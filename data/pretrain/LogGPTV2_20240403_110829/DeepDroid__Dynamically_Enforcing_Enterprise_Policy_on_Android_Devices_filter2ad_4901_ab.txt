ing. However, an App may have multiple ways to bypass
it using normal Android APIs. To solve this problem, we
can extend DeepDroid with a behavior detection model
similar to what has been proposed in FireDroid [14].
D. Native Code Context Enforcement
The process creation guard in Section V-B constrains
the access privileges of native operations with a course-
grained Granted or Denied decision; however, enterprises
may request a more ﬁne-grained control on native op-
erations. For instance, instead of disconnecting an app
completely from the Internet, the app may be allowed
to access some speciﬁc trusted web servers. Therefore,
besides conﬁguring inet group, we develop a native
code context enforcement module to regulate network
accessing operations by conﬁning the context of socket
calls, such as connect, recvfrom and sendto.
is important
We trace system calls of the target process to con-
strain its native behaviors. Since it
to
guarantee that the tracing code is executed before any
operation of target process, we must detect the launching
of the target process and monitor the process through
its entire life cycle. To achieve this goal, we trace fork
calls of the processes (e.g., zygote, adbd) that are in
charging of new app process creation and then map
newly created processes to applications by matching
their uid. Once the target app is identiﬁed, system calls
of its process tree are traced recursively by setting
ptrace options including TRACEFORK, TRACEVFORK
and TRACECLONE. Since our module works as a tracer
on a target process, when the target process is attached
successfully, the tracer can receive signals at both the
entry and exit of system calls, and meanwhile the target
process is suspended after entering syscall-enter-stop
and syscall-exit-stop. We maintain a ﬂag for each target
process to distinguish its system call entries from system
call exits. In a typical work ﬂow, this module ﬁrst uses
ptrace to extract CPU register information of a suspended
target. According to routines of ARM Procedure Call
Standard [15], the parameters of system calls are stored
in registers R0∼R3 and SP, and the result of a system
call is always stored in register R0. Therefore, our traces
can easily parse the parameters and return value of the
system calls. According to the policy rules, we can either
simply decline a resource access request or send a fake
return value.
Again, our work focuses on providing a mechanism
to support native code context enforcement, instead of
designing detailed policy rules. For various applications,
different parsers may be required to inspect their unique
context information. For instance, to restrict datagram
communication with a certain remote server, we need
to regulate system calls like sendto, sendmsg, recvmsg
and recvfrom. At the entry of sendto, the destination
address is extracted from sockaddr structure. Then, the
system calls can go through if the destination address
is valid or be stopped otherwise. Similarly, at the exit
of recvfrom, we can recognize received buffer data and
mask its content accordingly.
VI. DEEPDROID EVALUATION
Our goal of DeepDroid evaluation is threefold: (1) to
demonstrate that security policies on resource accessing
can be effectively enforced; (2) to demonstrate that
DeepDroid can be easily deployed to various Android
platforms, and (3) to measure its performance overhead.
We also analyze security and reliability of DeepDroid.
A. Functional Evaluation
To test the effectiveness of DeepDroid, we choose
the prevalent resources of Android identiﬁed in [13]
9
TABLE III: Tested Resources
Resource
Permission
Group
IMEI
Phone #
location
contacts
camera
account
logs
network
SMS/MMS message
READ PHONE STATE
READ PHONE STATE
ACCESS FINE LOCATION
READ CONTACTS
CAMERA
GET ACCOUNTS
READ LOGS
SEND SMS
INTERNET
camera
log
inet
PEP1
package
package
package
package
package
PCG
package
package/PCG
package/PCG
Result2
√
√
√
√
√
√
√
√
√
1 PEP is the policy enforcement point.
2 The policy is enforced either in package service or by Process Creation Guard (PCG).
and run a number of popular apps that access these
resources. For each resource, 5 most widely used apps
that access this resource are chosen from Google Play. In
our experiment, we manually instrument each resource
related method call to check if the operations can be
successfully regulated when we activate DeepDroid to
prohibit accessing this resource. Table III shows the e-
valuation results, which verify that all resource accessing
operations are controlled effectively.
B. Portability Evaluation
We run DeepDroid on a series of smart phones
with Android OS from version 2.3 to 4.x. As Table IV
summarizes, DeepDroid can be successfully deployed on
mainstream commercial Android devices with very small
system modiﬁcation.
1) Permission Enforcement Overhead: Permission en-
forcement overhead is mainly introduced by Permission
Conﬁgurator in the system server and behavior moni-
toring from binder interception. Permission Conﬁgurator
overrules system original permission checking procedure
with enterprise permission rules, and the Binder wrapper
parses the binder messages to perform app’s behavior
monitoring.
Since most benchmarks focus on overhead of the
entire process or the whole system, we need to design a
mechanism to benchmark the overhead of permission en-
forcement operations. To minimize measurement errors,
we choose sensitive operations that do not depend on a
certain hardware module or volatile surroundings (e.g.,
stability of network signal). As shown in Table V, we
construct a test case from a subset of prevalent resources
described in [13].
TABLE IV: DeepDroid Portability
TABLE V: Tested Permission Checking Transactions
Device
Nexus S(Samsung)
Sony LT29i
Galaxy Nexus(Samsung)
Samsung Galaxy Note II
Samsung Galaxy Note 3
Nexus 5(LG)
Meizu MX II
HUAWEI Honor 3c
Android
Android OS 2.3.6
Android OS 4.1.2
Android OS 4.2.2
Android OS 4.0
Android OS 4.1
Android OS 4.3
Android OS 4.4
Flyme 3.21
Android OS 4.2
Result
√
√
√
√
√
√
√
√
√
1 Flyme 3.2 is a customized version of Android OS 4.2.1
C. Performance Evaluation
DeepDroid’s system overhead is mainly introduced
by the operations on permission enforcement, binder
message interception, and system call tracing. Since a
permission checking is always accompanied by a binder
transaction, we combine the ﬁrst two overhead factors.
10
Class
phone state
contacts
SMS
messages
Permission
android.permission.
READ PHONE STATE
android.permission.
READ CONTACTS
android.permission.
SEND SMS
Trigger Point
TelephonyManager.
getDeviceId
ContentResolver.
SmsManager.
sendTextMessage
query(Phone.CONTENT URI...)
We evaluate the performance by initiating resource
access operations that require a permission checking
procedure in the following scenarios.
• Normal mode (S). The tested apps are granted re-
quired permissions by original permission mechanism
and the trigger points are executed successfully.
• Intercepted mode (S). The tested apps are granted
required permissions by Permission Conﬁgurator and
the trigger points are intercepted and monitored by the
binder.
• Normal mode (F). The tested apps are denied required
D. Security Analysis
Our system can ensure an enterprise security policy
enforcement on Android device through dynamic mem-
ory instrumentation of several critical system processes.
Malicious apps. DeepDroid may allow device users
to install their favorite apps on their Android smart-
phones. Some apps may be malicious and target at com-
promising our policy enforcement mechanism. However,
since the user-level malicious processes are securely
isolated into separate containers, they cannot manipulate
the code or the control ﬂow of DeepDroid unless they
have the root privilege, which is strictly protected and
monitored by enterprise administrators. We assume the
Android OS can be trusted. Therefore, without the root
privilege, malicious apps cannot compromise our mech-
anism.
Permission escalation attacks. An Android system
may suffer from permission escalation attacks, such as
confused deputy attack and collusion attack [18], [19],
[20]. In confused deputy attack, a malicious application
exploits the vulnerable interfaces of another privileged
(but confused) application to perform unauthorized op-
erations. This kind of attack usually happens when a
privileged app unintentionally exposes interfaces of sen-
sitive operation to an app without required permissions.
In collusion attack, malicious apps collude and combine
their permissions in order to perform actions beyond their
individual privileges. DeepDroid can be used to regulate
two apps’ communications that go through the binder
and system calls; however, if two apps may communicate
through some covert channels that are out of the control
of DeepDroid, we need to deploy other mechanisms to
help remove the covert channels.
Uncooperative user. Some employees may be re-
luctant to conform to enterprise’s security policies due
to various reasons, and they may simply deactivate our
system. Therefore, it is critical to guarantee that Deep-
Droid is correctly running on employees’ mobile devices,
and we use heartbeat messages to prove it. Therefore,
a mobile device that stops sending encrypted heartbeat
messages will trigger further investigation. Moreover, we
can use software based attestation approach [21], [22],
[23] to make sure the integrity of DeepDroid. On the
mobile platforms with TrustZone hardware support [24],
we can also use TrustZone to keep monitoring the
integrity of DeepDroid, similar to what has been done
in Knox [9].
DeepDroid misuse. An attacker may impersonate the
enterprise administrators to send false policy rules to the
mobile devices; however, since the attacker cannot obtain
the keying material shared between the device and the
enterprise server, it cannot perform this type of attacks.
DeepDroid exposes one control
interface of Android
system to third parties; however, since the code base of
DeepDroid is small and may be formally veriﬁed, the
attacker can hardly misuse our mechanism to attack the
system. Moreover, since all the communications between
the trusted enterprise server and the mobile device are
protected by a shared secret key, an external attacker
cannot steal the policy rules through eavesdropping.
VII. DISCUSSION
At Google I/O 2014 conference, Android L was un-
veiled and the previously experimental Android Runtime
(ART) [25] has replaced Dalvik as a default environment.
ART compiles byte code into executable ELF only once
during app installation. In spite of the runtime transfor-
mation, foundations of DeepDroid, including permission
mechanism, system service architecture, and binder IPC,
are barely changed. In other words, DeepDroid can
be easily ported to ART. Only the implementation of
runtime method interception in section V-A needs to be
changed accordingly. In ART, the .oat executable ﬁle
compiled from Java byte code is mapped into process by
calling dlopen function, and all Methods refer to their
native code in oatexec segment of .oat. ART runtime
method interception can be achieved by native code
inline-hooking. Hence, DeepDroid can also work on
ART-enabled devices with little modiﬁcation.
DeepDroid requires root privilege for installation.
This requirement is common among enterprise mobile
management solutions, and usually the root privilege can
be obtained from OEMs. With OEM support, DeepDroid
installation is simple and straightforward. OEMs only
need to modify the “init.rc” ﬁle and import DeepDroid as
a service. Then DeepDroid can run with a root privilege
and all other Android security features remain intact.
Since DeepDroid does not change the framework and
the kernel of Android system, the above conﬁguration
incurs very little impact on OEMs. Some other work
such as FireDroid [14] adopts a similar idea to obtain
root privilege from OEMs. Alternatively, with the support
of ARM TrustZone mechanism [24], DeepDroid may
use the secure domain for the installation in the normal
domain.
There exists a number of system access control solu-
tions for enterprise management, but our solution has
12
some advantages when comparing to those solutions,
particularly, SELinux [26] and Knox [9]. SEAndroid
enforces mandatory access control (MAC) in Android
kernel. Android’s support for SELinux has evolved from
permissive in 4.3 to full enforcement in 5.0 (L). SELinux
enhances system security by conﬁning privileged pro-
cesses and enforce policies on various domains. How-
ever, it is unavailable or disabled by default on Android
versions older than 4.4. Thus, old devices cannot be well
protected by SEAndroid. Moreover, it requires manufac-
turers to have a better understanding of SELinux im-
plementations. Until now, SEAndroid has not been fully
supported since Android 5.0 does not include middleware
MAC mechanism [5]. On the contrary, DeepDroid does
not rely on any unique kernel features and thus works
well on almost all Android versions and platforms. We
may enhance the security of DeepDroid with SEAndroid