title:Optimal Resilience for Erasure-Coded Byzantine Distributed Storage
author:Christian Cachin and
Stefano Tessaro
Optimal Resilience for Erasure-Coded Byzantine Distributed Storage
Christian Cachin
IBM Research
Stefano Tessaro
ETH Zurich
Zurich Research Laboratory
CH-8803 R¨uschlikon, Switzerland
Department of Computer Science
CH-8092 Zurich, Switzerland
PI:EMAIL
PI:EMAIL
Abstract
We analyze the problem of efﬁciently storing large amounts
of data on a distributed set of servers that may be ac-
cessed concurrently from multiple clients by sending mes-
sages over an asynchronous network. Up to one third of the
servers and an arbitrary number of clients may be faulty
and exhibit Byzantine behavior. We provide the ﬁrst simula-
tion of a multiple-writer multiple-reader atomic read/write
register using erasure-coding in this setting that achieves
optimal resilience and minimal storage overhead. Addition-
ally, we give the ﬁrst implementation of non-skipping times-
tamps which provides optimal resilience and withstands
Byzantine clients; it is based on threshold cryptography.
1. Introduction
Recent advances in the development of networked stor-
age systems, such as Network-Attached Storage (NAS),
Object Storage [5], and Storage-Area Networks (SAN),
combined with the increasing availability of fast networks,
have made it very attractive to store large amounts of infor-
mation in a distributed storage system. Such systems may
use replication in order to enhance their security and fault-
tolerance.
We consider a set of  servers, implementing the stor-
age system itself, and a possibly unbounded set of clients,
accessing the storage system for reading and writing data.
Servers and clients communicate by exchanging messages
over a fully connected asynchronous network. This model
is suitable for heterogeneous and wide-area networks, and,
furthermore, avoids timing assumptions, which may other-
wise become a vulnerability of the system. These servers
are subject to failures, and the system has to be designed in
order to tolerate them. Moreover, we do not want to limit
ourselves to “benign” crashes of the parties, i.e., servers and
clients, because a malicious entity might take control over
some of them and launch a coordinated attack. For this rea-
son, we consider Byzantine failures and assume that up to
 servers and any number of clients may deviate from the
protocol in an arbitrary way.
A distributed storage system needs to handle concurrent
access by clients. A good abstraction for a concurrent stor-
age system is a multiple-writer multiple-reader read/write
register [19]. Such a register is a shared object which can
be used by many clients in order to store and retrieve a
value. A block storage system can be modeled as an ar-
ray of these registers. Thus, the problem of implementing
a storage system can be formalized as the problem of sim-
ulating a multiple-writer multiple-reader read/write register
by the servers. Despite the simplicity of such a register, it
is not immediately clear how it should behave if accessed
concurrently. Lamport [19] has introduced three types of
consistency conditions for registers: safety, regularity, and
atomicity. Atomicity is the strongest one, requiring every
execution to appear sequential, and it is the one considered
here.
Previous fault-tolerant simulations of registers in a
message-passing environment are based on replication [4,
21, 23, 6], where each server keeps a complete copy of the
data. Our approach wastes less resources and it is based
on information dispersal [24] and erasure coding. Here,
the data is split into blocks such that each server stores ex-
actly one block, and the information stored at the non-faulty
servers is enough to reconstruct the original data. But deal-
ing with faulty servers and with faulty clients is more com-
plicated than in replication-based storage, because the data
representation must be more tightly integrated with the syn-
chronization protocol.
Some defense mechanisms for mitigating the problems
caused by Byzantine failures are known as well [18, 15],
but only the recent protocol of Goodson et al. [16] supports
concurrent access to the stored data and tolerates faulty
clients. Their solution still allows malicious clients to write
inconsistent data to the servers, and recovering from such
inconsistent writes might be expensive. On the other hand,
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:29:21 UTC from IEEE Xplore.  Restrictions apply. 
Cachin and Tessaro [10] deﬁne veriﬁable information dis-
persal, where the servers validate the consistency of data at
write time and reject inconsistent writes. However, Cachin
and Tessaro [10] do not address concurrent updates.
In this paper, we present a new fault-tolerant simula-
tion of an atomic register using erasure coding for data
that is not self-verifying [23]. We give a deﬁnition of
an atomic register simulation protocol in an asynchronous
message-passing model, where both servers and clients
are subject to Byzantine faults. Our protocol is the ﬁrst
distributed erasure-coded simulation of a multiple-writer
multiple-reader read/write register that provides atomic se-
mantics and optimal resilience in this model.
In other
words, our solution tolerates the failure of up to one third
of the servers and of an arbitrary number of clients [23],
and requires a minimal amount of extra storage space for
erasure coding.
The protocol follows the “listeners’ pattern” proposed
by Martin et al. [23], but uses asynchronous veriﬁable in-
formation dispersal [10] and asynchronous reliable broad-
cast for tolerating Byzantine clients. Our protocol improves
the storage and communication efﬁciencies of Martin et
al.’s replication-based protocol for the simulation of atomic
registers [23] and improves the resilience and the storage
complexity of Goodson et al.’s solution for erasure-encoded
storage [16]. Like some of the previous work, our protocol
uses interaction among the servers.
The challenge with using erasure coding in the concur-
rent setting is that no server stores the entire data, and in
order to read correctly, a client must receive data blocks be-
longing to the same data item from multiple servers. A pos-
sible way for keeping track of multiple concurrently writ-
ten versions of the data is provided by (logical) timestamps:
Whenever a new data item is written, it receives a higher
timestamp. Malicious parties, however, may be able to
mount a denial-of-service attack by making timestamps ar-
bitrarily large. Bazzi and Ding [6] considered this problem
and solved it by introducing so-called non-skipping times-
tamps, where the value of every timestamp is bounded by
the number of writes that have been executed previously in
the system and where no timestamp value can be “skipped.”
We provide an improved implementation of non-skipping
timestamps based on threshold signatures that withstands
the Byzantine failure of clients and of up to one third of the
servers. Our solution uses cryptographic digital signatures,
but key management is very simple: We require the single
public key of the service to be stored at the clients and no
client keys are kept at the servers.
1.1. Related work
not address protocol aspects for implementing IDA in dis-
tributed systems. IDA is extended by Krawczyk [18] using
a technique called distributed ﬁngerprinting in order to en-
sure the integrity of data in case of alterations of the stored
blocks by malicious servers. The same idea is subsequently
improved by Alon et al. [3]. Furthermore, Garay et al. [15]
propose an information dispersal scheme for synchronous
networks that tolerates Byzantine server failures. Their
model does not allow Byzantine clients, even though some
attacks are tolerated. Because of its inherent synchrony,
this protocol cannot be translated to an asynchronous net-
work. Asynchronous information dispersal protocols that
tolerate only crash failures have recently received more at-
tention [14, 2].
A solution for erasure-coded storage in an asynchronous
network with robustness against Byzantine servers and
clients has been proposed by Goodson et al. [16]. Their
scheme provides atomic semantics and is able to detect in-
consistently written data only at read-time; the content of
the storage system must then be rolled back to the last cor-
rectly written state. Abd-El-Malek et al. [1] recently pro-
posed an improvement of this scheme to shift the veriﬁca-
tion work from the read-time to earlier periods, when the
system is idle. However, retrieving data can still be inefﬁ-
cient in the case of several faulty write operations, and both
protocols require  (cid:2)  (cid:3)(cid:0).
Cachin and Tessaro [10] introduce the concept of ver-
iﬁable information dispersal in asynchronous networks,
which guarantees that, once a storage operation has been
accepted by the servers, the data is stored consistently. This
is analogous to veriﬁability in secret sharing [13]. However,
the question of concurrent access to data is not addressed.
Many simulations of read/write registers in the message-
passing model based on replication have been given, most
of them considering only a bounded number of client pro-
cesses or being restricted to crash failures (see e.g. the work
of Attiya et al. [4]). Phalanx [21] is a practical system for
survivable coordination that also provides a simulation of
safe read/write registers based on replication and tolerates
Byzantine failures of both clients and  (cid:2)  (cid:3)(cid:0) servers.