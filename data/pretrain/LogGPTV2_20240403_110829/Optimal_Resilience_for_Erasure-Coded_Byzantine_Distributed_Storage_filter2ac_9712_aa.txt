# Optimal Resilience for Erasure-Coded Byzantine Distributed Storage

**Authors:**
- Christian Cachin, IBM Research, Zurich Research Laboratory, CH-8803 RÃ¼schlikon, Switzerland
- Stefano Tessaro, ETH Zurich, Department of Computer Science, CH-8092 Zurich, Switzerland

**Contact:**
- Email: [PI:EMAIL] (for both authors)

## Abstract
We address the challenge of efficiently storing large volumes of data on a distributed set of servers that can be concurrently accessed by multiple clients over an asynchronous network. Up to one-third of the servers and any number of clients may exhibit Byzantine behavior. We present the first simulation of a multiple-writer, multiple-reader atomic read/write register using erasure coding in this setting, achieving optimal resilience and minimal storage overhead. Additionally, we introduce the first implementation of non-skipping timestamps, which provides optimal resilience and withstands Byzantine clients, based on threshold cryptography.

## 1. Introduction
Recent advancements in networked storage systems, such as Network-Attached Storage (NAS), Object Storage, and Storage-Area Networks (SAN), combined with the increasing availability of fast networks, have made it highly attractive to store large amounts of information in distributed storage systems. These systems often use replication to enhance security and fault tolerance.

In this paper, we consider a set of \( n \) servers implementing the storage system and a potentially unbounded set of clients accessing the system for reading and writing data. Communication between servers and clients occurs over a fully connected, asynchronous network. This model is suitable for heterogeneous and wide-area networks and avoids timing assumptions, which could otherwise become a vulnerability. The servers are subject to failures, and the system must be designed to tolerate them. Moreover, we consider Byzantine failures, assuming that up to \( f \) servers and any number of clients may deviate from the protocol in arbitrary ways.

A distributed storage system needs to handle concurrent access by clients. A good abstraction for such a system is a multiple-writer, multiple-reader read/write register. Such a register is a shared object that allows many clients to store and retrieve a value. A block storage system can be modeled as an array of these registers. The problem of implementing a storage system can thus be formalized as simulating a multiple-writer, multiple-reader read/write register by the servers. Despite its simplicity, it is not immediately clear how such a register should behave under concurrent access. Lamport introduced three types of consistency conditions for registers: safety, regularity, and atomicity. Atomicity, the strongest condition, requires every execution to appear sequential, and it is the one considered here.

Previous fault-tolerant simulations of registers in a message-passing environment have been based on replication, where each server keeps a complete copy of the data. Our approach, based on information dispersal and erasure coding, is more resource-efficient. In this method, the data is split into blocks, with each server storing exactly one block. The information stored at the non-faulty servers is sufficient to reconstruct the original data. However, dealing with faulty servers and clients is more complex than in replication-based storage, as the data representation must be tightly integrated with the synchronization protocol.

Some defense mechanisms for mitigating Byzantine failures are known, but only the recent protocol by Goodson et al. supports concurrent access to the stored data and tolerates faulty clients. Their solution still allows malicious clients to write inconsistent data, and recovering from such writes can be expensive. On the other hand, Cachin and Tessaro define verifiable information dispersal, where servers validate the consistency of data at write time and reject inconsistent writes, but they do not address concurrent updates.

In this paper, we present a new fault-tolerant simulation of an atomic register using erasure coding for data that is not self-verifying. We provide a definition of an atomic register simulation protocol in an asynchronous message-passing model, where both servers and clients are subject to Byzantine faults. Our protocol is the first distributed erasure-coded simulation of a multiple-writer, multiple-reader read/write register that provides atomic semantics and optimal resilience. Specifically, our solution tolerates the failure of up to one-third of the servers and an arbitrary number of clients, requiring minimal extra storage space for erasure coding.

The protocol follows the "listeners' pattern" proposed by Martin et al. but uses asynchronous verifiable information dispersal and asynchronous reliable broadcast to tolerate Byzantine clients. Our protocol improves the storage and communication efficiency of Martin et al.'s replication-based protocol and enhances the resilience and storage complexity of Goodson et al.'s solution for erasure-encoded storage. Like some previous work, our protocol uses interaction among the servers.

The challenge with using erasure coding in a concurrent setting is that no server stores the entire data, and to read correctly, a client must receive data blocks belonging to the same data item from multiple servers. A possible way to keep track of multiple concurrently written versions of the data is through logical timestamps. Malicious parties may mount denial-of-service attacks by making timestamps arbitrarily large. Bazzi and Ding addressed this issue by introducing non-skipping timestamps, where the value of every timestamp is bounded by the number of previous writes and no timestamp value can be skipped. We provide an improved implementation of non-skipping timestamps based on threshold signatures, which withstands Byzantine failures of clients and up to one-third of the servers. Our solution uses cryptographic digital signatures, but key management is simple: we require only the single public key of the service to be stored at the clients, and no client keys are kept at the servers.

### 1.1. Related Work
Rabin's Information Dispersal Algorithm (IDA) does not address protocol aspects for implementing IDA in distributed systems. Krawczyk extended IDA using distributed fingerprinting to ensure data integrity against alterations by malicious servers. Alon et al. subsequently improved this idea. Garay et al. proposed an information dispersal scheme for synchronous networks that tolerates Byzantine server failures but does not allow Byzantine clients. Due to its inherent synchrony, this protocol cannot be translated to an asynchronous network. Asynchronous information dispersal protocols that tolerate only crash failures have received more attention recently.

Goodson et al. proposed a solution for erasure-coded storage in an asynchronous network with robustness against Byzantine servers and clients. Their scheme provides atomic semantics and detects inconsistently written data at read-time, rolling back the content to the last correctly written state. Abd-El-Malek et al. improved this scheme to shift verification work from read-time to idle periods, but retrieving data can still be inefficient with several faulty write operations, and both protocols require \( f < n/3 \).

Cachin and Tessaro introduced verifiable information dispersal in asynchronous networks, ensuring consistent data storage once a storage operation is accepted by the servers. However, they did not address concurrent access to data. Many simulations of read/write registers in the message-passing model based on replication have been given, most considering only a bounded number of client processes or being restricted to crash failures. Phalanx is a practical system for survivable coordination that provides a simulation of safe read/write registers based on replication and tolerates Byzantine failures of both clients and \( f < n/3 \) servers.