## 常用头字段HTTP协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：1.  通用字段：在请求头和响应头里都可以出现；2.  请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；3.  响应字段：仅能出现在响应头里，补充说明响应报文的信息；4.  实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。对 HTTP报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了HTTP 报文。后续的课程中我将会以应用领域为切入点介绍连接管理、缓存控制等头字段，今天先讲几个最基本的头，看完了它们你就应该能够读懂大多数HTTP 报文了。首先要说的是**Host**字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个HTTP/1.1 规范里要求**必须出现**的字段，也就是说，如果请求头里没有Host，那这就是一个错误的报文。Host字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用Host 字段来选择，有点像是一个简单的"路由重定向"。例如我们的试验环境，在 127.0.0.1上有三个虚拟主机："www.chrono.com""www.metroid.net"和"origin.io"。那么当使用域名的方式访问时，就必须要用Host 字段来区分这三个 IP相同但域名不同的网站，否则服务器就会找不到合适的虚拟主机，无法处理。**User-Agent**是请求字段，只出现在请求头里。它使用一个字符串来描述发起HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。但由于历史的原因，User-Agent非常混乱，每个浏览器都自称是"Mozilla""Chrome""Safari"，企图使用这个字段来互相"伪装"，导致User-Agent 变得越来越长，最终变得毫无意义。不过有的比较"诚实"的爬虫会在 User-Agent里用"spider"标明自己是爬虫，所以可以利用这个字段实现简单的反爬虫策略。**Date**字段是一个通用字段，但通常出现在响应头里，表示 HTTP报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。**Server**字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供Web 服务的软件名称和版本号，例如在我们的实验环境里它就是"Server:openresty/1.15.8.1"，即使用的是 OpenResty 1.15.8.1。Server字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在bug，那么黑客就有可能利用 bug攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。比如 GitHub，它的 Server 字段里就看不出是使用了 Apache 还是Nginx，只是显示为"GitHub.com"。![](Images/4fa99a1eb3669c27123871a881bf9b44.png){savepage-src="https://static001.geekbang.org/resource/image/f1/1c/f1970aaecad58fb18938e262ea7f311c.png"}实体字段里要说的一个是**Content-Length**，它表示报文里 body的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么body 就是不定长的，需要使用 chunked 方式分段传输。
## 小结今天我们学习了 HTTP 的报文结构，下面做一个简单小结。1.  [HTTP 报文结构就像是"大头儿子"，由"起始行 + 头部 + 空行 +    实体"组成，简单地说就是"header+body"；]{.orange}2.  [HTTP 报文可以没有 body，但必须要有 header，而且 header    后也必须要有空行，形象地说就是"大头"必须要带着"脖子"；]{.orange}3.  [请求头由"请求行 + 头部字段"构成，响应头由"状态行 +    头部字段"构成；]{.orange}4.  [请求行有三部分：请求方法，请求目标和版本号；]{.orange}5.  [状态行也有三部分：版本号，状态码和原因字符串；]{.orange}6.  [头部字段是 key-value    的形式，用":"分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展；]{.orange}7.  [HTTP/1.1 里唯一要求必须提供的头字段是    Host，它必须出现在请求头里，标记虚拟主机名。]{.orange}
## 课下作业1.  如果拼 HTTP 报文的时候，在头字段后多加了一个    CRLF，导致出现了一个空行，会发生什么？2.  讲头字段时说":"后的空格可以有多个，那为什么绝大多数情况下都只使用一个空格呢？欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。![unpreview](Images/ef4039b8339061228105ddc8e0816541.png){savepage-src="https://static001.geekbang.org/resource/image/1a/26/1aa9cb1a1d637e10340451d81e87fc26.png"}![unpreview](Images/4913a489805db29b38aefa585223c013.png){savepage-src="https://static001.geekbang.org/resource/image/56/63/56d766fc04654a31536f554b8bde7b63.jpg"}
# 10 \| 应该如何理解请求方法？上一讲我介绍了 HTTP 的报文结构，它是由 header+body构成，请求头里有请求方法和请求目标，响应头里有状态码和原因短语，今天要说的就是请求头里的请求方法。
## 标准请求方法HTTP 协议里为什么要有"请求方法"这个东西呢？这就要从 HTTP 协议设计时的定位说起了。还记得吗？蒂姆·伯纳斯 -李最初设想的是要用 HTTP 协议构建一个超链接文档系统，使用 URI来定位这些文档，也就是资源。那么，该怎么在协议里操作这些资源呢？很显然，需要有某种"动作的指示"，告诉操作这些资源的方式。所以，就这么出现了"请求方法"。它的实际含义就是客户端发出了一个"动作指令"，要求服务器端对URI 定位的资源执行这个动作。目前 HTTP/1.1规定了八种方法，单词**都必须是大写的形式**，我先简单地列把它们列出来，后面再详细讲解。1.  GET：获取资源，可以理解为读取或者下载数据；2.  HEAD：获取资源的元信息；3.  POST：向资源提交数据，相当于写入或上传数据；4.  PUT：类似 POST；5.  DELETE：删除资源；6.  CONNECT：建立特殊的连接隧道；7.  OPTIONS：列出可对资源实行的方法；8.  TRACE：追踪请求 - 响应的传输路径。![](Images/bbfd6424a5dfbf00b0d25ffc6f0d35a0.png){savepage-src="https://static001.geekbang.org/resource/image/3c/6d/3cdc8ac71b80929f4a94dfeb9ffe4b6d.jpg"}看看这些方法，是不是有点像对文件或数据库的"增删改查"操作，只不过这些动作操作的目标不是本地资源，而是远程服务器上的资源，所以只能由客户端"请求"或者"指示"服务器来完成。``{=html}既然请求方法是一个"指示"，那么客户端自然就没有决定权，服务器掌控着所有资源，也就有绝对的决策权力。它收到HTTP请求报文后，看到里面的请求方法，可以执行也可以拒绝，或者改变动作的含义，毕竟HTTP 是一个"协议"，两边都要"商量着来"。比如，你发起了一个 GET请求，想获取"/orders"这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：1.  假装这个文件不存在，直接返回一个 404 Not found 报文；2.  稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403    Forbidden；3.  再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用    HEAD 方法获取文件的元信息。
## GET/HEAD虽然 HTTP/1.1里规定了八种请求方法，但只有前四个是比较常用的，所以我们先来看一下这四个方法。**GET**方法应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的，自0.9 版出现并一直被保留至今，是名副其实的"元老"。它的含义是请求**从服务器获取资源**，这个资源既可以是静态的文本、页面、图片、视频，也可以是由PHP、Java 动态生成的页面或者其他格式的数据。GET 方法虽然基本动作比较简单，但搭配 URI和其他头字段就能实现对资源更精细的操作。例如，在 URI后使用"#"，就可以在获取页面后直接定位到某个标签所在的位置；使用If-Modified-Since字段就变成了"有条件的请求"，仅当资源被修改时才会执行获取动作；使用 Range字段就是"范围请求"，只获取资源的一部分数据。**HEAD**方法与 GET方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的"元信息"。HEAD 方法可以看做是 GET 方法的一个"简化版"或者"轻量版"。因为它的响应头与GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body数据的浪费。比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用HEAD，服务器会在响应头里把文件的修改时间传回来。你可以在实验环境里试一下这两个方法，运行 Telnet，分别向 URI"/10-1"发送GET 和 HEAD 请求，观察一下响应头是否一致。    GET /10-1 HTTP/1.1Host: www.chrono.com  HEAD /10-1 HTTP/1.1Host: www.chrono.com
## POST/PUT接下来要说的是**POST**和**PUT**方法，这两个方法也很像。GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，向URI 指定的资源提交数据，数据就放在报文的 body 里。POST 也是一个经常用到的请求方法，使用频率应该是仅次于GET，应用的场景也非常多，只要向服务器发送数据，用的大多数都是 POST。比如，你上论坛灌水，敲了一堆字后点击"发帖"按钮，浏览器就执行了一次 POST请求，把你的文字放进报文的 body 里，然后拼好 POST 请求头，通过 TCP协议发给服务器。又比如，你上购物网站，看到了一件心仪的商品，点击"加入购物车"，这时也会有POST 请求，浏览器会把商品 ID 发给服务器，服务器再把 ID写入你的购物车相关的数据库记录。PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST存在微妙的不同，通常 POST 表示的是"新建""create"的含义，而 PUT则是"修改""update"的含义。在实际应用中，PUT 用到的比较少。而且，因为它与 POST的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST方法上传数据。实验环境的"/10-2"模拟了 POST 和 PUT 方法的处理过程，你仍然可以用 Telnet发送测试请求，看看运行的效果。注意，在发送请求时，头字段"Content-Length"一定要写对，是空行后body 的长度：    POST /10-2 HTTP/1.1Host: www.chrono.comContent-Length: 17 POST DATA IS HERE PUT /10-2 HTTP/1.1Host: www.chrono.comContent-Length: 16 PUT DATA IS HE
## 其他方法讲完了GET/HEAD/POST/PUT，还剩下四个标准请求方法，它们属于比较"冷僻"的方法，应用的不是很多。**DELETE**方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理DELETE 请求。**CONNECT**是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时Web 服务器在中间充当了代理的角色。**OPTIONS**方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow字段里返回。它的功能很有限，用处也不大，有的服务器（例如Nginx）干脆就没有实现对它的支持。**TRACE**方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 -响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web服务器通常也是禁止使用。