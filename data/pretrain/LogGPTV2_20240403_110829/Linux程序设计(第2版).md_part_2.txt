我们在编写这本书的时候使用的是基于英特尔公司CPU芯片的系统，但我们讨论的内容很
少是只适用于英特尔芯片的。虽然在一台只有2MB内存且没有硬盘的386机器上运行Linux也是
可能的（确实可以运行），但要想成功地运行Linux并试验书中的程序示例，我们推荐至少要有
以下的配置：
·奔腾级处理器。
·32MB内存。
·600MB可用硬盘空间，并且最好是在同一个分区里。
·如果想运行X窗口系统，还需要有一块它支持的显卡。
X窗L系统所支持的显卡的资料可以在http://wwwxfrcc86.org/网址处查到：
运行本书大部分章节中的代码所需要的硬件配置其实是相当小的，只有涉及X窗口系统的有
关章节才需要比较强大的配置（或更多的耐心）！
我们便用了两台不同配置的Linux系统来编写本书的内容和开发那些程序示例，因此我们确
信只要Linux能够运行在你的机器上，你就可以顺利地完成本书的学习。另外，在本书的技术校
对期间，我们在另外一个Linux版本上完成了全部代码的测试工作。
加入jaVa编程群：524621833
---
## Page 10
VII
在软件要求方面需要提醒读者注意的是，程序示例中有一小部分需要比较新的Linux内核版
本，即2.2或更高版本才能顺利运行。Java开发工具包（JavaDevelopmentKit）要求使用最新版
本的GCC和C语言库（glibc2或更高）。至于其他工具软件，最好的办法是设法获得它们最新的
版本。比如说，Tcl和Tk章节中的程序示例分别需要在7.5和8.0版本以上才能顺利运行。我们会
在必要时提醒大家注意最低配置要求，如渠读者在代码运行方面遇到了麻烦，使用比较新一些
的工具可能会有所帮助。好在所有这些软件工具都可以很方便地下载到，而且，我们在附录C里
已经准备了一份因特网资源指南以帮助读者找到它们。如果读者使用的是最近推出的Linux发行
版本，就应该不会遇到什么问题。
因为Linux、GNU工具包以及其他软件都是在GPL版权规定下发行的，所以它们是有-些特
点的，其中之一就是所谓的“自由性”。它们的源代码永远是公开的，任何人都不能抹杀这种自
由性。因此，它们也都是一些“源代码开放”软件，“源代码开放软件”这个术语的含义要比
“自由软件”的含义宽一些，因为有些专利软件在某种规定的条件下也会提供其源代码。在
GNU/Linux世界里，你永远能够得到技术支持一一你可以自己动手修改源代码，也可以雇佣其他
人。目前，为Linux及其相关软件工具提供收费技术支持的公司正在不断增加。
实例代码
我们已经尽了最大的努力向读者提供能够最好地说明书中有关概念的示范性程序和代码段：
特别需要指出的是，我们并没有对我们调用过的每一个函数的返回值是否就是我们所预期
的进行检查。在真正的应用软件成品代码里我们当然会对函数的返回值进行检查，面读者也必
须这样做，因为只有这样才能为程序的错误处理提供一个有效的手段。我们在书中的第3章里介
绍了一些捕获和处理程序错误的办法。
本书所有程序代码都可以从下面这个网址下载到：
一
http://www.wrox.com
书中的所有代码都遵守GNU的公共许可证（GNUPublicLicense）。我们建议读者下载一份
全部程序代码的拷贝，这样可以节省你不少的打字时间。
体例
下一些编写体例。
书中的文字框里是一些重要的，不应该被忘记的内客。它们与其周边的内容息息相
关，就像电影《课中谋》中特工们准备窈取的关键资料。
代码部分与我们准备介绍学习的代码区分开，并且让它们在书中的内容里更加明显，让读者看
清楚应用程序的编写进度。在重要的场合，我们还会在代码部分的后面加上一个“操作注释”
来解释与前面理论有关的代码中容易被混滑的关键之处。我们发现这两个标记能够把比较难于
理解的代码清单分解为相对简单的部分。
加入jaVa编程群：524621833
/
---
## Page 11
VIII
告诉我们你的想法
我们已经努力使这本书正确而详尽，因此我们希望读者能够告诉我们本书就是你最想要和
最需要的，让我们能够得到一丝满足；也希望读者对我们这本书的编排方面多提宝贵意见。
我们欢迎对我们这份努力的反馈意见，不管是批评还是赞扬，我们都将在今后的编辑工作
中采纳。如果你有话要说，请按以下地址和我们联系：
PI:EMAIL
或者
http://www.wrox.com
现在就把这两个地址加到你的书签里去吧！
本书的英文书名为：BeginningLinux Programming.2nd Edition
英文书书号为：ISBN1-861002-97-1
加入jaVa编程群：524621833
---
## Page 12
目录
序言
2.3.2编写脚本程序
20
前言
2.3.3把脚本设置为可执行程序
第1章入门知识….
2.4shell程序设计的语法.
-.3
1.1什么是UNIX操作系统
2.4.1变量
.23
1.2什么是Linux操作系统...
2.4.2条件测试
1.3发行版本…
2.4.3控制结构
*1
.29
1.4GNU项目和自由软件基金会
2.4.4函数·
.39
1.5为Linux系统设计程序
..3
2.4.5命令
1.6UNIX程序
2.4.6命令的执行
1.7获得帮助
2.4.7即时文档
1.8程序开发系统的预备知识
2.4.8调试脚本程序
.57
1.8.1程序
2.5shell程序设计示例
.58
1.8.2头文件
2.5.1工作需求
1.8.3库文件
2.5.2设计
..58
1.8.4静态库
2.6本章总结
66
1.8.5共享库
/2
第3章如何使用和处理文件
*67
1.9UNIX系统中程序设计的特点和原则
13
3.1UNIX的文件结构
1.9.1简单性
3.1.1目录结构
1.9.2重点性
3.1.2 文件和设备
1.9.3可反复使用的程序组件.
3.2系统调用和设备驱动程序
1.9.4过滤器
33库函数
.0
1.9.5开放的文件格式
3.4文件的底层访问
.7
1.9.6灵活适应性
3.4.1write系统调用
.7.
1.10本章总结….
3.4.2read系统调用
...72
第2章shell程序设计
3.4.3opcn系统调用
.7.3
2.1什么是shel
.1
3.4.4访间权限的初始化值.
..74
2.2管道和重定向
3.4.5umask变量
*..75
2.2.1对输出数据进行重定向.
3.4.6cloe系统调用
22.2对输人数据进行重定向
41
.18
3.4.7iocu系统调用
3.4.8其他与文件管理有关的系统调用.78
2.3可以被视为程序设计语言的shel
3.5标准I/O库
80
2.3.1交互式程序
6-
3.5.1fopen函数...
8
加入java编程群
：524621833
---
## Page 13
X
3.5.2 fread函数
--82
4.6主机资料
..9
3.5.3 fwrite函数.
4.7日志记录功能
3.5.4 fclose函数
4.8资源和限制
-124
3.5.5 fflush函数
4.9本章总结
3.5.6 fseek函数
..83
第5章终端
.-/30
3.5.7fgetc、getc、getchar函数
5.1对终端进行读写
./.30
3.5.8 fputc、putc、putchat函数
5.1.1对重定向输出进行处理
3.5.9fgets.gets函数
......
5.1.2与终囊进行“对话”
--.34
3.5.10格式化输入和输出
5.2终端驱动程序和通用终端接口.1.36
3.5.11对数据流进行处理的其他函数
.8
5.2.1概述
-.36
3.5.12文件流错误处理
5.2.2硬件模型
3.5.13文件流和文件描述符的关系
90
5.3termios结构
/38
3.6文件和子目录的维护
5.3.1输人模式
3.6.1chmod系统调用
5.3.2输出模式
3.6.2chown系统调用
5.3.3控制模式
3.6.3unlink、link、symlink系统调用.….
5.3.4本地模式
.41
3.6.4mkdir和rmdir系统调用
.9/
5.3.5特殊的控制字符
3.6.5chdir系统调用和getcwd函数.9?
5.3.6终端的速度
3.7扫描子目录
5.3.7其他功能函数
3.7.1opendir函数
5.4终端的输出
148
3.7.2readdir函数
93
5.4.1终增的类型
·148
3.7.3 telldir函数
5.4.2确定终端类型的方法
.149
3.7.4 seekdir函数
5.4.3terminfo的使用方法
./51
3.7.5closodir函数
5.5检测键盘输入
3.8错误处理
96
5.6本章总结
3.9高级论题
.97
第6章curses孟数库
-/59
3.9.1 fenl系统调用
6.1使用curses函数库进行编译
159
3.9.2mmap函数
..98
6.2基本概念
.-/60
3.10本章总结
00