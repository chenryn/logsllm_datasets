ssize=（sizeof（caddr32_t）*nent）:
[3]
[...]
cbplist=kmem_alloc(ssize,KM_NOSLEEP)
[4]
if（cbplist==NULL）
return（ENOMEM):
if（copyin（aiocb.cbplist，ssize）){
error=EFAULT:
goto done;
[...]
if（aiop->aio_doneq）{
if（mode1==DATAMODEL_NATIVE）
ucbp=（aiocb_t**)cbplist;
---
## Page 33
24第一部分内核态
else
ucbp32=（caddr32_t*)cbp1ist:
[...]
for（i=0:irommaxrommax-CSRROMOFF+4;
if（crom_buf->len1en;
else
crom_buf->len=1en;
err=copyout(ptr,crom_buf->ptr,1en);
[4]
在[1]处的1en和crom_buf->len都是有符号整数类型，我们可以控制后者的值，因为
它在[2]处作为参数直接传递给ioctl。无论1en最开始被初始化为一个什么样的值，不管是
0还是一些较小的正值，当把crom_buf->1en设定为一个负值时，在[3]处的条件都会满足，
而在[4]处，copyout（）函数被调用，1en作为一个参数传递给了它，copyout（）函数的原型
如下：
int
copyout（constvoid*restrictkaddr,void*restrict
udaddr,size_t1en)—nonnull（1)_nonnu11（2);
这种情况下负值就会被认为是很大的正整数，而crom_buf->ptr指向用户区，这就会导致读
任意的内核内存。
随着2009年MacOSXSnowLeopard操作系统的发布，本书中涉及的所有操作系统
都支持x86-64位机器上的64位内核。这直接标示着x86-64位架构（在2003年由AMD提
出）在服务器市场及用户/消费者市场都有广泛的使用。我们将在第3章中详细探讨x86-
64位架构。
当然，考虑到要对以前版本操作系统软件的向前兼容，改变这些并不是那么容易，为了提
升功能，大多数编译器在32位代码中使用ILP32模型而在64位代码中使用LP64模型（我们
已经在“未初始化的/未验证的/被破坏的指针解引用”一节中），讨论了这些数据模型的含
义。这里要注意的是，所有的主流UNIX操作系统（Linux、Solaris、*BSDs等）和MacOSX
都使用LP64模型。唯一要注意的是Windows，它使用的是LLP64数据模型，其中long和int
类型的数据是32位的，而longlongs和指针类型的数据是64位的。
这些改变暴露了（有时具有安全含义）很多C程序员的不良习惯，大家都认为指针、整
数、长整数是一样大小的，因为在过去很长一段时间里，在32位架构是这样的。这是另一类
整数问题的普遍的来源，也是特别微妙的，因为这常常会影响一些已经正常运行了好多年的
程序（直到出现了64位的端口）。还有一个值得提及的问题是编译器通常在一些最常见的整
量中）。
---
## Page 35
26第一部分内核态
大体上讲，如果知道C、C++里面的数学计算规律和类型转换，整数问题很好理解。这类
如何转换。除了C99标准外，还有一个很好的能帮助理解这些规则和相关问题的参考，那就是
CERT安全编码标准。8
竞态条件
么一类情形，有两个或者两个以上执行者将要执行某一动作并且执行结果会由于它们执行顺序
的不同而完全不同。在谈到操作系统时，大多数情况下都不希望处于这种情形下：确定性是一
个很好的属性，尤其是对于系统的正确运行起决定作用的那些路径而言。
此类竞态条件要想发生，必须有多个竞争者同时执行任务，或者至少一个执行和另一个
执行是交错进行的。第一种情况是在对称多进程操作系统中特有的，因为有多CPU或多核，
就有多条不同的内核路径同时进行。第二种情况是单处理器系统中竞态条件发生的唯一可
能的情况。开始的任务以某种方式被中断而让第二个任务去执行。现在，这已经不是偶然
发生的情况了：现代内核中的很多部分都能够被抢占，这就意味能够中断它们在CPU中的
操作而去支持其他的进程。而且，内核路径（kernelpath）能够休眠，例如，等待内存分
则会执行。我们将在第3章中看到多调度程序的行为有多大的影响，以及如何增加“赢得”
竞争的可能性。
为了不让竞态条件发生，就必须在各种行动者之间保证某种同步性，比如在A任务完成前
保证B任务等待。事实上，在操作系统中，有许多同步机制能够实现各种内核任务/路径间的
协调，比如锁、信号量、条件变量等。但是这些同步机制都可能在实现的时候耗费资源。比如
锁，内核进程可以拥有一种排斥性的锁，拥有后，将排斥其他内核进程使用CPU，当然，如果此
进程占用锁太长时间，而对于这个锁又有很多争夺（即有太多的进程想占有该锁），那么就会影
响操作系统的效率。我们将在第3章和本书第二部分中提供对于这种情况更详细的分析。此外，
可以参考第1章最后的“相关阅读”部分，对这个话题进行更深人理解。
现在我们对竞态条件有了初步的认识，下面进行具体分析。正如已经知道的，竞态条件能
以及逻辑bug相结合时就会变得尤其难以发现），而且它就隐藏在那些讨厌的bug中，需要道
踪（以及复制再现）。几年来，竞态条件引发了许多耐人寻味的bug和内核级别上的漏洞利用，
在这一节的最后，我们将讨论Linux内核中页面错误处理程序的问题，而在这里，
我们先讨论一下另外一个典型的情景，关系到另外一个竞态条件，bug，也同样来源于
Linux内核。这个bug是内核与那些必须访问的用户区缓存（因此要拷贝到内核内存中）
交互的一个例子，这种情况经常发生在各种不同的内核中（当然也很可能将继续发生），下
面是具体的代码：
---
## Page 36
第2章内核漏洞分类
27
intcmsghdr_from_user_compat_to_kern(structmsghdr*kmsg,
unsignedchar*stackbuf,intstackbuf_size)
structcompat_cmsghdr_user*ucmsg;
struct cmsghdr*kcmsg,*kcmsg_base:
compat_size_tucmlen;
_kernel_size_tkcmlen,tmp;
kcmlen=0:
kcmsg_base=kcmsg=（structcmsghdr*)stackbuf:
[1]
[...]
while（ucmsg!=NULL）{
if(get_user(ucmlen,&ucmsg->cmsg_1en))
[2]
return-EFAULT:
/*Catchbogons.*/
if（CMSG_COMPAT_ALIGN(ucmlen)msg_contro1)+ucmlen)>kmsg->msg_contro11en)
[3]
return -EINVAL:
tmp=（（ucmlen-CMSG_COMPAT_ALIGN（sizeof（*ucmsg)))+
CMSG_ALIGN（sizeof（structcmsghdr))):
kcmlen+=tmp:
[4]
ucmsg=cmsg_compat_nxthdr（kmsg.ucmsg.ucmlen):
[...]
if（kcmlen>stackbuf_size)
[5]
kcmsg_base=kcmsg=kma1loc(kcmlen,GFP_KERNEL);
[...]
while（ucmsg!=NULL）{
_get_user(ucmlen,&ucmsg->cmsg_len);
[6]
tmp=（（ucmlen-CMSG_COMPAT_ALIGN（sizeof（*ucmsg))）+
CMSG_ALIGN(sizeof(structcmsghdr)));
kcmsg->cmsg_1en=tmp;
—get_user(kcmsg->cmsg_1evel,&ucmsg->cmsg_1eve1);
get_user(kcmsg->cmsg_type,&ucmsg->cmsg_type):
/*Copyoverthedata.*/
if(copy_from_user(CMSG_DATA(kcmsg).
[7]
CMSG_COMPAT_DATA(ucmSg),
(ucmlen-
CMSG_COMPAT_ALIGN(sizeof（*ucmsg)))))
gotoout_free_efault;
正如上面代码所示，一个用户空间的缓冲区的长度（ucmsg->cmsg_1en）在[2]处被拷贝
到内核地址空间中，在[6]处get_user（）函数又重复了这一操作。这个值随后又用来计算内
核空间缓冲区kcmsg的确切大小，kcmsg最初在[1]处（stackbuf只是一个指向分配的栈空
---
## Page 37
28第一部分内核态
间的指针，栈空间的大小是stackbuf_size）被存放在栈中。为了防止溢出，在[3]处会执行验
证。但是，在[5]处分配了精确的空间之后（不管之前分配的栈被使用了或是堆中的空间被保
留），在[6]处，这个长度值又一次拷贝并使用，却没有经过安全验证，最终在[7]处用来执行
最终的用户空间缓冲区的拷贝。
正常情况下这段代码运行得很好，可是如果在[2]和[6]两次get_user（）实例执行的间
隔中恰巧有另一个线程获得了CPU并且改变了用户区的一些值，那会发生什么呢？必然发生的
是，这个值可能会增长并导致内存溢出。这是竞态条件的一个例子，其中第一个执行者（内核
路径）试图执行一项动作（拷贝用户空间缓冲区），而第二个执行者试图在两次值（那些保存
了缓冲区大小的值）计算操作之间改变缓冲区的长度。之所以说这种bug是我们最喜欢的bug
之一，还有另外一个原因：它不仅展示了一个典型的竞态条件情况，而且能够随意地转化为堆
溢出或者栈溢出。实际上，分配缓冲区的方式取决于用户控制的ucmsg->cmsg_1en变量中的
第一个值。
在仔细考虑漏洞利用的细节之前，还有一件重要的事情需要指出：这类bug还是非常
容易利用的，单CPU系统也一样，只要想办法让某个内核控制路径被挂起（因此，就要
让出CPU）。当然并不是所有的内核函数/路径都能够强行进入这种情形，不过阅读完后
度）的函数通常可以做到这一点（例如，通过等待硬盘1/O，在被要求的页面已经被换出
的情况下）。
要讨论的第二个漏洞是Linux中影响页面错误处理程序的漏洞。您能在iSEC网站（www.
isec.pl）上找到关于这个问题的细节的讨论以及漏洞利用的方法；还有iSEC中其他一些内核公
vma=find_vma（mm,address）;
if（!vma)
[1]
gotobad_area;
if（vma->vm_startvm_f1ags&VM_GROWSDOWN))
[3]
gotobad_area;
if（error_code&4)
/*
*accessingthestackbelow.%espisalwaysabug.