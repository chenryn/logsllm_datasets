title:ROTE: Rollback Protection for Trusted Execution
author:Sinisa Matetic and
Mansoor Ahmed and
Kari Kostiainen and
Aritra Dhar and
David M. Sommer and
Arthur Gervais and
Ari Juels and
Srdjan Capkun
ROTE: Rollback Protection for Trusted Execution
Sinisa Matetic, Mansoor Ahmed, Kari Kostiainen, Aritra Dhar, David Sommer, and Arthur 
Gervais, ETH Zurich; Ari Juels, Cornell Tech; Srdjan Capkun, ETH Zurich
https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/matetic
This paper is included in the Proceedings of the 26th USENIX Security SymposiumAugust 16–18, 2017 • Vancouver, BC, CanadaISBN 978-1-931971-40-9Open access to the Proceedings of the 26th USENIX Security Symposium is sponsored by USENIXROTE: Rollback Protection for Trusted Execution
Sinisa Matetic
ETH Zurich
David Sommer
ETH Zurich
Mansoor Ahmed
ETH Zurich
Arthur Gervais
ETH Zurich
Kari Kostiainen
ETH Zurich
Ari Juels
Cornell Tech
Aritra Dhar
ETH Zurich
Srdjan Capkun
ETH Zurich
Abstract
Security architectures such as Intel SGX need protec-
tion against rollback attacks, where the adversary vio-
lates the integrity of a protected application state by re-
playing old persistently stored data or by starting mul-
tiple application instances. Successful rollback attacks
have serious consequences on applications such as ﬁnan-
cial services. In this paper, we propose a new approach
for rollback protection on SGX. The intuition behind
our approach is simple. A single platform cannot efﬁ-
ciently prevent rollback, but in many practical scenarios,
multiple processors can be enrolled to assist each other.
We design and implement a rollback protection system
called ROTE that realizes integrity protection as a dis-
tributed system. We construct a model that captures ad-
versarial ability to schedule enclave execution and show
that our solution achieves a strong security property: the
only way to violate integrity is to reset all participat-
ing platforms to their initial state. We implement ROTE
and demonstrate that distributed rollback protection can
provide signiﬁcantly better performance than previously
known solutions based on local non-volatile memory.
1
Introduction
Intel Software Guard Extensions (SGX) enables ex-
ecution of security-critical application code, called en-
claves, in isolation from the untrusted system software
[1]. Protections in the processor ensure that a malicious
OS cannot read or modify enclave memory at runtime.
To protect enclave data across executions, SGX provides
a security mechanism called sealing that allows each en-
clave to encrypt and authenticate data for persistent stor-
age. SGX-enabled processors are equipped with certiﬁed
cryptographic keys that can issue remotely veriﬁable at-
testation statements on the software conﬁguration of en-
claves. Through these security mechanisms (isolation,
sealing, attestation) SGX enables development of various
applications and online services with hardened security.
The architecture has also its limitations. While sealing
prevents a malicious OS from reading or arbitrarily mod-
ifying persistently stored enclave data, rollback attacks
[2, 3, 4, 1] remain a threat. In a rollback attack a mali-
cious OS replaces the latest sealed data with an older en-
crypted and authenticated version. Enclaves cannot eas-
ily detect this replay, because the processor is unable to
maintain persistent state across enclave executions that
may include platform reboots. Another way to violate
state integrity is to create two instances of the same en-
clave and route update requests to one instance and read
requests to the other. To remote clients that perform at-
testation, the instances are indistinguishable.
Data integrity violation through rollback attacks can
have severe implications. Consider, for example, a ﬁ-
nancial application implemented as an enclave. The en-
clave repeatedly processes incoming transactions at high
speed and maintains an account balance for each user or
a history of all transactions in the system. If the adver-
sary manages to revert the enclave to its previous state,
the maintained account balance or the queried transac-
tion history does not match the executed transactions.
To address rollback attacks, two basic approaches are
known. The ﬁrst is to store the persistent state of enclaves
in a non-volatile memory element on the same platform.
The SGX architecture was recently updated to support
monotonic counters that leverage non-volatile memory
[5]. However, the security guarantees and the perfor-
mance limits of this mechanism are not precisely doc-
umented. Our experiments show that writes of counter
values to this memory are slow (80-250 ms), which lim-
its its use in high-throughput applications. More impor-
tantly, this memory allows only a limited number of write
operations. We show that this limit is reached within just
few days of continuous system use after which the mem-
ory becomes unusable. Similar limitations also apply to
rollback protection techniques that leverage Trusted Plat-
form Modules (TPMs) [2, 4, 3].
The second common approach is to maintain in-
tegrity information for protected applications in a sep-
USENIX Association
26th USENIX Security Symposium    1289
arate trusted server [6, 7, 8]. The drawback of such
solutions is that the server becomes an obvious target
for attacks. Server replication using standard Byzantine
consensus protocols [9] avoids a single point of failure,
but requires high communication overhead and multiple
replicas for each faulty node.
In this paper we propose a new approach to protect
SGX enclaves from rollback attacks. The intuition be-
hind our solution is simple. A single SGX platform
cannot prevent rollback attacks efﬁciently, but in many
practical scenarios the owner or the owners of proces-
sors can assign multiple processors to assist each other.
Our approach realizes rollback protection as a distributed
system. When an enclave updates its state, it stores a
counter to a set of enclaves running on assisting proces-
sors. Later, when the enclave needs to recover its state, it
obtains counter values from assisting enclaves to verify
that the recovered state data is of the latest version.
We consider a powerful adversary that controls the OS
on the target platform and on any of the assisting plat-
forms. Additionally, we even assume that the adversary
can break SGX protections on some of the assisting pro-
cessors and control all network communication between
the platforms. Our adversary model combines commonly
considered network control based on the standard Dolev-
Yao model [10] and Byzantine faults [11, 12], but addi-
tionally captures the the ability of the adversary to restart
trusted processes from a previously saved state and to run
multiple instances of the same trusted process. Such ad-
versarial capabilities are crucial for the security analysis
of our system, and we believe that the model is of gen-
eral interest. In fact, using our model we found potential
vulnerabilities in recent SGX systems [3, 13, 14].
Secure and practical realization of distributed roll-
back protection under such a strong adversarial model
involves several challenges. One of the main challenges
is that when an assisting enclave receives a counter, its
own state changes, which implies a set of new state up-
dates that would in turn propagate. To prevent endless
update propagation, the counter value must be stored in
the volatile runtime memory of enclaves. However, the
assisting enclaves may be restarted at any time. More-
over, the adversary can also create multiple instances
of the same enclave on all assisting platforms and route
counter writes and reads to separate instances.
We design and implement a rollback protection sys-
tem called ROTE (Rollback Protection for Trusted Ex-
ecution). The main components of our solution are a
state update mechanism that is an optimized version of
consistent broadcast protocols [15, 16], and a recovery
mechanism that obtains lost counters from the rest of the
protection group upon enclave restart. We also design a
session key update mechanism to address attacks based
on multiple enclave instances.
Our solution achieves a strong security property that
we call all-or-nothing rollback. Although the attacker
can restart enclaves freely, and thus implement subtle at-
tacks where enclave state updates and recovery are inter-
leaved, the adversary cannot roll back any single enclave
to its previous state. The only way to violate data in-
tegrity is to reset the entire group to its initial state. If
desired, similar to [4, 2], our approach can also provide
crash resilience, assuming deterministic enclaves and a
slightly weaker notion of rollback prevention (the latest
input can be executed twice).
We implemented ROTE on SGX and evaluated its
performance on four SGX machines. We tested larger
groups of up to 20 platforms using a simulated imple-
mentation over a local network and geographically dis-
tributed enclaves. Our evaluation shows that state up-
dates in ROTE can be very fast (1-2 ms). The number
of counter increments is unlimited. This is in contrast
to solutions based on SGX counters and TPMs, where
state updates are approximately 100 times slower and
limited. Compared to Byzantine consensus protocols,
our approach requires signiﬁcantly fewer replicas ( f + 1
instead of the standard 3 f + 1). Enclave developers can
use our system through a simple API. The ROTE TCB
increment is moderate (1100 LoC).
Contributions. We make the following contributions.
• New security model. We introduce a new security
model for reasoning about the integrity and freshness of
SGX applications. Using the model we identiﬁed poten-
tial security weaknesses in existing SGX systems.
• SGX counter experiments. We show that SGX coun-
ters have severe performance limitations.
• Novel approach. We propose a novel way to pro-
tect SGX enclaves. Our main idea is to realize roll-
back protection by storing enclave-speciﬁc counters in
a distributed system of collaborative enclaves on distinct
nodes.
• ROTE. We propose and implement a system called
ROTE that effectively protects against rollback attacks.
ROTE ensures integrity and freshness of application data
in a powerful adversarial model.
• Experimental evaluation. We demonstrate that dis-
tributed rollback protection incurs only a small perfor-
mance overhead. When deployed over a low-latency net-
work, the state update overhead is only 1-2 ms.
The rest of this paper is organized as follows. Sec-
tion 2 explains models and rollbacks attacks. Section 3
describes our approach. Section 4 describes the ROTE
system and Section 5 provides security analysis. Sec-
tion 6 provides performance evaluation and Section 7
further discussion. We review related work in Section 8.
Section 9 concludes the paper.
1290    26th USENIX Security Symposium
USENIX Association
but the enclave cannot distinguish which seal is the lat-
est. Every enclave instance i can unseal data previously
sealed by an instance of the same enclave identity e.
Communication operations. Due to attestation, a
client can write data such that only a particular enclave
can read it. The client can read data from an enclave and
verify which enclave wrote it. We model these primi-
tives as single operations that can be called from the same
or remote platform, although attestation is an interactive
protocol between the enclave and client.
• Write(me,i). The OS can write message me to an en-
clave instance i. Only an enclave with enclave identity e
can read the written message me.
• me ← Read(i). The OS can read message me from an
enclave instance i. The read message me identiﬁes the
enclave identity e that wrote the data.
Note that remote attestation identiﬁes the enclave
identity, but not the platform identity, because the at-
testation protocol is either anonymous or returns client-
speciﬁc pseudonyms (see Appendix A for details).
In
local attestation the platform is implicitly known.
We do not model platform reboots, as those have the
same effect as enclave restarts. Our model assumes that
the runtime memory of each enclave instance is perfectly
isolated from the untrusted OS and other enclaves. We
consider information leakage from side-channel attacks
a realistic threat [17, 18, 19], but an orthogonal problem
to rollback attacks, and thus outside of our model.
2.2 Local Adversary Model
We consider a powerful adversary who, after an ini-
tial trusted setup phase, controls all system software on
the target platform, including the OS. Based on the SGX
model, the adversary can schedule enclaves and start
multiple instances of the same enclave, offer the latest
and previous versions of sealed data, and block, delay,
read and modify all messages sent by the enclaves.
The adversary cannot read or modify the enclave run-
time memory or learn any information about the se-
crets held in enclave data. The adversary has no ac-
cess to processor-speciﬁc keys, such as the sealing key
or the attestation key, and the adversary cannot break
cryptographic primitives provided by the SGX architec-
ture. The enclaves may also implement additional cryp-
tographic operations that the adversary cannot break.
The adversarial capabilities that we identiﬁed as part
of the model can be critical for many SGX systems. The
ability to schedule, restart and create multiple enclave
instances, enables subtle attacks that we address in this
paper. We analyzed SGX systems using this model and
found vulnerabilities that can be addressed through the
techniques developed in this paper. These ﬁndings are
reported in an extended version of this paper [20].
Figure 1: Modeled SGX operations.
2 Problem Statement
In this section we deﬁne models for the SGX architec-
ture and the adversary. After that, we explain rollback
attacks, limitations of known solutions, and our require-
ments. Appendix A provides a summary of the SGX ar-
chitecture for readers that are not familiar with it.
2.1 SGX Model
Figure 1 illustrates our SGX model. We model en-
claves and the operating system, their main functional-
ity, and the operations through which they interact. Our
model captures the main SGX functionalities that are
available on all SGX platforms.
Scheduling operations. Enclave execution is sched-
uled by the OS.
• e ← Create(code). The system software running on
the OS can create an enclave by providing its code. The
SGX architecture creates a unique enclave identiﬁer e
that is deﬁned by the code measurement.
• i ← Start(e). The system software can start a cre-
ated enclave using its enclave identiﬁer e. The enclave
generates a random and unique instance identiﬁer i for
the enclave instance that executes the code that was as-
signed to it during creation. While an enclave instance
is running, the OS and other enclaves are isolated from
its runtime memory. Each enclave instance has its own
program counter and runtime memory.
• Suspend(i) and Resume(i). The OS can suspend the
execution of an enclave. When an enclave is suspended,
its program counter and runtime memory retain their val-
ues. The OS can resume suspended enclave execution.
• Terminate(i). The OS can terminate the enclave ex-
ecution. At termination, the enclave runtime memory is
erased by the SGX architecture and the enclave instance
i is rendered unusable.
Storage operations. The second set of operations is
related to sealing data for local persistent storage.
• s ← Seal(data). An enclave can save data for local
persistent storage. This operation creates an encrypted,
authenticated data structure s that is passed to the OS.
• OfferSeal(i,s). The OS can offer sealed data s. The
enclave can verify that it previously created the seal,
USENIX Association
26th USENIX Security Symposium    1291
OSschedulingEnclaveruntime memorycode, dataCreate(), Delete()Start(), Terminate()Suspend(), Resume()OfferSeal()storageWrite()Read()Seal()e id = {code}attestationsealingcommunicationEnclaveiid = rand()2.3 Rollback Attacks
The goal of the adversary is to violate the integrity of
the enclave’s state. This is possible with a simple roll-
back attack. After an enclave has sealed at least two