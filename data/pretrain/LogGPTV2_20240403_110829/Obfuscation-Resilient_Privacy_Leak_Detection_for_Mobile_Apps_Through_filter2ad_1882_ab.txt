handle obfuscations of the actual data since it does not look for
speciﬁc tokens that are known to be associated with leaks, but
3
rather treats every inexplicable change in the network trafﬁc as
a potential leak.
We stress that the example we discussed in this section
is not synthetic, but it is actually the simpliﬁed version of a
snippet taken from one of the most popular apps in the Google
Play Store. Speciﬁcally, this example is the simpliﬁed version
of a functionality implemented in the popular InMobi ad library.
We also note that this case of nested encodings and encryption
is not just an isolated example: our experiments, discussed at
length in §VI, show that these obfuscated leaks occur quite
frequently and that existing black-box approaches are unable to
detect them.
III. SOURCES OF NON-DETERMINISM
One of the key prerequisites for performing differential
analysis is to eliminate any sources of non-determinism between
different executions. Only by doing so, one can reliably attribute
any changes in the network output following changes in private
input values to information leakage. While previous work has
focused on deterministic executions through the use of OS
snapshots [23], according to our experiments the network itself
is by far the largest source of non-determinism.
When executing an app multiple times on exactly the same
device, with the same settings, and using the same user input,
one would intuitively expect an app to produce exactly the
same (i.e., deterministic) network trafﬁc during every execution.
However, our preliminary experiments showed that this is not the
case: the network trafﬁc and more speciﬁcally the transmitted
and received data frequently changes on every execution, and
even between the same requests and responses during a single
execution.
This non-determinism is not necessarily something that
is introduced by the app developer intentionally to evade
analysis systems, but, instead, it is most often part of the
legitimate functionality and standard network communication.
We conducted a small-scale study on 15 Android apps randomly
selected from the Google Play Store, and we investigated the
most common sources of non-determinism in network trafﬁc.
We were able to identify the following categories:
•
•
•
•
Random values. Random numbers used to generate
session identiﬁers or, for instance, to implement game
logic. Also, the Android framework provides developers
with an API to generate 128-bit random universally
unique identiﬁers (UUID). In the most common sce-
nario, apps use this API to generate an UUID during
the installation process.
Timing values. Timestamps and durations, mainly
used for dates, logging, signatures, and to perform
measurements (e.g., loading time).
System values. Information about the state and the
performance of system (e.g., information about free
memory and available storage space).
Encrypted values. Cryptographic algorithms use ran-
domness to generate initialization vectors (IV) and
padding.
•
•
Network values. Information that is assigned by a
network resource (e.g., cookies, server-assigned session
identiﬁers).
Non-deterministic execution. Randomness inherent
to the execution of an app, such as different loading
times affecting the UI exploration.
IV. APPROACH
For any given app, our analysis consists of two main phases.
In the ﬁrst phase (see §IV-A), called network behavior summary
extraction, we execute the app multiple times in an instrumented
environment to collect raw network traces, and contextual
information, which allows us to attribute the non-determinism
that we see in the network behavior to the sources discussed in
§III. We then combine these network traces with the contextual
information to create a contextualized trace for each run. Finally,
we merge the contextualized network traces of all runs into a
network behavior summary of the app.
In the second phase of our approach (see §IV-B), we run
the app again in exactly the same instrumented environment,
with the only difference that we change one of the input
sources of private information (e.g., IMEI, location). We then
compare the contextualized trace collected in this ﬁnal run
with the network behavior summary of the previous runs to
identify any discrepancy. We perform this comparison in two
steps: differential analysis, which identiﬁes differences, and risk
analysis, which scores the identiﬁed differences to determine
potential privacy leaks.
Figure 2 shows a high-level overview of our approach, while
Figure 3 illustrates the individual steps in more detail using a
simpliﬁed example.
A. Network Behavior Summary Extraction
Network Trace & Contextual Information. For each execu-
tion of the app in our instrumented environment, we collect a
network trace, which contains the raw HTTP ﬂows generated
by the app, and contextual information, which contains the
values generated by any of the sources of non-determinism
we described earlier. Our approach here goes beyond simple
network trafﬁc analysis, and includes instrumenting the way
the app is interacting with the Android framework. Speciﬁcally,
AGRIGENTO is able to eliminate the different sources of non-
determinism by intercepting calls from the app to certain
Android API calls and recording their return values, and in
some cases replacing them—either by replaying previously
seen values or by returning constant values. First, AGRIGENTO
records the timestamps generated during the ﬁrst run of each
app, and replays the same values in the further runs. Second,
it records the random identiﬁers (UUID) generated by the app.
Third, it records the plaintext and ciphertext values whenever the
app performs encryption. Finally, the instrumented environment
sets a ﬁxed seed for all random number generation functions,
and replaces the values of system-related performance measures
(e.g., free memory, available storage space) with a set of
constants.
Note that when an app uses its own custom encryption
routines, or generates random identiﬁers itself without relying
on Android APIs, AGRIGENTO will not be able to detect these
Fig. 2. High-level overview of AGRIGENTO: during the network behavior
summary extraction it ﬁrst generates a baseline of an app’s network behavior
during n runs, taking into account non-determinism in the contextual infor-
mation; during the differential analysis it then modiﬁes the sources of private
information and identiﬁes privacy leaks based on differences in the network
behavior of the ﬁnal run compared to the network behavior observed in the
previous runs.
as sources of non-determinism. However, as we explain in the
next paragraph, our approach is conservative, which means this
would produce a false positive, but not a false negative.
Contextualized Trace. We build the contextualized trace
by incorporating the contextualized information into the raw
network trace. To do this, we remove all sources of non-
determinism (i.e., values stored in the contextual information)
we encountered during the execution, by labeling all timestamps-
related values, random identiﬁers, and values coming from the
network, and decrypting encrypted content by mapping the
recorded ciphertext values back to their plaintext. Essentially,
we look at the raw network trace and try to determine, based
on string comparison, values in the HTTP trafﬁc that come
from potential sources of non-determinism. This is similar to
the techniques that previous works use to ﬁnd certain values of
private information in the network trafﬁc. The key difference is
that we do not perform the string matching to ﬁnd leaks, but,
rather, to explain sources of non-determinism. This is essentially
the opposite goal of previous work: rather than ﬁnding leaks,
we use string matching techniques to ﬂag potential leaks as
“safe.” This approach has the advantage of being conservative.
In fact, we ﬂag any source of non-determinism that we cannot
explain. While in previous work a failure of the string matching
would lead to a missed leak (i.e., a false negative), our approach
would produce, in the worst case, a false positive.
Network Behavior Summary. When AGRIGENTO builds the
contextualized network traces, it essentially removes all common
sources of non-determinism from the network trafﬁc. However,
it cannot fully eliminate non-determinism in the execution path
of the app. Even though AGRIGENTO runs the app in an instru-
mented environment and replays the same sequence of events
for each run, different loading times of the UI and other factors
can result in different execution paths. To mitigate this issue,
we run each app multiple times and merge the contextualized
traces collected in the individual runs to a network behavior
summary. Intuitively, the network behavior summary includes
all the slightly different execution paths, generating a more
complete picture of the app’s network behavior. In other words,
the network behavior summary represents “everything we have
4
Contextual InfoNetwork TraceContextualized TraceInstrumented EnvironmentContextualized Trace#1Run#nRun...Network Behavior SummaryContextualized TraceFinal RunAppSources of LeakDifferential AnalysisRisk AnalysisPhase 1: Network Behavior Summary ExtractionPhase 2: Differential Analysis......AppSources of LeakAppSources of LeakContextual InfoNetwork TraceContextual InfoNetwork TraceInstrumented EnvironmentInstrumented EnvironmentFig. 3. Example of how AGRIGENTO performs its analysis in two phases. (1) In the ﬁrst phase it builds a network behavior summary and replaces common
sources of non-determinism. (2) In the second phase performs differential analysis by changing the value of an input source of private information to identify
differences in the network behavior, which it then scores as potential privacy leaks.
seen” during the executions of the given app and aims at
providing a trusted baseline behavior of the app.
A distinctive aspect of AGRIGENTO is how it determines
the number of times each app should be executed. Intuitively,
the number of runs affects the performance of our tool in terms
of false positives. However, we observed that this parameter
strongly depends on the complexity of the app. Therefore, our
approach is iterative and decides after each run if another one is
required. After each run AGRIGENTO performs the differential
analysis using the collected contextualized traces. By analyzing
the discrepancies in the network behavior without having altered
any source of private information, we can understand when
AGRIGENTO has sufﬁciently explored the app’s behavior, i.e.,
when the network behavior summary reaches convergence. In
practice, we say that an app reaches convergence when we do
not see any discrepancies in the network behavior summary for
K consecutive runs. In §VI-C, we show how this parameter sets
a trade-off between the ability of explaining non-determinism
and the overall time it takes AGRIGENTO to analyze an app
(i.e., the average number of runs). Also, because some apps
might never reach convergence, we set a maximum number of
runs.
B. Differential Analysis
In a second phase, we run the app in the same environment
as before, but modify the value of private information sources,
such as the IMEI and location, we want to track. We can do
this (a) once for all values to detect if an app is stealthily
leaking information in general, or (b) multiple times—once
for every unique identiﬁer—to precisely identify the exact
type of information the app is leaking. In the example in
Figure 3, AGRIGENTO changed the value of a source of private
information from c734f4ec to 03ff61e4.
Differential Analysis. As in the previous phase, we collect
a network trace and contextual information to build a con-
textualized trace. Then, we compare this contextualized trace
against the network behavior summary, which we extracted
in the previous phase. To extract the differences, we leverage
the Needleman-Wunsch algorithm [29] to perform a pairwise
string sequence alignment. The algorithm is based on dynamic
programming and can achieve an optimal global matching. It
is well-suited for our scenario: in fact, it has been successfully
applied to automatic network protocol reverse engineering
efforts [7], [45], [50], which conceptually have a similar goal
than our network behavior summary, in that they extract a
protocol from observing the network behavior during multiple
executions.
At this point of our analysis, we eliminate the ﬁnal source of
non-determinism: values that come from the network. For each
difference, AGRIGENTO checks if its value has been received
in a response to a previous network request (e.g., the value is a
server-assigned identiﬁer). We assume that leaked information is
not part of the payload of previous responses. This is reasonable
since, in our threat model, the attacker does not know the value
of the leaked source of private information in advance.
After this ﬁltering step, AGRIGENTO raises an alert for
each remaining difference between the contextualized trace in
the ﬁnal run and the network behavior summary. This is a
conservative approach, which means that, if there is some source
of non-determinism AGRIGENTO does not properly handle
(e.g., apps that create UUIDs themselves or perform custom
encryption without leveraging the Android framework), it will
ﬂag the app: In the worst case, this will produce a false positive.
Risk Analysis. In the last phase of our approach, AGRIGENTO
quantiﬁes the amount of information in each identiﬁed differ-
ence to evaluate the risk that an alert is caused by an actual
information leak. Our key intuition is that not all identiﬁed
differences bear the same risk. Thus, we assign a score to
each alert based on how much the information differs from
the network behavior summary. Speciﬁcally, we leverage two
distance metrics, the Hamming distance and the Levenshtein
distance, to compare each alert value to the corresponding value
in the network behavior summary. Finally, for each app we
5
https://ads.com/show?data=3951820fb1cad2e77a996e18fd1973ffhttps://ads.com/register?id=4716ac99-767e-42f4-86fa-092d489431a3&special=Truehttps://ads.com/show?data=dde108ec00cfc08d3b22a39659e3f6cfhttps://ads.com/register?id=e9040325-2b7e-a674-de21-ce1b983fa8a5https://ads.com/show?data=7aca67bfc75d7816a1d907fb834c8f69https://ads.com/register?id=732d064f-a465-0414-07f9-ff7d4c27544chttps://auth.domain.com/user/signUUIDs: [732d064f-a465-0414-07f9-ff7d4c27544c]Timestamps: [146897456, 146897562]Decryption map: {"7aca67bfc75d7816a1d907fb834c8f69"=>"146897456_c734f4ec"}UUIDs: [4716ac99-767e-42f4-86fa-092d489431a3]Timestamps: [146897985]Decryption map: {"3951820fb1cad2e77a996e18fd1973ff"=>"146897985_c734f4ec"}UUIDs: [e9040325-2b7e-a674-de21-ce1b983fa8a5]Timestamps: [146898910, 146912344]Decryption map: {"dde108ec00cfc08d3b22a39659e3f6cf"=>"146898910_03ff61e4"}https://ads.com/show?data=_c734f4echttps://ads.com/register?id=https://auth.domain.com/user/signhttps://ads.com/show?data=_c734f4echttps://ads.com/register?id=https://ads.com/register?special=Truehttps://ads.com/show?data=_c734f4echttps://ads.com/register?id=https://auth.domain.com/user/signhttps://ads.com/register?special=Truehttps://ads.com/show?data=_03ff61e4https://ads.com/register?id=03ff61e4#1 Run#n RunFinal RunNetwork TraceNetwork TraceNetwork TraceContextual infoContextual infoContextual infoContextualized TraceContextualized TraceContextualized TraceNetwork Behavior SummaryDifferential Analysis_c734f4ec_03ff61e4Score("c734f4ec", "03ff61e4") = 21Risk AnalysisPhase 2Phase 1compute a cumulative score S as the sum of the scores of all
the alerts that AGRIGENTO produced for the app. This score
provides a measure of the amount of information (i.e., the
number of bits) an app can potentially leak, and it can thus be
used as an indirect measure of the overall risk of a privacy leak
in a given app.
V. SYSTEM DETAILS
We implemented AGRIGENTO in two main components: an
on-device component, which instruments the environment and
collects contextual information, and the core off-device compo-
nent, which intercepts the network trafﬁc, extracts the network
behavior summary, and performs the differential analysis.
A. Apps Environment Instrumentation
We implemented a module, based on Xposed [4], which
hooks method calls and records and modiﬁes their return
values. As a performance optimization, AGRIGENTO applies
the contextualization steps only when needed (i.e., only when
it needs to address values from a non-deterministic source).
Random values. To record Android random identiﬁers
(UUIDs) the module intercepts the return of the Android
API randomUUID() and reads the return value. However,
recording the randomly generated values is not enough: apps
frequently process these numbers (e.g., multiply them with a
constant), and thus they usually do not appear directly in the
network trafﬁc. To handle this scenario, we set a ﬁxed seed
for random number generation functions. By doing so, we can
observe the same values in the output network trafﬁc for each
run, even without knowing how they are transformed by an
app. However, always returning the same number is also not
an option since this might break app functionality. Thus, we
rely on a precomputed list of randomly generated numbers.
For each run, the module modiﬁes the return value of such
functions using the numbers from this precomputed list. In
case the invoked function imposes constraints on the generated
number (e.g., integers in the interval between 2 and 10), we
adapt the precomputed numbers in a deterministic way (e.g.,
by adding a constant), to satisfy the speciﬁc requirements of a
function call.
Timing values. Also in the case of timing information, only
recording the values is not enough since timestamps are often
used to produce more complex values (e.g., for the generation of
signatures). To deal with timestamp-related values, the module
hooks all the methods providing time-related information, such
as System.currentTimeMillis(), stores the return
values in a ﬁle during the ﬁrst run, and modiﬁes the return
values reading from the ﬁle in the next runs. It reads the stored
timestamps in the same order as they were written and, in case
one of the next runs performs more calls to a speciﬁc method
than the ﬁrst run (this could be due to a different execution
path), it leaves the original return values unmodiﬁed for the
exceeding calls.
System values. We
return val-
ues of Android APIs that apps use to perform perfor-
mance measurements and ﬁngerprint the device for example
by reading information about
the available storage space
to constants
set
the
Fig. 4. Example of how AGRIGENTO leverages Crypto API traces to build an
entry of the decryption map that maps ciphertext to its corresponding plaintext
(*address represents the content stored at that address).
from StatFs.getAvailableBlocks(), or by querying