REFLECTION’S HIDDEN POWER 
 “MODIFYING PROGRAMS AT RUN-TIME”
By J~~~~~~~ M~~~~~~
5/27/08
i 
Contents
Contents
......................................................................................................................................................
ii  
Abstract
......................................................................................................................................................
iv  
Glossary
.......................................................................................................................................................
v  
Introduction
................................................................................................................................................
vi  
Implementation of Reflection Manipulation
................................................................................................
 1  
Real Life Usage: Reflection 101
..................................................................................................................
 2  
Implementing Reflection
.............................................................................................................................
 4  
Load an Assembly
....................................................................................................................................
 4  
Getting the Types From an Assembly
......................................................................................................
 4  
Getting and Invoking Constructor of an Object Type 
..............................................................................
 4  
Traversing Instantiated Objects 
..............................................................................................................
 6  
Invoking Functionality on an Object
........................................................................................................
 6  
Change the Values of an Object
...............................................................................................................
 7  
The DotNet World: From System Process to Class Level
...........................................................................
 8  
High Level View: What Can Reflections Do and What Is It?
......................................................................
 9  
How to Navigate to a Specific Object
........................................................................................................
 10
How to Access the Form Object
................................................................................................................
 11
New Vectors: Access by Reflection
........................................................................................................
 12
Limitations and Brick walls
.....................................................................................................................
 12
Demo Attacks
............................................................................................................................................
13
The SQL Injection
...................................................................................................................................
 13
 The Social Engineering Vector
...............................................................................................................
 14
Conclusion
.................................................................................................................................................
15
ii
Illustrations
Figure 1 .    Code  - Common Flags.............................................................................................................2
Figure 2 .    Code  - Build Instance Flag .....................................................................................................2
Figure 3 .    Code  - Build Static Flag .........................................................................................................2
Figure 4 .    Code  - Load Assembly ...........................................................................................................4
Figure 5 .    Code  - Gain Access to Types in Assembly..............................................................................4
Figure 6 .    Code  - Get and Load Constructor of an Object........................................................................5
Figure 7 .    Code  - Traversing Objects.......................................................................................................6
Figure 8 .    Code  - Invoking Functionality on Objects...............................................................................6
Figure 9 .    Code  - Change Values on Objects...........................................................................................7
Figure 10 .  Image - System Process Overview...........................................................................................8
Figure 11 .  Image - System Process Overview Alternate Implementations ...............................................8
Figure 12 .  Code  - DotNet Call to Get Forms..........................................................................................11
Figure 13 .  Code  - System Call to Get Forms..........................................................................................11
Figure 14 .  Code  - Demo SQL Injection..................................................................................................13
Figure 15 .  Code  - Demo Social Engineering..........................................................................................14
iii
Abstract
This paper will demonstrate using Reflection to take control over a DotNet (.Net) 
compiled code. The focus of this paper will be on how to use Reflection to navigate and gain 
access to values and functionality that would normally be off limits. This paper will be geared 
for any DotNet programmer (focus will be in C#). No special knowledge of Reflection is 
necessary. The basic concept of Reflection and DotNet will be given, along with some light 
training on using reflection. This paper is written for the DotNet v2.0 and v3.5 versions of 
DotNet. Examples will be given on attacks, like forcing a program to change values and execute 
functionality.
iv
Glossary
AppDomain  -
Assembly -
.GetType() – 
UML -
The DotNet AppDomain is equivalent to a process. It provides separation and 
protection between AppDomains. This is typically a separation between code 
that has independent execution.  Ex. Say ‘void Main()’ has crashed, the program 
can still report the problem and try to recover with a secondary AppDomain.
The DotNet Assemblies contain the definition of types, a manifest, and other 
meta-data. Standard DotNet Assemblies may or may not be executable; they 
might exist as the .EXE(Executable) or .DLL(Dynamic-link library). 
Is a function that is inherited from Object in DotNet. It returns the System.Type 
for the object it is called on.
Is an acronym for Unified Modeling Language, it is a graphical language for 
visualizing, specifying, constructing, and documenting the artifacts in software.
v
Introduction
Subject
Reflection grants access to a meta level of programs. This paper will look at how to use 
Reflection to gain access and control over an outside .EXE or .DLL. Reflection makes it possible 
to gain access to private and protected areas of a program, as well as directly modifying most any 
variable or trigger functionality.
Purpose
This paper is a resource for programmers researching Reflection. This report will give the 
reader a basic concept of Reflection and some example code to play with. It will give an 
overview of Reflection and in-depth usages in “real world settings.”
Scope
This paper will cover Reflection on managed DotNet specifically at Run-Time. 
Over View
This paper will start off by covering how to use Reflection to manipulate a compiled 
program. It will cover some basic parts of reflection; some example code will be given. Some 
supporting background information on DotNet and Reflection will be provided. Afterwards we 
get to direct attacks opened up by Reflection  
vi
Implementation of Reflection Manipulation
The first step in a Reflection attack is loading the outside codebase. This is done by 
loading the Assembly from an .EXE or .DLL into an accessible AppDomain, which will grant 
easy access. 
The second step will be finding the object types in the program. This will grant access to 
launch constructors, access static objects, and invoke static functions.
The third step, depending on the targeted outcome, is to run the program on its normal 
path. To do this get the common entry point of “void Main()” and invoke it.
The fourth step is gaining access to the part of the program to be controlled. Most of the 
time this will be an instance object that will need to be found by traversing between instance 
objects to get a reference. This can be extraordinarily difficult.
The fifth step is impacting changes. This is normally accomplished by setting a value or 
invoking some specific functionality on an object. 
Some optional parts to this sequence are:
•
Re-code “void Main()” to take complete control over the program’s entry point. 
•
Load the target compiled code base into a different AppDomain.
•
Access the Form object(s) and take over the GUI.
As with any endeavor, knowing the lay of the land is invaluable. After reading over the 
code base and/or looking at the UML, an experienced programmer should be well equipped to 
move around inside and control the target program. Also Sequence diagrams can also come in 
handy as they show a specific execution path.  
1 
Real Life Usage: Reflection 101
One of the basic tasks for Reflection is changing a value on an object. To do this simply 
do a GetType on the target instance object-- access its fields with GetFields and do a SetValue on 
the target field. 
By doing a GetType on an object it will return a System.Type. This can then be used to 
gain access to fields, methods, attributes, and more. The main trick to using these functions and 
most of Reflection is setting the flags on the requests.
Some flags commonly used are:
System.Reflection.BindingFlags.Instance                 = retrieve from the instance part of an object
System.Reflection.BindingFlags.Static                     = retrieve from the static area of object type
 System.Reflection.BindingFlags.NonPublic            = retrieve non-public items 
System.Reflection.BindingFlags.Public                    = retrieve public items 
System.Reflection.BindingFlags.FlattenHierarchy   = retrieve from derived classes    
Figure 1 .    Code  - Common Flags
The flags are constructed by an OR operation as they are an enumeration type.
This is a demo flag built to access material on an instance object that is public and 
non-public as well as material from its derived classes. Example below:   
System.Reflection.BindingFlags flag = System.Reflection.BindingFlags.Instance | 
System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | 
System.Reflection.BindingFlags.FlattenHierarchy;
Figure 2 .    Code  - Build Instance Flag 
This is a demo flag built to access material on a static object that is public and non-public 
as well as material from its derived classes. Example below:
System.Reflection.BindingFlags flag = System.Reflection.BindingFlags.Static | 
System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | 
System.Reflection.BindingFlags.FlattenHierarchy;
Figure 3 .    Code  - Build Static Flag 
To get the Fields for an object it would be:
       objectIn.GetType().GetFields(flag);
To get the Methods for an object it would be:
       objectIn.GetType().GetMethods(flag);
           Flags do not cancel each other out, so it is ok to do a request for instance and static or 
public and non-public on the same flag.  
2
Implementing Reflection
Some key parts to Reflection are: load an Assembly, getting the types from an Assembly, 
getting and invoking constructors of an object type, traversing instantiated objects, invoking 
functionality on an object, and changing the values of an object.  
Load an Assembly
public static System.Reflection.Assembly LoadAssembly(string filePath)
{
        System.Reflection.Assembly AM = System.Reflection.Assembly.LoadFile(filePath);
        return AM;
}
Figure 4 .    Code  - Load Assembly 
Getting the Types From an Assembly
public static System.Type[] LoadAssembly(System.Reflection.Assembly assemblyIn)
{
        myAssembly = assemblyIn;
        System.Type[]typesInAssembly = null;
        typesInAssembly = GetTypesFromAssembly(myAssembly);
        return typesInAssembly;
}
Figure 5 .    Code  - Gain Access to Types in Assembly
Getting and Invoking Constructor of an Object Type 
public static object LoadObject(System.Type theType)
{
    System.Reflection.ConstructorInfo[] ConstructorList = GetConstructors(theType);
    //pick the default constructor from the list, some times it will be 0
    System.Reflection.ConstructorInfo defaultConstructor = ConstructorList[0];
    return LoadConstructor(defaultConstructor, new object[]{});
}
public static System.Reflection.ConstructorInfo[] GetConstructors(System.Type theType)
{
    return theType.GetConstructors();
}
public static object LoadConstructor(System.Reflection.ConstructorInfo theConstructor, object[] param)
{
    return theConstructor.Invoke(param);
}
Figure 6 .    Code  - Get and Load Constructor of an Object
3