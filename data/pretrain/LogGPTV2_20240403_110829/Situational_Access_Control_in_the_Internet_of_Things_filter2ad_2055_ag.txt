they are equally dangerous. For example, users of IFTTT—which
interacts with many other services—frequently encounter many
different OAuth 2 prompts with different, hard-to-follow semantics.
To reduce the number of prompts, IFTTT eagerly requests access to
all APIs of a Web-service channel once the user activates a single
recipe that uses any of them, resulting in overprivileging,7 as noted
by Fernandes et al. [31]
A.3 App-service interaction
We use Samsung’s SmartThings API as an example of app-service
interaction.
Subjects. SmartThings apps, SmartApps, are essentially collections
of event handlers written in the Groovy language. Apps are supplied
to users through a curated app market. They typically run on the
Samsung cloud service, but some can run offline on the SmartThings
hub, and this facility is expected to be enabled for more apps [65].
Objects. SmartApps control smart devices compatible with the
SmartThings service and, typically, connected to the SmartThings
hub device. The access-control system protects accesses of apps
(subjects) to device APIs (objects).
Access-control policies. Apps control devices using their skills:8
collections of commands and attribute values that are exposed by
devices. Many skills are defined in the API and they tend to be
very specific vs., for example, Android permissions. For example,
“dishwasher mode” allows to get and set operation modes for the
dishwasher, i.e., Home/Away/Night (see below). Some of the skills
are similar to OCF resource types (see Section A.1).
Policy creation. App declare the skills they require, while Smart-
Things devices declare the skills they implement. When installing
a SmartApp, the user is prompted to assign to it devices imple-
menting its required skill(s). The skills requested by a SmartApp
do not define its privilege level (and calling them “permissions”
7For example, if the user activates a recipe that requires access to any Facebook
channel, even a read-only one, IFTTT will immediately ask for access to the follow-
ing Facebook Web API access rights, which include the right to post to the user’s
page [20]: manage_pages, public_profile, publish_actions, user_about_me,
user_events, user_friends, user_location, user_photos, user_posts,
user_status, user_website.
8“Capabilities” in SmartThings terminology, but we use “skills” to avoid confusion
with the standard access-control meaning of “capability.”
may be confusing). Instead, access rights are determined via device
assignment by the user: a SmartApp is allowed to access all of its
assigned devices’ APIs. Fernandes et al. noted that this design often
results in overprivileging [28].
Access-control enforcement. The Groovy runtime environment
on the SmartThings cloud platform checks resource-access opera-
tions against app skills.
Situational constraints. SmartThings tracks three specific situa-
tions through modes: Home, Away, and Night. Modes are described
by the documentation as “behavioral filters.” The user can configure
apps to run only in specific modes.Apps can (and are encouraged
by the developer documentation) change their behavior according
to modes. Mode changes are highly configurable using routines,
user-defined automation rules with triggers and actions (similar in
structure to IFTTT rules), and apps. A natural configuration is to
switch the Home/Away mode according to the device’s location, and
set the Night mode according to the time of day. SmartThings users
can add custom modes but developers cannot. Modes are mutually
exclusive and thus not suitable for tracking multiple non-exclusive
situations.
A.4 Channel-recipe interactions (IFTTT)
The IFTTT recipe structure is described in Section 4. In IFTTT,
recipes are subjects, actions are objects. Access-control policies are
implicitly defined by recipe functionality, i.e., every recipe can
access its attached actions (subject to situational constraints, see
below). Correspondingly, policy creation is the process of activating
recipes.
Situational constraints. Recipes can potentially do dangerous
things, such as disarm an alarm system or tweet on the user’s behalf,
but they can fire only if they are activated by their triggers. One can
view triggers as having a dual purpose: they define the sufficient
and necessary conditions for the execution of recipe actions, or, in
other words, the situation in which the trigger executes.
In IFTTT, every recipe is limited to one situational constraint
defined by its trigger, as well as two other optional constraints. First,
for any activated recipe, users can choose to be notified when it runs.
Notifications are transmitted through push messages to the IFTTT
app on the user’s phone. The second constraint is recipe filters,
which are pieces of code that execute after the trigger and prior
to the action. A filter can “decide,” based on the situational factors
such as the time of day or information available about the trigger-
firing event, not to execute the action. For example, a developer
can define that a recipe only runs between 2pm and 4pm.
A planned future feature is the ability to query third-party in-
terfaces from the filter code. With this ability, filters would be a
powerful tool for enforcing situational constraints. In contrast to
our ESOs, however, filters cannot be shared among recipes.
B IFTTT SURVEY
Collected data. We implemented a crawler that extracts IFTTT
recipes, actions, and triggers, similarly to Ur et al. [70] and Surba-
tovich et al. [66]. We extracted the recipes, actions, and triggers of
the 571 recipe collections curated by IFTTT partner services, acces-
sible from the “services” page, https://ifttt.com/search/services, as
of January 5th, 2018. We extracted 13619 recipes,9 not counting the
“notify me about new recipes for this service” recipe. It exists for
every service and we removed it from our analysis.
Our statements about IFTTT recipes in Section 2 are based on
the following recipe statistics:
Top 10 most utilized triggers (by recipes).
(1) say a specific phrase by AMAZON_ALEXA (498 recipes)
(2) button press by DO_BUTTON (457 recipes)
(3) you enter an area by LOCATION (309 recipes)
(4) you exit an area by LOCATION (239 recipes)
(5) every day at by DATE_AND_TIME (234 recipes)
(6) new public video uploaded by you by YOUTUBE (215 recipes)
(7) say a simple phrase by GOOGLE_ASSISTANT (200 recipes)
(8) every day of the week at by DATE_AND_TIME (155 recipes)
(9) any new note by DO_NOTE (131 recipes)
(10) flic is clicked by FLIC (112 recipes)
Top 10 most utilized actions (by recipes).
(1) send a notification from the ifttt app by IF_NOTIFICATIONS
(823 recipes)
(2) add row to spreadsheet by GOOGLE_SHEETS (648 recipes)
(3) send me an email by EMAIL (491 recipes)
(4) send an email by GMAIL (332 recipes)
(5) post a tweet by TWITTER (322 recipes)
(6) post to channel by SLACK (277 recipes)
(7) quick add event by GOOGLE_CALENDAR (245 recipes)
(8) change color by HUE (192 recipes)
(9) call my phone by PHONE_CALL (187 recipes)
(10) turn on lights by HUE (181 recipes)
Top 10 most utilized triggers (by users).
(1) button press by DO_BUTTON (2904292 users)
(2) any new photo by you by INSTAGRAM (2296873 users)
(3) say a specific phrase by AMAZON_ALEXA (2088880 users)
(4) you enter an area by LOCATION (1933872 users)
(5) new feed item by FEED (1708995 users)
(6) any new note by DO_NOTE (1401746 users)
(7) every day at by DATE_AND_TIME (1261117 users)
(8) any new photo by DO_CAMERA (1196368 users)
(9) tomorrow’s forecast calls for by WEATHER (1194811 users)
(10) you exit an area by LOCATION (1022967 users)
Top 10 most utilized actions (by users).
(1) send a notification from the ifttt app by IF_NOTIFICATIONS
(6830526 users)
(2) send me an email by EMAIL (5282087 users)
(3) add row to spreadsheet by GOOGLE_SHEETS (4760448 users)
(4) quick add event by GOOGLE_CALENDAR (2460103 users)
(5) post a tweet by TWITTER (1868969 users)
(6) upload file from url by GOOGLE_DRIVE (1446966 users)
(7) add file from url by DROPBOX (1365485 users)
9 The URL access used by [70] and [66] to exhaustively crawl all recipes, including
those created by users and not advertised in channel pages, is no longer available.
However, the vast majority of the recipes collected in these studies are duplicates and
unpopular recipes. Our collection contains about 6,000 unique recipes, compared to Ur
et al.’s 16,000. The mean user adoption of recipes in our collection is 4,884 users and
the median is about 55 users, vs. Ur et al.’s mean of 52 and median of 1. This is at least
partly due to the growing adoption of IFTTT in general after the Ur et al. collection
was published.
(8) post a tweet with image by TWITTER (1318712 users)
(9) create a note by EVERNOTE (1225323 users)
(10) call my phone by PHONE_CALL (1178089 users)
Home/away trigger. We observe that location-based triggers are
among the most common, with over 500 apps and 3 million users
using them. The “location” trigger is provided by the IFTTT service
itself, not by a partner service. It uses the location capabilities of
the user’s phone to determine the area the user is in. To use it, the
IFTTT mobile app must be installed.
We manually examined the descriptions of 100 randomly chosen
apps that use location-based triggers (enter an area, leave an area,
enter or leave an area) to understand why they use location. Most
recipes use location for determining if the user is in a specific place:
home for 75, gym for 5, work for 2, and vacation for 2. Only 16
recipes do not specify the meaning of the location-based trigger.
For the majority of those, however, it appears that location is most
likely used for determining if the user is at home (e.g., “disarm your
alarm when you leave an area”).
C ESO EXAMPLES
To illustrate the range of situations that are useful for IoT access
control, we suggest (but do not implement) several ESOs in addition
to those described in Section 6.
User is away, using GPs and presence sensors. {situation_name:
HomeAway; ESO_description: “Home presence detection using
phone geolocation, Nest and SmartThings presence sensors.”}
Protected APIs, configuration: user is required to install an An-
droid app that uses location services, configure their location, and
indicate which sensors to use. If Nest is used, the ESO asks for the
Nest API token away and calls into the Nest API for the status of
the presence sensor, https://developer-api.nest.com/structures/h
ome_id/away10 (see Section A.2). Optionally, the user installs a
SmartThings SmartApp which requests the presenceSensor ca-
pability (see Section A.3), and (upon installation) asks the user for
access to all presence sensors in the home. Behavior: in addition to
geofencing-based tracking, this ESO also uses the presence-sensor
data from Nest and SmartThings. If presence was recently detected
and geofencing does not indicate that the user is at home, then the
phone app starts to actively query the location API (as opposed
to passively waiting for an “enter area” event). is_active() returns
“active” if the user is not at home, “not active” otherwise.
Notify user via push notifications.
{situation_name: Noti-
fyUser; ESO_description: “whenever access occurs, send the
user a push notification with the access details.”}
Protected APIs„ configuration: user is required to install an An-
droid app but does not need to approve any permissions beyond
normal ones needed for all apps. Behavior: is_active(s, a) sends
the user a push notification if there has been an access of subject s
with capability a. Always returns “active”.
Notify user via push notifications and smart lights.
{situation_name: NotifyUser; ESO_description: “Whenever
10This Nest API itself uses phone geolocation in addition to Nest sensors. Nest currently
does not offer third-party access to “raw” presence sensors. However, when the phone
location sensors indicate the user is away, and the in-house presence sensors detect
occupancy, this API will return an indication, which is useful for this ESO.
access occurs, send the user a push notification and blink
smart lights.”} Protected APIs, configuration: user is required
to install an Android app (none of its permissions require user au-
thorization) and a SmartThings app that uses the light capability.
Behavior: is_active(s, a) sends the user a push notification and
logs the fact that there has been an access of subject s with capabil-
ity a. Always returns “active”.
Use cases of “notify user” ESOs. This situation is useful in many
diverse, common scenarios. Our study of IFTTT recipes (see Sec-
tion 2.2) indicates that many users would like to be notified of
almost any possibly dangerous operation. Automatic user notifica-
tion is natural for accesses that are (a) infrequent and (b) require the
user’s attention anyway, e.g., taking pictures if a burglary has been
detected or a smart garage door opened when the user is away.
D OAUTH 2
OAuth 2access delegation flows. Delegation involves the user,
a user agent (e.g., browser, app), and the subject and object ser-
vices. The delegation flow begins when (1) the user-agent issues
a request to the subject service. Then, (2) user-agent is redirected
by the subject service to the object service. A request for a token
with a specified scope can be transmitted over the redirect request.
Then, (3) the object service “obtains an authorization decision (by
asking the resource owner or by establishing approval via other
means)” [39], and (4) redirects the user agent back to the subject
service. Then, (5) the access token is passed to the subject service
either over the final redirect request11 (implicit grant) or using di-
rect service-service communication (authorization code token grant).
The object service can return an access token with a scope different
from the requested scope (specifying the de-facto granted scope
in the “access token response” that relays the token from the ob-
ject to the subject). Finally, (6) the subject can access the protected
resource. Figure D.1 depicts the access delegation flow.
Optionally, a refresh token can be granted along with an access
token. The refresh token has a later expiry date and can be used to
fetch a fresh access token to replace an expired one.
Example: adding a Nest Cam Alexa skill To illustrate the rele-
vant OAuth 2functionality, consider a user who wishes to enable
the “Nest Cam” Alexa skill. This skill lets users control Nest Cam
via Amazon products, e.g., stream the camera feed directly to Ama-
zon Show, which is an Alexa terminal with a screen. The user can
install this skill from a skills market on the Amazon Web site. Since
Alexa accesses Nest Cam through its Web API, it requires the cor-
responding OAuth 2token. If it does not have the token already, it
initiates an OAuth 2flow to obtain the token. The Nest service then
authenticates the user (e.g., using a password or an authentication
cookie) and prompts her for approval. When the flow ends and if
permission was granted, the user is redirected back to the skills
market where she can continue to configure the skill.
On-demand permissioning. OAuth 2is popular because it is easy
for users and developers. OAuth 2delegation flows can be seamlessly
nested in any flow of the subject service where the user is involved.
They can begin whenever the user invokes an operation in the
11Not directly over the request but via an HTTP fragment field, obtainable by a service
script—see OAuth 2specification [39].
Figure D.1: OAuth 2access delegation
subject service that requires access to a third-party service. When
a delegation flow ends, the user is redirected back to continue the
original operation. In our example, when the flow ends, if the user
has approved Amazon’s access to the camera in some Nest account
and was redirected back to Amazon, the configuration flow can
continue seamlessly.
User approval and permission semantics. The process of obtain-
ing the user’s approval is not standardized in OAuth 2. Typically,
following user identification and authentication, the object website
displays an HTTP form to request the permission grant. It includes
a description of the requested permissions and the URL identifying
Amazon, and prompts the user for approval.