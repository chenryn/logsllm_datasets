3.x版本系统上，用户可以在UI图形界面中发送短消息。我们首先研究设备的文件系统以及逆向PE文件。
我们找到一个名称为“C2KMS.DL3”的文件，这个文件会读取短消息的文件内容，并将短消息传送到B83
CDMA模块进行发送。我们在这里更改了一个长度检查，但是我们不能完全控制数据。
所以我们需要进一步修改B83模块固件。我们在文件系统中找到了B83固件，在恢复文件格式之后，对它进行逆向分析。
非常幸运的是，首先B83子板基于PowerPC平台(一种精简指令集RISC的中央处理器架构)，而我们也有其固件对应的反编译器。其次，固件本身没有进行签名检查，只有CRC(循环冗余校验)。此外，二进制文件中符号表数据也保留着!
我们继续定位“buildSmsMsg”函数，并修改函数使得可以携带任意数据。然后我们刷新B83模块，此时我们就可以发送任意的PDU(协议数据单元)了。
现在我们将要尝试触发bug并使基带crash!我们该如何利用这个bug呢?这个过程也并不像看起来那么简单! 攻击payload是一条畸形的CDMA 1x
SMS传输层消息。其SMS_MSG_TYPE字段必须是00000000，表示SMS点对点消息。
该消息由TLV格式的参数组成，其中一些参数必须被设置正确才能确保触发有漏洞的函数，包括:
  * Teleservice Identifier(PARAMETER_ID 00000000)
  * Originating Address(PARAMETER_ID 00000010)
在这些参数中，Bearer Data(PARAMETER_ID 00001000)会在漏洞函数中被解析：
Bearer Data(PARAMETER_ID
00001000)在漏洞函数中被解析为由TLV格式的子参数组成的结构。为此我们必须适当地配置子参数以表示该消息为PRL消息。
类型为Message Display Mode (SUBPARAMETER_ID 00001111)的子参数最为关键，其中：
  * MSG_DISPLAY_MODE字段必须设为0x03
  * RESERVED字段必须设为0x10
漏洞代码的基本功能是对Bearer
Data中的子参数进行排序，缓冲区溢出就发生在该部分代码中。乍一看，这种利用似乎非常容易，因为没有NX/ASLR/Stack
Canary等保护措施，看起来就像90年代的典型栈溢出利用。但这是真的吗?
事实上，尽管有多条路径可以触发漏洞函数，但并不是所有的路径都可以通过空口消息触发。其中有一条路径可以通过空口消息触发，但是此时能够被溢出的那个缓冲区并不在栈上，而是在全局变量段中。还有另一条将缓冲区放在栈上的路径，但限制条件是只有当手机从USIM卡中读取短消息的时候才能触发，看上去对远程利用这个漏洞没什么帮助。到这里为止，所有的可能性都被考虑过了，但仍然没有发现任何明显可行的方法，似乎前方是一条没有出口的死路。
但永不放弃始终是我们的信条。通过对该部分逻辑更深刻地理解，我们最终找到了一条非常深但是十分稳定的路径。
基带处理PRL消息的整个过程如下：
  * 通过空口接收信息
  * 解码消息(第一次触发漏洞函数，但缓冲区不在栈上)
  * 编码消息
  * 将消息写入USIM卡
  * 从USIM卡中读出信息
  * 解码消息(第二次触发漏洞函数并且缓冲区在栈上)
Payload必须能通过第一次解码和编码的过程，并在第二次解码的过程中溢出栈缓冲区。为了构造这样的payload，我们需要一些简单的数学上的抽象：
  * Payload:x
  * 解码函数——dec(x)
  * 编码函数——enc(x)
  * 栈溢出ROP链:p
  * 目标:对于给定的p，找到一个x使得p = dec(enc(dec(x))) 让我们用更优雅、更数学的方法来解决这个数学问题。我们的目标变为: 对给定的p，找到一个x，使得p = dec(x)且x = enc(dec(x))
  * 这里的x也称为复合函数enc(dec(x))的不动点
因此可以很容易导出p = dec(x) =
dec(enc(dec(x)))，正是我们想要的结果。通过这种方法构造的payload适用于任意多次的解码和编码过程，而不仅仅是一两次。此外，CMU200设备限制TP层消息（也就是我们的payload）的长度必须小于等于130字节，更给我们的构造过程增加了难度。
事实证明，构造这个Payload并不是一帆风顺的，但它是可以实现的!
更多细节请阅读我们的白皮书。我们也把这个漏洞的利用过程改编成了今年TCTF预选赛中的一道pwnable题目——Mighty
Dragon，其名字正是来源于基带的代号“霸龙”。在当时的比赛中仅有一支队伍解出了这道题目，可见这道题是非常有挑战性的，欢迎感兴趣的小伙伴踊跃尝试，关注微信号“KeenSecurityLab”并回复“Mighty
Dragon”获取题目下载链接。
在我们实现漏洞利用之后，我们如何展示呢?我们不能像在Windows上那样运行一个calc.exe计算器可执行程序来进行演示。最终，我们决定将手机IMEI修改成1337XXX，这样我们可以从手机设置UI看到修改后的变化。
在成功得到基带中的代码执行能力后，我们可以得到很多信息，比如间谍短信，电话，互联网流量，甚至可以修改这些信息。尽管比赛没有要求完成基带绕过，但许多其他研究人员的研究结果表明这是可以实现的。例如Project
Zero的Gal使用WiFi芯片中的DMA来修改内核内存，Comsecuris使用MTK基带中的路径遍历来覆盖AP中的文件。这也和浏览器漏洞类似，在实现第一个RCE(远程代码执行)之后，你可以结合沙箱逃逸漏洞构建完整的攻击链。基带在实现第一个RCE之后，也可以构建一条基带逃逸攻击链，并得到完整的系统控制。
最后，我们想和大家说的是，只要你足够坚定，在现代基带实现远程终端控制是完全有可能的。这种攻击也是真实的存在的。究其根本，一方面基带是由内存不安全的语言编写的，因此无法避免内存破坏问题，另一方面，基带安全也一直没有受到足够的重视。
我们也希望基带在未来的部署中可以考虑更多安全缓解措施，也许将来也会用内存安全的语言编写基带。
* * *