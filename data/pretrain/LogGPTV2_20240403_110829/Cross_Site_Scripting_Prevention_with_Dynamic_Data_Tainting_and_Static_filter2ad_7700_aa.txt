title:Cross Site Scripting Prevention with Dynamic Data Tainting and Static
Analysis
author:Philipp Vogt and
Florian Nentwich and
Nenad Jovanovic and
Engin Kirda and
Christopher Kr&quot;ugel and
Giovanni Vigna
Cross-Site Scripting Prevention with
Dynamic Data Tainting and Static Analysis
Philipp Vogt§, Florian Nentwich§, Nenad Jovanovic§,
Engin Kirda§, Christopher Kruegel§, and Giovanni Vigna‡
§ Secure Systems Lab
Technical University Vienna
{pvogt,fnentwich,enji,ek,chris}@seclab.tuwien.ac.at
‡ University of California, Santa Barbara
PI:EMAIL
Abstract
Cross-site scripting (XSS) is an attack against web ap-
plications in which scripting code is injected into the output
of an application that is then sent to a user’s web browser.
In the browser, this scripting code is executed and used to
transfer sensitive data to a third party (i.e., the attacker).
Currently, most approaches attempt to prevent XSS on the
server side by inspecting and modifying the data that is ex-
changed between the web application and the user. Un-
fortunately, it is often the case that vulnerable applications
are not ﬁxed for a considerable amount of time, leaving the
users vulnerable to attacks. The solution presented in this
paper stops XSS attacks on the client side by tracking the
ﬂow of sensitive information inside the web browser. If sen-
sitive information is about to be transferred to a third party,
the user can decide if this should be permitted or not. As
a result, the user has an additional protection layer when
surﬁng the web, without solely depending on the security of
the web application.
1 Introduction
Nowadays, many web sites make extensive use of client-
side scripts (mostly written in JavaScript) to enhance user
experience. Unfortunately, this trend has also increased the
popularity and frequency of cross-site scripting (XSS) at-
tacks. When a cross-site scripting vulnerability is present in
a web application, an attacker can inject scripting code into
the pages generated by the web application. Such situations
can arise, for example, due to lacking security awareness
on part of the developers, or due to programming mistakes
induced by ﬁnancial and time constraints. This allows an
attacker to circumvent the same-origin policy [19], which
states that scripts loaded from a certain domain cannot ac-
cess data belonging to any other domain.
In XSS attacks, the same-origin policy is circumvented
because when the victim’s browser receives the generated
output page, the maliciously-injected code is executed in
the context of the site hosting the vulnerable web applica-
tion, and, therefore, it has access to sensitive data stored by
that site in the victim’s browser (e.g., using cookies). Usu-
ally, the attack code transfers the sensitive information to a
server under the attacker’s control. This information allows
the attacker to impersonate the victim or hijack the victim’s
current session.
There are two general methods for injecting malicious
In
code into the web page that is displayed to the user.
the ﬁrst method, called stored XSS, the attacker persistently
stores the malicious code in a resource managed by the web
application, such as a database. The actual attack is carried
out at a later time, when the victim requests a dynamic page
that is constructed from the contents of this resource. As an
example, consider a web-based bulletin board system (e.g.,
phpBB [25]) where people can post messages that are dis-
played to all visitors of the bulletin board. Let us assume
further that the application does not remove script content
from posted messages. In this case, the attacker can craft
a message similar to the one in Figure 1. This message
contains the malicious JavaScript code, which the bulletin
board stores in its database. A visiting user who reads this
message retrieves the scripting code as part of the message.
The user’s browser then executes the script, which, in turn,
Look at this picture!
Figure 1. Transfer of a cookie.
sends the user’s cookie to a server under the attacker’s con-
trol.
In the second method, called reﬂected XSS, the attack
script is not persistently stored, but, instead, it is immedi-
ately “reﬂected” back to the user. For instance, consider
a search form that includes the search query into the page
with the results, but without ﬁltering the query for scripting
code. This vulnerability can be exploited, for example, by
sending to the victim an email with a specially-crafted link
that points to the search form and that contains the mali-
cious JavaScript code. By tricking the victim into clicking
this link, the search form is submitted with the JavaScript
code as the query string, and the attack script is immedi-
ately sent back (reﬂected) to the victim, as part of the web
page with the results.
The optimal approach to prevent XSS attacks would be
to eliminate the vulnerabilities in the affected web applica-
tions. To this end, a web application must properly vali-
date all input, and in particular, remove malicious scripts.
The problem is that many service providers do not ﬁx their
web applications in a timely way. Hence, a promising ap-
proach for protecting users against XSS attacks is to deploy
the necessary security mechanisms on the client side.
In contrast
to traditional,
The solution proposed in this paper uses dynamic data
tainting.
tainting-based ap-
proaches on the server side, we taint sensitive information
on the client side. The goal is to ensure that a JavaScript
program can send sensitive information only to the site from
which it was loaded. To this end, the information ﬂow of
sensitive data is tracked inside the JavaScript engine of the
browser. Whenever an attempt to relay such information
to a third party (i.e., the adversary) is detected, the user is
warned and given the possibility to stop the transfer.
Unfortunately, it is not possible to detect all information
ﬂows dynamically [27]. This is a problem, because the ad-
versary has complete freedom to craft his attack code, and,
therefore, he could leverage information ﬂows that are not
covered by dynamic analysis to successfully launch XSS
attacks. To address this limitation, we complement our dy-
namic mechanism with an additional static analysis compo-
nent. This static analysis component is invoked on-demand
and covers those cases that cannot be decided dynamically.
Using a combination of static and dynamic analysis, we can
combine the advantages of both approaches. The dynamic
analysis allows us to precisely track sensitive information
with low runtime overhead. By switching to static analysis
when necessary, our system can provide stronger security in
the face of malevolent attack code.
To demonstrate that our approach is capable of solv-
ing real-world problems, we integrated a prototype imple-
mentation of our techniques into the popular Firefox web
browser (which turned out to be a considerable engineering
effort). By further equipping Firefox with a web crawler
capable of simulating user actions, we were able to conduct
a large-scale and fully automatic evaluation of our system
on more than one million web pages. The empirical results
demonstrate that our approach provides reliable protection
against XSS attacks in real-world usage, with a low false
positive rate.
To summarize, the contributions of this paper are as follows:
• A dynamic taint analysis and a complementary static
analysis that prevent XSS attacks by monitoring the
ﬂow of sensitive information in the web browser.
• The integration of the analyses into the popular Firefox
web browser.
• The development of a Firefox-based web crawler ca-
pable of simulating user actions. This allowed us to
perform a large-scale empirical validation of our tech-
niques based on the automatic browsing of more than
one million web pages.
The rest of this paper is structured as follows. In Sec-
tion 2, we present related work on detecting and preventing
XSS attacks. In Section 3, we introduce our dynamic anal-
ysis technique. Then, in Section 4, we extend our approach
using static techniques. Sections 5 and 6 discuss how in-
formation could be leaked to an adversary and some imple-
mentation issues, respectively. Section 7 presents the eval-
uation of our prototype, and, ﬁnally, Section 8 concludes.
2 Related Work
There are two main criteria that can be used for dis-
tinguishing between XSS protection techniques: The point
of deployment (client-side or server-side), and the analysis
paradigm in use (dynamic or static).
Server-side protection. A well-known, dynamic server-
side protection mechanism is Perl’s taint mode [3]. In this
case, the ﬂow of tainted values is tracked within the Perl
interpreter. More precisely, input from untrusted sources
is marked as being potentially malicious, and propagated
through the program. Any attempt to use tainted data di-
rectly or indirectly in a critical command that invokes a sub-
shell, modiﬁes ﬁles, directories, or processes will be aborted
with an error. The developer is given means to test the taint
status of data, as well as the ability to sanitize (i.e., un-
taint) the data where this seems appropriate. Analogously,
interpreter-based approaches for PHP are presented in [23]
and [26]. Dynamic taint propagation for the Java virtual
machine is employed in [10].
A dynamic taint-tracking scheme for C programs uti-
lizing source-to-source transformation is described in [30].
Here, the scope of protection ranges from classical buffer
overﬂow and format string vulnerabilities to the detection
of XSS and other types of injection attacks. Their method
is also applicable to scripting languages implemented in C,
such as PHP and Bash. In addition, there also exist dynamic
tainting approaches that do not deal with XSS attacks, but
focus on the detection of attacks that attempt to overwrite
sensitive program data (such as return addresses or function
pointers). For instance, in [22], binaries are rewritten at run-
time to allow for taint propagation. Hardware approaches
that dynamically track the propagation of taint values at the
architectural level are presented in [6] and [28].
In [15], an anomaly-based intrusion detection system is
presented that can detect XSS attacks. To this end, the sys-
tem analyzes web server logs and automatically retrieves
the proﬁles (length and structure) of typical parameters of
any protected web application. These proﬁles are then com-
pared to incoming user requests, such that requests with
atypical parameter proﬁles can be classiﬁed as potential at-
tacks.
Apart from the dynamic techniques mentioned so far,
static analysis can be used to detect XSS vulnerabilities on
the server side. In [16], the authors propose a static anal-
ysis approach for web applications in order to detect XSS
vulnerabilities. The analysis results are then cross-checked
with dynamic techniques to eliminate false warnings. A
technique based on data ﬂow analysis for detecting XSS and
similar vulnerabilities (such as SQL injection or command
injection) is presented in [13].
Client-side protection. There exist a few approaches
that, similarly to our solution, try to solve the problem on
the client side. In [12], the authors implemented a proxy
that can be used to protect a user while surﬁng the web.
To this end, the proxy analyzes the HTTP trafﬁc exchanged
between the user’s browser and the contacted web server.
First, client requests are scanned for special HTML char-
acters (such as the "<" character). Then, if the applica-
tion’s response reﬂects these presumably-malicious request
parameters back to the user, the web site is considered to
be vulnerable to XSS. As a result, these special characters
are encoded before the response is delivered to the user’s
browser, which disables the attempted attack. A limitation
of this approach is that it is focused on reﬂected XSS at-
tacks, and does not permit the detection and prevention of
stored XSS attacks.
The application-level ﬁrewall described in [14] analyzes
browsed HTML pages for hyperlinks that might lead to the
leakage of sensitive data. Based on this analysis, a set of
connection rules is generated on-the-ﬂy that prevents sus-
picious requests. The main idea behind this technique is
that sensitive information can be transmitted either by a
single link that is constructed dynamically inside the user’s
browser, or by several static links.
In [11], the Mozilla web browser is equipped with an
auditing system that monitors the execution of JavaScript
code. Using different intrusion detection techniques, the
observed operations are compared to high-level policies to
detect malicious behavior.
The main difference between our solution and other
client-based approaches is that they use various heuristics
for XSS detection, whereas we perform an in-depth and pre-
cise analysis of how sensitive values are propagated inside
the user’s browser. Using a combination of dynamic and
static analyses, we can efﬁciently identify implicit informa-
tion ﬂows that purely dynamic approaches cannot identify.
3 Dynamic Data Tainting
In a cross-site scripting attack, the code that is injected
into the output of the web application is under the attacker’s
control. This code is executed in the user’s web browser,
where it collects sensitive information that is then sent to
the attacker. Because the code runs in the context of the
vulnerable web site, it is not distinguishable from normal
application behavior.
The goal of our protection approach is to prevent that
sensitive data is sent to a third party (the adversary) with-
out the user’s consent. To this end, we designed a mech-
anism that can keep track of how sensitive data is used in
the browser. Our mechanism is based on the concept of dy-
namic data tainting, in which sensitive data is ﬁrst marked
(or tainted), and then, when this data is accessed by scripts
running in the web browser, its use is dynamically tracked
by our system. When tainted data is about to be transferred
to a third party, different kinds of actions can be taken. Ex-
amples are logging, preventing the transfer, or stopping the
program with an error. Note that it is sufﬁcient to model
the taint value associated with a piece of data as a simple
boolean ﬂag. In particular, it is not necessary to explicitly
store the domain that this data originated from (to be able to
distinguish the source domain from a third party domain),
as this information can be retrieved from the browser.
Our taint analysis is capable of tracking data dependen-
cies. That is, when a tainted value is assigned to another
variable, this variable becomes tainted as well. Also, when
any operand of an arithmetic or logic operation is tainted,
the result becomes tainted. Moreover, our solution is capa-
ble of handling direct control dependencies. That is, when-
Object
Document
Form
Any form input element
History
Select option
Location and Link
Window
Tainted properties
cookie, domain, forms, lastModiﬁed, links, referrer, title,
URL
action
checked, defaultChecked, defaultValue, name,
selectedIndex, toString, value
current, next, previous, toString
defaultSelected, selected, text, value