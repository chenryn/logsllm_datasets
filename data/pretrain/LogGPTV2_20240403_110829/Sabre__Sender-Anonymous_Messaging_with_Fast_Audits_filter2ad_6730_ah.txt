are two possibilities: either the leftmost subtree is rooted at
a 1-node and the rightmost subtree is rooted at a 0-node, or
vice versa. In both cases, one subtree has only type-0 leaves,
while, by the inductive hypothesis, the other subtree has a
single type-1 leaf with all others being of type 0.
â–¡
B. Du-Atallah (2+1)-party multiplication
Du-Atallah multiplication [13] is a (2 + 1)-party variant
of the well-known Beaver-triplet multiplication [4]. Suppose
servers 0 and 1 hold (2,2)-additive sharings [ğ‘¥] and [ğ‘¦]; their
goal is to compute a sharing [ğ‘¥ğ‘¦] of the product ğ‘¥ Â·ğ‘¦.
To this end, a semi-trusted third party samples the 5-
tuple (ğ‘Ÿ0, ğ‘Ÿ1, ğ‘ 0, ğ‘ 1, ğ‘¡) uniformly and sends (ğ‘Ÿ0, ğ‘ 0, ğ‘Ÿ0ğ‘ 1 + ğ‘¡) and
(ğ‘Ÿ1, ğ‘ 1, ğ‘Ÿ1ğ‘ 0 âˆ’ ğ‘¡) to servers 0 and 1. Server 0 uses ğ‘Ÿ0, ğ‘ 0 to
blind its shares, sending the pair ([ğ‘¥]0 + ğ‘Ÿ0, [ğ‘¦]0 + ğ‘ 0) to
server 1; meanwhile, server 1 sends ([ğ‘¥]1 + ğ‘Ÿ1, [ğ‘¦]1 + ğ‘ 1)
to server 0. Finally, server 0 outputs [ğ‘¥ğ‘¦]0 (cid:66) [ğ‘¥]0
[ğ‘¥ğ‘¦]1 (cid:66) [ğ‘¥]1
easy to check that [ğ‘¥ğ‘¦]0 + [ğ‘¥ğ‘¦]1 = ğ‘¥ Â· ğ‘¦, as desired.
(cid:0)[ğ‘¦]0 +
([ğ‘¥]1 + ğ‘Ÿ1)(cid:1) âˆ’ ğ‘ 0([ğ‘¥]1 + ğ‘Ÿ1) + (ğ‘Ÿ0ğ‘ 1 + ğ‘¡) and server 1 outputs
(cid:0)[ğ‘¦]1 + ([ğ‘¥]0 + ğ‘Ÿ0)(cid:1) âˆ’ ğ‘ 1([ğ‘¥]0 + ğ‘Ÿ0) + (ğ‘Ÿ1ğ‘ 0 âˆ’ ğ‘¡). It is
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 14:58:18 UTC from IEEE Xplore.  Restrictions apply. 
141966
)
s
m
(
e
m
i
t
k
c
o
l
c
-
l
l
a
W
30
20
10
0
ğ‘› = 212
2
17
10
22 25
Number of s-boxes
(a) 2-verifier SNIP auditing
32
ğ‘› = 214
160
120
80
40
0
2
)
s
m
(
e
m
i
t
k
c
o
l
c
-
l
l
a
W
ğ‘› = 216
ğ‘› = 218
)
B
M
i
(
e
z
i
s
f
o
o
r
P
17
10
22 25
Number of s-boxes
(b) Full-domain evaluation
32
1.5
1.0
0.5
2
10
22 25
Number of s-boxes
17
(c) Proof size
32
Fig. 9: 2-verifier SNIP auditing time, full-domain evaluation time, and proof size versus number of LowMC s-boxes.
d
n
o
c
e
s
/
s
e
i
r
e
u
Q
103
102
101
100
10âˆ’1
212
Sabre-M0 (1 KiB)
Sabre-M2 (1 KiB)
Sabre-M1 (1 KiB)
Sabre-M (1 KiB)
214
Number of mailboxes (ğ‘›)
216
218
Fig. 10: Throughtput of Sabre-M variants (1 KiB messages)
C. LowMC parameter selection
LowMC contains several tuning knobs allowing tradeoffs
among the total number of multiplications (i.e., s-boxes per
round), multiplicative depth (number of rounds), and wall-
clock running time. Roughly speaking, optimizing for total
number of multiplications minimizes overall communication
cost (for MPC-based auditing) and proof size (for SNIP-
based auditing), whereas optimizing for multiplicative depth
minimizes round complexity (for MPC-based auditing) or
proof verification time (for SNIP-based auditing). For our
Sabre implementation, we chose to optimize for multiplica-
tive depth by maximizing the number of s-boxes per round.
Figure 9 presents empirical evidence to justify this choice;
specifically, Figures 9a-9c respectively plot the wall-clock
time for 2-verifier SNIP auditing, the wall-clock running time
for full-domain DPF evaluation, and the expected size of 2-
verifier SNIPs for various settings of the â€œs-boxes per roundâ€
tuning knob and numbers of buckets/mailboxes. The graphs
show that optimizing for multiplicative depth is essentially
pessimal for auditing but optimal for full-domain evaluation,
which is the bottleneck operation in all Sabre variants.
D. Stepping stones to Sabre-M
This appendix describes the â€œstepping stonesâ€ that led to
the development Sabre-M.
1) Sabre-M0: Express with improved auditing: Consider a
Sabre-M0 instance with security parameter ğœ† âˆˆ N (say,
ğœ† = 128). The design of Sabre-M0 tightly parallels that
of Express, save for the new audit protocol. In a registra-
tion phase, the recipient contacts the servers to create a
âˆˆ
(F
2ğ¿)1Ã—ğ‘›
mailbox and receives a uniform random, ğœ†-bit address in
exchange. Suppose there are ğ‘› registered mailboxes with
addresses addr1, . . . , addrğ‘›. To deposit a message ğ‘€ âˆˆ F
2ğ¿
into the mailbox addressed by addrğ‘–, the sender samples
(dpf0, dpf1) â† Gen(1ğœ†, F
2ğ¿; addrğ‘–, ğ‘€) and then it sends
2ğœ†, F
dpfğ‘ to server ğ‘ for ğ‘ = 0, 1.
Upon receiving dpfğ‘, server ğ‘ constructs the vector
in which the ğ‘— th component equals
ğ‘€ğ‘
Eval(dpfğ‘, addrğ‘—); server ğ‘ adds ğ‘€ğ‘ to its mailbox database
to effectuate the write. We stress that (as in Expressâ€”owing
to the sparsity of the set of mailbox addresses within {0, 1}ğœ†)
Boyle et al.â€™s full-domain evaluation procedure does not apply
when computing ğ‘€ğ‘. Instead, each column requires O(ğœ†)
length-doubling PRG evaluations (for a total of O(ğœ†ğ‘›) evalua-
tions), plus one evaluation of the leaf-stretching PRG.
As per Definition 4, ğ‘€0 + ğ‘€1 âˆˆ (F
2ğ¿)1Ã—ğ‘› has message ğ‘€
in its ğ‘– th column and zero elsewhereâ€”provided the sender
generated (dpf0, dpf1) honestly, which the servers confirm via
any of the three audit protocol instantiations. Sabre-M0 very
quickly rejects malformed DPFs outright, whereas (like in
Express) otherwise well-formed DPFs whose distinguished
points do not correspond to registered mailbox addresses
will pass auditing, ultimately resulting in a (comparatively
expensive) no-operation â€œupdateâ€ to the mailbox database. In
particular, such well-formed, yet bogus writes incur the same
decidedly non-trivial cost as â€œtrueâ€ writes.
2) Sabre-M1: Sabre-M0 with shorter DPFs: Sabre-M1 pro-
vides a modest improvement over Sabre-M0 by dynamically
â€œtruncatingâ€ mailbox addresses to a prefix just long enough to
avoid collisions with high probability, thereby reducing both
(i) the size of (and cost of auditing) the keys dpf0 and dpf1
and (ii) the cost of computing ğ‘€0 and ğ‘€1 from them.
Upon registering a mailbox, the recipient still receives a
uniform random, ğœ†-bit mailbox address that senders must
know (in its entirety) to deposit messages into the mailbox.
The difference is that now only a prefix of this address (whose
length grows with the number of registered mailboxes) is
used when sampling and evaluating DPFs. The intuition here
is thatâ€”for purposes of correctnessâ€”it suffices merely to
guarantee that no two mailboxes map to the same prefix;
thus, one can compute the required prefix length for a given
number of registered mailboxes using a standard birthday
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 14:58:18 UTC from IEEE Xplore.  Restrictions apply. 
151967
bound calculation. (In our experiments in Section VII-D, we
chose the length to ensure that the probability of one or more
prefix collisions is strictly less than 0.001.)
This optimization improves efficiency relative to Sabre-M0.
However, it comes at the cost of increasing the probability of
an attacker â€œguessingâ€ a distinguished point corresponding to
a valid mailboxâ€”that is, random guesses potentially clobber a
registered mailbox with a probability that is now polynomial
in ğ‘›. To mitigate, Sabre-M1 requires the sender to transmit
an additive share [addr] of the full mailbox address alongside
dpfğ‘, after which the servers use a simple PIR-based protocol
to verify that the address shares reconstruct to the full
address of whatever mailbox the DPF keys reference.
Specifically, servers 0 and 1 hold in common an associative
array (key-value store) mapping each distinguished input to
its corresponding mailbox addresses. Let ğ· denote the set of
distinguished inputs reflected in the associative array and,
for each ğ‘– âˆˆ ğ·, let flag(ğ‘–)
ğ‘ denote the advice bit for the ğ‘– th leaf
of dpfğ‘ (see Section V-A). By construction, if (dpf0, dpf1) is
a valid DPF key pair, then flag(ğ‘–)
if and only if the
distinguished point is ğ‘–; thus, server ğ‘ outputs
0 = flag(ğ‘–)
1
[addrâ€²]ğ‘ (cid:66)
ğ‘–âˆˆğ·, ğ‘¡ (ğ‘)
ğ‘– =1 addrğ‘–
so that [addrâ€²]0 + [addrâ€²]1 = addrğ‘– over F
2ğœ†. The server
verify that this computed address [addrâ€²] matches the clientâ€™s
claimed address [addr] by checking that [addr]0 + [addrâ€²]0 =
[addr]1 + [addrâ€²]1.
The full-domain evaluation procedure still does not ap-
ply when computing ğ‘€ğ‘ in Sabre-M1; however, now the
cost of computing each column reduces from O(ğœ†) to just
O(poly(lg ğ‘›)) length-doubling PRG evaluations (reducing the
total cost of computing ğ‘€ğ‘ from O(ğ‘› ğœ†) to just O(ğ‘›poly(lg ğ‘›))
evaluations), plus ğ‘› evaluations of the leaf-stretching PRG.
Furthermore, the servers can now detect and reject DPFs
from senders who do not know a registered mailbox ad-
dress without incurring a costly no-operation to â€œupdateâ€ the
database.
3) Sabre-M2: Sabre-M1 with decoupled address checking:
Sabre-M2 improves on Sabre-M1 by eliminating the asso-
ciation between DPF leaves and mailbox addresses: Instead
of sampling DPFs whose distinguished points correspond to
mailbox addresses, senders sample DPFs whose distinguished
points correspond to the chronological order in which those
mailboxes were registered. In other words, to deposit a mes-
sage ğ‘€ âˆˆ F
2ğ¿ into the mailbox with address addrğ‘–, a sender
samples keys for a DPF with point (ğ‘–, ğ‘€) âˆˆ {0, . . . , ğ‘›âˆ’1}Ã—F
2ğ¿
rather than (addrğ‘–, ğ‘€) âˆˆ F
2ğ¿. With this optimization,
(i) the domain of DPFs has size equal to the number of regis-
tered mailboxes, and (ii) the full-domain evaluation procedure
applies when computing the ğ‘€ğ‘. This reduces the total cost of
computing ğ‘€ğ‘ to just ğ‘› âˆ’ 1 length-doubling PRG evaluations
plus ğ‘› evaluations of the leaf-stretching PRG. To ensure that
senders know the correct mailbox address, Sabre-M2 inherits
the PIR-based address checking of Sabre-M1.
4) Sabre-M: Sabre-M2 with O(1)-time address checking:
Sabre-M improves on Sabre-M2 by replacing the linear-com-
2ğœ† Ã— F
plexity PIR-based address check with a constant-complexity
PRF-based one described in Section IV. With this modification
in place, the entire auditing procedureâ€”that is, both checking
the well-formedness of the DPF and checking the validity of
the mailbox addressâ€”has complexity logarithmic in ğ‘›, allow-
ing the servers to rapidly reject bogus write requests from a
would-be resource-exhaustion DoS attacker. The benefits of
rapid auditing are shown in our experimental evaluation in
Section VII.
Figure 10 plots the throughput of each Sabre-M variant.
Notice that the plots for Sabre-M2 and Sabre-M overlap al-
most perfectly; we stress that this neck-to-neck performance
is an artifact of all writes being valid.
E. Proof of Theorem 3 (from Section V-B2)
Theorem 3 (Restatement). The 3-verifier SNIP auditing
protocol with hash function Hash: {0, 1}âˆ— â†’ {0, 1}ğœ‡ is per-
fectly simulatable and has perfect completeness and soundness
overwhelming in ğœ‡.
Proof (sketch). Perfect simulatability and completeness are
immediate consequences of the perfect simulatability and
completeness of (2+1)-party auditing. To see that soundness
is indeed overwhelming in ğœ‡, it suffices to note that since the
three verifiers collectively scrutinize all three partiesâ€™ views
from a simulated (2 + 1)-party audit, inconsistencies in the