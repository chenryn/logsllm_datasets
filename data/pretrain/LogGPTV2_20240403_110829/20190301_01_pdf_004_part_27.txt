IS
BEGIN
IF (p_amount > p_balance) THEN
RAISE overdrawn;
END IF;
END;
The following procedure (purchase) calls the check_balance procedure. If
p_amount is greater than p_balance, check_balance raises an exception; purchase
catches the ar.overdrawn exception. purchase must refer to the exception with a
package-qualified name (ar.overdrawn) because purchase is not defined within the
ar package.
CREATE PROCEDURE purchase(customerID INT, amount NUMERIC)
AS
BEGIN
ar.check_ balance(getcustomerbalance(customerid), amount);
record_purchase(customerid, amount);
EXCEPTION
WHEN ar.overdrawn THEN
raise_credit_limit(customerid, amount*1.5);
END;
When ar.check_balance raises an exception, execution jumps to the exception
handler defined in purchase:
EXCEPTION
WHEN ar.overdrawn THEN
raise_credit_limit(customerid, amount*1.5);
The exception handler raises the customer’s credit limit and ends. When the exception
handler ends, execution resumes with the statement that follows ar.check_balance.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 231
Database Compatibility for Oracle® Developers Guide
3.5.9 PRAGMA EXCEPTION_INIT
PRAGMA EXCEPTION_INIT associates a user-defined error code with an exception. A
PRAGMA EXCEPTION_INIT declaration may be included in any block, sub-block or
package. You can only assign an error code to an exception (using PRAGMA
EXCEPTION_INIT) after declaring the exception. The format of a PRAGMA
EXCEPTION_INIT declaration is:
PRAGMA EXCEPTION_INIT(exception_name,
{exception_number | exception_code})
Where:
exception_name is the name of the associated exception.
exception_number is a user-defined error code associated with the pragma. If you
specify an unmapped exception_number, the server will return a warning.
exception_code is the name of a pre-defined exception. For a complete list of valid
exceptions, see the Postgres core documentation available at:
https://www.postgresql.org/docs/11/static/errcodes-appendix.html
The previous section (User-defined Exceptions) included an example that demonstrates
declaring a user-defined exception in a package. The following example uses the same
basic structure, but adds a PRAGMA EXCEPTION_INIT declaration:
CREATE OR REPLACE PACKAGE ar AS
overdrawn EXCEPTION;
PRAGMA EXCEPTION_INIT (overdrawn, -20100);
PROCEDURE check_balance(p_balance NUMBER, p_amount NUMBER);
END;
CREATE OR REPLACE PACKAGE BODY ar AS
PROCEDURE check_balance(p_balance NUMBER, p_amount NUMBER)
IS
BEGIN
IF (p_amount > p_balance) THEN
RAISE overdrawn;
END IF;
END;
The following procedure (purchase) calls the check_balance procedure. If
p_amount is greater than p_balance, check_balance raises an exception; purchase
catches the ar.overdrawn exception.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 232
Database Compatibility for Oracle® Developers Guide
CREATE PROCEDURE purchase(customerID int, amount NUMERIC)
AS
BEGIN
ar.check_ balance(getcustomerbalance(customerid), amount);
record_purchase(customerid, amount);
EXCEPTION
WHEN ar.overdrawn THEN
DBMS_OUTPUT.PUT_LINE ('This account is overdrawn.');
DBMS_OUTPUT.PUT_LINE ('SQLCode :'||SQLCODE||' '||SQLERRM );
END;
When ar.check_balance raises an exception, execution jumps to the exception
handler defined in purchase.
EXCEPTION
WHEN ar.overdrawn THEN
DBMS_OUTPUT.PUT_LINE ('This account is overdrawn.');
DBMS_OUTPUT.PUT_LINE ('SQLCode :'||SQLCODE||' '||SQLERRM );
The exception handler returns an error message, followed by SQLCODE information:
This account is overdrawn.
SQLCODE: -20100 User-Defined Exception
The following example demonstrates using a pre-defined exception. The code creates a
more meaningful name for the no_data_found exception; if the given customer
does not exist, the code catches the exception, calls DBMS_OUTPUT.PUT_LINE to report
the error, and then re-raises the original exception:
CREATE OR REPLACE PACKAGE ar AS
overdrawn EXCEPTION;
PRAGMA EXCEPTION_INIT (unknown_customer, no_data_found);
PROCEDURE check_balance(p_customer_id NUMBER);
END;
CREATE OR REPLACE PACKAGE BODY ar AS
PROCEDURE check_balance(p_customer_id NUMBER)
IS
DECLARE
v_balance NUMBER;
BEGIN
SELECT balance INTO v_balance FROM customer
WHERE cust_id = p_customer_id;
EXCEPTION WHEN unknown_customer THEN
DBMS_OUTPUT.PUT_LINE('invalid customer id');
RAISE;
END;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 233
Database Compatibility for Oracle® Developers Guide
3.5.10 RAISE_APPLICATION_ERROR
The procedure, RAISE_APPLICATION_ERROR, allows a developer to intentionally abort
processing within an SPL program from which it is called by causing an exception. The
exception is handled in the same manner as described in Section 3.5.7. In addition, the
RAISE_APPLICATION_ERROR procedure makes a user-defined code and error message
available to the program which can then be used to identify the exception.
RAISE_APPLICATION_ERROR(error_number, message);
Where:
error_number is an integer value or expression that is returned in a variable named
SQLCODE when the procedure is executed. error_number must be a value between
-20000 and -20999.
message is a string literal or expression that is returned in a variable named SQLERRM.
For additional information on the SQLCODE and SQLERRM variables, see Section 3.13,
Errors and Messages.
The following example uses the RAISE_APPLICATION_ERROR procedure to display a
different code and message depending upon the information missing from an employee.
CREATE OR REPLACE PROCEDURE verify_emp (
p_empno NUMBER
)
IS
v_ename emp.ename%TYPE;
v_job emp.job%TYPE;
v_mgr emp.mgr%TYPE;
v_hiredate emp.hiredate%TYPE;
BEGIN
SELECT ename, job, mgr, hiredate
INTO v_ename, v_job, v_mgr, v_hiredate FROM emp
WHERE empno = p_empno;
IF v_ename IS NULL THEN
RAISE_APPLICATION_ERROR(-20010, 'No name for ' || p_empno);
END IF;
IF v_job IS NULL THEN
RAISE_APPLICATION_ERROR(-20020, 'No job for' || p_empno);
END IF;
IF v_mgr IS NULL THEN
RAISE_APPLICATION_ERROR(-20030, 'No manager for ' || p_empno);
END IF;
IF v_hiredate IS NULL THEN
RAISE_APPLICATION_ERROR(-20040, 'No hire date for ' || p_empno);
END IF;
DBMS_OUTPUT.PUT_LINE('Employee ' || p_empno ||
' validated without errors');
EXCEPTION
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 234
Database Compatibility for Oracle® Developers Guide
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('SQLCODE: ' || SQLCODE);
DBMS_OUTPUT.PUT_LINE('SQLERRM: ' || SQLERRM);
END;
The following shows the output in a case where the manager number is missing from an
employee record.
EXEC verify_emp(7839);
SQLCODE: -20030
SQLERRM: EDB-20030: No manager for 7839
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 235
Database Compatibility for Oracle® Developers Guide
3.6 Transaction Control
There may be circumstances where it is desired that all updates to a database are to occur
successfully, or none are to occur at all if any error occurs. A set of database updates that
are to all occur successfully as a single unit, or are not to occur at all, is said to be a
transaction.
A common example in banking is a funds transfer between two accounts. The two parts
of the transaction are the withdrawal of funds from one account, and the deposit of the
funds in another account. Both parts of this transaction must occur otherwise the bank’s
books will be out of balance. The deposit and withdrawal are one transaction.
An SPL application can be created that uses a style of transaction control compatible with
Oracle databases if the following conditions are met:
 The edb_stmt_level_tx parameter must be set to TRUE. This prevents the
action of unconditionally rolling back all database updates within the BEGIN/END
block if any exception occurs. See Section 1.3.4 for more information on the
edb_stmt_level_tx parameter.
 The application must not be running in autocommit mode. If autocommit mode is
on, each successful database update is immediately committed and cannot be
undone. The manner in which autocommit mode is turned on or off is application
dependent.
A transaction begins when the first SQL command is encountered in the SPL program.
All subsequent SQL commands are included as part of that transaction. The transaction
ends when one of the following occurs:
 An unhandled exception occurs in which case the effects of all database updates
made during the transaction are rolled back and the transaction is aborted.
 A COMMIT command is encountered in which case the effect of all database
updates made during the transaction become permanent.
 A ROLLBACK command is encountered in which case the effects of all database
updates made during the transaction are rolled back and the transaction is aborted.
If a new SQL command is encountered, a new transaction begins.
 Control returns to the calling application (such as Java, PSQL, etc.) in which case
the action of the application determines whether the transaction is committed or
rolled back unless the transaction is within a block in which PRAGMA
AUTONOMOUS_TRANSACTION has been declared in which case the commitment
or rollback of the transaction occurs independently of the calling program.
Note: Unlike Oracle, DDL commands such as CREATE TABLE do not implicitly occur
within their own transaction. Therefore, DDL commands do not automatically cause an
immediate database commit as in Oracle, and DDL commands may be rolled back just
like DML commands.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 236
Database Compatibility for Oracle® Developers Guide
A transaction may span one or more BEGIN/END blocks, or a single BEGIN/END block
may contain one or more transactions.
The following sections discuss the COMMIT and ROLLBACK commands in more detail.
3.6.1 COMMIT
The COMMIT command makes all database updates made during the current transaction
permanent, and ends the current transaction.
COMMIT [ WORK ];
The COMMIT command may be used within anonymous blocks, stored procedures, or
functions. Within an SPL program, it may appear in the executable section and/or the
exception section.
In the following example, the third INSERT command in the anonymous block results in
an error. The effect of the first two INSERT commands are retained as shown by the first
SELECT command. Even after issuing a ROLLBACK command, the two rows remain in the
table as shown by the second SELECT command verifying that they were indeed
committed.
Note: The edb_stmt_level_tx configuration parameter shown in the example below
can be set for the entire database using the ALTER DATABASE command, or it can be set
for the entire database server by changing it in the postgresql.conf file.
\set AUTOCOMMIT off
SET edb_stmt_level_tx TO on;
BEGIN
INSERT INTO dept VALUES (50, 'FINANCE', 'DALLAS');
INSERT INTO dept VALUES (60, 'MARKETING', 'CHICAGO');
COMMIT;
INSERT INTO dept VALUES (70, 'HUMAN RESOURCES', 'CHICAGO');
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('SQLERRM: ' || SQLERRM);
DBMS_OUTPUT.PUT_LINE('SQLCODE: ' || SQLCODE);
END;
SQLERRM: value too long for type character varying(14)
SQLCODE: 22001
SELECT * FROM dept;
deptno | dname | loc
--------+------------+----------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 237
Database Compatibility for Oracle® Developers Guide
40 | OPERATIONS | BOSTON
50 | FINANCE | DALLAS
60 | MARKETING | CHICAGO
(6 rows)
ROLLBACK;
SELECT * FROM dept;
deptno | dname | loc
--------+------------+----------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
40 | OPERATIONS | BOSTON
50 | FINANCE | DALLAS
60 | MARKETING | CHICAGO
(6 rows)
3.6.2 ROLLBACK
The ROLLBACK command undoes all database updates made during the current
transaction, and ends the current transaction.
ROLLBACK [ WORK ];
The ROLLBACK command may be used within anonymous blocks, stored procedures, or
functions. Within an SPL program, it may appear in the executable section and/or the
exception section.
In the following example, the exception section contains a ROLLBACK command. Even
though the first two INSERT commands are executed successfully, the third results in an
exception that results in the rollback of all the INSERT commands in the anonymous
block.
\set AUTOCOMMIT off
SET edb_stmt_level_tx TO on;
BEGIN
INSERT INTO dept VALUES (50, 'FINANCE', 'DALLAS');
INSERT INTO dept VALUES (60, 'MARKETING', 'CHICAGO');
INSERT INTO dept VALUES (70, 'HUMAN RESOURCES', 'CHICAGO');
EXCEPTION
WHEN OTHERS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('SQLERRM: ' || SQLERRM);
DBMS_OUTPUT.PUT_LINE('SQLCODE: ' || SQLCODE);
END;
SQLERRM: value too long for type character varying(14)
SQLCODE: 22001
SELECT * FROM dept;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 238
Database Compatibility for Oracle® Developers Guide
deptno | dname | loc
--------+------------+----------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
40 | OPERATIONS | BOSTON
(4 rows)
The following is a more complex example using both COMMIT and ROLLBACK. First, the
following stored procedure is created which inserts a new employee.
\set AUTOCOMMIT off
SET edb_stmt_level_tx TO on;
CREATE OR REPLACE PROCEDURE emp_insert (
p_empno IN emp.empno%TYPE,
p_ename IN emp.ename%TYPE,
p_job IN emp.job%TYPE,
p_mgr IN emp.mgr%TYPE,
p_hiredate IN emp.hiredate%TYPE,
p_sal IN emp.sal%TYPE,
p_comm IN emp.comm%TYPE,
p_deptno IN emp.deptno%TYPE
)
IS
BEGIN
INSERT INTO emp VALUES (
p_empno,
p_ename,
p_job,
p_mgr,
p_hiredate,
p_sal,
p_comm,
p_deptno);
DBMS_OUTPUT.PUT_LINE('Added employee...');
DBMS_OUTPUT.PUT_LINE('Employee # : ' || p_empno);
DBMS_OUTPUT.PUT_LINE('Name : ' || p_ename);
DBMS_OUTPUT.PUT_LINE('Job : ' || p_job);
DBMS_OUTPUT.PUT_LINE('Manager : ' || p_mgr);
DBMS_OUTPUT.PUT_LINE('Hire Date : ' || p_hiredate);
DBMS_OUTPUT.PUT_LINE('Salary : ' || p_sal);
DBMS_OUTPUT.PUT_LINE('Commission : ' || p_comm);
DBMS_OUTPUT.PUT_LINE('Dept # : ' || p_deptno);
DBMS_OUTPUT.PUT_LINE('----------------------');
END;
Note that this procedure has no exception section so any error that may occur is
propagated up to the calling program.
The following anonymous block is run. Note the use of the COMMIT command after all
calls to the emp_insert procedure and the ROLLBACK command in the exception
section.
BEGIN
emp_insert(9601,'FARRELL','ANALYST',7902,'03-MAR-08',5000,NULL,40);
emp_insert(9602,'TYLER','ANALYST',7900,'25-JAN-08',4800,NULL,40);
COMMIT;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 239
Database Compatibility for Oracle® Developers Guide
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('SQLERRM: ' || SQLERRM);
DBMS_OUTPUT.PUT_LINE('An error occurred - roll back inserts');
ROLLBACK;
END;
Added employee...