title:Privacy-preserving Logarithmic-time Search on Encrypted Data in Cloud
author:Yanbin Lu
PRIVACY-PRESERVING 
LOGARITHMIC-TIME SEARCH ON 
ENCRYPTED DATA IN CLOUD 
1 
Yanbin Lu 
University of California, Irvine 
(NDSS’11, Feb 6) 
CLOUD DATABASE ENVIRONMENT 
Database transfer 
Database Owner 
User 
2 
PRIVACY REQUIREMENTS 
  Privacy requirements: 
  Cloud server learns no information about database 
  Cloud server learns no information about user query 
  Owner can exercise access control over user query 
  Personal data vault example: 
  Owner: Patient 
  Database: Heart beat rate 
  Cloud server: Amazon RDS 
  User: Cardiologist 
3 
PRIVACY-PRESERVING SOLUTION 
Encrypted Database 
Query 
Database 
Owner 
Search token 
decryption key 
Data User 
Decrypt 
4 
REQUIREMENTS 
  Sublinear search 
  Linear search is untolerable in massive data 
  Query result integrity 
  Prevent cloud server from cheating user 
  Provable database update 
  Prevent cloud server from cheating database owner 
5 
RELATED WORK 
  Order preserving encryption 
  Deterministic and not IND-CPA secure 
  Domain distribution is fixed 
  Bellare et al. [crypto’07] 
  Deterministic and not IND-CPA secure 
  Only equality search is supported 
  Predicate encryption 
  Useful in privacy-preserving cloud database 
  Linear complexity 
6 
PREDICATE ENCRYPTION 
  Setup(    ): output secret key SK. 
1k
  Encrypt(              ): encrypt message     under   
                                   attributes    with key SK.  
SK, I, m
m
I
  Key-extraction(   ): outputs key  
g
kg
  Decrypt(         ): decrypts iff  
kg, CI
g(I) = 1
7 
BUILDING BLOCKS 
  Range predicate encryption (RPE) 
  Ciphertext associated with point 
t
  Decryption key associated with a range  
Q
  Decryption works if 
t ∈ Q
  Inner-product predicate encryption (IPE) 
  Ciphertext associated with vector 
  Decryption key associated with vector  
v
  Decryption works if  
x
v, x = 0
8 
STRAWMAN RPE BUILDING FROM IPE  
  Encrypt(t): create                                          where 
                                   if i = t and              otherwise.  
                      Run IPE encryption. 
x = (x1, . . . , xi, . . . , xT )
xi = 0
xi = 1
  Extract(Q): create                                         where 
                                   if            and             otherwise. 
                       Run IPE key extraction. 
y = (y1, . . . , yi, . . . , yT )
i ∈ Q
yi = 0
y1 = 1
  Decrypt(            ):  Run IPE decryption. 
et, kQ
9 
EFFICIENT RANGE REPRESENTATION 
!#!
!"!
!##!
!#"!
!"#!
!""!
#
!###!
" $
!##"!
!#"#!
% &
!#""!
!"##!
'
!"#"!
(
!""#!
)
!"""!
  Any range can be covered by                       nodes. 
  Point path intersects with range representation 
2 · (log T − 1)
10 
EFFICIENT RANGE PREDICATE ENCRYPTION 
  Encrypting point t: 
(X − v) =
αiX i
log Ti=0
P (X) = v∈CP(t)
A = (α0, . . . , αlog T )
  Key extraction for range Q: 
Kx = (x0, . . . , xlog T ),∀x ∈ MCS(Q)
  Observation:  
A · Kx = α0 · x0 + α1 · x1 + ··· + αlog T · xlog T = P (x)
11 
LOGARITHMIC-TIME SEARCH 
  Encrypting each node of B-tree 
  One RPE for search token 
  One RPE for real message 
  Search token extraction involves two rounds 
  One for left range 
  One for right range 
  Example: 
  Domain size [0-100] 
  Query range [10-20] 
  Left range [0-9], right range [21-100] 
12 
QUERY AUTHENTICATION 
  Authenticated data structure 
  Encrypted B-tree 
  Authenticated root 
  Query result verification 
  Left and right boundary to query range 
  Verification without leaking records out of range 
  Provable data update 
  Owner first verifies change path 
  Reconstructs and authenticates root 
13 
PERFORMANCE 
Total search time 
Search time per record 
14 
Thank you! 
15