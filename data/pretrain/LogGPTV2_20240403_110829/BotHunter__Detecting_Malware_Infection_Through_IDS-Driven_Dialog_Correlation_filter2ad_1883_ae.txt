The MS06-40 exploit, a buffer overflow vulnerability, allows attackers to craft RPC requests that can execute arbitrary code. This mechanism is used to force the victim's system to fetch and execute a binary named `netadp.exe` from the system folder. The infected system then connects to the z3net IRC network and joins two channels, where it is instructed to initiate scans of the 203.0.0.0/8 network on several ports. Other bot families successfully detected by BotHunter include variants of W32/Korgo, W32/Virut.A, and W32/Padobot.

BotHunter detected a total of 1,920 out of 2,019 successful bot infections, representing a 95.1% true positive rate. All observed malware instances transmitted their exploits through TCP ports 445 or 139, which are commonly targeted due to their frequent vulnerability. The analyzed infection set exhibited limited diversity in transmission methods, with approximately 40 unique patterns in the dialog warnings produced.

### False Negative Analysis
This experiment also identified 99 bot infections that did not produce bot profiles, resulting in a 4.9% false negative rate. To understand these occurrences, we manually examined each bot infection trace using tools like `tcpdump` and `ethereal`. The reasons for these failed detections can be categorized into three primary types:

1. **Infection Failures:**
   - Some infections led to instability and eventual failure in the infected host.
   - In other cases, the infected victim attempted to "phone home," but the SYN request received no reply.

2. **Honeynet Setup and Policy Failures:**
   - Our NAT mechanism did not correctly translate application-level address requests (e.g., FTP PORT commands), preventing some FTP egg download connections.
   - Some traces were incomplete due to errors in our honeypot recycling logic, which interfered with the observation of the infection logic.

3. **Data Corruption Failures:**
   - Data corruption was the dominant reason (86% of the failed traces) for preventing BotHunter sensors from producing dialog warnings. We suspect this may have occurred during log rotations by the Drone manager.

### Discussion
In addition to the above false negatives, other factors could prevent BotHunter from detecting infections. For example, a bot might lay dormant after infecting a host to avoid association with an outbound egg download or coordination event. This strategy could circumvent BotHunter if deployed with a fixed pruning interval. While some infected victims failed to phone home, the egg download source might eventually respond after the BotHunter pruning interval, causing a similar missed association. Sensor coverage is another fundamental concern for any detection mechanism. Furthermore, the honeynet environment provided a low-diversity set of bot infections, primarily focusing on direct exploits of TCP-445 and TCP-139. A more diverse set of honeypots with various OSs, vulnerable services, and Trojan backdoors would be needed to fully examine the behavioral complexities of bots and worms.

### Example Detection in a Live Deployment
In addition to laboratory and honeynet tests, BotHunter has been deployed in networks within the Georgia Tech campus and an SRI laboratory. In early February 2007, BotHunter detected a bot infection that produced E1, E4, and E5 dialog warnings. Upon inspection, the bot-infected machine was scanned, joined an IRC channel, and began scanning other machines. One unusual element was the omission of the actual infection transmission event (E2), which is typically observed in live honeynet testing. We assert that the bot profile represents an actual infection because the target of the E4 (C&C Server) dialog warning was an address blacklisted by ShadowServer and the botnet mailing list as a known C&C server.

### Experiments in a University Campus Network
We evaluated BotHunter's detection and false positive performance in a production campus network at the College of Computing (CoC) at Georgia Tech between October 2006 and February 2007. The monitored link exhibited typical diurnal behavior with a sustained peak traffic of over 100 Mbps during the day. Despite concerns about high traffic rates, BotHunter ran efficiently on a Linux server with an Intel Xeon 3.6 GHz CPU and 6 GB of memory, with average CPU and memory utilization of 28% and 3%, respectively.

To evaluate the representativeness of the traffic, we randomly sampled packets for analysis. The packets demonstrated wide diversity in protocols, including HTTP, SMTP, POP, FTP, SSH, DNS, and SNMP, as well as collaborative applications like IM, P2P, and IRC. This high volume of background traffic, involving large numbers of hosts and a diverse application mix, provided an appealing environment to confirm detection performance and examine false positives.

First, we injected bot traffic captured in a virtual network into the Georgia Tech network traffic to simulate real network infections. BotHunter correctly detected all 10 injected infections. Next, we conducted a longer-term (4 months) evaluation of false alarm production. BotHunter generated about 2,563,402 raw dialog warnings, but only 98 profiles were generated, less than one per day on average. Further analysis showed no false positives related to normal usage of collaborative applications. Most bot profiles involved access to MS-Exchange SMB and SMTP servers, which could be mitigated by additional whitelisting.

### Experiments in an Institutional Laboratory
We deployed BotHunter on a small, well-administered production network to evaluate false positive production in an operational environment. Over 10 days, BotHunter analyzed 182 million packets, generating 5,501 dialog warnings. Only one bot profile was produced, which upon inspection, was found to be a false alarm due to a 1.6 GB multi-file FTP transfer that matched a buffer overflow detection pattern.

### Limitations and Future Work
Several practical considerations present challenges for extending and adapting BotHunter for arbitrary networks. Bots could use encrypted communication channels or adopt stealthy scanning techniques. However, many systems remain unprotected, and attacks still happen in the clear. Open-source systems like BotHunter raise the bar for successful infections. Future work includes developing anomaly-based "entropy detectors" for identifying encrypted channels and new anomaly-based C&C detection schemes. Additionally, incorporating random delays in the hard prune interval can introduce uncertainty and counter evasion attempts. As bots evolve, the current set of states in the bot infection model may need to be extended or modified, which can be accomplished with simple configuration changes.