size.
‚Ä¢ The reduction rate, which we deÔ¨Åne as the relative fre-
quency of our reduction succeeding to reduce randomly
selected sets of Ô¨Åxed size to a minimal eviction set.
Here, a reduction is successful if the elements it returns are
congruent, i.e., they coincide on the set bits and on the slice
bits. For this check we rely on the reverse engineered slice
function for Intel CPUs [19].
With perfect tests (and hence correct algorithms), both the
eviction rate and the reduction rate should coincide with the
theoretical prediction given in Section III. Our analysis hence
(cid:21)(cid:23)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:41:36 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 5: Skylake: Eviction for speciÔ¨Åc address x on cache set zero, compared to our binomial model. Each point is the average
of 1000 reductions for sets of N randomly chosen addresses.


	


	
























(a) Eviction and reduction rates for an speciÔ¨Åc address x targeting
cache set 10, compared to our binomial model.


	


(a) Eviction and reduction rates for an speciÔ¨Åc address x, compared
to our binomial model.
	
























(b) Eviction and reduction rates for an arbitrary address, compared
to our multinomial model.
Fig. 6: Experiments on Skylake. Each point is the average of
100 reductions for sets of N randomly chosen addresses.
(b) Eviction and reduction rates for an arbitrary address, compared
to our multinomial model.
Fig. 7: Experiments on Haswell. Each point is the average of
100 reductions for sets of N randomly chosen addresses.
focuses on deviations of the eviction and reduction rate from
these predictions.
Experimental Results: The experimental results for evic-
tion and reduction for a speciÔ¨Åc address x are given in
Figures 5 and 6a (for Skylake), and Figure 7a (Haswell).
The results for arbitrary addresses are given in Figures 6b
and 7b (for Skylake and Haswell, respectively). We highlight
the following Ô¨Åndings:
‚Ä¢ Analysis under idealized conditions We Ô¨Årst analyze
our test and reduction algorithms under idealized conditions,
where we use the techniques described in Section V-A to
mitigate the effect of TLBs, complex replacement policies,
prefetching, and jitter. Figure 5 illustrates that, under these
conditions, eviction and reduction rates (Test 1 and Algo-
rithm 2) closely match. Moreover, eviction and reduction rates
closely match the theoretical prediction for small pages.
For huge pages, however, eviction and reduction rates remain
below the theoretical prediction, see Figure 5. We attribute this
to the fact that, using explicit allocations (see Appendix A),
huge pages are chosen from a pre-allocated pool of physical
pages that usually resides in a Ô¨Åxed zone. This limits the
uniformity of the more signiÔ¨Åcant bits and deviates from our
uniform modeling.
‚Ä¢ Effect of the cache replacement policies. Our experimental
results show that the eviction and reduction rates decrease
signiÔ¨Åcantly on Haswell (Figure 7a), and on Skylake when
targeting a cache set (Figure 6a) different from zero. The effect
is also visible in the evaluation of algorithms for Ô¨Ånding an
arbitrary eviction set (see Figures 6b and 7b).
The decrease seems to be caused by two factors: the replace-
ment policy of the targeted cache sets does not match our
models; and the targeted cache set are inÔ¨Çuenced by accesses
to other sets in the cache. We provide further evidence of this
effect in Section VI.
‚Ä¢ Effect of TLB thrashing. Virtual memory translations are
more frequent with small pages than with huge pages, which
shows in our experiments: The eviction rate lies above the
theoretical prediction, in particular for large sets, which shows
(cid:21)(cid:24)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:41:36 UTC from IEEE Xplore.  Restrictions apply. 
the existence of false positives. In contrast, the reduction rate
falls off. This is because false positives in tests cause the
reduction to select sets that are not eviction sets, which leads
to failure further down the path.
The effect is clearly visible in Figure 5, where we compare the
results on small pages with those on huge pages for cache set
zero on Skylake. We observe that the reduction rate on small
pages declines for N > 1500, which, as Appendix D shows,
coincides with the TLB capacity of Skylake of 1536 entries.
The effect is also visible in Figure 7b , where we attribute
the strong decline of the reduction rate after N > 1000
(Haswell‚Äôs TLB capacity is 1024 entries) to implicit memory
accesses having a greater chance to be an eviction set for
Haswell‚Äôs adaptive replacement policy. In the rest of Ô¨Ågures
the effect is overlaid with interferences of the replacement
policy. However, Figure 6b shows that with large TLBs, and
for most reasonable values of N, the effect of TLB thrashing
is negligible.























	
	
		






















 	!	

















C. Evaluating Performance
We evaluate the performance of our novel reduction al-
gorithm and compare it
to that of the baseline from the
literature. For this, we measure the average time required to
reduce eviction sets of different sizes to their minimal core.
We Ô¨Årst focus on idealized conditions that closely match the
assumptions of the theoretical analysis in Section IV.
To put the performance of the reduction in context, we also
evaluate the effort that is required for Ô¨Ånding an initial eviction
set to reduce. For this, we consider attackers with different
capabilities to control the set index bits, based on huge pages
(Œ≥ = 10), 4 KB pages (Œ≥ = 6), and with no control over the
set index bits (Œ≥ = 0).
Together, our evaluation gives an account of how the per-
formance gains of our novel reduction algorithm affect the
overall effort of computing minimal eviction sets.
Experimental Results: The results of the evaluation of
the reduction for a speciÔ¨Åc address on Skylake are given in
Figure 8. We focus on cache set zero to mitigate the effect of
the replacement policy, and we mitigate the inÔ¨Çuence of TLBs
and prefetching as described in Section V-A.2
Each data point is based on the average execution time of
10 successful reductions. The sizes of the initial sets (x-axis)
are chosen to depict the range where Ô¨Ånding an initial eviction
set does not require picking a too large number of candidate
sets (depicted by the green bars). For a more systematic choice
of the initial set size see the discussion below.
We highlight the following observations:
‚Ä¢ The slope of the orange curve clearly illustrates the
quadratic growth of execution time of the naive reduction,
whereas the blue curve shows the linear growth of our novel
algorithms. The absolute values account for constant factors
such as the 50 time measurements per test, and the overhead
due to metrics collection.
2In the limit case the stride of 64B makes inferences by prefetching
prohibitive even with a randomized order, which is why we disable hardware
prefetchers using wrmsr -a 0x1a4 15.
(cid:21)(cid:25)
Fig. 8: The vertical green bars (left axis) depict the average
number of times one needs to pick a set of addresses for
Ô¨Ånding an eviction set. Triangles (right axis) show time in
seconds: blue depicts the average execution time of group
test reductions; orange depicts the average execution time of
baseline reductions. Different plots illustrate attackers with
huge pages, 4KB pages, and w/o any control over the set index
bits, respectively.
‚Ä¢ For large set sizes, our novel reduction clearly outper-
forms the quadratic baseline. For example, for sets of size
3000, we already observe a performance improvement of a
factor of 10, which shows a clear practical advantage. For
small set sizes, this practical advantage seems less relevant.
For such sizes, however, the number of repetitions required
until Ô¨Ånd a real eviction set grows, as illustrated by the green
bars. For the total cost of Ô¨Ånding an eviction set, both effects
need to be considered in combination.
Optimal Choice of the Initial Set Size: For evaluating the
cost of Ô¨Årst identifying and then reducing eviction sets, we rely
on an expression for the overall number of memory accesses
required for Ô¨Ånding a minimal eviction set. This expression is
the sum of the expected number N
p(N ) of memory accesses
for Ô¨Ånding an eviction set, see Section III-C, and of the
memory accesses for the respective reductions N 2 and N, see
Propositions 1 and 2. Based on this expression, we compute
the optimal set sizes (from an attacker‚Äôs perspective) for the
linear and the quadratic reductions. We use these sizes as an
approximation of the optimal use of each reduction algorithm
in the overall pipeline, and we evaluate their execution time
on sets of this size.
Table I shows the comparison of the linear and the quadratic
reductions on sets of optimal size for three different attackers:
with huge pages, with 4KB pages, and in the limit.
We highlight the following observations:
‚Ä¢ For huge pages, computing eviction sets is cheap, and the
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:41:36 UTC from IEEE Xplore.  Restrictions apply. 
Baseline
Time
0.005s
0.179s
218.651s
Group Testing
N
Time
0.004s
62
862
0.023s
1.814s
53300
Attacker
P (C)
2‚àí3
2‚àí7
2‚àí13
N
62
662
26650
HP (Œ≥ = 10)
4KB (Œ≥ = 6)
Limit (Œ≥ = 0)
TABLE I: N shows the optimal set sizes for different attackers
(Œ≥ bits) on Skylake (a = 12) using 50 time measurements