正如注释所示， **IPC凭证代表一组任意属性**
，这些属性可以通过Mach消息中的发送权限在进程之间传递。`Mach凭证`的主要相关者似乎是Apple的[libdispatch](https://opensource.apple.com/source/libdispatch/libdispatch-1008.220.2/)库。
与我们相关的`ipc_voucher`的唯一字段是`iv_refs`和`iv_port`。其他字段与 **管理凭证对象的全局列表** 和
**存储凭证所代表的属性** 有关，这两个凭证都不会在漏洞利用中使用。
从iOS 12开始，`iv_refs`的类型为`os_refcnt_t`，它是 **32位引用计数** ，允许值范围为`1-0x0fffffff`（即7个f
，而不是8个f）。试图保留或释放超出此范围的引用计数将引发错误。
`iv_port`是指向`ipc_port`对象的指针，该对象表示 **此用户空间的凭证**
。只要在`iv_port`设置为`NULL`的`ipc_voucher`上调用`convert_voucher_to_port()`，它就会被初始化。
要创建 **Mach凭证** ，可以调用`host_create_mach_voucher()`陷阱。此功能采用 **描述凭证属性的“配方”**
，并返回代表凭证的 **凭证端口** 。但是，由于 **凭证是不可变的**
，因此有一个怪癖：如果生成的凭证属性与已存在的凭证完全相同，则`host_create_mach_voucher()`将 **仅返回对现有凭证的引用**
，而不是创建新凭证。
# 这是不合适的！
有许多不同的方法可以利用这个bug，但是在这篇文章中我将讨论我的最爱： **增加一个外部的Mach端口指针，使其指向管道缓冲区** 。
现在我们已经了解了漏洞是什么，现在是时候确定我们可以用它做什么了。正如您所期望的那样，一旦`ipc_voucher`的引用计数降至0，就会被释放内存。因此，我们可以利用漏洞导致
**凭证被意外释放** 。
但是，释放凭证仅在随后以有趣的方式重新使用已取用的凭证时才有用。这有三个组件： **存储指向已释放凭证的指针** ，
**使用有用的东西重新分配已释放的凭证** ，以及 **重用存储的凭证指针来修改内核状态**
。如果我们无法使这些步骤中的任何一个工作，那么整个bug几乎是无用的。
让我们考虑第一步， **存储指向凭证的指针**
。内核中有一些地方直接或间接存储凭证指针，包括`structipc_kmsg`的`ikm_voucher`字段和`struct
thread`的`ith_voucher`字段。其中，最容易使用的是`ith_voucher`，因为我们可以通过调用`thread_get_mach_voucher()`和`thread_set_mach_voucher()`直接
**从用户空间读取和写入该字段的值** 。因此，我们可以通过首先调用`thread_set_mach_voucher()`
存储一个对凭证的引用，接着我们可以使`ith_voucher`指向一个释放的凭证，然后使用我们的bug **删除刚才添加的引用** ，最后在用户空间中
**取消分配凭证端口以释放凭证** 。
接下来考虑如何使用有用的东西重新分配凭证。`ipc_voucher`对象存在于他们自己的`zalloc`区域`ipc.vouchers`中，因此我们可以轻松地将我们释放的凭证与另一个凭证对象重新分配。但是，重新分配任何其他类型的对象
**将要求我们强制内核执行区域垃圾收集** 并 **将仅包含已释放凭证的内存页面移动到另一个区域** 。不幸的是，凭证似乎没有
**存储任何重要的特权相关属性** ，因此将我们的已释放的凭证与另一个凭证重新分配可能没有帮助。这意味着我们必须 **执行区域gc** 并
**使用其他类型的对象重新分配凭证** 。
为了弄清楚我们应该重新分配什么类型的对象，首先检查我们将如何在线程的`ith_voucher`字段中使用凭证的 **悬空指针**
是有帮助的。我们有几个选项，但最简单的方法是调用`thread_get_mach_voucher()`来为已释放的凭证 **创建或返回凭证端口**
。这将在释放的`ipc_voucher`对象上调用`ipc_voucher_reference()`和`convert_voucher_to_port()`，因此我们需要确保`iv_refs`和`iv_port`都有效。
但是，使`thread_get_mach_voucher()`如此有用的原因是它 **将凭证的Mach端口返回给用户空间**
。我们有两种方法可以利用它。如果释放的`ipc_voucher`对象的`iv_port`字段为 **非NULL**
，则该指针直接被解释为`ipc_port`指针，`thread_get_mach_voucher()`将其作为Mach发送权返回给我们。另一方面，如果`iv_port`为`NULL`
，则`convert_voucher_to_port()`将返回一个新分配的凭证端口，该端口 **允许我们继续操纵从用户空间释放的凭证的引用计数** 。
这让我产生了 **使用外线端口重新分配凭证** 的想法。在 **消息中发送大量Mach端口权限** 的一种方法是 **在端口描述符中列出端口** 。当
**内核在外部端口描述符中复制** 时，它会分配一个数组来存储`ipc_port`指针列表。通过发送包含外部端口描述符的许多Mach消息，我们可以
**使用一组外部Mach端口指针可靠地重新分配释放的`ipc_voucher`** 。
由于我们可以控制数组中的哪些元素是 **有效端口**
以及哪些是`MACH_PORT_NULL`，因此我们可以确保使用`NULL`覆盖凭证的`iv_port`字段。这样，当我们在用户空间中调用`thread_get_mach_voucher()`时，`convert_voucher_to_port()`将
**分配一个指向重叠凭证的新凭证端口** 。然后我们可以 **在返回的凭证端口上 再次使用引用计数bug来修改
释放的凭证的`iv_refs`字段**，这将改变与`iv_refs`重叠的任何数量的 **外部端口指针** 的值。
当然，我们还没有解决确保`iv_refs`字段有效的问题。如前所述，如果我们想要重用`freedipc_voucher`而不触发 **内核恐慌**
，`iv_refs`必须在`1 - 0x0fffffff`的范围内。
该`ipc_voucher`结构是为`0x50`字节，`iv_refs`字段是在偏移`0x8`中; 由于iPhone是`little-endian(小端序)`，这意味着如果我们使用一系列外部端口重新分配释放的凭证，`iv_refs`将始终与`ipc_port`
指针的低32位重叠。让我们调用与`iv_refs`基本端口重叠的Mach
端口。使用`MACH_PORT_NULL`或`MACH_PORT_DEAD`作为基本端口将导致`iv_refs`为`0
或0xffffffff，`两者都无效。因此， **剩下的唯一选择是使用一个真实的Mach端口作为基本端口**
，使得`iv_refs`与真正的低32位覆盖`ipc_port`指针。  
这很危险，因为如果基本端口地址的低32位是0或大于0x0fffffff ，则访问已经释放的凭证将会发生混乱。幸运的是，最近的iOS设备上的
**内核堆分配** 表现得非常好：`zalloc`页面将 **从低地址开始从0xffffffe0xxxxxxxx范围分配**
，因此只要堆自从系统启动以来没有变得太不守规矩，我们 **可以合理地确定基本端口地址的低32位将在所需范围内**
。因此，如果在重新启动后运行漏洞，则将`iv_refs`与 **一个外部Mach端口指针** 重叠几乎肯定会正常工作。
## 利用思路
这为我们提供了利用此漏洞的思路：
  1. 分配一页Mach凭证。
  2. 在线程的`ith_voucher`字段中 **存储指向目标凭证的指针** ，并使用漏洞 **删除添加的引用** 。
  3. **取消分配凭证端口，释放所有凭证** 。
  4. **强制区域gc** 并 **使用一系列外部端口重新分配 已释放凭证的页面** 。使用指向基本端口的指针的 **低32位重叠目标凭证的`iv_refs`字段**，并 **将凭证的`iv_port`字段与`NULL`重叠**。
  5. 调用`thread_get_mach_voucher()`以 **检索与外部端口重叠的凭证的凭证端口** 。
  6. 再次使用此漏洞 **修改重叠凭证的iv_refs字段** ，该字段会 **更改外部基本端口指针** ，使其指向其他位置。
  7. 一旦我们 **收到包含外部端口的Mach消息** ，我们就会获得一个解释为`ipc_port`的 **任意内存的发送权** 。
# 管道相关利用(Pipe dreams)
那么我们应该如何获得发送权？理想情况下，我们能够完全控制我们收到的假`ipc_port`的内容，而不必通过 **解除分配** 然后 **重新分配**
支持假端口的内存来玩冒险游戏。
Ian实际上在他的[multi_path](https://bugs.chromium.org/p/project-zero/issues/detail?id=1558#c3)和[empty_list](https://bugs.chromium.org/p/project-zero/issues/detail?id=1564#c10)漏洞 **利用管道缓冲区** 中提出了一个很好的技术。到目前为止，我们的漏洞利用
**允许我们修改指向基本端口的外部指针** ，使其 **指向其他位置** 。因此，如果原始基本端口 **直接位于内核内存中的一堆管道缓冲区的前面**
，那么我们可以 **泄漏凭证引用以增加外部端口数组中的基本端口指针** ，以便它 **指向管道缓冲区** 。
此时，我们可以 **在用户空间中收到包含外部端口的消息** 。此消息将 **包含对`ipc_port`的发送权限**，该`ipc_port`
**与我们的一个管道缓冲区重叠** ，因此我们可以通过 **读取和写入重叠管道的文件描述符** 来 **直接读取和写入伪`ipc_port`内存的内容**。
# TFP0
一旦我们拥有一个 **完全可控的`ipc_port`对象的发送权限**，漏洞利用流程就清晰了。
我们可以使用相同的旧`pid_for_task()`技巧 **构建一个基本的内核内存读取原语** ： **将我们的端口转换为伪任务端口**
，以便伪任务的`bsd_info`字段（它是 **指向`proc`结构的指针**） **指向我们想要的内存read**
，然后调用`pid_for_task()`读取重叠`bsd_info->p_pid`的4个字节。不幸的是，有一个小问题：我们不知道
**内核内存中管道缓冲区** 的 **地址** ，因此我们不知道在哪里 **伪造假任务端口的`ip_kobject`字段点**。
我们可以通过将我们的 **假任务结构体** 放在我们发送到假端口的Mach消息中来解决这个问题，之后我们可以 **读取与端口重叠的管道缓冲区**
，并从端口的`ip_messages` **获取包含我们假任务的消息的地址`imq_messages`字段**。一旦我们知道包含我们的
**假任务的`ipc_kmsg`的地址**，我们就可以 **覆盖伪端口的内容** ，将其转换为 **指向伪任务的任务端口** ，然后
**像往常一样在伪任务端口上调用`pid_for_task()`来读取4个字节的任意内核内存**。
这种方法的一个不幸后果是它为每个4字节读取 **泄漏了一个`ipc_kmsg`结构**。因此，我们希望尽可能快地构建一个更好的 **读取原** 语，然后
**释放所有泄露的消息** 。
为了 **获得管道缓冲区的地址** ，我们可以 **利用它驻留在基本端口地址的已知偏移量**
。我们可以在虚假端口上调用`mach_port_request_notification()`来添加一个请求，一旦伪端口成为死名(dead name)，就会
**通知基本端口** 。这会导致伪端口的`ip_requests`字段指向一个新分配的数组，该数组包含 **指向基本端口的指针** ，这意味着我们可以
**使用内存读取原语** 来 **读出基本端口的地址** 并 **计算管道缓冲区的地址** 。
此时我们可以 **在管道缓冲区内构建一个伪内核任务** ，为我们 **提供完整的内核读、写** 。接下来，我们使用`mach_vm_allocate()`
**分配内核内存** ， **在该内存中编写一个新的伪内核任务** ，然后 **修改进程的`ipc_entry`表中的伪端口指针**，以
**指向新的内核任务** 。最后，一旦我们有了新的内核任务端口，我们就可以 **清理所有泄漏的内存** 。
这就是完全利用！您可以在此处找到适用于iPhone XS，iPhone XR和iPhone
8的漏洞利用代码：[voucher_swap](https://bugs.chromium.org/p/project-zero/issues/detail?id=1731#c10)。源代码中提供了对漏洞利用技术的更深入，逐步的技术分析。
# 撞bug
我在2018年12月6日向Apple报告了这个漏洞，截至12月19日Apple已经发布了iOS 12.1.3
beta版本16D5032a，修复了这个问题。由于这对Apple来说是一个令人难以置信的快速转变，我怀疑这个错误是由其他一方首先发现并报告的。
后来我了解到这个bug是由Qihoo 360 Vulcan Team的Qixun
Zhao（@S0rryMybad）独立发现和利用的。有趣的是，我们都是通过`semaphore_destroy()`引发了这个错误;
因此，我不会惊讶地发现这个错误在被修复之前已广为人知。Mybad将此漏洞用作天府杯远程越狱的一部分， 你可以阅读他获得`tfp0`的策略。
# 总结
这篇文章研究了[P0问题1731](https://bugs.chromium.org/p/project-zero/issues/detail?id=1731)的发现和利用，这是一个关于 **IPC凭证引用计数** 问题，其根源在于
**未能跟踪外部对象的MIG语义**
。在新引导后几秒钟运行时，此处讨论的漏洞利用策略非常可靠：在我测试的设备上，漏洞利用成功率高达99％。该漏洞利用也很简单，当成功时，它允许我们
**清理所有泄漏的资源并使系统处于完全稳定的状态** 。
在某种程度上，令人惊讶的是，这种“容易”的漏洞仍然存在：毕竟，XNU是开源的，并且对这样的有价值的错误进行了严格的审查。但是，MIG语义非常不直观，并且与编写安全内核代码的自然模式不一致。虽然我很想相信这是MIG的最后一个主要问题，但我看到至少还有一些问题我不会感到惊讶。
这个错误也是一个很好的提醒， **占位符代码也可能引入安全漏洞** ，应该像功能代码一样严格审查，无论它看起来多么简单。
最后，值得注意的是，在利用这个漏洞时，我所遇到的 **最大问题** 是， **允许的引用计数值的范围有限**
，在12版之前的iOS版本中甚至都不是问题。在早期的平台上，这个bug总是令人难以置信可靠。因此，很高兴看到即使`os_refcnt_t`没有阻止这个漏洞被利用，缓解至少会影响利用可靠性，并且可能会降低这样的漏洞对攻击者的价值。
我的下一篇文章将展示如何利用这个漏洞来分析Apple的 **指针认证实现** ，最终形成一种技术，允许我们 **为使用A键签名的指针伪造PAC** 。这足以
**通过JOP调用任意内核函数** 或 **在内核中执行任意代码** 。