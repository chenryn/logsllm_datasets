instruction performing the access.
Local stack variables are accessed in two ways. One way is
through a ﬁxed offset access from the frame pointer register.
Accesses of this type, like above, allow us to encode the
object-id intentions directly on the instructions that perform
the accesses. In this case the object-id might be Vi, where Vi
is an identiﬁer for ith variable belonging to a particular frame.
The second way that local stack variables can be accessed
is through pointers held in general-purpose registers that are
crafted by the program. This type of access occurs when
accessing non-scalar types such as arrays, when the address of
a local variable is taken and dereferenced, or when a piece of
code obtains a pointer to stack data (e.g., was passed a pointer
to stack local data as an argument). To validate this kind
of access, we require that the accessing pointer was crafted
speciﬁcally to access the object it is used to read or write;
i.e., it was intentionally provided the capability to access a
particular object-id inside a frame-id. This deﬁnition allows a
pointer to a speciﬁc stack object to be passed as an argument
to another function, but restricts the use of that pointer by the
callee to just the intended object-id and frame-id.
A ﬁnal class of memory operations used in the stack
abstraction is the case of accessing function arguments them-
selves. This is a special case—function arguments are held
in the caller’s frame, but no pointer is passed to the callee
to be treated as a capability for accessing them. Instead, the
locations of arguments are implicitly dictated by the calling
convention, and the callee will compute an offset beyond its
own frame to access the arguments it has been passed. While
we will still use compiler-level information to validate these
accesses, we leave our discussion of how this is done to each
of our concrete policies.
D. Policies
In this subsection we describe three concrete policies. In
each case, we (1) give a high level description of the policy,
(2) describe the implementation, and (3) detail the security
properties of the policy. The rules for each policy written in
SDMP notation are available in the appendix.
We focus on the the core policy behavior in this section and
discuss how our policies handle common low-level features
and optimizations in Appendix A, including setjmp/longjmp,
tail calls, and dynamic stack memory allocations such as
through alloca.
1) Return Address Protection:
Policy Description: The ﬁrst
stack protection policy
we present, Return Address Protection, is a lightweight policy
that is concerned only with control ﬂow hijacking attacks
that overwrite return addresses. It treats return addresses as
special objects and restricts access to words containing return
addresses to just the speciﬁc instructions generated by the
compiler for this purpose (i.e., Sec. IV-C). It is designed to
have comparable protection characteristics to mechanisms
such as stack canaries [29], shadow stacks [26], or the HDFI
stack protection policy [12], namely just the protection of
return addresses stored on the stack. We abbreviate “return
address” with RA in our tags and rules.
Because the policy is only concerned with differentiating
return addresses stored on the stack from all other stack
objects,
it only needs two object-ids: RA and OTHER.
As another simpliﬁcation, we will not differentiate return
481
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:32:21 UTC from IEEE Xplore.  Restrictions apply. 
addresses by any notion of their owner, thus choosing to use
a single frame-id in all cases. Conceptually, this is equivalent
to removing the frame-id ﬁeld from the tags for this policy;
we choose this interpretation for the rest of the section. The
full rules for the policy are available in Appendix B.
Policy Implementation: This policy requires support from
the compiler only to appropriately tag the instructions that
store and retrieve return addresses from the stack. Speciﬁcally,
the compiler tags the instruction in the function prologue
that stores the return address to the stack with a special
tag STORE–RA, which, with an appropriate rule, causes the
written memory word to become tagged RA. Similarly, the
compiler tags the instruction in the function epilogue generated
to retrieve the return address from the stack with a special tag
READ–RA. With an appropriate rule, instructions with this tag
are granted the unique permission to read words marked RA
from the stack.
In this policy all other memory words are tagged OTHER,
and all other instructions are tagged generically as INSTR.
Instructions tagged INSTR are permitted to access memory
words tagged OTHER but not those tagged RA.
One ﬁnal detail wraps up the policy: in standard stack
disciplines, the return address (which we will have tagged
RA) is left on the stack after a function returns. We insert one
additional instruction in the function epilogue that cleans up
the RA tag left on the stack by performing a store to the word
containing the return address. This cleanup instruction is
tagged REMOVE–RA by the compiler, granting it the unique
permission to overwrite words tagged RA, which it tags with
the generic OTHER.
Security Properties: The Return Address Protection policy
uses information from the compiler and appropriate rules to
keep return addresses saved on the stack tagged RA and all
other words tagged as OTHER. Only speciﬁc instructions
generated by the compiler to manage the stack abstraction
have permission to access words tagged RA, which prevents
any other code from overwriting them to hijack control ﬂow.
Separately, instructions that load return addresses from the
stack require valid RA targets;
this prevents attacks that
require attacker-synthesized return addresses, for which no
corresponding call instructions were issued, from being loaded
during return sequences (e.g., a standard ROP attack).1
This policy is complementary to CFI policies that restrict
the control-ﬂow edges taken by a program to match those
of a control-ﬂow graph. Return edges are imprecise in that
they can potentially return to any of their call cites [31];
the additional protection for return addresses in memory is
useful to assure a return ﬂows to the correct instance. This
policy could replace a shadow stack proposed by [31] for this
purpose.
2) Static Authorities:
Policy Description: The next policy we present, Static
Authorities, greatly expands upon the set of object-ids and
frame-ids that will be used to differentiate objects on the
stack. The key design decision of the policy is to statically
assign a unique identiﬁer to each function in a program,
and to reuse that same identiﬁer as the frame-id for each
dynamic function instance that is pushed onto the runtime call
stack. Conceptually, each function will tag the stack memory
that it allocates with its unique frame-id, and instructions
belonging to that function are the only instructions tagged
in the appropriate way to access (or create pointers to) that
allocated memory. In this sense, each function in a program
is the authority over the memory that it allocates.
In this policy we enrich our notion of object-ids for precise
object protection internal to a frame. Within each frame we
statically assign a unique object-id to each program-level
variable used by that function, including each primitive, array
and structure in the frame; i.e., for each variable Vi belonging
to a function f we assign a new differentiable object-id i.
Like Return Address Protection, we continue to use additional
object-ids to manage the stack control data, but now we expand
the set to include the return address, the saved frame pointer
and callee-saved registers; these other objects can also be used
to mount attacks, e.g., [32], [33]. Due to the restricted way
in which these compiler-managed objects are accessed (Sec.
IV-C), we reuse the same object-id for them all; we only need
to isolate them from the other program-managed objects on the
stack to secure them. Leveraging this piece of static analysis
allows us to avoid unnecessary tag and rule diversity.
At a high level, the implementation is then concerned with
(1) tagging stack memory according to the Static Authorities
formulation above, and (2) tagging instructions and deﬁning
appropriate rules to validate accesses to these stack objects to
enforce the invariants (Sec. IV-C). The full rules for the policy
are available in Appendix C. In Fig. 2 we show an example
of how the stack memory would be tagged when our tagging
scheme is applied to the code shown. For demonstrative
purposes, we assume the ﬁrst argument is passed on the stack.
Policy Implementation:
Initialization: To initialize this policy, we tag all stack memory
words with a special tag, EMPTY STACK, indicating that the
cell is unclaimed.2 Instructions are tagged with both their cor-
responding frame-id (authority identiﬁer) and an instruction-
type ﬁeld that is set generically as INSTR unless otherwise
indicated below. We initialize non-stack memory to ⊥.
Tagging Stack Memory: In each function prologue,
the
compiler adds instructions that tag the freshly allocated stack
words with their appropriate frame-id and object-id. These in-
structions are tagged with both the instruction-type SET MEM
and the object-id that they are initializing; with an appro-
1We note, however, that this simple policy would not prevent sophisticated
code reuse attacks, e.g., [30]. Our later policies provide protection for other
code pointers on the stack as well.
2For simplicity, we assume a ﬁxed, maximum stack size, although with
additional OS and loader support stack pages could be allocated lazily and
tagged on demand as they are faulted in.
482
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:32:21 UTC from IEEE Xplore.  Restrictions apply. 
long square(long i ){
long r = i ∗ i ;
return r ;
}
int main(){
long x = 3;
long r ;
r = square(x);
}
%

"



 


!
"



 #
 


!
$


(a) Source Code
(b) Stack Memory
Fig. 2: The Static Authorities tagging scheme. The tags we
show are pairs (frame-id, object-id). In this example we assign
frame-id 1 to main() and frame-id 2 to square(). We assign the
object-id 1 for stack control data, object-id 2 for arguments,
and use 3 and higher for program level variables. The word
containing the passed argument is described in the text.
priate rule, SET MEM instructions become the only type of
instructions that can claim empty stack memory, which they
convert from EMPTY STACK to the appropriate frame-id and
object-id of the allocated word. Functions that do not allocate
stack memory (e.g., handwritten assembly code in libc) tag no
memory—they require no stack protection.
Tagging Pointers: The compiler places the MAKE-PTR
instruction-type along with the frame-id and appropriate
object-id on instructions that create pointers to stack objects. A
special rule tags the resulting register with the corresponding
frame-id and object-id. Additionally, in the function prologue,
a MAKE-PTR is placed on the arithmetic instruction that
subtracts from the stack pointer register to allocate the fresh
frame. This transfers the frame-id from the static instruction to
the active stack pointer (and subsequently the frame pointer).
We use the same dynamic tainting rules as in [28] to propagate
pointer tags between registers,
to and from memory, and
through pointer operations such as pointer arithmetic.
Accessing Objects: The way in which accesses to stack
objects are validated depends on the access type. For direct
frame pointer offset accesses, instructions are tagged with
the instruction-type ACCESS LOCAL and the speciﬁc object-
id that they access; these accesses use the frame-id from the
frame pointer. For the general pointer case, a special rule
allows the access when the frame-id and object-id of the
accessing pointer matches the frame-id and object-id of the
stack word.
Retagging the Stack Pointer: After each function call, the
compiler inserts one instruction to tag the stack pointer back
to the authority identiﬁer of the caller. The frame pointer gets
the correct tag by retrieving the stored frame pointer from the
stack memory in the function epilogue.
Passing Arguments: To handle the special case of argument
the Static Authorities policy sets aside a special
passing,
object-id for arguments (ARG) and tags stack words that
contain passed arguments with this special object-id. These
argument words are extended with another ﬁeld, argument for,
containing the authority (frame-id) of the intended consumer.
Access to words marked ARG are permitted with a special rule
that allows the accesses if the accessor’s frame-id matches the
argument’s indicated argument for ﬁeld. The way in which
we tag ARGs with the appropriate authority identiﬁer of the
expected callee depends on the type of function call. For
direct calls, the needed information is trivially available to
the compiler, and these words can be set up by appropriately
tagging the instructions that prepare the arguments before the
call instruction. For indirect calls (in which the callee authority
identiﬁer is not known statically), we add additional ﬁelds to
keep function pointers tagged with their appropriate frame-
id, so that at runtime we can setup the argument words with
correct frame-id based on the dynamic function pointer being
used. We describe these details in Appendix C.
Clearing Memory: To clear a function’s allocated memory,
the compiler adds additional instructions into the function
epilogue tagged CLEAR MEM that, with an appropriate
rule, can release the stack memory allocated by the function
by retagging the words currently owned by the function’s
frame-id with the tag EMPTY STACK. We choose epilogue
clearing over prologue clearing to limit the writing privilege
of each function to just the memory that it has allocated itself.
Security Properties: The Static Authorities policy tags each
object on the stack with a frame-id, indicating which function
owns the object, as well as an object-id, indicating which
object held by that frame is stored there. Accesses to stack
objects are validated with compiler assistance, using tags on
instructions and pointers. Accesses are permitted only if the
correct frame-id and object-id are used, preventing the out-
of-bounds accesses that give rise to stack attacks; both inter-
frame and intra-frame violations are prevented with the Static
Authorities tagging scheme. However,
in order to achieve
cacheability of the metadata rules, the policy does reuse the
same frame-id for each dynamic instance of a function. This
reuse constrains the number of tags and rules that are generated
to remain modest, i.e., remain proportional to the number of
active functions in an application. It also means that the policy
does not differentiate between dynamic instances of a stack
object; it shares this limitation with systems built on static
points-to analysis like WIT [34] and others [35]. The Static
Authorities policy provides both spatial and temporal security
properties—a dangling pointer is still bound to its speciﬁc
frame-id and object-id.
Non-stack pointers are tagged ⊥, which prevents them from
accessing stack memory. Stack pointers are prevented from
accessing other memory regions, which are tagged ⊥. These
rules prevent gross cross-region violations, including “stack
clashes” [36]. Additionally, by combining these rules with
strict epilogue rules that require the stack pointer tag to not
be ⊥, the policy protects against stack pivots similar to [37].
483
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:32:21 UTC from IEEE Xplore.  Restrictions apply. 
3) Depth Isolation:
Policy Description: The last policy we present, Depth Isola-
tion, is constructed in almost the same way as Static Author-
ities. However, instead of using a unique function identiﬁer
to serve as the frame-id,
the Depth Isolation policy uses
the current stack depth, d, as the frame-id for each function
instance—this allows the policy to discriminate between dy-
namic instances of a particular stack object. The policy uses
the same set of differentiable objects within a frame as in
Static Authorities: that is, a unique object-id for each program
variable, an object-id for stack control data, and an object-id
for argument passing.
Conceptually, the system will maintain the current stack
depth, d, and all functions will use it to tag the dynamic
instances that they allocate. The full rules for the policy are
available in Appendix D.
Policy Implementation: Our Depth Isolation implementation
differs from Static Authorities in only a few aspects, so we
present the differences here. The other implementation details
are the same.
Maintaining Stack Depth: This policy requires tracking the
current stack depth to serve as the frame-id, which we choose
to place in the tag on the stack pointer register. In the function
prologue, the compiler tags the instruction that allocates the
stack frame with INCR–DEPTH; with an appropriate rule,
this causes the value held in the tag, d, to be updated to
d+1. Similarly, in the function epilogue, the compiler tags the
instruction that releases the stack frame with DECR–DEPTH,
which, with an appropriate rule, replaces the current depth, d,
with d-1.
Argument Passing: Argument passing in the Depth Isola-
tion policy is simpler than in the Static Authorities policy. We
tag stack words that contain arguments with the object-id ARG
and the current depth of caller d, but we do not need to extend
them with argument for as was done in Static Authorities.
Instead, in the Depth Isolation policy, we require that the depth
of the accessor to argument words is either d, the depth of the
owner, or d+1, the depth that will be used by the callee; no
other depths are permitted to access arguments.
Other: The Depth Isolation policy does not need to retag
the stack pointer after returning from a call because there is
no authority identiﬁer kept on the stack pointer; the depth
decrement by the caller sufﬁciently resets the stack pointer. In
Depth Isolation instructions have no authority identiﬁer and
so are only tagged with their instruction-type on initialization.
Security Properties: The Depth Isolation policy, like Static
Authorities, prevents out-of-bounds accesses to objects on the
stack by requiring that the frame-id and object-id tags of the
instruction or pointer match those of the accessed memory
word—and so it has similar security properties to Static
Authorities. However,
the Depth Isolation policy provides
better spatial memory safety properties than Depth Isolation,
as each live function instance (even of the same static function)
484
has a unique frame-id. The Depth Isolation policy has weaker
temporal guarantees; a dangling pointer tagged for a particular
frame-id and object-id may be able to be used for unintended
instances.
A. Methodology
V. EVALUATION
We model the runtime overheads for our stack protection
policies on the SPEC CPU2006 [38] benchmark set running on
a simulated metadata-enhanced Alpha microarchitecture. We
compile the benchmarks using gcc with the -O2 optimization
level. We allow each benchmark to complete any benchmark-
speciﬁc initialization, such as parsing input ﬁles or setting up
data structures, and then run it for an additional one billion
warm up instructions. After completing initialization and warm
up, we then collect statistics from the system for a 500M
instruction measurement period.
1) Microarchitecture: For concrete evaluation, we target a
single-issue, in-order Alpha microarchitecture with a uniﬁed
512KB L2 cache, a 64KB L1 instruction cache and a 64KB
L1 data cache. We use a wide-word, coupled metadata imple-
mentation for tags, so tags are moved atomically with their
associated data words. We simulate a 1024 entry L1 PUMP
cache and a 4096 entry L2 PUMP cache. We use the same
basic architecture optimizations as in [17]. Shortened metadata
tags in our L1 cache system are 11 bits, and shortened
metadata tags in our L2 system are 14 bits, with full 64-bit
tags in DRAM. At these sizes, running with a 1 GHz clock in a
32 nm process, the L1 and L2 cache access cycles are 1 and 5
cycles for both the baseline and tagged cases based on CACTI
[39] estimates. Cache lines are 8 words and require 100 cycles
to fetch from DRAM in the no-tag case and up to 130 cycles
in the tagged case; since tags live on the same DRAM page
with the data, they cost additional cycles for bandwidth but
do not require additional latency for page access or writeback.
The main memory cache compression from [17] means most
cache line accesses can fetch compressed tag descriptions for
the cache line and consequently require fewer than 130 cycles
to fetch the data and tags from DRAM.