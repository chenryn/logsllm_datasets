    prime1:
    [...]
这里我们可以看到模数n、公钥指数e和私钥指数d。它们是使用大端字节顺序的十六进制数字表示的。我们实际上需要一个2048位的密钥，而不是512位的，但道理您应该清楚了。
伪造签名很容易。我们取证书的前六个字段的MD5哈希值，根据规范添加一些常量[11]，然后用终端服务密钥[8]的私有部分进行加密。具体可以利用下列Python代码来完成：
我们需要拦截的下一个消息是包含加密的Client Random的消息。它看起来如下所示：
    From client:
    00000000: 03 00 01 1F 02 F0 80 64 00 08 03 EB 70 81 10 01 .......d....p...
    00000010: 02 00 00 08 01 00 00 DD 8A 43 35 DD 1A 12 99 44 .........C5....D
    00000020: A1 3E F5 38 5C DB 3F 3F 40 D1 ED C4 A9 3B 60 6A .>.8.??@....;`j
    00000030: A6 10 5A AF FD 17 7A 21 43 69 D0 F8 9B F1 21 A3 ..Z...z!Ci....!.
    00000040: F1 49 C6 80 96 03 62 BF 43 54 9D 38 4D 68 75 8C .I....b.CT.8Mhu.
    00000050: EA A1 69 23 2F F6 E9 3B E7 E0 48 A1 B8 6B E2 D7 ..i#/..;..H..k..
    00000060: E2 49 B1 B2 1B BF BA D9 65 0B 34 5A B0 10 73 6E .I......e.4Z..sn
    00000070: 4F 15 FA D7 04 CA 5C E5 E2 87 87 ED 55 0F 00 45 O..........U..E
    00000080: 65 2C C6 1A 4C 09 6F 27 44 54 FE B6 02 1C BA 9F e,..L.o'DT......
    00000090: 3B D8 D0 8D A5 E6 93 45 0C 9B 68 36 5C 93 16 79 ;......E..h6..y
    000000A0: 0B B8 19 BF 88 08 5D AC 19 85 7C BB AA 66 C4 D9 ......]...|..f..
    000000B0: 8E C3 11 ED F3 8D 27 60 8A 08 E0 B1 20 1D 08 9A ......'`.... ...
    000000C0: 97 44 6D 33 23 0E 5C 73 D4 02 4C 20 97 5C C9 F6 .Dm3#.s..L ...
    000000D0: 6D 31 B2 70 35 39 37 A4 C2 52 62 C7 5A 69 54 44 m1.p597..Rb.ZiTD
    000000E0: 4C 4A 75 D2 63 CC 52 15 8F 6E 2A D8 0D 61 A5 0A LJu.c.R..n*..a..
    000000F0: 47 5B 2A 68 97 7B 1B FF D3 33 10 49 15 9A D6 2C G[*h.{...3.I...,
    00000100: DF 04 6D 93 21 78 32 98 8B 0B F4 01 33 FB CC 5B ..m.!x2.....3..[
    00000110: 83 BA 2D 7F EA 82 3B 00 00 00 00 00 00 00 00 ..-...;........
同样，这里也高亮显示了加密的Client Random，其中前面的四个字节表示其长度（0x0108）。
由于它是用我们的证书来加密的，那么自然可以轻松解密了：
    00000000: 4bbd f97d 49b6 8996 ec45 0ce0 36e3 d170 K..}I....E..6..p
    00000010: 65a8 f962 f487 5f27 cd1f 294b 2630 74e4 e..b.._'..)K&0t.
我们只需要使用服务器的公钥重新加密它，并在传递它之前进行相应的替换即可。
不幸的是，事情还没有结束。我们现在知道了秘密的Client
Random，但不知道什么原因，微软并没有单纯用它作为对称密钥。有一个精心制作程序[6]可以导出客户端的加密密钥、服务器的加密密钥和签名密钥。
在导出会话密钥之后，我们可以初始化RC4流的s-box。由于RDP对于来自服务器的消息使用单独的密钥，而不是来自客户端的消息，因此我们需要两个s-box。s-box是一个256字节的数组，会根据密钥按照某种特定的方式进行重排。然后，s盒就会产生伪随机数流，用来与数据流进行异或处理。这个过程可以用下列Python代码完成：
正如你所看到的那样，协议要求密钥对4096个数据包加密后进行更新。但是这里我不打算实现这一点，因为我只是对凭证安全性的概念证明感兴趣，所以不想弄那么复杂。不过，如果读者学有余力的话，可以自行补上！
现在，我们已经万事俱备，足以读取所有的流量了。我们对含有键盘输入事件（即按键和按键释放）信息的数据包特别感兴趣。我从规范[12]了解到，消息可以包含多个数据包，并有慢路径包（从0x03开始）和快路径包（第一个字节可被四整除）。
键盘输入事件[13]由两个字节组成，例如：
    1 00000000: 01 1F ..
这意味着“S”键（0x1F）已被释放（因为第一个字节是0x01）。
当然，这里的解析工作处理的不是很到位，因为有时鼠标移动事件会被识别为键盘事件。此外，scancode需要转换为虚拟键代码，这取决于键盘类型和键盘布局。这样做好像有点复杂，所以我没有这样做，而是直接采用了参考资料[14]中的方法。对于概念验证来说，这已经足够好了。
让我们试验一下。连接到我们的虚假RDP服务器后，我们收到警告说无法验证服务器的真实性：
图4：无法验证服务器的身份…
注意到了吗？这不是SSL的警告。但是无论如何，我们现在已经可以看到按键了（见图5）。
顺便说一下，这正是Cain所做的事情。
**攻陷增强型RDP安全协议**
对我来说，降级到标准RDP安全协议是无法令人满意的。如果我是一个攻击者，我会尽量让攻击看起来不那么不显眼。在上面的情形中，受害人会注意到一个与平常不同的警告，并且在连接已经建立之后还必须输入其凭证。
当我使用Cain通过MitM方式攻击RDP连接时，要是没有看到相同的SSL警告的话，我会很不爽的。因为如果这个MitM工具会导致显示完全不同的警告的话，那么我就很难向客户解释为什么必须认真对待SSL警告，特别是当他们使用了未经验证的自签名证书的时候。
图5：以明文显示的键盘输入事件。密码是Secr3t！
因此，让我们尝试将连接降级为增强型RDP安全协议。为此，我们需要自己的自签名SSL证书，不过这可以由openssl生成：
    $ openssl req -new -newkey rsa：“$ KEYLENGTH”-days“$ DAYS”-nodes -x509 
    -subj“$ SUBJ”-keyout privatekey.key -out certificate.crt 2> / dev / null
我们需要在正确的时间将我们的Python
TCP套接字封装到SSL套接字中，这对于我们来说不成问题。我之前说过，标准的RDP协议使用了SSL隧道，但服务器总是选择“None”作为其加密级别。这简直太好了，因为可以安全地假设SSL封装器能确保数据的真实性和完整性。在SSL之上使用RC4是没有必要的，因为这就是在资源浪费。提取击键的工作方式与前一节完全相同。
唯一多出来的安全功能就是服务器会对原始协议协商请求进行确认。
在建立SSL连接后，服务器会对客户端说：“顺便说一下，你告诉我这些是你能够处理的安全协议。”用二进制表示的话，它看起来像这样：
    From server:
    00000000: 03 00 00 70 02 F0 80 7F 66 66 0A 01 00 02 01 00 ...p....ff......
    00000010: 30 1A 02 01 22 02 01 03 02 01 00 02 01 01 02 01 0..."...........
    00000020: 00 02 01 01 02 03 00 FF F8 02 01 02 04 42 00 05 .............B..
    00000030: 00 14 7C 00 01 2A 14 76 0A 01 01 00 01 C0 00 4D ..|..*.v.......M
    00000040: 63 44 6E 2C 01 0C 10 00 04 00 08 00 01 00 00 00 cDn,............
    00000050: 01 00 00 00 03 0C 10 00 EB 03 04 00 EC 03 ED 03 ................
    00000060: EE 03 EF 03 02 0C 0C 00 00 00 00 00 00 00 00 00 ................
然后，客户端可以将该值与最初在第一个请求中发送的值进行比较，如果不匹配，则终止连接。显然，这时已经太晚了。我们作为中间人，可以通过用其原始值（在这种情况下为0x03）替换相应字节（在偏移量为0x4C处的高亮显示字节）来隐藏来自客户端的伪协商请求。
之后，我们可以毫无阻碍的侦听一切流量了。好了，继续努力。
如预期的那样，受害者这里看到的是SSL警告。但这事仍然不够圆满。因为在建立RDP连接之前，没有提示我们输入凭据，而是直接显示了Windows登录屏幕。与NLA不同，认证是在会话内部进行的。同样，这仍然有别于典型的管理工作流程，很容易被精明的用户觉察到。
**突破CredSSP协议**
好吧，我承认：这里我们没有直接攻陷CredSSP协议。但我们会找到一种方法来绕过它。
首先，让我们看看如果我们不降低连接的安全等级的话，会发生什么。这时，发送到服务器的相关消息如下所示：
    From client:
    00000000: 30 82 02 85 A0 03 02 01 04 A1 82 01 DA 30 82 01 0............0..
    00000010: D6 30 82 01 D2 A0 82 01 CE 04 82 01 CA 4E 54 4C .0...........NTL
    00000020: 4D 53 53 50 00 03 00 00 00 18 00 18 00 74 00 00 MSSP.........t..
    00000030: 00 2E 01 2E 01 8C 00 00 00 08 00 08 00 58 00 00 .............X..
    00000040: 00 0A 00 0A 00 60 00 00 00 0A 00 0A 00 6A 00 00 .....`.......j..
    00000050: 00 10 00 10 00 BA 01 00 00 35 82 88 E2 0A 00 39 .........5.....9
    00000060: 38 00 00 00 0F 6D 49 C4 55 46 C0 67 E4 B4 5D 86 8....mI.UF.g..].
    00000070: 8A FC 3B 59 94 52 00 44 00 31 00 34 00 55 00 73 ..;Y.R.D.1.4.U.s
    00000080: 00 65 00 72 00 31 00 57 00 49 00 4E 00 31 00 30 .e.r.1.W.I.N.1.0
    00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
    000000A0: 00 00 00 00 00 00 00 00 00 11 0D 65 8E 92 7F 07 ...........e....
    000000B0: 7B 04 02 04 0C C1 A6 B6 EF 01 01 00 00 00 00 00 {...............
    000000C0: 00 D5 FD A8 7C EC 95 D2 01 A7 55 9D 44 F4 31 84 ....|.....U.D.1.