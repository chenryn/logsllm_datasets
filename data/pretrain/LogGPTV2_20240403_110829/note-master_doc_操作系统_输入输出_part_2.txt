当外设准备好后，通知DMA控制器，DMA控制器从CPU接管总线，并完成外设和内存之间的大量数据传输；传输完成后DMA控制器将总线控制权交还给CPU，整个数据交换的过程不需要CPU参与
**设备控制器内部缓存区存在的原因**
- 校验数据
- 总线可能忙
**优点：** 既有中断的优点，同时又降低了服务开销。
**缺点：** 控制电路更加复杂。
**应用场合：** 高速、大批量数据传输。
#### DMA控制器的两种工作状态
- 被动态（受控器）：未取得总线控制权，受CPU的控制
- 主动态（主控器）：接管并取得总线控制权，取代CPU而成为系统的主控者。
#### 传输步骤
申请阶段：一个设备接口试图通过总线直接向另一个设备发送数据(一般是大批量的数据)，它会先向CPU发送DMA请求信号
响应阶段：CPU收到DMA请求信号后，在当前的总线周期结束后，会按DMA信号的优先级和提出DMA请求的先后顺序响应DMA信号
数据传送阶段：CPU对某个设备接口响应DMA请求时，会让出总线控制权；于是在DMA控制器的管理下，外设和存储器直接进行数据交换，而不需CPU干预
传送结束阶段：数据传送完毕后，设备接口会向CPU发送DMA结束信号，交还总线控制权
#### 操作类型
数据传送：把源地址的数据传输到目的地址去（存储器或I/O）
数据校验：不进行数据传输，只对数据块内部的每个字节进行某种校验；这种数据校验一般安排在读数据块之后，以便校验所读的数据是否有效
数据检索：不进行数据传输，只是在指定的内存区域内查找某个关键字节或某几个数据位是否存在
#### 操作方式
- 单字节传输模式
- 块传输模式
- 请求参数模式
- 级联传输模式
### 零拷贝
对IO设备的读写，不将IO设备的数据先复制到内核空间，然后再复制到用户空间，以此获得更高的读写性能
这就是由 DMA 所完成的
#### 用户态直接IO
硬件上的数据直接拷贝至了用户空间，不经过内核空间
![屏幕截图 2022-06-14 153015](/assets/屏幕截图%202022-06-14%20153015.png)
#### mmap+write
实现内核缓冲区与应用程序内存的共享，省去了将数据从内核读缓冲区（read buffer）拷贝到用户缓冲区（user buffer）的过程，然而内核读缓冲区（read buffer）仍需将数据到内核写缓冲区（socket buffer）
![屏幕截图 2022-06-14 153136](/assets/屏幕截图%202022-06-14%20153136.png)
主要的用处是提高 I/O 性能，特别是针对大文件。对于小文件，内存映射文件反而会导致碎片空间的浪费
#### sendfile
```c
#include ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```
简化通过网络在两个通道之间进行的数据传输过程。sendfile 系统调用的引入，不仅减少了 CPU 拷贝的次数，还减少了上下文切换的次数
![屏幕截图 2022-06-14 154509](/assets/屏幕截图%202022-06-14%20154509.png)
sendfile 存在的问题是用户程序不能对数据进行修改
#### sendfile+ DMA gather copy
将内核空间（kernel space）的读缓冲区（read buffer）中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（ socket  buffer）中，由 DMA 根据内存地址、地址偏移量将数据批量地从读缓冲区（read buffer）拷贝到网卡设备中
![屏幕截图 2022-06-14 154734](/assets/屏幕截图%202022-06-14%20154734.png)
同样也不能对数据进行修改
#### splice
```c
splice(fd_in, off_in, fd_out, off_out, len, flags);
```
跟sendfile很像
![屏幕截图 2022-06-14 155235](/assets/屏幕截图%202022-06-14%20155235.png)
#### 写时复制
当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么就需要将其拷贝到自己的进程地址空间中
#### 缓冲区共享
每个进程都维护着一个缓冲区池，这个缓冲区池能被同时映射到用户空间（user space）和内核态（kernel space），内核和用户共享这个缓冲区池，这样就避免了一系列的拷贝操作
![屏幕截图 2022-06-14 155416](/assets/屏幕截图%202022-06-14%20155416.png)
### 通道和I/O处理机
在复杂的计算机系统中，外围设备的台数一般比较多，设备的种类、工作方式和工作速度的差别很大，为了把对外围设备的管理工作从CPU中分离出来，采用通道或I/O处理机方式
通道是能够专门执行I/O指令的处理机，它可以实现对外围设备的统一管理，以及外设与主存之间的数据传输
I/O处理机是通道方式的进一步发展，它的结构更接近于一般处理机。
## IO软件层次
![屏幕截图 2021-01-13 162227](/assets/屏幕截图%202021-01-13%20162227.png)
### 中断处理程序
> 在响应一个特定中断的时候，内核会执行一个函数，该函数叫中断处理程序
隐藏中断的最好方式是将会引起中断的操作阻塞起来。但中断处理需要花费相当多的CPU指令。
### 设备驱动程序
> 每个链接到计算机上的IO设备都需要某些设备特定代码进行控制，称之为**设备驱动程序**
USB设备驱动通过堆栈式来达到不同的设备基于同样的技术效果。为了访问设备的硬件，大多数操作系统都要求驱动程序运行在内核中，这也是系统崩溃的一个源头之一。
**可重入性**：驱动必须意识到第一次调用完成之前第二次调用会到来
### 与设备无关的IO软件
- 设备驱动程序的统一接口
对于每种设备类型类型，操作系统定义一组驱动程序必须支持的函数，设备名可以使用设备类型+次版本号来编码，同样，对文件系统的保护规则也适用于设备。
- 缓冲
![屏幕截图 2021-01-14 155141](/assets/屏幕截图%202021-01-14%20155141.png)
双缓冲：使用两个缓冲区交替使用，当一个满了之后直接复制到用户空间，另外一个接替上
环形缓冲：通过两个前后指针不断往前走实现一个逻辑上无限的缓冲区
- 错误报告
对于编程错误，如向一个输入设备发出了一个输出请求，操作系统直接返回错误码即可。
但对于实际的IO错误，应由驱动程序决定做什么，驱动程序解决不了，再向高层传递。但错误抛到高层，操作系统实际上除了返回一个错误码并失败外，并不存在其他多少事情可以做。
- 分配与释放专用设备
对于只允许有限数量进程使用的设备，操作系统必须对设备的使用请求进行检查，可以将得不到设备的进程调用失败掉。另外一种方式可以对得到设备的进程调用进行阻塞，而不是让其失败。
- 提供与设备无关的块大小
上层软件屏蔽掉不同设备的的块大小不一致
### 用户空间的IO软件
部分IO操作在用户空间完成，这是通过库过程来实现，也有通过假脱机的方式及守护进程的方式实现。
假脱机：IO设备通过一个文件来代表IO处理，用户进程直接处理这个文件来实现IO。
守护进程：用户进程通过将文件放置于某个目录下的，该目录称为假脱机目录，只有一个允许访问IO设备的进程，来读取这些文件进行操作，这个进程就是守护进程。
![屏幕截图 2021-01-14 170929](/assets/屏幕截图%202021-01-14%20170929.png)
### IO模型
- BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成
- NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的 I/O 模型,支持面向缓冲的，基于通道的 I/O 操作方法
- AIO (Asynchronous I/O):异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作
```mermaid
sequenceDiagram
  title BIO
  进程 ->> 操作系统: read
  loop
    操作系统 ->> 操作系统: 等待数据
  end
  操作系统 ->> 进程: 返回数据
```
```mermaid
sequenceDiagram
  title 多路复用非阻塞IO
  进程 ->> 操作系统: epoll
  loop
    操作系统 ->> 操作系统: 等待通道数据就绪
  end
  操作系统 ->> 进程: 返回数据就绪的通道
  进程 -->> 通道1: 非阻塞read
  通道1 -->> 进程: 有没数据都立即返回
  进程 -->> 通道2: 非阻塞read
  通道2 -->> 进程: 有没数据都立即返回
```
```mermaid
sequenceDiagram
  title 异步IO
  进程 ->> 操作系统: read
  操作系统 ->> 进程: 立即返回
  loop
    操作系统 ->> 操作系统: 准备数据
  end
  操作系统 -->> 进程: 异步通知进程数据到达
```
#### 阻塞与非阻塞
阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程
Linux 默认的 read 与 write 系统调用就是阻塞的，但如果设置了 O_NONBLOCK O_NONBLOCK 标志，read 如果没有读到数据，则会简单返回 -EAGAIN，不像默认的 read 会等待直至有数据进来
#### 同步与异步
同步和异步关注的是消息通信机制
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待这个*调用*的结果。
而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用
异步 IO 的实现有 Windows 的 IOCP、C++的 Boost asio、Linux 下的 aio
#### IO 多路复用
特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回
epoll select poll 都属于这种机制
```c
/* 
函数中定义了几个描述符集合，然后内核会关注这些描述符集合中
哪些描述符就绪了，然后返回已就绪的描述符个数，业务程序需要遍历所有的描述符集合
来找到可处理的描述符集合
 */
int select (int __nfds, fd_set *__readfds, fd_set *__writefds, fd_set *__exceptfds, struct timeval *__timeout)