or less instructions executed inside of it.
(cid:140)e dynamic analysis component does not need to log the entire
execution trace. (cid:140)is is because the pair-wise execution order of
instructions gives us information to reconstruct control-(cid:131)ow within
each code wave, and identi(cid:128)cation and analyses of code injections
only require API calls, code-reuse a(cid:138)acks and taint-logging infor-
mation. Additionally, for each code injection we can construct the
injection mechanics even without the taint-log because we don’t
need to backtrack on the taint propagations. We only need the
taint-logging information to derive the entire code injection graph.
As such, Tartarus comes with two se(cid:138)ings, one that produces the
taint-log and one that does not. (cid:140)e one that does not produces
minimal outputs (a few MB) from the dynamic analysis where taint
logs can become several (1-5) GBs for a large malware sample. In
total, Tartarus consists of about 9000 lines of C code and 3500 lines
of Python.
7 EVALUATION
To verify the e(cid:130)ectiveness of Tartarus, we have evaluated it against
a set of benchmark applications comprising synthetic applications
and real-world malware. In Section 7.1 we experimentally validate
the correctness of Taturatus by matching it with applications where
we have ground-truth. (cid:140)en in Section 7.2 we compare Tartarus
with previous works and our results show that Tartarus is more
precise by (cid:128)nding code injections in more applications. In Section
7.3 we perform in-depth analysis on two case studies, demonstrating
that Tartarus is able to capture malware propagations, dynamically
generated and code injections, and also give valuable insights about
the three. In Section 7.4 we present a study on the performance of
Tartarus relative to malware samples in our experiments, and (cid:128)nally
in Section 7.5 we report observations from matching Tartarus with
934 recently collected PE (cid:128)les from online malware repositories.
7.1 Experimental validation of correctness
In our (cid:128)rst experiment we empirically evaluate the correctness of
Tartarus. To do this, we match Tartarus with applications where
we know if the applications perform code injections or not. In
total, Tartarus is evaluated against three data sets comprising 49
applications.
(cid:140)e (cid:128)rst set, A, is composed of several code injection techniques
that are publicly documented. Four of these techniques include
code-reuse a(cid:138)acks and six of them do not. (cid:140)e second set, B, is com-
posed of a set of malware samples from 4 malware families where
anti-malware companies have documented that these malware sam-
ples inject code into other processes. We have only selected (cid:128)les
from reports where hashsums are given for the malware samples
to ensure we select correct samples. (cid:140)e third set, C, is composed
of benchmark applications where we are sure they do not inject
Samples
(A) PowerLoader
(A) PowerLoaderEx
(A) AtomBombing
(A) Codeless
(A) WPM, CRT
(A) WPM, STC, RT
(A) WPM, QAPC
(A) MVS, STC, RT
(A) MVS, CRT
(A) MVS, QAPC
(B) CryptoWall 4 [1]
(B) Gapz [36]
(B) Ramnit [35]
(B) Tinba [25]
Total




# num CRI
1
1
1
1
1
1
1
1
1
1
4
4
12
8
38

Tartarus CO CS
CI
CRI CI CI
0
0
1
0
0
1
1
0
0
0
0
1
1
1
0
1
0
0
0
0
0
0
0
1
1
1
0
0
0
0
4
0
0
3
1
1
7
4
0
8
8
0
7
15
24
1
1
1
1
1
1
1
1
1
1
4
4
12
8
38
Table 2: Evaluation with code injecting binaries.
#CRI = Code-reuse injection, #CI = Code Injection,
#Codeless = Modi(cid:128)ed version of Atombombing that
relies purely on code-reuse a(cid:138)acks.
#WPM = WriteProcessMemory, #CRT = CreateRemote(cid:140)read,
#STC = Set(cid:140)readContext, #RT = Resume(cid:140)read,
#QAPC = (cid:139)eueUserAPC/Nt(cid:139)eueUserAPC, #MVS =
MapViewOfSection, #CO = Codisasm, #CS = CuckooSandbox.
samples
(C) WCET [19]
Tartarus CO CS
CI
0
CI
0
# num CI
11
0
Table 3: Evaluation with non code-injecting binaries.
code into other processes. (cid:140)e benchmarks collected are all from
the WCET benchmark suite [19].
(cid:140)e (cid:128)rst (cid:128)ve columns of Table 2 show the results of matching
Tartarus with the samples from set A and B. As can be seen, Tartarus
correctly identi(cid:128)es code injection in all of the code injecting binaries,
and also identi(cid:128)es when code-reuse a(cid:138)acks are part of the code
injection techniques.
Given that our technique relies on taint to capture malware
execution, it is imperative that the taint does not explode. Tartarus
(cid:128)nds no code injecting binaries when matched with our data set
C, as shown in the (cid:128)rst three columns of Table 3. However, these
samples are fairly simple and do not behave in any complex system-
interactive behaviours. To measure the number of false positives
Tartarus produces in contexts where the samples use a lot of system
activities we match for each malware sample in dataset B the code
injections as identi(cid:128)ed by Tartarus with those identi(cid:128)ed in the
anti-malware companies’ reports.
In [25] CSIS and Trend Micro reports that Tinba injects into
winver.exe, explorer.exe, svchost.exe, (cid:128)refox.exe and iexplore.exe. In
6 of the 8 samples we analysed, Tartarus found injections into
winver.exe, explorer.exe, (cid:128)refox.exe and chrome.exe. In 1 of the 2
other samples Tartarus found injections into winver.exe, explorer.exe,
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1699svchost.exe, (cid:128)refox.exe and chrome.exe and (cid:128)nally in the last sample
Tartarus found injections into 20 processes on the system. We
picked 2 samples of the (cid:128)rst 6 to con(cid:128)rm that the malware indeed
injects into chrome.exe, and we also manually analysed the last
sample to verify that the sample injects into all processes on the
system for which it has privileges.
In [36] researchers from eset report that Gapz injects code into
the Windows process explorer.exe and also uses code-reuse a(cid:138)acks.
Tartarus found code injections into explorer.exe in 3 of the 4 sam-
ples we analysed and code-reuse a(cid:138)acks in all 3 of these. In two
of these samples Tartarus captured explorer.exe to be the only pro-
cess where injection occurred, where in the other one Tartarus
captured code injections into explorer.exe but also svchost.exe and
winlogon.exe. (cid:140)is sample contained about 3800 unique instructions
inside explorer.exe and only 22 and 138 unique instructions within
svchost.exe and winlogon.exe, respectively. (cid:140)e last sample exhibited
no code-reuse a(cid:138)acks and injected code into svchost.exe rather than
explorer.exe. We veri(cid:128)ed manually that this malware does indeed
inject code into svchost.exe and relies on CreateProcessInternalW
and Resume(cid:138)read functions, and no code-reuse a(cid:138)acks, to perform
the injection.
In [35] researchers from Symantec report that Ramnit injects
code into IEXPLORE.EXE and svchost.exe. In 9 out of the 12 Ram-
nit samples Tartarus found injections into IEXPLORE.EXE and sv-
chost.exe. In the remaining three samples, Tartarus captured code
injection into IEXPLORE.EXE and svchost.exe but also 25, 20 and 17
instructions inside of drwtsn32.exe, respectively.
In [1] researchers from Cisco report that CryptoWall 4 injects
into svchost.exe and explorer.exe. In all four samples of CryptoWall
4.0 in our data set we observed malware execution in these two
processes. In two of the samples svchost.exe and explorer.exe were
the only processes of which injection occurred. In the two other
samples, Tartarus also captured 20 and 17 instructions inside vssas-
mind.exe, respectively.
7.2 Comparative evaluation
To assess the quality of our results, we put Tartarus in context with
other approaches. Our second experiment, presented in this section,
compares our solution with two approaches that are state-of-the
art in malware analysis. We speci(cid:128)cally compare our tool with a
recent malware disassembler, Codisasm [5], and a coarse-grained
malware analysis platform, namely Cuckoo Sandbox.
Codisasm relies on both static and dynamic analysis and is aimed
at disassembling binaries with self-modifying code and overlapping
instructions. (cid:140)e tool is built on top of PIN and hooks two API calls
CreateRemoteThread and CreateRemoteThreadEx to follow the
malware propagation. Although Codisasm is designed as a malware
disassembler, it relies on capturing an instruction-level execution
trace of the malware to perform the disassembly. It furthermore
identi(cid:128)es dynamically generated code by monitoring for execution
of memory that is explicitly wri(cid:138)en by the malware, as described
in Section 4. As such, Tartarus and Codisasm both capture the
execution trace and dynamically generated code, although with
two di(cid:130)erent approaches, and this is the reason we select it as a
comparative benchmark. CuckooSandbox is a malware analysis tool
that is heavily used in industry and deploys a malware analyser with
In comparison to Cuckoo Sandbox, the (cid:128)rst thing we noticed
is that Cuckoo Sandbox fails on all four synthetic injection tech-
niques that rely on code-reuse a(cid:138)acks. Furthermore, Cuckoo fails
to observe code injection in 3 of the Gapz malware samples and 5
of the Ramnit malware samples. (cid:140)e sample from the Gapz family
that Cuckoo correctly identi(cid:128)ed as containing code injection was
the sample without code-reuse a(cid:138)acks as described above. (cid:140)e use
of ResumeThread was accurately reported by both Tartarus and
Cuckoo Sandbox.
(cid:140)e second thing we notice when comparing to Cuckoo is that
Cuckoo failed to correctly identify code injections via remote proce-
dure calls. We believe this is because many remote procedure calls
do not constitute code injections. (cid:140)erefore Cuckoo cannot create
a hook and label each remote procedure call an injection because
it will produce many false positives. Tartarus does not run into
this problem because tainted code must be be executed for Tartarus
to declare that a code injection occurs, and Tartarus can therefore
identify which remote procedure calls result in a code injection.
It may seem Tartarus should identify a code reuse a(cid:138)ack for the
remote procedure calls because an indirect branch in the target
process transfers execution to a value set by the process sending
the remote procedure call. However, in our cases, the destination of
the indirect branch is tainted code so the conditions for a code-reuse
a(cid:138)ack, as described in Section 3.5, are not satis(cid:128)ed. Furthermore,
it is important to note here that even in the case where a remote
procedure call is performed, and not to tainted memory, then we
will still not declare it as a code injection because only 1 code-reuse
a(cid:138)ack will be observed. As such, it does not satisfy the conditions
for a code injection described in Section 5 because there is no target
instruction nor a chain of code-reuse a(cid:138)acks.
system and API call granularity [11]. It contains many techniques
for automatically following malware in case of code injections. Both
Codisasm and CuckooSandbox follow malware based on function
hooking and heuristics about known injection techniques.
(cid:140)e results of executing our sample set A and B in Codisasm and
CuckooSandbox is shown in column 6 and 7 of Table 2. As can be
seen Tartarus outperformed both CuckooSandbox and Codisasm
by a large margin. CuckooSandbox detected code injection in 24
samples and Codisasm in 15 samples of the 38 applications.
Codisasm found code injections in 15 of the 36 samples. In par-
ticular, Codisasm found code injections in both of the synthetic
samples that relied on CreateRemote(cid:138)read. Because we don’t have
direct access to their system, but rather through a web interface,
it is di(cid:129)cult to assess the speci(cid:128)c cause of limitations in the other
samples. For several samples we would get get error messages back
from the server that either an unknown malfunction occurred or
the timeout occurred because the system had crashed or wasn’t able
to produce any traces. However, we consider the limitations to be a
result of two properties: one conceptual and one in the implementa-
tion. In terms of conceptual limitation, Codisasm follows malware
propagation based on monitoring calls to CreateRemoteThread
and CreateRemoteThreadEx. However, there are many techniques
that do not use either of these API functions to inject code. Notably
only 2 out of 10 injection techniques in data set A makes use of
CreateRemoteThread. From an implementation point of view, the
dynamic analysis component of Codisasm relies on PIN. PIN is a
process-level dynamic binary instrumentation framework and has
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1700Malware.exe
wave0
4150
instrs
wave1
2700
instrs
explorer.exe
wave2
3567
instrs
SetWindowsLong
SendNotifyMessage
Code-
reuse
attacks
23 instrs
wave1
456 instrs
wave0