www.TopSage.com
一加法的底数)。下面这些都是这两个
5.4剩余形参
49
---
## Page 67
foo可以用下列形式调用：
选形参那样。因为关键字实参带有标签，所以它们在必要实参之后可按任意顺序进行传递。例如
章所述，关键字是以冒号开始的名字，并且它们被自动定义为自求值常量。
有关键字形参的函数：
&key以及任意数量的关键字形参标识符，后者的格式类似于可选形参标识符。下面就是一个只
参类型，关键字形参，它可以允许调用者指定具体形参相应所使用的值。
个显式的值，就会导致前三个可选形参对于该调用者来说变成了必要形参。幸好我们有另一种形
想来解决的问题吗？
了。但是所有其他的调用者将不得不为所不关心的一到三个形参传递一些值。这不正是可选形参
值，并且更进一步，不同的调用者甚至有可能将分别选择使用其中一个参数。
5.5
样，FORMAT和+的形参列表可能看起来会是这样：
足了必要和可选形参之后的其余所有实参就将被收集到一个列表里成为该&rest形参的值。这
汗，这种绞尽脑汁的无聊事情绝对不是Lisp风格。
实现相关，但可以保证至少有50个。在当前所有实现中，它的最大值范围从4096到536870911。
这件事，还不得不使用一个合法函数调用所能够传递的那么多的可选形参。这一具体数量与具体
非常麻烦，光是写形参列表就已经足够麻烦了，何况还要在函数体中处理所有这些形参。为了做好
如果一个给定的关键字没有出现在实参列表中，那么对应的形参将被赋予其默认值，如同可
为了使函数带有关键字形参，在任何必要的&optional和&rest形参之后，可以加上符号
当然是。问题在于可选形参仍然是位置相关的——如果调用者想要给第四个可选形参传递一
相反，Lisp允许在符号&rest之后包括一揽子形参。如果函数带有&rest形参，那么任何满
50
① 常量CALL-ARGUMENTS-LIMIT将告诉你这个与具体实现有关的数值。
当调用这个函数时，每一个关键字形参将被绑定到紧跟在同名键字后面的那个值上。如第4
想为第一个形参提供值的调用者将会很方便—只需传递一个可选实参，然后忽略其他就好
尽管可选形参和剩余形参带来了很大的灵活性，但两者都不能帮助应对下面的情形。假设有
(foo
(foo
(foo
(defun foo (&key a b c) (list a b c))
(defun + (&rest numbers)
(defun format (stream string &rest values) ...)
(foo
(foo)
关键字形参
:a
第5章
1
L
:C 3}
函数
-→ (NIL NIL NIL)
(1 NIL 3)
(NIL NIL 1)
(NIL
www.TopSage.com
L
---
## Page 68
但是这样的话将报错：
这样也可以：
和&key形参：
吃掉原本用于关键字形参的关键字和值。例如，下面这个函数很不明智地混合了&optional形参
们一起使用。问题出在如果调用者没有为所有可选形参提供值时，那么没有得到值的可选形参将
种类型的形参组合使用，或者可能是组合&optional形参和&rest形参。其他两种组合方式，无
形参，最后才是关键字形参。但在使用多种类型形参的函数中，一般情况是将必要形参和另外一
种类型的形参时，它们必须以这样的顺序声明：首先是必要形参，其次是可选形参，再次是剩余
5.6混合不同的形参类型
论是&optional形参还是&rest形参，当与&key形参组合使用时，都可能导致某种奇怪的行为
内部使用短变量名，而不是API中的描述性关键字。不过该特性不常被用到。
可以让调用者这样调用它：
个foo的定义：
形参名替换成一个列表，令其含有调用函数时使用的关键字以及用作形参的名字。比如说下面这
在关键字形参和可选形参中，这个默认值形式都可以引用那些早先出现在形参列表中的形参。
(foo 1)→ (1 nil nil)
将&optional形参和&key形参组合使用时将产生非常奇怪的结果，因此也许应该避免将它
在单一函数里使用所有四种类型形参的情况虽然罕见，但也是可能的。无论何时，当用到多
(foo 12:z 3)→ (1 2 3)
如果像这样调用的话，就没问题：
(defun foo (x &optional y &key z) (list x y z))
这种风格在想要完全将函数的公共API与其内部细节相隔离时特别有用，通常是因为想要在
(foo :apple 10 :box 20 :charlie 30) → (10 20 30 T)
(defun foo (&key ((:apple a)) ((:box b) 0) ((:charlie c) 0 c-supplied-p))
同样，如果出于某种原因想让调用者用来指定形参的关键字不同于实际形参名，那么可以将
(defun foo (&key (a 0) (b 0 b-supplied-p) (c (+ a b)))
如同可选形参那样，关键字形参也可以提供一个默认值形式以及一个supplied-p变量名。
(list a b c c-supplied-p))
(foo :a 2 :b 1 :c 4) → (2 1
(foo :a 1 :c 3 :b 2) → (1 2 3)
4T)
1 NIL)
www.TopSage.com
5.6混合不同的形参类型
S
---
## Page 69
该名字不被求值，因此无需引用。
即以该值退出。RETURN-FROM是一个特殊操作符，其第一个“参数”是它想要返回的代码块名。
码块中。因此，对一个带有当前函数名和想要返回的值的RETURN-FROM进行求值将导致函数立
操作符所定义的代码块中返回。不过DEFUN会自动将其整个函数体包装在一个与其函数同名的代
数中间返回。
非常便利的。在这种情况下，你可以使用RETURN-FROM特殊操作符，它能够立即以任何值从函
返回值。这是从函数中返回值的最常见方式。
5.7
将得到如下结果：
&reat形参上；而适当的值，也会同时被绑定到&key形参上。因此，给定下列函数：
么基于关键字被分配到适当的&key形参中。如果&rest和&key同时出现在形参列表中，那么两
&optional形参之后的那些值被特别处理一
常地来讲，无论是&reat还是&key出现在形参列表中，都将导致所有出现在必要形参和
行为，就可以直接添加关键字形参，而无需修改甚至重新编译任何调用该函数的已有代码。
关键字形参将会使代码相对易于维护和拓展——如果需要为函数添加一些需要用到新参数的新
情况下添加新的关键字形参。也可以移除关键字形参，只要没人在使用它们。“一般而言，使用
它变成全部使用&key形参的形式—它们更灵活，并且总会可以在不破坏该函数的已有调用的
上，而&key形参z将得到默认值NIL，而不声明缺失了东西。
有两个&optional形参，上面最后一个调用将导致值:z和3分别被绑定到两个&optional形参
Lisp期待一个成对的关键字/值，或者什么也没有，否则就会报错。也许更坏的是，如果该函数带
在第20章将会看到，RETURN-FROM事实上不只用于函数，它还可以用来从一个由BLOCK特殊
但某些时候，尤其是想要从嵌套的控制结构中脱身时，如果有办法从函数中间返回，那将是
52
①有四个标准函数同时接受&optiona参数和&key参数一
目前写出的所有函数都使用了默认的返回值行为，即最后一个表达式的值被作为整个函数的
虽然可以安全地组合使用&rest形参和&key形参，但其行为初看起来可能会有一点奇怪。正
一般而言，如果正在编写一个同时使用&optional形参和&key形参的函数，可能就应该将
这是因为关键字：z被作为一个值填入到可选的y形参中了，只留下了参数3被处理。在这里，
(foo :a 1 :b 2 :c 3) → ((:A 1 :B 2 :C 3) 1 2 3)
(defun foo (&rest rest &key a b c) (list rest a b c))
READ-FROM-STRING还有两个&optional形参将参数：Start和10覆盖了。
s：start10）这样的调用看起来会忽略：start关键字形参，直接从索引位置0而非10处开始读取。这是因为
来。READ-FROM-STRING应该是新的Lisp程序员最常用到的函数之一
WRITE-LINE和WRITE-STRING。在标准化的过程中，出于跟早期LisP方言向后兼容的目的它们被原样保留了下
函数返回值
第5章
函数
www.TopSage.com
一要么作为&reat形参被收集到一个形参列表中，要
READ-FROM-STRING、PARSE-NAMESTRING
---
## Page 70
就可以得到如下的函数对象。
数同名的函数。这个名字是不被引用的。因此如果一个函数foo的定义如下。
道如何保持它们以及需要时如何调用它们。
都只是一些二进制数据——以原生编译的Lisp形式存在，可能大部分是由机器码构成。只需要知
创建一个函数而无需为其指定一个名字。一个函数对象的实际表示，无论是有名的还是匿名的，
创建一个新的函数对象以及赋予其一个名字。在第3章里我们看到，也可以使用LAMBDA表达式来
数已经是一种对代码比特进行抽象的标准方式，因此允许把函数视为数据也是合理的。
类似地，回调函数（callback）和钩子（hook）也需要能够保存代码引用便于以后运行。由于函
供一个比较任意两元素的函数，这样同样的底层算法就可以跟许多不同的比较函数配合使用了。
如，可以将一个函数作为参数传给另一个函数，从而能写出一个通用的排序函数，允许调用者提
5.8
诸如循环和条件语句这样的控制结构，都会求值得到一个值。因此在实践中这不是什么问题。
中出现的频率远小于return语句在源自C的语言里所出现的频率，因为所有的Lisp表达式，包括
就需要同时改变RETURN-FROM中所使用的名字。?但在事实上，显式的RETURN-FROM调用在LiSP
参数，它使用RETURN-FROM在发现之后立即返回该数对：
③一个函数对象的确切打印格式将随着不同的实现而有所不同。
②当然了，Lisp并不是唯一的将函数视为数据的语言。C使用函数指针；Perl使用子例程引用（subroutine reference）；
①另一个宏RETURN不要求使用一个名字。尽管如此，你不能用它来代替RETURN-FROM从而避免指定函数名，它是
特殊操作符FUNCTION提供了用来获取一个函数对象的方法。它接受单一实参并返回与该参
在Lisp中，函数只是另一种类型的对象。在用DEFUN定义一个函数时，实际上做了两件事
Python使用与Lisp相似的模式；C#使用了代理（delegate），其本质上是带有类型的函数指针；而Java则使用了相
一个从称为NIL的块中返回的语法糖。我将在第20章里跟BLOCK以及RETURN-FROM一起讨论其细节。
事实上，你已经用过FUNCTION了，但它是以伪装的形式出现的。第3章里用到的#·语法就是
CL-USER>(function foo)
CL-USER>（defun foo（x)（*2x）)
使用函数的主要方式是通过名字来调用它们，但有时将函数作为数据看待也是很有用的。例
必须承认的是，不得不指定正在返回的函数名多少会有些不便一
#
(defun foo(n)
下面这个函数使用了嵌套循环来发现第一个数对一
当笨重的反射（reflection）和匿名类机制。
作为数据的函数——高阶函数
(dotimes
(dotimes（j10)
(return-from foo（list i j))))))
(i10)
ij）n)
www.TopSage.com
5.8作为数据的函数一
一每个都小于10，并且其乘积大于函数的
一比如改变了函数的名字，
一高阶函数
e.com
---
## Page 71
数，假设你已有一个列表，其包括一个函数对象、一个最小值和一个最大值以及一个步长。换句
的函数EXP，它返回以e为底以其实参为指数的值。
输出打印多少星号。
并使用实参函数在min和max之间以stép为步长的返回值来绘制一个简单的ASCII式柱状图：
式将很可能被编译成相同的机器指令。
用的函数对象，其余的实参被传递到该函数中。因此，下面两个表达式是等价的：
来通过函数对象调用函数：FUNCALL和APPLY。?它们的区别仅在于如何获取传递给函数的实参。
FUNCTION的语法糖，正如“”是QUOTE的语法糖一样。"因此也可以像这样得到foo的函数对象。
所以你需要它被解释成一个变量。可以用任何接受单一数值实参的函数来调用plot，例如内置
FUNCALL用于在编写代码时确切知道传递给函数多少实参时。FUNCALL的第一个实参是被调
54
①思考FUNCTION的最佳方式是将其视为一个特殊类型的引用。QUOTE一个符号可以避免其被求值，从而得到该符
请注意，不需要使用FUNCTION或#来得到fn的函数值。因为它是作为函数对象的变量的值
②实际上还有第三个，特殊操作符MULTIPLB-VALUE-CALL，但是我将保留到第20章中当我讨论到返回多值的表
下面这个函数演示了FUNCALL的另一个更有建设性的用法。它接受一个函数对象作为实参
然而，当实参列表只在运行期已知时，FUNCALL的表现不佳。例如，为了再次调用plot函
  x.# ) 
CL-USER> #'foO
+***********
达式时再讨论它。
**************★****
***********
*★*
(loop for
第5章
formatt
door