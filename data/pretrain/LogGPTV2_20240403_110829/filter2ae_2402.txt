### 导语
FortiGuard研究人员对5月份发现的Emotet恶意软件样本进行了深入分析。本文将详细介绍该样本的解包过程、与C2服务器的通信机制，以及如何识别硬编码在可执行文件中的C2服务器列表和RSA密钥。

### 恶意Word文档
该样本是一个包含恶意宏的Word文档。当用户打开文档并启用宏时，恶意软件开始执行。具体来说，恶意宏会调用PowerShell脚本，如下图所示：

**图1. 执行PowerShell脚本**

从图中可以看出，恶意Word文档中的VB脚本通过PowerShell创建新进程。PowerShell的`-e`选项表示接收base64编码的字符串版本的命令。解码后的PowerShell脚本如图2所示：

**图2. 调试解码的PowerShell脚本**

变量`$YBAAU_D`是一个包含5个URL的列表，用于从远程服务器下载并执行payload。下表列出了每个恶意URL及其对应的payload名称、MD5值和大小：

| URL | Payload Name | MD5 | Size (KB) |
|-----|--------------|-----|-----------|
| URL1 | payload1.exe | md5_1 | 32.5 |
| URL2 | payload2.exe | md5_2 | 30.8 |
| URL3 | payload3.exe | md5_3 | 31.2 |
| URL4 | payload4.exe | md5_4 | 33.1 |
| URL5 | payload5.exe | md5_5 | 34.7 |

研究人员在分析5月初的样本时发现，前两个URL已无法访问，但剩下的三个URL仍然可用，且这些payload均为PE文件。接下来，我们将重点分析其中一个payload：`p4xl0bbb85.exe`（MD5: `a97cbbd774ca6e61cf9447d713f7cf5d`）。

### 第一层Payload
`p4xl0bbb85.exe`是经过定制打包器打包的。执行后，它会创建三个进程，如下图所示：

**图3. payload p4xl0bbb85.exe执行后的进程树**

首先，使用命令行`–f02b3a38`启动第一个进程（PID: 2784），然后将PE文件`itsportal.exe`写入路径`C:\Users\[XXX]\AppData\Local\itsportal\`。接着，执行`itsportal.exe`，再使用命令行`–c6857361`启动第二个进程（PID: 1980）。最后，退出前三个创建的进程，并从硬盘中删除`p4xl0bbb85.exe`。`itsportal.exe`即为持久化payload。

**图4. 持久化payload**

### 持久化Payload分析
`itsportal.exe`同样使用了定制打包器。研究人员追踪入口点的几个步骤，发现程序进入函数`sub_4012E0()`，如下图所示：

**图5. 函数`sub_4012E0()`**

以下是函数`sub_4012E0()`的C语言伪代码表示：

**图6. 函数sub_4012E0()的C语言伪代码表示**

在该函数中，恶意软件调用`sub_401440()`使用`VirtualAllocEx()`分配新的内存区域（大小为`0x1D0000`），并将内存起始地址加`0x102f0`作为跳板地址。随后，在循环中，复制`0xf080f8`的数据的`0x7B`字节到新的内存区域，继续复制数据直到字节达到`0x37`。最终，复制到内存区域的数据大小为`0x10600`。

接着，使用`sub_401560()`解密新内存区域中的数据，此时跳板代码被解密。程序跳转到跳板代码，最后跳转到`0x00401260`执行指令，如图7所示：

**图7. 跳转到0x00401260**

如图8所示，程序跳转到`0x1E02F0`执行跳板代码：

**图8. 跳转到跳板代码**

跳板代码的主要功能包括：
1. 分配一个新的内存区域（大小为`0x10000`，地址为`0x1F0000`），命名为region A。
2. 复制`0x1D0124`的数据的`0xf600`字节到region A。
3. 解密region A的数据，具体步骤如下：
   - 分配一个新的内存区域（大小为`0x14000`，地址为`0x200000`），命名为region B。
   - 复制region A的数据的前`0x400`字节到region B的起始位置。
   - 复制region A的所有数据段到region B。
   - 调用`UnmapViewofFile(0x400000)`解除其与文件的映射。
   - 调用`VirtualAlloc(0x400000, 0x14000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)`来分配并设置内存区域属性。
   - 复制region B的数据的`0x14000`字节到`0x400000`。
   - 从跳板代码的真实入口点`0x4CA90`跳转到执行指令。此时，解包工作完成。

下图显示了分配的内存区域和解包的程序：

**图9. 三个分配的内存区域和解包的程序**

最后，程序跳转到真实入口点`0x4C9A0`，如图10所示：

**图10. 跳转到真实入口点**

### 与C2服务器通信
为了调查与C2服务器的通信，研究人员首先获取了C2服务器列表。C2服务器列表硬编码在可执行文件中，解包后可以在偏移量`0x40F710`处找到，如图11所示：

**图11. 硬编码的C2服务器列表**

全局变量保存在`0x004124A0`处，结构如下：

```c
struct g_ip_port_list {
    DWORD *c2_list;
    DWORD *current_c2;
    DWORD size;
    DWORD current_c2_index;
};
```

成员变量`c2_list`指向硬编码的C2服务器列表缓存，列表中的每一项都包含IP地址和端口对。每个条目大小为8字节，前4个字节表示IP地址，后2个字节表示端口。`current_c2`指向当前选择的C2服务器，`size`表示C2服务器列表的大小，`current_c2_index`表示当前选定的C2服务器索引。

样本中共包含61个C2服务器，如下所示：

- 200.58.171.51:80
- 189.196.140.187:80
- 222.104.222.145:443
- 115.132.227.247:443
- 190.85.206.228:80
- 216.98.148.136:4143
- 111.67.12.221:8080
- 185.94.252.27:443
- 139.59.19.157:80
- 159.69.211.211:8080
- 107.159.94.183:8080
- 72.47.248.48:8080
- 24.150.44.53:80
- 176.58.93.123:8080
- 186.139.160.193:8080
- 217.199.175.216:8080
- 181.199.151.19:80
- 85.132.96.242:80
- 51.255.50.164:8080
- 103.213.212.42:443
- 192.155.90.90:7080
- 66.209.69.165:443
- 109.104.79.48:8080
- 181.142.29.90:80
- 77.82.85.35:8080
- 190.171.230.41:80
- 144.76.117.247:8080
- 187.188.166.192:80
- 201.203.99.129:8080
- 200.114.142.40:8080
- 43.229.62.186:8080
- 189.213.208.168:21
- 181.37.126.2:80
- 109.73.52.242:8080
- 181.29.101.13:80
- 190.180.52.146:20
- 82.226.163.9:80
- 200.28.131.215:443
- 213.172.88.13:80
- 185.86.148.222:8080
- 190.117.206.153:443
- 192.163.199.254:8080
- 103.201.150.209:80
- 181.30.126.66:80
- 200.107.105.16:465
- 165.227.213.173:8080
- 81.3.6.78:7080
- 5.9.128.163:8080
- 69.163.33.82:8080
- 196.6.112.70:443
- 37.59.1.74:8080
- 23.254.203.51:8080
- 190.147.116.32:21
- 200.45.57.96:143
- 91.205.215.57:7080
- 189.205.185.71:465
- 219.94.254.93:8080
- 186.71.54.77:20
- 175.107.200.27:443
- 66.228.45.129:8080
- 62.75.143.100:7080

接下来，我们分析发送给C2服务器的流量。样本中，发送给C2服务器的数据以`HTTP POST`请求的形式发送，如下图所示：

**图12. 抓取的发给C2服务器的流量**

HTTP会话数据如下图所示。HTTP body数据使用URL编码算法进行编码：

**图13. HTTP会话数据**

经过URL解码和base64解码后，可以看到实际数据是加密的。下一节将介绍HTTP body数据使用的解密算法。

**图14. 解码的HTTP body数据使用URL解码和base64解码**

### 加密算法
Emotet恶意软件可以收集诸如主机名、受感染机器上的进程列表等信息。收集的数据集如下图所示：

**图15. 收集的数据结构**

收集的数据使用Deflate算法进行压缩，如下图所示：

**图16. 用Deflate算法压缩数据**

恶意软件使用会话密钥对压缩后的数据进行加密，并将AES加密后的数据、哈希值和加密的会话密钥打包。会话密钥使用RSA公钥算法加密。打包后的数据结构如下图所示：

**图17. 打包后的数据结构**

使用RSA公钥加密的会话密钥大小为`0x60`字节，哈希值大小为`0x14`。这三部分数据打包后，恶意软件继续使用base64编码和URL编码算法对数据进行编码，最终组成要发送给C2服务器的HTTP body数据。

**图18. HTTP body数据**

从通信角度来看，程序需要处理来自C2服务器的响应数据，首先解密HTTP响应数据，然后使用Deflate算法解码对应的数据。RSA密钥硬编码在解包程序的偏移量`0x0040FBF0`处，大小为`0x6A`字节，如下图所示：

**图19. 硬编码的RSA密钥**

### 结论
Emotet是一款复杂的恶意软件，使用高级的定制打包器和复杂的加密算法与C2服务器进行通信，并具备其他高级功能。它可以从C2服务器提取攻击payload和其他相关恶意软件payload，其主要目的是从受害者处窃取敏感信息。

预告：下一篇关于Emotet的文章将介绍如何解包Emotet可执行文件并从中提取硬编码的C2服务器列表和RSA密钥。

本文翻译自：[原文链接]