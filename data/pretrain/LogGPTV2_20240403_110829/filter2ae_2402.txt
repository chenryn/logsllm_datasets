导语：​FortiGuard研究人员对5月份发现的Emotet恶意软件样本进行了分析。
* * *
FortiGuard研究人员就持续关注Emotet恶意软件的发展，本文对5月初发现的Emotet样本进行深度分析，具体包括解包persistent
payload、与C2服务器的通信、识别硬编码在可执行文件中的C2服务器列表和RSA密钥、以及如何加密收集的数据。
# 恶意word文档
该样本是一个word文档文件。打开word并启用宏后，恶意软件就会开始执行。
图1. 执行PowerShell脚本
可以看出恶意word文档中的VB脚本可以用PowerShell创建新进程。PowerShell的`-e`选项表明接收base64编码的字符串版本的命令。
解码的PowerShell脚本如图2所示：
图2. 调试解码的PowerShell脚本
变量`$YBAAU_D`是一个含有5个URL的列表，可以用来从远程服务器下载payload并执行。下表列出了每个恶意URL、以及从对应URL下载的payload名、md5值和payload大小。
研究人员分析5月初的样本时发现，前2个URL已经无法访问了，剩下3个URL仍然可以访问，这3个payload都是PE文件。
然后，研究人员对其中一个payload进行深入文件。本文的分析是基于payload`p4xl0bbb85.exe`(md5:
`a97cbbd774ca6e61cf9447d713f7cf5d`)的。
# 第一层payload
payload`p4xl0bbb85.exe`是用定制的packer打包的。执行后，会创建三个进程，如下图所示：
图3. payload p4xl0bbb85.exe执行后的进程树
首先用命令行`–f02b3a38`启动进程（`pid:2784`），然后将PE文件`itsportal.exe`写入文件夹`C:\Users\[XXX]\AppData\Local\itsportal`\中。然后，执行`itsportal.exe`。`itsportal.exe`执行后就可以用命令行`–c6857361`启动进程`pid:1980`。最后，退出前3个创建的进程，并将PE文件`p4xl0bbb85.exe`从硬盘中删除。PE文件`itsportal.exe`就是persistent
payload。
图4. persistent payload
# Persistent Payload分析
Payload itsportal.exe有一个定制的packer。研究人员追踪了入口点的几个步骤，发现程序进入了函数`sub_4012E0()`。
图5. 函数`sub_4012E0()`
下面是函数`sub_4012E0()`的C语言伪代码表示：
图6. 函数sub_4012E0()的C语言伪代码表示
在该函数中，恶意软件会调用函数`sub_401440()`来用`VirtualAllocEx()`分配新的内存区域(`0x1D0000`)，设置内存的开始地址加`0x102f0`作为trampoline
address。
然后，在循环中，首先复制`0xf080f8`的数据的`0x7B`字节到新的内存区域，然后继续复制数据。当字节达到`0x37`时，就不会在复制到新的内存区域。复制到内存区域的数据大小为`0x10600`。
然后，用函数`sub_401560()`来解密新的内存区域中的数据，此时trampoline代码就被解密了。然后，就看到程序会跳转到trampoline
code。最后，程序跳转到`0x00401260`来执行指令。
图7. 跳转到0x00401260
如图8所示，程序会跳转到`0x1E02F0`来执行 trampoline代码。
图8. 跳转到trampoline code
trampoline code的主要作用是：
  1. 分配大小为0x10000的心的内存区域（0x1F0000），并命名为region A；
  2. 复制0x1D0124的数据的0xf600字节到region A；
  3. 解密内存region A的数据，解密算法如下：
  1. 分配大小为0x14000的新的内存区域(0x200000)，并命名为region B；
  2. 复制region A的数据的前0x400字节到内存region B的开始；
  3. 复制region A的所有数据段到内存region B；
  4. 通过调用进程的地址空间来调用函数UnmapViewofFile(0x400000)来解除其与文件的映射；
  5. 调用函数VirtualAlloc(0x400000,0x14000,MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)来执行、读写内存区域；
  6. 复制内存区域region B数据的0x14000字节到0x400000；
  7. 从trampoline代码的真实入口点(0x4CA90)跳转到执行指令。此时，解包工作就完成了。
下图是内存图，其中标明了分配的内存区域和解包的程序。
图9. 3个分配的内存区域和解包的程序
最后，程序会跳转到真实的入口点0x4C9A0。
图10. 跳转到真实的入口点
这就是如何解包Emotet恶意软件。在解包的程序中，C2服务器列表硬编码在offset`0x40F710`处，公钥硬编码在offset
`0x40FBF0`处。
# 与C2服务器通信
为了调查与C2服务器的通信，研究人员首先获取C2服务器列表。C2服务器是硬编码在可执行文件中的，解包后，研究人员看到了offset`0x40F710`处保存的C2服务器列表，如图11所示。
图11. 硬编码的C2服务器列表
全局变量保存在`0x004124A0`处，结构如下所示：
    struct g_ip_port_list
    {
                      DWORD *c2_list;
                      DWORD *current_c2;
                      DWORD size;
                      DWORD current_c2_index;
    }
成员变量`c2_list`指向硬编码的C2服务器列表缓存，列表中的每一项都包含IP地址和端口对。大小为8字节，前4个字节表示IP地址，之后的2个字节表示端口。成员变量`current_c2`指向当前选择的C2服务器。成员变量size表示C2服务器列表的大小，成员变量`current_c2_index`表示C2服务器列表中当前选定的C2服务器的索引。
样本中共含有61个C2服务器，分别是：
    · 200.58.171.51:80
    · 189.196.140.187:80
    · 222.104.222.145:443
    · 115.132.227.247:443
    · 190.85.206.228:80
    · 216.98.148.136:4143
    · 111.67.12.221:8080
    · 185.94.252.27:443
    · 139.59.19.157:80
    · 159.69.211.211:8080
    · 107.159.94.183:8080
    · 72.47.248.48:8080
    · 24.150.44.53:80
    · 176.58.93.123:8080
    · 186.139.160.193:8080
    · 217.199.175.216:8080
    · 181.199.151.19:80
    · 85.132.96.242:80
    · 51.255.50.164:8080
    · 103.213.212.42:443
    · 192.155.90.90:7080
    · 66.209.69.165:443
    · 109.104.79.48:8080
    · 181.142.29.90:80
    · 77.82.85.35:8080
    · 190.171.230.41:80
    · 144.76.117.247:8080
    · 187.188.166.192:80
    · 201.203.99.129:8080
    · 200.114.142.40:8080
    · 43.229.62.186:8080
    · 189.213.208.168:21
    · 181.37.126.2:80
    · 109.73.52.242:8080
    · 181.29.101.13:80
    · 190.180.52.146:20
    · 82.226.163.9:80
    · 200.28.131.215:443
    · 213.172.88.13:80
    · 185.86.148.222:8080
    · 190.117.206.153:443
    · 192.163.199.254:8080
    · 103.201.150.209:80
    · 181.30.126.66:80
    · 200.107.105.16:465
    · 165.227.213.173:8080
    · 81.3.6.78:7080
    · 5.9.128.163:8080
    · 69.163.33.82:8080
    · 196.6.112.70:443
    · 37.59.1.74:8080
    · 23.254.203.51:8080
    · 190.147.116.32:21
    · 200.45.57.96:143
    · 91.205.215.57:7080
    · 189.205.185.71:465
    · 219.94.254.93:8080
    · 186.71.54.77:20
    · 175.107.200.27:443
    · 66.228.45.129:8080
    · 62.75.143.100:7080
然后，分析发送到C2服务器的流量。在样本中，发送给C2服务器的数据是以`HTTP POST`请求的方式发送的。
图12. 抓取的发给C2服务器的流量
HTTP session如下图所示。HTTP body数据是用URL编码算法编码的：
图13. HTTP session数据
在执行URL解码后，可以看出数据是用base64编码的。经过base64解码后，可以看到真实的数据是经过加密的。下一部分介绍HTTP
body数据使用的解密算法。
图14. 解码的HTTP body数据使用URL解码和base64解码
# 加密算法
Emotet恶意软件可以收集诸如`host name`、运行在受感染的机器上的进程列表等信息。下面是收集的数据集：
图15. 收集的数据的结构
然后，将收集的数据用Deflate算法压缩：
图16. 用Deflate算法压缩数据
然后，恶意软件会用session key将图16中的压缩数据进行加密，并用AES和session key、哈希值和加密的数据打包，session
key是用RSA公钥算法加密的。
图17. 打包后的数据结构
用RSA公钥加密的Session key大小为`0x60`字节，哈希值的大小为`0x14`。
将这3部分数据打包后，恶意软件会继续用base64来编码打包的数据，然后用URL编码算法进行编码。最后就组成了要发送给C2服务器的http body数据。
图18. HTTP body data
从通信的角度来看，程序必须要处理来自C2服务器的响应数据，首先解密HTTP响应数据，然后用Deflate算法解码对应的数据。
RSA密钥硬编码在解包的程序的offset`0x0040FBF0`处，大小为`0x6A`字节。
图19. 硬编码的RSA密钥
# 结论
Emotet是一款复杂的恶意软件，其中使用了高级的定制packer和复杂的加密算法来与C2服务器进行通信，并含有其他高级功能。它会从C2服务器提取出攻击payload和其他相关的恶意软件payload。这些攻击payload的目的都是从受害者处窃取敏感信息。
预告：下一篇关于Emotet的文章将介绍如何解包Emotet可执行文件并从可执行文件中提取出硬编码的C2服务器列表和RSA密钥。
本文翻译自：