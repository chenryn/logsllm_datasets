## 课堂练习通过这一节的学习，你会发现，一个进程的运行竟然要保存这么多信息，这些信息都可以通过命令行取出来，所以今天的练习题就是，对于一个正在运行的进程，通过命令行找到上述进程运行的所有信息。欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。![](Images/1a5564dd4e1c9f25d4772c7f844ca84a.png){savepage-src="https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg"}
# 14 \| 进程数据结构（下）：项目多了就需要项目管理系统上两节，我们解读了 task_struct的大部分的成员变量。这样一个任务执行的方方面面，都可以很好地管理起来，但是其中有一个问题我们没有谈。在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。那如何将用户态的执行和内核态的执行串起来呢？这就需要以下两个重要的成员变量：    struct thread_infothread_info;void  *stack;
## 用户态函数栈在用户态中，程序的执行往往是一个函数调用另一个函数。函数调用都是通过栈来进行的。我们前面大致讲过函数栈的原理，今天我们仔细分析一下。函数调用其实也很简单。如果你去看汇编语言的代码，其实就是指令跳转，从代码的一个地方跳到另外一个地方。这里比较棘手的问题是，参数和返回地址应该怎么传递过去呢？我们看函数的调用过程，A 调用 B、调用 C、调用 D，然后返回 C、返回 B、返回A，这是一个后进先出的过程。有没有觉得这个过程很熟悉？没错，咱们数据结构里学的栈，也是后进先出的，所以用栈保存这些最合适。在进程的内存空间里面，栈是一个从高地址到低地址，往下增长的结构，也就是上面是栈底，下面是栈顶，入栈和出栈的操作都是从下面的栈顶开始的。![](Images/af4a354a1a19aa9a82086a964a5d4daf.png){savepage-src="https://static001.geekbang.org/resource/image/ae/2e/aec865abccf0308155f4138cc905972e.jpg"}我们先来看 32 位操作系统的情况。在 CPU 里，**ESP**（Extended StackPointer）是栈顶指针寄存器，入栈操作 Push 和出栈操作 Pop 指令，会自动调整ESP 的值。另外有一个寄存器**EBP**（Extended BasePointer），是栈基地址指针寄存器，指向当前栈帧的最底部。``{=html}例如，A 调用 B，A 的栈里面包含 A 函数的局部变量，然后是调用 B的时候要传给它的参数，然后返回 A 的地址，这个地址也应该入栈，这就形成了A 的栈帧。接下来就是 B 的栈帧部分了，先保存的是 A 栈帧的栈底位置，也就是EBP。因为在 B 函数里面获取 A传进来的参数，就是通过这个指针获取的，接下来保存的是 B 的局部变量等等。当 B 返回的时候，返回值会保存在 EAX寄存器中，从栈中弹出返回地址，将指令跳转回去，参数也从栈中弹出，然后继续执行A。对于 64 位操作系统，模式多少有些不一样。因为 64位操作系统的寄存器数目比较多。rax用于保存函数调用的返回结果。栈顶指针寄存器变成了rsp，指向栈顶位置。堆栈的 Pop 和 Push 操作会自动调整rsp，栈基指针寄存器变成了 rbp，指向当前栈帧的起始位置。改变比较多的是参数传递。rdi、rsi、rdx、rcx、r8、r9 这 6个寄存器，用于传递存储函数调用时的 6 个参数。如果超过 6的时候，还是需要放到栈里面。然而，前 6个参数有时候需要进行寻址，但是如果在寄存器里面，是没有地址的，因而还是会放到栈里面，只不过放到栈里面的操作是被调用函数做的。![](Images/e84270e73f1b6de534691b7ad3d7c5b0.png){savepage-src="https://static001.geekbang.org/resource/image/77/c0/770b0036a8b2695463cd95869f5adec0.jpg"}以上的栈操作，都是在进程的内存空间里面进行的。
## 内核态函数栈接下来，我们通过系统调用，从进程的内存空间到内核中了。内核中也有各种各样的函数调用来调用去的，也需要这样一个机制，这该怎么办呢？这时候，上面的成员变量 stack，也就是内核栈，就派上了用场。Linux 给每个 task 都分配了内核栈。在 32 位系统上arch/x86/include/asm/page_32_types.h，是这样定义的：一个 PAGE_SIZE 是4K，左移一位就是乘以 2，也就是 8K。    #define THREAD_SIZE_ORDER1#define THREAD_SIZE(PAGE_SIZE stack;}从 task_struct 如何得到相应的 pt_regs 呢？我们可以通过下面的函数：    /* * TOP_OF_KERNEL_STACK_PADDING reserves 8 bytes on top of the ring0 stack. * This is necessary to guarantee that the entire "struct pt_regs" * is accessible even if the CPU haven't stored the SS/ESP registers * on the stack (interrupt gate does not save these registers * when switching to the same priv ring). * Therefore beware: accessing the ss/esp fields of the * "struct pt_regs" is possible, but they may contain the * completely wrong values. */#define task_pt_regs(task) \({\unsigned long __ptr = (unsigned long)task_stack_page(task);\__ptr += THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING;\((struct pt_regs *)__ptr) - 1;\})你会发现，这是先从 task_struct 找到内核栈的开始位置。然后这个位置加上THREAD_SIZE 就到了最后的位置，然后转换为 structpt_regs，再减一，就相当于减少了一个 pt_regs的位置，就到了这个结构的首地址。这里面有一个 TOP_OF_KERNEL_STACK_PADDING，这个的定义如下：    #ifdef CONFIG_X86_32
# ifdef CONFIG_VM86