• What if the preferences file is too large ?
• Open the file and return file descriptor
• What if the preferences file changes ?
• Clone file and open
• Return the file descriptor
clonefile
file 
check
open
preferences
file
Implementation of Preferences File Read
char __str[1032];
plist_path = [CFPDSource cacheActualPath];
if (!lstat(plist_path, &stat_buf) && stat_buf.st_size >= 0x100000){
snprintf(__str, 0x400uLL, "%s.cfp.XXXXXXX", plist_path);
tmp_plist_path = mktemp(__str);
if (tmp_plist_path) {
if (!clonefile(plist_path, tmp_plist_path, 0) ){
v4 = open(tmp_plist_path, 0);
...
}
}
}
[CFPDSource cloneAndOpenPropertyListWithoutDrainingPendingChangesOrValidatingPlist]
1. get preferences file path
2. judge the file size
3. clone preferences file
Implementation of File Clone
clonefile(plist_path, tmp_path)
snprintf(__str, 0x400uLL, "%s.cfp.XXXXXXX", plist_path);
dst_path = mktemp(__str);
Random file name at same directory of preferences file
Implementation of File Clone
clonefile(plist_path, tmp_path)
snprintf(__str, 0x400uLL, "%s.cfp.XXXXXXX", plist_path);
dst_path = mktemp(__str);
Random file name?
Really Random File Name? 
• snprintf
• Generate formatted string with its MAX length as 0x400
• mktemp
• “The trailing `X’s are replaced with a unique alphanumeric combination”
• What if strlen(plist_path) + strlen(”.cfp”) is equal 
to 0x400-1?
• snprintf will overflows and generate ”_str” without ”X”
• mktemp will returns a fixed filename without any randomness
snprintf(__str, 0x400uLL, "%s.cfp.XXXXXXX", plist_path);
dst_path = mktemp(__str);
Time of Check
clonefile
file 
check
open
controllable 
plist file
file_check(plist_path)
Time of check
Time of use
Arbitrary File Read
clonefile(plist_path, dst_path)
{plist_path}.cfp
Fixed file name
Arbitrary File Read: any file can be stolen and cloned to {plist_path}.cfp
symbolic link?
clonefile
file 
check
open
controllable 
plist file
Time of check
Time of use
Make Temporary File Name
clonefile
file 
check
open
controllable 
plist file
mktemp(“{plist_path}.cfp”)
Time of check
Time of use
mktemp
mktemp will fail if expected file exists
Arbitrary File Write
clonefile(plist_path, dst_path)
{plist_path}.cfp
Fixed file name
Arbitrary File Write: plist_path can be write to ANY path
symbolic link
clonefile
file 
check
open
controllable 
plist file
Time of check
mktemp
Time of use
Patch of CVE-2021-1740
• Replace temp path with symbolic link? No more fixed file
• Predicted/fixed temp path need to overflow snprintf
• Random temp file will not be created unless clonefileat is called 
successfully, so we have no time window to replace it
int ret = snprintf(__str, 0x400uLL, "%s.cfp.XXXXXXX", plist_path);
if (ret >= 0x400){
goto FAIL;
}
char *temp_path = mktemp(__str);
if (!clonefileat(dirfd, plist_file, AT_FDCWD, temp_path)){
int fd = open(temp_path, 0);
// ...
return fd;
}
How does cfprefsd Write 
Preferences Data?
Preferences Write Logic
Parse key, value from XPC message
Read data from target preferences file
Generate new data
Write data to a temp file
Rename temp file back to the target preferences file
Client have Write Permission to Preferences 
File?
bool -[CFPDSource validateAccessToken:accessType:]{
char fd_path[1024];
xpc_fd = xpc_dictionary_dup_fd(xpc_msg, "CFPreferencesAccessToken");
if (fcntl(xpc_fd, F_GETPATH, fd_path) != -1){
// check if path is consistent, plist_path is controllable by client
if (!strcmp(fd_path, plist_path) &&
// check if the file is writable by client
((fcntl(xpc_fd, F_GETFL, 0LL) & 3) == 2)){
return true; // check success
}
}
return false; // check failed
}
The client needs to pass the file descriptor to cfprefsd to prove that it has write 
permission to preferences file
Implementation of Preferences File Write
int64 _CFPrefsWritePlistToFDThenClose(){
tmp_file_fd = _CFPrefsTemporaryFDToWriteTo(v3, v4);
fcntl(tmp_file_fd, F_GETPATH, tmp_file_path);
while (...) {
write(tmp_file_fd, plist_data, plist_size);
}
close(tmp_file_fd);
rename(tmp_file_path, plist_path);
}
1. generate temp file
2. write preferences data to temp file
3. rename temp file to target plist file
Source Path is Symbolic Link?
rename(tmp_file_path, plist_path)
Created in temp directory
Fully controllable by client
No, created in root-ownered directory, client has 
no access to it
Symbolic link?
Target Path is Symbolic Link?
rename(tmp_file_path, plist_path)
Created in temp directory
Fully controllable by client
rename will firstly delete the symbolic link if it 
exists already
Symbolic link?
“If the final component of target is a symbolic link, the symbolic link is renamed, not the file or directory to 
which it points.”
Target Path is Symbolic Link?
rename(tmp_file_path, plist_path)
Created in temp directory
Fully controllable by client
rename will firstly delete the symbolic link if it 
exists already
Symbolic link?
“If the final component of target is a symbolic link, the symbolic link is renamed, not the file or directory to 
which it points.”
What if Middle Component of plist_path
is a Symbolic Link? 
/tmp/test/hello.plist
final component
middle component
➜
ln -s /Library/LaunchDaemons /tmp/test
➜
ls –l /tmp/
lrwxr-xr-x  1 xuanwulab
wheel   22  6 29 18:07 test -> /Library/LaunchDaemons
rename(tmp_file_path, plist_path)
Time of Check
rename
file 
check
open
controllable 
plist file
file_check(plist_path)
Time of check
Time of use
Arbitrary File Rename
rename
file 
check
open
controllable 
plist file
Time of check
Time of use
rename(tmp_path, plist_path)
Arbitrary File Write:  controllable content can be written to any path
replace middle component of it 
with symbolic link?
Patch of CVE-2021-1739
• rename -> renameat
• The target file of renameat will be created based on dir_fd
• Symbolic link (middle component of the target path) will not be followed
int renameat(
AT_FDCWD,   tmp_file_path, 
dir_fd,     file_name
)
/tmp/test/xlab.plist
xlab.plist
dir_fd = open(”/tmp/test”, 0)
Demo of Preferences Vulnerabilities
https://www.youtube.com/watch?v=Kh6sEcdGruU
https://support.apple.com/en-us/HT212011
NSXPC Server
• com.apple.storedownloadd.daemon
• /System/Library/PrivateFrameworks/CommerceKit.f
ramework/Versions/A/Resources/storedownloadd
• Root privilege, but sandboxed
• Sandbox Profile 
/System/Library/Sandbox/Profiles/com.apple.storedown
loadd.sb
• It is allowed to write many sensitive paths such as /Applications, 
/Library/Keychains/
[NSXPCListener initWithMachServiceName: @"com.apple.storedownloadd.daemon”];
storedownloadd’s Interfaces
@protocol ISDownloadService 
- (void)setStoreClient:(ISStoreClient*)storeClient;
- (void)performDownload:(SSDownload*)download 
withOptions:(NSUInteger)options 
replyBlock:(void (^)(NSUInteger, NSError*))reply;
@end
What to download ? What is SSDownload ?
SSDownload
@interface SSDownload : NSObject
@property(copy, nonatomic) NSArray *_assets;
@end
@implementation SSDownload
+ (BOOL)supportsSecureCoding{
return YES;
}
- (void)encodeWithCoder:(nonnull NSCoder *)coder {
[coder encodeObject:self._assets forKey:@"_assets"];
}
- (nullable instancetype)initWithCoder:(nonnull NSCoder *)coder {
return self;
}
@end
SSDownloadAsset
@interface SSDownloadAsset : NSObject
@property NSString * _customDownloadPath;
@property NSURL * _urlRequest;
@property NSArray * _hashes;
@end
@implementation SSDownloadAsset
+ (BOOL)supportsSecureCoding{
return YES;
}
- (void)encodeWithCoder:(nonnull NSCoder *)coder {
[coder encodeObject:self._customDownloadPath forKey:@"download-path"];
[coder encodeObject:self._urlRequest forKey:@"url"];
[coder encodeObject:self._hashes forKey:@"hashes"];
}
- (nullable instancetype)initWithCoder:(nonnull NSCoder *)coder {
return self;
}
@end
Serialization and Unserialization
SSDownloadAsset {
NSString * _customDownloadPath;
NSURL * _urlRequest;
NSArray * _hashes;
}// fully controllable by attacker
[SSDownloadAsset encodeWithCoder:]
[SSDownloadAsset initWithCoder:]
SSDownloadAsset {
NSString * _customDownloadPath;
NSURL * _urlRequest;
NSArray * _hashes;
} // fully controllable by attacker
XPC Message
48656c6c6f2c205875616e77754c6162...
XPC Message
48656c6c6f2c205875616e77754c6162...
Serialize
Unserialize
Attacker Process
storedownloadd Process
Download Logic
Perform the file 
download on url
Verify the 
response contents 
based on hashes
Write file to 
download-path
Hash Verification
• Calculate hash of response contents
• Compare with input hash
-[HashedDownloadProvider 
_verifyStreamedBytesWithHashes:]
It’s just a data integrity check !!!
Exploit of CVE-2020-27903
“Hi storedownloadd, please help me to download a 
file from this URL path, its hash is balabala ... and then 
write the contents to this download path, thanks!”
Patch of CVE-2020-27903 
• Removing the vulnerable code
• No com.apple.storedownloadd.daemon any more.
• RIP
Demo of CVE-2020-27903 
Other Logic Vulnerabilities
• XPC Service implementation flaw
• https://xlab.tencent.com/en/2021/01/11/cve-2020-9971-abusing-xpc-
service-to-elevate-privilege/
• NSXPC Vulnerabilities in Adobe Acrobat Reader
• https://rekken.github.io/2020/05/14/Security-Flaws-in-Adobe-Acrobat-
Reader-Allow-Malicious-Program-to-Gain-Root-on-macOS-Silently/
https://i.kym-cdn.com/photos/images/newsfeed/001/890/751/e0e.png
Advantage of IPC Logic Vulnerability
• Easy to exploit
• Stable 
• One exploit to rule them all
“Logic bugs in core framework like prefrences let us rule all Apple platforms, Intel and 
Apple Silicon alike, without changing one line of our exploit.”
State of Apple IPC Security
• Reduce the IPC attack surfaces
• More restricted sandbox rules
• Delete unnecessary high privilege services
• Adding more and more private entitlements
• com.apple.private.xxx
• …
• Limit the damage
• Sandbox IPC Server
• Rootless
• …
Conclusion
Latest IPC Mechanisms on Apple Platforms
• XPC, NSXPC
Interesting Apple IPC Logic Vulnerabilities
• Three logic vulnerabilities in Preferences
• One logic vulnerability in App Store
Advantage of IPC Logic Vulnerability
Status of Apple IPC Logic Vulnerability
“Logic bugs are always fun!”
Special Thanks
• Csaba Fitzl (@theevilbit)
• Ian Beer (@i41nbeer)
• Zhi Zhou (@CodeColorist)
Thanks.
Tencent Security Xuanwu Lab
@XuanwuLab
xlab.tencent.com