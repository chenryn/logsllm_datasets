quotactl syscall (C)
SUS (C)
Buffer (stack) overﬂow
Buffer (BSS) overﬂow
User/kernel pointer dereference
Format string bug
WU-FTPD (C)
Format string bug
Analysis
String tainting
+ System call interposition
String tainting
+ System call interposition
String tainting
+ System call interposition
String tainting
+ System call interposition
Pointer injection
Pointer injection
Pointer injection
String tainting
+ Function call interposition
String tainting
+ Function call interposition
Detected Vulnerability
Open ﬁle with tainted absolute path
Open ﬁle with tainted absolute path
Tainted HTML output includes 
Tainted HTML output includes 
Tainted code pointer dereference (return address)
Tainted data pointer dereference (application data)
Tainted pointer to kernelspace
Tainted format string speciﬁer in syslog
¯
Tainted format string speciﬁer in vfprintf
Table 3: The security experiments performed with the DIFT coprocessor.
)
%
(

d
a
e
h
r
e
v
O
O
e
m

i
t
n
u
R
1.00%
0.80%
0.60%
0.40%
0.20%
0.00%
Figure 3: Execution time normalized to an unmodiﬁed Leon.
)
%
(

d
a
e
h
r
e
v
O
O
e
m

i
t
n
u
R
QueuefillStalls
MemorycontentionStalls
12%
10%
8%
6%
4%
2%
0%
0
2
4
6
SizeoftheQueue(no.ofentries)
Figure 4: The effect of scaling the size of the decoupling queue on a worst-
case tag initialization microbenchmark.
We performed an indirect comparison between the copro-
cessor and multi-core approaches for DIFT, by evaluating the
impact of communicating traces between application and anal-
ysis cores, on application performance. To minimize con-
tention, the multi-core architecture [3] uses a 32-Kbyte table
for value prediction, that compresses 16 bytes of data per ex-
ecuted instruction, to a 0.8 byte trace. We found the overhead
of exchanging these compressed traces between cores in bulk
64-byte transfers to be 5%. The actual multi-core system may
have additional overheads due to the synchronization of the
application and analysis cores.
Since we synchronize the processor and the coprocessor
at system calls, and the coprocessor has good locality with
a small tag cache, we did not observe a signiﬁcant num-
1.2
1.15
1.1
1 1
1.05
1
gzip
gcc
twolf
twolf
d
a
e
h
r
r
e
v
O
e
e
v
i
t
a
e
e
l

0.95R
0.9
0.9
1
1.5
2
Ratioofmaincore'sclocktocoprocessor'sclock
Figure 5: Performance overhead when the coprocessor is paired with higher-
IPC main cores. Overheads are relative to the case when the main core and
coprocessor have the same clock frequency.
ber of memory contention or queue related stalls for the
SPECint2000 benchmarks. We evaluated the worst-case sce-
nario for the tag cache, by performing a series of continuous
memory operations designed to miss in the tag cache, without
any intervening operations. This was aimed at increasing con-
tention for the shared memory bus, causing the main processor
to stall. We found that tag cache misses were rare with a cache
of 512 bytes or more, and the overhead dropped to 2% even
for this worst-case scenario. We also wrote a microbench-
mark to stress test the performance of the decoupling queue.
This worst-case scenario microbenchmark performed continu-
ous operations that set and retrieved memory tags, to simulate
tag initialization. Since the coprocessor instructions that ma-
nipulate memory tags are treated as nops by the main core,
they impact the performance of only the coprocessor, causing
the queue to stall. Figure 4 shows the performance overhead
of our coprocessor prototype as we run this microbenchmark
and vary the size of the decoupling queue from 0 to 6 entries.
For these runs we use a 16-byte tag cache in order to increase
the number of tag misses and put pressure on the decoupling
queue. Without decoupling, the coprocessor introduces a 10%
performance overhead. A 6-entry queue is sufﬁcient to drop
the performance overhead to 3%. Note that the overhead of
a 0-entry queue is equivalent to the overhead of a DIVA-like
design which performs DIFT computations within the core, in
additional pipeline stages prior to instruction commit.
5.2.2 Processor/Coprocessor Performance Ratio
7 Acknowledgments
The decoupling queue and the coarse-grained synchronization
scheme allow the coprocessor to fall temporarily behind the
main core. The coprocessor should however, be able to match
the long-term IPC of the main core. While we use a single-
issue core and coprocessor in our prototype, it is reasonable
to expect that a signiﬁcantly more capable main core will also
require the design of a wider-issue coprocessor. Nevertheless,
it is instructive to explore the right ratio of performance capa-
bilities of the two. While the main core may be dual or quad
issue, it is unlikely to frequently achieve its peak IPC due to
mispredicted instructions, and pipeline dependencies. On the
other hand, the coprocessor is mainly limited by the rate at
which it receives instructions from the main core. The nature
of its simple operations allows it to operate at high clock fre-
quencies without requiring a deeper pipeline that would suffer
from data dependency stalls. Moreover, the coprocessor only
handles committed instructions. Hence, we may be able to
serve a main core with peak IPC higher than 1 with the simple
coprocessor pipeline presented.
To explore this further, we constructed an experiment
where we clocked the coprocessor at a lower frequency than
the main core. Hence, we can evaluate coupling the coproces-
sor with a main core that has a peak instruction processing rate
1.5x, or 2x that of the coprocessor. As Figure 5 shows, the co-
processor introduces a modest performance overhead of 3.8%
at the 1.5x ratio and 11.7% at the 2x ratio, with a 16-entry de-
coupling queue. These overheads are likely to be even lower
on memory or I/O bound applications. This indicates that the
same DIFT coprocessor design can be (re)used with a wide va-
riety of main cores, even if their peak IPC characteristics vary
signiﬁcantly.
6 Conclusions
We presented an architecture that provides hardware sup-
port for dynamic information ﬂow tracking using an off-core,
decoupled coprocessor. The coprocessor encapsulates all state
and functionality needed for DIFT operations and synchro-
nizes with the main core only on system calls. This design
approach drastically reduces the cost of implementing DIFT:
it requires no changes to the design, pipeline and layout of
a general-purpose core, it simpliﬁes design and veriﬁcation,
it enables use with in-order cores, and it avoids taking over
an entire general-purpose CPU for DIFT checks. Moreover,
it provides the same guarantees as traditional hardware DIFT
implementations. Using a full-system prototype, we showed
that the coprocessor introduces a 7% resource overhead over
a simple RISC core. The performance overhead of the copro-
cessor is less than 1% even with a 512-byte cache for DIFT
tags. We also demonstrated in practice that the coprocessor
can protect unmodiﬁed software binaries from a wide range of
security attacks.
We would like to thank Jiri Gaisler, Richard Pender, and
Gaisler Research in general for their invaluable assistance with
the prototype development. We would also like to thank Shih-
Lien Lu and the anonymous reviewers for their feedback on
the paper. This work was supported by an Intel Foundation
Graduate Fellowship, a Stanford Graduate Fellowship funded
by Sequoia Capital, and NSF awards CCF-0701607 and CCF-
0546060.
References
[1] AMD. AMD Lightweight Proﬁling Proposal, 2007.
[2] T. Austin. DIVA: A Reliable Substrate for Deep Submicron Microarchitecture
Design. In the Proc. of the 32nd MICRO, Haifa, Israel, Nov. 1999.
[3] S. Chen, B. Falsaﬁ, et al. Logs and Lifeguards: Accelerating Dynamic Program
Monitoring. Technical Report IRP-TR-06-05, Intel Research, Pittsburgh, PA, 2006.
[4] S. Chen, M. Kozuch, et al. Flexible Hardware Acceleration for Instruction-Grain
Program Monitoring. In the Proc. of the 35th ISCA, Beijing, China, June 2008.
[5] S. Chen, J. Xu, et al. Defeating Memory Corruption Attacks via Pointer Tainted-
ness Detection. In the Proc. of the 35th DSN, Yokohama, Japan, June 2005.
[6] J. Chung, M. Dalton, et al. Thread-Safe Dynamic Binary Translation using Trans-
actional Memory. In the Proc. of the 14th HPCA, Salt Lake City, UT, Feb. 2008.
[7] J. R. Crandall and F. T. Chong. MINOS: Control Data Attack Prevention Orthogo-
nal to Memory Model. In the Proc. of the 37th MICRO, Portland, OR, Dec. 2004.
[8] M. Dalton, H. Kannan, and C. Kozyrakis. Raksha: A Flexible Information Flow
Architecture for Software Security. In the Proc. of the 34th ISCA, San Diego, CA,
June 2007.
[9] M. Dalton, H. Kannan, and C. Kozyrakis. Real-World Buffer Overﬂow Protection
for Userspace and Kernelspace. In the Proc. of the 17th Usenix Security Sympo-
sium, San Jose, CA, July 2008.
[10] D. E. Denning and P. J. Denning. Certiﬁcation of programs for secure information
ﬂow. ACM Communications, 20(7), 1977.
[11] T. Garﬁnkel, B. Pfaff, and M. Rosenblum. Ostia: A Delegating Architecture for
Secure System Call Interposition. In the Proc. of the 11th NDSS, San Diego, CA,
Feb. 2004.
Intel Virtualization Technology (Intel VTx).
technology/virtualization.
http://www.intel.com/
[13] T. Jim, M. Rajagopalan, et al. System call monitoring using authenticated system
[12]
calls. IEEE Trans. on Dependable and Secure Computing, 3(3):216–229, 2006.
[14] LEON3 SPARC Processor. http://www.gaisler.com.
[15] A. Mahmood and E. J. McCluskey. Concurrent error detection using watchdog
processors – a survey. IEEE Trans. on Computers, 37(2), 1988.
[16] V. Nagarajan, H.Kim, et al. Dynamic Information Tracking on Multcores. In the
Proc. of the 12th INTERACT, Salt Lake City, UT, Feb. 2008.
[17] N. Nakka, Z. Kalbarczyk, et al. An Architectural Framework for Providing Relia-
bility and Security Support. In the Proc. of the 34th DSN, Florence, Italy, 2004.
[18] J. Newsome and D. X. Song. Dynamic Taint Analysis for Automatic Detection,
Analysis, and Signature Generation of Exploits on Commodity Software. In the
Proc. of the 12th NDSS, San Diego, CA, Feb. 2005.
[19] Perl taint mode. http://www.perl.com.
[20] F. Qin, C. Wang, et al. LIFT: A Low-Overhead Practical Information Flow Track-
ing System for Detecting Security Attacks. In the Proc. of the 39th MICRO, Or-
lando, FL, Dec. 2006.
[21] M. Rajagopalan, M. Hiltunen, et al. Authenticated System Calls. In the Proc. of
the 35th DSN, Yokohama, Japan, June 2005.
[22] W. Shi, J. Fryman, et al. InfoShield: A Security Architecture for Protecting Infor-
mation Usage in Memory. In the Proc. of the 12th HPCA, Austin, TX, 2006.
[23] Personal communication with Shih-Lien Lu, Senior Prinicipal Researcher, Intel
Microprocessor Technology Labs, Hillsboro, OR.
[24] G. E. Suh, J. W. Lee, et al. Secure Program Execution via Dynamic Information
Flow Tracking. In the Proc. of the 11th ASPLOS, Boston, MA, Oct. 2004.
[25] N. Vachharajani, M. J. Bridges, et al. RIFLE: An Architectural Framework for
User-Centric Information-Flow Security. In the Proc. of the 37th MICRO, Portland,
OR, Dec. 2004.
[26] G. Venkataramani, I. Doudalis, et al. FlexiTaint: A Programmable Accelerator for
Dynamic Taint Propagation. In the Proc. of the 14th HPCA, Salt Lake City, UT,
Feb. 2008.
[27] W. Xu, S. Bhatkar, and R. Sekar. Taint-enhanced policy enforcement: A practi-
cal approach to defeat a wide range of attacks. In the Proc. of the 15th USENIX
Security Symp., Vancouver, Canada, Aug. 2006.