948
2400
996
3200
15800
3900
667
13000
2300
6800
75000
constructed, and compared the program semantics to confirm the
correctness of the patch generated by Rupair.
Finally, we evaluated whether the rectified programs by Rupair
can defend against real-world attacks. To replay such attacks, we
collected historical attack data for existing CVEs [5], and replayed
them on the rectified Rust programs. Consequently, the experi-
ment results showed that all the rectified programs defeat these
attacks. This demonstrated that the Rupair can protect Rust pro-
grams against real-world attacks.
The above experiments demonstrate that Rupair is effective in
identifying and rectifying buffer overflow bugs.
4.4 RQ2: Scalability
To answer RQ2, we applied Rupair to the benchmarks in our
data set in Table 2, with 36 real-world Rust projects and a total
of 5,108,432 lines of Rust code.
In Table 3, we present the projects for which RUPAIR reported
buffer overflow vulnerabilities. In total, RUPAIR reported 29 buffer
overflow warnings in 9 projects, by the Algorithm 1. Among these
warnings, 14 were confirmed to be true buffer overflow vulnerabili-
ties by the SMT solver Z3. We present the accuracy numbers A in
the last row of Table 3, and A is calculated by
A = B/W ,
where B andW stand for number of bugs and warnings, respectively.
The accuracy is 48.3 on average, for all the programs.
Table 3: Experiment Results on 36 Rust Projects with
5,108,432 Lines of Rust Code
Warnings Bugs Accuracy (%)
Project
redox-os
tikv
servo
actix-web
deno
citybound
nebulet
resvg
zcash
Total
Description
an OS
a KV database
a Web browser
a web framework
a game engine
a simulation game
a microkernel
an SVG library
Zerocash protocol
NA
10
5
2
2
2
2
2
2
2
29
6
1
1
0
2
2
0
2
0
14
60.0
20.0
50.0
0.0
100.0
100.0
0.0
100.0
0.0
48.3
819Rupair: Towards Automatic Buffer Overflow Detection and Rectification for Rust
ACSAC ’21, December 6–10, 2021, Virtual Event, USA
4.5 RQ3: Correctness
To answer RQ3, we validate whether the functionalities of the
rectified programs and the original ones are consistent. To conduct
such validations, we use the test data distributed with each project
to perform regressions. We executed each Rust program twice,
separately on the rectified program and the original one, from the
same execution state. Then, we compare the outputs from the two
executions. If the outputs are the same, then the rectification is
marked as "PASS"; otherwise, an inconsistency is reported to the
Rust developer.
Note that the above approach to guarantee the correctness of
the rectified programs is incomplete, because different execution
trace may generate the same output. Thus, we also leveraged a
trace validation approach, as we discussed in Section 3.6.
In our evaluation, all the rectifications to the 14 buffer overflow
vulnerabilities identified by Rupair, are proved to be correct.
This experiment demonstrated the correctness of Rupair.
4.6 RQ4: Cost
To answer RQ4, for each rectified programs, we measure the size
increment, the runtime overhead Rupair introduced into the pro-
grams being rectified, and the performance of Rupair.
Size Increment. For each rectified programs, Rupair inserted 15
extra MIR instructions, and 29.75 x86-64 assembly instructions, on
average. Such size increments are insignificant.
Cost. To understand the runtime overhead Rupair introduced
into the rectified programs, we further compare the execution time
for each rectified program with its corresponding insecure program.
In Table 4, we presented the execution time (in microsecond), along
Table 4: Execution Time for Programs before and after the
Rectification (in millisecond)
CVE or project
CVE-2018-1000810
RUSTSEC-2017-0004
redox-ralloc
redox-relibc
array-mul
array-sum
binary-search
find-duplicate
find-median
sorted-array-merge
Average
Rectified? Before After
384
NA
3846
3958
10551
19976
8202
18441
3839
6070
NA
372
NA
3700
3813
10336
19589
8014
18352
3702
5686
NA
Yes
No
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
NA
Loss (%)
3.2
NA
3.9
3.8
2.1
2.0
2.3
4.9
3.7
6.7
3.6
with the performance loss. The loss L is calculated by
L = A/B − 1,
where A and B stand for execution time after and before the recti-
fication, respectively. The loss is between 2.0% and 6.7%, with an
average of 3.6% for all programs.
This experiment shows that the extra cost Rupair introduced is
low and insignificant.
Performance. Furthermore, to gain an understanding of the per-
formance of Rupair, we conducted experiments to measure the
time Rupair spent in rectifying each of the Rust projects. In Figure
5, we presented the running time Rupair used to scan each of the
Figure 5: Performance of Rupair on the 36 Rust Projects
36 projects. The x−axis shows the projects, in an increasing order
of code sizes. The y−axis on the left shows the sizes of each project
(lines of code) in base-10 log scale. The y−axis on the right shows
the execution time for each project (in milliseconds) also in base-
10 log scale. This result demonstrated that the execution time of
Rupair increases linearly to the sizes of programs. It takes Rupair
1853 milliseconds to analyze the 5,108,432 lines of Rust source code
(2757 LOC per millisecond).
This experiment demonstrates that Rupair is efficient to analyze
real-world large Rust projects.
5 DISCUSSION
In this section, we report some lessons learned during the design
and implementation of Rupair, and present some future research
directions. It should be noted that this work represents the first step
towards detecting and rectifying buffer overflow bugs in real-world
Rust projects, and demonstrates that it can effectively detect and
rectify real CVEs and memory bugs.
5.1 Intra- and Inter-procedural Analysis
An intra-procedural program analysis operates on a procedure
granularity, whereas an inter-procedural analysis analyze the whole
program. We have 3 primary goals for Rupair: 1) it should be
effective to identify and fix real-world CVEs; 2) it should be efficient
to analyze large Rust projects; and 3) it should incur low cost.
Experiment results have demonstrated the use of an intra-function
analysis as in this work is successful in achieving these goals. On
the other hand, it should be noted that the architecture of Rupair
(Fig. 4) is neutral to any concrete analysis algorithm, as long as
the algorithm works on Rust AST or MIR. To implement such an
inter-procedural algorithm, one would build a call graph G, and
visit graph edges reversely from the use-to-def in G. Although the
use of an intra-procedural algorithm should not be considered as
820ACSAC ’21, December 6–10, 2021, Virtual Event, USA
Baojian Hua, Wanrong Ouyang, Chengman Jiang, Qiliang Fan, and Zhizhong Pan
a limitation of this work, we believe it is worthy to explore the
effectiveness of an inter-procedural algorithm in future work.
5.2 Organization of the rustc Compiler
The current rustc compiler leverages three primary intermediate
representations: 1) AST (also called HIR), the high-level abstract
syntax trees close to Rust program sources ; 2) MIR, a control-flow
graph-based middle-level IR for program analysis and optimiza-
tions; and 3) LLVM, the low-level LLVM [45] byte code representa-
tion for target code generation. In an early design of Rupair, we
have tried to perform the buffer overflow analysis and program
rectification solely on the MIR representation, as it’s straightfor-
ward to implement the analysis in this work by leveraging MIR’s
existing static analysis framework.
However, our implementation experience has demonstrated that
such a design is not suitable to our purpose in this work. The key
difficulty is that the MIR is relatively low-level, and does not carry
the required source code information necessary for this study. To be
specific, MIR does not maintain the unsafe code block information,
which makes Algorithm 1 difficult to implement. Although the
query feature of rustc make it possible to make use of 1) the AST,
to obtain the necessary source program information; and 2) MIR, to
implement the analysis algorithm, we believe the analysis will be
easier to implement if MIR is annotated with necessary information
in a future compiler version.
5.3 Other Rust Vulnerabilities
This paper only discussed the detection and rectification of buffer
overflow memory bugs. Although memory bugs are pervasive and
severe, existing studies have demonstrated Rust programs are also
vulnerable to concurrency bugs [64]. Due to the distinct nature of
memory and concurrency bugs, we leave the study of concurrency
bugs to future work.
6 RELATED WORK
In recent years, the study of security and reliability of Rust language
has drawn much research attentions, and there are a significant
amount of research on automated program repair. However, the
work in this paper stands for a novel contribution to these fields.
6.1 Rust Security
Security of Rust features. Evans et al. [31] performed a large-
scale empirical study to explore how software developers are using
unsafe Rust in real-world Rust libraries and applications. Xu et
al.[76] performed an in-depth analysis regarding the culprits of real-
world memory-safety bugs and extracted three typical categories.
Qin et al.[64] conducted the first empirical study of safety practices
and safety issues in real-world Rust programs and had a particular
focus on how Rust ownership and lifetime rules impact developers.
However, these studies only study some specific unsafe features,
but don’t consider automatically fixing bugs like our work.
Rust Semantics Formalization. Reed[66] presented a formal se-
mantics for Rust that captures the key features relevant to memory
safety. LAMQADEM et al.[43] presented a formalization of the Rust
static semantics that includes lifetime inference. Wang et al.[72] de-
signed a formal operational semantics of Rust capturing ownership,
ownership moves and borrows and formalized the semantics in the
K framework. CRUST [71] is a bounded model checker designed to
verify the safety of Rust libraries implemented using unsafe code.
RustBelt [39] provided the first formal safety proof for a realistic
subset of Rust. Dang et al. [26] extended the RustBelt project and
added support for the weak memory model widely used in the Rust
library. Other researchers [34] [18] [30] conducted semi-automated
verification on Rust programs using Viper [59], a verification plat-
form based on separation logic. This approach has also been used to
deal with unsafe code [18], generics and type traits [30]. Matsushita
et al. [55] proposed a novel method for CHC-based program verifi-
cation, and formalized the semantics for a core language of Rust.
However, the focus of these studies in on formalizing the feature
semantics, and do not discuss the identification and rectification of
bugs.
Rust Security Tools. Zhang et al.[83] constructed a tool VRLife-
Time to help programmers reason about lifetime-related errors. Luo
et al. [65] built RustViz, a tool that generates an interactive timeline
depicting ownership and borrowing events for each variable. Light
[48] proposed Reenix, a Unix-like operating system kernel. Amit et
al. [46] used Rust to develop a new embedded operating system for
microcontrollers called Tock. Facebook posted Libra [12], which
used Rust to implement its underlying blockchain. However, a ma-
jor limitation of these studies is that none of these tools can identify
or rectify buffer overflow bugs.
6.2 Automated Program Rectification
Automated program rectification has been the subject of recent
study in the software engineering research community. And the
research efforts can be divided into two categories: the search-based
method and the semantic-based method.
The Search-based Program Rectification. GenProg [74] is one of
the earliest work on search-based program repair technology, by
using genetic programming to guide the generation and verification
of patches. Weimer et al. [73] proposed an AE (Adaptive Equiva-