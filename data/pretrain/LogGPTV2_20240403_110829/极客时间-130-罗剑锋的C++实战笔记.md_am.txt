# 调用C++写的函数    x = pydemo.add(1,2)      
# 调用C++写的函数pybind11 也支持函数的参数、返回值使用标准容器，会自动转换成 Python里的list、dict，不过你需要额外再包含一个"stl.h"的头文件。下面的示例代码演示了 C++ 的 string、tuple 和 vector 是如何用于 Python的：     #include               // 转换标准容器必须的头文件    PYBIND11_MODULE(pydemo, m)             // 定义Python模块pydemo    {      m.def("use_str",                     // 定义Python函数        [](const string& str)              // 入参是string        {            py::print(str);            return str + "!!";            // 返回string        }      );        m.def("use_tuple",                  // 定义Python函数        [](tuple x)     // 入参是tuple        {            get(x)++;            get(x)++;            get(x)+= "??";            return x;                     // 返回元组        }      );        m.def("use_list",                   // 定义Python函数        [](const vector& v)          // 入参是vector        {            auto vv = v;            py::print("input :", vv);            vv.push_back(100);            return vv;                    // 返回列表               }    }因为都是面向对象的编程语言，C++ 里的类也能够等价地转换到 Python里面调用，这要用到一个特别的模板类 class\_，注意，它有意模仿了关键字class，后面多了一个下划线。我拿一个简单的 Point类来举个例子：    class Point final    {    public:        Point() = default;        Point(int a)；    public:        int get() const;        void set(int a);    };使用pybind11，你需要在模板参数里写上这个类名，然后在构造函数里指定它在Python 里的名字。导出成员函数还是调用函数def()，但它会返回对象自身的引用，所以就可以连续调用，在一句话里导出所有接口：    py::class_(m, "Point")           // 定义Python类        .def(py::init())                    // 导出构造函数        .def(py::init())               // 导出构造函数        .def("get", &Point::get)            // 导出成员函数        .def("set", &Point::set)            // 导出成员函数        ;对于一般的成员函数来说，定义的方式和普通函数一样，只是你必须加上取地址操作符"&"，把它写成函数指针的形式。而构造函数则比较特殊，必须调用init() 函数来表示，如果有参数，还需要在 init()函数的模板参数列表里写清楚。pybind11的功能非常丰富，我们不可能一下子学完全部的功能，刚才说的这些只是最基本，也是非常实用的功能。除了这些，它还支持异常、枚举、智能指针等很多C++ 特性，你可以再参考一下它的文档slate-object="inline"，学习一下具体的方法，挖掘出它的更多价值。如果你在工作中重度使用 Python，那么 pybind11绝对是你的得力助手，它能够让 C++ 紧密地整合进 Python 应用里，让 Python跑得更快、更顺畅，建议你有机会就尽量多用。Lua接下来我要说的第二个脚本语言是小巧高效的Lua，号称是"最快的脚本语言"。你可能对 Lua不太了解，但你一定听说过《魔兽世界》《愤怒的小鸟》吧，它们就在内部大量使用了Lua 来编写逻辑。在游戏开发领域，Lua可以说是一种通用的工作语言。Lua与其他语言最大的不同点在于它的设计目标：不追求"大而全"，而是"小而美"。Lua自身只有很小的语言核心，能做的事情很少。但正是因为它小，才能够很容易地嵌入到其他语言里，为"宿主"添加脚本编程的能力，让"宿主"更容易扩展和定制。标准的 Lua（PUC-Rio Lua）使用解释器运行，速度虽然很快，但和 C/C++比起来还是有差距的。所以，你还可以选择另一个兼容的项目：LuaJIT（https://luajit.org/）。它使用了 JIT（Just intime）技术，能够把 Lua 代码即时编译成机器码，速度几乎可以媲美原生 C/C++代码。 不过，LuaJIT 也有一个问题，它是一个个人项目，更新比较慢，最新的2.1.0-beta3已经是三年前的事情了。所以，我推荐你改用它的一个非官方分支：OpenResty-LuaJIT（https://github.com/openresty/luajit2）。它由 OpenResty负责维护，非常活跃，修复了很多小错误。    git clone PI:EMAIL:openresty/luajit2.git    make && make install和 Python 一样，Lua 也有 C接口用来编写扩展模块，但因为它比较小众，所以 C++项目不是很多。现在我用的是 LuaBridge，虽然它没有用到太多的 C++11新特性，但也足够好。LuaBridge是一个纯头文件的库，只要下载下来，把头文件拷贝到包含路径，就能够直接用：    git clone PI:EMAIL:vinniefalco/LuaBridge.git我们先来看看在 Lua 里怎么调 C++的功能。 和前面说的 pybind11 类似，LuaBridge 也定义了很多的类和方法，可以把C++ 函数、类注册到 Lua 里，让 Lua调用。 但我不建议你用这种方式，因为我们现在有 LuaJIT。它内置了一个 ffi库（Foreign Function Interface），能够在 Lua脚本里直接声明接口函数、直接调用，不需要任何的注册动作，更加简单方便。而且这种做法还越过了Lua 传统的栈操作，速度也更快。使用 ffi 唯一要注意的是，**它只能识别纯 C 接口，不认识C++** ，所以，写 Lua扩展模块的时候，内部可以用 C++，但对外的接口必须转换成纯 C函数。 下面我写了一个简单的 add() 函数，还有一个全局变量，注意里面必须要用extern \"C\"声明：    extern "C" {                // 使用纯C语言的对外接口    int num = 10;     int my_add(int a, int b);     }    int my_add(int a, int b)    // 一个简单的函数，供Lua调用    {        return a + b;    }然后就可以用 g++ 把它编译成动态库，不像pybind11，它没有什么特别的选项：    g++ lua_shared.cpp -std=c++11 -shared -fPIC -o liblua_shared.so在 Lua 脚本里，你首先要用 ffi.cdef 声明要调用的接口，再用 ffi.load加载动态库，这样就会把动态库所有的接口都引进Lua，然后就能随便使用了：    local ffi = require "ffi"            -- 加载ffi库    local ffi_load = ffi.load            -- 函数别名    local ffi_cdef = ffi.cdef    ffi_cdef[[                           // 声明C接口    int num;    int my_add(int a, int b);        local shared = ffi_load("./liblua_shared.so")    -- 加载动态库     print(shared.num)                                -- 调用C接口    local x = shared.my_add(1, 2)                    -- 调用C接口在 ffi 的帮助下，让 Lua 调用 C接口几乎是零工作量，但这并不能完全发挥出 Lua的优势。 因为和 Python 不一样，Lua很少独立运行，大多数情况下都要嵌入在宿主语言里，被宿主调用，然后再"回调"底层接口，利用它的"胶水语言"特性去粘合业务逻辑。要在 C++ 里嵌入 Lua，首先要调用函数**luaL_newstate()**，创建出一个 Lua 虚拟机，所有的 Lua功能都要在它上面执行。因为 Lua 是用 C 语言写的，Lua 虚拟机用完之后必须要用函数**lua_close()** 关闭，所以最好用 RAII技术写一个类来自动管理。可惜的是，LuaBridge没有对此封装，所以只能自己动手了。这里我用了智能指针 shared_ptr，在一个lambda 表达式里创建虚拟机，顺便再打开 Lua基本库：     auto make_luavm = []()              // lambda表达式创建虚拟机    {        std::shared_ptr vm(  // 智能指针            luaL_newstate(), lua_close  // 创建虚拟机对象，设置删除函数            );        luaL_openlibs(vm.get());        // 打开Lua基本库        return vm;     };    #define L vm.get()                  // 获取原始指针，宏定义方便使用在 LuaBridge 里，一切 Lua 数据都被封装成了**LuaRef** 类，完全屏蔽了 Lua底层那难以理解的栈操作。它可以隐式或者显式地转换成对应的数字、字符串等基本类型，如果是表，就可以用"\[\]"访问成员，如果是函数，也可以直接传参调用，非常直观易懂。使用 LuaBridge 访问 Lua 数据时，还要注意一点，它只能用函数**getGlobal()** 看到全局变量，所以，如果想在 C++ 里调用 Lua功能，就一定不能加"local"修饰。给你看一小段代码，它先创建了一个 Lua 虚拟机，然后获取了 Lua 内置的package 模块，输出里面的默认搜索路径 path 和cpath：     auto vm = make_luavm();                  // 创建Lua虚拟机    auto package = getGlobal(L, "package");  // 获取内置的package模块    string path  = package["path"];          // 默认的lua脚本搜索路径    string cpath = package["cpath"];         // 默认的动态库搜索路径你还可以调用 **luaL_dostring() 和luaL_dofile()** 这两个函数，直接执行 Lua代码片段或者外部的脚本文件。注意，luaL_dofile()每次调用都会从磁盘载入文件，所以效率较低。如果是频繁调用，最好把代码读进内存，存成一个字符串，再用luaL_dostring() 运行：    luaL_dostring(L, "print('hello lua')");  // 执行Lua代码片段    luaL_dofile(L, "./embedded.lua");        // 执行外部的脚本文件在 C++ 里嵌入Lua，还有另外一种方式：**提前在脚本里写好一些函数，加载后在 C++里逐个调用**，这种方式比执行整个脚本更灵活。具体的做法也很简单，先用 luaL_dostring() 或者 luaL_dofile()加载脚本，然后调用 getGlobal() 从全局表里获得封装的 LuaRef对象，就可以像普通函数一样执行了。由于 Lua是动态语言，变量不需要显式声明类型，所以写起来就像是 C++的泛型函数，但却更简单：    string chunk = R"(                    -- Lua代码片段        function say(s)                   -- Lua函数1            print(s)        end        function add(a, b)                -- Lua函数2            return a + b        end    )";    luaL_dostring(L, chunk.c_str());      // 执行Lua代码片段    auto f1 = getGlobal(L, "say");        // 获得Lua函数    f1("say something");                  // 执行Lua函数    auto f2 = getGlobal(L, "add");        // 获得Lua函数    auto v = f2(10, 20);                  // 执行Lua函数只要掌握了上面的这些基本用法，并合理地划分出 C++ 与 Lua的职责边界，就可以搭建出"LuaJIT + LuaBridge +C++"的高性能应用，运行效率与开发效率兼得。比如说用 C++写底层的框架、引擎，暴露出各种调用接口作为"业务零件"，再用灵活的 Lua脚本去组合这些"零件"，写上层的业务逻辑。小结好了，今天我讲了怎么基于 C++ 搭建混合系统，介绍了 Python 和 Lua这两种脚本语言。Python 很"大众"，但比较复杂、性能不是特别高；而 Lua比较"小众"，很小巧，有 LuaJIT让它运行速度极快。你可以结合自己的实际情况来选择，比如语言的熟悉程度、项目的功能/性能需求、开发的难易度，等等。今天的内容也比较多，我简单小结一下要点：1.       C++    高效、灵活，但开发周期长、成本高，在混合系统里可以辅助其他语言，编写各种底层模块提供扩展功能，从而扬长避短；        2.       pybind11 是一个优秀的 C++/Python    绑定库，只需要写很简单的代码，就能够把函数、类等 C++ 要素导入    Python；        3.       Lua 是另一种小巧快速的脚本语言，它的兼容项目 LuaJIT    速度更快；        4.       使用 LuaBridge 可以导出 C++ 的函数、类，但直接用 LuaJIT 的 ffi    库更好；        5.       使用 LuaBridge 也可以很容易地执行 Lua 脚本、调用 Lua 函数，让 Lua    跑在 C++ 里。        课下作业最后是课下作业时间，给你留两个思考题：1.       你觉得使用脚本语言与 C++    搭建混合系统有什么优势？        2.       你觉得"把 C++ 嵌入脚本语言"和"把脚本语言嵌入    C++"有什么区别，哪种方式更好？        欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。![](Images/4d76fdd0420e64ddd7d7d9163ef7288c.png)savepage-src="https://static001.geekbang.org/resource/image/e4/2b/e47906e7f83ec210cc011e2652eee12b.jpg"}