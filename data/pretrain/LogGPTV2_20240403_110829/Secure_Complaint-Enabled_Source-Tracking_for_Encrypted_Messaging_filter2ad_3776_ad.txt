return âŸ¨A, ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk, ğ‘ğ‘‘)âŸ©(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘’, pk)
(ğ‘š, fdâ€²â€²) â† âŸ¨ğ‘ˆğ‘Ÿğ‘’ğ‘, ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk, ğ‘ğ‘‘)âŸ©(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘’, pk)
ğ‘šğ‘–ğ‘‘â€² â†R {0, 1}ğ‘›
ğ‘‡ğ‘Ÿğ‘’ğ‘ [ğ‘šğ‘–ğ‘‘â€²] â† (ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘š, fdâ€²â€²)
return ğ‘šğ‘–ğ‘‘â€²
getUser(ğ‘ˆ , ğ‘–ğ‘ ğ‘€ğ‘ğ‘™)
U â† Uâ„ğ‘œğ‘›ğ‘’ğ‘ ğ‘¡ âˆª Uğ‘šğ‘ğ‘™
if ğ‘ˆ âˆˆ U :
return âŠ¥
if ğ‘–ğ‘ ğ‘€ğ‘ğ‘™ :
Uâ€² â† âŸ¨A, ğ‘ƒğ‘›ğ‘’ğ‘¤ (sk, U)âŸ©(ğ‘ˆ , pk)
if Uâ€² = âŠ¥ : return âŠ¥
return Uğ‘šğ‘ğ‘™ .ğ‘ğ‘‘ğ‘‘(ğ‘ˆ)
(ğ‘ğ‘‘, Uâ€²) â† âŸ¨ğ‘ˆğ‘›ğ‘’ğ‘¤, ğ‘ƒğ‘›ğ‘’ğ‘¤ (sk, U)âŸ©(ğ‘ˆ , pk)
if (ğ‘ğ‘‘, Uâ€²) = âŠ¥ :
Uâ„ğ‘œğ‘›ğ‘’ğ‘ ğ‘¡ .ğ‘ğ‘‘ğ‘‘(ğ‘ˆ)
ğ‘‡ğ‘ğ‘¢ğ‘¡â„[ğ‘ˆ ] â† ad
return âŠ¥
malSend(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , md)
if ğ‘ˆğ‘  âˆ‰ Uğ‘šğ‘ğ‘™ :
(ğ‘ğ‘‘, ğ‘’) â† âŸ¨A, ğ‘ƒğ‘ ğ‘’ğ‘›ğ‘‘ (sk, md)âŸ©(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , pk)
if ğ‘ˆğ‘Ÿ âˆˆ Uğ‘šğ‘ğ‘™ :
return âŠ¥
return âŸ¨A, ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk, ğ‘ğ‘‘)âŸ©(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘’, pk)
(ğ‘š, fd) â† âŸ¨ğ‘ˆğ‘Ÿğ‘’ğ‘, ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk, ğ‘ğ‘‘)âŸ©(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘’, pk)
if fd = âŠ¥ :
ğ‘šğ‘–ğ‘‘ â†R {0, 1}ğ‘›
ğ‘‡ğ‘Ÿğ‘’ğ‘ [ğ‘šğ‘–ğ‘‘] â† (ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘š, fd)
return ğ‘šğ‘–ğ‘‘
return âŠ¥
ğ‘†ğ‘‡ ,E
return 0
ğ‘ ğ‘Ÿğ‘ğµğ¼ ğ‘ ğ·A
(sk, pk) â† KGen(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ )
(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , md, ğ‘ ğ‘¡) â† AO
1 (pk)
if ğ‘ˆğ‘Ÿ âˆ‰ Uâ„ğ‘œğ‘›ğ‘’ğ‘ ğ‘¡ :
return 0
(ğ‘ğ‘‘, ğ‘’) â† âŸ¨A2(ğ‘ ğ‘¡), ğ‘ƒğ‘ ğ‘’ğ‘›ğ‘‘ (sk, md)âŸ©(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , pk)
(ğ‘š, fd) â† âŸ¨ğ‘ˆğ‘Ÿğ‘’ğ‘, ğ‘ƒğ‘Ÿğ‘’ğ‘ (ğ‘ğ‘‘, sk)âŸ©(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘’, pk)
if fd = âŠ¥ :
(ğ‘ ğ‘Ÿğ‘, md) â† âŸ¨ğ‘ˆğ‘Ÿğ‘’ğ‘ (fd), ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk)âŸ©(ğ‘š, pk)
if (ğ‘ ğ‘Ÿğ‘, md) = âŠ¥ :
else : return 0
ğ‘¢ğ‘›ğ¹ğ‘‚ğ‘…ğºğ¸A
(sk, pk) â† KGen(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ )
(ğ‘š, ğ‘ ğ‘¡, Mğ‘ ğ‘’ğ‘›ğ‘¡) â† AO
1 (pk)
(ğ‘ ğ‘Ÿğ‘, md) â† âŸ¨A2(ğ‘ ğ‘¡), ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk)âŸ©(ğ‘š, pk)
if (ğ‘ ğ‘Ÿğ‘, md) = âŠ¥ :
if ğ‘ ğ‘Ÿğ‘ âˆ‰ Uğ‘šğ‘ğ‘™ âˆ§ (ğ‘ ğ‘Ÿğ‘, md, ğ‘š) âˆ‰ Mğ‘ ğ‘’ğ‘›ğ‘¡ :
return 0
return 1
ğ‘†ğ‘‡ ,E
return 1
else : return 0
Figure 2: Unforgeability and accountability games with their accompanying oracles. The adversary is also given access to send(Â·, ğ‘ˆ , Â·)
and receive(Â·, Â·, ğ‘ˆ) oracles for the underlying encrypted messaging scheme for all adversary-controlled users ğ‘ˆ âˆˆ Uğ‘šğ‘ğ‘™ , as well a
reporting oracle âŸ¨Â·, ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk)âŸ©(Â·, pk).
We say that ğ‘†ğ‘‡ is accountable or has accountability if Adv
is negligible for all efficient adversaries A.
Definition 3.6. We define the advantage of an adversary A in the
ğ‘¢ğ‘›ğ¹ğ‘‚ğ‘…ğºğ¸ game for a source-tracking scheme ğ‘†ğ‘‡ and messaging
scheme E as
srcâˆ’bind
ğ‘†ğ‘‡ ,E
(A)
Adv
unforge
ğ‘†ğ‘‡ ,E (A) = Pr[ğ‘¢ğ‘›ğ¹ğ‘‚ğ‘…ğºğ¸A
ğ‘†ğ‘‡ ,E = 1].
We say that ğ‘†ğ‘‡ is unforgeable if Adv
efficient adversaries A.
unforge
ğ‘†ğ‘‡ ,E (A) is negligible for all
We note that our unforgeability and accountability requirements
do not apply to the platform, only to users. As observed by [31],
requiring that a scheme be secure against platform-produced forg-
eries would conflict with the deniability properties discussed below.
3.4 Deniability
We require that a source-tracking scheme satisfies two types of
deniability to protect users if the messaging system is compromised:
â€¢ universal deniability: Users should be able to deny participating
â€¢ platform compromise deniability: If the platformâ€™s secret key sk is
leaked publicly, a user should still be able to deny participating
in a reported forwarding path.
in a forwarding path of a reported message.
Motivated by the approach of [31], we capture these goals by re-
quiring the existence of efficient protocols UForge and PForge that
can be executed by any user (with access to the platformâ€™s secret
keys in the case of PForge). These protocols must successfully create
a set of forged transcripts and forwarding data indistinguishable to
a third party from the actual transcripts resulting from the path and
subsequent report of a forwarded message. In universal deniability,
the party tasked with differentiating transcripts has access to the
platformâ€™s public keys and the secret keys of all users in the system,
while for platform compromise deniability, they are given access to
the platformâ€™s secret keys as well. We discuss the space of potential
deniability definitions and formalize security games for univer-
sal deniability (ğ‘ˆ ğ‘›ğ‘–ğ‘£ğ·ğ¸ğ‘ ) and platform-compromise deniability
(ğ‘ƒğ‘™ğ‘ğ‘¡ğ·ğ¸ğ‘ ) in Appendix A.2.
Definition 3.7. For a deniability game ğ·ğ¸ğ‘ and forgery algo-
rithm Forge, the advantage of an adversary A against this game,
Adv
ğ‘†ğ‘‡ ,E,Forge(A), is defined as
den
(cid:12)(cid:12)(cid:12)Pr(cid:104)ğ·ğ¸ğ‘ A,1
ğ‘†ğ‘‡ ,E,Forge = 1(cid:105) âˆ’ Pr(cid:104)ğ·ğ¸ğ‘ A,0
ğ‘†ğ‘‡ ,E,Forge = 1(cid:105)(cid:12)(cid:12)(cid:12) .
ğ‘†ğ‘‡ ,E,Forge(A) =
Adv
den
Definition 3.8. We say that a source-tracking scheme ğ‘†ğ‘‡ is deni-
able if there exist efficient (possibly interactive) algorithms UForge
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1490and PForge such that for any efficient adversaries Ağ‘¢ and Ağ‘,
platden
ğ‘†ğ‘‡ ,E,PForge(Ağ‘) are both negligible.
Adv
ğ‘†ğ‘‡ ,E,UForge(Ağ‘¢) and Adv
univden
4 TREE-LINKABLE SOURCE TRACKING
Straw-man scheme. A first straw-man attempt at tree-linkable
source-tracking could have the identity ğ‘ˆğ‘† of the original sender
of a message included with the message plaintext, so the final mes-
sage becomes an encryption of (ğ‘ˆğ‘ , ğ‘š). While this approach would
satisfy platform confidentiality and deniability requirements, it
does not satisfy user confidentiality, accountability, or unforgeabil-
ity, as nothing would prevent malicious users from observing or
tampering with the sender identity included in the message.
Our scheme. Instead, the starting point for our approach is to
have the platform append a signature on (Enc(ğ‘˜, ğ‘ˆğ‘ ), ğ‘ğ‘š) to each
message, where ğ‘˜ is an encryption key known only to the platform
and ğ‘ğ‘š is a commitment to the message plaintext, provided by
the sender. This signature is passed along whenever a message is
forwarded, and the signature is checked by each message recipient
using the platformâ€™s public key and commitment randomness ğ‘Ÿ
included by the sender alongside the end-to-end encrypted plain-
text. This scheme enforces user confidentiality, unforgeability, and
accountability, but it does not yet provide platform confidentiality
because the platform can always decrypt the sender identity that is
sent alongside each message.
Our final scheme combines the construction thus far with the
straw-man construction. When a message is forwarded for the
first time, the forwarder includes the signature, commitment, and
commitment randomness alongside the message plaintext that is
end-to-end encrypted and hidden from the platform, i.e., it encrypts
and sends (ğ‘š, Enc(ğ‘˜, ğ‘ˆğ‘†), ğ‘ğ‘š, ğ‘Ÿ). Subsequent forwards pass along
the same information inside the end-to-end encrypted ciphertext,
with each recipient checking that the signature and commitment
match the provided message and encrypted sender pair. Fresh mes-
sages include padding to hide the fact that they do not contain
forwarding information, and forwarded messages send the server
a commitment to an empty message to hide the fact that they are
forwards. Users report messages by sending the message plain-
text, commitment, randomness, and signature to the platform, who
checks the signature and decrypts the identity of the original sender.
In terms of security, hiding the forwarding information inside the
end-to-end encrypted message provides platform confidentiality,
while encrypting the original sender provides user confidentiality.
The fact that the forwarding information a user sees does not change
when a message is forwarded makes the scheme tree-linkable: a
user can tell when the same original message has been forwarded
to it twice. Accountability and unforgeability are provided by the
platform being the one to include the sender identity and signing
it, and deniability results from the sender identity being encrypted
and therefore hidden from everyone except the platform (and being
trivial to forge if the platform keys are known).
Our scheme, formalized in Figure 3, makes use of the underly-
ing messaging scheme E = (send(ğ‘š, ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ), receive(ğ‘ğ‘¡, ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ)) as
well as the following cryptographic tools.
â€¢ A symmetric encryption scheme
P = (KGenğ‘ ğ‘¦ğ‘š â†’ k, Enc(k, ğ‘š) â†’ ğ‘ğ‘¡, Dec(k, ğ‘ğ‘¡) â†’ ğ‘š).
Report(ğ‘š, pk)
ğ‘ˆğ‘Ÿğ‘’ğ‘ (fd)
ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk = (k, skğ‘ ))
fd
KGen(params)
k â† KGenğ‘ ğ‘¦ğ‘š
(skğ‘ , vkğ‘ ) â† KGenğ‘ ğ‘–ğ‘”
pk â† vkğ‘ , sk â† (k, skğ‘ )
return (pk, sk)
newUser(ğ‘ˆğ‘–, sk)
if ğ‘ˆğ‘– âˆˆ U :
return âŠ¥
U.ğ‘ğ‘‘ğ‘‘(ğ‘ˆğ‘–)
return U
AuthMsg(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , pk)
ğ‘ˆğ‘ğ‘¢ğ‘¡â„(ğ‘šğ‘ ğ‘”)
(ğ‘š,âŠ¥) â† ğ‘šğ‘ ğ‘”
(ğ‘ğ‘š, ğ‘Ÿ) â† Commit(ğ‘š)
//send (m,data) via underlying msg scheme
ğ‘’ â† send((ğ‘š,âŠ¥, ğ‘ğ‘š, ğ‘Ÿ), ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ)
(ğœ, ğ‘ ğ‘Ÿğ‘, ğ‘ğ‘š, ğ‘Ÿ) â† fd
if Â¬Open(ğ‘ğ‘š, ğ‘š, ğ‘Ÿ) :
if Â¬Vf(pk, ğœ, (ğ‘ğ‘š, ğ‘ ğ‘Ÿğ‘)) :
return âŠ¥
return âŠ¥
return Dec(k, ğ‘ ğ‘Ÿğ‘)
ğ‘ƒğ‘ ğ‘’ğ‘›ğ‘‘ (sk = (k, skğ‘ ), md)
(ğ‘ğ‘š, ğ‘’)
return ğ‘’
FwdMsg(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , pk)
ğ‘ˆğ‘“ ğ‘¤ğ‘‘ (ğ‘šğ‘ ğ‘”)
(ğ‘š, fd) â† ğ‘šğ‘ ğ‘”
(ğ‘ğ‘š, ğ‘Ÿ) â† Commit(âŠ¥)
ğ‘’ â† send((ğ‘š, fd, ğ‘ğ‘š, ğ‘Ÿ), ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ)
(ğ‘ğ‘š, ğ‘’)
RecMsg(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘’, pk)
ğ‘ˆğ‘Ÿğ‘’ğ‘
ğ‘ ğ‘Ÿğ‘ â† Enc(k, (ğ‘ˆğ‘ , md))
ğœ â† Sig(skğ‘ , (ğ‘ğ‘š, ğ‘ ğ‘Ÿğ‘))
return (ğ‘ğ‘‘ = (ğœ, ğ‘ ğ‘Ÿğ‘), ğ‘’)
ğ‘ƒğ‘ ğ‘’ğ‘›ğ‘‘ (sk = (k, skğ‘ ), md)
ğ‘ ğ‘Ÿğ‘ â† Enc(k, (ğ‘ˆğ‘ , md))
ğœ â† Sig(skğ‘ , (ğ‘ğ‘š, ğ‘ ğ‘Ÿğ‘))
return (ğ‘ğ‘‘ = (ğœ, ğ‘ ğ‘Ÿğ‘), ğ‘’)
ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk, ğ‘ğ‘‘)
ğ‘ğ‘‘
(ğœ, ğ‘ ğ‘Ÿğ‘) â† ğ‘ğ‘‘
(ğ‘š, fdâ€², ğ‘ğ‘š, ğ‘Ÿ) â† receive(ğ‘’, ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ)
//verify platform signature
if Â¬Vf(pk, ğœ, (ğ‘ğ‘š, ğ‘ ğ‘Ÿğ‘)) :
if fdâ€² = âŠ¥ : //If message is new
return âŠ¥
if Â¬Open(ğ‘ğ‘š, ğ‘š, ğ‘Ÿ) :
return ğ‘š, fd â† (ğœ, ğ‘ ğ‘Ÿğ‘, ğ‘ğ‘š, ğ‘Ÿ)
ğ‘š, ğ‘Ÿâ€²) â† fdâ€²
(ğœâ€², ğ‘ ğ‘Ÿğ‘â€², ğ‘â€²
return âŠ¥
else :
return âŠ¥
return âŠ¥
if Â¬Open(ğ‘ğ‘š,âŠ¥, ğ‘Ÿ) :
if Â¬Open(ğ‘â€²