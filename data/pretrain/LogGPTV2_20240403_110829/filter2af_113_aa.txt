> 原文链接： code-exploitation-of-a-write-what-where-in-internet-> explorer?tdsourcetag=s_pcqq_aiomsg>
在2018年的最后一天，我在`Internet
Explorer`中发现了一个[类型混淆漏洞](https://www.zerodayinitiative.com/advisories/ZDI-19-359/)，可以利用它产生一个`write-what-where`原语。它于今年四月得到修复，编号为[CVE-2019-0752](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-0752)。作为练习，我使用原始的开发技术为此漏洞编写了一个完整的exp。即使漏洞本身仅产生受控写入并且无法触发以产生信息泄漏，但是仍然存在直接且高度可靠的代码执行路径
此外值得注意的一点是，该利用过程不需要使用shellcode
# 背景
在`IE == 8`或更低的仿真级别，`Internet
Explorer`通过该[`IDispatchEx`机制](https://docs.microsoft.com/en-us/scripting/winscript/reference/idispatchex-interface)执行`DOM`方法和属性。尽管这是最自然的实现选择，但在性能方面还有很多不足。为了提高性能，`IE`为`DOM`属性和方法的子集实现了
**快速路径**
，这些是通过位于静态表`mshtml!_FastInvokeTable`中的函数指针调用的。当可用时，快速路径通过避免使用某些常规的调度机制来实现加速。以下反编译代码来自`mshtml!CBase::ContextInvokeEx`中的`IDispatchEx::InvokeEx`：
如上述的代码片段显示，如果请求的是`put`操作，则不会使用加速调用机制
原因很显然，对于给定的方法或属性，`_FastInvokeTable`只能包含一个条目，并且从属性的角度来讲，它将指向更频繁调用的属性`getter`而不是`setter`
# 漏洞分析
上述代码中漏洞的根源在于`IDispatchEx`允许两种不同的属性放置于同一处的事实。典型属性`put`将例如整数或字符串的标量值分配给属性，此操作类型由标志`DISPATCH_PROPERTYPUT`指出，其值为`0x4`。另一种属性的`put`是将对象引用分配给属性，在使用时，需要在调用时提供标志值`DISPATCH_PROPERTYPUTREF`，其值为`0x8`。
有点令人困惑的是，标志值被定义为这两个看似不相关的操作类型，因此无法通过`DISPATCH_PROPERTYPUT`位检测到`putref`类型的操作。因此，在上述代码中，类型的操作`DISPATCH_PROPERTYPUTREF`将被错误地路由到`_FastInvokeTable`属性的条目，而其中存放的属性是`get`方法的指针。`get`方法和`put`方法的函数签名必然是不同的，因此，这里传递的、用于给属性赋值的值就会出现类型混淆。
接下来发生的事情，取决于 **与被调用的特定属性相对应的** 混淆的`get/put`函数的签名。
我找到了三个可能的函数签名子句，如下所示：
在每种情况下，我们都能够调用`get`方法来代替`put`方法。
对于`Case 1`来说，并没有安全隐患，会调用`get_className_direct`函数，并且对于其out参数(类型为`BSTR
*`)，传递的是不兼容类型`BSTR`的值。当`get_className_direct`执行时，它会实例化一个新的`BSTR`来保存`get`操作的结果，并在`BSTR*
value`参数指定的地址处写入一个指向这个新字符串的指针。在我们的例子中，这会覆盖所提供的`BSTR`的字符数据的前四个字节。除了覆盖它们外，不会发生其他的内存损坏。注意，4字节指针值实在太短了，绝不可能
**溢出BSTR分配的字符数据部分** 并 **覆盖相邻的内存空间**
。此外，脚本无法访问损坏的字符串数据以进行信息泄漏，因为传递给`get_className_direct`的`BSTR`是临时的。之后，脚本所访问的`BSTR`的内存空间，和一开始的是不同的。因此，案例1是无法利用的。
对于`Case 2`来说，被利用的可能性更大一点，通过属性的put操作赋值的对象将作为`struct
tagVARIANT`的值进行传递，但由于将调用`get`方法，因此，`tagVARIANT`结构的前4个字节将被解释为`VARIANTARG
*`——一个指向将被结果值填充的`VARIANTARG`结构的指针。当然，我们能够对`tagVARIANT`的前4个字节施加部分控制，使其等于指向我们希望破坏的数据的地址。然而这种情况下，混淆的`get`和`put`函数具有不同的
**堆栈参数总长度**
，因此这里很难加以利用。当`getter`返回时，堆栈指针将无法进行适当的调整。函数调用方会立即检测到这种差异，并且安全地关闭该进程。
相比之下，`Case
3`提供了出色的可利用性。设置属性时传入的值将传递给`CElement::get_scrollLeft`，后者会将这些值解释为`int*`指针写入结果的位置。因此，`scrollLeft`的当前值将按照我们选择的地址写入内存。之后，控制权将返回给这个脚本。这为攻击者提供了一个`write-what-where`原语。唯一的限制似乎是`scrollLeft`的值不能设置为大于`0x001767dd`的值，所以，这个值就是我们可以写入的最大的`DWORD`值，然而这也不会造成很大的障碍。
以下`PoC`演示了如上所述的`write-what-where`原语。注意，这里使用的是`VBScript`。据我所知，这是生成所需`DISPATCH_PROPERTYPUTREF`的唯一方法。
为了触发该漏洞，我们可以将一个`MyClass`实例赋给`scrollLeft`
这样，系统会生成一个带有标志`DISPATCH_PROPERTYPUTREF`的调用。由于`mshtml!CBase::ContextInvokeEx`中存在安全漏洞，故被调用的将是`CElement::get_scrollLeft`，而不是`CElement::put_scrollLeft`
我们知道，`CElement::put_scrollLeft`具有一个整型参数，因此，调度机制会将`MyClass`实例强制转换为整型，当`CElement::get_scrollLeft`接收这个整数后，后面的函数会将该它解释为指向内存位置的指针
总而言之，值`0x1234`将写入`0xdeadbeef`。由于实现细节的原因，这里首先会对`0xdeadbeef`进行一些无关的读写操作。为了查看整体效果，最简单的方法是使用已知的有效地址替换`PoC`中的`0xdeadbeef`
# 漏洞利用
## 第一部分：从任意写到任意读
利用该漏洞的主要障碍在于，它虽然提供了 **写入原语** ，却没有 **读取原语** 或 **信息泄漏**
功能。因此，攻击者首先面临的问题是，不知道任何安全或有用的地址。
但是，只需 **分配一个非常大的数组** ， **使得所选的常量地址几乎总是位于该数组的内存空间中** ，就能轻松搞定这个问题：
创建`ar1`时，会在内存中为`VARIANT`结构分配一段地址连续的缓冲区，总长度为`0x30000000`字节。如果是从一个干净的进程开始的话，这段内存空间肯定会包括我们选择的地址`0x28281000`
最初，`ar1`中的所有`VARIANT`结构的内容都为`0`，因此，每个元素的类型都为`VT_EMPTY`。如果我们在`0x28281000`处写入一个新值，比如说`0x4003
(VT_BYREF | VT_I4)`，那么，它将改变`ar1`的一个元素的类型，使其不再是空值。
通过遍历数组，我们可以找出损坏的元素。这里，我们将这个元素称为`gremlin`，因为`gremlin`叫起来很气派。在我们的漏洞利用代码中，变量`gremlin`用于索引，因此，`gremlin`本身被引用为ar1(gremlin)。
注意，数组的起始地址的可变性是受约束的，因为该地址总是位于内存页的边界处，也就是说，是`0x1000`的倍数。因此，查找`gremlin`时，我们不必检查每个数组元素，我们可以检查每个第
**0x100（0x1000除以VARIANT的大小）**
处的元素即可。通过这种方法，可以快速完成对`gremlin`的搜索，通常不到一秒钟。顺便提一下，这种对地址可变性的约束也是我们可以确定0x28281000必定位于一个`VARIANT`元素的
**开头** 而不是`VARIANT` **中间某处** 的原因。
> 现在，为什么我选择给`gremlin`类型为`VT_BYREF | VT_I4`？
因为通过这种类型的`VARIANT`能够间接获取一个 **针对整数值的读取原语** 。
换句话说，假设我们按如下方式对`gremlin`的内存空间执行写操作：
然后，当读取`gremlin`的值时`ar1(gremlin)`，它将对地址0x12345678`进行`dereference(*addr)`操作，并返回从那里找到的4字节整数。也就是说，我们终于获取了
**读原语** 。
实际上，我掩饰了一个优点
要构造以上所示的`gremlin`，我们要将目标地址写入位置`0x28281008`。但是，如前所述，我们的`write原语`有一个限制，即它不能写大于的值`0x001767dd`
我使用的解决方案是一次写一个小值，每个值在范围内`0x00-0xff`，每个值从后续地址开始。通过重复这个过程4次，我们可以在内存中建立一个任意的4字节值，但需要注意的是，后面的3个字节最终会
**被零覆盖**
。在`VARIANT`如上图所示的结构中，在字段后面有一个未使用的4字节字段`0x28281008`，所以不需要的零不会造成伤害（更重要的是，它们都是零开始）。下图显示了如何把`0x12345678`通过四个单独的受限DWORD写入来构建任意`DWORD`。
应对下一个挑战： **我们仍然不知道任何有趣的地址** 。
同样，这很快就得到了补救。由于我们知道数组元素`ar1(gremlin)`位于`0x28281000`，因此数组元素`ar1(gremlin+1)`位于`0x28281010`。我们可以放置一个任意对象`ar1(gremlin+1)`，然后使用`gremlin`作为`read原语`来
**泄露目标对象的地址** ：