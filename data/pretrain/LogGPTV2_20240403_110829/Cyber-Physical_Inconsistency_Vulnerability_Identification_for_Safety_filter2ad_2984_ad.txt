functions after the detection. In ArduCopter, V1 and V2 are the
under-approximation (UA) vulnerabilities, as the crash check fails
to detect real crashes under the given conditions (check result =
false), whereas V3, V4, and V5 are the over-approximation (OA)
vulnerabilities, because the checks erroneously detect normal oper-
ations as safety-critical situations (check result = true). In PX4, V6
(OA) triggers a false alarm of the freefall check under wind gust,
and the landing check of V8 (OA) falsely determines the landing
status while the vehicle is hovering under rising wind, whereas V7
(UA) fails to detect actual ground contact. In APMrover2, V9 and
V10 (UA) miss the detection of actual crashes. Observe that each
case leads to critical and unrecoverable consequences such as crash,
drift away, and position lock. We present the actual attacks on real
and simulated vehicles as case studies in Section 5.3.
Effectiveness of Search-based Testing. We compare our evolu-
tionary search with gradient descent and random search. In the
gradient descent, we approximate the gradients by the variations of
inputs over the variation of the weighted sum of multiple objectives.
Note that gradients cannot be directly computed using the chain
rules [7] as an RV system is not a closed loop. As gradient descent
tends to get stuck in local optimals, we run it multiple times and
report the best result. We also run a random search, which per-
forms uniform sampling in the same input ranges as those in the
evolutionary search. We run it for a number of times that equal to
the total number of individuals in the evolutionary search. Table 5
(in Appendix) shows the cost value changes and the testing time
with different techniques for all the reported cases. Note that the
CP-inconsistency level (IL) indicates the difference between the
cyber and physical costs, thus the larger the better for our purpose.
Observe that while the evolutionary technique successfully finds
the vulnerabilities, the others mostly fail. Specifically, in the evo-
lutionary search, the optimization directions (↓ or ↑) for each cost
function (Cn and P) are consistent with the search goals, while the
others are not, meaning that other approaches cannot deal with
contradictory objectives.
Figure 11: Physical costs and threshold
Physical Accident Detection and Threshold. Recall that our
technique uses the physical cost (Fρ), i.e., the differences between
the RV and VRV states, and a threshold to determine a real accident.
The detection ought to be precise as it provides the ground truth for
the evolutionary search. Figure 11 shows clear distinction between
the real crashes confirmed in simulation (red and black circles) and
normal executions, which are the blue circles close to the x axis .
Each circle denotes the normalized maximum physical cost of a test.
Observe that the (pink) area for crashes and the (green) area for
none crashes have a big gap. It means that any threshold falling into
the gap allows precise detection of real crashes. Moreover, observe
that the under-approximation cases (red circles) clearly belong to
the pink area, meaning that our method can precisely report real
crashes while the safety checks fail.
5.3 Case Studies
In this section, we provide case studies for CP-inconsistency found
by our technique. We also discuss how attackers exploit these vul-
nerabilities to disrupt operations without leaving footprints.
5.3.1 ArduCopter. ArduCopter is equipped with several safety
checks. We present a representative over-approximation case in
the thrust loss check.
1 #define TLC_ANGLE_DEVIATION_CD 1500
2 #define TLC_MIN_THROTTLE 0.9f
3 #define CRASH_CHECK_ANGLE_DEVIATION 30.0f
4 #define TLC_TRIGGER_SEC 1
5
6 if(motors->is_thrust_boost) {
7
8 }
9 if( (!motors->armed() || land_completed) ||
10
(angle_target > TLC_ANGLE_DEVIATION_CD) ||
11
(throttle limited) ||
12
(throttle = 0) ||
13
(angle_error >= CRASH_CHECK_ANGLE_DEVIATION) {
14
15
16 }17 thrust_loss_counter++;
18 if(thrust_loss_counter >= TLC_TRIGGER_SEC) { //1(s)
19
20
21 }
gcs().send_text("Potential Thrust Loss");
motors->set_thrust_boost(ture);
return;
thrust_loss_counter = 0;
return;
Figure 12: thrust loss check in ArduCopter
Non-crashCrash (     UA)Session 1E: Cyberphysical Systems CCS '20, November 9–13, 2020, Virtual Event, USA272Table 4: CP-inconsistencies discovered
#
V1
V2
V3
V4
V5
V6
V7
V8
V9
Controller
ArduCopter
ArduCopter
ArduCopter
ArduCopter
ArduCopter
PX4
PX4
PX4
APMrover2
V10
APMrover2
Safety-check Type
VTF Configuration
crash check
crash with a wall
crash check
crash with an object
crash check
wind gust
thrust loss check
wind gust
parachute check
wind gust
freefall check
wind gust
ground contact
wind gust
landing check
Rising wind
crash check
object crash
crash check
non-fixed object crash weight
Vulnerability Type
Main Input Type
under-approximation
object rotation
under-approximation
weight / inertia
over-approximation
wind strength / direction
over-approximation
wind strength / direction / durration
over-approximation
wind strength / direction
over-approximation
wind strength / duration
under-approximation
wind strength / direction / duration
over-approximation
wind strength / duration
under-approximation
object position
under-approximation
Mission
Input Condition
straight line
[0 0 -28.6]
straight line
24 [12.3 15.4 3.0]
waypoints (S->N)
16 [-1 0 0]
fly up (takeoff)
32 [0 0 -89.9] 1
waypoints (W->E)
15->20 [0 1 0]
hovering
35 / 0.4
waypoints
31 [0.5 0.3 -0.8] 1.4
hovering
28 / 0.6
drive forward
[5 -0.3 0]
drive forward
2.3
6
6
6
# Constraints
# Model States
# Cyber Objectives
Check Result (Reaction) Attack Consequence
3
false
3
false
3
true (disarm)
5
true (thrust boost)
4
true (parachute)
3
true (alert)
3
false
4
true (zero thrust)
5
false
5
false
5
multiple impact crash
5
multiple impact crash
5
sudden drop
4
sudden acceleration and drift away
7
parachute released in normal operation
1
emergency alert in normal operation
4
bounce and fly away (trajectory deviation)
2
6
unexpected landing
2
4
run-off-road multiple crashes
2
crashes with a non-fixed object (no response)
6
6
6
6
4
Thrust Loss. ArduCopter triggers a boost of thrust when it detects
thrust loss. Figure 12 shows the simplified code for the thrust loss
checks in ArduCopter. In order to identify thrust loss, it has a
set of if-conditions (highlighted) on system states. When all these
conditions are satisfied to reach the statements at lines 20-21 (i.e.,
thrust loss is detected for at least TLC_TRIGGER_SEC=1 second),
the thrust boost function is triggered, which scales the motor thrust
by a ratio, to compensate for the detected loss.
To test the thrust loss safety checks, our VTF configuration uses
wind gust on the quadrotor flying in the loiter mode, in which the
vehicle tries to maintain the target pose - position and attitude. The
wind gust causes thrust loss on the vehicle. In this situation, the
expected behavior of the checks is to activate the thrust boost so
that the vehicle continues to fly against the wind forces.
Our technique was able to find an input condition that causes
erroneous detection of thrust loss and the undesired activation
of thrust boost (i.e., over-approximation CP-inconsistency). The
sudden boost (or acceleration), when there is no real thrust loss,
makes the vehicle fly away from the target position. Specifically, the
input condition includes the wind gust of speed 32mph in the exact
opposite direction of the motor thrust (=)
for 1 second. Note that under such a short duration of wind forces,
the controller can bring the vehicle back to its target pose. However,
due to this particular wind gust, all the thrust loss check conditions
are satisfied and the motor thrust boost is activated. As the wind
gust disappears after 1 second, the motor thrust boost is actually
activated under no wind forces. The boost makes all the motors
to reach their maximum speed. In practice, the attitude angle (roll
and pitch) of the quadrotor during hovering is not perfectly zero all
the time. With this small tilt, the maximum motor speed leads the
vehicle to move suddenly in an unexpected direction (depending
on the attitude angle) leading to a crash or another faulty failure
detection (e.g., GPS glitch due to unexpected sudden displacement,
even when the GPS sensor is normal).
We tested the case in the real world to confirm that the erroneous
behavior actually happens under the reported conditions (wind
(a) Fly with wind gust
(b) Blower and anemometer
Figure 13: Subject quadrotor and wind gust generator
speed 32mph, direction , and duration 1 sec). We can
inject various wind forces with a 56V leaf blower (with a maximum
speed of 125 mph and air volume of 465 cfm), as shown in Figure 13.
In this case, the wind gust is turned off after 1 sec, and the thrust
boost is not supposed to be triggered. However, it is triggered
after the wind gust is off. For the safety issue, we inserted code to
change the mode to Land immediately after triggering thrust boost
function to avoid an accident (i.e., landing instead of full throttle).
The video for the erroneous thrust loss check is available at [39].
5.3.2 APMrover2. We present two under-approximation cases for
APMrover2. Figure 14 shows the simplified code snippet from the
crash checker in APMrover2. It decides whether a crash happens
with multiple if-statements (highlighted in the code). If all the
conditions hold for more than 2 seconds (defined by CRASH_-
CHECK_TRIGGER_SEC), it determines that the current vehicle is
in a crashed state, and the controller initiates motor disarming to
avoid additional damages. The video at [35] shows a normal crash
and detection.
Side Crash into Walls. Our technique reported an under-approximation
vulnerability in which the RV misses the actual crash. The rover per-
forms a “line follow” mission in which it drives forward in a straight
Session 1E: Cyberphysical Systems CCS '20, November 9–13, 2020, Virtual Event, USA273//(m/s)
crash_counter = 0;
return;
//param:45(default)
1 #define CRASH_CHECK_VEL_MIN 0.3
2 #define CRASH_CHECK_THROTTLE_MIN 5.0 //(%)
3 #define CRASH_CHECK_TRIGGER_SEC 2
//(s)
4
5 if(!is_armed() || !is_autopilot_mode()) {
6
7
8 }
9 if({abs(pitch) > crash_angle ||
10
abs(roll) > crash_angle) {
11
crashed = true;
12 }
13 if(groundspeed() >= CRASH_CHECK_VEL_MIN ||
14
15
16
17
18 }19 crash_counter++;
20 if(crash_counter >= CRASH_CHECK_TRIGGER_SEC) {
21
22
23
24 }
ahrs.get_gyro().z >= CRASH_CHECK_VEL_MIN ||
get_throttle()  0.3m/s
after crash) and resets the crash_counter to zero (i.e., no crash).
The video is available at [37].
We have discussion and videos for an over-approximation and
an under-approximation for PX4. Due to the space limitations, they
are placed in the Appendix.
6 RELATED WORK
Many approaches have been proposed for RV testing in different
perspectives [5, 6, 22, 41, 52, 59, 67]. A typical testing approach
is live destructive testing with real vehicles under pre-designed
scenarios (e.g., crash) and requirements. A crash test is one of the
destructive testings. In 2012, Boeing 727 [22] is deliberately crashed
for experiments. Many automotive companies perform different
types of crash tests (e.g., frontal, side, and rollover) with dummies
under government car safety programs (e.g., NCAP [3]). These
real vehicle tests can collect the most accurate data from the real
crashes, but it is not economical and only performed for certain
scenarios. To reduce the cost, virtual tests with simulation, such as
LS-DYNA [6, 59, 67], have been utilized. However, the simulation