The authors would like to thank Jason Franklin for sev-
eral essential suggestions in preparing this work.
References
[1] The British national corpus. Oxford University Computing
Services. Information available at
http://www.natcorp.ox.ac.uk/.
[2] B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich, A. Sa-
hai, S. Vadhan, and K. Yang. On the (Im)possibility of ob-
International Cryptology Conference
fuscating programs.
(CRYPTO), 2001.
[3] J. Bethencourt. The libpaillier library. Available at
http://acsc.csl.sri.com/libpaillier/.
[4] J. Bethencourt and B. Waters. The privss toolkit. Avail-
able at http://acsc.csl.sri.com/privss/.
[5] J. Bethencourt, D. Song, and B. Waters. New techniques for
private stream searching. 2006. Extended abstract appeared
in the IEEE Symposium on Security and Privacy, full version
available at http://www.cs.cmu.edu/˜bethenco/
search.ps.
[6] D. Boneh, E.-J. Goh, and K. Nissim. Evaluating 2-DNF for-
mulas on ciphertexts. Theory of Cryptography Conference
(TCC), 2005.
[7] K. Borders and A. Prakash. Web tap: Detecting covert web
trafﬁc. ACM Conference on Computer and Communications
Security, V. Atluri, B. Pﬁtzmann, and P. D. McDaniel, ed.
ACM, Washington, D.C. October 2004.
[8] K. Borders, X. Zhao, and A. Prakash. Siren: Detecting eva-
IEEE Symposium on Security
sive malware (short paper).
and Privacy, 2006.
[9] C. Cachin, S. Micali, and M. Stadler. Computationally pri-
vate information retrieval with polylogarithmic communica-
tion. Eurocrypt, 1999.
[10] B. Chor, N. Gilboa, and M. Naor. Private information re-
trieval by keywords. Department of Computer Science,
Technion, Technical Report CS0917, 1998.
[28] R. Sion and B. Carbunar. On the computational practical-
ity of private information retrieval. Network and Distributed
System Security Symposium, 2007.
[11] C. Collberg, C. Thomborson, and D. Low. A taxonomy of
obfuscating transformations. Department of Computer Sci-
ences, The University of Auckland, Technical Report 148,
July 1997.
[12] I. Damg˚ard and M. Jurik. A generalisation, a simpliﬁcation
and some applications of Paillier’s probabilistic public-key
system. International Workshop on Practice and Theory in
Public Key Cryptography (PKC), 2001.
[13] T. ElGamal. A public key cryptosystem and a signature
International Cryp-
scheme based on discrete logarithms.
tology Conference (CRYPTO), August 1984.
[14] S. Goldwasser and Y. T. Kalai. On the impossibility of ob-
fuscation with auxiliary input. Symposium on Foundations of
Computer Science, Pittsburgh, Pennsylvania, October 2005.
[15] S. Goldwasser and S. Micali. Probabilistic encryption. Jour-
nal of Computer and System Sciences, 28(2), April 1984.
[16] M. Hirt and K. Sako. Efﬁcient receipt-free voting based on
homomorphic encryption. Eurocrypt, 2000.
[17] A. Kiayias and M. Yung. The vector-ballot e-voting ap-
proach. Financial Cryptography, 2004.
[18] B. Klimt and Y. Yang. Introducing the Enron corpus. Con-
ference on Email and Anti-Spam (CEAS), Corpus available
at http://www.cs.cmu.edu/˜enron/, 2004.
[19] E. Kushilevitz and R. Ostrovsky. Replication is not needed:
Single database, computationally-private information re-
trieval. Symposium on Foundations of Computer Science,
Miami Beach, Florida, October 1997.
[20] R. Murawski. Data exﬁltration techniques: How attackers
steal your sensitive data. Virus Bulletin Conference, October
2006.
[21] J. Newsome, B. Karp, and D. Song. Polygraph: Automat-
ically generating signatures for polymorphic worms. IEEE
Symposium on Security and Privacy, May 2005.
[22] R. Ostrovsky and W. Skeith. Private searching on streaming
data. International Cryptology Conference (CRYPTO), 2005.
[23] R. Ostrovsky and W. E. Skeith, III. A survey of single
database PIR: Techniques and applications. Cryptology
ePrint Archive, Report 2007/059, 2007.
http://eprint.iacr.org/.
[24] R. Ostrovsky and W. E. Skeith, III. Algebraic lower bounds
for computing on encrypted data. Cryptology ePrint Archive,
Report 2007/064, 2007. http://eprint.iacr.org/.
[25] P. Paillier. Public-key cryptosystems based on composite de-
gree residuosity classes. Eurocrypt, 1999.
[26] T. Sander, A. Young, and M. Yung. Non-interactive Crypto-
Computing for N C 1. Symposium on Foundations of Com-
puter Science, New York, New York, October 1999.
[27] R. Singer. Top-tier Israeli ﬁrms suspected of spying on com-
petition. Haaretz Daily News, English Edition, May 2005.
[29] B. Sullivan.
Israel espionage case points to new net
threat. MSNBC News, See http://www.msnbc.msn.
com/id/8145520/, June 2005.
[30] A. Vasudevan and R. Yerraballi. Cobra: Fine-grained mal-
ware analysis using stealth localized-executions. IEEE Sym-
posium on Security and Privacy, 2006.
A Example PIR Scheme
Here we give a very simple example of a private informa-
tion retrieval scheme (from [23]) constructed from a homo-
morphic cryptosystem, placed in the framework of general
public key program obfuscation. We use the Paillier cryp-
tosystem [25], which supports an additive homomorphism
via multiplication of ciphertexts. That is, ∀x1, x2 ∈ P ,
D(E(x1) · E(x2)) = x1 + x2.
Suppose the PIR server stores n database entries, each
considered to a single bit for simplicity. Assume the values
are arranged in a square matrix X = (xij)1≤i,j≤√
n. Now,
in the context of public key obfuscation, we are considering
the class of programs C that read all entries in the database
and return the entry at some predetermined index. Then
Compile and Decrypt may operate as follows:
Compile(M) → Menc, K
Let i0, j0 be the index of the bit that M returns. Gen-
erate a Paillier key pair with private key Kpriv. Next,
compute the vector Q = (qi)1≤i≤√
if i = i0
otherwise.
E(1)
E(0)
n, where
(
qi =
Note that Paillier is a probabilistic cryptosystem, so in
general each qi is distinct. Now let K = (Kpriv, j0)
and deﬁne Menc as follows:
Menc(X) → R
√
For each j ∈ {1, . . .
n}, compute rj =
n
i=1 qxij
. Output R = (r1, r2, . . . r√
n).
Decrypt(Menc(X) = R, K = (Kpriv, j0)) → {0, 1}
Using Kpriv, decrypt rj0 and output the result.
i
Q√
√
nX
To see that Decrypt will produce the correct output, note
that by the homomorphism
D(rj0) =
xij0D(qi) = xi0j0
.
i=1
The hiding property is achieved directly from the seman-
tic security of Paillier encryption, which has in turn been
prv_key
report.pdf
kennedy.jpg
hosta$ privss-qcon illuminati mkultra
hosta$ ls
enc_query
hostb$ ls
enc_query
hostb$ privss-search enc_query enc_res kennedy.jpg
hostb$ privss-search enc_query enc_res report.pdf
hostb$ privss-search enc_query enc_res interview.mp3 sirhan illuminati
hostb$ ls
enc_query
hosta$ ls
enc_query
hosta$ privss-recon enc_query enc_res prv_key
hosta$ ls
enc_query
interview.mp3
interview.mp3
interview.mp3
kennedy.jpg
report.pdf
report.pdf
enc_res
enc_res
prv_key
rfk "robert kennedy"
mkultra "sodium pentothal"
enc_res
prv_key
Figure 3. Example usage session with the privss toolkit.
√
With O(
proven based on the decisional composite residuosity as-
sumption (DCRA).
n) communication, this simple PIR scheme
is inefﬁcient relative to modern schemes. However,
it
serves to illustrate the usage of homomorphic encryption
and shares the general ﬂavor of more advanced schemes.
B The privss Toolkit
The privss toolkit is a general purpose package for
practical usage of a recent private stream searching scheme.
It utilizes a library implementing the Paillier cryptosys-
tem, which we have also made available [3]. A number
of extensions to the basic scheme described in [5] are also
implemented, including the Bloom ﬁlter-based index stor-
age, the technique for reducing the size of the Bloom ﬁlter,
and the method for transparently handling ﬁles of arbitrary
length. The interface of the toolkit is designed for straight-
forward invocation by larger systems in addition to manual
usage. It provides three command line tools. The function-
ality of these tools mirrors the three algorithms described
in [5]: QueryConstruction, StreamSearch, and
FileReconstruction.
privss-qcon
Generates an encrypted query and private key for the
speciﬁed keywords using the
QueryConstruction algorithm.
privss-search
Processes a ﬁle using an encrypted query, creat-
ing or updating a buffer of results according to the
StreamSearch algorithm.
privss-recon
the
private
from
Using
privss-search, recovers the ﬁles which matched
the
the FileReconstruction
buffer
query
using
and
key
a
algorithm.
In the framework of public key obfuscation as described in
Section 2, privss-qcon implements the Compile algo-
rithm, privss-search and the encrypted query would
be bundled together to form Menc, and privss-recon
implements the Decrypt algorithm.
Figure 3 depicts a simple example usage session of the
privss toolkit. First, an encrypted query for the key-
words “illuminati” and “mkultra” is generated on Host A.
The ﬁle enc query is sent to Host B, where it is used
to process three ﬁles, each of which has a list of associ-
ated keywords. The ﬁle enc res is produced. Back on
Host A, it is used with the private key prv key to recon-
struct the ﬁles with keywords matching the query. Note that
the privss-search tool does not attempt to read key-
words directly from the ﬁles. Instead it allows the user (or
higher-level invoking application) to specify keywords ex-
plicitly; in this way a variety of document types may be
handled in application speciﬁc ways. In this example, key-
words for the latter two ﬁles may have been obtained using
the pdftotext and id3info programs.
C Distributed Searches and Worms
Here we consider an additional, somewhat more spec-
ulative usage of PIR techniques in malware: distributed
searches.
If a malware author is seeking a particularly
rare piece of data across a large number of hosts, receiv-
ing results buffers from each individually will incur a large
amount of wasted bandwidth on the receiving host. Since
the receiving host will likely also be a compromised ma-
chine, this will increase the chances of detection and failure
to obtain the desired information.
However, a particular technical property of both private
stream searching schemes to date [22, 5] allows an alterna-
Figure 4. A distributed private search. Hosts Y and Z search two sets of documents in parallel, then host X combines the results.
tive approach. After a buffer of encrypted results has been
initialized for subsequent use with a particular query, the
buffer may be split by simply producing any number of
copies of it. These may be sent to multiple hosts, where
the StreamSearch algorithm (see Appendix B) may be
employed on each to process documents in parallel. Eventu-
ally, the resulting buffers (with contents now diverged from
one another) may be merged back together into a single
buffer of the same size. The resulting buffer may be used
with the FileReconstruction algorithm to obtain the
matching documents from all hosts, just as if the documents
on each host had be processed one after another with a sin-
gle buffer. In short, due to the homomorphism which origi-
nally allows the scheme to function, merging buffers is pos-
sible by simply multiplying the contents of the buffers to-
gether element by element (with minor additional consid-
erations [5]). This process for distributed private searches
is depicted in Figure 4. In step (a), a host X initializes a
buffer for the StreamSearch algorithm and sends copies
to hosts Y and Z. Hosts Y and Z each search their own set
of documents in step (b), before returning their copies of
the buffer to X in step (c). As step (d) host X applies the
homomorphism to obtain a single buffer containing the re-
sults from both Y and Z. At this point, host X may continue
the search by processing its own documents with the buffer.
Note that this process may be applied recursively; host Y for
example can in turn pass the buffer on to further hosts and
merge the results between steps (a) and (b). This pattern of
splitting and merging behavior suggests the possibility of
a private search being conducted by a worm in a tree like
fashion across a very large number of hosts. While this is
a highly speculative scenario, we now give rough calcula-
tions evaluating the feasibility of an extreme example that
may be suited to such a distributed search.
Suppose an attacker wishes to ﬁnd the PGP / GPG pri-
vate key of a speciﬁc individual and furthermore does not
wish to reveal their interest in that individual. Although it’s
not entirely clear when this secrecy would be essential (per-
haps an investigation of a particularly elusive criminal), we
continue the example due to technical interest. The attacker
assumes the key is stored on some workstation used by the
user,7 but does not know the location of the machine or does
not wish to speciﬁcally connect to it, thereby revealing their
intentions. Therefore they decide instead to release a worm
which will attempt to recover the key using the distributed
searching technique shown in Figure 4.
In this scenario, the search could be accomplished while
consuming relatively little bandwidth to and from any sin-
gle host. Suppose one million hosts will be infected by the
worm in all, and assume each host has at most one stored
private key to be searched. Using the scheme of [5] with a
256 KB query, under 1000 false positives should result, and
a results buffer of about 256 KB should sufﬁce to ensure
overﬂow does not occur. We omit the details of these cal-
culations here for brevity; for similar calculations see [5].
Suppose the worm, carrying the encrypted query within it,
infects new hosts in a tree pattern with a branching factor of
k using a precomputed hitlist. In this phase, each host will
receive the 256 KB encrypted query, and send it out to each
subsequent host it infects. Eventually, each leaf host runs
the StreamSearch algorithm on any stored keys discov-
ered, and return its 256 KB results buffer to the host that
infected it. Each non-leaf receives k buffers, merges them,
and recursively returns the result. Thus, overall, each host
uses (k + 1) · 256 KB of outbound bandwidth. With k = 3,
for example, each host would generate a total of 1 MB of
outbound bandwidth, and the infection tree would have a
height of 13. While it is unclear how likely such an attack
is in practice, this type of widespread, distributed private
search forms an intriguing possibility that perhaps deserves
further attention.
7Of course, it would most likely be encrypted with a passphrase, but
after retrieval it could be subjected to an ofﬂine dictionary attack.
XYZ(a) Split.XYZ(b) Parallel search.XYZ(c) Collect results.XYZ(d) Merge.