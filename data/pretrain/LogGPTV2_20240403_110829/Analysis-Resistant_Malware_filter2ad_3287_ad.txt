### Acknowledgments
The authors would like to thank Jason Franklin for his invaluable suggestions in preparing this work.

### References
1. **The British National Corpus**  
   Oxford University Computing Services.  
   Information available at: [http://www.natcorp.ox.ac.uk/](http://www.natcorp.ox.ac.uk/)

2. **On the (Im)possibility of Obfuscating Programs**  
   B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich, A. Sahai, S. Vadhan, and K. Yang.  
   International Cryptology Conference (CRYPTO), 2001.

3. **The Libpaillier Library**  
   J. Bethencourt.  
   Available at: [http://acsc.csl.sri.com/libpaillier/](http://acsc.csl.sri.com/libpaillier/)

4. **The PrivSS Toolkit**  
   J. Bethencourt and B. Waters.  
   Available at: [http://acsc.csl.sri.com/privss/](http://acsc.csl.sri.com/privss/)

5. **New Techniques for Private Stream Searching**  
   J. Bethencourt, D. Song, and B. Waters.  
   Extended abstract appeared in the IEEE Symposium on Security and Privacy, 2006.  
   Full version available at: [http://www.cs.cmu.edu/~bethenco/search.ps](http://www.cs.cmu.edu/~bethenco/search.ps)

6. **Evaluating 2-DNF Formulas on Ciphertexts**  
   D. Boneh, E.-J. Goh, and K. Nissim.  
   Theory of Cryptography Conference (TCC), 2005.

7. **Web Tap: Detecting Covert Web Traffic**  
   K. Borders and A. Prakash.  
   ACM Conference on Computer and Communications Security, V. Atluri, B. Pfitzmann, and P. D. McDaniel, eds.  
   ACM, Washington, D.C., October 2004.

8. **Siren: Detecting Evasive Malware (Short Paper)**  
   K. Borders, X. Zhao, and A. Prakash.  
   IEEE Symposium on Security and Privacy, 2006.

9. **Computationally Private Information Retrieval with Polylogarithmic Communication**  
   C. Cachin, S. Micali, and M. Stadler.  
   Eurocrypt, 1999.

10. **Private Information Retrieval by Keywords**  
    B. Chor, N. Gilboa, and M. Naor.  
    Department of Computer Science, Technion, Technical Report CS0917, 1998.

28. **On the Computational Practicality of Private Information Retrieval**  
    R. Sion and B. Carbunar.  
    Network and Distributed System Security Symposium, 2007.

11. **A Taxonomy of Obfuscating Transformations**  
    C. Collberg, C. Thomborson, and D. Low.  
    Department of Computer Sciences, The University of Auckland, Technical Report 148, July 1997.

12. **A Generalisation, a Simplification and Some Applications of Paillier’s Probabilistic Public-Key System**  
    I. Damgård and M. Jurik.  
    International Workshop on Practice and Theory in Public Key Cryptography (PKC), 2001.

13. **A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms**  
    T. ElGamal.  
    International Cryptology Conference (CRYPTO), August 1984.

14. **On the Impossibility of Obfuscation with Auxiliary Input**  
    S. Goldwasser and Y. T. Kalai.  
    Symposium on Foundations of Computer Science, Pittsburgh, Pennsylvania, October 2005.

15. **Probabilistic Encryption**  
    S. Goldwasser and S. Micali.  
    Journal of Computer and System Sciences, 28(2), April 1984.

16. **Efficient Receipt-Free Voting Based on Homomorphic Encryption**  
    M. Hirt and K. Sako.  
    Eurocrypt, 2000.

17. **The Vector-Ballot E-Voting Approach**  
    A. Kiayias and M. Yung.  
    Financial Cryptography, 2004.

18. **Introducing the Enron Corpus**  
    B. Klimt and Y. Yang.  
    Conference on Email and Anti-Spam (CEAS), 2004.  
    Corpus available at: [http://www.cs.cmu.edu/~enron/](http://www.cs.cmu.edu/~enron/)

19. **Replication is Not Needed: Single Database, Computationally-Private Information Retrieval**  
    E. Kushilevitz and R. Ostrovsky.  
    Symposium on Foundations of Computer Science, Miami Beach, Florida, October 1997.

20. **Data Exfiltration Techniques: How Attackers Steal Your Sensitive Data**  
    R. Murawski.  
    Virus Bulletin Conference, October 2006.

21. **Polygraph: Automatically Generating Signatures for Polymorphic Worms**  
    J. Newsome, B. Karp, and D. Song.  
    IEEE Symposium on Security and Privacy, May 2005.

22. **Private Searching on Streaming Data**  
    R. Ostrovsky and W. Skeith.  
    International Cryptology Conference (CRYPTO), 2005.

23. **A Survey of Single Database PIR: Techniques and Applications**  
    R. Ostrovsky and W. E. Skeith, III.  
    Cryptology ePrint Archive, Report 2007/059, 2007.  
    Available at: [http://eprint.iacr.org/](http://eprint.iacr.org/)

24. **Algebraic Lower Bounds for Computing on Encrypted Data**  
    R. Ostrovsky and W. E. Skeith, III.  
    Cryptology ePrint Archive, Report 2007/064, 2007.  
    Available at: [http://eprint.iacr.org/](http://eprint.iacr.org/)

25. **Public-Key Cryptosystems Based on Composite Degree Residuosity Classes**  
    P. Paillier.  
    Eurocrypt, 1999.

26. **Non-Interactive Crypto-Computing for NC1**  
    T. Sander, A. Young, and M. Yung.  
    Symposium on Foundations of Computer Science, New York, New York, October 1999.

27. **Top-Tier Israeli Firms Suspected of Spying on Competition**  
    R. Singer.  
    Haaretz Daily News, English Edition, May 2005.

29. **Israel Espionage Case Points to New Net Threat**  
    B. Sullivan.  
    MSNBC News, June 2005.  
    Available at: [http://www.msnbc.msn.com/id/8145520/](http://www.msnbc.msn.com/id/8145520/)

30. **Cobra: Fine-Grained Malware Analysis Using Stealth Localized-Executions**  
    A. Vasudevan and R. Yerraballi.  
    IEEE Symposium on Security and Privacy, 2006.

### A. Example PIR Scheme
Here we provide a simple example of a private information retrieval (PIR) scheme, constructed from a homomorphic cryptosystem, within the framework of general public key program obfuscation. We use the Paillier cryptosystem, which supports an additive homomorphism via multiplication of ciphertexts. Specifically, for all \( x_1, x_2 \in \mathbb{P} \), \( D(E(x_1) \cdot E(x_2)) = x_1 + x_2 \).

Suppose the PIR server stores \( n \) database entries, each considered as a single bit for simplicity. Assume the values are arranged in a square matrix \( X = (x_{ij})_{1 \leq i, j \leq \sqrt{n}} \). In the context of public key obfuscation, we consider the class of programs \( C \) that read all entries in the database and return the entry at some predetermined index. The `Compile` and `Decrypt` operations may be defined as follows:

- **Compile(M) → (Menc, K)**
  - Let \( (i_0, j_0) \) be the index of the bit that \( M \) returns.
  - Generate a Paillier key pair with private key \( K_{\text{priv}} \).
  - Compute the vector \( Q = (q_i)_{1 \leq i \leq \sqrt{n}} \), where
    \[
    q_i = 
    \begin{cases} 
    E(1) & \text{if } i = i_0 \\
    E(0) & \text{otherwise}
    \end{cases}
    \]
  - Note that Paillier is a probabilistic cryptosystem, so in general each \( q_i \) is distinct.
  - Let \( K = (K_{\text{priv}}, j_0) \) and define \( M_{\text{enc}} \) as follows:
    - **Menc(X) → R**
      - For each \( j \in \{1, \ldots, \sqrt{n}\} \), compute \( r_j = \prod_{i=1}^{\sqrt{n}} q_i^{x_{ij}} \).
      - Output \( R = (r_1, r_2, \ldots, r_{\sqrt{n}}) \).

- **Decrypt(Menc(X) = R, K = (K_{\text{priv}}, j_0)) → {0, 1}**
  - Using \( K_{\text{priv}} \), decrypt \( r_{j_0} \) and output the result.

To see that `Decrypt` will produce the correct output, note that by the homomorphism:
\[
D(r_{j_0}) = D\left(\prod_{i=1}^{\sqrt{n}} q_i^{x_{ij_0}}\right) = \sum_{i=1}^{\sqrt{n}} x_{ij_0} D(q_i) = x_{i_0 j_0}
\]

The hiding property is achieved directly from the semantic security of Paillier encryption, which has been proven based on the decisional composite residuosity assumption (DCRA). With \( O(\sqrt{n}) \) communication, this simple PIR scheme is inefficient relative to modern schemes. However, it serves to illustrate the usage of homomorphic encryption and shares the general flavor of more advanced schemes.

### B. The privSS Toolkit
The privSS toolkit is a general-purpose package for practical usage of a recent private stream searching scheme. It utilizes a library implementing the Paillier cryptosystem, which we have also made available. Several extensions to the basic scheme described in [5] are implemented, including Bloom filter-based index storage, techniques for reducing the size of the Bloom filter, and methods for transparently handling files of arbitrary length. The interface of the toolkit is designed for straightforward invocation by larger systems, as well as manual usage. It provides three command-line tools, mirroring the three algorithms described in [5]: `QueryConstruction`, `StreamSearch`, and `FileReconstruction`.

- **privss-qcon**: Generates an encrypted query and private key for the specified keywords using the `QueryConstruction` algorithm.
- **privss-search**: Processes a file using an encrypted query, creating or updating a buffer of results according to the `StreamSearch` algorithm.
- **privss-recon**: Recovers the files which matched the query using the `FileReconstruction` algorithm and the private key.

In the framework of public key obfuscation, `privss-qcon` implements the `Compile` algorithm, `privss-search` and the encrypted query form \( M_{\text{enc}} \), and `privss-recon` implements the `Decrypt` algorithm.

Figure 3 depicts a simple example usage session of the privSS toolkit. First, an encrypted query for the keywords "illuminati" and "mkultra" is generated on Host A. The file `enc_query` is sent to Host B, where it is used to process three files, each with a list of associated keywords. The file `enc_res` is produced. Back on Host A, it is used with the private key `prv_key` to reconstruct the files with keywords matching the query. Note that the `privss-search` tool does not attempt to read keywords directly from the files. Instead, it allows the user (or higher-level invoking application) to specify keywords explicitly, enabling the handling of various document types in application-specific ways. In this example, keywords for the latter two files may have been obtained using the `pdftotext` and `id3info` programs.

### C. Distributed Searches and Worms
We consider an additional, somewhat speculative usage of PIR techniques in malware: distributed searches. If a malware author seeks a particularly rare piece of data across a large number of hosts, receiving results buffers from each individually will incur significant bandwidth waste on the receiving host. This increases the chances of detection and failure to obtain the desired information.

However, a specific technical property of both private stream searching schemes to date [22, 5] allows an alternative approach. After a buffer of encrypted results has been initialized for subsequent use with a particular query, the buffer may be split by simply producing any number of copies. These can be sent to multiple hosts, where the `StreamSearch` algorithm may be employed on each to process documents in parallel. Eventually, the resulting buffers (with contents now diverged from one another) may be merged back into a single buffer of the same size. The resulting buffer can be used with the `FileReconstruction` algorithm to obtain the matching documents from all hosts, as if the documents on each host had been processed sequentially with a single buffer.

Due to the homomorphism that allows the scheme to function, merging buffers is possible by simply multiplying the contents of the buffers together element by element (with minor additional considerations [5]). This process for distributed private searches is depicted in Figure 4. In step (a), a host X initializes a buffer for the `StreamSearch` algorithm and sends copies to hosts Y and Z. Hosts Y and Z each search their own set of documents in step (b), before returning their copies of the buffer to X in step (c). In step (d), host X applies the homomorphism to obtain a single buffer containing the results from both Y and Z. At this point, host X may continue the search by processing its own documents with the buffer.

This process may be applied recursively; for example, host Y can pass the buffer on to further hosts and merge the results between steps (a) and (b). This pattern of splitting and merging behavior suggests the possibility of a private search being conducted by a worm in a tree-like fashion across a very large number of hosts. While this is a highly speculative scenario, we provide rough calculations evaluating the feasibility of an extreme example that may be suited to such a distributed search.

Suppose an attacker wishes to find the PGP/GPG private key of a specific individual and does not wish to reveal their interest in that individual. Although it's not entirely clear when this secrecy would be essential, we continue the example due to technical interest. The attacker assumes the key is stored on some workstation used by the user but does not know the location of the machine or does not wish to specifically connect to it, thereby revealing their intentions. Therefore, they decide instead to release a worm that will attempt to recover the key using the distributed searching technique shown in Figure 4.

In this scenario, the search could be accomplished while consuming relatively little bandwidth to and from any single host. Suppose one million hosts will be infected by the worm, and assume each host has at most one stored private key to be searched. Using the scheme of [5] with a 256 KB query, under 1000 false positives should result, and a results buffer of about 256 KB should suffice to ensure overflow does not occur. We omit the details of these calculations here for brevity; for similar calculations, see [5].

Suppose the worm, carrying the encrypted query within it, infects new hosts in a tree pattern with a branching factor of \( k \) using a precomputed hitlist. In this phase, each host will receive the 256 KB encrypted query and send it out to each subsequent host it infects. Eventually, each leaf host runs the `StreamSearch` algorithm on any stored keys discovered and returns its 256 KB results buffer to the host that infected it. Each non-leaf receives \( k \) buffers, merges them, and recursively returns the result. Thus, overall, each host uses \( (k + 1) \cdot 256 \) KB of outbound bandwidth. With \( k = 3 \), for example, each host would generate a total of 1 MB of outbound bandwidth, and the infection tree would have a height of 13. While it is unclear how likely such an attack is in practice, this type of widespread, distributed private search forms an intriguing possibility that perhaps deserves further attention.

7. Of course, the key would most likely be encrypted with a passphrase, but after retrieval, it could be subjected to an offline dictionary attack.

![Distributed Private Search](https://example.com/distributed_search.png)

- **(a) Split**: Host X initializes a buffer and sends copies to Hosts Y and Z.
- **(b) Parallel Search**: Hosts Y and Z each search their own set of documents.
- **(c) Collect Results**: Hosts Y and Z return their copies of the buffer to Host X.
- **(d) Merge**: Host X merges the results to obtain a single buffer.