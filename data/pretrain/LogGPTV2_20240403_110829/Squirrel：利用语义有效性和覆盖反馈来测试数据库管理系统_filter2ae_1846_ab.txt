我们从每个IR中剥离具体数据（如表名），以专注于骨架的变异。 基于IR的突变有效地保留了语法正确性。 一些基于生成的工具从AST生成SQL查询。
但是，由于严格的类型约束和复杂的操作，对AST进行更改与修改SQL查询同样具有挑战性。
**提高语义的正确性：** 由于确保生成的SQL查询的语义正确性被证明是 **NP-hard** 的，因此我们将尝试实际的解决方案以尽可能提高语义正确性。
现有的基于生成的工具定义了一组查询模板。 每个模板代表一个完整的查询，并包含操作数之间的特定静态约束。
但是，由于人力有限，这些框架无法保证其SQL模板的可表达性。 我们通过动态查询实例化解决了这个问题。
给定语法正确的SQL查询的骨架（即没有具体的操作数），我们的方法首先根据预定义的基本规则构建其数据依赖图。
例如，SELECT的操作数可以是FROM中使用的表的列名。 然后，我们尝试用关系满足数据依赖图的具体操作数填充骨架。
通过实例化，语义正确率足以测试DBMS。
## 3 Squirrel概览
> 图2：SQUIRREL概览，Squirrel旨在查找使DBMS崩溃的查询。 Squirrel首先将查询从SQL转换为IR；
> 然后，它使IR突变以生成新骨架。 接着用具体的操作数填充骨架。 最后，它运行新查询并检测错误。
图2概述了我们的DBMS测试框架Squirrel。给定一组正常的SQL查询，Squirrel的目标是查找使DBMS崩溃执行的查询。查询意味着一个测试用例，并且可能包含多个SQL语句。
Squirrel从一个空的数据库开始，并且需要查询来创建内容。
Squirrel通过四个关键组件来实现其目标：Translator，Mutator，Instantiator和SQL
Fuzzer。首先，Squirrel从包含初始查询和保存的有趣查询的队列中选择一个查询。然后，Translator将查询`I`转换为IR的向量`V`。同时，转换器将中的具体值剥离，以使其成为查询框架。我们的Mutator通过插入，删除和替换来产生新的IR向量`'`–`'`在语法上是正确的。接下来，我们的Instantiator执行`'`的数据依赖关系分析，并建立一个数据依赖关系图。然后，Instantiator选择满足数据依赖性的新具体值，并用这些值填充`'`。由于满足了数据依赖性，所以，`'`在语义上可能是正确的。最后，我们将`'`转换回SQL查询`'`并在DBMS中执行`'`查询。如果执行崩溃，我们将找到触发错误的输入。否则，如果`'`触发了程序的新执行路径，我们会将其保存到队列中以进行进一步的变异。
## 4 中间表示
我们设计SQL的中间表示（IR）以支持语法正确的查询变异。 我们将每个查询从SQL转换为IR，对IR进行突变，然后将新的IR转换回SQL查询以执行。
我们对IR的设计旨在实现三个目标：IR可以代表任何SQL语句（ **表达性** ）； 中间表示IR的格式和运作是统一的（ **一般性** ）；
IR和SQL之间的转换非常有效（ **简单性** ）。
IR采用静态单一分配（SSA）形式。 一个查询或测试用例包含一个或多个IR语句。 每个语句都是一个赋值，其中左侧是目标变量，右侧是文字或带操作数的运算符。
我们在IR中添加以下字段以存储必要的信息。
> `ir_type:` 一个IR语句的类型。 此类型基于AST中的相应节点，例如列名称的colum类型或表达式的expr类型。
> 我们还定义了一个特殊类型“Unknown”来表示在AST中没有相应节点的中间语句。
>
> `operator:` 由SQL关键字和数学运算符组成。 它指示IR执行的操作，包括三部分：前缀op_prefix，间缀
> op_mid和后缀op_suffix。 例如，“ CREATE trigger BEGIN list
> END”的IR带有前缀CREATE，间缀BEGIN和后缀END。
>
> `left_operand, right_operand:` IR运算符的操作数。
> 操作数是另一个IR语句，或者操作数是可选的或不需要的话，则可以为NULL。
>
> `data_value:` IR携带的具体数据，例如表名t1。
>
> `data_type:` 数据类型，如ColumnName就代表列名。
我们在附录A中提供了IR语法的正式定义。下面是SQL语句“ **SELECT c2，c6 FROM t1，t2 WHERE t1.c1 = t2.c5**
”的IR示例：
> 图3：执行SQL查询的IR示例。相关的AST语法树见图4.
> 图4：执行示例的AST语法树。Squirrel解析SQL查询并以AST表示它，最后将AST转换为IR。
图3显示了图1中的有效示例的IR（原始查询）。
图4中给出了相应的AST。V1和V4表示列名称c2和c6，它们对应于图4中的节点1和4。它们不包含任何运算符或操作数，但具有ColumnName数据类型和适当的数据值
。 V2和V5定义对列（V1和V4）的引用，而V3和V6创建两个表达式，它们每个只有一个操作数。 V7描述了SELECT的参数列表，包括c2和c6。
V8代表SELECT子句，它可以将DISTINCT作为其左操作数（此处为NULL）。 SELECT出现在左操作数之前，因此它是运算符前缀。
**由于我们的IR最多只允许两个操作数** ，因此我们必须使用两个中间节点Va和Vb连接三个节点8、14和25来构造SelectStmt的IR。
它们的ir_types设置为“Unknown”。 最后，V26定义了SELECT语句，它是图4中的节点26。
我们的IR只是一系列分配语句。 这种线性表示形式不同于树或图形结构（如AST），可帮助开发人员采用统一且简单的突变策略。
我们可以在保持语法正确性的同时执行语句的插入，删除和替换。 我们在附录B中介绍了有关SQL查询和IR之间转换的算法。
## 5 保留语法的变异
我们根据功能将SQL查询中的令牌分为两组。 SQL关键字和数学运算符定义要执行的操作，我们称这些标记为 **结构令牌** 。
其他标记指定已定义操作的目标，我们称它们为 **数据令牌** 。 数据可以是具有基本意义的文字，例如常量1，也可以表示语义，例如表名。
我们观察到，更改结构令牌比更改数据令牌对DBMS执行的影响更大。 差异来自两个原因。
首先，更改结构将更改查询的操作，从而触发不同的功能，而DBMS可能使用相同的逻辑来处理不同的文字数据。 例如，SQLite使用几乎相同的路径来处理
**查询A：“ SELECT c FROM t WHERE c = 1”** 和 **查询B：“ SELECT c FROM t WHERE c =
10”** ，但是使用明显不同的代码来处理 **查询C：“ SELECT c FROM t WHERE c >1“**开始。
其次，随机修改与语义相关的数据很可能会生成一个语义上不正确的查询，DBMS将拒绝执行该查询。 例如，用另一个表中的列替换查询A中的c会导致无效查询。
无论哪种情况，随机数据突变的效率都低于随机结构突变。
因此，我们从查询IR中剥离数据，并将变异主要应用于结构。 我们将在第6部分中讲数据修改。
### 5.1 数据结构分离
我们遍历IR，根据类型为data_type的预定义值替换每个数据。 具体来说，我们将 **语义数据替换为字符串“ x”** ，将
**常数更改为1或1.0** ，并将 **所有字符串更新为“ a”** 。 因此，在分离之后，正在运行的示例“ SELECT t2，c6 FROM
t1，t2 WHERE t1.c1 = t2.c5”变为“ SELECT x，x FROM x，x，WHERE x.x = x.x”。 查询A和B都变为“
SELECT x FROM x WHERE x = 1”，而查询C更改为“ SELECT x FROM x WHERE x> 1”。
**在库中存储IR：** 我们使用称为IR库的字典来存储各种IR。 字典的键是IR类型，而值是IR列表。
一个列表中的IR具有相同的类型，并且其结构完全不同。 例如，分离后，查询A，B和C具有相同的SelectStmt类型，它们应存储在相同的列表中。
我们从列表中删除查询B，因为它与A具有相同的结构。每当我们需要某种类型的IR时，我们都会从字典中找到相应的列表并随机返回一个元素。
在图2中，Squirrel接受种子查询以初始化IR库。 只要Squirrel发现生成的IR具有新结构，我们就会将其添加到库中的相应列表中。
我们对库中IR的最大数量设置了限制，以避免过多的内存使用。
### 5.2 基于类型的变异
我们定义了一组基于类型的突变，以更新IR或IR本身的左右操作数。
我们的突变集中在操作数上，因为IR的其他成员不能轻易更改：该运算符与IR类型密切相关，就像SelectClause
IR中的SELECT运算符一样，而data_type由其在查询中的位置决定，例如“ CREATE TABLE”必须是表名。
因此，我们的突变要么作用于整个IR，要么修改其操作数。 具体来说，对于IR程序中的每个IR : _v_ ，我们都以一定的概率执行以下突变：
> **插入** ：将IR添加到 _v_ 的适当位置。 如果 _v_ 的左孩子节点为空，我们从IR库中随机选择一个与 _v_ 共享相同类型的IR _w_ 。
> 如果 _w_ 的左孩子节点不为空，我们将其用作 _v_ 的左孩子。 相同的操作适用于右孩子节点。
>
> **替换：** 更改 _v_ 或其操作数。 我们首先从IR库中随机选择一个与类型相同的IR _w_ 。 然后，我们将 _w_ 的孩子复制到 _v_
> ，或者将 _v_ 替换为 _w_ ，并将所有 _v_ 的引用更新为 _w_ 。
>
> **删除：** 只需将一个IR– _v_ 替换为一个空的IR即可整体删除它。 可以对其子代执行相同的操作。
由于我们实质上是根据IR的类型来操作IR，因此语法正确性被保留的可能性很高。