Otherwise, R adds this LSA to its LSA database and
Router (R)
{
// f e t c h t h e LSA a t
// r o u t e r ’ s incoming queue
LSA = R. i n q u e u e . dequeue ( )
t h e t o p o f
t h e
i f
( ! R. v a l i d (LSA) )
continue ;
i f (LSA i s newer than one i n R. LSA DB)
{
R. f l o o d (LSA) ;
i f
{
(R. i s s e l f o r i g i n a t e d (LSA) )
R. f l o o d i n g t i m e r = m i n L S I n t e r v a l ;
FB LSA = R. g e n e r a t e f i g h t b a c k ( ) ;
// r e p l a c e e x i s t i n g queued f i g h t −b a c k
// w i t h t h e new one .
i f
(R. f l o o d i n g q u e u e . s i z e ( ) > 0 )
R. f l o o d i n g q u e u e . dequeue ( )
R. f l o o d i n g q u e u e . enqueue (FB LSA) ;
}
e l s e
{
R. LSA DB . update (LSA)
;
R. c a l c R T f l a g = True ;
}
}
i f (R. f l o o d i n g t i m e r == 0 )
{
(R. f l o o d i n g q u e u e . s i z e ( ) > 0 )
LSA = R. f l o o d i n g q u e u e . dequeue ( )
R. f l o o d (LSA) ;
i f
{
}
}
R. R o u t i n g T a b l e C a l c u l a t i o n ( ) ;
}
triggers the routing table calculation. The calculation logic
must be modeled since not every LSA installed in the LSA
database of a router eventually aﬀects that router’s routing
table.
6.1.4 The routing table calculation
To keep the model compact, we do not model the en-
tire routing table calculation logic. We are not interested
in modeling the calculated routing table, but only the func-
tionality that determines which LSAs will ultimately aﬀect
it. We start by considering R as reachable (it is the root of
its shortest path’s tree). Then, a lookup for R’s LSA in its
database is performed using the Link State ID ﬁeld. Note
that the fetched LSA may be either a valid LSA of R or a
malicious LSA crafted by the attacker in a previous stage.
For each advertised link in the fetched LSA, let W denote
the neighbor on the other side of that link. If an LSA for
W is found and contains a link back to R, then R’s LSA is
Listing 4: The routing table calculation procedure
R o u t i n g T a b l e C a l c u l a t i o n ( )
{
i f
( ! c a l c R T f l a g )
continue ;
c a l c R T f l a g = F a l s e ;
//R i s
R. r e a c h a b l e = True ;
t h e c u r r e n t
r o u t e r
f o r e v e r y V where V. r e a c h a b l e == True
{
// l o o k u p i n an a r b i t r a r y o r d e r w i t h i n
LSA d a t a b a s e f o r V ’ s LSA
V LSA = DB lookup (V)
;
f o r e v e r y l i n k L i n V LSA
{
W = L . n e i g h b o r ;
W LSA = DB lookup (W) ;
i f
{
(W LSA has
l i n k back t o V)
//V LSA a f f e c t s
V LSA . mark = True ;
W. r e a c h a b l e = True ;
t h e r o u t i n g t a b l e
}
}
}
f o r ( e v e r y Summary−LSA i n LSA DB)
{
i f
(LSA . A d v e r t i s i n g R o u t e r . r e a c h a b l e ==
True )
//LSA a f f e c t s
LSA . mark = True ;
t h e r o u t i n g t a b l e
}
}
marked and W is considered reachable in the shortest path
tree. This loop is executed for every reachable router.
According to the OSPF standard, a Summary-LSA in-
stalled in the database aﬀects the routing table if and only
if its Advertising Router ﬁeld contains an ID of a reachable
router. Therefore, our model marks such LSAs only if this
condition holds.
6.1.5
Speciﬁcation
We say that an attack is successful if there is an LSA
installed in a router for which all of the following three con-
ditions hold:
1. The LSA was originated by the attacker.
2. The LSA is marked, i.e., it aﬀects the routing table
calculation.
3. The LSA’s counter exceeds MIN COUNTER (where
MIN COUNTER is some large value).
The last condition ensures that the attack is persistent,
i.e., it is not reverted by the ﬁght-back mechanism. The
MIN COUNTER is a predeﬁned constant that determines
the persistency of the attack. In our model, when an LSA
that was originated by the attacker replaces an older in-
stance of that LSA which was also originated by the at-
tacker, then the counter value of the older LSA is copied to
that of the newer one. This allows our model to ﬁnd attacks
in which the false LSA’s instances are constantly changed
by the attacker. These are also considered persistent at-
tacks since the attacker has an uninterrupted eﬀect on the
routing table.
This speciﬁcation is coded as an assertion in the model’s
main loop. If the model checker ﬁnds a state of the model
which violates this assertion, then it must be the case that
the attacker managed to persistently aﬀect the routing table
calculation while evading the ﬁght-back mechanism.
6.2 Results
We implemented the above model in C and used the CBMC
tool [7] to perform the model checking. The CBMC tool is a
bounded model checker that receives a C program as input.
It can check whether all possible execution paths (loops are
checked up to some bound) of the C program satisfy an as-
sertion by translating the C program into a SAT formula
and by checking whether it is satisﬁable using a SAT solver.
It is also possible to add assumptions within the program
in order to check only a subset of the execution paths that
satisfy the assumptions.
6.2.1 Attacks found in our model
By running the model checker with our OSPF model im-
plementation, we recreated the following attacks:
1. The disguised LSA attack was found, where the at-
tacker sent two LSAs – a trigger LSA and a disguised
LSA. This attack was also found on the original model
from [5] without the extensions added here.
2. The periodic injection attack – where the attacker peri-
odically sent LSAs on behalf of some router at a higher
rate than MinLSInterval. Each LSA sent by the at-
tacker had a sequence number greater than the pre-
vious one. Therefore, the delayed ﬁght-back was also
replaced and delayed for each new instance. Conse-
quently, a sequence of malicious LSAs were present in
the victim’s LSA database more than MIN COUNTER
cycles, and the ﬁght-back was never sent due to reset
of the ﬂooding timer with every received false LSA.
3. An attack that exploits the new vulnerability was found
in our manual analysis stage. The output contained an
execution path that described the above attack, where
the LSA sent by the attacker was a Router-LSA having
a Link State ID equal to the victim’s ID but having a
diﬀerent value for the Advertising Router.
6.2.2 Correcting the vulnerabilities in the model
The CBMC model checker halts after it ﬁnds the ﬁrst
counterexample for the assertion in our model. Therefore,
in order to ﬁnd new vulnerabilities, we had to correct the
ones found above.
1. In order to avoid receiving the disguised LSA attack,
we changed the condition that triggers the ﬁght-back
mechanism, such that not only newer self-originated
LSA instances will trigger it, but also instances that
are considered identical to the LSA in the database,
and were actually originated by the attacker. In that
case the disguised LSA will also trigger a ﬁght-back.
[6] Satish Chandra, Patrice Godefroid, and Christopher
Palm. Software model checking in practice: An
industrial case study. In Proceedings of the 24th
International Conference on Software Engineering,
ICSE ’02, pages 431–441, 2002.
[7] Edmund Clarke, Daniel Kroening, and Flavio Lerda.
A tool for checking ANSI-C programs. In Kurt Jensen
and Andreas Podelski, editors, Tools and Algorithms
for the Construction and Analysis of Systems, volume
2988, pages 168–176. 2004.
[8] R. Coltun, D. Ferguson, J. Moy, and A. Lindem.
OSPF for IPv6. IETF RFC 5340, July 2008.
[9] Edsger. W. Dijkstra. A note on two problems in
connexion with graphs. Numerische Mathematik,
1:269–271, 1959.
[10] B. Fortz. On the evaluation of the reliability of OSPF
routing in IP networks. Technical report, Institut
d’administration et de gestion, 2001.
[11] E. Jones and O. Le Moigne. OSPF Security
Vulnerabilities Analysis. Internet-Draft
draft-ietf-rpsec-ospf-vuln-02, IETF, June 2006.
[12] Felix Lindner. Cisco IOS router exploitation. In Black
Hat USA, 2009.
[13] S. U. R. Malik, S. K. Srinivasan, S. U. Khan, and
L. Wang. A methodology for OSPF routing protocol
veriﬁcation. In Proceedings of the 12th International
Conference on Scalable Computing and
Communications (ScalCom), 2012.
[14] P. Matousek, J. R´ab, O. Rysavy, and M. Sv´eda. A
formal model for network-wide security analysis. In
Proceedings of ECBS 2008., pages 171–181, 2008.
[15] J. Moy. OSPF version 2. IETF RFC 2328, April 1998.
[16] Gabi Nakibly, Alex Kirshon, Dima Gonikman, and
Dan Boneh. Persistent OSPF attacks. In Proceedings
of NDSS, 2012.
[17] Corina Pasareanu, Matthew Dwyer, and Michael
Huth. Assume-guarantee model checking of software:
A comparative case study. In Theoretical and Practical
Aspects of SPIN Model Checking, volume 1680, pages
168–183. 1999.
[18] Feiyi Wang, Brian Vetter, and Shyhtsun Felix Wu.
Secure Routing Protocols: Theory and Practice.
Technical report, North Carolina State U., May 1997.
[19] S. F. Wu, H. C. Chang, F. Jou, F. Wang, F. Gong,
C. Sargor, D. Qu, and R. Cleaveland. Jinao: Design
and implementation of a scalable intrusion detection
system for the OSPF routing protocol. ACM
Transactions on Computer Systems, 2:251–273.
2. In order to avoid receiving the periodic injection at-
tack, we set the MinLSInterval to 0. In that case the
ﬁght-back is not delayed thus the attack cannot be
persistent.
3. In order to avoid receiving the new attack, we added
an assumption that during LSA generation by the at-
tacker, the Link State ID ﬁeld must equal the Adver-
tising Router ﬁeld. As noted above, this condition was
actually used in the patches released by most vendors
who were found vulnerable to the attack.
We reran CBMC on the corrected model and no new at-
tacks were found. This indicates that, once the above con-
ditions are enforced, an attacker will not be able to craft
a malicious LSA such that it will not trigger the ﬁght-back
mechanism while still aﬀecting the routing table calculation.
Nonetheless, we note that model checking is only as good
as the model itself. The above result cannot be considered
“proof” that no further weaknesses exist in OSPF in general
since we omitted details of OSPF operation that are not
relevant to the ﬁght-back mechanism. Moreover, since we
used a bounded model checker, namely one that does not
explore all the states of the model, the above result cannot
be considered “proof” that no other weaknesses in the ﬁght-
back mechanism exist. Nonetheless, we believe this result
provides a strong indication that there are no additional
weaknesses in this mechanism.
7. CONCLUSIONS
We present a systematic security analysis of the OSPF
protocol against ﬁght-back evasion attacks. The analysis
was conducted both manually and by formal veriﬁcation.
We found a persistent new attack on OSPF that exploits
vulnerabilities in the OSPF standard itself. The attack is
the ﬁrst to allow complete poisoning of all routers within
the AS. The attack is successful against OSPF implemen-
tations of some of the most popular router vendors on the
Internet. Then, we proposed three simple mitigation mea-
sures to defend against the attack. Using model checking,
we sought other persistent attacks that aim to evade the
ﬁght-back mechanism. The results gives an indication that
once the known weaknesses are mitigated no other weakness
in the ﬁght-back mechanism exists.
The general lesson one may draw from this security analy-
sis is that a defense mechanism must always be fully aligned
with the functionality that it protects. The slightest mis-
alignment or the tiniest functionality that is left uncovered
jeopardizes the entire functionality.
8. REFERENCES
[1] Cisco IOS emualtor. http://dynagen.org/.
[2] Full OSPF Model Implementation.
http://pastebin.com/1stZJRhy.
[3] Graphical network emulator. http://www.gns3.net.
[4] Mikrotik Routers and Wireless.
http://www.mikrotik.com/software.html.
[5] Orna Grumberg Adi Sosnovich and Gabi Nakibly.
Finding security vulnerabilities in a network protocol
using parameterized systems. In Proceedings of CAV,
2013.