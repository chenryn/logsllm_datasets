# 编程接口
这个部分描述了 `Lua` 的 C API ， 也就是宿主程序跟 `Lua` 通讯用的一组 C 函数。 所有的 API 函数按相关的类型以及常量都声明在头文件 `lua.h` 中。
虽然我们说的是“函数”， 但一部分简单的 API 是以宏的形式提供的。 除非另有说明， 所有的这些宏都只使用它们的参数一次 （除了第一个参数，那一定是 `Lua` 状态）， 因此你不需担心这些宏的展开会引起一些副作用。
C 库中所有的 `Lua` API 函数都不去检查参数是否相容及有效。 然而，你可以在编译 `Lua` 时加上打开一个宏开关 `LUA_USE_APICHECK` 来改变这个行为。
## 栈
`Lua` 使用一个 虚拟栈 来和 C 互传值。 栈上的的每个元素都是一个 `Lua` 值 （nil，数字，字符串，等等）。
无论何时 `Lua` 调用 C，被调用的函数都得到一个新的栈， 这个栈独立于 C 函数本身的栈，也独立于之前的 `Lua` 栈。 它里面包含了 `Lua` 传递给 C 函数的所有参数， 而 C 函数则把要返回的结果放入这个栈以返回给调用者 （参见 `lua_CFunction`）。
方便起见， 所有针对栈的 API 查询操作都不严格遵循栈的操作规则。 而是可以用一个 索引 来指向栈上的任何元素： 正的索引指的是栈上的绝对位置（从1开始）； 负的索引则指从栈顶开始的偏移量。 展开来说，如果堆栈有 n 个元素， 那么索引 1 表示第一个元素 （也就是最先被压栈的元素） 而索引 n 则指最后一个元素； 索引 -1 也是指最后一个元素 （即栈顶的元素）， 索引 -n 是指第一个元素。
## 栈大小
当你使用 `Lua API` 时， 就有责任保证做恰当的调用。 特别需要注意的是， 你有责任控制不要堆栈溢出。 你可以使用 `lua_checkstack` 这个函数来扩大可用堆栈的尺寸。
无论何时 `Lua` 调用 C ， 它都只保证至少有 `LUA_MINSTACK` 这么多的堆栈空间可以使用。 `LUA_MINSTACK` 一般被定义为 20 ， 因此，只要你不是不断的把数据压栈， 通常你不用关心堆栈大小。
当你调用一个 `Lua` 函数却没有指定要接收多少个返回值时 （参见 `lua_call`）， `Lua` 可以保证栈一定有足够的空间来接收所有的返回值， 但不保证此外留有额外的空间。 因此，在做了一次这样的调用后，如果你需要继续压栈， 则需要使用 `lua_checkstack`。
## 有效索引与可接受索引
`API` 中的函数若需要传入栈索引，这个索引必须是 有效索引 或是 可接受索引。
有效索引 指引用栈内真实位置的索引； 即在 1 到栈顶之间的位置 （`1 ≤ abs(index) ≤ top`）。 通常，一个可能修改该位置的值的函数需要传入有效索引。
除非另有说明， 任何可以接受有效索引的函数同时也接受 伪索引。 伪索引指代一些可以被 `C code` 访问得到 `Lua` 值，而它们又不在栈内。 这用于访问注册表以及 `C` 函数的上值（参见 §[C 闭包](#C 闭包)）。
对于那些只是需要栈中的值（例如查询函数） 而不需要指定一个栈位置的函数， 可以用一个可接受的索引去调用它们。 可接受索引 不仅可以是任何包括伪索引在内的有效索引， 还可以是任何超过栈顶但落在为栈分配出来的空间内的正索引。 （注意 0 永远都不是一个可接受索引。） 除非另有说明，`API` 里的函数都接受可接受索引。
允许可接受索引是为了避免对栈顶以外的查询时做额外的检查。 例如，`C` 函数可以直接查询传给它的第三个参数， 而不用先检查是不是有第三个参数， 即不需要检查 3 是不是一个有效索引。
对于那些以可接受索引调用的函数， 无效索引被看作包含了一个虚拟类型 LUA_TNONE 的值， 这个值的行为和 nil 一致。
## C 闭包
当 C 函数被创建出来， 我们有可能会把一些值关联在一起， 也就是创建一个 C 闭包 （参见 lua_pushcclosure）； 这些被关联起来的值被叫做 上值 ， 它们可以在函数被调用的时候访问的到。
无论何时去调用 C 函数， 函数的上值都可以用伪索引定位。 我们可以用 `lua_upvalueindex` 这个宏来生成这些伪索引。 第一个关联到函数的值放在 `lua_upvalueindex(1) `位置处，依此类推。 使用 `lua_upvalueindex(n)` 时， 若 n 大于当前函数的总上值个数 （但不可以大于 256）会产生一个可接受的但无效的索引。
## 注册表
`Lua` 提供了一个 注册表， 这是一个预定义出来的表， 可以用来保存任何 `C` 代码想保存的 `Lua` 值。 这个表可以用有效伪索引 `LUA_REGISTRYINDEX` 来定位。 任何 `C` 库都可以在这张表里保存数据， 为了防止冲突，你需要特别小心的选择键名。 一般的用法是，你可以用一个包含你的库名的字符串做为键名， 或者取你自己 `C` 对象的地址，以轻量用户数据的形式做键， 还可以用你的代码创建出来的任意 `Lua` 对象做键。 关于变量名，字符串键名中以下划线加大写字母的名字被 `Lua` 保留。
注册表中的整数键用于引用机制 （参见 luaL_ref）， 以及一些预定义的值。 因此，整数键不要用于别的目的。
当你创建了一个新的 `Lua` 状态机， 其中的注册表内就预定义好了几个值。 这些预定义值可以用整数索引到， 这些整数以常数形式定义在 `lua.h` 中。 有下列常数：
- `LUA_RIDX_MAINTHREAD`: 注册表中这个索引下是状态机的主线程。 （主线程和状态机同时被创建出来。）
- `LUA_RIDX_GLOBALS`: 注册表的这个索引下是全局环境。
## C 中的错误处理
在内部实现中，`Lua` 使用了 `C` 的 `longjmp` 机制来处理错误。 （如果你使用 `C++` 编译，`Lua` 将换成异常； 细节请在源代码中搜索 `LUAI_THROW`。） 当 `Lua` 碰到任何错误 （比如内存分配错误、类型错误、语法错误、还有运行时错误） 它都会 抛出一个错误出去； 也就是调用一次长跳转。 在 保护环境 下， `Lua` 使用 `setjmp` 来设置一个恢复点； 任何发生的错误都会跳转到最近的一个恢复点。
如果错误发生在保护环境之外， `Lua` 会先调用 `panic` 函数 （参见 lua_atpanic） 然后调用 abort 来退出宿主程序。 你的 `panic` 函数只要不返回 （例如：长跳转到你在 `Lua` 外你自己设置的恢复点） 就可以不退出程序。
`panic` 函数以错误消息处理器（参见 §2.3）的方式运行； 错误消息在栈顶。 不同的是，它不保证栈空间。 做任何压栈操作前，`panic` 函数都必须先检查是否有足够的空间 （参见 §4.2）。
大多数 `API` 函数都有可能抛出错误， 例如在内存分配错误时就会抛出。 每个函数的文档都会注明它是否可能抛出错误。
在 `C` 函数内部，你可以通过调用 `lua_error` 来抛出错误。
## C 中的让出处理
`Lua` 内部使用 `C` 的 `longjmp` 机制让出一个协程。 因此，如果一个 `C` 函数 `foo` 调用了一个 API 函数， 而这个 API 函数让出了（直接或间接调用了让出函数）。 由于 `longjmp` 会移除 `C` 栈的栈帧， `Lua` 就无法返回到 `foo` 里了。
为了回避这类问题， 碰到 `API` 调用中调用让出时，除了那些抛出错误的 `API` 外，还提供了三个函数： `lua_yieldk`， `lua_callk`，和 `lua_pcallk` 。 它们在让出发生时，可以从传入的 延续函数 （名为 k 的参数）继续运行。
我们需要预设一些术语来解释延续点。 对于从 `Lua` 中调用的 `C` 函数，我们称之为 原函数。 从这个原函数中调用的上面所述的三个 `C` `API` 函数我们称之为 被调函数。 被调函数可以使当前线程让出。 （让出发生在被调函数是 `lua_yieldk`， 或传入 `lua_callk` 或 `lua_pcallk` 的函数调用了让出时。）
假设正在运行的线程在执行被调函数时让出。 当再次延续这条线程，它希望继续被调函数的运行。 然而，被调函数不可能返回到原函数中。 这是因为之前的让出操作破坏了 `C` 栈的栈帧。 作为替代品，`Lua` 调用那个作为被调函数参数给出的 延续函数 。 正如其名，延续函数将延续原函数的任务。
下面的函数会做一个说明：
```lua
int original_function (lua_State *L) {
  ...     /* code 1 */
  status = lua_pcall(L, n, m, h);  /* calls Lua */
  ...     /* code 2 */
}
```
现在我们想允许被 `lua_pcall` 运行的 `Lua` 代码让出。 首先，我们把函数改写成这个样子：
```lua
int k (lua_State *L, int status, lua_KContext ctx) {
  ...  /* code 2 */
}
int original_function (lua_State *L) {
  ...     /* code 1 */
  return k(L, lua_pcall(L, n, m, h), ctx);
}
```
上面的代码中，新函数 k 就是一个 延续函数 （函数类型为 lua_KFunction）。 它的工作就是原函数中调用 lua_pcall 之后做的那些事情。 现在我们必须通知 `Lua` 说，你必须在被 lua_pcall 执行的 `Lua` 代码发生过中断（错误或让出）后， 还得继续调用 k 。 所以我们还得继续改写这段代码，把 lua_pcall 替换成 lua_pcallk：
```lua
 int original_function (lua_State *L) {
   ...     /* code 1 */
   return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
 }
```
注意这里那个额外的显式的对延续函数的调用： `Lua` 仅在需要时，这可能是由错误导致的也可能是发生了让出而需要继续运行，才会调用延续函数。 如果没有发生过任何让出，调用的函数正常返回， 那么 lua_pcallk （以及 lua_callk）也会正常返回。 （当然，这个例子中你也可以不在之后调用延续函数， 而是在原函数的调用后直接写上需要做的工作。）
除了 `Lua` 状态，延续函数还有两个参数： 一个是调用最后的状态码，另一个一开始由 lua_pcallk 传入的上下文 （ctx）。 （`Lua` 本身不使用这个值；它仅仅从原函数转发这个值给延续函数。） 对于 lua_pcallk 而言， 状态码和 lua_pcallk 本应返回值相同，区别仅在于发生过让出后才执行完时，状态码为 LUA_YIELD（而不是 LUA_OK）。 对于 lua_yieldk 和 lua_callk 而言， 调用延续函数传入的状态码一定是 LUA_YIELD。 （对这两个函数，`Lua` 不会因任何错误而调用延续函数。 因为它们并不处理错误。） 同样，当你使用 lua_callk 时， 你应该用 LUA_OK 作为状态码来调用延续函数。 （对于 lua_yieldk， 几乎没有什么地方需要直接调用延续函数， 因为 lua_yieldk 本身并不会返回。）
`Lua` 会把延续函数看作原函数。 延续函数将接收到和原函数相同的 `Lua` 栈，其接收到的 lua 状态也和 被调函数若返回后应该有的状态一致。 （例如， lua_callk 调用之后， 栈中之前压入的函数和调用参数都被调用产生的返回值所替代。） 这时也有相同的上值。 等到它返回的时候，`Lua` 会将其看待成原函数的返回去操作。
## 函数和类型
这里按字母次序列出了所有 C API 中的函数和类型。 每个函数都有一个这样的提示： [-o, +p, x]
对于第一个域，o， 指的是该函数会从栈上弹出多少个元素。 第二个域，p， 指该函数会将多少个元素压栈。 （所有函数都会在弹出参数后再把结果压栈。） x|y 这种形式的域表示该函数根据具体情况可能压入（或弹出） x 或 y 个元素； 问号 '?' 表示 我们无法仅通过参数来了解该函数会弹出/压入多少元素 （比如，数量取决于栈上有些什么）。 第三个域，x， 解释了该函数是否会抛出错误： '-' 表示该函数绝对不会抛出错误； 'e' 表示该函数可能抛出错误； 'v' 表示该函数可能抛出有意义的错误。
### lua_absindex
```lua
int lua_absindex (lua_State *L, int idx);
```
将一个可接受的索引 idx 转换为绝对索引 （即，一个不依赖栈顶在哪的值）。
### lua_Alloc
```lua
typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);
```
`Lua` 状态机中使用的内存分配器函数的类型。 内存分配函数必须提供一个功能类似于 `realloc` 但又不完全相同的函数。 它的参数有 `ud` ，一个由 `lua_newstate` 传给它的指针； `ptr` ，一个指向已分配出来/将被重新分配/要释放的内存块指针； `osize` ，内存块原来的尺寸或是关于什么将被分配出来的代码； `nsize` ，新内存块的尺寸。
如果 `ptr` 不是 `NULL`， `osize` 是 `ptr` 指向的内存块的尺寸， 即这个内存块当初被分配或重分配的尺寸。
如果 `ptr` 是 `NULL`， `osize` 是 `Lua` 即将分配对象类型的编码。 当（且仅当）`Lua` 创建一个对应类型的新对象时， `osize` 是 LUA_TSTRING，LUA_TTABLE，LUA_TFUNCTION， LUA_TUSERDATA，或 LUA_TTHREAD 中的一个。 若 `osize` 是其它类型，`Lua` 将为其它东西分配内存。
`Lua` 假定分配器函数会遵循以下行为：
当 `nsize` 是零时， 分配器必须和 `free` 行为类似并返回 `NULL`。
当 `nsize` 不是零时， 分配器必须和 `realloc` 行为类似。 如果分配器无法完成请求，返回 `NULL`。 `Lua` 假定在 osize >= nsize 成立的条件下， 分配器绝不会失败。
这里有一个简单的分配器函数的实现。 这个实现被放在补充库中，供 luaL_newstate 使用。
```lua
static void *l_alloc (void *ud, void *ptr, size_t osize,
                                           size_t nsize) {
    (void)ud;  (void)osize;  /* not used */
    if (nsize == 0) {
        free(ptr);
        return NULL;
    }
    else
        return realloc(ptr, nsize);
}
```
注意，标准 `C` 能确保 `free(NULL)` 没有副作用， 且 `realloc(NULL,size)` 等价于 `malloc(size)`。 这段代码假定 realloc 在缩小块长度时不会失败。 （虽然标准 `C `没有对此行为做出保证，但这看起来是一个安全的假定。）
### lua_arith
```lua
void lua_arith (lua_State *L, int op);  --  [-(2|1), +1, e]
```
对栈顶的两个值（或者一个，比如取反）做一次数学或位操作。 其中，栈顶的那个值是第二个操作数。 它会弹出压入的值，并把结果放在栈顶。 这个函数遵循 Lua 对应的操作符运算规则 （即有可能触发元方法）。
op 的值必须是下列常量中的一个：
- LUA_OPADD: 加法 (+)
- LUA_OPSUB: 减法 (-)
- LUA_OPMUL: 乘法 (*)
- LUA_OPDIV: 浮点除法 (/)
- LUA_OPIDIV: 向下取整的除法 (//)
- LUA_OPMOD: 取模 (%)
- LUA_OPPOW: 乘方 (^)
- LUA_OPUNM: 取负 (一元 -)
- LUA_OPBNOT: 按位取反 (~)
- LUA_OPBAND: 按位与 (&)
- LUA_OPBOR: 按位或 (|)
- LUA_OPBXOR: 按位异或 (~)
- LUA_OPSHL: 左移 (>)
### lua_atpanic
```lua
lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf); -- [-0, +0, –]
```
设置一个新的 panic 函数，并返回之前设置的那个。 （参见 §4.6）。
### lua_call
> [-(nargs+1), +nresults, e]
```lua
void lua_call (lua_State *L, int nargs, int nresults);
```
调用一个函数。
要调用一个函数请遵循以下协议： 首先，要调用的函数应该被压入栈； 接着，把需要传递给这个函数的参数按正序压栈； 这是指第一个参数首先压栈。 最后调用一下 lua_call； `nargs` 是你压入栈的参数个数。 当函数调用完毕后，所有的参数以及函数本身都会出栈。 而函数的返回值这时则被压栈。 返回值的个数将被调整为 `nresults` 个， 除非 `nresults` 被设置成 LUA_MULTRET。 在这种情况下，所有的返回值都被压入堆栈中。 Lua 会保证返回值都放入栈空间中。 函数返回值将按正序压栈（第一个返回值首先压栈）， 因此在调用结束后，最后一个返回值将被放在栈顶。
被调用函数内发生的错误将（通过 `longjmp` ）一直上抛。
下面的例子中，这行 `Lua` 代码等价于在宿主程序中用 C 代码做一些工作：
```lua
a = f("how", t.x, 14)
```
这里是 `C` 里的代码：
```lua
 lua_getglobal(L, "f");                  /* function to be called */
 lua_pushliteral(L, "how");                       /* 1st argument */
 lua_getglobal(L, "t");                    /* table to be indexed */
 lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
 lua_remove(L, -2);                  /* remove 't' from the stack */
 lua_pushinteger(L, 14);                          /* 3rd argument */
 lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */