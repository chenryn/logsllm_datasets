个指针和一个浮点数做乘法运算是否合法等。编译器所能分析的语义是静态语义（Static
Semantic），所谓静态语文是指在编译期可以确定的语义，与之对应的动态语义（Dynamic
程序员的自我修养一链接、装载与库
---
## Page 68
2.2编译器做了什么
45
Semantic）就是只有在运行期才能确定的语义。
静态语义通常包括声明和类型的匹配，类型的转换，比如当一个浮点型的表达式赋值给
一个整型的表达式时，其中隐含了一个浮点型到整型转换的过程，语义分析过程中需要完成
这个步骤，比如将一个浮点型赋值给一个指针的时候，语义分析程序会发现这个类型不匹配，
编译器将会报错。动态语义一般指在运行期出现的语义相关的问题，比如将0作为除数是一
个运行期语文错误。
经过语义分析阶段以后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐
式转换，语义分析程序会在语法树中插入相应的转换节点，上面描述的语法树在经过语义分
析阶段以后成为如图2-4所示的形式。
Expres
Assigr
Multiplicativ
assion[]
Express
integev
图2-4标识语义后的语法树
可以看到，每个表达式（包括符号和数字）都被标识了类型。我们的例子中几乎所有的
表达式都是整型的，所以无须做转换，整个分析过程很顺利。语义分析器还对符号表里的符
号类型也做了更新。
2.2.4中间语言生成
现代的编译器有着很多层次的优化，往往在源代码级别会有一个优化过程。我们这里所
描述的源码级优化器（SourceCodeOptimizer）在不同编译器中可能会有不同的定义或有
一些其他的差异。源代码级优化器会在源代码级别进行优化，在上例中，细心的读者可能已
经发现，（2+6）这个表达式可以被优化掉，因为它的值在编译期就可以被确定，类似的还
有很多其他复杂的优化过程，我们在这里就不详细描述了，经过优化的语法树如图2-5所示。
程序员的自我修养一链接、装载与库
---
## Page 69
46
第2章编译和链接
Assign
integer
Iduosgng
Expression[]
Expression'
infege
integer
Adoitive
Expressicn
Integer
图2-5优化后的语法树
我们看到（2+6）这个表达式被优化成8，其实直接在语法树上作优化比较困难，所以
源代码优化器往往将整个语法树转换成中间代码（IntermediateCode），它是语法树的序
表示，其实它已经非常接近目标代码了，但是它一般跟目标机器和运行时环境是无关的，比
如它不包含数据的尺寸、变量地址和寄存器的名字等。中间代码有很多种类型，在不同的编
译器中有着不同的形式，比较常见的有：三地址码（Three-address Code）和P-代码
（P-Code）。我们就拿最常见的三地址码来作为例子，最基本的三地址码是这样的：
x = y op z
这个三地址码表示将变量y和z进行op操作以后，赋值给x.这里op操作可以是算数
运算，比如加减乘除等，也可以是其他任何可以应用到y和z的操作。三地址码也得名于此，
因为一个三地址码语句里面有三个变量地址。我们上面的例子中的语法树可以被翻译成三地
址码后是这样的：
t1 = 2 + 6
t2 = index + 4
array[index]t3
t3 = t2 * t1
我们可以看到，为了使所有的操作都符合三地址码形式，这里利用了几个临时变量：1、
2和t3.在三地址码的基础上进行优化时，优化程序会将2+6的结果计算出来，得到t1=6。
然后将后面代码中的t1替换成数字6。还可以省去一个临时变量t3，因为t2可以重复利用。
经过优化以后的代码如下：
t2 = index + 4
t2 = t2 * 8
程序员的自我修养一
一链接、装载与库
---
## Page 70
2.2编译器做了什么
47
array[index] = t2
中间代码使得编译器可以被分为前端和后端，编译器前端负责产生机器无关的中间代
码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，
它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。
2.2.5目标代码生成与优化
源代码级优化器产生中间代码标志着下面的过程都属于编辑器后端。编译器后端主要包
括代码生成器（Code Generator）和目标代码优化器（Target CodeOptimizer）。让我们先
来看看代码生成器。代码生成器将中间代码转换成目标机器代码，这个过程十分依于目标
机器，因为不同的机器有看不同的字长、寄存器、整数数据类型和浮点数数据类型等。对于
上面例子中的中间代码，代码生成器可能会生成下面的代码序列（我们用x86的汇编语言来
表示，并且假设index的类型为int 型，array的类型为int 型数组）：
mov1 index, @ecx
add1 $4, tecx
 value of index to ecx
mull $8, $ecx
:ecx - ecx +4
mov] index, $eax
： ecx = ecx · 8
movl kecx, array(,eax,4): array [index] = ecx
 value of index to eax
最后目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式、使用位移
来代替乘法运算、剔除多余的指令等。上面的例子中，乘法由一条相对复杂的基址比例变址
寻址（Base IndexScale Addressing）的lea 指令完成，随后由一条mov指令完成最后的赋
值操作，这条mov指令的寻址方式与lea是一样的。
nov1
32(, $edx,8)。 $eax
index, $edx
lea1
nov1
teax, array [, $edx, 4)
现代的编译器有着异常复杂的结构，这是因为现代高级编程语言本身非常地复杂，比如
C++语言的定义就极为复杂，至今没有一个编译器能够完整支持C++语言标准所规定的所有
语言特性。另外现代的计算机CPU相当地复杂，CPU本身采用了诸如流水线、多发射、超
标量等诸多复杂的特性，为了支持这些特性，编译器的机器指令优化过程也变得十分复杂。
使得编译过程更为复杂的是有些编译器支持多种硬件平台，即允许编译器编译出多种目标
CPU的代码。比如著名的GCC编译器就几乎支持所有CPU平台，这也导致了编译器的指
令生成过程更为复杂。
经过这些扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化，编译器
忙活了这么多个步骤以后，源代码终于被编译成了目标代码。但是这个目标代码中有一个间
题是：index和array的地址还没有确定。如果我们要把目标代码使用汇编器编译成真正能
够在机器上执行的指令，那么 index和array的地址应该从哪儿得到呢？如果index和array
程序员的自我修养一链接、装载与库
---
## Page 71
48
第2章编译和链接
定义在跟上面的源代码同一个编译单元里面，那么编译器可以为 index 和array 分配空间，
确定它们的地址：那如果是定义在其他的程序模块呢？
这个看似简单的问题引出了我们一个很大的话题：目标代码中有变量定义在其他模块，
该怎么办？事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链
接的时候才能确定。所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文
件，然后由链接器最终将这些目标文件链接起来形成可执行文件。让我们带着这个问题，走
进链接的世界。
2.3
链接器年龄比编译器长
很久很久以前，在一个非常遥远的银河系人们编写程序时，将所有源代码都写在
同一个文件中，发展到后来一个程序源代码的文件长达数百万行，以至于这个地方的
人类已经没有能力维护这个程序了。人们开始寻找新的办法，一场新的软件开发革命
即将爆发···
为了更好地理解计算机程序的编译和链接的过程，我们简单地回顾计算机程序开发的历
史一定会非常有益。计算机的程序开发并非从一开始就有着这么复杂的自动化编译、链接过
程。原始的链接概念远在高级程序语言发明之前就已经存在了，在最开始的时候，程序员（当
时程序员的概念应该跟现在相差很大了）先把一个程序在纸上写好，当然当时没有很高级的
语言，用的都是机器语言，甚至连汇编语言都没有。当程序须要被运行时，程序员人工将他
写的程序写入到存储设备上，最原始的存储设备之一就是纸带，即在纸带上打相应的孔。
这个过程我们可以通过图2-6来看到，假设有一种计算机。它的每条指令是1个字节，
也就是8位。我们假设有一种跳转指令，它的高4位是0001，表示这是一条跳转指令：低4
0 0001 0100
1
2 -
4 1000 0111
3
图2-6纸带与机器指令
程序员的自我修养一链接、装载与库
---
## Page 72
2.3链接器年龄比编译器长
49
位存放的是跳转目的地的绝对地址。我们可以从图2-6中看到，这个程序的第一条指令就是
一条跳转指令，它的目的地址是第5条指令（注意，第5条指令的绝对地址是4）。至于0
和1怎么映射到纸带上，这个应该很容易理解，比如我们可以规定纸带上每行有8个孔位，
每个孔位代表一位，穿孔表示0，未穿孔表示1。
现在问题来了，程序并不是一写好就水远不变化的，它可能会经常被修改。比如我们在
第1条指令之后、第5条指令之前插入了一条或多条指令，那么第5条指令及后面的指令的
位置将会相应地往后移动，原先第一条指令的低4位的数字将需要相应地调整。在这个过程
中，程序员需要人工重新计算每个子程序或跳转的目标地址。当程序修改的时候，这些位置
都要重新计算，十分繁项又耗时，并且很容易出错。这种重新计算各个目标的地址过程被叫
做重定位（Relocation）。
如果我们有多条纸带的程序，这些程序之间可能会有类似的跨纸带之间的跳转，这种程
序经常修改导致跳转目标地址变化在程序拥有多个模块的时候更为严重。人工绑定进行指令
的修正以确保所有的跳转目标地址都正确，在程序规模越来越大以后变得越来越复杂和繁项。
没办法，这种黑暗的程序员生活是没有办法容忍的，先驱者发明了汇编语言，这相比机
器语言来说是个很大的进步。汇编语言使用接近人类的各种符号和标记来帮助记忆，比如指
令采用两个或三个字母的缩写，记住“jmp”比记住0001XXXX是跳转（jump）指令容易得
多了：汇编语言还可以使用符号来标记位置，比如一个符号“divide”表示一个除法子程序
的起始地址，比记住从某个位置开始的第几条指令是除法子程序方便得多，最重要的是，这
种符号的方法使得人们从具体的指令地址中逐步解放出来。比如前面纸带程序中，我们把刚
开始第5条指令开始的子程序命名为“foo”，那么第一条指令的汇编就是：
jmpfoo
当然人们可以使用这种符号命名子程序或跳转目标以后，不管这个“foo”之前插入或
减少了多少条指令导致“foo”目标地址发生了什么变化，汇编器在每次汇编程序的时候会
重新计算“foo”这个符号的地址，然后把所有引用到“foo”的指令修正到这个正确的地址。
整个过程不需要人工参与，对于一个有成百上千个类似的符号的程序，程序员终于摆脱了这
种低级的繁项的调整地址的工作，用一句政治口号来说叫做“极大地解放了生产力”。符号
（Symbol）这个概念随着汇编语言的普及迅速被使用，它用来表示一个地址，这个地址可
能是一段子程序（后来发展成函数）的起始地址，也可以是一个变量的起始地址。
有了汇编语言以后，生产力大大提高了，随之而来的是软件的规模也开始目渐庞大、这
时程序的代码量也已经开始快速地膨胀，导致人们要开始考虑将不同功能的代码以一定的方
式组织起来，使得更加容易阅读和理解，以便于日后修改和重复使用。自然而然，人们开始
将代码按照功能或性质划分，分别形成不同的功能模块，不同的模块之间按照层次结构或其
他结构来组织。这个在现代的软件源代码组织中很常见，比如在C语言中，最小的单位是
程序员的自我修养一链接、装载与库
---
## Page 73
50
第2章编译和链接
变量和函数，若干个变量和函数组成一个模块，存放在一个“e”的源代码文件里，然后这
些源代码文件按照目录结构来组织，在比较高级的语言中，如Java中，每个类是一个基本
的模块，若干个类模块组成一个包（Package），若干个包组合成一个程序。
在现代软件开发过程中，软件的规模往往都很大，动孤数百万行代码，如果都放在一个
模块肯定无法想象，所以现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖
又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、
理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。
在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是
须解决的问题。模块之间如何组合的问题可以归结为模块之间如何通信的问题，最常见的属
于静态语言的C/C++模块之间通信有两种方式，一种是模块间的函数调用，另外一种是模块
间的变量访问。函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以
这两种方式都可以归结为一种方式，那就是模块间符号的引用，模块间依靠符号来通信类似
于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者一
拼接刚好完美组合（见图2-7）.这个模块的拼接过程就是本书的一个主题：链接（Linking）。
Graph.o
User.o (
ogc
NeLO
Fbe.0
Init.o
图2-7模块同拼合
这种基于符号的模块化的一个直接结果是链接过程在整个程序开发中变得十分重要和
突出。我们在本书的后面将可以看到链接器如何将这些编译后的模块链接到一起，最终产生
一个可以执行的程序。
2.4模块拼装一静态链接
程序设计的模块化是人们一直在追求的目标，因为当一个系统十分复杂的时候，我们不
得不将一个复杂的系统逐步分割成小的系统以达到各个突破的目的。一个复杂的软件也如
此，人们把每个源代码模块独立地编译，然后按照须要将它们“组装”起来，这个组装模块
程序员的自我修养一链接、装载与库
---
## Page 74
2.4模块拼装—静态链接
51
的过程就是链接（Linking）。链接的主要内容就是把各个模块之间相互引用的部分都处理好，
使得各个模块之间能够正确地衔接。链接器所要做的工作其实跟前面所描述的“程序员人工
调整地址”本质上没什么两样，只不过现代的高级语言的诸多特性和功能，使得编译器、链
接器更为复杂，功能更为强大，但从原理上来讲，它的工作无非就是把一些指令对其他符号
地址的引用加以修正。链接过程主要包括了地址和空间分配（Address and Storage
Allocation）、符号决议（SymbolResolution）和重定位（Relocation）等这些步骤。
符号决议有时候也被叫做符号绑定（Symbol Binding1、名称绑定（NameBinding）
名称决议（Name Resolution）。基至还有叫做地址绑定（Address Binding）、指令绵
定（Instruction Binding）的，大体上它们的意思都一样，但从细节角度来区分，它们
之间还是存在一定区别的，比如“决议”更倾向于静态链接，而“绑定”更倾向于动
态链接，即它们所使用的范围不一样。在静态链接，我们将统一称为符号决议。
最基本的静态链接过程如图2-8所示。每个模块的源代码文件（如.c）文件经过编译器
编译成目标文件（ObjectFile，一般扩展名为.o或.obj），目标文件和库（Library）一起链接