如此一来，攻击者网站的所有访问者都会自动向票务系统跨域发送GET请求。如果有一个以“a”开头的客户，那么端点将返回200，并且onload函数将会被执行。攻击者的onload处理程序会将另一个脚本加载到DOM中，查询是否有以“aa”开头的客户。如果出现了onerror事件，那说明没有以字母“a”开头的客户，所以攻击者会将另一个脚本加载到DOM中，检查是否有以字母“b”开头的客户。该脚本将一直使用树搜索算法进行搜索，直到返回有效的客户名称为止。
一旦找到了一个客户名称，攻击者就可以使用相同类型的攻击来搜索需要客户名称的其他API端点，并返回其他的信息，
例如，搜索与客户相关联的电子邮件地址的端点。此外，攻击者还可以搜索匹配“*”模式的客户。如果此操作失败，则表示访问者没有访问票务系统的客户搜索的相应权限，所以也就无需发送其他请求了。由于窃取信息的请求是由攻击者站点的访问者发出的，所以攻击可以让所有访问者并行发送请求。如果将这些攻击手法与社会工程电子邮件结合一起，甚至可以从内部引发票务系统信息泄漏事件。
所以，这种攻击不是很牵强，也不需要特殊的条件。
**攻击的必要条件**
简单来说，需要具备以下条件：
1\. 不返回'X-Content-Type-Options：nosniff'HTTP头部，除非内容类型是JavaScript。
2\. 端点必须响应GET请求。
3\. 端点的状态码：200类型响应表示成功，非200类型响应表示失败。
4\. 该信息不可公开获取。
最重要的是，这里除了第一个条件中的JavaScript之外，根本没有提及内容类型。也就是说，这种攻击适用于XML、JSON、图像或任何其他内容。有关该攻击的必要条件的更多详细信息，请参阅防御措施部分。对于渗透测试人员来说，也应该阅读这一节，因为它对某些技巧进行了更加深入的解释。
**防御措施**
要想防御这种攻击，你只需要设法让上面的任意一个必要条件达不到要求就行了。下面，让我们从防御角度来深入讨论这些必要条件。
**必要条件1**
如果网站返回“X-Content-Type-Options：nosniff”HTTP头部的话，那么该攻击就会偃旗息鼓了。所以，最简单的防御措施，就是让它返回这个头部。服务器可以通过nosniff头部告诉浏览器，“当我说将给你时，就意味着这是真的！”。
为什么这个方法能奏效？这是因为，任意类型的文件都可以通过HTTP提供，但是，Web开发人员却并不总是正确地声明相应的文件类型。因此，当浏览器请求JavaScript文件时，内容类型头部可能会说它实际上是HTML。因此，浏览器就会抛出错误消息，直到它尝试将文件解析为JavaScript为止。此时，由于onload函数已经执行，所以任何解析错误都将调用window.onerror函数。如果内容类型未正确声明，nosniff头部的存在就意味着onerror将立即被调用。总是调用onerror就意味着没有发现差异和没有信息损失。如果内容类型是JavaScript，那么nosniff就没有帮助，所以你照样可以发起XSSI攻击。
注意：这只适用于支持nosniff头部的浏览器。IE和Chrome是第一批支持此头部的浏览器。Firefox也声明将要提供相应的支持，具体时间我还不清楚，但我发现Firefox
50已经支持nosniff头部，但是Firefox 45.5仍然没有提供相应的支持。我假设Edge跟IE一样，但我没有亲自测试它们。
**必要条件２**
脚本标签只能用于GET请求。因此，如果端点只接受POST请求，则此攻击就无能为力了。这个要求看似简单，但务必要小心。您可能已经设计了只接收POST请求的API，但您的内容管理系统也许仍然可以接收GET请求.。
**必要条件３**
如果端点始终返回200，那么也就无法从状态码中窃取信息了。但是，状态码的存在，是自有其存在的理由的！
不要仅仅为了阻止这种攻击而简单粗暴地废弃了HTTP协议的核心部分。请改用nosniff头部来阻止该攻击。
虽然固定的HTTP状态码可以阻止这里描述的这种攻击，但是却无法防御其他攻击。例如，顶层的JSON数组就可以解析为JavaScript，尽管顶层的JSON对象无法解析为JavaScript。因此，即使您的端点始终返回200状态码，照样可以创建window.onerror函数，然后根据是否存在解析错误来收集信息。只要把Content-Type头部设置为JSON，利用nosniff头就能阻止这种攻击。
**必要条件４**
如果攻击者能够在自己的浏览器中加载私密信息，那么他就不需要这种攻击了。该攻击主要是设法让用户访问攻击者的域，然后以用户在其他域的权限来获取更多信息，这通常要求用户已经经过了相应的认证。除此之外，如果您的家庭路由器有此漏洞，那么恶意公共站点可以通过它请求脚本，从而导致信息泄漏。
**进一步探讨**
**3XX状态码**
虽然本文没太关注打开重定向和3XX响应，但是它们可能进一步扩展该攻击。到目前为止，重定向到2XX的行为好像跟2XX类似，而重定向到非2XX的行为与非2XX的行为类似。这意味着如果发现打开的重定向，通过检查referer头保护自己的端点，如果启用了重定向的话，就可能会被绕过。这也是一个很好的思路。
**其他标签**
我相信，指向跨域的img标签的行为跟script标签的行为类似。也许在img和script标签中加载资源可能会由于解析差异而导致更多的信息泄露。此外，CSS也值得进一步仔细研究。
**其他属性**
我希望Subresource Integrity会导致进一步的信息泄漏，但它却明智地要求应用CORS了。如果你可以绕过CORS，那么这种攻击将会大放异彩。
我花了大量时间来测试通过onload，onerror和window.onerror获取信息的方法，其实，我们还可以考察其他诸多的属性，因为这可能会发现其他攻击方法，或通过每个请求获取更多的信息。
**结束语**
在加载跨域资源的时候，任何可检测的差异都能提供宝贵的信息。这些信息可能与登录神谕一样微不足道，但也可能与证书一样造成严重的信息泄露（虽然不太可能）。
**防御方：** 内容类型的分歧是各种攻击的常见手段。使用HTTP头部nosniff严格限制内容类型能够减轻这种攻击和其他攻击。这样做的另外一个好处是，
对不当的响应将产生显眼的错误提示，便于人们进行相应的修复工作。
**攻击方：**
人们对于同源策略的理解还不是非常深入，这使它成为bug的一个重要来源。一定要注意查找GET请求中返回的敏感信息，然后看看通过script标签跨域请求信息时，是否可以检测到任何行为的差异。