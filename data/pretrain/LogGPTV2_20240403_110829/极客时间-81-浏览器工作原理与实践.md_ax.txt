### 1. 如果当前任务执行时间过久，会影延迟到期定时器任务的执行在使用 setTimeout的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。我们先看下面这段代码：    function bar() {    console.log('bar')}function foo() {    setTimeout(bar, 0);    for (let i = 0; i ```长任务导致定时器被延后执行]{.reference}```{=html}```从图中可以看到，执行 foo 函数所消耗的时长是 500 毫秒，这也就意味着通过setTimeout 设置的任务会被推迟到 500 毫秒以后再去执行，而设置 setTimeout的回调延迟时间是 0。
### 2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒也就是说在定时器函数里面嵌套调用定时器，也会延长定时器的执行时间，可以先看下面的这段代码：    function cb() { setTimeout(cb, 0); }setTimeout(cb, 0);上述这段代码你有没有看出存在什么问题？你还是可以通过 Performance 来记录下这段代码的执行过程，如下图所示：![](Images/fb42d427e764d52b451b934a24ce398c.png){savepage-src="https://static001.geekbang.org/resource/image/cb/cd/cbb3b2b1ac8eb4752a585df5445412cd.png"}```{=html}```循环嵌套调用 setTimeout]{.reference}```{=html}```上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。下面是[Chromium实现 4毫秒延迟的代码](https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/frame/dom_timer.cc)，你可以看下：    static const int kMaxTimerNestingLevel = 5; // Chromium uses a minimum timer interval of 4ms. We'd like to go// lower; however, there are poorly coded websites out there which do// create CPU-spinning loops.  Using 4ms prevents the CPU from// spinning too busily and provides a balance between CPU spinning and// the smallest possible interval timer.static constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);    base::TimeDelta interval_milliseconds =      std::max(base::TimeDelta::FromMilliseconds(1), interval);   if (interval_milliseconds = kMaxTimerNestingLevel)    interval_milliseconds = kMinimumInterval;   if (single_shot)    StartOneShot(interval_milliseconds, FROM_HERE);  else    StartRepeating(interval_milliseconds, FROM_HERE);所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用setTimeout 来实现 JavaScript 动画就不是一个很好的主意。
### 3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒除了前面的 4毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于1000毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是1000毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。
### 4. 延时执行时间有最大值除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout设置的延迟值大于 2147483647 毫秒（大约 24.8天）时就会溢出，这导致定时器会被立即执行。你可以运行下面这段代码：    function showName(){  console.log(" 极客时间 ")}var timerID = setTimeout(showName,2147483648);// 会被理解调用执行运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于2147483647 毫秒的某个值，那么执行时就没有问题了。
### 5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的this 关键字将指向全局环境，而不是定义时所在的那个对象。这点在前面介绍this 的时候也提过，你可以看下面这段代码的执行结果：    var name= 1;var MyObj = {  name: 2,  showName: function(){    console.log(this.name);  }}setTimeout(MyObj.showName,1000)这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this会被设置为全局 window，如果是严格模式，会被设置为 undefined。那么该怎么解决这个问题呢？通常可以使用下面这两种方法。第一种是将`MyObj.showName`放在匿名函数中执行，如下所示：    // 箭头函数setTimeout(() => {    MyObj.showName()}, 1000);// 或者 function 函数setTimeout(function() {  MyObj.showName();}, 1000)第二种是使用 bind 方法，将 showName 绑定在 MyObj 上面，代码如下所示：    setTimeout(MyObj.showName.bind(MyObj), 1000)
## 总结好了，今天我们就介绍到这里，下面我来总结下今天的内容。-   首先，为了支持定时器的实现，浏览器增加了延时队列。-   其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout    设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。-   最后，在定时器中使用过程中，还存在一些陷阱，需要你多加注意。通过分析和讲解，你会发现函数 setTimeout在时效性上面有很多先天的不足，所以对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案。
## 思考时间今天我们介绍了setTimeout，相信你现在也知道它是怎么工作的了，不过由于使用 setTimeout设置的回调任务实时性并不是太好，所以很多场景并不适合使用setTimeout。比如你要使用 JavaScript 来实现动画效果，函数requestAnimationFrame 就是个很好的选择。那么今天留给你的作业是：你需要网上搜索了解下 requestAnimationFrame的工作机制，并对比 setTimeout，然后分析出 requestAnimationFrame实现的动画效果比 setTimeout 好的原因。欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png){savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}