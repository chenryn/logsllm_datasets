1
0
0
1
0
5
0
n
e
k
o
r
b
l
s
e
p
m
a
s
e
d
o
c
l
l
e
h
S
7Zip
Chrome
Edge
Firefox
iTunes
Photoviewer Notepad++
Powershell
VLC
WinRar
Functions Broken − Code Stripping
Functions Broken − Shredder
1−4
5−8
9−12
>12
1−4
5−8
9−12
>12
Figure 4: Number of shellcode samples broken by code strip-
ping [50] and Shredder. Bar segments denote the distribu-
tion of broken critical API functions in each case.
all invocations of the function use unanticipated argument values,
compared to the set of known arguments that Shredder expects.
As shown in Table 2 (columns “shellcode” and “ROP”), Shredder
is able to break 90–100% of the payloads for most applications.
Especially for ROP payloads, the only cases Shredder is not able to
break all of them are iTunes and VLC. Upon further inspection, this
is because: for iTunes and Reader, there are VirtualAlloc() call
sites that set the executable memory (cid:30)ag, and for VLC, there are
four VirtualProtect() call sites, two of which set the executable
memory (cid:30)ag, and two other in which the arguments are unknown.
5.4.2 Comparison with Code Stripping. We compare the added
bene(cid:27)t of Shredder over code stripping [50] i.e., just removing any
non-imported API functions, by repeating the same experiment,
this time without enforcing any policies to the remaining (imported)
critical API functions. Code stripping alone can break payloads by
prohibiting the use of critical API functions that are needed by the
payload but not by the application.
Figures 4 and 5 show the number of broken shellcode and ROP
payloads, respectively, for code stripping and Shredder. The break-
down in each bar of Figure 4 denotes the number of functions
broken in each case (as shellcode typically uses several API calls).
8Shredder: Breaking Exploits through API Specialization
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
n
e
k
o
r
b
l
s
d
a
o
y
a
p
P
O
R
0
3
5
2
0
2
5
1
0
1
5
0
s
t
n
a
i
r
a
v
e
d
o
c
l
l
e
h
s
n
e
k
o
r
b
f
o
%
0
0
1
0
8
0
6
0
4
0
2
0
7Zip
Chrome
Edge
Firefox
iTunes
Photoviewer Notepad++
Powershell
VLC
WinRar
7zip
Chrome
Edge
Firefox
iTunes
PhotoViewer
Powershell
VLC
Winrar
Code Stripping    
Shredder
Equivalent function classes broken
1−4
5−8
9−12
>13
Figure 5: Number of ROP payloads broken by code strip-
ping [50] and Shredder for 64-bit applications. Shredder
breaks all ROP payloads for eight out of the 10 applications.
Figure 6: Percentage of equivalent shellcode variants broken
by Shredder for 64-bit applications. Bar segments denote the
distribution of broken function classes in each case.
For instance, in the case of Chrome, Shredder blocks all 251 shell-
code samples by breaking up to 14 functions (although the (cid:27)rst
invalid invocation will lead to process termination, here we want
assess how comprehensive the derived policies are). In contrast,
code stripping blocks only about 70% of the shellcode samples. In
all cases Shredder o(cid:29)ers a signi(cid:27)cant bene(cid:27)t over code stripping.
When it comes to ROP payloads, the bene(cid:27)ts of Shredder are
even clearer. Memory-related functions like VirtualAlloc() and
VirtualProtect() are typically used by both legitimate applica-
tions and exploit code, and thus in most cases code stripping cannot
remove them. In contrast, Shredder blocks all 30 ROP payloads in
eight out of the ten applications, 22 of them in one application, and
nine in case of VLC (for reasons we explained earlier). Overall, it is
clear that API specialization achieves better protection than code
stripping alone for both types of payloads, and especially for ROP
payloads, which have become indispensable for modern exploits.
5.4.3 Robustness to Circumvention A(cid:29)empts. The fact that Shred-
der blocks most of the tested payloads in the context of the given
applications does not mean that attackers cannot modify their
shellcode or ROP code so that it conforms to the enforced API spe-
cialization policy. Knowing that Shredder is in place, an attacker
could pick a di(cid:29)erent set of API functions to achieve the same goal.
Although assessing this possibility in general is a challenging task,
due to the multiple combinations of API calls that an attacker could
use for a given task, we attempted to explore it by considering
classes of equivalent functions (or function combinations) that can
achieve the same goal.
For ROP payloads, we focus on functions that aim to give exe-
cute permission to a second-stage shellcode. Given that there are
two main ways to achieve this, we consider the equivalence of
VirtualAlloc() and VirtualProtect(), which (with adequate
code restructuring) could be used interchangeably. Consequently, if
for a given application only one of them is blocked, then attackers
could use the other one in their payloads to circumvent Shredder.
To assess the robustness of Shredder against such a circumvention
attempt, we repeated our evaluation by making the conservative as-
sumption that both functions can be used interchangeably in the 30
ROP payloads. As shown in the rightmost column of Table 2, even
under these unfavorable circumstances, Shredder can still block all
ROP payloads for eight applications. For the rest two, it manages to
block only the single ROP payload that relies on WinExec(), and
the other 29 payloads become usable, as Shredder has managed
to derive policies only for one of the two memory-related func-
tions in those applications. Despite its best-e(cid:29)ort nature, Shredder
still meaningfully raises the bar against exploitation, as in many
cases it considerably restricts the options an attacker has for the
construction of the ROP payload.
For the set of 251 shellcode samples, we derived 14 sets of equiv-
alent functions for di(cid:29)erent types of generic functionality. For ex-
ample, allocating memory with VirtualAlloc() could be replaced
by heapAlloc(), globalAlloc(), localAlloc(), malloc(), or
new(). A detailed list of all such equivalence classes is provided in
Table 7 in the appendix. Given these classes, we create all possible
variants of the 251 shellcode samples in our data set, totalling more
than 23 million samples. Figure 6 shows the percentage of shellcode
variants that Shredder can still block. For most applications, the
numbers are approaching 100%. This stems from the fact that many
of the equivalent functions are rarely used, or when used, they are
restricted by Shredder’s policies.
5.4.4 Real-world Use Case. To demonstrate the bene(cid:27)ts of the at-
tack surface reduction that API specialization o(cid:29)ers, we evaluated
Shredder using a real-world exploit against Chakra, the JavaScript
engine used in Microsoft Edge. The exploit [43] takes advantage
of two vulnerabilities (CVE-2016-7200 and CVE-2016-7201) to gain
code execution on Windows 10, while bypassing all exploit mitiga-
tions incorporated into Edge (at the time the exploit was written),
including: heap spray disruptors, by precisely allocating a mini-
mal amount of memory; ASLR, by leveraging a memory disclosure
vulnerability; export address table (cid:27)ltering (EAF+), by using hard-
coded addresses for critical API functions instead of dynamically
looking them up; and control (cid:30)ow guard (CFG), as well as gadget
chain detectors like kBouncer [55] and ROPGuard [29], by using
only two gadgets to set up a VirtualProtect() call, which is made
through a legitimate wrapper function—conforming this way to the
legitimate control (cid:30)ow graph enforced by CFG’s CFI policy and
avoiding any stack disruption.
9ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Shachee Mishra and Michalis Polychronakis
We veri(cid:27)ed that the above exploit works correctly against Edge
v40.17017.0.0 on Windows 10, and then tested it again with Shred-
der enabled. When the ROP code invoked VirtualProtect() to
give execute permission to the second-stage shellcode, Shredder re-
ported a policy violation and terminated the Edge process. Although
all previous exploit mitigations were bypassed, API specialization
helped as a last-resort measure to block the exploit.
6 LIMITATIONS AND FUTURE WORK
Shredder’s conservative approach, even when call-site-speci(cid:27)c poli-
cies are used, is not able to prevent all attacks. This stems from
the fact that if there is even one call site that cannot be restricted,
then attackers are likely to be able to use it with adequate e(cid:29)ort.
However, as all exploit mitigations, Shredder’s goal is not to provide
a silver bullet solution, but to deprive attackers from the current
unrestricted convenience of using any API function they will, in
any way possible. In doing so, Shredder does not introduce any
measurable overhead, and is fully compatible with existing applica-
tions and exploit mitigations. Consequently, it should be viewed as
a step towards improving the security of a system by limiting the
“latent complexity” that works in favor of attackers [25].
A limitation of our current prototype is that it simply relies on
Microsoft’s Detours [30] framework for library interposition. As dis-
cussed in Section 4.2, this issue can be addressed with adequate en-
gineering e(cid:29)ort by employing a secure function hooking technique,
such as the checkpoint-based approach used in kBouncer [55].
In contrast to code stripping [50], Shredder currently does not
actually remove any code from the address space of the protected
process, but just restricts the use of i) non-imported API functions
(similarly to code stripping), and ii) remaining (i.e., imported) criti-
cal functions, according to the derived policies. Although identify-
ing and removing all code dependencies of a given unused function
(including any non-exported internal functions that are not needed
anymore) is already a challenging problem when source code is
not available [50], in principle, program slicing techniques could be
used to remove parts of unnecessary code from within remaining
functions, according to the derived policies. We leave such more
(cid:27)ne-grained code removal techniques as part of our future work.
7 RELATED WORK
As non-executable memory protections and address space layout
randomization (ASLR) are not enough for the prevention of modern
ROP exploits (due to the proliferation of memory disclosure vulner-
abilities [42, 65]), there has been active research on a wide variety
of additional defenses. Two main approaches that we can identify
include static protection and runtime monitoring techniques.
Approaches of the former type include i) compiler-level tech-
niques for applying control (cid:30)ow integrity (CFI) [2], enforcing the
integrity of code pointers and the stack [41], or protecting indirect
control transfers [45, 53], and ii) binary-level techniques for apply-
ing code diversi(cid:27)cation [54, 72] or various forms of CFI [75, 76]. Run-
time monitoring approaches augment the execution of a process at
various levels (e.g., instruction, system call) to prevent attacks using
various techniques, such as performing anomaly detection by check-
ing for an unusually high frequency of ret instructions [16, 22],
ensuring the integrity of the stack [23], randomizing the locations of
code fragments [35], or preventing illegal indirect transfers [19, 55].
In this section, we focus on the areas of API-level monitoring and
code surface reduction, which are more closely related to our work.
7.1 API-level Monitoring
Monitoring execution at the system call or API level strikes a good
balance in terms of performance (system call or API function invoca-
tions are infrequent, e.g., compared to monitoring at the instruction
level) and analysis accuracy (given that malicious code has to even-
tually interact with the OS). Consequently, similar to Shredder,
many previous defenses rely on system call or API call interception
to perform various types of checks in order to block the execution
of malicious code.
In the front of defending against return-oriented programming
(ROP) exploits, several approaches rely on the idea of performing
runtime checks to identify control (cid:30)ow abnormalities that usually
appear when ROP code is executing. Given that checking all con-
trol (cid:30)ow transfers at runtime introduces a very high performance
overhead, systems like kBouncer [55] and ROPGuard [29] perform
these checks only before the execution of critical API functions.
In particular, kBouncer [55] relies on the Last Branch Record