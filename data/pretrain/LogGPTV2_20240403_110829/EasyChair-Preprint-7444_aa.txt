EasyChair Preprint
№ 7444
LogNG: an Online Log Parsing Method Based on N-Gram
Xiangrui Liu, Shi Ying, Xinquan Ge, Shengkang Hu and Tiangang Li
EasyChair preprints are intended for rapid 
dissemination of research results and are 
integrated with the rest of EasyChair.
February 8, 2022
LogNG: An Online Log Parsing Method Based on N-gram
| 1stXiangrui Liu | 2ndShi Ying | 3rdXinquan Ge | 4thShengkang Hu ||---|---|---|---|
| School of Computer Science |School of Computer Science |School of Computer Science |School of Computer Science |
| Wuhan University |Wuhan University |Wuhan University |Wuhan University |
| Wuhan, China |Wuhan, China |Wuhan, China |Wuhan, China |
| PI:EMAIL |PI:EMAIL |PI:EMAIL |PI:EMAIL |
5thTiangang Li 
School of Computer ScienceSchool of Computer Science 
Wuhan University 
City, Country 
tiangangli@whu.edu.cnAbstract—The first step in automatic log analysis is log parsing. The number of logs exploded with the increase in system size. Manual analysis of logs has become a difficult problem. To solve this problem, we proposed logNG, an online log parsing method based on N-gram that can efficiently parse logs in a streaming manner without the requirement for historical data training. When log messages are input in a stream, we first divide log messages of different lengths into different log groups. We’ll use an intuitive and simple assumption: If continuous multiple different tokens appear between log messages, these log messages belong to different log template. For each log group, we will use N-gram for template matching to further group log messages within our assumption. We evaluate and compare logNG with other log parsers on public data sets. The results of the experiments reveal that logNG can achieve the highest accuracy and efficiency.Index Terms—Log parsing, Online algorithm, N-gram
tainers ”) The position of the dynamic variable in the log template is marked with a wildcard ””.
Log Record Statement 	LOG.info("Got allocated containers " + variable) 
Raw Log 	2015-10-18 18:01:56,916 INFO [RMCommunicator Allocator] 
Message 	org.apache.hadoop.mapreduce.v2.app.rm.RMContainerAllocator: Got allocated containers 1
Log ParsingLog Parsing
Header Information:2015-10-18 18:01:56,916 INFO [RMCommunicator Allocator] org.apache.hadoop.mapreduce.v2.app.rm.RMContainerAllocator:
Date:2015-10-18  Time:18:01:56 Level:916 INFO Process:[RMCommunicator Allocator]
Parsed Log Component:org.apache.hadoop.mapreduce.v2.app.rm.RMContainerAllocator: Content:Got allocated containers 1
Static text:Got allocated containers
I. INTRODUCTION 	Dynamic variable:1I. INTRODUCTION 	Dynamic variable:1
Log Template：Got allocated containers 
Logs play an important role in modern software systems, but mining its value is still a huge challenge [1], [2], [3], [4]. Log parsing is the first step in automatic log analysis. The quality of log parsing greatly affects the downstream tasks of automatic log analysis [5], [6], [7]. The definition of log parsing is to convert unstructured data into structured data [8], [9]. Its purpose is to separate header information (including date, time, level, etc.) and content (including static text and dynamic variables) [10], [11], [12].As shown in “Fig. 1”, when the system is running, a log record statement will generate a raw log message [13], which usually consists of header information and content. The header information is usually composed of date (“2015-10-18”), time (“18:01:56”), level (“916 INFO”) and other parts.Log parsing requires more content (“Got allocated con-tainers”) than the header information which can be filtered out by regular expressions. The content consists of the static text of the log record statement (”“Got allocated containers”) and its designated dynamic variable (“1”). The log template corresponding to this log message is (”“Got allocated con-
Fig. 1. The Log Parsing Process of a Raw Log Message from Hadoop.In this paper, we propose an online automatic log parsing method logNG, which accurately and efficiently parses the raw log messages in a streaming manner. logNG automatically extracts log templates from raw log messages without source code and historical log data.
We evaluated logNG and other log parsers on real log data sets collected by the LogPai team1[14]. logNG achieved the highest results on most of the data sets, and it was also very fast in running time.In general, our work mainly has the following contributions:
• This paper proposes logNG, an online automatic log parsing method. The log messages we input in the form of a stream are divided into different log groups according to their length. For each log group, we use N-gram to further divide log messages for template matching.
11
• Our method not only solves the problem of manually parsing log templates, but also is an online method that does not require collection of historical data for training.• The experimental results on real log data sets prove the accuracy and high efficiency of logNG.
II. RELATED WORKII. RELATED WORK
Rule-based log parsing relies on artificial heuristic rules (basically in the form of regular expressions) to parse logs. However, this approach is not feasible due to rapid develop-ment of log size [15], [16], [17], [18], [19].Log parings based on source code has been supported by some research [20], [21]. However, this method is actually difficult to achieve because of unavailability of source code. 	Log parsing based on data mining does not require source code, but uses various data mining techniques to separate dynamic variables and static text by mining the characteristics in the log [22].LKE [23] is a representative algorithm for log parsing. In this offline parser, log messages are hierarchically clustered using weighted edit distance, and log keys are generated from the generated cluster. The log key corresponds to the log print statement. After the log message is converted to the log key, a finite state automaton is learned from the training log sequence.When the log group is created for the first time, we directly assign the content of the log message to Template. At this time, logNG has not distinguished between static text and dynamic variables. When the next log message comes, we will match it with Template of the existing log group. If the match is successful, logNG will compare Template with this log message. logNG will recognize static text and dynamic variables, and finally update.TemplateID refers to the ID of Template. The log group list is empty at the beginning. There is no log group, and TemplateID value does not exist at this time. When a new log group is generated, logNG assign TemplateID to 1. After that, whenever a new log group appears, logNG will assign a new TemplateID, the value of which is the previous TemplateID plus 1, so that TemplateID value is equivalent to the sequence number of this log group in the log group list. For example, TemplateID in “Fig. 2” is 13, indicating that this is the 13th log group and log template generated and identified by logNG. LogIDList is a list of the log ID. Each log message has a corresponding log ID. When the log message matches the log group, the LogIDList of the log group will add the ID value of the log message. For example, LogIDList in “Fig. 2” is [1,22,56,168,245. ..], this means that log messages with log ID 1, 22, 56, 168, 245, etc. match Template with TemplateID 13.| LogMine [24] is an unsupervised framework. It only scans | Log Group | Log Group List | Log Group | Log Group |
|---|---|---|---|---|
| log messages once and works in an iterative manner to |Log Group |Log Group List |Log Group |Log Group |
| generate a pattern hierarchy that can be extracted from a set |Log Group |Log Group |Log Group |Log Group || of log messages quickly and efficiently High-quality mode, |Log Group |Log Group |Log Group |TemplateID:13  Template:Verification succeeded for  Length:4  LogIDList:[1,22,56,168,245...] |
| which can process millions of log messages in a few seconds. |Log Group |Log Group |Log Group |TemplateID:13  Template:Verification succeeded for  Length:4  LogIDList:[1,22,56,168,245...] |MoLFI [25] is a tool for solving the problem of log message format identification. It reconstructs the problem of log message identification into a multi-objective problem and uses an evolutionary method to solve this problem.
SHISO [26] is an online method of mining log formats and retrieving log types and parameters. It creates a structured tree by using nodes generated from log messages.III. METHODOLOGY