the more likely an attacker is able to reconstruct the distribution
and reveal a taskâ€™s behavior. Therefore, ğœ–ğ‘–-indistinguishability canâ€™t
be guaranteed for an infinite time. For this reason, the ğœ–-Scheduler
should be used with other security measures for comprehensive pro-
tection against scheduler side channels. There exist some security
schemes that work well together in this context. For instance, one
can perform periodic security checks to detect possible intrusions
and anomalies [27]. With such a scheme, the distance between two
security checks can be used as a reference to compute the protection
duration parameter ğ½ğ‘–. Another feasible scheme is the restart-based
mechanism [1, 2] that enforces a reboot once a while. In such a case,
the maximum time to reset the system can be used to compute ğ½ğ‘–.
In both schemes, the adversaryâ€™s attack progress is disrupted once
the corresponding security measure kicks in and the ğœ–-Scheduler
offers further security guarantees from compromise via scheduler
side-channels. It is worth noting that not all attacks can be caught
by intrusion detection alone as system security is complex by its
)
ğœ–ğ‘–
ğœ–ğ‘–
2ğ½ğ‘– Î”ğœ‚ğ‘–
2ğ½ğ‘– Î”ğœ‚ğ‘–
(b) Probability density
(a) Noise scale of Lap(0,
Figure 4: (a) The noise scale of Lap(0,
) at 95ğ‘¡â„ percentile
with Î”ğœ‚ğ‘– = 190ğ‘šğ‘  and varying ğœ–ğ‘– and ğ½ğ‘–. Both axes are dis-
played in a base 10 logarithmic scale. (b) Probability density
of the randomized inter-arrival times for the task ğœğ‘– with
Tğ‘– = {33.33ğ‘šğ‘ , 100ğ‘šğ‘ }. The blue and green lines show the dis-
tribution when the desired period is at 33.33ğ‘šğ‘  and 100ğ‘šğ‘ 
respectively. In this case, ğœ–-Scheduler offers a job-level ğœ–-
indistinguishability for ğœğ‘– with ğœ–ğ‘– = 100, Î”ğœ‚ğ‘– = 190 and ğ½ğ‘– = 16.
very nature. For instance, the network attack demonstrated in Sec-
tion 7 will not be detected by IDS on a system and needs additional
network security that in itself isnâ€™t guaranteed to work. Other side-
channel attacks (e.g., power consumption, EM emanations) will also
not be detected by a regular IDS since attackers do not actually
â€œintrudeâ€ into a system. Whereas using the ğœ–-Schedulers, we can
increase the complexity for would-be attackers and foil all of these
types of attacks. In such a scenario, our model can act as a founda-
tion for RTS designers to evaluate risks and needs to protect against
scheduler side-channels.
Note that ğ½ğ‘– is defined in the number of job instances as each job
arrival draws a random value from the distribution. When the job-
level indistinguishability is considered, each taskâ€™s ğ½ğ‘– is computed
independently so the value can be different across tasks. Let ğœ† be
the protection duration in time, then
desired protection duration
 | ğœ ğ‘— âˆˆ Î“)
(8)
ğ½ğ‘– =
ğœ†
min(Tğ‘–)
(7)
ğ½ğ‘– = max(
ğœ†
min(Tğ‘—)
the smallest period of ğœğ‘–
the smallest period in the task set Î“
Equation 7 offers ğœ–ğ‘–-indistinguishability to ğœğ‘– within ğœ† time. For task-
level indistinguishability, ğ½ğ‘– for all tasks must be equal to offer the
desired indistinguishability guarantee (subject to ğœ–ğ‘–) as calculated
by Equation 8 where ğœ† is a global protection duration in time.
5.4 Choosing Indistinguishability Parameter
With the noise level (Î”ğœ‚ğ‘–) and protection duration (ğ½ğ‘–) determined
for a given task set, ğœ–ğ‘– is the major remaining variable that a system
designer must specify to secure the desired degree of protection.
Ideally, a smaller ğœ–ğ‘– value provides a better indistinguishability by
generating randomized inter-arrival times with larger noise scale.
However, a large noise scale may sometimes be impractical for real-
time applications. Figure 4(a) shows examples of noise scales (the
y-axis, represented by the 95ğ‘¡â„ percentile) with varied ğœ–ğ‘– values (the
x-axis) for a fixed Î”ğœ‚ğ‘– = 190ğ‘šğ‘  and various ğ½ğ‘– settings. It suggests
that an ğœ–ğ‘– value above an order of magnitude can be practical to
most RTS. Figure 4(b) shows an example of the distributions of the
10âˆ’210âˆ’1100101102103i100101102103104105NoiseScaleat95thPercentile(ms)âˆ†Î·i=190Ji11050100020406080100120140160180200Inter-ArrivalTime(ms)0.0000.0020.0040.0060.008ProbabilityDensityFunctionJi=16,âˆ†Î·i=190,i=100Âµ33.3ms100msSession 3A: Side Channel CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea672inter-arrival times for a task that has Tğ‘– = {33.33ğ‘šğ‘ , 100ğ‘šğ‘ } with
Î”ğœ‚ğ‘– = 190ğ‘šğ‘ , ğ½ğ‘– = 16 (with assuming ğœ† = 500ğ‘šğ‘ ) and ğœ–ğ‘– = 100. It
shows how a taskâ€™s inter-arrival times are randomly generated by
an ğœ–-Scheduler in a typical RTS setting.
Nevertheless, a suitable value for ğœ–ğ‘– is highly system-dependent.
Designers must be aware of system parameters (timing, periods,
deadlines, etc.) and dynamics of the RTS. Ultimately, it is up to the
system designer to select a value based on the overall security and
performance goals. This is analogous to the differential privacy
context where designers must be familiar with data and database
parameters before applying their mechanisms. Fortunately, a lot
of information needed for such â€œtuningâ€ is already obtained as
part of the rigorous engineering effort thatâ€™s undertaken during
RTS design [16, 43, 60]. For example, each taskâ€™s acceptable period
range can be determined based on given specifications (e.g., CPU,
memory) and application QoS requirements. The minimum range
of a task must be greater than or equal to its best-case execution
time (a value obtained during the aforementioned design phase).
The maximum range shouldnâ€™t be so large that makes the appli-
cation unusable (based on the desired QoS). We can then leverage
simulation techniques to automate the calculation of suitable pa-
rameters based on (a) desired protection outcomes and (b) average
performance expectations.
Note that all tasks must be assigned an identical ğœ– value to
achieve task indistinguishability while each task can have an inde-
pendent ğœ– value for job indistinguishability.
6 IMPLEMENTATION IN LINUX
We implemented ğœ–-Scheduler in both (a) real-time Linux kernel4
running on Raspberry Pi and (b) an open-source simulation plat-
form5 that we developed. The simulation is used for design space
exploration (Section 8) and the real-time Linux kernel is used for
demonstration with real hardware and applications and also to ana-
lyze overheads. In this section we provide the platform information
(also summarized in Table 5 in Appendix) and an overview of the
implementation in the real-time Linux kernel.
6.1 Platform and Operating System
We used a Raspberry Pi 4 (RPi4) Model B6 development board as
the base platform for our implementation. RPi4 runs a vendor-
supported open-source operating system, Raspbian (a variant of
Debian Linux). We forked the Raspbian kernel and modified it to
implement the proposed ğœ–-Scheduler. Since we focus on the single
core environment in this paper, the multi-core functionality of RPi4
was deactivated by disabling the CONFIG_SMP flag during the Linux
kernel compilation phase. The boot command file was also set with
maxcpus = 1 to further ensure the single core usage.
Real-time Environment. The mainline Linux kernel does not pro-
vide any hard real-time guarantees even with the custom scheduling
policies (e.g., SCHED_FIFO, SCHED_RR, SCHED_DEADLINE). However
the Real-Time Linux (RTL) Collaborative Project7maintains a kernel
(based on the mainline Linux kernel) for real-time purposes. This
4https://github.com/synercys/Epsilon-Scheduler
5https://github.com/synercys/RTS-Schedule-Simulator
6https://www.raspberrypi.org/products/raspberry-pi-4-model-b/.
7https://wiki.linuxfoundation.org/realtime/
patched kernel (known as the PREEMPT_RT) ensures real-time be-
havior by making the scheduler fully preemptable. In this paper, we
use a PREEMPT_RT-patched kernel (4.19.71-rt24+) to enable real-
time functionality. To further enable the fully preemptive function-
ality for the PREEMPT_RT patch, the CONFIG_PREEMPT_RT_FULL
flag was enabled during the kernel compilation phase. Furthermore,
the variable sched_rt_runtime_us was set to âˆ’1 to disable the
throttling of the real-time scheduler. This setting allows the real-
time tasks to use up the entire 100% CPU utilization if required8.
Also, the active coreâ€™s scaling_governor was set to performance
mode to disable dynamic frequency scaling during the experiments.
Vanilla EDF Scheduler. Since Linux kernel version 3.14, an EDF
implementation (i.e., SCHED_DEADLINE) is available in the kernel
code base [21]. Therefore, we used this built-in scheduler as the
baseline EDF implementation and extended it to implement an ğœ–-
Scheduler. In Linux the system call sched_setattr() is invoked
to configure the scheduling policy for a given process. By design,
the EDF scheduler in Linux has the highest priority among all the
supported scheduling policies (e.g., SCHED_NORMAL, SCHED_FIFO
and SCHED_RR). Itâ€™s also worth noting that the Linux kernel main-
tains a separate run queue for SCHED_DEADLINE (i.e., struct dl_rq).
Therefore, it is possible to extend SCHED_DEADLINE while keeping
other scheduling policies untouched.
6.2 Implementation of ğœ–-Scheduler
We implement the ğœ–-Scheduler as a scheduling mode under the
existing SCHED_DEADLINE. The mode can be switched by setting a
custom kernel parameter/proc/sys/kernel/sched_dl_mode. The
ğœ–-Schedulerâ€™s main functionality is implemented in the function
replenish_dl_entity() that is invoked whenever a new job of a
real-time task arrives. In this function, the ğœ–-Scheduler generates
a randomized inter-arrival time based on the Laplace distribution
associated with the current task (described below). The generated
inter-arrival time is used to compute the deadline for the newly ar-
rived job. This value is also used in the function start_dl_timer()
to schedule the arrival of the next job.
Laplace Distribution. ğœ–-Scheduler requires the generation of ran-
dom numbers based on Laplace distribution for obtaining random-
ized inter-arrival times. However, the Linux kernel code is self-
contained (i.e., it does not depend on the standard or any other
C libraries) and thus a random number generator thatâ€™s based on
Laplace distribution is not natively supported. While it is possible
to build such a generator out of the existing random number genera-
tion function get_random_bytes(), the required computations(e.g.,
logarithm calculations) will be costly. Considering that the task set
parameters are fixed at the design stage, the Laplace distributions
needed by each task are fixed and known as well. Therefore, rather
than building a common Laplace distribution-based random num-
ber generator, we may convert each required Laplace distributionâ€™s
percent point function (PPF) into an array and store each of them in
the kernel. Then, a Laplace distribution-based random number can
be drawn by randomly picking (with using get_random_bytes())
a number from the array thatâ€™s associated with the desired Laplace
8This change in system variable settings was mainly configured for the purpose of
experimenting with the ideas of ğœ–-Scheduler only. For most real use-cases, users can
keep this system variable untouched for more flexibility.
Session 3A: Side Channel CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea673Table 1: K-S Test and Average Minimum L2 Distance
Way Points
Min Dist (Meters)
K-S
Irregular
Comparison
ğœ– = 103, vanilla
ğœ– = 10, vanilla
ğœ– = 103, ğœ– = 10
0.016512
0.015882
0.018564
p-val
0.9997
0.9998
0.9982
0.006885
0.009288
N/A
(a) ğœ–-Scheduler (ğœ– = 103)
(b) ğœ–-Scheduler (ğœ– = 10)
Figure 5: The trajectory of the autonomous rover through
predefined way points running under ğœ–-Scheduler. The re-
sult indicates that larger diversification and higher protec-
tion with ğœ– = 10 can result in larger offsets in trajectory. The
worst observed deviations are 0.027ğ‘š and 0.057ğ‘š in the cases
of ğœ– = 103 and ğœ– = 10 respectively, compared to the trajectory
of Vanilla EDF. These deviations are reasonably small and
the autopilot performance is deemed acceptable.
distribution. The details of the aforementioned conversion and the
algorithm for the PPF-based Laplace distribution random number
generator are presented in Appendix B.
While this method allows us to draw a Laplace distribution-based
random number with a cost of a get_random_bytes() call, each
distribution requires some memory to store an array converted
from the PPF. Yet, as demonstrated by our implementation, an u32
(i.e., unsigned int) array storing 100 PPF points (which takes up
to 400 bytes) is sufficient to produce the desired distribution. An
example of the histogram for the generated random inter-arrival
times drawn by the implemented ğœ–-Scheduler in RT Linux for a task
with a target period 100ğ‘šğ‘  can be found in Figure 11 in Appendix.
7 EVALUATION ON REAL APPLICATIONS
In this section we evaluate the ğœ–-Scheduler with using two diverse,