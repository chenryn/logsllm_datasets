the more likely an attacker is able to reconstruct the distribution
and reveal a task’s behavior. Therefore, 𝜖𝑖-indistinguishability can’t
be guaranteed for an infinite time. For this reason, the 𝜖-Scheduler
should be used with other security measures for comprehensive pro-
tection against scheduler side channels. There exist some security
schemes that work well together in this context. For instance, one
can perform periodic security checks to detect possible intrusions
and anomalies [27]. With such a scheme, the distance between two
security checks can be used as a reference to compute the protection
duration parameter 𝐽𝑖. Another feasible scheme is the restart-based
mechanism [1, 2] that enforces a reboot once a while. In such a case,
the maximum time to reset the system can be used to compute 𝐽𝑖.
In both schemes, the adversary’s attack progress is disrupted once
the corresponding security measure kicks in and the 𝜖-Scheduler
offers further security guarantees from compromise via scheduler
side-channels. It is worth noting that not all attacks can be caught
by intrusion detection alone as system security is complex by its
)
𝜖𝑖
𝜖𝑖
2𝐽𝑖 Δ𝜂𝑖
2𝐽𝑖 Δ𝜂𝑖
(b) Probability density
(a) Noise scale of Lap(0,
Figure 4: (a) The noise scale of Lap(0,
) at 95𝑡ℎ percentile
with Δ𝜂𝑖 = 190𝑚𝑠 and varying 𝜖𝑖 and 𝐽𝑖. Both axes are dis-
played in a base 10 logarithmic scale. (b) Probability density
of the randomized inter-arrival times for the task 𝜏𝑖 with
T𝑖 = {33.33𝑚𝑠, 100𝑚𝑠}. The blue and green lines show the dis-
tribution when the desired period is at 33.33𝑚𝑠 and 100𝑚𝑠
respectively. In this case, 𝜖-Scheduler offers a job-level 𝜖-
indistinguishability for 𝜏𝑖 with 𝜖𝑖 = 100, Δ𝜂𝑖 = 190 and 𝐽𝑖 = 16.
very nature. For instance, the network attack demonstrated in Sec-
tion 7 will not be detected by IDS on a system and needs additional
network security that in itself isn’t guaranteed to work. Other side-
channel attacks (e.g., power consumption, EM emanations) will also
not be detected by a regular IDS since attackers do not actually
“intrude” into a system. Whereas using the 𝜖-Schedulers, we can
increase the complexity for would-be attackers and foil all of these
types of attacks. In such a scenario, our model can act as a founda-
tion for RTS designers to evaluate risks and needs to protect against
scheduler side-channels.
Note that 𝐽𝑖 is defined in the number of job instances as each job
arrival draws a random value from the distribution. When the job-
level indistinguishability is considered, each task’s 𝐽𝑖 is computed
independently so the value can be different across tasks. Let 𝜆 be
the protection duration in time, then
desired protection duration
 | 𝜏 𝑗 ∈ Γ)
(8)
𝐽𝑖 =
𝜆
min(T𝑖)
(7)
𝐽𝑖 = max(
𝜆
min(T𝑗)
the smallest period of 𝜏𝑖
the smallest period in the task set Γ
Equation 7 offers 𝜖𝑖-indistinguishability to 𝜏𝑖 within 𝜆 time. For task-
level indistinguishability, 𝐽𝑖 for all tasks must be equal to offer the
desired indistinguishability guarantee (subject to 𝜖𝑖) as calculated
by Equation 8 where 𝜆 is a global protection duration in time.
5.4 Choosing Indistinguishability Parameter
With the noise level (Δ𝜂𝑖) and protection duration (𝐽𝑖) determined
for a given task set, 𝜖𝑖 is the major remaining variable that a system
designer must specify to secure the desired degree of protection.
Ideally, a smaller 𝜖𝑖 value provides a better indistinguishability by
generating randomized inter-arrival times with larger noise scale.
However, a large noise scale may sometimes be impractical for real-
time applications. Figure 4(a) shows examples of noise scales (the
y-axis, represented by the 95𝑡ℎ percentile) with varied 𝜖𝑖 values (the
x-axis) for a fixed Δ𝜂𝑖 = 190𝑚𝑠 and various 𝐽𝑖 settings. It suggests
that an 𝜖𝑖 value above an order of magnitude can be practical to
most RTS. Figure 4(b) shows an example of the distributions of the
10−210−1100101102103i100101102103104105NoiseScaleat95thPercentile(ms)∆ηi=190Ji11050100020406080100120140160180200Inter-ArrivalTime(ms)0.0000.0020.0040.0060.008ProbabilityDensityFunctionJi=16,∆ηi=190,i=100µ33.3ms100msSession 3A: Side Channel CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea672inter-arrival times for a task that has T𝑖 = {33.33𝑚𝑠, 100𝑚𝑠} with
Δ𝜂𝑖 = 190𝑚𝑠, 𝐽𝑖 = 16 (with assuming 𝜆 = 500𝑚𝑠) and 𝜖𝑖 = 100. It
shows how a task’s inter-arrival times are randomly generated by
an 𝜖-Scheduler in a typical RTS setting.
Nevertheless, a suitable value for 𝜖𝑖 is highly system-dependent.
Designers must be aware of system parameters (timing, periods,
deadlines, etc.) and dynamics of the RTS. Ultimately, it is up to the
system designer to select a value based on the overall security and
performance goals. This is analogous to the differential privacy
context where designers must be familiar with data and database
parameters before applying their mechanisms. Fortunately, a lot
of information needed for such “tuning” is already obtained as
part of the rigorous engineering effort that’s undertaken during
RTS design [16, 43, 60]. For example, each task’s acceptable period
range can be determined based on given specifications (e.g., CPU,
memory) and application QoS requirements. The minimum range
of a task must be greater than or equal to its best-case execution
time (a value obtained during the aforementioned design phase).
The maximum range shouldn’t be so large that makes the appli-
cation unusable (based on the desired QoS). We can then leverage
simulation techniques to automate the calculation of suitable pa-
rameters based on (a) desired protection outcomes and (b) average
performance expectations.
Note that all tasks must be assigned an identical 𝜖 value to
achieve task indistinguishability while each task can have an inde-
pendent 𝜖 value for job indistinguishability.
6 IMPLEMENTATION IN LINUX
We implemented 𝜖-Scheduler in both (a) real-time Linux kernel4
running on Raspberry Pi and (b) an open-source simulation plat-
form5 that we developed. The simulation is used for design space
exploration (Section 8) and the real-time Linux kernel is used for
demonstration with real hardware and applications and also to ana-
lyze overheads. In this section we provide the platform information
(also summarized in Table 5 in Appendix) and an overview of the
implementation in the real-time Linux kernel.
6.1 Platform and Operating System
We used a Raspberry Pi 4 (RPi4) Model B6 development board as
the base platform for our implementation. RPi4 runs a vendor-
supported open-source operating system, Raspbian (a variant of
Debian Linux). We forked the Raspbian kernel and modified it to
implement the proposed 𝜖-Scheduler. Since we focus on the single
core environment in this paper, the multi-core functionality of RPi4
was deactivated by disabling the CONFIG_SMP flag during the Linux
kernel compilation phase. The boot command file was also set with
maxcpus = 1 to further ensure the single core usage.
Real-time Environment. The mainline Linux kernel does not pro-
vide any hard real-time guarantees even with the custom scheduling
policies (e.g., SCHED_FIFO, SCHED_RR, SCHED_DEADLINE). However
the Real-Time Linux (RTL) Collaborative Project7maintains a kernel
(based on the mainline Linux kernel) for real-time purposes. This
4https://github.com/synercys/Epsilon-Scheduler
5https://github.com/synercys/RTS-Schedule-Simulator
6https://www.raspberrypi.org/products/raspberry-pi-4-model-b/.
7https://wiki.linuxfoundation.org/realtime/
patched kernel (known as the PREEMPT_RT) ensures real-time be-
havior by making the scheduler fully preemptable. In this paper, we
use a PREEMPT_RT-patched kernel (4.19.71-rt24+) to enable real-
time functionality. To further enable the fully preemptive function-
ality for the PREEMPT_RT patch, the CONFIG_PREEMPT_RT_FULL
flag was enabled during the kernel compilation phase. Furthermore,
the variable sched_rt_runtime_us was set to −1 to disable the
throttling of the real-time scheduler. This setting allows the real-
time tasks to use up the entire 100% CPU utilization if required8.
Also, the active core’s scaling_governor was set to performance
mode to disable dynamic frequency scaling during the experiments.
Vanilla EDF Scheduler. Since Linux kernel version 3.14, an EDF
implementation (i.e., SCHED_DEADLINE) is available in the kernel
code base [21]. Therefore, we used this built-in scheduler as the
baseline EDF implementation and extended it to implement an 𝜖-
Scheduler. In Linux the system call sched_setattr() is invoked
to configure the scheduling policy for a given process. By design,
the EDF scheduler in Linux has the highest priority among all the
supported scheduling policies (e.g., SCHED_NORMAL, SCHED_FIFO
and SCHED_RR). It’s also worth noting that the Linux kernel main-
tains a separate run queue for SCHED_DEADLINE (i.e., struct dl_rq).
Therefore, it is possible to extend SCHED_DEADLINE while keeping
other scheduling policies untouched.
6.2 Implementation of 𝜖-Scheduler
We implement the 𝜖-Scheduler as a scheduling mode under the
existing SCHED_DEADLINE. The mode can be switched by setting a
custom kernel parameter/proc/sys/kernel/sched_dl_mode. The
𝜖-Scheduler’s main functionality is implemented in the function
replenish_dl_entity() that is invoked whenever a new job of a
real-time task arrives. In this function, the 𝜖-Scheduler generates
a randomized inter-arrival time based on the Laplace distribution
associated with the current task (described below). The generated
inter-arrival time is used to compute the deadline for the newly ar-
rived job. This value is also used in the function start_dl_timer()
to schedule the arrival of the next job.
Laplace Distribution. 𝜖-Scheduler requires the generation of ran-
dom numbers based on Laplace distribution for obtaining random-
ized inter-arrival times. However, the Linux kernel code is self-
contained (i.e., it does not depend on the standard or any other
C libraries) and thus a random number generator that’s based on
Laplace distribution is not natively supported. While it is possible
to build such a generator out of the existing random number genera-
tion function get_random_bytes(), the required computations(e.g.,
logarithm calculations) will be costly. Considering that the task set
parameters are fixed at the design stage, the Laplace distributions
needed by each task are fixed and known as well. Therefore, rather
than building a common Laplace distribution-based random num-
ber generator, we may convert each required Laplace distribution’s
percent point function (PPF) into an array and store each of them in
the kernel. Then, a Laplace distribution-based random number can
be drawn by randomly picking (with using get_random_bytes())
a number from the array that’s associated with the desired Laplace
8This change in system variable settings was mainly configured for the purpose of
experimenting with the ideas of 𝜖-Scheduler only. For most real use-cases, users can
keep this system variable untouched for more flexibility.
Session 3A: Side Channel CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea673Table 1: K-S Test and Average Minimum L2 Distance
Way Points
Min Dist (Meters)
K-S
Irregular
Comparison
𝜖 = 103, vanilla
𝜖 = 10, vanilla
𝜖 = 103, 𝜖 = 10
0.016512
0.015882
0.018564
p-val
0.9997
0.9998
0.9982
0.006885
0.009288
N/A
(a) 𝜖-Scheduler (𝜖 = 103)
(b) 𝜖-Scheduler (𝜖 = 10)
Figure 5: The trajectory of the autonomous rover through
predefined way points running under 𝜖-Scheduler. The re-
sult indicates that larger diversification and higher protec-
tion with 𝜖 = 10 can result in larger offsets in trajectory. The
worst observed deviations are 0.027𝑚 and 0.057𝑚 in the cases
of 𝜖 = 103 and 𝜖 = 10 respectively, compared to the trajectory
of Vanilla EDF. These deviations are reasonably small and
the autopilot performance is deemed acceptable.
distribution. The details of the aforementioned conversion and the
algorithm for the PPF-based Laplace distribution random number
generator are presented in Appendix B.
While this method allows us to draw a Laplace distribution-based
random number with a cost of a get_random_bytes() call, each
distribution requires some memory to store an array converted
from the PPF. Yet, as demonstrated by our implementation, an u32
(i.e., unsigned int) array storing 100 PPF points (which takes up
to 400 bytes) is sufficient to produce the desired distribution. An
example of the histogram for the generated random inter-arrival
times drawn by the implemented 𝜖-Scheduler in RT Linux for a task
with a target period 100𝑚𝑠 can be found in Figure 11 in Appendix.
7 EVALUATION ON REAL APPLICATIONS
In this section we evaluate the 𝜖-Scheduler with using two diverse,