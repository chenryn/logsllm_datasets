2018-17182
2018-18559
2018-5703
Type
OOB
OOB
UAF
OOB
double free
UAF
UAF
UAF
UAF
UAF
OOB
UAF
UAF
UAF
UAF
double free
double free
OOB
OOB
UAF
double free
OOB
OOB
OOB
UAF
UAF
OOB
Exploitation Methods
I
5 (1⋆)
13 (1⋆)
-
0 (1)
-
-
-
-
-
-
-
-
-
-
-
-
-
10 (0)
14 (1)
-
-
0 (0)
0 (0)
0 (0)
-
-
0 (0)
II
-
-
1(1⋆)
-
0 (1)
0 (1)
3 (1)
3 (1)
3 (1)
2 (0)
-
3 (1)
3 (1)
3 (1)
0 (0)
-
3 (1)
-
-
3 (1)
4 (1)
-
-
-
0 (0)
3(0)
-
III
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
12 (0)
-
-
-
4 (0)
-
-
-
-
-
-
IV
5 (0)
13 (0)
-
-
-
-
2 (0)
4 (0)
-
-
6 (1)
-
-
-
-
2 (1)
-
10 (0)
14 (0)
-
-
-
-
-
-
-
-
Table 3: Exploitability demonstration and comparison. The
numbers within the parentheses indicate the total amount
of exploits publicly available and those out of the paren-
theses represent the amount of exploits generated through
SLAKE. The star ⋆ denotes the objects used in the public ex-
ploit are not enclosed in the exploits developed through
SLAKE. I ∼ IV indicate the aforementioned exploitation meth-
ods pertaining to OOB, UAF, Double Free and metadata ma-
nipulation, respectively.
exploits, but also pinpoints 22 additional objects that have not yet
been seen to be used for exploitation. To some extent, this implies
the effectiveness of the kernel fuzzing as well as the effectiveness of
SLAKE in terms of helping security researchers track down useful
kernel objects.
6.3 Evaluation of Exploit Development
Comparison between public and SLAKE-generated exploits.
Table 3 shows the number of unique working exploits5 for each of
the kernel vulnerabilities in our dataset.
First, we can observe that, for all 18 vulnerabilities already having
public exploits, SLAKE could always find the data objects and the
corresponding system calls used in that exploit except for the cases
in the first 6 rows. Among all these 18 cases, there are 14 kernel
vulnerabilities, against which SLAKE could also generate alternative
working exploits using other distinct data objects. As we can further
observe, on average, SLAKE could help security researchers develop
8 additional unique exploits. This implies SLAKE could provide a
security researcher with the ability to diversify the way to perform
kernel exploitation.
5As we mentioned in Section 2.1, we demonstrate exploitability through the control
over the program counter. By working exploits, we, therefore, mean the exploits
through which one could obtain control over the program counter. By distinct exploits,
we mean those developed by using different victim or spray or both objects.
In addition, we can observe that, for those vulnerabilities that
have not yet demonstrated exploitability through a public exploit,
SLAKE could still assist security researchers in finding suitable
objects to perform exploitation (e.g., CVE-2016-4557 and CVE-
2017-7184 and CVE-2018-18559). While we cannot conclude un-
exploitability through the lack of a public exploit demonstrating
control flow hijacking, this observation ś to some extent ś implies
that SLAKE could potentially escalate the exploitability for a target
kernel vulnerability.
Some discussion of failure cases. In Table 2, we can also observe,
out of 27 test cases in our dataset, there are 9 vulnerabilities that
SLAKE cannot facilitate the development of their exploits.
As of the vulnerabilities pertaining to CVE-2017-1000112 and
CVE-2018-5703, their PoC programs demonstrate only the capabil-
ity in overwriting data inside the slab/slot pertaining to vulnerable
objects. Under this capability, the exploitation of these vulnerabili-
ties cannot use slab layout manipulation but the overwrite of critical
data within the vulnerable objects. Therefore, the exploitation fa-
cilitation approaches tied to SLAKE cannot be applied to such cases.
This does not dilute the value of SLAKE. This is in part because
the exploitability of such vulnerabilities can be easily determined ś
requiring much expertise and manual efforts ś but largely because
among all the vulnerabilities identified over the past years there are
fewer vulnerabilities that provide attackers with such a capability.
Regarding the vulnerabilities pertaining to CVE-2017-2636, CVE-
2014-2851, and CVE-2018-17182, we found that, in order to perform
an exploitation, we must allocate target objects to a special cache.
From our database, we do not find objects suitable for such caches.
Taking CVE-2014-2851 for example, we discover the vulnerable
object (group_info) of this vulnerability is in a relatively small size
(8 bytes). In our database, we fail to find a spray object that can
be allocated on the cache same as that of the vulnerable object.
In this work, we do not blame our proposed techniques for these
cases because our experiment setup includes only those common
kernel modules. In the real-world kernel images, many other ker-
nel modules are included. They might carry the objects useful for
exploitation.
With respect to vulnerabilities corresponding to CVE-2018-12714,
CVE-2018-16880, CVE-2017-17052, and CVE-2018-10840, their PoC
programs do not demonstrate a sufficient capability to write con-
trollable data to a memory region. Taking CVE-2018-12714 and
CVE-2018-16880 for example, we discover that, by following the
control demonstrated through their PoC programs, an attacker
does not have the freedom to control the value he writes to the
target memory regions. This indicates, the exploitability of these
vulnerabilities is heavily dependent upon the capability of these
vulnerabilities. As we will discuss in Section 7, we will explore
technical approaches to tackle this issue in the future.
7 DISCUSSION & FUTURE WORK
In this section, we discuss some related issues and future work.
Other OSes. To facilitate kernel exploitation, SLAKE utilizes an au-
tomated method to build a database which contains kernel objects
useful for exploitation. In this work, we demonstrate this approach
on Linux kernel. However, this automated approach can also be
applied to facilitate exploitation for other open-source OSes (e.g.,
FreeBSD[11] and Android [33]). For those closed-source OSes like
Windows, when utilizing our proposed approach for object identi-
fication and database construction, one has to devote energies to
binary code reverse engineering.
Other allocators. In addition to a database carrying objects for ex-
ploitation, SLAKE introduces a systematic approach for slab layout
manipulation. To extend this approach to other kernel allocators
(e.g., SLOB allocator [25], buddy system [5]) or those used in user-
land (e.g., ptmalloc[12]), a modification is required. Take ptmalloc
for example. Different from kernel memory management, ptmalloc
might coalesce two freed chunks (like the slot in SLAB/SLUB allo-
cator) into a single one before adding them to bins (like the cache
in SLAB/SLUB allocator) for recycle. In order to customize our ma-
nipulation approach for this allocator, memory manipulation has
to consider the binning and coalescing mechanism of ptmalloc. As
part of our future work, we will therefore explore how to augment
our memory manipulation approach for these different allocators.
Object identification. As is specified in Section 3.1, we deter-
mine a spray object by analyzing the argument of kernel functions
(e.g.,dst of the function copy_from_user(). While this design could
ensure SLAKE identifies most objects useful for heap spray, it could
possibly ignore some special situations. For example, userland data
can be copied first to the kernel stack through a system call and
then migrated to the slab through a kernel function (e.g., memcpy()).
To identify spray objects in this special situation, an accurate inter-
procedural data flow analysis is inevitable. Therefore, as another
part of our future work, we also intend to augment SLAKE with
the ability to perform inter-procedural data flow analysis and thus
handle such special situations.
Other exploitation methods. In addition to the four exploitation
methods discussed in Section 2, security researchers have developed
other approaches for exploiting some special cases (e.g., [16, 21])
as well as heap-based use-before-initialization vulnerability. While
those approaches are not as common as what we discussed in
this paper, by integrating them into SLAKE, we could enrich the
functionality of our technique. As a result, our future effort will
also include extending SLAKE for more exploitation methods.
Vulnerability capability. As is described in Section 2, we manu-
ally extract vulnerability capabilities from a PoC program under
the guidance of debugging tools. Technically speaking, this process
could be potentially automated by using dynamic analysis methods
such as symbolic tracing. Therefore, another line of our future work
will be to explore the automation of this mechanism and enrich
this functionality for SLAKE.
Recall that this work does not explore vulnerability capabilities
not manifested through a PoC program. As is shown in Section 6,
an inadequate capability could limit the exploitability of a vulnera-
bility. We argue vulnerability capability exploration is a non-trivial
problem, which might need the integration of various advanced
techniques in program analysis. Last but not least, our future effort
will therefore include exploring technical approaches to enriching
capabilities for a vulnerability.
8 RELATED WORK
The works most relevant to ours include those pertaining to kernel
exploitation as well as those automating the generation of exploits.
In the following, we describe the existing works in these two kinds
and discuss their difference from ours.
Kernel exploitation techniques. To facilitate heap spray in the
process of kernel Use-After-Free exploitation, Xu et al. proposed
two memory collision attack mechanisms [48]. In one of their at-
tack mechanisms, they employed the memory recycling mechanism
residing in kernel allocator. In another mechanism, they took ad-
vantage of the overlap between the physmap and the SLAB caches.
To facilitate the exploitation of Use-Before-Initialization, Lu et al.
proposed a deterministic stack spraying approach as well as an
exhaustive memory spraying technique [24]. Both provide an at-
tacker with the ability to manipulate data in uninitialized memory
regions. To assist with the process of finding a useful exploitation
primitive (e.g., control-flow hijack or arbitrary write/read), FUZE
[46] proposed an automated technique that utilizes under-context
fuzzing along with symbolic execution to explore exploitable ma-
chine states and thus expedite the development of working exploits
for Use-After-Free vulnerabilities. To escalate the ability for vulner-
abilities to bypass kernel mitigation, a recent work [45] introduces
a general exploitation method which first converts a control-flow
hijacking primitive into a classic stack overflow and then leverages
the traditional code-reuse attack to circumvent SMEP/SMAP. In
this work, we do not focus on facilitating kernel exploitation for a
specific type of vulnerabilities nor developing general exploitation
methods to bypass kernel mitigation. Rather, our research endeavor
centers around building a technical approach to not only facilitate
exploitation for various types of kernel vulnerabilities but also di-
versify the ways to perform memory layout manipulation and thus
exploitation.
Exploit Automation techniques. There is a rich collection of
research works on exploit generation automation. For example,
using preconditioned symbolic execution and concolic execution
techniques, Brumley et al. developed an automated approach to
generate working exploits for stack overflow and format string
vulnerabilities [3, 6]. Making use of symbolic tracing along with a
combination of shellcode layout remediation and path kneading,
Bao et al. developed ShellSwap that could automatically transplant
existing shellcode and thus synthesize new shellcode for a target
vulnerability [4]. With the facilitation of forward and backward
taint analysis, Mothe et al. devised a technical approach to craft
working exploits for simple vulnerabilities in user-mode applica-
tions [26]. Utilizing various dynamic analysis methods, a team
from the UK and a team from China crafted working exploits for
those heap overflow vulnerabilities residing in the userland appli-
cations [35, 44]. Using various program analysis, the Shellphish
team at UCSB developed two systems (PovFuzzer and Rex) which
give a security analyst the ability to turn a crash to a working ex-
ploit [38, 39, 41]. Regarding PovFuzzer, it repeatedly subtly mutates
input to a vulnerable binary and observes the relationship between
a crash and the input. With respect to Rex, it symbolically executes
the input with the goal of jumping to shellcode or performing an
ROP attack. To expedite the exploitation of vulnerabilities with
the capability of out-of-bounds access, Heelan et al. utilized regres-
sion tests to obtain the knowledge of how to perform heap layout
manipulation [15]. Recently, Ispoglou et al. proposed to automate
data-only attack to bypass control-flow integrity in userland [19].
Given arbitrary memory write primitives, it chains basic blocks
based on their semantics and thus achieves the exploitation goal.
In this work, we also develop a tool for facilitating exploit gener-
ation. However, our tool is fundamentally different from the afore-
mentioned tools and techniques. First, rather than dealing with
applications in the user space, our tool targets the Linux kernel
where exploitation typically involves more complicated operations
and more sophisticated memory layout. Second, rather than generat-
ing one single exploit for a target vulnerability, our tool explores all
possible kernel objects and exploitation methods to output various
working exploits. To some extent, this gives a security researcher
the ability to diversify the ways of launching kernel exploitation
and even escalate vulnerability exploitability.
9 CONCLUSION
In this paper, we built SLAKE to facilitate exploit development for
kernel vulnerabilities. Technically speaking, SLAKE uses static and
dynamic analysis techniques to track down data objects useful for
kernel exploitation. Using SLAKE against 27 real-world kernel vul-
nerabilities, we show a security researcher can effectively identify
kernel objects and the corresponding system calls to perform kernel
exploitation. In addition, with the facilitation of SLAKE, we demon-
strate a security researcher can also diversify his ways to perform
kernel exploitation. For some kernel vulnerabilities, we also find
that SLAKE can even escalate the exploitability for target vulnera-
bilities. With all of these demonstrations and findings, we conclude
that static and dynamic analysis techniques could significantly em-
power the capability of security researchers in developing working
exploits, and thus potentially benefit exploitability assessment for
Linux kernel bugs.
REFERENCES
[1] 2019. Code and Exploits for SLAKE. (2019). https://github.com/chenyueqi/
SLAKE.git.
[2] 0x3f97. 2018. cve-2017-8890 root case analysis. (2018). https://0x3f97.github.io/
exploit/2018/08/13/cve-2017-8890-root-case-analysis/.
[3] Thanassis Avgerinos, Sang Kil Cha, Alexandre Rebert, Edward J. Schwartz, Mav-
erick Woo, and David Brumley. 2014. Automatic Exploit Generation. Commun.
ACM 57 (2014).
[4] Tiffany Bao, Ruoyu Wang, Yan Shoshitaishvili, and David Brumley. 2017. Your Ex-
ploit is Mine: Automatic Shellcode Transplant for Remote Exploits. In Proceedings
of the 38th IEEE Symposium on Security and Privacy (S&P).
[5] Daniel P. Bovet and Marco Cesati. 2010. Understanding the Linux Kernel. Else-
vier.
[6] David Brumley, Pongsin Poosankam, Dawn Xiaodong Song, and Jiang Zheng.
2008. Automatic Patch-Based Exploit Generation is Possible: Techniques and Im-
plications. In Proceedings of the 29th IEEE Symposium on Security and Privacy
(S&P).
[7] Kees Cook. 2010. CVE-2010-2963 v4l compat exploit. (2010). https://outflux.net/
blog/archives/2010/10/19/cve-2010-2963-v4l-compat-exploit/.
[8] The MITRE Corporation. 2019. common Vulnerability and Exposures. (2019).
https://cve.mitre.org/cve/.
[9] SSD Secure Disclosure. 2017. SSD Advisory ś Linux Kernel AF_PACKET Use-