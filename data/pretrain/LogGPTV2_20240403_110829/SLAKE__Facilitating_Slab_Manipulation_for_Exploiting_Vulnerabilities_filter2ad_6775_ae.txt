### Table 3: Exploitability Demonstration and Comparison

| **Vulnerability ID** | **Type** | **Exploitation Methods** |
|---------------------|----------|---------------------------|
| 2018-17182          | OOB      | I: 5 (1⋆), II: -           |
| 2018-18559          | OOB      | I: 13 (1⋆), II: -          |
| 2018-5703           | UAF      | I: -, II: 1 (1⋆)           |
| ...                 | ...      | ...                       |

- **I**: Out-of-Bounds (OOB)
- **II**: Use-After-Free (UAF)
- **III**: Double Free
- **IV**: Metadata Manipulation

**Notes:**
- Numbers within parentheses indicate the total number of publicly available exploits.
- Numbers outside parentheses represent the amount of exploits generated through SLAKE.
- The star (⋆) denotes that the objects used in the public exploit are not included in the SLAKE-generated exploits.

### Evaluation of Exploit Development

#### Comparison Between Public and SLAKE-Generated Exploits

Table 3 provides a detailed comparison of the number of unique working exploits for each kernel vulnerability in our dataset. For the 18 vulnerabilities with existing public exploits, SLAKE successfully identified the data objects and corresponding system calls used in these exploits, except for the first six cases. Additionally, SLAKE was able to generate alternative working exploits using different data objects for 14 of these vulnerabilities. On average, SLAKE provided security researchers with 8 additional unique exploits, highlighting its potential to diversify exploitation methods.

**Key Observations:**
- **Public Exploits:** SLAKE could identify and use the same objects and system calls as those in public exploits, except for a few cases.
- **Alternative Exploits:** SLAKE generated alternative exploits using different data objects, enhancing the diversity of exploitation methods.
- **Unexploited Vulnerabilities:** For vulnerabilities without public exploits, SLAKE still identified suitable objects for potential exploitation, such as CVE-2016-4557, CVE-2017-7184, and CVE-2018-18559.

#### Failure Cases

In Table 2, out of 27 test cases, SLAKE could not facilitate the development of exploits for 9 vulnerabilities. These include:

- **CVE-2017-1000112 and CVE-2018-5703:** The Proof of Concept (PoC) programs only demonstrate the ability to overwrite data within the slab/slot of vulnerable objects, making it infeasible to apply SLAKE's exploitation facilitation methods.
- **CVE-2017-2636, CVE-2014-2851, and CVE-2018-17182:** Exploitation requires allocating target objects to a special cache, and suitable objects were not found in our database.
- **CVE-2018-12714, CVE-2018-16880, CVE-2017-17052, and CVE-2018-10840:** PoC programs do not provide sufficient capability to write controllable data to memory regions, limiting the exploitability of these vulnerabilities.

### Discussion & Future Work

#### Other Operating Systems

SLAKE's automated method for building a database of useful kernel objects can be applied to other open-source operating systems like FreeBSD and Android. For closed-source OSes like Windows, binary code reverse engineering would be necessary.

#### Other Allocators

To extend SLAKE's approach to other kernel allocators (e.g., SLOB, buddy system) or userland allocators (e.g., ptmalloc), modifications are required. For example, ptmalloc coalesces freed chunks before adding them to bins, necessitating a different memory manipulation approach.

#### Object Identification

SLAKE identifies spray objects by analyzing the arguments of kernel functions. However, this may miss some special cases where userland data is copied to the kernel stack and then to the slab. Future work will focus on enhancing SLAKE with inter-procedural data flow analysis to handle such cases.

#### Additional Exploitation Methods

Future efforts will include integrating more exploitation methods into SLAKE, enriching its functionality for handling special cases and heap-based use-before-initialization vulnerabilities.

#### Vulnerability Capability

Currently, vulnerability capabilities are manually extracted from PoC programs. Automating this process using dynamic analysis methods like symbolic tracing is a future goal. Additionally, exploring technical approaches to enhance the capabilities of vulnerabilities will be a key area of focus.

### Related Work

#### Kernel Exploitation Techniques

- **Xu et al. [48]:** Proposed memory collision attack mechanisms for kernel Use-After-Free (UAF) exploitation.
- **Lu et al. [24]:** Developed deterministic and exhaustive memory spraying techniques for Use-Before-Initialization (UBI) vulnerabilities.
- **FUZE [46]:** Utilized under-context fuzzing and symbolic execution to expedite the development of UAF exploits.
- **Recent Work [45]:** Introduced a method to convert control-flow hijacking primitives into classic stack overflows to bypass kernel mitigations.

#### Exploit Automation Techniques

- **Brumley et al. [3, 6]:** Developed automated approaches for generating exploits for stack overflow and format string vulnerabilities.
- **Bao et al. [4]:** Created ShellSwap for automatic shellcode transplantation.
- **Mothe et al. [26]:** Devised a method for crafting exploits for simple user-mode application vulnerabilities.
- **Teams from the UK and China [35, 44]:** Crafted exploits for userland heap overflow vulnerabilities.
- **Shellphish Team [38, 39, 41]:** Developed PovFuzzer and Rex for turning crashes into working exploits.
- **Heelan et al. [15]:** Used regression tests for heap layout manipulation.
- **Ispoglou et al. [19]:** Automated data-only attacks to bypass control-flow integrity in userland.

### Conclusion

SLAKE effectively facilitates the development of exploits for kernel vulnerabilities by identifying useful data objects and system calls. It also diversifies the ways to perform kernel exploitation and can even escalate the exploitability of certain vulnerabilities. This demonstrates the significant potential of static and dynamic analysis techniques in empowering security researchers to develop working exploits and assess exploitability for Linux kernel bugs.

### References

[1] 2019. Code and Exploits for SLAKE. (2019). https://github.com/chenyueqi/SLAKE.git.
[2] 0x3f97. 2018. cve-2017-8890 root case analysis. (2018). https://0x3f97.github.io/exploit/2018/08/13/cve-2017-8890-root-case-analysis/.
[3] Thanassis Avgerinos, Sang Kil Cha, Alexandre Rebert, Edward J. Schwartz, Maverick Woo, and David Brumley. 2014. Automatic Exploit Generation. Commun. ACM 57 (2014).
[4] Tiffany Bao, Ruoyu Wang, Yan Shoshitaishvili, and David Brumley. 2017. Your Exploit is Mine: Automatic Shellcode Transplant for Remote Exploits. In Proceedings of the 38th IEEE Symposium on Security and Privacy (S&P).
[5] Daniel P. Bovet and Marco Cesati. 2010. Understanding the Linux Kernel. Elsevier.
[6] David Brumley, Pongsin Poosankam, Dawn Xiaodong Song, and Jiang Zheng. 2008. Automatic Patch-Based Exploit Generation is Possible: Techniques and Implications. In Proceedings of the 29th IEEE Symposium on Security and Privacy (S&P).
[7] Kees Cook. 2010. CVE-2010-2963 v4l compat exploit. (2010). https://outflux.net/blog/archives/2010/10/19/cve-2010-2963-v4l-compat-exploit/.
[8] The MITRE Corporation. 2019. Common Vulnerability and Exposures. (2019). https://cve.mitre.org/cve/.
[9] SSD Secure Disclosure. 2017. SSD Advisory – Linux Kernel AF_PACKET Use-