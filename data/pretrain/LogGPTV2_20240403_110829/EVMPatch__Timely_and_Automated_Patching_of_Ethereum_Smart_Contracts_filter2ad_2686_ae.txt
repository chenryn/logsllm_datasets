we assume no prior knowledge on patching smart contracts
(see Table 5 how developers rated their prior experience
with smart contracts). In contrast, the third task consists of
extending EVMPATCH. This requires understanding a bug
class and perform root cause analysis to properly patch the
vulnerability. This is surely more challenging compared to
the previous two tasks. Since the third task covers a different
Table 4: Timing results for the tasks as reported by the developers
given in minutes and their reported conﬁdence in the correctness of
their results.
Task
Manual
Integer Patches
Conversion
EVMPATCH
Conversion
Patch Template
Time (Minutes)
Conﬁdence
Median Min Max Median (1-7)
47.50
6
35
78
62.50
1.50
4.00
33
1
2
110
3
15
2.5
-
7
bug class, we believe there is no signiﬁcant bias in the data
due to the developers completing the other two tasks ﬁrst.
For all tasks, we measured the time required by the
developer to perform the task (excluding the time required for
reading the tasks’ description). We asked the developers to rate
their familiarity with relevant technologies, their conﬁdence
levels in their patches, and the difﬁculty of performing the
tasks on a 7-point Likert scale. The full questionnaire and
the answers of the developers are shown in Table 5, and the
recorded time measurements are shown in Table 4. We provide
the supporting ﬁles in a github repository.8
We then performed both a manual code review and a cross-
check with EVMPATCH to analyze mistakes made by the
developers. The results of our study show that signiﬁcant effort
is needed to correctly patch smart contracts manually, whereas
EVMPATCH enables simple, user-friendly, and efﬁcient
patching. The time measurements show that the developers,
who had no prior experience with EVMPATCH, were able to
perform complex tasks utilizing EVMPATCH within minutes.
Patching Integer Overﬂow Bugs. We asked the developers
to ﬁx all integer overﬂow vulnerabilities in three contracts:
1 BEC [2] (CVE-2018-10299, 299 lines of code), and
2 HXG [17] (CVE-2018-11239, 102 lines of code) and
3 SCA [37] (CVE-2018-10706, 404 lines of code). To provide
a representative set of contracts, we chose three ERC-20 con-
tracts with varying complexity (in terms of lines of code) and
where the static analysis also includes missed bugs and false
alarms (see § 5.2.2). We ran OSIRIS on all three contracts and
provided the developers the analysis output as well as a copy of
the SafeMath Solidity library. This accurately resembles a real-
world scenario, where a blockchain developer quickly needs
to patch a smart contract based on the analysis results of recent
state-of-the-art vulnerability analysis tools and can look-up
manual patching tutorials available online. All developers
manually and correctly patched the source code of all three
contracts which demonstrates their expertise in blockchain
development. However, on the downside, it took the devel-
opers on average 51.8 min (σ = 16.6min) to create patched
version for the three contracts. In contrast, EVMPATCH fully
automates the patching process and is able to generate patches
for the three contracts within a maximum of 10 s.
Converting to an Upgradable Contract. The developers
had to convert a given smart contract into an upgradable smart
contract. We provided the developers a short description of the
delegatecall-proxy pattern and asked them to convert the given
contract into two contracts: one proxy contract and a logic
contract, which is based on the original contract. We provided
no further information on how to handle the storage-layout
problem, and we explicitly allowed using code found online.
The developers required an average of 66.3 min9 to convert
a contract into an upgradable contract. None of the developers
performed a correct conversion into an upgradable contract,
8github.com/uni-due-syssec/evmpatch-developer-study
9σ =31.3min, fastest 33 min and slowest 110 min
1302    30th USENIX Security Symposium
USENIX Association
which is also reﬂected in a median conﬁdence of 2.5 in the
correctness reported by the developers. We observed two
major mistakes: (a) The proxy contract would only support a
ﬁxed set of functions, i.e., the proxy would not support adding
functions to the contract, and (b) more importantly, only one
out of six developers correctly handled storage collisions in
the proxy and logic contract, i.e., ﬁve of the six converted
contracts were broken by design. Hence, it remains open how
long it would take developers to perform a correct conversion.
Next, we asked the developers to utilize EVMPATCH to
create and deploy an upgradable contract. As EVMPATCH
does not require any prior knowledge about upgradable con-
tracts, the developers were able to deploy a correct upgradable
contract within at most 3 min. In addition, patching with
EVMPATCH inspires high conﬁdence—a median of 7, the best
rating on our scale—in the correctness of the patch. This gives
a strong conﬁrmation that deployment of a proxy with EVM-
PATCH is indeed superior to manual patching and upgrading.
Extending EVMPATCH. The developers had to write a
custom patch template for EVMPATCH. We instructed
the developers on how to use EVMPATCH and how patch
templates are written with EVMPATCH’s patch template
language (see Figure 4 for an example). Furthermore, we
presented the developers an extended bug report that shows
how an access control bug can be exploited. The developers
leveraged the full EVMPATCH system, i.e., EVMPATCH
applies the patch and validates the patch using the patch
tester component which replays past transactions from the
blockchain and notiﬁes the developer whether: (a) the patch
prevents a known attack, and (b) whether the patch broke
functionality in other prior legitimate transactions. As such,
EVMPATCH allowed the developers to create a fully func-
tional and securely patched upgradable contract within a few
minutes. On average, the developers only needed 5.5 min, and
a maximum of 15 min, to create a custom patch template. As
expected, all developers correctly patched the given contract
using EVMPATCH, because a faulty patch would have been
reported by EVMPATCH’s patch tester to the developer.
EVMPATCH’s integrated patch tester gives the developers a
high conﬁdence into their patch. On average, the developers
reported a conﬁdence level of 6.6 (σ =0.4), where 7 is the most
conﬁdent. Furthermore, none of the developers considered
writing such a custom patch template as particularly difﬁcult.
Summary. Our study provides conﬁrmation that EVMPATCH
offers a high degree of automation, efﬁciency, and usability
thereby freeing developers from manual and error-prone tasks.
In particular, none of the six developers were able to produce
a correct upgradable contract mainly due to the difﬁculty of
preserving the storage-layout. Our study also conﬁrms that
extending EVMPATCH with custom patch templates is a
feasible task, even for developers that are unaware of the inner
workings of EVMPATCH.
6 Related Work
The infamous attack against “TheDAO” contract [7] received
considerable attention from the community. Since then, many
additional exploits and defenses, which mostly focus on discov-
ering bugs before the contract is deployed, were revealed. Luu
et al. presented the symbolic executor Oyente that explores a
contracts code, while looking for possible vulnerabilities [23].
Since then many other symbolic execution tools with better
precision, performance, and covering different vulnerabilities
have been proposed [13, 20, 24, 25, 28]. Furthermore, static
analyzers for both Solidity [12] and EVM bytecode have been
proposed [42]. Information ﬂow analysis and data sanitization
in a multi-transaction setting is analyzed by Ethainter [4].
Furthermore, methods from formal veriﬁcation and model
checking have been applied to smart contracts [14, 19] and the
semantics of the EVM and Solidity language have been for-
malized [15, 18]. However, only a small body of prior work has
researched dynamic analysis and runtime protections. Tools
such as Sereum [32] or ECFChecker [16] can detect live reen-
trancy attacks on vulnerable contracts. Recent work has further
explored modular dynamic analysis frameworks for protecting
smart contracts [6, 40]. Protection solutions that require
modiﬁcations to the smart contract execution environment are
unlikely to be integrated in to production blockchain systems.
Integer overﬂows have been widely studied in the context
of Ethereum smart contracts. Osiris [13] is an extension to
the symbolic execution tool Oyente [23] to accurately detect
integer bugs. The improved symbolic execution engine ﬁrst
attempts to infer the integer type, i.e., signedness and bit width,
from the speciﬁc instructions generated by Solidity compilers.
Next, it checks for possible integer bugs, such as truncation,
overﬂow, underﬂow, and wrong type casts. We leverage the
detection capabilities of Osiris, because it pinpoints the exact
location of the integer overﬂow bug. Other tools such as
TeEther [20] and MAIAN [28] implicitly ﬁnd integer bugs
when they generate exploits for smart contracts. However,
they do not report the exact location of the integer overﬂow,
because they focus on exploit generation. ZEUS [19] utilizes
abstract interpretation and symbolic model checking to verify
safety properties of smart contracts. While ZEUS can detect
potential integer overﬂow vulnerabilities, it does so at the
LLVM intermediate level and cannot determine the exact
location in the corresponding EVM bytecode.
Recently, bytecode rewriting for patching smart con-
tracts has been explored with SMARTSHIELD [47].
SMARTSHIELD requires a complete control-ﬂow graph
(CFG) to update jump targets and data references. As discussed
in § 4.1, generating a highly accurate CFG is highly challeng-
ing due to the EVM’s bytecode format. We believe that such
a bytecode rewriting strategy does not scale to larger and more
complicated contracts. In contrast, EVMPATCH’s trampoline-
based rewriting strategy does not require an accurate CFG
and is much more resilient when rewriting complex contracts.
USENIX Association
30th USENIX Security Symposium    1303
SMARTSHIELD implements custom bytecode analysis to
detect vulnerabilities, which may not be as accurate as special-
ized analyses. For example, SMARTSHIELD’s analysis does
not infer whether an integer type is signed, which is important
for accurate integer overﬂow detection [13]. EVMPATCH is a
ﬂexible framework that can integrate many static analysis tools
for detecting vulnerabilities and can leverage analysis tool
improvements with minimal effort. Last and most importantly,
EVMPATCH automates the whole lifecycle of deploying and
managing an upgradable contract, while SMARTSHIELD
is designed to harden a contract pre-deployment. With
EVMPATCH, a smart contract developer can also patch vulner-
abilities that are discovered after deployment of the contract.
The Ethereum community explored several design patterns
to allow upgradable smart contracts [11, 41, 45, 46] with man-
ual migration to a new contract and the proxy pattern being the
most popular (see § 2). The ZeppelinOS [46] framework sup-
ports upgradable contracts by implementing the delegatecall-
proxy pattern. However, developers have to manually ensure
compatibility of the legacy and patched contract on the Solidity
level. This can be achieved using static analysis tools that
perform “upgradeability” checks (e.g., Slither [35] checks for
a compatible storage layout), which relies on accurate knowl-
edge of compiler behavior with respect to storage allocations.
On the other hand, EVMPATCH combines existing analysis
tools and provides an automatic method to patch detected vul-
nerabilities while keeping storage layout consistent by design.
7 Conclusion
Updating erroneous smart contracts constitutes one of the
major challenges in the ﬁeld of blockchain technologies. The
recent past has shown that attackers are fast in successfully
abusing smart contract errors due to the natural design of the un-
derlying technology: always online and available, one common
and simple computing engine without any subtle software and
conﬁguration dependencies, and (often) high amount of cryp-
tocurrency at disposal. While many proposals have introduced
frameworks to aid developers in ﬁnding bugs, it remains open
how developers and the community can quickly and automat-
ically react to vulnerabilities on already deployed contracts. In
this work, we developed a framework that supports automated
and instant patching of smart contract errors based on bytecode
rewriting. In terms of evaluation, we were able to demonstrate
that real-world vulnerable contracts can be successfully
patched without violating the functional correctness of the
smart contract. Our developer study shows that an automated
patching approach greatly reduces the time required for patch-
ing smart contracts and that our implementation, EVMPATCH,
can be practically integrated into a smart contract developers
workﬂow. We believe that automated patching will increase
the trustworthiness and acceptance of smart contracts as it
allows developers to quickly react on reported vulnerabilities.
Acknowledgment
The authors would like to thank the reviewers—and especially
our shepherd Yinzhi Cao—for their valuable feedback, and the
developers for taking the time to participate in our study. This
work was partially funded by the Deutsche Forschungsgemein-
schaft (DFG, German Research Foundation) under Germany’s
Excellence Strategy - EXC 2092 CASA - 390781972
and the DFG as part of project S2 within the CRC 1119
CROSSING. This work has been partially supported by the EU
H2020-SU-ICT-03-2018 CyberSec4Europe project, funded by
the European Commission under grant agreement no. 830929.
References
[1]
[2]
[3]
[4]
ALERT: New batchOverﬂow Bug in Multiple ERC20 Smart Contracts
(CVE-2018-10299). URL: https://blog.peckshield.com/2018/
04/22/batchOverflow/ (visited on 05/27/2019).
BeautyChainToken. URL: https : / / etherscan . io / address /
0xc5d105e63711398af9bbff092d4b6769c82f793d.
Lorenz Breidenbach, Phil Daian, Ari Juels, and Emin Gün Sirer. An
In-Depth Look at the Parity Multisig Bug. 2017. URL: http : / /
hackingdistributed.com/2017/07/22/deep- dive- parity-
bug/ (visited on 04/20/2018).
Lexi Brent, Neville Grech, Siﬁs Lagouvardos, Bernhard Scholz, and
Yannis Smaragdakis. “Ethainter: A Smart Contract Security Analyzer
for Composite Vulnerabilities”. In: Proceedings of the 41th ACM
SIGPLAN Conference on Programming Language Design and Imple-
mentation (PLDI). 2020. DOI: 10.1145/3385412.3385990.
[7]
[8]
[6]
[5] Bryan Roger Buck and Jeffrey K. Hollingsworth. “An API for Runtime
Code Patching”. In: Int. J. High Perform. Comput. Appl. 14.4 (2000).
DOI: 10.1177/109434200001400404.
Ting Chen et al. “SODA: A Generic Online Detection Framework for
Smart Contracts”. In: Proceedings Network and Distributed System
Security Symposium (NDSS). 2020. DOI: 10 . 14722 / ndss . 2020 .
24449.
Phil Daian. Analysis of the DAO exploit. 2016. URL: http : / /
hackingdistributed . com / 2016 / 06 / 18 / analysis - of - the -
dao-exploit/ (visited on 10/10/2017).
Lucas Davi, Alexandra Dmitrienko, Manuel Egele, Thomas Fischer,
Thorsten Holz, Ralf Hund, Stefan Nürnberger, and Ahmad-Reza
Sadeghi. “MoCFI: A Framework to Mitigate Control-Flow Attacks
on Smartphones”. In: Proceedings Network and Distributed System
Security Symposium (NDSS). 2012.
Solidity Documentation. Layout of State Variables in Storage. URL:
https : / / solidity . readthedocs . io / en / v0 . 5 . 10 /
miscellaneous.html (visited on 05/27/2019).
Ethereum EIPs. ERC930 - Eternal Storage Standard. URL: https:
/ / github . com / ethereum / EIPs / issues / 930 (visited on
11/08/2019).
Ethereum Smart Contract Best Practices: Upgrading Broken Con-
tracts. URL: https://consensys.github.io/smart-contract-
best - practices / software _ engineering / #upgrading -
broken-contracts (visited on 09/28/2020).
Josselin Feist, Gustavo Grieco, and Alex Groce. “Slither: a static anal-
ysis framework for smart contracts”. In: Proceedings of the 2nd Inter-
national Workshop on Emerging Trends in Software Engineering for
Blockchain (WETSEB@ICSE). 2019. DOI: 10.1109/WETSEB.2019.
00008.
[9]
[10]
[11]
[12]
1304    30th USENIX Security Symposium
USENIX Association
[15]
[14]
[13] Christof Ferreira-Torres, Julian Schütte, and Radu State. “Osiris: Hunt-
ing for Integer Bugs in Ethereum Smart Contracts”. In: Proceedings of
the 34th Annual Computer Security Applications Conference (ACSAC).
2018. DOI: 10.1145/3274694.3274737.
Joel Frank, Cornelius Aschermann, and Thorsten Holz. “ETHBMC:
A Bounded Model Checker for Smart Contracts”. In: 29th USENIX
Security Symposium. 2020.
Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. “Founda-
tions and Tools for the Static Analysis of Ethereum Smart Contracts”.
In: Computer Aided Veriﬁcation. Springer International Publishing,
2018. DOI: 10.1007/978-3-319-96145-3_4.
Shelly Grossman, Ittai Abraham, Guy Golan-Gueta, Yan Michalevsky,
Noam Rinetzky, Mooly Sagiv, and Yoni Zohar. “Online detection of
effectively callback free objects with applications to smart contracts”.
In: Proceedings of the ACM on Programming Languages POPL (2018).
DOI: 10.1145/3158136.
[16]
[17] HexagonToken. URL: https : / / etherscan . io / address /
[18]
[19]
[20]
0xB5335e24d0aB29C190AB8C2B459238Da1153cEBA.
Jiao Jiao, Shuanglong Kan, Shang-Wei Lin, David Sanan, Yang Liu,
and Jun Sun. “Semantic Understanding of Smart Contracts: Executable
Operational Semantics of Solidity”. In: 2020 IEEE Symposium on
Security and Privacy. 2020. DOI: 10.1109/SP40000.2020.00066.
Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. “ZEUS:
Analyzing Safety of Smart Contracts”. In: Proceedings 2018 Network
and Distributed System Security Symposium (NDSS). 2018. DOI: 10.
14722/ndss.2018.23082.
Johannes Krupp and Christian Rossow. “teEther: Gnawing at Ethereum
to Automatically Exploit Smart Contracts”. In: 27th USENIX Secu-
rity Symposium. USENIX Association, 2018. URL: https://www.
usenix.org/conference/usenixsecurity18/presentation/
krupp.
[21] M A Laurenzano, M M Tikir, L Carrington, and A Snavely. “PEBIL:
Efﬁcient static binary instrumentation for Linux”. In: 2010 IEEE In-
ternational Symposium on Performance Analysis of Systems Software