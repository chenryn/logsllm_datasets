IoCreateDevice. Then a dispatch function (data type FUNCT_0049_095B_
Majorfunction and tag_id 7) was registered to the driver object (with tag_id
1) that was assigned to msdirectx by the Windows kernel. This dispatch func-
tion was invoked by the kernel I/O manager to process I/O requests issued by
the fu.exe processes. By checking the parameters of this dispatch function, we
found that the I/O control codes for process and driver concealment tasks are
0x2a7b2008 and 0x2a7b2020. Second, the kernel string function strncmp was
called 373 times by one msdirectx function, implying a brute-force searching
operation. The ﬁrst parameter of this function was constant string ”System”
and the second parameter was 6 bytes of data within the process descriptor of
the process System (with tag_id 2). Beginning with the address of the process
descriptor, the address of the second parameter was increased by one byte each
time this string function was called. The purpose of the search was to ﬁnd the
oﬀset of the process name in the EPROCESS structure. This was conﬁrmed by
manually checking the FUTo source. It seems that the deﬁnition of EPROCESS
structure has changed over the Windows versions and the brute-force searching
allows FUTo to work with diﬀerent Windows versions.
5.2 TCPIRPHOOK
Inserting hooks into the kernel to tamper with the kernel control-ﬂow path is one
major technique that attackers apply to rootkit attacks. A hooked function can
Toward Revealing Kernel Malware Behavior
319
intercept and manipulate kernel data to serve its malicious aims. TCPIRPHOOK
is one such rootkit and it intends to hide the TCP connections from local users.
Speciﬁcally, this rookit exploits the dispatch function table of the TCP/IP driver
object (associated with driver TCPIP.sys) and substitutes a dispatch function
with its hook. The hooked function registers another hook to the I/O request pack-
ets (IRP) such that the second hook can intercept and modify the query results for
network connections. We downloaded the rootkit package from [21] which also in-
cluded one driver ﬁle, irphook.sys. The rootkit was implemented to conceal all http
connections (with destination port 80). Before installing the rootkit, we opened
Internet Explorer to visit a few websites, and then ran the netstat utility to dis-
play the corresponding http connections. We loaded the irphook.sys to the kernel
and used netstat to verify that all https connections were gone. In the end, we
unloaded the irphook.sys. The test took less than 3 minutes.
The call graph of TCPIRPHOOK is shown in Figure 2. Function 0xf7ab8132
(irphook.sys) was the ﬁrst hook that was inserted into the 14th entry
(IRP MJ DEVICE CONTROL,) of the dispatch function table in the driver
TCPIP.sys. The replaced dispatch function was TCPDispatch (address
0xf726fddf) owned by driver TCPIP.sys. The ﬁrst hook invoked TCPDispatch
15 times in the call graph. In fact, it is common for rootkits to call the original
function in a hook, which reduces the coding complexity of the hook. Function
0xfa7b8000 (irphook.sys) was the second hook that was responsible for modify-
ing the query results for network connections. Although the second hook seems
to be called by TCPDispatch in the call graph, the actual direct caller of the
second hook was IopfCompleteRequest (ntoskrnl.exe). This is because Rkproﬁler
did not track the benign kernel code and had no knowledge of their call stacks.
On the other hand, even the indirect caller-callee relation between TCPDisptch
and the second hook can imply that the network connection query caused syn-
chronous IRP processing and completion in the kernel, which is comparable to
Fig. 2. TCPIRPHOOK call graph
320
C. Xuan, J. Copeland, and R. Beyah
asynchronous IRP processing and completion. But this information cannot be
inferred by simply looking at the IDA-pro’s call graph, because IDA-pro can-
not statically determine the symbol of function TCPDispatch and the calling
path from the ﬁrst hook to the second hook in Figure 3 is not presented in the
IDA-pro’s call graph.
Figure 3 is the tag trace graph of TCPIRPHOOK. Two hooking activities are
illustrated in this graph. The ﬁrst hook was installed at the driver loading stage.
To hook the dispatch function table of the driver TCPIP.sys, TCPIRPHOOK
ﬁrst calls the kernel function IoGetDeviceObjectPointer with the device name
\\Device\\Tcp to get the pointer (with tag_id 7) to the device object (with
tag_id 8) owned by driver TCPIP.sys. Then, the device object was visited to
get the address of the driver object (with tag_id 9) owned by driver TCPIP.sys.
Last, TCPIRPHOOK carried out the hooking by accessing the 14th entry of the
dispatch function table in the driver object: reading the address of the original
dispatch function (with tag_id 10) and storing it to a global variable; writing the
address of the second hook (with tag_id 11) to the table entry. The second hook
was dynamically installed in the context of process netstat.exe. When netstat.exe
was executed to query TCP connection status, the Windows kernel I/O manager
created an IRP (with tag_id 12) for the netstat.exe process. This IRP was
passed to the ﬁrst hook (function_id 5 and tag_id 11) of TCPIRPHOOK.
The ﬁrst hook obtained the IO_STACK_LOCATION object (with tag_id 13) from
this IRP and wrote the address of the second hook (with tag_id 14) to the data
member CompletionRoutine of the IO_STACK_LOCATION object. Thus, being one
Fig. 3. TCPIRPHOOK tag trace graph
Toward Revealing Kernel Malware Behavior
321
IRP completion function, the second hook would be called by the Windows
kernel to process the I/O return data for this IRP. Last, the tag trace graph also
captures the manipulation of the I/O return data. The buﬀer of the I/O return
data was pointed to by the data member UserBuﬀer of IRP and it was an array
of structure CONNINF101 (with tag_id 15). The size of the buﬀer was stored
in the data member IoStatus.Information of the IRP. Clearly, the tag_id 15 was
modiﬁed in the tag trace graph. By examining the tag trace table, we found that
the status of all http connections in the buﬀer were changed from 5 to 0.
5.3 Rustock.B
Rustock.B is a notorious backdoor rootkit that hides malicious activities on a
compromised machine. The distinguished feature of this rootkit is the usage of
multi-layered code packing, which makes static analysis cumbersome [7]. Unlike
the other two rookits described above, we did not have access to the source code
of this rootkit. However, several analysis results on this rootkit published on the
Internet helped us understand some behaviors of this rootkit. We downloaded
Rustock.B from [20] as one executable. During the test, we just double-clicked
the binary and waited until the size of the Rkproﬁler log stop being populated.
The test lasted about ﬁve minutes.
A malicious driver named system32:lzx32:sys was detected by Rkproﬁler.
90857 calls and 2936 tags were captured in the test. The driver contained self-
modiﬁying code and we found many RET instructions that did not have corre-
sponding CALL instructions at code unpacking stages. This is because unpacking
routines executed JMP instructions to transfer the controls to the intermedi-
ate or unpacked code. In addition, the driver modiﬁed the dedicated register
IA32_SYSENTER_EIP through WRMSR and RDMSR instructions to hijack the
Windows System Service Descriptor Table (SSDT). One hook was added to the
dispatch function table of driver Ntfs.sys to replace the original IRP_MJ_CREATE
dispatch function. This is similar to what TCPIRPHOOK does. We compared
the report generated by Rkproﬁler with others on the Internet and they matched
each other well. Table 2 lists the external functions and registry keys that were
called and created by Rustock.B. Unfortunately, the full report of this test can-
not be presented due to the space constraint.
6 Discussion
In addition to the incomplete kernel symbols provided by Microsoft, the current
implementation of Rkproﬁler suﬀers several other limitations that could be ex-
ploited by attackers to evade the inspection. First, attackers may compromise
the kernel without running any malicious kernel code, e.g., directly modifying
kernel data objects from user space or launching return-to-lib attacks without
the use of any function calls [24]. Rkproﬁler is not able to detect and proﬁle
such attacks. Instead, other defense approaches like control ﬂow integrity en-
forcement [2] could be adopted to address them. Second, the instruction pair
322
C. Xuan, J. Copeland, and R. Beyah
Table 2. External functions and registry keys manipulated by Rustock. B
ExFreePoolWithTag,
External Functions
MmProbeAndLockPages,
KeEnterCriticalRegion,
ExAllocatePoolWithTag,
ExInitializeN-
PagedLookasideList, IoAllocateMdl, IoGetCurrentProcess, IoGet-
DeviceObjectPointer,
IoGetRelatedDeviceObject, KeClearEvent,
KeDelayExecutionThread,
KeInitial-
izeApc, KeInitializeEvent, KeInitializeMutex, KeInitializeSpin-
Lock, KeInsertQueueApc, KeLeaveCriticalRegion, KeWaitForS-
ingleObject, MmBuildMdlForNonPagedPool, MmMapLocked-
Pages,
NtSetInformationProcess,
ObfDereferenceObject,
Probe-
ForRead, PsCreateSystemThread, PsLookupProcessByProcessId,
PsLookupThreadByThreadId, RtlInitUnicodeString,
_stricmp,
_strnicmp, swprintf, wcschr, wcscpy, _wcsicmp, _wcslwr, wcsncpy,
_wcsnicmp, wcstombs, ZwClose, ZwCreateEvent, ZwCreateFile,
ZwDeleteKey, ZwEnumerateKey, ZwOpenKey, ZwQueryInforma-
tionFile, ZwQueryInformationProcess, ZwQuerySystemInforma-
tion, ZwReadFile
ObReferenceObjectByHandle,
Registry Keys
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\pe386
HKEY\_LOCAL\_MACHINE\SYSTEM\CurrentControlSet\
Enum\Root\LEGACY_pe386
CALL/RET is used as the sole indicator of function call and return events.
attackers can obfuscate these function activities to escape the monitoring. For
example, JMP/JMP, CALL/JMP and JMP/RET can be employed to imple-
ment the function call and return events. Moreover, instead of jumping to a
target instruction (either the ﬁrst instruction of a callee function or the returned
instruction of a caller function), a attacker could craft the code to jump to one
of its neighbor instructions, while preserving the software logic intact. Defending
against such attacks is part of our future work. Third, a attacker may deter the
AMT method by accessing dynamic objects in unconventional ways. For exam-
ple, a rootkit can scan the stack of a benign kernel function to get the pointer to
a desired kernel object. These attacks are very challenging, because building an
accurate and up-to-date symbol table for all kernel objects is impractical. Last,
malware may have the capability of detecting virtual machine environments and
change their behavior accordingly. Exploring multiple execution paths [16] and
static analysis could mitigate this problem to some extent.
7 Related Work
Many previous works have focused on run time rootkit detection [19] [4] [17] [18]
[28] and prevention [29] [22] [25]. The main purpose of these mechanisms is to
protect data and code integrity of the guest OS at run time. On the other hand,
researchers have also applied program analysis techniques to create oﬄine rootkit
defense mechanisms with goals such as rootkit identiﬁcation, hook detection and
so on. Several works that fall into this category are discussed below.
Toward Revealing Kernel Malware Behavior
323
Rootkit Identiﬁcation. Kruegel [13] proposed a system that performs static
analysis of rootkits using symbolic execution, a technique that simulates program
execution with symbols. This system can only detect known rootkits. Moreover,
anti-static-analysis techniques like code obfuscation can be used to defeat this
system. Limbo [26] is another rootkit analysis system that loads a suspicious
driver into a PC emulator and uses ﬂood emulation to explore multiple running
paths of the driver. Limbo has a low false positive rate, but it performs poorly
when detecting unknown rootkits. Also, ﬂood emulation makes rootkits behave
abnormally in the emulator, possibly resulting in inaccurate detection. Panorama
[31] uses dynamic taint analysis to detect privacy-breaching rootkits. Sensitive
system data like keys and packets are tainted and system-wide taint propagation
is tracked. A taint graph is generated to tell whether a target rootkit accesses
the tainted data or not. Although this system is good at capturing data-theft
rootkits, it cannot provide necessary behavior information (e.g., kernel hooking)
associated with other types of rootkits.
Hook Detection. HookFinder [30] and HookMap [27] aim to identify the hook-
ing behavior of rootkits. HookFinder performs dynamic taint analysis and allows
users to observe if one of the impacts (tainted data) is used to redirect the sys-
tem execution into the malicious code. On the other hand, HookMap is intended
to identify all potential hooks on the kernel-side execution paths of testing pro-
grams such as ls and netstat. Dynamic slicing is employed to identify all mem-
ory locations that can be altered to diverted kernel control ﬂow. Unfortunately,
hooking is only one aspect of rootkit behavior and both systems cannot provide
comprehensive a view of rootkit activities in a compromised system.
Discovery of Sensitive Kernel Data Manipulation. K-tracer [14] is a
rootkit analysis system that automatically discovers the kernel data manipu-
lation behaviors of rootkits including sensitive data access, modiﬁcation and
triggers. K-tracer performs data slicing and chopping on sensitive data in the
rootkit trace and identiﬁes the data manipulation behaviors. K-tracer cannot
detect hooking behaviors of rootkits and is unable to deal with DKOM and
hardware-based rootkits. In comparison, Rkproﬁler can handle a broad range of
rootkits, including DKOM and hardware-based rootkits, and provide a complete
picture of rootkit activities in a compromised system.
Rootkit Proﬁling. PoKeR [23] is a QEMU-based analysis system that shares
the same design goal as Rkproﬁler: comprehensively revealing rootkit behavior.
PoKeR is capable of producing rootkit traces in four aspects: hooking behavior,
target kernel objects, user-level impact and injected code. Similar to Rkproﬁer,
PoKeR infers the dynamic kernel object starting from the static kernel objects.
However, PoKeR only tracks the pointer-based object propagation, while Rkpro-
ﬁler tracks both pointer-based and function-based object propagation. So Rkpro-
ﬁler can identify more kernel objects than PoKeR. In addition, the function call
and hardware access monitoring features of Rkproﬁler are not oﬀered by PoKeR.
324
C. Xuan, J. Copeland, and R. Beyah
8 Conclusion
In this paper, we present a sandbox-based rootkit analysis system that moni-
tors and reports rootkit behavior in a guest OS. The evaluation results demon-
strate the eﬀectiveness of this system in revealing rootkit behavior. However,
to strengthen the current implementation of Rkproﬁler, we need OS vendors
to provide the unpublished symbols, some of which may have been reversely
engineered by attackers.
References
1. Anubis Project (2009), http://anubis.iseclab.org/?action=home
2. Abadi, M., Budiu, M., Erlingsson, U., Ligatti, j.: Control-ﬂow integiryt: Principles,
implementations, and applications. In: Proceedings of the ACM Conference on
Computer and Communications Security, CCS (2005)
3. BitBlaze Project (2009), http://bitblaze.cs.berkeley.edu/
4. Baliga, A., Ganapathy, V., Iftode, L.: Automatic Inference and Enforcement of
Kernel Data Structure Invariants. In: Proceedings of the 24th Annual Computer
Security Applications Conference, ACSAC (2008)
5. Bellard, F.: QEMU and Kqemu (2009), http://fabrice.bellard.free.fr/qemu/
6. CBS News. Conﬁcker Wakes Up (2009),
http://www.cbsnews.com/stories/2009/04/09/tech/cnettechnews/
main4931360.shtml
7. Chiang, K., Lloyd, L.: A case Study of the Rustock Rootkit and Spam Bot. In:
First workshop on hot topics in understanding botnets (2007)
8. Dr.Web Company. Win32.Ntldrbot (aka Rustock.C) no longer a myth, no
longer a threat. New Dr.Web scanner detects and cures it for real (2009),
http://info.drweb.com/show/3342/en
9. Garﬁnkel, T., Rosenblum, M.: A Virtual Machine Introspection Based Architec-
ture for Intrusion Detection. In: Proceedings of the Symposium on Network and
Distributed System Security, NDSS (2003)
10. Geeg Blog. The Conﬁcker Worm Awakens (2009),
http://geeg.info/blog4.php/2009/04/the-conficker-worm-awakens
11. GraphViz Project (2009), http://www.graphviz.org/
12. Hoglund, G., Butler, J.: Rootkits: Subverting the Windows Kernel. Addison-Wesley
Professional, Reading (2005)
13. Kruegel, B.C., Robertson, W., Vigna, G.: Detecting Kernel-Level Rootkits through
Binary Analysis. In: Proceedings of the 20th Annual Computer Security Applica-
tions Conference, ACSAC (2004)
14. Lanzi, A., Sharif, M., Lee, W.: K-Tracer: A System for Extracting Kernel Malware
Behavior. In: Proceeding of the Annual Network and distributed System Security
Symposium, NDSS (2009)
15. Microsoft Symbol Server (2009), http://msdl.microsoft.com/download/symbols
16. Moser, A., Kruegel, C., Kirda, E.: Exploring multiple execution paths for malware
analysis. In: Proceedings of the IEEE Symposium on Security and Privacy (2007)
17. Petroni, N.L., Fraser, T., Molinz, J., Arbaugh, W.A.: Copilot - a Coprocessor-
based Kernel Runtime Integrity Monitor. In: Proceedings of the USENIX Security
Symposium (2004)
Toward Revealing Kernel Malware Behavior
325
18. Petroni, N.L., Fraser, T., Walters, A., Arbaugh, W.A.: An Architecture for
Speciﬁcation-Based Detection of Semantic Integrity Violations in Kernel Dynamic
Data. In: Proceedings of the USENIX Security Symposium (2006)
19. Petroni, N.L., Hicks, M.: Automated Detection of Persistent Kernel Control-Flow
Attacks. In: Proceedings of the ACM Conference on Computer and Communica-
tions Security, CCS (2007)
20. Oﬀensivecomputing Website (2009), http://www.offensivecomputing.net/
21. Rootkit website (2009), http://www.rootkit.com
22. Riley, R., Jiang, X., Xu, D.: Guest-Transparent Prevention of Kernel Rootkits with
VMM-based Memory Shadowing. In: Lippmann, R., Kirda, E., Trachtenberg, A.
(eds.) RAID 2008. LNCS, vol. 5230, pp. 1–20. Springer, Heidelberg (2008)
23. Riley, R., Jiang, X., Xu, D.: Multi-Aspect Proﬁling of Kernel Rootkit Behavior.
In: Proceedings of the ACM SIGOPS European Conference on Computer Systems,
EuroSys (2009)
24. Shacham, H.: The Geometry of Innocent Flesh on the Bone: Return-into-libc with-
out Function Calls. In: Proceedings of the ACM Conference on Computer and
Communications Security, CCS (2007)
25. Seshadri, A., Luk, M., Qu, N., Perrig, A.: SecVisor: A Tiny Hypervisor to Guar-
antee Lifetime Kernel Code Integrity for Commodity OSes. In: Proceedings of the
ACM Symposium on Operating Systems Principles, SOSP (2007)
26. Wilhelm, J., Chiueh, T.: A Forced Sampled Execution Approach to Kernel Rootkit
Identiﬁcation. In: Kruegel, C., Lippmann, R., Clark, A. (eds.) RAID 2007. LNCS,
vol. 4637, pp. 219–235. Springer, Heidelberg (2007)
27. Wang, Z., Jiang, X., Cui, W., Wang, X.: Countering Persistent Kernel Rootkits
Through systematic Hook Discovery. In: Lippmann, R., Kirda, E., Trachtenberg,
A. (eds.) RAID 2008. LNCS, vol. 5230, pp. 21–38. Springer, Heidelberg (2008)
28. Jiang, X., Wang, X., Xu, D.: Stealthy Malware Detection through VMM-Based
“Out-of-the-Box” Semantic View Recontruction. In: Proceedings of the ACM Con-
ference on Computer and Communications Security, CCS (2007)
29. Xuan, C., Copeland, J., Beyah, R.: Shepherding Loadable Kernel Modules through
On-demand Emulation. In: Flegel, U., Bruschi, D. (eds.) DIMVA 2009. LNCS,
vol. 5587, pp. 48–67. Springer, Heidelberg (2009)
30. Yin, H., Liang, Z., Song, D.: Hookﬁnder: Identifying and understanding malware
hooking behaviors. In: Proceeding of the Annual Network and distributed System
Security Symposium, NDSS (2008)
31. Yin, H., Song, D., Egele, M., Kruegel, C., Kirda, E.: Panorama: Captureing System-
wide Information Flow for Malware Detection and Analysis. In: Proceedings of the
ACM Conference on Computer and Communications Security, CCS (2007)