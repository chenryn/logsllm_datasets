的进程；或简单地说，它是最糟的进程。因此有
限制。因此，它是所有进程中名符其实地最不可预测和不可控制
它在任何时刻可以做任何事情，也可以拒绝任何事情，不受任何
义有所不同
我们剩下的工作是给出用算子递归定义的进程的定义。整
(A,Fn,Dn)=(A,∩Fn,
U{s,X|s∈divergences(P\C))
U{s,X|s∈divergences(P IQ)}
[F'(CHAOSA)
A(u,X)∈failures(Q))
，Q比P更易预测，更易控制，
∩Dn)
117
---
## Page 141
因，就在于保证屏蔽算子的连续性。
表达式也都是连续的。本书中发散的处理很是复杂的一个主要原
义的所有算子(/除外)都是连续的，因而以这些算子构成的每个
所有算子在适当的次序关系下是否是连续的。幸运的是本书中定
们在2.8.2节中给出的那个证明相同。
象以前一样，这个证明能否有效的关键是递归式右端使用的
---
## Page 142
上输出V，然后似P动作，可以定义为
理方法。
且在某些情况下，对这些已施加限制的记号可运用更为有力的推
因为这些记号可以使你联想到一些很有用的应用及实施方法；而
法则的特例。既然如此，为什么还要引入这些特殊的记号？这是
的概念来定义，而且大部分的法则也只是前面大家所熟悉的那些
再定义如下两个函数，它们可将通信的通道和消息分离出来
就是说明这种写法的例子。
传递的消息。1.1.3节X7的COPYBIT和2.6节X4的CHAIN2
描逃的一个事件，其中是发生通信的通道的名字，
事件，人们通常称这类事件为通信。所谓通倡就是用二元对
刻画的进程同时参予。而在本章中，我们将着重讲述一类特殊的
为一个无延时的动作，这种动作的发生可能需要一个以上的独立
设v是ac(P)中的一个元案。一个进程，如果它先在通道
在这一章里引人的所有操作都可以用前几章里的那些更基本
我们定义进程P能在通道上传递的所有消息的集合为
在前几章里，我们引入和说明一般的事件概念时，是把它作
channel(e,u)no, message(c,v) =v
ac(P) ={v)o.v∈aP)
第四章
4.2
4.1
输入和输出
o.v 
 引 
通
官
信
是通信时
119
---
## Page 143
进程确定通信中传递的消息的，而输人进程只能准备好接受可
道。上输出一个消息，同时Q又将它输入时，就会发生通信。输出
的箭头，并用通道名做上标记（见图4.1)。
格地)该进程字母表中的元素。
的输入通道。进程的输入通道或输出通道的名宇都称作（不很严
叫作该进程的输出通道，只为某进程输入信息的通道叫作该进程
且仅用于发生在两个进程之间的通信。为某进程输出信息的通道
其中 ain(COPY BIT) = aout(COPYBIT) = {0,1}
然后似P（x）动作，我们就将它定义为
这个进程初启时准备执行的唯一的事件就是通信事件。."。
输入通道。当P和Q被发组合成系统（PIQ)时，则每当P在通
R
120
画进程的连接框图时（2.4节)，通道被画成是指向适当方向
(c?x-→P(x))=(y:{yIchannel(y)=o}-P(message(y)))
我们将遵守这样一个约定，即每条通道仅用于单向通信，
如果一个进程最初准备在通道6上输入可传递的任意值；
假设P和Q为进程，为P的一个输出通道，
应用输入和输出的新定义，我们可以把1,1.3节中X7改写
举例
COPYBIT=μX.(in?x→(outIx-→X))
(clv-P) =(c,v→P)
图 
4.1
而且也是Q的
口
---
## Page 144
其中 P;=leftrs→P,
的字符一个一个地输出的进程可记为
X3一张穿孔卡上记载的值是80个字符构成的一个序列，整张卡
X2一个进程与COPY类似，只是每个输入的数字在输出前都
如果aleft=[0,1}，则 COPY 就与 COPY BIT(1,1,3 节X7)几
端去，该进程记为
片可当作单个值沿左通道传入。那么负责读入卡片，然后将其上
增大一倍，则有
乎完全一样了。
X1一进程把它从左端输入的每个消息立即拷贝下来并输出到右
明了这类现象。
的变量的值又是由前面某个输入操作所赋予的，以下几个例子说
后的儿节里我们还要给出几个更有意思的例子。
CHAIN2就是上述通信模型工作原理的一个实例，在4.3节及其
况下，我们将把αc(P)和ac(Q)简记为αc。其实2.6节X4中的
以后我们假设上述约束条件总是成立的：而且在不引起混淆的情
的约束条是通道的两端的字母表必须相同，即
中的就是由输出进程所确定的那个值。实现通信中，一个明显
传递的任意值。这样，实际将要发生的事件如果是通信.v，其
一般说来，进程要输出的值是由一个表达式确定的，其所舍
举例
DOUBLE=μX(left?x-→right1(x+x)-X)
aleft=aright =N
COPY = μX(left?x-→right!x→X)
aleft={s|s∈aright*A#s=80}
aleft(COPY)=aright(COPY)
αc(P) =ac(Q)
121
口
---
## Page 145
接的其它进程去做。因此我们要采用在第一章中引入的选择记
意一个通道上通信，至于实际通道的选择是留给与这个进程相连
个“→”来代替
X5--个进程从左至右拷贝消息，但把连续输入的一对星号用一
行后的行为：要等到该行足够长之后所有字符才被输出。
这里，P,所描逃的是进程已经输入序列s中的符号并将其排列成
此处P;=right1s->P(
进程的速度，那么前一段的最后一句话就要解释一下。我们先来
相应的输出准备就绪的先后所确定的，对此我们解释如下。
或从d上输入y，然后似Q(y)动作。通道的选择是由各通道上
号。设和d为不同的通道名，那么
有数组值的消息，由右通道输出，整个进程记为
所表示的进程，它一开始或从上输入，然后似P(x)动作，
125个字符长度的字符行。每集装成一行，就把该行当作一个具
SQUASH= μX.left?x-→
aleft=aright-[#"]
122
由于我们已经决定不考虑事件所延续的时间以及执行事件的
也许会有这样的进程，它一开始就谁备好在一组通道中的任
一个进程由左通道一个一个地输入字符，然后将它们集装成
else left?y→(if y="”then (right!""→X)
if x≠"*" then (right!x→X)
aright={s[s∈aleft*A#s=125}
(o?x-=P(x) |d?y-→Q(y))
olse(right!"*"→right1y-→X))
若#$=（empty→P>|leftx→P(x)
出，即
其中 P(,=leftx→P(e)
出的每一个消息输出到右通道，这个进程写微
输入值的某个函数值，然后重复动作
X8一个进程从up和left通道输入数据，并向doun通道输出
那么VAR的行为就与BOOL(2.6节X5)的行为几平完全一
VAR的行为就象是当前值为x的程序变量，左通道上的通信给
而VAR=(left?y→VAR,|right1x-→VAR)
到右通道的进程可记为
息，并把它放在栈顶；只要不空，它也准备着把顶的元素移
响应empty信号。在任:何时刘它都准备好从左通道输入新的消
列。
过一段可能的延迟，在这段时间里，后来的消息还可以加入队
离队，离队次序与它们加入时的次序相同，但消息由进至出要经
BUFFER的行为就是个队列，消息由队列右端人队，再由左端
X9进程时刻准备从左通道输入消息，并把已输入的但尚未输
样。
它赋新值，右通道上的通信负责取出其当前值。如果aleft={0,1}，
X10
124
有这样一个进程，其行为象个消息栈，当它是空时，它
NODE(u)= μX.(up:sum-sleft?prod→
[night!x→P,)
VAR=left?x-→VARs
aleft=aright
STACK = P
BUFFER=P
down! (sum + v* prod)→X)
口
---
## Page 148
那么P("c)≠"BLEEP，而它的结果是二元对 cons(v,P")。因此
的一个函数，且函数结果为进程Q(x)。因此调用如TLISP 函数
那么Q("c)≠"BLEEP；Q("c）的结果是以输入值x为其自变量
段分开处理，可看如下说明。
信，它就回答以"BLEEP。至于被传递的实际数值，将在下一阶
存的序列却是~s~。
消息，那么 STACK 就贮存消息序列~S，而BUFFER贮
消息的一端。譬如说，y是刚到的消息，x是它正准备要输出的
还参予empty事件，而且它把刚送到的消息放在贮存序列中输出
这个进程与前例中的进程很相似，所不同的是，当它为空时，它
调用LISP 南数
就由Q(")()来代表。
由此可见，当《c,v>是Q的一个迹时，在LISP语言中，Q/
这个函数的定义是
就可实施输入命合
样，
元对（c.)来代表，其结构是
4.2.1
，实施时就方便多了。如果进程没有准备好在该通道上的通
假设Q是输人命合
在通信进程的LISP 实施中，事件c.v自然可用打了标点的二
叉假设P是输出命合
我们把输入和输出指合当作是以通道名为自变量的函数，这
1实施
input(c,F) =Ay.if y ≠ o then "BLEEP else F
input(#c,Ax,Q(x))
output("c,u,P')
cons("c,v)
(cx→Q(x))
(c1v→P')
125
---
## Page 149
4.2.2描述
其中 P=LABELX.
X1 COPY = LABEL X.input("left,x.output("right,x.X))
其它算子也必须按照优化的要求重新实施。
就是为了鼓励使用高效的实施方法。这样做的缺点是，几平所有
那个值为止。我们引入有关输入和输出的特殊记号的理由之一，
值，逐个检验P（c.U)≠"BLEEP是否成立，值至找到了要找的
的效率会低得可怕，为了要找到输出的值，只好对ac中的所有的
件来处理，当作输入和输出命合的一个参数来传递。不过这么做
而P/c.u>可用cdr（P（"c)）来代表。
可见，当是P的一个迹时，在LISP语言里，u=car（P("o))，
就可实施输出命命，这个函数的定义是
为方便起见，干脆把tr↓省去，将tr↓right≤tr↓left简记为
1.9.6节)
通道上传递的消息序列。假设为一通道名，我们定义（参看
X2 PACK = P(NIL)
output(c,u, P) =Ay, if y=≠c then #BLEEP else cons(v, P)
126
在理论上，如果αc是有限集合，就有可能把c.当作-个事
在描述一个通信进程的行为时，简便的方法是，分别刻画各