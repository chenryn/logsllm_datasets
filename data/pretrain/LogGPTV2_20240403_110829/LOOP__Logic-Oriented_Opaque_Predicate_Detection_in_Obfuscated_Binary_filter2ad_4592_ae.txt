structions and related numerics library API calls (e.g., log,
exp and sqrt) are rarely seen in malicious code.
Two-way Opaque Predicates.
Figure 10 shows a subtle case of opaque predicate,
in
which two possible directions will sometimes be taken and
I1; I2 are executed in any case. P does not belong to the cat-
egories we summarized in Section 2 and therefore we cannot
ensure P is an opaque predicate in a single trace. One way
to detect such case is to check semantic equivalence of P ’s
two jump targets [49].
Unsolved Conjectures.
Recently Wang et al. [48] proposed a more stealthy obfus-
cation scheme by incorporating linear unsolved conjectures,
which appear to be correct but without proof. Figure 11
presents an example of embedding the well-known 3x+1 con-
jecture into a program. This conjecture asserts that given
any positive integer y, the loop will always terminate.
In
principle, we could treat the conjunction of branch condi-
tions derived from the unroll loop as a single opaque predi-
cate, which always evaluates to be true for any positive inte-
ger. However, diﬀerent from dynamic opaque predicates, the
number of conditions is various under diﬀerent inputs and
conditions themselves are not correlated as well. To detect
such unsolved conjectures, we observe that all the exam-
ples [48] will eventually converge to a ﬁxed value regardless
of the initial value. We could automatically generate test
cases to explore diﬀerent paths and observe whether the
multiple inputs cover the same value when the conjecture
loop ends. We leave it as our future work.
8. RELATED WORK
In this section, we ﬁrst present previous work on opaque
predicates detection, which is close in spirit to our work.
Then, we introduce related work on concolic testing, a hy-
brid approach to perform symbolic execution. In principle,
our trace-oriented detection is also a hybrid approach that
applies symbolic execution in de-obfuscation. At last we
introduce previous work on infeasible paths identiﬁcation,
which is related to our work in that LOOP can be applied
to detect infeasible paths in binary.
Opaque Predicate Detection.
The concept of opaque predicates is ﬁrst proposed by Coll-
berg et al. [17] to prevent malicious reverse engineering at-
tempts. Collberg et al. [17] also provide some ad-hoc detec-
tion methods. One of them is called “statistical analysis”;
that is, a predicate that always produces the same result
over a larger number of test cases has a great chance to
be an opaque predicate. Due to the limited set of inputs,
statistical analysis could lead to high false positive rates.
Preda et al. [42] propose to detect opaque predicates by
abstract interpretation. However, their approach only de-
tects a speciﬁc type of known invariant opaque predicates
such as ∀x ∈ Z.n|f (x). Madou [33] ﬁrst identiﬁes can-
didate branches that never change at run time, and then
veriﬁes such predicates by fuzz testing with a considerably
high error rate. Udupa et al. [45] utilize static path fea-
sibility analysis to determine whether an execution path is
feasible. However, their approach cannot work on a highly
obfuscated binary with, for example, complicated opaque
predicates based on pointer aliasing, which is known to be
statically intractable. OptiCode [43] has a similar idea in
using theorem prover to decide if a desired branch is always
true or false, but it can only deal with invariant opaque
predicates. Our work is diﬀerent from the previous work in
that LOOP is both general and accurate. We are able to
detect previously unknown opaque predicates in obfuscated
binary, including more sophisticated ones such as contextual
and dynamic opaque predicates.
Concolic Testing.
Our logic-based approach is inspired by the active research
in concolic testing [13, 12, 24, 25], a hybrid software veriﬁ-
cation method combining concrete execution with symbolic
execution. Similar to SAGE [25], LOOP ﬁrst maps symbols
to inputs and then collects constraints of these symbolic in-
puts along a recorded execution trace. The diﬀerence is
our primary purpose is not for path exploration; instead we
construct formulas representing the characteristics of opaque
predicates and solve these formulas with a constraint solver.
In addition to automatic input generation, we have seen
applications of concolic testing in discovery of deviations
in binary [6], software debugging with golden implementa-
tion [4], and alleviating under-tainting problem [27]. Our
I1;I2;        PfalseI1;I1;trueI2;x = input ( );I1;I2;x = input ( );I1;y = x;while (y > 1){    if (y%2 != 0)          y = 3*y+1;    else y = y/2;}I2;766approach adopts part of the concolic testing idea in software
de-obfuscation and malware analysis.
Infeasible Path Identiﬁcation.
The eﬀect of opaque predicates is to obfuscate control ﬂow
graph with infeasible paths. In software testing, eliminat-
ing infeasible paths saves eﬀorts to generate redundant test
cases. Previous work identiﬁes infeasible paths in source
code, either by branch correlation analysis [5], pattern match-
ing [40], or monitoring the search for test data [11]. However,
these work cannot be directly used to detect opaque pred-
icates in an adversary environment, in which the program
source code under examination is typically absent. There-
fore, we believe LOOP has compelling application in identi-
fying infeasible paths in binary.
9. CONCLUSION
Opaque predicates have been widely used in software pro-
tection and malicious program to obfuscation program con-
trol ﬂow. Existing eﬀorts to detect opaque predicates are ei-
ther heuristics-based or work only on speciﬁc categories. In
this paper, we have presented LOOP, a program logic-based
and obfuscation resilient approach to the opaque predicate
detection in binary code. Our approach represents the char-
acteristics of various opaque predicates with logical formu-
las and veriﬁes them with a constraint solver. LOOP de-
tects not only simple invariant opaque predicates, but also
advanced contextual and dynamic opaque predicates. Our
experimental results show that LOOP is eﬀective in detect-
ing opaque predicates in a range of benign and obfuscated
binary programs. By diagnosing culprit branches derived
from opaque predicates in an execution trace, LOOP can
help analysts for further de-obfuscation. The experiment of
speeding up code normalization for matching metamorphic
malware variants conﬁrms the value of LOOP in malware
defenses.
10. ACKNOWLEDGMENTS
We thank the ACM CCS 2015 anonymous reviewers and
Bill Harris for their valuable feedback. This research was
supported in part by the National Science Foundation (NSF)
grants CNS-1223710 and CCF-1320605, and the Oﬃce of
Naval Research (ONR) grant N00014-13-1-0175.
11. REFERENCES
[1] H. Agrawal and J. R. Horgan. Dynamic program
slicing. ACM SIGPLAN Notices, 25(6):246–256, 1990.
[2] B. Anckaert, M. Madou, B. D. Sutter, B. D. Bus,
K. D. Bosschere, and B. Preneel. Program
obfuscation: a quantitative approach. In Proceedings
of the 2007 ACM workshop on Quality of Protection
(QoP’07), 2007.
[3] G. Arboit. A method for watermarking Java programs
via opaque predicates. In Proceedings of 5th
International Conference on Electronic Commerce
Research (ICECR-5), 2002.
[4] A. Banerjee, A. Roychoudhury, J. A. Harlie, and
Z. Liang. Golden implementation driven software
debugging. In Proceedings of the 18th ACM SIGSOFT
International Symposium on Foundations of Software
Engineering (FSE’10), 2010.
[5] R. Bod´ık, R. Gupta, and M. L. Soﬀa. Reﬁning data
ﬂow information using infeasible paths. In Proceedings
of the 5th ACM SIGSOFT International Symposium
on Foundations of Software Engineering (FSE’97),
1997.
[6] D. Brumley, J. Caballero, Z. Liang, J. Newsome, and
D. Song. Towards automatic discovery of deviations in
binary implementations with applications to error
detection and ﬁngerprint generation. In Proceedings of
16th USENIX Security Symposium, 2007.
[7] D. Brumley, I. Jager, T. Avgerinos, and E. J.
Schwartz. BAP: A binary analysis platform. In
Proceedings of the 23rd international conference on
computer aided veriﬁcation (CAV’11), 2011.
[8] D. Brumley and J. Newsome. Alias analysis for
assembly. Technical Report CMU-CS-06-180R, School
of Computer Science, Carnegie Mellon University,
2006.
[9] D. Bruschi, L. Martignoni, and M. Monga. Detecting
self-mutating malware using control-ﬂow graph
matching. In Proceedings of Detection of Intrusions
and Malware & Vulnerability Assessment
(DIMVA’06), 2006.
[10] D. Bruschi, L. Martignoni, and M. Monga. Code
normalization for self-mutating malware. IEEE
Security and Privacy, 5(2), 2007.
[11] P. M. S. Bueno and M. Jino. Identiﬁcation of
potentially infeasible program paths by monitoring the
search for test data. In Proceedings of the 15th IEEE
International Conference on Automated Software
Engineering (ASE’00), 2000.
[12] C. Cadar, D. Dunbar, and D. Engler. KLEE:
Unassisted and automatic generation of high-coverage
tests for complex systems programs. In Proceedings of
the 2008 USENIX Symposium on Operating Systems
Design and Implementation (OSDI’08), 2008.
[13] C. Cadar, V. Ganesh, P. Pawlowski, D. Dill, and
D. Engler. EXE: Automatically generating inputs of
death. In Proceedings of the 2006 ACM Conference on
Computer and Communications Security (CCS’06),
2006.
[14] J. Cappaert and B. Preneel. A general model for
hiding control ﬂow. In Proceedings of the 10th Annual
ACM Workshop on Digital Rights Management
(DRM’10), 2010.
[15] H. Chen, L. Yuan, X. Wu, B. Zang, B. Huang, and
P.-c. Yew. Control ﬂow obfuscation with information
ﬂow tracking. In Proceedings of the 42nd Annual
IEEE/ACM International Symposium on
Microarchitecture (MICRO 42), 2009.
[16] C. Collberg, G. Myles, and A. Huntwork. Sandmark–a
tool for software protection research. IEEE Security
and Privacy, 1(4):40–49, July 2003.
[17] C. Collberg, C. Thomborson, and D. Low. A
taxonomy of obfuscating transformations. Technical
report, The University of Auckland, 1997.
[18] K. Coogan, G. Lu, and S. Debray. Deobfuscation of
virtualization-obfuscated software. In Proceedings of
the 18th ACM Conference on Computer and
Communications Security (CCS’11), 2011.
[19] B. Coppens, B. De Sutter, and J. Maebe.
Feedback-driven binary code diversiﬁcation. ACM
Transactions on Architecture and Code Optimization
(TACO), 9(4), Jan. 2013.
767[20] L. Cordella, P. Foggia, C. Sansone, and M. Vento. A
[35] A. Majumdar and C. Thomborson. Securing mobile
(sub)graph isomorphism algorithm for matching large
graphs. IEEE Transactions on Pattern Analysis and
Machine Intelligence, 26(10):1367–1372, 2004.
[21] DefenseCode. Diving into recent 0day Javascript
obfuscations. http://blog.defensecode.com/2012/
10/diving-into-recent-0day-javascript.html, last
reviewed, 04/27/2015.
[22] S. Drape. Intellectual property protection using
obfuscation. Technical Report RR-10-02, Oxford
University Computing Laboratory, 2010.
[23] V. Ganesh and D. L. Dill. A decision procedure for
bit-vectors and arrays. In Proceedings of the 2007
International Conference in Computer Aided
Veriﬁcation (CAV’07), 2007.
[24] P. Godefroid, N. Klarlund, and K. Sen. DART:
Directed automated random testing. In Proceedings of
the 2005 ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI’05),
2005.
[25] P. Godefroid, M. Y. Levin, and D. Molnar. Automated
whitebox fuzz testing. In Proceedings of the 15th
Annual Network and Distributed System Security
Symposium (NDSS’08), 2008.
[26] P. Junod, J. Rinaldini, J. Wehrli, and J. Michielin.
Obfuscator-LLVM - software protection for the
masses. In Proceedings of the 1st International
Workshop on Software PROtection (SPRO’15), 2015.
[27] M. G. Kang, S. McCamant, P. Poosankam, and
D. Song. DTA++: Dynamic taint analysis with
targeted control-ﬂow propagation. In Proceedings of
the 18th Annual Network and Distributed System
Security Symposium (NDSS’11), 2011.
[28] A. Kovacheva. Eﬃcient code obfuscation for Android.
Master’s thesis, University of Luxembourg, 2013.
[29] P. Larsen, A. Homescu, S. Brunthaler, and M. Franz.
SoK: Automated software diversity. In Proceedings of
the 2014 IEEE Symposium on Security and Privacy
(SP’14), 2014.
[30] C. Linn and S. Debray. Obfuscation of executable
code to improve resistance to static disassembly. In
Proceedings of the 10th ACM Conference on Computer
and Communications Security (CCS’03), 2003.
[31] L. Liu, J. Ming, Z. Wang, D. Gao, and C. Jia.
Denial-of-service attacks on host-based generic
unpackers. In Proceedings of the 11th International
Conference on Information and Communications
Security (ICICS’09), 2009.
[32] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. J. Reddi, and
K. Hazelwood. Pin: building customized program
analysis tools with dynamic instrumentation. In
Proceedings of the 2005 ACM SIGPLAN conference
on Programming language design and implementation
(PLDI’05), 2005.
[33] M. Madou. Application Security through Program
Obfuscation. PhD thesis, Ghent University, 2007.
[34] M. Madou, L. Van Put, and K. De Bosschere. LOCO:
An interactive code (de)obfuscation tool. In
Proceedings of the 2006 ACM SIGPLAN Symposium
on Partial Evaluation and Semantics-based Program
Manipulation (PEPM’06), 2006.
agents control ﬂow using opaque predicates. In
Proceedings of the 9th International Conference on
Knowledge-Based Intelligent Information and
Engineering Systems (KES’05), 2005.
[36] J. Ming, M. Pan, and D. Gao. iBinHunt: Binary
hunting with inter-procedural control ﬂow. In
Proceedings of the 15th Annual International
Conference on Information Security and Cryptology
(ICISC’12), 2012.
[37] A. Moser, C. Kruegel, and E. Kirda. Limits of static
analysis for malware detection. In Proceedings of the
23th Annual Computer Security Applications
Conference (ACSAC’07), December 2007.
[38] L. D. Moura and N. Bjørner. Z3: an eﬃcient SMT
solver. In Proceedings of the 14th International
Conference on Tools and Algorithms for the
Construction and Analysis of Systems, 2008.
[39] G. Myles and C. Collberg. Software watermarking via
opaque predicates: Implementation, analysis, and
attacks. Electronic Commerce Research, 6(2):155 –
171, April 2006.
[40] M. N. Ngo and H. B. K. Tan. Detecting large number
of infeasible paths through recognizing their patterns.
In Proceedings of the the 6th Joint Meeting of the
European Software Engineering Conference and the
ACM SIGSOFT Symposium on the Foundations of
Software Engineering (ESEC-FSE’07), 2007.
[41] J. Palsberg, S. Krishnaswamy, M. Kwon, D. Ma,
Q. Shao, and Y. Zhang. Experience with software
watermarking. In Proceedings of the 16th Annual
Computer Security Applications Conference
(ACSAC’00), 2000.
[42] M. D. Preda, M. Madou, K. D. Bosschere, and
R. Giacobazzi. Opaque predicate detection by abstract
interpretation. In Proceedings of 11th International
Conference on Algebriac Methodology and Software
Technology (AMAST’06), 2006.
[43] N. A. Quyn. OptiCode: Machine code deobfuscation
for malware analysis. In Proceedings of the 2013
SyScan, 2013.
[44] P. Szor. The Art of Computer Virus Research and
Defense. Addison-Wesley Professional, February 2005.
[45] S. K. Udupa, S. K. Debray, and M. Madou.
Deobfuscation: Reverse engineering obfuscated code.
In Proceedings of the 12th Working Conference on
Reverse Engineering (WCRE’05), 2005.
[46] C. Wang, J. Hill, J. C. Knight, and J. W. Davidson.
Protection of software-based survivability mechanisms.
In Proceedings of the 2001 International Conference
on Dependable Systems and Networks (DSN’01), 2001.
[47] S. Wang, P. Wang, and D. Wu. Reassembleable
disassembling. In Proceedings of the 24th USENIX
Security Symposium (USENIX Security’15), 2015.
[48] Z. Wang, J. Ming, C. Jia, and D. Gao. Linear
obfuscation to combat symbolic execution. In
Proceedings of the 2011 European Symposium on
Research in Computer Security (ESORICS’11), 2011.
[49] F. Zhang, D. Wu, P. Liu, and S. Zhu. Program logic
based software plagiarism detection. In Proceedings of
the 25th IEEE International Symposium on Software
Reliability Engineering (ISSRE’14), 2014.
768