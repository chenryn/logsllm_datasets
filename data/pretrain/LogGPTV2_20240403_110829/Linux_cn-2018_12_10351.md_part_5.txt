##### 中断规则
外部中断（即：设备中断）被称为 IRQ。现在有 16 个可能出现的 IRQ，编号 0 到 15。从 IRQ 号到 IDT 条目的映射是不固定的。在 `picirq.c` 中的 `pic_init` 映射 IRQ 0 - 15 到 IDT 条目 `IRQ_OFFSET` 到 `IRQ_OFFSET+15`。
在 `inc/trap.h` 中，`IRQ_OFFSET` 被定义为十进制的 32。所以，IDT 条目 32 - 47 对应 IRQ 0 - 15。例如，时钟中断是 IRQ 0，所以 IDT[IRQ\_OFFSET+0]（即：IDT[32]）包含了内核中时钟中断服务程序的地址。这里选择 `IRQ_OFFSET` 是为了处理器异常不会覆盖设备中断，因为它会引起显而易见的混淆。（事实上，在早期运行 MS-DOS 的 PC 上， `IRQ_OFFSET` 事实上是 0，它确实导致了硬件中断服务程序和处理器异常处理之间的混淆！）
在 JOS 中，相比 xv6 Unix 我们做了一个重要的简化。当处于内核模式时，外部设备中断总是被关闭（并且，像 xv6 一样，当处于用户空间时，再打开外部设备的中断）。外部中断由 `%eflags` 寄存器的 `FL_IF` 标志位来控制（查看 `inc/mmu.h`）。当这个标志位被设置时，外部中断被打开。虽然这个标志位可以使用几种方式来修改，但是为了简化，我们只通过进程所保存和恢复的 `%eflags` 寄存器值，作为我们进入和离开用户模式的方法。
处于用户环境中时，你将要确保 `FL_IF` 标志被设置，以便于出现一个中断时，它能够通过处理器来传递，让你的中断代码来处理。否则，中断将被屏蔽或忽略，直到中断被重新打开后。我们使用引导加载程序的第一个指令去屏蔽中断，并且到目前为止，还没有去重新打开它们。
> 
> **练习 13**、修改 `kern/trapentry.S` 和 `kern/trap.c` 去初始化 IDT 中的相关条目，并为 IRQ 0 到 15 提供服务程序。然后修改 `kern/env.c` 中的 `env_alloc()` 的代码，以确保在用户环境中，中断总是打开的。
> 
> 
> 另外，在 `sched_halt()` 中取消注释 `sti` 指令，以便于空闲的 CPU 取消屏蔽中断。
> 
> 
> 当调用一个硬件中断服务程序时，处理器不会推送一个错误代码。在这个时候，你可能需要重新阅读 [80386 参考手册](https://pdos.csail.mit.edu/6.828/2018/labs/readings/i386/toc.htm) 的 9.2 节，或 [IA-32 Intel 架构软件开发者手册 卷 3](https://pdos.csail.mit.edu/6.828/2018/labs/readings/ia32/IA32-3A.pdf) 的 5.8 节。
> 
> 
> 在完成这个练习后，如果你在你的内核上使用任意的测试程序去持续运行（即：`spin`），你应该会看到内核输出中捕获的硬件中断的捕获帧。虽然在处理器上已经打开了中断，但是 JOS 并不能处理它们，因此，你应该会看到在当前运行的用户环境中每个中断的错误属性并被销毁，最终环境会被销毁并进入到监视器中。
> 
> 
> 
##### 处理时钟中断
在 `user/spin` 程序中，子环境首先运行之后，它只是进入一个高速循环中，并且内核再无法取得 CPU 控制权。我们需要对硬件编程，定期产生时钟中断，它将强制将 CPU 控制权返还给内核，在内核中，我们就能够将控制权切换到另外的用户环境中。
我们已经为你写好了对 `lapic_init` 和 `pic_init`（来自 `init.c` 中的 `i386_init`）的调用，它将设置时钟和中断控制器去产生中断。现在，你需要去写代码来处理这些中断。
> 
> **练习 14**、修改内核的 `trap_dispatch()` 函数，以便于在时钟中断发生时，它能够调用 `sched_yield()` 去查找和运行一个另外的环境。
> 
> 
> 现在，你应该能够用 `user/spin` 去做测试了：父环境应该会 fork 出子环境，`sys_yield()` 到它许多次，但每次切换之后，将重新获得对 CPU 的控制权，最后杀死子环境后优雅地终止。
> 
> 
> 
这是做回归测试的好机会。确保你没有弄坏本实验的前面部分，确保打开中断能够正常工作（即： `forktree`）。另外，尝试使用 `make CPUS=2 target` 在多个 CPU 上运行它。现在，你应该能够通过 `stresssched` 测试。可以运行 `make grade` 去确认。现在，你的得分应该是 65 分了（总分为 80）。
#### 进程间通讯（IPC）
（严格来说，在 JOS 中这是“环境间通讯” 或 “IEC”，但所有人都称它为 IPC，因此我们使用标准的术语。）
我们一直专注于操作系统的隔离部分，这就产生了一种错觉，好像每个程序都有一个机器完整地为它服务。一个操作系统的另一个重要服务是，当它们需要时，允许程序之间相互通讯。让程序与其它程序交互可以让它的功能更加强大。Unix 的管道模型就是一个权威的示例。
进程间通讯有许多模型。关于哪个模型最好的争论从来没有停止过。我们不去参与这种争论。相反，我们将要实现一个简单的 IPC 机制，然后尝试使用它。
##### JOS 中的 IPC
你将要去实现另外几个 JOS 内核的系统调用，由它们共同来提供一个简单的进程间通讯机制。你将要实现两个系统调用，`sys_ipc_recv` 和 `sys_ipc_try_send`。然后你将要实现两个库去封装 `ipc_recv` 和 `ipc_send`。
用户环境可以使用 JOS 的 IPC 机制相互之间发送 “消息” 到每个其它环境，这些消息有两部分组成：一个单个的 32 位值，和可选的一个单个页映射。允许环境在消息中传递页映射，提供了一个高效的方式，传输比一个仅适合单个的 32 位整数更多的数据，并且也允许环境去轻松地设置安排共享内存。
##### 发送和接收消息
一个环境通过调用 `sys_ipc_recv` 去接收消息。这个系统调用将取消对当前环境的调度，并且不会再次去运行它，直到消息被接收为止。当一个环境正在等待接收一个消息时，任何其它环境都能够给它发送一个消息 — 而不仅是一个特定的环境，而且不仅是与接收环境有父子关系的环境。换句话说，你在 Part A 中实现的权限检查将不会应用到 IPC 上，因为 IPC 系统调用是经过慎重设计的，因此可以认为它是“安全的”：一个环境并不能通过给它发送消息导致另一个环境发生故障（除非目标环境也存在 Bug）。
尝试去发送一个值时，一个环境使用接收者的 ID 和要发送的值去调用 `sys_ipc_try_send` 来发送。如果指定的环境正在接收（它调用了 `sys_ipc_recv`，但尚未收到值），那么这个环境将去发送消息并返回 0。否则将返回 `-E_IPC_NOT_RECV` 来表示目标环境当前不希望来接收值。
在用户空间中的一个库函数 `ipc_recv` 将去调用 `sys_ipc_recv`，然后，在当前环境的 `struct Env` 中查找关于接收到的值的相关信息。
同样，一个库函数 `ipc_send` 将去不停地调用 `sys_ipc_try_send` 来发送消息，直到发送成功为止。
##### 转移页
当一个环境使用一个有效的 `dstva` 参数（低于 `UTOP`）去调用 `sys_ipc_recv` 时，环境将声明愿意去接收一个页映射。如果发送方发送一个页，那么那个页应该会被映射到接收者地址空间的 `dstva` 处。如果接收者在 `dstva` 已经有了一个页映射，那么已存在的那个页映射将被取消映射。
当一个环境使用一个有效的 `srcva` 参数（低于 `UTOP`）去调用 `sys_ipc_try_send` 时，意味着发送方希望使用 `perm` 权限去发送当前映射在 `srcva` 处的页给接收方。在 IPC 成功之后，发送方在它的地址空间中，保留了它最初映射到 `srcva` 位置的页。而接收方也获得了最初由它指定的、在它的地址空间中的 `dstva` 处的、映射到相同物理页的映射。最后的结果是，这个页成为发送方和接收方共享的页。
如果发送方和接收方都没有表示要转移这个页，那么就不会有页被转移。在任何 IPC 之后，内核将在接收方的 `Env` 结构上设置新的 `env_ipc_perm` 字段，以允许接收页，或者将它设置为 0，表示不再接收。
##### 实现 IPC
> 
> **练习 15**、实现 `kern/syscall.c` 中的 `sys_ipc_recv` 和 `sys_ipc_try_send`。在实现它们之前一起阅读它们的注释信息，因为它们要一起工作。当你在这些程序中调用 `envid2env` 时，你应该去设置 `checkperm` 的标志为 0，这意味着允许任何环境去发送 IPC 消息到另外的环境，并且内核除了验证目标 envid 是否有效外，不做特别的权限检查。
> 
> 
> 接着实现 `lib/ipc.c` 中的 `ipc_recv` 和 `ipc_send` 函数。
> 
> 
> 使用 `user/pingpong` 和 `user/primes` 函数去测试你的 IPC 机制。`user/primes` 将为每个质数生成一个新环境，直到 JOS 耗尽环境为止。你可能会发现，阅读 `user/primes.c` 非常有趣，你将看到所有的 fork 和 IPC 都是在幕后进行。
> 
> 
> 
.
> 
> **小挑战！**为什么 `ipc_send` 要循环调用？修改系统调用接口，让它不去循环。确保你能处理多个环境尝试同时发送消息到一个环境上的情况。
> 
> 
> 
.
> 
> **小挑战！**质数筛选是在大规模并发程序中传递消息的一个很巧妙的用法。阅读 C. A. R. Hoare 写的 《Communicating Sequential Processes》，Communications of the ACM\_ 21(8) (August 1978)， 666-667，并去实现矩阵乘法示例。
> 
> 
> 
.
> 
> **小挑战！**控制消息传递的最令人印象深刻的一个例子是，Doug McIlroy 的幂序列计算器，它在 [M. Douglas McIlroy，《Squinting at Power Series》，Software–Practice and Experience， 20(7) (July 1990)，661-683](https://swtch.com/%7Ersc/thread/squint.pdf) 中做了详细描述。实现了它的幂序列计算器，并且计算了 sin ( x + x  3) 的幂序列。
> 
> 
> 
.
> 
> **小挑战！**通过应用 Liedtke 的论文（[通过内核设计改善 IPC 性能](http://dl.acm.org/citation.cfm?id=168633)）中的一些技术、或你可以想到的其它技巧，来让 JOS 的 IPC 机制更高效。为此，你可以随意修改内核的系统调用 API，只要你的代码向后兼容我们的评级脚本就行。
> 
> 
> 
**Part C 到此结束了。**确保你通过了所有的评级测试，并且不要忘了将你的小挑战的答案写入到 `answers-lab4.txt` 中。
在动手实验之前， 使用 `git status` 和 `git diff` 去检查你的更改，并且不要忘了去使用 `git add answers-lab4.txt` 添加你的小挑战的答案。在你全部完成后，使用 `git commit -am 'my solutions to lab 4’` 提交你的更改，然后 `make handin` 并关注它的动向。
---
via: 
作者：[csail.mit](https://pdos.csail.mit.edu) 选题：[lujun9972](https://github.com/lujun9972) 译者：[qhwdw](https://github.com/qhwdw) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出