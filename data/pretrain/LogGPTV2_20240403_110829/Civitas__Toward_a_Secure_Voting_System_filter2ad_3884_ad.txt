blocking, O(BM 2) PETs are required, where B = (cid:98) V
K(cid:99)
is the number of blocks, V is the number of voters, K is
the minimum number of voters per block, and M is the
maximum number of votes submitted in a block. Like-
wise, blocking reduces invalid credential elimination from
is halved. By a result of Gomułkiewicz et al. [34], the revealed information
can be made statistically small by requiring each teller to perform a total
of ﬁve permutations. We estimate this would increase tabulation time by
at most 3%. Mix networks based on zero-knowledge proofs [32, 57] would
improve anonymity at the cost of more expensive veriﬁcation.
20The presence of invalid credentials is an information channel. For ex-
ample, if there are zero invalid credentials, then no voter submitted a vote
with a fake credential. The adversary could detect this from the PET results
posted on the bulletin board. To eliminate this channel, each teller could
post a random number of votes with invalid credentials.
361
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:14:20 UTC from IEEE Xplore.  Restrictions apply. 
Table 1. Modular exponentiations per block
Agent Action
RT
Voter
TT
Generate all credentials
Distribute all credentials
Retrieve a credential
Vote
Retrieve data
Verify proofs
Eliminate duplicates
Anonymize (mixes)
Eliminate invalids
Decrypt
Protocol
4K
14K
12A
4C + 7
–
(cid:1)(8A − 1)
4M (C + 1)
(cid:0)M
2
2(A + 1)(M + K)
KM (8A − 1)
K(4A − 1)
BB
K
–
A
–
AK + A + 1
–
3A
2A
3A
A
O(V N) PETs to O(BKM). The B factor in each of these
terms is easily parallelizable, since a different set of ma-
chines can be used to implement the tabulation tellers for
each block. Tabulation time then depends on M and K, but
not V . Therefore performance can scale independently of
the number of voters.
Table 1 identiﬁes the number of modular exponentiations
performed per block by individual agents: registration tellers
(RT), tabulation tellers (TT), and voters. (Tabulation time
is dominated by modular exponentiations.) The table dis-
tinguishes protocol exponentiations, which are required by
the Civitas voting scheme regardless of the implementation
of the bulletin board, from bulletin board (BB) exponenti-
ations, which are required by the particular implementation
used in our prototype. BB exponentiations result from RSA
signatures and veriﬁcations. Exponentiations are counted
under the assumption that there are no duplicate votes and
that no voters abstain, maximizing the number of PETs re-
quired. Parameter A describes the number of election au-
thorities of each kind—i.e., if A = 4, then there are four reg-
istration tellers, four tabulation tellers, and four ballot boxes.
Regardless of A, there is a single bulletin board. Table 1 as-
sumes a plurality ballot with C candidates.
7. Implementation in Jif
Our prototype of Civitas is implemented in JifE [15], an ex-
tension of Jif 3.0 [54,56]. Jif is a security-typed language in
which programs are annotated with information-ﬂow secu-
rity policies. The Jif compiler and runtime guarantee end-to-
end enforcement of these polices. Information-ﬂow policies
control both the release and propagation of information, en-
abling the protection of both sensitive data and data derived
therefrom. Information-ﬂow policies are therefore stronger
than access control policies, which control only the release
of information.
Jif security policies are expressed using the decentralized
label model [55], which allows speciﬁcation of conﬁdential-
ity and integrity requirements of principals. Such policies
are useful for constructing systems like Civitas, in which
principals need to cooperate yet are mutually distrusting.
For example, if information is labeled with conﬁdentiality
policy RT1(cid:1) voter76, then principal RT1 permits principal
labeled with integrity policy TT3(cid:0) Sup, then principal TT3
voter76 to learn the information; such a policy would be
suitable for the private credential share generated by regis-
tration teller RT1 for voter76. Similarly, if information is
requires that only principal Sup has inﬂuenced the informa-
tion; such a policy would be suitable for the ballot design,
which only the supervisor may specify.
In general, a principal p may specify a set R of readers in
conﬁdentiality policy p(cid:1) R. JifE extends Jif with declassi-
ﬁcation and erasure policies [16], which allow principals to
state conditions on when the set of readers in a conﬁdential-
ity policy may be changed.
Declassiﬁcation policies allow the set of readers of infor-
mation to be expanded. For example, in the implementation
of mix networks, each tabulation teller must commit to ran-
dom bits. The bits are then revealed and used to verify the
mix. The security of the mix requires maintaining the se-
crecy of these bits until all tellers have committed. In the
code, this requirement is expressed using a declassiﬁcation
policy. The policy annotating the variable storing the ran-
dom bits of TTi indicates that the information is readable
only by TTi until condition AllCommitted is satisﬁed, upon
which the information may be declassiﬁed to be readable by
all principals. AllCommitted becomes true at the program
point where all commitments have been received.
Erasure policies mandate conditions upon which the set
of readers must be restricted. For example, each registration
teller must store a private credential share for each voter un-
til the voter requests it. After this, the teller may erase the
share, ensuring that the share cannot later be disclosed.21 In
21Erasure is a design choice that impacts recovery from voters’ accidental
loss or deletion of credentials. If tellers do not erase shares, then tellers
can reissue credentials. But if tellers do erase shares, then reissue is not
possible. Instead, tellers would need to revoke lost shares and issue new
shares. This is left as future work.
362
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:14:20 UTC from IEEE Xplore.  Restrictions apply. 
Table 2. Lines of JifE code per component
LOC
Component
5,740
Tabulation teller
3,173
Common
Registration teller
1,290
1,138
Supervisor
911
Log service (bulletin board and ballot box)
826
Voter client
Registrar
308
13,386
Total
the code, the variable storing the share is annotated with an
erasure policy indicating that this information becomes un-
readable by all principals when condition Delivered is sat-
isﬁed. Delivered becomes true at the program point where
receipt of the share has been acknowledged by the voter. The
JifE compiler inserts code at that point to erase the informa-
tion from memory.
Our implementation of Civitas totals about 13,000 lines
of JifE code. Table 2 gives the number of lines of code in
each component; common code includes shared data struc-
tures and utility methods for retrieving and caching election
information. About 8,000 additional lines of Java code are
used to perform I/O and to implement number-theoretic op-
erations such as encryption and zero-knowledge proofs.
8. Performance
A voting system is practical only if tabulation can be com-
pleted in reasonable time, with reasonable cost and secu-
rity. Civitas offers a tradeoff between these three factors,
because tabulation can be completed more quickly by ac-
cepting higher cost or lower security.
Notions of reasonable time, cost, and security may dif-
fer depending on the election or the observer.
In current
U.S. elections, accurate predictions of election results are
available within a few hours. Therefore, we chose a target
tabulation time of ﬁve hours. The two most important pa-
rameters affecting security are K, the minimum number of
voters within each block, and A, the number of authorities of
each kind.22 As reasonable values for these parameters, we
chose K = 100 and A = 4. Anonymity within 100 voters
seems comparable to what is available in current real-world
elections, where results are tabulated at a precinct level and
observers might correlate voters with ballots.23 Similarly,
four mutually distrusting authorities might offer better over-
sight than real-world elections.
22Recall from Section 6 that if A = 4, then there are four registration
tellers, four tabulation tellers, and four ballot boxes.
23Random block assignment might even offer stronger anonymity than
real-world elections.
Experiment design. We used Emulab [74] as an experi-
ment testbed. The experiments ran on machines containing
3.0 GHz Xeon processors and 1 GB of RAM, networked on
a 1 Gb LAN. Note that only tabulation tellers actually need
hardware this fast, whereas voters could use substantially
less powerful hardware without impacting performance or
the voting experience. Our machines ran Red Hat Linux 9.0
and Java 1.5.0 11. For RSA, AES, and SHA implementa-
tions, we used Bouncy Castle JCE provider 1.33. We imple-
mented the remaining cryptographic functionality, including
El Gamal and zero-knowledge proofs, ourselves. We used a
C library, GMP 4.2.1, for implementations of modular expo-
nentiation and multiplication.
Key lengths were chosen to meet or exceed NIST rec-
ommendations for 2011–2030 [3]. We used 128-bit AES
keys, 2048-bit RSA keys, and 224-bit El Gamal keys from a
2048-bit group—i.e., |p| = 2048 and |q| = 224. A modular
exponentiation in this size group required about 3.7 ms.
Each experiment simulated all phases of a complete elec-
tion, including all the cryptographic protocols in Section 5.
Therefore the results should be representative of a real de-
ployment. All experiments used plurality ballots with three
candidates. No voters abstained, so N ≥ V and M ≥ K.24
Experiments were repeated three times, and we report the
sample mean. The sample standard deviation was always
less than 2% of the mean.
Setup and voting time. Generation of keys and creden-
tials scales linearly in the number of authorities and voters,
respectively, and can be conducted ofﬂine. During the vot-
ing phase, voters retrieve credential shares from registration
tellers and submit votes to ballot boxes. A voter client takes
about 325 ms to acquire a credential share from a registration
teller, and about 20 ms to submit a vote to a ballot box. Thus,
for four authorities, it takes a voter less than 1.4 seconds to
retrieve credentials and submit a vote. From the registra-
tion teller’s perspective, it takes about 200 ms of CPU time
to distribute a single voter’s credential share. A registration
teller could therefore process 18,000 voters per hour.
Tabulation time and space. Figure 2(a) shows the re-
sults of four tabulation tellers processing blocks sequen-
tially, where V is a multiple of K. The data indicate that
Civitas requires 39 seconds per voter per authority to tabu-
late a single block, and that votes from 500 voters, in blocks
of 100, can be tabulated in ﬁve hours. (The time to com-
bine the block tallies is negligible.) Parameters A and K
have non-linear effects on tabulation time, as shown in Fig-
ure 2(b) and Figure 2(c). Communication increases quadrat-
ically in A, and PETs take time proportional to K 2. Fig-
ure 2(c) indicates that a block of 200 voters can be tabulated
in less than ﬁve hours.
24Recall that N is the number of votes submitted and M is the maximum
number of votes submitted in a block.
363
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:14:20 UTC from IEEE Xplore.  Restrictions apply. 
(a)
(c)
(b)
(d)
Figure 2. Tabulation time vs. (a) Voters: K = 100, A = 4; (b) Authorities: K = V = 100; (c) Anonymity:
V = K, A = 4; (d) Chaff: K = V = 100, A = 4
The independence of blocks can be exploited to decrease
tabulation time by processing blocks in parallel. Given a set
of tabulation teller machines for each block, the data in Fig-
ure 2(a) predict that tabulation could be completed in about
65 minutes, independent of V . Because of the linear trade-
off between time and machines at the granularity of blocks,
the remaining measurements in this study are for tabulation
of a single block.
The memory footprint of Civitas is very small. With
M = 100, the active set of a tabulation teller is never more
than 8 MB. The size of the active set scales linearly in M, so
modern machines could easily ﬁt tabulation in memory for
substantially larger values of M (and of K, since K ≤ M).
The storage space needed for the entire bulletin board is less
than 620 MB for an election where K = 100, V = 100, and