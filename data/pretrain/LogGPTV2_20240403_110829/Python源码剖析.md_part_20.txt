void Excute()
好了，我们的SmallPython儿乎已经完成了，最后所缺的就是一个交互式环境：
在这里，通过变量名symbol，获得了变量值object。而在刚才的ExcueteAdd中，
第6章
void
Pyobject*GetobjectBysymbol(string& symbol)
cout
cout print(obiect):
最简单的Python模拟
TeturnNULL;
Excutecommand (m_Command):
returny
continue;
prompt,
>
>>>printc
a+=>>b=
R<<
**********PythonResearch**********
C:1WINDOWSisystem321cmd.exe
s3=s1+s2
s2
心
Python源码剖析
6.4
深度探索动态语言核心技术
交互式环境
109
---
## Page 141
Python虚拟机
第2部分
---
## Page 143
7.1Python程序的执行过程
文件是怎样转换成一系列的机器指令并被执行的呢？
只要完成这些动作，Pyhon程序就如我们所预期的那样开始工作，那么，一个文本方式的.py
进行系统管理工作。要运行这些程序，我们或者是双击文件图标（Windows平台），或者
时，首先进行的动作都是先对文件中的Pyhon源代码进行编译，编译的主要结果是产生
Python程序。在真正开始执行之前，实际上，Python的解释器还要完成一个非常复杂的工
my-program.py执行一个特定的Python程序时，Python解释器立即被激活，然后执行
当我们在命令行下敲入python时，目的就是为了激活这个解释器。当我们通过python
与Java和C#是一样的，Pyhon程序的执行原理和Java程序、C#程序的执行原理都可以用
说法是不正确的，实际上，尽管Python不如Java，C#一样出身名门，但是Python的本质
们都有所耳闻，因为坊间广泛地流传着这样一种说法：Pyton是一种解释性的语言。这种
作一
两个词囊括一
事实上，py文件中的Pyhon语句并没有被转换成一系列的机器指令。这一点可能我
平时我们可能每天都会写一些这样或那样的Pyhon程序，或者是处理文本，或者是
编译.py文件。
我们知道，Pyton有一个非常核心的东西，这个东西通常被称为解释器（interpreter）
编译？没错，确实是编译。实际上，Python解释器在执行任何一个Pyhon程序文件
一虚拟机、字节码。
-Code对象与pyc文件
Python的编译结果
Python源码剖析
一深度探索动态语言核心技术
第
CHAPTER
V
---
## Page 144
Python源码剖析
114
可以这么说，Pyhon虚拟机是一种抽象层次更高的虚拟机。
能更强大、更拽，而是说与Java或.NET相比，Pyhon的虚拟机距离真实机器更远。或者
种更高级的虚拟机。这里的高级不是说Pyhon的虚拟机的功能比Java和NET虚拟机的功
的虚拟机与Java和NET虚拟机还有不同之处。
program.pyc对应program.class，这个过程与Python执行程序的过程实际是完全一致的。
对programjava进行编译，产生一个program.class文件，最后调用java命令执行
Python的编译器和虚拟机都藏身于这个python25.dll中，在安装Python的时候，安装程序
python25.dll 既当爹，又当妈，既完成了编译器的工作，又完成了虚拟机的工作。没错，
执行过程：
下一个编译器外带一个虚拟机吧。听，别着急，我们先通过图7-1来看一看Python程序的
如果你仔细观察过python.exe，你会发现这个可执行程序仅仅只有24KB，不太可能容纳
作。那么这些Python的编译器还有Python的虚拟机在什么地方呢？难道在pyhon.exe中？
Machine），由虚拟机按照顺序一条一条地执行字节码，从而完成对Python程序的执行动
一组Python的bytecode（字节码），然后将编译的结果交给Python的虚拟机（Virtual
下。
第7章Python的编译结果
虽然Python程序执行的机理与Java程序和C#程序的执行机理是一样的，但是Python
对比一下Java程序，首先我们会有一个program.java的Java源程序，然后，用javac
细心的你一定发现了，
program.py
一深度探索动态语言核心技术
python25.dll
编译
，我在编译和执行的地方都放上了一个python25.dll，似乎
图7-1Python程序的执行过程
Code对象与pyc文件
program.pyc
一个最大的不同是，Python的虚拟机是一
python25.dll
执行
执行结果
---
## Page 145
7.2.1
7.2
后，编译结果又被保存到了pyc文件中。当下一次运行相同的程序时，Python会根据pyc
式，它们实际上是Pyhon对源文件编译的结果的两种不同存在方式。
PyCodeobject对象才是其真正的编译结果，而pyc文件只是这个对象在硬盘上的表现形
文件中，正襟危坐的其实是一个PyCodeObject对象，对于Python编译器来说，
件中。这个对象和文件就是我们这章探索的重点：PyCodeobject对象和pye文件。
象中，当Pyhon运行结束后，这个运行时对象中所包含的信息甚至还会被存储在一种文
息。在Pyhon运行期间，这些源文件中提供的静态信息最终会被存储在一个运行时的对
来，编译的结果中包含了字符串，常量值，字节码等在源代码中出现的一切有用的静态信
的编译结果就是字节码。那么Pyhon的编译过程对字符串和常量值的处理结果是什么呢？
们可以看到，其中包含了一些字符串，一些常量值，还有一些操作。当然，Pyhon对操作
运行的时候所必需的。
下去了。然而除了字节码之外，编译的结果中还应包含其他一些信息，这些信息也是Pyhon
译，编译的结果是什么呢？当然有字节码，否则接下来的Pyon虚拟机也就没办法再玩
个源文件被Pyhon编译器编译之后究竟应该产生一些什么结果。
际上是不太准确的。下面我们先通过考察一个简单的Pyhon程序源文件来猜测一下，一
def Fun(:
[demo.py]
=A(）
Python编译器的编译结果
在程序运行期间，编译结果存在于内存的PyCodeobject对象中：而Python结束运行
从上面的描述中，可以看出，尽管图7-1中编译的结果是一个pyc文件，但是在pyc
在编译过程中，这些包含在Pyton源代码中的静态信息都会被Pyhon编译器收集起
看一下demo.py，让我们充当Python编译器，用肉眼来解析一下，从这个文件中，我
现在我们已经知道，Python在执行demo.py时，首先需要进行的动作就是对其进行编
在图7-1中可以看到，Pyhon对源程序的编译结果是生成了一个.pyc文件，然而这实
PyCodeObject对象与pyc文件
pass
DaSS
7.2Python编译器的编译结果
Python源码剖析
-PyCodeObject对象
PyCodeObject对象
深度探索动态语言核心技术
115
---
## Page 146
7.2.2
Python源码剖析
116
后的剖析中，我们会一步一步将PyCedeObject的各个域里都包含了哪些信息全挖掘出来。
理解Pyhon虚拟机的运行行为，必须要彻底地理解Python的编译结果一
中描述的过程没有太多的区别。我们把关注的重点放在Pyton的编译结果上，要彻底地
编译了
表的CodeBlock，而最后一个是对应defFun所代表的CodeBlcok。
创建3个PyCodeObject对象，一个是对应demo.py整个文件的，一个是对应classA所代
作用域时，我们就算是进入了一个新的CodeBlock了。
Block呢？事实上，Python有一个简单而清晰的规则：当进入一个新的名字空间，或者说
会创建一个PyCodeobject对象与这段代码对应。那么如何确定多少代码算是一个Code
这里可以稍稍透露一下，在co_code域存放的就是编译所生成的字节码指令序列。
typedef struct
[code.h]
Python源码中的PyCodeObject
回顾一下上一节的demo.py文件，在Python编译器对源代码完成编译之后，总共会
Python编译器在对Python源代码进行编译的时候，对于代码中的一个CodeBlock
PyCodeobject对象中的各个域各包含了什么信息，我们现在可以暂时不理会，在以
ByCodeobject
先来看一看在Python源码中对PyCodeObject的声明：
对Python的编译过程，我们不做过多的剖析，毕竞，Python的编译过程和编译原理
第7章Python的编译结果
void
Pyobjeot
Pyobjeet
Pyobi
Pyobject
Pyobject
Pyobi
PyObjectHmAD
Byobject
PVObT
nt
北
co_flags;
costacksize;
CO
colargcoumit;
*co_zombieframe /Eoz optimization only
lect
iegt
ecb
深度探索动态语言核心技术
nlocals;
*co_filename;
kco names;
cellvars;
consts
code;
name:
CO
Code对象与pyc文件
for hash/cmp
#entries needed forevaluation stack*/
#arouments,
serinc
Eirst
Si
string
maist
rana
TISE
img
tuple
(constantsused)
source line number
of
of strings （cell variable names)
strings
except
(local variable names)*/
args*/
TBA
lcel
-PyCodeobject.
---
## Page 147
7.2.3pyc文件
编译成相应的 PyCodeobject的中间结果，然后创建abc.pyc文件，并将中间结果写入该
或abc.dll文件，如果没有这些文件，而只是发现了abc.py，那么Python会首先将abc.py
程中，如果碰到importabc这样的语句，那么Python将到设定好的path中寻找abo.pyc
Python会为其产生pyc文件了。
说在demo.py中对demo.py进行一个importdemo的动态加载动作之后，你就会发现，
PyCodeobject对象，这样下次Python就不会再次进行编译了。当在另外一个程序，比如
demo.py这样的形式执行的程序，Python就不会存储编译结果了。
后就再也没用了，所以也就没有保存其对应的pyc文件的必要，因此，对于直接用python
些琐碎的工作，比如统计某个特定文件中的词频信息，这样的程序可能仅仅运行一次，然
原因不得而知，不过我们可以做出一个合理的猜测：有一些Pyhon程序只是临时完成一
对象一起存储在pyc文件中。但不幸的是，事实并不总是这样。试着在命令行下执行一下
编译后得到的bytecode序列。前面我们提到，Python会将这些字节码序列和pyCodeobject
的编译后，
间。因此，都会有一个PyCodeObject对象与其对应。所以，demo.py经过Python编译器
一个PyCodeObject对象。在Python中，类、函数、module都对应着一个独立的名字空
我们需要记住的是，
入，你一定会对名字空间以及Pyhon在名字空间链上的行为有越来越深刻的理解。现在
间消耗在从这条名字空间链中确定一个符号所对应的对象是什么。
以一个套一个地形成一条名字空间链，Pyhon虚拟机在执行的过程中，会有很大一部分时
符号只可能有一种意义，a要么是PyIntobject，要么是pyStringobect。名字空间可
在另一个名字空间中，它则可能是一个eyStringobject对象。在一个名字空间中，一个
什么，在Pyhon中，这并不是确定的，而是需要通过名字空间来决定。
号的上下文环境，符号的含义取决于名字空间。更具体地说，
这意味着Python的import机制会触发pyc文件的生成。实际上，在Python运行的过
但是假如说demo.py中实现的是一个需要被重用的类时，我们就希望能存储其对应的
每一个PyCodeobject对象中都包含了每一个CodeBlock中所有Python源代码经过
对于某个符号，比如说a在某个名字空间中，它可能是一个pyIntobject对象：而
如果你现在对名字空间的概念还不是太明了，不要紧，随着对Pyhon源码剖析的深
在这里，我们开始提及Pyhon中一个至关重要的概念一
一共得到3个PyCodeObject对象。
一个我们前面所说的CodeBlock，就对应着一个名字空间，它会对应
7.2Python编译器的编译结果
Python源码剖析
PyCodeObject对象
一个变量名对应的变量值是
一深度探索动态语言核心技术
名字空间名字空间是符
117
---
## Page 148
Python源码剖析
118
体意义
含义，这一点是无论如何不能绕过去的。表7-1列出了PyCodeobject对象中各个域的具
节流就至关重要了。这也就是我们所关心的pyc文件的格式。
示的generator.py来创建上面那段代码（CodeObjecttpy）对应的pyc文件。
这些方法间没有什么优劣之分，不过我们在这里选用impornt机制罢了。很容易利用下面所
对应的pyc文件有很多种方法，比如利用Python标准库中的py_compile、compiler工具。
用Python内建的impmodule来完成对生成pyc文件的触发。当然，为了得到一个py文件
文件中的pyCodeObject重新在内存中复制出来。
文件。接下来，Python才会对abc.pyc文件进行import的动作，实际上也就是将abc.pyc
co_argcount
Field
主面
def generate_pyc(name):