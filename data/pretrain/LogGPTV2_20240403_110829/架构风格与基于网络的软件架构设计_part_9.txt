MA REV+COD + ++ ± ++ + + - +
3.5.1 虚拟机（Virtual Machine，VM）
所有移动代码风格的基础是虚拟机（或解释器）风格[53]。代码必须以某种方式来执行，
首选的方式是在一个满足了安全性和可靠性关注点的受控环境中执行，而这正是虚拟机风格
所提供的。虚拟机风格本身并不是基于网络的风格，但是它通常在客户-服务器风格（REV
和COD风格）中与一个组件结合在一起使用。
虚拟机通常被用作脚本语言的引擎，包括像Perl[134]这样的通用语言和像PostScript[2]
这样的与特定任务相关的语言。虚拟机带来的主要好处是在一个特定平台上分离了指令
（instruction）和实现（implementation）（可移植性），并且使可扩展性变得容易。因为难
以简单地通过查看代码来了解可执行代码将要做什么事情，因此降低了可见性。同时由于需
要对求值环境（evaluation environment）进行管理，也降低了简单性，但在一些情况下可以
通过简化静态的功能（static functionality）得到补偿。
3.5.2 远程求值（Remote Evaluation，REV）
远程求值风格[50]来源于客户-服务器风格和虚拟机风格，一个客户端组件必须要知道如
何来执行一个服务，但缺少执行此服务所必需的资源（CPU周期、数据源等等），这些资源
恰好位于一个远程站点上。因此，客户端将如何执行服务的代码发送给远程站点上的一个服
务器组件，服务器组件使用可用的资源来执行代码，然后将执行结果发送回客户端。这种远
程求值风格假设将要被执行的代码是处在一种受保护的环境中，这样除了那些正在被使用的
资源外，它不会影响到相同服务器的其他客户端。
远程求值风格的优点包括：能够定制服务器组件的服务，这改善了可扩展性和可定制性；
当代码能够使它的动作适应于服务器内部的环境（而不是客户端做出一系列交互来做同样的
事情）时，能够得到更好的效率（译者注：即通过一次交互，直接发送一段代码到服务器上
执行，并且将结果返回）；由于需要管理求值的环境，降低了简单性，但在一些情况下可以
通过简化静态的服务器功能得到补偿。可伸缩性降低了，但是可以通过服务器对执行环境的
管理（杀掉长期运行的代码，或当资源紧张时杀掉大量消耗资源的代码）加以改善，但是管
第3章 基于网络的架构风格 31
理功能本身会导致与部分故障和可靠性相关的难题。然而，最大的限制是，由于客户端发送
代码而不是标准化的查询，因此缺乏可见性。如果服务器无法信任客户端，缺乏可见性会导
致明显的部署问题。
3.5.3 按需代码（Code on Demand，COD）
在按需代码风格[50]中，一个客户端组件知道如何访问一组资源，但不知道如何处理它
们。它向一个远程服务器发送对于如何处理资源的代码的请求，接收这些代码，然后在本地
执行这些代码。
按需代码风格的优点包括：能够为一个已部署的客户端添加功能，改善了可扩展性和可
配置性；当代码能够使它的动作适应于客户端的环境，并在本地与用户交互而不是通过远程
交互时，能够得到更好的用户可觉察性能和效率。由于需要管理求值环境，降低了简单性，
但在一些情况下可以通过简化静态的客户端功能得到补偿。由于服务器将工作交给了客户端
（否则将消耗服务器的资源），从而改善了服务器的可伸缩性。像远程求值风格一样，最大
的限制是由于服务器发送代码而不是简单的数据，因此缺乏可见性。如果客户端无法信任服
务器，缺乏可见性会导致明显的部署问题。
3.5.4 分层-按需代码-客户-缓存-无状态-服务器（Layered-Code-on-Demand-
Client-Cache-Stateless-Server，LCODC$SS）
作为一些架构如何互补的例子，考虑将按需代码风格添加到上面讨论过的分层-客户-缓
存-无状态-服务器风格上。因为代码被看作不过是另一种数据元素，因此这并不会妨碍
LC$SS风格的优点。该风格的一个例子是HotJava Web浏览器[java.sun.com]，它允许applet
和协议扩展作为有类型的媒体（typed media）来下载。
LCODC$SS风格的优点和缺点正是COD风格和LC$SS风格的优点和缺点的组合。我们
将进一步讨论COD风格和其他CS风格的组合，不过这个调查并非是想要包括所有可能的组
合。
3.5.5 移动代理（Mobile Agent，MA）
在移动代理风格[50]中，一个完整的计算组件，与它的状态、必需的代码、执行任务所
需的数据一起被移动到远程站点。该风格可以看作来源于远程求值风格和按需代码风格，因
为移动性是同时以这两种方式工作的。
移动代理风格超越那些已经在REV风格和COD风格中描述过的优点的主要优点是：对
于选择在何时移动代码而言，具有更大的灵活性（dynamism）。当一个应用根据推算决定
移动到另一个地点，以减少在该应用和它希望处理的下一组数据之间的距离，此时它可以在
一个地点正处于处理信息的中途（译者注：即不必等待信息完全处理完）。此外，因为应用
状态每次都是在单一地点，所以减少了由局部故障引起的可靠性问题。
3.6 点对点风格（Peer-to-Peer Styles）
第3章 基于网络的架构风格 32
表3-5：评估基于网络的超媒体系统的点对点风格
风格 继承 网 用 效 可 简 可 可 可 可 可 可 可 可
络 户 率 伸 单 进 扩 定 配 重 见 移 靠
性 可 缩 性 化 展 制 置 用 性 植 性
能 觉 性 性 性 性 性 性 性
察
性
能
EBI + -- ± + + + + - -
C2 EBI+LCS - + + ++ + + ++ ± + ±
DO CS+CS - + + + + + - -
BDO DO+LCS - - ++ + + ++ - +
3.6.1 基于事件的集成（Event-based Integration，EBI）
基于事件的集成风格也被称作隐式调用（implicit invocation）风格或者事件系统（event
system）风格，它通过除去了解连接器接口的标识（identity on the connector interface）的必
要性，降低了组件之间的耦合。此风格不是直接调用另一个组件，而是一个组件能够发布
（或广播）一个或者多个事件。在事件发布后，系统中的其他组件能够注册对于某些事件类
型的兴趣，由系统本身来调用所有已注册的组件[53]。该风格的例子包括：Smalltalk-80中的
MVC范例[72]，以及很多软件工程环境的集成机制，包括Field [113]、SoftBench[29]和
Polylith[110]。
通过使添加侦听事件的新组件变得容易（可扩展性）、鼓励使用通用的事件接口和集成
机制（可重用性）、允许组件被替换而不会影响其他组件的接口（可进化性），基于事件的
集成风格为可扩展性、可重用性和可进化性提供了强有力的支持。如同管道和过滤器系统一
样，将组件放在事件接口上——这一“看不见的手”需要高层次的配置架构。大多数EBI系
统也将显式调用（explicit invocation）作为交互的一种补充形式 [53]。对于由数据监视支配，
而不是由数据获取支配的应用，EBI通过除去轮询式交互（polling interactions）的必要性，
能够提高效率。
EBI系统的基本形式由一个事件总线组成，所有的组件通过这个总线侦听它们所感兴趣
的事件。当然，这会立即导致有关通知的数量、由通知引发其他组件的广播从而导致的事件
风暴、在通知传送系统中的单点故障等方面的可伸缩性问题。这些问题能够通过以损害简单
性为代价，使用分层系统和事件过滤来加以改善。
EBI系统的另一个缺点是：难以预料一个动作将会产生什么样的响应（缺乏可理解性），
事件通知并不适合交换大粒度的数据[53]，而且也不支持从局部故障中恢复。
3.6.2 C2
C2架构风格[128]直接支持大粒度的重用，并且通过加强底层独立性（substrate
independence），支持系统组件的灵活组合。它通过将基于事件的集成风格和分层-客户-服
务器风格相结合来达到这些目标。异步通知消息向下传送，异步请求消息向上传送，这是组
件之间通信的唯一方式。这加强了对高层依赖的松散耦合（服务请求可以被忽略），并且与
底层实现了零耦合（不知道使用了通知），从而改善了对于整个系统的控制，又没有丧失
EBI的大多数优点。
第3章 基于网络的架构风格 33
通知是对于组件中的状态变化的公告。C2并不对在通知中应该包括什么内容加以限制：
一个标志、一个状态delta改变量、或者一个完整的状态表述都是有可能的。一个连接器的
首要职责是消息的路由和广播；它的第二个职责是消息过滤。引入对于消息的分层过滤，解
决了EBI系统的可伸缩性问题，同时也改善了可进化性和可重用性。包括了监视能力的重量
级连接器能够被用来改善可见性和减少局部故障所导致的可靠性问题。
3.6.3 分布式对象（Distributed Objects，DO）
分布式对象风格将系统组织为结对进行交互的组件的集合。一个对象是一个实体，这个
实体封装了一些私有的状态信息或数据、操作数据的一组相关的操作或过程、以及一个可能
存在的控制线程，这种封装使得它们能够被整体地看作单个的单元[31]。通常，一个对象的
状态对于所有其他对象而言，是完全隐藏和受到保护的。检查或修改对象状态的唯一方法是
对该对象的一个公共的、可访问的操作发起请求或调用。这样就为每个对象创建了一个良好
定义的接口，在对象的操作实现和它的状态信息保持私有的同时，公开操作对象的规格，这
样做改善了可进化性。
一个操作可以调用可能位于其他对象之上的操作。这些操作也同样可以调用其他对象之
上的操作，以此类推。一个相关联的调用链被称作一个动作（action）[31]。状态分布于对象
之间，这对使状态尽可能保持最新而言是有利的，但是不利之处是难以获得系统活动的总的
视图（缺乏可见性）。
一个对象为了与另一个对象交互，它必须知道另一个对象的标识。当一个对象的标识改
变时，它必须对所有显式调用它的其他对象做修改[53]。这就必需要有一些控制器对象来负
责维护系统的状态，以完成应用的需求。分布式对象系统的核心问题包括：对象管理、对象
交互管理和资源管理[31]。
分布式对象系统被设计用来隔离正在被处理的数据，因此该风格通常不支持数据流。然
而，当它和移动代理风格相结合时，可以为对象提供更好的移动性。
3.6.4 被代理的分布式对象（Brokered Distributed Objects，BDO）
为了降低对象标识的影响，现代分布式对象系统通常使用一种或更多种中间风格
（intermediary styles）来辅助通信。这包括基于事件的集成风格和被代理的客户/服务器
（brokered client/server）风格[28]。被代理的分布式对象风格引入了名称解析组件——其目
的是将该组件接收到的客户端请求中一个通用的服务名称解析为一个能够满足该请求的对象
的特定名称，并使用这个特定名称来答复客户端。尽管它改善了可重用性和可进化性，但额
外的间接层要求额外的网络交互，这降低了效率和用户可觉察的性能。
被代理的分布式对象系统目前受到两个标准的控制：OMG[97]所开发的CORBA行业标
准和ISO/IEC [66]所开发的开放分布式处理（ODP）的国际标准。
尽管分布式对象引起了非常多的兴趣，然而与大多数其他的基于网络的架构风格相比，
这样一类架构风格能够提供的优点很少，它们最适合被使用在包括了对已封装服务（例如硬