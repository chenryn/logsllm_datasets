1字节
0x34
0x56
程序员的自我修养一链接、装载与库
---
## Page 474
A.2ELF常见股
451
续表
Big-Endian
Little-Endian
2字节
0x56
0x34
3字节
0x78
0x21
Little-Endian主要用于我们现在的 PC的 CPU中，即Intel 的x86系列兼容机：Big-Endian
则主要应用在目前的 Mac 机器中，
般指PowerPC系列处理器。另外值得一提的是，日前
的 TCP/IP 网络及 Java 虚拟机的字节序都是 Big-endian的，这意味着如果通过网络传输
0x12345678这个整形变量，首先被发送的应该是0x12，接着是0x34，然后是0x56，最后是
0x78。所以我们的程序在处理网络流的时候，必须注意字节序的问题。
big-endian和itle-endian的争论由来已久，计算机界对两种方式的优劣进行了长期的争
论，争论双方相互不妥协（至今仍未完全妥协）。DannyCoben于1980年写的一篇名叫“On
战的双方。从此以后这两个术语开始流行并且一直延用至今。
A.2
ELF常见段
ELF常见名如表A-2所示。
表A-2
段名
说明
这个段里面保存了那些程序中用到的、基本上未初始化的数据，这个
.bss
段在程序被运行时，在内存中会被清零，这个段本书不占用碰盘空间，
它的属性为SHT_NOBITS.具体请参照3.3节
.comment
这个段包含编译器版本信息
data
这个段中包含的是程序中初始化的数据，主要是已初始化的全局变量、
静态变量
data1
与.data 类似
debug
这个段中包含的是调试信息
.dynamic
动态链接信息，详见7.5.2节
dynstr
动态链接时的字符串表，主要是动态链接符号的符号名，详见7.5.3节
dynsym
动态链接时的符号表，主要用于保存动态链接时的符号，详见7.5.3节
.fini
程序退出时执行的代码，这些代码晚于main函数抗行，多数被用作实
现C++全局析构，详见11.4节
.fini_array
包含一些程序或共享对象退出时须要执行的函数指针
.hash
符号表的哈希表，主要用于加快符号查找
程序员的自我修养一链接、装载与库
---
## Page 475
452
附录A
续表
段名
说明
.init
程序执行前的初始化代码，这些代码早于main函数被执行，多数时被
用于实现C++全局构造，详见11.4节
.init_array
包含一些程序或共享对象刚开始初始化时所须要执行的函数指针
interp
包含了动态链接器的路径，详见75.1节
.line
包含了调试时用的行号信息，主要表示机器代码与源代码行号之间的
对应关系
note
额外信息段，编译器、链接器或操作系统厂商可能会在里面保存程序
相关的额外信息，这个属于平台相关的
-preinit_array
保存的是早于初始化阶段执行的函数指针数组，这些品数会在.in讯
anTay的函数指针数组之前被执行
rodata
只读数据段
rodata1
同.rodat
shstrtab
段名字特串表
strtab
字符事表，通常是符号表里的符号名所需要的字符事
symtab
符号表，这个段中保存的是链接时所需要的料号信息，详见3.5节
这个段保存的是线程局部存储的未初始化数据。殿认情况下，每次进
tbss
程启动新的线程时，系统会产生一份.Ibss副本并且将它的内容初始化
为率
.tdata
这个段保存的是线程局部存储的初始化数据，默认情况下，每次进程
启动新的线程时，系统会产生一份.data副本
text
代码段，存放程序的可执行代码，详见3.3.1节
ctors
这个段保存的是全局构造函数指针，详见11.4节
.data.rel.ro
这个段保存的是程序的只读数据，与rodata类似，唯一不同的是它在
重定位时会被改写，然后将会被置为只读
.dtors
这个段保存的是全局析构函数指针，详见11.4节
.eh_frame
这个段保存的是与C++异常处理相关的内容
.eh_frame_hdr
这个段保存的是与C++异常处理相关的内容
-gcc_except_table
语官相关数据
gnu.version
符号版本相关，详见8.2节
gnu.version_d
符号版本相关，详见8.2节
-gnu.version_f
符号版本相美，详见8.2节
got.plt
这个段保存的是PLT信息，详见7.4节
jer
Java程序相关
.note.ABI-ag
用于指定程序的ABI
stab
调试信息
stabstr
stab中用到的字符串
程序员的自我修养—链接、装载与库
---
## Page 476
A.3常用开发工具命令行参考
453
A.3
常用开发工具命令行参考
A.3.1
gcc，GCC编译器
·E：只进行预处理并把预处理结果输出。
-C：只编译不链接，
·-0：指定输出文件名。
-S：输出编译后的汇编代码文件。
-1：指定头文件路径。
-e name：指定 name 为程序入口地址。
-ffreestanding：编译独立的程序，不会自动链接C运行库、启动文件等。
-finline-functions,-fno-inline-functions：启用/关闭内联函数。
g：在编译结果中加入调试信息，-ggdb就是加入GDB调试器能够识别的格式。
-L：指定链接时查找路径，多个路径之间用冒号隔开。
：
-nostartfiles：不要链接启动文件，比如 crtbegin.o、crtend.o。
-nostdlib：不要链接标准库文件，主要是C运行库。
-00：关闭所有优化选项。
-shared：产生共享对象文件。
-static：使用静态链接。
-Wall：对源代码中的多数编译警告进行启用。
-IPIC：使用地址无关代码模式进行编译。
-IPIE：使用地址无关代码模式编译可执行文件。
-XLinker：把 option传递给链接器。
-WI：把option传递给链接器，与上面的选项类似。
-fomit-frame-pointer：禁止使用EBP作为函数顿指针。
-fno-builtin：禁止GCC编译器内置函数。
-fno-stack-protector：是指关闭堆栈保护功能。
-ffunction-sections：将每个函数编译到独立的代码段。
-fdata-sections：将全局/静态变量编译到独立的数据段。
程序员的自我修养一链接、装载与库
---
## Page 477
454
附录A
A.3.2
2Id，GNU链接器
-static：静态链接。
-]：指定链接某个库。
-e name：指定name 为程序入。
：合并目标文件，不进行最终链接。
-L：指定链接时查找路径，多个路径之间用冒号隔开。
-M：将链接时的符号和地址输出成一个映射文件。
-0：指定输出文件名。
、
-s：清除输出文件中的符号信息。
-S：清除输出文件中的调试信息。
-T：指定链接脚本文件。
-version-script：指定符号版本脚本文件。
-soname：指定输出共享库的 SONAME。
-expont-dynamic：将全局符号全部导出。
-verbose：链接时输出详细信息。
-rpath：指定链接时库查找路径。
A.3.3
objdump，GNU目标文件可执行文件查看器
·a：列举a文件中所有的目标文件。
-b bfdname:指定 BFD 名。
-C：对于C++符号名进行反修饰（Demangle）。
g：显示调试信息。
-d：对包含机器指令的段进行反汇编。
-D：对所有的段进行反汇编。
·f：显示目标文件文件头。
·-h：显示段表。
显示行号信息。
P：显示专有头部信息，具体内容取决于文件格式。
4：显示重定位信息。
-R：显示动态链接重定位信息。
程序员的自我修养—链接、装载与库
---
## Page 478
A.3常用开发工具命令行参考
455
·s：显示文件所有内容。
-S：显示源代码和反汇编代码（包含-d参数）。
·-W：显示文件中包含有DWARF调试信息格式的段。
·七：显示文件中的符号表。
·-T：显示动态链接符号表。
·x：显示文件的所有文件头。
A.3.4cI，MSVC编译器
·c：只编译不链接。
·Za：禁止语言扩展。
·Mlink：链接指定的模块或给链接器传递参数。
·/Od：禁止优化。
·/O2：以运行速度最快为目标优化。
·/O1：以最节省空间为目标优化。
·/GR或/GR-：开启或关闭RTTI。
·/Gy：开启函数级别链接。
·IGS或/GS-：开启或关闭。
·/Fa[file]：输出汇编文件。
·E：只进行预处理并且把结果输出。
·I：指定头文件包含目录。
·rZi：启用调试信息。
·/LD：编译产生DLL文件。
·/LDd：编译产生DLL文件（调试版）。
·/MD：与动志多线程版本运行库MSVCRTLIB链接。
·MDd：与调试版动态多线程版本运行库MSVCRTD.LIB链接。
·/MT：与静态多线程版本运行库LIBCMTLIB链接。
·/MTd：与调试版静态多线程版本运行库LIBCMTD.LIB链接。
A.3.5link，MSVC链接器
·/BASE:address：指定输出文件的基地址。
程序员的自我修养一链接、装载与库
---
## Page 479
456
附录A