# 【技术分享】Windows内核池喷射的乐趣
|
##### 译文声明
本文是翻译文章，文章来源：theevilbit.blogspot.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[ **天鸽**](http://bobao.360.cn/member/contribute?uid=145812086)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**前言——Windows内核池喷射**
我计划写这一系列文章已经有一年了，我对这些东西做过一些研究，但是常常会忘记，也没有正确地写下笔记。我想探索的是什么样的对象可以用于内核池喷射，主要关注于它们消耗多少空间，它们拥有什么属性，并且到最后写了一段代码，将池孔大小（
**pool hole size**
）作为输入，然后动态地告诉我们在这里使用什么样的对象能够控制池分配以达到溢出的目的。我思考这一问题已经有段时间了，让我再一次感到兴奋的是当我看到了来自
@steventseeley
的一条推特（），我决定把它写出来，另一方面也是我自己的兴趣使然。
微软有一个很棒的内核对象列表，我们可以通过调用用户模式功能来创建内核对象，尽管它不是很完整，但仍然是一个很好的开始：[https://msdn.microsoft.com/library/windows/desktop/ms724485(v=vs.85).aspx](https://msdn.microsoft.com/library/windows/desktop/ms724485%28v=vs.85%29.aspx)
另一个重要的链接，是一个我们能够找到 **pool tag** （译者注：poll
tag是调试时用于识别块的字符）的列表，当查看池分配时也是十分方便的：[https://blogs.technet.microsoft.com/yongrhee/2009/06/23/pool-tag-list/](https://blogs.technet.microsoft.com/yongrhee/2009/06/23/pool-tag-list/)
在这篇文章中，我想探讨的是 Mutex 对象，由于笔记不完整它让我很头疼，我会讲到如何找到并查看对象在池空间中的实际分配以及对象本身的一些基本信息。  
**第一部分——环境配置及对象大小**
在设置环境的部分，我们并不需要进行远程内核调试，进行本地内核调试就足够了，因为我们只探索内核内存，目前也就不需要设置任何断点。所以本地调试足以满足我们的需求。为此，我们需要在
Windows 中启用调试：
    bcdedit -debug ON
之后，需要重启机器。一旦完成，我们就可以启动 WinDBG，转到内核调试，然后选择本地调试。我建议使用下面的命令来加载符号：
    .symfix
    .reload
此时我们就可以探索内核内存空间了。我将使用 Win7 SP1 x86 进行演示。
首先，如果我们希望获得更全面的对象列表，可以使用下面的命令：
    !object ObjectTypes
我们会得到这样的东西：
    lkd> !object ObjectTypes
    Object: 8be05880  Type: (851466d8) Directory
        ObjectHeader: 8be05868 (new version)
        HandleCount: 0  PointerCount: 44
        Directory Object: 8be05ed0  Name: ObjectTypes
        Hash Address  Type                      Name
        ---- -------  ----                      ----         00  851d6900 Type                      TpWorkerFactory
             851466d8 Type                      Directory
         01  8521a838 Type                      Mutant
             851cddb0 Type                      Thread
         03  857c7c40 Type                      FilterCommunicationPort
         04  8522a360 Type                      TmTx
         05  851d29c8 Type                      Controller
         06  8521d0b8 Type                      EtwRegistration
         07  851fe9c8 Type                      Profile
             8521a9c8 Type                      Event
             851467a0 Type                      Type
         09  8521cce0 Type                      Section
             8521a900 Type                      EventPair
             85146610 Type                      SymbolicLink
         10  851d69c8 Type                      Desktop
             851cdce8 Type                      UserApcReserve
         11  85221040 Type                      EtwConsumer
             8520e838 Type                      Timer
         12  8522a8f0 Type                      File
             851fe838 Type                      WindowStation
         14  860a6f78 Type                      PcwObject
         15  8521ceb0 Type                      TmEn
         16  851d2838 Type                      Driver
         18  8521db70 Type                      WmiGuid
             851fe900 Type                      KeyedEvent
         19  851d2900 Type                      Device
             851cd040 Type                      Token
         20  85214690 Type                      ALPC Port
             851cd568 Type                      DebugObject
         21  8522a9b8 Type                      IoCompletion
         22  851cde78 Type                      Process
         23  8521cf78 Type                      TmRm
         24  851d6838 Type                      Adapter
         26  852139a8 Type                      PowerRequest
             85218448 Type                      Key
         28  851cdf40 Type                      Job
         30  8521c940 Type                      Session
             8522a428 Type                      TmTm
         31  851cdc20 Type                      IoCompletionReserve
         32  8520e9c8 Type                      Callback
         33  85894328 Type                      FilterConnectionPort
         34  8520e900 Type                      Semaphore
这是一个可以在内核空间中分配的对象的列表。我们可以通过查看更多的细节来探索几个关于它们的重要属性。使用命令 dt nt!_OBJECT_TYPE
 我们可以得到关于某对象（object）的更多细节，比如句柄总数等。但是最重要的是 _OBJECT_TYPE_INITIALIZER
结构的偏移量，它将给我们带来极大的方便。让我们看看它为我们提供了 Mutant 对象的哪些我想要的信息：
    lkd> dt nt!_OBJECT_TYPE 8521a838
       +0x000 TypeList         : _LIST_ENTRY [ 0x8521a838 - 0x8521a838 ]
       +0x008 Name             : _UNICODE_STRING "Mutant"
       +0x010 DefaultObject    : (null) 
       +0x014 Index            : 0xe ''
       +0x018 TotalNumberOfObjects : 0x15f
       +0x01c TotalNumberOfHandles : 0x167
       +0x020 HighWaterNumberOfObjects : 0xc4d7
       +0x024 HighWaterNumberOfHandles : 0xc4ed
       +0x028 TypeInfo         : _OBJECT_TYPE_INITIALIZER
       +0x078 TypeLock         : _EX_PUSH_LOCK
       +0x07c Key              : 0x6174754d
       +0x080 CallbackList     : _LIST_ENTRY [ 0x8521a8b8 - 0x8521a8b8 ]
然后阅读下 _OBJECT_TYPE_INITIALIZER：
    lkd> dt nt!_OBJECT_TYPE_INITIALIZER 8521a838+28
       +0x000 Length           : 0x50
       +0x002 ObjectTypeFlags  : 0 ''
       +0x002 CaseInsensitive  : 0y0
       +0x002 UnnamedObjectsOnly : 0y0
       +0x002 UseDefaultObject : 0y0
       +0x002 SecurityRequired : 0y0
       +0x002 MaintainHandleCount : 0y0
       +0x002 MaintainTypeList : 0y0
       +0x002 SupportsObjectCallbacks : 0y0
       +0x002 CacheAligned     : 0y0
       +0x004 ObjectTypeCode   : 2
       +0x008 InvalidAttributes : 0x100
       +0x00c GenericMapping   : _GENERIC_MAPPING
       +0x01c ValidAccessMask  : 0x1f0001
       +0x020 RetainAccess     : 0
       +0x024 PoolType         : 0 ( NonPagedPool )
       +0x028 DefaultPagedPoolCharge : 0
       +0x02c DefaultNonPagedPoolCharge : 0x50
       +0x030 DumpProcedure    : (null) 
       +0x034 OpenProcedure    : (null) 
       +0x038 CloseProcedure   : (null) 
       +0x03c DeleteProcedure  : 0x82afe453     void  nt!ExpDeleteMutant+0
       +0x040 ParseProcedure   : (null) 
       +0x044 SecurityProcedure : 0x82ca2936     long  nt!SeDefaultObjectMethod+0
       +0x048 QueryNameProcedure : (null) 
       +0x04c OkayToCloseProcedure : (null)
这里告诉了我们两个重要的事情：
**此对象被分配给的池类型 – 在这里是非分页池（NonPagedPool）**
**功能偏移（这在实际的漏洞利用部分十分重要）**
之后，我们来分配一个 Mutant 对象，然后在内核池中找到它。我写了一段简短的 Python 代码来实现它：
    from ctypes import *
    from ctypes.wintypes import *
    import os, sys
    kernel32 = windll.kernel32
    def alloc_not_named_mutex():
            hHandle = HANDLE(0)
    hHandle = kernel32.CreateMutexA(None, False, None)
    if hHandle == None:
                    print "[-] Error while creating mutex"