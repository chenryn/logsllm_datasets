Porting from Oracle to PostgreSQL
by Paulo Merson February/2002
If you are starting to use PostgreSQL or you will migrate from Oracle database server, I hope this document helps. If you have Java
applications and use JDBC, the “Data types and JDBC” section will be particularly useful.
Oracle and PostgreSQL both conform to standard SQL. However, they contain several extensions and implementation details that
differentiate one from the other. The most important differences are listed in this document.
If you have comments about this document, please email me: pmerson@cs.cmu.edu.
1. SQL Syntax, Functions, Sequences, Etc.
Oracle PostgreSQL
select sysdate from dual select ‘now’::datetime
There is no “dual” table
Unlike other RDBMS, PostgreSQL allows a “select” without the
”from” clause. This use does not affect portability because
the syntax to get current time is already DBMS specific.
CREATE SEQUENCE seqname [ INCREMENT BY integer ] CREATE SEQUENCE seqname [ INCREMENT increment ]
[ MINVALUE integer ] [ MAXVALUE integer ] [ MINVALUE minvalue ] [ MAXVALUE maxvalue ]
[ START WITH integer ] [ CACHE integer ] [ CYCLE | NOCYCLE ] [ START start ] [ CACHE cache ] [ CYCLE ]
Oracle’s “create sequence” has other arguments not listed here and not If you don’t specify MAXVALUE, then the maximum value is
supported by PostgreSQL, but the main difference is the need of ‘by’ and 2147483647 for ascending sequences.
“with” after “increment” and “start”.
If you don’t specify ”MAXVALUE” or if you use the parameter
“NOMAXVALUE”, then the actual limit is 1027.
1
Oracle PostgreSQL
To return the current value and increment the counter: To return the current value and increment the counter:
sequence_name.nextval; nextval(‘sequence_name’);
Possible usage in a select statement: Possible usage in a select statement
select sequence_name.nextval from dual; select nextval(‘sequence_name’);
Note that unlike other RDBMS, PostgreSQL allows a select without the
‘from’ clause. This use does not affect portability because the sequence
syntax is already DBMS specific.
SELECT product_id, SELECT a,
DECODE (warehouse_id, 1, ’Southlake’, CASE WHEN a=1 THEN 'one'
2, ’San Francisco’, WHEN a=2 THEN 'two'
3, ’New Jersey’, ELSE 'other'
4, ’Seattle’, END
’Non-domestic’) FROM test
quantity_on_hand
FROM inventories
select employeeid, select employeeid,
NVL(hire_date, sysdate) coalesce(hire_date, 'now'::datetime)
from employee from employee
where employeeid = 10; where employeeid = 10;
Oracle also has a “coalesce” function that is a generalization of the
commonly used NVL function.
Outer join – “(+)” Doesn’t support outer join. The workaround is to use a union.
Hierarchical queries – “CONNECT BY” Nothing similar
SELECT product_id FROM inventories SELECT product_id FROM inventories
MINUS EXCEPT
SELECT product_id FROM order_items; SELECT product_id FROM order_items;
select unique col1, col2 from table1 select distinct col1, col2 from table1
In Oracle “distinct” and “unique” keywords are synonymous in the select PostgreSQL doesn’t allow “select unique”.
statement.
2
Oracle PostgreSQL
Oracle relational operators may have a space between the characters. For PostgreSQL relational operators doesn’t allow spaces, the characters that
example, the following select will work: compound an operator must be consecutive when the command is
parsed:
select id,name from employee where id > = 10;
// There are spaces and tabs between “>” and “=” select id,name from employee where id >= 10;
To get the remainder of the division of 10 by 4 (modulo) use the “mod” To get the remainder of the division of 10 by 4 (modulo)
function: use the “%” operator. (And PostgreSQL has many other arithmetic
operators.)
select mod(10,4) from dual;
select 10 % 4;
The “ROWNUM” pseudo-column returns a number indicating the order There isn’t anything equivalent to Oracle ROWNUM.
in which Oracle selects the row.
However, you can limit the number of rows returned by a query using the
ROWNUM can be used to limit the number of rows returned by a query, “LIMIT” clause:
for example:
select * from employees order by name limit 10;
select * from employees where rownum  10 MB
LONG - Character data of variable length up to getString TEXT – variable length up to 1 GB getString
2 GB
It’s suggested that you use TEXT if n > 10 MB
DATE – holds date and time getDate TIMESTAMP getTimestamp
getTime You still can use getDate to read a TIMESTAMP
column, but you will loose the time portion of
getTimestamp
the data.
TIMESTAMP oracle.sql.
getTIMESTAMP
Nothing similar DATE – holds only the date (resolution is one getDate
day)
Nothing similar TIME – holds only the time (00:00:00.00 – getTime
23:59:59.99)
5
Oracle JDBC* PostgreSQL JDBC
RAW(size) – binary data of length size bytes getBytes BYTEA getBytes
(max 2000)
LONG RAW – binary data or variable length up
to 2GB
Nothing similar BIT(n) – fixed length string of 1’s and 0’s (?)
BIT VARYING(n) – variable length string of 1’s
and 0’s
CLOB – character large object (max 4GB) getClob TEXT (max 1GB) getString
BLOB – binary large object (max 4GB) getBlob BYTEA (max 1GB) getBytes
BYTEA is not documented in PostgreSQL 7.1 but
it’s fully implemented; Jdbc 7.2-1.2 is
required though in order to use getBytes and
setBytes.
Besides TEXT and BYTEA, PostgreSQL supports
large objects as separate files. They are
stored in a separate table in a special
format, and are referred to from regular
tables by an OID value. More information:
http://www.postgresql.org/idocs/index.php?larg
eobjects.html
http://www.postgresql.org/idocs/index.php?jdbc
-lo.html
ROWID oracle.sql. Nothing similar
getROWID
Nothing similar BOOLEAN – can have the value TRUE, FALSE or getBoolean
NULL
Typically, char(1) is used to store a value
that is translated to Boolean in the If you store '0' and '1' in a varchar(1) or
application logic. char(1) column, then the jdbc driver can
correctly interpret these values as boolean
If you store '0' and '1' in a varchar2(1) or
false an true respectively using
char column, then the jdbc driver can
ResultSet.getBoolean. However,
correctly interpret these values as boolean
PreparedStatement.setBoolean simply does not
false an true respectively using
work.
ResultSet.getBoolean and
PreparedStatement.setBoolean If you use PostgreSQL BOOLEAN, then your Java
code can use getBoolean and setBoolean.
org.
Oracle Spatial features ? Geometric data types: POINT, LINE, CIRCLE,
postgresql.
etc.
geometric.*
6
Oracle JDBC* PostgreSQL JDBC
Nothing similar Network address data types: INET, MACADDR, (?)
CIDR.
*
JDBC note: Typically PreparedStatement.setXxx is used to set the value of arguments (or “host” variables) inside SQL statements.
And there is a correspondent ResultSet.getXxx method to read the value returned by a query into java variables. Each get/setXXX
method has a specific Java data type or class associated to it (e.g. set/getInt deals with int; set/getDate deals with
java.sql.Date, etc.). Further, you can use different methods to read the same database data type, but usually there is a recommended
method. For example, a BIGINT column can be read with getShort, getInt, getLong, getDouble, etc., but the recommended method
is getLong.
So, to indicate the proper way to use each data type in Java I simply listed the recommended getXxx JDBC method.
4. Other Considerations:
• The set of operators and SQL functions is very similar though Oracle has a richer set. For example, both DBMS have the concatenation
operator “||”, as well as substr, upper, to_char and other functions with the same syntax. However, any Oracle function that is being
used must have its syntax compared to the equivalent function in PostgreSQL, if such exists.
• PostgreSQL lacks the ability to query across multiple databases.
• PostgreSQL’s PL/pgSQL is similar to Oracle PL/SQL and can be used to write stored functions. PostgreSQL doesn’t have packages or
procedures (only functions). More about this: http://www.postgresql.org/idocs/index.php?plpgsql-porting.html
• Both DBMS have triggers and the create trigger statement is similar, but the code executed by the trigger for PostgreSQL must be
in a stored function written by the user, while in Oracle you have the option of writing the code in a PL/SQL block in the create
trigger statement. PostgreSQL has yet an additional resource called the “rule system” that allows the definition of business logic that
is executed upon an event.
• The create table statement is similar in both DBMS. One noticeable difference is that PostgreSQL doesn’t have pctfree,
pctused, inittrans, and maxtrans clauses. They also differ in the create database statement, mainly in the arguments and
clauses that specify storage details.
7
5. References:
• Oracle 9i documentation - http://download-east.oracle.com/otndoc/oracle9i/901_doc/nav/docindex.htm
• PostgreSQL documentation - http://www.postgresql.org/idocs/
• “Oracle to Postgre Conversion” - http://openacs.org/doc/openacs/html/oracle-to-pg-porting.html
• “PostgreSQL JDBC 2.0 compliance” - http://lab.applinet.nl/postgresql-jdbc/
• An important source of information is the PostgreSQL mailing lists: http://archives.postgresql.org/
8
|---|--------------------------|------------|
| 0 | Oracle                   | PostgreSQL |
| 1 | select sysdate from dual | select ‘now’::datetime  
There is no “dual” table 
Unlike other RDBMS, PostgreSQL allows a “select” without the 
”from” clause. This use does not affect portability because 
the syntax to get current time is already DBMS specific.            |
| 2 | CREATE SEQUENCE seqname [ INCREMENT BY integer ] 
[ MINVALUE integer ] [ MAXVALUE integer ] 
[ START WITH integer ] [ CACHE integer ] [ CYCLE | NOCYCLE ]  
Oracle’s “create sequence” has other arguments not listed here and not 
supported by PostgreSQL, but the main difference is the need of ‘by’ and 
“with” after “increment” and “start”. 
If you don’t specify ”MAXVALUE” or if you use the parameter 
“NOMAXVALUE”, then the actual limit is 1027.                          | CREATE SEQUENCE seqname [ INCREMENT increment ] 
[ MINVALUE minvalue ] [ MAXVALUE maxvalue ] 
[ START start ] [ CACHE cache ] [ CYCLE ] 
If you don’t specify MAXVALUE, then the maximum value is 
2147483647 for ascending sequences.            |