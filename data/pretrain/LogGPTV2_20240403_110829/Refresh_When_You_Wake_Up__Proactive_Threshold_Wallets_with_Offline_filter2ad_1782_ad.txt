to sign
message m. Both parties output the same R when honest,
with private state stateb.
• (σ ∈ Zq) ← πσ
Sign(stateb)
Completes the signature started by πR
Sign when both
parties are honest, i.e. σ veriﬁes as a signature on message
m with R as the public nonce and pk as the public key.
Setup captures a speciﬁc kind of secret sharing,
i.e. the kind where the signing key is Shamir-shared among
the parties. Multiplicative shares for instance are not captured
by this abstraction. The (2,2) threshold ECDSA protocols of
Lindell [44] and Castagnos et al. [45] are not captured by our
abstraction for this reason. Additionally signature schemes that
do not have randomized signing algorithms such as BLS [46]
can not be decomposed as per this abstraction.
signature functionality. In particular let Sign ∈ {SignH
SignH
Finally these protocols must realize the relevant threshold
ECDSA,
Schnorr} where
Note that πDKG
H(m) + sk · rx
ECDSA(sk, k, m) =
Schnorr(sk, k, m) = H(R||m) · sk + k
k
SignH
SignH
where rx is the x-coordinate of k · G in the ECDSA signing
equation. We therefore deﬁne functionality F n,2
Sign to work as
follows:
1) Sample and store a secret key sk (and reveal the public
key via pk) upon receiving the (init) command from
all parties.
2) When parties Pi, Pj initiate the signing process and send
the command get-instance-key, sample a fresh
k ← Zq and send R = k · G to both parties.
of
the
To make
Setup,πR
3) When Pi, Pj request the completed signature by sending
proceed, use SignH (sk, k, m) to compute and return it.
protocol
concrete
Sign), we restrict access of their corresponding
Sign,πσ
(πDKG
simulators (S DKG
Setup,S R
Sign,S σ
Setup can
only send (init) on behalf of a corrupt party and receive pk
in response. For signing, S R
Sign can initiate initiate the process
and receive R. Finally only S σ
Signcan request the signature
itself from the functionality. We defer formal details to the
full version of this paper.
role
Sign. Speciﬁcally S DKG
Sign) to F n,2
each
An implication of this restriction is that πR
Sign has to be
simulatable without the signature σ, therefore it cannot leak
any information about this value. (The approach of splitting
the simulator into several simulators to limit what kind of
information can be leaked in different stages of the protocol
has been used before e.g., in secret-sharing based MPC proto-
cols to claim that the protocol does not leak any information
about the output until the reconstruction phase performed in
the last round of the protocol). This abstraction was chosen
deliberately to enforce this property; one of our key techniques
in this work (Section VII) relies on πR
Sign keeping σ hidden.
Threshold Schnorr: We recall a folklore instantiation of
F n,2
Sign for SignSchnorr in the full version of this paper (note that
threshold Schnorr also works for EdDSA).
Threshold ECDSA: We note that the recent protocols of
Gennaro and Goldfeder [5], Lindell et al. [6], and Doerner et
al. [7] for SignECDSA can also be cast in the above framework
if required. We discuss this in further detail in Section VIII.
VI. COORDINATING TWO PARTY REFRESH
As the ﬁnal protocol combines two independent concepts:
using the blockchain for synchronization, and authenticating
communication to ofﬂine parties, we ﬁrst present a base
protocol for the former for a (2, 2) access structure and
augment it with the latter to obtain a (2, n) protocol. In this
section, we describe the malicious secure protocol for two
parties to coordinate an authenticated refresh of the secret key
shares. The (2, 2) protocol is described with Shamir secret
shares (points on a polynomial) rather than just additive shares
so as to allow for a smoother transition to the (2, n) setting.
Intuition: The two parties begin by running the ﬁrst
half of the threshold signing protocol πR
Sign to obtain the
signing nonce R that will be used for the subsequent threshold
signature itself. They then sample a new candidate (shared)
polynomial f(cid:48) by publicly sampling the difference polynomial
(cid:48)
b = f(cid:48)(b) tagged with R and
fδ and store their local share sk
the epoch number epoch in a list rpool. Speciﬁcally rpool
(cid:48)
is a list of (R, sk
b, epoch) values that are indexed by R as
the unique identifying element. Following this, they complete
the threshold signing by running πσ
Sign and a designated party
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
615
sends the resulting signature (and message) to GLedger, i.e.
posts them to the public ledger.
Protocol 1: π(2,2)
ρ-sign
Parameters: Elliptic Curve Group (G, G, q)
Parties: Pb, P1−b (recall b ∈ {1, 2} is the index of the current
party and 1−b is a shorthand for the index of the counterparty)
Ideal Oracles: F RDL
Inputs:
Com-ZK, GLedger
b
• Common: Message to be signed m ∈ {0, 1}∗, public
key pk ∈ G, each party’s share in the exponent pkb =
(0)·F (b) where F is the polynomial over G passing
λ1−b
through (0, pk) and (b, f (b) · G), epoch index epoch ∈
Z+
(0)·
f (b) ∈ Zq
• Private: Each party Pb has private input skb = λ1−b
b
1) Tag R from Threshold Signature:
i. Run the ﬁrst half of the threshold signing protocol
(R, stateb) ← πR
Sign (skb, 1 − b, m)
2) Sample New Polynomial:
for response (idcoin, δ)
i. Send (sample-element, idcoin, q) to FCoin and wait
ii. Deﬁne degree-1 polynomial fδ over Zq
fδ(0) = 0 and fδ(1) = δ
such that
iii. Compute
sk
3) Store Tagged Refresh:
(cid:48)
b = skb + fδ(b)
b, epoch) to rpool
i. Retrieve Epoch index epoch
ii. Append (R, sk(cid:48)
σ ← πσ
tx) to GLedger
4) Complete the threshold signature protocol by running
5) If σ (cid:54)= ⊥ then set tx = (m, R, σ) and send (Submit, sid,
Sign
Note that in Step 5 it is sufﬁcient for only one party to send
the transaction tx to the ledger.
While the above protocol generates candidate refresh poly-
nomials, choosing which one to use from rpool (and when to
delete old shares) is done separately. The idea is that when
a new block is obtained from GLedger the parties each scan
it to ﬁnd signatures under their shared public key pk. The
signatures are cross-referenced with rpool tuples stored in
memory by matching R (no two signatures will have the same
R) and the ones without corresponding tuples are ignored. If
any such signatures are found, the one occurring ﬁrst in the
block is chosen to signal the next refresh; in particular the
(cid:48)
corresponding sk
b overwrites skb stored in memory, rpool is
erased, and the epoch counter is incremented.
Protocol 2: π(2,2)
ρ-update
Parameters: Elliptic Curve Group (G, G, q)
Parties: Pi (local refresh protocol)
Ideal Oracles: GLedger
Inputs: Epoch
epoch,
counter
a
list
rpool
=
{(epoch, sk(cid:48)
1) Send (Read) to GLedger and receive (Read, b). Set BLK to
i, R)}, private key share ski.
be the latest block occurring in b
under pk such that ∃(R, sk(cid:48)
2) Search for the ﬁrst signature (σ, R) occurring in BLK
3) Overwrite ski = sk(cid:48)
4) Set epoch = epoch + 1
i, epoch) ∈ rpool
i and erase rpool
It is clear that this protocol achieves all desired properties
when both parties are honest. We give a proof of the extended
(2, n) protocol directly in the next section. However we make
a few observations at this point that will aid in building the
proof for the extended protocol.
a) Before and after a refresh: the view of an adversary
corrupting Pb when epoch = x is completely independent of
the view when corrupting P1−b after epoch = x + 1. This is
clear as polynomials f and f(cid:48) are independently distributed,
and so skb = f (b) can not be meaningfully combined with
1−b = f(cid:48)(1 − b).
(cid:48)
sk
b) No two entries in rpool will have the same R: by
virtue of each R being chosen uniformly for each entry, the
likelihood of there being two entries with the same R value
√
in rpool is negligible, with O(
q) signatures having to be
generated before a collision occurs.
VII. (2, n) REFRESH WITH TWO ONLINE
In this section, we give the malicious secure protocol for
two online parties to coordinate an authenticated refresh of the
secret key for arbitrarily many ofﬂine parties. We now describe
how to ensure that ofﬂine parties can get up to speed upon
waking up, crucially in a way that every party is in agreement
about which polynomial to use so that ski erasures are always
safe.
Goal: Observe that if every party is in agreement about
rpool, then the rest of the refresh procedure is deterministic
and straightforward. Therefore it sufﬁces to construct a mech-
(cid:48)
anism to ensure that for each (R, sk
b, epoch) tuple an online
party Pb appends to its rpool, each ofﬂine party Pi is able
(cid:48)
i, epoch) to its own rpool.
to append a consistent value (R, sk
(cid:48)
Here ‘consistent’ means that the points (0, sk), (b, sk
i)
are collinear.
(cid:48)
b), (i, sk
An Attempt at a Solution: We ﬁrst note that since either
one of the online parties Pb may be malicious and therefore
unreliable, it simpliﬁes matters to design the refresh protocol
so that they both send the same message to an ofﬂine Pi. The
message itself should deliver fδ(i) (so that Pi can compute
(cid:48)
i) along with R. Simultaneously it must be ensured that a
sk
malicious party is unable to spoof such a message and confuse
Pi.
In order to solve this problem, we take advantage of the
fact that the parties already share a distributed key setup; as
any two parties must be able to sign a message in a (2, n)
threshold signature scheme, we take advantage of this feature
to authenticate sent messages with threshold signatures inter-
nal to the protocol. In particular, when any Pb, P1−b agree on
an entry (R, skb) to add to rpool, they also produce a threshold
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
616
signature z under the shared public key pk authenticating
this entry. Each Pb is instructed to send the new rpool entry
accompanied by its signature z to every ofﬂine party. If at
least one of Pb, P1−b follows the protocol (note that only
one may be corrupt), every ofﬂine party will have received
the new rpool entry when it wakes up. Additionally due to
the same reason that (2, n) signatures are unforgeable by an
adversary corrupting a single party, such an adversary will be
unable to convince any ofﬂine Pi to add an entry to rpool that
was not approved by an honest party. An implication of this
unforgeability feature is that an ofﬂine party can safely ignore
received messages that are malformed.
A Subtle Attack: Again the inherent unfairness of two-
party computation stands in the way of achieving a consistent
rpool. In particular an adversary corrupting P ∗
b may choose
to abort the computation the moment she receives the internal
threshold signature z, denying the online honest party P1−b
this value and therefore removing its ability to convince its
ofﬂine friends to add the new rpool entry. This is a dangerous
situation, as P ∗
b now has the power to control whether the
ofﬂine parties update rpool or not, i.e. by choosing whether or
not to send the new rpool entry (which it can convince ofﬂine
parties to use as it has z). While this will not immediately
constitute a breach of privacy, the fact that honest parties do
not agree on rpool could violate unanimous erasure; at best
this requires all honest parties to come online to re-share the
secret, and at worst this could mean that the secret key is lost
forever (e.g. in the (2,3) cold storage use case).
Our Solution: This is where it is crucial that the ﬁrst
half of the threshold signing protocol (πR
Sign) is simulatable
without the signature σ itself; in fact it is the entire reason
for this choice of abstraction. Assume that P1−b updates its
rpool with the new value before even producing z. Following
this, P1−b will refuse to instruct F n,2
Sign to reveal the signature
σ until it is in possession of the local threshold signature z
to send to ofﬂine parties. There are now two choices that P ∗
has when executing the attack described above:
b
i.e.
• Update rpool of ofﬂine parties:
the adversary
chooses to add (R, fδ) to the rpool of some/all ofﬂine
parties. In this case, in order to actually exploit the in-
consistency between rpool of different honest parties, the
adversary must trigger a refresh that produces different
outcomes for different rpool. Speciﬁcally, the signature
σ under public key pk and the nonce R must appear
on the blockchain; i.e. the same R that Pb interrupted
signing with P1−b but sent to ofﬂine parties. However
since protocol πR
Sign by itself keeps σ completely hidden
and P1−b does not continue with πσ