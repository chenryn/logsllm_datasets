### Signatures and Threshold Cryptography

To sign a message \( m \), both parties should output the same \( R \) when they are honest, using their private state \( \text{state}_b \). The signature process is completed by the following steps:

1. **Signature Generation:**
   - \(\sigma \in \mathbb{Z}_q\) is generated by \(\pi_{\sigma}\text{Sign}(\text{state}_b)\).
   - This completes the signature started by \(\pi_R\text{Sign}\) when both parties are honest.
   - \(\sigma\) verifies as a signature on message \( m \) with \( R \) as the public nonce and \( pk \) as the public key.

2. **Setup and Secret Sharing:**
   - The setup captures a specific kind of secret sharing, such as Shamir sharing, where the signing key is distributed among the parties.
   - Multiplicative shares, for example, are not covered by this abstraction.
   - Protocols like (2,2) threshold ECDSA by Lindell [44] and Castagnos et al. [45] are not captured by this abstraction.
   - Signature schemes without randomized signing algorithms, such as BLS [46], cannot be decomposed using this abstraction.

3. **Signature Functionality:**
   - The relevant threshold ECDSA and Schnorr signature schemes are defined as:
     - \( \text{ECDSA}(sk, k, m) = H(m) + sk \cdot r_x \)
     - \( \text{Schnorr}(sk, k, m) = H(R \| m) \cdot sk + k \)
   - Here, \( r_x \) is the x-coordinate of \( k \cdot G \) in the ECDSA signing equation.

4. **Functionality Definition:**
   - \( F_{\text{Sign}}^{n,2} \) works as follows:
     1. Sample and store a secret key \( sk \) (and reveal the public key \( pk \)) upon receiving the (init) command from all parties.
     2. When parties \( P_i \) and \( P_j \) initiate the signing process and send the command `get-instance-key`, sample a fresh \( k \in \mathbb{Z}_q \) and send \( R = k \cdot G \) to both parties.
     3. When \( P_i \) and \( P_j \) request the completed signature by sending `proceed`, use \( \text{Sign}_H(sk, k, m) \) to compute and return it.

5. **Simulator Access:**
   - To make the protocol concrete, we restrict access to the corresponding simulators:
     - \( S_{\text{DKG}}^{\text{Setup}} \) can only send (init) on behalf of a corrupt party and receive \( pk \) in response.
     - \( S_R^{\text{Sign}} \) can initiate the process and receive \( R \).
     - Only \( S_{\sigma}^{\text{Sign}} \) can request the signature itself from the functionality.

6. **Implications:**
   - \(\pi_R\text{Sign}\) must be simulatable without the signature \(\sigma\), ensuring no information about \(\sigma\) is leaked.
   - This approach is used in secret-sharing-based MPC protocols to ensure that no information is leaked until the reconstruction phase.

### Threshold Schnorr and ECDSA

- **Threshold Schnorr:**
  - A folklore instantiation of \( F_{\text{Sign}}^{n,2} \) for \(\text{Sign}_{\text{Schnorr}}\) is provided in the full version of the paper.
  - Threshold Schnorr also works for EdDSA.

- **Threshold ECDSA:**
  - Recent protocols by Gennaro and Goldfeder [5], Lindell et al. [6], and Doerner et al. [7] for \(\text{Sign}_{\text{ECDSA}}\) can be cast in the above framework if required.
  - Further details are discussed in Section VIII.

### Coordinating Two-Party Refresh

The final protocol combines two concepts: using the blockchain for synchronization and authenticating communication to offline parties. We first present a base protocol for a (2,2) access structure and then augment it for a (2,n) setting.

#### Malicious Secure Protocol for Two Parties

**Intuition:**
- The two parties run the first half of the threshold signing protocol to obtain the signing nonce \( R \).
- They sample a new candidate polynomial \( f' \) by publicly sampling the difference polynomial \( f_{\delta} \) and store their local share \( \text{sk}'_b \) tagged with \( R \) and the epoch number in a list \( \text{rpool} \).
- After completing the threshold signing, a designated party sends the resulting signature (and message) to the public ledger.

**Protocol 1: \(\pi_{(2,2)}^{\rho-\text{sign}}\)**

- **Parameters:**
  - Elliptic Curve Group \((G, G, q)\)
- **Parties:**
  - \( P_b, P_{1-b} \) (where \( b \in \{1, 2\} \))
- **Ideal Oracles:**
  - \( F_{\text{RDL}}, \text{Com-ZK}, \text{GLedger} \)
- **Inputs:**
  - Common: Message \( m \in \{0, 1\}^* \), public key \( pk \in G \), each partyâ€™s share in the exponent \( \text{pk}_b = \lambda_{1-b}^{(0)} \cdot F(b) \), epoch index \( \text{epoch} \in \mathbb{Z}^+ \)
  - Private: Each party \( P_b \) has private input \( \text{sk}_b = \lambda_{1-b}^{(0)} \cdot f(b) \)

**Steps:**

1. **Tag \( R \) from Threshold Signature:**
   - Run the first half of the threshold signing protocol: \((R, \text{state}_b) \leftarrow \pi_R\text{Sign}(\text{sk}_b, 1 - b, m)\)

2. **Sample New Polynomial:**
   - Send (sample-element, idcoin, q) to FCoin and wait for response (idcoin, \(\delta\)).
   - Define degree-1 polynomial \( f_{\delta} \) over \( \mathbb{Z}_q \) such that \( f_{\delta}(0) = 0 \) and \( f_{\delta}(1) = \delta \).
   - Compute \( \text{sk}'_b = \text{sk}_b + f_{\delta}(b) \).

3. **Store Tagged Refresh:**
   - Retrieve Epoch index \( \text{epoch} \).
   - Append \((R, \text{sk}'_b, \text{epoch})\) to \( \text{rpool} \).

4. **Complete the threshold signature protocol:**
   - Run \(\sigma \leftarrow \pi_{\sigma}\text{Sign}\).
   - If \(\sigma \neq \perp\), set \( tx = (m, R, \sigma) \) and send (Submit, sid, tx) to GLedger.

**Protocol 2: \(\pi_{(2,2)}^{\rho-\text{update}}\)**

- **Parameters:**
  - Elliptic Curve Group \((G, G, q)\)
- **Parties:**
  - \( P_i \) (local refresh protocol)
- **Ideal Oracles:**
  - \( \text{GLedger} \)
- **Inputs:**
  - Epoch counter, list \( \text{rpool} = \{(R, \text{sk}'_i, \text{epoch})\} \), private key share \( \text{sk}_i \).

**Steps:**

1. **Send (Read) to GLedger:**
   - Receive (Read, b) and set BLK to the latest block occurring in b under \( pk \).

2. **Search for the first signature:**
   - Find the first signature \((\sigma, R)\) in BLK.

3. **Overwrite and Update:**
   - Overwrite \( \text{sk}_i = \text{sk}'_i \) and erase \( \text{rpool} \).
   - Set \( \text{epoch} = \text{epoch} + 1 \).

**Observations:**

- **Before and after a refresh:**
  - The view of an adversary corrupting \( P_b \) when \( \text{epoch} = x \) is independent of the view when corrupting \( P_{1-b} \) after \( \text{epoch} = x + 1 \).
- **No two entries in rpool will have the same \( R \):**
  - The likelihood of having two entries with the same \( R \) value in \( \text{rpool} \) is negligible.

### (2, n) Refresh with Two Online Parties

In this section, we describe a malicious secure protocol for two online parties to coordinate an authenticated refresh of the secret key for arbitrarily many offline parties.

**Goal:**
- Ensure that offline parties can get up to speed upon waking up, with all parties in agreement about which polynomial to use.

**Attempt at a Solution:**
- Both online parties send the same message to an offline party \( P_i \), delivering \( f_{\delta}(i) \) along with \( R \).
- Use threshold signatures to authenticate messages, ensuring unforgeability.

**Subtle Attack:**
- An adversary corrupting \( P_b \) may abort the computation after receiving the internal threshold signature \( z \), denying the online honest party \( P_{1-b} \) the ability to convince its offline friends to add the new \( \text{rpool} \) entry.

**Our Solution:**
- Ensure that \( \pi_R\text{Sign} \) is simulatable without the signature \( \sigma \).
- \( P_{1-b} \) updates its \( \text{rpool} \) before producing \( z \) and refuses to reveal \( \sigma \) until it has \( z \) to send to offline parties.
- This prevents the adversary from controlling whether offline parties update \( \text{rpool} \) or not.

This solution ensures that the protocol remains robust and secure, even in the presence of a malicious party.