# 显示交易笔数，欺诈交易笔数num = len(data)num_fraud = len(data[data['Class']==1]) print('总交易笔数: ', num)print('诈骗交易笔数：', num_fraud)print('诈骗交易比例：{:.6f}'.format(num_fraud/num))
# 欺诈和正常交易可视化f, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(15,8))bins = 50ax1.hist(data.Time[data.Class == 1], bins = bins, color = 'deeppink')ax1.set_title('诈骗交易')ax2.hist(data.Time[data.Class == 0], bins = bins, color = 'deepskyblue')ax2.set_title('正常交易')plt.xlabel('时间')plt.ylabel('交易次数')plt.show()
# 对 Amount 进行数据规范化data['Amount_Norm'] = StandardScaler().fit_transform(data['Amount'].values.reshape(-1,1))
# 特征选择y = np.array(data.Class.tolist())data = data.drop(['Time','Amount','Class'],axis=1)X = np.array(data.as_matrix())
# 准备训练集和测试集train_x, test_x, train_y, test_y = train_test_split (X, y, test_size = 0.1, random_state = 33) 
# 逻辑回归分类clf = LogisticRegression()clf.fit(train_x, train_y)predict_y = clf.predict(test_x)
# 预测样本的置信分数score_y = clf.decision_function(test_x)  
# 计算混淆矩阵，并显示cm = confusion_matrix(test_y, predict_y)class_names = [0,1]
# 显示混淆矩阵plot_confusion_matrix(cm, classes = class_names, title = '逻辑回归 混淆矩阵')
# 显示模型评估分数show_metrics()
# 计算精确率，召回率，阈值用于可视化precision, recall, thresholds = precision_recall_curve(test_y, score_y)plot_precision_recall() 运行结果：                    Time            V1      ...               Amount          Classcount  284807.000000  2.848070e+05      ...        284807.000000  284807.000000mean    94813.859575  1.165980e-15      ...            88.349619       0.001727std     47488.145955  1.958696e+00      ...           250.120109       0.041527min         0.000000 -5.640751e+01      ...             0.000000       0.00000025%     54201.500000 -9.203734e-01      ...             5.600000       0.00000050%     84692.000000  1.810880e-02      ...            22.000000       0.00000075%    139320.500000  1.315642e+00      ...            77.165000       0.000000max    172792.000000  2.454930e+00      ...         25691.160000       1.000000 [8 rows x 31 columns![](Images/8d0240144d82e56eb046d5abd1da3630.png){savepage-src="https://static001.geekbang.org/resource/image/5e/61/5e98974d6c2e87168b40e5f751d00f61.png"}    总交易笔数:  284807诈骗交易笔数： 492诈骗交易比例：0.001727![](Images/c7b04414e821c99c3addfc4ef08958ea.png){savepage-src="https://static001.geekbang.org/resource/image/c8/d2/c8a59cb4f3d94c91eb6648be1b0429d2.png"}![](Images/c490f4095dcaf86db78eb3ccaf766653.png){savepage-src="https://static001.geekbang.org/resource/image/bf/39/bfe65c34b74de661477d9b59d4db6a39.png"}    精确率: 0.841召回率: 0.617F1 值: 0.712![](Images/ffb4a1f85fd11024fff1fbe423b42aeb.png){savepage-src="https://static001.geekbang.org/resource/image/28/69/28ccd0f8d609046b2bafb27fb1195269.png"}\你能看出来欺诈交易的笔数为 492 笔，占所有交易的比例是很低的，即0.001727，我们可以通过数据可视化的方式对欺诈交易和正常交易的分布进行呈现。另外通过可视化，我们也能看出精确率和召回率之间的关系，当精确率高的时候，召回率往往很低，召回率高的时候，精确率会比较低。代码有一些模块需要说明下。我定义了 plot_confusion_matrix函数对混淆矩阵进行可视化。什么是混淆矩阵呢？混淆矩阵也叫误差矩阵，实际上它就是TP、FP、TN、FN这四个数值的矩阵表示，帮助我们判断预测值和实际值相比，对了多少。从这个例子中，你能看出TP=37，FP=7，FN=23。所以精确率 P=TP/(TP+FP)=37/(37+7)=0.841，召回率R=TP/(TP+FN)=37/(37+23)=0.617。然后使用了 sklearn 中的 precision_recall_curve函数，通过预测值和真实值来计算精确率 -召回率曲线。precision_recall_curve函数会计算在不同概率阈值情况下的精确率和召回率。最后定义plot_precision_recall 函数，绘制曲线。
## 总结今天我给你讲了逻辑回归的概念和相关工具的使用，另外学习了在数据样本不平衡的情况下，如何评估模型。这里你需要了解精确率，召回率和F1的概念和计算方式。最后在信用卡欺诈分析的项目中，我们使用了逻辑回归工具，并对混淆矩阵进行了计算，同时在模型结果评估中，使用了精确率、召回率和F1 值，最后得到精确率 - 召回率曲线的可视化结果。从这个项目中你能看出来，不是所有的分类都是样本平衡的情况，针对正例比例极低的情况，比如信用卡欺诈、某些疾病的识别，或者是恐怖分子的判断等，都需要采用精确率 -召回率来进行统计。![](Images/c10089d1fcd57a97650384f0177a2ce0.png){savepage-src="https://static001.geekbang.org/resource/image/ab/50/abee1a58b99814f1e0218778b98a6950.png"}\最后留两道思考题吧，今天我们对信用卡欺诈数据集进行了分析，它是一个不平衡数据集，你知道还有哪些数据属于不平衡数据么？另外，请你使用线性SVM（对应 sklearn 中的LinearSVC）对信用卡欺诈数据集进行分类，并计算精确率、召回率和 F1 值。欢迎你在评论区与我分享你的答案，也欢迎点击"请朋友读"，把这篇文章分享给你的朋友或者同事。![](Images/8b75105190797b2e4f7be2536b6543db.png){savepage-src="https://static001.geekbang.org/resource/image/48/96/48cb89aa8c4858bbc18df3b3ac414496.jpg"}