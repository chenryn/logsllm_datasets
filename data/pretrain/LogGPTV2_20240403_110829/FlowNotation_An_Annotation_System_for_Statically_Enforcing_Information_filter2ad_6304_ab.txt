the Pool system with a Secure Computation protocol [27, 28]; Pan-
taloons RSA, the top result on GitHub for an RSA implementation in
C [14]; MiniAES, a performant AES multiparty computation imple-
mentation [6, 7], and Bellare-Micali OT, an implementation of the
Bellare-Micali oblivious transfer protocol [3]; Kerberos ASN.1 En-
coder, the ASN.1 encoder module of Kerberos [1]; Gnuk OpenPGP-
do, a portion of the OpenPGP module from gnuk [22]; Tiny SHA3,
a reference implementation of SHA3 [17].
As an example, we demonstrate how FlowNotation can be used
to discover flaws in large, automatically generated segments of
code that would be very difficult for a programmer to manually
analyze. The tool SCDtoObliv [24] generates highly performant
floating point circuits but the resulting circuit files are hard to
interpret and debug. We uncovered a flaw in the subtraction circuit,
which computes "A+(−B)". The function that does the sign flipping,
__obliv_c__flipBit, is annotated so that it can only accept an input
Poster PresentationCCS’18, October 15-19, 2018, Toronto, ON, Canada2208Library
Obliv-C Library
SCDtoObliv FP Circuits
ACK Oqueue
Secure Mux Application
Pool Framework
Pantaloons RSA
MiniAES
Bellare-Micali OT
Kerberos ASN.1 Encoder
Gnuk OpenPGP-do
Tiny SHA3
Total Number of Policies
Secrecy
Integrity
Sequencing
2
4
7
4
4
5
9
5
2
5
3
1
4
7
3
2
2
4
3
2
0
3
1
0
7
4
4
3
4
2
0
5
0
0
0
2
0
0
0
1
0
1
1
1
Figure 1: Evaluation Results
LoA ∼ LoC Issues
11
10
19
11
8
12
13
12
8
11
6
80
43,000
700
150
500
300
2000
100
300
250
200
0
1
0
0
1
1
0
2
0
1
0
with the needsFlipping label. Our tool reports an error; the sign
bit of the first operand, rather than the second, was given to the
__obliv_c__flipBit. Thus “(−A) + B" was computed, so results of
the circuit were negated with respect to the correct answer.
4 RELATED WORK
Related work for FlowNotation spans three research areas: C pro-
gram analysis tools, information flow types, and linear types (type
states). We discuss work in each area below.
Tools for Analyzing C Programs. Closest to our work is CQual [13].
Both works on theoretical foundations and practical applications
of type qualifiers have been published [4, 5, 11, 12, 26]. Our annota-
tions are indeed type qualifiers. Our work and prior work on type
qualifiers share the same goal of producing a lightweight tool to
check simple secrecy and integrity properties.
Information Flow Type Systems. Information flow type systems
is a well-studied field. Several projects have extended existing lan-
guages to include information flow types (e.g., [15, 16]). Sabelfeld et
al. provided a comprehensive summary in their survey paper [18].
Most information flow type systems do not deal with declassifica-
tion. At most, they will include a “declassify" primitive to allow
information downgrade, similar to our relabel operations. How-
ever, we have not seen work where the sequence of labels is part
of the information flow type like ours. As a result, we are able to
prove a noninterference theorem that implies API sequencing. The
proof technique we use for our noninterference theorem is directly
borrowed from FlowML [16].
Linear Types and Typestate. Our sequencing policy is tangen-
tially related to other type systems that aim to enforce API contracts.
This line of work includes typestate and linear types [2, 8, 19]. The
idea is that by using typestate/linear types one can model and check
behaviors such as files being opened and closed in a balanced man-
ner [2]. However, unlike in typestate the types on variables do not
change in our system; when a part of a policy is fulfilled there is a
new variable that “takes on" the rest of the policy.
REFERENCES
[1] 2017. Kerberos ASN.1 Encoder. https://github.com/krb5/krb5/tree/master/src/
lib/krb5/asn.1. [Online].
[2] Jonathan Aldrich, Joshua Sunshine, Darpan Saini, and Zachary Sparks. 2009.
Typestate-oriented Programming. In Proc. of (OOPSLA ’09).
[3] Mihir Bellare and Silvio Micali. 1989. Non-interactive Oblivious Transfer and
Applications. In Proc. of (CRYPTO ’89).
[4] Pete Broadwell, Matt Harren, and Naveen Sastry. 2003. Scrash: A System for
Generating Secure Crash Information. In Proc. of (SSYM’03).
[5] Brian Chin, Shane Markstrum, and Todd Millstein. 2005. Semantic type qualifiers.
ACM SIGPLAN Notices 40, 6 (2005), 85–95.
[6] Ivan Damgård and Rasmus Zakarias. 2016. Fast Oblivious AES A Dedicated
Application of the MiniMac Protocol. In AFRICACRYPT 2016.
[7] Ivan Damgård and Rasmus Zakarias. 2016. MiniAES Repository. https://github.
com/AarhusCrypto/MiniAES. [Online].
[8] Robert DeLine and Manuel Fähndrich. 2001. Enforcing high-level protocols in
low-level software. ACM SIGPLAN Notices 36, 5 (2001), 59–69.
[9] Jack Doerner. 2015. Absentminded Crypto Kit Repository. https://bitbucket.org/
jackdoerner/absentminded-crypto-kit/. [Online].
[10] Jack Doerner and Abhi Shelat. 2017. Scaling ORAM for Secure Computation. In
[11] David Evans. 1996. Static Detection of Dynamic Memory Errors. SIGPLAN Not.
Proc. of (CCS ’17).
31, 5 (May 1996), 44–53.
[12] Jeffrey Scott Foster and Alexander S Aiken. 2002. Type qualifiers: lightweight
specifications to improve software quality. Ph.D. Dissertation. UC Berkeley.
[13] Jeffrey S. Foster, Manuel Fähndrich, and Alexander Aiken. 1999. A Theory of
Type Qualifiers. SIGPLAN Not. 34, 5 (May 1999), 192–203.
Pantaloons/RSA Repository.
[14] Michael McGee. 2011.
https://github.com/
pantaloons/RSA/. [Online].
In Proc of (POPL ’99).
[15] Andrew C Myers. 1999. JFlow: Practical mostly-static information flow control.
[16] François Pottier and Vincent Simonet. 2002. Information Flow Inference for ML.
SIGPLAN Not. 37, 1 (Jan. 2002), 319–330.
[17] Markku-Juhani O. Saarinen. 2016. Tiny SHA3. https://github.com/mjosaarinen/
tiny_sha3
[18] A. Sabelfeld and A. C. Myers. 2003. Language-based information-flow security.
IEEE Journal on Selected Areas in Communications 21, 1 (Jan 2003), 5–19.
[19] R. E. Strom and S. Yemini. 1986. Typestate: A programming language concept for
enhancing software reliability. IEEE Transactions on Software Engineering SE-12,
1 (Jan 1986), 157–171.
[20] Dennis Volpano and Geoffrey Smith. 1997. A type-based approach to program
security. In Proc. of (TAPSOFT ’97).
[21] A. C. C. Yao. 1986. How to generate and exchange secrets. In 27th Annual
Symposium on Foundations of Computer Science (sfcs 1986). 162–167.
[22] NIIBE Yutaka. 2018. Gnuk. https://www.fsij.org/category/gnuk.html
[23] Samee Zahur. 2015. Obliv-C Repository. https://github.com/samee/obliv-c/.
[24] Samee Zahur and Darion Cassel. 2015. SCDtoObliv Repository. https://github.
com/samee/obliv-c/tree/obliv-c/SCDtoObliv. [Online].
[25] S Zahur and Evans D. 2015. Obliv-C: A Language for Extensible Data-Oblivious
Computation. IACR Cryptology ePrint Archive (2015).
[26] Xiaolan Zhang, Antony Edwards, and Trent Jaeger. 2002. Using CQUAL for Static
Analysis of Authorization Hook Placement. In Proc. of (USENIX ’02).
[27] Ruiyu Zhu, Yan Huang, and Darion Cassel. 2017. Pool Framework Repository.
https://github.com/jimu-pool/PoolFramework/. [Online].
[28] Ruiyu Zhu, Yan Huang, and Darion Cassel. 2017. Pool: Scalable On-Demand
Secure Computation Service Against Malicious Adversaries. In Proc. of (CCS
’17).
Poster PresentationCCS’18, October 15-19, 2018, Toronto, ON, Canada2209