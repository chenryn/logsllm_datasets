struct or variable allocated on the stack or heap, or
the value returned by malloc. All base pointers are in
bounds. The intended data unit of the base pointer is
the corresponding array, struct, variable, or allocated
block of memory to which it refers.
• Pointer Arithmetic: All pointer arithmetic expres-
sions contain a starting pointer (for example, a pointer
variable or the name of a statically allocated array)
and an oﬀset. We say that the value of the expres-
sion is derived from the starting pointer. A derived
pointer is in bounds if and only if the corresponding
starting pointer is in bounds and the derived pointer
points into the same data unit as the starting pointer.
Regardless of where the starting and derived pointers
point, they have the same intended data unit.
• Pointer Variables: A pointer variable is in bounds
if and only if it was assigned to an in-bounds pointer.
It has the same intended data unit as the pointer to
which it was assigned.
Jones and Kelly distinguish a valid out-of-bounds pointer,
which points to the next byte after its intended data unit,
from an invalid out-of-bounds pointer, which points to some
other address not in its intended data unit. They imple-
ment this distinction by padding each data item with an
extra byte. A valid out-of-bounds pointer points to this ex-
tra byte; all invalid out-of-bounds pointers have the value
ILLEGAL (-2). This distinction supports code that uses
valid out-of-bounds pointers in the termination condition of
loops that use pointer arithmetic to scan arrays. Finally,
Jones and Kelly instrument the code to check the status of
each pointer before it dereferences it; attempting to deref-
erence an out-of-bounds pointer causes the program to halt
with an error.
Jones and Kelly’s scheme does not support programs that
ﬁrst use pointer arithmetic to obtain a pointer to a location
past the end of the intended data unit, then use pointer
arithmetic again to jump back into the intended data unit
and access data stored in this data unit. While the behav-
ior of programs that do this is undeﬁned according to the
ANSI C standard, in practice many C programs use this
technique [38]. Ruwase and Lam’s extension uses an out-of-
bounds objects (OOBs) to support such behavior [38].
As in standard C compilation, in-bounds pointers refer di-
rectly into their intended data unit. Whenever the program
computes an out-of-bounds pointer, Ruwase and Lam’s en-
hancement generates an OOB object that contains the start-
ing address of the intended data unit and the oﬀset from the
start of that data unit. Instead of pointing oﬀ to some arbi-
trary memory location outside of the intended data unit or
containing the value ILLEGAL (-2), the pointer points to
the OOB object. The generated code checks pointer deref-
erences for the presence of OOB objects and uses this mech-
anism to halt the program if it attempts to dereference an
out-of-bounds pointer. The generated code also uses OOB
objects to precisely track data unit oﬀsets and appropriately
translate pointers derived from out-of-bounds pointers back
into the in-bounds pointer representation if the new pointer
jumps back inside the intended data unit. In practice, this
enhancement signiﬁcantly increases the range of programs
that can execute without terminating because of a failed
memory error check [38]. This extension also has the crucial
property that, unlike the Jones and Kelly scheme, it main-
tains enough information to determine the memory block
and oﬀset for each out of bounds pointer.
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:38:47 UTC from IEEE Xplore.  Restrictions apply. 
3.2 Continuation Code
Our implementation of the write continuation code stores
the written value in a hash table indexed under the memory
block and oﬀset of the write. For out of bounds reads it
looks up the accessed memory block and oﬀset and returns
the stored value if it is present in the hash table. If there is
no indexed value, it returns a default value.
To avoid memory leaks, it is necessary to manage the
memory used to store out of bounds writes in the hash ta-
ble. Our implementation devotes a ﬁxed amount of memory
to the hash table, in eﬀect turning the hash table into a
cache of out of bounds writes. We use a least recently used
replacement policy. It is possible for this policy to lead to
a situation in which an out of bounds read attempts to ac-
cess a discarded write entry. Our experimental results show
that the distance (measured in out of bounds memory ac-
cesses) between successive accesses to the same entry in the
hash table is relatively small and that our set of applications
never attempts to access a discarded write entry. We chose
to use a ﬁxed size cache (instead of some other data struc-
ture that attempts to store all out of bounds writes until
the program deallocates the corresponding memory blocks)
to eliminate the possibility of denial of service attacks that
cause the program to exhaust the available memory by gen-
erating and storing a very large number of out of bounds
writes.
Our basic philosophy views out of bounds accesses not
as errors but as normal, although uncommon, events in the
execution of the program. We acknowledge, however, that
programmers may wish to be informed of out of bounds
accesses so that they can increase the size of the accessed
memory block or change the program to eliminate the out
of bounds accesses. Our compiler can therefore optionally
augment the generated code to produce a log that identiﬁes
each out of bounds access. Programmers can use this log to
locate and eliminate out of bounds accesses.
4. EXPERIENCE
We implemented a compiler that generates code for bound-
less memory blocks and obtained several widely-used open-
source programs with out of bounds memory accesses. Many
of these programs are key components of the Linux-based
open-source interactive computing environment; many of
the out of bounds accesses in these programs correspond
to exploitable buﬀer overﬂow security vulnerabilities.
4.1 Methodology
We evaluate the behavior of three diﬀerent versions of
each program: the Standard version compiled with a stan-
dard C compiler (this version is vulnerable to any out of
bounds accesses that the program may contain), the Check
version compiled with the CRED safe-C compiler [38] (this
version terminates the program with an error message at
the ﬁrst out of bounds access), and the Boundless version
compiled with our compiler (this compiler generates code to
store out of bounds writes in a hash table and return the
values for corresponding out of bounds reads). We evaluate
three aspects of each program’s behavior:
• Security and Resilience: We chose a workload with
an input that triggers known out of bounds mem-
ory accesses; this input typically exploits a security
vulnerability as documented by vulnerability-tracking
organizations such as Security Focus [11] and Secu-
riTeam [10]. We observe the behavior of the diﬀerent
versions on this workload, focusing on how the diﬀer-
ent programs execute after the out of bounds accesses.
• Performance: We chose a workload that both the
Standard and Boundless versions can execute success-
fully. We use this workload to measure the request
processing time, or the time required for each version
to process representative requests. We obtain this time
by instrumenting the program to record the time when
it starts processing the request and the time when it
stops processing the request, then subtracting the start
time from the stop time.
• Standard Usage: When possible, we use the Bound-
less version of each program as part of our normal com-
putational environment. During this deployment we
present the program with a workload intended to sim-
ulate standard usage; we also ensure that the workload
contains attacks that trigger out of bounds accesses in
each program. We focus on the acceptability of the
continued execution of the Boundless version of the
deployed program.
We ran all the programs on a Dell workstation with two
2.8 GHz Pentium 4 processors, 2 GBytes of RAM, and run-
ning Red Hat 8.0 Linux.
4.2 Sendmail
Sendmail is the standard mail transfer agent for Linux and
other Unix systems [13]. It is typically conﬁgured to run as
a daemon which creates a new process to service each new
mail transfer connection. This process executes a simple
command language that allows the remote agent to transfer
email messages to the Sendmail server, which may deliver
the messages to local users or (if necessary) forward some
or all of the messages on to other Sendmail servers. Ver-
sions of Sendmail earlier than 8.11.7 and 8.12.9 (8.11 and
8.12 are separate development threads) have a memory er-
ror vulnerability which is triggered when a remote attacker
sends a carefully crafted email message through the Send-
mail daemon [12]. When Sendmail processes the message,
the memory error causes it to execute the injected code in
the message. The injected code executes with the same per-
missions as the Sendmail server (typically root).
4.2.1
Security and Resilience
We worked with Sendmail version 8.11.6. The Standard
version of Sendmail executes the out of bounds writes and
corrupts its call stack. The Check version is apparently dis-
abled by a memory error that occurs whenever the Send-
mail daemon wakes up to check for incoming messages. The
Boundless version is not vulnerable to the attack — it stores
the out of bounds writes in the hash table and executes
through the memory error triggered by the attack to con-
tinue to successfully process subsequent Sendmail commands.
4.2.2 Performance
Figure 2 presents the request processing times for the
Standard and Boundless versions of Sendmail. All times are
given in milliseconds. The Receive Small request receives a
message whose body is 4 bytes long; the Send Small request
sends the same message. The Receive Large request receives
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:38:47 UTC from IEEE Xplore.  Restrictions apply. 
a message whose body is 4 Kbytes long; the Send Large re-
quest sends the same message. We performed each request
at least twenty times and report the means and standard
deviations of the request processing times.
Request
Receive Small
Receive Large
Send Small
Send Large
Standard
Boundless
15.6 ± 2.9% 72.9 ± 2.1%
16.8 ± 4.3% 77.9 ± 0.6%
20.4 ± 3.3% 86.7 ± 2.4%
21.5 ± 5.7% 88.8 ± 1.9%
Slowdown
4.7
4.6
4.2
4.1
Figure 2: Request Processing Times for Sendmail
(milliseconds)
4.2.3
Standard Usage
For our standard usage workload, we installed the Bound-
less version of Sendmail on one of our machines and used it
to process a set of one thousand messages, composed of 960
valid messages and 40 attack messages (we sent one attack
message before every 24 valid messages). On this workload,
Sendmail successfully executes through the memory errors
and correctly processes all the messages.
Our memory error logs indicate that Sendmail generates a
steady stream of memory errors during its normal execution.
In particular, every time the Sendmail daemon wakes up to
check for work, it generates a memory error. We logged
12,017 out of bounds memory accesses. All of the out of
bounds reads access values which had been previously stored
in the hash table.
4.3 Pine
Pine is a widely used mail user agent (MUA) that is dis-
tributed with the Linux operating system [9]. Pine allows
users to read mail, fetch mail from an IMAP server, compose
and forward mail messages, and perform other email-related
tasks. We use Pine 4.44, which is distributed with Red Hat
Linux version 8.0. This version of Pine has out of bounds
accesses associated with a failure to correctly parse certain
legal From ﬁelds [8].
4.3.1
Security and Resilience
Our security and resilience workload contains an email
message with a From ﬁeld that triggers this memory error.
This workload causes the Standard version to corrupt its
heap and abort. The Check version detects the memory
error and terminates the computation with an error message
identifying the error. With both of these versions, the user
is unable to use Pine to read mail because Pine aborts or
terminates during initialization as the mail ﬁle is loaded and
before the user has a chance to interact with the program.
The user must manually eliminate the From ﬁeld from the
mail ﬁle (using some other mail reader or ﬁle editor) before
he or she can use Pine. While the Check version protects
the user against injected code attacks, it prevents the user
from using Pine to read mail as long as the mail ﬁle contains
the problematic From ﬁeld.
The Boundless version, on the other hand, continues to
execute through the out of bounds accesses to enable the
user to process their mail. This version processed all of our
workloads without errors.
4.3.2 Performance
Figure 3 presents the request processing times for the
Standard and Boundless versions of Pine. All times are
given in milliseconds. The Read request displays a selected
empty message, the Compose request brings up the user in-
terface to compose a message, and the Move request moves
an empty message from one folder to another. We performed
each request at least twenty times and report the means and
standard deviations of the request processing times.
Request
Read
Compose
Move
Standard
Boundless
0.287 ± 7.1%
2.19 ± 1.7%
3.44 ± 1.8%
0.385 ± 4.3%
1.34 ± 10.4% 1.90 ± 10.0%
Slowdown
7.6
8.9
1.4
Figure 3: Request Processing Times for Pine
(milliseconds)
As these numbers indicate, the Boundless version is sub-
stantially slower than the Standard version for the Read
and Compose requests. However, because Pine is an inter-
active program, its performance is acceptable as long as it
feels responsive to its users. Assuming a pause perceptibil-
ity threshold of 100 milliseconds for this kind of interactive
program [18], it is clear that the application of boundless
memory blocks should not degrade the program’s interac-
tive feel. Our subjective experience conﬁrms this expecta-