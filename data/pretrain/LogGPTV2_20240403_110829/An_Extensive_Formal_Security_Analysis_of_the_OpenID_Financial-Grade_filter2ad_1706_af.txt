integrity. These properties have been central to also OAuth 2.0
and OpenID Connect [6], [7]. But as mentioned, the FAPI
has been designed to fulﬁll these properties under stronger
adversaries, therefore using various OAuth extensions. While
our formulations of these properties are inspired by those for
OAuth 2.0 and OpenID Connect, they had to be adapted and
extended for the FAPI, e.g., to capture properties of resource
servers, which previously have not been modeled. We also
state our main theorem.
We give an overview of each security property. For the
authorization property, we provide an in-depth explanation,
together with the formal deﬁnition. Appendix D contains a
proof sketch for the authorization property. Full details and
proofs of all properties are given in our technical report [25].
1) Authorization: Informally speaking, for authorization we
require that an attacker cannot access resources belonging to
an honest user (browser). A bit more precise, we require that
in all runs ρ of a FAPI web system FAPI if an honest resource
server receives an access token that is associated with an honest
client, an honest authorization server, and an identity of an
honest user, then access to the corresponding resource is not
provided to the attacker in any way. We highlight that this
does not only mean that the attacker cannot access the resource
directly at the resource server, but also that the attacker cannot
access the resource through a client.
In order to formalize this property, we ﬁrst need to deﬁne
what it means for an access token to be associated with a client,
an AS, and a user identity (see below for an explanation of
this deﬁnition).
Deﬁnition 1 (Access Token associated with C, AS and ID).
Let c be a client with client
id clientId issued to c by
the authorization server as, and let id ∈ IDas, where IDas
denotes the set of identities governed by as. We say that
an access token t is associated with c, as and id in state
S of the conﬁguration (S,E,N) of a run ρ of a FAPI web
system, if there is a sequence s ∈ S(as).accessTokens such
that s ≡ (cid:5)id,clientId,t, r(cid:6), s ≡ (cid:5)MTLS,id,clientId,t,key, rw(cid:6) or
s ≡ (cid:5)OAUTB,id,clientId,t,key
(cid:2), rw(cid:6), for some key and key
(cid:2)
.
Intuitively, an access token t is associated with a client c,
authorization server as, and user identity id, if t was created
by the authorization server as and if the AS has created t for
the client c and the identity id.
More precisely,
the access token is exchanged for an
authorization code (at the token endpoint of the AS), which
is issued for a speciﬁc client. This is also the client to which
the access token is associated with. The user identity with
which the access token is associated is the user identity that
authenticated at the AS (i.e., logged in at the website of the
AS). In the model, the AS associates the access token with
the client identiﬁer and user identity by storing a sequence
containing the identity, the client identiﬁer and the access
token (i.e., (cid:5)id,clientId,t, r(cid:6), (cid:5)MTLS,id,clientId,t,key, rw(cid:6) or
(cid:5)OAUTB,id,clientId,t,key
(cid:2), rw(cid:6)). Furthermore, the last entry of
the sequence indicates if the client is using the Read-Only or
the Read-Write ﬂow. In addition to this, for the Read-Write
ﬂow, the AS stores whether the access token is bound via
mTLS or OAUTB (along with the corresponding key with
which the access token is associated).
We can now deﬁne authorization formally, again the expla-
nation of this deﬁnition follows below.
Deﬁnition 2 (Authorization Property). We say that the FAPI
web system with a network attacker FAPI is secure w.r.t. au-
thorization iff for every run ρ of FAPI , every conﬁguration
(S,E,N) in ρ, every authorization server as ∈ AS that is
honest in S with sas
.resource_servers being domains of
honest resource servers used by as, every identity id ∈ IDas
0
for which the corresponding browser, say b, is honest in S,
every client c ∈ C that is honest in S with client id clientId
issued to c by as, every resource server rs ∈ RS that
is
honest in S such that id ∈ srs
.ids (set of IDs handled by rs),
.authServ ∈ dom(as) (set of domains controlled by as) and
srs
with domrs ∈ sas
.resource_servers (with domrs ∈ dom(rs)),
0
every access token t associated with c, as and id and every
resource access nonce r ∈ srs
.wNonce[id] it
holds true that:
If r is contained in a response to a request m sent to rs with
t ≡ m.header[Authorization], then r is not derivable from
the attackers knowledge in S.
.rNonce[id] ∪ srs
0
0
0
0
As outlined above, the authorization property states that if
the honest resource server receives an access token associated
with a client identiﬁer, authorization server, and user identiﬁer,
then the corresponding resource access is not given to the
attacker. Access to resources is modeled by nonces called
resource access nonces. For each user identity, there is one set
of nonces representing read access, and another set representing
write access. In our model of the FAPI, when a resource server
receives an access token associated with a user from a client,
the resource server returns to the client one of the resource
access nonces of the user, which in turn the client forwards
to the user’s browser. The above security property requires
that the attacker does not obtain such a resource access nonce
(under the assumptions state in the property). This captures
that there should be no direct or indirect way for the attacker
(cid:21)(cid:23)(cid:22)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:17 UTC from IEEE Xplore.  Restrictions apply. 
to access the corresponding resource. In particular, the attacker
should not be able to use a client such that he can access the
resource through the client.
For the authorization property to be meaningful, we require
that the involved participants are honest. For example, we
require that the authorization server at which the identity is
registered is honest. If this is not the case (i.e., the attacker
controls the AS),
then the attacker could trivially access
resources. The same holds true for the client for which the
access token is issued: If the user chooses a client that is
controlled by the attacker, then the attacker can trivially access
the resource (as the user authorized the attacker client to do so).
In our model of the FAPI, the client (non-deterministically)
chooses a resource server that the authorization server supports
(this can be different for each login ﬂow). As in the Read-Only
ﬂow, the access token would trivially leak to the attacker if the
resource server is controlled by the attacker, we require that the
resource servers that the AS supports are honest. Furthermore,
in the WIM, the behavior of the user is subsumed in the
browser model, therefore, we require that the browser that
is responsible for the user identity that is involved in the ﬂow
should be honest. Otherwise, the attacker could trivially obtain
the credentials of the user.
2) Authentication: Informally speaking, the authentication
property states that an attacker should not be able to log in at
a client under the identity of an honest user. More precisely,
we require that in all runs ρ of a FAPI web system FAPI
if in ρ a client considers an honest user (browser) whose ID
is governed by an honest AS to be logged in (indicated by
a service token which a user can use at the client), then the
adversary cannot obtain the service token.
3) Session Integrity: There are two session integrity prop-
erties that capture that an honest user should not be logged in
under the identity of the attacker and should not use resources
of the attacker. As shown in Section IV-D, session integrity is
not given for all conﬁgurations available in the FAPI. Therefore,
we show a limited session integrity property that captures
session integrity for web server clients that use OAUTB.
Nonetheless, our session integrity property here is stronger
than those used in [6], [7] in the sense that we deﬁne (and
prove) session integrity not only in the presence of web
attackers, but also for the much stronger network attacker.
(This is enabled by using the __Secure- preﬁx for cookies.)
Session Integrity for Authorization for Web Server Clients
with OAUTB: Intuitively, this property states that for all runs
ρ of a FAPI web system FAPI , if an honest user can access
the resource of some identity u (registered at AS as) through
the honest web server client c, where c uses OAUTB as the
holder of key mechanism, then (1) the user started the ﬂow at
c and (2) if as is honest, the user authenticated at the as using
the identity u.
Session Integrity for Authentication for Web Server Clients
with OAUTB: Similar to the previous property, this property
states that for all runs ρ of a FAPI web system FAPI , if an
honest user is logged in at the honest client c under some
identity u (registered at AS as), with c being a web server
client using OAUTB as the holder of key mechanism, then (1)
the user started the ﬂow at c and (2) if as is honest, the user
authenticated at the as using the identity u.
By Session Integrity for Web Server Clients with OAUTB
we denote the conjunction of both properties.
Now, our main theorem says that
these properties are
satisﬁed for all FAPI web systems.
Theorem 1. Let FAPI be a FAPI web system with a network
attacker. Then, FAPI is secure w.r.t. authorization and authen-
tication. Furthermore, FAPI is secure w.r.t. session integrity
for web server clients with OAUTB.
We emphasize that the FAPI web systems take into account
the strong attacker the FAPI is supposed to withstand as
explained in Section III-C. Such attackers immediately break
plain OAuth 2.0 and OpenID Connect. This, together with the
various OAuth 2.0 security extensions which the FAPI uses
and combines in different ways, and which have not formally
been analyzed before, makes the proof challenging.
VI. CONCLUSION
In this paper, we performed the ﬁrst formal analysis of
an Open Banking API, namely the OpenID Financial-grade
API. Based on the Web Infrastructure Model, we built a
comprehensive model comprising all protocol participants
(clients, authorization servers, and resource servers) and all
important options employed in the FAPI: clients can be app
clients or web server clients and can make use of either the
Read-Only or the Read-Write proﬁle. We modeled all speciﬁed
methods for authenticating at the authorization server and both
mechanisms for binding tokens to the client, namely, Mutual
TLS and OAuth 2.0 Token Binding. We also modeled PKCE,
JWS Client Assertions, and the JWT Secured Authorization
Response Mode (JARM).
Based on this model, we then deﬁned precise security
properties for the FAPI, namely authorization, authentication,
and session integrity. While trying to prove these properties for
the FAPI, we found several vulnerabilities that can enable an
attacker to access protected resources belonging to an honest
user or perform attacks on session integrity. We developed
ﬁxes against these attacks and formally veriﬁed the security
of the (ﬁxed) OpenID FAPI.
This is an important result since the FAPI enjoys wide
industry support and is a promising candidate for the future
lead in open banking APIs. Financial-grade applications entail
very high security requirements that make a thorough formal
security analysis, as performed in this paper, indispensable.
Our work also constitutes the very ﬁrst analysis of various
OAuth security extensions, namely PKCE, OAuth mTLS,
OAUTB, JARM, and JWS Client Assertions.
Acknowledgements. This work was partially supported by
Deutsche Forschungsgemeinschaft (DFG) through Grant KU
1434/10-2.
(cid:21)(cid:23)(cid:23)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:17 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] “Blurred Lines: How FinTech Is Shaping Financial Services,” 2016. PwC
Global Fin-Tech Report.
[2] European Union, “DIRECTIVE (EU) 2015/2366 OF THE EUROPEAN
PARLIAMENT AND OF THE COUNCIL.” https://eur-lex.europa.eu/
legal-content/EN/TXT/HTML/?uri=CELEX:32015L2366&from=DE.
[3] S. T. Mnuchin and C. S. Phillips, “A Financial System That Creates
Economic Opportunities – Nonbank Financials, Fintech, and Innovation.”
https://home.treasury.gov/sites/default/ﬁles/2018-08/A-Financial-
System-that-Creates-Economic-Opportunities---Nonbank-Financials-
Fintech-and-Innovation_0.pdf.
[4] M. Leszcz, “The UK Open Banking Implementation Entity Adopts
the OpenID Foundation Financial-Grade API (FAPI) Speciﬁcation
& Certiﬁcation Program.” https://openid.net/2018/07/12/the-uk-open-
banking-implementation-entity-adopts-the-openid-foundation-ﬁnancial-
grade-api-fapi-speciﬁcation-certiﬁcation-program/.
[5] OpenID Financial-grade API Working Group, “OpenID Foundation
Financial-grade API (FAPI).” Aug. 23, 2018. https://bitbucket.org/openid/
fapi/src/ceb0f829bc532e9c540efaa94f6f96d007371ca2/.
[6] D. Fett, R. Küsters, and G. Schmitz, “A Comprehensive Formal Security
Analysis of OAuth 2.0,” in Proceedings of the 23nd ACM SIGSAC
Conference on Computer and Communications Security (CCS 2016),
pp. 1204–1215, ACM, 2016.
[7] D. Fett, R. Küsters, and G. Schmitz, “The Web SSO Standard OpenID
Connect: In-Depth Formal Security Analysis and Security Guidelines,”
in IEEE 30th Computer Security Foundations Symposium (CSF 2017),
IEEE Computer Society, 2017.
[8] A. Kumar, “Using automated model analysis for reasoning about security
of web protocols,” in Proceedings of the 28th Annual Computer Security
Applications Conference on - ACSAC’12, Association for Computing
Machinery (ACM), 2012.
[9] C. Bansal, K. Bhargavan, and S. Maffeis, “Discovering Concrete Attacks
on Website Authorization by Formal Analysis,” in 25th IEEE Computer
Security Foundations Symposium, CSF 2012 (S. Chong, ed.), pp. 247–
262, IEEE Computer Society, 2012.
[10] C. Bansal, K. Bhargavan, A. Delignat-Lavaud, and S. Maffeis, “Discov-
ering Concrete Attacks on Website Authorization by Formal Analysis,”
Journal of Computer Security, vol. 22, no. 4, pp. 601–657, 2014.
[11] R. Wang, Y. Zhou, S. Chen, S. Qadeer, D. Evans, and Y. Gurevich,
“Explicating SDKs: Uncovering Assumptions Underlying Secure Authen-
tication and Authorization,” in Proceedings of the 22th USENIX Security
Symposium, Washington, DC, USA, August 14-16, 2013, pp. 399–314,
USENIX Association, 2013.
[12] S. Pai, Y. Sharma, S. Kumar, R. M. Pai, and S. Singh, “Formal
Veriﬁcation of OAuth 2.0 Using Alloy Framework,” in CSNT ’11
Proceedings of the 2011 International Conference on Communication
Systems and Network Technologies, pp. 655–659, Proceedings of the
International Conference on Communication Systems and Network
Technologies, 2011.
[13] S. Chari, C. S. Jutla, and A. Roy, “Universally Composable Security
Analysis of OAuth v2.0,” IACR Cryptology ePrint Archive, vol. 2011,
p. 526, 2011.
[14] S.-T. Sun and K. Beznosov, “The Devil is in the (Implementation) Details:
An Empirical Analysis of OAuth SSO Systems,” in ACM Conference
on Computer and Communications Security, CCS’12 (T. Yu, G. Danezis,
and V. D. Gligor, eds.), pp. 378–390, ACM, 2012.
[15] W. Li and C. J. Mitchell, “Security issues in OAuth 2.0 SSO implemen-
tations,” in Information Security - 17th International Conference, ISC
2014, Hong Kong, China, October 12-14, 2014. Proceedings, pp. 529–
541, 2014.
[16] R. Yang, G. Li, W. C. Lau, K. Zhang, and P. Hu, “Model-based
Security Testing: An Empirical Study on OAuth 2.0 Implementations,”
in Proceedings of the 11th ACM on Asia Conference on Computer and
Communications Security, AsiaCCS 2016, Xi’an, China, May 30 - June
3, 2016, pp. 651–662, ACM, 2016.
[17] E. Shernan, H. Carter, D. Tian, P. Traynor, and K. R. B. Butler, “More
Guidelines Than Rules: CSRF Vulnerabilities from Noncompliant OAuth
2.0 Implementations,” in Detection of Intrusions and Malware, and
Vulnerability Assessment - 12th International Conference, DIMVA 2015,
Milan, Italy, July 9-10, 2015, Proceedings, vol. 9148 of Lecture Notes