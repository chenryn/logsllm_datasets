Old (PHP-5) Zvals 
• Zval is a pointer 
• Zval creation => allocate struct 
• GC – refcount + cycle detection 
• Reference – point same struct 
. 
New Zvals motivation 
• Less derefs 
• Less allocations 
• Designed for embedding 
– In structs 
– In arrays 
– On the stack 
. 
New Zvals 
• Zval is a struct 
• Only value & type 
• zend_value: union 
– primitive value 
– pointer to struct 
. 
Example: int 
$x = 1337; 
zval struct 
value 
1337 
type 
IS_LONG 
. 
New Zvals - GC 
• Refcount depends on type 
– Not refcounted: primitives 
– Refcounted: complex types 
Example: string 
Example: string 
$x = “apple”; 
zval struct 
value 
type 
IS_STRING 
_zend_string 
refcount 
hash 
len 
val[] 
_zend_string 
refcount 
0 
hash 
0 
len 
5 
val[] 
‘a’ 
‘p’ 
‘p’ 
‘l’ 
‘e’ 
‘\0’ 
_zend_string 
refcount 
1 
hash 
0 
len 
5 
val[] 
‘a’ 
‘p’ 
‘p’ 
‘l’ 
‘e’ 
‘\0’ 
. 
New Zvals – references 
• New type: reference 
$x = 1337; 
zval struct ($x) 
value 
1337 
type 
IS_LONG 
New Zvals – references 
• New type: reference 
zval struct ($x) 
value 
1337 
type 
IS_LONG 
_zend_reference 
refcount 
0 
val 
zval struct 
value 
1337 
type 
IS_LONG 
$x = 1337; 
$y = &$x; 
New Zvals – references 
• New type: reference 
$x = 1337; 
$y = &$x; 
zval struct ($x) 
value 
type 
IS_REFERENCE 
_zend_reference 
refcount 
1 
val 
zval struct 
value 
1337 
type 
IS_LONG 
New Zvals – references 
• New type: reference 
$x = 1337; 
$y = &$x; 
zval struct ($x) 
value 
type 
IS_REFERENCE 
zval struct ($y) 
value 
type 
IS_REFERENCE 
_zend_reference 
refcount 
2 
val 
zval struct 
value 
1337 
type 
IS_LONG 
. 
ZVALS Take Away 
• Designed for embedding 
• Less derefs & heap use 
• References - complicated 
. 
(AKA vulns) 
Use Uninitialized Value 
• SplObjectStorage::unserialize 
• Which leads to 
– rval = &inf 
. 
Type Confusion 
• Making a Reference… 
• Change type 
• SplObjectStorage::unserialize 
. 
Type Confusion 
php_var_unserialize(&entry) 
Type Confusion 
php_var_unserialize(&entry) 
zval struct (entry) 
value 
type 
IS_OBJECT 
_zend_object 
…. 
Type Confusion 
php_var_unserialize(&entry) 
if (Z_TYPE(entry) != IS_OBJECT) { /* ERROR!!! */ } 
zval struct (entry) 
value 
type 
IS_OBJECT 
_zend_object 
…. 
Type Confusion 
php_var_unserialize(&entry) 
if (Z_TYPE(entry) != IS_OBJECT) { /* ERROR!!! */ } 
php_var_unserialize(&inf) 
zval struct (entry) 
value 
type 
IS_OBJECT 
_zend_object 
…. 
Type Confusion 
php_var_unserialize(&entry) 
if (Z_TYPE(entry) != IS_OBJECT) { /* ERROR!!! */ } 
php_var_unserialize(&inf) 
zval struct (entry) 
value 
type 
IS_OBJECT 
_zend_reference 
refcount 0 
val 
zval struct 
value 
type 
IS_OBJECT 
_zend_object 
…. 
Type Confusion 
php_var_unserialize(&entry) 
if (Z_TYPE(entry) != IS_OBJECT) { /* ERROR!!! */ } 
php_var_unserialize(&inf) 
zval struct (entry) 
value 
type 
IS_REFERENCE 
_zend_reference 
refcount 1 
val 
zval struct 
value 
type 
IS_OBJECT 
_zend_object 
…. 
Type Confusion 
php_var_unserialize(&entry) 
if (Z_TYPE(entry) != IS_OBJECT) { /* ERROR!!! */ } 
php_var_unserialize(&inf) 
zval struct (entry) 
value 
type 
IS_REFERENCE 
_zend_reference 
refcount 2 
val 
zval struct 
value 
type 
IS_OBJECT 
zval struct (inf) 
value 
type 
IS_REFERENCE 
_zend_object 
…. 
. 
Use After Free 
• Pointing to dynamic struct 
• var_unserializer.c:process_nested_data 
• data points to ht 
• data stored in var_hash 
• when ht resized 
• ht reallocated 
. 
Use After Free 
var_hash 
zval struct 
value 
type 
IS_OBJECT 
_zend_object 
… 
properites 
. 
zval struct 
zval struct 
value 
0 
value 
1 
type 
IS_LONG 
type 
IS_LONG 
zval struct 
zval struct 
zval struct 
value 
0 
value 
1 
value 
2 
type 
IS_LONG 
type 
IS_LONG 
type 
IS_LONG 
Use After Free 
• Not very common 
• Unserialize ensure size ht 
• Yet…  
• __wakeup define property 
• DateInterval add properties 
. 
Bugs Take Away 
• More unserialize vulns 
• Different vulns 
• Use freed values 
. 
(WHERE MEMORY COMES FROM) 
Old (PHP-5) Allocator 
• Heap 
• Meta data per slot 
– Size 
– Flags 
• Free List 
. 
PHP-7 Allocator 
• Complete Rewrite 
• Bins 
• Free Lists 
. 
Allocator 
• Allocate CHUNK from OS (2MB) 
• Divide to PAGES (4096B) 
• First page – descriptor 
– List of allocated and free pages 
– Pointers to BINS 
• BIN 
– free list 
– By size 
– Multiple pages 
. 
New CHUNK 
CHUNK 
chunk 
descriptor 
free_slots 
page_info 
. 
New BIN 
CHUNK 
chunk 
descriptor 
free_slots 
page_info 
16 
… 
. 
emalloc(size) 
bin_num = size2bin(size) 
if NULL == heap->free_slots[bin_num] 
init_bin(heap, bin_num) 
return pop(heap->free_slots[bin_num]) 
emalloc 
CHUNK 
chunk 
descriptor 
free_slots 
page_info 
16 
… 
32 
. 
efree(ptr) 