# 【技术分享】Windows x64 shellcode编写指南
|
##### 译文声明
本文是翻译文章，文章来源：tophertimzen.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
翻译：[xgxgxggx](http://bobao.360.cn/member/contribute?uid=2830254841)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**前言**
最近我重写了几个shellcode，将之前32位平台下实现的shellcode移植到64位平台。在向64位平台移植过程，我发现很难在网上找到相关资料，因此我将我的移植过程写成一篇博客（我的第一篇），希望能帮到像我一样需要移植64位shellcode的人。  
网上已经有几篇教程介绍关于shellcode的相关基础知识了，因此我不会介绍这些。虽然我会介绍关于调用约定、register
clobbering和寄存器相关知识，但是我不会讨论很多汇编基础知识。
请参考Skape的[Understanding Windows Shell
code](https://publish.adlab.corp.qihoo.net:8360/contribute/www.nologin.com/Downloads/Papers/win32-shellcode.pdf)等文章，或者资源[project-shellcode](http://www.projectshellcode.com/)进行深入学习(Understanding Windows Shell
code原始链接失效，这里替换了，原始链接为[http://repo.hackerzvoice.net/depot_madchat/windoz/vulns/win32-shellcode.pdf)。](http://repo.hackerzvoice.net/depot_madchat/windoz/vulns/win32-shellcode.pdf\)%E3%80%82)
我将介绍32位汇编与64位汇编的差异，以及如何利用Windows系统中的结构体用于开发64位shellcode。我还将介绍我开发的2种漏洞利用辅助开发工具。
在开始之前需要说明的是我仍然在学习漏洞利用开发的初级阶段，为简单化，本文实验的系统为Window 7
x64版本。为简化叙述，x86指Win32平台，x64指Win64平台。
**寄存器(Registers)**
**x86**
x86处理器中有8个32位的通用寄存器
– eax-累加器
– ecx-计数寄存器
– edx-数据寄存器
– ebx-基地址寄存器
– esp-堆栈指针
– ebp-基址指针
– esi-源索引寄存器
– edi-目标索引寄存器
– eip-指令寄存器
由于向后兼容原因，其中4个寄存器（eax,ebx,ecx,edx）可以拆分16位和8位寄存器
– AX-EAX的低16位
– AH-AX的高8位
– AL-AX的低8位
– BX-EBX的低16位
– BH-EBX的高8位
– BL-EBX的低8位
ECX和EDX也使用字母（C,D）和后缀（X,H或L）表示16位和8位寄存器。
**x64**
64位处理器使用前缀“R”扩展上述8个寄存器，RAX,RCX,RDX等。需要注意的是x86平台下的寄存器表示方式仍然可用（eax,ax,al等）。
还引入了8个新的寄存器，r8、r9、r10、r11、r12、r13、r14和r15。这些寄存器也可以分为32位、16位和8位的版本。
– r#=64位
– r#d=低32位
– r#w=低16位
– r#b=8位
不幸的是，这些新的8位扩展寄存器不能够使用像eax中的低16位的高8位
**Clobber寄存器(Clobber Registers)**
Clobber寄存器是一些可能在函数（如Windows
API）中被覆盖修改的寄存器。在汇编代码中不应该使用这些寄存器，容易引发程序不稳定，但是如果明确知道在api函数中那些寄存器会别修改还是可以使用这些寄存器的。
在Win32 API中,EAX、ECX和EDX都是Clobber寄存器，在Win64
API中，除了RBP、RBX、RDI、RSI、R12、R13、R14和R15，其他的寄存器都是Clobber寄存器。  
RAX和EAX分别用于x64和x86函数的返回值。
**调用约定(Calling Convention)**
**x86**
Win32 API一般使用__stdcall调用约定，从右到左向堆栈上传递参数。
如调用函数有两个参数int x和int y的函数foo
    foo(int x,int y)  
在堆栈上传递为
    push y  
    push x  
**x64**
Win64平台下函数调用约定不同，但与Win32平台下的__fastcall相似，均使用寄存器传参，前四个参数分别使用RCX、RDX、R8和R9传递，其他多余的参数使用堆栈传递。需要注意的是，使用寄存器传参时从右到左传递参数。
如对Windows函数MessageBox的调用声明如下：
    int WINAPI MessageBox(  
    _In_opt_  HWND hWnd,  
    _In_opt_  LPCTSTR lpText,  
    _In_opt_  LPCTSTR lpCaption,  
    _In_      UINT uType  
    );
在Win64调用预定下，参数为:
    r9 = uType  
    r8 = lpCaption  
    rdx = lpText  
    rcx = hWnd
**Shellcode**
****让我们开始吧，现在Win64下的Shellcode与Win32的关键区别我们已经知道了，开始我们的文章吧。  
为显示运行Win64
shellcode，我将编写代码弹出MessageBox对话框。当shellcode最终完成后，我将使用我编写的工具将shellcode代码注入到calc进程中，验证shellcode能够在另一个进程中运行。
**注释**
我将使用NASM编译汇编代码，使用Jeremy
Gordon编写的golink链接程序。使用你最喜欢的文本编辑器编辑汇编代码，我使用Windows平台下的Notepad++,然后开始编写代码。
**开始**
**1).声明NASM指令**
    bits 64 
    section .text
    global start
**2).设置堆栈**
    start: 
        sub rsp, 28h                ;reserve stack space for called functions
        and rsp, 0fffffffffffffff0h ;make sure stack 16-byte aligned
**3).得到Kernel32的基地址**
Win64与Win32平台的PEB结构位置是不同的，在Win32中，PEB为[fs:30h]指向的地址，而在Win64为[gs:60h]
虽然PEB结构发生了巨大变化，但是我们只关心LDR链表(PEB_LDR_DATA)所在的未知，在Windbg中使用&rdquo;!peb&rdquo;命令可以得到LDR所在的位置。
在Windbg输出的PEB结构中，Ldr.InMemoryOrderModuleList中包含Kernel32.dll,在链表第三个未知，此列表显示了进程中各个内存模块（PE文件，可执行文件和dll文件）在内存中所在的位置。
    Ldr.InMemoryOrderModuleList:         00000000002b3150 . 00000000002b87d0
            Base TimeStamp                     Module
        ff600000 4a5bc9d4 Jul 13 16:57:08 2009 C:WindowsSystem32calc.exe
        77b90000 4ce7c8f9 Nov 20 05:11:21 2010 C:WindowsSYSTEM32ntdll.dll
        77970000 4ce7c78b Nov 20 05:05:15 2010 C:Windowssystem32kernel32.dll
通过在Windbg中使用dt命令填充PEB结构，确定Ldr链表所在的位置。
    0:000> dt _PEB 000007fffffd4000
    ntdll!_PEB
       +0x000 InheritedAddressSpace : 0 ''
       +0x001 ReadImageFileExecOptions : 0 ''
       +0x002 BeingDebugged    : 0x1 ''
       +0x003 BitField         : 0x8 ''
       +0x003 ImageUsesLargePages : 0y0
       +0x003 IsProtectedProcess : 0y0
       +0x003 IsLegacyProcess  : 0y0
       +0x003 IsImageDynamicallyRelocated : 0y1
       +0x003 SkipPatchingUser32Forwarders : 0y0
       +0x003 SpareBits        : 0y000
       +0x008 Mutant           : 0xffffffff`ffffffff Void
       +0x010 ImageBaseAddress : 0x00000000`ff600000 Void
       +0x018 Ldr              : 0x00000000`77cc2640 _PEB_LDR_DATA
Ldr链表位于PEB的0x18位置
现在，我们还需要做一下步骤：
– 通过在PEB偏移0x18处获得Ldr链表，获得Ldr链表后，访问位于Ldr结构偏移0x20处的InMemoryOrderModuleList，如下输出
    0:000> dt _PEB_LDR_DATA 77cc2640
    ntdll!_PEB_LDR_DATA
       +0x000 Length           : 0x58
       +0x004 Initialized      : 0x1 ''
       +0x008 SsHandle         : (null) 
       +0x010 InLoadOrderModuleList : _LIST_ENTRY [ 0x00000000`002b3140 - 0x00000000`002b87c0 ]
       +0x020 InMemoryOrderModuleList : _LIST_ENTRY [ 0x00000000`002b3150 - 0x00000000`002b87d0 ]
       +0x030 InInitializationOrderModuleList : _LIST_ENTRY [ 0x00000000`002b3270 - 0x00000000`002b87e0 ]
       +0x040 EntryInProgress  : (null) 
       +0x048 ShutdownInProgress : 0 ''
       +0x050 ShutdownThreadId : (null)
–
偏移0x20处为InMemoryOrderModuleList，由InMemoryOrderModule列表的输出的图中可以看出，Kernel32.dll是第3个内存模块。在_LIST_ENTRY结构包含向前和向后的指针，所有_LIST_ENTRY组成一个循环链表，通过这个链表可以找到Kernel32的基地址。
    0:000> dt _LIST_ENTRY