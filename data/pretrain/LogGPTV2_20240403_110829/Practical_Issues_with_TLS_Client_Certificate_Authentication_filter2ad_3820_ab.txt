### Certificate Chain Post-Verification at Application Level

Performing certificate chain post-verification at the application level is non-trivial. The `mod_ssl` module exports the client certificate in the `SSL_CLIENT_CERT` environment variable and additional certificates provided in the client's `Certificate` message in the `SSL_CLIENT_CERT_CHAIN_n` variables (which are not preserved on session resumption). However, the chain used in the verification process is not exported.

### TLS Client Certificate Authentication (CCA) Deployments

Most practical TLS CCA deployments use either `require` or `optional` values for the `SSLVerifyClient` configuration directive. Based on private discussions with service providers, the only verification step typically performed at the application level is to check whether the `commonName` attribute of the subject DN in the client certificate contains the name and personal identity code of the natural person in the expected format. `mod_ssl` provides the subject DN in the `SSL_CLIENT_S_DN` environment variable, or it can be extracted from the client certificate using, for example, the `openssl_x509_parse()` function available in PHP. If this check succeeds, the person is considered authenticated, and the server-side application proceeds with authorization using the extracted personal identity code.

### Reconnaissance

We found that all `mod_ssl` and OpenSSL client certificate verification checks are performed before the client sends the `CertificateVerify` message, which proves possession of the corresponding private key. This allows an attacker to enumerate the server's trust settings by using easily obtainable certificates. For example, an attacker can send an arbitrary certificate in the client's `Certificate` message and observe whether the server aborts the handshake by sending an alert message before receiving the `CertificateVerify` message. If the server does not abort, the attacker can conclude that the certificate is in the server's `SSLCACertificateFile` trust store (unless `SSLVerifyClient` is set to `optional_no_ca`). The server's trust settings, in the form of DNs of the CAs in the trust store, are also disclosed in the `CertificateRequest` message unless explicitly overridden by the `SSLCADNRequestFile` directive.

The value of `SSLVerifyClient` can be similarly determined by sending an arbitrary self-signed client certificate in a TLS CCA handshake. If the handshake succeeds, `SSLVerifyClient` is set to `optional_no_ca`. Otherwise, an empty `Certificate` message can be sent to distinguish between `optional` and `require`.

Additionally, an attacker can determine the `SSLVerifyDepth` value if they have any root certificate in the server's `SSLCACertificateFile` trust store. To do this, the attacker must send a fake certificate chain in the client's `Certificate` message, chaining up to any root certificate in the server's trust store. Certificates in the fake chain must contain the correct issuer description to pass the certificate chain building algorithm in OpenSSL, but the signatures must be invalid. If the `SSLVerifyDepth` is exceeded, the server will abort the handshake with a `certificate_unknown` alert message. If not, OpenSSL will continue with signature verification, which will fail, and the TLS handshake will be aborted with a `decryption_failed` alert message. If `SSLVerifyClient` is set to `optional_no_ca`, the attacker can send a fake chain that chains up to any self-signed root CA certificate included in the attacker's `Certificate` message. In this case, if the `SSLVerifyDepth` is exceeded, the handshake will fail with an `unknown_ca` alert message.

### Privacy of Client’s Certificate

As shown in Figure 1, the client's `Certificate` message is sent before encryption is applied, making the content of the client's certificate available to passive network attackers. Certificates issued to natural persons usually contain the name and personal identity code. Even if a certificate does not include personal data, the public key can be used by a passive network attacker to track the client. A TLS extension has been proposed to the IETF Network Working Group to allow encrypting the client certificate in the initial TLS handshake by moving the client's `Certificate` message after the `ChangeCipherSpec` message. Another proposed TLS extension provides opportunistic encryption for the entire TLS handshake. However, these extensions have not yet been standardized, and even if they were, it would take years for them to be widely deployed and supported.

A practical workaround to protect the client certificate is for the server to request the client certificate during renegotiation. This way, the client's `Certificate` message will be encrypted by the cipher suite negotiated in the previous TLS negotiation. This can be configured by specifying the `SSLVerifyClient` directive in the Apache directory context. However, renegotiation negatively impacts performance, as an additional handshake is performed. Performance can be improved if both the client and server enable TLS session resumption. Unfortunately, recent versions of `mod_ssl` do not support resumption of TLS sessions established during renegotiation.

None of the analyzed browsers warn users about the privacy leak if the TLS server requests CCA during the initial TLS negotiation.

### Denial-of-Service (DoS) Attack Vectors

TLS CCA-enabled `mod_ssl` faces additional DoS attack vectors. On the server side, OpenSSL must perform ASN.1 parsing on arbitrary certificates provided in the client's `Certificate` message. The signatures on the built chain and the client's signature of handshake messages in the `CertificateVerify` message must also be verified. Parsing ASN.1 structures is complex, and OpenSSL has had security vulnerabilities when parsing untrusted data. Recently, a DoS attack tool has been released that exploits computational asymmetry in a server-authenticated TLS handshake.

OpenSSL enforces several limitations:
- The handshake will fail if the client's `Certificate` message exceeds 100 kilobytes.
- The handshake will fail if the `CertificateVerify` message exceeds 512 bytes, limiting the RSA modulus to 4096 bits.
- Chain building stops if its depth exceeds 100.
- Signatures on the certificate chain will not be verified if the chain exceeds the depth configured by the `SSLVerifyDepth` directive.

Additionally, signature verification will fail if the RSA public key modulus exceeds 16384 bits or if the public exponent for an RSA public key with a modulus larger than 3072 bits exceeds 64 bits. Our experiment shows that with an "Intel Core 2 Duo" processor, 26 RSA verifications per second can be performed with a 16384-bit modulus and the maximum allowed 64-bit public exponent, and only 20 RSA verifications per second with a 3072-bit modulus and a 3072-bit public exponent.

Since signatures on the certificate chain are verified starting from the root CA certificate down to the client certificate, an attacker would need a certificate in the chain with these characteristics, signed by a CA that chains up to a root CA in the server's trust store, which is unlikely. If `SSLVerifyClient` is set to `optional_no_ca`, the attacker can provide an arbitrary certificate chain, and OpenSSL will verify signatures as long as the chain does not exceed the depth limit. The default `SSLVerifyDepth` value is 1, resulting in two signature verification operations per handshake. In the worst-case scenario, where `SSLVerifyClient` is set to `optional_no_ca` and `SSLVerifyDepth` is set to 100, an attacker could send a certificate chain containing 75 certificates, each with a 3072-bit modulus and a 3072-bit public exponent, almost reaching the 100KB limit for the `Certificate` message size. This would force a server with the described processor to spend four seconds processing the handshake.

Another DoS attack vector exists if the server requests TLS CCA on renegotiation after receiving an HTTP request. The request body must be buffered by the server before renegotiation, and the request body can be processed or discarded by the target resource. To prevent memory exhaustion, `mod_ssl` provides the `SSLRenegBufferSize` directive, which limits the request body size (default is 256KB). If the client sends a larger request body, the server returns a 413 Request Entity Too Large error. This creates a problem for servers that must support large POST requests. A workaround is for the client to include the `Expect: 100-continue` header field, sending the request body only after the TLS CCA is performed and the server responds with a 100 Continue status code. However, this mechanism is not used by browsers, so servers requiring TLS CCA on renegotiation and supporting large POST requests must set `SSLRenegBufferSize` to a large value, providing a DoS attack vector.

### Freshness of the Client’s Proof

In a CCA process, the client proves to the server that they have access to the private key corresponding to the public key in the client's certificate. This is done by signing a message digest of previously exchanged TLS handshake messages and providing the signature in the `CertificateVerify` message. It is crucial for the server-side application to determine the freshness of this proof. For example, the server's security policy might require that the client prove recent access to their smart card before performing an authenticated action.

We found that there is no environment variable provided by `mod_ssl` to reliably determine the freshness of the proof given in the TLS CCA process. From the protocol description, the client cannot compute a signature before the server sends its `ServerHello` message, which contains the server's randomness and cannot be predicted by the client. The contents of all further messages up to the `CertificateVerify` message can be predicted by the client. Therefore, the freshness of the client's possession of the private key could be determined by the timestamp indicating when the server sent its `ServerHello` message.

Even if TLS session resumption is not enabled, the time of the HTTP request cannot be reliably used by the server-side application to calculate the freshness of the client's proof of possession. The assumption that the TLS connection will timeout if the `CertificateVerify` message is not provided soon enough after the `ServerHello` message does not hold. OpenSSL itself does not enforce a timeout, but Apache has a default timeout of 300 seconds, configurable by the `TimeOut` directive. However, this timeout counter is reset whenever new data is added to the read or write buffer. By using TLS fragmentation and sending empty TLS message fragments, the TLS connection can be kept open indefinitely before sending the `CertificateVerify` message.

After the release of the DoS attack tool Slowloris, which tries to open many connections to the target server and keep them open, the Apache HTTP server starting from version 2.2.15 includes the `mod_reqtimeout` module, which imposes restrictions on the minimum transfer speed and the time a client is allowed to stay connected. Debian GNU/Linux and most software distributions based on Debian ship Apache with `mod_reqtimeout` enabled by default. The default configuration forces the connection to be terminated if the client's HTTP request header is not received within 40 seconds. However, the total time for receiving an HTTP request body is not enforced as long as the first byte of the request body is received within the first 10 seconds and the minimum data transfer rate of 500 bytes per second is maintained. Since the TLS renegotiation process is part of the request body receiving process, the renegotiation handshake can be kept open indefinitely as long as the data rate of 500 bytes per second is maintained. In practice, one TLS record containing an AES-encrypted empty handshake message padded to the maximum allowed length will have a size of 277 bytes; therefore, two such TLS records must be sent per second to maintain the required data rate.

As a result, many servers requiring TLS CCA might not put a time constraint on an attacker for obtaining a signature once the data to be signed is known. This can be exploited, for example, in the Estonian ID card case if the victim provides a padding oracle to the attacker. Since forging a signature using a padding oracle attack requires thousands of oracle calls to the ID card, the attacker can obtain a forged signature several hours after the data to be signed is known. This limitation might not be a problem, and a padding oracle attack can be practically exploited to perform CCA on behalf of the victim if the attacker has access to such an oracle.

Even if a server-side application could obtain the time the client performed CCA, another problem arises. Server-side scripting engines do not provide function calls to communicate to the underlying `mod_ssl` that a particular TLS session should be cleared to request client certificate re-authentication. Browsers also do not provide an API to force TLS session deletion from the client side.

### Certificate Revocation Checking

At the `mod_ssl` level, client certificate revocation checking can be performed using a certificate revocation list (CRL). The `SSLCARevocationFile` directive specifies the location of CRLs used for certificate chain revocation checking. Only direct CRLs are supported, and only those certificates for which CRLs are provided will be checked. When CRL files are updated, the Apache process must be gracefully restarted (using signal USR1) to reload the CRLs. The TLS CCA handshake will fail if an outdated CRL is specified, i.e., if `nextUpdate` is in the past. However, there is no check to ensure `thisUpdate` is not in the future, so outdated CRLs used by servers with backward system time will not be detected.

In `mod_ssl` version 2.4, revocation checks can also be performed using the Online Certificate Status Protocol (OCSP).

### CCA Audit Trail

HTML form-based password authentication provides a flexible way to record authentication success and failures at the application level. However, in the case of `mod_ssl`, CCA failure for any reason ends with a TLS handshake failure without reaching the application level. Therefore, CCA auditing must be done at the `mod_ssl` level.

To fully benefit from the auditing process, the logging provided by `mod_ssl` is insufficient. When using the `LogLevel` value `error`, only general CCA success and failure messages are logged. When `LogLevel` is set to `debug`, the subject DN of the certificate and the packets received by OpenSSL are dumped into the log file. However, if CCA is performed on renegotiation, the packets of the handshake are in an encrypted form. The full TLS CCA handshake should be logged in a decrypted form to allow investigation of the precise reasons for authentication failure and, in the case of successful CCA, to use the handshake messages as proof that the server interacted with a client who possessed the private key corresponding to the client's certificate. The proof would even indicate the time period, as the randomness in the `ClientHello` and `ServerHello` messages contains the timestamp of the client and server, and the server's `Certificate` message contains the validity period of the certificate.

### CCA Support in Browsers

When a server requests CCA, the browser asks the user whether to perform CCA and which certificate to use. The client certificate selection windows as implemented by browsers are shown in Figure 2. The Chrome browser has different selection windows in Linux and Windows, as it uses the NSS library for TLS in Linux and SChannel and Windows certificate management facilities in Windows.

The client certificate selection windows provide different levels of detail. Chrome uses the address from the address bar to indicate the CCA requesting party, while Firefox shows information from the server's certificate. Unfortunately, Internet Explorer (IE) does not inform the user which party is requesting CCA in its client certificate selection window.

The list of certificates in the selection window is filtered according to the list of CA DNs provided in the server's `CertificateRequest` message. If the server sends an empty list of DNs, the browser offers to select any client certificate the user has. Certificates whose purpose specified in the certificate extensions is not consistent with CCA are not listed. Additionally, IE and Chrome do not list client certificates that are not yet valid or have expired. If the user has no suitable client certificates for authentication, the certificate selection window is not shown, and an empty `Certificate` handshake message is sent.

The Firefox certificate selection window has an additional option "Remember this decision," which is enabled by default. Disabling this option would significantly degrade the user experience, as the user would be asked to select the certificate again whenever a new TLS session is established with the server. IE and Chrome do not support disabling this option and automatically cache the certificate choice for a particular server until the browser is restarted or the user manually clears the TLS cache. However, caching the client certificate choice creates usability and security issues. If the user selects the wrong certificate and wants to authenticate with a different one or prevent the browser from performing further CCA with the server (e.g., after logout), the user must restart the browser or manually clear the TLS cache, disrupting all connections in the current browsing session.

Firefox exposes a JavaScript non-standard function `window.crypto.logout()`, which clears the TLS session cache and certificate choice for the server in whose browser security domain the function is called. This function can be used by server-side applications to provide true logout functionality and allow the user to re-authenticate with a different client certificate. Unfortunately, similar functionality is not provided by Chrome. However, Chrome clears the client certificate choice if the TLS CCA handshake is not successful, preventing deadlock if the user chooses the wrong client certificate.