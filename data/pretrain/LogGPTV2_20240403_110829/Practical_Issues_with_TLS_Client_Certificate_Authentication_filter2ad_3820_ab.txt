parties.
It is not trivial to perform certiﬁcate chain post-veriﬁcation at
application level. The mod_ssl exports the client certiﬁcate
in the SSL_CLIENT_CERT environment variable and extra
certiﬁcates provided in the client’s Certificate message in
the SSL_CLIENT_CERT_CHAIN_n variables (not preserved
on session resumption), but the chain used in the veriﬁcation
process is not exported.
Most TLS CCA deployments in practice use require or
optional values for the SSLVerifyClient conﬁguration
directive, and as we have found from private discussion with
service providers,
the only veriﬁcation step performed at
the application level is to check whether the commonName
attribute of the subject DN in the client certiﬁcate contains
the name and personal identity code of the natural person
in the expected form (mod_ssl provides subject DN in
the environment variable SSL_CLIENT_S_DN or it can be
extracted from the client certiﬁcate using, for example, the
function openssl_x509_parse()1 available in PHP). If
this check succeeds, the person is assumed to be authenticated
and the server-side application continues with the authorization
using the extracted personal identity code.
1http://www.php.net/manual/en/function.openssl-x509-parse.php
C. Reconnaissance
We found that all mod_ssl and OpenSSL client certiﬁ-
cate veriﬁcation checks are done before the client has sent
his CertificateVerify message proving that he is in
possession of a corresponding private key. This allows the
enumeration of the server’s trust settings by using certiﬁcates
which may be easily obtained by the attacker. For example,
an attacker could send an arbitrary certiﬁcate in the client’s
Certificate message and observe whether the server
aborts the handshake by sending an alert message before
receiving the client’s CertificateVerify message. If
the server does not abort the connection, the attacker can
conclude that the certiﬁcate in question is indeed located in
the server’s SSLCACertificateFile trust store (unless
SSLVerifyClient is set
to optional_no_ca). Note
that the server’s trust settings in the form of DNs of the
CAs located in the server’s trust store are also disclosed
in the CertificateRequest message, if not explicitly
overridden by the SSLCADNRequestFile directive.
The value of SSLVerifyClient can be similarly deter-
mined, for instance, by sending an arbitrary self-signed client
certiﬁcate in a TLS CCA handshake. If the handshake suc-
ceeds, the SSLVerifyClient is set to optional_no_ca.
Otherwise, an empty Certificate message can be sent to
distinguish between optional and require.
However, we have discovered that an attacker can also
the attacker
determine the SSLVerifyDepth value if
has any root certiﬁcate that
is located in the server’s
SSLCACertificateFile trust store. In order to do that
an attacker has to send a fake certiﬁcate chain in the client’s
Certificate message, that chains up to any root certiﬁ-
cate in the server’s SSLCACertificateFile trust store.
Certiﬁcates in the fake chain have to contain the correct
issuer description so that the certiﬁcate chain building al-
gorithm in OpenSSL succeeds; however, the signatures on
the certiﬁcates must be invalid. If the SSLVerifyDepth
has been exceeded, the server will abort the handshake by
sending a certificate_unknown alert message. How-
ever, if the SSLVerifyDepth was not exceeded, OpenSSL
will continue with signature veriﬁcation on the certiﬁcate
chain, which will
fail and the TLS handshake will be
aborted with a decryption_failed alert message. If the
SSLVerifyClient option optional_no_ca is used, the
attacker can send a fake chain that chains up to any attacker’s
chosen self-signed root CA certiﬁcate that
is included in
the attacker’s Certificate message. In this case, if the
SSLVerifyDepth has been exceeded the handshake will
fail with an unknown_ca alert message.
D. Privacy of Client’s Certiﬁcate
As can be seen in Fig. 1, the client’s Certificate mes-
sage is sent before encryption has been applied; therefore, the
content of a client’s certiﬁcate is available to passive network
attackers. Certiﬁcates issued by CAs to natural persons usually
contain at least the name and personal identity code of a per-
son. Even if a certiﬁcate does not include any personal data, the
public key in the certiﬁcate can be used by a passive network
attacker to track the client. A TLS extension [11] has been
proposed for standardization to the IETF Network Working
Group that allows a client certiﬁcate to be encrypted in the
initial TLS handshake by moving the client’s Certificate
message after the client’s ChangeCipherSpec message.
4
Another proposed TLS extension [12] provides opportunistic
encryption for the whole TLS handshake. However,
these
extensions have not yet been standardized and even if they
had, it would take years for them to be widely deployed and
supported.
A practical workaround that can be used to protect the
client certiﬁcate is for a server to request the client certiﬁ-
cate on renegotiation. This way, the client’s Certificate
message will be encrypted by the cipher suite negotiated
by the previous TLS negotiation. As stated before, this can
be conﬁgured by specifying mod_ssl conﬁguration direc-
tive SSLVerifyClient in the Apache directory context.
However,
the renegotiation has a negative impact on per-
formance, since an additional handshake is performed when
renegotiating. The performance can be improved if the TLS
session resumption is enabled by both a client and a server.
Unfortunately, recent versions of mod_ssl do not support
resumption of TLS sessions that have been established on
renegotiation [13].
We have observed that none of the browsers analyzed warn
the user about the privacy leak if the TLS server requests CCA
on initial TLS negotiation.
E. Denial-of-service Attack Vectors
The TLS CCA enabled mod_ssl faces additional denial-
of-service (DoS) attack vectors. On the server-side OpenSSL
has to perform ASN.1 parsing on arbitrary certiﬁcates that
are provided in the client’s Certificate message. The
signatures on a built chain have to be veriﬁed and the client’s
signature of handshake messages provided in the client’s
CertificateVerify message must also be veriﬁed. Pars-
ing of ASN.1 structures is not a trivial task and OpenSSL
has had security vulnerabilities that can be exploited if ASN.1
parsing is performed on untrusted data [14]. Recently a DoS
attack tool2 has been released which exploits computational
asymmetry in a server-authenticated TLS handshake.
message is larger than 100 kilobytes;
But what impact might the TLS CCA have on a server? We
found that there are several limitations enforced by OpenSSL:
• the handshake will fail if the client’s Certificate
• the handshake will fail if the CertificateVerify
message is larger than 512 bytes, which means that the
maximum length of the RSA modulus that the client’s
public key can have is 4096 bits.
• chain building will stop when its depth exceeds 100;
• the signatures of the certiﬁcate chain will not be veriﬁed
if the chain is larger than the depth conﬁgured by the
mod_ssl SSLVerifyDepth directive;
In addition to the above, signature veriﬁcation will not be
performed and will fail if the modulus of the RSA public key
is larger than 16384 bits or if the public exponent for a RSA
public key whose modulus is larger than 3072 bits is larger
than 64 bits. Our experiment shows that with an “Intel Core
2 Duo PI:EMAIL” processor, 26 RSA veriﬁcations per
second can be performed with a public key having a 16384-
bit modulus and the maximum allowed 64-bit public exponent,
and only 20 RSA veriﬁcations per second with a public key
having a 3072-bit modulus and a 3072-bit public exponent.
Since the signatures on a certiﬁcate chain are veriﬁed starting
from the root CA certiﬁcate down to the client certiﬁcate, an
2http://www.thc.org/thc-ssl-dos/
5
attacker would need to have a certiﬁcate in a certiﬁcate chain
whose public key had these characteristics and was signed
by a CA that chained up to a root CA located in server’s
SSLCACertificateFile trust store, which is unlikely to
happen. Unfortunately, if the SSLClientVerify is set to
optional_no_ca,
the attacker can provide an arbitrary
certiﬁcate chain in the Certificate message and signatures
will be veriﬁed by OpenSSL as long as the chain does not
exceed the depth limit conﬁgured by SSLVerifyDepth. The
default conﬁguration value for SSLVerifyDepth is 1, which
would result in OpenSSL performing two signature veriﬁcation
operations per handshake – one to verify the signature on the
certiﬁcate chain and another to verify the signature given in the
CertificateVerify message. The worst case scenario,
where SSLClientVerify is set to optional_no_ca and
SSLVerifyDepth is set to 100, would allow an attacker to
send a certiﬁcate chain in a Certificate message contain-
ing 75 certiﬁcates (whose public keys have a 3072-bit modulus
and a 3072-bit public exponent) reaching almost 100KB of the
maximum allowed for a Certificate message size, and
would force a server that had the processor described above
to spend four seconds of wall time processing the handshake.
Another DoS attack vector exists if the server requests
TLS CCA on renegotiation after receiving an HTTP request.
The problem in this scenario is that
the request body of
an HTTP request has to be buffered by the server before
renegotiation is performed and the request body can be pro-
cessed or discarded by the target resource [15]. To prevent
possible memory exhaustion by a DoS attack, mod_ssl
provides conﬁguration directive SSLRenegBufferSize,
which limits the request body size that may be buffered
by the server (the default value is 256KB). If the client
sends a larger request body,
the server will return error
413 Request Entity Too Large. This creates a prob-
lem if the server must support
large POST requests. The
workaround that can be used by the client is to include a header
ﬁeld Expect: 100-continue in the request header sent
to the server, sending the request body only after the TLS CCA
has been performed and the server has responded with status
code 100 Continue [15]. Unfortunately, this mechanism is
not used by browsers [16] and therefore servers that require
TLS CCA on renegotiation and must support large POST
requests will have to set SSLRenegBufferSize to a large
value, thereby providing a DoS attack vector.
F. Freshness of the Client’s Proof
In a CCA process the client proves to the server that he has
access to the private key that corresponds to the public key
in the client’s certiﬁcate. This is done by signing a message
digest of previously exchanged TLS handshake messages and
providing a signature in the client’s CertificateVerify
message. For a server-side application it is crucial to determine
the freshness of this proof. For example, the server’s security
policy might require that before some authenticated action can
be performed, the client must prove that he has had recent
access to his smart card. We have found that there is no
environment variable provided by mod_ssl that could be used
to reliably determine the freshness of the proof given in the
TLS CCA process. From the protocol description we see that
the client cannot compute a signature before the server has
sent its ServerHello message which contains the server’s
randomness and therefore cannot be predicted by the client,
while the contents of all further messages up to the client’s
CertificateVerify message can be predicted by the
client. Therefore, the freshness of a client’s possession of the
private key could be determined by the timestamp indicating
the moment when the server sent its ServerHello message.
We found that even if TLS session resumption is not enabled,
the time of the HTTP request cannot be reliably used by the
server-side application to calculate the freshness of the client’s
proof of possession. The assumption does not hold that the
TLS connection will timeout if the CertificateVerify
message is not provided soon enough after the ServerHello
message. OpenSSL itself does not enforce a timeout, but
Apache has a default timeout set to 300 seconds, conﬁgurable
by the TimeOut directive. However, this timeout counter will
be reset whenever new data is added to the read or write buffer.
By using TLS fragmentation and sending empty TLS message
fragments the TLS connection can be kept open for an unlim-
ited amount of time before sending a CertificateVerify
message.
After the DoS attack tool Slowloris [17] was released (the
tool tries to open many connections to the target server and
keep them open as long as possible),
the Apache HTTP
server starting from version 2.2.15 includes the module
mod_reqtimeout [18] that
imposes restrictions on the
minimum transfer speed and the time a client is allowed to stay
connected. Debian GNU/Linux and most software distribu-
tions based on Debian ship Apache with mod_reqtimeout
enabled by default. The default conﬁguration will force the
connection to be terminated if the client’s HTTP request header
is not received within 40 seconds. However, the total time for
receiving an HTTP request body is not enforced as long as
the ﬁrst byte of the request body is received in the ﬁrst 10
seconds and then the minimum data transfer rate of 500 bytes
per second is maintained [19]. Since the TLS renegotiation
process is part of the request body receiving process [18], the
renegotiation handshake can be kept open for an unlimited
amount of time as long as the data rate of 500 bytes per
second is maintained. In practice, one TLS record containing
an AES encrypted empty handshake message that is padded
to the maximum allowed length will have a size of 277 bytes;
therefore two such TLS records must be sent in a second to
maintain the required data rate of 500 bytes per second.
As a result, many servers requiring TLS CCA might not
put a time constraint on an attacker for obtaining a signature
once the data to be signed is known. This can be exploited, for
example, in the Estonian ID card case if the victim provides a
padding oracle to the attacker. Since forging a signature using
a padding oracle attack requires thousands of oracle calls to the
ID card, the attacker can obtain forged signature only several
hours after the data to be signed is known [20]. We see that
this limitation might not be a problem, and therefore a padding
oracle attack can be practically exploited to perform CCA on
behalf of the victim if the attacker has access to such an oracle.
Even if a server-side application could obtain the time the
client performed CCA, we face another problem. Server-side
scripting engines do not provide function calls that could
be used to communicate to the underlying mod_ssl that a
particular TLS session should be cleared in order to request
client certiﬁcate re-authentication, and as will be discussed
further, browsers also do not provide API, which could be
used to force a TLS session deletion from the client side.
6
G. Certiﬁcate Revocation Checking
At mod_ssl level client certiﬁcate revocation checking
can be performed using a certiﬁcate revocation list (CRL).
The SSLCARevocationFile directive speciﬁes a location
where CRLs used for certiﬁcate chain revocation checking
are located. Only direct CRLs are supported and only these
certiﬁcates will be checked for which CRLs are provided.
When CRL ﬁles are updated, the Apache process must be
gracefully restarted (using signal USR1) in order to reload
CRLs. The TLS CCA handshake will fail if an outdated CRL is
speciﬁed i.e., if nextUpdate is in the past. However, there
is no check of whether thisUpdate is not in the future,
and therefore outdated CRLs used by servers with a backward
system time will not be detected.
In mod_ssl version 2.4, the revocation checks can also be
performed using the Online Certiﬁcate Status Protocol (OCSP).
H. CCA Audit Trail
HTML form-based password authentication provides a ﬂex-
ible way to record authentication success and failures at
application level. However, in the case of mod_ssl, the CCA
failure resulting from any reason will end with a TLS hand-
shake failure without reaching the application level. Therefore
CCA auditing must be done at the mod_ssl level.
In order to fully beneﬁt from the auditing process,
Unfortunately, the logging provided by mod_ssl is not
sufﬁcient. When using the LogLevel value error, only
general CCA success and failure messages are logged. When
LogLevel is set to value debug, which provides the maxi-
mum verbosity level, the subject DN of the certiﬁcate and the
packets received by OpenSSL are also dumped into the log
ﬁle; however, if the CCA is performed on renegotiation, the
packets of the handshake dumped are in an encrypted form.
the
full TLS CCA handshake should be logged in a decrypted
form. This would allow investigation of the precise reasons
for authentication failure, and in a case of successful CCA,
the handshake messages could be used by a server as proof
that the server was interacting with a client who possessed the
private key corresponding to the client’s certiﬁcate. The proof
would even give an indication about the time period, since
the randomness in the ClientHello and ServerHello
messages contains the timestamp of the client and server and
the server’s Certificate message contains the validity
period of the certiﬁcate.
I. CCA Support in Browsers
When a server requests the CCA, the browser has to ask
the user whether to perform CCA and which certiﬁcate should
be used for that. The client certiﬁcate selection windows as
implemented by browsers can be seen in Fig. 2. The Chrome
browser has a different selection window in Linux and Win-
dows, since in Linux it uses the NSS library to implement TLS
while on Windows it uses SChannel and Windows certiﬁcate
management facilities.
As can be seen, the client certiﬁcate selection windows
provide different levels of detail. Chrome uses the address
from the address bar to indicate the CCA requesting party,
while Firefox shows information from the server’s certiﬁcate.
Unfortunately, the IE in its client certiﬁcate selection window
does not even try to inform which party is requesting CCA.
(a) Firefox under Linux
(b) Chrome under Linux
(c) IE under Windows 7
(d) Chrome under Windows 7
Fig. 2: Client certiﬁcate selection windows
The list of certiﬁcates in the selection window is ﬁltered
according to the list of CA DNs provided in the server’s
CertificateRequest message. If a server sends an empty
list of DNs, the browser offers to select any client certiﬁcate
that
the user has. Certiﬁcates whose purpose speciﬁed in
the certiﬁcate extensions is not consistent with CCA are not
listed in the certiﬁcate selection window. In addition, IE and
Chrome will not list client certiﬁcates that are not yet valid or
have expired. If the user has no suitable client certiﬁcates for
authentication the certiﬁcate selection window is not shown
and an empty client Certificate handshake message is
sent.
The Firefox certiﬁcate selection window has an additional
option “Remember this decision” which is enabled by de-
fault. In practice, browsing with this option disabled would
signiﬁcantly degrade the user experience, since the user would
be asked to select the certiﬁcate again whenever a new TLS
session was established with the server. IE and Chrome do
not even support disabling this option and automatically cache
certiﬁcate choice for a particular server until
the browser
has been restarted or the user has manually cleared the TLS
cache [21] (in Firefox: “Tools” – “Clear Recent History” –
“Active Logins”, in IE: “Tools” – “Internet Options” – “Con-
tent” – “Clear SSL state”, in Chrome not implemented [22]).
However, the caching of the client certiﬁcate choice creates
another usability and security issue. If the user has selected
the wrong certiﬁcate and wants to authenticate with a different
one or wants to prevent the browser from performing further
CCA with the server (e.g., after logout), the user has to restart
the browser or manually clear the TLS cache, disturbing all
connections in the current browsing session.
7
Firefox
exposes
a
JavaScript
non-standard
function
window.crypto.logout() [23] which clears the TLS
session cache and certiﬁcate choice for the server in whose
browser security domain the function is called. This function
can be used by server-side applications to provide true logout
functionality and the possibility for the user to re-authenticate
with a different client certiﬁcate.
Unfortunately, similar
functionality is not provided by
Chrome [24]. However, Chrome clears the client certiﬁcate
choice if the TLS CCA handshake is not successful, thereby
preventing deadlock if the user has chosen the wrong client