230 other packages in 2018, a number that has been growing
since the creation of npm. The graph at the bottom shows the
package reach of the top-5 packages (top in terms of their
package reach, as of 2018). In 2018, these packages each
reach between 134,774 and 166,086 other packages, making
them an extremely attractive target for attackers.
To better understand how the reach of packages evolves
over time, Figure 5 shows the distribution of reached pack-
ages for multiple years. For example, the red line shows that
in 2018, about 24,500 packages have reached at least 10 other
packages, whereas only about 9,500 packages were so in-
ﬂuential in 2015. Overall, the ﬁgure shows that more and
more packages are reaching a signiﬁcant number of other
packages, increasing the attractiveness of attacks that rely on
dependencies.
Some highly popular packages reach more than 100,000
other packages, making them a prime target for attacks.
This problem has been aggravating over the past few
years.
The high reach of a package ampliﬁes the effect of both
vulnerabilities (TM-leg) and of malicious code (TM-mal).
As an example for the latter, consider the event-stream inci-
dent discussed when introducing TM-acc in Section 2.2. By
Figure 3: Evolution of direct package dependencies and its
impact on transitive dependencies. Note the logarithmic scale
on the y-axis.
number of maintainers responsible for these packages. Both
numbers have been increasing super-linearly over the past
eight years. At the end of our measurement range, there is
a total of 676,539 packages, a number likely to exceed one
million in the near future. These packages are taken care of
by a total of 199,327 maintainers. The ratio of packages to
maintainers is stable across our observation period (ranging
between 2.81 and 3.51).
In many ways, this growth is good news for the JavaScript
community, as it increases the code available for reuse. How-
ever, the availability of many packages may also cause devel-
opers to depend on more and more third-party code, which
increases the attack surface for TM-pkg by giving individual
packages the ability to impact the security of many other pack-
ages. The following analyzes how the direct and transitive de-
pendencies of packages are evolving over time (Section 4.1.1)
and how many other packages individual packages reach via
dependencies (Section 4.1.2).
4.1.1 Direct and Transitive Dependencies
Figure 3 shows how many other packages an average npm
package depends on directly and transitively. The number
of direct dependencies has been increasing slightly from 1.3
in 2011 to 2.8 in 2018, which is perhaps unsurprising given
the availability of an increasing code base to reuse. The less
obvious observation is that a small, linear increase in direct
dependencies leads to a signiﬁcant, super-linear increase in
transitive dependencies. As shown by the upper line in Fig-
ure 3, the number of transitive dependencies of an average
package has increased to a staggering 80 in 2018 (note the
logarithmic scale).
From a security perspective, it is important to note that each
directly or transitively depended on package becomes part of
the implicitly trusted code base. When installing a package,
1000    28th USENIX Security Symposium
USENIX Association
computing event-stream’s reach and comparing it with other
packages, we see that this package is just one of many possible
targets. As of April 1, 2018 (the end of our measurement pe-
riod), event-stream has a reach of 5,466. That is, the targeted
package is relatively popular, but still far from being the top-
most attractive package to compromise. In fact, 1,165 other
packages have a greater or equal reach than event-stream.
Variants of the event-stream attack could easily be re-
peated with other packages.
In order to perform a similar analysis for the eslint-scope
security incident, we need to use a slightly modiﬁed version
of package reach. This attack targeted a development tool,
namely eslint, hence, to fully estimate the attack surface we
need to consider dev dependencies in our deﬁnition of reach.
We do not normally consider this type of dependencies in our
measurements because they are not automatically installed
with a package, unlike regular dependencies. They are instead
used only by the developers of the packages. Therefore the
modiﬁed version of package reach considers both transitive
regular dependencies and direct dev dependencies.
We observe that eslint-scope has a modiﬁed reach of more
than 100,000 packages at the last observation point in the data
set. However, there are 347 other packages that have a higher
reach, showing that even more serious attacks may occur in
the future.
The attack on eslint-scope has targeted a package with
an inﬂuence not larger than that of hundreds of other
packages. It is likely that similar, or perhaps even worse,
attacks will happen and succeed in the future.
4.2 Analysis of Maintainers
We remind the reader that there is a signiﬁcant difference
between npm maintainers and repository contributors, as dis-
cussed in Section 2.1. Even though contributors also have a
lot of control over the code that will eventually end up in an
npm package, they can not release a new version on npm, only
the maintainers have this capability. Hence, the discussion
that follows, about the security risks associated with maintain-
ers, should be considered a lower bound for the overall attack
surface.
Attacks corresponding to TM-acc in which maintainers are
targeted are not purely hypothetical as the infamous eslint-
scope incident discussed earlier shows. In this attack, a mali-
cious actor hijacked the account of an inﬂuential maintainer
and then published a version of eslint-scope containing ma-
licious code. This incident is a warning for how vulnerable
the ecosystem is to targeted attacks and how maintainers in-
ﬂuence can be used to deploy malware at scale. We further
discuss the relation between packages and maintainers.
Figure 4: Evolution of package reach for an average package
(top) and the top-5 packages (bottom).
Figure 5: Distribution of package reach by individual pack-
ages, and how it changes over time. Note the log scale on the
vertical axis.
USENIX Association
28th USENIX Security Symposium    1001
Figure 6: Evolution of maintainers sorted by package count
per year.
Figure 7: Evolution of package count for six popular main-
tainers.
4.2.1 Packages per Maintainer
Even though the ecosystem grows super-linearly as discussed
in Section 4.1, one would expect that this is caused mainly by
new developers joining the ecosystem. However, we observe
that the number of packages per maintainer also grows sug-
gesting that the current members of the platform are actively
publishing new packages. The average number of packages
controlled by a maintainer raises from 2.5 in 2012 to 3.5 in
2013 and almost 4.5 in 2018. Conversely, there are on aver-
age 1.35 maintainers in the lifetime of a package. The top
5,000 most popular packages have an average number of 2.83
maintainers. This is not unexpected, since multiple people are
involved in developing the most popular packages, while for
the majority of new packages there is only one developer.
Next, we study in more detail the evolution of the number
of packages a maintainer controls. Figure 6 shows the main-
tainer package count plotted versus the number of maintainers
having such a package count. Every line represents a year.
The scale is logarithmic to base 10. It shows that the majority
of maintainers maintain few packages, yet some maintain-
ers maintain over 100 packages. Over the years, the package
count for the maintainers increased consistently. In 2015, only
slightly more than 25,000 maintainers maintained more than
one package, whereas this number has more than tripled by
2018.
We further analyze ﬁve different maintainers in top 20
according to number of packages and plot the evolution of
their package count over the years in Figure 7. types is the
largest maintainer of type deﬁnitions for TypeScript, most
likely a username shared by multiple developers at Microsoft,
ehsalazar maintains many security placeholder packages, jon-
schlinkert and sindresorhus are maintaining many micropack-
ages and isaacs is the npm founder. From Figure 7 we can
see that for two of these maintainers the increase is super-
linear or even near exponential: types and kylemathews have
sudden spikes where they added many packages in a short
time. We explain this by the tremendous increase in popular-
ity for TypeScript in the recent years and by the community
effort to prevent typosquatting attacks by reserving multiple
placeholder. The graph of the other maintainers is more linear,
but surprisingly it shows a continuous growth for all the six
maintainers.
The number of packages that both the inﬂuential and
the average maintainers control increased continuously
over the years.
4.2.2
Implicitly Trusted Maintainers
One may argue that the fact that maintainers publish new
packages is a sign of a healthy ecosystem and that it only
mimics its overall growth. However, we show that while that
may be true, we also see an increase in the general inﬂuence
of maintainers. That is, on average every package tends to
transitively rely on more and more maintainers over time.
In Figure 8 we show the evolution of IT Mt, the average
number of implicitly trusted maintainers. As can be seen,
IT Mt almost doubled in the last three years for the average
npm package, despite the plateau of the curve reached in 2016
which we again speculate it is caused by the left-pad incident.
This is a worrisome development since compromising any
of the maintainer accounts a package trusts may seriously
impact the security of that package, as discussed in TM-acc.
The positive aspect of the data in Figure 8 is that the growth
in the number of implicitly trusted maintainers seems to be
less steep for the top 10,000 packages compared to the whole
ecosystem. We hypothesize that the developers of popular
packages are aware of this problem and actively try to limit
the IT Mt. However, a value over 20 for the average popular
package is still high enough to be problematic.
1002    28th USENIX Security Symposium
USENIX Association
Figure 8: Evolution of average number of implicitly trusted
maintainers over years in all packages and in the most popular
ones.
Figure 9: Number of implicitly trusted maintainers for top
10,000 most popular packages.
The average npm package transitively relies on code
published by 40 maintainers. Popular packages rely on
only 20.
When breaking the average IT Mt discussed earlier into in-
dividual points in Figure 9, one can observe that the majority
of these packages can be inﬂuenced by more than one main-
tainer. This is surprising since most of the popular packages
are micropackages such as "inherits" or "left-pad" or libraries
with no dependencies like "moment" or "lodash". However,
only around 30% of these top packages have a maintainer cost
higher than 10. Out of these, though, there are 643 packages
inﬂuenced by more than a hundred maintainers.
More than 600 highly popular npm packages rely on
code published by at least 100 maintainers.
Figure 10: Distribution of maintainers reach in different years.
4.2.3 Maintainers Reach
In Figure 10, we plot the reach MRt of the maintainers in the
npm ecosystem. The reach has increased over the years at all
levels. For example, in 2015 there were 2,152 maintainers
that could affect more than 10 packages, and this number
increased to 4,041 in 2016, 6,680 in 2017 and ﬁnally reaching
an astonishingly high 10,534 in 2018. At the other end of
the distribution, there were 59 maintainers that could affect
more than 10,000 packages in 2015, 163 in 2016, 249 in
2017 and ﬁnally 391 in 2018. The speed of growth for MRt
is worrisome, showing that more and more developers have
control over thousands of packages. If an attacker manages
to compromise the account of any of the 391 most inﬂuential
maintainers, the community will experience a serious security
incident, reaching twice as many packages as in the event-
stream attack.
391 highly inﬂuential maintainers affect more than
10,000 packages, making them prime targets for attacks.
The problem has been aggravating over the past years.
Finally, we look at the scenario in which multiple popular
maintainers collude, according to the desirable collusion strat-
egy introduced in Section 3.2, to perform a large-scale attack
on the ecosystem, i.e., TM-col. In Figure 11 we show that
20 maintainers can reach more than half of the ecosystem.
Past that point every new maintainer joining does not increase
signiﬁcantly the attack’s performance.
4.3 Security Advisories Evolution
Next, we study how often vulnerabilities are reported and
ﬁxed in the npm ecosystem (TM-leg). Figure 13 shows
the number of reported vulnerabilities in the lifetime of the
ecosystem. The curve seems to resemble the evolution of
number of packages presented in Figure 2, with a steep in-
crease in the last two years. To explore this relation further
we plot in Figure 14 the evolution of the number of advisories
USENIX Association
28th USENIX Security Symposium    1003
Figure 11: Combined reach of 100 inﬂuential maintainers.
Figure 12: Total reach of packages for which there is at least
one unpatched advisory (vulnerability reach VRt).
Figure 13: Evolution of the total and unpatched number of
advisories.
Figure 14: Evolution of VRRt, the rate of published vulnera-
bilities per 10,000 packages.
reported per 10,000 packages and we observe that it grows
from two in 2013 to almost eight in 2018. This is a sign of a
healthy security community that reports vulnerabilities at a
very good pace, keeping up with the growth of the ecosystem.
When analyzing the type of reported vulnerabilities in de-
tails, we observe that almost half of the advisories come from
two large-scale campaigns and not a broader community ef-
fort: First, there are 141 advisories published in January 2017
involving npm packages that download resources over HTTP,
instead of HTTPs. Second, there are 120 directory traver-
sal vulnerabilities reported as part of the research efforts of
Liang Gong [16]. Nevertheless, this shows the feasibility of
large-scale vulnerability detection and reporting on npm.
Publishing an advisory helps raise awareness of a security
problem in an npm package, but in order to keep the users