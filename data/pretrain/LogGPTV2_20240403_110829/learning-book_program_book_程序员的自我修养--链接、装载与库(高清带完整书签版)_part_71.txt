12.1.3系统调用的端
系统调用完成了应用程序和内核交流的工作，因此理论上只需要系统调用就可以完成一
些程序，但是：
理论上，理论总是成立的。
事实上，包括Linux，大部分操作系统的系统调用都有两个特点：
·使用不使。操作系统提供的系统调用接口往往过于原始，程序员须要了解很多与操作
系统相关的组节，如果没有进行很好的包袋，使用起来不方使。
·各个操作系统之间系统调用不兼容。首先Windows系统和Linux系统之间的系统调用
就基本上完全不同，虽然它们的内容很多都一样，但是定义和实现大不一样。即使是
同系列的操作系统的系统调用都不一样，比如Linux和UNIX就不相同。
为了解决这个问题，第1章中的“万能法则”又可以发挥它的作用了。“解决计算机的
问题可以通过增加层来实现”，于是运行库挺身面出，它作为系统调用与程序之间的一个抽
象层可以保持着这样的特点：
·使用简便。因为运行库本身就是语言级别的，它一般都设计相对比较友好。
·形式统一。运行库有它的标准，叫做标准库，凡是所有遵循这个标准的运行库理论上
都是相互兼容的，不会随者操作系统或编详器的变化面变化。
程序员的自我修养一链接、装载与库
---
## Page 411
388
第12章系统调用与API
这样，当我们使用运行库提供的接口写程序时，就不会面临这些问题，至少是可以很大
程度上掩盖直接使用系统调用的整端。
例如C语言里的 fread，用于读取文件，在Windows 下这个函数的实现可能是调用
ReadFile这个APl，面如果在Linux下，则很可能调用了read这个系统调用。但不管在哪个
平台，我们都可以使用C语言运行库的fread来读文件。
运行时库将不同的操作系统的系统调用包装为统一固定的接口，使得同样的代码，在不
同的操作系统下都可以直接编译，并产生一致的效果。这就是源代码级上的可移植性。
但是运行库也有运行库的缺陷，比如C语言的运行库为了保证多个平台之间能够相互
通用，于是它只能取各个平台之间功能的交集。比如 Windows 和Linux都支持文件读写，
那么运行库就可以有文件读写的功能；但是Windows原生支持图形和用户交互系统，而Linux
却不是原生支持的（通过XWindows），那么CRT就只能把这部分功能省去。因此，一且程
序用到了那些CRT之外的接口，程序就很难保持各个平台之间的兼容性了。
12.2系统调用原理
12.2.1特权级与中断
现代的CPU常常可以在多种截然不同的特权级别下执行指令，在现代操作系统中，通
常也据此有两种特权级别，分别为用户模式（UserMode）和内核模式（Kemel Mode），也
被称为用户态和内核态。由于有多种特权模式的存在，操作系统就可以让不同的代码运行在
不同的模式上，以限制它们的权力，提高稳定性和安全性。普通应用程序运行在用户惹的模
式下，请多操作将受到限制，这些操作包括访问硬件设备、开关中断、改变特权模式等。
般来说，运行在高特权级的代码将自已降至低特权级是允许的，但反过来低特权级的
代码将白己提升至高特权级则不是轻易就能进行的，否则特权级的作用就有名无实了。在将
低特权级的环境转为高特权级时，须要使用一种较为受控和安全的形式，以防止低特权模式
的代码破坏高特权模式代码的执行。
系统调用是运行在内核态的，而应用程序基本都是运行在用户态的。用户态的程序如何
运行内核态的代码呢？操作系统一股是通过中断（Interrupt）来从用户态切换到内核态。什
么是中断呢？中断是一个硬件或软件发出的请求，要求CPU暂停当前的工作转手去处理更
加重要的事情。举一个例子，当你在编辑文本文件的时候。键盘上的键不断地被按下，CPU
如何获知这一点的呢？一种方法称为轮询（Poll），即CPU每隔一小段时间（儿十到儿百毫
秒）去询问键盘是否有键被按下，但除非用户是疯狂打字员，否则大部分的轮询行为得到的
程序贝的自我修养一键接、装载与库
---
## Page 412
12.2系统调用原理
389
都是“没有键被按下”的回应，这样操作就被浪费掉了。另外一种方法是CPU不去理踩键
盘，面当键盘上有键被按下时，键盘上的芯片发送一个信号给CPU，CPU接收到信号之后
就知道键盘被按下了，然后再去询问键盘被按下的键是哪一个。这样的信号就是一种中断，
结果如图12-1所示。
陪我追街
图12-1现实中的中断
中断一般具有两个属性，一个称为中断号（从0开始），一个称为中断处理程序（Interrupt
ServiceRoutine，ISR）。不同的中断具有不同的中断号，而同时一个中断处理程序一一对应
个中断号。在内核中，有一个数组称为中断向量表（InterruptVectorTable），这个数组的
第n项包含了指向第n号中断的中断处理程序的指针.当中断到来时，CPU会暂停当前执
行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，井调用它。中断
处理程序执行完成之后，CPU会继续执行之前的代码。一个简单的示意图如图12-2所示。
User mode
uogdnueu
execution
occured
Next instruction
User Mode
Kernel Mode
Interrupt
Vedlor
Table
ruptHandle
图12-2CPU中断过程
通常意义上，中断有两种类型，一种称为硬件中断，这种中断来自于硬件的异常或其他
事件的发生，如电源掉电、键盘被按下等，另一种称为软件中断，软件中断通常是一条指令
（i386下是int），带有一个参数记录中断号，使用这条指令用户可以手动触发某个中断并执
行其中断处理程序。例如在i386下，int0x80这条指令会调用第0x80号中断的处理程序。
程序员的自我修养—链接、装载与库
---
## Page 413
390
第12章系统调用与API
由于中断号是很有限的，操作系统不会舍得用一个中断号来对应一个系统调用，面更倾
向于用一个或少数儿个中断号来对应所有的系统调用。例如，i386下Windows里绝大多数
系统调用都是由int0x2e来触发的，而Linux则使用int0x80来触发所有的系统调用。对于
同一个中断号，操作系统如何知道是哪一个系统调用要被调用呢？和中断一样，系统调用都
有一个系统调用号，就像身份标识一样来表明是哪一个系统调用，这个系统调用号通常就是
系统调用在系统调用表中的位置，例如Linux里fork的系统调用号是2.这个系统调用号在
执行int指令前会被放置在某个固定的寄存器里，对应的中断代码会取得这个系统调用号，
并且调用正确的函数。以Linux的int0x80为例，系统调用号是由cax来传入的。用户将系
统调用号放入eax，然后使用int0x80调用中断，中断服务程序就可以从eax里取得系统调
用号，进而调用对应的函数。
12.2.2基于int的Linux的经典系统调用实现
在本节里，我们将了解到当应用程序调用系统调用时，程序是如何一步步进入操作系统
内核调用相应函数的。图12-3是以fork为例的Linux系统调用的执行流程。
用户代码
ferkG)
户代码
用户市
内核态
中新内量
洗用
系用
图12-3Linux系统中断流程
接下来让我们一步一步地了解这个过程的细节。
1.触发中断
fork:
int main()
fork() ;
fork函数是一个对系统调用fork的封装，可以用下列宏来定义它：
程序员的自我修养一链接、装载与库
---
## Page 414
12.2累统调用原理
391
_syscal10 (pid_t, fork) ;
_syscall0是一个宏函数，用于定义一个没有参数的系统调用的封装，它的第一个参数为
这个系统调用的返回值类型，这里为pid_，是一个Linux自定义类型，代表进程的id._syscall0
的第二个参数是系统调用的名称，_syscallo展开之后会形成一个与系统调用名称同名的函
数。下面的代码是i386版本的syscall0定义：
define _8ysca110 (type, name)
(pTon) aueu ad
1ong__re8;
_asm volatile (*int $0x80*
((ourugN)O.
:*sa* (_res)
_8yscal1_return (type,_res) :
对于 syscallO(pid_t,fork），上面i的宏将展开为：
pid_t fork(void)
_asm_ volatile (*int $0x80*
long _res;
1 *=a* (_res)
：“O"（NR_fork))
_syscal1_return (pid_t,_res) ;
如果读者对这种AT&T格式的汇编不熟悉，请看下面的解释。
首先_asm_是一个gcc的关键字，表示接下来要嵌入汇编代码，volatile关键字告诉
GCC对这段代码不进行任何优化。
_asm_的第一个参数是一个字符串，代表汇编代码的文本，这里的汇编代码只有一句：
int $0x80，这就要调用0x80号中断。
“=a”（__res）表示用eax（a表示cax）输出返回数据并存储在_res里。
“0”（_NR_#name）表示_NR_#name为输入，“0”指示由编译器选择和输出相同
的寄存器（即eax）来传递参数。
更直观一点，可以把这段汇编改写为更为可读的格式：
main -> fork:
pid_t fork(void)
1ong _res1
int $0x80
$eax =
_NR_fozk
_syscall_return(pid_t,__res) ;
res = Seax
程序员的自我修养一链接、装载与库
---
## Page 415
392
第12章系统调用与API
_NR_fork是一个宏，表示fork系统调用的调用号，对于x86体系结构，该宏的定义可
以在 Linux/include/asm-x86/unistd_32.h 里找到：
#define _NR_restart_syscal1
#define
0
#define NR_fork
_NR_exit
1
define
_NR_read
2
define _NR_write
3
4
• .....
而_syscall_retum 是另一个宏，定义如下：
#define _syscal1_return(type, res)
1op
1f ({un8igned 1ong) (re8)>= (unsigned 1ong) (-125))(
res ± -1;
errno = -(res)1
(0)q(
return (type)(res);
这个宏用于检查系统调用的返回值，并把它相应地转换为C语言的ermo错误码。在
Linux里，系统调用使用返回值传递错误码，如果返回值为负数，那么表明调用失败，返回
值的绝对值就是错误码。而在C语言里则不然，C语言里的大多数函数都以返回-1表示调
用失败，面将出错信息存储在一个名为ermmo的全局变量（在多线程库中，emmo存储于TLS
中）里。_syscall_returm 就负责将系统调用的返回信息存储在ermmo中。这样，fork函数在
汇编之后，就会形成类似如下的汇编代码：
fork:
nov eax, 2
cmp eax, 0xFFFFFF83
int 0x80
neg eax
{b sy8ca11_noerror
mov errno, eax
nov eax, OxFFFFFFFF
syscall_noerror:
ret
如果系统调用本身有参数要如何实现呢？下面是x86Linux下的 syscall1，用于带1个
参数的系统调用：
#define _sysca112 (type, name, type1, arg1)
type nane (typel arg1)
_asm_ volatile (*int $0x80*
long _res;
:*=a* (_res)
:*0*(NR_##name),“b"((long)(arg1))）:
_syscall_return (type,_res1 :
程序员的自我修养一—链接、装载与库
---
## Page 416
12.2系统调用原理
393
这段代码和_syscallo 不同的是，它多了一个b"（(long（argi).这一句的意思是先把arg1
强制转换为long，然后存放在EBX（b代表EBX）里作为输入。编译器还会生成相应的代
码来保护原来的EBX的值不被破坏。这段汇编可以改写为：
eax * NR_##name
push ebx
[6.1e = xqa
int 0x80
pop ebx
_res = eax
可见，如果系统调用有1个参数，那么参数通过EBX来传入，x86下Linux支持的系
统调用参数至多有6个，分别使用6个寄存器来传递，它们分别是EBX、ECX、EDX、ESI、
EDI 和 EBP.
当用户调用某个系统调用的时候，实际是执行了以上一段汇编代码。CPU执行到int
$0x80时，会保存现场以便恢复，接若会将特权状态切换到内核态。然后CPU便会查找中
断向量表中的第0x80号元素，
以上是Linux实现系统调用入口的思路，不过也许你会想知道glibc是否真的是如此封
装系统调用的？答案是否定的，glibe使用了另外一套调用系统调用的方法，尽管原理上仍
然是使用0x80号中断，但细节上却是不一样的。由于这种方法与我们前面介绍的方法本质
上是一样的，所以在这里就不介绍了。
2.切换堆栈
在实际执行中断向量表中的第0x80号元素所对应的函数之前，CPU首先还要进行栈的
切换。在Linux中，用户态和内核态使用的是不同的栈，两者各自负责各自的函数调用，互
不干扰。但在应用程序调用0x80号中断时，程序的执行流程从用户态切换到内核态，这时
程序的当前栈必须也相应地从用户栈切换到内核栈。从中断处理函数中返回时，程序的当前
栈还要从内核栈切换回用户栈。