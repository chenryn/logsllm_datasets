title:Kernel Malware Analysis with Un-tampered and Temporal Views of Dynamic
Kernel Memory
author:Junghwan Rhee and
Ryan Riley and
Dongyan Xu and
Xuxian Jiang
Kernel Malware Analysis with Un-tampered and
Temporal Views of Dynamic Kernel Memory
Junghwan Rhee1, Ryan Riley2, Dongyan Xu1, and Xuxian Jiang3
1 Purdue University
{rhee,dxu}@cs.purdue.edu
2 Qatar University
PI:EMAIL
3 North Carolina State University
PI:EMAIL
Abstract. Dynamic kernel memory has been a popular target of recent kernel
malware due to the difﬁculty of determining the status of volatile dynamic ker-
nel objects. Some existing approaches use kernel memory mapping to identify
dynamic kernel objects and check kernel integrity. The snapshot-based memory
maps generated by these approaches are based on the kernel memory which may
have been manipulated by kernel malware. In addition, because the snapshot only
reﬂects the memory status at a single time instance, its usage is limited in tempo-
ral kernel execution analysis. We introduce a new runtime kernel memory map-
ping scheme called allocation-driven mapping, which systematically identiﬁes
dynamic kernel objects, including their types and lifetimes. The scheme works by
capturing kernel object allocation and deallocation events. Our system provides a
number of unique beneﬁts to kernel malware analysis: (1) an un-tampered view
wherein the mapping of kernel data is unaffected by the manipulation of kernel
memory and (2) a temporal view of kernel objects to be used in temporal analysis
of kernel execution. We demonstrate the effectiveness of allocation-driven map-
ping in two usage scenarios. First, we build a hidden kernel object detector that
uses an un-tampered view to detect the data hiding attacks of 10 kernel rootkits
that directly manipulate kernel objects (DKOM). Second, we develop a temporal
malware behavior monitor that tracks and visualizes malware behavior triggered
by the manipulation of dynamic kernel objects. Allocation-driven mapping en-
ables a reliable analysis of such behavior by guiding the inspection only to the
events relevant to the attack.
Keywords: Kernel memory mapping, kernel malware analysis, virtualization.
1 Introduction
Dynamic kernel memory is where the majority of kernel data resides. Operating system
(OS) kernels frequently allocate and deallocate numerous dynamic objects of various
types. Due to the complexity of identifying such objects at runtime, dynamic kernel
memory is a source of many kernel security and reliability problems. For instance, an
S. Jha, R. Sommer, and C. Kreibich (Eds.): RAID 2010, LNCS 6307, pp. 178–197, 2010.
c(cid:2) Springer-Verlag Berlin Heidelberg 2010
Kernel Malware Analysis with Un-tampered and Temporal Views
179
increasing amount of kernel malware targets dynamic kernel objects [4,10,18,23]; and
many kernel bugs are caused by dynamic memory errors [13,27,28].
Advanced kernel malware uses stealthy techniques such as directly manipulating
kernel data (i.e., DKOM [4]) or overwriting function pointers (i.e., KOH [10]) located
in dynamic kernel memory. This allows attacks such as process hiding and kernel-level
control ﬂow hijacking. These anomalous kernel behaviors are difﬁcult to analyze be-
cause they involve manipulating kernel objects that are dynamically allocated and deal-
located at runtime; unlike persistent kernel code or static kernel data that are easier to
locate, monitor, and protect.
To detect these attacks, some existing approaches use kernel memory mapping based
on the contents of runtime memory snapshots [1,5,16] or memory access traces [23,31].
These approaches commonly identify a kernel object by projecting the type and address
of a pointer onto the memory. However, such a technique may not always be accurate
– for example, when an object is type cast to a generic type or when an embedded list
structure is used as part of larger data types. In benign kernel execution, such inaccu-
racy can be corrected [5]; but it becomes a problem in malware analysis as the memory
contents may have been manipulated by kernel malware. For example, a DKOM attack
to hide a process may modify the next task and prev task pointers in the process
list. This causes the process to disappear from the OS view as well as from the kernel
memory map. To detect this attack, some existing approaches rely on data invariants
such as that the list used for process scheduling should match the process list. However,
not every data structure has an invariant. Additionally, the kernel memory map gener-
ated from a snapshot [1,5,16] reﬂects kernel memory status at a speciﬁc time instance.
Therefore, the map is of limited usage in analyzing the kernel execution. Some mapping
approaches are based on logging malware memory accesses [23,31] and thus provide
temporal information. However they only cover objects accessed by the malware code
and cannot properly handle certain attack patterns due to assumptions in its mapping
algorithm [21].
In this paper, we present a new kernel memory mapping scheme called allocation-
driven mapping that complements the existing approaches. Our scheme identiﬁes dy-
namic kernel objects by capturing their allocations and does not rely on the runtime
content of kernel memory to construct the kernel object map. As such, the map is re-
sistant to attacks that manipulate the kernel memory. On top of our scheme, we build
a hidden kernel object detector that uses the un-tampered view of kernel memory to
detect DKOM data hiding attacks without requiring kernel object-speciﬁc invariants.
In addition, our scheme keeps track of each kernel object’s life time. This temporal
property is useful in the analysis of kernel/kernel malware execution. We also build a
temporal malware behavior monitor that systematically analyzes the impact of kernel
malware attacks via dynamic kernel memory using a kernel execution trace. We ad-
dress a challenge in the use of kernel memory mapping for temporal analysis of kernel
execution: A dynamic memory address may correspond to different kernel objects at
different times because of the runtime allocation and deallocation events. This problem
can be handled by allocation-driven mapping. The lifetime of a dynamic kernel object
naturally narrows the scope of a kernel malware analysis.
180
J. Rhee et al.
(a) Type-projection mapping
(b) Allocation-driven mapping
Fig. 1. Illustration of kernel memory mapping approaches. a1 and a2 represent kernel memory
addresses. X and Y are data types for kernel objects.
The contributions of this paper are summarized as follows:
– We present a new kernel memory mapping scheme called allocation-driven map-
ping that has the following properties desirable for kernel malware analysis: un-
tampered identiﬁcation of kernel objects and temporal status of kernel objects.
– We implement allocation-driven mapping at the virtual machine monitor (VMM)
level. The identiﬁcation and tracking of kernel objects take place in the VMM with-
out modiﬁcation to the guest OS.
– We develop a hidden kernel object detector that can detect DKOM data hiding at-
tacks without requiring data invariants. The detector works by comparing the status
of the un-tampered kernel map with that of kernel memory.
– We develop a malware behavior monitor that uses a temporal view of kernel objects
in the analysis of kernel execution traces. The lifetimes of dynamic kernel objects
in the view guide the analysis to the events triggered by the objects manipulated by
the malware.
We have implemented a prototype of allocation-driven mapping called LiveDM (Live
Dynamic kernel memory Map). It supports three off-the-shelf Linux distributions.
LiveDM is designed for use in non-production scenarios such as honeypot monitoring,
kernel malware proﬁling, and kernel debugging.
2 Background – Kernel Memory Mapping
There have been several approaches [1,5,16,23,31] that leverage kernel memory map-
ping to test the integrity of OS kernels and thereby detect kernel malware. These ap-
proaches (similar to garbage collection [3,19]) commonly identify kernel objects by
recursively traversing pointers in the kernel memory starting from static objects. A ker-
nel object is identiﬁed by projecting the address and type of a traversed pointer onto
memory; thus, we call this mechanism type-projection mapping. For example, in Fig.
1(a) the mapping process starts by evaluating the pointer ﬁelds of the static data object.
When the second ﬁeld of this object is traversed, the type X of the pointer is projected
onto the memory located in the obtained address a1, identifying an instance of type X.
Kernel Malware Analysis with Un-tampered and Temporal Views
181
The underlying hypothesis of this mapping is that the traversed pointer’s type accu-
rately reﬂects the type of the projected object. In practice there are several cases when
this may not be true. First, if an object allocated using a speciﬁc type is later cast to a
generic type, then this mapping scheme cannot properly identify the object using that
pointer. For instance, in Fig. 1(a) the third ﬁeld of the static object cannot be used to
identify the Y instance due to its generic void* type. Second, in modern OSes many
kernel objects are linked using embedded list structures which connect the objects us-
ing list types. When these pointers are traversed, the connected objects are inaccurately
identiﬁed as list objects. KOP [5] addresses these problems by generating an extended
type graph using static analysis. Some other approaches rely on manual annotations.
When type-projection mapping is used against kernel malware, these problems may
pose concerns as such inaccuracy can be deliberately introduced by kernel malware. In
type-projection mapping, the kernel memory map is based on the content of the kernel
memory, which may have been manipulated by the kernel malware. This property may
affect the detection of kernel rootkits that hide kernel objects by directly manipulating
pointers. To detect such attacks, a detector needs to rely on not only the kernel mem-
ory map but also additional knowledge that reveals the anomalous status of the hidden
objects. For this purpose, several approaches [1,5,18] use data structure invariants. For
example, KOP [5] detects a process hidden by the FU Rootkit [4] by using the invari-
ant that there are two linked lists regarding process information which are supposed to
match, and one of them is not manipulated by the attack. However, a data invariant is
speciﬁc to semantic usage of a data structure and may not be applicable to other data
structures. For type-projection mapping, it is challenging to detect data hiding attacks
that manipulate a simple list structure (such as the kernel module list in Linux) without
an accompanying invariant.
In general, we can categorize these approaches into two categories based on whether
they make use of a static snapshot or dynamic runtime memory access trace.
2.1 Static Type-Projection Mapping
This approach uses a memory snapshot to generate a kernel memory map. SBCFI [16]
constructs a map to systematically detect the violation of persistent control ﬂow in-
tegrity. Gibraltar [1] extracts data invariants from kernel memory maps to detect kernel
rootkits. A signiﬁcant advantage of this approach is the low cost to generate a memory
snapshot. A memory snapshot can be generated using an external monitor such as a
PCI interface [1], a memory dump utility [5], or a VMM [16], and the map is generated
from the snapshot later.
The memory snapshot is generated at a speciﬁc time instance (asynchronously);
therefore, its usage is limited for analyzing kernel execution traces where dynamic ker-
nel memory status varies over time. The same memory address, for example, could store
different dynamic kernel objects over a period of time (through a series of deallocations
and reallocations). The map cannot be used to properly determine what data was stored
at that address at a speciﬁc time. We call this a dynamic data identity problem, and it
occurs when an asynchronous kernel memory map is used for inspection of dynamic
memory status along the kernel execution traces.
182
J. Rhee et al.
2.2 Dynamic Type-Projection Mapping
This mapping approach also uses the type-projection mechanism to identify kernel ob-
jects, but its input is the trace of memory accesses recorded over runtime execution
instead of a snapshot. By tracking the memory accesses of malware code, this approach
can identify the list of kernel objects manipulated by the malware. PoKeR [23] and
Rkproﬁler [31] use this approach to proﬁle dynamic attack behavior of kernel rootkits
in Linux and Windows respectively.
Since a runtime trace is used for input, this approach can overcome the asynchronous
nature of static type-projection mapping. Unfortunately, current work only focuses on
the data structures accessed by malware code, and may not capture other events. For
example, many malware programs call kernel functions during the attack or exploit
various kernel bugs, and these behaviors may appear to be part of legitimate kernel exe-
cution. In these cases, this dynamic type-projection techniques need to track all memory
accesses to accurately identify the kernel objects accessed by legitimate kernel execu-
tion. Since this process is costly (though certainly possible), it is not straightforward for
this approach to expand the coverage of the mapped data to all kernel objects.
3 Design of LiveDM
In this section, we ﬁrst introduce the allocation-driven mapping scheme, based on which
our LiveDM system is implemented. We then present key enabling techniques to im-
plement LiveDM.
3.1 Allocation-Driven Mapping Scheme
Allocation-driven mapping is a kernel memory mapping scheme that generates a ker-
nel object map by capturing the kernel object allocation and deallocation events of
the monitored OS kernel. LiveDM uses a VMM in order to track the execution of the
running kernel. Whenever a kernel object is allocated or deallocated, LiveDM will in-
tercede and capture its address range and the information to derive the data type of
the object subject to the event (details in Section 3.2) in order to update the kernel
object map. We ﬁrst present the beneﬁts of allocation-driven mapping over existing ap-
proaches. After that we will present the techniques used to implement this mapping
scheme.
First, this approach does not rely on any content of the kernel memory which can
potentially be manipulated by kernel malware. Therefore, the kernel object map pro-
vides an un-tampered view of kernel memory wherein the identiﬁcation of kernel data
is not affected by the manipulation of memory contents by kernel malware. This tamper-
resistant property is especially effective to detect sophisticated kernel attacks that
directly manipulate kernel memory to hide kernel objects. For instance, in the type-
projection mapping example (Fig. 1(a)) if the second pointer ﬁeld of the static object
is nulliﬁed, the X object cannot be identiﬁed because this object cannot be reached
by recursively scanning all pointers in the memory. In practice, there can be multiple
pointer references to a dynamic object. However, malware can completely isolate an
Kernel Malware Analysis with Un-tampered and Temporal Views
183
object to be hidden by tampering with all pointers pointing to the object. The address
of the hidden object can be safely stored in a non-pointer storage (e.g., int or char)
to avoid being discovered by the type-projection mapping algorithm while it can be
used to recover the object when necessary. Many malicious programs carefully control
their activities to avoid detection and prolong their stealthy operations, and it is a vi-
able option to suspend a data object in this way temporarily and activate it again when
needed [30].
In the allocation-driven mapping approach, however, this attack will not be effective.
As shown in Fig. 1(b), each dynamic object is recognized upon its allocation. There-
fore the identiﬁcation of dynamic objects is reliably obtained and protected against the
manipulation of memory contents. The key observation is that allocation-driven map-
ping captures the liveness status of the allocated dynamic kernel objects. For malware
writers, this property makes it signiﬁcantly more difﬁcult to manipulate this view. In
Section 6.1, we show how this mapping can be used to automatically detect DKOM
data hiding attacks without using any data invariant speciﬁc to a kernel data structure.
Second, LiveDM reﬂects a temporal status of dynamic kernel objects since it cap-
tures their allocation and deallocation events. This property enables the use of the kernel
object map in temporal malware analysis where temporal information, such as kernel
control ﬂow and dynamically changing data status, can be inspected to understand com-
plicated kernel malware behavior. In Section 2.1, we pointed out that a dynamic data
identity problem can occur when a snapshot-based kernel memory map is used for dy-
namic analysis. Allocation-driven mapping provides a solution to this problem by accu-
rately tracking all allocation and deallocation events. This means that even if an object
is deallocated and its memory reused for a different object, LiveDM will be able to
properly track it.
Third, allocation-driven mapping does not suffer from the casting problem that oc-
curs when an object is cast to a generic pointer because it does not evaluate pointers to
construct the kernel object map. For instance, in Fig. 1(b) the void pointer in the third
ﬁeld of the static data object does not hinder the identiﬁcation of the Y instance because
this object is determined by capturing its allocation. However, we note that another kind
of casting can pose a problem: If an object is allocated using a generic type and it is cast
to a speciﬁc type later, allocation-driven mapping will detect the earlier generic type.
However, our study in Section 5 shows that this behavior is unusual in Linux kernels.
There are a number of challenges in implementing the LiveDM system based on
allocation-driven mapping. For example, kernel memory allocation functions do not
provide a simple way to determine the type of the object being allocated.1 One solu-
tion is to use static analysis to rewrite the kernel code to deliver the allocation types to
the VMM, but this would require the construction of a new type-enabled kernel, which
is not readily applicable to off-the-shelf systems. Instead, we use a technique that de-
rives data types by using runtime context (i.e., call stack information). Speciﬁcally, this
technique systematically captures code positions for memory allocation calls by using
virtual machine techniques (Section 3.2) and translates them into data types so that OS
kernels can be transparently supported without any change in the source code.
1 Kernel level memory allocation functions are similar to user level ones. The function
kmalloc, for example, does not take a type but a size to allocate memory.
184
J. Rhee et al.
3.2 Techniques
We employ a number of techniques to implement allocation-driven mapping. At the
conceptual level, LiveDM works as follows. First, a set of kernel functions (such as
kmalloc) are designated as kernel memory allocation functions. If one of these func-
tions is called, we say that an allocation event has occurred. Next, whenever this event
occurs at runtime, the VMM intercedes and captures the allocated memory address
range and the code location calling the memory allocation function. This code location