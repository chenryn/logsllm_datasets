# 散列
---
- https://www.kancloud.cn/imxieke/ruby-base/107303
---
# 散列
通过索引可以获取数组元素或对其赋值。
```ruby
person = Array.new
person[0] = "田中一郎"
person[1] = "佐藤次郎"
person[2] = "木村三郎"
p person[1] #=> "佐藤次郎"
```
散列与数组一样，都是表示对象集合的对象。数组通过索引访问对象内的元素，而散列则是利用键。索引只能是数值，而键则可以是任意对象。通过使用键，散列就可以实现对元素的访问与赋值。
```ruby
person = Hash.new
person["tanaka"] = "田中一郎"
person["satou"] = "佐藤次郎"
person["kimura"] = "木村三郎"
p person["satou"] #=> "佐藤次郎"
```
在本例中，`tanaka`、`satou` 等字符串就是键，对应的值为 `"田中一郎 "`、`"佐藤次郎 "`。散列中 `[]` 的用法也与数组非常相似。
# 散列的创建
与数组一样，创建散列的方法也有很多。其中下面两种是最常用到的。
**使用 {}**
使用字面量直接创建散列。
```ruby
{ 键 => 值}
```
像下面那样指定键值对，键值对之间用逗号`（,）`隔开。
```ruby
h1 = {"a"=>"b", "c"=>"d"}
p h1["a"]    #=> "b"
```
另外，用符号作为键时，
```
{ 键: 值}
```
也可以采用上述定义方法。
```ruby
h2 = {a: "b", c: "d"}
p h2    #=> {:a=>"b", :c=>"d"}
```
**使用 Hash.new**
`Hash.new` 是用来创建新的散列的方法。若指定参数，则该参数值为散列的默认值，也就是指定不存在的键时所返回的值。没指定参数时，散列的默认值为 `nil`。
```ruby
h1 = Hash.new
h2 = Hash.new("")
p h1["not_key"]    #=> nil
p h2["not_key"]    #=> ""
```
散列的键可以使用各种对象，不过一般建议使用下面的对象作为散列的键。
- 字符串（String）
- 数值（Numeric）
- 符号（Symbol）
- 日期（Date）
# 值的获取与设定
与数组一样，散列也是用 `[]` 来实现与键相对应的元素值的获取与设定的。
```ruby
h = Hash.new
h["R"] = "Ruby"
p h["R"]    #=> "Ruby"
```
另外，我们还可以用 `store` 方法设定值，用 `fetch` 方法获取值。下面的例子的执行结果与上面的例子是一样的。
```ruby
h = Hash.new
h.store("R", "Ruby")
p h.fetch("R")    #=> "Ruby"
```
使用 `fetch` 方法时，有一点与 `[]` 不一样，就是如果散列中不存在指定的键，程序就会发生异常。
```ruby
h = Hash.new
p h.fetch("N")    #=> 错误（IndexError）
```
如果对 `fetch` 方法指定第 2 个参数，那么该参数值就会作为键不存在时散列的默认值。
```ruby
h = Hash.new
h.store("R", "Ruby")
p h.fetch("R", "(undef)")    #=> "Ruby"
p h.fetch("N", "(undef)")    #=> "(undef)"
```
此外，`fetch` 方法还可以使用块，此时块的执行结果为散列的默认值。
```ruby
h = Hash.new
p h.fetch("N"){ String.new }    #=> ""
```
**一次性获取所有的键、值**
我们可以一次性获取散列的键、值。由于散列是键值对形式的数据类型，因此获取键、值的方法是分开的。此外，我们还可以选择是逐个获取，还是以数组的形式一次性获取散列的所有键、值，不过这两种情况下使用的方法是不同的。
方法 | 数组形式	| 迭代器形式
- | - | -
获取键                  | keys	   | each_key{| 键 | ......}
获取值                  | values	   | each_value{| 值 | ......}
获取键值对[ 键, 值]	    |  to_a	   |  each{| 键 , 值 | ......}each{| 数组 | ......}
`keys` 与 `values` 方法各返回封装为数组后的散列的键与值。`to_`a 方法则会先按下面的形式把键值对封装为数组，[ 键, 值]
然后再将所有这些键值对数组封装为一个大数组返回。
```ruby
h = {"a"=>"b", "c"=>"d"}
p h.keys    #=> ["a", "c"]
p h.values  #=> ["b", "d"]
p h.to_a    #=> [["a", "b"], ["c", "d"]]
```
除了返回数组外，我们还可以使用迭代器获取散列值。
使用 `each_key` 方法与 `each_value` 方法可以逐个获取并处理键、值。使用 `each` 方法还可以得到 [ 键 , 值 ] 这样的键值对数组。
无论是使用 `each` 方法按顺序访问散列元素，还是使用 `to_a` 方法来获取全部的散列元素，这两种情况下都是可以按照散列键的设定顺序来获取元素的。
**散列的默认值**
下面我们来讨论一下散列的默认值（即指定散列中不存在的键时的返回值）。在获取散列值时，即使指定了不存在的键，程序也会返回某个值，而且不会因此而出错。我们有 3 种方法来指定这种情况下的返回值。
- 创建散列时指定默认值
    `Hash.new` 的参数值即为散列的默认值（什么都不指定时默认值为 nil）。
    ```ruby
    h = Hash.new(1)
    h["a"] = 10
    p h["a"]    #=> 10
    p h["x"]    #=> 1
    p h["y"]    #=> 1
    ```
    这个方法与初始化数组一样，所有的键都共享这个默认值。
- 通过块指定默认值
    当希望不同的键采用不同的默认值时，或者不希望所有的键共享一个默认值时，我们可以使用 `Hash.new` 方法的块指定散列的默认值。
    ```ruby
    h = Hash.new do |hash, key|
    hash[key] = key.upcase
    end
    h["a"] = "b"
    p h["a"]    #=> "b"
    p h["x"]    #=> "X"
    p h["y"]    #=> "Y"
    ```
    块变量 `hash` 与 `key`，分别表示将要创建的散列以及散列当前的键。用这样的方法创建散列后，就只能在需要散列默认值的时候才会执行块。此外，如果不对散列进行赋值，通过指定相同的键也可以执行块。
- 用 fetch 方法指定默认值
    最后就是刚才已经介绍过的 `fetch` 方法。当 `Hash.new` 方法指定了默认值或块时，`fetch` 方法的第 2 个参数指定的默认值的优先级是最高的。
    ```ruby
    h = Hash.new do |hash, key|
    hash[key] = key.upcase
    end
    p h.fetch("x", "(undef)")    #=> "(undef)"
    ```
# 查看指定对象是否为散列的键或值
- `h.key?(key)`
- `h.has_key?(key)`
- `h.include?(key)`
- `h.member?(key)`
    上面 4 个方法都是查看指定对象是否为散列的键的方法，它们的用法和效果都是一样的。大家可以统一只用某一个，也可以根据不同的情况选择使用。
    散列的键中包含指定对象时返回 `true`，否则则返回 `false`。
    ```ruby
    h = {"a" => "b", "c" => "d"}
    p h.key?("a")       #=> true
    p h.has_key?("a")   #=> true
    p h.include?("z")   #=> false
    p h.member?("z")    #=> false
    ```
- `h.value?(value)`
- `h.has_value?(value)`
    查看散列的值中是否存在指定对象的方法。这两个方法只是把 `key?`、`has_key?` 方法中代表键的 `key` 部分换成了值 value，用法是完全一样的。