completed
srv_active,
leted
aio
aio
requests
requests
requests
0 srv_shutdown, 277461
第2章理解MySQL体系结构|55
(read thread)
(write thread
(read thread）
(read
(flushed=0 and
Log
ead
thread
th
ead
ad
---
## Page 78
56
|MySQL DBA工作笔记：数据库管理、架构优化与运维开发
输出如下：
看
新落盘。如果结合最开始的 InnoDB 体系结构图，其实整体要表达的含义是类似的。
磁盘文件，是一个异步的过程，而且为了防止断电丢失数据库，会按照一定的策略把数据刷
的时候会慢一些，之后就会快得多，整个过程是把磁盘里的数据加载到这个缓存里面。
一下缓冲池和内存的输出内容，按照关键字“BUFFER POOLAND MEMORY”查看，
0ld database pages 120340
怎么理解 MySQL 里面的缓存池管理呢，我们可以先使用 show engine innodb status
另外一部分是 buffer cache，其实指的是磁盘等块设备的缓冲，比如内存里的数据要写入
这里要隆重介绍下 InnoDB 里的LRU 技术，也是在数据库缓存设计中都会使用的
如果理解了上面的输入含义，也就基本理解了缓冲池的基本含义。
Pending reads
Database pages 
Free buffers
Dictionary
Total 1arge memory allocated 33533460480
BUFFER POOL AND MEMORY
其中 page cache 是文件系统层面的缓存,数据库层面最直观的表现就是首次查询数据
memory
326446
1633878
all
O
1965840
ocated14596467
Page cache
应用程序
磁盘
read
read
young
#LRU列表中分配的数据页数，
#缓冲池分配的页数
0
图2-29
#由innodb 分配的总内存为 32G
HT
，包含 young sublist 和 old
因为该服务
数
务
---
## Page 79
也叫缓存污染。为了解决这个问题，InnoDB 存储引擎引入了 innodb_old_blocks_time 来
block 区域，整个LRU 就会是性能瓶颈了，而且 mid 位置的页也不是永久的，这种情况
系可以参考如下图2-30所示。
域，里面的数据可以理解为热数据。
midpoint 由参数 innodb_old_blocks_pct 控制，我们来简单验算验证一下，可以看到是很接近
insertion stategy。默认配置插入到列表长度的 5/8 处，和数学中的黄金分割（0.618）很接近,
的值。
接插入到缓冲区队列的队头，而是插入LRU列表的 midpoint 位置。这个算法称之为 midpoint
法中，当访问到的页不在缓冲区会直接将磁盘页数据调到缓冲区队列；而ImnoDB 并不是直
信息等，它们的管理不是基于LRU 的。
大小是不相等的，其实还有一些其他缓冲池的页被分配利用，比如自适应哈希索引、Lock
比较细心，拿出笔算一下，会发现 Free buffers +Database pages 的值和 Buffer pool size 的
326446，大约是5G，除此之外可用的页为：Free buffers1633878，大约是25G，如果你
会有一个列表，我们叫LRU LIST，上面存放了一些数据页，这里就是 Database pages
的，怎么能够减少重复的页加载频率呢，InnoDB 的 LRU是一种定制化的算法，首先它
算法。
回到LRU 算法，InnoDB 在LRU 列表中加入了参考点，也叫 midpoint。传统的LRU算
LRU 本质是尽可能让数据页在缓存中长时间保留，提高访问效率，但是缓存是有限
但是有了参照点后，怎么有效地管理呢，
之后的列表称之为 old 列表，也叫 old sublist 或者 sublist of old block 区域，它们的关
midpoint 之前的列表称之为 new 列表，也叫 young sublist 或者 sublist of new block 区
mysql>
BlockCached
0.6250
5/8
 select 5/8,1-120340/326446 ,100-@@innodb_old_blocks_pct;
BlockCached
BufferPool LRUList
63%
elockCached
0.6314
Sublistof old
BlockCached
BlockCached
图2-30
一些全表扫描的表如果进入 sublistof new
1
Block Cached
BlockCached
BlockCached
631
%28
第2章理解MySQL体系结构|57
elock cached
BlockCached
---
## Page 80
58丨MySQLDBA工作笔记：数据库管理、架构优化与运维开发
75，而根据谷歌的压测推荐是80）。
Checkpoint LSN来维护的，我们下一小节会细说Checkpoint 技术。
一个较新的状态，在系统崩溃之后能够快速地恢复，这个在数据状态的记录中是通过
使用率和性能来说，不是越大越好。
可用页数量，默认值为1000，即16M，它会影响现成Page Cleaner 刷新脏页的数量，从
者动态的，在 MySQL 5.6 版本中引入了新参数 innodb_Iru_scan_depth 来控制 LRU 列表中
的一些关联关系没搞明白。
LIST和FREELIST，它们和LRULIST是什么关系呢，很多同学从入门到放弃就是因为这样
2.3.5InnoDB 中的脏页管理
况下性能提升明显。
可以通过 hash 算法指向不同的缓存池里面，可以进行并行的内存读写，在高IO 负载的情
BUFFERPOOL会从O开始，如下：
如果你在线上环境查看InnoDB的状态输出信息，会看到有多个BUFFER POOL的输出，
该参数来保证热点数据不轻易被刷出，这个参数值默认为1000（毫秒）。
表示页读取到 mid位置之后需要等待多久才会被加入到LRU 列表的热端。可以通过设置
所以这个时候反过来看“BUFFERPOOLAND MEMORY”部分的输出就不难理解了
而对于脏页的刷新比例，是由参数 innodb_max_dirty_pages_pact 来控制的（默认是
为什么会需要 FLUSH LIST 来维护脏页的数量呢，主要目的是让InnoDB 尽可能保持
这几个LIST之间的关系类似于下图2-31这样的形式。
对于脏页的管理，InnoDB 有一个专门的列表FLUSHLIST，它的大小不是无限大或
其实这个是由FREELIST来维护的。
Free buffers
我们在InnoDB status 里面输出的内容：
前面熟悉了InnoDB对于LRU的管理方式之后，有些同学可能有些迷茫，说还有FLUSH
这个是通过参数 innodb_buffer_pool_instances 开启了多个缓存池，把需要的数据页
Pending reads
Modified db pages
Free buffers
Buffer pool
---BUFFERPOOL0
INDIVIDUAL BUFFER POOL INFO
pages
pages
size
204625
40414
204625
bytes
245730
---
## Page 81
要远远高于FLUSHLIST。
的管理方式，追求多快好省，而FREELIST和LRULIST是一种动态平衡的状态，大小
此种类型 page 位于 LRU LIST 和 FLUSH LIST 中。
此种类型 page 位于 LRU LIST 中。
缓存池中的页就是在这三种状态中变换和调整；总体来说，FLUSHLIST是一种定量
其中，脏页的比率计算可以参考如下图2-32所示的公式：
隔几秒钟再去查看，会发现页的数量有很明显地变化。
如果要查看 page 的一些状态数据，可以使用如下的命令：
（2）clean page：此 page 被使用，对应数据文件中的一个页面，但是页面没有被修改，
（1）free page：此 page 未被使用，此种类型 page 位于 FREE LIST中。
Variable_name
其中 buffer pool 中的最小单位是页，分为三种类型：
Innodb_buffer_pool_pages_misc
Innodb_buffer_pool_pages_LRU_flushed
001
Innodb
Innodb
Innodb_buffer_pool_pages_data
nnodb
nnodb
buffer
buffer_pool
buffer
buffer
LRU LIST
FREE LIST
pool
pool
pool
l_pages_flushed
pages_
pages
pages_made_young
pages_made_not
pages
total
old
free
，对应数据文件中的一个页面，
图2-32
图2-31
_young
|Value
262112
93638
11
3340
254103
7998
270022533
6324461464
FLUSH LIST
第2章理解MySQL体系结构|59
，但是页面被修改过
1
---
## Page 82
60丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
和搭建 Slave 经常会用到，另外根据二阶段提交的场景，崩溃恢复也会用到 Binlog。
redo log buffer,而事务提交的时候会通过 Redo Log Buffer 把数据变化写入 Redo Log 里面
undo开始有了新的变化。
擎,也就是说无论是MyISAM还是InnoDB 等存储引擎，Binlog 都会记录，所以数据恢复
有记录数据变化过程的日志，也就是我们接下来要分析的两类日志。
能，刷新脏页的过程是异步的，而一旦数据库崩溃，如何保证数据的完整性呢，首先得
FLUSHLIST来刷新脏页以完成数据落盘，这个过程中还需要注意，为了提高吞吐量和性
2.3.6
并存？
（假设有3组redo日志），如下图2-34所示。
到了这里，相信很多同学还会冒出一个新的问题：一次数据变更，产生了Binlog 和
其次，Binlog 是 MySQL server 范畴的，记录的是数据的变更操作，支持多种存储引
首先，Redo 是 Innodb 引擎范畴的，记录物理页的修改，做崩溃恢复时所用。
update test set tid=100;
（2）Undo log：存放在共享表空间里面的（ibdata*文件），从 MySQL 5.7版本开始，
（1）Redo 日志：Innodb 的事务日志，保存在日志文件 ib_logfile*里面。
通过上面的分析，我们知道 InnoDB 里面的数据变化都会有相应的页来存储，通过
In-MemoryStructures
在 InnoDB 处理的时候，会把相应的页加载到 Buffer Pool里面，数据的变化会写入
假设我们有如下一条 SQL语句：
我们来看官方提供的一个 InnoDB 体系架构图（图2-33）。
InnoDB的日志管理
口
eratingSyst
Oper
图2-33
Doublewrite Buffer
Change Buffer
Undo Logs
ib_logfile1
zooopun
eral Tablespa
广
redo log_buffer
ib_logfile1
图2-34
ib_logfileo
ib_logfile2
redologfiles
---
## Page 83
期，如下图2-35所示。
at_trx_commit为0，数据导入后，恢复为1。
总结，如下表2-4所示。
以 innodb_flush_log_at_trx_commit 更为出名，甚至是 MySQL 面试必考题目，我们来简单
sync_binlog 是将二进制日志文件刷新到磁盘上,它们就是行业里著名的双“1”参数，其中
其中 innodb_flush_log_at_trx_commit 是将事务日志从 innodb log buffer 写入到 redo log中,
Redo，它们是否需要同步？
参数选项
这里我们就需要引出两个重量级参数innodb_flush_log_at_trx_commit 和 sync_binlog,
再来说下 undo Log，undo 记录了数据修改的前镜像。存放于 ibdata 中，它就好比是
注：在数据导入中，为了提高性能，
实时写日志
实时写日志
延迟写日志
日志写入模式
延迟刷盘
实时刷盘
刷盘模式
事务日志写入OS
log buffer实时写日志，每隔1秒刷盘
log buffer实时写日志，数据刷盘
log buffer 每隔1秒写日志，数据刷盘
务提交，
图2-35
表2-4
可以考虑临时调整参数值innodb_flush_log
务日志写入刷新）
小结
每隔1秒刷新到磁盘
第2章理解MySQL体系结构|61
较快，存在数据丢失风险
最大安全性-
最快，存在数据丢失风险
特点
层面
---
## Page 84
62丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
电，一切都晚了。
们使用 Word 编辑文件一样，我们是建议大家使用过程中边编辑边保存，否则电脑突然断
何使得恢复的过程高效可行，就需要考虑检查点机制（Checkpoint），检查点机制就跟我
实他早就在那里了，道理是类似的。
在课堂上点名，直到你点名叫到某个学生并且你们目光相遇，你才知道他来上课了，其
内容在前面已经讲过了。
2.3.7
荐使用的。
数innodb_purge_rseg_truncate_frequency 可以做 undo 截断。
以说是上了正道了，我们可以截断，化被动为主动，这种方式就很好。
是无能为力，不过这个也算是一个过渡的特性吧，到了MySQL5.7版中，这个功能就可
理是没有现成的办法的，想把它收缩，而唯一的办法就是重建或者重构数据。
一个摄像机，记录了过去的美好时光。
一回到 InnoDB 上面，如果数据库发生宕机，我们可以借助 redo 来完成崩溃恢复，如
不过这个新特性还是有使用门槛的，需要重新初始化，
：MySQL 5.6 版中把 undo 做了剥离，可以指定单独的 undo 表空间，但是收缩阶段还
Last checkpoint at 1337477208506
有的同学说，我怎么不知道，其实这些知识点就在我们身边，假设你是一个老师，