title:Obfuscation-Resilient Executable Payload Extraction From Packed Malware
author:Binlin Cheng and
Jiang Ming and
Erika A. Leal and
Haotian Zhang and
Jianming Fu and
Guojun Peng and
Jean-Yves Marion
Obfuscation-Resilient Executable Payload 
Extraction From Packed Malware
Binlin Cheng, Hubei Normal University & Wuhan University; Jiang Ming, 
Erika A Leal, and Haotian Zhang, The University of Texas at Arlington; 
Jianming Fu and Guojun Peng, Wuhan University; Jean-Yves Marion, 
Université de Lorraine, CNRS, LORIA
https://www.usenix.org/conference/usenixsecurity21/presentation/cheng-binlin
This paper is included in the Proceedings of the 30th USENIX Security Symposium.August 11–13, 2021978-1-939133-24-3Open access to the Proceedings of the 30th USENIX Security Symposium is sponsored by USENIX.Obfuscation-Resilient Executable Payload Extraction From Packed Malware
Binlin Cheng∗†
Jiang Ming∗‡
Hubei Normal University & Wuhan University, China
The University of Texas at Arlington, USA
PI:EMAIL
Erika A Leal and Haotian Zhang
The University of Texas at Arlington, USA
{erika.leal,haotian.zhang}@mavs.uta.edu
PI:EMAIL
Jianming Fu† and Guojun Peng†
Wuhan University, China
{jmfu,guojpeng}@whu.edu.cn
Université de Lorraine, CNRS, LORIA, F-54000 Nancy, France
Jean-Yves Marion
PI:EMAIL
Abstract
Over the past two decades, packed malware is always a ve-
ritable challenge to security analysts. Not only is determining
the end of the unpacking increasingly difﬁcult, but also advan-
ced packers embed a variety of anti-analysis tricks to impede
reverse engineering. As malware’s APIs provide rich infor-
mation about malicious behavior, one common anti-analysis
strategy is API obfuscation, which removes the metadata of
imported APIs from malware’s PE header and complicates
API name resolution from API callsites. In this way, even
when security analysts obtain the unpacked code, a disassem-
bler still fails to recognize imported API names, and the unpac-
ked code cannot be successfully executed. Recently, generic
binary unpacking has made breakthrough progress with noti-
ceable performance improvement. However, reconstructing
unpacked code’s import tables, which is vital for further mal-
ware static/dynamic analyses, has largely been overlooked.
Existing approaches are far from mature: they either can be ea-
sily evaded by various API obfuscation schemes (e.g., stolen
code), or suffer from incomplete API coverage.
In this paper, we aim to achieve the ultimate goal of Win-
dows malware unpacking: recovering an executable malware
program from the packed and obfuscated binary code. Based
on the process memory when the original entry point (OEP)
is reached, we develop a hardware-assisted tool, API-Xray,
to reconstruct import tables. Import table reconstruction is
challenging enough in its own right. Our core technique, API
Micro Execution, explores all possible API callsites and exe-
cutes them without knowing API argument values. At the
same time, we take advantage of hardware tracing via Intel
Branch Trace Store and NX bit to resolve API names and
ﬁnally rebuild import tables. Compared with the previous
work, API-Xray has a better resistance against various API
∗Both authors contributed equally to the paper.
†(1) Key Laboratory of Aerospace Information Security and Trust Com-
puting, Ministry of Education; (2) School of Cyber Science and Engineering,
Wuhan University.
‡Corresponding authors: jiang.ming@uta.edu.
obfuscation schemes and more coverage on resolved Win-
dows API names. Since July 2019, we have tested API-Xray
in practice to assist security professionals in malware analy-
sis: we have successfully rebuilt 155,811 executable malware
programs and substantially improved the detection rate for
7,514 unknown or new malware variants.
1 Introduction
Over the past two decades, malware is always one of the top
cyber threats that can cause catastrophic damage. In 2020,
over 350,000 new malicious programs worldwide are identi-
ﬁed every day [39]. McAfee Lab estimates that malware reve-
nue can reach multiple billions of dollars by 2020 [45]. Driven
by huge ﬁnancial gains, malware authors typically obfuscate
their programs to circumvent malware detection. Among dif-
ferent obfuscation technologies, binary packing is the most
prevalent one adopted by Windows malware [49, 55, 74, 86],
because it protects the original code from static analysis and
has a right balance between strength and performance [1, 6].
The trend of binary packing development reveals two salient
features. First, when a packed malware starts running, the
attached unpacking routine will pass through multi-layers of
self-modifying code until the original entry point (OEP) of
the payload is reached [11, 73]. Second, complicated packers
also incorporate multiple anti-analysis methods (e.g., anti-
debugging, anti-hooking, and anti-sandbox) to hinder both
automated and manual unpacking attempts [63].
On the defender side, generic binary unpacking has ge-
nerated a large body of literature [8, 15, 35, 38, 51, 52, 60].
Most of them rely on memory access tracing to ﬁnd the re-
ach of OEP and then dump the current process memory as
the unpacked program. The recent progress in this direction,
BinUnpack [15], proposes an effective heuristics to quickly
determine the end of multi-layer unpacking without heavy me-
mory access tracing. Despite this, in BinUnpack’s large-scale
evaluation, the authors have admitted that many unpacked
USENIX Association
30th USENIX Security Symposium    3451
malware samples cannot run, which weakens the utilization
of unpacked code in further malware analysis. This lack of
executability is not just BinUnpack that faces issues, and it
is actually fairly common for existing generic unpacking so-
lutions [8, 35, 38, 51, 52, 60]. The root cause is the unpacked
code’s import tables, which store the metadata of imported
APIs, are corrupt.
To perform malicious behavior (e.g., code remote injection
and C&C communication) in diverse Windows systems, mal-
ware samples interact with Windows OS through user-level
Windows APIs [27, 29, 53]. The import table structures in a
PE∗ ﬁle’s header store the information about Windows APIs
that the PE ﬁle requires to execute. In particular, Import Ad-
dress Table (IAT) is an address lookup table for calling Win-
dows APIs; API callsites in a PE ﬁle refer to the IAT via
indirect calls/jumps.† Note that the IAT does not take effect
until the program is loaded into memory. Another table, Im-
port Name Table (INT), containing API names corresponding
to IAT entries, can be treated as the IAT’s index. Using the
INT, Windows PE loader ﬁlls each IAT entry with the asso-
ciated Windows API’s virtual address. Since these two ta-
bles are referenced from the PE header, examining these data
from a malware sample’s header yields information about
this malware’s capability. For example, a malware instance
that imports functions from advapi32.dll is likely to access
or change the registry; “CreateRemoteThread” API is often
misused for the purpose of process injection [37]. The list of
loaded APIs is necessary and of great practical signiﬁcance
for understanding malware behavior [3, 4, 32, 65]. Especially
for a new malware variant, its instructions may not match any
known malware signatures, but API calls can still provide
valuable insight into its malicious intention [70].
Unfortunately, binary packer developers are also aware of
the value of imported APIs. They reduce the wiggle room for
security analysts by not using the standard API resolution in
the packed PE ﬁle. Two key factors amplify the attackers’ ad-
vantage. First, they delete INT & IAT entries and dereference
both of them from the PE header, so that these two import
tables become unavailable for analysis. Second, to sustain
the original functionality after unpacking, the attached un-
packing routine works in an ad-hoc way to customize a new
IAT before the execution of the original code. As our study
shows in §3, this custom IAT can contain misleading entries
to hide the real names of invoked APIs. As a result, given
the process memory produced by a generic unpacking tool,
a disassembler fails to recognize API names at API callsites
(e.g., call [ f1]), because IAT entries (e.g., [ f1]) do not directly
point to the related APIs in a DLL. In addition, without the
INT as an index, Windows PE loader cannot load correct API
addresses of the target system into the IAT, and therefore the
unpacked program has no executability in a Windows system.
∗Portable Executable (PE) is an executable ﬁle format in Windows OS.
†e.g., call [ f1], and f1 points to an entry of the IAT.
The goal of import table reconstruction is to resolve invo-
ked API names and reconstruct the removed INT & IAT for
the unpacked program. Therefore, a disassembler can recog-
nize imported APIs to facilitate static analysis. Furthermore,
the unpacked program becomes a “working PE” that can be
successfully executed. Since most of the anti-analysis tricks
embedded in a packer have been removed, this working PE un-
leashes the power of malware dynamic analysis. We name the
process memory when the unpacking algorithm reaches the
original entry point of the packed program as OEP memory.
The research question of recovering a working executable ﬁle
is, given OEP memory, how to reason about the real API name
corresponding to each API callsite. Especially, different API
obfuscation schemes (e.g., stolen code and ROP redirection)
may go through a lengthy call/jump chain before reaching
the real API code, rendering manually resolving API names
tedious and error-prone.
Researchers have realized the signiﬁcance of import table
reconstruction [2, 15, 17, 40–42, 44, 62, 69, 73, 81]. However,
they do not cover all API obfuscation methods that we pre-
sent in this work. The current solutions can only resolve
partial API names either for statically identiﬁable targets or
limited targets in a single execution trace. No work claims
to resolve Windows API names for an unpacked program
completely. Besides, many approaches track the target of an
API call using API hooking [62] or dynamic binary instru-
mentation [17, 40–42, 73], but malware can ﬁngerprint these
monitoring environments.
In this paper, we aim to bridge the gap in the generic bi-
nary unpacking domain. Our technique, named API-Xray, is
a hybrid static-dynamic analysis towards complete import
table reconstruction. To transparently collect runtime control
ﬂow targets, we take a less intrusive approach with no code
injection via hardware-assisted mechanisms: Intel Branch
Trace Store (BTS) and NX bit [20]. More concretely, given
an unpacked program’s OEP memory, we ﬁrst perform sta-
tic analysis to explore all potential API callsites. Then, our
proposed “API Micro Execution” enforces executing each
potential API callsite without requiring concrete function ar-
guments. At the same time, we track the target address of
an API call with the help of BTS’s branch tracing capability.
In addition, we also enable NX bit to interrupt the execution
when the complex control ﬂow ﬁnally reaches the target API.
After that, we further analyze BTS record and determine the
real API addresses that we need. At last, we associate the
obtained API addresses with the corresponding API names,
rebuild INT & IAT entries, and restore the PE header. API-
Xray complements the state-of-art binary unpacking tools and
frees security analysts from the burden of manually piecing
together the tedious steps of import table reconstruction.
We conduct a set of experiments to evaluate the efﬁcacy
of API-Xray. We ﬁrst compare API-Xray with representative
related work (e.g., S&P’15 [73] and CCS’18 [15]) on the
prevalent packers that contain API obfuscation. API-Xray is
3452    30th USENIX Security Symposium
USENIX Association
the only one that can defeat different API obfuscation schemes
and reconstruct import tables entirely in all cases. Compared
with the other two common hardware tracing mechanisms,
namely Last Branch Record and Intel Processor Trace, we
demonstrate that BTS is the only right option for import table
reconstruction. At last, we report our experience after testing
API-Xray in practice: 1) we have successfully rebuilt 174,285
malware’s import tables, and 149,488 of them are labeled as
“Malicious” by at least one malware sandbox. 2) for 7,514
unknown or new malware variants, the output of API-Xray
can substantially increase the accuracy of malware detection.
In summary, this paper makes the following contributions:
• The success of import table reconstruction hinges on the
deep understanding of API obfuscation. Our in-depth
study unveils new API obfuscation schemes that are
not public before. Our work serves as a baseline for
evaluating the effectiveness of future work (§3).
• Our proposed “Hardware-Assisted API Micro Execution”
is the ﬁrst approach towards recovering an executable
program from the packed code. Our work exhibits strong
resistance to API obfuscation and signiﬁcantly lightens
the burden of security professionals (§4).
• We have evaluated API-Xray extensively with a large-
scale dataset, including prevalent and custom packers.
API-Xray maintains a high success rate consistently in
all cases (§5).
2 Background and Related work
Given a packed malware sample, our work assumes that se-
curity analysts have already found the original entry point
(OEP) of malware and obtained the process memory at that
time (i.e., OEP memory). Note that most of the current ge-
neric unpacking tools can meet this prerequisite. This paper
tackles binary packer’s API obfuscation, which deters security
analysts from the further analysis of the unpacked code.
Various API obfuscation schemes are prevalent in pac-
kers. We ﬁrst introduce the background information needed
to understand this challenging problem. Then we discuss the
limitations of existing import table reconstruction methods.
At last, we introduce the work most germane to our hardware-
assisted control ﬂow monitoring. Regarding the complexity
of advanced packers and the status quo of generic unpacking
techniques, interested readers are referred to three papers:
CSUR’13 [63], S&P’15 [73], and CCS’18 [15].
2.1 Binary Packers Avoid Using Standard
API Name Resolution
The Role of Import Tables. Figure 1 illustrates an example
of standard API resolution. The header of a PE ﬁle contains
two import tables: import name table (INT) and import ad-
dress table (IAT). These two tables contain names and addres-
ses of APIs that need to be imported from a speciﬁc DLL (e.g.,
kernel32.dll), respectively. Since the compiler is unaware of
imported API addresses at compilation time, IAT entries are
ﬁrst ﬁlled with placeholders temporarily ( 1 ). Note that API
names in the INT and API addresses in the IAT are main-
tained in the same order ( 2 ). When the executable ﬁle is
loaded, Windows PE loader is responsible for mapping the