To: PI:EMAIL (Jeffrey Friedl)
From: PI:EMAIL (The King)
Date: Thu, Feb 29 2007 11:15
Message-Id:
Subject:Be seein'ya around
Reply-To:PI:EMAIL
X-Mailer: Madam Zelda's Psychic Orb [version 3.7 PL92]
Sorry Ihaven't been around lately.A fewyears back I checked into
that ole heartbreak hotel in the sky，ifyaknowwhatImean.
The Duke says *hi".
Elvis
我们希望程序的输出结果king.our包括下面的内容：
To: PI:EMAIL (The King)
From: PI:EMAIL (Jeffrey Friedl)
Subject:Re:Be seein'ya around
On Thu, Feb 29 2007 11:15 The King wrote:
I>SorryIhaven'tbeen around lately.Afewyears back I checked
I>into that ole heartbreak hotel in the sky.ifyaknowwhatImean.
I> The Duke says "hi*.
I>
Elvis
现在我们来分析。为了生成新的header，我们需要知道目标地址（即本例中的elvis@hh，
tabloid.org，来自原始信息中的Reply-To字段），收件人的姓名（TheKing），我们自
己的地址和姓名，以及主题。另外，为了生成邮件正文的导入部分（introductoryline），我
们还需要知道原始邮件的日期。
这些工作可以分为下面3步：
1.从原始邮件的header中提取信息；
2.生成回复邮件header；
3.打印原始邮件信息，行首用1>’缩进。
这样考虑有点超前了一一在没有决定程序如何读人数据之前，就关心起如何处理数据了。
幸运的是，Perl提供了神奇的“<>”操作符。在应用到变量Svariable时，使用“Svariable
=<>”，这个有趣的结构能够每次读入一行数据。输人的数据来自命令行中Perl脚本之后列
出的文件名（例如上面例子中的king.in）。
请不要混淆操作符<>与Shell的重定向符号“>filename”或者是Perl的大于/小于号。Perl
中的<>相当于其他语言中的getline（）函数。
1.I
---
## Page 81
使用正则表达式修改文本
55
读人所有输人数据之后，<>很方便地返回未定义的值（作为布尔值处理），所以整个文件可
以这样处理：
while （$line =<>）{
...处理sline.
1
我们会用类似的办法来处理邮件，但是邮件本身的性质决定了我们必须对邮件header特殊
处理。第个空行之前的信息是header，之后的则是正文部分。为了只读入header，我们可
以使用下面这段代码。
处理header
while ($line = <>){
if（$line =~m/\s*$/）{
last；#停止while循环内的处理，跳出循环
）
...处理header信息...
）
..处理邮件内的其他信息.··
****
我们用\s*S来检查表示邮件header结束的空行。这个正则表达式检查的是，当前的文本
行是否有一个行开头（其实每一行都有，由脱字符匹配），然后跟着任意数目的空白字符（尽
管我们并不期望有任何空白字符），然后字符串结束（注3)。关键词last会跳出while循
环，停止处理header。
所以，在循环内部，在空行检测之后，我们能够按照自己的想法来处理header的每一行。
在本例中，我们希望提取信息，例如邮件的主题和时间。
要提取主题，我们可以使用一个常见的技巧：
if($line~m/^Subject:（.*)/i）（
$subject = $1;
这段代码尝试匹配一个以‘Subject：·’开头，但不区分Subject大小写的字符申。如果能
够匹配，后面的.*匹配这一行的其他部分。因为*在括号中，所以之后我们能用s1来
访问邮件的主题。在这个例子中，我们希望把它保存到变量ssubject中。当然，如果正则
表达式无法匹配这个字符串（大多数情况下都不能），结果就是if语句返回结果为false，
Ssubject变量没有变化。
注3：我在这里用的是“字符串”（string）而不是“行”（line），因为虽然对本例来说这不是一个
问题，但正则表达式常要处理的可能是一个包含多行文本的字符事。通常，脱字符和美元
符只匹配整个字符串的开头和结尾（在本章后面我们会遇到一个相反的例子）。无论如何，
此处这种区别并不重要，因为根据我们的程序，我们知道Sline的内容不会多于一行。
---
## Page 82
56
第2章：入门示例拓展
关于.*的警告
.*；通常用来表示“一组任何字符”（abunchofanything），因为点号可以匹配任何字
符（在某些工具中，不包括换行符），而星号表示可以为任意数目，但并非必须。.*
可能很有用。
不过，如果把.*作为整个正则表达式的一部分，而用户又不真正了解其中的原理，
就可能陷入某些隐藏的“陷阱”。我们已经看到过一个例子（26），并会在第4章深
入讨论这个话题的时候见到更多的例子（164)。
我们可以用同样的办法来处理Date和Reply-To字段：
if（$line=~m/^Date:（.*)/i）{
$date = $1;
if（$line=~m/^Reply-To:（.*)/i）（
$reply_address = $1;
From：所在的行稍微麻烦一点。首先，我们需要找到以‘From:'开头的行，而不是以‘From
开头的第一行。我们需要的是：
From: PI:EMAIL (The King)
它包含了邮件的发送地址，发送者的姓名在括号内，我们要提取的是姓名（译注1）。
我们用From：·（\S+）来提取发送地址。你可能猜到了，S匹配的是所有的非空白字符
（49），所以"S+匹配第一个空白之前的文本（或者目标文本末尾之前的所有字符）。在
本例中，就是邮件的发送地址。匹配之后，我们希望匹配括号内的文字。显然，此处也需
要匹配括号本身。我们用（和）来匹配，转义之后的括号不再具有特殊的含义。在括号
内，我们希望匹配任何字符一除了括号之外的任何字符，所以采用[~（）]*。记住，字符
组的元字符不同于正则表达式的“普通”元字符，在字符组内部，括号不再具有特殊含义，
因此也不需要转义。
综合起来，我们得到：
From:·(\s+）\(（[(）1*)\）
其中的括号有点多，初看起来不太好懂，图2-4解释得更清楚：
译注1：一般情况下，邮件应当回复到“回复地址”，即Reply-To字段的内容，若此字段不存
在，则回复到发送的邮箱，故此处说需要提取的只是发送者的姓名。
---
## Page 83
使用正则表达式修改文本
57
字符类内部的字符，括号没有特殊含义
普通括号字符
^From:
(\8+）\（（[（)】*)V）
中
保存到s1
保存到s2
图2-4：嵌套的括号，$1和$2
如果图2-4的正则表达式能够匹配，我们可以通过$2得到发送者的姓名，从$1得到可能的
回复地址。
if（$line=~m/^From:（\s+）\（（[（）]*）\）/i）（
$reply_address = $1;
$from_name = $2;
并非所有的E-mail信息都包含Reply-To字段，所以我们把s1暂定为回复地址。如果之后
出现了$Reply-To字段，我们会重设Sreply_address。综合起来就得到：
while ($line =)
if（Sline=~m/^\s*S/）（#如果存在空行
last；#就立即结束while循环
if （$line =~m/^Subject:（.*)/i）（
$subject = $1;
2
if （$line =~m/^Date:（.*）/i）{
Sdate=$1;
if（$line=m/^Reply-To:（\s+）/i）（
Sreply_address = $1;
if（$1ine=~m/^From:（\8+）\（（[^（）]*）\）/i）（
$reply_address = $1;
$from_name = $2;
这段程序检查header的每一行，如果某个正则表达式能够匹配，则设置相应的变量。header
的许多行无法由这些正则表达式匹配，所以会被忽略。
---
## Page 84
58
第2章：入门示例拓展
while循环结束之后，我们就能够生成回复邮件的header了（注4)：
print"To:$reply_address($from_name)\n";
print *From:jfriedl\@regex.info（Jeffrey Friedl)\n*;
print *Subject:Re:Ssubject\n";
print *\n”;#blank line to separate the header from message body.
请注意，我们在主题之前加上了Re：，表示这是一封回复邮件。最后，在header之后，我
们列出原始邮件的内容：
print"On$date$from_namewrote:\n*;
对于其他的输人信息（也就是原始邮件的正文部分），我们在每一行之前添加“1>’提示
符：
while（Sline=<>){
print *|>$line";
（
有意思的是，这段程序也可以用另一种方法，使用正则表达式来加入引用提示符：
$line=~8/~/1>/;
print $line;
存在的字符”“替换”为>，其实并没有替换任何字符，只是在字符串的开头加人>。
在本例中这样做有点滥用的嫌疑了，但是我们将在本章中看到类似（但更有用）的例子。
其实世界的问题，真实世界的解法
既然摆出了一个真实世界的例子，就应该指出这个解法在真实世界中的缺德。我已经说过，
这些例子的目的在于展示正则表达式的使用方法，而Perl程序不过是展示的手段。我使用
的Perl程序并不一定使用了最有效或者最好的解法，但是，我希望它能说明正则表达式的
用法。
同样，真实世界的邮件信息比这个简单问题中的邮件信息复杂很多。From：这一行就可能有
许多种格式，而我们的程序只能处理一种。如果真正的From：这一行无法匹配我们的模式，
则sfrom_name变量就不会设置，使用时保持在未定义的状态（也就是“没有值”的值的一
种）。理想的解决办法是修改这个正则表达式，让它能够处理各种不同的邮件地址/姓名格式，
注4：在Perl的正则表达式和双引号内的字符串中，大多数“@”都必须转义（o77）。
---
## Page 85
使用正则表达式修改文本
59
不过，作为第一步，在检查原始邮件之后（生成回复模板之前），我们可以这样：
if(not defined($reply_address)
or not defined($from_name)
or not defined($subject)
or not defined($date))
1
die *couldn't glean the required information!";
Perl的defined函数检查一个变量是否设置了值，而die函数用来发出错误信息，退出程
序。
另一点需要考虑的是，程序假设From：这一行出现在Reply-To：之前。如果From：出现在
之后，就会覆盖从Reply-To取得的sreply_address。
“真正的”真实世界
发送电子邮件的程序有许多类，每类程序对标准的理解都不一样，所以处理电子邮件并不
是件简单的事情。我曾经想用Pascal程序来处理电子邮件，但我发现，如果没有正则表达
式，处理起来极其困难，困难到我决定先用Pascal写一个类似Perl的正则表达式包，再来
做其他事情。进人没有正则表达式的世界之后才发现，自己已经习惯正则表达式的功能和
便捷了，而我显然不希望在没有正则表达式的世界呆太久。
用环视功能为数值添加逗号
AddingCommastoaNumberwithLookaround
大的数值，如果在其间加人逗号，会更容易看懂。下面的程序：
可能输出“TheUSpopulationis298444215”，但对大多数说英语的人来说，“298.444.215"
看起来更加自然。用正则表达式该如何做呢？
动脑子想想这个问题，我们应该从这个数的右边开始，每次数3位数字，如果左边还有数
字的话，就加人一个逗号。如果我们能把这种思路直接用到正则表达式中当然很好，可惜
正则表达式一般都是从左向右工作的。不过梳理一下思路就会发现，逗号应该加在“左边有
数字，右边数字的个数正好是3的倍数的位置”，这样，使用一组相对较新的正则表达式特
）
环视结构不匹配任何字符，只匹配文本中的特定位置，这一点与单词分界符b、锚点
---
## Page 86
60
第2章：入门示例拓展
和'S相似。但是，环视比它们更加通用。
一种类型的环视叫“顺序环视（lookahead）”，作为表达式的一部分，顺序环视顺序（从左
至右）查看文本，尝试匹配子表达式，如果能够匹配，就返回匹配成功信息。肯定型顺序
环视（positivelookahread）用特殊的序列（?=）来表示，例如（？=\d），它表示如果当前
位置右边的字符是数字则匹配成功。另一种环视称为逆序环视，它逆序（从右向左）查看
文本。它用特殊的序列"（？<=)表示，例如（？<=\d)，如果当前位置的左边有-一位数字，
则匹配成功（也就是说，紧跟在数字后面的位置）。
环视不会“占用”字符
在理解顺序环视和其他环视功能时需要特别注意一点，即在检查子表达式能否匹配的过程
中，它们本身不会“占用”任何文本。这可能有点难懂，所以我准备了下面的例子。正则
表达式Jeffrey：匹配：
.byJeffrey Friedl.
但同样的正则表达式，如果使用顺序环视功能，即（?=Jeffrey），则匹配标记的位置：
byJeffreyFriedl
顺序环视会检查子表达式能否匹配，但它只寻找能够匹配的位置，而不会真正“占用”这
些字符。不过，把顺序环视和真正匹配字符的部分—例如Jeffi—结合起来，我们能
得到比单纯的‘Jeffi更精确的结果。结合之后的正则表达式是（?=Jeffrey)Jeff，下一页
.byJeffrey Friedl.
在此处它的匹配和单纯的Jeffi一样，但是下面的情况不会匹配：
byThomasJefferson
Jeffi自己能够匹配这一行，但是因为不存在（?=Jeffrey）能够匹配的位置，整个表达式
就无法匹配。现在环视的好处还看得不是很明显，但是请不用担心，现在我们只需要关心
顺序环视的原理—我们很快会遇到能够充分展现其价值的例子，。
受此启发，你或许会发现（?=Jeffrey）Jeffi和Jeff（?=rey）是等价的（能够发现这一点
的读者很了不起）。它们都能匹配“Jeffrey”这个单词中的“Jeff”。
我们还需要认识到，它们结合的顺序非常重要。Jeff（?=Jeffrey）不会匹配上面的任何一
个例子，而只会匹配后面紧跟有“Jeffrey”的“Jeff”。