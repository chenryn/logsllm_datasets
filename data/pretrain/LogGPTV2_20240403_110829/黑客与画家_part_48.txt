他们创造便利，尽可能多地把语言的内部暴露在他们面前。
方式改动你的语法模型。我的建议就是，让他们这样干吧，而且应该为
样高度组合的系统，那就更是如此了。许多黑客会用你做梦也想不到的
有用户以违背你本意的方式使用你的工具。如果你制造的是编程语言这
言总是稍微带一点放纵不羁、不服管教的个性。
用。C语言就是这样的例子，早期的Lisp 语言也是如此。真正的黑客语
个都有很完整的独立用途。“混乱”的意思是它允许黑客以自己的方式使
入内部，揣测原始设计者的意图。
些高级抽象的语言内部接口。比如，黑客喜欢破解，而破解就意味着深
火”，我指的是他们会突破设计者提供给用户的外部语义层，试着控制某
其实，黑客并不会彻底颠覆你的工具，在一个大型程序中，他可能
你应该开胸怀，欢迎这种揣测。对于制造工具的人来说，总是会
① 在《神经外科医生手记》（When the Air Hits Your Brain）一书中，神经外科医生弗托塞
一种真正优秀的编程语言应该既整洁又混乱。“整洁”的意思是设计
优秀程序员经常想做一些既危险又令人恼火的事情。所谓“令人恼
的。一切正常当然很好，但是不可否认，能够抓到某些bug会让人兴奋到极点。
很难把腰椎间盘突出与又大又好吃联系在一起，但是，我想我知道他们指的是什么。我
克讲述了住院总医生戈雷的一段话，内容关于外科医生与内科医生的区别。
但是他们看到高血压就憎恨不已..”
些内科医生真是令人讨厌，总是喜欢谈论一辈子只能遇到一次的病例。这就
戈雷和我要了一个大比萨，找了一张空桌子坐下。他点起一根香烟，说：“那
和他们的区别。你看，我们喜欢腰椎间盘突出，觉得像比萨一样又大又好吃，
是他们的问题，他们只喜欢古怪的东西，讨厌普通的常见病例。这就是我们
PDG
203
梦以求的编程语言
---
## Page 230
一梦以求的编程语言
是像胡佛水坝那样从一开始就作为大型工程来设计。一下子从无到有做
筑。许多一次性程序后来也都变成了正式的程序，具备了正式的功能和
次，就像二战期间很多美国大学造的一大批临时建筑后来都成了永久建
间转化数据的程序等。令人吃惊的是，
者（为了某项模拟任务）自动生成测试数据的程序，以及在不同格式之
短时间内写出来的程序。比如，自动完成某些系统管理任务的程序，或
意料。
务。这意味着它必须很适合开发一次性程序。这一点可能出乎很多人的
被它搞得一蹶不振。最后，要么是项目陷人僵局，要么是做出来一个规
有很大用处了。
那样的语言，它是井然有序的模范，非常适合教学，但是除此之外就没
程语言。所以，我们就有了一个看似矛盾的结论：如果你想设计一种适
进。这种方法比较不会让人望而生畏，程序在不断的开发之中逐渐进步。
模小、性能差的东西。你想造一片闹市，却只做出一家商场；你想建一
出一个大项目是很恐怖的一件事。当人们接手一个巨型项目时，很容易
人感到非常不满、频频摇头。与黑客语言形成鲜明对照的就是像 Pascal
序，因为大型项目就是从一次性程序演变而来的。
合开发大型项目的编程语言，就必须使得这种语言也适合开发一次性程
用到最后，因为除非有外部政治因素的干预，程序员很少会中途更换编
一般来说，使用这种方法开发程序，一开始用什么编程语言，就会一直
个罗马，却只造出一个巴西利亚；你想发明C语言，却只开发出Ada。
外部用户。
所谓一次性程序，就是指为了完成某些很简单的临时性任务而在很
我有一种预感，最优秀的那些大型程序就是这样发展起来的，而不
开发大型程序的另一个方法就是从一次性程序开始，然后不断地改
为了吸引黑客，一种编程语言必须善于完成黑客想要完成的各种任
优秀的编程语言所具备的功能，应该会使得言必称“软件工程”的
Perl 就是一个鲜明的例子。它不仅仅设计成适合开发一次性程序，
一次性程序
一次性程序往往不是真的只用一
PDG
---
## Page 231
引力。如果考虑到你最多只打算在这个程序上耗费一个小时，这一点就
者，具有良好的互动性，可以快速得到运行结果。
必须先编译后使用的语言就不具备互动性。受欢迎的编程语言应该是前
者互动。一种有命令行界面、可以实时反馈的语言就具有互动性，那些
因为它本来就是一种系统管理工具，操作系统已经默认安装它了。
语言可以想用就用，因为它是操作系统的一部分；Perl可以想用就用，
安装和配置，最好已经安装在你的电脑上了。它必须是想用就用的。C
性程序是你只想在一小时内写出来的程序，所以它不应该耗费很多时间
言才适合开发重要的程序，但是在此之前它已经广为流行了。
壮大后，Perl才随之发展成了一种正式的编程语言。到了 Perl5，这种语
收集在一起而已。后来程序员用它写一次性程序，当那些程序逐渐发展
更重要了。
而且它本身就很像一次性程序。最初的 Perl 只是好几个生成表格的工具
发应用程序的层次吗？哦，真是太糟了。但是别忘了，编程语言是供程
数式编程，这些都不如函数库重要。那些习惯用变量类型考虑问题的语
语言本身。某种语言到底是静态类型还是动态类型、是面向对象还是函
未来的函数库将像语言内核一样精心设计。优秀函数库的重要性将超过
性程序的原始目的往往就是转化或提取字符串。许多 Perl程序的原型可
符串的巨大函数库。这类函数库对一次性程序特别重要，因为开发一次
重要特点，并且我认为正在变得越来越重要。Perl 就赢在它具有操作字
可以了。函数库就是别人帮你写好的程序，所以它是编程语言的另一个
言设计者可能会对这种趋势感到不寒而栗。这不等于把语言设计降到开
能就是把几个函数库调用放在一起。
什么样的语言适合写一次性程序？首先，它必须很容易装备。一次
我认为，未来 50年中，编程语言的进步很大一部分与函数库有关，
很容易装备不仅仅指很容易安装或者已经安装，还指很容易与使用
简洁性的最高形式当然是有人已经帮你把程序写好，你只要运行就
一次性程序的另一个特点就是简洁。对黑客来说，这一点永远有吸
函
数库
205
一梦寐以求的编程语言
---
## Page 232
00
许多程序员都已经注意到自己很容易搞错瓶颈到底在哪里。
很久以前就指出，运行速度只取决于一些关键的瓶颈。而在编程实践中，
上，我觉得代码的运行速度不是编程语言的设计者能够控制的。高德纳
数能满足自己的需要。
符集合。函数库的使用应该符合程序员的直觉，让他可以猜得出哪个函
得快。函数库的设计基础与语言内核一样，都是一个小规模的正交运算
数库数量变得太多，找到一个你需要的函数有时候还不如自己动手写来
序员使用的，而函数库就是程序员需要的东西。
序员编辑源码的时候，代码编辑器能够实时用红色显示瓶颈的部分。另
部分的性能，而不是非要等到程序员手动运行后才能知道。比如，当程
脱节，前者竭尽全力想要解决的问题其实方向不甚正确。
能大于编译器的作用。这里又一次反映出语言设计者与用户之间发生了
给使用者的赠品。但是在现实中，一个好的性能分析器对程序的帮助可
知道程序每个部分的时间开销。
会解决这个问题，虽然这方面还有很长的路要走，但是未来你可以快速
的语言，这也许是无法避免的。不管怎样，我认为一个好的性能分析器
个部分对性能的影响比较大。可能确实如此，如果你使用一种非常抽象
你需要能够找出瓶颈到底在什么地方。
楚，你只需要在瓶颈处声明清楚参数类型就可以了。所以，更重要的是
认为这是对自己技术水平的考验，而最多只把性能分析器当作一个附送
言。为了提高运行速度，并没有必要每个函数的每个参数类型都声明清
(profiler)，而不是使用其他方法，比如精心选择一种静态类型的编程语
这个问题一部分源于沟通不畅。语言设计者喜欢提高编译器的速度，
设计优秀的函数库是很难的，并不只是写一大堆代码而已。一旦函
让性能分析器自动运行可能是一个好主意。它自动告诉程序员每个
所以，
人们在使用非常高级的语言（比如Lisp）时，经常抱怨很难知道哪
众所周知，好的编程语言生成的代码有较快的运行速度。但是实际
，编程时提高代码运行速度的关键是使用好的性能分析器
效 
率
---
## Page 233
务器能够支持的用户数量就成了软件业者的关键问题。互联网软件的资
许多有趣的应用程序都将是运行在服务器端的互联网软件，所以每台服
在变得越来越重要，那就是每个处理器能够同时支持的用户数量。未来
简洁、快速、格式化输出的函数，还有些措施则需要深层次的结构变化，
在这方面，编程语言也能起到作用，有些措施是显而易见的，比如采用
速度，而是受限于 IO 的速度。加快 IVO 速度将是很值得做的一件事。
随着互联网软件的兴起，越来越多的程序主要不是受限于计算机的运算
在瓶颈处内嵌字节码，这可能是一个不错的主意。然后，针对这部分字
成一项很有用的功能。让字节码成为语言的正式组成部分，允许程序员
这样做主要是为了让代码容易移植到不同的操作系统，但是这也可以变
浪费运算能力的好办法。
自己用处理器做了很多无用功，但是一直没有找到能够看出程序是怎样
成一个忙碌又悲惨的可怜虫，就像那些为政府跑腿的小人物。我总觉得
某种形式的内存访问是不合理算法的信号，我不会感到很惊讶。如果有
出现了问题。
我的工位没法看到仪表盘，但是只要我听到声音，就能立刻知道服务器
由微型马达驱动，每当马达旋转的时候，就会发出一阵轻微的噪音。在
板，上面有各种各样的仪表盘，用来显示服务器的状况。仪表盘的指针
发出声音，表示出现了问题。
动运行的性能分析器用图形实时显示程序运行时的内存状况，甚至可以
重要，因为服务器上有很多程序同时运行，它们都需要你密切关注。自
比如采用缓存和持久化对象（persistentobject)。
节码的优化也就变得可以移植了。
一个方法应该是设法显示正在运行的程序的情况，这对互联网软件尤其
一个小人儿可以钻进计算机看看我们的程序是怎么运行的，他可能会变
用户关心的是反应时间（response time），但是软件的另一种效率正
现在有一些语言先编译成字节码（byte code)，然后再由解释器执行。
性能分析器甚至有可能自动找出不合理的算法。如果将来有人发现
正如许多最终用户已经意识到的，运行速度的概念正在发生变化。