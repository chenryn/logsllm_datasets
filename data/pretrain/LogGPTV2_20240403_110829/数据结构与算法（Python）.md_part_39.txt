量。成员 dist 包含从起点到目的节点的最小权值路线的当前总权值。对于图中的每一个节点，算法均会
重复进行一次，但各顶点重复的先后顺序是由一个优先队列控制的，队列中决定顺序的参量是 dist 值。当
节点被创建时 dist 被设置成一个很大的数，虽然理论上说应该将其设为正无穷，但实际操作中我们只需要将
它设置成比实际问题中可能出现的任何距离都要大的值即可。
Dijkstra 算法的代码如表代码7.11所示。当算法结束时各个距离都被正确地设置成表中每
节点之间的前驱连接。
from pythonds.graphs import PriorityQueue, Graph, Vertex
def dijkstra(aGraph,start):
pq = PriorityQueue()
start.setDistance(0)
pq.buildHeap([(v.getDistance(),v) for v in aGraph])
while not pq.isEmpty():
currentVert = pq.delMin()
for nextVert in currentVert.getConnections():
newDist = currentVert.getDistance() \
+ currentVert.getWeight(nextVert)
if newDist < nextVert.getDistance():
nextVert.setDistance( newDist )
nextVert.setPred(currentVert)
pq.decreaseKey(nextVert,newDist)
代码7.11
Dijkstra 算法使用了优先队列，回忆一下，在学习树的时候我们曾经基于“堆”结构实现了优先
队列。简单的优先队列实现与Dijkstra算法中的优先队列实现有一些不同。首先，优先队列
PriorityQueue 类储存了键值对元组，这对于 Dijkstra 算法来说非常重要，因为优先队列中的 key 值
必须与图中节点的 key 值匹配，同时，键值对中的值用来决定优先级，也决定了 key 在优先队列中
的位置。在这种实现优先队列的方法中，我们把节点间的距 离作为优先级，因为我们都知道，在探
索下一个节点时，我们总是想要探索有最小距离的节 点。第二点不同之处是添加了 decreaseKey 方
法。正如你所看到的，当队列中已经存在了到 某个节点的距离，而这个距离减小的时候，这个节点
将被移到队首。
让我们沿着下面几张图片的顺序理解 Dijkstra 算法的一个应用实例。开始节点是 u， 与其相邻
的三个节点是 v，w 和 x。因为开始时到 v，w，x 的距离都被初始化成 sys.maxint， 从起始节点
到这三个节点的代价就是它们的直接代价，所以我们更新这三个节点的代价值。 同时，设置每个节
点的前驱节点为 u，并且把距离作为 key 值将每个节点都放进优先队列中。算法当前状态见图
7.49。
下一次 while 循环中我们考察与 x 相邻的节点。之所以先考察 x 是因为 x 的总代价最小，
因此被弹到优先队列的顶端。对于 x 节点，我们考察与它相邻的节点 u，v，w，和 y。对于 每一
个相邻的节点，我们要检查经由 x 节点的当前节点的距离是否小于已知的距离。明显可 以看出 y
满足条件，因为它的距离是 sys.maxint。节点 u，v 不满足条件，因为它们各自的 固有距离是 0 和
2。然而，我们现在可以知道，经由 x 到 w 的距离小于直接从 u 到 w 的距离。 因此需要更新 w
的距离值，并将 w 的前驱节点从 u 改为 x。算法当前状态见图 7.49。下一步是检查与 v 相邻的顶
点（见图 7.51）。这一步对于图本身无影响，所以我们转而检查节点 y。此时发现，对于 w 和 z
来说经由 y 代价更小，所以如上段所述调整其距离值和前驱节点（见图 7.52）。 最后检查节点 w
和节点 z（见图 7.52 和图 7.54），然而没有发现需要改变的地方，因此优先队列变为空的，
Dijkstra 算法结束。
图 7.49：追踪 Dijkstra 算法
图7.50：追踪 Dijkstra 算法
图7.51：追踪 Dijkstra 算法
图7.52：追踪 Dijkstra 算法
图 7.53：追踪 Dijkstra 算法
图7.54：追踪 Dijkstra 算法
十分重要的一点是，Dijkstra 算法只适用于所有权值都为正数的情况。如果在某条边引入了负
的权值，那么整个算法将陷入无限循环。
我们需要注意的是，为了在互联网上传递信息，其他的算法也被用来寻找最短路径。在 互联网问
题上使用 Dijkstra 算法的一个问题是你必须有完整的图结构，否则算法无法运行。这暗示着每个路
由器需要拥有互联网上所有路由器的完整地图。实际操作中这是不可能做到的，因此其他的算法允许
路由器在传递信息的过程中发现新的图结构。这种算法被称为“距离向量”路由算法。
7.11.2.DIJKSTRA 算法分析
最后，进行 Dijkstra 算法的时间复杂度分析。首先，由于我们最初把图中的每一个节点都加入了
优先队列，所以建立优先队列的时间复杂度为 O(V)。建立完队列之后，while 循环对于每个节点
都会执行一次。因为所有顶点在一开始就都被加入，并且仅当循环执行完 后才会被移出。循环体内部
delMin 操作的时间复杂度为 O（Vlog（V））。For 循环对于图中的每条边都会执行一次，在循环体内部
decreaseKey 操作的时间复杂度为 O（Elog（V））。 所以结合起来，总的时间复杂度为 O（（V+E）log
（V））。
7.12. PRIM 最小生成树算法
为了说明我们的最后一个图算法，让我们来考虑一个在线游戏设计者和无线电网络开发者面
对的问题。这个问题是，他们想要高效地传递信息给那些可能正在收听的人。这在游戏中非常重要，
它使每一名玩家都可以了解到其他玩家的实时位置。这在无线电网联络中也很重要，它使每一名接入
频道的听众可以得到他们需要的全部数据去重现他们正在收听的歌曲。图 7.55向我们阐明了这个广播
问题。
图 7.55：广播问题
关于这一问题有一些无脑的强制解决办法，所以让我们先来看一看这些解决办法来帮助我们更好
的理解广播问题。这也会在我们解决这一问题时让你更加欣赏我们给出的解决方法。在开始的时
候，广播主持有一些所有听众都需要接收的信息。最简单的解决方式是广播主持有一个所有听众的名
单然后向每一名听众逐一发送信息。在图7.55中我们展现了一个小的 网络包括一个广播和一些听众。
用第一种方式，每一段信息需要发送四次。假设使用的是最短路径，让我们来看看每一个路由器需要
处理多少次相同的信息。
每一段从广播发出的信息都经过了路由器 A，因此 A 看到了每一段信息的四次拷贝。路 由器 C 只看
到了面向它的听众的信息的一次拷贝。然而路由器 B 和 D 会看到每一条信息的三次拷贝因为路由器 B
和D 在通往听众 1,2,3 的最短路径上。当你考虑到播音主持每秒要发送上百条信息给一个收音机，这就
会成为一个巨大的额外负担。
一个无脑的强制解决办法是播音主持每份信息只发送一份然后让路由器来把它们分类。在这种情
形下，最简单的解决方式是一种叫做无控制流动的方法。这种方式根据安排工作。每段信息的开始时
间(ttl)值设置为大于或者等于播音主持到距他最远的收听者之间距离的一些数。每一个路由器复制一
份信息然后把信息传递给所有与它相邻的路由器。当信息传递 时 ttl 降低。每一个路由器持续地向与
它相邻的所有路由器传递信息拷贝，直到ttl 值变为 0。显然无控制流动的方法会比我们的第一种方
法产生更多的不必要的信息。
这种解决方式属于最小重量生成树的一种。形式上我们给图 G=(V,E)定义了如下的最小生成树 T。T
是一个连接 V中所有顶点的E的非循环子集。T中边界重量的和是最小化的。
图 7.56 展示了一个简化版的广播图并且着重突出了在图中形成最小生成树的边界。现在 为了
解决我们的广播问题，广播主持向网络中简要发送了一份播音信息的拷贝。每一个路由 器向作为生
成树一部分的任意相邻路由器发送信息，包括刚刚向它发送信息的相邻路由器。 在此问题中，A 向
B 发送信息，B 向 D 和 C 发送信息，D 向 E 发送信息，E 向 F 发送信息，F 向 G 发送信息。没
有路由器会重复接收同一份信息，并且所有对其感兴趣的听众都能够看到这一信息。一个连接 V 中所
有顶点的 E 的非循环子集。T 中边界重量的和是最小化的。
图 7 . 5 6 ：广播图的最小生成树
我们将要用来解决这一问题的算法叫做 Prim 算法。Prim 算法隶属于“贪心算法”一类，因
为每一步我们都会选择最简单的下一步。在这种情形下最简单的下一步将会沿着最低重量 的边
缘。
我们的最后一步是开发 Prim 算法。
最基本的想法是构建一个如下的生成树：
While T is not yet a spanning tree
Find an edge that is safe to add to the tree
Add the new edge to T
步骤中的窍门是指引我们去“找到一条安全的边界”。我们像定义任意边界那样定义安全边界，即连
接在生成树中的一个顶点和不在生成树中的一个顶点。这确保了这个树总会保 持一个树的形状而不会
产生循环。
执行 Prim 算法的 Python 代码在 代码12中展示。Prim 算法与 Diikstra 算法相似，因为他们
都用优先队列去选择下一个添加到图中的顶点。
from pythonds.graphs import PriorityQueue, Graph, Vertex
def prim(G,start):
pq = PriorityQueue()
for v in G:
v.setDistance(sys.maxsize)
v.setPred(None)
start.setDistance(0)
pq.buildHeap([(v.getDistance(),v) for v in G])
while not pq.isEmpty():
currentVert = pq.delMin()
for nextVert in currentVert.getConnections():
newCost = currentVert.getWeight(nextVert) \
+ currentVert.getDistance()
if nextVert in pq and newCost<nextVert.getDistance():
nextVert.setPred(currentVert)
nextVert.setDistance(newCost)
pq.decreaseKey(nextVert,newCost)
代码12
接下来的这些图（图 7.57到图7.63) 展示了算法在样品树上面的运行情况。我们将顶点 A 作为起始
点。到其他任意点的距离被初始化为无穷。看着 A 的相邻点我们可以更新顶点 B 和 C的两个距离，
因为 A 到 B 和 C 的距离小于无穷。这时 B 和 C 已到了优先队列的前端。更新之前 B 和 C 的连接通过将它们指
向 A。需要着重强调的是我们还没有将 B 和 C 添加到生成树中。一个点在没有被移出优先队列之前是不
会被添加到生成树中的。
既然B 有着最小距离，接下来我们来讨论B点。检查 B 的相邻顶点我们发现 D 和 E 可以被更新。D
和 E 都能够得到新的距离值并且他们的之前连接可以被更新。移至优先队列 的下一个点我们找到了 C。
优先队列中唯一与 C 相邻的点是 F，然后我们可以更新到 F 的距 离并且调整 F 在优先队列中的位置。
现在我们寻找点 D 的临近点。我们发现我们可以更新 E 并且将到 E 的距离从 6 减到 4。当我们这么做
时我们改变了从 E 指回 D 的连接，然后准备把它植入生成树的不同位置。剩下 的就是像你期待的那样，
算法开始，将每一个新的点加入树中。
图7.57：描绘 Prim 算法
图 7.58：描绘 Prim 算法
图7.59：描绘 Prim 算法
图7.60：描绘 Prim 算法
图7.61：描绘 Prim 算法
图7.62：描绘 Prim 算法
北京大学地球与空间科学学院/数据结构与算法/内部使用教材
图7.63：描绘 Prim 算法
7.13. 小结
本章我们学习了图抽象数据类型，以及若干实现方法。假如我们可以把一个原始问题转化成
可以被表示成图的事物，我们就可以用图来解决许多问题。特别地，我们发现图在以下领域可以解决
很多问题：
广度优先搜索算法 BFS，解决无权图的最短路径问题
 带权图的最短路径算法 Dijkstra 算法
 图的深度优先搜索算法
 用于简化图的强连通分支算法
 用于排序任务的拓扑排序算法
 用于广播消息的最小生成树算法
7.14 ．关键词
无圈图 邻接表 邻接矩阵
300
北京大学地球与空间科学学院/数据结构与算法/内部使用教材
邻近的 广度优先搜索 (BFS) 圈
有圈图 有向无圈图 深度优先森林
深度优先搜索 (DFS) 有向图 有向无圈图 (DAG)
有向图 边的权重 边
括号性质 路径 最短路径
生成树 强连通分支 (SCC) 拓扑排序 & 不受限洪水
顶点 权重t
7.15 问题讨论
1、画出与下图所示邻接矩阵对应的图。
2、画出与下图所示的表示边的表格中对应的图。
3、去掉权重，在上个问题的图中实现广度优先搜索。
4、buildGraph 函数的大 O 时间复杂度是多少。
5、导出拓扑排序算法的大 O 时间复杂度。
6、导出强连通分支算法的大 O 时间复杂度。
7、分步展示Dijkstra 算法在上面所示的图中的应用。
8、用 Prim 算法，找到上述图中的具有最小权重的生成树。
9、画出关系图来解释你发一封邮件所需的步骤。在你的图中执行一次拓扑排序。
10、导出表达骑士周游问题执行时间的指数的底的表达式。
11、解释为什么一般的深度优先搜索算法不适合解决骑士周游问题。
12、Prim 最小生成树算法的大 O 时间复杂度是多少。
7.16 编程练习
1. 修改深度优先搜索函数产生一个拓扑排序。
301
北京大学地球与空间科学学院/数据结构与算法/内部使用教材
2. 修改深度优先搜索生成强连通分支。
3. 写出图的transpose方法。
4. 使用广度优先搜索，写一个算法来确定从每个顶点到其他所有顶点的最短路径（最短路
径问题）。
5. 用广度优先搜索修改递归章节的迷宫程序，找到走出迷宫的最短路径。
6. 写一个程序来解决以下问题：你有两个罐子，一个是 4 加仑、另一个是 3 加仑。每个
罐子上都没有标记。有一个泵，可以用来为罐子满上水。你如何使用 4 加仑的水罐得到两加仑
的水？
7. 将上述问题一般化，你解决方案的参数包括每一个罐子的大小和最后留在较大罐子里的
水量。
8. 写一个程序来解决以下问题：三个传教士和三个食人族到河边，发现一艘船一次只能载
两人。每个人都要过河来继续旅程。然而，如果任意一边的岸上的食人族数量超过传教士，传
教士将被吃掉。找到使每个人都安全地到达河的另一边的所有路径。
302