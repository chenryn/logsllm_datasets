14 foreach v ∈ V(SDFlow) do
if isRegister(v) then continue
if ∀ vi ∈ I: v.time  512
Total
/bin
21
10
12
23
19
15
7
3
2
112
/sbin
22
33
17
17
22
8
2
2
2
125
/usr/bin
73
150
113
147
103
66
35
32
32
751
/usr/sbin
18
20
11
14
25
8
4
3
2
105
Total
134
213
153
201
169
97
48
40
38
1093
FA2 
b1 
FA1 
a1 
a2 
address 
G 
a1 
target flow 
V 
(a) 
t0 
R 
time 
t0 
G 
Attack 
a1 
FA2 
V 
ta 
tb 
(b) 
target  
flow 
R 
tc 
time 
successful data-oriented attacks since vertex addresses
are highly unpredictable. We develop two methods in
data-oriented attacks to address this challenge: stitch-
ing with deterministic addresses and stitching by address
reuse. Note that attackers can use others methods devel-
oped for control ﬂow attacks to bypass ASLR here, like
disclosure of random addresses [14, 35].
3.3.1 Stitching With Deterministic Addresses
When security-critical data is stored in deterministic
memory addresses, stitching data ﬂows of such data is
not affected by ASLR. Existing work [2, 34, 37] have
shown that current ASLR implementations leave a large
portion of program data in the deterministic memory
region. For example, Linux binaries are often com-
piled without the “-pie” option, resulting in deterministic
memory regions. We study deterministic memory size
of Ubuntu 12.04 (x86) binaries under directories /bin,
/sbin, /usr/bin and /usr/sbin, and show the re-
sults in Table 1. Among 1093 analyzed programs, more
than 87.74% have deterministic memory regions. Two
hundred and twenty-three programs have deterministic
memory regions larger than 64KB. Inside such memory
regions, there is many security-critical data, like random-
ized addresses in .got.plt and conﬁguration struc-
tures in .bss. Hence we believe stitch with determinis-
tic addresses in real-world programs is practical.
We build an information leakage attack against the
orzhttpd web server [5] (details in Section 6.4.3) us-
ing the stitch with deterministic addresses. To respond
to a page request, orzhttpd uses a pointer to retrieve
the HTTP protocol version string. The pointer is stored
in memory. If we replace the pointer value with the ad-
dress of a secret data, the server will send that secret to
the client. However this requires both the address of the
pointer and the address of the secret to be predictable.
In the orzhttpd example, we ﬁnd that the address of
the pointer is ﬁxed (0x8051164) and choose the con-
tents of the .got.plt section (allocated at a ﬁxed ad-
dress) as the secret to leak out. Figure 6 shows two 2D-
Figure 6:
Stitch with deterministic memory addresses of the
orzhttpd server. This attack is the similar to the one in Figure 4,
except the address of the source vertex and the pointer’s address of of
the target vertex are ﬁxed. This attack works with ASLR.
DFGs for the benign execution and the attack, respec-
tively. With this attack, the content of .got.plt is sent
to the attacker, which leads to an memory address disclo-
sure exploit useful for constructing second-stage control-
hijacking attacks or stealing secret data in randomized
memory region. Unlike a direct memory disclosure at-
tack, here we use the corruption of deterministically-
allocated data to leak randomized addresses.
Identifying Stitch with Deterministic Addresses. We
represent the deterministic memory region as a set D.
Our algorithm considers the intersection of D for the ver-
tices in the source ﬂow and the target ﬂow. The previ-
ously outlined stitching algorithms can then be used di-
rectly prioritizing the vertices in the intersection with D.
3.3.2 Stitching By Address Reuse
If the security-critical data only exists inside the random-
ized memory region, data-oriented attacks cannot use de-
terministic addresses. To bypass ASLR in such cases,
we leverage the observation that a lot of randomized ad-
dresses are stored in memory. If we can reuse such real-
time randomized addresses instead of providing concrete
address in the exploit, the generated data-oriented attacks
will be stable (agnostic to address randomization). There
are two types of address reuse: partial address reuse and
complete address reuse.
Partial Address Reuse. A variable’s relative address,
with respect to the module base address or with respect
to another variable in the same module, is usually ﬁxed.
Attackers can easily calculate such relative addresses in
advance. On the other hand, instructions commonly get
a memory address with one base address and one rela-
tive offset (e.g., array access, switch table).
If attack-
ers control the offset variable, they can corrupt the offset
with the pre-computed relative address from the selected
vertex (source vertex or target vertex) and reuse the ran-
domized base address. In this way attackers can access
184  24th USENIX Security Symposium 
USENIX Association
8
1 struct user_details { uid_t uid; ... } ud;
2 ...
//run with root uid
3 ud.uid = getuid(); //in get_user_info()
4 ...
5 vfprintf(...);
6 ...
7 setuid(ud.uid);
8 ...
//in sudo_askpass()
//in sudo_debug()
Code 3: Code snippet of sudo, setting uid to normal user id.
the intended data without knowing their randomized ad-
dresses. We show an example of a vulnerable instruction
pattern, that allows the attacker partial ability to read a
value from memory and write it out without knowing
randomized addresses. If attackers control %eax, they
can reuse the source base address %esi in the ﬁrst in-
struction, and reuse the destination base address %edi
in the second instruction. In fact, any memory access in-
struction with a corrupted offset can be used to mount
partial address reuse attack.
1 //attackers control %eax
2 mov
(%esi,%eax,4), %ebx
3 mov
%ecx, (%edi,%eax,4)
//reuse %esi
//reuse %edi
Complete Address Reuse. We observe that a variable’s
address is frequently saved in memory due to the limi-
tation of CPU registers. If the memory error allows re-
trieving such spilled memory address for reading or writ-
ing, attackers can reuse the randomized vertex address
existing in memory to bypass ASLR. For example, in
the following assembly code, if attacker controls %eax
on line 1, it can load a randomized address into %ebx
from memory. Then, attacker can access the target ver-
tex pointed by %ebx without knowing the concrete ran-
domized address. The attacker merely needs to know the
right offset value to use in %eax on line 2, or may have
a deterministic %esi value to gain arbitrary control over
addresses loaded on line 2.
1 //attacker controls %eax
2 mov
3 mov
(%esi, %eax, 4), %ebx
%ecx, (%ebx) /mov
(%ebx), %ecx
Let us consider a real example of the sudo pro-
gram [9] that shows how to use such instruction patterns
that permit complete address reuse meaningfully. Code 3
shows the related code of sudo, where a format string
vulnerable exists in the sudo debug function (line 5).
At the time of executing vfprintf() on line 5, the
address of the user identity variable (ud.uid) exists on
the stack. The vfprintf() function with format string
“%X$n” uses the Xth argument on stack for “%n”. By
specifying the value of X, vfprintf() can retrieve the
address of ud.uid from its ancestor’s stack frame and
change the ud.uid to the root user ID without knowing
address 
&arg 
&ud.uid 
0 
100 
3 
address 
stack  
area  
100 
7 
time 
0 
(a) 
&ud.uid 
… ….  