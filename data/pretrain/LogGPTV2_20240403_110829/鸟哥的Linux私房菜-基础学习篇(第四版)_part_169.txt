Loaded: loaded （/usr/lib/systemd/system/cups.service; enabled）
Active: inactive （dead） since Tue 2015-08-11 19:19:20 CST; 3h 29min ago
# 有趣得很！竟然是 enable 但是却是 inactive 耶！相当特别！
# 2. 那就直接关闭，同时确认没有启动喔！
[root@study ~]# systemctl stop cups.service
[root@study ~]# systemctl disable cups.service
rm '/etc/systemd/system/multi-user.target.wants/cups.path'
rm '/etc/systemd/system/sockets.target.wants/cups.socket'
rm '/etc/systemd/system/printer.target.wants/cups.service'
# 也是非常特别！竟然一口气取消掉三个链接文件！也就是说，这三个文件可能是有相依性的问题喔！
[root@study ~]# netstat -tlunp | grep cups
# 现在应该不会出现任何数据！因为根本没有 cups 的任务在执行当中～所以不会有 port 产生
# 3. 尝试启动 cups.socket 监听用户端的需求喔！
[root@study ~]# systemctl start cups.socket
[root@study ~]# systemctl status cups.service cups.socket cups.path
cups.service - CUPS Printing Service
Loaded: loaded （/usr/lib/systemd/system/cups.service; disabled）
Active: inactive （（dead）） since Tue 2015-08-11 22:57:50 CST; 3min 41s ago
cups.socket - CUPS Printing Service Sockets
Loaded: loaded （/usr/lib/systemd/system/cups.socket; disabled）
Active: active （（listening）） since Tue 2015-08-11 22:56:14 CST; 5min ago
cups.path - CUPS Printer Service Spool
Loaded: loaded （/usr/lib/systemd/system/cups.path; disabled）
Active: inactive （（dead））
# 确定仅有 cups.socket 在启动，其他的并没有启动的状态！
# 4. 尝试使用 lp 这个指令来打印看看？
[root@study ~]# echo "testing" | lp
lp: Error - no default destination available. # 实际上就是没有打印机！所以有错误也没关系！
[root@study ~]# systemctl status cups.service
cups.service - CUPS Printing Service
Loaded: loaded （/usr/lib/systemd/system/cups.service; disabled）
Active: active （（running）） since Tue 2015-08-11 23:03:18 CST; 34s ago
[root@study ~]# netstat -tlunp | grep cups
tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN 25881/cupsd
tcp6 0 0 ::1:631 :::* LISTEN 25881/cupsd
# 见鬼！竟然 cups 自动被启动了！明明我们都没有驱动他啊！怎么回事啊？
上面这个范例的练习在让您了解一下，很多服务彼此之间是有相依性的！cups 是一种打印服务，这个打印服务会启用 port 631 来提供
网络打印机的打印功能。 但是其实我们无须一直启动 631 端口吧？因此，多了一个名为 cups.socket 的服务，这个服务可以在“用户有需要打
印时，才会主动唤醒 cups.service ”的意思！ 因此，如果你仅是 disable/stop cups.service 而忘记了其他两个服务的话，那么当有用户向其他两
个 cups.path, cups.socket 提出要求时， cups.service 就会被唤醒！所以，你关掉也没用！
强强迫迫服服务务注注销销 （（mask）） 的的练练习习
比较正规的作法是，要关闭 cups.service 时，连同其他两个会唤醒 service 的 cups.socket 与 cups.path 通通关闭，那就没事了！ 比较不
正规的作法是，那就强迫 cups.service 注销吧！通过 mask 的方式来将这个服务注销看看！
# 1. 保持刚刚的状态，关闭 cups.service，启动 cups.socket，然后注销 cups.servcie
[root@study ~]# systemctl stop cups.service
[root@study ~]# systemctl mask cups.service
ln -s '/dev/null' '/etc/systemd/system/cups.service'
# 喔耶～其实这个 mask 注销的动作，只是让启动的脚本变成空的设备而已！
[root@study ~]# systemctl status cups.service
cups.service
Loaded: masked （（/dev/null））
Active: inactive （dead） since Tue 2015-08-11 23:14:16 CST; 52s ago
[root@study ~]# systemctl start cups.service
Failed to issue method call: Unit cups.service is masked. # 再也无法唤醒！
上面的范例你可以仔细推敲一下～原来整个启动的脚本配置文件被链接到 /dev/null 这个空设备～因此，无论如何你是再也无法启动这个
cups.service 了！ 通过这个 mask 功能，你就可以不必管其他相依服务可能会启动到这个想要关闭的服务了！虽然是非正规，不过很有效！
^_^
那如何取消注销呢？当然就是 unmask 即可啊！
[root@study ~]# systemctl unmask cups.service
rm '/etc/systemd/system/cups.service'
[root@study ~]# systemctl status cups.service
cups.service - CUPS Printing Service
Loaded: loaded （/usr/lib/systemd/system/cups.service; disabled）
Active: inactive （dead） since Tue 2015-08-11 23:14:16 CST; 4min 35s ago
# 好佳在有恢复正常！
上一小节谈到的是单一服务的启动/关闭/观察，以及相依服务要注销的功能。那系统上面有多少的服务存在呢？这个时候就得要通过 list-
units 及 list-unit-files 来观察了！ 细部的用法如下：
[root@study ~]# systemctl [command] [--type=TYPE] [--all]
command:
list-units ：依据 unit 列出目前有启动的 unit。若加上 --all 才会列出没启动的。
list-unit-files ：依据 /usr/lib/systemd/system/ 内的文件，将所有文件列表说明。
--type=TYPE：就是之前提到的 unit type，主要有 service, socket, target 等
范例一：列出系统上面有启动的 unit
[root@study ~]# systemctl
UNIT LOAD ACTIVE SUB DESCRIPTION
proc-sys-fs-binfmt_mis... loaded active waiting Arbitrary Executable File Formats File System
sys-devices-pc...:0:1:... loaded active plugged QEMU_HARDDISK
sys-devices-pc...0:1-0... loaded active plugged QEMU_HARDDISK
sys-devices-pc...0:0-1... loaded active plugged QEMU_DVD-ROM
.....（中间省略）.....
vsftpd.service loaded active running Vsftpd ftp daemon
.....（中间省略）.....
cups.socket loaded failed failed CUPS Printing Service Sockets
.....（中间省略）.....
LOAD = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB = The low-level unit activation state, values depend on unit type.
141 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.
# 列出的项目中，主要的意义是：
# UNIT ：项目的名称，包括各个 unit 的类别 （看扩展名）
# LOAD ：开机时是否会被载入，默认 systemctl 显示的是有载入的项目而已喔！
# ACTIVE ：目前的状态，须与后续的 SUB 搭配！就是我们用 systemctl status 观察时，active 的项目！
# DESCRIPTION ：详细描述啰
# cups 比较有趣，因为刚刚被我们玩过，所以 ACTIVE 竟然是 failed 的喔！被玩死了！ ^_^
# 另外，systemctl 都不加参数，其实默认就是 list-units 的意思！
范例二：列出所有已经安装的 unit 有哪些？
[root@study ~]# systemctl list-unit-files
UNIT FILE STATE
proc-sys-fs-binfmt_misc.automount static
dev-hugepages.mount static
dev-mqueue.mount static
proc-fs-nfsd.mount static
.....（中间省略）.....
systemd-tmpfiles-clean.timer static
336 unit files listed.
使用 systemctl list-unit-files 会将系统上所有的服务通通列出来～而不像 list-units 仅以 unit 分类作大致的说明。 至于 STATE 状态就是前
两个小节谈到的开机是否会载入的那个状态项目啰！主要有 enabled / disabled / mask / static 等等。
假设我不想要知道这么多的 unit 项目，我只想要知道 service 这种类别的 daemon 而已，而且不论是否已经启动，通通要列出来！ 那该
如何是好？
[root@study ~]# systemctl list-units --type=service --all
# 只剩下 *.service 的项目才会出现喔！
范例一：查询系统上是否有以 cpu 为名的服务？
[root@study ~]# systemctl list-units --type=service --all | grep cpu
cpupower.service loaded inactive dead Configure CPU power related settings
# 确实有喔！可以改变 CPU 电源管理机制的服务哩！
通过上个小节我们知道系统上所有的 systemd 的 unit 观察的方式，那么可否列出跟操作界面比较有关的 target 项目呢？ 很简单啊！就
这样搞一下：
[root@study ~]# systemctl list-units --type=target --all
UNIT LOAD ACTIVE SUB DESCRIPTION
basic.target loaded active active Basic System
cryptsetup.target loaded active active Encrypted Volumes
emergency.target loaded inactive dead Emergency Mode
final.target loaded inactive dead Final Step
getty.target loaded active active Login Prompts
graphical.target loaded active active Graphical Interface
local-fs-pre.target loaded active active Local File Systems （Pre）
local-fs.target loaded active active Local File Systems
multi-user.target loaded active active Multi-User System
network-online.target loaded inactive dead Network is Online
network.target loaded active active Network
nss-user-lookup.target loaded inactive dead User and Group Name Lookups