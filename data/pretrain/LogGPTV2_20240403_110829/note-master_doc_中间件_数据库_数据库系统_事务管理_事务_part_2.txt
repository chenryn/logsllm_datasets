不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。
## 事务隔离性级别
不同的级别吞吐量及资源利用率、等待时间等都不同 其中串行化是最差的 读未提交是最好的
从上往下，隔离级别递减
- 可串行化 SERIALIZABLE
  - 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题 实际使用中会导致大量超时和锁争用
每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。如果需要在单线程执行的事务中访问，系统就会变得非常慢
- 可重复读 REPEATABLE-READ
  - 保证在同一个事务中多次读取同一数据的结果是一样的
- 已提交读 READ-COMMITTED
  - 一个事务只能读取已经提交的事务所做的修改
数据库通过使用行锁（row-level lock） 来防止脏写。但想要防止脏读使用读锁就8太行了，大多数数据库都选择维护新旧两个值，事务提交之前读取的都是旧值，只有提交了才能读到新值
- 未提交读 READ-UNCOMMITTED
  - 事务中的修改，即使没有提交，对其它事务也是可见的
隔离级别             | 脏读 | 不可重复读 | 幻读 | 加锁读
---------------- | -- | ----- | -- | ---
READ-UNCOMMITTED | √  | √     | √  | ×
READ-COMMITTED   | ×  | √     | √  | ×
REPEATABLE-READ  | ×  | ×     | √  | ×
SERIALIZABLE     | ×  | ×     | ×  | √
降低隔离级别可以提升性能，如果应用层对短暂的不一致无感，也是可以接受的
无论是脏读 幻读 不可重复读，原因都是因为隔离性被破坏 实现上面各种隔离级别都是使用读锁 写锁 或者范围锁相互配合来实现的
MVCC是一种读取优化策略，它的“无锁”是特指读取时不需要加锁。MVCC的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的
## 并发控制
### 锁
为了避免事务一直获取不到锁饿死，在进行锁授予的时候应该是公平的，先来先得
#### 锁粒度
锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高
封锁粒度越小，系统开销就越大
#### 锁类型
##### 读写锁
- 共享锁：简写为S锁，可读不可写
- 排它锁：简写为X锁，可读可写
加了排它锁的数据，就只能允许加锁的事务进行读写
加了共享锁的数据，允许其他事务对其再加共享锁进行读，但不允许再加排它锁
##### 意向锁
意向锁在读写锁的基础上，增加了IX（表的排它锁）与IS（表的共享锁）
- 当一个事务要对数据加S锁之前，就必须获得IS锁或者IX锁
- 当一个事务要对数据加X锁之前，必须获得IX锁
#### 死锁
此处可以参考操作系统中的[死锁处理](/操作系统/死锁.md#处理死锁的策略)
##### 死锁预防
- 对加锁请求进行排序，使得获取相同的锁的顺序是一致的
- 有可能导致死锁时，对部分事务回滚 从而打破死锁环
- 锁超时，事务至多等待一段给定的时间。若在此期间内未授予该事务锁，则称该事务超时
##### 死锁检测与恢复
通过等待图来描述锁之间的关系，如果发现有环，那就是出现死锁了
要从死锁中恢复的手段需要考虑的：
1. 选择牺牲的事务：这点基于代价考量，牺牲哪个事务付出的代价最小
2. 回滚：选择好要牺牲的事务，要决定回滚多远，是全部回滚，还是回滚到产生死锁之前的状态
3. 避免饿死：为了避免同一个事务总是被选中牺牲，常用的方案是一个事务被回滚次数的越多，那下次被选中的概率越小
#### 封锁协议
规定事务何时对数据项们进行加锁、解锁
##### 三级封锁协议
- 一级封锁协议
事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁
```mermaid
stateDiagram-v2
  T1 --> T1获取A的X锁
  T1获取A的X锁 --> T1修改A
  T1修改A --> T1提交
  T1提交 --> T1释放A的X锁
  T2 --> T2等待0
  T2等待0 --> T2获取A的S锁
  T2获取A的S锁 --> T2等待1
  T2等待1 --> T2等待2
  T2等待2 --> T2获取锁成功
  T2获取锁成功 --> T2读取A
  T2读取A --> T2释放A的S锁
```
- 二级封锁协议
在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁
```mermaid
stateDiagram-v2
  T1 --> T1获取A的X锁
  T1获取A的X锁 --> T1读A
  T1读A --> T1写A
  T1写A --> T1回滚
  T1回滚 --> T1释放A的X锁
  T2 --> T2等待0
  T2等待0 --> T2获取A的S锁
  T2获取A的S锁 --> T2等待1
  T2等待1 --> T2等待2
  T2等待2 --> T2等待3
  T2等待3 --> T2获取锁成功
  T2获取锁成功 --> T2读A
  T2读A --> T2释放A的S锁
```
- 三级封锁协议
在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁
```mermaid
stateDiagram-v2
  T1 --> T1获取A的S锁
  T1获取A的S锁 --> T1读A
  T1读A --> T1释放A的S锁
  T2 --> T2等待0
  T2等待0 --> T2获取A的X锁
  T2获取A的X锁 --> T2等待1
  T2等待1 --> T2获取锁成功
  T2获取锁成功 --> T2写A
  T2写A --> T2提交
  T2提交 --> T2释放A的X锁
```
##### 树形封锁协议
通过将数据项描述为树的节点，想要获取数据项的锁，那就必须先获取到该数据项父节点的锁，使用这种协议不会产生死锁
```mermaid
stateDiagram-v2
  根 --> 数据项1的锁
  数据项1的锁 --> 数据项3的锁
  根 --> 数据项2的锁
```
##### 两阶段封锁协议
加锁和解锁分为两个阶段进行
- 增长阶段：可以获得锁，不能释放锁
- 缩减阶段：可以释放锁，不能获得锁
锁升级只能发生在增长阶段，而锁降级只能发生在缩减阶段
严格两阶段封锁协议：要求所有排它锁在事务提交之后可以释放
强两阶段封锁协议：事务提交之前不得释放任何锁
MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定
锁的类型：
- 读写锁
- 谓词锁：锁住满足某些条件的数据
- 索引区间锁：使用起始索引跟结束索引代表这区间数据都被锁住了
实现：
锁管理器通过一个锁表来表示数据项被哪些事务的什么锁锁着，加锁与解锁就代表着增加与删除一个链表项
![锁表](/assets/20230419203700.png)
##### 多粒度封锁协议
通过将数据项划分为各个层次的锁，如表锁、行锁等来，粗粒度的锁覆盖细粒度的锁，增强了并发性
### 基于时间戳的协议
为每个事务分配一个唯一的时间戳，时间戳决定了事务的执行顺序
当一个事务执行读写操作时，它会检查所有已经对该数据项进行读写操作的事务的时间戳，如果有任何一个操作的时间戳晚于该事务的时间戳，则该事务必须等待
时间戳排序协议保证冲突可串行化，而且可以保证无死锁，因为事务不需要等待