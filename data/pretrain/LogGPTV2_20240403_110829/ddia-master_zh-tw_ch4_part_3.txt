![](../img/fig4-2.png)
**图 4-2 使用 Thrift 二进位制协议编码的记录**
[^iii]: 实际上，Thrift 有三种二进位制协议：BinaryProtocol、CompactProtocol 和 DenseProtocol，尽管 DenseProtocol 只支援 C ++ 实现，所以不算作跨语言【18】。除此之外，它还有两种不同的基于 JSON 的编码格式【19】。真逗！
与 [图 4-1](Img/fig4-1.png) 类似，每个栏位都有一个型别注释（用于指示它是一个字串、整数、列表等），还可以根据需要指定长度（字串的长度，列表中的专案数） 。出现在资料中的字串 `(“Martin”, “daydreaming”, “hacking”)` 也被编码为 ASCII（或者说，UTF-8），与之前类似。
与 [图 4-1](../img/fig4-1.png) 相比，最大的区别是没有栏位名 `(userName, favoriteNumber, interests)`。相反，编码资料包含栏位标签，它们是数字 `(1, 2 和 3)`。这些是模式定义中出现的数字。栏位标记就像栏位的别名 - 它们是说我们正在谈论的栏位的一种紧凑的方式，而不必拼出栏位名称。
Thrift CompactProtocol 编码在语义上等同于 BinaryProtocol，但是如 [图 4-3](../img/fig4-3.png) 所示，它只将相同的资讯打包成只有 34 个位元组。它透过将栏位型别和标签号打包到单个位元组中，并使用可变长度整数来实现。数字 1337 不是使用全部八个位元组，而是用两个位元组编码，每个位元组的最高位用来指示是否还有更多的位元组。这意味著 - 64 到 63 之间的数字被编码为一个位元组，-8192 和 8191 之间的数字以两个位元组编码，等等。较大的数字使用更多的位元组。
![](../img/fig4-3.png)
**图 4-3 使用 Thrift 压缩协议编码的记录**
最后，Protocol Buffers（只有一种二进位制编码格式）对相同的资料进行编码，如 [图 4-4](../img/fig4-4.png) 所示。它的打包方式稍有不同，但与 Thrift 的 CompactProtocol 非常相似。Protobuf 将同样的记录塞进了 33 个位元组中。
![](../img/fig4-4.png)
**图 4-4 使用 Protobuf 编码的记录**
需要注意的一个细节：在前面所示的模式中，每个栏位被标记为必需或可选，但是这对栏位如何编码没有任何影响（二进位制资料中没有任何栏位指示某栏位是否必须）。区别在于，如果栏位设定为 `required`，但未设定该栏位，则所需的执行时检查将失败，这对于捕获错误非常有用。
#### 栏位标签和模式演变
我们之前说过，模式不可避免地需要随著时间而改变。我们称之为模式演变。Thrift 和 Protocol Buffers 如何处理模式更改，同时保持向后相容性？
从示例中可以看出，编码的记录就是其编码栏位的拼接。每个栏位由其标签号码（样本模式中的数字 1,2,3）标识，并用资料型别（例如字串或整数）注释。如果没有设定栏位值，则简单地从编码记录中省略。从中可以看到，栏位标记对编码资料的含义至关重要。你可以更改架构中栏位的名称，因为编码的资料永远不会引用栏位名称，但不能更改栏位的标记，因为这会使所有现有的编码资料无效。
你可以新增新的栏位到架构，只要你给每个栏位一个新的标签号码。如果旧的程式码（不知道你新增的新的标签号码）试图读取新程式码写入的资料，包括一个新的栏位，其标签号码不能识别，它可以简单地忽略该栏位。资料型别注释允许解析器确定需要跳过的位元组数。这保持了向前相容性：旧程式码可以读取由新程式码编写的记录。
向后相容性呢？只要每个栏位都有一个唯一的标签号码，新的程式码总是可以读取旧的资料，因为标签号码仍然具有相同的含义。唯一的细节是，如果你新增一个新的栏位，你不能设定为必需。如果你要新增一个栏位并将其设定为必需，那么如果新程式码读取旧程式码写入的资料，则该检查将失败，因为旧程式码不会写入你新增的新栏位。因此，为了保持向后相容性，在模式的初始部署之后 **新增的每个栏位必须是可选的或具有预设值**。
删除一个栏位就像新增一个栏位，只是这回要考虑的是向前相容性。这意味著你只能删除可选的栏位（必需栏位永远不能删除），而且你不能再次使用相同的标签号码（因为你可能仍然有资料写在包含旧标签号码的地方，而该栏位必须被新程式码忽略）。
#### 资料型别和模式演变
如何改变栏位的资料型别？这也许是可能的 —— 详细资讯请查阅相关的文件 —— 但是有一个风险，值将失去精度或被截断。例如，假设你将一个 32 位的整数变成一个 64 位的整数。新程式码可以轻松读取旧程式码写入的资料，因为解析器可以用零填充任何缺失的位。但是，如果旧程式码读取由新程式码写入的资料，则旧程式码仍使用 32 位变数来储存该值。如果解码的 64 位值不适合 32 位，则它将被截断。
Protobuf 的一个奇怪的细节是，它没有列表或阵列资料型别，而是有一个栏位的重复标记（`repeated`，这是除必需和可选之外的第三个选项）。如 [图 4-4](../img/fig4-4.png) 所示，重复栏位的编码正如它所说的那样：同一个栏位标记只是简单地出现在记录中。这具有很好的效果，可以将可选（单值）栏位更改为重复（多值）栏位。读取旧资料的新程式码会看到一个包含零个或一个元素的列表（取决于该栏位是否存在）。读取新资料的旧程式码只能看到列表的最后一个元素。
Thrift 有一个专用的列表资料型别，它使用列表元素的资料型别进行引数化。这不允许 Protocol Buffers 所做的从单值到多值的演变，但是它具有支援巢状列表的优点。
### Avro
Apache Avro 【20】是另一种二进位制编码格式，与 Protocol Buffers 和 Thrift 有著有趣的不同。它是作为 Hadoop 的一个子专案在 2009 年开始的，因为 Thrift 不适合 Hadoop 的用例【21】。
Avro 也使用模式来指定正在编码的资料的结构。它有两种模式语言：一种（Avro IDL）用于人工编辑，一种（基于 JSON）更易于机器读取。
我们用 Avro IDL 编写的示例模式可能如下所示：
```c
record Person {
    string                userName;
    union { null, long }  favoriteNumber = null;
    array         interests;
}
```
等价的 JSON 表示：
```json
{
    "type": "record",
    "name": "Person",
    "fields": [
        {"name": "userName", "type": "string"},
        {"name": "favoriteNumber", "type": ["null", "long"], "default": null},
        {"name": "interests", "type": {"type": "array", "items": "string"}}
    ]