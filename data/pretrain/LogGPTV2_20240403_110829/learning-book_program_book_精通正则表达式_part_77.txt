匹配一组嵌套的括号
MatchingaSetofNestedParentheses
上文已经介绍过如何匹配包含规范配对括号的行，这里我会介绍匹配对称括号的办法（其
中可能包含更多的嵌套括号）：\（（？：[^（）】++1（?R））*\）。
这个表达式的组成部分与之前的一样，但是顺序安排略有不同。同样，如果你希望把它当
作大的正则表达式的一部分，应该把它包括在捕获型括号中，并且修改（?R）来递归地引
用对应的自表达式，例如（？1）：（必须使用这组捕获型括号对应的编号）。
效率
PHP Efficiency Issues
PHP的preg程序使用的PCRE是经过优化的NFA正则引擎，所以第4到6章介绍的许多技
巧都可以直接应用。其中包括对关键部分进行性能测试，根据实际数据而不是从理论分析
来比较程序的快慢。第6章给出了PHP的性能测试的例子（234）。
如果程序对时间要求很严格，请记住两点，回调函数通常要比模式修饰符。更快（?465），
在太长的目标字符串中使用命名捕获必须进行更多的数据拷贝。
程序运行中，遇到正则表达式会编译，但是PHP有一个容量高达4096个正则表达式的大
型缓存（242），所以实际上，特殊的patterm字符串只需要在第一次遇到的时候编译。
模式修饰符S值得单独介绍：它会“研究（study)”-个正则表达式，试图进行更快的匹配（它
与Perl的study函数不相关，Perl的study函数研究的是目标字符串，而不是正则表达式
359)。
模式修饰符S：“研究”
TheSPattern Modifier:“Study”
使用模式修饰符S告诉正则引擎，在应用这个正则表达式之前，花一点时间（注5）来研究，
希望这些多花的时间是值得的。但是，也可能这样做之后也不会提升速度，但是某些情况
下，速度的提升是与数据规模相关的。
现在有良好的标准来判断哪种情况下此功能具有价值：它是第6章所说的开头字符组识别
优化（247）的增强。
注5：确实只是一点时间。对于一般的CPU，非常长非常复杂的正则表达式，使用模式修饰符8
只需要多花百分之一到千分之一秒的时间。
---
## Page 505
效率
479
首先要告诉你的是，除非你希望对大规模的文本应用某个正则表达式，否则不太可能节省
多少时间。只有把同一个表达式应用到大规模的文本，或者大量小规模文本时，才需要考
虑模式修饰符S。
不使用模式修饰符S，标准优化
来看个简单的例子1|比对
]
&<>
\r?\n\r?\n
rn
---
## Page 506
480
第10章：PHP
模式修饰符S没有用处的场合
想想在哪些情况下模式修饰符S没有用会很有其法：
开头有锚点的表达式（例如和bi)，或者一个锚点紧跟全局性多选分支。这限于当
前的实现，b的限制，理论上在未来的某些版本中可以去掉。
能够匹配空字符的表达式，例如S*。
表达式可以从任何字符开始匹配（或者是绝大多数字符），例如（？：[^（）]++1\（（？R）
））*，请参考第475页的例子。这个表达式能够从除）’之外的任何字符开始匹
配，所以预先检查一遍几乎不会去掉任何开始的位置。
开头字符只有一种可能的表达式，因为它们已经进行了优化。
使用建议
使用模式修饰符S之后，preg引擎花在预分析上的时间并不会太长，所以如果你希望对大
量的文本应用正则表达式，无妨使用它。如果你觉得有机会使用，潜在的可能就值得尝试。
扩展示例
Extended Examples
用这两个例子作为本章的结束。
用PHP解析CSV
CSV Parsing with PHP
这里有一个用PHP解析CSV（逗号分隔值）的程序，原来的例子在第6章（271）。这个
正则表达式使用了占有优先量词（142），而不是固化分组括号，因为它们看起来更清晰。
首先，这是我们将要使用的正则表达式：
$csv_regex ='{
\G(？: ~1, )
( ? :
#或者是双引号字段.·
“#起始双引号
（["]*+（？："[^"]*+）*+）
“#结束双引号
#...或者是...
#...非双引号/适号文本...
（["，]*+）
}x' ;
---
## Page 507
扩展示例
481
然后，我们用它来解析SCSV文件中的一行：
/*应用正则表达式，填充Sall_matches*/
preg_match_all(Scsv_regex, $line, $all_matches);
/*SResult用来保存从Sall_matches收集的数据*/
SResult = array （）;
/*遍历每个成功的匹配...*/
for （$i =0;$i 0)
array_push($Result, Sall_matches [2][$i]) ;
else
/*否则为引用字段、在使用前处理其中内嵌的相连双引号*/
array_push($Result, preg_replace(′/**/','*', $all_matches[1][$i]));
/*现在可以使用sResult数组*/
检查taggeddata的嵌套正确性
Chrking Tagged Data for Proper Nesting
这个例子有点复杂，它用到了许多有意思的知识：检查XML（或者是XHTML，或者任何
标记的数据）是否包含孤立的或者错误匹配的标签。我的办法是检查正确匹配的tag，非tag
素tag”），希望我能找到整个字符串。
下面是完整的正则表达式：
1s（+（1++[<>}1(）2）+[2））
这可能相当复杂，但是如果分解为各个部分，就可以掌握了。外层的（)S：包围表达式
的主体，保证在返回success之前匹配整个目标字符串。主体包含在一组捕获型括号之内，
正则表达式的主体
正则表达式的主体，就是这三个多选分支（在正则表达式中的下画线标注，以便观察），它
们包含在（？：）*+中，容许任意的混合都能匹配。这三个多选分支匹配的分别是：tags、
非tag文本，以及自封闭tag。
---
## Page 508
482
第10章：PHP
因为每个多选分支能够匹配的文本之间是没有冲突的（也就是说，如果一个多选分支能够
匹配，另两个就不能匹配），我知道稍后的回溯永远不会容许另一个多选分支匹配同样的文
本。利用这一点，我们可以使用占有优先的星号，提高“容许任何混合”括号的匹配效率。
它告诉正则引擎，不要徒劳地回溯，如果找不到匹配，就很快出结果。
因为同样的原因，三个多选分支可以以任何顺序出现，我把最可能匹配的多选分支放在最
前面（260)。
现在逐个看这些多选分支：
第2个多选分支非tag文本我从它开始讲，因为[^<>]++很简单。这个多选分支匹配非
tag文本。在这里使用占有优先量词可能有点多此一举一外面的（？：)*+）也是占有优
先的，但是为了安全起见，我希望在我知道不会带来负面影响的地方使用占有优先量词。（通
常使用占有优先量词是为了提高效率，但是它也会改变匹配的语意。这种修改可能有帮助，
不过你必须清楚它的后果259）。
第3个多选分支自封闭tag第3个多选分支]*+/>匹配自封闭tag，例如和
（自封闭tag在后面的尖括号之前有反斜线）。与之前一样，占有优先量词可能有
点多余，但它肯定不会带来负面影响。
第1个多选分支一对匹配的tags。最后我们来看第1个多选分支：]*+（?
(?1))
这个子表达式的第一部分（以下画线标注）匹配开头的tag，用（\w++），也就是整个正则
表达式的第2组捕获型括号（在W++中使用占有优先量词是很重要的，我们将会看到）
匹配tag名称。
(?之前，确保没有匹配自封闭tag，例如（我们已经看到，自封闭的tag
由第3个多选分支处理）。
在开头tag匹配之后，（?1）会递归地应用到第一组捕获型括号内的子表达式。它是之前提
到的“主体”，也就是一块只包含对称tag的文本。它匹配之后应该匹配对应的结尾tag（closing
tag），就是这个多选分支的第一部分匹配的（tag的名字捕获到第二组捕获型括号）。
---
## Page 509
扩展示例
483
如果是检查HTML或者其他tag名不区分大小写的数据，请在正则表达式之前添加（?i），
或者使用模式修饰符i。
完成了！
占有优先量词
关于第1个多选分支]*+（?中的\w++i的占有优先，我希望多说几句。
如果流派的功能不够强大，不能使用占有优先量词或者固化分组（139），我会在这个多
选分支的（\w+）之后加上\b：“]*(?l。
\b很重要，它能够停止（\w+）的匹配，例如，‘…’中第一个“1i’的匹配。
这样会将‘rk’单独留在捕获型括号外面，导致后面的反向引用2引l用的tag名不完整。
正常情况下这些都不会发生，因为\w+是匹配优先的，会匹配整个tag名。不过，如果正则
表达式应用到嵌套结构糟糕的文本中，它应该匹配失败，搜索中的回溯会强迫“w+匹配不
完整的tag名，例如‘"’。bi能解决这个问题。
谢天谢地，PHP的强大的preg引擎支持占有优先量词，使用"（\w++）与附加bi的意义一
样：不容许回溯切割tag名，但是效率更高。
真实世界的XML
真实世界的XML比简单的匹配tag要复杂得多。我们还必须考虑XML注释、CDATA部分、
处理指令和其他。
添加对XML注释的支持是很容易的，只需要增加第4个多选分支，，请务必
使用（?s）或者是模式修饰符S，这样点号能够匹配换行符。
同样，CDATA部分的格式是，可以用另一个多选分支来处理，‘’之类的处理指令需要再添加一个多选分支：
1。
entity声明的形式是，可以用I来处理。XML中有许多类似
的结构，他们中的大部分可以用取代‘来处理。》
制
---
## Page 510
484
第10章：PHP
虽然还有些问题，不过上面的办法应该能够应付绝大多数XML。下面是完整的PHP代码：
Sxml_regex ='{
（
（？：]*+（?（?1）
#匹配一组tag
1[^<>]++
#非tag字符
1
#自封闭tag
1
#注视
1
#cdata数据
1
#处理指令
1
#Entity声明之类
)*+
)$
!,xS {
if (preg_match($xml_regex, $xml_string))
echo"block structure seems valid\n";
else
echo *block structure seems invalid\n';
HTML
常见的情况是，真实世界的HTML有各种各样的问题，这样的检测几乎没有实用价值，例
HTML也有些特殊情况我们必须处理，注释和tag。
HTML注释规范与XML注释一样：，使用模式修饰符s。
部分是重要的，因为它可能包含‘'，所以必须容许
之间出现任何字符。我们可以这样处理：]。有趣的是，
不包含禁止出现的‘’和‘>’的字符的script序列会被第1个多选分支捕获，因为它走的
也是“匹配的一组tag”的套路。如果不包含任何其他字符，第1个多选分支会失
败，这些文本留给新增的多选分支。
这里是HTML版本的PHP程序：
Shtml_regex ='{
^（
(?：]*+（?（?1）
#匹配一对tag
1[<>]++
#非tag文本