(cid:1)
(cid:11) (cid:12) (cid:13)(cid:13)(cid:14)(cid:15)(cid:16)(cid:16)(cid:17)(cid:14)(cid:14)(cid:17)(cid:18) (cid:16)
Fig. 11: Bit ﬂips vs. number of aggressor rows. Module A15:
Number of bit ﬂips in bank 0 as we vary the number of aggressor
rows. Using SoftMC, we refresh DRAM with standard tREFI and
run the tests until each aggressor rows is hammered 500K times.
C. Case II: Module A15
To provide an understanding of the different ﬂavors of in-
DRAM TRR, we further study the behavior of a memory
module from a different manufacturer: A15. We quickly test
and conﬁrm that the mitigation acts at every refresh command,
corroborating the observation made in the previous case study.
We then move to analyzing the relationship between the
number of bit ﬂips and the number of aggressors n, with the
default refresh rate, depicted in Figure 11. We ﬁnd that we
can reliably ﬂip bits for n ≥ 7, indicating a sampler of size 6.
Double-sided RowHammer resurrected. Although we now
already bypass the mitigation, we take this one step further
and try to analyze the sampler to see if we can revive the
more efﬁcient double-sided RowHammer attack. Our approach
consists of ﬁnding the minimal set of dummy rows that allows
us to trick the mitigation mechanism into refreshing all other
neighbors of the hammered rows but our victim. For this, we
focus on a single row that we know to be susceptible to bit ﬂips
and for which we ﬁnd in advance the threshold of hammers
required to observe bit ﬂips. Based on this threshold, we carry
out successive experiments while modifying two parameters:
(i) the distribution of activations across aggressor and dummy
rows and (ii) the number of dummies starting from 6 (i.e., the
supposed size of the sampler). To our surprise, regardless of
the conﬁguration, we could not detect any bit ﬂip.
Investigating further, we discover two more parameters that
were previously unaccounted for:
DRAM command order dependency. The sampler may act at
speciﬁc DRAM commands issued within a refresh interval
and thus it may not necessarily sample based only on
frequency. In the case of module A15, the sampler seems
to record the ﬁrst α activations after a refresh command—
where α ≤ 6.
In module A15, we observe a
Address dependency.
dependency between the aggressor-row address and the
dummy rows’ addresses. That
is, when hammering two
aggressor rows, we detect more bit ﬂips when we pick
particular dummy rows compared to picking random
dummy rows. This suggests that the design of the sampler
involves optimizations to reduce the storage cost of tracking
row activations such that multiple aggressor rows’ addresses
may conﬂict.
Observation 5: The sampler records row activations at
speciﬁc commands and likely at speciﬁc ordering of
commands (i.e., it performs command-order-based sam-
pling).
Observation 6: The sampling mechanism is affected by the
addresses of aggressor rows (i.e., sampling is row-address-
dependent).
D. Running on the CPU: Module A15
While we observe a considerable number of bit ﬂips when
we use the (optimal) activation pattern discovered by SoftMC,
a custom FPGA memory controller does not represent a
widespread threat model. As a consequence, we want to check
if we can reproduce the same access pattern when running on
commodity hardware, such as a regular desktop computer.
During the analysis process, we ﬁnd the mitigation of
the A15 memory module to be command order and address
dependent. This represents a great challenge when trying to
reproduce access patterns that cause bit ﬂips from the CPU.
In fact, in order to fool the mitigation, we need to carry out a
speciﬁc series of activations right after a REFRESH command
to keep the inhibitor busy with another set of rows than the
intended victim row. This means we need to synchronize our
access pattern with the REFRESH command. Even though
we can detect refresh operations (Section IV), synchronizing
our access pattern with them is much more difﬁcult. We
re-implement the access patterns discovered in the analysis
process, which we explain in Section V-C, to run on the CPU.
However, we observe much fewer bit ﬂips compared to what
we obtain with SoftMC, suggesting we may not be able to
perfectly synchronize the hammering pattern with the refresh
operations using a CPU. This is likely due to the fact that
the memory controller applies various optimizations that can
reorder memory requests and refresh commands.
E. Observations
Our experiments in Section V-D show the difﬁculty of
reproducing our FPGA results—those obtained in a simpliﬁed,
controlled environment—on a modern CPU. This advocates
for a better solution for ﬁnding effective access patterns that
trigger bit ﬂips on TRR-protected DDR4 chips. In the next
section, we introduce TRRespass, a black-box RowHammer
test suite that generates effective access patterns to bypass in-
DRAM TRR solutions.
TRRespass is inspired by the insights that we obtained using
our analysis of TRR-protected DDR4 chips in this section.
More speciﬁcally, we take advantage of the following insights:
1. The sampler can track a limited number of aggressor
rows. Thus, we may need to overﬂow the sampler’s ag-
gressor rows table in order to bypass the TRR mitigation.
2. The sampler may sample activations at speciﬁc com-
mands, at a speciﬁc frequency, or both.
3. The sampler design may be row address dependent.
Therefore, some rows may be easier to hammer than
others and the same set of rows activated in different
order may yield completely different results.
4. The cells in DDR4 chips are much more RowHammer-
prone than those on DDR3 [51], requiring fewer activa-
tions to trigger bit ﬂips.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
754
In the next section, we describe how we use these observa-
tions to build a (guided) black-box fuzzer that can cause bit
ﬂips on TRR-protected DDR4 modules.
VI. TRRespass: A TRR-AWARE ROWFUZZER
To convert the knowledge that we gathered from our analy-
sis process on the FPGA-based SoftMC platform into practical
attacks that we can launch from regular software on a CPU, we
developed a guided black-box fuzzer for RowHammer called
TRRespass. When searching for usable access patterns, a CPU-
based fuzzer has two main advantages over an FPGA-based
approach: (i) it allows an attacker to completely ignore the
memory controller (and the optimizations it implements), and
(ii) it provides a scalable approach to testing for RowHammer
bit ﬂips. Indeed, since different manufacturers deploy very
different TRR solutions as we show in Section V, trying to
obtain a detailed understanding of the full behavior of every
TRR-protected memory module is not practical. Even so, we
will demonstrate that these details in most cases do not get
in the way of ﬁnding effective patterns: TRRespass was able
to automatically ﬁnd access patterns that trigger bit ﬂips on
modules we did not analyze, and even on mobile platforms
using LPDDR4(X) chips—albeit in a simpliﬁed way.
A. Design
Based on the observations in Section V, TRRespass’ fuzzing
strategy is based on two parameters: Cardinality and Location.
Cardinality. Cardinality represents the number of aggressor
rows hammered. We show in Section V-B that some modules
require a large number of aggressor rows to overﬂow the
sampler and induce bit ﬂips. For instance, Figure 11 indicates
that we need at least 7 rows to observe bit ﬂips in module
A15. On the other hand, increasing the cardinality too much
is counterproductive. In particular, a DRAM module cannot
carry out more than a certain number of activations within the
64 ms interval between two refreshes of the same row. The
maximum number of row activations that can be performed
within 64 ms mainly depends on the row cycle time (tRC) that
deﬁnes the number of clock cycles between two ACTIVATE
commands to the same bank. In most modules tRC ≈ 45 ns. It
follows that the maximum number of activations that we can
perform within a 64ms interval is 1.4×106 (64 ms÷45 ns). If
we tune the fuzzer to hammer each aggressor row at least 50K
times (see Section V-B), the upper limit for the cardinality is
28 rows.
Location. Based on the results of Section V-C, we know
that the sampler may have dependence on row addresses.
Thus, we want to randomize the location of the aggressors
to maximize the probability of bypassing address-dependent
TRR mitigations. Moreover, by picking the access pattern
randomly, we implicitly bypass any feature of the sampler
in the time domain. That is, regardless of the design of the
sampler (command-order-based or frequency-based), choosing
random values for the distances between the aggressors also
randomizes the aggressors’ relative positions in the access
pattern. Given a set of aggressors, we choose to activate them
in a round-robin fashion since our experiments show that other
strategies do not bring beneﬁts in terms of the number of bit
ﬂips.
Fuzzing strategy. TRRespass evaluates randomly-generated
access patterns based on the number of unique bit ﬂips. It
generates the patterns by randomizing the cardinality and
location parameters. If a bank contains n rows, evaluating the
combinations of all n rows taking k at a time (k 2).
(a) Assisted double-sided
(b) 4-sided
Fig. 12: Hammering patterns discovered by TRRespass. Aggressor
rows are in red ( ) and victim rows are in blue ( ).
The analysis on all the 42 DRAM modules then allowed
us to generalize the assisted double-sided access pattern to
a broader class of access patterns which we call Many-
sided RowHammer. Our results show that an attacker can
beneﬁt from sophisticated hammering patterns that exploit
repeated accesses to many aggressor rows. We now refer to the
discovered patterns using the nomenclature n-sided where n
is the cardinality of the pattern. For instance, assisted double-
sided which is effective on B modules (Figure 12a), falls
under the category of 3-sided RowHammer. Note that while we
omit the location of the aggressors from this discussion, this
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
755
TABLE II: TRRespass results. We report the number of patterns found and bit ﬂips detected for the 42 DRAM modules in our set.
Date
(yy-ww)
Freq.
(MHz)
Size
(GB)
MAC
Found
Patterns
Best Pattern
Corruptions
1 → 0
0 → 1
Double
Refresh
Total
Module
A0,1,2,3
A4
A5
A6,7
A8
A9
A10
A11
A12,13
A14
A15
‡
B0
B1
B2
B3
B4,5
B6,7
B8
(cid:3)
B9
(cid:3)
B10,11
C0,1
C2,3
C4,5
C6,7
C8
C9
C10,11
C12
‡
C13
‡
16-37
16-51
18-51
18-15
17-09
17-31
19-02
19-02
18-50
19-08†
17-08
18-11
18-11
18-49
19-08†
19-08†
19-08†
19-08†
19-08†
16-13†
18-46
19-08†
19-08†
19-08†
19-08†
18-47
19-04
15-01†
18-49
2132
2132
2400
2666
2400
2400
2400
2400
2666
3200
2132
2666
2666
3000
3000
2666
2400
2400
2400
2132
2666
2800
3000
3000
3200
2666
2933
2132
2132
4
4
4
4
8
8
16
16
8
16
4
16
16
16
8
8
4
8
8
8
16
4