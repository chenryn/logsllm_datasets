i
Enc(eki, xj,0
i − x1,0
i + x1,0
i
i + x1,1
i
justiﬁcation/remark
many-yy-IND
security game
one-yy-IND security of MIFE
)
)
)
many-yy-IND security for n instance of FE
Figure 4.4: Sequence of games for the proof of Theorem 10. Here, for any slot i ∈ [n], and j ∈ [Qi],
ctj
i refers to the j’th challenge ciphertext for slot i ∈ [n]. Changes are highlighted in gray for better
visibility.
Games G0, G1 , G2 :
CS ⊆ [n] ← A(1λ, F m,X,Y
(pk, msk, (eki)i∈[n]) ← Setup(1λ, F m,X,Y
α ← AOEnc(·,·),OKeygen(·)(pk,{eki}i∈CS)
Return α.
)
n
n
)
i
, xj,1
i )):
OEnc(i, (xj,0
i := Enc(pk, eki, xj,0
ctj
i := Enc(pk, eki, xj,0
ctj
i := Enc(pk, eki, xj,1
ctj
Return ctj
i .
i
i − x1,0
i − x1,0
i − x1,1
i + x1,0
)
i + x1,1
)
i + x1,1
)
i
i
OKeygen(y1k···kyn):
Return KeyGen(pk, msk, y1k···kyn).
Figure 4.5: Games for the proof of Theorem 10. In the selective variants of these games, the adversary
sends its challenges {xj,b
i }i∈[n],j∈[Qi],b∈{0,1} before seeing the public key and querying any decryption
keys.
Game G2: we replace the challenge ciphertexts to ctj
) =
Enc(pk, eki, xj,1
i ) for all i ∈ [n] and j ∈ [Qi], using the many-yy-IND security of FE for
n instances, which is implied by the single-instance security (see Lemma 5). We prove in
Lemma 32 that there exists a PPT adversary B2 such that
i = Enc(pk, eki, xj,1
i − x1,1
i + x1,1
i
AdvG1(A) − Adv2(A) ≤ Advmany-yy-IND
FE,B2,n
(λ).
Putting everything together, we obtain:
Advmany-yy-IND
MIFE,A (λ) ≤ Advone-yy-IND
MIFE,B1
(λ) + Advmany-yy-IND
FE,B2,n
(λ).
Lemma 31: Game G0 to G1
There exists a PPT adversary B1 such that
|AdvG0(A) − AdvG1(A)| ≤ Advone-yy-IND
MIFE,B1
(λ).
90
Chapter 4. Multi-Input Inner-Product Functional Encryption from Pairings
Proof of Lemma 31. In game G1, which is described in Figure 4.5, we replace Enc(pk, eki, xj,0
Enc(pk, eki, x1,0
This is justiﬁed by the following properties:
i ) =
)) for all i ∈ [n], j ∈ [Qi].
)) with Enc(pk, eki, x1,1
i − x1,0
i − x1,0
i + (xj,0
i + (xj,0
i
i
• one-yy-IND security of MIFE;
• the fact Enc′ is linearly homomorphic. Namely, for all i ∈ [n], given Enc′(gpk′, ek′
i + xj,0
i − x1,0
xj,0
(corresponding to challenge ciphertexts in slots i in game Gβ).
and gpk′, we can create a fresh encryption Enc′(gpk′, ek′
i, x1,β
i
i
i, x1,β
),
i − x1,0
)
i
The adversary B1 proceeds as follows.
-Simulation of pk:
In the adaptive variant, i.e. yy = AD, B receives the set CS ⊆ [n] from A, sends it to its own
experiment, receives a public key which it forwards to A.
i }i∈[n],j∈[Qi],b∈{0,1}, and
the set CS ⊆ [n] from A. It sends the pair of vectors {x1,b
i }i∈I,b∈{0,1} as its selective challenge
to its experiment, where I ⊆ [n] is the set of indices i ∈ [n] for which Qi > 0. It gets back pk,
which it forwards to A, and the challenge ciphertexts {cti}i∈I, where cti = Enc(pk, eki, x1,β
1 ),
for β ∈ {0, 1}, when B1 is interacting with the experiment SEL-INDMIFE
(1λ,B1), which is the
selective variant of AD-INDMIFE
In the selective variant, i.e. yy = SEL, it receives the challenge {xj,b
β
β
(1λ,B1) from Deﬁnition 23.
i
, xj,1
i )):
-Simulation of OEnc(i, (xj,0
In the adaptive variant, if j = 1, that is, it is the ﬁrst query for slot i ∈ [n], then B1 queries
its own oracle to get cti := Enc(pk, eki, x1,β), where β ∈ {0, 1}, depending on the experiment
B1 is interacting with. If j > 1, B1 uses the fact that the single-input inner-product scheme is
linearly homomorphic to generate all the remaining ciphertexts ctj
i for i ∈ I, j ∈ {2, . . . , Qi}
by combining cti = Enc(pk, eki, x1,β
i k0)
i − x1,0
i + xj,0
to obtain Enc′(gpk′, ek′
) which matches
the challenge ciphertexts in Game Gβ. Note that this can be done using gpk′. B1 returns
{ctj
i}i∈[n],j∈[Qi] to A.
In the selective variant, the same thing happens, except queries to OEnc are performed
beforehand.
i kzi) with the vector (xj,0
i kzi) = Enc(eki, x1,β
) = Enc′(gpk′, ek′
i − x1,0
i − x1,0
i + xj,0
i, x1,β
i, x1,β
i
i
-Simulation of OKeygen(y1k···kyn):
B1 simply uses its own secret key generation oracle on input y1k···kyn and forwards the
answer to A.
It is clear that for all
β ∈ {0, 1}, when B1 interacts with one-SEL-INDMIFE
, it simulates the game Gβ to A.
Therefore,
Finally, B1 forwards the output α of A to its own experiment.
β
Advone-yy-IND
MIFE,B1
(λ) =
(cid:12)(cid:12)(cid:12)Prhone-yy-INDMIFE
|AdvG0(A) − AdvG1(A)|.
0
(1λ,B1) = 1i − Prhone-yy-INDMIFE
1
(1λ,B1) = 1i(cid:12)(cid:12)(cid:12) =
Lemma 32: Game G1 to G2
4.1 Selectively-Secure, Private-Key MIFE for Inner Products
91
There exists a PPT adversary B2 such that
|AdvG1(A) − AdvG2(A)| ≤ Advmany-yy-IND
FE,B2,n
(λ).
i
i, x1,1
i + (xj,1
i − x1,1
) kzi) with Enc(gpk′, ek′
i, x1,1
Proof of Lemma 32. In Game G2, which is described in Figure 4.5, we replace Enc(gpk′, ek′
i +
i − x1,0
(xj,0
i kzi), for all
i ∈ [n], j ∈ [Qi]. This follows from the many-yy-IND security of FE for n instances, which we
can use since for each key query y1k . . .kyn and all r, z, we have
i − x1,1
, yii, which follows from the restriction
i + xj,0
hx1,1
, yii = hxj,1
The latter is equivalent to hxj,0
imposed by the security game (see Remark 7).
We build a PPT adversary B2 such that:
i − x1,0
i − x1,0
) kzi) = Enc(gpk′, ek′
i kz, yikri = hx1,1
i kz, yikri.
i − x1,1
i + xj,1
i, xj,1
i
i
i
|AdvG1(A) − AdvG2(A)| ≤ Advmany-yy-IND
FE,B1,n
(λ).
Adversary B2 proceeds as follows.
First, B2 samples zi ← Zk
using its own encryption oracle on input (i, (xj,0
dky1k···kyn by ﬁrst sampling r ←R Zk
oracle on input (i, yikr). It returns dky1k···kyn := ({[di]2}i∈[n], [r]2, [Pihzi, ri]T ).
Finally, B2 forwards the outputs α of A to its own experiment.
β ∈ {0, 1}, when B2 interacts with many-yy-INDMIFE
Therefore,
p for all i ∈ [n]. Then, it simulates all challenge ciphertexts ctj
i kzi)). It simulates all decryption keys
p, and setting di as the output of its own decryption key
It is clear that for all
, it simulates the game G1+β to A.
i kzi, xj,1
β
i
Advmany-yy-IND
FE,B2,n
(λ) =
(cid:12)(cid:12)(cid:12)Prhmany-yy-INDFE
|AdvG1(A) − AdvG2(A)|.
0 (1λ, 1n,B2) = 1i − Prhmany-yy-INDFE
1 (1λ, 1n,B2) = 1i(cid:12)(cid:12)(cid:12) =
Putting everything together
In Figure 4.6 we spell out the details of the scheme in the previous section with a concrete
instantiation of the underlying single-input inner-product scheme, whose one-SEL-SIM security
is proven under the Dk-MDDH assumption, which is provided for completeness in Section 2.6.1.
92
Chapter 4. Multi-Input Inner-Product Functional Encryption from Pairings
p
n
):
Setup(1λ, F m,X,Y
PG := (G1, G2, p, P1, P2, e) ←R PGGen(1λ), A ←R Dk(p).
Zm×(k+1)
msk := {Wi, Vi, zi}i∈[n]. Return (pk, msk, (eki)i∈[n]).
Enc(pk, eki, xi):
, Vi ←R Zk×(k+1)
, zi ←R Zk
p, eki
p
For all i ∈ [n]: Wi ←R
:= (zi, [WiA]1, [ViA]1), pk := (PG, [A]1),
.
−Asi
si ←R Zk
xi + WiAsi
zi + ViAsi
KeyGen(msk, y1k···kyn):
r ←R Zk
1
p, return
p. For all i ∈ [n]: di :=
r(cid:19) , z := hz1 + ··· + zn, ri
(cid:18)yi
Return(cid:0){[di]2}i∈[n], [r]2, [z]T(cid:1)
Dec(cid:16)(cid:0){[di]2}i∈[n], [r]2, [z]T(cid:1),{[ci]1}i∈[n](cid:17):
[d]T :=Pi e([ci]⊤
1 , [di]2) − [z]T
Return the discrete log of [d]T .
i yi + Vir
W⊤
Figure 4.6: Our private-key MIFE scheme for the functionality F m,X,Y
, which is proven many-SEL-
IND-static in Corollary 2, and many-AD-IND secure in Theorem 51. Both rely on the Dk(p)-MDDH
assumption in G1 and G2.
n
4.2 Achieving Adaptive Security
93