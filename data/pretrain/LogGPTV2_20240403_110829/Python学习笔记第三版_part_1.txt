3.
6
Python 学习笔记
(cid:19788)(cid:8233)(cid:17512)(cid:1)
(cid:1)
学习笔记 . 第三版
前⾔ 4
更新 6
上卷 语⾔详解 7
⼀. 概述 8
⼆. 类型 9
1. 基本环境 9
2. 内置类型 36
三. 表达式 90
1. 词法 90
2. 赋值 99
3. 运算符 109
4. 控制流 120
5. 推导式 127
四. 函数 131
1. 定义 131
2. 参数 139
3. 返回值 148
4. 作⽤域 150
5. 闭包 156
6. 调⽤ 164
五. 迭代器 172
1. 迭代器 172
2. ⽣成器 177
3. 模式 184
4. 函数式编程 188
六. 模块 192
1. 模块 192
2. 导⼊ 193
3. 包 194
七. 类 195
1. 定义 195
2. 字段 196
3. 属性 197
!2
学习笔记 . 第三版
4. ⽅法 198
5. 继承 199
6. 开放类 200
7. 操作符重载 201
⼋. 异常 202
1. 异常 202
2. 断⾔ 203
3. 上下⽂ 204
九. 元编程 205
1. 装饰器 205
2. 描述符 206
3. 元类 207
4. 注解 208
⼗. 进阶 209
1. 解释器 209
2. 扩展 210
⼗⼀. 测试 211
1. 单元测试 211
2. 性能测试 212
⼗⼆. ⼯具 213
1. PDB 213
2. PIP 214
3. iPython 215
4. Jupyter Notebook 216
5. VirtualENV 217
下卷 标准库 218
⼗三. ⽂件 219
⼗四. 数据 220
⼗五. 数据库 221
⼗六. ⽹络 222
⼗七. 并发 223
⼗⼋. 系统 224
!3
前言
写这本书的时候，我已摆脱萌新⾝份，勉强算得上是个有经验的作者。可即便如此，依然
⽆法保证内容正确，且满⾜某某⼈的胃⼜。显然，这不可能做到。
在我看来，书⼤抵分两类：学习和研究。学习类书籍满⾜⽇常学习和提升需要，⽤简练语
⾔把问题说清楚。最关键的是有条清晰线索，把散乱的知识串联起来。学习者可据此了解
前因后果，为其在茫茫⽹海中导航，⽤以探寻神秘之地。⾄于研究类图书或论⽂，应摆脱
基础，摆脱语法，全⼼关注算法、架构、性能，乃⾄内部实现等等。所有这些，以思想为
⽀撑，超脱语⾔窠⾅，构建并完善⾃有体系。
不同于写散⽂⼩说，技术类⽂字并不好组织。⾃然语⾔易阅读，但不便描述有复杂流程分
⽀的逻辑，易导致歧义。更何况，这其中还有各种转译带来的⿇烦。有句话⼤家都⽿熟，
所谓 “⼀图胜千⾔”。故应以⾃然语⾔开宗明义，阐述理论和规则，随后⽤代码继续对这段
⽂字进⾏详细解释，毕竟代码先天有描述逻辑的优势。
很多书，尤其是英⽂版，习惯⽤⼤量篇幅对代码⽰例作各种讲解。感觉有些啰嗦，怕是很
少去读第⼆遍，最多⽤记号笔划出重点。既如此，为何不相信读者能阅读并理解这些代码
呢？这本就是程序猿吃饭的本钱，最多在关键位置辅以注释便可。当然，前提怕是要设定
为⾮⼊门读者。好在，我⼀再强调写的是第⼆本，或者闲书。
在这本书⾥，对于理论层⾯，我会尝试说得明⽩些。还会引⼊⼀些类⽐，或许不⼤合适，
总归其原意是为加深理解，毕竟不是所有⼈都能⽴即明⽩那些云⾥雾⾥的抽象理念。⼀如
上⾯所⾔，⽂字与代码相辅相承，应静下⼼来⽤代码去验证那些⽂字背后的东西。在我眼
⾥，代码也是种⾃然语⾔，缩排跳转仿若图形，本就是最好的笔记注释。起码它离机器尚
有些距离，为⼈类⽽发明。
⽆论我说得多悦⽿动听，本书终归是本学习笔记。算不上多专业，适合闲暇翻阅⼀⼆。
读者定位
本书着重于剖析语⾔相关背景和实现⽅式，适合有⼀定 Python 编程基础的读者，⽐如准
备从 2.7 升级到 3.6 环境。⾄于初学者，建议寻本从零开始，循序渐进介绍如何编码的图
书为佳。
学习笔记 . 第三版
联系方式
鉴于能⼒有限，书中难免错漏。如您发现任何问题，请与我联系，以便更正。谢谢！
邮件：PI:EMAIL
微博：weibo.com/qyuhen
雨 痕
⼆〇⼀七，初夏
(cid:1)
!5
学习笔记 . 第三版
更新
2013-01-09 第⼆版，基于 Python 2.7。
2017-06-01 第三版，基于 Python 3.6。
!6
学习笔记 . 第三版
上卷 语言详解
Python 3.6
!7
学习笔记 . 第三版
一. 概述
⽰例运⾏环境: CPython 3.6, macOS 10.12
鉴于不同运⾏环境差异，⽰例输出结果会有所不同。尤其是 id，以及内存地址等信息。
另，为阅读⽅便，对输出结果作了裁剪处理，请以实际运⾏结果为准。
Python 始于 1989 年，早于 1995 年发布的 Java 和 Ruby。发展⾄今，甚⾄⽐⼤部分 Pythoner 年纪
还⼤。如此长的时间跨度，其⾝上不可避免有各个时期的思想风格。
单就语⾔⽽论，Python 复杂度远超 C、Go ，称得上是易学难精。
但众多规则也带来编码上的便利，算是冰⽕两重天。
!8
学习笔记 . 第三版
二. 类型
1. 基本环境
作为⼀种完全⾯向对象，且兼顾函数式的编程语⾔，Python 复杂程度要远⾼出许多⼈的设
想，诸多概念被隐藏在看似简单的代码背后。为了更好且更深⼊理解相关规则，在讲述语
⾔特征以前，我们需对世界背景做个初步了解。
1.1 类型
从抽象⾓度看，每个运⾏中的程序（进程）都由数量众多的 “鲜活” 对象组成。每个对象都
有其独特的状态和逻辑，通过⾏为触发，或与其他对象交互来体现设计意图。⾯对如此众
多的个体，作为设计师⾃然需要以宏观视⾓来规划世界。那么⾸先要做的，就是将所有个
体分门别类归置于某个族群。
我们习惯将⽣物分为动物、植物，进⽽又有猫科、⽝科等细分。通过对多个个体的研究，
归纳其共同特征，抽象成便于描述的种族模版。另⼀⽅⾯，有了模版后，可据此创建⼤量
⾏为类似的个体。所以，分类是个基础⼯程。
在专业术语上，我们将类别称做类型（class），⽽个体叫做实例（instance）。类型持有
所有个体的共同⾏为和共享状态，⽽实例仅保存私有特性即可。如此，在内存空间布局上
才是最⾼效的。
以张三、李四为例，他们属于⼈类的特征，诸如吃饭、⾛路等等，统统放到 “⼈类” 这个类型⾥。
个⼈只要保存姓名、性别、胖瘦、肤⾊这些即可。
类型指针 张三，男 ...
⼈人类
类型指针 李李四，男，胖⼦子 ...
class instance
!9
学习笔记 . 第三版
每个实例都会存储所属类型指针。需要时，透过它间接访问⽬标即可。但从外在逻辑接⼜
看，任何实例都是 “完整” 的。
存活的实例对象都有个 “唯⼀” 的 ID 值。
>>> id(123)
4487080432
>>> id("abc")
4488899864
不同 Python 实现使⽤不同算法，CPython ⽤内存地址作为 ID 值。这意味着它只能保证在某个时
间，在所有存活对象⾥是唯⼀的。不保证整个进程⽣命周期内是唯⼀的，因为内存地址会被复⽤。
如此，ID 也就不适合作为全局⾝份标识。
可⽤ type 返回实例所属类型。
>>> type(1)
int
>>> type(1.2)
float
>>> type("hello")
str
如要判断实例是否属于特定类型，须⽤ isinstance 函数。
>>> isinstance(1, int)
True
>>> isinstance(1, float)
False
类型之间可构成继承关系。就像⽼虎继承⾃猫科，⽽猫科又继承⾃哺乳动物，再往上还有
更顶层类型。继承关系让⼀个类型拥有其所有祖先类型的特征。历史原因让 Python 允许
多继承，也就是说可有多个⽗类型，好似⼈类同时拥有⽗族、母族的遗传特征。
!10
学习笔记 . 第三版
issubclass isinstance
动物
哺乳动物
猫科
狮⼦子 ⽼老老⻁虎
狮⻁虎兽 王⼩小⻁虎
class instance
任何类型都是其祖先类型的⼦类，同样对象也可以判定为其祖先类型的实例。这与⾯向对
象三⼤特性中的多态有关，后⽂再做详述。
class Animal: pass # 动物
class Mammal(Animal): pass # 哺乳动物（继承⾃自动物）
class Felidae(Mammal): pass # 猫科
class Lion(Felidae): pass # 狮⼦子
class Tiger(Felidae): pass # ⽼老老⻁虎
class Liger(Lion, Tiger): pass # 狮⻁虎兽（继承⾃自两个直系⽗父类型）
>>> issubclass(Liger, Lion)
True
>>> issubclass(Liger, Tiger)
True
>>> issubclass(Liger, Animal) # 是任何层次祖先类型的⼦子类。
True
>>> wxh = Liger() # 王⼩小⻁虎（狮⻁虎兽实例例）
!11
学习笔记 . 第三版
>>> isinstance(wxh, Lion)
True
>>> isinstance(wxh, Tiger)
True
>>> isinstance(wxh, Animal) # 是任何祖先类型的实例例。
True
事实上，所有类型都有⼀个共同祖先类型 object，它为所有类型提供原始模版，以及系统
所需的基本操作⽅式。
>>> issubclass(Liger, object)
True
>>> issubclass(int, object)
True
类型虽然是个抽象的族群概念，但在实现上也只是个普通的实例。区别在于，所有类型对
象都是 type 的实例，这与继承关系⽆关。
>>> id(int)
4486772160
>>> type(int)
>>> isinstance(int, type)
True
怎么理解呢？想想看，单就类型对象⾃⾝⽽⾔，其本质就是个⽤来存储⽅法和字段成员的
特殊容器，⽤同⼀份设计来实现这些容器才是正常思路。
就好⽐扑克牌，从玩法逻辑上看，J、Q、K、A 等等都有不同含义。但从材质上看，它们完全相
同，没道理⽤不同材料去制作这些内容不同的卡⽚。同理，继承也只是说明两个类型在逻辑上存
在关联关系。如此，所有类型对象都属于 type 实例就很好理解了。
⽆论是在编码，还是设计时，我们都要正确区分逻辑与实现的差异。
>>> type(int)
!12
学习笔记 . 第三版
>>> type(str)
>>> type(type)
当然，类型对象属于特殊存在。默认情况下，它们由系统在载⼊时⾃动创建，⽣命周期通
常与进程（虚拟机、解释器）相同，且仅有⼀个实例。
>>> type(100) is type(1234) is int # 指向同⼀一类型对象。
True
1.2 名字
在通常认知⾥，变量是⼀段有特定格式的可读写内存，变量名则是这段内存的别名。因为
在编码阶段，⽆法使⽤直接或间接⼿段确定内存具体位置，所以使⽤名称符号来代替。
注意区分变量名和指针的不同。
接下来，静态编译和动态解释型语⾔对于变量名的处理⽅式就完全不同。类似 C、Go 这
类静态编译型语⾔，其编译器会使⽤直接或间接寻址⽅式替代作为变量名符号。也就是说
变量名不参与执⾏过程，是可被剔除的。但在 Python 这类动态语⾔⾥，名字和对象是两
个实体。名字不但有⾃⼰的类型，要分配内存，还会介⼊实际执⾏过程。甚⾄可以说，名
字才是其动态执⾏模型的基础。
如果将寻址⽅式⽐喻为顾客直接按编号寻找银⾏服务柜台，那么 Python 的名字就是⼀个
接待员。任何时候，顾客都只能通过接待员间接与⽬标服务进⾏互动。从表⾯上看，这似
乎是 VIP 待遇，但实际增加了中间环节和额外的成本开销，于性能不利。好处是，接待员
与服务之间拥有更多的可调整空间。
鉴于此，名字必须与⽬标对象关联起来才有意义。
>>> x
NameError: name 'x' is not defined
!13