or resets the target bit, logs its value and the attacker measures a
SMoTherSpectre timing sample. We run the attack 10,000 times
and separate the collected samples based on the value of the target
bit on that particular run, yielding two sets of attacker timings
corresponding to the target bit being zero or one. Finally, we run
the Student’s t-test to check whether the sets are statistically dis-
tinguishable. We used this methodology on four SMoTher-gadgets
described in Section 6.1. Table 4 shows the results: the distributions
are differentiable with at-least 95% confidence for each of the four
gadgets. The attack does not require extremely high BTI success
rate: in our samples, we observe BTI success rates ranging between
16% and 25%. The whole experiment takes about 75 seconds of real-
time, of which a total of 20 seconds are spent by the orchestrator
waiting for the server to be fully setup before launching the client.
We run the OpenSSL attack on an i5-6200u CPU. A run of 100,000
encryptions is performed by the victim for each value of the secret
bit. The large number of encryptions is necessary to estimate the
probability density function for this SMoTher-gadget. A practi-
cal attack can confidently leak a bit with fewer encryptions. The
attack takes about 950 ms of userspace time, leading to a mea-
surement rate of more than 200,000 samples/second. The attacker
succeeded in BTI with a success rate up to around 80%. We have
found the time taken by the victim to reach the indirect call from
the call triggering encryption entry to be highly predictable. The
attacker is thus able to run the timing sequence concurrently with
the victim’s SMoTher-gadget without additional synchronization.
Figure 7 shows the distribution of timestamp counter difference
.rept 8;
btrl r8d, r9d;
btrl r10d, r11d;
btsl r8d, r9d;
btsl r10d, r11d;
.endr;
0xf5393: testq
0xf539a: je
0xf539c: mov
...
0xf5382: add
...
0x400,(rdx)
f5382
-0xb0(rbp),rdi
0x1,rax
if(ctx->cipher->do_cipher(ctx, out, in, inl))
{
*outl = inl;
return 1;
}
...
(a) Attacker-timed code
(b) Victim SMoTher gadget (glibc)
(c) Victim BTI gadget (OpenSSL)
Figure 6: Gadgets from real-world libraries used in our SMoTherSpectre exploit for leaking the 3r d LSB of byte 1 of rdx’s pointee
to achieve thread-level parallelism within a core. These include
coarse-grained and interleaved multithreading.
BTI mitigations. Mitigations against branch target injection
are also known as Spectre v2 mitigations. These include retpolines,
which rewrite code to remove indirect calls [33], as well as CPU-
based controls. Intel has exposed to developers a set of security
controls that limit an attacker’s ability to perform BTI. While they
have been applied in selected cases, they have not been widely
adopted because of their overhead [7], and because in many cases,
the required gadgets were simply not present [23]. Wide adoption
of these mitigations may limit the SMoTherSpectre attack.
Summary. Fully mitigating the attack in either of these two
categories is sufficient to stop the attack presented in this paper.
However, SMoTherSpectre does not necessarily need to employ
BTI: it can be generalized to use any other form of speculative
control flow hijack, e.g., Return Stack Buffer (RSB) overflow [27]
or speculative return address overwrite [22]. In those cases, corre-
sponding mitigations would apply.
7 RELATED WORK
Transient Execution Attacks. Transient execution attacks ex-
ploit instructions that are executed, yet not necessarily retired and
thus cover both attacks based on speculative execution as well as
out-of-order execution [5].
At the beginning of 2018, two security issues exploiting specu-
lative execution were revealed under the name “Spectre” [18, 23].
Spectre V1 (“Bounds Check Bypass”) exploits branch prediction
on a conditional branch to achieve an out-of-bounds access during
speculative execution: given a conditional branch that performs
a bounds-check on an array, the branch predictor is trained to
the in-bounds case by performing multiple executions of the corre-
sponding code with a benign index. When the code is then executed
with an out-of-bounds index, a misprediction occurs and the ar-
ray access with the malicious index is performed. If the result is
used in further computation such as another array access, it can be
leaked through a side channel. Spectre V2 (“Branch Target Injec-
tion”) exploits branch prediction on indirect control-flow transfers.
To this end the attacker first trains the branch predictor for a given
address to transfer control to an address of the attacker’s choosing.
The predictor will then use the branch history created by the at-
tacker for a spatially or temporally co-located victim. Again, a cache
side-channel can be used to leak data of the attackers choosing in
the following. The return stack buffer, which is used for return
statements in a similar fashion as the branch history is used for
indirect jumps has also been leveraged as a speculative execution
Figure 7: Probability density function (estimated using kernel den-
sity estimation) for the attacker’s timing running our SMoTher-
Spectre attack on OpenSSL, for when the victim’s secret bit is one
versus zero.
measured by the attacker for the SMoTher gadget. The distribu-
tions show a significant variation, with that corresponding to the
zero-secret tending towards higher values. The Student’s t-test is
able to successfully distinguish between them with 95% confidence.
The test reports a timing difference of 10.69% ± 6.31%.
6.4 Mitigating SMoTherSpectre
Mitigations for SMoTherSpectre can be subdivided in two cate-
gories: mitigations for SMoTher and mitigations for BTI.
SMoTher mitigations. The general
idea of preventing
SMoTher attacks is to ensure that two threads with different privi-
leges (in the general sense) do not compete for the same execution
port.
Currently available software SMoTher mitigations are limited.
Apart from the straightforward but performance-costly possibility
of disabling SMT in its entirety (up to 10-15% overhead on Intel),
the OS scheduler can employ a side-channel aware strategy. For
example, the OS scheduler can decide to only colocate (on threads
on the same core) processes from the same user [12].
Finally, CPU-level mitigations could be deployed in the future,
possibly improving both security and performance over existing
mitigations. For instance, alternatives to SMT can be considered
trigger [24, 27]. The return address on the stack has also been the
target of other work, showing that through load-to-store forward-
ing it can be speculatively overwritten, leading to a speculative
execution sibling of the classic stack buffer overflow [22].
Meltdown [26] (“Rogue Data Cache Load”), which was also re-
vealed in early 2018 exploits out-of-order execution: a memory
load instruction immediately after a high latency instruction might
fetch data into the cache even if it is not permitted to access the
actual memory location. The reason is that on certain CPUs, the
corresponding permission check is not on the critical path for the
data fetch and the exception is only triggered after the data fetch.
On such CPUs this allows reading arbitrary kernel memory from
userspace. Similarly, also privileged system register can be read
(“Rogue System Register Read”). The more recent Foreshadow [34]
attacks a similar phenomenon, “L1 Terminal Fault” in Intel nomen-
clature. If an instruction accesses a virtual address that is not in the
translation lookaside buffer (TLB) and the corresponding page table
entry’s (PTE) present bit is not set, this is referred to as a “terminal
fault”. During out-of-order execution, the processor computes a
physical address from the PTE, which is used for a lookup in the L1
data cache. Until the instruction retires and a page fault is raised,
cached data is forwarded to dependent instructions, which can be
used in an attack. This bypasses various access checks, including
SGX protection, extended page table address translation and system
management mode (SMM) checks, thus affecting virtualization and
SGX enclaves (enclave data is not encrypted in L1D). Also related to
out-of-order execution is the speculative store bypass [3, 20]: for a
code sequence of a dependent store and a load instruction, the load
instruction, if executed out-of-order before the store might retrieve
stale data from memory that can be used in a side channel. This
happens in cases where the CPU cannot detect the dependency in
the code sequence.
Transient execution attacks are not only a local security issue
that requires a victim device to execute attacker-controlled code.
As Netspectre [29] demonstrates they also work remotely. While
being less effective, they are still powerful enough to break, for
example, address space layout randomization.
Cache Side Channels. Cache side channels leverage timing
differences in accesses to different tiers of the memory hierarchy.
Accesses to cached locations will be faster, whereas accesses to
uncached locations will be slower, as the data needs to be fetched
from main memory. This principle applies to both data and instruc-
tions: Execution of code whose instructions are not cached will
take longer than execution of cached code.
To use an evict-and-time cache side channel, one first primes
the cache by executing a victim function and then measures how
long the function takes to execute – this is the baseline run. One
can now compare this baseline against further executions of the
function, with different cache sets evicted. If the time the function
takes to execute is slower than the baseline, the victim function
depends on the evicted cache set.
To use a prime-and-probe cache side channel, one first primes the
cache with known attacker-controlled addresses. One then waits for
the victim code to run. Afterwards, one measures the access time to
addresses used for probing: it will be low for addresses touched by
the victim code and high for others. The difference to evict-and-time
is that the attacker measures her own operation in contrast to the
execution of victim code. Both evict-and-time and prime-and-probe
have been extensively used to attack AES implementations [28, 32].
Another technique that became popular with attacks leveraging
a shared last-level cache (LLC) is flush-and-reload. It requires an
instruction that allows an attacker to flush a certain cache line, such
as clflush on x86_64. In a corresponding attack, the attacker first
flushes a cache line and then waits for the victim code to execute.
Afterwards the attacker times the access to the address, which
will be fast if the victim accessed (reloaded) it and slow otherwise.
Flush-and-reload is similar to prime-and-probe, but much more
fine-grained as individual cache lines can be targeted. It has been
used to leak information from the LLC, which is typically shared
among multiple CPU cores [36]. Related to flush-and-reload, flush-
and-flush [16] is based on the observation, that clflush will take
less time to execute when it is run on a location that is not cached.
The advantage over flush-and-reload is that no actual access that
would pull data into the cache is performed, making the attack
stealthier.
Finally, prime-and-abort leverages Intel’s transactional memory
mechanism to detect when a cache set has been evicted without
the need to probe the cache [8]. In contrast to all previous cache
side channels, it does not need to time an operation. Transactional
memory operations require transactional data to be buffered in the
cache which has limited space. A transaction set up by the attacker
will abort if the victim accesses a critical address.
Other Side Channels. Mitigations against cache-based side
channels have led researchers to explore other shared resources
as well. TLBleed [14] shows how the TLB can be used as a side
channel to leak a cryptographic key. Aforementioned Netspectre-
AVX [29] uses a side channel based on AVX instructions. This side
channel exploits the fact that the execution unit processing those
instructions employs aggressive power saving. When such units
have not been used for a long time, they execute much slower.
In particular, execution-unit-sharing-based side channels in the
SMT settings have been studied as early as in 2006: Wang and
Lee [35] demonstrate a multiply-based covert channel making use
of contention on execution units. Aciicmez and Seifert [1] extend
this work by analyzing its applicability as a side channel. Anders
Fogh [11] proposes a generalized result by analyzing contention
results of the cross product of 12 curated instructions. Finally, Ports-
mash [2], concurrently and independently demonstrates how port
contention can be used to leak sensitive cryptographic material
from OpenSSL. Portsmash relies on a known vulnerable implemen-
tation of OpenSSL, and therefore does not require any mitigation
beyond avoiding vulnerable code patterns. In contrast, SMoTh-
erSpectre does not require a secret-dependent control flow by
combining port contention with BTI, and thereby showing broader
applicability of the port contention side channel. Finally, in contrast
with all previous works, this work provides a characterization of
this side channel, including an analysis for low number of victim
instructions.
8 CONCLUSION
We further our understanding of possible attacks in the space of
speculative execution. This is crucial to design suitable defenses
and to apply them to the right systems. In particular, we show
that Branch Target Injection attacks against applications that do
not load attacker-provided code are feasible, by crafting an exploit
for the OpenSSH server and encryption using OpenSSL. To this
end, we present a precise characterisation of port contention, the
non cache-based side channel we use for the attack, and develop
a tool to help us find suitable gadgets in existing code. We will
open-source our proof of concept implementation, gadget finder, as
well as the data of our measurements to enable others to study this
interesting side channel. As a consequence, it is now clear that in
SMT environments defenses solely relying on mitigating cache side
channels, or solely relying on reverting microarchitectural state
after speculative execution, are insufficient.
In the immediate future, implementing existing BTI mitigations is
sufficient to prevent SMoTherSpectre. Future work may mitigate
such attacks with lower performance overhead and better security
guarantees, for instance through side-channel resistant ways of
designing thread-level parallelism in upcoming CPUs.
REFERENCES
[1] Onur Aciicmez and Jean-Pierre Seifert. 2007. Cheap hardware parallelism implies
cheap security. In Fault Diagnosis and Tolerance in Cryptography, 2007. FDTC 2007.
Workshop on. IEEE, 80–91.
[2] Alejandro Cabrera Aldaya, Billy Bob Brumley, Sohaib ul Hassan, Cesar Pereida
García, and Nicola Tuveri. 2018. Port Contention for Fun and Profit. Cryptology
ePrint Archive, Report 2018/1060. https://eprint.iacr.org/2018/1060.
[3] AMD. 2018. Speculative Store Bypass Disable. https://developer.amd.com/
wp-content/resources/124441_AMD64_SpeculativeStoreBypassDisable_
Whitepaper_final.pdf.
[4] Zack Bloom. 2018.
Cloud Computing without Containers.
blog.cloudflare.com/cloud-computing-without-containers/.
[5] Claudio Canella, Jo Van Bulck, Michael Schwarz, Moritz Lipp, Benjamin von
Berg, Philipp Ortner, Frank Piessens, Dmitry Evtyushkin, and Daniel Gruss.
2018. A Systematic Evaluation of Transient Execution Attacks and Defenses.
https://arxiv.org/abs/1811.05441.
[6] Intel Coorporation. 2016. Intel 64 and IA-32 architectures optimization reference
https://
manual.
shotgun/.
[7] Jonathan Corbet. [n.d.]. Taming STIBP. https://lwn.net/Articles/773118/.
[8] Craig Disselkoen, David Kohlbrenner, Leo Porter, and Dean Tullsen. 2017.
Prime+Abort: A Timer-Free High-Precision L3 Cache Attack using Intel TSX. In
USENIX Security Symposium.
[9] Dmitry Evtyushkin, Dmitry Ponomarev, and Nael Abu-Ghazaleh. 2016. Jump
over ASLR: Attacking branch predictors to bypass ASLR. In The 49th Annual
IEEE/ACM International Symposium on Microarchitecture. IEEE Press, 40.
[10] Agner Fog. [n.d.].
Instruction tables: Lists of instruction latencies, through-
puts and micro-operation breakdowns for Intel, AMD and VIA CPUs. https:
//www.agner.org/optimize/instruction_tables.pdf.
[11] Anders Fogh. [n.d.]. Covert Shotgun. https://cyber.wtf/2016/09/27/covert-
[12] Anders Fogh and Christopher Ertl. [n.d.]. Wrangling with the Ghost: An
inside story of mitigating speculative execution side channel vulnerabilities.
https://i.blackhat.com/us-18/Thu-August-9/us-18-Fogh-Ertl-Wrangling-
with-the-Ghost-An-Inside-Story-of-Mitigating-Speculative-Execution-Side-
Channel-Vulnerabilities.pdf.
[13] Google [n.d.]. Google Compute Engine FAQ. https://cloud.google.com/compute/
docs/faq. Accessed: 2019-02-13.
[14] Ben Gras, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2018. Translation
Leak-aside Buffer: Defeating Cache Side-channel Protections with TLB Attacks.
In USENIX Security Symposium.
[15] Daniel Gruss, Moritz Lipp, Michael Schwarz, Richard Fellner, Clémentine Mau-
rice, and Stefan Mangard. 2017. Kaslr is dead: long live kaslr. In International
Symposium on Engineering Secure Software and Systems. Springer, 161–176.
[16] Daniel Gruss, Clémentine Maurice, Klaus Wagner, and Stefan Mangard. 2016.
Flush+Flush: A Fast and Stealthy Cache Attack. In Detection of Intrusions and
Malware, and Vulnerability Assessment.
[17] Nadia Heninger and Hovav Shacham. 2009. Reconstructing RSA Private Keys
from Random Key Bits. In Advances in Cryptology - CRYPTO 2009, 29th Annual
International Cryptology Conference, Santa Barbara, CA, USA, August 16-20, 2009.
Proceedings (Lecture Notes in Computer Science), Shai Halevi (Ed.), Vol. 5677.
Springer, 1–17. https://doi.org/10.1007/978-3-642-03356-8_1
[18] Jann Horn. 2018.
Reading privileged memory with a side-channel.
https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-
with-side.html. Project Zero 3 (2018).
[19] Ralf Hund, Carsten Willems, and Thorsten Holz. 2013. Practical timing side
channel attacks against kernel space ASLR. In 2013 IEEE Symposium on Security
and Privacy. IEEE, 191–205.
[20] Secure Windows Initiative. 2018.
Speculative Store Bypass.
https:
//blogs.technet.microsoft.com/srd/2018/05/21/analysis-and-mitigation-
of-speculative-store-bypass-cve-2018-3639/.
[21] Khaled N Khasawneh, Esmaeil Mohammadian Koruyeh, Chengyu Song, Dmitry
Evtyushkin, Dmitry Ponomarev, and Nael Abu-Ghazaleh. 2018. SafeSpec: Ban-
ishing the Spectre of a Meltdown with Leakage-Free Speculation. arXiv preprint
arXiv:1806.05179 (2018).
[22] Vladimir Kiriansky and Carl Waldspurger. 2018. Speculative Buffer Overflows:
Attacks and Defenses. https://people.csail.mit.edu/vlk/spectre11.pdf.
[23] Paul Kocher, Daniel Genkin, Daniel Gruss, Werner Haas, Mike Hamburg, Moritz