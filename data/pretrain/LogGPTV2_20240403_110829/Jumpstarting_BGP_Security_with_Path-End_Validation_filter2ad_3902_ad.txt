attacks. These extensions, similarly to path-end validation,
satisfy the constraints, discussed in Section 2, on providing a
deployable and effective defense. In particular, these exten-
sions do not involve any changes to BGP routers.
We ﬁrst show that at no additional deployment cost, path-
end validation can be extended to validate longer path-sufﬁxes.
We then show how the addition of a single-bit ﬁeld to the
path-end record can mitigate certain types of “route-leakage”
incidents. We incorporated these extensions into our open-
source implementation, presented in Section 7.
We last discuss which path-manipulation attack strategies
remain at the attacker’s disposal despite these extensions and
discuss their effectiveness.
6.1 Validating Longer Path-Sufﬁxes
We introduced path-end validation as a means to ensure
that the last AS-hop on a BGP path is valid. Observe, how-
ever, that the adjacency list in the path-end record, allows to
verify whether any link to/from an adopting AS on a path is
consistent with the path-end record for that AS, even if the
350
00.10.20.30.40.50102030405060708090100Attacker’s Success RateExpected Deployment (top ISPs)1. Next-AS2. BGPsec in partial deployment3. 2-hop4. BGPsec (full deployment, legacy allowed)5. RPKI (full Deployment)00.10.20.30.40.50102030405060708090100Attacker’s Success RateExpected Deployment (top ISPs)1. Next-AS2. BGPsec in partial deployment3. 2-hop4. BGPsec (full deployment, legacy allowed)5. RPKI (full Deployment)00.10.20.30.40.50102030405060708090100Attacker’s Success RateExpected Deployment (top ISPs)1. Next-AS2. BGPsec in partial deployment3. 2-hop4. BGPsec (full deployment, legacy allowed)5. RPKI (full Deployment)(a) Global security evaluation.
(b) Protection of top content providers.
Figure 9: Attacker success rate for different strategies as function of adopters under partial RPKI deployment.
adopter is not the origin (i.e., last) AS. Consider, for exam-
ple, the scenario that both the last and the next-to-last ASes
on a BGP path are adopters. Any other adopter should be
able to validate the 2-AS-hops sufﬁx of that path by examin-
ing the path-records of these two ASes. In general, if the last
k ASes on a BGP path published path-end records, then all
adopters can validate the last k AS-hops on that path.
Let us revisit the deployment scenario illustrated in Fig-
ure 1, in the event that AS 2 chooses to launch the 2-hop at-
tack against AS 1 by advertising the false route 2-300-1, this
attack will be detected since AS 300 is an adopter and the at-
tacker is not one of its valid neighbors. Instead, the attacker,
AS 2, may exploit AS 1’s only legacy neighbor, AS 40, and
announce the route 2-40-1 to avoid detection. As adoption
gains traction, however, the attacker’s options are incremen-
tally limited. Speciﬁcally, when AS 40 will also adopt, AS 1
will become protected from 2-hop attacks.
We describe, in Section 7, how to enforce path-end vali-
dation rules without changes to today’s router conﬁguration
interface. We show that ﬁltering BGP paths with invalid
links, as explained above, has the exact same complexity as
enforcing these ﬁlters only for the last AS-hop on the path.
Hence, extending path-end validation to validate longer path-
sufﬁxes comes at no extra cost.
We point out, however, that as our results in Section 4
indicate, k-hop attacks, for k > 1, are not very effective.
Hence, while validating path-sufﬁxes longer than the 1-AS-
hop (i.e., validation beyond the last hop) can help in reducing
the effectiveness of attacks is speciﬁc scenarios, this cannot,
on average, signiﬁcantly improve over path-end validation
even if ubiquitously adopted.
6.2 Mitigating Route-Leaks
Route leakage is an incident where an AS propagates a
BGP path advertisement in a manner that violates its own
path-export policy, e.g., announces a BGP path from one
provider to another provider. This can be the result of a
misconﬁguration or, alternatively, an attack that leverages
a compromised BGP router. Route leaks circumvent even
full deployment of the most powerful BGP security mech-
anisms, e.g., BGPsec [22], and are a bothersome security
vulnerability in practice, as evidenced by recent inadvertent
incidents [3, 4, 28].
351
The vast majority of ASes on the Internet (over 85%) are
stubs, i.e., have no AS customers and so do not provide tran-
sit services to other ASes. We observe that RPKI can easily
be extended to protect from route-leak attacks (e.g., due to
conﬁguration errors or compromised equipment) by stubs.
Speciﬁcally, path-end validation can be extended to allow a
stub to specify that its AS number should only appear at the
end of a BGP path (since stubs, by deﬁnition, do not transit
trafﬁc to external destinations). To this end, a Boolean ﬂag
is added to path-end records to indicate whether the origin
provides may transit trafﬁc or should only appear at the end
of the route. Observe that this implies that in the event of a
route-leak from a stub adopter, all other adopters will indeed
not fall victim to the attack. Consider again the network in
Figure 1 and assume that AS 1’s router is compromised and
propagates a BGP advertisement received from its provider
AS 40 to its other provider AS 300 (e.g., advertising a pop-
ular service such as Amazon as in a recent incident [28]).
The new “non-transit indicator” ﬂag allows AS 300 to dis-
card this BGP advertisement, preventing further dissemina-
tion into the network (e.g., to its own provider, AS 200).
We point out that this can be viewed as a non-local ana-
logue of defensive ﬁltering [22], i.e., ISPs policing the BGP
advertisements of their stub AS customers.
To measure how deployment of this simple extension to
RPKI can aid in mitigating route leaks we use the simulation
framework in Section 4. We evaluate our defense under two
scenarios: ﬁrst when the victim is a randomly chosen AS
(chosen uniformly), and second when the victim is a large
content provider from the list in [33]. The route leaker in
both cases is a multi-homed stub AS that advertises a BGP
path it learns to the victim to all of its neighbors (excluding
the one it obtained that route from) in a manner that violates
the Gao-Rexford export condition (see Section 3).
Figure 10 describes our results both for the general case
and for content providers. We observe that since the leaked
route must contain at least two hops (often more), route leak-
age typically has lower success rate than route-manipulation
attacks (e.g., the next-AS attack), unless those of the latter
type are prevented by a defense mechanism (path-end vali-
dation, BGPsec, etc.). We ﬁnd that our extension allows to
mitigate the route-leakage threat, halving its effect already
with 10 adopters (both when the victim is a random AS and
00.10.20.30.40.50102030405060708090100Attacker’s Success RateDeployment (top ISPs)1. Prefix Hijack2. RPKI (full deployment)00.10.20.30.40.5020406080100Attacker’s Success RateDeployment (top ISPs)1. Prefix Hijack2. RPKI (full deployment)BGP advertisements. Even though such an AS can always
break connectivity by simply dropping all packets, the au-
thenticity and conﬁdentiality of the communication can be
protected using cryptographic protocols such as IPsec [26]
and TLS [16].
We conclude that eliminating (sub)preﬁx hijacking and
next-AS attacks indeed signiﬁcantly limits the ability of the
attacker.
7. PROTOTYPE
We present a prototype implementation, which comple-
ments RPKI and allows to deploy path-end validation with
today’s routing infrastructure. We envision this prototype
as a ﬁrst step, providing an immediate defense against path-
manipulation attacks, before path-end validation is integrated
into RPKI. To allow the community to deploy and experi-
ment with path-end validation, our implementation is open-
source and available at https://github.com/yossigi/pathend.
7.1 Implementation Details
Our implementation uses path-end records, where an ori-
gin AS holding an RPKI certiﬁcate speciﬁes a list of ap-
proved neighboring ASes and whether it provides transit ser-
vices. We use the following ASN.1 syntax to deﬁne the
record format:
PathEndRecord ::= SEQUENCE {
timestamp Time,
origin
adjList SEQUENCE (SIZE(1..MAX)) OF ASID,
transit_flag BOOLEAN
ASID,
}
Path end records are stored in public repositories, simi-
lar to RPKI’s publication points [24]. We envision that the
two repositories of both mechanisms may be co-located to
avoid establishment of additional services, however, to sup-
port path-end validation on today’s Internet, i.e., before RPKI
publication points support distribution of path-end records,
we implement the system’s repositories. When a reposi-
tory receives an AS’s path-end record to store (via HTTP
POST), along with a signature from the origin AS, it uses that
AS’s RPKI certiﬁcate to verify the signature over its path-
end record (we utilize RPKI’s certiﬁcate revocation lists to
remove records in case the signing key was revoked), as well
as validates that the timestamp speciﬁed in the record is not
before an already existing entry for the same origin. See Fig-
ure 11a. An AS can update or delete its path-end records us-
ing a signed announcement sent to the repositories, similarly
to Route Origin Authorization records (ROAs) in RPKI.
Since BGP routers do not yet accept path-end records, we
also implement an “agent application” that updates period-
ically from the repositories and conﬁgures BGP routers in
the adopter’s network with path-end-ﬁltering policies. See
illustration in Figure 11b. To avoid trusting the path-end
record repository (until the trusted RPKI publication points
support distribution of path-end records), the agent retrieves
the corresponding record signature, which path-end reposito-
ries store along with the records. It then veriﬁes the signature
Figure 10: Path-end validation as route-leaks defense
when it is one of the content providers) and eventually reach-
ing 0.5% success rate when the top 100 ISPs adopt.
6.3 What is Left?
We discussed above two extensions to RPKI designed to
prevent path-manipulation attacks beyond next-AS attacks.
We now investigate which path-manipulation attacks are not
eliminated by path-end validation and these two extensions,
even when fully deployed. Understanding how such attacks
can be completely eliminated in a deployable manner (e.g.,
without resorting to heavyweight online cryptography or blowup
in conﬁguration complexity) remains an open question.
Advertising existent, yet unavailable paths. Observe that
the ﬁrst of the two extensions to RPKI discussed above, when
ubiquitously adopted, prevents an attacker from advertising
a nonexistent path without being detected. This does not,
however, prevent the attacker AS from advertising an exis-
tent path, even though that path was never advertised to it by
a neighboring AS. Importantly, however, unless the attacker
is directly connected to the victim, such an attack involves
announcing a path of length at least 2 and therefore, as shown
in Section 4, is not very effective.
Colluding attackers. As in essentially all past research on
BGP security, our threat model does not consider the pos-
sibility that multiple attackers collude. An attacker AS a1
can, for instance, approve a colluding attacker AS a2 as a
neighbor in its path-end record, thus enable a2 to advertise
the AS-path (a2, a1, v) to a victim v that neighbors AS A.
However, this attack, too, results in a path of length 2 or
more, and so is signiﬁcantly less harmful (on average) than
next-AS attacks (Section 4).
Route leaks by ISPs. Our second extension to RPKI pre-
vents (in full deployment) all route leakage from stubs, yet
does not prevent route leaks by ISPs. We point out, however,
that, as before, unless the route leaker happens to be the di-
rect neighbor of the victim, this attack too cannot be more
effective than the 2-hop attack.
Data-plane attacks. Similarly to BGPsec and other propos-
als for securing the BGP control plane, path-end valiation
does not prevent data-plane attacks, in which a malicious
or faulty router advertises a legitimate BGP path but for-
wards data trafﬁc in a manner that is incompatible with its
352
00.010.020.030.040.050.060.070.080102030405060708090100Attacker’s Success RateDeployment (top ISPs)1. Victims chosen uniformly2. Victims are large content providers(a) AS Administrator stores path-end record
(b) Agent application conﬁgures ﬁltering rules
Figure 11: Path-end validation deployment
using the RPKI certiﬁcates retrieved from RPKI’s publica-
tion points (similarly to the veriﬁcation process performed
by the repository). The agent retrieves each update from a
random path-end repository, so as to ensure that a compro-
mised repository cannot remove a record or provide an ob-
solete image of the database, i.e., prevent “mirror world at-
tacks” (see [29] for discussion on such attacks within RPKI).
The agent application supports an automated mode, where
the network administrator provides the credentials needed to
conﬁgure a BGP router, and agent automatically connects to
the router to deploy ﬁltering rules according to the path-end
records it retrieves. The agent also supports a manual mode,
where it only outputs the ﬁltering policies to a router conﬁg-
uration ﬁle, which the administrator can later apply.
7.2 Deploying Path-End Filtering Rules
We next describe how the agent conﬁgures ﬁltering rules
for BGP advertisements on today’s routers. For each AS, the
agent deploys at most two ﬁltering rules. This results in less
than a ﬁfth of the rules required for origin authentication with
RPKI, which involves a ﬁltering rule per IP-preﬁx, origin-
AS pair (there are roughly 53K ASes advertising over 590K
preﬁxes). We therefore believe that path-end validation can
scale to support the entire set of ASes.
We note that if path-end validation were fully integrated
into RPKI (as advocated here), then it could piggyback RPKI’s
existing ﬁltering mechanism, i.e., extend RPKI’s origin au-
thentication policies, to support validation of last-hop. This
would allow to establish ﬁne-grained path-end ﬁltering mech-
anism on a per-preﬁx, rather than per-AS granularity, with-
out adding to the number of ﬁltering rules established by
vanilla RPKI.
To illustrate the ﬁltering rules we use the network described
in Figure 1, and present the routing policy for protecting
AS1, whose adjacent ASes are 40, 300. Our description uses
the Cisco IOS command-line interface. We veriﬁed that routers
from other vendors (e.g., Juniper Networks) support the same
functionality.
We ﬁrst use AS1’s path-end record to create the follow-
ing access list (named as1), which blacklists routes contain-
ing (invalid) links to AS1 from non-adjacent ASes and, in
case AS1 is a stub, i.e., does not provide transit services,
routes where AS1 is an intermediate hop on the path.
// disallow any AS but 40 or 300 to
// advertise a link to AS1
ip as-path access-list as1 deny _[^(40|300)]_1_
// if AS1 is a stub, deny routes where
// AS1 is an intermediate hop
ip as-path access-list as1 deny _1_[0-9]+_
The agent creates another access list (named allow-all) to
allow all other routes. This access list is global, i.e., created