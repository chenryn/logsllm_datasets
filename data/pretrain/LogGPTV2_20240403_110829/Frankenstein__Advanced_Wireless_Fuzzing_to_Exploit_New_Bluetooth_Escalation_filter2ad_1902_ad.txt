Within the receive header done interrupt, the packet header
is available. Besides, it is checked whether the remote device
acknowledged the previous transmission. If no retransmission
is required, the next packet is put into the ACL task storage for
transmission. Those LMP packets which the remote device
acknowledged are passed back to the LM for ﬁnal processing.
Table 2: Calling convention for an ACL slave connection.
QEMU
baseline
Frankenstein with
heap sanitizer
Unicorn with
heap sanitizer
Figure 4: Performance comparison of heap sanitizer with
Frankenstein and Unicorn hooks in LMP fuzzing.
Bluetooth Clock
0b??00
0b??01
0b??10
0b??11
phy_status
Receive header done
Receive done, Slot01 interrupt
Transmit done
Slot11 interrupt
USENIX Association
29th USENIX Security Symposium    27
Once the packet has been received, receive done is called.
The receive buffer is unmapped, and the packet is saved to the
ACL task storage. During the Slot01 interrupt, the hardware
is conﬁgured to transmit the next packet. In addition, the
received packet is handed to the corresponding thread. LMP
packets are passed to the LM thread. ACL packets are passed
to the bttransport thread. Transmit done will unmap the
transmit buffer. This process repeats with the Slot11 interrupt.
5.6 Code Coverage
We came up with a different representation for coverage-
guided fuzzing of protocols. Instead of handling all the input
data as a single Binary Large Object (BLOB), we represent
it as a sequence of packets, where packets and sequences are
mutated separately. This enables the fuzzer to reorder already
known packets to increase coverage. We start with a single se-
quence containing only one packet that consists of null-bytes.
For each execution, a random sequence is chosen from the
population and mutated. To distinguish the effect of mutating
sequences from mutating packets, only one of those is per-
formed per measurement. If the mutation of a single packet
increased the code coverage, the sequence containing the new
packet is added to the population. If mutating a sequence
increased the code coverage, it is also added to the population.
Sequence mutations are reordering packets, inserting known
packets from other sequences, or merging two sequences.
Both approaches were compared with the same set of mu-
tations over two million test cases, as shown in Figure 5. We
previously implemented this reference implementation [39].
Packet level with BlueZ
Packet level
Classic BLOB
4,000
3,000
2,000
s
k
c
o
l
b
c
i
s
a
b
n
i
e
g
a
r
e
v
o
C
1,000
100
101
102
Executed test cases (log scale)
103
104
105
106
Figure 5: LMP fuzzing strategy comparison.
Table 3: Coverage increase by new zero-click attack surfaces.
Scenario
LMP fuzzing
LMP fuzzing with BlueZ HCI
Attach to stack hciconfig hci1 up
Attach to stack hcitool scan
Attach to stack hcitool cc
Attach to stack hcitool lescan
Attach to stack hcitool lecc
Total
Coverage
2.76 %
0.56 %
2.04 %
0.59 %
1.04 %
0.57 %
1.85 %
9.40 %
Our adaptive approach ﬁnds more blocks in a shorter amount
of time. The total coverage for LMP fuzzing converges to
2.76 %. Introducing HCI support increases the coverage fur-
ther by 0.56 %, as HCI handlers and the UART receive state
machine are invoked.
We evaluate the total code coverage during LMP and BCS
task fuzzing. This was obtained by using QEMU with the
translate_block trace option. The total code coverage is
then loaded to IDA Lighthouse plugin [24] to determine the
percentage coverage shown in Table 3. Each row shows the
amount of new code reached using the described method.
The total code coverage we reached so far is 9.40 %. How-
ever, we only analyzed speciﬁc scenarios prior to pairing,
which enable potential zero-click attacks. This focus is rea-
sonable as the Patchram is limited and Broadcom will likely
not ﬁx issues that require pairing. The code coverage reached
is comparable to the size of the related parts within the Blue-
tooth speciﬁcation. For example, we reached 3.32 % code
coverage by fuzzing LMP, and the chapter containing LMP
in the speciﬁcation is only 4.05 % of the total Bluetooth spec-
iﬁcation in pages [12, p. 567ff]. Also, Broadcom provides
vendor-speciﬁc additions and utilizes the ThreadX operating
system, which are not part of the speciﬁcation.
As also shown in Table 3, coverage increases by attach-
ing the ﬁrmware to the host stack. This realistic behavior is
possible due to Frankenstein’s full-stack approach. Fuzzers
that do not implement thread switches and only focus on one
speciﬁc protocol handler cannot reach these protocol parts
by design. This includes CVE-2019-11516 that requires inter-
action between the BCS kernel and link manager. Moreover,
as Frankenstein includes host stack behavior, the identiﬁed
issues will likely reproduce on physical devices.
Coverage also offers further insights. Even with the partial
symbols, identifying relevant functions is complex. Simply
calling a function in emulation and observing the execution
can help to gain valuable high-level insights into the code.
For example, 420 functions end on Rx and potentially receive
data. Observing coverage enables us to determine which of
these functions are important and in which reception handler
context they are called.
5.7 Adding New Firmware
Apart from this use case described here, Frankenstein is also
capable of fully emulating ﬁrmware if no memory snapshot
is available but only the compiled ﬁrmware including debug
symbols. ELF is a common format of these images that can be
directly imported into Frankenstein. Without a memory snap-
shot, hardware initialization needs to be performed, which
is challenging in complex environments. In the use case not
described here we were able to set up a working emulation
within half a week, including support of buttons, Serial Pe-
ripheral Interface (SPI), and Controller Area Network (CAN)
interfaces of a smaller ﬁrmware.
28    29th USENIX Security Symposium
USENIX Association
Our workﬂow for integrating new ﬁrmware looks as fol-
lows. The ﬁrmware is executed until a fault—such as inﬁnite
loop or illegal instruction–occurs. Then, we ﬁx the root cause
of this. We add function tracing hooks to function calls that
seem to be relevant. Those function calls are displayed dur-
ing emulation to show the program ﬂow. Prior to functions
or interrupt handlers, hardware registers and buffers can be
modiﬁed, e.g., using read. This includes clock values and
receive buffers of external hardware. Then, coverage-guided
fuzzing can be used to verify how the input is processed by
the ﬁrmware.
6 Fuzzing Results and Exploitation
This section describes the heap exploitation technique and
documents three heap overﬂows.
6.1 Heap Corruption
None of the observed devices implements any exploit miti-
gation, such as Data Execution Prevention (DEP) or Address
Space Layout Randomization (ASLR). The memory allocator
described in Section 5.3 can be easily exploited. With a heap
overﬂow, an attacker can control a free list pointer to point to
any location. This pointer is treated as a valid BLOC buffer due
to repetitive allocations, as depicted in Figure 6. This leads
to a write-what-where gadget and allows for Remote Code
Execution (RCE). The technique has already been discussed
for the exploitation of Marvell Wi-Fi controllers, although it
was not used in the actual exploit [43].
6.2 Classic Bluetooth Device Scanning EIR
(CVE-2019-11516)
This section describes a heap overﬂow exploit in device in-
quiry, utilizing the full stack [12, p. 513]. As a device scans
for other devices, these can respond with an EIR. An EIR con-
tains additional information such as the device name, which
is copied into an HCI event to be displayed to the user to list
available devices for pairing. The EIR length is extracted from
the payload header and subject to the same physical-layer con-
straints such as data rate and maximum packet duration. Due
to these physical-layer restrictions, the ﬁrmware skips further
length checks prior to copying an EIR.
Figure 7 shows the ACL header format [12, p. 482]. The
packet length is followed by Reserved for Future Use (RFU)
bits, which should be set to zero. The ﬁrmware includes these
bits in the packet length. Non-zero RFU bits exceed the buffer
length of the HCI event.
The hardware buffer holding the payload is not restricted
to the payload length of the speciﬁc packet being parsed.
Even worse, it contains a duplicate of the packet payload, as
depicted in Figure 8. This makes memory located after the
original packet’s payload predictable.
We allocate three buffers in a row within the affected BLOC
pool to exploit this heap overﬂow with a write-what-where
gadget. This cannot be achieved using the EIR packets, as the
data rate is too low compared to the UART connection to the
host—the BLOC pool would be cleared faster than ﬁlled.
We exploit that the host issues an HCI_Remote_Name_
Request command when an unknown device connects [12,
p. 1815ff]. The returned HCI_Remote_Name_Request_
Complete event has the correct size to be allocated in the
affected BLOC pool. The attacker-controlled remote name is
read via LMP in multiple packets into that buffer. By omitting
the last packet and silently dropping the connection, the buffer
is kept for several seconds until a timeout occurs. Repeating
this process, we can write arbitrary memory, resulting in RCE.
The over-the-air PoC works on various devices, as listed
in Table 4. By overﬂowing the BLOC header with an invalid
address, the Bluetooth chip of the device under test crashes.
The PoC running on the CYW20735 evaluation board changes
the device name to the payload and MAC address to pretend to
be multiple physical devices. This method works well against
Android and Linux hosts.
Overﬂow
Affected
Corrupted
Free
Free
BLOC Struct
Target
(a) Layout immediately after a heap overﬂow.
Free (Head)
Corrupted
Free
Free
BLOC Struct
Target
(b) Layout after a heap overﬂow and a free of the affected buffer.
Figure 6: Effect of overﬂowing a free BLOC buffer.
Validated in hardware
Should be zero
LLID
2 B
Flow
1 B
Length
10 B
RFU
3 B
Figure 7: Payload header format for multi-slot ACL packets
and all Enhanced Data Rate (EDR) ACL packets.
25 25 25 25 25 25 25 25 25 25 25 25 ca fe ba be MAC address
be ef e0 04 c8 01 02 03 04 05 06 07 08 09 0a 0b EIR
0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db
dc dd de df f4 d6 41 9a 64 65 66 67 68 69 6a 6b Duplicated
6c 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b
7c 7d 7e 7f 00 26 26 26 26 26 26 26 26 26 26 26
sufﬁx
Figure 8: Overﬂowing hardware buffer that allows control
over more bytes than the actual payload length.
USENIX Association
29th USENIX Security Symposium    29
Table 4: Devices vulnerable to CVE-2019-11516.
Table 5: Devices vulnerable to CVE-2019-13916.
Chip
BCM20702
BCM4335C0
BCM4345B0
BCM4358A3
BCM4345C1
Unknown
BCM20707
BCM4347B0
BCM4347B1
BCM4357
CYW20735B1
BCM4375B1
CYW20819A1
Device
Thinkpad T430
Nexus 5, Xperia Z3 Compact,
Samsung Galaxy Note 3, LG G4
iPhone 6 (unﬁxed in iOS 12.4)
Samsung Galaxy S6, Nexus 6P
iPhone SE (prior iOS 12.4)
Samsung Galaxy A3 (2016)
Fitbit Ionic
Samsung Galaxy S8
iPhone 8/X/XR (prior iOS 12.4)
Samsung Galaxy 9+/Note 9
Evaluation Board
Samsung Galaxy S10e/S10/S10+
Evaluation Board
Build Date
< 2010?
Dec 11 2012
Jul 15 2013
Oct 23 2014
Jan 27 2015
Unknown
Unknown
Jun 3 2016
Oct 11 2016
Unknown
Jan 18 2018
Apr 13 2018
May 22 2018
Vuln
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
No
Yes
The Bluetooth stack on Apple devices does not allow for
multiple unauthenticated connections simultaneously and is
not covered by our PoC. We extracted ROM and Patchram
from jailbroken iOS 12.4 devices with InternalBlue and can
conﬁrm that the iPhone SE, 7, and 8/X/XR received a patch in
August 2019 or earlier. On the iPhone 6, the vulnerability is
still unpatched, but all Patchram slots are already occupied.
Since Android needs to support a lot of different hardware,
and vendors need to apply individual ﬁxes, patches take a
bit longer. A ﬁx was issued on August 5 2019, and it took
Samsung until mid-September to roll out these patches for
their devices.
The EIR vulnerability requires users to scan for devices.
We were able to observe device scanning in practice, for
example, every few hours inside a residential accommodation.
However, we do not know which apps or user actions did
trigger device scanning. Some apps require frequent scanning.
Bhaskar et al. built a smartphone app used by law enforcement
that scans for credit card skimmers using classic Bluetooth [7].
In our observations, location services only use BLE device
scanning, but no classic device scanning.
6.3 Any BLE Packet (CVE-2019-13916)
This section describes a heap overﬂow in the reception of
Bluetooth Low Energy (LE) Protocol Data Units (PDUs).