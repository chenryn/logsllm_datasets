### Receive Header Done Interrupt

Upon the completion of the receive header done interrupt, the packet header is available. Additionally, the system checks whether the remote device has acknowledged the previous transmission. If no retransmission is required, the next packet is queued in the ACL task storage for transmission. LMP packets that have been acknowledged by the remote device are passed back to the Link Manager (LM) for final processing.

### Performance Comparison

**Table 2: Calling Convention for an ACL Slave Connection**

| Configuration | QEMU Baseline | Frankenstein with Heap Sanitizer | Unicorn with Heap Sanitizer |
|---------------|---------------|----------------------------------|------------------------------|
| Performance   | [Baseline]    | [Frankenstein]                   | [Unicorn]                    |

**Figure 4: Performance comparison of heap sanitizer with Frankenstein and Unicorn hooks in LMP fuzzing.**

### Bluetooth Clock and Interrupts

- **Bluetooth Clock:** 
  - `0b??00`
  - `0b??01`
  - `0b??10`
  - `0b??11`

- **Interrupts:**
  - `phy_status`: Receive header done
  - `Receive done, Slot01 interrupt`
  - `Transmit done`
  - `Slot11 interrupt`

### Packet Reception and Transmission

Once a packet is received, the `receive done` function is called. The receive buffer is unmapped, and the packet is saved to the ACL task storage. During the `Slot01 interrupt`, the hardware is configured to transmit the next packet. The received packet is also handed to the corresponding thread. Specifically, LMP packets are passed to the LM thread, while ACL packets are passed to the `bttransport` thread. The `transmit done` function unmaps the transmit buffer. This process repeats with the `Slot11 interrupt`.

### Code Coverage in Fuzzing

We developed a novel representation for coverage-guided fuzzing of protocols. Instead of handling all input data as a single Binary Large Object (BLOB), we represent it as a sequence of packets, where packets and sequences are mutated separately. This approach allows the fuzzer to reorder known packets to increase coverage. We start with a single sequence containing one null-byte packet. For each execution, a random sequence is chosen from the population and mutated. To distinguish the effects of mutating sequences from mutating packets, only one of these is performed per measurement. If the mutation of a single packet increases code coverage, the sequence containing the new packet is added to the population. If mutating a sequence increases coverage, it is also added to the population. Sequence mutations include reordering packets, inserting known packets from other sequences, or merging two sequences.

**Figure 5: LMP fuzzing strategy comparison.**

### Coverage Increase by New Zero-Click Attack Surfaces

**Table 3: Coverage increase by new zero-click attack surfaces.**

| Scenario                             | Coverage (%) |
|--------------------------------------|--------------|
| LMP fuzzing                          | 2.76         |
| LMP fuzzing with BlueZ HCI           | 0.56         |
| Attach to stack `hciconfig hci1 up`   | 2.04         |
| Attach to stack `hcitool scan`        | 0.59         |
| Attach to stack `hcitool cc`          | 1.04         |
| Attach to stack `hcitool lescan`      | 0.57         |
| Attach to stack `hcitool lecc`        | 1.85         |
| Total                                | 9.40         |

Our adaptive approach finds more blocks in a shorter amount of time. The total coverage for LMP fuzzing converges to 2.76%. Introducing HCI support increases the coverage further by 0.56%, as HCI handlers and the UART receive state machine are invoked.

### Adding New Firmware

Frankenstein can fully emulate firmware even if no memory snapshot is available, provided the compiled firmware includes debug symbols. ELF is a common format for these images, which can be directly imported into Frankenstein. Without a memory snapshot, hardware initialization needs to be performed, which can be challenging in complex environments. In our use case, we were able to set up a working emulation within half a week, including support for buttons, SPI, and CAN interfaces.

### Workflow for Integrating New Firmware

1. Execute the firmware until a fault (e.g., infinite loop or illegal instruction) occurs.
2. Fix the root cause of the fault.
3. Add function tracing hooks to relevant function calls.
4. Modify hardware registers and buffers before functions or interrupt handlers.
5. Use coverage-guided fuzzing to verify how the input is processed by the firmware.

### Fuzzing Results and Exploitation

#### Heap Corruption

None of the observed devices implement exploit mitigations such as Data Execution Prevention (DEP) or Address Space Layout Randomization (ASLR). The memory allocator described in Section 5.3 can be easily exploited. A heap overflow allows an attacker to control a free list pointer, leading to a write-what-where gadget and enabling Remote Code Execution (RCE).

#### Classic Bluetooth Device Scanning EIR (CVE-2019-11516)

This section describes a heap overflow exploit in device inquiry, utilizing the full stack. As a device scans for other devices, these can respond with an Extended Inquiry Response (EIR). The EIR contains additional information such as the device name, which is copied into an HCI event. The EIR length is extracted from the payload header, and due to physical-layer constraints, the firmware skips further length checks prior to copying the EIR.

**Figure 7: ACL header format.**

**Figure 8: Overflowing hardware buffer.**

#### Devices Vulnerable to CVE-2019-11516

**Table 4: Devices vulnerable to CVE-2019-11516.**

| Chip          | Device                              | Build Date   | Vulnerable? |
|---------------|-------------------------------------|--------------|-------------|
| BCM20702      | Thinkpad T430                       | < 2010?      | Yes         |
| BCM4335C0     | Nexus 5, Xperia Z3 Compact, etc.    | Dec 11 2012  | Yes         |
| BCM4345B0     | iPhone 6 (unfixed in iOS 12.4)      | Jul 15 2013  | Yes         |
| BCM4358A3     | Samsung Galaxy S6, Nexus 6P         | Oct 23 2014  | Yes         |
| BCM4345C1     | iPhone SE (prior iOS 12.4)          | Jan 27 2015  | Yes         |
| Unknown       | Samsung Galaxy A3 (2016)            | Unknown      | Yes         |
| BCM20707      | Fitbit Ionic                        | Unknown      | Yes         |
| BCM4347B0     | Samsung Galaxy S8                   | Jun 3 2016   | Yes         |
| BCM4347B1     | iPhone 8/X/XR (prior iOS 12.4)      | Oct 11 2016  | Yes         |
| BCM4357       | Samsung Galaxy 9+/Note 9            | Unknown      | Yes         |
| CYW20735B1    | Evaluation Board                    | Jan 18 2018  | No          |
| BCM4375B1     | Samsung Galaxy S10e/S10/S10+        | Apr 13 2018  | Yes         |
| CYW20819A1    | Evaluation Board                    | May 22 2018  | Yes         |

#### Any BLE Packet (CVE-2019-13916)

This section describes a heap overflow in the reception of Bluetooth Low Energy (LE) Protocol Data Units (PDUs).