query.
This can be partially addressed by setting up an index, in
our case by using a BF. For example, for AND queries on
two columns, for each record with value a for column A,
and value b for column B, the following keywords are added:
A:a, B:b, AB:a.b. With this approach, the indexed AND
queries become equivalent to single term queries. However,
this cannot be fully generalized, as space grows exponentially
in the number of search columns.
Complex queries. The performance of CNF queries can be
analyzed by viewing them as AND queries where each disjunct
(i.e, OR query) is treated as a single term query. In general, any
other complex Boolean query can be converted to CNF and
then analyzed in a similar manner. In other words, performance
scales with the number of results returned by the best disjunct
when the query is represented in CNF. Note that we do not
actually need to convert our queries to this form
(nor know anything about the data, in particular, which
are high- or low-entropy terms) in order to achieve this
performance (this aspect is even better than MySQL).
Computation and Communication. Both computational
and communication resources required for our protocol are
proportional to the query complexities described above.
False Positives. As our system is built on Bloom ﬁlters, false
positives are possible. In our experiments, we set each BF
−6. Assuming the worst-case scenario
false positive rate to 10
for us, where the DB is such that many of the search paths do
−6 false
reach and query the BFs at the leaves, this gives 10
positive probability for each term of the query. Of course, the
false positive is a tunable parameter of our system.
IX. RELATED WORK
The problem of private DBMS can be solved by general pur-
pose secure computation schemes [26], [38], [52], [53]. These
solutions, however, involve at least linear (often much more)
work in the database size, hence cannot be used for practical
applications with large data. Oblivious RAM (ORAM) [27]
can be used to completely hide the client’s query pattern,
and can also be used as a tool to achieve sublinear amortized
time for secure computation if we allow to leak the program
running time [29], [39]. Nonetheless, computational costs are
still prohibitively high, rendering these solutions impractical
for the scale we are interested in.
Private Information Retrieval protocols (PIR) [16] consider
a scenario where the client wishes to retrieve the ith record of
the server’s data, keeping the server oblivious of the index i.
Symmetric PIR protocols [24] additionally require that client
should not learn anything more than the requested record.
While most PIR and SPIR protocols support record retrieval
by index selection, Chor et al. [15] considered PIR by key-
word. Although these protocols have sublinear communication
complexity, their computation is polynomial in the number of
records, and inefﬁcient for practical uses.
Another approach would be to use fully homomorphic
encryption (FHE). In 2009, Gentry [21] showed that FHE is
theoretically possible. Despite this breakthrough and many fol-
low up works, current constructions are too slow for practical
use. For example, it is possible to homomorphically compute
720 AES blocks in two and a half days [23].
Little work has appeared on practical, private search on
a large data. In order to achieve efﬁciency, weaker security
(some small amount leakage) has been considered. The work
of [44], [47] supports single keyword search and conjunctions.
However, the solution does not scale well to databases with
a large number of records (say millions); its running time is
linear in the number of DB records. One of the interesting
features of this work is the way they address range queries.
Our system also uses their idea to achieve range queries,
and extends it to support negations (since we use a sublinear
underlying OR query, our range queries are also sublinear, in
contrast to them). A more efﬁcient solution towards this end
was proposed in [18]. However, they only considered single
keyword search.
Any single keyword search solution can be used to solve
(insecurely) arbitrarily Boolean formulas; solve each keyword
in the formula separately and then combine (insecurely).
Obviously, however, this leaks much more information to the
parties (and also has work proportional to the sum of the work
for each term). Our system, in contrast, provides privacy of
the overall query (and work proportional to just the smallest
term).
There has been a long line of research on searchable
symmetric encryption (SSE) [11]–[13], [17], [25], [41], [50].
Note that, although many of the techniques used in SSE
schemes can be used in our scenario, the SSE setting focuses
on data outsourcing rather than data sharing. That is, in SSE
the data owner is the client, and so no privacy against the
client is required. Additionally, SSE solutions often offer either
a linear time search over the number of database records
[12], [41], [50], or a restricted type of client’s queries [17],
[32], namely single keyword search or conjunctions. One
exception is the recent SSE scheme of [11], which extended
the approach of [17] to allow for any Boolean formula of the
form k0∧φ(k1, ..., km−1), where φ(·) is an arbitrarily Boolean
formula. Their search time complexity is O(m×D(k0)), where
D(k0) is the number of records containing keyword k0. Note
that an arbitrary formula could be represented this way, as
k0 can always be set to true, but then the complexity will
be linear in the number of records. On the other hand, if the
client can format the query so that k0 is a term with very
few matches, the complexity will go down accordingly. In
contrast, our solution addresses arbitrary Boolean formulas,
370
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:00:22 UTC from IEEE Xplore.  Restrictions apply. 
with complexity proportional to the best term in the CNF
representation of the formula. Searchable encryption has also
been studied in the public key setting [4], [6], [9], [10], [49].
Here, many users can use the server public key to encrypt their
own data and send it to the server.
The CryptDB system [45] addresses the problem of DB
encryption from a completely different angle, and as such is
largely incomparable to our work. CryptDB does not aim to
address the issue of the privacy of the query (but it does
achieve query privacy similar to the single-keyword search
solution described above). Their threat scenario focuses on
DB data conﬁdentiality against the curious DB administrator,
and they achieve this by using a non-private DBMS over what
they call SQL-aware encrypted data. That is, the SQL query is
pre-processed by a fully trusted proxy that encrypts the search
terms of the query. The query is then executed by standard
SQL, which combines the results of individual-term encrypted
searches. Additionally, for free-text search, CryptDB uses the
linear solution of [50].
The closest
term to appear ﬁrst in the query term,
to our setting/work is a a very recent ex-
tension [31] of the SSE solution [11], which additionally
(to the SSE requirements) addresses data privacy against the
client (and hence, as we do, addresses private DB). We note
that the work of [11], [31] is performed independently and
concurrently to ours. [31] support the same class of functions
as [11] (discussed above). In the worst case, such as when the
client has little a priori information about the DB and chooses
a sub-optimal
the
complexity of the [31] solution can be linear in the DB size.
In contrast, our solution for general formulas does not depend
on the client’s knowledge of data distribution or representation
choice (beyond the size of the formula). However, we note that
for typical practical applications this is not a serious issue,
as the client can represent his query as a conjunction, and
moreover, can make a good guess for which term will have
low frequency in the data and is a good choice as the ﬁrst
term. Thus, a large majority of practically useful queries can
be evaluated by [31] with asymptotic complexity similar to
ours. In terms of security, our guarantees vary: [31] achieves
security against malicious client, which is much stronger than
our semi-honest setting, and of particular importance for the
policy enforcement. Our leakages vary and are incomparable.
We and [31] leak different access pattern structures (search
tree for us and index lookups for [31]). Because we use a
more expensive basic step of SFE, our protection of query-
related data, at least in some cases, is somewhat better. For
example, depending on the DB data, we may hide everything
about the individual terms of the query, while [31] leak to
the client and (their counterpart of the) IS the support sizes
for individual terms of the disjunctive queries (individual term
supports are revealed to the client, but this is only an issue if
the query does not ask for all the columns of the records).
key primitives. We also note that our interactive approach
allows signiﬁcant ﬂexibility. For example, the 0-1 security
(cf. Section V-B),
is naturally and cheaply achievable in
our system; it appears harder/more expensive to achieve in
a non-interactive system, and in fact is not considered in
[10]. The use of GC as the basic block similarly provides
signiﬁcant ﬂexibility and opportunities for feature expansion.
A strong point of [31] is easy scalability due to storing search
structures on disk. This is achieved at the cost of signiﬁcant
additional system complexity and setup time. Finally, [31]
naturally support multiple clients, while our natural extensions
to multiple clients require that all clients share a secret key
not known to IS.
Because of the different trade offs presented by our work
and that of [31], each system is better suited for different
applications/use cases. It is interesting to note that these two
works, the ﬁrst ones to address the major open problem of
truly practical, provably secure, and very rich (including any
formula) query DBMS, are based on very different technical
approaches. We believe that this adds to the value and strength
of each of these systems.4
X. DISCUSSION AND MOTIVATION OF OUR SETTING
Semi-honest model. Semi-honest model is often reasonable
in practice, especially in the Government use scenarios. For
example, C, S and index server may be Government agencies,
whose systems are veriﬁed and trusted to execute the pre-
scribed code. Further, regular audits will help enforce semi-
honest behavior.
Security against malicious adversaries can be added by stan-
dard techniques, but this results in impractical performance.
In follow up work we show how to amend our protocols to
protect against one malicious player (C or IS) at a very small
cost (ca. 10% increase). This is possible mainly because the
underlying GC protocols are already secure against malicious
evaluator.
Impact of the allowed leakage. Formally pinning down
exact privacy loss is beyond the reach of state-of-the-art
cryptography, even with no leakage beyond the output and
amount of work (the ﬁeld of differential privacy is working
on this problem, with very moderate success). Therefore,
understanding our leakage and its impact for speciﬁc appli-
cations is crucial to ascertain whether it’s acceptable. We
informally investigated the impact of leakage in several natural
applications, such as population DBs and call-record DBs
and query patterns (see example below); we believe that our
protection is insufﬁcient in some scenarios, while in many
others it provides strong guarantees.
Rough leakage estimation for call-records DB. Consider
a call-records DB,
including columns (Phone number,
Callee phone number, time of call). The client C
is allowed to only ask queries of the form select * where
4We note that in an earlier stage there were two other performers on
the IARPA SPAR program. However, we do not know the details of their
approaches, and are not aware of published work presenting their solutions.
At the same time, the concrete query performance of [31] is
somewhat better than ours, due to their elegant non-interactive
approach. The very expensive step of DB setup is faster for
us, and the CPU load is lower, as we use mainly symmetric-
371
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:00:22 UTC from IEEE Xplore.  Restrictions apply. 
phone number = xxx AND callee phone number
= yyy AND time of call ∈ {interval}.
For typical call patterns (e.g.,0-10 calls/person/day), the
query leakage will almost always constitute a tree with
branches either going to the leafs (returned records) or trun-
cated one or two levels from the root. We believe that for many
purposes this is acceptable leakage. Again, we stress that this
is not a formal or detailed analysis (which is beyond the reach
of today’s state-of-the-art); it is included here to support our
belief that our system gives good privacy protection in many
reasonable scenarios.
Reliance on the third party. While a two-party solution is
of course preferable, these state-of-the-art solutions are orders
of magnitude slower than what is required for scalable DB
access. Probably the most reasonable approach would be to
use ORAM, which is set up either by a trusted party or as
a (very expensive) 2-PC between data owner and the querier.
Then the querier can query the ORAM held by the data owner.
Due to privacy requirements, each ORAM step must be done
over encrypted data, which triggers performance that is clearly
unacceptable for the scale required in our application (cf. [29]).
Further, in Government use cases, employing third party is
often seen as reasonable. For example, such a player can be
run by a neutral agency. We emphasize that the third party is
not trusted with the data or queries, but is trusted not to share
information with the other parties.
XI. CONCLUSION
Guaranteeing complete search privacy for both the client and
the server is expensive with today’s state of the art. However,
a weaker level of privacy is often acceptable in practice,
especially as a trade-off for much greater efﬁciency. We
designed, proved secure, built and evaluated a private DBMS,
named Blind Seer, capable of scaling to tens of TB’s of data.
This breakthrough performance is achieved at the expense
of leaking search tree traversal information to the players.
Our performance evaluation results clearly demonstrate the
practicality of our system, especially on queries that return
a few results where the performance overhead over plaintext
MySQL was from just 1.2× to 3× slowdown.
We note that
the range from complete privacy to best
performance is wide and our work only targets a speciﬁc point
within it. We see it as a step towards exploring several other
trade-offs in this space. Our goal for future work is to develop
a highly tunable system which will be able to be conﬁgured
and match many practical scenarios with different privacy and
performance requirements.
Acknowledgments. This work was supported in part by the
Intelligence Advanced Research Project Activity (IARPA) via
Department of Interior National Business Center (DoI/NBC)
contract Number D11PC20194. The U.S. Government is au-
thorized to reproduce and distribute reprints for Governmental
purposes notwithstanding any copyright annotation thereon.
Disclaimer: The views and conclusions contained herein are
those of the authors and should not be interpreted as nec-
essarily representing the ofﬁcial policies or endorsements,
either expressed or implied, of IARPA, DoI/NBC, or the U.S.
Government.
Fernando Krell was supported by BECAS CHILE, CONI-
CYT, Gobierno de Chile.
This material is based upon work supported by (while author
Keromytis was serving at) the National Science Foundation.
Any opinion, ﬁndings, and conclusions or recommendations
expressed in this material are those of the author(s) and
do not necessarily reﬂect the views of the National Science
Foundation.
We thank MIT Lincoln Labs researchers for supporting
this program from the beginning to the end and facilitating
extensive testing of our code.