cess policy in which a host that triggers a transmission-failure alert after β seconds is
disconnected from network services other than PillarBox. Any disconnected services
are restored only when PillarBox’s decrypter again receives a buffer from the host and
can detect alerts. In a benign network outage, this policy will not adversely affect hosts:
They will lack network service anyway. An adversary that suppresses PillarBox buffer
transmission, though, will cut itself off from the network until PillarBox can analyze
any relevant alerts. Such interfacing of PillarBox with network-access policies limits
the attackers ability to perform online actions while remaining undetected.
4 PillarBox Buffer and Protocols
We now present the main component of PillarBox, the PBB, and its protocols (run by
the bufferer and decrypter), which realize a reliable messaging channel, as well as the
functionality exported to the alerter and gap-checker to secure the SAS chain of custody.
Ideal “Lockbox” Security Model. Conceptually, the PBB serves as a “lockbox” for
message transport: It’s a buffer of T ﬁxed-size slots that supports two basic operations:
K.D. Bowers et al.
56
1. write: The sender S (the client in PillarBox) inserts individual messages into the
buffer via write in a round-robin fashion. Given currently available position I ∈
{0, . . . , T −1} (initially set at random), a new message is written in slot I (replacing
the oldest message), and I is incremented by 1 (mod T ).
2. read: The receiver R (the server in PillarBox) invokes read, which outputs the
(monotonically increasing) sequence numbers j of the buffer and sj of the last
inserted message, along with the T messages in the buffer starting at position I,
with wraparound.
Messages buffered in this ideal “lockbox” can only be read via the read interface
and can only be modiﬁed (authentically) via the write interface. When read by R, a
message mi stored at slot i is guaranteed to be either the most recent message written
to slot i (the empty symbol ∅ if no message was ever written), or a special corruption
symbol ⊥ that indelibly replaces all the buffer’s contents if the buffer was tampered
with or modiﬁed otherwise than by write.
The goal of an attacker on compromising a host is to learn SAS actions and suppress
alerts buffered during the critical window. The ideal read interface of the “lockbox”
buffer protects against violations of stealth (the attacker cannot observe when R reads
the buffer). Given the write interface, the attacker can only violate buffer integrity in
the post-compromise period in one of four ways:
1. Buffer modiﬁcation/destruction: The attacker can tamper with the contents of the
buffer to suppress critical-window alerts. As noted above, this will cause decryption
errors indicated by the special symbol ⊥.
2. Buffer overwriting: The attacker can exploit buffer wraparound by writing T rela-
tively benign messages into it to overwrite and thereby destroy messages generated
during the critical window.
3. Buffer dropping: The attacker can simply drop buffers or delay their transmission.9
4. Transmission stoppage: The attacker can break the PBB completely, causing no
buffer transmission for an extended period of time, or indeﬁnitely.
During the critical window, the attacker can alternatively try to attack so quickly that
the critical window is nearly zero. In this case, there is not sufﬁcient time for PillarBox
to take in a SAS alert message and put it in the PBB. Our experiments in Section 5 show
in some settings of interest that this attack is unlikely.
Adversarial buffer modiﬁcation or destruction, as explained above, is an easily de-
tectable attack. It causes the server to receive a symbol ⊥, indicating a cryptographic
integrity-check failure. The gap-checker in PillarBox detects both buffer overwriting
attacks and buffer dropping attacks by the same means: It looks for lost messages, as
indicated by a gap in message sequence numbers.10 Figure 4 depicts a normal buffer
transmission and one, ostensibly during an attack, in which messages have been lost
to an alert ﬂood or to buffer overwriting. A transmission stoppage is detectable simply
9 The attacker can also potentially cause buffers to drop by means of a network attack during
the critical window, but the effect is much the same as a post-compromise attack.
10 I.e., a gap alert is issued when the sequence numbers sj and sj(cid:2) of (of the last inserted messages
in) two successively received buffers j and j
(cid:2)
are such that sj(cid:2) − sj ≥ T .
PillarBox: Combating Next-Generation Malware
57
(cid:5)(cid:16)(cid:18)(cid:14)(cid:6)(cid:13)(cid:1)(cid:7)(cid:21)(cid:10)(cid:9)(cid:18)(cid:1)(cid:1)
(cid:19)(cid:21)(cid:8)(cid:8)(cid:9)(cid:19)(cid:19)(cid:12)(cid:16)(cid:15)(cid:1)
(cid:5)(cid:10)(cid:1)
(cid:22)(cid:2)(cid:23)(cid:1)
(cid:4)(cid:12)(cid:19)(cid:19)(cid:12)(cid:15)(cid:11)(cid:1)(cid:14)(cid:9)(cid:19)(cid:19)(cid:6)(cid:11)(cid:9)(cid:19)(cid:1)(cid:1)
(cid:22)(cid:11)(cid:6)(cid:17)(cid:1)(cid:6)(cid:13)(cid:9)(cid:18)(cid:20)(cid:23)(cid:1)
(cid:5)(cid:10)(cid:1)
(cid:22)(cid:3)(cid:23)(cid:1)
(cid:2)(cid:21)(cid:1)
(cid:2)(cid:22)(cid:1)
(cid:5)(cid:10)(cid:20)(cid:1)(cid:28)(cid:1)(cid:5)(cid:10)(cid:1)(cid:27)(cid:1)(cid:26)(cid:1)
(cid:2)(cid:21)(cid:1)
(cid:2)(cid:22)(cid:1)
(cid:5)(cid:10)(cid:1)(cid:27)(cid:1)(cid:24)(cid:25)(cid:1)(cid:28)(cid:1)(cid:5)(cid:10)(cid:20)(cid:1)(cid:1)
(cid:4)(cid:19)(cid:7)(cid:16)(cid:11)(cid:6)(cid:15)(cid:15)(cid:9)(cid:13)(cid:8)(cid:1)(cid:12)(cid:7)(cid:17)(cid:17)(cid:6)(cid:8)(cid:7)(cid:17)(cid:1)
(cid:3)(cid:14)(cid:17)(cid:18)(cid:1)(cid:12)(cid:7)(cid:17)(cid:17)(cid:6)(cid:8)(cid:7)(cid:17)(cid:1)
(cid:2)
Fig. 4. Gap rule example on successively received buffers C1, C2, indexed by sequence numbers
and T = 10: (A) Normal message overlap between buffers; (B) A detectable gap: Messages
j, j
with sequence numbers sj + 1 and sj + 2 have been lost
when the server has received no buffers for an extended period of time, producing a
transmission-failure alert, as noted above.
Security Deﬁnitions. Our implementation of this ideal “lockbox” consists of the PBB
and three operations: (i) The sender S runs Write to insert a message into the PBB
and (ii) Wrap to encapsulate the PBB for transmission, and (iii) The receiver R runs
Read to extract all messages from a received, encapsulated PBB. We denote by C the
contents of the PBB after a series of Write operations by S, and by ˆC a cryptographic
encapsulation transmitted to R. We require two security properties, immutability, and
stealth and two non-cryptographic ones, persistence and correctness.
Informally, correctness dictates that under normal operation any sequence of mes-
sages of size at most T added to C by S can be correctly read by R in an order-
preserving way; in particular, the T most recent messages of C and their exact order
can be determined by R. Persistence means that by encapsulating the buffer C repeat-
edly, it is possible to produce a given message in C more than once.
For our two cryptographic properties, we consider a powerful adaptive adversary A
that operates in two phases: (1) Prior to compromise, A fully controls the network, and
may arbitrarily modify, delete, inject, and re-order transmissions between S and R; A
may also determine when S encapsulates and sends the PBB, and may also choose its
time of compromise; (2) On compromising S, A corrupts S, learns its secret state, and
fully controls it from then on.
Immutability means, informally, that pre-compromise messages in C are either re-
ceived unaltered by R in the order they were written, or are marked as invalid; i.e.,
even after compromising S, A cannot undetectably drop, alter or re-order messages
in C. Stealth means, informally, that A cannot learn any information about messages
buffered prior to compromise. It is stronger than conﬁdentiality. Not only cannot A
learn the contents of messages, it also cannot learn the number of buffered messages—
or if any were buffered at all. This holds even after A has compromised S.
Detailed Construction. Our construction employs (and we assume basic familiarity
with) a forward-secure pseudorandom number generator FS-PRNG (e.g., [10]) that
exports two operations GenKey and Next to compute the next pseudorandom num-
bers, as well as an authenticated encryption scheme (e.g., [2]) that exports operations
AEKeyGen, AuthEnc and AuthDec to encrypt messages m of size k to ciphertexts of
size g(k) ≥ k.
58
K.D. Bowers et al.
j, i, j), message m ∈ {0, 1}(cid:3), buffer C
(cid:2)
(cid:2)
j, i + 1, j), updated buffer C
Operation Write
Input: secret key (ri, r
Output: new secret key (ri+1, r
1. C[C[T ]] = (AuthEncri (m), i)
2. C[T ] = C[T ] + 1 mod T
3. (ri+1, r
4. delete ri
5. return [(ri+1, r
(cid:2)
j, i + 1, j), C]
j, i + 1, j) ← KEvolve(ri, r
(cid:2)
(cid:2)
j, i, j, 1, low)
(cid:2)
j, i, j), buffer C
(cid:2)
j+1, i, j + 1), encaps. buffer ˆC
Operation Wrap
Input: secret key (ri, r
Output: new secret key (ri, r
1. ˆC = (AuthEncr(cid:2)
(C), j)
2. (ri, r
3. delete r
4. return [(ri, r
(cid:2)
j
(cid:2)
j+1, i, j + 1), ˆC]
j+1, i, j + 1) ← KEvolve(ri, r
(cid:2)
j
(cid:2)
j, i, j, 1, high)
(cid:2)
j, i, j), encapsulated buffer ˆC
Operation Read
Input: secret key (ri, r
(cid:2)), (m0, . . . , mT−1)
Output: new secret key (rl, r
(cid:2) ≤ j then return [(ri, r
1. if j
(cid:2) − j, high)
(cid:2)
(cid:2)
2. (ri, r
j(cid:2) , i, j
j, i, j, j
3. (C[0], . . . , C[T ]) = C ← AuthDecr(cid:2)
j(cid:2) (c
4. if C = ⊥ then return [(ri, r
5. for 0 ≤ k < T do
(cid:2)
j(cid:2) , l, j
(cid:2)) ← KEvolve(ri, r
j, i, j), ⊥]
(cid:2)
j, i, j), ⊥]
(cid:2)
(cid:2)); I = C[T ]
(a) (c, l) = C[k + I mod T ]
j, i, j), ⊥]
(b) if k = 0 ∧ l ≤ i then return [(ri, r
(cid:2)
(c) if k (cid:8)= 0 ∧ l (cid:8)= LAST + 1 then return [(ri, r
, l − i, low)
(d) (rl, r
(e) mk ← AuthDecrl (c); LAST = l
(cid:2)) ← KEvolve(ri, r
j(cid:2) , l − T + 1, j
(cid:2)
Fig. 5. Operations Write, Wrap and Read
(cid:2)
j(cid:2) , i, j
(cid:2)), (m0, . . . , mT−1)]
(cid:2)
j(cid:2) , l, j
(cid:2)
6. return [(rl−T +1, r
j, i, j), ⊥]
(cid:2)
In particular, the sender S maintains the following data structure:
1. a secret key σ (also kept by the receiver R);
2. a buffer C, C = (C[0], C[1], . . . , C[T − 1]), initially ﬁlled with random data, that
takes the form of an array of size T + 1, where C[i], 0 ≤ i ≤ T , denotes the
ith position in C; we set the size of each slot C[i] to be s = g((cid:5)), where (cid:5) is an
appropriate given message length (deﬁning message space {0, 1}(cid:3)).11
3. a current index I, initialized at a random position in C, and itself stored at C[T ].
Key management operates as follows. Given a security parameter κ, algorithm KGen
ﬁrst initiates an authenticated encryption scheme as well as two FS-PRNGs, one low-
layer to generate sequence r0, r1, . . . (for message encryption) and one high-layer to
(cid:2)
generate sequence r
1, . . . (for buffer encryption). It then initializes the secret states
of S and R, which take the (simpliﬁed) form (ri, r
(cid:2)
j, i, j), denoting the most recent
11 In our EAX encryption implementation: (cid:2) = 1004 and g((cid:2)) = 1024.
(cid:2)
0, r
PillarBox: Combating Next-Generation Malware
59
forward-secure pseudorandom numbers for the low and high layers, along with their
(cid:2)
sequence numbers. Also, given the current secret state (ri, r
j, i, j), an integer t and a
control string b ∈ {low, high}, algorithm KEvolve creates the corresponding low- or
high-layer t-th next forward-secure pseudorandom number.
Then our main protocols operate as shown in Figure 5. First, given secret writing
(cid:2)
j, i, j), message m and buffer C, Write securely encodes m, adds it in C and