tation:
the access-control policy represented by the ACT
should not have been applied to this context.
We reported the new vulnerabilities found by FIXMEUP
and they were assigned CVE candidate numbers: CVE-
2012-2443, 2444, 2445, 2437 and 2438. We conﬁrmed the
correctness of our repairs by testing each program and ver-
ifying that it is no longer vulnerable. When an unautho-
rized user invokes the repaired applications through either
an intended or unintended entry point and attempts to ex-
ecute the sensitive operation, every repaired application re-
jects the attempt and executes the code corresponding to the
failed check from the original ACT.
7 Related Work
Related work includes techniques for ﬁnding access-control
bugs, since it is a necessary ﬁrst step to repairing them, gen-
eral bug ﬁnding, program repair, and transformation tools.
i n c l u d e ” c o n f . php ” ;
i n c l u d e o n c e ” i n c l u d e s . php ” ;
s e s s i o n s t a r t ( ) ;
1 
Figure 12: minibloggie: Attempted repair
plate for each target is critical to successful repair.
Figure 13 shows repairs to GRBoard in remove
multi f ile.php and swf upload ok.php. These two ﬁles
implement different access-control logic to protect role-
speciﬁc sensitive operations. Observe that $GR variable in
swf upload ok.php is not renamed and the existing vari-
able is used instead, i.e., $GR = new COMMON() at line
4. On the other hand, in remove multi f ile.php, FIX-
MEUP deﬁnes a new variable $GR newone to avoid un-
wanted dependences when it inserts this statement.
Figure 11 also shows how FIXMEUP leaves line 2 in-
tact in process.php when applying the template based on
AddDn.php. This reuse is crucial for correctness. Had
FIXMEUP naively inserted this statement from the template
rather than reuse the existing statement, the redundant, du-
plicated statement would have introduced an unwanted de-
pendence because this function call has a side effect on the
$ SESSION variable. Because of statement reuse, how-
ever, this dependence remains exactly the same in the re-
paired code as in the original.
The last column demonstrates that the inserted state-
ments in 37 repair instances introduce no unwanted depen-
dences that affect the rest of the program. Figure 14 shows
one instance where a repair had a side effect because of an
slidesshow.php
. . .
1
2 $ g i d =$ GET [ ’ g i d ’ ] ;
3 $form pw newone = $ POST [ ’ form pw ’ ] ;
/ / e x i s t i n g s t a t e m e n t s
/ /
[ FixMeUp
r e p a i r ]
. . . .
i f
( ! c h e c k a d m i n l o g i n ( ) ) { / /
i f
( ( s t r l e n ( $ g i d i n f o [ ’ g a l l e r y p a s s w o r d ’ ] ) > 0 ) ) {
[ FixMeUp r e p a i r ]
4
5
6
7
8
9
10
12
13
11 }
}
. . . .
i f
14
15
16 }
/ /
[ FixMeUp r e p a i r ]
/ / @ACC( ’ g u e s t ’ )
i f
( ! c h e c k g a l l e r y p a s s w o r d ( $ g i d i n f o [ ’
g a l l e r y p a s s w o r d ’ ] , $form pw newone ) ) { / /
FixMeUp r e p a i r ]
[
’ f a c e b e g i n . php . mphp ’ ) ;
i n c l u d e ( $TEMPLATE DIR .
[ FixMeUp r e p a i r ]
/ /
e r r o r ( y ( ’ Password i n c o r r e c t . ’ ) ) ;
}
r e p a i r ]
/ /
[ FixMeUp
( ! c h e c k g a l l e r y p a s s w o r d ( $ g i d i n f o [ ’
g a l l e r y p a s s w o r d ’ ] , $form pw ) ){
i n c l u d e ( $TEMPLATE DIR .
e r r o r ( y ( ” Password i n c o r r e c t . ” ) ) ;
’ f a c e b e g i n . php . mphp ’ ) ;
Figure 14: YaPiG: Attempted repair
Static detection of access-control bugs. Prior work sim-
ply reports that certain statements are reachable without an
access-control check. Sun et al. require the programmer
to specify the intended check for each application role and
then automatically ﬁnd execution paths with unchecked ac-
cess to the role’s privileged pages [36]. Chlipala ﬁnds secu-
rity violations by statically determining whether the appli-
cation’s behavior is consistent with a policy speciﬁed as a
database query [5].
One consequence of access-control bugs in Web appli-
cations is that attackers may perform unintended page nav-
igation. Several approaches ﬁnd these unintended naviga-
tion ﬂows [2, 10]. They generally rely on heuristics and/or
dynamic analysis to learn the intended ﬂows and are thus
incomplete. Furthermore, they cannot detect ﬁner-grained
access-control bugs. For example, a missing check on the
same page as the protected operation will not manifest as an
anomalous page navigation.
Without a programmer-provided speciﬁcation, static
analysis may infer the application’s access-control poli-
cies. Son and Shmatikov use consistency analysis to ﬁnd
variables in access-control logic [33]. Son et al. devel-
oped RoleCast, a tool that ﬁnds role-speciﬁc access-control
checks without speciﬁcation by exploiting software engi-
neering conventions common in Web applications [32].
None of these approaches automatically repair the bugs
they ﬁnd, whereas FIXMEUP (1) computes code templates
that implement access-control logic, (2) ﬁnds calling con-
texts that implement this logic incorrectly, (3) transforms
the code by inserting the template into one or more methods
in the vulnerable contexts, and (4) validates that the trans-
formed code implements the correct logic.
Code mining. A popular bug ﬁnding approach is to mine
the program for patterns and looks for bugs as deviations or
anomalies. This approach typically ﬁnds frequently occur-
ring local, intraprocedural patterns [9]. Tan et al. showed
how to ﬁnd access-control bugs in SELinux using similar
techniques, but with interprocedural analysis [37]. When
applied to Web applications, heuristics based on ﬁnding de-
viations from common, program-wide patterns will likely
generate an overwhelming number of false positives. As
shown in [36] and [32], access-control logic in Web appli-
cations is signiﬁcantly more sophisticated than simple “this
check must always precede that operation” patterns. They
are role- and context-sensitive, with different policies en-
forced on different execution paths. Simple pattern match-
ing won’t ﬁnd violations of such policies.
Verifying access control in Java libraries. Access-
control checks are standardized in Java libraries and are
simply calls to the SecurityManager class. A rich body
of work developed techniques for verifying access control
in Java class libraries [16, 29, 31, 35], but none of them
attempt to repair access-control bugs.
Dynamic detection of access-control bugs. In the secu-
rity domain, dynamic analysis ﬁnds security violations by
tracking program execution [4, 7, 12, 43]. For example,
Hall´e et al. dynamically ensure that page navigation within
the application conforms to the state machine speciﬁed by
the programmer [12]. GuardRails requires the develop-
ers to provide explicit access-control speciﬁcations and en-
forces them dynamically within its framework for Ruby [3].
Alternatives to explicit speciﬁcation include learning the
state machine by observing benign runs and then relying
on anomaly detection to ﬁnd violations [6], or using static
analysis of the server code to create a conservative model
of legitimate request patterns and detecting deviations from
these patterns at runtime [11]. Violations caused by missing
access-control checks are an example of generic “execution
omission” bugs. Zhang et al. presented a general dynamic
approach to detecting such bugs [44].
In addition to the usual challenges of dynamic analy-
sis, such as incomplete coverage, dynamic enforcement of
access-control policies is limited in what it can do once
it detects a violation. Typically, the runtime enforcement
mechanism terminates the application since it does not
know what the programmer intended for the application to
do when an access-control check fails.
By contrast, our objective is to repair the original pro-
gram. In particular, for the program branch corresponding
to a failed access-control check, we insert the exact code
used by the programmer as part of the correct checks (it
may generate an error message and return to the initial page,
terminate the program, etc.). The repaired program thus be-
haves as intended, does not require a special runtime envi-
ronment, and can be executed anywhere.
Dynamic repair of software bugs. Dynamic program
repair ﬁxes the symptom, but not the cause of the er-
ror [4, 7, 12, 22, 30, 43]. For example, dynamic repair
allocates a new object on a null-pointer exception, or ig-
nores out-of-bounds references instead of terminating the
program. The dynamic ﬁxes, however, are not reﬂected in
the source code and require a special runtime.
Static detection of injection vulnerabilities. Many tech-
niques detect data-ﬂow vulnerabilities, such as cross-site
scripting and SQL injection [13, 15, 17, 39, 42]. These bugs
are characterized by tainted inputs ﬂowing into database
queries and HTML content generation. Access-control bugs
are control-ﬂow vulnerabilities: they enable the attacker to
execute a sensitive operation, which may or may not be ac-
companied by illegitimate data ﬂows. For example, if a con-
stant query deletes the database, there is no tainted data ﬂow
into the operation.
Automatic remediation of software bugs. Much prior
work ﬁnds code clones within the same application to help
programmers refactor, ﬁx bugs, and add features consis-
tently [8, 18, 20, 23, 38]. These tools suggest where a bug
ﬁx may be needed, but do not transform the program. FIX-
MEUP solves the dual of this problem:
it inserts similar
code where it is missing.
Several tools learn from a developer-provided ﬁx and
help apply similar ﬁxes elsewhere. They perform the same
syntactic edit on two clones [21], or suggest changes for
API migration [1], or do not perform the edit [23], or ask
users where to apply the edit [19]. These approaches only
apply local edits and none of them consider the interproce-
dural edits that are required to repair access-control logic.
In the more limited domain of access-control bugs, we au-
tomate both ﬁnding the missing logic and applying the ﬁx.
Generating program ﬁxes. A few approaches automati-
cally generate a candidate patch and then check correctness
with compilation and testing. For example, Perkins et al.
generate patches to enforce invariants that are are observed
in correct executions but violated in erroneous ones [25].
They test several patched executions and select the most
successful one. Weimer et al. [40, 41] generate candidate
patches by randomly replicating, mutating, or deleting code
from the program. Jin et al. automatically ﬁx bugs by ﬁnd-
ing violations of pre-deﬁned patterns encoded as ﬁnite-state
machines, such as misplaced or missing lock and unlock
pairs [14]. Their static analysis moves or inserts one or
two lines of code to satisfy the correct pattern. All of these
approaches focus on one- or two-line changes that satisfy
some dynamic or static local predicate. By contrast, FIX-
MEUP extracts and inserts multi-line code sequences re-
sponsible for enforcing the application’s context-sensitive
access-control policy.
8 Conclusion
We presented FIXMEUP, the ﬁrst static analysis and pro-
gram transformation tool for ﬁnding and repairing access-
control bugs in server-side Web applications. FIXMEUP
starts with an access-control policy that maps security-
sensitive operations—such as database queries and privi-
leged ﬁle operations—to access-control checks that protect
them from unauthorized execution. FIXMEUP then auto-
matically extracts the code responsible for access-control
enforcement, uses it to create an access-control template,
ﬁnds calling contexts where the check is missing or im-
plemented incorrectly, repairs the vulnerability by applying
the template, and validates the repair. The key to seman-
tically correct repairs is the novel algorithm that ﬁnds and
reuses existing statements that are part of the access-control
logic. In particular, reuse of existing statements helps FIX-
MEUP avoid duplicating statements that have side effects
on the rest of the program. FIXMEUP successfully repaired
30 access-control bugs in 10 real-world PHP applications,
demonstrating its practical utility.
Acknowledgments. This research was partially supported
by the NSF grants CNS-0746888, SHF-0910818, CCF-
1018271, and CNS-1223396, a Google research award,
the MURI program under AFOSR Grant No. FA9550-
08-1-0352, and the Defense Advanced Research Agency
(DARPA) and SPAWAR Systems Center Paciﬁc, Contract
No. N66001-11-C-4018.
References
[1] J. Andersen and J. Lawall. Generic patch inference. In ASE,
pages 337–346, 2008.
[2] D. Balzarotti, M. Cova, V. Felmetsger, and G. Vigna. Multi-
module vulnerability analysis of Web-based applications. In
CCS, pages 25–35, 2007.
[3] J. Burket, P. Mutchler, M. Weaver, M. Zaveri, and D. Evans.
GuardRails: A data-centric Web application security frame-
work. In USENIX WebApps, 2011.
[4] W. Chang, B. Streiff, and C. Lin. Efﬁcient and extensible
security enforcement using dynamic data ﬂow analysis. In
CCS, pages 39–50, 2008.
[5] A. Chlipala. Static checking of dynamically-varying se-
In OSDI,
curity policies in database-backed applications.
pages 105–118, 2010.
[6] M. Cova, D. Balzarotti, V. Felmetsger, and G. Vigna. Swad-
dler: An approach for the anomaly-based detection of state
violations in Web applications. In RAID, pages 63–86, 2007.
[7] M. Dalton, C. Kozyrakis, and N. Zeldovich. Nemesis: Pre-
venting authentication and access control vulnerabilities in
In USENIX Security, pages 267–282,
Web applications.
2009.
[8] E. Duala-Ekoko and M. Robillard. Tracking code clones in
evolving software. In ICSE, pages 158–167, 2007.
[9] D. Engler, D. Chen, S. Hallem, A. Chou, and B. Chelf. Bugs
as deviant behavior: A general approach to inferring errors
in systems code. In SOSP, pages 57–72, 2001.
[10] V. Felmetsger, L. Cavedon, C. Kruegel, and G. Vigna. To-
ward automated detection of logic vulnerabilities in Web ap-
plications. In USENIX Security, pages 143–160, 2010.
[11] A. Guha, S. Krishnamurthi, and T. Jim. Using static analy-
sis for Ajax intrusion detection. In WWW, pages 561–570,
2009.
[12] S. Hall´e, T. Ettema, C. Bunch, and T. Bultan. Eliminating
navigation errors in Web applications via model checking
and runtime enforcement of navigation state machines. In
ASE, pages 235–244, 2010.
[13] Y. Huang, F. Yu, C. Hang, C. Tsai, D. Lee, and S. Kuo. Se-
curing Web application code by static analysis and runtime
protection. In WWW, pages 40–52, 2004.
[14] G. Jin, L. Song, W. Zhang, S. Lu, and B. Liblit. Automated
atomicity-violation ﬁxing. In PLDI, pages 389–400, 2011.
[15] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static anal-
In
ysis tool for detecting Web application vulnerabilities.
S&P, pages 258–263, 2006.
[16] L. Koved, M. Pistoia, and A. Kershenbaum. Access rights
analysis for Java. In OOPSLA, pages 359–372, 2002.
[17] B. Livshits, A. Nori, S. Rajamani, and A. Banerjee. Merlin:
Speciﬁcation inference for explicit information ﬂow prob-
lems. In PLDI, pages 75–86, 2009.
[18] J. Mayrand, C. Leblanc, and E. Merlo. Experiment on the
automatic detection of function clones in a software system
using metrics. In ICSM, 1996.
[19] N. Meng, M. Kim, and K. McKinley. Systematic editing:
In
Generating program transformations from an example.
PLDI, pages 329–342, 2011.
[20] R. Miller and B. Myers.
Interactive simultaneous editing
of multiple text regions. In USENIX ATC, pages 161–174,
2001.
[21] H. Nguyen, T. Nguyen, G. Wilson Jr., A. Nguyen, M. Kim,
and T. Nguyen. A graph-based approach to API usage adap-
tation. In OOPSLA, pages 302–321, 2010.
[22] H. Nguyen and M. Rinard. Detecting and eliminating mem-
ory leaks using cyclic memory allocation. In ISMM, pages
15–29, 2007.
[23] T. Nguyen, H. Nguyen, N. Pham, J. Al-Kofahi, and
T. Nguyen. Recurring bug ﬁxes in object-oriented programs.
In ICSE, pages 315–324, 2010.
[24] OWASP top 10 application security risks. https://www.
owasp.org/index.php/Top_10_2010-Main,
2010.
[25] J. Perkins, S. Kim, S. Larsen, S. Amarasinghe, J. Bachrach,
M. Carbin, C. Pacheco, F. Sherwood, S. Sidiroglou, G. Sul-
livan, W.-F. Wong, Y. Zibin, M. Ernst, and M. Rinard. Au-
tomatically patching errors in deployed software. In SOSP,
pages 87–102, 2009.
[26] PHC: the open source php compiler.
http://www.
phpcompiler.org.
[27] PHP. http://www.php.net.
[28] PHP
advent
2010:
Usage
statistics.
http://phpadvent.org/2010/
usage-statistics-by-ilia-alshanetsky.
[29] M. Pistoia, R. Flynn, L. Koved, and V. Sreedhar. Interpro-
cedural analysis for privileged code placement and tainted
variable detection. In ECOOP, pages 362–386, 2005.
[30] M. Rinard, C. Cadar, D. Dumitran, D. Roy, T. Leu, and
W. Beebee.
Enhancing server availability and security
through failure-oblivious computing. In OSDI, pages 303–
316, 2004.
[31] A. Sistla, V. Venkatakrishnan, M. Zhou, and H. Branske.
CMV: Automatic veriﬁcation of complete mediation for
Java Virtual Machines. In ASIACCS, pages 100–111, 2008.
[32] S. Son, K. McKinley, and V. Shmatikov. RoleCast: Finding
missing security checks when you do not know what checks
are. In OOPSLA, pages 1069–1084, 2011.
[33] S. Son and V. Shmatikov. SAFERPHP: Finding semantic
vulnerabilities in PHP applications. In PLAS, 2011.
[34] M. Sridharan, S. Fink, and R. Bodik. Thin slicing. In PLDI,
pages 112–122, 2007.
[35] V. Srivastava, M. Bond, K. McKinley, and V. Shmatikov. A
security policy oracle: Detecting security holes using multi-
ple API implementations. In PLDI, pages 343–354, 2011.
[36] F. Sun, L. Xu, and Z. Su. Static detection of access control
In USENIX Security,
vulnerabilities in Web applications.
2011.
[37] L. Tan, X. Zhang, X. Ma, W. Xiong, and Y. Zhou. AutoISES:
Automatically inferring security speciﬁcations and detecting
violations. In USENIX Security, pages 379–394, 2008.
[38] M. Toomim, A. Begel, and S. Graham. Managing duplicated
code with linked editing. In VLHCC, pages 173–180, 2004.
[39] G. Wasserman and Z. Su. Sound and precise analysis of Web
applications for injection vulnerabilities. In PLDI, pages 32–
41, 2007.
[40] W. Weimer, S. Forrest, C. Le Goues, and T. Nguyen. Auto-
matic program repair with evolutionary computation. Com-
mun. ACM, 53(5):109–116, 2010.
[41] W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest. Au-
tomatically ﬁnding patches using genetic programming. In
ICSE, pages 364–374, 2009.
[42] Y. Xie and A. Aiken. Static detection of security vulnera-
bilities in scripting languages. In USENIX Security, pages
179–192, 2006.
[43] A. Yip, X. Wang, N. Zeldovich, and F. Kaashoek. Improv-
ing application security with data ﬂow assertions. In SOSP,
pages 291–304, 2009.
[44] X. Zhang, S. Tallam, N. Gupta, and R. Gupta. Towards lo-
cating execution omission errors. In PLDI, pages 415–424,
2007.