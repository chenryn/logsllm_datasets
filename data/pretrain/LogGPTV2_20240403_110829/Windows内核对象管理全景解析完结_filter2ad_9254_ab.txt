          +0x000 Waiting          : 0y0
          +0x000 Waking           : 0y0
          +0x000 MultipleShared   : 0y0
          +0x000 Shared           : 0y0000000000000000000000000000 (0)
          +0x000 Value            : 0
          +0x000 Ptr              : (null)
       +0x098 DeviceMap        : (null)
       +0x09c SessionId        : 0xffffffff
       +0x0a0 NamespaceEntry   : (null)
       +0x0a4 Flags            : 0
我们就沿着展开第一个HashBuckets吧，看看里边的数据都是些什么。-r2是告诉Windbg递归展开内部2层。注意第二层的ChainLink为null，说明这条链已经到头了。我们来具体分析下HashBuckets[0]号链上的这两个元素都是啥对象。
先看第一个对象，如下；正好是root对象；
    0: kd> dt nt!_OBJECT_HEADER 0xa8610b60-18
       +0x000 PointerCount     : 0n6
       +0x004 HandleCount      : 0n0
       +0x004 NextToFree       : (null)
       +0x008 Lock             : _EX_PUSH_LOCK
       +0x00c TypeIndex        : 0x3 ''
       +0x00d TraceFlags       : 0 ''
       +0x00e InfoMask         : 0x2 ''
       +0x00f Flags            : 0x12 ''
       +0x010 ObjectCreateInfo : 0x00000001 _OBJECT_CREATE_INFORMATION
       +0x010 QuotaBlockCharged : 0x00000001 Void
       +0x014 SecurityDescriptor : 0xa860501c Void
       +0x018 Body             : _QUAD
第二个对象信息如下：
    0: kd> dt nt!_OBJECT_HEADER 0xa278b358-18
       +0x000 PointerCount     : 0n2
       +0x004 HandleCount      : 0n0
       +0x004 NextToFree       : (null)
       +0x008 Lock             : _EX_PUSH_LOCK
       +0x00c TypeIndex        : 0x19 ''
       +0x00d TraceFlags       : 0 ''
       +0x00e InfoMask         : 0x2 ''
       +0x00f Flags            : 0x12 ''
       +0x010 ObjectCreateInfo : 0x00000001 _OBJECT_CREATE_INFORMATION
       +0x010 QuotaBlockCharged : 0x00000001 Void
       +0x014 SecurityDescriptor : (null)
       +0x018 Body             : _QUAD
    0: kd> dt nt!_OBJECT_HEADER_NAME_INFO 0xa278b358-18-10
       +0x000 Directory        : 0xa8605ed0 _OBJECT_DIRECTORY
       +0x004 Name             : _UNICODE_STRING "Ntfs"
       +0x00c ReferenceCount   : 0n0
    0: kd> dt nt!_DEVICE_OBJECT 0xa278b358
       +0x000 Type             : 0n3
       +0x002 Size             : 0xb8
       +0x004 ReferenceCount   : 0n1
       +0x008 DriverObject     : 0xa2407660 _DRIVER_OBJECT
       +0x00c NextDevice       : (null)
       +0x010 AttachedDevice   : 0xa24648a8 _DEVICE_OBJECT
       +0x014 CurrentIrp       : (null)
       +0x018 Timer            : (null)
       +0x01c Flags            : 0x40
       +0x020 Characteristics  : 0
       +0x024 Vpb              : (null)
       +0x028 DeviceExtension  : (null)
       +0x02c DeviceType       : 8
       +0x030 StackSize        : 9 ''
       +0x034 Queue            : 
       +0x05c AlignmentRequirement : 0
       +0x060 DeviceQueue      : _KDEVICE_QUEUE
       +0x074 Dpc              : _KDPC
       +0x094 ActiveThreadCount : 0
       +0x098 SecurityDescriptor : 0xa87be310 Void
       +0x09c DeviceLock       : _KEVENT
       +0x0ac SectorSize       : 0x200
       +0x0ae Spare1           : 1
       +0x0b0 DeviceObjectExtension : 0xa278b410 _DEVOBJ_EXTENSION
       +0x0b4 Reserved         : (null)
    0: kd> dt 0xa2407660 _DRIVER_OBJECT
    ntdll!_DRIVER_OBJECT
       +0x000 Type             : 0n4
       +0x002 Size             : 0n168
       +0x004 DeviceObject     : 0xa2ee4020 _DEVICE_OBJECT
       +0x008 Flags            : 0x92
       +0x00c DriverStart      : 0xa782f000 Void
       +0x010 DriverSize       : 0x12f000
       +0x014 DriverSection    : 0xa192f368 Void
       +0x018 DriverExtension  : 0xa2407708 _DRIVER_EXTENSION
       +0x01c DriverName       : _UNICODE_STRING "\FileSystem\Ntfs"
       +0x024 HardwareDatabase : 0x841aa250 _UNICODE_STRING "\REGISTRY\MACHINE\HARDWARE\DESCRIPTION\SYSTEM"
       +0x028 FastIoDispatch   : 0xa786e900 _FAST_IO_DISPATCH
       +0x02c DriverInit       : 0xa79329fa     long  Ntfs!GsDriverEntry+0
       +0x030 DriverStartIo    : (null)
       +0x034 DriverUnload     : (null)
       +0x038 MajorFunction    : [28] 0xa78c7bc8     long  Ntfs!NtfsFsdCreate+0
都出来了，原来是文件系统下的一个文件设备驱动对象。ok，分析完上边两个Directory中的对象后，再回到之前说的Windbg的自动化命令的输出，我们来对比下：
是不是一模一样，现在你是否可以彻底搞明白Windbg的自动化命令是如何工作了的呢？不，我应该问，你是否彻底搞明白Windows的内核对象管理是如何实现了的呢？
## 4、附赠两张Windows内核对象全景图
下边这张图是我之前，很久以前学XP的时候自己总结的，而文章中讲解的是Win7的，所有有所区别，但原理是一样的，看这个图，有一种俯视的感觉：
## 5、作业
仿照着我给的上边这个图，把Win7下的内核对象管理也弄一张类似的图出来。