title:Using Amnesia to Detect Credential Database Breaches
author:Ke Coby Wang and
Michael K. Reiter
Using Amnesia to Detect Credential Database Breaches
Ke Coby Wang, University of North Carolina at Chapel Hill; 
Michael K. Reiter, Duke University
https://www.usenix.org/conference/usenixsecurity21/presentation/wang-ke-coby
This paper is included in the Proceedings of the 30th USENIX Security Symposium.August 11–13, 2021978-1-939133-24-3Open access to the Proceedings of the 30th USENIX Security Symposium is sponsored by USENIX.Using Amnesia to Detect Credential Database Breaches
Ke Coby Wang
University of North Carolina at Chapel Hill
Michael K. Reiter
Duke University
PI:EMAIL
PI:EMAIL
Abstract
Known approaches for using decoy passwords (honeywords)
to detect credential database breaches suﬀer from the need
for a trusted component to recognize decoys when entered
in login attempts, and from an attacker’s ability to test stolen
passwords at other sites to identify user-chosen passwords
based on their reuse at those sites. Amnesia is a framework
that resolves these diﬃculties. Amnesia requires no secret
state to detect the entry of honeywords and additionally al-
lows a site to monitor for the entry of its decoy passwords
elsewhere. We quantify the beneﬁts of Amnesia using proba-
bilistic model checking and the practicality of this framework
through measurements of a working implementation.
1 Introduction
Credential database breaches have become a widespread se-
curity problem. Verizon conﬁrmed 3950 database breaches
globally between Nov. 2018 and Oct. 2019 inclusive; of those
1665 breaches for which they identiﬁed victims, 60% leaked
credentials [43].1 Credential database breaches are the largest
source of compromised passwords used in credential stuﬃng
campaigns [42], which themselves are the cause of the vast
majority of account takeovers [41]. Unfortunately, there is
usually a signiﬁcant delay between the breach of a credential
database and the discovery of that breach; estimates of the
average delay range from 7 [23] to 15 [41] months. The result-
ing window of vulnerability gives attackers the opportunity to
crack the passwords oﬄine (if the stolen credential database
stores only password hashes), to determine their value by
probing accounts using them [41], and then to either use them
directly to extract value or sell them through illicit forums for
traﬃcking stolen credentials [41, 42].
Decoy passwords have been proposed in various forms to
interfere with the attacker’s use of a stolen credential database.
In these proposals (see Sec. 2), a site (the target) stores decoy
1This number excludes 14 breaches of victims in Latin America and the
Caribbean for which the rate of credential leakage was not reported.
passwords alongside real passwords in its credential database,
so that if the attacker breaches the database, the correct pass-
words are hidden among the decoys. The attacker’s entry of
a decoy password can alert the target to its breach; the term
honeywords has been coined for decoys used in this way [25].
While potentially eﬀective, honeywords suﬀer from two
related shortcomings that, we believe, have limited their use in
practice. First, previous proposals that leverage honeywords
require a trusted component to detect the entry of a honey-
word, i.e., a component that retains secret state even after
the target has been breached. Such a trusted component is a
strong assumption, however, and begs the question of whether
one could have been relied upon to prevent the breach of the
target’s database in the ﬁrst place. Second, the eﬀectiveness
of honeywords depends on the indistinguishability of the user-
chosen password from the decoys when they are exposed to an
attacker. However, because so many users reuse their chosen
passwords across multiple accounts [11, 36, 44], an attacker
can simply test (or stuﬀ ) all passwords for an account leaked
from the target at accounts for the same user at other sites.
Any password that works at another site is almost certainly
the user-chosen password at the target.
In this paper, we resolve both of these diﬃculties and re-
alize their solutions in a framework called Amnesia. First,
we show that honeywords can be used to detect a target’s
database breach with no persistent secret state at the target,
a surprising result in light of previous work. Speciﬁcally,
we consider a threat model in which the target is breached
passively but completely and potentially repeatedly. Without
needing to keep secrets from the attacker, Amnesia neverthe-
less enables the target to detect its own breach probabilis-
tically, with beneﬁts that we quantify through probabilistic
model checking. Our results show, for example, that Amnesia
substantially reduces the time an attacker can use breached
credentials to access accounts without alerting the target to
its breach.
To address credential stuﬃng elsewhere to distinguish the
user-chosen password from the honeywords, Amnesia enables
the target to monitor for the entry of passwords stolen from it
USENIX Association
30th USENIX Security Symposium    839
at other sites, called monitors. Via this framework, incorrect
passwords entered for the same user at monitors are treated
(for the purposes of breach detection) as if they had been
entered locally at the target. One innovation to accomplish
this is a cryptographic protocol by which a monitor transfers
the password attempted in an unsuccessful login there to
the target, but only if the attempted password is one of the
passwords (honey or user-chosen) for the same account at the
target; otherwise, the target learns nothing. We refer to this
protocol as a private containment retrieval (PCR) protocol,
for which we detail a design and show it secure. Leveraging
this PCR protocol, we show that Amnesia requires no trust in
the monitors for the target to accept a breach notiﬁcation. In
other words, even if a monitor is malicious, it cannot convince
an unbreached target that it has been breached.
We ﬁnally describe the performance of our Amnesia imple-
mentation. Our performance results suggest that the compu-
tation, communication and storage costs of distributed mon-
itoring are minimal. For example, generating a monitoring
response takes constant time and produces a constant-size
result, as a function of the number of honeywords, and is prac-
tical (e.g., no more than 10ms and about 1KB, respectively).
To summarize, our contributions are as follows:
• We develop the ﬁrst algorithm leveraging honeywords by
which a target site can detect the breach of its password
database, while relying on no secret persistent state. We
evaluate this design using probabilistic model checking to
quantify the security it provides.
• We extend this algorithm with a protocol to monitor ac-
counts at monitors to detect the use of the target’s hon-
eywords there. Our algorithm is the ﬁrst such proposal to
ensure no false detections of a database breach, despite
even malicious behavior by monitors.
• A core component of this algorithm is a new cryptographic
protocol we term a private containment retrieval protocol,
which we detail and prove correct.
• We describe the performance of our algorithm using an
implementation and show that it is practical.
2 Related Work
Within research on decoy passwords, we are aware of only
two proposals by which a target can detect its own breach
using them. Juels and Rivest [25] coined the term honeywords
for decoy passwords submitted in login attempts to signal to a
site that it was breached by an attacker. In their proposal and
works building on it (e.g., [14]), the target is augmented with a
trusted honeychecker that stores which of the passwords listed
with the account is the user-chosen one; login attempts with
others alert the site to its breach. Almeshekah et al. [2] use
a machine-dependent function (e.g., hardware security mod-
ule) in the password hash at the target site to prevent oﬄine
cracking of its credential database if breached. Of more rele-
vance here, an attacker who is unaware of this defense and so
attempts to crack its database oﬄine will produce plausible de-
coy passwords (ersatzpasswords) that, when submitted, alert
the target site to its breach. The primary distinction between
these proposals and ours is that ours permits a target to detect
its own breach without any secret persistent state. In con-
trast, these proposals require a trusted component—the hon-
eychecker or the machine-dependent function—whose state
is assumed to remain secret even after the attacker breaches
the site. In addition, we reiterate that ersatzpasswords are
eﬀective in alerting the target to its breach only if the at-
tacker is unaware of the use of this scheme, as otherwise the
attacker will know that passwords generated through oﬄine
cracking without access to the machine-dependent function
are ersatzpasswords.
Other uses of decoy passwords leverage defenses at other,
unbreached sites—either their online guessing defenses gener-
ically [5,28] or their cooperation to check for decoy passwords
speciﬁcally [5, 48]—to defend accounts whose credentials
have been stolen, whether by phishing [48], user device com-
promise [5], or the target site’s database breach [28]. While
we extend our design in Sec. 5 to monitor for a target’s hon-
eywords being submitted in login attempts at monitors, to
our knowledge our design is the ﬁrst to eliminate the need
for the target to trust another site in order to accept that a
detected breach actually occurred. Speciﬁcally, in our design
a monitor, even if malicious, cannot convince an unbreached
site that it has been breached.
Various other works have leveraged decoy accounts to de-
tect credential database breaches, i.e., accounts with no owner
that, if ever accessed, reveal the breach of the account’s site or
a site where a replica of the account was created (e.g., [14,21]).
In Tripwire [13], each decoy account is registered with a dis-
tinct email address and password, for which the password at
the email provider is the same. Any login to the email account
(provided that the email provider is itself not compromised)
suggests the breach of the website where that email address
was used to register an account. Like the previously discussed
proposals, this design places trust in the detecting party (the
email provider or, in this case, the researchers working with it)
to be truthful when reporting the breach of a target. Indeed,
DeBlasio et al. report that sites’ unwillingness to trust the
evidence they provided of the sites’ breaches was an obsta-
cle to getting them to act.2 Moreover, the utility of artiﬁcial
accounts hinges critically on their indistinguishability from
real ones, and if methods using them became eﬀective in hin-
dering attacker activity, ensuring the indistinguishability of
these accounts would presumably become its own arms race.
Our design is agnostic to whether it is deployed on real or
decoy accounts, sidestepping the need for convincing decoy
accounts but also demanding attention to the risks to real
2The paper concludes, “A major open question, however, is how much
(probative, but not particularly illustrative) evidence produced by an external
monitoring system like Tripwire is needed to convince operators to act, such
as notifying their users and forcing a password reset” [13, Section 8].
840    30th USENIX Security Symposium
USENIX Association
accounts that it might introduce.
To be fair, generation of honeywords that are suﬃciently
indistinguishable from real ones is itself a topic of active
investigation (e.g., [1, 14, 45]). Here we will simply assume
that a site can generate honeywords in isolation to satisfy
certain properties, detailed in Sec. 3. The development of
methods to achieve these properties is a separate concern.
An alternative to decoy passwords or accounts for defend-
ing against a breach of a site’s credential database is for the
site to instead leverage a breach-hardening service. Even
after having breached the target’s credential database, the at-
tacker must succeed in an online dictionary attack with the
breach-hardening service per stolen credential he wishes to
use, provided that the breach-hardening service is itself not si-
multaneously breached (e.g., [15,30–32,40]). While diﬀering
in their details, these schemes integrate the breach-hardening
service tightly into the target’s operation, in the sense that,
e.g., the benign failure of a breach-hardening service would
interfere with login attempts at the target. In contrast, while
the benign failure of our monitors would render them useless
for helping to detect the target’s breach, the operation of the
target would be otherwise unaﬀected.
3 Honeywords
We assume the existence of a randomized honeyword genera-
tor HoneyGen that, given an account identiﬁer a, user-chosen
password πa, and integer k, produces a set Πa containing πa
and k other strings and having the following properties. We
use “←” to denote assignment of the result of evaluating the
expression on its right to the variable on its left, and “ $←” to
denote sampling an element uniformly at random from the set
on its right and assigning the result to the variable on its left.
First, the essential purpose of honeywords is to make it
diﬃcult for an adversary who breaches a credential database
to determine which of the passwords listed for an account
a is the user-chosen one. In other words, for any attacker
algorithm A that is given the account identiﬁer a and its set
of passwords Πa, we assume
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) Πa ← HoneyGen(a, πa ,k)
π ← A(a, Πa)
(cid:19) ≈ 1
(1)
k + 1
(cid:18)
P
π = πa
Second, because honeywords are intended to alert the
target to a breach of its credential database, avoiding false
alarms requires that an adversary be unable to generate a hon-
eyword for an account without having actually breached the
target. In particular, this property would ideally be achieved
even if the user-chosen password πa is known, e.g., because
the user was phished or because she reused πa as her pass-
word at another site that was compromised. While these place
the user’s account at the target at risk, neither equates to
the target’s wholesale breach and so should not suﬃce to
induce a breach detection at the target. That is, for any at-
tacker algorithm B that knows only the account identiﬁer a
and user-chosen password πa, we assume:
(cid:18)
π ∈ Πa \{πa}
P
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) Πa ← HoneyGen(a, πa ,k)
(cid:19) ≈ 0
π ← B(a, πa)
(2)
This assumption implies that any two invocations of
HoneyGen(a, πa ,k) produce sets Πa, Π(cid:48)
a that intersect only
in πa with near certainty. Otherwise, an adversary B(a, πa)
a ← HoneyGen(a, πa ,k) and returns a random
that invokes Π(cid:48)
a \{πa} would violate (2). In other words, (2) implies
π ∈ Π(cid:48)
that the honeywords generated at two diﬀerent sites for the
same user’s accounts are distinct, even if the user reuses the
same password for both accounts.
4 Detecting Honeyword Entry Locally
The ﬁrst contribution of this paper is in demonstrating how the
target site can detect its own breach while relying on no secret
persistent state. We detail the threat model for this section in
Sec. 4.1 and provide the detection algorithm in Sec. 4.2. We
demonstrate the eﬃcacy of this algorithm in Sec. 4.3.
4.1 Threat Model
Our goal is to enable a site, called the target, to detect that its
credential database has been stolen. We assume that the target
uses standard password-based authentication, i.e., in which
the password is submitted to the target under the protection
of a cryptographic protocol such as TLS.
We allow for an attacker to breach the target passively only,
in which case it captures all persistent storage at the site asso-
ciated with validating or managing account logins. Through-
out this paper, this persistent storage is denoted DB, and in-
formation associated speciﬁcally with account a is denoted
DBa. In particular, the information captured includes the pass-
words listed for each of the site’s user accounts (DBa .auths);
if stored as salted hashes, the attacker can crack the pass-
words oﬄine. The attacker also captures any long-term cryp-