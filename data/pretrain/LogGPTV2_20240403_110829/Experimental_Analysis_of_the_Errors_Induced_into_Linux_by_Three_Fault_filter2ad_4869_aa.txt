title:Experimental Analysis of the Errors Induced into Linux by Three Fault
Injection Techniques
author:Tahar Jarboui and
Jean Arlat and
Yves Crouzet and
Karama Kanoun
Experimental Analysis of the Errors Induced into Linux
by Three Fault Injection Techniques
Tahar Jarboui, Jean Arlat, Yves Crouzet and Karama Kanoun
LAAS-CNRS, 7 avenue du Colonel Roche 31077 Toulouse Cedex 4 — France
{jarboui, arlat, crouzet, kanoun}@laas.fr
Abstract
The  main  goal of  the  experimental study  reported  in
this  paper  is  to  investigate  to  what  extent  distinct
fault injection techniques lead to similar consequences
(errors and failures). The  target system  we  are  using
to carry out our investigation is the Linux kernel as it
provides  a  representative  operating  system.  It  is
featuring full  controllability and observability  thanks
to  its  open  source  status.  Three  types  of  software-
implemented fault injection  techniques are considered,
namely: 
the
parameters  of  the  kernel  calls,  ii) corruption  of  the
parameters of  the  kernel calls,  and  iii)  corruption  of
the  input  parameters of  the  internal  functions  of  the
kernel. The  workload being  used for the  experiments
is  tailored  to  activate  selectively  each  functional
component.  The  observations  encompass 
typical
kernel  failure  modes  (e.g.,  exceptions  and  kernel
hangs) as well  as  a  detailed  analysis  of  the  reported
error codes.
i) provision  of 
invalid  values 
to 
1.  Introduction
implementation, 
injection 
Many supporting tools and techniques exist today that
facilitate and automate the  conduct  of  fault  injection
experiments [1]. In particular, due to its wide range of
the
applicability  and  ease  of 
software-implemented 
fault 
technique
(SWIFI) is now  very popular.  Nevertheless, although
several studies have  shown  the  wide  range  of  faults
that SWIFI can simulate  (e.g.,  see [2-4]), more work
is needed to better understand the actual behaviors that
are  induced  by  this 
technique.  Indeed,  such  an
understanding  and  characterization  of  the  erroneous
behaviors 
injection
experiments 
into  well-established
dependability  benchmarks.  Previous  work  on
robustness 
target
operating  system  is  subjected  to  erroneous  and/or
stressful kernel calls offers a  promising  contribution
for  characterizing  operating  system  behavior  in  the
presence  of  faults  [5-7].  Nevertheless,  in  order  to
facilitate  the  acceptance  and  the  portability  of  such
benchmarks, we have also to rely as much as possible
on  well-identified  Application 
Programming
is  mandatory  so 
techniques  where 
that  fault 
testing 
turn 
can 
the 
that 
strong 
faultloads 
impact  on 
for  generating 
Interfaces (APIs) to  precisely specify how  to  perturb
the  operating  system  and  enhance  our  understanding
of  the  erroneous  behaviors  caused  by  the  various
injection  possibilities 
that  can  be  supported  by
SWIFI.
The ultimate aim of this  work is  the  identification of
techniques 
are
representative  of  software  faults  that  may  impact
operating systems. Indeed, operating systems (OS) are
critical  components  of  any  computer  system.  Their
malfunctions  have  a 
the
dependability  of  the  global  system.  As  a  pragmatic
approach we investigate to  what extent  distinct  fault
injection  techniques  lead  to  similar  consequences.
Indeed,  in  such  case,  it  is  worthwhile  to  select  the
technique that is easier to apply.
Even  though  perturbations  affecting  the  operating
system  depend  on 
the  application  domain  (for
example, space systems are more exposed to  hardware
errors caused by  radiations), all  software  systems  are
under the threat of software faults.  This  paper focuses
on software faults.
The  Linux  kernel  was  selected  as  a  target  for  our
experiments as  it  provides a representative  OS.  It  is
featuring  high 
and
observability thanks  to  its  open source  status.  Fault
model  equivalence 
the
observations made after each experiment. We rely on
the  error detection mechanisms of  Linux  to  draw our
conclusions. We focus our analysis on  the  scheduling
component.
The results presented in this paper reveal i)  differences
in  the  system  behavior  in  the  presence  of  either
internal faults or faults applied at the API level and ii)
some  similarities  for  the  two  injection  techniques
used at  the  API  level,  from the  point  of  view of  the
errors provoked, with  a slight  advantage  for  the  bit-
flip  technique  since  it  was  able  to  provoke  more
distinct erroneous behaviors. Nevertheless, the  set  of
invalid parameters used in these experiments could be
enriched to  include additional invalid cases.  The  first
results corroborate the insights obtained in  [5] for the
Chorus  microkernel,  for  which  the  failure  modes
induced  by 
the  memory
containing the code and data of the  microkernel and at
the API were different.
injecting  bit-flips 
is  established 
controllability 
through 
level 
of 
in 
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:15:42 UTC from IEEE Xplore.  Restrictions apply. 
The  rest  of  the  paper  is  organized  as  follows.
Section 2  presents  the  target  system  model.  The
experimental  framework  is  presented  in  Section  3.
Result  analysis  and  comparison  between  the  three
fault injection  techniques are presented in  Section  4.
Concluding remarks are drawn in Section 5.
2.  Target  system  model
file 
to  distinguish 
synchronization, 
The  target  of  our  study  is  the  Linux  kernel.  Four
main  entry  points  can  be  identified,  through  which
Linux  kernel functions  are executed. Indeed, a switch
to  kernel  mode  can  be  triggered  by:  i) an  interrupt
issued to  the  CPU  by  a  hardware  device  to  indicate
that it requires attention, ii) an  exception signaled by
a  CPU  because  of  an  error,  iii) a kernel  call  (or
system  call) issued by  an application or  iv) a  kernel
thread.  The  activation  of  kernel  internal  functions
depends on these entry points  but  also  on  the  current
state  of  the  kernel. In  this  paper,  we  concentrate  on
the third entry point: kernel calls issued via the API.
Based on  the  work presented in  [8],  and  to  facilitate
the  analysis  of  the  Linux  kernel,  we  decomposed  it
into five functional components:  scheduling, memory
management, 
system(s)
management  and  communication.  Each  functional
component is composed of elementary functions.
It  is  worthwhile 
the  elementary
functions  that  are  reachable  from  the  API  (kernel
calls) from those that  are not  (internal functions).  By
modifying  the  gcc  compiler,  we  were  able  to
generate at  kernel  compilation  a  call  graph  for  each
kernel  call.  A  call  graph  is  composed  of 
the
elementary functions  called  by  the  considered  kernel
call.  For  each kernel call,  we define depth levels.  As
an example, Figure  1  describes the  call graph for the
kernel call sched_setscheduler that has  three depth
levels.  The “system_call” node is  present  in  all  call
graphs associated  with  any  kernel  call.  It  represents
the kernel call entry point.
The goal is to analyze the degree of similarities of  the
erroneous  behaviors  reported  for  the  kernel  as  a
consequence of  fault injection  at  the  first  level (API)
and  in  lower  levels.  The  dots  at  the  end  of  arrows
represent the  fault  injection  locations.  The  injection
at  the  first  level  corresponds  to  external  faults,
whereas 
levels
(i.e., inside  the  kernel)  maps  to  internal  faults.
The injection  techniques used are detailed in  the  next
section.  We detail in  section 4  the  results  related  to
some  kernel  calls  of 
the  scheduling  functional
component.
injection 
lower 
fault 
in 
the 
3.  Experimental  framework
in 
[9] 
those  classified 
In  this  study,  three  fault  models  are  considered.  A
fault model is  defined with  respect  to  the  fault  type
and to the fault location. The fault types used are b i t -
flips  and  invalid  parameters.  We  consider  two
locations,  either the  parameters of  the  targeted kernel
call  (i.e.,  external  faults)  or  the  parameters  of  the
underlying  kernel  functions  (i.e., internal  faults).
External  faults  mimic  faults  from  the  application
level  and  they  test  the  robustness  of  the  kernel.
Internal faults  emulate various classes of  faults  such
as 
the  Orthogonal  Defect
Classification 
(e.g.,  assignment,  checking,
interface,  etc).  In  this  paper,  we  consider  only  the
interface class as indicated in Figure 1.
We associate a fault injection technique model to  each
fault model. The three considered injection  techniques
are  thus:  i)  provision  of  API  invalid  parameters,
ii) bit-flip  in  API  parameters,  and  iii)  bit-flip  in
internal function parameters.
The goal is to inject various faults and to  observe and
compare the resulting error sets. We have developed a
versatile tool  supporting  the  application of  the  three
injection  techniques.  Each  technique  requires  four
main steps:
1) The kernel calls issued by the process that the tool
is  tracing  are  intercepted.  The  tool  uses  Linux
ptrace() interface and intercepts  kernel  calls  in
user mode as in [10] and [11]. The kernel call that
is  targeted  by  the  fault  injection  experiment  is
thus interrupted.
2) A  fault  is  injected  according  to  the  associated
model  (i.e.,  technique).  The  injection  process
ensures the  synchronization between the  fault and
the  workload  and 
result
comparison for the three techniques.
thus  allows 
for 
3) The  execution  of  the  interrupted  kernel  call  is
resumed.
4)  The system behavior is observed.
system_call
API
sched_setscheduler
Level 1
setscheduler
Level 2
find_process_by_pid
move_first_runqueue
Level 3
Fault injection location
Figure 1- Call graph for sched_setscheduler kernel call
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:15:42 UTC from IEEE Xplore.  Restrictions apply. 
Table 1- Data type classes used by the scheduling component
Permission flag
Integer
Process identifier
Read pointer
Write pointer
Time pointer
-1
INT_MIN