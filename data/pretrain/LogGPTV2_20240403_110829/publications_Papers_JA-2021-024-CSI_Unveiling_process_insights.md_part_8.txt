### References

1. **Sequences of Developer Interactions in Visual Studio for Usage Smells**  
   *IEEE Transactions on Software Engineering* 43 (4) (2017) 359–371.  
   doi:10.1109/TSE.2016.2592905.

2. **The Statechart Workbench: Enabling Scalable Software Event Log Analysis Using Process Mining**  
   M. Leemans, W. M. P. van der Aalst, M. G. J. van den Brand  
   *2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)*, IEEE, 2018, pp. 502–506.  
   doi:10.1109/SANER.2018.8330248.

3. **Measuring Program Comprehension: A Large-Scale Field Study with Professionals**  
   X. Xia, L. Bao, D. Lo, Z. Xing, A. E. Hassan, S. Li  
   *IEEE Transactions on Software Engineering* 44 (10) (2018) 951–976.  
   doi:10.1109/TSE.2017.2734091.

4. **Assessing Software Development Teams’ Efficiency Using Process Mining**  
   J. Caldeira, F. Brito e Abreu, J. Reis, J. Cardoso  
   *2019 International Conference on Process Mining (ICPM)*, Institute of Electrical and Electronics Engineers (IEEE), 2019, pp. 65–72.  
   doi:10.1109/ICPM.2019.00020.

5. **Evaluating Coding Behavior in Software Development Processes: A Process Mining Approach**  
   P. Ardimento, M. L. Bernardi, M. Cimitile, F. M. Maggi  
   *2019 IEEE/ACM International Conference on Software and System Processes (ICSSP)*, IEEE, 2019, pp. 84–93.  
   doi:10.1109/ICSSP.2019.00020.

6. **Learning Analytics to Improve Coding Abilities: A Fuzzy-Based Process Mining Approach**  
   P. Ardimento, M. L. Bernardi, M. Cimitile, G. De Ruvo  
   *IEEE International Conference on Fuzzy Systems, Vol. 2019-June*, Institute of Electrical and Electronics Engineers Inc., 2019, pp. 1–7.  
   doi:10.1109/FUZZ-IEEE.2019.8859009.

7. **Mining Developer’s Behavior from Web-Based IDE Logs**  
   P. Ardimento, M. L. Bernardi, M. Cimitile, G. De Ruvo  
   *2019 IEEE 28th International Conference on Enabling Technologies: Infrastructure for Collaborative Enterprises (WETICE)*, IEEE, 2019, pp. 277–282.  
   doi:10.1109/WETICE.2019.00065.

8. **Bad Smells in Code**  
   K. Beck, M. Fowler, J. Brant, W. Opdyke, D. Roberts  
   *Improving the Design of Existing Code*, O’Reilly, 1999, Ch. 3, pp. –.

9. **BPMN: An Introduction to the Standard**  
   M. Chinosi, A. Trombetta  
   *Computer Standards & Interfaces* 34 (1) (2012) 124–134.

10. **XES Standard Definition**  
    C. Günther, E. Verbeek  
    Tech. rep., BPMcenter.org (2014).

11. **A Systematic Mapping Study of Process Mining**  
    A. R. C. Maita, L. C. Martins, C. R. López Paz, L. Rafferty, P. C. K. Hung, S. M. Peres, M. Fantinato  
    *Enterprise Information Systems* 12 (5) (2018) 505–549.  
    doi:10.1080/17517575.2017.1402371.

12. **Process Mining Techniques and Applications – A Systematic Mapping Study**  
    C. d. S. Garcia, A. Meincheim, E. R. Faria Junior, M. R. Dallagassa, D. M. V. Sato, D. R. Carvalho, E. A. P. Santos, E. E. Scalabrin  
    *Expert Systems with Applications* 133 (2019) 260–295.  
    doi:10.1016/j.eswa.2019.05.003.

13. **Recursion Aware Modeling and Discovery for Hierarchical Software Event Log Analysis**  
    M. Leemans, W. M. P. van der Aalst, M. G. J. van den Brand  
    *2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)*, 2018, pp. 185–196.  
    doi:10.1109/SANER.2018.8330208.

14. **EBK-Means: A Clustering Technique Based on Elbow Method and K-Means in WSN**  
    B. Purnima, K. Arvind  
    *International Journal of Computer Applications* 105 (9) (2014) 17–24.

15. **The Silhouette Width Criterion for Clustering and Association Mining to Select Image Features**  
    N. Kaoungku, K. Suksut, R. Chanklan, K. Kerdprasop, N. Kerdprasop  
    *International Journal of Machine Learning and Computing* 8 (1) (2018) 69–73.  
    doi:10.18178/ijmlc.2018.8.1.665.

16. **Hyperparameter Optimization for Effort Estimation**  
    T. Xia, R. Krishna, J. Chen, G. Mathew, X. Shen, T. Menzies  
    Tech. rep., North Carolina State University (April 2018).

17. **Clustering DyCoMan: An Online Cross-Company Software Effort Estimation Study**  
    L. L. Minku, S. Hou  
    *ACM International Conference Proceeding Series*, Association for Computing Machinery, 2017, pp. 12–21.  
    doi:10.1145/3127005.3127007.

18. **Census Data Mining and Data Analysis Using WEKA**  
    S. B. Jagtap, B. G. Kodge  
    *International Conference in Emerging Trends in Science, Technology and Management-2013*, Singapore, 2013, pp. –.

19. **Auto-WEKA 2.0: Automatic Model Selection and Hyperparameter Optimization in WEKA**  
    C. Thornton, H. H. Hoos, K. Leyton-Brown  
    *Journal of Machine Learning Research* 1 (2017) 429.

20. **Which Process Metrics Can Significantly Improve Defect Prediction Models? An Empirical Study**  
    L. Madeyski, M. Jureczko, M. Jureczko  
    *Software Quality Journal* 23 (2015) 393–422.  
    doi:10.1007/s11219-014-9241-7.

### Appendix A. Product Metrics

**Table A.7: Product Metrics Description**

| Name | Description | Scale |
|------|-------------|-------|
| VG | McCabe Cyclomatic Complexity (Avg. per Method) | Numeric |
| PAR | Number of Parameters (Avg. per Method) | Numeric |
| NBD | Nested Block Depth (Avg. per Method) | Numeric |
| CA | Afferent Coupling (Avg. per Package Fragment) | Numeric |
| CE | Efferent Coupling (Avg. per Package Fragment) | Numeric |
| RMI | Instability (Avg. per Package Fragment) | Numeric |
| RMA | Abstractness (Avg. per Package Fragment) | Numeric |
| RMD | Normalized Distance (Avg. per Package Fragment) | Numeric |
| DIT | Depth of Inheritance Tree (Avg. per Type) | Numeric |
| WMC | Weighted Methods per Class (Avg. per Type) | Numeric |
| NSC | Number of Children (Avg. per Type) | Numeric |
| NORM | Number of Overridden Methods (Avg. per Type) | Numeric |
| LCOM | Lack of Cohesion of Methods (Avg. per Type) | Numeric |
| NOF | Number of Attributes (Avg. per Type) | Numeric |
| NSF | Number of Static Attributes (Avg. per Type) | Numeric |
| SIX | Specialization Index (Avg. per Type) | Numeric |
| NOP | Number of Packages | Numeric |
| NOC | Number of Classes (Avg. per Package Fragment) | Numeric |
| NOI | Number of Interfaces (Avg. per Package Fragment) | Numeric |
| NOM | Number of Methods (Avg. per Type) | Numeric |
| NSM | Number of Static Methods (Avg. per Type) | Numeric |
| MLOC | Method Lines of Code (Avg. per Method) | Numeric |
| TLOC | Total Lines of Code | Numeric |
| VG LEVEL | Different levels of ∆VG (LOW, MEDIUM, HIGH) | Categorical |

### Appendix B. Process Metrics

**Table A.8: Process Metrics Description**

| Name | Description | Scale |
|------|-------------|-------|
| DEV | Number of Developers | Numeric |
| SES | Number of User/Development Sessions | Numeric |
| EVTS | Number of Events Collected | Numeric |
| NFILES | Number of Unique Files Touched | Numeric |
| NCOM | Number of Unique Commands Issued in IDE | Numeric |
| PCCPF | Process Cyclomatic Complexity per File Touched | Numeric |
| EC | Number of Event Classes | Numeric |
| NOA | Number of Activities | Numeric |
| NSS | Number of Simple States | Numeric |
| NCS | Number of Composite States | Numeric |
| NOT | Number of Transitions | Numeric |
| PCC | Process Cyclomatic Complexity | Numeric |
| NVER | Number of Unique IDE Versions | Numeric |
| NCAT | Number of Unique Command Categories | Numeric |
| NPLA | Number of Unique IDE Platforms | Numeric |
| NISP | Number of Unique Geographic Locations | Numeric |
| NOS | Number of Unique Operating Systems | Numeric |
| NPER | Number of Unique Perspectives used in the IDE | Numeric |
| PCC LEVEL | Different levels of PCC (LOW, HIGH) | Categorical |

### Appendix C. Process-Extended Metrics

**Table A.9: Process-Extended Metrics Description**

| Category | Name | Scale |
|----------|------|-------|
| Refactor | Java-Extract Method | Numeric |
| Refactor | Java-Move - Refactoring | Numeric |
| Refactor | Java-Extract Class... | Numeric |
| Refactor | Java-Rename - Refactoring | Numeric |
| Refactor | Delete Resources | Numeric |
| Refactor | Java-Encapsulate Field | Numeric |
| Refactor | Java-Change Method Signature | Numeric |
| Refactor | Java-Move Type to New File | Numeric |
| Eclipse Editor | File Open | Numeric |
| Eclipse Editor | File Editing | Numeric |
| Eclipse Editor | File Close | Numeric |
| Project Explorer | Project Explorer | Numeric |
| Package Explorer | Package Explorer | Numeric |
| Code Smell Visualization | Long Method | Numeric |
| Code Smell Visualization | God Class | Numeric |
| Code Smell Visualization | Feature Envy | Numeric |
| Code Smell Visualization | Duplicated Code | Numeric |
| Eclipse View | Find and Replace | Numeric |
| Eclipse View | Copy | Numeric |
| Eclipse View | Paste | Numeric |
| Eclipse View | Edit Cut | Numeric |
| Eclipse View | Delete | Numeric |
| Eclipse View | Undo | Numeric |
| Eclipse View | Redo | Numeric |
| Eclipse View | Import | Numeric |
| Eclipse View | Refresh | Numeric |
| File | Save | Numeric |
| File | Save All | Numeric |
| Source | Generate Getters and Setters | Numeric |
| Compare | Select Next Change | Numeric |
| ... | ... | ... |
| Text Editing | Delete Previous Word | Numeric |

### Appendix D. Algorithms Shown in Model Evaluations

- **RandomCommittee**: Method for building an ensemble of randomizable base classifiers. Each base classifier is built using a different random seed number (but based on the same data). The final prediction is a straight average of the predictions generated by the individual base classifiers.
- **RandomSubSpace**: This method constructs a decision tree-based classifier that maintains the highest accuracy on training data and improves generalization accuracy as it grows in complexity. The classifier consists of multiple trees constructed systematically by pseudo-randomly selecting subsets of components of the feature vector, i.e., trees constructed in randomly chosen sub-spaces.
- **RandomForest**: Method for constructing a forest of random trees. It consists of a learning method for classification, regression, and other tasks that operates by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees.
- **RepTree**: Fast decision tree learner. Builds a decision/regression tree using information gain/variance and prunes it using reduced-error pruning (with back-fitting). Only sorts values for numeric attributes once. Missing values are dealt with by splitting the corresponding instances into pieces.
- **LMT (Logistic Model Trees)**: Classification trees with logistic regression functions at the leaves. The algorithm can deal with binary and multi-class target variables, numeric and nominal attributes, and missing values.
- **Logistic Regression**: Method for building and using a multinomial logistic regression model with a ridge estimator. Logistic regression is a statistical model that, in its basic form, uses a logistic function to model a binary dependent variable, although more complex extensions exist.
- **LWL (Locally Weighted Learning)**: Uses an instance-based algorithm to assign instance weights, which are then used by a specified WeightedInstancesHandler. Can do classification (e.g., using naive Bayes) or regression (e.g., using linear regression).
- **LinearNNSearch**: Implements the brute-force search algorithm for nearest neighbor search.
- **DecisionTable**: Builds and uses a simple decision table majority classifier.
- **Bagging**: Method for bagging a classifier to reduce variance. Can do classification and regression depending on the base learner.
- **KStar**: An instance-based classifier where the class of a test instance is based upon the class of those training instances similar to it, as determined by some similarity function. It differs from other instance-based learners in that it uses an entropy-based distance function.

### Appendix E. Best-Fit Models - Source Code

#### Listing 2: Best-Fit Model Code for Refactoring Practice Detection

```java
// Java code to implement the best model found.
// Attribute Search
AttributeSelection as = new AttributeSelection();
ASSearch asSearch = ASSearch.forName("weka.attributeSelection.GreedyStepwise", 
                                     new String[]{"-C", "-R"});
as.setSearch(asSearch);

// Attribute Evaluation and Selection
ASEvaluation asEval = ASEvaluation.forName("weka.attributeSelection.CfsSubsetEval", 
                                           new String[]{"-M", "-L"});
as.setEvaluator(asEval);
as.SelectAttributes(instances);

// Reduce Dimensions
instances = as.reduceDimensionality(instances);

// Build Classifier
Classifier classifier = AbstractClassifier.forName("weka.classifiers.meta.RandomCommittee", 
                                                  new String[]{"-I", "64", "-S", "1", "-W", 
                                                                "weka.classifiers.trees.RandomForest", 
                                                                "--", "-I", "29", "-K", "13", "-depth", "3"});
classifier.buildClassifier(instances);
```

#### Listing 3: Best-Fit Model Code for Expected Cyclomatic Complexity Level Detection

```java
// Java code to implement the best model found.
// Attribute Search
AttributeSelection as = new AttributeSelection();
ASSearch asSearch = ASSearch.forName("weka.attributeSelection.GreedyStepwise", 
                                     new String[]{"-C", "-R"});
as.setSearch(asSearch);

// Attribute Evaluation and Selection
ASEvaluation asEval = ASEvaluation.forName("weka.attributeSelection.CfsSubsetEval", 
                                           new String[]{"-L"});
as.setEvaluator(asEval);
as.SelectAttributes(instances);

// Reduce Dimensions
instances = as.reduceDimensionality(instances);

// Build Classifier
Classifier classifier = AbstractClassifier.forName("weka.classifiers.lazy.LWL", 
                                                  new String[]{"-K", "60", "-A", 
                                                                "weka.core.neighboursearch.LinearNNSearch", 
                                                                "-W", "weka.classifiers.rules.DecisionTable", 
                                                                "--", "-E", "auc", "-S", 
                                                                "weka.attributeSelection.GreedyStepwise", "-X", "2"});
classifier.buildClassifier(instances);
```

This revised version provides a more structured and professional format, with clear and consistent formatting for references and appendices.