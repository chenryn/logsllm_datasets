类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要
注意子类函数的访问修饰权限不能少于父类的。
public class Father {
public static void main(String[] args) {
// TODO Auto-generated method stub
Son s = new Son();
s.sayHello();
}
public void sayHello() {
System.out.println("Hello");
}
}
class Son extends Father{
@Override
public void sayHello() {
// TODO Auto-generated method stub
System.out.println("hello by ");
}
}
原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。
重写 总结：
1.发生在父类与子类之间
2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同
3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)
4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常
重载（Overload）
在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）
则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来
判断重载。
public class Father {
public static void main(String[] args) {
// TODO Auto-generated method stub
Father s = new Father();
s.sayHello();
s.sayHello("wintershii");
}
public void sayHello() {
System.out.println("Hello");
}
public void sayHello(String name) {
System.out.println("Hello" + " " + name);
}
}
重载总结：
1.重载Overload是一个类中多态性的一种表现
2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)
3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准
25、equals与==的区别
==：
== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是
指相同一个对象。比较的是真正意义上的指针操作。
1、比较的是操作符两端的操作数是否是同一个对象。
2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。
3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：
int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。
equals：
equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以
适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的
equals方法返回的却是==的判断。
总结：
所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的
equals object可能为null 则空指针
在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排
查老代码使用“==”，替换成equals
36、++i与i++的区别
i++：先赋值，后计算
++i：先计算，后赋值
37、程序的结构有那些？
顺序结构
选择结构
循环结构
38、数组实例化有几种方式？
静态实例化：创建数组的时候已经指定数组中的元素,
int [] a= new int[]{ 1 , 3 , 3}
动态实例化：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值
39、Java中各种数据默认值
Byte,short,int,long默认是都是0
Boolean默认值是false
Char类型的默认值是’’
Float与double类型的默认是0.0
对象类型的默认值是null
40、Java常用包有那些？
Java.lang
Java.io
Java.sql
Java.util
Java.awt
Java.net
Java.math
41、Object类常用方法有那些？
Equals
Hashcode
toString
wait
notify
clone
getClass
42、java中有没有指针？
有指针，但是隐藏了，开发人员无法直接操作指针，由jvm来操作指针
43、java中是值传递引用传递？
理论上说，java都是引用传递，对于基本数据类型，传递是值的副本，而不是值本身。对于对象类型，传递是对象的引用，当在一个方法操
作操作参数的时候，其实操作的是引用所指向的对象。
44、实例化数组后，能不能改变数组长度呢？
不能，数组一旦实例化，它的长度就是固定的
45、假设数组内有5个元素，如果对数组进行反序，该如何做？
创建一个新数组，从后到前循环遍历每个元素，将取出的元素依次顺序放入新数组中
46、形参与实参区别
实参(argument)：
全称为"实际参数"是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用
时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。
形参(parameter)：
全称为"形式参数" 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数
时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。
形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。
实参出现在主调函数中，进入被调函数后，实参变量也不能使用。
形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传
送。
1.形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结
束返回
主调函数后则不能再使用该形参变量。
2.实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传
送给形
参。 因此应预先用赋值，输入等办法使实参获得确定值。
3.实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
4.函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，
形参的值
发生改变，而实参中的值不会变化。
5.当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一
份，在该
函数运行结束的时候形参被释放，而实参内容不会改变。
而如果函数的参数是指针类型变量,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使用的也是实参的地址，即使用的就
是实参
本身。所以在函数体内部可以改变实参的值。
47、构造方法能不能显式调用？
不能，构造方法当成普通方法调用，只有在创建对象的时候它才会被系统调用
48、什么是方法重载？
方法的重载就是在同一个类中允许同时存在一个以上的同名方法，只要它们的参数个数或者类型不同即可。在这种情况下，该方法就叫被重
载了，这个过程称为方法的重载（override）
49、构造方法能不能重写？能不能重载？
可以重载，但不能重写。
50、内部类与静态内部类的区别？
静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对
象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法；
普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。
如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访问属性或者调用方法。
如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内部类的对象作为一个属性，外同类可
以通过该属性调用普通内部类的方法或者访问普通内部类的属性
如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即可。
51、Static关键字有什么作用？
Static可以修饰内部类、方法、变量、代码块
Static修饰的类是静态内部类
Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在
static方法中不能使用this或者super关键字。
Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类
的时候，只为静态分配一次内存。
Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多
个，如果有多个，按照先后顺序依次执行。
52、final在java中的作用，有哪些用法?