identify coverage-increasing test cases by tracing the coverage
of all test cases. While such approaches decrease the number
of test cases required to create a coverage-increasing test case,
their rates of discarded test cases mean that coverage-guided
tracing represents a performance improvement.
B. System Scalability
System scalability represents an additional focus of re-
search on improving fuzzing. AFL’s execution monitoring
component avoids overhead from repetitive execve() calls
by instead using a fork-server execution model [50]. Xu et
al. [61] further improve AFL and libFuzzer’s performance
by developing several fuzzer-agnostic operating primitives.
Distributed fuzzing has also gained popularity; Google’s Clus-
terFuzz [72] (the backbone of OSS-Fuzz [3]) allocates more
resources to fuzzing by parallelizing across thousands of
virtual machines. As these efforts aim to improve performance
of all fuzzers, they serve as complements to other fuzzing
optimizations (e.g., coverage-guided tracing).
X. CONCLUSION
Coverage-guided tracing leverages the fact that coverage-
increasing test cases are the overwhelmingly uncommon case
in fuzzing by modifying target binaries so that they self-report
when a test case produces new coverage. While our results
show that the additional steps involved in coverage-guided
tracing (namely, running the modiﬁed binary,
tracing, and
unmodifying based on new coverage) are twice as expensive
as tracing alone, the ability to execute test cases at native
speed, combined with the low rate of coverage-increasing test
cases, yields overhead reductions of as much as 1300% and
70% for black- and white-box binaries, respectively. Applying
coverage-guided tracing in hybrid fuzzing achieves 616% and
79% more test case executions than black- and white-box
tracing-based hybrid fuzzing, respectively. Thus, given that
tracing consumes over 90% of the total time spent fuzzing—
even for fuzzers that focus on test case generation—reductions
in tracing time carry over to fuzzing as a whole;
From a higher level, our results highlight the potential
advantages of identifying and leveraging asymmetries inherent
to fuzzing. Fuzzing relies on executing many test cases in the
hopes of ﬁnding a small subset that are coverage-increasing
or crash-producing. Even given recent attempts to reduce the
number of discarded test cases, they are still the common
case. Another opportunity is that most of the code itself is
uninteresting, but must be executed to reach the interesting
code. Thus, we envision a future where faster than full-
speed execution is possible by ﬁnding ways to skip other
“uninteresting” but common aspects of fuzzing.
ACKNOWLEDGMENT
We would like to thank our reviewers for helping us
improve the paper. We also thank Xiaozhu Meng from the
Dyninst project and Insu Yun from the QSYM project for
graciously assisting us in utilizing their software in our im-
plementations. Lastly, we thank Michal Zalewski for providing
guidance on the inner workings of AFL. This material is based
upon work supported by the National Science Foundation
under Grant No. 1650540.
(cid:25)(cid:17)(cid:17)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:42:59 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1]
“CVE Details: The ultimate
Tech. Rep., 2018.
vulnerabilities-by-types.php
security vulnerability datasource,”
[Online]. Available: https://www.cvedetails.com/
[24]
[2] E.
P.
Bounimova,
“Billions
Testing
Available:
billions-and-billions-of-constraints-whitebox-fuzz-testing-in-production/
Molnar,
Fuzz
Production,”
[Online].
https://www.microsoft.com/en-us/research/publication/
Constraints: Whitebox
Godefroid,
of
and
in
Billions
Tech.
Rep.,
2012.
and
D.
[3] K. Serebryany, “OSS-Fuzz - Google’s continuous fuzzing service for
open source software,” in USENIX Security Symposium, ser. USENIX,
2017.
[4] R. Swiecki, “honggfuzz,” 2018. [Online]. Available: http://honggfuzz.
com/
[5] M. Zalewski, “American fuzzy lop,” 2017.
http://lcamtuf.coredump.cx/aﬂ/
[Online]. Available:
[6] K. Serebryany, “Continuous fuzzing with libfuzzer and addresssani-
tizer,” in IEEE Cybersecurity Development Conference, ser. SecDev,
2016, pp. 157–157.
[7] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida, and H. Bos,
“VUzzer: Application-aware Evolutionary Fuzzing,” in Network and
Distributed System Security Symposium, ser. NDSS, 2017.
[8] M. B¨ohme, V.-T. Pham, and A. Roychoudhury, “Coverage-based Grey-
box Fuzzing As Markov Chain,” in ACM SIGSAC Conference on
Computer and Communications Security, ser. CCS, 2016, pp. 1032–
1043.
[9] Y. Li, B. Chen, M. Chandramohan, S.-W. Lin, Y. Liu, and A. Tiu,
“Steelix: Program-state Based Binary Fuzzing,” in ACM Joint Meeting
on Foundations of Software Engineering, ser. ESEC/FSE, 2017, pp.
627–637.
talos vulndev, “AFL-Dyninst,” 2018.
//github.com/talos-vulndev/aﬂ-dyninst
[Online]. Available: https:
[10]
[11] S. Schumilo, C. Aschermann, R. Gawlik, S. Schinzel, and T. Holz,
“kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels,” in
USENIX Security Symposium, ser. USENIX, 2017, pp. 167–182.
[12] G. Zhang, X. Zhou, Y. Luo, X. Wu, and E. Min, “PTfuzz: Guided
Fuzzing with Processor Trace Feedback,” IEEE Access, vol. 6, pp.
37 302–37 313, 2018.
[13] M. Security, “Dharma: A generation-based, context-free grammar
fuzzer.” 2018. [Online]. Available: https://github.com/MozillaSecurity/
dharma
J. Johnson, “gramfuzz,” 2018. [Online]. Available: https://github.com/
d0c-s4vage/gramfuzz
[14]
[15] M. Eddington, “Peach fuzzing platform,” 2018. [Online]. Available:
https://www.peach.tech/products/peach-fuzzer/
[16] T. Wang, T. Wei, G. Gu, and W. Zou, “TaintScope: A Checksum-Aware
Directed Fuzzing Tool for Automatic Software Vulnerability Detection,”
in IEEE Symposium on Security and Privacy, ser. Oakland, 2010, pp.
497–512.
[17] M. Vuagnoux, “Autodafe, an Act of Software Torture,” 2006. [Online].
Available: http://autodafe.sourceforge.net/
[18] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting
Fuzzing Through Selective Symbolic Execution,” in Network and Dis-
tributed System Security Symposium, ser. NDSS, 2016, pp. 2–16.
I. Yun, S. Lee, M. Xu, Y. Jang, and T. Kim, “QSYM: A Practical
Concolic Execution Engine Tailored for Hybrid Fuzzing,” in USENIX
Security Symposium, ser. USENIX, 2018.
[19]
[20] C. Cadar, D. Dunbar, D. R. Engler, and others, “KLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems
Programs.” in USENIX Symposium on Operating Systems Design and
Implementation, ser. OSDI, 2008, pp. 209–224.
[21] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing
mayhem on binary code,” in IEEE Symposium on Security and Privacy,
ser. Oakland, 2012, pp. 380–394.
[22] V. Chipounov, V. Kuznetsov, and G. Candea, “S2e: A platform for
in-vivo multi-path analysis of software systems,” in ACM SIGPLAN
International Conference on Architectural Support for Programming
Languages and Operating Systems, ser. ASPLOS, 2011, pp. 265–278.
[23] P. Godefroid, M. Y. Levin, and D. Molnar, “SAGE: whitebox fuzzing
for security testing,” Queue, vol. 10, no. 1, p. 20, 2012.
J. Hertz and T. Newsham, “ProjectTriforce: AFL/QEMU fuzzing with
full-system emulation.” 2017. [Online]. Available: https://github.com/
nccgroup/TriforceAFL
“Dyninst API,” 2018. [Online]. Available: https://dyninst.org/dyninst
[25]
[26] S. Nagy and M. Hicks, “FoRTE-FuzzBench: FoRTE-Research’s
fuzzing benchmarks,” 2019. [Online]. Available: https://github.com/
FoRTE-Research/FoRTE-FuzzBench
[27] ——, “aﬂ-ﬁd: A suite of AFL modiﬁcations
for ﬁxed input
dataset experiments,” 2019. [Online]. Available: https://github.com/
FoRTE-Research/aﬂ-ﬁd
[28] ——, “UnTracer-AFL: An AFL implementation with UnTracer
[Online]. Available: https:
(our coverage-guided tracer),” 2019.
//github.com/FoRTE-Research/UnTracer-AFL
[29] P. Godefroid, A. Kiezun, and M. Y. Levin, “Grammar-based whitebox
fuzzing,” in ACM SIGPLAN Conference on Programming Language
Design and Implementation, ser. PLDI, 2008, pp. 206–215.
[30] M. Sutton, A. Greene, and P. Amini, Fuzzing: brute force vulnerability
discovery. Pearson Education, 2007.
[31] M. B¨ohme, V.-T. Pham, M.-D. Nguyen, and A. Roychoudhury, “Di-
rected Greybox Fuzzing,” in ACM SIGSAC Conference on Computer
and Communications Security, ser. CCS, 2017, pp. 2329–2344.
[32] V. Ganesh, T. Leek, and M. Rinard, “Taint-based directed whitebox
fuzzing,” in International Conference on Software Engineering, ser.
ICSE, 2009, pp. 474–484.
[33] P. Godefroid, M. Y. Levin, D. A. Molnar, and others, “Automated
whitebox fuzz testing.” in Network and Distributed System Security
Symposium, ser. NDSS, 2008, pp. 151–166.
[34] S. Gan, C. Zhang, X. Qin, X. Tu, K. Li, Z. Pei, and Z. Chen, “CollAFL:
Path Sensitive Fuzzing,” in IEEE Symposium on Security and Privacy,
ser. Oakland, 2018, pp. 660–677.
Intel, “Intel Processor Trace Tools,” 2017.
https://software.intel.com/en-us/node/721535
[Online]. Available:
[35]
[36] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: Building Cus-
tomized Program Analysis Tools with Dynamic Instrumentation,” in
ACM SIGPLAN Conference on Programming Language Design and
Implementation, ser. PLDI, 2005, pp. 190–200.
[37] A. Nikolic, “Guided Fuzzing And Binary Blobs,” Information Security
Symposium (Fsec), 2016. [Online]. Available: https://www.youtube.
com/watch?v=zQb-QT7tiFQ
J. L. Gustafson, “Reevaluating Amdahl’s law,” Communications of the
ACM, vol. 31, no. 5, pp. 532–533, 1988.
[38]
[39] P. Chen and H. Chen, “Angora: efﬁcient fuzzing by principled search,”
in IEEE Symposium on Security and Privacy, ser. Oakland, 2018.
[40] Shellphish, “ShellPhuzz,” 2018. [Online]. Available: https://github.com/
[41]
shellphish/fuzzer
“DARPA Cyber Grand Challenge,” 2018.
https://github.com/cybergrandchallenge
[Online]. Available:
[42] Y. Shoshitaishvili, “CGC Binaries: Compiled CGC binaries
for
experimentation porpoises.” 2017. [Online]. Available: https://github.
com/zardus/cgc-bins
J. Kinder, F. Zuleger, and H. Veith, “An abstract interpretation-based
framework for control ﬂow reconstruction from binaries,” in Inter-
national Workshop on Veriﬁcation, Model Checking, and Abstract
Interpretation, ser. VMCAI, 2009, pp. 214–228.
[43]
[44] H. Theiling, “Extracting safe and precise control ﬂow from binaries,” in
IEEE International Conference on Real-Time Systems and Applications,
ser. RCTSA, 2000, pp. 23–30.
[45] D. K¨astner and S. Wilhelm, “Generic control ﬂow reconstruction from
assembly code,” in ACM SIGPLAN/SIGBED International Conference
on Languages, Compilers, Tools and Theory for Embedded Systems,
ser. LCTES, 2002, pp. 46–55.
[46] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna,
“SoK: (State of) The Art of War: Offensive Techniques in Binary
Analysis,” in IEEE Symposium on Security and Privacy, ser. Oakland,
2016.
(cid:25)(cid:17)(cid:18)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:42:59 UTC from IEEE Xplore.  Restrictions apply. 
[47] H. Peng, Y. Shoshitaishvili, and M. Payer, “T-Fuzz: fuzzing by program
transformation,” in IEEE Symposium on Security and Privacy, ser.
Oakland, 2018.
[48] C. Lemieux, R. Padhye, K. Sen, and D. Song, “PerfFuzz: Automati-
cally Generating Pathological Inputs,” in ACM SIGSOFT International
Symposium on Software Testing and Analysis, ser. ISSTA, 2018, p. 12.
J. Wang, B. Chen, L. Wei, and Y. Liu, “Skyﬁre: Data-Driven Seed
Generation for Fuzzing,” in IEEE Symposium on Security and Privacy,
ser. Oakland, 2017.
[49]
[50] M. Zalewski,
“Fuzzing
2014.
fuzzing-binaries-without-execve.html
[Online]. Available:
random programs without
execve(),”
http://lcamtuf.blogspot.com/2014/10/
[70]
ity addition,” in IEEE Symposium on Security and Privacy, ser. Oakland,
2016, pp. 110–121.
“laf-intel: Circumventing Fuzzing Roadblocks with Compiler Trans-
formations,” 2016. [Online]. Available: https://laﬁntel.wordpress.com/
[71] U. Karg´en and N. Shahmehri, “Turning Programs Against Each Other:
High Coverage Fuzz-testing Using Binary-code Mutation and Dynamic
Slicing,” in ACM Joint Meeting on Foundations of Software Engineer-
ing, ser. ESEC/FSE, 2015, pp. 782–792.
[72] Google, “ClusterFuzz,” 2018. [Online]. Available: https://github.com/
google/oss-fuzz/blob/master/docs/clusterfuzz.md
[51] R. Stallman, R. Pesch, S. Shebs, and others, “Debugging with GDB,”
Free Software Foundation, vol. 675, 1988.
[52] A. Brown and G. Wilson, “The Architecture of Open Source Applica-
tions: Elegance, Evolution, and a Few Fearless Hacks,” vol. 1, 2012.
J. Keniston, P. S. Panchamukhi, and M. Hiramatsu, “Kernel probes
(kprobes),” Documentation provided with the Linux kernel sources (v2.
6.29), 2016.
[53]
[54] M. Hiramatsu and S. Oshima, “Djprobe–Kernel probing with the
smallest overhead,” in Linux Symposium, ser. Linux Symposium, 2007,
p. 189.
[55] S. Arnautov, B. Trach, F. Gregor, T. Knauth, A. Martin, C. Priebe,
J. Lind, D. Muthukumaran, D. O’keeffe, M. Stillwell, and others,
“SCONE: Secure Linux Containers with Intel SGX.” in USENIX
Symposium on Operating Systems Design and Implementation, ser.
OSDI, 2016, pp. 689–703.
[56] M. Rash,
“aﬂ-cve: A collection of vulnerabilities discovered
[Online]. Available: https:
(aﬂ-fuzz),” 2017.
by the AFL fuzzer
//github.com/mrash/aﬂ-cve
[57] Google, “fuzzer-test-suite: Set of tests for fuzzing engines,” 2018.
[Online]. Available: https://github.com/google/fuzzer-test-suite
[58] M. Zalewski, “aﬂ-users > Re: ”FidgetyAFL” implemented in 2.31b,”
2016. [Online]. Available: goo.gl/zmcvZf
[59] G. Klees, A. Ruef, B. Cooper, S. Wei, and M. Hicks, “Evaluating Fuzz
Testing,” in ACM SIGSAC Conference on Computer and Communica-
tions Security, ser. CCS, 2018.
[60] A. Vargha and H. D. Delaney, “A Critique and Improvement of the
CL Common Language Effect Size Statistics of McGraw and Wong,”
Journal of Educational and Behavioral Statistics, vol. 25, no. 2, pp.
101–132, 2000.
[61] W. Xu, S. Kashyap, C. Min, and T. Kim, “Designing New Operating
Primitives to Improve Fuzzing Performance,” in ACM SIGSAC Confer-
ence on Computer and Communications Security, ser. CCS, 2017.
[62] S. S. Muchnick, Advanced compiler design implementation. Morgan
Kaufmann, 1997.
“SanitizerCoverage: Clang 7 documentation,” 2018. [Online]. Available:
https://clang.llvm.org/docs/SanitizerCoverage.html
[63]
[64] W. H. Hawkins, J. D. Hiser, M. Co, A. Nguyen-Tuong, and J. W. David-
son, “Zipr: Efﬁcient Static Binary Rewriting for Security,” in IEEE/IFIP
International Conference on Dependable Systems and Networks, ser.
DSN, 2017.
[65] R. Wang, Y. Shoshitaishvili, A. Bianchi, A. Machiry, J. Grosen,
P. Grosen, C. Kruegel, and G. Vigna, “Ramblr: Making Reassembly
Great Again,” in Network and Distributed System Security Symposium,
ser. NDSS, 2017, pp. 2–15.
[66] S. Wang, P. Wang, and D. Wu, “Reassembleable Disassembling,”
ser. USENIX Sec, 2015, pp.
https://www.usenix.org/conference/
in USENIX Security Symposium,
627–642.
usenixsecurity15/technical-sessions/presentation/wang-shuai
[Online]. Available:
[67] A. R. Bernat and B. P. Miller, “Anywhere, Any-time Binary Instrumen-
tation,” in ACM SIGPLAN-SIGSOFT Workshop on Program Analysis
for Software Tools, ser. PASTE, 2011, pp. 9–16.
J. Lopez, L. Babun, H. Aksu, and A. S. Uluagac, “A Survey on
Function and System Call Hooking Approaches,” Journal of Hardware
and Systems Security, vol. 1, no. 2, pp. 114–136, 2017.
[68]
[69] B. Dolan-Gavitt, P. Hulin, E. Kirda, T. Leek, A. Mambretti, W. Robert-
son, F. Ulrich, and R. Whelan, “Lava: Large-scale automated vulnerabil-
(cid:25)(cid:17)(cid:19)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:42:59 UTC from IEEE Xplore.  Restrictions apply.