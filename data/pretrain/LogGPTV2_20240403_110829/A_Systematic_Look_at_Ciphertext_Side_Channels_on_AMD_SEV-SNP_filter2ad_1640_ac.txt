Levels (VMPLs) that provide additional hardware isolated
abstraction layers. However, the hypervisor can still sense a
ﬁnished context switch due to the interaction triggered by the
hypercall from VMPL0.
Locating pt_regs after VMEXIT. Besides using the
VMGEXIT to detect a context switch, the attacker can also
use it to locate the pt_regs struct. For that, after reaching a
VMGEXIT, the attacker clears the P bit for all guest pages
and resumes the VM. This will hand back control to the
#VC handler in the VM, which will subsequently try to copy
the results of the emulated instruction from the GHCB to
pt_regs. Since all guest pages were marked as not present,
this causes a nested page fault. In our experiments, the second
NPF caused by data page read access after resuming the VM is
the memory page containing pt_regs. We did not encounter
any false positives during our experiments.
B. Attacking Constant-time ECDSA
In this section, we demonstrate how to use the context
switch primitive from the previous section to attack the
constant-time ECDSA implementation in OpenSSL. More
precisely, we show that the adversary can infer the nonce
k in the constant-time ECDSA algorithm by inspecting the
ciphertext changes in the pt_regs structure of the targeted
process. This can then be used to recover the secret key.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:55:46 UTC from IEEE Xplore.  Restrictions apply. 
5341
VMHypervisorRDMSRVMGEXITwithparametersinGHCBUpdateGHCBResumeVChandlerContinueexecutionVChandlerReadGHCBUpdatept_regsEmulateinstructionVMPL3VMPL0HypervisorRDMSRAssigntoVMPL0HypercallwithparametersResponserequestEmulateinstructionUpdateVMPL3savestateResumeVMPL3Continueexecution1 int i, cardinality_bits, group_top, kbit, pbit,
Z_is_one;
kbit = BN_is_bit_set(k, i) ˆ pbit;
EC_POINT_CSWAP(kbit,r,s,group_top,Z_is_one);
2 ...
3 for (i = cardinality_bits - 1; i >= 0; i--) {
4
5 // kbit is used to determine the conditional swap
6
7 // single step of the Montgomery ladder
8
9
10
11
12
13 // pbit helps to merge CSWAP with that of the next
ERR_raise(ERR_LIB_EC,
EC_R_LADDER_STEP_FAILURE);
goto err;
if (!ec_point_ladder_step(group, r, s, p, ctx)){
}
iteration
pbit ˆ= kbit;
14
15 }
Listing 1: Part of the elliptic curve scalar multiplication
ec_scalar_mul_ladder() from OpenSSL. The function
uses the Montgomery ladder algorithm and constant-time
primitives to protect the secret scalar k against side channels.
The Elliptic Curve Digital Signature Algorithm (ECDSA)
is a widely used signature algorithm that works as follows:
1) Prepare the curve parameters (CURVE, G, n), where G
is the elliptic curve base point of prime order n.
2) Prepare a key pair by choosing uniform dA ∈ Z∗
n. dA is
3) Generate a cryptographically secure random integer k ∈
the private key. The public key is QA = dAG.
Z∗
n (also known as the nonce k).
x-coordinate of the resulting point is used).
4) Calculate a non-zero r by r = (kG)x mod n (only the
5) Calculate s = k−1(h(m)+rdA) mod n, where m is the
message and h(m) is a hash of m. (r, s) then forms the
ECDSA signature pair.
A predictable or leaked nonce k allows to immediately
recover the private key dA by:
dA = r−1((ks) − h(m)) mod n.
Targeted ECDSA implementation. Our attack targets the
ECDSA implementation of the OpenSSL library1 for the curve
secp384r1 that is commonly used for TLS/SSL connec-
tions. The goal of our attack is to steal the nonce k and
thus infer the private key dA. In OpenSSL, ECDSA signing
is handled by the ECDSA_do_sign function, which in turn
calls ec_scalar_mul_ladder to calculate r. Note that
the implementation of the function is speciﬁcally designed to
protect k against side channel attacks (Listing 1).
Identify instruction pages. Besides monitoring context
switches and locating pt_regs via the methods shown in
the previous part, we also need to identify the appropriate
code locations in order to intercept the guest VM at proper
execution points, which gives the attacker the opportunity
to extract valuable ciphertext. In our work, we combine the
widely-used page fault controlled side channel [25], [30], [34],
[35] with performance counters to build a ﬁne-grained tool
1Commit: c4b2c53fadb158bee34aef90d5a7d500aead1f70.
to identify instruction pages’ physical addresses. Speciﬁcally,
we make use of the Retired Instructions counter [2, Event
PMCx0C0], which can be conﬁgured to only count the amount
of retired instructions inside the VM and thus reveal
the
number of instructions executed between two pages faults. The
attacker can simply build a template of the retired instruction
counts for code paths in a known binary. In our experiments,
we were able to locate the target pages on the ﬂy, without
relying on repeated access patterns.
C. End-to-end attack against Nginx
We now show the steps needed to steal
the nonce k
generated by an Nginx webserver. The nonce, together with
the corresponding signature, allows the attacker to recover the
secret key of the server.
 Send HTTPS request. The attacker sends a HTTPS request
to the Nginx server in order to trigger the targeted code paths.
 Locate target function in physical memory. Right after
sending the HTTPS request, the attacker clears the P bit of
all VM pages. The attacker then locates the guest physical
addresses of the functions ec_scalar_mul_ladder()
(gPA0) and BN_is_bit_set (gPA1) using the page fault
channel combined with the retired instruction counter.
 Locate pt_regs. The attacker pauses the VM for a while
(e.g., by trapping the VM in the NPF handler for a few
milliseconds) when they intercept a NPF of gPA0. They then
use the method from Section IV-A to ﬁnd the physical address
gPA3 of the current thread’s pt_regs structure.
 Single-step loop iterations. The attacker
iteratively
clears the P bit of gPA1 to pause the VM when it en-
ters BN_is_bit_set. After intercepting the correspond-
ing NPF for gPA1,
for
gPA0, causing an NPF when the ret instruction inside
BN_is_bit_set is executed, i.e. the function tries to return
to ec_scalar_mul_ladder(). The attacker then pauses
the VM in the gPA0 NPF for a while (several milliseconds)
and resumes the VM without handling the NPF. The attacker
might observe several consecutive NPFs for gPA0, but keeps
the P bit cleared until a VMGEXIT is encountered.
 Record the ciphertext and recover the nonce k. The
attacker records the ciphertext of the RAX ﬁeld in pt_regs
after
the VMGEXIT, which contains the return value of
BN_is_bit_set at this execution point. The conjunct reg-
ister stored near RAX in pt_regs is R8, which remains
unchanged during the for loop. The attacker then sets the
P bit of gPA0, clear the P bit of gPA1 in order to intercept
BN_is_bit_set for the next iteration and repeat step .
After 384 iterations, the attacker has collected a sequence of
ciphertexts. Since RAX can only take two distinct values, they
can recover the nonce k with only 1 bit of entropy.
the attacker clears the P bit
D. Evaluation
All experiments throughout
this paper were conducted
on an AMD EPYC 7763 64-Core Processor. The host
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:55:46 UTC from IEEE Xplore.  Restrictions apply. 
6342
kernel (branch sev-snp-part2-rfc4), QEMU (branch
sev-snp-devel), and OVMF (branch sev-snp-rfc-5)
were directly forked from AMD SEV’s GitHub repository [5].
The victim VMs were protected by SEV-SNP and used
the unmodiﬁed guest kernel provided by AMD (branch
sev-snp-part2-rfc4). The victim VMs were conﬁgured
with 2GB DRAM, 30GB disk, and one virtual CPU (vCPU).
However, the capacity of the victim VMs (including vCPU,
DRAM, and disk) is not relevant for the attack procedure.
For the attack on Nginx, an unmodiﬁed Nginx server
and an OpenSSL library were installed inside the victim
VMs. The Nginx version is 1.21.3, which was released
on 07 Sep. 2021. The Nginx server
supports HTTPS
requests with a self-signed ECC certiﬁcate with 384-
bit key. The curve used is secp384r1. The OpenSSL
was forked from OpenSSL’s Github repository (Commit:
c4b2c53fadb158bee34aef90d5a7d500aead1f70)
and was modiﬁed to log the ground truth after the signing
procedure, so we could verify the extracted secret.
Proof of concept code is available at https://github.com/
UzL-ITS/sev-ciphertext-side-channels/.
Identifying target functions. To estimate the attacker’s ability
to locate target functions on the ﬂy, we sent 500 consecutive
HTTPS requests. For each request, we monitored the page
access pattern along with the number of retired instructions
and tried to locate the target functions in real-time. The refer-
ence page access pattern and the corresponding performance
counter values were collected in a different VM with the
same Nginx and OpenSSL version, but without SEV-SNP’s
protection and with a different kernel version, to show the
pattern’s independence of the exact kernel version.
In 496 out of those 500 requests,
the target function’s
physical addresses were successfully located, while a miss was
reported for the remaining four requests. The average time
needed to locate the target functions was 59.28 milliseconds
with a standard deviation of 2.12 milliseconds. No false
positive was reported.
Context-switch latency. To collect the ciphertext of the up-
dated pt_regs, the attacker needs to wait until an internal
context switch, which is the most time-consuming part of
the end-to-end attack. In our implementation,
the attacker
pauses the VM by calling udelay(), which
takes a delay in microseconds. We evaluated both the proper
interval for a direct context switch and the average waiting
time. Since the attacker doesn’t set the P bit at the execution
point unless observing the VMGEXIT, the attacker might get
several repeated NPFs in a row. Figure 3a shows the number
of NPFs we observed under different intervals. We usually
directly detected a context switch when interval was larger
than 2000 (two milliseconds). Figure 3b shows the average
waiting time. It usually took four milliseconds until an internal
context switch occurred, thus we paused the victim VM by
using udelay(4000) in our attack.
Performance. We repeated the attack 50 times and measured
the overall time for an end-to-end attack. The average time
(a) #NPFs for udelay intervals. (b) Avg. time for context switch.
Figure 3: Relationship between udelay interval and internal
context switch.
was 8.53 seconds with a standard deviation of 0.33 seconds.
The main latency is caused by waiting for an interval context
switch. For a 384-bit nonce k, the attacker can intercept 384
* 5 = 1920 NPFs for gPA0 in total. In our setting, we chose
to wait for a context switch every time when intercepting
an NPF of gPA0. However, for each iteration, only one
out of ﬁve NPFs is caused by the ret instruction inside
BN_is_bit_set. Thus, the attacker could also choose to
only wait and grab ciphertext at that NPF. By doing that,
approximately 6 seconds (384 * 4 * 4ms) waiting time can be
avoided. However, one side effect is that some internal events
(e.g., an unexpected context switch) might cause a repeated
NPF of gPA0, which will confuse the attacker and reduce the
accuracy. In our implementation, the average accuracy for the
recovered nonce k is 89.1%.
V. EXPLOITING MEMORY ACCESSES IN USER SPACE
In the previous section, we have seen how an attacker can
exploit the context switch mechanism of the Linux OS inside
the VM to leak register values of running processes. We now
turn our attention to leakages directly caused by the victim
application’s memory access behavior. We demonstrate that
the OpenSSL ECDSA code from the previous section is also
vulnerable to the dictionary attack targeting stack variables,
and show an example of the collision attack against the EdDSA
implementation in OpenSSH.
A. Breaking Constant-time ECDSA via Dictionary Attack
As shown in Listing 1, ec_scalar_mul_ladder uses
several local integer variables: kbit controls the conditional
swaps by EC_POINT_CSWAP in the for loop. Assuming that
ki refers to the i-th bit of k, at the beginning of a loop iteration,
pbit stores ki−1. After calling BN_is_bit_set(k, i)
to retrieve ki, kbit stores ki−1 ⊕ ki−2 (XOR). pbit is later
updated to ki at the end of the iteration.
Stack layout. We target the 16-byte memory block where
pbit is stored. By our observation, the memory block con-
taining pbit also contains additional variables, which is not
surprising given the small size of pbit. In our case, pbit,
kbit and cardinality_bits all share the same 16-byte
memory block. The cardinality_bits variable does not
change during the runtime of the for loop from Listing 1.
Thus, the value range of the ciphertext is only dependent on
the secret, i.e. pbit and kbit.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:55:46 UTC from IEEE Xplore.  Restrictions apply. 
7343
020004000Interval(udelay)0204060NPFs500100020004000Interval(udelay)468Time(ms)Table I: Possible pbit and kbit pairs when intercepting
BN_is_bit_set() in ec_scalar_mul_ladder(). The let-
ters A to D represent the 16-byte ciphertexts the attacker may observe,
which depend on the values of kbit and pbit. The value of kbit
and pbit in the i + 1-th iteration is updated depending on ki.
i-th iteration
kbit
i + 1-th iteration
pbit
kbit
pbit
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
Pair
A
A
B
B
C
C
D
D
ki
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
1
0
1