7 Related Work
A lot of prior work is related to PCFS; here we describe only the most closely related
work.
Relation to PCA. Proof-carrying authorization (PCA), the general architecture on
which PCFS builds, has been implemented in several other systems [8, 9, 25]. However,
PCFS diﬀers from these systems in several ways. The most signiﬁcant diﬀerence is
that in all existing PCA-based systems, the proof that the user constructs is given
directly to the system interface at the time of access. As a result, the proof veriﬁer must
be called every time an access is requested. This design works well only when the time
taken to check certiﬁcates and the proof (typically several milliseconds) is not signiﬁcant
in comparison to the time taken to perform the actual operation. This has been the
case in all implementations of PCA to date. In contrast, a ﬁle system access is a fast
operation that takes of the order of a few micro or milli seconds only, and checking
several certiﬁcates and a proof at each access results in visible delays for the user. We
actually conﬁrmed this hypothesis through an earlier implementation of PCFS that used
the PCA architecture directly. As a result of this prior experience, in the present design
of PCFS, proofs are veriﬁed in advance of performing operations, and capabilities issued
in return are used to authorize access.
Second, the logic used in in PCFS (discussed in Section 3) contains explicit time.
This allows accurate representation of expiration dates of policy rules in logical formulas
21
and also in proofs. In contrast, logics used so far in PCA systems are unaware of time,
and rule expiration is enforced using an extra-logical mechanism. Having time in the
logic also allows more expressive rules, e.g., those that use arithmetic over time.
Third, in all existing implementations using PCA, the user is authenticated to the
system interface using a challenge response protocol with a fresh nonce. This nonce must
be embedded in the proof used to authorize access because the interface does not learn
the identity of the user. This implies that the proof cannot be completed in advance
of the access (although some parts of it that are independent of the nonce can be).
Owing to concerns regarding eﬃciency, we do not consider this style of authentication
a good design principle for PCA. Instead, we believe that the authentication protocol
used should tell the system interface the identity of the user. In distributed settings a
password or public key can be used for authentication, and in centralized settings like
PCFS the system interface can learn the user id of the calling process through a system
call like getuid(). This form of authentication allows proofs of access to be created
and checked in advance of access, which is central to obtaining eﬃciency in PCFS.
Other related work. Many prior ﬁle systems have used capabilities to authorize
access (e.g., [6, 20, 28, 31, 32]), although the use of proofs to generate capabilities is
novel to our work. Prior work by Chaudhuri considers a formal analysis of correctness
of an implementation of authorization through cryptographic capabilities in the face of
dynamic policies [13]. That paper also considers many strategies for enforcing time-
dependent and state-dependent policies, but the mechanism used to generate policies is
treated abstractly (in contrast, in Theorem 4.1, we prove our enforcement correct with
respect to a concrete logic and proof system).
Many logics and logic-based languages have been proposed in the past for represent-
ing access control policies (e.g., [4, 5, 10, 14, 18, 21, 30]). The k says s modality in BL
is most closely related to a similar modality in Binder [14]. Our treatment of explicit
time draws on work by DeYoung et al. [16]. We believe that the combination of time
and interpreted predicates is novel to BL. The implementation of the proof search tool
for BL builds upon work on uniform proofs for logic programming [27], and draws on
ideas from the language Lolli [22].
8 Conclusion
PCFS combines strong logical foundations for access policies with an eﬃcient enforce-
ment based on proofs and cryptographic capabilities. Owing to a very expressive logic
for policies, and conditions in capabilities, PCFS automatically enforces time-dependent
policy rules, as well as policies that depend on ﬁle system state. A signiﬁcant contribu-
tion of our work is Theorem 4.1 which shows that enforcement of policies using procaps
is sound with respect to enforcement with proofs directly (as in PCA).
A number of interesting avenues remain for future work that we discuss here brieﬂy.
One interesting direction is to apply the PCFS architecture to build a networked ﬁle
system, with the proof veriﬁer and storage on separate nodes, and a decentralized store
for procaps. Procaps already support decentralization, since their integrity is protected
by the signature contained in them. Another interesting line of work may be to use
capabilities to implement access control on devices that have little computational power
22
(e.g., embedded devices), and support them with the existing front end from PCFS that
runs on a separate machine. A third subject of interest is to consider more case studies
of policies used in practice to see if they can be expressed and enforced in PCFS.
References
[1] Bonnie++. Available from http://www.coker.com.au/bonnie++/.
[2] FUSE: Filesystem in Userspace. Available from http://fuse.sourceforge.net/.
[3] SecPAL research release for .NET, 2007. Online at http://research.microsoft.com/
en-us/projects/secpal/.
[4] Mart´ın Abadi. Access control in a core calculus of dependency. Electronic Notes in Theoret-
ical Computer Science, 172:5–31, April 2007. Computation, Meaning, and Logic: Articles
dedicated to Gordon Plotkin.
[5] Mart´ın Abadi, Michael Burrows, Butler Lampson, and Gordon Plotkin. A calculus for
access control in distributed systems. ACM Transactions on Programming Languages and
Systems, 15(4):706–734, 1993.
[6] Marcos K. Aguilera, Minwen Ji, Mark Lillibridge, John MacCormick, Erwin Oertli, Dave
Andersen, Mike Burrows, Timothy Mann, and Chandramohan A. Thekkath. Block-level
security for network-attached disks.
In Proceedings of the 2nd Conference on File and
Storage Technologies (FAST), pages 159–174, 2003.
[7] Andrew W. Appel and Edward W. Felten. Proof-carrying authentication. In G. Tsudik,
editor, Proceedings of the 6th ACM Conference on Computer and Communications Security,
pages 52–62, Singapore, November 1999. ACM Press.
[8] Lujo Bauer. Access Control for the Web via Proof-Carrying Authorization. PhD thesis,
Princeton University, November 2003.
[9] Lujo Bauer, Scott Garriss, Jonathan M. McCune, Michael K. Reiter, Jason Rouse, and
Peter Rutenbar. Device-enabled authorization in the Grey system. In Proceedings of the
8th International Conference on Information Security (ISC’05), pages 431–445. Springer
LNCS 3650, September 2005.
[10] Moritz Y. Becker, C´edric Fournet, and Andrew D. Gordon. Design and semantics of a
decentralized authorization language. In Proceedings of the 20th IEEE Computer Security
Foundations Symposium (CSF-20), pages 3–15, 2007.
[11] Moritz Y. Becker and Peter Sewell. Cassandra: Flexible trust management applied to
In Proceedings of 17th IEEE Computer Security Foundations Workshop
health records.
(CSFW-17), pages 139–154, 2004.
[12] Bor-Yuh Evan Chang, Kaustuv Chaudhuri, and Frank Pfenning. A judgmental analysis of
linear logic. Technical Report CMU-CS-03-131R, Carnegie Mellon University, 2003.
[13] Avik Chaudhuri. On secure distributed implementations of dynamic access control. In Pro-
ceedings of the Joint Workshop on Foundations of Computer Security, Automated Reasoning
for Security Protocol Analysis, and Issues in the Theory of Security (FCS-ARSPA-WITS),
pages 93–107, 2008.
23
[14] John DeTreville. Binder, a logic-based security language. In M. Abadi and S. Bellovin,
editors, Proceedings of the Symposium on Security and Privacy (S&P’02), pages 105–113,
Berkeley, California, May 2002. IEEE Computer Society Press.
[15] Henry DeYoung. A logic for reasoning about time-dependent access control policies. Tech-
nical Report CMU-CS-08-131, Computer Science Department, Carnegie Mellon University,
December 2008.
[16] Henry DeYoung, Deepak Garg, and Frank Pfenning. An authorization logic with explicit
time. In Proceedings of the 21st IEEE Computer Security Foundations Symposium (CSF-
21), Pittsburgh, Pennsylvania, June 2008. Extended version available as Technical Report
CMU-CS-07-166.
[17] Deepak Garg. Proof search in an authorization logic. Technical Report CMU-CS-09-121,
Carnegie Mellon University, June 2009.
[18] Deepak Garg and Frank Pfenning. Non-interference in constructive authorization logic. In
J. Guttman, editor, Proceedings of the 19th IEEE Computer Security Foundations Workshop
(CSFW-19), pages 283–293, Venice, Italy, July 2006.
[19] Gerhard Gentzen. Untersuchungen ¨uber das logische Schließen. Mathematische Zeitschrift,
39:176–210, 405–431, 1935. English translation in M. E. Szabo, editor, The Collected Papers
of Gerhard Gentzen, pages 68–131, North-Holland, 1969.
[20] H. Gobioﬀ, G. Gibson, and D. Tygar. Security for network attached storage devices. Tech-
nical Report CMU-CS-97-185, Carnegie Mellon University, 1997.
[21] Yuri Gurevich and Itay Neeman. DKAL: Distributed-knowledge authorization language.
In Proceedings of the 21st IEEE Symposium on Computer Security Foundations (CSF-21),
pages 149–162, June 2008.
[22] Joshua S. Hodas and Dale Miller. Logic programming in a fragment of intuitionistic linear
logic. Information and Computation, 110(2):327–365, 1994.
[23] R. Housley, W. Ford, W. Polk, and D. Solo. Internet X.509 public key infrastructure. See
http://www.ietf.org/rfc/rfc2459.txt, 1999.
[24] Butler Lampson, Mart´ın Abadi, Michael Burrows, and Edward Wobber. Authentication
in distributed systems: Theory and practice. ACM Transactions on Computer Systems,
10(4):265–310, November 1992.
[25] Chris Lesniewski-Laas, Bryan Ford, Jacob Strauss, Robert Morris, and M. Frans Kaashoek.
Alpaca: Extensible authorization for distributed services. In Proceedings of the 14th ACM
Conference on Computer and Communications Security (CCS’07), Alexandria, VA, October
2007.
[26] Ninghui Li and John C. Mitchell. Datalog with constraints: A foundation for trust manage-
ment languages. In Proceedings of the 5th International Symposium on Practical Aspects of
Declarative Languages (PADL’03), pages 58–73. Springer LNCS 2562, 2003.
[27] Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. Uniform proofs as a
foundation for logic programming. Annals of Pure and Applied Logic, 51:125–157, 1991.
[28] Christopher Olson and Ethan L. Miller. Secure capabilities for a petabyte-scale object-
based distributed ﬁle system. In Proceedings of the ACM Workshop on Storage Security
and Survivability (StorageSS’05), pages 64–73, 2005.
24
[29] Frank Pfenning and Rowan Davies. A judgmental reconstruction of modal logic. Mathe-
matical Structures in Computer Science, 11:511–540, 2001.
[30] Andrew Pimlott and Oleg Kiselyov. Soutei, a logic-based trust-management system. In
Proceedings of the Eighth International Symposium on Functional and Logic Programming
(FLOPS’06), pages 130–145, 2006.
[31] Benjamin C. Reed, Edward G. Chron, Randal C. Burns, and Darrell D. E. Long. Authen-
ticating network-attached storage. IEEE Micro, 20(1):49–57, 2000.
[32] Jude T. Regan and Christian D. Jensen. Capability ﬁle names: Separating authorisation
In Proceedings of the 10th USENIX
from user management in an internet ﬁle system.
Security Symposium (SSYM’01), August 2001.
A Description of the Logic BL
This appendix describes the proof system of the logic BL, and its meta theory. The
syntax of the logic was presented in Section 3. Proof terms M are summarized below:
M ::= x | pf conjI M1 M2 | pf conjE1 M | pf conjE2 M | pf disjI1 M |
pf disjI2 M | pf disjE M ([x]M1) ([y]M2) | pf topI | pf botE M |
pf impI ([x][v1][v2]M) | pf impE M1 M2 u1 u2 | pf forallI ([v]M) |
pf forallE t M | pf existsI t M | pf existsE M1 ([x][v]M2) |
pf atI M | pf atE M1 ([x]M2) | pf saysI M | pf saysE M1 ([x]M2) |
pf sinjI | pf sinjE M1 M2 | pf cinjI | pf cinjE M1 M2
Variables x, v in square brackets [x], [v] are binding occurrences. Bound variables may
be α-renamed implicitly.
1 ≤ u1 and u2 ≤ u(cid:48)
Figures 4 and 5 list the rules of the natural deduction system for BL. All rules in
Figure 4 are similar to corresponding rules in prior work by DeYoung [15, Chapter 5],
done in the context of η-logic [16]. There are only two minor diﬀerences: (a) Our rules
contain the view α and the state E both of which remain unchanged in all rules of
Figure 4, and (b) BL contains the connective ⊥ (rule ⊥E), which η-logic does not. For
descriptions of the rules in Figure 4, we refer the reader to the prior work by DeYoung.
Rules in Figure 5 are peculiar to BL. Rule (hyp) states that the assumption s ◦
2] entails s ◦ [u1, u2] if u(cid:48)
1, u(cid:48)
[u(cid:48)
2, i.e., the interval [u1, u2] is a subset
of the interval [u(cid:48)
2]. This makes intuitive sense: if a formula s holds throughout an
interval, it must hold on every subinterval as well. The proof term corresponding to
this (trivial) derivation is x, where x is also the name for the assumption s ◦ [u(cid:48)
1, u(cid:48)
2].
The rule (claims) is similar, except that it allows us to conclude s ◦ [u1, u2] from the
assumption k(cid:48) claims s ◦ [u(cid:48)
In this case, it must also be shown, among other
things, that k(cid:48) is stronger than the principal k in the view (premise Ψ |= k(cid:48) (cid:23) k).
(saysI) is the only rule which changes the view. The notation Γ| in this rule denotes
the subset of Γ that contains exactly the claims of principals, i.e., the set {(k(cid:48) claims
s(cid:48) ◦ [u(cid:48)
2]) ∈ Γ}. The rule means that (k says s) ◦ [u1, u2] holds in any view α if
s ◦ [u1, u2] holds in the view k, u1, u2 using only claims of principals. Assumptions of
the form s(cid:48) ◦ [u(cid:48)
2] are eliminated from Γ in the premise because they may have been
added in the view α, but may not hold in the view k, u1, u2. Its dual rule (saysE) states
1, u(cid:48)
2].
1, u(cid:48)
1, u(cid:48)
1, u(cid:48)
25
M1 :: Σ; Ψ; E; Γ
α−→ s1 ◦ [u1, u2]
(pf conjI M1 M2) :: Σ; Ψ; E; Γ
M2 :: Σ; Ψ; E; Γ
α−→ s1 ∧ s2 ◦ [u1, u2]
α−→ s2 ◦ [u1, u2]
∧I
M :: Σ; Ψ; E; Γ
α−→ s1 ∧ s2 ◦ [u1, u2]
(pf conjE1 M ) :: Σ; Ψ; E; Γ
α−→ s1 ◦ [u1, u2]
M :: Σ; Ψ; E; Γ
α−→ s1 ◦ [u1, u2]
(pf disjI1 M ) :: Σ; Ψ; E; Γ
α−→ s1 ∨ s2 ◦ [u1, u2]
∧E1
∨I1
M :: Σ; Ψ; E; Γ
α−→ s1 ∧ s2 ◦ [u1, u2]
α−→ s2 ◦ [u1, u2]
∧E2
(pf conjE2 M ) :: Σ; Ψ; E; Γ
M :: Σ; Ψ; E; Γ
α−→ s2 ◦ [u1, u2]
(pf disjI2 M ) :: Σ; Ψ; E; Γ
α−→ s1 ∨ s2 ◦ [u1, u2]
∨I2
M1 :: Σ; Ψ; E; Γ, x : s1 ◦ [u1, u2]
α−→ s1 ∨ s2 ◦ [u1, u2]
M :: Σ; Ψ; E; Γ
1, u(cid:48)
α−→ s(cid:48) ◦ [u(cid:48)
2]
M2 :: Σ; Ψ; E; Γ, y : s2 ◦ [u1, u2]
(pf disjE M ([x]M1) ([y]M2)) :: Σ; Ψ; E; Γ
α−→ s(cid:48) ◦ [u(cid:48)
1, u(cid:48)
2]
α−→ s(cid:48) ◦ [u(cid:48)
1, u(cid:48)
2]
∨E
α−→ (cid:62) ◦ [u1, u2]
(cid:62)I