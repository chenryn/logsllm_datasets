元素，它们对应于括号捕获的元素。也就是说，Sp1it没有返回的部分或全部的文本，会
包含在返回的list中。
例如，在处理HTML时，对下面的文本调用split（/(]*>)/)：
."'and·very'very'much'effort
返回：
（'...'and·'，''，'very`，'',
‘very'，''，'*much'，''，'*effort...')
如果去掉捕获型括号，split（/]*>/)返回：
多出来的元素不受分段上限的限制（chunk-limit限制原来字符串切分之后的分段数目，而
不是返回元素的数目）。
如果包含多个捕获型括号，每次匹配之后，list会多出多个元素。如果某个捕获型括号没有
参与匹配，对应的元素为undef。
巧用Perl的专有特性
FunwithtPerlEnhancements
最先由Perl提供的许多正则表达式概念，现在其他语言也提供了。包括非捕获型括号、环
视（以及之后的逆序环视）、宽松排列模式（其实是大多数模式，实际上还包括配套的A、
八z和z）、固化分组、G和条件判断结构。这些概念不再是Perl独有的，所以我把它们
挪到本书的通用部分。
不过Perl者也没有停止创新，所以现在还有些重要的概念只有Perl提供。其中最有意思的
是在匹配尝试中执行任意代码的功能。长期起来，Perl的特点之一就是正则表达式与代码的
紧密集成，但是此特性把集成提升到了新的高度。
注8：其实确实存在一种伴随效应，它在若干年前就被摒弃（deprecate）了，但是没有从语言中
去除。如果在scalarcontext或者voidcontext下使用split，它会把结果写入@_变量（它
也是用来传递函数参数的变量，所以万万不要在这两种应用场合下使用Split）。在这两
种情况下使用split，如果设置了u8ewarning或是命令行参数-w，都会看到警报。
---
## Page 353
巧用Perl的专有特性
327
我们先来简单看看这个特性和目前Peri独有的其他特性，然后详细讲解。
动态正则结构（??（perlcode））
应用正则表达式时，每次遇到表达式中的这个结构，就会执行其中的Perl代码。执行
的结果（或者是regex对象，或者是解释为正则表达式的字符事）会作为当前匹配的
一部分即刻被应用。
（\d+)(??("X{S1)"））$;中的动态正则结构以下画线标注，这个正则表达式匹配的行
开头是一个数，然后是字符‘x’必须重现对应的次数，直到行末尾。
擎遇到动态正则结构，执行“x（$1）”，得到X（3），解释得到的'x（3）作为当前正
下面我们会看到，匹配任意深度的嵌套结构时，动态正则结构尤其有用。
嵌套代码结构（?（arbitraryperlcode））
与动态正则结构一样，在正则表达式的应用过程中，遇到此结构也会执行其中的Perl
代码，但是这个结构更为通用，因为代码不需要返回任何特定的值。通常也不会用到
返回值（不过如果表达式之后的部分需要，可以通过变量S^R得到302）。
有一种情况会用到这段代码的执行结果：如果内嵌的代码结构用作（?ifthenlelse）中
的if条件（140)。此时，结果会解释为布尔值，根据它来决定执行then还是else分
支。
内嵌代码可以干许多事情，相当有用的就是调试。下面这段程序会在每次应用正则表
达式时显示一条信息，内嵌的代码结构用下画线标注：
hava a nice day"=~m{
(?(print"Starting match.\n"))
\b(?:thelan|a)\b
---
## Page 354
328
第7章：Perl
测试中，正则表达式只匹配1次，但是信息会显示6次，说明传动装置在第6次尝试
之前已经在5个位置应用了正则表达式，第6次可以完全匹配。
正则文字重载
正则文字重载能够让程序员先自行处理正则文字，再将它们交给正则引擎。它可以用
来为Perl的正则流派扩展新的功能。例如，Perl没有提供单独的单词起始和结束分隔
符（只有b)，不过你可能希望使用\，让Perl能够识别这些结构。
正则重载有些重要的限制，严格制约了它的用途。在讲解\的例子时我们会看到
这一点。
如果正则表达式中内嵌了Perl代码（无论是动态正则结构还是内嵌代码结构），最好是只使
用全局变量，除非你明白关于338页讲解的my变量的重要知识。关于my变量的讨论，请
参阅第338页。
用动态正则表达式结构匹配嵌套结构
Using a Dyamic Regex fo Match Nested Pairs
动态正则表达式的主要用途之一是匹配任意深度的嵌套结构（长久以来人们认为正则表达
式对此无能为力）。匹配任意深度的嵌套括号是个重要的例子。为了说明白动态正则如何解
决这个问题，我们首先必须知道传统结构为什么不能解决这个问题。
匹配括号文本的简单表达式是（（[^（)1)*\）。在外层括号内不容许出现括号，所以不能
容许嵌套（也就是，只容许深度为0的嵌套）。用regex对象来表示就是：
mySLevel0=qr/\（（[^（)】)*\）/x;#括号内文本
if （Stext =~m/\b（ \w+$Level0 ）/x）{
print*found function call:$1\n*;
含嵌套的括号。现在修改正则表达式来处理它，也就是需要能够处理深度为1的嵌套。
---
## Page 355
巧用Perl的专有特性
329
容许深度为1的嵌套意味着，外部的括号里头可以出现括号。所以，我们需要修改匹配外
层括号内文本的表达式（（）]，添加一个子表达式匹配内层括号里的文本。我们可以这样，
SLeve10保存这样一个正则表达式，再从此往上叠加：
my $Level0 = qr/ \(([^(）]
）*\）/x;
#括号内文本
my SLevel1=qr/\（（[^()]1$Leve10）*\）/x;
#1层嵌套
这里的SLevel0与之前的相同，新出现了SLevel1，匹配对应深度的括号，加上SLeve10，
就得到深度为1的嵌套。
为了增加嵌套的深度，我们可以用同样的方法，通过SLevel1（仍然使用sLeve1o）得到
$Leve12:
my $Level0 = qr/ \(([^()]
）*\）/x;
#括号内文本
my SLeve11 = qr/ \(([^()］1$Level0 )*\）/x;
#1层嵌套
my $Leve12 = qr/ \(（[^()]1 $Level1 )→\）/x;
#2层嵌套
继续下去就是：
my $Leve13=qr/ \(（[^()];$Leve12)*\）/x;
#3层嵌套
my $Leve14=qr/ \（（[^()]：$Leve13）*\）/x;
；#4层嵌套
my $Leve15=qr/\（（[(）];$Leve14）*\）/x;
#5层嵌套
图7-1说明了开始几层的情况：
第3层
\（（[（）]|L2）*\）
第2层
\（（[（)]丨Level1）*）
第1层
\（（[（）]|Lv）*\）
第0层
（（0
)*1)
图7-1：层数较少的嵌套
把这些层级加起来的结果很复杂，下面是SLeve113：
(((（(￥（(([()]))1[（)~]))1[()))1（)~))\
这相当难看。
---
## Page 356
330
第7章：Perl
幸运的是，我们不需要直接解释它（那是正则引擎的工作)。使用sLevel变量很容易处理，
但问题是，嵌套的深度是由SLeve1变量的数目决定的。这种办法不够灵活（用墨非定律来
说就是，如果程序能处理深度为X的嵌套，则遇到的数据的嵌套深度必定会是X+1)。
幸运的是，动态正则可以应付任意深度的嵌套。你只需要想明白，除第一个之外，每个SLeve1
变量的构建方式都是相同的：需要增加一级嵌套深度时，只需要包含上一级的SLeve1变量
即可。但如果sLevel变量都是相同的，它就同样能包含更深级别的SLevel。事实上，它还
可以包括自身。如果在匹配更深层的嵌套时它可以用某种方式包含自身，就能递归地处理
任意深度的嵌套。
这就是动态正则的威力所在。如果我们创建一个regex对象-—比如SLeve1变量，就可以
表达式，返回已存在的regex对象的Perl代码当然符合要求)。如果我们能把sLeve1之类的
regex对象放人SLevelN，就可以用（??（SLevelN））s来引I用它：
my$LevelN;
#必须首先声明，下面才能使用
SLevelN=qr/\（（[^()]1（??{ $LevelN }））*\）/x;
它就能匹配任意深度的嵌套括号，用法同之前的SLeve10：
if （Stext =~ m/\b（ \w+$LevelN ）/x）{
print*found function call:$1\n*;
哈！想明白其中的道理可不是件容易的事情，不过一且用过，就会发现这个工具的价值。
现在我们已经有了基本的办法，我希望做些修改提高效率。我会替换捕获型括号为固化分
组（这里既不需要捕获文本，也不需要回溯），之后可以把[^（）]；改为（^（）]+提高效率。
（不要在固化分组中这样做，否则会造成无休止匹配226)。
最后，我希望把（和）移动到动态正则表达式两端。这样，在确实需要用到之前，引擎
不会直接调用动态正则结构。下面是修改之后的版本：
$LevelN=qr/（?>[^（）]+1\（（??{$Leve1N}）\））*/x;
因为它不包含外部的（…\），调用sLevelN时必须手动添加。
---
## Page 357
巧用Perl的专有特性
331
这样一来，表达式就十分灵活，可以在任何可能出现嵌套括号的地方使用，而不仅仅是出
现了嵌套括号的地方：
if （Stext=~m/\b（\w+\（SLevelN\））/x）{
print "found function call: $l\n";
）
if （not $text=~m/^SLevelN S/x）{
print "mismatched parentheses!\n*;
第343页还有一个关于$Leve1N的例子。
使用内嵌代码结构
Llsing the Embedded-Code Construct
内嵌代码结构很适合调试正则表达式，以及积累正在进行的匹配的信息。下面几页详细给
出了一组例子，最终得到模拟POSIX匹配的方法。讲解的过程可能比真正的答案更有意思
（除非你只需要POSIX的匹配语意），因为在讲解中我们会收获有用的技巧和启发。
先从简单的正则表达式调试技巧开始。
用内嵌代码显示匹配进行信息
这段程序：
"abcdefgh*=~m{
(?:dlelf)
的结果是：
starting match at [1abcdefgh]
starting match at [albcdefgh]
starting match at [ablcdefgh]
starting match at [abcldefgh]
正则表达式的开头就是内嵌代码结构，所以只要正则表达式开始新一轮匹配，就会执行：
print*starting match at[S'l$']\n
它用变量s和S'（300）（注9）表示目标字符串，用‘标记当前的匹配位置（在这里就
是匹配开始的位置）。从结果中我们可以知道，传动装置（*148）进行了4次应用，才匹
配成功。
注9：通常，我不推荐使用特殊的匹配变量S、S&和S'，它们会降低整个程序的效率（356），
但是它们对临时调试非常有用。
---
## Page 358
332
第7章：Perl
事实上，如果我们添加：
(.<>]ee.d）
在正则表达式末尾，则结果是：
matched at [abcefgh]
分与开头的例子是一样的：
abcdefgh*=~m(
（u]b.d）
[def]
}×;
从理论上说，结果应该是一样的，实际情况却是：
starting match at [abcldefgh]
为什么呢？Perl足够聪明，对这个以[def]开头的正则表达式进行开头字符/字符组/字串
识别优化（247），这样传动装置就能略过那些它认为必然会失败的尝试。结果是忽略了
其他所有尝试，只进行了可能导致匹配的尝试，我们可以通过内嵌代码结构观察到这种现
象。
panic:top_env
使用内嵌代码或是动态正则表达式时，如果程序忽然终止，给出这样的信息：
panic:top_env
很可能是因为正则表达式的代码部分存在语法错误。Perl不能识别某些错误的语法，
结果就是这条信息。解决的办法就是修正语法错误。
用内嵌代码显示所有匹配
Perl使用的是传统型NFA引擎，所以一旦找到匹配就会停下来，即使还存在其他的匹配也
是如此。如果巧妙地使用内嵌代码，我们能够让Perl显示所有的匹配。我们仍然以177页
的‘onself’为例来说明。
oneselfsufficient" =~ m{
one(self)?(selfsufficient)?
(?(print“matched at[$'S']\n"})
)×;
---
## Page 359
巧用Perl的专有特性
333
结果如我们所料：
matched at [sufficient]
表示‘oneselfsufficient’已经被正则表达式匹配。
前获得的匹配。在这个例子中谈论其中的区别意义不大，因为内嵌代码结构位于正则表达
式的最后。我们知道，内嵌代码结构完成时，整个正则表达式的所有匹配尝试都已结束，
实际匹配的结果就是如此。
会失败。如果它在内嵌代码执行之后生效（也就是在“matched”信息打印之后），就会强迫
引擎回溯，查找新的匹配。每次输出“matched”信息之后，（?！）都会强迫引擎回溯，最
终试遍所有的可能。
matched at [sufficient]
matched at []
matched at [selfsufficient]
我们所做的修改确保正则表达式必然不能完整匹配，但是这样做却能让引擎报告显示所有
可能的匹配。如果不使用（？！），Perl只会返回第一个匹配，使用（？！）则可以见到其他可