3.9.4
Unit Testing
90
3.9.5
Fault Injection
90
3.9.6
Syntax Testing
91
3.9.7
Negative Testing
94
3.9.8
Regression Testing
95
3.10 Summary
96
CHAPTER 4
Fuzzing Metrics
99
4.1
Threat Analysis and Risk-Based Testing
103
4.1.1
Threat Trees
104
4.1.2
Threat Databases
105
4.1.3
Ad-Hoc Threat Analysis
106
4.2
Transition to Proactive Security
107
4.2.1
Cost of Discovery
108
4.2.2
Cost of Remediation
115
4.2.3
Cost of Security Compromises
116
4.2.4
Cost of Patch Deployment
117
4.3
Defect Metrics and Security
120
4.3.1
Coverage of Previous Vulnerabilities
121
4.3.2
Expected Defect Count Metrics
124
Contents
ix
4.3.3
Vulnerability Risk Metrics
125
4.3.4
Interface Coverage Metrics
127
4.3.5
Input Space Coverage Metrics
127
4.3.6
Code Coverage Metrics
130
4.3.7
Process Metrics
133
4.4
Test Automation for Security
133
4.5
Summary
134
CHAPTER 5
Building and Classifying Fuzzers
137
5.1
Fuzzing Methods
137
5.1.1
Paradigm Split: Random or Deterministic Fuzzing
138
5.1.2
Source of Fuzz Data
140
5.1.3
Fuzzing Vectors
141
5.1.4
Intelligent Fuzzing
142
5.1.5
Intelligent Versus Dumb (Nonintelligent) Fuzzers
144
5.1.6
White-Box, Black-Box, and Gray-Box Fuzzing
144
5.2
Detailed View of Fuzzer Types
145
5.2.1
Single-Use Fuzzers
145
5.2.2
Fuzzing Libraries: Frameworks
146
5.2.3
Protocol-Specific Fuzzers
148
5.2.4
Generic Fuzzers
149
5.2.5
Capture-Replay
150
5.2.6
Next-Generation Fuzzing Frameworks: Sulley
159
5.2.7
In-Memory Fuzzing
161
5.3
Fuzzer Classification via Interface
162
5.3.1
Local Program
162
5.3.2
Network Interfaces
162
5.3.3
Files
163
5.3.4
APIs
164
5.3.5
Web Fuzzing
164
5.3.6
Client-Side Fuzzers
164
5.3.7
Layer 2 Through 7 Fuzzing
165
5.4
Summary
166
CHAPTER 6
Target Monitoring
167
6.1
What Can Go Wrong and What Does It Look Like?
167
6.1.1
Denial of Service (DoS)
167
6.1.2
File System–Related Problems
168
6.1.3
Metadata Injection Vulnerabilities
168
6.1.4
Memory-Related Vulnerabilities
169
6.2
Methods of Monitoring
170
6.2.1
Valid Case Instrumentation
170
6.2.2
System Monitoring
171
x
Contents
6.2.3
Remote Monitoring
175
6.2.4
Commercial Fuzzer Monitoring Solutions
176
6.2.5
Application Monitoring
176
6.3
Advanced Methods
180
6.3.1
Library Interception
180
6.3.2
Binary Simulation
181
6.3.3
Source Code Transformation
183
6.3.4
Virtualization
183
6.4
Monitoring Overview
184
6.5
A Test Program
184
6.5.1
The Program
184
6.5.2
Test Cases
185
6.5.3
Guard Malloc
187
6.5.4
Valgrind
188
6.5.5
Insure++
189
6.6
Case Study: PCRE
190
6.6.1
Guard Malloc
192
6.6.2
Valgrind
193
6.6.3
Insure++
194
6.7
Summary
195
CHAPTER 7
Advanced Fuzzing
197
7.1
Automatic Protocol Discovery
197
7.2
Using Code Coverage Information
198
7.3
Symbolic Execution
199
7.4
Evolutionary Fuzzing
201
7.4.1
Evolutionary Testing
201
7.4.2
ET Fitness Function
201
7.4.3
ET Flat Landscape
202
7.4.4
ET Deceptive Landscape
202
7.4.5
ET Breeding
203
7.4.6
Motivation for an Evolutionary Fuzzing System
203
7.4.7
EFS: Novelty
204
7.4.8
EFS Overview
204
7.4.9
GPF + PaiMei + Jpgraph = EFS
206
7.4.10 EFS Data Structures
206
7.4.11 EFS Initialization
207
7.4.12 Session Crossover
207
7.4.13 Session Mutation
208
7.4.14 Pool Crossover
209
7.4.15 Pool Mutation
210
7.4.16 Running EFS
211
7.4.17 Benchmarking
215
7.4.18 Test Case—Golden FTP Server
215
Contents
xi
7.4.19 Results
215
7.4.20 Conclusions and Future Work
219
7.5
Summary
219
CHAPTER 8
Fuzzer Comparison
221
8.1
Fuzzing Life Cycle
221
8.1.1
Identifying Interfaces
221
8.1.2
Input Generation
222
8.1.3
Sending Inputs to the Target
222
8.1.4
Target Monitoring
223
8.1.5
Exception Analysis
223
8.1.6