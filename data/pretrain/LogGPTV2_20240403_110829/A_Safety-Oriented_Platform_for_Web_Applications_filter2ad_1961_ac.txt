cess, derived from tinyproxy [16]. The proxy checks each
requested URL against the browser instance’s network pol-
icy, returning an error if the URL is outside of the manifest-
deﬁned Web service.
For unencrypted connections, the proxy can ﬁlter based
on the full URL. SSL connections, however, encrypt the
URL. For these connections, the proxy can ﬁlter based only
on host and port number. Similarly, other protocols, such as
streaming video, can be restricted based only on network-
and transport-level connection attributes, since our proxy
does not understand their protocols. This limits the trust-
worthiness of our current proxy to that of the DNS system
on which it relies, even for SSL-protected connections.
Each Xen VM executing a browser instance includes
several virtual disks, which are initialized and controlled by
the BOS kernel. A read-only root disk contains the base ﬁle
system for the browser instance, including the image of its
guest OS. A writable data disk provides storage for any data
the browser instance needs to durably store on the local sys-
tem. When an application is launched for the ﬁrst time, its
data disk is initialized to a blank ﬁle system.
Separating the writable data disk from the read-only
root disk permits simple upgrade semantics if the root disk
changes: the BOS replaces the root disk, but preserves the
data disk. Any data that the browser instance stores in the
data disk therefore survives upgrades. More importantly,
by making the root disk read-only, we can safely share root
disks across browser instances.
Persistent changes made by the application are applied to
the virtual data disk on the guest OS, not to the ﬁle-system
of the host OS on which the user is running. In this way, the
user’s OS is isolated from potentially dangerous changes,
such as those made by spyware or other pathogens. Equally
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:31 UTC from IEEE Xplore.  Restrictions apply. 
   aa.com                www.aa.com 
   www.touraa.com        network.realmedia.com 
   www.macromedia.com    www.latinmedios.com 
   ad.doubleclick.net    switch.atdmt.com 
  ...additional advertising partner sites...
    Windows ia32 FireFox http://www.mozilla.org/firefox_ia32.vm
  ...additional browser instances...
   ...DSA signature block...
Figure 5. A sample manifest. This manifest for the American Airlines Web service permits access to the main Web
site and the sites of advertising partners. It indicates that the browser instance should run a stock Firefox browser.
important, the user can remove all durable changes made by
an application simply by deleting its browser instance.
3.3 Manifests
A Web service deﬁnes a Web application by creating a
manifest and making it accessible to the BOS kernel. The
manifest describes policies and attributes that control the
execution and behavior of all browser instances associated
with the Web application. A manifest is an XML docu-
ment that includes: (1) a network policy, which speciﬁes
the remote network services with which a browser instance
can interact; (2) a browser policy, which speciﬁes the code
that should be initially installed within a browser instance’s
sandbox; (3) a digital signature for the Web service; (4)
a human-readable Web application name; (5) a machine-
readable manifest name; and (6) a globally unique identiﬁer
for the application. Figure 5 shows a sample manifest.
3.3.1 Manifest location and authentication
Conceptually, every Web object has an associated mani-
fest. Web servers can supply an “X-Tahoma-manifest”
HTTP header extension when delivering a Web object. This
header speciﬁes the unique name for the object’s manifest
and a URL from which the manifest can be retrieved by the
browser operating system.
There are two ways for the user to launch a Web appli-
cation for the ﬁrst time. First, the user can invoke one of
Tahoma’s management tools and pass the URL to it. Sec-
ond, the user can type the URL into a browser instance of
a different Web application. In either case, the result is the
same. The BOS performs an HTTP HEAD operation on
the supplied URL to ﬁnd and retrieve the Web application’s
manifest.
executes inside a new Xen virtual machine.
It will then fork a new browser instance that
In addition to the HTTP header extension, we also sup-
port per-server manifest ﬁles. If a manifest is not provided
in an object’s HTTP header, the BOS attempts to download
“/manifest.xml” from the Web server providing that
object. As a ﬁnal fall-back, the BOS also consults a local
database of manually supplied manifest ﬁles.
If none of
these mechanisms succeeds, the BOS automatically gener-
ates a new generic manifest that implements the basic Web
security model that conventional browsers enforce. The
generic manifest permits access to any URLs reached on
a path from the top-level URL. However, the BOS forks a
new browser instance to execute any document not in the
top-level URL’s domain.
Tahoma uses public-key certiﬁcates to authenticate Web
applications to clients. Each Web application has an asso-
ciated master public/private key pair. Using the private key,
Web services sign manifests to prove their authenticity to
clients. These signatures are included in the manifests us-
ing the XML-SIG standard [5]. Note that this certiﬁcation
scheme does not completely solve all trust issues. Neither
the BOS nor a user has any reason to initially believe that
a particular key pair speaks for the real-world entity that
should be associated with the Web application. For this we
rely on traditional PKI certiﬁcation authorities.
Manifest signatures allow an application’s manifest to
evolve over time. A signature securely veriﬁes that two
manifests came from the same source. A Web service can
replace an existing application manifest by sending a new
manifest with the same name. Alternatively, the Web ser-
vice can add a manifest for a Web application by sending
a new manifest that has a different manifest name but the
same application name.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:31 UTC from IEEE Xplore.  Restrictions apply. 
3.3.2 Manifest policies
As previously mentioned, the manifest network policy de-
scribes the access rights of a browser instance by listing the
Web sites with which it may communicate. An entry in the
list contains a host name (or a regular expression against
which candidate host names are matched) and an optional
set of qualiﬁers, including a port, protocol, or URL on that
host. The Web service speciﬁed by a manifest is deﬁned
as the union of all items in its network policy. To allow an
application’s Web service to be incrementally deﬁned, a sin-
gle Web application may consist of multiple manifests. Be-
cause network policies are simply lists, we can easily con-
catenate network policies within manifests without creating
unexpected policy effects.
Web services can express any policy they choose. Noth-
ing prevents one Web application from including a Web ob-
ject in its manifest that also falls in a second application.
In other words, Web applications can overlap. This reﬂects
the nature of the Web:
there are no technical restrictions
on linking or embedding content without the approval of
its publisher. However, a Web application can prevent its
browser instances from fetching content from or sending
information to other Web applications.
In addition to the network policy, each manifest speci-
ﬁes the code that should be run in the browser instance. If
the Web service wishes to run a stock Web browser, it pro-
vides a list of permissible browsers and guest OSs. As a
performance optimization, the BOS kernel stores a set of
VM checkpoints of freshly booted stock browsers. If one
of the browser checkpoints matches a permissible browser
speciﬁed in the manifest, the BOS clones the checkpoint
into a new VM sandbox. If not, the BOS relies on the Web
service to supply a URL of a VM image to download and
execute.
Alternatively, the Web service can mandate that a custom
browser instance should run in the sandbox. In this case,
the Web service must supply a URL and hash of the custom
VM image to be downloaded. The VM image must contain
a bootable x86 guest operating system and applications.
We will not discuss network policy creation in detail in
this paper. However, we have built a Web crawler to aid
in manifest construction and have written manifests for the
top ten most popular Web sites (according to Alexa.com).
In general, we found it fairly simple to construct manifests
with the help of this tool.
3.4 The Window Manager
Tahoma’s user interface is implemented by a window
manager process running in Domain0. We designed the
windowing mechanisms with both performance and safety
in mind. For performance, the window manager ofﬂoads
work, using functions available in the graphics processing
unit (GPU) of modern video cards.For safety, our imple-
mentation ensures that browser instances cannot perform
denial-of-service attacks by consuming excessive BOS re-
sources: all graphics state is maintained by and charged to
the browser instances themselves.
The Tahoma window manager provides a virtual screen
abstraction to each browser instance. Within this virtual
screen, the browser instance can create and position one
or more rectangular sprites, as shown in Figure 6a. Each
sprite consists of a grid of tiles. A tile, which is backed by a
single 4KB machine page in the browser instance’s virtual
machine, contains 32 x 32 pixels, with 32 bits of color and
alpha information per pixel.
Providing browser instances with the abstraction of mul-
tiple sprites is useful for several reasons. A Web browser
typically exposes multiple windows to the user; each win-
dow can be represented by a sprite.
In addition, layered
user-interface elements, such as ﬂoating toolbars and pull-
down menus, can be incorporated as additional sprites over-
laid on the main window sprite. By using page-aligned tiles,
the window manager can exploit the dirty-page tracking of
the CPU memory management unit (MMU) to determine
which tiles have been modiﬁed and need to be copied to the
graphics card.
The Tahoma window manager superimposes the sprites
of each browser instance onto the physical computer screen,
as shown in Figure 6. Many different policies are possi-
ble. For example, the window manager could co-mingle the
sprites of all browser instances in the main screen area, as
shown in Figure 6b. Alternatively, it could preserve the no-
tion of virtual screens, as shown in Figure 6c.
To simplify porting browsers to Tahoma, we modiﬁed
the Qt multi-platform GUI library to interact with the win-
dow manager through its tiles and sprites abstractions. We
preserved Qt’s API; Qt-compatible applications can be re-
linked against our modiﬁed libQT to make them work with
Tahoma’s graphics subsystem.
3.5 Browsers
The execution environment of a browser instance is
based on a Xen virtual machine. Therefore, most appli-
cations will run on Tahoma with little or no modiﬁcation.
However, three kinds of modiﬁcations may be necessary:
(1) linking to libQT to access the Tahoma graphics sub-
system; (2) using a browser-call to access remote services,
rather than accessing the network directly through a virtual
device; and (3) using browser-calls for new functions, such
as forking a new browser instance or interacting with the
holding bin.
To date, we have implemented two Tahoma browsers:
a port of the Konqueror Web browser [18] and a port of
the MPlayer media player [20]. Konqueror is a fully fea-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:31 UTC from IEEE Xplore.  Restrictions apply. 
virtual screen (app 1)
virtual screen (app 2)
sprite
sprite
sprite
sprite
sprite
spriteite
(a)
(b)
(c)
Figure 6. Tahoma window manager. (a) The Tahoma window manager aggregates the virtual screens of each
browser instance on the physical screen. (b) In one policy, the individual sprites from each instance are all collapsed
into a single drawing area. (c) In another policy, the window manager preserves the isolation of sprites for each instance
in their own virtual screens.
tured Web browser that supports Java applets, JavaScript,
SSL, DOM, and cascading style sheets. The MPlayer me-
dia player supports most popular video and audio codecs,
either natively or by wrapping third party binary codec li-
braries. The MPlayer implementation is performance fo-
cused, optimizing the speed of video decoding via special-
ized hardware features, such as CPU SIMD extensions or
GPU colorspace conversion and image scaling.
Our MPlayer port demonstrates the ﬂexibility of the
Tahoma architecture. By selecting MPlayer to run in their
browser instances, Web services can provide users with
streaming media applications, such as Internet radio or
television, instead of a more conventional HTML brows-
ing service. From the perspective of a user, an MPlayer
browser instance will have a radically different look and
feel than a conventional Web browser. From the perspec-
tive of Tahoma, MPlayer is simply a browser instance and
is treated like any other browser instance.
3.6 Summary
We implemented the Tahoma browser operating system
as a layer on top of the Xen virtual machine monitor. Our
implementation beneﬁts from the ability to create and con-
trol Xen virtual machines through the Xen Domain0 VM.
This lets us program the major components of Tahoma – the
BOS kernel, the network proxy, and the window manager
– as user-mode Domain0 processes. Browser instances,
which are encapsulated in Xen virtual machines, communi-
cate with the BOS kernel through high-level browser-calls
carried by virtual network links. In the following section,
we evaluate the safety beneﬁts and the performance over-
head of our Tahoma architecture and its implementation.
4 Evaluation
Our Tahoma prototype consists of approximately 10K
lines of Perl and C code. This section evaluates two as-
pects of the prototype: (1) its safety and effectiveness in
containing threats, and (2) its performance. We have not
yet optimized our implementation. Therefore, our perfor-
mance results should be considered as an upper bound on
the overhead intrinsic to our approach.
4.1 Safety and Eﬀectiveness
A critical measure of Tahoma’s value is whether it suc-
cessfully prevents or contains threats that occur in practice.
Isolation should provide signiﬁcant safety beneﬁts. How-
ever, Tahoma will not prevent all threats.
As an example, security vulnerabilities can arise due to
Tahoma’s dependence on external systems, such as DNS.
Attackers that subvert DNS can subvert Tahoma’s network
ﬁltering policies by changing legitimate bindings to point
to IP addresses outside of the intended domain. Tahoma
cannot defend itself from these attacks. Another example
is a malicious browser instance, which could use a sharing
interface provided by Tahoma to attack another browser in-
stance or Web application. While Tahoma greatly reduces
the number of sharing channels, these channels still exist.
Consider a browser that contains a buffer-overﬂow vulner-
ability in its URL parsing code. A malicious browser in-
stance could use the fork browser-call to pass an attack
string to a second browser instance, potentially subverting
it. Any channel that permits sharing between mutually dis-
trusting Web applications is susceptible to attack.
To quantitatively evaluate the effectiveness of Tahoma,
we obtained a list of 109 security vulnerabilities discovered
in current or previous versions of the widely used Mozilla
open source browser. We analyzed the vulnerabilities and
classiﬁed them into ﬁve different categories. The ﬁve vul-
nerability categories, along with the Tahoma features in-
tended to defend against them, are:
• Sandbox weakness: Browsers use language and run-
time mechanisms to sandbox scripts, applets, and
other active Web content, but these language- and
type-speciﬁc sandboxes are often ﬂawed.
In con-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:31 UTC from IEEE Xplore.  Restrictions apply. 
class of vulnerability
examples
% contained
weak sandbox
Active content can replace a portion of the JavaScript runtime with its own scripts and gain access to trusted areas of Mozilla.
100% (55 of 55)
vulnerable sharing interface
By crafting an HTML upload form, attackers can select the name of a file to transfer, accessing any file on the user’s machine.