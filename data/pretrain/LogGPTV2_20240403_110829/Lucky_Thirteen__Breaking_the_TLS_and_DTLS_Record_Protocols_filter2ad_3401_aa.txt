title:Lucky Thirteen: Breaking the TLS and DTLS Record Protocols
author:Nadhem J. AlFardan and
Kenneth G. Paterson
2013 IEEE Symposium on Security and Privacy
Lucky Thirteen: Breaking the TLS and DTLS Record Protocols
Nadhem J. AlFardan and Kenneth G. Paterson
Information Security Group,
Royal Holloway, University of London
Email: {nadhem.alfardan.2009, kenny.paterson}@rhul.ac.uk
Egham, Surrey TW20 0EX, UK
Abstract—The Transport Layer Security (TLS) protocol
aims to provide conﬁdentiality and integrity of data in transit
across untrusted networks. TLS has become the de facto secure
protocol of choice for Internet and mobile applications. DTLS
is a variant of TLS that is growing in importance. In this
paper, we present distinguishing and plaintext recovery attacks
against TLS and DTLS. The attacks are based on a delicate
timing analysis of decryption processing in the two protocols.
We include experimental results demonstrating the feasibility of
the attacks in realistic network environments for several differ-
ent implementations of TLS and DTLS, including the leading
OpenSSL implementations. We provide countermeasures for
the attacks. Finally, we discuss the wider implications of our
attacks for the cryptographic design used by TLS and DTLS.
Keywords-TLS, DTLS, CBC-mode encryption, timing attack,
plaintext recovery
I. INTRODUCTION
TLS is arguably the most widely-used secure communica-
tions protocol on the Internet today. Starting life as SSL, the
protocol was adopted by the IETF and speciﬁed as TLS 1.0
[7]. It has since evolved through TLS 1.1 [8] to the current
version TLS 1.2 [9]. Various other RFCs deﬁne additional
TLS cryptographic algorithms and extensions. TLS is now
used for securing a wide variety of application-level trafﬁc
and has become a serious rival to IPsec for general VPN
usage. It is widely supported in client and server software
and in cryptographic libraries for embedded systems, mobile
devices, and web application frameworks.
The DTLS protocol is a close relative of TLS, developed
from TLS by making minimal changes so as to allow it
to operate over UDP instead of TCP [16]. This makes
DTLS suitable for use where the costs of TCP connection
establishment and TCP retransmissions are not warranted,
for example, in voice and gaming applications. DTLS exists
in two versions, DTLS 1.0 [20], which roughly matches TLS
1.1 and DTLS 1.2 [21], which aligns with TLS 1.2.
Both TLS and DTLS are actually protocol suites, rather
than single protocols. The main component of (D)TLS that
concerns us here is the Record Protocol, which uses sym-
metric key cryptography (block ciphers, stream ciphers and
MAC algorithms) in combination with sequence numbers
The second author’s research was supported by an EPSRC Leadership
Fellowship, EP/H005455/1.
to build a secure channel for transporting application-layer
data. Other major components are the (D)TLS Handshake
Protocol, which is responsible for authentication, session
key establishment and ciphersuite negotiation, and the TLS
Alert Protocol, which carries error messages and manage-
ment trafﬁc. Setting aside dedicated authenticated encryption
algorithms (which are yet to see widespread support in TLS
or DTLS implementations), the (D)TLS Record Protocol
uses a MAC-Encode-Encrypt (MEE) construction. Here, the
plaintext data to be transported is ﬁrst passed through a
MAC algorithm (along with certain header bytes) to create
a MAC tag. The supported MAC algorithms are all HMAC-
based, with MD5, SHA-1 and SHA-256 being the allowed
hash algorithms in TLS 1.2 [9]. Then an encoding step
takes place. For the RC4 stream cipher, this just involves
concatenation of the plaintext and the MAC tag, while
for CBC-mode encryption (the other possible option), the
plaintext, MAC tag, and some encryption padding of a
speciﬁed format are concatenated. In the encryption step,
the encoded plaintext is encrypted with the selected cipher.
In the case where CBC-mode is selected, the block cipher
is DES, 3DES or AES (with DES being deprecated in TLS
1.2). Following [18], we refer to this MEE construction as
MEE-TLS-CBC. We provide greater detail on its operation
in the (D)TLS Record Protocol in Section II.
The widespread use of TLS (and the increasing use
of DTLS) makes the continued study of the security of
these protocols of great importance. Indeed, the evolution
of the TLS Record Protocol has largely been driven by
cryptographic attacks that have been discovered against it,
including those in [25], [5], [17], [3], [4], [10], [18], [1].
Of particular interest lately have been attacks based on the
use of chained initialisation vectors (IVs) for CBC-mode
in SSL and TLS 1.0, in particular, the so-called BEAST
attack [10] which has its roots in [23], [17], [3], [4]. This
attack achieved full plaintext recovery against TLS, but
only in scenarios where an attacker can gain access to a
chosen plaintext capability, perhaps by inducing the user to
ﬁrst download malicious javascript code into his browser.
Despite this strong requirement, the BEAST attack attracted
signiﬁcant industry and media attention in 2011. Amongst
the possible countermeasures are upgrading to TLS 1.1 or
1.2, the inclusion of a dummy zero-length message prior to
1081-6011/13 $26.00 © 2013 IEEE
DOI 10.1109/SP.2013.42
526
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:50 UTC from IEEE Xplore.  Restrictions apply. 
each real TLS message, or the abandonment of CBC-mode
encryption in favour of RC4 or an authenticated encryption
algorithm.
The other major line of attacks against the TLS Record
Protocol comprises [25], [5], [17], [18], [1] and relates
to how the padding that is required in MEE-TLS-CBC is
handled during decryption. The problems here all stem from
the fact that the padding is added after the MAC has been
computed and so forms unauthenticated data in the encoded
plaintext. Taken altogether, the attacks in [25], [5], [17], [18],
[1] show that handling padding arising during decryption
processing is a delicate and complex issue for MEE-TLS-
CBC.
It is the case that all these attacks on CBC-mode in
TLS could be avoided by adopting RC4 or a dedicated
authenticated encryption mode, or perhaps by redesigning
(D)TLS to use only an Encrypt-then-MAC construction.
However, RC4 is not an option for DTLS, and not NIST-
recommended for TLS [6]; meanwhile authenticated encryp-
tion modes are only available in TLS 1.2, which is not
yet widely supported.1 Redesigning (D)TLS would require
even more radical changes than adopting TLS 1.2. So it
would be fanciful to “wish away” MEE-TLS-CBC, and all
the complexity that this entails: this is an option that is
ﬁrmly embedded in the TLS and DTLS RFCs, in widespread
use, and will remain so for the foreseeable future. On the
other hand, we might hope that after more than a decade of
intensive study, we would have arrived at a point where we
understand how to implement MEE-TLS-CBC securely. In
this paper, we show that this is not the case.
A. Our Results
We present a family of attacks that apply to CBC-mode
in all TLS and DTLS implementations that are compliant
with TLS 1.1 or 1.2, or with DTLS 1.0 or 1.2. They also
apply to implementations of SSL 3.0 and TLS 1.0 that
incorporate padding oracle attack countermeasures (imple-
mentations that do not are of course already vulnerable to
known attacks).
The attacks come in various distinguishing, partial plain-
text recovery, and full plaintext recovery ﬂavours. For the
plaintext recovery attacks, no chosen-plaintext capability is
needed, in contrast to the BEAST attacks: the attacks can be
mounted by a standard man-in-the-middle (MITM) attacker
who sees only ciphertext and can inject ciphertexts of his
own composition into the network. The details of which
speciﬁc attacks are possible depends on the exact size of
MAC tags output by the MAC algorithm negotiated by the
Handshake Protocol, and also on the fact that the exactly 13
bytes of header data are incorporated in the MAC calculation
(hence our title).
1SSL Pulse (https://www.trustworthyinternet.org/ssl-pulse/) reported that
only 11.4% of 200,000 websites surveyed support TLS 1.2 in January 2013;
most major browsers currently do not support TLS 1.2.
527
The applicability of the attacks is also implementation-
dependent, because of the manner in which different imple-
mentations interpret the RFCs. We have investigated several
different open-source implementations of TLS and DTLS,
and found all of them to be vulnerable to our new attacks
or variants of them (or even old attacks in one case).
We have implemented a selection of the attacks in an
experimental setting. As with earlier attacks, completely
breaking TLS is challenging because the attacks create
“broken” TLS records and so consume many TLS sessions.
Nevertheless, our basic attack can extract full plaintext
for the current OpenSSL implementation of TLS assuming
the attacker is located, say, in the same LAN segment as
the targeted TLS client or server, using roughly 223 TLS
sessions to reliably recover a block of plaintext in a multi-
session attack scenario like that considered in [5]. Such a
scenario is applicable when, for example, an application pro-
tocol performs automatic TLS reconnection and password
retransmission. Given its complexity, this basic attack would
seem to present only a theoretical threat. However, variants
of it are much more effective:
• The distinguishing attacks against TLS are quite prac-
tical for OpenSSL, requiring just a handful of sessions
in order to reliably tell apart the encryptions of chosen
messages.
• Breaking DTLS implementations is fully practical even
for a remote attacker, since we can exploit the fact that
DTLS errors are non-fatal to mount the attacks in a
single session, and reuse the ampliﬁcation techniques
from [1] to boost the delicate timing signals on which
our attacks depend.
• We also have more efﬁcient partial plaintext recov-
ery attacks on TLS and DTLS. For example, against
OpenSSL TLS, an attacker who knows one byte of a
block in either of the last two byte positions can reliably
recover each of the remaining bytes in that block using
216 sessions.
• The complexity of all our attacks can be reduced using
language models and sequential statistical techniques
as in [5], [10]. As a simple example, if the plaintext
is base64 encoded, as is the case for HTTP basic
access authentication and cookies, then the number of
TLS sessions needed to recover a block reduces from
roughly 223 to 219.
• In the web setting, our techniques can be combined
with those used in the BEAST attack [10]: client-
side malware running in the browser can be used to
initiate all the needed TLS sessions, with an HTTP
cookie being automatically injected by the browser in
a predictable location in the plaintext stream in each
session. The malware can also control the location of
the cookie such that there is only one unknown byte in
the target block at each stage of the attack. The attacker
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:50 UTC from IEEE Xplore.  Restrictions apply. 
then combines the “one known byte” variant of our
attack and the base64 optimisation above (assuming the
sensitive part of the cookie is base64 encoded). Putting
all of these improvements together, we estimate that
HTTP cookies can be recovered using 213 sessions per
byte of cookie (with all the sessions being automatically
generated). Note that the malware does not need the
ability to inject chosen plaintext into an existing TLS
session for this attack.
B. How the Attacks Work
Our new attacks exploit the fact that, when badly for-
matted padding is encountered during decryption, a MAC
check must still be performed on some data to prevent the
known timing attacks. But what data should be used for
that calculation? The TLS 1.1 and 1.2 RFCs recommend
checking the MAC as if there was a zero-length pad. As
noted in those RFCs:
This leaves a small timing channel, since MAC
performance depends to some extent on the size
of the data fragment, but it is not believed to be
large enough to be exploitable, due to the large
block size of existing MACs and the small size of
the timing signal.
We conﬁrm that there are indeed small timing differences,
but, contrary to what is written in the RFCs, they can be
exploited. In short, provided there is a fortuitous alignment
of various factors such as the size of MAC tags, the block
cipher’s block size, and the number of header bytes, then
there will be a time difference in the time that it takes to
process TLS records having good and bad padding, and this
difference will show up in the time at which error messages
appear on the network. This timing side-channel can then be
“wrangled” into revealing plaintext data via careful statistical
analysis of multiple timing samples.
C. Disclosure
Given the large number of affected implementations, we
ﬁrst notiﬁed the IETF TLS Working Group chairs,
the
IETF Security Area directors and the IRTF Crypto Forum
Research Group (CFRG) chairs of our attacks in November
2012. We then began the process of contacting individual
vendors. Patches to address our attacks have been issued by
OpenSSL, NSS, GnuTLS, PolarSSL, CyaSSL, MatrixSSL,
Opera, F5, BouncyCastle and Oracle. For further details, see
the full version [2].
D. Further Details on Related Work
Padding oracle attacks began with Vaudenay [25], who
showed that the presence of a padding oracle, that is, an
oracle telling an attacker whether the padding was correctly
formatted or not, could be leveraged to build a decryption
capability. Canvel et al. [5] showed that such an oracle could
be obtained for the then-current version of OpenSSL by
exploiting a timing difference in TLS decryption processing.
In essence, in OpenSSL, if the padding was incorrectly
formatted, then no MAC check was performed, while if
the padding was correct, then the MAC check was done.
In turn, this meant faster production of an error message in
the “invalid padding” case than in the “valid padding” case.
Thus the padding oracle was revealed through a timing side-
channel. A complication for full plaintext recovery is that
in TLS, the corresponding error messages are fatal, leading
to the termination of the TLS session. To overcome this,
Canvel et al. considered the multi-session setting, wherein
it is assumed that the same plaintext is transmitted in the
same position in the ciphertext in many sessions. Moeller
[17] subsequently pointed out that not doing padding format
checks is not an option, since this enables even simpler
attacks. The correct solution, as advocated in TLS 1.1 and
TLS 1.2, is to check the padding format carefully, report a
single error message for padding and MAC failures, and
to make the record processing time essentially the same
whether or not the padding is correct. Most recently, in
[1], we showed that the OpenSSL implementation of DTLS
did not adopt the known attack countermeasures. We also
introduced novel timing ampliﬁcation techniques to build
full plaintext recovery attacks against this implementation
of DTLS, even though DTLS has no explicit error messages
to time.
Theoretical support for the MEE construction used in
(D)TLS can be found in [12], [14], [18]. In particular,
Paterson et al. [18] gave the ﬁrst positive security results
for a fully accurate model MEE-TLS-CBC that includes
all the details of the CBC-mode encoding step (which in-
corporates padding), proving that MEE-TLS-CBC provides
Length Hiding Authenticated-Encryption security, provided
that
its MAC and CBC-mode block cipher components
satisfy natural security properties, that the MAC tags are
long enough, and that it is implemented so that decryption
does not reveal the cause of any failures. Our attacks exploit
the fact that current implementations of (D)TLS fail to meet
this last assumption. So our attacks do not contradict the
results of [18], but instead relativize their applicability to
practice.
In independent work, Pironti et al. [19] identify effectively
the same timing channel in TLS that we exploit. However
they dismiss it as being “too small to be measured over
the network” and instead focus on using it
to recover
information about message lengths. The recent CRIME
attack exploits the optional use of compression in TLS in
combination with a chosen plaintext capability to mount a
plaintext recovery attack.
II. THE (D)TLS RECORD PROTOCOL
We focus on the cryptographic operation of the TLS
and DTLS Record Protocols in the case of CBC-mode
528
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:50 UTC from IEEE Xplore.  Restrictions apply. 
SQN 
HDR 
Payload 
MAC 
transmitted over the wire then has the form:
HDR||C
Payload 
MAC tag 
Padding 
Encrypt 
Ciphertext 
Figure 1. D(TLS) encryption process
encryption. The core encryption process is illustrated in
Figure 1 and explained in more detail below.
Data to be protected by TLS or DTLS is received from the
application and may be fragmented and compressed before
further processing. An individual record R (viewed as a byte
sequence of length at least zero) is then processed as follows.
The sender maintains an 8-byte sequence number SQN which
is incremented for each record sent2, and forms a 5-byte ﬁeld
HDR consisting of a 2-byte version ﬁeld, a 1-byte type ﬁeld,
and a 2-byte length ﬁeld. It then calculates a MAC over
the bytes SQN||HDR||R; let T denote the resulting MAC
tag. Note that exactly 13 bytes of data are prepended to the
record R here before the MAC is computed. The size of
the MAC tag is 16 bytes (HMAC-MD5), 20 bytes (HMAC-
SHA-1), or 32 bytes (HMAC-SHA-256). We let t denote
this size in bytes.
The record is then encoded to create the plaintext P
by setting P = R||T||pad. Here pad is a sequence of
padding bytes chosen such that the length of P in bytes
is a multiple of b, where b is the block-size of the selected
block cipher (so b = 8 for 3DES and b = 16 for AES). In
all versions of TLS and DTLS, the padding must consist of
p + 1 copies of some byte value p, where 0 ≤ p ≤ 255.