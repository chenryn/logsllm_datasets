几乎所有的大型企业都有资料仓库，但在小型企业中几乎闻所未闻。这可能是因为大多数小公司没有这么多不同的 OLTP 系统，大多数小公司只有少量的资料 —— 可以在传统的 SQL 资料库中查询，甚至可以在电子表格中分析。在一家大公司里，要做一些在一家小公司很简单的事情，需要很多繁重的工作。
使用单独的资料仓库，而不是直接查询 OLTP 系统进行分析的一大优势是资料仓库可针对分析类的访问模式进行最佳化。事实证明，本章前半部分讨论的索引演算法对于 OLTP 来说工作得很好，但对于处理分析查询并不是很好。在本章的其余部分中，我们将研究为分析而最佳化的储存引擎。
#### OLTP资料库和资料仓库之间的分歧
资料仓库的资料模型通常是关系型的，因为 SQL 通常很适合分析查询。有许多图形资料分析工具可以生成 SQL 查询，视觉化结果，并允许分析人员探索资料（透过下钻、切片和切块等操作）。
表面上，一个数据仓库和一个关系型 OLTP 资料库看起来很相似，因为它们都有一个 SQL 查询介面。然而，系统的内部看起来可能完全不同，因为它们针对非常不同的查询模式进行了最佳化。现在许多资料库供应商都只是重点支援事务处理负载和分析工作负载这两者中的一个，而不是都支援。
一些资料库（例如 Microsoft SQL Server 和 SAP HANA）支援在同一产品中进行事务处理和资料仓库。但是，它们也正日益发展为两套独立的储存和查询引擎，只是这些引擎正好可以透过一个通用的 SQL 介面访问【49,50,51】。
Teradata、Vertica、SAP HANA 和 ParAccel 等资料仓库供应商通常使用昂贵的商业许可证销售他们的系统。Amazon RedShift 是 ParAccel 的托管版本。最近，大量的开源 SQL-on-Hadoop 专案已经出现，它们还很年轻，但是正在与商业资料仓库系统竞争，包括 Apache Hive、Spark SQL、Cloudera Impala、Facebook Presto、Apache Tajo 和 Apache Drill【52,53】。其中一些基于了谷歌 Dremel 的想法【54】。
### 星型和雪花型：分析的模式
正如 [第二章](ch2.md) 所探讨的，根据应用程式的需要，在事务处理领域中使用了大量不同的资料模型。另一方面，在分析型业务中，资料模型的多样性则少得多。许多资料仓库都以相当公式化的方式使用，被称为星型模式（也称为维度建模【55】）。
[图 3-9](../img/fig3-9.png) 中的示例模式显示了可能在食品零售商处找到的资料仓库。在模式的中心是一个所谓的事实表（在这个例子中，它被称为 `fact_sales`）。事实表的每一行代表在特定时间发生的事件（这里，每一行代表客户购买的产品）。如果我们分析的是网站流量而不是零售量，则每行可能代表一个使用者的页面浏览或点选。
![](../img/fig3-9.png)
**图 3-9 用于资料仓库的星型模式的示例**
通常情况下，事实被视为单独的事件，因为这样可以在以后分析中获得最大的灵活性。但是，这意味著事实表可以变得非常大。像苹果、沃尔玛或 eBay 这样的大企业在其资料仓库中可能有几十 PB 的交易历史，其中大部分储存在事实表中【56】。
事实表中的一些列是属性，例如产品销售的价格和从供应商那里购买的成本（可以用来计算利润率）。事实表中的其他列是对其他表（称为维度表）的外来键引用。由于事实表中的每一行都表示一个事件，因此这些维度代表事件发生的物件、内容、地点、时间、方式和原因。
例如，在 [图 3-9](../img/fig3-9.png) 中，其中一个维度是已售出的产品。`dim_product` 表中的每一行代表一种待售产品，包括库存单位（SKU）、产品描述、品牌名称、类别、脂肪含量、包装尺寸等。`fact_sales` 表中的每一行都使用外来键表明在特定交易中销售了什么产品。（简单起见，如果客户一次购买了几种不同的产品，则它们在事实表中被表示为单独的行）。
甚至日期和时间也通常使用维度表来表示，因为这允许对日期的附加资讯（诸如公共假期）进行编码，从而允许区分假期和非假期的销售查询。
“星型模式” 这个名字来源于这样一个事实，即当我们对表之间的关系进行视觉化时，事实表在中间，被维度表包围；与这些表的连线就像星星的光芒。
这个模板的变体被称为雪花模式，其中维度被进一步分解为子维度。例如，品牌和产品类别可能有单独的表格，并且 `dim_product` 表格中的每一行都可以将品牌和类别作为外来键引用，而不是将它们作为字串储存在 `dim_product` 表格中。雪花模式比星形模式更规范化，但是星形模式通常是首选，因为分析师使用它更简单【55】。
在典型的资料仓库中，表格通常非常宽：事实表通常有 100 列以上，有时甚至有数百列【51】。维度表也可以是非常宽的，因为它们包括了所有可能与分析相关的元资料 —— 例如，`dim_store` 表可以包括在每个商店提供哪些服务的细节、它是否具有店内面包房、店面面积、商店第一次开张的日期、最近一次改造的时间、离最近的高速公路的距离等等。
## 列式储存
如果事实表中有万亿行和数 PB 的资料，那么高效地储存和查询它们就成为一个具有挑战性的问题。维度表通常要小得多（数百万行），所以在本节中我们将主要关注事实表的储存。
尽管事实表通常超过 100 列，但典型的资料仓库查询一次只会访问其中 4 个或 5 个列（ “`SELECT *`” 查询很少用于分析）【51】。以 [例 3-1]() 中的查询为例：它访问了大量的行（在 2013 年中所有购买了水果或糖果的记录），但只需访问 `fact_sales` 表的三列：`date_key, product_sk, quantity`。该查询忽略了所有其他的列。
**例 3-1 分析人们是否更倾向于在一周的某一天购买新鲜水果或糖果**
```sql
SELECT
  dim_date.weekday,
  dim_product.category,
  SUM(fact_sales.quantity) AS quantity_sold
FROM fact_sales
  JOIN dim_date ON fact_sales.date_key = dim_date.date_key
  JOIN dim_product ON fact_sales.product_sk = dim_product.product_sk
WHERE
  dim_date.year = 2013 AND
  dim_product.category IN ('Fresh fruit', 'Candy')
GROUP BY
  dim_date.weekday, dim_product.category;
```
我们如何有效地执行这个查询？
在大多数 OLTP 资料库中，储存都是以面向行的方式进行布局的：表格的一行中的所有值都相邻储存。文件资料库也是相似的：整个文件通常储存为一个连续的位元组序列。你可以在 [图 3-1](../img/fig3-1.png) 的 CSV 例子中看到这个。
为了处理像 [例 3-1]() 这样的查询，你可能在 `fact_sales.date_key`、`fact_sales.product_sk` 上有索引，它们告诉储存引擎在哪里查询特定日期或特定产品的所有销售情况。但是，面向行的储存引擎仍然需要将所有这些行（每个包含超过 100 个属性）从硬碟载入到记忆体中，解析它们，并过滤掉那些不符合要求的属性。这可能需要很长时间。