2.1.2 Pre-shared key (PSK). In the event that a PSK has been
established, a client and a server can begin communicating without
a DH exchange. This is potentially attractive for low-power envi-
ronments, however, without a DHE the connection loses perfect
forward secrecy (PFS). In a PSK handshake, the server authenticates
via a PSK.
2.1.3 PSK with DHE. By combining a PSK with DHE this mode
maintains PFS whilst limiting the number of expensive public key
operations that the server needs to perform.
2.1.4 Group renegotiation. It can be the case that the groups sent
by a client are not acceptable to the server. In this case, the server
may respond with a HelloRetryRequest message. This indicates
to the client which groups the server will accept, and provides the
client with the opportunity to respond with an appropriate key
share before returning to the main handshake.
Client
Server
Client
Server
ClientHello
KeyShare*
PSK
ServerHello
KeyShare*
PSK
EncryptedExtensions
Finished
Finished
[ApplicationData]
Figure 2: A PSK resumption handshake (Section 2.1.7)
2.1.5 New session ticket (NST). After a successful handshake,
the server can issue an NST at any time. These tickets create a
binding to a resumption-specific secret and can be used by the
client as PSKs in subsequent handshakes.
2.1.6 PSK binder. A PSK binder is a value that binds a PSK to the
handshake where the PSK is offered by a client in a ClientHello
message and, if the PSK was generated by a server in-band, to the
handshake where it was generated. A ClientHello can contain
multiple binders arranged in a list, where each binder is computed
over a hash of the ClientHello message (without the binder list
itself).
2.1.7
Session resumption and PSK. This handshake variant al-
lows a client to use a key established out-of-band (OOB) to start a
new session, or to use an NST established in a previous handshake
to resume the session. This avoids the use of expensive public-key
operations and in the case of a resumption, ties the security context
of the new connection to the original connection. Note that a server
may reject a resumption attempt made by a client, so the specifica-
tion recommends that the client supplies an additional (EC)DHE
key share with its PSK when trying to resume a session. Figure 2
depicts a PSK resumption handshake.
2.1.8 Zero round trip time (0-RTT). A client can use a PSK to
send application data in its first flight of messages, reducing the la-
tency of the connection. As noted in the TLS 1.3 draft specification,
this data is not protected against replay attacks. If the communicat-
ing entities wish to take advantage of the 0-RTT mechanism, they
should provide their own replay protection at the application layer.
A 0-RTT handshake is depicted in Figure 3.
2.1.9 Post-handshake client authentication. After a successful
handshake, the server can send a CertificateRequest message.
If the client responds with an acceptable certificate, then the server
ClientHello
KeyShare*
PSK
(ApplicationData)
ServerHello
KeyShare*
PSK
EncryptedExtensions
Finished
[ApplicationData]
Finished
[ApplicationData]
Figure 3: A 0-RTT handshake (Section 2.1.8)
might authenticate the client. However, because the specification
allows certificates to be rejected ‘silently’, the client cannot be sure
of its authentication status in general. We discuss this in greater
detail in Section 5.2.
2.1.10 Key update. After a successful handshake, either party
can request an application data key update. Because the read and
write keys for application data are independent, either party can
immediately update their write key after requesting a key update.
2.1.11 Key derivation. A TLS 1.3 handshake will generate a set
of keys on which both the client and server agree. The specification
defines a key schedule which uses the repeated application of an
HMAC-based key derivation function (HKDF) [34] to combine the
secret inputs with fixed labels so as to generate a set of independent
keys.
The key schedule has two secret inputs, the (EC)DHE and the
PSK. Depending on the handshake mode, either one or both of these
will be used. The key schedule also includes the transcript hash in
the key derivation. Because the transcript includes nonces, even if
the secret inputs are repeated, the generated keys are guaranteed
to be independent.
2.2 Stated goals and security properties
The TLS 1.3 handshake protocol is intended to negotiate crypto-
graphic keys via the mechanism of authenticated key exchange
(AKE). These keys can then be used by the record layer to provide
critical security guarantees, including confidentiality and integrity
of messages. As stated in Section 2.1, TLS 1.3 makes use of inde-
pendent keys to protect handshake messages and application data
messages: protection of the handshake messages starts with the
server’s EncryptedExtensions message, and in the majority of
handshake modes, protection of application data messages occurs
after the transmission of the server and client Finished messages,
respectively. In the case of a 0-RTT handshake, application data is
protected with a PSK as part of the client’s first flight of messages.
The TLS specification[46, Appendix E.1] lists eight properties
that the handshake protocol is required to satisfy:
1. Establishing the same session keys. Upon completion of
the handshake, the client and the server should have estab-
lished a set of session keys on which they both agree.
Secrecy of the session keys. Upon completion of the hand-
shake, the client and server should have established a set of
session keys which are known to the client and the server
only.
2.
3. Peer authentication. In the unilateral case, upon comple-
tion of the handshake, if a client C believes it is communicat-
ing with a server S, then it is indeed S who is indeed executing
the server role. An analogous property for the server holds
in the bilateral (mutual) authentication case.
4. Uniqueness of session keys. Each run of the protocol should
produce distinct, independent session keys.
5. Downgrade protection. An active attacker should not be
able to force the client and the server to employ weak cipher
suites, or older versions of the TLS protocol.
6. Perfect Forward Secrecy (PFS). In the case of compromise
of either party’s long-term key, sessions completed before
the compromise should remain secure. This property is not
claimed to hold in the PSK key exchange mode.
7. Key compromise impersonation (KCI) resistance. Should
an attacker compromise the long-term key of party A, the
attacker should not be able to use this key to impersonate an
uncompromised party in communication with A.
8. Protection of endpoint identities. The identity of the server
cannot be revealed by a passive attacker that observes the
handshake, and the identity of the client cannot be revealed
even by an active attacker that is capable of tampering with
the communication.
We model six out of the eight required properties, omitting down-
grade protection and the protection of endpoint identities. Also, as
stated previously, 0-RTT mechanisms allow for replay of early data
across sessions. We discuss the reduced 0-RTT security properties
as well as the properties described above more fully in Section 4.
The draft specification refers to RFC 3552[47] for an informal
description of the TLS 1.3 threat model. This model assumes a Dolev-
Yao attacker[23]– an attacker that can perform man-in-the-middle
(MITM) attacks by being able to replay, insert, delete, and modify
messages at will. We consider a strictly more powerful attacker, as
we will explain in Section 4.1.
3 MODELLING THE PROTOCOL
3.1 The Tamarin prover
The Tamarin prover [48] is a symbolic modelling and analysis
tool for security protocols. Its specification language facilitates
the construction of highly detailed models of security protocols,
their security requirements and powerful Dolev-Yao-style attack-
ers. The verification algorithm of Tamarin is based on constraint
solving and multiset-rewriting techniques, which allows its users
to prove intricate security properties in complex protocols exhibit-
ing branches and loops. Moreover, it offers state-of-the-art sym-
bolic Diffie-Hellman support. Tamarin inherently supports non-
monotonic state and it includes an extensive graphical user inter-
face that enables the visualisation and interactive construction of
proofs.
These features make Tamarin a good fit for the modelling and
in-depth analysis of highly complex protocols such as TLS 1.3. In
particular, the support for branching allowed us to model the deci-
sions that the protocol participants can make during execution, the
loops were instrumental in covering repeated connections within a
single session, and the main security aspects of TLS 1.3 critically
depend on Diffie-Hellman key exchange. The non-monotonic state
support enabled us to model branching without having to resort
to custom-tailored hacks or having to rely on the considerable
over-approximation where all branches can be considered simul-
taneously. Lastly, the visualisations of attacks found by Tamarin
provided us with a way to quickly identify potential problems, with
either the protocol or our model– the graphical user interface was
a great asset in guiding our TLS 1.3 verification workflow.
We introduce the Tamarin specification language by considering
a toy example rule:
rule Example_Rule:
[ !Key(x,y), Fr(n) ]--[ Send(x,n,y) ]->[ Out(senc{n}y) ]
Tamarin rules consist of three respective parts: a left-hand side,
actions and a right-hand side. The rules are used to define a transition
system, whose global state is maintained as a multiset of so-called
facts. The initial state of the transition system is the empty multiset.
A rule can only be executed if all the facts on its left-hand side
are available in the current state. When a rule is executed, it will
consume the facts on the left, i.e. removing them from the global
state, and produce facts on the right, i.e. adding them to the global
state. Facts are either linear or persistent; each available linear fact
can only be consumed once, and persistent facts can be consumed
any number of times. Actions specify observable events in every
trace, and are used to express security properties. There are several
special facts, one of which is the Fr fact, which is implicitly available
in all states because of Tamarin’s built-in Fresh rule, and is used
to produce fresh (unique) values. In the above example, if an agent
x owns a symmetric key y, then it can send out a fresh value n that
is symmetrically encrypted with y. A basic property that states the
secrecy of n can be encoded as a simple lemma:
lemma Example_Property:
"All x y n #i. Send(x,n,y) @ i ==> not Ex #j. K(n) @ j"
A more realistic lemma needs to account for the attacker model.
For example, in the presence of an attacker who can compromise
symmetric keys, a formula resembling not Revealed(y) @ k needs
to be conjoined with the left-hand side of the above property or it
will be trivially false.
We defer the details of our Tamarin model to Section 4, and note
differences to other TLS 1.3 models in the next section.
3.2 A comprehensive model
Using Tamarin’s modelling framework we devised a comprehensive
symbolic model of TLS 1.3 that captures the specified protocol
behaviours, as well as unexpected behaviours that arise from a
complex interaction of an unbounded number of sessions. Our
model captures these behaviours in the presence of a powerful
attacker1.
Other TLS 1.3 analyses consider the constituent parts of TLS 1.3,
viewing these as separate protocols, and proceed to tie the indi-
vidual proofs together with a compositionality result. For instance,
[10] considers the resumption mechanism as a separate protocol
in which both the client and the server take as input a symmetric
value—the PSK. If the PSK remains unknown to the attacker in
every execution of the resumption protocol, a gap remains to be
filled before concluding that the full handshake always completes
without the attacker knowing the PSK. This gap is filled by a man-
ual compositionality proof. In our work, there is no need for such
manual proofs; composition is trivially satisfied by our comprehen-
sive model, as Tamarin considers all the possible interactions in
proving each property.
Although our model undoubtedly draws from the Tamarin mod-
els described in [30] and [22], we opted to model TLS 1.3 with a
significant increase in fidelity to the draft specification. Such an
approach resulted in an improved ability to capture the full func-
tionality of TLS, as well as a broader class of realistic attacks. This
class includes the coverage of complicated interaction attacks, such
as the post-handshake client authentication attack in [22]. Addi-
tionally, by closely matching our model to the specification and
allowing for an almost line-per-line comparison, we achieve full
transparency regarding which parts of the specification we abstract
away from, and which assumptions our modelling process relies on.
We discuss the relation between our model and the RFC in detail in
Section 6.
Not only is our model more comprehensive than the Tamarin
models that precede it, it also incorporates the many changes to
the TLS 1.3 specification that have materialised since the develop-
ment of these models. In the following sections, we describe our
modelling process, pointing out enhancements over the previous
models.
3.3 Closely modelling the specification
As with previous models [22], we employ the use of Tamarin rules
to model state transitions within the TLS 1.3 protocol. However,
our state transitions are far more fine-grained and modular in com-
parison to [22], modelling the effective change in state as a result
of transmission, receipt and processing of cryptographic parame-
ters. For instance, a basic, initial TLS 1.3 handshake invokes up to
21 different rules and the associated state transitions before post-
handshake operations can commence. These state transitions are
depicted in Figure 4, and correspond to message flights an crypto-
graphic processing as described in Section 2.1, Figure 1. The full
state diagram can be found in Appendix A.
Below we provide an example of one of our rules:
rule send:
[ SendStream(~tid, $actor, $peer, auth_status, app_key_out),
1We defer discussion of our attacker capabilities to Section 4.1.
Fr(~data)
]
--[ Send(~tid),
SendData(~tid, $actor, $peer, auth_status, ~data)
]->
[ SendStream(~tid, $actor, $peer, auth_status, app_key_out),
Out(senc{data_record(~data)}app_key_out)
]
We also note the extensive use of macros in our model, which is
enabled by the m4 preprocessor and allowed us to cover most of the
specification, whilst syntactically keeping our model close to it. For
example, our ClientHello message is a macro that expands to:
handshake_record('1',
ProtocolVersion,
ClientRandom,
'0', // legacy_session_id
$cipher_suites,
'0', // legacy_compression_methods
ClientHelloExtensions)
which reflects almost exactly how it is written in our Tamarin files.
ClientRandom is itself another macro, defined to be the value of
the client nonce nc. In Tamarin’s syntax, constants are enclosed
by single quotes. Constructing the model in this fashion enables a
direct syntactic comparison to the specification. Previous Tamarin
models also employ macros, but the connection to the specification
is much less evident. For instance, in [22] ClientHello is defined
to be the pair of values nc,pc, representing the client’s nonce and
“parameters”, which serves as a placeholder for handshake values
that are abstracted away.
In our model we have tried to define cryptographic components
in a way that is reminiscent of imperative programming. As in
the specification, we compute the handshake secret by computing
the function HKDF-Extract(gxy,es), and the handshake keys are