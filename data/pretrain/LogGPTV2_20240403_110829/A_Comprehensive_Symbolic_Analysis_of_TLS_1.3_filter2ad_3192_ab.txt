### 2.1.2 Pre-Shared Key (PSK)
When a Pre-Shared Key (PSK) has been established, a client and a server can initiate communication without performing a Diffie-Hellman (DH) key exchange. This is particularly advantageous in low-power environments. However, the absence of a DH exchange means that the connection loses Perfect Forward Secrecy (PFS). In a PSK handshake, the server authenticates using the PSK.

### 2.1.3 PSK with DHE
By combining a PSK with a Diffie-Hellman Ephemeral (DHE) key exchange, this mode maintains PFS while reducing the number of expensive public key operations that the server needs to perform.

### 2.1.4 Group Renegotiation
If the groups proposed by the client are not acceptable to the server, the server may respond with a `HelloRetryRequest` message. This message indicates to the client which groups the server will accept, allowing the client to respond with an appropriate key share before resuming the main handshake.

### 2.1.5 New Session Ticket (NST)
After a successful handshake, the server can issue a New Session Ticket (NST) at any time. These tickets create a binding to a resumption-specific secret and can be used by the client as PSKs in subsequent handshakes.

### 2.1.6 PSK Binder
A PSK binder is a value that binds a PSK to the handshake where the PSK is offered by the client in a `ClientHello` message. If the PSK was generated by the server in-band, it is also bound to the handshake where it was generated. A `ClientHello` message can contain multiple binders, each computed over a hash of the `ClientHello` message (excluding the binder list itself).

### 2.1.7 Session Resumption and PSK
This handshake variant allows a client to use a key established out-of-band (OOB) to start a new session or to use an NST from a previous handshake to resume a session. This avoids the need for expensive public-key operations and, in the case of resumption, ties the security context of the new connection to the original connection. Note that a server may reject a resumption attempt made by a client. Therefore, the specification recommends that the client includes an additional (EC)DHE key share with its PSK when attempting to resume a session. Figure 2 illustrates a PSK resumption handshake.

### 2.1.8 Zero Round Trip Time (0-RTT)
A client can use a PSK to send application data in its first flight of messages, reducing the latency of the connection. As noted in the TLS 1.3 draft specification, this data is not protected against replay attacks. If the communicating entities wish to take advantage of the 0-RTT mechanism, they should provide their own replay protection at the application layer. Figure 3 depicts a 0-RTT handshake.

### 2.1.9 Post-Handshake Client Authentication
After a successful handshake, the server can send a `CertificateRequest` message. If the client responds with an acceptable certificate, the server may authenticate the client. However, because the specification allows certificates to be rejected "silently," the client cannot be certain of its authentication status. This is discussed in greater detail in Section 5.2.

### 2.1.10 Key Update
After a successful handshake, either party can request an update to the application data keys. Since the read and write keys for application data are independent, either party can immediately update their write key after requesting a key update.

### 2.1.11 Key Derivation
A TLS 1.3 handshake generates a set of keys on which both the client and server agree. The specification defines a key schedule that uses the repeated application of an HMAC-based key derivation function (HKDF) to combine the secret inputs with fixed labels, generating a set of independent keys. The key schedule has two secret inputs: the (EC)DHE and the PSK. Depending on the handshake mode, one or both of these inputs are used. The key schedule also includes the transcript hash in the key derivation. Because the transcript includes nonces, even if the secret inputs are repeated, the generated keys are guaranteed to be independent.

### 2.2 Stated Goals and Security Properties
The TLS 1.3 handshake protocol is designed to negotiate cryptographic keys via authenticated key exchange (AKE). These keys are then used by the record layer to provide critical security guarantees, including confidentiality and integrity of messages. As stated in Section 2.1, TLS 1.3 uses independent keys to protect handshake messages and application data messages. Protection of handshake messages starts with the server’s `EncryptedExtensions` message, and in most handshake modes, protection of application data messages occurs after the transmission of the server and client `Finished` messages. In a 0-RTT handshake, application data is protected with a PSK as part of the client’s first flight of messages.

The TLS specification [46, Appendix E.1] lists eight properties that the handshake protocol must satisfy:

1. **Establishing the same session keys**: Upon completion of the handshake, the client and server should have established a set of session keys on which they both agree.
2. **Secrecy of the session keys**: Upon completion of the handshake, the client and server should have established a set of session keys known only to them.
3. **Peer authentication**: In the unilateral case, upon completion of the handshake, if a client C believes it is communicating with a server S, then it is indeed S executing the server role. An analogous property holds for the server in the bilateral (mutual) authentication case.
4. **Uniqueness of session keys**: Each run of the protocol should produce distinct, independent session keys.
5. **Downgrade protection**: An active attacker should not be able to force the client and server to use weak cipher suites or older versions of the TLS protocol.
6. **Perfect Forward Secrecy (PFS)**: In the event of a compromise of either party’s long-term key, sessions completed before the compromise should remain secure. This property does not hold in the PSK key exchange mode.
7. **Key compromise impersonation (KCI) resistance**: If an attacker compromises the long-term key of party A, the attacker should not be able to use this key to impersonate an uncompromised party in communication with A.
8. **Protection of endpoint identities**: The identity of the server cannot be revealed by a passive attacker observing the handshake, and the identity of the client cannot be revealed even by an active attacker capable of tampering with the communication.

We model six out of the eight required properties, omitting downgrade protection and the protection of endpoint identities. Additionally, 0-RTT mechanisms allow for the replay of early data across sessions. We discuss the reduced 0-RTT security properties and the properties described above more fully in Section 4.

The draft specification refers to RFC 3552 [47] for an informal description of the TLS 1.3 threat model. This model assumes a Dolev-Yao attacker [23], who can perform man-in-the-middle (MITM) attacks by replaying, inserting, deleting, and modifying messages at will. We consider a strictly more powerful attacker, as we will explain in Section 4.1.

### 3.1 The Tamarin Prover
The Tamarin prover [48] is a symbolic modeling and analysis tool for security protocols. Its specification language facilitates the construction of highly detailed models of security protocols, their security requirements, and powerful Dolev-Yao-style attackers. Tamarin's verification algorithm is based on constraint solving and multiset-rewriting techniques, allowing users to prove intricate security properties in complex protocols exhibiting branches and loops. It also offers state-of-the-art symbolic Diffie-Hellman support, non-monotonic state, and an extensive graphical user interface for visualizing and interactively constructing proofs.

These features make Tamarin well-suited for modeling and in-depth analysis of highly complex protocols like TLS 1.3. Specifically, the support for branching allowed us to model the decisions that protocol participants can make during execution, and the loops were instrumental in covering repeated connections within a single session. The main security aspects of TLS 1.3 critically depend on Diffie-Hellman key exchange. The non-monotonic state support enabled us to model branching without resorting to custom-tailored hacks or relying on considerable over-approximation. The visualizations of attacks found by Tamarin provided a way to quickly identify potential problems, either with the protocol or our model, and the graphical user interface was a great asset in guiding our TLS 1.3 verification workflow.

We introduce the Tamarin specification language with a toy example rule:

```tamarin
rule Example_Rule:
[ !Key(x,y), Fr(n) ]--[ Send(x,n,y) ]->[ Out(senc{n}y) ]
```

Tamarin rules consist of three parts: a left-hand side, actions, and a right-hand side. The rules define a transition system whose global state is maintained as a multiset of facts. The initial state is the empty multiset. A rule can only be executed if all the facts on its left-hand side are available in the current state. When a rule is executed, it consumes the facts on the left, removing them from the global state, and produces facts on the right, adding them to the global state. Facts are either linear or persistent; each available linear fact can only be consumed once, and persistent facts can be consumed any number of times. Actions specify observable events in every trace and are used to express security properties. There are several special facts, such as the `Fr` fact, which is implicitly available in all states due to Tamarin’s built-in `Fresh` rule and is used to produce fresh (unique) values. In the example, if an agent `x` owns a symmetric key `y`, it can send out a fresh value `n` that is symmetrically encrypted with `y`. A basic property stating the secrecy of `n` can be encoded as a simple lemma:

```tamarin
lemma Example_Property:
"All x y n #i. Send(x,n,y) @ i ==> not Ex #j. K(n) @ j"
```

A more realistic lemma needs to account for the attacker model. For example, in the presence of an attacker who can compromise symmetric keys, a formula resembling `not Revealed(y) @ k` needs to be conjoined with the left-hand side of the above property, or it will be trivially false.

We defer the details of our Tamarin model to Section 4 and note differences to other TLS 1.3 models in the next section.

### 3.2 A Comprehensive Model
Using Tamarin’s modeling framework, we devised a comprehensive symbolic model of TLS 1.3 that captures the specified protocol behaviors and unexpected behaviors arising from a complex interaction of an unbounded number of sessions. Our model captures these behaviors in the presence of a powerful attacker.

Other TLS 1.3 analyses consider the constituent parts of TLS 1.3 as separate protocols and tie the individual proofs together with a compositionality result. For instance, [10] considers the resumption mechanism as a separate protocol where both the client and the server take as input a symmetric value—the PSK. If the PSK remains unknown to the attacker in every execution of the resumption protocol, a gap remains to be filled before concluding that the full handshake always completes without the attacker knowing the PSK. This gap is filled by a manual compositionality proof. In our work, there is no need for such manual proofs; composition is trivially satisfied by our comprehensive model, as Tamarin considers all possible interactions in proving each property.

Although our model draws from the Tamarin models described in [30] and [22], we opted to model TLS 1.3 with a significant increase in fidelity to the draft specification. This approach resulted in an improved ability to capture the full functionality of TLS and a broader class of realistic attacks, including complicated interaction attacks such as the post-handshake client authentication attack in [22]. By closely matching our model to the specification and allowing for an almost line-per-line comparison, we achieve full transparency regarding which parts of the specification we abstract away and which assumptions our modeling process relies on. We discuss the relation between our model and the RFC in detail in Section 6.

Our model is not only more comprehensive than the Tamarin models that precede it but also incorporates many changes to the TLS 1.3 specification that have materialized since the development of these models. In the following sections, we describe our modeling process, pointing out enhancements over the previous models.

### 3.3 Closely Modeling the Specification
As with previous models [22], we use Tamarin rules to model state transitions within the TLS 1.3 protocol. However, our state transitions are far more fine-grained and modular compared to [22], modeling the effective change in state resulting from the transmission, receipt, and processing of cryptographic parameters. For example, a basic, initial TLS 1.3 handshake invokes up to 21 different rules and associated state transitions before post-handshake operations can commence. These state transitions are depicted in Figure 4 and correspond to message flights and cryptographic processing as described in Section 2.1, Figure 1. The full state diagram can be found in Appendix A.

Below is an example of one of our rules:

```tamarin
rule send:
[ SendStream(~tid, $actor, $peer, auth_status, app_key_out),
  Fr(~data)
]
--[ Send(~tid),
    SendData(~tid, $actor, $peer, auth_status, ~data)
]->
[ SendStream(~tid, $actor, $peer, auth_status, app_key_out),
  Out(senc{data_record(~data)}app_key_out)
]
```

We also extensively use macros in our model, enabled by the m4 preprocessor, which allows us to cover most of the specification while keeping our model syntactically close to it. For example, our `ClientHello` message is a macro that expands to:

```tamarin
handshake_record('1',
  ProtocolVersion,
  ClientRandom,
  '0', // legacy_session_id
  $cipher_suites,
  '0', // legacy_compression_methods
  ClientHelloExtensions)
```

This reflects almost exactly how it is written in our Tamarin files. `ClientRandom` is another macro, defined as the value of the client nonce `nc`. In Tamarin’s syntax, constants are enclosed by single quotes. Constructing the model in this fashion enables a direct syntactic comparison to the specification. Previous Tamarin models also employ macros, but the connection to the specification is much less evident. For instance, in [22], `ClientHello` is defined as the pair of values `nc, pc`, representing the client’s nonce and "parameters," which serves as a placeholder for handshake values that are abstracted away.

In our model, we have tried to define cryptographic components in a way that is reminiscent of imperative programming. As in the specification, we compute the handshake secret by computing the function `HKDF-Extract(gxy, es)`, and the handshake keys are derived accordingly.