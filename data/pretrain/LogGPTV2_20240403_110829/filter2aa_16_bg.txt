初始化声明符表中的声明符包含被声明的标识符;声明说明符由一系列的类型和存储类 说明符组成。
声明说明符:
存储类说明符 声明说明符 opt 类型说明符 声明说明符 opt 类型限定符 声明说明符 opt
初姑化声明符表: 初始化声明符
初姑化声明符袁，初始化声明符 初始化声明符:
声明符
声明符 = 初值
声明符将在稍后部分讨论(参见 A.8.5 节)。声明符包含了被声明的名字。一个声明中必 须至少包含一个声明符，或者其类型说明符必须声明一个结构标记、一个联合标记或枚举的 成员。不允许空声明。
A.8.1               存储类说明符
存储类说明符如下所示: 存储类说明符:
auto register static extern typedef
有关存储类的意义，我们已在 A.4 节中讨论过。
说明符 auto 和 register 将声明的对象说明为自动存储类对象，这些对象仅可用在函 数中。这种声明也具有定义的作用，并将预留存储空间。带有 register 说明符的声明等价 于带有 auto 说明符的声明，所不同的是，前者暗示了声明的对象将被频繁地访问。只有很少 的对象被真正存放在寄存器中，并且只有特定类型才可以。该限制同具体的实现有关。但是， 如果一个对象被声明为  register，则将不能对它应用一元运算符&(显式应用或隐式应用都 不允许)。
说明:对声明为 register 但实际按照 auto 类型处理的对象的地址进行计算是非法的。 这是一个新增加的规则。
说明符 static 将声明的对象说明为静态存储类。这种对象可以用在函数内部或函数外 部。在函数内部，该说明符将引起存储空间的分配，具有定义的作用。有关该说明符在函数 外部的作用参见 A.11.2 节。
函数内部的 extern 声明表明，被声明的对象的存储空间定义在其它地方。有关该说明 符在函数外部的作用参见 A.11.2 节。
typedef 说明符并不会为对象预留存储空间。之所以将它称为存储类说明符，是为了语 法描述上的方便。我们将在 A.8.9 节中讨论它。
一个声明中最多只能有一个存储类说明符。如果没有指定存储类说明符，则将按照下列 规则进行:在函数内部声明的对象被认为是 auto 类型;在函数内部声明的函数被认为是 extern 类型;在函数外部声明的对象与函数将被认为是 static 类型，且具有外部连接。详 细信息参见 A.10 节和 A.11 节。
A.8.2              类型说明符
类型说明符的定义如下: 类型说明符:
void char short int long float double signed
unsigned
结构或联合说明符 枚举说明符 类型定义名
其中，long 和 short 这两个类型说明符中最多有一个可同时与 int 一起使用，并且，在这 种情况下省略关键字 int 的含义也是一样的。long 可与 double 一起使用。signed 和 unsigned 这两个类型说明符中最多有一个可同时与 int、int 的 short 或 long 形式、char 一起使用。signed 和 unsigned 可以单独使用，这种情况下默认为 int 类型。signed 说 明符对于强制 char 对象带符号位是非常有用的;其它整型也允许带 signed 声明，但这是
多余的。
除了上面这些情况之外，在一个声明中最多只能使用一个类型说明符。如果声明中没有 类型说明符，则默认为 int 类型。
类型也可以用限定符限定，以指定被声明对象的特殊属性。 类型限定符:
const volatile
类型限定符可与任何类型说明符一起使用。可以对 const 对象进行初始化，但在初始化
以后不能进行赋值。volatile 对象没有与实现无关的语义。
说明:const 和 volatile 属性是 ANSI 标准新增加的特性。const 用于声明可以存放 在只读存储器中的对象，并可能提高优化的可能性。volatile 用于强制某个实现屏蔽可能 的优化。倒如，对于具有内存映像输入/输出的机器，指向设备寄存器的指针可以声明为指 向 volatile 的指针，目的是防止编译器通过指针删除明显多余的引用。除了诊断显式尝试 修改 const 对象的情况外，编译器可能会忽略这些限定符。
A.8.3              结构和联合声明
结构是由不同类型的命名成员序列组成的对象。联合也是对象，在不同时刻，它包含多 个不同类型成员中的任意一个成员。结构和联合说明符具有相同的形式。
结构或联合说明符:
结构或联合标识符 opt {结构声明表}
结构或联合 标识符
结构或联合:
struct union
结构声明表是对结构或联合的成员进行声明的声明序列:
结构声明表
结构声明
结构声明表 结构声明 结构声明:
说明符限定符表 结构声明符表 说明符限定符表:
类型说明符 说明符限定符表 opt
类型限定符 说明符限定符表 opt
结构声明符表: 结构声明符
结构声明符表, 结构声明符 通常，结构声明符就是结构或联合成员的声明符。结构成员也可能由指定数目的比特位组成，
这种成员称为位字段，或仅称为字段，其长度由跟在声明符冒号之后的常量表达式指定。
结构声明符:
声明符
声明符 opt: 常量表达式 下列形式的类型说明符将其中的标识符声明为结构声明表指定的结构或联合的标记: 结构或联合标识符 {结构声明表}
在同一作用域或内层作用域中的后续声明中，可以在说明符中使用标记(而不使用结构声明 表)来引用同一类型，如下所示:
结构或联合 标识符 如果说明符中只有标记而无结构声明表，并且标记没有声明，则认为真为不完整类型。具有
不完整结构或联合类型的对象可在不需要对象大小的上下文中引用，比如，在声明中(不是
定义中)，它可用于说明一个指针或创建一个 typedef 类型，其余情况则不允许。在引用之 后，如果具有该标记的说明符再次出现并包含一个声明表，则该类型成为完整类型。即使是 在包含结构声明表的说明符中，在该结构声明表内声明的结构或联合类型也是不完整的，一 直到花括号“   }"终止该说明符时，声明的类型才成为完整类型。
结构中不能包含不完整类型的成员。因此，不能声明包含自身实例的结构或联合。但是， 除了可以命名结构或联合类型外，标记还可以用来定义自引用结构。由于可以声明指向不完 整类型的指针，所以，结构或联合可包含指向自身实例的指针。
下列形式的声明适用一个非常特殊的规则: 结构或联合 标识符，
这种形式的声明声明了一个结构或联合，但它没有声明表和声明符。即使该标识符是外 层作用域中已声明过的结构标记或联合的标记(参见 A.11.1 节)，该声明仍将使该标识符成为 当前作用域内一个新的不完整类型的结构标记或联合的标记。
说明:这是 ANSI 中一个新的比较难理解的规则。它旨在处理内层作用域中声明的相互递 归调用的结构，但这些结构的标记可能已在外层作用域中声明。
具有结构声明表而无标记的结构说明符或联合说明符用于创建一个惟一的类型，它只能 被它所在的声明直接引用。
成员和标记的名字不会相互冲突，也不会与普通变量冲突。一个成员名字不能在同一结
构或联合中出现两次，但相同的成员名字可用在不同的结构或联合中。
说明:在本书的第 1 版中，结构或联合的成员名与其父辈无关联。但是，在 ANSI 标准 制定前，这种关联在编译器中普遍存在。
除字段类型的成员外，结构成员或联合成员可以为任意对象类型。字段成员(它不需要 声明符，因此可以不命名)的类型为 int、unsigned int 或 signed int，并被解释为指 定长度(用二进制位表示)的整型对象，int 类型的字段是否看作为有符号数同具体的实现 有关。结构的相邻字段成员以某种力式(同具体的实现有关)存放在某些存储单元中(同具 体的实现有关)。如果某字段之后的另一字段无法全部存入已被前面的字段部分占用的存储单 元中，则它可能会被分割存放到多个存储单元中，或者是，存储单元中的剩余部分也可能被 填充。我们可以用宽度为 0 的无名字段来强制进行这种填充，从而使得下一字段从下一分配 单元的边界开始存储。
说明:在字段处理方面，ANSI 标准比第 1 版更依赖于具体的实现。如果要按照与实现相 关的方式存储字段，建议阅读一下该语言规则。作为一种可移植的方法，带字段的结构可用 来节省存储空间(代价是增加了指令空间和访问字段的时间)，同时，它还可以用来在位层次 上描述存储布局，但该方法不可移植，在这种情况下，必须了解本地实现的一些规则。
结构成员的地址值按它们声明的顺序递增。非字段类型的结构成员根据其类型在地址边 界上对齐，因此，在结构中可能存在无名空穴。若指向某一结构的指针被强制转换为指向该 结构第一个成员的指针类型，则结果将指向该结构的第一个成员。
联合可以被看作为结构，其所有成员起始偏移量都为 0，并且其大小足以容纳任何成员。 任一时刻它最多只能存储其中的一个成员。如果指向某一联合的指针被强制转换为指向一个 成员的指针类型，则结果将指向该成员。
如下所示是结构声明的一个简单例子:
struct tnode { char tword[20]; int count;
struct tnode *left; struct tnode *right;
}
该结构包含一个具有 20 个字符的数组、一个整数以及两个指向类似结构的指针。在给出 这样的声明后，下列说明:
struct tnode s, *sp;
将把 s 声明为给定类型的结构，把 sp 声明为指向给定类型的结构的指针。在这些声明的基础 上，表达式
sp•>count
引用 sp 指向的结构的 count 字段，而
s.left
则引用结构的左子树指针，表达式
s.right•>tword[0]
引用 s 右子树中 tword 成员的第一个字符。 通常情况下，我们无法检查联合的某一成员，除非已用该成员给联合赋值。但是，有一
个特殊的情况可以简化联合的使用:如果一个联合包含共享一个公共初始序列的多个结构，
并且该联合当前包含这些结构中的某一个，则允许引用这些结构中任一结构的公共初始部分。 例如，下面这段程序是合法的:
union {
struct {
int type;
} n; struct {
int type; int intnode;
} ni; struct {
int type;
float floatnode;
} nf;
} u;
...
u.nf.type = FLOAT; u.nf.floatnode = 3.14;
...
if (u.n.type == FLOAT)
... sin(u.nf.floatnode) ...
A.8.4             枚举
枚举类型是一种特殊的类型，它的值包含在一个命名的常量集合中。这些常量称为枚举 符。枚举说明符的形式借鉴了结构说明符和联合说明符的形式。
枚举说明符:
enum 标识符 opt {枚举符表} enum 标识符
枚举符表:
枚举符
枚举符表, 枚举符 枚举符:
标识符
标识符 = 常量表达式
枚举符表中的标识符声明为 int 类型的常量，它们可以用在常量可以出现的任何地方。 如果其中不包括带有=的枚举符，则相应常量值从 0 开始，且枚举常量值从左至右依次递增 1。 如果其中包括带有=的枚举符，则该枚举符的值由该表达式指定，其后的标识符的值从该值开 始依次递增。
同一作用域中的各枚举符的名字必须互不相同，也不能与普通变量名相同，但其值可以 相同。
枚举说明符中标识符的作用与结构说明符中结构标记的作用类似，它命名了一个特定的 枚举类型。除了不存在不完整枚举类型之外，枚举说明符在有无标记、有无枚举符表的情况 下的规则与结构或联合中相应的规则相同。无枚举符表的枚举说明符的标记必须指向作用域 中另一个具有枚举符表的说明符。
说明:相对于本书第 1 版，枚举类型是一个新概念，但它作为 C 语言的一部分已有好多 年了。
A.8.5          声明符
声明符的语法如下所示 声明符:
指针 opt 直接声明符 直接声明符
标识符
(声明符)
直接声明符 [常量表达式 opt] 直接声明符(形式参数类型表) 直接声明符(标识表 opt)
指针:
* 类型限定符表 opt
* 类型限定符表 opt 指针 类型限定符表
类型限定符
类型限定符表 类型限定符 声明符的结构与间接指针、函数及数组表达式的结构类似，结合性也相同。
A.8.6              声明符的含义
声明符表出现在类型说明符和存储类说明符序列之后。每个声明符声明一个帷一的主标 识符，该标识符是直接声明符产生式的第一个候选式。存储类说明符可直接作用于该标识符， 但其类型由声明符的形式决定。当声明符的标识符出现在与该声明符形式相同的表达式中时， 该声明符将被作为一个断言，其结果将产生一个指定类型的对象。
如果只考虑声明说明符(参见  A.8.2  节)的类型部分及特定的声明符，则声明可以表示为 “ T D"的形式，其中 T 代表类型，D 代表声明符。在不同形式的声明中，标识符的类型可用 这种形式来表述。
在声明 T D 中，如果 D 是一个不加任何限定的标识符，则该标识符的类型为 T。 在声明 T D 中，如果 D 的形式为:
(D1)
则 D1 中标识符的类型与 D 的类型相同。圆括号不改变类型，但可改变复杂声明符之间的结合。
1，指针声明符
在声明 T D 中，如果 D 具有下列形式:
* 类型限定符表 D1
且声明 T D1 中的标识符的类型为"类型修饰符 T"，则 D 中标识符的类型为"类型修饰符 类 型限定符表指向 T 的指针"。星号*后的限定符作用于指针本身，而不是作用于指针指向的对 象。
例如。考虑下列声明:
int *ap[];
其中，ap[]的作用等价于 D1，声明“  int ap[]"将把 ap 的类型声明为“  int 类型的数组"， 类型限定符表为空，且类型修饰符为“   ……的数组"。因此，该声明实际上将把 ap 声明为"指 向 int 类型的指针数组"类型。
我们来看另外一个例子。下列声明: