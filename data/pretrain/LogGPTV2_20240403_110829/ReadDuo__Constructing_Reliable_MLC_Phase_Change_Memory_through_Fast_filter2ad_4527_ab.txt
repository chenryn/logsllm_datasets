22
23
24
25
26
27
28
29
640
210
E=0 (No protection)
Scan in every S seconds and eliminate E or fewer errors
E=1
E=16
E=7
E=8
E=9
1.23E-02
7.09E-02
1.63E-01
2.81E-01
4.20E-01
5.65E-01
7.02E-01
8.18E-01
8.50E-01
9.03E-01
9.34E-05
2.56E-03
1.43E-02
4.44E-02
1.03E-01
2.03E-01
3.43E-01
5.11E-01
5.65E-01
6.79E-01
too small
1.81E-14
2.09E-11
2.51E-09
1.06E-07
2.52E-06
3.73E-05
3.78E-04
7.21E-04
2.68E-03
too small
1.78E-14
4.07E-13
8.98E-11
6.17E-09
2.25E-07
4.84E-06
6.86E-05
1.44E-04
6.59E-04
too small
too small
9.55E-15
2.88E-12
3.23E-10
1.80E-08
5.63E-07
1.12E-05
2.60E-05
1.46E-04
too small
too small
too small
too small
too small
too small
9.10E-15
3.33E-12
1.55E-11
3.80E-10
E=17
too small
too small
too small
too small
too small
too small
too small
2.92E-13
1.51E-12
4.61E-11
E=18
too small
too small
too small
too small
too small
too small
too small
1.06E-14
1.32E-13
4.42E-12
LERDRAM
(Target)
1.42E-14
2.84E-14
5.69E-14
1.14E-13
2.28E-13
4.55E-13
9.10E-13
1.82E-12
2.28E-12
3.64E-12
Table IV: The line error rate (LER) under different ECC code and scrub interval (using M-metric sensing)
Time S
(seconds)
21 − 26
27
28
29
210
211
212
213
214
E=0 (No protection)
Scan in every S seconds and eliminate E or fewer errors
E=1
E=2
E=3
E=4
E=5
too small
6.40E-06
3.84E-05
2.69E-04
9.85E-04
2.42E-03
4.78E-03
8.14E-03
1.26E-02
too small
2.04E-11
7.34E-10
3.60E-08
4.83E-07
2.91E-06
1.14E-05
3.31E-05
7.91E-05
too small
too small
3.33E-15
3.18E-12
1.58E-10
2.33E-09
1.80E-08
8.94E-08
3.31E-07
too small
too small
too small
too small
4.54E-14
1.38E-12
2.13E-11
1.80E-10
1.03E-09
too small
too small
too small
too small
7.11E-15
7.99E-15
2.99E-14
3.01E-13
2.58E-12
too small
too small
too small
too small
too small
too small
too small
too small
6.88E-15
E=6
too small
too small
too small
too small
too small
too small
too small
too small
1.67E-15
E>=7
too small
too small
too small
too small
too small
too small
too small
too small
too small
LERDRAM
(Target)
2.28E-13
4.55E-13
9.10E-13
1.82E-12
3.64E-12
7.28E-12
1.46E-11
2.91E-11
5.83E-11
Table V: The LER when choosing different W=1
R(...): R-sensing
M(...): M-sensing
R(BCH=8,S=8)
R(BCH=10,S=8)
M(BCH=8,S=640)
Probability of (ii)
LERDRAM
W=1
5.69E-14
5.69E-14
4.56E-12
3.59E-13
4.83E-14
too small
Probability of (iii)
LERDRAM
W=1
8.54E-14
9.1E-12
8.54E-14
1.7E-14
too small
6.84E-12
(ii) the probability of a memory line accumulating less than
W errors in the ﬁrst S-second interval while accumu-
lating more than (E-W) errors in the second S-second
interval is smaller than LERDRAM;
(iii) the probability of a memory line accumulating less
than W errors in the ﬁrst two S-second intervals while
accumulating more than E-W errors in the following
S-second interval is smaller than LERDRAM;
We next check these probabilities to set up the parameter
values for the baseline designs. Table III and Table IV sum-
marize the probabilities of (i) when adopting R-sensing and
M-sensing, respectively. From Table III, a R-sensing scheme
that adopts (BCH=8,S=8) can meet LERDRAM. In this scheme,
each memory line is attached with a BCH-8 code and is
scrubbed every 8s. This matches the observation in [26],
[2] that adopts BCH-8 code. M-sensing can meet LERDRAM
using (BCH=8,S=640). While the scrubbing interval for M-
sensing can be relaxed to 214 (16,384) seconds, we choose
S=640 for reasons that we will elaborate in the next section.
We then check the probabilities of (ii) and (iii) and sum-
marize the results for three selected E and S combinations
in Table V. Our study shows that W needs to be small for
R-sensing — a bigger W requires stronger BCH code than
those listed. From Table V, we ﬁnd that (BCH=8, S=8)
fails to match LERDRAM even using W=1. The implication
is, a scrubbing scheme that adopts (BCH=8, S=8) needs to
rewrite every line at scrubbing time no matter if the line
has a drift error. A scheme that adopts (BCH=10, S=8) can
relax it to skip rewriting if no error is found. A M-sensing
scheme is much safer, e.g., using (BCH=8,S=640,W=1) is
sufﬁcient to meet LERDRAM.
In this paper, we choose (BCH=8, S=8, W=1) for R-
metric based scrubbing and (BCH=8, S=640,W=1) for M-
metric based scrubbing. From above analysis, a reliable R-
sensing scheme needs either using W=0 (i.e., rewriting at
scrubbing time) or using (BCH=10,W=1). Both of which
tend to introduce larger overhead. We choose (BCH=8, S=8,
W=1) only for comparison purpose. For M-metric based
scrubbing, it is possible to relax W or S to further reduce
overhead. Given the large interval, we observe that
the
overhead is already low.
206
the
Comparing different mitigation schemes. Figure 3
studies
state-of-the-art drift mitigation schemes.
Scrubbing indicates the scheme that adopts R-sensing [2]
with (BCH=8,S=8,W=1). M-metric indicates the scheme
that adopts M-sensing with (BCH=8,S=640,W=1). TLC in-
dicates the scheme that adopts the TLC scheme [26].
TLC
Scrubbing
M-metric
d
e
z
i
l
a
m
r
o
N
1.4
1.2
1
0.8
0.6
0.4
0.2
0
Execution 
Time
Energy-D
Area
Figure 3: Comparing existing drift mitigation schemes.
As shown in the ﬁgure, Scrubbing and M-metric
introduce large performance degradation — scrubbing
wastes memory bandwidth on scrubbing and reduces mem-
ory availability; M-metric slows down each memory ac-
cess. TLC, while showing no performance degradation, show
large density penalty. In summary, mitigating resistance drift
in MLC PCM chips remains a challenging research topic.
In this paper, our design goal is to devise a drift resilient
solution that matches the reliability of MLC PCM with
that of DRAM, and achieve high performance, low energy
consumption, good memory density, and good chip lifetime
simultaneously, as shown in Table VI.
Table VI: The design goal of our proposed ReadDuo scheme
Performance
Energy Density
Endurance
Scrubbing
TLC
M-metric
ReadDuo
-
+
-
+
-
+
-
+
+
-
+
+
-
+
+
+
B. ReadDuo-Hybrid: a Simple Hybrid Integration of R-
Sensing and M-Sensing
Given that (i) R-sensing is faster than M-sensing but
requires a short 8s scrubbing interval, and (ii) M-sensing
can meet LERDRAM with a large 640s scrubbing interval, a
simple integration of both sensing approaches is to conduct
R-sensing ﬁrst and, if R-sensing fails due to resistance drift,
conducts M-sensing. This is referred to as simple hybrid
sensing, or ReadDuo-Hybrid. Intuitively, if most read oper-
ations ﬁnish with R-sensing, ReadDuo-Hybrid can achieve
performance close to that in R-metric only sensing, and, if
there are drift errors, M-sensing with (BCH=8,S=640,W=1)
helps to provide reliability guarantee.
Unfortunately, R-sensing is less reliable. As an example,
the data returned from R-sensing may contain more than 20
errors while, if sensing the same memory line at the same
207
time with M-metric, the returned data has only ﬁve errors. In
ReadDuo-Hybrid, we need to ensure the undetected errors,
i.e., those that cannot be detected by BCH-8, during R-
sensing can meet the reliability target LERDRAM.
We next elaborate the design details of ReadDuo-Hybrid.
In particular, we need to enhance W=1 to W=0 in order
to meet DRAM reliability, i.e., ReadDuo-Hybrid is a hy-
brid sensing that adopts (BCH=8,S=640,W=0) for M-metric
based scrubbing — each line is refreshed every 640s.
Decoupling error detection and error correction. BCH
code is an ECC code with Hamming distance d, which can