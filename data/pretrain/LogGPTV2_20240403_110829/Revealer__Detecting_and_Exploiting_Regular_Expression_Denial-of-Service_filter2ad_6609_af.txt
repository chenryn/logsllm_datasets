386
10
engines of other languages—JavaScript, Python, Ruby and PHP.
The results are listed in Table VI.
381 (84.67%) and 443 (98.44%) regexes caused a timeout on
Java 8 regex engine under 1,024 and 8,192 pumps, respectively.
Seven regexes took less than 10 seconds to match even with
65,536 pumps. Four of them (including the 2 special cases
mentioned in §VI-B) start with (?=^.{1,254}$), which limits
the maximum acceptable input length to 254. However, their
matching time could be more than 10 minutes when the number
of pumps was only 128 (and even when the attack string length
was only 128). The other three have strict limit on the repetition
of attack cores. For example, (\\dx\\.]{0,2}(?!\\n)){6,12}
requires the pattern to be matched for no more than 12
times, so longer inputs would not increase the matching time.
Their matching time was as high as 0.578, 0.622 and 6.711
seconds, respectively, which were still quite large for real-time
applications.
Most vulnerabilities REVEALER detected could also lead
to ReDoS on other engines. But up to 64 regexes did not cause
timeout on them even with a 65,536 pump limit for JavaScript,
Python and Ruby. This might be because these engines do not
support some features (e.g., only the Java 8 engine supports
possessive quantifiers among the four), or because the engines
work differently for some features (e.g., the ‘-’ character in
the set operation [\d-z] is treated as a literal in Java, but
as a range sign in JavaScript and Python). As we mentioned
in §II-B, PHP limits the number of backtracking searches to
prevent ReDoS. With 65,536 pumps, 286 (63.56%) of the 450
vulnerable regexes triggered PHP’s internal backtracking limit;
116 (25.78%) reached the stack limit. However, some vulnerable
regexes can still cause a 10-second timeout in PHP, i.e., 3 caused
timeouts with 8,192 pumps, and 10 caused timeouts with 65,536
pumps. These regexes are “Loop-after-Loop” cases, whose
backtracking behavior cannot be detected under PHP regex
engine’s current limit. Our results demonstrate that REVEALER
can also find ReDoS vulnerabilities in PHP programs.
E. Detecting Real-World Vulnerabilities
We have demonstrated that REVEALER is able to effectively
detect both known and unknown ReDoS vulnerabilities in a
benchmark dataset. In this section, we explore whether it can
also detect unknown vulnerabilities in real-world applications.
We extracted regexes from popular open-source projects for
vulnerability detection. Specifically, we searched on GitHub
for popular (with more than 600 stars) Python and JavaScript
projects that contain the keywords “editor”, “web app”, or
“database” in their description. These projects are likely to use
regexes. For Python, we downloaded 28 database, 13 editor, and
7 web app projects. For JavaScript, we downloaded 31 database,
65 editor, and 34 web app projects. We applied REVEALER to
regexes extracted from them with default settings.
1 var styfn = {};
2 styfn. applyFromString = function ( string ){
3 // vulnerable to "/*\t\t\t\t\t\t\t\t\t\t\t ... \t\t\t\t\
4
5
t\t"
var remaining = ’’ + string ;
remaining = remaining . replace (" [/][*](\ s|.) +?[*][/] "
, ’’);
Listing 1: A vulnerable regular expression in library cytoscape.
if hasattr ( _negotiate_value , ’regex ’):
1 def _negotiate_value ( response ):
2
3
4
5
else:
regex = _negotiate_value .regex
regex = re. compile (’(?:.* ,) *\s* Negotiate \s
*([^ ,]*) ,?’, re.I)
6
# vulnerable to ",,,,,,,,,,,,,,,,,,, ...
,,,,,,,,,,,,,,,,,,\b"
if authreq :
7
8
9
Listing
urllib2-kerberos and requests-kerberos.
2: A vulnerable
match_obj = regex. search ( authreq )
regular
expression
in
libraries
REVEALER detected 53 and 169 vulnerable regexes in
Python and JavaScript projects, respectively. We cross-validated
the vulnerabilities, and got 13 and 32 regexes in Python and
JavaScript projects that trigger a 10-second timeout with attack
strings no longer than 128, respectively. We discuss several
interesting cases next.
Branch in Loop vulnerability.
OmniDB (2.2K stars) is a
lightweight web application for database management. One
of its library cytoscape.js contains a vulnerable regex in the
code of core functions, as shown in Listing 1. An attacker could
provide a 128-character long attack string for the vulnerable
style function, which would take the OmniDB server more than 24
hours to perform the match. Other users of this web application
would therefore get affected.
The code snippet tries to remove comments from a style
string. However, this regex contains the vulnerable structure
“Branch in Loop”, in which branch \s and branch . both accept
a blank character, e.g., the TAB symbol \t. To mitigate the
vulnerability, we need to remove the overlapping parts of the
two branches. In this case, since . generally includes \s, we
can simply remove the latter branch.
Loop in Loop vulnerability.
hue (4.1K stars) is a pop-
ular open-source SQL query assistant for databases and
warehouses. It uses two libraries urllib2-kerberos and
requests-kerberos that both contain such a vulnerable regex
in the authentication handler, as shown in Listing 2. Since
requests-kerberos is a popular library which is also used by
other 600+ repositories, we also reported this vulnerability to
requests-kerberos. If an attacker send the attack string to
these two libraries for Kerberos HTTP negotiate authentication,
it is likely that such authentication would take a large amount
of time (more than 24 hours with a 128-character long attack
string), thus affects other users of the corresponding databases
and warehouses.
As shown, there is a “Loop in Loop” vulnerable structure,
i.e., (?:.*,)*, in which a sequence of ‘,’ can be matched
by both the outer and the inner loop. To solve the problem,
we can change either loop into a quantifier not supporting
backtracking. A quick fix is to use a possessive quantifier by
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1479
1 var d = "^[\ _$a -z][\ _$a -z0 -9]*(\[.*?\]) *(\.[\ _$a -z][\ _$a
-z0 -9]*\(\[.*?\]) *)*$"
2 // vulnerable to "_[._[]._[]._[]._[]._[]._[] ... ._[]._
[]\b"
3 e = ["true", "false"]; return {
4 D: [], Y: function (b) {
5
6
k = e. substring (d, j +
1); b.push(k); var n = " @ko_token_ " + (b. length
- 1) + "@",
e = e. substring (0, d) + n + e. substring (j + 1),
j = j - (k. length - n. length ), d = o
7
8
Listing 3: A vulnerable regular expression in library dropdownlist.
loops,
Specifically,
placing an extra ‘+’ after the original quantifier ‘*’, but since
possessive quantifier is not supported in Python, we can change
the structure to (?:.*,).
Loop after Loop vulnerability. kendo-ui-core (2.3K stars)
is a HTML5, jQuery-based widget library for building modern
web applications. The code in its dropdownlist library contains
a vulnerable regex, as shown in Listing 3. If the attacker is able
to pass a 128-character long attack string to the library, the
corresponding web application would hang for 71.92 seconds.
there is a “Loop after Loop” structure,
i.e., ‘.*?’ in (\[.*?\])* and
where two adjacent
(\.[\_$a-z][\_$a-z0-9]*(\[.*?\])*)*, both accept “._[]”.
For this kind of vulnerabilities, we need to separate the two
loops by another expression that does not accept “._[]” so that
these two loops will not be directly connected. Alternatively,
we can remove the overlapping parts in the two loops. For
example, we can modify ‘.*?’ to one that will not overlap
with the latter loop.
Responsible Disclosure. We are unable to notify the authors
of the 213 newly detected vulnerable regexes in §VI-B as the
dataset does not include the source of a regex. We did contact
the relevant developers about new vulnerabilities we detected
in §VI-E (including the above three) and are in the process of
obtaining new CVE IDs. At the time of writing, 6 developers
have confirmed and 2 have fixed the vulnerabilities.
VII. RELATED WORK
Empirical Study of Regular Expression. Bates et al. found
regular expressions could be exploited to bypass XSS filters
[1]. Champan et al. studied the usage of regular expressions in
Python [6]. Wang et al. measured the test coverage of regular
expressions in [36]. Rex solves regular expression constraints
using a symbolic representation [35]. EGRET and Reggae
generate test strings to help identify flawed regular expressions
[19, 20]. In [23] and [13], the authors investigated management
difficulties and the portability problem of regular expressions.
REVEALER specifically targets the problem of super-linear
matching complexity in regular expressions and is orthogonal
to these works.
Empirical Studies of ReDoS. ReDoS is found harmful in
many application scenarios. Smith et al. found catastrophic
backtracking being utilized to evade network intrusion detection
[31]. Davis et al. investigated the incidence of super-linear
regular expressions and claimed ReDoS as a common security
vulnerability [11]. Staicu et al. found ReDoS attacks could
compromise the availability of JavaScript-based web servers
[32]. These works are orthogonal to REVEALER, which focuses
on detecting and exploiting ReDoS vulnerabilities.
ReDoS Detection. Previous works have studied the detection
of ReDoS vulnerabilities. Berglund et al. proposed static
analysis methods to identify vulnerable regexes based on
a novel automaton model [3]. Sugiyama et al. measured
the complexity of regular expression matching by simulating
the matching using a tree transducer and analyzing the size
increase of the output tree [33]. Similarly, RXXR2 builds
search trees from regular expressions and characterizes the
exponential branching blowup in the tree as a symbol of super-
linear complexity [29]. These works focus on detecting regex
structures with an exponential matching complexity and would
miss the polynomial vulnerabilities. Weideman et al. [37]
and Rexploiter [38], however, can identify vulnerable NFA
patterns with exponential or polynomial complexity. But all
these static analysis methods support only a limited set of
extended features, and have high false positive because they
cannot verify the attack strings they generated. REVEALER
supports all extended features and reports only true positives
by verifying the vulnerabilities in dynamic analysis. ReScue is
a fuzz testing technique specifically optimized for ReDoS [30].
It generates the attack strings using a genetic algorithm, which
makes it less efficient than static analysis methods.
Several existing works for Algorithmic DoS detection can
also be extended to ReDoS, e.g., fuzzers like SlowFuzz [28],
HotFuzz [5], and hybrid approaches like Badger [25].
ReDoS Mitigation.
Several existing works proposed to
mitigate ReDoS vulnerabilities by modifying the structure
of regular expressions. Becchi et al. proposed to merge non-
equivalent states by labeling the transitions [2]. In [7], the
authors searched for variants of regular expressions with
better performance. Merwe et al. removed ambiguity from
regular expressions to mitigate algorithmic DoS vulnerabilities
[34]. Some other works proposed flexible resource allocation
methods to limit the impact of ReDoS attacks. Lin et al. used
hierarchical parallel methods on GPU to accelerate regular
expression matching [21]. DeDoS mitigates asymmetric DoS
attacks by deploying the program in a replicable fusion [14].
Davis et al. incorporated timeouts at the event handler level
to mitigate ReDoS [12]. They also proposed to dynamically
allocate memory to cope with extreme situations in [10]. We aim
to detect ReDoS vulnerabilities and provide useful information
to help developers mitigate ReDoS.
VIII. CONCLUSION
Regular expression Denial-of-Service (ReDoS) attacks can
severely degrade the performance and availability of an applica-
tion and its hosting server. In this paper, we present REVEALER,
which is a hybrid-approach system that automatically detects
and exploits ReDoS vulnerabilities. We statically model the
ReDoS vulnerabilities for regular expressions with extended
features such that REVEALER can locate the vulnerable subex-
pressions of a regex. REVEALER then dynamically simulates
regex matching to generate attack strings to trigger the worst
case matching of a potential vulnerable regex. We thoroughly
evaluated the effectiveness and efficiency of REVEALER on a
benchmark dataset and on real-world popular applications. We
demonstrated that REVEALER can significantly outperform the
state-of-the-art ReDoS detection tools, and can effectively and
efficiently detect unknown ReDoS vulnerabilities.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1480
ACKNOWLEDGMENT
The authors would like to thank Andrej Bogdanov, Siu On
Chan and the anonymous reviewers for their helpful feedback.
The work described in this paper was partly supported by a
grant from the Research Grants Council of the Hong Kong
Special Administrative Region, China (CUHK 14210219).
REFERENCES
[1] D. Bates, A. Barth, and C. Jackson. Regular expressions
considered harmful in client-side XSS filters. In Proceed-
ings of the 19th International World Wide Web Conference
(WWW), Raleigh, NC, Apr. 2010.
[2] M. Becchi and S. Cadambi. Memory-efficient regular
expression search using state merging. In Proceedings
of the 26th IEEE International Conference on Computer
Communications (INFOCOM), Barcelona, Spain, May
2007.
[3] M. Berglund, F. Drewes, and B. van der Merwe. An-
alyzing catastrophic backtracking behavior in practical
regular expression matching. Electronic Proceedings in
Theoretical Computer Science, 151:109–123, may 2014.
doi: 10.4204/eptcs.151.7. URL https://doi.org/10.4204%
2Feptcs.151.7.
[4] M. Berglund, W. Bester, and B. van der Merwe. For-
malising boost posix regular expression matching.
In
B. Fischer and T. Uustalu, editors, Theoretical Aspects of
Computing – ICTAC 2018, pages 99–115, Cham, 2018.
Springer International Publishing.
[5] W. Blair, A. Mambretti, S. Arshad, M. Weissbacher,
W. Robertson, E. Kirda, and M. Egele. HotFuzz:
Discovering algorithmic denial-of-service vulnerabilities
In Proceedings of the
through guided micro-fuzzing.
2020 Annual Network and Distributed System Security
Symposium (NDSS), San Diego, CA, Feb. 2020.
[6] C. Chapman and K. T. Stolee. Exploring regular expres-
sion usage and context in python. In Proceedings of the
25th International Symposium on Software Testing and
Analysis (ISSTA), Saarbrücken, Germany, July 2016.
[7] B. Cody-Kenny, M. Fenton, A. Ronayne, E. Considine,
T. McGuire, and M. O’Neill. A search for improved
performance in regular expressions. In Proceedings of
the Genetic and Evolutionary Computation Conference,
GECCO ’17, pages 1280–1287, New York, NY, USA,
2017. Association for Computing Machinery.
ISBN
9781450349208. doi: 10.1145/3071178.3071196. URL
https://doi.org/10.1145/3071178.3071196.
[8] S. A. Crosby and D. S. Wallach. Denial of service via
In Proceedings of the
algorithmic complexity attacks.
12th USENIX Security Symposium (Security), Washington,
DC, Aug. 2003.
[9] C. CÂMPEANU, K. SALOMAA, and S. YU. A formal