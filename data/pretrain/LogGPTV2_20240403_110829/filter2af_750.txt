最近做题遇到一些静态编译的elf，一般这种静态编译的程序函数都是成千上百个的，如果一个个看肯定头皮发麻，我们通常是挑重点抓大头来解题
但是作为一个强迫症，看着一堆没有符号的函数：subxxxx()真的是不爽，就在网上查了一波学习了一下遇到这种情况该如何把静态编译并且strip后的程序的符号给找回来
IDA中提供了一个东西做FLIRT：库文件快速识别与鉴定技术（Fast Library Identification and Recognition
Technology）
简单的说，这玩意，能通过一个静态链接库的签名文件，来快速识别被去符号的程序中的函数，从而为函数找到符号
那么怎么样操作呢？
首先你得有这个静态链接库的签名文件
IDA提供了一个生成签名文件的工具，在IDA的插件目录下一般能找到一个叫做flair70.zip的压缩包，里面放着各个版本的FLAIR解析器，win的，mac的，linux的都有（我用的是IDA
pro 7.0 ）
我这里测试的环境是，Ubuntu16.04虚拟机，因此我用的linux下的FLIRT，测试用例是我自己搞了一个c程序，静态编译成test
将这些文件拷到虚拟机中，和测试用例放一起，记得给他们赋予执行权限
一般来说，在linux下，库文件一般放在/usr/lib和/lib下，
就找一个叫libc.a的就我们要用的静态编译库了，然后把库也一起放在同个文件夹中，东西准备好以后就可以开始操作生成签名文件了
步骤如下
  1. 搞到用于静态编译的静态库。
  2. 用FLAIR解析器为该库创建一个pat文件。
  3. 用sigmake来处理生成的pat文件，并生成一个签名文件。
  4. 将生成的签名文件复制到IDA的/sig/pc目录中
  5. 在IDA中shift+F5，选择添加sig文件进行解析
**创建pat文件**
用这个命令就行了，以上说明5个被忽略了
**创建签名文件**
这里说明有11个冲突的，需要解决一下
sigmake会生成一个排斥文件以指导如何解决“冲突”，在文件夹中发现的test.exc就是排斥文件，打开看一下：
    ;--------- (delete these lines to allow sigmake to read this file)
    ; add '+' at the start of a line to select a module
    ; add '-' if you are not sure about the selection
    ; do nothing if you want to exclude all modules
    .....
这个文件中出现了一堆的冲突函数的选项，在签名添加+或者-，或者不理他
添加完以后，记得删除前面的；开头的行，再次执行上面的命令
直到不产生报错
这时我们就产生了sig文件，把它复制到IDA的/sig/pc目录中
接着在IDA中shift+F5，右击添加sig文件
可以看到这里通过这种方法识别出了61个函数，虽然不是很多，但说明还是有点用的
到这里了，就会有一个问题，难道我每次都要去生成sig才能这样搞吗？
这当然过于麻烦，因此早有大佬把各个平台各个版本的sig都放到github上面去了
我们只需要下载下来，导入就行了
这里放几个链接
但是又产生了一个问题，如何才能检测到程序用的是哪一个sig？  
在成千上万的sig文件中一个个试也太没效率了，这里我找到的方法目前就只有是用file命令和strings命令去找版本信息，从而挑选sig
不知道有没有一种插件或者脚本可以直接批量跑sig文件，测试出最佳的sig、、、如果有的话希望大佬告诉我  
这里我把各个版本的FLIRT解析器上传到附件
* * *
感谢M4X大佬，果然有一种叫做iscan的脚本可以匹配测试出最佳的sig  
另外，在看雪还发现其他几种恢复符号的方法，这里贴一下链接  