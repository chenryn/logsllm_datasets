!
#


*
"
"


"

*

%

Fig. 3: Average measures for various graph properties.
within 90 days (01/2016 - 04/2016) ‚Äîshowing that such sites
are increasingly utilized by cybercriminals.
Per-family distribution. Figure 2 shows the per-family
distribution of enticement in exploit kit malware infection.
Search engines and compromised sites consistently rank as the
top enticement strategies used by the currently popular exploit
kits. This similarity is attributed to the fact that exploit kit
authors often employ similar black-hat SEO schemes or they
could compromise similar set of vulnerable sites.
II-C. Insights on Graph Properties
Malware infection involves actors (i.e., various hosts) and
relations (e.g., request, response, download, redirect) that
link actors. Such a structure is essentially a (directed) graph.
Inspired by this inherent graph structure, we studied graph
properties of malware infection. A snapshot of our analysis is
shown in Figure 3 which shows the average measurement of
different graph properties. While the detailed insights from our
graph abstraction are presented in Sections III and IV, here
we brieÔ¨Çy summarize the graph properties we examined in our
dataset.
Basic Graph Properties. On average, infection graphs have
higher number of nodes and edges. In addition, infection graphs
tend to have higher diameter, degree, and volume.
Centrality. Except for load centrality, on average infection
graphs have lower degree-centrality, closeness-centrality, and
betweenness-centrality.
Connectedness. Due to high frequency of request-response
and redirection relations, infection graphs on aggregate tend to
have higher measures for degree-connectivity, neighbors, and
page-rank.
II-D. Insights on HTTP Header Properties
Infections standout. While HTTP headers are interesting for
pattern matching, in this work, we examine a more specialized
set of header elements relevant to payload-agnostic dynamics
analysis. Figure 4 captures the summary of our analysis on the
infection dataset. Overall, we notice a contrasting statistical

	
Fig. 4: Average counts for HTTP header elements.
distribution of infection traces in comparison to benign traces.
In particular, the average number of GET and POST requests,
redirection chains, and HTTP 40X response codes is visibly
higher (in some cases more than double) than the benign
counterparts. A typical infection has at least 2 chains of
redirection, while a typical infection-free trace has none. In
some infection traces, we noticed exceptionally long redirection
chains in some families of exploit kit infections (e.g., as long
as 30 in the Goon exploit kit). Exploit kits such as Angler,
Nuclear, and Neutrino are also known for their elaborate chains
of redirections (see the ‚ÄúNo. of Redirects‚Äù column in Table I).
Post-infection calling back attempts. In 708 of the 770
infection traces, we conÔ¨Årmed at least one attempt of ‚Äúcalling
back home‚Äù. In all of the cases, our analysis reveals that the
hosts (IP addresses) to which post-download requests were
initiated from the victim host have never been seen prior to or
during the download dynamics. We found this characteristic to
conÔ¨Årm our intuition behind analyzing the whole-spectrum of
malware infection to engineer effective features for detection.
III. WEB CONVERSATION GRAPH ANALYTICS
We now present our web conversation analytics focusing on
graph abstraction, construction, and annotations.
Overview. Figure 5 shows a high-level overview of DY-
NAMINER with two major stages, an OfÔ¨Çine Web Conversation
Analytics (Stage 1) and an On-the-Wire Malware Detection
(Stage 2). In stage 1, DYNAMINER analyzes web conversation
traces (PCAPs) to construct a WCG and performs analytics
on it. The result of the analytics is payload-agnostic features
that are used to train a classiÔ¨Åer. In stage 2, DYNAMINER
continually receives real-time HTTP request-response transac-
tions and infers clue(s) of infection. Whenever it Ô¨Ånds an
infection clue (e.g., a redirection chain above a threshold
followed by a download of a likely-malicious payload type),
it builds a potential infection WCG around the clue(s). The
constructed WCG is then passed to a feature extraction engine
to extract the WCG properties to be evaluated by the classiÔ¨Åer.
Finally, DYNAMINER gives a verdict (infection or benign)
on the WCG. If DYNAMINER deems a WCG infectious, the
corresponding session is terminated. For each WCG deemed
benign, DYNAMINER keeps monitoring it as it grows, until
the corresponding web session is terminated (usually by the
user) or the WCG stops to grow.
466
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:20:37 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 5: High-level overview of DYNAMINER.
III-A. Graph Abstraction
We now describe how we build WCGs as they make the
foundation of our analytics, learning, and detection. A WCG
is a directed graph that captures the interaction between a host
and one or more remote hosts. A node in the WCG represents
a unique host, which can be a victim host, a malicious host, or
a redirect intermediary host. A victim host is the one to which
malware payload is downloaded (and executed). Alternatively,
a victim host is also characterized by post-infection exÔ¨Åltration
to the attacker‚Äôs server. A node is designated malicious if there
is at least one download of malware payload from it to a
victim host. An intermediary redirect host is a host that does
nothing more than chaining hosts beginning from the victim
host. An edge from host Hi to host Hj could mean (i) Hi
sends a request (e.g., GET, POST) to Hj (ii) victim Hj receives
response from host Hi (which could be payload download) or
(iii) Hi is redirected to Hj.
Let us formally deÔ¨Åne our abstraction for the WCG. Suppose
that H denotes the set of all hosts in a WCG dataset, Rq denotes
the set of all requests, and Rs denotes the set of all responses,
and Rr denotes the set of all redirects. Then the WCG Gi for
a client Hi is deÔ¨Åned as Gi = (Œ¶i, Œ®i, Œ£i, Œ±, Œ≤) where:
‚Ä¢ Œ¶i ‚äÜ Rqi √ó Rqi denotes a set of directed edges that
‚Ä¢ Œ®i ‚äÜ Rsi √ó Rsi denotes a set of directed edges that
‚Ä¢ Œ£i ‚äÜ Rri √ó Rri denotes a set of directed edges that
correspond to redirection relations in which Hi participates.
‚Ä¢ Œ± denotes a set of attributes about nodes and may include
correspond to responses received by Hi.
correspond to requests initiated by Hi.
node type, IP address, and port number.
‚Ä¢ Œ≤ denotes a set of attributes about edges between nodes such
as protocol, payload details (e.g., type, size), timestamp,
and user-agent.
III-B. Graph Construction
Given an HTTP transaction stream, to construct a WCG we
Ô¨Årst extract unique hosts to populate the nodes. Next, we group
the HTTP transactions into conversations between pairs of hosts.
For each conversation pair, we identify one or more request,
response, or redirection edges. We then annotate the nodes
and the edges with relevant conversation attributes. Finally, we
leverage the source-destination information to connect nodes
467
via edges. The construction of the WCG begins by adding
what we refer to as origin node. An origin node is a special
node that indicates the enticement source. When the origin of
a web conversation is known, the origin node takes the name
of the referrer. Otherwise, it is marked ‚Äúempty‚Äù.
Real infection example. Figure 6 shows a simpliÔ¨Åed WCG
we constructed from an infection trace of the Angler exploit kit.
The ‚Äúbing.com‚Äù node is the referrer node which is the origin
that initiated to the malware site. Counting in the origin node,
the WCG has 8 nodes and 31 edges (not all are shown in the
graph). In the pre-download dynamics (blue dotted region), the
victim is redirected (via a search engine) to a compromised
site A which then leads it to B (an exploit kit landing page).
An iframe redirection in B then leads the victim to the exploit
kit server C that serves Flash exploits. The download dynamics
(red dotted oval) ends with a download of a Ô¨Çash Ô¨Åle from host
C. Finally, the post-download dynamics (purple dotted oval)
shows the malware contacting, via POST requests, remote hosts
D, E, and F. These three hosts point to 3 unique IP addresses
that serve the infamous CryptoWall ransomware. For the sake of
brevity, we have not shown all the attributes of nodes and edges
on the WCG in Figure 6. However, our approach annotates
nodes and edges of a WCG with attributes that we use for
computing features. In the following, we discuss annotation of
nodes, edges, and the WCG as a whole.
III-C. Graph Annotations
Node-Level: The nodes in the WCG are annotated with the
following attributes:
‚Ä¢ Basic attributes: These include hostname and IP address.
‚Ä¢ URIs per host: For each host, we count the unique number
of URIs that have the hostname (IP address) of a host.
‚Ä¢ Payload summary: This captures the count of different
payload types that originate from or received by a node.
The payload types include: known exploit types (e.g.,
*.jar, *.exe, *.pdf, *.xap, *.swf) and commonly exchanged
payloads (e.g., images, HTML, JavaScript code, compressed
Ô¨Åles, text Ô¨Åles). The summary also includes ransomware
exploit payloads. Since ransomware comes with variable Ô¨Åle
extensions, we match Ô¨Åle extensions in the web conversation
against 45 distinct Ô¨Åle extensions that we compiled from
industry reports on ransomware [10].
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:20:37 UTC from IEEE Xplore.  Restrictions apply. 
	

	!

bing.com
[1]:origin
victim
!




!!

	
 








!

[2]: req('GET',1, 'bing.com')
[3]: res( '200 OK', 'HTML', '110.9KB', '19:30:23')
[4]: req('GET', 5, 'A')
[5]: res('200 OK', 'HTML', '58B', '19:30:31')
[6]: req('GET',132, 'A')
[8]: req('GET',114, 'C')
[10]: req('GET',92, 'none')
[11]: res('200 OK', 'BINARY', '414KB', '19:30:56')
[7]: res('200 OK', 'HTML', '93KB', '19:30:40')
[9]: res('200 OK', 'SWF', '44.5KB', '19:30:44')
[12]: req('POST',28,  'None')
[13]: res('200 OK', 'TXT', '5B', '19:31:12')
[14]: req('POST',28, 'None')
[15]: res('404 ', 'HTML', '35.9KB', '19:31:33')
[16]: req('POST', 28, 'None')
[18]: req('POST', 26, 'None')
[20]: req('POST', 26, 'None')
A
B
C
	

	!

D
E
	

	!

[17]: res('200 OK', 'TXT', '14B', '19:31:44')
F
[19]: res('200 OK', 'HTML', '120.5KB', '19:32:18')
[21]: res('200 OK', 'TXT', '6B', '19:32:59')
Fig. 6: Example WCG (Angler exploit kit captured on 12/21/2015). For ‚Äúreq‚Äù edges, the attributes shown are respectively: HTTP method,
URI length, and referrer. We excluded the exact URI in requests to maximize the readability of the graph. For ‚Äúres‚Äù edges, the attributes are
respectively: HTTP response code, payload type, payload size in bytes, and timestamp. The victim‚Äôs user agent is MSIE8.0 on Windows 7.
Edge-Level: The edges in the WCGs are annotated with the
following properties:
‚Ä¢ Timestamp: the time at which the event represented by the
edge happens.
‚Ä¢ Conversation stage: this property is assigned 0 for an
edge that appears in pre-download stage, 1 for an edge in
download stage, and 2 for edges in post-download stage. To
determine the stage of an edge, we take a request-response
pair and reason over a combination of: timestamp, HTTP
method, response codes. For instance, if a request uses GET
as a method, no known exploit payload is downloaded to
a victim client prior to that, and the response code is 30x,
then we assign the request-response pair to a pre-download
stage. All the remaining request-response pairs are assigned
to download stage after correlating their timestamp for
inconsistencies. Note that the last 30x response code is the
end of the pre-download stage and the beginning of the
payload download stage. With the same token, the last 20x
response whose content type is one of the known exploit
payloads is considered the end of the payload download
stage. For request-response pairs that use POST as a method
to contact nodes from which no known exploit payload is
downloaded, and the response code is either 200 or 40x,
we assign them to a post-download stage.
‚Ä¢ HTTP method: This captures which HTTP method is used
in a request edge.
‚Ä¢ URI length: The URI length of a request edge.
‚Ä¢ Response code: The HTTP response code of a response
edge.
‚Ä¢ Payload Ô¨Åle type: The payload type of a response edge.
‚Ä¢ Payload size: The payload size in bytes of a response edge.
Graph-Level: In addition to node and edge attributes, we
also compute aggregate properties that we use as foundations
of features for classifying infectious WCGs. The following are
annotations we add to a WCG.
‚Ä¢ Do not track: It is assigned 1 if the ‚ÄúDNT‚Äù property is
enabled. Otherwise, it is assigned 0.
‚Ä¢ X-Flash version: If version of ‚ÄúX-Flash‚Äù is set, we capture
its value. Otherwise, it is assigned 0.
‚Ä¢ Average payload counts: The graph-level count of different
payload types.
sizes in bytes.
‚Ä¢ Average payload sizes: The graph-level measure of payload
‚Ä¢ Total methods for requests: The total count of GET, POST,
and other request methods in the graph.
‚Ä¢ Total referrers: The graph-level total count of requests for
468
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:20:37 UTC from IEEE Xplore.  Restrictions apply. 
which referrer is set.
‚Ä¢ Cross-domain redirection: The count of redirections that
happen between two different origins.
‚Ä¢ Redirection length: The number of unique hops involved
‚Ä¢ TLD diversity: The number of unique top-level domains
in a redirection chain.
involved in redirection.
‚Ä¢ Graph dynamics: The graph-level properties including
order, size, degree, density, volume, different measures
of centrality and connectivity, neighborhood dynamics, and
clustering coefÔ¨Åcient.
‚Ä¢ Conversation duration: The total duration in seconds of
the conversation in the graph.
‚Ä¢ Average inter-transaction time: this captures the average
inter-arrival time of HTTP transactions in the graph.
‚Ä¢ Average delay between successive redirects: this captures an
estimate of the average time spent between two successive
redirections. This property is useful in identifying infectious
redirections from benign redirections since infections tend
to have shorter delays between consecutive redirects.
III-D. Notes on Heuristics and Global Properties
Heuristics. In order to comprehensively capture behavior
and relations in WCGs, we employ a number of heuristics.
We infer pre-download redirections primarily from referrer and
redirection header values of the HTTP transactions. However,
redirection evidence is often embedded in obfuscated HTML
or Javascript. We reverse engineer obfuscated JavaScript and
HTML code to mine evidence the enriches redirection chains
that the WCG follows before the Ô¨Årst download event. Although
we capture the pre-download dynamics in order to capture
how redirection plays out, our observation suggests that, in
some cases, one can Ô¨Ånd redirection chains in WCGs after
downloads happen. In particular, while infectious WCGs
perform redirections before dropping an exploit payload, we
noticed instances of benign WCGs where redirections happen
even after downloading a payload (e.g., when clicking on
ad banners). For such cases, our pre-download redirection
inference method is modiÔ¨Åed such that we take the sum of all
redirections in a WCG.
Global properties. From the analytics on our ground truth
dataset, we found out that there are 10 nodes on average per
malware infection graph with a minimum of 2 nodes and a
maximum of 404 nodes. The range of edges is between 2 and
1778 edges, with an average of 46 edges. As for lifetime, the
graphs have an average lifetime of 123 seconds with a range
between 0.5 and 4061 seconds.
closely related work ([9, 12, 16, 25]). While the descriptions
in Table II are self-explanatory, in the rest of this section we
provide more context on graph properties and HTTP header
features. Note that the reference dataset for all the distributions
we present in this section is the ground truth data in Table I.
IV-A. Graph Features (f7 - f25)
Our focus on graph dynamics is motivated by the downloader
graph analytics in [12] and redirection graph analysis in [25].
While [12] also uses diameter, density, and clustering coefÔ¨Åcient
of downloader graphs, our WCG abstraction semantically
differs from [12] in three respects. Firstly, we use payload as
an edge attribute and the URL from which it is downloaded as
a node. Differently from our technique, [12] uses a downloaded
executable as a node and the source URL as an edge. Secondly,
[12, 16] and [25], analyze downloader graph and redirection
graph respectively. In DYNAMINER, we rather combine the
download graph with the redirection graph. In addition, we also
include post-download graph dynamics whenever available. In
fact, our study conÔ¨Årmed that 92% of the infection WCGs
contain at least 1 post-download edge. Thirdly, we compute
and show the effectiveness of new graph features compared