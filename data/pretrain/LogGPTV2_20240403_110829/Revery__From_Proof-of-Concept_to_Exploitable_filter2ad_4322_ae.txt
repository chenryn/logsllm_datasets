NO
NO
NO
NO
NO
NO
NO
NO
NO
YES
YES
YES
YES
Table 2: Comparison with symbolic execution
6.4 Efficiency of Control-Flow Stitching
Given the candidate exploitable states, Revery utilizes a novel
control-flow stitching solution to generate inputs to trigger both the
vulnerability and exploitable states. In theory, symbolic execution
could be used solely to explore paths from the vulnerability point
to the exploitable states. To compare the efficiency between them,
we thus evaluated Revery and a strawman symbolic exuection tool
SYMBEX based on angr.
6.4.1 Overall Results. Table 2 shows the evaluation results on 14
programs which angr is able to handle. Revery could generate EXP
inputs to trigger exploitable states for all 14 programs in minutes.
But SYMBEX could only solve 4 of them. The exploitable points of
these 4 programs are right after the vulnerability points and before
the crashing points, and thus require no efforts to explore paths.
SYMBEX failed to solve the program main in four hours, and failed
for the rest 9 programs.
Path Reusing Rate. We use path reusing rate to assess the quality
of stitching points that Revery found. This rate is computed based
on the count of basic blocks reused from the diverging path, com-
pared to the count of basic blocks in the exploitation path. A higher
reusing rate indicates that the stitching point is better for exploit
generation. As shown in the table, more than half of the programs
has a path reusing rate higher than 60%.
Failure Analysis. SYMBEX failed for 9 programs. We pointed
out that, traditional symbolic execution is unable to infer some
exploitable state constraints and thus fails to generate exploits. As
discussed in Section 5, Revery could infer these constraints from the
diverging path. In the following, we take two programs babyheap
and marimo as examples.
Listing 1: Code fragment of babyheap
i = g e t _ i n t _ f r o m _ u s e r ( )
team = t e a m _ l i s t [ i ] ;
i f
team ) manage_team ( team ) ;
(
1
2
3
Example 1: babyheap. As shown in Listing 1, the target exploitable
state is in the function manage_team, which could only be triggered
if the the argument team is not NULL. But this value is retrieved
Figure 12: An CTF program Marimo. Data constraints is essen-
tial for generating a heap overflow exploit.
using a symbolic index from the array team_list. Traditional sym-
bolic executions, e.g., SYMBEX, will concretize the symbolic index,
and in most cases will get a NULL pointer from the array. As a
result, it could not trigger the exploitable state.
Example 2: marimo. Figure 12 illustrates the vulnerability of
marimo. There is an overflow in the marimo-0 object, which cor-
rupts the object marimo-1. If and only if the object marimo-1 is
passed to edit_marimo function, the exploitable state could be trig-
gered. However, angr does not know the knowledge and gets a
random value from the solver.
On the other hand, Revery knows this knowledge from the
crashing path, and adds the extra constraint of the exploitable
state. So it could generate exploits successfully.
7 RELATED WORK
7.1 Automatic Exploit Generation
Revery aims at automatic exploit generation, which is still an
open challenge. A few number of solutions have been proposed.
7.1.1 AEG Based on Symbolic Execution. APEG [14] is the first
automated exploitation solution based on patch analysis. AEG [11]
develops a novel preconditioned symbolic execution and path pri-
oritization techniques to generate exploits at the source code level.
Mayhem [15], which is built based on the hybrid symbolic execu-
tion and memory index modeling techniques, can automatically
generate exploits at the binary level.
These solutions symbolically execute the whole program and are
not scalable in path exploration. Unlike Revery, they are unaware of
exploitable state constraints. Previous AEG solutions (such as [11])
could not solve the derivability problem. They usually only support
stack overflow (where exploitable point is the crashing point) and
format string (where exploitable point is the vulnerability point)
vulnerabilities, rather than heap-based vulnerabilities. Since the
exploitable points are in the crashing paths, no diverging paths are
explored by these solutions.
Moreover, they will concretize symbolic values in order to make
symbolic execution practical. For example, Mayhem proposes a pri-
oritized concretization solution. As aforementioned, concretization
could lead to non-exploitable states.
1.  puts(“Select number or [B]ack”);2.  printf(“>>”);3.  scnaf(“%c”,&tmp)4.  index = tmp-0x30;5.  edit_marimo(marimo_list[index])marimo-0 ptrmarimo_listmarimo-1 ptrmarimo-0marimo-10:1:(cid:17)(cid:69)(cid:86)(cid:86)(cid:75)(cid:72)(cid:68)(cid:83)Session 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada19257.1.2 AEG Based on Crash Analysis. Sean Heelan [20] makes use of
dynamic taint analysis and program verification to generate control-
flow-hijack exploits based on the crashing PoC input. Similarly,
starting from the crashing point, CRAX [22] symbolically executes
the program to find exploitable states and automatically generates
working exploits at the binary level.
These solutions only search the crashing paths for exploitable
states. As aforementioned, exploitable states do not always exist in
crashing paths. So they will be hindered by the exploit derivability
issue. By contrast, Revery explores exploitable states not only in
crashing paths but also in diverging paths.
7.1.3 Data-Oriented AEG. FLOWSTITCH [21] automatically gen-
erates data-oriented exploits, able to reach information disclosure
and privilege escalation, by stitching multiple data flows without
breaking the control flow.
Although it also uses stitching, it is quite different from Revery.
First, it targets data-flow stitching, while the control-flow is intact,
making symbolic execution easier. Second, it only produces exploits
of data-only attacks, instead of control-flow hijacking attacks.
7.1.4 Other AEG Solutions. FUZE [40] is a novel framework to fa-
cilitate the process of kernel UAF exploitation. FUZE utilizes fuzzing
to find different dereference sites of the dangling pointer. By con-
trast, Revery utilizes layout-oriented fuzzing to explore diverging
paths and search exploitable states in them.
Ardilla [23] and Chainsaw [8] are AEG solutions for web applica-
tions. Ardilla can create SQL injection and cross-site scripting (XSS)
attacks automatically. Chainsaw is a system that reasons systemati-
cally over the navigation structure and uses the database state of
web applications to automatically generate working exploits. They
are quite different from AEG for binary applications, including
Revery.
7.2 Directed Fuzzing
Revery utilizes fuzzing to explore diverging paths. There are
many advances in this field in recent years.
7.2.1 Coverage-Guide Fuzzing. There are many works which aim
to increase code coverage of fuzz testing, called coverage-guide
fuzzing. AFL [41], libFuzzer [30], honggfuzz [38], AFLFast [13],
VUzzer [27] and CollAFL [18] are some state-of-the-art coverage-
guided fuzzers. In general, they prioritize the seeds with higher
code-coverage for further mutation. However, they do not target
specific code or memory states, and thus are not efficient in explor-
ing diverging paths which must satisfy some requirements.
7.2.2 Target-Directed Fuzzing. The most similar work to our focus
is AFLGo [12], a greybox fuzzing tool. AFLGo[12] prioritizes seeds
that are closer to a piece of predetermined target code, enabling
efficient directed fuzzing. In our solution, we are interested in seeds
that can trigger multiple layout-contributor instructions, rather
than one instruction. AFLGo is not effective in exploring diverging
paths which have multiple target points. Revery guides a fuzzer
with layout-contributor slice to explore diverging paths and search
for exploitable states efficiently.
7.3 Vulnerability Detection
Revery utilizes memory tagging to detect security violations.
There are many sanitizers [2, 28, 32, 36] proposed for this purpose.
For example, ASAN [32] pads objects with redzones and places
freed objects into quarantines, able to detect spatial and temporal
violations. Valgrind [7] replaces heap management functions with
self-modified implementations, which also use redzones to detect
memory safety violations. SoftBound [24] records base and bound
information for every pointer as disjoint metadata to enforce com-
pletely spatial memory safety for C programs. CETS [25] uses a
key and lock address with each pointer in a disjoint metadata space
and checks pointer dereferences to enforce temporal safety for C
programs.
All of these solutions will slightly change the memory layout
of target programs as a result of the instrumentation and thus are
not suitable for exploit generation. By contrast, Revery utilizes a
shadow memory to track the tags of pointers and the status of heap
objects non-intrusively.
8 DISCUSSION
AEG is an open challenge. Revery only moves one step towards
this goal. It has many challenges, including but not limited to:
• Advanced Defenses. More and more defenses are proposed
and deployed in practice, in order to stop popular attacks. These
defenses not only raise the bar for human attackers, but also
hinder automated solutions. For example, Revery could not by-
pass ASLR because it lacks the ability of information disclosure.
It could trigger exploitable states for 5 of 19 programs, but not
able to generate working defenses, because of the sanity checks
deployed in heap allocators.
• Heap Layout Massaging. A large number of heap-based vul-
nerabilities could only be exploited in specific memory layouts.
Due to the complexity of memory allocators and the program
behavior, it is very challenging to generate inputs to build mem-
ory layouts as expected.
• Combination of Multiple Vulnerabilities. In practice, a suc-
cessful exploit usually require multiple vulnerabilities. We have
to assemble different vulnerabilities and utilize their corruption
effects to craft a final exploit.
• Program Comprehension and Analysis. To successfully ex-
ploit a program, it is necessary to understand the program
behavior, e.g., what input will cause what output, and make dy-
namic decisions at runtime. In addition, few program analysis
solutions could extract such information. As aforementioned,
the widely used symbolic execution has many limitations too.
9 CONCLUSION
Existing AEG solutions are facing the challenges from exploit
derivability issue, symbolic execution bottleneck and heap-based
vulnerabilities. We proposed a solution Revery able to search ex-
ploitable states in diverging paths rather than crashing path, with
a novel layout-oriented fuzzing and a control-flow stitching solu-
tion. It could trigger both vulnerabilities and exploitable states for
a big portion of vulnerable applications. It could also successfully
generate working exploits for certain vulnerabilities. It has moved
one step towards practical AEG. But there is a long way to go.
Session 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1926ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers for their con-
structive comments. This work is supported by the Key Laboratory
of Network Assessment Technology, Chinese Academy of Sciences
and Beijing Key Laboratory of Network Security and Protection
Technology, as well as Beijing Municipal Science and Technology
Project (No.Z181100002718002), National Natural Science Foun-
dation of China (No. 61572481 and 61602470, 61772308, 61472209,
61502536, and U1736209), and Young Elite Scientists Sponsorship
Program by CAST (No. 2016QNRC001).
REFERENCES
[1] 2018. CTF TIME. https://ctftime.org. Online: accessed 01-May-2018.
[2] 2018. DataFlowSanitizer. https://clang.llvm.org/docs/DataFlowSanitizerDesign.
html. Online: accessed 01-May-2018.
[3] 2018.
!exploitable Crash Analyzer. http://msecdbg.codeplex.com/. Online:
accessed 01-May-2018.
[4] 2018. OSS-Fuzz: Five Months Later, and Rewarding Projects. https://testing.
googleblog.com/2017/05/oss-fuzz-five-months-later-and.html. Online: accessed
01-May-2018.
[5] 2018. Rex - Shellphish’s automated exploitation engine . https://github.com/
shellphish/rex. Online: accessed 01-May-2018.
[6] 2018. Unlink Exploit . https://heap-exploitation.dhavalkapil.com/attacks/unlink_
exploit.html. Online: accessed 01-May-2018.
[7] 2018. Valgrind. http://valgrind.org. Online: accessed 01-May-2018.
[8] Abeer Alhuzali, Birhanu Eshete, Rigel Gjomemo, and VN Venkatakrishnan. 2016.
Chainsaw: Chained automated workflow-based exploit generation. In Proceedings
of the 2016 ACM SIGSAC Conference on Computer and Communications Security.
ACM, 641–652.
[9] S. Andersen and V. Abella. 2004. Data Execution Prevention: Changes to Func-
tionality in Microsoft Windows XP Service Pack 2, Part 3: Memory Protection
Technologies. http://technet.microsoft.com/en-us/library/bb457155.aspx.
[10] Thanassis Avgerinos, Sang Kil Cha, Brent Lim, Tze Hao, and David Brumley.
2011. AEG: Automatic exploit generation. In Network and Distributed System
Security Symposium.
[11] Thanassis Avgerinos, Sang Kil Cha, Alexandre Rebert, Edward J Schwartz, Mav-
erick Woo, and David Brumley. 2014. Automatic exploit generation. Commun.
ACM 57, 2 (2014), 74–84.
[12] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen, and Abhik Roychoudhury.
2017. Directed greybox fuzzing. In Proceedings of the 2017 ACM SIGSAC Conference
on Computer and Communications Security. ACM, 2329–2344.
[13] Marcel Böhme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
based greybox fuzzing as markov chain. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security. ACM, 1032–1043.
[14] David Brumley, Pongsin Poosankam, Dawn Song, and Jiang Zheng. 2008. Auto-
matic Patch-Based Exploit Generation is Possible: Techniques and Implications.
In Proceedings of the 29th IEEE Symposium on Security & Privacy. Oakland, CA.
[15] Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. 2012.
Unleashing mayhem on binary code. In Security and Privacy (SP), 2012 IEEE
Symposium on. IEEE, 380–394.
[16] DA DARPA. 2014. Cyber grand challenge. Retrieved June 6 (2014), 2014.
[17] Thomas Dullien and Halvar Flake. 2011. Exploitation and state machines. Pro-
ceedings of Infiltrate (2011).
[18] S. Gan, C. Zhang, X. Qin, X. Tu, K. Li, Z. Pei, and Z. Chen. [n. d.]. CollAFL: Path
Sensitive Fuzzing. In 2018 IEEE Symposium on Security and Privacy (SP), Vol. 00.
660–677. https://doi.org/10.1109/SP.2018.00040
[19] Liang He, Yan Cai, Hong Hu, Purui Su, Zhenkai Liang, Yi Yang, Huafeng Huang,
Jia Yan, Xiangkun Jia, and Dengguo Feng. 2017. Automatically assessing crashes
from heap overflows. In Proceedings of the 32nd IEEE/ACM International Conference
on Automated Software Engineering. IEEE Press, 274–279.
[20] Sean Heelan. 2009. Automatic generation of control flow hijacking exploits for
software vulnerabilities. Ph.D. Dissertation. University of Oxford.
[21] Hong Hu, Zheng Leong Chua, Sendroiu Adrian, Prateek Saxena, and Zhenkai
Liang. 2015. Automatic Generation of Data-Oriented Exploits.. In USENIX Security
Symposium. 177–192.
[22] Shih-Kun Huang, Min-Hsiang Huang, Po-Yen Huang, Chung-Wei Lai, Han-Lin
Lu, and Wai-Meng Leong. 2012. Crax: Software crash analysis for automatic
exploit generation by modeling attacks as symbolic continuations. In Software
Security and Reliability (SERE), 2012 IEEE Sixth International Conference on. IEEE,
78–87.
[23] Adam Kieżun, Philip J. Guo, Karthick Jayaraman, and Michael D. Ernst. 2009.
Automatic creation of SQL injection and cross-site scripting attacks. In ICSE
2009, Proceedings of the 31st International Conference on Software Engineering.
Vancouver, BC, Canada, 199–209.
[24] Santosh Nagarakatte, Jianzhou Zhao, Milo M.K. Martin, and Steve Zdancewic.
2009. SoftBound: Highly Compatible and Complete Spatial Memory Safety for C.
In Intl. Conf. on Programming Language Design and Implem.
2010. CETS: Compiler Enforced Temporal Safety for C.
[25] Santosh Nagarakatte, Jianzhou Zhao, Milo M.K. Martin, and Steve Zdancewic.
[26] PaX-Team. 2003. PaX ASLR (Address Space Layout Randomization). http://pax.
grsecurity.net/docs/aslr.txt.
[27] Sanjay Rawat, Vivek Jain, Ashish Kumar, and Herbert Bos. 2017. VUzzer:
Application-aware Evolutionary Fuzzing. In Network and Distributed System
Security Symposium.
[28] Alexey Samsonov and Kostya Serebryany. 2013. New features in AddressSanitizer.
(2013).
[29] Edward J Schwartz, Thanassis Avgerinos, and David Brumley. 2011. Q: Exploit
[30] Kosta Serebryany. 2016. Continuous Fuzzing with libFuzzer and AddressSanitizer.
Hardening Made Easy.. In USENIX Security Symposium. 25–41.
In Cybersecurity Development (SecDev), IEEE. IEEE, 157–157.
open source software. (2017).
[31] Kostya Serebryany. 2017. OSS-Fuzz - Google’s continuous fuzzing service for
[32] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy
Vyukov. 2012. AddressSanitizer: A fast address sanity checker. In the 2012 USENIX
Annual Technical Conference. 309–318.
[33] Kostya Serebryany, Evgenii Stepanov, Aleksey Shlyapnikov, Vlad Tsyrklevich,
and Dmitry Vyukov. 2018. Memory Tagging and how it improves C/C++ memory
safety. CoRR abs/1802.09517 (2018). arXiv:1802.09517 http://arxiv.org/abs/1802.
09517
[34] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Andrew Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel,
et al. 2016. Sok:(state of) the art of war: Offensive techniques in binary analysis.
In Security and Privacy (SP), 2016 IEEE Symposium on. IEEE, 138–157.
[35] Alexander Sotirov. 2007. Heap feng shui in javascript. Black Hat Europe (2007).
[36] Evgeniy Stepanov and Konstantin Serebryany. 2015. MemorySanitizer: fast
detector of uninitialized memory use in C++. In Code Generation and Optimization
(CGO), 2015 IEEE/ACM International Symposium on. IEEE, 46–55.
[37] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution.. In
NDSS, Vol. 16. 1–16.
[38] Robert Swiecki. 2016. Honggfuzz. Available online a t: http://code. google.
com/p/honggfuzz (2016).
[39] Julien Vanegue. 2013. The automated exploitation grand challenge. In presented
at H2HC Conference.
[40] Wei Wu, Yueqi Chen, Jun Xu, Xinyu Xing, Xiaorui Gong, and Wei Zou. 2018.
FUZE: Towards Facilitating Exploit Generation for Kernel Use-After-Free Vul-
nerabilities. In 27th USENIX Security Symposium (USENIX Security 18). USENIX
Association.
[41] Michal Zalewski. 2018. American Fuzzy Lop. http://lcamtuf.coredump.cx/afl/.
Online: accessed 01-May-2018.
Session 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1927