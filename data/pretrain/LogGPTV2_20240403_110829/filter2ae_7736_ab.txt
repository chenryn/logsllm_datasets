    import sympy
    import gmpy2
    n=117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127
m是n/166的开放根，和p q 中的一个距离很近
    m=sympy.nextprime(842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458029)
    m2=842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458029*166
    k=m
    p=0
    q=0
    while (m>10000):
        if(n%m==0):
            \#print (m) A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x
根据方程可以直接算出x和y
    a=2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724
    x=1
    y=1
    n=0
    c=0
    d=0
    for x in range(1,100):
       for y in range(2,100):
           c=(y+1)/x
           d=x%y
           if(d!=0):
               n=(((y%x)**5)%d)**2019+y**316+c
           if(n==a):
                print (x)
                print (y)
    可得x=2 y=83
    p=next_prime(z*x*y)
    q=next_prime(z)
    n=q*p
因此可以猜测n和（z _x_ y） _z的值也是很接近的，也就是n和z^2_
166是很接近的，那么sqrt(n/166)和q是很接近的。所以从sqrt(n/166)附近查找prime。
e是未知的，但是e的取值范围相对是小的，直接猜或者爆破，结果可知e为65537.
解密脚本
    import sympy
    import math
    import binascii
    from Crypto.Util.number import long_to_bytes
    n=117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127
m即是sqrt(n/166)的近似值
    m=sympy.nextprime(842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458029)
    c=86974685960185109994565885227776590430584975317324687072143606337834618757975096133503732246558545817823508491829181296701578862445122140544748432956862934052663959903364809344666885925501943806009045214347928716791730159539675944914294533623047609564608561054087106518420308176681346465904692545308790901579479104745664756811301111441543090132246542129700485721093162972711529510721321996972649182594310700996042178757282311887765329548031672904349916667094862779984235732091664623511790424370705655016549911752412395937963400908229932716593592702387850259325784109798223415344586624970470351548381110529919234353
    p=0
    q=0
    \#从m附近查找q或p
    while(m>100):
        if(n%m==0):
            p=m
            print "p="
            print p
            q=n/p
            print "q=" 
            print q
            break
        m=sympy.nextprime(m)
    def egcd(a,b):
        if a==0:
            return (b,0,1)
        else:
            g,y,x=egcd(b%a,a)
            return (g,x-(b//a)*y,y)
    def modinv(a,m):
        g,x,y=egcd(a,m)
        if g!=1:
            raise Exception(" error")
        else:
            return x%m
    e=1
    d=0
爆破e
    while(e uint) public balances;
       uint public MinDeposit = 0.1 ether;
       Log TransferLog;
       event FLAG(string b64email, string slogan);
       constructor(address _log) public { 
           TransferLog = Log(_log);
         }
       function Ap() public {
           if(balances[msg.sender] == 0) {
               balances[msg.sender]+=1 ether;
           }
       }
       function Transfer(address to, uint val) public {
           if(val > balances[msg.sender]) {
               revert();
           }
           balances[to]+=val;
           balances[msg.sender]-=val;
       }
       function CaptureTheFlag(string b64email) public returns(bool){
         require (balances[msg.sender] > 500 ether);
         emit FLAG(b64email, "Congratulations to capture the flag!");
       }
       function Deposit()
       public
       payable
       {
           if(msg.value > MinDeposit)
           {
               balances[msg.sender]+= msg.value;
               TransferLog.AddMessage(msg.sender,msg.value,"Deposit");
           }
       }
       function CashOut(uint _am) public 
       {
           if(_am= uint)
       require(address3 == msg.sender + 0x32c3edb)
       balanceOf[address1] -= _value;
       balanceOf[address2] += _value;
       allowance[address1][msg.sender] -= _value;
然后在标准token的sol里面有一个函数：
    function approve(address _spender, uint256 _value) public returns (bool) {
       allowed[msg.sender][_spender] = _value;
       Approval(msg.sender, _spender, _value);
       return true;
     }
通过approve函数给allowance[msg.sender][msg.sender]赋值，随便大于1000的值就行。
然后调用0x5ad0ae39，这里就比较蛋疼了，因为爆破不出这个函数名，没法直接用remix做题，没办法只能写代码了。
过程如图：
* * *