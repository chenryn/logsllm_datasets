Android version
Fig. 3. Amount of source methods for bluetooth, location and NFC information
in different Android versions
loading and reﬂection, but still work on an unmodiﬁed stock
Android phone. We analyzed the malware samples for this
obfuscation technique but found no sample that actually tries
to obtain personal data through such methods. Furthermore, we
did also not ﬁnd methods for sinks which are not so well known
as shown in the motivating example (cf. Section II). However,
we expect such advanced techniques to become more prevalent
when security tools evolve, for instance by incorporating the
results of this paper, and thus more effectively detect the easier
cases.
D. RQ4: Changes during Android Versions
To assess how well SUSI can deal with previously unseen
versions of the Android operating system, we compared the
categorized source and sink lists generated for a selection
of different Android releases. Figure 3 shows the number
of sources found for API versions 4 (Android 1.6) to 18
(Android 4.3). We here focus on the bluetooth, location, and
NFC categories, as they nicely demonstrate how Android was
extended over the various versions. From the ﬁgure one can
clearly deduce that new sources are introduced with every
version. This is yet another motivation to use a tool-supported
approach like SUSI’s to discover sources and sinks.
The distribution of the number of source methods for
location information shows three different
jumps, namely
between versions 8 and 9, between 16 and 17, and between 17
and 18. This is due to major changes in the Android location
APIs [34]–[36]. The same holds for the jumps in the number
of bluetooth information sources between versions 17 and
18, where new source-bearing classes where added to the
android.bluetooth API. One also clearly sees that NFC
was added to Android in API version 9 [34]. There are some
cases in which the number of sources is decreased from one
version to the next, e.g. between versions 4, 5, 6, 7 and 8
for location. This is related to minor changes in the API. The
cross-validation results on the different Android versions were
effectively the same as reported for version 4.2 in Sections
V-A2 and V-B.
11
Our results show that SUSI detects the changes in different
API versions very well. It reliably ﬁnds new sources and sinks
that were added to the Android platform and thus provides a
much higher level of coverage than available lists assembled by
hand. Note that for completely new, previously unanticipated
APIs that should yield a new category, SUSI obviously cannot
anticipate this category either. In such cases one can easily
open a new category, though, by annotating by hand a few
examples that fall into this category. This is exactly how we
formed categories in SUSI’s training set.
E. RQ5: Existing lists of sources & sinks
In this section we assess to what extent current static [2]–[7],
[9], [12], [13] and dynamic [14], [15] code analysis approaches
could beneﬁt from our categorized sources/sinks list. As our
results show, SUSI ﬁnds all the sources and sinks these previous
approaches mention, plus many others which the community
was previously unaware of, including some of which are actually
being used by malware. Most of the code-analysis tools were
not publicly available, precluding one from directly comparing
their source and sink lists to SUSI’s [2], [3], [6], [7], [9], [15].
For those approaches we thus estimated the lists from their
research papers.
Mann et al. [9] mention a few concrete source and sink
methods. This hand-picked list is only a fraction of the one
produced by SUSI. The taint-tracking tool CHEX [2] uses
a list of 180 semi-automatically collected sources and sinks.
Unfortunately, this list is not publicly available and the paper
does not explain how the semi-automatic approach works. The
authors do mention that their list is based on the Android
permission map by Porter Felt et al. [37] but also argue
that this list is insufﬁcient. LeakMiner [3] uses the Android
permission map to identify sources and sinks. From this map
it ﬁlters out all methods an application is not allowed to use.
However, this leaves open how the tool actually identiﬁes
the relevant sources and sinks in the remaining method set.
Furthermore, if all methods not requiring a permission are
ﬁltered, some sensitive data might be overlooked as we have
shown. ScanDal [6] and AndroidLeaks [7] do not provide
concrete lists of source and sink methods. The publications only
provide categories (e.g., location information, phone identiﬁer,
internet, etc.), which are also covered by our automatic
categorization. Aurasium [15] shifts the problem of identifying
sources and sinks by intercepting calls at the system level, i.e.,
between the native Android libraries and the standard Linux
system libraries. While this reduces the number of methods to
consider, it makes it harder to reconstruct higher-level semantics,
and is failure-prone in case of Android version upgrades. Due
to this design, the sources and sinks considered by Aurasium
are incomparable to SUSI’s results.
Three different taint-analysis approaches were publicly
available to us: The dynamic taint analysis tool TaintDroid [14],
an approach based on DeD by Enck et al. [4], and SCan-
Droid [38]. TaintDroid does not specify the high-level API calls
as sources or sinks. Instead, it uses the smaller set of lower-level
internal system methods called by those, an approach somewhat
comparable to Aurasium. However, this again raises the problem
of reconstructing the higher-level context from lower-level
calls. The type of data leaked can thus be imprecise. The DeD
approach works by decompiling the Android bytecode into Java
bytecode which is then used as input for the commercial Fortify
SCA [12] static code-analysis suite. Fortify can be conﬁgured
with rules for deﬁning sources and sinks. Enck et al. created
such rules and made them publicly available [39]. The list
contains about 100 Android sources and 35 Android sinks, all
of which are also included in SUSI’s source and sink lists. For
SCanDroid, we extracted the source and sink speciﬁcations
from the source code (version of April 2013). The resulting
list appears hand-picked and is fully covered by SUSI’s output.
For evaluating the completeness of the source and sink lists
contained in these three tools, we analyzed the most frequently
referenced source and sink methods in the malware samples
from Section V-C. Table VIII shows that the three tools treat
only a few of the methods as a sources or sinks respectively.
To assess TaintDroid, we created a separate app for every
source and sink in the table. For a source, the respective data is
obtained and then leaked via the network (note that the network
connection is treated as a sink by TaintDroid). For the sinks we
used the well-known getLongitude() method as a source
(which is treated as a source by TaintDroid) and also created
one app per sink. We ran all of our apps on a phone with
Cyanogenmod 10 [40] containing TaintDroid for Android 4.1.
The results of our evaluation are shown in Table VIII.
Table VIII shows that the source and sink lists of the three
tools are missing some important methods such as one returning
the Wiﬁ MAC-address which enables a phone to be uniquely
identiﬁed. All three tools also miss the method for obtaining
the list of accounts (mail, Exchange, social networks, etc.)
registered in the phone.
We also found that TaintDroid over-approximates the list
of sources and sinks, leading to over-tracking, for instance
by tainting the result value of all methods in the Telephony-
Manager class, including the result of toString(), which is
just the Java object ID (default implementation inherited from
java.lang.Object). We thus argue that automatically inferring
higher-level API methods as provided by our approach would
improve tools like TaintDroid as this would allow one to more
easily categorize and differentiate various types of sources and
sinks.
In total, the results of our evaluation show that obtaining
a complete list of sensitive sources and sinks is difﬁcult and
SUSI’s automatically generated list of categorized sources and
sinks can be used to improve this situation.
We also examined well-known commercial tools for static
code analysis such as Fortify SCA [12] by HP and IBM
AppScan Source [13]. As we found, by default these tools
provide lists that are rather incomplete. However, both provide
an easy way to integrate new sources and sinks to be considered
by the analysis. This shows that these tools shift the problem
of deﬁning sources and sinks to the analyst, who still needs to
obtain such a list from somewhere. SUSI can help to provide
more comprehensive defaults.
VI. SOURCES NOT CONSIDERED BY SUSI
SUSI works well when it comes to classifying sources
and sinks based on their structural similarity to other sources,
respectively sinks. In practice, this seems to work well for
sources that return data from method calls and sinks that obtain
1 NmeaListener mylistener = new
NmeaListener() {
2
3
4
5
6
7
public void onNmeaReceived(long arg0,
String nmea) {
if (nmea.startsWith("$GPGLL")) {
String[] data = nmea.split(",");
Log.d("Loc", "Longitude: "
+ data[3]} + data[4]
+ ", Latitude: " + data[1] +
data[2]);
}
}
8
9
10 };
11 LocationManager lm = (LocationManager)
this.getSystemService(LOCATION_SERVICE);
12 lm.addNmeaListener(mylistener);
13 // Just to start GPS, no data from this
callback is ever used
14 lm.requestLocationUpdates
(LocationManager.GPS_PROVIDER, 0, 0,
new LocationListener() { ... });
Listing 2. Android Location via NMEA Data
data through parameters. Android offers other less prevalent
sources and sinks, however, which cannot be easily classiﬁed
through machine learning which we will show in this section.
Applications can implement callback methods and receive
data from the operating system through the parameters of these
methods. This is commonly used to, e.g., obtain the location in
an Android application. In an attempt to avoid detection, the
app could however register the callback with onNmeaReceived
instead of the well-known onLocationChanged method and
then parse the raw GPS data (the NMEA records) as shown in
Listing 2 to get the same data. This shows, that a complete list
of callback methods is required for ﬁnding all data leaks. SUSI
cannot currently ﬁnd such callbacks due to our deﬁnition of
sources. The number of callback interfaces in the Android
operating system is however sufﬁciently small for manual
inspection. All callback handlers are deﬁned using a small set
of well-known and documented interfaces. Static analysis thus
aid their detection by ﬁnding methods taking these interfaces as
parameters. This approach scales well and does not introduce
an unreasonable number of false positives as shown in [41].
Android deﬁnes layout controls through XML ﬁles. In the
source code, they can be accessed by passing the respective
identiﬁer to the system’s ﬁndViewById function. Depending on
the ID that is passed, this function can return, for instance, a
reference to a password ﬁeld or to a button with a constant
label. Thus, depending on the ID, the method can or can not
be a source. Since calls to this function are present in almost
every Android app, a precise analysis must model the Android
resource system. If UI sources are restricted to password ﬁelds
(the default in FlowDroid [41]), the analysis scales well in
terms of precision. Regarding every input ﬁeld as a source,
on the other hand, can lead to a substantial number of false
positives. A more ﬁne-grained tradeoff might be possible by
exploiting knowledge about the app’s expected behavior.
VII. RELATED WORK
Our work was originally inspired by Merlin [42], a proba-
bilistic appraoch that uses a potentially incomplete speciﬁcation
12
Method
android.bluetooth.BluetoothAdapter.getAddress()
android.net.wiﬁ.WiﬁInfo.getMacAddress()
java.util.Locale.getCountry()
android.net.wiﬁ.WiﬁInfo.getSSID()
android.telephony.gsm.GsmCellLocation.getCid()
android.telephony.gsm.GsmCellLocation.getLac()
android.location.Location.getLongitude()
android.location.Location.getLatitude()
android.accounts.AccountManager.getAccounts()
java.util.Calendar.getTimeZone()
android.telephony.TelephonyManager.getDeviceId()
android.telephony.TelephonyManager.getSubscriberId()
android.telephony.TelephonyManager.getLine1Number()
android.provider.Browser.getAllBookmarks()
android.telephony.SmsManager.sendTextMessage()
android.util.Log.d()
java.net.URL.openConnection()
android.telephony.TelephonyManager.getSimSerialNumber() Returns the serial number of the
Description
Returns the hardware address of
the local Bluetooth adapter.
Returns the MAC address of the
Wiﬁ interface.
Returns the country code for the
phone’s locale.
Returns the SSID of the current
802.11 network.
Returns the GSM cell id.
Returns the GSM location area
code.
Returns the longitude in degrees.
Returns the latitude in degrees.
Returns all accounts of any type
registered on the device as a list.
Returns the time zone.
Returns the unique device ID.
Returns the unique subscriber ID.
Returns the phone number of the
device.
SIM.
Returns a cursor pointing to a list
of all the bookmarks.
Send a text based SMS.
Sends a debug log message.
Returns a URLConnection instance
that represents a connection to the
remote object referred to by the
URL.
TaintDroid
no
SCanDroid DeD
no
no
no
no
no
no
no
yes
yes
no
no
yes
yes
yes
yes
yes
yes
no
yes
no
no
no
no
no
yes
yes
no
no
no
no
no
no
no
yes
no
no
no
no
no
no
no
yes
yes
no
no
yes
yes
yes
yes
no
yes
yes
no
TABLE VIII.
DETECTION OF MOST FREQUENTLY USED SOURCES AND SINKS IN MALWARE SAMPLES [21] IN DIFFERENT ANALYSIS TOOLS
of sources, sinks and sanitizers to produce a more complete
one. Livshits et al.’s approach is based on a propagation
graph, a representation of the interprocedural data ﬂow in
the program where probabilistic inference rules are applied.
Their speciﬁcations are based on string-related vulnerabilities,
such as cross-side-scripting vulnerabilities or sql-injections.