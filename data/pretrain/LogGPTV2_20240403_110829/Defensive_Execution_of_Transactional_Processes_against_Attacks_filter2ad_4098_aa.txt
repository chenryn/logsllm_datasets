title:Defensive Execution of Transactional Processes against Attacks
author:Meng Yu and
Wanyu Zang and
Peng Liu
Defensive Execution of Transactional Processes against Attacks
Meng Yu, Wanyu Zang
Department of Computer Science
Monmouth University, 07764
PI:EMAIL
Peng Liu
School of Information Sciences and Technology
Pennsylvania State University, 16801
PI:EMAIL
Abstract
It is a well known problem that the attack recovery of
a self-healing system rolls back not only malicious transac-
tions, but also legitimate transactions that are dependent on
the malicious transactions. Rolling back and re-executing
damaged transactions increase the response time of the sys-
tem and may cause a signiﬁcant processing delay. In such
situations, the availability of the system is compromised
and the system suffers the vulnerability of Denial of Ser-
vice (DoS). In this paper, we propose a defensive execut-
ing technique and analyze its effectiveness. Our technique
concurrently executes multiple paths of a transactional pro-
cesses based on the prediction generated by a Discrete Time
Markov Chain. The defensive execution can reduce the de-
lay caused by recovery. We also propose a branch cutting
technique to reduce the extra cost introduced by defensive
execution. Our analytical results show that our technique is
practical against transactional level attacks.
1
Introduction
Distributed transactional processing systems (e.g., dis-
tributed database systems and workﬂow systems) are im-
portant in most critical infrastructures such as ﬁnancial ser-
vices. These services rely on the correctness, availability,
and reliability of the processing systems. Each transactional
process consists of a set of transactions that are related to
each other in terms of the semantics of a business process.
Each transaction represents a speciﬁc unit of work that the
business needs to do (e.g., a speciﬁc application program,
a database transaction). A consistent and reliable execution
of distributed transactional processes is crucial for all orga-
nizations.
However, it is well known that system vulnerabilities
cannot be totally eliminated, and such vulnerabilities can
be exploited by attackers who penetrate the system. Even
worse, in such situation, legitimate transactions referring to
the damaged transactions will also be affected since they
G(cid:1)V, E(cid:2)
1
t3
t6
0.3
t4
1
t8
1
0.9
0.1
t11
1
t12
0.3
t2
0.6
0.7
0.7
t7
t1
0.8
0.2
t9
0.5
0.5
0.4
1
t5
t10
Figure 1. An example of transactional pro-
cesses
compute results or make decisions based on wrong infor-
mation.
Figure 1 shows an example of damage spreading and re-
pair. In the ﬁgure, nodes are transactions and edges indicate
executing paths. The destination node of a directed edge
starts after the source node is complete, e.g., t12 will start
after t7 is done. If a node has more than one successors, the
number on an edge indicates the probability that the speciﬁc
path (or node) can be taken (Section 3 discusses how to de-
termine the probabilities).
In the ﬁgure, continuous lines
are the actual executing path and dash lines are possible ex-
ecuting paths.
In Figure 1, path t1t2t5t7t12 has been executed. If t2 was
compromised by an attacker, it would be possible that t2
made a wrong decision to select t5 as its successor. t7 may
also generate wrong information based on t2’s results. The
example shows a single compromised transaction may af-
fects many legitimate transactions. If we want to recover
the transactional process and given t12 is correct anyway (t12
does not depend on any of t2,t5 and t7) we need to roll back
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:05:44 UTC from IEEE Xplore.  Restrictions apply. 
1
(undo) t2t5t7 and redo t2 to select correct executing path. In
the procedure, damage tracing and repair are involved.
We have to rely on attack recovery techniques to address
the above problem. After the attacker successfully beats
prevention techniques, attack recovery techniques restore
the integrity level by repairing the damage caused by suc-
cessful intrusions.
Previous work [1, 10, 14, 15] introduced different tech-
niques to trace damage spreading and repair the damage in
transactional processing systems. However, if attacks hap-
pen, all affected transactions will be rolled back (undone)
and redone.
Rolling back and re-executing damaged transactions in-
crease the response time of the system and may cause a sig-
niﬁcant processing delay. In such situations, the availability
of the system is compromised and the system suffers the
vulnerability of Denial of Service (DoS).
In this paper, we propose a defensive executing tech-
nique and analyze its effectiveness. Our technique con-
currently executes multiple paths of a transactional pro-
cesses based on the prediction generated by a Discrete Time
Markov Chain. The defensive execution can reduce the de-
lay caused by recovery. We also propose a branch cutting
technique to reduce the extra cost introduced by defensive
execution. Our analytical results show that our technique is
practical against transactional level attacks.
This paper is organized as follows. Section 2 deﬁnes im-
portant terms used in this paper. Section 3 describes the
details of our defensive executing technique. Garbage col-
lection will be discussed in Section 4. We discussed the
effectiveness of our technique in Section 5 and compare it
with related work in Section 6. Finally, Section 7 concludes
the paper.
2 Preliminary
t2 makes a decision on which executing path will be se-
lected. The selection between t2’s successor t3 and t5 is
called control dependence, which is denoted by t2 →c t3 and
t2 →c t5. In the ﬁgure, execution path t1t2t5 was selected.
Assume ≺ is a relation on set S then we deﬁne
(cid:7) ≺ x}. Note
minimal(S ,≺) = {x | x ∈ S ∧ (cid:1)x
there may be more than one result qualiﬁed by the deﬁni-
tion of minimal(S ,≺). For example, In Figure 1, given
S = {t1,t2,t9}, since t1 ≺ t2 and t1 prect9, t1 is the qual-
iﬁed results for minimal(S ,≺). minimal(S ,≺) deﬁnes
start transactions in all left transactions of a transactional
process.
(cid:7) ∈ S , x
Once t2 is identiﬁed as a transaction compromised by
the attacker, and the selection of execution path t1t2t5t7 was
wrong, the execution of t5 and t7 need to be recovered. Fur-
thermore, if t12 reads information generated by t5, which
is ﬂow data dependence denoted by t5 → f t12, the damage
will be spread to t12. Note that even though no message has
been sent from t5 to t12, they may still have data dependen-
cies since they may share data objects.
In the above example, damage is spread through depen-
dency relations. We can similarly deﬁne the other two types
of data dependence. If t j modiﬁes data objects after ti reads
them, then t j is anti-ﬂow dependent on ti, which is denoted
by ti →a t j. If ti ≺ t j, and they have common data objects to
modify, then t j is output dependent on ti, which is denoted
by ti →o t j.
All the relations → f , →a and →o are data dependency
relations and are not transitive. From the well known results
of concurrency and parallel computing, if t j is data depen-
dent on ti, then they cannot run in parallel or concurrently,
and ti ≺ t j must be satisﬁed. Otherwise, the value shared by
ti and t j will be incorrectly calculated.
In this section, we introduce some preliminary terms and
concepts used in this paper.
2.2 Unrecoverable transactions
2.1 Dependency relations
Dependency relations are important because not only
data items are calculated through dependency relations, but
also executing orders of concurrent transactions are deter-
mined by dependency relations. Furthermore, we need the
dependency relations to determine proper defensive execu-
tions.
In Figure 1, the start node of an arrow will be executed
right before the end node, which deﬁnes a precedence re-
lation. For example, t1 precedes t2, which is denoted by
t1 ≺ t2. There are several possible executing paths in Fig-
ure 1. One of them is t1t2t5t7t12. An other one is t1t2t3t4t8t12.
In a distributed system, we need to consider both inside
operations and interactions with the outside world. The for-
mal models in previous work, such as [15, 14] were unable
to formalize interactions with the outside world. Since in-
teractions with the outside world are not recoverable, we
use an OW S (outside world site) to model the outside world.
All transactions happened on an OW S are unrecoverable.
We consider all inputs obtained from users and all outputs
to the users happen on a user site Su which is a OW S. All
user’s transactions are called OW T s (outside world trans-
actions). For example, a transaction that a user withdraws
money from a ATM cannot be recovered. It is an OW T and
the ATM is an OW S.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:05:44 UTC from IEEE Xplore.  Restrictions apply. 
2
2.3 Transactional processes
With above notations, transactional processes can be
modeled as (T, S,≺,→ f ,→a,→o,→c), where T is a set of
transactions, S is a set of sites that are corresponding to a
host or a processor in the distributed system, Su ∈ S is an
OW S, and all dependency relations among transactions.
2.4 Concurrency restrictions and domino-effects
We use a simple example to explain that there do exist
some restrictions on executing orders of transactions in de-
pendency relation based recovery.
Consider transactions t1 : a = 1,t2 : b = 2, and t3 : y =
a+b, which are executed in the sequence of t1 ≺ t2 ≺ t3. We
have t1 → f t3 ∧t2 → f t3. Assume that t2 has been identiﬁed
as compromised by an IDS, so the value of b is corrupted.
Therefore, t3 is also corrupted since it reads a incorrect b.
During the concurrency restrictions, the rolling back and re-
doing damaged transactions have to strictly follow speciﬁc
orders [15, 14]. The effects that a compromised transaction
affects all legitimate transactions depending on it are called
Domino-effects.
To recover, t2 needs to be undone followed by redone.
t3 needs to be redone. Please note that t3 does not need
to be undone because in the example, no transaction is de-
pendent on t3. We must satisfy the sequence of undo(t2) ≺
redo(t2) ≺ redo(t3) in the recovery. Any other execution
will get wrong results. The precedence relations introduced
by dependency relations is called concurrency restrictions.
The concurrency restriction is also caused by depen-
dency relations. However, we can break anti-ﬂow depen-
dency relations by introducing multi-version data, as de-
scribed in Section 3.
3 Defensive execution
This section describes the details of mathematical model
based prediction, data structure support, and branch cutting
in defensive executions.
3.1 A motivative example
Domino-effects always happen if transactional processes
are attacked. During the recovery, all concurrency restric-
tions have to be strictly followed to guarantee that the re-
covery is correct [15, 14]. Both domino-effects and concur-
rency restrictions cause signiﬁcant execution delay of re-
covery.
The recovery delay can be reduced or totally removed by
defensive execution. The basic idea of defensive execution
is to concurrently execute multiple paths that are most likely
to happen. For example, in Figure 1, while executing path
t1t2t5t7t12 we also execute path t5t6t7 and t3t4t8 as backup
executions. t1t2t5t7t12 is called actual execution.
If the execution of path t1t2t5t7t12 was manipulated by
the attacker, and path t1t2t5t6t8t12 should be the correct exe-
cution, we can discard old execution and switch to the cor-
rect execution immediately, which may signiﬁcantly reduce
the delay of recovery. Please note that defensive execution
does not handle the situation that the recovery path is the
same to the attacked path, which can be handled by previ-
ous work [15, 14].
3.2 Discrete time Markov chain based self-
adaptive prediction
Since executing all possible paths in a transactional pro-
cess may cost too many resources, we use a mathematical
model to choose the best candidate backup executions.
In a transactional process, if we consider the execution
of each transaction as a state, and associate each transi-
tion from one state to an other, we will get a Discrete Time
Markov Chain (DTMC) [13, 11]. We can predict the most
possible executing paths in a transactional process accord-
ing to its DTMC.
Given n transactions in a transactional process, the initial
(cid:4)
probability distribution is π(0) = (1,0,0, . . . ,0
). After the
(cid:1)
(cid:2)(cid:3)
n−1
kth step, the probability that a speciﬁc transaction will be
executed is given by
π(n) = π(0)Pn
(1)
(cid:4)
where P is the state-transition probability matrix of DTMC
and P = P· P··· P
. P is given by {ai j}, where ai j is the
(cid:2)(cid:3)
(cid:1)
probability of executing t j after transaction ti is done.
n
The initial P can be determined in different ways. For
example, it can be determined by the statistical results of
executions, or provided by the designer of the transactional
process. Otherwise, the initial P is determined in the fol-
lowing way. If ti has m successors, we assign 1
m as the state-
transition probability to each transition.
Once we have the initial P, we revise it according to real
executions. We record the actual executing path in each ex-
ecution of the process, then revise P according to how fre-
quently a successor will be selected in previous executions.
Therefore, our DTMC based prediction is self-adaptive.
In Figure 1, we may obtain state-transition probabili-
ties after enough executions, as associated numbers to each
edge. For example, the edge from t6 to t7 is 0.7, which in-
dicates that after t6 is done, t7 will have 70% chance to be
taken. t8 will have the other 30% change to be taken. The
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:05:44 UTC from IEEE Xplore.  Restrictions apply. 
3
state-transition probability matrix P is as follows.
0
0
0
0
0
0
0
0
0
0
0
0
0.8
0
0
0
0
0
0
0
0
0
0
0
0
0.3
0
0