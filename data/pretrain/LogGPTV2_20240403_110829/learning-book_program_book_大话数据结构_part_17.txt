长度为5
元素e进栈
图 4-4-3
因此对于进栈操作push，其代码如下：
/插入元素为新的栈项元素·/
Status Push（SqStack*s,SElemType e)
if（s->top
MAXSIZE
-1)
栈满*/
return ERROR;
s->top++;
栈顶指针增加一
S->data[S->top]-e;
/将新插入元素赋值给栈顶空间·
return OK;
---
## Page 118
大话数据结构
4.4.3栈的顺序存储结构一出栈操作
出栈操作pop，代码如下：
/若栈不空，则删除S的栈项元素，用通回其值，并返回OK：否则返四ERROR·/
Status Pop（SqStack *S,SElemType *e)
if（s->top=--1)
return ERROR;
dotop1+1==S->top2）/·栈已满，不能弄push新元素了*/
95
---
## Page 120
大语数据结构
return ERROR;
if（stackNumber-1）/·栈1有元素进栈·/
S->data[++S->top1]=e:/若栈1则先top1+1后给数组元素赋值*/
elseif（stackNumber==2）/·栈2有元素进栈*/
S->data[--S->top2]-e;/·若栈2则先top2-1后给数组元素赋佳*/
return OK;
因为在开始已经判断了是否有栈满的情况，所以后面的top1+1或top2-1是不担
心溢出问题的。
对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber，
代码如下：
/若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则适国ERROR*/
Status Pop（SqDoubleStack *S,SElemType *e,int stackNumber）
if(stackNumber--1)
if（s->topl---1)
return ERROR;
/说明1已经是空栈，溢出/
"e=S->data[S->top1--];/·将栈1的项元素出*/
elseif（stackNumber==2)
1
if（S->top2--MAXSIZE)
return ERROR;
/说明2已经是空栈，溢出/
e=S->data[S->top2++];/·将栈2的栈顶元素出栈*/
return OK;
事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也
就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样，你买入时，一定是有
一个你不知道的人在做卖出操作。有人赚钱，就一定是有人赔钱。这样使用两栈共享
空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而
溢出了。
当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果是不相
96
---
## Page 121
第4章栈与队列
同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂，大
家要注意这个前提。
4.6栈的链式存储结构及实现
4.6.1栈的链式存储结构
讲完了栈的顺序存储结构，我们现在来看看栈的链式存储结构，简称为链栈。
想想看，栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由
于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢，所以比较
好的办法是把栈顶放在单链表的头部（如图4-6-1所示）。另外，都已经有了栈顶在头
部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头
结点的。
top
an-1
：
a1
栈底
图 4-6-1
对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如
果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是
否溢出的问题。
但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL
的时候。
链栈的结构代码如下：
6
---
## Page 122
大话数据结构
typedef struct StackNode
SElemType data;
StackNode,*LinkStackPtr:
typedef struct LinkStack
LinkstackPtr top:
int count;
}LinkStack;
链栈的操作绝大部分都和单链表类似，只是在插入和删除上，特殊一些。
4.6.2栈的链式存储结构一
一进栈操作
对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针，示
意图如图4-6-2所示代码如下。
top
2
①
top
1
a
图 4-6-2
/·插入元素e为新的栈顶元素*/
Status Push(LinkStack*s,SElemType e）
LinkStackPtr s-（LinkStackPtr）malloc（sizeof（StackNode））:
fa=eepnext-S->top1/·把当前的栈项元素值给新结点的直接后继，如图中①*/
86
---
## Page 123
第4章梭与队列
S->top=s;
/将新的结点s赋值给栈顶指针，如图中②*/
S->count++;
return OK;
4.6.3栈的链式存储结构
一出栈操作
至于链栈的出栈pop操作，也是很简单的三句操作。假设变量p用来存储要删除
的栈顶结点，将顶指针下移一位，最后释放p即可，如图4-6-3所示。
p③
top
?
aj
top
aj-1
a1
图 4-6-3
/若栈不空，则删除S的栈项元素，用e返回其值，并返田OK；否则返团ERROR*/
Status Pop（LinkStack*S,SElemType *e)
LinkStackPtr p:
if（StackEmpty(*s))
return ERROR;
*e=S->top->data;
:doitop=S->top->next；/，使得栈项指针下移一位，指向后一结点，如图④*/
free（p）;
释放结点p*/
S->count--!
return OK;
链栈的进栈push和出栈pop操作都很简单，没有任何循环操作，时间复杂度均
66
---
## Page 124
大语数据结构
为0[1）。
对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为0（1）。对于空间性
能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的
优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些
内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，如果栈
的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反
之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。
4.7栈的作用
有的同学可能会觉得，用数组或链表直接实现功能不就行了吗？干吗要引入栈这
样的数据结构呢？这个问题问得好。
其实这和我们明明有两只脚可以走路，干吗还要乘汽车、火车、飞机一样。理论
上，陆地上的任何地方，你都是可以靠双脚走到的，可那需要多少时间和精力呢？我
们更关注的是到达而不是如何去的过程。
栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更
加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下
标增减等细节问题，反而掩盖了问题的本质。
所以现在的许多高级语言，比如Java、C#等都有对栈结构的封装，你可以不用关
注它的实现细节，就可以直接使用Stack的push和pop方法，非常方便。
4.8栈的应用—递归
栈有一个很重要的应用：在程序设计语言中实现了递归。那么什么是递归呢？
当你往镜子前面一站，镜子里面就有一个你的像。但你试过两面镜子一起照吗？如
果A、B两面镜子相互面对面放着，你往中间一站，嘿，两面镜子里都有你的千百个
“化身”。为什么会有这么奇妙的现象呢？原来，A镜子里有B镜子的像，B镜子里也
有A镜子的像，这样反反复复，就会产生一连串的“像中像”。这是一种递归现象，
如图4-8-1所示。
100
---
## Page 125
第4章栈与队列
图4-8-1
我们先来看一个经典的递归例子：斐波那契数列（Fibonacci）。为了说明这个数
列，这位斐老还举了一个很形象的例子。
4.8.1斐波那契数列实现
说如果免子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子
来。假设所有兔都不死，那么一年以后可以繁殖多少对兔子呢？
我们拿新出生的一对小免子分析一下：第一个月小兔子没有繁殖能力，所以还是
一对；两个月后，生下一对小兔子数共有两对；三个月以后，老兔子又生下一对，因
为小兔子还没有繁殖能力，所以一共是三对依次类推可以列出下表（表4-8-1）。
表4-8-1
所经过的月数123456789101112
免子对数1123581321345589144
表中数字1，1，2，3，5，8，13…构成了一个序列。这个数列有个十分明显的
特点，那是：前面相邻两项之和，构成了后一项，如图4-8-2所示。
101
---
## Page 126