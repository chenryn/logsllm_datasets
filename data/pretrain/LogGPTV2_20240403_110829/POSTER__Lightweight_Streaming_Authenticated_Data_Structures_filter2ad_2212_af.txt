erating, uses the random number to test the performance of the
scheme.
First, consider the value of µ by experiments and analysis.
Table 4 shows comparison of redundancy, number of extension,
and, the time spend when appending and verifying in the case
of selecting diﬀerent values. The more the value of , the more
the redundancy, but the fewer the number of extensions required
to reach a certain scale. In extreme case, each time appending
data, needs to extend scale, that is, , it does not cause redun-
dancy, but increases the complexity of appending operation so
that the data appending time increased. Another special case
is to extend the scale by double extension, and the redundancy
increases, but does not signiﬁcantly increase the complexity of
appending data operations.
From Table 4, can know the eﬀect of diﬀerent µ values is not
particularly signiﬁcant on the average time of appending and
verifying. After many experiments, ﬁnd that when µ = 8, the
average time of appending and verifying is slightly lower than
that of when setting µ to other values. Diﬀerent machine have
12
MANUSCRIPT ACCEPTEDACCEPTED MANUSCRIPTTable 4. The impact on DFHMT choosing diﬀerent µ
/ Jurnal of Network and Computer Applicaion 00 (2018) 1–15
13
µ
Redundancy(%)
Expansion times(to 256)
Time of inserting (s)
Time of veriﬁcation (s)
4
75
66
8
87.5 93.75 96.88
35
2
50
129
1.19 1.20 1.19 1.19
0.31 0.31 0.31 0.31
13
1.19
0.31
32
16
20
diﬀerent conﬁgurations, and because the errors and other rea-
sons, according to the experimental data the value last selected
may not be the same. Considering the redundancy, the num-
ber of extensions required, the average time of appending and
verifying, etc., we set µ = 8 to be the parameter of follow-up
experiments in this paper.
Comparing DFHMT, FHMT constructed on the basis of
FHMT and DCAT, and SADS-DCAT by experiments. The tree
structure of DFHMT during the initialization phase is empty,
and no node needs to be generated. When can not continue
to append data, dynamically extend the scale of the tree.
In
general, when extending the scale of the tree in DFHMT to
the same as for the tree in FHMT, the total number of nodes
generated are the same. Just FHMT determines the depth of
the tree at the beginning, and the nodes are generated in ad-
vance. So from the total number of nodes, there are little diﬀer-
ence between DFHMT and FHMT. However, when querying
and verifying, the average authentication path of DFHMT is
shorter, which reduces the space overhead and communication
overhead, reduces the number of operation and improves the
eﬃciency of veriﬁcation.
When appending data, DFHMT is updated layer by layer
from the leaf node to the root node. The number of nodes to
be updated is depth (tree depth), which is consistent with the
FHMT scheme. When SADS-DCAT appending a leaf node,
only updates the nodes until the unique chameleon hash node
corresponding to the leaf node instead of updating the nodes un-
til the root node. That is, SADS-DCAT updates less data than
the depth of tree when appending data. However, considering
the DFHMT uses simple numerical multiplication and addition
instead of complex hash operations, the eﬃciency of DFHMT
and SADS-DCAT can not be evaluated simply by the number
of nodes updated when appending data. DFHMT appends a
new node, users only need times multiplication operation and
an addition operation. Although SADS-DCAT updates fewer
nodes when appending data, each updating requires a complex,
time-consuming hash operation.
The lightweight mentioned in this paper mainly refers to the
operations of the client. DFHMT transfers almost all calcula-
tion tasks to the server, which greatly reduces the burden on
the client. The changes for average time of appending data for
the three SADS methods with the amount of data are shown in
Fig. 12(a), For both DFHMT and FHMT the average time of
client appending data is much far less than the SADS-DCAT,
and for the former two, the unit of the average time of client is
microseconds, almost negligible. Since the client of DFHMT
does simple numerical multiplication and addition when ap-
(a) Comparison between three SADS construction methods
(b) Comparison of DFHMT and FHMT
Fig. 12. The average time of data inserting at client
pending data. Fig. 12(b) shows that the comparison of the av-
erage time of client for DFHMT and FHMT when appending
data, we can ﬁnd the performance of DFHMT is better than
that of FHMT.
DFHMT spends most of the time in the operation of server
when appending data,
the comparison of the average time
changes with the amount of data when appending data is as
shown in Fig. 13, for DFHMT, the average time increases with
the increase of the amount of data. And we can ﬁnd, when the
amount of data to be inserted is relatively small, the average
time of DFHMT is far less than that of FHMT. This is because
DFHMT need not predetermine the depth of the tree as FHMT
does when initializing. When the amount of data is small, the
number of node to be updated is relatively small. However,
the average time of DFHMT is more than that of SADS-DCAT
when appending data, this is because, for DFHMT, the opera-
tions on the server are based on ciphertext encrypted with FHE,
the average time is aﬀected by the eﬃciency of the FHE algo-
rithm.
The authentication path of DFHMT and that of SADS-DCAT
13
MANUSCRIPT ACCEPTEDACCEPTED MANUSCRIPT/ Jurnal of Network and Computer Applicaion 00 (2018) 1–15
14
shows the range veriﬁcation algorithm is relatively eﬃcient.
Fig. 13. The average time of data inserting
Fig. 15. The average time of data veriﬁcation
Fig. 14. The average length of authentication path
Fig. 16. The average time of range veriﬁcation
are similar when querying and verifying. Both schemes use the
root node of the smallest subtree as the root node for veriﬁca-
tion, so the average authentication path is shorter than that of
FHMT, as shown in Fig. 14. And the average veriﬁcation time
of DFHMT is less than that of FHMT, as shown in Fig. 15. In
addition to using multiplication operations and addition opera-
tions, DFHMT also need to do decryption operation of FHE,
which makes the most of the time consumed in the decryp-
tion operation. SDAS-DCAT also need to use complex hash
operations several times. But due to the low eﬃciency of the
current FHE algorithm, the average veriﬁcation time is more
than that of SADS-DCAT, which is one of the directions to
be improved later. Because of the current eﬃciency issue of
FHE, DFHMT is not better to SADS-DCAT from the veriﬁca-
tion point of view. DFHMT also supports range query and ver-
iﬁcation, the changes for the average time of range veriﬁcation
with the size of the range queried are as shown in Fig. 16. The
size of the range has no obvious eﬀect on the average time of
verifying, and comparing with the signal element veriﬁcation,
the range veriﬁcation does not increase too much time, which
Through the above analysis, we can know that DFHMT
scheme can extend scale dynamically and is better than FHMT
in terms of appending, query and verifying. Compared with
SADS-DCAT, the nodes updated increase, but the usage of sim-
ple numerical multiplication and addition greatly improves the
eﬃciency of the resource-limited clients.
7. Conclusion
In this paper, we have proposed a DFHMT with multiple im-
provements based on the static FHMT. The DFHMT is not re-
quired to predetermine the data size, and it has the feature of
adaptive expansion. Therefore, it is more suitable for the data
stream environment where the data size is considered to be un-
limited instead of ﬁxed. We designed the key algorithms for the
DFHMT including which includes initialization, data append-
ing, tree extension, query and veriﬁcation, which are proven to
be more eﬃcient and less space-consuming compared to that
of the static FHMT. Finally, we conducted several experiments
in order to compare the performances between the DFHMT,
14
MANUSCRIPT ACCEPTEDACCEPTED MANUSCRIPT/ Jurnal of Network and Computer Applicaion 00 (2018) 1–15
15
FHMT and DCAT. The results indicate that the DFHMT not
only solves the problem of ﬁxed data size but also exhibits many
improvements in terms of time and space consumption at client,
which means it is more suitable for lightweight environment.
8. Acknowledgements
The authors would like to thank the reviewers for their de-
tailed reviews and constructive comments, which have helped
improve the quality of this paper. This work was supported
by the National Natural Science Foundation of China (No.
61772127), the program for Talents of Higher Education in
Liaoning province (No. LJQ2015081), the Doctoral Science
Fund of Liaoning province (No.
the Natural
Science Foundation of Guangdong Province for Distinguished
Young Scholars (No. 2014A030306020), Guangzhou scholars
project for universities of Guangzhou (No. 1201561613), and
the Science and Technology Planning Project of Guangdong
Province (No. 2015B010129015).
201601166),
References
Atighehchi, K., Bonnecaze, A., Risterucci, G., 2015. New models for eﬃcient
authenticated dictionaries. Computers and Security 53, 203 – 214.
Benabbas, S., Gennaro, R., Vahlis, Y., 2011. Veriﬁable delegation of compu-
tation over large datasets. In: Conference on Advances in Cryptology. pp.
111–131.
Brandenburger, M., Cachin, C., Kneevic, N., 2017. Don’t trust the cloud, ver-
ify: Integrity and consistency for cloud object stores. ACM Transactions on
Privacy and Security 20 (3), 1–11.
Camenisch, J., Derler, D., Krenn, S., Pohls, H. C., Samelin, K., Slamanig,
D., 2017. Chameleon-hashes with ephemeral trapdoors and applications to
invisible sanitizable signatures. In: Conference on Practice and Theory of
Public-Key Cryptography 2017. pp. 152 – 182.
Catalano, D., Fiore, D., 2013. Vector commitments and their applications. In:
Conference on Public-Key Cryptography - PKC 2013. pp. 55 – 72.
Fiore, D., Gennaro, R., 2012. Publicly veriﬁable delegation of large polyno-
mials and matrix computations, with applications. In: ACM Conference on
Computer and Communications Security. pp. 501–512.
Gao, C., Chen, Q., Li, X., Xia, S., 2018. Cloud-assisted privacy-preserving
proﬁle-matching scheme under multiple keys in mobile social network.
Cluster Computing. DOI: 10.1007/s10586-017-1649-y.
Goodrich, M. T., Tamassia, R., Triandopoulos, N., 2011. Eﬃcient authenticated
data structures for graph connectivity and geometric search problems. Algo-
rithmica (New York) 60 (3), 505 – 552.
Huang, Z. G., Liu, S. L., Mao, X. P., Chen, K. F., Li, J., 2017. Insight of
the protection for data security under selective opening attacks. Information
Sciences 412, 223 – 241.
Khan, M. A., 2016. A survey of security issues for cloud computing. Journal of
Network & Computer Applications 71, 11–29.
Kim, K. S., Jeong, I. R., 2016. Eﬃcient veriﬁable data streaming. Security &
Communication Networks 8 (18), 4013–4018.
Krupp, J., Schroeder, D., Simkin, M., Fiore, D., Ateniese, G., Nuernberger, S.,
2016. Nearly Optimal Veriﬁable Data Streaming. In: Public-Key Cryptog-
raphy -PKC 2016, PT I. pp. 417–445.
Li, J., Chen, X. F., Li, M. Q., Li, J. W., Lee, P. P. C., Lou, W. J., 2014. Secure
deduplication with eﬃcient and reliable convergent key management. IEEE
Transactions on Parallel & Distributed Systems 25 (6), 1615–1625.
Li, J., Zhang, Y. H., Chen, X. F., Xiang, Y., 2018. Secure attribute-based data
sharing for resource-limited users in cloud computing. Computers & Secu-
rity 72, 1 – 12.
Li, P., Li, J., Huang, Z. G., Li, T., Gao, C. Z., Yiu, S. M., Chen, K., 2017. Multi-
key privacy-preserving deep learning in cloud computing. Future Generation
Computer Systems 74, 76–85.
Martel, C., Nuckolls, G., Devanbu, P., Gertz, M., Kwong, A., Stubblebine,
S. G., 2004. A general model for authenticated data structures. Algorithmica
39 (1), 21–41.
Merkle, R. C., 1987. A digital signature based on a conventional encryption
function. In: A Conference on the Theory and Applications of Crypto-
graphic Techniques on Advances in Cryptology. pp. 369–378.
Miller, A., Hicks, M., Katz, J., Shi, E., 2014. Authenticated data structures,
generically. In: Conference Record of the Annual ACM Sigplan-Sigact
Symposium on Principles of Programming Languages. pp. 411 – 423.
Naor, M., Nissim, K., 2000. Certiﬁcate revocation and certiﬁcate update. IEEE
Journal on Selected Areas in Communications 18 (4), 561 – 70.
Papamanthou, C., Shi, E., Tamassia, R., Yi, K., 2013. Streaming authenticated
data structures. In: Theory and Applications of Cryptographic Techniques,
EUROCRYPT 2013. pp. 353 – 370.
Papamanthou, C., Triandopoulos, N., Triandopoulos, N., 2010. Optimal au-
thenticated data structures with multilinear forms. In: International Confer-
ence on Pairing-Based Cryptography. pp. 246–264.
Parno, B., Raykova, M., Vaikuntanathan, V., 2012. How to delegate and verify
in public: veriﬁable computation from attribute-based encryption. In: Inter-
national Conference on Theory of Cryptography. pp. 422–439.
Peng, S., Zhou, F. C., Xu, J., Xu, Z. F., 2016. Comments on ”identity-based dis-
tributed provable data possession in multicloud storage”. IEEE Transactions
on Services Computing 9 (6), 996–998.
Pulls, T., Peeters, R., 2015. Balloon: A forward-secure append-only persistent
authenticated data structure. In: European Symposium on Research in Com-
puter Security. pp. 622–641.
Schoder, D., Simkin, M., 2015. Veristream - a framework for veriﬁable data
streaming. In: Proceedings of FC 2015. pp. 548 – 566.
Schroeder, D., Schroeder, H., 2012. Veriﬁable data streaming. In: ACM Con-
ference on Computer and Communications Security. pp. 953–964.
Sookhak, M., Gani, A., Khan, M. K., Buyya, R., 2014. Dynamic remote data
auditing for securing big data storage in cloud computing. Information Sci-
ences 380, 101–116.
Tamassia, R., Triandopoulos, N., 2005. Computational bounds on hierarchical
data processing with applications to information security. In: International
Conference on Automata, Languages and Programming. pp. 153–165.
Tang, Y. Z., Liu, L., Wang, T., Hu, X., Sailer, R., Pietzuch, P., 2014. Outsourc-
ing multi-version key-value stores with veriﬁable data freshness. In: IEEE
International Conference on Data Engineering. pp. 1214–1217.
Yu, C. M., 2015. Poster: Lightweight streaming authenticated data structures.
In: ACM Sigsac Conference on Computer and Communications Security.
pp. 1693–1695.
15
MANUSCRIPT ACCEPTEDACCEPTED MANUSCRIPT