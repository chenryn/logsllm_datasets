title:Reproducible Dependability Benchmarking Experiments Based on Unambiguous
Benchmark Setup Descriptions
author:Kerstin Buchacker and
Mario Dal Cin and
Hans-J&quot;org H&quot;oxer and
Roland Karch and
Volkmar Sieh and
Oliver Tsch&quot;ache
Reproducible Dependability Benchmarking Experiments Based on
Unambiguous Benchmark Setup Descriptions
K. Buchacker, M. Dal Cin, H.-J. H¨oxer, R. Karch, V. Sieh, O. Tsch¨ache
Institut f¨ur Informatik 3
Friedrich Alexander Universit¨at Erlangen-N¨urnberg
Germany
Abstract
Dependability benchmarking is performance bench-
marking extended by dependability aspects.
It is an es-
sential feature of benchmarks of any kind, that they make
possible the fair evaluation and comparison of a system’s
attributes. To avoid biased benchmarking results, indepen-
dent teams should be able to repeat the benchmark of a
system and produce results similar to those of the original
benchmark. A semantically unambiguous description of the
benchmark setup is a major step towards the goal of repro-
ducible benchmarking experiments. This paper introduces a
VHDL-based method for semantically unambiguous bench-
mark setup description of both the static and dynamic as-
pects of benchmarks in general. The approach proposed
uses VHDL only as unambiguous description and model-
ing language and does not place restrictions on the actual
evaluation of the experiment in any way. A dependability
benchmarking experiment using this method is presented.
1. Introduction
Benchmarks are used to compare systems, often as mar-
keting instruments. To ensure credibility, the exact bench-
mark conﬁguration must be laid open in such detail, that
others can reproduce the results and thus validate the bench-
mark. Ideally, all aspects of the benchmark conﬁguration
must be described semantically unambiguously.
Current benchmarks go through a lot of trouble to attain
this mark. For the well known benchmarks of the Transac-
tion Processing Council, the benchmark conﬁgurations are
published as so called full-disclosure reports (usually sev-
eral hundred pages in length), including detailed hardware
descriptions as well as source code of the scripts and pro-
grams used. For benchmarks of the Standard Performance
Evaluation Corporation the same holds true. Most bench-
marking and fault injection experiments include a multitude
of small programs and scripts run semi-automatically from
the commandline.
For disciplines such as physics, chemistry or biology, it
is common practice that experimental setups be described in
such detail and completeness, that the experiments can be
reproduced and validated by independent teams. In com-
puter science detail and completeness can be achieved by
casting the complete experiment setup into a formal ma-
chine readable description, a model. In some cases it should
even be possible to feed this model to a program or automa-
ton which evaluates it automatically.
To this end, we have chosen VHDL [1] as formal de-
scription language. VHDL has been in practical use in re-
search and industry for a long time and its semantics for
both static and dynamic models are very well speciﬁed.
Other modeling languages, such as UML, which is being
used by more and more people, are not suited for our pur-
pose, as they do not yet have a well deﬁned unambiguous
semantic [2, 15]. In our approach, a single VHDL model
describes the model and its evaluation semantically unam-
biguously, in detail and completeness. The necessary input
for the experiment, such as hardware and software compo-
nents and user input as well as the benchmark elements such
as work- and faultload, are identiﬁed in the VHDL model.
The approach proposed uses VHDL only as unambigu-
ous description and modeling language.
It is the essence
of any model, that it places no demands on its evaluation
other that full compliance with the model. Therefore our
approach implies at no point that the actual benchmarking
experiment must be carried out using VHDL simulation.
The experiment could be carried out using real hardware,
a virtual machine or VHDL simulation. Of course, assum-
ing that the model is indeed semantically unambiguous and
that the evaluations are carried out correctly, whatever the
method employed, all must give the same results.
The following sections explain how we have imple-
mented our vision. Section 2 treats all the physically avail-
able more or less static components, in short, the hardware.
Section 3 talks about the interaction of the user or, gener-
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:26:06 UTC from IEEE Xplore.  Restrictions apply. 
cpu
mem
cpu0
memory
mem
mem0
s
u
b
m
e
m
video
mem
video
type
interface
name
type
component
bus
direction of  communication
n
o
r
e
w
o
p
t
e
s
e
r
ctrl
basic_control
isa
s
u
b
a
s
i
isa
bridge
mem
mem2isa
mem2isa_
isa
ethcard
eth
ethbus
eth0
isa
serial
isa
serial
serial3
serial serialbus
isa
serial
serial2
serial serialbus
isa
serial
serial serialbus
serial1
serial0
ide
idectrl
isa
ide_ctrl
idedisk
hda
idedisk
hdb
ide
ide
serial serialbus
s
u
b
e
d
i
idedisk
hdd
idedisk
hdc
ide
ide
Figure 1. Graphical Representation of a Hardware Description in Structural VHDL
ally speaking, the environment with the hardware. As the
term ”interaction” implies, this includes mostly dynamic
non-tangible aspects. Section 4 references our prototype
experiment to test and validate the approach described in
this paper. Section 5 concludes the paper.
2. Hardware
The hardware is described in structural VHDL.
The hardware description details the complete physi-
cal system, which may consist of more than one machine
and can include interconnection networks. The ﬁnest gran-
ularity on component level are commercial-off-the-shelf
components, such as network interface cards, harddisks or
motherboards.
Section 2.1 explains how to create an unambiguous hard-
ware conﬁguration description. Section 2.2 shows how a
hardware faultload can be described.
2.1. Conﬁguration
Figure 1 shows an example of a graphical representation
of the structural VHDL-model of the hardware of a single
machine. In a networking context, a single machine is often
referred to as a node.
The node in ﬁgure 1 is a typical server (such as kept in a
19 inch rack in a separate server room) without monitor and
keyboard. CPU, memory, video card, the mem-to-isa bridge
(commonly called north-south-bridge), the IDE-controller,
serial and ethernet card are shown as separate components.
They can be extra plugin cards or onboard components.
As a server, the machine has four disks connected to the
IDE-controller. The ctrl component models the external
switches (such as power and reset) on the machine’s casing.
The links to the exterior world are through the ethernet
and serial interfaces and the buttons or switches (such as
poweron and reset) present on the casing and the classical
input/output devices keyboard, mouse and video. These
interfaces to the outside world may be input only (such
as the mouse interface usually is) or output only (such as
non-touchscreen monitors) or input/output capable (such as
the ethernet or serial interfaces). Even if the interfaces are
present, they are not necessarily connected (such as the in-
terface of the video card of the server in ﬁgure 1).
Once components such as the node in ﬁgure 1 are de-
ﬁned, they can be used to build larger structures. To this
end, the interfaces of the aggregate components are con-
nected to appropriate buses. The node in ﬁgure 1 is reused
in section 4 in ﬁgure 8 detailing our benchmarking experi-
ment setup.
A textual VHDL-model of a small client-server setup
with three nodes (two clients and a server) interconnected
with a common network is shown in ﬁgure 2. The ethernet-
interfaces of the nodes are connected to a common ethernet
(lines 2, 4 and 6 of ﬁgure 2).
In this way we can build a hierarchy of components start-
ing from the simple predeﬁned ones and, reusing the com-
ponents deﬁned at the previous level of the hierarchy, ﬁ-
nally arrive at very complex setup descriptions completely
in VHDL.
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:26:06 UTC from IEEE Xplore.  Restrictions apply. 
1 architecture structural of system is
2
3
4
signal network : ethbus;
begin
server : node
generic map (memsize => 512)
port map (eth => network);
clients : for i in 1 to 2 generate
client : node
5
6
generic map (memsize => 64)
port map (eth => network);
end generate;
7
8 end structural;
Figure 2. Structural VHDL Code for a Small
Client-Server System
The component node (from ﬁgure 1) used in ﬁgures 2
and 8 is parametrized for ﬂexible reuse. It is conﬁgured as
server (large memory, line 4 in ﬁgure 2) and client machine
(smaller memory, line 6 in ﬁgure 2).
2.2. Hardware Faults
For pure performance benchmarks the unambiguous def-
inition of the conﬁguration is all that is necessary concern-
ing the hardware. For dependability benchmarks as pro-
posed by DBench [8], we must take into consideration that
hardware can fail and that these hardware failures may be
part of a faultload.
[13] ﬁrst proposed the idea of using
VHDL-components with integrated fault descriptions. We
are building on this general idea to deﬁne the failure behav-
ior of the basic components in our VHDL model.
Where the basic components used in [13] are the clas-
sical low-level VHDL-components at the gate level, for de-
pendability benchmarking we are using relatively high-level
hardware components available off-the-shelf. The fault de-
scriptions associated with such high-level components are
of course not the same bit-ﬂips and stuck-ats as those for
gate level components.
It is nevertheless possible to de-
scribe the component failure behavior in VHDL. The fol-
lowing paragraphs discuss how to model possible faults us-
ing an ethernet card as an example.
Figure 3 shows the VHDL model of the ethernet card
of our node in ﬁgure 1 including its failure behavior. Fig-
ure 4 visualizes how the VHDL-components of ﬁgure 3 are
connected together. The VHDL entity ethcore is a black
box, whose functionality — behavior compatible to that of
the well-known NE2000 ethernet interface card — is im-
plemented in our component library. The isa-interface
of ethcore is directly connected to the isa-interface of
ethcard. The unidirectional interfaces oeth for output
and ieth for input of ethcore are both connected to
the bidirectional interface eth of ethcard. oeth and
ieth are input signals to the processes ifault and ofault.
1
2
3
4
5
entity ethcore is
port( isa
: inout isabus,
oeth : out ethbus,
ieth : in ethbus );
end entity ethcore;
entity ethcard is
port( isa : inout isabus,
eth : inout ethbus );
6 end entity ethcard;
7 architecture internal of ethcard is
8
ofault : boolean
fault
interval 1 year duration 5 sec;
9
fault
ifault : boolean
interval 1 year duration 5 sec;
signal oeth_int : ethbus;
signal ieth_int : ethbus;
10
11
12 begin
13
14
core : ethcore
port map (isa => isa,
ieth => ieth_int,
oeth => oeth_int);
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
ofault : process(oeth_int, ofault)
begin
if ofault then
eth <= ’0’;
else
eth <= oeth_int;
end if;
end ofault;
ifault : process(ieth_int, ifault)
if ifault then
ieth_int <= ’0’;
else
ieth_int <= eth;
end if;
end ifault;
30 end architecture internal;
Figure 3. Example of a VHDL Component De-
scription Including Failure Behavior
Each process has another input signal, namely a fault sig-
nal. The fault signals are of the special VHDL type fault.
A fault is deﬁned in [13] as a signal with a boolean value
which occurs with a certain frequency. The interval given
is the mean time to failure, the duration is the mean fault
activation time. These parameters are used for documenta-
tion only and should ideally be taken from known failure
statistics of the component in question. They can later be
used to calculate the measures of interest from the data col-
lected in the experiment. Processes deﬁned within the same
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:26:06 UTC from IEEE Xplore.  Restrictions apply. 
ethcard
ethcore
i
s
a
b
u
s
isa
isa
oeth
oeth_int
ieth
core