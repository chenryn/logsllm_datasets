try(
Pattern regex w Pattern.compile(userInput);
)catch (PatternSyntaxException ex)(
// Syntax error in the regular expression
要想在一个字符串上能够使用该正则表达式，那么就需要创建一个Matcher：
Matcher regexMatcher =regex.matcher(subjectString);
要在另外一个字符串上也可以使用该正则式，那么你可以按照上面的方法创建一个新
的Matcher，或者也可以复用已有的Matcher：
102
第3章
www.TopSage.com
---
## Page 119
regexMatcher.reset(anotherSubjectString);
JavaScript
在你的代码中的字面正则表达式：
var myregexp=/regexpattern/;
从用户输人获取的正则表达式，作为一个字符串存储在变量userinput中：
var myregexp = new RegExp(userinput);
Perl
$myregex= qr/regexpattern/
从用户输人获取的正则表达式，作为一个字符串存储在变量Suserinput中：
$myregex - qr/$userinput/
Python
reobj = re.compile("regex pattern")
从用户输人获取的正则表达式，作为一个字符串存储在变量userinput中：
reobj = re.compile(userinput)
Ruby
在你的代码中的字面正则表达式：
myregexp=/regex pattern/;
从用户输人获取的正则表达式，作为一个字符串存储在变量userinput中：
讨论
在正则表达式引擎能把正则表达式匹配到一个字符串之前，正则表达式首先需要被编
译。这个编译的动作是在你的应用程序运行过程中完成的。正则表达式构造函数或者
编译功能会分析包含你的正则表达式的字符串，并把它转换成一个树形结构或者是状
态机。执行实际的模式匹配的函数则会在扫描该字符串的同时遍历该树或者自动机。
支持字面正则表达式的编程语言会在执行过程到达这个正则表达式操作符的时候进行
编译。
.NET
在C#和VB.NET中，.NET的System.Text.RegularExpressions.Regex类中会包含一个编
使用正则表达式编程
103
www.TopSage.com
---
## Page 120
译好的正则表达式。最简单的构造函数只接受一个参数，也就是包含你的正则表达式
的一个字符串。
如果在正则表达式中存在一个语法错误的话，那么RegexO构造函数会产生一个
ArgumentException例外。这个例外消息会说明到底是遇到了哪个错误。如果该正则表
达式是由程序的用户提供的话，那么就很有必要捕获这个例外。把例外消息显示给用
户，然后要求用户对正则表达式进行修改。如果你的正则表达式是一个硬编码的字符
事常量，那么可以忽略捕获例外的过程，但是你需要使用代码覆盖工具来保证该行代
码会正常执行，而不会产生例外。你不能通过修改状态或者模式来使同一个字面正则
表达式在一种情形下可以编译，而在另外一种情形下会编译失败。注意，如果你的字
面正则表达式中存在语法错误，那么它会在你的程序运行时产生例外，而不是在程序
编译的过程中。
如果你会在一个循环内部，或者在整个程序中会重复使用某个正则表达式，那么应当
构造一个Regex对象。构造一个正则表达式对象并不会带来额外的开销。因为不管你
怎么使用，把该正则式作为字符事参数的Regex类的静态成员总是会在内部构造一个
Regex对象，所以完全可以在你自已的代码中进行构造，这样还可以保留一个到该对象
的引用。
如果只计划使用该正则式一次或者少数几次，那么你可以使用Regex类的静态成员，
这样可以少写几行代码。静态的Regex成员并不会立即丢弃在内部构造的正则表达式
对象，事实上，它们会在缓存中保留最近使用过的15个正则表达式。你可以通过设置
Regex.CacheSize属性来修改缓存的大小。但是不要过于依赖这个缓存。如果需要频繁
使用许多正则对象的话，那么还是需要保存一份自已的缓存，这样检索效率才会比字
符串搜索更为高效。
Java
在Java语言中，Pattern类中会包含一个编译好的正则表达式。你可以使用
Patterm.compileO类厂来创建该类的对象，它只需要一个参数，即包含你的正则表达式
的一个字符串。
如果在正则表达式中存在一个语法错误，那么Pattern.compileO类厂会产生一个
PattermSyntaxException例外。这个例外消息会说明到底是遇到了哪个错误。如果该正则
表达式是由程序的用户提供的话，那么就很有必要捕获这个例外。把例外消息显示给
用户，然后要求用户对正则表达式进行修改。如果你的正则表达式是一个硬编码的字
符串常量，那么可以忽略捕获例外的过程，但是你需要使用代码覆盖工具来保证该行
代码会正常执行，而不会产生例外。你不能通过修改状态或者模式来使同一个字面正
则表达式在一种情形下可以编译，而在另外一种情形下会编译失败。注意，如果你的
学面正则表达式中存在语法错误，那么它会在你的程序运行时产生例外，而不是在程
104第3章
www.TopSage.com
---
## Page 121
序编译的过程中。
除非你计划只使用这个正则表达式一次，否则都应当创建一个Pattern对象，而不是
使用String类的静态成员。虽然可能会需要多写几行代码，但是它运行起来会更加高
效。静态的调用会在每一次都重新编译你的正则表达式。事实上，Java只对很少几个
非常基本的正则任务才提供静态调用。
-个Patterm对象只会保存一个编译好的正则表达式；它并不会做任何实际的工作。实
际上的正则匹配是由Matcher类来完成的。如果想要创建一个Matcher对象，就需要使用
编译好的正则表达式来调用matcherO函数。把目标字符串作为matcherO的唯一参数。
你可以调用matcherO任意多次，从而可以使用同一个正则表达式来匹配多个字符串。
你也可以同时使用同一个正则式的多个匹配器（matcher)，只要把所有的工作都限制在
单个线程中即可。Pattern和Matcher这两个类都不是线程安全的。如果想要在多个线程
中使用同一个正则表达式，那么就要在每个线程中分别调用Patterm.compileO。
如果在把一个正则式应用到一个字符串之后，还想要把同一个正则式应用到另外一个
字符串，那么你可以通过调用resetO函数来重复使用Matcher对象。把下一个目标字符
串作为唯一参数传递给该函数。这比创建一个新的Matcher对象的效率更高。resetO会
返回你所调用的同一个Matcher，并且充许你很容易地只使用一行代码就可以完成重置
并且接着使用该匹配器，例如：regexMatcher.reset(nextString).findO。
JavaScript
在实例3.2中给出的字面正则表达式的记法已经创建了一个新的正则表达式对象。要想
重复使用同一个对象，那么就可以简单地把它赋给一个变量。
如果有一个正则表达式存储在一个字符串变量中（比如，因为你要求用户输人一个正
则表达式)，那么可以使用RegExpO构造函数来编译这个正则表达式。注意在字符串之
内的正则表达式并没有使用正斜杠来进行分隔。这些斜杠是属于JavaScript为字面的
RegExp对象使用的记法，而不属于正则表达式自身的一部分。
数的JavaScript解答都略掉了这行代码，直接使用字面的正则表达式。在
：你自己的代码中，当多次使用同一个正则表达式的时候，你应当把该正
则表达式赋给一个变量，然后再使用该变量，而不是每次都把同一个字
面正则表达式复制到你的代码中。这样不仅可以提高性能，还能使你的
代码更加容易维护。
PHP
PHP并没有提供把编译好的正则表达式保存到一个变量中的方法。每当你想要使用一
DD
使用正则表达式编程105
www.TopSage.com
---
## Page 122
个正则表达式的时候，就必须把它作为-个字符事来传递给其中的一个preg函数。
preg函数类会保存包含最多4096个编译好的正则表达式的一个缓存。虽然基于哈
希的缓存查找并不像访问一个变量那么快，但是与每次都重新编译同一个正则表达
式相比，它对性能的影响并不是很大。当缓存已满时，最早被编译的正则表达式会
被移除。
Perl
你可以使用“quoteregex”操作来编译一个正则表达式，并把它赋给一个变量。它使用
的语法与在实例3.1中讲解的匹配操作符是一样的，唯一的区别是它以两个字母pr开
始，而不是字母m开头。
在重复使用较早编译好的正则表达式的时候，Perl通常是比较高效的。因此，在本章的
代码示例中，我们并没有使用qr//。只有实例3.5中演示了它的使用方法。
当你要在正则表达式中插人变量，或者是当你把整个正则表达式当作字符串来获取的
时候（比如是从用户输人获得），qr/会很有用。使用qr/Sregexstring/，可以控制正则表
达式什么时候被重新编译，以反映Sregexstring的新内容。m/Sregexstring/会每次都重新
编译该正则表达式，而m/Sregexstring/o永远不会进行重新编译。实例3.4中会解释/o
的含义。
Python
在Python的re模块中的compileO函数会接受一个包含你的正则表达式的字符串，然后
返回包含编译好的正则表达式的一个对象。
如果你计划反复使用同一个正则表达式，那么应当显式地调用compile(函数。在re模
块中的所有函数都会首先调用compileO，然后再在编译好的正则表达式对象之上调用
你想要用的函数。
compile0函数会保存它编译的最后100个正则表达式的引l用列表。这会把对于最后100
个使用过的正则表达式的重新编译过程都降级为一个词典查找动作。当缓存已满时，
缓存会被全部清除。
Y
如果性能不是问题的话，那么缓存会工作得足够好，从而你可以直接使用re模块中的
函数。但是如果性能有问题，那么就应当选择调用compile(。
Ruby
在实例3.2中给出的字面正则表达式的记法已经创建了一个新的正则表达式对象。要想
重复使用同一个对象，那么就可以简单地把它赋给一个变量。
如果有一个正则表达式存储在一个字符事变量中（比如，因为你要求用户输入一个正
106第3章
www.TopSage.com
---
## Page 123
则表达式），那么可以使用Regexp.newO类厂或者它的同义函数Regexp.compile(来编译
这个正则表达式。注意在字符串之内的正则表达式并没有使用正斜杠来进行分隔。这
些斜杠只属于Ruby为字面的Regexp对象使用的记法，而不属于正则表达式自身的一
部分。
由于把字面正则表达式赋给一个变量是很简单的，因此在本章中绝大多
数的Ruby解答都略掉了这行代码，直接使用字面的正则表达式。在你自
达式赋给一个变量，然后使用该变量，而不是每次都把同一个字面正则
表达式复制到你的代码中。这样不仅可以提高性能，还能使你的代码更
加容易维护。
把正则表达式编译为CIL
C#
VB.NET
Dim RegexObj As New Regex("regex pattern", RegexOptions.Compiled)
讨论
当你在.NET中不传递任何选项来构造一个Regex对象的时候，正则表达式会按照我
们在本实例前面的“讨论”小节中描述的方式来进行编译。如果你把
RegexOptions.Compiled作为第二个参数传递给RegexO构造函数，Regex类会采用一种
不同的方式：它会把你的正则表达式编译为CIL，或者也被称作MSIL。CIL指的是通
用中间语言（CommonIntermediateLanguage），它是一种低级语言，与C#和VisualBasic
相比，它离汇编语言更近一些。所有.NET编译器都会产生CIL。你的应用程序第一次
运行的时候，.NET框架会把CIL继续编译成适合用户计算机的机器代码。
使用RegexOptions.Compiled来编译正则表达式的好处是，它的运行速度比不使用这个
选项来编译正则表达式快10倍以上。缺点是编译过程本身会比把正则式字符事分析成
一棵树要慢两个数量级。CIL代码也会成为程序中持久的一部分，直到程序运行结束。
CIL代码不会被垃圾收集。
只有在一一个正则表达式要么非常复杂，要么需要处理非常多的文本，从而用户在使用
该正则表达式操作的过程中会感受到明显停顿的时候，我们才推荐使用
RegexOptions.Compiled。如果正则表达式在一刹那间就能够完成任务，那么就不值得花
费这么多时间来进行编译和汇编。
使用正则表达式编程107
www.TopSage.com
---
## Page 124
参见
实例3.1、3.2和3.4。
3.4设置正则表达式选项
问题描述
你想要使用所有可用的匹配模式来编译一个正则表达式：宽松排列、不区分大小写，
点号匹配换行符以及脱字符和美元符号匹配换行处。
解决方案
#
Regex regexObj = new Regex("regex pattern"
RegexOptions.Singleline 1 RegexOptions.Multiline);
VB.NET
Dim RegexObj As New Regex("regex pattern",
RegexOptions.IgnorePatternWhitespace Or RegexOptions.IgnoreCase Or
RegexOptions.Singleline Or RegexOptions.Multiline)
Java
Pattern regex = Pattern.compile("regex pattern",
Pattern.COMMENTS 1 Pattern.CASE_INSENSITIVE IPattern.UNICODE_CASE1
Pattern.DOTALL 1 Pattern.MULTILINE);
JavaScript
代码中的字面正则表达式：
var myregexp=/regex pattern/im;
从用户输人获取的正则表达式（作为一个字符串userinput)：
PHP
regexstring ='/regex pattern/simx';
Perl