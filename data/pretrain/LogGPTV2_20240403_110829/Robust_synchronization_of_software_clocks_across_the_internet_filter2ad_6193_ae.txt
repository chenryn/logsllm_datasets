### 优化后的文本

**图8：使用算法（不包含局部速率）与参考值的时间序列对比，背景中显示的是朴素估计。参考值中的孤立跳变是由于未校正的 \(T_{f,i}\) 中的时间戳噪声所致。**

在图9中，中间曲线展示了整个3周内，通过 \(\tau^{\prime}\) 计算的估计值与校正后的参考值 \(\theta_g(t)\) 之间的差值中位数。该差值在广泛的窗口大小范围内约为28微秒，且四分位距（上下的线条）也非常小，在 \(\tau^{\prime}/\tau^* = 0.5\) 的最优值处约为11微秒，对窗口大小的敏感度很低。即使从最高（第99百分位）到最低（第1百分位）的范围也仅约为50微秒。考虑到我们当前对路径不对称性的最佳评估为约50微秒，这意味着偏移量的模糊性为 \(\Delta/2 \approx 25\) 微秒（公式(18)），并且时间戳问题将结果的可验证性限制在约5微秒以内，图9表明算法在消除网络延迟变化方面表现非常出色。在连续3个月的监测期间（有间隔，见第6节）使用ServerInt时，获得了几乎相同的结果，当前3周的跟踪数据是其子集。

图9(a)还比较了使用和不使用局部速率的估计结果。差异很小，使用局部速率仅在选择过大的窗口大小时获得一些抗干扰能力。无论哪种情况，结果对 \(\tau^{\prime}\) 的精确值不敏感都是令人鼓舞的，并且最优值接近 \(\tau^{\prime} = \tau^*\) 正是我们SKM公式的预期结果，也是对其的自然验证。

图9(b)检查了结果随质量评估参数E的变化情况。同样发现非常低的敏感度，最优结果在E的小倍数下实现，这符合预期。由于这里 \(\tau^{\prime} = \tau^*/2\)，使用局部速率带来的差异可以忽略不计，这与图9(a)一致。

我们还对老化率参数 \(\lambda\) 和局部速率窗口宽度 \(\bar{\tau}\) 进行了敏感性分析。对于这些相对良好的数据，敏感性如此之低，以至于它们完全可以省略而几乎没有影响。这些改进只有在某些条件下才会带来实际好处，例如高丢包率情况下，\(\tau^{\prime}\) 窗口内的数据包可能比预期的更远（见第6.1节中的“丢包”部分），或者当参数未针对特定情况进行优化时。例如，我们发现使用局部速率也有助于在E选择过低时稳定估计。

接下来，我们研究了算法对轮询周期的性能。我们没有给出使用局部速率改进的结果（它们非常相似）。我们将迄今为止使用的16秒周期与其他周期进行比较，包括通常允许的默认值范围：64到256秒。关于 \(\tau^{\prime}\) 的敏感性结果与图9(a)报告的结果非常相似，尽管最优“拐点”位置略微移动到较大的值。E的结果除了误差分布略有扩展外，基本不变。

现在，我们将其他参数固定为 \(\tau^{\prime} = \tau^*\)，\(E = 4\delta\)，以及 \(\lambda = 0.02\) PPM，并改变轮询率。图9(c)再次显示敏感性非常低。特别是，尽管信息减少了32倍，但中位数误差（粗线）只变化了几微秒。这一点非常重要，因为NTP服务器不应被过度加载。这也减轻了主机的内存和计算负担。

最后，我们研究了算法在四个不同环境下的性能，代表不同的主机-服务器环境，如图3所示。我们使用 \(\tau^{\prime} = \tau^*\)，\(E = 4\delta\)，以及64秒的轮询周期。可以看到，从实验室转移到更稳定的机房后，变化性有所减少，进一步迁移到更近的本地服务器时，变化性进一步减小。使用ServerExt时，中位数误差的跳跃是由于路径不对称性显著增加。与之前一样，误差约为 \(\Delta/2\)，远小于14.2毫秒的往返时间。更高的变化性是由于更多的跳数导致的更高噪声，使得高质量的数据包更为罕见。我们应该注意到，这里我们在极端情况下测试算法，即服务器在所有意义上都比必要的情况要远得多。

**6. 一个稳健的工作系统**

在本节中，我们讨论了完成算法所需解决的额外问题，并展示了用C语言编写的在线实现结果。我们还描述了额外的鲁棒性问题及其解决方案。出于篇幅原因，我们无法提供详细的流程图。完整的细节将在[7]中以高度结构化和注释的参考C实现形式提供。

**6.1 额外问题**

**预热阶段**：每个使用窗口或需要达到最小质量的估计算法部分都需要一个“预热阶段”，在此期间首次建立完整的数据窗口和/或质量。假设必须立即提供估计值（从第一个数据包开始的偏移量和绝对时钟，从第二个数据包开始的 \(\hat{p}\) 和差异时钟），我们简要描述了我们的方法的主要特点：

- \(\hat{r}(t)\)：不需要预热，但对于小样本量的点误差估计不应信任 → 定义基于RTT样本数量的预热窗口 \(T_w\)。
- \(\hat{p}(t)\)：在 \(T_w\) 内，使用一种局部速率类型的算法来利用 \(\Delta(t)\) 增加同时管理延迟误差，其中近端和远端窗口的初始宽度为1，并随着 \(\Delta(t)/4\) 增长。第一个估计值仅为朴素估计 \(\hat{p}_{2,1}\)。在 \(T_w\) 之后，应用第5.2节中的初始化。需要注意与窗口和水平偏移检测的交互。
- \(p_l(t)\)：只是一个改进，因此无需特殊预热 → 只有在 \(T_w\) 后有完整窗口 \(\bar{\tau}\) 时才激活。
- \(\hat{\theta}(t)\)：在 \(T_w\) 内，质量评估参数E增加，并填充SKM窗口，否则无变化。第一个估计值仅为服务器时间戳 \(T_{b,1}\)。

**窗口处理**：正如第4.1节末尾所讨论的，尽管CPU振荡器具有很高的稳定性，但由于多种原因，条件可能会随时间变化，因此最终必须忘记过去。在实践中，为了限制存储的每包历史数据量，这也是必要的。我们将其实现为一个顶层“滑动”窗口，宽度为 \(T\)，每隔 \(T/2\) 更新一次以限制计算负担。下面我们将 \(T\) 设置为1周。

顶层窗口直接影响 \(\hat{p}(t)\) 和最小估计 \(\hat{r}(t)\)，因为 \(\hat{p}_l(t)\) 和 \(\hat{\theta}(t)\) 已经基于有限且较小的窗口。当窗口达到全尺寸时，最旧的一半数据将被丢弃，并按以下方式进行更新：

- \(\hat{r}(t)\)：首先执行此操作。基于完整的历史数据集（现在宽为 \(T/2\)）计算新的值（实际上是在线计算的）。如果在窗口期间发生了向上水平偏移（见下文），则新值将仅基于最后一个检测到的偏移点之后的值。
- \(\hat{p}(t)\)：如果当前定义估计值的配对中的第一个数据包 \(j\) 被丢弃，则将其替换为新窗口中具有相似或更好点质量的第一个数据包。使用新配对计算总质量（由于 \(\Delta(t)\) 将约为 \(T/2\)，因此会很高），如果超过当前质量，则更新 \(\hat{p}(t)\)。

**点误差重新评估**：每当 \(\hat{p}(t)\) 和 \(\hat{r}(t)\) 更新时，过去的点误差实际上会发生变化，这会影响所有量的估计。对于未来的估计，使用新的点误差，但我们不会追溯性地改变已经计算的估计值。对于速率估计，这意味着当前用于估计的数据包 \(j\) 和 \(i\) 如果重新评估可能会被拒绝。我们不会这样做：它们仍然是当前的索引，但是速率估计的质量会被重新评估并正常用于算法中。上述原则适用于 \(\hat{p}(t)\) 和 \(\hat{r}(t)\) 发生变化的任何原因：正常的在线更新、窗口变化或水平偏移（见下文）。

**时钟偏移一致性**：更新 \(\hat{p}(t)\) 实际上重新定义了 \(C(t)\)，并在偏移估计中引起跳跃。虽然这在方程(7)的绝对时钟 \(C_a(t)\) 中被抵消，但我们通过向常数 \(C\) 添加 \(TSC(t^-)(\hat{p}(t^-) - \hat{p}(t))\) 来保持 \(\hat{\theta}(t)\) 的连续性，从而重新定义时钟，使其在更新前与旧时钟一致。

**丢失的数据包**：任何丢失的数据包都将被排除在分析之外。窗口 \((\tau^*, \tau^{\prime}, \bar{\tau}, T, T_s)\) 虽然名义上定义为时间间隔，但实际上基于维持一个固定数量的数据包，通过将名义间隔大小除以已知的轮询周期来计算。由于丢失的数据包比例通常很低，这导致时间尺度控制的漂移非常小，并大大简化了算法的细节。

为了防止使用局部速率改进时失去时间尺度控制的可能性，使用 \(T_{f,i}\) 时间戳来监控自上次数据包以来的时间。如果它相对于局部速率尺度太大（我们使用阈值间隙大小 \(\bar{\tau}/2\)），则认为局部速率已过期且不使用。此外，如果窗口内的数据包质量太低（根据第5.3节算法中的(iii)点精确定义），则稍微不同地形成估计，以增加新数据的重要性：在新的朴素估计（使用其点误差）和最近的 \(\hat{\theta}(t)\)（使用其估计误差的老化形式）之间进行加权求和。

图12总结了在标准默认轮询周期64秒和256秒下，完整的在线算法在连续3个月期间的性能。在此期间，我们的跟踪收集出现了两次主要中断，持续时间分别为约1.5小时和3.8天，以及一次服务器错误事件。尽管存在这些异常情况，性能始终保持非常良好到优秀，并且轮询率的变化对其影响不大。

**图9：关键参数对偏移估计误差的敏感性分析：(a) 窗口大小 \(\tau^{\prime}\)（\(E = 4\delta\)，有和没有局部速率：\(\bar{\tau} = 20\tau^*\)），(c) 轮询周期（\(\tau^{\prime} = \tau^*\)，\(E = 4\delta\)，没有局部速率）。从上到下，曲线分别是经验误差 \(\hat{\theta}(t) - \theta_g(t)\) 的99%、75%、50%（中位数）、25%和1%百分位。在每种情况下，敏感性都非常低。**

**图10：在四个不同运行环境下的性能（与图3相同的数据集）。从上到下：经验误差 \(\hat{\theta}(t) - \theta_g(t)\) 的99%、75%、50%、25%和1%百分位。**

**图12：在标准默认轮询周期64秒和256秒下，完整的在线算法在连续3个月期间的性能。在此期间，我们的跟踪收集出现了两次主要中断，持续时间分别为约1.5小时和3.8天，以及一次服务器错误事件。尽管存在这些异常情况，性能始终保持非常良好到优秀，并且轮询率的变化对其影响不大。**

**中位数 = -31 微秒**
**四分位距 = 15 微秒**

**中位数 = -33 微秒**
**四分位距 = 24.3 微秒**