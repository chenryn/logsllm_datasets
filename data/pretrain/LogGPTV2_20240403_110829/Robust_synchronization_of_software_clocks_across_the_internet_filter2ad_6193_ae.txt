]
s
m
[
s
e
t
a
m
i
t
s
e
t
e
s
f
f
O
naive
reference
algorithm
4
4.5
Tb [day]
5
5.5
Figure 8: Time series of ˆθi using the algorithm (without lo-
cal rates) against reference values, with naive estimates in the
background. The isolated jumps in the reference values are due
to timestamping noise in the (uncorrected) Tf,i.
In ﬁgure 9 the central curve shows the median of the difference of
the estimates from the corrected reference values θg(t), as a func-
tion of τ (cid:10)
, calculated over the entire 3 weeks. It is around 28µs over
a wide range of window sizes, and the inter-quartile range (the lines
above and below) is likewise very small, of the order of 11µs for the
optimal value at τ (cid:10)/τ ∗ = 0.5, again with low sensitivity to window
size. Even the range from the topmost (99th percentile) to the bot-
tommost (1st percentile) curve is only of the order of 50µs. Given
that our best current evaluation of the path asymmetry is around
∆ ≈ 50µs, which implies an ambiguity in offset of ∆/2 ≈ 25 µs
(equation (18)), and that timestamping issues limit the veriﬁability
of our results to around 5µs in any case, ﬁgure 9 suggest that the
algorithm is working very well in eliminating the variability in net-
work delay. Essentially identical results were obtained over the 3
month period of continuous monitoring (with gaps, see section 6)
using ServerInt, of which the current 3 week trace is a subset.
Figure 9(a) also compares the estimation with and without the
use of local rates. The differences are marginal, with local rate we
only gain some immunity to the effects of choosing a window size
too large. In either case, the insensitivity of the results to the precise
value of τ (cid:10)
is encouraging, and the fact the optimum is close to τ (cid:10) =
τ ∗
is precisely what we would expect from our SKM formulation,
and a natural validation of it.
Figure 9(b) examines the results as a function of the quality as-
sessment parameter E. Again very low sensitivity is found, with
optimal results being achieved at a small multiples of δ, as one
would expect. Since τ (cid:10) = τ ∗/2 here, the fact that using local rates
makes a negligible difference is consistent with ﬁgure 9(a).
We also performed sensitivity analyses with respect to the aging
rate parameter , and the local rate window width ¯τ. For each, the
sensitivity is so low for this relatively well behaved data that they
could be omitted entirely with little effect. These reﬁnements bring
tangible beneﬁts only under certain conditions, such as high loss,
where packets in the τ (cid:10)
window may be much further in the past
than intended (see ‘lost packets’ in section 6.1), or when parame-
ters have not been optimised for a given set of circumstances. For
example we found that using local rate also helped stabilise esti-
mates when E was selected too low.
We next examined the performance of the algorithm with respect
to polling period. We do not give results using the local rate reﬁne-
ment (they were very similar). We compare the period of 16 sec-
onds used so far with others, including the usual range of allowed
default values: 64 to 256. The sensitivity results with respect to
τ (cid:10)
were very similar to those reported in ﬁgure 9(a), although the
optimal ‘kink’ position moves to slightly larger values. The results
for E were unchanged beyond a slight spreading of the error distri-
bution.
We now keep the other parameters ﬁxed at τ (cid:10) = τ ∗
, E = 4δ,
and  = 0.02 PPM and vary the polling rate. Figure 9(c) shows
again that the sensitivity is very low. In particular the median error
(thick central line) only changed by a few microseconds despite a
reduction of raw information by a factor of 32 across the plot. This
is signiﬁcant since it is essential that NTP servers not be excessively
loaded. It also reduces the memory and computational burden at the
host.
Finally, we examine the performance of the algorithm over the
, E = 4δ, and ¯τ = 5τ ∗
four different traces, representing different host-server environments,
used in ﬁgure 3. We use τ (cid:10) = τ ∗
, and a
polling period of 64. We see the reduction in variability when mov-
ing from the laboratory into the more stable machine room, and
a further improvement when moving from ServerInt to the even
closer local server. The jump in median error when ServerExt is
used is due to the much increased path asymmetry. As before, the
(a)
(b)
(c)
]
s
µ
[
r
o
r
r
E
t
e
s
f
f
O
0
−10
−20
−30
−40
−50
−60
−70
no local rate
with local rate
0.0625
0.125
0.25
0.5
τ’/τ*
10
0
−10
−20
−30
−40
−50
−60
−70
−80
no local rate
with local rate
]
s
µ
[
r
o
r
r
E
t
e
s
f
f
O
1
2
4
1 2 3 4
7
10
E / δ
20
]
s
µ
[
r
o
r
r
E
t
e
s
f
f
O
20
0
−20
−40
−60
−80
−100
−120
16
32
64
Polling Period  [sec]
128
256
512
Figure 9: Sensitivity analysis of offset estimate errors with respect to key parameters: (a) window size τ (cid:10)
, (E = 4δ, with and without
local rate: ¯τ = 20τ ∗
), and (c) polling period (τ (cid:10) = τ ∗
,
E = 4δ without local rate). From top to bottom the curves are the 99%, 75%, 50% (the median) 25% and 1% percentiles of the
empirical errors ˆθ(t) − θg(t) . The sensitivity is very low in each case.
) (b) quality assessment E (τ (cid:10) = τ ∗/2, with and without local rate: ¯τ = 20τ ∗
0
−100
−200
−300
−400
−500
]
s
µ
[
r
o
r
r
E
t
e
s
f
f
O
Lab−Int
MR−Int
Host −− Server Environment
MR−Loc
MR−Ext
Figure 10: Performance over four different operating envi-
ronments (same data sets as ﬁgure 3). Top to bottom: 99%,
75%, 50% 25% and 1% percentiles of the empirical errors
ˆθ(t) − θg(t).
error is approximately ∆/2 using the values from table 2, much
smaller than the round-trip time of 14.2 ms. The increased vari-
ability is due to the higher noise resulting from the larger number
of hops, making quality packets much rarer. We should recall at
this point that here we are testing the algorithm in the extreme case
of a server that is much further away in all senses than necessary.
6. A ROBUST WORKING SYSTEM
In this section we address additional issues that are important to
complete the algorithms, and present results from a working on-
line implementation written in C. We also describe additional ro-
bustness issues and our solutions to them. For space reasons, we
cannot present detailed ﬂow diagrams. Full details will be made
available at [7] by way of a heavily structured and commented ref-
erence C implementation.
6.1 Additional Issues
Warmup Phase: Each part of the estimation algorithms which
uses a window, or requires a minimum quality to ﬁrst be reached,
needs a ‘warm up phase’ during which the full window of data
and/or quality is established for the ﬁrst time. We describe brieﬂy
the main features of our approach, under the assumption that esti-
mates must be made available immediately (offset and the absolute
clock from the ﬁrst packet, and ˆp and the difference clock from the
second).
• ˆr(t): Requires no warmup, but point error estimates based
on it should not be trusted for small sample size → deﬁne
warmup window Tw calibrated in number of RTT samples.
• ˆp(t): In Tw, use a local rate type algorithm to exploit ∆(t)
increase whilst managing delay errors, where the width of
the near and far windows is initially 1 and grows as ∆(t)/4.
The ﬁrst estimate is just the naive estimate ˆp2,1. After Tw,
the initialisation of section 5.2 applies. There are interac-
tions with windowing and level shift detection which must
be carefully managed.
• pl(t): Just a reﬁnement, so no special warmup → only acti-
• ˆθ(t): In Tw, the quality assessment parameter E is increased,
and the SKM window is ﬁlled up, otherwise no change. The
ﬁrst estimate is just the server timestamp Tb,1.
vated once a full window ¯τ available after Tw.
Windowing: As discussed at the end of section 4.1, despite the
high stability of the CPU oscillator, conditions may change over
time for many reasons, and so one must eventually forget the past.
This is also necessary in practice in order to limit the amount of
per-packet historical data that may be stored. We implement this
as a top level ‘sliding’ window of width T , updated at intervals of
T /2 to limit the computational burden. We set T to 1 week below.
The top level window only impacts directly on ˆp(t) and the min-
imum estimate ˆr(t), as ˆpl(t) and ˆθ(t) are already based on limited
(and much smaller) windows. When the window reaches full size,
the oldest half of the data is discarded and the updates occur as
follows:
• ˆr(t): This operation is performed ﬁrst. A new value is cal-
culated (actually was calculated on-line) based on the full set
(now T /2 wide) of historical data. If an upward level shift(s)
occurred during the window (see below), then the new value
will be based only on values beyond the last detected shift
point.
• ˆp(t):
If the ﬁrst packet j of the current pair deﬁning the
estimate was discarded, then it is replaced by the ﬁrst packet
in the new window of similar or better point quality. The
total quality using the new pair (which will be high as ∆(t)
will be of the order of T /2) is then calculated, and ˆp(t) is
updated if it exceeds the current quality.
Re-evaluation of Point Errors: Whenever the estimates ˆp(t) and
ˆr(t) are updated the past point errors effectively change, which im-
pacts on estimates of all quantities. For the purposes of future es-
timates the new point errors are used, however for simplicity we
do not retrospectively alter estimates already calculated. For rate
estimates, this means that the current packets j and i used in the es-
timate may actually be rejected if they were assessed again. We do
not do so: they remain the current indices, however the quality of
the rate estimate is reassessed and used as normal in the algorithms.
The above principle holds true regardless of the cause of a change
in ˆp(t) and ˆr(t): normal on-line updating, window change, or level
shift (see below).
Clock Offset Consistency: Updating ˆp(t) effectively redeﬁnes
the C(t) and results in a jump in the offset estimate. Although
this is cancelled in the absolute clock Ca(t) of equation (7), we
preserve the continuity of ˆθ(t) by adding TSC(t−)(ˆp(t−) − ˆp(t))
to the constant C, effectively redeﬁning the clock again so it agrees
with the old one just before the update.
Lost Packets: Any lost packets are simply excluded from the
analysis. The windows: (τ ∗, τ (cid:10), ¯τ , T, Ts), although nominally de-
ﬁned as time intervals, are in practice based on maintaining a ﬁxed
number of packets calculated by dividing the nominal interval size
by the known polling period. As the proportion of lost packets is
typically very low, this results in very little drift in the control of
time-scale, and greatly simpliﬁes the details of the algorithms.
To guard against the possibility of loss of time-scale control when
using the local rate reﬁnement, the Tf,i timestamps are used to mon-
itor the time since the previous packet. If it is too large compared
to the local rate scale (we use a threshold gap size of ¯τ /2) then the
local rate is deemed out of date and is not used. Furthermore, if
in addition the quality of packets in the window is too low (in the
precise sense deﬁned in point (iii) of the algorithm in section 5.3),
the estimate is formed slightly differently in order to increase the
importance of the new data: a weighted sum is made between the
new naive estimate, using its point error, and the most recent ˆθ(t),
using an aged form of its estimated error.
Figure 12 summarises the performance of the full on-line algo-
rithm over a continuous 3 month period for standard default polling
periods of 64 and 256 seconds. During this time, two major gaps
occured in our trace collection, of duration around 1.5 hours and
3.8 days, in addition to a server error event. Despite these anoma-
lies, the performance remained uniformly very good to excellent,
and did not change greatly with polling rate.
0.035
0.03
0.025
0.02
0.015
0.01
0.005
0
Median = −31 µs
IQR = 15 µs
Median = −33 µs
IQR = 24.3 µs
0.035
0.03
0.025
0.02
0.015
0.01
0.005