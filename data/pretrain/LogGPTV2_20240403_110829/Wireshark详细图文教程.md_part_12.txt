在包列表中选择一个你感兴趣的 TCP 包，然后选择 Wireshark 工具栏菜单的"Following TCP Streams"选项(或者使用
包列表鼠标右键的上下文菜单)。然后，Wireshark 就会创建合适的显示过滤器，并弹出一个对话框显示 TCP 流的所有
数据。如图 7.1 “"Follow TCP Stream"对话框”所示
注意
值得注意的是：Follow Tcp Stream 会装入一个显示过滤来选择你已经选择的 Tcp 流的所有包。
7.2.1. "Follow TCP Stream"对话框
图 7.1. "Follow TCP Stream"对话框
流的内容出现的顺序同他们在网络中出现的顺序一致。从 A 到 B 的通信标记为红色，从 B 到 A 的通信标记为蓝色。当
然，如果你喜欢的话你可以从"Edit/Preferences"菜单项的"Colores"修改颜色。
非打印字符将会被显示为圆点。XXX - What about line wrapping (maximum line length) and CRNL conversions?
在捕捉过程中，TCP 流不能实时更新。想得到最近的内容需要重新打开对话框。
你可以在此对话框执行如下操作：
1. Save As 以当前选择格式保存流数据。
2. Print 以当前选择格式打印流数据。
3. Direction 选择流的显示方向("Entire conversation", "data from A to B only" or "data from B to A only").
4. Filter out this stream 应用一个显示过滤，在显示中排除当前选择的 TCP 流。
5. Close 关闭当前对话框。移除对当前显示过滤的影响。
你可以用以下格式浏览流数据。
1. AsCII。在此视图下你可以以 ASCII 凡是查看数据。当然最适合基于 ASCII 的协议用，例如 HTTP.
2. EBCDIC。For the big-iron freaks out there.（不知道这句是什么意思， EBCDIC 是 IBM 公司的字符二进制
编码标准。）
3. HEX Dump. 允许你查看所有数据，可能会占用大量屏幕空间。适合显示二进制协议。
4. C Arrays. 允许你将流数据导入你自己的 C 语言程序。
5. RAW。 允许你载入原始数据到其他应用程序做进一步分析。显示类似与 ASCII 设置。但“save As”将会保存
为二进制文件。
7.3. 时间戳
时间戳，时间戳的精度，等等是在让人感到困惑。本节将向你介绍介绍 Wireshark 处理时间戳时都发生了什么。
在包被捕捉时，每个包在进入时都被加上时间戳，这个时间戳将会保存在捕捉文件中，所以他们也可以在以后分析时
使用。
那么说，时间戳是从哪里来的呢？是捕捉的时候产生的。Wireshark 从 libpcap(WinPcap) libraray(库)中获得时间
戳。而 libpcap(winpcap)又是从操作系统内核获得的时间。如果捕捉数据是从捕捉文件载入的，很显然 Wireshark 从
文件中获得时间戳数据。
7.3.1. Wireshark 内置
Wireshak 内置的格式使用的时间戳格式由日期(从 1.1.1970 开始)和时间（从凌晨起，纳秒(10 亿分之一秒)为单位）
组成。你可以调整 Wireshark 在包列表的时间戳显示方式。见第 3.7 节 “"View"菜单”的"Time Display Format"
项。
当读取或写入捕捉文件时，Wireshark 按需要在内置格式和其他捕捉文件格式间进行时间戳转换。
捕捉时，Wireshark 使用 libpcap(WinPcap)捕捉库（支持纳秒精度）。除非你在专用的捕捉硬件上进行捕捉，一般这
样的精度已经足够了。
7.3.2. 捕捉文件格式
Wireshark 支持的捕捉文件格式都带有时间戳。不同的捕捉文件格式的时间戳精度有很大不同，从秒"0"到纳秒
"0.123456789"都有。大多数格式捕捉文件存储的时间戳都是固定精度的，些捕捉文件格式甚至存储了时间戳精度本身
（可能是出于方便）。
大多数被 Wireshark(和或多其他工具)使用的 libpcap 捕捉文件格式都仅支持固定的百万分之一固定精度"0.123456"
注意
写入数据到一个实际支持精度比你写入数据精度低的格式文件中，可能会导致数据丢失。例如：如果你载入一
个纳秒精度的捕捉文件，然后将其存储为 libpcap 文件(百万分之一秒精度)。Wireshark 很明显会将时间精度
调整为百万分之一秒。
7.3.3. 准确性
经常有人问："Wireshark 的时间戳的准确性如何？"。实际上，Wireshark 自身不会创建时间戳，而是通过其他的地方
得到时间并显示他们。所以，准确性取决于你实用的捕捉系统(操作系统，性能。。。)。因此以上问题很难通过通常
的途径回答。
注意
通常 USB 连接的网络适配器提供的精度非常差。入口的实际上“占用很长的时间和走很曲折的路”才能穿过
USB 数据线到系统内核。而数据包只有被系统内核处理过以后才会打上时间戳，这种时间戳机制将会导致准确
性大大降低。
结论：如果你需要精确的时间戳，请不要使用 USB 连接的网卡！(笔者的注脚：有没有网卡在 USB 硬件上提前
加上时间戳的？)[17]
7.4. 时区
当你在各地旅行时，会碰到时区的困扰。如果你从其他时区得到捕捉文件，时区问题会给你带来更大的困扰:-)
首先，下面有两个原因说明你为什么完全不需要考虑时区问题：
• 你仅对两个包的时间戳的差别有兴趣，你并不需要了解捕捉包的实际的日期和时间(通常是这样)。
• 很可能你不会得到不同与你所在时区的包文件，所以你基本上碰不到时区问题。例如：你的团队的所有都和你
工作在一个时区。
表 7.1.
什么是时区?
人们希望时间和日升日落对应。早成应该是 6 点钟，天黑应该在 20：00.这些时间又随着四季变化。如果地球上每个
人使用同样的全局时间，将只有一小部分人的日落和时间对应，这将会导致混乱。
因此，人们将地球划分为不同的区域，每个区域都有一个本地时间对应本地的日升日落。
时区基于 UTC(Coordinated Universal Time)或者 Zulu 时间(军事和航空)。旧有的 GTM(格林尼治时间)已不再使用，
因为它有少许误差(与 UTC 相比达到 0.9 秒)。UTC 起始时区等于 0(位于格林威治，英格兰)，所有的时区和它的偏在在
-12~+14 小时之间！
例如：如果你住在柏林，你的时区将比 UTC 早 1 小时，所以你的时区应该是"+1"(与 UTC 时间比较的差别，以小时为单
位)。柏林的 3 点和 UTC 的两点钟表示同一个时刻。
有些地区要加以注意，因为那里的时区不是用整小时的。(比如：新德里的时区是 UTC+05:30)
更多相关信息见 http://en.wikipedia.org/wiki/time_zone 和
http://en.wikipedia.org/wiki/Coordinated_Universal_Time。
表 7.2.
什么是时 DST?
Daylight Saving Time(DST),又称为夏令时，目的是在夏天的几个月里“拯救”白天的时间(夏季白昼较长，如果按照
传统的作息时间，比较可惜，不过我不认为)。为了达到这个目的，很多国家（但不是所有的）增加一个 DST 小时到
UTC 中。所以你还得加个小时(极少数地方甚至是 2 小时)的时差来计算你的时区。
不幸的是，DST 并未在全世界范围内被启用。你可能同样注意到，北半球和南半球的夏令时是刚好相反的（比如：欧
洲是夏季时，澳大利亚则是冬季）。
注意：不管 DST 怎样，UTC 在全年都是一致的。
更多相关信息见 http://en.wikipedia.org/wiki/Daylight_saving.
7.4.1. 正确设置你的计算机的时区
如果你同世界各地的人一同工作，正确设置计算机时区非常有必要。
你应当按正确的顺序设置时间和时区
1. 设置正确的时区。
2. 设置本地时间。
这样的顺序将告诉你的计算机本地时间和时区。
提示
如果你去各地旅行，通常可能会犯尝试调整计算机本地时间的错误。实际上并不需要这样做，仅仅调整时区
就可以了。在计算机上，时间实际上没有发生变化，你只是在不同时区采用不同的本地时间而已。
提示
你可以使用网络时间协议(Network Time Protocol NTP)通过与互联网上的 NTP 授时服务器同步来自动调整你
的计算机的时间。Wireshark 支持的所有平台都可以使用 NTP 客户端，可参见 http://www.ntp.org/的介绍。
7.4.2. Wireshark 和时区的关系
那么，Wireshark 和时区到底有什么关系？
Wireshark 原生的捕捉文件格式(libpcap 格式),和一些其他格式，例如 sniffer,EtherPeek,AiroPeek 和 Sun snoop
格式，都将包到达时间存储为 UTC 时间。UNIX 系统，Windos NT 系统(NT 4.0,2000,xp,2003,vista)在系统内部都将时
间表示为 UTC.当 Wireshark 进行捕捉时，无需进行转换。但如果你没有正确设置时区，即使系统时钟正确显示了本地
时间，UTC 时间也有可能是错误的。"windows 9X 系列(win95,98,winMe)"在系统内部以本地时间表示时间。在捕捉时，
WinPcap 必须将时间转换为 UTC 时间再发送给 Wireshark.如果时区设置错误，转换时间也不会正确。
其他捕捉格式，如 Microsoft Network Monitor,Dos-based Sniffer,和 Network Instruments Observer 格式，保存
包到达时间为本地时间。
在 Wireshark 内部，时间戳以 UTC 时间显示；这意味着，如果要读取那些保存包达到时间为本地时间的捕捉文件，
Wireshark 需要将本地时间转换为 UTC 时间。
随后 Wireshark 会始终以本地时间显示时间戳。用于显示捕捉数据的计算机会将 UTC 时间转换为本地时间，并显示这
个这个本地时间。对于那些是以 UTC 值来存储包到达时间的捕捉文件，这意味着到达时间会显示为你所在时区的本地
时间，这很有可能同与你不同时区的捕捉数据的人看到的到达时间不一样。对于那些以本地时间存储包到达时间的包
文件，时区转换会使用你所在的时区与 UTC 偏差，以及 DST 规则进行转换，这很可能会导致错误时间显示，将显示设
置修改改为显示本地时间可能会修正这个错误，这样现实的时间值可能会与捕捉文件到达时间一致。
表 7.3. 各时区 UTC 到达时间
Los Angeles New York Madrid London Berlin Tokyo
Capture File(UTC) 10:00 10:00 10:00 10:00 10:00 10:00
Local Offset to UTC -8 -5 -1 0 +1 +9
Displayed Time(local Time) 02:00 05:00 09:00 10:00 11:00 19:00
举例：假定有人在洛杉矶本地时间临晨 2:00 点整捕捉了一个包，然后发送给你包含那个包的文件。那个包在包文件中
的时间戳将是 UTC 时间 10:00.你在柏林打开后会看到那个包显示的时间是 11:00 点。
假设现在你和你的同事正在通过电话，视频会议，或者网络会议讨论那个包文件。前面提到的那个包，在洛杉矶的朋
友看到的依然是 2:00,而你看到的却是 11:00。对同一个时间点，两个地方会显示不同的本地时间。
结论：你可能不介意你看到的时间戳的日期/时间显示，除非你确实需要正确设置时间/日期。所以，如果你得到一个
其他时区/DST 的捕捉文件，你必须了解两地的时区/DST 的不同，对时间戳做合适的调整。无论怎样，确定每台电脑都
正确设置了时间和时区。
7.5. 合并包
7.5.1. 什么是合并包
网络协议经常需要传输较大的数据块，在传输时，底层协议可能不支持这样大的数据块(比如网络包大小的限制)，或
者是像像 TCP 一样的流数据,TCP 流完全不知道数据分块情况。(原文为:or is stream-based like TCP, which doesn't
know data chunks at all.)
在这种情况下，网络协议必须确定数据块分段的边界，并(如果有必要)将数据块分割为多个包。很明显在接受端也需
要有找到数据块分段边界的机制。
提示
在 Wireshark 里面，这个机制/方法被称为合并/reasembling，在特定协议的描述可能不尽相同(例如：
desegmentation, defragmentation, ...)
7.5.2. 如何用 Wireshark 合并包
对那些可以被 Wireshark 识别的协议，Wireshark 通常处理过程为：查找、解码、显示数据块。Wireshark 会尝试查找
数据块对应的包，在"Packet Bytes"面板的附加页面显示合并以后的数据。(关于“Packet Bytes”面板的详细介绍，
见第 3.7 节 “"View"菜单”)
图 7.2. 带有合并包附加选项卡"Packet Bytes 面板"
注意
合并可能发生在多个协议层，所以在"Packet Bytes"面板可能会见到多个附加页选项卡
注意
你会在数据块的最后一个包看到合并后的数据。
以HTTP Get应答为例：请求数据(例如一个HTML页面)返回时。Wireshark会显示一个16进制转储数据在"Packet Bytes"
面板的一个名为"Uncompressed entity body"新选项卡。
默认情况下，首选项中合并功能被设置为允许。在 2005 年 9 月之前默认值是不允许。如果你的首选项是在 200 年 9
月之前设置的，你得确认一下，合并包选项的设置。合并包对分析网络包作用非常大。
允许和禁止合并包设置对协议来说还有两项要求。
1. 下层的协议(如：TCP)必须支持合并。通常协议支持合并与否都是通过协议的参数设置的。
2. 高层协议协议(如:HTTP)必须使用合并机制来合并分片的数据。这些也同样可以通过协议参数来允许或禁止。
在设置高层协议的时候 tooltip 会提醒你同样需要考虑低层的协议设置。
7.6. 名称解析
名字解析尝试将数字地址解析成适合人们阅读格式。有两种方法可以完成这项工作：通过系统/网络服务(例如获取主
机名)和/或 Wireshark 指定的赋值文件。关于通过赋值文件进行解析的详情，可以参见???
名字解析可以分协议层进行允许，禁止设置。
7.6.1. 名字解析的流弊
名字解析在使用 Wireshark 时有重要价值，甚至可以节约大量时间。不幸的是，名字解析也有它自己的缺点。
• 名字解析经常会不可用。服务器可能不知道需要被解析的名字，或者服务器不可用。又或者需要解析的名字在
赋值配置文件中找不到。
• 名字解析并没有存储在捕捉文件或其他什么地方。因此你以后打开捕捉文件或者在其他设备上打开文件有可能
发现名字解析不可用。每次打开捕捉文件可能会发现部分地址略微发生变化，也许仅仅是因为无法连接到名字
解析服务器(之前还是可以连接的)
• DNS可能会增加额外的包到 Wireshark中。你会在包文件中看到由 Wireshark 请求 DNS 服务生成的包进出你的
机器。
• 解析名称被 Wireshark 缓存。这对设备性能有一定需求。但是，如果名字解析信息在 wireshark 运行时发生变
化，wireshark 不会注意到这个变化，因为它是从缓存进行解析的。如果这些信息在 Wireshark 运行时变化了，
例如获取一个新 DHCP 租约，Wireshark 不会注意到。(这些是针对 DNS 还是所有信息？有多少机器使用动态 dns
注册？)
提示
名字解析在包列表填入时已经完成。如果一个包填入包列表以后被解析，包列表的内容不会立即更改，相反解
析结果会被缓存，你可以使用"View/Reload"重建包列表，来正确显示名字解析结果。但在捕捉过程中这样做
没有效果。
7.6.2. 以太网名字解析(mac 层)
尝试将 MAC 地址(e.g. 00:09:5b:01:02:03)解析为适合阅读的地址（"Human readable"）
ARP名字解析(系统服务) Wireshark 会向操作系统发出请求，将以太网地址转换为对应的 IP 地址(e.g.
00:09:5b:01:02:03->192.168.0.1)