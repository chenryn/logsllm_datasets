title:Mantis: Reactive Programmable Switches
author:Liangcheng Yu and
John Sonchack and
Vincent Liu
Mantis:	Reactive	Programmable	Switches
L i a n g c h e n g 	 Y u , 	 J o h n 	 S o n c h a c k , 	 V i n c e n t 	 L i u
To d a y ’ s   N e t w o r k s   R e a c t
• A common task: reacting to current network conditions 
• Detecting failures and then rerouting 
• Identifying malicious flows and then filtering 
• Recognizing load imbalance and then adjusting
• In data centers, reactions need be fast
To d a y ’ s   P r i m i t i v e s   f o r   R e a c t i o n
SDNs or conventional control loops 
Flexible but slow
Built-in data plane primitives 
Fast but restrictive 
Programmable switches? 
Constraints on operations in actions, number of stages, SRAM 
accesses, egress/ingress communication, in-band match-action 
updates…
To d a y ’ s   P r i m i t i v e s   f o r   R e a c t i o n
Can we enable fine-grained reactions with  
minimum latency and maximum flexibility?
SDNs or conventional control loops 
Flexible but slow
Built-in data plane primitives 
Fast but restrictive 
Programmable switches? 
Constraints on operations in actions, number of stages, SRAM 
accesses, egress/ingress communication, in-band match-action 
updates…
A p p r o a c h
Can we enable fine-grained reactions with  
minimum latency and maximum flexibility?
1. Push the reactions as close to the switch ASIC as possible 
2. Co-design the data plane program for fine-grained malleability 
and ease of use
M a n t i s   O v e r v i e w
Usable, fast, and expressive in-network reactions on today’s RMT switches
Simple extension to P4
Arbitrary C code
10s of us
Generates code for dynamic reconfigurability/serializability
A b s t r a c t i o n
1. Malleable entities 
• Amenable to fine-grained reconfiguration at runtime 
2. Reactions 
• Package reaction logic into a C-like function
A n a t o m y   o f   M a n t i s
1
2
4
3
M1   Language 
M2   Translation 
M3   Isolation 
M4   Execution
M 1 :   S t a r t   w i t h   P 4   C o d e
foo.p4
table my_table {  
  reads { ipv4.dst : ternary; }  
  actions { my_action; drop; }  
} 
action my_action() {  
  modify_field(priority, 1);  
} 
How to make it run time reconfigurable?
foo.p4r
M 1 :   P 4 R   E x a m p l e
table my_table {  
  reads { ipv4.dst : ternary; }  
  actions { my_action; drop; }  
} 
action my_action() {  
  modify_field(priority, 1);  
} 
M 1 :   P 4 R   E x a m p l e
foo.p4r
malleable value prio_var {  
  width : 16; init : 1;  
}  
table my_table {  
  reads { ipv4.dst : ternary; }  
  actions { my_action; drop; }  
} 
action my_action() {  
  modify_field(priority, ${prio_var});  
} 
Declaring malleable entities
Previous P4 code with 
references to malleable entities
M 1 :   P 4 R   E x a m p l e
foo.p4r
malleable value prio_var {  
  width : 16; init : 1;  
}  
table my_table {  
  reads { ipv4.dst : ternary; }  
  actions { my_action; drop; }  
} 
action my_action() {  
  modify_field(priority, ${prio_var});  
} 
reaction my_reaction(reg re_qdepths[1:10]){  
  uint16_t cur_max = 0; 
  for (int i = 1; i  cur_max) { 
      cur_max = re_qdepths[i];  
    } 
  } 
  if (cur_max > THRESHOLD) { 
    ${prio_var} = 5; 
  }  
} 
Declaring malleable entities
Previous P4 code with 
references to malleable entities
Specifying reaction arguments
Reaction with arbitrary C
Reconfiguration
M 1 :   P 4 R   E x a m p l e
foo.p4r
malleable value prio_var {  
  width : 16; init : 1;  
Malleable entities 
}  
• Malleable value 
table my_table {  
  reads { ipv4.dst : ternary; }  
• Malleable field (table match, action…) 
  actions { my_action; drop; }  
• Malleable table 
} 
action my_action() {  
Reaction function arguments 
  modify_field(priority, ${prio_var});  
• Register 
} 
• Field 
reaction my_reaction(reg re_qdepths[1:10]){  
  uint16_t cur_max = 0; 
• Malleable field 
  for (int i = 1; i  cur_max) { 
      cur_max = re_qdepths[i];  
    } 
  } 
  if (cur_max > THRESHOLD) { 
    ${prio_var} = 5; 
  }  
} 
Reaction with arbitrary C
Reconfiguration
Declaring malleable entities
Previous P4 code with 
references to malleable entities
Specifying reaction arguments
A n a t o m y   o f   M a n t i s
1
2
4
3
M1   Language 
M2   Translation 
M3   Isolation 
M4   Execution
M 2 :   P 4 R   Tr a n s f o r m a t i o n
foo.p4r
malleable value prio_var {  
  width : 16; init : 1;  
}  
table my_table {  
  reads { ipv4.dst : ternary; }  
  actions { my_action; drop; }  
} 
action my_action() {  
  modify_field(priority, ${prio_var});  
}
Generalize user-specified knobs for “hitless” reconfiguration
M 2 :   P 4 R   Tr a n s f o r m a t i o n
foo.p4r
malleable value prio_var {  
  width : 16; init : 1;  
}  
table my_table {  
  reads { ipv4.dst : ternary; }  
  actions { my_action; drop; }  
} 
action my_action() {  
  modify_field(priority, ${prio_var}p4r_meta_.prio_var);  
} 
header_type p4r_meta_t_ { 
  field {prio_var : 16;} 
} 
metadata p4r_meta_t_ p4r_meta_;
Replace the malleable value
M 2 :   P 4 R   Tr a n s f o r m a t i o n
foo.p4r
malleable value prio_var {  
  width : 16; init : 1;  
}  
table my_table {  
  reads { ipv4.dst : ternary; }  
  actions { my_action; drop; }  
} 
action my_action() {  
  modify_field(priority, ${prio_var}p4r_meta_.prio_var);  
} 
header_type p4r_meta_t_ { 
  field {prio_var : 16;} 
} 
metadata p4r_meta_t_ p4r_meta_; 
table p4r_init_ { 
  actions {p4r_init_action_;} 
  size : 1; 
} 
action p4r_init_action_(prio_var) { 
  modify_field(p4r_meta_.prio_var, prio_var); 
} 
Replace the malleable value
Multi-purpose initialization table
A n a t o m y   o f   M a n t i s
1
2
4
3
M1   Language 
M2   Translation 
M3   Isolation 
M4   Execution
M 3 :   I s o l a t i o n   ( A C I D )
Isolation matters, consider
reaction my_reaction(reg src, reg dst){}
2
• Expectation: src ← p1, dst ← p1
p2
• Without isolation: src ← p1, dst ← p2
dst
Mantis enforces per-pipeline, per-reaction serializable isolation
1
p1
src
Mantis Agent
Measurement
t
Packet 
processing
Update
M 3 :   I s o l a t i n g   M e a s u r e m e n t
src register
dst register
p4r_meta_.mv=0
p4r_meta_.mv=1
idx0
idx0
idx1
idx1
Storing field arguments values
Checkpoint
Working copy
For a register, at most one element will be updated on a packet thread
Stale values may appear in the current checkpoint for register arguments
Timestamps   appended 
to the duplicate buffer
ti
)}
{(
ri, ti
Data plane
ti > ti−1
else
Control plane
M 3 :   I s o l a t i n g   U p d a t e s
Three-phase updates for isolating fast, repeated, partial updates
vv=0 (exact match)
Match
Action
hdr.a=0, vv=0 my_action(0)
hdr.a=0, vv=1 my_action(0)
hdr.a=1, vv=0 my_action(1)
hdr.a=1, vv=1 my_action(1)
From previous mirror phase
vv=0
Match
Action
hdr.a=0, vv=0 my_action(0)
hdr.a=0, vv=1 my_action(0)
hdr.a=1, vv=0 my_action(1)
hdr.a=1, vv=1 my_action(2)
Prepare updates in vv=1 
copy for malleable entities
vv=1
Match
Action
hdr.a=0, vv=0 my_action(0)
hdr.a=0, vv=1 my_action(0)
hdr.a=1, vv=0 my_action(2)
hdr.a=1, vv=1 my_action(2)
Mirror the changes to the 
shadow copy for amortization
vv ⊕ 1
Commit
Bounded memory overhead and predictable latency
A n a t o m y   o f   M a n t i s
1
2
4
3
M1   Language 
M2   Translation 
M3   Isolation 
M4   Execution
M 4 :   M a n t i s   C o n t r o l   P l a n e
Traditionally data/control plane interactions are treated as one-off, 
isolated events, i.e., assumed to be “on the slow path”
Mantis control plane is instead reaction-centric
  helper_state = precompute_metadata(); 
  memo = setup_cache(helper_state); 
  run_user_initialization(helper_state, memo); 
  while(!stopped) { 
    updateTable(memo, "p4r_init_", {measure_ver : mv ^ 1}); 
    read_measurements(memo, mv); mv ^= 1; 
    run_user_reaction(memo, helper_state, vv ^ 1); 
    updateTable(memo, "p4r_init_", {config_ver : vv ^ 1}); 
    fill_shadow_tables(memo, vv); vv ^= 1; 
  }
Dialogue
Prologue
~PCIe latency of the underlying system
I m p l e m e n t a t i o n   a n d   E v a l u a t i o n
Prototype implementation on a Wedge100BF-32X Tofino switch 
• P4R frontend: Flex/Bison based, ~5000 lines of C++ and grammar 
• Mantis agent: dynamic (re)loading of user reaction (.so object)
https://github.com/eniac/Mantis
D e m o
I m p l e m e n t a t i o n   a n d   E v a l u a t i o n
Prototype implementation on a Wedge100BF-32X Tofino switch 
• P4R frontend: Flex/Bison based, ~5000 lines of C++ and grammar 
• Mantis agent: dynamic (re)loading of user reaction (.so object)
Evaluation 
• How fast is Mantis’s reaction time?  
• What is the overhead? 
• What are the applications of Mantis? 
• How does Mantis compare to existing alternatives?
M a n t i s   A c h i e v e s   F a s t   R e a c t i o n   T i m e s  
a: Reaction argument
b: Malleable entity update
Fb(1 tblMod) + ∑
a∈args(Fa(a)) + C + ∑
End-to-end reaction time: 10s of us
t∈tblMods(2Fb(t)) + 2Fb(Ninit − 1) + Fb(1 tblMod)
M a n t i s   C P U   O v e r h e a d
A dialogue loop occupies up to a single core but can be throttled
Latency penalty 
median: ~4.64% 
p99: ~6.45% 
Overall, Mantis can co-exist with other functionalities
DoS mitigation
Measurement
Flow signature, 
packet count 
U s e   C a s e s
Route 
Recomputation
Heartbeat counts, 
timestamp
Hash polarization 
mitigation
Queue depths of 
ECMP ports
Control logic
Reconfiguration
Block the sender 
if the estimated 
flow size exceeds 
a threshold
Drop the 
malicious traffic 
for the blocked 
senders
Mark the failed link if 
received heartbeat 
number is small than 
expected after 
consecutive K 
confirmations
Reroute traffic 
towards the affected 
link
Change ECMP 
hashing input to 
another permutation 
if found a persistent 
imbalance of port 
utilization
Reconfigure the 
malleable fields for 
another 5-tuple 
permutation
Reinforcement 
Learning
Packet counts and 
queue depths
Use a Q-learning 
algorithm to 
calculate the optimal 
ECN threshold 
based on rewards
Change ECN 
malleable value
F l o w   S i z e   E s t i m a t i o n
• CAIDA traces, 20s chunk, 10Gbps link of ISP 
• Evaluation setting 
backbone  
• Arguments 
• Algorithm 
• packet source IP and packet counter 
• Estimation formula 
t0
•
: timestamp when first observe the flow 
• Mantis sampling rate: every 10us, ~1 in 5 packets
̂ft − ̂ft0
t − t0
S u m m a r y
• Fine-grained reaction to network statistics as first class citizen 
• P4R interface to simplify the encoding of serializable reaction 
• Generic support of sub-RTT reactive behaviors 
Mantis can be used for… 
• Encoding flexible control logic 
• Workarounds of current limitations 
• Reducing memory overhead via offloading 
• Data/control plane co-design
https://github.com/eniac/Mantis
Thank you for your attention!
L i v e   Q & A