encounter diffi culties getting them to work against IE. Also, features specifi c to
Firefox have historically allowed a range of attacks to work that are not possible
against IE, as described in Chapter 13.
cc2200..iinndddd 774499 88//1199//22001111 1122::2211::0044 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 750
750 Chapter 20 n A Web Application Hacker’s Toolkit
A large number of browser extensions are available for Firefox that may be
useful when attacking web applications, including the following:
n HttpWatch is also available for Firefox.
n FoxyProxy enables fl exible management of the browser’s proxy confi gu-
ration, allowing quick switching, setting of different proxies for different
URLs, and so on.
n LiveHTTPHeaders lets you modify requests and responses and replay
individual requests.
n PrefBar allows you to enable and disable cookies, allowing quick access
control checks, as well as switching between different proxies, clearing
the cache, and switching the browser’s user agent.
n Wappalyzer uncovers technologies in use on the current page, showing
an icon for each one found in the URL bar.
n The Web Developer toolbar provides a variety of useful features. Among
the most helpful are the ability to view all links on a page, alter HTML
to make form fi elds writable, remove maximum lengths, unhide hidden
form fi elds, and change a request method from GET to POST.
Chrome
Chrome is a relatively new arrival on the browser scene, but it has rapidly gained
popularity, capturing approximately 15% of the market.
A number of browser extensions are available for Chrome that may be useful
when attacking web applications, including the following:
n XSS Rays is an extension that tests for XSS vulnerabilities and allows
DOM inspection.
n Cookie editor allows in-browser viewing and editing of cookies.
n Wappalyzer is also available for Chrome.
n The Web Developer Toolbar is also available for Chrome.
Chrome is likely to contain its fair share of quirky features that can be used
when constructing exploits for XSS and other vulnerabilities. Because Chrome
is a relative newcomer, these are likely to be a fruitful target for research in the
coming years.
cc2200..iinndddd 775500 88//1199//22001111 1122::2211::0055 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 751
Chapter 20 n A Web Application Hacker’s Toolkit 751
Integrated Testing Suites
After the essential web browser, the most useful item in your toolkit when
attacking a web application is an intercepting proxy. In the early days of web
applications, the intercepting proxy was a standalone tool that provided minimal
functionality. The venerable Achilles proxy simply displayed each request and
response for editing. Although it was extremely basic, buggy, and a headache
to use, Achilles was suffi cient to compromise many a web application in the
hands of a skilled attacker.
Over the years, the humble intercepting proxy has evolved into a number
of highly functional tool suites, each containing several interconnected tools
designed to facilitate the common tasks involved in attacking a web application.
Several testing suites are commonly used by web application security testers:
n Burp Suite
n WebScarab
n Paros
n Zed Attack Proxy
n Andiparos
n Fiddler
n CAT
n Charles
These toolkits differ widely in their capabilities, and some are newer and
more experimental than others. In terms of pure functionality, Burp Suite is
the most sophisticated, and currently it is the only toolkit that contains all the
functionality described in the following sections. To some extent, which tools
you use is a matter of personal preference. If you do not yet have a preference,
we recommend that you download and use several of the suites in a real-world
situation and establish which best meets your needs.
This section examines how the tools work and describes the common work
fl ows involved in making the best use of them in your web application testing.
How the Tools Work
Each integrated testing suite contains several complementary tools that share
information about the target application. Typically, the attacker engages with the
cc2200..iinndddd 775511 88//1199//22001111 1122::2211::0055 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 752
752 Chapter 20 n A Web Application Hacker’s Toolkit
application in the normal way via his browser. The tools monitor the resulting
requests and responses, storing all relevant details about the target application
and providing numerous useful functions. The typical suite contains the fol-
lowing core components:
n An intercepting proxy
n A web application spider
n A customizable web application fuzzer
n A vulnerability scanner
n A manual request tool
n Functions for analyzing session cookies and other tokens
n Various shared functions and utilities
Intercepting Proxies
The intercepting proxy lies at the heart of the tool suite and remains today the
only essential component. To use an intercepting proxy, you must confi gure
your browser to use as its proxy server a port on the local machine. The proxy
tool is confi gured to listen on this port and receives all requests issued by the
browser. Because the proxy has access to the two-way communications between
the browser and the destination web server, it can stall each message for review
and modifi cation by the user and perform other useful functions, as shown in
Figure 20-2.
Configuring Your Browser
If you have never set up your browser to use a proxy server, this is easy to do on
any browser. First, establish which local port your intercepting proxy uses by
default to listen for connections (usually 8080). Then follow the steps required
for your browser:
ÿ ÿ ÿ
n In Internet Explorer, select Tools Internet Options Connections
LAN settings. Ensure that the “Automatically detect settings” and “Use
automatic confi guration script” boxes are not checked. Ensure that the “Use
a proxy server for your LAN” box is checked. In the Address fi eld, enter
127.0.0.1, and in the Port fi eld, enter the port used by your proxy. Click
the Advanced button, and ensure that the “Use the same proxy server for
all protocols” box is checked. If the hostname of the application you are
attacking matches any of the expressions in the “Do not use proxy server
cc2200..iinndddd 775522 88//1199//22001111 1122::2211::0055 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 753
Chapter 20 n A Web Application Hacker’s Toolkit 753
for addresses beginning with” box, remove these expressions. Click OK
in all the dialogs to confi rm the new confi guration.
ÿ ÿ ÿ ÿ
n In Firefox, select Tools Options Advanced Network Settings.
Ensure that the Manual Proxy Confi guration option is selected. In the HTTP
Proxy fi eld, enter 127.0.0.1, and in the adjacent Port fi eld, enter the port
used by your proxy. Ensure that the “Use this proxy server for all proto-
cols” box is checked. If the hostname of the application you are attacking
matches any of the expressions in the “No proxy for” box, remove these
expressions. Click OK in all the dialogs to confi rm the new confi guration.
n Chrome uses the proxy settings from the native browser that ships with
the operating system on which it is running. You can access these set-
ÿ ÿ
tings via Chrome by selecting Options Under the Bonnet Network
ÿ
Change Proxy Settings.
Figure 20-2: Editing an HTTP request on-the-fly using an intercepting proxy
cc2200..iinndddd 775533 88//1199//22001111 1122::2211::0055 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 754
754 Chapter 20 n A Web Application Hacker’s Toolkit
WORKING WITH NON-PROXY-AWARE CLIENTS
Occasionally, you may fi nd yourself testing applications that use a thick cli-
ent that runs outside of the browser. Many of these clients do not offer any
settings to confi gure an HTTP proxy; they simply attempt to connect directly
to the web server hosting the application. This behavior prevents you from
simply using an intercepting proxy to view and modify the application’s
traffi c.
Fortunately, Burp Suite offers some features that let you continue working
in this situation. To do so, you need to follow these steps:
1. Modify your operating system hosts file to resolve the hostnames used by
the application to your loopback address (127.0.0.1). For example:
127.0.0.1 www.wahh-app.com
This causes the thick client’s requests to be redirected to your own
computer.
2. For each destination port used by the application (typically 80 and 443),
configure a Burp Proxy listener on this port of your loopback interface,
and set the listener to support invisible proxying. The invisible proxying
feature means that the listener will accept the non-proxy-style requests
sent by the thick client, which have been redirected to your loopback
address.
3. Invisible mode proxying supports both HTTP and HTTPS requests. To pre-
vent fatal certificate errors with SSL, it may be necessary to configure your
invisible proxy listener to present an SSL certificate with a specific host-
name which matches what the thick client expects. The following section
has details on how you can avoid certificate problems caused by inter-
cepting proxies.
4. For each hostname you have redirected using your hosts file, configure
Burp to resolve the hostname to its original IP address. These settings
ÿ ÿ
can be found under Options Connections Hostname Resolution.
They let you specify custom mappings of domain names to IP addresses
to override your computer’s own DNS resolution. This causes the outgo-
ing requests from Burp to be directed to the correct destination server.
(Without this step, the requests would be redirected to your own com-
puter in an infinite loop.)
cc2200..iinndddd 775544 88//1199//22001111 1122::2211::0055 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 755
Chapter 20 n A Web Application Hacker’s Toolkit 755
WORKING WITH NON-PROXY-AWARE CLIENTS
5. When operating in invisible mode, Burp Proxy identifies the destina-
tion host to which each request should be forwarded using the Host
header that appears in requests. If the thick client you are testing does
not include a Host header in requests, Burp cannot forward requests cor-
rectly. If you are dealing with only one destination host, you can work
around this problem by configuring the invisible proxy listener to redirect
all its requests to the required destination host. If you are dealing with
multiple destination hosts, you probably need to run multiple instances
of Burp on multiple machines and use your hosts file to redirect traffic for
each destination host to a different intercepting machine.
Intercepting Proxies and HTTPS
When dealing with unencrypted HTTP communications, an intercepting proxy
functions in essentially the same way as a normal web proxy, as described in
Chapter 3. The browser sends standard HTTP requests to the proxy, with the
exception that the URL in the fi rst line of the request contains the full hostname
of the destination web server. The proxy parses this hostname, resolves it to
an IP address, converts the request to its standard nonproxy equivalent, and
forwards it to the destination server. When that server responds, the proxy
forwards the response back to the client browser.
For HTTPS communications, the browser fi rst makes a cleartext request to
the proxy using the CONNECT method, specifying the hostname and port of the
destination server. When a normal (nonintercepting) proxy is used, the proxy
responds with an HTTP 200 status code and keeps the TCP connection open.
From that point onward (for that connection) the proxy acts as a TCP-level relay
to the destination server. The browser then performs an SSL handshake with
the destination server, setting up a secure tunnel through which to pass HTTP
messages. With an intercepting proxy, this process must work differently so
that the proxy can gain access to the HTTP messages that the browser sends
through the tunnel. As shown in Figure 20-3, after responding to the CONNECT
request with an HTTP 200 status code, the intercepting proxy does not act as
a relay but instead performs the server’s end of the SSL handshake with the
browser. It also acts as an SSL client and performs a second SSL handshake with
the destination web server. Hence, two SSL tunnels are created, with the proxy
acting as a middleman. This enables the proxy to decrypt each message received
cc2200..iinndddd 775555 88//1199//22001111 1122::2211::0055 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 756
756 Chapter 20 n A Web Application Hacker’s Toolkit
through either tunnel, gain access to its cleartext form, and then reencrypt it
for transmission through the other tunnel.
Attacker Internet Target
CONNECT wahh-app:433
200 Connection established
Intercepting proxy
SSL tunnel 1 SSL tunnel 2
GET / HTTP/1.1
1101001000100 User-Agent: Mozilla/ 1001001101000
11010100000... 4.0 (compatible; MSIE 10001001001...
7.0; Windows NT 5.1)
Host: wahh-app.com
...
HTTP/1.1 200 OK
1100100110010 Content-Type: text/ 0010010100001
01010101110... html 01111010100...
Content-Length:
24246
...
Figure 20-3: An intercepting proxy lets you view and modify HTTPS communications
Of course, if any suitably positioned attacker could perform this trick with-
out detection, SSL would be fairly pointless, because it would not protect the
privacy and integrity of communications between the browser and server. For
this reason, a key part of the SSL handshake involves using cryptographic
certifi cates to authenticate the identity of either party. To perform the server’s
end of the SSL handshake with the browser, the intercepting proxy must use
its own SSL certifi cate, because it does not have access to the private key used
by the destination server.
In this situation, to protect against attacks, browsers warn the user, allowing
her to view the spurious certifi cate and decide whether to trust it. Figure 20-4
shows the warning presented by IE. When an intercepting proxy is being used,
both the browser and proxy are fully under the attacker’s control, so he can
accept the spurious certifi cate and allow the proxy to create two SSL tunnels.
When you are using your browser to test an application that uses a single
domain, handling the browser security warning and accepting the proxy’s
cc2200..iinndddd 775566 88//1199//22001111 1122::2211::0055 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 757
Chapter 20 n A Web Application Hacker’s Toolkit 757
homegrown certifi cate in this way normally is straightforward. However, in
other situations you may still encounter problems. Many of today’s applica-
tions involve numerous cross-domain requests for images, script code, and
other resources. When HTTPS is being used, each request to an external
domain causes the browser to receive the proxy’s invalid SSL certifi cate. In
this situation, browsers usually do not warn the user and thus do not give
her the option to accept the invalid SSL certifi cate for each domain. Rather,
they typically drop the cross-domain requests, either silently or with an alert
stating that this has occurred.
Figure 20-4: Using an intercepting proxy with HTTPS communications generates a
warning in the attacker’s browser
Another situation in which the proxy’s homegrown SSL certifi cates can cause
problems is when you use a thick client running outside the browser. Normally,
these clients simply fail to connect if an invalid SSL certifi cate is received and
provide no way to accept the certifi cate.
Fortunately, there is a simple way to circumvent these problems. On instal-
lation, Burp Suite generates a unique CA certifi cate for the current user and
stores this on the local machine. When Burp Proxy receives an HTTPS request
to a new domain, it creates a new host certifi cate for this domain on-the-fl y and
signs it using the CA certifi cate. This means that the user can install Burp’s CA
certifi cate as a trusted root in her browser (or other trust store). All the result-
ing per-host certifi cates are accepted as valid, thereby removing all SSL errors
caused by the proxy.
cc2200..iinndddd 775577 88//1199//22001111 1122::2211::0066 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 758
758 Chapter 20 n A Web Application Hacker’s Toolkit
The precise method for installing the CA certifi cate depends on the browser
and platform. Essentially it involves the following steps:
1. Visit any HTTPS URL with your browser via the proxy.
2. In the resulting browser warning, explore the certifi cate chain, and select
the root certifi cate in the tree (called PortSwigger CA).
3. Import this certifi cate into your browser as a trusted root or certifi cate
authority. Depending on your browser, you may need to fi rst export the
certifi cate and then import it in a separate operation.
Detailed instructions for installing Burp’s CA certifi cate on different browsers
are contained in the online Burp Suite documentation at the following URL:
http://portswigger.net/burp/help/servercerts.html
Common Features of Intercepting Proxies
In addition to their core function of allowing interception and modifi cation of
requests and responses, intercepting proxies typically contain a wealth of other
features to help you attack web applications:
n Fine-grained interception rules, allowing messages to be intercepted for
review or silently forwarded, based on criteria such as the target host,
URL, method, resource type, response code, or appearance of specifi c
expressions (see Figure 20-5). In a typical application, the vast majority of
requests and responses are of little interest to you. This function allows you
to confi gure the proxy to fl ag only the messages that you are interested in.
n A detailed history of all requests and responses, allowing previous messages
to be reviewed and passed to other tools in the suite for further analysis
(see Figure 20-6). You can fi lter and search the proxy history to quickly fi nd