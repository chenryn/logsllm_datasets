## 为什么需要简单直观？简单直观，看似是一条每个人都能清楚明白的原则。事实上，这是一个非常容易被忽略的原则。如果我们没有对简单直观这个原则有一个基本的认识，就不太可能遵循这样的原则。我们都喜欢原创和挑战，来展示我们的聪明才智。而简单直观的事情，显而易见的解决办法，似乎不足以展示我们的智慧和解决问题的能力。遗憾的是，在软件世界里，一旦我们脱离了简单直接的原则，就会陷入行动迟缓、问题倍出的艰难境地。简洁是智慧的灵魂，我们要充分理解这一点。**简单直观是快速行动的唯一办法**我们真正要的不是简单直观的代码，而是轻松快速的行动。编写简单直观的代码只是我们为了快速行动而不得不采取的手段。有一个说法，如果面条代码能够让我们行动更快，我们就会写出面条代码，不管是刀削面还是担担面。我见过的优秀的程序员，无一例外，都对简洁代码有着偏执般的执着。甚至小到缩进空格该使用几个空格这样细枝末节的问题，都会严格地遵守编码的规范。乍一看，纠缠于缩进空格不是浪费时间吗？可是真相是，把小问题解决好，事实上节省了大量的时间。``{=html}这些对代码整洁充满热情的工程师，会对整个团队产生积极的、至关重要的影响。这种影响，不仅仅关乎到工程进展的速度，还关系到工程的质量。真正能够使得产品获得成功，甚至扭转科技公司命运的，不是关键时刻能够救火的队员，而是从一开始就消除了火灾隐患的队员。**简单直观减轻沟通成本**简单直观的解决方案，有一个很大的优点，就是容易理解，易于传达。事情越简单，理解的门槛越低，理解的人越多，传达越准确。一个需要多人参与的事情，如果大家都能够清晰地理解这件事情，这就成功了一半。我们不要忘了，客户也是一个参与者。简单直观的解决方案，降低了用户的参与门槛，减轻了学习压力，能够清晰地传递产品的核心价值，最有可能吸引广泛的用户。**简单直观降低软件风险**软件最大的风险，来源于软件的复杂性。软件的可用性，可靠性，甚至软件的性能，归根到底，都是软件的复杂性带来的副产品。越复杂的软件，我们越难以理解，越难以实现，越难以测量，越难以实施，越难以维护，越难以推广。如果我们能够使用简单直接的解决方案，很多棘手的软件问题都会大幅地得到缓解。如果代码风格混乱，逻辑模糊，难以理解，我们很难想象，这样的代码会运行可靠。
## 该怎么做到简单直观？如果我们达成了共识，要保持软件的简单直观，那么，我们该怎么做到这一点呢？最重要的就是做小事，做简单的事情。**使用小的代码块**做小事的一个最直观的体现，就是代码的块要小，每个代码块都要简单直接、逻辑清晰。整洁的代码读起来像好散文，赏心悦目，不费力气。如果你玩过乐高积木，或者组装过宜家的家具，可能对"小部件组成大家具"的道理会深有体会。代码也是这样，一小块一小块的代码，组合起来，可以成就大目标。作为软件的设计师，我们要做的事情，就是识别、设计出这些小块。如果有现成的小块代码可以复用，我们就拿来用。如果没有现成的，我们就自己来实现这些代码块。为了保持代码块的简单，给代码分块的一个重要原则就是，**一个代码块只做一件事情**。前面，我们曾经使用过下面的例子。这个例子中，检查用户名是否符合用户名命名的规范，以及检查用户名是否是注册用户，放在了一个方法里。    /** * Check if the {@code userName} is a registered name.         * * @return true if the {@code userName}is a registered name. * @throws IllegalArgumentException if the {@code userName} is invalid */boolean isRegisteredUser(String userName) {    // snipped}如果单纯地从代码分块来看，还有优化的空间。我们可以把上述的两件事情，分别放到一个方法里。这样，我们就有了两个可以独立使用的小部件。每个小部件都目标更清晰，逻辑更直接，实现更简单。    /** * Check if the {@code userName} is a valid user name. * * @return true if the {@code userName} is a valid user name. */boolean isValidUserName(String userName) {    // snipped}    /** * Check if the {@code userName} is a registered name.         * * @return true if the {@code userName} is a registered name. */boolean isRegisteredUser(String userName) {    // snipped}**遵守约定的惯例**把代码块做小，背后隐含一个重要的假设：这些小代码块要容易组装。不能进一步组装的代码，如同废柴，没有一点儿价值。而能够组装的代码，接口规范一定要清晰。越简单、越规范的代码块，越容易复用。这就是我们前面反复强调的编码规范。**花时间做设计**对乐高或者宜家来说，我们只是顾客，他们已经有现成的小部件供我们组合。对于软件工程师而言，我们是软件的设计者，是需要找出识别、设计和实现这些小部件的人。识别出这些小部件，是一个很花时间的事情。有的程序员，喜欢拿到一个问题，就开始写代码，通过代码的不断迭代、不断修复来整理思路，完成设计和实现。这种方法的问题是，他们通常非常珍惜自己的劳动成果，一旦有了成型的代码，就会像爱护孩子一般爱护它，不太愿意接受新的建议，更不愿意接受大幅度的修改。结果往往是，补丁摞补丁，代码难看又难懂。有的程序员，喜欢花时间拆解问题，只有问题拆解清楚了，才开始写代码。这种方法的问题是，没有代码的帮助，我们很难把问题真正地拆解清楚。这样的方法，有时候会导致预料之外的、严重的架构缺陷。大部分的优秀的程序员，是这两个风格某种程度的折中，早拆解、早验证，边拆解、边验证，就像剥洋葱一样。拆解和验证，看起来很花时间。是的，这两件事情的确很耗费时间。但是，如果我们从整个软件的开发时间来看，这种方式也是最节省时间的。如果拆解和验证做得好，代码的逻辑就会很清晰，层次会很清楚，缺陷也少。一个优秀的程序员，可能 80% 的时间是在设计、拆解和验证，只有 20%的时间是在写代码。但是，拿出 20% 的时间写的代码，可能要比拿出 150%时间写的代码，还要多，还要好。这个世界真的不是线性的。有一句流传的话，说的是"跑得慢，到得早"。这句话不仅适用于健身，还适用于写程序。**借助有效的工具**我自己最常使用的工具，就是圆珠笔和空白纸。大部分问题，一页纸以内，都可以解决掉。当然，这中间的过程，可能需要一打甚至一包纸。一旦问题有点大，圆珠笔和空白纸就不够用了。这时候，我们需要称手的工具，帮助我们记忆和思考。现在我最喜欢的工具有思维导图、时序图和问题清单。在拆解问题时，思维导图可以帮助我厘清思路，防止遗漏。时序图可以帮助我理解关键的用例，勾画清楚各个部件之间的联系。而问题清单，可以记录下要解决和已经解决的问题，帮助我记录状态、追踪进度。你最顺手的工具是什么？欢迎你分享在留言区，我们一起来学习。
## 小结今天，我们主要聊的话题，就是做小事。我们工作生活中，一旦出现两种以上的竞争策略，要记住这个经过实践检验的理念：选择最简单，最直观的解决方案。当然，我们遇到的不会总是简单的问题。如果把复杂的问题、大的问题，拆解成简单的问题、小的问题，我们就能够化繁为简，保持代码的整洁和思路的清晰。
## 一起来动手通常一个用户登录的设计，需要输入用户名和密码。用户名和密码一起传输到服务器进行校验，授权用户登录。但现在有了更先进的设计。用户先输入用户名，用户名通过服务器检验，才能进一步输入密码，然后授权用户登录。你愿不愿意分析一下，这种简单的流程变化，带来的收益？客户端和服务器端的接口代码，大致应该是什么样子的？你使用了什么工具来分析这些问题？欢迎你在留言区讨论上面的问题，我们一起来看看这种简单的变化可以带来什么样的好处。![](Images/64444bae3ac90f82cb45ef5f1bc68d94.png){savepage-src="https://static001.geekbang.org/resource/image/5a/98/5a96a612403912b80de030e742e2e598.jpg"}
# 21 \| 怎么设计一个简单又直观的接口？我们前面聊过接口规范，开放的接口规范是使用者和实现者之间的合约。既然是合约，就要成文、清楚、稳定。合约是好东西，它可以让代码之间的组合有规可依。但同时它也是坏东西，让接口的变更变得困难重重。接口设计的困境，大多数来自于接口的稳定性要求。摆脱困境的有效办法不是太多，其中最有效的一个方法就是要**保持接口的简单直观**。那么该怎么设计一个简单直观的接口呢？
## 从问题开始软件接口的设计，要从真实的问题开始。一个解决方案，是从需要解决的现实问题开始的。要解决的问题，可以是用户需求，也可以是现实用例。面对要解决的问题，我们要把大问题分解成小问题，把小问题分解成更小的问题，直到呈现在我们眼前的是公认的事实或者是可以轻易验证的问题。比如说，是否可以授权一个用户使用某一个在线服务呢？这个问题就可以分解为两个小问题：1.  该用户是否为已注册的用户？2.  该用户是否持有正确的密码？我们可以使用思维导图来描述这个分解。![](Images/63d2d7138f1b9e49f10969c13efeb597.png){savepage-src="https://static001.geekbang.org/resource/image/c9/f1/c9d13e1a67471048a8d42867171351f1.png"}\分解问题时，我们要注意分解的问题一定要"相互独立，完全穷尽"（MutuallyExclusive and Collectively Exhaustive）。这就是 MECE 原则。使用 MECE原则，可以帮助我们用最高的条理化和最大的完善度理清思路。``{=html}如何理解这个原则呢？先来说一下"相互独立"这个要求。问题分解后，我们要仔细琢磨，是不是每一个小问题都是独立的，都是可以区分的事情。我们以上面的分解为例子，仔细看会发现这种划分是有问题的。因为只有已经注册的用户，才会持有正确的密码。而且，只有持有正确密码的用户，才能够被看作是注册用户。这两个小问题之间，存在着依赖关系，就不能算是"相互独立"。我们要消除掉这种依赖关系。变更后，就需要两个层次的表达。第一个层次问题是，该用户是否为已注册的用户？这个问题，可以进一步分解为两个更小的问题：用户持有的用户名是否已注册？用户持有的密码是否匹配？1.  该用户是否是已注册的用户？    a\. 用户名是否已注册？    b\. 用户密码是否正确？这种描述的思维导图，和上面的相比，已经有了很大的差别。![](Images/1ff7a3f44d2984e01c1ffa29d2672ac1.png){savepage-src="https://static001.geekbang.org/resource/image/51/19/51509360e2c8103bbd09eb855483da19.png"}\除了每一项都要独立之外，我们还要琢磨，是不是把所有能够找到的因素，都找到了？也就是说，我们是否穷尽了所有的内容，做到了"完全穷尽"？你可能早已经注意到了上述问题分解的缺陷。如果一个服务，对所有的注册用户开放，上面的分解就是完备的。否则，我们就漏掉了一个重要的内容，不同的注册用户，可以访问的服务可能是不同的。也就是说如果没有访问的权限，那么即使用户名和密码正确也无法访问相关的服务。如果我们把漏掉的加上，这个问题的分解可以进一步表示为：1.  该用户是否是已注册的用户？    a\. 用户名是否已注册？    b\. 用户密码是否正确？2\. 该用户是否有访问的权限？![](Images/c6f7528406b4fe4748c33e631f7e5591.png){savepage-src="https://static001.geekbang.org/resource/image/fb/13/fb829082bcd4be9b6e949e4fb39c2913.png"}\完成上述的分解后，对于是否授权用户访问一个服务这个问题，我们就会有一个清晰的思路了。**为什么从问题开始？**为什么我们要遵循"相互独立，完全穷尽"的原则呢？只有完全穷尽，才能把问题解决掉。否则，这个解决方案就是有漏洞的，甚至是无效的。只有相互独立，才能让解决方案简单。否则，不同的因素纠缠在一起，既容易导致思维混乱，也容易导致不必要的复杂。还有一个问题，我们也要清楚地理解。那就是，为什么要从问题开始呢？从问题开始，是为了让我们能够找到一条主线。然后，围绕这条主线，去寻找解决问题的办法，而不是没有目标地让思维发散。这样，也可以**避免需求膨胀和过度设计**。比如说，如果没有一条主线牵制着，按照面向对象编程的思路，我们看到"用户"两个字，马上就会有无限的联想。是男的还是女的呀？姓啥名谁呀？多大岁数了？家住哪儿啊？一系列问题都会冒出来，然后演化成一个庞大的对象。但事实上，对于上面的授权访问问题，我们根本不需要知道这些。**自然而来的接口**把大问题分解成小问题，再把小问题分解成更小的问题。在这个问题逐层分解的过程中，软件的接口以及接口之间的联系，也就自然而然地产生了。这样出来的接口，逻辑直观，职责清晰。对应的，接口的规范也更容易做到简单、稳定。还记得我们前面说过的 Java 的命名规范吗？Java类的标识符使用名词或者名词短语，接口的标识符使用名词、名词短语或者形容词，方法的标识符使用动词或者动词短语。这背后的逻辑是，Java类和接口，通常代表的是一个对象；而 Java 的方法，通常代表的是一个动作。我们在分解问题的过程中，涉及到的关键的动词和动词短语、名词和名词短语或者形容词，就是代码中类和方法的现实来源。比如，从上面的问题分解中，我们很容易找到一个基础的小问题：用户名是否已注册。这个小问题，就可以转换成一个方法接口。我们前面讨论过这个接口。下面，我们再来看看这段使用过的代码，你有没有发现什么不妥的地方？    /** * Check if the {@code userName} is a registered name.         * * @return true if the {@code userName} is a registered name. */boolean isRegisteredUser(String userName) {    // snipped}不知道你看到没有，这个方法的命名是不妥当的。根据前面的问题分解，我们知道，判断一个用户是不是注册用户，需要两个条件：用户名是否注册？密码是否正确？上面例子中，这个方法的参数，只有一个用户名。这样的话，只能判断用户名是不是已经被注册，还判断不了使用这个用户名的用户是不是真正的注册用户。如果我们把方法的名字改一下，就会更符合这个方法的职能。    /** * Check if the {@code userName} is a registered name.         * * @return true if the {@code userName} is a registered name. */boolean isRegisteredUserName(String userName) {    // snipped}如果你已经理解了我们前面的问题分解，你就会觉得原来的名字有点儿刺眼或者混乱。这就是问题分解带给我们的好处。问题的层层简化，会让接口的逻辑更直观，职责更清晰。这种好处，也会传承给后续的接口设计。
## 一个接口一件事情前面，我们提到过一行代码只做一件事情，一块代码只做一件事情。一个接口也应该只做一件事情。如果一行代码一件事，那么一块代码有七八行，不是也应该做七八件事情吗？怎么能说是一件事情呢？这里我们说的"事情"，其实是在某一个层级上的一个职责。授权用户访问是一件完整、独立的事情；判断一个用户是否已注册也是一件完整、独立的事情。只是这两件事情处于不同的逻辑级别。也就是说，一件事情，也可以分几步完成，每一步也可以是更小的事情。有了逻辑级别，我们才能分解问题，接口之间才能建立联系。对于一件事的划分，我们要注意三点。1.  一件事就是一件事，不是两件事，也不是三件事。2.  这件事是独立的。3.  这件事是完整的。如果做不到这三点，接口的使用就会有麻烦。比如下面的这段代码，用于表示在不同的语言环境下，该怎么打招呼。在汉语环境下，我们说"你好"，在英语环境下，我们说"Hello"。    /** * A {@code HelloWords} object is responsible for determining how to say * "Hello" in different language. */class HelloWords {    private String language = "English";    private String greeting = "Hello";     // snipped      /**     * Set the language of the greeting.     *     * @param language the language of the greeting.     */    void setLanguage(String language) {        // snipped     }     /**     * Set the greetings of the greeting.     *     * @param language the greetings of the greeting.     */    void setGreeting(String greeting) {        // snipped     }     // snipped }这里涉及两个要素，一个是语言（英语、汉语等），一个是问候语（Hello、你好等）。上面的这段代码，抽象出了这两个要素。这是好的方面。看起来，有两个独立的要素，就可以有两个独立的方法来设置这两个要素。使用setLanguage() 设置问候的语言，使用 setGreeting()设置问候的问候语。看起来没什么毛病。但这样的设计对用户是不友好的。因为 setLanguage() 和 setGreeting()这两个方法，都不能表达一个完整的事情。只有两个方法合起来，才能表达一件完整的事情。这种互相依赖的关系，会导致很多问题。 比如说：1.  使用时，应该先调用哪一个方法？2.  如果语言和问候语不匹配，会出现什么情况？3.  实现时，需不需要匹配语言和问候语？4.  实现时，该怎么匹配语言和问候语？这些问题，使用上面示例中的接口设计，都不好解决。一旦接口公开，软件发布，就更难解决掉了。**减少依赖关系**有时候，"一个接口一件事情"的要求有点理想化。如果我们的设计不能做到这一点，一定要减少依赖关系，并且声明依赖关系。一般来说一个对象，总是先要实例化，然后才能调用它的实例方法。构造方法和实例方法之间，就有依赖关系。这种依赖关系，是规范化的依赖关系，有严格的调用顺序限制。编译器可以帮我们检查这种调用顺序。但是，我们自己设计的实例方法之间的依赖关系，就没有这么幸运了。这就要求我们弄清楚依赖关系，标明清楚依赖关系、调用顺序，以及异常行为。下面的这段代码，摘录自 OpenJDK。这是一个有着二十多年历史的，被广泛使用的Java 核心类。这段代码里的三个方法，有严格的调用顺序要求。要先使用initSign() 方法，再使用 update() 方法，最后使用 sign()方法。这些要求，是通过声明的规范，包括抛出异常的描述，交代清楚的。    /* * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved. * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. * *  */ package java.security; import java.security.InvalidKeyException;import java.security.PrivateKey;import java.security.SignatureException;import java.security.SignatureSpi; /** * The Signature class is used to provide applications the functionality * of a digital signature algorithm. Digital signatures are used for * authentication and integrity assurance of digital data. *  *  *  * @since 1.1 */public abstract class Signature extends SignatureSpi {    // snipped        /**     * Initialize this object for signing. If this method is called     * again with a different argument, it negates the effect     * of this call.     *     * @param privateKey the private key of the identity whose signature     * is going to be generated.     *     * @exception InvalidKeyException if the key is invalid.     */    public final void initSign(PrivateKey privateKey)            throws InvalidKeyException {        // snipped    }     /**     * Updates the data to be signed or verified, using the specified     * array of bytes.     *     * @param data the byte array to use for the update.     *     * @exception SignatureException if this signature object is not     * initialized properly.     */    public final void update(byte[] data) throws SignatureException {        // snipped    }     /**     * Returns the signature bytes of all the data updated.     * The format of the signature depends on the underlying     * signature scheme.     *     * A call to this method resets this signature object to the state     * it was in when previously initialized for signing via a     * call to {@code initSign(PrivateKey)}. That is, the object is     * reset and available to generate another signature from the same     * signer, if desired, via new calls to {@code update} and     * {@code sign}.     *     * @return the signature bytes of the signing operation's result.     *     * @exception SignatureException if this signature object is not     * initialized properly or if this signature algorithm is unable to     * process the input data provided.     */    public final byte[] sign() throws SignatureException {        // snipped    }         // snipped}然而，即使接口规范里交待清楚了严格的调用顺序要求，这种设计也很难说是一个优秀的设计。用户如果不仔细阅读规范，或者是这方面的专家，很难第一眼就对调用顺序有一个直观、准确的认识。这就引出了另一个要求，接口一定要"皮实"。**使用方式要"傻"**所有接口的设计，都是为了最终的使用。方便、皮实的接口，才是好用的接口。接口要很容易理解，能轻易上手，这就是方便。此外还要限制少，怎么用都不容易出错，这就是皮实。上面的 OpenJDK例子中，如果三个方法的调用顺序除了差错，接口就不能正常地使用，程序就不能正常地运转。既不方便，也不皮实。