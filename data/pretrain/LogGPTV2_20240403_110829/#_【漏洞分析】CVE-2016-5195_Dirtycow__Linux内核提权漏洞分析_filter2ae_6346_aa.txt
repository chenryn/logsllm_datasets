# 【漏洞分析】CVE-2016-5195: Dirty COW - Linux内核提权漏洞详解

## 译文声明
本文为翻译文章，原文来源于安全客。译文仅供参考，具体内容和含义以原文为准。

**作者**: [A7um](http://bobao.360.cn/member/contribute?uid=183557479)  
**稿费**: 700 RMB（欢迎投稿！）  
**投稿方式**: 发送邮件至 linwei#360.cn 或访问 [网页版](http://bobao.360.cn/contribute/index) 在线投稿

---

## 漏洞概要
- **漏洞编号**: CVE-2016-5195
- **漏洞类型**: 内核竞态条件漏洞
- **漏洞危害**: 本地提权
- **影响范围**: Linux kernel > 2.6.22 (发布于2007年)

该漏洞由Phil Oester于2016年10月18日提交，并由Linux创始人Linus Torvalds亲自修复。10月20日，Phil Oester将部分漏洞细节发布到GitHub上，迅速在社交媒体上引起了广泛关注。由于该漏洞几乎影响所有版本的Linux系统，并且能够实现本地提权，因此备受关注。

[官方GitHub发布的POC](https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c) 可以向任意可读文件写入任意内容，利用该POC可以轻松获取root权限。例如，可以通过修改 `/etc/passwd` 文件中的用户UID来提权，或者通过修改具有S位的root拥有的二进制程序代码，使其执行 `execve("/bin/sh")` 等操作。

### 基础知识
本文假设读者了解以下技术：
- [写时拷贝 (Copy on Write, COW)](http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html)
- [竞态条件](http://baike.baidu.com/link?url=KYVGZZs3z1EstguoNCFaEmaPe-_bfbiQ47_uoP8H2HvLXxYIDtoUttgWymYFqfGOLcuY943QERhwmm-TtEDulwx7bY60s93Kho6Y8T31-enDKKVSAR4OQEkuDE2cdyUY)
- 页式内存管理
- [缺页中断处理](http://blog.csdn.net/chenyu105/article/details/7061845)

### 涉及的系统调用与系统文件
在正式分析漏洞之前，我们先对官方GitHub上的POC中涉及的几个系统调用和系统文件进行简要说明：

#### `mmap`
```c
void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset);
```
这是一个常用的函数，用于将磁盘上的文件映射到虚拟内存中。当 `flags` 设置为 `MAP_PRIVATE` 时，对映射内存的写操作会触发COW机制，写入的是COW后的内存，不会同步到磁盘文件中。

#### `madvise`
```c
int madvise(caddr_t addr, size_t len, int advice);
```
此函数用于告知内核关于 `addr` 到 `addr+len` 范围内内存的使用情况，以便内核进行进一步的内存管理。当 `advice` 为 `MADV_DONTNEED` 时，表示该内存区域在接下来不再使用，内核将释放这块内存以节省空间，并相应地清空页表项。

#### `write`
```c
ssize_t write(int fd, const void* buf, size_t count);
```
这是一个常见的函数，用于向 `fd` 所指向的文件写入最多 `count` 字节的 `buf` 中的内容。

#### `/proc/self/mem`
这个文件是一个指向当前进程虚拟内存的文件。通过读写 `/proc/self/mem`，可以直接读写虚拟内存空间，并忽略内存映射时的权限设置。这意味着我们可以利用 `/proc/self/mem` 来改写不具有写权限的虚拟内存。

### 触发原理
为了便于理解，我们首先概述一下该漏洞的触发原理：

1. 当调用 `write` 系统调用向 `/proc/self/mem` 文件写入数据时，内核会调用 `get_user_pages` 函数获取要写入的内存地址。
2. `get_user_pages` 会调用 `follow_page_mask` 获取内存页表项，并要求页表项所指向的内存映射具有可写权限。
3. 第一次获取页表项会因缺页而失败，`get_user_pages` 会调用 `faultin_page` 进行缺页处理后再次尝试获取页表项。
4. 如果第二次获取也失败，则 `get_user_pages` 会第三次调用 `follow_page_mask` 并不再要求内存映射具有可写权限，这时通常可以成功获取页表项并强制写入。
5. 但是，如果在第二次获取页表项失败后，另一个线程调用 `madvise(addr, addrlen, MADV_DONTNEED)` 清空了该只读文件的VM_PRIVATE映射的页表项，那么在第三次调用 `follow_page_mask` 时，由于不再要求写权限，内核不会再执行COW操作。因此，在缺页处理完成后，第四次调用 `follow_page_mask` 时不仅会成功获取页表项，而且写入的内容也会同步到只读文件中，从而导致越权写入。

### 控制流分析
接下来，我们通过分析相关内核代码来进一步理解漏洞的具体控制流程。

#### 相关函数
以下是相关函数的简化版本，虽然简化但仍然较为复杂，建议先浏览这部分内容，再继续阅读后面的控制流分析，然后根据需要回查这些函数。

```c
get_user_pages {
    ...
    return __get_user_pages(...); // 核心函数
}

__get_user_pages(vma, ..., int flag, ...) {
    ...
    retry:
        ...
        page = follow_page_mask(..., flag, ...); // 获取页表项
        if (!page) {
            int ret;
            ret = faultin_page(vma, ...); // 获取失败时调用
            switch (ret) {
                case 0: // 返回0则重试
                    goto retry;
                ...
            }
        }
}

follow_page_mask(..., flag, ...) {
    ...
    return follow_page_pte(..., flag, ...); // 寻找页表项
}

follow_page_pte(..., flag, ...) {
    ...
    if ((flags & FOLL_WRITE) && !pte_write(pte)) { 
        pte_unmap_unlock(ptep, ptl);
        return NULL; // 如果要求写权限但没有写权限，则返回空
    }
    return pages; // 否则返回页表项
}

faultin_page(vma, ...) {
    ...
    ret = handle_mm_fault();
    if ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))
        *flags &= ~FOLL_WRITE; // 去掉写权限要求
    ...
    return 0;
}

handle_mm_fault() {
    __handle_mm_fault();
}

__handle_mm_fault() {
    handle_pte_fault();
}

handle_pte_fault() {
    if (!fe->pte) {
        ... 
        return do_fault(fe); // 页表为空，调用do_fault处理缺页
    }
    if (fe->flags & FAULT_FLAG_WRITE) { // 页表不为空但无写权限，可能需要COW
        ...
    }
}
```

通过以上分析，我们可以更清晰地理解Dirty COW漏洞的触发机制及其在内核中的具体表现。希望本文能帮助读者更好地理解和防范此类漏洞。