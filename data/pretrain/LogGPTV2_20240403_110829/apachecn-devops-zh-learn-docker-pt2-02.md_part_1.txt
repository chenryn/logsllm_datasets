# 二、处理 Docker 容器
在前一章中，我们解释了刺激和可持续的概念，这些概念清楚地阐明了 Docker 制作未来和灵活的应用感知容器的方式。我们讨论了将 Docker 容器引入多个环境(内部和外部)的所有相关细节。您可以在自己的环境中轻松复制这些 Docker 功能，以获得有益的体验。现在，我们的下一个逻辑步骤是果断地理解容器生命周期的各个方面。您将学习如何以高效和无风险的方式优化您自己的容器以及其他第三方容器的利用率。容器将被发现、访问、评估，并用于更大更好的分布式应用。
在本章中，我们将深入探讨并详细描述容器搬运的关键方面。为了读者的利益，还将讨论一些利用容器的实用技巧和执行命令。
在本章中，我们将涵盖以下主题:
*   澄清 Docker 术语
*   使用 Docker 映像和容器
*   Docker 注册表及其存储库的含义
*   Docker 中心登记处
*   搜索 Docker 映像
*   使用交互式容器
*   跟踪容器内部的变化
*   控制和管理 Docker 容器
*   从容器构建映像
*   将容器作为守护程序启动
## 澄清 Docker 术语
为了大大简化本章的可理解性，并尽量减少任何形式的歧义，经常使用的术语将在下一节中解释。
### Docker 映像
Docker 映像是组成可执行软件应用的所有文件的集合。这个集合包括应用以及所有的库、二进制文件和其他依赖项，比如部署描述符，这些都是运行应用所必需的。Docker 映像中的这些文件是只读的，因此无法更改映像的内容。如果您选择更改映像的内容，Docker 允许的唯一选项是使用新的更改添加另一个图层。换句话说，Docker 映像由层组成，您可以使用`docker history`子命令查看这些层，如[第 3 章](03.html)、*建筑映像*中所述。
Docker 映像体系结构有效地利用这种分层概念，无缝地向现有映像添加附加功能，以满足不同的业务需求，并提高映像的重用。换句话说，可以通过在现有映像上添加额外的图层并导出新映像来为该映像添加功能。Docker 映像具有父子关系，最底部的映像称为**基础映像**。基本映像是没有任何父映像的特殊映像:
![](img/image_02_001.png)
在上图中，`ubuntu`是一个基础映像，它没有任何父映像。
Ubuntu is a Debian-based Linux operating system. The Ubuntu Docker image is a minimalist bundle of software libraries and binaries that are critical to run an application. It does not include the Linux kernel, device drivers, and various other services a full-fledged Ubuntu operating system would provide.
![](img/image_02_002.png)
正如你在上图中看到的，一切都从一个基础映像开始，在这个例子中，它是`ubuntu`。此外，`wget`功能将作为图层添加到映像中，`wget`映像将引用`ubuntu`映像作为其父映像。在下一层中，添加了一个 Tomcat 应用服务器的实例，并将`wget`映像作为其父映像。对原始基础映像所做的每个添加都存储在一个单独的层中(这里生成了一种层次结构来保持原始身份)。准确地说，任何 Docker 映像都必须源自基础映像，并且通过获取新的模块来不断丰富映像的功能，这是通过在现有 Docker 映像上逐个添加额外的模块作为新层来实现的，如上图所示。
Docker 平台提供了一种构建新映像或扩展现有映像的简单方法。您还可以下载其他人已经创建并存放在 Docker 映像存储库中(私有或公共)的 Docker 映像。每个映像都有一个唯一的标识，如下一节所述。
### Docker 容器
Docker 映像是应用栈捆绑包的只读模板，它们没有任何关联的状态。Docker 容器是从 Docker 映像中分离出来的，它在静态映像层之上添加了一个读写层。如果我们试图与面向对象的编程范式进行比较，Docker 映像通常是类，而 Docker 容器是对象(类的实例)。
Docker 映像定义了 Docker 容器的行为，例如当容器启动时运行什么进程。在前一章中，当您调用`docker run hello-world`时，Docker 引擎从`hello-world` Docker 映像中启动了一个新的容器，它继续在屏幕上输出大量信息。从这个例子中，很明显 Docker 映像是 Docker 容器的基本构建块，Docker 映像规定了 Docker 容器的行为。
![](img/image_02_003.png)
如上图所示，当容器被剥离时，可写(读写)层被添加到映像的顶部，以保持应用状态。容器层下可能有几个只读映像(可写)。
### Docker 注册表
一个**Docker 登记处**是一个可以存储 Docker 映像的地方，以便世界各地的软件开发人员可以公开或私下找到、访问和使用这些映像，从而在没有任何风险的情况下快速创建新的复合应用。因为所有存储的映像都经过了多次验证、确认和细化，所以这些映像的质量非常高。您可以将 Docker 映像发送到注册表，以便使用`docker push`子命令进行注册和存放。您可以使用`docker pull`子命令从注册表下载 Docker 映像。
Docker Registry 可以由第三方托管为公共或私有注册表，类似于以下注册表之一:
*   Docker 集线器
*   Docker
*   谷歌容器注册
*   容器登记处
每个机构、创新者和个人都可以拥有自己的 Docker Registry 来存储他们的映像，以供内部和/或外部访问和使用。
## 使用 Docker 映像
在前一章中，我们使用
`hello-world`映像演示了典型的 *Hello World* 示例。现在，需要更仔细地观察`docker pull`子命令的输出，这是下载 Docker 映像的实际命令。现在，在本节中，我们将使用`busybox`映像，一个最小但非常方便的 Docker 映像，来深入探讨 Docker 映像处理:
![](img/image_02_004.png)
如果你密切关注`docker pull`子命令的输出，你会注意到`Using default tag: latest`文本。Docker 映像管理功能(Docker 主机或 Docker 映像注册表上的本地映像存储)支持存储 Docker 映像的多个变体。换句话说，你可以使用标签来修改你的图片。
默认情况下，Docker 始终使用标记为`latest`的映像。每个映像变体都可以通过用适当的标签对其进行限定来直接识别。可以通过在标签和存储库名称(`:`)之间添加冒号(`:`)来对映像进行标签限定。为了演示，我们将拉出`busybox`的`1.24`标记版本，如下所示:
![](img/image_02_005.png)
太棒了。不是吗？我们能够拉一个特定版本的`busybox`；在这种情况下，就是`busybox:1.24`。`docker pull`命令还支持`-a`选项来下载所有可用的映像变体。谨慎使用此选项，因为最终可能会填满磁盘空间。
到目前为止，我们从存储库中下载了一些 Docker 映像，现在它们在 Docker 主机中本地可用。您可以通过运行`docker images`子命令找到 Docker 主机上可用的映像:
![](img/image_02_006.png)
显然，我们在前面的列表中有三个项目，为了更好地理解这些项目，我们需要理解`docker images`子命令打印出来的信息。以下是可能的类别列表:
*   `REPOSITORY`:这是存储库或映像的名称。在前面的示例中，存储库名称是`hello-world`和`busybox`。
*   `TAG`:这是与映像关联的标签，例如`1.24`和`latest`。一个或多个标签可以与一个映像相关联。
*   `IMAGE ID`:每个映像都与一个唯一的 ID 相关联。映像标识使用 64 位十六进制长随机数表示。默认情况下，`docker images`子命令只显示 12 个十六进制数字。您可以使用`--no-trunc`标志显示所有 64 个十六进制数字(例如:`sudo docker images --no-trunc`)。
*   `CREATED`:表示映像创建的时间。
*   `SIZE`:此类别突出显示映像的虚拟大小。
### Docker 枢纽
在上一节中，当您运行`docker pull`子命令时，`busybox`映像被神秘下载。在这一节中，让我们解开围绕`docker pull`子命令的谜团，以及 Docker Hub 如何为这一意想不到的成功做出巨大贡献。
Docker 社区中的好人已经建立了一个映像存储库，并在默认位置`index.docker.io`公开提供。这个默认位置被称为**Docker 中心**。`docker pull`子命令被编程为在该位置寻找映像。因此，当你拉一张`busybox`图片时，它会毫不费力地从默认注册表中下载。这种机制有助于加速 Docker 容器的旋转。Docker Hub 是官方存储库，包含全球 Docker 开发社区创建和存放的所有精心策划的映像。实施这种所谓的解决方案是为了通过大量隔离任务来确保存储在 Docker Hub 中的所有映像都是安全的。还有其他机制，如创建映像摘要和内容信任，这使您能够验证通过任何渠道从注册表接收的所有数据的完整性和发布者。
从这些 Docker 映像中清除任何有意或无意引入的恶意软件、广告软件、病毒等，都有成熟的验证和确认方法。数字签名是 Docker 映像最大完整性的突出机制。尽管如此，如果官方映像已经被破坏或篡改，那么 Docker 引擎将发出警告，然后继续运行该映像。
除了官方存储库，Docker Hub 注册表还为第三方开发人员和提供商提供了一个平台，用于共享他们的映像以供一般消费。第三方映像以其开发者或存款人的用户标识为前缀。例如`thedockerbook/helloworld`为第三方图片，其中`thedockerbook`为用户 ID，`helloworld`为图片库名称。您可以使用`docker pull`子命令下载任何第三方映像，如下所示:
```
$ sudo docker pull thedockerbook/helloworld
```
除了前面的存储库，Docker 生态系统还提供了一种利用来自除 Docker Hub 注册表之外的任何第三方存储库中心的映像的机制，并且它还提供了由本地存储库中心托管的映像。如前所述，Docker Engine 已经被编程为在默认情况下在`index.docker.io`查找映像，而在第三方或本地存储库中心的情况下，我们必须手动指定应该从哪里提取映像的路径。手动存储库路径类似于没有协议说明符的 URL，例如`https://`、`http://`和`ftp://`。以下是从第三方存储库中心提取映像的示例:
```
$ sudo docker pull registry.example.com/myapp  
```
### 搜索 Docker 映像
正如我们在上一节中所讨论的，Docker Hub 存储库通常既包含官方映像，也包含第三方 Docker 爱好者提供的映像。在撰写本书时，数以千计的精选 Docker 映像(也称为**Docker 化应用)**可供用户使用。其中大部分被数百万用户下载。这些映像可以按原样使用，也可以作为特定于用户的应用的构造块。
您可以使用`docker search`子命令在 Docker Hub 注册表中搜索 Docker 映像，如本例所示:
```
$ sudo docker search mysql  
```
在`mysql`上的搜索将列出许多`mysql`映像，但是我们将通过使用`head -10`命令将它限制为五行，如下所示:
![](img/image_02_007.png)
正如您在前面的搜索输出摘录中看到的，映像是根据它们的星级排序的。搜索结果还指示该映像是否是官方映像(由 Docker Inc .策划和主持)。搜索结果还指示映像是否使用 Docker Inc .提供的自动化框架构建。由 Docker Inc .策划和托管的`mysql`映像具有`2759`星级，这表明这是最受欢迎的`mysql`映像。出于安全原因，我们强烈建议您使用 Docker Inc .正式托管的映像，否则请确保这些映像由可信且知名的来源提供。列表中的下一张图片是`mysql-server`，由第三方`mysql`提供，星级为`178`。Docker 容器是分布式应用的标准构建块。
在全球多个社区成员的热情贡献下，Docker 映像的动态存储库正在实现。软件工程师可以下载存储在 Docker Hub 中的映像，并提供不同的映像和容器，以满足不同的业务需求。这种安排是为了优雅地自动化和加速软件应用的构建、部署和使用。Docker Hub 代表了为应用提供大量映像的社区努力，这样开发人员和系统管理员可以专注于构建新的特性和功能，同时最大限度地减少他们在商品脚手架和管道上的重复工作。
基于 Docker Hub 注册表中的搜索查询以及与许多开发人员社区成员的讨论，Docker 公司(它是 Docker 运动的先锋)如此有力和热情地得出结论，开发人员社区想要他们最喜欢的编程语言的预构建栈。具体来说，开发人员希望尽可能快地开始工作，编写代码时不浪费时间，也不与环境、脚手架和依赖关系做斗争。
## 使用交互式容器
在第一章中，我们运行了我们的第一个 *Hello World* 容器，以了解容器化技术是如何工作的。在本节中，我们将以交互模式运行容器。`docker run`子命令将映像作为输入，并将其作为容器启动。您必须将`-t`和`-i`标志传递给`docker run`子命令，以使容器具有交互性。`-i`标志是关键驱动，通过抓取容器的标准输入(`STDIN`)使容器具有交互性。`-t`标志分配一个伪 TTY 或伪终端(终端仿真器)，然后将其分配给容器。
在下面的例子中，我们将使用`ubuntu:16.04`映像和`/bin/bash`作为命令来启动一个交互式容器:
```
$ sudo docker run -i -t ubuntu:16.04 /bin/bash  
```
由于`ubuntu`映像尚未下载，如果我们使用`docker pull`子命令，那么我们将获得以下消息，`docker run`命令将开始自动拉动`ubuntu`映像，并显示以下消息:
```
Unable to find image 'ubuntu:16.04' locally
16.04: Pulling from library/ubuntu
```
一旦下载完成，容器将与`ubuntu:16.04`映像一起启动。它还将在容器内启动一个 Bash shell，因为我们已经指定`/bin/bash`作为要执行的命令。这将使我们进入一个 Bash 提示，如下所示:
```
root@742718c21816:/# 
```
前面的 Bash 提示将确认我们的容器已经成功启动，并准备接受我们的输入。如果你对提示符中的十六进制数字`742718c21816`感到疑惑，那么它只不过是容器的主机名。按照 Docker 的说法，主机名与容器 ID 相同。
让我们快速交互运行几个命令，并确认我们提到的提示是正确的，如下所示:
```
root@742718c21816:/# hostname
742718c21816
root@742718c21816:/# id
uid=0(root) gid=0(root) groups=0(root)
root@742718c21816:/# echo $PS1
[e]0;u@h: wa]${debian_chroot:+($debian_chroot)}u@h:w$ 
root@742718c21816:/#  
```
从前面的三个命令中，很明显，提示是使用用户标识、主机名和当前工作目录组成的。
现在，让我们使用 Docker 的一个利基特性将其从交互式容器中分离出来，然后看看 Docker 为这个容器管理的细节。是的，我们可以使用 *Ctrl* + *P* 和 *Ctrl* + *Q* 转义序列将其从我们的容器中分离出来。这个转义序列会将 TTY 从容器中分离出来，并在 Docker 主机提示`$`中让我们着陆；但是，容器将继续运行。`docker ps`子命令将列出所有正在运行的容器及其重要属性，如下所示:
```
$ sudo docker ps
CONTAINER ID IMAGE COMMAND CREATED 
STATUS PORTS NAMES
742718c21816 ubuntu:16.04 "/bin/bash" About a 
minute ago Up About a minute jolly_lovelace
```
`docker ps`子命令将列出以下细节:
*   `CONTAINER ID`:显示与容器关联的容器 ID。容器标识是一个 64 位十六进制长随机数。默认情况下，`docker ps`子命令将只显示 12 个十六进制数字。您可以使用`--no-trunc`标志显示所有 64 位数字(例如`sudo docker ps --no-trunc`)。
*   `IMAGE`:这显示了制作 Docker 容器的映像。
*   `COMMAND`:这显示了容器启动期间执行的命令。