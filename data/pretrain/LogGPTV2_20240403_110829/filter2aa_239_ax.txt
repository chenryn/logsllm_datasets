5.1 资源
资源是一个被反复使用的术语。术语“资源”的一个用法是本地化。在本地化中，资源
用于翻译文本和图像。基于用户的区域，加载正确的资源。术语“资源”的另一个用法在本
章中介绍。这里，资源用于另一个主题：使用托管和非托管的资源——存储在托管或本机
堆中的对象。尽管垃圾收集器释放存储在托管堆中的托管对象，但不释放本机堆中的对
象。必须由开发人员自己释放它们。
使用托管环境时，很容易被误导，注意不到内存管理，因为垃圾收集器（GC）会处
理它。很多工作都由GC完成；了解它是如何工作的，什么是大小对象堆，以及什么数据
类型存储在堆栈上是非常有益的。同时，垃圾收集器处理托管的资源，那么非托管资源
呢？它们需要由开发人员释放。程序可能是完全托管的程序，但是框架的类型呢？例如，
文件类型包装了一个本地文件句柄。这个文件句柄需要释放。为了尽早释放这个句柄，最
好了解IDisposable接口和using语句，参见本章的内容。
本章介绍内存管理和内存访问的各个方面。如果很好地理解了内存管理和C#提供的
指针功能，也就能很好地集成C#代码和原来的代码，并能在非常注重性能的系统中高效
地处理内存。
5.2 后台内存管理
C#编程的一个优点是程序员不需要担心具体的内存管理，垃圾回收器会自动处理所
有的内存清理工作。用户可以得到像C++语言那样的效率，而不需要考虑像在C++中那样
内存管理工作的复杂性。虽然不必手动管理内存，但仍需要理解后台发生的事情。理解程
序在后台如何管理内存有助于提高应用程序的速度和性能。本节要介绍给变量分配内存时
在计算机的内存中发生的情况。
  注意： 本节不详细介绍许多主题的相关内容。应把这一节看作是一般过程的
简化向导，而不是实现的确切说明。
5.2.1 值数据类型
Windows使用一个虚拟寻址系统，该系统把程序可用的内存地址映射到硬件内存中的
实际地址上，这些任务完全由Windows在后台管理。其实际结果是32位处理器上的每个进
程都可以使用4GB的内存——无论计算机上实际有多少物理内存（在64位处理器上，这个
数字会更大）。这个4GB的内存实际上包含了程序的所有部分，包括可执行代码、代码加
载的所有DLL，以及程序运行时使用的所有变量的内容。这个4GB的内存称为虚拟地址空
间，或虚拟内存。为了方便起见，本章将它简称为内存。
  注意： 在.NET Core应用程序中，在Visual Studio Project Properties的Debug设
置中选择体系结构，指定是调试32位还是64位应用程序（见图5-1）。选择x86时，就调
试运行在32位和64位系统上的32位应用程序；选择x64时，就调试运行在64位系统上的
64位应用程序。如果看不到不同的选项，就必须安装具体的运行库，参见第1章。
图5-1
4GB中的每个存储单元都是从0开始往上排序的。要访问存储在内存的某个空间中的
一个值，就需要提供表示该存储单元的数字。在任何复杂的高级语言中，编译器负责把人
们可以理解的变量名转换为处理器可以理解的内存地址。
在处理器的虚拟内存中，有一个区域称为栈。栈存储不是对象成员的值数据类型。另
外，在调用一个方法时，也使用栈存储传递给方法的所有参数的副本。为了理解栈的工作
原理，需要注意在C#中的变量作用域。如果变量a在变量b之前进入作用域，b就会首先超
出作用域。考虑下面的代码：
    {
      int a;
      // do something
      {
        int b;
        // do something else
      }
图5-2
    }
首先声明变量a。接着在内部代码块中声明了b。然后内部代码块终止，b就超出作用
域，最后a超出作用域。所以b的生存期完全包含在a的生存期中。在释放变量时，其顺序
总是与给它们分配内存的顺序相反，这就是栈的工作方式。
还要注意，b在另一个代码块中（通过另一对嵌套的花括号来定义）。因此，它包含
在另一个作用域中。这称为块作用域或结构作用域。
我们不知道栈具体在地址空间的什么地方，这些信息
在进行C#开发时是不需要知道的。栈指针（操作系统维护
的一个变量）表示栈中下一个空闲存储单元的地址。程序
第一次开始运行时，栈指针指向为栈保留的内存块末尾。
栈实际上是向下填充的，即从高内存地址向低内存地址填
充。当数据入栈后，栈指针就会随之调整，以始终指向下
一个空闲存储单元。这种情况如图5-2所示。在该图中，显示了栈指针800000（十六进制
的0xC3500），下一个空闲存储单元是地址799999。
下面的代码会告诉编译器，需要一些存储空间以存储一个整数和一个双精度浮点数，
这些存储单元分别称为nRacingCars和engineSize。声明每个变量的代码行表示开始请求访
问这个变量，闭合花括号标识这两个变量超出作用域的地方。
    {
      int nRacingCars = 10;
      double engineSize = 3000.0;
      // do calculations;
    }
假定使用如图5-2所示的栈。nRacingCars变量进入作用域，赋值为10，这个值放在存
储单元799996～799999上，这4个字节就在栈指针所指空间的下面。有4个字节是因为存储
int要使用4个字节。为了容纳该int，应从栈指针对应的值中减去4，所以它现在指向位置
799996，即下一个空闲单元（799995）。
下一行代码声明变量engineSize（这是一个double数），把它初始化为3000.0。一个
double数要占用8个字节，所以值3000.0放在栈上的存储单元799988～799995上，栈指针对
应的值减去8，再次指向栈上的下一个空闲单元。
当engineSize超出作用域时，运行库就知道不再需要这个变量了。因为变量的生存期
总是嵌套的，当engineSize在作用域中时，无论发生什么情况，都可以保证栈指针总是会
指向存储engineSize的空间。为了从内存中删除这个变量，应给栈指针对应的值递增8，现
在它指向engineSize末尾紧接着的空间。此处就是放置闭合花括号的地方。当nRacingCars
也超出作用域时，栈指针对应的值就再次递增4。从栈中删除enginesize和nRacingCars之
后，此时如果在作用域中又放入另一个变量，从799999开始的存储单元就会被覆盖，这些
空间以前是存储nRacingCars的。
如果编译器遇到int i、j这样的代码行，则这两个变量进入作用域的顺序是不确定的。
两个变量是同时声明的，也是同时超出作用域的。此时，变量以什么顺序从内存中删除就
不重要了。编译器在内部会确保先放在内存中的那个变量后删除，这样就能保证该规则不
会与变量的生存期冲突。
5.2.2 引用数据类型
尽管栈有非常高的性能，但它还没有灵活到可以用于所有的变量。变量的生存期必须
嵌套，在许多情况下，这种要求都过于苛刻。通常我们希望使用一个方法分配内存，来存
储一些数据，并在方法退出后的很长一段时间内数据仍是可用的。只要是用new运算符来
请求分配存储空间，就存在这种可能性——例如，对于所有的引用类型。此时就要使用托
管堆。
如果读者以前编写过需要管理低级内存的C++代码，就会很熟悉堆（heap）。托管堆
和C++使用的堆不同，它在垃圾回收器的控制下工作，与传统的堆相比有很显著的优势。
托管堆（简称为堆）是处理器的可用内存中的另一个内存区域。要了解堆的工作原理
和如何为引用数据类型分配内存，看看下面的代码：
    void DoWork()
    {
      Customer arabel;
      arabel = new Customer();
      Customer otherCustomer2 = new EnhancedCustomer();
    }
在这段代码中，假定存在两个类Customer和EnhancedCustomer。EnhancedCustomer类
扩展了Customer类。
首先，声明一个Customer引用arabel，在栈上给这个引用分配存储空间，但这仅是一
个引用，而不是实际的Customer对象。arabel引用占用4个字节的空间，足够包含Customer
对象的存储地址（需要4个字节把0～4GB之间的内存地址表示为一个整数值）。
然后看下一行代码：
    arabel = new Customer();
这行代码完成了以下操作：首先，它分配堆上的内存，以存储Customer对象（一个真
正的对象，不只是一个地址）。然后把变量arabel的值设置为分配给新Customer对象的内
存地址（它还调用合适的Customer（）构造函数初始化类实例中的字段，但此处我们不必
担心这部分）。
Customer实例没有放在栈中，而是放在堆中。在这个例子中，现在还不知道一个
Customer对象占用多少字节，但为了讨论方便，假定是32个字节。这32个字节包含了
Customer的实例字段，和.NET用于识别和管理其类实例的一些信息。
为了在堆上找到存储新Customer对象的一个存储位置，.NET运行库在堆中搜索，选
取第一个未使用的且包含32个字节的连续块。为了讨论方便，假定其地址是200000, arabel
引用占用栈中的799996～799999位置。这表示在实例化arabel对象前，内存的内容应如图
5-3所示。
图5-3
给Customer对象分配空间后，内存的内容应如图5-4所示。注意，与栈不同，堆上的
内存是向上分配的，所以空闲空间在已用空间的上面。
图5-4
下一行代码声明了一个Customer引用，并实例化一个Customer对象。在这个例子中，
用一行代码在栈上为otherCustomer2引用分配空间，同时在堆上为mrJones对象分配空间：
    Customer otherCustomer2 = new EnhancedCustomer();
该行把栈上的4个字节分配给otherCustomer2引用，它存储在799992～799995位置上，
而otherCustomer2对象在堆上从200032开始向上分配空间。
从这个例子可以看出，建立引用变量的过程要比建立值变量的过程更复杂，且不能避
免性能的系统开销。实际上，我们对这个过程进行了过分的简化，因为.NET运行库需要
保存堆的状态信息，在堆中添加新数据时，这些信息也需要更新。尽管有这些性能开销，
但仍有一种机制，在给变量分配内存时，不会受到栈的限制。把一个引用变量的值赋予另
一个相同类型的变量，就有两个变量引用内存中的同一对象了。当一个引用变量超出作用
域时，它会从栈中删除，如上一节所述，但引用对象的数据仍保留在堆中，一直到程序终
止，或垃圾回收器删除它为止，而只有在该数据不再被任何变量引用时，它才会被删除。
这就是引用数据类型的强大之处，在C#代码中广泛使用了这个特性。这说明，我们
可以对数据的生存期进行非常强大的控制，因为只要保持对数据的引用，该数据就肯定存
在于堆上。
5.2.3 垃圾回收
由上面的讨论和图5-3和图5-4可以看出，托管堆的工作方式非常类似于栈，对象会在
内存中一个挨一个地放置，这样就很容易使用指向下一个空闲存储单元的堆指针来确定下
一个对象的位置。在堆上添加更多的对象时，也容易调整。但这比较复杂，因为基于堆的
对象的生存期与引用它们的基于栈的变量的作用域不匹配。
图5-5
在垃圾回收器运行时，它会从堆中删除不再引用的所
有对象。垃圾回收器在引用的根表中找到所有引用的对
象，接着在引用的对象树中查找。在完成删除操作后，堆
会立即把对象分散开来，与已经释放的内存混合在一起，
如图5-5所示。
如果托管的堆也是这样，在其上给新对象分配内存就
成为一个很难处理的过程，运行库必须搜索整个堆，才能
找到足够大的内存块来存储每个新对象。但是，垃圾回收
器不会让堆处于这种状态。只要它释放了能释放的所有对
象，就会把其他对象移动回堆的端部，再次形成一个连续
的内存块。因此，堆可以继续像栈那样确定在什么地方存
储新对象。当然，在移动对象时，这些对象的所有引用都
需要用正确的新地址来更新，但垃圾回收器也会处理更新问题。
垃圾回收器的这个压缩操作是托管的堆与非托管的堆的区别所在。使用托管的堆，就
只需要读取堆指针的值即可，而不需要遍历地址的链表，来查找一个地方放置新数据。
  注意： 一般情况下，垃圾回收器在.NET运行库确定需要进行垃圾回收时运
行。可以调用System.GC.Collect（）方法，强迫垃圾回收器在代码的某个地方运行。
System.GC类是一个表示垃圾回收器的.NET类，Collect（）方法启动一个垃圾回收过
程。但是，GC类适用的场合很少，例如，代码中有大量的对象刚刚取消引用，就适合
调用垃圾回收器。但是，垃圾回收器的逻辑不能保证在一次垃圾收集过程中，所有未
引用的对象都从堆中删除。
  注意： 在测试过程中运行GC是很有用的。这样，就可以看到应该回收的对
象仍然未回收而导致的内存泄漏。因为垃圾回收器的工作做得很好，所以不要在生产
代码中以编程方式回收内存。如果以编程方式调用Collect，对象会更快地移入下一代，
如下所示。这将导致GC运行更多的时间。
创建对象时，会把这些对象放在托管堆上。堆的第一部分称为第0代。创建新对象
时，会把它们移动到堆的这个部分中。因此，这里驻留了最新的对象。
对象会继续放在这个部分，直到垃圾回收过程第一次进行回收。这个清理过程之后仍
保留的对象会被压缩，然后移动到堆的下一部分上或世代部分——第1代对应的部分。
此时，第0代对应的部分为空，所有的新对象都再次放在这一部分上。在垃圾回收过
程中遗留下来的旧对象放在第1代对应的部分上。老对象的这种移动会再次发生。接着重
复下一次回收过程。这意味着，第1代中在垃圾回收过程中遗留下来的对象会移动到堆的
第2代，位于第0代的对象会移动到第1代，第0代仍用于放置新对象。
  注意： 有趣的是，在给对象分配内存空间时，如果超出了第0代对应的部分
的容量，或者调用了GC.Collect（）方法，就会进行垃圾回收。
这个过程极大地提高了应用程序的性能。一般而言，最新的对象通常是可以回收的对
象，而且可能也会回收大量比较新的对象。如果这些对象在堆中的位置是相邻的，垃圾回
收过程就会更快。另外，相关的对象相邻放置也会使程序执行得更快。
在.NET中，垃圾回收提高性能的另一个领域是架构处理堆上较大对象的方式。
在.NET下，较大对象有自己的托管堆，称为大对象堆。使用大于85 000个字节的对象时，
它们就会放在这个特殊的堆上，而不是主堆上。.NET应用程序不知道两者的区别，因为
这是自动完成的。其原因是在堆上压缩大对象是比较昂贵的，因此驻留在大对象堆上的对
象不执行压缩过程。
在进一步改进垃圾回收过程后，第二代和大对象堆上的回收现在放在后台线程上进
行。这表示，应用程序线程仅会为第0代和第1代的回收而阻塞，减少了总暂停时间，对于
大型服务器应用程序尤其如此。服务器和工作站默认打开这个功能。
有助于提高应用程序性能的另一个优化是垃圾回收的平衡，它专用于服务器的垃圾回
收。服务器一般有一个线程池，执行大致相同的工作。内存分配在所有线程上都是类似
的。对于服务器，每个逻辑服务器都有一个垃圾回收堆。因此其中一个堆用尽了内存，触
发了垃圾回收过程时，所有其他堆也可能会得益于垃圾的回收。如果一个线程使用的内存
远远多于其他线程，导致垃圾回收，其他线程可能不需要垃圾回收，这就不是很高效。垃
圾回收过程会平衡这些堆——小对象堆和大对象堆。进行这个平衡过程，可以减少不必要
的回收。
为了利用包含大量内存的硬件，垃圾回收过程添加了GCSettings.LatencyMode属性。
把这个属性设置为GCLatencyMode枚举的一个值，可以控制垃圾回收器进行回收的方式。
表5-1列出了GCLatencyMode可用的值。
表5-1 GCLatencyMode的设置
成员
说明
Batch
禁用并发设置，把垃圾回收设置为最大吞吐量。这会重写配
置设置
Interactive
工作站的默认行为。它使用垃圾回收并发设置，平衡吞吐量
和响应
LowLatency
保守的垃圾回收。只有系统存在内存压力时，才进行完整的
回收。只应用于较短时间，执行特定的操作
SustainedLowLatency
只有系统存在内存压力时，才进行完整的内存块回收
NoGCRegion
.NET 4.6新增成员。对于GCSettings，这是一个只读属性。
可以在代码块中调用GC.TryStartNoGC-Region和
EndNoGCRegion来设置它。调用TryStartNoGCRegion，定义
需要可用的、GC试图访问的内存大小。成功调用
TryStartNoGCRegion后，指定不应运行的垃圾回收器，直到
调用EndNoGCRegion为止
LowLatency或NoGCRegion设置使用的时间应为最小值，分配的内存量应尽可能小。
如果不小心，就可能出现溢出内存错误。
5.3 强引用和弱引用
垃圾回收器不能回收仍在引用的对象的内存——这是一个强引用。它可以回收不在根
表中直接或间接引用的托管内存。然而，有时可能会忘记释放引用。
  注意： 如果对象相互引用，但没有在根表中引用，例如，对象A引用B, B引
用C, C引用A，则GC可以销毁所有这些对象。
在应用程序代码内实例化一个类或结构时，只要有代码引用它，就会形成强引用。例
如，如果有一个类MyClass，并创建了一个变量myClassVariable来引用该类的对象，那么
只要myClassVariable在作用域内，就存在对MyClass对象的强引用，如下所示：
    var myClassVariable = new MyClass();
这意味着垃圾回收器不会清理MyClass对象使用的内存。一般而言这是好事，因为可
能需要访问MyClass对象，可以创建一个缓存对象，它引用其他几个对象，如下：
    var myCache = new MyCache();
    myCache.Add(myClassVariable);
现在使用完myClassVariable了。它可以超出作用域，或指定为null：
    myClassVariable = null;
如果垃圾回收器现在运行，就不能释放myClassVariable引用的内存，因为该对象仍在
缓存对象中引用。这样的引用可以很容易忘记，使用WeakReference可以避免这种情况。
  注意： 使用事件很容易错过引用的清理。此时也可以使用弱引用。
弱引用允许创建和使用对象，但是垃圾回收器碰巧在运行，就会回收对象并释放内
存。由于存在潜在的bug和性能问题，一般不会这么做，但是在特定的情况下使用弱引用
是很合理的。弱引用对小对象也没有意义，因为弱引用有自己的开销，这个开销可能是比
小对象更大。
弱引用是使用WeakReference类创建的。使用构造函数，可以传递强引用。示例代码
创建了一个DataObject，并传递构造函数返回的引用。在使用WeakReference时，可以检查
IsAlive属性。再次使用该对象时，WeakReference的Target属性就返回一个强引用。如果属
性返回的值不是null，就可以使用强引用。因为对象可能在任意时刻被回收，所以在引用
该对象前必须确认它存在。成功检索强引用后，可以通过正常方式使用它，现在它不能被
垃圾回收，因为它有一个强引用：
    // Instantiate a weak reference to MathTest object
    var myWeakReference = new WeakReference(new DataObject());
    if (myWeakReference.IsAlive)
    {
      DataObject strongReference = myWeakReference.Target as DataObject;
      if (strongReference ! = null)
      {
        // use the strongReference
      }
    }
    else
    {
      // reference not available
    }
5.4 处理非托管的资源
垃圾回收器的出现意味着，通常不需要担心不再需要的对象，只要让这些对象的所有
引用都超出作用域，并允许垃圾回收器在需要时释放内存即可。但是，垃圾回收器不知道
如何释放非托管的资源（例如，文件句柄、网络连接和数据库连接）。托管类在封装对非
托管资源的直接或间接引用时，需要制定专门的规则，确保非托管的资源在回收类的一个
实例时释放。
在定义一个类时，可以使用两种机制来自动释放非托管的资源。这些机制常常放在一
起实现，因为每种机制都为问题提供了略为不同的解决方法。这两种机制是：
● 声明一个析构函数（或终结器），作为类的一个成员
● 在类中实现System.IDisposable接口
下面依次讨论这两种机制，然后介绍如何同时实现它们，以获得最佳的效果。
5.4.1 析构函数或终结器
前面介绍了构造函数可以指定必须在创建类的实例时进行的某些操作。相反，在垃圾
回收器销毁对象之前，也可以调用析构函数。由于执行这个操作，因此析构函数初看起来
似乎是放置释放非托管资源、执行一般清理操作的代码的最佳地方。但是，事情并不是如
此简单。
  注意： 在讨论C#中的析构函数时，在底层的.NET体系结构中，这些函数称