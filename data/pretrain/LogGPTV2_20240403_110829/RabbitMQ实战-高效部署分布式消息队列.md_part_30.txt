---
## Page 197
9.1能用RabbitMQRESTAPI做什么
175
9.1能用RabbitMQRESTAPI做什么
API是完全REST化的，理解这一点很重要。因此操作的项目名称总是会包
含在URL内。举个例子，如果你想要查看虚拟主机oak下名为branches 的队列
数据统计的话，就可以构造如下URL并以HTTPGET请求的方式发送给服务器：
http://localhost:55672/api/queues/oak/branches。如果使用cURL来发
送请求的话，你会看到如下所示：
$curl-i-u guest:guest
http://localhost:55672/api/queues/oak/branches
HTTP/1.1200OK
Server: MochiWeb/1.1 WebMachine/1.7 (participate in the frantic)
Date: Tue, 05Jul 2011 22:55:25 GMT
Content-Type: application/json
Content-Length:739
Cache-Control: no-cache
("memory":9136,"messages":0,"consumer_details": [],
"idle_since":"2011-7-516:55:1","exclusive_consumer_pid":"",
"exclusive_consumer_tag":"", "messages_ready":0,
"backing_queue_status":("ql":0,"q2":0,
注意：CURL让你可以在命令行上手工发送和接收HTTP请求。在大多
数Linux/UNIX发行版本上都能找到它。也可以直接在http://curl.haxx.se/
download.html进行下载。
喔，除了简单易读的HTTP头之外，下面那一大块杂乱的内容是什么呢？如果
你看一下Content-Type头的话，就会发现应答内容被编码成了application/
json。JSON代表了JavaScriptObjectNotation，可以替代XML来编码数据（请
参阅http://en.wikipedia.org/wiki/JSON来获得更深入的理解）。JSON允许你使用编
程语言能够理解的结构，例如哈希表、数组、字串和整型来编码数据。如果你懂
JavaScript的话，则可能已经明白了该API返回的是哈希表格式的队列数据。举例
来说，哈希表中memory元素指的是队列当前消耗的内存大小（以字节为单位）。当
使用ManagementAPI时，每一次调用要么返回空的内容（创建或者删除条目的动作）;
要么返回一个JSON格式的哈希表，包含了你请求的数据（列表或者展现条目的动
1对于本章示例来说，RabbitMQ运行在localhost上；如果没有修改Management插件的话，默认监
听端口是55672。
---
## Page 198
176
第9章使用RESTAPI控制Rabbit
作）。
与API请求返回的数据同样重要的是用来发起请求的HTTP动作。此处使用的
是GET请求。RabbitMQAPI将GET解释为“给我展示位于/api/queues/oak/
DELETE。POST和PUT用来创建条目，而DELETE用来删除条目。POST和PUT不
可互换使用。某些API调用需要POST来创建条目，而另一些则使用PUT（查阅本
节末尾的参考链接，就能明白什么地方该用PUT，什么地方该用POST了）。假设该
branches 队列尚不存在，你想用 API来创建它。通过使用和之前一样的URL，但
是将动作更改为PUT，就能将请求从获取队列详情更改为创建队列：
H- Ind x- asanb:asane n- T- Iano s
"Content-Type:application/json"\
-d'"auto_delete":false,"durable":false}'\
s
HTTP/1.1 204 NoContent
Server:MochiWeb/1.1 WebMachine/l.7 (participate in the frantic)
Date:Tue, 05 Ju1 2011 23:24:46 GMT
Content-Type:application/json
Content-Length:0
好吧，你并非仅仅将动作更改为PUT。你同时还将JSON哈希表‘{"auto_
delete"：false，"durable"：false}'添加到了正文中，同时添加了
ContentType头，这样API会知道正文中的数据是JSON编码的。请求正文告诉
API，关闭auto_delete和durable标志。这两个参数和之前本书中Python示例
创建队列时指定的auto_delete和durable标志是一样的。事实上，和Python
AMQP示例一样，API需要在创建队列时指定标志。如果你将正文留空的话，就会
收到一个API错误。不管用API创建队列还是设置权限，每当使用PUT或者POST
动作的时候，都需要将函数参数编码为JSON格式的哈希表，然后添加到请求正文中。
现在你能创建队列并查看它们的数据统计了，但是你还能做什么呢？以下是一
些 API能做的其他事情：
■查看当前链接列表和详情——/api/connections
■下载或者上传完整的RabbitMQ服务器配置，包括队列、交换器和绑定
--/api/all-configuration
·列出集群中的所有节点（以及它们的数据统计）一一/api/nodes
---
## Page 199
9.2对客户端授权访问
177
·查看或者创建虚拟主机—/api/vhosts/
■为用户设置权限-/api/permissions//
Management API（以及插件）总是在不断地增强，这里提到的只是众多API提
供的功能中的一小部分。你可以通过用浏览器访问http://localhost:55672/api来查看
自前大多数（以及完整的）API列表和支持的HTTP动作。话不多说！让我们创建
一些凭证，以便你能使用API来编写脚本！
9.2对客户端授权访问
参数。就像通过AMQP访问RabbitMQ的应用一样，脚本使用普通的RabbitMQ
API。举个例子，如果你有一个监控脚本仅能检查队列数据统计的话，就可以创建
一个新的Rabbit用户，并将该用户在虚拟主机上的权限设置为：
■Read:.*
·Write: (empty)
■Config: (empty)
这样设置将允许该脚本（以及知道该脚本的Rabbit用户名和密码的人）只能对
队列进行监控，而不能发布消息或者更改配置。
那么如何为API访问创建用户呢？这很简单：通过rabbitmqctl创建用户，
并将admin属性设置为true即可。让我们创建一个名为monitor的用户，脚本可
以使用该用户来监控默认（/）虚拟主机（但是不能写或者更改任何东西）的数据统
计了。在RabbitMQ目录下运行：
$ sbin/rabbitmqctl add_user monitor monitorMe
Creating user "monitor" ...
...done.
$ sbin/rabbitmqctl set_admin monitor
Setting administrative status for user "monitor" ...
...done.
$ sbin/rabbitmqctl set_permissions -p / monitor "" "" ",*"
---
## Page 200
178
第9章使用RESTAPI控制Rabbit
Setting permissions for user"monitor"in vhost "/".
...done.
就是这么简单！set_admin命令至关重要。如果没有为用户设置admin
标记的话，无论它的权限如何设置，都无法访问API。最后一条命令（set_
permissions）赋予monitor用户在默认（/）虚拟主机下完整的读权限，但没有
赋予配置或者写权限。在准备好了monitor用户之后，你可以开始编写第一个AP
脚本来查看队列数据统计了。
9.3访问数据统计
在日常工作中，总要反复查看特定队列上有多少条消息。某些时候是为了调试
新的应用程序；另一些时候则是为了监控产品环境中，等待消费的消息和投递到消
费者但仍未确认的消息之间的比率（第二个度量标准对于发现导致消费者崩溃的始
作俑者来说非常有用）。虽然你可以使用rabbitmgct1来列出队列的消息总数，但
是这有两个主要的缺点：
（1）rabbitmqctl只能在那些安装了Erlang并且和RabbitMQ服务器拥有相
同Erlangcookie的计算机上才能运行。
（2）rabbitmqctl只会向你展示队列的消息总数。它不会区分等待确认的已
投递消息和等待消费的消息。
听起来对RabbitManagementAPI来说是个完美的工作！你将使用Python内建
的httplib和json库来和Rabbit进行通信，并且对请求和响应进行编码/解码。
由于你想要从命令行上运行数据统计查询脚本，因此需要对命令行参数进行解析，
如下列清单所示。
清单9.1queue_stats.py—获取初始设定
①有效参
import sys, json, httplib, urllib, base64
数数目
if len(sys.argv)/，如下
列清单所示。
清单9.2queue_stats.py构造请求
vhost = urllib.quote(vhost,safe=')
 299:
print"Error executing API call (%d):%s"%(response.status
response.read())
sys.exit(2)
这段脚本首先建立了到API服务器的HTTP连接I。此时，服务器等待API请
求和授权凭证。由于RabbitAPI使用HTTPBasic认证，因此你需要将用户名和密
码封装为?username:password格式并进行Base64编码²。然后，你需要创建一
个字典（哈希表）用来包含HTTP头3。其中之一是Authorization头，它包含
了基于Base64编码的凭证，添加在ASCII字符串"Basic"之后。另一个同样重
要的是Content-Type头，因为它让API服务器知道请求正文（如果有的话）是
以JSON格式编码的。由于这里只发送GET请求，因此请求正文总是空的。但设置
Content-Type是一个好习惯,以免在需要的时候(PUT或者POST请求）忘记。最后，
你将请求发送4到API服务器并接收响应5。如果在完成请求之前发生问题的话，
API服务器会将HTTP响应代码设置为4xx或5xX。任何高于299的响应代码都非
正常情况，所以检测代码时应小于299。如果发生错误的话，需要将错误报告给
用户并退出程序；否则就解析响应并将队列详情展现给用户，如下列清单所示。
清单9.4queue_stats.py-解析并展现队列数据统计
payload = json.loads(response.read())
<1对响应进
行解码
展现队列
2数据统计
print "\tMessages:"
print"\t\tUnack'd:"+str(payload["messages_unacknowledged"])
print "\t\tTotal:"+ str(payload["messages"])
sys.exit(0)
2Base64是一种将文本和二进制数据编码为ASCII字符的方法。HTTPBasic认证规范要求
u sername:password在发送之前需要进行Base64编码。有关Base64的更多信息请参阅http://
en.wikipedia.org/wiki/Base64
---
## Page 203
9.4自动化vhost和用户配置
181
由于API服务器总是以JSON哈希表的格式返回信息，因此第一步要做的是将
响应内容用JSON进行解码I。这一步将JSON编码的哈希表转换成了编程语言支
持的哈希表类型。对于Python来说，这意味着响应被转换成了一个Python字段。
响应被编码为JSON格式的美妙之处在于一旦解码完成，你就可以像其他字典（哈
希表）那样访问resp_payload中的字段了。举例来说，获取队列占用的内存数量
那么，程序运行起来是什么样子呢？
$ python queue_stats.py localhost:55672 guest
guest/test
'test'QueueStats
Memory Used (bytes): 9104
Consumer Count:3
Messages:
Unack'd:3
Ready:4
Total:7
从输出可以看到，默认（/）虚拟主机内的test队列消耗了9104字节的内存，
拥有三个消费者，并且包含了总共七条消息。除了这七条消息之外，你还能看到其
中的三条消息已经发送给了消费者，并等待确认，同时另外的四条正等待发送给下
一个消费者。只用了不到60行的代码，并且你可以从基础设施中的任何地方进行
访问！这就是RabbitManagementAPI的强大之处。它使得你可以在任何能够访问网
络的地方监控并控制Rabbit。到目前为止我们所做的是读取数据统计，这对于控制