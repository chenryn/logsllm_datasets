a=5;
return 0;
a=5;
_insert函数访问一个全局链表，
 在32位机上赋值是原子操作，
如果一个函数只访问自己的局部变量或参数，
 读取这个变量到寄存器需要两个32位寄存器才放得下，也需要两条指令
-g
00
c7
0
5
5495 04 08 00
5095 04 0805
0
，则有可能用一条指令完成赋值，因而是原子操作。如
下一节线程会讲到如何保证一个代码段以原子操作完成。
 不是-
，有可能因为重入而造成错乱，
，是不是原子操作呢？比
 在16位机上就不是。如果在程序中需要使用
movl
 movl
$0x0,0x8049554
$0x5,0x8049550
，假如这两步操作必定会一起做完
，则称为可重入（Reentrant）
像这样的函数称为
，其根本原因在
-..--.-..-..--
635
因此
---
## Page 636
对于程序中存在多个执行流程访问同一全局变量的情况，volatile限定符是必要的，此外，虽然程
量a内存单元的读写。
身的规范，
没有改变a的值，
是编译器优化得有错误吗？不是的。设想一
则main函数的指令中有:
例如：
内存读变量a的值，
将全局变量a从内存读到eax寄存器，
面的方法编译和反汇编这个程序，在main函数的指令中有：
数sighandler,
为了简洁，这里只写了一个代码框架来说明问题。在main函数中首先要注册某个信号的处理函
在使用sig_atomic_t类型的变量时，还需要注意另一个问题。看如下的例子:
说编译器估
仍然死在第二条指令上，
，是因为调用了特定平台上的特定库函数,
一条指令将全局变量a的内存单元直接和0比较，如果相等，
SiS
#include 
做错了
8048359:
8048352:
8048359:
8048357:
8048352:
，不归编译器管，
.....
....
然后在-
，a的值就没有理由会变，
，只能说编译器无法识别程序中存在多个执行流程。之所以程序中存在多个执行流
while(!a);
return 
，可见这三条指令等价于C代码的while(la)；循环。如果在编译时加了优化选项，
是等价的，
do
一个while死循环中等待信号发生,
，程序员应该自己处理这些问题。C语言提供了volatile限定符，
0;
因为不会再次从内存读取变量a的值。
83 3d
65
这样再次回到main函数时就可以退出while循环，执行后续处理。用上
并且优化之后省去了每次循环读内存的操作，
fe
6
7
￥e
 sighandler
3c95040８00
 sighandler */
 wait until
对eax和eax做AND运算，
0408
不需要反复从内存读取，
L下
l a changes in sighandler */ 
如果程序只有单-
 arrives
je
cmp1
test
mov
只要没有影响Zero标志位，回到main函类
 如果有信号递达则执行sighandler，
，则第二条指令成了一个死循环，
，若结果为0则跳回循环开头，
8048352
$0x0,0x804953c
%eax,%eax
volatile
一的执行流程,
因此上面的两条指令
 编译器也不会优化掉对变
效率非常高。
只要当前执行流程
所以不能
，如果将
再次从
636
注
数
---
## Page 637
从解除信号屏蔽到调用pause之间存在间隙，SIGALRM仍有可能在这个间隙递达。要消除这个间隙,
以了。看看以下方法可行吗？
如何解决上述问题呢？读者可能会想到，在调用pause之前屏蔽sIGALRM信号使它不能提前递达就可
出现这个问题的根本原因是系统运行的时序（Timing）并不像我们写程序时所设想的那样。虽
现在重新审视例 33.2“mysleep"，设想这样的时序：
4.6.竞态条件与sigsuspend函数请点评
什么样的内存单元会具有这样的特性呢？肯定不是普通的内存，
序只有单一的执行流程，但是变量属于以下情况之一的，也需要
(Race Condition）。
先级的进程）
4. pause();
3．解除对SIGALRM信号的屏蔽;
2. alarm(nsecs);
1．屏蔽SIGALRM信号；
7．可是SIGALRM信号已经处理完了，还等待什么呢？
6．返回这个进程的主控制流程，alarm(nsecs)返回，调用pause()挂起等待。
4．nsecs秒钟之后闹钟超时了，内核发送sIGALRM信号给这个进程，处于未决状态。
3
1．注册SIGALRM信号的处理函数。
5
·即使多次向变量的内存单元中写数据，只写不读，也并不是在做无用功，而是有特殊意义的
·变量的内存单元中的数据不需要写操作就可以自己发生变化，每次读上来的值都可能不一样
数sig_alrm之后再次进入内核。
优先级更高的进程执行完了，
执行很长时间 
内核调度优先级更高的进程取代当前进程执行，并且优先级更高的进程有很多个，每个都要
，如果我们写程序时考虑不周密，就可能由于时序问题而导致错误，这叫做竞态条件
，、内核要调度回这个进程执行。SIGALRM信号递达，执行处理函
而是映射到内存地址空间的硬件寄
限定:
637
---
## Page 638
来对该信号是屏蔽的，从sigsuspend返回后仍然是屏蔽的。
个信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值，如果原
屏蔽"和“挂起等待信号"这两步能合并成一
这样更不行了，
4．解除对SIGALRM信号的屏蔽;
2. alarm(nsecs);
1．屏蔽SIGALRM信号;
be caught 
blocked */
unsigned int mysleep(unsigned int nsecs)
int sigsuspend(const sigset_t *sigmask);
#include 
*/
，sigsuspend没有成功返回值，只有执行了一个信号处理函数之后sigsuspend才返
还没有解除屏蔽就调用pause，
/* some signal has been caught,
suspmask = oldmask;
alarm(nsecs);
sigaddset(&newmask,
newact.sa_
newact.sa_handler
/* set our handler,
unsigned int
sigset
struct sigaction
/* block SIGALRM and save current signal mask */
，进程的信号屏蔽字由sigmask参数指定，
flags 
'&oldact, NULL); /* reset previous action
&newact，
SIGALRM);
sig_al;
 save previous information */
 newact, oldact;.
一个原子操作就好了，
 SIGALRM);
unslept;
 which unblocks SIGALRM */
&newmask,
，同时解决了竞态条件的问题，在对时序要求严格的
 &oldact);
 oldmask, suspmask;
&oldmask);
 SIGALRM is now blocked */
/* wait for any signal to
/* make sure SIGALRM isn't
，可以通过指定sigmask来临时解除对某
638
---
## Page 639
义sIGCHLD信号的处理函数，在其中调用wait获得子进程的退出状态并打印。
请编写一个程序完成以下功能：父进程fork出子进程，
终止时会通知父进程，父进程在信号处理函数中调用wait清理子进程即可。
能处理自己的工作了；采用第二种方式，父进程在处理自己的工作的同时还要记得时不时地轮询-
进程一章讲过用wait和waitpid函数清理僵尸进程，
4.7.关于SIGCHLD信号请点评
如果在调用mysleep函数时sIGALRM信号没有屏蔽:
3.阻塞信号
用。请编写程序验证这样做不会产生僵尸进程。
通常是没有区别的，
会产生僵尸进程，也不会通知父进程。
事实上，由于UNIX的历史原因，
其实，子进程在终止时会给父进程发SIGCHLD信号，该信号的默认处理动作是忽略，父进程可以自
塞地查询是否有子进程结束等待清理（也就是轮询的方式）
义SIGCHLD信号的处理函数,
3
 2．调用sigsuspend(&suspmask);时解除对sIGALRM的屏蔽，然后挂起等待待。
程序实现复杂。
4.
一页
但这是一
一个特例。
这样父进程只需专心处理自己的工作，
要想不产生僵尸进程还有另外一种办法：父进程调
，自动恢复原来的屏蔽字，也就是再次屏蔽sIGALRM。
，此方法对于Linux可用，但不保证在其它UNIX系统上都可
&oldmask，NULL);时再次解除对sIGALRM的屏蔽。
全国嵌入式人才培训基地
起始页
二一级
 这样fork出来的子进程在终止时会自动清理掉，不
，父进程可以阻塞等待子进程结束，也可以非阻
子进程调用exit(2)终止，
。采用第一种方式,
第 34 章终端、作业控制与守护进程
，父进程自定
父进程阻塞了就不
28
---
## Page 640
4.捕捉信号
2.作业控制
1.终端
目录
第 34 章 终端、作业控制与守护进程 请点评
上一页
守护进程
2.2.
2.1.Session与进程组
1.3.网络登录过程
1.2.终端登录过程
1.1.终端的基本概念
与作业控制有关的信号
第34章终端、作业控制与守护进程
部分III. Linux系统编程
全国嵌入式人才培训基地
全国嵌入式人才培训基地
起始页
上一级
1.终端
640
---
## Page 641
再开
在图形终端窗口下运行这个程序，可能会得到
能是任意文件。下面我们通过实验看一下各种不同的终端所对应的设备文件名。
问。ttyname函数可以由文件描述符查出对应的文件名，
端。事实上每个终端设备都对应一个不同的设备文件，
示SIGINT，Ctrl-\表示SIGQUIT。
在第33 章信号还讲过，在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl-C表
输入读也就是读用户的键盘输入,
道fork会复制PCB中的信息，
在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，
1.1.终端的基本概念 请点评
1.终端 请点评
在第28章文件与IIQ中讲过,
(Controlling Terminal)
上一页
一个终端窗口运行这个程序，可能又会得到
$ ./a.out
例 34.1.查看终端对应的设备文件名
fd
fd
./a.out
2:
1：
/dev/pts/0
/dev/pts/0
int main()
#include
#include 
return 0;
printf("fd 
 每个进程的标准输入、标准输出和标准错误输出都指向控制终端，
在第1节“引言"讲过，
 每个进程都可以通过一个特殊的设备文件/dev/tty访问它的控制终
因此由Shell进程启动的其它进程的控制终端也是这个终端。默认情况
第 34章终端、作业控制与守护进程
，进程往标准输出或标准错误输出写也就是输出到显示器上。此外
%s\n",
全国嵌入式人才培训基地
ttyname(1
ttyname(0));
1.终端
 控制终端是保存在PCB中的信息，
，该文件描述符必须指向一个终端设备而不
，这个终端成为Shell进程的控制终端
一个通用的接口，
而我们知
进程从标准
一个进程
下二
---
## Page 642
硬件驱动程序负责读写实际的硬件设备,
内核中处理终端设备的模块包括硬件驱动程序和线路规程（Line Discipline）
过Linux的minicom或Windows的超级终端工具登录到目标板的系统。
再举个例子，做嵌入式开发时经常会用到串口终端，
示图形终端窗口所对应的终端。
示当前虚拟终端,
F6切换到6个字符终端，相当于有6套虚拟的终端设备,
1.2.终端登录过程 请点评
看结果是什么。
读者可以再试试在Ctrl-Alt-F2的字符终端下或者在telnet或ssh登陆的网络终端下运行这个程序，看
用Ctrl-AIt-F1切换到字符终端运行这个程序，结果是
一个过滤器，
一台PC通常只有一套键盘和显示器，
内核
图 34.1.终端设备模块
阳阳
P
S
fd
./a.out
1:
0：
2:
0：
 对于某些特殊字符并不是让它直接通过，
read/write等系统调,用的实现
终端设备（键盘·显示器等)
/dev/ttyi
/dev/ttyl
/dev/ttyl
/dev/pts/1
/dev/pts/1
/dev/pts/:
line discipline 
终端设备驱动
用户进程
Topen/read/write/ioctl..
L
将主机和目标板用串口线连起来，
，也就是只有一套终端设备,
，比如从键盘读入字符和把字符输出到显示器，线路规程像
，目标板的每个串口对应一个终端设备，比
 而是做特殊处理,
 它们共用同一套物理终端设备，对应的设备
一样也是一个通用的接口，但它不能表
，就可以在主机上通
 但是可以通过Ctrl-Alt-F1~Ctrl-Alt-
，比如在键盘上按下Ctrl-
 切换到Ctrl-Alt-
642
---
## Page 643
3、login程序提示用户输入密码（输入密码期间关闭终端的回显）
2、getty根据命令行参数打开终端设备作为它的控制终端，
序设置一
的配置文件来配置init。
有些新的Linux发行版已经不用/etc/inittab这个配置文件了，例如Ubuntu用/etc/event.d目录下
我们从终端退出登录后会再次提示输入帐号。
是9600（波特率只对串口和Modem终端有意义）
1、系统启动时，init进程根据配置文件/etc/inittab确定需要打开哪些终端。
现在我们来看终端登录的过程：
看到该字符的回显。
输出队列,
终端可以配置成回显（Echo）模式，
从队列中读取字符，
以输入队列为例，
终端设备有输入和输出队列缓冲区，如下图所示。
进程，
，通常会使该进程停止。线路规程应该过滤哪些字符和做哪些特殊处理是可以配置的。
 execl("/bin/bash",
一些环境变量，设置当前工作目录为该用户的主目录，然后执行Shell:：
内核
用户进程
图34.2.终端缓冲
1:2345:respawn:/sbin/getty 9600 ttyl
因此我们在命令行键入字符时，该字符不仅可以被程序读取，我们也可以同时在屏幕上
to line discipline
用户进程调用write写入
从键盘输入的字符经线路规程过滤后进入输入队列，
输出队列
 每个字段用:号隔开。
一般情况下，
"-bash", NULL);
"login"
当输入队列满的时候再输入字符会丢失,
如果开启回显
在这种模式下,
from line discipline
，开头的1是这一行配置的id，通常要和tty的后缀一致，
-p"
，输入队列中的每个字符既送给用户程序也送给
输入队列
用户进程调,用read读取
，打开终端/dev/ttyl,
 把文件描述符0、1、2都指向控制终
然后验证帐号密码的正确性。
 用户程序以先进先出的顺序
，它再执行login程序:
同时系统会响铃警报。
例如配置文件中有