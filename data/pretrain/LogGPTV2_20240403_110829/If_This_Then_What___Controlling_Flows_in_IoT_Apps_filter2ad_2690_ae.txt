to learn if the applet was triggered. Despite leaking only one bit of
information, i.e., whether some kids arrived home, some users may
find it as sensitive information. To allow for these cases, we extend
the semantic model with support for trigger-sensitive applets.
Presence projection function In order to distinguish between
trigger-sensitive applets and trigger-insensitive applets, we define
a presence projection function π which determines whether trig-
gering an applet is sensitive or not. Thus, for an input i that triggers
an applet, π (i) = L (π (i) = H) means that triggering the applet can
(not) be visible to an attacker.
Based on the projection function, we define input equivalence.
Two inputs i and j are equivalent (written i ≈ j) if either their
presence is low, or if their presence is high, then they are equivalent
to the empty event ε.
π (i) = H
i ≈ ε
π (j) = L
π (i) = L
i ≈ j
Applets as reactive programs A reactive program is a program
that waits for an input, runs for a while (possibly) producing some
::= t (x ){c; o1 (sink1), . . . , on (sinkn )}
Syntax:
a
Monitor semantics:
Applet-Low
⟨c[i/x], m0, S0, Γ0⟩L →n ⟨stop, m, S, Γ⟩
n ≤ timeout
π (i) = L
⟨t (x ){c; o1 (sink1), . . . , ok (sinkk )}⟩ i→ {oj (m(outj )) | S (oj ) (cid:55)→ ff }
Applet-High
π (i) = H
n ≤ timeout
⟨c[i/x], m0, S0⟩ →n ⟨stop, m, S⟩
S (oj ) = ff ⇒ m(outj )|B = ∅
⟨t (x ){c; o1 (sink1), . . . , ok (sinkk )}⟩ i→ {oj (m(outj )) | S (oj ) (cid:55)→ ff }
Figure 14: Applet monitor
outputs, and finally returns to a passive state in which it is ready to
receive another input [5]. As a reactive program, an applet responds
with (output) actions when an input is available to set off its trigger.
We model the applets as event handlers that accept an input
i to a trigger t (x ), (possibly) run filter code c after replacing the
parameter x with the input i, and produce output messages in the
form of actions o on sinks sink.
For the applet semantics, we distinguish between trigger-sensitive
applets and trigger-insensitive applets (Figure 14). In the case of a
trigger-insensitive applet, we execute the filter semantics by enforc-
ing information flow control via rule Applet-Low, as presented
in Figure 13. In line with IFTTT applet functionality, we ignore
outputs on sinks whose actions were skipped inside the filter code.
If the applet is trigger-sensitive, we execute the regular filter
semantics with no information flow restrictions, while instead re-
quiring no blacklisted URLs on the sinks (rule Applet-High). Label
propagation and enforcing information flow is not needed in this
case, as an attacker will not be able to infer any observations on
whether the applet was triggered or not.
Termination Trigger-sensitive applets may help against leak-
ing information through the termination channel. Recall the filter
code in Example 6.3 that would possibly timeout depending on
the amount transferred using Stripe. In line with IFTTT applets
which are executed with a timeout, we model applet termination by
counting the steps in the filter semantics. If the filter code executes
in more steps than allowed by the timeout, the monitor blocks the
applet execution and no outputs are performed.
6.3 Soundness
Projected noninterference. We now define a security character-
ization that captures what it means for filter code to be secure. Our
characterization draws on the baseline condition of noninterfer-
ence [7, 16], extending it to represent the attacker’s observations in
the presence of URL-enriched markup.
String equivalence We use the projection to B relation from
Section 6.2 to define string equivalence with respect to a set of
blacklisted URLs. We say two strings s1 and s2 are equivalent and
we write s1 ∼B s2 if they agree on the lists of blacklisted values
they contain. More formally, s1 ∼B s2 iff s1|B = s2|B. Note that
projecting to B returns a list and the equivalence relation on strings
requires the lists of blacklisted URLs extracted from them to be
equal, pairwise.
Memory equivalence Given a typing environment Γ, we define
memory equivalence with respect to Γ and we write ∼Γ if two
memories are equal on all low variables in Γ: m1 ∼Γ m2 iff∀l . Γ(l ) =
L ⇒ m1 (l ) = m2 (l ).
Projected noninterference Equipped with string and memory
equivalence, we define projected noninterference. Intuitively, a com-
mand satisfies projected noninterference if and only if for any two
runs that start in memories agreeing on the low part and produce
two respective final memories, the final memories are equivalent
for the attacker on the sink. The definition is parameterized on a
set B of blacklisted URLs.
Definition 6.9 (Projected noninterference). Command c, input i1,
memory m1, typing environment Γ, and URL blacklist B, such
that ⟨c, m1⟩ →∗ ⟨stop, m′
1⟩, satisfies projected noninterference if
for any input i2 and memory m2 such that i1 ≈ i2, m1 ∼Γ m2, and
1 (out) ∼B m′
2⟩, m′
⟨c, m2⟩ →∗ ⟨stop, m′
Soundness theorem. We prove that our monitor enforces pro-
jected noninterference. The proof is reported in Appendix B.
2 (out).
Theorem 1 (Soundness). Given command c, input i1, mem-
URL blacklist B such that ⟨c[i1/x], m1, S, Γ⟩pc ↛∗(cid:32), configuration
ory m1, typing environment Γ, program context pc, skip set S, and
⟨c[i1/x], m1, S, Γ⟩pc satisfies projected noninterference.
7 FlowIT
We implement our monitor, FlowIT, as an extension of JSFlow [21],
a dynamic information flow tracker for JavaScript, and evaluate the
soundness and permissiveness on a collection of 60 IFTTT applets.
7.1 Implementation
We parameterize the JSFlow monitor with a set B of blacklisted
values and extend the context with a set S of skip actions. The set
B is represented as an array of strings, where each string denotes a
blacklisted value, whereas the set S is represented as an array of
triples (action, skip, sink), where action is a string denoting the
actions’ name, skip is a boolean denoting if the action was skipped
or not, and sink is a labeled value specifying the current value on
the sink. Initially, all skips map to false and all sinks map to null.
We extend the syntax with two APIs skip/1 and sink/3, for
skipping actions and sending values on a sink, respectively. The
API skip/1 takes as argument a string denoting an action name in
S and sets its corresponding skip boolean to true. The API sink/3
takes as argument a string denoting an action name in S, an action
ingredient, and a value to be sent on the sink, and it updates its
corresponding sink value with the string obtained by evaluating its
last argument.
We further extend the syntax with two constructs for creating
HTML image markups with a given URL imgl/1 and imgh/1, and
with two constructs for defining upload links urll/1 and urlh/1.
The monitor then ensures that whenever a construct linkl is created
the current pc and the label of the argument are both low, and for
each construct linkh no elements in B are contained in the string
its argument evaluates to.
Consider Example 7.1 where we rewrite the URL upload attack
from Figure 2 in the syntax of our extended JSFlow monitor.
Example 7.1 (Privacy attack from Figure 2).
1
2
3
publicPhotoURL = lbl ( encodeURIComponent ( '
IosPhotos . newPhotoInCameraRoll .
PublicPhotoURL '))
attack = urll (" www . attacker . com ?" +
publicPhotoURL )
sink ( ' GoogleDrive . uploadFileFromUrlGoogleDrive '
, ' setUrl ', attack )
Here, lbl/1 is an original JSFlow function for assigning a high la-
bel to a value. Instead of the actual user photo URL, we use the string
'IosPhotos.newPhotoInCameraRoll.PublicPhotoURL', while for spec-
ifying the value on the sink, we update the sink attribute of action '
GoogleDrive.uploadFileFromUrlGoogleDrive' with variable attack.
The execution of the filter code is blocked by the monitor due to
the illegal use of construct urll in line 2. Removing this line and
sending on the sink only the photo URL, as in sink('GoogleDrive
.uploadFileFromUrlGoogleDrive', 'setUrl', publicPhotoURL), re-
sults in a secure filter code accepted by the monitor.
Trigger-sensitive applets. For executing filter code originating
from trigger-sensitive applets, we allow JSFlow to run with the
flag sensitive. When present, the monitor blocks the execution
of filters attempting to send blacklisted values on the sink. To be
in line with rule Applet-High, which executes the filter with no
information flow restrictions, all variables in the filter code should
be labeled low.
7.2 Evaluation
Focusing on privacy, we evaluate the information flow tracking
mechanism of FlowIT on a collection of 60 applets. Due to the closed
source nature of applet’s code, the benchmarks are a mixture of
filter code gathered from forums or recreated by modeling existing
applets.
From the 60 applets, 30 are secure and 30 insecure, with a secure
and insecure version for each applet scenario. 10 applets were
considered trigger-sensitive, while the rest were assumed to be
trigger-insensitive.
Table 3 summarizes the results of our evaluation. Indicating the
security of the tool, false negatives are insecure programs that the
tool would classify as secure. Conversely, indicating the permissive-
ness of the tool, false positives are secure programs that the tool
would reject. No false negatives were reported, and only one false
positive is observed on the “artificial” filter code in Example 7.2.
Example 7.2.
1
2
3
if (H) { skip }
else { skip }
sink(linkL(b ));
The example is secure, as it always skips the action, irrespective
of the value of high guard H. However, the monitor blocks the filter
execution due to the action being skipped in high context.
The benchmarks are available for further experiments [3].
8 RELATED WORK
IFTTT. Our interest in the problem of securing IoT apps is inspired
by Surbatovich et al. [45], who study a dataset of 19,323 IFTTT
recipes (predecessor of applets before November 2016), define a
four-point security lattice and provide a categorization of potential
secrecy and integrity violations with respect to this lattice. They
focus solely on access to sources and sinks but not on actual flows
emitted by applets, and study the risks that users face by granting
permissions to IFTTT applets on services with different security
levels. In contrast, we consider users’ permissions as part of their
privacy policy, since they are granted explicitly by the user. Yet,
we show that applets may still leak sensitive information through
URL-based attacks. Moreover, we propose short- and longterm
countermeasures to prevent the attacks.
Efail by Poddebniak et al. [41] is related to our URL markup
attacks. They show how to break S/MIME and OpenPGP email
encryption by maliciously crafting HTML markup in an email to
trick email clients into decrypting and exfiltrating the content of
previously collected encrypted emails. While in our setting the
exfiltration of sensitive data by malicious applet makers is only
blocked by clients that refuse to render markup (and not blocked
at all in the case of URL upload attacks), efail critically relies on
specific vulnerabilities in email clients to be able to trigger malicious
decryption.
Mi et al. [36] conduct a six-month empirical study of the IFTTT
ecosystem with the goal of measuring the applets’ usage and ex-
ecution performance on the platform. Ur et al. [47, 48] study the
usability, human factors and pervasiveness of IFTTT applets, and
Huang at al. [22] investigate the accuracy of users’ mental models
in trigger-action programming. He et al. [19] study the limitations
of access control and authentication models for the Home IoT, and
they envision a capability-based security model. Drawing on an
extension of the dataset by Mi et al. [36], we focus on security and
privacy risks in the IoT platforms.
Fernandes et al. [11] present FlowFence, an approach to informa-
tion flow tracking for IoT application frameworks. In recent work,
Fernandes et al. [12] argue that IFTTT’s OAuth-based authorization
model gives away overprivileged tokens. They suggest fine-grained
OAuth tokens to limit privileges and thus prevent unauthorized
actions. Limiting privileges is an important part of IFTTT’s access
control model, complementing our goals that access control can-
not be bypassed by insecure information flow. Recently, Celik et
al. [6] propose a static taint analysis tool for analyzing privacy
violations in IoT applications. Kang et al. [34] focus on design-level
vulnerabilities in publicly deployed systems and find a CSRF attack
in IFTTT. Nandi and Ernst [38] use static analysis to detect pro-
gramming errors in rule-based smart homes. Both these works are
complementary to ours.
URL attacks. The general technique of exfiltrating data via URL
parameters has been used for bypassing the same-origin policy
in browsers by malicious third-party JavaScript (e.g., [49]) and
for exfiltrating private information from mobile apps via browser
intents on Android (e.g, [50, 51]). The URL markup and URL upload
attacks leverage this general technique for the setting of IoT apps.
To the best of our knowledge, these classes of attacks have not been
studied previously in the context of IoT apps.
Observational security. The literature has seen generalizations of
noninterference to selective views on inputs/outputs, ranging from
Cohen’s work on selective dependency [7] to PER-based model of
information flow [42] and to Giacobazzi and Mastroeni’s abstract
noninterference [15]. Bielova et al. [4] use partial views for inputs
in a reactive setting. Greiner and Grahl [18] express indistinguisha-
bility by attacker for component-based systems via equivalence re-
lations. Murray et al. [37] define value-sensitive noninterference for
compositional reasoning in concurrent programs. Value-sensitive
noninterference emphasizes value-sensitive sources, as in the case
of treating the security level of an input buffer or file depending on
its runtime security label, enabling declassification policies to be
value-dependent. Like value-sensitive noninterference, projected
noninterference builds on the line of work on partial indistinguisha-
bility to express value-sensitive sinks in a setting with URL-enriched
output. Sen et al. [43] describe a system for privacy policy com-
pliance checking in Bing. The system’s GROK component can be
leveraged to control how sensitive data is used in URLs. GROK is
focused on languages with support for MapReduce, with no global
state and limited control flows. Investigating connections of our
framework and GROK is an interesting avenue for future work.
9 CONCLUSION
We have investigated the problem of securing IoT apps, as repre-
sented by the popular IFTTT platform and its competitors Zapier
and Microsoft Flow. We have demonstrated that two classes of
URL-based attacks can be mounted by malicious applet developers
in order to exfiltrate private information of unsuspecting users.
These attacks raise concerns because users often trust IoT applets
to access sensitive information like private photos, location, fitness
information, and private social network feeds. Our measurement
study on a dataset of 279,828 IFTTT applets indicates that 30% of
the applets may violate privacy in the face of the currently deployed
access control.
We have proposed short- and longterm countermeasures. The
former is compatible with the current access control model, extend-
ing it to require per-applet classification of applets into exclusively
private and exclusively public. The latter caters to the longterm
expansion plans on IoT platforms. For this, we develop a formal
framework for tracking information flow in the presence of URL-
enriched output and show how to secure information flows in IoT
app code by state-of-the-art information flow tracking techniques.
Our longterm vision is that an information flow control mechanism
like ours can provide automatic means to vet the security of applets
before they are published.
Ethical considerations and coordinated disclosure. No IFTTT,
Zapier, or Microsoft Flow users were attacked in our experiments,
apart from our test user accounts on the respective platforms. We
ensured that insecure applets were not installed by anyone by mak-
ing them private to a single user account under our control. We
have disclosed content exfiltration vulnerabilities of this class to
IFTTT, Zapier, and Microsoft. IFTTT has acknowledged the design
flaw on their platform and assigned it a “high” severity score. We
are in contact on the countermeasures from Section 5 and expect
some of them to be deployed short-term, while we are also open
to help with the longterm countermeasures from Section 6. Zapier
relies on manual code review before apps are published. They have
acknowledged the problem and agreed to a controlled experiment
(in preparation) where we attempt publishing a zap evading Za-
pier’s code review by disguising insecure code as benign. Microsoft
is exploring ways to mitigate the problem. To encourage further
research on securing IoT platforms, we will publicly release the
dataset annotated with security labels for triggers and actions [3].
Acknowledgements This work was partially supported by the
Wallenberg AI, Autonomous Systems and Software Program (WASP)
funded by the Knut and Alice Wallenberg Foundation. It was also
partly funded by the Swedish Foundation for Strategic Research
(SSF) and the Swedish Research Council (VR).
REFERENCES
[1] alexander via IFTTT. 2018. Automatically back up your new iOS photos to
Google Drive. https://ifttt.com/applets/90254p-automatically-back-up-your-
new-ios-photos-to-google-drive. (2018).
[2] Almond via IFTTT. 2018. Get an email alert when your kids come home and
connect to Almond. https://ifttt.com/applets/458027p-get-an-email-alert-when-
your-kids-come-home-and-connect-to-almond. (2018).
[3] Iulia Bastys, Musard Balliu, and Andrei Sabelfeld. 2018.
If This Then What?
Controlling Flows in IoT Apps. Complementary materials at http://www.cse.
chalmers.se/research/group/security/IFCIoT.
[4] Nataliia Bielova, Dominique Devriese, Fabio Massacci, and Frank Piessens. 2011.
Reactive non-interference for the browser: extended version. Technical Report.
KULeuven. Report CW 602.
[5] Aaron Bohannon, Benjamin C. Pierce, Vilhelm Sjöberg, Stephanie Weirich, and
Steve Zdancewic. 2009. Reactive noninterference. In ACM Conference on Computer
and Communications Security. ACM, 79–90.
[6] Z. Berkay Celik, Leonardo Babun, Amit Kumar Sikder, Hidayet Aksu, Gang Tan,
Patrick McDaniel, and A. Selcuk Uluagac. 2018. Sensitive Information Tracking
in Commodity IoT. In 27th USENIX Security Symposium (USENIX Security 18).
USENIX Association, Baltimore, MD.
[7] E. S. Cohen. 1978. Information Transmission in Sequential Programs. In F. Sec.
Comp.
[8] Dorothy E. Denning and Peter J. Denning. 1977. Certification of Programs for
Secure Information Flow. Commun. ACM (1977).
[9] devin via IFTTT. 2018. Automatically text someone important when you call 911
from your Android phone. https://ifttt.com/applets/165118p-automatically-text-
someone-important-when-you-call-911-from-your-android-phone. (2018).
[10] Anind K. Dey, Timothy Sohn, Sara Streng, and Justin Kodama. 2006.
iCAP:
Interactive Prototyping of Context-Aware Applications. In Pervasive Computing,
4th International Conference, PERVASIVE 2006, Dublin, Ireland, May 7-10, 2006,
Proceedings. 254–271.
[11] Earlence Fernandes, Justin Paupore, Amir Rahmati, Daniel Simionato, Mauro
Conti, and Atul Prakash. 2016. FlowFence: Practical Data Protection for Emerging
IoT Application Frameworks. In USENIX.
[12] Earlence Fernandes, Amir Rahmati, Jaeyeon Jung, and Atul Prakash. 2018. De-
centralized Action Integrity for Trigger-Action IoT Platforms. In NDSS.
[13] GDPR 2018. General Data Protection Regulation, EU Regulation 2016/679. (2018).
[14] Martin Georgiev and Vitaly Shmatikov. 2016. Gone in Six Characters: Short URLs
Considered Harmful for Cloud Services. CoRR abs/1604.02734 (2016).
[15] Roberto Giacobazzi and Isabella Mastroeni. 2004. Abstract non-interference:
parameterizing non-interference by abstract interpretation. In POPL.
[16] Joseph Goguen and José Meseguer. 1982. Security Policies and Security Models.
[17] Google via IFTTT. 2018. Keep a list of notes to email yourself at the end of the
day. https://ifttt.com/applets/479449p-keep-a-list-of-notes-to-email-yourself-
at-the-end-of-the-day. (2018).