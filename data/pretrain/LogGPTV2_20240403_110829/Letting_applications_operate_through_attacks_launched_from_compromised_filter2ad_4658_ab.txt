mation in out future work. Actually such traﬃc poses the
problems of both the request replication and response val-
idation. Since the request is encrypted between the client
and the application on the front stage replica, the applica-
tion on the back stage replica has no way to understand the
semantics of the replicated request. As a result, the response
comparison is meaningless.
3.4 State Validation for Intrusion Detection
Comparing the state of replicated applications on two
replicas involves the whole memory space, metadata, and
dependable ﬁles of the service application processes. For
practical concerns, we select a subset of critical code/data
sections that will seriously aﬀect the execution correctness of
the service application for comparison. First, the code seg-
ment of the application shall remain unchanged once loaded
into memory. The request processing routine of the two
replicated applications must be identical, thus the code seg-
ment validation can help to detect any compromise that
leverages driver vulnerability exploitation to tamper service
application’s code segment. Second, the metadata of the ser-
vice application needs to be validated by comparison. The
metadata of the application process is maintained and up-
dated by OS kernel, but the compromised driver with unre-
stricted privilege can distort it for commercial proﬁt. Some
key metadata could be compromised by attackers to manipu-
late the correct execution of the service application. Though
with kernel privilege of the compromised driver, the attack-
ers have unrestricted right to tamper anywhere of the ker-
nel address space, the metadata of the service application is
most critical and vulnerable provided that the attacker aims
at commercial proﬁt. Last, some sensitive or critical data
of the service application must be veriﬁed through compar-
ison, since it determines the correctness of the application’s
execution and enterprise’s revenue. We allow service ap-
plication developers or system administrators to conﬁgure
what should be veriﬁed by comparison, because they are
supposed to know much better what is more critical and
valuable. By default, the global variables, static data, and
function pointers of the service application are veriﬁed by
bit-by-bit comparison.
Obviously, intensive state validation helps to detect the
compromise swiftly, while runtime overhead arises corre-
spondingly. In this paper, we design both the ﬁne-grained
time slice state validation and coarse-grained time slice state
validation, and allow dynamic switch between them to bal-
ance accuracy and performance. The ﬁne-grained time slice
state validation is system call synchronization based oﬄine
bitwise comparison. Whenever one system call is issued by
one service application process, the state of the process, in-
cluding code segment, metadata, and dependable ﬁles, is
logged. Since the two service applications are synchronized
at the granularity of system call, the states (contained in the
logs) of them must be identical. The coarse-grained time
slice state validation is request synchronization based oﬄine
bitwise comparison. The state of each service application is
logged whenever one request is processed, and then veriﬁed
through comparison.
3.5 Operate-through Intrusion Response
With the response and state validation, the compromise
to the service application through vulnerable driver code
exploitation can be quickly detected. During normal execu-
tion before any exploit, the two replicated applications are
well synchronized at least at the per packet processing gran-
ularity. Hence, from the front tier proxy’s point of view,
the responses to incoming requests arrive generally simul-
taneously. Due to DRASP architecture we deployed, the
service application on the front stage replica will always be
the victim, while the one on the back stage replica survives.
Though the victim replica malfunctions due to the exploita-
tion, the other replica still performs well and stick to the
criterion of correct execution. Thus, it is safe for the system
administrator to transfer the following service workload to
the survival replica, without losing any accumulated state,
continuity or correctness. Simultaneously, system adminis-
trator should also prepare to restart a new criteria replica
from a clean VM image, and conﬁgure the corresponding
heterogeneous devices emulation and service application, to
continue the DRASP protection.
4. EVALUATION
In this section, we report experiments on DRASP archi-
tecture by showing the eﬀectiveness and eﬃciency of DRASP
in the driver-vulnerability-oriented service-application-target
intrusion detection. We run Xen hypersivor 3.3.0 as virtual
platform, and conﬁgure it to emulate Realtek RTL8139 NIC
plus Gravis ultrasound GF1 sound card for one DomU, and
Intel 82540EM NIC plus sound blaster 16 sound card for the
other. Though there are other heterogeneous device emula-
tion options, e.g., video card, USB etc., we think NIC and
sound card are suﬃcient to demonstrate proof-of-concept of
DRASP framework. Both of the two guest operating sys-
tems on DomU are installed with Fedora 5 (kernel version
2.6.15). We run dhttpd server on the two guest OSes as ser-
vice application, and deploy the modiﬁed tinyproxy as the
front tier proxy for request replication and response valida-
tion.
4.1 Capacity in Driver Vulnerability Oriented
Intrusion Detection
Response Validation Based Detection. Attackers
can set the existing driver function pointer to arbitrary code
either implemented by the attackers or of OS kernel’s. As a
result, the attackers can execute any code with kernel priv-
ilege. We simulate such an attack by inserting a buﬀer
overﬂow bug into packet processing function of the Real-
tek RTL8139 NIC driver 8139too, while the Intel 82540EM
NIC driver e1000 does not have such a bug at the corre-
sponding function. The attacker exploits the bug in the
driver 8139too, and then redirects the hard start xmit func-
tion pointer to attacker’s injected code. Thus, whenever
any packet is transmitted on the victim replica, the control
ﬂow will be redirected to the driver’s injected code. The
injected code simulates the manipulation of some payload
data of each packet for commercial proﬁt. Since the driver
e1000 is not inserted with such a bug, the exploit did not
succeed and the function pointer hard start xmit cannot be
tampered on the survival replica. Thus, the response from
the survival replica is the correct one without manipulation.
As a result, the response validator on the front tier proxy
detects such mismatch among the responses made by the
two service applications, and conﬁrms a compromise of the
victim replica.
4.2 Efﬁciency
In order to evaluate the runtime overhead introduced by
state and response validation, we compare the performances
of dhttpd server running on the native Xen-HVM Domain
U and on the Xen-HVM Domain U with our instrumenta-
tion (including request replication, response and state val-
idation functionalities). On another machine, we simulate
clients sending continuous requests over concurrent connec-
tions to fetch an 24 KB ﬁle. The native Xen-HVM Domain
U achieves the response time of almost 45 ms. The response
time of dhttpd server with our instrumentation with coarse-
grained time slice state validation is around 47 ms, while the
response time with ﬁne-grained time slice state validation is
around 50 ms. We believe that such overhead is reasonable
and aﬀordable for most service applications.
4.3 Continuity, Accumulated State and Cor-
rectness Preservation
We run dhttpd server on our instrumentation platform,
and Apache benchmark [1] on another machine to evaluate
the continuity, accumulated state and correctness preserva-
tion functionalities of DRASP. We conﬁgure Apache bench-
mark to simulate 50 concurrent connections sending requests
to dhttpd server for 600 seconds. During this period, tinyproxy
continues to switch between the front stage replica and the
back stage replica per 10 seconds. We repeat the experiment
for 10 times, and do not ﬁnd any missing/false response
for all the requests. Hence, we can conclude that once one
replica is compromised, the service will continue without
any interruption by transferring the workload to the other
replica.
5. RELATED WORK
Application state preservation. Existing application
recovery techniques ([13], [9], [14], [5]) can preserve the con-
tinuity and accumulated states only in the scenario when
the application’ vulnerability is exploited, rather the OS ker-
nel. Most of them ([13] and [9]) take periodical snapshot of
the application state and log system events during routine
execution. Upon exploit to the protected application, de-
pendency tracking ([10], [13], and [21]) is applied to analyze
the intrusion “footprint” across the system. Roll-back/roll-
forward actions are performed to get rid of intrusion harm,
meanwhile the clean state of the application can be pre-
served with best eﬀort. Failure-Oblivious Computing [14] is
proposed to continue server execution through memory error
exploit by inserting checks that dynamically detect invalid
memory accesses. Data structure consistency speciﬁcation
is proposed by [5] to automatically detect and repair data
structures, thus enabling the program to continue to execute
productively even in the face of otherwise crippling errors.
Diversity approach. Software diversity for intrusion de-
tection has been studied in several works, such as COTS
[19], Behavioural Distance [8], and Detection of Split Per-
sonalities [2]. COTS Diversity [19] proposes design diversity,
e.g., N-version programming, and applies it into web servers
to verify their interactions with the environment for any
anomaly, e.g., HTTP responses from those web servers. Be-
havioural Distance [8], and Detection of Split Personalities
[2] aim to detect intrusion or anomaly by comparing the sys-
tem call sequence made by the diverse applications. Though
all the above approaches are eﬀective in detecting compro-
mised applications, they are limited in detecting the com-
promise launched from driver code vulnerability exploita-
tion as DRASP. The seminal work N-variant [4] proposes
address space partition and instruction set tag diversities
to detect divergences caused by intrusions. Though, both
N-variant and DRASP can achieve similar intrusion detec-
tion, we think DRASP approach is more generic in server
environment, especially with fault tolerant system deployed.
6. CONCLUSION
In this paper, we present a novel approach, DRASP, to
prevent compromised drivers from manipulating service ap-
plications for commercial proﬁt, and preserve as much accu-
mulated state, continuity and correctness of the service as
possible. DRASP relies on virtual platform underneath to
emulate heterogeneous devices for guest operating system,
and correspondingly produce driver-diverse replicas. Ser-
vice applications identically replicated on the two replicas
are synchronized either at the system call or packet pro-
cessing granularity. By validating the responses and states
of the two applications on the two replicas, DRASP ap-
proach can swiftly detect the intrusion to the service ap-
plication through the driver vulnerability exploitation. Our
evaluation demonstrates that DRASP can achieve on-the-ﬂy
driver-oriented intrusion response and ensure the correctness
of the applications’ execution.
Acknowledgment
This work was supported by AFOSR FA9550-07-1-0527 (MURI),
NSF CNS-0905131, ARO W911NF-09-1-0525 (MURI), NSF
CNS-0916469, ARO W911NF1210055, and AFRL FA8750-
08-C-0137.
7. REFERENCES
[1] ab - Apache HTTP server benchmarking tool.
http://httpd.apache.org/docs/2.0/programs/ab.html.
[2] Davide Balzarotti, Marco Cova, Christoph Karlberger,
Christopher Kruegel, Engin Kirda, and Giovanni
Vigna. Eﬃcient detection of split personalities in
malware. In NDSS, 2010.
[3] Andy Chou, Junfeng Yang, Benjamin Chelf, Seth
Hallem, and Dawson Engler. An empirical study of
operating systems errors. In SOSP, pages 73–88, 2001.
[4] Benjamin Cox, David Evans, Adrian Filipi, Jonathan
Rowanhill, Wei Hu, Jack Davidson, John Knight, Anh
Nguyen-tuong, and Jason Hiser. N-variant systems: A
secretless framework for security through diversity. In
USENIX Security Symposium, pages 105–120, 2006.
[5] Brian Demsky and Martin Rinard. Automatic
detection and repair of errors in data structures. In
OOPSLA, pages 78–95, 2003.
[6] Alex Depoutovitch and Michael Stumm. Otherworld -
giving applications a chance to survive os kernel
crashes. In Eurosys, 2010.
[7] Xiaoning Ding, Hai Huang, Yaoping Ruan, Anees
Shaikh, Brian Peterson, and Xiaodong Zhang.
Splitter: a proxy-based approach for post-migration
testing of web applications. In Eurosys, 2010.
[8] Debin Gao, Michael K. Reiter, and Dawn Song.
Behavioral distance for intrusion detection. In RAID,
pages 63–81, 2005.
[9] Taesoo Kim, Xi Wang, Nickolai Zeldovich, and
M. Frans Kaashoek. Intrusion recovery using selective
re-execution. In OSDI, 2010.
[10] Samuel T. King and Peter M. Chen. Backtracking
intrusions. In SOSP, 2003.
[11] Clemens Kolbitsch, Thorsten Holz, Christopher
Kruegel, and Engin Kirda. Inspector gadget:
Automated extraction of proprietary gadgets from
malware binaries. In IEEE Symposium on Security
and Privacy, 2010.
[12] Nicolas Palix, Gael Thomas, Suman Saha, Christophe
Calv´l´ls, Julia Lawall, and Gilles Muller. Faults in
linux: ten years later. In ASPLOS, 2011.
[13] Feng Qin, Joseph Tucek, and Yuanyuan Zhou. Rx:
treating bugs as allergies – a safe method to survive
software failures. In SOSP, pages 235–248, 2005.
[14] Martin Rinard, Cristian Cadar, Daniel Dumitran,
Daniel M. Roy, Tudor Leu, and William S. Beebee.
Enhancing server availability and security through
failure-oblivious computing. In OSDI, pages 303–316,
2004.
[15] Rodrigo Rodrigues, Miguel Castro, and Barbara
Liskov. Base: using abstraction to improve fault
tolerance. In SOSP, pages 15–28, 2001.
[16] Daniel J. Scales, Mike Nelson, and Ganesh
Venkitachalam. The design of a practical system for
fault-tolerant virtual machines. ACM SIGOPS
Operating Systems Review, 44(4):30–39, 2010.
[17] R. Sekar. An eﬃcient black-box technique for
defeating web application attacks. In NDSS, 2009.
[18] Yuen-Lin Tan, Terrence Wong, John D. Strunk, and
Gregory R. Ganger. Comparison-based ﬁle server
veriﬁcation. In USENIX Annual Technical Conference,
2005.
[19] Eric Totel, Frederic Majorczyk, and Ludovic Me. Cots
diversity based intrusion detection and application to
web servers. In RAID, pages 43–62, 2005.
[20] Jian Yin, Jean-Philippe Martin, Arun Venkataramani,
Lorenzo Alvisi, and Mike Dahlin. Separating
agreement from execution for byzantine fault tolerant
services. In SOSP, pages 253–267, 2003.
[21] Shengzhi Zhang, Xiaoqi Jia, Peng Liu, and Jiwu Jing.
Cross-layer comprehensive intrusion harm analysis for
production workload server systems. In ACSAC, 2010.