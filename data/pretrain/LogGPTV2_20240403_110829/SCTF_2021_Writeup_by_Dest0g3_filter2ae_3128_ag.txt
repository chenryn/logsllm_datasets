                y = (x1 + y1 * x2) * inverse(y1 + x2, mod) % mod
                return (x, y)
            elif (x1 - y1 ** 2) % mod != 0:
                x = (x1 * x2 + 2) * inverse(x1 - y1 ** 2, mod) % mod
                return (x, None)
            else:
                return (None, None)
        else:
            if (x1 + x2 + y1 * y2) % mod != 0:
                x = (x1 * x2 + (y1 + y2) * 2) * inverse(x1 + x2 + y1 * y2, mod) % mod
                y = (y1 * x2 + x1 * y2 + 2) * inverse(x1 + x2 + y1 * y2, mod) % mod
                return (x, y)
            elif (y1 * x2 + x1 * y2 + 2) % mod != 0:
                x = (x1 * x2 + (y1 + y2) * 2) * inverse(y1 * x2 + x1 * y2 + 2, mod) % mod
                return (x, None)
            else:
                return (None, None)
    def myPower(P, a, mod):
        #myPower(M, e, finitN)
        target = (None, None)
        t = P
        while a > 0:
            if a % 2:
                target = add(target, t, mod)
            t = add(t, t, mod)
            a >>= 1
        return target
    q = 96462444106165749114415475247527781475899281431287939376394470369752659528725019508082117417839694214107263318483433819291390803338678461598066595218255356966679663156577567407281598226907095764472683889152435703416069908655422522652572101471012612583954177451023603485842114326384356753874451635385984216161
    p = 109907086493390616985013523787169507492760993681846064986781887428535317768524351469280456086685032407075193800472550867209575915122581771387158292578171930229912424185824752394842783208794649345771724454755004504493300150933357546701398911549986363985587419816454664592991507387712041226027111204451401188919
    pad = 137721017917989303482714812804521878485399750349045730614909765849483734915386664162501818685326223825286437120470811742765458919135068008802037057001305957541685605553587948107128475798135395471664645215380069682937424337247849713639490229310163392013463505444535723967494278649509979458626531074957697946993
    c =(166431982461794383404765894353564652417286281286845040815812696140245010936597690881728163044999563295606777822589599719988749943986277241768406486432942976971806090294723679213709276119783333317719736480695779056909005344748713312922208943911234004090154620267867923985496066206993388826848408016113230559895319140692117846347161636934408901418900660630848238252785792937558161125236263657446105045318374541989968623804546523311550966511721989817712979188863096534909514606855128351038197938270797429538803633123512162732858973784140131107258309968348721003718514188938837464306149466871073659419970807525573186177295974780597677202177278450017235952741828648411332753623971689087414338005032425283018127420482524353019039589883070439499816602536780385008119304807415943660538320547325663679105882323899559945539040614335041356182742492246188685166079997529059728431638477119368978924088838246744082322934215253952260604000, 583811541976786499144377377934025235584387131534635007022251365145942422227051060939985851484706210836767096516219672713844985063110538384884200155176672559391335026702801538941879468724743394010709887016418730105669706000795612301487140087279830678314909581314560039721638176230206155638477025095967507768951649990761591795801514872889641096293748540210199152367695575307597602483917419532171797268649128704295643514700599003974515092476985280147122085743107678260804403848731411523152508976557299100005180707794868709825610527244045712157278351329970986028569553983677992653806577740248777743401724460474149400544970284499843498104577389527968551869656641095498167438798405641085540418812727789234175230571563718616654865504708574325812468631975439864831103170397966449939536937839005435391565163846769907939906973391750780003117155026788680288079657919663977842795793378060965920997621456965471449613549935486637988132751)
    pad =117974859274346072583739577879237661359633939326177996925545772649078598610987301667759912933925662285927802009264196767594856451275711699740105534472053429854738915648249617679338619108159296653886787677835343872851980353011790571950727888130983528711607533379553800325336063577707548506215714783818842480239
    e1 = 2816364923215542703181103700546313680109699436794123566226755921623782970809742716991858902522746028156003630828900076158585411663702115647361928930336417992964232866389633747914430575706682691181456229019202935906062908587609722493361057620793975135051750614902337992567625486243873224234033256269675850528518211544253411469959902538438091955199793022342556708413965433779350671626129791137318004869160747756926534289668211426638719794731091512998036558584096298208598924494265349419704363061401758956080768587013310392993665629098212668360357545504145264857268152702858316846654320106999264941629532500605382044391
    e = 7688844608122166688554531210042890906331317367269721882913839185271394937163082744925864177779002472233203611799817777199710838582026800408107353934895515601449211254844714968565944446477081395969750472765835932266965229128856452781816269289992832230947973758915003020471524086758777628035741239238359503130190607998292797906572873297770527569698066692949759789487870533498458377873270494530630801359434977962847044065574759512179511120769361043269784870586239376868814910804487324802261815900392837165247623551114275644333697133133053782070322628235841247238848243632844856346687843129893451542644093889516093928419
    d = inverse(e, ((p**3)-1)*((q**3)-1)*((pad**3)-1))
    print(d)
    #print((p-1)*(q-1)*(pad-1))
    n = p*q*pad
    M = myPower(c,d,n)
    print(M)
    print(long_to_bytes(M[0]))
    print(long_to_bytes(M[1]))
    #SCTF{@@##Say_say_it_again_Sometimes_the_RSA_was_winding_in_my_mind@@##}
###  christmasZone
通过Gröbner Basis进行lcg系数的求解
    p= 12827136631950660209216359962655539318636877290716821157529934201187219916291097512646340799814928196320503957951369709433553128222068986394496491383172957
    vs= [(1, 41380349828344668841722013593988154321093099094259357736377736864534670060706791545109606752287504685771188039864996559723310519654574206262666374726529575), (2, 384991383452695588666216941014720946683784460631264884797727791455132234632438790091275812930469701960771509347594917989067900680524277581738313254612711871), (3, 2324819542625170348844359780621276807555503871252850096339863557086701529895982915686058495680950841284900600209950521822433876540926171344905286018406959743), (4, 9038337376811138597523510592313164861722600343233504981317555262132010358260176119807566000121093361554267202529233467631393363767071867844509978588374760233)]
    Fp = GF(p)
    P. = PolynomialRing(Fp)
    f = []
    for X, y in vs:
        f.append(
            x_1+(a*x_1+b)*X+(a^2*x_1+a*b+b)*X^2+(a^3*x_1+a^2*b+a*b+b)*X^3+(a^4*x_1+a^3*b+a^2*b+a*b+b)*X^4+(a^5*x_1+a^4*b+a^3*b+a^2*b+a*b+b)*X^5-y)
    f = ideal(f)
    B = f.groebner_basis()
    print(B)
    print(-B[0])
再根据gift值，以及生成的特殊phi值构造二元copper  
f(x,y) = x _(y**2+a_ y+b)+1 (x = k,y = p+q)
微调参数分解n值，得到p q
    import itertools
    def small_roots(f, bounds, m=1, d=None):
            if not d:
                    d = f.degree()
            R = f.base_ring()
            N = R.cardinality()
            f /= f.coefficients().pop(0)
            f = f.change_ring(ZZ)
            G = Sequence([], f.parent())
            for i in range(m+1):
                    base = N^(m-i) * f^i
                    for shifts in itertools.product(range(d), repeat=f.nvariables()):
                            g = base * prod(map(power, f.variables(), shifts))
                            G.append(g)
            B, monomials = G.coefficient_matrix()
            monomials = vector(monomials)
            factors = [monomial(*bounds) for monomial in monomials]
            for i, factor in enumerate(factors):
                    B.rescale_col(i, factor)
            B = B.dense_matrix().LLL()
            B = B.change_ring(QQ)
            for i, factor in enumerate(factors):
                    B.rescale_col(i, 1/factor)
            H = Sequence([], f.parent().change_ring(QQ))
            for h in filter(None, B*monomials):
                    H.append(h)
                    I = H.ideal()
                    if I.dimension() == -1:
                            H.pop()
                    elif I.dimension() == 0:
                            roots = []
                            for root in I.variety(ring=ZZ):
                                    root = tuple(R(root[var]) for var in f.variables())
                                    roots.append(root)
                            return roots
            return []
    e = 2122057207992053205813770227849040233008910764365408170807753866052370273036652511326089337097360978735074872616654616913246201310148862001548717525315340025551386286859760434183016041810428435636703565295076056164899655565064479034568939414539781862057507880933035055798925469493379171063624396109774778347319852379080566673380010455470481679145108944783447900704049011034802113265281840271722439782048757303053321402550218515376334799866137565004833177407151305907248656027100625115285653505268015889011758846754314363803434935375750532978323034293333866829909394024977100845590141939498841156488858312084500963993
    n = 64392795853847475796939596948374573513341136006013188358665448316305707477998438325517993586430100318003625505157712138814030987620038360820900112359350226402638642419396935215229157012026467896203963294845355310085476165076942465877433408205263068546705226319393063008332679430070032638523530045872344446063 
    PR. = PolynomialRing(Zmod(e))
    b = n**2-n+1
    a = n+1
    f = x*(y**2+a*y+b)+1
    bounds = (2^400,2^513)
    solves = small_roots(f, bounds, m=3,d=4)
    print(solves)
    from z3 import *
    s = Solver()
    p=Int('p')
    q=Int('q')
    s.add(p+q == 16075043011792317702314886102947415867389005788775646985921769735667763497545302824191943535380623937133010105678608525588010746665008631519574789537497184)
    s.add(p*q == 64392795853847475796939596948374573513341136006013188358665448316305707477998438325517993586430100318003625505157712138814030987620038360820900112359350226402638642419396935215229157012026467896203963294845355310085476165076942465877433408205263068546705226319393063008332679430070032638523530045872344446063)
    if s.check() == sat:
        print(s.model())
根据复数群阶为p^2-1，进行(m1,m2)坐标的计算
    from Crypto.Util.number import *
    def PowPlus(msg,k):
        c=Complex(msg[0],msg[1])
        while k>0:
            if k%2:
                k-=1
                c.OnePlus()
            else:
                k//=2
                c.Double()
        return c.val()
    class Complex:
        baseRe = 1
        baseIm = 0
        p= 7580404339410605275626408632293985390119410811758716323067754026905773097627216054700243523685903084284434158078654472410013702925363551739091210471600391
        q= 8494638672381712426688477470653430477269594977016930662854015708761990399918086769491700011694720852848575947599954053177997043739645079780483579065896793
        n  = p*q
        #print(n)
        def __init__(self, re=0, im=0):
            self.re = re
            self.im = im
        def OnePlus(self):
            _re = (self.re*Complex.baseRe - self.im*Complex.baseIm)%Complex.n
            _im = (self.re*Complex.baseIm + self.im*Complex.baseRe)%Complex.n
            Complex.baseRe = _re
            Complex.baseIm = _im
        def Double(self):
            _re  = (self.re*self.re - self.im*self.im)%Complex.n
            _im  = (self.re*self.im + self.im*self.re)%Complex.n
            self.re = _re
            self.im = _im
        def val(self):
            return Complex.baseRe,Complex.baseIm,Complex.n
    c = (19398712966389173067515660342342371376171822855077792430320907920482468319034356508473830699130119726502328267606091971072624658237697431558761718296916369668202230512807622341524837789641448767802361925545348467904711602267688826344269930586157457184165009996779745720616560780946563277776544719243932403743,
    13560918884675796397422230974896753903564514060544004622609605573166124357809803049342207856908237157989458174631058128913271365699175849042916944962684319362603309646697695167167430136068004838289739138033112696576679443996914506782400912475705559889360576361738784125657707992917972167925405463413645788482)
    n=64392795853847475796939596948374573513341136006013188358665448316305707477998438325517993586430100318003625505157712138814030987620038360820900112359350226402638642419396935215229157012026467896203963294845355310085476165076942465877433408205263068546705226319393063008332679430070032638523530045872344446063
    gift=2122057207992053205813770227849040233008910764365408170807753866052370273036652511326089337097360978735074872616654616913246201310148862001548717525315340025551386286859760434183016041810428435636703565295076056164899655565064479034568939414539781862057507880933035055798925469493379171063624396109774778347319852379080566673380010455470481679145108944783447900704049011034802113265281840271722439782048757303053321402550218515376334799866137565004833177407151305907248656027100625115285653505268015889011758846754314363803434935375750532978323034293333866829909394024977100845590141939498841156488858312084500963993
    q = 7580404339410605275626408632293985390119410811758716323067754026905773097627216054700243523685903084284434158078654472410013702925363551739091210471600391
    p = 8494638672381712426688477470653430477269594977016930662854015708761990399918086769491700011694720852848575947599954053177997043739645079780483579065896793
    e = 65537
    d = inverse(e,((p**2-1)*(q**2-1)))
    m = PowPlus(c,d)
    print(m)
最后带回到lcg的最终函数中，进行求根操作
    from Crypto.Util.number import *
    p= 12827136631950660209216359962655539318636877290716821157529934201187219916291097512646340799814928196320503957951369709433553128222068986394496491383172957
    Fp = GF(p)
    P. = PolynomialRing(Fp)
    f = 11107539725989784588516877085136635908441115815151777097583290968795799306769460994508287779871429800738567516424098853986080960831813283913437018239025437+6034160863709066159778637899413973476966589977510559161150723567270894349213718484715685277168177740978230265501194740744557053261099813264349946684623551*x+11808887268447615257558026664894363806999904142221396040940006609671437127001478734524740326597666486964008913813253292274982099443656137651300834404341881*(x^2)+408075133608148131249456572820748106237284025037403147065865246531192645806945237995787775219190720718153273784347803717882930185025920239290910304167402*(x^3)+4586162932140607804368341437906558310926893012932245826928444385726983454281600231400780493854722062464754924769164109577757840996243554965034972504134321*(x^4)+7435523904449446900250673933815874711521312121405976462709406086538363177633587861964325099576317873907473145572937759422049634936735496229252692590236983*(x^5)-350564116714246428053802172070389474233820454679751477780333001945330301565284220095378516478556445046920811976843797532587184369824085245405082799485151297628128033782611724987963819163245257329754695802584996154786305817413634573781285885239952095626683987775731171250077614548234305028236410536510063272314122315196083472829068485752967550562846302833889516005729928622362083333892583681788035557019567883417091108619687009927945069447260541066489511357746392173728172212543
    m = f.roots()[0][0]
    long_to_bytes(m)
    #SCTF{all1Want4ChristmasisU}
###  ciruit map
下载附件到处看看，发现是个DES，再看看秘钥空间2^24，还有两次加密，但是有个加密0的，
跑中间相遇攻击
    #include
    #include
    #include
    using namespace std;
    unsigned int SBoxes[6][16] = {
        {15, 1, 7, 0, 9, 6, 2, 14, 11, 8, 5, 3, 12, 13, 4, 10}, 
        {3, 7, 8, 9, 11, 0, 15, 13, 4, 1, 10, 2, 14, 6, 12, 5}, 
        {4, 12, 9, 8, 5, 13, 11, 7, 6, 3, 10, 14, 15, 1, 2, 0}, 
        {2, 4, 10, 5, 7, 13, 1, 15, 0, 11, 3, 12, 14, 9, 8, 6}, 
        {3, 8, 0, 2, 13, 14, 5, 11, 9, 1, 7, 12, 4, 6, 10, 15}, 
        {14, 12, 7, 0, 11, 4, 13, 15, 10, 3, 8, 9, 2, 6, 1, 5}};
    unsigned int SInvBoxes[6][16] = {
        {3, 1, 6, 11, 14, 10, 5, 2, 9, 4, 15, 8, 12, 13, 7, 0}, 
        {5, 9, 11, 0, 8, 15, 13, 1, 2, 3, 10, 4, 14, 7, 12, 6}, 
        {15, 13, 14, 9, 0, 4, 8, 7, 3, 2, 10, 6, 1, 5, 11, 12}, 
        {8, 6, 0, 10, 1, 3, 15, 4, 14, 13, 2, 9, 11, 5, 12, 7}, 
        {2, 9, 3, 0, 12, 6, 13, 10, 1, 8, 14, 7, 11, 4, 5, 15}, 
        {3, 14, 12, 9, 5, 15, 13, 2, 10, 11, 8, 4, 1, 6, 0, 7}};
    unsigned int PBox[] = {15, 22, 11, 20, 16, 8, 2, 3, 14, 19, 18, 1, 12, 4, 9, 13, 23, 21, 10, 17, 0, 5, 6, 7};
    unsigned int PInvBox[] = {20, 11, 6, 7, 13, 21, 22, 23, 5, 14, 18, 2, 12, 15, 8, 0, 4, 19, 10, 9, 3, 17, 1, 16};
    unordered_map  middle_data;
    unsigned int S(unsigned int block, unsigned int SBoxes[6][16]){
        unsigned int output = 0;
        for(int i = 0; i > 4 * i) & 0b1111] > pbox[i]) & 1;
            output |= (bit << i);
        }
        return output;
    }
    unsigned int encrypt_data(unsigned int block, unsigned int key){
        unsigned int res = block;
        for(int i = 0; i < 3; i++){
            res ^= key;
            res = S(res, SBoxes);
            res = permute(res,PBox);
        }
        res ^= key;
        return res;
    }
    unsigned int decrypt_data(unsigned int block, unsigned int key){
        unsigned int res = block;
        res ^= key;
        for(int i = 0; i < 3; i++){
            res = permute(res, PInvBox);
            res = S(res, SInvBoxes);
            res ^= key;