Browser. An example follows.
(function(){ this.evaluate= function (){codes} other codes})();
From the perspective of the native JavaScripts, they can
only see evaluate but no other private objects inside the vir-
tual JavaScript engine. The web developer (writing trusted
scripts owned by the web site) would be required to avoid
overwriting this narrow interface of Virtual Browser.
6Note that functions such as document.write belong to DOM
and not the JavaScript engine.
4.2 Communication through Redirection
In Section 4.2.1, we will discuss data security that makes
sure general data is secured, and script security that is more
complicated to handle. Then, in Section 4.2.2, we give a
detailed analysis on each component of Virtual Browser to
show how data and scripts are ﬂowing.
4.2.1 Data Security
Data security consists of general data security and security
of special data—script.
General Data Security.
Data in our system is classiﬁed into two categories: pri-
vate data and shared data. Private data refers to virtu-
alized objects and functions in Virtual Browser, which are
generated by third-party codes. Shared data refers to some
shared objects for communication between the third-party
and the trusted codes. Private data in Virtual Browser is
safe because of encapsulation of our sandbox in Section 4.1.2.
We however need to consider the security of shared objects.
Data in shared objects can be secured in various ways. We
illustrate two methods: mirrored objects and access control.
• Mirrored Object. Some objects, such as String, Date, and
Math are not necessarily shared. We can create a copy of
such an object, which means we turn them into private
data. Below is a simpliﬁed example copied from Mozilla
Narcissus JavaScript engine[28].
function String(s) {
s = arguments.length ? "" + s : "";
if (this instanceof String) {
this.value = s;
return this;
}
return s;
}
When third-party scripts try to access a property of String,
third-party scripts are accessing the mirrored String de-
ﬁned in Virtual Browser. Similarly, Object may be mir-
rored to prevent using prototype chain to access the orig-
inal (unique) Object object. Notice that not only Object
is virtualized here but also the whole process of accessing.
Because each time third-party codes call the property pro-
totype, they will go through getValue interface of Virtual
JavaScript engine. Virtual Browser will fetch virtualized
contents for it. So the whole accessing process is secured.
• Access Control. Virtual Browser uses access control to
secure must-share data, which means third-party scripts
can access an object only when they have the right to do
that. There are many existing works about how to facil-
itate communications between diﬀerent entities, such as
methods in postMessage channel [14], and Object Views
[25]. They employ diﬀerent policy engines. We can adopt
either of them. Object Views [25], which can also be de-
ployed on Google Caja [20], is a good choice for us.
Script Security.
Scripts are also a special kind of data, but they can be
executed. Execution of third-party scripts outside of the
virtual JavaScript engine may cause the third-party Java-
Script to escalate its privileges. Based on the assumption
about native execution we made earlier, i.e., scripts have to
be parsed before execution, we need to prevent third-party
data from ﬂowing into the native parser. Therefore, our task
is to track ﬂows that might go out of the virtual JavaScript
engine. Scripts in Virtual Browser are classiﬁed into two
categories: conﬁrmed scripts and potential scripts.
First, some types of data that we know are JavaScript
codes, such as the data assigned to innerHTML, the pa-
rameter of setTimeout, etc. For this type of scripts, we use
redirection to redirect these kinds of data back into Virtual
Browser. There are two categories.
• Scripts that need immediate execution. For example, when
some JavaScript strings passed to eval, they will be added
to the JavaScript execution queue immediately. When
processing eval, we directly put these codes back into our
system. For example, eval(str) will be interpreted as eval-
uate(str) in which evaluate is part of our system.
• Scripts that need delayed execution. Some scripts’ execu-
tion is triggered by certain events or functions. For ex-
ample, when setTimeout(”alert(1)”,100) is executed, the
code inside will be executed 100 milliseconds later. We
adopt a pseudo-function pointer here. Virtual Browser
ﬁrst parses scripts and put it into an anonymous func-
tion. In this function, Virtual Browser executes parsed
scripts with correct scope and registers this anonymous
function with events that will trigger the original func-
tion. Therefore, when an event triggers this function
or a function calls this function, this function will ex-
ecute the parsed data inside our system. We still en-
sure third-party scripts are running in the sandbox. For
the aforementioned example, it will look like setTime-
out(function(){execute(parsed node, exe context)},100). We
call this method the pseudo-function pointer method.
Second, we do not know if some data is a script or not.
This data is therefore a potential script. Potential scripts
exist because the trusted JavaScripts running on the na-
tive JavaScript engine, plugins, etc. have higher privileges
and we do not have control over them. They may get data
and execute it as a script, which is the well-known privi-
lege escalation problem. Trusted JavaScripts from the web
site will not intentionally behave maliciously, but they may
unintentionally grant escalated privileges to the third-party
JavaScripts. Next, we will analyze the potential privilege es-
calation possibilities in our system, which can be classiﬁed
into three categories.
• Access Shared Object. Trusted JavaScript code may ac-
cess shared objects, which are contaminated by third-
party JavaScript code. Therefore, trusted JavaScript code
might unintentionally grant escalated privileges to a third-
party JavaScript.
• Access Sandbox. Trusted JavaScript codes may access the
sandbox directly. We have already discussed this issue in
Section 4.1.2.
• Access Third-Party JavaScript. Trusted JavaScript code
may want to invoke some third-party JavaScript code.
Because of our encapsulation of Virtual Browser, direct
access is prohibited. However, if a function call is nec-
essary, Virtual Browser can use pseudo-function pointers
discussed earlier to let trusted JavaScript invoke third-
party code while ensuring security at the same time.
Because the last two types of privilege escalation are solved
by encapsulation, only the ﬁrst one remains. This type of
privilege escalation is not the focus of our paper. We can
leverage the solutions from previous works. Finifter et al.
[19] propose a solution by limiting interface of shared ob-
jects and third-party programs in ADSafe. The interface of
Virtual Browser is similarly designed to be narrow in order
to control the ﬂow.
4.2.2 Security Analysis of Data Flows in Virtual Browser
Components
Now, we discuss the ﬂow of data in Virtual Browser. We
analyze data ﬂows and script ﬂows among three components,
which are the virtual JavaScript engine, the virtual HTML
and CSS parsers.
Securing Data Flows of the Virtual JavaScript Engine.
A narrow interface will help limit data ﬂows and ease data
ﬂow examination. As mentioned in Section 3.1.2, the inter-
face of the virtual JavaScript Engine has three parts: put-
Value, getValue and function call/return. Every ﬂow from
the virtual JavaScript engine needs to go through this inter-
face.
We show all possible data and script ﬂows of the virtual
JavaScript engine in Figure 5. Every ﬂow that goes into the
native JavaScript engine is conservatively considered mali-
cious because we have no control over the native JavaScript
engine. All the ﬂows in Figure 5 are presented below.
• Redirection of Possible Accesses (Flows 1 and 2). Flow
1 exists because JavaScript can generate JavaScript. For
example, eval can execute a string as JavaScript. Flow
2 is caused by the fact that some objects, functions and
properties may lead to HTML, JavaScript, and CSS pars-
ing. For example, the document.write function and in-
nerHTML property cause HTML parsing. The onClick
property causes JavaScript parsing. We use redirection to
redirect these functions to corresponding components in
our system. For example, a modiﬁcation of innerHTML
in virtual DOM node will use the virtual HTML parser
in Virtual Browser to parse it.
• Privilege Escalation (Flows 4, 5, and 6). Because trusted
JavaScript has higher privileges, privilege escalation can
happen. It can do anything as we mentioned in Section
4.2.1. Flow 4 is to access shared objects. Flow 5 is to ac-
cess third-party JavaScript codes. Flow 6 is to access Vir-
tual Browser itself. Flow 5 is secured by pseudo-function
pointers. Flow 6 is secured by encapsulation. Flow 4 is
hard to secure. We illustrate some methods in Section
4.2.1. In this regard, we are on par with state-of-the-art
approaches, such as ADSafe [1], Web Sandbox [27] and
Google Caja [20].
• Hidden Access to Native Code (Flow 3). Flow 3 is a hid-
den ﬂow. In common cases, JavaScript running on the vir-
tual JavaScript engine cannot access native JavaScripts
and through them access the native JavaScript Engine.
However, the hidden ﬂow can be triggered by two condi-
tions. First, the third-party JavaScripts running on the
virtual engine modify shared objects that belong to ﬂow 7
(part of ﬂow 2). Second, native JavaScripts use a shared
object that belongs to ﬂow 4. We can break either of
these two conditions to prevent this kind of privilege es-
calation. We have discussed how to break the second
condition in Section 4.2.1. We will discuss about cut-
ting the ﬁrst here.
If a mirrored object is used, ﬂow 7
is blocked automatically. If access control mechanism is
used, a write privilege will have to be carefully given to
Third-Party 
JS
Shared
Object
Trusted    
JS Script
4
7
6
5
Virtual
JS Core
3
2
1
Native JavaScript Engine
Figure 5: Securing Data/Scripts Flows (I)
Virtual CSS 
Parser
Virtual HTML Parser
2'’
2'
Shared
Object
10'’
10'
12'
11'’
12'’
11'
2'
9
2'’
Virtual JS Core
8'
8'’
Native JavaScript Core
Figure 6: Securing Data/Scripts Flows (II)
a third-party program. Usually, a read privilege is suﬃ-
cient.
Securing Data Flows of the Virtual HTML and CSS
Parsers.
The interfaces to the virtual HTML and CSS parsers are
narrow. The HTML parser and the CSS parser take a string
as input and give parsed results as an output. The virtual
HTML and CSS parsers can use each other as well as the
virtual JavaScript parser. They do not have other interfaces.
In Figure 6, we show all the possible ﬂows of the virtual
HTML and CSS parsers. We ignore ﬂows that come into the
virtual JavaScript engine because they have already been
discussed.
Flows 2′ and 2′ ′ are redirected from ﬂow 2 in Figure 5.
Any possible parsing of HTML and CSS is done inside the
sandbox. Flow 8′ and 8′ ′ are outﬂows of HTML and CSS
parsers, discussed in Section 4.1.1. Flow 11′ and 11′ ′ are sim-
ilar to Flow 2 in Figure 5. We use pseudo function pointers
to redirect them to the virtual JavaScript engine (Flows 12′
and 12′ ′). Other ﬂows are inside our system and do not
cause any security issues. They facilitate communication
among components in Virtual Browser.
5.
IMPLEMENTATION
We have implemented a prototype of Virtual Browser.
Our virtualized browser contains a virtual JavaScript parser
and a virtual JavaScript execution engine, a virtual HTML
parser and a virtual CSS parser. We reused and modi-
ﬁed the existing JavaScript implementations of the HTML
parser[32] and the CSS parser[33]. For our JavaScript en-
gine, we modiﬁed Mozilla Narcissus metacircular JavaScript
Engine[28], implemented over JavaScript itself. Moreover,
we implemented a simpliﬁed version of virtual DOM. Only
basic functionality is supported. For example, we support
innerHTML, outerHTML, innerText, document.write, docu-
ment.writeln and so on in Flow 2′ (Figure 6). As we have
already discussed, if some ﬂows are not introduced, it will
result only in reduced functionality but no security prob-
lems. A production level implementation would also include
other components such as an XML parser.
Except the ECMAScript standard, diﬀerent browsers may
implement diﬀerent non-standard features of the JavaScript
language. Our Virtual Browser needs to be compatible with
those non-standard features in order to third-party JavaScripts
that rely on those features. Two methods are used here.
First, we support the standard features and non-standard
features which has been implemented by most browsers. For
example, we support try...catch (e)
if exp2 ...
instead of non-standard try ... catch (e if exp1) ... catch
(e if exp2) .... Second, for important features, we detect
browser vendors and versions when necessary. For exam-
ple, we use ActiveXObject(”Microsoft.XMLHTTP”) in IE
but XMLHttpRequest in other browsers.
if exp1 ...
At the same time, sometimes, Virtual Browser needs to
provide non-supported features than the underlying native
browser. In this case, we need to mimic those non-supported
features. For example, IE does not support the keyword
const; so we use var and give it a tag if it is a constant to
make it appear like a const.
6. EVALUATION
This section is organized as follows.
In Section 6.1, we
evaluate the performance of Virtual Browser prototype, mem-
ory usage, and parsing latency. In Section 6.2, 6.3, and 6.4,
we evaluate Virtual Browser prototype with existing browser
quirks and native JavaScript engine bugs, and completeness
of our prototype.
6.1 Performance Evaluation
We measure the execution speed of Virtual Browser with
mircrobenchmarks and macrobenchmark, and follow with
discussion.
Microbenchmarks.
We compare the execution speed of Virtual Browser and
Microsoft Web Sandbox [27], a state-of-the-art runtime ap-
proach for sandboxing third-party applications. Microsoft
Web Sandbox[27] implemented by Microsoft Live Labs as a
web-level runtime sandbox written in JavaScript. The idea
was derived from BrowserShield[31] project, which rewrites
dynamic web content and inserts runtime security checks.
Web Sandbox has some problems with the virtualization of
local variables7. Therefore, we only use global variables in
our benchmarks for the comparison with Web Sandbox. We
7For example, in the following JavaScript code,
var tempReturn; for (var i = 0;i<10000; i++) tempReturn
= fncTest();
Web Sandbox will rewrite the code as follows.
var tempReturn; for(var i = 0; i < 1e4; i++) h(); tempRe-
turn = j.fncTest()
Web Sandbox does not wrap up i in the above code. To the
best of our knowledge, Web Sandbox tries to avoid wrapping
local variables to improve performance. Local variables are
supposed to be put in their virtualized environment (Vir-
tualizing local variables should be achieved in virtualized
environment but not during virtualized execution). Such re-
laxations are dangerous because it exposes local variables di-
Operations
New Game
Drop a Piece
Mouse Move
Game Over
Time
50ms
18ms
1ms
8ms
Figure 7: Delays of Operations in Connect Four
however note that since Virtual Browser virtualizes all vari-
ables, including both global and local, there are no perfor-
mance impacts if we use local variables instead of global
variables in our approach.
Our experiments are performed on Firefox 3.6. The re-
sults of the execution speed of Web Sandbox and Virtual
Browser on JavaScript microbenchmarks is shown in Ta-
ble 2. In this experiment, we measure each important atomic
operation 10K times and report the cumulative delay. Our
system and Web Sandbox achieve nearly the same perfor-
mance. Microbenchmarks 1-4 are some basic JavaScript op-
erations. Virtual Browser is faster than Web Sandbox for
array operations while for arithmetic and functional opera-
tions, the two perform nearly the same. Microbenchmarks
5-7 are object operations and have comparable performance
on these two. Microbenchmarks 8-9 are string operations.
Virtual browser uses mirrored string object which makes it
slightly slower. Microbenchmarks 10-11 are DOM opera-
tions. Because Virtual Browser enforces a check on each el-
ement passed to or returned by DOM functions, it is slightly
slower. Microbenchmark 12 and 13 evaluates the with and
eval statements which are not supported by Web Sandbox.
Macrobenchmark.
We measure Connect Four, a JavaScript game from the
front page of a popular JavaScript game web site [5], which
is listed as the ﬁrst site by Google search when searching
for JavaScript games. The task of Connect Four is to con-
nect four pieces of the same color. Delays of operations in
Connect Four are shown in Figure 7. Virtual Browser does
not cause any user visible delay. Due to the fact that eval is
used, Connect Four cannot be run on Microsoft Web Sand-
box without modiﬁcation.
Discussion.
While Virtual Browser is as slow as Web Sandbox, it is
much more secure and complete. Although slowness may
limit applicability of this approach, our system remains well
suited for securing third party JavaScripts. On average, a
single JavaScript operation of a parsed AST tree in our sys-
tem costs 0.03-0.05ms. For a common JavaScript program
without mouse movement events (mouse move events are
equivalent to the heavy animation in the later discussion),
a user may trigger an event every 500ms, which means one
can still write 5000 lines of code (1-2 operations per line).
This is long enough to implement a decent program. For a
heavy animation script, an image may need to be updated
every 50 ms, allowing developers to perform 500 operations
to deal with one event, which is long enough for most usages.
For example, the bounce game in Figure 8 is a medium-sized
game (800 lines of codes). From the user’s perspective, she
rectly to the native JavaScript engine and because the server
and client may have diﬀerent interpretation of local variables
due to browser quirks as we have already mentioned in Sec-
tion 2.
Operation
1. Arithmetic Operation
2. Invoke Function
3. Populate Array