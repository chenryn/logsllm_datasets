。
。
1
第22章二进制位数组·369
0
L
。
1
L
。
。
---
## Page 374
370◆第四部分独立功能的实现
22.4.2
量，从而减少检查操作执行的次数。
尽可能地增加每次检查所能处理的二进制位的数
BITCOUNT命令的实现尽可能地高效，程序必须
查肯定不是一个高效程序应有的表现，为了让
很短的时间内完成，但重复执行上亿次这种检
历算法将需要执行检查操作四十亿次！
000）！而对于长度为500MB 的位数组来说，
位数组将需要执行检查操作八亿次（100＊8000
bit 来计算，使用遍历算法检查长度为100MB 的
那么按1 MB = 1 000 000 Byte = 8 000 000
位数组包含的二进制位的数量成正比。
位的值是否为1，所以检查操作执行的次数将与
因为这个算法在每次循环中只能检查一个二进制
位长的位数组进行遍历并计数的整个过程。
1的二进制位时，将计数器的值增一。
是遍历位数组中的每个二进制位，并在遇到值为
22.4.1
BITCOUNT命令的具体实现原理。
容易，需要用到一些精巧的算法。
尽管遍历算法对单个二进制位的检查可以在
例如，假设要检查的位数组的长度为100MB,
遍历算法虽然实现起来简单，但效率非常低，
图22-17展示了程序使用遍历算法，对一个8
接下来的几个小节将对BITCOUNT命令可能使用的几种算法进行介绍，并最终给出
根据这个原理，我们可以创建一个表，表的
实现BITCOUNT命令最简单直接的方法，就
9
口对于一个有限集合来说，集合元素的排列
优化检查操作的一个办法是使用查表法：
BITCOUNT命令要做的工作初看上去并不复杂，但实际上要高效地实现这个命令并不
表示的二进制位排列也是有限的。
而对于一个有限长度的位数组来说，
方式是有限的。
算法
二进制位统计算法（2）：查表
：（）
它能
buf[0]10120010
buf[0]1 01 200 2|0
buf[0]10
buf[0]]
buf[0]101
buf[0]
buf[0]]1
buf[0]]
图 22-17
counter=l
1
counter=1
buf[1］（空字符）
buf[1】（空字符）
buf[1](空字符)
buf[1](空字符）
buf[1］（空字符）
buf[1］（空字符）
buf[1】（空字符）
buf[1］（空字符）
。
counter=2
。
遍历算法的运行过程
110010
1
counter=3
1
counter=3
1
1
[。
counter=3
0010
ol010
counter-
counter=4
---
## Page 375
题实际上并没有那么简单，因为查表法的实际效果会受到内存和缓存两方面因素的限制：
操作执行的次数：
查表法的效率提升了8倍：
制位，和之前介绍的遍历算法相比,
一次查表操作，就可以检查8个二进
少个值为 1 的位。
进行查表，直接知道这个值包含了多
读人8个位，然后根据这8个位的值
这个表格，我们可以一次从位数组中
来说，我们可以创建表格22-1，通过
为1的二进制位。
直接知道这个位数组包含了多少个值
对位数组的每个位进行检查的情况下，
根据输入的位数组进行查表，在无须
键为某种排列的位数组，而表的值则是相应位数组中，值为1的二进制位的数量。
通过使用表 22-1，我们只需执行
举个例子，对于 8位长的位数组
创建了这种表之后，我们就可以
口除了内存大小的问题之外，查表法的效果还会受到CPU缓存的限制：对于固定大小
口因为查表法是典型的空间换时间策略，算法在计算方面节约的时间是通过花费额外
初看起来，只要我们创建一个足够大的表，那么统计工作就可以轻易地完成，但这个问
口如果我们将表键的大小扩展为32位，那么每次查表就可以处理32个二进制位，检
口如果我们将表键的大小扩展为16位，那么每次查表就可以处理16个二进制位，检
如果我们创建一个更大的表的话，那么每次查表所能处理的位就会更多，从而减少查表
口 而对于 500 MB长的位数组来说，使用查表法处理该位数组需要执行五亿次查表操作。
以100 MB = 800 000 000
器只可能接受数百个字节或者数百 KB 的内存消耗。
的表也仅需数百个 KB，但创建键长为 32 位的表却需要十多个 GB。在实际中，服务
计二进制位的问题来说，创建键长为8位的表仅需数百个字节，创建键长为16位
的内存换取而来的，节约的时间越多，花费的内存就越大。对于我们这里讨论的统
需要一亿两千五百万次查表。
查100MB长的二进制位只需要两千五百万次查表，检查 500MB长的二进制位只
两亿五千万次查表。
查100MB长的二进制位只需要五千万次查表，检查500MB长的二进制位只需要
查表法处理长度为100MB的位数组需要执行查表操作一亿次。
bit（八亿位）来计算，使用
表 22-1 可以快速检查 8 位长的位数组包含多少个 
键（位数组）
1111 1111
1111 1110
1111 1101
0000 0111
0000 0110
0000 0101
0000 0100
0000 0011
0100 0000
1000 0000
0000 0000
*
值（值为1的位数量）
第22章
二进制位数组·371
00
L
1
2
2
0
---
## Page 376
372·第四部分独立功能的实现
且不需要使用任何额外的内存。
法，该算法通过一系列位移和位运算操作，可以在常数时间内计算多个字节的汉明重量，并
种特殊指令的普通处理器来说，目前已知效率最好的通用算法为variable-precision SWAR算
开发了多种不同的算法，一些处理器甚至直接带有计算汉明重量的指令，而对于不具备这
被称为“计算汉明重量（HammingWeight)”。
22.4.3
种算法。
检查中统计多个二进制位的算法，接下来要介绍的variable-precisionSWAR算法就是这样一
来说仍然远远不够。
键长为8位或者键长为16位的表，而这两种表带来的效率提升，对于处理非常长的位数组
法，但受限于查表法带来的内存压力，以及缓存不命中可能带来的影响，我们只能考虑创建
为了高效地实现 BITCOUNT命令，我们需要一种不会带来内存压力、并且可以在一次
因为汉明重量经常被用于信息论、编码理论和密码学，所以研究人员针对计算汉明重量
以下是一个处理 32位长度位数组的variable-precision SWAR 算法的实现:
BITCOUNT命令要解决的问题—统计一个位数组中非0二进制位的数量，在数学上
口步骤1计算出的值i的二进制表示可以按每两个二进制位为一组进行分组，各组的
以下是调用 swar（bitarray）的执行步骤：
uint32_t swar(uint32_t i) {
由于以上列举的两个原因，我们可以得出结论，查表法是一种比遍历算法更好的统计办
十进制表示就是该组的汉明重量。
换出操作就会越频繁，最终影响查表法的实际效率。
就越少，查表时出现缓存不命中（cachemiss）的情况就会越高，缓存的换人和
的CPU 缓存来说，创建的表格越大，CPU缓存所能保存的内容相比整个表格的比例
return i;
i =(i*(0x01010101) >> 24);
/1步骤 4
i=（i & OxOFOFOFOF）+（(i >> 4）& OxOFOFOFOF);
//步骤3
1 =(i& 0x33333333)+((i >> 2)& 0x33333333);
//步骤2
(55555955X0  （ >24 语句则通过右移运算，将bitarray 的汉明重量移动到最低八
8
00
0
表22-4在对二进制进行八位分组下，Ox3A70F21B的汉明重量
0010
0011
表 22-3 在对二进制进行四位分组下，0x3A70F21B 的汉明重量
表22-2在对二进制进行两位分组下，0x3A70F21B的汉明重量
10
 11
2
00000100
00111010
01
10
0010
1010
01
10
0
01
0011
1110
?
?
6
L
00000011
01110000
8
0
0000
0000
8
00
分
分
10
11
这个值的每八个二进制位的十进制表
这个值的每四个二进制位的十进制表
2
0100
1111
?
10
11
10100000
11110010
0
8
0001
0010
01
10
第22章
8
0001
0001
01
二进制位数组·373
01
00000100
11011000
01
10
0011
1011
3
0
---
## Page 378
374·第四部分独立功能的实现
22.4.4
位数组的大小超过了缓存的大小，这种优化的效果就会降低并最终消失。
次循环中多次执行 swar，从而按倍数提升计算汉明重量的效率：
swar 函数是单纯的计算操作，所以它无须像查表法那样，使用额外的内存。
要快32 倍，比键长为8位的查表法快4 倍，比键长为 16 位的查表法快2倍，并且因为
也即是十进制值16，这个值就是0x3A70F21B 的汉明重量，如表22-6所示。
另外，因为 swar 函数是一个常数复杂度的操作，所以我们可以按照自己的需要，在一
汉明重量
0x100c0904
当然，在一个循环里执行多个 swar 调用这种优化方式是有极限的：一旦循环中处理的
例如，如果我们在一次循环中调用两次 swar 函数，那么计算汉明重量的效率就从
之后程序计算0x100c0904>〉24，将汉明重量移动到低八位，最终得出值0x10,
以下伪代码展示了BITCOUNT命令的实现原理：
口 如果未处理的二进制位的数量小于128 位，那么程序使用查表算法来计算二进制位
口如果未处理的二进制位的数量大于等于128位，那么程序使用 variable-precision
在执行BITCOUNT命令时，程序会根据未处理的二进制位的数量来决定使用那种算法：
03
口查表算法使用键长为8位的表，表中记录了从00000000到11111111在内的
又例如，如果我们在一次循环中调用四次 swar 函数，那么一次循环就可以计算
的汉明重量。
SWAR算法来计算二进制位的汉明重量。
所有二进制位的汉明重量。
128个二进制位的汉明重量，这比每次循环只调用一次 swar 函数要快四倍！
之前的一次循环计算 32 位提升到了一次循环计算64 位。