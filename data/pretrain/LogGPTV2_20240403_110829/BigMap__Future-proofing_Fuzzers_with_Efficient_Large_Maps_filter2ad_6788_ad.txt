### 1. 数据概览
- **数值数据**:
  - 13.98, 25.64, 101, 140, 122, 174, 345, 1,046, 64,317, 65,781, 76,065, 82,105, 108,231, 131,677
- **优化选项**:
  - licm, gvn, strength-reduce, indvars, loop-vectorize, instcombine

### 2. 指标说明
1. **最大边覆盖**: 在所有模糊测试配置中，达到的最大边覆盖率。
2. **使用64kB映射**。
3. **通过SanitizerCoverage计算** [18]。

### 3. 性能指标
- **测试用例生成吞吐量或执行速率**: 表示单位时间内评估的测试用例数量。在其他条件相同的情况下（如种子选择和变异策略），更高的吞吐量通常意味着更好的覆盖率。
- **唯一崩溃**: AFL内置了去重机制来查找唯一的崩溃。如果一个崩溃覆盖了一个之前未见过的边，或者不覆盖所有之前崩溃共有的边，则认为该崩溃是唯一的。这需要维护局部和全局的崩溃覆盖率位图。
- **边覆盖率**: 尽管崩溃覆盖率是衡量模糊测试性能的有效方法，但程序中的崩溃通常是稀疏的。因此，除了崩溃覆盖率外，我们还报告边覆盖率。直观上，覆盖更多边的模糊测试器更有可能发现更多的漏洞。为了获取边覆盖率，我们收集了模糊测试器的输出语料库，并对其进行了无偏的独立覆盖率构建。

### 4. 实验设置
1. **基准测试**: 我们在实验中使用了19个基准测试。这些基准测试的特性见表II。前13个基准测试来自FuzzBench [10]，它们相对较小且碰撞率较低。其余六个基准测试是从OSSFuzz [5] 收集的LLVM优化传递。这些基准测试共享相同的LLVM-opt二进制文件 [20]，并通过命令行参数选择不同的模糊测试框架。LLVM-opt二进制文件本身具有大量的静态边。总体而言，这些基准测试涵盖了广泛的可发现边数（约1k至131k）和碰撞率。
2. **性能度量**: 使用以下指标来评估我们的方法的性能：
   - 测试用例生成吞吐量或执行速率
   - 唯一崩溃
   - 边覆盖率

### 5. 映射大小变化的影响
我们声称BigMap在不同大小的覆盖率位图下都能高效运行。本节通过比较BigMap与AFL在四种不同映射大小（64kB、256kB、2MB 和 8MB）下的性能来验证这一说法。在这个实验中，我们取三次运行的平均值以减少随机变异步骤引入的变化。

#### 5.1 测试用例生成吞吐量
- 如图6所示，随着映射大小的增加，AFL的吞吐量显著下降。对于8MB映射，AFL的吞吐量从每秒4,400个测试用例降至每秒125个。而BigMap则在所有映射大小下保持了稳定的吞吐量（超过每秒4,100个测试用例）。

#### 5.2 边覆盖率和唯一崩溃
- 图7显示了随映射大小增加的边覆盖率。结果表明，BigMap在24小时的时间预算内达到了所有基准测试的平台期。

### 6. 覆盖率度量组合的评估
BigMap在大映射下的高效性使其能够组合多个覆盖率度量。我们在本节中研究了将laf-intel [11] 和 N-gram [12] 叠加的情况。由于原版AFL不支持laf-intel和N-gram，我们在社区维护的AFL版本AFLPlusPlus [23] 上实现了BigMap。我们使用了OSSFuzz上的所有LLVM模糊测试框架作为基准测试。

### 7. 并行模糊测试的可扩展性评估
每个模糊测试实例使用一个CPU核心。因此，一个具有n个物理核心的系统可以几乎无性能损失地运行n个并行模糊测试实例（假设其他系统资源的竞争最小），从而获得大约n倍的吞吐量。这种线性扩展属性可以通过以下方式实现：

### 8. 结论
- BigMap在处理大映射时表现出色，适用于复杂覆盖率度量和高碰撞率的应用场景。
- 对于大型应用和/或应用广泛覆盖率度量时，碰撞缓解可以提高崩溃覆盖率。

### 9. 图表
- **图6**: 不同映射大小下AFL和BigMap的测试用例生成吞吐量。
- **图7**: 随映射大小增加的边覆盖率。
- **图8**: 不同映射大小下找到的唯一崩溃。

### 10. 表格
- **表III**: 使用laf-Intel和N-gram的代码覆盖率。

以上是对原文的优化，使其更加清晰、连贯和专业。希望对你有帮助！