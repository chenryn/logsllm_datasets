  App	
  Seek	
  User	
  Consent	
  Perform	
  Ac6on	
  Reject	
  Opera6on	
  NO NO Security Sensitive? User Agreed? YES YES OS User Input Prompt Dialog Process	
  Input	
  Auth	
  User?	
  I/O	
  Dispatcher	
  YES NO NO YES Perform	
  YES NO Assistive Technology OS A11y Library App AT Allowed? A11y Allowed? Alt. Input 1054.1 Evaluation Methodology
Given an OS platform, we evaluate the security of the accessibility
features it oﬀers as follows:
1. We studied the availability of the built-in assistive technologies
and the accessibility library on the platform. For built-in assistive
technologies, we focused on the availability of a natural language
user interface because it provides the most powerful control over
the system. For the accessibility library, we focused on whether
an application needs special privileges to use the library; if so,
how such privileges are granted.
2. Using our input validation model (Figure 3), we examined the
input handling process of the analyzed platform. When a check
is missing or ﬂawed, we try to launch attacks exploiting the
missing or ﬂawed check. Speciﬁcally, if the built-in natural
language user interface lacks input validation or if the validation
can be bypassed, we try to escalate our malware’s privilege
through synthetic voice. If the OS-level check is missing and
there is a security mechanism that requires user consent, we try
to escalate our malware’s privilege by spooﬁng the mechanism
with synthetic input. If the OS-level check is not missing, we
assess whether its access control policy is consistent with other
security mechanisms; if not, we evaluate what new capabilities
become available. If the application level check is missing or
ﬂawed, we examine whether accessibility support provides us
new capabilities.
3. Using our output validation model (Figure 4), we examined the
output handling process of the analyzed platform. If the OS-level
check is missing, we try to read the UI structure of other appli-
cations. If the application level check is missing, we examine
whether new capabilities become available. In particular, since
most of displayed information is available through screenshots,
we try to steal a password because it is usually not displayed
in plaintext. We assume obtaining any other (potentially sensi-
tive) information as plaintext via AT is no harder than reading a
password.
4.2 Availability of Accessibility Features
Table 1 summarizes the availability of a natural language user inter-
face and accessibility libraries on the four platforms. Natural lan-
guage user interfaces are available on all platforms except Ubuntu;
accessibility libraries are available on all studied platforms 4.
Platform Natural Language
User Interface
Windows
Ubuntu
iOS
Android
Speech
Recognition*
None
Siri
Touchless
Control*
Accessibility
Libraries
UIAutomation
ATK, AT-SPI
UIAutomation*
AccessibilityService*
Table 1: Accessibility libraries and natural language user interface on
each platform. * indicates the feature requires special setup/privilege.
For natural language user interfaces, both Speech Recognition and
Touchless Control for the Moto X5 require initialization (training)
release versions. For iOS, we tested iOS 6.1.4, the latest iOS 6 at
the time the research was performed.
4 On iOS, there is no accessibility library, but the UIAutomation
framework provides most capabilities that we require.
5 For the natural language user interface on Android, we try to
analyze Touchless Control which is only available on the Moto X,
due to the lack of a privileged natural language user interface in
Android by default.
Figure 4: Required security checks for an AT as a new output subsys-
tem. Application is required to decide which input can transit through
the accessibility library, then the AT receives the output to deliver it
to the user. Grayed boxes indicate the checks required by OS and the
application.
AT can control. For example, interaction requests from untrusted AT
to security sensitive processes such as system services and system
settings should not be forwarded. Otherwise, privilege escalation
would be feasible (A2). In addition, the access control policy should
be consistent with other access control mechanisms to prevent a
malicious AT from obtaining new capabilities (A1).
Third, the OS should provide the ﬂexibility to allow an appli-
cation to specify a ﬁne-grained security policy on how to handle
interaction requests from an AT. More speciﬁcally, the OS should
1) allow the application to distinguish input from real hardware and
input from AT; and 2) allow the application to set its own callback
functions to handle input events from AT. More importantly, when
no customization is provided, the default setting should align with
the platform’s default security policy.
These three checks are complementary to each other for the fol-
lowing reasons. First, for AT-like natural language user interfaces
for motor disabled people, it has to be able to control all applications
and the underlying system; the only viable check is within the AT
itself. Second, as not all ATs are trustworthy, the OS-level check is
necessary to prevent malicious AT from compromising the system.
Third, OS-level access controls are not aware of the context of each
non-system application, so the application level check provides the
last line of defense for an application to protect itself from malicious
ATs (A1).
Similarly, to securely handle alternative output and prevent infor-
mation leakage (A3), two checks (gray boxes in Figure 4) should
be performed. The application level check allows the application to
specify what information is sensitive so it will not be available to AT.
Again, we must emphasize that when no customization is provided,
the default setting should align with the platform’s security policy.
The OS-level check prevents untrusted ATs from acquiring sensitive
information speciﬁc to the system.
4 Security Evaluation of A11y
In this section, we ﬁrst describe our evaluation methodology, and
then present the results of the security evaluation on major platforms:
Microsoft Windows, Ubuntu Linux, iOS, and Android. The speciﬁc
versions of the evaluated systems are: Windows 8.1, Ubuntu 13.10,
iOS 6 and Android 4.4 on the Moto X 3.
3For Windows, Ubuntu, and Android, we tested the latest release
version as of November 2013. Attacks still work for the current
Process	
  Output	
  Output	
  YES Assistive Technology OS App On Screen? On A11y? NO YES Screen Output Alt. Output A11y Library YES NO AT Allowed? 106before ﬁrst use. Siri can be enabled without any setup. Although
Speech Recognition on Windows requires initialization, this step
can be bypassed by modifying the values of a registry sub-key
at HKEY_CURRENT_USER\Software\Microsoft\Speech. Since
this key is under HKEY_CURRENT_USER, it is writable by any unpriv-
ileged process.
For accessibility libraries, both desktop environments (Windows
and Ubuntu Linux) have no privilege requirements for using the
libraries, thus they are available to any application.
On iOS, the UIAutomation framework, though not a full-ﬂedged
accessibility library, provides the functionality to send synthesized
touch and button events. Since this framework is part of the private
API set, its usage is forbidden by apps in the Apple App Store.
However, as demonstrated in [33], the enforcement can be bypassed.
Unlike other platforms, Android’s accessibility library (Acces-
sibilityService) is available only after the following requirements
are met: ﬁrst, the app must declare use of the permission BIND_
ACCESSIBILITY_SERVICE. Second, the user must explicitly enable
the app as an accessibility service. When changing accessibility
settings, a user is prompted with a dialog that displays what kind
of capabilities will be granted to the AccessibilityService, which
is very similar to the app permission system. Nonetheless, users
are prone to enable permissions when apps provide step-by-step
instructions. In particular, we ﬁnd that there are more than 50 apps
on the Google Play store that declare use of permissions for Acces-
sibilityService, and two of them [14, 29] have been downloaded by
more than ten million users combined. Both are rated 4.3 out of 5
stars.
4.3 Vulnerabilities in Input Validation
Platform Assistive Tech.
Windows
Ubuntu
iOS 6
Android
Check
None
N/A
None
Authentication
OS Level
Check
UIPI*
None
None
Permission*
Application
Level Check
None
None
None
None
Table 2: Status of input validation on each platform. * indicates the
check enforces a security policy that is diﬀerent from other security
mechanisms.
Table 2 summarizes the examination results of each platform
when checked against our input reference model (Figure 3). There
are two common problems across all analyzed platforms.
Missing or ﬂawed input validation within AT. Natural language
user interfaces usually have more privileges than normal applica-
tions; most of them lack authentication for voice input. More-
over, some accept self-played input (sending audio from the built-in
speaker to microphone), making it possible to inject audio input
through text-to-speech (TTS). Although Touchless Control on the
Moto X tries to authenticate its input, the authentication can be
easily bypassed with a replay attack. As a result, an attacker can
obtain the privileges of the natural language user interface (attack
#1, #5, #9).
Control of other applications. At the application level, no plat-
form provides a precise way to check whether the input event is
from the hardware or from the accessibility library. Moreover, at the
OS level, although Windows and Android have access controls for
AT, their protections are not complete. This allows a malicious AT
to control most applications the same way as a human user would.
Speciﬁcally, a malicious AT can send input events to make other ap-
plications perform security sensitive actions (attack #4, #6, #7, #10)
and spoof security mechanisms that require user consent (attack #2,
#3, #8).
Implementation of attacks. We tested all Windows-based attacks
by implementing proof-of-concept malware. For controlling apps
on Ubuntu Linux, iOS 6, and Android, we checked the capability
of sending synthetic input to other applications by writing sample
code for sending basic user interactions such as clicking a button,
and writing content into a textbox. For iOS, we also wrote code to
test for special UI windows such as passcode lock, password dialog,
and remote view. For Touchless Control, we implemented sample
malware that records sound in the background; we then sliced the
authentication phrase from it manually, and replayed the slice within
the malware. For Siri, we manually performed the same attack.
4.3.1 Windows
The OS-level check applied to the accessibility library on Windows
is called User Interface Privilege Isolation (UIPI) [23]. UIPI is a
mandatory access control (or mandatory integrity control (MIC) in
Microsoft’s terminology) that sets an integrity level (IL) for every
process and ﬁle, and enforces a relaxed Biba model [5, 22]: no
write/send to a higher integrity level. The integrity levels (IL) are
divided in 5 categories: Untrusted, Low, Medium, High, and System.
Regular applications run at Medium IL, while processes executed
by an active administrator runs at High IL. As an MIC, the IL
of a process is inherited by all of its child processes, and takes
the minimum privilege when two or more ILs are applied on the
process.
UIPI prevents attackers from sending input to higher IL processes.
For example, malware cannot spoof UAC through a synthesized
click because normal programs including malware run at either
Medium IL (when launched by the user) or Low IL (when launched
by browser, i.e., drive-by attacks), while the UAC window runs at
System IL. Furthermore, malware cannot take control of applications
that are executed by the administrator, which has a higher IL (High
IL).
Unfortunately, the protection provided by UIPI is not complete:
since most applications are running at the same Medium IL as
malware, UIPI allows malware to control most other applications
via AT.
Furthermore, the lack of security checks at the assistive technol-
ogy and application levels results in more vulnerabilities: missing
input validation in the built-in natural language user interface allows
privilege escalation attacks through Speech Recognition (attack #1);
missing application level checks enables escalation of privilege (at-
tack #2), and theft of user passwords (attack #3).
Attack #1: privilege escalation through Speech Recognition. Con-
trol of Speech Recognition is security sensitive for several reasons.
First, although there is a setup phase, it can be bypassed as men-
tioned in Section §4.2. After setup, any process can start Speech
Recognition. Second, Speech Recognition always runs with ad-
ministrative privilege (High IL) regardless of which process runs
it. This allows it to control almost all other applications on the sys-
tem, including applications running with administrative privileges.
Because of these “features” of Speech Recognition and the prob-
lems mentioned previously (i.e., no input validation, and accepting
self-played voice), malware running at Medium or even Low IL can
escalate itself to administrative privilege through synthetic voice.
Figure 5 shows the workﬂow of the privilege escalation attack
from a Medium IL malware. The ﬁrst step is to launch Speech
Recognition through CreateProcess() with the argument sapisvr
.exe -SpeechUX. Second, the malware launches the msconfig.exe
107Figure 5: Workﬂow of privilege escalation attack with Windows Speech
Recognition.
Figure 6: Dialog that pops-up when Explorer.exe tries to copy a ﬁle
to a system directory. The dialog runs at the same Medium IL as
Explorer.exe. Thus, any application with Medium IL can send a syn-
thetic click to the “Continue” button, and proceed with writing the ﬁle.
application through CreateProcess(). Since msconfig.exe is
an application for an administrator to manage the system conﬁgura-
tion, it automatically runs at High IL. While malware cannot send
input events to this process (prevented by UIPI), Speech Recog-
nition can. After launching msconfig.exe, the malware can use
voice commands to launch a command shell by choosing an item
under the tools tab of msconfig.exe. This is accomplished by
playing a piece of synthetic speech “Tools, Page Down, Command
Prompt, Launch!”. Once the command shell that inherits the High
IL from msconfig.exe is launched, the malware then says “cd” to
its directory, says its own executable name and “Press Enter” to be
executed with administrative privileges.
Attack #2: privilege escalation with Explorer.exe. Explorer
.exe is a special process in Windows that has higher privilege than
its running IL. Unlike other Medium IL processes, Explorer.exe
has the capability of writing to High IL objects such as the System32
directory. Although this capability is protected by a UAC-like dia-
log (Figure 6), i.e., Explorer.exe asks for the user conﬁrmation
before writing to a system directory of Windows, the dialog belongs
to Explorer.exe itself. Since this action requires user consent, the
application should check whether the input comes from the user
or AT. However, there is no such check. As a result, malware can
overwrite ﬁles in system directories by clicking the conﬁrmation