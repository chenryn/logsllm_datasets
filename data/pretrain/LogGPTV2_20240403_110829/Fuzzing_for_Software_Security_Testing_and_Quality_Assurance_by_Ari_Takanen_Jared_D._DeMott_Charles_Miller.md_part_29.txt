this is a stack-based vulnerability and Guard Malloc only modifies the way heap
buffers are allocated,
charlie-millers-computer:~ cmiller$
DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib ./test 0
AAAAAAAAAAAAAAAAAAAA
GuardMalloc: Allocations will be placed on 16 byte boundaries.
GuardMalloc: - Some buffer overruns may not be noticed.
GuardMalloc: - Applications using vector instructions (e.g., SSE
or Altivec) should work.
GuardMalloc: GuardMalloc version 18
Notice that the program exited without a bus error, failing to detect the stack
overflow. Likewise, it did not help find the vulnerability associated with 2. It did
succeed in finding the bug from test case number 7. It did not find the one for test
case 9, but did for case 10 and gave the following error:
GuardMalloc[test-1140]: Attempting excessively large memory
allocation: 914748368 bytes
Overall, Guard Malloc worked as advertised. It located vulnerabilities associ-
ated with heap allocations such as heap overflows and wild memory writes on the
6760 Book.indb 190 12/22/17 10:50 AM
6.6 Test Program 191
heap. It also logged when excessive memory allocations occurred. It did not help
with stack-based or static-variable-based vulnerabilities.
6.6.4 Valgrind
Performing the same experiment as above with Valgrind gives pretty much the same
results. It helps find the heap-based bugs and not the others. It also warns of an exces-
sive memory allocation. However, notice the much more detailed reporting provided
by Valgrind, which points out the line number and exactly what has occurred. This
kind of information can help reduce the time required for postfuzzing analysis. Here
is what the output looks like when Valgrind fails to find a vulnerability:
[cmiller@Linux ~]$ valgrind ./test 0 AAAAAAAAAAAAAAAAAAAA
...
==6107== ERROR SUMMARY: 0 errors from 0 contexts (suppressed:
12 from
1)
...
Here is some detailed information about the two bugs it does find:
[cmiller@Linux ~]$ valgrind ./test 1 AAAAAAAAAAAAAAAAAAA
...
==6110== Invalid write of size 1
==6110== at 0x40069D8: strcpy (mc_replace_strmem.c:272)
==6110== by 0x8048576: main (test.c:30)
==6110== Address 0x401F038 is 0 bytes after a block of size 16
alloc’d
==6110== at 0x40053D0: malloc (vg_replace_malloc.c:149)
==6110== by 0x80484D3: main (test.c:12)
...
==6110== ERROR SUMMARY: 4 errors from 2 contexts (suppressed:
12 from
1)
and
[cmiller@Linux ~]$ valgrind ./test 3 18
...
==6154== Invalid write of size 1
==6154== at 0x80485AF: main (test.c:38)
==6154== Address 0x401F03A is 2 bytes after a block of size 16
alloc’d
==6154== at 0x40053D0: malloc (vg_replace_malloc.c:149)
==6154== by 0x80484D3: main (test.c:12)
Looking at the first of these outputs shows that it correctly identifies the buf-
fer overflow due to a strcpy on line 30 of test.c, and furthermore that it is trying to
6760 Book.indb 191 12/22/17 10:50 AM
192 Target Monitoring
write past a buffer of size 16 that was allocated in line 12 of test.c. Likewise, the
other bug is correctly identified as a write of 1 byte that takes place on line 38 of
test.c and is 2 bytes after an allocated buffer of size 16.
6.6.5 Insure++
Insure++ is a commercial product that adds memory checks at compile time. Below
is an excerpt from the instrumented source code for the test program that shows
the types of checks added to the source code.
...
auto void *_Insure_1i;
_insure_decl_lwptr(_Insure_fid_1, 9L, 0, 9, (void *)
(&_Insure_1i),
65536, 2);
_Insure_0i = (16);
_Insure_1i = malloc(_Insure_0i);
_insure_assign_ptra_after_call((void **)(&_Insure_1i), 9,
&_Insure_spmark);
_insure_ptra_check(9, (void **)(&_Insure_1i), (void
*)_Insure_1i);
if (_Insure_1i) {
_insure_alloca(10, _insure_get_heap_handle(0), (void **)
(&_Insure_1i),
_Insure_0i, 0, 4096, (char *)0, 0);
}
_insure_assign_ptraa(9, (void **)(&heap_buffer1), (void
**)(&_Insure_1i),
(void *)((char *)_Insure_1i));
heap_buffer1 = (char *)_Insure_1i;
...
_Insure_3_es = atoi(argv[2]);
_insure_after_call(&_Insure_spmark);
_insure_index2_checka(21, (void **)(&heap_buffer1), (void
*)heap_buffer1,
(int)_Insure_3_es, sizeof(char), 0L);
(heap_buffer1[_Insure_3_es]) = (0);
...
This excerpt consists of the lines relevant to case 3. The first set of lines is the
allocation of heap_buffer1. There are various calls to internal Insure++ functions
such as _insure_assign_ptra_after_call() and _insure_alloca(), which set
up the allocation. Later, when an index into the buffer is used, checks are made to
ensure this is safe, using the _insure_index2_checka() function.
Insure++ has the most information available, and it is not surprising that it does
the best job of monitoring. In fact, it finds all the memory corruption bugs (Figure
6.8), which is significantly better than the other tools we’ve discussed, all of which
missed two. It did not complain about the denial of service issue.
6760 Book.indb 192 12/22/17 10:50 AM
6.6 Test Program 193
Figure 6.8 Insure++ reports on all issues it has helped detect.
Insure++ also quickly points out the exact cause and location of problems,
including line numbers. In fact, Figure 6.9 shows that not only does it find where
the wild pointer write occurs, but also identifies the first spot where a problem
occurs because of it.
This type of detailed information can save a tremendous amount of time when
analyzing the results of fuzzing.
6.6.6 AddressSanitizer
To enable AddressSanitizer we have to compile our test program with correct com-
piler flags:
[attekett@Ubuntu ~]$ gcc –version
gcc (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609
Copyright (C) 2015 Free Software Foundation, Inc.
.
[attekett@Ubuntu ~]$ gcc -fsanitize=address ./test.c -o test-asan
[attekett@Ubuntu ~]$ ./test-asan 0 AAAAAAAAAAAAAAAAAAAA
=================================================================
==10666==ERROR: AddressSanitizer: stack-buffer-overflow on
address 0x7ffc865685a0 at pc 0x7f9c6e974709 bp 0x7ffc86568530
sp 0x7ffc86567cd8
.
6760 Book.indb 193 12/22/17 10:50 AM
194 Target Monitoring
Figure 6.9 Insure++ reveals detailed information about the location of two bugs.
AddressSanitizer correctly detects our stack and heap based bugs. Overflows in
our global variables static_buffer1 and static_buffer2 are not detected. In general,
AddressSanitizer can detect overflow of the global variables, but in our example we
need add initialization of the global variables in to our example code:
char static_buffer1[16]={0};
char static_buffer2[16]={0};
AddressSanitizer does not report anything unless it detects an issue during the
execution. Here is how AddressSanitizer reports the stack buffer overflow from
our first test:
=================================================================
==3473==ERROR: AddressSanitizer: stack-buffer-overflow on address
0x7fffc2229b20 at pc 0x7f76c9aa1709 bp 0x7fffc2229ab0
sp 0x7fffc2229258
WRITE of size 21 at 0x7fffc2229b20 thread T0
#0 0x7f76c9aa1708 (/usr/lib/x86_64-linux-gnu/libasan.
so.2+0x62708)
#1 0x400d41 in main test.c:25
#2 0x7f76c969682f in __libc_start_main (/lib/x86_64-linux-gnu/
libc.so.6+0x2082f)
#3 0x400af8 in _start (/home/attekett/test-asan+0x400af8)
6760 Book.indb 194 12/22/17 10:50 AM
6.6 Test Program 195
Address 0x7fffc2229b20 is located in stack of thread T0 at offset
48 in frame
#0 0x400bd5 in main test.c:8
This frame has 1 object(s):
[32, 48) ‘stack_buffer2’ 0x10007843d360: f1 f1 00 00[f4]f4 f3 f3 f3 f3 00 00 00 00 00 00
0x10007843d370: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10007843d380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10007843d390: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10007843d3a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10007843d3b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8
application bytes):
Addressable: 00
Partially addressable: 01 02 03 04 05 06 07
Heap left redzone: fa
Heap right redzone: fb
Freed heap region: fd
Stack left redzone: f1
Stack mid redzone: f2
Stack right redzone: f3
Stack partial redzone: f4
Stack after return: f5
Stack use after scope: f8
Global redzone: f9
Global init order: f6
Poisoned by user: f7
Container overflow: fc
Array cookie: ac
Intra object redzone: bb
ASan internal: fe
==3473==ABORTING
AddressSanitizer report tells us that our program is trying to do a write of 21
bytes, from function main in source file test.c line 25, which overflows variable
stack_buffer2. The AddressSanitizer output also includes visual presentation of
the shadow bytes around the address where the invalid access occurred. Overall
6760 Book.indb 195 12/22/17 10:50 AM
196 Target Monitoring
the information AddressSanitizer report provides is very similar to what Valgrind
report includes.
6.7 Case Study: pCrE
The last example illustrated the strengths and weaknesses of some monitoring tools
in a test environment. Now, let us try them on an example that is a little more
realistic. The Perl Compatible Regular Expression library is used by many open-
source applications including Firefox, Safari, Apache, and Postfix. This library has
had various vulnerabilities associated with it throughout its lifetime. The current
version as of the writing of this book is 7.4. Let us look back in time at version
6.2, which can still be found on the internet. It turns out that a modified version
of this library was shipped with Apple’s iPhone in April 2007, and the bugs we’re
considering here allowed for remote exploitation of the device. This library can be
built with the commands:
./configure
./make
gcc -g -I. pcredemo.c -o pcredemo .libs/libpcre.a
This produces a small sample program called pcredemo, which takes two arguments.
The first argument is a regular expression and the second is a string to examine
with the supplied regular expression. For example,
cmiller$ ./pcredemo ‘ab.d’ ABCDabcdABCD
Match succeeded at offset 4
0: abcd
No named substrings
There are multiple vulnerabilities in this particular version of PCRE. Below are
two inputs that cause a heap overflow condition.
cmiller$ ./pcredemo ‘[[**]]’ a
PCRE compilation failed at offset 6: internal error:
code overflow
cmiller$ ./pcredemo
‘(?P)(?P>a){1}’ a
PCRE compilation failed at offset 32: internal error:
code overflow
As can be seen from the output, the PCRE library correctly identifies that an
overflow has occurred, but only after the fact. However, since the program does
not crash, it is likely that a fuzz tester who blindly attached a debugger and ignored
the output might miss this useful message. In fairness, this program outputs many
different error messages, especially when fuzzing, so it would be easy to miss this
particular message in the noise.
6760 Book.indb 196 12/22/17 10:50 AM
6.7 Case Study: PCRE 197
In fact, one of the authors of this book did fuzz this library and the program
never crashed. It was only through luckily observing the output of the application
that something more was noticed. After this was noticed, the author reran the inputs
under Insure++ and found the vulnerability.
Now that we have a real program with a couple of real bugs, let’s see how the
advanced memory corruption monitors do in detecting these two buffer overflows.
6.7.1 Guard Malloc
Since these two vulnerabilities are heap overflows, there is a good chance Guard
Malloc will find the bugs. In fact, it does find both of them,
cmiller$
DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib ./pcredemo
‘[[**]]’ a
GuardMalloc: Allocations will be placed on 16 byte boundaries.
GuardMalloc: - Some buffer overruns may not be noticed.
GuardMalloc: - Applications using vector instructions (e.g., SSE
or Altivec) should work.
GuardMalloc: GuardMalloc version 18
Bus error
cmiller$
DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib ./pcredemo
‘(?P)(?P>a){1}’ a
GuardMalloc: Allocations will be placed on 16 byte boundaries.
GuardMalloc: - Some buffer overruns may not be noticed.
GuardMalloc: - Applications using vector instructions (e.g., SSE
or Altivec) should work.
GuardMalloc: GuardMalloc version 18
Bus error
Running the first example under the gdb debugger reveals the exact line where the
overflow occurs:
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_PROTECTION_FAILURE at address: 0xb000d000
0x00004f7b in compile_regex (options=, oldims=0, brackets=0xbffff4a4,
codeptr=0xbffff49c, ptrptr=0xbffff498, errorcodeptr=0xbffff4a0,
lookbehind=0, skipbytes=0, firstbyteptr=0xbffff4ac,
reqbyteptr=0xbffff4a8, bcptr=0x26, cd=0xbffff454) at
pcre_compile.c:3557
3557 PUT(code, 1, code - start_bracket);
Likewise for the second vulnerability,
Program received signal EXC_BAD_ACCESS, Could not access memory.
Reason: KERN_PROTECTION_FAILURE at address: 0xb000d000
6760 Book.indb 197 12/22/17 10:50 AM