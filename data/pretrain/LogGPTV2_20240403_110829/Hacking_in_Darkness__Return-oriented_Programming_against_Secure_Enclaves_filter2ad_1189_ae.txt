chose, instead of the key that is generated by isv_enclave.
On generating the REPORT, we prepare a REPORTDATA at
the untrusted space using the chosen ECDH public key,
and then chain the ROP gadgets to copy the REPORTDATA
to the enclave space. Note that the EREPORT requires
its parameters to be located in the enclave space. After
copying the REPORTDATA, we call the EREPORT leaf func-
tion with copied data to generate the REPORT inside the
isv_enclave. After this, we copy the generated REPORT
from the isv_enclave to isv_app and delivers the REPORT
USENIX Association
26th USENIX Security Symposium    533
Host operating systemISV_APPSeISV_ENCLAVE (trusted)Generate_ECDH_key_pairs(&pub, &priv)Copy_out_public_key(&pub)Compute_DH_key()Generate_REPORT_DATA(&pub)Run_EREPORT()Copy_out_REPORT()Secure channel established!Quoting Enclave (QE)Service providerREPORT①②③REPORTQuote④②①Launch ISV_ENCLAVESend_msg_1(pub)Proc_msg_2(msg2)Send_msg_3(quote)Generate key pairs(&pub_s, &priv_s)Send_response(pub_s, signature)Verify_quote(quote)Compute_DH_key()Secure channelestablished!⑤⑤④③Figure 7: The Man-in-the-middle (MitM) attack of the SGX malware for hijacking the remote attestation in SGX.
to the QE to sign it.
As a result, at the untrusted space, the attacker can
retrieve the REPORT that contains the ECDH parameter of
his/her own choice, and the REPORT is signed correctly.
Hijacking remote attestation. The full steps of hijack-
ing the remote attestation of an enclave are as follows (see
Figure 7).
First, (1) instead of isv_enclave, the SGX malware
generates an ECDH public/private key pair and own the
private key. (2) the SGX malware sends the generated
public key to the remote server.
Then, (3) on receiving the quote request from the server,
the SGX malware calculates the shared secret correspond-
ing to the parameters received by the remote server. Also,
the SGX malware prepares TARGETINFO and REPORTDATA
at isv_app. The TARGETINFO contains the information of
the QE that enables the QE to cryptographically verify
and sign the generated REPORT. The REPORTDATA is gener-
ated with the chosen public key as a key parameter to run
EREPORT in the isv_enclave. After that, SGX malware
launches the Dark-ROP attack (3-1, 3-2 and 3-3) to copy
prepared parameters (TARGETINFO and REPORTDATA) from
the untrusted app to the enclave and generate REPORT with
the ECDH public key that the SGX malware generated at
the first step. Moreover (3-4), the generated report will be
copied out to the SGX malware from the isv_enclave,
and the SGX malware sends the generated REPORT to the
Quoting Enclave to sign this with the correct key. Because
the REPORT is generated by the enclave correctly, the QE
will sign this and return it to the attacker.
Finally, (4) the SGX malware sends this signed REPORT
to the remote server. Now, the remote server shares the
secret; however, it is not shared with the isv_enclave,
but with the SGX malware so that the secure communica-
tion channel is hijacked by the SGX malware. Note that
the remote server cannot detect the hijacking because all
parameters and the signature are correct and verified.
6
Implementation
We implemented both the proof-of-concept attack and
the SGX malware in the real SGX hardware. For the
hardware setup, we use the Intel Core i7-6700 Skylake
processor, which supports the first and only available
specification of SGX, SGXv1. For the software, we run
the attack on Ubuntu 14.04 LTS, running Linux kernel
4.4.0. Additionally, we use the standard Intel SGX SDK
and compiler (gcc-5) to compile the code for the enclave
for both attacks.
To launch the Dark-ROP attack on the real SGX hard-
ware, we use the RemoteAttestation example binary in
the Intel SGX SDK, which is a minimal program that
only runs the remote attestation protocol, with slight mod-
ification, to inject an entry point that has a buffer overflow
vulnerability, as mentioned in Figure 2.
Because the example is a very minimal one, we be-
lieve that if the Dark-ROP attack is successful against the
RemoteAttestation example, then any other enclave pro-
grams that utilizes the remote attestation are exploitable
by Dark-ROP if the program has memory corruption
bugs.
Finding gadgets from standard SGX libraries. First,
we search for gadgets from the example binary. To show
the generality of finding gadgets, we find gadgets from the
standard SGX libraries that are essential to run enclave
534    26th USENIX Security Symposium
USENIX Association
Launch ISV_ENCLAVEGenerate_ECDH_key_pairs(&pub, &priv)Send_msg_1(pub)Proc_msg_2(msg2) {Compute_DH_key( )Generate_REPORTDATA( )ROP_copy_parameter( )ROP_EREPORT( )Get_Quote( )}Send_msg_3(quote)Host operating systemSGX malware(Man-in-the-Middle)SeISV_ENCLAVE (trusted)Generate key pairs(&pub_s, &priv_s)Send_response(pub_s, signature)Verify_quote(quote)Compute_DH_key( )The secret is sharedbetweenthe remote server and the attackerQuoting Enclave (QE)Service providerRAX GadgetRBX GadgetRCX GadgetENCLU GadgetRSI GadgetRDI GadgetRCX GadgetmemcpyGadgetRDX GadgetTARGETINFOREPORTDATAREPORT①②③③-①REPORTQuotememcpyGadget④③-②③-③③-④③-⑤Table 1: Information for the length of ROP gadget chains for
launching functions that breach the security of SGX.
memcpy
80
Length of gadget chains (byte)
EGETKEY
LEAF FUNCTION
88
248
EREPORT
248
programs such as the library for controlling the enclave
(libsgx_trts.a), the library that handles remote attestation
protocol (libsgx_tkey_exchange.a), and the standard C
library for SGX (libsgx_tstdc.a) because these libraries
will be linked regardless of the program logic.
From the example binary, we found that four gad-
gets are enough to fulfill the gadget requirement de-
scribed in §3 to launch the Dark-ROP attack against the
RemoteAttestation example. Table 2 lists these four
gadgets found in the example binary.
Constructing ROP chains for Dark-ROP. By chain-
ing these gadgets, we construct ROP chains for calling
the memcpy() function, and the EREPORT and EGETKEY leaf
functions. To call the memcpy() function, we chained
the four gadgets as follows. To set the registers for
calling the memcpy function, we chained three gad-
gets, pop rsi; pop r15; ret and pop rdi; ret to set
the destination and source address of memory copy, and
pop rdx; pop rcx; pop rbx; ret to set the length of
the data to be copied. As a result, we constructed an
ROP chain for calling the memcpy() function. The total
size of the gadget chain was 80 bytes, as shown in Ta-
ble 1. To call the EGETKEY leaf function, we should call the
memcpy() function to copy the KEYREQUEST structure first,
set the register arguments for EGETKEY, and then call the
memcpy() function again to move the generated key out
to the untrusted area. By chaining two memcpy() gadgets
and the leaf function gadgets, calling EGETKEY requires
248 bytes for gadget chaining. Similar to above, calling
the EREPORT also requires 248 bytes for gadget chaining.
Because the size of the chain is small enough (248 bytes
as max) to fit into the overflowed stack (or heap area), we
believe that the attack will work well in most cases.
7 Mitigation
We expect the adoption of traditional defense mechanisms
in SGX to possibly mitigate Dark-ROP. However, since
there are discrepancies between the normal execution en-
vironment and SGX, the specific features of SGX, which
facilitate the attack in some aspects, need to be considered
in the implementation of those defenses.
Gadget elimination. As shown in [28], the useful gad-
get that can be exploited to launch Dark-ROP can be
eliminated before the enclave is deployed. For instance,
we can transform the enclave code in a way to ensure
that it does not contain any non-intended ret instructions.
Moreover, we need to consider how to manage the non-
removable SGX specific gadgets that contain the ENCLU
instruction. For the transition between the host program
and the enclave, at least one ENCLU instruction (for
EEXIT leaf function) is required for the enclave, the re-
quirement that makes it hard to completely remove the
gadgets. We expect that implanting the register validation
logic right after the ENCLU instruction could be a possi-
ble solution. Specifically, we can ensure that the ENCLU
instruction in a certain location is tightly coupled with
one of the pre-defined leaf functions. Besides, the way to
remove the gadget that performs as a memcpy function,
which is generally required to operate (un)marshalling
the parameters between the host program and the enclave,
should also be considered.
Control flow integrity. Deploying the CFI in the en-
clave also needs to consider the SGX-specific features.
For instance, as shown in Figure 3, an attacker can arbi-
trarily incur the AEX to freeze the status (context) in the
enclave. Then, he can create another thread to leak or
manipulate the context (e.g., the saved general-purpose
registers in the stack) of the trapped thread. Therefore,
if the CFI implementation uses one of the general regis-
ters to point to the reference table that defines allowed
target blocks, it can be easily bypassed by the attacker’s
manipulating the context saved in the stack of the trapped
thread.
Fine-grained ASLR. Research projects that adopt
fine-grained ASLR on enclave programs such as SGX-
Shield [31] would possibly mitigate Dark-ROP. However,
it should also accompany with enclave developer’s care-
ful configuration since Dark-ROP can still be effective by
exploiting the number of state save area (NSSA) field that
defines the number of allowed re-entrances to the enclave
without reconstructing it. More specifically, SGX allows
multiple synchronous entrances (EENTER) depending
on the value configured in the NSSA field, even after the
AEX happens (if ERESUME is executed instead of EEN-
TER, the enclave crashes and thus the attacker needs to
reconstruct the enclave). Therefore, if the value of the
NSSA field is large enough, the attacker might be able to
continuously reenter the enclave without reconstructing
it, which enables the preservation of the previous mem-
ory layout. According to SGX specifications [20, 21],
the value of NSSA can be up to a 4-byte integer, and we
expect this to be enough to reliably locate all necessary
gadgets.
8 Related work
In this section, we describe SGX-related prior works in
the following respects: (1) application of SGX, (2) attacks
USENIX Association
26th USENIX Security Symposium    535
against SGX, (3) enclave confidentiality protection, and
(4) comparison between BROP and Dark-ROP.
SGX application.
Intel SGX has been utilized to se-
cure various applications. Ryoan [17] ported Google
NaCl in and SGX enclave to create a distributed sand-
box that prevents sensitive data leakage. SCONE [3]
leverages SGX to host a Docker container in the enclave,
which specifically concerns the security enhancement and
low overhead. Town Crier [39] isolates the crypto func-
tions for the smart contract in the enclave. To prevent
an Iago [10] attack, Haven [6] isolates the unmodified
Windows application, library OS, and shielded module
together in the enclave. Network services and protocols
such as software-defined inter-domain routing are shown
to possibly coordinate with SGX in Kim et al [25].
Attacks on SGX. Several research projects have ex-
plored potential attack surfaces on SGX. The controlled
side-channel attack [33, 38] shows that the confidentiality
of the enclave can be broken by deliberately introducing
page faults. Asyncshock [37] presents how a synchro-
nization bug inside the multi-threaded enclave can be
exploited. Unfortunately, this work does not target the
attacker who has full control over the enclave program.
Instead, the work describes how the proposed attack can
subvert the confidentiality and integrity of SGX.
Enclave confidentiality protection. As described in
[18, 24, 30], an enclave binary can be distributed as a
cipher text to preserve the confidentiality of the code and
data deployed in the enclave. VC3 [30] shows a concrete
implementation example that partitions the enclave code
base as public (plaintext) and private (encrypted) and
enables the public code to decrypt the private code. CON-
FIDENTIAL [34] provides a methodology that prevents
the secret leakage from the enclave by enforcing the nar-
row interface between the user program and small library,
and defining the formal model to verify the information
release confinement. In addition, Moat [34, 35] tracks
information flows by using static analysis to preserve the
enclave confidentiality. Our work shows that, even with
the protection of enclave confidentiality, Dark-ROP can
be successfully deployed by exploiting a certain SGX
hardware design and its functionality.
Revisiting BROP for Dark-ROP. Blind ROP [7] is an
attack technique that can locate and verify the required
gadgets in the restrictive environment where neither the
target binaries nor the source code is known to the attacker.
To this end, it depends on two primary gadgets, which
are called the trap gadget and the stop gadget, both of
which incur the program to be crashed or stopped when
they are consumed (popped) as part of the input payload
that is crafted by an attacker to specify the potential (and
currently probed) gadget.
On the contrary, the Dark-ROP attack takes an orthog-
onal approach, which exploits the three oracles that allow
the attacker to obtain hints of the gadgets by the fea-
tures of SGX (i.e., page fault, EEXIT, and the memory)
to identify required gadgets from a completely hidden
environment. Additionally, the Dark-ROP attack can be
applied to any application that runs in an enclave, whereas
original Blind ROP is only applicable to server-like appli-
cations.
9 Conclusion
Dark-ROP is the first practical ROP attack on real SGX
hardware that exploits a memory-corruption vulnerability
and demonstrates how the security perimeters guaranteed
by SGX can be disarmed. Despite the vulnerability in the
enclave, realizing the attack is not straightforward since
we assume the most restrictive environment where all the
available security measures based on Intel SGX SDK and
recent SGX-related studies are deployed in the enclave;
thus, the code reuse attack and reverse engineering on the
enclave binary may not be conducted. To overcome this
challenge and accomplish the attack, Dark-ROP proposes
the novel attack mechanism, which can blindly locate
the required ROP gadgets by exploiting SGX-specific
features such as enclave page fault and its handling by
an asynchronous exception handler, ENCLU introduced
as part of new SGX instructions, and shared memory
for the communication between the enclave and the non-
enclave part of program. Finally, as a consequence of