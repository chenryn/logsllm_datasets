allow init t init var run t:file
{create getattr read append write
setattr unlink};
allow init t bin t:file
{{read getattr lock execute ioctl}
execute no trans};
allow init t etc t:file
{read getattr lock ioctl};
allow logrotate t etc t:file
3.
4.
{read getattr lock ioctl};
allow logrotate t bin t:file
5.
{{read getattr lock execute ioctl}
execute no trans};
allow chfn t etc t:file
6.
{create ioctl read getattr write
setattr append link unlink rename};
Figure 6 shows the result of the parsing of the previ-
ous rules. In this example, subjects with type init t
are allowed to read from and write to init var run t
and logrotate t is allowed to read from etc t and
bin t.
We note that Figure 6 shows that chfn t has write
access to etc t which logrotate t can read. While
logrotate cannot write any ﬁle with the label etc t,
USENIX Association  
17th USENIX Security Symposium 
329
chfn_t
init_t
init_var
_run_t
logrotate
_t
etc_t
bin_t
Figure 6:
Information-ﬂow graph for the system pol-
icy, including the logrotate program’s policy mod-
ule. chfn t is not trusted to modify other trusted pro-
grams, but it has write access to logrotate’s ﬁles la-
beled etc t.
it provides such a ﬁle via its package installation, so it
depends on the integrity of ﬁles of the label. This will be
identiﬁed as a tamperproof compliance exception below.
We are able to parse the text version of an SELinux
policy (ﬁle policy.conf) with a C program inte-
grated with Flex and Bison. We are also able to analyze
the binary version of the SELinux system policy.
Add logrotate program’s information ﬂows.
In
a similar fashion to the method above, we extend the
information ﬂow graph with the vertices (labels) and
edges (read and write ﬂows) from the logrotate pol-
icy module.
Remove edges where neither vertex is in the tamper-
proof goal policy. As these ﬂows cannot tamper the
logrotate program, we remove these edges from the
system policy for compliance testing.
5.1.3 Evaluating logrotate
This section presents how we automatically test tam-
perproof compliance. Tamperproof compliance is based
checking the system policy for information ﬂow integrity
as deﬁned by the tamperproof goal policy.
Integrity Compliance Checking. To detect integrity vi-
olations, we identify information ﬂows that violate the
Biba integrity requirement [4]: an information ﬂow from
a low integrity label (type in SELinux) to a high in-
tegrity label. read and write arguments are subject
and object.
N onBibaF lowsSELinux(P olicy) =
{(t1, t2) : t1, t2 ∈ types(P olicy). highintegrity(t1)∧
lowintegrity(t2) ∧ (read(t1, t2) ∨ write(t2, t1))}
We use the XSB Prolog engine [32] as the underlying
platform. We developed a set of prolog queries based on
the NonBiba Flows rule to detect the labels that affect
compliance (i.e., the high integrity requirement that are
not enforced by the system policy).
As mentioned in the previous section, we evaluate
tamperproof compliance at installation time. Each time
we load the policy graphs generated above into the Pro-
log engine and we run the integrity Prolog queries to
determine if any ﬂows satisfy (negatively) the NonBiba
Flows, thus violating compliance.
Results. Table 1 presents the results for compliance
checking logrotate against the generated tamper-
proof goal policy (see column 4). Only etc t has unau-
thorized writers.
In the SELinux/MLS reference pol-
icy, these writers are programs with legitimate reasons
to write to ﬁles in the /etc directory, but none have le-
gitimate reasons to write to logrotate ﬁles. For ex-
ample, chfn, groupdadd, passwd, and useradd
are programs that modify system ﬁles that store user
information in /etc, kudzu is an program that de-
tects and conﬁgures new and/or changed hardware in
a system and requires to update its database stored in
/etc/sysconfig/hwconf, and updfstab is de-
signed to keep /etc/fstab consistent with the devices
plugged in the system.
The obvious solution would be to reﬁne the labels for
ﬁles in /etc to eliminate these kinds of unnecessary and
potentially-risky operations.
5.2 Evaluating other Trusted Programs
Table 2 shows a summary of the results from applying
the PIDSI approach to eight SELinux trusted programs
for which policy modules and packages are deﬁned. The
table shows: (1) trusted package, (2) ﬁle labels (SELinux
types) used per package, (3) number of writers detected
per type (Writers) and (4) exceptions. The integrity re-
quirement assigned by default is high integrity for all
types, except for the ones marked with **; because of the
semantics associated to /var, various applications write
to this directory, we assign low integrity requirement to
var log t and var run t.
The
common system types
(bin t, etc t,
lib t, man t, sbin t and usr t) are marked
with † in the last two columns. The results for these
types are displayed in Table 3. The results show only
two exceptions, none in Table 2 and two in Table 3.
These reasons behind and resolutions for these excep-
tions are shown in Table 4. One good resolution would
be a reﬁnement of the policies: programs should have
particular labels for their ﬁles, even if they are installed
in system directories, instead of using general system la-
bels. The use of a general system label gives all system
330 
17th USENIX Security Symposium 
USENIX Association
Package
cups
SELinux Label
initrc exec t
textrel shlib t
lpr exec t
dbusd etc t
system types
var log t**
var run t**
var spool t
dmidecode
dmidecode exec t
system types
hald
iptables
kudzu
locale t
initrc exec t
hald exec t
dbusd etc t
system types
iptables exec t
initrc exec t
system types
locale t
initrc exec t
system types
initrc exec t
Network
Manager
NetworkManager
var run t
NetworkManager
exec t
dbusd etc t
system types
rpm exec t
rpm var lib t
system types
var spool t
sshd exec t
sshd var run t
ssh keygen exec t
ssh keysign exec t
rpm
sshd
8
9
8
7
†
14
10
10
8
†
7
8
8
7
†
8
8
†
7
8
†
8
8
8
7
†
8
7
†
10
8
8
8
8
no
no
no
no
†
no
no
no
no
†
no
no
no
no
†
no
no
†
no
no
†
no
no
no
no
†
no
no
†
no
no
no
no
no
Table 2: Results of applying the PIDSI approach to
SELinux Trusted Packages. Columns with a ‘†’ are dis-
played in table 3
programs access to these ﬁles (case APP LABELS in Ta-
ble 4). However, this option is not always possible, as
sometimes a program actually requires access to system
ﬁles. In such cases, the programs have to be trusted (case
ADD in Table 4). For example, some trusted programs
read information from the /etc/passwd ﬁle, so those
subjects permitted to modify that ﬁle must be trusted.
Only a small number of such programs must be trusted.
6 Discussion
Trusted programs may use system ﬁles, such as system
libraries or the password ﬁle, in addition to the ﬁles pro-
vided in their packages. Because some of our trusted pro-
gram packages installed their own libraries under the sys-
Writers
Exception
SELinux Label Writers
Exceptions
bin t
etc t
lib t
man t
sbin t
usr t
9
18
8
8
8
7
no
integrity
no
integrity
no
no
Table 3: System labels referenced by the packages pre-
sented in Table 2. Only etc t and man t have conﬂicts;
the number of conﬂicting types per case can not be high
(Writers column is an upper limit since it includes trusted
writers), so we can precisely examine each exception and
suggest resolutions (shown in Table 4).
tem label lib t our analysis included system libraries.
Therefore, application integrity not only depends on the
integrity of the ﬁles in the installation package but also
on some other ﬁles. In general, the ﬁles that the program
execution depends on should be comprehensively identi-
ﬁed. These should be well-known per system.
An issue is whether a trusted program may create a ﬁle
whose integrity it depends upon that has a system label.
For example, a trusted program generates the password
ﬁle, but this used by the system, so it has a system label.
We did not see a case where this happened for our trusted
programs, but we believe that this is possible in practice.
We believe that more information about the integrity of
the contents generated by the program will need to be
used in compliance testing. For example, if the program
generates data it marks as high integrity, then we could
leverage this in addition to package ﬁles and program
policy labels to generate tamperproof goal policies.
An issue with our approach is the handling of low in-
tegrity program objects. Since low integrity program ob-
jects are the lowest integrity objects in the system, any
program can write to these objects. We ﬁnd that we
want low integrity program objects to be relative to the
trusted programs; lower than all trusted programs, but
still higher than system data. Further investigation is re-
quired.