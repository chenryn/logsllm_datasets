tion 3.3.
Step six contains the analysis and classiﬁcation of the at-
tack manifestations according to a number of criteria. Each
manifestation has a number of properties that makes it more
or less useful for the detection of the attack. For exam-
ple, some are unique identiﬁers of the attack, and some are
only supportive of an attack hypothesis; some can be logged
with small resources, while other require resource demand-
ing logging; some come from necessary attack events, and
some may not be present in another attack script version.
The event and manifestation categorisation is discussed in
Section 3.4.
The attack indicators are created from the attack mani-
festations in step seven. The attack indicators consist of the
minimal unique parts of the attack manifestations, which
can be distinguished from the rest of the attack and nor-
mal event traces. This includes parts of single log entries,
sequences of parts of entries, or counts of entries. In the
system call logging case, the candidates for attack indica-
tors are unique system calls, unique system call sequences,
unique system call arguments or return values. Further dis-
cussion of creation of attack indicators is found in Sec-
tion 3.5.
The last step of the method is to deﬁne the log data re-
quirements of the created attack indicators. This is done by
summarising the log elements used in the indicators.
3.3 Comparison of event traces
Comparing two log traces from an attack event and a
normal event requires support from automated tools. Of-
ten many log entries are produced by a single event and
these do not always end up in exactly the same order. The
methods for comparing traces and extracting manifestations
for the three different log types we have used for the attack
evaluation are presented here.
System call logs. One way to compare system call logs is to
use a method based on creating diff ﬁles similar to those cre-
ated by the UNIX “diff” command. Here, the diff command
matches text strings in the two input ﬁles and produces an
output ﬁle with the lines that are added, removed or changed
in the ﬁrst input ﬁle compared to the second input ﬁle. The
diff command can not be used directly because the argu-
ments to some system calls differ almost every time they
are used. Thus, we automatically remove irrelevant infor-
mation, i.e. mainly process IDs, time stamps, and ﬁle de-
scriptors, before using the traditional UNIX diff command.
We then restore the removed log data ﬁelds from the orig-
inal system call logs. From these diff ﬁles it was possi-
ble to manually extract indicators without much effort and
knowledge about the function of the traced program. Man-
ifestations, such as certain system calls only appearing in
one of the ﬁles, differences in frequency of certain system
calls, sequences of system calls that differ, and system call
arguments that differ, could be seen rather easily. For this
method to work well, one process at a time should be anal-
ysed, and preferably the two traces should be from the same
program version.
Also, we supported the comparisons with system call fre-
quency analysis and searches for strings that appear in the
attack script and user names involved in the attack for ex-
tracting the attack manifestations. Counting the use of each
4
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
system call in the event traces clearly distinguishes calls that
appear in one trace but not in the other.
Network trafﬁc logs. Diff ﬁles similar to the ones we de-
scribe for the system call logs were created for the compari-
son of the network trafﬁc logs. The elements in the network
packet logs that were selected for comparison was source IP,
destination IP, transport protocol, application protocol port,
and data length.
We also used some visualisation methods to compare
two logs and extract the differences. Packet types, packet
sizes and the use of different protocol ﬂags were useful to
plot, to get a conception about similarities and differences in
two packet streams. String searches were useful for ﬁnding
packets containing special strings or ﬁle names that were
connected to the attack.
Application logs are often designed to be manually read-
able and user actions do not generate a large amount of data
in these logs. We have only used manual comparison for
these logs in the attack evaluations in this paper.
3.4 Categorisation of events, manifestations, and
indicators
The reason for classifying attack events and their mani-
festations is that it helps us choose which manifestations to
use when creating attack indicators. The most useful mani-
festations are strong indicators of events that are malicious,
always part of the attack and can only be performed in one
way.
The reason for classifying attack indicators is that it
helps us choose the best set of indicators, and thus also log
elements, for detecting a group of attacks. This can form
the basis for creation of a new “slimmed” log data source
containing only necessary information. Another reason for
classifying attack indicators is that it helps an IDS designer
to choose the best set of indicators for detecting a speciﬁc
attack. What the best set of indicators is, depends for ex-
ample on the possibility to use different kinds of logging in
the system and the processing power of the IDS. Also, the
indicators in the set should complement each other, for ex-
ample by including one that is useful for detecting the attack
attempt, and another indicating the result of the attack.
Another goal of the classiﬁcation is that it should be use-
ful for quickly determining the (theoretical) detection ca-
pability of an IDS, for a speciﬁc set of attacks and for a
speciﬁc set of input log data.
Below we suggest categorisations that can be used for
evaluating the events, manifestations, and indicators. These
are used in the presentation of our results in Section 4.
The Attack Phases are divided into three parts:
preparatory events (P1), attack execution events (P2), and
compromised-system-use events (P3).
The Attack Meta-Event Necessity Categories are di-
vided into two levels: necessary attack events (N1) and op-
tional attack events (N2). An attack event is classiﬁed as
necessary if it is necessary for the attack to be successful.
Obviously, indicators built of necessary attack events are
more useful than those from optional attack events. The lat-
ter can easily be defeated by attack variations.
The Attack Meta-Event Variability Categories are di-
vided into two levels: invariable events (V1) and variable
events (V2). Even if an attack event in itself is N1, the par-
ticular methods used to perform the event may be exchange-
able, resulting in a different attack trace.
The Attack Meta-Event Maliciousness Categories are
divided into three parts: violation (M1), indirect violation
(M2), and benign events (M3).
The Attack Manifestation Strength Categories are di-
vided into two parts: strong manifestations (S1) and weak
manifestations (S2), depending on how much information
the manifestation reveals about the underlying event. A
strong manifestation of a meta-event representing a viola-
tion is of course more useful for detection than a weak man-
ifestation of a meta-event representing a benign event. A
meta-event classiﬁed as benign (M3) can generate strong
manifestations, but these only show that a speciﬁc (normal)
event has taken place and can not be used for detection by
themselves.
The Attack Indicator Application Categories are di-
vided into ﬁve parts:
indicator for identifying the attack
(U1), indicator for detecting illicit behaviour (U2), indica-
tor for detecting attack result (U3), indicator for detecting
service in vulnerable mode (U4), and indicator for detect-
ing use of the vulnerable service (U5).
The Attack Indicator Complexity Categories are di-
vided into four parts: single log entry (C1), sequence of log
entries (C2), count of log entries (C3), and log entries re-
quiring parsing to assemble event (C4), related to the com-
puting and memory resources needed to use the indicator in
question.
3.5 Extraction of log indicators
Indicators are created from the manifestations by analy-
sis of the included log entries. The goal of the analysis is
to ﬁnd the unique minimal parts of the manifestation that
could be used for detection. For example, in the system
call logs manifestations we analyse each system call to de-
termine if it is unique, i.e. a foreign symbol according to
Killourhy et al. [KMT04]. We also study the arguments
and return values to see if they are unique. Sequences are
studied to ﬁnd out if they are unique. These sequences can
also include the log entries surrounding the manifestation,
and corresponds to the minimal foreign sequences used in
Killourhy et al. [KMT04]. The last type of analysis is the
frequency analysis of single system calls and sequences.
5
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Attack progress
Execution
Preparations
Normal RSA setup on user
Normal ssh RSA login with
account
prepared key,
Create or transfer shared
library with call to seteuid(0) which triggers execution of
shared library
Prepared ssh RSA key to
load shared library
Success:
Execution of shared library
as root
Failed:
Execution of shared library
as user
System usage
Checking root identity
Traces
Figure 2. OpenSSH attack phases
3.6 Discussion of the framework
The goal of this work is to be of help in the search for
suitable log data that can be included in a new log source
for intrusion detection. However, the framework presented
in this paper is still only an outline of how the log data ex-
traction procedure can be done. We have suggested some
partly automated methods for extracting manifestations and
for creation of log indicators that we use for the attack anal-
ysis. We have also suggested categories for classiﬁcation
and evaluation of attack events, manifestations, and indica-
tors. A complete methodology for extraction of log data
requires further automation of each step and further investi-
gation of how each step is best implemented. These issues
are the subject of ongoing work.
We still believe that a new log source can be created from
the lists of log data that are extracted in the attack analysis
process described in this paper. By analysing attacks and
selecting log indicators for which the log elements are com-
mon for a group of attacks, we can minimise the log data
needs for that group of attacks. Another possible use of this
framework is to help developers of intrusion detection sig-
natures to ﬁnd and choose suitable attack signatures.
4 Attack analysis
In this section, we describe experiments that we have
carried out. We used the proposed framework and the sug-
gested methods for analysing attacks to determine their log
data requirements. We chose three different attacks and
three different log sources for the ﬁrst set of experiments.
We tried to choose attacks that are different in their log data
demands. Since no classiﬁcation exists that is based on log
data needs, the attacks were chosen on other characteris-
tics that seemed relevant. One is a denial of service attack
against a network protocol (Neptune SYN ﬂood - CERT
CA-96.21), one is a buffer overﬂow which affects the execu-
tion ﬂow in the operating system (Tcpdump attack - bugtraq
ID 1870, CVE-2000-1026), and one is a exploit of a priv-
ilege checking ﬂaw (OpenSSH - bugtraq ID 1334, CVE-
2000-0525). Three of the main types of audit sources are
studied in the experiments in this paper. These are network
trafﬁc logged by tcpdump; system calls logged by strace
and also by syscalltracker; and application-based logging
with syslog.
4.1 OpenSSH analysis
We exemplify the use of the methodology with the
OpenSSH attack and go through the steps in more detail
for this attack. This attack is a local root attack against the
OpenSSH server. The ﬂaw is in the ssh RSA login pro-
cedure. The user adds an option to the RSA key, which
makes the ssh server load a user-deﬁned shared library. The
ﬂaw is that the shared library is loaded with the rights of
the ssh server, and not the user. Figure 2 shows the main
user actions in the different phases of the OpenSSH attack.
For each of these user events, we created a meta-event by
adding the expected system reaction and response.
4.1.1 OpenSSH events. The normal events we chose to
compare the attack events to, were ssh password login for
the RSA setup, RSA login session without commands for
the key preparation and creation of shared library, and a
normal RSA login with identity checking commands for
the attack execution and system usage events. The failed
attack variants used were an attack against an invulnera-
ble OpenSSH version (3.1), and one against the vulnerable
OpenSSH version (2.9) run with the “UseLogin” option set
to “no” in the conﬁguration ﬁle. The second variant does
not use the systems /bin/login program, which is necessary
for the attack to work. Table 4.1.1 shows an example of a
meta-event, from the OpenSSH attack, with the correspond-
ing normal and failed attack meta-event.
4.1.2 Comparing traces. The syslog ﬁles were uncom-
plicated to compare. There were few entries for each event
and they always ended up in the same order.
The tcpdump logs were a little bit more complicated,
since the packets did not always show up in the same or-
der, and since they were encrypted it was difﬁcult to match
them. The comparison of tcpdump ﬁles were supported by
6
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Table 1. A meta-event example for the OpenSSH attack
Events of
one meta-event
user action
system reaction1
system reaction2
system reaction3
system response
Successful attack
Normal behaviour
SSH RSA login with
prepared key
“Installing” shared library
Using shared library
Performing identity check
Root prompt
SSH RSA login with
normal key
(no corresponding reaction)
(no corresponding reaction)
Performing identity check
User prompt
Failed attack
(wrong SSH version)
SSH RSA login with
prepared key
(no corresponding reaction)
(no corresponding reaction)
Performing identity check
User prompt
creating diff ﬁles created with the method described in Sec-
tion 3.2 and by plotting packet sizes and TCP ﬂags.
The system call logs were the most time-consuming to
compare. Some system calls ended up in different order
comparing two traces generated by the same event. These
were brk(), rt sigprocmask(), and wait4(). When the user
were typing commands, the calls sometimes differed be-
tween runs since characters were sent one or two at a time.
Still, it was feasible to use the diff ﬁles to extract the mani-
festations for all events in this attack.
4.1.3 OpenSSH attack manifestations and log ele-
ments. In the syslog logs there are no differences between
successful attack and a normal ssh RSA login. Neither are
there any signiﬁcant differences in the tcpdump logs. The
best tcpdump manifestation is the packet with the clear text
ssh server version number. The trafﬁc is encrypted, so the
user commands etc can not be seen at all. The comparison
of system call log ﬁles generate more useful manifestations.
Table 2 shows all the events for the OpenSSH attack and
the presence of attack manifestations for the events in the
different log ﬁles. Table 3 shows the chosen indicators for
the OpenSSH attack, and the log elements needed for each
of these indicators. Here it can be seen that we actually have
strong manifestations from the syslog and tcpdump logs,
but it should be noted that these are only from benign attack
events, and thus not very useful for detection. From the
system call logs we have strong manifestations of all events,
except the actual “execution” of the shared library. We can
only see the secondary effects of this event.
The ﬁrst three indicators are from benign attack events,
but are the best that could be created from syslog and tcp-
dump. The rest of the indicators are from malicious or indi-
rectly malicious manifestations in the system call log. The
fourth indicator uses the fact that the call setresuid() should
not appear in the login program trace, i.e. it is a foreign
symbol. The ﬁfth indicator uses a sequence of system calls
that do not normally appear. The sixth indicator uses the
call getuid() with return value, and the rest of the indicators
use a single system call together with a speciﬁc argument.
4.2 Tcpdump attack analysis
The Tcpdump attack generates interesting entries in both
the network trafﬁc log and the system call log. However,
there are no entries from the attack in the syslog ﬁles. Also,
Table 2. Attack events for the OpenSSH attack
Presence of attack
Attack events
Meta-event 1: [P1,N1,V2,M3]
User action: Scp transfer of RSA key
System reaction and response: -
Meta-Event 2: [P1,N1,V2,M3]
User action: Password login to set up key
System reaction and response: -
Meta-Event 3: [P1,N1,V2,M3]
User action: Commands to set up key
System reaction and response: -
Meta-Event 4: [P1,N2,V2,M3]
User action: RSA login to test setup
System reaction and response: -
Meta-Event 5: [P1,N1,V2,M3]
User action: RSA login to do attack setup
System reaction and response: -
Meta-Event 6: [P1,N1,V2,M2]
User action: Commands to set up shared library
System reaction and response: -
Meta-Event 7: [P1,N1,V2,M2]
User action: Commands to prepare RSA key
System reaction and response: -
Meta-Event 8: [P2,N1,V1,M1]
User action: Ssh login using prepared RSA key
System reaction 1: ”Installation” of shared lib
System reaction 2: Use of shared library
System reaction 3: Extra mprotect() calls
System reaction 4: Lib debug info is printed
System reaction 5: Changed setuid() calls
System reaction 6: Extra egrep sessions
System reaction 7: System checks identity
System reaction 8: Root’s PATH is used
System reaction 9: Root’s conﬁgurations ﬁles
System response: User is given root prompt
Meta-Event 9:[P3,N2,V1,M2]
User action: ”whoami” command
System reaction 1: executes whoami program
System reaction 2: checks user identity
System response: answer to whoami