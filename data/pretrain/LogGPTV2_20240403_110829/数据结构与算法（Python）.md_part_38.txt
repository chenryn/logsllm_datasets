函数使用一个变量以在 dfsvisit 的调用过程中保持对时间的记录，我们选择将这段代码作为一个
继承于 Graph 类的方法类。这个操作通过添加一个时间实例变量和 dfs 与 dfsvisit 两个方法拓
展了图类。观察11行你会发现 dfs 算法在图中每个白色节点迭代调用 dfsvisit 来遍历图中的所
有顶点。我们遍历所有顶点而不是简单地从某个选定起始顶点开始搜索是为了保证图中所有顶点都
被考虑到并且没有顶点在深度优先森林中被遗漏。 for aVertex in self 这条语句或许看起来不同
寻常，但是要记住在这例子中 self 是 DFSGraph 类的一个实例并且遍历一个图类的实例中所有的
顶点是很自然的。
from pythonds.graphs import Graph
class DFSGraph(Graph):
def __init__(self):
super().__init__()
self.time = 0
def dfs(self):
for aVertex in self:
aVertex.setColor('white')
aVertex.setPred(-1)
for aVertex in self:
if aVertex.getColor() == 'white':
self.dfsvisit(aVertex)
def dfsvisit(self,startVertex):
startVertex.setColor('gray')
self.time += 1
startVertex.setDiscovery(self.time)
for nextVertex in startVertex.getConnections():
if nextVertex.getColor() == 'white':
nextVertex.setPred(startVertex)
self.dfsvisit(nextVertex)
startVertex.setColor('black')
self.time += 1
startVertex.setFinish(self.time)
代码7.10
虽然我们对 bfs 的实现只对那些拥有一条可以指回起始顶点的路径的节点感兴趣，但是创建一
个广度优先森林来表示图中所有顶点对之间的最短路径是有可能的。我们将此留作练习。在我们接
下来的两个算法中我们会看见为何保持对深度优先森林的追踪是重要的。
dfsvisit 方法以一个叫做 startVertex 的单一顶点开始并尽可能深地探索所有相邻白色顶
点。如果你仔细观察 dfsvisit 的代码并将其与广度优先搜索进行比较，你应当注意到 dfsvisit
算法除了在内部循环的最后一行外与 bfs 几乎相同。 dfsvisit 递归调用自身以继续对更深层次的
探索，而 bfs 通过将顶点添加到一个队列中以便后续探索。需要注意的是，在 bfs 使用队列的地
方， dfsvisit 使用的是栈。你虽然在代码中看不见栈的形式，但是它暗含在 dfsvisit 的递归调
用中。
以下插图说明了深度优先搜索算法对一个较小的图的操作。这些图中，虚线表示边已经检查，
但在边的另一端的顶点已经被添加到深度优先树中。在代码中这个测试是通过检查另一端的顶点的
颜色是否是非白色的来实现的。
搜索从图中的 A 顶点开始（图7.23）。由于所有的顶点在开始时都是白色的所以算法首先访问
A 顶点。访问该节点的第一步操作是将其颜色设置为灰色以表明这个顶点已被探索过并且将“ 发现
时间” 设置为 1。由于 A 顶点拥有两个相邻顶点（B和D）并且这两个顶点都需要被访问，所以我
们任意地决定，比如我们按照字母表顺序依次访问相邻顶点。
接下来访问 B 顶点（图7.24），然后它的颜色被设置为灰色并且它的“ 发现时间” 被设置为
2。由于 B 顶点同样有两个相邻顶点（C和D），所以我们按照字母表顺序接着访问 C 顶点。
在访问 C 顶点（图7.25）的过程中我们到达了树的一枝的末端。在将 C 顶点涂为灰色并将
“ 发现时间” 设置为 3 后，算法认为 C 顶点没有相邻顶点。这意味着我们完成了对 C 顶点搜索
并且我们可以将其涂为黑色并设置“结束时间”为4。你能在图7.26中看见这一阶段的情形。
由于 C 顶点在一枝的末端，所以我们返回 B 顶点并继续探索 B 顶点的相邻顶点。由于 B顶点
的唯一相邻顶点是 D，所以我们现在访问 D 顶点（图7.27）并从此继续我们的搜索。D顶点迅速将
我们带向 E 顶点。 E 顶点有 B 和 F 两个相邻顶点。通常我们会按照字母表顺序探索这些相邻顶
点，但由于 B 顶点已经被标记为灰色，所以算法识别出它不应该访问会导致算法陷入死循环的 B
顶点。所以继续探索列表中的下一个顶点F。（图7.28）
F 顶点只有一个相邻顶点 C，但由于 C 顶点已经被标记为黑色，不能继续探索，并且算法也到
达了树的另一枝的末端。从此开始，你会看见算法一路运算返回初始顶点、设置“结束时间”并设
置顶点颜色为黑色（图7.29-图7.34）。
图7.23 建立深度优先搜索树 10
图7.24 建立深度优先搜索树 11
图 7.25 建立深度优先搜索树 12
图 7.26 建立深度优先搜索树 13
图 7.27 建立深度优先搜索树 14
图 7.28 建立深度优先搜索树 15
图 7.29 建立深度优先搜索树 16
图 7.30 建立深度优先搜索树 17
图 7.31 建立深度优先搜索树 18
图 7.32 建立深度优先搜索树 19
图 7.33 建立深度优先搜索树 20
图 7.34 建立深度优先搜索树 21
“开始时间”和“ 结束时间” 展示了每个顶点的被称为括号性质的性质。这个性质意味着深度优
先树中一个特定顶点的所有的子顶点拥有与它们的父顶点相比更晚的“发现时间”和比
更早的“ 结束时间”。图7.35展示了深度优先搜索算法建立的树。
图 7.35 最终深度优先搜索树
7.9 拓扑排序
在计算机学家看来，几乎所有的问题都可以转化为一个图问题，为了验证这个说法，让我们考
虑一个复杂的问题——做一个热香饼。食谱十分简单：鸡蛋1个，面粉1杯，油1汤匙，牛奶3/4
杯。制作热香饼需要先预热平底锅，将所有原料混合均匀后，再将原料舀入加热好的锅中。待锅中
的混合物开始冒泡时，将面饼翻面，煎至底部变为金黄色。在吃松饼之前你也可以加热一些果酱作
为佐料。图 7.36以图表的形式说明了这一过程。
图 7.36： 制作热香饼的步骤
制作热香饼的困难之处在于第一步做什么。如图 7.36 所示，你可以从加热平底锅开始，也可以
从向面粉中加入原料开始。为了帮助我们在制作热香饼时的每一步都能有一个清晰的顺序，我们可
以求借助于一个叫拓扑排序的图算法。
拓扑排序可以将一个有向无圈图(DAG)转换为一个只含它所有顶点的线性排列，例如如果一个图
G包含一个边界(v,w)，然后我们就可以按顺序将顶点v放在顶点w之前。DAG 在许多应用中都可以
起到指示事件优先级的作用，制作热香饼只是其中一个例子。像这样的例子还有：设计软件工程日
程，制作可以优化数据库查询的图表，解决矩阵相乘等问题。
拓扑排序是深度优先搜索(DFS)的一个简单却有效的应用。拓扑排序的算法遵从以下法则：
1.为所求图问题调用DFS函数。我们调用DFS的主要原因是为了计算每一个事件顶点的完成时
间。
2.按完成时间降序将事件顶点存储在一个列表中。
3.将列表作为拓扑排序的结果返回。
图7.37展示了我们把DFS应用于图7.36中热香饼制作问题后所构造的深度优先森林。
图7.37：对做热香饼的图进行深度优先搜索的结果
最后，图7.38展示了为我们的图应用拓扑排序算法后的结果。现在，所有模棱两可的东西都被
移除，我们可以确切地知道制作热香饼时每一步的顺序了。
图 7.38：用有向无圈图(DAG)表示拓扑排序的结果
7.10 强连通分支
本章剩余部分我们将关注一些极其巨大的图，用来学习一些其他算法，这些图产生于互联网上
主机之间的连接和网页之间的链接。我们将从这些网页开始。
像 Google 和 Bing 这样的搜索引擎都是从网页构成的巨大有向图中搜索想要得到的事实。为了
将互联网转换为一张图，我们将每一张网页看作一个顶点，网页上的超链接看作联接顶点的边。图
7.39 显示了图的一个非常小的部分，这部分开始于（美国）路德学院的计算科学主页，通过网页之
间的链接产生。当然，这张图可以相当巨大，所以我们不得不限制每张网站到与代码段所在主页的
最大链接数不能超过10个。
图7.39：由源自路德学院计算科学主页的链接形成的图
如果你仔细研究了图7.39，你也许会观察到一些有意思的现象。首先你也许会注意图中许多其
他的网站也是路德学院的网站。其次，你也许会注意有一些链接指向了爱荷华的其他一些大学。第
三，你可能发现有一些链接指向一些其他的人文艺术学院。
你可能会从中得出结论，这些将同一水平的网站聚合在一起的网页有一些潜在的结构。有一种
图算法能够帮助我们发现图中高度相互关联的顶点，它被称为强连通分支算法(SCC)。我们正式在一
张图 G 中定义一个强连通分支C，作为最大的顶点子集 c⊂V，因此对于其中每一对顶点 v,w∈C，
我们均能使w和v相互连通。图 7.40 显示了一个仅有三个强连通分支的简易图，其中的强连通分支
由不同的阴影区分开。
图 7.40：一张有三个强连通分支的有向图
一旦强连通分支被区分后，我们就可以将一个强连通分支中的所有顶点合并为单个更大的顶点
从而简化图的形式。图 7.40 的简化形式见图 7.41。
图 7.41：简化图
我们将再一次看到我们可以利用深度优先搜索开发强有力的算法。但在我们处理 SCC 算法之前
我们必须考虑另一个定义。对于一个图G，它的换置图被定义为所有的边都被逆转的一个新图GT。
也就是说，如果原图G有一个从节点A至节点B的有向边，那么换置图GT中会含一个从节点B至节
点A的边。图 7.42 和 7.43 分别展示了一张简单图和它的换置图。
图 7.42：图G
图 7.43：换置图GT
再看一遍上图。我们可以发现无论图7.42还是图7.43都有两个强连通分支。
我们现在可以描述该算法来计算整个图中的强连通分支。
1.调用深度优先搜索算法(DFS)计算图G中每个顶点的完成时间。
2.计算置换图GT
3.调用DFS计算图GT，但是当DFS主循环探索每个顶点时，减少完成时间。
4.步骤3生成的森林中每一棵树都是一个强连通分支，输出每一棵树每一个顶点的地址从而识别
其分支。
让我们追溯图7.40中所描述的每步的操作。图7.44显示了对原图调用DFS算法时的起始和结束
时间，图7.45显示了在转置图中运行DFS时起始和结束时间。
图 7.44：原图G的结束时间
图 7.45：转置图GT的结束时间
最终，图7.46显示了强连通分支算法的步骤3中形成的三棵树组成的树林。你会注意到我们并
没有提供给你SCC算法的python代码，因为我们将其留为测试题。
图 7.46：强连通分支
7.11 最短路径问题
当你浏览网页，发送邮件，或者在校园里另一个地方登录某实验室主机时，电脑后台会运行很
多指令将你所使用的电脑的信息传输给另一台电脑。深入研究信息是如何通过网络在电脑之间传递
是计算机网络课程的首要课题。然而，我们讨论计算机网络的工作方式只是为了理解另一种十分重
要的图运算法。
图 7.47：互联网连接概览
图 7.47 展示的是高度抽象概括后的互联网交流方式。当你使用自己的浏览器向服务器发出一个
网页浏览请求时，这个请求必须遍历你当地局域网并且通过路由器发送到互联网上，在搜索过互联
网后最终到达服务器所在局域网的路由器。然后你所要浏览的网页经由相同的路由器组传送回你的
浏览器。图1中的云形标记里的“Internet”就是上述路径中额外需要的路由器，它们共同的任务是
把你的信息从一个地方传输到另一个地方。如果你的电脑支持路由跟踪指令，你可以看到许多路由
器在为你服务。下面的文本是路由跟踪指令的输出结果，它显示路德学院的网页服务器和明尼苏达
大学的邮件服务器是通过13个路由器连接。
1 192.203.196.1
2 hilda.luther.edu (216.159.75.1)
3 ICN-Luther-Ether.icn.state.ia.us (207.165.237.137)
4 ICN-ISP-1.icn.state.ia.us (209.56.255.1)
5 p3-0.hsa1.chi1.bbnplanet.net (4.24.202.13)
6 ae-1-54.bbr2.Chicago1.Level3.net (4.68.101.97)
7 so-3-0-0.mpls2.Minneapolis1.Level3.net (64.159.4.214)
8 ge-3-0.hsa2.Minneapolis1.Level3.net (4.68.112.18)
9 p1-0.minnesota.bbnplanet.net (4.24.226.74)
10 TelecomB-BR-01-V4002.ggnet.umn.edu (192.42.152.37)
11 TelecomB-BN-01-Vlan-3000.ggnet.umn.edu (128.101.58.1)
12 TelecomB-CN-01-Vlan-710.ggnet.umn.edu (128.101.80.158)
13 baldrick.cs.umn.edu (128.101.80.129)(N!) 88.631 ms (N!)
Routers from One Host to the Next over the Internet
Routers from One Host to the Next over the Internet
互联网上每一个路由器都连接着一个或多个其他的路由器。所以如果你在同一天中的不同时间
段执行路由跟踪指令，很有可能发现你发送的信息在不同的时间经过了不同的路由器。这是因为任
何两个路由器之间的连接都不是没有代价的，而是受线路拥挤情况、时间以及许多其他因素的影
响。这样，当你知道我们可以用一张含有权边的图来代表路由器之间的网络时，就不会感到惊讶
了。
图 7.48：互联网路由器之间的连接和权重
图7.48展示了一个用有权重图来代表互联网路由器之间相互连接情况的小例子。我们想要解决
的问题是找到一条总权重最小的路线，并且使之实现传递任何信息的功能。这个问题听起来很熟
悉，因为它与我们用广度优先算法解决过的问题很相似，区别在于现在我们要考虑的是整条路线的
总权值，而不是路线中的节点数。需要特别注意的是，如果所有边的权值都相等，那么这两个问题
是等价的。
7.11.1.DIJKSTRA 算法
我们即将使用的选择加权最短路径的算法被称为“Dijkstra 算法。“Dijkstra”算法是一 种迭代算法，
用来提供从一个确定的开始节点到所有图中其他节点的最短路径，这与广度优先搜索的结果很类似。
为了追踪从开始节点到每一个结束节点的总权值，我们将在顶点 Vertex 类中使用 dist 作为实例变