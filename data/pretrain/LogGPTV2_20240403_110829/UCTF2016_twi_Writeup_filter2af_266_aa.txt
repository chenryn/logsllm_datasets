# UCTF2016 twi Writeup
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
该题目分类为REVERSE。最终目标是提交一个flag。
从题目来看，本题目应该是UCTF 2016中的题目，可能是由于笔者的搜索能力还有待提高，没有能够找到相关的Writeup。所以，本次只能自己摸着石头过河了。
题目下载地址：
## 解题准备
### 验证下载正确性
### 基础信息分析
#### 文件类型识别
可以看到，文件是Atmel AVR 8-bit 的ELF文件。
查看是否有隐藏信息
从binwalk的结果来看，应该没有什么隐藏的数据。
字符串分析
各位小伙伴看到这个是不是就已经跃跃欲试了啊。反正我当时是觉得前途光明，形势非常好。不是小好，而是大好。。。
### 环境准备
#### 模拟器
笔者手头并没有Atmel AVR架构的板子，所以优先考虑使用模拟器。
经过搜索，发现了三款模拟器：
  * simavr
  * simulavr
  * qemu-system-avr
考虑到simavr在网络上得到了比较多的推荐，优先考虑使用之。
笔者的系统是Ubuntu 20.04 LTS on Windows 10 WSL。这三款模拟器都可以通过apt 直接安装。
sudo apt install simavr
安装成功后，可以执行一下，看看说明信息。在说明信息中，发现了–list-cores参数。我们一并来看一下simavr都支持哪些core。
#### 调试器
有了模拟器，我们可以执行镜像了。接下来，需要调试工具。
sudo apt install gdb-avr
gdb这种神器想必大家已经用得出神入化，不用笔者这种小白啰嗦啦。
#### 反编译器
考虑到笔者对版权的洁癖以及贫穷，IDA虽然强大，但也只能忍痛放弃。
其实Ghidra已然足够强大了，我们本次选择ghidra_9.1.2_PUBLIC_20200212作为逆向工作环境。
在Ghidra中Import 目标文件，AVR架构可以正常识别。之后进行自动分析。
可见镜像从地址0x000000开始。由于镜像没有任何symbol或者debug信息，此处可能需要手动按D来强制进行反汇编。细心的小伙伴可能已经发现，明明每个指令是两个字节，但是前面的地址并没有按照两个字节增加。。。
#### Atmel AVR架构
Atmel AVR 8-bit 是一个精简指令集架构。具体信息大家可以去网上找。信息还是不少的，必定Arduino就是采用这个架构的。
AVR 采用哈弗结构，指令、数据分开寻址。从上面的图，大家可以看到code地址。其实还有一个mem地址。来看下图：
好的，我们现在来讨论一下上面说的，code地址的增加步进不是2的问题。
可以看到，mem寻址是按照1个字节的步进增加的。这里涉及到AVR的寻址模式。mem是按照正常的方式寻址，而code是按照2个字节为一组寻址。也就是内存中的地址是PC
* 2。
关于AVR 8-bit的寄存器，总体来说和一般RISC架构的大同小异。不过这里要注意寄存器的别名。比如
W、X、Y以及Z，这个几个是用来间接寻址的寄存器。由于寻址需要，所以他们是8个通用寄存器，分成4对，作为4个16 bit寄存器。
需要注意的是，在gdb中执行“i r”的话，并不会显示这几个寄存器。为了能更方便的获取这几个寄存器的信息，笔者还专门写了一段gdb脚本。。。
在实际操作中，需要准备一份AVR 8-bit的指令说明书。笔者搞到这个里面里面带广告，就不放出来了，大家自己找找吧。
## 尝试运行
运行镜像，最大的挑战在于如何选择机型。笔者认为，越简单的东西，越不容易出问题。出了问题，也可以更方便的排查，所以先选择了atmega8
作为目标机型。当然，最终机型的确定是在整个解题过程中，一点点确定的。题目中的twi其实指的就是单片机中使用广泛的TWI协议，所以比如0x53、0x21和0x23肯定是TWI相关寄存器。另外，根据程序逻辑，判断0x60
肯定不能是寄存器，而是内存区域。
解题成功后，再次进行实验，目前发现atmega8 和 atmega32 都可以作为目标机型。
执行命令：
simavr -t -m atmega8 –gdb twi.70087b1e507aee08fc5c376a7b5ccc80
执行gdb，并attach：
avr-gdb
target remote :1234
这里笔者遇到了问题。尝试设定断点，可是得到：
首先，断点失败。这个在我偶然ptype
$pc的时候找到了答案。由于AVR是指令数据分开寻址，所以要设定断点，我们需要提供code地址而不是data地址。怎么提供呢？大家自己ptype
$pc下试试吧。当然，也可以参照笔者编写的gdb脚本。
其次，为啥明明设定的是0x26，地址却变成了0x800026。因为我们提供的0x26被认为是数据，而被模拟器自动转换到了对应的内存区域。具体情况大家可以参照simavr的源代码。
那么执行、断点的问题都解决了，我们可以开始进行逻辑分析了。
## 逻辑分析
### 入口点
通过Vector表，我们可以找到入口点：
这个函数是我自己加的，默认分析完这里是个label。这段代码的作用主要是进行栈的初始化，并且将程序段的一些数据copy到data区域以及进行一些内存区域的初始化。
从本块代码，我们可以看到，SP被初始化为0x45f。
接下来，将我们关注的字符串”flag{“ copy到了0x60。当然，还有”success”和”fail”
等等。然后跳转到了函数：FUN_code_0002d3。
### FUN_code_0002d3
这个函数里面逻辑还是挺多的。
嗯，顿时头大。到这里，笔者决定先跑起来看看。
### 寻找线索
运行起来，没有Log输出。（后来发现，偶尔会有”fail” 的log出来，应该是模拟器的问题。）
经过了几次c – CTRL_C 循环后，发现程序都停在这里：
接下来看看这里在干什么。注意，这里地址是0x240，需要换算成code地址：0x120。
经过一番痛苦的分析，笔者发现：这段逻辑是个延迟。没有发现任何side effect，纯纯的延时。嗯，那还能咋办，为了能够进一步分析，当然要干掉啊。
这里，干掉这个延时有两个办法：