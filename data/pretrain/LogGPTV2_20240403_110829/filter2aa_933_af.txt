previously created for the sake of this demo. Before we do this, we need to use Process 
Monitor (ProcMon).
In Procmon.exe, we will set up filters, as shown in the following screenshot:
Figure 4.9 – ProcMon filtering by example
68     Bypassing the Dynamic Engine
As seen here, we can configure the Process Name filter to display the exact and only 
results of the notepad.exe process. Then, we use the Operation filter to be only the 
value of CreateFile, which of course, as explained before, creates a file or receives a 
handle to an existing one. Finally, we use the Path filter followed by the Demo value so 
that it will only display results regarding filenames with a Demo string in them. Here is a 
screenshot that shows the results after the opening of the file with notepad.exe:
Figure 4.10 – ProcMon CreateFile example
As seen here, the CreateFile operation is performed with a Desired Access of Generic 
Read, as it should be. Let's now go deeper and understand how this operation is executed 
from a low-level perspective. In the following example, and in the case of Windows's 
notepad.exe program, the Windows API function used is CreateFileW. We need to 
put a breakpoint on this function to understand the execution flow. To do this, we will use 
the x64dbg user-mode debugger. 
The following screenshot demonstrates how a breakpoint is set on the CreateFileW 
function and shows that the process hit the breakpoint:
Antivirus bypass using process injection     69
Figure 4.11 – x64dbg CreateFileW call example
In the command pane of x64dbg, you can see the bp CreateFileW command, and after 
we hit Enter and the F9 key to continue execution, the process hit the breakpoint. There, 
we can now see an assembly instruction of jmp CreateFileW, which is part of the 
kernel32.dll library.
70     Bypassing the Dynamic Engine
The following screenshot shows what happens after the jump is executed—execution is 
transferred from kernel32.dll to the kernelbase.dll library, which contains the 
actual Windows Native API function, ZwCreateFile: 
Figure 4.12 – x64dbg ZwCreateFile call example
Finally, in the following screenshot, you can see that the execution is transferred from the 
kernelbase.dll library to the ntdll.dll library before the syscall instruction 
is executed and transferred to lower layers of the Windows operating system such as the 
kernel:
Figure 4.13 – x64dbg syscall after ZwCreateFile call example
Armed with this deeper understanding of the basic concepts and practices underlying 
how Windows handles process execution, we can now delve into three process-injection 
techniques.
Antivirus bypass using process injection     71
Classic DLL injection
We refer to this first technique as classic DLL injection. This technique forces the loading 
of a malicious DLL into a remote process by using these six basic Windows API functions: 
• OpenProcess: Using this function and providing the target process ID as one of 
its parameters, the injector process receives a handle to the remote process.
• VirtualAllocEx: Using this function, the injector process allocates a memory 
buffer that will eventually contain a path of the loaded DLL within the target 
process.
• WriteProcessMemory: This function performs the actual injection, inserting the 
malicious payload into the target process.
• CreateRemoteThread: This function creates a thread within the remote process, 
and finally executes the LoadLibrary() function that will load our DLL.
• LoadLibrary/GetProcAddress: These functions return an address of the 
DLL loaded into the process. Considering that kernel32.dll is mapped to the 
same address for all Windows processes, these functions can be used to obtain the 
address of the API to be loaded in the remote process.
Note
The x86 and x64 processes have a different memory layout, and loaded DLLs 
are mapped onto different address spaces.
After performing these six functions, the malicious DLL file runs within the operating 
system inside the address space of the target victim process.
72     Bypassing the Dynamic Engine
In the following screenshot, you can see a malware that is using classic DLL injection in 
IDA Pro view:
Figure 4.14 – Classic DLL injection in IDA Pro
Now that we understand this basic process-injection technique, let's proceed to the next 
ones.
Process hollowing
The second of the three techniques we will discuss here is called process hollowing. 
This is another common way to run malicious code within the memory address space of 
another process, but in a slightly different way from classic DLL injection. This injection 
technique lets us create a legitimate process within the operating system in a SUSPENDED 
state, hollow out the memory content of the legitimate process, and replace it with 
malicious content followed by the matched base address of the hollowed section. This way, 
even knowledgeable Windows users will not realize that a malicious process is running 
within the operating system.
Here are the API function calls used to perform the process-hollowing injection 
technique:
• CreateProcess: This function creates a legitimate operating system process 
(such as notepad.exe) in a suspended state with a dwCreationFlags 
parameter.
Antivirus bypass using process injection     73
• ZwUnmapViewOfSection/NtUnmapViewOfSection: Those Native API 
functions perform an unmap for the entire memory space of a specific section of a 
process. At this stage, the legitimate system process has a hollowed section, allowing 
the malicious process to write its malicious content into this hollowed section.
• VirtualAllocEx: Before writing malicious content, this function allows us to 
allocate new memory space.
• WriteProcessMemory: As we saw before with classic DLL injection, this 
function actually writes the malicious content into the process memory.
• SetThreadContext and ResumeThread: These functions return the context to 
the thread and return the process to its running state, meaning the process will start 
to execute.
In the following screenshot, you can see a malware that is using process hollowing in IDA 
Pro view:
Figure 4.15 – The first three Windows API calls of process hollowing in IDA Pro
74     Bypassing the Dynamic Engine
The preceding screenshot shows the first three Windows API calls. The following 
screenshot shows the last four of these:
Figure 4.16 – The last four Windows API calls of process hollowing in IDA Pro
Process hollowing used to be an effective method to bypass antivirus software, but today's 
antivirus engines will detect it relatively easily. Let's continue with the last process-
injection example.
Antivirus bypass using process injection     75
Process doppelgänging
The third—and last—technique that we will explain in this book is called process 
doppelgänging. This fascinating process-injection technique is mostly used to bypass 
antivirus engines and can be used to evade some memory forensics tools and techniques.
Process doppelgänging makes use of the following Windows API and Native API 
functions:
• CreateFileTransacted: This function creates or opens a file, file stream, or 
directory based on Microsoft's NTFS-TxF feature. This is used to open a legitimate 
process such as notepad.exe.
• WriteFile: This function writes data to the destined injected file.
• NtCreateSection: This function creates a new section and loads the malicious 
file into the newly created target process.
• RollbackTransaction: This function ultimately prevents the altered executable 
(such as notepad.exe) from being saved on the disk.
• NtCreateProcessEx, RtlCreateProcessParametersEx, 
VirtualAllocEx, WriteProcessMemory, NtCreateThreadEx, 
NtResumeThread: All of these functions are used to initiate and run the altered 
process so that it can perform its intended malicious activity.
In the following screenshot, you can see a PE file that is using process doppelgänging in 
IDA Pro view:
Figure 4.17 – The first two Windows API calls of process doppelgänging 
76     Bypassing the Dynamic Engine
The preceding screenshot shows the first two Windows API calls. The following 
screenshot shows the last two of these:
Figure 4.18 – The last two Windows API calls of process doppelgänging 
Based on a study presented in 2017 by Tal Liberman and Eugene Kogan, Lost in 
Transaction: Process Doppelgänging (https://www.blackhat.com/docs/
eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-
Doppelganging.pdf), the following table shows that the process doppelgänging 
process-injection technique succeeded in evading all of the listed antivirus software:
Antivirus bypass using process injection     77
Table 4.1 – Bypassed antivirus software using process doppelgänging  
Now that we have finished explaining about the three techniques of process injection, let's 
understand how threat actors use process injection as part of their operations.
Process injection used by threat actors
Over the years, many threat actors have used a variety of process-injection techniques, 
such as the following advanced persistent threat (APT) groups:
• APT 32 (https://attack.mitre.org/groups/G0050/)
• APT 37 (https://attack.mitre.org/groups/G0067/)
• APT 41 (https://attack.mitre.org/groups/G0096/)
• Cobalt Group (https://attack.mitre.org/groups/G0080/)
• Kimsuky (https://attack.mitre.org/groups/G0094/)
• PLATINUM (https://attack.mitre.org/groups/G0068/)
• BRONZE BUTLER (https://attack.mitre.org/groups/G0060/)
78     Bypassing the Dynamic Engine
In the past, many types of malware created by APT groups made use of basic injection 
techniques, such as those described here, to hide themselves from users and from 
antivirus software. But since these injection techniques have been signed by antivirus 
engines, it is no longer practical to use them to perform antivirus software bypass.
Today, there are more than 30 process-injection techniques, some of which are better 
known than others.
Security researchers are always trying to find and develop new injection techniques, 
while antivirus engines try to combat injection mainly using the following two principal 
methods:
1. Detecting the injection at a static code level—searching for specific combinations of 
functions within the compiled code even before execution of the file.
2. Detecting the injection at runtime—monitoring processes within the operating 
system to identify when a particular process is attempting to inject into another 
process (a detection that will already raise an alert at the initial handle operation on 
the target victim process).
In November 2019, we published a poster containing 17 different injection types, with 
relevant combinations of functions for each injection type. This was aimed at helping 
security researchers investigate, hunt for, and classify malware by injection type, as well as 
to help security researchers and antivirus developers perform more efficient detection of 
injection types.
Here is the first part of that poster:
Antivirus bypass using process injection     79
 Figure 4.19 – Hunting Process Injection by Windows API Calls: Part 1 
80     Bypassing the Dynamic Engine
Here is the second part of that poster:
 Figure 4.20 – Hunting Process Injection by Windows API Calls: Part 2 
Now that we know about process injection, we will move on to learning the second bypass 
technique we used during our research: antivirus bypass using a DLL.
Antivirus bypass using a DLL     81
Antivirus bypass using a DLL
A DLL is a library file containing number of functions (sometimes hundreds or more) that 
are, as the name suggests, dynamically loaded and used by Windows PE files.
DLL files either include or actually export Windows and Native API functions that are 
used or imported by PE executables. Those DLLs are used by various programs such as 
antivirus software programs, easing development by letting coders call a wide range of 
prewritten functions.
To understand better what a DLL file is, as well as any other PE-based file types, it is 
important to understand the PE file format.
PE files
PE files play an important role in the Windows operating system. This file format is used 
by executable binary files with the .exe extension as well as by DLLs with the .dll 
extension, but those are not only the file types using this versatile file format. Here are a 
few others:
• CPL: Base file for control panel configurations, which plays a basic and important 
role in the operating system. An example is ncpa.cpl, the configuration file of the 
network interfaces available on Windows.
• SYS: System file for Windows operating system device drivers or hardware 
configuration, letting Windows communicate with hardware and devices.
• DRV: Files used to allow a computer to interact with particular devices.
• SCR: Used as a screen saver—used by the Windows operating system.
• OCX: Used by Windows for ActiveX control for purposes such as creating forms and 
web page widgets.
• DLL: Unlike with EXE files, DLL files cannot be run on the hard drive by double-
clicking on them. Running a DLL file requires a host process that imports and 
executes its functions. There are a few different ways to accomplish this. 
As with many other file formats (Executable Linkable Format (ELF) and Mach Object 
(Mach-O) files, to name but a few), the PE file format structure has two main parts: the PE 
headers, which will include relevant and important technical information about PE-based 
files, and the PE sections, which will include the PE file content. Each one of the sections 
will serve a different goal in PE files.
82     Bypassing the Dynamic Engine
PE file format structure
The following diagram demonstrates the structure of a mmmArsen.exe file:
Figure 4.21 – The PE structure
Let's look at PE headers.
PE headers
Here is an explanation of each one of the PE headers:
• Disk Operating System (DOS) header—An identifier or magic value to identify PE 
files.
• DOS stub—An old message that still remains in most PE files. It will likely say This 
program cannot be run in DOS mode and will sometimes be manipulated 
in order to bypass antivirus software.
• PE header—This header basically declares that a file is in the PE file format.
• Optional header—This will include variable information such as the size of 
the code, the entry point of the executable/library file, the image base, section 
alignment, and more.
• Sections table—This is a reference table for each one of the PE sections.
Antivirus bypass using a DLL     83
PE sections
Here is an explanation of each one of the PE sections:
• Code section—This section will include the machine code of the program 
(compiled code) that the central processing unit (CPU) will eventually execute.
• Imports section—This section will include needed functions, which are imported 
from DLLs such as Kernel32.dll and Ntdll.dll.
• Data section—This section will include the variables and function parameters that 
will be used by the program.
The execution
The first option is to use rundll32.exe, which allows the execution of a function 
contained within a DLL file using the command line. For example, to run the entry point 
with a single argument, we can use the following syntax:
RUNDLL32.EXE , 
As an example, the following screenshot demonstrates a DLL running under rundll32.
exe with an non existent function name:
Figure 4.22 – Hello World DLL running using rundll32.exe
84     Bypassing the Dynamic Engine
A second way to execute DLL files is by loading the file into an EXE file using the 
LoadLibrary()/LoadLibraryEx() functions. When an EXE file uses the 
LoadLibrary() function, it passes the name of the module as a parameter, as follows:
Figure 4.23 – LoadLibraryA() Windows API function from Microsoft Developer Network (MSDN)
Only once this is done can the DLL file be run within the EXE file that called it.
Many hackers take advantage of this mechanism for the following reasons:
• DLL files are usually hidden from the ordinary user.
• When a DLL loads inside another process, that DLL has access to the process 
memory space of the process loading the DLL.
• It is much more difficult to perform automatic dynamic analysis on a DLL than on 
an EXE file.
• When a DLL is loaded to a process it is more difficult to find the DLL inside the 
system processes, and thus this makes life harder for antivirus detection and for 
incident response.
Now that we know about how it is possible to bypass antivirus software with a DLL, we 
will move on to learning the third bypass technique we used during our research: antivirus 
bypass using timing-based techniques.
Antivirus bypass using timing-based techniques     85
Antivirus bypass using timing-based 
techniques
In order to sell security products, antivirus vendors have to emphasize two central 
characteristics, as follows:
• High level of detection—Protecting the user from threats
• User-friendly—Comfortable user interface (UI), clear images, fast scans, and more
For example, we can look at a particular endpoint that has about 100,000 files. If we were 
to demand maximum detection from antivirus software, scanning all of those 100,000 files 
could take a few days—and, in a few cases, even longer. This is an extreme demand that 
antivirus vendors cannot possibly meet, and are not supposed to.
In order to avoid this kind of situation, antivirus vendors do everything possible to 
maximize wait time during a scan, even if this means that at best, detection is less precise, 
or at worst, that malware is not detected at all.
Antivirus vendors prefer to scan about 100,000 files in 24 minutes, with a detection rate 
of about 70%, over scanning the same number of files in 24 hours, with a detection rate 
of around 95%, and it is precisely this preference that attackers and researchers can take 
advantage of to avoid detection and, in fact, to conduct antivirus bypass.
There are a few techniques we can use as part of timing-based bypass. In this book, we 
will explain two main techniques. The first technique will utilize Windows API calls that 
cause the malware not to reach its malicious functionality within a short time. The second 
technique causes the malware to take a long time loading, thus causing the antivirus 
software to give up on continuing the malware scan and to conclude that it is an innocent 
file.
Windows API calls for antivirus bypass
The two Windows API calls we will address in this chapter are Sleep() (https://
docs.microsoft.com/en-us/windows/win32/api/synchapi/
nf-synchapi-sleep) and GetTickCount() (https://docs.microsoft.
com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-
gettickcount).
86     Bypassing the Dynamic Engine
In the past, malware authors used the Sleep() function to cause the malware to delay 
executing its malicious functionality for a few seconds, minutes, hours, or even days. That 
way, it could avoid detection by conducting anti-analysis, to harden the life for antivirus 
software and malware analysts.
But today, when—for example—a static engine of an antivirus software detects the 
Sleep() function in a file, the engine causes its emulator to enter the function and run 
the file for the length of time assigned by its function.
For example, if the static engine detects the Sleep() function with a 48-hour delay, the 
antivirus emulator will perform emulation on the file, making it think that 48 hours have 
passed, thus bypassing its "defense" mechanism.
That is the main reason that the Sleep() function is not really applicable today for 
antivirus bypass. So, in order to use the timing-based bypass technique, we have to use 
other functions—functions such as GetTickCount().
The GetTickCount() function is not passing any parameters but returns the amount of 
time the operating system has been up and running, in milliseconds (ms). The maximum 
amount of time the function can return is 49.7 days.
Using this function, a malware identifies how long the operating system has been running 
and decides when the best time is to run its malicious functions and—of course—whether 
it is advisable to execute them at all.
The following screenshot illustrates the Sleep() function within a PE file:  
Antivirus bypass using timing-based techniques     87
Figure 4.24 – Sleep() function in a PE file
88     Bypassing the Dynamic Engine
The following screenshot shows an al-khaser.exe file (https://github.com/
LordNoteworthy/al-khaser) that uses the Sleep() and GetTickCount() 
functions to identify whether time has been accelerated:
Figure 4.25 – GetTickCount() function in a PE file
The following screenshot shows the number of keylogger detections after using the 
GetTickCount() function:
Figure 4.26 – Malicious file that is detected by 3/70 antivirus vendors
Here is a list of antivirus vendors that did not detect the keylogger file:
• Avast