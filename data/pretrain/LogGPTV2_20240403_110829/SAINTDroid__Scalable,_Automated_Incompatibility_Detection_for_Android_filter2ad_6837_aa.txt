title:SAINTDroid: Scalable, Automated Incompatibility Detection for Android
author:Bruno Vieira Resende e Silva and
Clay Stevens and
Niloofar Mansoor and
Witawas Srisa-an and
Tingting Yu and
Hamid Bagheri
University of Nebraska - Lincoln
DigitalCommons@University of Nebraska - Lincoln
Computer Science and Engineering: Theses,
Dissertations, and Student Research
Computer Science and Engineering, Department of
4-2019
GAINDroid: General Automated Incompatibility
Notifier for Android Applications
Bruno Vieira Resende e Silva
University of Nebraska-Lincoln, PI:EMAIL
Follow this and additional works at: https://digitalcommons.unl.edu/computerscidiss
Part of the Computer Engineering Commons, and the Computer Sciences Commons
Vieira Resende e Silva, Bruno, "GAINDroid: General Automated Incompatibility Notifier for Android Applications" (2019).
Computer Science and Engineering: Theses, Dissertations, and Student Research. 167.
https://digitalcommons.unl.edu/computerscidiss/167
This Article is brought to you for free and open access by the Computer Science and Engineering, Department of at DigitalCommons@University of
Nebraska - Lincoln. It has been accepted for inclusion in Computer Science and Engineering: Theses, Dissertations, and Student Research by an
authorized administrator of DigitalCommons@University of Nebraska - Lincoln.
GAINDROID: GENERAL AUTOMATED INCOMPATIBILITY NOTIFIER FOR
ANDROID APPLICATIONS
by
Bruno Vieira Resende e Silva
A THESIS
Presented to the Faculty of
The Graduate College at the University of Nebraska
In Partial Fulﬁlment of Requirements
For the Degree of Master of Science
Major: Computer Science
Under the Supervision of Hamid Bagheri
Lincoln, Nebraska
April, 2019
GAINDROID: GENERAL AUTOMATED INCOMPATIBILITY NOTIFIER FOR
ANDROID APPLICATIONS
Bruno Vieira Resende e Silva, M.S.
University of Nebraska, 2019
Adviser: Hamid Bagheri
With the ever-increasing popularity of mobile devices over the last decade,
mobile apps and the frameworks upon which they are built frequently change.
This rapid evolution leads to a confusing jumble of devices and applications
utilizing differing features even within the same framework. For Android apps
and devices, representing over 80% of the market share, mismatches between the
version of the Android operating system installed on a device and the version
of the app installed, can lead to several run-time crashes, providing a poor user
experience.
This thesis presents GAINDroid, an analysis approach, backed with a class-
loader based program analyzer, that automatically detects three types of mis-
matches to which an app may be vulnerable across versions of the Android API
it supports. Unlike all prior techniques that focus on identifying a particular
problem, such as callback APIs issues, GAINDroid has the potential to greatly in-
crease the scope of the analysis by automatically and effectively analyzing various
sources of incompatibilities that may lead an app to crash at run-time. We applied
GAINDroid to 3,590 real-world apps and compared the results of our analysis
against state-of-the-art tools. The experimental results demonstrate its ability to
outperform the existing analysis techniques in terms of both the number and type
of mismatches correctly identiﬁed as well as run-time performance of the analysis.
Table of Contents
List of Figures
List of Tables
1 Introduction
2 Background
2.1 Android API Background . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 API Compatibility Issues . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.1 API invocation mismatch . . . . . . . . . . . . . . . . . . . . .
2.2.2 API callback mismatch . . . . . . . . . . . . . . . . . . . . . . .
2.3 Permission-induced Compatibility Issues . . . . . . . . . . . . . . . .
iii
v
vi
1
5
5
6
7
8
9
3 Approach
12
3.1 API Usage Extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.2 Database Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.3 Permissions Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
3.4 Mismatch Detection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
4 Empirical Evaluation
22
4.1 Objects of Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
4.2 Variables and Measures
. . . . . . . . . . . . . . . . . . . . . . . . . . 25
iv
Independent Variables . . . . . . . . . . . . . . . . . . . . . . . 25
4.2.1
4.2.2 Dependent Variables . . . . . . . . . . . . . . . . . . . . . . . . 26
4.2.3
Study Operation . . . . . . . . . . . . . . . . . . . . . . . . . . 26
4.3 Threats to Validity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
5 Results
28
5.1 RQ1: Accuracy .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
5.2 RQ2: Real-World Applicability . . . . . . . . . . . . . . . . . . . . . . 34
5.3 RQ3: Performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
.
6 Discussion
7 Related Work
8 Conclusion and Future Work
Bibliography
41
43
48
51
v
List of Figures
2.1 Mismatch between app and device API level
. . . . . . . . . . . . . . . .
7
3.1 Architectural Overview of GAINDroid . . . . . . . . . . . . . . . . . . . 13
5.1 Scatter plot representing analysis time for compatibility checking of
Android apps using GAINDroid . . . . . . . . . . . . . . . . . . . . . . . 38
5.2 Number of classes loaded by GAINDroid and CiD when analyzing
real-world Android apps.
. . . . . . . . . . . . . . . . . . . . . . . . . . . 39
5.3 Amount of memory used by GAINDroid and CiD when analyzing
real-world Android apps.
. . . . . . . . . . . . . . . . . . . . . . . . . . . 40
vi
List of Tables
2.1 Types of mismatch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
4.1 Basic Characteristics of Objects of Analysis . . . . . . . . . . . . . . . .
. 24
5.1 Effectiveness and Efﬁciency of GAINDroid . . . . . . . . . . . . . . . . . 29
5.2 Time comparison between GAINDroid . . . . . . . . . . . . . . . . . . . 37
7.1 Comparing GAINDroid to the state-of-the-art of compatibility detection
techniques. .
.
.
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
1
Chapter 1
Introduction
Android is the leading mobile operating system representing over 80% of the
market share [4]. The rapid rise of Android is largely due to its vibrant app
market [12], which currently contains nearly three million apps, with thousands,
are added and updated on a daily basis. Android apps are developed using an
application development framework (ADF) that ensures apps devised by a wide
variety of suppliers can interoperate and coexist in the same environment. An ADF
exposes well-deﬁned application programming interfaces (APIs) that encapsulate
a series of commands that directly access resources from the Android operating
system and hardware. In this fashion, developers can devote their effort only
to develop apps using the provided APIs, instead of deeply understanding the
operating system or hardware.
The Android ADF evolves frequently, with hundreds of releases from multiple
device vendors since the birth of Android in 2008 [27]. Such a rapid evolution
witnessed in the Android ADF can lead to various incompatibilities in the Android
apps that target a speciﬁc version of the Android operating system but run on
older or newer versions of it. As a result, defects and vulnerabilities, especially
after ADF updates, have continued to plague the dependability and security of
the Android devices and their apps [54, 58]. A recent study shows that 23% of
2
Android apps behave differently after a framework update, and around 50% of the
Android updates have caused previously working apps to fail or rendered systems
unstable [45]. This type of dependability concern has been referred to as “death
on update” [33, 39, 36, 64, 47, 69].
In addition, the launch of Android ADF version 6 (API level 23) introduced
a dynamic permission system, which may lead to a new class of incompatibility
issues. In the prior versions, the permission system was entirely static, where
the user should grant permissions requested by an app during the app’s installa-
tion, otherwise the installation would be canceled. The new permission system
instead allows users to give permissions dynamically, allowing only the access
to resources he/she thinks is safe, at run-time [19]. There are two common ways
that compatibility issues can arise; (i) when an app targets an API level of 23 or
higher and it does not appropriately implement mechanisms to support run-time
dangerous permissions; and (ii) when any app using dangerous permissions is
targeting API-level of 22 or below and is installed on devices with the API-level of
23 or higher.
Recent efforts in the literature have studied compatibility issues [46, 67, 68].
However, existing compatibility detection techniques target only certain types of
APIs. For example, work by Huang et al. [46] only targets callback APIs related
lifecycles; generically identifying them requires signiﬁcant manual labor [46] as
well as thorough inspection of incomplete documentations [68]. Approaches pre-
sented in [51, 44] also target misuse of the Android API. However, they speciﬁcally
target mismatched regarding API invocation. In other words, when an API method
is invoked within the code but the current Android platform does not support
the referred method. Problems related to the permission mechanism have also
been targeted [61, 60]. However, those techniques are speciﬁc for the interaction
3
between wearable apps with the same mobile app, only verifying if both apps
have shared the same set of permissions. Furthermore, none of the state-of-the-
art techniques consider incompatibilities due to the dynamic permission system,
introduced in Android level 23. Meanwhile, the state-of-the-art compatibility
detection techniques suffer from acknowledged frequent ’false alarms’, because
of the coarse granularity at which they capture API information. With the lack of
proper support for detecting compatibility issues, it may take a long time to isolate
and repair such issues. It has been shown that a large portion of faults reported
after an Android ADF release was not addressed for more than six months [65].
In this thesis, we present GAINDroid (General, Automated Incompatibility
Notiﬁer for AndDROID), that automatically detects mismatches regarding the use
of Android APIs and the permission-induced compatibility issues. Unlike all prior
techniques that focus on identifying a particular problem, such as callback APIs
issues, our approach has the potential to greatly increase the scope of the analysis
by automatically and effectively analyzing three sources of incompatibilities that
may lead an app to crash at run-time.
We present results from experiments on 3,590 real-world apps (including
benchmark apps used to validate state-of-the-art tools), validating GAINDroid’s
ability in (1) effective perform compatibility analysis of Android apps, that many
of those reported issues cannot be even detected by the state-of-the-art analysis
techniques; and (2) outperforming other compatibility detection tools also in terms
of scalability. The rest of this thesis is organized as follows. Chapter 2 presents
essential background information about run-time errors in Android. Chapter 3
describes our approach to identify potential mismatches. Chapter 4 describes our
empirical evaluation. Chapter 5 answers the three research questions about our
approach. Chapter 6 provides an additional discussion of our results. Chapter 7
describes related work. Finally, chapter 8 discusses future work and concludes this
thesis.
4
5
Chapter 2
Background
In this section, we provide background information related to the Android API
and motivating examples that demonstrate the need for building a technique that
can effectively identify general API compatibility issues. We also describe three
types of API and permission-related compatibility issues, summarized in Table 2.1,
with illustrative examples.
Table 2.1: Types of mismatch
Mismatch type
API invocation
(App → Android)
(Android → App)
API callback
Permissions
APC
App Device
level
Abbr Compatibility level
≥ α
API
< α
≥ α
< α
≥ α
< α
≥ α
< α
≥ 23 ≥ 23
< 23 ≥ 23
Backward
Forward
Backward
Forward
PRM
N/A
Forward
Mismatch if
app invokes API method
introduced/updated in α
app overrides API callback
introduced/updated in α
app misuses runtime
permission checking
2.1 Android API Background
As of November 2018, there are 16 releases of the Android API and the most recent
is Android Pie (supporting API level 28) [38]. Each version contains new and
updated methods to improve performance and security, and to make new features
and resources available for developers so they can enhance the user experience of
6
the app. In this work, we mainly refer to each release of the Android API by its API
level (e.g., 26) rather than the associated name (Oreo) or Android version number
(8.0) [6]. Developers use the provided APIs to access the core functionalities of
the platform in order to create an application. Google strongly recommends that
developers specify the range of the API levels that it can support in the manifest
ﬁle or Gradle ﬁle by specifying a value for three speciﬁc attributes:
• minSdkVersion: The earliest level of the API supported by the app. If this
attribute is not set, the app can be installed on a device running any API
level.
• targetSdkVersion: The targeted level of the API, against which the app was
developed.
• maxSdkVersion: The most recent supported level of the API. According to
the Google documentation, declaring this attribute is not recommended [25]
but installing an older app on a newer device may still lead to unexpected
behavior [58].
2.2 API Compatibility Issues
As previously mentioned, incompatible API levels can cause run-time crashes in
Android apps installed on a device running a different level of the API than that
targeted by the app. Changes to the API are generally additive, so most such
crashes stem from a lack of backward-compatibility, where an app is targeting a
higher API level but, installed on a device running a lower one [25]. For example,
in Figure 2.1, in the spectrum of device SDK version, the app would work ﬂawlessly
on devices with Android framework as the same astargetSdkVersion but, when
7
Figure 2.1: Mismatch between app and device API level
installed on devices with older versions of the system (in the ﬁrst red area), apps
would crash. However, despite Google’s assurances, there may also be issues with
f orward-compatibility when an app is installed on devices with a higher API level
than the app’s target (the second red area in Figure 2.1). If the app invokes a
method or overrides a callback introduced in a newer level of the API than that
supported by the device or removed in a newer level of the API than targeted by
the app, there would be a mismatch, which could potentially crash the app.
We divide these API incompatibilities into two types, as shown in Table 2.1:
invocation mismatches, where an app attempts to directly invoke an API method
that is not supported by the device; and callback mismatches, where an app
implements a callback method missing from the API level installed on the device,
which the Android system on the device will never invoke.