# Automatic Patch-Based Exploit Generation is Possible: Techniques and Implications

**Authors:**  
David Brumley, Pongsin Poosankam, Dawn Xiaodong Song, Jiang Zheng

**Affiliations:**  
- David Brumley, Pongsin Poosankam: Carnegie Mellon University
- Dawn Song: UC Berkeley & CMU
- Jiang Zheng: U. Pittsburgh

**Emails:**  
- {dbrumley, ppoosank}@cs.cmu.edu
- PI:EMAIL (for Dawn Song and Jiang Zheng)

**Abstract:**

The problem of automatic patch-based exploit generation (APEG) involves generating an exploit for a potentially unknown vulnerability in a program \(P\) given its patched version \(P'\). In this paper, we present techniques for APEG and demonstrate their effectiveness by automatically generating exploits for five Microsoft programs based on patches provided via Windows Update. While our techniques may not be universally applicable, the conservative estimation of attacker capabilities suggests that APEG should be considered practical. Our results highlight a critical security implication: current patch distribution schemes, such as Windows Update, which stagger patch distribution over extended periods, may allow early recipients of the patch to compromise a significant number of vulnerable hosts before they receive the patch.

## 1. Introduction

Releasing a patch to address a vulnerability is generally seen as beneficial for security. However, the entire timeline of patch distribution must be considered. A new patch can reveal information about the vulnerability, and early access to a patch can provide advantages to attackers. From a security perspective, it is important to understand:
- The information about the vulnerability revealed by the patch.
- How quickly this information can be derived from the original and patched programs.
- The advantage this information provides to attackers.

Previous work, such as fuzz testing, has not addressed these questions. The APEG problem is defined as: given a program \(P\) and its patched version \(P'\), automatically generate an exploit for the vulnerability in \(P\) that is fixed in \(P'\). To our knowledge, APEG has not been previously demonstrated in public literature.

In this paper, we show that APEG is feasible through experiments with five recently patched Windows programs. We do not claim that our techniques work in all cases, but the conservative assumption in security is to estimate the capabilities of attackers. Under this assumption, APEG should be considered practical, and those who have received a patch should be considered to have the capability to create an exploit.

One significant consequence of our findings is that having early access to a patch provides a substantial advantage over those who do not. This is particularly relevant given current patch distribution practices, which often stagger patch release over hours or days. For example, Gkantsidis et al. [18] show that it takes about 24 hours for 80% of unique IP addresses to check for a new patch via Windows Update. In our experiments, we generate exploits from a patch in just a few minutes. Modern threats, such as the Slammer worm, have shown that once an exploit is available, most vulnerable hosts can be compromised within minutes [27]. Therefore, our results suggest that early recipients of a patch could potentially compromise a large number of vulnerable hosts before they receive the patch.

### Input Validation Vulnerabilities

We focus on input validation vulnerabilities where the set of inputs accepted by \(P\) is a superset of the safe inputs for \(P\). Figure 1 illustrates this concept, where the set difference between all inputs and safe inputs represents the set of exploit inputs. Common types of vulnerabilities, such as buffer overflows, integer overflows, and heap overflows, are fundamentally input validation issues.

Figure 2 shows a typical integer overflow input validation vulnerability. This example is based on a real-life vulnerability in Internet Explorer (DSA SetItem). The set of inputs that are exploits in this example is \(2^{32} - 3 \leq \text{input} \leq 2^{32} - 1\). The patched program \(P'\) adds a check for overflow on line 5, which any exploit for \(P\) will fail.

### Challenges

One challenge for APEG is that software is often only available in binary form. Our approach targets the case where both \(P\) and \(P'\) are binary code. Addressing APEG for libraries is important because library vulnerabilities can be exploited by multiple programs, and many security updates target libraries. Another challenge is isolating the changes between \(P\) and \(P'\). Tools like binDiff [33] and EBDS [13] help identify changed instructions, but it is insufficient to simply locate these changes. APEG requires constructing real inputs that exploit the vulnerability in the original unpatched program.

### Approach Overview

Our approach to APEG is based on the observation that input validation bugs are typically fixed by adding missing sanitization checks. These added checks in \(P'\) indicate where the vulnerability exists and under what conditions an input may exploit it. Our goal is to:
1. Identify the added checks in \(P'\).
2. Automatically generate inputs that fail these checks.

Execution paths in \(P'\) that fail the new checks are called exploitable paths. We propose three approaches:
- A dynamic analysis approach that considers one path at a time.
- A static approach that encompasses multiple paths without enumerating them individually.
- A combined approach using both dynamic and static analysis.

### Results Overview

To evaluate our approach, we conducted experiments with five Microsoft programs, each with a serious security vulnerability that was fixed by a patch. In some cases, the vulnerabilities were widely exploited, indicating the potential impact of future automatically generated exploits. Our results show that each of the three proposed approaches has strengths for different vulnerabilities. We were able to generate exploits, usually within a few minutes, with the fastest end-to-end time being under 30 seconds. In cases where a public proof-of-concept exploit was available, the exploits we generated were often different. We also demonstrated the ability to generate polymorphic exploit variants and exploits for vulnerabilities with no previously published exploit.

### Contributions

This paper demonstrates that APEG is practical and should be considered in the design of current patch distribution architectures. We propose several research directions for rethinking patch distribution. APEG is also useful for security practitioners, as it can help vendors prioritize bug fixes. Our techniques, based on a mix of dynamic and static analysis, are likely to be of independent interest in the field of automatic test case generation.

---

**Note:** The text has been revised for clarity, coherence, and professionalism. The structure and content have been refined to better convey the key points and contributions of the research.