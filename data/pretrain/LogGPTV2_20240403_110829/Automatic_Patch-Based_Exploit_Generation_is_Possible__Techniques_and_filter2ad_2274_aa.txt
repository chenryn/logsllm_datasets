title:Automatic Patch-Based Exploit Generation is Possible: Techniques and
Implications
author:David Brumley and
Pongsin Poosankam and
Dawn Xiaodong Song and
Jiang Zheng
2008 IEEE Symposium on Security and Privacy
Automatic Patch-Based Exploit Generation is Possible:
Techniques and Implications
David Brumley, Pongsin Poosankam
{dbrumley,ppoosank}@cs.cmu.edu
Dawn Song
Jiang Zheng
PI:EMAIL PI:EMAIL
∗
Carnegie Mellon University
UC Berkeley & CMU
U. Pittsburgh
Abstract
The automatic patch-based exploit generation prob-
lem is: given a program P and a patched version of the
program P ′, automatically generate an exploit for the
potentially unknown vulnerability present in P but ﬁxed
in P ′.
In this paper, we propose techniques for auto-
matic patch-based exploit generation, and show that our
techniques can automatically generate exploits for 5 Mi-
crosoft programs based upon patches provided via Win-
dows Update. Although our techniques may not work
in all cases, a fundamental tenant of security is to con-
servatively estimate the capabilities of attackers. Thus,
our results indicate that automatic patch-based exploit
generation should be considered practical. One impor-
tant security implication of our results is that current
patch distribution schemes which stagger patch distri-
bution over long time periods, such as Windows Update,
may allow attackers who receive the patch ﬁrst to com-
promise the signiﬁcant fraction of vulnerable hosts who
have not yet received the patch.
1 Introduction
At ﬁrst glance, releasing a patch that addresses a vul-
nerability can only beneﬁt security. We must, however,
consider the entire time line for patch distribution. A
∗This material is based upon work partially supported by the Na-
tional Science Foundation under Grants No. 0311808, No. 0433540,
No. 0448452, No. 0627511, and CCF-0424422. Partial support was
also provided by the U.S. Army Research Ofﬁce under the Cyber-TA
Research Grant No. W911NF-06-1-0316, and under grant DAAD19-
02-1-0389 through CyLab at Carnegie Mellon. The views and con-
clusions contained here are those of the authors and should not be
interpreted as necessarily representing the ofﬁcial policies or endorse-
ments, either expressed or implied, of ARO, NSF, or the U.S. Gov-
ernment or any of its agencies. This work was also supported in part
by the Korean Ministry of Information and Communication and the
Korean Institute for Information Technology Advancement under pro-
gram 2005-S-606-02.
new patch reveals some information, and having early
access to a patch may confer advantages to an attacker.
From a security standpoint, we should consider a) what
information about a potentially unknown vulnerability is
revealed by a patch, b) how quickly that information can
be derived from the original and patched program, and
c) what advantage that information yields to attackers.
No previous work (such as fuzz testing as discussed in
Section 7) has addressed these questions.
The automatic patch-based exploit generation
(APEG) problem is: given a program P and a patched
version of the program P ′, automatically generate
an exploit for the potentially unknown vulnerability
present in P but ﬁxed in P ′. Successful APEG would
demonstrate that attackers could use patches to create
exploits. To the best of our knowledge, APEG has not
been previously demonstrated in public literature. Thus,
the question of whether APEG is feasible for real-world
programs was unanswered.
In this paper, we show that automatic patch-based ex-
ploit generation is possible as demonstrated by our ex-
periments using 5 Windows programs that have recently
been patched. We do not claim our techniques work in
all cases or for all vulnerabilities. However, a fundamen-
tal tenant of security is to conservatively estimate the
capabilities of attackers. Under this assumption, APEG
should be considered practical, and those who have re-
ceived a patch should be considered armed with an ex-
ploit.
One important consequence of our result is that hav-
ing access to a patch confers a signiﬁcant advantage over
those who do not have access to the patch. The secu-
rity advantage is important in light of current patch dis-
tribution practices. Current patch distribution practices
stagger patch distribution, usually over hours, days, or
longer. For example, Gkantsidis et al. show that for
Windows Update it takes about 24 hours for 80% of the
unique observed IPs to check for a new patch [18]. In
978-0-7695-3168-7 /08 $25.00 © 2008 IEEE
DOI 10.1109/SP.2008.17
143
All inputs
Safe Inputs
Figure 1. An input validation vulnerability
occurs when the set of all inputs for P (in
white) is a superset of the set of safe in-
puts for P (in black). The set difference is
the set of exploits for P .
our experiments, we generate exploits from a patch in
only a few minutes. Modern threats such as the Slammer
worm have empirically demonstrated that once an ex-
ploit is available, most vulnerable hosts can be compro-
mised in minutes [27]. Our results therefore imply that
those who ﬁrst receive a patch could potentially com-
promise most remaining vulnerable hosts before they re-
ceive a patch via current patch distribution architectures.
Thus, our work indicates that current patch distribution
schemes that stagger patch roll-out over large time peri-
ods requires rethinking.
Input Validation Vulnerabilities. We target input val-
idation vulnerabilities where the set of inputs accepted
by P is a superset of the safe inputs for P . Figure 1
shows this intuition graphically, where the set of safe
inputs is a subset of all inputs for P . The difference
between the safe and all inputs accepted by P is the
set of exploit inputs. A common approach for patching
such vulnerabilities is to add additional input sanitiza-
tion checks in P ′ so that only safe inputs are processed
without error. Many common types of vulnerabilities are
at core input validation vulnerabilities, such as buffer
overﬂows, integer overﬂows and underﬂows, and heap
overﬂows.
Figure 2 shows a typical integer overﬂow input vali-
dation vulnerability we use throughout this paper. This
example is motivated by a real-life vulnerability in In-
ternet Explorer (called DSA SetItem, for which we gen-
erate an exploit for in Section 4). All integers in this
example are 32-bits, and therefore all arithmetic is per-
formed mod 232. On line 1, the input integer vari-
able is checked to see if it is even: if so, a temporary vari-
able named s is assigned input+2 (mod 232), else if
odd, input+3 (mod 232). Line 6 calls realloc, a
manual memory management routine, which changes
the size of the passed in ptr to point to s allocated bytes
of memory. For example, if s is less than the size cur-
rently pointed to by ptr, then the resulting pointer will
point to a smaller area of memory.
In this example, we consider any input that causes
overﬂow on line 2 or 4 to be an exploit. Thus, the set of
i s a u s e r
i n p u t
i f ( i n p u t %2 == 0 ) g o t o 2 e l s e g o t o 4 ;
s
: = i n p u t + 2 ;
i n p u t
: = i n p u t + 3 ;
: = r e a l l o c ( p t r ,
s ) ;
. . u s e o f p t r
. . . ;
P :
1 .
2 .
3 . g o t o 5 ;
4 .
5 . 
6 . p t r
7 .
s
i n p u t
P ′ :
1 .
2 .
3 . g o t o 5 ;
4 .
5 .
6 . p t r
7 .
s
i f
i s a u s e r
i n p u t
i f ( i n p u t %2 == 0 ) g o t o 2 e l s e g o t o 4 ;
s
: = i n p u t + 2 ;
: = i n p u t + 3 ;
( s > i n p u t ) g o t o 6 e l s e g o t o ERROR ;
: = r e a l l o c ( p t r ,
s ) ;
. . . u s e o f p t r
. . .
Figure 2. Our running example of an inte-
ger overﬂow input-validation vulnerability
in P (top) and the patch P ′ (below). An in-
teger overﬂow may happen on lines 2 or 4
of P . Line 5 of P ′ checks for overﬂow.
inputs which are exploits is 232 − 3 ≤ input ≤ 232 − 1.
At best, any exploit will cause a user of ptr after line
6 to cause a denial of service attack by crashing the pro-
gram, or at worst, allow an attacker to hijack control of
the program (as in the real-life vulnerability that moti-
vated this example). The patched program P ′ adds a
check for overﬂow on line 5. Any input which is an ex-
ploit for P will fail the inserted check in P ′.
Challenges. One challenge for APEG is that software
is often only available in binary (i.e., executable) form.
Thus, in our approach and implementation, we target the
case when P and P ′ are binary code. In our setting, P
and P ′ can be either an executable programs or library.
Addressing APEG for libraries is important since a) li-
brary vulnerabilities may often be exploited by multiple
programs which use the library, and b) on many OSs se-
curity updates are often to libraries. For example, we
conducted a survey of patches released from Microsoft
in 2006 and found 84% of the security-related updates
were changes in libraries. If P is a library, then the gen-
erated exploit x is a valid set of arguments to an exported
(e.g., callable) function in the library, while if P is a pro-
gram, x is an input to the program.
Another challenge is to isolate what changes have oc-
curred between P and P ′. To address this problem, se-
curity practitioners have developed tools, such as bin-
diff [33] and EBDS [13], which ﬁrst disassemble both
P and P ′, and then identify which assembly instruc-
tions have changed. Security practitioners use these dif-
ferencing tools to help manually reverse engineer what
144
the unknown or unpublished vulnerability that a patch
addresses [13, 14, 31, 33], and in some cases, manually
create exploits [14].
However, it is insufﬁcient to simply locate the in-
structions which have changed between P and P ′. In or-
der for APEG to be feasible, one has to solve the harder
problem of automatically constructing real inputs which
exploit the vulnerability in the original unpatched pro-
gram. Further, when feasible, it is important to know the
speed at which exploits can be generated from patches
in order to design adequate security defenses.
Approach Overview. Our approach to APEG is based
on the observation that input-validation bugs are usually
ﬁxed by adding the missing sanitization checks. The
added checks in P ′ identify a) where the vulnerability
exists, and b) under what conditions an input may ex-
ploit the vulnerability. The intuition for our approach is
that an input which fails the added check in P ′ is likely
an exploit for P . Our goal is to 1) identify the checks
added in P ′, and 2) automatically generate inputs which
fail the added checks. In Figure 2, the goal would be
to ﬁrst discover the check added on line 5, then gener-
ate a value for input such that P ′(input) that fails the
check and leads to the ERROR state.
We call execution paths that fail the new check (i.e.,
execute the ERROR state in our example) in P ′ ex-
ploitable paths since any input that would execute such
a path in P ′ is a likely exploit for P . There may be many
exploitable paths, e.g., there are 2 exploitable code paths
in our running example. However, the number of ex-
ploitable paths is typically only a fraction of all possible
execution paths.
We propose techniques which scale when there are
many different possible paths, but potentially only a few
are exploitable. We present three different approaches:
a dynamic analysis approach which considers a single
path at a time, a static approach which encompasses
multiple paths without enumerating them individually,
and a combined approach based upon a combination of
dynamic and static analysis. We show through eval-
uation that each technique is useful for automatically
generating exploits from patches for different real-world
vulnerabilities.
Results Overview. To evaluate the effectiveness of our
approach, we have conducted experiments using 5 pro-
grams from Microsoft. Each program initially had a se-
rious security vulnerability which was ﬁxed by a patch.
In some cases, the vulnerability is widely exploited,
indicating the potential impact of future automatically
generated exploits. Our results also show that each of
the 3 approaches we propose have strengths for different
vulnerabilities. In each case we are able to generate an
exploit, usually within a few minutes. The fastest end-
to-end time we were able to generate a veriﬁable exploit
is under 30 seconds. We believe that with further work
on our research prototype this time could be reduced.
In our evaluation, for the cases when a public proof-
of-concept exploit is available, the exploits we gener-
ate are often different than those publicly described.
We also demonstrate that we can automatically generate
polymorphic exploit variants. Finally, we are able to au-
tomatically generate exploits for vulnerabilities which,
to the best of our knowledge, have no previously pub-
lished exploit.
Contributions. This paper shows that automatically
generating exploits from patches within minutes should
be considered practical. Current patch distribution ar-
chitectures are not designed with the threat of APEG in
mind. We argue that our results imply that we should im-
mediately begin rethinking the design of current patch
distribution architectures, and to this end, we propose
several research directions.
Although we target the case where APEG is used by
an attacker, APEG is also useful for security practition-
ers. For example, since APEG demonstrates a bug is
exploitable, it could be used by vendors to prioritize bug
ﬁxes.
At the core of our approach for automatic patch-
based exploit generation is the ability to generate an in-
put that fails a check at a speciﬁed line of code. Gen-
erating inputs that execute a line of code is also studied
in automatic test case generation. However, existing au-
tomatic test case generation techniques did not work for
several vulnerabilities in our experiments. We propose a
new technique based upon a mix of dynamic and static
analysis to handle these cases. Thus, our techniques are
likely to be of independent interest.
2 Automatic Patch-Based Exploit Genera-
tion: Problem Deﬁnition and Approach
2.1 Background Deﬁnitions
Our techniques are based on methods from the program
veriﬁcation community, thus we adopt their notation in
this paper (such as in [11]). A program deﬁnes a rela-
tionship between an initial state space and a ﬁnal state
space. The state space of a program consists of all vari-
ables and memory. In our setting, memory is modeled
as an array mapping 32-bit integers signifying memory
addresses to 8-bit integers signifying memory values. In
our setting, all registers are modeled as variables, and
each memory cell can also be considered a separate vari-
able when convenient. In Figure 2, the state space con-
sists of memory and the variables s and input. When
desired, we can also distinguish variables by their up-
145
date site, e.g., the variable s on line 2 from s on line
5 (e.g., by transforming the program into static single
assignment form [28]).
A safety policy φ is a ﬁrst-order logic Boolean predi-