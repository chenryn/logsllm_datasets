instruction because a ret instruction indicates the completion of a
function call.
For the value in the sliding window that matches the criteria
above, CREDAL deems it as a valid return address candidate, and
follows the aforementioned steps to pinpoint the crash function.
With the crash function identiﬁed, CREDAL further performs pro-
gram counter recovery. Since memory corruptions manipulate the
program counter through indirect jump instructions (e.g., ret;
532Figure 2: The snapshot of a crashing program after exploiting its overﬂow vulnerability. For simplicity and demonstration, the stack protector has been disabled
and we convert the instruction on a binary into the statement in C programming language.
call EDX), and point it to an invalid memory address, CREDAL
examines indirect jump instructions in the crash function.
In particular, CREDAL ﬁrst uses an intra-procedural Control Flow
Graph (CFG) to identify all the indirect jump instructions reachable
from the instruction corresponding to the candidate return address.
Figure 2 shows an intra-procedural CFG for function crash().
In this CFG, we prune all the direct function calls and cut off cor-
responding connections. The intuition here is that the crashing
stack exhibits a different layout if the crashing function calls an-
other subroutine after the instruction corresponding to the return
address. Again, take the example code shown in Figure 2. The
return address on the crashing stack points to an instruction in crash
function crash(). The CFG within the crash function indicates a
call to function foo2(). If the program invokes function foo2()
and crashes after, the stack frame of function bar() would not be
presented on the crashing stack.
Second, CREDAL veriﬁes the destinations of indirect jump in-
structions identiﬁed on the aforementioned CFG. More speciﬁcally,
CREDAL computes the destination of each indirect jump instruction
using the values of processor registers or memories preserved in the
core dump. Then, CREDAL attempts to match the destination with
the value held in the program counter. When identifying a match,
CREDAL restores the program counter to the address of that indirect
jump instruction and deems it as the crash point. Note that if the
information is incomplete for CREDAL to recover the crash point,
our analysis terminates.
The aforementioned program counter recovery mechanism fol-
lows systematic analysis and veriﬁcation. However, it still intro-
duces uncertainty to crash point identiﬁcation. For example, a
crash function does not invoke any subroutine before the crash, and
CREDAL mistakenly identiﬁes the remnants on the stack as a valid
Figure 3: Stack pointer veriﬁcation. For simplicity and demonstration, the
return address points a line of C programming code converted from the
instruction on a binary.
return address. To minimize such uncertainty, CREDAL further veri-
ﬁes the identiﬁed crash point by checking the displacement of the
stack pointer. Figure 3 shows an example where crash function
crash() does not invoke any subroutines but the stack frame of
an earlier call to bar1() is preserved. Thus, function foo1() is
mistakenly identiﬁed as the crash function. By examining the dis-
placement of the stack pointer before and after the call to bar1(),
however, CREDAL can identify the difference between the expected
and actual stack pointer. As is illustrated in Figure 3, the position
of ESP should be at the bottom and the top of the stack frame of
bar1() at the entry and exit of the function, respectively. Since
there is no other operation to ESP within function foo1(), the
expected position for ESP should remain at the top of the frame of
bar1() at the crash. However, this expectation does not match the
observation from the core dump, which indicates the incorrectness
1// global variable2int glob; 3// global function pointer4int (*glob_func)(int*); 56void bar1(void){7...8foo();9...10}1112void bar2(){13...14foo();15...16}1718void bar(){19...20}2122void foo1(){23...24}2526void foo2(){27...28}2930void sub(){31int x;32…33}34int foo(void){35int a, b, *c, *d;36// local function pointer37void (*local_func)(void); 38char buff[8];39b = 2;40c = &b;41d = &b;42// pointer dereference43*d = 5; 44local_func = &foo1;45glob = 0;46glob_func(c);47a = 1;48// overflow49scanf("%s", buf); 50crash(local_func);51return 1;52}5354int crash(void(*func)(void)){55int aa, bb;56aa = 1;57sub();58bar();59bb = aa + 560…61// crash point (indirect call)62func(); 63// direct call64foo2(); 65...66return 1;67}old EBPabcdlocal_funcbuffuncretold EBPaabbretold EBPCFA of foo()CFA of crash()...CFA of bar()call ;...mov    0x8(%esp),%eax;add    $0x5,%eax;mov    %eax,0xc(%esp);mov    0x8(%ebp),%eax;call   *%eax; #call *funccall   ;mov    $0x1,%eax;leave;ret;Crashing StackVulnerable Code FragmentCFG for crash()ESP...Corrupted Memory Arearetretret............Stack LayoutBefore Calling f2Stack LayoutAfter CrashExpected ESP after a call to bar1Actual ESP1int f0(){2f1();3f2();4}56int foo1(){7int a;8bar1();9a++;10}10int f1(){11foo1();12}1314int f2(){15crash();16}1718int crash(){19/*No subroutines*/20...21}Vulnerable Code Fragmentf0f1foo1bar1f0f2ESP at exitof bar1ESP after prologue of bar1bar1crash533of crash point identiﬁcation. The intuition behind this veriﬁcation
is that the stack frame of the crash function mistakenly identiﬁed
generally does not share the same size as that of the actual crash
function.
With the design discussed above, we believe CREDAL can identify
a crash point with high conﬁdence because it is very unlikely to
bring about the coincidence where (1) the remnants on the crashing
stack are mistakenly deemed as an address that points to a valid
instruction; (2) the instruction above the valid instruction is a call
instruction; (3) an indirect jump in the crash function mistakenly
identiﬁed encloses a destination that happens to share the same value
as the corrupted program counter; (4) the stack frame of the crash
function mistakenly identiﬁed happens to share the same size as that
of the actual crash function. In Section 6, we will demonstrate the
effectiveness and correctness of CREDAL in tracking down a crash
point.
4.3 Identifying Stack Trace
With the crash point identiﬁed, we now discuss how to use it to
track down a stack trace. As is described in Section 3, CREDAL has
the access to the source code of a crashing program. Thus, it can
compile the code with debugging options enabled, and obtain the
call frame information of the crashing program.
The call frame information is typically used for stack unwinding.
Following DWARF standard [18], therefore, CREDAL can “virtu-
ally” unwind a crashing stack and track down a stack trace. As
is discussed in Section 3, data corruption on stack however may
introduce uncertainty to stack unwinding. As a result, CREDAL also
veriﬁes the legitimacy of a stack frame in each step in addition to
following the restored registers to ﬁnd all stack frames.
More speciﬁcally, CREDAL walks the crashing stack and checks
the validity of the return address in each stack frame by following
the criteria discussed in Section 4.2. In addition, CREDAL examines
the allocation of a newly unwound stack frame and ensures it is
laid just on top of the last stack frame successfully identiﬁed. The
intuition here is that the frames on stack should be compactly laid
out but not overlapped. Similar to the approach we leverage in
Section 4.2, CREDAL ﬁnally veriﬁes the size of a newly identiﬁed
stack frame using the displacement of the stack pointer.
As is discussed in the previous section, the design of CREDAL
follows a conservative principle. When “virtually” unwinding a
crashing stack and identifying a stack frame cannot pass the afore-
mentioned veriﬁcation, CREDAL stops the unwinding operation and
produces a partial stack only with the stack frames successfully
identiﬁed. We design CREDAL to conservatively identify stack trace
so that corrupted stacks can also be handled.
In Section 6, we
will demonstrate the correctness of CREDAL in partially (or fully)
identifying a stack trace.
4.4 Discovering Data Dependency Mismatch
As is mentioned above, memory corruption typically incurs data
corruption. If the value of a variable observed in the core dump does
not match any reachable deﬁnition, a data dependency mismatch
is found. Here, we describe how CREDAL pinpoints such a depen-
dency mismatch and highlights the corresponding code fragment.
On a high level, we statically analyze the set of possible values for
each variable on the recovered trace and match the possible values
with the actual value in the core dump. Assuming our analysis on
possible value sets is sound, if the value of a variable indicated by
the core dump falls out of the corresponding value set, a memory
corruption must have occurred.
To obtain such value sets, we perform an inter-procedural reach-
ing deﬁnition analysis with the restored stack trace. As we will
describe in the following presentation, our analysis is conservatively
designed to avoid loss of soundness. Speciﬁcally, our analysis ﬁrstly
constructs an inter-procedural CFG that covers all possible call se-
quences from the entry function to the crash point according to the
recovered stack. As resolving indirect calls may introduce inaccu-
racy, CREDAL skips indirectly called functions (whose targets are
unknown) but preserves their arguments. Although skipping indirect
calls results in a partial CFG, our subsequent analysis will con-
servatively consider the potential effects of these indirectly called
functions, to make the whole analysis sound. Figure 4 illustrates the
CFG corresponding to the example in Figure 2.
To the partial CFG, we apply an intra-procedural points-to analy-
sis to each function, following a context and path insensitive strat-
egy. With the points-to information, we can easily calculate the
reaching deﬁnition in each function. We then populate the intra-
procedural results across function boundaries and extend the re-
sults to the whole CFG. We achieve this using a summary-based
inter-procedural static analysis algorithm (i.e., the "functional ap-
proach") [40]. More speciﬁcally, we capture the effects caused by a
function modifying variables in another function through pointers
passed as arguments. To guarantee the soundness of our results, we
handle indirectly called functions in a conservative manner. To be
speciﬁc, we assume that an indirect call modiﬁes all global variables
and all variables possibly pointed to by the argument. We assume
those variables may equal any value after the indirect call. Take
vulnerable code in Figure 2 for example, our analysis gets rid of
global variable glob and local variable b when analysis reaches
to line 46, since glob_func represents an indirect call which
receives pointer c to local variable b.
After obtaining the reaching deﬁnition results, we deduce the
possible value set for each variable (i.e., value constraints on each
variable). If one deﬁnition can be tracked back to a constant value,
we add the constant to the set. Otherwise, we assume the deﬁni-
tion leads to all possible values. Afterwards we start searching
for corrupted variables in the core dump. Note that CREDAL does
not consider global variables if the crashing program has multi-
threading, because global variables are shared by all threads and
a core dump does not unveil when a global variable was modiﬁed
by other threads. We also do not consider those variables if the
crashing stack does not preserve their values (e.g., variable x in
function sub()). The intuition here is that there is no sufﬁcient
evidence to examine data dependency mismatch if the ﬁnal value of
the variable is unknown.
For a variable of non-pointer type, if its ﬁnal value in the core
dump does not match the value constraints, we determine a depen-
dency mismatch with this variable. Further, we highlight the code
fragment from all the reachable deﬁnitions of this variable to the
crash point in the CFG. Take variable a in Figure 2 for an example.
a has one deﬁnition, namely a = 1 at line 47. The ﬁnal value
of a is corrupted and deviates from 1, thus we catch a mismatch
on a. The code segment is determined as from line 47 to line
50 and line 55 to line 62.
For a variable of pointer type, CREDAL ﬁrst takes it as a normal
non-pointer variable and performs the above check. In addition,
CREDAL searches for another type of dependency mismatch. As-
suming on any path from the ﬁrst function to the crash point on the
CFG, there exists at least one dereference to this pointer without
subsequent re-deﬁnition, the pointer must have been unintentionally
manipulated. The intuition is that if there is no unintended manipu-
lation, the process should have crashed in the previous dereferences.
CREDAL deems this as dependency mismatch on pointer derefer-
ence. Similarly, CREDAL highlights the code fragment from all the
dereferences to the crash point in the CFG.
534Figure 4: An inter-procedural control ﬂow graph and data dependency constraints. Note that scanf() is a call to an external library. For simplicity and
demonstration, we do not unfold this call. The list of constraints deﬁnes data dependency e.g., a@foo=1 indicates variable a in function foo should be equal
to 1 at the crash; d@foo=[valid] indicates pointer d should be valid at the crash.
5.
IMPLEMENTATION
We have implemented a prototype of CREDAL for Linux 32-bit
system, which takes as input a core dump ﬁle as well as the bi-
nary and source code of the corresponding crashing program. As
CREDAL needs debugging information for analysis, our implemen-
tation requires the binary to be compiled with debugging options
(e.g., -g with gcc). In this section, we present some important
implementation details.
Linux operating system organizes a core dump ﬁle in the form of
Executable Linkable Format (ELF). The implementation of CREDAL
employs libelf, an open source library [9] to parse the ﬁle in ELF
and retrieve the corresponding memory information. Considering
CREDAL needs to examine the entire working memory of a crashing
program, and Linux kernel typically does not include ﬁle-backed
mappings in a core dump, our implementation augments libelf
with the ability to interpret the note segment in an ELF ﬁle so that
CREDAL can identify ﬁle-backed memory mappings and consume
the information in that memory area.
CREDAL currently relies on the debug information to disassemble
binaries and unwind crashing stacks. For disassembly, our imple-
mentation uses libdwarf library [6] to parse a binary and then em-
ploys libdisasm library [8] to identify instructions in it. For un-
winding a crashing stack, our implementation relies on libdwarf
library to extract call frame information from .debug_frame and
.eh_frame stored in ELF ﬁles. To perform virtual unwinding, we
also implement CREDAL by modifying libunwind library [10].
As is mentioned in Section 4, CREDAL constructs an intra-procedural
CFG on a binary. However, indirect jump instructions introduce
non-deterministic to the CFG construction. Given instruction [jmp
%EAX], for example, it is difﬁcult to construct the consecutive nodes
on CFG without determining the destination of this instruction. To
address this problem, our implementation uses LLVM [12] to extract
program semantics from source code and identify the destinations
of indirect jump instructions. For example, assume an indirect jump
instruction is a low-level representation of a switch statement in
C programming language. Our implementation employs LLVM
APIs to identify the destinations from those case statements, and
completes CFG construction.
In our design, CREDAL utilizes the displacement of a stack pointer
to verify the crash point and stack trace identiﬁed. To do this,
CREDAL needs to know the change to ESP for a given code frag-
ment. Within the code fragment, there may be a variety of exe-
cution paths that cover the operations of ESP (e.g., [add $0x4,
%ESP], [pop] or [push %EAX]). Theoretically, stack pointer
ESP may end up at different position when going through different
paths. To guarantee the correctness of program execution, a com-
piler however ensures ESP has the same displacement whichever
paths the program walks through. As a result, our implementation
chooses an arbitrary path to compute the displacement of ESP when
verifying a crash point or stack trace.
Our implementation seeks for data dependency mismatches on