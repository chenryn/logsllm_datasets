Static 
and Runtime Overhead 
Although 
the previous 
increase 
static 
different 
tion mechanisms 
they come at 
we present 
cost in relation 
subsection 
the system resiliency 
illustrated that 
in many cases, 
our protec­
and dynamic cost. In the following 
code size and runtime measurements 
to put this 
with the benefits  gained. 
timing 
itself. 
that execute 
exceptions 
corresponds 
timing behavior 
infrequently 
former category 
the pathologic 
invoke the schedule
of benchmarks, 
their real-world 
SYNc2 stands out 
bombards the scheduler 
slower on real hardware. 
machine-dependent  CPU 
overhead, 
in almost 
in 
use case for our 
can be classified 
continuously 
SYNc2, constitutes 
scheme: It continuously 
lead to heavy impact on the runtime 
and execute 
Figure 5 shows that 
into two categories: While some 
r/thread  objects 
ion). The total real-world 
(99.8 %) to the simplistic 
aside from the EXCEPTI benchmark, 
at 2.66 GHz and measured 
(with the RDTSCP CPU instruct
runtime 
accurately 
model of our simulation, 
which triggers 
hundredfold 
the results 
benchmarks 
and therefore 
others access the scheduler 
the same runtime.  The 
particular 
protection 
with accesses and spends almost no time  in 
application 
1 8  times longer for the CRC and SUM+DMR protection 
variants, 57 times for 
Hamming code. B ecause the Hamming protection 
we 
consistently causes an order of magnitude 
to plot this variant. 
omitted 
for 107 clock cycles or longer in Figure 5 -shows way 
-running 
more encouraging 
application 
and scheduler 
the runtime costs stay well  below 
be considered  negligible. 
In conformity 
runtime overhead for 
the whole benchmark 
at only 0.09 % for the SUM+DMR, CRC and CRC+DMR 
protection 
0.23 % and 1 .75 % respectively. 
E. Discussion 
dreaded 
468 times for the 
scheme 
higher overhead, 
that is, a mix of computation, 
invocations. For these long-running 
by TMR and Hamming with 
1  % in most cases and can 
with Amdahl's law, the 
the benchmark 
running around 
idle phases 
benchmarks, 
TMR and even 
The second category 
and test suite totals 
of benchmarks 
extremely, 
variants, 
results. 
followed 
profile, 
These  benchmarks  contain 
a realistic 
the 
have little 
overhead. 
The evaluation 
total runtime 
to offer the best 
shows that, for our set of benchmarks, 
of overhead.  Most 
protec­
the 
Overall, 
costibenefit 
ratio in 
and shows a negligible  slowdown 
mechanism suffices for the use case, the 
EDM/ERMs come at different  levels 
tion mechanisms 
SUM+DMR variant seems 
most cases, 
if a detection-only 
CRC protection 
work fast and efficiently 
case  32 
the Hamming protection, which 
inefficient 
single-bit 
not be used in favor of SUM+DMR and CRC+DMR. 
granularity 
(in our 
at bit level is 
turns out to be by far the most 
-at least when 
choice. TMR has no real  benefit 
and 8-bit-burst 
bit). The only EDM/ERM that operates 
faults are considered -and should 
may be a reasonable 
at machine-word 
choice. 
Both mechanisms 
on real hardware; 
Figure 4 shows the static 
binary sizes of (due to space 
V I .  RELATED WORK 
of variants .  The DATA sections 
of all 
Protecting 
computer 
systems' memories 
500  bytes) 
mostly constant 
and stay constant 
with different 
to  the baseline 
(max. increase compared 
a selection 
are negligibly 
constraints) 
binaries 
tiny (around 
in size; B S S  also  remains 
protection 
is 3 . 6  % ) .  The code  size 
between the different 
by an average 
variants 
TMR: 1 05 %), the Hamming variant 
(TEXT) increases vary extremely 
CRC increases 
the code 
of 58 % (SUM+DMR: 74 %, CRC+DMR: 79 %, 
variants:  While 
costs a whopping 
average 
that there might 
from the mainframe 
concern remaining 
of this problem indicates 
all" solution. Hence,  there  is 
this problem. We classify related 
susceptibility 
hardware-supported 
memory protection. 
analyses of operating 
work  into 
systems 
against 
errors is a 
era. The persist
ence 
be no "one size fits 
a large body of work attacking 
three categories: 
to memory errors, 
memory protection, 
and software
-based 
of 146% .  
Depending 
o n  the benchmark, 
the protected 
code sections 
more or less often, resulting 
are executed 
runtime 
tions on  a contemporary 
overhead. We 
in highly varying 
all variant/benchmark 
combina­
running 
Intel Core i7-M620 notebook 
deployed 
A. Susceptibility 
Errors 
Analyses 
of Operating 
Systems to Memory 
Several 
studies have 
addressed the assessment of operating 
systems in the presence of hardware 
faults .  Already in the 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:00 UTC from IEEE Xplore.  Restrictions apply. 
clock 1 
clockcnv  clock1ruth 
exceptl 
lIagl 
kill 
mqueue1 
1 00  -
50 -
-
OJ  1111111'1 
6  0 -
lB '00 
>. ro c 
ii5 1 00 -
mutex1 
mutex2 
50 -
mutex3 
release  schedl 
sync2 
sync3 
threadO  thread 1  thread2 
Binary 
section 
DATA 
• TEXT 
. BSS 
I  I  I  I  I 
O> U CI: CI: Ol 
  a:     .S 
o> o o l-E 
[!)  =>  I 
(/) 
Fig. 4: Code size of selected 
with Hamming being the most inefficient 
protection 
variant. 
variants : The TEXT segment grows due to additional 
CPU instructions 
for each EDM/ERM, 
bin_sem1 
clockl 
clockcnv 
clocktruth 
cnLsem1 
flag 1 
except 1 
2e+05 - I 
-:::::=-••• 
lG 
:;; 4e+06 
g 3e+06 
C3 2e+06 
'Q;' l e+06 
E 0e+00 
§ 
l e+05- ••• 
Oe+OO -7 I  I  I  I 
 fi     
 o 9 9 1-
m  5 o (/)  
a: :: =  I 
release 
0e+00 
schedl 
8e+09 
6e+09 
4e+09 
2e+09 
Oe+OO 
4e+08 -
2e+08  -
0e+00 -
kill 
sync2 
6e+05 
2e+05  -••• 
4e+05 - I 
2e+05  -
Oe+OO --
sync3 
2e+08 - I 
::::: =_ ••• 
8e+05 
5e+05 
2e+05 
Oe+OO 
I  I  I  I  I 
 0 9 9 1-
m  &?5 o (/)  
ge+ 1 0  -
6e+ 1 0  -
3e+l0  -
l e+O? 
8e+06 
5e+06 
2e+06 
Oe+OO 
2e+05 - I 
:::::=-••• 
mutex3 
2  05 
mutex2 
mutex1 
6e+05 -
Oe+OO -
2e+09  -
5e+09  -
threadO 
4e+05  - 14e+05 - I 
0e+00 - _ ... 0::00 =_ ••• 8e+09  -
:::: =  I 
oe+oo- - ··· 
I  I  I  I  I 
 0 9 9 1-
m  &?5 O (/)  
thread 1 
Oe+OO -
2e+04 -
4e+05 -
6e+05  - I 
2e+05  -••• 
Oe+OO -7 I  I  I  I 
 fi     
 o 9 9 1-
m  5 o (/)  
thread2 
Fig. 5 :  Real-world 
order of 104 to 106 clock cycles) 
runtime, 
measured 
on an Intel Core i7-M620 notebook: 
Eleven out of 2 1  benchmarks 
and continuously 
invoke the operating 
system's scheduler, 
resulting  in 
run very short (in the 
for each 
high overhead 
EDMIERM. These benchmarks 
exhibit 
profile. The scheduler 
flows, so that the runtime costs stay well below 1  % in  most 
a more  realistic  application 
are actually  the 
pathologic 
use case for our protection 
data structures 
scheme. The remaining 
are accessed infrequently  in 
the benchmarks' control 
ten benchmarks 
cases and can be considered 
negligible. 
nineties, Kao et al. [26] inj ected memory faults into the 
kernel address space of a UNIX operating 
Fabre et 
al. [27] performed 
with a 
microkernel 
with a UNIX-like 
the Linux kernel has been analyzed 
ection experiments 
system, and so did Madeira et al. [28] 
operating 
[29], [30]. 
system. More 
real-time 
operating 
fault-inj
system. 
similar 
recently, 
data structure
s, such as Scheduler 
and Thread objects. 
B. Hardware-supported 
Memory Protection 
These studies 
ground on a few thousand 
faults  being  ran­
to millions 
of instructions 
executed 
systems. We doubt their general 
applicability, 
-to the best 
of our knowledge 
-to which extent 
domly injected, compared 
by the operating 
as it is unclear 
statistically 
fault-injection 
the whole  fault 
Moreover, 
significant 
experiment
we provide 
conclusions are drawn  from 
sampled 
in that we cover 
s. Our work 
differs 
space and do not rely on random sampling. 
-system 
insight  into 
particular 
operating
Chipkill 
detection 
of 1 2.5 % .  Commercial 
64 bits of data, yielding 
double-bit-error 
overhead 
rather weak error-correction  scheme 
in tolerating 
multi-bit 
to independent 
energy consumption 
Therefore, 
and memory management 
[31 ] ,  increasing 
4 adjacent bits) by interleaving 
DRAM chips, at the cost of up to 30 % higher 
[8] improves 
this 
word-wise 
a word 
[9], 
up to 1 8 .75 % and 26.5 %. 
hardware modifications 
units (MMU) have been proposed 
due to forced narrow-I/O 
errors (typically 
overhead 
storage 
several 
configuration 
[9]. 
to memory controller 
Commodity 
ECC DIMMs store 8 bits of redundancy  for 
in single-bit-error  correction  and 
(SEC-DED) 
with uniform storage 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:00 UTC from IEEE Xplore.  Restrictions apply. 
The MMU has also been used to manage  page-level  EDMs 
logic" of the application 
researchers attacked 
this modu­
in 
programming, 
from the "business 
problem by exercising 
should be separated 
to reduce complexity.  Several 
larity 
particular 
et al. [38] implemented 
control-flow 
runtime 
memory errors. 
as a proof of concept, 
aspect-oriented 
AspectC++ 
overhead. 
[37], [38].  For example, 
checking 
However, 
triple-time-redundant 
Alexandersson 
execution 
and 
which led 
to 300 % 
addresses 
none of these approaches 
can deal with memory errors. 
lists and binary trees that use 
unprotected. 
Aumann 
approach 
s. A formal  methodology 
and extended 
it to 
for 
by 
that are satisfied 
in [40]. Automatic 
detection 
user-defined 
invariants 
at 
Finally, 
robust data structures 
linear 
(constraints 
is presented 
pointers but 
leave the payload 
a similar 
stack data structure
of invariants 
Taylor et al. [ 1 8] proposed 
redundant 
et al. [39] formalized 
fault-tolerant 
the specification 
correct data structures) 
and repair of errors by validating 
runtime 
structures 
Moreover, 
are often difficult 
object protection, 
software, 
of the system  nor 
however, 
we do not require 
do we need to modify it. 
requires 
it is essential that appropriate 
- or even impossible 
has been studied 
because 
in [41 ] .  Thus, the design of robust data 
an excellent  understanding 
of the software. 
is very easy to apply to existing 
knowledge 
comprehensive 
invariants 
exist, 
which 
-to specify.  Our generic 
VII. CONCLUSIONS 
works from other authors. We regard the 
an aspect-oriented 
which can be tailored 
approach 
based 
clearly 
and, thus, overhead-wise 
In this paper we have presented 
overhead 
knowledge 
fault-tolerance, 
to software-based 
on application 
outperforms 
related 
total performance 
same time, the number of system failures 
silent  data 
and thread data structures 
12.8 % to below 0.01 %. Moreover, 
generic 
program as well. 
and can  be applied 
corruptions) 
of 0.09-1 .7 % as negligible. 
At the 
(both crashes 
and 
caused by errors in eCos' scheduler 
could be reduced significa
ntly from 
our approach 
is completely 
to any other object-oriented 
C++ 
An interesting 
side effect is that in  contrast 
to hardware 
software bugs are also detected. 
For example, 
if 
thread or an interrupt 
of an object, the proposed 
mechanism 
Considering the ongoing trend towards 
handler erroneously 
overwrites 
will detect 
multi-and 
ECC solutions, 
a parallel 
the content 
the problem. 
many-core 
become a huge benefit. 
CPUs and multi-threaded 
code, this property  might 
The main disadvantage 
of the approach 
is the significant 
a problem 
s. Code size 
code. This is certainly 
code bloat, caused by the vast number of instantiations 
generic 
age scenario
goal for future work. We expect that a better interprocedural 
analysis 
reduce the number of checks, 
to future  work. 
but its implementation 
is subject 
inside the AspectC++ 
would help to further 
in some embedded us­
will therefore 
be our primary 
reduction 
compiler 
of 
ACKNOWLEDGMENTS 
We wish to thank the anonymous 
reviewers 
for their very 
and encouraging 
helpful 
supported 
by the German Research 
program SPP 1 500 under grant no. 
project A4. 
comments. This work was  partly 