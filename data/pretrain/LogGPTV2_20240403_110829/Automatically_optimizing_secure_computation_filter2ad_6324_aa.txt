title:Automatically optimizing secure computation
author:Florian Kerschbaum
Automatically Optimizing Secure Computation
Florian Kerschbaum
SAP Research
Karlsruhe, Germany
ﬂPI:EMAIL
ABSTRACT
On the one hand, compilers for secure computation pro-
tocols, such as FairPlay or FairPlayMP, have signiﬁcantly
simpliﬁed the development of such protocols. On the other
hand, optimized protocols with high performance for special
problems demand manual development and security veriﬁ-
cation. The question considered in this paper is: Can we
construct a compiler that produces optimized protocols? We
present an optimization technique based on logic inference
about what is known from input and output. Using the
example of median computation we can show that our pro-
gram analysis and rewriting technique translates a FairPlay
program into an equivalent – in functionality and security
– program that corresponds to the protocol by Aggarwal et
al. Nevertheless our technique is general and can be applied
to optimize a wide variety of secure computation protocols.
Categories and Subject Descriptors
D.3.4 [Programming Languages]: Processors—Optimiza-
tion; D.4.6 [Operating Systems]: Security and Protec-
tion—Cryptographic controls
General Terms
Security, Programming Languages
Keywords
Secure Two-Party Computation, Programming, Optimiza-
tion
1.
INTRODUCTION
Secure (Multiparty) computation protocols [4, 7, 15, 31]
allow a number of parties the computation of a function on
joint input without disclosing anything except what can be
inferred by one party’s input and output. This oﬀers an
intriguing solution to many real-world problems where col-
laboration is prevented by the reluctance to disclose one’s
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’11, October 17–21, 2011, Chicago, Illinois, USA.
Copyright 2011 ACM 978-1-4503-0948-6/11/10 ...$10.00.
data. Privacy-preserving data mining [2, 21] is just one ex-
ample of many.
Secure computation protocols are notoriously diﬃcult to
develop, since they require a high degree of domain exper-
tise. Compilers, such as FairPlay [23] or FairPlayMP [6],
have signiﬁcantly simpliﬁed their development. They im-
plement general techniques – the protocols of Yao [31] and
Beaver et al. [4], respectively – in a cryptographic protocol
layer and translate a program describing the ideal function-
ality into a circuit that is then interpreted by this layer. This
reduces the development of the protocol to programming the
ideal functionality.
Unfortunately, the compiler approach can be quite inef-
ﬁcient and is currently not amenable to large problem in-
stances. Fortunately, a large body of work exists on opti-
mized secure computation protocols for special problems.
Besides the speciﬁcation of the protocol itself, optimized
protocols usually require a hand-crafted proof of security.
These proofs are diﬃcult and can be omitted in the com-
piler approach, since they are implicit in the cryptographic
protocol layer.
Naturally, the question arises if a compiler could also pro-
duce optimized protocols.
In programming languages the
optimizing techniques of compilers have already overtaken
the capabilities of even the most skilled assembler program-
mers. In this paper we present an optimization technique for
a secure computation compiler. To the best of our knowl-
edge this is the ﬁrst such technique. Our optimizer takes as
input a FairPlay program in the Secure Function Deﬁnition
Language (SFDL). It outputs a Java program with several
calls to FairPlay as a subroutine.
The basic idea is as follows: Everything that can be in-
ferred from one’s input and output is known. All known in-
formation can be revealed during the computation and does
not have to be computed securely. Via logic inference we
(under-) estimate the knowledge of each agent about a pro-
gram’s variables. Then we extract all operations on known
data to the Java program of the local agent. This can signif-
icantly reduce the functionality that needs to be computed
securely and the size of the circuit(s).
This paper contributes
• logic inference rules about an agent’s knowledge in a
SFDL program.
• a program transformation based on the result of the
inference.
• an evaluation based on example applications of median
and weighted average.
703We present our optimization technique using a running ex-
ample of median computation. In Section 2 we present this
example in detail with program code for SFDL, optimized
version as suggested by Aggarwal et al. [1] and performance
comparison. Then, based on this example we show our in-
ference rules and transformation technique in Section 3. We
report our evaluation including the examples of oblivious
transfer and weighted average in Section 4. Finally, we de-
scribe related work in Section 5 and conclude the paper in
Section 6.
2. RUNNING EXAMPLE
As a running example in this paper we consider the joint
computation of the median. We consider two parties – Alice
and Bob – and each party has a set of n (distinct) integers.
Alice and Bob want to jointly compute the median element
of the union of their sets without disclosing anything else.
We implement the distributed algorithm by Aggarwal et
al. [1]. Let each party’s set be sorted in ascending order.
The algorithm proceeds in several rounds.
In each round
each party chooses the median element of its set and then
the parties compare these two elements. The party with the
lower median disposes all elements below its median and the
party with the higher median disposes all elements above its
median. They begin a new round with these newly formed
sets until each set has size 1 in which case they choose the
lower one as the joint median.
We implemented this algorithm in SFDL of the FairPlay
system [23]. This is not straightforward, since eﬃciently ac-
cessing the median of a variably sized array requires division
which is not available in SFDL. This problem can be avoided
by unrolling the loops and precomputing the division.
In
order not to complicate the exposition we choose n = 2.
Furthermore, to simplify the analysis to be presented in this
paper we replace arrays with structures of scalar variables.
The resulting program is depicted in Listing 1.
Aggarwal et al.
[1] not only present a distributed algo-
rithm, but a distributed, secure protocol. The key insight
of their protocol is that given the output of the joint me-
dian, the result of each comparison can be inferred. Then,
in order to implement an eﬃcient, secure algorithm it is only
necessary to implement the comparisons using secure com-
putation and all other operations can be implemented locally
at the party’s site. In Listing 1 the two relevant comparisons
are depicted in lines 17 and 25.
The protocol by Aggarwal et al. can no longer be im-
plemented as a single FairPlay program.
Instead we im-
plemented it using the L1 language and system for mixed-
protocol secure computation [30]. The resulting program is
depicted in Listing 2.
In L1 the same program is executed by both parties; ex-
cept lines preceded by numbers are only executed by the
parties with the respective identiﬁers. These identiﬁers are
also returned by the call to the built-in function id(). The
function call comp32 in lines 9 and 17 invokes a secure com-
putation of a comparison using the local input x, i.e. each
party submits its variable x to a joint secure computation
protocol.
The similarity between the two programs is not surpris-
ing, since they implement the same algorithm. Nevertheless,
they compile into two very diﬀerent protocols. While the
FairPlay program implements Yao’s protocol, the L1 pro-
gram invokes secure computation only for the comparisons.
1
6
program Median {
typ e Elem
typ e A l i c e I n p u t = s t r u c t { Elem x ,
= I n t ;
typ e A l i c e O u t p u t = Elem ;
typ e B o b I n p u t
= s t r u c t { Elem x ,
Elem y } ;
Elem y } ;
typ e BobOutput
typ e I n p u t = s t r u c t { A l i c e I n p u t
= Elem ;
B o b I n p u t
a l i c e ,
bob } ;
11
typ e Output = s t r u c t { A l i c e O u t p u t a l i c e ,
BobOutput
bob } ;
16
21
26
f u n c t i o n Output o u t
( I n p u t
i n ) {
v a r Elem a , b ;
i f
( i n . a l i c e . x <= i n . bob . x ) {
a = i n . a l i c e . y ;
b = i n . bob . x ;
} e l s e {
a = i n . a l i c e . x ;
b = i n . bob . y ;
}
i f
( a <= b ) {
o u t . a l i c e = a ;
o u t . bob
= a ;
} e l s e {
o u t . a l i c e = b ;
o u t . bob
= b ;
31
}
}
}
Listing 1: Median Computation in FairPlay
i n c l u d e ”u t i l Y a o O T s . l 1 ” ;
i n c l u d e ”compareYao . l 1 ” ;
i n t Median ( ) {
i n t x = l o a d I n t ( ” i n p u t x ” + i d ( ) ) ;
i n t y = l o a d I n t ( ” i n p u t y ” + i d ( ) ) ;
i n t a ;
2
7
i f
( comp32 ( x ) == 1 ) {
1 : a = y ;
2 : a = x
12
} e l s e {
1 : a = x ;
2 : a = y ;
}
i f
( comp32 ( a ) == 1 ) {
1 : send ( 2 , ”a ” , a ) ;
2 : a = r e a d I n t ( ”a ” ) ;
} e l s e {
1 : a = r e a d I n t ( ”a ” ) ;
2 : send ( 1 , ”a ” , a ) ;
17
22
}
r e t u r n a ;
}
27
Median ( ) ;
Listing 2: Median Computation in L1
704is known from input and output.
If our optimized proto-
col reveals this additional information – but nothing else –,
then this does not violate semi-honest security, since it can
be constructed by the simulator. We need to be very care-
ful that our analysis is safe and always underestimates the
possible inferences from input and output.
3.2 Algorithm
In our algorithm to transform a SFDL program we use la-
beling of variables. Each variable in the program is assigned
any of two labels: {A} or {B}. Labels are non-exclusive,
i.e. a variable may be assigned none, one or two labels. The
contents of a variable labeled {A} is (always) known to Alice
and the contents of a variable labeled {B} is (always) known
to Bob. A variable without labels is secret and can only be
implemented using secure computation while a variable with
both labels is public information and can be freely shared.
The program text is known to both parties and so are all
constants in the program. Our algorithm for optimizing a
SFDL program proceeds as follows:
1. We convert the SFDL program into single-static as-
signment (SSA), 3-operand code form.
2. We use our inference algorithm to infer the labels of
each variable.
3. We segment the program into diﬀerent protocols. Each
statement of which all variables are known to any party
are executed locally by that party. Only statements
with operands whose intersection of labels is empty will
be executed using a secure computation as in FairPlay.
We give two examples of our segmentation of a program
into protocols. Consider the addition expression in Listing 3.
We have written the labels of the variables in subscript.
a A = b A + c A B ;
Listing 3: Local Computation
This statement can be executed locally at Alice’s site,
since she knows all variables and the result a can be used
as input in subsequent computations. Now, consider the
comparison expression in Listing 4.
a A B = b A < c B ;
Listing 4: Secure Computation
This statement must implemented as a secure computa-
tion. It is the program representation of Yao’s millionaires’
problem [31] where two parties compare private numbers.
3.3 Static Single Assignment
We convert the SFDL program into static single assign-
In SSA each variable is assigned at
ment (SSA) [9] form.
most once and never changed afterwards.
If a variable is
changed in the original program, a new variable is intro-
duced in SSA.
a = b ? c : d ;
Listing 5: Conditional Assignment
Figure 1: Secure Median
The result is a striking diﬀerence in performance. We ran
experiments with both protocols for diﬀerent joint set sizes
2n = 4, 8, 16, 32, 64. The performance measurements are de-
picted in Figure 1. For only 64 elements in the joint set the
L1 implementation already outperforms the FairPlay imple-
mentation by more than a factor of 30.
The research question of this paper is: Given the similar-
ity between the two programs can we compile the FairPlay
program into the protocol of the L1 program? Furthermore,
can we design an optimization algorithm that is not only
applicable to Aggarwal et al.’s median computation, but is
generic?
3. TRANSFORMATION
3.1 Semi-Honest Security
We consider secure computation protocols secure in the
semi-honest model [14]. Loosely speaking, an adversary in
the semi-honest model adheres to the protocol, but may keep
a record of the interaction and later try to infer additional
information from it. A protocol secure in the semi-honest
model, keeps everything about a party’s input conﬁdential
that cannot be inferred from one’s input and output.