}
destroy(tfile); // free napi
netif_napi_del(p); // use-after-free
list_for_each_entry_safe(p, n,
&dev->napi_list, dev_list)
Listing 1: The code snippet of the Linux kernel with a
bug. When triggered with different system call sequences and
arguments, the bug demonstrates two different error behaviors
– a general protection fault error and a use-after-free error.
in tun->flags, the kernel will initialize a timer and link the
corresponding napi to the list of the network device napi_list
(cid:44)→ . In line 12, another function tun_detach is responsible for
cleaning up the data enclosed in tun_file as well as closing
the ﬁle. If IFF_NAPI is set, the kernel will cancel the timer and
remove the napi from napi_list of the device. In line 24, the
function free_netdev will go through the napi_list to delete
napi in the list.
The kernel bug results from the potential inconsistent state
of the ﬂag tun->flags in tun_attach and tun_detach. Take for
example the kernel bug report [8] generated by Syzkaller. The
PoC program attached to the report shows that a system call
invokes tun_attach with IFF_NAPI unset. In this way, the kernel
neither initializes the timer nor adds the corresponding napi to
the list. Following this setup, the PoC program further invokes
the system call ioctl to set IFF_NAPI in tun->flags before
calling to tun_detach, which causes inconsistent ﬂags between
tun_attach and tun_detach. Then, in line 17, the kernel attempts
to stop the timer, which dereferences a pointer enclosed in the
timer object in tun_detach. However, as is mentioned above,
the timer is not initialized in tun_attach, which results in a
general protection fault. The general protection fault implies
accessing storage that is not designated for use. Therefore,
based on this single observation, many security analysts may
infer the bug is probably unexploitable.
However, after closely looking at this bug, we realize that,
by varying the PoC program and thus modifying the way to
assign inconsistent value for the shared variable, we can have
the kernel demonstrate a use-after-free error. To be speciﬁc, we
can set tun->flags with IFF_NAPI before invoking the function
tun_attach. In this way, after tun_attach is called, it could
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2079
in line 18 ∼ 19, but frees it
add the corresponding tun_file to the device list napi_list
(cid:44)→ . Following this setup, we can further invoke ioctl to clear
tun_flags and then call tun_detach. As is shown in Listing 1,
the function tun_detach does not remove the corresponding
napi from the list
in line
21. Therefore, when traversing the device list, the KASAN-
instrumented kernel will
throw the use-after-free error. In
comparison with the error shown in the report [8], instead
of accessing an invalid kernel memory address that generates
a general protection fault, this non-permitted access ties to
a valid kernel memory address and eventually corrupts the
kernel memory. Therefore, based on this use-after-free error,
many analysts may consider the bug is probably exploitable.
III. DESIGN RATIONALE & OVERVIEW
Given a kernel bug report demonstrating one particular
error behavior, one instinctive reaction for exploring its other
possible error behaviors is to utilize the concept of directed
fuzzing, which explores paths to a program site of our interest.
We can expect that, through some of the newly identiﬁed
routes to the buggy code fragment, one could trigger the bug
speciﬁed in the report again and observe new error behaviors.
However, this approach is not likely to be effective.
First,
to use directed fuzzing to expose multiple error
behaviors, we need to identify the buggy code fragment (i.e.,
the root cause of the error), treat it as the point of interest,
and feed it to the directed fuzzer. However, it is challenging
to pinpoint the root cause of the kernel bug correctly and
automatically. Incorrectly deeming a non-root-cause site as the
site of the fuzzer’s interest could even fail the fuzzer to trigger
the bug, let alone ﬁnding multiple error behaviors of the bug.
Second, even if we can point out the root cause of the
kernel bug and have a directed fuzzer repeatedly reaches out
to the buggy code, it does not mean the kernel could manifest
multiple error behaviors. In addition to following different
paths to the buggy code, the exhibition of error behaviors also
relies upon the context after the bug triggering. For example,
in addition to following a speciﬁc path to the buggy code
snippet, we also need a separate kernel thread to vary a global
variable, diversifying the contexts needed for triggering the
bug and demonstrating different errors. By design, directed
fuzzing cannot vary the context after reaching out to the target
code of its interest.
In response to the limitation of directed fuzzing, existing
kernel fuzzing techniques could handle the aforementioned
two problems in a better fashion. Kernel fuzzers like Syzkaller
do not require the input of the root cause of a given bug.
They simply vary system calls’ sequences and their argu-
ments and thus thoroughly test kernel code through different
paths. Besides, it also introduces new system calls to vary
the execution contexts. These characteristics complement the
shortage of directed fuzzing. Unfortunately, as we will show in
Section VI, this approach confronts extremely low efﬁciency
and demonstrates poor effectiveness.
The design principle of existing kernel fuzzing techniques is
to maximize the kernel code coverage, which avoids executing
the code paths that have already been explored. However,
to trigger the same bug and explore its other possible error
behaviors, the fuzzer needs to execute the same buggy code
snippets repeatedly and expects the kernel to run into the same
buggy site in a different context. Therefore, as we will show
in Section VI, the code-coverage-based kernel fuzzing method
(like Syzkaller) has only little beneﬁt for identifying multiple
error behaviors of a single kernel bug.
In this work, we address this problem by extending an
existing kernel fuzzing approach with kernel-object guidance.
Based on our observation from many kernel bugs, we discover
the root cause of a kernel bug usually results from two prac-
tices. One is the inappropriate usage of a kernel object, which
further contributes to a kernel error (e.g., the aforementioned
case assigning inconsistent ﬂag value for a kernel object in
tun_struct type). The other is an incorrect value involved in
computation with a kernel object, which is further propagated
to a critical kernel operation, forcing a kernel to demonstrate
an error (e.g., an unsanitized integer used as the offset of a
kernel object, causing an out-of-bounds memory access). As
such, guided by the objects relevant to the error speciﬁed in
the bug report, we can have the kernel fuzzer away from those
paths and contexts irrelevant to the bug and thus improve its
efﬁciency signiﬁcantly.
To realize the idea mentioned above, we design our techni-
cal approach as a multi-step procedure that combines static
analysis and kernel fuzzing techniques. As is depicted in
Figure 1, we ﬁrst
take as input a kernel bug report, run
the enclosed PoC program, and track down those kernel
structures involved in the kernel errors (e.g., struct tun_file
(cid:44)→ in the motivating example 1). The objects in these types
indicate the possible objects under inappropriate usage or
involving computation with an incorrect value. Therefore,
we further examine the kernel source code and identify the
statements that operate the objects in these types. In this
work, we treat these statements as the sites critical to the
success of kernel bug triggering. As a result, we instrument
these statements so that we can collect the feedback of object
coverage when performing kernel fuzzing and then use the
coverage to adjust the corresponding PoC program. In this
work, our kernel fuzzing mechanism takes as input the original
PoC program attached in the bug report. Using a new mutation
and seed generation method, it varies the PoC, improving the
efﬁciency and effectiveness in a bug’s multiple error behavior
explorations. In the following section, we will discuss these
techniques in detail.
IV. TECHNICAL DETAILS
In this section, we elaborate on the technical details of our
object-driven kernel fuzzing approach. First, we describe how
to analyze a kernel bug report and identify critical structures
(i.e., the structures involved in the corresponding kernel error).
Second, we discuss how to ﬁlter out kernel structures to further
improve kernel fuzzing efﬁciency in error behavior explo-
ration. Finally, we discuss how to use the identiﬁed structures
to design our object-driven kernel fuzzing mechanism.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2080
Fig. 1: The workﬂow of GREBE. (a) Following a kernel error trace obtained from a crash report, GREBE performs backward
taint analysis and identiﬁes all the kernel objects involved in the crash/panic. (b) Based on the objects’ rareness, GREBE narrows
down the objects critical to the kernel error. (c) Guided by the objects ﬁltered out in the last step, GREBE instruments kernel
and treats the critical objects’ (de)allocation and dereference sites as the anchor sites. (d) GREBE customizes Syzkaller so that
it could leverage the anchor sites’ reachability feedback to select seeds. Besides, GREBE introduces a customized mechanism
to mutate seeds so that GREBE could diversify the ways to trigger the same kernel bug.
1 // in drivers/vhost/vhost.c
2 void vhost_dev_cleanup(struct vhost_dev *dev)
3 {
4
5
6
7
8
9
kthread_stop(dev->worker);
dev->worker = NULL;
dev->kcov_handle = 0;
WARN_ON(!list_empty(&dev->work_list));
if (dev->worker) {
}
\
int __ret_warn_on = !!(condition);
\
if (unlikely(__ret_warn_on))
10 }
11 // in include/asm-genric/bug.h
12 #define WARN_ON(condition) ({
13
14
15
16
17 })
unlikely(__ret_warn_on);
\
__WARN();
\
\
Listing 2: The code snippet that performs explicit checking.
A. Critical Structure Identiﬁcation
In this work, we utilize backward taint analysis to identify
essential kernel structures (i.e., those involved in the error
speciﬁed in the given bug report). Here, we detail how we
identify the source and the sink and thus perform backward
taint analysis accordingly.
1) Report Analysis & Taint Source Identiﬁcation: The
Linux kernel has a variety of debugging features implemented
in different ways (e.g., BUG, WARN, and KASAN). However, most
of them follow the same pattern. That is enforcing checks dur-
ing the kernel execution and examining whether pre-deﬁned
conditions are satisﬁed. If the conditions do not hold, then the
kernel runs into an error state and logs critical information
for debugging purposes. Following the critical information
logging, the kernel may take further action to panic itself or
kill the current process.
Take, for example,
the case shown in Listing 2. The
function vhost_dev_cleanup() cleans the worker attached to the
vhost_dev device. In line 4, the kernel examines the work_list
(cid:44)→ . If the WARN_ON macro deems the list is empty, the kernel
continues its execution at line 5, which performs the cleanup
task. Otherwise, the kernel will execute the code in WARN_ON
macro and log the error. In this example, the error is reported
if and only if the pre-deﬁned condition “!list_empty(&dev->
(cid:44)→ work_list)” is true at runtime. Therefore, the variable dev->
(cid:44)→ work_list in the condition indicates a cause of the bug and
Fig. 2: An illustrating example and its dominator tree, which
demonstrate two different methods of logging kernel errors.
The line 7 is a logging statement responsible for kernel error
recording. The line 15 is the wrapper of the logging statement
at line 16. The variable conv in line 1 is the taint source that
our proposed approach identiﬁes. Note that for simplicity we
place the two error logging functions at two different branches
sharing the same conditional jump block. In the real world,
the error logging cannot occur in this way.
should become the starting point of our analysis (i.e., the taint
source of our backward analysis). In this example, the kernel
developers explicitly formulate the pre-deﬁned condition as an
expression and pass it to the macro WARN_ON for error handling.
However, for some other debugging features, the checking
is instrumented by a compiler or completed by hardware
instead of a piece of source code written by kernel developers.
For these features, the condition is implicitly formulated and
cannot be identiﬁed from the kernel source code. In the
following, we describe how we deal with various debugging
features and their error logging mechanisms and thus identify
the taint source.
Explicit Checking. Similar to the aforementioned example,
the kernel developers explicitly formulate the checking as an
expression and pass it to the standard debugging features such
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2081
Crash report:general protection fault: 0000 [#1] SMP KASANRIP: 0010:hrtimer_active+0x211/0x410 kernel/time/hrtimer.c:1142…crash siteobj_A, obj_Bobj_Cobj_Aobj_Bobj_C(b) Object Filtering(a) Backward Taint AnalysisPopularity RankingStructure Graph Constructionobj_Aobj_B(c) Kernel InstrumentationDedicated MutationSeed GenerationSeed SelectionSyzkallerPoC:mmap(…)r0=syz_open_dev$tun(…)ioctl$TUNSETIFF(r0,…)…(d) Customized Fuzzinglabel1:…tmp = icmp (conv, 0)….label2:…label3:…deﬁne bug(…)…1//comparison2tmp=icmp(conv,0)3//conditionaljump4br(tmp,label1,label2)56label1:7call@printk(...)//log89label2:10br(label3)//directjump1112label3:13call@bug(...)//call1415definebug(..)16call@printk(...)//log1 // source code
2 walk->offset = sg->offset;
3
4 // pseudo binary code after instrumentation
5 kasan_check_read(&sg->offset, sizeof(var));
6 tmp = LOAD(&sg->offset, sizeof(var)); // first access
7 kasan_check_write(&walk->offset, sizeof(var));
8 STORE(tmp, &walk->offset); // second access
Listing 3: The code snippet that performs implicit checking.
as WARN_ON and BUG_ON. Inside these macros, it is a patterned
code block that includes a condition statement and a logging
statement that will be executed if the condition is satisﬁed.
Apart from this standardized way to log kernel errors, the
developers can also build their own macro that wraps a logging
statement in a helper function (e.g., the code in the line 15 &
16 shown in Figure 2).
To identify the condition that
triggers the execution of
the logging statement and thus pinpoint
the taint source,
we ﬁrst trace back along the dominator tree until we ﬁnd
a dominator basic block, the last statement of which is a
conditional jump (e.g., given the wrapped logging statement in
line 16 in Figure 2, the line 4 is the statement linking to the
dominator basic block). Second, we treat the corresponding
comparison as the condition that triggers the execution of the
error logging (e.g., the line 2 in Figure 2). Finally, we extract
the corresponding variable in the condition as our taint source
(e.g., conv in Figure 2).
Implicit Checking. Implicit checking refers to the situation
where the checking is not part of the kernel source code but
instrumented by a compiler or completed by hardware. For
implicit checking done by compiler instrumentation, Kernel
Address Sanitizer (KASAN) is such an example in which
KASAN-enabled compiler instruments every memory access
so that the kernel could examine whether the access to a
memory address is legal. KASAN relies on shadow memory
to record the memory status. If the instrumented kernel, for
example, touches a freed memory region, it will generate a
bug report indicating the instruction that triggers a use-after-
free error. Regarding the implicit checking done by interrupts
(e.g., general protection fault detected by MMU), the interrupt
handling routine is responsible for logging the corresponding
instruction.
From bug reports generated by these debugging mecha-
nisms, we can easily identify the instruction that performs
the invalid memory access. With this information in hand, our
next step is to identify the variable associated with that invalid
memory access. However, the binary instruction enclosed in
the report contains no type information. To deal with this
problem, from the debugging information, we map binary
instructions with their corresponding statements in the source
code. Suppose the mapped source code is a simple statement
with only one load or store. In that case, we directly conclude
that this statement is the one causing the illegal memory access
and treat the operand variable as a taint source. However,
if the identiﬁed instruction links to a compound statement
involving multiple memory loads and stores (e.g., walk->offset
(cid:44)→ = sg->offset depicted in Listing 3), we perform further
analysis. To be speciﬁc, we ﬁrst examine the bug report and
pinpoint the speciﬁc instruction that captures the kernel error.
Then, we treat the memory access associated with the error-
catching instruction as our taint source. To illustrate this, we
again take, for example, the case shown in Listing 3. The
bug report indicates the error is captured by the statement
kasan_check_read(&sg->offset, sizeof(var)) which associates
with sg->offset. We deem sg->offset in line 2 as the taint
source.
2) Taint Propagation & Sink Identiﬁcation: Recall