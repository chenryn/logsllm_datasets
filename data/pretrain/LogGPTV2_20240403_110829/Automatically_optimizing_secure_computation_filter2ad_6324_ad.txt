dural language, called Secure Function Deﬁnition Language
(SDFL), a compiler that translates SDFL programs into one-
pass Boolean circuits that can be securely evaluated using
the protocol suggested by [31]. Originally, i.e., as presented
in [23], the FairPlay system supported only secure two-party
computations written in SDFL 1. This system served as a
basis for the development of the FairPlayMP system [6].
FairPlayMP supports the secure evaluation of multi-party
computations written in SFDL 2. Some circuit optimization
techniques for FairPlay are presented in [28].
There are other compilers [12, 32] which produce safe code
for a program according to an information ﬂow policy in a
distributed environment. Nevertheless, they do not allow to
specify any secure computation and oﬀer no secure imple-
mentation for the resulting information ﬂow.
Just FairPlay and FairPlayMP are instances of systems
which only describe the ideal functionality of a secure com-
putation, i.e. what is to be implemented by the protocol.
The burden of ﬁnding the ideal protocol is with the com-
piler. To the best of our knowledge we present the ﬁrst
technique that automatically optimizes such a program.
7105.2 Protocol Description Speciﬁcation
6. CONCLUSIONS
Next to FairPlay and its speciﬁcation of the ideal function-
ality, there are several secure computation implementations
where the programmer can give the compiler hints on how to
optimize. In the Secure Multiparty Computation Language
(SMCL) [25] the programmer speciﬁes the ideal function-
ality, but may specify also the visibility of variables as se-
cret, private or public. This is similar to our (party-speciﬁc)
labels, but we infer the labels automatically via program
analysis and do not burden the programmer. The TASTY
compiler and its TASTYL language [17] allow implementing
mixed-protocol implementations using not only Yao’s pro-
tocol, but also (additively) homomorphic encryption. The
programmer can specify in TASTYL which protocol is to
be used for which operation. This results in signiﬁcantly
more eﬃcient, yet always provably secure protocols. The
VIFF framework [10] extends the Python language using
a library.
It oﬀers the programmer several primitives for
secure computation, but the protocol description is up to
the programmer. The Sharemind framework [8] oﬀers an
interpreter for an assembler-like language implementing se-
cure protocols. The programmer has to specify the protocol
description using the primitives. The L1 system [30] al-
lows specifying protocol descriptions with many primitives
including Yao’s protocol and homomorphic encryption. It
also oﬀers a library for network communication.
All of these languages, compilers or frameworks are in-
stances of systems where the programmer can – at least
partially – specify how the protocol is implemented. This
approach leads to signiﬁcantly more eﬃcient protocols, but
puts an additional burden on the programmer. In this paper
we have chosen a diﬀerent approach. We use program analy-
sis to infer the optimal protocol from the ideal functionality,
but, of course, our techniques are also applicable in combi-
nation with other, programmer speciﬁed optimizations. To
the best of our knowledge we are the ﬁrst to present a fully
automatic technique.
5.3 Examples
We use several optimized protocols as our examples. Our
running example of the median computation by Aggarwal et
al.
[1] was one of the ﬁrst instances of a (hand-)optimized
secure computation protocol. Our optimization technique
was able to even slightly exceed the manual optimization.
Oblivious transfer (OT) is a long known primitive in cryp-
tography. 1-out-of-2 OT was introduced by Even et al. [11].
Our optimization was not able to improve its programming
language speciﬁcation. On the one hand, this is good, be-
cause our optimization is safe. After all, Kilian has shown
that cryptography can be founded on OT [19]. On the other
hand, it shows that our optimization technique cannot op-
timize the cryptographic implementation. This is not sur-
prising, since it only consider the ideal functionality. There
are several (cryptographically) optimized protocols for OT,
e.g. [13, 22, 24].
Our last example is joint lot size computation as weighted
average. This has been introduced in [27]. It shows the man-
ifold applications of secure computation. Our optimization
technique was able to match the manual optimization, if the
program was accordingly structured.
We have presented the ﬁrst technique to automatically
optimize a secure computation program. Our program anal-
ysis infers what a party knows from input and output. This
additional information is then used to perform several com-
putations locally instead of as a secure protocol. We have
shown using the running example of median computation
that our optimization technique can match (and even ex-
ceed) those performed manually by the programmer. Using
our implementation we were able to compile and execute an
SFDL program as Aggarwal et al.’s protocol.
As the performers of an automated analysis related to
Aggarwal et al.’s protocol we would like to make a few com-
ments on this protocol. First, our analysis underpins that
the protocol is secure. Our analysis is crafted carefully to
be safe and resulted in a slightly more revealing protocol
than the manually designed one. Second, our analysis shows
that protocol is very slightly ineﬃcient. Our analysis con-
cludes – and it is very easy to verify manually – that the last
comparison can also be implemented as a Yao’s millionaire’s
protocol. Aggarwal et al. recommend to use a minimum
computation that outputs the minimum element. This is
very slightly less eﬃcient, but avoids sending the output by
one party. Our compiled protocol is therefore slightly more
eﬃcient.
For future work we see two open problems. First, our
analysis works on protocols secure in the semi-honest model.
We would like to extend this to protocols secure in the ma-
licious model. One can adapt the compiler from the semi-
honest to the malicious model by Goldreich [14], but this
could be too ineﬃcient. Second, our prototypical implemen-
tation uses the ModLeanTab theorem prover [5]. We can
perform the compilation of the median example in roughly
one minute, but the majority of the time is spent on proving
the theorems. A more eﬃcient algorithm that scales to large
programs and maybe avoids theorem proving is desirable.
7. ACKNOWLEDGEMENTS
We are grateful to Axel Schr¨opfer for implementing the
L1 examples and performing the experiments and to Achim
Brucker and Marcel J¨unemann for implementing SSA and
the transformation.
8. REFERENCES
[1] G. Aggarwal, N. Mishra, and B. Pinkas. Secure
computation of the k-th ranked element. In
EUROCRYPT’04: Advances in Cryptology, 2004.
[2] R. Agrawal and R. Srikant. Privacy-preserving data
mining. ACM SIGMOD Record, 29(2), 2000.
[3] A. Banerjee. A joint economic-lot-size model for buyer
and supplier. Decision Sciences, 17, 1986.
[4] D. Beaver, S. Micali, and P. Rogaway. The round
complexity of secure protocols. In STOC’90:
Proceedings of the 22nd ACM Symposium on Theory
of Computing, 1990.
[5] B. Beckert and R. Gore. In CADE’98: Proceedings of
the International Conference on Automated Deduction,
1998.
[6] A. Ben-David, N. Nisan, and B. Pinkas. Fairplaymp: a
system for secure multi-party computation. In
CCS’08: Proceedings of the 15th ACM Conference on
Computer and Communications Security, 2008.
711[7] M. Ben-Or, S. Goldwasser, and A. Wigderson.
Completeness theorems for non-cryptographic
fault-tolerant distributed computation. In STOC’88:
Proceedings of the 20th ACM Symposium on Theory of
Computing, 1988.
[8] D. Bogdanov, S. Laur, and J. Willemson. Sharemind:
a framework for fast privacy-preserving computations.
In ESORICS’08: Proceedings of the 13th European
Symposium on Research in Computer Security, 2008.
[9] R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman,
and F. K. Zadeck. Eﬃciently computing static single
assignment form and the control dependence graph.
ACM Transactions Programming Languages and
Systems, 13(4), 1991.
[10] I. Damg˚ard, M. Geisler, M. Krøigaard, and J. B.
Nielsen. Asynchronous multiparty computation:
theory and implementation. In PKC’09: Proceedings
of the 12th International Conference on Practice and
Theory in Public Key Cryptography, 2009.
[11] S. Even, O. Goldreich, and A. Lempel. A randomized
protocol for signing contracts. Communications of the
ACM, 28(8), 1985.
[12] C. Fournet, G. L. Guernic, and T. Rezk. A
security-preserving compiler for distributed programs:
from information-ﬂow policies to cryptographic
mechanisms. In CCS’09: Proceedings of the 16th ACM
Conference on Computer and Communications
Security, 2009.
[13] C. Gentry and Z. Ramzan. Single-database private
information retrieval with constant communication
rate. In ICALP’05: Proceedings of the 32nd
International Colloquium on Automata, Languages
and Programming, 2005.
[20] S. Kripke. A semantic analysis of modal logic i:
normal modal propositional calculi. Zeitschrift f¨ur
Mathematische Logik und Grundlagen der
Mathematik, 9, 1963.
[21] Y. Lindell and B. Pinkas. Privacy-preserving data
mining. In CRYPTO’00: Advances in Cryptology,
2000.
[22] H. Lipmaa. An oblivious transfer protocol with
log-squared communication. In ISC’05: Proceedings of
the 8th International Conference on Information
Security, 2005.
[23] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella.
Fairplay—a secure two-party computation system. In
Proceedings of the 13th USENIX Security Symposium,
2004.
[24] M. Naor and B. Pinkas. Eﬃcient oblivious transfer
protocols. In SODA’01: Proceedings of the 12th
ACM-SIAM Symposium on Discrete Algorithms, 2001.
[25] J. D. Nielsen and M. I. Schwartzbach. A
domain-speciﬁc programming language for secure
multiparty computation. In PLAS’07: Proceedings of
the ACM Workshop on Programming Languages and
Analysis for Security, 2007.
[26] A. Paus, A.-R. Sadeghi, and T. Schneider. Practical
secure evaluation of semi-private functions. In
ACNS’09: Proceedings of the 7th International
Conference on Applied Cryptography and Network
Security, 2009.
[27] R. Pibernik, Y. Zhang, F. Kerschbaum, and
A. Schr¨opfer. Secure collaborative supply chain
planning and inverse optimization - the jels model.
European Journal of Operational Research, 208(1),
2011.
[14] O. Goldreich. Foundations of Cryptography, volume 2.
[28] B. Pinkas, T. Schneider, N. P. Smart, and S. C.
Cambridge University Press, 2004.
[15] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game. In STOC’87: Proceedings of the
19th ACM Symposium on Theory of Computing, 1987.
[16] J. Y. Halpern. Reasoning about knowledge: a survey.
In D. M. Gabbay, C. J. Hogger, and J. A. Robinson,
editors, Handbook of Logic in Artiﬁcial Intelligence
and Logic Programming, volume 4. Oxford University
Press, 1995.
[17] W. Henecka, S. K¨ogl, A.-R. Sadeghi, T. Schneider,
and I. Wehrenberg. Tasty: tool for automating secure
two-party computations. In CCS’10: Proceedings of
the 17th ACM Conference on Computer and
Communications Security, 2010.
[18] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster
secure two-party computation using garbled circuits.
In Proceedings of the 20th USENIX Security
Symposium, 2011.
[19] J. Kilian. Founding crytpography on oblivious
transfer. In STOC’88: Proceedings of the 20th ACM
Symposium on Theory of Computing, 1988.
Williams. Secure two-party computation is practical.
In ASIACRYPT’09: Advances in Cryptology, 2009.
[29] A. Sabelfeld and A. C. Myers. Language-based
information-ﬂow security. IEEE Journal on Selected
Areas in Communications, 21(1), 2003.
[30] A. Schr¨opfer, F. Kerschbaum, and G. M¨uller. L1 – an
intermediate language for mixed-protocol secure
computation. In COMPSAC’11: Proceedings of the
35th IEEE Computer Software and Applications
Conference, 2011.
[31] A. C.-C. Yao. How to generate and exchange secrets.
In FOCS’86: Proceedings of the 27th IEEE Symposium
on Foundations of Computer Science, 1986.
[32] S. Zdancewic, L. Zheng, N. Nystrom, and A. C.
Myers. Untrusted hosts and conﬁdentiality: Secure
program partitioning. In SOSP’01: Proceedings of the
18th ACM Symposium on Operating System
Principles, 2001.
712APPENDIX
A. MEDIAN EXAMPLE
Assumptions:
Trace of world W1:
Inference in world W1:
Trace of world W2:
Inference in world W2:
Trace of world W3:
Inference in world W3:
Trace of world W4:
Inference in world W4:
Kin.alice.x
Kin.alice.y
Kout.alice
Klt in.alice.x in.alice.y
Klt in.bob.x in.bob.y
W1 (cid:15) a = true
W1 (cid:15) b = A2
W1 (cid:15) c = B
W1 (cid:15) d = true
W1 (cid:15) out.alice = A2
d = true
out.alice
b
b = A2 K(b = A2 ⇒ a = true)
W1 (cid:15) a
W2 (cid:15) a = f alse
W2 (cid:15) b = A1
W2 (cid:15) c = B
W2 (cid:15) d = true
W2 (cid:15) out.alice = A1
d = true
out.alice
b
b = A1 K(b = A1 ⇒ a = f alse)
W2 (cid:15) a
W3 (cid:15) a = true
W3 (cid:15) b = A2
W3 (cid:15) c = B
W3 (cid:15) d = f alse
W3 (cid:15) out.alice = B
d = f alse
out.alice
a = true
c
in.alice.x
in.bob.x
W3 (cid:15) a
W4 (cid:15) a = f alse
W4 (cid:15) b = A1
W4 (cid:15) c = B
W4 (cid:15) d = f alse
W4 (cid:15) out.alice = B
out.alice
out.alice = B K(out.alice = B ⇒ d = f alse)
d
d = f alse
a = f alse
lt c b
lt in.bob.x in.bob.y
lt in.bob.y in.alice.x
a = f alse
lt c in.alice.x
lt in.bob.x in.alice.x
W4 (cid:15) a
Global inference:
W1 (cid:15) a W2 (cid:15) a W3 (cid:15) a W4 (cid:15) a
Ka
713