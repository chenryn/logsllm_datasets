in which each vertical 
faults, 
and correct 
for a given fault (on the 
the 
and for evaluating 
are ordered 
executions, 
point of view of faults, 
the percentage 
of failed 
horizontal 
amount of elusive 
by the percentage 
spectively. 
several 
(63.60%) is detected 
their location 
in the re­
maining test cases. This fact is representative 
that elude testing 
of code where they re­
since the portions 
side are hard to cover and exercise; 
the problem of generat­
ing test cases to achieve 
of time often occurs in testing 
100 
90 
80 
 70 
!!l 60 
:; J!! '0 ., 50 
'" 
A first subset of faults 
E ., 40 
"  ... 30 
20 
10 
0 
re­
the two reasons 
why 
by a small number of test cases since 
in the source code is not executed 
faults are elusive. 
of complex systems [ I]. 
a high coverage 
us to analyze 
of real faults 
This enabled 
in a limited 
injected 
amount 
Moreover, 
there is a second subset 
of faults 
(21.83%) that 
5  10 15 20 
Test case 
25  30 35 
40 
seldom manifest 
tion is executed 
themselves 
even if their source code loca­
many times. They are also representative 
of 
Figure 5. Percentages 
executions 
for each test case. 
of failures 
and correct 
978-1-4244-7501-8/101$26.00 
©2010 IEEE 
441 
DSN 2010: Natella et al. 
2010 IEEE/IFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
The percentage 
of faults detected 
and covered by each 
faults, 
in the number of detected 
is low for non-elusive 
of 
there are only are 
test case is shown in Figure 5. Because the percentage 
failures 
small differences 
test cases (with few exceptions). 
activation 
test cases; therefore, 
several 
issue that should be analyzed 
This also means that the 
among 
inputs to trigger elusive faults. 
an SFI campaign requires 
faults are distributed 
in future research. 
This is still an open 
of elusive 
triggers 
between 
faults 
a set of 
workload 
(in terms of amount 
effects of a more demanding 
of data and operations 
rate). 
1.! 2.3! 4! 5. 61! time 
I  : 
I MySQL test case I I 
3. MySQL start 
TPC-C start 
Test case start 
TPC-C benchmark  4. Test case stop 
MySQL (faulty)  6. MySQL stop 
5. TPC-C stop 
Distribution 
of faults with 
to numer of failures 
Elusive 
«50% failures) 
faults 
Non-elusive 
(>=50% failures) 
faults 
Figure 7. Experiment 
of results 
using T PC-C. 
setup for the validation 
10  15 20 
Number of failures 
25  30 35 
We selected 
a random sample of 668 faults from those 
about the same proportion 
0 or 1 failure, 
causing 
keeping 
Figure 6. As in the previous 
has been executed 
considered 
with 
TPC-C (e.g., some test cases forced a reboot of the DBMS). 
only test cases (34 in total) 
times, one for each test case. We 
campaign, 
not conflicting 
several 
each faulty version 
of 
40 
30 
25 
  20 
'0  15 
 10 
Q. 
only a small part of faults 
Figure 8 shows the distribution 
to the number of failures, 
of faults in the sample 
after the addition 
with respect 
TPC-C. During the experiments, 
(\.35%) caused 2 or more failures, 
triggered 
of TPC-C and a test case (0.90%). Even with TPC-C 
benchmark, 
for the MySQL DBMS, 98.65% of faults in the sample 
revealed 
which represents 
a quite demanding 
which were always 
by TPC-C (0.45%) or by the joint execution 
workload 
nature. 
of 
an elusive 
Distribution 
of faults with respect to numer of failures 
Figure 6. Distribution 
to the number of failures. 
of faults with respect 
The last set of faults in Figure 4 contains 
non-elusive 
which are easy to detect. Their extent can be 
in Figure 6, which shows the fault distribution 
to the number of times they caused a failure. 
of faults cause a small number of failures, 
(29.56%). 
injected 
faults, 
observed 
with respect 
The majority 
with the predominance 
failure 
that faults 
representative; 
faults 
failures 
a failure 
that choosing 
significantly 
12.73% (at least 75% of failures) 
of failures) 
is non-negligible, 
nevertheless, 
of non-elusive 
a threshold 
faults. 
different 
(more than 35). In fact, 14.57% of faults caused 
at least in the 50% of cases. It should be noted 
affect this result (see Figure 6), ranging 
to 19.86% (at least 25% 
than 50% does not 
from 
of faults causing 0 (30%) or I 
This result seems to support 
by G-SWFIT are elusive 
the thesis 
50 
and therefore 
of non-elusive 
the percentage 
and they cause a large number of 
'0 30 " '" 
 20 "  " Q. 10 
4.3 Validation of results 
o 
5 
10 
15 
20 
Number of failures 
25 
30 
Figure 8. Distribution 
faults with respect to the number of failures 
(under test cases and T PC-C running at the 
same time). 
of a sample of elusive 
In order to get more confidence 
in our conclusions, 
we 
by means of a second experimental 
faults 
these results 
Our aim was to confirm (or not) that the low 
of 
challenged 
campaign. 
number of non-elusive 
the test cases but is really related 
Therefore, 
of the TPC-C benchmark3 as an additional 
this setup (Figure 
the same time on the same database, 
workload. 
7), TPC-C and a test case are executed 
is not due to the simplicity 
the faults. 
to the nature of 
we augmented 
In 
at 
in order to analyze  the 
test cases with an implementation 
3http://jtpcc.sourceforge.netl 
5 Improving fault representativeness 
In this section 
we address 
our second research 
Our goal is to tell apart elusive 
before any actual fault injection. 
us to filter non-elusive 
increase 
from non-elusive 
This ability 
will allow 
and thus 
its representativeness. 
faults from the faultload 
problem. 
faults 
978-1-4244-7501-8/10/$26.00 
©2010 IEEE 
442 
DSN 2010: Natella et al. 
2010 IEEE/IFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
nents 
we deeply analyze 
In order to understand 
their fault type and the component 
the key features 
them with respect 
5.1 Analysis of fault types and compo­
50 
45 
40 
l35 
OJ '" " .l! 
30 
25 
0 " '" .. E " 0 a; ... 
20 
15 
10 
5 
In Figure 9 and Figure lOwe compare the distributions 
0 
U  S  In  (f) 
LL  :0  w  LL 
:0 
:E  :E 
on the shape 
if differences 
faults, 
tant factors: 
they are located. 
affect the elusiveness 
is true, faultload 
including 
of the injected 
to two impor­
in which 
that these factors 
can 
representativeness 
fault types or components. 
across fault types (Table I), respectively.  Ap­
I and 2 in Figure 4) and non­
if this hypothesis 
We hypothesize 
can be improved 
of injected 
has little 
specific 
faults; 
by 
faults 
subsets 
(including 
fault elusiveness 
influence 
quantitatively 
evaluate 
are statistically 
of elusive 
elusive 
parently, 
of the distribution.  To 
between distributions 
are not caused by random factors) 
Kolmogorov-Smirnov 
for evaluating 
underlying 
test (p-value 
samples are from the same distribution 
i.e., differences 
the fault type alone cannot discriminate 
It should be noted that this result 
fault type affects where faults 
could have occurred 
probability 
=  0.4333), 
are not statistically 
distribution. 
more frequently 
are injected 
cannot be rejected, 
Therefore, 
significant. 
non-elusive 
faults. 
is not obvious, 
since the 
(e.g., a fault type 
in code easy to test). 
if two samples are drawn from the same 
On the basis of the KS 
the null  hypothesis 
that the two 
In "3 .l! 0 " '" .. E " 
50 
45 
40 
l35 
30 
25 
20 
15 
 ... 
10 
5 
0 
U  S  In 
LL  :0  w 
:0 
:E 
significant 
(i.e., they 
we use the two-sample 
(KS) test [19], which is a procedure 
Figure 10. Non-elusive 
across types. 
faults distribution 
U ..J :0 
w  > 
:0  :0 
 :; :0 
... w  
to group related 
procedures/classes; 
developers 
source files as components, 
influence 
of both individual 
whole source file (e.g., the use of a shared variable 
related 
we take into account the 
and the 
procedures/classes 
Faults were injected 
in 96 components. 
procedures). 
by defining 
by 
14.---.------------------. 
12 
  10 
t OJ "3 8 :! o " '" 
-E 6 
 ... 4 
(f)  U 
LL  ..J 
:E  :0 
... w  
<I: ... ..J :0    i 
Fault Type 
10 20 30 40 50 60 70 80 90 
Component 10 
Figure 11. Elusive faults distribution  across 
components. 
Figure 9. Elusive faults distribution 
across 
types. 
In order to analyze whether 
the elusiveness 
is related 
to a specific 
system component, 
faults 
the same procedure 
of elusive 
12). We use the term "component" 
file of MySQL core. Source files are adopted by C/C++ 
faults (Figure I I  and Figure 
to refer to a source 
on the distributions 
and non-elusive 
across components 
of injected 
we applied 
with a confidence 
The two distributions 
confirms this observation, 
rejected 
=  7.2862 . 10-7). This result 
is influenced 
due to the interplay 
code. Therefore, 
target component 
elusive 
and non-elusive 
faults. 
are noticeably 
different; 
the KS test 
since the null  hypothesis 
level greater 
than 99% (p-value 
that the elusiveness 
suggests 
can be 
by the target component; 
it is probably 
between faults and the surrounding 
we will analyze if the features 
of the 
to discriminate 
between 
can be exploited 
978-1-4244-7501-8/10/$26.00 
©2010 IEEE 
443 
DSN 2010: Natella et al. 
2010 IEEE/IFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
Table 2. Software 
complexity 
metrics. 
Name  Description 
AvgCyc  Average cyclomatic 
complexity of functions in the 
component 
12 
  10 
 .! 8 
'0 ., '" 
6 
E 
 a.. 4 
2 
In fact, the relative 
Before training 
the decision 
tree, we split components 
10 20 30 40 50 60 
70 80 90 
Component 10 
Figure 12. Non-elusive 
across components. 
faults distribution 
references 
5.2 Filtering  non-elusive 
faults 
From the results 
of the previous 
section, 
we observe 
that 
faults across 
faults 
of elusive 
percentage 
of non-elusive 
are significantly 
tends to be higher in some 
(on the right side in Figure I I  and Figure 12). 
and non-elusive 
different. 
if these components 
they can be discarded 
are identified 
from the analysis 
of non-elusive 
In 
before fault 
in order 
faults. 
terms, this means that fault which locations 
fall 
out from the fault­
the distributions 
components 
percentage 
components 
Therefore, 
injection, 
to reduce the relative 
practical 
into these components 
load. This reduces the skew of non-elusive 
results 
iments. 
of complexity 
metrics. 
since the complexity 
paths) and its relationships 
the ability 
metrics 
and the loss of time in performing 
To characterize the 
components, 
We investigate 
complexity 
(e.g., the number of 
with other components 
faults on the 
misleading 
exper­
we collected 
a set 
test the component; 
can reveal where faults 
may hide from tests. 
to thoroughly 
of a component 
will be filtered 
affect 
metrics 
We selected 
a set of complexity 
metrics 
(Table 2) that 
therefore, 
(InDepR, 
(assuming 
from a software artifact 
and thus are available 
to the 
(AvgCyc, MaxCyc), the code size (LaC), 
on symbols (e.g.,  a function) 
InDepC) or exported 
( OutDepR, Out­
can be easily collected 
source code availability), 
tester before SFI: they take into account the  cyclomatic 
complexity 
and dependencies 
imported 
DepC) by the component. 
relationship 
containing 
commonly used in data mining problems, 
trees [22]. A decision 
that are used to classify 
are based on complexity 
and components 
we adopted a technique 
namely decision 
set of questions 
between complexity 
non-elusive 
tree is a hierarchical 
metrics (for instance 
In order to extract 
an element. 
the hidden 
faults, 
metrics 
that are 
"Is LoC 
In our study, questions 
MaxCyc  Maximum cyclomatic 
complexity 
of functions 
in the 
component 
LoC 
Number of lines of code 
OutDepC Dependencies 
of the component ("fan-out"), 
number of 
components 
OutDepR Dependencies 
of the component ("fan-out"), 
number of 
references 
InDepC  Dependencies 
on the component ("fan-in"), 
number of 
components 
InDepR  Dependencies 
on the component ("fan-in"), 
number of 
greater 
than 340?"), 
to be classified. 
other classifiers 
provides 