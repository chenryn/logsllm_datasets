uses a private-key encryption scheme and exploits the linearity of
the Shamir secret sharing [18] and the ElGamal encryption [6].
3A multi-challenge version of the definition is implied by the single-challenge one
using standard hybrid argument.
4For simplicity, we assume that passwords are distributed uniformly in the pass-
word space. The definition can be easily generalized to cover arbitrary password
distributions.
3.1 Construction Overview
Let G be a cyclic group of prime order ğ‘ with generator ğº, and
let ğ»0, ğ»1 : {0, 1}âˆ— â†’ G be two independent hash functions. A
ciphertext ğ¶ = SKE.Enc(ğ‘ 0, (ğ¶0, ğ¶1)) consists of a symmetric-key
ciphertext of two group elements ğ¶0 and ğ¶1 under the server secret
key component ğ‘ 0, and is accompanied by a nonce ğ‘›. The elements
ğ¶0 and ğ¶1 are computed as follows
ğ¶0 = ğ»0(pw, ğ‘›) Â· ğ»0(ğ‘›)Â¯ğ‘ 0
ğ¶1 = ğ»1(pw, ğ‘›) Â· ğ»1(ğ‘›)Â¯ğ‘ 0 Â· ğ‘€
where Â¯ğ‘ 0 is part of the conceptual rate-limiter secret key, and ğ‘€
is the encrypted message. The conceptual key Â¯ğ‘ 0 is secret-shared
among ğ‘š rate-limiters using the well-known Shamir secret sharing
scheme with reconstruction threshold ğ‘¡. In contrast to [12], we
do not distinguish between server and rate-limiter nonces. In our
scheme, the nonce ğ‘› is obtained via a coin-flipping protocol between
the server and ğ‘¡ rate-limiters. The server key is now used in a secret-
key encryption scheme to allow for stronger security properties.
An important feature of the Shamir secret sharing scheme is that
the reconstruction function is linear. That is, given a set of ğ‘¡ shares
and their indices {(ğ‘– ğ‘— , ğ‘ ğ‘– ğ‘—)}ğ‘¡
ğ‘—=1, there exists a public linear combina-
ğ‘—=1 ğœ†ğ‘—ğ‘ ğ‘– ğ‘— .
This feature is crucial for the decryption protocol, as we will see.
tion with some coefficients (ğœ†1, . . . , ğœ†ğ‘¡) such that Â¯ğ‘ 0 =ğ‘¡
polynomial â„“ğ‘ƒ,ğ‘–(ğ‘¥) :=ğ‘— âˆˆğ‘ƒ\{ğ‘–} ğ‘¥âˆ’ğ‘—
3.2 Formal Description
Ingredients. Given a finite set P of size |P| â‰¥ ğ‘¡, let Subsetğ‘¡ (P)
be an algorithm which returns an arbitrary size-ğ‘¡ subset ğ‘ƒ of P.
Let GGen : 1ğœ† â†¦â†’ (G, ğ‘, ğº) be a group generation algorithm which
maps the security parameter 1ğœ† to the description (G, ğ‘, ğº) of a
cyclic group G of prime order ğ‘ with generator ğº. Let ğ‘¡, ğ‘š âˆˆ N with
ğ‘¡ â‰¤ ğ‘š â‰¤ ğ‘. For any subset ğ‘ƒ âŠ† [ğ‘š] and ğ‘– âˆˆ ğ‘ƒ, recall the Lagrange
ğ‘–âˆ’ğ‘— . Let ğœ†ğ‘ƒ,ğ‘– := â„“ğ‘ƒ,ğ‘–(0). For the ease
of notation, we define ğœ†ğ‘ƒ,0 := 1 for all ğ‘ƒ. Let ğ»0, ğ»1 : {0, 1}âˆ— â†’ G
and ğ» : {0, 1}âˆ— â†’ {0, 1}ğœ† be independent hash functions to be mod-
eled as random oracles. Let SKE.(KGen, Enc, Dec) be a symmetric-
key encryption scheme. Let (GGen, Prove, Vf) be a non-interactive
zero-knowledge proof of knowledge (NIZKPoK) scheme for the
relation
ğ‘…GDL :=
(cid:169)(cid:173)(cid:173)(cid:171)
ğ´1,1
...
ğ´ğ‘š,1
(cid:170)(cid:174)(cid:174)(cid:172) âˆˆ Gğ‘šÃ—(ğ‘›+1),
(G, ğº, ğ‘),
ğµ1
...
ğµğ‘š
. . . ğ´1,ğ‘›
...
. . .
. . . ğ´ğ‘š,ğ‘›
(ğ‘¥1, . . . , ğ‘¥ğ‘›) âˆˆ Zğ‘›
ğ‘ :
ğ‘—=1ğ´ğ‘¥ ğ‘—
âˆ€ğ‘– âˆˆ [ğ‘š], ğµğ‘– =ğ‘›
ğ‘–,ğ‘—
as described in Appendix A.2. Here, the tuple (G, ğº, ğ‘) is a com-
mon reference string, the matrix in Gğ‘šÃ—(ğ‘›+1) is the statement, and
(ğ‘¥1, . . . , ğ‘¥ğ‘›) âˆˆ Zğ‘›
ğ‘ is a witness satisfying the statement.
Setup (Figure 3). The setup algorithm runs GGen to generate
the description of the group. It then generates the secret keys
sk0, . . . , skğ‘š,where skğ‘– has the format (ğ‘ ğ‘–, ğ‘˜ğ‘–, ğ¾0, { Â¯ğ‘† ğ‘— , Â¯ğ¾ğ‘—}ğ‘¡âˆ’1
ğ‘—=0) where
5
(ğ‘–, ğ‘—) â† AO(1ğœ†)
(sk0, ğ‘›, ğ¶, pw, ğ‘€) := Queries[ğ‘–]
(skâ€²
SoundnessÎ ,A(1ğœ†)
1 : Queries := âˆ…
2 : O := {EncO, DecO }
3 :
4 :
5 :
6 : ğ‘0 := ((sk0, ğ¶) = (skâ€²
0, ğ¶â€²))
7 : ğ‘1 := (ğ‘€ â‰  âŠ¥ âˆ§ ğ‘€â€² â‰  âŠ¥)
8 : ğ‘2 := (((ğ‘›, pw) = (ğ‘›â€², pwâ€²)) âˆ§ (ğ‘€ â‰  ğ‘€â€²))
9 : ğ‘3 := (((ğ‘›, pw) â‰  (ğ‘›â€², pwâ€²)) âˆ§ (ğ‘€, ğ‘€â€² âˆˆ M))
10 :
0, ğ‘›â€², ğ¶â€², pwâ€², ğ‘€â€²) := Queries[ ğ‘—]
return ğ‘0 âˆ§ ğ‘1 âˆ§ (ğ‘2 âˆ¨ ğ‘3)
EncO(sk0, pw, ğ‘€, ğ‘Ÿ, ğ‘š, ËœR1, . . . , ËœRğ‘š)
1 :
2 : Queries := Queries âˆª(cid:8)(sk0, ğ‘›, ğ¶, pw, ğ‘€)(cid:9)
((ğ‘›, ğ¶),âˆ—, . . . ,âˆ—) â† âŸ¨S(â€œencâ€, sk0, pw, ğ‘€; ğ‘Ÿ), ËœRO
ğ‘šâŸ©
1 , . . . , ËœRO
3 :
return ğœ–
DecO(sk0, pw, ğ‘›, ğ¶, ğ‘Ÿ, ğ‘š, ËœR1, . . . , ËœRğ‘š)
1 :
2 : Queries := Queries âˆª(cid:8)(sk0, ğ‘›, ğ¶, pw, ğ‘€)(cid:9)
(ğ‘€,âˆ—, . . . ,âˆ—) â† âŸ¨S(â€œdecâ€, sk0, pw, ğ‘›, ğ¶; ğ‘Ÿ), ËœRO
1 , . . . , ËœRO
ğ‘šâŸ©
3 :
return ğœ–
Figure 2: Soundness Experiment
ğ‘ 0 is a secret key for a symmetric key encryption scheme SKE and
ğºğ‘ ğ‘– =ğ‘¡âˆ’1
(cid:40)ğ¾0
ğ‘¡âˆ’1
ğºğ‘˜ğ‘– =
ğ‘—=0 Â¯ğ‘†ğ‘– ğ‘—
ğ‘—=0
ğ‘— , ğ‘– âˆˆ [ğ‘š]
ğ‘– = 0
ğ‘– âˆˆ [ğ‘š].
Â¯ğ¾ğ‘– ğ‘—
ğ‘—
Each party can verify the validity of their keys using the subroutine
KVf defined in Figure 5.
Encryption (Figure 3). The encryption protocol begins with a
coin-flipping procedure. Each party samples some randomness ğ‘›ğ‘–
and exchanges their randomness with each other. They then hash
all randomness using the hash function ğ» to create a nonce ğ‘›.
With the help of the rate-limiters, the server computes the tuple
(ğ¶0, ğ¶1) := (ğ»0(pw, ğ‘›) Â· ğ»0(ğ‘›)Â¯ğ‘ 0, ğ»1(pw, ğ‘›) Â· ğ»1(ğ‘›)Â¯ğ‘ 0 Â· ğ‘€). It then
compute ğ¶ â† SKE.Enc(ğ‘ 0, (ğ¶0, ğ¶1)).
Let ğ‘ƒ be any ğ‘¡-subset of [ğ‘š]. The ciphertext components ğ»0(ğ‘›)Â¯ğ‘ 0
and ğ»1(ğ‘›)Â¯ğ‘ 0 can be expressed as ğ»0(ğ‘›)Â¯ğ‘ 0 = ğ»0(ğ‘›)ğ‘–âˆˆğ‘ƒ ğœ†ğ‘ƒ,ğ‘–ğ‘ ğ‘– and
ğ»1(ğ‘›)Â¯ğ‘ 0 = ğ»1(ğ‘›)ğ‘–âˆˆğ‘ƒ ğœ†ğ‘ƒ,ğ‘–ğ‘ ğ‘– respectively.
ğ‘–,0
ğ‘–âˆˆğ‘ƒğ‘Œ ğœ†ğ‘ƒ,ğ‘–
Decryption (Figure 4). The decryption protocol begins with the
server informing the rate-limiters of the nonce ğ‘›, and decrypting the
ciphertext ğ¶ to obtain (ğ¶0, ğ¶1). The server then computes the value
ğ‘Œ0,0 := ğ¶0 Â· ğ»0(pw, ğ‘›)âˆ’1, while the ğ‘–-th rate-limiter computes ğ‘Œğ‘–,0 :=
ğ»0(ğ‘›)ğ‘ ğ‘– . Conceptually, the parties would like to check if ğ‘Œ0,0 =
for some ğ‘¡-subset ğ‘ƒ of [ğ‘š]. If the relation is satisfied,
meaning that the password is likely correct, the rate-limiters would
jointly help the server to compute ğ»1(ğ‘›)Â¯ğ‘ 0, which allows the latter
to recover the message ğ‘€. However, naively performing the joint
computation of ğ»1(ğ‘›)Â¯ğ‘ 0 would cost one extra round of computation.
In the following, we outline a three-phase protocol where the round
for computing the value ğ»1(ğ‘›)Â¯ğ‘ 0 is merged with one of the rounds
in the checking procedure.
First, the parties jointly compute an encryption of the value
ğ‘ := ğ‘Œâˆ’1
ğ‘–,0 under the public key ğ¾ = ğ¾0 Â· Â¯ğ¾0, where the
corresponding secret key is secret-shared among the participants.
This can be done by having the parties encrypt their respective in-
puts using the linearly-homomorphic ElGamal encryption scheme,
0,0ğ‘–âˆˆğ‘ƒğ‘Œ ğœ†ğ‘ƒ,ğ‘–
6
exchange the ciphertexts with each other (via the server), and ho-
momorphically compute an encryption of ğ‘ locally. This costs 2
rounds of communication.
Recall that the goal of the protocol is to allow the server to obtain
ğ»1(ğ‘›)Â¯ğ‘ 0 in the case ğ‘ = ğ¼ (the identity element). We observe that
for a randomly sampled Ëœğ‘Ÿ and for an arbitrary group element ğ´,
ğ‘ Ëœğ‘Ÿ Â· ğ´ = ğ´ when ğ‘ = ğ¼, and uniformly random otherwise. With
this observation, in the second phase the parties jointly compute
the encryption of ğ‘ Ëœğ‘Ÿ and ğ‘ Ëœğ‘Ÿâ€² Â· ğ»1(ğ‘›)Â¯ğ‘ 0 respectively for random Ëœğ‘Ÿ
and Ëœğ‘Ÿâ€². Similar to the first phase, this costs another 2 rounds of
communication.
In the last phase, the parties jointly help the server to decrypt
the ciphertexts, so that the latter can check whether ğ‘ Ëœğ‘Ÿ = ğ¼ (and
hence ğ‘ = ğ¼), and if so obtain ğ»1(ğ‘›)Â¯ğ‘ 0. This costs 1 round of com-
munication. Together with the first round where the server sends
the nonce ğ‘›, we obtain a 6-round protocol.
At this point, the decryption functionality is already achieved
and the protocol can already be terminated. However, the rate-
limiters have no knowledge about whether the decryption was
successful or not, i.e., whether ğ‘ = ğ¼, and thus can only perform
â€œcoarse-grainedâ€ rate-limiting. That is, the rate-limiters would count
both successful and failed decryption attempts, since they cannot
distinguish between the two. This is often sufficient in applications,
since typically a user would not login (successfully) too frequently.
To support â€œfine-grainedâ€ rate-limiting, the server would send an
extra message to the rate-limiters to allow them to decrypt the
encryption of ğ‘ Ëœğ‘Ÿ . These additional steps are highlighted in dashed
boxes in Figure 8. This costs an extra round of communication and
results in a 7-round protocol.
Key Rotation and Ciphertext Update (Figure 5). The goal of key-
rotation is to update the secret keys from skğ‘– to skâ€²
ğ‘–, where
skğ‘– = (ğ‘ ğ‘–, ğ‘˜ğ‘–, ğ¾0, { Â¯ğ‘† ğ‘— , Â¯ğ¾ğ‘—}ğ‘¡âˆ’1
ğ‘—=0)
skâ€²
ğ‘– = (ğ‘ â€²
ğ‘—}ğ‘¡âˆ’1
ğ‘—=0)
0, { Â¯ğ‘†â€²
ğ‘– , ğ¾â€²
ğ‘— , Â¯ğ¾â€²
ğ‘– , ğ‘˜â€²
Setup(1ğœ†, 1ğ‘š, 1ğ‘¡)
// ğ‘  and ğ‘† keys are used for encrypting password records
// ğ‘˜ and ğ¾ keys are used in the decryption protocol
crs := (G, ğ‘, ğº) â† GGen(1ğœ†)
ğ‘ 0 â† SKE.KGen(1ğœ†), ğ‘˜0 â†$ Zğ‘ // Server key
ğ¾0 := ğºğ‘˜0
// Rate-limiter keys (to be shared)
Â¯ğ‘  ğ‘— , Â¯ğ‘˜ ğ‘— â†$ Zğ‘, âˆ€ğ‘— âˆˆ [0, ğ‘¡ âˆ’ 1]
Â¯ğ‘ (ğ‘¥) :=
Â¯ğ‘  ğ‘— ğ‘¥ ğ‘— , Â¯ğ‘˜(ğ‘¥) :=
ğ‘¡âˆ’1âˆ‘ï¸
ğ‘¡âˆ’1âˆ‘ï¸
Â¯ğ‘˜ ğ‘— ğ‘¥ ğ‘—
ğ‘—=0
ğ‘—=0
Â¯ğ‘˜ ğ‘— , âˆ€ğ‘— âˆˆ [0, ğ‘¡ âˆ’ 1]
Â¯ğ‘† ğ‘— := ğº Â¯ğ‘  ğ‘— , Â¯ğ¾ğ‘— := ğº
ğ‘ ğ‘– := Â¯ğ‘ (ğ‘–), ğ‘˜ğ‘– := Â¯ğ‘˜(ğ‘–), âˆ€ğ‘– âˆˆ [ğ‘š]
skğ‘– := (ğ‘ ğ‘–, ğ‘˜ğ‘–, ğ¾0, { Â¯ğ‘† ğ‘— , Â¯ğ¾ğ‘— }ğ‘¡âˆ’1
return (crs, sk0, . . . , skğ‘š)
ğ‘—=0) âˆ€ğ‘– âˆˆ [0, ğ‘š]
EncâŸ¨S(â€œencâ€, sk0, pw, ğ‘€), Â· Â· Â·âŸ©
ensure KVf(0, sk0)
ğ‘›0 â†$ {0, 1}ğœ†
receive ğ‘›ğ‘– from Rğ‘– âˆ€ğ‘– âˆˆ [ğ‘š]
P := {ğ‘– : ğ‘›ğ‘– â‰  âŠ¥}
ensure |P| â‰¥ ğ‘¡
ğ‘ƒ â† Subsetğ‘¡ (P)
send { ğ‘—, ğ‘› ğ‘— } ğ‘—âˆˆğ‘ƒâˆª{0} to Rğ‘– âˆ€ğ‘– âˆˆ ğ‘ƒ
ğ‘› := ğ» ({ğ‘–, ğ‘›ğ‘– }ğ‘–âˆˆğ‘ƒâˆª{0})
ğ‘‹0 â† ğ»0(ğ‘›), ğ‘‹1 â† ğ»1(ğ‘›)
ğ‘Œ0,0 â† ğ»0(pw, ğ‘›), ğ‘Œ0,1 â† ğ»1(pw, ğ‘›)
receive (ğ‘Œğ‘–,0, ğ‘Œğ‘–,1, ğœ‹ğ‘–) from Rğ‘– âˆ€ğ‘– âˆˆ ğ‘ƒ
ğ‘—=0 Â¯ğ‘†ğ‘– ğ‘—
ğ‘— , âˆ€ğ‘– âˆˆ ğ‘ƒ
ğ‘†ğ‘– :=ğ‘¡âˆ’1
ensure âˆ€ğ‘– âˆˆ ğ‘ƒ : Vf(cid:169)(cid:173)(cid:171)crs,(cid:169)(cid:173)(cid:171) ğº
ğ¶0 :=ğ‘–âˆˆğ‘ƒâˆª{0}ğ‘Œ ğœ†ğ‘ƒ,ğ‘–
ğ¶ := SKE.Enc(ğ‘ 0, (ğ¶0, ğ¶1))
return (ğ‘›, ğ¶)
ğ‘–,0
(cid:170)(cid:174)(cid:172) , ğœ‹ğ‘–(cid:170)(cid:174)(cid:172)
, ğ¶1 :=ğ‘–âˆˆğ‘ƒâˆª{0}ğ‘Œ ğœ†ğ‘ƒ,ğ‘–
ğ‘†ğ‘–
ğ‘Œğ‘–,0
ğ‘Œğ‘–,1
ğ‘‹0
ğ‘‹1
ğ‘–,1
EncâŸ¨Â· Â· Â· , Rğ‘–(â€œencâ€, skğ‘–), Â· Â· Â·âŸ©, âˆ€ğ‘– âˆˆ [ğ‘š]
ensure KVf(ğ‘–, skğ‘–)
ğ‘›ğ‘– â†$ {0, 1}ğœ†
send ğ‘›ğ‘– to S
receive { ğ‘—, ğ‘›â€²
ensure ğ‘›ğ‘– = ğ‘›â€²
ğ‘› := ğ» ({ğ‘–, ğ‘›ğ‘– }ğ‘–âˆˆğ‘ƒâˆª{0})
ğ‘‹0 â† ğ»0(ğ‘›), ğ‘‹1 â† ğ»1(ğ‘›)
ğ‘Œğ‘–,0 â† ğ‘‹ ğ‘ ğ‘–0 , ğ‘Œğ‘–,1 â† ğ‘‹ ğ‘ ğ‘–1
ğ‘†ğ‘– := ğºğ‘ ğ‘–
ğ‘— } ğ‘—âˆˆğ‘ƒâˆª{0} from S
ğ‘–
ğœ‹ğ‘– â† Prove(cid:169)(cid:173)(cid:171)crs,(cid:169)(cid:173)(cid:171) ğº
ğ‘‹0
ğ‘‹1
send (ğ‘Œğ‘–,0, ğ‘Œğ‘–,1, ğœ‹ğ‘–) to S
return ğœ–
(cid:170)(cid:174)(cid:172) , ğ‘ ğ‘–(cid:170)(cid:174)(cid:172)
ğ‘†ğ‘–
ğ‘Œğ‘–,0
ğ‘Œğ‘–,1
Â· ğ‘€
Figure 3: Setup Algorithm and Encryption Protocol of TPHE
where ğ‘ â€²
0 is a fresh SKE secret key, and the following hold:
0
Hid
(cid:12)(cid:12)(cid:12) Pr(cid:104)
Pr(cid:104)
and a uniform password distribution PW with |PW| â‰¥ ğ‘„Dec,