0x00000209`4b3f2f60 ]
   +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000209`4b3f3b10 - 
0x00007fff`ff43a4f0 ]
   +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00007fff`ff2d0000 - 
0x00000000`00000000 ]
   +0x030 DllBase          : 0x00000000`001f5000 Void
   +0x038 EntryPoint       : 0x00000000`003c003a Void
   +0x040 SizeOfImage      : 0x4b3f2cc0
   +0x048 FullDllName      : _UNICODE_STRING "ntdll.dll"
   +0x058 BaseDllName      : _UNICODE_STRING "⸰䬿ȉ"
   +0x068 FlagGroup        : [4]  "???"
   +0x068 Flags            : 0xff43a280
   +0x068 PackagedBinary   : 0y0
   +0x068 MarkedForRemoval : 0y0
   +0x068 ImageDll         : 0y0
   +0x068 LoadNotificationsSent : 0y0
   +0x068 TelemetryEntryProcessed : 0y0
   +0x068 ProcessStaticImport : 0y0
   +0x068 InLegacyLists    : 0y0
   +0x068 InIndexes        : 0y1
   +0x068 ShimDll          : 0y0
   +0x068 InExceptionTable : 0y1
   +0x068 ReservedFlags1   : 0y00
   +0x068 LoadInProgress   : 0y0
   +0x068 LoadConfigProcessed : 0y1
   +0x068 EntryProcessed   : 0y0
   +0x068 ProtectDelayLoad : 0y1
   +0x068 ReservedFlags3   : 0y11
   +0x068 DontCallForThreads : 0y0
   +0x068 ProcessAttachCalled : 0y0
   +0x068 ProcessAttachFailed : 0y0
   +0x068 CorDeferredValidate : 0y0
   +0x068 CorImage         : 0y1
   +0x068 DontRelocate     : 0y0
   +0x068 CorILOnly        : 0y1
   +0x068 ChpeImage        : 0y1
   +0x068 ReservedFlags5   : 0y11
   +0x068 Redirected       : 0y1
   +0x068 ReservedFlags6   : 0y11
   +0x068 CompatDatabaseProcessed : 0y1
   +0x06c ObsoleteLoadCount : 0x7fff
   +0x06e TlsIndex         : 0
   +0x070 HashLinks        : _LIST_ENTRY [ 0x00000000`a280d1d6 - 
0x00000000`00000000 ]
   +0x080 TimeDateStamp    : 0
   +0x088 EntryPointActivationContext : 0x00000209`4b3f2ef0 _ACTIVATION_CONTEXT
   +0x090 Lock             : 0x00000209`4b3f2ef0 Void
   +0x098 DdagNode         : 0x00000209`4b3f2ef0 _LDR_DDAG_NODE
   +0x0a0 NodeModuleLink   : _LIST_ENTRY [ 0x00000000`00000000 - 
0x00000000`00000000 ]
   +0x0b0 LoadContext      : (null) 
   +0x0b8 ParentDllBase    : 0x00000209`4b4070f8 Void
   +0x0c0 SwitchBackContext : (null) 
   +0x0c8 BaseAddressIndexNode : _RTL_BALANCED_NODE
   +0x0e0 MappingInfoIndexNode : _RTL_BALANCED_NODE
   +0x0f8 OriginalBase     : 0xf46857d4
   +0x100 LoadTime         : _LARGE_INTEGER 0x00000002`00000000
   +0x108 BaseNameHashValue : 0x800
   +0x10c LoadReason       : 0 ( LoadReasonStaticDependency )
   +0x110 ImplicitPathOptions : 0
   +0x114 ReferenceCount   : 0
   +0x118 DependentLoadFlags : 0xfdf023f0
   +0x11c SigningLevel     : 0x66 'f'
ntdll!_LDR_DATA_TABLE_ENTRY
   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000209`4b3f3b00 - 
0x00000209`4b3f2dd0 ]
   +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000209`4b3f4f30 - 
0x00000209`4b3f3b10 ]
   +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00007fff`fe180000 - 
0x00007fff`fe1970d0 ]
   +0x030 DllBase          : 0x00000000`000be000 Void
   +0x038 EntryPoint       : 0x00000000`00420040 Void
   +0x040 SizeOfImage      : 0x4b3f3670
   +0x048 FullDllName      : _UNICODE_STRING "KERNEL32.DLL"
   +0x058 BaseDllName      : _UNICODE_STRING "㕐䬿ȉ"
   +0x068 FlagGroup        : [4]  "`???"
   +0x068 Flags            : 0xff43a260
   +0x068 PackagedBinary   : 0y0
   +0x068 MarkedForRemoval : 0y0
   +0x068 ImageDll         : 0y0
跟进其结构，实现模块断链隐藏dll也是没问题的。
上述过程使用!dlls命令结果也是相同的：
   +0x068 LoadNotificationsSent : 0y0
   +0x068 TelemetryEntryProcessed : 0y0
   +0x068 ProcessStaticImport : 0y1
   +0x068 InLegacyLists    : 0y1
   +0x068 InIndexes        : 0y0
   +0x068 ShimDll          : 0y0
   +0x068 InExceptionTable : 0y1
   +0x068 ReservedFlags1   : 0y00
   +0x068 LoadInProgress   : 0y0
   +0x068 LoadConfigProcessed : 0y1
   +0x068 EntryProcessed   : 0y0
   +0x068 ProtectDelayLoad : 0y1
   +0x068 ReservedFlags3   : 0y11
   +0x068 DontCallForThreads : 0y0
   +0x068 ProcessAttachCalled : 0y0
   +0x068 ProcessAttachFailed : 0y0
   +0x068 CorDeferredValidate : 0y0
   +0x068 CorImage         : 0y1
   +0x068 DontRelocate     : 0y0
   +0x068 CorILOnly        : 0y1
   +0x068 ChpeImage        : 0y1
   +0x068 ReservedFlags5   : 0y11
   +0x068 Redirected       : 0y1
   +0x068 ReservedFlags6   : 0y11
   +0x068 CompatDatabaseProcessed : 0y1
   +0x06c ObsoleteLoadCount : 0x7fff
   +0x06e TlsIndex         : 0
   +0x070 HashLinks        : _LIST_ENTRY [ 0x00000000`0871fae9 - 
0x00000000`00000000 ]
   +0x080 TimeDateStamp    : 0
   +0x088 EntryPointActivationContext : 0x00000209`4b3f3610 _ACTIVATION_CONTEXT
   +0x090 Lock             : 0x00000209`4b3f3610 Void
   +0x098 DdagNode         : 0x00000209`4b3f3610 _LDR_DDAG_NODE
   +0x0a0 NodeModuleLink   : _LIST_ENTRY [ 0x00000000`00000000 - 
0x00000000`00000000 ]
   +0x0b0 LoadContext      : 0x00007fff`ff3ec3a4 _LDRP_LOAD_CONTEXT
   +0x0b8 ParentDllBase    : 0x00000209`4b406b08 Void
   +0x0c0 SwitchBackContext : 0x00000209`4b3f5f68 Void
   +0x0c8 BaseAddressIndexNode : _RTL_BALANCED_NODE
   +0x0e0 MappingInfoIndexNode : _RTL_BALANCED_NODE
   +0x0f8 OriginalBase     : 0x00000004`536cd652
   +0x100 LoadTime         : _LARGE_INTEGER 0x00000002`00004000
   +0x108 BaseNameHashValue : 0
   +0x10c LoadReason       : 0 ( LoadReasonStaticDependency )
   +0x110 ImplicitPathOptions : 0
   +0x114 ReferenceCount   : 0
   +0x118 DependentLoadFlags : 0xfdf023f0
   +0x11c SigningLevel     : 0x66 'f'
获取PEB
这里介绍几种常用的编程中调用PEB的方法，首先PEB结构庞杂，可以去http://bytepointer.com/resou
rces/tebpeb32.htm、http://bytepointer.com/resources/tebpeb64.htm 去下载别人整理好的头文
件，方便相关结构体调用。
NtQueryInformationProcess
NtQueryInformationProcess 是一个内核函数，用来查看进程信息，其结构体如下：
它的第二个参数可以是一个PROCESS_BASIC_INFORMATION的结构体：
__kernel_entry NTSTATUS NtQueryInformationProcess(
  [in]            HANDLE           ProcessHandle,
  [in]            PROCESSINFOCLASS ProcessInformationClass,
  [out]           PVOID            ProcessInformation,
  [in]            ULONG            ProcessInformationLength,
  [out, optional] PULONG           ReturnLength
);
该结构体的第二个参数是指向PEB的指针，所以我们便可以使用该方法来获取PEB的内容，demo如下：
汇编调用
对于获取PEB来说32位与64位并不相同，分别存放在fs与gs寄存器中，这里分别给出64位与32位的汇编
代码：
typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
#include "Windows.h"
#include "winternl.h"
typedef NTSTATUS(*MYPROC) (HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);
int main()
{
    HANDLE h = GetCurrentProcess();
    PROCESS_BASIC_INFORMATION ProcessInformation;
    ULONG lenght = 0;
    HINSTANCE ntdll;
    MYPROC GetProcessInformation;
    wchar_t commandline[] = L"C:\\windows\\system32\\notepad.exe";
    ntdll = LoadLibrary(TEXT("Ntdll.dll"));
    //resolve address of NtQueryInformationProcess in ntdll.dll
    GetProcessInformation = (MYPROC)GetProcAddress(ntdll, 
"NtQueryInformationProcess");
    //get _PEB object
    (GetProcessInformation)(h, ProcessBasicInformation, &ProcessInformation, 
sizeof(ProcessInformation), &lenght);
    //replace commandline and imagepathname
    ProcessInformation.PebBaseAddress->ProcessParameters->CommandLine.Buffer = 
commandline;
    ProcessInformation.PebBaseAddress->ProcessParameters->ImagePathName.Buffer = 
commandline;
    return 0;
}
X64：
x86：
因为vs默认支持x86汇编，这里来演示x64如何内联汇编查找PEB，这里的代码直接选择获取其参数：
然后定义主程序，缺少的部分去上面的那个文件里面去找：
GetPEBAsm64 proc
    push rbx
    xor rbx,rbx
    xor rax,rax
    mov rbx, qword ptr gs:[00000060h]
    mov rax, rbx
    pop rbx
    ret
GetPEBAsm64 endp
__asm
    {
    mov eax, dword ptr fs : [00000030h]
    mov peb, eax
}
.code
ProcParam PROC
mov rax, gs:[30h]      ; TEB from gs in 64 bit only
mov rax, [rax+60h]     ; PEB
mov rax, [rax+20h]     ; RTL_USER_PROCESS_PARAMETERS
ret
ProcParam ENDP
end
#include 
typedef struct _UNICODE_STRING {
    unsigned short Length;
    unsigned short MaximumLength;
    wchar_t* Buffer;
} UNICODE_STRING, * PUNICODE_STRING;
typedef struct _CURDIR {
    UNICODE_STRING DosPath;
这里可做你想要的任何修改，原结构如下：
    void* Handle;
} CURDIR, * PCURDIR;
typedef struct _RTL_USER_PROCESS_PARAMETERS {
    unsigned int MaximumLength;
    unsigned int Length;
    unsigned int Flags;
    unsigned int DebugFlags;
    void* ConsoleHandle;
    unsigned int ConsoleFlags;
    void* StandardInput;
    void* StandardOutput;
    void* StandardError;
    CURDIR CurrentDirectory;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;
PRTL_USER_PROCESS_PARAMETERS ProcParam(void);
int main(void)
{
    wprintf(L"%s\n", ProcParam()->CurrentDirectory.DosPath.Buffer);
}
typedef struct _RTL_USER_PROCESS_PARAMETERS
{
    DWORD                   MaximumLength;                 //0x00 
    DWORD                   Length;                        //0x04 