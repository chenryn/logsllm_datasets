code是什么。
1、向驱动发送一个 "d" 对应的 control code,驱动中对应的逻辑是根据之前 asw 构造的矩阵验证用户名。
2、验证密码开头是不是 d4iDaiwo_,是的话,开始验证密码。
3、验证通过的话,输出 flag is password。
4、到这里,结合驱动里的逻辑,我们发现 flag 跟用户名完全没关系,不用在意用户名及验证用户名相关的逻辑。
5、发送一个 "f" 对应的 control code 给驱动,传入的 buffer 里面的 status 设置为 0xA,驱动收到之后设置传入的
buffer 里面的 status 为 0xB,初始的 key 值是利用当前 SSDT 里 NtDeviceIoControlFile
的指针算出来的(基本的防hook),计算可知这个值是 0x1490。
6、对于密码里接下来的 32 个字符,每两位一组,看作一个 unsigned short 和 key 值 xor,把 xor 之后的 key 值传给驱动。
检查status是否被驱动设置为 0xC 了,如果是的话,再发一个 f 请求给驱动要求验证。驱动如果认为正确,会把 status 设置为 0xD。
驱动里把每次收到的 key 值作为 Big Endian 的 unsigned short
存到了数组里,然后按照每个数从低位到高位,其他升序的顺序填充进一个 16×16 的矩阵。
然后计算 AX,跟 B 比较,其中 A、B 是硬编码在驱动里的两个矩阵,X 是根据 flag 填充的矩阵。
最后计算 flag 程序如下:
    sage: user_expected
    [ 38  42  57  53  54  64  56  67  19  53  43  45  34  85  64  51]
    [ 48  46  67 116  90 100  58  74  57  86  52  50  67 105  52  96]
    [ 33  37  37  55  52  81  42  56  53  52  37  44  34  76  55  52]
    [ 42  24  27  63  72  64  45  48  37  36  39  37  40  71  46  62]
    [ 33  25  42  72  66  51  33  57  38  57  50  33  54  80  40  71]
    [ 24  48  45  63  62  87  58  59  61  64  43  54  58  85  63  63]
    [ 43  32  59  58  60  69  31  67  40  56  59  47  39  83  66  53]
    [ 50  41  35  82  90  92  44  71  75  71  65  50  53 112  69  98]
    [ 54  38  79  61  65  90  44  80  37  69  63  53  49  86  72  51]
    [ 43  54  35  71  68  74  34  66  47  45  62  43  35  85  73  78]
    [ 31  40  58  60  69  88  52  76  50  64  59  47  54  90  62  68]
    [ 47  36  41  58  61  69  32  45  36  38  43  46  14  79  48  62]
    [ 29  48  65  57  64  85  30  67  54  72  72  54  55  86  68  64]
    [ 61  46  60  76  74  74  53  53  47  58  50  69  33 106  69  72]
    [ 45  45  73  71  70 101  54  63  46  68  48  59  51  82  52  58]
    [ 30  46  58  65  61  80  39  55  51  71  52  48  60  76  46  62]
    sage: flag_expected
    [ 352  336  134  423  441  365  535    0  514  500  288  825  435  365  315  825]
    [ 524  452  184  525  518  491  709    0  715  638  430 1164  595  491  526 1164]
    [ 370  330  122  372  376  343  485    0  459  433  257  796  388  343  311  796]
    [ 297  294  138  320  343  348  460    0  469  425  247  753  381  348  302  753]
    [ 325  316  124  381  368  356  474    0  497  457  290  802  428  356  342  802]
    [ 431  383  134  460  436  414  553    0  539  517  304  937  474  414  379  937]
    [ 380  344  135  441  444  397  537    0  532  491  285  862  440  397  341  862]
    [ 465  458  181  496  496  481  647    0  654  606  368 1098  550  481  423 1098]
    [ 446  391  157  509  520  463  632    0  611  559  315  991  501  463  413  991]
    [ 399  370  165  432  420  397  590    0  552  525  323  913  464  397  328  913]
    [ 422  386  140  474  463  435  594    0  570  559  316  968  502  435  393  968]
    [ 326  311  144  345  374  322  481    0  476  445  276  755  384  322  281  755]
    [ 449  391  141  520  476  437  585    0  575  550  320  970  503  437  398  970]
    [ 430  421  181  491  526  447  614    0  642  583  360 1001  513  447  375 1001]
    [ 456  388  160  478  481  439  610    0  598  552  329  986  501  439  434  986]
    [ 417  365  137  457  420  397  533    0  532  497  307  900  466  397  395  900]
    sage: user_expected  flag_expected
    [0 1 1 0 1 1 1 0 1 0 0 1 0 1 0 1]
    [1 1 1 1 0 0 1 0 0 1 1 1 1 0 0 1]
    [1 0 0 1 1 1 1 0 1 1 1 1 1 1 1 1]
    [1 0 0 0 0 0 1 0 1 0 1 1 0 0 1 1]
    [0 0 1 0 0 1 0 0 1 1 0 1 1 1 1 1]
    [1 0 0 0 0 0 1 0 0 0 0 1 0 0 1 1]
    [0 1 0 0 1 1 1 0 1 1 0 1 0 1 0 1]
    [0 0 0 0 0 0 1 0 0 1 0 1 1 0 0 1]
    [1 1 0 0 0 1 0 0 0 0 0 1 0 1 0 1]
    [1 1 0 1 1 0 0 0 1 0 0 1 0 0 1 1]
    [0 1 0 1 1 1 1 0 1 1 0 1 0 1 0 1]
    [0 0 0 1 1 0 0 0 1 1 0 1 1 0 0 1]
    [0 0 0 1 0 1 0 0 0 0 0 1 1 1 1 1]
    [0 1 0 1 1 0 0 0 0 1 1 1 1 0 0 1]
    [1 0 0 1 1 1 1 0 1 0 0 1 0 1 0 1]
    [0 0 0 0 0 0 1 0 1 1 1 1 1 0 0 1]
    sage: flag = user_expected  flag_expected
    sage: %cpaste
    Pasting code; enter '--' alone on the line to stop or use Ctrl-D.
    :cur = 0x1490
    :ans = 'RCTF{d4iDaiwo_'
    :need = [int(''.join(map(lambda a: chr(ord('0')+a), list(x)[::-1])),2) for x in list(flag)]
    :for x in need:
    :       t = (x >> 8) | ((x & 0xFF) next;
            free(ptr);
        }
        result = puts("Your order has been submitted!");
    }
这里 printlog 可以用来泄漏信息,然后为了不崩溃,我们只要改掉 free 的 got 表,把程序强行跳转到读选项前面,开始新的一轮选择。  
当然这样是有副作用的,破坏了栈,会无限增长,不过我们不比太在意。
至此,有了几乎无限次任意可读地址内存泄漏,就可以 dynELF 找出 system 和 puts 的偏移,然后就利用之前那个劫持程序流就可以拿到
shell。
PS:这里泄漏便宜和拿 shell 可以用两个程序,反正偏移永远不会变,所以哪怕直接暴力跑 N 遍强行 dump 所有内存也是可以的,只是跑的久点而已。
**QQ (MISC 200)  
**
这题脑洞有多大真是怎么吐槽都不觉得过,最后一小时的时候,为了保准不被 217 绝杀(因为感觉很可能他们有藏
flag,而我们却没有任何底牌了,完全就是任人鱼肉的感觉),这题是我们认定的希望,于是最后又再次围了一群人上去脑洞这题,然而尝试遍各种我们自己都不信的方法,终究没能对上出题人的脑电波(求众筹砍出题人,往死里砍!)。
最后比赛结束后才知道,竟然是用 颜色值 * 宽度 求和,然后就得到 QQ,看看资料就有 flag。
这题不得不说很佩服 217 的脑洞能力,这种 xjb 乱猜的题也能那么快猜出来……
****
**Load (MOBILE 350)**
这题真是想到就心酸……
本来在 QQ 那题 YY 不出来之后,已经打算听天由命了(诸葛老师还提前表示比赛结束,浪费好多感情 (>_>)),然而最后三分钟的时候,某人表示拿到
android 350 的一个 key
不知道怎么用,然后立刻被我们团团围住,然后给了个方法立刻试了下,就看到手机突然弹出个网页(想来十有八九上面就直接写着个
flag),然而由于之前在实验室干活的时候,配置了 burp 的代理一直没有关,导致网页没能打开,于是……
就在我们激动不已的时候,一个悲剧悄然来袭。某人赶忙拿起手机,就在尝试去关 burp
代理的时候,屏幕一黑!我去,数据线由于动作太大断开了一下,这个手机电池坏了的有木有!!!
赶忙从旁边又拿了个安卓手机过来,想要补救,旁边电脑都打开提交页面准备好了,然而由于太急,手忙脚乱,刚开始连题目给的 apk
都忘记装了。然后就听到旁边某人喊了一句,217
反超了,然后不解释就更乱了,于是终究没能反绝杀……感觉这就是命吧,都是太激动惹的祸,想来以后也不太能再有这么好的机会了……
吐槽完毕,下面进入正题:
首先查看 AndroidManifest.xml
唯一一个被 permission 保护的服务
Permission 没有被保护
使用 permission bindService