以下是优化后的文本，使其更加清晰、连贯和专业：

### 参考文献

1. Valentin Rothberg. 生成用于容器的 SECCOMP 配置文件：使用 Podman 和 eBPF。[在线]。访问日期：2019 年 10 月 15 日。链接: <https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.html>。

2. Robert N. M. Watson. 利用系统调用包装器中的并发漏洞。*USENIX 攻击技术研讨会 (WOOT)*, 2007 年。

3. Jerome H. Saltzer 和 Michael D. Schroeder。计算机系统中信息保护。*IEEE Transactions on Computers*, 卷 63, 期 9, 页 1278-1308, 1975 年。

4. Pawel Sarbinowski, Vasileios P. Kemerlis, Cristiano Giuffrida, 和 Elias Athanasopoulos。VTPin: 二进制文件的实际 VTable 劫持防护。*年度计算机安全应用会议 (ACSAC)*, 页 448-459, 2016 年。

5. Felix Schuster, Thomas Tendyck, Christopher Liebchen, Lucas Davi, Ahmad-Reza Sadeghi, 和 Thorsten Holz。伪造面向对象编程：C++ 应用程序中防止代码重用攻击的难度。*IEEE 安全与隐私研讨会 (S&P)*, 页 745-762, 2015 年。

6. Hovav Shacham。无辜肉体的几何学：x86 上无需函数调用的返回到 libc 技术。*ACM 计算机与通信安全会议 (CCS)*, 页 552-561, 2007 年。

7. Hashim Sharif, Muhammad Abubakar, Ashish Gehani, 和 Fareed Zaffar。TRIMMER：应用程序专业化以减少代码膨胀。*IEEE/ACM 自动化软件工程国际会议 (ASE)*, 页 329-339, 2018 年。

8. Kevin Z. Snow, Fabian Monrose, Lucas Davi, Alexandra Dmitrienko, Christopher Liebchen, 和 Ahmad-Reza Sadeghi。即时代码重用：细粒度地址空间布局随机化的有效性。*IEEE 安全与隐私研讨会 (S&P)*, 页 574-588, 2013 年。

9. Peter Snyder, Cynthia Taylor, 和 Chris Kanich。大多数网站不需要振动：一种改进浏览器安全的成本效益方法。*ACM 计算机与通信安全会议 (CCS)*, 页 179-194, 2017 年。

10. Brad Spengler。PaX：任意代码执行的终结。*G-Con2*, 2003 年。

11. Guy Lewis Steele Jr. 揭穿“昂贵的过程调用”神话或过程调用实现的危害性或 LAMBDA：终极 GOTO。*ACM 全国会议*, 页 153-162, 1977 年。

12. Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu, 和 Zhendong Su。Perses：语法引导的程序缩减。*国际软件工程会议 (ICSE)*, 页 361-371, 2018 年。

13. Debian。通用操作系统。不稳定发行版（“sid”）。[在线]。访问日期：未指定。链接: <https://www.debian.org/releases/sid/>。

14. László Szekeres, Mathias Payer, Tao Wei, 和 Dawn Song。SoK：内存中的永恒战争。*IEEE 安全与隐私研讨会 (S&P)*, 页 48-62, 2013 年。

15. Chia-Che Tsai, Bhushan Jain, Nafees Ahmed Abdul, 和 Donald E. Porter。现代 Linux API 使用和兼容性的研究：支持什么。*欧洲计算机系统会议 (EuroSys)*, 页 1-16, 2016 年。

16. David Wagner 和 Drew Dean。通过静态分析进行入侵检测。*IEEE 安全与隐私研讨会 (S&P)*, 页 156-168, 2000 年。

17. Zhiyuan Wan, David Lo, Xin Xia, Liang Cai, 和 Shanping Li。挖掘 Linux 容器的沙箱。*国际软件测试、验证与验证会议 (ICST)*, 页 92-102, 2017 年。

18. Debian Wiki。使用符号文件。[在线]。访问日期：未指定。链接: <https://wiki.debian.org/UsingSymbolsFiles>。

19. David Williams-King, Graham Gobieski, Kent Williams-King, James P. Blake, Xinhao Yuan, Patrick Colp, Michelle Zheng, Vasileios P. Kemerlis, Junfeng Yang, 和 William Aiello。Shuffler：快速且可部署的连续代码重新随机化。*USENIX 操作系统设计与实现研讨会 (OSDI)*, 页 367-382, 2016 年。

20. David Williams-King, Hidenori Kobayashi, Kent Williams-King, Graham Patterson, Frank Spano, Yu Jian Wu, Junfeng Yang, 和 Vasileios P. Kemerlis。Egalito：布局无关的二进制重新编译。*ACM 编程语言和操作系统架构支持国际会议 (ASPLOS)*, 页 133-147, 2020 年。

21. Xiaoyang Xu, Masoud Ghaffarinia, Wenhao Wang, Kevin W. Hamlen, 和 Zhiqiang Lin。CONFIRM：评估现代软件控制流完整性保护的兼容性和相关性。*USENIX 安全研讨会 (SEC)*, 页 1805-1821, 2019 年。

22. Yves Younan, Wouter Joosen, 和 Frank Piessens。针对 C 和 C++ 程序的代码注入攻击的运行时对策。*ACM 计算调查 (CSUR)*, 卷 44, 期 3, 页 1-28, 2012 年。

23. Qiang Zeng, Zhi Xin, Dinghao Wu, Peng Liu, 和 Bing Mao。定制的应用特定系统调用表。技术报告，宾夕法尼亚州立大学, 2014 年。

24. Hanqing Zhao, Yanyu Zhang, Kun Yang, 和 Taesoo Kim。打破所有层次的乌龟：一个从 VMware ESXi 中逃脱的利用链。*USENIX 攻击技术研讨会 (WOOT)*, 2019 年。

### A. 特殊情况

**GNU IFUNC**

GCC、GNU Binutils 和 glibc 提供了对间接函数的支持，这是一种 GNU 特定功能。这些符号类型为 STT_GNU_IFUNC，并有一个关联的解析器函数，该函数将在运行时通过 PLT 解析出实际的目标函数。IFUNC 通常用于自定义 ld.so 的符号解析，并选择不同的处理器特定功能实现。

sysfilter 将每个调用链接到一个 IFUNC PLT 条目，包括：
1. 相应的解析器函数。
2. 在 VCG 中的所有潜在目标 —— 这些目标很容易识别，因为它们是解析器中取地址的函数。

**GNU NSS**

名称服务切换 (NSS) [45] 由 glibc 用于选择不同的名称解析机制（例如，平面文件数据库、DNS、LDAP）。glibc 会咨询 nsswitch.conf 文件来确定各种数据库（如 passwd、shadow、group、hosts 等）与解析机制（如 files、dns、ldap）之间的映射。每种机制对应一个不同的动态共享对象（如 libnss_files.so、libnss_dns.so、libnss_ldap.so），提供特定的 NSS API 实现。根据 nsswitch.conf 的内容，glibc 会使用 dlopen 加载相应的 .so ELF 文件，并通过 dlsym 获取相关函数的地址后调用它们。sysfilter 解析 nsswitch.conf，并利用隐式的库/函数依赖机制将匹配的 ELF 对象和函数添加到分析范围 (§ 3.1.1) 和 VCG (§ 3.1.2) 中。

**重叠函数**

某些版本的 glibc 包含一些函数体与其他函数重叠的函数。例如，在 glibc v2.24 中，大约有 30 个函数完全嵌入在其他函数内部（如 connect 包含 __connect_nocancel）。当 f1() 与 f2() 重叠且 &f1() < &f2() 时，两个函数都可以被直接或间接调用，但如果 f1() 被执行，f2() 也会被调用，因为执行会落入后者。sysfilter 通过仔细检查函数边界（.eh_frame 部分；§ 3.1.2）并相应地连接 DCG 中的相关函数来支持这种情况。

**手写汇编**

只要手写汇编代码符合我们的加固假设 (§ 2)，对 sysfilter 来说并不是问题。sysfilter 不支持非位置无关代码 (PIC) 对象 (§ 3.1.1)；因此，如果分析嵌入在二进制文件中的汇编代码，它将是 PIC 的。如果缺少 .eh_frame 记录（对于手写汇编）或者代码和数据混合，那么我们的分析精度将会受到影响。然而，幸运的是，链接到流行二进制文件/库的手写汇编代码通常包含支持堆栈展开和 C++ 异常处理的注释 [49]。最后，如果有关函数边界的部分信息可用，sysfilter 将采用线性和递归反汇编技术以及最先进的启发式方法 [94] 来近似函数边界。

### B. 强制实施细节

```c
struct seccomp_data {
    int nr;                   // 系统调用号
    __u32 arch;               // 架构 (x86-64)
    __u64 instruction_pointer; // 执行系统调用时的指令指针值 (%rip)
    __u64 args[6];            // 系统调用参数 (寄存器 %rdi, %rsi, %rdx, %r10, %r8, %r9)
};

#define ARCH AUDIT_ARCH_X86_64
#define NRMAX (X32_SYSCALL_BIT - 1)
#define ALLOW SECCOMP_RET_ALLOW
#define DENY SECCOMP_RET_KILL_PROCESS

struct sock_filter filter[] = {
    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, arch)),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, ARCH, 0, 7),
    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, nr)),
    BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 61, 11, 0),
    BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 8, 0, 2),
    BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 2, 19, 14),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 1, 0, 18),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 0, 17, 16),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 3, 0, 17),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 2, 0, 2),
    BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 11, 14, 12),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 9, 0, 21),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 8, 13, 14),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 56, 0, 12),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 11, 0, 23),
    BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 115, 5, 0),
    BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 96, 0, 2),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 79, 8, 7),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 61, 7, 8),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 102, 6, 6),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 96, 5, 0),
    BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 292, 2, 0),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 202, 3, 32),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 115, 2, 3),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 317, 1, 34),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 292, 0, 1),
    BPF_STMT(BPF_RET | BPF_K, ALLOW),
    BPF_STMT(BPF_RET | BPF_K, DENY)
};
```

图 9 显示了一个经典 BPF (cBPF) 程序，由 sysfilter 编译，强制执行以下系统调用集合：
- 0 (read)
- 1 (write)
- 2 (open)
- 3 (close)
- 8 (lseek)
- 9 (getuid)
- 11 (mmap)
- 56 (munmap)
- 61 (clone)
- 79 (wait4)
- 96 (getcwd)
- 102 (gettimeofday)
- 115 (dup3)
- 202 (getgroups)
- 292 (futex)
- 317 (seccomp)

过滤器检查字段 `nr` 是否属于 {0,1,2,3,8,9,11,56,61,79,96,102,115,202,292,317}。`BPF_JEQ` 语句断言 `nr` 是否是 16 个允许的系统调用之一，而 `BPF_JGE` 语句实现了搜索过程中的“快捷方式”。

图 8 显示了 `struct seccomp_data` 结构，该结构由 Linux 内核在每次系统调用时传递给 seccomp-BPF 过滤器。字段 `nr` 填充了系统调用号，而 `arch` 和 `instruction_pointer` 分别填充了执行系统调用时的架构和指令指针值（即 x86-64 中的 AUDIT_ARCH_X86_64 和 %rip）。同样，`args[6]` 是一个六元素数组，填充了系统调用参数（即 x86-64 中的寄存器 %rdi, %rsi, %rdx, %r10, %r8, 和 %r9）。

希望这些修改能使您的文本更加清晰、连贯和专业。