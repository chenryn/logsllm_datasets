[75] Valentin Rothberg. Generate SECCOMP Proﬁles for Containers Us-
ing Podman and eBPF. https://podman.io/blogs/2019/10/15/
generate-seccomp-profiles.html.
[92] Robert N. M. Watson. Exploiting Concurrency Vulnerabilities in Sys-
tem Call Wrappers. In USENIX Workshop on Offensive Technologies
(WOOT), 2007.
[76] Jerome H. Saltzer and Michael D. Schroeder. The Protection of Infor-
mation in Computer Systems. IEEE, 63(9):1278–1308, 1975.
[77] Pawel Sarbinowski, Vasileios P. Kemerlis, Cristiano Giuffrida, and
Elias Athanasopoulos. VTPin: Practical VTable Hijacking Protection
for Binaries. In Annual Computer Security Applications Conference
(ACSAC), pages 448–459, 2016.
[78] Felix Schuster, Thomas Tendyck, Christopher Liebchen, Lucas Davi,
Ahmad-Reza Sadeghi, and Thorsten Holz. Counterfeit Object-oriented
Programming: On the Difﬁculty of Preventing Code Reuse Attacks in
C++ Applications. In IEEE Symposium on Security and Privacy (S&P),
pages 745–762, 2015.
[79] Hovav Shacham. The Geometry of Innocent Flesh on the Bone: Return-
into-libc without Function Calls (on the x86). In ACM SIGSAC Con-
ference on Computer and Communications Security (CCS), pages 552–
561, 2007.
[80] Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaf-
far. TRIMMER: Application Specialization for Code Debloating. In
IEEE/ACM International Conference on Automated Software Engineer-
ing (ASE), pages 329–339, 2018.
[81] Kevin Z. Snow, Fabian Monrose, Lucas Davi, Alexandra Dmitrienko,
Christopher Liebchen, and Ahmad-Reza Sadeghi. Just-In-Time Code
Reuse: On the Effectiveness of Fine-Grained Address Space Layout
Randomization. In IEEE Symposium on Security and Privacy (S&P),
pages 574–588, 2013.
[82] Peter Snyder, Cynthia Taylor, and Chris Kanich. Most Websites Don’t
Need to Vibrate: A Cost-Beneﬁt Approach to Improving Browser Secu-
rity. In ACM SIGSAC Conference on Computer and Communications
Security (CCS), pages 179–194, 2017.
[83] Brad Spengler. PaX: The Guaranteed End of Arbitrary Code Execution.
In G-Con2, 2003.
[84] Guy Lewis Steele Jr. Debunking the “Expensive Procedure Call” Myth
or, Procedure Call Implementations Considered Harmful or, LAMBDA:
The Ultimate GOTO. In ACM National Conference, pages 153–162,
1977.
[85] Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong
In International
Su. Perses: Syntax-Guided Program Reduction.
Conference on Software Engineering (ICSE), pages 361–371, 2018.
[86] Debian The Universal Operating System. The unstable distribution
(“sid”). https://www.debian.org/releases/sid/.
[87] László Szekeres, Mathias Payer, Tao Wei, and Dawn Song. SoK: Eter-
nal War in Memory. In IEEE Symposium on Security and Privacy
(S&P), pages 48–62, 2013.
[88] Chia-Che Tsai, Bhushan Jain, Nafees Ahmed Abdul, and Donald E.
Porter. A Study of Modern Linux API Usage and Compatibility: What
In European Conference on
to Support When You’re Supporting.
Computer Systems (EuroSys), pages 1–16, 2016.
[89] David Wagner and Drew Dean. Intrusion Detection via Static Analysis.
In IEEE Symposium on Security and Privacy (S&P), pages 156–168,
2000.
[90] Zhiyuan Wan, David Lo, Xin Xia, Liang Cai, and Shanping Li. Min-
ing Sandboxes for Linux Containers. In International Conference on
Software Testing, Veriﬁcation and Validation (ICST), pages 92–102,
2017.
[93] Debian Wiki. Using Symbols Files. https://wiki.debian.org/
UsingSymbolsFiles.
[94] David Williams-King, Graham Gobieski, Kent Williams-King, James P.
Blake, Xinhao Yuan, Patrick Colp, Michelle Zheng, Vasileios P. Ke-
merlis, Junfeng Yang, and William Aiello. Shufﬂer: Fast and Deploy-
able Continuous Code Re-Randomization. In USENIX Symposium on
Operating Systems Design and Implementation (OSDI), pages 367–382,
2016.
[95] David Williams-King, Hidenori Kobayashi, Kent Williams-King, Gra-
ham Patterson, Frank Spano, Yu Jian Wu, Junfeng Yang, and Vasileios P.
Kemerlis. Egalito: Layout-Agnostic Binary Recompilation. In ACM
SIGPLAN International Conference on Architectural Support for Pro-
gramming Languages and Operating Systems (ASPLOS), pages 133–
147, 2020.
[96] Xiaoyang Xu, Masoud Ghaffarinia, Wenhao Wang, Kevin W. Hamlen,
and Zhiqiang Lin. CONFIRM: Evaluating Compatibility and Relevance
of Control-ﬂow Integrity Protections for Modern Software. In USENIX
Security Symposium (SEC), pages 1805–1821, 2019.
[97] Yves Younan, Wouter Joosen, and Frank Piessens. Runtime Coun-
termeasures for Code Injection Attacks against C and C++ Programs.
ACM Computing Surveys (CSUR), 44(3):1–28, 2012.
[98] Qiang Zeng, Zhi Xin, Dinghao Wu, Peng Liu, and Bing Mao. Tailored
Application-speciﬁc System Call Tables. Technical report, Pennsylva-
nia State University, 2014.
[99] Hanqing Zhao, Yanyu Zhang, Kun Yang, and Taesoo Kim. Breaking
Turtles All the Way Down: An Exploitation Chain to Break out of
In USENIX Workshop on Offensive Technologies
VMware ESXi.
(WOOT), 2019.
A VCG Special Cases
GNU IFUNC GCC, along with the GNU Binutils and glibc,
provide support for (a GNU-speciﬁc feature, named) indi-
rect functions. Such symbols are of type STT_GNU_IFUNC
and have an associated resolver function that will “return”
the actual/target function to be used in lieu of the indirect
(IFUNC) symbol [31]. The resolution takes place via PLT,
at run-time; IFUNCs are typically used for customizing the
symbol resolution of ld.so, and selecting among different
function implementations that use processor-speciﬁc features.
sysfilter links every call via an IFUNC PLT entry with:
(1) the respective resolver function, and (2) all its potential
targets in VCG—the latter are easily identiﬁable as they are
functions whose address is taken in the resolver.
GNU NSS The Name Service Switch (NSS) [45] is used by
glibc to select among different name resolution mechanisms
(e.g., ﬂat-ﬁle databases, DNS, LDAP). Speciﬁcally, glibc
consults nsswitch.conf to determine the mapping between
various databases (i.e., passwd, shadow, group, hosts, etc.)
and resolution mechanisms (e.g., files, dns, ldap). Each
such mechanism corresponds to a different dynamic shared
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    473
object (e.g., libnss_files.so, libnss_dns.so, libnss_-
ldap.so), which provides a speciﬁc implementation of the
NSS API. Depending on the contents of nsswitch.conf,
glibc loads the analogous .so ELF ﬁle, using dlopen, and
invokes the relevant functions (NSS), after obtaining their ad-
dresses via dlsym. sysfilter parses nsswitch.conf, and
makes use of the implicit library/function dependency mech-
anism to add the matching ELF object(s) and function(s) in
the analysis scope (§ 3.1.1) and VCG (§ 3.1.2), respectively.
Overlapping Functions Certain versions of glibc include
functions whose body overlaps with that of other functions. In
particular, in v2.24 of glibc, ≈ 30 functions are completely
embedded inside others (e.g., connect wraps __connect-
_nocancel). In cases where, say, f1() overlaps with f2(),
and &f1() < &f2(), both functions can be (in)directly-
invoked by others, but if f1() gets executed, f2() will be
invoked as well, as the execution will fall through to the latter.
sysfilter supports such cases by carefully inspecting func-
tion boundaries (.eh_frame section; § 3.1.2), and connecting
the respective functions in DCG, accordingly.
Hand-written Assembly ASM code is not problematic for
sysfilter as long as it adheres to our hardening assumptions
(§ 2). sysfilter does not support non-PIC objects (§ 3.1.1);
hence, if ASM code that is embedded in binaries is analyzed,
it will be PIC (by construction). If .eh_frame records (for
hand-written ASM) are missing, or code and data are mixed,
then the precision of our analyses will be affected. Thankfully,
however, the (hand-written) ASM code that is linked-with
popular binaries/libraries oftentimes contains annotations to
support stack unwinding and (C++) exception handling [49].
Lastly, if partial information regarding function boundaries
is available, sysfilter will resort to using a combination of
linear and recursive disassembly techniques, and state-of-the-
art heuristics [94], for approximating function boundaries.
B Enforcement Details
1 struct seccomp_data {
2
3
4
5
6 };
int nr ;
__u32 arch ;
__u64 instruction_pointer ; /* IP value
__u64 args [6];
/* syscall number
*/
/* architecture (x86-64) */
*/
*/
/* syscall arguments
AUDIT_ARCH_X86_64
SECCOMP_RET_KILL_PROCESS
( offsetof (struct seccomp_data , nr ))) ,
( offsetof (struct seccomp_data , arch ))) ,
1 #define ARCH
2 #define NRMAX ( X32_SYSCALL_BIT - 1)
3 #define ALLOW SECCOMP_RET_ALLOW
4 #define DENY
5
6 struct sock_filter filter [] = {
7 BPF_STMT ( BPF_LD | BPF_W | BPF_ABS ,
8
9 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , ARCH , 0, 7) ,
10 BPF_STMT ( BPF_LD | BPF_W | BPF_ABS ,
11
0) ,
12 BPF_JUMP ( BPF_JMP | BPF_JGE | BPF_K , 61 , 11 ,
0) ,
5,
13 BPF_JUMP ( BPF_JMP | BPF_JGE | BPF_K , 8,
0) ,
2,
14 BPF_JUMP ( BPF_JMP | BPF_JGE | BPF_K , 2,
19 ,
15 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 1,
0) ,
18 , 19) ,
16 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 0,
17 ,
17 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 3,
0) ,
16 , 17) ,
18 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 2,
0) ,
2,
19 BPF_JUMP ( BPF_JMP | BPF_JGE | BPF_K , 11 ,
14 ,
20 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 9,
0) ,
21 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 8,
13 , 14) ,
12 ,
22 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 56 ,
0) ,
11 , 12) ,
23 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 11 ,
0) ,
24 BPF_JUMP ( BPF_JMP | BPF_JGE | BPF_K , 115 , 5,
0) ,
2,
25 BPF_JUMP ( BPF_JMP | BPF_JGE | BPF_K , 96 ,
0) ,
26 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 79 ,
8,
27 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 61 ,
7,
8) ,
0) ,
28 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 102 , 6,
6) ,
29 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 96 ,
5,
0) ,
30 BPF_JUMP ( BPF_JMP | BPF_JGE | BPF_K , 292 , 2,
0) ,
31 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 202 , 3,
32 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 115 , 2,
3) ,
0) ,
33 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 317 , 1,
34 BPF_JUMP ( BPF_JMP | BPF_JEQ | BPF_K , 292 , 0,
1) ,
35 BPF_STMT ( BPF_RET | BPF_K , ALLOW ),
36 BPF_STMT ( BPF_RET | BPF_K , DENY ) };
(mmap), 11
(munmap), 56
(clone), 61
following syscall
(gettimeofday), 102
(getcwd), 96
(getgroups), 202
Figure 9: Classic BPF (cBPF) Program. Compiled-
by sysfilter, enforcing the
set:
0 (read), 1 (write), 2 (open), 3 (close), 8 (lseek),
(wait4),
9
(getuid),
79
115
(dup3), and
317 (seccomp). The ﬁlter checks if the value of ﬁeld
nr ∈ {0,1,2,3,8,9,11,56,61,79,96,102,115,202,292,317}
via means of (deterministic) skip list-based search. The
BPF_JEQ statements assert if the value of nr is one of the 16
allowed syscalls, whereas BPF_JGE statements implement the
“shortcuts” in the search process.
(futex), 292
Figure 8: struct seccomp_data. Passed by the Linux
kernel to seccomp-BPF ﬁlters on every syscall. The ﬁeld
nr is ﬁlled with the system call number, while arch and
instruction_pointer are ﬁlled with the respective archi-
tecture, and value of the instruction pointer, during the time
of executing syscall (i.e., AUDIT_ARCH_X86_64 and %rip,
in x86-64). Likewise, args[6] is a six-element array, ﬁlled
with the syscall arguments (i.e., the values of registers %rdi,
%rsi, %rdx, %r10, %r8, and %r9, in x86-64).
474    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association