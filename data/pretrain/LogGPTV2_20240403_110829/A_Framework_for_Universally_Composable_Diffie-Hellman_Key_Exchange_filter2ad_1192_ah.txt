USA, August 18-22, 1996, Proceedings, ser. Lecture Notes in
Computer Science, vol. 1109. Springer, 1996, pp. 268–282.
[27] M. Abdalla, M. Bellare, and P. Rogaway, “The Oracle Difﬁe-
Hellman Assumptions and an Analysis of DHIES,” in Topics
in Cryptology - CT-RSA 2001, The Cryptographer’s Track at
RSA Conference 2001, San Francisco, CA, USA, April 8-12,
2001, Proceedings, ser. Lecture Notes in Computer Science,
vol. 2020. Springer, 2001, pp. 143–158.
[28] M. Backes, M. D¨urmuth, D. Hofheinz, and R. K¨usters,
“Conditional Reactive Simulatability,” International Journal
of Information Security (IJIS), vol. 7, no. 2, pp. 155–169,
April 2008.
[29] R. Canetti and M. Fischlin, “Universally Composable Com-
mitments,” in Advances in Cryptology—CRYPTO 2001, 21st
Annual International Cryptology Conference, ser. Lecture
Notes in Computer Science, vol. 2139. Springer, 2001, pp.
19–40.
[30] R. Canetti and H. Krawczyk, “Universally Composable No-
tions of Key Exchange and Secure Channels,” in Advances
in Cryptology - EUROCRYPT 2002, International Conference
on the Theory and Applications of Cryptographic Techniques,
Proceedings, ser. Lecture Notes in Computer Science, vol.
2332. Springer, 2002, pp. 337–351.
[31] E. Rescorla, “The transport layer security (TLS) protocol
version 1.3 (draft 09),” October 2015, https://tools.ietf.org/
html/draft-ietf-tls-tls13-09.
[32] H. Krawczyk, “Cryptographic Extraction and Key Derivation:
The HKDF Scheme,” in Advances in Cryptology - CRYPTO
2010, 30th Annual Cryptology Conference, Proceedings, ser.
Lecture Notes in Computer Science, T. Rabin, Ed., vol. 6223.
Springer, 2010, pp. 631–648.
[33] B. Blanchet, “An Efﬁcient Cryptographic Protocol Veriﬁer
Based on Prolog Rules,” in Proceedings of the 14th IEEE
Computer Security Foundations Workshop (CSFW-14).
IEEE
Computer Society, 2001, pp. 82–96.
[34] S. Meier, B. Schmidt, C. Cremers, and D. A. Basin, “The
TAMARIN Prover for the Symbolic Analysis of Security Pro-
tocols,” in Computer Aided Veriﬁcation - 25th International
Conference (CAV 2013), ser. Lecture Notes in Computer Sci-
ence, N. Sharygina and H. Veith, Eds., vol. 8044. Springer,
2013, pp. 696–701.
[35] C. J. F. Cremers, “The Scyther Tool: Veriﬁcation, Falsiﬁ-
cation, and Analysis of Security Protocols,” in Computer
Aided Veriﬁcation, 20th International Conference, CAV 2008,
Princeton, NJ, USA, July 7-14, 2008, Proceedings, ser. Lec-
ture Notes in Computer Science, vol. 5123. Springer, 2008,
pp. 414–418.
[36] N. Swamy, C. Hritcu, C. Keller, A. Rastogi, A. Delignat-
Lavaud, S. Forest, K. Bhargavan, C. Fournet, P. Strub,
M. Kohlweiss, J. K. Zinzindohoue, and S. Z. B´eguelin, “De-
pendent types and multi-monadic effects in F,” in Proceedings
of
the 43rd Annual ACM SIGPLAN-SIGACT Symposium
898
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:54 UTC from IEEE Xplore.  Restrictions apply. 
on Principles of Programming Languages, POPL 2016, St.
Petersburg, FL, USA, January 20 - 22, 2016. ACM, 2016,
pp. 256–270.
[37] N. Swamy, J. Chen, C. Fournet, P. Strub, K. Bhargavan,
and J. Yang, “Secure distributed programming with value-
dependent types,” J. Funct. Program., vol. 23, no. 4, pp. 402–
451, 2013.
[38] J. Bengtson, K. Bhargavan, C. Fournet, A. D. Gordon, and
S. Maffeis, “Reﬁnement Types for Secure Implementations,”
in Proceedings of the 21st IEEE Computer Security Founda-
tions Symposium, CSF 2008.
IEEE Computer Society, 2008,
pp. 17–32.
[39] R. K¨usters, T. Truderung, and J. Graf, “A Framework for
the Cryptographic Veriﬁcation of Java-like Programs,” in
25th IEEE Computer Security Foundations Symposium (CSF
2012).
IEEE Computer Society, 2012, pp. 198–212.
[40] M. Bellare and P. Rogaway, “Entity Authentication and Key
Distribution,” in Advances in Cryptology – Crypto ’93, 13th
Annual International Cryptology Conference, ser. Lecture
Notes in Computer Science, D. Stinson, Ed., vol. 773.
Springer-Verlag, 1993, pp. 232–249.
[41] R. Canetti and H. Krawczyk, “Analysis of Key-Exchange
Protocols and Their Use for Building Secure Channels,” in
Advances in Cryptology – EUROCRYPT 2001, ser. Lecture
Notes in Computer Science, B. Pﬁtzmann, Ed., vol. 2045.
Springer, 2001, pp. 453–474.
[42] C. J. F. Cremers and M. Feltz, “Beyond eCK: Perfect
Forward Secrecy under Actor Compromise and Ephemeral-
Key Reveal,” in Computer Security - ESORICS 2012 - 17th
European Symposium on Research in Computer Security, ser.
Lecture Notes in Computer Science, S. Foresti, M. Yung, and
F. Martinelli, Eds., vol. 7459. Springer, 2012, pp. 734–751.
[43] G. Barthe, B. Gr´egoire, S. Heraud, and S. Z. B´eguelin,
“Computer-Aided Security Proofs for the Working Cryp-
tographer,” in Advances in Cryptology - CRYPTO 2011 -
31st Annual Cryptology Conference, Santa Barbara, CA,
USA, August 14-18, 2011. Proceedings, ser. Lecture Notes
in Computer Science, vol. 6841. Springer, 2011, pp. 71–90.
[44] B. Blanchet, “A Computationally Sound Mechanized Prover
for Security Protocols,” in IEEE Symposium on Security and
Privacy (S&P 2006).
IEEE Computer Society, 2006, pp.
140–154.
[45] R. Canetti and S. Gajek, “Universally Composable Symbolic
Analysis of Difﬁe-Hellman based Key Exchange,” Cryptology
ePrint Archive, Tech. Rep. 2010/303, 2010, available at http:
//eprint.iacr.org/2010/303.
[46] R. Canetti and H. Krawczyk, “Security Analysis of IKE’s
Signature-Based Key-Exchange Protocol,” in Advances in
Cryptology - CRYPTO 2002, 22nd Annual International Cryp-
tology Conference, ser. Lecture Notes in Computer Science,
M. Yung, Ed., vol. 2442. Springer, 2002, pp. 143–161.
APPENDIX
A. Proof Sketch of Theorem 2
As mentioned before, one of the key ideas for the deﬁni-
tion of the simulator S is to provide gc for unknown Difﬁe-
Hellman keys, where c is choosen uniformly at random
from {1, . . . , n}, and gab for known ones. The proof itself
consists of series of hybrid systems where we replace parts
of the realization with the version used in the ideal protocol
and then show that no environment can distinguish this
replacement with more than a negligible probability.
In the ﬁrst step, one deﬁnes a hybrid system P 1
crypto where
all asymmetric operations and nonce generation is handled
as in Fcrypto while all other operations are performed as in
Pcrypto. Because we did not modify any of these operations,
the original proof still holds, which reduced this step to the
security of the asymmetric operations.
Next, one deﬁnes a hybrid system P 2
crypto where also
exponent handling is replaced with the ideal version. In
particular, P 2
crypto prevents exponent guessing and collisions.
Any distinguishing environment on this system can be re-
duced to the DDH assumption: If the environment manages
to guess an exponent, or an unknown exponent is generated
that is not fresh, then this can be used by an attacker on
the DDH assumption to calculate the secret exponent a
from the experiment. We note that this reduction requires
a lot of attention to details and is more involved than
usual reductions to the DDH assumption. This is because
P 2
crypto can be used by the environment to perform several
operations with a and ga that are not available in the DDH
experiment; an adversary must be able to simulate all of
these operations without actually knowing a.
In the the third hybrid system P 3
crypto one replaces real with
ideal Difﬁe-Hellman key generation, however, without pre-
venting key collisions or key guessing. That is, the simulator
provides the Difﬁe-Hellman keys as described above. This
step requires a hybrid argument itself, as we have to replace
a polynomial number of unknown keys in the order of their
creation. We can then reduce the distinguishing advantage
of an environment for the r-th and r + 1-th hybrid system
to the DDH assumption. Importantly, we have to establish
a single negligible bound for the distinguishing advantage
that is independent of r, as the sum of polynomially many
different negligible functions is not necessarily negligible.
Just as in the previous step, the reduction in this step requires
a lot of care for details as there are several operations in the
hybrid systems that an adversary on the DDH assumption
has to simulate without knowing the secret exponents a and
b of the DDH experiment.
In the fourth hybrid system P 4
crypto, symmetric encryption
and key derivation are replaced with their ideal versions,
and key guessing and key collision are prevented. Again,
this step requires a hybrid argument which is quite in-
volved as we have to consider symmetric encryption and
899
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:54 UTC from IEEE Xplore.  Restrictions apply. 
, lsid(cid:2)
, lsid(cid:2)
, lsid(cid:2)
, r(cid:2)): As (pid(cid:2)
(pid R, lsid R, R) (cid:6)= (pid(cid:2)
, r(cid:2)) as x (cid:6)= y (gx is blocked
when gy is generated). Thus, we conclude that r(cid:2) = I.
We still have to argue that (pid R, lsid R, R) is already in a
global session with (pid(cid:2)
, r(cid:2)) has
signed a message, it has already completed its part of the
key exchange and thus is in a session with some responder.
By the deﬁnition of S, this will be the honest instance of
(cid:2) = (gx, gy, pid(cid:2)).
a responder that signed the message m
the instance (pid R, lsid R, R) is the only one
However,
that would sign such a message as y/gy is unique, so
(pid(cid:2)
, lsid(cid:2)
, r(cid:2)) is in a session with (pid R, lsid R, R). Note
that both instances use the same unknown exponents x and
y to derive a session key, with x (cid:6)= y, and they are never
paired with any other DH shares. Thus both instances will
output pointers to the same unknown session key.
Now consider an honest instance in the key usage phase.
As shown above, such an instance in the real world/internal
simulation will have a pointer to an unknown session key in
Fcrypto. Furthermore, no instance besides the two instances
in the same session will have access to this pointer as no
other instances have a pointer to x or y. Thus, instances in
the real world behave just like instances in the ideal world
that use F(cid:2)
crypto, i.e., the simulation is perfect also in this
case.
Finally consider a corrupted instance. The simulator has
full control over the I/O interface of such an instance. If the
instance was explicitly corrupted by the adversary (i.e., it is
under the control of the adversary) either before or after the
key exchange, the adversary gets access only to known keys
which do not exist in F(cid:2)
crypto. Thus, the simulator is able
to simulate the exact behavior of Fcrypto for such explicitly
corrupted instances. In the case of a corrupted instance that
was not explicitly corrupted by the adversary (i.e., where one
of the signing keys is corrupted), the simulator also has to
simulate unknown keys. However, these unknown keys will
never be inserted into/used in F(cid:2)
crypto as no honest instance
will complete a KE with a corrupted instance (as shown
above). Thus, the simulator can also easily simulate this
case.
We note that S is a responsive simulator as it fulﬁlls the
runtime conditions and it responds immediately to restricting
messages as long as the environment does the same, which
happens with overwhelming probability. This concludes the
proof.
key derivation simultaneously: All symmetric keys can be
encrypted, thus the security of symmetric keys depends on
the security of the encryption scheme. However, Difﬁe-
Hellman keys and key derivation keys can be used to create
new symmetric keys, i.e., the security of the encryption
scheme in turn depends on the security of the key derivation
schemes. In the hybrid argument, we track the order in
which unknown keys are used for the ﬁrst time. The r-th
hybrid system performs operations with the ﬁrst r unknown
keys ideally, and all other operations as in the realization.
One can then reduce the distinguishing advantage of an
environment for the r-th and r + 1-th hybrid system to
the security games of the encryption and key derivation
schemes. Again, it is important to establish a negligible
bound for the distinguishing advantage that is independent
of r.
In the ﬁnal step, we have to replace MACs with their ideal
versions. As this step is unaffected by our extension, just as
the ﬁrst step, the original proof still holds, which reduced
this step to the security of the MAC scheme.
B. Postponed cases of the proof of Theorem 3
, lsid(cid:2)
i.e.,
, lsid(cid:2)
, say (pid(cid:2)
We still have to show that the simulation is perfect in case
of an uncorrupted instance of a responder during the key
establishment phase, in case of uncorrupted instances during
the key usage phase, and in case of corrupted instances.
Let (pid R, lsid R, R) be an uncorrupted instance of MR
that wants to establish a session with pid(cid:2)
. We only have
to show that (pid R, lsid R, R) is already part of a global
session in F MA
key-use when it outputs a pointer to the session
key, as every action up to that point can be simulated
perfectly. Observe that, if (pid R, lsid R, R) outputs such a
pointer, then it has accepted the third protocol message
and pid(cid:2)
must still be uncorrupted. In other words, there
is an instance of pid(cid:2)
, r(cid:2)), that has signed
the message m = (gy, gx, pid R), where y is the secret
exponent of (pid R, lsid R, R) and x is the secret exponent
of (pid(cid:2)
, r(cid:2)). This instance is uncorrupted by the same
this instance is
argument as above. We now argue that
an initiator, i.e., r(cid:2) = I: Suppose by contradiction that
r(cid:2) = R,
the message was signed by a responder
whose secret exponent is x and who has received the group
element gy. Recall that, when such an instance receives
gy, it ﬁrst uses the BlockGroupElement command on gy.
Thus, afterwards no instance will be able to generate gy
via a GenExp command. Hence, the instance (pid(cid:2)
, r(cid:2))
cannot have received its ﬁrst protocol message before the
instance (pid R, lsid R, R) has received its ﬁrst protocol
message, as in this case (pid R, lsid R, R) would no longer
be able to create the exponent y. By the same argument,
(pid(cid:2)
, r(cid:2)) also cannot have received its ﬁrst protocol
message after (pid R, lsid R, R) has received its ﬁrst protocol
message, as in this case (pid(cid:2)
, r(cid:2)) would not be able
to create the secret exponent x. Of course, we also have that
, lsid(cid:2)
, lsid(cid:2)
, lsid(cid:2)
900
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:54 UTC from IEEE Xplore.  Restrictions apply.