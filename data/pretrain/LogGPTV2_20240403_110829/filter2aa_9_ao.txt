本文要介绍的身份认证协议也叫Kerberos，它有着非常广泛的应用，比如Windows域环境的身份认证就会用到它。我们用域账号登录电脑，就在不知不觉间完成了一次Kerberos认证过程。
Kerberos的认证结果是双向的—当账号A访问资源B时，不但B要确保A并非冒充，而且A也要查明B不是假货。我们一般只知道前者，比如前文提到的CIFS服务器就要在Session Setup中对造访者验明正身。后者则很少被提及，因为人们一般不会怀疑自己要访问的资源是假的。其实后者还是很有必要的，举一个例子：如果你老板伪造了一台网络打印机，但是你没法确认它的真假，就可能把求职信打到他办公室里去，然后就真的得出去求职了。西游记中其实也出现需要相互认证的场景，比如如来佛祖要认出假冒的访问者六耳猕猴，唐僧师徒也要识别山寨的“资源”小雷音寺。
双向认证的方式不止一种，最简单的做法是互报密码。这个过程就像电影中用暗号接头。A说：“江南风光好”，B说：“遍地红花开”。如果双方都核对无误，就可以激动地握手“同志，我可找到你了！”假如其中一方报错暗号，则接头失败。这种方式的弊端很多，最大的问题是不方便管理。比如在一个数百名员工共享几百台机器的环境中，当新加入一名员工时，就得在几百台机器上更新账号信息。相信没有管理员能忍受这样的环境。
有没有办法做得更好呢？Kerberos采用的方法是引入一个权威的第三方来负
 责身份认证。这个第三方称为KDC，它知道域里所有账号和资源的密码。假如账号A要访问资源B，只要把KDC拉出来证明双方身份就行了。在这种机制下，A 和B都没必要知道对方的密码，完全依赖KDC就可以。
原理说起来简单，通过程序实行起来可就难了。事实上由于Kerberos过于复杂，从来没有一位技术作家能把它简单地表述出来。最文艺的Kerberos诠释当属麻省理工学院编的一出话剧，搜索一下“Kerberos 四幕话剧”就能找到它，但其实理解这话剧还是不容易。幸好有了Wireshark之后，可以使Kerberos的认证过程变得清晰很多。在下面的实验中，账号A是我的域账号linp1，资源B是一台叫CAVA的Windows服务器。账号A访问资源B其实就是linp1登录CAVA的过程。
第一步，账号A和KDC互相认证。
这可以看成一道有趣的小学奥数题：已知世界上只有A和KDC知道A的密码，如何利用该密码互相证明自己的身份？你也许会想到孔明和周瑜在手心对字，直接向对方亮出A的密码。但在网络环境中不能这样做，因为如果其中一方是假的，不就被套到真密码了吗？既要做到不说出密码，又要让对方知道自己拥有密码，应该怎样实现？Kerberos自有一套严密的办法。
1．账号A利用hash函数把密码转化成一把密钥，我们称它为Kclt。
2．用Kclt把当前时间戳加密，生成一个字符串。我们用“{时间戳} Kclt”来表示它。
3．把上一步生成的字符串“{时间戳} Kclt”、账号A 的信息，以及一段随机字符串发给KDC。这样就组成了Kerberos的身份认证请求AS_REQ。我们用下面这个公式来表示这个请求。AS_REQ =“{时间戳} Kclt”，“账号A的信息”，“随机字符串”
如图1所示，我实验室中的账户名字为linp1，本次生成的随机字符串是136224786。
图1
4．KDC收到AS_REQ之后，先读到账号A的信息“linp1”，于是便调出A的密码，再用同样的hash函数转化为Kclt。有了Kclt就可以解开“{时间戳} Kclt”了，如果能解开则说明该请求是由账号A生成的，因为其他账号不可能有Kclt可以加密。
Kerberos为什么要选用时间戳来加密，而不是其他呢？原因就是黑客可能在网络上截获字符串“{时间戳} Kclt”，然后伪装成账户A来骗认证。这种方式称为重放攻击。重放攻击的伪装过程需要一段时间，所以KDC把解密得到的时间戳和当前时间作对比，如果相差过大就可以判断是重放攻击了。假如采用与时间无关的字符来加密，则无法避开重放攻击，这就是我们必须在域中同步所有机器时间的原因。
5．接下来轮到KDC向账号A证明自己的身份了，上文提到的随机字符串就用在这里。理论上KDC只要用Kclt加密随机字符串，再回复给账号A就可以证明自己的身份了。因为假的KDC是没有Kclt的，账户A拿到回复之后解不出那个随机字符串，就知道KDC有假。
总结以上过程，账号A和KDC都没有向对方发送密码，所以即便一方是假的也不会泄露信息。而如果双方都是真的，则实现了互相认证，可以算是完美了。不过这个机制下的KDC会非常忙碌，假设每次认证都得调出账号密码、hash、解
 密……而且每个客户端一天可能要验证数十次，那域中就得配备大量的KDC才负担得起。有没有办法进一步改进呢？Kerberos为此设计了一个精巧的方法。
a．KDC生成两把一样的密钥Kclt-Kdc，作为以后账户A和KDC之间互相认证之用，这样就省去了调出账号A的密码和hash等工作。按理说其中一把Kclt-Kdc要发给账户A保管，另一把由KDC自己保管。但是保管密钥对忙碌的KDC来说也是一个负担，所以它决定委托给账户A保管，以后账号A每次需要KDC的时候，再把这把密钥还回来。这个办法听上去不太靠谱，万一有个假冒的账户A交回来一把假密钥怎么办？为了避免这个问题，KDC把自己的密码hash 成Kkdc，然后用它加密那把委托给A的密钥。Kerberos里把这个委托的密钥称为TGT（Ticket Granting Ticket），可以用下面的公式来表示。
TGT = {账户A相关信息，Kclt-kdc} Kkdc
有了这个委托保存的机制，KDC只需记得自己的Kkdc，就能解开委托给所有账号的TGT，从而获得与该账号之间的密钥。通过这个机制，KDC的工作负担就大大降低了。
总结下来，KDC回复给账户A 的AS_REP应包含以下信息（见图2）。
AS_REP=TGT, {Kclt-kdc,时间戳，随机字符串}Kclt
图2
 b．账户A收到AS-REP之后利用Kclt解密“{Kclt-kdc,时间戳，随机字符串} Kclt”。通过解开来的随机字符串和时间戳来确定KDC的真实性，然后把Kclt-kdc 和TGT保存起来备用。
第二步，账号A请KDC帮忙认证资源B。
1．这时应该发什么给KDC呢？首先TGT是肯定要交还给KDC的，其次还有账户A的相关信息、当前时间戳，以及要访问的资源B的信息（见图3）。这个请求在Kerberos 中称为TGS-REQ，可以用下面的公式表示。
TGS_REQ = TGT，{账户A相关信息，时间戳}Kclt-kdc，“资源B相关信息”
图3
2．KDC收到TGS-REQ之后，先用Kkdc解密TGT得到Kclt-kdc，再用Kclt-kdc解密出账号A的相关信息和时间戳来验证其身份。一旦认定账号A为真，就要想办法帮助A和B互相认证了。
3．KDC生成两把同样的密钥供A和B之间使用，我们就称这个密钥为Kclt-srv吧。其中一把密钥直接交给账号A，另一把委托A转交给资源B。为了确保A不会受到假的资源B所骗，Kerberos把B的密码hash成Ksrv，然后用它加密那把委托A转交给B的Kclt-srv，成为一张只有真正的B能解密的Ticket。总结起来，KDC给账号A的回复可以表示如下（见图4）。
Ticket = {账号A的信息，Kclt-srv}Ksrv
TGS_REP = {Kclt-srv}Kclt-kdc, Ticket
这里的“账号A的信息”可不仅仅包括名字，连A所在的Domain Groups都包含在里面。所以如果A属于很多个groups，TGS_REP包会非常大。
图4
4．账号A收到TGS_REP之后，先用Kclt-kdc解开{Kclt-srv}Kclt-kdc，从而得到Kclt-srv。Ticket留着发给资源B。接下来如果需要多次访问资源B，都可以使用同一个Ticket，而不需要每次都向KDC申请，这也大大降低了KDC的负担。
第三步，账号A和资源B互相认证。
1．到这一步就简单了。账号A给资源B发送“{账号A的信息，时间戳} Kclt-srv”以及上一步收到的Ticket。这个请求称为AP_REQ。
AP_REQ = “{账号A的信息，时间戳} Kclt-srv”，Ticket
2．如果资源B是假的，它是解不开Ticket的。如果资源B是真的，它可以用自己的密码生成Ksrv来解开Ticket，从而得到Kclt-srv。有了Kclt-srv就可以解开“{账号A的信息，时间戳} Kclt-srv”部分。这样资源B就可以确定账号A为真，然后 回复AP_REP来证明自己也是真的。
AP _REP = {时间戳}Kclt-srv
3．账号A利用Kclt-srv来解密AP_REP，再通过得到的时间戳来判断对方是否为真。
 第三步是抓不到网络包的，因为这个实验过程是用户linp1登录Windows服务器CAVA，第三步没有发生在网络上。假如接下来用户linp1访问CAVA之外的其他资源，比如访问网络共享，我们就能在Session Setup里找到AP_REQ和AP_REP了。如图5所示，我在Session Setup AndX Request包中点开Security Blob，就把AP_REQ显示出来了。
图5
如果这是你第一次认识Kerberos，我估计已经看得云里雾里了。请相信这是人类的正常反应，我给好几批工程师培训过Kerberos，几乎没有人能很快理清楚的。图6是整个认证过程的流程图，也许对理解会有所帮助。
图6
当你完全理解Kerberos之后，可能会意识到一个问题：不对啊，那么多加密
 信息都被Wireshark显示出来了，还有 什么安全可言？其实我是用linp1的密码生成了一个keytab文件，再用它来解密的。具体操作如下。
1．参照Wireshark的官方说明生成keytab文件，步骤请参考http://wiki. wireshark.org/Kerberos。
2．把这个文件和网络包放到同一个目录里。
3．打开Wireshark的Edit-->Preferences-->Protocols-->KRB5菜单，在图7所示的窗口勾上两个选项，然后输入keytab文件的名字。
图7
4．打开网络包，就能看到解密后的内容了。
这也是我喜欢Wireshark的原因之一，即使像Kerberos这么复杂的协议，它也能完全解析出来。这简直是域管理员的福音。我稍作回忆，就能想到很多处理过的Kerberos相关例子。
案例1：某客户可以用“\\”访问某文件服务器，但用了“\\”则不能访问。
 用了Wireshark抓包才知道，客户端用IP访问时用了NTLM作身份验证，而用域名访问时则用Kerberos。由于两种验证方法机制不同，所以结果也不一样。比如当客户端和服务器的时间没有同步时，Kerberos会认为该访问是重放攻击而拒绝访问，但NTLM不会。
案例2：一个域账号明明被加到某个组里，该组也被赋予访问文件夹的权限，但是该账号就是访问不了这个文件夹。
用Wireshark解密了AP_REQ之后，并没有看到那个组。很可能是用户登录（获得包含组信息的ticket）之后，才被加到那个组里的。让该用户注销后再登录，获得新Ticket就好了。
案例3：某台客户端加入域失败，查了很久都没找到原因。
用了Wireshark之后，在包里发现 “KRB5KRB_ERR_RESPONSE_TOO_BIG”的错误信息（见图8）。利用该报错很快就从微软的网站上找到了解决方案。
图8
TCP/IP的故事
我们生活在这样一个时代：只要连上网络，就可以和朋友交流，无论距离远近；也可以网购商品，发誓剁手都无济于事；还可以点评正在发生的大小事件，像皇上批阅奏章一样日理万机。用我们这一行的表达方式，可以说现代人的生活是基于网络的。
网络的流行很大程度上要归功于Vinton Cerf和Robert Kahn这对老搭档（见图1）。他们在20世纪70年代设计的TCP/IP协议奠定了现代网络的基石，也因此获得过计算机界的最高荣誉—图灵奖。
图1
说起来TCP/IP还不是这两位互联网之父的第一次合作。在此之前，他们一起参与了阿帕网的开发。阿帕网称得上现代网络的前身，当时谁也没有想到，颠覆阿帕网的竟是它的两位设计者。Robert后来回忆说，当他把工作重心从阿帕网转向TCP/IP时，身边的人都以为他的事业陷入低谷，而实际上那才是他事业的真正开始。
 Robert为人低调，每次接受采访都一本正经。Vinton热情外向，关于他的趣事很多。比如他和女友第一次约会时去了艺术博物馆。IT男Vinton在一幅大型作品前伫立良久，最后冒出一句评语：“这画真像一只巨大的新鲜汉堡包”，我们可以想象他的画家女友当时的表情。当然，找个技术青年当男友也不是一无是处。后来在他们的婚礼上，录音机突然卡壳了。Vinton终于发挥了一把特长，和伴郎一起到小房间修录音机了。互联网造福了世界，自然也包括Vinton自己的生活。因为夫妻俩都有听力缺陷，听电话非常吃力，电子邮件就为他们带来不少便利。
现在人们说到TCP/IP时，指的已经不止是TCP和IP两个协议，而是包括了Application Layer、Transport Layer、Internet Layer和Network AccessLayer的四层模型。TCP处于Transport Layer，而IP处于Internet Layer。鲜为人知的是，一开始这两个协议并没有分层，而是合在一起的。当时的计算机科学家Jon Postel对此批评说：