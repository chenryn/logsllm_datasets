protocol says to, and the computation result is sent to A.
If i0, i1 ∈ C, credi0 (cid:54)= ⊥, credi1 (cid:54)= ⊥
• CH(i0, i1, δ, M ):
δ nor i1
δ is used, the following happens.
and neither i0
δ with password pwib and credib computes
The instance ib
what the protocol says to, and sends back the output of
the computation to A.
For any above query, if this query causes the client or the
instance to accept or terminate, this will also be shown to A.
A is allowed to make arbitrary number of queries to CH.
(A) be the event that A outputs
Anonymity. Let SuccanonP
a bit b(cid:48) such that b = b(cid:48), where the bit b was picked at the
beginning of the protocol. An APAKE protocol P is said to
be anonymous if for any PPT adversary A, there exists a
negligible function ν such that
AdvanonP
(A) def= 2 Pr[SuccanonP
(A)] − 1 ≤ ν(λ).
4. OUR APAKE PROTOCOL
In this section, we present a new APAKE protocol in the
extra-storage setting. It employs an algebraic MAC scheme
MAC = (KeyGen, MAC, Verify) with credential presentation
1A model allowing A to generate the server’s public key
is applicable if the domain parameters are selected from a
standard.
It does not undermine anonymity if a proof of
knowledge of SK is published.
1183algorithm (Show, ShowVerify), a password-based encryption
scheme PE = (Enc, Dec) and a digital signature scheme
DS = (Gen, Sign, Ver), which are described in Section 2. We
prove that our construction achieves AKE security, client
authentication and anonymity in the random oracle model.
4.1 Our Construction
Our construction consists of the following phases.
Setup. Given a security parameter λ, a server chooses a set
of domain parameters (G, p, g), where G is a group of prime
order p and generated by g. The server runs (parmac, sk)
← KeyGen(1λ) and (pk, sk) ← Gen(1λ). Let H1 : {0, 1}∗ →
Mc and H2 : {0, 1}∗ → {0, 1}κ be cryptographic hash func-
tions, where κ is the length of session keys. The server
publishes params ← (G, p, g, parmac, pk) as the set of system
parameters and sets SK = (sk, sk) as his secret key.
Registration. Each client needs to register to the server in
advance. The registration phase is executed over a secure
channel, which can be established, e.g., using TLS with the
server’s public key pk. The registration protocol is shown
in Figure 2, and details are described as follows.
1. A client sends her identity ID to the server and authenti-
cates herself to the server according to the server’s policy.
2. If the server accepts the registration request from client
ID, he does the following. The server computes a message
m ← H1(ID), and generates an authentication tag σ on
message m using sk. Then he generates an NIZK proof
π proving knowledge of sk such that Verify(sk, m, σ) = 1
and (parmac, sk) ∈ KeyGen(1λ) hold. Finally, the server
sends a credential σ and its proof π to the client.
3. When receiving a pair (σ, π), the client computes m ←
H1(ID), and veriﬁes if π is valid on statement (parmac, m, σ).
If π is valid, the client encrypts the credential σ with
her password pw into a ciphertext [σ]pw, and puts the
password-protected credential cred ← (ID, [σ]pw) to her
preferred storage with integrity-protection.
Login. To login the server, a client authenticates herself
to the server and establishes a session key with the server.
Suppose that the client has already obtained her password-
protected credential cred = (ID, [σ]pw). The login protocol
is shown in Figure 3, and details are described as follows.
1. Upon a login request, the server picks y $← Z∗
p and com-
putes Y ← gy. Then, he generates a signature σS on
message Y using sk, and sends (Y, σS) to the client.
2. When receiving a pair (Y, σS), the client veriﬁes whether
σS is valid on message Y under pk. If she accepts σS,
she computes m ← H1(ID), and decrypts ciphertext [σ]pw
with her password pw to recover credential σ. Then she
chooses x $← Z∗
p and calculates X ← gx. Next, the client
runs algorithm Show on input parmac, (m, σ) and a label
(cid:96) = (X, Y, σS) to generate a presentation proof σC =
(T, V, Σ). Finally, the client sends (X, σC ) to the server.
3. Upon receiving a pair (X, σC ), the server executes the
ShowVerify algorithm on input parmac, a presentation proof
σC , a label (cid:96) = (X, Y, σS) and sk to verify if σC is valid.
4. If they both do not abort, then the client and the server
can compute the same session key K via H2(Y, σS, X, σC ,
Y x) and H2(Y, σS, X, σC , X y) respectively.
4.2 Security Proofs
(denoted by P) in Theorems 1, 2, and 3 respectively.
We prove the security of the proposed APAKE protocol
Theorem 1
(AKE security). If MAC is suf-rmva se-
cure and weak pseudorandom, the tag-randomization is sim-
ulatable, SPK is a labeled SE-NIZK, PE is IND-ET secure,
DS is EUF-CMA secure, the DDH assumption holds in G,
and both H1 and H2 are random oracles, then our APAKE
protocol guarantees the AKE security. In particular, we have
AdvAKEP,D (A) ≤ qse/|D| + O
+ Advsuf-rmvaMAC
O (N|D|/|Me|) + Adveuf-cma
(cid:17)
(cid:16)
(cid:17)
s /p + N AdvwprMAC(B4)+
(B7)
Advuzk
(B3) + N 2/|Mc| + q2
(B6) + O
SPK(B1) + Advss-ext
SPK (B2)
(cid:16)
DS
N qcqsAdvDDHG
,
where qc is the maximum number of sessions per client, qs
is the maximum number of server sessions, Advuzk
SPK (resp.,
Advss-ext
SPK ) is the advantage for the unbounded zero-knowledge
(resp., simulation-sound extractability) of SPK,and AdvDDHG
is the advantage for the DDH assumption.
Proof. Firstly, we construct an algorithm CredSim who
can generate presentation proofs without knowledge of sk
and any credential using a zero-knowledge simulator Sim
for SPK. We also construct an algorithm CredExt who can
extract a message-tag pair from any presentation proof pro-
duced by A using an online extractor Ext for SPK.
CredSim(parmac, (cid:96)) : Given parmac and a label (cid:96), CredSim runs
(T (cid:48), V (cid:48)) ← TVSim(parmac) and Σ(cid:48) ← Sim((parmac, T (cid:48), V (cid:48)), (cid:96))
and outputs a presentation proof σC ← (T (cid:48), V (cid:48), Σ(cid:48)), where
TVSim is deﬁned in Section 2.3.
CredExt(parmac, σC , (cid:96)) : Given parmac, σC = (T, V, Σ) and a
label (cid:96), CredExt runs Ext((parmac, T, V ), Σ, (cid:96)).
If T is not
correctly formed or Ext returns invalid,2 CredExt outputs
invalid. Otherwise (Ext returns witness (m, a)), CredExt
computes σ ← Derand(T, a) and outputs (m, σ).
Let A be an adversary who aims at breaking the AKE secu-
rity of our APAKE protocol P. This proof will proceed via
a sequence of games G0, G1, . . . , G7. We will bound the de-
crease in A’s advantage between two successive games, and
use Advi(A) to denote the advantage of A in game Gi.
Game G0. This is the real game. Recall that A is given ac-
cess to Cred = {credi = (IDi, [σi]pwi )}N
i=1, params, and all
the oracles speciﬁed in the security model, where σi is a cre-
dential on mi = H1(IDi). We have AdvAKEP,D (A) = Adv0(A).
Game G1 (Simulate and Extract). This game is the same
as game G0, except that using CredSim to generate presen-
tation proofs for client instances, for each presentation proof
σC created by A, rejecting σC if CredExt outputs invalid
or Verify(sk, m, σ) = 0 for (m, σ) ← CredExt(parmac, σC , (cid:96)),
and accepting σC otherwise, where (cid:96) = (X, Y, σS).
Analysis. When CredExt(parmac, (T, V, Σ), (cid:96)) outputs (m, σ),
Verify(sk, m, σ) = 1 if and only if V = fv(T, sk). Moreover,
simulated T (cid:48) has the same distribution as real T . Thus, G1
has the same distribution as G0, except that the proofs of
SPK are simulated by Sim and Ext fails for extraction. Let B1
(resp., B2) be an algorithm that breaks the unbounded zero-
knowledge (resp., simulation-sound extractability) of SPK
by interacting with A. Then, we have
2If VerifySPK((parmac, T, V ), Σ, (cid:96)) = 0, Ext returns invalid.
1184Client (params, pw)
m ← H1(ID)
Abort if VerifyNIZK((parmac, m, σ), π) = 0
[σ]pw ← Encpw(σ)
Store cred ← (ID, [σ]pw)
secure channel
−−−−−−−−−→
ID
(σ, π)
←−−−−−−−−−
Server (params, SK )
m ← H1(ID), σ ← MAC(sk, m)
π ← NIZK(cid:8)(sk) : Verify(sk, m, σ) = 1 ∧
(parmac, sk) ∈ KeyGen(1λ)(cid:9)
Figure 2: Registration Protocol of Our APAKE Protocol
Client (params, pw, cred = (ID, [σ]pw))
Abort if Ver(pk, Y, σS) = 0
m ← H1(ID), σ ← Decpw([σ]pw)
x $← Z∗
p, X ← gx
σC ← Show(parmac, m, σ, (X, Y, σS))
K ← H2(Y, σS, X, σC , Y x)
(Y, σS)
←−−−−−−−−−−
Server (params, SK )
y $← Z∗
p, Y ← gy
σS ← Sign(sk, Y )
(X, σC )
−−−−−−−−−−→ Abort if ShowVerify(parmac, σC , (X, Y, σS), sk) = 0
K ← H2(Y, σS, X, σC , X y)
Figure 3: Login Protocol of Our APAKE Protocol
Adv0(A) = Adv1(A) + O
(cid:16)
Advuzk
SPK(B1) + Advss-ext
SPK (B2)
.
(cid:17)
i=1.
Game G2 (MAC Forgery). This game is the same as G1,
except that rejecting any presentation proof σC produced
by A such that CredExt(parmac, σC , (cid:96)) outputs (m, σ) and
(m, σ) /∈ {(mi, σi)}N
Analysis. We bound the decrease in A’s advantage from G1
to G2 using a reduction from the suf-rmva security of MAC.
Let B3 be an algorithm that has access to parmac, an oracle
mac and a veriﬁcation oracle verify. B3 executes just as in
G1 and interacts with A, with the following exceptions:
• B3 generates the system parameters params using parmac.
Then B3 makes N queries to oracle mac and obtains
$← Mc. For each i ∈ [N ], B3 pro-
{(mi, σi)}N
grams random oracle H1 such that H1(IDi) = mi.
i=1 for mi
• For each (m, σ) ← CredExt(parmac, σC , (cid:96)), B3 accepts σC
if and only if oracle verify(sk, m, σ) returns 1.
If A behaves diﬀerently between G1 and G2, there exists
a pair (m∗, σ∗) ← CredExt(parmac, σ∗
C , (cid:96)∗) such that oracle
verify(sk, m∗, σ∗) returns 1 and (m∗, σ∗) /∈ {(mi, σi)}N
i=1.
Then B3 can output (m∗, σ∗) as its forgery. Thus, we have
Adv1(A) = Adv2(A) + Advsuf-rmvaMAC
(B3).
Game G3 (Exclude Collisions). This game is the same
as G2, except that aborting if the event abort1 that mi = mj
for some i, j ∈ [N ] and i (cid:54)= j occurs, for each (m, σ) ←
CredExt(parmac, σC , (cid:96)) such that m = mi for some i ∈ [N ],
accepting σC iﬀ σ = σi, aborting if the event abort2 that the
messages from server instances encounter a collision occurs.
Analysis. Since H1 is a random oracle, Pr[abort1] ≤ N 2/|Mc|.
Clearly, Pr[abort2] ≤ q2
s /p. So we have
Adv2(A) ≤ Adv3(A) + N 2/|Mc| + q2
s /p.
Game G4 (Randomize Credentials). This game is the
same as G3, except that replacing [σi]pwi with [Ri]pwi for
each i ∈ [N ] where Ri
$← T , for each (m, σ) ← CredExt(parmac,
σC , (cid:96)) such that m = mi for some i ∈ [N ], accepting σC if
and only if σ = Ri.
Analysis. We bound the decrease in A’s advantage from
G3 to G4 using a reduction from the weak pseudorandom-
ness of MAC. We use a hybrid argument to complete the
reduction. For each j ∈ [N ] ∪ {0}, let game G3,j be the
same as G3, except that setting credi ← (IDi, [Ri]pwi ) for
each i ∈ [j] where Ri
$← T , and using {Ri}i∈[j] to veri-
fy the presentation proofs produced by A. It is clear that
G3,0 and G3,N are the same as G3 and G4 respectively. If
A behaves diﬀerently between G3 and G4 with probabili-
ty , then A must behave diﬀerently between G3,j−1 and
G3,j for some j ∈ [N ] with probability at least /N . We
can construct an algorithm B4 which breaks the weak pseu-
dorandomness of MAC with probability at least /N via
interacting with A. B4 is given parmac, a challenge (m∗, σ∗),
and an oracle mac. B4 makes N − j mac queries and ob-
i=j+1. Then, B4
tains N − j message-tag pairs {(mi, σi)}N
programs random oracle H1 such that H1(IDj) = m∗ and
H1(IDi) = mi for each i ∈ {j + 1, . . . , N}. B4 also picks
i=1 in T . Next, B4 executes as
j − 1 random values {Ri}j−1
in G3, except that B4 sets credi ← (IDi, [Ri]pwi ) for each
(cid:1)
i ∈ [j − 1], credj ← (IDj, [σ∗]pwj ) and credi ← (IDi, [σi]pwi )
to verify the presentation proofs produced by A. If σ∗ =
MAC(sk, m∗), B4 behaves exactly as in G3,j−1. Otherwise
(i.e., σ∗ is uniformly random in T ), B4 behaves exactly as
in G3,j. Then, Adv3,j−1(A) = Adv3,j(A) + AdvwprMAC(B4).
Thus, we have Adv3(A) ≤ Adv4(A) + N AdvwprMAC(B4).
Game G5 (Randomize Ciphertexts). This game is the
same as G4, except that replacing [Ri]pwi with a random
ciphertext Ci ∈ C for each i ∈ [N ], and rejecting all client
messages created by A.
Analysis.
In game G4, since Ri is uniform at random in
Me = T for each i ∈ [N ] and presentation proofs for client
instances are simulated by CredSim, the only way for guess-
ing passwords is to amount on-line dictionary attacks by
making Send queries to the server. Thus, we can bound
the decrease in A’s advantage from G4 to G5 using a re-
for each i ∈ [N ]\[j], and B4 uses (cid:0){Ri}j−1
i=1 , σ∗,{σi}N