示层需要处理动态查询，十分消耗内存）。上游Borgmon可以过滤从下游Borgmon收集
主要负责规则运算和汇总。有的时候全局层（global）也会被划分为计算层和展示层（展
收集层和一个汇总层（一般由于单个Borgmon的RAM和CPU限制导致）。数据收集层
息。
如图10-3所示，在更复杂的部署模型中，我们进一步将数据中心Borgmon划分为一个
障在数据中心维护或者意外情况下产生的单点故障问题。）
（Google 将生产环境按区域划分，任何改动都以区域为单位进行。运行两个实例可以保
于Borgmon之间互相传输time-series数据，进而节约不断收集服务数据带来的CPU和
同时，这样也会成为设计中的单点故障源。为此，我们设计了一种流式传输协议，用
内运行的某个服务的全部实例在理论上可行，但在实际操作中很快就会遇到性能问题，
一个Borgmon实例可以从另外一个实例中获取信息。虽然用一个实例收集全世界范围
监控系统的分片机制
SDB
Borgmon
Borgmon
ClusterA
Tasks
Global
Inter-Borgmon
ClusterB
监控系统的分片机制
Application
Borgmon
DCScraping
Borgmon
ClusterC
Borgmon
Tasks
Global
105
---
## Page 148
120
针对Borgmon规则的单元测试和回归测试工具。通过使用这些工具，以及一些合成的
当然，任何高级编程语言环境中都难以避免复杂程序出现Bug，Borgmon为此提供了
Borgmon同时支持语言级别的模板。Borgmon提供一种类似于宏的模板机制，允许用户
负载均衡器前面的www.google.com以及负载均衡器后面的真实Web服务器。在这种模
series 暴露给Borgmon使用。SRE团队经常使用探针程序收集响应速度的直方图和回
Google SRE团队通常利用探针程序（prober）解决了该问题。探针程序使用应用级别
味着我们并不知道最终用户看到的是什么样。例如：白盒监控只能看到已经接收到的请
但是，白盒监控并不能完全代表一个被监控系统的所有状态。完全依赖白盒监控，就意
功能部署时还是应对紧急情况下都非常有用。
源，无论是对应的组件失败，某个队列满了，
Borgmon规则也是基于服务内部指标写成的。
前文说过，Borgmon是一个白盒监控系统，负责监控目标服务的内部状态。同时，
黑盒监控
106
的可能性。
创造出一些可重用的规则库，进一步减小了配置文件中的重复程度，降低配置文件出错
大降低了监控系统配置文件的维护要求。
可以应用到许多不同的收集目标上。这种分离机制可能看起来没有那么重要，但是却极
Borgmon配置文件是将规则定义与具体收集的目标分开组织的。这意味着同样一套规则
配置文件的维护
也可以在发生全局问题时，快速定位某个具体的数据中心。
式下，我们可以知道当某个数据中心出现间题时，整个www.google.com依然工作，同时
情况的探测，我们可以发现局部问题并且消除无效报警。举例来说，我们可能同时检测
探针程序既可以直接探测前端，也可以探测负载均衡服务后面的服务。通过对两种不同
time-series创建功能的混合体。
复大小，以便观察最终用户可见的性能指标。探针程序是一种检查测试模型和一些高级
例如检查HTTP回复中的HTML结果。探针程序甚至可以将结果中的值取出作为time
也可以由Borgmon收集其结果信息。探针程序还可以针对返回结果进行应用级别的校验。
的自动请求探测目标是否成功返回。这些探针可以直接向报警管理服务发送AlertRPC，
而没有返回的错误。同时，报警策略也只包含了工程师能想到的错误情况。
求，并不能看到由于DNS故障导致没有发送成功的请求，或者是由于软件服务器崩溃
第10章基于时间序列数据进行有效报警
，还是系统中存在某种性能瓶颈。无论在新
。这种透明模型可以非常有效地找到错误根
---
## Page 149
这些模板库非常灵活，
因此，标签在整个系统中有很多用途：
series.
应的实例名称、分片，以及所在的数据中心。这些标签可以用来分组和汇总对应的tine-
通过使用Borgmon标签机制，我们可以针对任务进行区分：Borgmon给每个目标添加对
时失败。
因为它们都运行在同一个数据中心中，而数据中心由于使用同一个网络结构而有可能同
文件（可能会由于错误的配置文件而同时失败）。而一个分片中的任务也是命运共享的，
of fate）理念进行的。例如一个任务的所有实例是命运共享的，由于它们共享一个配置
得调试单独组件时可以单独获取对应信息。这种分组结构一般是根据命运共享（share
个任务有不同的实例数量。一个工程师可以将这个层级关系体现在Borgmon体系中，使
在每个数据中心中，服务由多个分片（shard）组成，每个分片由多个任务组成，同时每
例如，一个服务可能提供了一个全球可用的API，由处于多个数据中心的任务实例组成。
供了一系列通用汇总模板，允许用户将任意指定监控值按自已的服务部署模型汇总。
第二类模板代表了一种如何将单实例监控数据按级汇总到全局范围的模型。这些模板提
Borgmon规则类库和代码类库形成了一套事实意义上的命名体系。）
系统客户端类库及通用RPC框架等。（虽然varz接口并没有要求任何命名体系，但是
用这个模板构建监控系统。这样的模板包括HTTP服务器类库、内存分配器类库、存储
个代码类库暴露的所有监控信息系统模板化，从而使得使用这个类库的用户可以通过使
在Google内部大量的Borgmon通用模板库中，两类模板是最多的。第一类模板将某
行校验
列测试，然后统一分发到所有的 Borgmon 实例上。Borgmon 实例会在接受新配置之前进
组（production monitoring team）维护一套持续集成体系，针对所有配置文件运行一系
time-series 数据，我们可以确保每条Borgmon 规则都是正确的。生产环境监控架构 SRE
·标签可以用来标记数据维度（例如，HTTP 状态码信息用code标签在http_
）标签可以标记数据来源（实例名称和任务名）。
标签可以标记局部分组信息和汇总信息（例如 zone标签代表数据中心，shard标
responses变量中标记）。
签代表逻辑分组信息）。
一套模板可以在不同的汇总级别上应用。
配置文件的维护
107
122
---
## Page 150
123
time-series进行监控和报警的理念。Pormetheus、Riemann、Heka和Bosun都是很好的例子。
虽然Borgmon仍是Google内部工具，但是任何人都可以利用开源软件尝试这种使用
在持续不断地改进和完善。
十年是一个相当长的时间了，随着Google的不断成长，今天Google内部的监控系统也
108
SRE工作中不断重现的一个模式，SRE确保他们做的每一件事都能够扩展到更大的规模。
保证监控系统的维护成本与服务的部署规模呈非线性相关增长是非常关键的。这是在
也让具体监控变得很简单。
就已经带有了使用的类库中的监控信息，同时大量使用模板化的汇总规则和监控台模板，
这些报警规则都基于一种抽象的time-series模型，也更易于维护。新应用程序上线之时
这种松耦合模式使得被监控系统可以独立于监控系统报警规则之外自由扩展。同时由于
的新模型。
Borgmon将测试和报警模型革命成了海量信息收集和中央化规则计算、统一分析和报警
十年之后
第10章基于时间序列数据进行有效报警
---
## Page 151
注1这一章文字的早期版本曾经出现在；login：（2015年10月，第40期，第5篇）。
为了鼓励这种工程化解决问题的方式，Google在招聘SRE团队时着重选拔同时具有系
运维问题，
团队十分不一样的地方在于，SRE团队非常强调用工程化手段来应对运维问题。而这些
能和可靠性保障。因此SRE要参与所服务项目的on-call轮值工作。SRE团队和纯运维
Google内部的很多重要服务，比如Search、Ads、Gmail等都有专门的SRE团队负责性
所运维的服务维持正常运转。
IT行业里，on-call任务一般是由专门的运维团队（Ops）进行的，主要目标是保障他们
值班人员必须保证可以随时响应紧急问题，不管是在工作时间，还是在非工作时间。在
很多职业要求从事该职业的人员参与某种类型的on-call轮值任务。在on-call值班过程中
介绍
变得更均衡的。
轮值制度时发展的核心方法论，解释了这些方法论是如何使服务变得更可靠，工作压力
将会给服务甚至团队带来非常严重的后果。本章描述了GoogleSRE历年来执行on-call
可用性。但是，on-call轮值制度执行过程中有一些十分重要的环节，如果没有正确执行，
on-call轮值是很多运维和研发团队的重要职责，这项任务的目标是保障服务的可靠性和
，当达到一定规模时，也确实只有采用软件工程化手段才能解决。
作者：Andrea Spadaccini 注1
on-call轮值
编辑：KavitaGuliani
第11章
00
126
125
---
## Page 152
在团队中，副on-call轮值制度并不是必需的。很多相关性密切的团队经常彼此作为副
作为生产系统的监管者，on-call工程师负责处理生产环境中即将或者正在发生的业务事
这一节主要介绍了on-call工程师的主要工作，为本章其余部分做背景介绍。
on-call工程师的一天
on-call，互相值班，共同分担工作压力。
其他非紧急的生产环境变更需求。
在另一个团队里，主on-call人只负责处理生产系统紧急情况，而副on-call人负责处理
团队可能以副on-call人作为主on-call 人的辅助，负责处理主on-call 人没有响应的情况。
很多团队同时有主on-call人和副on-call人值班，主副分工每个团队都各有不同。有的
非紧急的生产系统事件，例如低优先级警报的处理，或者新软件的发布可以由on-call工
并且尝试解决问题。必要的话，on-call工程师可以联系其他团队，或者升级（escalate）
事故（更确切地说，13分钟内）。如果一个系统的SLO更为宽松，那么响应时间可以在
不可用时间（参见附录A）。这个要求说明了on-call工程师必须在分钟级别上响应生产
终用户的业务系统在每个季度想要达到99.99%的可用度，那么每个季度共有13分钟的
响应时间通常跟业务需要的可靠性有关。比如在下面这个简单例子中：如果一个面向最
短信、自动电话呼叫及APP等）。
非常灵活的报警传递机制，可以将报警信息通过各种不同渠道同时送达多个设备（邮件、
是30分钟。公司提供一个可以接受报警信息的设备，通常来说是手机。Google有一套
的服务，或者时间非常紧迫的服务来说，这个时间定为5分钟。而非敏感业务通常来说
范围是SRE团队和产品业务团队共同商议得出的。一般来说，对任何直接面向最终用户
在on-call时，该工程师承诺可以在分钟级别执行生产系统中的维护需求，具体的时间
故，以及评审对生产系统的变更请求。
务优化手段来更好地服务整个业务。
解更多有关运维事务压力的讨论，请参见第29章。
息的处理是第一紧急要务，几乎超过一切其他活动，包括研发项目的进行。如果想要了
程师在工作时间内评审或者执行。这些任务与生产报警信息相比不算紧急。生产报警信
请求支援。
几十分钟内。
上限。SRE至少要花50%的时间进行工程项目研发，以便能够研发出更好的自动化和服
110
一旦接收到报警信息，
第11章on-cal轮值
，工程师必须确认（ack），on-call工程师必须能够及时定位问题
---