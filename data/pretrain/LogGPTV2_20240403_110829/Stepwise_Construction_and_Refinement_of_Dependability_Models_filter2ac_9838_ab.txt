t
C22
M
I2
S21ok
S
21ko
M
S2
t’C22
M
I2
Figure 7. Two functions with a structural de-
pendency
presented.
Interfacing rules have been deﬁned in formal
terms. However, the main rules are stated here in an in-
formal manner.
Upstream and downstream MI have the same number
of immediate transitions and the arcs that are connected to
these transitions are built in a systematic way:
(cid:15) Upstream MI: It contains one function transition tF
for each series (set of) component(s), to mark the func-
tion’s up state place, and one component transition tCx
for each series, distinct component that has a direct im-
pact on the functional model, to unmark the function’s
up state place.
- Each tF is linked by an inhibitor arc to the function’s
up state place, by an arc to the function’s up state
place and by one bidirectional arc to each initial
(ok) component’s place;
- Each tCx is linked by an arc to the function’s up state
place and by one bidirectional arc to each failure
component’s place.
(cid:15) Downstream MI: It contains one function transition
t’F for each series (set of) component(s), to unmark
the function’s failure state place, and one component
transition t’Cx for each series, distinct component that
has a direct impact on the functional model, to mark
the function’s failure state place.
- Each t’F is linked by an arc to the function’s failure
state place and by one bidirectional arc to each
initial (ok) component’s place;
- Each t’Cx is linked by an inhibitor arc to the func-
tion’s failure state place, by an arc from the func-
tion’s failure state place and by one bidirectional
arc to each component’s failure place.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:12:51 UTC from IEEE Xplore.  Restrictions apply. 
4. Reﬁnement of the structural model
4.1. Component decomposition
We assume that the structural model is organized in a
modular manner, i.e., it is composed of sub-models repre-
senting the behavior of the system’s components and their
interactions. For several reasons, the ﬁrst model that is built,
starting from the functional-level model, may be not very
detailed. One of these reasons could be the lack of informa-
tion in the early system’s selection and development phases.
Another reason could be the complexity of the system to be
modeled. To master this complexity a high level model is
built and then reﬁned progressively.
As soon as more detailed information is available con-
cerning the system’s composition and events governing
component evolution, the structural model can be reﬁned.
Another reﬁnement may be done regarding event distri-
butions. Indeed, an assumption is made that all events gov-
erning the system’s behavior are exponentially distributed,
which, in some cases, is not a good assumption. In partic-
ular, failure rates of some components may increase over
time.
Model reﬁnement allows detailed behavior to be taken
into account and leads to more detailed results compared
to those obtained from a high level model. In turn, these
detailed results may help in selecting alternative solutions
for a given structure. For our purpose, we consider three
types of reﬁnement: Component, state/event and distribu-
tion. Given the fact that the system’s model is modular,
reﬁnement of a component’s behavior is undertaken within
the component sub-model and special attention should be
paid to its interactions with the other sub-models. However,
in this paper due to the lack of space, we will mainly address
the new dependencies created by the reﬁnement, without
discussing those already existing.
Component reﬁnement consists in replacing a compo-
nent by two or more components. From a modeling point
of view, such a reﬁnement leads to the transformation of the
component’s sub-model into another sub-model. Our ap-
proach is to use the same transformation rules as those used
for the interface model presented in section 3.
State/event ﬁne-tuning consists in replacing, by a sub-
net, the place/transition corresponding to this state/event.
We deﬁne basic reﬁnement cases, whose combination cov-
ers most usual possibilities of state/event reﬁnement.
For distribution adjustment, we use the method of stages.
Consider an event whose distribution is to be transformed
into a non-exponential one. This method consists in replac-
ing the transition associated with this event, by a subnet. We
have adapted already published work to take into account
dependencies between the component under consideration
and components with which it interacts. This is done with-
out changing the sub-models of the latters.
A section is devoted to each reﬁnement type.
Consider a single function achieved by a single software
component on a single hardware component. Suppose that
the software is itself composed of N components. Three
basic possibilities are taken into account (combinations of
these three cases model any kind of system):
(cid:15) The N components are redundant, which means that
they are structurally in parallel;
(cid:15) The N components are in series;
(cid:15) There are Q components in parallel and R+1 compo-
nents in series (with Q+R=N).
Our goal is to use reﬁnement rules identical, as far as
possible, to the ones used in Section 3.
In the following we explain how a single component is
replaced by its N components. These decompositions are
respectively called parallel, series and mixed.
4.1.1. Parallel decomposition. Consider software S’s de-
composition into two redundant components S1 and S2.
Thus, S’s up state is the result of S1 or S2’s up states, and
S’s failure state is the combined result of S1 and S2’s failure
states.
t
1S
S1ok
T
12
S1
ko
t’S
1
S
ok
tS
T11
T
22
t’S
Sko
tS2
S2ok
T21
S2ko
t’S2
Immediate transition
Timed transition
S1’s failure rate
S2’s failure rate
S1’s restoration rate
S2’s restoration rate
= λ
S1
= λ
S2
µ
=
S1
= µ
S2
= software’s ok state
= software’s fail state
T 11
T 21
T 12
T
22
Sok
Sko
Figure 8. Parallel decomposition
Figure 8 gives a GSPN model of this case. The gen-
eralization to N components is straightforward. It is worth
mentioning that the interface model between the system and
its components is built exactly in the same manner as the
interface model between a function and its associated com-
ponents.
4.1.2. Series decomposition. Consider the decomposition
of software S into two series components S and S. Hence,
this case is identical to the one presented in Fig. 5 when
replacing F by S, H by S and S by S.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:12:51 UTC from IEEE Xplore.  Restrictions apply. 
4.1.3. Mixed decomposition. Suppose S is composed of
three components: S, S and S, where S is in series with
S and S, that are redundant. This case is identical to the
example presented in Fig. 6 when replacing F by S and H
by S.
4.1.4. Conclusion.
In all the cases illustrated above, we
have considered only one token in each initial place. K
identical components can be modeled by a simple model
with K tokens in each initial place. When reﬁning the be-
havior of such components, a dissymmetry in their behavior
may appear. Indeed, this is due to the fact that some com-
ponents that have the same behavior at a given abstraction
level, may exhibit a slightly different behavior when more
details are taken into account. If this is the case, one has to
modify the model of the current abstraction level before re-
ﬁnement. This may lead to changing the interface model ei-
ther between the functional-level and the structural model,
or between two successive structural models. This is the
only case where reﬁnement leads to changing the model at
the higher level.
4.2. State/Event ﬁne-tuning
In GSPNs, places correspond to system’s states and
timed transitions to events that guide state changes. The
ﬁne-tuning of places/transitions allows more detailed be-
havior to be modeled. Reﬁnement has been studied in Petri
nets ([13, 12]) and more recently in Time Petri Nets [8].
Our goal is to detail the system’s behavior by reﬁning the
underlying GSPN. Our sole constraint is to ensure that the
net’s dynamic properties (aliveness, boundness and safe-
ness), at each reﬁnement step, are preserved. The main
motivation for model reﬁnement is to have more detailed
results about system behavior, that better reﬂect reality.
We deﬁne three basic reﬁnement cases. Combinations
of these three cases cover most usual situations for depend-
ability models’ reﬁnement. They are given in Table 1.
TR1 allows the replacement of one event by two com-
peting events. It allows the event’s separation into two other
events with different rates. TR2 allows a sequential reﬁne-
ment of events, while TR3 allows the reﬁnement of a state
into two or more states. These transformations are illus-
trated on the following simple example.
Consider the hardware model given in Fig. 9(a). Several
successive reﬁnement steps are depicted in Figures 9(b), (c)
and (d).
After a fault activation (T) two types of faults are dis-
tinguished: Temporary and permanent, with probability a
and  (cid:0) a respectively. Using TR3, we obtain the model
depicted in Fig. 9(b).
To take into account error detection latency (1/(cid:14)) for
hardware components, we apply TR2 to transition T of
Table 1. State/Event reﬁnement
Initial model
T
TR1: Separation
into two events
T
1
T
2
competing
Two
events
Sequence
TR2:
of events
State re-
TR3:
ﬁnement
T1
T
2
T
t
1
t 2
Reﬁnement of the
action represented
by transition T
t = p (cid:17) prob. of
ﬁring t,
t = p (cid:17) prob. of
ﬁring t and
p + p = 1
Fig. 9(b). The resulting model is presented in Fig. 9(c).
Finally, we model the error detection efﬁciency by ap-
plying TR3. Detected errors allow immediate system’s re-
pair. We then add a perception latency (transition T),
Fig. 9(d). This latency is important to be modeled because,
as long as the non-detected error is not perceived, the sys-
tem is in a non-safe state. Repair can be performed only
after perception of the effects of such errors.
This is a small example of a state/event reﬁnement ap-
plication. Other details can be added to the model using the
cases presented in this section.
4.3. Distribution adjustment
It is well known that the exponential distribution as-
sumption is not appropriate for all event rates. For example,
due to error conditions accumulating with time and use, the
failure rate of a software component might increase.
The possibility of including timed transitions with non-
exponential ﬁring time is provided by the method of stages
[7]. This method transforms a non Markovian process into
a Markovian one, by decomposing a state (with a non expo-
nential ﬁring time distribution) into a series of k successive
states. Each of these k states will then have a negative ex-
ponential ﬁring time distribution, to simulate an increasing
rate. In GSPNs, a transition, referred to as extended transi-
tion, is replaced by a subnet to model the k stages.
The transformation of an exponential distribution into
a non-exponential one might create new timing dependen-
cies. Indeed, the occurrence of some events in other compo-
nents might affect the extended transition. For example, the
restart of a software component might lead to the restart of
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:12:51 UTC from IEEE Xplore.  Restrictions apply. 
(b) 2 types of faults
t 1
t 2
T21
T22
= 1−a
= a
= µ
= ε
repair rate
disappearance rate
(a) Compact model
λ
ν
T1
=
T
2 =
failure rate
restoration rate
H
ok
T
1
T2
TR3
t 1
T22
H def
H ok
H def
TR3
t 3
t 4
T2122
= d
t 3 = 1−d
t 4
T2121 = µ
= π
T2122
T2121
error perception rate
211T
212T
δ=
µ
=
error detection rate
(d) Error detection efficiency
(c) Error detection latency
Figure 9. State/Event reﬁnement
the component under consideration (that has an increasing
failure rate) and thus stop the accumulation of error condi-
tions, bringing back the software under consideration to its
initial state.
In previously published work [1, 2], the dependency be-
tween events is modeled only by concurrent transitions en-
abled by the same place. This is not very convenient when
several components interact with the component under con-
sideration, as it could lead to changing their models. We
have adapted this extension method to allow more ﬂexibil-
ity and take into account this type of dependency.
The salient idea behind our approach is to reﬁne the
event’s distribution without changing the sub-models of the
components, whose behavior may affect the component un-
der consideration (when assuming a non-exponential distri-
bution).
In the rest of this section, we ﬁrst present the extension
Hok
Hdef
TR2
H
ok
H
def
t 2
T21
T211
T212
method presented in [2] and then present our adapted exten-
sion method.
4.3.1. Previous work. Concerning the transitions’ timers,
three memory policies have been identiﬁed and studied in
the literature, namely, resampling, age memory and en-
abling memory. The latter is well adapted to model the kind
of dependency that is created when modeling system’s de-
pendability as mentioned above. It is deﬁned as follows: At
each transition ﬁring, the timers of all the timed transitions
that are disabled by this transition are restarted, whereas the
timers of all the timed transitions that are not disabled hold
their present values.
In [1] and [2] an application of the enabling memory pol-
icy in structural conﬂict situations has been given. It con-
cerns the initial model of Fig. 10, in which transition T to
be extended is in structural conﬂict with transition Tres.
S
T 1
S
T res
Figure 10. Initial model
When applying the enabling memory policy as given in
[2] to transition T of Fig. 10, the resulting model is pre-
sented in Fig. 11. In this ﬁgure, the k series stages are mod-
eled by transitions tc, tc, T
 and places P, P and
P. Token moving in these places is controlled by the con-
trol places Pc, Pc and P.
 and T
S
resT
1P
k−1
t c1
2P
t
c2
c2P
1T
1
3P
2T
1
S
k−1
1t
t 2
4P
t
3
t
4
c1P
Figure 11. Enabling memory with structural
conﬂict
After removal of the token from S by ﬁring of transition
Tres, the clearing of places P, P and P is accomplished