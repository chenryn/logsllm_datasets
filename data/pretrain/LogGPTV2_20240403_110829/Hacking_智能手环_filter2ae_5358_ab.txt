P0.24 | – | OLED RES# 引脚  
I2C 协议涉及到的东西实质上远比
[UART](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter) 这样简单的协议更多。其中最大的一个优点是在同一条总线支持多个主设备和从设备。这又增加了一点复杂性。往小了说是，我们需要知道 MCU
该和那个从设备通信；往大了说是，除了物理引脚，还要知道用于 OLED 显示屏的物理引脚的 ”逻辑“ 地址。
幸运的是，nRF5 SDK 中有个 I2C
扫描器的示例。简而言之，它尝试和每个可能的逻辑地址通信，当另一端有响应时返回报告。我修改过的一个版本在这里，运行并查看输出：
    $ make
    # ...
    $ make flash
    # ...
    $ make log
    # ...
    TWI scaner
    TWI device detected 0x3c
真是一个好消息，我们有理由相信显示屏被真确识别了，它也的确使用 I2C 总线。上谷歌搜索发现，`0x3c` 是这类设备的通用地址。
现在，我们可以尝试发送一些像素到显示屏上。在这个级别没有抽象的库可用。在 [ssd1306](https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf)
的文档中,我们找到了一些低层级的方法来发送数据到显示屏。该过程由一些列配置命令组成。其中包括设置屏幕方向、写入模式、大小。之后，把在屏幕上显示的数据字节序列发送到显示器的图形显示数据
RAM(GDDRAM)中。
为了得到正确的配置，我看了一下[Adafruit’s ssd1306
library](https://github.com/adafruit/Adafruit_SSD1306),并尝试枚举出相似的命令。我在这个项目中花在这里的时间最多。把所有细节都搞清除是非常耗时的。直到现在仍然还有些行为我无法解析，然而显示器已经可以正常显示数据了。
绘制了一个硬编码的位图
这是[示例程序](https://github.com/rbaron/fitless/tree/master/oled_test)。
通过这些设置，显示屏被划分为包含 96 行的 4 行（页）。所以每一页的高度为 8
像素。发送的第一个字节的数据会被垂直的放在第一列上；第二个字节的数据会占据第二行的未知；第三行类似，直到第 96
行。当第一页写完，会到第二页继续类似的过程。
或者说，这是预期的结果。下面视频中观察的结果却不相同: 首先是一些奇数列被填充，然后是偶数列，最后才是类似的循环过程。
﻿  
您的浏览器不支持video标签  
调试慢放版的位图显示
我花了很长的时间去弄明白为什么我在屏幕上看得到无意义的内容，然后又花了些时间调整配置来修复它。最后我放下了自尊，把这个奇怪的渲染逻辑在程序中实现，今天就到此为止吧！
##
## Arduino 之旅
在我挖掘 Adafruit’s ssd1306 库时，我希望有一种方法可以在 nRF51822 中 “模拟”
Arduino特定的比特。事实上已经有经验丰富的大神做了相似的[项目](https://github.com/sandeepmistry/arduino-nRF5)，此项目还不止于此，他使用 nRF5 SDK 实现了 Arduino 核心库。
使用这个项目，我们可以打开 Arduino IDE 选择 nRF5 板，我们可以使用 Arduino 现有的生态开发程序。我 fork
了这个[项目](https://github.com/rbaron/arduino-nRF5),并添加了对我们的这个手环板子的支持。可以在下拉菜单中选择使用
`Tools > Board > ID115 Fitness Bracelet(nRF51822)`。
通过Arduino IDE 上传的没有任何补丁的 Adafruit ssd1306 库
这也意味着我们可以使用 [Adafruit 的 OLED
库](https://github.com/adafruit/Adafruit_SSD1306)。让我惊讶和欣慰的是，OLED 也出现了 “先奇数，后偶素”
的渲染顺序。我很高兴 [forked](https://github.com/rbaron/Adafruit_SSD1306)
这个库。现在我们得到了各种抽象的方法，而不是之前使用的低级方法，例如绘制文本。
传统的 “Hello,World!”
##
## 模拟 IO
除了数字 IO,”开、关”。nRF51822 有 10 个用于读取模拟输入的引脚。这是很有用的，例如读取当前的电量。从文档中得知，当输入为
`0V`，我们会读取到 `0`;当输入为 `VCC` 时，我们会读取到 `1023`;当输入电压介于在它之间时也对应着相应的数值。
我定期的输出模拟信号的值，并绘制出了完整的信号结果。
震动板和充电对模拟输入的影响
我认为 `P0.05` 引脚和充电状态有关。在充电是他的数值会升高，不充电的时候会下降。我怀疑 `P0.26`
引脚连接着加速度传感器输出，当我摇动手环时它的数值会飙升。`P0.03` 和 `P0.04`
可能也连着着加速度传感器输出，但是这种行为可能对应着芯片输入的二阶效应。例如，注意在第一张图中当加速度传感器需要更多的能量时，电池电量（pin5）也会抖动。下面是一个二阶效应的例子。
代码可以在[sketch](https://github.com/rbaron/fitless/tree/master/analog_input/AnalogInput)上找到。原始数据和绘制脚本在[这里](https://github.com/rbaron/fitless/tree/master/analog_input/AnalogInput)。现在我们又可以在我们的映射表中添上几行了。
nRF51822 引脚 | 板子 | 描述  
---|---|---  
P0.05 | – | 模拟输入-与电池充电相关  
P0.26 | – | 模拟输入-加速度传感器  
P0.03 | – | 模拟输入-加速度传感器(可能)  
P0.04 | – | 模拟输入-加速度传感器(可能)  
##
## 按钮
在最初的固件中，触控手环屏幕的指定位置可以点亮屏幕。如果我记得没错，按住它可以用来计时。这并不是一个实体点击按钮，而是某种运行效果不错的电容传感器。使用相同的方法找到数字输出，我找到了它与
MCU 连接方式。
您的浏览器不支持video标签  
按钮
代码可以在[这里](https://github.com/rbaron/fitless/tree/master/button/Button)找到。
nRF51822 引脚 | 板子 | 描述  
---|---|---  
P0.10 | – | 数字输入-内置按钮  
##
## 低功耗蓝牙(BLE)
nRF5 的蓝牙功是使用一个称为
[SoftDevice](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.softdevices51%2Fdita%2Fnrf51%2Fsoftdevices.html)
实现的。它是包含在 BLE 的堆栈中的预编译二进制文件。它应该独立于应用程序运行。SoftDevice 有相当多的版本，找到正确的版本依赖于 SDK
的版本和芯片的版本。
[文档](http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v12.3.0%2Findex.html)(不幸的是没有直达链接)兼容表中可以查询到指定芯片版本对应那个
SDK 版本和 SoftDevice 版本。对于我而言，芯片上标有 “QFAAHO” ，它有 256 KB 闪存，16KB RAW,与 SoftDevice
s130 兼容。
我使用的 12.3 版本的 SDK 里面有一些使用 Software s130 的示例程序。与我们到目前为止刷入的程序相比，这些程序直接被刷入到地址
`0x0`。现在我们需要将 SoftDevice 刷入到地址 `0x0`, 实际的地址是 `0x1b000`。启动并初始化后，为了说明这一点，我做了一个类似
binky
的例子。但[这里](https://github.com/rbaron/fitless/tree/master/blinky/id115/s130/armgcc)从
SoftDevice 开始,观察到的行为是一致的，除了我们需要确保 SoftDevice 在之前就被刷写过。
    $ make
    # ...
    $ make flash-softdevice
    # ...
    $ make flash
    # ...
    $ make log
    # ...
    Hello,world!
可以说，在蓝牙应用中最简单的 “Hello World”
程序是把设备变为[信标](https://en.wikipedia.org/wiki/Bluetooth_low_energy_beacon)。信标只广播自己，监听者的责任是探测到在其范围中信标并做出反应。这个
SDK 在相同的 `ble_app_beacon` 下提供了这样一个示例。它会假定 SoftDevice `s130` 在之前已近烧写了。
在这里，我们直接与芯片通信，而不是通过 SDK，这让事情变得更加困难。此外，还不得不调整 RAM 的大小（正如我从 blinky
示例中学到的那样），另外一个难以追踪的问题。事实证明，BLE 堆栈使用一个晶振来执行时间敏感的任务。SDK 示例假定有一个外部晶振。曾经我使用了上千个
`printf`
来搞清楚这些，需要将配置标志更改为使用合成时钟生成器来解决这个问题。[信标源码](https://github.com/rbaron/fitless/tree/master/ble_app_beacon)在这里可以找到。
##
## BLE + Arduino
一旦使用 nRF5 SDK 的 BLE 示例程序运行正常，并且了解了 RAM 和晶振陷阱。 我一次又一次的看了 Arduino
的运行环境。[sandeepmistry/arduino-BLEPeripheral](https://github.com/sandeepmistry/arduino-BLEPeripheral)是做
Aruino-nRF5 项目的那个人的另一个很棒的项目。它提供了在设置 BLE 外围设备的内部细节的一个不错的抽象。
﻿  
您的浏览器不支持video标签  
使用 BLE 点亮蓝色的 LED(使用这个 APP)
让我惊讶不已的是，我并没有 fork 这个库。Arduino-nRF5 项目的作者花了些时间让所有的板子都是可配置的，于是需要在下拉菜单 `Tools >
Low Frenquency Clock > Synthesized` 中选择合适的 SoftDevice
和晶振源。真是了不起，你可以在上面的视频中看到，我写了一个开关 LED 的
[快速上手的例子](https://github.com/rbaron/fitless/tree/master/ble_led)。
##
## 下一步
此时，在数周的时间里，我盯着这块板看了好几个小时之后，我非常期待能把它重新放回抽屉的后面，并把它放在那里一段时间。
注: 原作者已授权
​