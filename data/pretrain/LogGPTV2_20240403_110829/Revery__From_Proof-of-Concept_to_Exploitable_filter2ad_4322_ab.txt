be hijacked, e.g., line 15 in the example. They are special ex-
ploitable points. In the running example, it is a second-order
exploitable point, caused by the first exploitable point in line 14.
• Exploitation path: the path taken by a successful exploit, e.g.,
• Stitching points: special instructions in the diverging path and
crashing path, which could be stitched together to generate
the exploitation path, e.g., line 11 and line 13 in the example.
In practice, there may be numerous sub-paths between two
stitching points to explore.
It is worth noting that, the crashing point (line 12) in the running
example could reach to the hijacking point (line 15), but it is not
exploitable. As aforementioned, this hijacking point is a second-
order exploitable point, made by the exploitable point in line 14.
Without the help of line 14, line 15 could not be exploited.
9->10->11->13->14->15 in the example.
So, to conduct successful exploitations, we have to think outside
the box made by the original PoC, and search for exploitable states
in diverging paths. This is the intuition of our solution and the
origin of the name Revery. To the best of our knowledge, existing
AEG solutions paid few attentions to this exploit derivability issue.
2.3 Our Solution: Revery
We proposed a novel solution Revery, to solve the exploit deriv-
ability issue and assess the exploitability of heap-based vulnerabili-
ties. At the high level, Revery analyzes the vulnerability in detail,
utilizes the vulnerability information to guide a fuzzer rather than
symbolic execution to explore diverging paths and search for ex-
ploitable states, then synthesizes exploitation paths by stitching
the crashing path and diverging path, and finally generates inputs
to trigger both the vulnerability and exploitable states. As shown
in Figure 2, it has three major components.
2.3.1 Vulnerability Analysis. Revery first analyzes the vulnerabil-
ity in detail, similar to existing AEG solutions. It uses dynamic
analysis to test target application with the provided PoC input.
More specifically, it tracks the states of each pointer and memory
object, and catches security violations along the crashing path. It
could thus identify the vulnerability point, e.g., line 10 in Figure 1.
More importantly, it identifies exceptional objects corrupted by
the vulnerability, e.g., obj2 in the example. Revery also identifies
the exceptional object’s indexing objects, which could be used to
locate the exceptional object, e.g., the global variable gvar in the
example. Moreover, it retrieves layout-contributor instructions from
the execution trace, which create the exceptional and indexing
objects and set up their point-to relationships, e.g., line 7 in the
example. These objects and contributor instructions are used to
construct a layout-contributor digraph.
2.3.2 Diverging Path Exploration. Revery searches for exploitable
states in diverging paths, to solve the exploit derivability issue.
Rather than using symbolic execution, it employs fuzzing.
First, it employs a novel layout-oriented fuzzing solution to ex-
plore diverging paths. To facilitate exploit generation, only diverg-
ing paths with memory layouts similar as the PoC input’s will be
explored. So, it drives a fuzzer to explore paths close to the crash-
ing path, in a similar way as directed fuzzing solutions [12]. But
instead of using the full crashing path, it uses the aforementioned
layout-contributor instructions as the fuzzer’s guidance. The fuzzer
could thus produce diverging inputs to exercise the diverging paths
(e.g., 9->11->13->14 in the figure) with proper memory layouts.
Then, Revery searches for exploitable states in the diverging
paths. Several heuristics are used to identify exploitable states. For
example, if a memory store operation’s destination is controlled by
the corrupted object, e.g., line 14, it is an exploitable state.
Furthermore, Revery also searches for hijacking points in these
diverging paths. Hijacking points sometimes are not obvious. So
Revery uses some heuristics to infer hijacking points. For example,
line 15 in the figure is a second-order hijacking point, which could
be enabled if line 14 overwrites the global function pointer.
2.3.3 PoC Stitching. Once an exploitable state (together with a
diverging input) in a diverging path is found, Revery will try to
synthesize a new input to trigger both the vulnerability and the
exploitable state. In general, it first finds the stitching points in the
crashing path (e.g., line 11) and in the diverging path (e.g., line 13),
with some specific data flow analysis.
layout-contributorsliceVulnerability AnalysisDiverging Path ExplorationExploit SynthesisVulnerabilityIdentiﬁcationLayout AnalysisProgPOClayout-contributordigraphLayout-oriented FuzzingFilterExploitableState SearchIdentifyStitchingPointsDivergingPathsDivergingInputsGenerateExploitEXPCrashingPathStitchControl-FlowPathsSession 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1917enabling detection of not only spatial vulnerabilities (e.g., heap
overflow) but also temporal vulnerabilities (e.g., use-after-free).
In principle, each pointer is expected to access a specific memory
object of valid status. If it is used at runtime to access an object of
different tags or invalid status, then a security violation is caught.
Figure 3 shows an example of vulnerability identification.
3.1.1 Memory tags. Each heap object and pointer is attached with
a memory tag, indicating its lineage. This tag will be uniquely gen-
erated when an object is created, and propagate to the object’s
pointers and other related pointers as a taint label (taint analy-
sis). Moreover, each heap object is associated with a status, i.e.,
uninitialized, busy, or free, standing for three status in its
life-cycle, i.e., allocated but not initialized, initialized and being
used, or freed. It is worth noting that, a freed memory region could
be allocated to new objects, and its memory status and tag will
change accordingly.
In some corner cases, developers could use one object’s pointer
to get another object’s pointer, with an arithmetic operation. It will
wrongly propagate the first object’s tag to the second pointer. For-
tunately, this is rare for heap objects, since the offsets between heap
objects are not fixed. The only exception is heap management func-
tions, which could inspect adjacent objects in this way, no matter
what semantics these objects would have. So Revery will disable
tag propagation and validation for these special functions. It is
worth noting that, this optimization is only for cross-object pointer
deriving. Revery supports in-object pointer driving as normal.
intended objects, i.e., tag_obj and tag_ptr must match.
Security rules. For each heap memory access instruction (i.e.,
3.1.2
load and store), we could get the pointer’s tag tag_ptr and target
memory region’s tag tag_obj and status status_obj. The memory
access must not violate the following security rules:
• V1: access intended objects: Instructions should only access
• V2: read busy objects: Load instructions should not access
freed or uninitialized memory, i.e., status_obj must be busy.
• V3: write alive objects: Store instruction should not access
freed memory, i.e., status_obj must be busy or uninitialized.
Any violation of these rules will cause a vulnerability. For ex-
ample, a buffer overflow memory access will violate the rule V1.
An uninitialized variable vulnerability will violate the rule V2. A
use-after-free (UAF) vulnerability could violate either rule V1, V2
or V3. If the freed object’s memory has not been taken by other
objects, then read access to it will violate V2, and write access to it
will violate V3. If the freed object’s memory is taken, then its tag
will change, and any access to it via the original dangling pointer
will violate the rule V1.
3.2 Layout Analysis
Revery further analyzes object layouts to characterize the vul-
nerability state and retrieve instructions contributing to the state.
3.2.1 Vulnerability-related Object Layout. Each heap-based vul-
nerability (including heap overflow and UAF) is related to one
exceptional object, whose content is (or will be) corrupted by the
vulnerability. Further operations on these objects could lead the
weird machine to exploitable states.
Figure 3: Illustration of heap-based vulnerability identifica-
tion. Each heap object and pointer is associated with a mem-
ory tag. An extra status is attached to each memory object.
Then it utilizes a lightweight symbolic execution to explore po-
tential sub-paths between these two stitching points (e.g., 11->13),
and stitch the crashing path with the diverging path to synthesize
an exploitation path (e.g., 9->10->11->13->14->15), and finally
generate inputs to exercise the exploitation paths. Several optimiza-
tions are deployed to make the symbolic execution lightweight.
Therefore, Revery could produce EXP inputs able to trigger both
vulnerabilities and exploitable states. It could help experts to quickly
generate working exploits. In certain cases, Revery is able to di-
rectly generate exploits. For example, Revery could generate an
exploit input to hijack the control flow, by utilizing the exploitable
state at line 14 to overwrite the global function pointer handler.
Assumptions. We assume the victim program is deployed in
regular modern operating systems, with default defenses enabled
(e.g., DEP [9] or sanity checks in glibc). Except that ASLR [26] is
disabled, since it requires an extra information disclosure vulnera-
bility or exploit, which Revery currently does not support.
3 VULNERABILITY ANALYSIS
To exploit a vulnerability, it is necessary to locate the vulnerabil-
ity point and the program state at that point. Furthermore, to solve
the exploit derivability issue, exploitable states around the vulner-
ability state should be searched for. Therefore, Revery performs
vulnerability identification to locate the vulnerability, and performs
layout analysis to characterize the vulnerability state.
3.1 Vulnerability Identification
Given a PoC input, Revery first needs to identify its correspond-
ing vulnerability point. Dozens of solutions have been proposed to
detect memory errors, e.g., AddressSanitizer [32] and Valgrind [7].
However, AddressSanitizer and Valgrind will slightly change the
memory layout of target applications, and thus are not suitable for
exploit generation.
Revery utilizes a different technique, named memory tagging
(MT, also known as memory coloring, memory tainting, lock and
key) to locate vulnerabilities. A recent work [33] has implemented
memory tagging in hardware. However, it encodes tags in memory
pointers and thus affects the program states. Moreover, it only
detects spatial memory violations, but not temporal violations.
Revery uses a shadow memory to non-intrusively track the tags
of pointers and heap objects. It also tracks the status of heap objects,
Memory store(cid:18)(cid:79)(cid:82)(cid:68)(cid:71)tag  AShadowMemorytag Astatus bitstag Bstatus bitsmalloc(a) request(d) access(b) returnpointertag  Atag  A(c) pointer transferSession 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1918Figure 4: An example layout-contributor digraph. Assume
the object created at line 35 is an exceptional object. It could
be indexed by objects created at line 22 and 5 repsectively,
and eventually pointed by a global pointer ptr.
Figure 5: An example layout-contributor slice. Compared to
the path a=>b, the path a=>c=>d has a longer prefix with the
target slice in the path a=>c=>e=>f.
Assume the vulnerability point uses a pointer with tag tag_ptr
to access a target object with tag tag_obj. If it is a write access,
the object with tag tag_obj is the exceptional object, which will
be corrupted by this write access. If it is a read access and this
vulnerability is a UAF, the object with tag tag_ptr is the exceptional
object, which will be corrupted by new object allocations that take
the same memory. Revery currently does not support other types
of read access violation well.
Further, Revery also tracks all indexing objects that can be used
to locate exceptional objects. These exceptional objects and index-
ing objects are connected with the point-to relationship. As a result,
Revery could get a digraph of objects, denoted as layout digraph.
This layout digraph characterizes the vulnerability state to some
extent. Figure 4(b) shows an example layout digraph.
3.2.2 Vulnerability-related Code. As aforementioned, the weird
machine has to enter specific initial states, including the vulnera-
bility state. So, it is necessary to prepare a similar object layout as
the vulnerability’s, both in diverging paths and exploitation paths.
Thus, instructions contributing to the layouts are important.
We can see that, the following two types of operations could
contribute the object layout: (1) memory allocations that creates
new objects, and (2) store operations that assign an object’s field
with a pointer to another object. As a result, Revery could retrieve
all such contributor operations, which operate on objects in the
layout digraph, and generate a layout-contributor digraph.
More specifically, each node in this digraph is an exceptional
object or an indexing object, with an attribute of the object’s creator
instruction and memory tag. Each edge in the digraph represents a
point-to relationship between two objects, with an attribute of the
pointer assignment instruction. Given a target exceptional object,
we could use backward slicing to construct this digraph. Figure 4(c)
shows an example layout-contributor digraph. This digraph has a
simpler form, called layout-contributor slice, which is a sequence of
contributor instructions in execution order.
4 DIVERGING PATH EXPLORATION
To solve the exploit derivability issue, it is necessary to explore
diverging paths and search exploitable states in them. In this section,
we will introduce how Revery explores diverging paths.
4.1 Alternative Choices
Existing automated exploit generation solutions, e.g., AEG [10]
and Mayhem [15], heavily rely on symbolic execution to explore
the crashing path or reachable paths from the vulnerability point,
in order to search exploitable states along the path exploration.
However, symbolic execution has several severe challenges, and is
not suitable for path exploration or exploitable state searching.
First, it is not scalable in path exploring. It suffers from the path
explosion issue caused by branches and loops in programs. Even
when analyzing one path, it costs too many resources. Moreover,
the symbolic constraints are often too complicated to solve.
Second, symbolic execution may get blind to certain exploitable
states. It has to concretize some symbolic values along the explo-
ration, by adding extra constraints of concretized value assignments.
It is impossible to try all candidate concretized values, thus misses
certain values and causes blindness to certain exploitable states.
For example, it will concretize the symbolic arguments of mem-
ory allocation in a path, in order to model the memory states and
explore following sub-paths. It is likely that only a small number
of allocations could cause exploitable states. So the concretized
memory allocation may lead to a non-exploitable state.
Moreover, it will also concretize symbolic indexes in memory
access operations, because otherwise the operations’ results are
unknown. Similarly, it could also lead to non-exploitable states.
Another choice is exploring paths with the combination of fuzzing
and symbolic execution, e.g., Driller [37]. However, the symbolic
execution component of such solutions still have the aforemen-
tioned challenges. Moreover, the fuzzing component usually lacks
of targets, and thus is not effective at finding exploitable states.
4.2 Layout-Oriented Fuzzing
Revery utilizes fuzzing solely to explore diverging paths and
search for exploitable states. As shown in vulnerability discovery,
fuzzing is more effective than symbolic execution in exploring paths
and program states. So, it is likely that fuzzing could also help find
diverging paths and exploitable states faster.
Revery employs a novel layout-oriented fuzzing solution guided
by the layout-contributor digraph, to explore diverging paths that
build similar memory layouts as the vulnerability.
5: call malloc6: mov [ptr],eax(cid:335)(cid:17)10: call malloc 11: mov ebx,[ptr]12: mov [ebx+8],eax….22: call malloc 23: mov [eax],0x024: mov ebx,[ptr]25: mov [ebx+0x10],eax…35: call malloc36: mov ebx,[ptr]37: mov ecx,[ebx+0x10]38: mov [ecx+8],eax+0x00 ptr+0x00 ?+0x08 ptr+0x10 ptr+0x00 data+0x08 ptr+0x00 ?+0x00 ?tag: t5tag: t10tag: t22tag: t35t5t10t22(cid:87)(cid:22)(cid:24)ins 5ins 6ins 12ins 10ins 22ins 35ins 25ins 38layout-contributor slice:5, 6, 10, 12, 22, 25, 35, 38 (a) sample execution trace(b) layout digraph (c) layout-contributorlayout-contributor digraph:instruction 1instruction 3instruction 4abcedfginstruction 2Session 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1919Figure 6: Illustration of the fuzzer implemented by Revery.
4.2.1 Design. Revery extends the popular coverage-guided fuzzer
AFL to perform fuzzing. Instead of relying solely on code coverage
to guide path exploration, Revery uses layout-contributor digraph
as a guidance to tune the direction of exploration and mutation.
Similar to directed fuzzing [12], Revery drives the fuzzer to ex-
plore paths close to the crashing path. It only aims at matching
instructions in the layout-contributor slice, and ignores other in-
structions in the crashing path. The design choices are made from
the following three intuitions.
For simplicity, we introduce several terminologies. Given an
input Ia, it could hit several layout-contributor instructions (maybe
not in the same order as the guiding slice). The full list of such
instructions is denoted as La, and its longest common subsequence
(LCS) with the target guiding slice is denoted as Pa.
• Intuition 1: An input that hits all layout-contributor instruc-
tions, in the same order as the guiding slice, could construct a
similar memory layout as the vulnerability.
Layout-contributor instructions are responsible for creating the
exceptional object of a vulnerability and its indexing objects,
as well as setting the point-to relationships among them. So,
an input hitting the full layout-contributor slice could probably
construct similar memory layouts.
• Intuition 2: An input that hits a longer subsequence of the
guiding slice is more likely to derive inputs hitting the full slice.
In other words, if input Ia’s LCS Pa is longer than Ib’s LCS
Pb, then the input Ia is better than Ib. As shown in Figure 5,
assuming the target slice is in path a=>c=>e=>f, then an input
exercising the path a=>c=>d is better than other inputs exercis-
ing a=>b. Further mutations on this input could derive inputs
hitting the full guiding slice faster.
• Intuition 3: Inputs hitting fewer layout-contributor instruc-
tions are more likely to introduce fewer troubles for further
exploit generation.
In other words, for two inputs Ia and Ib, if their LCS Pa and
Pb have a same length, but the layout-contributor instruction
list La is longer than Lb, then the input Ib is better than Ia.
In this case, the input Ia has more duplicated or out-of-order
contributor instructions than Ib, which could cause redundant
object creation or layout construction, making the memory
layout too complicated to exploit.
Implementation Details. Revery extends the popular fuzzer
4.2.2
AFL [41]. As shown in Figure 6, AFL applies a continuous loop
to explore paths. It (1) keeps a queue of good testcases, i.e., seeds;
and (2) selects a seed from the queue; and then (3) mutates the
seed to get a bunch of new testcases, and then (4) run the target
Figure 7: Filter diverging paths by matching their layouts
against target crashing path’s and aligning them when
matched.
binary program with the generated testcases in QEMU, and track the
coverage, and then (5) identify seeds based on coverage information.
Revery modifies AFL in the following two aspects.
Tracking Slice Hit Count. Revery adds an extra buffer HIT
in the shared memory between QEMU and the fuzzer driver, in
addition to the existing bitmap used for code coverage tracking.
HIT[0] is used to track the count of slice hit, while HIT[i] is used
to track whether the i-th instruction in the guiding slice has been
hit or not.
More specifically, each time a layout-contributor instruction is
executed, QEMU will increase the slice hit count HIT[0]. If this
instruction is the n-th (n>=1) instruction in the guiding slice, then
QEMU will set HIT[n] if and only if HIT[n-1] has been set. In this
way, the fuzzer driver could get the slice hit count in HIT[0], and
the LCS of guiding slice in HIT[1:N].
Tuning Fuzzing Directions. Revery modifies the fuzzer dri-
ver to make use of the collected slice hit information. Basically, it
slightly changes the algorithms of seed selection. When picking up
a seed from the queue to mutate, it first prioritizes seeds that have
longer LCS, as discussed in Intuition 2. Then among seeds with
LCS of same length, it prioritizes seeds with fewer slice hit count,