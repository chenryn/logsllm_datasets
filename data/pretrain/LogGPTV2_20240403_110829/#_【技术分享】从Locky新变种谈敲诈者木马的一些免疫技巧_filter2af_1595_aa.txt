# 【技术分享】从Locky新变种谈敲诈者木马的一些免疫技巧
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
****
**0x1 前言**
Locky敲诈者木马算是敲诈者木马中传播时间较长，变种较多的一款。在最近一段时间里，其变种Thor、Aesir开始频繁出现。这些Locky变种之间的核心加密功能代码几乎是相同的，只是改动了加密的后缀名，不过相比较老版本的Locky敲诈者，此类新变种在自我防御机制上有了较大改变，例如利用全局原子表代替注册表项存储标志字符串以应对对于相关注册表项的检测。不过即使填补了旧版Locky的坑，Locky新变种依然存在一些可以用来免疫的点，本文就旨在通过对Locky新变种的一些技术细节的分析来谈谈对此类木马的免疫手段。
**0x2 先看看Locky的新变化**
**1\. 感染方式的变化**
感染方式上其实不能称作变化，应该称之为扩展。早期的Locky一般通过邮件传播，恶意代码存在于邮件附件Word文档中，通过调用Word宏执行恶意代码。而Locky新变种的感染方式有所增加，除了Word宏执行恶意代码之外，也存在以JS脚本作为邮件附件进行感染的变种。除外，Locky新变种借助PowerShell或PowerShell+Rundll32组合执行恶意代码。下图展示的是一款Locky新变种使用的代码执行方式，其使用PowerShell启动恶意程序进程。
图1 使用PowerShell启动恶意程序进程
**2\. 标志字符串存储的变化**
老版本Locky敲诈者会访问一些相关的注册表项并将一些标志字符串存储在注册表中，例如HKCUSoftwareLocky注册表项。这些标志字符串用来判断该计算机中的文件是否已被加密，以及此次加密工作是否完成。此类方法最大的缺陷在于用户可以设置ACL阻止任何用户访问相关注册表项或者自定义一个相同的注册表项来“欺骗”敲诈者。
Locky新变种摈弃了注册表，转而使用全局原子表来存放相关的标志字符串。由于访问全局原子表并不需要打开操作，一般用户也不知道如何往全局原子表中添加全局原子来“欺骗”敲诈者，因此该方法相比较使用注册表存储标志字符串的方法更加有效。  
图2 程序查询原子表相关字符串以判断计算机是否已被感染
**3\. 密钥和加密**
老版本Locky敲诈者从服务器获取RSA公钥，当然这么做并不能保证程序能正常获得RSA公钥。由于存放密钥的地址经常发生变更，可能用户感染敲诈者时该地址已失效，因此在服务器存放RSA公钥并不能保证每次都能加密成功。Locky新变种采用了和大部分敲诈者一样的方式，将RSA公钥硬编码到程序中，这就能保证成功加密文件。
在加密方式上，Locky新变种和老版本相同，使用微软提供的一系列API完成加密工作。
**0x3 再说说对Locky新变种的免疫手法**
**1\. 从Rundll32.exe入手**
正如上文提到的，Locky新变种在恶意代码的运行方式上相比较老版本复杂的多，主要也是从对抗杀软这方面考虑。在这些新变种中，使用最为广泛的当属Rundll32.exe运行恶意dll的方式。微软对于Rundll32.exe的使用做了限制，使用命令行调用Rundll32.exe时命令行必须满足以下格式。
而对于使用Rundll32.exe执行的导出函数，其必须参数必须满足如下要求。
但是查看Locky新变种释放的恶意Dll发现该Dll并无导出函数。
图3 IDA显示Dll无导出函数
其实这是恶意Dll使用的伎俩。由于Rundll32.exe执行Dll导出函数的流程是LoadLibraryExW—GetProcAddress—ExportFuntion，第一步LoadLibraryExW会导致Dllmain的执行，而恶意Dll在Dllmain中将自身的代码从内存中解除映射，并映射新的代码，新的代码中定义了导出函数，因此该恶意Dll就完成了导出函数从无到有的转变。
图4 完成代码重建后Dll“生”出了导出函数
使用这种方法构造了一种无导出函数的Dll调用导出函数的假象。也为分析造成了一些困扰。不过该恶意程序为了实现代码的重建也是付出了一定的代价，这也算是一个可以防御的点。
之所以说恶意程序付出了一定代价，是因为其使用了TLS（线程局部存储）技术，该技术解决了多线程中线程操作全局变量带来的冲突问题。下图展示了Dll的区段组成，可以很清楚地看到.tls段。
图5 Dll的区段中存在.tls段
对于WinXP而言，在程序执行主功能代码之前会初始化静态定义的线程局部变量，因此在程序执行主功能前已经分配一部分内存用于存储线程局部变量，如果程序运行中动态调用一个Dll（例如使用LoadLibary函数调用Dll），且该Dll中也静态定义了线程局部变量，由于存储线程局部变量的空间已经固定，将导致Dll的线程局部变量无法初始化，从而导致Dll调用失败。同理，Rundll32.exe在执行主功能代码之前已经初始化静态定义的线程局部变量，在执行过程中调用LoadLibraryExW函数加载恶意Dll。根据恶意Dll存在tls段可以确定该Dll静态定义了线程局部变量，这样就会导致LoadLibraryExW函数调用失败，Rundll32.exe弹出警告框如下所示。