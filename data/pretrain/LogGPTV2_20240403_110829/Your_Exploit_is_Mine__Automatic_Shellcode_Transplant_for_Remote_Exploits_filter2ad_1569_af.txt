### Symbolic Execution for Exploit and Leaked Information Correlation

Symbolic execution can be employed to identify the correlation between an exploit and leaked information or its reference, allowing for necessary modifications. In this context, memory conflicts are unlikely to arise, as they are specific to placing replacement shellcode in memory. However, path conflicts will still occur and need to be resolved due to the modifications required to re-target the leak. Once the relationship is established, one can develop an exploit by solving the constraints.

### Ricochet Problem for Denial of Service Vulnerabilities

We define the ricochet problem for Denial of Service (DoS) vulnerabilities as generating a modified exploit that causes the same effect on the vulnerable program. If the original exploit causes the program to crash or hang at a given point, the modified exploit should have the same effect. In this scenario, ShellSwap is used purely as an exploit replaying system.

### Exploit Replayability

ShellSwap assumes that the original exploit is deterministically replayable, meaning it always succeeds when re-launched against the target. However, this assumption does not always hold. For instance, a vulnerable server may use a challenge-response protocol that requires the client to send messages with a nonce negotiated at the beginning of the session. This nonce would change upon replay, causing the exploit to fail. Asymmetric encryption and environmental randomness can also lead to such failures. To generate a modified exploit in these cases, ShellSwap would need to treat the exploit as a state machine rather than a series of static bytes, requiring fundamental design extensions.

Our experiments showed that most exploits in our dataset are replayable, and our system is applicable to the majority. We plan to investigate the replaying of non-deterministic exploits in future work.

### Modern Defense Mechanisms

Modern systems employ memory protection mechanisms such as Address Space Layout Randomization (ASLR) and Data Execution Prevention (DEP). These protections can be bypassed by well-crafted exploits.

Our solution to the shellcode transplant problem is based on a functional original exploit, which implies that the exploit has already bypassed the required defense mechanisms. When this is the case, ShellSwap’s replacement exploit often bypasses these mitigations as well. For example, DEP can be bypassed using Return Oriented Programming (ROP), which chains pieces of code (gadgets) to map an executable page and insert shellcode. Alternatively, the page containing the shellcode can be marked executable using `mprotect`. ShellSwap bypasses DEP by reusing the original exploit’s DEP bypass and replacing the final mapped shellcode with the replacement shellcode. If the replacement shellcode cannot be located at the same address, the final control flow transfer must be modified to point to the new location. This can be done using a constraint solver as an adaptation of the Path Kneading phase.

For more general DEP bypass scenarios, such as those using pure ROP payloads without mapped shellcode, future work is needed to solve the ROP chain transplant problem.

Bypassing ASLR is similar. One method, in the absence of DEP, is to overwrite the instruction pointer to point to `jmp *%reg` with a register `%reg` referring to the shellcode. A typical instance is `jmp *%esp`. For ShellSwap, the modified exploit can bypass ASLR if 1) the original exploit can bypass ASLR and 2) the replacement shellcode is placed at the same start address as the original shellcode. This ensures that when the program dereferences a function pointer or returns from a function, it jumps to the start of the replacement shellcode, making the modified exploit successful. The final shellcode location can be modified through an adaptation of the Path Kneading phase.

More complex cases, including exploits that require an information disclosure step to break ASLR, are currently not supported by ShellSwap. We plan to explore these in future work and welcome collaboration in this area.

### Future Work

We plan to explore four main areas of future work:

1. **Encrypted, Packed, or Obfuscated Traffic**: Extend ShellSwap to handle encrypted, packed, or obfuscated traffic. While our approach assumes knowledge of the encryption key, exploring cases without this knowledge would be interesting, though challenging in cryptographically-secure scenarios. Additionally, handling nondeterministic behavior would require addressing fundamental issues.

2. **Online Exploit Modification**: Enable ShellSwap to perform live exploit modification against remote systems, adapting to the system's operation. Symbolic tracing is currently a bottleneck, but optimizations from related work could improve this capability. This would allow ShellSwap to reason about information disclosure during an exploit to defeat ASLR.

3. **ROP Chain Transplant Problem**: Extend ShellSwap to handle the ROP chain transplant problem. Related work in automatic ROP payload generation can be leveraged for this purpose.

4. **Shellcode Polymorphism**: Expand ShellSwap to generate semantically equivalent shellcode with different contents to satisfy path constraints. This could involve building a dictionary of "instruction synonyms" or creating templates to interchange instructions without changing semantics.

### Related Work

#### Automatic Exploit Generation (AEG)
AEG techniques automatically generate exploits with shellcode. These methods, mostly based on dynamic symbolic execution, are closely related to ShellSwap, as both take a vulnerable program and shellcode to generate a viable exploit. Helaan et al. proposed a method to place shellcode in memory by scanning for symbolic memory gaps. However, AEG techniques lack a principled approach to diagnose and resolve conflicts imposed by replacement shellcode, making ShellSwap more efficient for shellcode transplanting.

#### Intrusion Detection
ShellSwap detects attacks by enforcing taint-based security policies during dynamic symbolic tracing. Traditional taint tracking on dynamic binary instrumentation frameworks like Pin and Valgrind is used to detect attacks during runtime. While these solutions are more performant, ShellSwap cannot use them as they do not record path constraints, which are vital to our approach.

#### Manual Ricochet Attacks in the Wild
Ricochet attacks are widely adopted in competitive attack-defense contests. Teams like Shellphish and PPP have reported significant success by stealing and replaying exploits. However, while the concept is well-known within the hacking community, our system is the first end-to-end automatic ricochet attack generation system.

### Conclusion
In this paper, we introduce the automatic shellcode transplanting problem and propose ShellSwap, a system for automatic shellcode transplant for remote exploits. Our experiments show that ShellSwap successfully generated 88% of the exploits in 100 test cases, implying that exploit generation no longer requires specialized skills. Victims unfamiliar with exploit knowledge can now generate their own exploits.

### Acknowledgements
We thank our shepherd, Gang Tan, and the reviewers for valuable suggestions. We also thank Alexandre Rebert, Matthew Maurer, and Vyas Sekar for their comments on the project.

### References
[1] QEMU. http://www.qemu-project.org/.
...
[32] W. Xu, S. Bhatkar, and S. Brook. Taint-Enhanced Policy Enforcement: A Practical Approach to Defeat a Wide Range of Attacks. In 15th USENIX Security Symposium, pages 121–136, 2004.