symbolic execution to ﬁnd the correlation between the exploit
and the leaked information or its reference, and modify it
accordingly. In this case, the memory conﬂicts will likely not
come into play (since they are speciﬁc to placing replacement
shellcode in memory), but path conﬂicts will still occur, and
will need to be kneaded away, due to the modiﬁcations required
to re-target the leak. After identifying the relation, one can
come up with an exploit by solving the constraints.
We deﬁne the ricochet problem for Denial of Service
vulnerabilities as the generation of a modiﬁed exploit that
causes the same effect to the vulnerable program. Of course,
there is little modiﬁcation required – if the original exploit
makes the program crash or hang at a given point, the modiﬁed
exploit should have the same effect. In this case, ShellSwap is
used purely as an exploit replaying system.
2) Exploit Replayabilty: ShellSwap assumes that the original
exploit is deterministically replayable, in the sense that the
exploit always succeeds when re-launched against the target.
However, this assumption does not always hold. For instance, a
vulnerable server may implement a challenge-response protocol
that requires the client to send messages with a nonce that
the two sides negotiated at the beginning of the session. This
nonce would change when we replay the exploit, and the exploit
would fail. Asymmetric encryption and sources of randomness
from the environment can also manifest in such failures. To
generate the modiﬁed exploit for such case, ShellSwap would
have to consider an exploit as a state machine rather than a
series static bytes, which would require fundamental extensions
of the design.
This being said, our experiments showed that most of
the exploits in our dataset are replayable, and our system
is applicable for this majority. We intend to investigate the
replaying of non-deterministic exploits in future work.
3) Modern Defense Mechanisms: Modern systems have
memory protection mechanisms such as Address Space Layout
Randomization (ASLR) and Data Execution Prevention (DEP).
However, such protection mechanisms can be bypassed by
properly-crafted exploits.
Our solution to the shellcode transplant problem is based
on an functional original exploit, which implies that this
exploit has already bypassed the required defense mechanisms.
When this is the case, ShellSwap’s replacement exploit often
bypasses these mitigation techniques as well. For example,
DEP is often bypassed through the use of Return Oriented
Programming that chains pieces of code (termed gadgets) in a
program to map an executable page (using the Linux mmap or
DECREE allocate syscalls), insert shellcode into it, and
execute it. Alternatively, the page containing the shellcode (for
example, the program stack) can simply be marked executable
836
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
by mprotect. For such exploits, ShellSwap bypasses DEP
by reusing the original exploit’s DEP bypass and replacing the
ﬁnal mapped shellcode with the replacement shellcode. If the
replacement shellcode cannot be located at the same location
as the original shellcode, the ﬁnal control ﬂow transfer of the
mitigation bypass stage must be modiﬁed to point at the new
location. This can be done with the constraint solver as an
adaptation of the Path Kneading phase discussed in Section IV.
However, in the more general case of DEP bypass (for
example, when a pure ROP payload is used, with no mapped
shellcode), future work is required to solve the ROP chain
transplant problem.
Bypassing ASLR is similar. One way to bypass ASLR, in
the absence of DEP, is to overwrite the instruction pointer
to point to jmp *%reg with a register %reg referring to
a register location that currently points to the shellcode. A
typical instance of the instruction is jmp *%esp. For the
ShellSwap system, the modiﬁed exploit is able to bypass the
ASLR protection if 1) the original exploit is able to bypass
ASLR and 2) the beginning of the replacement shellcode is
placed at the same start address as the shellcode in the original
exploit (to which control ﬂow is transferred after DEP bypass,
for example). In this way, when the program dereferences
a function pointer or returns a function, it will jump to the
address of the start of the original shellcode, which is also the
start of the replacement shellcode, and the modiﬁed exploit will
succeed. Again, the ﬁnal shellcode location can be modiﬁed
through an adaptation of the Path Kneading phase.
More complex cases, including exploits that require an
information disclosure step (to break ASLR), are currently
not supported by ShellSwap. We plan to explore these in future
work, and would welcome collaboration in this area.
C. Future Work
We plan to explore, and hope to see other researchers
investigate, four main areas of future work.
First, ShellSwap can be extended to deal with encrypted,
packed, or obfuscated trafﬁc. In theory, our approach can handle
these cases, because we assume knowledge the encryption key
and because the decryption/decoding/deobfuscation functional-
ity is in the original binary. However, the exploration of cases
that do not assume knowledge of the encryption key would
be interesting (albeit probably impossible in cryptographically-
secure cases). A further generalization of this is the ability to
successfully transplant shellcode in the presence of nondeter-
minism. Currently, ShellSwap cannot handle nondeterministic
behavior, and some fundamental problems would need to be
addressed to enable its operation on this.
Second, it would be interesting to make ShellSwap usable
in an on-line capacity, where instead of modifying exploits
and launching them at a later date, ShellSwap could perform
the exploit live against the remote system, modifying it as
appropriate based on that system’s operation. Symbolic tracing
is the current bottleneck of achieving this capability, but it can
likely be improved by leveraging optimizations from related
work [8, 25, 28]. Interestingly, the ability to function on-line
would allow ShellSwap to reason about information disclosure
in the course of an exploit to defeat ASLR, which is something
that is not currently possible.
Third,
the extension of ShellSwap to the ROP chain
transplant problem would be an interesting future direction.
Related work in the ﬁeld of automatic ROP payload generation
can be leveraged toward this end [27, 29].
Finally, ShellSwapcan be expanded to support the generation
of shellcode that is semantically equivalent to the replacement
shellcode while having different contents to satisfy path
constraints. Such shellcode polymorphism would increase
the cases in which ShellSwap can resolve path conﬂicts.
For example, we could consider building up a dictionary of
“instruction synonyms”, or creating templates to interchange
instructions without changing the semantics.
VIII. RELATED WORK
A. Automatic Exploit Generation
An exploit is valuable to attackers only when it suits attack-
ers’ speciﬁc goal. The technique of automatically generating
an exploit with a piece of shellcode is called automatic exploit
generation (AEG) [7, 11, 20, 27]. Those work are mostly
based on dynamic symbolic execution. AEG is closely related
to ShellSwap in the sense that they both take a vulnerable
program and a piece of shellcode and generate a viable exploit.
Helaan et al. [17] proposed how to place shellcode in
memory: scan through the memory and ﬁnd symbolic memory
gaps that are big enough to hold the entire piece of shellcode.
For each gap, they try to put shellcode at different offsets by
constraining symbolic memory bytes beginning at that offset
to the actual bytes of the shellcode. This procedure continues
until the shellcode is put in a memory gap or all gaps have
been tried.
As we have demonstrated in our evaluation, AEG techniques
are not suitable for shellcode transplanting, as they lack prin-
cipled approach to diagnose and resolve conﬂicts imposed by
replacement shellcode, and must resort to symbolic exploration.
Our system makes it possible to adapt and retroﬁt an existing
exploit to different instances of shellcode efﬁciently.
B. Intrusion Detection
In ShellSwap we detect attacks triggering software vulnera-
bilities and capture exploits by enforcing a set of taint-based
security policies during dynamic symbolic tracing. Traditionally,
taint tracking implemented on dynamic binary instrumentation
frameworks (e.g. Pin [22] and Valgrind [23]) is used to
detect attacks during runtime, Xu et al. [32], Autograph[19],
Vigilante [14], and Bouncer [13] are all reasonable choices.
While those solutions are more performant than symbolic
tracing, ShellSwap cannot use them as they do not record
path constraints, which are vital to our approach.
C. Manual Ricochet Attacks in the Wild
Ricochet attacks are widely adopted in competitive attack-
defense contests today. The CTF team Shellphish has stated at
DEF CON:
837
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
“Stealing and replaying exploits has become very
popular; basically, it is the main way in which most
teams attack others these days. I think that, during
the last DEF CON, a majority of our ﬂags (aka
points) were coming from running ‘stolen’ exploits.”
The CTF team PPP has also stated they inspected network
trafﬁc to ﬁnd new vulnerabilities, which helped them score
points and win DEF CON CTF in 2013 and 2014.
However, while the concept of ricochet attacks is well-known
within the hacking-competition community [2, 4], it does not
appear to have received much direct attention elsewhere. To
the best of the knowledge, our system is the ﬁrst end-to-end
automatic ricochet attack generation system.
IX. CONCLUSION
In this paper, we introduce the automatic shellcode trans-
planting problem. Given a program, an exploit and a piece of
shellcode, this problem asks how to automatically generate a
new exploit that targets the potentially unknown vulnerability
present in the program and executes the given shellcode.
We also propose ShellSwap, which is the system for
automatic shellcode transplant for remote exploits. To our best
knowledge, the ShellSwap system is the ﬁrst automatic system
that generally apply different shellcode on the exploits for
unknown vulnerabilities. In our experiment, we evaluated the
ShellSwap system on a combination of 20 exploits and 5 pieces
of shellcode that are independently developed and different
from the original exploit. Among the 100 test cases, our
ShellSwap system successfully generated 88% of the exploits.
Our results imply that exploit generation no longer requires
delicate exploit skills. For those victims who are not familiar
with exploit knowledge, they can also generate their exploits.
X. ACKNOWLEDGEMENTS
The authors would like to thank our shepherd, Gang Tan,
and the reviewers for the valuable suggestions. We would also
like to thank Alexandre Rebert, Matthew Maurer and Vyas
Sekar for their comments on the project.
REFERENCES
[1] QEMU. http://www.qemu-project.org/.
[2] The NOPSRUS Team @ DEF CON CTF 2007. http:
//nopsr.us/ctf2007/.
[3] Tracer. https://github.com/angr/tracer.
[4] We are Samurai CTF and we won Defcon CTF this
year. AMA! http://www.reddit.com/r/netsec/comments/
y0nnu/we_are_samurai_ctf_and_we_won_defcon_ctf_
this/c5r9osm, 2013.
[5] CGC
Final
Event
File Archive.
https:
//repo.cybergrandchallenge.com/CFE/, 2016.
[6] The
CGC
Repository.
https://github.com/
CyberGrandChallenge, 2016.
[7] T. Avgerinos, S. K. Cha, B. T. H. Lim, and D. Brumley.
AEG: Automatic Exploit Generation. In Proceedings of
18th Annual Network and Distributed System Security
Symposium. Internet Society, 2011.
[8] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley.
Enhancing Symbolic Execution with Veritesting.
In
Proceedings of the International Conference on Software
Engineering, pages 1083–1094, New York, New York,
USA, 2014. ACM Press.
[9] T. Bao, J. Burket, M. Woo, R. Turner, and D. Brumley.
ByteWeight: Learning to Recognize Functions in Binary
Code.
In Proceedings of the 23rd USENIX Security
Symposium, pages 845–860. USENIX, 2014.
[10] D. Brumley, J. Newsome, D. Song, H. Wang, and S. Jha.
Theory and Techniques for Automatic Generation of
Vulnerability-Based Signatures. IEEE Transactions on
Dependable and Secure Computing, 5(4):224–241, 2008.
[11] D. Brumley, P. Poosankam, D. Song, and J. Zheng.
Automatic Patch-Based Exploit Generation is Possible:
Techniques and Implications. In Proceedings of the 2008
IEEE Symposium on Security and Privacy, pages 143–157.
IEEE, 2008.
[12] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley.
Unleashing Mayhem on Binary Code. In Proceedings
of the 2012 IEEE Symposium on Security and Privacy,
pages 380–394. IEEE, 2012.
[13] M. Costa, M. Castro, L. Zhou, L. Zhang, and M. Peinado.
Bouncer: Securing Software by Blocking Bad Input. In
Proceedings of 21st Symposium on Operating Systems
Principles, pages 117–130. ACM, 2007.
[14] M. Costa, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou,
L. Zhang, and P. Barham. Vigilante: End-to-End Con-
tainment of Internet Worms. In Proceedings of the 20th
ACM Symposium on Operating Systems Principles, pages
133–147. ACM, 2005.
[15] CVE Details. Vulnerabilities By Type. https://www.
cvedetails.com/vulnerabilities-by-types.php, 2017.
[16] L. Davi, A. Dmitrienko, M. Egele, T. Fischer, T. Holz,
R. Hund, N. Stefan, and A.-R. Sadeghi. MoCFI: A Frame-
work to Mitigate Control-Flow Attacks on Smartphones.
In Proceedings of the 19th Network and Distributed
System Security Symposium. The Internet Society, 2012.
[17] S. Heelan. Automatic generation of control ﬂow hijacking
exploits for software vulnerabilities, 2009.
[18] W. Hu, J. Hiser, D. Williams, A. Filipi, J. W. Davidson,
D. Evans, J. C. Knight, A. Nguyen-Tuong, and J. Rowan-
hill. Secure and practical defense against code-injection
attacks using software dynamic translation. Proceedings
of the Virtual Execution Environments, pages 2–12, 2006.
[19] H.-A. Kim and B. Karp. Autograph: Toward Automated,
Distributed Worm Signature Detection. In Proceedings
of the 13th USENIX Security Symposium, pages 271–286.
USENIX, 2004.
[20] Z. Lin, X. Zhang, and D. Xu. Convicting Exploitable
Software Vulnerabilities: An Efﬁcient Input Provenance
Based Approach. In IEEE International Conference on
Dependable Systems and Networks With FTCS and DCC
(DSN), pages 247–256. IEEE, 2008.
[21] C. M. Linn, M. Rajagopalan, S. Baker, C. Collberg,
S. K. Debray, and J. H. Hartman. Protecting Against
838
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
Unexpected System Calls. In Proceedings of the 14th
USENIX Security Symposium, pages 239–254. USENIX,
2005.
[22] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood.
Pin: Building Customized Program Analysis Tools with
Dynamic Instrumentation.
In Programming Language
Design and Implementation, pages 190–200. ACM, 2005.
[23] N. Nethercote and J. Seward. Valgrind: A Framework for
Heavyweight Dynamic Binary Instrumentation. In Pro-
ceedings of the 2007 ACM Conference on Programming
Language Design and Implementation, pages 89–100.
ACM, 2007.
[24] N. A. Quynh. Unicorn - The ultimate CPU emulator.
http://www.unicorn-engine.org/.
[25] A. Romano and D. Engler. Expression Reduction from
Programs in a Symbolic Binary Executor. In Proceedings
of the 20th International Symposium Model Checking
Software, pages 301–319. Springer, 2013.
[26] F. B. Schneider. Enforceable Security Policies. ACM
Transactions on Information and System Security, 3(1):30–
50, 2000.
[27] E. J. Schwartz, T. Avgerinos, and D. Brumley. Q: Exploit
Hardening Made Easy. In Proceedings of the USENIX
Security Symposium, pages 379–394, 2011.
[28] K. Sen, G. Necula, L. Gong, and W. Choi. MultiSE:
Multi-Path Symbolic Execution using Value Summaries.
In Joint Meeting on Foundations of Software Engineering,
pages 842–853, New York, New York, USA, 2015. ACM
Press.
[29] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens,
M. Polino, A. Dutcher, J. Grosen, S. Feng, C. Hauser,
C. Kruegel, and G. Vigna. (State of) The Art of War:
Offensive Techniques in Binary Analysis. In Proceedings
of the 2016 IEEE Symposium on Security and Privacy,
pages 138–157. IEEE, 2016.
[30] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang,
J. Corbetta, Y. Shoshitaishvili, C. Kruegel, and G. Vigna.
Driller: Augmenting Fuzzing Through Selective Symbolic
Execution. In Proceedings of the Network and Distributed
System Security Symposium, 2016.
[31] D. Wheeler.
the next Heart-
bleed. http://www.dwheeler.com/essays/heartbleed.html#
valgrind-conﬁrmed, 2014.
How to detect
[32] W. Xu, S. Bhatkar, and S. Brook. Taint-Enhanced Policy
Enforcement: A Practical Approach to Defeat a Wide
Range of Attacks. In 15th USENIX Security Symposium,
pages 121–136, 2004.
839
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply.