static char s[9] = { 0xb2, 0xdb, 0xca, 0xc6, 0xce, 0xcd, 0xc4, 0x0a, 0x00 };
/*半角片假名イロハニホヘト的字符编码+换行+0 */
api_putstr0(s);
api_end();
}
在这个程序中我们特地声明了一个s[]用来保存要显示字符串，有人可能会说，那为啥不直接
写成下面这样呢？
api_putstr0(“ｲﾛﾊﾆﾎﾍﾄ\n”);
这样写的话在Windows中可能没问题，但在Linux中可能就不行了。准确地说，其实这并不
是操作系统的问题，而是字符编码方式的问题。
说到底，字符串就是一串按顺序排列的字符编码，而对于半角片假名应该赋予怎样的编码，
图灵社区会员 metorm 专享 尊重版权
5 日文文字显示（1）（harib25e） …… 623
有着不同的标准。在Windows常用的“Shift-JIS”①编码中，半角的“イロハニホヘト”的字符编
1
码和s[]中的值一模一样，但在Linux常用的“日文EUC”编码中，则变成了形如0x8e, 0xb2, 0x8e,
0xdb, 0x8e, 0xca, 0x8e, 0xc6, …这样的排列，即在每个半角片假名前都加上了一个0x8e。
18
最近出现了一些功能强大的文本编辑器，可以选择字符编码方式，也就是说，在Windows中
也可以按EUC编码保存，而在Linux中也可以按Shift-JIS编码保存了，所以刚刚我们也说了，这并
3
不完全是操作系统的问题。
因此，如果直接写成“MS Mincho\n”的话，根据字符编码方式的不同，最终形成的字符串
20
（数值的排列）也会不同，所以我们需要用二进制数字逐个来写出字符的编码，这样一来，即便
在Linux下make这个程序，也应该可以得到完全相同的可执行文件。
21
■■■■■
22
好了，我们来“make run”试试看。能不能成功呢？我们已经修改了Makefile，将nihongo.fnt
加入到磁盘映像中了，因此默认的语言模式应该是日文模式。哦哦，显示出来了！
7
如果我们先执行“langmode 0”然后再运行iroha.hrb的话，就会显示出下面这样的乱码，这
也验证了我们编写的程序成功运行了，撒花！
8
9
26
27
成功显示出了半角片假名！ 在英文模式下显示出乱码 28
由于中文不存在像日文半角片假名这样的特殊字符，所以我们不需要考虑这个问题。不
28
过，本节中提到的由于文字编码方式不同导致实际生成的字符编码数据不同的问题，在中文
中也是存在的。例如简体中文的GB2312和繁体中文的BIG5就是两种不同的编码方式，相互
14
之间不能兼容。本节中提到的“EUC”实际上是“Extended Unix Code”的缩写，是一种为
了让中日韩文字能够兼容ASCII编码而提出的一种兼容编码方式，GB2312（以及后来的
15
——————————
① 其实“Shift-JIS“这个名称是不正确的，准确名称应该是“MS汉字编码“，不过反倒是“Shift-JIS“的使用最
16
广泛。
图灵社区会员 metorm 专享 尊重版权
624 …… 第28天：文件操作与文字显示
GB18030）都属于EUC方式，而Shift-JIS则不属于EUC方式。
66 日文文字显示（2）（harib25f）
好啦，接下来我们该挑战全角字符的显示了。在全角字符显示方面，Shift-JIS和日文EUC的
处理方法是不同的，我们先从Shift-JIS开始。
各种半角字符，包括字母、数字、符号、片假名等，加起来总的字符数也不是很多，用1个
字节完全可以容纳，不过汉字就不行了，汉字需要使用2个字节来表示（在某些编码方式中，甚
至会使用3个甚至更多的字节来表示）。
例如“あ”在Shift-JIS中的编码为0x82、0xa0两个字节。只要用文本编辑器输入一个“あ”
并保存，再用二进制编辑器打开就能看到这个编码了（注：在中文系统下，需要用支持选择编码
方式的文本编辑器，并选择用Shift-JIS编码保存）。下面我们来讲解一下如何将0x82、0xa0这两个
字节的编码转换为区点的编号。
■■■■■
我们先来看第一个字节。如果这个字节为0x81，则代表01区或02区；0x82则代表03区或04
区；0x83则代表05区或06区……我们把规则整理成下面这张表，顺便将0x00～0x7f也加进去了。
Shift-JIS的第一个字节
0x00 控制字符 （中略）
0x01 控制字符 0xdd 半角片假名（“ﾝ”）
0x02 控制字符 0xde 半角片假名（“ﾟ”）
（中略） 0xdf 半角片假名（“ﾞ”）
0x1d 控制字符 0xe0 全角字符（1面63区～64区）
0x1e 控制字符 0xe1 全角字符（1面65区～66区）
0x1f 控制字符 0xe2 全角字符（1面67区～68区）
0x20 半角字符（空格） （中略）
0x21 半角字符（“!”） 0xed 全角字符（1面89区～90区）
0x22 半角字符（“””） 0xee 全角字符（1面91区～92区）
（中略） 0xef 全角字符（1面93区～94区）
0x7c 半角字符（“|”） 0xf0 全角字符（2面01区或08区）
0x7d 半角字符（“}”） 0xf1 全角字符（2面03区～04区）
0x7e 半角字符（“~”） 0xf2 全角字符（2面05区或12区）
0x7f 控制字符 0xf3 全角字符（2面13区～14区）
0x80 不使用 0xf4 全角字符（2面15区或78区）
0x81 全角字符（1面01区～02区） 0xf5 全角字符（2面79区～80区）
图灵社区会员 metorm 专享 尊重版权
6 日文文字显示（2）（harib25f） …… 625
（续） 1
0x82 全角字符（1面03区～04区） 0xf6 全角字符（2面81区～82区）
0x83 全角字符（1面05区～06区） 0xf7 全角字符（2面83区～84区） 18
（中略） （中略）
0x9d 全角字符（1面57区～58区） 0xfa 全角字符（2面89区～90区）
3
0x9e 全角字符（1面59区～60区） 0xfb 全角字符（2面91区～92区）
0x9f 全角字符（1面61区～62区） 0xfc 全角字符（2面93区～94区）
20
0xa0 不使用 0xfd 不使用
0xa1 半角片假名（“｡”） 0xfe 不使用
0xa2 半角片假名（““”） 0xff 不使用 21
接下来是第二个字节，如下表。
22
Shift-JIS的第二个字节
0x00 不使用 0x81 全角字符（较小的区的65点） 7
0x01 不使用 0x82 全角字符（较小的区的66点）
0x02 不使用 （中略）
8
（中略） 0x9c 全角字符（较小的区的92点）
0x3d 不使用 0x9d 全角字符（较小的区的93点）
0x3e 不使用 0x9e 全角字符（较小的区的94点） 9
0x3f 不使用 0x9f 全角字符（较大的区的01点）
0x40 全角字符（较小的区的01点） 0xa0 全角字符（较大的区的02点）
26
0x41 全角字符（较小的区的02点） 0xa1 全角字符（较大的区的03点）
0x42 全角字符（较小的区的03点） （中略）
（中略） 0xfa 全角字符（较大的区的92点） 27
0x7c 全角字符（较小的区的61点） 0xfb 全角字符（较大的区的93点）
0x7d 全角字符（较小的区的62点） 0xfc 全角字符（较大的区的94点）
28
0x7e 全角字符（较小的区的63点） 0xfd 不使用
0x7f 不使用 0xfe 不使用
28
0x80 全角字符（较小的区的64点） 0xff 不使用
参照上面的两张表，我们就可以得到“あ”的编码0x82、0xa0对应04区02点。
14
知道了区点编号我们就可以计算出字模的内存地址，再显示出来也就很容易了。
15
■■■■■
我们来修改一下操作系统吧。
16
图灵社区会员 metorm 专享 尊重版权
626 …… 第28天：文件操作与文字显示
本次的graphic.c节选
void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s)
{
extern char hankaku[4096];
struct TASK *task = task_now();
char *nihongo = (char *) *((int *) 0x0fe8), *font; /*从此开始*/
int k, t; /*到此结束*/
if (task->langmode == 0) {
for (; *s != 0x00; s++) {
putfont8(vram, xsize, x, y, c, hankaku + *s * 16);
x += 8;
}
}
if (task->langmode == 1) {
for (; *s != 0x00; s++) {
if (task->langbyte1 == 0) { /*从此开始*/
if ((0x81 langbyte1 = *s;
} else {
putfont8(vram, xsize, x, y, c, nihongo + *s * 16);
}
} else {
if (0x81 langbyte1 && task->langbyte1 langbyte1 - 0x81) * 2;
} else {
k = (task->langbyte1 - 0xe0) * 2 + 62;
}
if (0x40 langbyte1 = 0;
font = nihongo + 256 * 16 + (k * 94 + t) * 32;
putfont8(vram, xsize, x - 8, y, c, font ); /*左半部分*/
putfont8(vram, xsize, x , y, c, font + 16); /*右半部分*/
} /*到此结束*/
x += 8;
}
}
return;
}
本次的bootpack.h节选
struct TASK {
（中略）
unsigned char langmode, langbyte1;
};
图灵社区会员 metorm 专享 尊重版权
6 日文文字显示（2）（harib25f） …… 627
这里的变量k用来存放区号，变量t用来存放点号，为了方便计算，我们存放的是减1之后的
1
值。由于我们没有考虑第2面的字符，因此如果以后要支持第四水准汉字会比较麻烦，不过要支
持第二和第三水准汉字还是比较容易的，只要修改载入nihongo.fnt的部分就可以了。
18
struct TASK中的langbyte1是当接收到全角字符时用来存放第1个字节内容的变量。当接收到
半角字符，或者全角字符显示完成之后，该变量被置为0。
3
putfonts8_asc中每接收到1个字节就会执行x += 8;，当显示全角字符时，需要在接收到第2个
字节之后，再往左回移8个像素并绘制字模的左半部分。
20
采用这种方式时，如果一开始langbyte1不置为0，显示就会出问题，因此我们还需要再修改
一下console.c。
21
本次的console.c节选
22
void console_task(struct SHEET *sheet, int memtotal)
{
（中略）
if (nihongo[4096] != 0xff) { /*是否载入了日文字库？*/ 7
task->langmode = 1;
} else {
task->langmode = 0;
8
}
task->langbyte1 = 0; /*这里！*/
（中略）
} 9
int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)
26
{
（中略）
if (finfo != 0) { 27
/*找到文件的情况*/
（中略）
if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {
28
（中略）
start_app(0x1b, 0 * 8 + 4, esp, 1 * 8 + 4, &(task->tss.esp0));
（中略）
timer_cancelall(&task->fifo); 28
memman_free_4k(memman, (int) q, segsiz);
task->langbyte1 = 0; /*这里！*/
} else { 14
cons_putstr0(cons, ".hrb file format error.\n");
}
（中略）
15
}
（中略）
}
16
图灵社区会员 metorm 专享 尊重版权
628 …… 第28天：文件操作与文字显示
对console_task所做的修改只是在决定langmode默认值时顺便将langbyte1置为0而已。
当程序出现bug或者强制结束时可能出现在显示全角字符第1个字节时停止的情况，而对
cmd_app所做的修改就是为了应对这种情况。
不过换行还有一点问题，当字符串很长时，可能在全角字符的第1个字节处就遇到自动换行
了，这样一来当收到第2个字节时，字模的左半部分就会画到命令行窗口外面去。所以我们在遇
到第1个字节换行时，可以特意将cur_x再右移8个像素。
本次的console.c节选
void cons_newline(struct CONSOLE *cons)
{
int x, y;
struct SHEET *sheet = cons->sht;
struct TASK *task = task_now(); /*这里！*/