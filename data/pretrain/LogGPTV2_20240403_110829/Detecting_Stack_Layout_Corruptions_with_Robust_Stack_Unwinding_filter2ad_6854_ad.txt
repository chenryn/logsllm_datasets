.
s
s
e
m
a
g
6
1
4
.
p
m
s
u
e
z
.
4
3
4
s
c
a
m
o
r
g
.
5
3
4
h
c
n
e
b
l
r
e
p
.
0
0
4
M
D
A
s
u
t
c
a
c
.
6
3
4
d
3
e
i
l
s
e
l
.
7
3
4
d
m
a
n
.
4
4
4
k
m
b
o
g
.
5
4
4
x
e
l
p
o
s
.
0
5
4
y
a
r
v
o
p
3
5
4
.
g
n
e
j
s
.
8
5
4
x
i
l
u
c
l
a
c
.
4
5
4
r
e
m
m
h
6
5
4
.
f
r
.
w
1
8
4
r
a
t
s
a
.
3
7
4
m
b
l
.
0
7
4
o
t
n
o
t
.
5
6
4
p
p
t
e
n
m
o
1
7
4
.
3
x
n
i
h
p
s
.
2
8
4
d
n
a
r
c
e
p
s
.
8
8
9
d
n
a
r
e
p
s
.
9
9
9
f
e
r
4
6
2
h
.
4
6
4
D
T
D
F
s
m
e
G
9
5
4
.
m
u
t
n
a
u
q
b
i
l
.
2
6
4
Fig. 6. Runtime performance of SLIck.
Runtime Impact for the SYS Policy. With this policy, the average overhead
of SLIck in 34 evaluated programs is 3.09 % with the maximum overhead of
22.8 % in Mysql. High overhead of Mysql is due to very intensive stress tests for
a database in I/O and low level services. As an evidence, the second column of
Table 2 which is the system call count shows that Mysql benchmark generates a
signiﬁcantly higher number of system calls over 40 millions compared to other
programs having under 164 thousands system calls.
Runtime Impact for the SYS+INT Policy. A ﬁner-grained inspection
based on system calls and timer interrupts is oﬀered with a slightly higher per-
formance cost of 3.93 % on average and with the maximum overhead of 22.8 % in
Mysql. This policy causes increased overhead on CPU intensive workloads due
to additional inspections introduced by timer interrupts.
7 Discussion
Comparison with ROPGuard/EMET. Our work is closely related to an
early exploration based on stack unwinding, ROPGuard/EMET [21]. How-
ever, there are several major diﬀerences that distinguish SLIck from ROP-
Guard/EMET as follows.
– Our approach has a higher and reliable inspection coverage compared to ROP-
Guard: SLIck inspects the user stack with the full depth on all system calls
and timer interrupts. In contrast, ROPGuard inspects the stack only on a
selective set of critical user level APIs with a limited depth of the stack. Thus
ROPGuard/EMET cannot detect the attacks that directly trigger system
calls without using the APIs. Also if the binary is built statically, ROPGuard
cannot be applied due to its base on the library interposition technique.
– ROPGuard operates in the same user level as the monitored program. There-
fore, it is subject to manipulation by the attacker. However, SLIck is isolated
from the user space due to its implementation in the OS kernel.
– SLIck’s inspections are performed with a higher frequency compared to ROP-
Guard: SLIck inspects the stack on all system calls and non-deterministic
Detecting Stack Layout Corruptions with Robust Stack Unwinding
87
timer interrupts. ROPGuard, however, only checks the stack on a set of
critical API functions.
– SLIck achieves a reliable stack walking and improved ROP detection by using
precise stack layout information extracted from the unwinding data while
ROPGuard uses a heuristic based on the frame pointer which is not reliable.
– This work proposes two stack layout invariants which are derived from the
unwinding information, and these invariants are veriﬁed by using an improved
and reliable stack walking mechanism.
– We discovered that a small number of binaries have incomplete unwinding
information which aﬀects the current stack walking mechanisms. We propose
ﬂexible stack unwinding algorithm to overcome this issue and enable a reliable
and high quality inspection of the entire stack.
Stack Pivoting Attacks. A stack pivoting attack [49,62] manipulates the
stack pointer to point to the data controlled by ROP gadgets. This attack is
trivially detected by our approach because SLIck uses the valid stack memory
address ranges assigned by the OS. When an unexpected memory area is used
for the stack pointer, SLIck detects it as a FCI violation (Sect. 5.2). A related
work [43] achieves this feature using a compiler approach and source code while
SLIck can prevent this attack transparently for existing binaries.
Stack Manipulation Detection. Traditional buﬀer overﬂow attacks [36,48,51]
attempting to overwrite the return addresses in the stack are likely to violate the
invariants. Thus such attacks can be transparently detected by SLIck without any
recompilation, or instrumentation of the program.
Support of Dynamic Code. Dynamically generated code is used by several
platforms such as virtual machines, interpreters, dynamic binary translators,
and emulators. While they are out of the scope of this paper, we believe our
approach can be extended to support them with engineering eﬀorts because
these platforms also provide ways to unwind stack frames for dynamic code. For
instance, Java has a tool called jstack that can dump the whole stack frames
including both of the Java code and the underlying native code and libraries.
If such a platform-speciﬁc logic is integrated into our stack unwinding algorithm,
we should be able to support such dynamic code as well as native code.
Integrity of a Kernel Monitor. SLIck resides in the OS kernel. While the
attack scenarios of ROP exploits against the kernel is certainly possible, in this
paper we do not focus on the countermeasures for such attacks because of existing
detection or prevention mechanisms on OS kernel integrity [22,23,27,39–41,45].
We rely on such approaches to ensure the integrity of SLIck.
Control-Flow Integrity. Our approach raises the bar for ROP exploits by
introducing new security invariants on the layout of the stack. Essentially code
88
Y. Fu et al.
and the stack status have correspondence generated by compilers, but it is not
strictly enforced at runtime. SLIck veriﬁes this loose correspondence by using