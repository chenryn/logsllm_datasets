### 运行时性能分析

#### SYS策略下的运行时影响
在SYS策略下，SLIck在34个评估程序中的平均开销为3.09%，其中Mysql的最大开销达到22.8%。Mysql的高开销主要是由于其在I/O和低级服务上的密集压力测试所致。如表2第二列所示，Mysql生成了超过4000万次系统调用，远高于其他程序（这些程序的系统调用次数均低于164,000）。

#### SYS+INT策略下的运行时影响
基于系统调用和定时器中断的更细粒度检查提供了更高的性能成本，平均为3.93%，最大开销同样出现在Mysql中，为22.8%。这种策略增加了CPU密集型工作负载的开销，因为定时器中断引入了额外的检查。

### 讨论

#### 与ROPGuard/EMET的比较
我们的工作与早期基于栈展开技术的探索（即ROPGuard/EMET [21]）密切相关，但存在一些显著差异：
- **检查覆盖率**：SLIck在所有系统调用和定时器中断上对用户栈进行全深度检查，而ROPGuard仅在一组选定的关键用户级API上进行有限深度的检查。因此，ROPGuard/EMET无法检测到直接触发系统调用而不使用API的攻击。此外，如果二进制文件是静态构建的，ROPGuard也无法应用，因为它依赖于库插桩技术。
- **隔离性**：ROPGuard在用户级别运行，容易受到攻击者的操纵；而SLIck通过在操作系统内核中实现，从而与用户空间隔离。
- **检查频率**：SLIck在所有系统调用和非确定性的定时器中断上进行检查，而ROPGuard仅在一组关键API函数上检查栈。
- **可靠性**：SLIck利用从展开数据中提取的精确栈布局信息来实现可靠的栈遍历和改进的ROP检测，而ROPGuard则依赖于不可靠的帧指针启发式方法。
- **新提出的不变量**：本文提出了两个从展开信息中派生出的栈布局不变量，并通过改进且可靠的栈遍历机制进行验证。
- **灵活的栈展开算法**：我们发现少数二进制文件具有不完整的展开信息，这会影响当前的栈遍历机制。为此，我们提出了一种灵活的栈展开算法，以克服这一问题并实现整个栈的可靠高质量检查。

#### 栈枢轴攻击
栈枢轴攻击[49,62]通过操控栈指针指向受控的ROP小工具数据区域。SLIck能够轻松检测此类攻击，因为它使用由操作系统分配的有效栈内存地址范围。当栈指针指向意外的内存区域时，SLIck会将其识别为FCI违规（第5.2节）。相关研究[43]通过编译器方法和源代码实现了类似功能，而SLIck可以在不重新编译或对程序进行任何工具化的情况下透明地防止此类攻击。

#### 栈操作检测
传统的缓冲区溢出攻击[36,48,51]试图覆盖栈中的返回地址，这类攻击很可能违反SLIck所定义的不变量。因此，SLIck可以无需重新编译或对程序进行任何工具化即可透明地检测到这些攻击。

#### 动态代码支持
动态生成的代码被虚拟机、解释器、动态二进制翻译器和仿真器等平台广泛使用。虽然这些不在本文的研究范围内，但我们认为通过工程努力，SLIck的方法可以扩展以支持它们，因为这些平台也提供了用于动态代码的栈帧展开方法。例如，Java有一个名为jstack的工具，可以转储包括Java代码及其底层本地代码和库在内的所有栈帧。如果将这种特定于平台的逻辑集成到我们的栈展开算法中，我们应该能够支持这样的动态代码以及原生代码。

#### 内核监控完整性
SLIck驻留在操作系统内核中。尽管针对内核的ROP攻击场景确实可能存在，但在本文中我们并未专注于此类攻击的对策，因为已有多种现有的检测或预防机制来确保操作系统内核的完整性[22,23,27,39–41,45]。我们依靠这些方法来确保SLIck的完整性。

#### 控制流完整性
我们的方法通过引入新的栈布局安全不变量提高了ROP攻击的门槛。本质上，代码和栈状态之间存在由编译器生成的对应关系，但在运行时并未严格执行。SLIck通过使用精确的栈布局信息来验证这种松散的对应关系。