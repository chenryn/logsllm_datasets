cute interrupt handlers as appropriate. In this mode, then,
FIE never generates symbolic variables, and so is able to
quickly evaluate on concrete values along many paths.
Fuzzing provides surprisingly good coverage for many
of the ﬁrmware programs, in fact beating symbolic exe-
cution modes in many cases. This is because fuzzing can
evaluate states more quickly, and for simple programs
this can lead to good coverage in a 50 minute test.
USENIX Association  
22nd USENIX Security Symposium  473
11
e
g
a
r
e
v
o
c
e
v
i
t
a
l
e
R
0.6
0.4
0.2
0
−0.2
−0.4
−0.6
1
25
50
75
99
1
25
50
75
99
Figure 8: Coverage of SMUDGE relative to FUZZ (top) and
SMUDGE relative to PLAIN (bottom) for the 50-minute tests.
Here SMUDGE outperforms FUZZ and PLAIN for 32% and 42%
of the programs, respectively.
Plain, Prune, and Smudge: We now turn to modes
that use FIE as a symbolic executor with the architecture-
aware analysis. To compare the efﬁcacy of the state prun-
ing and memory smudging techniques, we use three dif-
ferent modes: PLAIN (no pruning or smudging), PRUNE
(with pruning but not smudging), and SMUDGE (pruning
and smudging, with smudging threshold t = 100). All
three modes used the most conservative interrupt model.
Overall SMUDGE provides better coverage than all oth-
ers, including FUZZ. A comparison of relative perfor-
mance for each ﬁrmware appears in the charts of Fig-
ure 8. The x-axes is the ﬁrmware (ordered by y-values)
and the y-value is (Ns−Nf )/Ntot where Ns is, for the left
chart, the number of instructions covered by SMUDGE
for this ﬁrmware, Nf is the number covered by FUZZ,
and Ntot is the NEXI for the ﬁrmware. The right chart
is the same except comparing SMUDGE with PLAIN.
These graphs surface two facts. First, there exists a large
number of ﬁrmware programs for which the analyses do
equally well (where relative coverage is 0, most often be-
cause both analyses had 100% coverage), which is due to
the large number of very simple ﬁrmware from GitHub
and the TI website. Second, SMUDGE can do worse than
others on a few ﬁrmware programs, but improves per-
formance over FUZZ for 32% of the programs and over
PLAIN for 42% of the programs.
50-minute analysis outcomes:
In Table 9 we give a
breakdown of the emitted termination status for the anal-
yses. FIE can either stop because it runs out of mem-
ory (No mem), the requested amount of execution time
has been reached (Timeout), or because there exist no
more active states (Finished). Additionally, FIE will out-
put bug reports. As can be seen, pruning and smudging
help reduce memory usage and increase the number of
analyses that ﬁnish. Potential bugs were reported for 92
ﬁrmware programs by the BASELINE, all false positives.
Smudging introduced a false positive in one ﬁrmware,
since a pointer was smudged. (Smudging a pointer fre-
quently leads to a memory safety violation, because any
dereference of it will be viewed as an error.) FIE makes
it easy to determine if a warning is related to smudging
Mode
BASELINE
FUZZ
PLAIN
PRUNE
SMUDGE
Termination status
FPs
No mem Timeout
Finished
9
10
7
0
0
2
79
85
64
46
88
10
7
35
53
93
0
0
0
1
Table 9: Counts of each termination code seen in the 50-minute
runs. “No mem”: the analysis exhausted memory; “Timeout”:
analysis ran for the full 50 minutes; “Finished”: analysis com-
pleted early. The ﬁnal column is the number of ﬁrmware pro-
grams with erroneous bug reports.
by marking variables that were smudged as such in the
bug report. No true positives were found in these short
runs.
Recall that an explicit design goal for FIE was the abil-
ity to support complete analyses (all possible symbolic
states are checked). The PLAIN, PRUNE, and SMUDGE
modes do support this: an analysis is complete if the
termination status was Finished and no bugs were re-
ported. Modulo the limitations discussed in the next sec-
tion, this veriﬁes the absence of bugs. The ﬁrst row of Ta-
ble 7 shows the number of ﬁrmware programs for which
PLAIN, PRUNE, or SMUDGE were able to verify the ab-
sence of memory safety and (some kinds of) peripheral
misuse bugs, in these short 50 minute runs.
As can
be seen, our pruning and smudging mechanisms enable
a huge increase in the number of analyses that FIE can
complete: a 6x increase when we use pruning and an
additional factor of 1.48x improvement when we add in
smudging. In the end, the total number of ﬁrmware pro-
grams for which one of the analysis modes completed is
53. (One ﬁrmware was completed by PRUNE but had a
false positive under SMUDGE, and so it was not counted
in the SMUDGE column of Table 7.)
We note that these complete analyses revealed that 13
ﬁrmware programs have dead code missed by the static
optimization passes, which means for these our mea-
sured coverage is lower than it should be (e.g., for one
ﬁrmware we achieved a complete analysis but only 45%
coverage). For consistency, we do not correct the NEXI
values for these ﬁrmware programs.
Firmware complexity measures: The above shows that
FIE enables complete analyses for a majority of the
ﬁrmware programs in our corpus, yet the total amount of
code covered across the full corpus indicates that FIE was
not able to explore most of the larger ﬁrmware programs
given only 50 minutes. As can be seen in Figure 10, the
coverage is uniformly poor for ﬁrmware programs with
more than 4,000 executable instructions. More subtly,
there exist many much smaller programs for which cov-
erage is also poor (the vertical trend closer to the y-axis),
which could be due to complicated but short code con-
474  22nd USENIX Security Symposium 
USENIX Association
12
)
%
(
e
g
a
r
e
v
o
C
1
0.8
0.6
0.4
0.2
0
0
FUZZ
PLAIN
PRUNE
SMUDGE
Conservative
Basic block
e
g
a
r
e
v
o
C
%
1
0.8
0.6
0.4
0.2
0
1,000 2,000 3,000 4,000 5,000 6,000
NEXI
Figure 10: Coverage as a function of ﬁrmware size in the 50
minute tests.
Complexity
Criteria
# FWs
low
medium
high
≤ 100 NEXI
or  500 NEXI
and ≥ 2 loops
49
37
13
SMUDGE
coverage
Avg: 93.6%
Med: 100%
Avg: 79.5%
Med: 93.1%
Avg: 27.8%
Med: 24.8%
Table 11: Criteria for ﬁrmware complexity groups, the number
of ﬁrmware programs (# FWs) in each group, and SMUDGE’s
average and median coverage for each group.
structs or, perhaps, undiscovered dead code.
To focus subsequent experiments on the more chal-
lenging ﬁrmware programs, we partition the programs
into three complexity groups based on a simple static
analysis.
(Using static analysis avoids biasing the set
unnecessarily by the nature of FIE’s analysis.) The cri-
teria for partitioning our programs into low-, medium-,
and high-complexity groups is described in Table 11. To
determine the number of loops in a program, we use
LLVM’s built-in loop detection. We chose this partic-
ular partitioning for its simplicity, but admit there are
many other possibilities. We give the average and me-
dian performance of the 50-minute SMUDGE runs as bro-
ken down by each group. Of the 53 programs that FIE is
able to complete analysis for in 50 minutes, 38 are low
complexity and 14 are medium complexity. The average
NEXI for these completed programs is 84.4 and the aver-
age number of loops is 2.2; the most complex completed
program has a NEXI of 414 and 17 loops.
Effect of smudging threshold: We now measure the ef-
fect of the smudging threshold t on coverage and false
positive rates for the high complexity ﬁrmware pro-
grams. By decreasing t one might hope to achieve a
trade-off between coverage improvements (by breaking
out of loops even more quickly) and increased risk in
false positives. We run SMUDGE for 50-minutes for
each of t = 1,10,1000 for the 13 ﬁrmware programs and
Figure 12: Coverage when spawning interrupts every instruc-
tion (Conservative) versus once per basic block for the 13 high-
complexity ﬁrmware programs.
use as well the t = 100 results from the runs discussed
above. The average coverages were 23.3%, 25.2%,
25.5%, 25.6% for t = 1,10,100,1000, making the dif-
ferences too small to be signiﬁcant. The number of false
positives increased for small t; with t = 1 there were two
false positives, and none for the larger values of t. We
conclude that t = 100 strikes a reasonable balance, but
further performance improvements may not be easily ob-
tained by tweaking t.
Relaxing the interrupt model: Recall that we have so
far been using FIE with a very conservative interrupt
model in which all enabled interrupts ﬁre at every pro-
gram point. This can mean that most instructions, as
opposed to just branches, end up forking off multiple
new states. We therefore implement a relaxed interrupt
model in which every enabled interrupt ﬁres at the ﬁrst
instruction of each basic block, but not during subse-
quent instructions. This means analysis will miss pos-
sible paths (barring complete analyses) but could speed
up performance and thereby increase code coverage. In
Figure 12 we compare, for the high-complexity ﬁrmware
programs, the coverage obtained by SMUDGE with t =
100 using both the conservative interrupt model (Con-
servative) and the new model that only ﬁres at each basic
block (Basic block). The results are both from 50 minute
runs. Several of the ﬁrmware programs see drastic cover-
age improvements, the last bar on the right represents the
largest improvement at 232%. No false positives arose in
these basic block runs, however one program hit a code
construct4 currently not supported by FIE.
Finding vulnerabilities: FIE currently supports ﬁnding
two types of bugs: memory safety violations, such as
buffer overruns and out-of-bounds accesses to memory
objects like arrays, as well as peripheral-misuse errors in
which a ﬁrmware writes to a read-only memory location
or to locked ﬂash. It will be easy to increase scope to
further security properties in the future.
4A ﬁrmware used a custom variable argument function. We plan to
add support in the public release version.
USENIX Association  
22nd USENIX Security Symposium  475
13
Firmware
CDC Driver
HID Driver
controleasy
Types
NEXI
4,489 Memory safety
2,958 Memory safety
1,255
Flash misuse
# bugs
10
11
1
Table 13: Summary of vulnerabilities discovered by FIE. The
ﬁnal column is the number of distinct vulnerabilities in the
ﬁrmware.
We supplemented the above analyses with runs in
which we allowed SMUDGE to run up to 24 hours, with
t = 100 and using the conservative interrupt model, on
each of the 13 high-complexity programs. Table 13 gives
a breakdown of the 22 bugs found across all of the runs.
The bugs were spread across three ﬁrmware programs,
the two USB drivers supplied by TI and one community
ﬁrmware called Controleasy. Of the bugs, 21 were mem-
ory safety violations while one was a ﬂash misuse bug.
CDC Driver and HID Driver share some common source
ﬁles, one of the bugs spans both, while the others are