S
newkey
Con ≡ νK.Key(K, B, C, A)
Con ≡ Key(K, B, X, Y )
where
(X,Y) = (A,C) or (C,A)
keyconﬁrm
Pre(+S)
True
KnowA,ρKey(K, B, X, Y ) KnowA,ρKey(K, A, B, C)
Eﬀect(+S)
GKA,ρ(K, B, C)
Pre(-S)
True
True
True
Eﬀect(-S)
Inf ormedB,τ (K, B, C, A)
Inf ormedB,τ (K, B, X, Y )
True
KnowB,τ Key(K, A, B, C)
KnowB,τ KnowA,ρ
Key(K, A, B, C)
Axiom A9 states that if a key K is generated by A then K
is generated by A acting in some role. Axioms A10,A11,A12
are based on the honesty assumption of regular principals.
The intuition of axiom A10 is that generated keys are ran-
dom and hence it is impossible for an agent to generate the
same key twice. Axiom A11 follows from the structure of
the speech acts that requires that when a key is sent in a
speech act, information about the association of the key to
the receiver of the act must be included. Hence a honest
principal would never receive a key that is not associated
with it. Axiom A12 states that freshly generated session
keys are accessible only by their generator and the princi-
pals for whom they are generated. This axiom implies that
well-designed protocols protect the secrecy of the exchanged
keys.
Let AP be the abstract protocol in example 1. Let R0, R1
be complete runs of regular principals A and B in the ini-
tiator (denoted by I) and responder (denoted by R) roles
respectively. S is a regular principal in the role of a server.
Applying the eﬀect rule and then the consequence rule, we
obtain:
(cid:5) AP.R0[KnowA,I KnowB,RKey(K, A, B, S)] and
(cid:5) AP.R1[KnowB,RKnowA,I Key(K, A, B, S)]
(cid:5) AP.R0[KnowA,I Key(K, A, B, S)] and
(cid:5) AP.R1[KnowB,RKey(K, A, B, S)]
Hence
Applying the inference rule and axioms of S5 and the ax-
iom A12, we obtain:
(cid:5) AP.R0[KnowA,I¬Access(P E, K)] and
(cid:5) AP.R1[KnowB,R¬Access(P E, K)]
4.
IMPLEMENTING SPEECH ACTS
The events of sending or receiving speech acts are imple-
mented by the actions of sending or receiving some message.
+νb.m
A sending action has the form
while a receiving action has the form
where m is
a message and b is a key or nonce. The notation νb indicates
that b is freshly (or randomly) generated at this action (i.e.
the action actually consists of two tasks: generating b and
sending out the message). m is also called the message of
the respective action.
−m
+m
or
Note that for ease of reference, we have made a distinc-
tion between the higher-level notion of events of sending
or receiving speech acts denoted by +S or -S where S is a
speech act, and the lower-level notion of actions of sending
or receiving messages. As such, events are implemented by
actions.
Let S be a speech act. The messages appearing in the
actions implementing the events of sending or receiving S
are called the representations of S. A speech act could have
more than one representation.
Taking a hint from prudent engineering [2], a representa-
tion of a speech act should contain vital information about
its type, its content, the identity and role of its sender and
receiver and other information like reply-to, and reply-with-
nonces. We simply assume that the principals somehow rec-
ognize the basic message components like nonce, keys and
principal identiﬁers when they see them. See [16] on how it
could be done.
Let S be a speech act from a sender A in role ρ to a receiver
B in role τ . The notation mS refers to a representation of
S. We also often say that mS represents S.
If S is an inform act of type newkey whose content is of
the form Key(K,B,X,Y) (where (X,Y) = (A,C) or (C,A))
then
mS = {inf, newkey, A, ρ, B, τ, K, B, X, Y }KAB , or
mS = {inf, newkey, A, ρ, B, τ, K, B, X, Y }KB ,
If S is an inform act of type keyconﬁrm with a content of
the form Key(K,A,B,C) then
mS = {inf, keyconf irm, A, ρ, B, τ, C}K , or
mS = {inf, keyconf irm, A, ρ, B, τ, Hash(K), C}KB
The representation of a request (resp. reply) act depends
on the representation of the reply (resp. request) act in the
same conversation. Let (S,S’) be a conversation form and n
be the nonce in S,S’.
If (S,S’) is a conversation of type newkey and the content
of S’ is νK.Key(K, A, C, B), then there are at least two
diﬀerent ways to represent (S, S
):
(cid:1)
• mS = {req, newkey, A, ρ, B, τ, n, C}KB
mS(cid:1) = {rep, newkey, B, τ, A, ρ, n, K, C}KA
• mS = req, newkey, A, ρ, B, τ, n, C
mS(cid:1) = {rep, newkey, B, τ, A, ρ, n, K, C}KAB ,
If (S,S’) is a conversation of type keyconﬁrm and the con-
tent of S is Key(K,A,B,C), then there are at least two dif-
ferent ways to represent (S, S
):
(cid:1)
• mS = {req, keyconf irm, A, ρ, B, τ, n, Hash(K), C}KB
mS(cid:1) = {rep, keyconf irm, B, τ, A, ρ, n}KA
• mS = {req, keyconf irm, A, ρ, B, τ, n, Hash(K), C}KAB
mS(cid:1) = {rep, keyconf irm, B, τ, A, ρ, n, Hash(K), C}KAB ,
The event +S of sending a speech act S is implemented by
the action +mS with two exceptions: 1) if S is a request act
with nonce n then the event of sending S is implemented by
the action +νn.mS, and 2) if S is a reply or inform act of
type newkey with a content of the form νK.Key(K, X, Y, Z),
then the event of sending S is implemented by the action
+νK.mS.
mented by the action −mS
The event -S of receiving a speech act S is always imple-
As there are many diﬀerent ways to implement speech
acts, a speech act-oriented protocol could have many dif-
ferent implementations. For example, there are at least 16
diﬀerent but correct ways to implement the abstract proto-
col in example 1.
Though a speech act could have many representations, it
is easy to see that each representation represents exactly one
speech act
Lemma 1: Let S and R be speech acts and mS, mR be
representations of S,R respectively. If S and R are diﬀerent
acts then mS (cid:6)= mR
4.1 Role Topology and Message Forwarding
Many security protocols do not allow principals acting
in certain roles to communicate directly. An example is
the well-known Otway-Rees protocol [8] (see appendix B)
that does not allow initiators to communicate directly with
servers. All messages between principals in these roles are
routed through the responders.
In general, each security protocol P assumes the existence
of a directed graph G = (RO, V ), V = RO × RO describ-
ing the connection topology of the roles in P. A direct link
from role ρ to role τ in G represents a direct communication
channel from principals acting in role ρ to principals act-
ing in role τ . A question that immediately arises is how to
implement a speech act if the role topology forbids a direct
communication between its sender and receiver.
Consider the abstract speech act oriented protocol in ex-
ample 1. Suppose that the connection topology allows direct
communication only between initiators and servers as well as
between initiators and responders. In this case, the speech
act (3) in which S informs B about the new key K is imple-
mented by letting S (server) send message to B (responder)
through A (initiator). See appendix C for more details.
We give now the general translation algorithm. Let P be a
well-designed speech act oriented protocol and G = (RO, V )
be a given connection topology for the roles in P
Let S be a speech act in P and ρ, τ be the roles of the
sender A and receiver B in S respectively. Further let
ρ, ρ1, . . . , ρm, τ be a shortest path from ρ to τ with A1, . . . , Am
being the principal terms occupying the roles ρ1, . . . , ρm in
P. S is implemented by forwarding the message mS from A
through A1, . . . , Am to B as:
mS−→ Am
A
P is translated into a message exchanging protocol by suc-
mS−→ . . .
mS−→ A1
mS−→ B
cessively translating each of its acts as above.
5. SOUNDNESS AND COMPLETENESS OF
PROTOLOG
Strand spaces have been introduced by Fabrega, Herzog
and Guttman [11] to give an operational semantics for message-
exchanging protocols under the Dolev-Yao assumption of
perfect cryptography. We adapt the strand space model to
our framework to give an operational semantics to the lower-
level message-exchanging protocols obtained by implement-
ing the speech acts as described in the previous chapter. The
protocol logic Protolog is then interpreted over the adapted
strand models.
Let AP be an arbitrary but ﬁxed speech act oriented key
exchange protocol. For simplicity and due to the limited
space, we assume that AP has a role topology in which there
is a direct link between every pair of diﬀerent roles (all the
results in this chapter are proved for the general case in the
full paper). A strand is a sequence of nodes labelled by
actions of sending or receiving messages. The ith node of a
strand s is denoted by (s,i). Act(s,i) denotes the ith action
in s. The message of the action labelling (s,i) is denoted by
term(s, i). Often, if there is no danger of confusion, a strand
is identiﬁed with the sequence of actions labelling its nodes.
A binary relation ⇒ over the set of strand nodes is deﬁned
by ⇒ = {((s, i), (s, i + 1)) | s is a strand }
Let S be a set of strands and (s,i) be a node in S. A key
or nonce b is said to originate at (s,i) if (s,i) is a sending
action and b occurs in term(s,i) and for all j < i, b does not
occur in term(s,j). b is said to uniquely originate at (s,i) in
S if (s,i) is the only node in S at which b originates.
There are two kinds of strands, regular strand and pene-
trator strands. A node lying on a regular (resp. penetrator)
strand is called a regular (resp. penetrator) node. We often
say that a node N implements a speech act event E if the
action labelling N implements E. For a regular principal A
and a role ρ ∈ RO, an AP-regular strand of A in role ρ is
a regular strand s = N1, . . . , Nm such that each Ni imple-
ments the event Ei in a run R = E1, . . . , Em of A in role ρ
according to AP. We also say that strand s implements run
R. There are eight kinds of penetrator strands:
Key-strand: (cid:10)+K(cid:11) where K ∈ KEY \ K
RO-strand: (cid:10)ρ(cid:11) where ρ ∈ RO
PI-strand: (cid:10)+A(cid:11) where A ∈ P I
Nonce-strand: (cid:10)+n(cid:11) where n ∈ N ON CE
S-strand: (cid:10)−gh +g +h(cid:11)
E-strand: (cid:10)−K − h + {h}K(cid:11)
C-strand: (cid:10)−g − h + gh(cid:11)
D-strand: (cid:10)−K
−1 − {h}K + h(cid:11)
where K consists of all secret shared keys KAB, and private
keys K
−1
A of regular principals.
With the exception of the Key, and RO-strands, the other
deﬁnitions of penetrator strands coincide with the deﬁni-
tions given in [11, 14]. In [11, 14], the penetrator is assumed
to possess initially a set of keys and the key the penetrator
could pick up in a key strand should belong to this set. We
do not impose this restriction on the penetrator as we as-
sume that the penetrator has access to any algorithm that
could be used for key or nonce generation.
The assumption that the keys or nonces generated by reg-
ular principals are random and hence could not be generated
by the penetrator is captured by their unique origination re-
quirement in the deﬁntion of historical bundles ( introduced
shortly below)
A bundle of AP is is deﬁned as a pair (S,→) whereas
S is a ﬁnite set of strands, → is a binary relation over the
set of nodes in S such that the following two conditions are
satisﬁed:
(cid:1)
(cid:1)
(cid:1)
, i
(cid:1)
(cid:1)
, i
) hold
then there is exactly one node (s’,i’) such that Act(s
is a sending action and (s
term(s
1) For each node (s,i) in S, if Act(s,i) is a receiving action
(cid:1)
, i
)
) → (s, i) and term(s, i) =
2) The transitive closure of the relation → ∪ ⇒ is acyclic
3) Every regular strand in S is AP-regular.
The notation n (cid:13)→ n
(cid:1)
means that either n ⇒+ n
(cid:1)
with n a
receiving node and n’ a sending node, or n → n
(cid:1)
. A path is
a ﬁnite sequence of nodes and edges n1 (cid:13)→ n2 (cid:13)→ . . . (cid:13)→ nk.
A strand s is said to precede (resp. follow) a strand r in
a bundle (S,→) if there is path starting in s (resp. r) and
ends in r (resp. s).
To deal with replay attacks, we introduce the idea of his-
torical bundle as a triple (S0, S1, →) whereas (S0 ∪ S1,→)
is a bundle and S0 (resp. S1) is the set of past (resp. re-
cent) strands. Recent strands represent runs that have just
happened recently while past strands represent strands that
had happened in the past. Therefore it is possible that