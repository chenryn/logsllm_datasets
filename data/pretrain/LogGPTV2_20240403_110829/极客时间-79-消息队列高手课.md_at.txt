# 注意缩进    
# 在这里安全的访问共享资源    
# 锁会在 with 代码段执行完成后自动释放接下来我们说一下，使用锁的时候，遇到的最常见的问题：死锁。
## 如何避免死锁？死锁是指，由于某种原因，锁一直没有释放，后续需要获取锁的线程都将处于等待锁的状态，这样程序就卡死了。导致死锁的原因并不多，第一种原因就是我在刚刚讲的，获取了锁之后没有释放，有经验的程序员很少会犯这种错误，即使出现这种错误，也很容易通过查看代码找到Bug。还有一种是锁的重入问题，我们来看下面这段代码：    public void visitShareResWithLock() {  lock.lock(); // 获取锁  try {    lock.lock(); // 再次获取锁，会导致死锁吗？  } finally {    lock.unlock();  }在这段代码中，当前的线程获取到了锁lock，然后在持有这把锁的情况下，再次去尝试获取这把锁，这样会导致死锁吗？答案是，不一定。**会不会死锁取决于，你获取的这把锁它是不是可重入锁。**如果是可重入锁，那就没有问题，否则就会死锁。大部分编程语言都提供了可重入锁，如果没有特别的要求，你要尽量使用可重入锁。有的同学可能会问，"既然已经获取到锁了，我干嘛还要再次获取同一把锁呢？"其实，如果你的程序足够复杂，调用栈很深，很多情况下，当你需要获取一把锁的时候，你是不太好判断在n层调用之外的某个地方，是不是已经获取过这把锁了，这个时候，获取可重入锁就有意义了。最后一种死锁的情况是最复杂的，也是最难解决的。如果你的程序中存在多把锁，就有可能出现这些锁互相锁住的情况。我们一起来看下面这段Python 代码：    import threading def func1(lockA, lockB):  while True:    print("Thread1: Try to accquire lockA...")    with lockA:      print("Thread1: lockA accquired. Try to accquire lockB...")      with lockB:        print("Thread1: Both lockA and LockB accrquired.")  def func2(lockA, lockB):  while True:    print("Thread2: Try to accquire lockB...")    with lockB:      print("Thread2: lockB accquired. Try to accquire lockA...")      with lockA:        print("Thread2: Both lockA and LockB accrquired.")  if __name__ == '__main__':  lockA = threading.RLock();  lockB = threading.RLock()  t1 = threading.Thread(target=func1, args=(lockA, lockB,))  t2 = threading.Thread(target=func2, args=(lockA, lockB,))  t1.start()  t2.start()这个代码模拟了一个最简单最典型的死锁情况。在这个程序里面，我们有两把锁：lockA和lockB，然后我们定义了两个线程，这两个线程反复地去获取这两把锁，然后释放。我们执行以下这段代码，看看会出现什么情况：    $ python3 DeadLock.pyThread1: Try to accquire lockA...Thread1: lockA accquired. Try to accquire lockB...Thread1: Both lockA and LockB accrquired.Thread1: Try to accquire lockA...... ...Thread1: Try to accquire lockA...Thread2: Try to accquire lockB...Thread1: lockA accquired. Try to accquire lockB...Thread2: lockB accquired. Try to accquire lockA...可以看到，程序执行一会儿就卡住了，发生了死锁。那死锁的原因是什么呢？请注意看代码，这两个线程，他们获取锁的顺序是不一样的。第一个线程，先获取lockA，再获取 lockB，而第二个线程正好相反，先获取 lockB，再获取 lockA。然后，你再看一下死锁前的最后两行日志，线程 1 持有了 lockA，现在尝试获取lockB，而线程 2 持有了 lockB，尝试获取lockA。你可以想一下这个场景，两个线程，各持有一把锁，都等着对方手里的另外一把锁，这样就僵持住了。这是最简单的两把锁两个线程死锁的情况，我们还可以分析清楚，你想想如果你的程序中有十几把锁，几十处加锁解锁，几百的线程，如果出现死锁你还能分析清楚是什么情况吗？关于避免死锁，我在这里给你几点建议。1.  再次强调一下，避免滥用锁，程序里用的锁少，写出死锁 Bug    的几率自然就低。2.  对于同一把锁，加锁和解锁必须要放在同一个方法中，这样一次加锁对应一次解锁，代码清晰简单，便于分析问题。3.  尽量避免在持有一把锁的情况下，去获取另外一把锁，就是要尽量避免同时持有多把锁。4.  如果需要持有多把锁，一定要注意加解锁的顺序，解锁的顺序要和加锁顺序相反。比如，获取三把锁的顺序是    A、B、C，释放锁的顺序必须是 C、B、A。5.  给你程序中所有的锁排一个顺序，在所有需要加锁的地方，按照同样的顺序加解锁。比如我刚刚举的那个例子，如果两个线程都按照先获取    lockA 再获取 lockB 的顺序加锁，就不会产生死锁。最后，你需要知道，即使你完全遵从我这些建议，我也无法完全保证你写出的程序就没有死锁，只能说，会降低一些犯错误的概率。
## 使用读写锁要兼顾性能和安全性对于共享数据来说，如果说某个方法在访问它的时候，只是去读取，并不更新数据，那是不是就不需要加锁呢？还是需要的，因为如果一个线程读数据的同时，另外一个线程同时在更新数据，那么你读到的数据有可能是更新到一半的数据，这肯定是不符合预期的。所以，无论是只读访问，还是读写访问，都是需要加锁的。如果给数据简单地加一把锁，虽然解决了安全性的问题，但是牺牲了性能，因为，那无论读还是写，都无法并发了，跟单线程的程序性能是一样。实际上，如果没有线程在更新数据，那即使多个线程都在并发读，也是没有问题的。我在上节课跟你讲过，大部分情况下，数据的读写比是不均衡的，读要远远多于写，所以，我们希望的是：-   读访问可以并发执行。-   写的同时不能并发读，也不能并发写。这样就兼顾了性能和安全性。读写锁就是为这一需求设计的。我们来看一下 Java中提供的读写锁：    ReadWriteLock rwlock = new ReentrantReadWriteLock(); public void read() {  rwlock.readLock().lock();  try {    // 在这儿读取共享数据  } finally {    rwlock.readLock().unlock();  }}public void write() {  rwlock.writeLock().lock();  try {    // 在这儿更新共享数据  } finally {    rwlock.writeLock().unlock();  }}在这段代码中，需要读数据的时候，我们获取读锁，获取到的读锁不是一个互斥锁，也就是说read()方法是可以多个线程并行执行的，这样使得读数据的性能依然很好。写数据的时候，我们获取写锁，当一个线程持有写锁的时候，其他线程既无法获取读锁，也不能获取写锁，达到保护共享数据的目的。这样，使用读写锁就兼顾了性能和安全。
## 小结锁可以保护共享资源，避免并发更新造成的数据错误。只有持有锁的线程才能访问被保护资源。线程在访问资源之前必须获取锁，访问完成后一定要记得释放锁。一定不要滥用锁，否则容易导致死锁。死锁的原因，主要由于多个线程中多把锁相互争用导致的。一般来说，如果程序中使用的锁比较多，很难分析死锁的原因，所以需要尽量少的使用锁，并且保持程序的结构尽量简单、清晰。最后，我们介绍了读写锁，在某些场景下，使用读写锁可以兼顾性能和安全性，是非常好的选择。
## 思考题我刚刚讲到，Python 中提供了try-with-lock，不需要显式地获取和释放锁，非常方便。遗憾的是，在 Java中并没有这样的机制，那你能不能自己在 Java 中实现一个 try-with-lock 呢？欢迎你把代码上传到 GitHub上，然后在评论区给出访问链接。如果你有任何问题，也可以在评论区留言与我交流。感谢阅读，如果你觉得这篇文章对你有一些启发，也欢迎把它分享给你的朋友。![](Images/4daea3d1a08e48460d8df87c2a766cef.png){savepage-src="https://static001.geekbang.org/resource/image/de/23/de0a489e6b4fa9a49450bf9197593423.jpg"}