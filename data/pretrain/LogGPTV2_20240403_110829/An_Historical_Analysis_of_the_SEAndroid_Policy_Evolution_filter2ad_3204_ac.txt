There is an interesting data point in Figure 4. In Android 9.0, the
bin 10000 − 99999 has grown from 1 to 5. The four new rules are:
allow domain dev_type:lnk_file r_file_perms;
get_prop(domain, core_property_type)
allow domain fs_type:dir getattr;
allow domain fs_type:filesystem getattr;
These four rules allow the attribute domain, which includes vir-
tually every subject, to read all “link files” (i.e., symbolic links), to
invoke the stat() system call on virtually every file and direc-
tories in the system, and to access all the “core properties” (i.e.,
configuration values similar to the registry in Microsoft Windows).
In addition, even though there are only five rules in this bin, they
impact more than 110, 000 boxes. Therefore, if there is ever a need
to deny the stat() call for a few specific processes, one would
need to carve out additional rules from these generic rules, e.g., by
 1101001,00010,0001=10⁵AverageNumber of rulesRange of number of box per rule4.34.45.06.07.08.09.0633ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
B. Im et al.
Figure 5: Number of rules mapped to a single box.
Figure 6: Ratio between change of rules and boxes.
creating certain negative rules or splitting these generic rules into
smaller, more specific ones.
Lastly, we present the “average” number of boxes per rule across
each Android security policy snapshot. We see a spike in An-
droid 4.4, which is likely caused by the massive “unconfined” do-
main issue. It then drops for 5.0, and becomes relatively stable from
6.0 through 9.0. This suggests that Android team has achieved a
stable engineering discipline, in the sense that while the absolute
number of boxes is growing exponentially, the effort per box to
construct suitable policies is roughly constant across these three
releases.
Takeaway #2: Some small number of rules could touch a large num-
ber of boxes due to the abstraction features. Overall, the number of
boxes touched by a rule increased over time, but this ratio seems
to be stabilizing, despite the continued exponential growth in the
absolute number of rules and boxes.
4.3 Number of rules per box
As before, we define a box to be an atomic access control unit. Our
next concern is that multiple rules might speak about the same
box. Why is it bad to have multiple rules influencing the same box?
Consider the case of a security engineer, auditing the security policy,
who determines that one of the rules is over-broad and thus requires
some effort to fix the problem. If our engineer didn’t realize that
multiple rules allowed the same box, then this engineering effort
might not have its desired impact. Where a high ratio of “boxes
per rule” indicates the use of macros and grouping features, a high
ratio of “rules per box” instead indicates a degree of imprecision in
the design of the rules.
Figure 5 shows the rules per box for seven different commits at
dates selected across the range of Android. Since it is natural that
one box should be derived from the only one rule, we do not collect
these cases. As we see from the graph, there are a large number
of boxes derived from 2 or 3 rules for all the sampled commits.
More importantly, there is a trend that the tail (i.e., boxes with ten
or more rules that specify them) is growing over time. The most
popular box, generated by a remarkable set of 23 rules is:
system_server system_file:dir search;
Some example rules that generate this box include:
allow hal_gnss system_file dir {open... search};
allow hal_power system_file dir {open... search};
allow hal_thermal system_file dir {open... search};
...
HAL, the “hardware abstraction layer,” represents an important
boundary between the core Android distribution and the efforts
that OEMs make to port Android to their specific devices. These 23
HAL-related rules allow the same box, but it’s unclear whether this
was deliberate or accidental. Certainly, if a later analysis determines
that system_server permissions need to be customized, or that
this particular box needs to be denied, then each of these 23 rules
would need to be changed. Many of these rules say nothing at
all about system_server, at least not directly, but they impact it
nonetheless.
How did this happen? This is a consequence of the overlapping
rules in HAL-related macro functions and attributes, where macros
sometimes even expand into other macros. The HAL subsystem
would benefit from some degree of refactoring to simplify its secu-
rity policies, redesigning it to avoid so much overlap.
Takeaway #3: Most boxes only have a small number of rules, but a
few boxes contain more than ten rules, which could be an obstacle
for effective policy maintenance.
4.4 Ratio of rule vs. box changes
To further understand how commits affect the number of rules and
the number of boxes, we plot the ratio ∆B/∆R for each commit,
where ∆B is the number of added boxes, and ∆R is the number of
added rules. If ∆B (or ∆R) is negative, this means that a commit has
reduced the number of boxes or rules, respectively.
Figure 6 shows the results starting from July 2015—we did not
present earlier data due to the use of unconfineddomain. The aver-
age ratio is 120, meaning that the “box” metric is more sensitive to
changes. Moreover, we observed negative ratios, which means that
the number of rules has increased (or decreased) while the number
of boxes has decreased (or increased)—further evidence that their
relation is non-linear.
For the peak indicated by A, the ratio is larger than 35, 000. We
found that this is because Google added a new file type called
vendor_file_type, and added file-related rules to the domain sub-
ject, which includes virtually all processes. Another peak, as indi-
cated by B, has not affected the number of rules much; rather, a
new permission map is added to existing rules. For instance, a rule
allow domain system_file: file {execute read open};
would become the following:
allow domain system_file: file {execute read open map};
 1101001,00010,00023456789101117182223Number of boxesNumber of overlapped rules for a single box01/04/201201/11/201305/02/201312/23/201403/02/201506/28/201607/12/2017 -5,0005,00015,00025,00035,000Jul-15Jan-16Jul-16Jan-17Jul-17Jan-18Box -rule change ratioAB634An Historical Analysis of the SEAndroid Policy Evolution
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
is the age of the type, and the y-axis is the cumulative distribution.
This means that the types on the left side of the CDF are older, and
types on the right side are more recent. The arrows “A” and “E” in-
dicate the “oldest” subjects and objectives, respectively, which were
created at the very beginning of the policy by NSA; they account
for 20% of all the current types. The arrows “C” and “G” indicate the
introduction of the types for the hardware abstraction layer (“HAL”)
subsystem (e.g., hal_audio_ default and hal_drm_default). These
types were introduced in a single commit by Google in October
2016.
At arrow “B”, the types of system properties were separated
into multiple types such as audio_prop and bluetooth_prop. Before
this commit, all the properties were associated with a single type,
system_prop. This was presumably part of a privilege separation
engineering push within Android. Perhaps as part of the same effort,
at arrow “F”, all the system services were separated into multiple
types such as alarm_service and cpuinfo_service. Before this commit,
all the system services were assigned to a single type, system_service.
In this commit, a new attribute temp_system_server_service was
added and all the separated services were associated with the new
attribute; they inherited all the rules for the existing system_service
type. The temp_system_server_service attribute later disappeared,
perhaps unsurprisingly, given it is a “temporary” name.
At arrow “H”, a number of HAL related types were added in a
single commit. In this case, the new types were related to a new HAL
service which is now part of the version 8.0. Regions near arrows
“D” and “I” indicate a radical increase of the types for Android,
which are all part of the version 8.0 or later such as lowPAN (low-
power wireless personal area network) for Android IoT devices and
exported property feature for debugging annotations.
All of the commits at these labeled arrows after the initial NSA
version were authored by Google. This suggests that other ven-
dors are making only minor updates and tweaks, at least as far as
their contributions to Android AOSP are concerned; large-scale
engineering shifts are only happening at Google. We discuss more
about different vendor contributions in Section 5.5.
Takeaway #5: A non-trivial portion of the rules were present since
the beginning, although the majority of the rules have gone through
changes. Major events tend to affect a large number of rules, show-
ing up as jump points in the curve.
5.2 The increasing policy complexity
As shown in Figures 3 and 7, the complexity of the policy is ex-
ponentially increasing over time. Since the complexity is directly
related to its maintainability, we would like to evaluate and estimate
the growth pattern in more detail.
Figure 8 shows the linear scale fitted curves of three important
indicators for policy complexity, which are the number of types,
rules, and boxes. We generated this figure partly by extrapolating
the future complexity increase based on the current change trends.
For instance, extrapolating from the growth, the number of types
and the number of rules might double from today (mid-2018) to
mid-2020.
However, the fitted curve of the number of the boxes is different.
As shown in Figure 8(c), we fit different segments of the graph
with three different curves having different exponents. Not only
(a) Subjects
(b) Objects
Figure 7: Cumulative distribution of the age of types.
Takeaway #4: A change in the number of rules may not always lead
to a corresponding change in the number of boxes.
4.5 Summary
To summarize, the box and rule metrics have an interesting and
non-linear relationship; used in combination, anomalies and large
changes directly point to interesting and relevant engineering
changes in Android’s history, such as the introduction and eventual
elimination of Android’s use of unconfineddomain.
By expanding rules to boxes, we gain an instrument that is very
sensitive to policy changes. Even though the written rule changes
might be small, the box changes can be enormous. This allows us
to focus our attention on both local discontinuities, which point to
specific significant patches made to the SEAndroid policy, as well
as the broader multi-year trends in SEAndroid engineering. With
our work, Google and OEMs could institute security policy metrics
for SEAndroid. Our policy metrics could prove useful alongside
other traditional software engineering metrics (e.g., lines of code,
or bugs filed and fixed) to help Android project managers quantify
the evolving complexity of their system. Any non-trivial changes in
the metrics might imply significant policy differences, or perhaps
even inadvertent policy misconfigurations.
5 AN HISTORICAL ANALYSIS
As we mentioned before, the metrics we’ve devised allow us to
plot long-term patterns of the evolution of the SEAndroid security
policy. With these metrics, and the attendant timestamps, we can
examine a number of other trends over time.
5.1 The “age” of rules
To start, we want a metric that speaks to the degree of turnover
of the rules in SELinux policies. We can derive a given rule’s “age”
by identifying the Git commit when it was most recently changed.
The longer a rule has been unchanged, the older it must be. Rather
than using wall-clock timestamps, we instead use the order of the
commits. This means that, as the rate of commits has increased in
recent years, our age metric will “speed up” to reflect the increased
degree of activity.
Figures 7(a) and 7(b) show the cumulative distribution function
diagrams of the age of each SEAndroid subject and object, respec-
tively, across all commits on the master AOSP branch. The x-axis
 00.10.20.30.40.50.60.70.80.91ABCD 00.10.20.30.40.50.60.70.80.91EFGHI635ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
B. Im et al.
(a) Types
(b) Rules
(c) Boxes
(a) Number of types captured in May 2017
Figure 8: Fitted curves for types, rules, and boxes.
is the number of boxes growing, the exponent of growth is grow-
ing! Super-exponential growth of our security policies cannot be a
desirable attribute.
In Figure 8(c), we sampled important points after the “unconfined
domain” period, which is separated to 3 different curves with dif-
ferent exponents and constants, because there are multiple jumps
in the original curve due to the addition of new types, rules, and
macros in every version release. For example, a big jump happened
in 2017, due to the addition of HAL layer, as shown in Figure 7.
The slopes of the fitted lines of all those three different curves are
radically increasing.
This is a very important indication of the complexity increase—
the exponent seems to be increasing, which suggests that the policy
maintainability is getting more challenging as time goes on. Since
there is virtually no maintenance manual or any public documen-
tation about the policy, the device manufacturers, who need to
customize the policy for their products, would face an enormous
obstacle in terms of maintainability and evaluability for their prod-
uct releases. Even if major contributors such as Google have con-
sistently maintained internal documents, the trend still indicates
that their maintainability is likely to get more difficult over time.
Takeaway #6: The complexity of the SEAndroid policy is increas-
ingly super-exponentially, which complicates maintainability and
analysis.
5.3 The effect of multiple branches
Git is a distributed source-code management system, allowing sep-
arate organizations to maintain separate repositories with separate
histories, merging those histories whenever they want. This has
the curious property that the version of history that we see will
change over time as alternative histories are merged or rebased into
the mainline history. Among other issues, if two different branches
are merged into one, we cannot distinguish which was the mas-
ter and which was the merged branch without prior information;
instead, we only can see that two branches merged. This means
that tracking the “real” history of Android AOSP would require
us to maintain snapshots of the entire Git repository’s state, taken
over time, rather than just examining the newest repository for its
historical commits; this issue has been pointed out before by Bird et