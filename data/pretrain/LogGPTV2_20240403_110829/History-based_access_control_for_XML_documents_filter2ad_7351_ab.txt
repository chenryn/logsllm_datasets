Control Model” . . . . . . . . . . . . . . . . . . . . . . 123
9 Conclusions and Future Work
127
9.1 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
9.2 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
Index
Bibliography
131
134
List of Figures
1.1 Loss in dollar for diﬀerent types of incidents (source [GLLR06])
1.2 Alternative sets when the desired set cannot be speciﬁed . . .
2
5
2.1 Example of an access matrix . . . . . . . . . . . . . . . . . . . 14
2.2 Components of the RBAC model
. . . . . . . . . . . . . . . . 16
2.3 Example of a role hierarchy . . . . . . . . . . . . . . . . . . . 17
2.4 An example of the tree organization of the objects . . . . . . . 19
2.5 Situation after access to objects o6 and o9
. . . . . . . . . . . 20
2.6 XML example document . . . . . . . . . . . . . . . . . . . . . 22
2.7 Example usage of Namespaces . . . . . . . . . . . . . . . . . . 24
2.8 Example of a Schema for a Report . . . . . . . . . . . . . . . 25
2.9
. . . . . . . . . . . . . 29
Integrity reporting protocol [SZJvD04]
3.1 Role hierarchy of the scenario . . . . . . . . . . . . . . . . . . 32
3.2 Data transfers of Situations 1, 2 and 3 . . . . . . . . . . . . . 33
3.3 Sets of objects with diﬀerent permissions . . . . . . . . . . . . 35
Illustration of the is-copy-of relation . . . . . . . . . . . . . . 49
4.1
. . . . . . . . . . . . . . . . . . 50
4.2 Syntax of access control rules
4.3 Rule denying view . . . . . . . . . . . . . . . . . . . . . . . . 55
4.4 Rule denying view . . . . . . . . . . . . . . . . . . . . . . . . 56
4.5 Rule denying deleting of a section . . . . . . . . . . . . . . . . 57
4.6 Additional functions
. . . . . . . . . . . . . . . . . . . . . . . 59
4.7 An example of the objects in the CWM . . . . . . . . . . . . . 59
4.8 Rule enforcing the read policy . . . . . . . . . . . . . . . . . . 60
4.9 Strict rule enforcing the write policy . . . . . . . . . . . . . . 61
4.10 More ﬂexible rule for the write policy . . . . . . . . . . . . . . 61
5.1 System architecture . . . . . . . . . . . . . . . . . . . . . . . . 67
5.2 Protocol steps for performing an operation in Combination 2 . 81
5.3 Protocol steps for performing an operation in Combination 4 . 83
5.4 Distributed System architecture . . . . . . . . . . . . . . . . . 84
xvii
xviii
LIST OF FIGURES
6.1 Security architecture organized in layers
6.2 Attestation protocol
. . . . . . . . . . . . 96
. . . . . . . . . . . . . . . . . . . . . . . 100
. . . . . . . . . . . . . . . . . . 105
7.1 Example of a history element
7.2 Components implemented in the prototype . . . . . . . . . . . 106
7.3 Screenshot of the User Interface . . . . . . . . . . . . . . . . . 107
7.4 Example of the XML representation of the copy database . . . 108
7.5 Example of a policy dcoument . . . . . . . . . . . . . . . . . . 109
7.6 Screenshot of the Server Conﬁgurator . . . . . . . . . . . . . . 111
8.1 Sticky policies [SBO06] . . . . . . . . . . . . . . . . . . . . . . 124
List of Tables
3.1 Diﬀerent protection levels of documents in the scenario . . . . 32
3.2 Document types used in the scenario . . . . . . . . . . . . . . 32
4.1 Versions of the create operation and their parameters
. . . . 45
4.2 Versions of the delete operation and their parameters
. . . . 45
4.3 Versions of the copy operation and their parameters . . . . . . 46
4.4 Parameters of the change-attribute operation . . . . . . . . 47
4.5 Versions of the view operation and their parameters . . . . . . 48
4.6 Getting the copies of an object
. . . . . . . . . . . . . . . . . 54
4.7 Getting related nodes depending on time . . . . . . . . . . . . 56
4.8 Getting the context of a history entry . . . . . . . . . . . . . . 57
4.9 Getting accessed nodes . . . . . . . . . . . . . . . . . . . . . . 58
. . . . . . . . . . . . . . . . . 58
4.10 Getting speciﬁc nodes of a rule
5.1 Components of our system architecture . . . . . . . . . . . . . 79
5.2 Possible sides to implement the components
. . . . . . . . . . 80
5.3 Comparison of the four combinations . . . . . . . . . . . . . . 84
6.1 Attacks on the client and required mechanisms . . . . . . . . . 91
. . . . . . . . 94
6.2 Attacks on the server and required mechanisms
7.1 Arguments for storing operations in histories . . . . . . . . . . 104
7.2 Speciﬁcation of the test system . . . . . . . . . . . . . . . . . 112
7.3 Summary of the performance of diﬀerent groups . . . . . . . . 113
xix
xx
LIST OF TABLES
List of Algorithms
1
2
3
4
5
6
7
8
Create View . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
Evaluate Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
Create Element . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
Create Text Content . . . . . . . . . . . . . . . . . . . . . . . . 71
Split Text Block . . . . . . . . . . . . . . . . . . . . . . . . . . 72
Copy Element
. . . . . . . . . . . . . . . . . . . . . . . . . . . 73
Copy Text Content . . . . . . . . . . . . . . . . . . . . . . . . . 73
Delete Text Content . . . . . . . . . . . . . . . . . . . . . . . . 74
xxi
xxii
LIST OF ALGORITHMS
Chapter 1
Introduction
In this chapter, we will give a motivation for access control in general and
history-based access control in particular.
In addition to this, we give an
outline for this thesis.
1.1 Motivation
In the recent years, there was a development in which paper documents were
more and more replaced by electronic documents. As electronic documents
introduce several advantages, as space saving storage, faster electronic trans-
fer and the possibility to perform an electronic search, they also bring new
risks. One such risk is that electronic documents can be stolen more easily.
For example, a hacker can steal electronic documents remotely without en-
tering the building where the computer on which the documents are stored is
located. According to studies of the FBI/CSI [GLLR05, GLLR06], unautho-
rized access and information theft are responsible for a major part of damages
caused by computer crime. In addition to that, electronic documents can be
more easily destroyed, e.g., one inconsiderate command can deleted an entire
document. Moreover, it is much more diﬃcult to control the propagation of
information contained in electronic documents, since they can be copied very
eﬃciently compared to paper documents. As a consequence, criminals exploit
the new opportunities of electronic documents to steal digital information.
Figure 1.1 shows the amount of loss for several types of computer crime
incidents as reported in [GLLR06]. The second largest amount of loss is
attributed to unauthorized access to information, which clearly shows the
high demand for access control mechanisms, which are mechanisms to restrict
access to authorized persons. In other words, these mechanisms deﬁne who
is allowed or denied to access which object. The fourth largest amount of
1
2
CHAPTER 1.
INTRODUCTION
loss is caused by the theft of proprietary information. This sum of this
type of loss and of unauthorized access exceeds the amount of loss by virus
contamination. Since the sketched types of loss can be reduced with access
control mechanisms, this highlights the importance of access control even
more. Moreover, Figure 1.1 shows that only a relative small amount of loss
is created by outsiders penetrating the system. This indicates that protection
mechanisms should focus on inside attackers, which are authorized users of
the system.
Figure 1.1: Loss in dollar for diﬀerent types of incidents (source [GLLR06])
Access control mechanisms were introduced, to reduce the risks described
above, namely the risk of information theft and the risk of accidental deletion.
Many diﬀerent solutions were developed to provide access control for diﬀerent
types of storing data. Access control systems must be designed diﬀerently for
diﬀerent methods of storing data, because the methods can diﬀer signiﬁcantly
in structure and in semantics. For example, concerning XML documents, it
is not useful to grant access to a node without granting access to the parent
node, because nodes in an XML document have a parent child relation and
they form a semantical unit. Without the parent node, the semantics of the
child node is not clear. In contrast to this, the semantics of ﬁles stored in
directories is much diﬀerent. Here, granting access to a subdirectory without
the parent directory is acceptable. Moreover, tables in a relational database
have diﬀerent semantics than XML documents and ﬁles in a ﬁle system. In
$885.500$90.100$161.210$162.500$260.000$269.500$291.510$469.010$647.510$758.000$923.700$1.262.410$1.849.810$2.556.900$2.922.010$6.034.000$6.642.660$10.617.000$15.691.460OtherExploit of DNS serverPassword sniffingWeb site defacementSabotage of data or networksMisuses of public web applicationInstant messaging misuseAbuse of wireless networkPhishingSystem penetration by outsiderBots within the organizationTelecom fraudInsider abuse of net accessFinancial fraudDenial of serviceTheft of proprietary informationLaptop or mobile hardware theftUnauthorized access to informationVirus contamination1.1. MOTIVATION
3
addition to this, diﬀerent representations of data can require a diﬀerent level
of granularity. For example, for a system that stores ﬁles of diﬀerent formats
and the internal structure of these ﬁles is not known, it is useful to deﬁne
access on the level of ﬁles. In contrast to this, a system that stores ﬁles of
one speciﬁc type and the internal structure of these ﬁles is known, it can be
required to deﬁne access to parts of these ﬁles individually. In this case, it
also depends on the structure of these ﬁles how access must be deﬁned, e.g.,
it makes a big diﬀerence whether these ﬁles contain ﬂat list structures or the
data is organized as a tree. As a consequence, we will have a closer look on
methods of storing data and diﬀerent document formats.
Up to then, many diﬀerent data formats and methods to store data ex-
isted. Most applications had their own data format and the interoperability
between systems with a diﬀerent data format was limited. Moreover, some
systems store their data in databases, whereas others use ﬁles organized in
a speciﬁc directory structure. To exchange data the corresponding formats
must be converted from one format to the other. In some cases, this was es-
pecially diﬃcult, since some formats were highly dependent on the properties
of the processing computer, e.g., the byte order of the processing computer.
Besides these problems, some formats suﬀered from the problem, that they
were diﬃcult to extend. More simply, some formats were designed in a way,
that does not allow to store information that was not speciﬁed in the existing
format. For example, some formats stored the date as two decimal digits,
which caused problems when the date changed from the year 1999 to 2000.
As a result of the previous considerations, the Extensible Markup Lan-
guage (XML) [Con04] was introduced in 1998. The language XML oﬀers
several advantages compared to other representations of data, e.g., binary
representation. First of all, it is both readable for humans and for com-
puters. Moreover, it supports the storing of unicode text and can represent
common data structures like lists and trees.
Although much work on access control in the areas of ﬁle systems or rela-
tional databases has already been done, deﬁning access to XML documents
is a diﬀerent issue as stated in [FM04]. The structure of XML documents
is not always known in advance, e.g., if an XML document has no schema.
Moreover, as stated above, elements in XML documents are much more de-
pendent on their context than ﬁles in a ﬁle system or records in a database
are, e.g., it is not always useful to grant access to an element without granting
access to its descendants.
Since XML is widely used and oﬀers many technical advantages, we focus
on access control for XML documents in this thesis. As a remaining question,
we must evaluate how we want to deﬁne access for XML documents. There
are many diﬀerent approaches for this task, which we will discuss in the
4
following.
CHAPTER 1.
INTRODUCTION
Previous methods for access control deﬁned access for each object individ-
ually and required to manually maintain lists of allowed and denied objects.
For example, newly created objects must be manually added to the access
control list. But this approach has several drawbacks. First, the manual
assignment of access rights to objects is both ineﬃcient and error-prone. Ad-
ditionally, this approach does not allow to implement a central access control
strategy in an automatic and systematic way. Instead, we need an approach
in which objects are described by their properties and access control deﬁni-
tions are derived by rules which make use of these properties. In contrast
to the manual approach, only the set of rules must be maintained and it
must only be updated when the overall access control strategy changes. This
rule-based method of specifying access is required in many business scenarios
due its advantages in security and its lower eﬀort of maintenance.
In these scenarios, company internal rules deﬁne how access should be
granted. For example, a set of documents to which access should be denied
can be deﬁned by a set of rules that speciﬁes the corresponding documents
by using conditions on certain properties of these documents. We refer to
these rules as access control rules. When new documents are created or
existing documents are changed the access control rules are evaluated again
and the resulting set of documents and their corresponding permissions is
updated. To sum up, instead of manually maintaining access control lists,
access control rules can be used to deﬁne access with the help of conditions
about certain properties of the objects automatically.
Models for access control for XML documents diﬀer in their expressive-
ness for deﬁning the conditions used in access control rules. The models
expressiveness for these conditions has direct impact on both usability and
security. In the following, we will discuss the consequences of having an ac-
cess control model that lacks expressiveness and cannot express the required
conditions to express access control rules for a speciﬁc scenario.
If the used model is not able to express a required condition for granting
or denying access in an access control rule, an alternative condition must
be chosen that can be expressed with the model. There are three diﬀerent
types of alternative conditions besides the intended condition. Figure 1.2
illustrates the resulting sets of objects, depending on the chosen alternative
condition.
The ﬁrst alternative is to chose an expressible condition that speciﬁes a
set of objects which is too large and includes the intended set of objects. If
the access to these objects is denied, access to some objects is denied even
though it was not intended to do so. The result is a limitation of usability,
because access is denied in a case where it is not required. If the access to
1.1. MOTIVATION
5
Figure 1.2: Alternative sets when the desired set cannot be speciﬁed
these objects is allowed, access to objects is granted, which is not intended to
be granted, which results in a security problem, since access to some objects
is granted but should be denied.
The second alternative is to chose an expressible condition that both
misses some objects that should be included and selects additional objects
that should not be included in the resulting set. The result of such a condition
is a set which overlaps with the intended set of objects. In any case, such a
speciﬁcation both limits the security and the usability.
Finally, the third alternative is to chose an expressible condition that
speciﬁes a set that is a subset of the intended set of objects. This alternative
is the opposite to the ﬁrst alternative. Depending on whether the access to
these objects is allowed or denied, this speciﬁcation limits either security or
usability.
As a result of the previous discussion, we learn that the expressiveness
of the model for deﬁning access control rules is very important. However,
the expressiveness always depends on the requirements of a speciﬁc scenario,
because diﬀerent scenarios can require very diﬀerent conditions for specify-
ing objects in access control rules. As a consequence, there is not absolute
measurement for expressiveness. We only can say that the expressiveness of
a model for specifying object in access control rules is suﬃcient for a speciﬁc
scenario.
In the previous discussion, we focussed on specifying objects in access
control rules, but the concept of deﬁning objects by rules can also be used for
subjects. In many cases, there are much more objects than there a subjects
in the system. For this reason and to reduce complexity, we focus on how
to specify objects in this thesis. Nevertheless, approaches that focus on the
speciﬁcation of subjects can be combined with our approach as these two
aspects are independent of each other.
The question is what are the properties that should be used in access
All objects of the systemIntended set of objectsA too large set of objectsA too small set of objectsOverlapping set of objects6