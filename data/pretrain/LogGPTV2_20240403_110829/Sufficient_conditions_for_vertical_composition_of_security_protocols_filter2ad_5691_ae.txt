to transform it to a P1 attack: then we can replace every
9This is not a consequence of the fact that t (cid:54)= CP [t(cid:48)] for
any t(cid:48) as t may contain variables.
1
concrete payload m labeled spayload(A, B) simply with the
abstract payload(A, B) and obtain a valid P1 attack.
4.6 Abstract Payloads (Παρθενοπαˆιος)
In the channel protocol P1 with abstract payload(A, B),
we require that the intruder knows initially
{payload(A, B) | dishonest(A) ∨ dishonest(B)}
if the channel-type κ(A, B) includes secrecy (i.e., if it is
A→• B or A•→• B, which we can denote by secrecy ∈
κ(A, B)); otherwise, the intruder initially knows all pay-
loads {payload(A, B)}. With this, we assume that the in-
truder may “in the worst case” know all payloads that are
not explicitly secret (even though he may not ﬁnd out the
actual payload in a concrete run of P2[P1] or P P2
1 ). This is
essential for the soundness of the payload abstraction in the
sense that when a concrete payload is known (and this fact
is not yet a violation of a secrecy goal), then the intruder
knows also the corresponding abstract payload.
1
This condition is thus used in the last step of the proof
when we transform a P P2
attack into a P1 attack and thus
replace concrete payloads with abstract payloads: if the at-
tack includes that the intruder can produce a concrete pay-
load m labeled spayload(A, B), then either we already had
earlier a secrecy violation (thus there exists a shorter at-
tack) or it is one of the public payloads, and the intruder
thus knows payload(A, B).
4.7 Properties of Concrete Payloads (Αφιάραος)
For the concrete payloads, we similarly require that all
payloads that are not explicitly secret are included in the
initial intruder knowledge of P P2
and P2, i.e., initially the
intruder knowledge M0 contains at least:
(cid:83)
honest(A) ∧ (dishonest(B) ∨ secrecy (cid:54)∈ κ(A, B)) MA,B.
1
Moreover, all the other—secret—payloads (when A and B
are honest and κ(A, B) entails secrecy) must be considered
as secrets in P1 and P2 (and thus they are also secrets in
P P2
1 ). This can be expressed in ASLan for instance by
adding the fact secret(M,{A, B}) in every transition where
an honest agent sends a payload M labeled spayload(A, B)
or receives a payload M labeled rpayload(A, B) and using
the general attack rule (1).10
This condition is, of course, similar to the previous one on
abstract payloads. We use it in the proof in two ways: as al-
ready explained before, whenever in the attack the intruder
uses a payload that is supposed to be secret, we already
have a simpler attack to reduce to. Conversely, whenever
10Pedantically, to fulﬁll the condition of protocol indepen-
dence, we should use two distinct facts secretP1 and secretP2
for secrecy in the respective subprotocols.
444the intruder uses a payload that is not supposed to be se-
cret, then this is already part of the initial knowledge. This
is the closing stone in the proof, because the payloads are
the only non-atomic submessages shared between the two
protocols P P2
and P2, and having these always in the ini-
tial knowledge (when not secret) allows us thus to solve P P2
constraints using only P P2
1 messages and P2 constraints only
using P2 messages.
1
1
Discussion.
We like to point out that most of the conditions imposed
here actually are, in a sense, in line with the prudent engi-
neering principles of security protocols of Abadi and Need-
ham [1].
• Execution independence in (Τυδεύς): we have a gen-
eral notion of security protocols that may have databa-
ses; for simplicity, we do not deal with the interac-
tions that can arise from diﬀerent protocols sharing
a database.
In fact, one may argue that it is pru-
dent engineering that channel and application proto-
cols should indeed not have a shared database, but
rather separate data-spaces except long-term keys.
• (Ιπποέδων): it should be consistent over all protocols
which items are secrets and which are not. (The other
aspects of this condition are modeling aspects.)
• (Καπανεύς) corresponds to the central prudent engi-
neering principle that every message should clearly in-
dicate what it means, hence, it should not be a mere
collection of data but rather have enough identiﬁers so
that the meaning of each piece of data is unique.
• (Πολυνείκης) similarly requires that the payloads are
unique for honest sender/receiver pairs (even though
the names do not need to be recognizable). This con-
dition is indeed a restriction that does not necessarily
follow from prudent engineering and that many proto-
cols in practice may not adhere to; we will thus try to
lift in future work.
• (Ετέοκλος) is again in line with the paradigm that
every message should say what it means, and in this
case the integration of two protocols that results from
inserting a message in a transport protocol should have
a clear distinction between “letter and envelope”, so to
speak.
• (Παρθενοπαˆιος) is actually not directly a requirement
on the design of the channel protocol, but that it should
satisfy its goals even under the assumption that all
payloads are known whenever they are not explicitly
secret from the intruder (even though the intruder in
practice may sometimes not know all non-secret pay-
loads).
In fact, we believe that this is again in the
spirit of prudent engineering.
• (Αφιάραος) is the analogon of the previous property
for the channel protocol.
satisﬁed by many protocols and that are easy syntactical
checks. Now, we want, however, to discuss what are the
limitations of the composability result so far and how we
can extend it to the case of more messages for what con-
cerns both the static aspect and the logical aspect of vertical
protocol composition.
The composability result of [27] refers to only one sin-
gle payload message of the application protocol being trans-
mitted over the channel provided by the channel protocol.
There are two reasons why this is a limitation. First, if the
channel protocol is complex (and consisting of many steps),
it is not desirable to execute this entire protocol for every
message transmission of an application protocol. Second,
disjointness conditions would not even allow repeated appli-
cations of the composability result, i.e., P2[P1[P1]] when we
have two messages in P2 that should be transmitted over a
channel provided by P1.
Our conjecture is that there is no insurmountable obsta-
cle to allowing the deﬁnition of a channel protocol for more
than one message transmission. One obvious way to go is to
generalize the channel protocol to the transmission of several
payload messages payload1(A1, B1), . . . , payloadk(Ak, Bk) for
a ﬁxed number k of transmissions (the endpoints of the
channels may diﬀer); these transmissions would be over k
diﬀerent channel types κi(Ai, Bi); they would be reﬂected
P [·], and the application protocol
by k disjoint contexts C i
can then transmit k messages with associated concrete pay-
A,B (for 1 ≤ i ≤ k). These payload
load message sets Mi
message sets would have to be disjoint unless κi(Ai, Bi) =
κj(Aj, Bj). The respective extensions of the deﬁnitions and
proofs are notationally involved, but conceptually simple, so
we avoided them here.
More generally, we also like to allow the transmission of an
unbounded number of messages over a channel. The most
prominent examples for this are, of course, secure channel
protocols like TLS that establish a pair of symmetric keys
(one for client-to-server transmissions, and one for server-to-
client; see also [14]). We discuss an example based on TLS
in more detail in [28]; this includes a suitable notation for
the transmission protocol(s), i.e., how payload messages are
handled. Note that we are here focussing only on the chan-
nel’s transmission properties for the single messages such as
authentication and secrecy, not for their relationship such
as their ordering, completeness or replay protection.
Again, there is no fundamental problem in extending our
static vertical composition result for arbitrary message trans-
missions as long as, again, the message spaces Mi
Ai,Bi for
the diﬀerent used channel types are disjoint. In particular,
observe that we require honest receivers in the channel pro-
tocol to accept any payload that is embedded into the proper
context; thus, the abstraction of the payload in the pure Pi
works, independent of whether there is just one concrete
payload message per session or many of them.
We also conjecture that the principles of vertical protocol
composition of [27] can also be extended to arbitrary payload
transmissions. However, we leave it for future work.
5. EXTENSION TO MORE MESSAGES
6. CONCLUSIONS
As we remarked above, our seven conditions appear com-
plex because they are formulated at a deep technical level,
but they actually reﬂect realistic static properties that are
We have formalized seven static conditions that are suf-
ﬁcient for vertical protocol composition for a large class of
channels and applications. Our results tell us that we can
445check in isolation — with any protocol veriﬁcation method11
— a channel protocol P1 with abstract payload, as well as
an application protocol P2 that uses the respective channel
type. If this channel type is part of the ones deﬁned in [27]
and the suﬃcient conditions of this paper are satisﬁed for
P1 and P2, then we can combine Theorems 1 and 2 to infer
that P2[P1] is secure.
As we have already partly mentioned above, there are a
number of interesting directions for future work, in particu-
lar, allowing for negative checks also on the channel proto-
col when considering ﬁner abstractions and formalizing the
extension of our suﬃcient conditions to the case of more
messages for what concerns both the static aspect and the
logical aspect of vertical protocol composition.
7. ACKNOWLEDGMENTS
The work presented in this paper was partially supported
by the EU FP7 Projects no. 318424, “FutureID: Shaping the
Future of Electronic Identity” (futureid.eu) and no. 257876,
“SPaCIoS: Secure Provision and Consumption in the Inter-
net of Services” (spacios.eu), and by the PRIN 2010-2011
Project “Security Horizons”. Much of this work was carried
out while Luca Vigan`o was at the Dipartimento di Informat-
ica, Universit`a di Verona, Italy.
8. REFERENCES
[1] M. Abadi and R. M. Needham. Prudent engineering
practice for cryptographic protocols. IEEE Trans.
Software Eng., 22(1):6–15, 1996.
[2] S. Andova, C. Cremers, K. Gjøsteen, S. Mauw,
S. Mjølsnes, and S. Radomirovi´c. A framework for
compositional veriﬁcation of security protocols.
Information and Computation, 206:425–459, 2008.
[3] A. Armando, W. Arsac, T. Avanesov, M. Barletta,
A. Calvi, A. Cappai, R. Carbone, Y. Chevalier,
L. Compagna, J. Cu´ellar, G. Erzse, S. Frau, M. Minea,
S. M¨odersheim, D. von Oheimb, G. Pellegrino, S. E.
Ponta, M. Rocchetto, M. Rusinowitch,
M. Torabi Dashti, M. Turuani, and L. Vigan`o. The
AVANTSSAR Platform for the Automated Validation
of Trust and Security of Service-Oriented
Architectures. In TACAS, LNCS 7214, pp. 267–282.
Springer, 2012.
[4] A. Armando, R. Carbone, and L. Compagna. LTL
Model Checking for Security Protocols. In CSF 20,
pp. 385–396. IEEE CS, 2007.
[5] The AVANTSSAR Project: Deliverable 2.3: ASLan
(ﬁnal version), 2010. Available at www.avantssar.eu.
[6] D. Basin, S. M¨odersheim, and L. Vigan`o. OFMC: A
symbolic model checker for security protocols.
International Journal of Information Security,
4(3):181–208, 2005.
[7] B. Blanchet. From secrecy to authenticity in security
protocols. In SAS’02, LNCS 2477, pp. 342–359.
Springer, 2002.
[8] R. Canetti. Universally composable security: A new
paradigm for cryptographic protocols. In FOCS’01,
pp. 136–145. IEEE CS, 2001.
11Such as ProVerif [7] or the AVANTSSAR Platform [3],
where for bounded-session tools compositionality only holds
for those bounded sessions.
[9] Y. Chevalier, R. K¨usters, M. Rusinowitch, and
M. Turuani. Deciding the security of protocols with
Diﬃe-Hellman exponentiation and products in
exponents. In FST TCS, LNCS 2914. Springer, 2003.
[10] S. Ciobˆaca and V. Cortier. Protocol composition for
arbitrary primitives. In CSF 23. IEEE CS, 2010.
[11] V. Cortier and S. Delaune. Safely composing security
protocols. Form Method Syst Des, 34(1):1–36, 2009.
[12] A. Datta, A. Derek, J. C. Mitchell, and D. Pavlovic.
Secure protocol composition. In FMSE’03, pp. 11–23.
ACM, 2003.
[13] S. Delaune, S. Kremer, and M. D. Ryan. Composition
of password-based protocols. In CSF 21, pp. 239–251.
IEEE CS, 2008.
[14] T. Gibson-Robinson and G. Lowe. Analysing
applications layered on unilaterally authenticating
protocols. In FAST, LNCS 7140, pp. 164–181.
Springer, 2011.
[15] T. Groß and S. M¨odersheim. Vertical protocol
composition. In CSF 24, pp. 235–250. IEEE CS, 2011.
[16] J. D. Guttman. Authentication tests and disjoint
encryption: a design method for security protocols.
Journal of Computer Security, 3–4(12):409–433, 2004.
[17] J. D. Guttman. Cryptographic protocol composition
via the authentication tests. In FOSSACS, LNCS
5504, pp. 303–317. Springer, 2009.
[18] J. D. Guttman and F. J. Thayer. Protocol
independence through disjoint encryption. In CSFW
2000, pp. 24–34, 2000.
[19] G. O. Hutchinson. Aeschylus. Seven against Thebes.
Clarendon Press, Oxford, 1985.
[20] A. Kamil and G. Lowe. Understanding abstractions of
secure channels. In FAST, LNCS 6561, pp. 50–64,
Springer, 2011.
[21] R. K¨usters and M. Tuengerthal. Composition
Theorems Without Pre-Established Session Identiﬁers.
In CCS 18, pp. 41–50. ACM, 2011.
[22] U. M. Maurer. Constructive cryptography – A new
paradigm for security deﬁnitions and proofs. In
TOSCA 2011, LNCS 6993, pp. 33–56. Springer, 2011.
[23] U. M. Maurer and R. Renner. Abstract Cryptography.
In ICS, pp. 1–21. Tsinghua U.P., 2011.
[24] U. M. Maurer and P. E. Schmid. A calculus for
security bootstrapping in distributed systems.
J. Comp. Sec., 4(1):55–80, 1996.
[25] J. K. Millen and V. Shmatikov. Constraint solving for
bounded-process cryptographic protocol analysis. In
CCS, pp. 166–175. ACM, 2001.
[26] S. M¨odersheim. Algebraic Properties in Alice and Bob
Notation. In Ares’09, 2009.
[27] S. M¨odersheim and L. Vigan`o. Secure pseudonymous
channels. In ESORICS 14, LNCS 5789, pp. 337–354.
Springer, 2009.
[28] S. M¨odersheim and L. Vigan`o. Suﬃcient Conditions
for Vertical Protocol Composition (Extended Version).
TR-2014-07, DTU Compute, Denmark, 2014.
Available at imm.dtu.dk/~samo.
[29] M. Rusinowitch and M. Turuani. Protocol insecurity
with a ﬁnite number of sessions, composed keys is
NP-complete. Theor. Comput. Sci., 299:451–475, 2003.
446