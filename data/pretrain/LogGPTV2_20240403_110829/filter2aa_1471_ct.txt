Diagnostic Policy Engine, Base Filtering 
Engine, Performance Logging and Alerts, 
Windows Firewall, WWAN AutoConfig
Services that run in 
the local service 
account but make 
no use of the 
network at all. 
Services run with a 
write-restricted 
token.
Lo
cal
Sy
DWM, WDI System Host, Network 
Connections, Distributed Link Tracking, 
Windows Audio Endpoint, Wired/WLAN 
Services that run in 
the local system 
account and make 
ste
m
Ne
tw
ork
Re
stri
cte
d
AutoConfig, Pnp-X, HID Access, User-
Mode Driver Framework Service, 
Superfetch, Portable Device Enumerator, 
HomeGroup Listener, Tablet Input, 
Program Compatibility, Offline Files
use of the network 
on a fixed set of 
ports.
Ne
tw
ork
Ser
vic
e
Cryptographic Services, DHCP Client, 
Terminal Services, WorkStation, Network 
Access Protection, NLA, DNS Client, 
Telephony, Windows Event Collector, 
WinRM
Services that run in 
the network service 
account and make 
use of the network 
on various ports (or 
have no enforced 
network 
restrictions).
Ne
tw
ork
Ser
vic
eA
nd
No
Im
per
so
nat
ion
KTM for DTC
Services that run in 
the network service 
account and make 
use of the network 
on a fixed set of 
ports. Services run 
with a write-
restricted token.
Ne
tw
ork
IPSec Policy Agent
Services that run in 
the network service 
account and make 
Ser
vic
eN
et
wo
rk
Re
stri
cte
d
use of the network 
on a fixed set of 
ports.
Svchost service splitting
As discussed in the previous section, running a service in a shared host
process saves system resources but has the big drawback that a single
unhandled error in a service obliges all the other services shared in the host
process to be killed. To overcome this problem, Windows 10 Creators Update
(RS2) has introduced the Svchost Service splitting feature.
When the SCM starts, it reads three values from the registry representing
the services global commit limits (divided in: low, medium, and hard caps).
These values are used by the SCM to send “low resources” messages in case
the system runs under low-memory conditions. It then reads the Svchost
Service split threshold value from the
HKLM\SYSTEM\CurrentControlSet\Control\SvcHostSplitThresholdInKB
registry value. The value contains the minimum amount of system physical
memory (expressed in KB) needed to enable Svchost Service splitting (the
default value is 3.5 GB on client systems and around 3.7 GB on server
systems). The SCM then obtains the value of the total system physical
memory using the GlobalMemoryStatusEx API and compares it with the
threshold previously read from the registry. If the total physical memory is
above the threshold, it enables Svchost service splitting (by setting an
internal global variable).
Svchost service splitting, when active, modifies the behavior in which
SCM starts the host Svchost process of shared services. As already discussed
in the “Service start” section earlier in this chapter, the SCM does not search
for an existing image record in its database if service splitting is allowed for a
service. This means that, even though a service is marked as sharable, it is
started using its private hosting process (and its type is changed to
SERVICE_WIN32_OWN_PROCESS). Service splitting is allowed only if the
following conditions apply:
■    Svchost Service splitting is globally enabled.
■    The service is not marked as critical. A service is marked as critical if
its next recovery action specifies to reboot the machine (as discussed
previously in the “Service failures” section).
■    The service host process name is Svchost.exe.
■    Service splitting is not explicitly disabled for the service through the
SvcHostSplitDisable registry value in the service control key.
Memory manager’s technologies like Memory Compression and
Combining help in saving as much of the system working set as possible.
This explains one of the motivations behind the enablement of Svchost
service splitting. Even though many new processes are created in the system,
the memory manager assures that all the physical pages of the hosting
processes remain shared and consume as little system resources as possible.
Memory combining, compression, and memory sharing are explained in
detail in Chapter 5 of Part 1.
EXPERIMENT: Playing with Svchost service splitting
In case you are using a Windows 10 workstation equipped with 4
GB or more of memory, when you open the Task Manager, you
may notice that a lot of Svchost.exe process instances are currently
executing. As explained in this section, this doesn’t produce a
memory waste problem, but you could be interested in disabling
Svchost splitting. First, open Task Manager and count how many
svchost process instances are currently running in the system. On a
Windows 10 May 2019 Update (19H1) system, you should have
around 80 Svchost process instances. You can easily count them by
opening an administrative PowerShell window and typing the
following command:
Click here to view code image
(get-process -Name "svchost" | measure).Count
On the sample system, the preceding command returned 85.
Open the Registry Editor (by typing regedit.exe in the Cortana
search box) and navigate to the
HKLM\SYSTEM\CurrentControlSet\Control key. Note the current
value of the SvcHostSplitThresholdInKB DWORD value. To
globally disable Svchost service splitting, you should modify the
registry value by setting its data to 0. (You change it by double-
clicking the registry value and entering 0.) After modifying the
registry value, restart the system and repeat the previous step:
counting the number of Svchost process instances. The system now
runs with much fewer of them:
Click here to view code image
PS C:\> (get-process -Name "svchost" | measure).Count
26
To return to the previous behavior, you should restore the
previous content of the SvcHostSplitThresholdInKB registry value.
By modifying the DWORD value, you can also fine-tune the
amount of physical memory needed by Svchost splitting for
correctly being enabled.
Service tags
One of the disadvantages of using service-hosting processes is that
accounting for CPU time and usage, as well as for the usage of resources by a
specific service is much harder because each service is sharing the memory
address space, handle table, and per-process CPU accounting numbers with
the other services that are part of the same service group. Although there is
always a thread inside the service-hosting process that belongs to a certain
service, this association might not always be easy to make. For example, the
service might be using worker threads to perform its operation, or perhaps the
start address and stack of the thread do not reveal the service’s DLL name,
making it hard to figure out what kind of work a thread might be doing and to
which service it might belong.
Windows implements a service attribute called the service tag (not to be
confused with the driver tag), which the SCM generates by calling
ScGenerateServiceTag when a service is created or when the service
database is generated during system boot. The attribute is simply an index
identifying the service. The service tag is stored in the SubProcessTag field
of the thread environment block (TEB) of each thread (see Chapter 3 of Part
1 for more information on the TEB) and is propagated across all threads that
a main service thread creates (except threads created indirectly by thread-
pool APIs).
Although the service tag is kept internal to the SCM, several Windows
utilities, like Netstat.exe (a utility you can use for displaying which programs
have opened which ports on the network), use undocumented APIs to query
service tags and map them to service names. Another tool you can use to
look at service tags is ScTagQuery from Winsider Seminars & Solutions Inc.
(www.winsiderss.com/tools/sctagquery/sctagquery.htm). It can query the
SCM for the mappings of every service tag and display them either
systemwide or per-process. It can also show you to which services all the
threads inside a service-hosting process belong. (This is conditional on those
threads having a proper service tag associated with them.) This way, if you
have a runaway service consuming lots of CPU time, you can identify the
culprit service in case the thread start address or stack does not have an
obvious service DLL associated with it.
User services
As discussed in the “Running services in alternate accounts” section, a
service can be launched using the account of a local system user. A service
configured in that way is always loaded using the specified user account,
regardless of whether the user is currently logged on. This could represent a
limitation in multiuser environments, where a service should be executed
with the access token of the currently logged-on user. Furthermore, it can
expose the user account at risk because malicious users can potentially inject
into the service process and use its token to access resources they are not
supposed to (being able also to authenticate on the network).
Available from Windows 10 Creators Update (RS2), User Services allow a
service to run with the token of the currently logged-on user. User services
can be run in their own process or can share a process with one or more other
services running in the same logged-on user account as for standard services.
They are started when a user performs an interactive logon and stopped when
the user logs off. The SCM internally supports two additional type flags
—SERVICE_USER_SERVICE (64) and
SERVICE_USERSERVICE_INSTANCE (128)—which identify a user service
template and a user service instance.
One of the states of the Winlogon finite-state machine (see Chapter 12 for
details on Winlogon and the boot process) is executed when an interactive
logon has been initiated. The state creates the new user’s logon session,
window station, desktop, and environment; maps the
HKEY_CURRENT_USER registry hive; and notifies the logon subscribers
(LogonUI and User Manager). The User Manager service (Usermgr.dll)
through RPC is able to call into the SCM for delivering the
WTS_SESSION_LOGON session event.
The SCM processes the message through the
ScCreateUserServicesForUser function, which calls back into the User
Manager for obtaining the currently logged-on user’s token. It then queries
the list of user template services from the SCM database and, for each of
them, generates the new name of the user instance service.
EXPERIMENT: Witnessing user services
A kernel debugger can easily show the security attributes of a
process’s token. In this experiment, you need a Windows 10
machine with a kernel debugger enabled and attached to a host (a
local debugger works, too). In this experiment, you choose a user
service instance and analyze its hosting process’s token. Open the
Services tool by typing its name in the Cortana search box. The
application shows standard services and also user services instances
(even though it erroneously displays Local System as the user
account), which can be easily identified because they have a local
unique ID (LUID, generated by the User Manager) attached to their
displayed names. In the example, the Connected Device User
Service is displayed by the Services application as Connected
Device User Service_55d01:
If you double-click the identified service, the tool shows the
actual name of the user service instance (CDPUserSvc_55d01 in
the example). If the service is hosted in a shared process, like the
one chosen in the example, you should use the Registry Editor to
navigate in the service root key of the user service template, which
has the same name as the instance but without the LUID (the user
service template name is CDPUserSvc in the example). As
explained in the “Viewing privileges required by services”
experiment, under the Parameters subkey, the Service DLL name is
stored. The DLL name should be used in Process Explorer for
finding the correct hosting process ID (or you can simply use Task
Manager in the latest Windows 10 versions).
After you have found the PID of the hosting process, you should
break into the kernel debugger and type the following commands
(by replacing the  with the PID of the service’s
hosting process):
!process  1
The debugger displays several pieces of information, including
the address of the associated security token object:
Click here to view code image
Kd: 0> !process 0n5936 1
Searching for Process with Cid == 1730
PROCESS ffffe10646205080
    SessionId: 2  Cid: 1730    Peb: 81ebbd1000  ParentCid: 
0344
    DirBase: 8fe39002  ObjectTable: ffffa387c2826340  
HandleCount: 313.
    Image: svchost.exe
    VadRoot ffffe1064629c340 Vads 108 Clone 0 Private 962. 
Modified 214. Locked 0.
    DeviceMap ffffa387be1341a0
    Token                             ffffa387c2bdc060
    ElapsedTime                       00:35:29.441
    ...
To show the security attributes of the token, you just need to use
the !token command followed by the address of the token object
(which internally is represented with a _TOKEN data structure)
returned by the previous command. You should easily confirm that
the process is hosting a user service by seeing the
WIN://ScmUserService security attribute, as shown in the
following output:
Click here to view code image
0: kd> !token ffffa387c2bdc060
_TOKEN 0xffffa387c2bdc060
TS Session ID: 0x2
User: S-1-5-21-725390342-1520761410-3673083892-1001
User Groups:
 00 S-1-5-21-725390342-1520761410-3673083892-513
    Attributes - Mandatory Default Enabled
...  ...
OriginatingLogonSession: 3e7
PackageSid: (null)
CapabilityCount: 0      Capabilities: 0x0000000000000000
LowboxNumberEntry: 0x0000000000000000
Security Attributes:
 00 Claim Name   : WIN://SCMUserService
    Claim Flags: 0x40 - UNKNOWN
    Value Type   : CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64
    Value Count: 1
    Value[0]   : 0
 01 Claim Name   : TSA://ProcUnique
    Claim Flags: 0x41 - UNKNOWN
    Value Type   : CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64
    Value Count: 2
    Value[0]   : 102
    Value[1]   : 352550
Process Hacker, a system tool similar to Process Explorer and
available at https://processhacker.sourceforge.io/ is able to extract
the same information.
As discussed previously, the name of a user service instance is
generated by combining the original name of the service and a
local unique ID (LUID) generated by the User Manager for
identifying the user’s interactive session (internally called context
ID). The context ID for the interactive logon session is stored in the
volatile HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Winlogon\VolatileUserMgrKey\ \\contextLuid registry value, where 
and  identify the logon session ID and the user SID. If
you open the Registry Editor and navigate to this key, you will find
the same context ID value as the one used for generating the user
service instance name.
Figure 10-22 shows an example of a user service instance, the Clipboard
User Service, which is run using the token of the currently logged-on user.
The generated context ID for session 1 is 0x3a182, as shown by the User
Manager volatile registry key (see the previous experiment for details). The
SCM then calls ScCreateService, which creates a service record in the SCM
database. The new service record represents a new user service instance and
is saved in the registry as for normal services. The service security descriptor,
all the dependent services, and the triggers information are copied from the
user service template to the new user instance service.
Figure 10-22 The Clipboard User Service instance running in the context
ID 0x3a182.
The SCM registers the eventual service triggers (see the “Triggered-start
services” section earlier in this chapter for details) and then starts the service
(if its start type is set to SERVICE_AUTO_START). As discussed in the
“Service logon” section, when SCM starts a process hosting a user service, it
assigns the token of the current logged-on user and the
WIN://ScmUserService security attribute used by the SCM to recognize that
the process is really hosting a service. Figure 10-23 shows that, after a user
has logged in to the system, both the instance and template subkeys are
stored in the root services key representing the same user service. The
instance subkey is deleted on user logoff and ignored if it’s still present at
system startup time.
Figure 10-23 User service instance and template registry keys.
Packaged services
As briefly introduced in the “Service logon” section, since Windows 10
Anniversary Update (RS1), the Service Control Manager has supported