We call this data a ballot deﬁnition. In the Diebold system, a
Proceedings of the 2004 IEEE Symposium on Security and Privacy (S&P’04)  
1081-6011/04 $ 20.00 © 2004 IEEE 
Voter
Poll Worker
Poll Worker
(with access to
network trafﬁc)
•
Internet Provider
(with access to
network trafﬁc)
OS
Developer
Voting
Device
Developer
Section
Vote multiple times
using forged smartcard
Access administrative functions
or close polling station
Modify system conﬁguration
Modify ballot deﬁnition
(e.g., party afﬁliation)
Cause votes to be miscounted
by tampering with conﬁguration
Impersonate legitimate voting
machine to tallying authority
Create, delete, and modify votes
Link voters with their votes
Tamper with audit logs
Delay the start of an election
Insert backdoors into code
(with forged
smartcard)
•
•
(with access to
storage media)
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
III-B
III-C
IV-A
IV-B
IV-B
IV-C
IV-C, IV-E
IV-E
IV-F
IV-G
V-C
THIS TABLE SUMMARIZES SOME OF THE MORE IMPORTANT ATTACKS ON THE SYSTEM.
TABLE I
to ensure, for example, that there are no more votes collected
than people who are registered at or have entered any given
polling location.
DETAILED OVERVIEW OF THE CODE. The 4.3.1 snapshot of
the AccuVote-TS tree [9] has 136 .h ﬁles totaling 16414 lines
and 120 .cpp ﬁles totaling 33195 lines, for a total of 256 ﬁles
and 49609 lines of C++ code. While a full description of every
module in the Diebold AccuVote-TS 4.3.1 system is beyond
the scope of this paper, we describe the bootstrapping process
as well as the main state transitions that occur within a Diebold
system during an election, making explicit references to the
relevant portions of the code.
The voting terminal
is implemented in the directory
BallotStation/, but uses
in the support-
ing directories Ballot/, DES/, DiagMode/, Shared/,
TSElection/, Utilities/, and VoterCard/.
libraries
from the
registry (the
The method CBallotStationApp::DoRun() is the
main loop for the voting terminal software. The DoRun()
method begins by invoking CBallotStationApp::
LoadRegistry(), which loads information about
the
voting terminal
registry keys
are stored under HKEY_LOCAL_MACHINE\Software\
Global Election Systems\AccuVote-TS4) . If the
program fails to load the registry information, it believes that
it is uninitialized and therefore creates a new instance of the
CTSRegistryDlg class that asks the administrator to set
up the machine for the ﬁrst time. The administrator chooses,
among other things, the COM port to use with the smartcard
reader, the directory locations to store ﬁles, and the polling
location identiﬁer. The CBallotStationApp::DoRun()
method then checks for the presence of a smartcard reader
and, if none is found, gives the administrator the option to
interact with the CTSRegistryDlg again.
The DoRun() method then enters a while loop that
thing
the software is shut down. The ﬁrst
iterates until
Proceedings of the 2004 IEEE Symposium on Security and Privacy (S&P’04)  
1081-6011/04 $ 20.00 © 2004 IEEE 
DoRun() does in this loop is check for the presence of
some removable media on which to store election results
and ballot conﬁgurations (a ﬂoppy under Windows or a
removable storage card on a Windows CE device). It then
tries to open the election conﬁguration ﬁle election.
edb. If it fails to open the conﬁguration ﬁle,
the pro-
gram enters the CTSElectionDoc::ES_NOELECTION
state and invokes CBallotStationApp::Download(),
which creates an instance of CTransferElecDlg to down-
load the conﬁguration ﬁle. To do the download, the termi-
nal connects to a back-end server using either the Internet
or a dial-up connection. Subsequently, the program enters
the CTSElectionDoc::ES_PREELECT state, invoking the
CBallotStationApp::PreElect() method, which in
turn creates an instance of CPreElectDlg. The administra-
tor can then decide to start the election, in which case the
method CPreElectDlg::OnSetForElection() sets
the state of
to CTSElectionDoc::ES_
ELECTION.
the terminal
is
in
the
now that
Returning to the while loop in CBallotStationApp::
the
state
DoRun(),
the machine
CTSElectionDoc::ES_ELECTION,
DoRun()
method invokes CBallotStationApp::Election(),
which creates an instance of CVoteDlg. When a card is
inserted into the reader, the application checks to see if the
card is a voter card, administrator card, or ender card. If
it is an ender card, or if it is an administrator card and if
the user enters the correct PIN, the CVoteDlg ends and
the user is asked whether he or she wishes to terminate
the election and, if so, the state of the terminal is set to
CTSElectionDoc::ES_POSTELECT. If the user entered
a voter card, then DoVote() is invoked (here DoVote()
is an actual function; it does not belong to any class). The
DoVote() function ﬁnds the appropriate ballot for the
user’s voter group or, if none exists, opens the nonpartisan
ballot (recall that the system is designed to support different
ballots for different voters, as might occur in a primary party
election). It
then creates an instance of CBallotDlg to
display the ballot and collect the votes.
We recall
that if, during the election process, someone
inserted an administrator or ender card into the terminal
and chooses to end the election,
the system would enter
the CTSElectionDoc::ES_POSTELECT state. At
this
point the voting terminal would offer the ability to upload
the election results to some back-end server for ﬁnal tab-
ulation. The actual
transfer of results is handled by the
CTransferResultsDlg::OnTransfer() method.
III. SMARTCARDS
While it is true that one can design secure systems around
the use of smartcards, merely the use of smartcards in a system
does not imply that the system is secure. The system must
use the smartcards in an intelligent and security-conscious
way. Unfortunately, the Diebold system’s use of smartcards
provides very little (if any) additional security and, in fact,
opens the system to several attacks.
A. Exploiting the lack of cryptography: Creating homebrew
smartcards
Upon reviewing the Diebold code, we observed that the
smartcards do not perform any cryptographic operations. This,
in and of itself, is an immediate red ﬂag. One of the biggest
advantages of smartcards over classic magnetic-stripe cards
is the smartcards’ ability to perform cryptographic operations
internally, and with physically protected keys. Because of a
lack of cryptography, there is no secure authentication of the
smartcard to the voting terminal. This means that nothing
prevents an attacker from using his or her own homebrew
smartcard in a voting terminal. One might naturally wonder
how easy it would be for an attacker to make such a homebrew
smartcard. First, we note that user-programmable smartcards
and smartcard readers are available commercially over the
Internet in small quantities and at reasonable prices. Second,
an attacker who knows the protocol spoken between voting
terminals and legitimate smartcards could easily implement a
homebrew card that speaks the same protocol. We shall shortly
consider how an attacker might go about learning the protocol
if he or she does not know it a priori.
Once the adversary knows the protocol between the terminal
and the smartcards, the only impediment to the mass pro-
duction of homebrew smartcards is that each voting terminal
will make sure that the smartcard has encoded in it the cor-
rect m_ElectionKey, m_VCenter, and m_DLVersion
(see DoVote() in BallotStation/Vote.cpp). The m_
ElectionKey and m_DLVersion are likely the same for
all locations and, furthermore, for backward-compatibility pur-
poses it is possible to use a card with m_ElectionKey and
m_DLVersion undeﬁned. The m_VCenter value could be
learned on a per-location-basis by interacting with legitimate
smartcards, from an insider, or from inferences based on
the m_VCenter values observed at other polling locations.
In short, all the necessary information to create homebrew
counterfeit smartcards is readily available.
In the next subsections we consider attacks that an adversary
could mount after creating homebrew cards. We ﬁnd the issues
we uncovered to be particularly distressing as modern smart-
card designs allow cryptographic operations to be performed
directly on the smartcard, making it possible to create systems
that are not as easily vulnerable to such security breaches.
REVERSE ENGINEERING THE SMARTCARD PROTOCOL. It
turns out that adversaries, including regular voters, who do
not know a priori the protocol between the smartcard and
the terminal can “easily” learn the protocol, thereby allowing
them to produce homebrew voter cards. An adversary, such as
a poll worker, with the ability to interact with a legitimate
administrator or ender card could also learn enough infor-
mation to produce homebrew administrator and ender cards
(Section III-C).
Let us consider several ways that an adversary could learn
the protocol between voter cards and voting terminals. After
voting, instead of returning the canceled card to the poll-
worker, the adversary could return a fake card that records
how it is reprogrammed, and then dumps that information to
a collaborating attacker waiting in line to vote. Alternatively,
the attacker could attach a “wiretap” device between the
voting terminal and a legitimate smartcard and observe the
communicated messages. The parts for building such a device
are readily available and, depending on the setup at each
voting location, might be unnoticed by poll workers. An
attacker might not even need to use a wiretap device: as
a literal “person-in-the-middle” attack, the adversary could
begin by inserting a smartcard into the terminal that records
the terminal’s ﬁrst message. The adversary would then leave
the voting location, send that message to a real voter card
that he or she stole, and learn the real voter card’s response.
The adversary’s conspirator could then show up at the voting
location and use the information gained in the ﬁrst phase to
learn the next round of messages in the protocol, and so on.
We comment again that these techniques work because the
authentication process is completely deterministic and lacks
any sort of cryptography.
B. Casting multiple votes
In the Diebold system, a voter begins the voting process by
inserting a smartcard into the voting terminal. Upon checking
that the card is “active,” the voting terminal collects the user’s
vote and then deactivates the user’s card; the deactivation
actually occurs by rewriting the card’s type, which is stored
as an 8-bit value on the card, from VOTER_CARD (0x01)
to CANCELED_CARD (0x08). Since an adversary can make
perfectly valid smartcards, the adversary could bring a stack of
active cards to the voting booth. Doing so gives the adversary
the ability to vote multiple times. More simply, instead of
bringing multiple cards to the voting booth, the adversary
could program a smartcard to ignore the voting terminal’s
deactivation command. Such an adversary could use one card
Proceedings of the 2004 IEEE Symposium on Security and Privacy (S&P’04)  
1081-6011/04 $ 20.00 © 2004 IEEE 
to vote multiple times. Note here that the adversary could be
a regular voter, and not necessarily an election insider.
Will the adversary’s multiple-votes be detected by the voting
system? To answer this question, we must ﬁrst consider what
information is encoded on the voter cards on a per-voter basis.
The only per-voter information is a “voter serial number” (m_
VoterSN in the CVoterInfo class). m_VoterSN is only
recorded by the voting terminal if the voter decides not to
place a vote (as noted in the comments in TSElection/
Results.cpp, this ﬁeld is recorded for uncounted votes for
backward compatibility reasons). It is important to note that if
a voter decides to cancel his or her vote, the voter will have the
opportunity to vote again using that same card (and, after the
vote has been cast, m_VoterSN will no longer be recorded).
If we assume the number of collected votes becomes greater
than the number of people who showed up to vote, and if the
polling locations keep accurate counts of the number of people