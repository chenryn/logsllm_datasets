bytecode instructions are parsed into opcodes and operands,
and semantic information consisting of native instructions
that carry out the actions of the bytecode instructions. We
identify the control-ﬂow semantics from which structures
such as a control-ﬂow graph (CFG) can be generated. To-
gether, these techniques provide the foundation for overcom-
ing the emulation layer and performing subsequent malware
analysis.
Our algorithms are based on dynamic analysis. We exe-
cute the emulated malware once in a protected environment
and record the entire x86 instruction trace generated by the
malware. From this trace, we extract syntactic and semantic
information about the bytecode that the malware’s emulator
was interpreting during execution. The contributions made
by our approach offer the opportunities to reconstruct be-
havioral information about unknown bytecode interpreted by
an unknown decode-dispatch emulator and to subsequently
apply traditional malware analysis to the sample.
The algorithms operate as follows:
1) Identify variables within the raw memory of the emu-
lator based upon the access patterns of reads and writes
in an execution trace. We developed abstract variable
binding, a forward and backward dynamic data-ﬂow
analysis, for this identiﬁcation.
2) Identify the subset of those variables that are can-
didates for the emulator’s virtual program counter
(VPC). We ﬁnd possibilities by clustering the emu-
lator’s memory reads, some of which are bytecode
fetches, based upon the abstract variable used to
specify the accessed memory location.
3) Identify the boundaries of the bytecode data within
the x86 application, the decode-dispatch loop, and the
emulator phases. For each cluster of reads through
the same abstract variable, we determine whether the
reads occurred during execution of loop iteration with
emulator-like operations.
4) Identify the syntax and the semantics of bytecode op-
erations. We examine how bytecode is accessed by the
emulation phases to identify its syntax. We discover
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
bytecode handler, forming the semantics of the byte-
code instructions. Handlers that cause non-sequential
updates to the VPC indicate that the bytecode opcode
corresponds to a control transfer operation, allowing
our system to construct a CFG for the bytecode.
The following sections describe these steps in detail.
3.1. Abstract Variable Binding
A decode-dispatch emulator fetches bytecode instructions
from addresses speciﬁed by a virtual program counter
(VPC). Like a program counter or instruction pointer register
in hardware, a VPC acts as a pointer to the currently execut-
ing bytecode instruction. Knowing the memory location of
the VPC allows an analyzer to observe how the emulator
accesses bytecode instructions and executes them, which
reveals information about the bytecode instruction syntax
and semantics. We locate an emulator’s VPC through a series
of analyses, beginning with abstract variable binding.
Abstract variable binding identiﬁes, for each memory read
instruction of an execution trace, the program variable con-
taining the address specifying the location from which the
data should be read. Consider pseudo-code of an emulator
that regularly fetches instructions pointed to by the VPC:
instruction = bytecode[VPC]
or
instruction = ∗VPC
(1)
In these examples, the VPC is an index into an array of
bytecode or a direct pointer into a buffer of bytecode. During
its execution,
the emulator will execute these bytecode
fetches many times. Although each fetch may access a
different memory location within the bytecode buffer, all
fetches used the same VPC variable as the speciﬁer of the
location. Abstract variable binding will attach a program
variable, such as VPC, to every memory read instruction
in the execution trace that uses that variable to specify its
access location.
Successful abstract variable binding will help our analyzer
identify the VPC and the bytecode buffer used by the
unknown emulator in a malware instance. Each bytecode
fetch will appear in the execution trace as a memory read
instruction whose accessed location is bound to the VPC
variable. The emulator likely executes many other memory
reads unrelated to bytecode fetch, and these may have their
own bindings to other variables in the program. Steps 2 and 3
of our algorithms, presented in Sections 3.2 and 3.3, whittle
down the bindings to only those of the VPC.
Our analysis of x86 instruction traces rather than source
code complicates abstract variable binding in fundamental
ways. First, a binary program has no notion of high-level lan-
guage variables. A compiler translating an emulator’s high-
level code into low-level x86 instructions will assign each
variable to a memory location or register in a way unknown
to our analysis. Second, the x86 architecture requires all
memory read and write operations accessing dynamically
computed addresses to use register indirect addressing. In
case of performing a memory read using an address stored
in a variable, if the variable is assigned a memory location,
then that value will be transferred into the register rather
than being accessed directly. For example, the pseudo-x86
translation of (1) may be the two-instruction sequence:
eax ← [VPC]
instruction ← [eax]
(2)
(3)
where VPC represents a pointer variable (assigned a particu-
lar memory address), eax is a register, and instruction
is a register or memory location. The ﬁrst instruction loads
the value of the variable VPC to eax. This value is the
address used in the second instruction where the register
eax can be considered temporary storage for the VPC. In
other words, (2) binds eax to VPC, and this binding is
propagated to the read operation in (3).
With a limited number of registers, the same register
can be bound to different variables at different points of
execution. When updating a variable with a non-immediate
value, the new value must be loaded into a register using
an instruction similar to (2) before transferring the value
to the variable’s assigned memory location. In this case,
the register is already bound to a variable and the binding
is not changed when loading the value into the register.
Without knowledge of how variables in the program are
assigned to memory or registers, it is hard to determine
whether a register load operation such as (2) is a new
variable binding to the register or a new value assigned to
an already bound variable. We draw three conclusions that
impact the design of our abstract variable binding algorithm.
First, we use absolute memory addresses as our description
of a high-level language variable. Second, we must analyze
data ﬂows along an entire trace to determine variable binding
information appropriately. Third, to be able to identify all
abstract variables, we must conservatively consider both
scenarios described above for each instruction similar to (2).
Abstract variable binding propagates binding informa-
tion using dynamic data-ﬂow analysis across an execution
trace of the emulated malware. We use both a forward
and a backward propagation steps, corresponding to the
two different ways in which a variable’s value may be
set. A variable’s value may be an incremental update to
its previous value; forward binding identiﬁes the abstract
variables (memory locations) from which a read operation’s
address is derived in this case. A variable’s value may
also be directly overwritten with a new value unrelated
to its previous contents. Backward binding determines the
appropriate bindings in this case based on the variable’s
future use. Our backward binding algorithm is conservative
and introduces imprecision.
98
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
Algorithm 1 Forward Binding
Initialize: ∀r ∈ R : B0(r) = {} and V0(r) = NONE
for i = 1 to l do
∀r ∈ R : Bi(r) = Bi−1(r) and Vi(r) = Vi−1(r)
Update Bi and Vi using rules F1 to F6
if
then
i ∈ ρ and instruction is r1 ←v [r2] or r1 (cid:17)v [r2]
F B(i) = Bi(r2)
end if
end for
Algorithm 2 Backward Binding
Input: ∀r ∈ R and 1 ≤ i ≤ l : Vi(r) from Alg. 1
Initialize: ∀r ∈ R : B(cid:48)
l+1(r) = {σr} for 1 ≤ j ≤ k
for i = l to 1 do
i(r) = B(cid:48)
i+1(r)
i using rules B1 to B3
i ∈ ρ and instruction is r1 ←v [r2] or r1 (cid:17)v [r2]
BB(i) = B(cid:48)
i(r2)
∀r ∈ R : B(cid:48)
Update B(cid:48)
if
then
end if
end for
A malicious emulator may also attempt to complicate
analysis by obfuscating its use of a VPC. For example, it
may replace a single VPC with a collection of variables and
switch among the collection during execution. However, the
collection must together still follow an orderly progression
and update sequence to ensure that the emulator correctly
executes the bytecode. This fundamental need to maintain
consistency will produce data ﬂows between two elements
of the VPC collection whenever the emulator switches from
one element to another. Our data-ﬂow analysis will track
these ﬂows and remains robust to this type of emulator
obfuscation.
We use the following notations for the presentation of
our algorithms. Let M denote the memory address space
of the emulator and R the set of registers available on the
target hardware. We uniquely identify abstract variables by
memory addresses using the set α ⊆ M. We represent
instructions in an intermediate representation that expresses
only simple move and compute operations on registers and
memory and has one source and one destination. Let the
loading of constant c into register r be denoted as r ← c.
A memory read operation is r ←v [m], which indicates that
the value v is read from memory address m and loaded
into register r. Here m can be a constant or register holding
an address. Memory writes are denoted by [m] ←v r. A
register-to-register move operation is r1 ← r2. If the right-
hand side of any of these operations involves computation
using the speciﬁed variable or address, then we denote the
assignment as (cid:17) rather than ←. We identify each instruction
in an execution trace with a sequence number i ∈ N. Let
the set ρ ⊆ N consist of all read operations of the form
r ← [m] or r (cid:17) [m]. Lastly, let the function Addr : ρ → M
be deﬁned as: Addr(i) represents the address of a read
operation i ∈ ρ.
3.1.1. Forward Binding. Forward binding identiﬁes those
variables supplying the address used by a read operation.
The algorithm works on the execution trace and propagates
information forward along the instructions in the trace. For
each register, we track both the set of abstract variables
bound to the register and the value stored in the register.
A memory read instruction is bound to the same variable
as that bound to the register specifying the address of the
read. The set Bi(r) denotes the abstract variables bound to
register r ∈ R at instruction i. Vi(r) represents the value
in register r at i. Forward propagation updates bindings and
values according to the following six rules based upon the
instruction type. For convenience, we use the function fi to
indicate the computation of instruction i.
r ← c: Bi(r) = {} and Vi(r) = c
r ←v [c]: Bi(r) = {c} and Vi(r) = v
r1 ←v [r2]: Bi(r1) = {Vi−1(r2)} and Vi(r1) = v
r (cid:17) c: Bi(r) = Bi−1(r) and Vi(r) = fi(Vi(r), c)
r (cid:17)v [c]: Bi(r) = Bi−1(r) ∪ {c} and Vi(r) =
fi(Vi−1(r), v)
r1 (cid:17)v [r2]: Bi(r1) = Bi−1(r1) ∪ {Vi−1(r2)} and
Vi(r1) = fi(Vi−1(r1), v)
F1
F2
F3
F4
F5
F6
Rules F1–F3 apply new register value assignments where
values are taken directly from a constant, register, or memory
location. Bindings reset to those of the data source. Rules
F4–F6 compute assigned values from the previous register
value and other data; these correspond to incremental up-
dates to a value and do not cause bindings to reset. Rules
F3 and F6 correspond to reads using indirect addressing and
are points where instruction bindings indicate possible VPC
use.
All rules update B and V based on the current and
immediate predecessor instructions, so propagation operates
from the ﬁrst instruction to the last. The algorithm outputs
the mapping F B : N → α∗ describing bindings from
memory read operations to abstract variables. Algorithm 1
presents the pseudo-code for forward binding; l is the trace
length.
3.1.2. Backward Binding. We expect realistic bytecode
languages to provide one or more types of control transfer
operations such as jumps and branches. Forward binding
propagates abstract variable bindings when operations com-
pute an incremental update to an already-bound variable,
which does not reﬂect the semantics of a control transfer.
Control transfers will instead cause the emulator to directly
overwrite the VPC with the target address. The emulator will
execute instructions matching rule F1 or F2, which reset the
99
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
Backward binding operates in the reverse order of forward
binding. It ﬁrst binds a variable to a register when that
register’s value is stored to memory, and then propagates
the binding backwards to other registers using the following
rules:
B1
B2
B3
i(r2) = {Vi(r1)}
i(r) = {c}
i(r2) = B(cid:48)
[r1] ← r2 : B(cid:48)
[c] ← r : B(cid:48)
r1 ← r2 : B(cid:48)
i+1(r1)
binding information. Backward binding, a second variable
binding step that follows the forward algorithm, computes
bindings in such cases by identifying bound variables when
a value is written out to memory and then propagating the
binding backward to all previous uses. This algorithm is
conservative and may over-approximate the actual variable
bindings.
The algorithm outputs the mapping for backward binding
BB : N → α∗. Algorithm 2 presents pseudo-code for
backward binding.
3.1.3. Identifying Dependent Abstract Variables. Vari-
ables used to contain memory read addresses may them-
selves be interdependent. For example, if the obfuscation
technique of utilizing a collection of VPCs is used, the
VPC related variables have a relationship with each other.
Likewise memory reads that access operands may occur
at short, ﬁxed offsets from the VPC value. We identify
dependencies among abstract variables by tracking the ﬂow
of data values from one abstract variable to another. As
this is forward data-ﬂow, we incorporate dependent variable
identiﬁcation as part of our forward binding algorithm.
Let the mapping DV : α → α∗ denote abstract variable
dependencies, where Y ∈ α is a dependent variable of X
if Y ∈ DV (X). To populate this mapping, we add the
following rule to Algorithm 1:
[r1] ← r2 : DV (r1) = DV (r1) ∪ {Bi(r2)}
D1
Dependencies are commutative. After the completion of
Algorithm 1, we add the converse of each dependency
identiﬁed by the algorithm: ∀X, Y ∈ M: if X ∈ DV (Y )
then add Y ∈ DV (X). Identifying these abstract variable
dependencies thwart attacks that introduce extraneous store
operations or copy operations from one variable to another
before use.
3.1.4. Lifetime of Variables. Our x86 execution trace
analysis introduces one ﬁnal challenge that
is often not
present when using high-level language variables. We use
absolute memory locations as our abstract variables, but the
same memory location may be used for different variables
at different points of execution. Although variables in the
static data region have the lifetime of the entire execution,
variables on the stack and heap have shorter lifetimes. The
same address can be shared among multiple variables in
different execution contexts depending on the allocation and
deallocation operations performed during execution.
100
We address the limited lifetime of stack variables by
including stack semantics and analysis of the stack pointer
register esp as part of our algorithms. Our set of abstract
variables α is made of tuples α ⊆ M × N × N that use
integers to denote the start and end of the variable’s live
range within the execution trace. At the ﬁrst access to a
memory address m ∈ M at instruction s, we add (m, s,∞)
to α. If the tth instruction modiﬁes the esp register such that
an abstract variable’s memory address has been deallocated
from the stack, then the end of its lifetime is set to t.
Any access to the same memory address after its lifetime
expired creates a new abstract variable. For pedagogy, we
presented Algorithms 1 and 2 without live ranges; updates
to the algorithms to include lifetimes are straightforward.
In this work, we do not address lifetimes for variables
allocated on the heap. Prior heap analysis research [3] often
assumed that the analyzer understood the heap allocation
and deallocation routines. We cannot make this assumption
for malware binaries, which may be stripped of debugging
information and deliberately obfuscate the heap routines.
Further research is needed to address this open problem.
3.2. Identifying Candidate VPCs
We use the computed variable bindings to identify can-
didate variables that may be the malware emulator’s virtual
program counter. We ﬁrst combine the bindings identiﬁed
by the forward and backward algorithms to compute the
complete abstract variable bindings for each memory read.
the function Vars : N → α∗ be computed as the
Let