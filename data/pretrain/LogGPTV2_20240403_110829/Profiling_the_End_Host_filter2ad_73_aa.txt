title:Profiling the End Host
author:Thomas Karagiannis and
Konstantina Papagiannaki and
Nina Taft and
Michalis Faloutsos
Proﬁling the End Host
Thomas Karagiannis1, Konstantina Papagiannaki2,
Nina Taft2, and Michalis Faloutsos3
1 Microsoft Research
2 Intel Research
3 UC Riverside
Abstract. Proﬁling is emerging as a useful tool for a variety of diagno-
sis and security applications. Existing proﬁles are often narrowly focused
in terms of the data they capture or the application they target. In this
paper, we seek to design general end-host proﬁles capable of capturing
and representing a broad range of user activity and behavior. We ﬁrst
present a novel methodology to proﬁling that uses a graph-based struc-
ture to represent and distill ﬂow level information at the transport layer.
Second, we develop mechanisms to: (a) summarize the information, and
(b) adaptively evolve it over time. We conduct an initial study of our pro-
ﬁles on real user data, and observe that our method generates a compact,
robust and intuitive description of user behavior.
1 Introduction
Proﬁling a behavior refers to the act of observing measured data and extracting
information which is representative of the behavior or usage patterns. Proﬁling is
useful in developing a model of the behavior and in deriving guidelines of what is
normal and abnormal within that context. Examples of successful uses of proﬁles
include proﬁling of traﬃc patterns on server links to uncover DoS and ﬂash
crowd events [4], web-server proﬁling [11], power usage proﬁles for eﬃcient power
management [10], proﬁling end-to-end paths to detect performance problems [8],
proﬁling of traﬃc patterns on aggregated gateway and router links to facilitate
accurate application classiﬁcation [5], etc.
While there has been research on proﬁling web server traﬃc [4,11], and gate-
way and backbone links (i.e., highly aggregated traﬃc) [5,12], end-host proﬁling
has received little attention. One work in this area is [7] in which the authors
build end-host proﬁles with the goal of defending against worm attacks. Their
proﬁle describes the community of hosts an end-system normally interacts with.
We believe that observing the host behavior at the transport layer can reveal
a wealth of information, such as: behaviors on who tries to talk to the host,
who the host communicates with, the mix of applications used, the dispersion
(or randomness) of the destinations contacted for a particular application, the
pattern of port usage, the evolving mix of protocol usage, and so on. A number
of security applications have identiﬁed particular features, derivable from packet
header ﬁelds, as useful for detecting speciﬁc attacks. For example, many IDS
S. Uhlig, K. Papagiannaki, and O. Bonaventure (Eds.): PAM 2007, LNCS 4427, pp. 186–196, 2007.
c(cid:2) Springer-Verlag Berlin Heidelberg 2007
Proﬁling the End Host
187
systems will declare a machine compromised if the number of simultaneous TCP
connections exceeds a predeﬁned threshold [2,1]. Yet other systems look for a
change in the dispersion on destination IP addresses to ﬁnd anomalies [6].
All aforementioned work tends to deﬁne proﬁles within the bounds of their
intended use. In this work, we are trying to formalize the concept of proﬁling
transport layer information and identify desirable properties. We believe that a
proﬁling mechanism, focused on end-hosts, should meet the following goals.
– Goal 1: It should be able to identify dominant and persistent behaviors of
the end-system, capturing repeatable behaviors over time.
– Goal 2: It should be a compact enough representation, avoiding excess detail
that may correspond to ephemeral behavior. This is important in a network-
ing setting due to the use of ephemeral ports by certain applications.
– Goal 3: It should be stable over short-time scales avoiding transient variabil-
ity in the host behavior.
– Goal 4: It should evolve by adding new behaviors and removing stale ones.
– Goal 5: It should be able to capture historical information to illustrate typical
ranges of values for features.
Our main contribution is a novel approach to proﬁle end-host systems based on
their transport-layer behavior. First, we propose the use of a graph-based struc-
ture which we call a graphlet, to capture the interactions among the transport-
layer protocols, the destination IP addresses and the port numbers. Note that
graphlets have two key properties: (a) they are extensible, since through an-
notations of the nodes or links one could achieve a lossless representation of
all ﬂow information through a single graph, and (b) they provide intuitive and
interpretable information. The notion of graphlets was introduced in [5] for ap-
plication classiﬁcation. Building on [5], we extend this original idea in a number
of nontrivial ways. Second, we design a two step method that is based on an un-
supervised online learning process. In the ﬁrst step, we build and continuously
update activity graphlets that capture all the current ﬂow activity. The second
step contains mechanisms to (a) compress the large activity graphlets to retain
only essential information, and (b) to evolve this latter summary in a way that
reﬂects changes over time. The output of this process is called a proﬁle graphlet.
Using enterprise network traces, we ﬁnd that user activity is successfully cap-
tured in our proﬁles. In particular, our proﬁles capture roughly 70-90% of all
user activity, yet are about 80-90% smaller in size relative to the uncompressed
activity graphlets. This result demonstrates that our proﬁles are eﬃcient and
compact while still remaining highly descriptive. Our initial ﬁndings indicate
that proﬁles can vary greatly across users and this motivates the use of end-host
proﬁles for security, diagnosis and classiﬁcation applications. One of our inter-
esting ﬁndings is that over short time scales (e.g., 15 minutes) the proﬁles evolve
slowly typically experiencing small changes, yet over longer periods of time (e.g.,
a month), the majority of the proﬁle content may change. This indicates that
most parts of the proﬁle are apt to change, and further underscores the need for
adaptivity.
188
T. Karagiannis et al.
2 Data Description
We collected packet header traces within a secure enterprise network environ-
ment. Using the CoMo monitoring tool [9], we capture all traﬃc on the access
link of our oﬃce building. Two traces were collected; one spans the entire month
of October 2005, and the other a two week period in November 2005. We monitor
the traﬃc of roughly 200 distinct internal IP addresses, that collectively repre-
sent user laptops and desktops, as well as network infrastructure equipment (e.g.,
NFS or DNS servers).
3 Methodology
3.1 Capturing Host Activity Via Graphs
A fundamental element of our proﬁling methodology is the special purpose
graph, called graphlet. The concept of graphlets was ﬁrst introduced by the
BLINC methodology [5] to capture the distinct transport layer footprint of
diﬀerent applications, termed as “application graphlets”. Application graphlets
were further used for the classiﬁcation of the traﬃc observed at a traﬃc ag-
gregation point into applications. Our use of graphlets in this work is signiﬁ-
cantly diﬀerent from the original BLINC work. We extend the deﬁnition of a
graphlet, introduce graphlet annotations and manipulate the graphlet in diﬀer-
ent ways (in terms of learning, updating, compacting, etc). First, the intended
goal and use of graphlets in our work is substantially diﬀerent compared to
BLINC. BLINC’s goal was to identify application footprints in traﬃc streams
in a supervised manner according to the pre-deﬁned application graphlets. On
the contrary, we study graphlets with the goal to proﬁle hosts in an unsu-
pervised way, i.e., we learn (and update) an unknown user behavior on-line.
Second, as described below, we extend the graphlet deﬁnition to include addi-
tional elements. Third, we introduce ideas for summarizing and creating compact
graphlets.
A graphlet is a graph arranged in six columns corresponding to: (srcIP, proto-
col, dstIP, srcport, dstport, dstIP). Fig. 1(top left) presents an example graphlet
that was derived from one of our LAB hosts and plotted using the graphviz
tool [3]. The BLINC graphlets consisted only of the ﬁrst 5 columns; the addi-
tional sixth column here is critical to our methodology.
Each graphlet node1 presents a distinct entity (e.g. port number 80) from the
set of possible entities of the corresponding column. The lines connecting nodes
imply that there exists at least one ﬂow whose packets contain the speciﬁc nodes.
This way, each ﬂow creates a directed graphlet path starting from the host IP
address on the left and traversing the appropriate entities in each column. Note
that we deﬁne a ﬂow by the 5-tuple of the packet header, and the ﬂow can consist
of one or more packets. Similarly, a graphlet path can correspond to a multitude
1 The term node indicates the components of a graphlet, while the term host indicates
a communicating device.
Proﬁling the End Host
189
Activity graphlet
Profile graphlet
proto dstIP
sPort dPort dstIP
proto dstIP
sPort dPort
dstIP
Node
In-Degree
Out-Degree
Significant-Node Set
6
10.212.4.255
-
4
2
2
_80
2
2
Fig. 1. Example of a host activity and proﬁle graphlets and the signiﬁcant node set
of ﬂows with the same 5-tuple deﬁnition. The destination IP appears twice at
the third and sixth column in the graphlet. This redundancy is critical, since it
allows us to observe all pairwise interactions between the most information-heavy
ﬁelds of the 5-tuple: destination IP address (dstIP ), the source port (srcport)
and destination port (dstport).
If many ﬂows traverse a node, the node will most likely have a high degree. By
construction, all edges in a graphlet are between nodes of adjacent columns. If
we traverse a graphlet from left to right by following a path, we deﬁne a direction
in visiting the nodes. This way, we can deﬁne the in-degree (out-degree) of
a node as the number of edges on the left (right) side of the node. The in- and
out-degree of a dstIP, srcport, or dstport node abstracts its interaction with the
other two types of nodes. For example, the out-degree of a node representing
port 80, captures the dispersion of addresses visited using web applications.
Because we are building proﬁles for a single host, there is only one source IP
address and hence this ﬁeld is not included in what we are terming the “heavy
information ﬁelds” of the 5-tuple. We point out that a graphlet is a directed
graph. When the host is the source, the directed edges ﬂow from left to right in
our depictions. If the directed edges ﬂow from right to left, then our host is the
recipient of incoming ﬂows. Note that although conceptually each proﬁle consists
of two directed graphs, in practice a single data structure can be designed to
capture all the needed information.
For example, Fig. 1 presents an “activity” graphlet which resulted by observ-
ing all the incoming and outgoing ﬂows of a host during a speciﬁc time window.
The “proﬁle” graphlet refers to our distilled and compact version of the activity
graphlet. (Activity and proﬁle graphlets, along with signiﬁcant node sets are
discussed in Sec. 3.3).
190
T. Karagiannis et al.
s
t
s
o
h
d
n
E
#
103
102
101
100
0
10
20
30
40
50
Average out-degree of the TCP node
s
t
s
o
h
d
n
E
#
103
102
101
100
0
5
10
15
20
25
30
35
40
45
Average out-degree of the "port 80" node
Fig. 2. Histograms of the average out-degree of two diﬀerent nodes (TCP and “port
80” node) in the client graphlets computed every 15 minutes. Signiﬁcant variations in
the number of out-degrees across clients point towards client personalized proﬁles.
3.2 The Advantages of graphlet Proﬁling
We believe that graphlets are an interesting approach to end-host proﬁling for a
number of reasons. First, one could imagine keeping per host ﬂow records in order
to compute statistics regarding its behavior. A database of ﬂow records is an
enormous amount of information. Instead, our graphlet achieves a representation
of important information in a compact form limiting the redundancy. Second,
such ﬂow records are not interpretable without further processing. However, the
paths, nodes and node properties in graphlets are easy to interpret.
We can further expand graphlets to annotate nodes with temporal informa-
tion. For example, we can create time series information for each node (e.g., the
time series of the out-degree). This is equivalent to annotating the nodes in the
graph and tracking the evolution of the weights. Similarly, we can attach weights
to links in the graph in order to track more typical features, such as the number
of packets or bytes for all ﬂows transiting that path. Existing security solutions
use threshold based-techniques on metrics like the number of TCP connections
per destination port per time interval. Recent solutions examine the dispersion
of the 3 key ﬁelds [6]. All such techniques can be captured within the framework
of weight-annotated graphlets. The power of this proﬁling mechanism is that it
goes beyond these methods, since it also incorporates the graph relationships,
all in a single structure. We illustrate this here with three examples:
• The out-degree of the TCP node (or any protocol node) reveals the typical
number of TCP destination IPs per client. By observing how the out-degree
of the TCP node in the graphlet evolves over time, we learn about the typi-
cal range for the number of simultaneous destinations contacted through TCP
within a window of time (the time scale of the graphlet). For example, Fig. 2
(left) presents a histogram of the average out-degree of the TCP node for all our
client graphlets every 15 minutes. We observe a wide range of behavior.
• For applications with well-known port numbers, graphlets can reveal what is
the typical number of destination IPs contacted for each given application. For
Proﬁling the End Host
191
Method: Construct Proﬁle
1. Upon arrival of each packet, update
activity graphlet if ﬂow information
not already included.
2. Every t minutes
a). identify new signiﬁcant activity,
according to summarization policy
as candidate to join proﬁle graphlet.
b). Add new signiﬁcant activity into
proﬁle, if approved by delayed-accept
policy, using Algorithm 1.
c). Remove stale parts of proﬁle
according to aging policy.
Fig. 3. Summary of Method
Algorithm 1: Populate Proﬁle Graphlet
with Signiﬁcant Nodes
Repeat until all signiﬁcant nodes
processed
1. Rank all nodes in activity
graphlet according to their maximum
in-degree or out-degree:
max{indegree, outdegree}
2. Remove the highest degree node
and all its edges. Insert into
proﬁle graphlet.
Fig. 4. Algorithm: inserting signiﬁ-
cant nodes into proﬁle
example, examining the out-degree of the graphlet node for destination “port
80” reveals the number of destinations typically contacted by an HTTP appli-
cation. Similarly Fig. 2 (right) presents a histogram of the average out-degree
of the “port-80” node for all our client graphlets computed every 15 minutes.