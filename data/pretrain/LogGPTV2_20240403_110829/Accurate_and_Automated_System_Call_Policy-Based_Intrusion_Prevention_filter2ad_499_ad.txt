require injected code. This kind of attack typically over-
ﬂow the arguments of the single system call it needs.
The facts that PAID performs advanced system call ar-
gument check and it inserts null system calls randomly
greatly decrease the vulnerability of PAID to these types
of attacks. If an attacker is able to directly manipulate
dynamic-variable-type system call arguments of some
sensitive system calls, PAID cannot stop this type of data
attack. However, to the best of our knowledge this type
of attack is extremely rare in practice. Moreover, under
PAID’s extensive system call argument checks, it is even
less likely for this type of attacks to prevail.
4 Performance Evaluation
4.1 Prototype and Methodology
The current PAID compiler is derived from GCC 3.1
and GNU ld 2.11.94 (linker), and runs on RedHat Linux
7.2, and it can successfully compile the whole GLIBC
(version 2.2.5), and production-mode network server
programs, such as Apache and Wu-ftpd. For this study,
we used as test programs the set of network server ap-
plications listed in Table 1, and compared PAID’s perfor-
mance and space requirement with those running under
GCC 3.1 and Red Hat Linux 7.2, which represent the
baseline case. To analyze detailed performance over-
head, we conducted each experiment in two different
conﬁgurations: plain PAID that only uses CSFGs (plain
PAID ), and PAID with both random null system calls
and input argument check (argument/random PAID ).
To test the performance of each server program, we
used two client machines to continuously send 2000 re-
quests to the tested server program. The throughput of
a network server application is calculated by dividing
2000 by the time interval between the ﬁrst request and
termination of the last request. The latency is calcu-
lated by taking the average of the response time mea-
surements for the 2000 requests.
The server machine is a 1.5-GHz P4 with 256MB
memory, one client machine is a 300-MHz P2 with
128MB memory and the other client is a 1.1-GHz P3
with 512MB memory. They are connected through an
isolated 100Mbps Ethernet link. All machines run Red-
Hat Linux 7.2. To test http and ftp servers, the client
machines continuously fetched a 60-KByte ﬁle from the
server, and the two client programs were started simul-
taneously. In the case of pop3 server, the clients checked
mails and retrieved a 60-KByte mail from the server. All
client programs used in the test were modiﬁed to send
2000 requests continuously to the server. To speed up
the request sending process, client programs discarded
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:27:46 UTC from IEEE Xplore.  Restrictions apply. 
the data returned from the server. All network server
programs tested were statically linked, and the GLIBC-
2.2.5 library was recompiled by the PAID compiler.
Program
Qpopper
Apache
Wu-ftpd
Proftpd
pure-ftpd
Plain
PAID
Latency
Penalty
9.666%
5.436%
8.341%
5.901%
5.614%
Argument/
Random
PAID
Latency
Penalty
13.020%
6.918%
9.074%
8.233%
8.358%
Plain
PAID
Throughput
Penalty
8.815%
5.158%
7.699%
5.572%
5.316%
Argument/
Random
PAID
Throughput
Penalty
11.520%
6.470%
8.319%
7.601%
7.713%
Table 2. Thelatencyandthroughputpenalty
of each network application compiled under
different PAID conﬁgurationswhen compared
withthebaselinecase.
4.2 Performance Overhead
PAID adds an extra .csfg section to an applica-
tion’s binary image to store all CSFGs. Because of the
.csfg section and the notify system call insertion, the
binary image of a network application compiled under
the PAID compiler is larger than that compiled under
GCC. The binary image space overhead of the test appli-
cations ranges from 59.78% to 109.10% when compiled
under a plain PAID compiler (plain PAID), and from
60.01% to 110.54% when compiled under a plain PAID
compiler augmented with insertion of random null sys-
tem calls and system call argument-related notify sys-
tem calls (argument/random PAID), as shown in Table 1.
Most of the space overhead is due to the .csfg sec-
tion, whose absolute size ranges from 337,856 bytes
to 935,440 bytes for the argument/random version of
PAID. In addition, a 2-Mbyte saved stack data struc-
ture is allocated for each application to store the return
addresses.
In total, each applications needs less than
3Mbytes of extra address space to work under PAID.
The performance overhead of PAID mainly comes
from stack transition check, argument check and the de-
cision logic required to move to the next CSFG state. We
measured the average additional processing overhead of
each system call due to this check, and the results are
5.98%, 6.6%, 7.73%, 9.12% and 10.02% for Apache,
Pure-ftpd, Proftpd, Wu-ftpd, and Qpopper respectively.
The overall latency and throughput penalty of PAID
compared with the base case (generic GCC/Linux) is
shown in Table 2. The overall latency penalty of plain
PAID ranges from 5.436% (Apache) to 9.666% (Qpop-
per), and the throughput penalty ranges from 5.158%
(Apache) to 8.815% (Qpopper). These results show that
PAID’s run-time performance overhead is quite reason-
able. This is also true for the argument/random PAID
conﬁguration. The latency penalty for argument/random
PAID is from 6.918% (Apache) to 13.02%(Qpopper),
and the throughput penalty ranges from 6.47% (Apache)
to 11.52% (Qpopper). Compared with plain PAID, ar-
gument/random PAID incurs more overhead, because
each null system call inserted incurs expensive context
switching overhead. As the number of null system calls
inserted increases, this overhead also increases, but the
strength of protection against mimicry attacks also im-
proves as attack codes are forced to follow more closely
the application’s original execution ﬂow.
The largest number of stack frames that ever appears
in the worst-performing test program, Qpopper, is 15.
For other tested programs, the stack size rarely exceeds
20, with the common stack frame size between 3 and 10.
This stack size distribution results show that for com-
mon network applications, PAID’s run-time veriﬁer does
not need to traverse a large portion of the CSFG for each
system call instance, and that is the reason why PAID’s
throughput and latency penalty is relatively modest.
Appli
cation
Qpopper
Apache
Wu-ftpd
Proftpd
Pure-ftpd
System
Call
Sites
38
26
54
13
54
Total
Arg
Num
76
51
102
25
82
Static
Con-
stant
50
23
60
17
30
Dyn.
Con-
stant
Dyn. Var
w/ Con-
straints
Dyn. Var
w/o Con-
straints
5
8
11
0
4
5
9
6
4
7
16
11
25
4
41
Table 3. Effectsofsystemcallargumentanal-
ysis.
4.3 Eﬀectiveness of System Call Argu-
ment Analysis
We tested the effectiveness of PAID’s system call ar-
gument analysis mechanism on the following ten critical
system calls: open, execve, create, chdir,
rename, mkdir, ioctl, link, unlink, and
chroot, as well as two wrapper system calls, fopen
and system. Table 3 shows the results of applying the
system call argument analysis on ﬁve network programs.
Between 50% to 84% of all system call arguments are
static constants, dynamic constants or dynamic variables
with constraints, depending on the applications. This re-
sult shows that system call argument analysis can indeed
serve as a powerful tool to defeat mimicry attacks. Wu-
ftpd and Apache have comparatively more dynamic con-
stants than others. The reason is that they tend to retrieve
operational information from conﬁguration ﬁles or from
the user input. Through our analysis, 21% to 59% of the
variables whose values cannot be derived statically are
either dynamic constants or variables with constraints.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:27:46 UTC from IEEE Xplore.  Restrictions apply. 
Since all our test programs are network applications that
process inputs from the network, it is unlikely that all
system call argument values can be determined statically
or at program initialization time.
Surprisingly, Proftpd does not have any dynamic con-
stants, and Pure-ftpd has a much higher percentage of
system call arguments that are classiﬁed as dynamic
variable. After examining the source code, we ﬁnd that
there are two major reasons that prevents PAID from
identifying their system call arguments as constants or
constraints. First, Pure-ftpd uses customized string ma-
nipulation functions whose semantics are unknown to
PAID. As a result, PAID cannot propagate constants
across these functions. Second, complicated program
and data structures such as function pointer and linked
list prevent PAID from conducting precise slice analy-
sis. Moreover, Pure-ftpd tends to invoke system calls
right after receiving user inputs, and use these inputs as
system call arguments. As a result, Pure-ftpd has many
more dynamic variables than other applications.
5 Conclusion
This paper describes the design, implementation, and
evaluation of PAID, a fully operational compiler-based
host-based intrusion detection and prevention system
that can automatically derive a highly accurate system
call model from the source code of an application and
use it for intrusion detection with low run-time over-
head. One key feature of PAID is its ability to exploit
run-time information, speciﬁcally, the return address se-
quence on the user/kernel stack and results of notify
system calls, to disambiguate the non-determinism in-
herent in a pure static analysis approach. The other
unique feature of PAID is that it can derive more pre-
cise constraints on the values of system call arguments
than other existing systems. In fact, we believe this pa-
per is the ﬁrst that presents quantitative measurements
on the effectiveness of deriving system call argument
constraints. Combination of these techniques effectively
reduces the vulnerability window to mimicry attacks to
a very small set of unlikely program patterns. As a re-
sult, PAID is one of the, if not the, most comprehensive
and efﬁcient host-based intrusion detection systems in
both the research and commercial worlds. Performance
measurements on a fully working PAID prototype show
that the run-time latency and throughput penalty of PAID
are under 13.02% and 11.52%, respectively, for a set of
popular network applications including the Apache web
server, a Pop3 server, the wu-ftpd FTP daemon, etc. This
excellent performance improvement mainly comes from
the fact that the system call model the PAID compiler
generates is very close to a DFA.
References
[1] CERT Coordination Center. Cert summary cs-2003-01.
http://www.cert.org/summaries/, 2003.
[2] H. H. Feng, J. T. Gifﬁn, Y. Huang, S. Jha, W. Lee, and
B. P. Miller. Formalizing sensitivity in static analysis for
intrusion detection. In IEEE Symposium on Security and
Privacy, Oakland, California, May 2004.
[3] H. H. Feng, O. M. Kolesnikov, P. Fogla, W. Lee, and
W. Gong. Anomaly detection using call stack informa-
tion. In Proceedings of the IEEE Symposium on Secu-
rity and Privacy, pages 62–76, Berkeley, CA, May 2003.
IEEE Press.
[4] J. T. Gifﬁn, S. Jha, and B. P. Miller. Detecting manipu-
lated remote call streams. USENIX Security Symposium,
August 2002.
[5] J. T. Gifﬁn, S. Jha, and B. P. Miller. Efﬁcient context-
sensitive intrusion detection. 11th Annual Network and
Distributed System Security Symposium, February 2004.
Codesurfer.
[6] GrammaTech,
Inc.
http://www.grammatech.com/products/codesurfer/.
[7] D. Grove and L. Torczon. Interprocedural constant prop-
agation: A study of jump function implementations. In
Proceedings of the ACM SIGPLAN 1993 conference on
Programming language design and implementatio, pages
90–99, 1993.
[8] S. Hofmeyr, S. Forrest, and A. Somayaji. Intrusion de-
tection using sequences of system calls. Journal of Com-
puter Security, 6(3), 1998.
[9] L. C. Lam and T. Chiueh. Automatic extraction of highly
accurate application-speciﬁc sandboxing policy. In Sev-
enth International Symposium on Recent Advances in
Intrusion Detection, Sophia Antipolis, French Riviera,
France, September 15-17 2004.
[10] R. Sekar, M. Bendre, P. Bollineni, and D. Dhurjati. A fast
automaton-based method for detecting anomalous pro-
gram behaviors. IEEE Symposium on Security and Pri-
vacy, pages 144–155, 2001.
[11] D. Wagner and D. Dean.
Intrusion detection via static
analysis. In Proceedings of the IEEE Symposium on Se-
curity and Privacy, pages 156–169, Oakland, CA, May
2001. IEEE Press.
[12] D. Wagner and P. Soto. Mimicry attacks on host-based
intrusion detection systems.
In Proceedings of the 9th
ACM Conference on Computer and Communications Se-
curity, November 2002.
[13] C. Warrender, S. Forrest, and B. Pearlmutter. Detecting
intrusions using system calls: Alternative data models.
In 1999 IEEE Symposium on Security and Privacy, pages
133–145, Oakland, California, May 1999.
[14] M. N. Wegman and F. K. Zadeck. Constant propaga-
tion with conditional branches. ACM Transactions on
Programming Languages and Systems, 13(2):181–210,
April 1991.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:27:46 UTC from IEEE Xplore.  Restrictions apply.