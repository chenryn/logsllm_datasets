bilinear maps. In a nutshell,
let BilGen be an algorithm
outputting the parameters (p, ˆe, G1, G2, GT , g1, g2) for a Type-
III pairing. For our instantiation, we choose the BN curve
9
family [9] and in particular the BN254 curve, which gives
us around 100 bit of security. If one wants to go for a larger
security level with comparable performance, one can follow
the same lines as Zcash7 and choose the BLS curve family [8]
and in particular the curve BLS12-381 giving roughly 120
bits of security.8
RSA. To have a security level of RSA parameters that is
comparable to the one for our chosen bilinear groups, we
selected moduli of 2048 bits in size.
D. A Concrete PBCH
We now present an efﬁcient instantiation of a PCH. In
particular, we instantiate our PCH using the concrete CHET
introduced in Section IV-B. We stress that although we end
up in a construction that instantiates one component based on
the RSA setting and the other one in a prime order group,
neither inﬂuences the other regarding choice of the security
parameters and it is a compromise to obtain a good overall
efﬁciency.
Our Construction. In Scheme 3, we present our concrete
instantiation. Likewise to the abstract algorithmic deﬁnition
of PCHs, we assume that all algorithms implicitly have ac-
cess to pk. Note that we use the CP-ABE scheme, which
is made IND-CCA2 secure as discussed in Section IV-A.
This scheme is used as a CCA secure KEM and combined
with an IND-CCA2 secure symmetric encryption scheme to
obtain a CCA2 secure hybrid encryption scheme (using the
compiler formalized in [20]). Consequently, we encrypt the
ephemeral
trapdoor using the symmetric scheme (denoted
by (KGenSE, EncSE, DecSE) in our construction). It is easy
to show that this modiﬁcation preserves the adaptive IND-
CCA2 security of the modiﬁed CP-ABE scheme. We note that
the hash functions H1, H2, H3, H4 are modeled as a random
oracles (ROs) [13]9 and let enc : {0, 1}(cid:96)+κ → GT be in
injective encoding function and (cid:96) be the maximum length of
keys output by KGenSE(1κ).
Combining the results in Theorems 1-3, 4, and Theorem 1
from [16], we obtain the following.
Corollary 1. The construction in Scheme 3 is an indistinguish-
able, outsider and insider collision-resistant PCH.
E. Performance Evaluation
To evaluate the practicality of our scheme, we implemented
our construction from Scheme 3 in Python 3.5.3 and base
our implementation on the Charm [2] framework version
0.5010, the implementation of FAME from the authors of [1]11,
whereas we use our own implementation of CH. We performed
the measurements on a laptop with an Intel Core i7-7600U
CPU @ 2.80GHz with 16GB RAM running Ubuntu 18.04.
All frequent operations, i.e., KGen, Hash, Verify and Adapt
7https://z.cash/blog/new-snark-curve.html
8Estimates from a personal communication with Razvan Barbulescu.
9We note that any practical ABE scheme in literature that support an
unlimited number of attributes from an unbounded domain are proven secure
in the Random Oracle Model.
10https://github.com/JHUISI/charm
11https://github.com/sagrawal87/ABE
for a policy of 64 attributes (consist of two OR clauses with
32 attributes connected via AND) are signiﬁcantly below a
second. Due to space constraints, we refer the reader to the
full version for the detailed performance analysis.
V. BLOCKCHAIN TRANSACTION-LEVEL REWRITING
In this section, we come back to the application of policy-
based chameleon-hash functions (PCHs) to rewriting objects in
blockchains, where we use the syntax of the Bitcoin blockchain
for our discussion. We recall that while Ateniese et al. [6]
target rewriting entire blocks within a blockchain, we propose
transaction-level rewriting. Here, blocks in the blockchain
remain intact but only speciﬁc transactions inside a block can
be rewritten. We deem this application much more important
than when focusing on blocks as it is much more ﬁne-grained
and keeps the overall blockchain intact. We recall that each
block in a blockchain stores a compact representation of a set
of transactions, i.e., the root hash of a Merkle tree (denoted
TX ROOT) which accumulates all transactions associated to
a block. Now, one way to integrate transaction-level rewriting
capabilities into blockchains by means of PCHs is as follows.
Every participant who engages in the role of an attribute
authority includes pk using a transaction signed under the key
corresponding to the public key of an address owner (we stress
that there are various other ways of distributing the pk’s in
a way that they can be veriﬁed). The attribute authority can
then issue PCH secret keys to other users. If a user wants
to include a modiﬁable transaction the transaction needs to
be hashed using the PCH. In Figure 5, we consider a toy
example of a block (Bi) which accumulates four transactions
Ti,1, . . . , Ti,4. Let us assume that transaction Ti,1 should be
rewritable by users that satisfy access policy A. Then the
last three transactions (Ti,2 to Ti,4) are processed as usual,
i.e., input to the hash computation based on H, but the ﬁrst
transaction is preprocessed by means of the PCH and the
hash value A is input in the Merkle tree. Observe that the
randomness ri
is not included in the hash computation of
the aggregation and is provided as non-hashed part of the
transaction/block. When the transaction needs to be updated,
everyone with a secret key satisfying A can compute a collision
for hash value A and provide the new randomness r(cid:48)
i. Note
that in contrast to the scenario of Ateniese et al. [6], the hash
function used to chain blocks remains to be a conventional
collision-resistant hash function and the PREV H values are
never updated.
Let us brieﬂy recall how the security properties of the PCH
come into play. Indistinguishability guarantees that it is not
detectable whether a hash computed by means of the PCH has
been adapted, i.e., whether a rewrite happened. We stress that
this even holds if PCH secret keys that would allow to compute
a collision are leaked. More importantly, the properties insider
and outsider collision-resistance guarantee that only someone
in possession of a secret key (trapdoor) whose attributes satisfy
the access policy used upon computing the hash is able to
perform editing.
VI. CONCLUSION
We tackle the problem of rewriting objects in blockchains
in a way, ﬂexible enough for real-world needs regarding
the granularity of who can perform such an operation. With
10
PPGenPCH(1κ) : On input security parameter κ run
1) Choose prime e1 s.t. e1 > N(cid:48) with N(cid:48) = maxr{(N, ·, ·, ·, ·) ← RSAKGen(1κ; r)}.
2) Run (N1, p1, q1, ·, ·) ← RSAKGen(1κ), choose a hash function H1 : {0, 1} → Z∗
skCHET ← (d1) pkCHET ← (κ, N1, e, H1).
3) Run (p, ˆe, G1, G2, GT , g1, g2) ← BilGen(1κ). Pick a1, a2, b1, b2 ←$ Z∗
{0, 1}∗ → (Zp)2, an encryption scheme (KGenSE, EncSE, DecSE), and set
. Compute d1 s.t. ed1 ≡ 1 mod (p1 − 1)(q1 − 1), set
p and w1, w2, w3 ←$ Zp, hash functions H3 : {0, 1}∗ → G1 and H4 :
N1
mpkABE ← (g2, q1 ← ga1
2 , q2 ← ga2
2 , T1 ← ˆe(g1, g2)w1a1+w3 , T2 ← ˆe(g1, g2)w2a2+w3 , H3, H4, (KGenSE, , EncSE, DecSE)), and
mskABE ← (a1, a2, b1, g2, gw1
1 , gw2
1 , gw3
1 )
and return skPCH ← (mskABE, skCHET) and pkPCH ← (mpkABE, pkCHET).
KGenPCH(skPCH, S) : On input skPCH = (mskABE, skCHET) and attribute set S, parse msk as (a1, a2, b1, g2, gw1
1 , gw2
1 , gw3
1 ), pick ρ1, ρ2 ←$ Zp and compute
For all s ∈ S and t = 1, 2 compute
sk0 = (sk0,1, sk0,2, sk0,3) ← (gb1ρ1
2
, gb2ρ2
2
, gρ1+ρ2
2
).
where σs ←$ Zp and set sks ← (sks,1, sks,2, g
−σs
1
). Moreover, for t = 1, 2 compute
sks,t ← H3(y(cid:107)1(cid:107)t)
b1ρ1
at
· H3(y(cid:107)2(cid:107)t)
b2ρ2
at
· H3(y(cid:107)3(cid:107)t)
ρ1+ρ2
at
· g
σs
at
1
,
where σ(cid:48) ←$ Zp and set sk(cid:48) ← (sk(cid:48)
). Set skS,ABE ← (sk0, {sks}s∈S, sk(cid:48)) and return (skCHET, skS,ABE).
HashPCH(pkPCH, m, M) : On input public key pk = (mpkABE, pkCHET), a message m and a matrix encoding M of access structure A, parse pkCHET =
· H3(011(cid:107)t)
b1ρ1
at
· H3(012(cid:107)t)
b2ρ2
at
· H3(013(cid:107)t)
ρ1+ρ2
at
σ(cid:48)
at
1 ,
· g
sk(cid:48)
t ← gwt
1 · g−σ(cid:48)
1, sk(cid:48)
2.gd3
1
1
(κ, N1, e, H1) and:
1) Run (N2, p2, q2, ·, ·) ← RSAKGen(1κ), ﬁx a hash function H2 : {0, 1} → Z∗
2) Choose r1 ←$ Z∗
, compute h1 ← H1((m, N1, H1, N2, H2))re
and r(cid:48) ← (r1, r2).
3) Choose r ←$ {0, 1}κ, k ←$ KGenSE(1κ) compute (u1, u2) ← H4((r, A)) and ct0 ← (qu1
then for i ∈ [(cid:96)] and z = 1, 2, 3 compute
, r2 ←$ Z∗
N2
N1
. Compute d2 s.t. ed2 ≡ 1 mod (p2 − 1)(q2 − 1).
1 mod N and h2 ← H2((m, N1, H1, N2, H2))re
N2
2. set h(cid:48) ← (h1, h2)
1 , qu2
2 , gu1+u2
2
). Assuming M has (cid:96) rows and k columns,
cti,z ← H3(π(i)(cid:107)z(cid:107)1)u1 · H3(π(i)(cid:107)z(cid:107)2)u2 · k(cid:89)
(cid:2)H3(0(cid:107)j(cid:107)z(cid:107)1)u1 · H3(0(cid:107)j(cid:107)z(cid:107)2)u2(cid:3)(M)i,j .
Set cti ← (cti,1, cti,2, cti,3), K ← encode(k, r), compute ˆct ← T u1
· K, ˜ct ←$ EncSE(k, d2), and set ct ← (ct0, ct1, . . . , ct(cid:96), ˆct, ˜ct).
VerifyPCH(pkPCH, m, h, r) : On input public parameters pk = (mpkABE, pkCHET), message m, hash value h = (h(cid:48), N2, H2, ct), and randomness r =
1 mod N1 and
AdaptPCH(skS, m, m(cid:48), h, r) : On input skS = (skCHET, skS,ABE) messages m and m(cid:48), hash value h = (h(cid:48), N2, H2, ct) and randomness r = (r1, r2) and
Return (h, r) ← ((h(cid:48), N2, H2, ct), r(cid:48)).
(r1, r2), parse pkCHET = (κ, N1, e, H1), verify whether r1 ∈ Z∗
h2 = H2((m, N1, H1, N2, H2))re
assuming that S satisﬁes the access policy A used for encryption and associated to the hash (otherwise return ⊥), parse skCHET = (d1) and:
1) Compute coefﬁcients {λi}π(i)∈S for the MSP (M, π) associated to A as discussed in Section 2, compute
2 mod N2. If all checks hold, return 1 and 0 otherwise.
, and whether h1 = H1((m, N1, H1, N2, H2))re
, r2 ∈ Z∗
N1
N2
(cid:89)
i∈I
(cid:89)
A ← ˆct · ˆe(
i,1, sk0,1) · ˆe(
ctλi
B ← ˆe(sk(cid:48)
π(i),1, ct0,1) · ˆe(sk(cid:48)
skλi
1 ·(cid:89)
i∈I
i,3, sk0,3),
i,2, sk0,2) · ˆe(
ctλi
i∈I
π(i),2, ct0,2) · ˆe(sk(cid:48)
skλi
ctλi
3 ·(cid:89)
i∈I
skλi
π(i),3, ct0,3),
j=1
· T u2
2
1
(cid:89)
2 ·(cid:89)
i∈I
i∈I
2) Compute (u(cid:48)
K(cid:48) ← A · B−1 and set (k(cid:48), r(cid:48)) ← encode−1(K(cid:48)).
u(cid:48)
1 , q
1 · H3(π(i)(cid:107)z(cid:107)2)u(cid:48)
i,z ← H3(π(i)(cid:107)z(cid:107)1)u(cid:48)
ct(cid:48)
2) ← H4((r(cid:48), A)) and ct(cid:48)
0 ← (q
u(cid:48)
1+u(cid:48)
2
u(cid:48)
2 , g
1, u(cid:48)
1
2
2
). Assuming M has (cid:96) rows and k columns, then for i ∈ [(cid:96)] and z = 1, 2, 3 compute
2 · k(cid:89)
(cid:2)H3(0(cid:107)j(cid:107)z(cid:107)1)u(cid:48)
j=1
1 · H3(0(cid:107)j(cid:107)z(cid:107)2)u(cid:48)
2(cid:3)(M)i,j .
u(cid:48)
2
u(cid:48)
1
1
(cid:48) ← T
i ← (ct(cid:48)
i,3), compute ˆct
3) Check if h1 = H1((m, N1, H1, N2, H2))re
i,2, ct(cid:48)
) and return ⊥ if d(cid:48)
Set ct(cid:48)
i,1, ct(cid:48)