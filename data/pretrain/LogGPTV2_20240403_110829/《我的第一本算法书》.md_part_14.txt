统称为‘公钥基础设施”（Public Key Infrastructure，PKI）。
网站本身内容的服务器是由同一个组织来管理的。
信息相对应，而服务器证书与域名信息相对应。因此，我们还可以确认网站域名和存储
网站未被第三者冒充。
信中同样也要用到数字证书。只要能收到来自网站的含有公开密钥的证书，就能确认该
运转。因此根认证中心多为大型企业，或者与政府关联且已经取得了社会信赖的组织。
根认证中心自身进行证明的证书为“根证书”。如果根认证中心不被信任，整个组织就无法
通过大型组织对小组织的信赖担保，树结构就建立了起来。
检测。只要A发行了证书，公司 B就可以向社会表示自己获得了公司A的信任。于是，
法得到社会的认可。
证中心A。此时出现了一个刚成立的公司B，虽然B想要开展认证中心的业务，但它无
数字证书就是像这样通过认证中心来担保公开密钥的制作者。这一系列技术规范被
此处的证书叫作“服务器证书”，同样由认证中心发行。个人的证书会与他的邮箱
到目前为止，我们了解的都是个人之间交付公开密钥的例子，其实在网站之间的通
补充说明
于是B向 A申请发行数字证书。当然A会对B 能否开展认证中心业务进行适当的
最顶端的认证中心被称为“根认证中心”（root CA)，其自身的正当性由自己证明。对
CA
---
## Page 178
第
聚类
9
章
---
## Page 179
166
聚类
第6章
No.
文、数学、英语成绩数据化，并将他们按照“擅长或不擅长的科目相似”进行聚类。
据之间的“差距”进行定义。首先来看下面的示例。
》定义数据间的差距
■如何定义“相似”
类相似的数据。也就是说，这些数据被分为了3个簇。
“簇”。下面的示例中每个点都代表1个数据，在平面上位置较为相近、被圈起来的点就代表一
■将相似的对象分为一组
6-1
 假设某所高中的某个年级中共有 400 名学生，现在我们想要将这些学生在考试中取得的语
根据数据类型不同，
聚类就是在输入为多个数据时，将“相似”的数据分为一组的操作。1个组就叫作1个
定义该数据是否“相似”的标准也不同。具体来说，就是要对两个数
什么是聚类
---
## Page 180
数据按要求分为k个簇。
聚类算法供我们选择。
“簇的数量”，并根据教室的面积确定“每个簇内的数据量”。现在有很多种可以满足各类条件的
间的最大距离设为10，等等。而设定什么样的条件取决于进行聚类的目的。
比如想把数据分为10个簇，或者想把1个簇内的数据定在 30~50人之间，再或者想把簇内数据
符合条件的算法
就互为“相似的数据”。
据（c,m,e,）和（C2, m2,é2）之间的差距定义为(C-c2)²+(m,-m2)+(e-e2)²，其中差距小的数据
下一节就将介绍其中最基本，也是最有代表性的聚类算法“k-means 算法”。该算法可以把
假如是为了开办暑期补习班而对学生进行分班，那么就要根据老师和教室的数量来确定
即使定义好了数据间的差距，聚类的方法也会有很多种。我们可以设定各种各样的条件
把每个学生都转换成“语文成绩，数学成绩，英语成绩）”形式的数据后，就可以将两个数
29
什么是聚类
9
---
## Page 181
68
聚类
第6章
No
据，用两点间的直线距离表示数据间的差距。
本例中我们将簇的数量定为3。此处用点表示数
首先准备好需要聚类的数据，然后决定簇的数量。
9
k-means 算法是聚类算法中的一种，它可以根据事先给定的簇的数量进行聚类。
k-means算法
图灵社区会员夏科(PI:EMAIL)专享尊重版权
中心点。
该数据最近的
个数据和距离
色的线连接名
此处用不同颜
随机选择3个点作为簇的中心点。
各
距离最近。
个中心点中的哪一个点
计算各个数据分别和3
---
## Page 182
重新计算距离最近的簇的中心点，并将数据分到相应的簇中，
计算各个簇中数据的重心，然后将簇的中心点移动到这个位置。
将数据分到相应的簇中。这样，3个簇的聚类就完成了
中心点”也会改变。
数据的“距离自己最近的
随着中心点的移动，部分
６9
k-means 算法
612
---
## Page 183
04
聚类
第6章
类也就完成了。
4轮操作结束后，结果如上图所示。即使继续重复操作，中心点也不会再发生变化，操作到此结束，聚
再发生变化为止。
点移到重心的位置”这两个操作，直到中心点不
重复执行“将数据分到相应的簇中”和“将中心
3轮操作结束后，
地分为一组了。
似的数据已经被恰当
此时我们可以确定，相
结果如上图所示。
---
## Page 184
这样的聚类结果。
适的数量，或者不断改变簇的数量来试验 k-means 算法。
的需求。
要事先确定好簇的数量，所以设定的数量如果不合理，运行的结果就可能会不符合我们
那么聚类将如下图所示。
已经在数学层面上得到证明。
另外，如果簇的数量同样为2，但中心点最初的位置不同，那么也可能会出现下图
如果对簇的数量没有明确要求，那么我们可以事先对数据进行分析，推算出一个合
前面的例子中我们将簇的数量定为3，若现在使用同样的数据，将簇的数量定为2,
解说
位于左边和下边的两个数据块被分到了一个簇中。就像这样，由于k-means 算法需
k-means 算法中，随着操作的不断重复，中心点的位置必定会在某处收敛，这一点
8
：.
k-means算法
６１２
---
## Page 185
聚类
72
第6章
根据定义方法不同，会有“最短距离法”“最长距离法”“中间距离法”等多种算法。
个阶段的簇的数量都不同，对应的聚类结果也不同。只要选择其中最为合理的1个结果
簇就会减少1个。执行n-1次后，所有数据就都被分到了一个簇中。在这个过程中，每
n 个簇。然后重复执行“将距离最近的两个簇合并为一个”的操作 n-1次。每执行1次,
k-means 算法不同，层次聚类算法不需要事先设定簇的数量。
补充说明
就好。
最合适的聚类结果。
因此，我们可以通过改变随机设定的中心点位置来不断尝试 k-means 算法，再从中选择
即使簇的数量相同，只要随机设置的中心点最初的位置不同，聚类的结果也会产生变化。
合并簇的时候，为了找出“距离最近的两个簇”，需要先对簇之间的距离进行定义。
在层次聚类算法中，一开始每个数据都自成一类。也就是说，有n个数据就会形成
除了k-means 算法以外，聚类算法还有很多，其中“层次聚类算法”较为有名。与
与之前的情况不同，这次右上和右下的两个数据块被分到了一个簇中。也就是说
---
## Page 186
第
其他算法
章
---
## Page 187
74
其他算法
第7章
No.
里得的著作中，因此得以命名。
算法。现在人们已无法确定该算法具体的提出时间，但其最早被发现记载于公元前 300 年欧几
能更高效地求解最大公约数。
1112和695的最大公约数为139。然而两个数字越大，因式分解就越难。此时，使用欧几里得算法就
通常的做法是先对两个数字因式分解，找出共同的素数，然后求出最大公约数（GCD）。这样就能求出
在学习欧几里得算法之前，我们先来看一看数字1112和695的最大公约数是多少吧。
欧几里得算法（又称辗转相除法）用于计算两个数的最大公约数，被称为世界上最古老的
1112=139×2×2×2
695 =139×5
欧几里得算法
1112
139.GCD
695
---
## Page 188
运算，结果为139。
继续重复同样的操作，对417和278进行mod
除完后的余数为417。
作流程吧。
那么，我们就来看一看欧几里得算法的具体操
3
417mod278=
695mod 417
1112 mod695=417
1112 mod 695
1112
二
=417
695
139
278
是说，278可以被139整除。
对278和139进行mod运算，结果为0。也就
算。结果为278。
接下来再用除数695和余数417进行mod运
06
就是算出A除以B后的余数C。
第5章也讲过mod运算即取余运算，A mod B
数。也就是对两个数字进行mod运算。我们在
首先用较小的数字去除较大的数字，求出余
O
8
278mod139
417mod278
695 mod 417
1112 mod 695
695 mod 417
1112 mod 695
1112 mod 695
二
二
=278
二
139
417
417
278
0
欧几里得算法
---
## Page 189
176
其他算法
第7章
这里和前面的运算一样，用小的数去除大的数，得到的余数为417。
2
解，在1112上画出8个刻度，在695上画出5个刻度。
将最大公约数设为n，然后在直线上画出相应刻度。由于我们已知最大公约数为139，所以为了方便理
1112和695的最大公约数。
余数为0时，最后一次运算中的除数139就是
278mod 139
417mod278=
695mod 417
1112 mod 695
139
…GCD
n{
1112
+
417
图灵社区会员夏科（PI:EMAIL）专享尊重版权
+
二
139
278
417
695
一
HHHHH
695
HHHHH
度划分。
好也可以用长度为 n 的刻
从这张图就能看出,417正
定是最大公约数n的整数倍。
但是可以确定1112和695一
线可以被划分为多少个刻度，
实际上我们并不知道两条直
呢？我们结合图片来想一想。
为什么用欧几里得算法可以求得最大公约数
1112
表示 1112 和 695。
分别用相应长度的直线来
695
---
## Page 190
继续做除法。由于278可以被139整除，所
继续重复mod运算。用417去除695，得到余数278。
13
在于即使两个数字再大，只要按照步骤进行操作就能高效地求得两者的最大公约数。
解说
使用欧几里得算法，
139
图灵社区会员夏科(PI:EMAIL）专享尊重版权
，只需重复做除法便能求得最大公约数。这个算法最大的优势就
278
王
TTH
整数倍。
余数 278 同样也是 n的
余数为0。此时便能求得最大公约数n为139。
15
13
一
77
欧几里得算法
---
## Page 191
78
其他算法
第7章
No.
参考：5-5公开密钥加密
泛应用的 RSA 算法就会用到大素数，因此“素性测试”在该算法中起到了重要的作用。
身整除，且大于1的自然数。素数从小到大有2、3、5、7、11、13-.目前在加密技术中被广
常大，这种方法就十分耗费时间。这种时候就可以用“费马测试”来解决这个问题。
根据mod运算的结果可知，3599 能被59整除。也就是说，3599并不是素数。但假如需要判断的数非
的数字。
整除。“整除”就是指mod运算的结果为0。由于3599的平方根为59.99…，所以只需要除以从2到59
我们来试着判断3599是否为素数吧。简单的方法便是将3599按顺序除以比2大的数字，看是否能被
02
素性测试是判断一个自然数是否为素数的测试。素数（prime number）就是只能被1 和其自
素性测试
3599 mod 59 = 0 
3599 mod 58=3 
3599 mod 3 = 2 
3599 mod 2
3599≠素数
3599
=1 
>
---
## Page 192
观察原本的数和余数，发现两者一致。
06
如上图所示。
对于比5小的数，分别计算它们的5次方，结果
我们先来学习基础知识一
04
费马测试被称为概率性素性测试，它判断的是“某个数是素数的概率大不大”。
O
3
2” (= 32)
3² (= 243)
5=素数
53
5=素数
=243
图灵社区会员夏科（PI:EMAIL）专享尊重版权
mod5='
mod 5= 2
mod5=
mod 5= 4
一素数的性质。首先来看一看素数5有什么样的性质。
3
费马测试
由此，可以推导出关于素数5，以上公式成立。
们除以5后的余数，结果如上图所示。
接下来，再对结果分别进行mod运算，求得它
O
1²(= 1)
2² (= 32)
3 (= 243)
5=素数
n mod 5 = n
n<5
5=素数
mod5=4
。在讲解费马测试之前，
mod 5 = 1
mod5=2
mod5=3
2
79
素性测试
---
## Page 193
180
其他算法
第7章
个数最后得到的余数都和原本的数相同，因此可以判断113是素数。
随机选择3个比113小的数作为n，计算这些数的113次方，再用113去除得到的结果，求出余数。3
法就是“费马测试”。
满足费马小定理来判断一个数是否为素数的方
都是成立的。这就是“费马小定理”。根据是否
实际上不只是5，对于任意素数p，上面的公式
08
时，就可以大致判断该数为素数。
（Miller-Rabin）素性测试”。用这个方法重复进行测试后，当数不是素数的概率小于0.580
余数之后就能判断该数是素数的可能性非常高，那么大致就可以判定该数是素数了。
如果每一个小于p的数都要去计算，就会非常耗费时间。实际上，如果确认了几组n和
比如在RSA算法中，用于素性测试的是根据费马测试改进而来的“米勒－拉宾
解说
确认n和余数一致的次数越多，
nmod p= n
n<p
p=素数
113= 素数(?)