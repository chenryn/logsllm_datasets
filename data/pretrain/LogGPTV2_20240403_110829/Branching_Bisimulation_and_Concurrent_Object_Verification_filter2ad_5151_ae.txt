!' &''
 
	
&!'!$((%  ""#)%!
Fig. 9. A divergence of the HW queue generated by CADP.
F. Automatic bug hunting
As indicated in Table II, we found two violations of lin-
earizability and lock-freedom. All the found counterexamples
are generated in case of just two or three threads. This shows
the potential of our approach as bug-hunting technique.
1) We encounter an violation of lock-freedom in the revised
Treiber stack of [10]. This revised version prevents the
ABA problem from the original Treiber stack but at the
expense of violating the wait-freedom of hazard pointers
in the original algorithm [24]. We found this bug by an
automatically generated counterexample of divergence-
sensitive branching bisimulation checking by CADP with
just two concurrent threads. The error-path ends in a self-
loop in which one thread keeps reading the same hazard
pointer value of another thread yielding this thread does
not make progress (The detail can be found in [33]).
275
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:24:37 UTC from IEEE Xplore.  Restrictions apply. 
VERIFYING LINEARIZABILITY AND LOCK-FREEDOM OF CONCURRENT QUEUES.
TABLE VI
ΘSP/≈ Δ∗/≈ Theorem 5.8 (lock-free) time (s)
DGLM Result
#Th.
#Op.
2
2
2
2
2
2
2
3
3
3
4
1
2
3
4
5
6
7
1
2
3
1
ΔMS
326
5477
49038
304049
1554292
7092627
30265728
10845
1496486
76157266
485872
ΔDGLM
291
4951
43221
261671
1310133
5881529
24789593
9488
1210014
55936348
415329
ΘSP
72
855
5810
30165
136334
571501
2300270
876
51986
1600195
10842
ΔAbs
106
1325
9426
50797
237044
1019763
4187822
1577
114815
4110621
25276
28
209
817
2471
6347
15041
33739
220
6152
62808
2040
28
209
863
2648
6765
15820
35021
220
7337
74551
2476
MS
0.27
0.46
0.70
2.12
9.41
45.23
210.9
0.49
9.35
613.34
3.32
0.26
0.43
0.88
2.17
9.05
39.88
188.27
0.41
7.98
410.91
3.22
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Result
DGLM
Theorem 5.3 (linearizablity) time (s)
MS
0.22
0.75
1.15
2.32
4.75
10.79
27.44
0.76
5.20
54.61
2.18
0.24
0.70
1.36
2.31
5.02
10.54
27.16
0.65
5.07
54.79
2.16
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
2) Our experiments conﬁrm the (known) bug in the HM
lock-free list [17] which was amended in the online errata
of [17]. The counterexample is generated by the trace
reﬁnement checking of the quotients of concrete object
and the speciﬁcation. It consecutively removes the same
item twice, which violates the speciﬁcation of the list.
G. Efﬁciency and state-space savings
Fig. 10 shows the overview of the generated state spaces of
11 concurrent data structures and their branching bisimulation
quotient systems, where the state-space (x and y-axis) is on
logarithmic scale. For the algorithms, we ﬁx the number of
threads to 2 and vary the number of operations a thread
can perform from 1 to 10. The results show that verifying
linearizability based on branching bisimulation quotient is very
efﬁcient. For most cases, we obtain a quotient system which
is 2 to 3 orders of magnitude (i.e., 100 to 1000 times) smaller
than the concrete objects. And in general, for the non-blocking
algorithms, the larger the system the higher the state space
reduction factor. The largest reductions are obtained for the
Treiber stack with hazard pointers (Treiber stack+HP) and the
MS lock-free queue yielding a quotient with 0.01% and 0.02%
of the size of the concrete objects, respectively.
VII. DISCUSSION ON WEAK BISIMULATION
We give a discussion about weak bisimulation [34]. Weak
bisimulation, denoted by ∼w, is obtained by replacing the
second clause of Deﬁnition 4.1 with:
1, s2) ∈ R, or there exists s
(cid:2)
(cid:2)
2
(cid:2)
1, then either (s
τ−−→ s
2. if s1
such that s2 ==⇒ τ−−→ s
(cid:2)
2 and (s
(cid:2)
1, s
2) ∈ R.
(cid:2)
Compared with branching bisimulation, weak bisimulation
does not require the intermediate states passed through to be
matched. Back to the MS queue example in Fig. 6, checking by
the CADP tool, it returns s1 ∼w s3, along with it s2 (cid:9)∼w s4 and
s2 ∼w s5. For branching bisimulation, the tool reports s1 (cid:9)≈ s3,
along with it s2 (cid:9)≈ s4 and s2 ≈ s5.
To explain the difference, consider, for instance, the tran-
sition s1 −−→ s2. In weak bisimulation, it can be matched by
s3 −−→ s4 −−→ s5, despite that s2 (cid:9)∼w s4. However, this is not
allowed in branching bisimulation because of s2 (cid:9)≈ s4.
Therefore, branching bisimulation better takes into account
the intermediate state that two equivalent states pass through,
while weak bisimulation lacks the feature and fails to perceive
the effect of linearization point s1 −−→ s3, which is an essential
internal transition for the entire system evolution. So the weak
bisimilar is not suitable for analyzing complicated executions.
Another feature of bisimulation is the equivalence checking.
For various concurrent data structures, we have checked the
equivalence relation ≈ and ∼w between the object system Δ
and the corresponding concurrent speciﬁcation Θsp respec-
tively. Experimental results in Table VII clearly indicate that,
for complex algorithms (e.g., the HSY stack [37]), there does
not exist the weak bisimulation equivalence (and also weak
bisimulation with explicit divergence) between the system Δ
and the speciﬁcation Θsp that is speciﬁed by one atomic block.
Δ
MS
TABLE VII
DGLM
Object
CHECKING Δ ≈ ΘSP AND Δ ∼W ΘSP FOR VARIOUS ALGORITHMS.
≈
No
No
No
No
No
No
Yes
No
Θsp/≈ ∼w
No
6347
No
6347
No
6152
No
11567
11567
No
No
166
Yes
234
5932
No
Θsp
136334
136334
51986
15357
15357
822
487
12341
Δ/≈
6765
6765
4018
12422
15368
195
234
11496
155492
1310133
89483
472664
1311915
HW
HM
Lazy
CCAS
Treiber
HSY
2-5
2-5
3-2
3-2
3-2
4-1
2-2
3-2
246761798
1688
823
VIII. RELATED WORK
Concurrent object veriﬁcation including verifying lineariz-
ability and lock-freedom has been intensively investigated in
the literature. We only discuss the most relevant work.
A plethora of proof-based techniques has been developed