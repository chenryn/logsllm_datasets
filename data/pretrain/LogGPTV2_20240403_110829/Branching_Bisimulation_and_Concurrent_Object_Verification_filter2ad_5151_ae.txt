!' &''
 
	
&!'!$((%  ""#)%!
Fig. 9. A divergence of the HW queue generated by CADP.
F. Automatic bug hunting
As indicated in Table II, we found two violations of lin-
earizability and lock-freedom. All the found counterexamples
are generated in case of just two or three threads. This shows
the potential of our approach as bug-hunting technique.
1) We encounter an violation of lock-freedom in the revised
Treiber stack of [10]. This revised version prevents the
ABA problem from the original Treiber stack but at the
expense of violating the wait-freedom of hazard pointers
in the original algorithm [24]. We found this bug by an
automatically generated counterexample of divergence-
sensitive branching bisimulation checking by CADP with
just two concurrent threads. The error-path ends in a self-
loop in which one thread keeps reading the same hazard
pointer value of another thread yielding this thread does
not make progress (The detail can be found in [33]).
275
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:24:37 UTC from IEEE Xplore.  Restrictions apply. 
VERIFYING LINEARIZABILITY AND LOCK-FREEDOM OF CONCURRENT QUEUES.
TABLE VI
Î˜SP/â‰ˆ Î”âˆ—/â‰ˆ Theorem 5.8 (lock-free) time (s)
DGLM Result
#Th.
#Op.
2
2
2
2
2
2
2
3
3
3
4
1
2
3
4
5
6
7
1
2
3
1
Î”MS
326
5477
49038
304049
1554292
7092627
30265728
10845
1496486
76157266
485872
Î”DGLM
291
4951
43221
261671
1310133
5881529
24789593
9488
1210014
55936348
415329
Î˜SP
72
855
5810
30165
136334
571501
2300270
876
51986
1600195
10842
Î”Abs
106
1325
9426
50797
237044
1019763
4187822
1577
114815
4110621
25276
28
209
817
2471
6347
15041
33739
220
6152
62808
2040
28
209
863
2648
6765
15820
35021
220
7337
74551
2476
MS
0.27
0.46
0.70
2.12
9.41
45.23
210.9
0.49
9.35
613.34
3.32
0.26
0.43
0.88
2.17
9.05
39.88
188.27
0.41
7.98
410.91
3.22
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Result
DGLM
Theorem 5.3 (linearizablity) time (s)
MS
0.22
0.75
1.15
2.32
4.75
10.79
27.44
0.76
5.20
54.61
2.18
0.24
0.70
1.36
2.31
5.02
10.54
27.16
0.65
5.07
54.79
2.16
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
2) Our experiments conï¬rm the (known) bug in the HM
lock-free list [17] which was amended in the online errata
of [17]. The counterexample is generated by the trace
reï¬nement checking of the quotients of concrete object
and the speciï¬cation. It consecutively removes the same
item twice, which violates the speciï¬cation of the list.
G. Efï¬ciency and state-space savings
Fig. 10 shows the overview of the generated state spaces of
11 concurrent data structures and their branching bisimulation
quotient systems, where the state-space (x and y-axis) is on
logarithmic scale. For the algorithms, we ï¬x the number of
threads to 2 and vary the number of operations a thread
can perform from 1 to 10. The results show that verifying
linearizability based on branching bisimulation quotient is very
efï¬cient. For most cases, we obtain a quotient system which
is 2 to 3 orders of magnitude (i.e., 100 to 1000 times) smaller
than the concrete objects. And in general, for the non-blocking
algorithms, the larger the system the higher the state space
reduction factor. The largest reductions are obtained for the
Treiber stack with hazard pointers (Treiber stack+HP) and the
MS lock-free queue yielding a quotient with 0.01% and 0.02%
of the size of the concrete objects, respectively.
VII. DISCUSSION ON WEAK BISIMULATION
We give a discussion about weak bisimulation [34]. Weak
bisimulation, denoted by âˆ¼w, is obtained by replacing the
second clause of Deï¬nition 4.1 with:
1, s2) âˆˆ R, or there exists s
(cid:2)
(cid:2)
2
(cid:2)
1, then either (s
Ï„âˆ’âˆ’â†’ s
2. if s1
such that s2 ==â‡’ Ï„âˆ’âˆ’â†’ s
(cid:2)
2 and (s
(cid:2)
1, s
2) âˆˆ R.
(cid:2)
Compared with branching bisimulation, weak bisimulation
does not require the intermediate states passed through to be
matched. Back to the MS queue example in Fig. 6, checking by
the CADP tool, it returns s1 âˆ¼w s3, along with it s2 (cid:9)âˆ¼w s4 and
s2 âˆ¼w s5. For branching bisimulation, the tool reports s1 (cid:9)â‰ˆ s3,
along with it s2 (cid:9)â‰ˆ s4 and s2 â‰ˆ s5.
To explain the difference, consider, for instance, the tran-
sition s1 âˆ’âˆ’â†’ s2. In weak bisimulation, it can be matched by
s3 âˆ’âˆ’â†’ s4 âˆ’âˆ’â†’ s5, despite that s2 (cid:9)âˆ¼w s4. However, this is not
allowed in branching bisimulation because of s2 (cid:9)â‰ˆ s4.
Therefore, branching bisimulation better takes into account
the intermediate state that two equivalent states pass through,
while weak bisimulation lacks the feature and fails to perceive
the effect of linearization point s1 âˆ’âˆ’â†’ s3, which is an essential
internal transition for the entire system evolution. So the weak
bisimilar is not suitable for analyzing complicated executions.
Another feature of bisimulation is the equivalence checking.
For various concurrent data structures, we have checked the
equivalence relation â‰ˆ and âˆ¼w between the object system Î”
and the corresponding concurrent speciï¬cation Î˜sp respec-
tively. Experimental results in Table VII clearly indicate that,
for complex algorithms (e.g., the HSY stack [37]), there does
not exist the weak bisimulation equivalence (and also weak
bisimulation with explicit divergence) between the system Î”
and the speciï¬cation Î˜sp that is speciï¬ed by one atomic block.
Î”
MS
TABLE VII
DGLM
Object
CHECKING Î” â‰ˆ Î˜SP AND Î” âˆ¼W Î˜SP FOR VARIOUS ALGORITHMS.
â‰ˆ
No
No
No
No
No
No
Yes
No
Î˜sp/â‰ˆ âˆ¼w
No
6347
No
6347
No
6152
No
11567
11567
No
No
166
Yes
234
5932
No
Î˜sp
136334
136334
51986
15357
15357
822
487
12341
Î”/â‰ˆ
6765
6765
4018
12422
15368
195
234
11496
155492
1310133
89483
472664
1311915
HW
HM
Lazy
CCAS
Treiber
HSY
2-5
2-5
3-2
3-2
3-2
4-1
2-2
3-2
246761798
1688
823
VIII. RELATED WORK
Concurrent object veriï¬cation including verifying lineariz-
ability and lock-freedom has been intensively investigated in
the literature. We only discuss the most relevant work.
A plethora of proof-based techniques has been developed