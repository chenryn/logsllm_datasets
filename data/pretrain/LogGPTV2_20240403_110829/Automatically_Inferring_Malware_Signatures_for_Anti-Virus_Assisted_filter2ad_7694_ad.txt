### Signatures Derived from 200 PHP Scripts

Table 4 summarizes the signatures derived from 200 PHP scripts, categorized by the character sets used: ASCII (\x01-\x7F), Printable-1 (all printable ASCII characters), Printable-2 (\x20-\x7F), Printable-3 (Printable-2 excluding '=' and ';'), and Printable-4 (Printable-2 excluding slashes and ':'). Sets marked with * have been used for attacks.

Similar to shellcodes in network attacks, useful malicious markers need to consist of certain bytes to pass input validation of common network protocols and end-user applications. In these scenarios, ASCII or printable characters are especially promising. We analyzed 200 PHP files from VirusTotal that were detected by all five virus scanners. Depending on the applied virus scanner, the samples correspond to 28–37 malware families. For each family, we derived signatures and inspected their suitability for use as malicious markers.

Although we are only operating on 30 to 40 different signatures, we are able to find suitable malicious markers for all virus scanners and character sets. The actual effort for an adversary to find suitable markers for a given application is thus considered relatively low.

### No Logs, No Crime

Similar to the empirical study presented earlier, we begin by considering the open-source scanner ClamAV as an attack target. Our goal is to remove traces of password guessing, for example, over SSH, POP3, or IMAP. Linux and other UNIX systems keep track of failed login attempts in a log file, often called `auth.log`, as shown in Figure 10. Note that the username, which is controlled by the attacker, is stored in clear text in the log file. It turns out that a large range of printable characters (Printable-4) can be used as a username and is written verbatim to the file.

As a consequence, an attacker may finish each iteration over a list of guessed passwords with a set of malicious markers, i.e., specially crafted login names that correspond to anti-virus signatures. If the attacked host is running a virus scanner configured to delete or quarantine viruses, any file containing such a malicious marker is deleted or at least moved to a different location. This not only makes manual investigation of the attack difficult but may also inhibit the functionality of tools analyzing log files to stop password guessing, such as fail2ban [26].

Figure 9 exemplarily shows a signature used by ClamAV that is accepted as a login name and allows tagging the authentication log as malicious. Once the SSH daemon writes the malicious marker to `auth.log`, ClamAV steps in to remove the file and destroys all evidence of the previously attempted attack. With the same technique, any log file that stores received network data in clear text can be deleted. Other imaginable targets include log files of web, name, and database servers that record requests and queries verbatim.

```php
if(function_exists('exec'))@exec(if(function_exists('shell_exec'))@shell_exec(if(function_exists('system'))@system(if(function_exists('passthru'))@passthru(
```

**Figure 9: ClamAV signature labeled PHP.ShellExec**

### Deletion of Emails

With a slight twist, malicious markers can also be used to obstruct the delivery of emails. To illustrate this setting, we consider the commercial anti-virus product AV2 operated on Windows. As a target, we choose Mozilla Thunderbird, which stores the user’s emails in a variation of the mbox format family [5]. While attachments and binary data are encoded, the email body is stored verbatim in this format. This enables an attacker to smuggle in malicious markers by sending crafted emails. The adversary is free to use any ASCII-encoded characters, including non-printable, but excluding ASCII extensions and the NUL-character (Printable-1). Figure 11 shows a suitable candidate for AV2 that can be used as an implant in this setting.

It suffices that the attacker delivers a single email to the victim to trigger quarantining or deleting the inbox database. The crafted email does not even need to look suspicious, as the attacker may use ASCII control characters, such as `\f` (NP form feed, new page) or a sequence of newline characters or whitespaces, to hide the malicious marker from being displayed in clear sight in Mozilla Thunderbird and other mail clients. Note that it is not possible to simply use a complete malware binary for this attack as it likely contains non-printable characters and thus is incorrectly stored in the email database. Moreover, chances are high that the malware binary would be filtered out by the email gateway already, whereas the malicious marker most probably would not. We discuss this in more detail in Section 6.

```php
="s"+"p"+"l"+"i"+"t";
```

**Figure 11: AV2 signature labeled JS:Decode-BHU [Trj]**

### Removing Browser Cookies

The presented attack vector can also be adapted to assist in web-based attacks. In this scenario, our goal is to force a user to re-login into a web application and thereby enable tampering with the authentication process. For this setting, we use Google Chrome as the target application and consider AV5 as our partner in crime. Google Chrome stores its cookies in a simple SQLite3 database called `User Data\Default\Cookies`. Interestingly, while the actual value of the cookie is strictly encoded when stored in this database, the name of the cookie is not: A cookie name may hence consist of any printable character in the range from \x20 to \x7E, except for semicolons and the equality sign (Printable-3).

An attacker may hence simply provide a specially crafted cookie, with the malicious marker as its name, on a website and lure its victim into visiting it (no evolved web-based attack, e.g., MITM, needed). On access to the webpage, the anti-virus product blocks access to the cookie database, thereby forcing the user to re-authenticate with certain web applications. Figure 12 exemplarily shows a signature used by AV5 that meets the mentioned criteria of allowed characters.

The same attack vector can be used to tamper with any data that contains user-controlled information and is stored in files by the browser. Mozilla Firefox, for instance, also stores HTML5 local storage objects in a SQLite database and thus is also a suitable target for malicious markers in web-based communication.

```php
\x65\x76\x61\x6C\x28\x67\x7A\x69\x6E\x66\x6C\x61\x74\x65
\x28\x62\x61\x73\x65\x36\x34\x5F\x64\x65\x63\x6F\x64\x65
\x28'7X1re9s2z/Dn9VcwmjfZq+PYTtu7s2MnaQ7t2jTpcugp6ePJsmx
rkS1PkuNkWf77C4CkREqy43S
(a) Originally as matched by AV5
eval(gzinflate(base64_decode('7X1re9s2z/Dn9VcwmjfZq+PYTt
u72MnaQ7t2jTpcugp6ePJsmxrkS1PkuNkWf77C4CkREqy43S
(b) Same signature with resolved encoding.
```

**Figure 12: AV5 signature labeled Backdoor.PHP.ASQ**

### Mitigations

To make any attack using malicious markers ineffective, one could obstruct direct access to the stored content, though this comes at the cost of usability. A less effective but more practical variant might be to simply encode or compress the stored content, which definitely raises the bar for the attacker but does not rule out malicious markers in general, as AV products occasionally also match encoded or compressed artifacts, as illustrated in Figure 12.

### Improving Anti-Virus Products

A prerequisite for the success of malicious markers is the interplay with an anti-virus product operated on a victim’s system. Hence, there exist different options for countering the attacks by adapting anti-virus products. Quick and easy solutions are, for example, the blacklisting of files for quarantining and the binding of signatures to certain file types.

In the long run, a more effective approach is to eliminate the feasibility of implanting signatures: This, however, requires pattern-based signatures to also account for the semantics and context of malicious code. It is not sufficient to simply spot the appearance of a pattern, but rather ensure that it is correctly embedded in the context of malicious code—a challenging yet necessary task to improve anti-virus products.

### Limitations

The presented malicious markers can be mitigated at different stages of the attack path, ranging from the network transmission to the affected applications and exploited anti-virus products. Anti-virus assisted attacks using malicious markers target a specific albeit widespread type of signatures. Naturally, this approach is subject to limitations, which we discuss in the following.

#### Network-Based Mitigation

The transmission of implants can be effectively blocked if the same signatures that are used on client systems are also deployed on a network gateway, for example, as part of an intrusion detection system. In this setting, tampered cookies, emails, and logins can be filtered out before reaching the client systems. This requires all security products on the host and network level to originate from the same vendor, as signatures are usually not shared among vendors. However, reliably enforcing such a homogeneous network setup is difficult and might even be impossible in some scenarios.

#### Application-Based Mitigation

The presented attack exploits the fact that several applications write data retrieved over the network verbatim to a single file. A simple defense strategy is thus to isolate content originating from different senders. For example, Microsoft Edge stores cookies in separate files rather than in a common database, while Apple Mail writes each received email to an individual file. In some settings, however, it is not feasible to separate content or determine its origin. For example, storing each entry of an authentication log in a separate file is far from being a practical solution.

An alternative strategy is to encrypt retrieved data with a local key before storing it to a file. This encryption renders the data unreadable to the virus scanner, making it difficult for the attacker to inject malicious markers.

#### Heuristics and Dynamic Execution

As already stated in Section 3, we do not consider any detection mechanisms based on heuristics. In particular, this includes all signature matching approaches that are based on the results of dynamic execution or unpacking. Although the underlying matching techniques might be similar but applied to execution logs or memory dumps, we do not consider the underlying patterns for our attacks. Note that injecting patterns from dynamic execution, such as sequences of system calls, into a benign process is a difficult problem and beyond the scope of this work.

#### Alternative Signatures

In practice, virus scanners often use different signatures for the same malware family, such as W32.Virut.a and W32.Virut.b. However, it is also possible that multiple signatures map to the same label. Effectively, this can be thought of as a disjunction of signatures. If these individual signatures match in different malware samples, we are able to derive the disjunction correctly. However, a problem arises whenever several of such signatures occur in the same file. If these are disjoint, our method is not able to derive any of them, since whenever the byte sequence corresponding to one signature is altered, another signature triggers an alarm. If they do overlap, we are able to at least derive the intersection of all occurring signatures.

#### Repetitive Byte-Sequences

We run into a similar problem whenever one signature matches a sequence of bytes multiple times within a file. For example, if we consider a file that contains the same signature twice, one signature always matches if we apply our derivation algorithm, as we only flip single bytes during the derivation. Consequently, it is not possible for our approach to reveal the used signature in this case. Our empirical study, however, shows that such cases are rare, and we are able to retrieve byte patterns for a third of the considered signatures.

### Related Work

The analysis and detection of malware is a very active area of research both in academia and industry. Implementations of such systems are under high scrutiny, subject to security audits, and are targets of adversarial attacks. Due to the widespread use of signature-based detection in commercial products, a significant body of research has particularly studied the merits and deficiencies of these systems. In the following, we discuss each of these related strains of research in detail.

#### Attacking Anti-Virus Products

Many researchers have dealt with vulnerabilities in anti-virus products and point out implementation flaws that allow bypassing defensive mechanisms or hijacking execution [2, 29, 42, 64]. Over the past year, Ormandy, for instance, called attention to several flaws in widespread commercial security products [43–47], demonstrating the large attack surface such systems expose. Our method, in contrast, does not rely on implementation flaws but addresses a conceptual issue in the use of poorly designed signatures.

Similar in spirit, Min and Varadharajan [35] make use of anti-virus products as an ally for attacks and introduce "AV-Parmware," an advanced malware piggybacking virus scanners. In particular, the device driver of the virus scanner is tricked into starting the malicious code on every boot and ensures stealthy operation by providing the malware with the same high privileges as itself. "AVLeak" [6], on the other hand, also employs repeated scans of AV products but uses the results to carefully leak fingerprints of used emulators.

#### Evasion of Detection

Exploits in anti-virus products can also be used to bypass detection. However, the underlying programming logic of file format parsers, unpackers, or search algorithms might also be used to evade detection. Jana and Shmatikov [25], for instance, describe two classes of bypasses: Chameleon attacks where a malware sample appears as a different type than it actually is, and werewolf attacks that exploit differences in parsing logic of specific file types. Both are based on a difference in "perception" between the product at the end-host and the virus scanner.

A popular example in this context is the Portable Document Format (PDF): The Adobe Reader is so liberal in processing malformed documents that it is difficult to exactly reproduce its behavior in a security product [49, 63]. If a virus scanner's type-inference fails, there is often no alternative but reverting to static pattern-based signatures.

Moreover, methods for evading signature-based detection have been proposed and studied in various contexts [e.g., 18, 36, 52, 53, 65]. In mobile security research, for instance, Zheng et al. [65] assess the robustness of virus scanners for mobile malware against simple transformations. Continuing this line of research, DroidChameleon [52] implements more advanced transformations, showing that in 2013, ten commercial Android anti-malware products can be bypassed using common obfuscation techniques. In a follow-up work, the authors additionally show that even one year later, these systems can still be bypassed with the same techniques [53].

#### Deriving Signatures

In intrusion detection, testing signatures has received substantial attention [30, 38, 55, 56, 60]. Some authors attempt to manually [38] and automatically [30] derive signatures from such systems. In contrast to our method, the latter inspects the execution of the matching process on a binary level, while we observe the outcome of the matching completely passively but strategically modify the input.

Deriving signatures from anti-virus software, on the contrary, has received very little attention so far. Christodorescu and Jha [9] explore possibilities for evaluating virus scanners and provide first insights into the feasibility of signature extraction. Filiol [15] extends this and defines a naive algorithm similar to the underlying idea described in this paper, and presents an extraction scheme to determine the signatures.