12
8
3
12
7
3
2
1
6
11
4
5
0
5
Table 4: Signatures derived from 200 PHP scripts partitioned by used characters sets: ASCII (\x01-\x7F),
Printable-1 (all printable ASCII characters), Printable-2 (\x20-\x7F), Printable-3 (Printable-2 excl. = and ;)
and Printable-4 (Printable-2 excl. slashes and :). Sets marked with * have been used for the attacks.
Similar to shellcodes in network attacks, useful malicious
markers need to consist of certain bytes to pass input valida-
tion of common network protocols and end-user applications.
In these scenarios ASCII or printable characters are especially
promising. We thus consider 200 PHP ﬁles from VirusTotal
that are detected by all ﬁve virus scanners. Depending on
the applied virus scanner the samples correspond to 28–37
malware families. For each family, we derive signatures and
inspect their suitability for the use as malicious markers.
Table 4 summarizes the diﬀerent categories of character sets.
Although we are only operating on 30 to 40 diﬀerent sig-
natures, we are able to ﬁnd suitable malicious markers for
all virus scanners and character sets. The actual eﬀort for
an adversary to ﬁnd suitable markers for a given application
thus has to be considered as being rather low.
No logs, no crime. Similar to the empirical study presented
earlier, we begin by considering the open-source scanner
ClamAV as an attack target. We aim at removing traces of
password guessing, for example, over SSH, POP3 or IMAP.
For this purpose, we exploit that Linux and other UNIX
systems keep track of failed login attempts in a log ﬁle, often
called auth.log as show in Figure 10. Note that the username
which is controlled by the attacker is stored in clear in the
log ﬁle. It turns out that a large range of printable characters
(Printable-4 ) can be used as username and is written verbatim
to the ﬁle.
As a consequence, an attacker may ﬁnish each iteration
over a list of guessed passwords with a set of malicious
markers, i.e., specially crafted login names that correspond
to anti-virus signatures. If the attacked host is running a
virus scanner conﬁgured to delete or quarantine viruses, any
ﬁle containing such a malicious marker is deleted or at least
moved to a diﬀerent location. This not only makes manual
investigation of the attack hard but may also inhibit the
functionality of tools analyzing log ﬁles to stop password
guessing, such as fail2ban [26].
Figure 9 exemplarily shows a signature used by ClamAV
that is accepted as login name and allows to tag the authen-
tication log as malicious. Once the SSH daemon writes the
malicious marker to auth.log ClamAV steps in to remove
the ﬁle and destroys all evidence of the previously attempted
attack. With the same technique any log ﬁle can be deleted
that stores received network data in clear. Other imaginable
targets are, for instance, log ﬁles of web, name and database
servers that record requests and queries verbatim.
if(function_exists(’exec’))@exec(if(function_exists(
’shell_exec’))@shell_exec(if(function_exists(’system’))
@system(if(function_exists(’passthru’))@passthru(
Figure 9: ClamAV signature labeled PHP.ShellExec
Deletion of emails. With a slight twist, malicious markers can
also be used to obstruct the delivery of emails. To illustrate
this setting, we consider the commercial anti-virus product
AV2 operated on Windows. As target we choose Mozilla
Thunderbird, which stores the user’s emails in a variation
of the mbox format family [5]. While attachments and bi-
nary data are encoded, the email body is stored verbatim
in this format. This enables an attacker to smuggle in
malicious markers by sending crafted emails. The adver-
sary is free to use any ASCII encoded characters, including
non-printable, but excluding ASCII extensions and the NUL-
character (Printable-1 ). Figure 11 shows a suitable candidate
for AV2 that can be used as implant in this setting.
It suﬃces that the attacker delivers a single email to the
victim to trigger quarantining or deleting the inbox database.
The crafted email does not even need to look suspicious, as
the attacker may use ASCII control characters, such as \f
(NP form feed, new page) or a sequence of newline characters
or whitespaces, to hide the malicious marker from being
displayed in clear sight in Mozilla Thunderbird and other
mail clients. Note that it is not possible to simply use a
complete malware binary for this attack as it likely contains
non-printable characters and thus is incorrectly stored in
the email database. Moreover, chances are high that the
malware binary would be ﬁltered out by the email gateway
already, whereby the malicious marker most probably would
not. We discuss this in more detail in Section 6.
=\"s\"+\"p\"+\"l\"+\"i\"+\"t\";
Figure 11: AV2 signature labeled JS:Decode-BHU [Trj]
Removing browser cookies. The presented attack vector can
also be adapted to assist in web-based attacks. In this sce-
nario our goal is to force a user to re-login into a web appli-
cation and thereby enable tampering with the authentication
process. For this setting, we use Google Chrome as the target
application and consider AV5 as our partner in crime. Google
Chrome stores its cookies in a simple SQLite3 database called
User Data\Default\Cookies. Interestingly, while the actual
value of the cookie is strictly encoded when stored in this
database, the name of the cookie is not: A cookie name may
hence consist out of any printable character in the range
from \x20 to \x7E, except for semicolons and the equality
sign (Printable-3 ).
An attacker may hence simply provide a specially crafted
cookie, with the malicious marker as its name, on a website
and lure its victim into visiting it (no evolved web-based
attack, e.g., MITM, needed). On access of the webpage
the anti-virus product blocks access to the cookie database,
thereby forcing the user to re-authenticate with certain web
594Feb 2 23:59:15 alice sshd[6126]: Invalid user mallory from 111.202.98.106
Feb 2 23:59:15 alice sshd[6126]: input_userauth_request: invalid user mallory [preauth]
Feb 2 23:59:17 alice sshd[6126]: pam_unix(sshd:auth): check pass; user unknown
Feb 2 23:59:17 alice sshd[6126]: pam_unix(sshd:auth): authentication failure;
logname= uid=0 euid=0 tty=ssh ruser= rhost=111.202.98.106
Feb 2 23:59:18 alice sshd[6126]: Failed password for invalid user mallory from 111.202.98.106 port 46447 ssh2
Feb 2 23:59:19 alice sshd[6126]: Connection closed by 111.202.98.106 [preauth]
Figure 10: Excerpt of Linux’s auth.log showing a failed attempt of mallory signing into a host called alice.
applications. Figure 12 exemplarily shows a signature used by
AV5 that meets the mentioned criteria of allowed characters.
The same attack vector can be used to tamper with any
data that contains user-controlled information and is stored
in ﬁles by the browser. Mozilla Firefox, for instance, also
stores HTML5 local storage objects in a SQLite database
and thus is also a suitable target for malicious markers in
web-based communication.
\x65\x76\x61\x6C\x28\x67\x7A\x69\x6E\x66\x6C\x61\x74\x65
\x28\x62\x61\x73\x65\x36\x34\x5F\x64\x65\x63\x6F\x64\x65
\x28’7X1re9s2z/Dn9VcwmjfZq+PYTtu7s2MnaQ7t2jTpcugp6ePJsmx
rkS1PkuNkWf77C4CkREqy43S
(a) Originally as matched by AV5
eval(gzinflate(base64_decode(’7X1re9s2z/Dn9VcwmjfZq+PYTt
u72MnaQ7t2jTpcugp6ePJsmxrkS1PkuNkWf77C4CkREqy43S
(b) Same signature with resolved encoding.
Figure 12: AV5 signature labeled Backdoor.PHP.ASQ
any attack using malicious marker ineﬀective, at the prize
of obstructing direct access to the stored content. A less
eﬀective but more practical variant might be to simply encode
or compress the stored content, which deﬁnitely raises the
bar for the attacker but does not rule out malicious markers
in general, as AV products occasionally also match encoded
or compressed artifacts as illustrated in Figure 12.
Improving anti-virus products. A prerequisite for the suc-
cess of malicious markers is the interplay with an anti-virus
product operated on a victim’s system. Hence, there exist
diﬀerent options for countering the attacks by adapting anti-
virus products. Quick and easy solutions are, for example,
the blacklisting of ﬁles for quarantining and the binding of
signatures to certain ﬁle types.
In the long run a more eﬀective approach is to eliminate the
feasibility of implanting signatures: This, however, requires
pattern-based signatures to also account for the semantics
and context of malicious code. It is not suﬃcient to simply
spot the appearance of a pattern, but rather ensure that it
is correctly embedded in the context of malicious code—a
challenging yet necessary task to improve anti-virus products.
6. MITIGATIONS
7. LIMITATIONS
The presented malicious markers can be mitigated on
diﬀerent stages of the attack path, ranging from the network
transmission to the aﬀected applications and exploited anti-
virus products.
Anti-virus assisted attacks using malicious markers target
a speciﬁc albeit wide-spread type of signatures. Naturally,
this approach is thus subject to limitations which we discuss
in the following.
Network-based mitigation. The transmission of implants can
be eﬀectively blocked, if the same signatures that are used
on client systems are also deployed on a network gateway,
for example as part of an intrusion detection system. In this
setting, tampered cookies, emails and logins can be ﬁltered
out before reaching the client systems. This requires all secu-
rity products on the host and network level to originate from
the same vendor, as signatures usually are not shared among
vendors. However, reliably enforcing such a homogeneous
network setup is diﬃcult and might even be impossible in
some scenarios.
Application-based mitigation. The presented attack exploits
the fact that several applications write data retrieved over the
network verbatim to a single ﬁle. A simple defense strategy
is thus to isolate content originating from diﬀerent senders.
For example, Microsoft Edge stores cookies in separate ﬁles
rather than in a common database, while Apple Mail writes
each received email to an individual ﬁle. In some settings,
however, it is not feasible to separate content or determine its
origin. For example, storing each entry of an authentication
log in a separate ﬁle is far from being a practical solution.
An alternative strategy is to encrypt retrieved data with a
local key before storing it to a ﬁle. This encryption renders
Heuristics and dynamic execution. As already stated in Sec-
tion 3, we do not consider any detection mechanisms based on
heuristics. In particular, this includes all signature matching
approaches that are based on the results of dynamic execution
or unpacking. Although the underlying matching techniques
might be similar but applied to execution logs or memory
dumps, we do not consider the underlying patterns for our
attacks. Note that injecting patterns from dynamic execu-
tion, such as sequences of system calls, into a benign process
is a diﬃcult problem and beyond the scope of this work.
Alternative signatures. In practice, virus scanners often use
diﬀerent signatures for the same malware family, such as
W32.Virut.a and W32.Virut.b. However, it is also possible
that multiple signatures map to the same label. Eﬀectively,
this can be thought as a disjunction of signatures. If these
individual signatures match in diﬀerent malware samples,
we are able to derive the disjunction correctly. However, a
problem arises whenever several of such signatures occur in
the same ﬁle. If these are disjoint, our method is not able
to derive any of them, since whenever the byte sequence
corresponding to one signature is altered, another signature
triggers an alarm. If they do overlap, we are able to at least
derive the intersection of all occurring signatures.
595Repetitive byte-sequences. We run into a similar problem
whenever one signature matches a sequence of bytes multiple
times within a ﬁle. For example, if we consider a ﬁle that
contains the same signature twice, one signature always
matches if we apply our derivation algorithm, as we only ﬂip
single bytes during the derivation. Consequently, it is not
possible for our approach to reveal the used signature in this
case. Our empirical study, however, shows that such cases
are rare and we are able to retrieve byte patterns for a third
of the considered signatures.
8. RELATED WORK
The analysis and detection of malware is a very vivid area
of research both in academia and industry. Consequently
implementations of such systems are under high scrutiny,
subject to security audits and target of adversarial attacks.
Also, due to the widespread use of signature-based detec-
tion in commercial products, a signiﬁcant body of research
has particularly studied the merits and deﬁciencies of these
systems. In the following, we discuss each of these related
strains of research in detail.
Attacking anti-virus products. Many researchers have dealt
with vulnerabilities in anti-virus products and point out
implementation ﬂaws that allow to bypass defensive mech-
anisms or hijack execution [2, 29, 42, 64]. Over the past
year Ormandy, for instance, called attention to several ﬂaws
in wide-spread commercial security products [43–47] demon-
strating the large attack surface such systems expose. Our
method in contrast does not rely on implementation ﬂaws,
but addresses a conceptual issue in the use of poorly designed
signatures.
Similar in spirit, Min and Varadharajan [35] make use of
anti-virus products as an ally for attacks and introduce “AV-
Parmware”, an advanced malware piggybacking virus scan-
ners. In particular, the device driver of the virus scanner is
tricked into starting the malicious code on every boot and
ensures a stealthy operation by providing the malware with
the same high privileges as itself. “AVLeak” [6], on the other
hand, also employs repeated scans of AV products, but uses
the results to carefully leak ﬁngerprints of used emulators.
Evasion of detection. Of course, exploits in anti-virus prod-
ucts can also be used to bypass detection. However, also the
underlying programming logic of ﬁle format parsers, unpack-
ers or search algorithms might be used to evade detection.
Jana and Shmatikov [25], for instance, describe two classes
of bypasses: Chameleon attacks where a malware sample
appears as a diﬀerent type than it actually is and werewolf
attacks that exploit diﬀerences in parsing logic of speciﬁc
ﬁle types. Both, are based on a diﬀerence in “perception”
between the product at the end-host and the virus scanner.
A popular example in this context is the Portable Document
Format (PDF): The Adobe Reader is to such an extent lib-
eral in processing malformed documents that do not comply
the speciﬁcations, that it is diﬃcult to exactly reproduce its
behavior in a security product [49, 63]. If a virus scanner’s
type-inference fails, there often is no alternative but reverting
to static pattern-based signatures.
Moreover, methods for evading signature-based detection
have been proposed and studied in various contexts [e.g.,
18, 36, 52, 53, 65]. In mobile security research for instance,
Zheng et al. [65] assess the robustness of virus scanners for
mobile malware against simple transformations. Continu-
ing this line of research, DroidChameleon [52] implements
more advanced transformations, showing that in 2013, ten
commercial Android anti-malware products can be bypassed
using common obfuscation techniques. In a follow-up work,
the authors additionally show that even one year later, these
systems can still be bypassed with the same techniques [53].
Deriving signatures. In intrusion detection, testing signatures
has received substantial attention [30, 38, 55, 56, 60]. To this
end some authors attempt to manually [38] and automati-
cally [30] derive signatures from such systems. In contrast to
our method the latter however inspects the execution of the
matching process on a binary level, while we observe the out-
come of the matching completely passively but strategically
modify the input.
Deriving signatures from anti-virus software on the con-
trary has received very little attention so far. Christodorescu
and Jha [9] explore possibilities for evaluating virus scanners,
and in particular, provide ﬁrst insights into the feasibility
of signature extraction. Filiol [15] extends this and deﬁnes
a naive algorithm similar to the underlying idea describe in
this paper, and presents an extraction scheme to determine