## 调试日志不输出到标准输出这个配置文件里有两节：第一节是全局（global）配置，配置了适用于所有级别的日志选项；第二节是专门用于调试（debug）级别的配置（你当然也可以自己配置fatal、error、warning等其他级别）。假设这个配置文件的名字是log.conf，我们在代码中可以这样使用：    #include "easylogging++.h"    INITIALIZE_EASYLOGGINGPP    int main()    {      el::Configurations conf{        "log.conf"};      el::Loggers::        reconfigureAllLoggers(conf);      LOG(DEBUG)   > `2020-01-26 12:54:58.986739 D [test.cpp:11] A debug message`>>>  > `2020-01-26 12:54:58.987444 I An info message`>我们也可以明确看到我们在配置文件中定义的日志格式生效了，包括：1.  日期时间的格式使用"."分隔秒的整数和小数部分，并且小数部分使用 6    位    2.  日志级别使用单个大写字母        3.  对于普通的日志，后面直接跟日志的信息；对于调试日志，则会输出文件名和行号        我们现在只需要修改配置文件，就能调整日志格式、决定输出和不输出哪些日志了。此外，我也推荐在编译时定义宏`ELPP_DEBUG_ASSERT_FAILURE`，这样能在找不到配置文件时直接终止程序，而不是继续往下执行、在终端上以缺省的方式输出日志了。性能跟踪Easylogging++可以用来在日志中记录程序执行的性能数据。这个功能还是很方便的。下面的代码展示了用于性能跟踪的三个宏的用法：    #include     #include     #include "easylogging++.h"    INITIALIZE_EASYLOGGINGPP    void foo()    {      TIMED_FUNC(timer);      LOG(WARNING)   > `2020-01-26 15:00:11.99736 W A warning message`>>>  > `2020-01-26 15:00:11.99748 I Executed [void foo()] in [110 us]`>>>  > `2020-01-26 15:00:11.99749 W A warning message`>>>  > `2020-01-26 15:00:11.99750 I Executed [void foo()] in [5 us]`>>>  > `2020-01-26 15:00:11.99750 W A warning message`>>>  > `2020-01-26 15:00:11.99751 I Executed [void foo()] in [4 us]`>>>  > `2020-01-26 15:00:11.99774 I Executed [a block] in [232 us]`>>>  > `2020-01-26 15:00:11.99776 I Executed [void bar()] in [398 us]`>不过需要注意，由于 Easylogging++本身有一定开销，且开销有一定的不确定性，这种方式只适合颗粒度要求比较粗的性能跟踪。性能跟踪产生的日志级别固定为 Info。性能跟踪本身可以在配置文件里的GLOBAL 节下用 `PERFORMANCE_TRACKING = false` 来关闭。当然，关闭所有 Info级别的输出也能达到关闭性能跟踪的效果。记录崩溃日志在 GCC 和 Clang 下，通过定义宏`ELPP_FEATURE_CRASH_LOG`我们可以启用崩溃日志。此时，当程序崩溃时，Easylogging++会自动在日志中记录程序的调用栈信息。通过记录下的信息，再利用 `addr2line`这样的工具，我们就能知道是程序的哪一行引发了崩溃。下面的代码可以演示这一行为：    #include "easylogging++.h"    INITIALIZE_EASYLOGGINGPP    void boom()    {      char* ptr = nullptr;      *ptr = '\0';    }    int main()    {      el::Configurations conf{        "log.conf"};      el::Loggers::        reconfigureAllLoggers(conf);      boom();    }你可以自己尝试编译运行一下，就会在终端和日志文件中看到崩溃的信息了。使用 macOS的需要特别注意一下：由于缺省方式产生的可执行文件是位置独立的，系统每次加载程序会在不同的地址，导致无法通过地址定位到程序行。在编译命令行尾部加上 `-Wl,-no_pie`可以解决这个问题。其他Easylogging++还有很多其他功能，我就不再一一讲解了。有些你简单试一下就可以用起来的。对于`ELPP_STL_LOGGING`，你也可以在包含 easylogging++.h之前包含我的output_container.h，可以达到类似的效果。此外，Easylogging++ 的 samples目录下有不少例子，可以用作参考。比如常见的日志文件切换功能，在Easylogging++ 里实现是需要稍微写一点代码的：Easylogging++会在文件满的时候调用你之前注册的回调函数，而你需要在回调函数里对老的日志文件进行重命名、备份之类的工作，samples/STL/roll-out.cpp则提供了最简单的实现参考。注意我使用的都是全局的日志记录器，但 Easylogging++允许你使用多个不同的日志记录器，用于（比如）不同的模块或功能。你如果需要这样的功能的话，也请你自行查阅文档了。spdlog跟 Easylogging++ 比起来，spdlog 要新得多了：前者是 2012年开始的项目，而后者是 2014 年开始的。我在 2016 年末开始在项目中使用Easylogging++ 时，Easylogging++ 的版本是 9.85 左右，而 spdlog 大概是0.11，成熟度和热度都不那么高。整体上，spdlog也确实感觉要新很多。项目自己提到的功能点是：1.  非常快（性能是其主要目标）        2.  只需要头文件即可使用        3.  没有其他依赖        4.  跨平台        5.  有单线程和多线程的日志记录器        6.  日志文件旋转切换        7.  每日日志文件        8.  终端日志输出        9.  可选异步日志        10. 多个日志级别        11. 通过用户自定义式样来定制输出格式        开始使用 spdlog跟 Easylogging++的例子相对应，我们以最简单的日志输出开头：    #include "spdlog/spdlog.h"    int main()    {      spdlog::info("My first info log");    }代码里看不到的是，输出结果中的"info"字样是彩色的，方便快速识别日志的级别。这个功能在Windows、Linux 和 macOS 上都能正常工作，对用户还是相当友好的。不过，和Easylogging++ 缺省就会输出到文件中不同，spdlog缺省只是输出到终端而已。你也许从代码中已经注意到，spdlog 不是使用 IO 流风格的输出了。它采用跟Python 里的 `str.format`一样的方式，使用大括号------可选使用序号和格式化要求------来对参数进行格式化。下面是一个很简单的例子：      spdlog::warn(        "Message with arg {}", 42);      spdlog::error(        "{0:d}, {0:x}, {0:o}, {0:b}",        42);输出会像下面这样：>  > `[2020-01-26 17:20:08.355] [warning] Message with arg 42`>>>  > `[2020-01-26 17:20:08.355] [error] 42, 2a, 52, 101010`>事实上，这就是 C++20 的 `format` 的风格了------spdlog 就是使用了一个 `format`的库实现 fmt \[3\。设置输出文件在 spdlog里，要输出文件得打开专门的文件日志记录器，下面的例子展示了最简单的用法：    #include "spdlog/spdlog.h"    #include "spdlog/sinks/basic_file_sink.h"    int main()    {      auto file_logger =        spdlog::basic_logger_mt(          "basic_logger",          "test.log");      spdlog::set_default_logger(        file_logger);      spdlog::info("Into file: {1} {0}",                   "world", "hello");    }执行之后，终端上没有任何输出，但 test.log文件里就会增加如下的内容：>  > `[2020-01-26 17:47:37.864] [basic_logger] [info] Into file: hello world`>估计你立即会想问，那我想同时输出到终端和文件，该怎么办呢？答案是你可以设立一个日志记录器，让它有两个（或更多个）日志槽（sink）即可。示例代码如下：    #include     #include "spdlog/spdlog.h"    #include "spdlog/sinks/basic_file_sink.h"    #include "spdlog/sinks/stdout_color_sinks.h"    using namespace std;    using namespace spdlog::sinks;    void set_multi_sink()    {      auto console_sink = make_shared();      console_sink->set_level(        spdlog::level::warn);      console_sink->set_pattern(        "%H:%M:%S.%e %^%L%$ %v");      auto file_sink =        make_shared(          "test.log");      file_sink->set_level(        spdlog::level::trace);      file_sink->set_pattern(        "%Y-%m-%d %H:%M:%S.%f %L %v");      auto logger =        shared_ptr(          new spdlog::logger(            "multi_sink",            {console_sink, file_sink}));      logger->set_level(        spdlog::level::debug);      spdlog::set_default_logger(        logger);    }    int main()    {      set_multi_sink();      spdlog::warn(        "this should appear in both "        "console and file");      spdlog::info(        "this message should not "        "appear in the console, only "        "in the file");    }大致说明一下：1.  `console_sink` 是一个指向           `stdout_color_sink_mt`    的智能指针，我们设定让它只显示警告级别及以上的日志信息，并把输出式样调整成带毫秒的时间、有颜色的短级别以及信息本身。        2.  `file_sink` 是一个指向         `basic_file_sink_mt`    的智能指针，我们设定让它显示跟踪级别及以上（也就是所有级别了）的日志信息，并把输出式样调整成带微秒的日期时间、短级别以及信息本身。        3.  然后我们创建了日志记录器，让它具有上面的两个日志槽。注意这儿的两个细节：1.    这儿的接口普遍使用         `shared_ptr`；2. 由于           `make_shared` 在处理           `initializer_list` 上的缺陷，对           `spdlog::logger` 的构造只能直接调用        `shared_ptr`    的构造函数，而不能使用         `make_shared`，否则编译会出错。        4.  最后我们调用了         `spdlog::set_default_logger`    把缺省的日志记录器设置成刚创建的对象。这样，之后的日志缺省就会记录到这个新的日志记录器了（我们当然也可以手工调用这个日志记录器的           `critical`、        `error`、        `warn`    等日志记录方法）。        在某次运行之后，我的终端上出现了：>  > `20:44:45.086 W this should appear in both console and file`>而 test.log 文件中则增加了：>  > `2020-01-26 20:44:45.086524 W this should appear in both console and file`>>>  > `2020-01-26 20:44:45.087174 I this message should not appear in the console, only in the file`>跟 Easylogging++ 相比，我们现在看到了 spdlog也有复杂的一面。两者在输出式样的灵活性上也有不同的选择：Easylogging++对不同级别的日志可采用不同的式样，而 spdlog对不同的日志槽可采用不同的式样。日志文件切换在 Easylogging++里实现日志文件切换是需要写代码的，而且完善的多文件切换代码需要写上几十行代码才能实现。这项工作在spdlog 则是超级简单的，因为 spdlog直接提供了一个实现该功能的日志槽。把上面的例子改造成带日志文件切换我们只需要修改两处：    #include "spdlog/sinks/rotating_file_sink.h"    //  替换  basic_file_sink.h    …      auto file_sink = make_shared(        "test.log", 1048576 * 5, 3);      //  替换  basic_file_sink_mt，文件大      //  小为  5MB，一共保留  3  个日志文件这就非常简单好用了。适配用户定义的流输出虽然 spdlog 缺省不支持容器的输出，但是，它是可以和用户提供的流 ` v;    // …    spdlog::info(      "Content of vector: {}", v);只用头文件吗？使用 spdlog 可以使用只用头文件的方式，也可以使用预编译的方式。只用头文件的编译速度较慢：我的机器上使用预编译方式构建第一个例子需要一秒多，而只用头文件的方式需要五秒多（Clang 的情况；GCC 耗时要更长）。因此正式使用的话，我还是推荐你使用预编译、安装的方式。在安装了库后，编译时需额外定义一个宏，在命令行上要添加库名。以 GCC为例，命令行会像下面这个样子：>  > `g++ -std=c++17 -DSPDLOG_COMPILED_LIB test.cpp -lspdlog`>其他刚才介绍的还只是 spdlog的部分功能。你如果对使用这个库感兴趣的话，应该查阅文档来获得进一步的信息。我这儿觉得下面这些功能点值得提一下：1.  可以使用多个不同的日志记录器，用于不同的模块或功能。        2.  可以使用异步日志，减少记日志时阻塞的可能性。        3.  通过         `spdlog::to_hex`    可以方便地在日志里输出二进制信息。        4.  可用的日志槽还有 syslog、systemd、Android、Windows    调试输出等；扩展新的日志槽较为容易。        内容小结今天我们介绍了两个不同的日志库，Easylogging++ 和spdlog。它们在功能和实现方式上有很大的不同，建议你根据自己的实际需要来进行选择。我目前对新项目的推荐是优先选择 spdlog：仅在你需要某个 Easylogging++提供、而 spdlog 不提供的功能时才选择Easylogging++。当然，C++的日志库远远不止这两个：我挑选的是我觉得比较好的和有实际使用经验的。其他可选择的日志库至少还有Boost.Log \[4\、g3log \[5\、NanoLog \[6\ 等（Log for C++ 接口有着 Java式的啰嗦，且感觉有点"年久失修"，我明确不推荐）。在严肃的项目里，选择哪个日志库是值得认真比较和评估一下的。课后思考请对比一下 Easylogging++ 和spdlog，考虑以下两个问题：1.       Easylogging++ 更多地使用了编译时的行为定制，而 spdlog    主要通过面向对象的方式在运行时修改日志的行为。你觉得哪种更好？为什么？        2.       Easylogging++ 使用了 IO 流的方式，而 spdlog 使用了           `std::format`    的方式。你更喜欢哪种？为什么？        参考资料\[1\] Amrayn Web Services, easyloggingpp.https://github.com/amrayn/easyloggingppslate-object="mark"} \[2\] Gabi Melman, spdlog. slate-object="mark"}https://github.com/gabime/spdlogslate-object="mark"} \[3\] Victor Zverovich, fmt. slate-object="mark"}https://github.com/fmtlib/fmtslate-object="mark"} \[4\] Andrey Semashev, Boost.Log v2.https://www.boost.org/doc/libs/release/libs/log/doc/html/index.htmlslate-object="mark"} \[5\] Kjell Hedström, g3log. slate-object="mark"}https://github.com/KjellKod/g3logslate-object="mark"} \[6\] Stanford University, NanoLog.https://github.com/PlatformLab/NanoLogslate-object="mark"} 