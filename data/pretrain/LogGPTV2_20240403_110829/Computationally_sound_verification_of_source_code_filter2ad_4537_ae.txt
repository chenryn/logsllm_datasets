kinds of bitstrings are observed. We will call these condi-
tions the “enc-sig-implementation conditions”.
Furthermore, [7] imposes conditions on the CoSP proto-
col. These ensure that all encryptions and signatures are
produced using fresh randomness and that secret keys are
not sent around. A protocol satisfying these conditions is
called key-safe. Assuming that all these conditions are ful-
ﬁlled, we get computational soundness for encryptions and
signatures:
Theorem 2
(Computational soundness [7]). If
Impl satisﬁes the enc-sig-implementation conditions, then
Impl is a computationally sound implementation of Mes for
the class of key-safe protocols.
When combining Theorem 2 with Theorem 1, we immedi-
ately get the following lemma:
Lemma 3. Let Impl be a computational implementation
satisfying the enc-sig-implementation conditions. Let A0 be
an eﬃciently decidable RCF expression such that M ⊢ A0
and ΠA0 is key-safe.
If A0σMes
DY is robustly →-safe or A0 is robustly ;-σMes
DY -safe,
then A0 is robustly computationally safe using Impl.
This lemma still has the drawback that one has to check
whether ΠA0 is key-safe. To be able to simplify the lemma,
we introduce a library σHighlevel that serves as a wrapper
for σMes
DY and that ensures that a program A0 that never di-
rectly calls σMes
DY but only the wrappers from σHighlevel will
result in a key-safe ΠA0 . For example, σHighlevel exports
a function σHighlevel (encrypt ) that takes an encryption key
and a plaintext, chooses a fresh nonce for randomness, and
then invokes σMes
DY (lib enc). This ensures that the randomness-
argument of σMes
DY (libenc) is always a fresh nonce. Further-
more, the function σHighlevel (enckeypair ) picks a fresh nonce
and uses that nonce to generate an encryption and a decryp-
tion key. The decryption key is wrapped using a private con-
structor DecKey so that it can only be used as an argument
of σHighlevel (decrypt ). This ensures that keys are generated
with fresh randomness and that the output of σMes
DY (lib dk) will
only be used as the second argument to σMes
DY (lib dec).11 For
signatures and signing keys, we proceed similarly. “Harm-
less” functions such as pairs are simply exported by σHighlevel
(possibly with modiﬁed calling conventions for more conve-
nient use, in particular for the functions related to payload
strings). The source code of σHighlevel is presented in the
full version.
11Notice that this has the eﬀect that keys may not be cor-
rupted during the protocol execution (no adaptive corrup-
tion). It is, however, possible to model statically corrupted
parties by subsuming them into the adversary and letting
him choose their keys.
The next lemma states that σHighlevel can be used to en-
force key-safety.
Lemma 4. Let A0 be an RCF expression with Mes ⊢ A0
DY = ∅ and not containing the RCF-
and fv (A0) ∩ dom σMes
constructors DecKey and SigKey.
Then ΠA0σHighlevel is key-safe.
Finally, we get computational soundness for encryptions
and signatures with respect to programs using the DY li-
brary:
Theorem 3
(Computational soundness for σMes
DY ).
Let Impl be a computational implementation satisfying the
enc-sig-implementation conditions. Let A0 be an eﬃciently
decidable RCF expression such that fv (A0) ⊆ σHighlevel , A
is pc-free, A does not contain the RCF-constructor DecKey
or SigKey, and the FOL/F-formulae in A do not contain
forbidden function symbols.
Then,
robustly →-safe,
then
if A0σHighlevel σMes
DY is
A0σHighlevel is robustly computationally safe using Impl.
Let A′
0 := A0σHighlevel . Since fv (A0) ⊆ σHighlevel
Proof.
and dom σHighlevel ∩ dom σMes
DY = ∅.
is key-safe. Furthermore, Mes ⊢ A′
Thus by Lemma 4, ΠA′
0
since Mes ⊢ σHighlevel (x) for all x ∈ dom σHighlevel . Hence by
Lemma 3, if A′
0 is robustly
computationally safe using Impl.
DY is robustly →-safe, then A′
DY = ∅, fv (A0) ∩ dom σMes
0σMes
0
5.5 Sealing-based library.
In the library σMes
DY , we have internally represented sym-
bolic cryptography as terms in some datatype. An alter-
native approach is used in the F7 veriﬁcation framework
[16]. In this approach, a library σS based on seals is used
(cf. Section 1.1). The main diﬃculty with such a library is
that it uses a global state to keep track of encryptions and
signatures produced by the protocol. We can, however, show
that robust safety with respect to σS implies robust safety
with respect to σMes
DY . From this, we immediately get a com-
putational soundness result for σS; the theorem is exactly
the same as Theorem 3, except that σMes
DY is replaced by σS.
We refer to the full version for details.
6. CONCLUSIONS
This paper presents a computational soundness result for
F7, a type-checker for F# programs. We show the computa-
tional soundness of a generic DY library as well as the com-
putational soundness of a sealing-based library. The proof
is conducted in the CoSP framework and solely concerns the
semantics of RCF programs, without involving any crypto-
graphic arguments. This makes our result easily extensible
to additional cryptographic primitives supported by CoSP.
We remark that the proof does not depend on a speciﬁc
veriﬁcation technique, thus our computational soundness re-
sult would automatically apply to reﬁnements of the type
system, or even to a diﬀerent analysis technique, as long
as these use the same symbolic cryptographic libraries. To
the best of our knowledge, this is the ﬁrst computational
soundness result for an automated veriﬁcation technique of
protocol implementations.
Acknowledgments. This work was partially funded by the
Cluster of Excellence “Multimodel Computing and Interac-
tion” (German Science Foundation), the Emmy Noether Pro-
gramme (German Science Foundation), the Miur’07 Project
396SOFT (Security Oriented Formal Techniques), the ERC
starting grant “End-to-end security”, and the DFG grant
3194/1-1.
7. REFERENCES
[1] M. Abadi, M. Baudet, and B. Warinschi. Guessing
attacks and the computational soundness of static
equivalence. In Proc. 9th International Conference on
Foundations of Software Science and Computation
Structures (FOSSACS), volume 3921 of Lecture Notes
in Computer Science, pages 398–412. Springer, 2006.
[2] Mart´ın Abadi and C´edric Fournet. Mobile values, new
names, and secure communication. In POPL ’01:
Proceedings of the 28th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages,
pages 104–115, New York, NY, USA, 2001. ACM
Press.
[3] Mart´ın Abadi and Andrew D. Gordon. A calculus for
cryptographic protocols: The spi calculus. In Proc. 4th
ACM Conference on Computer and Communications
Security, pages 36–47, 1997.
[4] Mart´ın Abadi and Jan J¨urjens. Formal eavesdropping
and its computational interpretation. In Proc. 4th
International Symposium on Theoretical Aspects of
Computer Software (TACS), pages 82–94, 2001.
[5] Mart´ın Abadi and Phillip Rogaway. Reconciling two
views of cryptography (the computational soundness
of formal encryption). Journal of Cryptology,
15(2):103–127, 2002.
[6] Pedro Ad˜ao and C´edric Fournet. Cryptographically
sound implementations for communicating processes.
In Proc. ICALP, pages 83–94, 2006.
[7] Michael Backes, Dennis Hofheinz, and Dominique
Unruh. CoSP: A general framework for computational
soundness proofs. In ACM CCS 2009, pages 66–78.
ACM Press, November 2009. Full version on IACR
ePrint 2009/080. Some of the deﬁnitions we use only
occur in the full version.
[8] Michael Backes, Matteo Maﬀei, and Dominique Unruh.
Library source code with F7 type-checking
annotations. Available at http:
//crypto.m2ci.org/unruh/misc/rcf/library.zip.
[9] Michael Backes, Matteo Maﬀei, and Dominique Unruh.
Computationally sound veriﬁcation of source code
(full version). IACR ePrint archive 2010/416, 2010.
[10] Michael Backes and Birgit Pﬁtzmann. Symmetric
encryption in a simulatable Dolev-Yao style
cryptographic library. In Proc. 17th IEEE Computer
Security Foundations Workshop (CSFW), pages
204–218, 2004.
[11] Michael Backes, Birgit Pﬁtzmann, and Michael
Waidner. A composable cryptographic library with
nested operations (extended abstract). In Proc. 10th
ACM Conference on Computer and Communications
Security, pages 220–230, 2003. Full version in IACR
Cryptology ePrint Archive 2003/015, Jan. 2003.
[12] Michael Backes, Birgit Pﬁtzmann, and Michael
Waidner. Symmetric authentication within a
simulatable cryptographic library. In Proc. 8th
European Symposium on Research in Computer
Security (ESORICS), volume 2808 of Lecture Notes in
Computer Science, pages 271–290. Springer, 2003.
[13] Michael Backes, Birgit Pﬁtzmann, and Michael
Waidner. The reactive simulatability (RSIM)
framework for asynchronous systems. Information and
Computation, 205(12):1685–1720, 2007.
[14] David Basin, Sebastian M¨odersheim, and Luca Vigan`o.
OFMC: A symbolic model checker for security
protocols. International Journal of Information
Security, 2004.
[15] M. Baudet, V. Cortier, and S. Kremer.
Computationally sound implementations of equational
theories against passive adversaries. In Proc. 32nd
International Colloquium on Automata, Languages and
Programming (ICALP), volume 3580 of Lecture Notes
in Computer Science, pages 652–663. Springer, 2005.
[16] Jesper Bengtson, Karthikeyan Bhargavan, C´edric
Fournet, Andrew D. Gordon, and Sergio Maﬀeis.
Reﬁnement types for secure implementations. In Proc.
21st IEEE Security Foundations Symposium (CSF),
pages 17–32, 2008. Full version is Microsoft Research
technical report MSR-TR-2008-118.
[17] K. Bhargavan, C. Fournet, A. D. Gordon, and S. Tse.
Veriﬁed interoperable implementations of security
protocols. In Proc. 19th IEEE Computer Security
Foundations Workshop (CSFW), pages 139–152.
IEEE, 2006.
[18] K. Bhargavan, C. Fournet, and A.D. Gordon. Modular
veriﬁcation of security protocol code by typing. In
Proc. 37th Symposium on Principles of Programming
Languages (POPL). ACM Press, 2010.
[19] Karthikeyan Bhargavan, Ricardo Corin, C´edric
Fournet, and Eugen Z˘alinescu. Cryptographically
veriﬁed implementations for TLS. In 15th ACM
Conference on Computer and Communications
Security (CCS 2008), pages 459–468. ACM Press,
2008.
[20] B. Blanchet. An eﬃcient cryptographic protocol
veriﬁer based on Prolog rules. In Proc. 14th IEEE
Computer Security Foundations Workshop (CSFW),
pages 82–96. IEEE Computer Society Press, 2001.
[21] Bruno Blanchet. A computationally sound mechanized
prover for security protocols. In IEEE Symposium on
Security and Privacy, Proceedings of SSP 2006, pages
140–154. IEEE Computer Society, 2006. Extended
version online available as IACR ePrint 2005/401.
[22] Sagar Chaki and Anupam Datta. Aspier: An
automated framework for verifying security protocol
implementations. In Proc. 22nd IEEE Computer
Security Foundations Symposium (CSF), pages
172–185. IEEE, 2009.
[23] Hubert Comon-Lundh. About models of security
protocols (abstract). In Ramesh Hariharan, Madhavan
Mukund, and V Vinay, editors, Proc. FSTTCS,
Dagstuhl, Germany, 2008. Schloss Dagstuhl. http:
//drops.dagstuhl.de/opus/volltexte/2008/1766/.
[24] Hubert Comon-Lundh and V´eronique Cortier.
Computational soundness of observational equivalence.
In Proc. ACM CCS, pages 109–118, 2008.
[25] Danny Dolev and Andrew C. Yao. On the security of
public key protocols. IEEE Transactions on
Information Theory, 29(2):198–208, 1983.
397[26] Shimon Even and Oded Goldreich. On the security of
multi-party ping-pong protocols. In Proc. 24th IEEE
FOCS, pages 34–39, 1983.
[27] C´edric Fournet. On the computational soundness of
cryptographic veriﬁcation by typing. Workshop on
Formal and Computational Cryptography (FCC 2009),
2009.
[28] J. Goubault-Larrecq and F. Parrennes. Cryptographic
protocol analysis on real c code. In Proc. 6th
International Conference on Veriﬁcation, Model
Checking and Abstract Interpretation (VMCAI’05),
volume 3385 of Lecture Notes in Computer Science,
pages 363–379. Springer-Verlag, 2005.
[29] Jean Goubault-Larrecq and Fabrice Parrennes.
Cryptographic protocol analysis on real C code. In 6th
International Conference on Veriﬁcation, Model
Checking, and Abstract Interpretation, (VMCAI 2005),
pages 363–379. Springer, 2005.
[30] A. Gunter. Semantics of Programming Languages:
Structures and Techniques. MIT Press, 1992.
[31] Jonathan Herzog, Moses Liskov, and Silvio Micali.
Plaintext awareness via key registration. In Advances
in Cryptology: CRYPTO 2003, volume 2729 of Lecture
Notes in Computer Science, pages 548–564. Springer,
2003.
[32] Romain Janvier, Yassine Lakhnech, and Laurent
Mazar´e. Completing the picture: Soundness of formal
encryption in the presence of active adversaries. In
Proc. ESOP, pages 172–185, 2005.
[33] Richard Kemmerer, Catherine Meadows, and Jon
Millen. Three systems for cryptographic protocol
analysis. Journal of Cryptology, 7(2):79–130, 1994.
[34] Peeter Laud. Semantics and program analysis of
computationally secure information ﬂow. In Proc. 10th
European Symposium on Programming (ESOP), pages
77–91, 2001.
[35] Peeter Laud. Symmetric encryption in automatic
analyses for conﬁdentiality against active adversaries.
In Proc. 25th IEEE Symposium on Security & Privacy,
pages 71–85, 2004.
[36] Gavin Lowe. Breaking and ﬁxing the
Needham-Schroeder public-key protocol using FDR.
In Proc. 2nd International Conference on Tools and
Algorithms for the Construction and Analysis of
Systems (TACAS), volume 1055 of Lecture Notes in
Computer Science, pages 147–166. Springer, 1996.
[37] Michael Merritt. Cryptographic Protocols. PhD thesis,
Georgia Institute of Technology, 1983.
[38] Daniele Micciancio and Bogdan Warinschi. Soundness
of formal encryption in the presence of active
adversaries. In Proc. 1st Theory of Cryptography
Conference (TCC), volume 2951 of Lecture Notes in
Computer Science, pages 133–151. Springer, 2004.
[39] Lawrence Paulson. The inductive approach to
verifying cryptographic protocols. Journal of
Cryptology, 6(1):85–128, 1998.
[40] Steve Schneider. Security properties and CSP. In Proc.
17th IEEE Symposium on Security & Privacy, pages
174–187, 1996.
[41] Christoph Sprenger, Michael Backes, David Basin,
Birgit Pﬁtzmann, and Michael Waidner.
Cryptographically sound theorem proving. In Proc.
19th IEEE Computer Security Foundations Workshop
(CSFW), pages 153–166, 2006.
398