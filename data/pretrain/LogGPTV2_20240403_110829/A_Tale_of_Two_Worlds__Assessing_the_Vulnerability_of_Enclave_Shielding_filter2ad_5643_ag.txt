Exploiting synchronisation bugs in Intel SGX enclaves. In European Symposium
on Research in Computer Security. 440–457.
[51] S. Weiser, M. Werner, F. Brasser, M. Malenko, S. Mangard, and A.-Reza Sadeghi.
2019. TIMBER-V: Tag-Isolated Memory Bringing Fine-grained Enclaves to RISC-V.
In NDSS 2019.
[52] J. Woodruff, R. NM Watson, D. Chisnall, S. W Moore, J. Anderson, B. Davis, B.
Laurie, P. G Neumann, R. Norton, and M. Roe. 2014. The CHERI capability model:
Revisiting RISC in an age of risk. In ISCA 2014. 457–468.
[53] M. Xu, C. Qian, K. Lu, M. Backes, and T. Kim. 2018. Precise and scalable detection
of double-fetch bugs in OS kernels. In IEEE Symposium on Security and Privacy.
661–678.
[54] Y. Xu, W. Cui, and M. Peinado. 2015. Controlled-channel attacks: Deterministic
side channels for untrusted operating systems. In IEEE Symposium on Security
and Privacy. 640–656.
A VULNERABLE CODE SAMPLES
A.1 OE legacy ecall dispatcher
The (legacy) ecall interface _handle_call_enclave() does not vali-
date that arg_in.args points outside the enclave. While this pointer
is subsequently checked by the oeedger8r-generated entry code,
an error code is still written to the in-enclave memory location on
failure (cf. Listing 2). After our report, the legacy handle_call_encl
ave() dispatcher has been removed completely.
oe_call_enclave_args_t args , * args_ptr ;
...
if (! oe_is_outside_enclave (( void *) arg_in ,
1 static oe_result_t _handle_call_enclave ( uint64_t arg_in ) {
2
3
4
5
6
7
8
9
args_ptr = ( oe_call_enclave_args_t *) arg_in ;
args = * args_ptr ;
...
OE_RAISE ( OE_INVALID_PARAMETER );
sizeof ( oe_call_enclave_args_t )))
10 ⭑ func ( args . args );
11
...
Listing 6: https://github.com/Microsoft/OpenEnclave/blob/
93ac313a/enclave/core/sgx/calls.c#L216
A.2 OE built-in attestation ecall
Evidently, a check that validates that arg_in points outside the
enclave was overlooked. We thus can overwrite in-enclave memory
through the write to host_arg->result. Note that the target buffer
has to have a certain size to avoid segfaults in the function _oe_g
et_local_report() that is called within _handle_get_sgx_report()
(this is because the parameter oe_get_sgx_report_args_t is a large
struct). Because of that, _oe_get_local_report() will very likely
fail with the return value OE_INVALID_PARAMETER (0x3) and overwrite
the first four bytes of the memory at host_arg with 0x03000000.
if ( host_arg == NULL )
OE_RAISE ( OE_INVALID_PARAMETER );
( oe_get_sgx_report_args_t *) arg_in ;
// Validate and copy args to prevent TOCTOU issues .
oe_result_t result = OE_UNEXPECTED ;
oe_get_sgx_report_args_t * host_arg =
oe_get_sgx_report_args_t enc_arg ;
size_t report_buffer_size = sizeof ( sgx_report_t );
1 oe_result_t _handle_get_sgx_report ( uint64_t arg_in ) {
2
3
4
5
6
7
8
9
10
11
12 ⭑ enc_arg = * host_arg ;
13
14
15
16
17
18
19 ⭑ * host_arg = enc_arg ;
20
21 done :
22
23 ⭑
24
25 }
OE_CHECK ( _oe_get_local_report ( NULL , 0,
host_arg -> result = result ;
result = OE_OK ;
if ( host_arg )
return result ;
( enc_arg . opt_params_size != 0) ? enc_arg . opt_params : NULL ,
enc_arg . opt_params_size , ( uint8_t *) & enc_arg . sgx_report ,
& report_buffer_size ));
Listing 7: https://github.com/microsoft/OpenEnclave/blob/
93ac313a/enclave/core/sgx/report.c#L388
A.3 Asylo ecall entry point
Asylo’s trusted ecall dispatcher is declared in Intel SGX-SDK EDL
specification as follows: public int ecall_dispatch_trusted_call
(uint64_t selector, [user_check] void *buffer). However, in the
code below, it becomes apparent that the [user_check] argument
buffer is never properly validated before being unmarshalled. This
issue can most easily be mitigated by properly declaring the argu-
ment buffer using edger8r’s [in] pointer attribute instead of the
problematic [user_check] attribute. Further, the validation logic
at line 16 contains a logic mistake which incorrectly assumes that
outside == ¬inside (cf. Section 5.3).
1 int ecall_dispatch_trusted_call ( uint64_t selector , void * buffer ) {
return asylo :: primitives :: asylo_enclave_call ( selector , buffer );
2
3 }
4
5 int asylo_enclave_call ( uint64_t selector , void * buffer ) {
6
SgxParams * const sgx_params = reinterpret_cast (
buffer );
7
8 ⭑ const void * input = sgx_params -> input ;
9 ⭑ size_t input_size = sgx_params -> input_size ;
10 ⭑ sgx_params -> input = nullptr ;
11 ⭑ sgx_params -> input_size = 0;
12
13
14
15
16 ⭑
17
void * output = nullptr ;
size_t output_size = 0;
if ( input ) {
if ( TrustedPrimitives :: IsTrustedExtent ( input , input_size )) {
PrimitiveStatus status { error :: GoogleError :: INVALID_ARGUMENT ,
" input should lie within untrusted memory ." };
return status . error_code () ;
18
19
}
Listing 8: https://github.com/google/asylo/blob/e4810bdbac/
asylo/platform/primitives/sgx/trusted_sgx.cc#L98
A.4 SGX-LKL SIGILL signal handler exploit
SGX-LKL intercepts the SIGILL (undefined instruction) to handle
instructions like rdtsc inside the enclave. In this case, the host exe-
cutes rdtsc and the result is passed back into the enclave through
the enclave’s signal handler interface. In case of SIGILL, an adver-
sary can change the untrusted siginfo argument to point into the
enclave, which will then yield the memory contents at that location
as the 64-bit result of rdtsc, as shown by our PoC. This specific
vulnerability can only be exploited if the target in-enclave memory
starts with 0x04000000 (i.e., siginfo->signum==SIGILL). In addition,
the rdtsc result needs to be outputted back to the untrusted side
(e.g., our PoC simply prints it to the terminal). Note that adversaries
can also use the in-enclave signal handler’s execution itself as a
side-channel. Depending on the contents of the memory pointed to
by siginfo->signum different code paths are taken, so established
side-channel approaches may reconstruct the secret-dependent con-
trol through differences in timing [30], page tables [47, 54], or other
microarchitectural elements [24, 46].
enclave_signal_info_t * siginfo ) {
...
int ret ;
switch ( siginfo -> signum ) {
case SIGSEGV :
1 void __enclave_signal_handler ( gprsgx_t * regs ,
2
3
4
5 ⭑
6
7 ⭑
8
9
10 ⭑
11
12
13
14
15
ret = handle_sigill ( regs , siginfo -> arg );
break ;
ret = handle_sigsegv ( regs , siginfo -> arg );
break ;
case SIGILL :
ret = -1;
default :
}
...
Listing 9: https://github.com/lsds/sgx-lkl/blob/664eb25a/src
/sgx/enclave_signal.c#L17
A.5 Sancus authentic execution stub
Passing a ciphertext pointer argument that points inside the enclave
may unintentionally decrypt enclave memory, potentially leading
to information disclosure. Interestingly, we observed that untrusted
array index arguments were properly sanitized to safeguard against
well-understood buffer overflow vulnerabilities.
1 void SM_ENTRY __sm_handle_input ( uint16_t conn_id ,
2
3 {
const void * payload , size_t len )
if ( conn_id >= SM_NUM_INPUTS ) return ;
size_t data_len = len - AD_SIZE - SANCUS_TAG_SIZE ;
uint8_t * input_buffer = alloca ( data_len );
4
5
6
7 ⭑ uint8_t * cipher = ( uint8_t *) payload + AD_SIZE ;
8 ⭑ uint8_t * tag = cipher + data_len ;
9
10
11
12 ⭑ if ( sancus_unwrap_with_key ( __sm_io_keys [ conn_id ],
13
14
15
16
17
18 }
{
}
payload , AD_SIZE , cipher ,
data_len , tag , input_buffer ))
__sm_input_callbacks [ conn_id ]( input_buffer , data_len );
Listing 10: https://github.com/sancus-pma/sancus-compiler
/blob/5d5cbff/src/stubs/sm_input.c#L7
A.6 OE string ecall edge wrapper
As part of OE’s “deep copy” marshalling scheme, the _handle_call
_enclave_function() from the trusted runtime properly copies the
entire marshalled input buffer into the enclave (including the string
argument and alleged length which are put into the serialized input
_buffer by the untrusted runtime). The oeedger8r bridge then takes
care to redirect all pointers to the marshalled input buffer. However,
when doing so the auto-generated oeedger8r entry code below does
not explicitly null-terminate the untrusted string argument. Hence,
the trusted user function will incorrectly assume that the string
is properly terminated and may perform out-of-bounds memory
read/writes beyond the end of the string.
size_t input_buf_size , uint8_t * output_buf ,
size_t output_buf_size , size_t * output_bytes_written )
1 void ecall_my_ecall ( uint8_t * input_buf ,
2
3
4 {
5
6
7
8
9
10
11
12
oe_result_t _result = OE_FAILURE ;
/* NOTE : output buf code removed for sake of space */
my_ecall_args_t * pargs_in =( my_ecall_args_t *) input_buf ;
size_t input_buf_offset = 0;
/* Make sure buffers lie within the enclave */
OE_ADD_SIZE ( input_buf_offset , sizeof (* pargs_in ));
if (! input_buf || ! oe_is_within_enclave ( input_buf ,
input_buf_size ))
goto done ;
13
14
/* OE_SET_IN_POINTER (s , s_len * sizeof ( char )) */
if ( pargs_in ->s) {
*( uint8_t **) & pargs_in ->s = input_buf + input_buf_offset ;
OE_ADD_SIZE ( input_buf_offset , ( size_t )( s_len * sizeof ( char )));
if ( input_buf_offset > input_buf_size ) {
15
16
17 ⭑
18
19
20
21
22
23
24
25 ⭑ my_ecall ( pargs_in ->s);
26
27 }
}
oe_lfence () ;
...
}
_result = OE_BUFFER_TOO_SMALL ;
goto done ;
/* lfence after checks */
/* Call user function */
Listing 11: Proxy function generated by oeedger8r for the
EDL specification: public void my_ecall([in,string] char *s).
A.7 Keystone integer overflow
We discovered a potential vulnerability that originates from an
integer overflow in the detect_region_overlap() function which
is used during the process of creating an enclave. Evidently, there
is no check to guarantee that the integer additions do not over-
flow. Suppose that epm_base=0x82800000 and epm_size=100000. If
one passes addr=0x1 and size=0xffffffffffffffff, there is an over-
lap between both regions. However, when these values are put
into the above condition, this evaluates to “no overlap” (zero). The
above issue was not exploitable at the time of discovery: various
constraints imposed on the size prevented the exploitation of this
issue, but it might have been problematic in the future if the overlap
check was used in different parts of the code.
...
1 static int detect_region_overlap ( uintptr_t addr , uintptr_t size )
2 {
3
4 ⭑ region_overlap |= (( uintptr_t ) epm_base  addr );
...
Listing 12: https://github.com/keystone-enclave/riscv-pk/
blob/e24d47c/sm/pmp.c#L71