you specify which interface a method belongs to when you implement it, like
this:
Click here to view code image
class Horse : ILandBound, IJourney
{
    ...
    int ILandBound.NumberOfLegs()
    {
        return 4;
    }
    int IJourney.NumberOfLegs()
    {
        return 3;
    }
}
Now you can see that the horse has four legs and has pulled the coach for
three legs of the journey.
Apart from prefixing the name of the method with the interface name,
there is one other subtle difference in this syntax: the methods are not marked
public. You cannot specify the protection for methods that are part of an
explicit interface implementation. This leads to another interesting
phenomenon. If you create a Horse variable in the code, you cannot actually
invoke either of the NumberOfLegs methods because they are not visible. As
Download from finelybook PI:EMAIL
450
far as the Horse class is concerned, they are both private. In fact, this makes
sense. If the methods were visible through the Horse class, which method
would the following code actually invoke, the one for the ILandBound
interface or the one for the IJourney interface?
Click here to view code image
Horse horse = new Horse();
...
// The following statement will not compile
int legs = horse.NumberOfLegs();
So, how do you access these methods? The answer is that you reference
the Horse object through the appropriate interface, like this:
Click here to view code image
Horse horse = new Horse();
...
IJourney journeyHorse = horse;
int legsInJourney = journeyHorse.NumberOfLegs();
ILandBound landBoundHorse = horse;
int legsOnHorse = landBoundHorse.NumberOfLegs();
I recommend explicitly implementing interfaces when possible.
Interface restrictions
The essential idea to remember is that an interface never contains any
implementation. The following restrictions are natural consequences of this:
You’re not allowed to define any fields in an interface, not even static
fields. A field is an implementation detail of a class or structure.
You’re not allowed to define any constructors in an interface. A
constructor is also considered to be an implementation detail of a class
or structure.
You’re not allowed to define a destructor in an interface. A destructor
contains the statements used to destroy an object instance. (Destructors
are described in Chapter 14, “Using garbage collection and resource
management.”)
You cannot specify an access modifier for any method. All methods in
an interface are implicitly public.
Download from finelybook PI:EMAIL
451
You cannot nest any types (such as enumerations, structures, classes, or
interfaces) inside an interface.
An interface is not allowed to inherit from a structure or a class,
although an interface can inherit from another interface. Structures and
classes contain implementation; if an interface were allowed to inherit
from either, it would be inheriting some implementation.
Defining and using interfaces
In the following exercises, you will define and implement interfaces that
constitute part of a simple graphical drawing package. You will define two
interfaces, called IDraw and IColor, and then you will define classes that
implement them. Each class will define a shape that can be drawn on a
canvas on a form. (A canvas is a control that you can use to draw lines, text,
and shapes on the screen.)
The IDraw interface defines the following methods:
SetLocation With this method, you can specify the position as x- and
y-coordinates of the shape on the canvas.
Draw This method actually draws the shape on the canvas at the
location specified by using the SetLocation method.
The IColor interface defines the following method:
SetColor You use this method to specify the color of the shape.
When the shape is drawn on the canvas, it will appear in this color.
Define the IDraw and IColor interfaces
1. Start Microsoft Visual Studio 2017 if it is not already running.
2. Open the Drawing solution, which is located in the \Microsoft
Press\VCSBS\Chapter 13\Drawing folder in your Documents folder.
The Drawing project is a graphical application. It contains a form called
DrawingPad. This form contains a canvas control called
drawingCanvas. You will use this form and canvas to test your code.
3. In Solution Explorer, click the Drawing project. On the Project menu,
Download from finelybook PI:EMAIL
452
click Add New Item.
The Add New Item—Drawing dialog box opens.
4. In the left pane of the Add New Item—Drawing dialog box, click Visual
C#, and then click Code. In the middle pane, click the Interface
template. In the Name box, type IDraw.cs, and then click Add.
Visual Studio creates the IDraw.cs file and adds it to your project. The
IDraw.cs file appears in the Code and Text Editor window, and should
look like this:
Click here to view code image
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace Drawing
{
    interface IDraw
    {
    }
}
5. In the IDraw.cs file, add the following using directive to the list at the
top of the file:
Click here to view code image
using Windows.UI.Xaml.Controls;
You will reference the Canvas class in this interface. The Canvas class
is located in the Windows.UI.Xaml.Controls namespace for Universal
Windows Platform (UWP) apps.
6. Add the methods shown here in bold to the IDraw interface:
Click here to view code image
interface IDraw
{
    void SetLocation(int xCoord, int yCoord);
    void Draw(Canvas canvas);
}
Download from finelybook PI:EMAIL
453
7. On the Project menu, click Add New Item again.
8. In the Add New Item—Drawing dialog box, in the middle pane, click
the Interface template. In the Name box, type IColor.cs, and then click
Add.
Visual Studio creates the IColor.cs file and adds it to your project. The
IColor.cs file appears in the Code and Text Editor window.
9. In the IColor.cs file, at the top of the file, add the following using
directive to the list:
using Windows.UI;
You will reference the Color class in this interface, which is located in
the Windows.UI namespace for UWP apps.
10. Add the following method shown in bold to the IColor interface
definition:
Click here to view code image
interface IColor
{
    void SetColor(Color color);
}
You have now defined the IDraw and IColor interfaces. The next step is
to create some classes that implement them. In the following exercise, you
will create two new shape classes, called Square and Circle. These classes
will implement both interfaces.
Create the Square and Circle classes, and implement the interfaces
1. On the Project menu, click Add Class.
2. In the Add New Item—Drawing dialog box, in the middle pane, verify
that the Class template is selected. In the Name box, type Square.cs,
and then click Add.
Visual Studio creates the Square.cs file and displays it in the Code and
Text Editor window.
3. At the top of the Square.cs file, add the following using directives to the
Download from finelybook PI:EMAIL
454
list:
Click here to view code image
using Windows.UI;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Shapes;
using Windows.UI.Xaml.Controls;
4. Modify the definition of the Square class so that it implements the
IDraw and IColor interfaces, as shown here in bold:
Click here to view code image
class Square: IDraw, IColor
{
}
5. Add the following private variables shown in bold to the Square class:
Click here to view code image
class Square : IDraw, IColor
{
    private int sideLength;
    private int locX = 0, locY = 0;
    private Rectangle rect = null;
}
These variables will hold the position and size of the Square object on
the canvas. The Rectangle class is located in the
Windows.UI.Xaml.Shapes namespace for UWP apps. You will use this
class to draw the square.
6. Add the following constructor shown in bold to the Square class:
Click here to view code image
class Square : IDraw, IColor
{
    ...
    public Square(int sideLength)
    {
          this.sideLength = sideLength;
    }
}
This constructor initializes the sideLength field and specifies the length
of each side of the square.
Download from finelybook PI:EMAIL
455
7. In the definition of the Square class, hover over the IDraw interface. On
the lightbulb context menu that appears, click Implement Interface
Explicitly, as shown in the following image:
This feature causes Visual Studio to generate default implementations of
the methods in the IDraw interface. You can also add the methods to the
Square class manually if you prefer. The following example shows the
code generated by Visual Studio:
Click here to view code image
void IDraw.Draw(Canvas canvas)
{
     throw new NotImplementedException();
}
void IDraw.SetLocation(int xCoord, int yCoord)
{
     throw new NotImplementedException();
}
Each of these methods currently throws a NotImplementedException
exception. You are expected to replace the body of these methods with
your own code.
8. In the IDraw.SetLocation method, replace the existing code that throws
a NotImplementedException exception with the following statements
shown in bold:
Click here to view code image
Download from finelybook PI:EMAIL
456
void IDraw.SetLocation(int xCoord, int yCoord)
{
    this.locX = xCoord;
    this.locY = yCoord;
}
This code stores the values passed in through the parameters in the locX
and locY fields in the Square object.
9. Replace the exception code generated in the IDraw.Draw method with
the statements shown here in bold:
Click here to view code image
void IDraw.Draw(Canvas canvas)
{
    if (this.rect != null)
    {
        canvas.Children.Remove(this.rect);
    }
    else
    {
        this.rect = new Rectangle();
    }
    this.rect.Height = this.sideLength;
    this.rect.Width = this.sideLength;
    Canvas.SetTop(this.rect, this.locY);
    Canvas.SetLeft(this.rect, this.locX);
    canvas.Children.Add(this.rect);
}
This method renders the Square object by drawing a Rectangle shape on
the canvas. (A square is simply a rectangle for which all four sides have
the same length.) If the Rectangle has been drawn previously (possibly
at a different location and with a different color), it is removed from the
canvas. The height and width of the Rectangle are set by using the value
of the sideLength field. The position of the Rectangle on the canvas is
set by using the static SetTop and SetLeft methods of the Canvas class,
and then the Rectangle is added to the canvas. (This causes it to be
displayed.)
10. Add the SetColor method from the IColor interface to the Square class,
as shown here:
Click here to view code image
Download from finelybook PI:EMAIL
457
void IColor.SetColor(Color color)
{
    if (this.rect != null)
    {
        SolidColorBrush brush = new SolidColorBrush(color);
        this.rect.Fill = brush;
    }
}
This method checks that the Square object has actually been displayed.
(The rect field will be null if it has not yet been rendered.) The code sets
the Fill property of the rect field with the specified color by using a
SolidColorBrush object. (The details of how the SolidColorBrush class
works are beyond the scope of this discussion.)
11. On the Project menu, click Add Class. In the Add New Item – Drawing
dialog box, in the Name box, type Circle.cs, and then click Add.
Visual Studio creates the Circle.cs file and displays it in the Code and
Text Editor window.
12. At the top of the Circle.cs file, add the following using directives to the
list:
Click here to view code image
using Windows.UI;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Shapes;
using Windows.UI.Xaml.Controls;
13. Modify the definition of the Circle class so that it implements the IDraw
and IColor interfaces as shown here in bold:
Click here to view code image
class Circle : IDraw, IColor
{
}
14. Add the following private variables shown in bold to the Circle class:
Click here to view code image
class Circle : IDraw, IColor
{
    private int diameter;
    private int locX = 0, locY = 0;
Download from finelybook PI:EMAIL
458
    private Ellipse circle = null;
}
These variables will hold the position and size of the Circle object on
the canvas. The Ellipse class provides the functionality that you will use
to draw the circle.
15. Add the constructor shown here in bold to the Circle class:
Click here to view code image
class Circle : IDraw, IColor
{
    ...
    public Circle(int diameter)
    {
        this.diameter = diameter;
    }
}
This constructor initializes the diameter field.
16. Add the following SetLocation method from the IDraw interface to the
Circle class:
Click here to view code image
void IDraw.SetLocation(int xCoord, int yCoord)
{
    this.locX = xCoord;
    this.locY = yCoord;
}
Note This method is the same as that in the Square class. You will
see how you refactor the code to avoid this repetition later in the
chapter.
17. Add the Draw method shown here to the Circle class:
Click here to view code image
void IDraw.Draw(Canvas canvas)
{
Download from finelybook PI:EMAIL
459
    if (this.circle != null)
    {
        canvas.Children.Remove(this.circle);
    }
    else
    {
        this.circle = new Ellipse();
    }
    this.circle.Height = this.diameter;
    this.circle.Width = this.diameter;
    Canvas.SetTop(this.circle, this.locY);
    Canvas.SetLeft(this.circle, this.locX);
    canvas.Children.Add(this.circle);
}
This method is also part of the IDraw interface. It is similar to (but the
same as) the Draw method in the Square class, except that it renders the
Circle object by drawing an Ellipse shape on the canvas. (A circle is an
ellipse for which the width and height are the same.) As with the
SetLocation method, you will see how to refactor this code to reduce any
repetition later in this chapter.
18. Add the following SetColor method to the Circle class:
Click here to view code image
void IColor.SetColor(Color color)
{
    if (this.circle != null)
      {
        SolidColorBrush brush = new SolidColorBrush(color);
        this .circle.Fill = brush;
      }
}
This method is part of the IColor interface. As before, this method is
similar to that of the Square class.
You have completed the Square and Circle classes. You can now use the
form to test them.
Test the Square and Circle classes
1. Display the DrawingPad.xaml file in the Design View window.
2. On the form, click the large shaded area.
Download from finelybook PI:EMAIL
460
The shaded area of the form is the Canvas object. Clicking on this area
sets the focus to this object.
3. In Properties window, click the Event Handlers button. (This button has
an icon that looks like a bolt of lightning.)
4. In the list of events, locate the Tapped event, and then double-click in
the Tapped text box.
Visual Studio creates a method called drawingCanvas_Tapped for the
DrawingPad class and displays it in the Code and Text Editor window.
This is an event handler that runs when the user taps the canvas with a
finger or clicks the left mouse button over the canvas. You can learn
more about event handlers in Chapter 20, “Decoupling application logic
and handling events.”
5. At the top of the DrawingPad.xaml.cs file, add the following using
directive to the list:
using Windows.UI;
The Windows.UI namespace contains the definition of the Colors class,
which you will use when you set the color of a shape as it is drawn.
6. Add the following code shown in bold to the drawingCanvas_Tapped
method:
Click here to view code image
private void drawingCanvas_Tapped(object sender,
TappedRoutedEventArgs e)
{
    Point mouseLocation = e.GetPosition(this.drawingCanvas);
    Square mySquare = new Square(100);
    if (mySquare is IDraw)
    {
        IDraw drawSquare = mySquare;
        drawSquare.SetLocation((int)mouseLocation.X,
(int)mouseLocation.Y);
        drawSquare.Draw(drawingCanvas);
    }
}
The TappedRoutedEventArgs parameter to this method provides useful
information about the position of the mouse. In particular, the
Download from finelybook PI:EMAIL
461
GetPosition method returns a Point structure that contains the x- and y-
coordinates of the mouse. The code that you have added creates a new
Square object. It then checks to verify that this object implements the
IDraw interface (this is good practice and helps to ensure that your code
will not fail at runtime if you attempt to reference an object through an
interface that it does not implement) and creates a reference to the object
by using this interface. Remember that when you explicitly implement
an interface, the methods defined by the interface are available only by
creating a reference to that interface. (The SetLocation and Draw
methods are private to the Square class and are available only through
the IDraw interface.) The code then sets the location of the Square to the
position of the user’s finger or mouse. Note that the x- and y-coordinates
in the Point structure are actually double values, so this code casts them
to ints. The code then calls the Draw method to display the Square
object.
7. At the end of the drawingCanvas_Tapped method, add the following
code shown in bold:
Click here to view code image