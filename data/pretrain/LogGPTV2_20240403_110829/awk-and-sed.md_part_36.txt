printf "%s %6.2f\n", $0, amount 
amount = $2 * $3
并用一个空行将不同的订单分隔开。前面两行提供了客)
它只是着重介绍了 awk 对数据的处理能力和报告功能（令
，包括每项的订数及每项的单价。包含通信列表和客户订
50192241
- 270 -
第十章
“底部抽屉”
的
成
---
## Page 253
函数将一个字段分割为子值。
在数据库术语中，
录到少有3个字段。然后用一个for 循环从第三个字段开始读取所有的字段。
每个记录的字段数是可变的，这依赖于订货的项目数。首先，
该脚本将从设置字段和记录分隔符开始：
生所有订单的总份数和总数量。
果
以便显示报告。这个报告将显示每个项目的总订单份数和总量。我们还希望产
行进行处理。现在，
这个程序不必将客户的记录作为一个整体来访问，它只是简单地对独立的项目
配
果
的个数，%f的默认值是6。Print 语句打印当前记录以及变量 amount 的值。如
“6.2”指定最小输出域宽度为6且精度为2。精度即十进制小数点右边的数字
赋给变量 amount。Printf格式转换符“%f”用于打印一个浮点型的数据，
这里的主过程只影响匹配模式的行。它用第二字段乘以第三个字段，
在多行记录中一行为一个字段，则子值就是行中的单词。我们可以用 split()
在这个过程中打印一行，
for （i = 3;i = 3 {
#2
#1 2 7.50 15.00
P.0 NONE Date: 03/14/97
Martin S. Rossi
#
#
#
#
#1 3 7.50 22.50
P.0 N61331 97 Y 045 Date: 03/14/97
Char lotte Webb
$ addem orders
 print”’
2 5 6.75 33.75
71 7.50 7.50
1 7.50
2 37.50
17.50
QQ群：
22.50
Z
7.50
每个字段有一个值且每个值还能再分成子值。也就是说，如
g
$*
，我们来设计一个程序以读取多个记录，并累计订单信息，
next
50192241
，则将从标准输入中读取下一行。如果行和模式不匹
-271 -
第十章 
我们检查输入记
“底部抽屉”
并将结果
---
## Page 254
以下是整个程序：
我们对这些值进行累计，直到读完最后一条记录。END 过程用于打印报告。
然后我们对这些值进行一些算术运算：
易地记住每个出现所表示的意思：
接着我们将数组的每个独立的元素指定给一个特定的变量。这主要是为了更容
函数返回的元素的个数被保存在变量 sV中。
割到数组 order 的元素中：
有
这个脚本的下面部分将每个字段分割为子值。$i提供当前字段的值，
，将执行else 语句，在屏幕上打印出错信息。
NF >= 3 {
# addemup 
#! /bin/sh 
amt [title]
vol [title] += copies
total_amt += amount 
total_vol += copies
amount = copies * price
copies = order [2]
title = order[1]
#结束循环
print "Incomplete Record"
procedure
 else
SV
 cat addemup
(sv ==
for （i = 3;i >”
当运行程序时，
只符，以提示执行了哪个print语句。在下面的例子中，我们只简单地使用变
$INDEXDIR/format. idx
$INDEXDIR/combine. idx 
$INDEXDIR/pagenums. idx | tee page.tmp 
 $INDEXDIR/input. idx $FILES 
else
if (PRIMARY)
if ($0 ~ /retrieving/) print ">> retrieving" >"/dev/tty"
该
的
测
，你可以用tee 命令将输出重定向到一个文件，同时也将输出用管道传
”是作为一对字符来用的，用来立即引起对输出的注意，
print (">>PRIMARY:", PRIMARY)
else
if (SECONDARY)
QQ群：
如果它遇到字符串“retrieving”
50192241
print (">>TERTIARY:", TERTIARY)
pr int (">>SECONDARY:", SECONDARY)
- 276 -
，可以在 print 语句中插入标
它将打印一个信息。
第十章 
，试图理解这些基本结
，修改程序就像是重新
“底部抽屉”
“！!”也是-
---
## Page 259
要认识到 awk 脚本通常只限定在固定领域，程序主要是要解决某个特定的问题
另一个和防御技术有关的方面是错误处理。换句话说就是一旦程序检测到错误
删除程序的另一部分。你迟早会发现引起问题的那部分代码。
Slash and burn
可以使程序打印出错信息和/或使程序终止。
具有所希望的数据类型。
误不应被认为是程序问题。
各种类型的输入错误和不一致会使脚本的运行出现问题。你可能会认为用户错
可以用“slash and burn”来了解程序是如何工作的。首先，使用样本输入运
当所有的方法都失败时，
这里将条件注释掉，使得print 语句能够无条件地被执行。
号去掉并用一个编辑命令来恢复这些行，而不至于影响程序的注释。
这样在后续的编辑中就能注意到它们，并做想应的处理。也便于将这些注释符
利用注释排除干扰
文件 page.tmp 中。相同的输出通过管道输送到 combine.idx。
通过添加“tee page.tmp”
时
你可能想在处理每个记录前对它进行验证，确保存在正确的字段数或指定字段
御”过程包围起来，
为脚本设置防御措施
在样本输入上运行修改过的程序并和原始的输出相比较。看发生了什么变化。
行
之
循
结果是核心程序中断时，
点
另一个简单的技术是注释掉一系列可能引起问题的行，
原始程序，并保存输出。
间的所有语句及相应的大括号。如果问题仍然存在（程序仍然中断）
环，看它是否是引起问题的原因。确信删除的是完整的单元，例如，
技术，
失。当然，
#% if（thisFails）
却是在全部放弃或重新从头开始之前一个有效的办法。有时当仅有
print "l give up"
要对程序做一个备份并在临时备份上删除行。这是一个非常笨
QQ群：
以俘获不一致的输入记录和防止程序的意外失败。例如，
50192241
这是惟一可以用来查找出现什么问题的方法。其思
 可以使用编辑器来删除命令或删除部分程序直到错误
因此，