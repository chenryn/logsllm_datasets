为了进一步提高语法的正确性，我们将变异后的中间表示（IR）转换回SQL查询，并通过解析器执行语法验证。如果解析成功，则认为该查询没有语法错误，并在下一阶段使用它。否则，将丢弃新的IR并尝试生成另一个。

图5展示了对示例IR进行变异以生成三个新查询的过程。具体来说，在V26的右子元素中插入了一个ORDER BY子句；用CountClause替换了V8的右子元素，使新查询能够计算原始结果中的行数；删除了Vb的右子元素，从而有效去除了WHERE子句。这三个新生成的IR都是语法正确的。

### 未知类型处理
如第4节所述，某些IR由于在抽象语法树（AST）中缺乏相应的节点而被标记为Unknown类型。我们利用这种未知类型来实现模糊匹配，无需寻找具体的类型，这加快了查询生成的速度。尽管如此，一次性解析所需的语法验证仍然不受影响。然而，若无精确类型匹配，Squirrel可能会创建一些无效查询。

## 6. 语义引导实例化
语义正确的查询有助于深入理解数据库管理系统(DBMS)的执行逻辑，并有效地发现潜在缺陷。但针对结构化、语义绑定输入程序生成此类测试案例仍是一项未解决的挑战。先前研究表明，像jsfunfuzz这样的先进JavaScript模糊器所生成的测试案例在语义上往往是无效的。DBMS测试同样面临这一问题。

为此，我们提出了一种数据实例化算法，旨在提升生成SQL查询的语义准确性。如第5节所述，在变异后，IR程序形成了一个语法正确的框架，其中数据部分已被移除。我们的实例化过程首先分析不同数据间的依赖关系，随后填充满足所有这些依赖的具体值。经过此步骤后，查询极有可能在语义上也是正确的。

### 6.1 数据依赖推断
数据依赖描述了语义绑定数据间的关系，任何未满足的依赖都将导致查询无法通过语义检查。图6展示了四个SQL语句之间的数据依赖关系，其中包括三个CREATE语句和一个运行示例。每个变量均被替换为带有索引的x以区分不同的x。

这两个语句定义了两种类型的关系：“isAnElement”（虚线表示A是B的一个元素）和“isA”（实线表示A可以是B）。基于生命周期原则（即使用前必须先创建变量，并且一旦删除便不再使用）以及自定义原则（考虑数据类型、范围及操作确定关系），我们制定了一组规则来自动推导查询内数据间的依赖关系。

此外，我们还细化了每种数据类型，不仅描述其语义含义也反映使用上下文。例如，CREATE TABLE子句中的表具有CreateTable类型，而FROM子句中的表则具有UseTable类型。根据自定义原则，我们还指定了数据范围，以便识别潜在候选值的位置。例如，FROM子句中的表可以从任何已定义表中选择，因此具有UseAnyTable类型；而WHERE子句中的表只能来自FROM子句列出的表之一，故拥有UseFromTable类型。Squirrel在查询解析与转换期间识别并设置这些精确的数据类型。

### 6.2 IR实例化
Squirrel通过填充具体数据来实例化查询。算法1概述了其实例化流程。对于依赖图中的每棵树，我们按照广度优先搜索及语句顺序对节点排序，确保生命周期的正确性。对于整数等字面量数据，随机赋值或从预定义集合中选取（第5行）。对于语义绑定数据，则填入适当的有效名称。在此过程中维护两个映射：dataMap跟踪具有不同类型唯一名称，RelationMap将每个元素映射到其依赖项。若当前节点无依赖项（第6行），则要么定义新变量（创建唯一字符串作为名称）（第7-9行），要么为预定义术语如函数名（第10-13行）。若有父节点存在，则依据RelationMap查找合适值（第15-27行）。最后，将IR程序转回SQL查询输出。若因依赖关系不满导致失败，则说明IR程序包含语义错误。

图7显示了数据列值实例化结果及最终SQL查询。Squirrel给x1分配v1，因为它是不依赖其他项的CreateTable。接着按顺序处理x2至x9，并分别为它们命名。对于x12，其类型为UseAnyTable且依赖于x1，根据算法1第23行规定，我们把x1的名字v1赋予x12。其余数据类似处理即可完成实例化。

## 实现
Squirrel由总共43,783行代码构成，详见表1所示各组件细分情况。
- **AST解析器**：设计了一个通用AST解析器处理跨DBMS共通功能，并针对每个DBMS定制了解析器支持特定实现特性。基于Bison 3.3.2和Flex 2.6.4开发，遵循官方文档中描述的标准，专注于与数据库操作相关的语法部分。
- **Fuzzer**：基于AFL 2.56b构建，采用保留语法变异器及语义指导实例化器替代原有变异器。当发现有趣测试案例时将其剥离后的IR保存至库中，并在每次查询后清理数据库以减少交互影响。
- **应用扩展**：应用于其他DBMS可能需根据目标系统调整。首要任务是定制通用解析器支持独特功能；其次编写相应语义关系规则；第三，若DBMS运行于客户端-服务器模式下还需为其开发客户端。经验证明，整个过程通常不超过两天时间。

## 评估
我们在实际关系型DBMS上测试了Squirrel，以评估其在检测内存错误方面的有效性。特别是：
- Squirrel能否从生产级DBMS中检测出内存错误？(§8.1)
- 相较最新测试工具，Squirrel表现如何？(§8.2)
- 在DBMS测试中，基于语言正确性和覆盖率反馈的作用是什么？(§8.3)

### 基准
选择了SQLite、PostgreSQL、MySQL三种广泛使用的DBMS进行全面评估，并额外使用MariaDB仅用于错误查找。所有测试均采用默认配置和编译选项。Squirrel与五款模糊器进行了对比，包括基于突变的AFL、Angora，混合型QSYM，结构型GRIMOIRE以及生成型SQLsmith。虽然尽可能多地进行了测试，但仍遇到了一些兼容性问题，详情见表2。