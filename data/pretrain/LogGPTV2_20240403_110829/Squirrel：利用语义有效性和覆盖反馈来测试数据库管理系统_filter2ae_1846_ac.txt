为了进一步提高语法的正确性，我们将变异的IR转换回SQL查询，并使用解析器执行语法验证。 如果解析成功，我们得出结论该查询没有语法错误，将在下一阶段使用它。
否则，我们将丢弃新的IR，然后尝试生成另一个IR。
> 图5：IR程序的变异策略，包括基于类型的插入和替换，以及可选操作数的删除。
图5显示了对正在运行的示例的IR进行变异以生成三个新查询的示例。 具体来说，我们在V26的右子元素中插入ORDERBY子句，（因为）；
我们用CountClause替换V8的右子元素，其中新查询将对原始结果的行进行计数； 我们删除Vb的右子元素以有效删除WHERE子句。
这三个新的IR在语法上都是正确的。 **UnknownType：**
正如我们在§4中提到的，某些IR的类型为Unknown，因为它们在AST中没有相应的节点。
我们使用Unknown类型执行模糊类型匹配，而无需搜索具体类型，这可以加快查询的生成速度。 始终需要一次性解析的语法验证不受影响。
但是，如果没有精确的类型匹配，Squirrel可能会创建一些无效的查询。
## 6 语义引导实例化
语义正确的查询使模糊测试者可以深入了解DBMS的执行逻辑并有效地发现错误。
但是，对于模糊处理采用结构化，语义绑定输入的程序，生成语义正确的测试用例是一项尚未解决的挑战[44]。
先前的研究表明，由jsfunfuzz（一种最先进的JavaScript模糊器）生成的测试用例在语义上是无效的。 DBMS测试中也存在类似的问题。
我们提出一种数据实例化算法，以提高生成的SQL查询的语义正确性。 如§5所述，在进行突变后，IR程序是语法正确的框架，其中删除了数据。 我们的实例化程序
**首先分析不同数据之间的依赖关系，然后用满足所有依赖关系的具体值填充骨架。** 实例化之后，查询很有可能在语义上是正确的。
### 6.1 数据依赖推断
> 图6：数据依赖示例。 该示例由三个新的CREATE语句和我们正在运行的示例组成。 在“Relation”中，我们显示两种类型的关系：“
> isAnElement”（虚线）和“ isA”（实线）。
数据依赖性描述了语义绑定数据之间的关系。 任何不满足的依赖关系都将使查询无法通过语义检查。
图6显示了四个SQL语句之间的数据依赖关系，包括三个CREATE语句和我们的执行示例。 我们的语法正确的变异已将每个变量替换为x。
为了区分不同的x，我们为每个x分配一个索引。
这四个语句包含两种类型的关系：一种定义A是B（isAnElement）的元素，如x2所示的灰色虚线表示x1的列；
另一个描述A可以是B（isA），如x12所示的黑色实线可以是x1。
我们定义了一组规则，以自动推断查询中数据之间的依赖关系。 这些规则遵循两个原则。
生存期原则要求我们在使用SQL变量之前先创建它们，并在删除变量后停止使用它。 定制原则要求我们考虑数据类型，范围和操作来确定关系。
我们需要完善§4中提到的数据类型，以准确描述数据依赖性。
**数据类型：**
我们优化每种数据类型，以便它不仅描述语义含义，而且反映使用上下文。即使使用相同的基本类型，不同语句中的数据库元素也可以具有不同的依赖关系。基于生命周期原理，我们将定义/使用信息包含在数据类型中，以指示元素是新定义还是现有定义的使用。例如，CREATE
TABLE子句中的表将具有CreateTable类型，而FROM子句中的表将具有UseTable类型。根据自定义原则，我们还包括数据范围，以显示在哪里可以找到潜在的候选值。例如，FROM子句中的表可以是任何已定义的表，因此具有UseAnyTable类型，而WHERE子句中的表必须是FROM子句中的表之一，因此具有UseFromTable类型。变量的精确数据类型取决于其在AST中的位置。因此，Squirrel在查询解析和转换期间识别并设置数据类型。
图6显示了每个IR数据的精确类型。例如，x1是一个新定义的表，因此类型为CreateTable。 x2和x3的类型为CreateColumn。
x12具有UseAnyTable类型，因为它可以是任何已定义的表（x1，x4，x7），而x14只能是FROM子句中列出的表。
x10可以是FROM中表的任何列，而x15只能是表x14中的列。
**数据关系规则：** 使用精炼的数据类型，我们可以进一步定义数据关系规则，以帮助自动推断数据依赖性。 关系规则是四个元素的元组（A，B，C，D）
：A是关系目标，B是关系源；C定义关系；D表示关系的范围，
包括针对同一语句中的关系的intraStmt，针对多个语句的关系的interStmt，对于任何实例都适用，而对于根据Define-Use链最短路径的元素而言，最接近。
我们为所有DBMS定义了八条通用规则，为SQLite定义了一条附加规则，为MySQL定义了两条附加规则，为MariaDB附加了两条附加规则，为PostgreSQL附加了一条附加规则。
例如，关系规则（UseFromTable，UseTableColumn，isAnElement，nearest）意味着UseTableColumn类型的数据是同一语句中具有UseFromTable类型的最近数据的元素。
在图6中，我们可以使用此关系规则推断x15和x14之间的关系。
**依赖图：** 利用数据类型和关系，Squirrel会为每个突变的IR程序自动构造一个依赖图 _G_ = _{V,E}_ 。
中的每个节点都是IR数据及其数据类型。 _E_ 中的每个边缘描述了从边缘源到目标的一种关系。
如果数据类型可能依赖于两种或多种数据类型，我们将随机选择一种以避免循环依赖。 另外，如果有多个候选值用于从属类型，Squirrel会随机选择一个以建立边。
这样，图中的每个节点最多具有一个父节点，并且依赖图形成为一棵树或几棵树。 附录C包含有关依赖关系图构造的更多详细信息。
> 图7：IR结构的实例化。我们从图6的依赖关系创建一个具体的依赖关系图，替换所有占位符x，最后得到一个具体的新查询。
图7显示了从图6构建的一种可能的依赖关系图。例如，我们选择x1作为x12的依赖关系，尽管根据图6，它可以是（x1，x4，x7）中的任何一个。基于不同的选择，我们可以为每个突变的IR创建多个具体的数据依赖图。
有一些细节未在图中显示，例如x10应该是x2和x3之一。 Squirrel可以正确处理这些隐式依赖性。
### 6.2 IR实例化
> 算法1：语义实例化
Squirrel通过填写具体数据来实例化查询。算法1显示了我们的实例化算法。对于依赖关系图中的每棵树，我们都基于广度优先搜索和语句顺序对节点进行排序，从而保证了生命周期的正确性。对于整数之类的文字数据，我们将其设置为随机值或预定义值集中的一个（第5行）。对于语义绑定数据，我们填写适当的有效名称。在此过程中，我们维护两个映射：dataMap跟踪具有不同类型的唯一名称，而RelationMap将每个元素映射到其依赖项。如果当前节点没有依赖项（第6行），则它要么定义一个新变量（我们在其中创建一个新的唯一字符串作为其名称）（第7-9行），要么是一个预定义的术语，例如函数名（第10-行）
13）。如果当前节点有一个父节点，我们就知道它有一些依赖关系（第15-27行）：如果当前节点创建了一个新变量，我们只需为其生成一个唯一的字符串（第16-19行）；如果当前节点使用变量，则我们检查RelationMap为其找到合适的值（第22-23行）。最后，我们将IR程序转换回SQL查询并返回。如果由于不满意的依赖关系导致该过程失败，则IR程序将包含语义错误。
图7显示了数据和列值实例化的结果以及最终的SQL查询。 Squirrel将v1分配给x1，因为它是不依赖的CreateTable。
由于语句的顺序，我们接下来处理x2和x3并分别为其分配名称v2和v3。 我们以类似的方式处理x4-x9。
对于x12，它的类型为UseAnyTable，并且依赖于x1，因此根据算法1的第23行，我们将x1的名称v1分配给x12。 其他数据可以用相同的方式实例化。
## 7 实现
我们用43783行代码实现了Squirrel。表1显示了不同组件的细分。
> 表1：SQUIRREL组件的代码大小，共43783行
AST解析器。我们设计了一个通用的AST解析器来处理不同DBMS的通用功能，并为每个DBMS自定义解析器以支持特定于实现的功能。我们的实现基于Bison
3.3.2和Flex
2.6.4。我们的AST解析器的语法符合官方DBMS文档中描述的规范。我们支持该规范中的大多数语法，但是不涉及与管理功能相关的某些部分。通过这种方式，我们可以专注于测试与数据库操作有关的那些语法。
模糊器。我们在AFL
2.56b之上构建Squirrel，并用保留语法的mutator和语义指导的实例化器替换其mutator。当模糊器发现一个有趣的测试用例时，我们将其剥离的IR保存到IR库中。我们在每个查询之后删除数据库，以最大程度地减少不同查询之间的相互作用。
应用效果。将Squirrel应用于其他DBMS的工作可能取决于DBMS。首先，我们应该自定义通用解析器以支持目标DBMS的独特功能。其次，我们将根据语法编写语义关系规则。第三，如果DBMS在客户端-服务器模式下运行（例如MySQL和PostgreSQL），我们需要为其实现一个客户端。在我们的案例中，我们的一位作者花了一天的时间来定制解析器，而花了不到六个小时的时间来为我们测试的每个DBMS实施语义规则和客户端。我们认为，将Squirrel应用于另一个DBMS最多需要两天的时间。
## 8 评估
我们在实际的关系DBMS上测试了Squirrel，以了解其在查找内存错误中的有效性。 具体来说，我们的评估旨在回答以下问题：
>   * Squirrel是否可以检测来自实际生产级别DBMS的内存错误？ （§8.1）
>
>   * Squirrel是否可以胜过最新的测试工具？ （§8.2）
>
>   * DBMS测试中基于语言正确性和覆盖范围的反馈有哪些贡献？ （§8.3）
>
>
**基准:** 我们选择三种广泛使用的DBMS进行广泛评估，包括SQLite ，PostgreSQL
，MySQL。我们还使用Squirrel测试了MariaDB
，仅用于查找错误。我们使用默认的配置和编译选项来编译它们。我们将Squirrel与五个模糊器进行比较，包括基于突变的模糊器AFL
和Angora，混合模糊器QSYM
，结构模糊器GRIMOIRE和基于生成的模糊器SQLsmith。我们尝试运行尽可能多的测试，但是如表2所示，我们遇到了一些兼容性问题。由于MySQL需要客户端发送查询（即C
/ S模式），因此QSYM，Angora和GRIMOIRE无法直接对其进行测试。由于缺少接口，SQLsmith不正式支持MySQL。
PostgreSQL支持C /
S模式和单一模式，我们可以使用QSYM在单一模式下对其进行测试。但是，GRIMOIRE无法将PostgreSQL成功编译为单个静态二进制文件。
Angora可以编译它，但不能运行二进制文件。我们正在积极寻求潜在的解决方案。