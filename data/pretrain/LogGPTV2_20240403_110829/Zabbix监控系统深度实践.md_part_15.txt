同时，我们也可以通过“Administration”→“Audit"，在过滤条件中选择“Action"，就可
我们单击Event的时间，可以看到Action的细节，包括发送了信息的具体内容。
对于发送出去的消息，怎么查看历史消息呢？怎么获知什么时间发送了什么消息呢？在
注意，对于一个Host的报警，Zabbix只会把这个报警发送给对这个Host至少有“读”权
 Conditions：在后面进行介绍，因为它的设置是“Send message”和“Remote command"”
@Default message：使用默认的消息格式。默认这个是被打上勾的，取消选择，可以看到
 Send only to：选择的是给“Send toUser groups”和“Send to Users”中发送消息时使用的
 Send to Users：类似于“Send to User groups"，只是发送警报的对象换成用户。
默认定义的消息格式。
Media type。比如选择了“Email”，那么就会向前面的User发送电子邮件。
·Global script：在Administration-Scripts 中定义的一些命令。
的两个。
所共有的。
Monitered
图6-5
---
## Page 118
认的去运行。
启apache
如果Zabbix用户想要有这个权限，需要修改下sudoer文件。
能发送命令给它让它执行呢？
个是必然的，因为 active 模式的 Zabbix Agent 其实根本没有在服务器上安装 Zabbix Agent，怎么
Zabbix Agent。还有一点要注意，对于 active 模式的 Zabbix Agent，是无法执行远程命令的。这
中，“EnableRemoteCommands”这一项要设置为1，否则无法远程执行命令。修改后记得重启
本（即Custom scriptes）一定要在 zabbix_agentd.conf 中预先定义，而且在zabbix_agentd.conf
在Remote command 中，还支持Macro定义。
要不是cat个文件之类的，都足够了。如果在多行写多个命令，Zabbix会按照顺序执行。而且，
发送的命令长度也有限制，即不能超过255个字符，这个对于一般的命令是绰绰有余的了，只
的命令，下面看看Remote command的应用场景。
如果 Host上某一类Interface有多个（比如多个Zabbix Agent实例），那么Zabbix会选择默
对于剩下的“Conditions"，它有两个选项“Not ack”和“Ack”，“ack”是“acknowledge”
zabbix ALL=NOPASSWD:/etc/init.d/apache restart
#允许“zabbix”用户可以在不需要密码的情况下运行/etc/init.d/apacherestart，即重
#允许“zabbix”用户不需要密码就可以运行所有root 权限的命令
shell> visudo
对于远程执行命令，权限也是个问题。默认情况下，Zabbix是没有权限来重启系统服务的，
zabbix ALL=NOPASSWD:ALL
相比上面介绍的发送消息，Remote command 稍显复杂。在Agent上执行的自定义脚
Zabbix无法通过ZabbixProxy向ZabbixAgent发送，一定要从Zabbix Server发起。而且
（5）弹性计算，根据系统情况，新增或删除云节点。
（4）根据CPU负载，自动进行虚拟机的调配。
（3）在磁盘要满了的情况下，自动删除一些文件（比如/tmp）。
（2）当在服务器不响应时，使用IPMI的“reboot”命令重启服务器。
（1）应用无法响应时，自动重启某些应用。
Remote command最大的好处是什么呢？是自动。Zabbix会根据配置的条件，去执行对应
第6章报警配置
·103°
---
## Page 119
·104°
关的 Trigger 中关联的 Host。
务器是CPU密集型”，对应到 Zabbix，就是“CPU>20”且“Host 属于CPU Host group"。
就执行Action。比如CPU负载超过20这个Trigger，可能对于消耗CPU的服务器来说不需要报
一种条件。即Action不是直接和Triger挂钩的，而是可以配置一组条件，如果都满足这些条件，
Action之间，抽象了一个Condition的概念。“Condition”的中文意思是“情况”，可以理解为某
一类的 Trigger如果出问题了，就统一触发某个Action。Zabbix 就是这么做的，
“条件”就是Trigger，那不能对每一个Triger都设置一个Action 吧？最好的办法就是定义某
ack"，那么只有当Event 没有被“Ack”的情况下需要执行。
个事情。这里的“Not ack”和“Ack",表达的是在何种情况下需要执行Operation。如果选择“Not
的缩写，
Zabbix监控系统深度实践
Time period
Triggervalue
Trigger severity
Trigger name
Trigger
Host
Template
Host group
Application
Condition类型
6.3.3
最常用的是基于 Trigger 的 Event，在表6-5中，提到的 Host等，指的都是和这个Event 相
报警，肯定是基于某个条件的，比如某个服务器的CPU负载超过20。在Zabbix，这种
在Zabbix 中，意为某个Event是否被人“认领”了，可以理解为，有没有人在处理这
Condition
in,not in
=>=
like,not like
三，
=，<>
=，like,not like
<>
<>
支持的操作
Event生成的时间是否属于某一个范围
Trigger是OK 还是PROBLEM
Trigger的严重等级的范围
Tigger名字是否和一个字符串匹配
触发的 Trigger 是否是某一个Trigger
Host 是否是某一个Host
Trigger 是否属于一个Template
Host 是否属于一个 Host group
notlike：AppA的名字中不包含“APP”
like：AppA的名字中包含“APP"
=：AppA 的名字和APP完全一致
称为AppA，设置的字符串称为APP
限定Application，我们把生成这个Event的Trigger所关联Item的Application
表6-5
说
明
，它在Trigger 和
---
## Page 120
西还不能是在维护中，否则明明有人是在维护这台服务器，Zabbix却还在拼命报警，就不好了。
想很有道理，一般来说，我们的 Action 都是在某样东西出问题时才需要行动的，而且，这个东
是“Maintenance status=not in maintenance”。为什么 Zabbix要有这两个Condition 呢？其实仔细想
PROBLEM的时候会触发。反之亦然。
会被删除，这个Action也会被禁用，防止出现错误执行Action，并且只能由用户自己重新启用。
Proxy
Host name
Host metadata
Proxy
Receiver value
Uptime/Downtime
Discovery status
check)
Discovery rule (Discovery
Service port
Servicetype
Host IP
Maintenance
Condition类型
Trigger 的值是会变的，如果设置了“Trigger=Problem"，表示的是当 Triger从 OK 变成
表6-7是基于Active agent auto-registration 的 Condition。
表6-6是基于Discovery的Event可以使用的 Condition。
当创建一个Action 的时候，默认会有两个Condition：一个是“Trigger=PROBLEM"，另一个
如果设置的Condition中的任何一个对象（Host等）被删除了，那么这个相关的Condition
status
in,not in
支持的操作
=，<>
=，<>，>=，=，=
=，>
=，
=<>
=>
like,not like
like，not like
表6-7
表6-6
是否使用某个Proxy监控
收到的数据是否满足一定条件
Up状态或者Down状态超过或者小于一个时间段
和Lost四种
Discovery属于哪种状态，共有Up，Down，Discovered
Discovery 规则是否是某一个特定的
服务的端口是否在某个范围内
创建Discovery规则时可以选择的那几个
Discovery是否属于某个服务，服务有 SSH等，就是在
IP是否在某个范围内
说
是否被某个Proxy监控
Host的 Hostname是否满足条件
Host的元数据是否满足条件
明
第6章报警配置
●105
续表
---
## Page 121
·106°
Condition之间的逻辑运算符有以下几种。
比如需要同时满足两个Condition，又或者只要满足两个Condition 中的一个等，Zabbix支持的
Zabbix监控系统深度实践
Node
Host
Template
Host group
Event type
Application
那么最后组合的 Condition 就是（Host group = Oracle servers or Host group = MySQL servers）
OAND/OR：根据选择的条件，自动调整。
OR：所有Condition满足一个就行了
AND：所有Condition同时满足。
Event支持的Condition都介绍完了，对于不同的Condition的组合，Zabbix 也有一套逻辑，
O Trigger是“normal”状态。
Trigger是“unknown”状态。
@ Low-level discovery 规则是“normal”状态。
Item是“normal”状态。
Event type 中的事件类型有以下几种。
表6-8是基于 Zabbix内部事件的 Condition。
·Triger name like ‘Database is unavailable”
如果选择不同的Condition，它就变成OR。比如有下面这些Condition：
=，<>
=，>
=，>
=,like, not like
Event是否属于某一个Node（Node是Zabbix分布式部署的一个节点）
Host 是否是某一个 Host
Template是否是某一个特定的
Host group是否是某一个 Host group
事件的类型（目前支持的类型我们在表格后介绍）
和基于 trigger的event 中的介绍一致
表6-8
选择相同类型的Condition 时，它就变成 and；
---
## Page 122
所有 Escalation Steps 都是从 Host（或者其他）结束Maintainence 状态后开始。
period 也只会影响Action 执行与否，而不会影响Action中的 Operation 执行与否。
地说，
Escalation Step 都会被执行。Maintainence 状态不会停止Operation，只会对Action有关系。简单
情况。
没有限制，Zabbix只会从第一个开始逐个执行。
每一个步骤可以定义一个Action和持续时间。步骤（1）要在报警发生后马上发出，步骤个数
有重启成功），那么就要通知工程师来进行恢复了。这是一个报警扩散的过程，即Escalation。
起了，可能首先是重启PHP进程，那么如果过了一段时间这个故障还没有恢复（即PHP进程没
6个小时都没有人处理，这个故障还没有恢复，那么可能就要汇报给经理了。或者，PHP进程挂
（4）当 Host 在 no-data Maintainence 状态时发生问题，在结束 no-data Maintainence 状态时，
一些额外的操作。比方，一台服务器磁盘满了，可能马上需要通知的是一线的运维工程师。如果
6.3.4
（3）在Maintainence状态时发生了问题，并且在Maintainence状态结束后依然没有恢复
（1）出问题的Host在发出第一个报警后进入了Maintainence状态：这个Action剩余的
（5）不同的Escalation Steps 非常接近互相有重叠部分：每一个Escalation 都会接替之前的
Escalation是一个比较复杂的机制，特别是跟其他的东西结合起来之后，下面看一些常见
Escalation 的意思是“增加，扩大”，在Zabbix中，它指的是一个报警在一定条件下，会执行
可以定义一个“Escalation Step”，意为“扩散步骤”，定义何时扩散报警，以及如何扩散。
可以向用户发送恢复通知。
① Remote command 可以在事件发生后马上执行，也可以在一定时间没有解决后才执行。
◎报警可以升级，发送给更多的用户。
发生问题后，第一时间通知用户。
Zabbix中，支持的Escalation有以下几种。
一旦这个Action被执行，那么其中的每一步都会执行。
延迟报警。
在问题解决前，每隔一段时间向用户报警。
Escalations
第6章报警配置
107
---
## Page 123
·108·
程师去解决。
发送消息的内容中加上类似“这个问题已经10小时没有处理”之类的话，提醒收到报警的工
进行下面的设置。
Trigger恢复了，那么就会打断这些事件。
点都会将报警发送给MySQLAdministration用户组中的所有用户，当然，如果在这个过程中，
个操作。
设置为“1800”秒，即要求中的30分钟。
大家理解。
这个Action的消息了。
信息会被发送。其中后面的那条信息会在发送的信息前加上“NOTE：Escalationcancelled:action
执行一个动作。这些行为跟Event和Action相关。
Escalation，但是由于步骤（1）是在问题发生后马上执行的，所以“之前的Escalation”至少会
Zabbix监控系统深度实践
‘<Action name》’disabled”。这样，用户就会知道Action已经被禁用了，之后也不会收到关于
（6）在Escalation执行过程中，Action被禁用了：正在发送过程中的信息和之后的那一条
在问题发生后，如果10个小时还没有恢复，那么这个问题就会通知到资深DBA，可以在
（2）将escalation steps 设置为“From 2to 2"，意思就是只在第（2）步中执行。
（1）在Operation标签中，将默认时间设置为“36000”秒，即10个小时。
如果示例1中的问题一直没有解决，我们希望把这个问题通知到更加资深的DBA，可以
通过这样的设置，假设Action是0点0分触发的，那么在0点30分、1点、1点30、2
（2）在 Steps 的地方设置为“From 1 to 5"，表示Escalation Step 的第一到第五步都是执行这
2.示例2
（1）在Action 的Operation标签中,将“Default operation step duration”（默认操作间隔时间
1.示例1
Escalation 稍微有点复杂，但很有用，下面一起看几则关于Escalation的例子，希望能帮助
---
## Page 124
我们设置了默认的时间间隔是1800秒，即30分钟。
知用户，最后使用IPMI命令，重启MySQL服务器。如图6-6所示。
给DBA经理，如果还解决不了，会尝试重启数据库。如果依然解决不了，那么只能发邮件通
（3）在02:00、02:10和02:20向Zabbix administration用户组发送邮件。
（2）在02:00和02:10向Database manager用户组发送邮件。
（1）在00:00、00:30、01:00、01:30会向MySQL administration用户组发送邮件，这是由于
（4）在04:00向Guests用户组发送邮件。
假设问题是在00:00发生的，那么它的执行顺序如下。
最后看一个自定义Duration的例子，先看是如何设置Action的，如图6-7所示。
4.示例4
当出现问题时，先通知MySQLAdministration，
3.示例3
AclonCond
Action
Conns
Actionopeation
Action operntions
Nea
New
1-0
Steps
1800(mnirmm60 seconds)
1000
Sendmeage iousergrous: Guests via Ei
Detalls
Rumremote con
Send message tousergroups:Guests vin Em
Sendmesge to user grops:Dat
Sendmessge tousergroup:MSQLAdnistrat vinE
Details
60seconds)
图6-7
图6-6
如果问题持续10个小时，将这个问题发送
ators vis Emei
04:00:00
02:00:00
02:00:00
Start in
04:00:00
02:00:00
Imediatey
Startin
Defaut
3600
Duration(ec)
Deflaut
Detlauit
Duration (secAction
Action
第6章报警配置
Remove
Remove