n
u
R
icrobenchmarks
MC
Figure 7. Performance of rewritten microbench-
mark class ﬁles relative to the performance of
the corresponding original class ﬁles.
Application Performance
1.425
1.181
1.253
1.217
1.082
1.062
1.067
1.032
Original Classes
Modified Classes
Modified Optimized
s
e
s
s
a
C
l
1.6
1.4
1.2
1
0.8
0.6
0.4
0.2
0
d
e
i
f
i
d
o
m
n
U
o
t
e
v
i
t
a
e
R
e
m
l
i
t
n
u
R
JavaCup
Jess
OTP
LinPack
Applications
Figure 8. Performance of rewritten application
class ﬁles relative to the performance of the
corresponding original class ﬁles.
sured the performance of these systems in three conﬁgu-
rations: their original unmodiﬁed state, their state after be-
ing rewritten, and their state after being rewritten with the
leaf method optimization discussed in section 4.5. Gen-
erally, when we discuss results in this section, we refer to
the optimized numbers.
5.1. Microbenchmarks
We ﬁrst measured a series of microbenchmarks to
stress-test
the JVM with certain language constructs:
looping, method and ﬁeld accesses, exception handling,
synchronization, and I/O. We used a microbenchmark
package developed at University of California, San Diego,
and modiﬁed at University of Arizona for the Sumatra
Project4. The results are shown in ﬁgure 7.
4The original web site is http://www-cse.ucsd.edu/
users/wgg/JavaProf/javaprof.html. The source we used
was distributed from http://www.cs.arizona.edu/sumatra/
As one would expected, tight loops suffered the worst
slow-downs: roughly a factor of two. When we rewrite
the loop, the termination check costs roughly the same as
the original loop termination check, so it’s sensible to see
a factor of two performance degradation.
For other microbenchmarks, we saw much smaller over-
heads. The overhead of handling exceptions, performing
synchronization, or doing I/O operations dominates the
cost of checking for termination. The largest overhead of
these was 14% for the synchronization microbenchmark.
The additional overhead can be attributed to performing
the termination check once for each iteration of the loop.
For the I/O and exception-handling microbenchmarks,
the performance ﬁgures are much better. Since I/O and
exception handling are relatively costly operations, mod-
iﬁcations don’t have as signiﬁcant an impact on perfor-
mance.
We observe that the leaf method optimization gener-
ally has a small performance beneﬁt. The loop method
invocation microbenchmark shows the most dramatic im-
provement; the optimized benchmark runs 30% faster than
the unoptimized benchmark. In one case, the exception
handling benchmark, the optimized program ran roughly
1% slower than the unoptimized program. Similar behav-
ior occurred in the Linpack macrobenchmark. The op-
timized programs are genuinely performing fewer termi-
nation checks, but still have a longer running time. The
culprit appears to be Sun’s JIT compiler (sunwjit). When
the benchmarks are run with the JIT disabled, the opti-
mized programs are strictly faster than the non-optimized
programs. We have observed similar deviant behavior
with Sun’s HotSpot JIT running on Sparc/Solaris and
Linux/x86. We have sent an appropriate bug report to Sun.
5.2. Application benchmarks
We benchmarked the real-world applications JavaCup5,
Linpack6, Jess7, and JOTP8. These programs were cho-
sen to provide sufﬁciently broad insight into our system’s
performance.
JavaCup, a parser-generator, was chosen to demonstrate
how the rewritten classes perform in handling text pro-
cessing. Jess, an expert system, was chosen to demon-
strate the performance of the rewritten classes in handling
symbolic data and solving logic problems. Linpack is a
loop-intensive ﬂoating-point benchmark. JOTP is a one-
time password generator which uses a cryptographic hash
function. The results are shown in ﬁgure 8.
ftp/benchmarks/Benchmark.java
5http://www.cs.princeton.edu/˜appel/modern/
java/CUP/
6http://netlib2.cs.utk.edu/benchmark/
linpackjava/
7http://herzberg1.ca.sandia.gov/jess/
8http://www.cs.umd.edu/˜harry/jotp/
Microbenchmarks
Application Benchmarks
Microbenchmark
Checks per Second
Application Benchmark
Checks per Second
Empty Loop
Loop Field Operation
Loop Method Invocation
Exceptions
Synchronization
Input/Output
Unoptimized
107
4
107
3
107
3
107
3
107
5
105
5
723
887
995
729
427
978
Optimized
107
843
107
914
107
515
107
366
107
082
105
713
4
3
3
7
4
9
JavaCup
Jess
JOTP
Linpack
Unoptimized
107
2
107
1
107
4
107
3
771
013
102
128
Optimized
107
152
107
501
107
905
107
598
2
1
2
2
Figure 9. Average number of termination checks performed per one second of increase in runtime for the
micro and application benchmarks.
For the JavaCup test, we generated a parser for the
Java 1.1 grammar. There was a modest 6% increase in
execution time. For the Jess test, we ran several of the
sample problems included with Jess through the system,
and calculated the cumulative runtimes. There was a 3%
increase in execution time. Both JavaCup and Jess repre-
sent applications which do not make extensive use of tight
loops. Instead, these applications spend more of their time
performing I/O and symbolic computations. Their per-
formance closely tracks the performance of the I/O mi-
crobenchmark.
For the Java OTP generator, we generated a one-time
password from a randomly-chosen seed and password, us-
ing 200,000 iterations. There was a 18% increase in run-
time. For the Linpack benchmark, there was a 25% in-
crease in runtime. Linpack is a loop-intensive program,
while JOTP makes extensive use of method calls as well
as loops. As a result, we would expect their performance
to more closely track the loop-based microbenchmarks.
Note in particular the beneﬁt JOTP got from the leaf
method optimization.
5.3. Termination check overhead
To gauge the actual impact of our class ﬁle modiﬁca-
tions, we counted the number of times we checked the ter-
mination ﬂag for each benchmark. Using this, we calcu-
lated the number of termination checks being performed
per every second increase in runtime overhead. The re-
sults for all benchmarks are listed in ﬁgure 9.
000
For the three looping microbenchmarks, We found that
roughly 40
000 checks are performed for every sec-
ond of runtime overhead. This evaluates to around 10
CPU cycles for each check performed. Likewise, for the
exception and synchronization microbenchmarks, while
the cost of performing these original operations far out-
weighs the cost of the termination checks, still we see the
same number of, and sometimes more, termination checks
per second of overhead.
For the input/output microbenchmark, however, only
around 970
000 termination checks are performed per
second of overhead. This can be attributed to the other op-
erations being performed by the input/output benchmark.
In particular, it needs to contend with the additional over-
head of the blocking call management code. It is also im-
portant to keep in mind that the cost of performing I/O far
outweighs the cost of termination checks.
The application benchmarks reﬂect the results of the mi-
crobenchmarks. All of these results fell within the same
range, between 15
000 checks per
second of overhead. Since none of the benchmarks per-
form any signiﬁcant amount of I/O, these ﬁgures are in
line with the microbenchmarks results.
000 and 29
000
000
These performance ﬁgures seem to indicate that for
real-world applications, the showdown will be roughly
proportional to how much the application’s performance
is dependent on tight loops. Applications which have tight
loops may experience at worst a factor of two slowdown
and more commonly 15
25%. Applications without tight
loops can expect more modest slowdowns, most likely be-
low 7%. The number of termination checks the system
can perform per second seems not to be a limiting factor
in system performance.
6. Soft termination in practice
In order to demonstrate our soft termination system, we
integrated it into the Jigsaw web server. Jigsaw is a free,
open Java-based web server which supports servlets9. We
integrated our bytecode-rewriting system into the servlet
loader for Jigsaw. Thus, every servlet that is loaded into
Jigsaw is ﬁrst rewritten to support soft termination.
We also wrote an administrative screen similar to the
top utility in UNIX. It provides a list of all active servlets
9http://www.w3.org/Jigsaw/

D

D

D

D

D

D

D

D

D

D

D

D

D

D

D

D

D

D

D

D







E
It also gives an option to terminate a
on the system.
servlet. Selecting this option activates the terminate signal
in the speciﬁed servlet. We observed that servlets would
take at most ten seconds to terminate.
A number of attacks against Java focusing on resource
exhaustion have been proposed [24]. Several of these fo-
cus on ﬂaws in Java’s access control framework. For ex-
ample, the standard recipe for designing such attack in-
cludes setting a threads priority to tt MAX PRIORITY to
help ensure the program does its job. Java speciﬁes an
access control privilege for changing thread priority. The
more serious Business Assassin applet relied on Java al-
lowing unprivileged threads to stop one-another. Our soft
termination system does not try to stop these attacks.
A number of other resource exhaustion attacks do
not take advantage of ﬂaws in Java’s security system.
These include creating threads which loop inﬁnitely,
overriding the Applet.stop() method, or catching a
ThreadDeath exception and recreating the thread. As
mentioned in section 4.4, soft termination successfully
stops such applets.
7. Conclusion
While Java and other general-purpose language-based
systems for codelets have good support for memory pro-
tection, authorization, and access controls, there is little
support for termination. Without termination, a system
can be vulnerable to denial-of-service attacks or even to
bugs where a faulty codelet has an inﬁnite loop.
We have introduced a concept we call soft termination,
along with a formal design and an implementation for Java
that allows for asynchronous and safe termination of mis-
behaving or malicious codelets. Soft termination can be
implemented without making any changes to the under-
lying language or runtime system. Our Java implementa-
tion relies solely on class-ﬁle bytecode rewriting, making
it portable across Java systems and easier to consider ap-
In real-world benchmarks,
plying to non-Java systems.
our system shows slow-downs of 3
25%. This could
possibly be further reduced if we could leverage a safe
point mechanism already implemented within the JVM.
A larger research area remains: building language run-
times that support the general process-management se-
mantics of operating systems. Because language runtimes
allow and take advantage of threads and memory refer-
ences that easily cross protection boundaries, traditional
operating system processes may not be the appropriate in
this new setting. Opportunities exist to design new mech-
anisms to add these semantics to programming language
runtimes.
8. Acknowledgments
Jiangchun “Frank” Luo and Liwei Peng helped imple-
ment an early prototype of this system. Matthias Felleisen
and Shriram Krishnamurthy provided many helpful com-
ments. This work is supported by NSF Grant CCR-
9985332.
References
[1] J. Alves-Foss, editor. Formal Syntax and Semantics of
Java. Number 1523 in Lecture Notes in Computer Sci-
ence. Springer-Verlag, July 1999.
[2] G. Back and W. Hsieh. Drawing the Red Line in
Java.
In Proceedings of the Seventh IEEE Workshop
on Hot Topics in Operating Systems, Rio Rico, Arizona,
Mar. 1999.
http://www.cs.utah.edu/flux/
papers/redline-hotos7.ps.
[3] G. Back, W. C. Hsieh,
and J. Lepreau.
Isolation,
Pro-
resource management,
cesses in KaffeOS:
and sharing in Java.
the Fourth
Symposium on Operating Systems Design and Im-
plementation (OSDI 2000), San Diego, California,
Oct. 2000.
http://www.cs.utah.edu/flux/
papers/kaffeos-osdi00-base.html.
In Proceedings of
[4] G. Back, P. Tullmann, L. Stoller, W. C. Hsieh, and
Techniques for the design of Java Op-
J. Lepreau.
erating System.
the 2000 Usenix
Annual Technical Conference, San Diego, California,
June 2000.
http://www.cs.utah.edu/flux/
papers/javaos-usenix00-base.html.
In Proceedings of
[5] P. Bernadat, D. Lambright, and F. Travostino. Towards
a resource-safe Java for service guarantees in uncoopera-
tive environments.
In IEEE Workshop on Programming
Languages for Real-Time Industrial Applications, Madrid,
Spain, Dec. 1998.
[6] G. Cohen, J. Chase, and D. Kaminsky. Automatic pro-
gram transformation with JOIE.
In Proceedings of the
1998 Usenix Annual Technical Symposium, pages 167–
178, New Orleans, Louisiana, June 1998.
[7] G. Czajkowski and T. von Eicken. JRes: A resource ac-
counting interface for Java.
In Proceedings of the ACM
Conference on Object-Oriented Programming, Systems,
Languages, and Applications, pages 21–35, Vancouver,
British Columbia, Oct. 1998.
[8] D. Dean. The security of static typing with dynamic link-
ing. In Fourth ACM Conference on Computer and Com-
munications Security, Zurich, Switzerland, Apr. 1997.
[9] D. Dean. Formal Aspects of Mobile Code Security. PhD
thesis, Princeton University, Princeton, New Jersey, Nov.
1998.
[10] D. Dean, E. W. Felten, D. S. Wallach, and D. Balfanz. Java
security: Web browsers and beyond.
In D. E. Denning
and P. J. Denning, editors, Internet Besieged: Countering
Cyberspace Scofﬂaws, pages 241–269. ACM Press, New
York, New York, Oct. 1997.
[11] S. Drossopoulou and S. Eisenbach. Java is type safe —
probably. In Proceedings of the European Conference on
E
Object-Oriented Programming (ECOOP ’97), Jyv¨askyl¨a,
Finland, June 1997.
[12] S. Drossopoulou, D. Wragg, and S. Eisenbach. What is
Java binary compatibility?
In Proceedings of the ACM
Conference on Object-Oriented Programming, Systems,
Languages, and Applications, pages 341–358, Vancouver,
British Columbia, Oct. 1998.
[13] G. Edjlali, A. Acharya, and V. Chaudhary. History-based
access control for mobile code. In Proceedings of the 5th
ACM Conference on Computer and Communications Se-
curity (CCS ’98), pages 38–48, San Francisco, California,
Nov. 1998. ACM Press.
[14] U. Erlingsson and F. B. Schneider. SASI enforcement of
security policies: A retrospective. In Proceedings of the
1999 New Security Paradigms Workshop, Caledon Hills,
Ontario, Canada, Sept. 1999. ACM Press.
[15] M. Feeley. Polling efﬁciently on stock hardware. In Pro-
ceedings of the conference on Functional programming
languages and computer architecture, Copenhagen, Den-
mark, June 1993.
[16] M. Felleisen and R. Hieb. The revised report on the syn-
tactic theories of sequential control and state. Theoretical
Computer Science, 102:235–271, 1992.
[17] M. Flatt, R. B. Findler, S. Krishnamurthy,
and
M. Felleisen. Programming languages as operating sys-
tems (or revenge of the son of the Lisp machine).
In
Proceedings of the 1999 ACM International Conference
on Functional Programming (ICFP ’99), Paris, France,
Sept. 1999. http://www.cs.rice.edu/CS/PLT/
Publications/icfp99-ffkf.ps.gz.
[18] L. Gong. Inside Java 2 Platform Security: Architecture,
API Design, and Implementation. Addison-Wesley, Read-
ing, Massachusetts, June 1999.
[19] J. Gosling, B. Joy, and G. Steele. The Java Language Spec-
iﬁcation. Addison-Wesley, Reading, Massachusetts, 1996.
[20] C. Hawblitzel, C.-C. Chang, G. Czajkowski, D. Hu, and
T. von Eicken. Implementing multiple protection domains
in Java. In USENIX Annual Technical Conference, New
Orleans, Louisiana, June 1998. USENIX.
[21] M. Hicks, P. Kakkar, J. T. Moore, C. A. Gunter, and
S. Nettles. PLAN: A Packet Language for Active Net-
works.
In Proceedings of the Third ACM SIGPLAN In-
ternational Conference on Functional Programming Lan-
guages, pages 86–93. ACM, 1998. http://www.cis.
upenn.edu/˜switchware/papers/plan.ps.
[22] T. Lindholm and F. Yellin. The Java Virtual Machine Spec-
iﬁcation. Addison-Wesley, Reading, Massachusetts, 1996.
[23] D. Malkhi, M. Reiter, and A. Rubin. Secure execution of
Java applets using a remote playground. In Proceedings of
the 1998 IEEE Symposium on Security and Privacy, pages
40–51, Oakland, California, May 1998.
[24] G. McGraw and E. W. Felten. Securing Java: Getting
John Wiley and
Down to Business with Mobile Code.
Sons, New York, New York, 1999.
[25] K. Nilsen, S. Mitra, S. Sankaranarayanan, and V. Thanu-
Asynchronous Java exception handling in a
van.
real-time context.
In IEEE Workshop on Program-
ming Languages for Real-Time Industrial Applications,
Madrid, Spain, Dec. 1998. NewMonics, Inc. http:
//www.newmonics.com/news/conferences/
rtss/plrtia/async.exception.pdf.
[26] E. G. Sirer, R. Grimm, A. J. Gregory, and B. N. Ber-
shad. Design and implementation of a distributed virtual
machine for networked computers. In Proceedings of the
Seventeenth ACM Symposium on Operating System Prin-
ciples, pages 202–216, Kiawah Island Resort, South Car-
olina, Dec. 1999. ACM.
[27] R. Stata and M. Abadi. A type system for Java byte-
code subroutines. In Proceedings of the 25th ACM Sym-
posium on Principles of Programming Languages, pages
149–160. ACM, Jan. 1998.
[28] P. Tullman and J. Lepreau. Nested Java processes: OS
structure for mobile code. In Eighth ACM SIGOPS Euro-
pean Workshop, Sept. 1998.
[29] L. van Doorn. A secure Java virtual machine.
In Ninth
USENIX Security Symposium Proceedings, Denver, Col-
orado, Aug. 2000.
[30] D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten. Ex-
tensible security architectures for Java. In Proceedings of
the Sixteenth ACM Symposium on Operating System Prin-
ciples, pages 116–128, Saint-Malo, France, Oct. 1997.
[31] D. S. Wallach and E. W. Felten. Understanding Java stack
inspection. In Proceedings of the 1998 IEEE Symposium
on Security and Privacy, pages 52–63, Oakland, Califor-
nia, May 1998.