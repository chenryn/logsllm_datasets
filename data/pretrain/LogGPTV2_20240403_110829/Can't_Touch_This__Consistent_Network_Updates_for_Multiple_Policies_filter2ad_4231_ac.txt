technical result of this paper: we provide a rigorous proof that
the problem is alreadyNP-hard in n-node networks with k = 2
policies which could be consistently updated in R = 2 rounds.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:17:41 UTC from IEEE Xplore.  Restrictions apply. 
v
w
Fig. 3: Example conﬁguration where node w must be updated
after node v to avoid loops. A valid schedule is a superse-
quence of the sequence vw.
1
F BF B
F BF F
F F F B
F F F F
Round
2
F BBF
BF F B
3
BF BF
BF F F
F F BF
F F F F
TABLE I: Updateable nodes per round for a 3-round sched-
ule. F F F F nodes can be updated either in the ﬁrst or in
the third round. No BB nodes are possible in policy updates
solvable within 2 rounds, and hence, we do not need to
consider them.
1) Outline of Reduction: We prove the hardness by a
reduction from Max-2SAT [19]. Recall that in Max-2SAT,
the input is a formula in conjunctive normal form with two
literals per clause, and the task is to determine the maximum
number of clauses that can be simultaneously satisﬁed by
an assignment. Unlike the decision problem 2SAT which is
polynomial-time solvable, Max-2SAT is NP-hard.
Let us ﬁrst consider the problem of deciding whether the
policies can be updated in 3 rounds using only n touches
(so each node must be updated only once). An F B node
cannot be the last updated node (as it is symmetric to up-
dating a BF node in the ﬁrst round, which violates loop-
freedom), so nodes F BF B, F BF F and F F F B cannot be
updated in the third round. They can always be updated in
ﬁrst round and there is no beneﬁt of updating them in the
second round (as they may be updated as ﬁrst nodes during
the second round); hence, we can assume that they will be
updated in the ﬁrst round. Similarly, we will assume that
nodes BF BF , BF F F and F F BF are always updated in
the third round. Because F B nodes cannot be updated in the
third round and BF nodes cannot be updated in the ﬁrst round,
F BBF and BF F B nodes can only be updated in the second
round. Finally, nodes F F F F can be updated in any round,
but because, similarly as before, there is no beneﬁt in updating
them in the second round, we will assume that they are updated
in the ﬁrst or the third round. Note that we only consider
policies which are solvable within two rounds and hence, we
do not need to classify nodes of type BB. No 2-round solvable
policy update problem can include any BB nodes: such nodes
cannot be updated neither in the ﬁrst nor in the last (second)
round.
Because we can always update F F and F B nodes in the
ﬁrst round, and F F and BF nodes in the third round, so to
verify whether the schedule does not violate loop-freedom, it
is enough to check, whether F BBF and BF F B nodes can
be updated in the second round (that is that their update does
not violate loop-freedom). See Table I for an overview.
We will use this classiﬁcation in our reduction. For each
variable, we will create an F F F F node, and its value in the
Max-2SAT formula will be decided based on whether the node
is updated in the ﬁrst or the last round. For each clause, we
will create two nodes (one for each literal in the clause) and
each of them will be a BF F B node: they will always be
updated in the second round. In what follows we will use xi
to denote both a variable and node for this variable, and for
j to denote nodes
a clause Cj = l ∨ k we will use yl
j and yk
created for this variable.
Let us consider the (partial) graphs in Figure 4. Let us
assume that nodes v and w in both graphs are of type F F F F
and that the backward node in each graph is of type BF F B.
Then, in the graph on the top, v must be updated before the
backward edge (in the ﬁrst round), and in the graph on the
bottom, w must be updated after the backward edge (in the
third round).
v
w
Fig. 4: Examples of F F F F nodes which must be updated in
either ﬁrst or third round.
We will combine these two graphs to create a gadget
for each variable. Let us consider a variable xi, and two
clauses: Cj, which contains the literal xi, and Ck, which
contains the literal¬xi. Then, we will create a gadget as shown
in Figure 5. We will make xi an F F F F node, and both yxi
j
and y¬xi
k BF F B nodes. If we update the node for xi in the
ﬁrst round, then we can update yxi
j , and if we update xi in
the third round, then we can update y¬xi
.
k
For each variable, we will create such gadgets in both
policies, and the node corresponding to the variable will be
the same (physical switch) in both policies; therefore, either
it will be updated in the ﬁrst round in both policies, or in the
third round.
We will use the version of Max-2SAT,
in which each
variable occurs in at most three clauses. Therefore, we will
split the clauses, such that in a variable gadget in one policy
there will be two clauses, and in the other policy one clause.
Also, the nodes for each clause must be in different policies
(because of the clause gadget, which we will describe in
Section III-B2). We will describe how to split clause nodes
into policies in Section III-B7.
2) Clause gadget: Since in the Max-2SAT problem it is
enough that one literal in a clause is satisﬁed, we will need
to be able to update one of the clause nodes independently
of the variable nodes. To achieve this, we will use the gadget
presented in Figure 6, which will be a part of the variable
gadget. We will denote vertices created for clause Ci as d1
i
and d2
i . We will make them F F F F nodes, and hence, they
can be updated in either the ﬁrst or the third round. If d1
i gets
137
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:17:41 UTC from IEEE Xplore.  Restrictions apply. 
xi
yxi
j
y¬xi
k
Fig. 5: Outline of a gadget for variables.
v
w
z
Fig. 8: Gadget for creating nodes of required type.
updated in the ﬁrst round, then it enables the clause node in
the ﬁrst policy to be updated, but then, even if d2
i is updated, in
the second policy, the clause node has to be updated using the
variable gadget. Similarly if we update d2
i in the ﬁrst round,
and w in the third round, we can then update the clause node
in the second policy in the second round.
Because this gadget shares nodes between policies, clause
nodes must be in different policies.
d2
i
d1
i
d1
i
d2
i
C
C
Fig. 6: Gadget for updating clauses in one of the policies.
3) Specifying node type: There are some nodes in the
gadget, which we want to make forward nodes, when looking
from the point of view of the new policy (that is, we want to
guarantee that its second letter in the classiﬁcation is F ). As
an example, in Figure 7, v is a backward node which we want
to make a BF node. To do this, we will add a new node just
after v, which we will denote as w, and create an edge from
the end of the gadget to w. Then, we will create a new node
after the gadget and create an edge from w to this new node.
The construction is depicted in Figure 7. Node w is visited in
the new policy after the whole gadget has been visited (so also
after v), and therefore edge (v, w) is forward when looking
from the point of view of the new policy. Node w is now
an F B node, so it could possibly allow to update some BF F B
nodes, if updated in the ﬁrst round, therefore we will make w
a BF node in the other policy to force it being updated in the
second round.
v
w
Fig. 7: Construction to make v a BF node.
4) Nodes of required type: For some nodes in one policy
there is a required type in the other policy (e.g. a clause node,
which has to serve as an F B node). To create such nodes
we will use the gadget shown in Figure 8. In this gadget v is
an F F node, w is a F B node and z is a BF node.
138
5) Complete gadget for variable: In Figure 9 we present
the gadget for variable xi, and its two clauses Cj, containing
literal xi, and Ck, containing literal ¬xi. In this gadget we
included gadgets for both clauses. The essential edges of the
gadget (presented in Figure 5) are drawn in loosely dashed
black, edges of clause gadgets are drawn in loosely dashed
grey, edges added to change the node type (described in
Section III-B3) are drawn in densely dashed grey and the other
edges added to connect the graph are drawn in densely dashed
black. We will set the type of all densely dashed black and grey
edges to type BF in the other policy, so, unless 2 touches will
be used for them, they will be updated in the second or third
round, and therefore any update schedule must assume that
they will be updated after clause vertices.
1, ti
2, . . . ti
px.
ti
6) Transforming a Max-2SAT formula: In this section we
will show how to transform a Max-2SAT formula, so that each
variable appears in at most three clauses. Let φ be a Max-2SAT
formula with m clauses. Then for each variable x in φ, which
has px positive occurences and nx negative occurences, we
will create variables x1, x2, . . . , xpx , x1, x2, xnx. We will use
those variables to substitute occurences of x in φ (we will
substitute literal ¬x with variable xi, hence, we want xi to
be true iff x is false). For each i ∈ {1, . . . , px} we will create
nx. Similarly for each i ∈ {1, . . . , nx} we
variables ti
1, ti
will create variables ti
2, . . . ti
Now for each i∈{1, . . . , px} we will create clauses xi (cid:14)⇒
px (p (cid:14)⇒ q in 2SAT can be written
1 (cid:14)⇒ . . . (cid:14)⇒ ti
as ¬p∨ q). We also create similar clauses for each xi. Then
for each i ∈ {1, . . . , px} and j ∈ {1, . . . , nx} we create a
clause¬ti
that for each i ∈ {1, . . . , px} and j ∈ {1, . . . , nx}, xi and xj
i . If all these clauses are satisﬁed, they guarantee
j∨¬tj
cannot be both true. However, note that these clauses do not
guarantee that all variables for x have the same value, that is,
there may be some i, j such that xi is true and xj is false.
For each variable in φ, we create px(2(px − 1) + nx) +
nx(2(nx− 1)+ px) variables; clearly, this reduction is polyno-
mial. We will denote the resulting formula by φ′ and we will
denote the number of clauses of φ′ by m′. Now to ﬁnish the
reduction we will prove the following theorem.
Lemma 2. There is an assignment satisfying m− k clauses
of φ if and only if there is an assignment satisfying m′ − k
clauses of φ′.
are satisﬁed, so exactly k clauses are unsatisﬁed.
Proof: First, let us assume that there is an assignment that
satisﬁes m− k clauses of φ. Then, we will set xi = x, ti
j =
x, xi = 1− x and ti
j = 1− x. Then, all new clauses added to φ′
isﬁes m′ − k clauses of φ′. We will prove that there is an
assignment which satisﬁes at least m− k clauses of φ. For
each variable x let Px = {i ∈ {1, . . . , px} ∣
∣xi = 1} and
Nx = {i ∈ {1, . . . , nx} ∣
∣xi = 1}. Then we set x to be 1,
Now let us assume that there is an assignment that sat-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:17:41 UTC from IEEE Xplore.  Restrictions apply. 
d2
j
d1
j
xi
yxi
j
d2
k
d1
k
¬xi
k
y
Fig. 9: Complete gadget for a variable. The essential edges of the gadget (presented in Figure 5) are drawn in loosely dashed
black, edges of clause gadgets are drawn in loosely dashed grey, edges added to change the node type (described in Section III-B3)
are drawn in densely dashed grey and the other edges added to connect the graph are drawn in densely dashed black.
if ∣Px∣ > ∣Nx∣, and to 0 otherwise (thus we choose the value
of x based on the majority voting of variables xi and xi).
of those literals of x, which were true in φ′, but are false in φ)