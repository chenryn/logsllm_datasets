SKI, PKI(cid:1)
Responder R(cid:1)
Inputs:(cid:1)
SKR,PKR,RR(cid:1)
SKR, PKR(cid:1)
DH-KeyExchange(cid:1)
PKR, KIR(cid:1)
PKI, KIR(cid:1)
RI (cid:1)
(cid:3)
(cid:6)
(cid:4)
(cid:5)(cid:6)
)
(
c j PKI PK R
s.t. (IDj, c j ) (cid:2) RI
(cid:7)
(cid:6)
(cid:8)
(cid:9)(cid:6)
(cid:2)rj (cid:1) RI : BFI.insert(rj )
BFII
RR (cid:1)
(cid:3)
(cid:6)
(cid:4)
(cid:5)(cid:6)
)
(
ck PKI PK R
s.t. (IDk, ck ) (cid:2) RR
(cid:7)
(cid:6)
(cid:8)
(cid:9)(cid:6)
(cid:3)X (cid:1) r (cid:2) RR  s.t.
(cid:7)
(cid:8)
BFI.contains(r)
(cid:9)
(cid:4)
(cid:5)
(cid:6)
ckey (cid:1)R {0,1}160
rrand (cid:1)R {0,1}160
irand (cid:1)R {0,1}160
rkey (cid:1) KDF(irand, rrand)
rset (cid:1)
(cid:4)
(cid:7)
(cid:5)
(cid:7)
(cid:6)
HMAC(rkey, r)
(cid:3)r (cid:2) RI  s.t.
HMAC(ckey, r) (cid:2) cset
(cid:8)
(cid:7)
(cid:9)
(cid:7)
(cid:10)
ckey, rrand, cset
cset (cid:1)
(cid:3)
(cid:4)
(cid:5)
(cid:6)
HMAC(ckey, x)
(cid:7)
s.t. x (cid:2) X '
(cid:8)
rset,irand
rkey (cid:1) KDF(irand, rrand)
X (cid:1)
(cid:5)
(cid:6)
(cid:7)
r, (cid:4)r (cid:2) (cid:3)X  s.t.
HMAC(rkey, r) (cid:2) rset
(cid:8)
(cid:9)
(cid:10)
Figure 3: Friend Finding using Bloom ﬁlter based PSI (BFPSI).
• I can construct HMACs for each element of its own RI using
the received ckey as the key and check whether the resulting
HMAC is present in cset.
• For each of these elements, I computes HMACs with a key
rkey, obtained via a key derivation function using its own
random coin irand and rrand. The resulting response set
rset is sent to R, along with irand.
• R can recompute rkey, construct a HMAC on every element
using rkey and check if the resulting HMAC is found
of X
in rset. If it is, then that element is added to X.
(cid:3)
Remark: Relying on Bloom ﬁlters to realize private intersection
of high-entropy items yields constructions incurring only a con-
stant number of public-key cryptography operations and a reduced
communication overhead – a remarkable performance gain which
we further analyze in Sec. 5.
2.5 Security Considerations
We now analyze the security of our proposed techniques, follow-
ing security requirements outlined in Sec. 2.1.
Authenticity. Our proposed techniques guarantee authenticity of
claimed friendships, via bearer capabilities. These, by deﬁnition,
confer the same authorizations on anyone who holds them, One
potential concern is that users could maliciously re-distribute them
to other users. However, we assume that: (1) capabilities are stored
securely, and (2) parties who receive capabilities legitimately (hon-
est but curious) do not share them with others who are not author-
ized to receive them. We argue that such assumptions are reason-
able in the context of the Common Friends service, which is de-
signed to be implemented on mobile devices. These are usually
equipped with software and hardware platform security features
that can ensure application-speciﬁc secure storage [38].
Nonetheless, it is trivial to extend our constructions to support
“friendship certiﬁcates”, i.e., signatures issued on public keys of
(cid:3)
one’s friends. Note that friends can securely exchange public keys
via the server S, in the same way they exchange bearer capabilities.
At the end of the friend ﬁnding protocol interaction, once R has
, it can ask I to conﬁrm
determined the candidate intersection set X
(cid:3)
that it possesses a valid friendship certiﬁcate from each entity in X
Privacy. The proposed techniques reduce the problem of priva-
tely discovering common friends to secure computation of set in-
tersection. Thus, privacy of our proposals stem from the security of
the underlying protocol that Common Friends instantiates, e.g., the
PSI construction in [17], the PSI-CA variant in [14], or the BFPSI
variant we introduce. The security of the latter relies on the fact
that items are taken at a random from a large space, thus, while
we do not claim it achieves security comparable to traditional PSI
protocols, we can demonstrate that the BFPSI construction reveals
nothing besides the intended output.
Initiator’s Privacy (Proof Sketch). We prove that responder R learns
nothing about initiator I’s items outside intended output, regard-
less of the protocol variant. In the basic and cardinality-only vari-
ant, this follows immediately from the security of the underlying
PSI [17] and PSI-CA protocols [14], respectively. Whereas, in the
mutual-output variant (which relies on BFPSI), I’s privacy follows
from the one-way property of the hash functions used to construct
the Bloom ﬁlter and the unpredictability of input sets (bearer capab-
ilities). Recall that, in ROM, the hash of an unpredictable function
is a PRF, thus, if R could learn more than the intersection, it would
be violating the PRF properties. That is, let us assume that:
{R
∗
(f (IDR), f (IDR) ∩ f (IDI ))}
{ViewR(f (IDR), f (IDI ))}
(cid:3)
c(cid:8)≡
(f (IDR),f (IDI ))
(f (IDR),f (IDI ))
∗
∗ ∈ X
s.t. c
∗
) = 0. Since c
∗ (cid:8)∈ f (IDR) ∩
Then, there must exist one item c
f (IDI ), i.e., BFI .contains(c
is drawn from a
large space (computationally infeasible to enumerate), it must hold
that BF is invertible, thus, the hash function used for constructing
the Bloom ﬁlter is not a secure PRF.
Responder’s Privacy (Proof Sketch). Recall that, in the basic and
cardinality-only variants, I has no output from the protocol, and,
R’s privacy immediately stems from the security of the underlying
PSI [17] and PSI-CA protocols [14], respectively, thus, I’s view
should be efﬁciently simulated with only its inputs and outputs.
R’s privacy in the the mutual-output variant, i.e., protocol in
Fig. 3, is also straightforward. Recall that R sends I cset with the
HMAC of all items in the intersection (which is intended output of
the protocol). Recall that Bloom ﬁlters may introduce false pos-
itives, however, if I could learn something about the false positive
found by R, then the HMAC used to construct cset must not be a
secure HMAC. However, this is impossible since, in ROM, HMAC
is known to be pseudo-random [7].
3. FRAMEWORK DESIGN
We now present the design of our Common Friends framework
and discuss how developers can integrate it into their own applica-
tions. We argue that it is crucial to abstract away the details of un-
derlying cryptographic techniques, so that application developers,
who might not be cryptography experts, can easily rely on secure
and privacy-preserving techniques to discover common friends (and
possibly use them to guide trust and/or access control decisions).
Our goal is to do so in such a way that application developers:
(1) can use an intuitive and well-deﬁned API;
(2) only need to specify the kind of functionality they need (e.g.,
ﬁnding how many or which common friends);
164
Initiator device(cid:1)
App(cid:1)
Common 
Friends Service(cid:1)
Inputs:(cid:1)
SKI,PKI,RI(cid:1)
GetPublicKey(cid:1)
GetPublicKey
PKI(cid:1)
PK
Set up channel(cid:1)
IReq(cid:1)
accepted/rejected(cid:1)
Responder device(cid:1)
App(cid:1)
Common 
Friends Service(cid:1)
Inputs:(cid:1)
SKR,PKR,RR(cid:1)
StartResponder(IReq)(cid:1)
RRes(cid:1)
Initialize 
PSI state 
machine 
indicated 
by  type(cid:1)
Process(IRes)(cid:1)
ResultContainer(cid:1)
ProcessContainer(M)(cid:1)
ProcessContainer
ProcessContainer(M))
(M))
ResultContainer(cid:1)
ResultContainer
R ltC t i
ResultContainer
getResult(cid:1)
R l
Result, KIR(cid:1)
RRes(cid:1)
IRes(cid:1)
M(cid:1)
MM
M(cid:1)
MM
StartInitiator(RRes)(cid:1)
IRes(cid:1)
ProcessContainer(M)(cid:1)
(M)
ProcessContainer
PProcessContainer
P
(M)
ResultContainer(cid:1)
ResultContainer
ResultContainer
Initialize 
PSI state 
machine 
indicated 
by type(cid:1)
Optional(cid:1)
(possibly 
repeated 
many times)(cid:1)
getResult(cid:1)
tR lt
Result, KIR(cid:1)
Figure 4: Common Friend Service framework. Optional mes-
sage exchanges involving ProcessContainer invocations are used
by PSI protocols that require more than three message ﬂows.
Name
StartResponder
StartInitiator
P rocess
P rocessContainer
Input Output
RRes
IReq
IRes
RRes
IRes
RC
RC
M
getResult
-
P R
Invoker
R
I
R
R,I
R,I
Description
Triggers PSI
Triggers PSI; extracts KIR
Processes IRes
PSI variant speciﬁc method
Gets ﬁnal PSI result
and shared key KIR
Table 4: Common Friends service interface.
Notation
Description
type
IReq
RRes
IRes
RC
M
PR
Type of Common Friends