Systems (LCTES). 69–80.
[34] Úlfar Erlingsson, Martín Abadi, Michael Vrable, Mihai Budiu, and George C.
Necula. 2006. (XFI): Software Guards for System Address Spaces. In Proceedings
of the 7th Symposium on Operating Systems Design and Implementation (OSDI).
[35] Francisco Falcon. 2015. Exploiting Adobe Flash Player in the era of Control Flow
https:
Guard. In Black Hat Europe.
[36] Behrad Garmany and Tilo Müller. 2013. PRIME: private RSA infrastructure for
memory-less encryption. In Proceedings of the 29th Annual Computer Security
Applications Conference (ACSAC). 149–158.
[37] Dan Goodin. 2007.
Safari zero-day exploit nets $10,000 prize.
//www.theregister.co.uk/2007/04/20/pwn-2-ownwinner/.
[38] Brian Gorenc. 2017. Pwn2Own 2017 – An Event for the Ages.
//blog.trendmicro.com/pwn2own-2017-event-ages/.
https:
http:
[39] Shay Gueron. 2010. Intel® Advanced Encryption Standard (AES) New Instruc-
tions Set. Intel Corporation (2010).
[40] Hong Hu, Zheng Leong Chua, Sendroiu Adrian, Prateek Saxena, and Zhenkai
Liang. 2015. Automatic Generation of Data-Oriented Exploits. In Proceedings of
the 24th USENIX Security Symposium. 177–192.
[41] Hong Hu, Shweta Shinde, Sendroiu Adrian, Zheng Leong Chua, Prateek Saxena,
and Zhenkai Liang. 2016. Data-Oriented Programming: On the Expressiveness of
Non-Control Data Attacks. In Proceedings of the 37th IEEE Symposium on Security
& Privacy (S&P).
[42] Intel. 2015.
Software Guard Extensions SDK. https://software.intel.com/
sites/default/files/managed/b4/cf/Intel-SGX-SDK-Developer-Reference-for-
Windows-OS.pdf.
[43] Trevor Jim, J. Greg Morrisett, Dan Grossman, Michael W. Hicks, James Cheney,
and Yanling Wang. 2002. Cyclone: A Safe Dialect of C. In Proceedings of the
USENIX Annual Technical Conference (ATC). 275–288.
[44] Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss, Werner Haas,
Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael Schwarz,
and Yuval Yarom. 2019. Spectre Attacks: Exploiting Speculative Execution. In
Proceedings of the 40th IEEE Symposium on Security & Privacy (S&P).
[45] Koen Koning, Xi Chen, Herbert Bos, Cristiano Giuffrida, and Elias Athanasopou-
los. 2017. No Need to Hide: Protecting Safe Regions on Commodity Hardware.
In Proceedings of the 12th European Conference on Computer Systems (EuroSys).
437–452.
[46] Vadim Kotov. 2014. Dissecting the newest IE10 0-day exploit (CVE-2014-
http://labs.bromium.com/2014/02/25/dissecting-the-newest-ie10-0-
0322).
day-exploit-cve-2014-0322/.
[47] Volodymyr Kuznetsov, László Szekeres, Mathias Payer, George Candea, R. Sekar,
and Dawn Song. 2014. Code-pointer Integrity. In Proceedings of the 11th USENIX
Conference on Operating Systems Design and Implementation (OSDI). 147–163.
[48] MWR Labs. 2013. MWR Labs Pwn2Own 2013 Write-up - Webkit Ex-
ploit. https://labs.mwrinfosecurity.com/blog/mwr-labs-pwn2own-2013-write-
up-webkit-exploit/.
[49] Michael Larabel. 2016. The Current Spectre / Meltdown Mitigation Over-
head Benchmarks On Linux 5.0. https://www.phoronix.com/scan.php?page=
article&item=linux50-spectre-meltdown.
[50] Chris Lattner and Vikram Adve. 2005. Automatic Pool Allocation: Improving Per-
formance by Controlling Data Structure Layout in the Heap. In Proceedings of the
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI). 129–142.
[51] Byoungyoung Lee, Chengyu Song, Yeongjin Jang, Tielei Wang, Taesoo Kim, Long
Lu, and Wenke Lee. 2015. Preventing Use-after-free with Dangling Pointers
Nullification. In Proceedings of the 22nd Annual Network and Distributed System
Security Symposium, (NDSS).
[52] Haifei Li. 2011. Understanding and Exploiting Flash ActionScript Vulnerabilities.
[53] Joshua Lind, Christian Priebe, Divya Muthukumaran, Dan O’Keeffe, Pierre-Louis
Aublin, Florian Kelbert, Tobias Reiher, David Goltzsche, David Eyers, Rüdiger
Kapitza, Christof Fetzer, and Peter Pietzuch. 2017. Glamdring: Automatic appli-
cation partitioning for Intel SGX. In Proceedings of the USENIX Annual Technical
Conference (ATC).
[54] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval
Yarom, and Mike Hamburg. 2018. Meltdown: Reading Kernel Memory from User
Space. In Proceedings of the 27th USENIX Security Symposium.
[55] Yutao Liu, Tianyu Zhou, Kexin Chen, Haibo Chen, and Yubin Xia. 2015. Thwarting
memory disclosure with efficient hypervisor-enforced intra-domain isolation.
In Proceedings of the 22nd ACM Conference on Computer and Communications
Security (CCS). 1607–1619.
[56] Chris Lomont. 2016.
Introduction to Intel Advanced Vector Exten-
sions. https://software.intel.com/en-us/articles/introduction-to-intel-advanced-
vector-extensions.
[57] Vitaliy B. Lvin, Gene Novark, Emery D. Berger, and Benjamin G. Zorn. 2008.
Archipelago: Trading Address Space for Reliability and Security. In Proceedings
of the 13th International Conference on Architectural Support for Programming
Languages and Operating Systems (ASPLOS). 115–124.
[58] Ali Jose Mashtizadeh, Andrea Bittau, Dan Boneh, and David Mazières. 2015. CCFI:
Cryptographically Enforced Control Flow Integrity. In Proceedings of the 22nd
ACM Conference on Computer and Communications Security (CCS). 941–951.
[59] Marina Minkin, Daniel Moghimi, Moritz Lipp, Michael Schwarz, Jo Van Bulck,
Daniel Genkin, Daniel Gruss, Berk Sunar, Frank Piessens, and Yuval Yarom. 2019.
Fallout: Reading Kernel Writes From User Space.
[60] Daniel Moghimi. 2014. Subverting without EIP. http://www.moghimi.org/
subverting-without-eip/.
[61] Micah Morton, Jan Werner, Panagiotis Kintis, Kevin Z. Snow, Manos Antonakakis,
Michalis Polychronakis, and Fabian Monrose. 2018. Security Risks in Asynchro-
nous Web Servers: When Performance Optimizations Amplify the Impact of
Data-oriented Attacks. In Proceedings of the 3rd IEEE European Symposium on
Security & Privacy (Euro S&P).
[62] Tilo Müller, Felix C. Freiling, and Andreas Dewald. 2011. TRESOR Runs En-
cryption Securely Outside RAM. In Proceedings of the 20th USENIX Security
Symposium.
[63] Santosh Nagarakatte, Milo M. K. Martin, and Steve Zdancewic. 2015. Everything
You Want to Know About Pointer-Based Checking. In Proceedings of the 1st
Summit on Advances in Programming Languages, (SNAPL). 190–208.
[64] Santosh Nagarakatte, Jianzhou Zhao, Milo M.K. Martin, and Steve Zdancewic.
2009. SoftBound: Highly Compatible and Complete Spatial Memory Safety for C.
In Proceedings of the 30th ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI). 245–258.
[65] Santosh Nagarakatte, Jianzhou Zhao, Milo M.K. Martin, and Steve Zdancewic.
2010. CETS: Compiler Enforced Temporal Safety for C. In Proceedings of the
International Symposium on Memory Management (ISMM). 31–40.
[66] George C. Necula, Jeremy Condit, Matthew Harren, Scott McPeak, and Westley
Weimer. 2005. CCured: Type-safe Retrofitting of Legacy Software. ACM Trans.
Program. Lang. Syst. 27, 3 (May 2005), 477–526.
[67] Gene Novark and Emery D. Berger. 2010. DieHarder: Securing the Heap. In
Proceedings of the 17th ACM Conference on Computer and Communications Security
(CCS). 573–584.
[68] Panagiotis Papadopoulos, Giorgos Vasiliadis, Giorgos Christou, Evangelos
Markatos, and Sotiris Ioannidis. 2017. No Sugar but all the Taste! Memory
Encryption without Architectural Support. In Proceedings of the European Sym-
posium on Research in Computer Security (ESORICS). 362–380.
[69] Andrew Pardoe. 2017.
Security Features in Microsoft Visual C++.
https://blogs.msdn.microsoft.com/vcblog/2017/06/28/security-features-
in-microsoft-visual-c/.
[70] PaX Team. 2003.
Address Space Layout Randomization.
http://
[71] PaX Team. 2003. Paging Based Non-executable Pages. http://pax.grsecurity.net/
pax.grsecurity.net/docs/aslr.txt.
docs/pageexec.txt.
[72] David J Pearce, Paul HJ Kelly, and Chris Hankin. 2007. Efficient field-sensitive
pointer analysis of C. ACM Transactions on Programming Languages and Systems
(TOPLAS) 30, 1 (2007), 4.
[73] Niels Provos, Markus Friedl, and Peter Honeyman. 2003. Preventing Privilege
Escalation. In Proceedings of the 12th USENIX Security Symposium.
[74] Roman Rogowski, Micah Morton, Forrest Li, Kevin Z. Snow, Fabian Monrose, and
Michalis Polychronakis. 2017. Revisiting Browser Security in the Modern Era:
New Data-only Attacks and Defenses. In Proceedings of the 2nd IEEE European
Symposium on Security & Privacy (Euro S&P).
[75] Olatunji Ruwase and Monica S. Lam. 2004. A Practical Dynamic Buffer Overflow
Detector. In Proceedings of the 11th Network and Distributed System Security
Symposium (NDSS). 159–169.
[76] Felix Schuster, Manuel Costa, Cédric Fournet, Christos Gkantsidis, Marcus
Peinado, Gloria Mainar-Ruiz, and Mark Russinovich. 2015. VC3: Trustworthy
data analytics in the cloud using SGX. In Proceedings of the 36th IEEE Symposium
on Security & Privacy (S&P). IEEE, 38–54.
[77] Fermin J. Serna. 2012. CVE-2012-0769, the case of the perfect info leak. http:
//zhodiac.hispahack.com/my-stuff/security/FlashASLRbypass.pdf.
[78] C. Song, H. Moon, M. Alam, I. Yun, B. Lee, T. Kim, W. Lee, and Y. Paek. 2016. HDFI:
Hardware-Assisted Data-Flow Isolation. In Proceedings of the IEEE Symposium on
Security and Privacy (S&P).
[79] Bjarne Steensgaard. 1996. Points-to analysis in almost linear time. In Proceedings
of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming
languages (POPL). 32–41.
[80] Yulei Sui and Jingling Xue. 2016. SVF: interprocedural static value-flow analysis in
LLVM. In Proceedings of the 25th International Conference on Compiler Construction
(CC). 265–266.
[81] Bing Sun, Chong Xu, and Stanley Zhu. 2017. The Power of Data-Oriented Attacks:
Bypassing Memory Mitigation Using Data-Only Exploitation. In Black Hat Asia.
[82] Chia-Che Tsai, Donald E Porter, and Mona Vij. 2017. Graphene-SGX: A practical
library OS for unmodified applications on SGX. In Proceedings of the USENIX
Annual Technical Conference (ATC).
[83] Victor van der Veen, Dennis Andriesse, Enes Göktaş, Ben Gras, Lionel Sambuc,
Asia Slowinska, Herbert Bos, and Cristiano Giuffrida. 2015. Practical Context-
Sensitive CFI. In Proceedings of the 22nd ACM Conference on Computer and Com-
munications Security (CCS). 927–940.
[84] Stephan van Schaik, Alyssa Milburn, Sebastian Österlund, Pietro Frigo, Giorgi
Maisuradze, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2019. RIDL:
Rogue In-flight Data Load. In Proceedings of the 40th IEEE Symposium on Security
& Privacy (S&P).
[85] Giorgos Vasiliadis, Elias Athanasopoulos, Michalis Polychronakis, and Sotiris
Ioannidis. 2014. PixelVault: Using GPUs for Securing Cryptographic Operations.
In Proceedings of the 21st ACM Conference on Computer and Communications
Security (CCS). 1131–1142.
[86] Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. 1993.
Efficient Software-based Fault Isolation. In Proceedings of the 14th ACM Sympo-
sium on Operating Systems Principles (SOSP). 203–216.
[87] David Weston and Matt Miller. 2016. Windows 10 Mitigation Improvements.
Black Hat USA.
[88] Jisoo Yang and Kang G. Shin. 2008. Using Hypervisor to Provide Data Secrecy
for User Applications on a Per-page Basis. In ACM International Conference on
Virtual Execution Environments (VEE). 71–80.
[89] Yves Younan. 2015. FreeSentry: Protecting Against Use-After-Free Vulnerabil-
ities Due to Dangling Pointers. In Proceedings of the 22nd Annual Network and
Distributed System Security Symposium, (NDSS).
[90] Min Hong Yun and Lin Zhong. 2019. Ginseng: Keeping Secrets in Registers When
You Distrust the Operating System. In Proceedings of the Network and Distributed
System Security Symposium (NDSS).
[91] Bin Zeng, Gang Tan, and Greg Morrisett. 2011. Combining Control-flow Integrity
and Static Analysis for Efficient and Validated Data Sandboxing. In Proceedings
of the 18th ACM Conference on Computer and Communications Security (CCS).
A APPENDIX: ADDITIONAL
IMPLEMENTATION DETAILS
In Section 5 we discussed the encryption transformation which we
apply to the merged intermediate representation code. During our
experiments with applying our approach to various applications,
we encountered several corner cases that required special consid-
eration, when applying this transformation. In what follows, we
discuss the most important ones and how we addressed them.
A.1 Object Alignment
Although AES operates on 128-bit data blocks, sensitive objects
come in various smaller and larger sizes. To accommodate any
object size, we round up the size of sensitive objects to multiples
of 128 bits, and allocate them strictly on 128-bit boundaries. We
handle global, stack, and heap objects in the following ways.
Global and Stack Variables: LLVM’s IR supports the specification
of alignment for global and stack variables. We use this feature
to specify a custom alignment of 16 bytes for sensitive global and
stack variables and round up the size of these variables to a multiple
of 128 bits.
Heap Variables: We must ensure that the alignment requirements
are respected for objects allocated dynamically on the heap. To
achieve this, we provide custom memory allocation functions. These
custom memory allocation functions use the posix_memalign func-
tion to allocate memory aligned to 128 bit boundaries. We also
round up the size of the allocated region to the nearest multiple of
128 bits. Then, as part of our memory encryption transformation,
all sensitive calls to memory allocation library functions, such as
malloc and calloc, are automatically replaced with our custom
memory allocation functions.
A.2 Globals with Default Initializers
When global variables are initialized to default values, their mem-
ory is allocated in the .data segment and is initialized to the spec-
ified value at compilation time—there are no explicit StoreInst
instruction executed at runtime. Because our AES instrumentation
transforms explicit memory loads and stores, we must handle the
initialization of global variables in a separate way. This is achieved
by introducing an encrypt_globals function that encrypts all sen-
sitive global variables, and inserting a call to this function at the
start of the main function.
A.3 Sensitive Constants
The sensitive data domain may include constants which must be
encrypted in memory. By default, LLVM allocates constants in the
.rodata section, which is a read-only section. Attempting to write
to these objects as part of the encryption process would cause a
protection fault. In our implementation, we address this problem
by removing the constant specifier for these objects.
A.4 Environment variables
The sensitive data domain may include pointers to environment
variables, such as $HOME, which can end up being marked as sensi-
tive as a result of the over-approximation of our pointer analysis.
Data: List of objects annotated as SENSITIVE, sensitive
value flow sinks, pts-to and pts-from information
Result: List of all objects in the sensitive equivalence class
eq_class := List of objects annotated as sensitive;
new_objs := eq_class;
while !new_objs.isEmpty() do
ptr_set := ptrs which can point to objs in eq_class;
ptr_targets := targets of all ptrs in ptr_set;
new_objs := ptr_targets \ eq_class ;
eq_class := eq_class ∪ ptr_targets;
end
Algorithm 1: Find sensitive data equivalence class.
Encrypting these environment variables causes system calls such
as fopen to break, and thus these variables must not be modified.
We provide a cloneenv function, that first clones the value of the
environment variable, and returns a pointer to the cloned version.
Our memory encryption transformation replaces all sensitive calls
to the libc function getenv with this cloneenv function.