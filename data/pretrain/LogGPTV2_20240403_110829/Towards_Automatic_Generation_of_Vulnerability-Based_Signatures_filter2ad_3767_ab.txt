cepts everything LP,c does. Incomplete solutions will have
false negatives. We deﬁne soundness as ∀x : x /∈ LP,c ⇒
MATCH(x) = BENIGN, i.e., MATCH does not accept any-
thing extra not in LP,c.
Unsound solutions will have false
positives. A consequence of Rice’s theorem [26] is that no
signature representation other than a Turing machine can be
both sound and complete, and therefore for other represen-
tations we must pick one or the other. In our setting, we
focus on soundness, i.e., we tolerate false negatives but not
false positives. In Section 5 we show how to reformulate
our algorithm to generate complete but unsound signatures.
1
2.2 Vulnerability Conditions
The vulnerability condition c is a function which takes
an instruction I ∈ T and the current program state and re-
turns either EXPLOIT, indicating T |= c, or BENIGN and
a new program state reﬂecting the execution of I. The ﬁrst
instruction I such that c(I) = EXPLOIT is called the vul-
nerability point.
Intuitively, the vulnerability point is the
ﬁrst instruction which may cause unsafe execution, e.g., the
ﬁrst out-of-bounds write on line 11 of our running example.
Formally, a vulnerability condition c is a function
evaluation stack (e.g., CISC instructions may dereference a
calculated memory address all in the same instruction), and
M : ADDR → VALUE is a map from 32-bit memory loca-
tions to values (including both stack and heap addresses).
We can encode c as an algorithm, and as described in
Section 3 inline the encoding into the original program at
the vulnerability point during signature creation. Also note
that c need only be speciﬁed once for each type of vulner-
ability. Our contribution is not how to specify the vulner-
ability condition: we assume it is given. We note entire
programming languages are speciﬁed in a similar manner
to c (e.g., via formal operational semantics [45]), thus our
techniques should apply to any vulnerability condition that
can be stated with an algorithm.
In our running example the vulnerability condition is to
check each dereference to make sure it is within the allo-
cated bounds. One way to accomplish this is to shadow
each pointer ∈ T with a “safe” pointer value that records
the base address and size of the memory allocated. Then,
each dereference is checked to see if the corresponding safe
pointer would still be in bounds. A formal operational se-
mantics of this vulnerability condition may look like:
Γ, D, M, K (cid:9) *exp (cid:2) D, M, K (cid:2) *(cid:3) (cid:9) exp
Γ [n → SafePtr(m, s)] , D, M : [n → vn] , K(cid:2)*(cid:3) (cid:9) n
BENIGN if m ≤ n = 4 )
8
r e t u r n EXPLOIT ;
∗ u r l = i n p [ c ] ; c + + ; u r l + + ;
9
10
11
’ ) c + + ;
’ ) {
r e t u r n BENIGN ;
}
Figure 2. The TM signature for our running
example
program such as looping and memory aliasing, which may
lead to imprecision in the signature. Regular expression sig-
natures are the other extreme point in the design space be-
cause matching is efﬁcient but many elementary construc-
tions such as counting must be approximated, and thus the
least accurate of the three representations.
Turing machine signatures. A Turing machine (TM)
signature is a program T consisting of those instructions
which lead to the vulnerability point with the vulnerability
condition algorithm inlined. Paths that do not lead to the
vulnerability point will return BENIGN, while paths that
lead to the vulnerability point and satisfy the vulnerability
TM signatures can be pre-
condition return EXPLOIT.
cise, e.g., a trivial TM signature with no error rate is em-
ulating the full program. A TM signature for our running
example is given in Figure 2:
3
Symbolic constraint signatures. A symbolic constraint
signature is a set of boolean formulas which approximate
a Turing machine signature. Unlike Turing machine signa-
tures which have loops, matching (evaluating) a symbolic
constraint signature on an input x will always terminate be-
cause there are no loops. Symbolic constraint signatures
only approximate constructs such as loops and memory up-
dates statically. As a result, symbolic constraint signatures
may not be as precise as the Turing machine signature.
Let x:y represent an inclusive range, e.g., inp[1:5]
means input bytes 1 through 5, inclusive. Then the sym-
bolic constraint signature (after considerable simpliﬁcation
for readability) for our running example is given in Figure 3.
This signature states that the ten-byte input matches the
signature if the ﬁrst input byte is ’G’ or ’g’, followed by
anywhere from 0 to 4 space characters, followed by at least
3
A path in a program is a path in the program’s control ﬂow graph.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
! = ’
’ ) ∨
’∧ i n p [ 2 : 6 ]
( i n p [ 0 ] = ’ g ’ ∨ i n p [ 0 ] = ’G ’ ) ∧
[ ( i n p u t [ 1 : 5 ]
( i n p [ 1 ] = ’
( i n p [ 1 : 2 ] = ’
( i n p [ 1 : 3 ] = ’
( i n p [ 1 : 4 ] = ’
’∧ i n p [ 3 : 7 ]
’∧ i n p [ 4 : 8 ]
’∧ i n p [ 5 : 9 ]
! = ’
! = ’
! = ’
’ ) ∨
! = ’
’ ) ∨
’ ) ∨
]
’ )
Figure 3. The symbolic constraint signature
for our running example.
5 non-space characters. At least 5 non-space characters are
needed in order to overﬂow the 4-byte allocated url buffer.
Note this signature is created by unrolling the loops on lines
8-9 and 10-12 of the TM signature. Although in our ex-
ample we can statically infer how many times to unroll the
loop, in general such inferences are not possible and an up-
per bound to unroll loops must be provided (this is the same
approach taken by bounded model checkers [15]).
Regular expression signatures. Regular expressions are
the least powerful signature representation of the three, and
may have a considerable false positive rate in some circum-
stances. For example, a well-known limitation is regular ex-
pressions cannot count [26], and therefore cannot succinctly
express conditions such as checking a message has a proper
checksum or even simple inequalities such as x[i] < x[j].
However, regular expression signatures are widely used in
practice. The regular expression signature we would pro-
duce for our running example (using the data-ﬂow tech-
niques described in Section 3.4) is
[g|G][ ]*[ˆ ]{5,}, which matches any input that be-
gins with ’g’ or ’G’, followed by zero or more spaces, fol-
lowed by at least 5 or more (represented as {5,}) non-space
characters .
Other signature types. One of the main contributions
from our construction is any language class may be used to
represent a signature. The signature user is free to pick the
appropriate representation for their situation. We leave as
future work systematic and formal investigation into other
signature representations, e.g., context free languages.
2.4 Signature Operations and Efﬁciency
We summarize upper bounds for various signature op-
erations in Table 1. Due to space constraints, we prove
these bounds in the extended version of this paper [8]. The
vulnerability language LP,c is recognized by a vulnera-
bility signature representation via the MATCH operation.
Matching efﬁciency is likely a primary concern when pick-
ing a signature representation. Turing machine signature
Representation
Turing machine Sig.
Symbolic Constraint Sig.
Regular Expression Sig.
Creation
poly(N)
poly(N )
poly(N ) - exp(N )
Signature Size Matching
poly(N )
poly(N )
exp(N )
Undecidable Undecidable
poly(S)
O(S)
Minimization Equivalence
Undecidable
exp(S)
O(S 2)
exp(S)
O(S 2)
Table 1. Summary of approximate bounds for the three vulnerability signature representations we
consider for a program of length N and signature size S. poly(X) denotes a function polynomial in
X, and exp(X) denotes a function exponential in X.
matching is undecidable (since matching can be reduced
to the halting problem), and symbolic constraint signatures
matching can be done in polynomial time. Regular expres-
sion matching can be performed in linear time.
TM signatures are created by encoding and inlin-
ing the vulnerability condition, which takes polynomial
time.
Symbolic constraint signature generation requires
ﬁrst creating a TM signature,
then several additional
polynomial-time transformation such as unrolling loops a
ﬁxed number of times. Regular expression signature cre-
ation entails either solving the symbolic constraint signa-
ture, which may take exponential time (in fact, is PSPACE-
complete [8]), or performing data-ﬂow analysis on the orig-
inal program, which takes polynomial time. The former ac-
curately represents all solutions to the symbolic constraints,
while the latter approximates the original program via data-
ﬂow analysis and is less accurate (see Section 3.4).
Signature merging is another important operation. In our
model, merging signatures A and B is equivalent to per-
forming a single analysis of Lab = La ∪ Lb, that is, the
union of the languages for both vulnerabilities. The union
operation for TM signatures is done by creating a new con-
dition cab = ca ∨ cb that evaluates true if T (P, x) |= ca
or T (P, x) |= cb . The union operation for symbolic con-
straints is the disjunction of the individual constraints, i.e.,
either constraint system could be satisﬁed. The union oper-
ation for regular expression is the “or” (|) operator.
2.5 Monomorphic Execution Path (MEP) and
Polymorphic Execution Path (PEP) Signature
Coverage
We introduce the notion of vulnerability signature cover-
age in which we create a vulnerability signature with respect
to only a subset of program paths an exploit may follow.
The ability to consider subset of paths to a vulnerability (as
opposed to all program paths an exploit may follow) is im-
portant since creating a signature for all program paths that
lead to the vulnerability may be too expensive. Our signa-
ture creation techniques take an iterative approach in order
to be scalable where we successively improve signatures by
ﬁrst considering a small coverage, and then incrementally
increasing our coverage to include more program paths to
the vulnerability.
First, consider a single path in the program an input may
take that satisﬁes the vulnerability condition, which we call
Monomorphic Execution Path (MEP) coverage. Our initial
MEP path is usually the path taken by the sample exploit.
An MEP covers only those program instructions executed
by an exploit on a single path to the vulnerability point, ex-
cluding statements with no effect on the computation, e.g.,
line 6 in the sample exploit is semantically a no-op with re-
spect to the vulnerability. Within an MEP, for each condi-
tional branch encountered, one target is an instruction lead-
ing towards the vulnerability point, while the other target
is a state BENIGN. An MEP is therefore a straight-line
program. At the vulnerability point the vulnerability con-
dition is evaluated, which returns either BENIGN or EX-
PLOIT. The vulnerability signature consists of all inputs
that reach the EXPLOIT state. Note that straight-line pro-
grams do not imply that only a single input leads to the
vulnerability point: there usually exists many other inputs
x(cid:2) (cid:14)= x that both reach the vulnerability point and the vul-
nerability condition evaluates to EXPLOIT. For example,
exploits usually have a payload which executes arbitrary at-
tacker code. A straight line program will return EXPLOIT
for exploits with different payloads because the execution
of different variants only differ after the vulnerability con-
dition has been satisﬁed.
A Polymorphic Execution Path (PEP) coverage includes
many different paths (i.e., MEPs) to the vulnerability point.
A complete PEP coverage includes all paths to the vulner-
ability point. Therefore, a complete PEP coverage signa-
ture accepts all inputs ∈ LP,c, i.e., the signature is com-
plete. More formally, complete coverage is obtained by
generating a signature for a chop [27, 48] of the program,
which includes all instructions that may be executed be-
tween a read statement where an exploit may be read in
and the vulnerability point. A chop has two distinguished
nodes: vinit and vﬁnal . vinit corresponds to the input read
statement (if multiple input read statements exist, then
vinit is an abstract node that is connected to each read
vﬁnal corresponds
statement in the control ﬂow graph).
to the inlined vulnerability condition branch returning EX-
PLOIT. We outline our algorithm for computing the chop
in Section 3.2.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 