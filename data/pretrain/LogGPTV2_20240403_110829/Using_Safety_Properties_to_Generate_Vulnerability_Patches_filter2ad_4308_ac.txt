of p, acc_end = dest+(cols+1)*(size/cols)+1
by adding the initial value dest to the accumulated up-
date of p, (cols+1)*(size/cols) from acc, plus
the last write via pointer p at
line 22. Hence it returns
[dest,dest+(cols+1)*(size/cols)+1] as the ex-
pressions denoting the access range [A1, An].
Our access range analysis can be considered as a form of
pattern-based loop analysis [14] with several differences. On
one hand, access range analysis aims to derive the number of
loop iterations as an expression involving program variables
and/or constants, while pattern-based loop analysis aims to
derive the number of loop iterations as a constant. On the other
hand, access range analysis requires loops be normalized to ﬁt
the pattern required by pattern-based loop analysis, and relies
on loop canonicalization to normalize loops.
Loop Cloning. Access range analysis cannot be applied to
loops that LLVM cannot canonicalize. For those loops, Senx
uses loop cloning. As an example, consider the loop in
Listing 3, where Senx applies loop cloning to produce new
code code that preserves the number of loop iterations, but
removes code that causes side-effects. The new code can then
be used to safely return the access range in the generated patch.
Because the patch must be inserted into a function where
both the access range and allocation range are available, loop
cloning ﬁrst searches on the call between the function where
the buffer is allocated and the function where the loop resides
(i.e. F). If no such function can be found, Senx will not be
able to generate a patch. Otherwise, it designates the function
it ﬁnds Fp and then clones each function Fi along the call
chain from F until Fp into the new code that returns the access
range. As a result, each Fi is either a direct or indirect caller
of F or is F itself.
Loop cloning needs to satisfy two requirements: 1) F must
compute the access range and pass the access range to its
caller; 2) any direct or indirect caller of F must pass the
access range that it receives from its callee upwards to the
next function along the call chain. Each Fi is cloned using the
following steps.
1) Loop cloning clones
the entire code of Fi
into
Fi_clone.
2) Using program slicing, it removes all statements that are
not needed in order to compute the access range or pass
the access range to Fp. If Fi is F, it retains statements
on which the execution of inst is dependent. If Fi is
a direct or indirect caller of F, it retains statements on
which the call to F is dependent.
3) It changes the return type of Fi_clone to void and
removes any return statement in Fi_clone.
4) It adds two output parameters start and end to
Fi_clone. If Fi is F, it inserts statements immediately
before the (nested) loops to copy the initial value of
the pointer or array index used in the faulty access into
start, and statements immediately after the loops to
copy the end value of such pointer or array index into
end. If Fi is a caller of F, it changes the call statement
2
3 +
4
5
6
7
8 +
9
10
11
12
13 +
14 +
15
16
17
18
19
20
}
}
i f
!= ' \ 0 ' ) {
o u t [ i ++] = c ;
}
return i ;
i n t
i ;
char c ;
i = 0 ;
while
( ( c = * ( i n ++) )
( c == ' \ 1 ' )
c = * ( i n ++) − 1 ;
1 i n t decode ( const char * in , char * o u t ) {
2
3
4
5
6
7
8
9
10
11 }
12
13 char * u d f _ d e c o d e ( const char * d a t a ,
14
15
16
17
18
19
20 }
( r e t && ! decode ( d a t a +1 ,
f r e e ( r e t ) ;
r e t = NULL;
char * r e t = m a l l o c ( d a t a l e n ) ;
i f
}
return r e t ;
r e t ) ) {
i n t d a t a l e n ) {
Listing 3: A complex loop involving a complex loop exit
condition and multiple updates to loop induction variable on
multiple execution paths.
1 + void d e c o d e _ c l o n e ( const char * in , char * out , char
** s t a r t , char ** end ) {
char c ;
* s t a r t = i n ;
while
( ( c = * ( i n ++) )
( c == ' \ 1 ' )
c = * ( i n ++) − 1 ;
i f
}
* end = i n ;
!= ' \ 0 ' ) {
char * u d f _ d e c o d e ( const char * d a t a ,
i n t d a t a l e n ) {
char * r e t = m a l l o c ( d a t a l e n ) ;
char * s t a r t , * end ;
d e c o d e _ c l o n e ( d a t a +1 ,
i f
( r e t && ! decode ( d a t a +1 ,
f r e e ( r e t ) ;
r e t = NULL;
}
return r e t ;
r e t , &s t a r t , &end ) ;
r e t ) ) {
Listing 4: A cloned and sliced loop that no longer contains
any statements that have side-effects and returns the number of
iterations. Statements preﬁxed with ’+’ are added or modiﬁed
by Senx to count and return the number of loop iterations.
to include the two output parameters in the list of call
arguments.
After cloning each Fi, loop cloning inserts a call to the
last cloned function into Fp, which returns the access range
in start and end. Subsequently a patch will be synthesized
to leverage the returned access range.
To see how loop cloning works, consider the example
in Listing 3, which presents a loop adapted from a real
buffer overﬂow vulnerability CVE-2007-1887 [38] in PHP,
a scripting language interpreter. The buffer overﬂow occurs
in function decode. The loop features a complex loop exit
condition and multiple updates to loop induction variable in
that depend on the content of the buffer that in points to. The
result of loop cloning is shown in Listing 4. Loop cloning is
invoked with decode as F, and the faulty access at line 5
545
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
as inst. It ﬁrst ﬁnds that function udf_decode is on the
call chain to decode and in which the allocation range is
available. Because udf_decode directly calls decode, it
only needs to clone decode. It then clones function decode
into decode_clone, after which it applies program slicing
to decode_clone with line 5 and variable c and in that
are accessed at line 5 as the slicing criteria. decode also has
a potential write buffer overﬂow at line 8, but in this example,
we focus on generating a predicate that will check whether
in can exceed the end of the buffer it points to. The program
slicing uses a backward analysis and removes all statements
that are irrelevant to the value of c and in at line 5, including
line 2, 4 and 8. After program slicing, it changes the return
type of decode_clone into void and removes all return
statements. And it adds two output parameters start and
end to the list of parameters of decode_clone. Then it
inserts a statement at line 3 to copy the initial value of in to
start before the loop and a statement at line 8 to copy the
end value of in to end after the loop. Finally it inserts into
function udf_decode a call to decode_clone at line 14
and a statement to declare start and end at line 13.
The new code produced by loop cloning must not have any
side-effects. If such a side-effect free slice cannot be produced,
Senx aborts patch generation.
Function Calls. In some cases,
the extracted expressions
contain the results of function calls. In such cases, Senx
must be careful that it does not call functions in a generated
predicate that have side-effects.
Senx deﬁnes a side-effect as: 1) a possible change to the
memory visible outside of a function, or 2) an invocation of
a system call that has external impact, or 3) an invocation of
a function that has any side-effect. We refer to a function that
has no side-effects as a safe function. First, it considers any
write to a global variable as a side-effect. To be conservative,
it also considers any write via a pointer argument passed to
the function as a side-effect. Second, it uses a white-list of
common API functions and system calls that have no external
impact such as changing ﬁle system state or outputting to a
device or the network. An invocation of a function or system
call on the white-list is considered as having no side-effects.
Senx uses a ﬂow-sensitive, context-insensitive intraprocedu-
ral static analysis to identify the list of safe functions. In the
beginning, the list contains only the functions on the white-
list. Senx performs the analysis for every function of a target
program and adds each function that has no side-effects to the
list.
For each function, Senx maintains a set of its callee func-
tions that might be "unsafe". Whenever a new function F is
added to the list, Senx removes F from the set of "unsafe"
callee functions for each function that calls F. When such a
set becomes empty for a function, Senx considers the function
as "safe" and also adds the function to the list.
D. Expression Translation
Because the patches Senx generates are source code patches,
the predicate of the patch must be evaluated in a single
function scope. However, sometimes the allocation range is
computed in one function scope, while the memory access
range is computed in a different function scope. So the
expression denoting the allocation range and the expression
denoting the memory access range are not both valid in a
single function scope. To make the expressions both valid in
a single function scope, one possible solution is to send the
expression valid in a source function scope as a call argument
to a destination function scope where the expression is not
valid. This approach requires adding a new function parameter
to the destination function, and adding a corresponding call
argument at every call site of the destination function. We
decided not to use this approach because it requires code
changes to any function on the call chain from the source
function to the destination function. In addition, unrelated
functions that call any of the changed functions will also have
to be changed, resulting in a very intrusive patch.
Expression translation solves this problem by translating
an expression exps from the scope of a source function fs to
an equivalent expression expd in the scope of a destination
function fd. It does not require adding new function parame-
ters or call arguments like the aforementioned solution. Senx
uses expression translation to translate both the buffer size
expression and memory access range expression into a single
function scope where the predicate will be evaluated. We call
this process converging the predicate.
At a high level, expression translation can be considered
as a form of lightweight function summarization [17]. While
function summarization establishes the relations between the
inputs to a function and the outputs of a function, expression
translation establishes the relations between the inputs to a
function and a subset of the local variables of the function.
It works by exploiting the equivalence between the arguments
that are passed into the function by the caller and the parame-
ters that take on the argument values in the scope of the callee.
Using this equivalence, expression translation can iteratively
translate expressions that are passed to function invocations
across edges in the call graph. Formally, expression translation
can converge the comparison between an expression expa, the
memory access range expression in fa, and exps, the buffer
size expression in fs iff along the set of edges E connecting
fa and fs in the program call graph, an expression equivalent
to either expa or exps form continuous sets of edges along
the path such that expa and exps can be translated along those
sets into a common scope.
Note that variables declared by a program as accessible
across different functions such as global variables in C/C++
do not require the translation, although the use of such kind
of variables is not very common. We refer to both function
parameters and such kind of variables collectively as nonlocal
variables. And we refer to an expression consisting of only
nonlocal variables as a nonlocal expression.
The
low-level
implementation
expression
two functions. Function
translation in Senx consists of
translate_se_to_scopes,
is
the core of expression translation. It translates a particular
listed in Algorithm 2,
of
546
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
expression expr to the scope of all candidate functions along
the call stack stack.
Algorithm 2 Translating an expression to the scope of each
function on the call stack.
Input: stack: a call stack consists of an ordered list of call
instruction
expr: the expression to be translated
inst: the instruction to which expr is associated
Output: translated_exprs: the translated expr in the scope
of each caller function on the call stack
1: procedure TRANSLATE_SE_TO_SCOPES
2:
3:
4:
5:
6:
7:
(cid:46) Translate expr to an expression in which all the
variables are the parameters of f unc
f unc ←get_func(inst)
expr ←make_nonlocal_expr(f unc, inst, expr)
if expr (cid:54)= ∅ then
for call ∈ stack do
(cid:46) Substitute each parameter variable in expr with
expr ←substitute_parms_with_args(call, expr)
f unc ←get_func(call)
translated_exprs[f unc] ← expr
expr ←make_nonlocal_expr(f unc, call, expr)
if expr = ∅ then
its correspondent argument used in call
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18: end procedure
end if
end for
break
end if
return translated_exprs
We illustrate how it works with the code in Listing 2.
For simplicity, we use source code line numbers to represent
the corresponding instructions. To translate the buffer size
involved in the buffer overﬂow, Senx ﬁnds that the buffer
is allocated from a call to malloc at line 2 from the call
stack that
it associates with each memory allocation, and
invokes translate_se_to_scopes with stack =[line 9
], expr =“x*y+1”, inst =line 2 , f unc = foo_malloc.
The function ﬁrst converts “x*y+1” into a deﬁnition in which
variables are all parameters of foo_malloc, which we call
a nonlocal deﬁnition, if such conversion is possible. This con-
version is done by function make_nonlocal_expr listed
in Algorithm 3, which tries to ﬁnd a nonlocal deﬁnition for
each variable in expr and then substitutes each variable with
its matching nonlocal deﬁnition. make_nonlocal_expr
relies on find_nonlocal_def_for_var, which recur-
sively ﬁnds reaching deﬁnitions for local variables in a func-
tion, eventually building a deﬁnition for them in terms of the
function parameters, global variables or the return values from
function calls. Note that a nonlocal deﬁnition can only be in
the form of an arithmetic expression without involving any
functions. In this case, the resulting expr is also “x*y+1”
because both x and y are parameters of foo_malloc.
Algorithm 3 Making a nonlocal expression.
Input: f: a function
inst: an instruction in f
expr: the RHS expression associated with inst
Output: nonlocal_expr: the nonlocalized expr
(cid:46) mapping stores the nonlocal deﬁnition for each
variable within expr
for var ∈ expr do
if ¬ is_var_nonlocal(f, var) then
def ←ﬁnd_nonlocal_def_for_var(f, inst, var)
if def = ∅ then
1: procedure MAKE_NONLOCAL_EXPR
2:
3: mapping ← ∅
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
(cid:46) We cannot ﬁnd a nonlocal deﬁnition for var
return ∅
else
mapping[var] ← def
end if
end if