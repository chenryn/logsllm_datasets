and hook evasion techniques, such as name confusion. Because it does not depend
on these semantic information at all for monitoring API calls, but it depends on
only taint tags.
A similar technique as code tainting has been used in previous research [5][13]
to detect attacks by tainting received data from the internet and then monitoring
a control transfer to the tainted data. We leverage the technique for malware
analysis on API monitoring. The diﬀerence is that our approach sets taint tags
on code with obvious intention for monitoring its execution, whereas the previous
research taints all received data for detecting a control transfer to it.
3.3 Tag Types and Monitored Instructions
We use the following three types of taint tags for identifying the execution of
three types of instructions for API monitoring.
– api-tags are targeted for instructions in each API
– malware-tag is targeted for instructions in malware
– benign-tag is targeted for instructions in benign programs
We taint all instructions in each API with api-tags. We use this type of tags
to detect the execution of APIs at CPU. Moreover, we embed API-identiﬁer
information in each api-tag which we can use to distinguish the execution of each
type of APIs. Regarding malware-tag, we taint all bytes in malware executable
and dynamically generated code with malware-tags. We use malware-tags to
identify the caller instruction of APIs and detect the execution of malware’s
aapush ebpmov ebp, espretaaaacall API_naacall API_naacall API_naaaaaapi-tagmalware-tagbenign-tagAPI_n:malware.exebenign.exeAPI_maaaaaaMonitoringOut of targetOut of target............aa(1)(3)(2)(1)(2)(3)7
Fig. 3. Our API Monitoring against Anti-analysis
instructions. On the other hand, we taint all bytes in benign programs with
benign-tags. By benign programs, we mean all ﬁles which have been installed
on Windows by default, or in other words, all instructions except for those in
malware and APIs. We mainly use this type of taint tag to identify the caller
instruction of APIs and then exclude the API calls from monitoring target.
3.4 API Monitoring Mechanism
We use code tainting with the three types of taint tags for monitoring APIs
invoked from malware. When a CPU fetches an instruction and the instruction
has an api-tag, it conﬁrms the taint tag set on the caller instruction. There
are three cases as shown in Fig.2: the API is called from malware, a benign
process or the internal of other APIs (nested call). As for the ﬁrst case, shown
in Fig.2 (1), if the caller instruction has a malware-tag, it determines that the
API calling is from malware. Thus, it captures the API calling and collects the
information related to the API calling, such as its arguments. With regard to
the second, shown in Fig.2 (2), if the caller one has a benign-tag, it determines
the API calling is from a benign process. Thus, it is out of our target monitoring
and does not need to capture this API calling. As for the third, shown in Fig.2
(3), if the caller has an api-tag, it is a nested API call. nested API calls are
also excluded from our monitoring target, so that we can focus only on API calls
directly invoked from malware. This makes the behaviors of malware clearer and
easier to be understood.
In Fig.3, we explain the behaviors of our API monitoring approach against the
two anti-analysis techniques: code injection and stolen code. Fig.3 (a) shows the
behavior against code injection. When malware injects code from malware.exe to
benign.exe, the taint tags of the code are propagated. The API calling from the
injected code is a control transfer from an instruction with a malware-tag to an
instruction with an api-tag. Then, we can identify it as our target API calling. On
the other hand, Fig.3 (b) shows the behavior of calling a stolen API. When the
few instructions at the entry of the API are copied to the allocated memory area
in malware.exe, the taint tags set on the instructions are also propagated. The
call instruction, call stolen API, has a malware-tag and the copied instruction,
mov edi, edi, has an api-tag, so we detect the API calling and include it into our
monitoring target.
movedi, edipush ebpaaaaaapush ebpAPI:API+4:movebp, esp...jmpAPI+4malware.exeStolen API:mov  edi, edicall   stolen_APICopyaaaamovedi, edipush ebpAPI:movebp, esp...malware.exeaaabenign.exeaaaaaaaapi-tagmalware-tagbenign-tag(b) Stolen Code Malware(a) Code Injection MalwareData flowAPI Callingacall APIcall APIaaaCopy8
Fig. 4. Analysis Process of API Chaser
4 System Description
In this section, we introduce the overview of our API monitor, API Chaser, which
uses the API monitoring approach we mentioned in the previous section. First,
we brieﬂy explain the main components of API Chaser. Second, we illustrate
its malware analysis process. Third, we present the enabling techniques used in
API Chaser.
4.1 Components
API Chaser has been built on a whole system emulator, Qemu (actually on Ar-
gos). API Chaser has the following components: virtual CPU for API monitoring
and taint propagation, shadow memory to store taint tags for virtual physical
memory (hereafter ”physical memory”), and shadow disk to store taint tags for
a virtual disk (hereafter ”disk”).
The virtual CPU is the core component of API Chaser. It is a dynamic
binary translator to translate from a guest instruction to host native instructions.
With the dynamic binary translation, it conducts API monitoring by the way
which we mentioned in the previous section and taint propagation based on our
propagation policy, which we will explain in the later subsection.
The shadow memory is a data structure for storing taint tags set on data on
physical memory. When the virtual CPU fetches an instruction, it retrieves the
taint tag set on the instruction from the shadow memory.
The shadow disk is also a data structure for storing taint tags set on data
on a disk. When data with taint tags is written into a disk, the taint tags are
transferred from the shadow memory to the shadow disk and stored into the
corresponding entries of the shadow disk. On the other hand, in the case of
transferring data with taint tags from a disk to physical memory, the taint tags
are also transferred from the shadow disk to the shadow memory.
4.2 Analysis Process
Fig.4 describes the analysis process of API Chaser. There are two steps for API
Chaser to analyze malware: taint setting and analysis.
Taint Setting Step In the taint setting step, API Chaser conducts pre-boot disk
tainting, which sets taint tags on all the target instructions in a disk image ﬁle
before booting a guest OS. We will explain the detail of pre-boot disk tainting
in the following subsection.
aMalwareExecutable-Taint Propagation-API MonitoringaMalwareProcessPre-boot Disk TaintingaaTaint Setting StepTaint Analysis StepDisk Image FileGuest OSBootingShadow DiskShadowMemoryVirtual CPUaaParsingLocation infoSet taintaaaaaaa9
Fig. 5. Code Taint Propagation Example
Analysis Step In the analysis step, API Chaser ﬁrst boots the guest OS in-
stalled on the disk image ﬁle. During the boot, target ﬁles containing target
instructions are loaded onto physical memory. At the same time, the taint tags
set on the target instructions are also transferred from the shadow disk to the
shadow memory. After completing the boot, API Chaser executes malware and
starts analysis. During analysis, API Chaser conducts API monitoring and taint
propagation based on our policy.
4.3 Enabling Techniques
We explain the enabling techniques used in API Chaser to support our API
monitoring: pre-boot disk tainting and code taint propagation.
Pre-boot Disk Tainting Pre-boot disk tainting is an approach to set taint tags
on target instructions on a disk image ﬁle before booting a guest OS. Properly
setting taint tags on all target instructions is not an easy task because they may
be copied and be widespread over the system after a guest OS has booted up.
For example, after booting a guest OS, an instruction of an API may be on a
disk, loaded onto memory, swapped out to disk, or swapped in to memory. When
we set taint tags on a target instruction, we have to identify all the locations of
widespread instructions and set tags on all of them. If we miss to set tags on
any one of them, it allows malware to evade our API monitoring.
To avoid this troublesome taint setting, we use pre-boot disk tainting. The
procedure of it is as follows. First, it parses a disk image ﬁle containing target
instructions and identiﬁes the location where the target instructions are stored.
We use disk forensic tools [14] to identify ﬁles containing target instructions, and
then, if necessary, we acquire the oﬀsets of the target instructions from the PE
header of the ﬁles and identify the locations of each API using disassemble tools
[15][16]. Second, it sets taint tags on corresponding entries of a shadow disk based
on the location information. Before launching a guest OS, all instructions surely
reside on a disk and they are not widespread yet. Pre-boot disk tainting makes
taint setting simpler because all we have to focus on are target instructions on
a disk. We no longer need to care whether target instructions have been loaded
or not.
Our Taint Propagation Policy API Chaser basically conducts taint propa-
gation to track the movement of monitored instructions based on the following
rules.
– Data move operations: If a source operand is tainted, it propagates its taint
tag to the destination.
mov[edi], eaxif eaxis tainted:set the tag of eaxon [edi];else:if ‘mov’has a malware-tagset a malware-tag on [edi];call CryptEncrypt(,,, pbData, pdwDataLen,,,); if ‘call’has a malware-tag:for(i= 0; i < *pdwDataLen; i++) {set a malware-tag on pbData[i];}Target InstructionCode TaintPropagationHandling CodeRule1 and Rule2Rule310
– Unary arithmetic operations: A taint tag is preserved as it is.
– Binary arithmetic operations: If any one of source operands is tainted, it
propagates the tag of the source operand to the destination.
In addition to the above rules, we use our original taint propagation rules for
memory-write operations, called code taint propagation, to prevent malware from
avoiding our monitoring by generating code using implicit-ﬂow like code extrac-
tion. Implicit ﬂow is a process where a value with a taint tag aﬀects the decision
making of following code ﬂow. However, there is no direct dependency between
the value and other values operated in the following code. Thus, a taint tag is not
propagated over the implicit ﬂow, even though they are semantically dependent
on each other. It is reported that taint tags are not properly propagated in some
WinAPIs which use implicit-ﬂow-like processing in its internal[10]. Actually, we
observed that malware-tags set on code of malware were not propagated to its
dynamically generated code. This is because most of obfuscated malware has en-
crypted or compressed original code in its data section and it uses implicit-ﬂow
like behavioral processing to unfold compressed or encrypted code and extract its
original code. If we fail to properly propagate malware-tags, we miss to identify
the execution of the instruction of malware.
To solve this, we use code taint propagation for code dynamically generated
by malware. Code taint propagation has the following rules.
– Rule1: If an executed instruction is tainted with malware-tag and the source
operand of it is not tainted, the taint tag of the instruction, i.e. malware-tags,
is set on the destination operand.
– Rule2: If an executed instruction is not tainted or tainted with the other
tags, it does not propagate the taint tag of the instruction to its destination.
– Rule3: If an instruction calling an API is tainted with malware-tag, the
taint tag of the instruction, i.e. malware-tags, is set on the written data by
the API.
The bottom-left pseudocode in Fig.5 is an example of Rule1 and Rule2, illus-
trating the case of mov [edi], eax. If the source operand of the target instruction,
eax, does not have any taint tags and the opcode, mov, has a malware-tag, we
set malware-tags on the destination operand, [edi]. Consequently, it appears as if
it propagates taint tags of opcode to the destination operand of the opcode. The
bottom-right pseudocode in Fig.5 is an example of Rule3, illustrating the case
of call CryptEncrypt whose prototype is shown as below. The call instruction has
a malware-tag and it calls CryptEncrypt API, which is a function to encrypt the
passed data and write its output to the memory area pointed by the argument,
pbData. The argument, pdwDataLen indicates the size of the output data.
BOOL WINAPI CryptEncrypt(_In_ HCRYPTKEY hKey, _In_ HCRYPTHASH hHash,
_In_ BOOL Final, _In_ DWORD dwFlags, _Inout_ BYTE *pbData,
_Inout_ DWORD *pdwDataLen, _In_ DWORD dwBufLen);
We detect the moment when execution is returned from the API by monitor-
ing a control transfer from an instruction with api-tag to one with malware-tag,
and then set malware-tags on written bytes by acquiring the location of the
11
Fig. 6. Taint Tag Format
written bytes from pbData. It seems as if the taint tag of the call instruction is
propagated to the written bytes of the API called from the instruction. Owing
to code taint propagation, we can taint all generated code with malware-tags
and identify the execution of the code based on its taint tags. We will discuss
the side-eﬀects of code taint propagation in Subsection 8.4.
5
Implementation
In this section, we explain the detailed implementations of API Chaser, focusing
on extensions from Argos [5]. We present the taint tag format, the virtual CPU,
the shadow memory and shadow disk, the virtual DMA controller and API
argument handlers.
5.1 Taint Tag Format
We introduce the format of a taint tag stored in shadow memory and shadow
disk. The size of a taint tag is four-byte. There are three format types, as shown in
Fig.6: immediate format type for malware-tags and benign-tags, pointer format
type for api-tags, and not-tainted type. The format is chosen depending on the
type of taint tag. We distinguish the format type based on the highest bit of
a tag. In case of the immediate type, we distinguish malware tags from benign
tags based on the second highest bit. Current API Chaser uses only the highest
two bits, and the other bits are unused. On the other hand, in case of the pointer
type, a taint tag is a pointer to an API Tag data structure. An API Tag structure
is a data structure to store information related to API such as an API name, a
DLL name, and API argument handling functions. We create an API Tag data
structure for each API, and all instructions in each API have a taint tag with a
pointer to the same API Tag data structure.
5.2 Virtual CPU
The virtual CPU of Qemu (Argos) realizes virtualization with dynamic binary
translation. It translates from instructions of a guest OS to instructions for a host
OS to consistently emulate the guest OS on host OS. Argos adds a taint tracking
mechanism into the dynamic binary translation. That is, it propagates taint tags
from source operands to destination after executing each instruction based on
its taint propagation policy. In API Chaser, we have added two new functions
to the virtual CPU: API monitoring mechanism and code taint propagation.
Fig.7 (a) shows the mechanism of API monitoring in the virtual CPU. When
an API call is invoked from malware, i.e. the execution transferring from the
instruction with a malware-tag to the one with an api-tag, the virtual CPU
1a310UnusedImmediate TypePointer Type0A Pointer to API Tag ( Not NULL) 1:Malware 0:Benigntypedef struct _api_tag{api_name[MAX_NAME];mod_name[MAX_NAME];void (*arg_handler)(...);...} API_TAG;a0NULLNot tainted12
Fig. 7. Examples of Dynamic Binary Translation
retrieves the information related to the API through its API Tag data structure
pointed by the taint tag, and generates host native instructions for handling the
API, i.e. invoking API handler function. An API handler outputs an API name
and a DLL name, and internally invokes argument handling functions.
As for code taint propagation, Fig.7 (b) and (c) show the diﬀerence in the
behaviors between Argos and API Chaser. In case of Argos, when it reads a
guest OS instruction for writing memory, it generates a taint handling function
as host native code. The function propagates taint tags from source operands
to the destination, if the source has any taint tags. In case of API Chaser, it
generates its original taint handling function for code taint propagation. The
function sets malware-tags on the writing destination, if the source operand
does not have any taint tags and the opcode has a malware-tag.
5.3 Shadow Memory, Disk and Virtual DMA Controller
Shadow memory is an array of four-byte entries, where each entry corresponds
to a byte on physical memory. Argos originally has shadow memory, but it has