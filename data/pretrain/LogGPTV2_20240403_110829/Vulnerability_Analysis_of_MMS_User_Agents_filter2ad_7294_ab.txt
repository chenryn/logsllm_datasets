X-Mms-Transaction-ID
X-Mms-MMS-Version
X-Mms-Message-Class
X-Mms-Expiry
X-Mms-Message-Size
X-Mms-Content-Location URL
From
Subject
message type
id string
mms version
message class
expiry time
message size
sender
subject
1 byte
string
1 byte
1 byte
long-integer
long-integer
string
encoded-string
encoded-string
The delivery of the message to the ﬁnal recipient is
performed in two steps. First, the recipient’s User Agent
is notiﬁed that a new message is waiting for retrieval.
The notiﬁcation is generated by the MMS Relay and de-
livered as a WAP Push message transported via SMS to
the recipient’s phone. Second, the User Agent retrieves
the message using a WTP/WSP GET request directed to
the MMS Relay. The WTP/WSP GET is translated into
an HTTP GET by the WAP gateway. The URL con-
tained in the request (e.g., http://mmsc.telco.-
com/mmsc/?msgid=47110815) is used by the MMS
Relay to retrieve the actual message from the MMS Server
(the URL is part of the notiﬁcation message). The message
is returned to the User Agent in the body of the reply to
the GET request. The messages used for notiﬁcation and
retrieval are called M-Notiﬁcation.ind and M-Retrieve.conf,
respectively.
3.2 MMS Messages
MMS messages are structured in a way similar to Inter-
net email messages, and consist of a header and a body. The
header contains control information, while the body rep-
resents the message content. The body is encoded using
the MIME multi-part encoding scheme and mostly uses a
multi-part/related structure. Messages transferred
within the MMS infrastructure are encoded in plain text,
while messages sent to and from a User Agent are in binary
format (to reduce the size of the data during over-the-air
transport). The encoding schema is the one deﬁned by the
WAP architecture [21].
The MMS architecture deﬁnes eight MMS message
types or protocol data units (PDUs). These eight message
types can be categorized in three groups: requests (denoted
by the sufﬁx req), conﬁrmations (denoted by the sufﬁx
conf), which are used to indicate the result of a request,
and indications (denoted by the sufﬁx ind), which are used
for asynchronous notiﬁcations. The types and formats are
speciﬁed in [22]. Table 1 shows the message types associ-
ated with each operation.
We will focus on the two messages M-Notiﬁcation.ind
and M-Retrieve.conf, because these are the messages that
are sent to a User Agent and could be leveraged to exploit
a vulnerability in that component. Of these two messages,
Figure 3. The M-Notiﬁcation.ind header.
Field Name
Content
Encoding
X-Mms-Message-Type
X-Mms-Transaction-ID
X-Mms-MMS-Version
From
Content-Type
Date
To
Cc
Bcc
Subject
X-Mms-Message-Class
X-Mms-Expiry
X-Mms-Delivery-Time
X-Mms-Priority
X-Mms-Sender-Visibility
X-Mms-Delivery-Report
X-Mms-Read-Reply
Message-ID
message type
id string
mms version
sender
content-type
date
receiver
carbon copy
blind carbon copy
subject
message class
expiry date or delta
date
message priority
show sender
delivery report
read indication
message id
1 byte
string
1 byte
encoded-string
string and binary
long-integer
encoded-string
encoded-string
encoded-string
encoded-string
1 byte or string
long-integer
long-integer
1 byte
1 byte
1 byte
1 byte
string
Figure 4. The M-Retrieve.conf header.
only the M-Retrieve.conf message has a body.
The format of the M-Notiﬁcation.ind message and the
type of binary encoding used when sent over-the-air is
shown in Figure 3. The M-Retrieve.conf message is more
complex then the M-Notiﬁcation.ind message. The header
ﬁelds of this message are shown in Figure 4.
4 The MMS User Agent
The MMS User Agent is the sending and receiving end-
point in the MMS system; it encodes, decodes, and ren-
ders MMS messages for the user. Due to the nature of the
system, the User Agent application needs to interact with
two different kinds of networks: First, the phone network
for receiving WAP Push messages (via SMS), and, sec-
ond, the IP-based network for sending and receiving the
actual MMS messages using WTP/WSP/HTTP. Since the
User Agent is not the only application that needs to receive
WAP Push messages, an intermediate component handles
all WAP Push messages and routes each message to the spe-
ciﬁc destination application, according to its content-type or
WAP-Application-ID. The intermediate component is often
called the PushRouter.
MMS User Agents normally have a few standard conﬁg-
uration options. With these options the user can decide if
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:30:50 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006messages should be downloaded immediately after receiv-
ing the notiﬁcation, or if the download has to be explicitly
requested by the user. These options are described in [20]
as immediate and delayed retrieval, respectively. Other op-
tions concern the MMSC address (e.g., http://mmsc.telco.-
com/mms) and the WAP gateway IP address and port.
4.1 The PocketPC MMS User Agent
The User Agent we analyzed is MMS Composer (Ver-
sion 2.0.0.13) from ArcSoft [2], which is the standard
User Agent that is shipped with our test device, an i-mate
PDA2k Phone1. Other PocketPC-based smart phones use
the same application, in different versions.
As mentioned above, the PushRouter handles all WAP
Pushes on the device. Conﬁguration information and the list
of target applications for WAP Push messages can be found
in the WindowsCE Registry at HKEY LOCAL MACHINE/-
Security/PushRouter. The User Agent application
executable is tmail, which is executed by the PushRouter
for each received WAP Push message with a content-type
of application/vnd.wap.mms-message.
An important feature of the PocketPC PushRouter appli-
cation is that it accepts WAP Pushes via both SMS and UDP
on port 2948, which is the IANA-assigned WAP Push port.
More interestingly, the UDP port is open on all network in-
terfaces (e.g., the wireless LAN interface). This feature is
leveraged by our virtual MMS system, which is described
in Section 5.3.
The delivery of an MMS message to a PocketPC-based
device is performed through a series of steps. First, the in-
coming WAP Push notiﬁcation (M-Notiﬁcation.ind) is de-
livered to the tmail application by the PushRouter. If the
tmail application is conﬁgured for immediate download,
it retrieves the message and displays the “new message”
symbol in the status bar. If the application, instead, is con-
ﬁgured for delayed retrieval, it ﬁrst displays the “new mes-
sage” symbol and then lets the user decide if he/she wants
to download the message or not. The message download it-
self is performed through a WTP/WSP GET of the message
URL, using the conﬁgured WAP gateway.
5 Analyzing the User Agent
The ﬁrst step in the analysis of the MMS User Agent was
to determine what kinds of inputs or attack vectors to the
application existed. These inputs would then be used for
1The i-mate PDA2k [7] is an OEM version of the HTC Blue Angel, a
so-called “smart phone” running the Windows Mobile 2003 Second Edi-
tion operating system. The device is based on an Intel XScale PXA263
processor, which is an ARM CPU. The device is equipped with a wireless
LAN (802.11b) interface, a Bluetooth interface, and multi-band GSM and
GPRS services.
fuzzing the User Agent application. The second step was
to determine if and how the messages used in the testing
procedure were modiﬁed by the MMS infrastructure. The
third step was to use the information gathered during the
previous two steps to implement a virtual MMS system that
would allow us to perform the security testing of the User
Agent application without depending on the mobile phone
network.
In the following sections we describe in more detail the
vectors used to test the User Agent, the analysis performed
to determine the effects of the MMS delivery infrastructure
on the messages, and the design of the virtual MMS system.
5.1 Input to the User Agent
We identiﬁed four main input methods to an MMS User
Agent. These four methods can be separated into two dif-
ferent categories: active and passive. Active methods can
be triggered directly from a remote device, while passive
methods require that the User Agent request the data (e.g.,
by initiating a GET request). The four input methods are de-
scribed below. The ﬁrst two belong to the active category,
while the last two are passive. Note that the two passive in-
puts are two sections of one message, the ﬁrst is the header
and the second is the body. We consider them separately be-
cause the MMS infrastructure treats them in different ways.
Also, none of the other message types have a body.
New Message Notiﬁcation. This is the M-Notiﬁcation.ind
MMS message. The User Agent receives this message
through a WAP Push. The message contains multiple
strings specifying: sender, receiver, and the download
URL for the actual message.
Delivery Indication. The M-Delivery.ind MMS message
type, as the notiﬁcation, is delivered through a WAP
Push. The message has a simple structure, since it just
indicates the delivery status of a sent message.
Message Header. This is the header of the M-Retrieve.conf
MMS message. The message is delivered to the User
Agent through the reply to a GET request. The header
contains multiple ﬁelds with different formats.
Message Body. This is the body part of the M-Retrieve-
.conf MMS message. We considered the header and
the body of the message separately because they are
treated differently by the infrastructure. More pre-
cisely, while the MMS headers are actually checked by
the various parts of the MMS infrastructure (and may
lead to the message being rejected), the message body
can be arbitrarily complex, and, therefore, it is more
difﬁcult to verify or sanitize.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:30:50 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006The other MMS message types are output generated by
the User Agent, and, thus, cannot be used to provide inputs
to the application.
5.2 Sanitization in the MMS Infrastruc-
ture
All messages submitted to an MMS Relay are subject
to veriﬁcation and possible modiﬁcation before being ac-
cepted for delivery. Messages failing the veriﬁcation step
are rejected and thus not delivered to their destination.
Because of this sanitization, a particular vulnerability
may not be exploitable, because the message part that is
used for an attack could cause the veriﬁcation process to
fail. In order to successfully attack an MMS User Agent,
sanitization has to be avoided, and, thus, its effects have to
be known. Identifying the sanitization rules of an MMS Re-
lay, therefore, is an important step in the analysis process.
To identify the sanitization rules and the message parts
that are not affected by the sanitization process, we tested
each message part (e.g., header ﬁelds and body parts) in-
dividually by submitting specially-crafted messages to an
MMS Relay.
Our fuzzing-like testing process works as follows: ﬁrst,
we create a list of message parts to be tested (e.g., the
header ﬁelds Subject, X-Mms-Message-ID, and Content-
Type); second, we deﬁne a number of applicable muta-
tion methods for each message part (e.g., string generator,
binary-string generator, or number generator); and, third,
each part is individually tested.
The test procedure assigns one of ﬁve modes to each
message part: unusable, truncated, scrubbed, deleted, and
not modiﬁed. These modes specify how the infrastructure
affects a message part. Initially all parts are marked as not
modiﬁed. The test output consists of the list of message
parts with the corresponding modes.
Testing each message part is done by ﬁrst generating a
value for the message part using one of the mutation meth-
ods. The message containing the generated value is then
sent through the infrastructure, and, ﬁnally, the result of the
submission is analyzed. If the submission is rejected, a new
value for the message part is generated using the same mu-
tation method and the message is sent again. If the mes-
sage is rejected again, the mutation method is changed. If
all mutation methods have been tried without success, the
message part is considered unusable and the next message
part is tested.
Accepted messages are retrieved and further analyzed. If
the message part is deleted, truncated, or modiﬁed, the re-
sult is recorded and the next message part is tested. If the
message part is not modiﬁed, then the same part is tested
again using a value generated by the next mutation method.
The next message part is tested after all mutation methods
have been tried or the part value is modiﬁed by the infras-
tructure.
At the end of the testing procedure, one has a precise
idea of the effects of the delivery process on the contents of
an MMS message.
5.3 The Virtual MMS System
The results collected by testing the sanitization process
performed by the MMS infrastructure were used to design
a virtual MMS system. The virtual MMS system is a test-
ing harness that allows one to test a User Agent application
using operational parameters that are identical to the ones
observed when using the actual mobile phone network. The
obvious advantages of using a virtual MMS infrastructure
are the ability to control every parameter of the delivery
process, the avoiding of usage fees, and the speeding up
of the actual testing. By using our virtual MMS system we
could speed-up the testing around 10 times. Delivery of
a single MMS message only takes about 6 seconds in the
virtual infrastructure while it takes at least 60 seconds when
using a real service provider infrastructure. A further advan-
tage of our virtual infrastructure is the possibility of testing
message-parts that would normally be ﬁltered/sanitized in a
real infrastructure. Although these message-parts may not
be exploitable in the real world, it is still important to test
how this information is handled by the User Agent.
The virtual MMS system consists of three components:
an HTTP server that acts as the MMS Relay, a WAP gate-
way, and the MMS message generator. The User Agent in-
teracts with these components using a wireless LAN.
HTTP Server. We used Apache [1] with the addition of
the MMS MIME type to the conﬁguration, so that
ﬁles with the mms extension are assigned the expected
content-type (namely, application/vnd.wap.-
mms-message).
WAP Gateway. We used the open-source WAP gateway
software Kannel [15] without any custom conﬁgura-
tion.
MMS Message Generator. The MMS message genera-
tor/fuzzer is based on MMSLib [14] a light-weight
MMS encoder library. The fuzzer generates binary-
-encoded MMS messages and stores them in a direc-
tory accessible by the HTTP server, so that a client can
access them.
To be able to use our virtual MMS system, the mobile
phone needs to be conﬁgured to connect to the testing in-
frastructure instead of a regular mobile phone network. This
is done by pointing the phone to the test WAP gateway and,
for message access, to the web server. In addition, the phone
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:30:50 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006has to be conﬁgured to use the wireless LAN connection as
the means to send and receive MMS messages.
To send a message to the phone, a message notiﬁcation
(M-Notiﬁcation.ind) is transmitted using a WAP Push mes-
sage encapsulated in a UDP datagram. The phone, in turn,
connects to the WAP gateway of the virtual MMS system
and receives the MMS message from our HTTP server.
6 Fuzzing MMS User Agents
We concentrated our fuzzing efforts around the M-
Notiﬁcation.ind and the M-Retrieve.conf messages types.
In the M-Retrieve.conf case, we looked at the message body
and the multi-part header. We also tested the SMIL imple-
mentation, since SMIL is an MMS-speciﬁc format [17].
The main component of our MMS fuzzing tool is the
fault-generator, which generates the actual content that is
encoded into the different ﬁelds of an MMS message. The
fault-generator is part of the MMS Message Generator.
Setting up a fuzzing session involves two steps (assum-
ing the device is already connected to the local wireless
LAN). First, the User Agent application has to be started,
and second, the debugger has to be attached to the target
process (tmail). After these two steps have been com-