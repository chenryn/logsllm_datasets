Conference on the Theory and Applications of Cryptographic Tech-
niques (EUROCRYPT), 2003.
[35] T. Ristenpart and S. Yilek, “The power of proofs-of-possession: Secur-
ing multiparty signatures against rogue-key attacks,” in International
Conference on the Theory and Applications of Cryptographic Tech-
niques (EUROCRYPT), 2007.
[36] D. Boneh, M. Drijvers, and G. Neven, “Compact multi-signatures for
smaller blockchains,” IACR Cryptology ePrint Archive, vol. 2018, p.
483, 2018.
[37] M. Fischlin, “Communication-efﬁcient non-interactive proofs of knowl-
edge with online extractors,” in Annual International Cryptology Con-
ference (CRYPTO), 2005.
15
[38] T. Ristenpart and S. Yilek, “The power of proofs-of-possession: Secur-
ing multiparty signatures against rogue-key attacks,” in Annual Inter-
national Conference on the Theory and Applications of Cryptographic
Techniques, 2007.
[39] T. Høiland-Jørgensen, B. Ahlgren, P. Hurtig, and A. Brunstrom, “Mea-
suring latency variation in the internet,” in International on Conference
on emerging Networking EXperiments and Technologies, 2016.
[40] M. Fadhil, G. Owen, and M. Adda, “Bitcoin network measurements for
simulation validation and parameterisation,” in International Network
Conference (INC), 2016.
[41] S. Ben Mariem, P. Casas, and B. Donnet, “Vivisecting blockchain p2p
networks: Unveiling the bitcoin ip network,” in ACM CoNEXT Student
Workshop, 2018.
[42] Mastercard, “Uk - domestic interchange fees,” https://tinyurl.com/
ybzkcxak, 2017.
[43] S. Campion, “Transit-oriented displacement?: The san jose ﬂea market
and the opportunity costs of smart growth,” 2011.
[44] A. Pelham, E. Sills, and G. S. Eisman, Promoting Health and Wellness
in Underserved Communities: Multidisciplinary Perspectives through
Service Learning. Service Learning for Civic Engagement Series.
ERIC, 2010.
J. A. List, “The economics of open air markets,” National Bureau of
Economic Research, Tech. Rep., 2009.
[45]
[46] T. T. Project, “Tor metrics,” https://metrics.torproject.org/onionperf-
latencies.html, 2019.
[47] T. Rufﬁng, P. Moreno-Sanchez, and A. Kate, “Coinshufﬂe: Practical
decentralized coin mixing for bitcoin,” in European Symposium on
Research in Computer Security (ESORICS), 2014.
J. Bonneau, A. Narayanan, A. Miller, J. Clark, J. A. Kroll, and E. W.
Felten, “Mixcoin: Anonymity for bitcoin with accountable mixes,” in
Financial Cryptography and Data Security (FC), 2014.
[48]
[49] D. Hopwood, S. Bowe, T. Hornby, and N. Wilcox, “Zcash protocol
speciﬁcation,” Technical report, 2016–1.10. Zerocoin Electric Coin
Company, Tech. Rep., 2016.
[50] S. Steffen, B. Bichsel, M. Gersbach, N. Melchior, P. Tsankov, and
M. Vechev, “zkay: Specifying and enforcing data privacy in smart
contracts,” in ACM Conference on Computer and Communications
Security (CCS, 2019.
[51] R. Khalil and A. Gervais, “Revive: Rebalancing off-blockchain payment
networks,” in ACM Conference on Computer and Communications
Security (CCS), 2017.
[52] R. A. E. Khalil and A. Gervais, “System and method for scaling
blockchain networks with secure off-chain payment hubs,” May 9 2019,
uS Patent App. 16/183,709.
[53] D. L. Salamon, G. Simonsson, J. Freeman, and B. J. Fox, “Orchid:
Enabling decentralized network formation and probabilistic micro-
payments,” 2018.
[54] R. Pass et al., “Micropayments for decentralized currencies,” in ACM
Conference on Computer and Communications Security (CCS), 2015.
J. Kwon, “Tendermint: Consensus without mining,” 2014.
[55]
[56] A. Kiayias, A. Russell, B. David, and R. Oliynykov, “Ouroboros: A
provably secure proof-of-stake blockchain protocol,” in Annual Inter-
national Cryptology Conference (CRYPTO), 2017.
[57] P. Vasin, “Blackcoin’s proof-of-stake protocol v2,” 2014.
[58] W. Li, S. Andreina, J.-M. Bohli, and G. Karame, “Securing proof-of-
stake blockchain protocols,” in Data Privacy Management, Cryptocur-
rencies and Blockchain Technology, 2017.
[59] Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich, “Algorand:
Scaling byzantine agreements for cryptocurrencies,” in ACM Symposium
on Operating Systems Principles (SOSP), 2017.
[60] L. Luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert, and P. Saxena,
“A secure sharding protocol for open blockchains,” in ACM Conference
on Computer and Communications Security (CCS), 2016.
[61] P. Li, G. Wang, X. Chen, and W. Xu, “Gosig: Scalable byzantine
consensus on adversarial wide area network for blockchains,” arXiv
preprint arXiv:1802.01315, 2018.
[62] E. Research, “Ethereum 2.0 spec–casper and sharding,” https://github.
com/ethereum/eth2.0-specs/blob/master/specs/core/0 beacon-chain.md,
2018.
[63] E. Conner, “Transaction throughput under shasper,” https://ethresear.ch/
t/transaction-throughput-under-shasper/3467, 2018.
[64] V. Buterin, “Slasher: A punitive proof-of-stake algorithm,” 2014.
[65] V. Buterin and V. Grifﬁth, “Casper the friendly ﬁnality gadget,” arXiv
preprint arXiv:1710.09437, 2017.
[66] M. Bellare, J. A. Garay, and T. Rabin, “Fast batch veriﬁcation for
modular exponentiation and digital signatures,” in International Con-
ference on the Theory and Application of Cryptographic Techniques
(EUROCRYPT), 1998.
APPENDIX
A. Background on Permissionless Consensus
In this appendix we review additional examples of recent
permissionless consensus system. We center our review around
schemes that do not introduce signiﬁcant additional security
assumptions, and refer the reader to [7] for a more thorough
survey.
Proof of Stake is proposed as an alternative to computational
puzzles in Proof of Work, where the nodes commit (i.e., stake)
funds in order to participate in the consensus process [55]–
[58]. These solutions are based on an economic-driven model
with nodes being rewarded for honest behavior and penalized
for diverging from the consensus. While they provide some la-
tency improvements, they do not reach the 3 seconds averages
of centralized payment processors.
For example, Ouroboros [56] reports a throughput of ap-
proximately 300 transactions per second and a block frequency
10-16 times smaller than that of Bitcoin. Thus, a merchant
will still have to wait for several minutes before a transaction
can be considered ﬁnalized. As another example of Proof-of-
Stake system, Algorand [59] has a throughput that is 125×
higher than that of Bitcoin, and latency of at least 22 seconds,
assuming a network with no malicious users.
Sharding. While Proof of Stake techniques involve the whole
network in the consensus process, sharding techniques promise
signiﬁcant performance improvement by splitting the network
in smaller groups. For example, Elastico [60] achieves four
times larger throughput per epoch for network sizes similar to
that of Bitcoin. However, it provides no improvement on the
conﬁrmation latency (∼ 800 seconds). Similarly, Gosig [61]
can sustain approximately 4.000 transactions per second with
an ∼1 minute conﬁrmation time. Rapidchain [20] has a
throughput of 7, 300 transactions per second with a 70-second
conﬁrmation latency.
Omniledger [19] is the only proposal that reports perfor-
mance (both throughput and latency) compatible with retail
payments. However, this comes at a security cost. Their low-
latency transactions (i.e., Trust-but-Verify) use shards com-
prised of only a few (or even one) “validators”. In the retail
setting,
this enables malicious validators to launch multi-
spending attacks by approving several conﬂicting payments
towards various honest merchants. While the attack and the
malicious validator(s) will be uncovered by the core validators
within ∼1 minute, this time-period sufﬁces for an adversary
to attack multiple merchants resulting in substantial losses.
Shasper for Ethereum is expected to be capable of handling
13, 000 transactions per second, while optimistic estimates
Fig. 5: Centralized Snappy instance. The customers ci
initiate
payments towards the merchants mj, who then consult with the
central statekeeper s and either accept or reject the payment.
report a minumum block frequency of ∼8 seconds [62]–[65].
However, even with such a small block interval, the latency
remains too high for retail purchases, as merchants will need
to wait for several blocks for transactions to eventually reach
ﬁnality.
B. Deployment Alternatives for Snappy
In this appendix we discuss alternative deployment options.
Centralized Snappy. While decentralization is one of the
main beneﬁts of Snappy, there may be cases where having
one central party is also acceptable. In this case, the merchants
can appoint a single party to approve or reject payments. This
simpliﬁes our protocols as each payment requires only one
approval query instead of several. However, if the central party
is untrusted, it still has to deposit a collateral for the merchants
to claim in case it equivocates. However, relying on a single
party comes with drawbacks. In particular, such a setup adds
a centralized layer on top of a fully decentralized blockchain,
while the reliance on a single service provider will likely result
in increased service fees.
Non-statekeeping Merchants In the previous section, we
discussed a fully centralized version of Snappy that allows
the system to scale even further and simpliﬁes statekeeping.
While this setup has several advantages,
the liveness and
quality of service of the deployment relies on the single party
that can unilaterally decide on changing the service fees and
processes. An alternative solution that retains most of the
centralization beneﬁts while remaining decentralized (but not
fully) is allowing non-statekeeping merchants. Merchants can
join the system and decide if they want to deposit a collateral
and perform statekeeping tasks or they simply want to be able
to receive payments.
This allows merchants who choose not to keep state to still
make use of the Snappy deployment and enables the system to
scale to millions of merchants. To incentivize statekeeping, a
small service fee could be paid by non-statekeeping merchants.
to those who have allocated a statekeeping collateral. While
this goes beyond the scope of this paper,
is probably
preferable if the statekeepers’ set remains open to all interested
it
16
merchants (cf.
to being capped or ﬁxed) and the service
fees are determined dynamically based on the offer/demand.
Note that several merchants may be represented by a single
statekeeping node. For example, instead of having small shops
match the collateral of large chain stores, their association
could maintain one node that performs the statekeeping for
all of them and routes their to-be-approved payments to the
rest of the statekeepers.
that
This setup has the advantage of being able to use any
trust relationships (e.g., small merchants trust their association)
when/where they exist, while still allowing a trustless setup for
actors who prefer it.
One pending transaction. Much of
the complexity of
Snappy’s protocols comes from the fact
the pending
transactions of a customer should never exceed in value the
collateral. One possible way to reduce this complexity is by
constraining the number of allowed pending transactions to 1.
Such a setup allows the customers to conduct at most one
transaction per block, and greatly simpliﬁes the settlement
process, as there are no pending transaction to be provided
by the merchant. We believe that such a setup is realistic and
may be preferable in cases where the customers are unlikely
to perform several transactions within a short period of time.
However, this is an additional assumption that may reduce the
utility of the system in some cases. For example, a customer,
who after checking out realizes that they forgot to buy an item,
will have to wait until the pending transaction is conﬁrmed.
Signature veriﬁcation batching. While the computational
cost of verifying an aggregated signature (i.e., two pairings)
is negligible for a personal computer, this is not true for
the Ethereum Virtual Machine, where a pairing operation is
considerably more expensive than a group operation. Our
original scheme tackles this cost by having the arbiter verify
signatures only in case of disputes. As an additional cost-
reduction optimization, the arbiter can use techniques such as
those in [66] to batch and check several signatures simultane-
ously
Let’s assume that
there are (cid:96) aggregated signatures
(σ1, . . . , σ(cid:96)) to be veriﬁed for the messages (m1, . . . , m(cid:96)). The
arbiter samples (cid:96) random ﬁeld elements (γ1, . . . , γ(cid:96)) from Zp.
The veriﬁer considers all the signatures to be valid if
(cid:96)(cid:89)
H(mi)γi,
n(cid:89)
 .
vj
e
σγi
i , h
=
e
i=1
i=1
j=1,τqi [j]=1
This roughly halfs the veriﬁcation costs. In systems where the
number of transactions is considerably more than the number
of statekeepers, we can reduce the costs per transaction further.
Assume that there are (cid:96) aggregated signatures (σ1, . . . , σ(cid:96)) to
be veriﬁed for the messages (m1, . . . , m(cid:96)) where (cid:96) (cid:29) n. The
veriﬁer samples (cid:96) random ﬁeld elements (γ1, . . . , γ(cid:96)) from Zp.
The veriﬁer considers all the signatures to be valid if
(cid:32) (cid:96)(cid:89)
(cid:32) (cid:96)(cid:89)
(cid:33)
(cid:33)
n(cid:89)
(cid:96)(cid:89)
 .
e
σγi
i , h
=
e
H(mi)γi, vj
i=1
j=1
i=1,τqi [j]=1
The cost of verifying a batch of (cid:96) signatures signed by n
merchants is then n + 1 pairing operations and 2(cid:96) group
exponentiations in G.
17
Fig. 6: Moving majority attack enables a customer to have two trans-
actions with the same index value approved by disjoint statekeeper
majorities.
Dynamic Statekeepers’ Consortia. So far we have considered
only cases where customers joined and withdrew from the
system. Similarly, one can imagine that statekeepers could
decide to leave or new statekeepers may want
to join an
existing deployment. Such functionality can be easily facili-
tated by modifying through the registration and de-registration
algorithms available for customers. However, while churning
customers do not pose a threat to the security of the system,
changes in the set of statekeepers may result in attacks.
Such an attack could enable a malicious customer to have
two approved transactions with the same index value. As
shown in Figure 6, initially the system features 5 statekeepers
(s1 . . . s5) and a merchant who wants to have a transaction
τ approved, reaches out to s1, s2 and s3. Subsequently, two
new statekeepers s6 and s7 join the system. The malicious
customer now issues another transaction τ(cid:48), such that τi = τ(cid:48)
i.
The merchant receiving τ(cid:48) now queries a majority of the
statekeepers (i.e., s4, s5, s6 and s7) and gets the transaction
approved. At the ﬁnal stage of the attack c issues another
transaction that invalidates τ and τ(cid:48) (e.g., a doublespend),
while the malicious merchant quickly claims τ(cid:48)
v from the
customer’s collateral. Because of the way the arbiter processes
claims (Line 12 in Algorithm 3),
is
now unable to claim τv from (cid:99)(cid:111)(cid:108)c. Moreover, none of the
statekeepers equivocated and thus no funds can be recouped
from their collateral.
the honest merchant
Snappy can safely support a dynamically changing set
of statekeepers,
if appropriate protection mechanisms are
deployed. For example, such attacks can be prevented: 1)
by giving early notice to the merchants about changes in
the set (e.g., multistage registration), and 2) by waiting (a
few minutes) until all past transactions are ﬁnalized in the
blockchain before/after every change.