2. The reference monitor obtains the security labels of s and o
(recorded by SB when the processes are created), and queries
the access control policies. A token is issued to specify al-
lowed access permissions.
3. Before any of send and recv methods is called, the token is
checked if the method can be activated, otherwise an access
control exception is generated.
6.3 Performance Results
We measured the communication and access control overhead be-
tween two processes in the same host OS (without isolation en-
forced) and in two different UMLs isolated with VMM in the host
OS, respectively. Under each case we measured the average over-
head with and without access control between the subject and ob-
ject processes. We measured the time for the access control deci-
sion check and the actual communication time. Since extra per-
formance overhead is introduced with access requests from a sub-
ject process and the decision making from the reference monitor,
denying and allowing an access result in the same performance
overhead.6 So an access is always allowed when the access con-
trol decision is checked in our performance study. Table 1 shows
the average values of 50 measurements. Since the communication
that we implemented in the prototype is through simple query-and-
response messages between processes, the overhead introduced by
the access control enforcement is comparable to the communica-
tion overhead. While the overhead signiﬁcantly increases from the
control within the same OS to that between UMLs in the same host
OS, the access control enforcement overhead is still less than 2.0
ms (less than 1/3 of the total overhead), which is acceptable for
most applications.
6Normally denying and allowing an access may result in different
overhead if different number(s) of policies are evaluated. Here we
only consider a small number of total policies such that the differ-
ence can be ignored.
124
UML1(cid:13)Tun(cid:13)/tap(cid:13)Reference Monitor(cid:13)Tun(cid:13)/tap(cid:13)UML2(cid:13)token(cid:13)send/(cid:13)recv(cid:13)VMM(cid:13)Host OS(cid:13)User space(cid:13)s(cid:13)o(cid:13)Policy(cid:13)access control (ms)
communication (ms)
total (ms)
-
0.372
0.372
0.465
0.369
0.834
no isolation
no control with control
isolation with VMM
no control with control
-
4.484
4.484
1.926
4.551
6.477
Table 1: Access control and communication overhead
Strategies can be used to further reduce the access control over-
head. For example, the reference monitor can cache a ﬁnite number
of tokens it has issued. If the security labels of the communicating
parties in a token have not updated upon the latest access, the to-
ken can be reused without querying the policy decision point (the
policy ﬁle in our prototype). This is useful for real applications
with complex access control policies and in distributed computing
environments.
7. RELATED WORK
Considerable research has been conducted to provide application
level security based on TC technologies. In [25], a security kernel
is used beyond hardware to provide separated runtime space for the
legacy operating system and “secure applications” (e.g., DRM ap-
plications). But communications between legacy applications and
these secure applications are not supported, as this architecture is
for multilateral security policies, e.g., platform owner’s security
and DRM policies. Similarly, a language-based virtual machine is
proposed in [16] to provide trusted services, which is only for ap-
plications developed with a Java-like program language. It does not
support communications between general processes and processes
in a virtual machine.
So far only a few researchers have considered the simultaneous
application-level security and ﬂexible communication requirements.
Besides those mentioned in Section 1, Terra [15] and sHype (secure
Hypervisor) [24] use virtual machine monitor (VMM) as the trusted
layer, which can support multiple legacy operating systems on a
single platform. Access control is enforced in the VMM layer for
resource sharing between upper VMs. The main difference from
our approach is that in our approach the security enforcement is
performed in a middle layer, which is above the main OS and below
the applications. That is, our approach can provide ﬁner-grained
security services between applications by integrating application
context information for access control.
Another line of work focuses on securing operating systems, such
as Security-enhanced Linux (SELinux) [19], TrustedBSD [5], and
Linux Security Modules (LSM) [29]. In these systems, the kernel
is extended to include authorization modules and enforce access
control policies. For example, in SELinux, security classes are de-
ﬁned for objects such as ﬁles, links, and processes, and accesses
to objects from subjects are controlled by policies. Because of the
complexity and the huge size of a general-purpose OS, it is con-
sidered that purely OS-based security enforcement cannot provide
high assurance security services to applications, which is demon-
strated by the increasing number of kernel-level rootkits in com-
modity OS’s. These studies differ from our architecture in that our
proposed trusted component (SB) is in the middle layer between
the OS kernel and the user space processes, such that it is trans-
parent to existing OS and applications. Furthermore, by leveraging
trusted hardware, our architecture provides high assurance for the
enforcement of policies.
Among these schemes, BIND [27] and KernelSec [23] are closest
to ours. Although BIND [27] also uses the hash chain for integrity
check of a process and its data, our approach is signiﬁcantly dif-
ferent from that in BIND. First, with SB, both the hash values of
the input/output and the process binary code are included in the
signature that is sent to the downstream process. It is not only the
integrity of the process code. This is practically necessary to ver-
ify that the output of a process is obtained with genuine input. For
example, in collaborative computing systems like SETI@Home, a
server needs to ensure that a peer does the computation with the
input that the server assigns, but not something faked. In BIND,
only the process code and its output data are veriﬁed, which cannot
capture the integrity and authenticity of the input. Second, the in-
tegrity veriﬁcation in our architecture is performed by SB on a plat-
form, which makes this function transparent to applications since
they always go through SB to communicate with each other. While
in BIND, for the purpose of ﬁne-grained attestation, the integrity
measurements and veriﬁcations are based on some critical sections
of a process, which calls the corresponding functions provided by
BIND. So the integrity veriﬁcation is performed by individual ap-
plications, whereby the security functions are not transparent to ap-
plications.
Similar to our approach, KernelSec [23] supports general security
policies such as MAC and information ﬂow control for applica-
tions. But as it is implemented at the OS kernel level without root of
trust, KernelSec cannot provide high assurance of security enforce-
ment. On the other side, SB supports more ﬂexible application- and
organization-speciﬁc access control policies with high assurance.
8. CONCLUSIONS
In this paper we propose a novel architecture for trusted computing.
A trusted component called SecureBus is located between the main
OS and applications to provide strong memory space isolation and
secure communication for user applications. SB effectively pre-
serves application integrity by attesting the integrity and authentic-
ity of process and data, and enforcing ﬂexible mandatory access
control policies for information ﬂow between applications, both
of which are required by applications to defend software-based at-
tacks. The major advantage of our architecture is that SB is trans-
parent to both the underlying OS and applications, and can provide
data authentication and ﬂexible access control between processes
simultaneously. In addition, our architecture enables the separa-
tion of security mechanisms from functionality in the design and
development of systems and applications, which is convenient for
legacy applications and OS’s. We have implemented a prototype
system to study its feasibility and the access control performance.
The experimental results show that SB is effective.
In this work we have examined the application of SB through the
Chinese Wall policy implemented using a lattice of security labels.
The architecture is applicable to a much wider range of policies,
details of which will be studied in future work.
125
pages 31–42, Oakland, CA, USA, 1997.
[18] J. F. Levine, J. B. Grizzard, and H. L. Owen. Detecting and
categorizing kernel-level rootkits to aid future detection.
IEEE Security & Privacy, 4(1):24–32, Jan.-Feb. 2006.
[19] P. Loscocco and S. Smalley. Integrating ﬂexible support for
security policies into the linux operating system. In
Proceedings of USENIX Annual Technical Conference, pages
29 – 42, June 25-30 2001.
[20] S. Muir, L. Peterson, M. Fiuczynski, J. Cappos, and
J. Hartman. Proper: Privileged operations in a virtualised
system environment. In Proceedings of Usenix Annual
Technical Conference, 2005.
[21] OASIS XACML TC. Core Speciﬁcation: eXtensible Access
Control Markup Language (XACML), 2005.
[22] R. Oppliger and R. Rytz. Does trusted computing remedy
computer security problems? IEEE Security & Privacy,
3(2):16–19, 2005.
[23] M. Radhakrishnan and J. A. Solworth. Application support
in the operating system kernel. In Proceedings of ACM
Symposium on InformAtion, Computer and Communications
Security, 2006.
[24] R.Sailer, T. Jaeger, E. Valdez, R. Perez, S. Berger, J. L.
Grifﬁn, and L. van Doorn. Building a mac-based security
architecture for the xen opensource hypervisor. Technical
report, IBM Research Report RC23629, 2005.
[25] A. Sadeghi and C. Stuble. Taming trusted platforms by
operating system design. In Proceedings of the 4th
International Workshop for Information Security
Applications, LNCS 2908, pages 286–302, Berlin, Germany,
August 2003.
[26] R. Sandhu. Lattice-based access control models. IEEE
Computer, 26(11), November 1993.
[27] E. Shi, A. Perrig, and L. Van Doorn. Bind: a ﬁne-grained
attestation service for secure distributed systems. In
Proceeedings of IEEE Symposium on Security and Privacy,
pages 154–168, Oakland, CA, USA, May 8-11 2005.
[28] Sean Smith. Trusted Computing Platforms: Design and
Applications. Springer, 2005.
[29] C. Wright, C. Cowan, S. Smalley, J. Morris, and
G. Kroah-Hartman. Linux security modules: General
security support for the linux kernel. In Proceedings of the
11th USENIX Security Symposium, 2002.
9. ACKNOWLEDGEMENT
We would like to thank anonymous reviewers for their helpful com-
ments. The work is partially supported by NSF grants CNS-0509061
and CNS-0621631, and by a grant from Intel.
10. REFERENCES
[1] LaGrande Technology Preliminary Architecture
Speciﬁcation,
http://www.intel.com/technology/security/downloads/PRELIM-
LT-SPEC D52212.htm.
[2] SETI@Home, http://setiathome.ssl.berkeley.edu/.
[3] TCG Speciﬁcation Architecture Overview.
https://www.trustedcomputinggroup.org.
[4] Universial TUN/TAP driver. http://vtun.sourceforge.net/tun/.
[5] TrustedBSD: Adding trusted operating system features to
FreeBSD. In Proceedings of the FREENIX Track: USENIX
Annual Technical Conference, pages 15–28, Boston, MA,
USA, June 28 2001.
[6] AMD platform for trustworthy computing. Microsoft
WinHEC,
http://www.microsoft.com/whdc/winhec/pres03.mspx, 2003.
[7] Technical introduction to next-generation secure computing
base (NGSCB). Microsoft WinHEC, 2003.
[8] A. Baliga, L. Iftode, and X. Chen. Paladin: Automated
detection and containment of rootkit attacks. Technical
Report DCS-TR-593, Rutgers University, Department of
Computer Science, 2006.
[9] E. Bertino, B. Catania, E. Ferrari, and P. Perlasca. A logical
framework for reasoning about access control models. ACM
Transaction on Information System Security, 6(1):71–127,
2003.
[10] D. Brewer and M. Nash. The chinese wall security policy. In
Proceedings of the IEEE Symposium On Research in Security
and Privacy, pages 206–214, Oakland, California, 1988.
[11] N. Damianou, N. Dulay, E. Lupu, , and M. Sloman. The
ponder policy speciﬁcation language. In Proceedings of the
Workshop on Policies for Distributed System s and Networks,
2001.
[12] Department of Defense National Computer Security Center.
Trusted Database Interpretation of the Trusted Computer
Systems Eval uation Criteria, April 1991. NCSC-TG-021.
[13] Jeff Dike. A user-mode port of the linux kernel. In
Proceedings of the 2000 Linux Showcase and Conference,
October 2000.
[14] I. Foster and C. Kesselman. Globus: A metacomputing
infrastructure toolkit. International Journal of Supercmputer
Applications, 11(2), 1997.
[15] T. Garﬁnkel, B. Pfaff, J. Chow, M. Rosenblum, and
D. Boneh. Terra: A virtual machine-based platform for
trusted computing. In Proceedings of the 19th ACM
Symposium on Operating Systems Principles, pages
193–206, Bolton Landing, New York, USA, October 1922
2003.
[16] V. Haldar, D. Chandra, and M. Franz. Semantic remote
attestation - a virtual machine directed approach to trusted
computing. In Proceedings of the Third virtual Machine
Research and Technology Symposium, pages 29–41, San
Jose, CA, USA, May 6-7 2004. USENIX.
[17] S. Jajodia, P. Samarati, , and V. S. Subrahmanian. A logical
language for expressing authorizations. In Proceedings of the
IEEE Symposium On Research in Security and Privacy,
126