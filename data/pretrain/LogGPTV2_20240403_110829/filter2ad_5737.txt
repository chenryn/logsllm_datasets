title:POSTER: A Framework for Phylogenetic Analysis in Mobile Environment
author:Fabio Martinelli and
Francesco Mercaldo and
Andrea Saracino
POSTER: A Framework for Phylogenetic Analysis
in Mobile Environment∗
Francesco Mercaldo
IIT-CNR
Pisa, Italy
Andrea Saracino
IIT-CNR
Pisa, Italy
Fabio Martinelli
IIT-CNR
Pisa, Italy
PI:EMAIL
PI:EMAIL
PI:EMAIL
ABSTRACT
To maximize the probability of successful attacks and reduce the
odds of being detected, malware developers implement different ver-
sions of the same malicious payloads. As a matter of fact, malware
writers often generate new malicious code starting from existing
ones, adding small programmed variations, or applying obfuscation
mechanisms, that change the code structure, without altering the
malicious functionalities. For these reasons phylogenetic analysis
is becoming of interest as instrument for malware analysts in order
to understand the derivation of a malicious payload, being thus
able to reconduct a derived piece of code to its original, known
originator. In this poster we describe a framework designed to infer
and shape the phylogenetic tree of mobile malicious applications.
The framework considers multi-level features with rule-based ma-
chine learning algorithm to retrieve antecedents and descendants
of malicious samples.
CCS CONCEPTS
• Security and privacy → Malware and its mitigation; Mobile
platform security;
KEYWORDS
malware, phylogenesis, lineage, triage, security, Android
ACM Reference Format:
Fabio Martinelli, Francesco Mercaldo, and Andrea Saracino. 2018. POSTER:
A Framework for Phylogenetic Analysis in Mobile Environment. In ASIA
CCS ’18: 2018 ACM Asia Conference on Computer and Communications Secu-
rity, June 4–8, 2018, Incheon, Republic of Korea. ACM, New York, NY, USA,
3 pages. https://doi.org/10.1145/3196494.3201588
1 INTRODUCTION AND BACKGROUND
In last years Android platform has increasingly been targeted by
malicious payload embedded into legitimate applications [6]. The
malicious code, hidden inside the so-called trojanized apps, aims
at leaking private data, or stealing users money, either directly
or indirectly [2, 8]. Currently there exists more than 1 million of
malicious samples [6] present in the wild, having an exponential
increase over the last 5 years. However, this huge amount of new
∗Produces the permission block, and copyright information
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea
© 2018 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-5576-6/18/06.
https://doi.org/10.1145/3196494.3201588
malware is not actually completely “new”, as many existing mal-
ware samples are actually derivations of pre-existing ones. As a
matter of fact malware, like any software, tend to evolve. More
specifically, malware writers modify existing code in way that are
typical in software engineering industry and open source environ-
ment [7]. The standard approach is the one of adding new features
to an existing malware, thus generating multiple configurations of
the same initial malware, with the goal of allowing the execution
on different platforms, merging together components of different
malicious programs [3].The study of the malware evolution usually
concern in phylogenetic analysis and variants identification [3].
Phylogenetic analysis represents the study of similarities and differ-
ences in program structure with the aim to find relationships within
groups of software, providing insights about new malware variants
not available within the repository of malware signatures. Variants
identification consists of localizing malware samples that introduce
an evolution with respect to an existing malware. Identifying mal-
ware lineage and phylogenetic can help to face more promptly zero
day malware programs, when they are or contain evolved versions
of known malware. The main limit of the methods already pro-
posed in literature is that they extract features at a single level of
program abstraction. Thus, malware writer could make ineffective
the detection technique by adopting an obfuscation technique at
that specific level of abstraction. Research community focused their
attention mainly on mobile malware detection [1, 6] and about
to improvement of mobile security model [4], while phylogenetic
analysis is poorly investigate in literature.
Starting from these considerations in this paper we introduce a
three-levels framework with the ability to perform phylogenetic
analysis by using three different levels of program abstraction: (i)
meta-data, (ii) source and (iii) run-time. Meta-data and a source
analysis are performed statically, i.e., it is not required to run the
application to extract and analyze feature while the run-time anal-
ysis requires the app to be executed in a controlled environment.
2 THE FRAMEWORK
In this section we explain in detail the architecture we designed.
As stated into the introduction, the proposed framework analyses
features related to Android applications of three different levels:
meta-data, static and dynamic. Figure 1 shows the framework ar-
chitecture.
2.1 Meta-data
Android apps must request permission in order to access sensitive
user data (for instance, contacts and SMS), as well as certain system
Poster SessionASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea825In order to consider only more informative 2grams and to reduce
the computation time we consider the 1000 more frequent 2grams.
This process is shown in the static analysis section of Figure 1.
2.3 Runtime
The dynamic analysis, considers both global features, i.e. related
to the device and operative system, and local features which are
related to specifically monitored apps. The Global Monitor moni-
tors the device and OS features at three levels, i.e. kernel (SysCall
Monitor), user (User Activity Monitor) and application (Message
Monitor). These features are monitored regardless of the specific
app or system components generating them, and are used to shape
the current behavior of the device itself. Then, these behaviors
are classified as genuine (normal) or malicious (anomalous) by
the Classifier component. The third block is the Per-App Monitor,
which implements a set of known behavioral patterns to monitor
the actions performed by the set of suspicious apps, through the
Signature-Based Detector. Finally, the User Interface & Prevention
component includes the Prevention module, which stops malicious
actions and, in case a malware is found, handles the procedure
for removing malicious apps using the User Interface (UI). The UI
handles notifications to device user, in particular: (i) the evaluation
of the risk score of newly-downloaded apps by the App Evaluation,
(ii) the reporting of malicious app (Notify) and (iii) to ask the user
whether to remove them. In Figure 1 this process is shown by the
dynamic analysis section.
2.4 The Phylogenetic Analysis
In order to obtain the three-level feature vector, we exploit the
BRIDEMAID platform [6, 7]: a framework developed by authors
able to extract to considered feature at meta-data, static and dynamic
level with the aim to identify Android malware classes and to
discriminate between legitimate and malicious application with an
accuracy equal to 99.7%.
The phylogenetic analysis basically relies on rule-based machine
algorithms. As a matter of fact, from each level of features the
proposed framework is able to obtain using the machine learning
rule-based classification algorithms a set of rule. The format of the
rules is the following: IF (the sample under analysis exhibits a set of
values for the features as described by the rule) THEN (the sample
is belonging to a specified class described by the rule).
For instance if a samples under analysis exhibits the TRUE value
for the all the rules belonging to the X family and only for two
rules belonging to the Y family, we can state that most the code
of the application is belonging to the X family but it contains also
behaviour belonging to the Y family. For this reason, with the
correlation of date of the last build, we can confirm that the sample
under analysis is belonging to the family X for the most of the code,
but it also represent an evolution from the X family to the Y one.
This is the reason why the proposed framework, once obtained
the feature vectors from the three levels and the computation phase
evaluating the rules, it compares the date of the last build of the
samples under analysis with the date of the samples in the trained
dataset (we easily obtain this information from the metadata of
the dex file of the Android application): whether the sample is
successive to the ones in the training dataset exhibiting the same
Figure 1: The designed framework from phylogenetic anal-
ysis
features (for instance, camera and internet)1. The list of the permis-
sion required by an application is stored in the so-called Manifest
i.e., an XML file contained in the root of the apk (i.e., the Android
application package). We consider the feature related to permission
as nominal: whether a permission is invoked into the application
under analysis the feature value is equal to 1, 0 otherwise.
Table 1 shows the considered permission.
As depicted in Table 1, we take in account the set of permissions
marked as "dangerous" by API 23 (i.e., Android 6.0 Marshmallow)2:
the permission features are nominal i.e., a permission can be re-
quested or not by the application under analysis.
In addition to permissions, we consider the number of application
download, the app rating and the developer reputation (whether
available), as shown in the meta-data section of Figure 1.
2.2 Source
In order to gather opcodes, we need to extract to smali classes from
the application under analysis.
We consider apktool to extract from the .apk the .dex file, which
is the compiled application file of a (Dalvik Executable); then, with
the smali3 tool, we disassemble the application .dex file and obtain
several files (i.e., smali classes) which contains the machine level
instructions, each consisting in an opcode and its parameters. From
these files, we obtain a set of opcode sequences where each item
is the sequence of opcodes corresponding to the machine level
instructions of a method of a class in a.
We compute the frequency of opcodes 2grams, as a matter of fact
previous studies demonstrate that 2gram features are most discrim-
inative in distinguish between legitimate and trusted applications
[1, 5, 6].
Let O be the set of possible opcodes, and let O =i =n
i =1 Oi the
set of n-grams (i.e., sequences of opcodes whose length is up to n,
we consider n = 2).
We denote with f (a, o) the frequency of the n-gram o ∈ O in
the application a: f (a, o) is hence the number of occurrences of o
divided by the total length of the opcode sequences in a. Finally,
we set the feature vector (cid:174)f (a) ∈ [0, 1]|O| corresponding to a to
(cid:174)f (a) = (f (a, o1), f (a, o2), . . . ) with oi ∈ O. Additionally, we split
the application code into chunks corresponding to class methods.
1https://developer.android.com/guide/topics/permissions/overview.html
2https://developer.android.com/about/versions/marshmallow/android-6.0.html
3https://code.google.com/p/smali/
Poster SessionASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea826Table 1: The considered permission.
CALL_PHONE
Permission
READ_CALENDAR
WRITE_CALENDAR
CAMERA
READ_CONTACTS
WRITE_CONTACTS
GET_ACCOUNTS
ACCESS_FINE_LOCATION
ACCESS_COARSE_LOCATION
RECORD_AUDIO
READ_PHONE_STATE
Description
Allows an application to read the user’s calendar data.
Allows an application to write the user’s calendar data.
Access the camera device.
Allows an application to read the user’s contacts data.
Allows an application to write the user’s contacts data.
Allows access to the list of accounts in the Accounts Service.
Allows an app to access precise location.
Allows an app to access approximate location.
Allows an application to record audio.
Allows read only access to phone state, including the phone number of the device, current cellular
network information and the status of any ongoing calls
Allows an application to initiate a phone call without going through the Dialer user interface for the user
in order to confirm the call.
Allows an application to read the user’s call log.
Allows an application to write (but not read) the user’s call log data.
Allows an application to modify and remove existing voicemails in the system.
Allows an application to use SIP service.
Allows an application to see the number being dialed during an outgoing call with the option to redirect
the call to a different number or abort the call altogether.
Allows an application to access data from sensors that the user uses to measure what is happening
inside his/her body, such as heart rate.
Allows an application to send SMS messages.
SEND_SMS
Allows an application to receive SMS messages.
RECEIVE_SMS
Allows an application to read SMS messages.
READ_SMS
Allows an application to receive WAP push messages.
RECEIVE_WAP_PUSH
Allows an application to monitor incoming MMS messages.
RECEIVE_MMS
READ_EXTERNAL_STORAGE
Allows an application to read to external storage.
WRITE_EXTERNAL_STORAGE Allows an application to write to external storage.
READ_CALL_LOG
WRITE_CALL_LOG
ADD_VOICEMAIL
USE_SIP
PROCESS_OUTGOING_CALLS
BODY_SENSORS
behaviour, the framework will classify the sample under analysis
as a descendant of the family. In this way it is possible to build
to genealogical tree of malware families. Furthermore, whether a
samples under analysis is matching all the rules belonging to a
family it is classified as variant of the considered family and for
this reason it will be places at the same position of the family in
the phylogenetic tree.
3 CONCLUSION AND FUTURE WORK
In this paper we propose a framework to track the phylogenetic
tree of an Android malicious application. It basically exploits three-
level features obtained with the BRIDEMAID framework (i.e., from
meta-data, static and dynamic analysis) and rule-based machine
learning algorithms.
As future work we plan to perform an extended characterization
of malicious families through the rules gathered by the involved
machine learning algorithms.
ACKNOWLEDGMENT
This work was partially supported by the H2020 EU funded project
NeCS [GA #675320], by the H2020 EU funded project C3ISP [GA
#700294].
REFERENCES
[1] Gerardo Canfora, Andrea De Lorenzo, Eric Medvet, Francesco Mercaldo, and
Corrado Aaron Visaggio. 2015. Effectiveness of opcode ngrams for detection of
multi family android malware. In Availability, Reliability and Security (ARES), 2015
10th International Conference on. IEEE, 333–340.
[2] Alessandro Castrucci, Fabio Martinelli, Paolo Mori, and Francesco Roperti. 2008.
Enhancing java me security support with resource usage monitoring. In Interna-
tional Conference on Information and Communications Security. Springer, 256–266.
[3] Aniello Cimitile, Fabio Martinelli, Francesco Mercaldo, Vittoria Nardone, Antonella
Santone, and Gigliola Vaglini. 2017. Model checking for mobile android malware
evolution. In Formal Methods in Software Engineering (FormaliSE), 2017 IEEE/ACM
5th International FME Workshop on. IEEE, 24–30.
[4] N Dragoni, F Martinelli, F Massacci, P Mori, C Schaefer, T Walter, and E Vetillard.
2008. Security-by-contract (SxC) for software and services of mobile systems. In
SecPerU 2007. MIT Press, 49–54.
[5] Alberto Ferrante, Miroslaw Malek, Fabio Martinelli, Francesco Mercaldo, and
Jelena Milosevic. 2017. Extinguishing Ransomware-a Hybrid Approach to An-
droid Ransomware Detection. In The 10th International Symposium on Foundations
Practice of Security.
[6] Fabio Martinelli, Francesco Mercaldo, and Andrea Saracino. 2017. Bridemaid:
An hybrid tool for accurate detection of android malware. In Proceedings of the
2017 ACM on Asia Conference on Computer and Communications Security. ACM,
899–901.
[7] Fabio Martinelli, Francesco Mercaldo, Andrea Saracino, and Corrado Aaron Vis-
aggio. 2016. I find your behavior disturbing: Static and dynamic app behavioral
analysis for detection of android malware. In Privacy, Security and Trust (PST),
2016 14th Annual Conference on. IEEE, 129–136.
[8] Yajin Zhou and Xuxian Jiang. 2012. Dissecting android malware: Characterization
and evolution. In Security and Privacy (SP), 2012 IEEE Symposium on. IEEE, 95–109.
Poster SessionASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea827