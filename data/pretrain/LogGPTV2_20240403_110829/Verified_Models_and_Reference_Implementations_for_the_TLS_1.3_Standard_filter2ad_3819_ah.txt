with
IEEE
Pironti,
veriﬁed
and
cryptographic
Secu-
[Online]. Available:
rity & Privacy
pubs/implementing-tls-with-veriﬁed-cryptographic-security-sp13.pdf
[22] K. Bhargavan and G. Leurent, “On the practical (in-)security of 64-bit
block ciphers: Collision attacks on HTTP over TLS and OpenVPN,” in
ACM SIGSAC Conference on Computer and Communications Security
(CCS), 2016, pp. 456–467.
Symposium on
(Oakland),
2013.
[23] ——, “Transcript collision attacks: Breaking authentication in TLS,
IKE, and SSH,” in ISOC Network and Distributed System Security
Symposium (NDSS), 2016.
[24] B. Blanchet, “A computationally sound mechanized prover for se-
curity protocols,” IEEE Transactions on Dependable and Secure
Computing, vol. 5, no. 4, pp. 193–207, 2008.
[25] ——, “Automatic veriﬁcation of correspondences for security pro-
tocols,” Journal of Computer Security, vol. 17, no. 4, pp. 363–434,
2009.
[26] ——, “Security protocol veriﬁcation: Symbolic and computational
models,” in Principles of Security and Trust (POST), 2012, pp. 3–
29.
[27] ——, “Modeling and verifying security protocols with the applied
pi calculus and ProVerif,” Foundations and Trends in Privacy and
Security, vol. 1, no. 1–2, pp. 1–135, Oct. 2016.
[28] D. Bleichenbacher, “Chosen ciphertext attacks against protocols based
on the RSA encryption standard PKCS# 1,” in Annual International
Cryptology Conference, ser. Lecture Notes in Computer Science, vol.
1462. Springer, 1998, pp. 1–12.
[29] M. Bodin, A. Chargu´eraud, D. Filaretti, P. Gardner, S. Maffeis,
D. Naudziuniene, A. Schmitt, and G. Smith, “A trusted mechanised
javascript speciﬁcation,” in ACM Symposium on the Principles of
Programming Languages (POPL), 2014, pp. 87–100.
[30] D. Cad´e and B. Blanchet, “Proved generation of implementations from
computationally secure protocol speciﬁcations,” Journal of Computer
Security, vol. 23, no. 3, pp. 331–402, 2015.
[31] S. Chaki and A. Datta, “Aspier: An automated framework for verifying
security protocol implementations,” in 2009 22nd IEEE Computer
Security Foundations Symposium.
IEEE, 2009, pp. 172–185.
[32] A. Chaudhuri, “Flow: Abstract interpretation of javascript for type
checking and beyond,” in ACM Workshop on Programming Languages
and Analysis for Security (PLAS), 2016.
[33] J.-S. Coron, Y. Dodis, C. Malinaud, and P. Puniya, “Merkle-Damg˚ard
revisited: How to construct a hash function,” in Advances in Cryptol-
ogy (CRYPTO), 2005, pp. 430–448.
[34] V. Cortier, S. Kremer, and B. Warinschi, “A survey of symbolic
methods in computational analysis of cryptographic systems,” Journal
of Automated Reasoning, vol. 46, no. 3-4, pp. 225–259, 2011.
[35] C. Cremers, M. Horvat, S. Scott, and T. van der Merwe, “Automated
analysis and veriﬁcation of TLS 1.3: 0-RTT, resumption and delayed
authentication,” in IEEE Symposium on Security and Privacy (Oak-
land), 2016, pp. 470–485.
[36] I. B. Damg˚ard, “A design principle for hash functions,” in Advances
in Cryptology–CRYPTO89, 1989, pp. 416–427.
[37] T. Dierks and E. Rescorla, “The Transport Layer Security (TLS)
Protocol Version 1.2,” IETF RFC 5246, 2008.
[38] Y. Dodis, T. Ristenpart, J. Steinberger, and S. Tessaro, “To hash or
not to hash again? (In)differentiability results for H 2 and HMAC,”
in Advances in Cryptology (Crypto), 2012, pp. 348–366.
[39] D. Dolev and A. C. Yao, “On the security of public key protocols,”
IEEE Transactions on Information Theory, vol. 29, no. 2, pp. 198–
207, 1983.
[40] B. Dowling, M. Fischlin, F. G¨unther, and D. Stebila, “A cryptographic
analysis of the TLS 1.3 handshake protocol candidates,” in ACM
Conference on Computer and Communications Security (CCS), 2015,
pp. 1197–1210.
[41] M. Fischlin, F. G¨unther, B. Schmidt, and B. Warinschi, “Key con-
ﬁrmation in key exchange: A formal treatment and implications for
TLS 1.3,” in IEEE Symposium on Security and Privacy (Oakland),
2016, pp. 452–469.
[42] M. Fischlin and F. G¨unther, “Multi-stage key exchange and the case of
Google’s QUIC protocol,” in ACM SIGSAC Conference on Computer
and Communications Security (CCS), 2014, pp. 1193–1204.
500
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
[43] S. Goldwasser, S. Micali, and R. Rivest, “A digital signature scheme
secure against adaptive chosen-message attacks,” SIAM Journal of
Computing, vol. 17, no. 2, pp. 281–308, April 1988.
[44] R. Hamilton, J. Iyengar, I. Swett, and A. Wilk, “QUIC: A UDP-based
multiplexed and secure transport,” 2016, IETF Internet Draft.
[45] K. E. Hickman, “The SSL protocol,” 1995, IETF Internet Draft, https:
//tools.ietf.org/html/draft-hickman-netscape-ssl-00.
[46] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk, “On the security of
TLS-DHE in the standard model,” in CRYPTO 2012, 2012, pp. 273–
293.
[47] T. Jager, J. Schwenk, and J. Somorovsky, “On the security of TLS
1.3 and QUIC against weaknesses in PKCS#1 v1.5 encryption,” in
ACM SIGSAC Conference on Computer and Communications Security
(CCS), 2015, pp. 1185–1196.
[48] N. Kobeissi, K. Bhargavan, and B. Blanchet, “Automated veriﬁcation
for secure messaging protocols and their implementations: A symbolic
and computational approach,” in IEEE European Symposium on
Security and Privacy (EuroS&P), 2017.
[49] H. Krawczyk, “Cryptographic extraction and key derivation: The
HKDF scheme,” in Advances in Cryptology (CRYPTO), 2010, pp.
631–648.
[50] ——, “A unilateral-to-mutual authentication compiler for key ex-
change (with applications to client authentication in tls 1.3),” in
ACM SIGSAC Conference on Computer and Communications Security
(CCS), 2016, pp. 1438–1450.
[51] H. Krawczyk, K. G. Paterson, and H. Wee, “On the security of the
TLS protocol: A systematic analysis,” in CRYPTO 2013, 2013, pp.
429–448.
[52] H. Krawczyk and H. Wee, “The OPTLS protocol and TLS 1.3,” in
IEEE European Symposium on Security & Privacy (Euro S&P), 2016,
cryptology ePrint Archive, Report 2015/978.
[53] R. K¨usters, T. Truderung, and J. Graf, “A framework for the cryp-
tographic veriﬁcation of Java-like programs,” in IEEE Computer
Security Foundations Symposium (CSF), 2012, pp. 198–212.
[54] A. Langley, M. Hamburg, and S. Turner, “Elliptic curves for security,”
IRTF RFC 7748 https://tools.ietf.org/html/rfc7748, Jan. 2016.
[55] X. Li, J. Xu, Z. Zhang, D. Feng, and H. Hu, “Multiple handshakes
security of TLS 1.3 candidates,” in IEEE Symposium on Security and
Privacy (Oakland), 2016, pp. 486–505.
[56] R. Lychev, S. Jero, A. Boldyreva, and C. Nita-Rotaru, “How secure
and quick is QUIC? provable security and performance analyses,” in
IEEE Symposium on Security & Privacy (Oakland), 2015, pp. 214–
231.
[57] U. Maurer and B. Tackmann, “On the soundness of authenticate-then-
encrypt: formalizing the malleability of symmetric encryption,” in
ACM SIGSAC Conference on Computer and Communications Security
(CCS), 2010, pp. 505–515.
[58] N. Mavrogiannopoulos, F. Vercauteren, V. Velichkov, and B. Preneel,
“A cross-protocol attack on the TLS protocol,” in ACM CCS, 2012.
[59] C. Meyer, J. Somorovsky, E. Weiss, J. Schwenk, S. Schinzel, and
E. Tews, “Revisiting SSL/TLS implementations: New Bleichenbacher
side channels and attacks,” in 23rd USENIX Security Symposium.
USENIX Association, 2014, pp. 733–748.
[60] B. M¨oller, T. Duong, and K. Kotowicz, “This POODLE bites: exploit-
ing the SSL 3.0 fallback,” https://www.openssl.org/∼bodo/ssl-poodle.
pdf, 2014.
[61] T. Okamoto and D. Pointcheval, “The gap-problems: a new class of
problems for the security of cryptographic schemes,” in Practice and
Theory in Public Key Cryptography (PKC), 2001, pp. 104–118.
[62] K. G. Paterson, T. Ristenpart, and T. Shrimpton, “Tag size does matter:
Attacks and proofs for the TLS record protocol,” in ASIACRYPT,
2011, pp. 372–389.
[63] K. G. Paterson and T. van der Merwe, “Reactive and proactive
standardisation of TLS,” in Security Standardisation Research (SSR),
2016, pp. 160–186.
[64] M. Ray, A. Pironti, A. Langley, K. Bhargavan, and A. Delignat-
Lavaud, “Transport Layer Security (TLS) session hash and extended
master secret extension,” 2015, IETF RFC 7627.
[65] E. Rescorla, M. Ray, S. Dispensa, and N. Oskov, “TLS renegotiation
indication extension,” IETF RFC 5746, 2010.
“0-RTT and Anti-Replay,”
[66] E. Rescorla,
mail-archive/web/tls/current/msg15594.html, Mar. 2015.
https://www.ietf.org/
[67] ——, “[TLS] PR#875: Additional Derive-Secret stage,” https://www.
ietf.org/mail-archive/web/tls/current/msg22373.html, Feb. 2017.
[68] B. Schmidt, S. Meier, C. Cremers, and D. Basin, “Automated analysis
of Difﬁe-Hellman protocols and advanced security properties,” in
IEEE Computer Security Foundations Symposium (CSF), 2012, pp.
78–94.
edu/∼dstefan/#projects.
[69] D. Stefan, “Espectro project description,” 2016, https://cseweb.ucsd.
[70] N. Swamy, C. Hrit¸cu, C. Keller, A. Rastogi, A. Delignat-Lavaud,
S. Forest, K. Bhargavan, C. Fournet, P.-Y. Strub, M. Kohlweiss, J.-
K. Zinzindohoue, and S. Zanella-B´eguelin, “Dependent types and
multi-monadic effects in F*,” in ACM Symposium on Principles of
Programming Languages (POPL), 2016, pp. 256–270.
[71] M. Vanhoef and F. Piessens, “All your biases belong to us: Breaking
RC4 in WPA-TKIP and TLS,” in USENIX Security Symposium, 2015,
pp. 97–112.
[72] D. Wagner and B. Schneier, “Analysis of the SSL 3.0 protocol,” in
USENIX Electronic Commerce, 1996.
[73] J. K. Zinzindohoue, E. Bartzia, and K. Bhargavan, “A veriﬁed extensi-
ble library of elliptic curves,” in IEEE Computer Security Foundations
Symposium (CSF), 2016, pp. 296–309.
APPENDIX A.
LEMMAS ON PRIMITIVES AND ON THE KEY SCHEDULE
We show the following properties:
• mack
H(m) = mack(H(m)) is an SUF-CMA (strongly
unforgeable under chosen message attacks) MAC. Indeed,
since mac = HMAC-H is a PRF, it is an SUF-CMA
MAC as shown in [10], and this property is preserved
by composition with a collision-resistant hash function.
sk (H(m)) is an UF-CMA signature.
Indeed, sign is an UF-CMA signature, and this property is
preserved by composition with a collision-resistant hash
function.
sk
H (m) = sign
• sign
a
is
hs
fresh
We also prove several
lemmas on the key schedule of
TLS 1.3, using CryptoVerif.
• When es is a fresh random value, e (cid:3)→ hkdf-extract(es,
e) and log 1 (cid:3)→ derive-secret(es, etsc, log 1) are indistin-
guishable from independent random functions, and kb =
and hkdf-extract(es, 0len H() )
derive-secret(es, pbk, “”)
are indistinguishable from independent fresh random val-
ues independent from these random functions.
(cid:3)→
• When
log 1
derive-secret(hs, htsc, log 1)(cid:6)derive-secret(hs, htss,
log 1) is indistinguishable from a random function and
hkdf-extract(hs, 0len H() ) is indistinguishable from a fresh
random value independent from this random function.
• When ms
the functions
log 4 (cid:3)→ derive-secret(ms, atsc, log 4)(cid:6)derive-secret(ms,
atss, log 4)(cid:6)derive-secret(ms, ems, log 4) and log 7
(cid:3)→
derive-secret(ms, rms, log 7) are indistinguishable from
independent random functions.
is a fresh random value,
random value,
• When l1, l2, l3 are pairwise distinct labels and s is a fresh
random value, hkdf-expand-label(s, li, “”) for i = 1, 2, 3
are indistinguishable from independent fresh random val-
ues.
All random values considered above are uniformly dis-
tributed. We use these properties as assumptions in our proof
of the protocol. This modular approach considerably reduces
the complexity of the games that CryptoVerif has to consider.
the key schedule could be
simpliﬁed by replacing groups of calls to derive-secret that
These results suggest
that
501
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
Idle(sk C, psk)
get client hello
SentClientHello(k0
c)
put server hello
ReceivedServerHello(mode S[v, kex ], kh
c
, kh
s )
(TLS 1.3)
(TLS 1.2 full)
(TLS 1.2 resumption)
put server ﬁnished 13
put server hello done 12
put server ﬁnished resume 12
SentClientFinished(kc, ks, psk(cid:7)
)
SentClientFinished(kc, ks)
SentClientFinished(kc, ks, psk(cid:7)
)
put server ﬁnished 12
ReceivedServerFinished(kc, ks, psk(cid:7)
)
Figure 7: Client state machine
Idle(sk S, kt)
put client hello
SentServerHello(mode S[v, kex ], k0
c
, kh
c
, kh
s )
(TLS 1.3)
(TLS 1.2 full)
(TLS 1.2 resumption)
get server ﬁnished 13
get server hello done 12
get server ﬁnished resume 12
SentServerFinished(kc, ks)
SentServerHelloDone()
ReceivedClientFinished(kc, ks, psk(cid:7)
)
put client ﬁnished 13
put client ccs 12
ReceivedClientFinished(kc, ks, psk(cid:7)
)
ReceivedClientCCS(kc, ks)
put client ﬁnished 12
SentServerFinished(kc, ks, psk(cid:7)
)
Figure 8: Server state machine
use the same key and log with a single call to derive-secret
that would output the concatenation of severals keys. The
same remark also holds for calls to hkdf-expand-label
that use the same key. This approach corresponds to the
usage of expansion recommended in the formalization of
HKDF [49], and would simplify the proof: some lemmas
above would no longer be needed. We would also rec-
ommend replacing ms = hkdf-extract(hs, 0len H() ) with
ms = derive-secret(hs, ms, “”): that would be more natural
since we use the PRF property of HMAC-H for this com-
putation and not the randomness extraction. If the argument
0len H() may change in the future, then we would support
Krawczyk’s recommendation [67] of applying hkdf-extract
to the result of derive-secret(hs, ms, “”).
APPENDIX B.
REFTLS PROTOCOL STATE MACHINES
Client. The RefTLS client implements the composite state
machine shown in Figure 7 for TLS 1.3 and TLS 1.2. Each
state represents a point in the protocol where the client
is either waiting for a ﬂight of handshake messages from
the server, or it has new session keys that it wishes to
communicate to the record layer. Each arrow is annotated
with the name of the function in RefTLS-CORE API that
implements the corresponding state transition. Each transi-
tion may involve processing a ﬂight of incoming messages,
changing the session state, and producing a ﬂight of outgoing
messages.
Server. The RefTLS server implements a dual state machine
for TLS 1.3 and TLS 1.2, as depicted in Figure 8. The
server decides which protocol version and key exchange the
handshake will use, and triggers the appropriate branch in
the state machine by sending a ServerHello. Like the
client, each of its state transition functions corresponds either
to a ﬂight of messages or to a change of keys.
502
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply.