---
## Page 396
8.函数类型和函数指针类型
7.指向数组的指针与多维数组
6.指向指针的指针与指针数组
5.常用的make命令行选项
3.指针与数组
2.指针类型的参数和返回值
第 23 章 指针 请点评
6
1.指针的基本概念
.不完全类型和复
指针与结构体
HE
杂声明
全国嵌入式人才培训基地
全国嵌入式人才培训基地
部分ⅡI. C语言本质
第23章指针
起始页
上一级
1.指针的基本概念
396
上二页
---
## Page 397
都占8个字节。
面
这里的&是取地址运算符（AddressOperator）
这几个变量的内存布局如下图所示，在初学阶段经常要借助于这样的图来理解指针。
变量表示，例如某程序中定义了以下全局变量：
个内存单元称为指针,
在第12章栈与队列讲过，堆栈有栈顶指针，
1.指针的基本概念 请点评
上一页
，但它们的内存单元都占4个字节，
 因为i的地址是在编译链接时能确定的，
0x804a010
0x804a014
0x804a020
0x804a024
图 23.1.指针的基本概念
char
int 
int
是数组的索引，
*pc = &c;
3
0x804a020
0x804a024
 通过指针和间接寻址访问变量，
pi:
pc:
i:0
C:0
 通过指针访问数组中的某个元素。
，并用i的地址来初始化pi。我们讲过全局变量只能用常量表达式初始
因为i不是常量表达式,
，因为要保存32位的虚拟地址，同理，在64位平台上指针变量
全国嵌入式人才培训基地
1.指针的基本概念
第23章指针
，队列有头指针和尾指针,
αi表示取变量i的地址,
，这种指针在C语言中可以用一
然而用i的地址来初始化一个指针却没有
注意pi和pc虽然是不同类型的指针变
。在图20.3“间接寻址"我们又看到另
，这些概念中的"指针"本质上
int *pi 
=&i;表示定义
一个指针类型的
保存地址的这
后面两
397
下一页
在
---
## Page 398
*型的，pc是char *型的，pi= pc;这样赋值就是错误的。但是可以先强制类型转换然后赋值：
用一个指针给另一个指针赋值时要注意，两个指针必须是同一类型的。在我们的例子中，
表示pi指向哪就让ptri也指向哪，本质上就是把变量pi所保存的地址值赋给变量ptri。
或者：
指针之间可以相互赋值，也可以用一个指针初始化另一个指针，例如：
值，*&E和E等价，如果表达式E是指针类型，&*E和E等价。
&运算符的操作数必须是左值，
为Dereference。
也称为Dereference操作，指针有时称为变量的引用（Reference），所以根据指针找到变量称
这里的*号是指针间接寻址运算符（Indirection Operator），
如果要改变pi所指向的整型变量的值，比如把变量j的值增加10，可以写:
如果要让pi指向另一个整型变量j，可以重新对pi赋值：
很明显是定义了一个指针和一个整型变量，就不容易看错了。
变量后面，而定义指针的*号写在变量前面，
同一个语句中定义多个指针变量，每一个都要有*号，例如：
图 23.2.把char*指针的值赋给int*指针
pi = (int *)pc;
int
int *ptri = pi;
*pi = *pi + 10;
pi = &j;
int *p, *q; 
..-..-.
*ptri;
，这样是定义了一个整型指针p和一个整型变量g，
，因为只有左值才表示一个内存单元，
 运算结果可以做左值。所以，如果表达式E可以做左
 更容易看错。定义指针的*号前后空格都可以省，写
，*pi表示取指针pi所指向的变量的值,
，才会有地址，
，定义数组的[号写在
，运算结果是指针
，pi是int
8
---
## Page 399
致段错误。*p－0;会导致段错误，就像放在眼前的炸弹一样很容易找到，相比之下，野指针的错
地址0及其附近，也不会把地址0~0xff的页面映射到物理内存，
就是把地址0转换成指针类型，
NULL在C标准库的头文件stddef.h中定义:
或者把它初始化为NULL：
为“野指针”（Unbound Pointer），为避免出现野指针，
外改写了数据而导致随后的运行中出错，就很难找到错误原因了。像这种指向不确定地址的指针称
的，
我们知道，
序在随后的运行中出错。有一种情况需要特别注意，定义
址，
有意义的，否则就不应该给pi这么赋值。因此使用指针要特别小心，很容易将指针指向错误的地
后3个字节已经不属于变量e了，
现在pi指向的地址和pc一样，
，后面用*p访问不确定的地址就会导致不确定的后果，
，访问这样的地址可能导致段错误，
0x804a010
0x804a014
0x804a020
0x804a024
#define NULL ((void *)0)
int main(void)
int main(void)
，在堆栈上分配的变量初始值是不确定的，
:
int *p = NULL;
：
int *p;
=0;
=0;
0x804a024
0x804a024
:od
i:0
0
pi:
.*..*
，但是通过*pc只能访问到一个字节，
，称为空指针，它的特殊之处在于，
，可能读到无意义的值，
，也就是说指针p所指向的内存地址是不确定
，在定义指针变量时就应该给它明确的初值,
X
，如果导致段错误还比较容易改正，
一个指针类型的局部变量而没有初始化：
，也可能意外改写了某些数据，
 所以任何对地址0的访问都会立刻导
，操作系统不会把任何数据保存在
，而通过*pi可以访问到4个字节，
，如果意
，使得程
399
---
## Page 400
第23章指针
下一章讲函数接口时再详细介绍void*指针的用处。
于函数接口，比如：
*指针不能直接Dereference，而必须先转换成别的类型的指针再做Dereference。void *指针常用
变量（也就是类型暂时不确定的变量）
计
*指针与其它类型的指针之间可以隐式转换，
用指针,
指针，
讲到这里就该讲一下void*类型了。
误就像埋下地雷一
，而不能定义voia型的变量,
，任意其它类型的指针也可以转换为通用指针,
int main(void)
void func(void *pv)
char c;
*pchar
char
一样，
，更难发现和排除，
= pv; 
因为void*指针和别的指针一
 在编程时经常需要一种通用指针，
全国嵌入式人才培训基地
 编译器不知道该分配几个字节给变量。同样道理，
，这次走过去没事，
而不必用类型转换运算符。
起始页
上一级
下次走过去就有事。
一样都占4个字节
，可以转换为任意其它类型的
2.指针类型的参数和返回值
注意
而如果定义void型
只能定义void*指
一
void
上一页
---
## Page 401
然后临时变量tmp的值成为表达式swap(&αi，&j)的值，然后在main函数中又把这个值赋给了p，相当
上面的例子还演示了函数返回值是指针的情况，return px;语句相当于定义了一个临时变量并
终swap函数将i和j的值做了交换。
我们知道，调用函数的传参过程相当于用实参定义并初始化形参，swap(&i，&j)这个调用相当于:
2.指针类型的参数和返回值 请点评
用px初始化：
的i和j。
首先看以下程序:
1
例 23.1.指针参数和返回值
int *p = tmp;
int *tmp = px;
尽管在swap函数的作用域中访问不到i和j这两个变量名，却可以通过地址访问它们，
int 
int main(void)
int *swap(int *px, int *py)
#include 
return 0;
int i = 10,
return px;
*py
temp =
int temp;
!Adx = xdx
2.指针类型的参数和返回值
 j = 20;
全国嵌入式人才培训基地
第23章指针
401
最
---
## Page 402
2、现在回头看第3节“形参和实参"的习题1，那个程序应该怎么改？
基本概念清晰，无论多复杂的形式都应该能正确分析。
我们会看到更复杂的参数和返回值形式，
1、对照本节的描述，
习题 请点评
最后的结果是swap函数的px指向哪就让main函数的p指向哪。我们知道px指向i，所以p也指向i。
1.指针的基本概念
页
，像图 23.1“指针的基本概念"那样画图理解函数的调用和返回过程。在下一章
全国嵌入式人才培训基地
，在初学阶段对每个程序都要画图理解它的运行过程，只要
起始页
上一级
3.指针与数组
下一页
---
## Page 403
在上面的例子中，表达式pa[-1]是合法的，它和a[0]表示同一
现在我们换一种画法，省略地址的具体数值，用方框表示存储空间，用箭头表示指针和变量之间的
元素占4个字节，所以pa++使pa所指向的地址加4，注意不是加1。
首先指针pa指向a[0]的地址，
3.指针与数组 请点评
在第1节“数组的基本概念"还讲过C语言允许数组下标是负数，
动转换成指向首元素的指针，
取数组的第2个元素，
的，
既然指针可以用++运算符，
关
下面画图理解。从前面的例子我们发现，地址的具体数值其实无关紧要，
不是取a的地址。
先看个例子，有如下语句：
系。
二
页
pa
图 23.3.指针与数组
int 
int a[10];
*pa =' &a[0];
低地址
a[0]a[1]a[2]a[3]
pa±2
是因为它等价于*(a+2)，
当然也可以用+、-运算符，
，注意后缀运算符的优先级高于单目运算符，所以是取a[0]的地址，
所以a[2]和pa[2]本质上是-
全国嵌入式人才培训基地
......
第 23章指针
3.指针与数组
在第1节“数组的基本概念"讲过数组名做右值时自
一样
E1[E2]这种写法和(*((E1)+(E2)）)是等价
另外，
，pa+2这个表达式也是有意义的，
高地址
[6]e
一样的，都是通过指针间接寻址访问元
个元素。
，现在你该明白为什么这样规定了。
，由于pa是int*指针,
，关键是要说明地址之间的
如上图所
一个int型
403
目
---
## Page 404
2.指针类型的参数和返回值
这个参数指向一串元素中的首元素，则经常写成数组的形式。
式是为了给读代码的人提供有用的信息，
参数写成指针形式还是数组形式对编译器来说没区别，都表示这个参数是指针，
第一种形式方括号中的数字可以不写，仍然是等价的：
等价于：
在函数原型中，如果参数是数组,
以&a是合法的，
根据什么来猜？根据第3节“形参和实参"讲过的Rule of Least Surprise原则。你理解了指针和常数
减法运算又表示什么意义？
现在猜一下，两个指针变量做比较运算（>、>=、<、<=、
值时转换成指向首元素的指针，
在取数组元素时用数组名和用指针的语法一样，但如果把数组名做左值使用，和指针就有区别了
个数组中元素的指针之间相互比较才有意义,
N
加减的概念，
是这个道理，应该尽可能让用户根据以往的经验知识就能推断出该系统的基本用法。
它能有什么意义，因此C语言也规定两个指针不能相加。
间的比较运算比的是地址，
，那就相当Surprise了
，同样只有指向同一个数组中元素的指针之间相减才有意义。两个指针相加表示什么？想不出
void func(int a[］)
void func(int *a)
void func(int a[10])
 再根据以往使用比较运算的经验，
........
，我们将在第7节“指向数组的指针与多维数组"介绍这种语法。
，但a++就不合法，
-.-.
不符合一般的经验。无论是设计编程语言还是设计函数接口或人机界面
C语言正是这样规定的，不过C语言的规定更为严谨，只有指向同一
但做左值仍然表示整个数组的存储空间，
则等价于参数是指针的形式，例如：
全国嵌入式人才培训基地
，如果这个参数指向一个元素，通常写成指针的形式，如果
否则没有意义。那么两个指针相减表示什么？pa_-
起始页
上一级
 指针相减表示两个指针之间相差的元素
==、
假如C语言为指针相加也规定了一种意
、！=）表示什么意义？两个指针变量做
，、但支持取地址运算符&，所
而不是首元素的存储空
4.指针与const 限定符
，之所以规定两种形
.1 == a,
 所以指针
---
## Page 405
即使不用const限定符也能写出功能正确的程序，
后者意外改写了前者所指向的内存单元，例如对下面的代码编译器会报警告：
式类型转换，例如：
指向非const变量的指针或者非const变量的地址可以传给指向const变量的指针，编译器可以做隐
a是一个指向const int型的const指针，因此*a和a都不允许改写。
以(*a)++是不允许的，
这两种写法是一样的，
const限定符和指针结合起来常见的情况有以下几种。
4.指针与const限定符 请点评
为：
但是，
a是一
3．const对编译器优化是一个有用的提示，编译器也许会把const变量优化成常量。
2．尽可能多地使用const限定符，
上一页
一个指向int型的const指针，*a是可以改写的，但a不允许改写。
的Bug，防止意外改写数据。
被改写。
指向const变量的指针或者const变量的地址不可以传给指向非const变量的指针，以免透过
const char *pc = &c;
char c =
 int const * const a;
char 
int * const a;
int const 
const int *a;
*pc
'a';
 *a;
&c;
但a可以改写，所以a++是允许的。
，把不该变的都声明成只读，
4.指针与const限定符
全国嵌入式人才培训基地
第23章指针
，但良好的编程习惯应该尽可能多地使用const，
，a所指向的内存单元不可改写，所
，这样可以依靠编译器检查程序中
你在调用这
因
---
## Page 406
p指向.rodata段，不允许改写，但编译器不会报错，在运行时会出现段错误。
3.指针与数组
注意上面第一行，如果要定义一个指针指向字符串字面值，
*或const char*指针传给它，所以下面这些调用都是合法的：
串"提到，字符串字面值类似于数组名，
在第3节“变量的存储布局"我们看到，
int main(void)
printf(