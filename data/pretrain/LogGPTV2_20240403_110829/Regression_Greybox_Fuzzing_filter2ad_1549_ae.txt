●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●●
●●
●
7.5
5.0
2.5
0.0
12
9
6
3
0
15
10
5
0
grok_27386*
●●
●●●
libxml2_dblfree
●
yara_19591*
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●●
●
●
●
●
●●
●
●
●
12
9
6
3
0
10.0
7.5
5.0
2.5
0.0
20
15
10
5
0
20
15
10
5
0
20
15
10
5
0
grok_28227
●
●
●
●
●
●
●
●
●
●
●●
●
●●
●
●
● ●●
●
●
●
●
●
●●
●
●
●
●●
●●●●●●
●
libxml2_UaF
●
●●
●
●
zstd_14368*
●
●
●
●
●●
●
libgit2_11007
libgit2_11194
●●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
openssl_17715*
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●●
●
●●
●
●
15
10
5
0
15
10
5
0
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●●
●●
●●
●
●
openssl_17722
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
Fuzzer
●
●
afl
aflchurn
Figure 5: Deduplication results (AFL versus AFLChurn). Effectiveness of Regression Greybox Fuzzing
Table 2 shows the performance for AFL and AFLChurn. For
three subjects 3○, neither AFL nor AFLChurn produces a crash in
the allotted time. For four subjects 1○, both fuzzers produce the first
crash before the first full cycle is completed. AFL (and AFLChurn)
maintain the seed corpus in a circular queue. New seeds are added
to the end of the queue; once the fuzzer reaches the end of the
queue, it wraps around. Without even the first cycle completed,
there is not much guidance that AFLChurn can provide.
For the remaining eight subjects 2○, the results are as follows.
AFLChurn discovers a regression about 1.5x faster and in more
campaigns than AFL. In one case, AFLChurn reduces the time
to produce the first crash from 17 to 9 hours. AFLChurn also
typically discovers the bug in more campaigns than AFL. For
two of the eight subjects, only AFLChurn finds the bug within
the allotted timeÐno doubt due to better efficiency. For most
subjects, AFLChurn produces more unique crashes than AFL.
Figure 5 shows the results of our deduplication. We wanted to
investigate whether the observed crashes are related to our selected
regression. We also wanted to determine whether other bugs have
been discovered, as well. To this end, we identified the bug report
in OSSFuzz that corresponds to each of the produced stack trace.
We found that all of the reported bugs are regressions, i.e., a bug-
introducing commit could be identified. We also found that our
fuzzers discovered up to four distinct bugs in a subject and that
shallow bugs mask deeper bugs in a subject.
After deduplication, we have 17+2 bugs, all of which are re-
gressions. There are two (+2) additional variants of bug 17737 in
libxml2, called UaF for use-after-free, and dblfree for double-free.
Bug 17737 is a heap use-after-free bug, which crashes at a particular
statement that reads from free’d (unallocated) memory. However,
only AFLChurn finds other locations in LibXML2 that read from
the free’d memory or free memory that has already been freed,
which yields different stack traces.
There are very few exceptions where AFLChurn does not out-
perform AFL. The lower performance in file is explained by the
short time-to-error. In under six minutes, neither fuzzer can com-
plete a full queue cycle, which removes the edge that AFLChurn
only gains over several queue cycles. We explain the lower per-
formance in grok by the randomness. Only four of twenty trials
of AFL actually discover 27386 and 28227 where AFL outperforms
AFLChurn. In all other cases, AFLChurn outperforms AFL.
AFLChurn detects almost all regression bugs significantly faster
than AFL for the majority of fuzzing campaigns (i.e., for 16 of 19
regressions there is a positive difference in medians). Our empiri-
cal results support our hypothesis that a fuzzer which is guided
towards code that has changed more recently ore more often is
also more efficient.
Such improved efficiency is particularly important when fuzzing
under a limited testing budget. For instance, during continuous
integration, a fuzzing campaign may be cut short after just a few
hundred thousand generated test inputs, or after one or two hours.
If we focus the limited testing budget on the error-prone regions
in the source code, we also increase the likelihood of finding a bug
within the given constraints.
RQ2. Contribution of Age and Churn
Individually
In order to understand the contribution of each heuristic individu-
ally, we investigated disabled either the age heuristic which priori-
tizes younger code (NoAge) or the churn heuristic which prioritizes
more frequently changed code (NoChurn).
Table 3 shows different performance measures for the AFLChurn
variants, NoAge and NoChurn. Again, we exclude from discussion
1○ the subjects where a crash is found before the first queue cycle
completes and 3○ the subjects that do not crash for any of the two
fuzzers. Notice that neither NoAge nor NoChurn find the regression
in systemd. For 2○, the remaining seven subjects, there is no clear
Session 7B: Fuzzing CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2177aspell_17187
●
●
●
●
●
●
●
●
●
●
●
●●
●
●●●
●● ●●
●
●
●
●
●
●
●
●
● ●●
●
●● ●
●●
●●●
●●
●
libgit2_11194
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
0.2
0.1
0.0
0.002
0.001
0.000
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●●
●
●
●
●
●
libgit2_11382*
●
●
●●
●
●
●
●●
●
●●●●●
●●
●●●●
●
●●●●
● ●
●
●●
●
●●●
●
●●
●
●●●●●
●
openssl_17722
unbound_20308*
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
20
15
10
5
0
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●●
●
●
●
●●
●
●
●
●
●
●
●
●●
●
●
●
file_13222*
grok_24427
15
10
5
0
20
15
10
5
0
2
1
0
●
●
●
●
●
●
●
●
●
●●●●
●●●
●
●
●●
●
●●
●
●
●
libhtp_17198*
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
● ●
●
●
●●●
●
●
●
●
● ●●●
●
●
●
●
●