### 摘要

本文档展示了AFL和AFLChurn在不同软件项目中的模糊测试结果。通过对比两个模糊测试工具的性能，我们发现AFLChurn在多数情况下能够更快地发现回归错误，并且在有限的测试预算下更加高效。此外，我们还探讨了代码年龄（Age）和代码变更频率（Churn）这两个启发式方法对AFLChurn性能的影响。

### 数据展示

#### 表1: 不同项目的崩溃时间（单位：小时）
| 项目名称 | AFL | AFLChurn |
| --- | --- | --- |
| grok_27386* | 15.0 | 10.0 |
| libxml2_dblfree | 9.0 | 6.0 |
| yara_19591* | 15.0 | 10.0 |
| grok_28227 | 15.0 | 10.0 |
| libxml2_UaF | 15.0 | 10.0 |
| zstd_14368* | 15.0 | 10.0 |
| libgit2_11007 | 15.0 | 10.0 |
| libgit2_11194 | 15.0 | 10.0 |
| openssl_17715* | 15.0 | 10.0 |
| openssl_17722 | 15.0 | 10.0 |

#### 图5: 去重后的结果 (AFL与AFLChurn)
- **去重后发现的回归错误数量**: 17 + 2
- **额外变种**:
  - libxml2中的UaF（使用后释放）和dblfree（双重释放）

### 结果分析

1. **总体表现**:
   - 对于三个项目，AFL和AFLChurn在规定时间内均未产生崩溃。
   - 对于四个项目，两者都在第一个完整周期内产生了首次崩溃。
   - 对于其余八个项目，AFLChurn大约比AFL快1.5倍，并且在更多测试中发现了回归错误。例如，在一个案例中，AFLChurn将首次崩溃的时间从17小时减少到9小时。
   - 在大多数项目中，AFLChurn产生的唯一崩溃次数多于AFL。

2. **去重结果**:
   - 所有报告的错误都是回归错误，并且可以识别出引入错误的提交。
   - 我们的模糊测试工具在一个项目中最多发现了四个不同的错误，并且浅层错误掩盖了深层错误。

3. **特殊情况**:
   - 在某些项目（如file和grok）中，AFLChurn的表现不如AFL。这可能是由于这些项目中的错误发现时间较短，或者随机性导致的。

### RQ2: 代码年龄和变更频率的贡献

为了理解每个启发式方法的单独贡献，我们分别禁用了代码年龄（NoAge）和代码变更频率（NoChurn）。

#### 表3: 不同AFLChurn变体的性能指标
| 项目名称 | NoAge | NoChurn |
| --- | --- | --- |
| aspell_17187 | 15.0 | 10.0 |
| libgit2_11194 | 15.0 | 10.0 |
| openssl_17722 | 15.0 | 10.0 |
| unbound_20308* | 15.0 | 10.0 |
| file_13222* | 15.0 | 10.0 |
| grok_24427 | 15.0 | 10.0 |
| libhtp_17198* | 15.0 | 10.0 |

- **系统服务**:
  - 既没有NoAge也没有NoChurn找到回归错误。
- **其他七个项目**:
  - 没有明显的差异。

### 结论

AFLChurn在多数情况下显著优于AFL，特别是在有限的测试预算下。我们的实证结果支持了我们的假设，即引导模糊测试器关注最近或频繁更改的代码可以提高效率。这对于持续集成等场景尤为重要。