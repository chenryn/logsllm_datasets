MOV [i], (i & 0x0f）
但却不知道[i]到底是BYTE， 还是WORD，还是DWORD。刚才就是出现了这种错误。 16
图灵社区会员 metorm 专享 尊重版权
70 …… 第4天：C语言与画面显示的练习
那怎么才能告诉计算机这是BYTE呢？
char *p; /*，变量p是用于内存地址的专用变量*/
声明一个上面这样变量p，p里放入与i相同的值，然后执行以下语句。
*p = i & 0x0f;
这样，C编译器就会认为“p 是地址专用变量，而且是用于存放字符（char）的，所以就是
BYTE.”。顺便解释一下类似语句：
char *p; /*用于BYTE类地址*/
short *p; /*用于WORD类地址*/
int *p; /*用于DWORD类地址*/
这次我们是一个字节一个字节地写入，所以使用了char。
既然说到这里，那我们再介绍点相关知识，“char i;”是类似AL的1字节变量，“short i;”
是类似AX的2字节变量，“int i;”是类似EAX的4字节变量。
而不管是“char *p”，还是“short *p”，还是“int *p”，变量p都是4字节。这是因为p
是用于记录地址的变量。在汇编语言中，地址也像ECX一样，用4字节的寄存器来指定，所
以也是4字节。
■■■■■
这样准备工作就OK了。再用“make run”运行一遍以下内容。
void HariMain(void)
{
int i; /*变量声明。变量i是32位整数*/
char *p; /*变量p，用于BYTE型地址*/
for (i = 0xa0000; i <= 0xaffff; i++) {
p = i; /*代入地址*/
*p = i & 0x0f;
/*这可以替代write_mem8(i, i & 0x0f);*/
}
for (;;) {
io_hlt();
}
}
哇，居然不使用write_mem8就能显示出条纹图案，真是太好了。
嗯？且慢！仔细看看画面，发现有一行警告。
warning: assignment makes pointer from integer without a cast
图灵社区会员 metorm 专享 尊重版权
3 挑战指针（harib01c） …… 71
这个警告的意思是说，“赋值语句没有经过类型转换，由整数生成了指针”。其中有两个单
1
词的意思不太明白。类型转换是什么？指针又是什么？
类型转换是改变数值类型的命令。一般不必每次都注意类型转换，但像这次的语句中，如果
2
不明确进行类型转换，C编译器就会每次都发出警告：“喂，是不是写错了？”顺便说一下，cast
在英文中的原意是压入模具，让材料成为某种特定的形状。
3
指针是表示内存地址的数值。C语言中不用“内存地址”这个词，而是用“指针”。在C语
言中，普通数值和表示内存地址的数值被认为是两种不同的东西，虽然笔者也觉得它们没什么不
4
同，但也只能接受这种设计思想了。基于这种设计思想，如果将普通整数值赋给内存地址变量，
就会有警告。为了避免这种情况的发生，可以这样写：
4
p = (char *） i;
这就对i进行了类型转换，使之成为表示内存地址的整数。（其实这样转换以后，数值一点都
6
没变，但对于C编译器来说，类型的不同有着很大的差别。）以后再进行这样的赋值时，就不会出
现这种讨厌的警告了。于是我们这样修改一下。
7
再运行一次“make run”吧。好了，不再出现那种烦人的警告了。write_mem8已经没用了，
所以可以将它从naskfunc.nas中删除。
8
这样的写法虽然有点绕圈子了，但我们实现了只用C语言写入内存的功能。
COLUMN-2 只要使用类型转换，就可以不用指针之类的方法吗？ 9
好不容易介绍完了类型转换，我们来看一个应用实例吧。如果定义：
10
p = (char *) i;
那么将上式代入下面语句中。
11
*p = i & 0x0f;
这样就能得到下式： 12
*((char *) i) = i & 0x0f;
13
这个语句执行起来毫无问题。虽然读起来不是很容易理解，但这样可以不特意声明p变
量，所以笔者偶尔还是会使用的。
有没有觉得这种写法与“BYTE[i] = i & 0x0f;”有些相像吗？在特别喜欢汇编语言的笔 14
者看来，会有这种感觉呢。（笑）
15
16
图灵社区会员 metorm 专享 尊重版权
72 …… 第4天：C语言与画面显示的练习
COLUMN-3 还是不能理解指针
能有这种想法，说明你很诚实。那好，我们再尽量详细地讲解一下。
如果你曾经使用过C语言，并且听说过“指针”这个词，那么刚才的说明肯定让你觉得
混乱，摸不着头脑。倒是那些从未接触过C语言的人更能理解一些。
这里，特别重要的一点是，必须想点办法让C语言完成以下功能：
MOV BYTE [i], (i & 0x0f)
也就是，向内存的第 i 号地址写入 i & 0x0f 的计算结果。而程序只是偶然地写成了：
int i;
char *p;
p = (char *) i;
*p = i & 0x0f;
必须要先理解以上程序。这可能与你所知道的指针的使用方法完全不同，不过暂时先不
要想这个。总之上面４行，是MOV语句的替代物，这一点是最重要的。
从没听说过 C语言指针的人，仅仅会想“哦，原来 C语言中是这么写的，没那么复杂
么。”的确如此，没什么不懂的嘛。
■■■■■
下面再稍微深入说明一下。我们常见的两个语句是：
p = (char *) i;
*p = i & 0x0f;
这两个语句有什么区别呢？这是不懂汇编的人常有的疑问。将以上语句按汇编的习惯写
一下吧。假设p相当于ECX，那么写出来就是：
MOV ECX, i
MOV BYTE [ECX], (i & 0x0f)
它们的区别很清楚，即一个是给ECX寄存器赋值，一个给ECX号内存地址赋值。这完
全是两回事。存储它们的半导体也不一样，一个在 CPU里，一个在内存芯片里。在 C语言
中，虽然p与*p只有一字之差，但意思上的差别却如此之大。
如果执行顺序调过来会怎么样呢？也就是像这样：
*p = i & 0x0f;
p = (char *) i;
不是很熟悉指针的人可能认为这样也行。但是，这相当于：
MOV BYTE [ECX], (i & 0x0f)
MOV ECX, i
如果这么做，第一个MOV的时候，ECX的值不确定，是个随机数，这会导致i & 0x0f 的
图灵社区会员 metorm 专享 尊重版权
3 挑战指针（harib01c） …… 73
结果写入内存的某个不可知的地址中。这样的后果很严重。 1
■■■■■
2
另一个比较常见的疑问，是关于声明的。在C语言中，如果不声明变量就不能使用。所
谓声明，就是类似“int i;”这种语句。有了这句话，变量 i 就可以使用了（与此不同的是汇
3
编语言中，EAX，DL等，不声明也可以自由使用）。在C语言中，声明了10个变量，就可
以用10个变量，这是理所当然的事。
既然如此，那为什么只声明了“char *p;”却不仅能使用 p，还可以使用*p 呢？这让人 4
搞不懂……确实，这个程序中，给p和*p赋值了。看上去，能够使用的变量数比实际声明的
变量数要多。
4
遇到这种情况时，我们先回到汇编语言中看看。
MOV ECX, i
6
MOV BYTE [ECX], (i & 0x0f)
看着这个程序，就不会再有人认为其中有 2 个变量了。其中只有一个 ECX。而且，同
7
样是“MOV AL， [ECX]”，ECX是123的时候，和ECX是124的时候，放入AL的值也是
不同的（只要这两处地址存放的不是同样的值）。这是因为地址不同，代表的内存区域不同。
8
就好比不同的住址，住的人也不一样。
所以，同样是*p，因为p值的不同，记录的值也不同。
9
*p = 3；
p = p + 3;
i = *p;
10
也就是说如果执行以上片段，i不一定是3，因为地址已经变了。
费了半天劲，其实笔者想说的就是，*p 并不是什么变量。确实，我们可以给*p 赋值，
11
也可以引用*p的值，这看起来就像变量一样。但即便如此，*p也不是一个变量，变量只有p。
所谓*p，就相当于汇编中BYTE [p]这种语句的代替。
12
如果你还执拗地说*p是一个变量，那照这种逻辑，变量可远不止2个，还有很多很多。
因为只要给p赋上不同的值，*p就代表完全不同区域的内存内容。
13
■■■■■
下一个问题也是关于声明的：“char *p；”声明的是*p，还是p呢？ 14
这也是一个常见的问题。 先给出结论吧，声明的是p。“既然如此，那为什么不写成char*
p；呢？”有这种想法，说明你这方面的直觉很好。笔者也认为这样写对于初学者来说更简
15
单易懂。事实上，在C语言中写成“char* p；”也可以，既不出错，也不出警告，运行也没
问题。
16
但这种写法有点小问题。如果写成“char* p,q;”，我们看上去会觉得 p和 q都表示地址
图灵社区会员 metorm 专享 尊重版权
74 …… 第4天：C语言与画面显示的练习
的变量，但C编译器却不那样认为，q会被看作是一般的1字节的变量。也就是被解释成“char
*p,q”。为了避免这样的误解，一般的程序员不写成“char* p;”，所以笔者也按照这个习惯编
写程序。另外，如果想要声明两个地址变量，就写成“char *q,*p;”。
■■■■■
今天的专栏写得好长呀，我们来整理总结一下吧。首先，本书中出现的“char *p;”不
必看作指针，这是最重要的决窍。p 不是指针，而是地址变量。不要使用“p 是指针”这种
模棱两可的说法，“p是地址变量”这种说法比较好。
将地址值赋给地址变量是理所当然的。并且，既然地址代表的是内存的地址，可以让该
地址存放自己想放的任何值。虽然也可以将地址变量说成是指针，但笔者听到指针这个说法
也很茫然，所以除了跟别人讨论时以外，笔者也不说指针什么的。
C语言中地址变量的声明，以及给内存地址赋值的，写法不是很习惯，但终究这只是写
法的不同，思考问题的方法与汇编语言差不多。在C语言开发人员看来，“C语言的*p比汇
编语言BYTE [p]，更短小精悍”，确实，简洁是一个长处，但就是因为简洁，才让初学者不
好理解。
C 语言的很多初学者都在学习指针时受挫，以至于会想“如果没有指针就好了”。而事
实上，没有指针的语言也确实是存在的。但这种语言很不好用，因为没有指针就无法往指定
内存的地址存入数据，那怎么往 VRAM上绘制图像呢？这种语言只能让写操作系统变得更
加困难。
笔者也认为，C语言指针的语法很难理解，所以希望能改善。但它像汇编语言一样，能
直接访问地址，这一点非常好。所以希望大家能这样想：“不是要废除指针，而是把指针改
善得更直观易懂。”
44 指针的应用（1）（harib01d）
绘制条纹图案的部分，也可以写成以下这样：
p = (char *) 0xa0000; /*给地址变量赋值*/
for (i = 0; i <= 0xffff; i++) {
*(p + i) = i & 0x0f;
}
本质上讲，所做的事跟之前一样。这里只是想说明，C语言还能用这种方法书写。
55 指针的应用（2）（harib01e）
C语言中，*（p + i ）还可以改写成p[i]这种形式，所以以上片段也可以写成这样：
图灵社区会员 metorm 专享 尊重版权
6 色号设定（harib01f） …… 75
p = (char *) 0xa0000; /*将地址赋值进去*/ 1
for (i = 0; i <= 0xffff; i++) {
p[i] = i & 0x0f;
2
}
其实要做的事还是没有什么变化，这里想要告诉大家各种写法，今后可以根据自己的喜好区
3
别使用。
COLUMN-4 p[i]是数组吗？ 4
写得不好的C语言教科书里，往往会说p[i]是数组p的第i个元素。这虽然也不算错，
4
但终究有些敷衍。如果读者不懂汇编语言，这种敷衍的说法是最省事的。
p[i]与*(p + i )意思完全相同。要是嫌后者太长太麻烦，或者是为了看起来好看就会使用
这种写法。在这个例子里，*(p + i )是6个字符，而p[i]只有4个字符。区别只有这一点，所 6
以大家可以根据喜好使用。p[i]不过是一个看起来像数列的使用了地址变量的省略写法而已。
反过来说，也可以将p[0]写成*p，写成指针的形式反倒是节省了2个字符。总之，根据
7
情况，按自己喜欢的方式写就行了。
不是说改变一下写法，地址变量就变成数组了。大家不要被那些劣质的教科书骗了。编
8
译器生成的机器语言也完全一样。这比什么都更能证明，意思没有变化，只是写法不同。
说个题外话，加法运算可以交换顺序，所以将*(p + i)写成*(i + p) 也是可以的。同理，
将 p[i]写成 i[p]也是可以的（可能你会不相信，但这样写既不会出错，也能正常运行）。a[2] 9
也可以写成 2[a]（这当然是真的）。难道还能说这是名为 2的数组的第 a个元素吗？当然不
能。所以，p[i]也好，i[p]也好，仅仅是一种省略写法，本质上讲，与数组没有关系。
10
66 色号设定（harib01f）
11
好了，到现在为止我们的话题都是以C语言为中心的，但我们的目的不是为了掌握C语言，
而是为了制作操作系统，操作系统中是不需要条纹图案之类的。我们继续来做操作系统吧。 12
可能大家马上就想描绘一个操作系统模样的画面，但在此之前要先做一件事，那就是处理颜
色问题。这次使用的是320× 200的8位颜色模式，色号使用8位（二进制）数，也就是只能使用0～ 13
255的数。我想熟悉电脑颜色的人都会知道，这是非常少的。一般说起指定颜色，都是用#ffffff
一类的数。这就是RGB（红绿蓝）方式，用6位十六进制数，也就是24位（二进制）来指定颜色。 14
8位数完全不够。那么，该怎么指定#ffffff方式的颜色呢？
这个8位彩色模式，是由程序员随意指定0～255的数字所对应的颜色的。比如说25号颜色对 15
应#ffffff，26号颜色对应#123456等。这种方式就叫做调色板（palette）。
如果像现在这样，程序员不做任何设定，0号颜色就是#000000，15号颜色就是#ffffff。其他 16
图灵社区会员 metorm 专享 尊重版权
76 …… 第4天：C语言与画面显示的练习
号码的颜色，笔者也不是很清楚，所以可以按照自己的喜好来设定并使用。
笔者通过制作OSAKA知道：要想描绘一个操作系统模样的画面，只要有以下这16种颜色就
足够了。所以这次我们也使用这16种颜色，并给它们编上号码0-15。
#000000:黑 #00ffff:浅亮蓝 #000084:暗蓝
#ff0000:亮红 #ffffff:白 #840084:暗紫
#00ff00:亮绿 #c6c6c6:亮灰 #008484:浅暗蓝
#ffff00:亮黄 #840000:暗红 #848484:暗灰
#0000ff:亮蓝 #008400:暗绿
#ff00ff:亮紫 #848400:暗黄
所以我们要给bootpack.c添加很多代码。
■■■■■
本次的bootpack.c