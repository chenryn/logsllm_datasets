3
4
5
6
7
8
9
10
__try {
...
// guarded code
value = * ptr ;
...
}
__except ( EXCEPTION_EXECUTE_HANDLER )
{
value = -1;
}
Listing 3: Example for Structured Exception Handling (SEH)
with corresponding ﬁlter on Windows
to -1; if the location is readable, it would be set to the content
of that address. Specifying EXCEPTION EXECUTE HANDLER as
the ﬁlter expression allows the handler to be executed for all
types of exceptions.
Any exception leads to the evaluation of the corresponding
ﬁlter expression which determines the appropriate action. The
ﬁlter can (i) simply resume the program execution (i.e., ignore
the exception completely), (ii) transfer the control ﬂow to
the exception handler, or (iii) forward the exception to the
next handler. The ﬁlters are implemented as separate functions
on the binary level and referenced in SEH structures. If an
exception is not handled and it is considered fatal by the
operating system, it causes program termination. This is also
the case for access violations generated by scanning attempts.
If an attacker can control dereferences inside of a guarded
code block and the corresponding ﬁlter allows either handling
or ignoring of access violations, she is able to scan arbitrary
memory.
To automatically locate potential memory oracles, we ﬁrst
need to collect all available exception handlers and their
guarded code regions. This is done via static analysis of the
target binary. We then discard any exception handlers which
are not able to handle access violations as indicated by their
ﬁlters. For this we symbolically execute the ﬁlter functions.
The resulting set of potential code locations is then analyzed
with the tools described in the previous section: instead of
system APIs, we now target the guarded code locations.
C. Swallowed exceptions
On further investigation we also added a third class of
possible memory oracles which was not covered before. There
are circumstances where exceptions are silently ignored. Here
we do not consider cases where an exception handler of a
program simply ignores the fault and continues execution or
a system API detects an error and the user program does
not check the error status. While leading to the same result,
suppressing of memory faults, these methods deliver the error
status to the user program, it just does not act on them. Instead
swallowed exceptions give no feedback to the user program
that an exception occurred. An example are user-kernel-user
callbacks [10], where the exception handling mechanism can
not support the context switches. The result is that the calling
program has no way of detecting that an exception occurred.
We do not consider this class of crash-resistant primitives in
our analysis.
IV. IMPLEMENTATION
In the following, we brieﬂy outline the implementation of
our framework and describe the reasons for our design choices.
Implementation details are available in the corresponding
technical report [27].
A. Syscalls on Linux
This exception handler could be used to probe memory
addresses, if an attacker controls the value of ptr. In the case of
any exception, including access violations, value would be set
On Linux, we use dynamic taint tracking to isolate viable
candidates. We target common server applications with test
cases, allowing for sufﬁcient code coverage. As we reuse test
194
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:22 UTC from IEEE Xplore.  Restrictions apply. 
cases and want to support additional applications with minor
changes, we chose a minimally invasive approach. The server
program is instrumented with libdft [25]—a data ﬂow tracking
library which we extended with byte granular taint tracking—
and the corresponding client program is controlled by our
monitor application. The monitor can send client and server
custom commands to control the taint state and invalidate
pointer arguments. After a test run we obtain a list of potential
crash-resistant primitives with details on which arguments were
valid or invalid during the test run. This list is then veriﬁed
manually to eliminate false positives.
B. Windows API Functions
As the Windows API does not deﬁne error states as uniformly
as the Linux syscall interface, we need to isolate appropriate
target functions ourselves. For this we use a fuzzing approach to
gather a list of functions that handle invalid pointer arguments
gracefully. Afterwards we locate any usage of these functions
in the targeted applications. For this we use the dynamic
instrumentation framework DynamoRIO [19]. The resulting
list of call sites is then reduced using heuristics to only retain
promising candidates. At the end of this analysis phase, the
results need to be manually veriﬁed to exclude any false
positives, mainly those cases in which the pointer arguments
are either short lived stack variables or volatile heap locations,
and thus cannot be controlled by the attacker.
C. Exception Handlers
Aside from the system level candidates, we also target
application-speciﬁc memory oracles in the form of exception
handlers. For this we use the fact that under 64bit Windows
every function in an application needs to provide stack unrolling
information in case it is contained in the call stack of an
exception. As such, we can parse the corresponding .pdata
section and retrieve the list of all exception handlers in an
executable module. We then use symbolic execution and the
SMT solver Z3 [32] to ﬁlter out the exception ﬁlters that allow
either all exceptions or at least access violations to be handled.
After this analysis step, we reuse the analysis methods we
developed for the tracking of API functions and target the
code covered in the exception handlers. At the end, we again
manually verify the results.
V. EVALUATION RESULTS
Based on our prototype implementation, we now discuss the
results of our analysis on binary executables for both Linux
and Windows.
A. Syscalls on Linux
We evaluated our framework with widely used server
applications on Linux. In particular, using our framework, we
ran the standard test suites for the following server programs:
Nginx 1.9, Cherokee 1.2, Lighttpd 1.4, and Memcached 1.4.
We focus on such popular server programs since they all handle
multiple connections per process. An attacker can simply use
one connection to probe a memory address (using a discovered
Table I: Syscalls indicated as potential (±) or valid (+) cr primitives
by our framework on Linux. Green circled ones were manually veriﬁed
to be usable as a cr primitive. The red non-circled plus sign indicates
a result manually veriﬁed to be a false positive.
x
n
i
g
N
±
+
Syscalls
chmod
connect
epoll wait
mkdir
open
read
recv
recvfrom
send
sendmsg
statfs
symlink
unlink
write
e
e
k
o
r
e
h
C
d
p
t
t
h
g
i
l
+
±
±
±
±
±
±
±
±
±
±
±
d
e
h
c
a
c
m
e
M
+
+
±
±
L
Q
S
e
r
g
t
s
o
P
±
±
±
±
±
±
±
crash-resistant primitive) and another connection to exercise
her arbitrary read/write primitives and modify the state of the
probing connection.
For completeness, we also consider server programs that
handle every new connection in an independent worker process,
focusing our analysis on PostgreSQL 9.0. In such cases, the
attacker can only use a single connection to probe and modify
the state of the program. While exploitation is generally
more complicated (it might be harder to restore the preferred
connection state to probe a new memory address), we still found
usable primitives in practice. Note that our goal is simply for the
worker process not to crash and a graceful process termination
is sufﬁcient for our purposes. As the worker process is expected
to terminate after serving a request, this does not constitute
any abnormal action.
Table I shows all the candidates reported by the framework.
As depicted by the non-circled plus-minus sign, many of the
candidates end up in a segmentation fault if we automatically
alter the target memory locations with an invalid memory
address. We have conﬁrmed our framework has ﬂagged all
these cases correctly using manual inspection. Despite the
many invalid candidates, our framework discovered a usable
crash-resistant primitive, depicted with a green circled plus
sign, in all of our server programs (with the two potential
candidates conﬁrmed via manual veriﬁcation).
Four candidates in total were indicated as valid candidates by
the framework. We conﬁrmed that our framework has ﬂagged
all these cases correctly using manual inspection, except the
valid candidate on Memcached which turned out to be a false
positive (depicted as a red non-circled plus sign). Manual
inspection revealed that the connection handling thread exits
after the candidate syscall epoll wait returns an error code,
while the server keeps running—which our framework currently
interprets as correct behavior. Subsequent connections, however,
195
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:22 UTC from IEEE Xplore.  Restrictions apply. 
never get processed by the now terminated connection handling
thread and the primitive is effectively unusable for multiple
probing attempts. This false positive can be simply eliminated
by checking the status of connection handling threads, a strategy
which our current prototype does not yet support in a generic
way. From our analysis, we found usable candidates in recv in
Nginx, epoll wait in Cherokee and PostgreSQL, and read in
Lighttpd and Memcached. We exemplify how such candidates
can be used as crash-resistant primitives in Section VI.
B. Windows API Functions
We had to ﬁrst collect crash-resistant API functions on
Windows. We extracted 20,672 API functions from the MSDN
library, of which 11,521 (55.7%) contained at least one pointer
argument. Hence, only these functions served as inputs for the
analysis phase via our custom API fuzzer. As a result, we found
400 API functions that are candidates for a crash-resistance
primitive both under Windows 7 and 10.
In the next step, we attempted to locate these functions
on execution paths, outlined here exemplary for Internet
Explorer 11 (64bit) on Windows 10. For this, we logged all
calls to target API functions while visiting the top 500 websites
from alexa.com [1]. In addition, we ran browser and JavaScript
benchmarks [2], [44] to increase the code coverage. Only 25
crash-resistant API functions were found on an execution path.
Finally, we used our analysis scripts to determine if these
functions were triggered from a JavaScript context. We found
12 functions with this characteristic.
To be a usable crash-resistant primitive, we have to trigger
them from JavaScript and control their arguments; in addition,
we must be able to intercept the return value. To analyze these
two properties, we created instruction traces and analyzed the
resulting execution paths. Unfortunately, all candidates had to
be excluded after a manual analysis since all of the pointer
arguments were unusable for our purposes. The reasons for
this are threefold. First, most functions were query functions
(e.g., GetPwrCapabilities) which are usually called by
supplying a stack-allocated structure. If such a pointer is invalid,
then the stack pointer is corrupted. This leads to an illegal
memory access and causes the program’s termination. Second,
a majority of the remaining candidates’ pointer arguments were
dereferenced outside of the target function. This also leads to
an illegal memory access if the pointer is invalid. Third, we
cannot control the pointer arguments of some candidates since
the pointers were volatile heap pointers which had no previous
references stored in memory.
This negative result for Windows API functions does not
imply that no crash-resistant primitive can be constructed using
our method. The coverage of test cases inﬂuences the number
of excluded functions after code path analysis: only 25 of the
400 candidate API functions were observed on execution paths.
Further work on improving code coverage may lead to more
candidates, and hence yield crash-resistant primitives.
Table II: The number of unique code locations that are guarded by
C-speciﬁc handlers during an Internet Explorer 11 run. The code
locations that appear on the execution path are from the set after
symbolic execution (SB).
DLL
# guarded program code
user32