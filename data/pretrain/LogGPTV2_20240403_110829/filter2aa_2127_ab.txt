我们的改进方案是
•
使用密码学原语（Cryptographic primitives）构造在int、int64等类型长度上的单射函数
•
安全的密码学算法往往考虑了各种攻击手段，但在代码混淆中，我们要考虑的性质似乎只有一
点：约束求解器难以处理它们
# 减小HASH函数混淆方法开销
if (Hash(x) == HC)
Decr(Basic_Block_CodeE, x)
Basic_Block_CodeE
方法
我们提出的若干新混淆方法
# 对3x+1猜想的深入研究
在机器算术中很多时候
3x+1猜想迭代会收敛回0，
比如1431655765 * 3 + 
1 = 0，原因是机器算术
中存在溢出。故而我们过
滤所有 y > 0xFFFF的情
况以避免出现溢出现象
我们使用Angr对编译后的BIN（-O0，无优化）进行分析，尝试
遍历所有可能的执行路径。左图显示的是随着分析的推进，每
Fork一条新路径所需的时间
图中有3处低峰，第1处是刚开始分析时的，而随着Fork路径的
增加（路径约束的复杂化），Fork新路径的时间也随之增加。第
2，3处低峰都对应着该前一条路径已经收敛至1（进入
deadended stash），故而向后回溯重新开始新路径探索
那么… Insight是什么？
•
3x+1猜想可以看成是简单的分段函数
•
简单的分段函数经过n次迭代后可能也能让约束求解器
难以处理
•
x / 2 的值可能是奇数或者偶数，3 * x + 1的值一定是
偶数。正是x / 2产生了路径爆炸
# 先定义一些概念
基于路径爆炸的混淆的强度来源于循环体内路径分支造成的程序状态空间激增。然而并不是任何路径分支类型都是有效
的。比如以下分支就是无效分支：
•
可真可假型的不透明谓词
尽管谓词会使程序状态空间增加, 但谓词的后继基本块的语义均是相同的. 即, 当符号执行工具要求解某一输
入时, 执行了谓词中的任意一条路径等价于探索了所有路径. 故而可真可假型不透明谓词并不能使混淆的强度得到提升.
•
分支条件受循环次数影响
以FOR 1中的循环为例, 当 (i % 2) 成立时, 下一轮循环 (i % 2) 必然不成立. 故而实际上 FOR 1循环体内的状
态空间数仍为 1.
基于此, 我们可以定义符号执行工具寻找到输入值 x 的概率P。
𝑃  1
𝑛 
m:
输入值为 x 时, 循环执行所需次数
n:
循环体内各有效分支分支条件带来的状态空间增量和
需要注意 n 的计算, 以分支条件 exp_a & exp_b 为例, 该分支条件带来的状态空间增量为 3.
FOR 1
for (i = 0; i  更少的迭代次数 => 更少的时间开销
•
不仅仅是一种混淆方法，而是一种构造一类混淆的框架
# 符号内存寻址
我们提到过改进FOR混淆的办法就是增加符号执行工具处理每一条路径所需的时间，符号内存
寻址就是非常好的工具
int i;
scanf(“%d”, &i);
int x = global_table[i]; ← 这就是符号内存寻址
•
符号内存寻址
•
指令访问内存的目标地址包含符号值
•
符号内存模型
•
符号执行工具的内存模型，不同的符号内存模型处理符号内存寻址的能力大不相同
# 符号内存模型
以对 a = table[i] 的内存访问为例
•
Single-object model：EXE，FuzzBall
•
只考虑一种情况，比如随机抽取 i == 12
•
Forking model：KLEE
•
为每一个可能的i的取值Fork新路径
•
Merging model：Angr
•
与Forking model基本相同，但是将这个过程交给了约束处理器进行处理。即向当前路
径的约束中添加Or(i=1, i=2, …), If(i == 1, a = table[1], If(i == 2,  a= table[2], If….))
•
Flat memory model：None
•
将这个内存视为一个连续的数组，由于这样做会产生许多约束，似乎没有符号执行工具
采用这种模型
[1]Timotej Kapus and Cristian Cadar. A segmented memory model for symbolic execution[C]. //In Proceedings of the 
2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of 
Software Engineering.
# 使用符号内存进行“去符号化”
x * (x + 1) % 2 == 1 是永假的不透明谓词
table6中的元素是按0, 1, 2, …255排列的，我们以x
的每个字节作为索引对table6进行了访问
插入“代码片段”前，Angr检测出该不透明谓词所
需的时间为0.05s，插入后，所需时间为62s
这即是前面提到的改进ForObfs的想法：增加符号执
行工具对每一条路径的求解所需时间。至于如何增
加路径总数我们暂且按下不表
# 符号内存的强度来源
为什么插入符号内存代码片段能使Angr求解时间变长
•
访问符号内存所需时间
•
T1 = 17s
•
Angr模拟涉及符号内存问题指令所需时间
•
求解不透明谓词所需时间
•
T2 = 45s
•
为什么从0.05s增加至45s？
•
因为Angr使用的Merge Memory Model
•
下图是变量x的符号表达式，这即是“去符号化”的含义，生成的符号
表达式“大约等价于”让约束求解器暴力遍历每一种取值情况
T1
T2
# 改进HASH Obfs 
•
密码学原语
•
密码中的基础组件
•
以恰当的方式组合起来构成一个高强度的加密系统
•
良好的加密系统需要考虑方方面面的攻击，然而在代码混淆中，我们需要考虑的只有一点：约束
求解器难以处理它
•
单射函数与密码学原语
•
我们将要介绍的密码学原语都可以看成一个单射函数f，单射函数具有一个数学性质：若f(a) ≠ f(b)，
则a ≠ b；若f(a) = f(b)，则a = b
•
多个单射函数复合所得的函数仍是单射函数
•
我们可以迭代使用密码学原语以构造一个约束求解器难以求解的单射函数代替开销高的哈希函数
然而，密码学原语中有一些涉及到了符号内存（AES的S-BOX）以及路径爆炸（Feistel网络结构中存在 if 语
句）难题。在使用它们时，我们不确定强度到底来源于原语本身，还是同时引入的符号内存以及路径爆炸难
题。故而，我们将要使用的原语都不涉及到两种难题
# 可以采用的原语
•
Feistel网络结构 → Feistel函数
•
Input: L, R；G是任意一个单射函数
•
L ^= G(R)
•
L, R = R, L
•
L ^= G(R)
•
仿射变换
•
f(x) = ax + b mod m，若GCD(a, m) = 1，则为仿射变换。int类型上进行运算时可以认为m = 2
•
数据依赖的循环移位
•
Input: a, b；RotateL是左循环移位
•
a ← RotateL(a + b, b)
•
b ← RotateL(a + b, a)
•
异或移位
•
f(a) = a ^ (a >>) n)，>>>表示逻辑右移，即高位补0的右移
•
数据项扩展
•
将 n 字节扩展到 m 字节，其中 m > n，出现于SHA-1等哈希函数中
# Feistel函数单射性证明
使用反证法进行证明，不妨假设类Feistel函数不是单射的，则存在I0  𝐿0, 𝑅0 , 𝐼1  𝐿1, 𝑅1 , 𝐼0  𝐼1, 𝑓 𝐼0  𝑓 𝐼1
𝐿0⨁𝐺 𝑅0  𝐿1 ⊕ 𝐺 𝑅1 ①
𝑅0⨁𝐺 𝐿0⨁𝐺 𝑅0
 𝑅1⨁𝐺 𝐿1⨁𝐺 𝑅1
②
进行分类讨论，
1) 𝐿0  𝐿1, 𝑅0  𝑅1
将①代入②，有𝑅0⨁𝐺 𝐿0⨁𝐺 𝑅0
= 𝑅1⨁𝐺 𝐿0⨁𝐺 𝑅0
，显然，由异或运算性质有𝑅0  𝑅1，与已知条件矛盾
2) 𝐿0  𝐿1, 𝑅0  𝑅1
由①知， 𝐺 𝑅0  GR1，则有𝑅0  𝑅1，与已知条件矛盾
3) 𝐿0  𝐿1, 𝑅0  𝑅1
与2)同理
综上所述，原命题得证，f(x)是单射函数
# 类Feistel函数
在证明过程中，我们使用了⊕运算的一个性质，即若a1 ≠ a2，a1 ⊕ b ≠ a2 ⊕ b
换言之，我们可以将⊕运算符重定义为其它运算，只要满足上述性质即可
基于此，我们可以提出一系列不同的单射函数，我们称之为类Feistel函数
f(L, R) = (L ⊕ G(R), R ⊕ G(L ⊕ G(R)))，其中， ⊕运算符可以重定义
我们使用一种：a ⊕ b = f(a) ^ g(b)，f，g均为单射函数
显然，对 a1 ≠ a2，假设存在 a1 ⊕ b = a2 ⊕ b，则有f(a1) ^ g(b) = f(a2) ^ g(b)，f, 
g均为单射函数，显然，有f(a1) = f(a2)，与定义矛盾，即满足上述性质
# 组合生成一个加密
•
将 4 字节的data变量扩展至 8 字节
•
进行了 4 轮类Feistel函数加密
•
类Feistel函数中的⊕运算重定义为my_xor
•
每一轮类Feistel函数加密结束后都再进行一次
仿射变换以及数据依赖的循环移位
•
Angr无法在6h内返回正确的输出结果
•
Insight
•
Feistel网络结构
•
简单复合不同原语并不会有好的效果，
复合64次异或移位与仿射变换Angr
仍能在可接受时间内输出结果
•
数据扩展
•
将输入扩展后再进行处理也能有效抵
抗约束求解器
# 结合符号内存改进ForObfs
前文我们讨论了利用符号内存增加求解一条路径所需的时间，现在我们讨论如何增加路径总数
•
Insight
•
数据扩展前首先对原数据进行
“去符号化”操作，以增加约束
求解器求解时间
•
基于原数据取值情况来确定扩展
数据方式能有效增加路径总数
•
效果
•
Angr求解出一条deadended路
径所需时间约为400s
•
4  400𝑠  28.4ℎ 极端复杂情况
•
400s 极端简单情况
•
极端复杂情况
•
Angr最后才遍历到正确的执
行路径
•
极端简单情况
•
Angr第一次就遍历到正确的
执行路径
•
Angr无法在2h内返回结果
实验