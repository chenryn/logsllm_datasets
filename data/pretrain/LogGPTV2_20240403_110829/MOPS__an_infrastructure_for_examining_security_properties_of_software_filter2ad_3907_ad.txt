stack context in env which has been saved by setjmp(env),
if the program uses multiple jump buﬀers, we need to match
every longjmp with its corresponding setjmp. Pattern vari-
ables (Section 3.1.2) handle this naturally, so long as there
is no aliasing.
5.1.4 Results
MOPS detected the vulnerability in wu-ftpd 2.4 beta 11
and discovered the oﬀending path that was given in the re-
port of the vulnerability [12].
wu-ftpd version 2.4 beta 12 ﬁxed the vulnerability by safe-
guarding every seteuid call with enabling/disabling signals.
This new version precedes every call to gain privilege (se-
teuid(0)) with a call to disable signals and follows every
call to drop privilege (seteuid(!0)) with a call to enable sig-
nals. We used MOPS to verify that this new version satisﬁes
Property 4, as given above.
5.2 Checking Proper Dropping of Privilege
Many server processes start with root privilege in their
user IDs. They often need to drop privilege temporarily
before doing untrusted operations on a user’s behalf or to
drop privilege permanently before passing control to the
user. Failure in dropping privilege may allow an attacker
R!=0,E!=0,S=0,CE=1,CP=1R=0,E=0,S=0,CE=1,CP=1R!=0,E!=0,S!=0,CE=0,CP=0R!=0,E=0,S=0,CE=1,CP=1R=0,E=0,S!=0,CE=1,CP=1R!=0,E=0,S!=0,CE=1,CP=1R=0,E!=0,S=0,CE=1,CP=1R=0,E!=0,S!=0,CE=1,CP=1R=0,E!=0,S=0,CE=0,CP=1R=0,E!=0,S!=0,CE=0,CP=1R!=0,E!=0,S=0,CE=0,CP=1EPERMR!=0,E=0,S!=0,CE=0,CP=1R=0,E=0,S=0,CE=0,CP=1R=0,E=0,S!=0,CE=0,CP=1R!=0,E=0,S=0,CE=0,CP=1R!=0,E!=0,S=0,CE=0,CP=0R=0,E=0,S=0,CE=0,CP=0R=0,E=0,S!=0,CE=0,CP=0R=0,E!=0,S!=0,CE=0,CP=0R=0,E!=0,S=0,CE=0,CP=0R!=0,E=0,S=0,CE=0,CP=0R!=0,E=0,S!=0,CE=0,CP=0to take control of the application or even the OS.
To detect this vulnerability, we need to ﬁnd which state-
ments in the program may be executed with privilege. Us-
ing the techniques described in Section 4, we built an FSA
for describing privilege transitions in each process on Linux
(Figure 9 shows the FSA, where for clarity all the labels of
the transitions are removed). Each state in the FSA encodes
whether the root privilege is present in the ruid, euid, and
suid. By using MOPS to ﬁnd, for each statement in the
program, the set of states in the FSA that the statement
may be executed in (Section 3.2), we are able to identify
all the statements that may be executed with privilege, and
therefore to determine whether each operation that intends
to drop privilege may fail. By this approach, we identiﬁed
two known vulnerabilities in sendmail : sendmail 8.10.1 fails
to drop root privilege in user IDs permanently due to a bug
in the Linux kernel and an unexpected interaction between
the user IDs and the capabilities [16], and sendmail 8.12.0
fails to drop privilege in group IDs permanently due to an
unexpected interaction between the user IDs and the group
IDs [19]. More details of these vulnerabilities may be found
elsewhere [8].
5.3 Verifying Success of System Calls
Failure of certain security related system calls may cause
vulnerability. For example, if setuid(getuid()) fails, the call-
ing process fails to drop privilege permanently which may
allow an untrusted application to take over the OS. We ob-
tain the following security property:
Property 5: the setuid system call should never
fail.
The FSA that we built for modeling uid-setting system
calls includes a state that represents failed calls. With this
FSA, MOPS is able to verify that no uid-setting system calls
may fail in OpenSSH 2.5.2.
5.4 Performance
We measured the performance of MOPS by sendmail 8.12.0,
which has 53k lines of code, in the experiment described in
Section 5.2. On an 1.5GHz Pentium machine, MOPS spent
110 seconds in parsing the source ﬁles and 95 seconds in
model checking. This computation needed less than 300MB
of memory. This suggests that MOPS will scale well to large
security-relevant programs.
6. DISCUSSION
The two major goals of MOPS are soundness and scala-
bility. Soundness will enable MOPS to be used not only as
a bug-ﬁnding tool but also as a property-veriﬁcation tool.
To evaluate the soundness of MOPS, let us look at the two
stages of MOPS: transforming a C program into a PDA, and
model checking the PDA. The latter stage is always sound.
The former stage is sound as long as every execution path
in the program is captured in the PDA. This requires that
the program be a portable, single-threaded C program that
has no implementation-deﬁned behavior:
for example, no
buﬀer overruns and no runtime code generation. In addition,
MOPS ignores control ﬂow by function pointers, signal han-
dlers, and non-local jumps via setjmp/longjmp. Although
this approximation introduces unsoundness, it is not a fun-
damental limitation of the approach but rather a limitation
of the current implementation. We can overcome this prob-
lem by manually transforming the control ﬂow that MOPS
ignores to the equivalent ones that MOPS considers, as we
did in Section 5.1.3. We are working on automating this
process and we hope to add it to a future version of MOPS.
Scalability will enable MOPS to work on a broad range of
programs, especially the more complex ones which are more
error-prone. MOPS has achieved high scalability by disre-
garding most data ﬂow and compacting the CFGs very eﬃ-
ciently [7]. This advantage, however, comes with the price
of lower precision: MOPS may mistakenly consider paths
that are infeasible in the program to be feasible, and issue
extraneous warnings. Although there is always a trade-oﬀ
between scalability and precision, we are investigating how
much we can push MOPS’s precision without sacriﬁcing scal-
ability.
7. RELATED WORK
A number of static analysis techniques have been used
to detect speciﬁc security vulnerabilities in software. Wag-
ner et al. used integer range analysis to ﬁnd buﬀer over-
runs [18]. Koved et al. used context sensitive, ﬂow sensitive,
interprocedural data ﬂow analysis to compute access rights
requirement in Java with optimizations to keep the analysis
tractable [15]. CQUAL [11] is a type-based analysis tool that
provides a mechanism for specifying and checking properties
of C programs. It is used to detect format string vulnera-
bilities [17] and to verify authorization hook placement in
the Linux Security Model framework [20], which are exam-
ples of the development of sound analysis for veriﬁcation of
particular security properties. The application of CQUAL,
however, is limited by its ﬂow insensitivity and context in-
sensitivity, although it is being extended to support both.
Metal [9, 1] is a general tool that checks for rule vio-
lations in operating systems, using meta-level compilation
to write system-speciﬁc compiler extensions. The goals of
Metal and MOPS are diﬀerent. Metal is aimed at ﬁnd-
ing bugs with few false positives. Therefore, false nega-
tives are quite possible and it is neither sound nor complete.
On the other hand, MOPS is aimed at verifying security
properties with no false negatives, which is achieved by its
soundness (modulo the mild assumptions discussed in Sec-
tion 6). Moreover, Metal is primarily an intra-procedural
tool — inter-procedural checking requires extra eﬀort from
the user. However, since interprocedural bugs are more elu-
sive, automated tools become more valuable when they ﬁnd
interprocedural bugs. MOPS is fully interprocedural.
SLAM [2, 3] is a pioneer project that uses software model
checking to verify temporal safety properties in programs. It
validates a program against a well designed interface using
an iterative process. During each iteration, a model checker
determines the reachability of certain states in a boolean ab-
straction of the source program and a theorem prover ver-
iﬁes the path given by the model checker.
If the path is
infeasible, additional predicates are added and the process
enters a new iteration. SLAM, however, does not yet scale
to very large programs. Compared to SLAM, MOPS trades
precision for scalability and eﬃciency by considering only
control ﬂow and ignoring most data ﬂow, as we conjecture
that many security properties can be veriﬁed without data
ﬂow analysis. Also since MOPS is not an iterative process,
it does not suﬀer from possible non-termination as SLAM
does.
Jensen et al. model checked a special class of security prop-
erties in Java using only control ﬂow analysis [14, 4].
Its
algorithm, however, requires that one speciﬁes a ﬁxed, ﬁnite
bound on the size of the program stack. The model checking
algorithm in MOPS is based on the work by Esparza [10],
which properly handles stacks of unbounded size. We have
extended the algorithm with backtracking and CFG com-
paction [7].
8. CONCLUSIONS
In this paper, we have described a formal approach that
is able to check a wide range of security properties in large
programs eﬃciently. We have implemented this approach in
a tool called MOPS. In our approach, we identify rules of
safe programming practice, encode them as security prop-
erties, and describe them by Finite State Automata (FSA).
To check these properties in a program, MOPS models the
program as a pushdown automaton (PDA) and uses model
checking techniques to determine the reachability of risky
states in the PDA. The major advantages of this approach
are: (1) since it is fully interprocedural, it is especially use-
ful in ﬁnding interprocedural bugs, which are more likely
to elude manual audit; (2) since it is sound (modulo mild
assumptions), it can reliably catch all bugs of the speciﬁed
types; (3) thanks to our novel compaction algorithm, MOPS
is eﬃcient and scales to handle large programs. Preliminary
evidence suggests that MOPS will be helpful in ﬁnding var-
ious types of security vulnerabilities in C programs.
We are working on extending MOPS. We are investigating
how much data ﬂow analysis we can incorporate into MOPS
without aﬀecting its scalability. We are also experimenting
with checking more security properties in more programs so
that we can improve MOPS as we gain more experience.
9. ACKNOWLEDGMENT
We thank Drew Dean for suggesting the security property
regarding setjmp and longjmp. Robert Johnson helped with
the initial implementation of pattern variable and David
Schultz helped improve the usability of MOPS. We are grate-
ful to Zhendong Su, David Schultz, Naveen Sastry, Dawn
Song, Helen Wang, and the anonymous reviewers for their
valuable comments.
10. AVAILABILITY
MOPS is available at:
http://www.cs.berkeley.edu/~daw/mops/
11. REFERENCES
[1] K. Ashcraft and D. Engler. Using programmer-written
compiler extensions to catch security holes. In
Proceedings of IEEE Security and Privacy 2002, 2002.
[2] T. Ball and S. K. Rajamani. Automatically validating
temporal safety properties of interfaces. In SPIN 2001,
Workshop on Model Checking of Software, 2001.
[3] T. Ball and S. K. Rajamani. The SLAM project:
Debugging system software via static analysis. In
POPL 2002, 2002.
[4] F. Besson, T. Jensen, D. L. Metayer, and T. Thorn.
Model checking security properties of control ﬂow
graphs. Journal of Computer Security, 9:217–250,
2001.
[5] M. Bishop and M. Dilger. Checking for race conditions
in ﬁle access. Computing Systems, 9(2):131–152, 1996.
[6] CERT. CERT Advisory CA-1997-16: ftpd signal
handling vulnerability.
http://www.cert.org/advisories/CA-1997-16.html.
[7] H. Chen and D. Wagner. MOPS: an infrastructure for
examining security properties of software. Technical
Report UCB//CSD-02-1197, UC Berkeley, 2002.
[8] H. Chen, D. Wagner, and D. Dean. Setuid
demystiﬁed. In Proceedings of the Eleventh Usenix
Security Symposium, San Francisco, CA, 2002.
[9] D. Engler, B. Chelf, A. Chou, and S. Hallem.
Checking system rules using system-speciﬁc,
programmer-written compiler extensions. In OSDI,
2000.
[10] J. Esparza, D. Hansel, P. Rossmanith, and
S. Schwoon. Eﬃcient algorithms for model checking
pushdown systems. Technical report, Technische
Universit¨at M¨unchen, 2000.
[11] J. Foster, M. F¨ahndrich, and A. Aiken. A theory of
type qualiﬁers. In ACM SIGPLAN Conference on
Programming Language Design and Implementation
(PLDI’99), May 1999.
[12] D. Greenman. Serious security bug in wu-ftpd v2.4.
http://online.securityfocus.com/archive/1/
6056/1997-01-04/1997-01-10/2.
[13] J. Hopcroft and J. Ullman. Introduction to automata
theory, languages, and computation. Addison-Wesley,
1979.
[14] T. Jensen, D. L. Metayer, and T. Thorn. Veriﬁcation
of control ﬂow based security properties. In
Proceedings of the 1999 IEEE Symposium on Security
and Privacy, 1999.
[15] L. Koved, M. Pistoia, and A. Kershenbaum. Access
rights analysis for java. In Proceedings of the 17th
Annual ACM Conference on Object-Oriented
Programming, Systems, Languages, and Applications,
2002.
[16] Sendmail Inc. Sendmail workaround for linux
capabilities bug. http://www.sendmail.org/
sendmail.8.10.1.LINUX-SECURITY.txt.
[17] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner.
Detecting format string vulnerabilities with type
qualiﬁers. In Proceedings of the 10th USENIX Security
Symposium, 2001.
[18] D. Wagner, J. Foster, E. Brewer, and A. Aiken. A ﬁrst
step towards automated detection of buﬀer overrun
vulnerabilities. In Proceedings of NDSS 2000, 2000.
[19] M. Zalewski. Multiple local sendmail vulnerabilities.
http://razor.bindview.com/publish/advisories/
adv_sm812.html.
[20] X. Zhang, A. Edwards, and T. Jaeger. Using CQUAL
for static analysis of authorization hook placement. In
Proceedings of the Eleventh Usenix Security
Symposium, August 2002.