Bluehat Shanghai 2019 |
David “dwizzzle” Weston |
Microsoft OS Security Group Manager
Advancing Windows Security
早上好 上海！
Windows for PCs
Familiar desktop experience
Broad hardware ecosystem
Desktop app compat
One Core OS 
Base OS
App and Device Platform 
Runtimes and Frameworks
Windows on XBOX
10 Shell experience
Unique security model
Shared gaming experience
Windows on IOT
Base OS
App and Device Platform 
Runtimes and Frameworks
Windows for …
Form factor appropriate 
shell experience
Device specific scenario
support
Windows is evolving….
Malicious code 
cannot persist on a 
device.
Violations of 
promises are 
observable.
All apps and 
system 
components have 
only the privilege 
they need.
All code executes 
with integrity.
User identities 
cannot be 
compromised, 
spoofed, or stolen.
Attacker with 
casual physical 
access cannot 
modify data or 
code on the device.
Increasing Security
Windows 10 S
10 S
Classic 
2
1
Mandatory Code Signing
Complete Password-less
“Admin-less” user account
4
3
Internet scripts and macros 
blocked
1
Run as admin
2
Execute Unsigned Code
3
Use passwords
4
Mitigations not always on
10 S:  Millions of installs, no widespread detections of malware
All code executes with integrity.
Code Integrity Improvements
CI policy removes many “proxy” binaries
Store signed only apps (UWP or Centennial)
“Remote” file extensions that support dangerous actions are blocked
Remote Office Macros are blocked by default
Windows 10 S
All binaries
Microsoft Signed
Proxy Binaries
Dangerous 
Handlers
Remote 
Dangerous 
Files
1st Order Code Integrity protection
A “1st order” CI bypass enables a remote attack to 
trigger initial unsigned code execution 
10 S focuses on preventing “1st” order bypasses
A “2nd order” bypass enabled additional unsigned code 
execution after reaching initial code execution
10 S offers less durable guarantees for “2nd” order 
bypasses
Windows 10 S
Network
Physical Machine
Trigger 
Handler
No
Yes
Exploit mitigation Strategy
Increase Cost of 
Exploitation
Control Flow 
Integrity
Signed Code Only
Read-only Data
Eliminate bug classes
Control Flow Challenges
Dangerous call 
targets
Unprotected 
Stack
Data 
corruption
1
2
3
((void(*)(int, int)) funcptr)(0, 1);
obj->method1();
void function_A(int, int) { ... }
int
function_B(int, int) { ... }
void function_C(Object*)
{ ... }
void Object::method1()
{ ... }
void Object::method1(int, int) { ... }
void Object::method2()
{ ... }
void Object2::method1()
{ ... }
Call sites
Call Targets
CFG
First generation CFI in Windows, coarse grained for compatibility and performance
“Export suppression” used to reduce number of call sites in specific processes (example: Microsoft Edge)
Improving Control Flow Integrity
Introducing: XFG
Goal: Provide finer-grained CFI in a way that is efficient and compatible
Concept: restrict indirect transfers through type signature checks
((void(*)(int, int)) funcptr)(0, 1);
obj->method1();
void function_A(int, int) { ... }
int
function_B(int, int) { ... }
void function_C(Object*)
{ ... }
void Object::method1()
{ ... }
void Object::method1(int, int) { ... }
void Object::method2()
{ ... }
void Object2::method1()
{ ... }
Call Sites
Call Targets
Improving Control Flow Integrity
XFG design: basics
Assign a type signature based tag to each address-taken function
For C-style functions, could be:
hash(type(return_value), type(arg1), type(arg2), ...)
For C++ virtual methods, could be:
hash(method_name, type(retval), highest_parent_with_method(type(this), method_name), type(arg1), type(arg2), ...)
Embed that tag immediately before each function so it can be accessed through function pointer
Add tag check to call-sites: fast fail if we run into a tag mismatch
Improving Control Flow Integrity
mov
rax, [rsi+0x98]
; load target address 
call [__guard_dispatch_icall_fptr]
.align 0x10
function:
push rbp
push rbx
push rsi
...
mov
rax, [rsi+0x98]
; load target address 
mov
r10, 0xdeadbeefdeadbeef
; load function tag
call [__guard_dispatch_icall_fptr_xfg] ; will check tag
.align 0x10
dq 0xcccccccccccccccc ; just alignment
dq 0xdeadbeefdeadbeef ; function tag
function:
push rbp
push rbx
push rsi
...
CFG instrumentation: Call Site 
xFG instrumentation : Call Site 
Target
Target
XFG Security
C-style function pointers can only call address-taken functions with same type signature
Call-site and targets have same number of arguments, arguments and return value have same types
C++ virtual methods can only call methods with same name and type in their class hierarchy
Can’t call wrong-type overload methods
Can’t call methods from other class hierarchies
Can’t call differently-named methods with same type in same hierarchy
This is much stronger than CFG, although it is an over-approximation
It should be noted that the use of a hash function means there could technically be collisions, but that is very unlikely (especially in a useful way) on a ~55 bit hash
Improving Control Flow Integrity
Control Flow Challenges
Dangerous call 
targets
Unprotected 
Stack
Data 
corruption
1
2
3
Shadow Stack Protection
Initial attempt to implement stack protection in software failed
OSR  designed software shadow stack (RFG) did not survive internal offensive 
research
Control-flow Enforcement Technology (CET)
Return address protection via a shadow stack
Hardware-assists for helping to mitigate control-flow hijacking & ROP
Robust against our threat model (assume arbitrary RW)
Rearward Control Flow
CET Shadow Stack Flow:
Call pushes return address on both stacks
Ret/ret_imm
pops return address from both stack
Execption if the return addresses don’t match
No parameters passing on shadow stack
Return EIPn-1
Param 1
Param 2
Return EIPn
Return EIPn-1
Return EIPn
Stack usage on near CALL
ESP 
after 
call
SSP
after 
call
+0
+4
Control Flow Integrity Challenges
Dangerous call 
targets
Unprotected 
Stack
Data 
corruption
1
2
3
Introducing: Kernel Data Protection
Problem: Kernel exploits in Windows leverage 
data corruption to obtain privilege escalation
Current State: Hypervisor-based code integrity 
prevents dynamic code injection and enforces 
signing policy
Prevent code is not enough, kernel has many 
sensitive data structures
Kernel Data Protection (KDP) uses Secure Kernel 
to enforce immutability
Data Corruption Protection
CVE-2016-7256 exploit: Open type font elevation of privilege
Corrupting Code Integrity Globals (credit: FuzzySec)
Data Corruption Protection
Admin
Static Data
Dynamic Data
VBOX
Capcom
CPU-Z
Attacker Process
NTSTATUS MmProtectDriver (
_In_ PVOID AddressWithinSection,
_In_ ULONG Size,
_In_opt_ ULONG Flags);
Kernel Data Protection:
Mechanism to perform read-only pool allocations
RO PTE Hypervisor Protected when VBS is enabled
Validation mechanism to allow callers to detect whether 
the memory they’re referencing is protected pool allocation
All apps and system components have only 
the privilege they need
Introducing: Admin-less
Elevation is been blocked Admin-less S mode
New Standard user type can make some 
device-wide changes 
Kernel Data Protection (KDP) uses Secure Kernel 
to enforce immutability
“Admin-less” Mode
Malicious code cannot persist on a device.
Firmware Security Issues
ESET discovers SEDNIT/APT28 UEFI malware
SMM attacks to bypass VBS
“ThinkPWN” exploit of Lenovo firmware
System Guard with DRTM
Utilize DRTM (Intel, AMD, QC) to perform TCB measurements from a Microsoft 
MLE
“Assume Breach” of UEFI and measure/seal critical code and data from hardware 
rooted MLE
Measured values:
Code integrity Policy
Hypervisor, kernel hashes
UEFI Vars
Etc…
Zero Trust
Measurements of key properties available in PCRs and TCG logs
Attest TCB components through System Guard runtime attestation + Microsoft 
Conditional Access + WDATP
SMM Attacks
Can be used to tamper HV and SK post-MLE
SMM paging protections + attestation on roadmap
Improving Boot Security
Improving Boot Security
System Guard with DRTM
External researchers and OSR REDTEAM highlighted SMM risks for DRTM 
and VBS
Arbitrary code execution in SMRAM can be used to defeat Hypervisor
Malicious code running in SMM is difficult to detect
Improving Boot Security
SMM vulnerabilities used in OSR 
REDTEAM reported to Lenovo
Mitigating SMM exploitation
Intel Runtime BIOS resilience provides the following security 
properties for SMM:
SMM entry point locked down
All code within SMM locked down
Memory map and page properties locked down
OS  and HV memory not directly accessible from SMM
Protecting SMM
SMM Page 
Table
SMI 
Handler
SMM 
BootCode/BootData
MMIO
SMRAM
Reserved
ACPINvs
RuntimeCode/RuntimeData
ACPI Reclaim
BootCode/BootData
LoaderCode/LoaderData
SMM Paging Audit
SMM Protection
Attackers with casual physical access 
cannot modify data or code on the device.
Increasing Physical Attacks
LPC/SPI TPM VMK Key Extraction with Logic Analyzer
Sources: 1, 2, 3
Bitlocker Cold Boot Attacks
Sources: 1
DMA Attacks with PCILeech
Sources: 1, 2
Security Goals
Prevent ‘’evil cleaner’’ drive by physical attacks from 
malicious DMA attacks
Design Details
Use IOMMU to block newly attached Thunderbolt™ 3 
devices from using DMA until an user is logged in
UEFI can enable IOMMU an BME in early boot until Windows  
boots (See Project Mu)
Automatically enable DMA remapping with compatible 
device drivers
In future releases, we are looking to harden protection on all 
external PCI ports and cross-silicon platforms 
Windows DMA protection
Connect peripheral
New devices are 
enumerated and 
functioning
OS
User
Peripheral 
Drivers opted-
in DMAr?
Yes
Enable DMAr for 
the peripherals
No
User logged in 
AND Screen 
unlocked?
No
Wait for user 
to login/
unlock 
screen
Yes
Security Goals
Prevent ‘’evil cleaner’’ drive by physical attacks from 
malicious DMA attacks
Design Details
Use IOMMU to block newly attached Thunderbolt™ 3 
devices from using DMA until an user is logged in
Automatically enable DMA remapping with compatible 
device drivers
In future releases, we are looking to harden protection on all 
external PCI ports and cross-silicon platforms 
Thunderclap Attack
Locked device
Encryption key is removed from memory
Encryption key is recomputed using user entropy
Windows Data Protection Under Lock
Per-file encryption provides a second layer of protection at rest
Key is derived from user secret (Hello, Biometric)
Unlocked device
Messages
Encrypted, key discarded upon lock
Passwords, 
credit card 
info
Health data
Documents 
and photos
App1 Data
App2 Data
App3 Data
Encrypted, key discarded upon shutdown
App1
App2
App3
Unenlightened Apps
Messaging 
Apps
Edge
Health
Mail, 
Photos, 
Documents, 
etc.
Enlightened Apps
BitLocker protection 
promise
User identities cannot be compromised, 
spoofed, or stolen.
Windows Hello and NGC
Offers biometric authentication and hardware backed 
key storage
PIN vulnerable to input attacks from malicious admin
Improving Identity Security
Future version of Windows include biometric hardening 
enabled through virtualization
Biometric hardening of the data path using 
virtualization
Hardening of credential release
Improving Identity Security
Sensor Adapter
Biometric Unit
Engine Adapter
Feature Extraction
Template Construction
Storage Adapter
Sensor
Driver
Windows Biometric Framework
Template DB
Spoofs
Replay
Leak/Inject
Replay
Leak/Inject
Modify 
templates
Template 
injection
Modify match 
result
Add 
unauthorized 
templates 
Inject match 
event
Replay
Steal TPM 
authblob
Windows Hello Attack Surface
Sensor
Driver
Template DB
Engine Adapter
Feature Extraction
Template Construction
Sensor Adapter
Storage Adapter
bioIso.exe
Secure Driver
Windows Hello Attack Surface
Sensor Adapter
Biometric Unit
Engine Adapter
Feature Extraction
Template Construction
Storage Adapter
Sensor
Driver
Template DB
Spoofs
Replay
Leak/Inject
Replay
Leak/Inject
Modify 
templates
Template 
injection
Modify match 
result
Add 
unauthorized 
templates 
Inject match 
event
Replay
Steal TPM 
authblob
Beyond Passwords
Violations of promises are observable.
Platform Tamper Detection for Windows
Spanning device boot to ongoing runtime process tampering
Designed for remote assessment of device health
Platform approach to benefit a variety of 3rd parties and scenarios
Hardware rooted device trust
Leverage the VBS security boundary to raise the bar on anti-tampering
Challenging to build tamper detection schemes on top of Windows
Extensible platform component that can be used via forthcoming public API
Tamper Evident Windows
1 2 3
Admin
EPROCESS
Driver Dispatch
Process Mitigations
VBOX
Capcom
CPU-Z
Attacker Process
Closing
Platform features rapidly changing
Windows is evolving quickly to increase protections against new 
attacks
Aspirational goals to provide strong guarantees across a growing 
threat model
Researchers and Community help us improve
Programs such as bug and mitigation bounty are critical
We want to work together with research communities in China 
and beyond to learn more about current and future attacks
Windows needs the community