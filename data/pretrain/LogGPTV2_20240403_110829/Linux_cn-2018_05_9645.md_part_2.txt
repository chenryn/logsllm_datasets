这个栈帧的内部数据是由两个重要的部分组成：*前一个*栈帧的地址（保存的 `ebp` 值）和函数退出才会运行的指令的地址（返回地址）。它们一起确保了函数能够正常返回，从而使程序可以继续正常运行。
现在，我们来看一下栈帧是如何产生的，以及去建立一个它们如何共同工作的内部蓝图。首先，栈的增长是非常令人困惑的，因为它与你你预期的方式相反。例如，在栈上分配一个 8 字节，就要从 `esp` 减去 8，去，而减法是与增长不同的奇怪方式。
我们来看一个简单的 C 程序：
```
Simple Add Program - add.c
int add(int a, int b)
{
    int result = a + b;
    return result;
}
int main(int argc)
{
    int answer;
    answer = add(40, 2);
}
```
*简单的加法程序 - add.c*
假设我们在 Linux 中不使用命令行参数去运行它。当你运行一个 C 程序时，实际运行的第一行代码是在 C 运行时库里，由它来调用我们的 `main` 函数。下图展示了程序运行时每一步都发生了什么。每个图链接的 GDB 输出展示了内存和寄存器的状态。你也可以看到所使用的 [GDB 命令](https://github.com/gduarte/blog/blob/master/code/x86-stack/add-gdb-commands.txt)，以及整个 [GDB 输出](https://github.com/gduarte/blog/blob/master/code/x86-stack/add-gdb-output.txt)。如下：
![](/data/attachment/album/201805/15/183143nubun1kk11f6kuh7.png)
第 2 步和第 3 步，以及下面的第 4 步，都只是函数的 序言   prologue ，几乎所有的函数都是这样的：`ebp` 的当前值被保存到了栈的顶部，然后，将 `esp` 的内容拷贝到 `ebp`，以建立一个新的栈帧。`main` 的序言和其它函数一样，但是，不同之处在于，当程序启动时 `ebp` 被清零。
如果你去检查栈下方（右边）的整形变量（`argc`），你将找到更多的数据，包括指向到程序名和命令行参数（传统的 C 的 `argv`）、以及指向 Unix 环境变量以及它们真实的内容的指针。但是，在这里这些并不是重点，因此，继续向前调用 `add()`：
![](/data/attachment/album/201805/15/183153s1whezj3xxrs14wx.png)
在 `main` 从 `esp` 减去 12 之后得到它所需的栈空间，它为 `a` 和 `b` 设置值。在内存中的值展示为十六进制，并且是小端格式，与你从调试器中看到的一样。一旦设置了参数值，`main` 将调用 `add`，并且开始运行：
![](/data/attachment/album/201805/15/183201abvr2pppvhdv8per.png)
现在，有一点小激动！我们进入了另一个函数序言，但这次你可以明确看到栈帧是如何从 `ebp` 到栈建立一个链表。这就是调试器和高级语言中的 `Exception` 对象如何对它们的栈进行跟踪的。当一个新帧产生时，你也可以看到更多这种典型的从 `ebp` 到 `esp` 的捕获。我们再次从 `esp` 中做减法得到更多的栈空间。
当 `ebp` 寄存器的值拷贝到内存时，这里也有一个稍微有些怪异的字节逆转。在这里发生的奇怪事情是，寄存器其实并没有字节顺序：因为对于内存，没有像寄存器那样的“增长的地址”。因此，惯例上调试器以对人类来说最自然的格式展示了寄存器的值：数位从最重要的到最不重要。因此，这个在小端机器中的副本的结果，与内存中常用的从左到右的标记法正好相反。我想用图去展示你将会看到的东西，因此有了下面的图。
在比较难懂的部分，我们增加了注释：
![](/data/attachment/album/201805/15/183206o5k7eaatkiztcevw.png)
这是一个临时寄存器，用于帮你做加法，因此没有什么警报或者惊喜。对于加法这样的作业，栈的动作正好相反，我们留到下次再讲。
对于任何读到这里的人都应该有一个小礼物，因此，我做了一个大的图表展示了 [组合到一起的所有步骤](https://manybutfinite.com/img/stack/callSequence.png)。
一旦把它们全部布置好了，看上起似乎很乏味。这些小方框给我们提供了很多帮助。事实上，在计算机科学中，这些小方框是主要的展示工具。我希望这些图片和寄存器的移动能够提供一种更直观的构想图，将栈的增长和内存的内容整合到一起。从软件的底层运作来看，我们的软件与一个简单的图灵机器差不多。
这就是我们栈探秘的第一部分，再讲一些内容之后，我们将看到构建在这个基础上的高级编程的概念。下周见！
---
via:
作者：[Gustavo Duarte](http://duartes.org/gustavo/blog/about/) 译者：[qhwdw](https://github.com/qhwdw) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出