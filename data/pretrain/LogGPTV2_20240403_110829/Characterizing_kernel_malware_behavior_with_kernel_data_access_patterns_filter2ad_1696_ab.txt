by the intersection and union of data behavior proﬁles.
Algorithm 1 Algorithm to derive a set of data behavior
elements in SM that belong to Dr.
return 0
if e.c 6= e′.c ∨ e.o 6= e′.o ∨ e.m 6= e′.m ∨ e.i 6= e′i then
end if
if e.f is an oﬀset then
if CompareElements(e, e′)= 1 then
for each e′ in Dr do
end for
end for
return I
I ← I ∪ {e}
end if
I ← ∅
for each e in SM do
1: function CheckSignature(SM , Dr)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11: end function
12: function CompareElements(e, e′)
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34: end function
if e.f ⊂ e′.f then
end if
if e.f ∈ e′.f then
end if
end if
end if
return 0
if e′.f is an oﬀset then
if e.f = e′.f then
end if
else
return 1
return 1
end if
else
return 1
if e′.f is a range of oﬀsets then
⊲ e′.f is a range of oﬀsets.
⊲ e.f is a range of oﬀsets.
SM and Dr, and returns the set of common elements, I.
Two for-loops at lines 3 and 4 generate a pair of elements
each from SM and Dr, and those elements are compared by
calling the CompareElements function at line 5.
To consider the two compared elements e and e′ as iden-
tical, their c, o, m, and i ﬁelds ﬁrst should be equal. Next,
their oﬀset ﬁelds (e.f and e′.f ) are compared. Because the
oﬀset ﬁeld can be either of an oﬀset or a range of oﬀsets,
there are several cases shown in lines 16-33. If e.f is an oﬀ-
set, it can match either an oﬀset or a range of oﬀsets. If both
e.f and e′.f are an oﬀset, their values should be identical.
If e.f is an oﬀset and e′.f is a range, they can match if e.f
belongs to e′.f ’s range. If e.f is a range of oﬀsets, it can
only match a range of oﬀsets that includes e.f .
3.
IMPLEMENTATION
DataGene generates the patterns of kernel memory ac-
cesses transparently without making changes in the source
code of the OS. To implement this feature, we employ vir-
tualization techniques. We used the QEMU [4] virtualizer
with the KQEMU optimizer for our implementation. The
host machine has 3.2Ghz Pentium D CPU and 2GB RAM.
The guest machine is conﬁgured with 256MB RAM and the
Redhat 8 operating system. This experimental platform is
chosen for the convenience of implementation. However, our
mechanism is generic and applicable to other operating sys-
tems and virtual machine platforms.
We implement the kernel memory mapper and the data
aggregator in the VMM. The kernel memory mapper tracks
kernel memory allocation and deallocation calls and cap-
tures dynamic kernel objects at runtime similar to [21]. When
there is a request to the VMM, a data behavior proﬁle can
be dumped into a ﬁle anytime during the execution of the
guest OS. For the purpose of generating a signature, dump-
ing the proﬁle once the OS is completely shutdown is pre-
ferred to capture most data behavior. However, to detect
kernel malware, the data behavior proﬁle can be generated
and periodically compared with the signature while the OS
is running.
In our experiments, we measured the quality of signatures
whether they trigger false positives as we increased the num-
ber of benign runs and malicious runs used for generating
malware signatures. We found with ﬁve or more sets of
benign runs and malicious runs, we could generate the sig-
natures that do not cause false positives in our testings with
newly generated benign runs. Therefore, we present the data
of these ﬁve sets of runs. However, we believe that a more
number of runs will certainly improve the quality of signa-
tures and it also depends on dynamic workload performed
in each run. In the benign runs, we performed various work-
load from daily commands to non-trivial application bench-
marks. The tested workload includes kernel compilation,
ssh, scp, lsmod, ps, top, find, and ls. Some workloads were
executed for several hours to allow any background admin-
istrative operation to be performed. We also used the work-
load of benign module loading and simple operations of the
/dev/kmem device (e.g., open and close without overwriting
kernel memory).
Among the memory accesses for kernel modules, we ex-
clude the accesses to a kernel module by the same module
which correspond to the accesses to a module’s local vari-
ables. This information is not used to generalize the internal
module activity. However, the accesses across modules are
used after generalizing the accessing code information. In
addition, the kernel data structure module having the admin-
istrative information regarding a kernel module is mapped
to the head of each module’s memory. We treat this part
of memory as a separate data structure from the remaining
module code or data.
4. EVALUATION
In this section we evaluate the eﬀectiveness of our data be-
havior signatures. First, we extract the signatures of three
classic rootkits and match them with benign and malicious
kernel runs. Second, we compare the signatures of all of the
tested kernel rootkits to determine common data behavior
across diﬀerent rootkits and how such common behavior can
be eﬀective in detecting the variants of rootkits. Third, we
list speciﬁc data elements that are shared by rootkit signa-
tures, which provide an in-depth understanding of the attack
operations that are common across kernel rootkits.
4.1 Detecting Kernel Rootkits using Data Be-
havior Signatures
When a data behavior signature is generated, the infor-
mation speciﬁc to the malicious code is generalized in large.
Therefore, we hypothesize that data behavior signatures may
be used not only to detect the malware whose signature is
available, but also to determine the presence of related mal-
ware. In order to validate this hypothesis, we generated the
signatures of three representative rootkits, and tested benign
kernel runs and malicious kernel runs with 16 rootkits.
To generate malware signatures, we chose three rootkits:
adore 0.38, SucKIT, and modhide. The adore rootkit has been
studied in several rootkit defense approaches [17, 18, 23,
22]. This rootkit has several versions with diﬀerences in
Table 1: Properties of benign runs for generating rootkit signatures and testing false positives of signatures.
Properties of a data behavior proﬁle
# of classes for the dynamic objects
# of read code sites for the dynamic objects
# of write code sites for the dynamic objects
# of classes for the static objects
# of read code sites for the static objects
# of write code sites for the static objects
# of false positives
Kernel run for generating signatures
Kernel run for testing false positives
1
206
10976
4342
15800
29609
4605
-
2
204
10857
4301
15800
29556
4617
-
3
223
12576
4885
15800
30151
4707
-
4
207
11365
4503
15800
29749
4632
-
5
223
12934
5176
15800
31353
6837
-
1
223
12610
4890
15800
30151
4707
0
2
223
12636
4911
15800
30172
4714
0
3
223
12635
4925
15800
30156
4710
0
4
223
13087
5285
15800
31053
6968
0
5
223
13118
5281
15800
33776
8025
0
Table 2: The number of matched data behavior elements between three rootkit signatures and the kernel
runs with 16 kernel rootkits (average of 5 runs, Ad1: adore 0.38, Ad2: adore 0.53, Ad3: adore-ng 1.56, SK:
SucKIT).
Signature (SM )
|SM|
45
14797
M
Ad1
SK
modhide
3
Detected
0
13
0
√
fuuld
hide lkm
The number of matched data behavior elements between SM and the kernel runs with the rootkits shown below (|I|).
37
2
0
√
kis modhide modhide1
17
18
1
√
Ad1 Ad2 Ad3
16
45
1
3
0
0
√
√
14797
0
√
14767
0
√
kbdv3
knark
linuxfu Rial
cleaner
hp
3
0
0
√
SK
10
superkit
10
0
16
0
√
5
1
0
√
7
1
0
√
0
0
2
√
5
1
0
√
20
2
0
√
0
0
3
√
0
1
2
√
features and we chose an old version, 0.38, for the signature
to evaluate its eﬀectiveness toward newer rootkit versions
(0.53 and 1.56). SucKIT is known for its attack vector, the
/dev/kmem device, that avoids the conventional driver-based
mechanism [20]. Several other rootkits followed this trend,
using this device while having diﬀerent goals. modhide is a
rootkit packaged with the adore rootkits to hide them from
the list of kernel modules.
We used ﬁve kernel runs with rootkits and ﬁve benign runs
to generate the signatures of such rootkits. Three data be-
havior signatures of the adore, SucKIT, and modhide rootkits
have 45, 14797, and 3 data behavior elements, respectively.
SucKIT has a signiﬁcantly high number of elements because
it scans kernel memory to collect information about the at-
tack targets (e.g., the system-call table), and this behavior
is observed as reading numerous static objects with a variety
of oﬀsets. Since we allow an oﬀset or a range of oﬀsets for
the oﬀset ﬁeld (f ), the number of data behavior elements
can vary depending on the threshold to aggregate the ele-
ments. This number is the trade-oﬀ between the details of
malware behavior and eﬃciency in the size of malware be-
havior. We used 15 for this threshold after trying several
diﬀerent numbers. The modhide rootkit simply manipulates
the kernel module list; thus, it has a few elements.
Using the generated three signatures, we inspected a to-
tal of 85 kernel runs: ﬁve benign runs, and 80 malicious
kernel runs with 16 kernel rootkits (each rootkit was used
to generate ﬁve malicious runs). These 16 rootkits included
the three rootkits used for generating signatures, two newer
versions of adore rootkits, and the other 11 rootkits. The
number of matched elements between the compared signa-
tures and the tested runs are presented in Table 1 (benign
runs) and Table 2 (malicious runs), which will be explained
below in detail.
Reliability in Benign Runs.
Table 1 shows the infor-
mation about two sets of benign kernel execution instances:
ﬁve benign runs used for signatures (columns 2-6) and an-
other ﬁve benign runs for testing potential false positives
(columns 7-11). The top three rows (below the column head-
ing) show information about the dynamic objects, such as
the number of classes for the dynamic kernel objects, the
number of code sites that read the dynamic kernel objects,
and the number of code sites overwriting the dynamic kernel
objects. The next three rows have the similar information
for the static kernel objects. Since static objects (kernel
functions and static data structures) are known at compile
time, the “# of classes for the static objects” has the same
value in diﬀerent runs.
The far right-hand ﬁve columns show the statistics for the
benign runs used for testing false positives of the signatures.
In these kernel runs, we generated an additional variety in
the workload (e.g., more applications and a heavier load with
multiple applications) so that such kernel runs contain more
code paths and data operations beyond the kernel runs used
for generating signatures. This additional runtime variation
results in more code sites for memory accesses (i.e., higher
numbers in # of read code sites and # of write code sites).
In this experiment, no false positive cases were found,
which conﬁrms that our signature generation procedure cap-
tures a reasonably close set of unique data behavior of kernel
rootkits and that the tested runs did not contain any data
behavior that appears in the signatures.
Detecting Rootkits using Data Behavior Signatures.
Malicious kernel runs were next tested by using three signa-
tures to determine any running malware based on the sim-
ilarity of the data access patterns between the compared
signature and the kernel run. We tested a total of 80 ker-
nel runs of 16 rootkits having a variety of targets and at-
tack vectors. For instance, seven rootkits (fuuld, hide_lkm,
hp, linuxfu, cleaner, modhide, and modhide1) directly ma-
nipulate kernel objects (DKOM [6]). Four rootkits (fuuld,
hide_lkm, SucKIT, and superkit) manipulate kernel memory
by using the /dev/kmem memory device, among which two
rootkits (fuuld and hide_lkm) directly manipulate only ker-
nel data and do not violate kernel code integrity. Therefore,
they are not detected by code integrity-based defense sys-
tems [23, 24].
Table 2 presents the number of matched data behavior
elements between signatures and kernel runs with rootkits
(I). Two left-hand columns show the information about
signatures: the name (M ) of the rootkit used for the sig-
nature and the size of the signature (|SM|). The remaining
16 columns present the number of data behavior elements
common in the compared signature (based on the rootkit in
the row heading) and the kernel run (where the rootkit in
the column heading is active). The presented numbers are
the averages of ﬁve kernel runs. However, the numbers are
consistent in the runs with the same rootkit.
Table 3: The number of common data behavior elements in the combination of rootkit signatures (Ad1:
adore 0.38, Ad2: adore 0.53, Ad3: adore-ng 1.56, SK: SucKIT).
M
Ad1
Ad2
Ad3
fuuld
hide lkm
SK
superkit
hp
kbdv3
knark