′
′
Now, suppose there is an eﬃcient KE-attacker A who succeeds, by forging attacks, against the
test-session ( ˆA; ˆB; X0; Y0) with ˆA ̸= ˆB (particularly, A ̸= B), we present an eﬃcient forger F against
the underlying OAKE-HDR signature, which contradicts the security of the underlying OAKE-HDR
signature scheme (that is based on the GDH assumption), and thus establishing the theorem. F works
as follows, by running A as a subroutine.
1. The inputs of F are (B; X0), and F has oracle access to the OAKE-HDR signer ˆB of public-key
B.
2. We assume F successfully guessed the unexposed test-session ( ˆA; ˆB; X0; Y0) held at ˆA, where
ˆA ̸= ˆB and F sets the DH-component from ˆA for the test-session just to be X0.
3. F sets the inputs to all parties other than ˆB, and thus can perfectly emulate these parties. In
particular, F can deal with state-reveal queries, session-key queries by A on any session other
than the test-session and its matching session, and party corruption queries on any party other
than ˆA and ˆB.
6In comparison, the analysis of HMQV to rule out key-replication attack in [42] is quite complicated, and is still reduced
to the underlying hardness assumptions (to be precise, to the unforgeability of HMQV-HDR).
33
4. When A activates a session at ˆB, either as a responder or initiator, with peer identity ˆP of
public-key P and incoming message X, then F feeds ˆB the value ( ˆP ; P; X). In response, F gets
values (y; Y; P cy) from ˆB, and then F hands A the value Y as the outgoing message from ˆB.
Actually, the values (y; Y; P cy) can be oﬄine pre-computed by ˆB, and leaked to F (and A ) prior
to the session involving them.
5. When A issues a state-reveal query against an incomplete session ( ˆB; ˆP ; Y ) (not matching to the
test-session) held at ˆB, then F returns the values (Y; y; P cy) to A .
6. When A issues a session-key query to a session ( ˆB; ˆP ; Y; X) (not matching to the test-session)
held at ˆB, then F queries the session-signature from its signing oracle ˆB by presenting the signing
oracle with ( ˆP ; P; X; Y ), and returns the HDR-signature from ˆB to A .
7. When A halts with a valid test-signature, denoted (cid:27)0, F stops and outputs (cid:27)0.
Suppose there are n parties in total in the system, and each party is activated at most m times (where
n and m are polynomials in the security parameter), in actual analysis F guesses the test-session by
choosing uniformly at random a triple ( ˆPi; ˆPj; t) (hoping that ˆPi = ˆA and ˆPj = ˆB and the test-session
is the t-th session activated at ˆA with peer ˆB), where 1 ≤ i ̸= j ≤ n and 1 ≤ t ≤ m. Thus, with
−1, F successfully guesses the test-session. It is easy to check that, conditioned on F
probability (n2m)
successfully checks the test-session, the view of A under the run of F is identical to that in the real
run of A in accordance with the forgery game deﬁned in Figure 2 . Suppose A successfully outputs,
with non-negligible probability ", the valid test-signature via forging attack in its real run, with still
−1" A (and thus F) outputs the valid test-signature under the run of
non-negligible probability (n2m)
F.
We need then to check whether the valid test HDR-signature outputted by F is a successful OAKE-
HDR forgery. As the test-signature output by A is valid, according to Deﬁnition G.2, we only need to
show the vector { ˆA; A; X0; Y0} did not appear in any one of the responses from the signing oracle ˆB.
We distinguish three cases, according to the appearance of Y0:
Case-1. Y0 was never output in any one of the signatures issued by ˆB. In this case, the test HDR-
signature output by A (and thus F) is clearly a successful forgery against OAKE-HDR.
Case-2. Y0 was output in one of the signatures issued by ˆB in a session non-matching to the test-session.
Denote by ( ˆB; ˆP ; Y0; X) this non-matching session, we have that ˆP ̸= ˆA or X ̸= X0. That is,
( ˆP ; P; X) ̸= ( ˆA; A; X0). As ˆB uses random and independent DH-components in each session, with
overwhelming probability the value Y0 is only used in this non-matching session ( ˆB; ˆP ; Y0; X),
and thus does not appear (except for a negligible probability of accidental repetition) in any other
signatures issued by ˆB in other sessions diﬀerent from ( ˆB; ˆP ; Y0; X). Thus, { ˆA; A; X0; Y0} did not
appear in any of the HDR-signatures issued by ˆB, and thus the test HDR-signature output by F
is a successful forgery against OAKE-HDR.
Case-3. Y0 was generated by ˆB in the matching session ( ˆB; ˆA; Y0; X0). However, this matching session
was never queried by A via session-key query or session-state query (recall we assume the test-
session and its matching session are unexposed in the CK-framework), which in turn implies that
F never queries ˆB for the HDR-signature of this matching session. Also, the random value Y0
was used by ˆB only for this matching session (except for a negligible probability of accidental
repetition). This implies that, in Case-3, the values { ˆA; A; X0; Y0} also did not appear in any one
of the responses from the signing oracle ˆB, and thus the test HDR-signature output by F is a
(cid:3)
successful forgery against OAKE-HDR.
Notes on the security analysis of (s)OAKE in the CK-framework. For the above security
analysis of (s)OAKE in the CK-framework, we have the following observations and notes:
34
• The analysis is actually w.r.t.
the public-key free variants of (s)OAKE, with players’ public-
keys removed from the inputs of the functions of c; d; e. The reason is that: (1) public-keys are
unnecessary for ruling out the key-replication attack; (2) for ruling out the forging attack, the
security of the underlying (s)OAKE-HDR signatures also does not rely on them.
• The analysis shows that OAKE and sOAKE remain their security in the CK-framework, even if
the attacker A exposes the private values (y; Acy) of the matching session (but not the session-key
itself). This provides extra security guarantee of (s)OAKE that is beyond the CK-framework. The
reason is that, even if these pre-computed private values are used by ˆB in the matching session
( ˆB; ˆA; Y0; X0) and exposed to A , the forger F never queries the HDR-signature corresponding to
this matching session as the underlying attacker A is not allowed to make the session-key query
against the matching session (note that F queries the HDR signer for a session-signature only
when A makes the session-key query against this session), and thus ( ˆA; A; X0; Y0) still did not
appear in any one of the signatures issued by ˆB.
Using Corollary G.1 and Corollary G.2, we have the following corollaries about the security of
(s)OAKE in the CK-framework w.r.t. any test-session between the identical players ˆA = ˆB. The proofs
are straightforward adaptations of the proof of Theorem G.2, and details are omitted here.
Corollary G.6 Under the CDH assumption in the RO model, the OAKE and sOAKE protocols (ac-
tually, the variants with public-keys removed from the inputs of c; d; e), with oﬄine pre-computed and
exposable DH-components, DH-exponents, and the DH-secrets of one’s DH-component and its peer’s
public-key (say Acy and Bdx), are SK-secure in the CK-framework w.r.t. any test-session of identical
peer and identical DH-component (i.e., ˆA = ˆB and X = Y ).
Corollary G.7 Under the GDH assumption and additionally the KEA assumption in the RO model,
the OAKE and sOAKE protocols (actually, the variants with public-keys removed from the inputs of
c; d; e), with oﬄine pre-computed and exposable DH-components, DH-exponents, and the DH-secrets of
one’s DH-component and its peer’s public-key (say Acy and Bdx), are SK-secure in the CK-framework
w.r.t. any test-session of identical peer but diﬀerent DH-components (i.e., ˆA = ˆB but X ̸= Y ).
Extension and adaptation to SK-security analysis of rOAKE. The SK-security analysis
follows the same outline of that of OAKE. Here, we mainly highlight the major diﬀerences between
them, besides the diﬀerence that the value K ^A = K ^B is additionally multiplied by gab in rOAKE.
We consider the three cases regarding the test-session ( ˆA; ˆB; X0; Y0). For the case of ˆA ̸= ˆB, the SK-
security analysis of rOAKE is essentially identical to that of (s)OAKE, with the following modiﬁcation:
only the values (X; x) and (Y; y) can be exposed for an incomplete session. For the case of ˆA = ˆB
but X0 ̸= Y0, there is an additional diﬀerence between the SK-security analysis of rOAKE and that
of OAKE. Speciﬁcally, when ruling out the forging attack, the input of F consists of only the value
B, while the value X0 = gx0 to be sent as the DH-component from ˆA in the test-session is generated
by F itself and thus x0 is known to F. Then, the assumed ability of forging attack is reduced to the
rOAKE-HDR signature under merely the GDH assumption for this case of ˆA = ˆB but X0 ̸= Y0. Finally,
the SK-security analysis of rOAKE, for the case of ˆA = ˆB and X0 = Y0, is identical to that of OAKE.
In particular, for this special case, all the pre-computed values (x; X; Ba+dx and (y; Y; Ab+cy) can be
exposed to the attacker for non-matching incomplete sessions. We have the following corollary:
Corollary G.8 The rOAKE protocol (actually, the variant with public-keys removed from the inputs of
c; d; e) is SK-secure in the random oracle model, under the following assumptions and secrecy exposure:
• The GDH assumption, with oﬄine pre-computed and exposable DH-components and DH-exponents,
for the case ˆA ̸= ˆB and the case ˆA = ˆB but X0 ̸= Y0.
• The CDH assumption, with oﬄine pre-computed and exposable DH-components, DH-exponents,
and the DH-secrets of one’s DH-component and its peer’s public-key (say Ab+cy and Ba+dx), for
the case ˆA = ˆB and X0 = Y0.
35
Notes on some inherent security limitations. The reader should beware of some inherent
security limitations for any one-round and two-round implicitly-authenticated DHKE protocols, e.g.,
the PFS vulnerability for any two-round implicitly-authenticated DHKE and the KCI vulnerability for
any one-round DHKE (more details are referred to [42]). Even for the three-round versions of (s,r)OAKE
and HMQV with explicit mutual authentications, there are also some inherent limitations. For example,
the protocol responder may not be able to get deniability in a fair way, in case the malicious protocol
initiator just aborts after receiving the second-round message. Also, both the three-round (s,r)OAKE
and (H)MQV suﬀer from the cutting-last-message attack [46], etc. We remark that losing deniability
fairness to protocol responder and lacking correct delivery guarantee of the last message are inherent to
the protocol structure of (s,r)OAKE and (H)MQV and do not violate the deﬁnition of the SK-security
in the CK-framework, which though can be easily remedied but at the price of ruining the performance
advantages and/or adding additional system complexity.
H More on Security of (s,r)OAKE Beyond the CK-Framework
In this section, we make some further investigations on the security properties of (s,r)OAKE not captured
by the CK-framework, which further strengthens the security guarantee of the (s,r)OAKE protocols.
The ﬁrst observation is: the security analysis of (s,r)OAKE in the CK-framework also implies that
(s,r)OAKE is resistant to reﬂection attacks.
H.1 Security with Public Computations
The work of [44] considers a new attack scenario for key-exchange protocols with public computations,
where it is convenient to split an entity (performing a run of KE-protocol) into two parts: a trusted
authentication device, and an untrusted computing device. The authentication device enforces the
conﬁdentiality of the authentication data, while some computing operations required by the protocol are
publicly carried out by the (possibly untrusted) computing device. This allows to use an authentication
device with little computing power, and to make computing devices independent from users [44].
The work [44] gives some concrete applications that might be beneﬁted from public computations:
(1) Mobile phones include smart cards which store the user authentication data; the handsets themselves
are the computing devices. (2) PCs (corresponding to the computing device) equipped with a crypto
token (corresponding to the authentication device) have a lot more computing power than the token
itself, but may be plagued by spyware or virus. For more details, the reader is referred to [44].
(H)MQV with public computations. With the computation of ˆB as an example (the same holds
for ˆA), a natural split of authentication computation and public computation is as follows [44]: The
authentication device generates (y; Y ), forwards Y to the computation device; After getting ( ˆA; X) from
the computation device, the authentication device computes s = y + eb, where e = h(Y; ˆA), and then
forwards s to the computation device; After getting s from the authentication device, the computation
device computes K ^B = (XAd)s, and then the session-key, and then communicate with ˆA with the
session-key.
One key point is: as we assume the computation device may not be trustful, once the value s is
leaked to an attacker (who may compromise the computation device), then the attacker can deﬁnitely
impersonate ˆB to ˆA in any sessions. Note that, by only compromising the computation device, the
attacker does not learn the DH-exponent y and the private-key b. This shows that (H)MQV does not
well support deployment in the public computation model.
(s,r)OAKE with public computations. For applications in such scenarios, the natural split of
authentication computation and public computation for (s,r)OAKE is as follows, with the computation
of ˆB as an example (the similar hold for ˆA): (1) The authentication device generates (y; Y ) and possibly
Af b+cy (in case the authentication device has learnt the peer identity ˆA) where c = 1 for sOAKE or
c = h( ˆA; A; Y ) for OAKE and rOAKE, and then forwards Y and possibly Af b+cy to the computation
device; (2) After getting X from the computation device, the authentication device computes s =
db + ey, where d = h( ˆB; B; Y ) and e = h(X; Y ) for OAKE and rOAKE (resp., d = 1 and e =
36
h( ˆA; A; ˆB; B; X; Y ) for sOAKE), and then forwards s to the computation device; (3) After getting s
from the authentication device, the computation device computes K ^B = AcyX s, and then the session-
key, and then communicates with ˆA with the session-key. Note that y; Y; c; d; Af b+cy; db can be oﬄine
pre-computed by the authentication device, and the authentication device needs only online computing
ey and s. Also, the computation device essentially needs to compute only one exponentiation X s.
Below, we make some discussions about the security of (s,r)OAKE in the public computation model.7
Discussion on security of sOAKE with public computations. We note that, under the DLP
assumption, the knowledge of (Ay; s) of a session of sOAKE, learnt by the adversary by compromising
the computation device, is essentially useless for the attacker to violate other sessions other than the
matching session ( ˆB; ˆA; Y; X). The reason is that s = b + ey for sOAKE, where e = h( ˆA; A; ˆB; B; X; Y )
commits to the whole session-tag. Thus, the value s cannot be used by the attacker to violate a non-
matching session, unless it can compute y from Ay (and thus b from s) which however is infeasible by
the DLP assumption.
∗
Discussion on security of OAKE and rOAKE ((r)OAKE in short) with public compu-
tations. The knowledge (Af b+cy; s) of a session of OAKE, where s = db + ey, d = h( ˆB; B; Y ) and
e = h(X; Y ), is essentially useless under the DLP assumption for the attacker to violate other sessions
∗
other than sessions of the tag ( ˆA
) may be diﬀerent from ( ˆA; A). As the
DH-component X is generated by uncorrupted players randomly and independently, it implies that with
overwhelming probability the knowledge of (Acy; s) can only help the attacker to violate the security of
at most one unexposed non-matching session.
∗
; ˆB; B; X; Y ) where ( ˆA
; A
∗
; A
For example, consider that the attacker interacts concurrently with ˆA (in the name of ˆB) and ˆB (in
∗ ̸= ˆA but of the same public-key A); the attacker faithfully relays the DH-components
the name of ˆA
X and Y in the two sessions; in case the attacker learns both s and the private-key a of ˆA, then it can
impersonate ˆB to ˆA in the unique session in which ˆA sends X.
On the one hand, we suggest the is quite unreasonable to assume the attacker get the ability to
expose both s and the secret-key of ˆA. On the other hand, we remark this weakness is at the price of
supporting the advantageous post-ID computability oﬀered by OAKE. Though this weakness can be
trivially remedied (by putting ˆA into d and ˆB into c), but at the price of sacriﬁcing the advantage of
post-ID computability. Even with this (seemingly unreasonable) weakness in the public computation
model for OAKE in mind, the potential damage caused is still much mitigated in comparison with that
of (H)MQV in such scenarios.
H.2 Resistance to KCI, and Weak PFS
Recall that the security of DHKE protocols in the CK-framework is w.r.t. an unexposed test-session
( ˆA; ˆB; X0; Y0), where ˆA and ˆB are uncorrupted parties (which implies both the private-keys a; b are not