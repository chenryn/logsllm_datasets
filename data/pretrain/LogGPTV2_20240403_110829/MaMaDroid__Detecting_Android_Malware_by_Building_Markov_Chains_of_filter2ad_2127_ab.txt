### Entry Node and Path Enumeration

The entry node, such as the `Execute` method in the code snippet from Figure 2, is identified by the absence of any incoming edges from other calls within the application. The system then enumerates all paths that are reachable from each entry node. These paths collectively form the sequences of API calls, which are used to build a Markov chain behavioral model and to extract features (see Section II-D).

### Abstracting Calls to Families/Packages

To enhance the robustness and scalability of MAMADROID, we abstract API calls to a higher level, operating in one of two modes: package mode or family mode. This abstraction allows the system to be resilient to API changes and manage large datasets more efficiently. Our experiments, detailed in Section III, show that from a dataset of 44,000 apps, over 10 million unique API calls were extracted. If these calls were not abstracted, the resulting graphs and feature vectors would be extremely sparse and computationally infeasible, given that the number of features in MAMADROID is the square of the number of nodes.

**Package Mode:**
- In this mode, an API call is abstracted to its package name using the list of Android packages. As of API level 24 (September 2016), there are 243 Android packages and 95 Google API packages.
- Developer-defined and obfuscated packages (e.g., `com.stericson.roottools` and `com.fa.a.b.d`) are labeled as "self-defined" and "obfuscated," respectively. An API call's package is considered obfuscated if the class implementation, extension, or inheritance cannot be determined due to identifier mangling [47].

**Family Mode:**
- In this mode, API calls are abstracted into nine possible families: `android`, `google`, `java`, `javax`, `xml`, `apache`, `junit`, `json`, and `dom`. These families correspond to the `android.*`, `com.google.*`, `java.*`, `javax.*`, `org.xml.*`, `org.apache.*`, `junit.*`, `org.json`, and `org.w3c.dom.*` packages.
- Developer-defined and obfuscated packages are again abstracted to families labeled as "self-defined" and "obfuscated," respectively.

Overall, there are 340 possible packages (243 + 95 + 2) and 11 possible families (9 + 2). Figure 4 illustrates the sequence of API calls obtained from the call graph in Figure 3, with the corresponding package/family abstraction in square brackets.

### Markov-chain Based Modeling

MAMADROID builds feature vectors for classification based on the Markov chains representing the sequences of extracted API calls for an app. Before delving into the details, let's review the basic concepts of Markov chains.

**Markov Chains:**
- Markov chains are memoryless models where the probability of transitioning from one state to another depends only on the current state [39].
- They are represented as a set of nodes (states) and edges (transitions) labeled with transition probabilities. The sum of all probabilities from any node is exactly 1.
- The set of possible states is denoted as \( S \). If \( S_j \) and \( S_k \) are two connected states, \( P_{jk} \) denotes the probability of transition from \( S_j \) to \( S_k \). \( P_{jk} \) is calculated as the number of occurrences of state \( S_k \) after state \( S_j \), divided by the total number of transitions from \( S_j \) to any state \( i \) in the chain, i.e., \( P_{jk} = \frac{O_{jk}}{\sum_{i \in S} O_{ji}} \).

**Building the Model:**
- MAMADROID uses Markov chains to model app behavior by evaluating every transition between calls.
- For each app, MAMADROID takes the sequence of abstracted API calls (packages or families, depending on the selected mode) and builds a Markov chain where each package/family is a state and the transitions represent the probability of moving from one state to another.
- State \( S_0 \) is the entry point from which other calls are made in a sequence. Figure 5 shows the Markov chains built using packages and families from the sequences reported in Figure 4.

**Robustness:**
- Considering single transitions is more robust against attempts to evade detection by inserting useless API calls. MAMADROID considers all possible calls, so adding calls does not significantly change the transition probabilities.

### Feature Extraction

The probabilities of transitioning from one state to another in the Markov chain are used as the feature vector for each app. States not present in a chain are represented as 0 in the feature vector. The feature vector depends on the operational mode of MAMADROID:
- With families, there are 11 possible states, resulting in 121 possible transitions.
- With packages, there are 340 states, resulting in 115,600 possible transitions.

**Principal Component Analysis (PCA):**
- PCA is applied to perform feature selection by transforming the feature space into a new space with components that are linear combinations of the original features.
- The first components contain as much variance (information) as possible. PCA reduces the feature space to a smaller one, reducing computation and memory complexity and potentially improving classification accuracy by eliminating misleading features.

### Classification

The final step is to classify apps as either benign or malware. MAMADROID uses different classification algorithms: Random Forests [9], 1-Nearest Neighbor (1-NN) [22], 3-Nearest Neighbor (3-NN) [22], and Support Vector Machines (SVM) [29]. Each model is trained using the feature vector obtained from the training sample. Results are presented and discussed in Section IV, validated using 10-fold cross-validation.

**Random Forests Configuration:**
- When abstracting to families, we use 51 trees with a maximum depth of 8.
- When abstracting to packages, we use 101 trees with a maximum depth of 64.

### Datasets

In this section, we introduce the datasets used in the evaluation of MAMADROID, which include 43,940 APK files—8,447 benign and 35,493 malware samples. The datasets range from October 2010 to May 2016, aiming to verify MAMADROID's robustness to changes in Android malware and APIs.

**Benign Samples:**
- **Oldbenign:** 5,879 apps collected by PlayDrone [55] between April and November 2013.
- **Newbenign:** 2,568 unique apps downloaded from the top 100 apps in each of the 29 categories on the Google Play store as of March 7, 2016.

**Malware Samples:**
- **Drebin:** 5,560 apps used to test DREBIN [5], dating back to October 2010 – August 2012.
- Additional malware samples from VirusShare: 6,228 (2013), 15,417 (2014), 5,314 (2015), and 2,974 (2016).

**API Calls and Call Graphs:**
- API calls are extracted using Androguard, resulting in 42,923 samples (8,402 benign, 34,521 malware).
- Call graphs are extracted using Soot, but 2,027 samples (410 benign + 1,617 malware) could not be processed due to various issues.

**Characterization of the Datasets:**
- Newer apps, both benign and malicious, use more API calls than older apps, indicating increased complexity over time.
- The fraction of API calls to the `android` family decreases, while `google` calls increase in newer apps.
- Benign and malicious apps show similar evolutionary trends, with malware lagging a few years behind in terms of complexity and API usage.

This comprehensive approach ensures that MAMADROID can effectively detect and classify Android malware, even as the landscape of mobile applications continues to evolve.