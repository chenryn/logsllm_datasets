no incoming edges (for example, the Execute method in the
snippet from Fig. 2 is the entry node if there is no incoming
edge from any other call in the app). Then, it enumerates the
paths reachable from each entry node. The sets of all paths
identiﬁed during this phase constitutes the sequences of API
calls which will be used to build a Markov chain behavioral
model and to extract features (see Section II-D).
Abstracting Calls to Families/Packages. Rather than analyz-
ing raw API calls, we build MAMADROID to work at a higher
level, and operate in one of two modes by abstracting each
call to either its package or family. This allows the system
to be resilient to API changes and achieve scalability. In fact,
our experiments, presented in Section III, show that, from a
dataset of 44K apps, we extract more than 10 million unique
API calls, which would result in a very large number of nodes,
with the corresponding graphs (and feature vectors) being quite
sparse. Since as we will see the number of features used by
MAMADROID is the square of the number of nodes, having
more than 10 million nodes would result in an impractical
computational cost.
When operating in package mode, we abstract an API
call to its package name using the list of Android pack-
ages3, which as of API level 24 (the current version as of
September 2016) includes 243 packages, as well as 95 from
the Google API.4 Moreover, we abstract developer-deﬁned
packages (e.g., com.stericson.roottools) as well as obfuscated
ones (e.g. com.fa.a.b.d), respectively, as self-defined and
obfuscated. Note that we label an API call’s package
as obfuscated if we cannot tell what its class implements,
extends, or inherits, due to identiﬁer mangling [47]. When
operating in family mode, we abstract to nine possible families,
i.e., android, google, java, javax, xml, apache, junit,
json, dom, which correspond to the android.*, com.google.*,
java.*, javax.*, org.xml.*, org.apache.*, junit.*, org.json, and
org.w3c.dom.* packages. Again, API calls from developer-
deﬁned and obfuscated packages are abstracted to families
labeled as self-defined and obfuscated, respectively. Over-
all, there are 340 (243+95+2) possible packages and 11 (9+2)
families. In Fig. 4, we show the sequence of API calls obtained
from the call graph in Fig. 3. We also report, in square brackets,
the family and the package to which the call is abstracted.
1The standard Android archive ﬁle format containing all ﬁles, including the
Java bytecode, making up the app.
2https://www.hackread.com/ghost-push-android-malware/
3https://developer.android.com/reference/packages.html
4https://developers.google.com/android/reference/packages
3
com.fa.c.RootCommandExecutor:
com.stericson.RootTools.RootTools:
Execute()
getShell()
[self-defined, self-defined]
[self-defined, self-defined]
com.stericson.RootShell.
execution.Shell: add()
[self-defined, self-defined]
com.fa.c.RootCommandExecutor:
Execute()
android.util.Log:
d()
[self-defined, self-defined]
[android.util, android]
com.fa.c.RootCommandExecutor:
Execute()
[self-defined, self-defined]
java.lang.Throwable:
getMessage()
[java.lang, java]
Fig. 4: Sequence of API calls extracted from the call graphs in Fig. 3, with the corresponding package/family abstraction in square brackets.
self-defined
0.5
self-defined
0.5
0.25
0.25
0.25
0.25
java.lang
android.util
java
android
(a)
(b)
Fig. 5: Markov chains originating from the call sequence example in
Section II-C when using packages (a) or families (b).
D. Markov-chain Based Modeling
Next, MAMADROID builds feature vectors, used for classi-
ﬁcation, based on the Markov chains representing the sequences
of extracted API calls for an app. Before discussing this in
detail, we review the basic concepts of Markov chains.
Markov chains are memoryless models where the probability
of transitioning from a state to another only depends on the
current state [39]. Markov chains are often represented as
a set of nodes, each corresponding to a different state, and
a set of edges connecting one node to another labeled with
the probability of that transition. The sum of all probabilities
associated to all edges from any node (including, if present,
an edge going back to the node itself) is exactly 1.The set
of possible states of the Markov chain is denoted as S. If Sj
and Sk are two connected states, Pjk denotes the probability
of transition from Sj to Sk. Pjk is given by the number of
occurrences (Ojk) of state Sk after state Sj, divided by Oji
for all states i in the chain, i.e., Pjk = Ojk(cid:80)
.
i∈S Oji
Building the model. MAMADROID uses Markov chains to
model app behavior, by evaluating every transition between calls.
More speciﬁcally, for each app, MAMADROID takes as input
the sequence of abstracted API calls of that app – i.e., packages
or families, depending on the selected mode of operation – and
builds a Markov chain where each package/family is a state
and the transitions represent the probability of moving from
one state to another. For each Markov chain, state S0 is the
entry point from which other calls are made in a sequence.
As an example, Fig. 5 illustrates the two Markov chains built
using packages and families, respectively, from the sequences
reported in Fig. 4.
We argue that considering single transitions is more robust
against attempts to evade detection by inserting useless API
4
calls in order to deceive signature-based systems (see Sec-
tion VI). In fact, MAMADROID considers all possible calls –
i.e., all the branches originating from a node – in the Markov
chain, so adding calls would not signiﬁcantly change the
probabilities of transitions between nodes (speciﬁcally, families
or packages, depending on the operational mode) for each app.
Feature Extraction. Next, we use the probabilities of transi-
tioning from one state (abstracted call) to another in the Markov
chain as the feature vector of each app. States that are not
present in a chain are represented as 0 in the feature vector. Also
note that the vector derived from the Markov chain depends on
the operational mode of MAMADROID. With families, there
are 11 possible states, thus 121 possible transitions in each
chain, while, when abstracting to packages, there are 340 states
and 115,600 possible transitions.
We also apply Principal Component Analysis (PCA) [32],
which performs feature selection by transforming the feature
space into a new space made of components that are a linear
combination of the original features. The ﬁrst components
contain as much variance (i.e., amount of information) as
possible. The variance is given as percentage of the total amount
of information of the original feature space. We apply PCA to
the feature set in order to select the principal components, as
PCA transforms the feature space into a smaller one where the
variance is represented with as few components as possible,
thus considerably reducing computation/memory complexity.
Furthermore, the use of PCA could also improve the accuracy
of the classiﬁcation, by taking misleading features out of the
feature space, i.e., those that make the classiﬁer perform worse.
E. Classiﬁcation
The last step is to perform classiﬁcation, i.e., labeling apps
as either benign or malware. To this end, we test MAMADROID
using different classiﬁcation algorithms: Random Forests [9], 1-
Nearest Neighbor (1-NN) [22], 3-Nearest Neighbor (3-NN) [22],
and Support Vector Machines (SVM) [29]. Each model is
trained using the feature vector obtained from the apps in a
training sample. Results are presented and discussed in Section
IV, and have been validated by using 10-fold cross validation.
Also note that, due to the different number of features used
in family/package modes, we use two distinct conﬁgurations for
the Random Forests algorithm. Speciﬁcally, when abstracting
to families, we use 51 trees with maximum depth 8, while,
with packages, we use 101 trees of maximum depth 64. To
tune Random Forests we followed the methodology applied
in [7].
Category Name
Date Range
#Samples
Benign
Malware
oldbenign Apr 2013 – Nov 2013
newbenign Mar 2016 – Mar 2016
Total Benign:
– Aug 2012
– Jun 2013
– Mar 2014
– Jun 2015
– May 2016
Total Malware:
Oct 2010
Jan 2013
Jun 2013
Jan 2015
Jan 2016
drebin
2013
2014
2015
2016
5,879
2,568
8,447
5,560
6,228
15,417
5,314
2,974
35,493
#Samples
(API Calls)
5,837
2,565
8,402
5,546
6,146
14,866
5,161
2,802
34,521
#Samples
(Call Graph)
5,572
2,465
8,037
5,538
6,123
14,827
4,725
2,657
33,870
TABLE I: Overview of the datasets used in our experiments.
III. DATASETS
In this section, we introduce the datasets used in the
evaluation of MAMADROID (presented later in Section IV),
which include 43,940 apk ﬁles – 8,447 benign and 35,493
malware samples. We include a mix of older and newer apps,
ranging from October 2010 to May 2016, as we aim to verify
that MAMADROID is robust to changes in Android malware
samples as well as APIs. To the best of our knowledge, we are
leveraging the largest dataset of malware samples ever used in
a research paper on Android malware detection.
Benign Samples. Our benign datasets consist of two sets of
samples: (1) one, which we denote as oldbenign, includes
5,879 apps collected by PlayDrone [55] between April and
November 2013, and published on the Internet Archive5 on
August 7, 2014; and (2) another, newbenign, obtained by
downloading the top 100 apps in each of the 29 categories on the
Google Play store6 as of March 7, 2016, using the googleplay-
api tool.7 Due to errors encountered while downloading some
apps, we have actually obtained 2,843 out of 2,900 apps. Note
that 275 of these belong to more than one category, therefore,
the newbenign dataset ultimately includes 2,568 unique apps.
Android Malware Samples. The set of malware samples
includes apps that were used to test DREBIN [5], dating back
to October 2010 – August 2012 (5,560), which we denote as
drebin, as well as more recent ones that have been uploaded
on the VirusShare8 site over the years. Speciﬁcally, we gather
from VirusShare, respectively, 6,228, 15,417, 5,314, and 2,974
samples from 2013, 2014, 2015, and 2016. We consider each
of these datasets separately for our analysis.
API Calls and Call Graphs. For each app in our datasets,
we extract the list of API calls, using Androguard9, since, as
explained in Section IV-E, these constitute the features used by
DROIDAPIMINER [2], against which we compare our system.
Due to Androguard failing to decompress some of the apks,
bad CRC-32 redundancy checks, and errors during unpacking,
we are not able to extract the API calls for all the samples,
but only for 42,923 (8,402 benign, 34,521 malware) out of the
43,940 apps (8,447 benign, 35,493 malware) in our datasets.
Also, to extract the call graph of each apk, we use Soot. Note
that for some of the larger apks, Soot requires a non-negligible
amount of memory to extract the call graph, so we allocate
5https://archive.org/details/playdrone-apk-e8
6https://play.google.com/store
7https://github.com/egirault/googleplay-api
8https://virusshare.com/
9https://github.com/androguard/androguard
Fig. 6: CDF of the number of API calls in different apps in each
dataset.
16GB of RAM to the Java VM heap space. We ﬁnd that for
2,027 (410 benign + 1,617 malware) samples, Soot is not able
to complete the extraction due to it failing to apply the jb
phase as well as reporting an error in opening some zip ﬁles
(i.e., the apk). The jb phase is used by Soot to transform Java
bytecode into jimple intermediate representation (the primary
IR of Soot) for optimization purposes. Therefore, we exclude
these apps in our evaluation and discuss this limitation further
in Section V-C. In Table I, we provide a summary of our seven
datasets, reporting the total number of samples per dataset, as
well as those for which we are able to extract the API calls
(second-to-last column) and the call graphs (last column).
Characterization of the Datasets. Aiming to shed light on
the evolution of API calls in Android apps, we also performed
some measurements over our datasets. In Fig. 6, we plot the
Cumulative Distribution Function (CDF) of the number of
unique API calls in the apps in different datasets, highlighting
that newer apps, both benign and malicious, are using more API
calls overall than older apps. This indicates that as time goes
by, Android apps become more complex. When looking at the
fraction of API calls belonging to speciﬁc families, we discover
some interesting aspects of Android apps developed in different
years. In particular, we notice that API calls to the android
family become less prominent as time passes (Fig. 7(a)), both
in benign and malicious datasets, while google calls become
more common in newer apps (Fig. 7(b)).
In general, we conclude that benign and malicious apps
show the same evolutionary trends over the years. Malware,
however, appears to reach the same characteristics (in terms
of level of complexity and fraction of API calls from certain
families) as legitimate apps with a few years of delay.
5
05000100001500020000250003000035000#API Calls0.00.20.40.60.81.0CDF2013201420152016drebinnewbenignoldbenign(a) android