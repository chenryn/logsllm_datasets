title:Securing a Remote Terminal Application with a Mobile Trusted Device
author:Alina Oprea and
Dirk Balfanz and
Glenn Durfee and
Diana K. Smetters
Securing a Remote Terminal Application with a Mobile Trusted Device
Alina Oprea1, Dirk Balfanz2, Glenn Durfee2, D. K. Smetters2
1 Carnegie Mellon University
2 Palo Alto Research Center
Pittsburgh, PA
PI:EMAIL
3333 Coyote Hill Road
Palo Alto, CA 94304
{balfanz, gdurfee,
smetters}@parc.com
Abstract
Many real-world applications use credentials such as
passwords as means of user authentication. When accessed
from untrusted public terminals, such applications are vul-
nerable to credential snifﬁng attacks, as shown by recent
highly publicized compromises [20].
In this paper, we describe a secure remote terminal ap-
plication that allows users possessing a trusted device to
delegate their credentials for performing a task to a pub-
lic terminal without being in danger of disclosing any long-
term secrets. Instead, the user gives the terminal the ca-
pability of performing a task temporarily (as long as the
user is in its proximity). Our model is intuitive in the sense
that the user exposes to the untrusted terminal only what he
sees on the display, and nothing else. We present the de-
sign and implementation of such a system. The overhead –
in terms of additional network trafﬁc – created by introduc-
ing a trusted third party is a moderate 12%.
1. Introduction
From 2000 to 2002, Queens resident JuJu Jiang col-
lected over 450 online banking passwords from unsuspect-
ing Kinko’s customers [20]. Jiang accomplished this by in-
stalling keyboard-snifﬁng software on public terminals in
thirteen Kinko’s stores in Manhattan, thus learning the Go-
ToMyPC [15] account passwords of hundreds of people that
had used those terminals. Armed with those GoToMyPC
passwords, Jiang could connect to, and gain full control of
the home PCs of his victims.
This story teaches us two lessons:
(1) Computer
users want to access their home computing environment
from public terminals. (2) Those public terminals can-
not be trusted with passwords or other credentials that
give full access to the users’ home computing environ-
ment.
How can we reconcile these two issues, and provide the
user any secure access at all to their home computing en-
vironment from an untrusted terminal? Clearly, if the ter-
minal were completely untrusted, then users would refrain
from using it. On the other hand, if they could completely
trust the public terminal, then no precautions against key-
board sniffers and the like would be necessary. In practice,
the truth is usually somewhere in the middle – such termi-
nals may often be trusted to perform the functions they ad-
vertise, but not be trustable with long-term secrets. We call
a terminal that is not fully trusted “untrusted”, even though
we trust it to a certain extent (e.g., not to deny service).
If users want to access their sensitive home computing
environment from an untrusted terminal, it would be nice if
they could control what information that terminal gains ac-
cess to – in particular, the terminal should only obtain in-
formation about those parts of the home computing envi-
ronment that the user chooses to access via the terminal, and
gain neither access to other parts, nor to the user’s long-term
secrets (e.g., passwords). This would allow the user to de-
cide what information to expose to a given terminal on a
case-by-case basis. For example, I may have no problem
having a friend’s PC access individual email messages in
my Inbox (as long as I have control over which email mes-
sages get accessed), while I may not let a public terminal at
a hackers’ conference access my Inbox at all.
This sounds like we are asking users to make sophisti-
cated security decisions – i.e., “decide what to expose to an
untrusted host”, something end-users are usually considered
ill-equipped to do. We believe instead that an effective fo-
cus on usability in system design can make such things not
only possible, but easy and intuitive. In designing this sys-
tem, our primary goal was to make it very easy for users to
specify which parts of their home computing environment
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:36:42 UTC from IEEE Xplore.  Restrictions apply. 
PDA
optical
mouse
connection to 
untrusted
terminal
PDA buttons 
serve as mouse 
buttons
Figure 1. Our augmented PDA
are exposed to the untrusted terminal, and which are not.
The simple analogy we have used here is “seeing” – the un-
trusted terminal gains access to any information, and only
that information, that it “sees” – that the user chooses to
display via the monitor. We use the same desktop metaphor
of traditional user interfaces, and simply extend the famil-
iar click-to-open semantics of such interfaces. In our sys-
tem, a mouse click (or double-click) that normally means
“open this item and display it” takes on an additional, yet
intuitive, meaning: “expose this component of my comput-
ing environment to the untrusted terminal I’m currently at”.
If a simple mouse click can expose a resource in our
home computing environment to an untrusted terminal, we
better make sure that only we, not the untrusted terminal,
can issue such mouse clicks (or other input events). In other
words, we provide the untrusted terminal read-only access
to our home computing environment, and provide the in-
put necessary to interact with that environment via a sepa-
rate, trusted input path protected from the untrusted termi-
nal.
At the same time, we would like the interaction with the
untrusted terminal to be as natural as possible. Our solu-
tion to this problem is to use a modiﬁed PDA that the user
plugs into the untrusted terminal, and which can be used
as a mouse (see Figure 1). The PDA will authenticate all
mouse (and other input) events to the home computing en-
vironment. It will withhold the credentials necessary to do
this authentication from the untrusted terminal, thus mak-
ing it impossible for the untrusted terminal to issue its own
input events. At the same time, the PDA will temporarily is-
sue (and update) credentials to the untrusted terminal allow-
ing it to display representations of those parts of the home
computing environment that the user decided to open up to
it. Once we unplug the PDA from the untrusted terminal, the
last credential issued expires after a timeout, leaving the ter-
minal unable to even display the user’s home computing en-
vironment.
We emphasize that the PDA in question is a general-
purpose PDA, which can be used as such by its users. It
just happens to also be a mouse that provides a trusted input
path to the user’s home computing environment when con-
nected to an untrusted terminal. Figure 1 shows our initial
prototype of such a PDA. A ﬁnished product would have the
same form factor as a PDA, perhaps with an LED and op-
tical sensor such as those found in optical mice embedded
in the back of it. Alternatively, the trusted device could be
a cell phone or two-way pager (e.g., a RIM BlackberryTM),
or a special-purpose device with a form factor similar to
“travel mice” currently sold. This has the advantage that
the device is much smaller (e.g., could be put on a key
chain), but has the disadvantage that it presents yet another
special-purpose device to be carried by its user that can-
not be used for other applications. For the rest of this paper,
we will assume that the trusted mobile device is a general-
purpose PDA that has optical mouse capabilities built in, or
at least provides “touchpad”-like functionality through its
touch screen.
In this paper, we describe a particular implementation of
this idea. The graphical representation of the home comput-
ing environment is, in fact, a copy of the home PC’s GUI
desktop, using any one of the standard “remote desktop”
protocols in common use today (for our implementation we
chose VNC [18]). We give the user full access to a home PC
of their choice. They can open applications or documents,
using their PDA as a mouse (and also as a keyboard). The
desktop environment is displayed on the untrusted terminal,
but only as long as the PDA is present. The terminal loses
all credentials to access the home environment after a speci-
ﬁed timeout has elapsed since the user walked away with the
PDA. The end result is that the user interacts with the un-
trusted terminal (almost) the same way he would with his
home PC, or with current remote desktop software. The ad-
vantage is that the user can be certain that only those items
that he “exposes” to the untrusted terminal are accessible to
the untrusted terminal.
We describe the goals of our system in Section 3, after
looking at some related work in Section 2. In Section 4 we
explain the design, implementation and performance evalu-
ation of our particular VNC-based application. We conclude
in Section 5.
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:36:42 UTC from IEEE Xplore.  Restrictions apply. 
2. Related Work
Traditional approaches to securing network access – e.g.,
the use of ssh [5] – leave the user still vulnerable to
password-snifﬁng attacks. Even the use of one-time pass-
words or tokens, while potentially preventing the untrusted
terminal from accessing the user’s resources in the future,
does not protect the user from malicious manipulation of
his home environment by the untrusted terminal while he
is present and authenticated. These approaches provide the
untrusted terminal total access to the home computing envi-
ronment, while protecting that access from malicious eaves-
droppers on the network. As we want to protect the home
computing environment from a potentially malicious access
terminal, this is insufﬁcient. Instead, we must be able to del-
egate to that terminal very limited capabilities to access the
home environment.
Delegation of credentials has been the focus of much
previous work, ranging from the theoretical to the more ap-
plied. For example, in the ABLP access control logic [1],
delegation plays a central role in form of “speaks-for” state-
ments. A principal Alice can delegate her privileges to a
principal Bob by announcing that Bob speaks for Alice. Re-
ﬁnements of that approach (e.g., [2] or [11]) allow ﬁner-
grained delegation, e.g., Alice could announce that Bob
speaks for her only for the next 5 minutes. SPKI [12] has a
form of certiﬁcates that allows principals to delegate a sub-
set of their rights to other principals.
Compared to these efforts, we take a rather pragmatic
approach: we simply send short-lived keys to the delega-
tee, which allow it to decrypt messages meant for the del-
egator for a short period of time. The advantage of our ap-
proach is that we can easily augment existing software (in
our case, VNC) without any of the heavy lifting required
by some of the cited approaches (e.g., [2] requires clients
to come up with proofs of authorization; other systems re-
quire some sort of shared infrastructure in which every host
must participate). In fact, our system doesn’t even require
the untrusted terminal to possess a private key.
Remotely-Keyed Encryption [6, 7] is closer to our
model: here an untrusted host is able to encrypt and de-
crypt data only with the help of a trusted smartcard (anal-
ogous to the PDA in our system). The remotely-keyed
encryption protocol is designed to guarantee that the smart-
card must be present and involved to encrypt or de-
crypt any data, while not actually sending all of that data
over the low-bandwidth link to the card. One disadvan-
tage of remotely-keyed encryption is that the host can de-
crypt only entire messages – handling streaming data, for
example, poses a problem. One could get around this by di-
viding the data stream into smaller packets which are
encrypted and decrypted separately, but then the smart-
card has to interact with the host for every packet received.
In our system, the frequency with which the PDA and un-
trusted terminal interact is determined by the expiration
time of delegated keys, not by the frequency of pack-
ets sent.
Zero-Interaction Authentication [10, 9] uses an authenti-
cation token to store credentials needed to use a host com-
puter. If you take the token away from the host computer,
the host computer will forget all keys needed to read and
write ﬁles, and will essentially become unusable. The sim-
ilarity to our work is that the token issues keys to the host
computer, which it then uses to get useful work done. The
difference is in the trust model. In Zero-Interaction Authen-
tication, the host computer is trusted. It voluntarily forgets
all keys once it senses that the token is no longer in prox-
imity. In our system, the host computer is untrusted. It con-
stantly needs updated keying material from the PDA to ac-
cess the user’s home PC desktop.