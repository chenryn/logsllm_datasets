This approach is the one implemented in strongSwan. It has
the advantage of requiring only a small amount of storage space
(the tables containing the constants used in SampleBernExp). A
drawback, however, is that it runs intrinsically in variable time:
the number of iterations is a priori unknown, and even though
one could choose to bound the number of iterations in SamplePos-
Gaussian by some sufficiently large value, carrying out the entire
loop every time would be very costly. This timing variability is
a source of side-channel leakage. Due to the contrived structure
of the algorithm (which starts over multiple times, etc.), it seems
difficult to extract a lot of information from that leakage on a noisy
trace, as provided by power or EM analysis techniques, especially
as a given Gaussian sample is used in only one signature gener-
ation (so that DPA/CPA style statistical tools are not applicable).
Nevertheless, one cannot rule out that this leakage can effectively
lead to a catastrophic security failure.
The branch tracing technique described in §3.4, in particular,
provides an ideal way of taking advantage of that leakage. Indeed,
a branch trace of the execution of SamplePosGaussian directly
reveals the output of that function: it suffices to count the number
of iterations of the for loop (reverting to 0 when the algorithm
restarts). And we have already seen that a branch trace of Sample-
BernExp reveals the input of that function. Therefore, a branch
trace of SampleGaussian reveals the value of x (as the output of
SamplePosGaussian) as well as the value y(y +2kx ), which is equal
2 (as the input of SampleBernExp). Since k is actually
to z
2, as well
a fixed constant for a given parameter set, one obtains z
as the sign of z from the final conditional branch, and hence the
complete output z! We have carried out this attack in the same
setting as in §3.4, and verified that it recovers the samples correctly:
see the GitHub repository for the corresponding parser.
This means that a branch trace of a BLISS signature generation in
strongSwan leaks the entire value of the random masks y1 and y2.
But the signature itself contains the values c and z1 = y1 + (−1)b s1c.
Hence, whenever c is invertible (which happens with probability
(1− 1/q)n > 95% for each signature), we can recover the secret key
element s1 as c−1 · (z1 − y1). And the secret key element s2 is easily
deduced from s1 using the public key.
In other words, a branch trace of a single BLISS signature gener-
ation in strongSwan will, with > 95% probability, reveal the entire
secret key! And unlike the attack on the rejection sampling, this
works for 100% of secret keys.
The attack is subject to the caveats mentioned at the end of §3.4:
it assumes a relatively powerful attacker and is not very stealthy.
Nevertheless, it shows that this variable-time approach for Gaussian
sampling has significant security implications.
2 − k
2
x
Figure 9: Description of the BLISS Gaussian sampling algorithm.
1: function SamplePosGaussian()
sample b uniformly in {0, 1}
2:
if b = 0 then return 0
3:
for i = 1 to ∞ do
4:
5:
6:
7:
8:
9: end function
end for
draw random bits b1 . . . bj for j = 2i − 1
if b1 . . . bj−1 (cid:44) 0 . . . 0 then restart
if bj = 0 then return i
5 ATTACKS ON THE MULTIPLICATION
We now turn to attacks targeting the multiplication between the
signature element c and the secret key (s1, s2). Those attacks will
apply to all secret keys (in contrast with the one from §3.2, which
only recovered a subset of all keys).
If no protection is used, traditional polynomial multiplication can
be attacked using classical DPA-like techniques. If an NTT-based
multiplication is used, we can target n one-to-one products between
a known varying value and a secret. However, since BLISS uses
sparse polynomials with small coefficients, other algorithms are
sometimes used to compute the product. Specifically, the 8-bit AVR
implementation of Pöppelmann et al. [46] that we target2 relies
on repeated shifted additions instead. The polynomial c (which we
recall has exactly κ coefficients equal to 1 and all others equal to 0) is
represented as a vector of κ indices corresponding to the ones, and
multiplication by c is an iterated sum over those indices. We show
that this unusual implementation of polynomial multiplication not
only remains vulnerable to side-channel analysis, but can in fact
be broken with a single trace. Thus, our proposed attack can be
applied even when using blinding countermeasures, such as the
ones proposed by Saarinen [49]. Indeed, the blinding randomizes
polynomials before multiplication using shifts and multiplications
by constants, which corresponds to a search space of affordable
dimension in the case of BLISS.
In the following, we first describe the sparse multiplication
of [46], and then propose an attack on this implementation, both
in the unprotected case and when using Saarinen’s blinding coun-
termesure.
5.1 Implementation details
First, let us recall that we target the multiplications of the poly-
nomial c with the two components s1, s2 of the secret key. These
polynomials have the following properties:
• s1 is of degree n with coefficients in {−2,−1, 0, 1, 2},
• s2 is of degree n with coefficients in {−3,−1, 1, 3, 5},
• c is of degree n and with κ coefficients 1 and all others equal
to 0.
Figure 10 describes the core of the targeted sparse multiplication.
Before performing this multiplication, the vector c is randomly
2This implementation does not claim any particular SCA resistance.
sample b ← SampleBernExp(cid:16)
sample x ← SamplePosGaussian()
sample y uniformly in {0, . . . , k − 1}
z ← kx + y
1: function SampleGaussian(k)
2:
3:
4:
5:
if b = 0 then restart
6:
if z = 0 then with probability 1/2 restart
7:
sample b uniformly in {0, 1}
8:
if b = 1 then z ← −z
9:
10:
return z
11: end function
y (y + 2kx )
(cid:17)
generated in such a way that the indices in the vector are not
ordered. Thus, even if one knows the non-zero coefficients of c (as
part of the signature), we cannot infer the order in which they are
accessed in the j-loop (i.e. we cannot deduce i from q and j).
5.2 Attacking the unprotected multiplication
The attack proceeds in two steps. First, the attacker recovers the
order in which the non-zero indices of c are stored in memory.
Then, based on this information, he recovers the coefficients of the
second multiplicand.
Recovering the order of indices in c. For the first step, one can use
two possible approaches:
(1) using SPA information from the if condition on i,
(2) performing a CPA on the computation of q-c[j].
The first technique involves exploiting the timing difference
induced by the if condition using pattern matching techniques.
There is indeed an exploitable timing difference between the pat-
terns corresponding to the conditional code being executed or not.
Finding the positions where the additional code is executed in a
j-loop allows to recover index positions. More precisely, the values
of j for which the if condition evaluates to true correspond to the
cells of array c that contain a value larger than q. This knowledge
directly translates to knowing the order of non-zero indexes in c.
for ( q = 0 ; q < N ; q ++ ) { /* loop on res coefficients */
res [q] = 0;
for ( j = 0 ; j < Kappa ; j ++ ) { /* loop on c coefficients */
int8_t val = 1;
int16_t i = ( q - c[j] ); /* the corresponding s coefficient
index */
if ( i < 0 ) {
i += N;
val = - val ;
}
val *= s[i ];
res [q] += val ; /* update res coefficient at position q */
}
}
Figure 10: Code snippet of mulSparse function from BLISS
implementation [46].
9
In the second approach, one exploits data-dependent leakage.
For a targeted value c[j], the samples corresponding to the com-
putations of i for the n different values of q are recorded. Then,
one can perform a CPA attack to distinguish the correct value of
c[j] from others since q is known.
Attacking the polynomial multiplication. Now that the attacker
knows the order in which the coefficients of c are processed, he
can compute the values of i for each inner-loop iteration. This
allows him to target the accumulation operation res[q] += val
since he knows which secret coefficient of s is contained in val.
Our hypothesis is that he obtains the Hamming weight of val and
res[q] (both before and after addition) as it is generally the case on
micro-controllers. This hypothesis is actually pessimistic, since one
may obtain additional leakage (e.g. Hamming distances) or more
informative ones (e.g. polynomials in the register bits).
Let us first look at what an attacker can learn from the leakage of
val. Values in this variable are directly linked to coefficients in s up
to a (known) sign inversion. Nevertheless, these coefficients cannot
be directly recovered from the leakages: obtaining the Hamming
weight of a variable taking values in {−2,−1, 0, 1, 2} will potentially
reveal its value if it is zero but only its sign if it is non-zero3. The
parameters of the scheme make the remaining exhaustive search
intractable.
Let us now consider the second leakage source, namely the Ham-
ming weight of res[q]. In that case the problem comes from the
fact that a classical divide-and-conquer strategy cannot be applied.
Exploiting a leakage on res[q] would require the knowledge of its
previous value to derive information on val. This previous value
actually is a sum of (unknown) coefficients of s, which prevents
such a divide-and-conquer strategy.
To overcome this difficulty, a first idea would be to use a Viterbi-
like algorithm to avoid testing all possible combinations. Indeed,
accumulating in res[q] can be seen as a Markov process: the state
being the current sum and the transitions being the possible values
for s[i]. The evaluation of the probability of a sequence could be
obtained using templates or derived from a correlation coefficient
between expected Hamming weights of the different states and the
trace chunks. We experimented this approach on simulated traces
and recovered the key. However, we did not manage to obtain good
results with a high level of noise.
confidence constraints of the form(cid:80)η
In highly noisy settings, the Hamming weight of a 16-bit variable
having a small absolute value (as is the case for res[q]) reveals its
sign, since the binary representation contains many leading zeros
if the value is non-negative and many leading ones in the opposite
case. Based on this simple observation, the attacker will obtain high-
j=1 s[ij] <
0. Recovering s[i]’s from those constraints is an Integer Linear
Programming (ILP) problem with no objective function (parameters
are large enough to guarantee the uniqueness of the solution).
j=1 s[ij] ≥ 0 or(cid:80)η
We performed some simulations based on this second idea. Sim-
ulating the Hamming weight of 16-bit variables, correct constraint
systems were obtained up to noise standard deviation 1.5 (as ex-
pected for a Gaussian noise). Using such error-less systems and the
Gurobi ILP solver [29] the secret vectors were recovered within
3For s2, coefficients are taken in {−3, −1, 1, 3, 5} thus exploitation is a bit easier but
still it is not enough).
Table 4: Results of simulated attacks on the multiplication
for several levels of noise.
noise
std. dev.
avg. number of
kept equations
1.0
2.0
3.0
3.5
11776
11608
8545
5200
avg. time
(1 sol.)
8.0 ms
8.9 ms
9.5 ms
87.9 ms
avg. time
(≤10 sol.)
62.7 ms
61.1 ms
44.2 ms
81.2 ms
nb.
sol.
1
1
1
2
a few dozen of milliseconds. To handle higher levels of noise, the
attacker should discard constraints in which he has less confidence
(i.e. those corresponding to leakage close to the cut-off).
Simulations have been performed up to a noise of standard devi-
ation 3.5 on a desktop computer. Results are given in Table 4. They
were obtained on a set of 50 systems for each noise level and they
show that attacks are easily performed in this range. We see that
the solver should be asked to look for more than a single solution in
some settings. Timings are provided both for situations when the
solver is asked for a single solution, and for 10 solutions. Systems
have also been produced for noise standard deviation 4.0 where
only 10% had a single solutions. Others where not solved after tens
of minutes. Ongoing experiments on a real device are expected
to provide insights about relevant parameters for the discarding
strategy and to confirm the applicability of this attack to real-world
settings.
Note that we presented results when attacking using a single
trace. Without SCA protection, however, different executions can
be combined to construct the system. Thus, the attack may work
in higher noise levels using more traces.
5.3 Attacking a blinded multiplication
Even in the case when Saarinen’s blinding countermeasure is used,
c remains sparse. Indeed, the blinding consists in shuffling and
multiplying by a constant, so that the same sparseMult function
can still be used (with val being initialized to the blinding constant).
However, the indices of the non-zero positions of the blinded c are
unknown because the signature contains the actual c and not the
blinded one. Thus, these indices have to be recovered in addition
to their positions in the array c. Note that the signature provides
us with the non-zero positions of the blinded c up to a shift. This
information may help with the index recovery.
Recovering the c indices. Similarly to the index order recovery
step above, we exploit the timing leakage due to the if condition.
More precisely, the if branch will be taken in a q-loop as many
times as the number of indices in c that are smaller than q. Hence,
the duration of the q-loop will decrease (non-strictly) as q grows.
The steps at which an actual decrease occur correspond to the
values of q that match an index in c, which trivially reveals the
non-zero positions of the vector. As previously mentioned, we may
additionally use the knowledge of the actual c to help (since we
know the indices up to a shift).
Unblinding c. Finally, we have to recover the actual value of s.
Here, we just have to go through the n possible shift values and
10
Figure 11: Constant time, branch-free version of the sam-
pling algorithms for Bexp(−x /f ).
r ← 1
for i = 0 to ℓ − 1 do
Sample a ← Bci
r ← r · (1 − xi + axi )
1: function SampleBernExpConstTime(x ∈ [0, 2ℓ ) ∩ Z)
2:
3:
4:
5:
6:
7:
8: end function
end for
return r
the invertible constants, which is of reasonable complexity for all
BLISS parameters.
6 DISCUSSION
We have presented side-channel attacks against three parts of the
BLISS signing algorithm, namely the rejection sampling step, the
Gaussian sampling, and the multiplication of the secret key by
the hash value c. We have found them to yield full key recoveries,
either on the embedded 8-bit AVR implementation of Pöppelmann et
al. [46] through EM emanations, on in the strongSwan software [51]
on a Linux desktop machine under branch tracing. In this section,
we n discuss possible countermeasures and conclusions that one
could draw from these observations.
6.1 Attack against the rejection sampling
As we have seen, the implementation of BLISS rejection sampling,