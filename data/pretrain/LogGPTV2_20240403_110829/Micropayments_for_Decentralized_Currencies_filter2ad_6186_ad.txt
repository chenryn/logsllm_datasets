then veriï¬es equality of the two. An input script that satis-
ï¬es this condition might be Ï‰ = [a1]
[a2] . . . [an] [script],
i.e. the script pushes arguments a1, . . . , an onto the stack,
and then pushes a string script onto the stack. When a
certain bit is set in the output address, then the release con-
dition ï¬rst evaluates Ï‰ to setup the stack, then interprets
the release condition which checks that the ï¬rst argument
[script] on the stack is the same one speciï¬ed in the release
condition, and then interprets [script] as a new script which
it then executes against the values a1, . . . , an which remain
on the stack.
A script hash is the preferred method for encoding multi-
signature release conditions, i.e. transactions which require
more than one party to sign for the release condition to be
satisï¬ed. A script such as
2 [pk1] [pk2] 2 check multisig
pushes the constants 2, pk1, pk2, 2 onto the stack and then
involves the check multisig operation which then reads
these 4 arguments and interprets them as â€œsucceed if the
next two arguments on the stack correspond to signatures
under 2 of the public keys pk1, pk2.â€ To satisfy this script,
the witness should be of the form Ï‰ = 0 Ïƒ1 Ïƒ2 where Ïƒi is a
signature on the transaction under key ski. The extra 0 at
the beginning is a peculiarity of the check sig operation.
3.2 Modiï¬cations to Bitcoin for MICROPAY1
The Bitcoin script language supports a check sig opera-
tion that reads a public key and a signature from the stack
and then veriï¬es the signature against the public key on
a message that is derived in a special way from the current
transaction. This (and its multi-sig version) is the only oper-
ation that performs signature veriï¬cation. In MICROPAY1,
however, our scheme requires the veriï¬cation of a signature
on a transcript of a coin-tossing protocol, i.e. step (3) of
the release condition Î esc(x, aesc, a2) needs to verify a signa-
ture on the tuple (c, a2, r2). Thus, to support our protocol,
we suggest a new operation check rawsig which reads a
public key, a signature, and values from the stack which it
2Base58 uses upper- and lower- case alphabet characters and
the numerals 1-9, but removes the upper-case O, upper-case
I and lower-case l to eliminate ambiguities
3A very speciï¬c transformation is used to change the cur-
rent transaction into a string upon which the signature Ïƒ is
veriï¬ed using public key pk.
213concatenates to produce the message that is used to check
the signature. More speciï¬cally, when this instruction is
called, the top of the stack should appear as follows:
[an] Â·Â·Â· [a1] [n] [Ïƒ] [pk]
The operation performs the following steps:
1. Read the top argument on the stack; interpret as a
public key. (Same as the ï¬rst step of op checksig.)
2. Read the next argument on the stack; interpret as a
signature string. (Same as the second step of op checksig.)
3. Read the next argument n from the stack and interpret
as a 32-bit unsigned integer.
4. Read the next n arguments an, anâˆ’1, . . . , a1 from the
top of the stack and concatenate to the string m =
a1||a2||Â·Â·Â·||an where || is a unique delimiter string.
5. Verify that Ïƒ is a signature on message m under public
key pk. If not, then abort. (Same as the last step of
the standard op checksig instruction.)
Thus, the only diï¬€erence between this instruction and the
op checksig instruction is how the message m is constructed.
In the later case, the message is constructed by removing
part of the script from the current transaction in a spe-
ciï¬c way. An implementation of this method in the libbit-
coin[8] library requires only 30 additional lines of code.
Additionally, in order to verify that the transcript of our
â€œcoin-ï¬‚ippingâ€ protocol is a winning transcript, we need to
add (or xor) integers on the top of the stack and compare
and integer on the stack to a ï¬xed constant. In the current
scripting language, numeric opcodes such as add and ltcmp
are restricted to operating on 4-byte integers. To ensure the
soundness of our coin-ï¬‚ipping protocol, however, we require
the merchant to select a witness x (that is used to form
the commitment c) from 128-bit strings. Thus, the integers
on our stack will be larger than 4-bytes, and currently, the
Bitcoin script stops evaluating the script and fails when this
event occurs. To enable our functionality, we require the
operations to simply truncate the integers on the stack to
4-byte values and continue evaluating the script (instead of
aborting the execution of the script as they do now). This
change requires only ï¬ve lines of code in libbitcoin.
3.3 Implementing MICROPAY2
We implement our second scheme in this section. Figure 2
shows the message ï¬‚ow; we then describe each message in
detail.
step 0. The VTS T publishes a public key pkT and retains
a secret key skT used for signing.
example: Party T publishes public key
0305a8643a73ecddc682adb2f9345817d
c2502079d3ba37be1608170540a0d64e7
step 1. The ï¬rst step of our scheme is for the user to post
an escrow transaction for $100X onto the blockchain. To do
so, the payer generates a new address aesc while retaining the
associated key pair (skesc, pkesc), and publishes a transaction
on the ledger that speciï¬es an output aesc with a special
scripthash output script. The scripthash output script will
be
hash160 [hesc] eq verify
Figure 2: An example of how MICROPAY2 can be
implemented in the Bitcoin scripting language.
where hesc is constructed by ï¬rst producing the redeemscript
resc â† â€œ2 [pkT ]
[pkesc] 2 check multisigâ€
and then computing hesc â† hash160(resc).
example The user posts escrow to the blockchain:
transaction {
hash fc7237b89...d347
inputs {
input {
address mtGBirEkX5...SMPQszNtYR
previous_output {
hash da27eb8d...6979
index 0
}
script "[ 30440...f401 ] [ 03c7...e463 ]"
sequence 4294967295
}
}
lock_time 0
outputs {
output {
address 2N8Q...Cw41VBPgWHoHv
script "hash160 [ a640...c939 ] equal"
value 1000000
}
output {
address mtGB...NtYR
script "dup hash160 [ 8b...c2 ] eqver checksig"
value 3250000
}
}
version 1
}
The escrow address for this example is 2N8Q...HoHv.
step 2. To request a payment, the merchant picks a random
r1 â† {0, 1}128 string and then computes c â† H(r1) where H
is the SHA256 operation implemented in the Bitcoin script-
ing language. The merchant also generates a new Bitcoin
Payer creates escrow2N8QHzsKadx92nRUjUX3U5Cw41VBPgWHoHvMmerchantPpayer1.Pick random r1 and addr a2.c=Com(r1), a2hash160 [ a64..939 ] equalscripthash2.  ğœ1, ğœ, L1,RSL1transaction {  hash da27â€¦ef42    input  {   }     script { empty   }    â€¦    output {       }    version 1 }ğœ1=sigesc(L1)The redeem script RS requires a multi-signature by payer key esc and by service key T.4. Verify win. sign L1.Tservice3. If r1+r2<R, t wins lottery.(L1,ğœ1,ğœ,c,r1,r2,a2)ğœt=sigT(L1)5. Use (ğœ1,ğœt) and redeem script RS  to spend escrow.RSğœ=sigesc(c,r2,a2)aesc214address a2 and sends (c, a2) to the payer while retaining the
public and secret keys associated with a2.
example The Merchant picks the random message
r1 â† 29c14f18638da11b75663e050087b591
computes c â† sha256(r1) and sends the message
7c12e848a4a3a9f31c7abea5ab323eeb
6893c3a08675cc6c076e39950e52695e
c =
along with a new bitcoin address
a2 â† mkKKRLweRbu7Dam82KiugaA9bcnYXSyAVP
step 3. Upon receiving (c, a2) from a merchant, the payer
veriï¬es that c is the proper length for the hash of a 128-bit
string, and that a2 is a well-formed bitcoin address. The
payer picks a random 8-bit string r2 â† {0, 1}8, and then
uses skesc in order to compute the signature Ïƒ on the message
(c, r2, a2) using the secret key skesc. The payer also computes
a signature Ïƒ1 on the transaction (aesc, a2) using the secret
key skesc. The payer sends (aesc, r2, Ïƒ, Ïƒ1) to the merchant.
example The payer randomly samples r2 â† 37 and then
computes a signature on (c, r2, a2) as
Ïƒ â† IKZRV...rgXLHs=
The payer then forms the transaction (aesc, a2) as follows
transaction {
hash 2de3...0e73
inputs {
input {
previous_output {
hash fc72...d347
index 0
}
script ""
sequence 4294967295
}
}
lock_time 0
outputs {
output {
address mkKK...yAVP
script "dup hash160 [ 34a...e2a ] eq_ver chksig"
value 100000
}
}
version 1
}
and then signs the transaction using skesc
Ïƒ1 â† 3044...ed01
step 4. Upon receiving (r2, Ïƒ, Ïƒ1) from the payer, the Mer-
chant ï¬rst veriï¬es the two signatures on the respective mes-
sages and veriï¬es that aesc has not yet been spent. The
merchant then checks whether r1 âŠ• r2 results in a string
whose last two (or alternatively, ï¬rst two) digits are zero.
If so, then the merchant has a winning ticket. To redeem
the escrow amount, the merchant sends the winning tuple
consisting of x = (c, r1, r2, Ïƒ, Ïƒ1, aesc, a2) to the VTS T . T
veriï¬es that the tuple corresponds to a win for the escrow
aesc, and if so, then signs the transaction (aesc, a2) using
public key pkT . Speciï¬cally, T veriï¬es that c = H(r1), Ïƒ
is a valid signature on (c, r2, a2) w.r.t. pkesc, and the last 2
digits of r1 âŠ• r2 are 00.
Furthermore, T publishes tuple x on its own bulletin board,
on the bitcoin blockchain, or on some â€œalt-chainâ€.
step 5. Finally, once M has received the signature ÏƒT from
T , then M can spend aesc to address a2 (which it controls)
using Ïƒ1, ÏƒT to satisfy the release condition.
4. EVALUATION
4.1 Expected Revenue and Expenditure
With each of our probabilistic payment schemes, the seller
receives X coins in expectation for every interaction with a
buyer. We provide a statistical analysis to guarantee that
after suï¬ƒciently many payments, both the buyer and the
seller respectively spend and receive an amount that is close
to the expectation with high probability.
Our scheme is parameterized by Ï, the probability that
a lottery ticket wins. One can tune Ï to balance the num-
ber of winning transactions with the variance in the actual
cost/revenue from each transaction. Although the previous
section used Ï = 1
100 , our implementation uses Ï that is a
power of 2 to simplify the coin-ï¬‚ipping protocol. Thus, in
the following sections, we consider Ï1 = 1
512 .
A standard Bernoulli analysis suï¬ƒces because the security
properties of our scheme prevent even malicious parties from
biasing independent executions of the protocol. Let Ri be a
random variable denoting revenue from the ith execution of
the protocol (e.g., Ri is either 0 or X/Ï, in our case, either
i Ri. As
discussed previously E[Ri] = Ï Â· X/Ï = X, so E[R] = Xn.
Recall that the probability that revenue is exactly Xk is
0 or 128). The total revenue is therefore R = (cid:80)n
128 and Ï2 = 1
Pr [R = Xk] =
(Ï)kÏ (1 âˆ’ Ï)nâˆ’kÏ
(cid:32)
(cid:33)
n
kÏ
Using this formula and Ï1 = 1
128 , we illustrate the prob-
ability of paying (or receiving) a speciï¬c amount per trans-
action in Fig. 3. These graphs show that both the buyer
(who may, say, make 1000 transactions per year) and a seller
(who may receive 10,000 transactions per month), the av-
erage price over those transactions will be close to the ex-
pected amount of X per transaction. The blue sections of
those graphs show 99% of the probability mass.
As the number of transactions increases for a very busy
seller (e.g, a web site that receives millions of views), the
guarantees on revenue become even tighter. To illustrate,
we now compute the probability that R < 0.8n, i.e., that
revenue is less than 80% of the expected value:
(cid:98)0.8nÏ(cid:99)(cid:88)
Pr [R < 0.8n] =
Pr [R = Ï Â· k]
k=0
The ï¬‚oor function in the summationâ€™s upper bound make
the function â€œchoppyâ€ and non-monotone at those n when
the value discretely increases by 1. The Chernoï¬€ bound is a
general tool that can be used to bound tail inequalities such
as this one. However, this estimate is loose, and we instead
compute the exact value in Fig. 4. After 100,000 transac-
tions, there is high probability that the actual revenue will
be at least 80% of the expected value and good probability
215Figure 3: Pr of payment amount (parameterized by
X) after 1,000 and 10,000 transactions (for win rate
Ï1 = 1
128 ). The blue region shows 99% of the mass.
If escrow is 128X, then the expected payment is X.
that the revenue will be at least 90% of the expected. In
Fig. 5, we show the same results for win rate Ï2 = 1
512 .