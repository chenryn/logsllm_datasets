title:VisibleV8: In-browser Monitoring of JavaScript in the Wild
author:Jordan Jueckstock and
Alexandros Kapravelos
VisibleV8: In-browser Monitoring
of JavaScript in the Wild
Jordan Jueckstock
North Carolina State University
PI:EMAIL
ABSTRACT
Modern web security and privacy research depends on accurate
measurement of an often evasive and hostile web. No longer just a
network of static, hyperlinked documents, the modern web is alive
with JavaScript (JS) loaded from third parties of unknown trustwor-
thiness. Dynamic analysis of potentially hostile JS currently presents
a cruel dilemma: use heavyweight in-browser solutions that prove
impossible to maintain, or use lightweight inline JS solutions that
are detectable by evasive JS and which cannot match the scope of
coverage provided by in-browser systems. We present VisibleV8,
a dynamic analysis framework hosted inside V8, the JS engine of the
Chrome browser, that logs native function or property accesses dur-
ing any JS execution. At less than 600 lines (only 67 of which modify
V8’s existing behavior), our patches are lightweight and have been
maintained from Chrome versions 63 through 72 without difficulty.
VV8 consistently outperforms equivalent inline instrumentation,
and it intercepts accesses impossible to instrument inline. This com-
prehensive coverage allows us to isolate and identify 46 JavaScript
namespace artifacts used by JS code in the wild to detect automated
browsing platforms and to discover that 29% of the Alexa top 50k
sites load content which actively probes these artifacts.
ACM Reference Format:
Jordan Jueckstock and Alexandros Kapravelos. 2019. VisibleV8: In-browser
Monitoring of JavaScript in the Wild. In Internet Measurement Conference
(IMC ’19), October 21–23, 2019, Amsterdam, Netherlands. ACM, New York, NY,
USA, 13 pages. https://doi.org/10.1145/3355369.3355599
1 INTRODUCTION
“Software is eating the world” [16], and that software is increasingly
written in JavaScript (JS) [6, 12]. Computer applications increasingly
migrate into distributed, web-based formats, and web application
logic increasingly migrates to client-side JS. Web applications and
services collect and control vast troves of sensitive personal informa-
tion. Systematic measurements of web application behavior provide
vital insight into the state of online security and privacy [35]. With
modern web development practices depending heavily on JS for even
basic functionality, and with increasingly rich browser APIs [50]
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or
a fee. Request permissions from permissions@acm.org.
IMC ’19, October 21–23, 2019, Amsterdam, Netherlands
© 2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-6948-0/19/10...$15.00
https://doi.org/10.1145/3355369.3355599
Alexandros Kapravelos
North Carolina State University
PI:EMAIL
providing an inviting attack surface for fingerprinting [13] and track-
ing [22], effective security and privacy measurement of the web must
include some degree of JS behavioral analysis.
Asifdealingwiththequirky,analysis-hostiledynamismofJSitself
werenotenough,researchersarealsolockedinanarmsracewitheva-
sive and malicious web content that frequently cloaks [24] itself from
unwanted clients. The ad-hoc approaches to JS instrumentation com-
mon in the literature suffer obvious shortcomings. Heavy-weight
systems built by modifying a browser’s JS engine can provide ade-
quate coverage and stealth, but suffer from high development costs
(on the order of thousands of lines of C/C++ code [33, 41, 53]) and
poor maintainability, with patches rarely or never ported forward
to new releases. Lighter-weight systems built by injecting in-band,
JS-based instrumentation hooks directly into the target application’s
namespace avoid these pitfalls but suffer their own drawbacks: struc-
tural and policy limits on coverage, and vulnerability to well-known
detection and subversion techniques (Section 2).
We argue in this paper that a maintainable in-browser JS instru-
mentation that matches or exceeds in-band equivalents in coverage,
performance, and stealth is possible. As proof, we present Visi-
bleV8 (VV8): a transparently instrumented variant of the Chromium
browser1 for dynamic analysis of real-world JS that we have suc-
cessfully maintained across eight Chromium release versions (63 to
72). VV8 lets us passively observe native (i.e., browser-implemented)
API feature usage by popular websites with fine-grained execution
context (security origin, executing script, and code offset) regardless
of how a script was loaded (via static script tag, dynamic inclusion,
or any form of eval). Native APIs are to web applications roughly
what system calls are to traditional applications: security gateways
through which less privileged code can invoke more privileged code
to access sensitive resources. As such, VV8 provides a JS analog to the
classic Linux strace utility. VV8 can be used interactively like any
other browser, but is primarily intended for integration with auto-
mated crawling and measurement frameworks like OpenWPM [22].
We demonstrate VV8 by recording native feature usage across
the Alexa top 50k websites, identifying feature probes indicative
of bot detection, and analyzing the extent of such activity across
all domains visited. Our collection methodology takes inspiration
from Snyder et al. [49], using an automated browser instrumen-
tation framework to visit popular domains, to randomly exercise
JS-based functionality on the landing page, and to collect statistics
on JS feature usage. Our identification and analysis of bot detection
artifacts used in the wild showcases VV8’s unique advantages over
traditional JS instrumentation techniques: improved stealth in the
1Chromium is the open-source core of Chrome, equivalent in functionality but
lacking Google’s proprietary branding and service integration. We use the names
interchangeably in this paper.
IMC ’19, October 21–23, 2019, Amsterdam, Netherlands
Jordan Jueckstock and Alexandros Kapravelos
face of evasive scripts, and universal property access tracking on
native objects that do not support proxy-based interposition.
Our contributions include:
• We demonstrate that state-of-the-art inline JS instrumenta-
tion fails to meet classical criteria for reference monitors [15]
and cannot prevent evasive scripts from deterministic detec-
tion of instrumentation.
• We present the first maintainable in-browser framework for
transparent dynamic analysis of JS interaction with native
APIs. Using instrumented runtime functions and interpreter
bytecode injection, VV8 monitors native feature usage from
inside the browser without disrupting JIT compilation or leav-
ing incriminating artifacts inside JS object space. We will open
source our patches and tools upon publication.
• We use VV8’s universal property access tracing to discover
non-standard features probed by code that detects “bots” (i.e.,
automated browsers, such as those used by researchers). We
find that on 29% of the Alexa top 50k sites, at least one of 49
identified bot artifacts is probed. This is clear evidence that
web measurements can be affected by the type of browser or
framework that researchers use.
2 BACKGROUND & MOTIVATION
2.1 Trends and Trade-offs
The state of the art in web measurements for security and privacy
relies on full browsers, not simple crawlers or browser-simulators,
to visit web sites. Experience with the OpenWPM framework [22]
indicated measurements from standard browsers (e.g., Firefox and
Chromium) to be more complete and reliable than those from light-
weight headless browsers (e.g., PhantomJS [10]). However, the ques-
tion of how best to monitor and measure JS activity within a browser
remains open. Assuming an open-source browser, researchers can
modify the implementation itself to provide in-browser (i.e., out-of-
band) JS instrumentation. Alternatively, researchers can exploit the
flexibility of JS itself to inject language-level (i.e., in-band) instru-
mentation directly into JS applications at run-time.
We provide a summary of recent security and privacy related
research that measured web content using JS instrumentation in
Table 1. Note that here “taint analysis” implies “dynamic analysis”
but additionally includes tracking tainted data flows from source to
sink. Fine-grained taint analysis is a heavy-weight technique, as is
comprehensive forensic record and replay, so it is not surprising that
these systems employed out-of-band (in-browser) implementations
in native (C/C++) code. Lighter weight methodologies that simply
log (or block) use of selected API features have been implemented
both in- and out-of-band, but the in-band approach is more popular,
especially in more recent works.
2.2 Fundamental Criteria
The problem of monitoring untrusted code dates to the very dawn
of computer security and inspired the concept of a reference mon-
itor [15], a software mediator that intercepts and enforces policy
on all attempted access to protected resources. The traditional cri-
teria of correctness for reference monitors are that they be tamper
proof, be always invoked (i.e., provide complete coverage), and
be provably correct, though this last element may be lacking in
Figure 1: Reference monitors (RM) in traditional OS &
application security
practical implementations. For security and privacy measurements,
we add the additional criterion of stealth: evasive or malicious code
should not be able to trivially detect its isolation within the reference
monitor and hide its true intentions from researchers, since such an
evasion could compromise the integrity of the derived results.
A classic example of a practical reference monitor is an operating
system kernel: it enforces access control policies on shared resources,
typically using a rings of protection scheme (Figure 1) assisted by
hardware. In order to enforce security policies like access controls
and audits, the kernel must run in a privileged ring. Untrusted user
code runs in a less-privileged ring, where the kernel (i.e., the ref-
erence monitor) can intercept and thwart any attempt to violate
system policy. Alternatively, inlined reference monitors (IRMs) [23]
attempt to enforce policy while cohabiting the user ring with the
monitored application, typically by rewriting and instrumenting the
application’s code on the fly at load or run time.
On the web, the browser and JS engine provide the equivalent of
a kernel, while JS application code runs in a “user ring” enforced by
the semantics of the JS language. JS instrumentation in general is a
kind of reference monitor; implemented in-band, it constitutes an
IRM. We argue that the JS language’s inherent semantics and current
implementation details make it impossible to build sound, efficient,
general-purpose IRMs in JS on modern web browsers.
2.3 The Case Against In-Band
JS Instrumentation
The standard approach to in-band JS instrumentation, which we call
“prototype patching,” is to replace references to target JS functions
or objects with references to instrumented wrapper functions or
proxy objects2. The wrappers can access the original target through
2Other forms of JS IRM exist, like nested interpreters [18, 52] and code-rewriting sys-
tems [20], but these have not yet proven fast enough for real-world measurement work.
"Kernel Space" (Browser Code) "User Space" (JavaScript Code) = Protected Browser APITraditional RM Execution Context Execution ContextInlined RM= Instrumentation LayerVisibleV8: In-browser Monitoring
of JavaScript in the Wild
IMC ’19, October 21–23, 2019, Amsterdam, Netherlands
Role
Problem
Platform
Availability
4
System
Implementation
In-band
In-band
In-band
In-band
In-band
In-band
Out-of-band
Out-of-band
Out-of-band
Out-of-band
Out-of-band
Out-of-band
Out-of-band
Out-of-band
Out-of-band
OpenWPM [21, 22, 38]1
Snyder et al., 2016 [49]
FourthParty [35]
TrackingObserver [45]
JavaScript Zero [47]
Snyder et al., 2017 [50]
Li et al., 2014 [34]
FPDetective [13]
WebAnalyzer [48]
JSgraph [33]
WebCapsule [41]
Mystique [19]
Lekies et al. [31, 32]
Stock et al. [51]
Tran et al., 2012 [53]
1 Including only OpenWPM usage depending on JS instrumentation
2 Supported only through Firefox 52 (end-of-life 2018-09-05)
3 Used both PhantomJS and Chrome built from a common patched WebKit
4 Binaries only
Firefox SDK2
Firefox SDK
Firefox SDK
Various
Attack surface
Privacy/tracking
Privacy/tracking WebExtension
WebExtension
Side-channels
Firefox SDK
Privacy/tracking
Malware
Firefox (unspecified)
Chrome 323
Privacy/tracking
Privacy/tracking
Internet Explorer 8
Dynamic analysis
Dynamic analysis
Dynamic analysis
Dynamic analysis
Policy enforcement
Policy enforcement
Dynamic analysis
Dynamic analysis
Dynamic analysis
Forensic record/replay Malware/phishing Chrome 48
Forensic record/replay Malware/phishing Chrome 36
Taint analysis
Chrome 58
Chrome (unspecified)
Taint analysis
Firefox (unspecified)
Taint analysis
Taint analysis
Firefox 3.6
Privacy/tracking
XSS
XSS
Privacy/tracking
Table 1: Survey of published JS instrumentation systems
1
2
3
4
5
6
7
8
9
10
11
12
13
references captured in a private scope inaccessible to any other code.
Note that the target objects themselves are not replaced or instru-
mented, only the references to them (a potential pitfall highlighted
in prior work [37]).
Structural Limits. The JS language relies heavily on a global
object (window in browsers) which doubles as the top level names-
pace. There is no mutable root reference to the global object, and
thus no way to replace it with a proxy version. Specific properties
of the global object may be instrumented selectively, but this pro-
cess naturally requires a priori knowledge of the target properties.
In-band instrumentation cannot be used to collect arbitrary global
property accesses, as required for our methodology in Section 5. This
limitation means that in-band JS instrumentation fails the complete
coverage criterion.