# Title: VisibleV8: In-Browser Monitoring of JavaScript in the Wild

## Authors
- Jordan Jueckstock, North Carolina State University
- Alexandros Kapravelos, North Carolina State University

## Abstract
Modern web security and privacy research relies on accurate measurement of a dynamic and often hostile web environment. The modern web is no longer just a network of static, hyperlinked documents; it is now a vibrant ecosystem powered by JavaScript (JS) loaded from third parties of varying trustworthiness. Dynamic analysis of potentially malicious JS presents a challenging dilemma: use heavyweight in-browser solutions that are difficult to maintain, or lightweight inline JS solutions that are easily detectable and offer limited coverage.

We introduce VisibleV8 (VV8), a dynamic analysis framework integrated into V8, the JS engine of the Chrome browser. VV8 logs native function or property accesses during any JS execution. Our implementation, comprising fewer than 600 lines of code (only 67 of which modify V8’s existing behavior), is lightweight and has been maintained across Chrome versions 63 through 72 without difficulty. VV8 outperforms equivalent inline instrumentation and can intercept accesses that are impossible to instrument inline. This comprehensive coverage allows us to identify 46 JavaScript namespace artifacts used by JS code in the wild to detect automated browsing platforms. We also discovered that 29% of the Alexa top 50k sites load content that actively probes these artifacts.

## ACM Reference Format
Jordan Jueckstock and Alexandros Kapravelos. 2019. VisibleV8: In-Browser Monitoring of JavaScript in the Wild. In Internet Measurement Conference (IMC '19), October 21–23, 2019, Amsterdam, Netherlands. ACM, New York, NY, USA, 13 pages. https://doi.org/10.1145/3355369.3355599

## 1. Introduction
"Software is eating the world," and much of this software is increasingly written in JavaScript (JS). As applications migrate to distributed, web-based formats, web application logic is shifting to client-side JS. Web applications and services collect and control vast amounts of sensitive personal information. Systematic measurements of web application behavior provide critical insights into online security and privacy. With modern web development heavily dependent on JS for even basic functionality and with rich browser APIs offering an attractive attack surface for fingerprinting and tracking, effective security and privacy measurement must include JS behavioral analysis.

The quirky and evasive nature of JS itself, combined with the arms race against evasive and malicious web content, poses significant challenges. Ad-hoc approaches to JS instrumentation, common in the literature, have clear shortcomings. Heavyweight systems built by modifying a browser's JS engine provide adequate coverage and stealth but suffer from high development costs and poor maintainability. Lighter-weight systems, which inject JS-based instrumentation hooks directly into the target application's namespace, avoid these issues but have their own limitations, such as structural and policy limits on coverage and vulnerability to detection and subversion techniques.

In this paper, we argue that a maintainable in-browser JS instrumentation that matches or exceeds in-band equivalents in coverage, performance, and stealth is feasible. We present VisibleV8 (VV8), a transparently instrumented variant of the Chromium browser that we have successfully maintained across eight Chromium release versions (63 to 72). VV8 passively observes native API feature usage by popular websites, providing fine-grained execution context regardless of how a script was loaded. Native APIs are to web applications what system calls are to traditional applications: security gateways through which less privileged code can invoke more privileged code to access sensitive resources. Thus, VV8 provides a JS analog to the classic Linux `strace` utility.

We demonstrate VV8 by recording native feature usage across the Alexa top 50k websites, identifying feature probes indicative of bot detection, and analyzing the extent of such activity. Our collection methodology, inspired by Snyder et al. [49], uses an automated browser instrumentation framework to visit popular domains, randomly exercise JS-based functionality, and collect statistics on JS feature usage. Our identification and analysis of bot detection artifacts highlight VV8's unique advantages over traditional JS instrumentation techniques, including improved stealth and universal property access tracking on native objects that do not support proxy-based interposition.

Our contributions include:
- Demonstrating that state-of-the-art inline JS instrumentation fails to meet classical criteria for reference monitors and cannot prevent evasive scripts from detecting instrumentation.
- Presenting the first maintainable in-browser framework for transparent dynamic analysis of JS interaction with native APIs. Using instrumented runtime functions and interpreter bytecode injection, VV8 monitors native feature usage from inside the browser without disrupting JIT compilation or leaving incriminating artifacts in JS object space. We will open-source our patches and tools upon publication.
- Using VV8's universal property access tracing to discover non-standard features probed by code that detects "bots" (i.e., automated browsers used by researchers). We find that on 29% of the Alexa top 50k sites, at least one of 49 identified bot artifacts is probed, indicating that web measurements can be affected by the type of browser or framework used by researchers.

## 2. Background & Motivation

### 2.1 Trends and Trade-offs
State-of-the-art web measurements for security and privacy rely on full browsers, not simple crawlers or browser-simulators, to visit websites. Experience with the OpenWPM framework [22] indicates that measurements from standard browsers (e.g., Firefox and Chromium) are more complete and reliable than those from lightweight headless browsers (e.g., PhantomJS [10]). However, the best approach to monitor and measure JS activity within a browser remains an open question. Researchers can modify the browser's implementation to provide in-browser (out-of-band) JS instrumentation or inject language-level (in-band) instrumentation directly into JS applications at runtime.

Table 1 summarizes recent security and privacy-related research that measured web content using JS instrumentation. Fine-grained taint analysis and comprehensive forensic record and replay are heavy-weight techniques, typically implemented out-of-band. Lighter-weight methodologies that simply log or block selected API features have been implemented both in- and out-of-band, with the in-band approach being more popular in recent works.

### 2.2 Fundamental Criteria
The problem of monitoring untrusted code dates back to the dawn of computer security and inspired the concept of a reference monitor, a software mediator that enforces policy on all attempted access to protected resources. Traditional criteria for reference monitors include tamper-proofness, complete coverage, and provable correctness. For security and privacy measurements, we add the criterion of stealth: evasive or malicious code should not be able to trivially detect its isolation and hide its true intentions, as such evasion could compromise the integrity of the results.

A classic example of a practical reference monitor is an operating system kernel, which enforces access control policies on shared resources using a rings of protection scheme. On the web, the browser and JS engine provide the equivalent of a kernel, while JS application code runs in a "user ring" enforced by the semantics of the JS language. JS instrumentation in general is a kind of reference monitor; implemented in-band, it constitutes an inlined reference monitor (IRM). We argue that the inherent semantics and current implementation details of the JS language make it impossible to build sound, efficient, general-purpose IRMs in JS on modern web browsers.

### 2.3 The Case Against In-Band JS Instrumentation
The standard approach to in-band JS instrumentation, known as "prototype patching," involves replacing references to target JS functions or objects with references to instrumented wrapper functions or proxy objects. The wrappers can access the original target through references captured in a private scope inaccessible to other code. Note that the target objects themselves are not replaced or instrumented, only the references to them.

**Structural Limits:** The JS language relies heavily on a global object (window in browsers) that doubles as the top-level namespace. There is no mutable root reference to the global object, making it impossible to replace it with a proxy version. Specific properties of the global object may be instrumented selectively, but this process requires a priori knowledge of the target properties. In-band instrumentation cannot be used to collect arbitrary global property accesses, as required for our methodology. This limitation means that in-band JS instrumentation fails the complete coverage criterion.