原始数值
取反
BKTKUKUKTKUKI
加1，获取
补数完成
图2-5获取00000001的补数的方法
补数的思考方式，虽然直观上不易理解，但逻辑上却非常严谨。
①这里所说的取反是指，把二进制数各数位的0变成1。1变成0.例如
00000001这个8位二进制数取反后就成了11111110
---
## Page 43
2.4便于计算机处理的“补数”
例如1-1，也就是1+（-1）这一运算，我们都知道答案应该是0。首
先，让我们将-1表示成10000001（错误的表示方法）来运算，看看结
果如何。0000001+10000001-10000010，很明显结果不是0（图
2-6）。如果结果是0.那么所有的数位都应该是0才对。
000000011的表示方法是正确的
+10000001-1的表示方法是错误的
10000101+(-11的运算结果不为0，是错误的
图2-6负数表示有误时的情况
接下来，让我们把-1表示成11111111（正确的表示方法）来进行
运算。00000001+11111111确实为0（=00000000）。这个运算中出现
了最高位溢出的情况，不过，正如之前所介绍的那样，对于溢出的位，
计算机会直接忽略掉。在8位的范围内进行计算时，100000000这个9
位二进制数就会被认为是00000000这一8位二进制数（图2-7）。
000000011的表示方法是正确的
+111111111的表示方法是正确的
00000001+（-1）的运算结果为0，是正确的
这个位溢出会被息略
图2-7负数表示正确时的情况
补数求解的变换方法就是“取反+1”。为什么使用补数后就能正确
地表示负数了呢？为了加深印象，我们来看一下图2-7，与此同时也希
---
## Page 44
第2章数据是用二进制数表示的
加，结果为0”这一法则。首先，大家可以用1和-1的二进制形式，来彻
底地了解补数的相关内容。除了1+（-1）之外，2+（-2）、39+（-39）等
同样如此。总之，要想使结果为0，就必须通过补数来实现。
当然，结果不为0的运算同样可以通过使用补数来得到正确的结
果。不过，有一点需要注意，当运算结果为负数时，计算结果的值也
是以补数的形式来表示的。比如3-5这个运算，用8位二进制数表示
3时为00000011，而5=00000101的补数为“取反+1”，也就是
11111011。因此3-5其实就是00000011+11111011的运算。
00000011+11111011的运算结果为11111110，最高位变成了1。这
就表示结果是一个负数，这点大家应该都能理解。那么11111110表示
的负数是多少大家知道吗？这时我们可以利用负负得正这个性质。假
若11111110是负△△，那么11111110的补数就是正△。通过求解补
数的补数，就可知该值的绝对值。1111110的补数，取反加1后为
00000010。这个是2的十进制数。因此，11111110表示的就是-2。我们
也就得到了3-5的正确结果（图2-8）。
00000011  3
+11111011-用补数表示的-5
1111110用补数表示的运算结果-2
图2-83-5的运算结果
①例如，00000001和取反后的1111110相加，结果为1111111，全部数位均
为1。因此，比11111110大1的数加上00000001后，1111111变为9位的
10000000。由于在8位的范国内运算时第9位会被计算机忽略，因此结果
就变成了00000000。
---
## Page 45
2.5遵辑右移和算术右移的区剂
编程语言包含的整数数据类型”中，有的可以处理负数，有的则不
能处理。例如，C语言的数据类型中，既有不能处理负数的unsigned
short类型，也有能处理负数的short类型。这两种类型，都是2字节
（=16位）的变量，都能表示2的16次幂=65536种值，这一点是相同
的。不过，值的范围有所不同，short类型是-32768~32767，umsigned
short类型是0~65535。此外，shont类型和unsigncd shont类型的另一
个不同点在于，short类型是将最高位为1的数值看作补数，面
unsigned short 类型则是32768以上的值。
仔细思考一下补数的机制，大家就会明白像-32768~32767这样
负数比正数多一个的原因了。最高位是0的正数，有0~32767共
32768个，这其中也包含0。最高位是1的负数，有-1~-32768共
32768个，这其中不包含0。也就是说，0包含在正数范围内，所以负
数就要比正数多1个。虽然0不是正数，但考虑到符号位，就将其划
分到了正数中。
2.5逻辑右移和算术右移的区别
在了解了补数后，让我们返回到右移这个话题。前文已经介绍过，
右移有移位后在最高位补0和补1两种情况。当二进制数的值表示图
形模式面非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动
的效果。这就称为逻辑右移（图2-9）。
①多数编程语言都会把数据代入变量来进行处理。支量中会指定可以存储的
数值的种类（整数还是小数）和表示数值大小（位数）的数据类型。C语言
的数据类型中，有用于整数的 char、unsigned char、short、unsigned short、
int、unsigned int和用于小数的float、double等。关于数据类型的详细内
容，我们会在第4章进行说明。
---
## Page 46
溢出的低位被芯略掉
空出来的高位用0补上
图2-9图形式的右移（逻辑右移）
将二进制数作为带符号的数值进行运算时，移位后要在最高位填
充移位前符号位的值（0或1）。这就称为算术右移。如果数值是用补
数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地
实现1/2、1/4、1/8等的数值运算。如果是正数，只需在最高位补0
即可。
现在我们来看一个右移的例子。将-4（=11111100）右移两位。这
时，逻辑右移的情况下结果就会变成00111111，也就是十进制数63，
显然不是-4的1/4。而算术右移的情况下，结果就会变成11111111，
用补数表示就是-1，即-4的1/4（图2-10）。
只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是
图形模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来的
低位补0即可。
---
## Page 47
2.5逻辑右移和算术右酵的区副
辑右移
移位前=-4
移位后=63
空出亲的高位用0填充
算数右移
移位前=-4
移位后=-1
空出来的高位用移位前符号位的值（这里是1】亲补足
图2-10逻辑右移和算术右移的区
下面顺便介绍一下符号扩充。以8位二进制数为例，符号扩充就
是指在保持值不变的前提下将其转换成16位和32位的二进制数。将
01111111这个正的8位二进制数转换成16位二进制数时，很容易就能
得出0000000001111111这个正确结果，但是像11111111这样用补数来
表示的数值，该如何处理比较好呢？实际上处理方法非常简单，将其
表示成1111111111111111就可以了。也就是说，不管是正数还是用补
数表示的负数，都只需用符号位的值（0或者1）填充高位即可。这就
是符号扩充的方法。图2-11向我们展示了将符号位扩充到高位的具体
流程。
更多资料请关注裁的新浪薄客http：//blo
---
## Page 48
第2章数握是用二进别数表示的
用8位表示的127
只需用符号位的值来填充高位即可
用16位表示的127
用8位表示的-1
只需用符号位的值来填充高位即可
用16位表示的-1
图2-11由8位转换成16位的符号扩充方法
2.6掌握逻辑运算的窍门
解释逻辑右移时，提及了“逻辑”这个术语。大家听到逻辑这个词
可能会感觉有些难，但实际上它很简单。在运算中，与逻辑相对的术
语是算术。我们不妨这样考虑，将二进制数表示的信息作为四则运算
的数值来处理就是算术。而像图形模式那样，将数值处理为单纯的0
和1的罗列就是逻辑。
计算机能处理的运算，大体可分为算术运算和逻辑运算。算术运
算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的0和！
分别进行处理的运算，包括逻辑非（NOT运算）、逻辑与（AND运
算）、逻辑或（OR运算）和逻辑异或（XOR运算）四种。
①XOR是英语exclusive or的缩写。有时也将XOR称为EOR。
---
## Page 49
2.6/掌握理辑运算的痧门
逻辑非指的是0变成1、1变成0的取反操作。逻辑与指的是“两
个都是1时，运算结果为1，其他情况下运算结果都为0的运算。逻
辑或指的是“至少有一方是1”时，运算结果为1，其他情况下运算结
果都是0的运算。逻辑异或指的是排斥相同数值的运算。“两个数值不
同”，也就是说，当“其中一方是1，另一方是0”时运算结果是1，其
他情况下结果都是0。不管是几位的二进制数，在进行逻辑运算时，都
是对相对应的各数位分别进行运算。
表2-1～表2-4总结了各逻辑运算的结果。这些表称为真值表。如
果将二进制数的0作为假（false）、1作为真（true）来考虑，逻辑运算
也可以被认为是真假的运算。真和真的AND运算结果为真，实际上也
确实如此。因为如果两方面都是真，答案就是真。
表2-1逻非（NOT）的真值表
表2-2逻辑与（AND）的真值表
A的值
NOTA的运算结果
A的值B的值AANDB的运算结果
0
0
0
0
1
0
0
1
0
1
0
0
1
1
1
表23逻辑或（OR）的真值表
表2-4逻辑异或（XOR）的真值表
A的值B的值AORB的运算结果
A的值B的值AXORB的运算结果
0
0
0
0
1
0
1
0
1
1
0
1
1
掌握逻辑运算的窍门，就是要据弃用二进制数表示数值这一想法。
大家不要把二进制数表示的值当作是数值，而应该把它看作是图形或
者开关上的ON/OFF（1是ON，0是OFF）。逻辑运算的运算对象不是
数值，因此不会出现进位的情况。看起来好像有些麻烦，总之就是不
---
## Page 50
第2章数据是用二进制数表示的
要将它作为数值来考虑。另外，还有一点非常重要，就是要对各种逻
辑运算分别能实现什么有一个整体印象。形成这样的印象后，即使不
看真值表也能判断出运算的结果。
图2-12表示的是对NIKKEI的头两个字母NI这一图形模式进行各
种逻辑运算后的结果。假设白色部分表示1.黑色部分表示0。通过图
2-12，我们就会对逻辑运算有一个具体的把握，即“逻辑非是所有位的
）
将一部分变为1（复位到1）的操作”“逻辑异或是将一部分进行取反
（相同取0，不同取1）的操作”。
逻辑非运算时，全部取反
NI
NOT
逐辑与运算时，表示1的部分不变，表示0的部分变成0
AND
逻辑或运算时，表示0的部分不变，表示1的部分变成1
OR
逻辑异或运算时，表示0的部分不变，表示1的部分取反
KOR
图2-12对图形模式进行4种逻辑运算的结果（这里白色部分表示1，黑色部分表示0）
---
## Page 51
2.6掌握逻辑运算的鸡门
学完本章后，大家应该对二进制数、移位运算、逻辑运算都十分
了解了吧。不过，二进制数的小数1011.0011用十进制数来表示的话是
多少呢？大家知道吗？想必大家也都很关心如何用二进制数来表示小
数这一问题。下一章会有详细说明。
---
## Page 52
CoLUMN
如果是你，
你会怎样介绍？
向小学生讲解CPU和二进制
下面，我想道请正在阅读本书的各位读者来进行一个挑战，那就是向完全不
了解程序的人介绍程序的工作原理。如果理解了程序的本质，相信大家都可
以用通俗易懂的语言进行讲解。当然了，介绍时不可以使用计算机专业术
语。本书的专栏是笔者向一年级小学生及老奶奶介绍程序工作原理的一个尝
试。亲爱的读者们，如果是你，你会怎样介绍呢？请在阅读以下内客的同时
也思考一下吧。