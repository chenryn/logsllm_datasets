following sections discuss these relations in more detail.
6.1 Website and Application Inference
In literature, the inference of visited websites has been investigated
from many perspectives. Vila et al. [47] use shared event loops to in-
fer opened websites from the server side. Panchenko et al. [37] use
traffic analysis to detect visited websites in the Tor network. Zhang
et al. [51] exploit iOS APIs to infer visited websites and running ap-
plications. Spreitzer et al. [42, 43] obtain distinct features from the
procfs filesystem and use Android APIs to infer opened web pages
and applications. Lee et al. [27] exploit uninitialized GPU memory
pages to detect websites, while Naghibijouybari et al. [35] exploit
OpenGL APIs and GPU performance counters for this task. Gulme-
zoglu et al. [20] observe hardware performance events of modern
processors to infer visited websites. Diao et al. [6] infer applications
through system interrupts. Jana and Shmatikov [26] demonstrate
that websites leave a distinct memory footprint in the browser ap-
plication. Oren et al. [36] as well as Gruss et al. [13] demonstrate
that opened websites and their individual elements can be inferred
from cache observations taken from a malicious JavaScript applet.
Shusterman et al. [41] extend this work by inferring websites from
JavaScript with simple last-level cache profiles that are classified
by convolutional neural networks and long short-term memory. As
this is concurrent work to ours, we provide a closer comparison
later in this section. Gulmezoglu et al. [19] use cache observations
to detect running applications in co-located virtual machines. In
this work, we also use measurements of cache activity to infer
running applications, visited websites, and streamed videos. The
Table 1: Related website and application inference attacks.
Acc. (%) Classes
Attack Vector
s
e
t
i
s
b
e
W
Attack
Our
[36]
[41]
[20]
[35]
[27]
[26]
[47]
[37]
[51]
[43]
[42]
s Our
[19]
[51]
[43]
[6]
[42]
n
o
i
t
a
c
i
l
p
p
A
Last-level Cache (LLC)
LLC
LLC
CPU Performance Events
GPU Performance Events
Uninitialized GPU Memory
Scheduling Statistics
Shared Event Loops
Traffic Analysis
iOS APIs
Java-based Android API
ProcFS Leaks
LLC
LLC
iOS APIs
Java-based Android API
Interrupt Handling
ProcFS Leaks
85.8
82.1
86.1
84.0
93.0
95.4
78.0
76.7
92.5
68.5
89.4
94.0
97.8
78.5
89.0
85.6
87.0
96.0
70
8
100
30
200
100
100
500
100
100
20
20
70
40
120
20
100
100
comparison of our results with other attacks is given in Table 1.
It shows that GPU-, network traffic-, and operating system-based
attacks achieve higher success rates for website classification than
our inference attack. However, our attack does not require access
to GPU, network, or OS APIs, which can be restricted or easily
monitored. We rely on simple memory accesses and coarse-grained
timing measurements, which are difficult to restrict and monitor.
Compared to the LLC-based attack by Oren et al. [36], our success
rates are higher, even though we classify significantly more web-
sites. Compared to the results by Shusterman et al. [41], we achieve
similar classification rates. At the same time, we relax the attacker
model by not only compensating imprecise timing sources but also
random cache replacement policies. For application detection, the
success rate of our approach is, to the best of our knowledge, the
highest one in literature.
Comparison with Shusterman et al. [41]. Shusterman et al. pre-
sent a similar inference attack than the one proposed in this work.
The LLC profiling is based on traces of cache activity (called memo-
rygrams) that are obtained from repeatedly accessing a buffer as
large as the LLC. The time to access the entire buffer then relates to
the activity in the LLC, which is used to infer websites. In contrast,
we build eviction sets to profile individual parts of the LLC. This pro-
vides a more fine-grained view on the cache activity. Shusterman
et al. profile the LLC for 30 seconds, while our profiling phase is
only 1.5 seconds. The authors further choose their CNN parameters
based on the success rate, while we select the parameters based on
validation loss. Using the validation loss makes the trained model
more robust, as success rates increase with over-fitting. This leads
to differences in the parameter selection, in particular regarding the
number of convolution layers, the kernel size, and the pooling size.
While Shusterman et al. use 3 convolution layers, a varying kernel
size for each layer, and a pooling size of 4, we train our model with
2 convolution layers, a constant kernel size per layer, and a pooling
size of 2. Furthermore, we incorporate the CNN design guidelines
by Prouff et al. [38] (see Section 6.3). In summary, both Shuster-
man et al. and this work propose inference attacks that share a
10
Session 3B: Learning and AuthenticationAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand223common goal, but differ regarding approach and attack environ-
ment. Shusterman et al. launch their attack from JavaScript on Intel
CPUs, while we conduct our attack on Android and ARM. Yet, the
achieved classification rates for Google Chrome are comparable
for both environments. We believe this emphasizes that inference
attacks of this kind are a practical, cross-platform threat.
6.2 Cache Attacks on ARM
Most cache attacks known today either use dedicated flush instruc-
tions [16, 18, 49] or targeted thrashing of cache sets [9, 17, 24, 45] to
observe cache activity. While many techniques have been proposed
for x86 processors, Lipp et al. [29] demonstrated the feasibility of
attacks also on ARM processors, which complicate attacks with
random replacement policies, exclusive and non-inclusive cache
hierarchies, and internal line locking mechanisms [12]. In this work,
we show that despite these challenges, simple LLC observations
are sufficient to infer user activity on ARM-based mobile devices.
Unlike previous work, we pair these simple observations with ad-
vanced machine learning techniques and thereby alleviate attack
difficulties on ARM processors.
Comparison with Lipp et al. [29]. Lipp et al. perform multiple
cache attacks on ARM devices, including Prime+Probe [45], the
attack technique employed in this work. For this reason, we com-
pare the Prime+Probe technique by Lipp et al. to ours. In particular,
we set up an experiment, in which we try to classify the first 20
websites from Table 4 in Appendix A. We obtain the Prime+Probe
code from the GitHub repository [30] by Lipp et al. and run the
eviction strategy evaluator on the ARM Cortex-A57. The strategy
22-1-6 yields the highest eviction rate of 98%. The code by Lipp
et al. uses pagemap entries to find eviction sets (thus requiring
root privileges), while we employ algorithms 1 and 2 that work
without elevated privileges. The profiling phase for the website
classification is 1.5 seconds. We collect 800 LLC profiles for each
website, and use 90% as training data and the rest as test data. We
then derive the ordered and FFT feature vectors, as described in
Section 3.3. We omit the unordered feature vector, as it yielded
lower accuracies than the other ones throughout our experiments.
While the approach by Lipp et al. achieves classification rates of
90% and 85% (ordered and FFT), our approach yields 93% and 94%.
Thus, our profiling technique achieves higher classification rates
while requiring no root privileges to find eviction sets.
6.3 Machine Learning and SCAs
Side-channel attacks (SCAs) typically rely on signal processing
and statistics to infer information from observations. Since 2011,
advanced machine learning approaches were introduced to side-
channel literature. Lerman et al. [28] use random forests (RFs),
SVMs, and self-organizing maps (SOMs) to compare the effective-
ness of machine learning techniques against template attacks. Later,
Gulmezoglu et al. [19] showed that SVM-based approaches can be
used to extract features from FFT components obtained from cache
traces. Martinasek et al. [33, 34] showed that basic neural network
techniques can recover AES keys with a 96% success rate. With the
increasing popularity of deep learning, corresponding techniques
were also studied for SCAs. In 2016, Maghrebi et al. [32] compared
four deep learning techniques with template attacks while attack-
ing an unprotected AES implementation using power consumption.
11
In 2017, Schuster et al. [39] showed that encrypted streams can be
used to classify videos with CNNs. Gulmezoglu et al. [20] used hard-
ware performance events to classify websites visited on a personal
computer using SVM and CNN.
Comparison with Prouff et al. [38]. It is important to follow a
systematic approach when choosing parameters of CNNs. Prouff
et al. studied the parameter selection of MLP and CNN in the con-
text of side-channel attacks. There are in total 4 rules to follow
according to their work. The first one states that consecutive con-
volution layers should have the same parameters. The second rule
is that pooling layers should have a dimension of 2. The third rule
is that the number of filters in a convolution layer should be higher
than the one of the previous layer. The fourth rule states that all
convolution layers should have the same kernel size. While we
implement rules 1, 2 and 4, rule number 3 does not apply to our
experiments. Instead, the number of filters decreases for each con-
volution layer. In addition, we do not exhaustively explore batch
sizes and optimization methods, since they do not significantly
affect the validation loss in our case.
7 CONCLUSION
Inference attacks undermine our privacy by revealing our most
secret interests, preferences, and attitudes. Unfortunately, modern
processors, which constitute the core of our digital infrastructure,
are particularly vulnerable to these attacks. Footprints in the pro-
cessor cache allow the inference of running applications, visited
websites, and streaming videos. Above all, the advances in machine
learning, especially the concepts behind deep learning, significantly
lower the bar of successfully implementing inference attacks. Our
work demonstrates that it is possible to execute an inference attack
without privileges, permissions, or access to special programming
interfaces and peripherals. The simple nature of the attack code
makes a comprehensive defense extremely difficult. This simplicity
is paired with the careful application of deep learning. Interferences
such as measurement noise, misalignment, or unfavorable processor
features are thereby conveniently compensated. The comparison
with concurrent work furthermore indicates that inference attacks
of this kind are ubiquitous and succeed across runtime environ-
ments and processing hardware. For applications that value the
privacy of their users, protection against inference attacks is there-
fore of utmost importance. A comprehensive solution, however,
seems to require a closer collaboration between hardware manu-
facturers, operating system designers, and application developers.
ACKNOWLEDGMENTS
We would like to thank our shepherd Martina Lindorfer as well as
the anonymous reviewers for their valuable feedback. This work is
supported by the National Science Foundation, under grants CNS-
1618837 and CNS-1814406. Berk Gulmezoglu is also supported by
the WPI PhD Global Research Award 2017.
REFERENCES
[1] Martín Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey
Dean, Matthieu Devin, Sanjay Ghemawat, Geoffrey Irving, Michael Isard, Manju-
nath Kudlur, Josh Levenberg, Rajat Monga, Sherry Moore, Derek Gordon Murray,
Benoit Steiner, Paul A. Tucker, Vijay Vasudevan, Pete Warden, Martin Wicke,
Yuan Yu, and Xiaoqiang Zheng. 2016. TensorFlow: A System for Large-Scale
Machine Learning. In 12th USENIX Symposium on Operating Systems Design and
Implementation, OSDI 2016, Savannah, GA, USA, November 2-4, 2016. 265–283.
Session 3B: Learning and AuthenticationAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand224[2] Alexa Internet Inc. 2018. The top 500 sites on the web. http://www.alexa.com/
topsites. Last accessed 2018-01-01.
[3] Android Open Source Project. 2008. Bionic Initial Contribution. https://android.
googlesource.com/platform/bionic/+/a27d2baa. Last accessed 2019-01-21.
[4] Erik Bosman, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2016. Dedup
Est Machina: Memory Deduplication as an Advanced Exploitation Vector. In IEEE
Symposium on Security and Privacy, San Jose, USA, May 22-26, 2016. 987–1004.
[5] Chih-Chung Chang and Chih-Jen Lin. 2011. LIBSVM: A library for support vector
machines. ACM TIST 2, 3 (2011), 27:1–27:27.
[6] Wenrui Diao, Xiangyu Liu, Zhou Li, and Kehuan Zhang. 2016. No Pardon for
the Interruption: New Inference Attacks on Android Through Interrupt Timing
Analysis. In IEEE Symposium on Security and Privacy, San Jose, USA, May 22-26,
2016. 414–432.
[7] Chollet F. et al. 2018. Keras. https://keras.io. Last accessed 2019-01-21.
[8] Qian Ge, Yuval Yarom, David Cock, and Gernot Heiser. 2018. A survey of mi-
croarchitectural timing attacks and countermeasures on contemporary hardware.
J. Cryptographic Engineering 8, 1 (2018), 1–27.
[9] Daniel Genkin, Lev Pachmanov, Eran Tromer, and Yuval Yarom. 2018. Drive-By
Key-Extraction Cache Attacks from Portable Code. In Applied Cryptography and
Network Security - ACNS 2018, Proceedings. 83–102.
[10] Michael Misiu Godfrey and Mohammad Zulkernine. 2013. A Server-Side Solution
to Cache-Based Side-Channel Attacks in the Cloud. In 2013 IEEE Sixth Interna-
tional Conference on Cloud Computing, Santa Clara, CA, USA, June 28 - July 3,
2013. IEEE Computer Society, 163–170.
[11] Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. 2014. Explaining and
harnessing adversarial examples. arXiv preprint arXiv:1412.6572 (2014).
[12] Marc Green, Leandro Rodrigues Lima, Andreas Zankl, Gorka Irazoqui, Johann
Heyszl, and Thomas Eisenbarth. 2017. AutoLock: Why Cache Attacks on ARM
Are Harder Than You Think. In 26th USENIX Security Symposium, Vancouver, BC,
Canada, August 16-18, 2017. 1075–1091.
[13] Daniel Gruss, David Bidner, and Stefan Mangard. 2015. Practical Memory Dedu-
plication Attacks in Sandboxed Javascript. In ESORICS 2015 - Proceedings Part
I, Vienna, Austria, September 21-25, 2015 (Lecture Notes in Computer Science),
Vol. 9326. Springer, 108–122.
[14] Daniel Gruss, Clémentine Maurice, Anders Fogh, Moritz Lipp, and Stefan Man-
gard. 2016. Prefetch Side-Channel Attacks: Bypassing SMAP and Kernel ASLR.
In Proceedings of ACM SIGSAC CCS 2016, Vienna, Austria, October 24-28, 2016.
368–379.
[15] Daniel Gruss, Clémentine Maurice, and Stefan Mangard. 2016. Rowhammer.js: A
Remote Software-Induced Fault Attack in JavaScript. In Detection of Intrusions
and Malware, and Vulnerability Assessment - DIMVA 2016. Springer, 300–321.
[16] Daniel Gruss, Clémentine Maurice, Klaus Wagner, and Stefan Mangard. 2016.
Flush+Flush: A Fast and Stealthy Cache Attack. In Detection of Intrusions and
Malware, and Vulnerability Assessment - DIMVA 2016. Springer, 279–299.
[17] Daniel Gruss, Raphael Spreitzer, and Stefan Mangard. 2015. Cache Template
Attacks: Automating Attacks on Inclusive Last-Level Caches. In 24th USENIX
Security Symposium, Washington, D.C., USA, August 12-14, 2015. 897–912.
[18] David Gullasch, Endre Bangerter, and Stephan Krenn. 2011. Cache Games -
Bringing Access-Based Cache Attacks on AES to Practice. In 32nd IEEE Symposium
on Security and Privacy, 22-25 May 2011, Berkeley, California, USA. 490–505.
[19] Berk Gülmezoglu, Thomas Eisenbarth, and Berk Sunar. 2017. Cache-Based
Application Detection in the Cloud Using Machine Learning. In AsiaCCS 2017,
Abu Dhabi, United Arab Emirates, April 2-6, 2017. 288–300.
[20] Berk Gülmezoglu, Andreas Zankl, Thomas Eisenbarth, and Berk Sunar. 2017.