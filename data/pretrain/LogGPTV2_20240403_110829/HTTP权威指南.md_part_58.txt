HTTP/1.1 200 OK
Content-type: image/gif
Content-encoding: gzip
[...]
gunzip gzip
响应报文
...011010011... ...011010011...
服务器使用gzip对图像进行压缩，以便在它和客户端
之间的狭窄网络连接上传送一个较小的文件。这样可
以节约网络带宽和客户端等待传送的时间。不过，客
户端在收到图像之后，还需要花费时间进行解压缩。
353
图15-4 展示了HTTP事务中的Accept-Encoding首部
Accept-Encoding字段包含用逗号分隔的支持编码的列表，下面是一些例子：
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
客户端可以给每种编码附带Q（质量）值参数来说明编码的优先级。Q值的范围从
0.0到1.0，0.0说明客户端不想接受所说明的编码，1.0则表明最希望使用的编码。
“*”表示“任何其他方法”。决定在响应中回送什么内容给客户端是个更通用的过
程，而选择使用何种内容编码则是此过程的一部分。第17章将详细讨论这个过程，
以及Content-Encoding首部和Accept-Encoding首部。
identity编码代号只能在Accept-Encoding首部中出现，客户端用它来说明相
对于其他内容编码算法的优先级。
370 ｜ 第15章
15.6 传输编码和分块编码
前一节讨论的内容编码，是对报文的主体进行的可逆变换。内容编码是和内容的具
体格式细节紧密相关的。例如，你可能会用gzip压缩文本文件，但不是JPEG文
件，因为JPEG这类东西用gzip压缩的不够好。
本节讨论传输编码。传输编码也是作用在实体主体上的可逆变换，但使用它们是由
于架构方面的原因，同内容的格式无关。如图15-5所示，使用传输编码是为了改变
报文中的数据在网络上传输的方式。
经过内容编码的响应
HTTP/1.0 200 OK
Content-encoding: gzip 标准的首部块
Content-type: text/html
[...]
标准的实体（只
[encoded message]
是经过了编码） 经过内容编码的报文，只是对报文的实
体部分进行了编码。而对于经过传输编
码的报文来说，编码作用在整个报文上，
经过传输编码的响应
报文自身的结构发生了改变。
HTTP/1.1 200 OK
基本的首部
Transfer-encoding: chunked
10
经过编码的块
abcdefghijk
1
a
图15-5 内容编码和传输编码的对比
15.6.1 可靠传输
长久以来，在其他一些协议中会用传输编码来保证报文经过网络时能得到“可靠传
输”。在HTTP协议中，可靠传输关注的焦点有所不同，因为底层的传输设施已经标
准化并且容错性更好。在HTTP中，只有少数一些情况下，所传输的报文主体可能
会引发问题。其中两种情况如下所述。
• 未知的尺寸
如果不先生成内容，某些网关应用程序和内容编码器就无法确定报文主体的最终
大小。通常，这些服务器希望在知道大小之前就开始传输数据。因为HTTP协议 354
要求Content-Length首部必须在数据之前，有些服务器就使用传输编码来发
实体和编码 ｜ 371
送数据，并用特别的结束脚注表明数据结束。7
• 安全性
你可以用传输编码来把报文内容扰乱，然后在共享的传输网络上发送。不过，由
于像SSL这样的传输层安全体系的流行，就很少需要靠传输编码来实现安全性了。
15.6.2 Transfer-Encoding首部
HTTP协议中只定义了下面两个首部来描述和控制传输编码。
• Transfer-Encoding
告知接收方为了可靠地传输报文，已经对其进行了何种编码。
• TE
355 用在请求首部中，告知服务器可以使用哪些传输编码扩展。8
下面的例子中，请求使用了TE首部来告诉服务器它可以接受分块编码（如果是
HTTP/1.1应用程序的话，这就是必须的）并且愿意接受附在分块编码的报文结尾上
的拖挂：
GET /new_products.html HTTP/1.1
Host: www.joes-hardware.com
User-Agent: Mozilla/4.61 [en] (WinNT; I)
TE: trailers, chunked
...
对它的响应中包含Transfer-Encoding首部，用于告诉接收方已经用分块编码对
报文进行了传输编码：
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Server: Apache/3.0
...
在这个起始首部之后，报文的结构就将发生改变。
传输编码的值都是大小写无关的。HTTP/1.1规定在TE首部和Transfer-Encoding
首部中使用传输编码值。最新的HTTP规范只定义了一种传输编码，就是分块编码。
与Accept-Encoding首部类似，TE首部也可以使用Q值来说明传输编码的优先顺
序。不过，HTTP/1.1规范中禁止将分块编码关联的Q值设为0.0。
注7：尽管可以因陋就简地用关闭连接作为报文结束的信号，但这种方法不能用于持久连接。
注8：如果这个首部起名叫Accept-Transfer-Encoding，它的意义就会更直白。
372 ｜ 第15章
HTTP将来的扩展可能会推动对更多传输编码的需求。如果真的如此，那分块编码
仍应始终作用在其他传输编码之上，这样就保证数据可以像隧道那样“穿透”那些
只理解分块编码但不理解其他传输编码的HTTP/1.1应用程序。
15.6.3 分块编码
分块编码把报文分割为若干个大小已知的块。块之间是紧挨着发送的，这样就不需
要在发送之前知道整个报文的大小了。
要注意的是，分块编码是一种传输编码，因此是报文的属性，而不是主体的属
性。本章前面部分讨论过的多部分编码，就是主体的属性，它和分块编码是完全
独立的。
1. 分块与持久连接
若客户端和服务器之间不是持久连接，客户端就不需要知道它正在读取的主体的长
度，而只需要读到服务器关闭主体连接为止。 356
当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-
Length首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体
的长度。
分块编码为这种困难提供了解决方案，只要允许服务器把主体逐块发送，说明每块
的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大
小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为0的块
作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备。
分块编码是相当简单的。图15-6展示了一个分块编码报文的基本结构。它由起始的
HTTP响应首部块开始，随后就是一系列分块。每个分块包含一个长度值和该分块
的数据。长度值是十六进制形式并将CRLF与数据分隔开。分块中数据的大小以字
节计算，不包括长度值与数据之间的CRLF序列以及分块结尾的CRLF序列。最后
一个块有点特别，它的长度值为0，表示“主体结束”。
客户端也可以发送分块的数据给服务器。因为客户端事先不知道服务器是否接受分
块编码（这是因为服务器不会在给客户端的响应中发送TE首部），所以客户端必须
做好服务器用411 Length Required（需要Content-Length首部）响应来拒绝分块
请求的准备。
实体和编码 ｜ 373
HTTP/1.1 200 OK
响应流 Content-type: text/plain
Transfer-encoding: chunked
HTTP响应 Trailer: Content-MD5
十六进制表示的分块大小（十六进制的27 39个字符）
第1块
27
We hold these truths to be self-evident
第2块 26
, that all men are created equal, that
84
第3块 they are endowed by their Creator with certain
unalienable Rights, that among these are Life,
Liberty and the pursuit of Happiness.
0
最后一块
Content-MD5:gjqei54p26tjisgj3p4utjgrj53
拖挂* *可选——仅当报文首部中有Trailer首部时才出现
357 图15-6 剖析分块编码报文
2. 分块报文的拖挂
如果客户端的TE首部中说明它可以接受拖挂的话，就可以在分块的报文最后加上拖
挂。产生原始响应的服务器也可以在分块的报文最后加上拖挂。拖挂的内容是可选的
元数据，客户端不一定需要理解和使用（客户端可以忽略并丢弃拖挂中的内容）。9
拖挂中可以包含附带的首部字段，它们的值在报文开始的时候可能是无法确定的
（例如，必须要先生成主体的内容）。Content-MD5首部就是一个可以在拖挂中发送
的首部，因为在文档生成之前，很难算出它的MD5。图15-6中展示了拖挂的使用
方式。报文首部中包含一个Trailer首部，列出了跟在分块报文之后的首部列表。
在Trailer首部中列出的首部就紧接在最后一个分块之后。
除了Transfer-Encoding、Trailer以及Content-Length首部之外，其他HTTP
首部都可以作为拖挂发送。
注9： trailer（拖挂）首部是在最初的分块编码被加入到HTTP/1.1规范的草案之后才加入的，因此有些
应用程序可能不理解这个首部（或者不理解拖挂），尽管它们声称是兼容HTTP/1.1的。
374 ｜ 第15章
15.6.4 内容编码与传输编码的结合
内容编码与传输编码可以同时使用。例如，图15-7中展示了发送方如何用内容编码
压缩HTML文件，再使用传输编码分块发送。接收方“重构”主体的过程和发送方
相反。
Content-type: text/html
内容编码
Content-type: text/html 9BF2578E 9BF2578E
Content-encoding: gzip A42670CD A42670CD
传输编码（分块）
426 9BF
Content-type: text/html
8EA 257
Content-encoding: gzip
Transfer-encoding: chunked 257 8EA
9BF 426
图15-7 内容编码和传输编码结合
15.6.5 传输编码的规则
对报文主体使用传输编码时，必须遵守以下规则。
• 传输编码集合中必须包括“分块”。唯一的例外是使用关闭连接来结束报文。
• 当使用分块传输编码时，它必须是最后一个作用到报文主体之上的。
• 分块传输编码不能多次作用到一个报文主体上。 358
这些规则使得接收方能够确定报文的传输长度。
传输编码是HTTP 1.1版中引入的一个相对较新的特性。实现传输编码的服务器必
须特别注意不要把经传输编码后的报文发送给非HTTP/1.1的应用程序。同样地，
如果服务器收到无法理解的经过传输编码的报文，它应当用501 Unimplemented状
态码来回复。不过，所有的HTTP/1.1应用程序至少都必须支持分块编码。
15.7 随时间变化的实例
网站对象并不是静态的。同样的URL会随着时间变化而指向对象的不同版本。以
实体和编码 ｜ 375
CNN的主页为例，同一天里多次访问http://www.cnn.com，可能每次得到的返回页
面都会略有不同。
可以把CNN的主页当作一个对象来考虑，其不同版本就可以看作这个对象的不同
实例（参见图15-8）。在图中，客户端多次请求同一个资源（URL），但得到的是该
资源的不同实例，因为它是随时间而变化的。在时间（a）和时间（b）具有相同的
实例，而在时间（c）则是不同的实例。
V1 V1 V2 V2 V4
(a) (b) (c) (d) (e)
时间 2月17日下 3月3日上午 4月2日上 4月12日下
午4点30分 11点21分 午9点07分 午1点48分
版本1 版本2 版本3 版本4 www.cnn.com
图15-8 实例是资源在某个时间的“快照”
HTTP协议规定了称为实例操控（instance manipulations）的一系列请求和响应操
作，用以操控对象的实例。两个主要的实例操控方法是范围请求和差异编码。这两
种方法都要求客户端能够标识它所拥有（如果有的话）的资源的特定副本，并在一
359 定的条件下请求新的实例。本章后面将讨论这些机制。