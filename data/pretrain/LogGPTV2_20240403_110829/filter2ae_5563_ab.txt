    /etc/:系统配置文件
其中/var/和/etc/目录下会包含大量的有用信息，很多都是很明显的，如/etc/serverkey.pem。如图八所示。
 图八
/etc/serverkey.pem文件内容
在嵌入式设备中找到TLS通信的私钥是很正常的，通过攻击一个设备获取私钥，进而可以对其他相同型号的设备展开攻击。
这个私钥一方面用于与华为或ISP服务器通信，但是，更多的是用来获取公开证书，进而与远程服务器通信。在这里，我们找到了两个证书，都来自于“同一个人”的签名。
/etc/servercert.pem: 最有可能是服务器密钥 /etc/root.pem: 很有可能用于与华为或者ISP服务器通信(不确定。。。)
更多的敏感数据是在/etc/ppp256/config和/etc/ppp258/config文件中，如图九所示。
这些身份认证信息对于HTTP 接口也是有效的，这也是我在此处提出来的原因。当然对于其他的很多路由器设备不一定有效。
分析如此多的不同文件，如果没有好的工具将会是非常耗费时间的，所以，我们将会尽可能的复制这些数据到u盘中，进而在电脑上进行分析。
 图九
config文件内容
### 五、 信息收集
当收集了文件之后，我们可以使用find . –name *.pem查找是否还有其他的TLS证书。
运行`grep -i –r password`，查找所有文件中的password字段，得到如图十所示。
 图十
password在所有文件中的信息
这里有很多的证书信息，主要是为STUN，TR-069和本地服务提供。此处展示出来是因为这些信息都是通过http传输的，但通常是隐藏的。这些证书要不以明文要不以base64编码后保存，当然编码是不能保护数据的。如图十一所示的是当前wifi密码的base64值。
    $ echo "QUJCNFVCTU4=" | base64 -D
    ABB4UBMN
 图十一
当前wifi密码
在分析上述密码的过程中，得到了2个比较重要的文件。
/var/curcfg.xml: 当前配置文件，包括base64后的wifi密码等
/etc/defaultcfg.xml: 默认配置文件，用于恢复出厂设置，但不包括路由器的wifi密码，主要是因为第一次使用的时候需要配置密码信息。
### 六、 探索ATP的CLI
由于ATP的CLI包含了非常少的命令，其中重要的命令之一是debug。debug display
将会显示igmpproxy、cwmp、sysuptime或者atpversion的使用，大部分都没有什么用，不知道cwmp是不是与路由器的远程配置有关，如图十二所示。
 图十二
cwmp的命令信息
再次，这些CWMP(TR-069)证书是用于远程路由器配置的凭据，这次甚至没有编码，明文的保存在里面。
其他的ATP命令功能很有限，如清屏、帮助，保存到flash中或退出等。
### 七、 探索Uboot的CLI
Bootloader的命令行接口提供了访问部分内存区域，但是，它没有提供直接访问flash芯片功能，如下所示：
    Please choose operation:
       3: Boot system code via Flash (default).
       4: Entr boot command line interface.
    You choosed 4
    Stopped Uboot WatchDog Timer.
    4: System Enter Boot Command Line Interface.
    U-Boot 1.1.3 (Aug 29 2013 - 11:16:19)
    RT3352 # help
    ?       - alias for 'help'
    bootm   - boot application image from memory
    cp      - memory copy
    erase   - erase SPI FLASH memory
    go      - start application at address 'addr'
    help    - print online help
    md      - memory display
    mdio   - Ralink PHY register R/W command !!
    mm      - memory modify (auto-incrementing)
    mw      - memory write (fill)
    nm      - memory modify (constant address)
    printenv- print environment variables
    reset   - Perform RESET of the CPU
    rf      - read/write rf register
    saveenv - save environment variables to persistent storage
    setenv  - set environment variables
    uip - uip command
    version - print monitor version
    RT3352 #
不要轻易的去使用erase、mm、mw或者nm命令，除非真的需要使用这些命令，错误的使用将会重启设备，然后设备变砖。此时，内存显示md和printenv引起了我的注意。
    RT3352 # printenv
    bootcmd=tftp
    bootdelay=2
    baudrate=57600
    ethaddr="00:AA:BB:CC:DD:10"
    ipaddr=192.168.1.1
    serverip=192.168.1.2
    ramargs=setenv bootargs root=/dev/ram rw
    addip=setenv bootargs $(bootargs) ip=$(ipaddr):$(serverip):$(gatewayip):$(netmask):$(hostname):$(netdev):off
    addmisc=setenv bootargs $(bootargs) console=ttyS0,$(baudrate) ethaddr=$(ethaddr) panic=1
    flash_self=run ramargs addip addmisc;bootm $(kernel_addr) $(ramdisk_addr)
    kernel_addr=BFC40000
    u-boot=u-boot.bin
    load=tftp 8A100000 $(u-boot)
    u_b=protect off 1:0-1;era 1:0-1;cp.b 8A100000 BC400000 $(filesize)
    loadfs=tftp 8A100000 root.cramfs
    u_fs=era bc540000 bc83ffff;cp.b 8A100000 BC540000 $(filesize)
    test_tftp=tftp 8A100000 root.cramfs;run test_tftp
    stdin=serial
    stdout=serial
    stderr=serial
    ethact=Eth0 (10/100-M)
    Environment size: 765/4092 bytes
我们可以看到类似设置UART串口波特率，以及一些有意思的内存位置。这些内存地址不是flash
IC地址空间的，flash的地址空间是0x00000000—0x00FFFFFF。
让我们利用md看看其中的部分内存，如kernel_addr=0xBFC40000，如图十三所示。
 图十三
BFC40000内存数据
其中的badd信息表示此处为无效地址，当用md访问无效的内存地址时，将会返回硬编码的badd提示内存地址无效。这些地址是好的地址，但是在u-boot阶段是不可访问的。
需要注意的是，通过启动uboot命令行接口将会导致路由器停止加载Linux内核到内存中，所以对内存的访问将是非常有限的子集。其中有效的地址空间如图十四所示。
 图十四
有限的可访问内存空间数据举例
这种方法查找内存非常受限，仅能够查看有限区域的数据，但是可以用这种方法来分析内存的存储结构，如在0x000d0000位置的内存内容明显变化，如图十五所示。
 图十五
0x000d0000位置的内存明显变化
最后附上实验的视频教程： http://static.video.qq.com/TPout.swf?vid=w01991tmnia&auto=0
* * *