当一个系统在部分节点发生故障、不遵守协议、甚至恶意攻击、扰乱网路时仍然能继续正确工作，称之为 **拜占庭容错（Byzantine fault-tolerant）** 的，这种担忧在某些特定情况下是有意义的：
* 在航空航天环境中，计算机记忆体或 CPU 暂存器中的资料可能被辐射破坏，导致其以任意不可预知的方式响应其他节点。由于系统故障非常昂贵（例如，飞机撞毁和炸死船上所有人员，或火箭与国际空间站相撞），飞行控制系统必须容忍拜占庭故障【81,82】。
* 在多个参与组织的系统中，一些参与者可能会试图欺骗或诈骗他人。在这种情况下，节点仅仅信任另一个节点的讯息是不安全的，因为它们可能是出于恶意的目的而被传送的。例如，像比特币和其他区块链一样的对等网路可以被认为是让互不信任的各方同意交易是否发生的一种方式，而不依赖于中心机构（central authority）【83】。
然而，在本书讨论的那些系统中，我们通常可以安全地假设没有拜占庭式的错误。在你的资料中心里，所有的节点都是由你的组织控制的（所以他们可以信任），辐射水平足够低，记忆体损坏不是一个大问题。制作拜占庭容错系统的协议相当复杂【84】，而容错嵌入式系统依赖于硬体层面的支援【81】。在大多数伺服器端资料系统中，部署拜占庭容错解决方案的成本使其变得不切实际。
Web 应用程式确实需要预期受终端使用者控制的客户端（如 Web 浏览器）的任意和恶意行为。这就是为什么输入验证，资料清洗和输出转义如此重要：例如，防止 SQL 注入和跨站点指令码。然而，我们通常不在这里使用拜占庭容错协议，而只是让伺服器有权决定是否允许客户端行为。但在没有这种中心机构的对等网路中，拜占庭容错更为重要。
软体中的一个错误（bug）可能被认为是拜占庭式的错误，但是如果你将相同的软体部署到所有节点上，那么拜占庭式的容错演算法帮不到你。大多数拜占庭式容错演算法要求超过三分之二的节点能够正常工作（即，如果有四个节点，最多只能有一个故障）。要使用这种方法对付 bug，你必须有四个独立的相同软体的实现，并希望一个 bug 只出现在四个实现之一中。
同样，如果一个协议可以保护我们免受漏洞，安全渗透和恶意攻击，那么这将是有吸引力的。不幸的是，这也是不现实的：在大多数系统中，如果攻击者可以渗透一个节点，那他们可能会渗透所有这些节点，因为它们可能都执行著相同的软体。因此，传统机制（认证，访问控制，加密，防火墙等）仍然是抵御攻击者的主要保护措施。
#### 弱谎言形式
尽管我们假设节点通常是诚实的，但值得向软体中新增防止 “撒谎” 弱形式的机制 —— 例如，由硬体问题导致的无效讯息，软体错误和错误配置。这种保护机制并不是完全的拜占庭容错，因为它们不能抵挡决心坚定的对手，但它们仍然是简单而实用的步骤，以提高可靠性。例如：
* 由于硬体问题或作业系统、驱动程式、路由器等中的错误，网路资料包有时会受到损坏。通常，损坏的资料包会被内建于 TCP 和 UDP 中的校验和所俘获，但有时它们也会逃脱检测【85,86,87】 。要对付这种破坏通常使用简单的方法就可以做到，例如应用程式级协议中的校验和。
* 可公开访问的应用程式必须仔细清理来自使用者的任何输入，例如检查值是否在合理的范围内，并限制字串的大小以防止透过大记忆体分配的拒绝服务。防火墙后面的内部服务对于输入也许可以只采取一些不那么严格的检查，但是采取一些基本的合理性检查（例如，在协议解析中）仍然是一个好主意。
* NTP 客户端可以配置多个伺服器地址。同步时，客户端联络所有的伺服器，估计它们的误差，并检查大多数伺服器是否对某个时间范围达成一致。只要大多数的伺服器没问题，一个配置错误的 NTP 伺服器报告的时间会被当成特异值从同步中排除【37】。使用多个伺服器使 NTP 更健壮（比起只用单个伺服器来）。
### 系统模型与现实
已经有很多演算法被设计以解决分散式系统问题 —— 例如，我们将在 [第九章](ch9.md) 讨论共识问题的解决方案。为了有用，这些演算法需要容忍我们在本章中讨论的分散式系统的各种故障。
演算法的编写方式不应该过分依赖于执行的硬体和软体配置的细节。这就要求我们以某种方式将我们期望在系统中发生的错误形式化。我们透过定义一个系统模型来做到这一点，这个模型是一个抽象，描述一个演算法可以假设的事情。
关于时序假设，三种系统模型是常用的：
* 同步模型
  **同步模型（synchronous model）** 假设网路延迟、程序暂停和和时钟误差都是受限的。这并不意味著完全同步的时钟或零网路延迟；这只意味著你知道网路延迟、暂停和时钟漂移将永远不会超过某个固定的上限【88】。同步模型并不是大多数实际系统的现实模型，因为（如本章所讨论的）无限延迟和暂停确实会发生。
* 部分同步模型
  **部分同步（partial synchronous）** 意味著一个系统在大多数情况下像一个同步系统一样执行，但有时候会超出网路延迟，程序暂停和时钟漂移的界限【88】。这是很多系统的现实模型：大多数情况下，网路和程序表现良好，否则我们永远无法完成任何事情，但是我们必须承认，在任何时刻都存在时序假设偶然被破坏的事实。发生这种情况时，网路延迟、暂停和时钟错误可能会变得相当大。
* 非同步模型
  在这个模型中，一个演算法不允许对时序做任何假设 —— 事实上它甚至没有时钟（所以它不能使用超时）。一些演算法被设计为可用于非同步模型，但非常受限。
进一步来说，除了时序问题，我们还要考虑 **节点失效**。三种最常见的节点系统模型是：
* 崩溃 - 停止故障
  在 **崩溃停止（crash-stop）** 模型中，演算法可能会假设一个节点只能以一种方式失效，即透过崩溃。这意味著节点可能在任意时刻突然停止响应，此后该节点永远消失 —— 它永远不会回来。
* 崩溃 - 恢复故障
  我们假设节点可能会在任何时候崩溃，但也许会在未知的时间之后再次开始响应。在 **崩溃 - 恢复（crash-recovery）** 模型中，假设节点具有稳定的储存（即，非易失性磁碟储存）且会在崩溃中保留，而记忆体中的状态会丢失。
* 拜占庭（任意）故障
  节点可以做（绝对意义上的）任何事情，包括试图戏弄和欺骗其他节点，如上一节所述。
对于真实系统的建模，具有 **崩溃 - 恢复故障（crash-recovery）** 的 **部分同步模型（partial synchronous）** 通常是最有用的模型。分散式演算法如何应对这种模型？