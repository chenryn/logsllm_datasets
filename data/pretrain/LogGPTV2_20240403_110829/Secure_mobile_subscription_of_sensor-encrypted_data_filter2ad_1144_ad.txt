l
z=1;z̸=j′ ez and thus
)ej′ Ej′ F 2
∏
)Ej′ F 2
′
′
can employ the common modulus attack to com-
pute x mod N , and then provide (x, ej′ ) as a solu-
tion to the given instance of the strong QR-RSA
problem.
Challenge. Once A decides that Query Phase 1 is over, he
, B
selects (^i, ^j) that he targets.
aborts. Otherwise, B responds with a random value in
K.
or ^j ̸= j
If ^i ̸= i
′
′
Query Phase 2. B responds to the queries as in Query
Phase 1.
Guess. A outputs a guess b
′
for b. B terminates.
A’s guess is \ignored". However, for A to do any thing
\useful", A should have issued sf (^i)F 2E^j mod N (i.e., the
\special" w) to the random oracle to get the correct k^i;^j,
which helps the computation of x and e^j.
If A has
non-negligible advantage ε to break our scheme, B can solve
(n−t)l , which
the strong QR-RSA problem with probability
is also non-negligible.
The simulation succeeds when (^i, ^j) = (i
, j
).
′
′
"
6. FEASIBILITY EVALUATION
There are three kinds of entities involved in our time-
based key management scheme, namely, the sensor nodes
(performing NodeKeyDer), the mobile users (performing
UserKeyDer), and the control center (performing Setup,
NodeKeyGen, and UserKeyGen). The control center
is probably a more powerful server, and the knowledge of
factorization of N = pq can signi(cid:12)cantly accelerate its op-
erations like computing ki;∗ = sf (i)F 2
mod N by exploiting
the Chinese remainder theorem. A mobile user is usually
234
equipped with a device like a PDA or a smart phone. While
de(cid:12)nitely weaker than a server, the user key derivation is
not an expensive operation for them. The sensor node is
the one with really limited computing power. In this sec-
tion, we evaluate the processing cost of deriving a session
key ki;j = H(kEj
i;∗ mod N ) by a node i at time period j.
Note that the computation or storage cost for a sensor node
is mainly a(cid:11)ected by l, which indicates that our scheme is
applicable to a very large WSN.
6.1 Case Study Settings
∏
We assume an adversary may corrupt up to 100 out of
2000 sensor nodes, and there are a total of 4096 time pe-
riods allocated by the control center for user subscription.
That is, we set n = 2000, t = 100, and l = 4096 as a case
study. Having l = 4096 is large enough for most real-life
applications. For examples, if each period corresponds to
one hour, l = 4096 corresponds to nearly half a year;
if
each period corresponds to one day, l = 4096 corresponds
to more than 11 years. We take the safe RSA modulus to
be |N| = 1024 bits in length, which is the recommended
security level nowadays.
Since H(·) is a one-way hash function (usually cost-e(cid:14)cient),
the major workload for computing ki;j = H(kEj
i;∗ mod N )
l
z=1;z̸=j ez
may consist of computing the product Ej =
regarding 1 ≤ j ≤ l and then computing the (modular)
exponentiation kEj
i;∗ mod N . This may be computationally
expensive. However, we shall show that the computation
can be done in a more e(cid:14)cient \divide-and-conquer" man-
ner. Let us begin with how to obtain each ez in Ej.
6.2 Prime Enumeration
In our case study, a sensor node needs l = 4096 primes af-
ter n (e1, e2,··· , e4096) to derive the session keys. There are
303 primes within n = 2000 (i.e., 2, 3, 5,··· , 1997, 1999), and
thus a sensor node actually needs to know the (cid:12)rst l
= 4399
primes. To obtain all these l
primes, at (cid:12)rst glance a sensor
node may choose to employ the Sieve of Eratosthenes with
O((d log d)(log log d)) time complexity and O(d) space com-
plexity [21], where d is the total number of integers to sieve
′ ≈ d/ ln d according to the prime number theorem). Even
(l
though there is a segmented version of the Sieve of Eratos-
thenes with O(d) time complexity and O(
d log log d/ log d)
space complexity [1], this is still too expensive for a sensor
node when d (essentially, l
) becomes signi(cid:12)cantly large. So
it is unfavorable (if not impractical) for a sensor node to
enumerate the primes by itself.
As a result, we suggest to pre-load the enumeration of
the l primes after n (e1 = 2003, e2 = 2011,··· , e4096 =
42071) into each sensor node’s memory, speci(cid:12)cally, read
only memory (ROM). In other words, a sensor node only
needs to look up in a static table to immediately obtain any
of the l = 4096 primes. The storage for all the l = 4096
primes occupies 59738 bits = 7468 bytes (ignoring the small
encoding overhead), which is fairly acceptable for the current
∥
generation of sensor nodes
6.3 Computation/Storage Tradeoff
∥
For example, a MICAz node has 128K bytes of ROM but
only 4K bytes of RAM. Detailed datasheet of the product
is available for download at http://www.openautomation.
net/uploadsproductos/micaz_datasheet.pdf (12/28 ’10).
√
′
′
.
′
235
Figure 2: Sensor’s computation/storage tradeo(cid:11) for
l = 8. Each stripe (separated by the dashed lines)
suggests a possible approach to computing the de-
sired key by only using exponentiation with an ex-
ponent at most |el| bits.
We know that the product of all l = 4096 primes is of
length 57581 bits and e1, the (cid:12)rst prime greater than n =
2000, is 11-bit long. To compute kEj
i;∗ mod N for a certain
j, a sensor node needs to compute ki;∗ to the power of a
certain Ej of up to 57570 bits in length (when |ej| = 11).
It reminds us of potential implementation challenges at low-
cost, resource-constrained sensor nodes. We address this
problem by doing the exponentiations separately, and opti-
mize the performance with the help of a key-tree structure,
which trades storage for computation e(cid:14)ciency.
The tradeo(cid:11), depicted in Fig. 2 with l = 8 as a simple
∏
illustration, is to have each sensor node pre-loaded with, in
addition to the primes enumeration, certain pre-computed
z∈{1;··· ;l}\{a;··· ;b} ez mod
keys in the form of ki;a∼b = sf (i)F 2
N , so that a node can compute a session key for a speci(cid:12)c
time period more e(cid:14)ciently. When a node is additionally
pre-loaded with 2r pre-computed keys, it only needs to take
2r − 1)
one of these keys to the power of the product of ( l
ei’s. Assuming the sensor node’s processor can only perform
viable exponentiations where the exponent is of at most |el|
2r −
bits in length, the computation can be implemented as ( l
1) such viable exponentiations.
In our case study where l = 4096, we have the tradeo(cid:11)
graph as shown in Fig. 3. We can see that when r = 1, a
node has to store the keys of total length 21 × 1024/8 = 256
bytes. When r = 2, a node needs to store the keys of length
22 × 1024/8 = 512 bytes, and so on. For the computational
cost, we consider the heaviest case: a pre-loaded key to the
2r − 1) primes.
power of the product of the most lengthy ( l
For example, assuming that a sensor node is preloaded with
28 pre-computed keys (i.e., 2r|N|/8 = 256 × 1024/8 = 32K
bytes), it needs to compute a key to the power of a 231-
bit exponent. According to the recent evaluation on sensor
nodes [14], this kind of exponentiation can be done in one
minute even in software implementation (and less than one
seconds in hardware implementation). This seems to be a
reasonable balance for a sensor node. Similarly, one can
appropriately trade storage for computation according to d-
i(cid:11)erent application conditions. Furthermore, note that the
key-tree as illustrated in Fig. 2 can be reused by a node
i when computing ki;j’s for di(cid:11)erent j’s, and thus certain
intermediate results can be cached for better computation
e(cid:14)ciency. For example, caching ki;1∼2 when ki;1 is comput-
ed enables the computation of k1;2 in the next time period
Figure 3: The computation/storage tradeo(cid:11) for 4096 time periods
to be done in one small-exponent exponentiation.
[2] Y. Bakos and E. Brynjolfsson. Bundling information
Finally, we want to stress that while the storage size may
look logarithmic to the total number of time periods, it is
still independent of the total number of nodes, as we dis-
cussed in Section 2.2.
7. CONCLUSION
Economic research has demonstrated that a subscription-
based payo(cid:11) model is more pro(cid:12)table than a tra(cid:14)c-based
one for the service owner. We envision a business model for
data provision services in wireless sensor networks, where a
time-based access control is adopted to protect data con(cid:12)-
dentiality. As an instantiation of the access control mecha-
nism, we proposed SMS-SED, a secure (t, n)-threshold time-
based key management system for secure mobile subscrip-
tion of sensor-encrypted data. The primary feature of the
scheme lies in that the control center can delegate the data
access rights to mobile users with respect to their subscrip-
tion time periods. Our cryptographic construction achieves
provable security even if an adversary can capture up to t
sensor nodes and reveal the stored node keys. We show that
our system is practical for the current generation of wireless
sensor networks and a tradeo(cid:11) study for balancing between
the processing overhead and the storage cost of a sensor n-
ode. The high e(cid:14)ciency of our system is from the design
principles of making common cases fast and supporting a
right level of security.
8. ACKNOWLEDGMENTS
This work was supported by the Singapore A∗STAR project
SEDS-0721330047 and by the National Natural Science Foun-
dation of China under Grant 60970138.
9. REFERENCES
[1] A. O. L. Atkin and D. J. Bernstein. Prime sieves using
binary quadratic forms. Mathematics of Computation,
73(246):1023{1030, 2004.
goods: Pricing, pro(cid:12)ts, and e(cid:14)ciency. Management
Science, 45(12):1613{1630, 1999.
[3] N. Bari(cid:19)c and B. P(cid:12)tzmann. Collision-free
accumulators and fail-stop signature schemes without
trees. In Advances in Cryptology - EUROCRYPT’97,
volume 1233 of LNCS, pages 480{494, 1997.
[4] M. Bellare, P. Rogaway, and D. Wagner. The EAX
mode of operation. In Fast Software Encryption
(FSE’04), volume 3017 of LNCS, pages 389{407, 2004.
[5] J. Benaloh and M. de Mare. E(cid:14)cient broadcast
time-stamping. Technical Report TR-MCS-92-1,
Clarkson University Department of Mathematics and
Computer Science, April 1992.
[6] H. Chan, A. Perrig, and D. X. Song. Random key
predistribution schemes for sensor networks. In IEEE
Symposium on Security and Privacy (S&P’03), pages
197{213, 2003.
[7] H.-Y. Chien. E(cid:14)cient time-bound hierarchical key
assignment scheme. IEEE Transactions on Knowledge
and Data Engineering (TKDE), 16(10):1301{1304,
2004.
[8] S. S. M. Chow, M. H. Au, and W. Susilo. Server-aided
signatures veri(cid:12)cation secure against collusion attack.
In 6th ACM Symposium on Information, Computer
and Communications Security (AsiaCCS’11), 2011. To
appear.
[9] S. S. M. Chow, J. K. Liu, and J. Zhou. Identity-based
online/o(cid:15)ine key encapsulation and encryption. In 6th
ACM Symposium on Information, Computer and
Communications Security (AsiaCCS’11), 2011. To
appear.
[10] R. Cramer and V. Shoup. Signature schemes based on
the strong RSA assumption. In 6th ACM Conference
on Computer and Communications Security (CCS’99),
pages 46{51, 1999.
[11] W. Du, J. Deng, Y. S. Han, S. Chen, and P. K.
236
[26] X. Yi and Y. Ye. Security of Tzeng’s time-bound key
assignment scheme for access control in a hierarchy.
IEEE Transactions on Knowledge and Data
Engineering (TKDE), 15(4):1054{1055, 2003.
[27] W. T. Zhu, R. H. Deng, J. Zhou, and F. Bao.
Time-bound hierarchical key assignment: An
overview. IEICE Transactions on Information and
Systems, E93-D(5):1044{1052, 2010.
Varshney. A key management scheme for wireless
sensor networks using deployment knowledge. In IEEE
International Conference on Computer
Communications (INFOCOM’04), pages 597{607,
2004.
[12] W. Du, J. Deng, Y. S. Han, P. K. Varshney, J. Katz,
and A. Khalili. A pairwise key predistribution scheme
for wireless sensor networks. ACM Transactions on
Information and System Security (TISSEC),
8(2):228{258, May 2005.
[13] L. Eschenauer and V. D. Gligor. A key-management
scheme for distributed sensor networks. In 9th ACM
Conference on Computer and Communications
Security (CCS’02), pages 41{47, 2002.
[14] W. Hu, P. I. Corke, W. C. Shih, and L. Overs.
secFleck: A public key technology platform for
wireless sensor networks. In 6th European Conference
on Wireless Sensor Networks (EWSN’09), volume
5432 of LNCS, pages 296{311, 2009.
[15] D. Liu and P. Ning. Improving key predistribution
with deployment knowledge in static sensor networks.
ACM Transactions on Sensor Networks (TOSN),
1(2):204{239, Nov 2005.
[16] D. Liu, P. Ning, and R. Li. Establishing pairwise keys
in distributed sensor networks. ACM Transactions on
Information and System Security (TISSEC),
8(1):41{77, Feb 2005.
[17] D. Micciancio. The RSA group is pseudo-free. In
Advances in Cryptology - EUROCRYPT’05, volume
3494 of LNCS, pages 387{403, 2005.
[18] A. Mohaisen, D. Nyang, and K. Lee. Hierarchical
grid-based pairwise key pre-distribution in wireless
sensor networks. Intl. Journal of Network Security
(IJNSEC), 8(1):282{292, 2009.
[19] B. Parno, A. Perrig, and V. Gligor. Distributed
detection of node replication attacks in sensor
networks. In IEEE Symposium on Security and
Privacy (S&P’05), pages 49{63, 2005.
[20] R. Poovendran, C. Wang, and S. Roy, editors. Secure
Localization and Time Synchronization for Wireless
Sensor and Ad Hoc Networks. Advances in
Information Security. Springer, 2006.
[21] P. Pritchard. Linear prime-number sieves: A family
tree. Science of Computer Programming, 9(1):17{35,
1987.
[22] V. Shoup. Practical threshold signatures. In Advances
in Cryptology - EUROCRYPT’00, volume 1807 of
LNCS, pages 207{220, 2000.
[23] W.-G. Tzeng. A time-bound cryptographic key
assignment scheme for access control in a hierarchy.
IEEE Transactions on Knowledge and Data
Engineering (TKDE), 14(1):182{188, 2002.
[24] D. Yao, N. Fazio, Y. Dodis, and A. Lysyanskaya.
ID-based encryption for complex hierarchies with
applications to forward security and broadcast
encryption. In 11th ACM Conference on Computer
and Communications Security (CCS’04), pages
354{363, 2004.
[25] X. Yi. Security of Chien’s e(cid:14)cient time-bound
hierarchical key assignment scheme. IEEE
Transactions on Knowledge and Data Engineering
(TKDE), 17(9):1298{1299, 2005.
237