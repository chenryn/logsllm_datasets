N SAtypeC ≈
N SAtypeD ≈
sizeblock
sizealignment
+ sizesc
sizeblock
1
+
sizesc
sizeblock
sizealignment
sizesc
sizealignment
sizesc
sizealignment
sizesc
sizeblock
× (1 +
=
sizeblock
≈ sizesc
sizeblock
+ sizesc
1
sizealignment
)
From the formulas we can see that
• The N SA of Type A and B consists of two parts. The ﬁrst
term of the N SA is only relevant to alignment size, and the
second term is relevant to both shellcode size and block size.
The N SA of Type A and Type B increases when the align-
ment size or block size decrease, or when the shellcode size
increases.
• The N SA of Type C is only relevant to the size of shellcode
and memory block size. The N SA is proportional to the size
of shellcode, and is inversely proportional to the size of the
memory block size.
• The N SA of Type D is more complex, but it is clear that
the N SA is inversely proportional to the size of the mem-
ory block. We also found that the N SA of Type D is much
smaller than that of Type A and B.
There are three independent variables in these formulas and the
function graph is hard to plot. To draw the graph, we must ﬁx two
of them. We assume that the heap memory block size is 1M bytes
and the shellcode size is 256 bytes. Figure 5 shows the function
graphs. The X-axis indicates the alignment size in bytes and the
Y-axis indicates the normalized attack surface area (NSA). To sim-
plify the calculation, we assume all the size of all instructions is
one. Therefore, the surface area of practical samples may be two or
three times of the theoretical value. As is showed in Figure 5, the
normalized attack surface of all new heap objects is lower than the
threshold of NOZZLE (50%).
84k3264k1/81/321/4k1/64kXXXXOOOX - Type A,BO - Type C,DNSAAlignment size(byte)Figure 6: A sample structure of memory blocks with little surface area.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
function heapspray(){
var scstring = unescape("%u9090...");
var alignment_size = 0x10000;
var pre_len = 0x00000c0c;
var post_len = alignment_size - 0x00000c0c - 0x6;
var head_offset = 0x24;
var jmp_str = unescape("%uFBE9%u00FF%uCC00");
var type1_str = CreateCCstringwithsize(pre_len) + jmp_str + CreateCCstringwithsize(post_len);
var type2_str = CreateCCstringwithsize(pre_len) + scstring +
CreateCCstringwithsize(post_len + 0x6 - scstring.length * 2);
var type1_total_str = DuplicateStr(type1_str, 15);
type1_total_str = type1_total_str.substr(head_offset / 2,
type1_total_str.length - head_offset / 2);
// cut off the header bytes
var m = new Array();
for(i = 0; i < 200; i++)
m[i] = type1_total_str + type2_str;
}
Figure 7: Sample JavaScript spraying heap with Type A blocks.
4. EXPERIMENT AND EVALUATION
In this section, we describe our experiments of Heap Taichi,
which generated heap objects that can bypass existing detection
mechanisms. We also measure their normalized attack surface with
different alignment sizes in the experiments.
4.1 Case study: A sample JavaScript code cre-
ating Type A heap objects
In this section, we give a JavaScript example of spraying a browser’s
heap with our Type A heap objects. This attack can also be done in
other languages, including VBScript and ActionScript.
Figure 6 illustrates the structure used in this example. The ma-
licious heap object’s size is 1M bytes, consisting of two types of
64K-byte memory blocks. The ﬁrst type only contains jump in-
structions at the landing positions, pointing to the landing position
in the next block. The second type of block contains the shellcode
at the landing position. We use the address 0x0c0c0c0c as the
jump target in step two of the attack. According to our analysis
in Section 3, the landing position is at the offset 0x0c0c of each
64K-byte block. We construct the ﬁnal block by concatenating 15
type-1 blocks and one type-2 block, forming a heap object of 1M
bytes. Note that each heap object allocated by Javascript has a 36-
byte header (a Windows heap management header and a Javascript
heap management header); we need to remove 36 bytes at the be-
ginning of the ﬁnal block, so that the offsets of landing positions
will not be shifted by the header.
Figure 7 shows a piece of JavaScript code that implements a
Heap Taichi attack, performing the heap object construction and
heap spraying. The function CreateCCstringwithsize is
used to create a string ﬁlled with value 0xCC and the function
DuplicateStr is used to create a long string. We ﬁll the blocks
with 0xCC, because it is the opcode of x86’s INT 3 instruction,
regarded as a terminator of a sequence of shellcode by existing ap-
proaches. We can ﬁll these blocks with random bytes, because they
are not used anyway. Because JavaScript strings use unicode en-
coding where each character takes 16 bits, we need to divide the
length measured in bytes by two to get the correct length of uni-
code strings. Line 7 constructs the type1_64k block, and line 8
constructs the type2_64k block. Then line 9 and line 10 prepare
the ﬁrst half of the ﬁnal block. Thirty six bytes are cut from the ﬁrst
half to accommodate the heap header. Finally, the heap is sprayed
in line 12 to line 14 by an array of 200 strings containing the ﬁnal
block, taking up 200M bytes of the browser’s heap region.
The scstring is ﬁlled with shellcode that libemu [9] cannot
detect, which is captured by our drive-by download monitoring sys-
tem [47]. The main reason that libemu cannot detect such shell-
code is that libemu just emulates shellcode and once the shellcode
includes instructions like xor eax, [edi] where register eax
can only be determined at run-time, libemu cannot work well. For
more evasion techniques, we refer readers to [29]. We extracted
44 shellcode pieces from those cached web pages, and 12 of them
can’t be detected by libemu. We choose a 236-byte shellcode to
ﬁll the scstring. Thus this script can bypass defending tech-
niques based on libemu shellcode detection. We have also scanned
this shellcode using 12 anti-virus products, and none of them could
recognize it as a malicious code.
0xCC 0xCC…0xCC0xE9 0xFB 0xFF 0x00 0x00 0xCC0xCC 0xCC…0xCCJump to next landing point3084 bytes6 bytes62446 bytes0x00xC0C0xC120xffff0xCC 0xCC…0xCCshellcode0xCC 0xCC…0xCC3084 bytes0xC0CType1_64kType1_64k...Type2_64kType1_64kExtra 36 byte header0x00xffffType1_64k:Type2_64k:Final blockSample ID Heap Object Type Alignment size
64k bytes
64k bytes
64k bytes
4k bytes
4k bytes
4k bytes
32 bytes
32 bytes
32 bytes
8 bytes
8 bytes
A64k
B64k
C64k
A4k
B4k
C4k
A32
B32
D32
A8
B8
Type A
Type B
Type C
Type A
Type B
Type C
Type A
Type B
Type D
Type A
Type B
Table 2: Samples used in surface area measurement
Block type
Type A
Type B
Type C
Type D
8 bytes
14%
25%
32 bytes
Alignment size
64K bytes
4K bytes
0.0068%
0.030%
0.030%
0.0068%
0.0055% 0.0054%
3.6%
3.6%
0.015%
Table 3: Normalized attack surface area in our experiments
In our experiment, we modiﬁed a cached drive-by download web
page by replacing its heap-spraying script with the one shown in
Figure 7. Then we browsed the page using IE6 on Windows XP.
The script reliably executed the shellcode, which downloaded and
installed a bot on the victim machine.
4.2 Surface area measurement experiments
We build several example heap blocks of all the four heap struc-
tures and various alignment sizes, shown as Table 2. For exam-
ple, A64k is the one given in the last subsection. B64k uses type
B structure, a modiﬁed version of A64k with different jump in-
structions. C64k uses Type C structure, which can be achieved
by replacing all type1_str with type2_str in our example
JavaScript. The shellcode used in our experiment has 236 bytes,
including 101 instructions. Its maximum attack surface area is 56.
To measure the normalized attack surface area (NSA), we im-
plemented NOZZLE’s surface area measurement algorithm. Table 3
summarizes the measured NSAs. We also plotted the results in Fig-
ure 8, where the Y-axis indicates the NSA of the attack vectors and
the X-axis indicates the test cases. In Figure 8, we also marked
several thresholds used in NOZZLE. When alignment size is 32 or
higher, the normalized attack surface areas of the samples are far
below the 50% threshold in NOZZLE.
When alignment size is 8, the Type C and Type D heap objects
cannot be created. B8 exceeds the 20% “no false positive thresh-
old” of NOZZLE, and A8 is on the border. The enhanced NOZZLE
detection should cooperate with 8-byte or 4-byte heap allocation
granularity.
In the Type A and Type B objects, there are many
landing positions connects to one copy of shellcode. The enhanced
NOZZLE detects all of them and reports a heap spraying attack.
Also, we can see the difference in ratio between these results and
the theoretical calculation in Section 3 is less than 3.0, which is
close to the average instruction length. Therefore, the experiments
conﬁrm our theoretical analysis.
4.3 Performance of ﬁne-grained memory allo-
cation granularity
To evaluate the performance of 8-byte alignments, we built the
Firefox 3.6.3 with jemalloc enabled and also modiﬁed jemalloc and
SpiderMonkey with 8-byte randomization. Then we measured the
modiﬁed Firefox’s Javascript performance with Sunspider Javascript
Figure 8: Sorted normalized attack surface area
Figure 9: A sample mixed layout
Benchmark and V8 Benchmark. The result showed that the perfor-
mance overhead is less than 5%. Researchers [26] also reported
acceptable performance overhead of an 8-byte aligned randomiza-
tion using other benchmarks.
5. DISCUSSION
5.1 Variations of Heap Taichi
Section 3 describes four basic memory layouts of Heap Taichi.
Attackers may create new attacks by extending Heap Taichi.
At instruction level, attackers can replace those jump instruction
with different instruction sequences, and ﬁll arbitrary instructions
between landing points and shellcode. At layout level, attackers
can use the basic layouts to compose new layouts. For example,
Figure 9 shows a “mixed” layout by combining Type A, B and C.
Type C includes multiple copies of shellcode but keeps a small sur-
face area; Type A and B layouts introduce more surface area but
fewer shellcode copies. Attackers could use all these types in one
heap block to balance these characteristics to evade detections.
5.2 Difﬁculty of detecting Heap Taichi attack
Under the 64K-byte alignment size, there are only 16 landing
points in one 1M heap block as analyzed in Section 3. Attackers
 0.001%0.010%0.100%1.000%10.000%100.000%B8A8A32B32A4kB4kD32A65kB64kC4kC64kThreshold proposed by Nozzle(50%) No false positive threshold of Nozzle(20%) Max top 150 Alexa sites(12%) NSA shellcode64KB cycle64KB cycle64KB cycle64KB cycle64KB cycle64KB cycle64KB cycleType A+B+CA 512 KB memory blockshellcodecould use mixed layouts similar to the example in Figure 9: place 3
to 5 shellcode pieces in one 1M heap block, and let landing points
lead to any one of these shellcode pieces. In average, four landing