TABLE I: Number of SSL/TLS certiﬁcates used by different
implementations for testing
Implementation
NSS
GnuTLS
OpenSSL
PolarSSL
CyaSSL
MatrixSSL
Certiﬁcate count
64
51
44
18
9
9
Testing with a handful of valid certiﬁcates is unlikely to
uncover vulnerabilities, omissions, and implementation ﬂaws
in the certiﬁcate validation logic. For example, we found that
GnuTLS mistakenly accepts all versions 1 certiﬁcates even
though the default ﬂag is set to accept only locally trusted
version 1 root certiﬁcates (see Section IX). This vulnerability
would have never been discovered with their existing test suite
because it only contains version 3 certiﬁcates.
Automated adversarial testing is rarely, if ever, performed
for SSL/TLS implementations. As we demonstrate in this
paper, systematic testing with inputs that do not satisfy the
protocol speciﬁcation signiﬁcantly improves the chances of
uncovering subtle implementation ﬂaws.
Several of the SSL/TLS implementations in our study, in-
cluding OpenSSL, NSS, and MatrixSSL, have been tested and
certiﬁed according to FIPS 140-2 [30], the U.S. government
computer security standard for cryptographic modules. As the
results of our testing demonstrate, FIPS certiﬁcation does not
mean that an implementation performs authentication correctly
or is secure against man-in-the-middle attacks.
119
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:03 UTC from IEEE Xplore.  Restrictions apply. 
TABLE II: 20 most common issuers in our corpus
Common Name (CN)
Cybertrust Public SureServer SV CA
Go Daddy Secure Certiﬁcation Authority
localhost.localdomain
GeoTrust SSL CA
COMODO SSL CA
RapidSSL CA
COMODO SSL CA 2
BMS
DigiCert High Assurance CA-3
Hitron Technologies Cable Modem Root Certiﬁcate Authority
VeriSign Class 3 Secure Server CA - G3
COMODO High-Assurance Secure Server CA
PositiveSSL CA 2
Entrust Certiﬁcation Authority - L1C
Daniel
Vodafone (Secure Networks)
192.168.168.168
GeoTrust DV SSL CA
localhost
Parallels Panel
Occurrences
30066
13300
7179
7171
7114
6358
5326
4878
4341
4013
3837
3681
2724
2719
2639
2634
2417
2174
2142
2084
VI. COLLECTING CERTIFICATES
We used ZMap [26] to scan the Internet and attempt an
SSL connection to every host listening on port 443. If the
connection was successful, the certiﬁcate presented by the
server was saved along with the IP of the host.
This scan yielded a corpus of 243,246 unique certiﬁcates.
23.5% of the collected certiﬁcates were already expired at the
time they were presented by their servers, and 0.02% were not
yet valid. The certiﬁcates in our corpus were issued by 33,837
unique issuers, identiﬁed by the value of their CN (“Common
Name”) ﬁeld. Table II shows the 20 most common issuers.
23,698 of the certiﬁcates are X.509 version 1 (v1) cer-
tiﬁcates, 4,974 of which are expired. This is important be-
cause—as our testing has uncovered—any v1 certiﬁcate issued
by a trusted CA can be used for man-in-the-middle attacks
against several SSL/TLS implementations (see Section IX).
20,391 v1 certiﬁcates are self-signed. Table III shows
the 10 most common issuers of the other 3,307 certiﬁcates.
localhost,
localdomain, and 192.168.1.1 are all self-issued
certiﬁcate chains, but many v1 certiﬁcates have been issued by
trusted issuers, especially manufacturers of embedded devices.
For example, Remotewd.com is used for remote control of
Western Digital Smart TVs, while UBNT and ZTE make
networking equipment. As we show in Section IX, SSL/TLS
implementations that speciﬁcally target embedded devices han-
dle v1 certiﬁcates incorrectly and are thus vulnerable to man-
in-the-middle attacks using these certiﬁcates.
437 certiﬁcates in our corpus have version 4, even though
there is no X.509 version 4. 434 of them are self-signed, the
other 3 are issued by Cyberoam, a manufacturer of hardware
“security appliances.” We conjecture that the cause is an off-
by-one bug in the certiﬁcate issuance software: the version ﬁeld
in the certiﬁcate is zero-indexed, and if set to 3 by the issuer,
it is interpreted as version 4 by SSL/TLS implementations.
Table IV shows the number of times various extensions
show up in our corpus and how many unique values we
observed for each extension. Extensions are labeled by short
names if known, otherwise by their object identiﬁers (OID).
TABLE III: 10 most common issuers of X.509 version 1
certiﬁcates
Common Name (CN)
BMS
Parallels Panel
localhost
brutus.neuronio.pt
plesk
remotewd.com
UBNT
localdomain
192.168.1.1
ZTE Corporation
Occurrences
4877
2003
1668
1196
1163
1120
1094
986
507
501
TABLE IV: Extensions observed in our corpus
Name or OID
basicConstraints
authorityKeyIdentiﬁer
subjectKeyIdentiﬁer
keyUsage
extendedKeyUsage
crlDistributionPoints
subjectAltName
authorityInfoAccess
certiﬁcatePolicies
nsCertType
nsComment
1.3.6.1.4.1.311.20.2
issuerAltName
1.3.6.1.5.5.7.1.12
SMIME-CAPS
1.3.6.1.4.1.311.21.10
1.3.6.1.4.1.311.21.7
privateKeyUsagePeriod
2.5.29.1
nsRevocationUrl
nsCaRevocationUrl
nsCaPolicyUrl
nsSslServerName
nsBaseUrl
1.2.840.113533.7.65.0
2.16.840.1.113719.1.9.4.1
nsRenewalUrl
2.5.29.80
qcStatements
2.5.29.7
2.16.840.1.113733.1.6.15
2.5.29.10
1.3.6.1.4.1.3401.8.1.1
freshestCRL
subjectDirectoryAttributes
1.3.6.1.4.1.311.10.11.11
2.5.29.3
2.16.840.1.113733.1.6.7
1.3.6.1.4.4324.33
1.3.6.1.4.4324.36
1.3.6.1.4.4324.34
1.3.6.1.4.4324.35
1.2.40.0.10.1.1.1
1.3.6.1.4.1.311.21.1
1.3.6.1.4.1.7650.1
1.3.6.1.4.1.311.10.11.87
1.3.6.1.4.1.311.10.11.26
1.3.6.1.4.1.8173.2.3.6
1.2.40.0.10.1.1.2
2.5.29.4
1.2.250.1.71.1.2.5
1.3.6.1.4.1.6334.2.2
Occurrences
161723
161572
151823
132970
131453
126579
101622
89005
81264
63913
5870
2897
1519
1474
915
875
873
871
175
112
104
74
73
63
59
54
33
10
8
7
6
5
4
4
4
3
2
2
2
2
2
2
2
2
1
1
1
1
1
1
1
1
Unique values
13
21990
72496
54
83
4851
59767
3864
418
21
185
11
115
2
4
16
312
798
133
39
52
32
17
31
6
26
7
10
2
7
6
1
4
3
2
3
1
2
2
2
2
1
2
1
1
1
1
1
1
1
1
1
120
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:03 UTC from IEEE Xplore.  Restrictions apply. 
VII. GENERATING FRANKENCERTS
The key challenge in generating test inputs for SSL/TLS
implementations is how to create strings that (1) are parsed
as X.509 certiﬁcates by the implementations, but (2) exercise
parts of their functionality that are rarely or never executed
when processing normal certiﬁcates.
We use our corpus of real certiﬁcates (see Section VI) as
the source of syntactically valid certiﬁcate parts. Our algorithm
them assembles these parts into random combinations we
call
frankencerts. One limitation of the certiﬁcates in our
corpus is that they all conform to the X.509 speciﬁcation. To
test how SSL/TLS implementations behave when faced with
syntactically valid certiﬁcates that do not conform to X.509,
we also synthesize artiﬁcial certiﬁcate parts and add them to
the inputs of the frankencerts generator (see Section VII-B).
A. Generating frankencerts
Algorithm 1 describes
a
the generation of
single
frankencert. Our prototype implementation of Frankencert
is based on OpenSSL. It uses parts randomly selected from
the corpus, with two exceptions: it generates a new RSA key
and changes the issuer so that it can create chains where the
generated frankencert acts as an intermediate certiﬁcate. The
issuer ﬁeld of each frankencert must be equal to the subject of
the certiﬁcate one level higher in the chain, or else all tested
implementations fail to follow the chain and do not attempt
to validate any other part of the certiﬁcate. For every other
ﬁeld, the generator picks the value from a randomly chosen
certiﬁcate in the corpus (a different certiﬁcate for each ﬁeld).
Extensions are set as follows. The generator chooses a
random number of extensions from among all extensions
observed in the corpus (Table IV). For each extension,
it
randomly chooses a value from the set of all observed values
for that extension. Each value, no matter how common or rare,
has an equal probability of appearing in a frankencert.
We use two CAs as roots of trust, with an X.509 version 1
certiﬁcate and an X.509 version 3 certiﬁcate, respectively. For
the purposes of testing, both root CAs are installed in the local
root of trust and thus trusted by all tested SSL/TLS clients.
Each frankencert is a well-formed X.509 certiﬁcate signed
by a locally trusted CA, but it may be invalid for a number of
reasons. By design, the frankencert generator does not respect
the constraints on X.509 extensions. It also randomly desig-
nates extensions as critical or non-critical in each generated
frankencert, violating the requirement that certain extensions
must be critical (Section IV). This allows us to test whether
SSL/TLS implementations reject certiﬁcates with unknown
critical extensions, as required by the X.509 RFC [69].
For certiﬁcate chains, we use between 0 and 3 frankencerts.
Each intermediate certiﬁcate uses the previous certiﬁcate’s
(randomly chosen) subject as its issuer and is signed by the
previous certiﬁcate, creating a chain that SSL/TLS implemen-
tations can follow. These chains are well-formed, but may
still be invalid because of the contents of random frankencerts