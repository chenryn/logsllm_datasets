+96 
c0 
03 
c0 
04 
c0 
05 
c0 
06 
07 
08 
09 
0a 
0b 
0c 
0d 
0e 
+112 
c0 
07 
c0 
08 
c0 
09 
c0 
0a 
c0 
0b 
c0 
0c 
c0 
0d 
c0 
0e 
branch byte
compression pointer
Start 
expansion 
here 
branch 
compression 
30 
totalLength= 0 
16 
32 
48 
64 
80 
96 
111 
127 
143 
159 
175 
191 
207 
221 
Vulnerability #2: Integer Overflow 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
a 
b 
c 
d 
e 
f 
+0 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+16 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+32 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+48 
00 
0e 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+64 
c0 
00 
0d 
0e 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+80 
c0 
01 
c0 
02 
0b 
0c 
0d 
0e 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+96 
c0 
03 
c0 
04 
c0 
05 
c0 
06 
07 
08 
09 
0a 
0b 
0c 
0d 
0e 
+112 
c0 
07 
c0 
08 
c0 
09 
c0 
0a 
c0 
0b 
c0 
0c 
c0 
0d 
c0 
0e 
branch byte
compression pointer
Start 
expansion 
here 
branch 
compression 
31 
totalLength= 1502 
Vulnerability #2: Integer Overflow 
• To maximize the totalLength, we used the maximum label length 
63 (0x3f) instead of 0x0f shown in the example. 
• Using this construction, we reached a name of length ~72700 bytes, 
overflowing the totalLength variable. 
• We have an RCE candidate  
• Can be triggered in response to every query type supported - using 
CNAME records. 
• Affects Treck versions = 2) { 
        /* copy preference value of MX record */ 
        memcpy(&addr_info->ai_mxpref, resourceRecordAfterNamePtr + 10, 2); 
        /* compute the length of the MX hostname */ 
        labelLength = tfDnsExpLabelLength(resourceRecordAfterNamePtr+0xc,dnsHeaderPtr,labelEndPtr); 
        addr_info->ai_mxhostname = NULL; 
        if (labelLength != 0) { 
            /* allocate buffer for the expanded name */ 
            asciiPtr = tfGetRawBuffer(labelLength); 
            addr_info->ai_mxhostname = asciiPtr; 
            if (asciiPtr != NULL) { 
                /* copy MX hostname to `asciiPtr` as ASCII */ 
                tfDnsLabelToAscii(resourceRecordAfterNamePtr + 0xc, asciiPtr, dnsHeaderPtr, 1, 0); 
                /* ... */ 
            } 
/* ... */ 
When tfDnsExpLabelLength reaches 
labelEndPtr, it stops processing (w/o error) 
and returns the current totalLength. 
34 
*Pseudo-code 
Vulnerability #3: Bad RDLENGTH 
• labelEndPtr is calculated based on the RDLENGTH field of the 
current resource record. 
• RDLENGTH is attacker-controlled! Oops… 
 NAME
 TYPE
 CLASS
 TTL
 RDLENGTH
RDATA
 example.com
 MX
 IN
 86400
 20 7
 0
 0
 4
 s
 m
 t
 p
 7
 e
 x
 a
 m
 p
 l
 e
 3
 c
 o
 m
0
labelEndPtr 
• tfDnsExpLabelLength returns 5; 
• tfDnsLabelToAscii will copy the entire MX hostname. 
35 
Artifact: Memory Leak 
36 
if (RDLENGTH = 2) { 
        /* copy preference value of MX record */ 
        memcpy(&addr_info->ai_mxpref, resourceRecordAfterNamePtr + 10, 2); 
        /* compute the length of the MX hostname */ 
        labelLength = tfDnsExpLabelLength(resourceRecordAfterNamePtr+0xc,dnsHeaderPtr,labelEndPtr); 
        addr_info->ai_mxhostname = NULL; 
        if (labelLength != 0) { 
            /* allocate buffer for the expanded name */ 
            asciiPtr = tfGetRawBuffer(labelLength); 
            addr_info->ai_mxhostname = asciiPtr; 
            if (asciiPtr != NULL) { 
                /* copy MX hostname to `asciiPtr` as ASCII */ 
                tfDnsLabelToAscii(resourceRecordAfterNamePtr + 0xc, asciiPtr, dnsHeaderPtr, 1, 0); 
                /* ... */ 
            } 
/* ... */ 
addrinfo structure 
is allocated 
addr_info is not 
freed on error flows 
*Pseudo-code 
Artifact: Memory Leak 
37 
• An addrinfo structure can be leaked during MX parsing logic. 
• Size of the leak 0x3c. 
• Comes in handy when exploiting heap vulnerabilities. 
CVE-2020-11901: Summary 
Treck 
Version 
Vuln #1: 
Read OOB 
Vuln #2:  
Integer Overflow 
Vuln #3:  
Bad RDLENGTH 
Artifact: 
Memory Leak 
Old 
New 
38 
A device can be affected by one or more vulnerabilities 
depending on the exact version. 
Affected 
Not affected 
Exploitation 
Exploiting CVE-2020-11901 on Schneider Electric UPS Device 
39 
Target Device 
• Schneider Electric APC UPS network card 
• Turbo186 (x86-based) 
• 16-bit Real Mode 
• No ASLR or DEP 
• Weird segmentation (shift 8 instead of 4) 
• No debugging capabilities 
• Only limited crashdumps 
40 
Vulnerability Recap 
• Primitive: heap overflow via DNS response parsing 
• Only alpha-numeric characters are copied* 
• We will exploit using “bad RDLENGTH” (#3) 
41 
Treck Version 
Vuln #1:  
Read OOB 
Vuln #2:  
Integer Overflow 
Vuln #3:  
Bad RDLENGTH 
Old 
New 
Exploiting Heap Overflows 
• Metadata corruption 
• Free-list pointers, block sizes, etc. 
• Application-specific data structures 
• Metadata exploitation considered more generic 
• As demonstrated in our exploit of CVE-2020-11896 
• Can we use the same technique here? 
42 
Treck Heap (in this case…) 
• Heap structure slightly different this time 
• Tightest fit favored 
• Adjacent free blocks are coalesced 
• Free-list checked on every heap operation 
• Pre and post sizes verified against each other 
• Allocated blocks checked only when free()’d 
• Avoiding a premature crash with alpha-numeric overflow is hard… 
Free List Base 
Size  (4 bytes) 
Next  (4 bytes) 
Data 
Size  (4 bytes) 
Free List Block 
… 
Exploitation Technique 
• We can overflow through all DNS response types 
• When the device boots*, 3 MX requests are transmitted 
• Interactivity in exploits is advantageous 
• Allows easier shaping 
• Crashing is favorable in order to reach deterministic state 
• No penalty* for crashing the network card 
44 
tsDnsCacheEntry 
tsDnsCacheEntry *dnscNextEntryPtr 
tsDnsCacheEntry *dnscPrevEntryPtr 
addrinfo *dnscAddrInfoPtr 
. . . 
char *dnscRequestStr 
int dnscErrorCode 
. . . 
short dnscFlags 
. . . 
Overflow Target 
• tsDnsCacheEntry 
• Contains a list of addrinfo structs 
• addrinfo holds the contents of a  
DNS answer (name, IP address, …) 
• Has many pointers and interesting fields 
• Many references in DNS response parsing 
45 
CNAME Processing 
if (found_cname) { 
  // Get the first addrinfo struct from `tsDnsCacheEntry` 
  first_addr_info = t_dns_cache_entry->dnscAddrInfoPtr; 
  if (first_addr_info) { 
    // get CNAME name length from the packet 
    length = tfDnsExpLabelLength(cname_rdata_ptr, packet_ptr, cname_rdata_end_ptr); 
    if (length) { 
      // allocate 
      cname_label_buffer = tfGetRawBuffer(length); 
      if (cname_label_buffer) { 
        // copy to new buffer 
        tfDnsLabelToAscii(cname_rdata_ptr, cname_label_buffer, packet_ptr, 1, 0); 
        first_addr_info->ai_canonname = cname_label_buffer; 
      } 
    } 
  } 
} 
46 
*Pseudo-code 
Controlled Pointer Write 
• We can write a 4-byte pointer 
• (Offset, Segment) 
• To any alpha-numeric address 
• Relatively strong exploitation primitive 
47 
Linear Overflow 
• Overflow is from end of MX name buffer 
MX Name Buffer 
Post-
Size 
Pre-
Size 
Pre-
Size 
tsDnsCacheEntry 
Post-
Size 
48 
Linear Overflow 
• Overflow is from end of MX name buffer 
• tsDnsCacheEntry must be placed after MX name buffer 
MX Name Buffer 
Post-
Size 
Pre-
Size 
Pre-
Size 
tsDnsCacheEntry 
Post-
Size 
EVIL CONTENTS 
49 
Heap Shaping - Limitations 
• Overflow target: tsDnsCacheEntry  
• Allocated on DNS request creation 
• Overflow source: MX name buffer 
• Allocated on DNS response parsing 
• Corrupting free blocks will result in a crash 
• We must overwrite only allocated data 
Heap Shaping – Target Shape 
• A specific hole pattern would allow us to overflow tsDnsCacheEntry 
• Because of tight-fit preference 
• Allocation primitives required to attain this shape 
Head … 
Hole #1 => MX name buffer 
separator Hole #2 => tsDnsCacheEntry separator 
… Tail 
51 
Temporary Allocation 
• Every DNS answer that contains a name (MX, PTR, CNAME) causes 
allocation 
• Controlled size, controlled contents 
• All answer types (except CNAME) get a new addrinfo as well 
• This allocation is free()’d after DNS parsing fails 
• Or DNS TTL expires 
• Good for creating arbitrary sized free regions 
// first, check if the type fits for MX parsing 
if (t_dns_cache_entry.dnscQueryType == DNS_TYPE_MX && answer_rr_dns.type == DNS_TYPE_MX) 
{ 
  new_addr_info = tfDnsAllocAddrInfo(); 
  if (new_addr_info) 
  { 
    if (answer_rr_dns.rdlen >= 2) 
    { 
      // ... further parsing, including linking the new addrinfo to the list 
    } 
    else 
    { 
      // ... exit with error code 
    } 
  } 
} 
addrinfo Memory Leak 
Allocation 
Validate data size 
New addrinfo 
won’t get free()’d 
Heap Shaping – Done! 
• The two allocation primitives are used to shape the heap 
• Reliable overflow of tsDnsCacheEntry 
• What can we overwrite with the CNAME pointer write primitive? 
Head … 
Hole #1 => MX name buffer 
separator Hole #2 => tsDnsCacheEntry separator 
… Tail 
Pointer Write Limitations 
• CNAME pointer written to address in tsDnsCacheEntry 
• Overflow is only alpha-numeric, with trailing null-byte 
• Can be used as segment MSB 
• Nothing placed in a strictly alpha-numeric address 
• Combine two alpha-numeric bytes => Non-alpha-numeric segment 
• This allows us to overwrite heap utility functions 
  XX   XX  YY   YY 
  |     |  |     | 
  -------  ------- 
     |        | 
   offset  segment 
0x004B  “EVIL.PAYLOAD”  
malloc(14); 
Recap 
Payload Trigger 
• free() error flow will be triggered on overflown MX name free 
• CNAME buffer contains crafted alpha-numeric shellcode 
• 2-stage decoder 
59 
Payload Trigger 
• free() error flow will be triggered on overflown MX name free 
• CNAME buffer contains crafted alpha-numeric shellcode 
• 2-stage decoder 
• We have achieved arbitrary payload execution! 
60 
DEMO 
61 
62 
Thanks for listening! 
PI:EMAIL