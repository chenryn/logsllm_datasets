SetThreadToken—Assigns an 
impersonation token to a thread. 
  PHANDLE Thread,
  HANDLE  Token
ResumeThread—Resumes the 
execution of the suspended 
thread.
DuplicateTokenEx—Creates the new token duplicating the 
existing token.
  HANDLE 
hExistingToken,
  DWORD 
dwDesiredAccess,
  LPSECURITY_ATTRIBUTES 
lpTokenAttributes,
  SECURITY_IMPERSONATION_LEVEL 
ImpersonationLevel,
  TOKEN_TYPE 
TokenType,
  PHANDLE 
phNewToken
Technical Analysis of Access Token Theft and Manipulation
7
REPORT
 Looking at the Code: Technique 1: 
CreateProcessWithTokenW
Looking at the code below, there are a few things that must be done to be 
able to spawn the process with SYSTEM privileges. 
■ To be able to access/read another process’s memory, the calling process 
must have “SeDebugPrivilege.” Users in the administrator group have 
this privilege disabled by default. Calling OpenProcessToken on the 
current process would return the token handle of the calling process, 
following which LookupPrivilegeValue with “SE_DEBUG_NAME” returns 
the LUID of the specified privilege. This will be returned in the TOKEN_
PRIVILEGES structure.
■ Next, we specify SE_PRIVILEGE_ENABLED in the TOKEN_PRIVILEGE 
structure attributes field to indicate that the privilege specified in the 
LUID needs to be enabled. Calling AdjustTokenPrivileges with the 
handle acquired from OpenProcessToken and structure will get this 
privilege enabled on the calling process.
■ Next, we call OpenProcess with the PID of the SYSTEM level process 
specified on the command line and with the returned process handle 
and execute OpenProcessToken to acquire the handle to the process’s 
primary token. To be able to successfully duplicate the token in the next 
call to DuplicateTokenEx, we need an access token with TOKEN_QUERY 
and TOKEN_DUPLICATE permissions. 
■ Before calling DuplicateTokenEx, we set SECURITY_IMPERSONATION_
LEVEL, which is an enumerator to “SecurityImpersonation” and TOKEN_
TYPE enumerator to “TokenPrimary.” This will allow the security context 
of the target process to be impersonated, which most malware of this 
type also does. With this, DuplicateTokenEx is called, returning the 
handle to the duplicated token.
■ This new token can now be used with CreateProcessWithTokenW, along 
with the executable name and the PROCESS_INFORMATION structure, to 
start a new process as a SYSTEM user.
Malware often attempts to set the session ID of the new process/thread to 
the same as the target process using SetTokenInformation to impersonate 
the user processes running from interactive logon. As shown below, the 
resulting new process created is running in the security context of the 
SYSTEM user.
Technical Analysis of Access Token Theft and Manipulation
8
REPORT
Following is a malware code snippet (dubbed RottonPotato: 
A9FD8100AA5EF47E68B2F084562AFDE0) using the same technique to 
start the process with a stolen access token:
 Looking at the Code: Technique 2: 
ImpersonateLoggedOnUser
■ As shown in the code below, we call GetUserName just after calling the 
OpenProcessToken to check the user security context under which the 
process is running. As highlighted in Technique 1, OpenProcessToken is 
called with the PID of the SYSTEM level process. 
■ Next, we call ImpersonateLoggedOnUser with the primary 
or impersonation token handle derived with the previous API. 
ImpersonateLoggedOnUser allows the calling thread to impersonate 
the security context of the current logged in user which is specified by 
the access token handle passed to it, after which GetUserName is called 
again to check the security context. As we see below, the context of the 
calling thread is changed to a SYSTEM level process. 
 Looking at the Code: Technique 3: CreateProcessAsUser
■ Here, we call CreateProcessAsUser with one of the arguments as a 
handle of the token acquired after calling DuplicateTokenEx. The new 
process to be created is also passed as an argument to the call which will 
subsequently run in the security context of the user represented by the 
token handle. 
■ To be able to create the process with the specified token handle, the 
calling process must have SE_ASSIGNPRIMARYTOKEN_NAME as 
shown here.
Technical Analysis of Access Token Theft and Manipulation
9
REPORT
 Below is the output after calling CreateProcessAsUser, subsequently 
creating the process with system level privileges.
Below is the code snippet from a malware implementing the same user 
impersonation technique.
 Looking at the Code: Technique 4: SetThreadToken 
ResumeThread 
■ In the below malware code, GetTokenInformation is called to acquire 
the TokenSessionID for the terminal services. Once the process access 
token is duplicated, TokenSessionID is set on the duplicated token using 
SetTokenInformation.
■ Subsequently, a thread is created in suspended mode and a 
new impersonated token is assigned to the created thread with 
SetThreadToken and then the suspended thread is resumed, calling 
ResumeThread, which executes in the security context of the user 
represented by the impersonated token. 
Technical Analysis of Access Token Theft and Manipulation
10
REPORT
 Other SYSTEM Level Processes
We checked out many other running SYSTEM level processes running and 
were able to acquire and impersonate access tokens from some of them, 
such as lsass.exe, winlogon.exe, googlecrashhandler.exe, and svchost.exe. 
However, as shown in the following output, acquiring access tokens from 
many of them failed owing to the security settings and read permissions for 
these processes. 
We see multiple forms of failures in the above output. One is the 
OpenProcess call failure and the other is OpenProcessToken call failure on 
the SYSTEM level processes. We wanted to further investigate these failures 
and check if there are any differences in the security settings and access 
permissions for these processes. While investigating the OpenProcess API 
failure on the passed PID, we found it was due to the protection settings of 
these SYSTEM level processes. More details about the access rights on 
the protected processes have been documented on MS docs. In summary, 
protected processes prevent several malicious activities from malware or 
non-protected processes which involve manipulating process objects like 
code injection, obtaining a handle to the protected process, debugging a 
running protected process, accessing memory, impersonating, or duplicating 
a handle from a protected process, injecting a thread into it, etc. Below are the 
protection settings for processes with OpenProcess failure and OpenProcess 
success when looked at through Sysinternal’s Process Explorer. We see 
that csrss.exe is protected with PsProtectedSignerWinTcb-Light and on 
accessing permissions settings, it throws a process open error.
Technical Analysis of Access Token Theft and Manipulation
11
REPORT
This is also indicated in the OpenProcess docs as well.
Many of the other processes were found to be protected with the same or 
other protections.
Digging into this a bit further and came across very interesting behavior 
which is worth highlighting here. If we look at the OpenProcess call in the 
code as shown below, PROCESS_QUERY_INFORMATION is passed as a 
desired access.
API documentation here mentions PROCESS_QUERY_INFORMATION 
from a process to the protected process isn’t allowed and we need to use 
PROCESS_QUERY_LIMITED_INFORMATION in the OpenProcess call if we 
need to acquire a handle to the protected process
Technical Analysis of Access Token Theft and Manipulation
12
REPORT
Further, I modified the code to use the PROCESS_QUERY_LIMITED_
INFORMATION while opening a handle to the protected process:
and I was able to successfully open the process, steal token and start a new 
process with SYSTEM level privileges.
While looking into OpenProcessToken call failure, we found few differences 
between the access permissions of those processes. The below snapshot 
highlights the differences in the permission settings for two different 
processes: one with OpenProcessToken success and the other with 
OpenProcessToken failure.
Technical Analysis of Access Token Theft and Manipulation
13
REPORT
Along with the above highlighted difference in the process permissions, 
a related Specterops blog here also highlights another major difference 
between the access token ownership of these processes because of 
which OpenProcessToken failed. Access token ownership relates to 
the TOKEN_USER and TOKEN_OWNER and as we see below, both the 
processes, lsass.exe with OpenProcessToken success and spoolsv.exe 
with OpenProcessToken failure, had a different token owner.
 Coverage
MITRE ATT&CK
MITRE ATT&CK maps “Access token manipulation” under privilege 
escalation technique T1134 and has identified many high impact malware 
attacks armed with lateral movement capabilities using process access 
token impersonation attacks as shown below. Many of the recent APTs 
have been using similar techniques as well. 
https://attack.mitre.org/techniques/T1134/
Technical Analysis of Access Token Theft and Manipulation
14
REPORT
The below simplified visualization maps the access token manipulation 
techniques used by malware to stages of lateral movement and when they 
are used during malware spreading activity.
LATERAL MOVEMENT
Target
Discovery
Gaining Resource
Access
Remote Code
Execution
Privilege
Escalation
Token Theft/
Impersonation
Credential
Theft
T1134.001
Create Process
with Token
T1134.002
Create and
impersonate token
T1134.003
Detecting Access Token Manipulation Attacks
 YARA Rule
One of the ways to detect access token attacks is to monitor the Windows 
APIs used. The following YARA rule can help with this detection. 
rule access_token_impersonation
{
meta:
       description = “Yara rule to detect process access token impersonation”
        author = “Chintan Shah”
        date = “2021-01-29”
        rule_version = “v1.1”
        malware_family = “APT28/ FIN/ RottenPotato/Petya”
        mitre_attack = “T1134.001 T1134.002 T1134.003”
strings:
      $api1 = “OpenProcess”
      $api2 = “OpenProcesstoken”
      $api3 = “DuplicateTokenEx”
      $apipath1_1 = “CreateThread”
      $apipath1_2 = “SetTokenInformation”
      $apipath1_3 = “SetThreadToken”
      $apipath1_4 = “ResumeThread”
      $apipath2_1 = “ImpersonateLoggedOnUser”
      $apipath3_1 = “CreateProcessWithToken”
      $apipath4_1 = “CreateProcessAsUser”
condition:
   (all of ($api*) and all of ($apipath1_*)) or ( $api1 and $api2 and $apipath2_1 ) or ( all of ($api*) and $apipath3_1) or ( all 
of ($api*) and $apipath4_1)
Technical Analysis of Access Token Theft and Manipulation
15
REPORT
Conclusion
Access token manipulation attacks help malware execute its lateral 
movement activities by staying under the radar and evading many other 
mitigations like User Account Control, file system restrictions and other 
System Access Control Lists (SACLs). Since these attack techniques use 
the inbuilt Windows security features and exploits known as Windows APIs, 
it is critical to monitor the malicious use of these APIs to generically detect 
the malware using them. Since malware would usually target SYSTEM level 
running processes for stealing tokens to gain elevated local privileges, it 
is also a good security measure to monitor the API calls targeting these 
processes.
About the Author
Chintan Shah
Chintan Shah is currently working as a Lead Security Researcher with the 
McAfee Intrusion Prevention System team and holds broad experience 
in the network security industry. He primarily focuses on exploit and 
vulnerability research, building threat Intelligence frameworks, reverse 
engineering techniques and malware analysis. He has researched and 
uncovered multiple targeted and espionage attacks and his interests lie in 
software fuzzing for vulnerability discovery, analyzing exploits, malware 
and translating to product improvement. 
Technical Analysis of Access Token Theft and Manipulation
16
REPORT
6220 America Center Drive
San Jose, CA 95002
888.847.8766
www.mcafee.com
About McAfee
McAfee is the device-to-cloud cybersecurity 
company. Inspired by the power of working 
together, McAfee creates business and 
consumer solutions that make our world a safer 
place. By building solutions that work with other 
companies’ products, McAfee helps businesses 
orchestrate cyber environments that are truly 
integrated, where protection, detection, and 
correction of threats happen simultaneously 
and collaboratively. By protecting consumers 
across all their devices, McAfee secures their 
digital lifestyle at home and away. By working 
with other security players, McAfee is leading 
the effort to unite against cybercriminals for the 
benefit of all.
www.mcafee.com
McAfee ATR
The McAfee® Advanced Threat Research 
Operational Intelligence team operates globally 
around the clock, keeping watch of the latest 
cyber campaigns and actively tracking the 
most impactful cyber threats. Several McAfee 
products and reports, such as MVISION Insights 
and APG ATLAS, are fueled with the team’s 
intelligence work. In addition to providing the 
latest Threat Intelligence to our customers, the 
team also performs unique quality checks and 
enriches the incoming data from all of McAfee’s 
sensors in a way that allows customers to hit the 
ground running and focus on the threats that 
matter.
Subscribe to receive our Threat Information.
Technical Analysis of Access Token Theft and Manipulation
17
REPORT
McAfee and the McAfee logo are trademarks or registered trademarks of McAfee, LLC or its subsidiaries in the US and other countries. 
Other marks and brands may be claimed as the property of others. Copyright © 2021 McAfee, LLC.  4735_0421
APRIL 2021