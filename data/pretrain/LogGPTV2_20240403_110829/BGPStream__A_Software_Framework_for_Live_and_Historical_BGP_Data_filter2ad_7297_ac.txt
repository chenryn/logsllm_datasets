runtime, 
transition  at 
3.5.3  A  command  line  interface  for  reconfiguration
management.  To 
fully  control  operations  during
application 
the  application
administrator should be given permission to reconfigure a
software application via the command line interface.   To
maximize  flexibility  of  the  application  transition,  a
command  line  interface  can  be  used  in  two  ways:  (1)
application  transition  for  only  one  module;  and  (2)  the
simultaneous upgrading of a group of modules that depend
on each other. A scripting language, such as Tcl/Tk [14],
provides  powerful  capabilities 
such  an
application-specific command line interface.
to  build 
4.  Implementation environment
We  implemented  the  framework  in  C++,  because  a
key  objective  was  to  develop  an  extensible  and  reusable
framework. To adapt to different environments and reduce
portability  problems,  ACE  (Adaptive  Communication
Environment)  [15][16]  was  used  to  map  the  framework
onto  many  platforms,  such  as  several  versions  of  Unix,
Linux, and Win32.
Dynamic  library  facilities  provided  by  the  operating
systems allow, at run time, loading a module library that
has been complied as a shared library. The object-oriented
system  design  further  allows  creating  an  instance  of  a
dynamic  module  at  run  time.  To  take  advantage  of  the
features  described  above,  dynamic  modules  satisfy  the
following implementation requirement.
Each  module-implementation  is  wrapped  as  a  C++
class, which is derived from a base class ModuleImp. This
Class  can  be  compiled  separately  as  a  dynamic  shared
library that can be loaded into and unloaded from memory
at  runtime  [17][18][19].  The  base  class  ModuleImp
contains  a  message  queue  and  some  essential  functions
used for internal manipulation of live software upgrades.
interface,  which  can  be  overridden  by 
Furthermore, the class ModuleImp exports some well-
known 
its
subclasses  that  implement  software  modules.  Due  to
inheritance and late binding, the newly created instance of
a  subclass  can  be  dynamically  type  cast  to  its  base  class
ModuleImp.  Therefore,  it  is  possible  to  pull  out  an  old
version of the module-implementation and plug in a new
version at run time.
that 
The module-proxy component is implemented by the
interacts  with  module-
class  ModuleType 
internally  and  exports  some  public
implementation 
interface for other software modules to communicate with
its  delegated  module.  A  ModuleType  object  can  be
configured  to  delegate  any  ModuleImp  object.  Each
ModuleType  object  contains  a  reference  to  a  ModuleImp
object with which it is currently bound.
During an online change, the reference to the module
implementation can be hot swapped to a new ModuleImp
object by the ModuleType object.
We found that software design patterns can facilitate
the  implementation  of  the  framework.  Also,  mutual
exclusion and barrier mechanisms can help us resolve the
synchronization  problem  when  a  group  of  modules  is
upgrade.
Proceedings of the 13 th International Symposium on Software Reliability Engineering (ISSRE’02) 
1071-9458/02 $17.00 © 2002 IEEE 
5.  Simulation results
Our  demonstration  application  based  on 
the
framework  is  called  non-stop  Router  consisting  of  four
modules:  TIMER,  IP  (Internet  Protocol)  [20],  OSPF
(Open Shortest Path First) [21], and VRRP (Virtual Router
Redundancy  Protocol)  [22],  which  are  concurrently
executed  and  provide  multiple  services  as  depicted  in
Figure 9. On one hand, ICMP (Internet Control  Message
Protocol)  packets,  HELLO  discovery  packets,  and
HEARTBEAT  packets  are  broadcasted  periodically.  On
the  other  hand,  there  are  three  nodes,  IP  monitor,  OSPF
monitor,  and  VRRP  monitor,  which  receive  the  ICMP
packets,  the  HELLO  packets  and  the  HEARTBEAT
packets  accordingly.  An  application  administrator  can
reconfigure  the  software  application  through  the  CLI
(Command Line Interface) node. To simulate a publisher
and subscriber communication model, the TIMER module
acts as a publisher by publishing a broadcast event. Other
modules  will  subscribe  to  the  broadcast  event  once  they
are  activated.  When  the  IP  module  receives  an  event
message periodically, it broadcasts an ICMP packet to the
neighborhood and meanwhile sends a control  message  to
the  OSPF module. Similarly, the  VRRP  module  not  only
broadcasts a HEARTBEAT packet to nodes but also sends
a  control  message  to  the  OSPF  module.  The  OSPF
module only broadcasts its HELLO packet after receiving
an  event  message.  To  maintain  application  consistency
before  and  after  a  live  software  upgrade,  the  content  in
messages sent by the VRRP module and the IP module to
the OSPF is assigned an integer number, called the relay
number, in a consecutive format.
Section  5.1  below,  illustrates  an  example  of  a
successful  replacement  transaction,  while  section  5.2
shows the scenario of an aborting transaction.
subscribe events
TIMER
Architecture of the
non-stop router
IP
send messages
 publish  events
OSPF
VRRP
send messages
broadcast
ICMP packet
IP  Monitor
broadcast
HEARTBEAT
packet
VRRP
Monitor
broadcast
HELLO packet
OSPF
Monitor
Figure 9.  Architecture of the non-stop router
5.1  Transaction One
Configuration command
Replace  IP  libIPImp_v2.so
Transaction  one  as  depicted  in  Figure  10  shows  that
Version  1  of  the  IP  module-implementation  can  be
successfully replaced with Version 2. In order to reach the
quiescent state, the IP module-implementation is disabled
by its module-proxy so that it stops broadcasting  packets
to  the  nodes  and  sending  the  messages  to  the  OSPF
module. After consuming all the pending messages in its
input  message  queue,  the  module-implementation  finally
gets a special TERM message appended by its proxy. As a
result, it terminates its task context and reaches the stable
state.  Once  Version  1  of  the  implementation  object  has
checkpointed  its  state  and  put  its  relay  number  into  the
state storage, Version 2 of the implementation object will
get a chance to recover the state transferred by its proxy.
In  this  case,  Version  2  of  the  implementation  object,
which has the same state as Version 1, is ready to send its
consecutive relay number in the messages again.
Figure 10. Transaction One
5.2  Transaction Two
Configuration Command
SetTimer   2
Syn_Replace  OSPF  libOSPFImp_v2.so
                    IP        libIPImp_v2.so
Proceedings of the 13 th International Symposium on Software Reliability Engineering (ISSRE’02) 
1071-9458/02 $17.00 © 2002 IEEE 
Figure 11 depicts the scenario of an aborting transaction.
The  maximum  preparation  time  is  two  seconds,  which
may be shorter than the time taken by one of the modules
to prepare for live upgrade. Within two seconds, the OSPF
module can reach a stable state, return its vote, and attain
voting  state.  However,  the  IP  module  cannot  meet  the
timing  constraint.  Thus,  the  IP  module  returns  a  “NO”
vote  to  the  software  upgrader.  The  software  upgrader
decides to abort the transaction because one of the target
modules  votes  "NO".  Consequently,  the  newly  created
implementation  objects  are  removed  from  memory,  and
the  original  implementation  objects  are  automatically
brought  back  into  service.  Finally,  the  queue  of  the
the  current
buffered  message 
implementation  object.  Although 
is
aborted, no pending messages or new incoming messages
are lost.
is  handed  over 
transaction 
the 
to 
that 
The  simulation  results  show 
the  proposed
framework provides capabilities for live software upgrade
of an actual non-stop multi-tasking application. Using the
framework,  the  Modules  OSPF,  IP,  VRRP  in  a  service-
critical  application  can  be  replaced,  added  and  removed
dynamically.  The  simulation  also  demonstrated 
the
process of concurrent upgrading a group of modules, and
proved that an upgrade transaction can be aborted in case
of  failure  and  the  all  or  nothing  property  can  be
guaranteed.
Figure 11. Transaction Two
6.  Discussion and experience
We have accumulated some valuable experience with
our  prototype  implementation.  We  found  that  a  live
upgrade  performed  at  a  modular  level  is  appropriate  for
complex  software  systems.  Our  framework  supports  the
following  features:  (1)  a  run-time  evolvable  software
architecture  at  a  granularity  of  module,  (2)  an  atomic
upgrade  transaction  without  influencing  other  running
modules,  (3)  maintaining  the  state  consistency  during
changes,  (4)  an  incremental  execution  of  reconfiguration
in soft real time, (5) a concurrent upgrade mechanism.
In  some  service  and/or  mission-critical  applications,
their  module  behaviors  rely  on  some  periodic  control
messages exchanged between modules. To avoid changing
the  state  machine  of  software  modules  due  to  a  live
upgrade,  an  upgrade  transaction  must  be  committed  or
aborted  within  a  timing  constrain.  Moreover,  no  control
message should be lost during the upgrade.
Scope  change  is  the  extent  to  which  the  software
modules  in  application  are  affected  by  an  upgrade.  The
revision  or  enhancement  of  the  message  protocol  causes
the changes to the interface of modules. Since a message
protocol is defined in communication peer, both modules
become replaced modules when their message protocol is
changed. The proxy of a module remains same except that
the implementation will be upgraded. Such a dependency
on a message protocol decides the scope change of target
modules. However, a problem arises when a new version
of a message protocol is introduced and two versions of a
message  protocol  may  both  be  used  in  communication
between  software  modules.  To  achieve  backward
compatibility,  two  versions  of  the  message  protocol
should  be  both  accommodated  by  the  replacing  module.
This will continue until all the modules that use the older
version of the message protocol have been updated. Thus,
a  module  is  able  to  create  and  use  the  correct  message
handler to process the messages labeled with a version. In
this way, scope change of software module as a result of a
live upgrade becomes minimal.
adopted 
To obtain the benefits of the framework, the software
applications  should  meet  the  following  requirements.  1)
The software modules must be written as derived class of
ModuleImp  based  on  dynamic  updating  protocol.  2)
Messaging and the model of publisher and subscriber shall
be 
The
implementation  of  software  modules  shall  enable  the
feature  of  state  transfer.  Since  the  application  state  is
variable, the “right” state handler will be written for a new
implantation  to  transform  the  state  from  the  old.  The
framework  provides  essential 
infrastructures,  binding
proxies  with  module  implementations,  upgrading  the
intercommunication. 
for 
3) 
Proceedings of the 13 th International Symposium on Software Reliability Engineering (ISSRE’02) 
1071-9458/02 $17.00 © 2002 IEEE 
modules, wrapping and transferring the state between the
versions of the implementation etc.
As  service  availability  and  state  consistency  are
preferred,  failure  to  upgrade  the  modules  that  have  not
reached quiescent condition within some bounded time is
an  acceptable  compromise.  The  plan  of  later  retry  is
considered as an alternative.
7.  Conclusion
a 
addressing, 
We have presented an integrated practical framework
for  live  software  upgrade.  The  design  of  the  framework
emphasizes  four  main  areas:  dynamic  architecture  and
communication  model, 
reconfiguration  management,
runtime  upgrade  protocol,  and  upgrade  technique.  We
introduced a unique dynamic  architecture  which  includes
indirect 
subscriber
communication  model,  a  name  service,  a  version-control
repository  and  a  software  upgrader.  We  designed  an
upgrade  protocol  for  module  addition,  replacement,  and
removal. A two-phase commit protocol was introduced to
ensure  robust  upgrades.  A  master-slave  concurrent
upgrade  mode  is  applied  to  minimize  the  downtime  of
services  provided  by  a  software  application.  We
implement a mechanism for maintaining state consistency
and controlling the upgrade transaction.
publisher 
and 
We  expect  that  future  work  in  this  framework  will
to  a
traditional
include  performance  measurement,  adaptation 
distributed 
authentication issues.
environment, 
some 
and 
8.  References
[1]  Pankaj Jalote, “Fault Tolerance in Distributed systems”
Prentice Hall, 1998.
[2]  Jeff Magee and Jeff Kramer, “Dynamic Structure in
Software Architectures,” Fourth SIGSOFT Symposium on
the Foundations of Software Engineering (FSE), pp. 3-14,
San Francisco, October 1996.
[3]  Peyman Oreizy and Richard N. Taylor, “On the Role of
Software Architectures in Runtime System
Reconfiguration,” Proceedings of the International
Conference on Configurable Distributed Systems (ICCDS
4), Annapolis, Maryland, May 1998.
[4]  Peyman Oreizy, Nenad Medvidovic, and Richard N.
Taylor, “Architecture-Based Runtime Software Evolution,”
IEEE/ACM International Conference on Software
Engineering (ICSE '98), pp. 177-186, Kyoto, Japan, April
19-25, 1998.
[5]  Deepak Gupta and Pankaj Jalote, “Increasing System
Availability through On-Line Software Version Change,”
Proceedings of 1993 IEEE 23rd International Symposium
On Fault-Tolerant Computing, pp. 30-35, August1993.
[6]   Jonathan E. Cook and Jeffrey A. Dage, “Highly Reliable
Upgrading of Components,” IEEE/ACM International
Conference on Software Engineering (ICSE ’99), pp. 203-
212, Los Angeles, CA.1999.
[7]  Lui Sha, “Dependable System Upgrade,” Technical Report,
Carnegie Mellon University, Sep. 1998.
[8]  Mike Gagliardi, Raj Rajkumar, and Lui Sha, “Designing for
Evolvability: Building Blocks for Evolvable Real-Time
Systems,” In Proceedings of the IEEE Real-time
Technology and Applications Symposium, pp. 100-109,
June 1996.
[9]  Object Management Group, “The common Object Request
Broker: Architecture and specification, 2.2 edition,” OMG
Technical Committee Document formal/98-07-01, Feb
1998.
[10] Microsoft Corporation, Various COM documents, MSDN
library, 1998.
[11] L. A. Tewksbury, Louise E. Moser, P. M. Melliar-Smith,
“Live Upgrades for CORBA Applications using object
replication,” IEEE International Conference on Software
Maintenance, pp488-497, Florence, Italy, Nov. 2001.
[12] Louise E. Moser, P. M. Melliar-Smith, P. Narasimhan, L.
A. Tewksbury, V. Kalogeraki, “Eternal: fault tolerance and
live upgrades for distributed object systems,” Proceedings
of IEEE information Survivability Conference and
Exposition (DISCEX 2000), Vol.2, pp184-196, 2000.
[13] Jeff Kramer and Jeff Magee, “The Evolving Philosophers
Problem: Dynamic Change Management,” IEEE
Transactions on Software Engineering, Vol.16, No.11, pp.
1293-1306, November 1990.
[14] Welch, Brent, “Practical Programming in Tcl and Tk,”
Third Edition, Prentice Hall, Nov. 1999.
[15] Douglas C. Schmidt “The Adaptive Communication
Environment: An Object-Oriented Network Programming
Toolkit for Developing communication Software,” 11th and
12th Sun Users Group Conference, June 1994.
[16] Douglas C. Schmidt, “Applying Patterns and Frameworks
to Develop Object-Oriented Communication Software,”
Handbook of Programming Languages, Volume I, edited by
Peter Salus, MacMillan Computer Publishing, 1997.
[17] Michael Franz, “Dynamic Linking of Software
Components,” IEEE Computer, Vol. 30, No. 3, pp. 74-81,
March 1997.
[18] W. Wilson Ho and Ronald A. Olsson. “An approach to
genuine dynamic linking,” Software-Pratice and
Experience, Vol. 21, No. 4, pp. 375-390, April, 1991.
[19] Donn Seeley, “Shared Libraries as Objects,” USENIX
Summer Conference Proceedings, pp. 25-37, 1990.
[20] F. Baker, “Requirements for IP Version 4 Routers”. RFC
1812. June 1995.
[21] J. Moy, “OSPF Version 2”. RFC 2328. April 1998.
[22] Knight, S., et al.,  “Virtual Router Redundancy Protocol”,
RFC 2338. April 1998.
Proceedings of the 13 th International Symposium on Software Reliability Engineering (ISSRE’02) 
1071-9458/02 $17.00 © 2002 IEEE