## 总结时刻这一节虽然只介绍了内核栈，但是内容更加重要。如果说 task_struct的其他成员变量都是和进程管理有关的，内核栈是和进程运行有关系的。我这里画了一张图总结一下 32 位和 64 位的工作模式，左边是 32 位的，右边是64 位的。-   在用户态，应用程序进行了至少一次函数调用。32 位和 64    的传递参数的方式稍有不同，32 位的就是用函数栈，64 位的前 6    个参数用寄存器，其他的用函数栈。-   在内核态，32 位和 64 位都使用内核栈，格式也稍有不同，主要集中在    pt_regs 结构上。-   在内核态，32 位和 64 位的内核栈和 task_struct 的关联关系不同。32    位主要靠 thread_info，64 位主要靠 Per-CPU 变量。![](Images/7d350cc0524c563e7c14e3cb09bcd6e3.png){savepage-src="https://static001.geekbang.org/resource/image/82/5c/82ba663aad4f6bd946d48424196e515c.jpeg"}
## 课堂练习这一节讲函数调用的时候，我们讲了函数栈的工作模式。请你写一个程序，然后编译为汇编语言，打开看一下，函数栈是如何起作用的。欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，[反复研读]{.orange}。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。![](Images/1a5564dd4e1c9f25d4772c7f844ca84a.png){savepage-src="https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg"}
# 15 \| 调度（上）：如何制定项目管理流程？前几节，我们介绍了 task_struct数据结构。它就像项目管理系统一样，可以帮项目经理维护项目运行过程中的各类信息，但这并不意味着项目管理工作就完事大吉了。task_struct仅仅能够解决"**看到**"的问题，咱们还要解决如何制定流程，进行项目调度的问题，也就是"**做到**"的问题。公司的人员总是有限的。无论接了多少项目，公司不可能短时间增加很多人手。有的项目比较紧急，应该先进行排期；有的项目可以缓缓，但是也不能让客户等太久。所以这个过程非常复杂，需要平衡。对于操作系统来讲，它面对的 CPU的数量是有限的，干活儿都是它们，但是进程数目远远超过 CPU的数目，因而就需要进行进程的调度，有效地分配 CPU的时间，既要保证进程的最快响应，也要保证进程之间的公平。这也是一个非常复杂的、需要平衡的事情。
## 调度策略与调度类在 Linux 里面，进程大概可以分成两种。一种称为**实时进程**，也就是需要尽快执行返回结果的那种。这就好比我们是一家公司，接到的客户项目需求就会有很多种。有些客户的项目需求比较急，比如一定要在一两个月内完成的这种，客户会加急加钱，那这种客户的优先级就会比较高。另一种是**普通进程**，大部分的进程其实都是这种。这就好比，大部分客户的项目都是普通的需求，可以按照正常流程完成，优先级就没实时进程这么高，但是人家肯定也有确定的交付日期。``{=html}那很显然，对于这两种进程，我们的调度策略肯定是不同的。在 task_struct 中，有一个成员变量，我们叫**调度策略**。    unsigned int policy;它有以下几个定义：    #define SCHED_NORMAL0#define SCHED_FIFO1#define SCHED_RR2#define SCHED_BATCH3#define SCHED_IDLE5#define SCHED_DEADLINE6配合调度策略的，还有我们刚才说的**优先级**，也在 task_struct 中。    int prio, static_prio, normal_prio;unsigned int rt_priority;优先级其实就是一个数值，对于实时进程，优先级的范围是0～99；对于普通进程，优先级的范围是100～139。数值越小，优先级越高。从这里可以看出，所有的实时进程都比普通进程优先级要高。毕竟，谁让人家加钱了呢。
### 实时调度策略对于调度策略，其中 SCHED_FIFO、SCHED_RR、SCHED_DEADLINE是实时进程的调度策略。虽然大家都是加钱加急的项目，但是也不能乱来，还是需要有个办事流程才行。例如，**SCHED_FIFO**就是交了相同钱的，先来先服务，但是有的加钱多，可以分配更高的优先级，也就是说，高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，我们遵循先来先得。另外一种策略是，交了相同钱的，轮换着来，这就是**SCHED_RR轮流调度算法**，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务。还有一种新的策略是**SCHED_DEADLINE**，是按照任务的 deadline进行调度的。当产生一个调度点的时候，DL 调度器总是选择其 deadline距离当前时间点最近的那个任务，并调度它执行。