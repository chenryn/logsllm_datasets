two database replicas. The system protects the clientâ€™s privacy
as long the adversary controls at most one of the two servers.
In traditional PIR schemes, the servers must take a linear
scan over the entire database in the process of answering
each client query. In the standard setting of PIR, in which the
USENIX Association
30th USENIX Security Symposium    877
servers store the database in its original form, this linear-time
server-side computation is inherent [7].
Oï¬„ine/online PIR. This linear-time cost on the servers is
a performance bottleneck, so recent work [12, 27, 30, 69]
constructs â€œoï¬„ine/onlineâ€ PIR schemes, which move the
serversâ€™ linear-time computation to an oï¬„ine preprocessing
phase. Oï¬„ine/online PIR schemes work in two phases:
â€¢ In the oï¬„ine phase, which takes place before the client
decides which database row it wants to fetch, the client
downloads a hint from one of the PIR servers. The hintâ€™s
size is sublinear in the size of the full database, though
generating it still takes the server time that is at least linear
in the size of the database.
â€¢ In the online phase, which takes place once the client
decides which database row it wants to fetch, the client
uses its hint to issue a query to the PIR servers. The serversâ€™
responses to the queries allow the client to reconstruct the
database row it is interested in, as well as to update its hint
in preparation for future queries. The total communication
and the serverâ€™s work in this step are sublinear in the
database size.
There are two beneï¬ts to using oï¬„ine/online PIR schemes:
1. Lower latency. The amount of online computation that
the servers need to perform to service a client query is
sublinear in the database size, compared with linear for
standard PIR schemes. This lower online cost can translate
into lower perceived latency for the client.
2. Lower total amortized cost. Since each client can reuse a
single hint for making many online queries, the serversâ€™
work per query is also sublinear in the database size,
compared with linear for standard PIR schemes.
âˆš
âˆš
3.2 Puncturable pseudorandom set
To construct our PIR schemes, we will use puncturable pseudo-
random sets [27,76], for which there are simple constructions
from any pseudorandom generator (e.g., AES-CTR).
Informally, a puncturable pseudorandom set gives a way
ğ‘› subset ğ‘† âŠ‚ {1, . . . , ğ‘›}
to describe a pseudorandom size-
using a short cryptographic key sk. (The set size is a tunable
parameter, but in this paper we always take the subset size
to be
ğ‘›.) Furthermore, it is possible to â€œpunctureâ€ the key
sk at any element ğ‘– âˆˆ ğ‘† to get a key skp that is a concise
description of the set ğ‘†(cid:48) = ğ‘†(cid:114){ğ‘–}. The important property of the
punctured key is that it hides the punctured element, in a strong
cryptographic sense. That is, given only skp, an adversary
cannot guess which was the punctured element with better
probability than randomly guessing an element from [ğ‘›] (cid:114)ğ‘†(cid:48).
This notion of puncturing comes directly from the literature
on puncturable pseudorandom functions [13,16,50,56,74].
The full syntax and deï¬nitions appear in prior work [27], but
we recall the important ideas here. More formally, a punctured
pseudorandom set consists of the following algorithms, where
we leave the security parameter implicit:
â€¢ Gen(ğ‘›) â†’ sk. Generate a random puncturable set key sk.
â€¢ GenWith(ğ‘›, ğ‘–) â†’ sk. Given an element ğ‘– âˆˆ [ğ‘›], generate
a random puncturable set key sk such that the element
ğ‘– âˆˆ Eval(sk).
â€¢ Eval(sk) â†’ ğ‘†. Given an unpunctured key sk, output a pseu-
dorandom set ğ‘† âŠ† [ğ‘›] of size
ğ‘›. (Or, given a punctured
key skp, output a pseudorandom set of size
â€¢ Punc(sk, ğ‘–) â†’ skp. Given a set key sk and element
ğ‘– âˆˆ Eval(sk), output a punctured set key skp such that
Eval(skp) = Eval(sk) (cid:114){ğ‘–}.
ğ‘› âˆ’ 1.)
âˆš
âˆš
Constructions. Prior work [27] constructs puncturable sets
from any pseudorandom generator ğº : {0, 1}ğœ† â†’ {0, 1}2ğœ†
(e.g., AES in counter mode) such that: (a) the set keys are
ğœ† bits long and (b) the punctured set keys are ğ‘‚(ğœ† log ğ‘›)
almost entirely of ğ‘‚(âˆš
bits long. Furthermore, the computation cost of Eval consists
ğ‘›) invocations of the PRG.
4 PIR with faster online time
In this section, we describe our new two-server oï¬„ine/online
PIR protocol. Throughout this section, we view the database
as a static array; in Section 5 we handle the case of a key-value
database that changes over time.
Compared with the best prior two-server scheme [27], ours
improves the serversâ€™ online time and the online communi-
cation by a multiplicative factor of the security parameter ğœ†.
Since we typically take ğœ† â‰ˆ 128 in practice, this improvement
gives roughly a 128-fold improvement in communication and
online computation cost.
âˆš
Speciï¬cally, on a database of ğ‘› records, of length â„“ bits
each, and security parameter ğœ†, existing PIR schemes have
online communication ğ‘‚(ğœ†2 log ğ‘› + ğœ†â„“) and online server
time ğ‘‚(ğœ†â„“
ğ‘›), measured in terms of main-memory reads and
evaluations of a length-doubling PRG. We bring the online
communication cost down to ğ‘‚(ğœ† log ğ‘›+ â„“) bits and the online
server-side computation time down to ğ‘‚(â„“
ğ‘›) operations
(dominated by the cost of ğ‘‚(âˆš
ğ‘›) AES operations and ğ‘‚(âˆš
ğ‘›)
random-access â„“-bit database lookups). Concretely, these
costs are modestâ€”less than a kilobyte of communication and
under 150 microseconds, even for blocklists with millions of
entries.
âˆš
âˆš
In terms of the preprocessing phase, similarly to previous
ğ‘› bits of communication and
work [27], our protocol uses ğœ†â„“
requires the server to do ğ‘‚(ğœ†â„“ğ‘›) work per client.
4.1 Deï¬nition
A two-server oï¬„ine/online PIR scheme for a database
D = (ğ·1, . . . , ğ· ğ‘›) of ğ‘› records, of length â„“ bits each, consists
of the following four algorithms, where we leave the security
parameter implicit.
Hint(D) â†’ â„. The ï¬rst database server uses the Hint algo-
rithm to generate a preprocessed data structure â„ that a
client can later use to privately query the database D. The
878    30th USENIX Security Symposium
USENIX Association
Hint algorithm is randomized, and the ï¬rst server must run
this algorithm once per client.
Query(â„, ğ‘–) â†’ (st, ğ‘0, ğ‘1). The client uses the Query algo-
rithm to generate the PIR queries it makes to the database
servers. The algorithm takes as input the hint â„ and the
database index ğ‘– âˆˆ [ğ‘›] that the client wants to read. The
algorithm outputs client state st and PIR queries ğ‘0 and ğ‘1,
one for each server.
Answer(D, ğ‘) â†’ ğ‘. The servers uses Answer, on database D
Reconstruct(st, ğ‘0, ğ‘1) â†’ (â„(cid:48), ğ·ğ‘–). The client uses state
st, generated at query time, and the serversâ€™ answers ğ‘0
and ğ‘1 to produce a new hint â„(cid:48) and the database record
ğ·ğ‘– âˆˆ {0, 1}â„“.
and client query ğ‘ to produce an answer ğ‘.
We sketch the correctness and privacy deï¬nitions here for
the case in which the client makes a single query. Prior work
gives the (lengthy) deï¬nitions for the multi-query setting [27].
Correctness. If an honest client interacts with honest servers,
the client recovers its desired database record. We say that
an oï¬„ine/online PIR scheme is correct if, for all databases
D = (ğ·1, . . . , ğ· ğ‘›) and all ğ‘– âˆˆ [ğ‘›], the probability
Pr
ğ‘– = ğ·ğ‘– :
(_, ğ·(cid:48)
(st, ğ‘0, ğ‘1) â† Query(â„, ğ‘–)
â„ â† Hint(D)
ğ‘0 â† Answer(D, ğ‘0)
ğ‘1 â† Answer(D, ğ‘1)
ğ‘–) â† Reconstruct(st, ğ‘0, ğ‘1)
is at least 1 âˆ’ negl(ğœ†), on (implicit) security parameter ğœ†.
Security. An attacker who controls either one of the two
servers learns nothing about which database record the client
is querying, even if the attacker deviates arbitrarily from
the prescribed protocol. More formally, for a database D =
(ğ·1, . . . , ğ· ğ‘›) and ğ‘– âˆˆ [ğ‘›], deï¬ne the probability distributions
ğ·(cid:48)
ViewD,0,ğ‘– :=
â„, ğ‘0 :
â„ â† Hint(D)
(_, ğ‘0, _) â† Query(â„, ğ‘–)
capturing the â€œviewâ€ of the ï¬rst server, and
ViewD,1,ğ‘– :=
ğ‘1 :
â„ â† Hint(D)
(_, _, ğ‘1) â† Query(â„, ğ‘–)
capturing the â€œviewâ€ of the second server.
An oï¬„ine/online PIR scheme is secure if, for every number
of records ğ‘›, record length â„“, database D, servers ğ‘  âˆˆ {0, 1},
and ğ‘–, ğ‘— âˆˆ [ğ‘›] the distributions ViewD,ğ‘ ,ğ‘– and ViewD,ğ‘ , ğ‘— are
computationally indistinguishable. This deï¬nition implicitly
captures security against an adversarial server that colludes
with additional clients in the system, since the adversary can
simulate the responses of the honest server to such clients.
4.2 Our scheme
Prior oï¬„ine/online PIR schemes [27] natively have relatively
large correctness error: the online phase fails with relatively
(cid:26)
(cid:26)
(cid:27)
,
(cid:27)
,
large probability â‰ˆ 1/âˆš
ğ‘›. To allow the client to recover its
record of interest with overwhelming probability, the client and
to drive the correctness error down to (1/âˆš
server must run the online-phase protocol ğœ† times in parallel
ğ‘›)ğœ† = negl(ğœ†).
Our improved PIR scheme (Construction 1) is slightly more
complicated than those of prior work, but the beneï¬t is that it
has very low (i.e., cryptographically negligible) correctness
error. Since our protocol has almost no correctness error, the
parties need not repeat the protocol ğœ† times in parallel, which
yields our ğœ†-fold performance gain.
Our main result of this section is:
âˆš
âˆš
âˆš
ğ‘›).
ğ‘› + 1) bits,
Theorem. Construction 1 is a computationally secure of-
ï¬‚ine/online PIR scheme, assuming the security of the underly-
ing puncturable pseudorandom set. On a database of ğ‘› âˆˆ N
records, each of length â„“ bits, and security parameter ğœ† âˆˆ N
(used to instantiate the puncturable pseudorandom set), the
scheme has:
â€¢ oï¬„ine communication ğœ†(â„“
â€¢ oï¬„ine time ğ‘‚(ğœ†â„“ğ‘›),
â€¢ client query time ğ‘‚(ğ‘›) in expectation,
â€¢ online communication 2(ğœ† + 1) log ğ‘› + 4â„“ bits, and
â€¢ online server time ğ‘‚(â„“
We formally analyze the correctness and security of Con-
struction 1 in the full version of this work [58]. Here, we
describe the intuition behind how the construction works.
Oï¬„ine phase. In the oï¬„ine phase of the protocol, the ï¬rst
server samples ğ‘‡ = ğœ†
ğ‘› puncturable pseudorandom set keys
(sk1, . . . , skğ‘‡ ). Then, for each ğ‘¡ âˆˆ [ğ‘‡], the server computes
the parity of the database records indexed by the set Eval(skğ‘¡).
If the database consists of ğ‘› records ğ·1, . . . , ğ· ğ‘› âˆˆ {0, 1}â„“,
then the ğ‘¡-th parity word is: ğ‘ƒğ‘¡ = âŠ• ğ‘—âˆˆEval(skğ‘¡) ğ· ğ‘— âˆˆ {0, 1}â„“.
The ğ‘¡ keys (sk1, . . . , skğ‘‡ ) along with the ğ‘‡ parity words
(ğ‘ƒ1, . . . , ğ‘ƒğ‘‡ ) form the hint that the server sends to the client.
If the server uses a pseudorandom generator seeded with seed
to generate the randomness for the ğ‘‡ invocations of Gen, the
hint that the client stores consists of (seed, ğ‘ƒ1, . . . , ğ‘ƒğ‘‡ ) and
has length ğœ† + ğœ†â„“
The key property of this hint is that with overwhelming
probability (at least 1 âˆ’ 2âˆ’ğœ†), each database record will be
included in at least one of the parity words. That is, for every
ğ‘– âˆˆ [ğ‘›], there exists a ğ‘¡ âˆˆ [ğ‘‡] such that ğ‘– âˆˆ Eval(skğ‘¡).
Online phase. In the online phase, the client has decided that
it wants to fetch the ğ‘–th record of the database, for ğ‘– âˆˆ [ğ‘›].
ğ‘› bits.
The clientâ€™s general strategy will be to obtain the parity
words of the database records indexed by sets of indices ğ‘† and
ğ‘†(cid:114){ğ‘–}. The client will then recover the value of the database
record from the two parity words.
Our scheme uses two instantiations of this strategy. In the
ï¬rst case, the client will take the set ğ‘† and its parity word ğ‘ƒ
from the stored hint. In the second case, the client will choose
ğ‘† to be a fresh random set that contains ğ‘–. The client chooses
between the instantiations at random each time it wants to
âˆš
USENIX Association
30th USENIX Security Symposium    879
Construction 1 (Our oï¬„ine/online PIR scheme). Parameters: database size ğ‘› âˆˆ N, record length â„“ âˆˆ N, security parameter
âˆš
ğ‘›, puncturable pseudorandom set (Gen, GenWith, Eval, Punc) construction of Section 3.2 with universe size
ğœ† âˆˆ N, ğ‘‡ := ğœ†
âˆš
ğ‘› and set size
ğ‘›.
Hint(D) â†’ â„.
â€¢ For ğ‘¡ âˆˆ [ğ‘‡]:
â€“ Sample a puncturable-set key skğ‘¡ â† Gen(ğ‘›).
// To reduce the hint size, we can sample the
// randomness for the ğ‘‡ invocations of Gen from a
// pseudorandom generator, whose seed we include
// in the hint.
records indexed by the set ğ‘†ğ‘¡.
ğ· ğ‘—.
ğ‘› âˆ’ 1)/ğ‘›).
(st(cid:48), ğ‘0, ğ‘1) â† QueryCommon(â„, ğ‘–).
(st(cid:48), ğ‘0, ğ‘1) â† QueryRare(ğ‘–).
â€“ Set ğ‘†ğ‘¡ â† Eval(skğ‘¡).
â€“ Compute the parity word ğ‘ƒğ‘¡ âˆˆ {0, 1}â„“ of the database
â€¢ Output the hint as: â„ â†(cid:0)(sk1, . . . , skğ‘‡ ), (ğ‘ƒ1, . . . , ğ‘ƒğ‘‡ )(cid:1).
That is, let ğ‘ƒğ‘¡ â† âŠ• ğ‘—âˆˆğ‘†ğ‘¡
Query(â„, ğ‘–) â†’ (st, ğ‘0, ğ‘1).
â€¢ Sample bit ğ›½ â†R Bernoulli(2(âˆš
â€¢ If ğ›½ = 0:
â€¢ If ğ›½ = 1:
â€¢ Set st â† (â„, ğ›½, st(cid:48))
â€¢ Return (st, ğ‘0, ğ‘1)
Answer(D, ğ‘) â†’ ğ‘.
â€¢ Parse the query ğ‘ as a pair (skp, ğ‘Ÿ), where skp is a
punctured set key and ğ‘Ÿ âˆˆ [ğ‘›].
â€¢ Compute ğ‘†p â† Eval(skp) and compute the parity word
ğ‘Š âˆˆ {0, 1}â„“ of the database records indexed by this set:
ğ‘Š â† âŠ• ğ‘—âˆˆğ‘†p
â€¢ Return ğ‘ â† (ğ‘Š, ğ·ğ‘Ÿ) âˆˆ {0, 1}2â„“ to the client.
Reconstruct(st, ğ‘0, ğ‘1) â†’ (â„(cid:48), ğ·ğ‘–).
â€¢ Parse the state st as (â„, ğ›½, st(cid:48)).
â€¢ Parse the answers as (ğ‘Š0, ğ‘‰0) and (ğ‘Š1, ğ‘‰1).
â€¢ If ğ›½ = 0:
â€“ Parse the hint â„ as(cid:0)(sk1, . . . , skğ‘‡ ), (ğ‘ƒ1, . . . , ğ‘ƒğ‘‡ )(cid:1).
â€“ Set â„(cid:48) â†(cid:0)(sk1, . . . , skğ‘‡ ), (ğ‘ƒ1, . . . , ğ‘ƒğ‘‡ )(cid:1).
â€“ Parse the state st(cid:48) as (ğ‘¡, sknew)
â€“ Set ğ·ğ‘– â† ğ‘ƒğ‘¡ âŠ• ğ‘Š1.
// The client updates the ğ‘¡-th component of the hint.
â€“ Set skğ‘¡ â† sknew and ğ‘ƒğ‘¡ â† ğ‘Š0 âŠ• ğ·ğ‘–.
// Common case
ğ· ğ‘—.
QueryCommon(â„, ğ‘–) â†’ (st(cid:48), ğ‘0, ğ‘1).
// The client ï¬nds a set ğ‘†ğ‘¡ in the hint that contains index ğ‘–.
// The client asks the second server for the parity of the
// database records in ğ‘†ğ‘¡ (cid:114){ğ‘–}.
âˆš
ğ‘› âˆ’ 1
// The client asks the ï¬rst server for the parity of
// records indexed by a freshly sampled random set.
// The client also asks each server for the value of one extra
// database record.