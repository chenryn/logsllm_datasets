June 2010 [22]. Table 1 correlates these 20 families with
the contents of our “milked” malware corpus for Au-
gust 2010. The column labeled kit designates families
Zlob
NAME
1
Palevo
2 Hiloti
Zbot
3
4
FakeRean
5 Onlinegames
6 Rustock
7
Ldpinch
8 Renos
9
10 Autoit
11 Conﬁcker
12 Opachki
13 Buzus
14 Koobface
15 Alureon
16 Bredolab
Piptea
17
18
Ertfor
19 Virut
20
Storm 2.0
% MONETIZATION KIT SEEN
Info stealer
Info stealer
Spam
Info stealer
7.50 DoS,Info stealer
4.69 Downloader/PPI
3.62
3.47 Rogue AV(s)
2.94
2.66
2.64
2.58 Rogue AV(s)
2.54 Rogue software
2.53 Downloader/PPI
2.48 Worm
1.95 Click Fraud
1.91
Info stealer
1.17 Downloader
1.16 Downloader
1.15 Downloader/PPI
1.13 Downloader/PPI
0.91 Rogue AV(s)
0.91 Downloader/PPI
0.80
Spam









?

?
?







Table 1: FireEye’s top 20 malware families observed in
their MAX Cloud network on the April–June 2010 time
period [22] and whether we observe them in our milk for
August 2010.
that are crimeware kits, software that one can purchase
and customize in order to build botnet variants. Each kit
sold may represent an individual botnet with a separate
owner. For popular kits such as zbot, many distinct bot-
nets instances exist [33]. The column labeled seen indi-
cates whether we see samples of the family in our milk-
ing data. We milk 12 of the top 20 families, remain un-
sure about the phylogeny of 3, and miss 5 (AutoIt, Buzus,
Conﬁcker, Koobface, Storm 2.0). We contacted FireEye
to inquire about the 3 unknown families, and based on
their response we believe they reﬂect generic tags used
by AV vendors, rather than speciﬁc families of malware.
3.2
“Milking” PPI Providers
This section starts the description of our milking opera-
tions. Figure 3 illustrates its architecture from milking
the executables until their classiﬁcation.
PPI “milker” requirements. Each PPI service uses at
least one downloader program. A PPI downloader has
three main tasks to perform: download the client pro-
grams, execute them, and communicate successful in-
stallation to the PPI service for accounting. For each
downloader used by a PPI service that we inﬁltrated, we
built our own program that mimics the network com-
2006200720082009201020052011iframedollars.biziframedollars.comiFrameDollarsiframecash.biziframemoney.bizbuytraff.biziframedollars.biziFrameCashiframedollars.comiFrameDollarsinstallscash.orgInstallsCashearning4u.comEarning4Ugangstabucks.comGangstaBucksFigure 3: Architecture of our PPI milking system. The milkers contact the PPI services through Tor and store the
executables for processing (). We then use Bro to distill network trafﬁc summaries from packet traces recorded for
each sample’s contained execution (). A behavioral classiﬁer then processes these summaries and stores clustering
and tagging results to a database ().
munication used by the downloader to obtain the client
programs, but does not implement the rest of the down-
loader’s functionality, namely executing the client pro-
grams and accounting. In particular, we do our best to
identify and avoid any accounting communication to pre-
vent the PPI service from crediting an afﬁliate. We call
such programs milkers because we use them to milk the
client programs that the PPI provider distributes.
Although each PPI downloader program uses a differ-
ent method to download the client programs from the
PPI service, we observe two large classes. Basic PPI
downloaders use plain HTTP and have a set of hard-
coded URLs supplying client programs. The downloads
remain unencrypted and could be spotted easily by any
network monitoring device. The LoaderAdv and one of
the GoldInstall downloaders (GoldInstall-dl) belong to
this class. Advanced PPI downloaders have a propri-
etary, often encrypted, C&C protocol. These download-
ers ﬁrst contact the C&C infrastructure to receive the list
of URLs supplying client programs. The Zlob, Virut, and
an alternative GoldInstall downloader (GoldInstall-list)
fall into this category. These downloaders still use HTTP
for the downloads, at times encrypting the executables or
disguising them as a benign ﬁle (e.g., by preﬁxing them
with a fake GIF header).
Building the milkers. Building a milker is most chal-
lenging for downloaders using undocumented C&C pro-
tocols and encryption routines. Our approach lever-
ages previously proposed techniques for automatic bi-
nary code reuse [5,16], which, given an executable, iden-
tify and extract parts of the executable related to a given
function or speciﬁc functionality deﬁned by the analyst.
Our milker building process is semi-automatic because
we also manually decompile parts of the extracted binary
code. The ﬁnal milker uses a mixture of C source code
and assembly instructions. For this project, building and
testing a basic milker required on average one day of full
work, while the advanced milkers required from two to
ﬁve days of work. It is worth noting that while build-
ing and testing the milker it is important to minimize the
amount of trafﬁc exchanged with the real C&C servers,
which the PPI administrators may monitor. We learned
this the hard way when the Zlob PPI service banned one
of our computers during the testing phase. Moving to a
different IP address ﬁxed the issue.
Updating the milkers. All PPI services frequently
change their download URLs to bypass blacklists. When
a PPI service changes its download URLs, our advanced
milkers simply download the updated list from the PPI
C&C infrastructure and keep milking. However, our ba-
sic milkers, which have the old download URLs hard-
coded, stop working until we update the URLs. To up-
date the download URLs for the basic milkers, we ﬁrst
develop network signatures for the basic PPI download-
ers. Then, we use two different approaches. First, we use
the network signatures to look for new PPI downloaders
within the executables we milk. If we ﬁnd a match, our
processing automatically extracts new URLs and adds
them to our basic milkers. In addition, we also periodi-
cally query search engines and repositories that perform
malware analysis [30] for any new trafﬁc that matches
the network signatures. Due to the prevalence of the PPI
services in this study, we often ﬁnd the new URLs in
public repositories immediately after URLs change.
Anonymity and geographical diversity. To provide
anonymity and geographical diversity for the milkers,
we route them, when possible, through Tor [31]. A
milker achieves geographical diversity by using 15 Tor
circuits in parallel, each circuit terminating in an exit
node in a different country. We chose these countries
in accordance with different price points advertised by
PPI providers. We verify with the MaxMind GeoIP
database [20] that the exit node’s IP address indeed re-
sides in the desired country. For GoldInstall, Loader-
Adv, and Virut, we conduct all network communication
through Tor. We cannot access Zlob through Tor. We
suspect the Zlob operators blacklist the Tor exit nodes,
which are publicly known. To achieve geographical di-
versity for this provider, we run its milkers on Ama-
zon’s EC2 cloud [9] from hosts in two different coun-
tries, without using Tor. We discuss the targets and re-
sults of geographically diverse milking in Section 4.4.
3.3 Running the Executables
We run each new milked executable under containment
in the GQ malware farm [18], a platform for hosting all
manner of malware-driven research in safe, controlled
fashion. GQ conﬁnes each piece of malware in its ex-
ecution by a custom, manually created containment pol-
icy that allows us to decide per-ﬂow whether to allow
trafﬁc to interact with the outside, drop it, rewrite it, or
reﬂect it to other machines inside the environment. In our
scenario, the malware family and behavior is completely
unknown when we run a newly milked sample. Thus, we
create a containment policy that allows us to run all of
our samples safely, and to classify them based on their
network trafﬁc.
We use this containment policy, called SinkAll, to au-
tomatically run thousands of executables, fully unsuper-
vised. This policy blocks network connections and redi-
rects them to internal sink servers within the farm. The
only trafﬁc from the malware allowed on the Internet is
DNS. The reason for allowing DNS is to try to get the
malware sample to attempt C&C communication, since
part of our classiﬁcation process (Section 3.4) examines
the trafﬁc content. While our DNS sink server could
simply reply to all DNS requests with a valid response
that includes a ﬁxed IP address, some malware sam-
ples resolve benign domains (e.g., microsoft.com,
google.com) and check the returned IP addresses
against a hard-coded list in the malware. Thus, our DNS
sink server proxies DNS requests and responses. If the
DNS response is a failure, the sink server spoofs a suc-
cessful DNS response with a ﬁxed IP address to try to get
the malware to attempt C&C communication.
SinkAll forwards all non-DNS TCP trafﬁc from the
malware to internal sink servers. For some well-known
protocols, e.g., HTTP and SMTP, these servers mimic
a valid session. This is important because some mal-
ware samples will test connectivity ﬁrst using these pro-
tocols, and a valid session may entice them to attempt
C&C communication. All other TCP trafﬁc goes to a
generic sink server that accepts arbitrary connections but
does not provide a response; it simply completes the TCP
handshake and accepts any data sent by the malware.
Finally, to detect anti-virtualization capabilities, sam-
ples that do not send any trafﬁc are rerun on a bare (non-
virtualized) host, also within the farm. (This did not of-
ten make a difference in practice.)
3.4 Classifying the Executables
We classify executables based on the network trafﬁc they
produce. First, we manually cluster them based on traf-
ﬁc similarity and create a cluster signature. Then, when
possible, we tag clusters with names used by the com-
munity such as Rustock or Palevo.
Each run of a malware sample in the farm produces a
trace of its network communication. We process the net-
work trace with the Bro intrusion detection system [24],
using a number of custom analysis scripts we developed.
The scripts ﬁrst check whether the sample generated any
network trafﬁc at all.
If it did not, then we queue the
executable for running on a bare host to check for anti-
virtualization techniques. If the sample did generate traf-
ﬁc, we extract a number of features to characterize the
network trafﬁc that we later use during clustering.
The ﬁrst feature is the list of protocols used by the
sample. To extract this feature, we leverage Bro’s dy-
namic protocol detection capabilities, which detects traf-
ﬁc for well-known protocols (e.g., DNS, HTTP, SMTP,
and IRC), regardless of the port with which the commu-
nication happens [8]. Another feature is the list of end-
points that communicate with the sample. For this, we
extract from the DNS trafﬁc the domains requested by
the sample. If the sample starts a connection without a
previous DNS request, we also add the IP address it con-
tacts to the list of end-points. Another feature is the list
of TCP/UDP destination ports for connections started by
the sample. Finally, we extract a content feature from the
payload of any connection. For any HTTP request orig-
inated by the malware, the content feature is the method
and the list of parameters from the URL. We ignore the
path in the URL and the parameter values because they
tend to change often between samples. For other proto-
cols, the content feature is simply the ﬁrst 16 bytes sent
by the malware.
We use the extracted features for clustering executa-
bles with similar network behaviors. In contrast to ex-
MILKER DOWNLOADS DISTINCT START DATE
LoaderAdv
4,334 Aug 1, 2010
GoldInstall
4,488 Aug 1, 2010
Virut
72 Aug 1, 2010
Zlob
259 Jan 3, 2011
Total
696,714
361,325
4,841
504
1,060,895
9,153