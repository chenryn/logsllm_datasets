That is a very nice hat.
This test is at line four.
at ten o*elock ve'11 go home.
$ sed -n */.at/p* data6
The cat is sleeping.
That is a very nice hat.
This test is at line four.
你应该能够明白为什么第一行无法匹配，而第二行和第三行就可以。第四行有点复杂。注意，
我们匹配了at，但在at前面并没有任何字符来匹配点号字符。其实是有的！在正则表达式中，
空格也是字符，因此at前面的空格刚好匹配了该模式。第五行证明了这点，将at放在行首就不
会匹配该模式了。
20.2.5字符组
点号特殊字符在匹配某个字符位置上的任意字符时很有用。但如果你想要限定待匹配的具体
字符呢？在正则表达式中，这称为字符组（character class）。
可以定义用来匹配文本模式中某个位置的一组字符。如果字符组中的某个字符出现在了数据
流中，那它就匹配了该模式。
---
## Page 446
20.2定义BRE模式
431
使用方括号来定义一个字符组。方括号中包含所有你希望出现在该字符组中的字符。然后你
可以在模式中使用整个组，就跟使用其他通配符一样。这需要一点时间来适应，但一旦你适应了，
效果可是令人惊叹的。
下面是个创建字符组的例子。
$ sed -n */ [ch]at/p’ data6
The cat is sleeping.
That is a very nice hat.
这里用到的数据文件和点号特殊字符例子中的一样，但得到的结果却不一样。这次我们成功
滤掉了只包含单词at的行。匹配这个模式的单词只有cat和hat。还要注意以at开头的行也没有
匹配。字符组中必须有个字符来匹配相应的位置。
在不太确定某个字符的大小写时，字符组会非常有用。
,d/sa [Ax] /. u- pas I sax. ouoa s
$ echo *yes* I sed -n */ [Yy]es/p*
Yes
yes
20
可以在单个表达式中用多个字符组。
,6/[ag] [aa] [/[0123456789] [01234567891[0123456789] [0123456789][01234567891/p
>* data8
60633
46201
223001
22203
$
这个结果出乎意料。它成功过滤掉了不可能是邮编的那些过短的数字，因为最后一个字符组
没有字符可匹配。但它也通过了那个六位数，尽管我们只定义了5个字符组。
记住，正则表达式模式可见于数据流中文本的任何位置。经常有匹配模式的字符之外的其他
字符。如果要确保只匹配五位数，就必须将匹配的字符和其他字符分开，要么用空格，要么像这
个例子中这样，指明它们就在行首和行尾。
$ sed -n *
> /′[0123456789] [0123456789][01234567891[0123456789][01234567891$/p
60633
> ' dataB
46201
22203
现在好多了！本章随后会看到如何进一步进行简化。
字符组的一个极其常见的用法是解析拼错的单词，比如用户表单输人的数据。你可以创建正
则表达式来接受数据中常见的拼写错误。
$ cat Gata9
I need to have gome malntenence Gone on ny cax,
I'1l pay that in a seperate invoice.
After I pay for the maintenance my car will be as good as nev,
$ sed -n '
/naint [eaJn[ae Jnce/p
/sep[ea]x [ea] te/p
I need to have gome malntenence done on my car.
data9
I'1l pay that in a seperate invoice.
After I pay for the maintenance my car will be aa good as nev,
本例中的两个sed打印命令利用正则表达式字符组来帮助找到文本中拼错的单词
maintenance和separate。同样的正则表达式模式也能匹配正确拼写的maintenance。
20.2.6排除型字符组
在正则表达式模式中，也可以反转字符组的作用。可以寻找组中没有的字符，面不是去寻找
---
## Page 448
20.2定义BRE模式
433
组中含有的字符。要这么做的话，只要在字符组的开头加个脱字符，
$ sed -n */ ['ch] at/p* data6
This test is at line four,
通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字
符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at
开头的行仍然未能匹配模式。
20.2.7区间
你可能注意到了，我之前演示邮编的例子的时候，必须在每个字符组中列出所有可能的数字，
这实在有点麻烦。好在有一种便捷的方法可以让人免受这番劳苦。可以用单破折线符号在字符组
中表示字符区间。只需要指定区间的第一个字符、单破折线以及区间的最后一个字符就行了。根
据Linux系统采用的字符集（参见第2章），正则表达式会包括此区间内的任意字符。
现在你可以通过指定数字区间来简化邮编的例子。
$ sed -n•/~[09][09][09][09][09]$/g* data8
20
46201
50633
45902
这样可是节省了不少的键盘输入！每个字符组都会匹配0-9的任意数字。如果字母出现在数
据中的任何位置，这个模式都将不成立。
$ echo *a8392*1sed -n /~[09][09][09][09] [09]$/p*
/$[60][6-0](6-0](6-0](6-0]/ . u- p9a 1 =6c8t. o2a $
$ echo *18a92* 1 sed -n /~[09][09][09][09][09]$/g
同样的方法也适用于字母。
$ sed -n */ [c-h]at/p′ data6
The cat is sleeping.
That is a very nice hat.
新的模式[c-h]at匹配了首字母在字母c和字母h之间的单词。这种情况下，只含有单词at
的行将无法匹配该模式。
还可以在单个字符组指定多个不连续的区间。
$ sed -n */ [a-ch-n] at/p’ data6
The cat is sleeping.
That is a very nice hat.
该字符组允许区间a-c、h-m中的字母出现在at文本前，但不允许出现d-g的字母。
---
## Page 449
434
第20章正则表达式
d/se[e-qo-e] / , u- pes 1 .*aeg oo6urnef u, I。 oups S
该模式不匹配fat文本，因为它没在指定的区间。
20.2.8特殊的字符组
除了定义自己的字符组外，BRE还包含了一些特殊的字符组，可用来匹配特定类型的字符。
表20-1介绍了可用的BRE特殊的字符组。
表20-1BRE特殊字符组
组
措述
[ [:a1pha:]]
匹配任意字母字符，不管是大写还是小写
[[:mx[e:]]
匹配任意字母数字字符0-9.A~Z或a~z
[[ :b1ank:1]
匹配空格或制表符
[[:1owex：11
[[:digit:]]
匹配0-9之间的数字
匹配小写字母字符a-z
[[:print:]]
匹配任意可打印字符
[[:pumct:]]
匹配标点符号
[[:apace:]]
匹配任意空白字符：空格、制表符、NL、FF、VT和CR
[[:upper:]]
匹配任意大写字母字符A~Z
可以在正则表达式模式中将特殊字符组像普通字符组一样使用。
,d/[[:at6tp:]1/, u- pes 1 ,oqe, oupe $
,d/[[:eqdte=]1/, u- pes 1 ,oqe, oqoe $
$ echo *abc123* I sed -n */[[:Glgit:11/p*
abc
$ echo *Thla la, a teat* 1 aed -n /[[:punct:11/p*
abc123
$ echo *Thls ia a test* I sed -n */[[:punct:]1/p
This ls, a test
20.2.9星号
在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次。
$ echo *ik* I sed -n */ie*k/p*
$ echo *iek* I sed -n /le*k/p*
1kc
,d/xaT/, u- pes 1 xeet。 oqoe $
Lek
,d/x/, u- pes 1 xoof, ouos $
Leek
---
## Page 450
20.2定义BRE模式
435
S echo *leeeek* 1 sed -n /le*k/p*
leeek
leeeek
这个模式符号广泛用于处理有常见拼写错误或在不同语言中有拼写变化的单词。举个例子，
如果需要写个可能用在美式或英式英语中的脚本，可以这么写：
,d/xnotoo/, u- pes 1 -A xooo e futae6 w,I。 ouoo s
,d/xnoto/, u- pes 1 /xegular , *expression/p'
可以使用这个模式轻松查找可能出现在数据流中文本行内任意位置的多个单词。
星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间。
,d/1+[oe]q/. u- pes 1、q, oqps $
,d/1+ [e]a/, u- pes 1 aeq, ouoe s
1C
,d/1+[oe]a/, u- pes 1 .eq, ouoo s
bat
,d/a+[oe]a/. u- pes 1 .1q. ouoo $
bet
btt
,d/2[ae]a/, u- pes 1 ,etq, ouoe s
,d/1+[ee]a/. u- pes 1 -soeeta. ouoo s
baat:
d/1[e|a/, u-pos 1,1ereotq, oqo $
baaeeet
,d/1 [se]α/, u- pes 1,1esoxeea, ouos S
baeeaeeat
只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行），模式就能够匹
---
## Page 451
436第20章正则表达式
配。如果出现了字符组之外的字符，该模式匹配就会不成立。
20.3扩展正则表达式
POSIXERE模式包括了一些可供Linux应用和工具使用的额外符号。gawk程序能够识别ERE
模式，但sed编辑器不能。
警告记住，sed编辑器和gawk程序的正则表达式引擎之间是有区别的。gawk程序可以使用大多
数扩展正则表达式模式符号，并且能提供一些额外过滤功能，而这些功能都是sed编辑器
所不具备的。但正因为如此，gawk程序在处理数据流时通常才比较慢。
本节将介绍可用在gawk程序脚本中的较常见的ERE模式符号。
20.3.1问号
问号类似于星号，不过有点细微的不同。问号表明前面的字符可以出现0次或1次，但只限于
此。它不会匹配多次出现的字符。
$ echo *bt* I gavk */be?t/ (print $0)*
$ echo *bet* I gawk */be?t/ [pr1nt $0)*
$ echo *beet* I gawk */be?t/ (pxint $0)*
bet
$ echo *beeet* I gauk /be?t/(pxint $0)*
如果字符e并未在文本中出现，或者它只在文本中出现了1次，那么模式会匹配
与星号一样，你可以将问号和字符组一起使用。
$ echo *bt* I gavk */b[ae] ?t/(pxint $0) 
$ echo *bat* I gawk */b[ae]7t/(pzint $0)*
bat
$ echo *bot* I gawk */b[ae]7t/ (pzint $0) *
$ echo *bet* I gawk */b[ae]7t/ (pzint $0)
bet
.(os autxd) /ac [oe]g/, xme6 1 aoeg. oyoe s
$ echo *beat* 1 gawk /b[ae]?t/ (print $0)*
$ echo *beet* I gawk */b[ae] ?t/(print $0)*
如果字符组中的字符出现了0次或1次，模式匹配就成立。但如果两个字符都出现了，或者其
中一个字符出现了2次，模式匹配就不成立。
---
## Page 452
20.3扩展正则表达式
437
20.3.2加号
加号是类似于星号的另一个模式符号，但跟问号也有不同。加号表明前面的字符可以出现1
次或多次，但必须至少出现1次。如果该字符没有出现，那么模式就不会匹配。
$ echo *beeet* I gawk */be+t/ (prlnt $0)*
$ echo *beet* I gawk */be+t/(print $0)*
oeeet
$ echo *bet* I gavk /be+t/(print $0) *
beet
(0$ 2ut.xd) /+oa/ , xnt6 1 。aq, ouoo S
bet
如果字符e没有出现，模式匹配就不成立。加号同样适用于字符组，与星号和问号的使用方
式相同。
(0s auxd] /a+[ee]a/, xyne6 1 -ag. ouoo $
.[0$ utxd] /+[ee]a/, xme6 1 ta. ouo s