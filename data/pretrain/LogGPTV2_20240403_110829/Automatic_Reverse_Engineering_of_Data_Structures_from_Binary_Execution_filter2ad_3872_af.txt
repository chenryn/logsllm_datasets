timeval.tv usec
int
int
int
int
int
int
Size
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
Mem Addr
bfffd154
bfffd158
bfffd160
bfffd164
bfffd168
bfffd16c
bfffd170
bfffd174
bfffd178
bfffd17c
bfffd180
bfffd184
bfffd18c
bfffd190
bfffd194
bfffd1a4
bfffd1a8
bfffd1ac
bfffd1b8
bfffd1bc
Content
38 ea ff bf
00 00 00 00
2c 00 00 00
67 45 8b 6b
0e 00 00 00
00 00 00 00
0a 00 00 63
0f 27 00 00
9f 86 01 00
9f 86 01 00
1c ea ff bf
10 ea ff bf
7a 4a 0e 00
22 00 00 00
00 00 00 00
7a 4a 0e 00
f2 f3 8d 8c
00 00 00 00
01 00 00 00
02 00 00 00
Offset
-9324
-8300
-8236
-8227
-4236
-4156
-4152
-3104
-3088
-3068
-3064
-3058
-3054
-0088
-0084
-0080
-0004
+0000
+0004
+0008
Type
Size
char[9],input t
char*
char[9],input t
char[28]
void*
struct 0x804834e*
void*
char*
char[16]
ip addr t
ip addr t
ip addr t
ip addr t
int
int
int
stack frame t
ret addr t
int
char*
9
4
9
28
4
4
4
4
16
4
4
4
4
4
4
4
4
4
4
4
Mem Addr
bfffd1c0
bfffd5c0
bfffd600
bfffd609
bfffe5a0
bfffe5f0
bfffe5f4
bfffea0c
bfffea1c
bfffea30
bfffea34
bfffea38
bfffea3c
bffff5d4
bffff5d8
bffff5dc
bffff628
bffff62c
bffff630
bffff634
Content
64 6e..64
c0 d1 ff bf
64 6e..64
00
00 ..
00 00 00 00
a0 2d 05 08
e0 f5 ff bf
10 ea ff bf
46 00 00 00
0a 00 01 33
0a 00 00 0b
0a 00 00 04
0a 00 00 04
80 00 00 00
80 00 00 00
ff f7 ff bf
88 f6 ff bf
a2 de 0d b6
02 00 00 00
b4 f6 ff bf
Table 3. Result on the unreachable memory type using type fun 0x804a708
ﬁeld that is input-relevant, in a way similar to stack
vulnerability detection. For the later case, the detector
scans the derived layout of a heap structure to check
the presence of both an input-relevant buffer ﬁeld and
a function pointer ﬁeld. Vulnerabilities in the global
memory region are handled similarly.
• Integer overﬂow vulnerability. Integer overﬂow oc-
curs when an integer exceeds the maximum value that
a machine can represent. Integer overﬂow itself may
not be harmful (e.g., gcc actually leverages integer
overﬂow to manipulate control ﬂow path condition
[38]), but if an integer variable is dependent on user
input without any sanity check and it is used as an
argument to malloc-family functions, then an integer
overﬂow vulnerability is likely.
In particular, over-
ﬂowed values passed to malloc functions usually result
in heap buffers being smaller than they are supposed
to be. Consequently, heap overﬂows occur. For this
type of vulnerabilities, our detector checks the actual
arguments to malloc family function invocations:
if
an integer parameter has both malloc arg t and
input t tags, an integer overﬂow vulnerability sus-
pect will be reported.
• Format string vulnerability. The format string vul-
nerability pattern involves a user input ﬂowing into
a format string argument.
Thus, we introduce a
semantics tag format string t, which is only
resolved at invocations to printf-family functions.
If a variable’s type set contains both input t and
format string t tags, a format string vulnerabil-
ity suspect is reported.
Besides facilitating vulnerability suspect identiﬁcation,
the information generated by REWARDS can also help
composing exploits. For instance, it is critical to know
Program
#Buffer Overﬂow
#Integer Overﬂow
#Format String
ncompress-4.2.4
bftpd-1.0.11
gzip-1.2.4
nullhttpd-0.5.0
xzgv-5.8
gnuPG-1.4.3
ipgrab-0.9.9
cﬁngerd-1.4.3
ngircd-0.8.2
1
3
3
5
3
0
0
4
12
0
0
0
2
8
3
5
0
0
0
0
0
0
0
0
0
1
1
Table 4. Number of vulnerability suspects
reported with help of REWARDS
i.e., a variable with the ret addr t tag,
the distance between a vulnerable stack buffer and a return
in
address,
order to construct a stack overﬂow exploit. Similarly, it
is important to know the distance between a heap buffer
and a heap function pointer for composing a heap overﬂow-
based code injection attack. Such information is provided
by REWARDS.
We applied our REWARDS-based detector to examine
several programs shown in the 1st column of Table 4. The
detector reported a number of vulnerable suspects based
on the aforementioned vulnerability patterns. The total
number of vulnerabilities of each type is presented in the
remaining columns. Observe that our detector does not
produce many suspects for these programs and hence can
serve as a tractable front end for our fuzzer. The fuzzer then
tries to generate exploits to convict the suspects. Details
of each conﬁrmed vulnerable data structure is shown in
the 2nd column of Table 5. The ﬁeld symbols do not
represent their symbolic names, which we do not know, but
rather the type tags derived for these ﬁelds. For instance,
format string t denotes that the ﬁeld is essentially
a format string; sockaddr in indicates that the ﬁeld
holds a socket address. The 3rd column presents the input
category that is relevant to the vulnerable data structure.
Benchmark
Suspicious Data Structure
Input
Offset
Vulnerability Type
ncompress-4.2.4
bftpd-1.0.11
gzip-1.2.4
nullhttpd-0.5.0
xzgv-5.8
gnuPG-1.0.5
ipgrab-0.9.9
cﬁngerd-1.4.3
ngircd-0.8.2
fun 0x08048e76 { -1052: char[13],
-1039: unused[1023],...
-0008: char*,
-0004: stack frame t,
+0000: ret addr t,
+0004: char**}
fun 0x080494b8 { -0064: char*,
-0060: char[12],
-0048: unused [44],
-0004: stack frame t,
+0000: ret addr t,
+0004: char*}
bss 0x08053f80 { ...
+244128: char[8],
+244136: unused[1016],
+245152: char*,...}
heap 0x0804f205 { +0000: char[11],
+0011: unused[5],
+0016: int,... }
heap 0x0804c41f {+0000: void[29],
+0029: unused[1024]}
bss 0x0809ac80 { ...
+91952: int,
+91956: int,...}
fun 0x080673fc { ...,
-0176: char[6],unused[2],
-0168: int,int,...}
heap 0x080afec1 { +0000:int,...,
argv[1]
{0..11}
Stack overﬂow
recv
{0..3}
Stack overﬂow
argv[1]
{0..6}
Global overﬂow
recv
{607,608}
Integer overﬂow
recv
{661..690}
Heap Overﬂow
fread
{4..11}
Integer overﬂow
fread
{2..5}
Integer overﬂow
+0036: void[5] }
fread
{6..10}
Heap overﬂow
fun 0x0804d06b { ...,
-0056: int,
-0052: int, int,...}
heap 0x0805a976 {+0000: void[60] }
fun 0x080496b8 { ...,
-0440: struct sockaddr in,
-0424: format string t[34],
-0390: unused[174],
-0216: char[4],,...}
fun 0x0805f9a5 { ...,
-0284: format string t[76]
-0208: unused[204],
-0004: stack frame t,
+0000: ret addr t,...}
fread
{20..23}
Integer overﬂow
fread
{40..100}
Heap overﬂow
read
{0..3}
Format String
recv
{12..15}
Format String
Table 5. Result from our vulnerability fuzzer with help of REWARDS