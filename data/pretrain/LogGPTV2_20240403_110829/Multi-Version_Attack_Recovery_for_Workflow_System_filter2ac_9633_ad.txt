(d)
10
15
5
K
(f)
5
0
2
8
10
4
E[T
]
1
6
(c)
41.4
41.3
41.2
41.1
41
40.9
40.8
40.7
40.6
40.5
0
10
15
5
K
(e)
s
k
s
a
i
t
s
u
o
c
p
s
u
s
f
i
o
r
e
b
m
u
N
Figure 3. Impacts on the system with differ-
ent parameters
In this case, K has little effect on l after it is large
enough, e.g., > 5 in the ﬁgure. Both E[T (cid:1)] and µ3 have
linear impacts on l while µ3 has relatively more signiﬁcant
impact on l. As for µ1 and λ1, as soon as ρ = λ1
µ1 is small
enough, their changes have little effect on l.
ploss = pK = ρK − ρK+1
1 − ρK+1
(5)
6. Related Work
The higher ploss is, the more unidentiﬁed malicious tasks
there are in the system.
The queue of recovery tasks is the second queue of the
tandem Jackson network. We assume that the probability
of its overﬂow [8] is relative small compared with the loss
probability of the ﬁrst queue since µ1 < µ2.
5.4. A Case Study
A case study is more intuitive than equations. We set up a
case, where E[T (cid:1)] = 10, K = 20, µ1 = 5, λ1 = 2, µ3 = 4,
to investigate the integrity level of the system. When param-
eters change, the results are shown in Figure 3.
An Intrusion Detection System (IDS) [9] can detect
some intrusions. But, in a workﬂow system, the damages
directly caused by the attacker may be spread by execut-
ing normal tasks without being detected by the IDS. The
IDS is unable to trace damage spreading and cannot locate
all damage to the system.
The checkpoint [10, 11] techniques also do not work for
efﬁcient workﬂow recovery. A checkpoint rolls back the
whole workﬂow system to a speciﬁc time. All work, includ-
ing both malicious tasks and normal tasks after the speciﬁc
time, will be lost, especially when the delay of the IDS is
very long. In addition, checkpoints introduce extra storage
cost.
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:34:29 UTC from IEEE Xplore.  Restrictions apply. 
The work most similar to ours handles malicious transac-
tions in a database system, as discussed in [1]. When intru-
sions have been detected by the IDS, the database system
isolates and conﬁnes the impaired data. Then, the system
carries out recovery for malicious transactions. This work
is different from ours in that they consider little about rela-
tions among transactions; the work is unable to trace dam-
age spreading and cannot locate all damage to the system.
In contrast, we show that to guarantee the correct recoveries
of a workﬂow, we need all data and control dependency re-
lations among transactions. Otherwise, both recovered and
newly executed transactions could be corrupted.
The failure handling of workﬂow has been discussed in
recent work [5, 4, 13]. Failure handling is different from
attack recovery in two aspects. On one hand, the two ar-
eas have different goals. Failure handling tries to guaran-
tee the atomicity of workﬂows. When failure happens, their
work ﬁnds which tasks should be aborted. If all tasks are
successfully executed, failure handling does nothing for the
workﬂow. Attack recovery has different goals, which need
to do nothing for failure tasks even if they are malicious, be-
cause malicious failure tasks have no effect on the workﬂow
system. Attack recovery focuses on malicious tasks that are
successfully executed. It tries to remove all effects of such
tasks. On the other hand, these two systems are active at dif-
ferent times. Failure handling occurs when the workﬂows
are in progress. When the IDS reports attacks, the mali-
cious tasks usually have been successfully executed. Fail-
ure handling is not applicable because no failure occurred.
Attack recovery is supposed to remove the effects of mali-
cious tasks after they are committed..
Rollback recovery, e.g. [7, 3], is surveyed in [6]. It fo-
cuses on the relationship of message passing and considers
temporal sequences based on message passing. In contrast
to their research, we focus on data and control dependency
relations inside workﬂow tasks. In fact, message passing is
a kind of data dependency relation but not vice versa (e.g.,
a data dependency relation caused by more than one mes-
sage passing step or by sharing data). We also observed that
in workﬂow recovery an execution path may change due
to control dependencies, causing different patterns of mes-
sage passing. In addition, our methods exploit more detail
in dependency relations than the methods that are message-
passing based; therefore our method is more effective and
efﬁcient for workﬂow recovery.
Decentralized workﬂow processing is becoming more
and more popular. In distributed workﬂow models, work-
ﬂow speciﬁcations cannot be accessed at a central node.
They are carried by the workﬂow itself or stored in a dis-
tributed manner. In either case, our theories are still practi-
cal. We need to process the speciﬁcations of workﬂows in a
distributed manner.
In some work such as [2], security and privacy are impor-
tant, and the whole speciﬁcation of workﬂows avoids being
exposed to all processing nodes to protect privacy. Our theo-
ries are based on the dependency relations among tasks. The
speciﬁcation can be best protected by exposing only depen-
dency relations to the recovery system.
7. Conclusions and Future Work
We described fundamental theories for on-line attack re-
covery of workﬂows. While an independent IDS reports ma-
licious tasks periodically, our techniques ﬁnd all damage
caused by the malicious tasks and repair them automati-
cally. We introduced restrictions of executing order that ex-
ist in an attack recovery system. We partially removed the
restrictions by introducing multi-version data objects to re-
duce unnecessary blocks in order to reduce degradation of
performance while carrying out the recovery. We evaluated
the performance and integrity level of such systems. We
will compare our multi-version data-objects-based systems
with single-version data-objects-based systems in the near
future.
Acknowledgment
We thank LouAnna Notargiacom for her valuable and
insightful comments. She also polished this paper to im-
prove the presentation. Our thanks also to the anonymous
reviewers. This work was supported in part by DARPA and
AFRL, AFMC, USAF, under award number F20602-02-1-
0216, by NSF CCR-TC-0233324, and by Department of
Energy Early Career PI Award.
References
[1] P. Ammann, S. Jajodia, and P. Liu. Recovery from malicious
transactions. IEEE Transaction on Knowledge and Data En-
gineering, 2002.
[2] V. Atluri, S. A. Chun, and P. Mazzoleni. A chinese wall secu-
rity model for decentralized workﬂow systems. In Proceed-
ings of the 8th ACM conference on Computer and Communi-
cations Security, pages 48–57. ACM Press, 2001.
[3] Y. bing Lin and E. D. Lazowska. A study of time warp
rollback machanisms. ACM Transactions on Modeling and
Computer Simulations, 1(1):51–72, January 1991.
[4] Q. Chen and U. Dayal. Failure handling for transaction hi-
In A. Gray and P.- ˚A. Larson, editors, Proceed-
erarchies.
ings of the Thirteenth International Conference on Data En-
gineering, April 7-11, 1997 Birmingham U.K, pages 245–
254. IEEE Computer Society, 1997.
[5] J. Eder and W. Liebhart. Workﬂow recovery. In Conference
on Cooperative Information Systems, pages 124–134, 1996.
[6] E. N. M. Elnozahy, L. Alvisi, Y. min Wang, and D. B. John-
son. A survey of rollback-recovery protocols in message-
passing systems. ACM Computing Surveys, 34(3):375–408,
September 2002.
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:34:29 UTC from IEEE Xplore.  Restrictions apply. 
[7] D. R. Jefferson. Virtual time. ACM Transaction on Program-
ming Languages and Systems, 7(3):404–425, July 1985.
[8] D. P. Kroese and V. F. Nicola. Efﬁcient simulation of a tan-
dem jackson network. ACM Transactions on Modeling and
Computer Simulation, 12(2):119–141, April 2002.
[9] W. Lee and S. J. Stolfo. A framework for constructing
features and models for intrusion detection systems. ACM
Transactions on Information and System Security (TISSEC),
3(4):227–261, 2000.
[10] J.-L. Lin and M. H. Dunham. A survey of distributed
database checkpointing. Distributed and Parallel Databases,
5(3):289–319, 1997.
[11] J.-L. Lin and M. H. Dunham. A low-cost checkpointing
technique for distributed databases. Distributed and Paral-
lel Databases, 10(3):241–268, 2001.
[12] R. A. Sahner, K. S. Trivedi, and A. Puliaﬁto. Performance
and Reliability Analysis of Computer Systems. Kluwer Aca-
demic Publishers, Norwell, Massachusetts, USA, 1996.
[13] J. Tang and S.-Y. Hwang. A scheme to specify and imple-
ment ad-hoc recovery in workﬂow systems. Lecture Notes in
Computer Science, 1377:484–??, 1998.
[14] H. C. Tijms. Stochastic Models. Wiley series in probability
and mathematical statistics. John Wiley & Son, New York,
NY, USA, 1994.
[15] M. Yu, P. Liu, and W. Zang.
Intrusion masking for dis-
tributed atomic operations. In The 18th IFIP International
Information Security Conference, Athens Chamber of Com-
merce and Industry, Greece, 26-28 May 2003. IFIP Techni-
cal Committee 11, Kluwer Academic Publishers.
Appendix: Proof of theorems
Proof of Theorem 4
1. Comes directly from criterion 4 of Deﬁnition 1.
2. Derived from rule 1 and the deﬁnition of relation →
3. By contradiction. If redo(Ti) ≺s undo(Ti) then the ef-
fects of task Ti will be undone, which violates crite-
rion 4 of Deﬁnition 1.
4. By contradiction. Assume redo(Ti) ≺s undo(Tj).
Since Ti →a
Tj, R(redo(Ti)) = R(Ti) and
so R(redo(Ti)) ∩
W (undo(Tj)) = W (Tj),
(cid:6)= φ. Moreover, W (undo(Tj)) is
W (undo(Tj))
dirty before undo(Tj). Therefore redo(Ti) reads dirty
data from R(redo(Ti)) ∩ W (undo(Tj)) then gener-
ates dirty data, which violates criterion 2 of Deﬁni-
tion 1.
5. By contradiction. From Ti →o Tj we have Ti ≺ Tj
and W (Ti) ∩ W (Tj) (cid:6)= φ. Then in the system log
W (Ti) has an older version than W (Tj) for W (Ti) ∩
W (Tj). If undo(Ti) ≺s undo(Tj) then W (Ti) ∩
W (Tj) was not undone for Ti. In other words, Ti was
not undone completely, which violates criterion 1 of
Deﬁnition 1.
6. Comes directly from criterion 4 of Deﬁnition 1.
7. Comes directly from criterion 4 of Deﬁnition 1.
8. Comes directly from the condition 3 of Theorem 2.
9. Comes directly from the condition 4 of Theorem 2.
10. Comes directly from the condition 2 of Theorem 3. (cid:1)
Proof of Theorem 5
1. Comes directly from criterion 4 of Deﬁnition 1.
2. undo(Ti) ≺s redo(Ti) comes directly from the rule 3
of Theorem 4.
If Tj is data dependent on Ti we prove the re-
sult by contradiction. Since R(redo(Ti)) = R(Ti)
and W (redo(Ti)) = W (Ti) so if Ti → Tj then
redo(Ti) → Tj. There are three cases.
• redo(Ti) →f Tj. When Tj reads data from
W (redo(Ti)) ∩ R(Tj) the redo(Ti) has not cre-
ated it. So the task Tj gets wrong data and is cor-
rupted.
• redo(Ti) →o Tj. After executing Tj, redo(Ti)
writes W (redo(Ti)) ∩ W (Tj) again. So the ex-
ecuting results of redo(Ti) in W (redo(Ti)) ∩
W (Tj) is lost. Therefore the task redo(Ti) is cor-
rupted.
• redo(Ti) →a Tj. redo(Ti) will read data that Tj
writes in R(redo(Ti))∩ W (Tj). But according to
the deﬁnition of workﬂow, redo(Ti) should read
data that exists in R(redo(Ti)) ∩ W (Tj) before
executing Tj. So the task redo(Ti) is corrupted.
In these cases, either the new task Tj is corrupted,
which violates criterion 3 of Deﬁnition 1, or the re-
covery task redo(Ti) is corrupted, which violates cri-
terion 2 of Deﬁnition 1.
If Tj is control dependent on Tj then the execution
of Tj depends on the executing result of Ti. If Tj ≺s
redo(Ti) then it is possible that Tj ∈ SF (redo(Ti)) af-
ter redo(Ti) is done. In this case, Tj creates dirty data
according to Theorem 1 therefore the execution of Tj
violates both criterion 3 and criterion 4 of Deﬁnition 1.
3. undo(Ti) ≺s redo(Ti) comes directly from rule 3 of
Theorem 4.
We prove redo(Ti) ≺s Tj by contradiction.
Since redo(Ti) ∈ R is not done, we do not know:
if Tk ∈ ST (redo(Tj)). Assume Tj ≺s
redo(Ti).
is possible that
After
Tk ∈ ST (redo(Tj)). According to the condition 4
of Theorem 2, Tj should be undone because it cre-
ates dirty data, which violates criterion 3 of Deﬁni-
(cid:1)
tion 1.
the redo(Ti) is done,
it
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:34:29 UTC from IEEE Xplore.  Restrictions apply.