to each other that it’s going to switch to a cryptographically secured channel for 
further communication. The Alert protocol is responsible for generating alerts and 
communicating them to the parties involved in the TLS connection. For example,  
if the server certificate the client receives during the TLS handshake is a revoked one,  
the client generates the certificate_revoked alert.
Appendix C  How TrAnsporT LAyer seCuriTy works?
366
The TLS handshake happens after the TCP handshake. For the TCP or for the 
transport layer, everything in the TLS handshake is just application data. Once the 
TCP handshake is completed, the TLS layer will initiate the TLS handshake. The Client 
Hello is the first message in the TLS handshake from the client to the server. As you can 
see in Figure C-9, the sequence number of the TCP packet is 1, as expected, since this 
is the very first TCP packet, which carries application data. The Client Hello message 
includes the highest version of the TLS protocol the client supports, a random number 
generated by the client, cipher suites and the compression algorithm supported by the 
client, and an optional session identifier (see Figure C-9). The session identifier is used 
to resume an existing session rather than doing the handshake again from scratch. The 
TLS handshake is very CPU intensive, but with the support for session resumption, this 
overhead can be minimized.
Figure C-8. TLS handshake
Appendix C  How TrAnsporT LAyer seCuriTy works?
367
Note TLs session resumption has a direct impact on performance. The master 
key generation process in the TLs handshake is extremely costly. with session 
resumption, the same master secret from the previous session is reused. it has 
been proven through several academic studies that the performance enhancement 
resulting from TLs session resumption can be up to 20%. session resumption also 
has a cost, which is mostly handled by servers. each server has to maintain the 
TLs state of all its clients and also to address high-availability aspects; it needs to 
replicate this state across different nodes in the cluster.
Figure C-9. TLS Client Hello captured by Wireshark
Appendix C  How TrAnsporT LAyer seCuriTy works?
368
One key field in the Client Hello message is the Cipher Suites. Figure C-12 expands 
the Cipher Suites field of Figure C-10. The Cipher Suites field in the Client Hello message 
carries all the cryptographic algorithms supported by the client. The message captured 
in Figure C-12 shows the cryptographic capabilities of the Firefox browser version 
43.0.2 (64-bit). A given cipher suite defines the server authentication algorithm, the key 
exchange algorithm, the bulk encryption algorithm, and the message integrity algorithm. 
For example, in TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 cipher suite, RSA 
is the authentication algorithm, ECDHE is the key exchange algorithm, AES_128_GCM 
is the bulk encryption algorithm, and SHA256 is the message integrity algorithm. Any 
cipher suite that starts with TLS is only supported by the TLS protocols. As we proceed in 
this appendix, we will learn the purpose of each algorithm.
Once the server receives the Client Hello message from the client, it responds back 
with the Server Hello message. The Server Hello is the first message from the server to 
the client. To be precise, the Server Hello is the first message from the server to the client, 
which is generated at the TLS layer. Prior to that, the TCP layer of the server responds 
back to the client with a TCP ACK message (see Figure C-11). All TLS layer messages are 
Figure C-10. TLS Client Hello expanded version captured by Wireshark
Appendix C  How TrAnsporT LAyer seCuriTy works?
369
treated as application data by the TCP layer, and each message will be acknowledged 
either by the client or the server. From here onward, we will not talk about TCP ACK 
messages.
Figure C-11. TCP ACK message from the server to the client
The Server Hello message includes the highest version of TLS protocol that both 
the client and the server can support, a random number generated by the server, the 
strongest cipher suite, and the compression algorithm that both the client and the 
server can support (see Figure C-13). Both parties use the random numbers generated 
by each other (the client and the server) independently to generate the master secret. 
This master secret will be used later to derive encryption keys. To generate a session 
identifier, the server has several options. If no session identifier is included in the Client 
Hello message, the server generates a new one. Even the client includes one; but if the 
server can’t resume that session, then once again a new identifier is generated. If the 
server is capable of resuming the TLS session corresponding to the session identifier 
specified in the Client Hello message, then the server includes it in the Server Hello 
message. The server may also decide not to include any session identifiers for any new 
sessions that it’s not willing to resume in the future.
Appendix C  How TrAnsporT LAyer seCuriTy works?
370
Note in the history of TLs, several attacks have been reported against the TLs 
handshake. Cipher suite rollback and version rollback are a couple of them. This 
could be a result of a man-in-the-middle attack, where the attacker intercepts 
the TLs handshake and downgrades either the cipher suite or the TLs version, 
or both. The problem was fixed from ssL 3.0 onward with the introduction of the 
Change Cipher Spec message. This requires both parties to share the hash of all 
TLs handshake messages up to the Change Cipher Spec message exactly as each 
party read them. each has to confirm that they read the messages from each other 
in the same way.
Figure C-12. Cipher suites supported by the TLS client captured by Wireshark
Appendix C  How TrAnsporT LAyer seCuriTy works?
371
After the Server Hello message is sent to the client, the server sends its public 
certificate, along with other certificates, up to the root certificate authority (CA) in the 
certificate chain (see Figure C-14). The client must validate these certificates to accept 
the identity of the server. It uses the public key from the server certificate to encrypt 
the premaster secret key later. The premaster key is a shared secret between the client 
and the server to generate the master secret. If the public key in the server certificate 
isn’t capable of encrypting the premaster secret key, then the TLS protocol mandates 
another extra step, known as the Server Key Exchange (see Figure C-14). During this step, 
the server has to create a new key and send it to the client. Later the client will use it to 
encrypt its premaster secret key.
If the server demands TLS mutual authentication, then the next step is for the 
server to request the client certificate. The client certificate request message from the 
server includes a list of certificate authorities trusted by the server and the type of the 
certificate. After the last two optional steps, the server sends the Server Hello Done 
message to the client (see Figure C-14). This is an empty message that only indicates to 
the client that the server has completed its initial phase in the handshake.
If the server demands the client certificate, now the client sends its public certificate 
along with all other certificates in the chain up to the root certificate authority (CA) 
required to validate the client certificate. Next is the Client Key Exchange message,  
which includes the TLS protocol version as well as the premaster secret key  
Figure C-13. TLS Server Hello captured by Wireshark
Appendix C  How TrAnsporT LAyer seCuriTy works?
372
(see Figure C-15). The TLS protocol version must be the same as specified in the initial 
Client Hello message. This is a guard against any rollback attacks to force the server to 
use an unsecured TLS/SSL version. The premaster secret key included in the message 
should be encrypted with the server’s public key obtained from the server certificate or 
with the key passed in the Server Key Exchange message.
The Certificate Verify message is the next in line. This is optional and is needed 
only if the server demands client authentication. The client has to sign the entire set of 
TLS handshake messages that have taken place so far with its private key and send the 
signature to the server. The server validates the signature using the client’s public key, 
which was shared in a previous step. The signature generation process varies depending 
on which signing algorithm picked during the handshake. If RSA is being used, then the 
hash of all the previous handshake messages is calculated with both MD5 and SHA-1. 
Then the concatenated hash is encrypted using the client’s private key. If the signing 
algorithm picked during the handshake is DSS (Digital Signature Standard), only a SHA- 
1 hash is used, and it’s encrypted using the client’s private key.
Figure C-14. Certificate, Server Key Exchange, and Server Hello Done captured by 
Wireshark
Appendix C  How TrAnsporT LAyer seCuriTy works?
373
At this point, the client and the server have exchanged all the required materials 
to generate the master secret. The master secret is generated using the client random 
number, the server random number, and the premaster secret. The client now sends the 
Change Cipher Spec message to the server to indicate that all messages generated from 
here onward are protected with the keys already established (see Figure C-15).
The Finished message is the last one from the client to the server. It’s the hash of the 
complete message flow in the TLS handshake encrypted by the already established keys. 
Once the server receives the Finished message from the client, it responds back with 
the Change Cipher Spec message (see Figure C-16). This indicates to the client that the 
server is ready to start communicating with the secret keys already established. Finally, 
the server will send the Finished message to the client. This is similar to the Finished 
message generated by the client and includes the hash of the complete message flow 
in the handshake encrypted by the generated cryptographic keys. This completes the 
TLS handshake, and here onward both the client and the server can send data over an 
encrypted channel.
Figure C-15. Client Key Exchange and Change Cipher Spec captured by 
Wireshark
Appendix C  How TrAnsporT LAyer seCuriTy works?
374
TLS VS. HTTPS
HTTp operates at the application layer of the TCp/ip stack, while the TLs operates between the 
application layer and the transport layer (see Figure C-1). The agent (e.g., the browser) acting 
as the HTTp client should also act as the TLs client to initiate the TLs handshake, by opening 
a connection to a specific port (default 443) at the server. only after the TLs handshake is 
completed, the agent should initiate the application data exchange. All HTTp data are sent 
as TLs application data. HTTp over TLs was initially defined by the rFC 2818, under the ieTF 
network working group. The rFC 2818 further defines a uri format for HTTp over TLs traffic, 
to differentiate it from plain HTTp traffic. HTTp over TLs is differentiated from HTTp uris by 
using the https protocol identifier in place of the http protocol identifier. The rFC 2818 was 
later updated by two rFCs: rFC 5785 and rFC 7230.
 Application Data Transfer
After the TLS handshake phase is complete, sensitive application data can be exchanged 
between the client and the server using the TLS Record protocol (Figure C-18). This 
protocol is responsible for breaking all outgoing messages into blocks and assembling all 
incoming messages. Each outgoing block is compressed; Message Authentication Code 
(MAC) is calculated and encrypted. Each incoming block is decrypted, decompressed, 
Figure C-16. Server Change Cipher Spec captured by Wireshark
Appendix C  How TrAnsporT LAyer seCuriTy works?
375
and MAC verified. Figure C-17 summarizes all the key messages exchanged in the TLS 
handshake.
Figure C-17. TLS handshake
During the TLS handshake, each side derives a master secret using the client- 
generated random key, the server-generated random key, and the client-generated 
premaster secret. All these three keys are shared between each other during the TLS 
handshake. The master secret is never transferred over the wire. Using the master 
secret, each side generates four more keys. The client uses the first key to calculate the 
MAC for each outgoing message. The server uses the same key to validate the MAC of 
all incoming messages from the client. The server uses the second key to calculate the 
MAC for each outgoing message. The client uses the same key to validate the MAC of all 
incoming messages from the server. The client uses the third key to encrypt outgoing 
messages, and the server uses the same key to decrypt all incoming messages. The server 
uses the fourth key to encrypt outgoing messages, and the client uses the same key to 
decrypt all incoming messages.
Appendix C  How TrAnsporT LAyer seCuriTy works?
376
REVERSE-ENGINEERING TLS
For each session, TLs creates a master secret and derives four keys from it for hashing and 
encryption. what if the private key of the server leaked out? if all the data transferred between 
clients and the server is being recorded, can it be decrypted? yes, it can. if the TLs handshake 
is recorded, you can decrypt the premaster secret if you know the server’s private key. Then, 
using the client-generated random number and the server-generated random number, you can 
derive the master secret—and then the other four keys. using these keys, you can decrypt the 
entire set of recorded conversations.
using perfect forward secrecy (pFs) can prevent this. with pFs, just as in TLs, a session key 
is generated, but the session key can’t later be derived back from the server’s master secret. 
This eliminates the risk of losing the confidentiality of the data if a private key leaks out. To 
add support for pFs, both the server and the client participating in the TLs handshake should 
support a cipher suite with ephemeral diffie-Hellman (dHe) or the elliptic-curve variant 
(eCdHe).
Note Google enabled forward secrecy for Gmail, Google+, and search in 
november 2011.
Figure C-18. Server Change Cipher Spec captured by Wireshark
Appendix C  How TrAnsporT LAyer seCuriTy works?
377
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4_19
APPENDIX D
UMA Evolution
User-Managed Access (UMA, pronounced “OOH-mah”) is an OAuth 2.0 profile. OAuth 
2.0 decouples the resource server from the authorization server. UMA takes one step 
forward: it lets you control a distributed set of resource servers from a centralized 
authorization server. It also enables the resource owner to define a set of policies at 
the authorization server, which can be evaluated at the time a client is granted access 
to a protected resource. This eliminates the need for the resource owner’s presence to 
approve access requests from arbitrary clients or requesting parties. The authorization 
server can make the decision based on the policies defined by the resource owner.
 ProtectServe
UMA has its roots in the Kantara Initiative. The Kantara Initiative is a nonprofit 
professional association focused on building digital identity management standards. 
The first meeting of the UMA working group was held on August 6, 2009. There were two 
driving forces behind UMA: ProtectServe and vendor relationship management (VRM). 
ProtectServe is a standard that was heavily influenced by VRM. The goal of ProtectServe 
was to build a permission-based data-sharing model that was simple, secure, efficient, 
RESTful, powerful, OAuth-based, and system identity agnostic. ProtectServe defines four 
parties in its protocol flow: the user, the authorization manager, the service provider, and 
the consumer.
The service provider (SP) manages the user’s resources and exposes them to the 
rest of the world. The authorization manager (AM) keeps track of all service providers 
associated with a given user. The user is the resource owner, who introduces all the 
service providers (or the applications he or she works with) to the authorization manager 
and builds access control policies that define the basis on which to share resources with 
others. The consumer consumes the user’s resources via the SP. Before consuming any 
services or resources, the consumer must request an access grant from the AM.  
378
The requested access grant is evaluated against the policies defined on the associated 
service by its owner, at the AM. ProtectServe uses OAuth 1.0 (see Appendix B) as the 
protocol for access delegation.
The steps in the ProtectServe protocol flow are as follows:
Step 1: The user or the resource owner introduces the SP to the AM (see Figure D-1).
 1. The user provides the metadata URL of the AM to the SP.
 2. The SP talks to the metadata endpoint of the AM and gets details 
related to the consumer key issuer, the request token issuer, 
the access token issuer, and the associated policies (OAuth 1.0 
specification defines consumer key, request token, and access 
token).
 3. The SP initiates an OAuth 1.0 flow by requesting an OAuth request 
token from the request token issuer (which could be the same 
AM).
 4. The AM generates an authorization request token and sends it 
back to the SP along with other parameters defined under OAuth 
1.0 specification.
 5. The SP redirects the user to the AM with a token reference along 
with other parameters defined under OAuth 1.0 specification, to 
get it authorized.
 6. Once authorized by the user, the authorization manager returns 
the authorized request token along with other parameters defined 
under OAuth 1.0 specification to the SP.
 7. To complete the OAuth 1.0 flow, the SP exchanges the authorized 
request token for an access token, with the AM.
 8. Once the OAuth flow is completed, the SP talks to the AM 
endpoint (which is secured with OAuth 1.0) to get an SP handle.
 9. The AM validates the OAuth signature and, once verified, issues 
an SP handle to the SP. An SP handle is a unique identifier 
generated by the AM to identify the SP in future communications.
That completes the initial step in the ProtectServe protocol flow.
Appendix d  UMA evolUtion
379
Note the service provider handle is a key that uniquely identifies the service 
provider at the authorization manager. this information is publicly available. A 
given service provider can have multiple service provider handles—one for each 
associated authorization manager.
Step 2: Each consumer who wants to get access to protected resources must be 
provisioned with corresponding consumer keys:
 1. The consumer tries to access a protected resource hosted in an SP.
 2. The SP detects the unauthenticated access attempt and returns an 
HTTP 401 status code with required details to get the SP metadata 
(see Figure D-2).
Figure D-1. The service provider bootstraps trust with the authorization manager 
Appendix d  UMA evolUtion
380
 3. With the details in the 401 response, the consumer talks to the SP’s 
metadata endpoint (see Figure D-2).
 4. The SP metadata endpoint returns the SP handle (which is 
registered at the AM) and the corresponding AM endpoint.
 5. The consumer talks to the AM endpoint to obtain a consumer key 
and a consumer secret (see Figure D-3).
 6. The consumer requests an access token from the AM, with its 
consumer key and the SP handle. The request must be digitally 
signed by the corresponding consumer secret.
 7. The AM validates the parameters in the access token request and 
issues an access token and a token secret to the consumer.
Figure D-2. The consumer is rejected by the service provider with a 401 response. 
R1 represents a resource
Appendix d  UMA evolUtion
381
Figure D-3. The consumer gets an access token from the authorization manager
Step 3: A consumer with a valid access token can access the protected resource 
hosted in the SP (see Figure D-4):
 1. The consumer tries to access the protected resource in the SP with 
its access token, signed with the access token secret.
 2. The SP talks to the AM and gets the secret key corresponding 
to the consumer’s access token. If required, the SP can store it 
locally.
 3. The SP validates the signature of the request using the access 
token secret.
 4. If the signature is valid, the SP talks to the policy decision 