I: Loading resource table from file: /home/tyrone/apktool/framework/1.apk
I: Loaded.
I: Regular manifest package...
I: Decoding file-resources...
I: Decoding values */* XMLs...
I: Done.
I: Copying assets and libs...
You can compile a fully working APK file again after making any necessary modifications to the source by using
the following command:
$ java -jar apktool.jar b output/ new.apk
I: Checking whether sources has changed...
I: Smaling...
I: Checking whether resources has changed...
I: Building resources...
I: Copying libs...
I: Building apk file...
NOTE
To build an application using apktool, the SDK tool aapt needs to be on your PATH.
Apktool is an ideal tool to use if you need to modify any aspect of an application that you do not have the source
for. Download it for free from https://code.google.com/p/android-apktool/.
Jadx
Jadx is an open source DEX decompiler project that is in a working state and looks evermore promising each
version. It contains command-line tools as well as a GUI to browse decompiled code. Source code and
downloads are at https://github.com/skylot/jadx. Figure 6.15 shows the jadx-gui tool that has decompiled an
Android application.
Figure 6.15 Viewing decompiled application code in Jadx-gui
JAD
JAD is another popular free tool that allows for the decompilation of Java Class files back to source files. It does
not provide a user interface like JD-GUI does. Unfortunately, it is not in active development anymore and the
last release was in 2001. In some cases it has been found to be less reliable than using other similar tools. You
can download it from a mirror site at http://varaneckas.com/jad/.
Dealing with ART
Android devices making use of the new Android Runtime (ART) convert DEX files into OAT files at installation
time. OAT files are essentially ELF dynamic objects that are run on the device and one would assume that they
would have to be treated like native code when reverse engineering them. A tool named oatdump performs a
similar disassembling function for OAT files as dexdump does for DEX files. Explore the options provided by this
tool if you are interested in disassembling an OAT file. However, similarly to dexdump the output is provided in
quite a raw manner.
One simple fact that can be used is that the APK file of each installed application is still stored on the device.
This means that the DEX file of your target application is still accessible in the normal way even when the
converted OAT file is being used on the device. Another interesting detail is that every OAT file contains the
original DEX file(s) embedded inside it. Pau Oliva created a script called oat2dex that can extract the DEX file(s)
from within a given OAT file. This script relies on radare2 (see http://www.radare.org/) and can be found at
https://github.com/poliva/random-scripts/blob/master/android/oat2dex.sh. This can be used if the original
APK containing the DEX is no longer available. At the time of writing reverse-engineering tools and techniques
for OAT files were still in active research by the security community.
Summary
Android is a unique operating system with some components that would be familiar to those who understand
the inner workings of Linux. However, the way in which applications work on Android is completely unique to
the platform. The security model provided for Android applications is complex but rich and requires you to have
a thorough understanding before you can analyze applications.
The tools available on Android for reverse engineers and hackers are mature and can be used to thoroughly
investigate application behavior and their underlying code. Using these tools it is possible to easily dig in and get
ready to start finding vulnerabilities in applications. This chapter presented all of the fundamental knowledge
required to move on to hacking Android applications and Chapter 7 will give you a kick start in doing just that!
CHAPTER 7
Attacking Android Applications
With everything you now know about Android applications and the environment under which they operate, you
would be correct in assuming that every developer cannot get everything right. Without a deep technical
understanding of every security mechanism at play, creating an application that has no vulnerabilities is tough
for a developer.
An attacker who is seeking to find vulnerabilities in an application should consider multiple approaches and
testing perspectives. The three high-level components to consider for each application are shown in Figure 7.1
and discussed in the list that follows.
Application container—Various ways may exist to defeat an application’s sandbox and gain access to
application data. Attack vectors could include a malicious application that has been installed on a device,
physical access to the device, or reviewing the application for other vulnerabilities.
Communications—Due to the choice of protocol and encryption implementation, intercepting and gaining
access to the data traversing a channel could be possible. Attack vectors could include ARP (Address
Resolution Protocol) poisoning, hosting a malicious wireless network or compromising upstream providers,
and positioning yourself to intercept and modify network traffic on a larger scale.
Internet server—A server that a mobile application communicates with may include vulnerabilities. Access
gained to this server will likely mean the complete compromise of information traversing from connected
mobile applications.
Figure 7.1 A high-level overview of various testing perspectives of an Android application
This chapter focuses heavily on attacking applications on a device and their communication channels with
Internet servers. This chapter does not cover vulnerabilities found in Internet servers. Dozens of publications
have discussed this vast topic in the past, and it will continue to change. Web service vulnerabilities or other
APIs that an application may communicate with are also not covered.
Before delving into attacking applications, we need to explore some application security model quirks that will
be used as the basis for attack later in the chapter.
Exposing Security Model Quirks
The Android security model is full of little quirks that are beneficial to know about when attempting to find
vulnerabilities in applications. This section covers the especially important quirks for application testers to
consider.
Interacting with Application Components
Applications on a device can interact with components that are exported. However, defining the conditions that
make a component “exported” is not simple and can differ depending on the version of Android in use.
Components can end up becoming exported to other applications running on the same device in three ways: by
the default export behavior, by being explicitly exported, and by being implicitly exported, as discussed next.
Default Export Behavior
Table 7.1 shows the default export behavior of each application component on different Android API versions.
Table 7.1 The Default Export Behavior of Each Application Component Across API Versions
APPLICATION COMPONENT EXPORTED (API = 17)
Activity False False
Broadcast receiver False False
Service False False
Content provider True False
In API version 17, which equates to Android 4.2 Jelly Bean, content providers are no longer exported by default.
However, if the targetSdkVersion of an application is set to 16 or lower, the content provider will still be
exported by default. You can read more about this security enhancement at http://android-
developers.blogspot.com/2013/02/security-enhancements-in-jelly-bean.html. This means that if the
declaration of a content provider does not specify an android:exported attribute, its exposure depends on what
version of Android the device is running. If it is running on Android 4.2 or above then it will depend on the
targetSdkVersion set in the  element of the manifest. If it is running on a device that is running a
version of Android before 4.2, the content provider is exposed. Here is an example of a content provider
manifest declaration lacking this explicit attribute:
Explicitly Exported
Application components can be explicitly marked as exported in the application manifest. This is the most
obvious way to know that a component is exported. The following is an example of an exported broadcast
receiver manifest declaration:
Implicitly Exported
Any component that makes use of an  is exported by default. This means that even intents that
aren’t explicitly targeting an application component’s intent filter can still be sent to the component. Here is an
example of an activity with an intent filter specified:
No android:exported attribute is specified and by default activities are not exported. However, because of the
intent filter present, this activity is still exported.
Finding Exported Components
You can find exported components of an application by inspecting the application’s manifest for the three
techniques mentioned. You can also use drozer from multiple viewpoints. The app.package.attacksurface
module is perfect for getting a high-level view of the exported components of an application. You run this
module against the Android browser as follows:
dz> run app.package.attacksurface com.android.browser
Attack Surface:
6 activities exported
4 broadcast receivers exported
1 content providers exported
0 services exported
For a more detailed view of the specific components exported, use the app..info modules. For
example, you can view the broadcast receivers exposed by the Android browser:
dz> run app.broadcast.info -a com.android.browser
Package: com.android.browser
com.android.browser.widget.BookmarkThumbnailWidgetProvider
Permission: null
com.android.browser.OpenDownloadReceiver
Permission: null
com.android.browser.AccountsChangedReceiver
Permission: null
com.android.browser.PreloadRequestReceiver
Permission: com.android.browser.permission.PRELOAD
For a more verbose view of any intent filters set on these components that may have caused the component to
become exported, use the -i flag on these modules.
Supreme User Contexts
In Chapter 6, you saw that the Android security model consists of a blend of a traditional UNIX file permission
enforcement model and custom kernel elements that control the access to assets using permissions. The two
most important user contexts that control these security functions are the root and system users.
With these user contexts having such powerful privileges on the OS, it is natural to expect that they can exert
control over installed applications as well. Let us shed some light on one particular fact: The root and system
users can interact with application components even when they are not exported. Whether an application
exports a component in its manifest or not is relevant only when the calling application is another non-system
application. Code running as root or system can interact with any component and send intents to them even
when they are not exported in their manifest. This means that an attacker who has gained this level of access to
a device can use it to send intents to components that were never intended to be accessible. Examples of
interacting with each application component in this way are explained in the relevant sections under the
“Attacking Application Components” portion of this chapter.
Application developers generally consider components that are not exported in their manifest to be private and
limited to internal use by the application. However, the issues that can be uncovered by abusing this level of
access is relatively low-risk because an attacker who has gained this level of access is able to do many worse
things on the compromised device. Chapter 8 explores these attacks in more depth. To find components that are
not exported by an application, you can examine the manifest or use the -u flag on any of the drozer app.
 .info modules.
TIP
The app.package.attacksurface module shows only application components that have been exported in
their manifest. This means that application components that have not been exported and can be attacked
from a privileged user context are not shown in this module’s output.
Permission Protection Levels
The best available protection against an unauthorized application being able to interact with an application
component is making use of a custom permission with protection level signature. This ensures that only
another application that was signed by the same certificate can be granted this permission.
However, on February 12, 2012, Mark Murphy described a scenario where the signature protection level could
be bypassed, and documented it at http://commonsware.com/blog/2014/02/12/vulnerabilities-custom-
permissions.html. He found that Android uses a “first one in wins” mentality in regard to protection levels on
permissions. This means that the first application to define a permission also sets the permission’s attributes
regardless of applications that may define the same permission after that. This will be referred to from this
point onward as a Protection Level Downgrade Attack. The following is the attack scenario:
1. An installed malicious application defines a set of known permission names from popular applications with a
protection level of normal.
2. The user then installs a popular application and the OS sees that one of the permissions is already defined.
This leads the OS to ignore the protection level of the permission and stick to the known parameters already
defined by the malicious application.
3. The permission that is supposed to be used to protect application components now has a downgraded
protection level of normal instead of another more secure value like signature. Even though the permission
was defined with a signature protection level, which was defined by the legitimate application, Android does
not know any different.
4. The malicious application can interact with the no-longer protected application components defined with the
downgraded permission.
As a proof of concept, we perform a practical example of this attack on the Twitter application here. The Twitter
application defines a number of permissions, which are bolded:
dz> run app.package.info -a com.twitter.android
Package: com.twitter.android
Application Label: Twitter
Process Name: com.twitter.android
Version: 5.31.0
Data Directory: /data/data/com.twitter.android
APK Path: /data/app/com.twitter.android-1.apk
UID: 10236
GID: [3003, 1028, 1015]
Shared Libraries: null
Shared User ID: null
Uses Permissions:
- com.twitter.android.permission.C2D_MESSAGE
- com.twitter.android.permission.RESTRICTED
- com.twitter.android.permission.AUTH_APP
- android.permission.INTERNET
- android.permission.ACCESS_NETWORK_STATE
- android.permission.VIBRATE
- android.permission.READ_PROFILE
- android.permission.READ_CONTACTS
- android.permission.RECEIVE_SMS
- android.permission.GET_ACCOUNTS
- android.permission.MANAGE_ACCOUNTS
- android.permission.AUTHENTICATE_ACCOUNTS
- android.permission.READ_SYNC_SETTINGS
- android.permission.WRITE_SYNC_SETTINGS
- android.permission.ACCESS_FINE_LOCATION
- android.permission.USE_CREDENTIALS
- android.permission.SYSTEM_ALERT_WINDOW
- android.permission.WAKE_LOCK
- android.permission.WRITE_EXTERNAL_STORAGE
- com.twitter.android.permission.READ_DATA
- com.google.android.c2dm.permission.RECEIVE
- com.google.android.providers.gsf.permission.READ_GSERVICES
- com.twitter.android.permission.MAPS_RECEIVE
- com.android.launcher.permission.INSTALL_SHORTCUT
- android.permission.READ_PHONE_STATE
- com.sonyericsson.home.permission.BROADCAST_BADGE
- com.sec.android.provider.badge.permission.READ
- com.sec.android.provider.badge.permission.WRITE
- android.permission.CAMERA
- android.permission.ACCESS_WIFI_STATE
- android.permission.READ_EXTERNAL_STORAGE
Defines Permissions:
- com.twitter.android.permission.READ_DATA
- com.twitter.android.permission.MAPS_RECEIVE
- com.twitter.android.permission.C2D_MESSAGE
- com.twitter.android.permission.RESTRICTED
- com.twitter.android.permission.AUTH_APP
To build a drozer agent that requests the defined permissions use the following command:
$ drozer agent build --permission com.twitter.android.permission
.READ_DATA
com.twitter.android.permission.MAPS_RECEIVE
com.twitter.android.permission.C2D_MESSAGE
com.twitter.android.permission.RESTRICTED
com.twitter.android.permission.AUTH_APP
Done: /tmp/tmpNIBfbw/agent.apk
Installing the newly generated agent and checking logcat reveals that only a single permission was granted: the
com.twitter.android.permission.AUTH_APP permission. At this point, interacting with any protected application
components on the Twitter application correctly results in a permission denial. You can test this on any
permission-protected application component, but here is a look at the content providers exposed by Twitter:
dz> run app.provider.info -a com.twitter.android
Package: com.twitter.android
Authority: com.twitter.android.provider.TwitterProvider
Read Permission: com.twitter.android.permission.RESTRICTED
Write Permission: com.twitter.android.permission.RESTRICTED
Content Provider: com.twitter.library.provider.TwitterProvider
Multiprocess Allowed: False