title:Fast and automated generation of attack signatures: a basis for building
self-protecting servers
author:Zhenkai Liang and
R. Sekar
Fast and Automated Generation of Attack Signatures:
A Basis for Building Self-Protecting Servers (cid:3)
Zhenkai Liang and R. Sekar
Dept. of Computer Science, Stony Brook University
Stony Brook, NY, USA
fzliang, PI:EMAIL
ABSTRACT
Large-scale attacks, such as those launched by worms and zombie
farms, pose a serious threat to our network-centric society. Exist-
ing approaches such as software patches are simply unable to cope
with the volume and speed with which new vulnerabilities are being
discovered. In this paper, we develop a new approach that can pro-
vide effective protection against a vast majority of these attacks that
exploit memory errors in C/C++ programs. Our approach, called
COVERS, uses a forensic analysis of a victim server’s memory to
correlate attacks to inputs received over the network, and automati-
cally develop a signature that characterizes inputs that carry attacks.
The signatures tend to capture characteristics of the underlying vul-
nerability (e.g., a message ﬁeld being too long) rather than the char-
acteristics of an attack, which makes them effective against variants
of attacks. Our approach introduces low overheads (under 10%),
does not require access to source code of the protected server, and
has successfully generated signatures for the attacks studied in our
experiments, without producing false positives. Since the signa-
tures are generated in tens of milliseconds, they can potentially be
distributed quickly over the Internet to ﬁlter out (and thus stop) fast-
spreading worms. Another interesting aspect of our approach is that
it can defeat guessing attacks reported against address-space ran-
domization and instruction set randomization techniques. Finally,
it increases the capacity of servers to withstand repeated attacks by
a factor of 10 or more.
Categories and Subject Descriptors
K.6.5 [Security and Protection]: Unauthorized access, Invasive
software
General Terms
Security, Management
Keywords
Memory error, Buffer overﬂow, Signature generation, Denial-of-
service protection, Worm defense
(cid:3)This
N000140110967 and an NSF grant CCR-0208877.
supported in part by an ONR grant
research is
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’05, November 7–11, 2005, Alexandria, Virginia, USA.
Copyright 2005 ACM 1-59593-226-7/05/0011 ...$5.00.
1.
Introduction
The past few years have witnessed an alarming increase in large-
scale attacks: automated attacks carried out by large numbers of
hosts on the Internet. These may be the work of worms, zombies,
or large numbers of hackers running attack scripts. Such attacks
have the following characteristics: they originate from many dif-
ferent hosts, target a non-negligible fraction of vulnerable hosts on
the Internet, and are repetitive. Buffer overﬂow attacks (or more
generally, attacks that exploit memory errors in C/C++ programs)
are the most popular choice in these attacks, as they provide sub-
stantial control over a victim host. For instance, virtually every
worm known to date has been based on this class of attacks.
The best protection available today against such large-scale at-
tacks is the deployment of software patches that correct the under-
lying software ﬂaw targeted by the attack. The beneﬁt of this ap-
proach is that it can ﬁlter out attacks without impacting legitimate
requests. Moreover, neither the performance nor the availability
of a patched application is degraded by attacks. Unfortunately,
patches are not available for previously unknown vulnerabilities
that are targeted by zero-day attacks. Even for known vulnerabili-
ties, there is often a long period of time between the identiﬁcation
of a vulnerability and the availability of a patch; and a further delay
in installation of these patches due to the need for extensive testing
at each site where the software is deployed. Consequently, patches
aren’t adequate against large-scale, repetitive attacks.
A second line of defense against zero-day attacks is memory-
error exploitation detection techniques such as StackGuard [10],
address-space randomization [1, 4, 5], and complete memory-error
protection [13, 14, 20, 27, 41]. Although these techniques can de-
tect attacks before system resources (e.g., ﬁles) are compromised,
they cannot protect the victim process itself, whose integrity is
compromised by the time of detection. For this reason, the safest
approach for recovery is to terminate the victim process. With
repetitive attacks, such an approach will cause repeated server
restarts, effectively rendering its service unavailable during peri-
ods of attack. Even worse, [29, 35] have shown how such repeti-
tive attacks can defeat probabilistic protection techniques such as
address-space and instruction set randomization.
In contrast to the above approaches, we present a new approach
that can provide effective protection against large-scale, repetitive
attacks. Our approach, called COVERS (COntext-based,
VulnERability-oriented Signature), is based on automatic genera-
tion of attack signatures by observing ongoing attacks, and using
these signatures to ﬁlter out future occurrences of these attacks. By
doing so, our approach preserves not only the integrity of the ser-
vice, but also its availability. The ﬁlters can deployed inside the ad-
dress space of a protected server (by intercepting library calls that
read network input) or as an in-line network ﬁlter. Our signatures
tend to capture the underlying vulnerability, which means that they
would likely block other attacks exploiting the same vulnerability.
This makes the approach effective against polymorphic worms.
1.1 Overview of Approach and Key Contributions
Our approach relies on the following four steps to generate attack
signatures:
(cid:15) Attack detection. We can use previously developed techniques
for detecting buffer overﬂow attacks, such as StackGuard [10],
address-space randomization (ASR) [1, 4, 5], and instruction-set
randomization (ISR) [3, 15].
(cid:15) Correlation to input. The correlation step identiﬁes the speciﬁc
network packet (or ﬂow) involved in an attack, and the bytes
within this packet that were responsible. This enables the signa-
ture search to be focused on the relevant parts of input, enabling
higher-quality signature generation. Previous work [22] has sug-
gested the use of taint analysis to track the input data that led to
the attack, but their implementation incurs signiﬁcant runtime
overheads, often slowing down programs by a factor of 10.
A key contribution of this paper is that of developing efﬁcient
techniques for correlation. Our approach is based on the observa-
tion that all known memory error exploits involve corruption of
pointer values, and that this value must be included in the attack
input. Based on this observation, we develop a forensic analysis
of the victim process memory to identify the memory region sur-
rounding the corrupted pointer value, and match this region with
recent inputs. Since the correlation step is performed only when
an attack is detected, it does not impact the performance of the
server during normal operation.
(cid:15) Identifying input context. This step is concerned with identify-
ing the logical input context within which an attack appears. For
instance, an attack may appear within a particular ﬁeld of a spe-
ciﬁc type of message. Knowing this information, we can restrict
signature matching to this ﬁeld, thereby avoiding some false pos-
itives that may otherwise arise. In addition, note that it is likely
that the same piece of code processes a particular message ﬁeld.
An attacker that wishes to exploit a vulnerability in this code
needs to embed the attack in this message ﬁeld, thereby making
it harder to evade detection. This contrasts with approaches that
use byte offsets to identify attack context, since these offsets can
be easily changed by modifying the length of some (benign) ﬁeld
preceding the vulnerable ﬁeld.
Our approach uses a simple speciﬁcation of message formats
(consisting of a few lines for most services) to guide the input
context identiﬁcation step. The relevant information for these
speciﬁcations is readily available from network protocol speciﬁ-
cations such as the IETF RFCs.
Development of input-context-aware signatures is another im-
portant contribution of this paper. In our experiments, this step
was necessary for generating accurate signatures in ﬁve out of
seven attacks. Previous approaches have largely ignored this
step, compensating for this weakness either by requiring a large
number of attack instances, which delays signature generation;
or by including non-essential details in the attack signature, rais-
ing the odds of false negatives.
(cid:15) Signature generation. This step exploits the characteristics of
the underlying vulnerability, such as excessively long message
ﬁelds or the presence of binary data within text-valued ﬁelds.
1.2 Beneﬁts of Approach
We have experimentally evaluated the effectiveness and perfor-
mance of our approach, as described in Section 7. Our experiments
involved several popular server programs, and exercised different
types of buffer overﬂow attacks such as stack-smashing, heap over-
ﬂows, and format-string attacks. These results demonstrate the fol-
lowing beneﬁts of our approach.
(cid:15) Effectiveness against attacks. Our approach generated effective
signatures to stop all the attacks used in our experiment.
(cid:15) Fast generation of signatures. Our approach is typically able
to generate signatures with just a single sample, and the overall
time for signature generation is of the order of ten milliseconds.
(cid:15) Low overheads under normal operation. Our approach intro-
duces low overheads of under 10% during normal operation.
(cid:15) No false positives. For all the attacks evaluated, our approach
does not produce any false positives.
(cid:15) Applicable to COTS software, without access to source. Our ap-
proach does not require any modiﬁcations to the protected server
software, or access to its source code.
These features of the approach make it possible to achieve the fol-
lowing objectives using our approach.
(cid:15) Effective protection against denial-of-service effect of repet-
itive attacks. Servers protected by our technique were able to
withstand repetitive attacks at a rate that is at least 10 times
higher than that of unprotected servers.
(cid:15) Protection from attacks on randomization.
[29] has devel-
oped an attack that defeats the 16-bits of randomness in PaX [1]
by using an attack that successively tries out all possible 16-bit
values. Our approach can defend against this attack by ﬁltering
out all but the ﬁrst few attack attempts. In a similar manner, our
approach can also defend against guessing attacks on instruction
set randomization [35].
(cid:15) Protection from polymorphic attacks. Our approach tends
to generate signatures that characterize underlying vulnerability,
e.g., excessive length of a message ﬁeld, rather than speciﬁc de-
tails such as the instruction sequence contained within an attack.
As a result, these signatures can stop attack variants that exploit
the same vulnerability.
(cid:15) Network-wide signature deployment to defeat fast-spreading
attacks. The speed of our signature generation makes it possi-
ble to distribute and deploy these signatures in the Internet to
stop fast-spreading worms. Moreover, the nature of our signa-
tures permit the receivers of signatures to verify them before de-
ployment — they can compare the signatures against their recent
input, and verify that the signature would not cause recently re-
ceived legitimate inputs to be discarded.
1.3 Organization of the Paper
The rest of the paper is organized as follows. We describe the
four steps in our approach in Sections 2–5.
Implementation of
these steps in described in Section 6. We evaluate our approach
in Section 7. Related work is discussed in Section 8, followed by
concluding remarks in Section 9.
2. Attack Detection
For attack detection, we can make use of any of the existing tech-
niques for memory-error exploit protection, such as StackGuard
[10, 11, 7], address-space randomization (ASR) [1, 4, 5], instruc-
tion set randomization (ISR) [3, 15], and complete memory-error
protection [13, 14, 20, 27, 41]. Of these techniques, we use ASR
in this paper, since it provides broad coverage against memory er-
ror exploits, has low overheads, and unlike complete memory error
protection techniques, does not pose any backward compatibility
problems.
Process Memory Space(cid:13)
Segmentation Fault(cid:13)
At M(cid:13)
Malicious(cid:13)
...(cid:13)
Input(cid:13)
A(cid:13) B(cid:13) C(cid:13) D(cid:13) E(cid:13) F(cid:13) G(cid:13) H(cid:13) I(cid:13) J(cid:13) K(cid:13) L(cid:13) M(cid:13)N(cid:13)
a1:(cid:13)
a2:(cid:13)
a3:(cid:13)
Q(cid:13) R(cid:13)
...(cid:13)
O(cid:13) P(cid:13)
X(cid:13)
X(cid:13)
D(cid:13)
E(cid:13)
F(cid:13)
G(cid:13)
H(cid:13)
I(cid:13)
J(cid:13)
K(cid:13)
L(cid:13)
M(cid:13)
N(cid:13)