4.4C++相关问题
115
须在main函数之后被执行，其中很具有代表性的就是C++的全局对象的构造和析构函数。
因此ELF文件还定义了两种特殊的段。
·.init该段里面保存的是可执行指令，它构成了进程的初始化代码。因此，当一个程序开
始运行时，在main 函数被调用之前，Glibc的初始化部分安排执行这个段的中的代码。
·.ini该段保存着进程终止代码指令。因此，当一个程序的main函数i正常退出时，Glibc
会安排执行这个段中的代码。
这两个段.init和Lfini 的存在有着特别的目的，如果一个函数放到.init 段，在main 函数执
行前系统就会执行它。同理，假如一个函数放到.fint 段，在main函数返回后该函数就会被
执行。利用这两个特性，C++的全局构造和析构函数就由此实现。我们将在第11章中作详
细介绍。
4.4.3C++与ABI
既然每个编译器都能将源代码编译成目标文件，那么有没有不同编译器编译出来的目标
文件是不能够相互链接的呢？有没有可能将MSVC编译出来的目标文件和GCC编译出来的
目标文件链接到一起，形成一个可执行文件呢？
对于上面这些问题，首先我们可以想到的是，如果要将两个不同编译器的编译结果链接
到一起，那么，首先链接器必须支持这两个编译器产生的目标文件的格式。比如MSVC编译
的目标文件是PE/COFF格式的，而GCC编译的结果是ELF格式的，链接器必须同时认识这
两种格式才行，否则肯定没戏。那是不是链接器只要同时认识目标文件的格式就可以了呢？
事实并不像我们想象的那么简单，如果要使两个编译器编译出来的目标文件能够相互链
接，那么这两个目标文件必须满足下面这些条件：采用同样的目标文件格式、拥有同样的符
号修饰标准、变量的内存分布方式相同、函数的调用方式相同，等等，其中我们把符号修饰
标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为ABI
(Application Binary Interface )。
ABI&AP
很多时候我们会碰到API（Application Programming Interface）这个念，它与 ABI
只有一字之差，而且非常类似，很多人经常将它们的横念搞混。那么它们之间有什么
区别呢？实际上它们都是所请的应用程序接口，只是它们所描述的接口所在的层面不
一样。API往往是指源代码级别的接口，比如我们可以说POSIX是一个API标准、
Windows所规定的应用程序接口是一个 API：而ABI是指二进制层面的接口，ABI 的
康容程度比APl要更为严格，比如我们可以说C++的对家内存分布（ObjectMemory
Layout）是C++ABI的一部分。API 更关注源代码层面的，比如 POSIX规定printfo
程序员的自我修养一链接、装载与库
---
## Page 139
116
第4章静态链接
这个函数的原型，它能保证这个函数定义在所有遵循POSIX标准的系统之间都是一样
的。但是它不保证printf在实际的每个系统中执行时，是否按照从右到左将参数压入
堆栈，参数在堆栈中如何分布等这些实际运行时的二进制级别的问题。比如有两台机
器，一台是Intel x86，另外一台是MIPS 的，它们都安装了Linux系统，由于Linux
支持POSIX标准，所以它们的C运行库都应该有printf函数。但实际上printf在被调
用过程中，这些关于参数和堆栈分布的细节在不同的机器上肯定是不一样的，甚至调
用 printf 的指令也是不一样的（x86 是 call 指令，MIPS 是 jal 指令），这就是说，API
相同并不表示ABI相同。
ABI的概念其实从开始至今一直存在，因为人们总是希望程序能够在不经任何修改的
情况下得到重用，最好的情况是二进制的指令和数据能够不加修改地得到重用。人们
始终在朝这个方向努力，但是由于现实的因素，二退制级别的重用还是很难实现。最
大的问题之一就是各种硬件平台、编程语言、编译器、链接器和操作系统之间的ABI
相互不兼容，由于ABI的不兼容，各个目标文件之间无法相互链接，二进制兼容性更
加无从谈起。
影响ABI的因素非常多，硬件、编程语言、编译器、链接器、操作系统等都会影响ABI。
我们可以从C语言的角度来看一个编程语言是如何影响ABI的。对于C语言的目标代码米
说，以下几个方面会决定目标文件之间是否二进制兼容：
·内置类型（如int、floal、char等）的大小和在存储器中的放置方式（大端、小端、对
齐方式等）
·组合类壁（如 struct、union、数组等）的存储方式和内存分布。
·外部符号（extemal-linkage）与用户定义的符号之间的命名方式和解析方式，如函数名
func在C语言的目标文件中是否被解析成外部符号_func。
·函数调用方式，比如参数入栈顺序、返回值如何保持等。
·堆栈的分布方式，比如参数和局部变量在堆栈里的位置，参数传递方法等。
·寄存器使用约定，函数调用时哪些寄存器可以修改，哪些须要保存，等等。
当然这只是一部分因素，还有其他因素我们在此不一一列举了，到了C++的时代，语言
层面对ABI的影响又增加了很多额外的内容，可以看到，正是这些内容使C++要做到二进
制兼容比C来得更为不易：
·继承类体系的内存分布，如基类，虚基类在继承类中的位置等。
·指向成员函数的指针（pointer-to-member）的内存分布，如何通过指向成员函数的指
针来调用成员函数，如何传递this指针。
·如何调用虚函数，vtable 的内容和分布形式，vtable 指针在object中的位置等。
·template 如何实例化
程序员的自我修养一链接、装载与库
---
## Page 140
4.5静态库链接
117
·外部符号的修饰。
全局对象的构造和析构。
·异常的产生和捕获机制。
·标准库的细节问题，RTTI如何实现等。
·内嵌函数访问细节。
C++一直为人垢病的一大原因是它的二进制兼客性不好，或者说比起C语言来更为不
易。不仅不同的编泽器编译的二进制代码之间无法相互兼容，有时候连同一个编译器的不同
版本之间兼容性也不好。比如我有一个库A是公司 CompanyA用CompilerA编译的，我有
另外一个库B是公司CompanyB用CompilerB编译的，当我想写一个C++程序来网时使用
库A和B将会很是棘手，有人说，那么我每次只要用同一个编译器编译所有的源代码就能
解决问题了。不错，对于小型项目来说这个方法的确可行，但是考虑到一些大型的项目，以
上的方法实际上并不可行。
很多时候，阵厂商往往不希望库用户看到库的源代码，所以一般是以二进制的方式提供
给用户，这样，当用户的编译器型号与版本与编译库所用的编译器型号和版本不同时，就可
能产生不兼容。如果让库的厂商提供所有的编译器型号和版本编译出来的库给用户，这基本
上不现实，特别是厂商对库已经停止了维护后，使用这样陈年老“库”实在是一件令人头痛
的事。以上的情况对于系统中已经存在的静态库或动态库须要被多个应用程序使用的情况也
几乎相同，或者一个程序由多个公司或多个部门起开发，也有类似的间题。
所以人们一直期待若能有统一的C++二进制兼容标准（C++ABI），诸多的团体和社区
都在致力于C++ABI标准的统一。但是目前情况还是不容乐戏，基本形成以微软的VISUAL
C++和GNU 阵营的GCC（采用Intel Itanium C++ABI标准）为首的两大派系，各持已见互
不兼容。早先时候，*NIX系统下的ABI也十分混乱，这个情况一直延续到LSB（Linux
Standard Base）和 Intel 的Itanium C++ABI标准出来后才有所改善，但并未彻庭解决ABI
的问题，由于现实的因素，这个问题还会长期地存在，这也是为什么有这么多像我们这样的
程序员能够存在的原因。
4.5
静态库链接
程序之所以有用，因为它会有输入输出，这些输入输出的对象可以是数据，可以是人，
也可以是另外一个程序，还可以是另外一台计算机，一个没有输入输出的程序没有任何意义。
但是一个程序如何做到输入输出呢？最简单的办法是使用操作系统提供的应用程序编程接
口（APl,Application ProgrammingInterface）。当然，操作系统也只是一个程序，它怎么
程序员的自我修养一链接、装载与库
---
## Page 141
第4章静态链接
统和VO时己经简单介绍过了。
让我们还是先回到--个比较初步的问题，就是程序如何使用操作系统提供的API。在一
般的情况下，一种语言的开发环境往往会附带有语言库（Language Library）。这些库就是
对操作系统的API的包装，比如我们经典的C语言版“Hello World”程序，它使用C语言
标准库的“printf”两数米输出一个字符串，“printr”函数对字符串进行一些必要的处理以后，
最后会调用操作系统提供的API，各个操作系统下，往终端输出字符串的API都不一样，在
Linux下，它是一个“write”的系统调用，而在Windows 下它是“WriteConsole”系统API.
库里面还带有那些很常用的函数，比如C语言标准库里面有很常用一个函数取得一个
字符串的长度叫strlenO)，该函数即遍历整个字符申后返回字符串长度，这个函数并没有调
用任何操作系统的API，也没有做任何输入输出。但是很大一部分库函数都是要调用操作系
统的API的，比如最常用的往终端输出格式化字符串的printf 就是会调用操作系统，往终端
里面打印一些字符串。我们将在第4部分更加详细地介绍库的概念，这里我们只是简单地介
绍静态库的链接过程。
其实一个静态库可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后
形成的一个文件。比如我们在Linux中最常用的 C语言静态库 libe 位于/usr/lib/libc.a，它属
于glibc项目的一部分：像Windows 这样的平台上，最常使用的C语言库是由集成开发环境
所附带的运行库，这些库一般由编译器厂商提供，比如Visual C++附带了多个版本的C/C++
运行库。表43列出了VC2008（内部版本号VC9）所附带的一部分C运行库（库文件存故
在VC安装目录下的lib目录）。
表4-3
C运行库
相关DLL
描述
libcmt.lib
Multithreaded Static多线程静态库
msvcrt.lib
msvcr90.d11
Multithreaded Dynamic多线程动态年
libcmtd.lib
Multithreaded Static Debug 多线程静态调试库
msvcnd.lib
msvcrt90d.dl1
Multithreaded Dynamic Debug多线程动态调试库
表43中只是简单列举了几种C语言运行库，我们在这里将介绍一个程序的目标文件如
何与C语言运行库链接形成一个可执行文件，关于库的更详细内容，将在第4部分展开讨论。
我们知道在一个C语言的运行库中，包含了很多跟系统功能相关的代码，比如输入输
出、文件操作、时间日期、内存管理等。glibc本身是用C语言开发的，它由成百上千个C
语言源代码文件组成，也就是说，编译完成以后有相同数量的目标文件，比如输入输出有
printf.o. scanf.o:文件操作有 fread.o,[write.o:时间日期有 date.o, time.o:内存管理有malloc.
等。把这些零收的目标文件直接提供给库的使用者，很大程度上会造成文件传输、管理和组
织方面的不便，于是通常人们使用“ar”压缩程序将这些目标文件压缩到一起，并且对其进
程序员的自我修养一链接、装载与库
---
## Page 142
4.5静态库链接
119
行编号和索引，以便于查找和检索，就形成了libc.a这个静志库文件。在我的机器上，该文
件有2.8MB大小，我们也可以使用“ar”工具来查看这个文件包含了哪些目标文件：
$ar -t 1ibc.a
init-first.o
libc-start.o
sysdep.o
version,o
check_fds.o
libc-t1s,o
elf-init,o
dso_handle.o
errno.o
iconv_open.o
errno-loc,0
lconv.o
gconv_open.o
iconv_close,o
gconv.o
gconv_close.0
gconv_conf .o
gconv_db.o
提
VisualC++也提供了与Linux下的ar类似的工具，叫lib.exe，这个程序可以用来创建、
示
提取、列举，ib 文件中的内客。使用“Bb /LIST libocmt.ib”就可以列举出 Iibcmt.ib 中所
有的目标文件。VisualC++ibcmt.ib中包含949个目标文件。具体参数请参照MSDN。
Iibc.a里面总共包含了1400个目标文件，那么，我们如何在这么多目标文件中找到
$objdump -t 1ibc.a
printf.o!
file fornat elf32-i386
SYMBOL TABLE:
00000000 1
d.text
1x00000000
000000001
.data
00000000 .data
000000001
00000000
1
d
.commentooooo0o0.comment
.b88
00000000
.b8s
00000000
00000000
1
d
,note.GNU-stack
00000026
00000000.note.GNU-stack
00000000
9
P
.text,
*UND*
3nop2800000000
—printf
00000000 g
00600600
F.text
*UND*
000o0026 printf
00000ooo vfprintf
00000000 g
F.text
11d0192000000
 + 1
可以看到“printf”函数被定义在了“printf.o”这个目标文件中。这里我们似乎找到了
最终的机制，那就是“HelloWorld”程序编译出来的目标文件只要和libc.a里面的“printf.o”
程序员的自我修养一链接、装载与库
---
## Page 143
120
第4章静态链接
链接在起，最后就可以形成一个可用的可执行文件了，这个解释似乎很完美，实际上已经
很接近最后的答案了，那么我们就按照这个方案去尝试一下，假设“HelloWorld”程序的源
代码为“hello.c”，使用如下方法编译：
$gcc -c -fno-builtin hello.c
换成“puts”函数，以提高运行速度，我们要使用“-fno-builtin”关闭这个内置函数优化选
项。现在我们还缺“printf.o”，通过“ar”1具解压出“printf.o”
$ar -x 1ibc.a
这个命令会将libc.a中的所有目标文件“解压”至当前口录。我们也可以找到“printf.o”
然后将其与“hello.o”链接在一起：
$1d hello.o printf.o