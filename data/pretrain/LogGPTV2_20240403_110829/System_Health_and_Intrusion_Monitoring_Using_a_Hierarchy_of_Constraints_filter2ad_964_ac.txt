generic constraints are developed based on well-studied security policies and
computer system design principles, historical behavior of the system, existing
attacks, and vulnerability models [16,17]. For example, some well-studied policies
for integrity and availability, such as the Clark-Wilson model [12], the Biba
System Health and Intrusion Monitoring Using a Hierarchy of Constraints
199
integrity model [13], and the Type Enforcement model [14] can be applied in
the process. In addition, well-established design principles (e.g., least privileges,
least common mechanisms, fail-safe defaults) for building secure systems [15]
are considered. These policies and principles have been applied in modeling,
design, and implementation of secure systems to restrict their operations to
achieve security goals and resist threats. However, existing systems do not take
these principles seriously. Our rationale is that although these constraints are
not directly enforced by existing systems, they can be monitored for violations
so that corrective actions can be performed to avoid security failures. As the
constraints are developed not just based on existing attacks, it can detect attacks
that we have not seen before.
4 Example Constraints and Implementation
In this section we describe several interesting constraints developed based on
the constraint model. In addition, we describe the implementation of these con-
straints. The constraints restrict the behavior of various components in a com-
puter system, including programs, protocols, and critical data. To be eﬀective,
one needs to identify the important components in a system to constrain, which
depends on the policy that one wants to enforce and the security goal one wants
to achieve. In this research, we initially focus on constraints for components that
run with special privileges (e.g., root in Unix) and entities that are highly re-
lated to these privileged components (e.g., protocols used by them). The goal is
to protect the system from malicious normal user.
4.1 Host-Based Constraints: Privileged Programs and Data
We have developed constraints of diﬀerent types for privileged programs. One
useful type of constraints for privileged programs are access constraints, which
restrict the ﬁles that can be accessed by a program. In general, one could iden-
tify the rules for restricting the accesses of a program based on its functionality,
usage, and the system security policy [5,7]. For example, the following access con-
straint of FTP expressed in English should be able detect the attack mentioned
in Section 2.1 regardless how the attacker twists the message.
1. Read ﬁles that are worldreadable
2. Write ﬁles that are owned by the user
3. Execute only /bin/ls, /bin/gzip, /bin/tar, /bin/compress
4. Chmod or chown no ﬁles
We are in the process of developing access constraints for all setuid root
programs and root servers/daemons in a standard Linux system. Many example
access constraints have been developed [5,7]; we will not discuss them in depth
here.
Other interesting constraints for privileged programs include constraints on
how it passes control to a user and how it deals with temporary ﬁles, written
informally in English as follow:
200
C. Ko et al.
A privileged process should discard all its privileges and capabilities before
it gives control to a user, such as executing a shell-type program or a
program created by a user – C1.
The temporary ﬁle for a program should be accessible only by the program
execution and should be removed when the program exits – C2.
In Unix, the ﬁrst constraint would require a privileged process to reset the
real and eﬀective user ID to that of the user, as well as the real and eﬀective
group ID to that of the user. Also, it requires the privileged process to close any
ﬁle descriptors on ﬁles that the user has no authority to access. Such constraint
can detect any attacks that attempt to use the capability (e.g., a ﬁle descriptor
for reading the shadow password ﬁle) left over by privileged processes [18]. The
second constraint could detect attackers tampering with the temporary ﬁles used
by privileged programs.
In addition, we have developed data constraints on valid values of security-
critical data. For example, the following constraints for the password ﬁle should
alarm on any modiﬁcation of password ﬁle that create a root account with no
password.
The password ﬁle /etc/passwd should be in the correct form and each user
deﬁned in the ﬁle should have a password – C3.
So far, we have implemented an access constraint compiler for translating ac-
cess constraint expressed in PE-Grammar [6] into a C++ object that can analyze
the audit data for violation. The Generic Software Wrapper [11] is employed to
provide audit data for monitoring host-level activity. The kernel resident Generic
Software Wrapper has proven to be an eﬀective way for eﬃciently collecting au-
dit data. The use of ﬂexible audit mechanism such as wrapper is important. For
example, we can use wrapper to provide information about the real and eﬀec-
tive user (group) ID of a process as well as the permission mode of all the ﬁles
opened by a process before it executes a user program; such data is necessary
for checking whether a privileged program violate the constraint C1.
4.2 Network-Based Constraints: Address Resolution Protocol
(ARP)
We have developed two constraints for the ARP protocol. In general, one can
develop operational constraints to restrict how various messages in a protocol are
exchanged as well as data constraints to conﬁne values of data in the messages.
The ﬁrst constraint for ARP could be a data constraint requiring that the
Ethernet-to-IP address mapping in any ARP message must be correct - the map-
ping should agree with an authoritative database that keeps all Ethernet to IP
mapping in the local area network. However, monitoring such constraint will
require additional work in maintaining the authoritative database. In addition,
it contradicts with one of the goal of ARP, which is to provide automatic sup-
port for dynamic address mapping. Such constraint will work in a very static
System Health and Intrusion Monitoring Using a Hierarchy of Constraints
201
environment in which no mobile machines are presented. However, it will not
work well in a very dynamic networking environment.
In addition, we have developed an operational constraint for the ARP proto-
col. Figure 3 speciﬁes the correct operational behavior of ARP protocol using a
state transition diagram. From the initial state, an ARP request on the network
asking for an IP address mapping moves the system to the “Reply wait” state
for that particular address. Additional address requests coming while in this
state have no eﬀect since it is perfectly valid for machines to resend the request
if they weren’t answered in a timely fashion. After the response message is seen,
the system moves to the “Cached” state. Finally, after the timeout, the system
moves back to the initial state.
ARP Request
initial
ARP Request
reply_wait
cached
ARP Response
ARP cache timeout
Fig. 3. A Constraint for the ARP Protocol.
We have implemented a simple network monitor for checking the ARP opera-
tional constraint. The monitor is implemented as a pre-processor to the SNORT
open source IDS. All ARP traﬃc on a local network is used to move the system
through the series of states, keeping track of valid IP address to MAC address
mappings. Due to the relatively small volume of ARP traﬃc in general, our sys-
tem is easily able to handle the ARP traﬃc generated by the 50 machines in our
monitored domain.
Using the single speciﬁcation for correct ARP behavior, the network moni-
tor is able to identify all of these variants of the ARP cache poisoning attack
described in Section 2.3. These all known methods of ARP cache poisoning
attacks, spanning multiple versions and operating systems, are detectable as in-
correct and, therefore disallowed ARP protocol transactions. There are, however,
considerable false reports due to DHCP automatic allocation of IP addresses.
To remove these false alarms, we are currently developing a speciﬁcation for
DHCP itself. This speciﬁcation would not only monitor for misuse of the DHCP
protocol, but DHCP speciﬁc transitions will feed into the ARP protocol speciﬁ-
cation, indicating that a particular ARP message is perfectly valid in the DHCP
context.
202
C. Ko et al.
4.3 Application Constraints
This subsection describes an application constraints motivated by the following
example.
The program Joe is a user-friendly text editor originally written by Joseph
Allen and currently maintained by the open source community. When started,
the application loads a hidden conﬁguration ﬁle called .joerc if it exists in the
current working directory. The ﬁle .joerc may contain instructions for the text
editor to execute arbitrary command.
An malicious user can created a carefully crafted .joerc ﬁle in a world-writable
directory. So that whenever a diﬀerent user (e.g. root) edits a ﬁle in that world
writable directory, the instruction speciﬁed in the .joerc ﬁle will be executed with
the permissions of the person editing the ﬁle. The constraint C4 stated below
can detect such misuse:
An application should read only conﬁguration ﬁles owned by the user whom
it is running as – C4.
5 Conclusions and Future Work
In this paper, we present an approach to real-time security monitoring of a
distributed system using a hierarchy of constraints. The approach conﬁnes the
behavior of system components at various levels of abstraction to increase the
detection coverage. We discuss the constraint model and provide several example
constraints for privileged programs, critical data, and the ARP protocol. The
constraints are implemented as a host-based analyzer that examines the audit
data generated by wrappers or as a pre-processor to the SNORT open source IDS.
The constraints developed using the methodology are highly eﬀective in detecting
intrusions. In addition, the development process is not just based on existing
attacks and vulnerability, but also knowledge on the system, its functionality,
and historical behavior. We strongly believe that the best rules for distinguishing
intrusions from legitimate activity have to take all these aspects into account.
Future work on this project will include developing diﬀerent types of con-
straints for more components and evaluating their eﬀectiveness. In addition, it
is important to identify a way to measure or estimate the eﬀectiveness of con-
straints as well as the cost of monitoring the constraints to allow analysis. Also, a
methodology for tailoring the constraints to a speciﬁc environment is required. It
would also be helpful to have a uniﬁed language for specifying the constraints so
that it can be automatically translated to an enforceable representation. Last,
a formal methodology for reasoning about the constraints would be useful to
understand the overall policy achieved by the constraints.
References
1. K. Ilgun, R. Kemmerer, and P. Porras , “State Transition Analysis: A Rule-
based Intrusion Detection Approach”, IEEE Transactions of Software Engineering,
2(13):181-199, March 1995.
System Health and Intrusion Monitoring Using a Hierarchy of Constraints
203
2. U. Lindqvist and P. Porras, “Detecting Computer and Network Misuse Through
the Production-Based Expert System Toolset (P-BEST)”, In Proceedings of the
1999 Symposium on Security and Privacy, May 1999.
3. H. Javitz and A. Valdes, “The NIDES Statistical Component Description and
Justiﬁcation,” Technical Report, Computer Science Laboratory, SRI International,
Menlo Park, CA , Mar 1994.
4. R. Lippmann et. al., “Evaluating Intrusion Detection Systems: The 1998 DARPA
Oﬀ-Line Intrusion Detection Evaluation,” DISCEX 2000 - DARPA Information
Survivability Conference and Exposition, Hilton Head, SC, 2000.
5. C. Ko, G. Fink and K. Levitt, “Automated Detection of Vulnerabilities in Privi-
leged Programs by Execution Monitoring”, In Proceedings of the 10th Computer
Security Application Conference, Orlando, Dec 1994.
6. C. Ko, M. Ruschitzka and K. Levitt, “Execution Monitoring of Security-Critical
Programs in Distributed Systems: A Speciﬁcation-based Approach,” In Proceed-
ings of the 1997 Symposium on Security and Privacy, May 1997.
7. R. Sekar, T. Bowen, and M. Segal, “On Preventing Intrusions by Process Behavior
Monitoring,” Workshop on Intrusion Detection and Network Monitoring Proceed-
ings, Berkeley, CA, USENIX, pages 29-40.
8. CERT Advisory CA-1999013 Multiple Vulnerabilities in WU-FTPD, CERT CC,
available at http://www.cert.org/advisories/CA-1999-13.html, Nov
1999.
9. M. Roesch, “Snort - Lightweight Intrusion Detection for Networks,” USENIX LISA
’99 conference, Nov 1999. Also available at http://www.snort.org.
10. L. Miras, “Advanced Evasion of IDS buﬀer overﬂow detection”, power point pre-
sentation in http://www.newhackcity.net/˜jeru
11. T. Fraser, L. Badger, M. Feldman, “Hardening COTS Software Using Generic
Software Wrappers”, IEEE Symposium on Security and Privacy, May 1999.
12. D. Clark and D. Wilson, “A Comparison of Commercial and Military Computer
Security Policies,” In Proceedings of the 1987 IEEE Symposium on Security and
Privacy, May 1987.
13. K.J. Biba, “Integrity Considerations for Secure Computer Systems,” Technical
Report ESD-TR-76-372, USAF Electronic Systems Division, Bedford, MA, 1977.
14. W. Boebert and R. Kain, “A Practical Alternative to Hierarchical Integrity Poli-
cies,” Proceedings of the 8th National Computer Security Conference, Gaithers-
burg, MD, 1985.
15. J. Saltzer and M. Schroeder, “The Protection of Information in Computer Sys-
tems,” In Proceedings of the IEEE, Vol. 63, No. 9, pages 1278-1308, March 1975.
16. C. Landwehr et. al., “A Taxonomy of Computer Program Security Flaws,” ACM
Computing Surveys, Vol.26, No. 3, September 1994.
17. I. Krsul, “Software Vulnerability Analysis,” Department of Computer Science, Pur-
due University, Ph.D. Thesis, Coast TR-98-09, 1998.
18. M. Bishop, “Writing Safe Privileged Programs,” Network Security 1997, New Or-
leans, LA, 1997.