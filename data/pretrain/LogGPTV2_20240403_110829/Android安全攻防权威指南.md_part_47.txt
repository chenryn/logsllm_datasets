除外，因为这个选项是在模拟器内实现的。
---
## Page 211
7.9漏洞分析
195
262 *1 - For memory 1eak detections.
9Z
264
10 - For adding pre-, and post- allocation stubs in order to detect
CHK_SENTINEL_VALUE, and CHK_FILL_PREE macros.
265
266*
buffer overruns.
设置相关属性需要root权限，还需要将1ibc_malloc_debug_leak.so库放入/system/lib
目录，这要暂时将/system分区重新挂载为可读写模式。这个动态库位于AOSP编译输出的
out/target/product/maguro/obj/lib目录下。下面的片段展示了整个配置过程：
dev:~/android/source $ adb push \
out/target/product/maguro/obj/1ib/1ibc_ma11oc_debug_1eak.so /data/1oca1/tmp
587 KB/s (265320 bytes in 0.440s)
she119maguro 1 /  $ 8u
dev:~/android/source $ adb shel1
rootemaguro1/  mount -o renount, rw /system
root9maguro1/ # cat /data/1ocal/tmp/1ibc_ma11oc_debug_1eak.9o > \
/system/1ib/1ibc_ma11oc_debug_leak,so
root9maguro:/ # mount =o renount,ro /system
rootemaguro1/ # setprop 1ibc.debug.ma1loc 5
rootemaguro:/  cd /data/local/tmp
rootimaguro1/data/local/tnp  ps 1 grep systen_server
system
379 125 623500 99200 tftfffff 40199304 S systen_server
6 6- 1xd/e/ee/e0x
root9maguro1/data/1oca1/tmp  1ogcat -d I grep -1 debug
I/1ibc
(TTT3)
( 2994) : /system/bin/bootanimation: using 1ibc.debug.ma11oc 5
I/1ibe
( 2999) : /system/bin/netd: using 1ibe.debug.mal1oc 5 (fi11)
I/1ibe
( 3001) : /sy8tem/bin/iptables: u8ing 1ibc.debug.malloc 5 (fi11)
I/11bc
( 3002) : /systen/bin/ip6tables: using 1ibe,debug.ma11oc 5 (fi11)
I/1ibc
( 3003) : /system/bin/iptables: using 1ibc.debug.malloc 5 (fi11)
I/11be
( 3000) : /system/bin/app_process: using 1ibc.debug-ma11oe 5
( 3004) : /syaten/bin/ip6tables: uoing 1ibc.debug.mal1oc 5 (fi11)
I/1ibe
(fi11)
[•..]
可惜的是，在Android4.3上用这个调试工具来测试一些公开漏洞的效果并不好。希望这个
情况能在未来的Android版本中得到改善。无论如何，这个调试工具至少为未来构造更稳定的堆
调试工具打下了基础。
·监税点
监视点（watchpoint）是一种特殊的断点，在指定内存发生某种操作时才会被触发。x86与
x64平台上的监视点通过硬件断点来实现，在发生内存读写操作时通知研究人员。不幸的是，大
多数ARM处理器没有实现硬件断点，但是在ARM平台上可以用软件来实现监视点，完成相同
的功能。然面，因为软件依赖于单步运行，所以软件监视点非常慢，成本开销较大。当然，用它
们来追踪特殊变量值的改变是非常有用的。
假如研究人员知道某个对象的成员变量在对象创建后发生了改变，想知道代码在哪里有改
动。首先，可以在对象创建时下一个断点。执行到断点处时，使用GDB的watch命令创建一个
监视点。继续执行会发现速度变慢了很多。当程序修改变量值后，GDB会在修改后的下一条指
---
## Page 212
196第7章调试与分析安全漏洞
令处暂停。这种技术可以帮助研究人员成功定位代码位置。
·断点
能够创建新断点的断点是非常强大的工具，也被称作互相依赖的断点。它最重要的用处是消
除噪音。假设在函数main_event_loop调用时发生了堆内存破坏（如函数名所示，这个函数会
被频繁调用），要明白问题的根源，需要理解在内存破坏发生时程序正在处理哪些内存块。如果
在main_event_loop上设置一个断点，执行就会不停地被打断。如果研究人员知道内存破坏源
自某个特定的输人，并且知道哪些代码负责处理相应的输人，就可以在那插入一个断点。当断点
被命中时，就可以在main_event_loop上再设置一个断点。如果运气比较好，首次命中的新断
点就是前溃发生的调用点。前面那些没有引发内存破坏的所有成功调用都被忽略（并且没有额外
性能开销）。在这个样例场景下，使用互相依赖的断点可以帮助分析人员缩小内存破坏的发生范
围。下面介绍一个类似的场景。
2.分析WebKit崩渍
分析漏洞的起源是一个选代的过程。要想跟踪一个漏洞，通常需要多次运行崩溃的测试样例。
尽管可以把调试器附加到进程上，但这样并不能马上了解问题的根源。向后追溯数据流和控制流
（包括过程间的控制流）才是问题的核心所在。
下面研究一个能够让搭载Android 4.3的Galaxy Nexus浏览器崩溃的HTML文件作为演示。
有题的是，Android上的稳定版和 beta版Chrome 都不受影响。我们使用本章前面介绍的一些技
术和调试方法来找到前溃的根源。
让浏览器反复前溃几次，然后查看tombstone文件会很有帮助：寄存器的值包含一些有用的
信息。下面列出了多次加载页面产生崩溃的情况：
rootemaguro1/data/tombstones + /Gata/local/tmp/busybox head -9 * 1 grep
pc
ip 00000001
sp 5e8003cB1x 5d46fee5pc 5a50ec48cpsr 200e0010
ip 00000001
8p 5ddba3c8
1r 5c865ee5
5pc 00000000cpsr 200f0010
pe 5e5fc2b8
ip 00000001
sp 5dede3c8
1r 5ca4bee5
ip 00000001
sp 5dede3c8
1r 5ca4bee5
pc 60538ad0cpsr 200e0010
ip 00000001
09000699 ds
1r 5d46fee5
pc 5a90bf80 cpsr 200e0010
ip 00000001
88900699d8
1r 5d46fee5
pc 5a518d20
cpsr 200f0010
ip 00000001
88900q99ds
1r 5d46fee5
ip 00000001sp 5ea003c81r 5d46fee5 pc 5edfa268cp8r 200f0010
从上面的结果可以看出，每次崩溃的地方都明显不同。PC寄存器（与x86下的EIP类似）
的值都不同，而且都很奇怪，在很大程度上表明这是一个释放后重用（use-after-free）漏洞。为
了进行确定并了解漏洞产生的原因，需要继续深人分析。
为了获得更多信息，需要使用本章开头搭建的native层代码调试环境。跟之前一样，在主机
上后台运行shell脚本debugging-sh。这个脚本会调用设备上的shell脚本attach.sh，让浏览器访问
about:blank页面，等待一段时间后附加到GDB服务器上。然后，在主机上运行GDB客户端并加
载GDB脚本，连接等待着的GDB服务器。
dev:gn-browser-dbg $ arm-eabi-gdb -q -x script gdb app_process
dev:~/android/source $ ./debugging-8h &
---
## Page 213
7.9漏洞分析197
dev:gn-browserdbg $ arm-eabi-gdb -q -× script.gdb app_process
[1] 28994
Reading aymbols fron /android/source/gn-browserdbg/app_process.. ,done,
varning: Could not load shared library symbols for 86 1ibrarie8, e.g. libm.
Use the *info sharedlibrary* command to see tbe complete listing.
epoll_wait () at bionic/1ibe/areh-arm/syscal1s/epol1_wait,S:10
warning: Breakpoint address adjusted from 0x40079b79 to 0x40079b78.
01
(gdb) cont
AOW
r7, ip
Continuing
调试器附加到进程上继续执行，然后打开导致崩溃的HTML页面。就像在attach.sh脚本中
所做的那样，可以使用amstart命令让浏览器访问指定页面。
shell@maguro:/ $ an start -a android.intent.action.VIEW -d \
http://evi1-site.com/crash1.html com-google.android.browser
可能需要多次加载页面才会发生崩溃。一且前溃发生，就可以开始深人分析了。
Program received signal SIGSEGV, Segmentation fault.
（1&uT 00000000x0
(gdb)
浏览器崩溃时PC寄存器被置0了！这很明显是一个严重的错误。可能造成这种情况的因素
有很多，所以需要清楚确切原因。
首先在调用栈寻找线索。下面是GDB的backtrace命令产生的输出：
(gdb) back
00x00000000 1n ?? ()
0x5d46fee4 in webCore::Node:1parentNode (this=0x5a621088) at
externa1/webkit/Source/WebCore/dom/Node.h:731
+2  0x5d6748e0 in WebCore::ReplacementFragment11removeNode (this=,
fragment=, matchStylewcoptinized out>, selectLon...1
at external/webkit/Source/WebCore/editing/ReplaceSelectionCommand.
#5 0x5d6764c2 in WebCore: :ReplaceSelectionCommand: :doApp1y
841d
(this=0x5a621800)
at externa1/webkit/Source/webCore/editing/ReplaceSelectionCommand.
60x5d66701e n webCore::BditCommand:apply (th1s0x5a621800)at
6181d
externa1/webkit/Source/WebCore/editing/BditCommand.cpp:92
0x5d66e2e2 in WebCore::executeInsertFragment (frame=,
---
## Page 214
198
第7章调试与分析安全漏洞
fragment=)
0x5d66e328 in webCore: :executeInsertHT9L (frane=0x5aa65690, value=,,.)
at external/webkit/Source/febCore/editing/BditorCommand.cpp:194
8#
at externa1/webkit/Source/WebCore/editing/BditorCommand.cpp:492
parameter=..., triggeringEvent=0x0)
#9
0x5d66d3d4 In WebCore: :Bditor: :Comnand: :execute (this=0x5ea0068c,
#10 0x5d5491a4 in MebCore::Document:1execCommand (this=0x5aalac80,
at externa1/webkit/Source/WebCore/edi ting/BditorCommand.cpp:1644
commandlame=..., userInterface=coptimized out>, value=...)
#11 0x5d5e7df6 in webCore1:DoeumentInternal::execCommandCal1back
at externa1/webk&t/Source/WebCore/dom/Doeument ,epp:4053
(args=coptimized out>)
at .../1ibwebcore_intermediates/Source/WebCore/bindings/V8Document ,
cpp:1473
#12 0x5d78dc22 in HandleApiCal1Helper (isolate=0x4173c468, args=..-)