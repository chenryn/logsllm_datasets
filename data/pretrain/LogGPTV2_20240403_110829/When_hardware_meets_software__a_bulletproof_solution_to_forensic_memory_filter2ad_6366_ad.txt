• modify PDE at virtual address 0x00000008, so that
it will map a physical 2MB page that needs to be
dumped. Since this PDE is the second one contained
in the Page Directory under our control, this physical
page will be mapped at virtual address 0x00200000
(lines 6 - 8);
• read a chunk of memory from virtual page starting at
0x00200000, create a packet with checksum and send
it over the network (lines 12 - 15). Alternatively, if we
want to avoid code duplication, it is possible to just
store memory chunks at an address that is readable
from SMM (e.g., any area tagged as Available in Fig-
ure 5) and trigger a SMI. The code executed in SMM
will then take care of signing and sending operations
just like it did for the ﬁrst 4GB;
• loop through the inner loop (lines 11-17) until a full
2MB page has been dumped, then repeat the proce-
dure (lines 4-18) until the whole memory higher than
4GB has been dumped.
Before ﬁnally returning back to protected mode we have
to make sure that (i) the execution ﬂow will not go out of our
code and that (ii) our code has enough privileges to operate
without triggering faults. To avoid (i) we clear the Inter-
rupt Flag in the EFLAGS register stored in the Save System
Map so that interrupts will not cause a transfer of the exe-
cution ﬂow to the system interrupt handlers. Non-Maskable
Interrupts (NMI), can still happen even if EFLAGS.IF is 0,
so we disable them by interacting directly with the APIC.
Disabling NMI is not a problem as the code that we will
execute in protected mode does not rely on them anyhow.
Problem (ii) is mainly due to the fact that, from SMM, we
cannot modify the CPL that will be set upon a resume. For-
tunately, the only operations for which our code will need
some custom privileges are I/O operations (both for inter-
acting with the NIC or to trigger a SMI and get control back
to code in SMM). This privileges can be granted by altering
the Input Output Privilege Level (IOPL) bits in EFLAGS just
like we do for IF.
4.5 Portability
The approach adopted by SMMDumper is completely OS-
independent and can be easily applied as a patch to already
existing BIOS or installed in new ones. The most restricting
requisites of SMMDumper are mainly hardware:
1. The presence on the target system of a port (USB,
serial) to interact with the smartcard hardware.
2. A network interface card to send out packets.
Developing drivers for many diﬀerent network interface cards
may be painful, as every piece of hardware has its speciﬁca-
tions and peculiarities. However, most BIOS already include
primitives to interact with on-board NICs (e.g., PXE [6]
functionality required to interact with the network). BIOS
manufacturers willing to support SMMDumper can easily
modify it to include additional drivers of well-known on-
board NICs.
5. EXPERIMENTAL EVALUATION
To verify the soundness of the proposed approach, we im-
plemented a prototype based on coreboot [13], so that it can
be easily installed on many production systems as a BIOS
update. The collector module of SMMDumper has been en-
tirely coded in Assembly and it counts slightly less than 500
LoC, of which ≈ 47% is for the MD5 implementation. To
perform tests, we employ QEMU 1.0.1 [1], equipped with
a single Intel 3GHz processor, 6GB of RAM and a Realtek
RTL8139 100Mbps network card.
86
To interact with the NIC, we implemented a small driver
that is able to run in SMM to send and receive UDP packets.
The code required to interact with this piece of hardware is
quite simple: to transmit a packet, the driver writes the
physical address and the size of the packet to the appropri-
ate control registers of the device. Then, it polls the status
register of the device until the transmission is completed. We
use polling instead of interrupts because interrupts are dis-
abled as soon as we switch to SMM. Packets reception, that
is needed for the retransmission protocol, is implemented
in the same way.
It is worth noting that we allocate the
packet transmission buﬀer in a region of memory outside
the SMRAM because devices cannot access SMRAM due
to hardware restrictions [17]. Before using this region, we
backup it into the SMRAM and restore it later, in order to
send it.
As a checksum algorithm to grant both packet and overall
memory integrity we use MD5. As we brieﬂy outlined in Sec-
tion 4.3.1, our choice of MD5 is convenient, as it allows us to
incrementally calculate the overall checksum of the memory
as we read it to create packets. To univocally sign the over-
all checksum, SMMDumper leverages an external hardware
device that is able to read a private key from a smart card
and use it to encrypt data. To perform experiments, we cre-
ated a simulated smart card reader that can be hotplugged
into our development environment by means of a Serial Port
(RS232). According to our threat model, since the commu-
nication channel is established once SMMDumper is already
executing, no attacks can interfere with this channel.
To evaluate the performance of SMMDumper and the av-
erage time needed to transfer the acquired volatile data
over the local network, we performed a number of trans-
mission tests (all the results are averages with negligible
standard deviation). With a chunk size of 1024B of mem-
ory, each transmitted UDP packet carries a total payload
size of 1024(chunk) + 16(MD5) + 8(phy addr) bytes. Us-
ing that value as our reference payload size, we measured
the time needed to transfer 6GB of memory to be ≈ 820
(cid:3)(cid:3)
,
≈ 10% of which is overhead due to the calculation of the
MD5 checksum over a single packet. The overall overhead
caused by the metadata inserted in every packet is 144MB.
It is worth noting that choosing a chunk size bigger than
1024B would introduce error-prone implementation intrica-
cies in exchange for a relatively small gain. By maximiz-
ing the chunk size up to the MTU, indeed, we would incur
in cross-page readings that, especially when dealing with
PAE, may be tricky to deal with. Assuming a chunk size of
(M T U −T CP header−16−8) = 1436B, the time needed to
dump 6GB and the overhead of metadata would respectively
and ≈ 103MB. This roughly corresponds to
drop to ≈ 814
an interesting downgrade of 29% of the overhead caused by
metadata. However, when calculated on the whole traﬃc,
the overall improvement is only of 0.66%. For this reason,
our current implementation relies on a 1024B chunk size and
trade a negligible performance boost for a more linear algo-
rithm.
(cid:3)(cid:3)
Finally, we must verify if SMMDumper is able to guaran-
tee the properties that we illustrated in Section 1. Firstly,
to evaluate if atomicity is satisﬁed, we instrumented our de-
velopment environment in order to take a snapshot of the
system memory before starting to execute our SMM ISR
handler. Then, we compared such a dump with the one pro-
duced by SMMDumper. Results showed that our technique
allows to gather an accurate and consistent memory dump:
as we expected, no changes occur on the host after we trigger
an SMI by pressing a speciﬁc sequence of keystrokes. How-
ever, we are aware that some changes may occur meanwhile
SMMDumper reads memory mapped I/O regions which are
reserved for devices. These changes however do not aﬀect
the consistency of our dump. Indeed, they cannot invalidate
the overall checksum since it is incrementally calculated, i.e.,
we just read these areas once, both for sending them out and
to calculate the hash. However, changes may happen be-
tween the time the user press the keystroke and the time at
which the actual chunk is sent out over the network. More-
over, since we mapped SMRAM [0x000a0000-0x000affff]
in a section of memory that overlaps the area used by video
RAM [0x000a0000-0x000bffff], the memory readings in
that address range result in a dump of the SMI ISR handler
and the SMRAM State Save Map, instead of the original
content of the memory area. We assert that these changes
do not violate consistency and atomicity properties as the
information they contain are strictly related to physical de-
vices and are not relevant for the analysis.
Secondly, we veriﬁed if the requirement of reliability is
satisﬁed.
In this part of the evaluation, we performed a
man-in-the-middle attack between the target machine run-
ning SMMDumper and the receiver host [14]. The attack
allowed us to accurately tamper with the packets, modify-
ing the payload and re-calculating the MD5 checksum to hide
evidences of our modiﬁcations. The receiving host, at the
end of the procedure, detected our evil modiﬁcations lever-
aging the overall encrypted checksum that SMMDumper sent
at the end of the dump.
In summary, our experiments show that SMMDumper is
able to provide an atomic and reliable snapshot of the target
system, in a timely fashion.
5.1 Future Work
The actual SMMDumper implementation does not address
Multi-Processor (MP) systems. Nevertheless, SMMDumper
can be easily extended for handling it. In MP systems, SMI
is propagated to all processors. As described in [15], pro-
cessors enter SMM at slightly diﬀerent times, because SMI
could be serviced in between of CPU instructions. There-
fore, SMM ISR handler waits for all processors to enter SMM
and then, using a semaphore, only one processor executes
the memory dump while the others wait it to complete.
Our threat model does not implicitly include the presence
of malicious hardware-assisted hypervisors on the target sys-
tem. However, when we do not have to dump more than
4GB of RAM, our solution is resilient to this kind of attacks.
On the other hand, as we explained in Section 4.4, the fall-
back solution to dump higher memory must exit SMM with
an rsm instruction. An hardware-assisted hypervisor could
intercept the rsm [8] and get hold of the execution control
before SMMDumper, thus disabling the acquisition of mem-
ory higher than 4GB.
Furthermore, we are currently working on a solution to
tackle the problem of dumping even more than 64GB of
RAM (i.e., on CPUs that support IA-32e mode). Prelimi-
nary results show that it is indeed possible to dump more
than this amount of RAM. Furthermore, to the best of our
knowledge, we believe that our future solution will be re-
silient to malicious hardware-based hypervisor attacks.
87
6. CONCLUSION
In this paper, we presented an SMM-based volatile mem-
ory acquisition technique that overcomes many of the limi-
tations aﬀecting state-of-the-art solutions. In particular, we
have shown how SMMDumper is able to atomically perform
a live memory acquisition, while guaranteeing the on-system
and in-transit integrity of the acquired information.
While the ﬁrmware-based implementation of our proof-
of-concept may be undermined by sophisticated kernel-level
malware, the design of SMMDumper remains sound, arguing
that the introduction of a naive and inexpensive hardware
modiﬁcation by vendors, such as an interrupt line directly
connected to the processor SMI pin, would make SMMDumper
completely bulletproof and resilient to any form of attacks.
Our experimental evaluation shows that SMMDumper is
eﬀective and eﬃcient, allowing for its real-world deployment
in digital forensic analyses and incident responses.
7. REFERENCES
[1] F. Bellard. QEMU, a fast and portable dynamic
translator. In Proceedings of the USENIX Annual
Technical Conference, FREENIX Track, pages 41–46,
2005.
[2] B. D. Carrier and J. Grand. A hardware-based
memory acquisition procedure for digital
investigations. Digital Investigation, 1(1):50–60, 2004.
[3] S. Embleton, S. Sparks, and C. Zou. SMM rootkits: a
new breed of OS independent malware. In Proceedings
of the 4th International Conference on Security and
Privacy in Communication Netowrks, page 11. ACM,
2008.
[4] Intel. Intel Software Network. http://software.
intel.com/en-us/forums/showthread.php?t=63946.
[5] Intel. Intel I/O Controller Hub 10 (ICH10) Family,
2008.
[15] Phoenix. BIOS Undercover: Writing A Software SMI
Handler, 2008. http://blogs.phoenix.com/phoenix_
technologies_bios/2008/12/
bios-undercover-writing-a-software-smi-handler.
html.
[16] J. Rutkowska. Beyond the CPU: Defeating hardware
based RAM acquisition tools, 2007.
http://invisiblethings.org/papers/
cheating-hardware-memory-acquisition-updated.
ppt.
[17] T. Schluessler and P. Rajagopal. OS Independent
Run-Time System Integrity Services. Research Paper,
IT Innovation and Research, Intel Corporation, 2005.
[18] S. Sokolov. 8042 keyboard controller.
http://stanislavs.org/helppc/8042.html.
[19] T. Vidas. Acquisition and Forensic Analysis of Volatile
Data Stores. PhD thesis, University of Nebraska at
Omaha, 2006.
[20] R. Wagner. Address resolution protocol spooﬁng and
man-in-the-middle attacks. The SANS Institute, 2001.
[21] J. Wang, A. Stavrou, and A. Ghosh. Hypercheck: A
hardware-assisted integrity monitor. In Proceedings of
the 13th International Symposium on Recent Advances
in Intrusion Detection (RAID), September 2010.
[22] J. Wang, K. Sun, and A. Stavrou. An Analysis of
System Management Mode (SMM)-based Integrity
Checking Systems and Evasion Attacks. Technical
report, George Mason University, 2011.
[23] J. Wang, F. Zhang, K. Sun, and A. Stavrou.
Firmware-assisted Memory Acquisition and Analysis
Tools for Digital Forensics. In Proceedings of the 6th
International Workshop on Systematic Approaches to
Digital Forensic Engineering (SADFE), Oakland,
California, USA, May 2011.
[24] R. Wojtczuk. Subverting the Xen hypervisor. Black
[6] Intel Corporation. Preboot Execution Environment
Hat USA, 2008, 2008.
[25] R. Wojtczuk and J. Rutkowska. Attacking SMM
memory via Intel CPU cache poisoning. Invisible
Things Lab, 2009.
(PXE) Speciﬁcation, 1999.
[7] Intel Corporation. Intel 64 and IA-32 Architectures
Software Developer’s Manual - Volume 3A, May 2012.
[8] Intel Corporation. Intel 64 and IA-32 Architectures
Software Developer’s Manual - Volume 3B, May 2012.
[9] F. Z. Kun Sun, Jiang Wang and A. Stavrou.
SecureSwitch: BIOS-Assisted Isolation and Switch
between Trusted and Untrusted Commodity OSes. In
Proceedings of the 19th Annual Network and
Distributed System Security Symposium (NDSS), San
Diego, California, USA, February 2012.
[10] E. Libster and J. Kornblum. A Proposal for an
Integrated Memory Acquisition Mechanism. ACM
SIGOPS Operating Systems Review, 42(3):14–20, 2008.
[11] L. Martignoni, A. Fattori, R. Paleari, and
L. Cavallaro. Live and Trustworthy Forensic Analysis
of Commodity Production Systems. In Proceedings of
the 13th International Symposium on Recent Advances
in Intrusion Detection (RAID), September 2010.
[12] A. Martin. FireWire memory dump of a Windows XP
computer: a forensic approach.
http://www.friendsglobal.com/papers/FireWire%
20Memory%20Dump%20of%20Windows%20XP.pdf.
[13] R. Minnich. coreboot. http://www.coreboot.org/.
[14] A. Ornaghi and M. Valleri. Man in the middle attacks
demos. Blackhat [Online Document], 2003.
88