The ZKB++ improvements reduce the proof size compared to ZKBoo
by a factor of 2; independent of the concrete circuit.
As an example, we can consider the concrete case of proving
knowledge of a SHA-256 pre-image. For this example, we set ℓ = 1
(for Boolean circuits), c = 256 (we use SHA-256 as a commitment
scheme), and s = κ (the randomness for the commitment in ZKBoo
that we eliminated in ZKB++). For the circuit, we use the SHA-256
boolean circuit from [23], for which m = 512, n = 256, and b =
22272. Given these parameters, if we set κ = 128, then the ZKB++
proof size is 618 kilobytes, which is only 48% of ZKBoo proof size
(1287 kilobytes). At the 80-bit security level, the ZKB++ proof size
is 385 kilobytes, and at the 40-bit security level, the proof size is
193 kilobytes. For all these figures, we used 256-bit commitments,
and thus in practice they may be slightly reduced by using a weaker
commitment scheme.
ZKB++ Security. From our argumentation above we conclude that
the security of ZKBoo directly implies security of ZKB++ in the
(Q)ROM.
4 THE FISH SIGNATURE SCHEME
The FS transform is an elegant way to obtain EUF-CMA secure
signature schemes. The basic idea is similar to constructing NIZK
proofs from Σ-protocols, but the challenge c is generated by hashing
the prover’s first message r and the message m to be signed, i.e.,
c ← H(r , m). In the following we will index the non-interactive
PPT algorithms (ProveH , VerifyH) by the hash function H, which
we model as a random oracle. Let us consider a language LR with
associated witness relation R of pre-images of a one-way function
fk : Dκ → Rκ, sampled uniformly at random from a family of one-
way functions { fk}k ∈Kκ , indexed by key k and security parameter
κ:
Henceforth, we may use { fk} for brevity. The function family { fk}
could be any one-way function family, but since we found that
function families based on block ciphers gave the most efficient
signatures, we tailor our description to this choice of { fk}. Here
we have that
where Enc(x, k) denotes the encryption of a single block k ∈ {0, 1}c·κ
with respect to key x ∈ {0, 1}c·κ. One can sample a one-way func-
tion { fk} with respect to security parameter κ uniformly at random
by sampling a uniformly random block k ∈ {0, 1}c·κ. In Appendix D
we formally argue that we can use a block cipher (viewed as a PRF)
in this way to instantiate an OWF. In the classical setting we set
c = 1, whereas we set c = 2 in the post-quantum setting to account
((y, k), x) ∈ R ⇐⇒ y = fk(x).
fk(x) (cid:66) Enc(x, k),
For public ϕ and y ∈ Lϕ, the prover has x such that y = ϕ(x). The prover and verifier use the hash functions G(·) and H(·) and H′(·) which
will be modeled as random oracles (H′ will be used to commit to the views). The integer t is the number of parallel iterations.
p ← Prove(x):
1. For each iteration ri , i ∈ [1, t]: Sample random tapes k
(i)
(i)
3 and simulate the MPC protocol to get an output view View
j and
output share y
(i)
j
(x
(i)
1 , k
(i)
1 , x
(i)
2 , k
. For each player Pj compute
(i)
(i)
(i)
3 ) = (G(k
1 ), G(k
3 ) ← Share(x, k
(i)
(i)
(i)
j ← Update(Update(· · · Update(x
j+1, k
j
(i)
j ← Output(View
(i)
(i)
j
j
(i)
j ).
||View
(i)
2 , x
View
(i)
1 , k
(i)
2 , k
y
(i)
j
, View
, x
, x
, D
(i)
j
2. Compute the challenge: e ← H(a(1), . . . , a(t)). Interpret the challenge such that for i ∈ [1, t], e(i) ∈ {1, 2, 3}
3. For each iteration ri, i ∈ [1, t]: let b(i) = (y
Commit [C
(i)
j ] ← [H′(k
(i)
j ], and let a(i) = (y
(i)
) and set
e(i)+2
(i)
(i)
(i)
2 )
(View
1 , k
2 , k
(i)
(i)
(i)
(View
3 , k
2 , k
3 , x
(i)
(i)
(i)
(View
1 , x
3 , k
1 , k
4. Output p ← [e,(b(1), z(1)),(b(2), z(2)),· · · ,(b(t), z(t))].
(i)
j ), k
(i)
e(i)+2, C
if e(i) = 1,
if e(i) = 2,
if e(i) = 3.
(i)
3 )
(i)
3 )
(i)
1 , C
(i)
2 , C
(i)
3 , C
(i)
1 , y
(i)
2 , y
(i) ←
(i)
3 ).
z
(i)
2 ), x ⊕ G(k
(i)
j
(i)
(i)
2 )),
1 ) ⊕ G(k
(i)
j+1) . . .) . . .) . . .),
, k
b ← Verify(y, p):
1. For each iteration ri , i ∈ [1, t]: Run the MPC protocol to reconstruct the views, input and output shares that were not explicitly
given as part of the proof p. In particular:
G(k
x
x
←
(i)
e(i)+1
if e(i) = 1,
if e(i) = 2,
if e(i) = 3.
(i)
1 )
(i)
G(k
2 )
(i)
3 given as part of z(i)
x
(i)
e ← Update(. . . Update(x
(i)
e(i)+1
(i)
e(i) ←
(i)
e(i)+1 from z(i) and compute
View
(i)
(i)
(i)
e(i) ← Output(View
e(i)), y
e(i)+2
(i)
(i)
e(i). For j ∈ {e(i), e(i) + 1}:
e(i) and View
(i)
(i)
(i)
(i)
(i)
′(k
[C
j ] ← [H
j ), k
||View
j ]
, View
j
j
(i)
(i)
(i)
(i)
e(i)+2 is a part of z(i).
3 ) and note that y
e(i)+2 and C
2 , C
(i)
(i)
e +1) . . .),
e , x
(i)
← Output(View
), y
e(i)+1
(i)
e +1, k
(i)
1 , C
(i)
3 , C
(i)
1 , y
(i)
2 , y
(i)
e , k
(i)
j
(i)
j
, D
, x
y
Compute the commitments for views View
Obtain View
Let a′(i) = (y
G(k
(i)
2 )
(i)
3 given as part of z(i)
x
(i)
G(k
1 )
if e(i) = 1,
if e(i) = 2,
if e(i) = 3.
← y ⊕ y
(i)
e(i) ⊕ y
(i)
e(i)+1
2. Compute the challenge: e′ ← H(a′(1), . . . , a′(t)). If, e′ = e, output Accept, otherwise output Reject.
Scheme 1: The ZKB++ proof system, made non-interactive using the Fiat-Shamir transform.
for the generic speedup imposed by Grover’s algorithm [52]. The
rationale for using a random instead of a fixed block k when creat-
ing the signature keypair is to improve security against multi-user
key recovery attacks and generic time-memory trade-off attacks
like [54]. To reduce the size of the public key, one could choose a
smaller value that is unique per user, or use a fixed value (with a
potential decrease in security). Since public keys in our schemes
are small (at most 64 bytes), our design uses a full random block.
When using ZKBoo to prove knowledge of such a pre-image, we
know [44] that this Σ-protocol provides 3-special soundness. We
apply the FS transform to this Σ-protocol to obtain an EUF-CMA
secure signature scheme. In the so-obtained signature scheme the
public verification key pk contains the image y and the value k
determining fk. The secret signing key sk is a random value x from
Dκ. The corresponding signature scheme, dubbed Fish, is illustrated
in Scheme 2.
If we view ZKBoo as a canonical identification scheme that is
secure against passive adversaries one just needs to keep in mind
that most definitions are tailored to 2-special soundness, and the
3-special soundness of ZKBoo requires an additional rewind. In par-
ticular, an adapted version of the proof of [61, Theorem 8.2] which
considers this additional rewind attests the security of Scheme 2.
The security reduction, however, is a non-tight one, like most sig-
nature schemes constructed from Σ-protocols.7 We obtain the fol-
lowing:
Corollary 4.1. Scheme 2 instantiated with ZKB++ and a secure
one-way function yields an EUF-CMA secure signature scheme in the
ROM.
7There are numerous works on signatures from (three move) identification schemes
[1, 2, 12, 32, 62, 73, 77]. Unfortunately existing proof techniques do not give tight
security reductions.
7
Gen(1κ) : Choose k ←R Kκ, x ←R Dκ, compute y ← fk(x), set pk ← (y, k) and sk ← (pk, x) and return (sk, pk).
Sign(sk, m) : Parse sk as (pk, x), compute p = (r , s) ← ProveH((y, k), x) and return σ ← p, where internally the challenge is computed
Verify(pk, m, σ) : Parse pk as (y, k), and σ as p = (r , s). Return 1 if the following holds, and 0 otherwise: