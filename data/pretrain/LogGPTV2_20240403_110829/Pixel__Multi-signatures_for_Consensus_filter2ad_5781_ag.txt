= A−αk
(cid:96)−1
∏
i=k+1
−M∗
w∗
k−wk
k+1
= A
A
.
−w∗
k+2+i
w∗
k−wk
A
(cid:96)−i
(cid:96)−k−2
∏
i=0
Because 1 ≤ k ≤ (cid:96)− 1, it is clear that all but the second of
these can be computed from B’s inputs, and that the second
cancels out with the factor g(α(cid:96)+1)
in d, so that it can indeed
compute d this way. The other components of the key are
also efﬁciently computable as
1
c = gr(cid:48)
ei = hr(cid:48)
= hr(cid:48)
1
w∗
2 · Bk
k−wk
i · A(cid:96)+k−i+1
k+i · A(cid:96)−i
for i = k + 1, . . . , (cid:96)
for i = 0, . . . , (cid:96)− k− 1 .
From this key (c,d,ek+1, . . . ,e(cid:96)) for w(cid:48), B can derive a key
for w and compute a signature as in the real signing algo-
rithm.
Case 2: t = t∗,M (cid:54)= M∗. For a signing query with t = t∗
but M (cid:54)= M∗, B proceeds in a similar way, but derives the
signature (σ1,σ2) directly. Algorithm B can generate a
valid signature using a similar approach as above, but us-
ing the fact that M (cid:54)= M∗ instead of wk (cid:54)= w∗
k. Namely, letting
w = t(cid:107)0(cid:96)−1−|t|, B computes a signature
σ1 = hx ·
= (cid:0)gγ
(cid:32)
h0 · (cid:96)−1
(cid:32)(cid:18)
∏
(cid:1)α ·
(cid:18)
i=1
1A(cid:96)
(cid:96)−1
∏
i=1
(cid:33)r
(cid:96)
· hM
hwi
i
1 · (cid:96)−1
∏
gγ0
(cid:19)wi · (gγ(cid:96)
(cid:19)
−w∗
(cid:96)−i+1 · A−M∗
(cid:33)r
A
i
1 · A1)M
i=1
1
·
1 · A(cid:96)−i+1
(cid:18)
gγi
gγ0+∑(cid:96)−1
·
1
= Aγ
1 · g(α(cid:96)+1)
1
i=1 γiwi+γ(cid:96)M
· AM−M∗
1
(cid:19)r
σ2 = gr
2
by setting
r ← r(cid:48) +
α(cid:96)
M∗ − M
mod q
for r(cid:48) ←$ Zq, so that B can compute (σ1,σ2) from its inputs
A1, . . . ,A(cid:96),B1, . . . ,B(cid:96) similarly to the case that t (cid:54)= t∗.
in turn requires simulating (cid:101)skw for all w ∈ Γ¯t. By the ﬁrst
Break in. Here, B needs to simulate sk¯t where t∗ ≺ ¯t. This
therefore simulate (cid:101)skw exactly as before.
1,σ∗
property of Γ¯t (described in Section 4.2), all of these w are
not preﬁxes of t∗ and also not preﬁxes of w∗, and we can
Forgery. When A(cid:48) outputs a forgery (σ∗
the veriﬁcation equation
2) that satisﬁes
e(σ∗
|t∗|
∏
then there exists an r ∈ Zq such that
ht∗
1,g2) = e(h,y)· e(cid:0)h0 ·
1 = hα ·(cid:0)h0 ·
|t∗|
∏
j=1
i
i
i=1
σ∗
σ∗
2 = gr
2 .
(cid:1) ,
, σ∗
2
(cid:96)
t∗
j · hM∗
j
h
(cid:1)r
· hM∗
(cid:96)
From the way that B chose the parameters h,h0, . . . ,h(cid:96), one
can see that
σ∗
1 = Aγ
1)γ0+∑
|t∗|
i=1 γit∗
i +γ(cid:96)M∗
· (gr
1, so we cannot directly extract
1 · g(α(cid:96)+1)
Note that we do not know gr
g(α(cid:96)+1)
1
1
from σ∗
e(σ∗
1. Instead, observe that we have
1,C2) = e(Aγ
1,C2)· e(g(α(cid:96)+1)
|t∗|
i=1 γit∗
1
2)γ0+∑
· e(C1,σ∗
,C2)
i +γ(cid:96)M∗
,
USENIX Association
29th USENIX Security Symposium    2109
from which B can easily compute its output e(g(α(cid:96)+1)
,C2) =
e(g1,g2)(γ·α(cid:96)+1). It does so whenever A(cid:48) is successful, so that
1
Adv(cid:96)-wBDHI∗
G1×G2
3
(B) ≥ Advsfu-cma
FS
(A(cid:48)) .
Step 2: fu-cma. Full fu-cma security for M = {0,1}∗ and
with Hq : M → {0,1}κ modeled as a random oracle then
follows because, given an fu-cma adversary A in the random-
oracle model, one can build a sfu-cma adversary A(cid:48) that
guesses the time period t∗ and the index of A’s random-oracle
query for Hq(M∗), and sets ¯t ← t∗ +1. If A(cid:48) correctly guesses
t∗, then it can use sk¯t to simulate A’s signature, key update,
and break-in queries after time ¯t until A’s choice of break-in
time ¯t(cid:48), at which point it can hand over sk ¯t(cid:48).
If A(cid:48) moreover correctly guessed the index of Hq(M∗),
and if A never made colliding queries Hq(M) = Hq(M(cid:48)) for
M (cid:54)= M(cid:48), then A’s forgery is also a valid forgery for A(cid:48). Note
that for A to be successful, it must hold that ¯t(cid:48) > t∗, so it must
hold that ¯t(cid:48) ≥ ¯t. The advantage of A(cid:48) is given by
Advsfu-cma
· Advfu-cma
(A(cid:48)) ≥ 1
T · qH
FS
(3)
where qH is an upper bound on A’s number of random-oracle
queries. Together with Equation (3), we obtain the inequality
of the theorem statement.
FS
(A)− q2
H
2κ ,
B Security Proof of Forward-Secure Multi-
signatures
Proof. We show how to construct a forger A for the multi-
signature scheme yields a forger A(cid:48) for the single-signer
scheme of Section 4.3 such that
Advfu-cma
FS
(A(cid:48)) ≥ Advfu-cma
FS
(A) .
The theorem then follows from Theorem 1.
Step 1: simulating A’s view. On input
the parameters
(T,h,h0, . . . ,h(cid:96)) and a public key y for the single-signer
scheme, the single-signer forger A(cid:48) chooses r ←$ Z∗
q and
stores (y,⊥,gr
1) in a list L. It computes y(cid:48) ← yr and runs A on
the same common parameters and target public key pk = y
and proof π = y(cid:48). Observe that π is indeed a valid proof for
pk since e(y(cid:48),g2) = e(HG1(PoP,y),y).
Algorithm A(cid:48) answers all of A’s key update, signing, and
break-in oracle queries, as well as random-oracle queries for
Hq, by simply relaying queries and responses to and from
A(cid:48)’s own oracles. Queries to the random oracle for HG1 are
answered as follows.
Random oracle HG1. On input (PoP,z), A(cid:48) checks whether
there already exists a tuple (z,·,v) ∈ L. If so, it returns v. If
not, it chooses r ←$ Z∗
q, computes v ← hr, adds a tuple (z,r,v)
to L and returns v.y
Step 2: extracting a forgery. When A outputs its forgery
(pk∗
1,π∗
1, . . . ,pk∗
n,π∗
n),M∗,t∗,Σ∗,
1, . . . ,pk∗
i = y(cid:48)
i. Looking ahead, if pk∗
n for public
n and computes the aggregate public key apk∗,
i = yi = gxi
2
i passes key veriﬁcation,
i = (hxi)ri and since we know ri, we will be
algorithm A(cid:48) ﬁrst veriﬁes the proofs π∗
1, . . . ,π∗
keys pk∗
creating additional entries in L if necessary. Let pk∗
and π∗
then we have y(cid:48)
able to “extract” hxi ∈ G1.
i = HG1(PoP,yi)xi
for all i = 1, . . . ,n. Let apk∗ = Y be the aggregate public key.
From the aggregate veriﬁcation equation
If all keys are valid, then it holds that y(cid:48)
1,g2) = e(h,Y )· e(cid:0)h0 ·
e(Σ∗
(cid:1)
|t∗|
∏
j=1
t∗
j · hHq(M∗)
j
h
(cid:96)
, Σ∗
2
and the fact that Y = ∏n
i=1 yi = y· g
∑n
i=1,yi(cid:54)=y xi
2
, we have that
e(Σ∗
i=1,yi(cid:54)=y xi·
1,g2) = e(h,y)· e(h,g2)
∑n
, Σ∗
2
t∗
j · hHq(M∗)
j
h
(cid:96)∏
(cid:96)+1
j=1
e(cid:0)h0 ·
e(cid:0)h0 ·
−∑n
(cid:1)
(cid:1) .
⇔ e(Σ∗
1 · h
i=1,yi(cid:54)=y xi,g2) = e(h,y)·
|t∗|
∏
t∗
j · hHq(M∗)
j
h
, Σ∗
2
(cid:96)
j=1
For all yi (cid:54)= y, A(cid:48) looks up the tuple (yi,ri,vi) in L. We know
that vi = hri, and hence that y(cid:48)
i = hrixi. By comparing the last
equation above to the veriﬁcation equation of the single-signer
scheme, and by observing that y(cid:48)
i = hrixi, we know that the
pair
−1/ri
n
∏
i=1,yi(cid:54)=y
y(cid:48)
i
1 ← Σ∗
σ∗
1 ·
2 ← Σ∗
σ∗
2
is a valid forgery for the single-signer scheme, so A(cid:48) can
output M∗,t∗, (σ∗
2) as its forgery.
1,σ∗
2110    29th USENIX Security Symposium
USENIX Association