Randomness As operating systems sit outside of the
trusted computing base (TCB) of SGX, OS-served ran-
dom functions such as srand and rand are not acces-
sible to enclaves. SGX instead provides a hardware-
protected random number generator (RNG) using the
rdrand instruction. REM relies on the SGX RNG.
3 Overview of PoUW and REM
The basic idea of PoUW, and thus REM, is to replace
the wasteful computation of PoW with arbitrary useful
computation. A miner proves that a certain amount of
useful work has been dedicated to a speciﬁc branch of
the blockchain. Intuitively, due to the value of the useful
work outside of the context of the blockchain supported
by REM, the hardware and power are well spent, and
there is no waste. A comprehensive analysis of the waste
is deferred to the full version [76]. Here we describe the
security model of REM and then give an overview of its
system mechanics.
3.1 Security Model
A PoW solution embodies a statistical proof of an ef-
fort spent by the miner. With PoUW, however, a miner
reports its own effort. The rational miner’s incentive is
to lie, report more work than actually performed, and
monopolize the blockchain. In PoUW / REM, use of a
TEE — Intel SGX in particular — prevents such attacks
and enforces correct reporting of work. The resulting
trust model is starkly different from that in traditional
PoW.
PoET introduced, and we similarly use in REM, a par-
tially decentralized blockchain model. The blockchain is
permissionless, i.e., any entity can participate as a miner,
as in a fully decentralized blockchain such as Bitcoin.
It is only partially decentralized, though, in that it relies
for security on two key assumptions about the hardware
manufacturer’s behavior.
First, we must assume that Intel correctly manages
identities, speciﬁcally that it assigns a signing key (used
for attestations) only to a valid CPU. It follows that Intel
does not forge attestations and thus mining work. Such
forgery, if detected in any context, would undermine the
company’s reputation and the perceived utility of SGX,
costing far more than potential blockchain revenue. Sec-
ond, we assume that Intel does not blacklist valid nodes
in the network, rendering their attestations invalid when
the IAS is queried. Such misbehavior would be publicly
visible and similarly damaging to Intel if unjustiﬁed.
Even assuming trustworthy manufacturer behavior,
though, a limited number of individual CPUs might be
physically or otherwise compromised by a highly re-
sourced adversary (or adversaries). Our trust model as-
sumes the possibility of such an adversary and makes
the strong assumption that she can learn the attestation
(EPID signing) key for compromised machines and thus
can issue arbitrary attestations for those machines.
In
particular, as we shall see, she can falsify random num-
ber generation and lie about work performed in REM.
Even this strong adversary, though, does have a key
limitation: As signing keys are issued by the manufac-
turer, and given our ﬁrst assumption above, it is not
possible for an adversary to forge identities. We fur-
ther assume that the signatures are linkable.
In SGX,
the EPID signature scheme for attestations has a linkable
(pseudonymous) mode [44, 8, 67], which permits anyone
to determine whether two signatures were generated by
the same CPU. As a result, event a compromised node
cannot masquerade as multiple nodes.
Outside the REM security model
It is important to
note that REM is a consensus framework, i.e., a means to
generate blocks, not a cryptocurrency. REM can be in-
tegrated into a cryptocurrency, as we show by swapping
it into the Bitcoin consensus layer. As REM has roughly
1430    26th USENIX Security Symposium
USENIX Association
the same exponentially distributed block-production in-
terval, such integration need not change security proper-
ties above the consensus layer. For example, fork res-
olution, transaction validation, block propagation, etc.,
remain the same in a REM-backed blockchain as in a
PoW-based one. Thus we do not expand the discussion
of the security issues relevant to those elements in the
REM security model.
3.2 REM overview
Figure 1 presents an architectural overview of REM.
There are three types of entities in the ecosystem of
REM: A blockchain agent, one or more REM miners, and
one or more useful work clients.
The useful work clients supply useful workloads to
REM miners in the form of PoUW tasks, each of which
encompass a PoUW enclave and some input. Any SGX-
compliant program can be transformed into a PoUW en-
clave using the toolchain we developed. Note that a
PoUW enclave has to conform to certain security re-
quirements. The most important is that it meters effort
correctly, something that can be efﬁciently veriﬁed by a
compliance checker and a novel technique we introduce
called hierarchical attestation. We refer readers to §5.2
and §5.3 for details.
The blockchain agent collects transactions and gener-
ates a block template, a block lacking the proof of useful
work (PoUW). As detailed later, a REM miner will attach
the required PoUW and return it to the agent. The agent
then publishes the full block to the P2P network, making
it part of the blockchain and receiving the corresponding
reward.
A miner takes as input a block template and a PoUW
task to produce PoUWs. It launches the PoUW enclave
in SGX with the prescribed input and block template.
Once the PoUW task halts, its results are returned to the
useful work client. The PoUW enclave meters work per-
formed by the miner and declares whether the mining
effort is successful and results in a block. Effort is me-
tered on a per-instruction basis. The PoUW enclave ran-
domly determines whether the work results in a block by
treating each instruction as a Bernoulli trial. Thus min-
ing times are distributed in much the same manner as
in proof-of-work systems. While in, e.g., Bitcoin, effort
is measured in terms of executed hashes, in REM, it is
the number of executed useful-work instructions. Intu-
itively, REM may be viewed as simulating the distribu-
tion of block-mining intervals associated with PoW, but
REM does so with PoUW, and thus eliminates wasted
CPU effort.
When a PoUW enclave determines that a block has
been successfully mined, it produces a PoUW, which
consists of two parts:
an SGX-generated attestation
demonstrating the PoUW enclave’s compliance with
REM and another attestation that a block was success-
fully mined by the PoUW enclave at a given difﬁculty pa-
rameter. The blockchain agent concatenates the PoUW
to the block template, forming a full block, and publishes
it to the network.
When a blockchain participant veriﬁes a fresh block
received on the blockchain network, in addition to ver-
ifying higher-layer properties (e.g., in a cryptocurrency
such as Bitcoin, that transactions, previous block refer-
ences, etc., are valid), the participant veriﬁes the attesta-
tions in the associated PoUW.
Intel’s PoET scheme looks similar to REM in that its
enclave randomly determines block intervals and attests
to block production. PoET, however, lacks the produc-
tion of useful work, an essential ingredient, as we explain
later in the paper. We now discuss our strategy in REM
for handling compromised nodes.
4 Tolerating Compromised SGX Nodes
SGX does not achieve perfect enclave isolation. While
no real practical attack is known,
researchers have
demonstrated potentially dangerous side-channel attacks
against applications [73] and even expressed concerns
about whether an attestation key might be extracted [24].
Therefore, even if we assume SGX chips are manu-
factured in a secure fashion, some number of individ-
ual instances could be broken by well-resourced adver-
saries. A single compromised node could be catastrophic
to an SGX-based cryptocurrency, allowing an adversary
to create blocks at will and perform majority attacks on
the blockchain. While she could not spend other people’s
money, which would require access to their private keys,
she could perform denial-of-service attacks, selectively
drop transactions, or charge excessive transaction fees.
In principle, a broken attestation key can be revoked
through the Intel Attestation Service (IAS), but this can
only happen if the break is detected to begin with. Conse-
quently, Intel has explored ways of detecting SGX com-
promise in PoET [6] by statistically testing for implau-
sibly frequent mining by a given node (using a “z-test”).
Details are lacking in published materials, however, and
a rigorous analytic framework seems to be needed.
For REM, we explore compromise detection within a
rigorous deﬁnitional and analytic framework. The cen-
terpiece is what we call a block-acceptance policy, a
ﬂexibly deﬁned rule that determines whether a proposed
block in a blockchain is legitimate. As we show, deﬁning
and analyzing policies rigorously is challenging, but we
provide strong analytical and empirical evidence that a
relatively simple statistical-testing policy (which we de-
note Pstat) can achieve good results. Pstat both limits an
USENIX Association
26th USENIX Security Symposium    1431
Figure 1: Architecture overview of REM
adversary’s ability to harvest blocks unfairly and mini-
mizes erroneous rejection of honestly mined blocks.
4.1 Threat Model and Deﬁnitions
4.1.1 Basic notation
policies,
block-acceptance
let M =
To model
{m1,··· ,mn} be the set of all miners, which we
assume to be static.
(Miners can join and leave the
system; M includes all potential miners.) An adversary
A controls a static subset MA ∈ M, where |MA| = k.
rate(mi) speciﬁes the mining rate of mi, the number of
mining operations per unit time it performs.
We deﬁne a candidate block to be a tuple B = (t,m,d),
where t is a timestamp, m ∈ M the identity of the CPU
that mines the block, and d is the block difﬁculty. Difﬁ-
culty d is deﬁned as the win probability per mining op-
eration in the underlying consensus protocol (e.g. a hash
in Bitcoin, a unit time of sleep in PoET, an instruction in
PoUW). B denotes the set of possible blocks B.
A blockchain is an ordered sequence of blocks. At
time τ, blockchain C(τ) is a sequence of accepted blocks
C(τ) = {B1,B2, . . . ,Bn} for some n. We drop τ where
its clear from context. We let r(τ) denote the number of
rejected blocks of honest miners, i.e., miners in M−MA,
in the history of C(τ). (Of course, r(τ) is not and indeed
cannot be recorded in a real blockchain system.) Let C
be the space of all possible blockchains C. Let Cm denote
blockchain C restricted to blocks mined by miner m ∈ M.
In REM, a blockchain-acceptance policy is used to de-
termine whether a block appears to come from a legiti-
mate miner (CPU that hasn’t been compromised).
1.
Deﬁnition
(Blockchain-Acceptance Policy) A
policy)
blockchain-acceptance
P : C ×B → {reject, accept} is a function that takes as
input a blockchain and a proposed block, and outputs
whether the proposed block is legitimate.
simply
policy
(or
4.1.2 Security and efﬁciency deﬁnitions
We model the consensus algorithm for the blockchain,
the adversary A, and honest miners respectively as
(ideal) programs progchain, progA, and progm. Together,
they deﬁne what we call a security game S(P) for a par-
ticular policy P.
We deﬁne security games and their constituent pro-
grams formally in Appendix A.2. Where clear from con-
text in what follows, we use the notation S, rather than
S(P), i.e., omit P.
A security game S may itself be viewed as a proba-
bilistic algorithm. Thus we may treat the blockchain re-
sulting from execution of S for interval of time τ as a
random variable CS(τ).
Normalizing the revenue from mining a block to 1, we
deﬁne the payoff for a miner m for a given blockchain C
as πm(C) = |Cm|.
An adversary A seeks to maximize payoffs for its min-
ers, as reﬂected in the following deﬁnition:
Deﬁnition 2. (Advantage of A). For a given security
game S, the advantage of A for time τ is:
AdvSA(τ) =
E[π ˆm(CS(τ))]
maxm j∈M−MA E[πm j (CS(τ))]
,
for any ˆm ∈ MA. Note that E[π ˆm(CS(τ))] is equal for all
such ˆm, as they all use strategy ΣA and can emit blocks
as frequently as desired (ignoring rate( ˆm)).
A policy that keeps AdvSA(τ) low is desirable, but
there’s a trade-off. A policy that rejects too many policies
incurs high waste, meaning that it rejects many blocks
from honest miners. We deﬁne waste as follows.
Deﬁnition 3. (Waste of a policy). For a given blockchain
C(τ) = {(B1,B2, . . . ,Bn)}, the waste is deﬁned as
Waste(C(τ)) =
r(τ)
n + r(τ)
.
For security game S, the waste at time τ is deﬁned as
WasteS(τ) = E[Waste(CS(τ))].
Our exploration of policies focuses critically on the
trade-offs between low AdvSA(τ) and low WasteS(τ). To
illustrate the issue, we give a simple example in Ap-
pendix A.3 of a policy that allows any CPU to mine only
one block over its lifetime. As τ → ∞, it achieves the
optimal AdvSA(τ) = 1, but at the cost of WasteS(τ) = 1,
i.e., 100% waste.
1432    26th USENIX Security Symposium
USENIX Association
StateNew	blockBlock-chainagentBlock	templatePoUWMinerPoUWEnclaveBlockchain	P2P	Network	TEEUseful	tasksUseful	resultsStateBlockchainAgentContentComplianceEffortVerifiers1223456Useful	Workclient(C,B):
Pα,ratebest
stat
parse B → (τ,m,d)
if |Cm| > F−1(1− α,dτ(ratebest)):
output reject
else
output accept
Figure 2: Pα
distribution with rate λ .
stat. F−1(·,λ ) is the quantile function for Poisson
4.2 The REM policy: Pstat
REM makes use of a statistical-testing-based policy that
we denote by Pstat. Pstat is compatible not just with
PoUW, but also with PoET and potentially other SGX-
based mining variants.
There are two parts to Pstat. First, Pstat estimates the
rate of the fastest honest miner(s) (fastest CPU type), de-
noted by ratebest = maxm∈M−MA rate(m). There are var-
ious ways to accomplish this; a simple one would be to
have an authority (e.g., Intel) publish specs on its fastest
CPUs’ performance.
(In PoET, mining times are uni-
form, so ratebest is just a system parameter.) We describe
an empirical approach to estimating ratebest in REM in
Appendix A.1.
Given an estimate of ratebest, Pstat
tests submitted
blocks statistically to determine whether a miner is min-
ing blocks too quickly and may thus be compromised.
The basic principle is simple: On receiving a block B
from miner m, Pstat tests the null hypothesis
H0 = {rate(m) ≤ ratebest}.
We use |Cm(τ)|, the number of blocks mined by m at
time τ, as the test statistic. Under H0, |Cm| should obey
a Poisson distribution with rate dτ(ratebest), denoted as
Pois[dτ(ratebest)]. Pstat rejects H0 if |Cm| is greater than
the (1−α)-quantile of the Poisson distribution. The false
rejection rate for a single test is therefore at most α. We
specify Pstat (for a given ratebest) in Figure 2.
An important property that differentiates Pstat from
canonical statistical tests is that Pstat repeatedly applies
a given statistical test to an accumulating history of sam-
ples. The statistical dependency between samples makes
the analysis non-trivial, as we shall show.
4.3 Analysis of Pstat
We now analyze the average-case and worst-case waste
and adversarial advantage of Pstat. We assume for sim-
plicity that ratebest is accurately estimated. We remove
this assumption in the worst-case analysis below. We
also assume that the difﬁculty d(t) is stationary over the
period of observation.
Waste Under Pstat, a miner generates blocks accord-
ing to a Poisson process; whether a block is accepted
or rejected depends on whether the miner has gener-
ated more blocks than a time-dependent threshold. This
process is obviously not memoryless and thus not di-
rectly representable as a Markov process. We can, how-
ever, achieve a close approximation using a discrete-time
Markov chain.
Indeed, as we show, we can represent
waste in Pstat using a discrete-time Markov chain that is
periodically identical to the process it models, meaning
that its expected waste is identical at any time nτ, for
n ∈ Z+ and τ a model parameter speciﬁed below. This
Markov chain has a stationary distribution that yields
an expression upper-bounding waste in Pstat.
(We be-
lieve, and the periodic identical property suggests, that
this bound is very tight.)
To construct the Markov Chain, we partition time into
intervals of length τ; we regard each such interval as a
discrete timestep. Assuming that all honest miners mine
at rate rate, let λ = dτ(rate). Thus an honest miner gen-
erates an expected Pois[λ ] blocks in a given timestep i,