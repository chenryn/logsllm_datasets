    	TCHAR szMutexName[MAX_PATH];
    	wsprintf(szMutexName, L"Test 15pb bingo! %d", GetCurrentProcessId());
    	g_hMutex = CreateMutex(NULL, TRUE, szMutexName);
    	TCHAR szLog[MAX_PATH] = { 0 };
    	wsprintf(szLog, L"NoModuleEntryCall Module Start:%p", hModule);
    	OutputDebugString(szLog);
    	//下面为正常Dll功能代码
    	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)NoModuleThread, NULL, NULL, NULL);
    }
    BOOL ChooseSub(HMODULE hModule, DWORD ul_reason_for_call, char* pstrModuleName)
    {
    	BOOL bRet = FALSE;
    	GetModuleFileNameA(NULL, exeModuleName, MAX_PATH);
    	if (ul_reason_for_call == NO_MODULE_MARK)
    		//	strcpy((char*)dllModuleName,pstrModuleName);
    		int a = 1;
    	else
    		GetModuleFileName(hModule, dllModuleName, MAX_PATH);
    	if (ul_reason_for_call == NO_MODULE_MARK)
    	{
    		NoModuleEntryCall(hModule, DLL_PROCESS_ATTACH, 0);
    		bRet = TRUE;
    	}
    	else
    	{
    		LaunchNoModule();
    		bRet = FALSE;
    	}
    	return bRet;
    }
    BOOL APIENTRY DllMain( HMODULE hModule,
                           DWORD  ul_reason_for_call,
                           LPVOID lpReserved
    					 )
    {
    	BOOL  bRet = FALSE;
    	if (ul_reason_for_call == DLL_PROCESS_ATTACH || ul_reason_for_call == NO_MODULE_MARK)
    	{
    		TCHAR szMutexName[MAX_PATH];
    		wsprintf(szMutexName, L"yanshier2013nomoduleinject%d", GetCurrentProcessId());
    		if (IsMutexExist((char*)szMutexName))
    			return FALSE;
    		bRet = ChooseSub(hModule, ul_reason_for_call, (char *)lpReserved);
    	}
    	else
    	{
    		if (ul_reason_for_call == DLL_PROCESS_DETACH)
    		{
    			ReleaseMutex(g_hMutex);
    			CloseHandle(g_hMutex);
    			bRet = TRUE;
    		}
    	}
    	return bRet;
    }
我注入了NTFSinfo这个程序.用PChunter是看不到自己注入的模块的
每隔一秒用 OutputString打印出一句 Test by IronMan. 需要的话直接在NoModuleThread替换功能就可以了。
自卸载dll源码编译 vs2010 vs2013
源码打包地址: 