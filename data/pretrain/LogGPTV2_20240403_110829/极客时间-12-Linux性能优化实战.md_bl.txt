# -l 表示只显示监听套接字
# -n 表示显示数字地址和端口 (而不是名字)
# -p 表示显示进程信息$ netstat -nlp | head -n 3Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      840/systemd-resolve 
# -l 表示只显示监听套接字
# -t 表示只显示 TCP 套接字
# -n 表示显示数字地址和端口 (而不是名字)
# -p 表示显示进程信息$ ss -ltnp | head -n 3State    Recv-Q    Send-Q        Local Address:Port        Peer Address:PortLISTEN   0         128           127.0.0.53%lo:53               0.0.0.0:*        users:(("systemd-resolve",pid=840,fd=13))LISTEN   0         128                 0.0.0.0:22               0.0.0.0:*        users:(("sshd",pid=1459,fd=3))netstat 和 ss的输出也是类似的，都展示了套接字的状态、接收队列、发送队列、本地地址、远端地址、进程PID 和进程名称等。其中，接收队列（Recv-Q）和发送队列（Send-Q）需要你特别关注，它们通常应该是0。当你发现它们不是 0时，说明有网络包的堆积发生。当然还要注意，在不同套接字状态下，它们的含义不同。当套接字处于连接状态（Established）时，-   Recv-Q    表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度）。-   而 Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）。当套接字处于监听状态（Listening）时，-   Recv-Q 表示 syn backlog 的当前值。-   而 Send-Q 表示最大的 syn backlog 值。而 syn backlog 是 TCP协议栈中的半连接队列长度，相应的也有一个全连接队列（acceptqueue），它们都是维护 TCP 状态的重要机制。顾名思义，所谓半连接，就是还没有完成 TCP三次握手的连接，连接只进行了一半，而服务器收到了客户端的 SYN包后，就会把这个连接放到半连接队列中，然后再向客户端发送 SYN+ACK 包。而全连接，则是指服务器收到了客户端的 ACK，完成了 TCP三次握手，然后就会把这个连接挪到全连接队列中。这些全连接中的套接字，还需要再被accept() 系统调用取走，这样，服务器就可以开始真正处理客户端的请求了。
## **协议栈统计信息**类似的，使用 netstat 或 ss ，也可以查看协议栈的信息：    $ netstat -s...Tcp:    3244906 active connection openings    23143 passive connection openings    115732 failed connection attempts    2964 connection resets received    1 connections established    13025010 segments received    17606946 segments sent out    44438 segments retransmitted    42 bad segments received    5315 resets sent    InCsumErrors: 42... $ ss -sTotal: 186 (kernel 1446)TCP:   4 (estab 1, closed 0, orphaned 0, synrecv 0, timewait 0/0), ports 0 Transport Total     IP        IPv6*  1446      -         -RAW  2         1         1UDP  2         2         0TCP  4         3         1...这些协议栈的统计信息都很直观。ss只显示已经连接、关闭、孤儿套接字等简要统计，而 netstat则提供的是更详细的网络协议栈信息。比如，上面 netstat 的输出示例，就展示了 TCP协议的主动连接、被动连接、失败重试、发送和接收的分段数量等各种信息。
## **网络吞吐和 PPS**接下来，我们再来看看，如何查看系统当前的网络吞吐量和PPS。在这里，我推荐使用我们的老朋友 sar，在前面的 CPU、内存和 I/O模块中，我们已经多次用到它。给 sar 增加 -n参数就可以查看网络的统计信息，比如网络接口（DEV）、网络接口错误（EDEV）、TCP、UDP、ICMP等等。执行下面的命令，你就可以得到网络接口统计信息：    
# 数字 1 表示每隔 1 秒输出一组数据$ sar -n DEV 1Linux 4.15.0-1035-azure (ubuntu) 01/06/19 _x86_64_(2 CPU) 13:21:40        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil13:21:41         eth0     18.00     20.00      5.79      4.25      0.00      0.00      0.00      0.0013:21:41      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.0013:21:41           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00这儿输出的指标比较多，我来简单解释下它们的含义。-   rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。-   rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒。-   rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。-   %ifutil 是网络接口的使用率，即半双工模式下为    (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s,    txkB/s)/Bandwidth。其中，Bandwidth 可以用 ethtool 来查询，它的单位通常是 Gb/s 或者Mb/s，不过注意这里小写字母 b，表示比特而不是字节。我们通常提到的千兆网卡、万兆网卡等，单位也都是比特。如下你可以看到，我的eth0 网卡就是一个千兆网卡：    $ ethtool eth0 | grep SpeedSpeed: 1000Mb/s
## **连通性和延时**最后，我们通常使用 ping ，来测试远程主机的连通性和延时，而这基于 ICMP协议。比如，执行下面的命令，你就可以测试本机到 114.114.114.114 这个 IP地址的连通性和延时：    