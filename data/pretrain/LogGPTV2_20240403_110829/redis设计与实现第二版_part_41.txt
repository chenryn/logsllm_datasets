全部迁移至目标节点
将这些键
源节点执行客户端发送的命令
源节点准备迁移槽 slot的键值对
目标节点准备导人槽 slot的键值对
完成对槽 slot的重新分片
将槽 slot指派给目标节点
开始对槽 slot 进行重新分片
客户端向源节点发送关于键key的命令
源节点是否保存了
于槽siot的键？
是
图17-26判断是否发送ASK错误的过程
源节点的数据库？
是
否
Y
键 key不存在键key 有可能在目标节点
源节点正在迁移槽
向客户端返回ASK错误
香
第17章
群267
---
## Page 272
268◆第三部分多机数据库的实现
结构，那么表示当前节点正在从 clusterNode 所代表的节点导人槽 i。
节点导人的槽：
17.5.1 CLUSTER SETSLOT IMPORTING 命令的实现
redis-cli真正支持ASK自动转向时，它的行为和上面展示的行为可能会有所不同。
ASK 自动转向行为实际上是根据 MOVED 自动转向行为虚构出来的。因此，当集群模式的
7003，然后再次执行命令：
发送的 ASK 错误的话，可以使用单机模式的 redis-cli 客户端：
不会打印错误，而是自动根据错误提供的IP地址和端口进行转向动作。如果想看到节点
在对集群进行重新分片的时候，向目标节点发送命令：
如果importing_slots_from[i］的值不为 NULL，而是指向一个 clusterNode
本节将对 ASK 错误的实现原理进行说明，并对比 ASK 错误和 MOVED 错误的区别。
在写这篇文章的时候，集群模式的 redis-cli 并未支持 ASK 自动转向，上面展示的
typedef struct clusterState {
127.0.0.1:7002> GET "1ove"
而如果我们向节点7002发送关于键"1ove”的命令，那么客户端会先被转向至节点
127.0.0.1:7003>
-> Redirected to slot [16198] located at 127.0.0.1:7003
127.0.0.1:7002> GET "is"
如果我们向节点7002发送关于键"is"的命令，那么这个命令会直接被节点7002执行：
 clusterState;
127.0.0.1:7002> GET "1ove"
$ redis-cli -p 7002
和接到 MOVED 错误时的情况类似，集群模式的 redis-Cli 在接到 ASK 错误时也
(error) ASK 16198 127.0.0.1:7003
!!...
clusterNode *importing_slots_from[16384];
被隐藏的 ASK 错误
---
## Page 273
那么表示当前节点正在将槽i 迁移至clusterNode所代表的节点。
节点的槽：
示的样子。
source_id 所代表节点的 clusterNode 结构。
17.5.2
clusterState 结构的migrating_slots_to数组记录了当前节点正在迁移至其他
如果migrating_slots_to[i］的值不为 NULL，而是指向一个clusterNode结构，
typedef struct clusterstate {
OK
127.0.0.1:7003> CLUSTER SETSLOT 16198 IMPORTING 9dfb4c4e0i6e627d9769e4c9bb0d4fa2
举个例子，如果客户端向节点7003发送以下命令：
 clusterState;
 9dfb..
CLUSTER SETSLOT  IMPORTING 
!/...
 clusterNode *migrating_slots_to[16384];
08e65c26
 CLUSTER SETSLOT MIGRATING 命令的实现
importing_slots_from
clusterState
是节点7002的ID
+**
图 17-27节点 7003的 importing_slots_from数组
16383
16382
16381
16198
→NULL
→NULL
→NULL
→NULL
→NULL
→NULL
"127.0.0.1"
 clusterNode
7002
port
第17章
ip
集
群·269
---
## Page 274
270·第三部分多机数据库的实现
在导人槽i的节点去查找键key。
如果槽i的确在进行迁移的话，那么节点会向客户端发送一个ASK 错误，引导客户端到正
clusterState.migrating_slots_to[i]，看键 key 所属的槽i是否正在进行迁移,
客户端发送的命令。
个节点，那么节点会尝试在自己的数据库里查找键key，如果找到了的话，节点就直接执行
17.5.3
的样子。
所代表节点的clusterNode结构。
举个例子，假设在节点7002向节点7003迁移槽16198期间，有一个客户端向节点7002
与此相反，如果节点没有在自己的数据库里找到键key，那么节点会检查自己的
如果节点收到一个关于键key 的命令请求，并且键 key 所属的槽i 正好就指派给了这
OK
127.0.0.1:7002> CLUSTER SETSLOT 16198 MIGRATING 04579925484ce537d3410d7ce97bd2e2
#0457..
举个例子，如果客户端向节点7002发送以下命令：
CLUSTER SETSLOT  MIGRATING 
在对集群进行重新分片的时候，向源节点发送命令：
60c459a2
ASK 错误
migrating_slots_to
clusterState
是节点7003的ID
+.
图 17-28 节点 7002 的 migrating_slots_to 数组
clusterNode*[16384]
16383
16382
16381
16198
...
2
。
→ NULL
→ NULL
→NULL
NULL
NULL
NULL
"127.0.0.1"
clusterNode
7003
port
+··
ip
---
## Page 275
是该命令的伪代码实现：
17.5.4
节点，然后首先向目标节点发送一个ASKING命令，之后再重新发送原本想要执行的命令。
16198有关的操作，如图17-29所示。
回错误：
to［16198］，节点7002发现自己正在将槽16198迁移至节点7003，于是它向客户端返
键"love"，
发送命令：
ASKING 命令唯一要做的就是打开发送该命令的客户端的 REDIS_ASKING 标识，以下
以前面的例子来说，当客户端接收到节点7002返回的以下错误时：
接到 ASK 错误的客户端会根据错误提供的 IP地址和端口号，转向至正在导人槽的目标
这个错误表示客户端可以尝试到IP为127.0.0.1，端口号为7003的节点去执行和槽
ASK 16198 127.0.0.1:7003
因为键"1ove”正好属于槽16198，所以节点7002会首先在自己的数据库中查找
def ASKING():
整个过程如图 17-30 所示。
客户端会转向至节点7003，首先发送命令：
GET "love"
"you get the key 'love!"
并获得回复：
GET "love"
然后再次发送命令：
ASKING
ASK 16198 127.0.0.1:7003
 ASKING 命令
但并没有找到，通过检查自己的clusterState.migrating_slots_
客户端
图17-29客户端接收到节点7002返回的ASK错误
客户端
ASK 16198 127.0.0.1:7003
图17-30客户端转向至节点 7003
"you get the key 'love'"
· GEr "love"
GET "love"
ASKING
转向
节点7003
节点7002
第17章
集
群271
---
## Page 276
272◆第三部分多机数据库的实现
GET命令就会被节点7003执行：
点7003会向客户端返回MOVED错误，指引客户端转向至节点7002。
7003发送以下命令：
MOVED 错误。
令，而直接发送想要执行的命令的话，那么客户端发送的命令将被节点拒绝执行，并返回
ASKING命令，然后才重新发送想要执行的命令，这是因为如果客户端不发送ASKING命
17-31展示了这个判断过程。
的客户端带有 REDIS_ASKING 标识，那么节点将破例执行这个关于槽i的命令一次，图
clusterState.importing_slots_from[i］显示节点正在导人槽i，并且发送命令
派给这个节点的话，那么节点将向客户端返回一个MOVED 错误；但是，如果节点的
但是，如果我们在发送GET命令之前，先向节点发送一个ASKING命令，那么这个
举个例子，我们可以使用普通模式的redis-cli客户端，向正在导人槽16198 的节点
127.0.0.1:7003> ASKING
虽然节点7003正在导人槽16198，但槽16198目前仍然是指派给了节点7002，所以节
127.0.0.1:7003> GET "1ove"
127.0.0.1:7003> GEr "1ove"
$ ./redis-cli -p 7003
当客户端接收到ASK错误并转向至正在导人槽的节点时，客户端会先向节点发送一个
在一般情况下，
(error) M0vED 16198 127.0.0.1:7002
reply("ok")
#向客户端返回OK回复
client,flags I= REDIS_ASKING
#打开标识
节点执行客户端发送的命令
如果客户端向节点发送一个关于槽i的命令，而槽i又没有指
图17-31节点判断是否执行客户端命令的过程
客户端向节点发送关于槽1 的命令
i是否指派给了节点？
是
ASKING 标识?
客户端是否带有
节点是否正在导人槽
否
---
## Page 277
表示从节点）。
点，如图17-32所示（图中以双圆形表示主节点，单圆形
加到集群里面，并将这两个节点设定为节点7000的从节
主节点的集群来说，我们可以将7004、7005两个节点添
点继续处理命令请求。
某个主节点，并在被复制的主节点下线时，代替下线主节
（slave），其中主节点用于处理槽，而从节点则用于复制
17.6复制与故障转移
17.5.5ASK错误和MOVED错误的区别
移除：
么第二次发送的 GET命令将执行失败，因为这时客户端的 REDIS_ASKING 标识已经被
会被移除。
个带有 REDIS_ASKING 标识的客户端发送的命令之后，客户端的 REDIS_ASKING 标识就
举个例子，对于包含7000、7001、7002、7003四个
Redis 集群中的节点分为主节点（master）和从节点
举个例子，如果我们在成功执行GET命令之后，再次向节点7003发送GET命令，那
口与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户
ASK错误和MOVED错误都会导致客户端转向，它们的区别在于：
127.0.0.1:7003> GET "1ove"
127.0.0.1:7003> ASKING
另外要注意的是，客户端的 REDIS_ASKING 标识是一个一次性标识，当节点执行了一
口MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到
(error) MOvED 16198 127.0.0.1:7002
127.0.0.1:7003> GET "1ove"
"you get the key 'love'n
"you get the key 'love'"
负责处理槽i 的节点，除非 ASK 错误再次出现。
于槽i的命令请求产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前
i 的命令请求发送至 ASK 错误所指示的节点，但这种转向不会对客户端今后发送关
端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽
节点。
接将命令请求发送至 MOVED 错误所指向的节点，因为该节点就是目前负责槽i 的
关于槽i的 MOVED 错误之后，客户端每次遇到关于槽i的命令请求时，都可以直
#REDIS_ASKING 标识未打开，执行失败
#移除 REDIS_ASKING 标识
#打开 REDIS_ASKING 标识
图 17-32设置节点 7004 和节点
7005成为节点7000的从节点
7002
7001
7000
1
复制
复制
第17章
集
7003
7005
1004
群273
---
## Page 278
274第三部分多机数据库的实现
点，如图17-34 所示。
集群各个节点的当前状态，
围的节点为已下线节点)。
改为复制节点7004，如图17-33所示（图中用虚线包
至槽5000，节点7005也会从原来的复制节点7000
么节点7004将接管原来由节点7000负责处理的槽
送的命令请求。
原来节点7000负责处理的槽，并继续处理客户端发
出一个节点作为新的主节点，这个新的主节点将接管
7000的两个从节点—节点7004和节点7005中选
表17-2记录了在对节点7000进行故障转移之后，
例如，如果节点7004被选中为新的主节点，那
如果在故障转移完成之后，下线的节点7000重新上线，那么它将成为节点7004的从节
如果这时，节点7000进人下线状态，那么集群中仍在正常运作的几个主节点将在节点
表17-1记录了集群各个节点的当前状态，以及它们正在做的工作。
7005
7004
7003
7002
7001
7000
7005
7004
7003
7002
7001
7000
节点