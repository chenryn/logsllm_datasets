Usually, if more than 3 packets are sent to the server under 10 ms,
the random value added to the IPID counter will never be larger
than one [3]. We send ICMP request packets to the server in parallel
and restrict the increment of system ticks. Our experiments show
that if the round-trip time (RTT) from the attacker to the server is
within 200 ms, the attacker only needs to send less than 300 packets
per second to force the hash-based IPID counter increasing linearly.
There are totally 2048 hash-based IPID counters in Linux, and the
probability of hash collisions between the attacker and the client is a
geometric distribution. When the protocol is specified as ICMP (see
Eq. 1), if the attacker has k IP addresses, the probability of collisions
between the attacker and the target client is 1 − (1 − p)k, where p
equals 1/2048. To construct an attack in practice, the attacker has
two strategies to detect victim clients by leveraging hash collisions.
The procedure of detecting victim clients by constructing hash
collisions is shown in Figure 4. First, the attacker pretends to be a
router and sends a forged ICMP “Fragmentation Needed” message
1A special case is that the source port in a spoofed SYN packet happens to match the
source port of a TCP connection from the client to the server. In this case, the spoofed
SYN packet will trigger a challenge ACK packet, instead of a SYN/ACK packet. However,
the attacker can still observe an additional increment to the shared IPID counter.
5
AttackerVictim serverVictim client requestsrc.ip=attackerreplyIPID=xSYNsrc.ip=clientSYN/ACKIPID=4444 requestsrc.ip=attackerreplyIPID=x+1ICMP(cid:256)Fragmentation Needed(cid:257){Clearing the DF flag of packets to the clientAttackerVictim serverVictim client requestsrc.ip=attackerreplyIPID=xSYNsrc.ip=clientSYN/ACKIPID=x+1 requestsrc.ip=attackerreplyIPID=x+2ICMP(cid:256)Fragmentation Needed(cid:257){Clearing the DF flag of packets to the clientAttacking Potential Targets. If the attacker has only one or a
few IP addresses, the attacker can detect potential victim clients
who collide with the attacker. In theory, if the attacker has only one
IP address, on a target server, the number of clients conflicting with
the attacker is 232/2048 = 221. Since the detection only depends
on the server side, the attacker can create a list of IP addresses
and select one from the list as the client’s IP address each time.
Following the procedure in Figure 4, the attacker can determine if
the selected one is a victim. In this way, the attacker can identify
and enumerate all the potential victim clients who are vulnerable to
its IP address. In our test, an attacker can detect more than 20 victim
clients within 6 minutes using one IP address (see Section 7.1).
Attacking Arbitrary Targets. If the attacker has enough number
of IP addresses, it can attack arbitrary TCP connections by alter-
nating its IP addresses to generate the hash collision. According
to the geometric probability distribution, if the attacker has more
than 2048 IP addresses, it can collide with any clients with above
63.2% probability. Especially, for servers having the IPv4 and IPv6
dual-stack, attackers can use IPv6 addresses to construct hash colli-
sions with arbitrary target clients, since both IPv4 and IPv6 use the
same 2048 hash-based IPID counters [53].
The detected hash-based IPID counter shared with the victim
client is stable. That is, if the server does not restart (i.e., the
Boot_key in Eq. 1 is not altered), the client’s TCP connection will
always share this IPID counter with the attacker. In practice, servers
(e.g., web servers and BGP routers) do not restart frequently. Hence,
the attacker can detect shared IPID counters and victim clients in
advance, regardless of if TCP connections have been established.
Note Linux assigned IPID to RST packets based on hash coun-
ters before version 4.18, and thus an attacker can observe its IPID
distribution to determine if it shares the same counter with the
client by spoofing SYN/ACK packets [3]. This vulnerability has been
fixed since Linux 4.18 by always setting the IPID of RST packets to
0, incurring no changes on any IPID counters. However, we find
that after the critical step of downgrading the IPID assignment,
an attacker can still detect hash collisions through forging SYN
packets and triggering the server to respond SYN/ACK packets and
then identify a victim client. Moreover, we will show that the fix
of assigning 0 to RST packets introduces yet another vulnerability,
which can be exploited by a pure off-path attacker to detect the
presence of victim TCP connections (see Section 5.1).
5 DETECTING TCP CONNECTIONS
Once a victim client is identified, the attacker can learn the presence
of TCP connections between the client and the server.
5.1 TCP Connection Detection
A TCP connection is identified by a four-tuple, i.e., [source IP ad-
dress, source port number, destination IP address, destination port
number]. Usually, the destination IP address, and port number are
public known, so an attacker only needs to infer the source IP ad-
dress and source port number. In our attack, since the victim client
can be detected by using hash collisions, the only missing tuple is
the source port number.
Assuming that a TCP connection from source port y has been
established earlier by a legal user in the victim client, an off-path
attacker can identify this port number by sending out probing
packets. First, the attacker continuously sends ICMP echo request
packets to the server and observes the IPID values of the reply
packets from the server. Then, the attacker impersonates the victim
client and sends a forged SYN/ACK packet with a guessed source
port number to the server. If the source port number specified
in the SYN/ACK packet does not equal y, according to the TCP
specification [41], the server will respond a RST packet to the client.
Due to the patch fixing the vulnerability identified by Alexander et
al. [3], Linux kernel versions 4.18 and beyond assign an IPID of 0
to the RST packet, which will not incur an increment to the shared
IPID counter. Hence, the IPID values in the reply packets observed
by the attacker are continuous.
If the guessed source port number specified in the forged SYN/ACK
packet equals y, the challenge ACK mechanism [44] makes the server
send a challenge ACK packet to the victim client for confirming the
legitimacy of the SYN/ACK packet. The IPID in the challenge ACK
packet will be assigned based on the shared IPID counter, which
will incur an additional increment to the counter. Thus, from the
view of the attacker, the IPID values in the reply packets from the
server will not be continuous.
The attacker repeats the above procedure, i.e., changing the
source port number specified in the forged SYN/ACK packet and
then observing the IPID of the reply packets, until the correct port
number y is identified. Finally, the TCP connection running on the
identified four-tuple is all known to the attacker.
5.2 Practical Considerations in Detection
There are three practical considerations that may have impact on
the detection time cost and the success rate.
(1) Unexpected Responses to SYN/ACK Packets. According to
the TCP specification, when receiving an unexpected SYN/ACK
packet, the server responds a RST packet to the client. However,
in practice, the RST packet may not be sent to the client in two
circumstances. First, some TCP implementations may not follow
the specification strictly, i.e., the server does not issue a RST packet
when an unexpected SYN/ACK packet is received. Second, firewalls
or other middleboxes may filter and discard the RST packet from the
server. However, in either case, the detection of TCP connections
will not be disturbed notably. The reason is that even if the RST
packet is discarded or not generated, it is still the same as being
accepted by the client and the shared IPID counter will not have an
additional increment. Instead, when the source port number y is
identified, the challenge ACK packet will be certainly issued to the
client due to the strict standard action enforced by RFC 5961, so
the attacker will observe the change of the IPID counter. Therefore,
the unexpected responses to SYN/ACK packets will not affect the
detection of TCP connections.
(2) Parallel Search for Source Port. The maximum possible port
range is 216 (from 0 to 65535), but the default range of source port
number on Linux is only from 32768 to 61000 and Windows has a
more narrow source port range from 49152 to 655352. To facilitate
the identification of the source port, the attacker can adopt a parallel
approach to search the source port number by sending multiple
probing packets in a certain range during a period. If the source
2The OS types or versions of the client are unrestricted in our exploit.
6
port is in the range, the shared IPID counter will have an additional
increment, so the attacker can further narrow the range. Otherwise,
the attacker can detect another port range in parallel. In addition,
the attacker can use a binary-search-like algorithm [9, 10] to further
reduce the detection time cost.
(3) Rate Limit of Challenge ACK. In order to avoid DoS attacks
against the server, the implementations of challenge ACK usually
enforce a rate limit to restrict the number of challenge ACK packets,
e.g., the rate limit enforced on per TCP connection on Linux is
no more than 1 challenge ACK packet per 500ms. Therefore, when
detecting TCP connections using the parallel approach, we need to
consider the rate limit of challenge ACK. Assuming we have located
the source port number in the range of [i, i + n], we need to further
narrow the detection range and the next challenge ACK packet will
be sent in 500 ms. In practice, the time cost is acceptable and will
not have a notable impact on the detection time. In our test, we can
detect a victim TCP connection within 40 seconds.
6 INFERRING SEQUENCE AND
ACKNOWLEDGMENT NUMBERS
In this section, we first briefly review the checking mechanism
for TCP sequence and acknowledgment numbers. To detect the
exact sequence number and an acceptable acknowledgment num-
ber for successfully injecting a forged segment into the target TCP
connection, we develop a four-step inference method. First, we
infer acceptable sequence numbers in the server’s receive window.
Second, based on the inferred sequence number, we locate the chal-
lenge ACK window. Third, we detect the lower boundary of the
server’s receive window (i.e., the exact sequence number) based
on the identified acceptable sequence numbers and challenge ACK
window. Finally, we detect the acceptable acknowledgment num-
bers via probing the boundary of the challenge ACK window and
inferring the boundary of the server’s send window. After obtaining
those information, the attacker is able to inject malicious segments
into the target TCP connection.
6.1 Preliminaries: Verifying Sequence Number
An TCP segment receiver first checks the sequence number in
the segment header based on its receive window when a TCP seg-
ment arrives, i.e., the condition of RCV .N XT <= SEG.SEQ <=
RCV .N XT + RCV .W N D must be satisfied, where SEG.SEQ is the
sequence number of the received segment, RCV .N XT is the se-
quence number of the next octet that the receiver expects to receive,
and RCV .W N D is the receive window size. Besides, the receiver
following RFC 5961 will check the acknowledgment number based
on its acceptable ACK window as described in Section 2.3. After
passing these two checks, the segment will be accepted. In current
TCP implementations, the ACK flag is always set to TRUE except for
the first SYN packet for establishing the connection. As a result, the
guessing of the acknowledgment number cannot be circumvented
by disabling the ACK flag.
Since TCP is a full duplex protocol, when both the sequence and
acknowledgment number acceptable by one side are inferred, the at-
tacker can also identify the sequence and the acknowledgment num-
ber acceptable by the other side. For example, in fact, the RCV .N XT
and SN D.N XT on the server are equivalent to SN D.N XT and
7
RCV .N XT on the client [9, 10, 41]. Hence, the attacker only needs
to infer the sequence and acknowledgment numbers of one side. In
our attack, we focus on inferring the sequence and acknowledgment
numbers acceptable by the server.
6.2 Inferring Acceptable Sequence Number
To infer the acceptable sequence numbers on the server side, the
attacker continuously sends ICMP request packets to the server and
observes the IPID values of the reply packets. Then, the attacker
impersonates the victim client to send a spoofed RST packet to the
server. The RST packet is specified with the guessed sequence num-
ber seq. We need to consider two cases: (i) seq not in the server’s
receive window and (ii) seq in the server’s receive window. Accord-
ing to the challenge ACK mechanism described in Section 2.3, in the
first case, the server will discard the spoofed RST packet directly,
so it does not influence the shared IPID counter. In the second case
when the guessed seq is in the server’s receive window, the server
will respond to this RST packet and send a challenge ACK packet to
the victim client to confirm the legitimacy of the packet. The IPID
of this challenge ACK packet is assigned based on the shared IPID
counter, and it will incur an additional increment to the counter.
The attacker can observe the increment and then determine that
the guessed seq is located in the server’s receive window3.
In practice, in order to reduce the time cost of sequence number
inference, the attacker can divide the sequence number space into
multiple blocks whose sizes are equal to the default receive window
size in Linux (87380 octets), probing only once per block. Besides,
the attacker can apply parallel search methods similar to those used
in connections detection to further reduce the time cost.
6.3 Locating the Challenge ACK Window
According to RFC 5961, when a segment arrives at the server, the
server also checks the segment’s acknowledgment number even
if its sequence number is in the server’s receive window. There
are three cases in the whole acknowledgment number space: (i)
the acknowledgment number in challenge ACK window, (ii) in the
acceptable ACK range, and (iii) invalid acknowledgment numbers.
In the first case, the server will issue a challenge ACK packet to
confirm the legitimacy of the triggering segment. In the second
case, the server will accept the segment directly. Otherwise, if the
segment carries an invalid acknowledgment number, the server
will discard it silently. The last two cases cannot be differentiated
directly because it cannot be observed from an off-path attacker.
However, the attacker can first identify the challenge ACK window
of the server and then infer the acceptable ACK numbers.
When locating the challenge ACK window, the attacker observes
and records the shared IPID counter. Then the attacker imperson-
ates the victim client and sends a spoofed ACK packet with a guessed
acknowledgment number ack to the server, the packet is also speci-
fied with an acceptable sequence number detected previously. If ack
is in the challenge ACK window of the server, a challenge ACK packet
will be issued, incurring an additional increment to the shared IPID
counter. Instead, if ack is not in the challenge ACK window, the
3In a special case when seq exactly matches the server’s RCV .N XT , the server will
reset the connection directly. However, the probability of this case occurring is 1/232,
which is negligible.
observed IPID will be continuous from the view of the attacker. In
practice, the challenge ACK window size is always between 1G and
2G [8–10], i.e., one quarter of the entire acknowledgment number
space. Hence, to facilitate the detection, the attacker can divide the
entire space into 4 blocks and probe each block to check which
block the challenge ACK window falls in.
6.4 Detecting the Exact Sequence Number