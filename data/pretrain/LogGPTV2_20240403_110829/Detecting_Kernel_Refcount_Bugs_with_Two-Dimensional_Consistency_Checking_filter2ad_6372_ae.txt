Though CRCount releases developers from the complicated
management of objects/references, its performance overhead
prevents its wide application. For programs that still rely on
manual manipulation of refcount operations (e.g., Linux ker-
nel, Mozilla Firefox), CID helps to detect refcount bugs.
Refcount Bug Detection. Due to the importance of refcount,
several works have attempted to detect them. Software de-
velopers and testers have implemented refcount tracing and
balancing techniques [6] to track leak of refcounted objects
dynamically in FireFox. The coverage of dynamical testing
is limited by its inputs. The researchers thus prefer to de-
tect refcount bugs through static analysis or symbolic exe-
cution. Referee [17] uses symbolic model checking to ﬁnd
the refcount errors in the presence of multiple threads. The
checking needs a complete control ﬂow about the program
under analysis, and it further assumes that the resources/ob-
jects is managed in the same way. Due to this assumption,
it is impossible to be applied to OS kernels. Pungi [24] per-
forms refcount bug detection in the native implementations of
USENIX Association
30th USENIX Security Symposium    2483
Python/C programs with a strong property that the change of
a refcount must equal the number of references escaped from
the function. However, it is hard to apply to the OS kernels
due to two reasons: 1) it requires accurate inter-procedural
escape-analysis which is hard to realize in the kernel; 2) its
detection strategy doesn’t ﬁt the kernel design where many
functions (e.g., wrappers) can increase/decrease the refcount
without reference-escaping. RID [29] proposes inconsistent
path pair (abbreviated as IPP) checking to detect refcount
bugs. The IPP checking identiﬁes the refcount inconsistency
between the paths which are indistinguishable outside the
target function by examining their arguments and the return
value. However, its detection scope is very narrow, as shown
in our evaluation—only detecting 10 out of 60 refcount bugs
reported between 2018 and 2020 from the Linux kernel.
Consistency Checking. Engler et al. [18] were among the
ﬁrst to explore the idea of statistical analysis. Though the
approach is unsound, it is widely adopted by researchers to de-
tect different kinds of bugs. Juxta [31] applies cross-checking
to detect semantic bugs between semantically equivalent im-
plementations of ﬁle systems. Yamaguchi et al. [41] infers
search patterns for taint-style vulnerabilities through cluster-
ing the sink patterns. APISan [43] aims to ﬁnd deviations
from majority in API usages under rich symbolic contexts.
CRIX [26] cross-checks the semantics of conditional state-
ments in the peer slices of critical variables to compare their
criticalness. RoleCast [38] also applies consistency checking
to detect role-speciﬁc missing checks in Web applications.
CID differs from all existing works from two perspectives.
First, CID is the ﬁrst to apply cross checking in refcount
bug detection. Refcount bug detection is much more com-
plicated by its nature, which requires the identiﬁcation of
refcount ﬁelds and operations. Second, Many refcount func-
tions are called only in a limited number of times, rendering
cross checking ineffective. CID incorporates the INC-DEC
consistency checking, which requires only one occurrence, to
address this problem.
Static Analysis in Kernels. Since more and more operating
systems are open-sourced (e.g., Linux, FreeBSD), static analy-
sis technique is widely adopted in detecting many kinds of se-
curity bugs in the kernel. Firstly, source code-based static anal-
ysis tools such as Smatch [8], Sparse [9] and Coccinelle [32]
are frequently used in the Linux kernel for source code analy-
sis and manipulation. However, these tools are not suitable for
implementing CID. Take Coccinelle as an example, it is not
used to build CID for two reasons: 1) our detection leverages
the correlation between different operations across functions
instead of capturing a speciﬁc pattern in one function; 2) our
approach relies on more heavy-weight data-ﬂow analysis such
as reference-escape analysis, path-constraint analysis which
is hard to implement in Coccinelle scripts.
Secondly, intermediate code-based analysis is preferred by
several recent works. K-Miner [20] partitions the kernel code
along separate execution paths starting from system-call entry
points to allow practical inter-procedural data-ﬂow analysis.
Dr.Checker [28] focuses on the Linux kernel drivers and im-
proves the precision of data ﬂow analysis by sacriﬁcing sound-
ness in a few cases. Both K-Miner [20] and Dr.Checker [28]
aim to improve practicality and precision of data ﬂow analysis
in kernel and serve as general bug detection tools. Meanwhile,
there are some detection tools designed for detecting a spe-
ciﬁc kind of bugs in kernel. UniSan [27] detects information
leaks caused by uninitialized reads. KINT [39] detects integer
errors. Other complementary approaches to static analysis use
symbolic execution [15, 34]. In comparison, CID leverages
precise path-sensitive intra-procedural analysis to perform
refcount bug detection instead of performing complex inter-
procedural analysis in the kernel. CID also employs tailored
techniques to identify refcount-related ﬁelds and operations.
9 Conclusion
Refcount bugs are quite common in the Linux kernel and
cause critical security impacts. This paper presented CID, a
scalable and effective system for refcount bug detection using
a two-dimensional consistency checking. CID models all ref-
count behaviors. In one dimension, it infers condition-aware
rules for detecting refcount bugs, and in the other dimension,
it detects deviating DEC behaviors across refcount callers. This
design helps CID avoid complicated semantic understanding
or reasoning on refcount operations, and to cover more bugs
than the state-of-the-art tools. Furthermore, considering ref-
count operations are diversely spanned in the whole kernel,
CID introduces behavior-based inference to systematically
identify refcount ﬁelds and the operations. By applying CID
to the Linux kernel, we found 44 new bugs, and the maintain-
ers have conﬁrmed 36 bugs.
Acknowledgements
We would like to thank our shepherd Thorsten Holz and
anonymous reviewers for their helpful comments. This work
was supported in part by the National Natural Science
Foundation of China (U1636204, U1836210, U1836213,
U1736208, 61972099), Natural Science Foundation of Shang-
hai (19ZR1404800), and National Program on Key Basic
Research (NO. 2015CB358800). Min Yang is the correspond-
ing author, and a faculty of Shanghai Institute of Intelligent
Electronics & Systems, Shanghai Institute for Advanced Com-
munication and Data Science, and Engineering Research Cen-
ter of CyberSecurity Auditing and Monitoring, Ministry of
Education, China. The authors from the University of Min-
nesota were supported in part by NSF awards CNS-1815621
and CNS-1931208. Any opinions, ﬁndings, conclusions, or
recommendations expressed in this material are those of the
authors and do not necessarily reﬂect the views of NSF.
2484    30th USENIX Security Symposium
USENIX Association
References
[1] Atomic type documentation. https://www.kernel.
org/doc/Documentation/atomic_t.txt.
[2] CVE-2016-0728 Bug Report.
https://perception-
point.io/resources/research/analysis-and-exploitation-
of-a-linux-kernel-vulnerability/.
[3] Kref type documentation. https://www.kernel.org/
doc/Documentation/kref.txt.
[4] Linux kernel git.
https://git.kernel.org/pub/
scm/linux/kernel/git/torvalds/linux.git.
[5] Refcount operation
documentation.
https:
//www.kernel.org/doc/Documentation/
driver-api/basics.rst.
[6] Refcount Tracing And Balancing for Firefox. https:
//developer.mozilla.org/en-US/docs/Mozilla/
Performance/Refcount_tracing_and_balancing.
[7] Refcount_t
type
documentation.
https:
//www.kernel.org/doc/Documentation/
core-api/refcount-vs-atomic.rst.
[8] Smatch: pluggable static analysis for C. https://lwn.
net/Articles/691882/.
[9] Sparse: a semantic parser for C. https://www.kernel.
org/doc/html/v4.14/dev-tools/sparse.html.
[10] A. Alexandresc. Modern C++ design: generic program-
ming and design patterns applied. 2001.
[11] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen,
and Abhik Roychoudhury. Directed Greybox Fuzzing.
In Proceedings of the 24th ACM SIGSAC Conference on
Computer and Communications Security (CCS), pages
2329–2344, 2017.
[12] Daniel Bovet and Marco Cesati. Understanding The
Linux Kernel. 2005.
[13] Hongxu Chen, Yinxing Xue, Yuekang Li, Bihuan Chen,
Xiaofei Xie, Xiuheng Wu, and Yang Liu. Hawkeye: To-
wards a Desired Directed Grey-Box Fuzzer. In Proceed-
ings of the 25th ACM SIGSAC Conference on Computer
and Communications Security (CCS), 2018.
[15] Vitaly Chipounov, Volodymyr Kuznetsov, and George
Candea. S2E: A Platform for in-Vivo Multi-Path Anal-
ysis of Software Systems. In Proceedings of the 16th
International Conference on Architectural Support for
Programming Languages and Operating Systems (ASP-
LOS), page 265–278, 2011.
[16] Jonathan Corbet. Faster reference-count overﬂow pro-
tection. https://lwn.net/Articles/728675/.
[17] Michael Emmi, Ranjit Jhala, Eddie Kohler, and Rupak
Majumdar. Verifying Reference Counting Implementa-
tions. In Tools and Algorithms for the Construction and
Analysis of Systems, pages 352–367, Berlin, Heidelberg,
2009.
[18] Dawson R. Engler, David Yu Chen, and Andy Chou.
Bugs as Deviant Behavior: A General Approach to In-
ferring Errors in Systems Code. In Proceedings of Sym-
posium on Operating Systems Principles (SOSP), 2001.
[19] David Gay, Rob Ennals, and Eric Brewer. Safe Manual
Memory Management. In Proceedings of the 6th Inter-
national Symposium on Memory Management (ISMM),
page 2–14, 2007.
[20] David Gens, Simon Schmitt, Lucas Davi, and Ahmad-
Reza Sadeghi. K-Miner: Uncovering Memory Corrup-
tion in Linux. In Proceedings of 25th Annual Network
and Distributed System Security Symposium (NDSS).
The Internet Society, 2018.
[21] Sean Heelan, Tom Melham, and Daniel Kroening. Au-
tomatic Heap Layout Manipulation for Exploitation. In
Proceedings of the 27th USENIX Security Symposium
(USENIX Security), pages 763–779, Baltimore, MD, Au-
gust 2018.
[22] Greg Kroah-Hartman. Kobjects and Krefs. In Proceed-
ings of the Linux Symposium, 2004.
[23] Chris Lattner and Vikram Adve. LLVM: A Compilation
Framework for Lifelong Program Analysis & Transfor-
mation. In International Symposium on Code Genera-
tion and Optimization (CGO), pages 75–86, 2004.
[24] Siliang Li and Gang Tan. Finding Reference-counting
Errors in Python/C Programs with Afﬁne Analysis.
In Proceedings of European Conference on Object-
Oriented Programming (ECOOP), pages 80–104, 2014.
[14] Yueqi Chen and Xinyu Xing. SLAKE: Facilitating
Slab Manipulation for Exploiting Vulnerabilities in the
Linux Kernel. In Proceedings of the 26th ACM SIGSAC
Conference on Computer and Communications Security
(CCS), page 1707–1722, 2019.
[25] Kangjie Lu and Hong Hu. Where Does It Go?: Reﬁn-
ing Indirect-Call Targets with Multi-Layer Type Anal-
ysis. In Proceedings of the 26th ACM Conference on
Computer and Communications Security (CCS), pages
1867–1881, 11 2019.
USENIX Association
30th USENIX Security Symposium    2485
[26] Kangjie Lu, Aditya Pakki, and Qiushi Wu. Detecting
Missing-Check Bugs via Semantic- and Context-Aware
In Proceed-
Criticalness and Constraints Inferences.
ings of the 28th USENIX Security Symposium (USENIX
Security), 2019.
[27] Kangjie Lu, Chengyu Song, Taesoo Kim, and Wenke
Lee. UniSan: Proactive Kernel Memory Initialization
to Eliminate Data Leakages. In Proceedings of the 23th
ACM SIGSAC Conference on Computer and Communi-
cations Security (CCS), page 920–932, 2016.
[28] Aravind Machiry, Chad Spensky, Jake Corina, Nick
Stephens, Christopher Kruegel, and Giovanni Vigna.
Dr.Checker: A Soundy Analysis for Linux Kernel
Drivers. In Proceedings of 26th USENIX Security Sym-
posium (USENIX Security), pages 1007–1024, Vancou-
ver, BC, August 2017.
[29] Junjie Mao, Yu Chen, Qixue Xiao, and Yuanchun Shi.
Rid: Finding Reference Count Bugs with Inconsistent
In Proceedings of the 21st In-
Path Pair Checking.
ternational Conference on Architectural Support for
Programming Languages and Operating Systems (ASP-
LOS), pages 531–544, 2016.
[30] Paul E. McKenney. Overview of linux-kernel reference
counting. http://www.open-std.org/jtc1/sc22/
wg21/docs/papers/2007/n2167.pdf/.
[31] Changwoo Min, Sanidhya Kashyap, Byoungyoung Lee,
Chengyu Song, and Taesoo Kim. Cross-Checking Se-
mantic Correctness: The Case of Finding File System
Bugs. In Proceedings of the 25th Symposium on Oper-
ating Systems Principles (SOSP), page 361–377, 2015.
[32] Yoann Padioleau, Julia Lawall, René Rydhof Hansen,
and Gilles Muller. Documenting and Automating Collat-
eral Evolutions in Linux Device Drivers. In Proceedings
of the 3rd ACM SIGOPS/European Conference on Com-
puter Systems (EuroSys), page 247–260, 2008.
[33] Sebastian Poeplau and Aurélien Francillon. Symbolic
Execution with SymCC: Don’t Interpret, Compile! In
Proceedings of the 29th USENIX Security Symposium
(USENIX Security), pages 181–198, 2020.
[34] David A. Ramos and Dawson Engler.
Under-
Constrained Symbolic Execution: Correctness Check-
ing for Real Code. In Proceedings of the 24th USENIX
Security Symposium (USENIX Security), pages 49–64,
Washington, D.C., 2015.
[35] Elena Reshetova. Conversion from atomic_t to ref-
count_t: summary of issues. https://www.openwall.
com/lists/kernel-hardening/2016/11/28/4.
[36] Elena Reshetova, Hans Liljestrand, Andrew Paverd,
and N Asokan. Toward Linux kernel memory safety.
Software: Practice and Experience, 48(12):2237–2256,
2018.
[37] Jangseop Shin, Donghyun Kwon, Jiwon Seo, Yeongpil
Cho, and Yunheung Paek. CRCount: Pointer Invali-
dation with Reference Counting to Mitigate Use-after-
free in Legacy C/C++. In Proceedings of 26th Annual
Network and Distributed System Security Symposium
(NDSS). The Internet Society, 2019.
[38] Sooel Son, Kathryn S. McKinley, and Vitaly Shmatikov.
Rolecast: Finding Missing Security Checks When You
Do Not Know What Checks Are. In Proceedings of
the 2011 ACM International Conference on Object Ori-
ented Programming Systems Languages and Applica-
tions (OOPSLA), page 1069–1084, 2011.
[39] Xi Wang, Haogang Chen, Zhihao Jia, Nickolai Zel-
dovich, and M. Frans Kaashoek.
Improving Integer
Security for Systems with KINT. In Presented as part
of the 10th USENIX Symposium on Operating Systems
Design and Implementation (OSDI), pages 163–177,
Hollywood, CA, 2012.
[40] Wei Wu, Yueqi Chen, Jun Xu, Xinyu Xing, Xiaorui
Gong, and Wei Zou. FUZE: Towards Facilitating Ex-
ploit Generation for Kernel Use-After-Free Vulnerabili-
ties. In Proceedings of the 27th USENIX Security Sym-
posium (USENIX Security), pages 781–797, Baltimore,
MD, August 2018.
[41] Fabian Yamaguchi, Alwin Maier, Hugo Gascon, and
Konrad Rieck. Automatic Inference of Search Patterns
for Taint-Style Vulnerabilities. In Proceedings of the
36th IEEE Symposium on Security and Privacy (S&P),
page 797–812, USA, 2015. IEEE Computer Society.
[42] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and
Taesoo Kim. QSYM: A Practical Concolic Execution
Engine Tailored for Hybrid Fuzzing. In Proceedings of
the 27th USENIX Conference on Security Symposium
(USENIX Security), 2018.
[43] Insu Yun, Changwoo Min, Xujie Si, Yeongjin Jang, Tae-
soo Kim, and Mayur Naik. APISan: Sanitizing API
Usages through Semantic Cross Checking. In Proceed-
ings of the 25th USENIX Security Symposium (USENIX
Security), pages 363–378, Austin, TX, August 2016.
USENIX Association.
A Bug Results
B Known Bugs to Compare RID with CID
2486    30th USENIX Security Symposium
USENIX Association
Buggy Function
tipc_crypto_rcv
prq_event_thread
ip6_route_info_create
aa_change_proﬁle (#Line: 1328)
tcp_bpf_recvmsg
tls_data_ready
bpf_exec_tx_verdict
ttm_bo_add_move_fence
ttm_bo_vm_fault_reserved
aa_change_proﬁle (#Line: 1318)
comedi_open
igt_ppgtt_pin_update
policy_update
btrfs_recover_relocation
nfs3_set_acl
Table 8: List of new refcount bugs detected by CID. We manually conﬁrmed the security impact of each bug in column 6, where
“ML” represents memory leak. We also investigate the latent period of the detected bugs (in column 7). In column 5, “I-D” and
“D-D” represent the INC-DEC consistency checking and DEC-DEC consistency checking respectively.
ID File
1
2
3
4
5