level, called restriction-based prediction, exploits the abundance of
self-loops, for guessing responses to membership queries with high
accuracy. The second level, called probability-based prediction,
exploits the fact that the same input messages often leads to the
same output message. Any possible prediction errors are detected
using random sampling (Section 3.1). If an error was made predict-
ing the responses to membership queries, our algorithm backtracks
to the ﬁrst erroneously predicted membership query, ﬁxes the error
(according to responses from sampling queries), and continues run-
ning L∗. Importantly, the same sampling queries can be used both
to detect missing states (as in the classical Angluin probabilistic
sampling [3]) and mispredictions.
We begin the formal presentation of our prediction techniques by
showing that entries in the S set have no self-loops, and therefore
can be used for prediction of responses that have self-loops.
432THEOREM 1. Let s ∈ S, s = c0 · c1 · · · cn be a string of n charac-
ters from ΣI. Let q0, q1, · · · , qn, qn+1 be a sequence of states visited
by δ∗ (q0, s). For 0 ≤ i < n + 1, every two adjacent states are dif-
ferent, i.e., qi 6= qi+1.
PROOF. Proof is by induction on the string length. The ε string
trivially satisﬁes the condition, as there is only one state in the se-
quence of visited states. Let s = c0 · · · ck and s ∈ S. Algorithm 1
on Line 5 appends a ∈ ΣI to s, and then in the loop that follows
computes responses to membership queries s · a · u, where u ∈ E are
the columns of T . Without loss of generality, let s · a be the small-
est string, according to our lexicographic ordering (Deﬁnition 5).
String s · a is moved to S (Line 3) only if ∀t ∈ S . ∃ u ∈ E . T (t, u) 6=
T (s · a, u). Every s · a string is obtained by extending strings from
S, so we know that s ∈ S. Thus, we conclude: ∃ u ∈ E . T (s, u) 6=
T (s · a, u), which implies that δ∗ (q0, s · u) 6= δ∗ (q0, s · a · u), be-
cause s and s · a are (eventually) both in S and they denote dif-
ferent states. Since s · a · u and s · u have the same preﬁx and suf-
ﬁx, symbol a must explain the difference in the response of the
state-machine. By induction hypothesis ∀ 0 ≤ i < k . ci 6= ci+1. So
we have: δ∗ (q0, s · a) = c0 · · · ck · ck+1. Assume ck = ck+1. Thus,
δ∗ (q0, s · a) = δ∗ (q0, s), a contradiction. So, we have proved that
in δ∗ (q0, s · a), the last two visited states are different, which proves
the theorem.
COROLLARY 1. From Deﬁnition 6, it follows that δ∗ (q0, s) for
s ∈ S has no self-loop transitions.
Intuitively, Theorem 1 suggests that strings from S, which are
loop-free, could be used to predict responses to input strings that
are similar to strings from S, but have additional symbols producing
self-loop transitions sprinkled around. We formalize that intuition
using the following two deﬁnitions.
DEFINITION 7
(DIFFERENTIATING SET). Let D ⊆ ΣI be a set
of all symbols in S, more precisely, D = {c | c ∈ [s] , s ∈ S}. As
S grows during the execution of Algorithm 1, D is going to be a
monotonically increasing set.
DEFINITION 8
I , and D ⊆ ΣI . The restriction function ρ : Σ∗
Σ∗
deﬁned recursively as follows:
(RESTRICTION FUNCTION). Let a ∈ ΣI , s ∈
I is then
I × D −→ Σ∗
ρ(s, D) = 
ε if s = ε
ρ(r, D) if s = a · r ∧ r ∈ Σ∗
a · ρ(r, D) if s = a · r ∧ r ∈ Σ∗
I ∧ a 6∈ D
I ∧ a ∈ D
Intuitively, the restriction function just deletes the symbols that
are not in a given set from a string. For example, ρ(a · b · b · a · c ·
d, {b, d}) = b · b · d.
Now, our restriction-based prediction rule can be simply stated
as: Given any membership query s · a · u, compute s′ = ρ(s · a, D),
and if s′ already exists in S ∪ S · ΣI, use the values in the s′ row of
table T to predict the values for the s · a · u row. More formally:
T (s · a, u) = T (ρ(s · a, D) , u), if the ρ(s · a, D) entry exists in T .
With this simple rule, we get highly accurate prediction, with few
errors.
The restriction-based prediction saves around 73% of member-
ship queries in our experiments with MegaD. Analyzing the results,
we identiﬁed one missed prediction opportunity. If the restricted in-
put string does not exist in the table, the previously presented tech-
nique is helpless. To improve the performance of the restriction-
based prediction even further, we track the set of observed response
messages for every input symbol. When the restriction-based ap-
proach fails, we apply a simple probability-based prediction: If a
particular input message produces the same output message for all
previous queries, we predict that response will be the same. If mul-
tiple different responses were observed for the same input, we do
not predict it. It would certainly be possible to lower the prediction
threshold — say, by picking the response that happens in at least
90% of cases — at the cost of increasing the number of erroneous
predictions and the cost of backtracking. We leave this ﬁne-tuning
for future work. Even with the simple probability-based prediction
currently implemented, we gain an additional 13% reduction in the
number of membership queries on MegaD, in addition to savings
achieved by the restriction-based prediction.
Mispredictions can produce erroneous state-machine conjectures.
However, we exploit the same random sampling equivalence check-
ing mechanism in L∗ (Section 3.1) to detect mispredictions. Thus,
mispredictions are guaranteed to be found with desired accuracy
ε and conﬁdence γ. Once an error is detected, L∗ backtracks to
the ﬁrst erroneously predicted query, ﬁxes it using the sampling
query response, removes all subsequently predicted entries from
the observation table, and continues the inference process. All the
prediction savings, both in the prior discussion and in the experi-
mental evaluation, take the cost of backtracking into account. So,
it is obvious that our prediction is very effective (86% total reduc-
tion in the number of queries) and accurate (inaccurate prediction
would require more frequent backtracking, reducing the savings).
4.4 Determinism, Resettability, and Sampling
This section describes the non-standard and non-obvious aspects
of using L∗ in our setting. More precisely, we discuss the impact
of the determinism and resettability assumptions (Section 2.3) and
the role of the sampling process in achieving the desired accuracy
of the model.
Both the determinism and resettability assumptions were rela-
tively easy to satisfy in our setting.
In our experiments, the ex-
change of messages was deterministic, except for one corner case:
Sometimes master servers respond with an arbitrarily long sequence
of INFO messages, which are always terminated with a non-INFO
message. Our inference infrastructure discards all the INFO mes-
sages, and treats the ﬁrst non-INFO message as the response. This
was the only source of non-determinism we encountered. To re-
set the state-machine, we begin both membership and sampling
queries with an INIT message (c.f. Table 1), which initiates a new
session. Once the session is started, every input message produces
a response — an output message.
As discussed in Section 3.1, we use a sampling-based approach
for equivalence queries. We generate uniformly distributed random
sequences of input messages, the number of which is determined
by the desired model accuracy and conﬁdence [3]. Once our im-
plementation of L∗ closes the table, it conjectures a state-machine,
which is then tested through sampling. The responses to sampling
queries are never predicted, for the purpose of sampling queries is
to discover new states that do not exist in the currently conjectured
model and to discover prediction errors.
5. ANALYSIS OF INFERRED MODELS
In this section, we analyze the complete protocol models ob-
tained from our inference technique with the goal of gaining deeper
understanding of MegaD. We present techniques to analyze the
protocol models to identify the critical links in botnet C&Cs, de-
sign ﬂaws, the existence of background communication channels
between C&C servers, and to identify implementation differences
for ﬁngerprinting and ﬂaw detection.
5.1 Identifying the Critical Links
Transitions in our Mealy machine models represent actions. Cer-
tain actions might be considered as bad, in the sense that they rep-
433resent a malicious or undesirable activity. When Mealy machines
are used, such activities are represented with transitions (more pre-
cisely, output responses).8 Once the bad transitions are identiﬁed,
we wish to ﬁnd a way to prevent such transitions from ever being
executed.
More formally, given a protocol state-machine M = (Q, ΣI , ΣO,δ,
λ, q0) and a set of bad output symbols B ⊆ ΣO representing bad ac-
tions, we wish to identify the minimal number of transitions we
have to disrupt to prevent the bots from executing transitions that
would produce output symbols from B. There are two ways (not
mutually exclusive) of achieving this. The ﬁrst option is to make it
impossible for bots to reach the states from which bad actions could
be performed by cutting a set of transitions in the state-machine,
I , a ∈ ΣI . λ (δ∗ (q0, s) , a) 6∈ B.
i.e., we wish to assure that ∀ s ∈ Σ∗
The second option is to disrupt the bad transitions themselves, i.e.,
to remove the transitions so as to assure that the following property
holds: ∀ s ∈ Σ∗
I . [λ∗ (q0, s)] ∩ B = /0.
Such an analysis can be done using max-ﬂow min-cut algorithms
[11], such that the initial state is a source, and the state at which
the bad transition originates is a sink. We performed this analysis
on the MegaD state-machine and arrived at a trivial conclusion for
a single pool of bots: since MegaD is a spamming botnet and a
single spamming edge is the only bad edge, taking down any one
of the botnet servers and the corresponding transitions in the state-
machine would prevent a pool of bots from spamming. However,
since different pools of bots talk to different sets of servers, it does
not stop other pools of MegaD bots from spamming. Unsatisﬁed
with this outcome, we attempt to develop an approach that works
across multiple pools of bots.
We extended the encoding of messages into alphabet symbols
shown in Table 1 by partitioning the set of messages into disjoint
sets, one set per server, so as to include the IP addresses of the
servers as an additional ﬁeld. We shall refer to this extended alpha-
bet as IP-extended. We ran our inference technique independently
on both master servers we have access to (each pool of bots talks
to a different master server), and computed a projection (deﬁned
below) of one state-machine onto the IP-extended alphabet of the
other.
DEFINITION 9
(STATE-MACHINE PROJECTION). The projec-
tion of a ﬁnite state-machine M = (Q, ΣI , ΣO,δ,λ, q0) onto alpha-
bet ΣA is deﬁned as a non-deterministic ﬁnite state-machine M′ =
(Q, ΣI ∩ ΣA, ΣO,δ′,λ′, q0), such that the following holds for ∀ a ∈
ΣI , x ∈ ΣO, qi, q j ∈ Q:
(qi,ε, q j) ∈ δ′
(qi, a, q j) ∈ δ′
(qi,ε,ε) ∈ λ′
(qi, a, x) ∈ λ′
iff
iff
iff
iff
(qi, a, q j) ∈ δ ∧ a 6∈ ΣA
(qi, a, q j) ∈ δ ∧ a ∈ ΣA
(qi, a, x) ∈ λ ∧ a 6∈ ΣA
(qi, a, x) ∈ λ ∧ a ∈ ΣA
Intuitively, all transitions of M on alphabet symbols not in ΣA
are replaced with non-deterministic transitions (ε), and the corre-
sponding outputs are replaced with empty outputs (ε). The result-
ing state-machine may be non-deterministic.
Computing a projection of a state-machine inferred from com-
munication of our bot emulator with one master server onto the al-
phabet of the machine inferred from communication with another
master server, we identiﬁed the key components shared among mul-
tiple pools of bots. The results are presented in Section 6.2.
8The conversion of Mealy to Moore machines introduces addi-
tional states, usually one extra state per transition. Hence the
two concepts, bad transitions in Mealy machines and bad states in
Moore machines are, as a matter of fact, equivalent concepts. Thus,
talking about bad transitions, as opposed to bad states, makes more
sense in our setting.
5.2 Identifying Design Flaws
We identiﬁed a design ﬂaw in the MegaD protocol, thanks to the
fact that our inference approach infers complete state-machines.
Given a complete state-machine and a speciﬁcation (i.e., a set of
properties expressed in a suitable formal logic), it is possible to au-
tomatically determine whether the properties hold using automatic
model checkers (e.g., [9]).
In our case, the state-machines were
simple enough that we could manually check a number of inter-
esting properties. We explain the ﬂaw we found later in Section
6.3.
5.3 Identifying Background-Channels
In situations when a client (a bot, in our case) talks to multiple
servers, it might be interesting to prove whether there exists any
background communication between the servers. Such background
communication channels can indicate inﬁltration traps, which se-
curity researchers need to be aware of before attempting to bring
a botnet down, or simply reveal interesting information about the
protocol.
To detect the background-channels, we devised the following
analysis: We restrict our bot emulator to communicate only with
a single server at the time, and infer the protocol model MT (for
the template server), MS (for the SMTP server), and MM (for the
master server). Then, we allow our bot emulator to communicate
with all the servers and compute the model M. We compute the
projection (Deﬁnition 9) of M onto input alphabets used for build-
ing individual server communication models (MT , MS, and MM),
and compare the obtained projection with the model of communi-
cation with the individual servers. Any differences imply that there
exist background communication channels. We prove existence of
communication between MegaD’s servers in Section 6.4.
5.4 Identifying Implementation Differences
Once the complete models of two different implementations of
the same protocol are computed, comparison of the models can re-
veal interesting deviations useful for ﬁngerprinting and ﬂaw detec-
tion. While it is possible to perform automatic equivalence check-
ing of large ﬁnite-state models (e.g., [24]), our models were simple
enough that we can do such an analysis manually. We discuss the
differences between Postﬁx SMTP 2.5.5 and MegaD’s implemen-
tation in Section 6.5.
6. EXPERIMENTAL EVALUATION
We implemented our version of L∗ in ∼ 1.7 KLOC of C++ and
the bot emulator and experimental infrastructure in ∼ 2.3 KLOC of
Python and Bash scripts. Our prototype performs up to eight par-
allel queries (as shown in Figure 3) concurrently tunneled through
Tor [15]. We conducted the experiments over a period of three
weeks starting March 27th, 2010. Figure 5 illustrates the inferred
MegaD protocol state-machine.
In the rest of this section, we evaluate our protocol inference
approach on the MegaD botnet C&C distributed system, MegaD’s
non-standard implementation of SMTP, and the standard SMTP as
implemented in Postﬁx 2.5.5. We present the results of our analysis
of inferred complete models, and validate our inference approach
by comparing the inferred SMTP models against the SMTP stan-
dard.
6.1 Performance and Accuracy
In this section, we present the experimental evidence of the ef-
fectiveness of our response prediction technique and discuss the
model accuracy.
4340
1 / 6
2
3
1 / 7
1 / 5
9 / -
7 / -
8 / -
6
1 2 / 1 1
1
1 2 / 1 1
1 / 6
4
1 2 / 1 1
1 2 / 1 1
1 2 / 1 1
1 / 7
5
1 / 5
7
8 / -
7 / - 9 / -
9 / -
8 / -
8
7 / -
8 / -
9 / -
7 / - 9 / -
8 / -
7 / -
9 / -
8 / -
7 / - 9 / -
8 / -
9 / -
8 / -
7 / -
9
7 / -
1 / 5
1 0
1 / 7
1 / 9
1 2
1 4
1 / 6
1 6
8 / -
8 / -
1 2 / 1 1
1 1
1 / 5
1 / 9
1 / 7
1 3
  1 / 1 0     1 2 / 8     1 1 / -     1 5 / 1 3  
1 / 1 0
1 2 / 1 1
1 2 / 1 1
1 5
1 / 6
1 2 / 1 1
1 7
Figure 5: Protocol State-Machine of MegaD’s distributed Command and Control system. Self-transition edges are removed for
clarity. The state-machine transitions are labeled according to the alphabet in Table 1. For example, 15/13 denotes NOTIFY /
NOTIFY_RECVED. The process of spamming is triggered in state 13, through self-edges 1/10, 12/8, 11/-, 15/13.
The prediction results are shown in Table 2. The overall reduc-
tion in the number of queries that have to be sent over the network
is between 24.5% (for MegaD’s SMTP) and 86.1% (for MegaD’s
C&C). We believe there are two main reasons our prediction is
much more effective on the MegaD C&C than on SMTP: First,
C&C is a more complex protocol that involves three different types
of servers, two of which use proprietary protocols. Second, our
understanding of the two protocols when we were designing mes-
sage abstractions was very different — we knew nothing about the
C&C state-machine, while the SMTP state-machine is well known
[23]. We believe this inherent lack of knowledge about an unknown
protocol model, yet to be inferred, results in some amount of redun-
dancy. However, it is important to be conservative when abstracting
messages, as otherwise it is easy to miss important states and tran-
sitions. This inherent tradeoff between accuracy and redundancy
makes our prediction technique even more valuable, as we can in-
fer larger protocols, without sacriﬁcing accuracy. As a matter of
fact, since sending and receiving a single message through Tor took
around 6.8 seconds on average, 86.1% prediction accuracy means
that our response predictor saved (56,716−6,406)×6.8
= 3.95 days of
computation, reducing the total amount of time required to infer the
MegaD C&C to around 12 hours.
3600×24
Parallelization of the experiment improved the performance even
further. While a single bot emulator would return a response mes-
sage every 6.8 seconds, on average, eight parallel bots would return
a message every 1.4 seconds, a 4.85X improvement on average in
addition to improvements obtained by response prediction. The ex-