### Fast Verified Post-Quantum Software
**Daniel J. Bernstein**

#### SymCrypt: Failures for Rare Inputs
A critical bug was discovered in SymCrypt, the core cryptographic library responsible for implementing asymmetric and symmetric crypto algorithms in Windows 10 and 8, respectively. This issue highlights the vulnerabilities that can arise even with careful development practices.
—“Warning: Google Researcher Drops Windows 10 Zero-Day Security Bomb”, Forbes, [https://tinyurl.com/y69fx3nh](https://tinyurl.com/y69fx3nh)

#### Falcon Software: Skewed Randomness
The Falcon software produced valid signatures but leaked information about the private key. The existence of such bugs underscores the limitations of traditional development methodologies, which often rely on being "super careful" rather than employing robust verification techniques.
—“OFFICIAL COMMENT” within NISTPQC (NIST Post-Quantum Cryptography Standardization Project), [https://tinyurl.com/y5w46bde](https://tinyurl.com/y5w46bde)

#### Minerva: Timing Attack
Libgcrypt, wolfSSL, and Crypto++ have released patches to address a timing attack vulnerability. However, MatrixSSL and Oracle’s SunEC library remain vulnerable.
—“Minerva attack can recover private keys from smart cards, cryptographic libraries”, ZDNet, [https://tinyurl.com/y6rlkov4](https://tinyurl.com/y6rlkov4)

#### Cryptographic Software Vulnerabilities
A 2021 study by Blessing–Specter–Weitzner identified 73 actual cryptographic vulnerabilities, including 11 severe ones, in popular cryptographic libraries such as OpenSSL, GnuTLS, Mozilla TLS, WolfSSL, Botan, Libgcrypt, LibreSSL, and BoringSSL, post-2010 CVEs.

#### Increasing Complexity
The demands for post-quantum cryptography are becoming more stringent:
- **Post-Quantum**: Must be resistant to quantum attacks.
- **Performance**: Must be fast.
- **Security**: Must prevent timing attacks.

The ecosystem of post-quantum specifications and software is becoming increasingly complex.

#### Examples of Complications
The official Keccak (SHA-3) code package includes multiple versions optimized for different architectures:
- `KeccakP-1600-reference.c`
- `KeccakP-1600-x86-64-shld-gas.s`
- `KeccakP-1600-AVX2.s`
- `KeccakP-1600-AVX512.s`
- `KeccakP-1600-times8-SIMD512.c`

These optimized versions provide significantly better performance compared to the reference implementation and "optimizing" compilers.

Each NISTPQC candidate includes hand-optimized software that outperforms state-of-the-art compiled code.

#### Symbolic Testing: A Solution
Symbolic-testing tools ensure that optimized software produces the same outputs as the reference software for all inputs. These tools are user-friendly and can efficiently handle many post-quantum subroutines.

**New Tool: saferewrite**
- **Description**: A new symbolic-testing tool.
- **Availability**: Open source from [https://pqsrc.cr.yp.to](https://pqsrc.cr.yp.to).
- **Underlying Tools**: valgrind, VEX library, Z3 theorem prover, angr.io binary-analysis/symbolic-execution toolkit.

#### Case Study: int16[64] Comparison
- **Subroutine**: Used in the Frodo post-quantum KEM.
- **Reference Implementation**:
  ```c
  #include <stdint.h>
  int cmp_64xint16(const uint16_t *x, const uint16_t *y) {
      for (int i = 0; i < 64; i++) {
          if (x[i] != y[i]) return -1;
      }
      return 0;
  }
  ```

- **Optimized Version**:
  ```c
  #include <string.h>
  int cmp_64xint16(const uint16_t *x, const uint16_t *y) {
      return memcmp(x, y, 128);
  }
  ```
  - **Analysis**: Unsafe due to variable time and non-standard output values.

- **Corrected Version**:
  ```c
  #include <stdint.h>
  int cmp_64xint16(const uint16_t *x, const uint16_t *y) {
      uint32_t differences = 0;
      for (long long i = 0; i < 64; i++) {
          differences |= x[i] ^ y[i];
      }
      return (differences >> 16) - 1;
  }
  ```
  - **Analysis**: Confirmed to be safe and equivalent to the reference implementation.

#### Examples in the saferewrite Package
- **cmp_64xint16 Implementations**: 10 sample implementations, including one using OpenSSL’s CRYPTO_memcmp.
- **Other Functions**: 103 sample implementations of 39 other functions, ranging from simple to complex.
- **Automatic Input Generation**: unsafe-differentfrom automatically provides inputs that trigger differences, which can be challenging to find through traditional testing.

#### Example: Integer-Sequence Encoders
- **Optimized Code**: From NTRU Prime, using Intel AVX2 vector instructions.
  - **File**: `encode_761x1531/avx/encode.c` (245 lines)
  - **Generation**: Automatically generated by a Python script (239 lines).

- **Reference Code**:
  - **Files**: `encode_761x1531/ref/Encode.c` (38 lines), `encode_761x1531/ref/wrapper.c` (18 lines)
  - **Analysis**: Confirmed to be a safe rewrite of the reference code.

#### Excerpt from avx/encode.c
```c
x = _mm256_loadu_si256((__m256i *) reading);
x = _mm256_add_epi16(x, _mm256_set1_epi16(2295));
x &= _mm256_set1_epi16(16383);
x = _mm256_mulhi_epi16(x, _mm256_set1_epi16(21846));
y = x & _mm256_set1_epi32(65535);
x = _mm256_srli_epi32(x, 16);
x = _mm256_mullo_epi32(x, _mm256_set1_epi32(1531));
x = _mm256_add_epi32(y, x);
x = _mm256_shuffle_epi8(x, _mm256_set_epi8(
    12, 8, 4, 0, 12, 8, 4, 0, 14, 13, 10, 9, 6, 5, 2, 1,
    12, 8, 4, 0, 12, 8, 4, 0, 14, 13, 10, 9, 6, 5, 2, 1
));
x = _mm256_permute4x64_epi64(x, 0xd8);
_mm_storeu_si128((__m128i *) writing, _mm256_extractf128_si256(x, 0));
*((uint32 *) (out + 0)) = _mm256_extract_epi32(x, 4);
*((uint32 *) (out + 4)) = _mm256_extract_epi32(x, 6);
```

#### Links and Future Work
- **saferewrite Package**: Available at [https://pqsrc.cr.yp.to](https://pqsrc.cr.yp.to).
- **Future Enhancements**:
  - More post-quantum and pre-quantum case studies.
  - Support for additional languages (e.g., Python).
  - Developer integration for incremental testing.
  - Subroutine swaps for faster testing.
  - Plugins for dedicated equivalence testers.
  - Higher assurance for the entire toolchain.
- **Related Work**: Cryptol/SAW/hacrypto, Cryptoline, Fiat-Crypto, HACL*, Jasmin, ValeCrypt, VST.