is used to evaluate each incoming web request and outgoing
web response and detect any violations.
Due to the stateless nature of HTTP protocol, session vari-
ables are explicitly deﬁned in web applications to maintain
the state of a web session. There are two ways for maintain-
ing session states: 1) client side only, where session states
are directly carried in cookies, hidden forms, or URLs; 2)
collaboration of the client and the server, where the server
stores the session states and issues a session ID to the client
for indexing its session states. In either case, session states
can be retrieved at runtime for each web request indepen-
dent of the web application implementation. For example,
when session states are carried in cookies, hidden forms, or
rewritten URLs, they can be directly retrieved from the web
requests. When session states are kept in the server side,
they can be found either in a ﬁle or a database table.
In
the case of PHP, the session state is by default stored in
temporary ﬁles located at /var/lib/php5, which is indexed
by session ID within web requests, while in the case of JSP,
the session state is persisted in database tables.
One straightforward approach to modeling the application
behavior is to derive its states from the session variables and
their values directly. Yet, this approach has several issues:
(cid:1)(cid:2)(cid:3)
1) at one application state, session variables may exhibit a
large range of values. For example, $ SESSION[‘username’]
can assume as many possible values as the number of regis-
tered users in the same application state. Thus, directly us-
ing session variable values to diﬀerentiate application states
may result in a large number of spurious states; 2) deﬁni-
tion of session variables may be missing from the application
implementation. As a result, two application states in the
speciﬁcation can not be diﬀerentiated by the collection of
all session variables. For example, in the application shown
in Fig. 1, there is no session variable deﬁned for indicating
whether the admin user identity has been logged.
Our approach follows the stateless property of HTTP and
regards the session variables as part of the input to the web
application along with web requests. Similarly, the output of
the application consists of the web response and the session
variables. In this way, the web application can be regarded
as a stateless system, as shown in Fig. 2. Under this state-
less system model, we characterize the application behavior
in the form of three types of likely invariants. 1) Type I input
invariants: recall that the web application input consists of
the web request and the values of the session variables when
the request is made. This type of invariants models the re-
lationship between the web requests and the session variable
values. Essentially, it tries to capture the constraints on the
web requests at certain session states. By identifying the in-
variant component of session variables, this approach avoids
the introduction of spurious states by unnecessary session
variables. 2) Type II input/output invariants: this type of
invariants models the relationship between the web request
and response as well as the changes in the session variables
after the web request is processed. Essentially, it tries to
capture the constraints on the application state transition
and the input/output dependency at a certain state. Both
type I and II invariants rely on the session variables to in-
fer the application states. When the session variables are
not suﬃciently deﬁned, we need a third type of invariant.
3) Type III input/output sequence invariants: this type of
invariants models the relationship between consecutive web
request/response pairs. Essentially, it tries to capture the
application states that are not revealed by deﬁned session
variables by leveraging the historical request/response in-
formation. In the following sections, we ﬁrst formalize our
system model and then illustrate how to extract three types
of invariants and apply them into runtime detection.
3.1 System Model
As shown in Fig.2, a web application is regarded as a state-
less system F , which accepts an input min and emits an out-
put mout, expressed as F (min) = mout. An input min con-
sists of a web request and a set of session variable name/value
pair S(min). To facilitate detection, we further decompose a
web request into two components: a web request key r(min),
which includes the HTTP request method and the target ﬁle,
and a set of input parameter name/value pair P (min). In
this paper, we only consider GET and POST methods and
focus on PHP pages. For example, the web request keys
include GET-login.php, POST-login.php, in the application
shown in Fig. 1. Similarly, an output consists of a web re-
sponse and a set of session variable name/value pair S(mout).
A web response is a synthesized web page, which is usually
generated by ﬁlling dynamic contents into static web page
structure (i.e., template). To deal with the inﬁnite number
of possible web responses, we decompose a web page into a
web template, the number of which is ﬁnite, with a set of
dynamic contents, which become output parameters. If we
assign a unique ID to each static template, a web response
can be symbolized as a web template ID (i.e., web response
key v(mout)) and a set of output parameter name/value pair
Q(min). In the next section, we illustrate how to symbol-
ize a web page into a web template with a set of output
parameters.
POST  http://example.com/login.php username=testuser&passwd=xx
r (request key)                  P (input parameter)              
min
$_SESSION[‘privilege’]=null&$_SESSION[‘username’]=null
S (session variable)   
Template: t.index_user
/html/body: user info for testuser
Web 
Application
F
v (response key)                  Q (output parameter)              
$_SESSION[‘privilege’]=“user”&$_SESSION[‘username’]=“testuser”
mout
S (session variable)   
Figure 2: A stateless view of web application
3.2 Web Page Symbolization
To symbolize a web page, we ﬁrst extract the web tem-
plates (O) from all the observed web pages (D). Then, given
a web page d ∈ D, we classify it into a most possible template
(v) and extract the set of output parameters (Q) accordingly.
Techniques for extraction of templates from web pages have
been presented in existing literatures [19, 13]. In this paper,
we leverage the method from TEXT [13], which expresses
the DOM tree structure of a web page as a set of essential
paths. Our template extraction procedure contains the fol-
lowing four steps. Step 1 and 2 are similar to TEXT and
step 3 and 4 are designed to fulﬁll the purpose of template
extraction in our context.
(1) Transformation: the DOM tree structure of a web page
d is ﬁrst transformed into a set of paths Pd. Here, we fo-
cus on the paths that lead to the leaf text nodes, which
carry the information sent back to the clients within web
pages. An index page from our example application can be
expressed as three paths: “/html/body/Welcome to the ap-
plication”, “/html/body/user information for: testuser.” and
“/html/body/a/logout”, as shown in Fig.3.
Web Page
/html/body/Welcome to the example application.
/html/body/user information for: testuser
/html/body/a/Logout
All paths
/html/body/Welcome to the example application.
/html/body/a/Logout
Template paths 
(t.index_user)
/html/body/  user information for:
Output parameter

testuser
Figure 3: An example of page symbolization
(2) Pruning: to extract templates from all the paths, those
paths that lead to dynamic contents should be pruned. To
do so, we deﬁne the support of a path as the number of pages
in D that contain the path. Since the occurrence of a path
(cid:2)(cid:3)(cid:1)
that belongs to a template is generally higher, paths with
low support are most likely dynamic contents and should be
pruned. For each page d, the minimum support threshold
td is deﬁned as the mode (i.e., the most frequent value) of
the occurrence of paths that are contained in the page. Note
that using one threshold for all the pages is inappropriate as
each template may generate diﬀerent number of pages. After
the paths with support lower than the threshold are pruned,
each page is expressed as a set of “essential” paths. We use
ep(d) to denote the number of essential paths contained in
the page d.
(3) Clustering:
two web pages are probably generated
from the same web template if they have similar set of es-
sential paths. The similarity (Dist) between two pages di dj
is deﬁned as follows:
(cid:16)
Dist(di, dj) =
cp(di, dj)
ep(di) × ep(dj)
(1)
where cp(di, dj) is the number of common essential paths
contained in di and dj. We then perform hierarchical ag-
glomerative clustering over all pages based on the above
similarity metric. Each resulting cluster corresponds to a
web template. The essential path set of a new template is
the intersection of path sets from the two templates that are
merged together.
(4) Parametrization: for each page in D, after eliminating
the essential paths contained in the template it belongs to,
the remaining paths in its path set belong to output param-
eters. The parameter is identiﬁed by the path leading to the
text node and its value is the content of the text node. We
extract those parameters that are observed in all the pages
that belong to the template as the set of output parameters
of the template. For each parameter, we put the common
parts (i.e., tokens) from all the observed values into the pa-
rameter name and only extract the variable part as its value.
For the example application, we obtain seven templates.
They are the login page (t.login form), logout page (t.logout),
wrong login page (t.wrong login), regular user information
page (t.index user ), admin user information page (t.index admin),
logging identity page (t.admin) and the title change page
(t.title form). As shown in Fig.3, the template t.index user
has a parameter “/html/body/user information for:”, which
displays the user’s information and its value is the current
user name.
Given a web page d, it is ﬁrst transformed into a set of
paths. Then, it is classiﬁed into the template v that has the
highest similarity with its path set (i.e., v = argmax(Dist(d, vi)),
vi ∈ O). The corresponding output parameters for the tem-
plate are ﬁnally extracted.
3.3
Invariant Extraction
We extract three types of invariants: (1) type I input in-
variants, indexed by the web request key r; (2) type II in-
put/output invariants, indexed by the key pair (r, v); (3)
type III input/output sequence invariants, also indexed by
the request key r. We also show some example invariants
extracted from the application in Fig.1.
3.3.1 Type I Invariant
The inputs with the same request key r are grouped to-
gether. We extract the following types of invariants for each
request key r.
(1) A set of session variables Sinv(r) that are always present.
(cid:2)(cid:3)(cid:1)
An example invariant of this type is Sinv(GET-index.php) =
{$ SESSION[‘username’], $ SESSION[‘privilege’]}.
(2) A set of input parameters Pinv(r) that are always
present. An example invariant of this type is Pinv(POST-
login.php) = {email, passwd}.
(3) For a speciﬁc session variable s ∈ Sinv(r), its value is
drawn from an enumeration set V (p, r).
drawn from an enumeration set V (s, r). For example, invari-
ants of this type include: V ($ SESSION[‘privilege’], GET-
admin.php) = {admin}, V ($ SESSION[‘privilege’], GET-
index.php) = {admin, user};
(4) For a speciﬁc input parameter p ∈ Pinv(r), its value is
(5) The value of an input parameter p ∈ Pinv(r) is always
equal to the value of a session variable s ∈ Sinv(r). For
the request key GET-index.php, the session variable $ SES-
SION[‘username’] is always equal to the input parameter
username.
3.3.2 Type II Invariant
The input/output pairs with the same key pair (r, v) are
grouped together. We ﬁrst extract the same set of invariants
as type I for the key pair. For example, an invariant drawn
for the key pair (GET-login.php, t.logout) is that V (logout,
(GET-login.php, t.logout) = {1} and the input parameter
logout is added into Pinv(GET-login.php, t.logout).
We also extract two new invariants for each key pair (r, v):
(1) The value of an output parameter is always equal to the
value of an input parameter and/or a session variable. This
invariant reﬂects the dataﬂow within the web application.
An invariant for the key pair (POST-login.php, t.index user )
is that the output parameter /html/body/ of the template
t.index user is always equal to the session variable $ SES-
SION[‘username’] and the input parameter username.
(2) The session state is unchanged. For example, the user’s
session state always stays the same by observing the key pair
(GET-login.php, t.login form), but evolves for the key pair
(POST-login.php, t.index user ).
3.3.3 Type III Invariant
For each request key r, we extract the following invariant:
(1) A set of input/output key pairs that always precede
the web request key in one session. An invariant of this
type is the key pair (GET-admin.php, t.admin) always pre-
cedes the request key GET-admin2.php and the key pair
(GET-admin2.php, t.title form) always occurs before POST-
admin2.php.
3.4 Detection
Each web request key r is associated with a set of invari-
ants, including both type I and type III invariants. Each
input/output key pair (r, v) is also associated with a set of
type II invariants. For detection, each invariant is trans-
formed into an evaluation function, which operates on an
input or an input/output pair. If the input or input/output
pair satisﬁes the invariant, the function returns true. Oth-
erwise, the function returns false. The runtime detection is
performed in two phases:
(1) validating the input min: the web request is accepted,
if and only if the request key has been observed and all the
invariants associated with it are satisﬁed. Otherwise, the
web request is dropped.
(2) validating the input/output pair (min, mout): the web
page is sent back to the user if and only if the corresponding
key pair has been observed and all the invariants associated
with it are satisﬁed. Otherwise, the web page is blocked.
All the attacks that exploit the example application can be
detected by our extracted invariants. (1) Each auth bypass
attack instance violates the invariants associated with three
request keys GET-admin.php, GET-admin2.php and POST-
admin2.php respectively and are detected at the ﬁrst phase.
For example, the ﬁrst attack instance violates the invariant
V ($ SESSION[‘privilege’], GET-admin.php) = {admin}. (2)
the parameter manipulation attack violates the invariant
associated with the request key GET-index.php where the
input parameter username is always equal to the session
variable $ SESSION[‘username’] and is detected in the ﬁrst
phase. It also violates the invariant of the key pair (GET-
index.php, t.index user ) that the output parameter “/html/
body/user information for:” is equal to both the input pa-
rameter username and $ SESSION[‘username’].
(3) the
workﬂow bypass attack violates the invariant associated with
the request key GET-admin2.php that the key pair (GET-
admin.php, t.admin) always precedes the request key and is
detected in the ﬁrst phase.
4.
IMPLEMENTATION
We implement the prototype of our detection system BLOCK
as a proxy that sits between the web application and the
client, as shown in Fig. 4. BLOCK is capable of intercept-
ing all the messages exchanged between the web application
and the client and taking snapshots of the user’s session in-
formation stored at the server side. To capture the web
requests and responses, we build BLOCK on top of Web-
Scarab [18], an open source web application testing tool,
which is deployed at the web server and conﬁgured as a re-
verse proxy. PHP web applications, which are our focus in
this paper, by default store the users’ session information in
temporary ﬁles at the directory /var/lib/php5. BLOCK is
able to locate the correct session ﬁles, indexed by the ses-
sion ID within the web request, and read the user’s session
information. BLOCK can be operated in two modes: train-
ing and detection. In the training mode, BLOCK collects
the observed web requests, responses and their associated
session information, analyzes those execution traces and ex-
tracts the set of relevant invariants. In the detection mode,
BLOCK monitors the interactions between the clients and
the web application, dynamically detects and blocks those
potential attacks that violate the extracted invariants. We
note that BLOCK can be easily extended to other platforms
other than PHP by just modifying the component that ac-
cesses the session information to handle a variety of pro-
gramming frameworks. For example, in the case of Tomcat
servlet, the component should be able to access database
tables via JDBC drivers, which store persistent session in-
formation. Our implementation is independent of the web
application (i.e., doesn’t require the source code for analysis
or instrumentation). Thus, it can scale up to protect a large
number of web applications.
4.1 Training Mode
The components of BLOCK in the training mode are shown
in Fig. 5. Whenever a web request or a web page is captured,
the message constructor takes a snapshot of the current ses-
sion state and composes the corresponding messages, which
is sent to the trace collector. After suﬁcient traces have been
collected, BLOCK will perform oﬄine learning. The trace
Client/
Simulator
P
r
o
x
y
Web Server