 的反汇编代码为例：
.text:00401050 ; =============== S U B R O U T I N E ===============================  
.text:00401050  
.text:00401050 ➏; void bar(int j, int k);  
.text:00401050 ; Attributes: bp-based frame  
.text:00401050  
.text:00401050 ➐bar       proc near               ; CODE XREF: demo_stackframe+2A‚p  
.text:00401050 
.text:00401050 arg_0     = dword ptr  8  
.text:00401050 arg_4     = dword ptr  0Ch  
.text:00401050  
.text:00401050 push ebp  
.text:00401051 mov ebp, esp  
.text:00401053 sub esp, 8  
.text:00401056 ➎The next three lines test j
.text:00401056 mov eax, [ebp+arg_0]  
.text:00401059 cmp eax, [ebp+arg_4] 
.text:0040105C jge short loc_40106C ➌; Repeating comments get echoed at referencing locations  
.text:0040105E mov [esp], offset aTheSecondParam  ➍; "The second parameter is larger"  
.text:00401065 call printf  
.text:0040106A jmp short locret_40108E  ➊; jump to the end of the function  
.text:0040106C ;   ---------------------------------------------------------------------------    
.text:0040106C  
.text:0040106C loc_40106C:                             ; CODE XREF: bar+C•j  
.text:0040106C mov eax, [ebp+arg_0] ➋; Repeating comments get echoed at referencing locations  
.text:0040106F cmp eax, [ebp+arg_4]  
.text:00401072 jle short loc_401082  
.text:00401074 mov [esp], offset aTheFirstParame  ❹; "The first parameter is larger"  
.text:0040107B call printf  
.text:00401080 jmp short locret_40108E  
.text:00401082 ;   ---------------------------------------------------------------------------  
.text:00401082  
.text:00401082 loc_401082:                             ; CODE XREF: bar+22•j  
.text:00401082 mov [esp], offset aTheParametersA  ❹; "the parameters are equal"  
.text:00401089 call printf  
.text:0040108E    
.text:0040108E locret_40108E:                          ; CODE XREF: bar+1A•j  
.text:0040108E                                         ; bar+30•j  
.text:0040108E leave  
.text:0040108F retn  
.text:0040108F bar  end  
绝大多数IDA 注释以分号为前缀，表示这一行分号以后的部分属于注释。这与许多汇编器的注释方法类似，并等同于许多脚本语言中的#式注释和C++ 中的// 式注释。
7.2.1 常规注释
最简单直接的注释为常规注释
 。常规注释位于现有汇编代码行的尾部，如前面代码中➊处的注释。右击反汇编窗口右边缘，或者使用冒号（: ）热键，可打开“输入注释”对话框，若在其中输入了多行注释，常规注释将跨越多行。每一行注释将排到反汇编窗口的右侧，并同样以分号开头，且与最第一个分号对齐。要编辑或删除一段注释，必须重新打开“输入注释”对话框，在必要时对其中的注释进行编辑或删除。默认情况下，常规注释以蓝色显示。
IDA 本身就大量使用常规注释。在分析阶段，IDA 插入常规注释说明为调用函数而压入的参数。只有当IDA 拥有被调用函数的参数名称或类型信息时，它才会使用常规注释。通常，这些信息包含在类型库中（这些内容将在第8章和第13 章讨论），也可以手动输入。
7.2.2 可重复注释
可重复注释
 一旦输入，将会自动出现在反汇编窗口中的许多位置。在前面的代码段中，➋处的注释即为可重复注释。在反汇编代码清单中，可重复注释的颜色默认为蓝色，这使得我们很难将它们与常规注释区分开来。在这种情况下，行为比外观更加重要。可重复注释的行为与交叉引用的概念有关。如果一个程序位置引用了另一个包含可重复注释的位置，则该注释会在第一个位置回显。默认情况下，回显的注释以灰色文本显示，从而将这些注释与其他注释区分开来。可重复注释的热键为分号（;），因此，可重复注释与常规注释非常容易引起混淆。  
在前面的代码中，我们注意到，➌处的注释与➋处的注释完全相同。➋处的注释被重复，因为➌处的指令（ jge short loc_40106C
 ）引用了➋处的地址（0040106C
 ）。
如果在一个显示可重复注释的位置添加一段常规注释，则可重复注释将被常规注释覆盖，该位置将仅显示常规注释。如果在➌处输入一段常规注释，那么，从➋处继承得来的可重复注释将不再在➌处显示。如果你删除➌处的常规注释，可重复注释将再次显示。
可重复注释的一种变体与字符串有关。任何时候，如果IDA 自动创建一个字符串变量，字符串变量所在的位置都将添加一段虚拟的可重复注释。我们称之为虚拟
 注释，因为用户无法编辑这段注释。虚拟注释的内容被设置为字符串变量的内容，并且会在整个数据库中显示，就像是一段可重复注释一样。因此，任何引用字符串变量的位置都将以重复注释的形式显示字符串变量的内容。标注为➍的3段注释证明，这类注释是因为引用了字符串变量才显示的。
7.2.3 在前注释和在后注释
在前注释
 和在后注释
 是出现在指定的反汇编行之前或之后的全行注释，它们是IDA 中仅有的不以分号为前缀的注释。在上面的代码段中，➎处的注释即为一段“在前注释”。通过将与某个行相关的地址与该行之后或之前的指令进行比较，即可区分“在前”注释与“在后”注释。
7.2.4 函数注释
通过函数注释
 ，你可以为函数的反汇编代码清单顶部显示的注释分组。前面代码段中➏处显示的注释即为函数注释，其中也包含函数原型。要输入函数注释，首先应突出显示函数顶部的函数名称（➐），然后再输入一段常规注释或可重复注释。可重复函数注释将在调用该函数的任何位置回显。当使用第8章将介绍的SetFunction Type命令时，IDA 将自动生成函数原型式注释。
7.3 基本代码转换
许多时候，对于IDA 生成的反汇编代码清单，你会感到非常满意。但情况并非始终如此。如果你所分析的文件类型与常见编译器生成的普通二进制可执行文件相差甚大，你可能需要对反汇编分析和显示过程进行更多的控制。在分析采用自定义文件格式（IDA 无法识别）的模糊代码或文件时，情况更是如此。
IDA 提供的代码转换包括以下几类：
将数据转换为代码；
将代码转换为数据；
指定一个指令序列为函数；
更改现有函数的起始或结束地址；
更改指令操作数的显示格式。
利用这些操作的频繁程度取决于诸多因素及你的个人喜好。一般而言，如果二进制文件非常 复杂，或者说IDA 不熟悉用于构建二进制文件的编译器所生成的代码序列，那么，IDA 在分析阶 段可能会遇到更多麻烦，因此，你也就需要对反汇编代码进行手动调整。
7.3.1 代码显示选项
你能够对反汇编代码清单所做的最简单的转换是，自定义IDA 为每个反汇编行生成的信息数量。每一个反汇编行都可视为一个由许多部分组成的集合，毫不奇怪，IDA 就称之为反汇编行部分
 。标签、助记符和操作数始终会在反汇编行中显示。你也可以通过Options▶General命令打开“IDA Options”对话框，并选择“Disassembly”选项卡，为每一个反汇编行选择其他需要显示的部分（如图7-4所示）。
图7-4
  反汇编行显示选项
右上角的Display disassembly line parts（显示反汇编行部分）区域提供了几个选项，可帮助你对反汇编行进行自定义。IDA 反汇编文本视图会默认选择行前缀、注释和可重复注释。下面说明其中的每一个选项。
Line prefixes（行前缀）
 。行前缀是每个反汇编行的section:address
 部分。不选这个选项， 每个反汇编行将不会显示行前缀（图形视图的默认设置）。为说明这个选项，我们在后面 的反汇编代码中禁用了行前缀。
Stack Pointer（栈指针）
 。IDA 会详细分析每一个函数，以跟踪程序栈指针的变化。这种分析对于理解每个函数的栈帧的布局非常重要。选中栈指针选项，IDA 将会显示栈指针在每个函数执行过程中的相对变化。这样做有助于识别调用约定方面的差异（例如，IDA 可能不知道某个特殊的函数使用的是stdcall
 调用约定），或者确定对栈指针的不寻常操纵。栈指针跟踪如代码段中➊下面一列所示。在这个例子中，在第一条指令之后，栈指针改变了4字节；在第三条指令之后，总共改变了0x7C字节。在函数退出时，栈指针恢复到它的原始值（相对变化为0字节）。任何时候，如果IDA 遇到一个函数返回语句，并检测到栈指针的值不为0，这时，IDA 将标注一个错误条件，并将相关指令以红色显示。有时候，这样做可能是有意阻挠自动分析。其他情况下，这可能是由于编译器使用了IDA 无法准确分析的“序言”和“尾声”代码。
Comments （注释）和Repeatable comments（可重复注释）
 。取消任何一个选项，IDA将不会显示相应类型的注释。如果你希望梳理一个反汇编代码清单，这些选项可能有用。
Auto comments（自动注释）
 。IDA 可能会为某些指令类型自动添加注释。这种注释可以作为一种提醒，以帮助用户了解特殊指令的行为。IDA 不会为x86 mov
 等简单的指令添加注释。➋处的注释即为自动注释。用户注释优先于自动注释。因此，如果希望看到IDA 为某一行添加的自动注释，你必须删除你添加的任何注释（常规注释或可重复注释）。
Bad instructions marks（无效指令标记）
 。IDA 可以标记出处理器认为合法，但一些汇编器可能无法识别的指令。未记入文档的CPU 指令（而非非法指令）即属此类。这时，IDA 会将这种指令作为一个数据字节序列进行反汇编，并将未记入文档的指令显示为一段以
 开头的注释。这样做的目的是生成大多数汇编程序都可以处理的反汇编代码。请参阅IDA 帮助文档了解使用标记的更多详情。
Numbers of opcode bytes（操作码字节数）
 。大多数反汇编器都能够生成列表文件，逐个显示生成的机器语言字节，以及它们相应的汇编语言指令。IDA 支持将一个十六进制窗口与反汇编代码清单窗口同步，查看与每一个指令有关的机器语言字节。你可以指定IDA 应为每个指令显示的机器语言字节的数量，选择性地查看与汇编语言指令混杂在一起的机器语言字节。
如果你正在反汇编的是指令大小固定的处理器的代码，那么，这个问题就相当简单。但是，对于x86 等指令长度可变，其指令大小从1 字节到十几字节不等的处理器来说，情况就变得复杂了。不管指令多长，IDA 都会在反汇编代码清单中为你在这里指定的字节数预留显示空间，而将反汇编代码行的剩余部分移向右边，从而为你指定的操作码字节数提供空间。在下面的代码中，操作码字节数设置为5，➌下面的一列即说明了这一点。➍处的+号表示：根据当前设置，该位置的指令过长，因而无法完整显示。
➊   ➌  
000 55                   push    ebp  
004 89 E5                mov     ebp, esp  
004 83 EC 78             sub     esp, 78h         ➋; Integer Subtraction  
07C 8B 45 10             mov     eax, [ebp+arg_8]  
07C 89 45 F4             mov     [ebp+var_C], eax  
07C 8B 45 0C             mov     eax, [ebp+arg_4]  
07C 89 45 A4             mov     [ebp+var_5C], eax  
07C C7 45 A0 0A  ➍00+    mov     [ebp+var_60], 0Ah  
07C C6 45 A8 41          mov     [ebp+var_58], 41h  
07C 8B 45 A4             mov     eax, [ebp+var_5C]  
07C 89 44 24 04          mov     [esp+4], eax  
07C 8B 45 A0             mov     eax, [ebp+var_60]  
07C 89 04 24             mov     [esp], eax  
07C E8 91 FF FF FF       call    bar              ➋; Call Procedure  
07C C9                   leave                    ➋; High Level Procedure Exit  
000 C3                   retn                     ➋; Return Near from Procedure
你还可以通过调整图7-4右下角的缩进值和边距，进一步自定义反汇编窗口。这些选项的任何变化都只影响当前数据库。这些选项的全局设置保存在主要配置文件/cfg.ida.cfg中。
7.3.2 格式化指令操作数
在反汇编过程中，IDA 会做出许多决定，确定如何格式化与每条指令有关的操作数。通常，它做出的最重要决定是，如何格式化由各种指令使用的各种整数常量。除其他内容外，这些常量可表示跳转或调用指令中的相对偏移量、全局变量的绝对地址、用在算术运算中的值或者程序员定义的常量。为了使反汇编代码更具可读性，IDA 尽可能地使用符号名称，而非数字。有时候，IDA 根据被反汇编的指令（如调用指令）的上下文做出格式化决定；其他情况下，则根据所使用的数据（如访问的全局变量或栈帧中的偏移量）做出格式化决定。别的许多情况下，常量的具体使用情形可能并不十分清楚，这时，IDA 一般会将相关常量格式化成一个十六进制常量。
如果你碰巧是少数精通十六进制的人中的一个，那么，你会非常喜爱IDA 的操作数格式化功能。右击反汇编窗口中的任何常量，打开如图7-5所示的上下文菜单。
图7-5
  常量格式化选项
在上图中，菜单提供的选项可将常量（41h
 ）重新格式化成十进制、八进制或二进制值。由于这个例子中的常量属于ASCII可打印常量，菜单中还提供了一个选项，可将该常量格式化成一个字符常量。无论什么时候，只要你选择了一个特殊的选项，菜单将显示可用于替代操作数文本的具体文本。
许多时候，程序员在他们的源代码中使用已命名的常量。这些常量可能是使用了#define
 语句（或其等效语句）的结果，也可能属于一组枚举常量。遗憾的是，如果编译器已经完成对源代码的编译，它就不再可能确定源代码使用的是符号常量、文字常量还是数字常量。IDA 维护着大量与许多常见库（如C标准库或Windows API）有关的已命名的常量，用户可以通过常量值的上下文菜单中的Use standard symbolic constant（使用标准符号常量）选项来访问这些常量。在图7-5中，对常量0AH选择这个选项，将打开如图7-6所示的符号选择对话框。
图7-6
  符号选择对话框
根据我们尝试格式化的常量值进行过滤后，这个对话框中的常量从IDA 的内部常量列表导入。在这个例子中，我们看到的是所有IDA 认为与0AH相等的常量。如果我们确定在创建一个X.25类型的网络连接过程中使用了该值，那么，我们就可以选择AF_CCITT，并最终得到下面的反汇编行：
.text:004010A2                 mov     [ebp+var_60], AF_CCITT
标准常量列表非常有用，可用于确定某个特殊的常量是否与一个已知的名称有关，使我们免 于在API文档中搜索潜在的匹配项，从而帮助我们节省大量时间。
7.3.3 操纵函数
在初步的自动分析完成之后，出于许多原因，你可能希望操纵函数。例如，IDA 无法定位一个函数调用，由于没有直接的方法到达函数，IDA 将无法识别它们。另外，IDA 可能无法正确确定函数的结束部分，需要你手动干预，以更正反汇编代码中的错误。此外，如果编译器已经将函数分割到几个地址范围，或者在优化代码的过程中，编译器为节省空间，将两个或几个函数的共同结束序列合并在一起，这时，IDA 同样无法确定函数的结束部分。
1. 新建函数
在某些情况下，你可能需要在没有函数的地方创建新函数。新函数可以由已经不属于某个函数的现有指令创建，或者由尚未被IDA 以任何其他方式定义（如双字或字符串）的原始数据字节创建。将光标放在将要包含在新函数中的第一个字节或指令上，然后选择Edit ▶Functions ▶Create Function，即可创建一个新函数。在必要时，IDA 会将数据转换成代码。接下来，它会向前扫描，分析函数的结构，并搜索返回语句。如果IDA 能够找到正确的函数结束部分，它将生成一个新的函数名，分析栈帧，并以函数的形式重组代码。如果它无法找到函数的结束部分，或者发现任何非法指令，则这个操作将以失败告终。
2. 删除函数
你可以使用Edit ▶Functions ▶Delete Function命令删除现有函数。如果你认为IDA 的自动分析出现错误，你可能希望删除一个函数。
3. 函数块
在由Microsoft Visual C++编译器生成的代码中，经常可以找到函数块。编译器移动不常执行的代码段，用以将经常执行的代码段“挤入”不大可能被换出的内存页，由此便产生了函数块。
如果一个函数以这种方式被分割，IDA 会通过跟踪指向每个块的跳转，尝试定位所有相关的块。多数情况下，IDA 都能找到所有这些块，并在函数的头部列出每一个块，如下面某个函数的
反汇编代码所示：
.text:004037AE ChunkedFunc     proc near  
.text:004037AE  