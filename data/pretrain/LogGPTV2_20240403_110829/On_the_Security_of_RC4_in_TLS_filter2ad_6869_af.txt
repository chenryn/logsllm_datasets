Recall that our single-byte bias attack targets the ﬁrst 256
bytes of plaintext across multiple TLS sessions or con-
nections with random keys. In order to efﬁciently gen-
erate the large number of ciphertexts needed to test our
attack, we again used the s client and s server tools,
this time modifying the s client source code to force a
session resumption for each TLS packet sent.
Using this approach, we were able to generate around
221 encryptions of a ﬁxed plaintext per hour; with 225
recorded ciphertexts, we obtained results comparable to
the simulation of our single-byte bias attack reported in
Section 5.1 above. A second possible approach to ensure
frequently enough rekeying is to actively interfere with
the TLS session after each ciphertext is sent, causing it
to fail and be restarted, by injecting a bad TLS packet or
by resetting the corresponding TCP connection.
We admit that we do not currently have an automated
mechanism for forcing session resumption, e.g., from
JavaScript. However, JavaScript running in the browser
can trigger the browser to establish a fresh TLS session
(with a fresh, random key) after each HTTP connection
torn down by the attacker. We estimate that this second
approach would be signiﬁcantly slower than using ses-
sion resumption because of the additional overhead of
running the full TLS Handshake. Thus, even though our
double-byte bias attack has higher complexity in terms
of its ciphertext requirements than our single-byte bias
attack, in practice it could be the more efﬁcient attack in
terms of total running time, because it can be executed in
a single session (or a small number of sessions).
Furthermore, while the single-byte bias attack suc-
cessfully recovered ﬁxed plaintext bytes in the initial
256 bytes of the TLS ciphertexts, our subsequent experi-
mentation with modern web browsers revealed that these
bytes consisted mostly of less interesting HTTP head-
ers rather than cookies. For this reason, after this ba-
sic validation, we switched our experimental focus to the
double-byte bias attack.
5.3.3 Validating the double-byte bias attack
The double-byte bias attack does not rely on session re-
sumption or session renegotiation and is hence easier to
implement in practice. As our experimental setup for
this attack, we used a network comprising three (non-
virtualized) nodes: a legitimate web server (www.abc.
com) that serves 16-byte secure cookies over HTTPS,
a malicious web server (www.evil.com) serving a ma-
licious JavaScript, and a client running a web browser
representing a user. The legitimate and malicious web
servers run Apache and PHP. For the client, we experi-
mented with various browsers, including Firefox, Opera
and Chrome. The nodes were connected through a
100 Mbps Ethernet link; they were equipped with Intel
Core i7 processors with 2.3 GHz cores and 16 GB of
RAM. None of our experiments used all available CPU
resources, nor saturated the network bandwidth.
In this setup, we let the client visit https://www.
abc.com. This will result in the legitimate web server
sending the client a secure cookie which will be stored
by the client’s browser. This cookie will be the tar-
get of the attack. We then let the client visit http://
www.evil.com and run the malicious JavaScript served
by the malicious web server. Note that the same-origin
policy (SOP) implemented by the client’s browser will
prevent the JavaScript from directly accessing the se-
cure cookie. However, the JavaScript will direct repeated
HTTP requests to the legitimate server over TLS (i.e. us-
ing HTTPS)11. The client’s browser will then automat-
ically attach the cookie to each request and thereby re-
peatedly encrypt the target cookie as required in our at-
tack.
The JavaScript uses XMLHttpRequest objects12 to
send the requests. We tested GET, POST, and HEAD re-
quests, but found that POST requests gave the best per-
formance (using Firefox). Furthermore, we found that
the requests needed to be send in blocks to ensure that
the browser stayed responsive and didn’t become over-
loaded.
For all the browsers we tested (Firefox, Chrome, and
Opera), we found that the requests generated by the
JavaScript resulted in TLS messages containing more
than 256 bytes of ciphertext. To keep the target cookie
in a ﬁxed position in the TLS message (modulo 256)
as needed for the double-byte bias attack, we therefore
added padding by manipulating the HTTP headers in the
request to bring the encrypted POST requests up to ex-
actly 512 bytes. This padding introduces some overhead
to the attack. The exact amount and location of padding
needed is browser-dependent, since different browsers
behave differently in terms of the content and order of
HTTP headers included in POST requests.
In practice,
then, the attacker’s JavaScript would need to perform
some browser ﬁngerprinting before carrying out its at-
tack.
As an alternative method for generating request to the
legitimate web server, we tried replacing the JavaScript
318  22nd USENIX Security Symposium 
USENIX Association
14
code with basic HTML code, using HTML tags such as img,
pointing to https://www.abc.com. The target cookie
was still sent in every request, but we found this approach
to be less effective (i.e. slower) than using JavaScript.
For Firefox with 512-byte ciphertexts encrypting
padded XMLHttpRequest POST requests, we were able
to generate 6 million ciphertexts per hour on our net-
work, with each request containing the target cookie in
the same position (modulo 256) in the corresponding
plaintext. Given that our attack needs on the order of
13 · 230 encryptions to recover a 16-byte plaintext with
high success probability, we estimate that the running
time for the whole attack would be on the order of 2000
hours using our experimental setup. The attack gener-
ates large volumes of network trafﬁc over long periods of
time, and so should not be considered a practical threat.
Nevertheless, it demonstrates that our double-byte bias
attack does work in principle.
6 Discussion and Conclusions
We have shown that plaintext recovery for RC4 in TLS
is possible for the ﬁrst about 200 or so bytes of the
plaintext stream (after the Finished message), provided
sufﬁciently many independent encryptions of the same
plaintext are available. The number of encryptions re-
quired (around 228 to 232 for reliable recovery) is large,
but not completely infeasible. We have also shown that
plaintext recovery for RC4 is possible from arbitrary po-
sitions in the plaintext, given enough encryptions of the
same plaintext bytes. Here, the number of encryptions
required is rather higher (around 13· 230), but the attack
is more ﬂexible and more efﬁcient in practice because
it avoids rerunning the TLS Handshake. Certainly, the
security level provided by RC4 in TLS is far below the
strength implied by the 128-bit key in TLS.
This said, it would be incorrect to describe the attacks
as being a practical threat to TLS today. However, our
attacks are open to further enhancement, using, for ex-
ample, the ability of our algorithms to output likelihoods
for candidate plaintext bytes coupled with more sophis-
ticated plaintext models. It may also be possible to en-
hance the rate of ciphertext generation in browsers using
methods beyond our knowledge. It would seem danger-
ous to assume that the attacks will not be improved by
other researchers in future.
There are countermeasures to the attacks. We dis-
cussed these countermeasures extensively with vendors
during the disclosure process that we followed prior to
making our attacks public. They include: discarding
the initial keystream bytes output by RC4, as recom-
mended in [19]; fragmenting the initial HTTP requests at
the browser so that the initial keystream bytes are mostly
(or entirely) used to encrypt MAC ﬁelds; adding random
padding to HTTP requests; and limiting the lifetime of
cookies or the number of times they can be sent from
the browser. The ﬁrst countermeasure cannot easily be
implemented in TLS because it would require mass co-
ordination between the many different client and server
implementations. The ﬁrst two countermeasures are not
effective against our double-byte bias attack. The third
countermeasure can be relatively easily implemented in
browsers but increases the complexity of our attacks
rather than defeating them completely. The fourth coun-
termeasure is currently effective, but not immune to fur-
ther improvements of our attacks. Some vendors (e.g.
Opera13) have implemented a combination of these (and
other) countermeasures; others (e.g. Google in Chrome)
are focussing on implementing TLS 1.2 and AES-GCM.
We recognise that, with around 50% of TLS trafﬁc
currently using RC4, recommending that it be avoided
completely in TLS is not a suggestion to be made lightly.
Nevertheless, given the rather small security margin pro-
vided by RC4 against our attacks, our recommendation
is that RC4 should henceforth be avoided in TLS, and
deprecated as soon as possible.
Acknowledgements
We thank David McGrew for raising the question of the
security of RC4 in TLS.
References
[1] Wireless LAN medium access control (MAC) and physical layer
(PHY) speciﬁcation, 1997.
[2] Wireless LAN medium access control (MAC) and physical layer
(PHY) speciﬁcation: Amendment 6: Medium access control
(MAC) security enhancements, 2004.
[3] ALFARDAN, N., AND PATERSON, K. G. Lucky 13: Breaking
In IEEE Symposium on
the TLS and DTLS record protocols.
Security and Privacy (2013).
[4] ALFARDAN, N. J., BERNSTEIN, D. J., PATERSON, K. G., PO-
ETTERING, B., AND SCHULDT, J. C. N. On the security of RC4
in TLS and WPA.
Information Security Group at Royal Hol-
loway, University of London, 2013. http://www.isg.rhul.
ac.uk/tls/RC4biases.pdf.
[5] AMMAN, B. Personal communication, February 2013.
[6] CANVEL, B., HILTGEN, A., VAUDENAY, S., AND VUAGNOUX,
M. Password interception in a SSL/TLS channel. Advances in
Cryptology-CRYPTO 2003 (2003), 583–599.
[7] DIERKS, T., AND ALLEN, C. The TLS Protocol Version 1.0.
RFC 2246, Internet Engineering Task Force, Jan. 1999.
[8] DIERKS, T., AND RESCORLA, E. The Transport Layer Secu-
rity (TLS) Protocol Version 1.1. RFC 4346, Internet Engineering
Task Force, Apr. 2006.
[9] DIERKS, T., AND RESCORLA, E. The Transport Layer Secu-
rity (TLS) Protocol Version 1.2. RFC 5246, Internet Engineering
Task Force, Aug. 2008.
[10] DUONG, T., AND RIZZO, J. Here come the ⊕ Ninjas. Unpub-
lished manuscript, 2011.
USENIX Association  
22nd USENIX Security Symposium  319
15
Notes
of RC4
see
being
advice
the
at Qualys’ website
in
1The research of the third, fourth and ﬁfth authors was supported
by an EPSRC Leadership Fellowship, EP/H005455/1. The research of
the second author was supported by the National Science Foundation
under grant 1018836 and by the Netherlands Organisation for Scientiﬁc
Research (NWO) under grant 639.073.005.
Pulse
(https://www.trustworthyinternet.org/
ssl-pulse/) reported in June 2013 that only 15.1% of 170,000
websites surveyed support TLS 1.2; most major browsers currently do
not support TLS 1.2.
examples
recommended
3For
2SSL
of CBC attacks,
face
https://community.qualys.com/blogs/securitylabs/
2011/10/17/mitigating-the-beast-attack-on-tls,
Ivan Ristic’s personal blog http://blog.ivanristic.com/
2009/08/is-rc4-safe-for-use-in-ssl.html,
PhoneFac-
tor’s
http://blog.phonefactor.com/2011/09/23/
slaying-beast-mitigating-the-latest-ssltls
-vulnerability, and F5’s suggested Lucky 13 mitigation at
http://support.f5.com/kb/en-us/solutions/public/
14000/100/sol14190.html. Other examples abound on discussion
forums and vendor websites.
blog
4http://notary.icsi.berkeley.edu
5Unfortunately, we do not currently know of a way to trigger TLS
session resumption from JavaScript running in a browser.
6The Internet Message Access Protocol (IMAP) is a popular proto-
col for email retrieval.
7Note that when attacking secret URL parameters from HTTPS
connections or passwords from IMAP sessions such limitations do not
arise.
8 In detail, instead of an internal permutation S of 8-bit values,
Fluhrer and McGrew consider variants of RC4 based on permutations
of 3-bit, 4-bit, and 5-bit values, respectively. Note that in these versions
of RC4, the internal variables i and j, as well as the output Zr, will also
be 3-bit, 4-bit and 5-bit values, respectively.
9Note that the internal state S, which corresponds to a permutation
over byte values, will not be distributed as a random permutation im-
mediately after the key scheduling algorithm is run, even if the used
key is picked uniformly at random. Furthermore, j will not be random,
but initialized to 0. However, random S and j will be a close approx-
imation after keystream bytes have been generated a short period of
time (see [12] for further discussion of this property).
10Our experiments showed that there is no signiﬁcant difference in
the recovery rate when running the attack on encryptions of the plain-
text generated by a single key and encryptions generated by a small
number of different keys.
11This is made possible by Cross-Origin Resource Sharing (CORS),
a mechanism developed to allow JavaScript to make requests to another
domain than the domain the script originates from.
12http://www.w3.org/TR/XMLHttpRequest/
13http://my.opera.com/securitygroup/blog/2013/03/
20/on-the-precariousness-of-rc4
[11] FLUHRER, S. R., MANTIN, I., AND SHAMIR, A. Weaknesses in
the key scheduling algorithm of RC4. In Selected Areas in Cryp-
tography (2001), S. Vaudenay and A. M. Youssef, Eds., vol. 2259
of Lecture Notes in Computer Science, Springer, pp. 1–24.
[12] FLUHRER, S. R., AND MCGREW, D. Statistical analysis of the
alleged RC4 keystream generator. In FSE (2000), B. Schneier,
Ed., vol. 1978 of Lecture Notes in Computer Science, Springer,
pp. 19–30.
[13] ISOBE, T., OHIGASHI, T., WATANABE, Y., AND MORII, M.
Full plaintext recovery attack on broadcast RC4. In Preproceed-
ings of FSE (2013).
[14] JAGANATHAN, K., ZHU, L., AND BREZAK, J. The RC4-HMAC
Kerberos Encryption Types Used by Microsoft Windows. RFC
4757 (Informational), Dec. 2006.
[15] MAITRA, S., PAUL, G., AND SENGUPTA, S. Attack on broad-
In FSE (2011), A. Joux, Ed., vol. 6733 of
cast RC4 revisited.
Lecture Notes in Computer Science, Springer, pp. 199–217.
[16] MANTIN,
I.
Predicting and distinguishing attacks on rc4
keystream generator. In EUROCRYPT (2005), R. Cramer, Ed.,
vol. 3494 of Lecture Notes in Computer Science, Springer,
pp. 491–506.
[17] MANTIN, I., AND SHAMIR, A. A practical attack on broadcast
RC4. In FSE (2001), M. Matsui, Ed., vol. 2355 of Lecture Notes
in Computer Science, Springer, pp. 152–164.
[18] MCGREW, D., AND BAILEY, D. AES-CCM Cipher Suites for
Transport Layer Security (TLS). RFC 6655 (Proposed Standard),
2012.
[19] MIRONOV, I.
(Not so) random shufﬂes of RC4.
In CRYPTO
(2002), M. Yung, Ed., vol. 2442 of Lecture Notes in Computer
Science, Springer, pp. 304–319.
[20] PHP DOCUMENTATION GROUP. PHP manual, Feb 2013. http:
//www.php.net/manual/en/session.configuration.
php#ini.session.hash-bits-per-character.
[21] SALOWEY, J., CHOUDHURY, A., AND MCGREW, D. AES Ga-
lois Counter Mode (GCM) Cipher Suites for TLS. RFC 5288
(Proposed Standard), Aug. 2008.
[22] SEN GUPTA, S., MAITRA, S., PAUL, G., AND SARKAR, S.
Proof of empirical RC4 biases and new key correlations. In Se-
lected Areas in Cryptography (2011), pp. 151–168.
[23] SEN GUPTA, S., MAITRA, S., PAUL, G., AND SARKAR, S.
(Non-) random sequences from (non-) random permutations –
analysis of RC4 stream cipher. Journal of Cryptology to appear
(2013).
[24] SEPEHRDAD, P., VAUDENAY, S., AND VUAGNOUX, M. Discov-
ery and exploitation of new biases in RC4. In Selected Areas in
Cryptography (2010), A. Biryukov, G. Gong, and D. R. Stinson,
Eds., vol. 6544 of Lecture Notes in Computer Science, Springer,
pp. 74–91.
[25] SEPEHRDAD, P., VAUDENAY, S., AND VUAGNOUX, M. Sta-
tistical attack on RC4 – distinguishing WPA. In EUROCRYPT
(2011), K. G. Paterson, Ed., vol. 6632 of Lecture Notes in Com-
puter Science, Springer, pp. 343–363.
[26] VAUDENAY, S., AND VUAGNOUX, M. Passive-only key recov-
ery attacks on RC4. In Selected Areas in Cryptography (2007),
C. M. Adams, A. Miri, and M. J. Wiener, Eds., vol. 4876 of Lec-
ture Notes in Computer Science, Springer, pp. 344–359.
320  22nd USENIX Security Symposium 
USENIX Association
16