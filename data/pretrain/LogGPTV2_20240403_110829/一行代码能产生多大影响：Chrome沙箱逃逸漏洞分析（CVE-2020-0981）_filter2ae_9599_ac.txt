Activator，该系统服务负责启动进程外COM服务器，可以从我们的沙箱级别访问该服务。它还将所有COM服务器作为服务进程的子级启动，这意味着Job对象不会被继承。看起来很理想，但还存在一个小问题，为了使DCOM
Activator有效，我们需要沙箱可以创建的进程外COM服务器。该对象必须满足以下条件：
1、服务器的Launch Security授予沙箱本地激活权限；
2、服务器不能以交互用户身份运行（该用户会从沙箱中派生），也不能在服务进程中运行；
3、服务器可执行文件必须可以访问受限令牌。
在这里，我们不需要担心第3条，GPU进程可以访问系统可执行文件，因此我们使用预先安装的COM服务器。创建后，是否无法访问COM服务器也并不重要，我们所需要的只是在Job外部启动COM服务器进程的权限，然后就可以实现劫持。我们可以使用`OleViewDotNet`和`Select-ComAccess`命令，找到可访问的COM服务器。
     PS> Get-ComDatabase -SetCurrent
    PS> Get-ComClass -ServerType LocalServer32 | `
          Where-Object RunAs -eq "" | `
          Where-Object {$_.AppIdEntry.ServiceName -eq ""} | `
          Select-ComAccess -ProcessId 6804 `
               -LaunchAccess ActivateLocal -Access 0 | `
          Select-Object Clsid, DefaultServerName
    Clsid                                DefaultServerName
    -----                                -----------------    3d5fea35-6973-4d5b-9937-dd8e53482a56 coredpussvr.exe
    417976b7-917d-4f1e-8f14-c18fccb0b3a8 coredpussvr.exe
    46cb32fa-b5ca-8a3a-62ca-a7023c0496c5 ieframe.dll
    4b360c3c-d284-4384-abcc-ef133e1445da ieframe.dll
    5bbd58bb-993e-4c17-8af6-3af8e908fca8 ieproxy.dll
    d63c23c5-53e6-48d5-adda-a385b6bb9c7b ieframe.dll
在Windows 10的默认安装中，我们有6个备选的软件。请注意，其中4个都在DLL中，但是这些类已经注册为在DLL
Surrogate中运行，因此仍然可以在进程外使用。我们决定选择COREDPUSSVR中的服务器，因为它是唯一的可执行文件，而不是通用的DLLHOST，因此更易于查找。这个COM服务器的启动安全性授予每个人和所有AppContainer程序包本地激活权限，如下所示：
顺便提一句，即使为`COREDPUSSVR`注册了两个类，这个可执行文件实际上也只注册了一个以`417976b7`开头的类。创建另一个类，将启动服务器可执行文件，但是类的创建将会挂起，以等待一个永远不会出现的类。
要启动服务器，我们需要在模拟子进程无标志受限令牌的同时调用`CoCreateInstance`。我们还需要传递`CLSCTX_ENABLE_CLOAKING`，以模拟令牌激活服务器，默认值将使用已设置子进程缓解标志的进程令牌，因此将会阻止进程的创建。这样一来，我们就可以发现一个`COREDPUSSVR`实例在相同的沙箱级别运行，但是在Job对象之外，并且也没有子进程的缓解。我们似乎接近成功了。
但是，还没有那么快。通常，新进程的默认安全性基于用于创建新进程的访问令牌中的默认DACL。但遗憾的是，由于某些未知原因，DCOM
Activator在进程上设置了一个明确的DACL，它仅授予对用户、SYSTEM和当前登录SID的访问权限。即使GPU进程实际上以相同的安全级别运行，也不允许GPU进程打开新的COM服务器进程。我们如此接近成功，但又离成功如此遥远。我尝试了几种方法在COM服务器内部执行代码，例如Windows
Hooks，但没有效果。
幸运的是，进程启动后创建的所有线程仍然将使用默认的DACL。我们可以打开其中一个线程，进行完全访问，并使用`SetThreadContext`更改线程上下文以重定向执行。我们需要对这些新线程的线程ID进行暴力破解，因为进一步的沙箱缓解措施将阻止我们使用`CreateToolhelp32Snapshot`来枚举无法直接打开的进程，而`NtGetNextThread`需要我们现在还没有的父进程句柄。
滥用线程会非常痛苦，特别是在我们没有办法直接将任何内容写入进程的时候，但这至少可以有效。为了简便起见，我决定调用WinExec，它将生成一个新进程，并且只需要执行命令行即可。新进程将具有基于默认DACL的安全性，因此我们可以将其打开。
我可以选择其他类似`LoadLibrary`的方式来加载DLL。但是，在比较混乱的线程上下文中，这可能会导致进程崩溃。我认为，最好的方法是尽快逃逸这个进程，以避免这种情况。
那么，用什么作为WinExec的命令行呢？我们无法在COM服务器进程中直接写入或分配内存，但是我们可以轻松地重新利用二进制文件中现有的字符串来执行。为了避免寻找字符串地址或处理ASLR，我们选择在DLL的开头使用PE签名，该签名为我们提供了字符串“PE”。当传递给WinExec时，当前的PATH环境变量将会用于查找要启动的可执行文件。我们可以将PATH设置为COM服务器中所需的任何内容，因为当以相同的安全级别启动进程时，DCOM
Activator将使用调用方的环境。我们唯一要做的就是找到一个可以写入的目录，这次我们可以使用`Get-AccessibleFile`找到一个候选对象，如下所示。
    PS> Get-AccessibleFile -Win32Path "C:" -Recurse -ProcessIds 6804 `
         -DirectoryAccessRights AddFile -CheckMode DirectoriesOnly `
         -FormatWin32Path | Select-Object Name
    Name
    ----    C:ProgramDataMicrosoftDeviceSync
通过设置PATH环境变量，在其中包含`DeviceSync`路径，并将名为PE.exe的可执行文件复制到该目录，我们可以设置线程上下文，并生成一个新的进程，该进程不在Job对象中，并且可以由GPU进程打开。
现在，我们可以利用内核漏洞，以低IL运行不受限制的令牌，从新的进程中调用`CreateProcessAsUser`。这样一来，将会删除所有除低级别IL以外的沙箱。最后一步，就是突破低IL。也有很多方法可以做到这一点，但我选择了滥用UAC服务。通过滥用相同的令牌访问权限，我们得以在利用链中滥用权限，打开不受限制的令牌，从而获得UI访问权限。这样一来，我们可以自动化特权用户界面，以在低级别沙箱外部执行任意代码。这不一定有效，但可以尝试。
最终，我们总结的利用链如下：
1、打开一个不受限制的令牌。
a、暴力破解进程，直到找到合适的进程令牌。
2、复制令牌，以创建新的主令牌，并使令牌可写。
a、重复令牌为只读；  
b、复制句柄，以获得写访问权限。
3、投放令牌的IL，以匹配当前令牌。
4、使用新令牌调用`CreateProcessAsUser`。
a、创建一个新的受限令牌，以删除子进程缓解标志。  
b、将环境块的PATH设置为包含`DeviceSync`的文件夹，然后投放PE.exe文件。  
c、模拟受限令牌，并创建OOP COM服务器。  
d、暴力破解COM服务器进程中的线程ID。  
e、修改线程上下文，以调用WinExec，在内存中传递已知PE签名的地址。  
f、等待创建PE进程。
5、逃逸低IL沙箱。
a、生成屏幕键盘的副本，并打开其令牌。  
b、根据打开的令牌，创建具有UI访问权限的新进程。  
c、自动运行对话框，以退出低IL沙箱。
或者，以图表形式表示如下：
## 总结
我希望通过这篇文章，能让大家熟悉Windows内核中的一个微小更改是如何严重影响沙箱环境安全性的。此外，还演示了缓解沙箱行为的漏洞利用的价值。因为缓解措施的存在，很多时候都让漏洞利用过程不再那么便捷。  
研究引入漏洞的场景和过程会非常有趣。我们推断，也许是有人在更新代码的过程中，认为这是一个Bug，并且对其进行了“修复”。或者，是随着时间的推移才失去了单线的安全性。无论如何，这并不是有意的调整，而且也在现在提供了修复的方案。  
由于操作系统中的一些“特性”，即使漏洞利用方法需要花费很多精力才能发现，但通常也可以通过一些缓解措施来达成目标。这些功能本身并非安全问题，但对于构建漏洞利用链来说非常有帮助。