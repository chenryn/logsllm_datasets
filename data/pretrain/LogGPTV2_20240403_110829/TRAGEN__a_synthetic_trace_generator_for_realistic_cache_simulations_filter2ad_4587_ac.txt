bFD, the subtraction operator provides a means to compute the
bFD of the trace that is formed by removing all the requests (i.e.,
corresponding bytes) that are made for a subset of objects from Î ğµ.
If Î ğµ
1 is the sequence that is removed from Î ğµ, the byte footprint
2 = Î ğµ âŠ– Î ğµ
descriptor of the resultant sequence Î ğµ
1 can be computed
using the subtraction operator. By using the inverse fourier transform,
the subtraction operator runs in ğ‘‚(ğ‘‡ ğ‘† log ğ‘†) time.
(iii) Scaling. Given a byte sequence Î ğµ and its corresponding
bFD, the scaling operator provides a means to compute the byte
footprint descriptor of a trace whose traffic rate is intensified or
rarefied i.e., the traffic volume ğœ† is altered. The scaling operator runs
in ğ‘‚(ğ‘‡ ğ‘†) time.
We experimentally verify that the calculus works for bFD. We
consider the trace EU that is described in Table 3. We compute bFD
of each individual traffic class in the trace and use the calculus to find
the bFD of the traffic mix. We verify that the bHRC computed using
the trace that corresponds to the traffic mix aligns with the bHRC
predicted by the calculus. The result of the experiment is depicted in
Figure 4. The Media0+Media1(trace) curve depicts the bHRC com-
puted from the subsequence of trace EU that consists of objects from
the Media0 and Media1 traffic class. The Media0+Media1(calculus)
curve depicts the bHRC computed using the addition operator from
the calculus.
3.2 Object size distribution of a traffic mix
A traffic mix is specified by a list of traffic classes Î“ = {ğœ1, . . . , ğœğ‘›}
and a weight vector W = {ğ‘¤1, . . . , ğ‘¤ğ‘›} that specifies the traffic
contribution of each traffic class in GBps. To compute the object size
distribution of a traffic mix, we first compute an object weight vector
O that provides us the ratio of the number of objects per traffic class
that is to be present in the produced synthetic trace.
For each traffic class, we first compute the expected unique byte
rate (ğ‘ˆğ‘–), which is the number of unique bytes requested per unit
time. Now, we can compute the expected unique object rate i.e., the
370
IMC â€™21, November 2â€“4, 2021, Virtual Event, USA
Anirudh Sabnis and Ramesh K. Sitaraman
Algorithm 1 Object Weight Estimator
1: Input. (i) A list of byte footprint descriptors ğ‘ğ¹ ğ· = {ğ‘ğ¹ ğ·1, . . . , ğ‘ğ¹ ğ·ğ‘›}
of each traffic class ğœğ‘– , (ii) a weight vector ğ‘Š = {ğ‘¤1, . . . , ğ‘¤ğ‘›}, where
ğ‘¤ğ‘– specifies the traffic volume (in GBps) for the traffic class ğœğ‘– , and
(iii) size distribution of the objects ğ‘†ğ‘ = {ğ‘†ğ‘1, . . . , ğ‘†ğ‘ğ‘›} of each traffic
class ğœğ‘– .
2: Output. An object weight vector O = {ğ‘œ1, . . . , ğ‘œğ‘›} that specifies the
ratio of number of objects per traffic class.
ğ‘ˆğ‘œğ‘Ÿğ‘–ğ‘” + = ğ‘ƒğ‘Ÿğ‘ (ğ‘ , ğ‘¡). ğ‘ 
ğ‘ˆğ‘œğ‘Ÿğ‘–ğ‘” = 0
for ğ‘  âˆˆ ğ‘† do // ğ‘† be the stack distance buckets in ğ‘ƒğ‘Ÿğ‘ (ğ‘ , ğ‘¡).
for ğ‘¡ âˆˆ ğ‘‡ do // ğ‘‡ be the time buckets in ğ‘ƒğ‘Ÿğ‘ (ğ‘ , ğ‘¡).
3: O â† {}
4: for ğ‘ğ¹ ğ·ğ‘– âˆˆ ğ‘ğ¹ ğ· do // ğ¹ ğ·ğ‘– = âŸ¨ğœ†, ğ‘ƒğ‘Ÿğ‘ (ğ‘ , ğ‘¡), ğ‘ƒğ‘ğ‘ (ğ‘ , ğ‘¡)âŸ©
5:
6:
7:
8:
9:
10:
11:
12:
13:
end for
Let ğ‘ ğ‘ğ‘£ğ‘”
be the average object size of the traffic class ğœğ‘–
Let ğœ†ğ‘– be the traffic volume (in GBps) of traffic class ğœğ‘–
Ã— ğ‘ˆğ‘œğ‘Ÿğ‘–ğ‘”
ğ‘ˆğ‘– = ğ‘¤ğ‘–
ğœ†ğ‘–
ğ‘œğ‘– â† ğ‘ˆğ‘–
ğ‘ ğ‘ğ‘£ğ‘”
ğ‘–
Append ğ‘œğ‘– to O
end for
14:
ğ‘¡
ğ‘–
15:
16: end for
17: return O
Initialization. An empty list ğ¶ that represents a cache is initialized
in line 5. Through lines 7-11, we iteratively create new objects,
assign them a size that is sampled from the object size distribution
ğ‘†ğ‘, and append them to the list. We repeat till the sum of the sizes
of the objects exceeds the maximum stack distance in ğ‘ƒ(ğ‘ ). The
maximum stack distance is the maximum number of unique bytes in
any request or byte subsequence of the original trace. Each entry in
ğ¶ is thus a tuple âŸ¨ğ‘œğ‘–ğ‘‘, ğ‘§âŸ© of object id and size.
Synthetic trace generation. The trace generation algorithm runs
from line 17 to line 27. In each iteration ğ‘–, the object at the first
position in the list ğ¶, say ğ‘œ = âŸ¨ğ‘œğ‘–ğ‘‘, ğ‘§âŸ©, is appended to the trace ğ‘† that
is being produced. Now, a stack distance ğ‘ ğ‘– is sampled from ğ‘ƒ(ğ‘ )
and the list is manipulated based on the value of ğ‘ ğ‘–. There are two
cases:
(i) if ğ‘ ğ‘– is finite (lines 17-21): the object ğ‘œ is removed and re-
inserted back at a position ğ‘— in ğ¶, by moving the objects at positions
â‰¥ ğ‘— by a step. The location ğ‘— is decided as follows. We find the first
position in the list, say ğ‘˜, such that the sum of the sizes of the objects
at locations from 1 to ğ‘˜ in ğ¶ is greater than ğ‘ ğ‘–. Let the sum of the
sizes of the objects be ğ‘†ğ‘˜ and the size of the object at position ğ‘˜ be
ğ‘§ğ‘˜. Now, if ğ‘ ğ‘– â‰¤ ğ‘†ğ‘˜âˆ’1 + ğ‘§ğ‘˜
2 , i.e., the stack distance ğ‘ ğ‘– falls on the first
half of the object at position ğ‘˜, then ğ‘— is set to ğ‘˜ âˆ’ 1 and set to ğ‘˜
otherwise. This ensures that object ğ‘œ is re-inserted at a location that
is as close as possible to stack distance ğ‘ ğ‘–.
(ii) if ğ‘ ğ‘– is âˆ (lines 21-25): object ğ‘œ is removed from ğ¶ and a new
object ğ‘œâ€² is inserted at the end of the list.
Now in line 28, a timestamp ğ‘¡ğ‘– is assigned to each request ğ‘Ÿğ‘– in the
synthetic trace ğ‘†. We assign timestamp to the synthetic trace based
on the byte rate ğœ† obtained from the bFD.
Time complexity. We implement the list ğ¶ as the leaves of a ğµ+-tree
[15], and thus, the complexity of the algorithm is O(ğ‘ log ğ‘š), where
Figure 4: The bHRC for the traffic mixes in the EU trace as predicted
by the calculus aligns with the original.
ğ‘–
. Here, ğ‘ ğ‘ğ‘£ğ‘”
number of unique objects requested per unit time, for the traffic class
as ğ‘ˆğ‘–/ğ‘ ğ‘ğ‘£ğ‘”
is the average object size of the traffic class.
The ratio of unique object rate across the specified traffic classes
gives us the object weight vector O . The procedure is described in
Algorithm 1.
ğ‘–
(cid:17)
ğ‘ˆğ‘œğ‘Ÿğ‘–ğ‘” =ğ‘¡ğ‘  ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡)(cid:16) ğ‘ 
The computation of unique byte rate ğ‘ˆğ‘– is done as follows. Let
ğ‘ˆğ‘œğ‘Ÿğ‘–ğ‘” be the expected unique byte rate of a traffic class ğœğ‘– and
bFD of ğœğ‘– is a tuple âŸ¨ğœ†, ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡), ğ‘ƒğ‘ğ‘(ğ‘ , ğ‘¡)âŸ©. As described in lines
6-10 of Algorithm 1, we can compute ğ‘ˆğ‘œğ‘Ÿğ‘–ğ‘” from the bFD using
. Recall that ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡) is a joint probabil-
ity distribution that a reuse byte subsequence has ğ‘  unique bytes and
ğœ† Ã— ğ‘ˆğ‘œğ‘Ÿğ‘–ğ‘” (line
duration ğ‘¡ seconds. Now, ğ‘ˆğ‘– can be computed as ğ‘¤ğ‘–
13), where ğ‘¤ğ‘– is the traffic volume specified by the user and ğœ† is the
traffic volume of the original trace.
ğ‘¡
The object size distribution, SZ, of the traffic mix can be com-
puted by weighting the SZ of individual traffic classes by a weight
proportional to its contribution in the object weight vector.
4 Trace Generator
The trace generator produces a synthetic trace with same request
hit rate curve (rHRC) or byte hit rate curve (bHRC) as the original
trace or a user-specfied traffic mix.
4.1 Trace generation algorithm
Algorithm 2 performs trace generation and is described below.
Input. The algorithm is provided with a model of a traffic class or
traffic mix:
(1) a FD âŸ¨ğœ†, ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡), ğ‘ƒğ‘(ğ‘ , ğ‘¡)âŸ©,
(2) a bFD âŸ¨ğœ†, ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡), ğ‘ƒğ‘ğ‘(ğ‘ , ğ‘¡)âŸ©,
(3) an object size distribution ğ‘†ğ‘, and
(4) the number of requests ğ‘ to be generated.
Output. A synthetic trace ğ‘† = {ğ‘Ÿ1, . . . , ğ‘Ÿğ‘ }, where each ğ‘Ÿğ‘– = âŸ¨ğ‘¡ğ‘–, ğ‘œğ‘–, ğ‘§ğ‘–âŸ©
is a tuple of timestamp, object id, and object size.
Note: The algorithm uses either the FD or bFD depending on
whether RHR or BHR is required. Let ğ‘ƒ(ğ‘ ) =ğ‘¡ ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡) or ğ‘ƒ(ğ‘ ) =
ğ‘¡ ğ‘ƒğ‘Ÿğ‘(ğ‘ , ğ‘¡) be the marginal distribution from the FD or bFD, de-
pending on the input. .
371
0.02.55.07.510.0Cache size (TB)0.00.20.40.60.81.0Byte hit rate (BHR)Media0+Media1(trace)Media0+Media1(calculus)Media0+Media2(trace)Media0+Media2(calculus)TRAGEN: A Synthetic Trace Generator for Realistic Cache Simulations
ğ‘ is the length of the synthetic trace and ğ‘š is the number of unique
objects in the synthetic trace. The algorithm runs for ğ‘ iterations
and in each iteration it takes log(ğ‘š) time to insert the object back
into the list at the sampled stack distance (line 19).
We will now formally prove that the algorithm produces a syn-
thetic trace that has approximately the same HRCs as predicted
by the footprint descriptors. In particular, if Footprint Descriptor
(FD) is provided as the input, the algorithm produces a trace with
approximately the same rHRCs (Theorem 3). When Byte-weighted
Footprint Descriptor (bFD) is provided as the input, the algorithm
produces a trace with approximately the same bHRCs (Theorem 4).
Algorithm 2 Synthetic trace generator
1: Input. (i) A Footprint Descriptor (FD) âŸ¨ğœ†, ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡), ğ‘ƒğ‘(ğ‘ , ğ‘¡)âŸ©, (ii) Byte-
weighted Footprint Descriptor (bFD) âŸ¨ğœ†, ğ‘ƒğ‘Ÿğ‘ (ğ‘ , ğ‘¡), ğ‘ƒğ‘ğ‘ (ğ‘ , ğ‘¡)âŸ©, (iii) Ob-
ject size distribution (ğ‘†ğ‘ (ğ‘§)) and (iv) trace length ğ‘ .
2: Output. A synthetic trace ğ‘† = {ğ‘Ÿ1, . . . , ğ‘Ÿğ‘ }, where ğ‘Ÿğ‘– = âŸ¨ğ‘¡ğ‘–, ğ‘œğ‘–, ğ‘§ğ‘– âŸ© is a
tuple of timestamp, object identifier and object size.
4: ğ‘ƒ (ğ‘ ) =ğ‘¡ ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡) or ğ‘ƒ (ğ‘ ) =ğ‘¡ ğ‘ƒğ‘Ÿğ‘ (ğ‘ , ğ‘¡) depending on whether RHR
3: Phase 1 - Initialization.
or BHR is required.
5: ğ¶ â† {}, ğ¶ğ‘ ğ‘–ğ‘§ğ‘’ = 0.
6: ğ¶ğ‘šğ‘ğ‘¥ is the maximum finite ğ‘  in ğ‘ƒ (ğ‘ ).
7: while ğ¶ğ‘ ğ‘–ğ‘§ğ‘’ < ğ¶ğ‘šğ‘ğ‘¥ do
8:
9:
10:
11: end while
Create object ğ‘œ and assign a size ğ‘§ sampled from ğ‘†ğ‘ .
Add object ğ‘œ to the list ğ¶.
ğ¶ğ‘ ğ‘–ğ‘§ğ‘’ â† ğ¶ğ‘ ğ‘–ğ‘§ğ‘’ + ğ‘§.
12: Phase 2 - Synthetic trace generation.
13: ğ‘† â† ğœ™, ğ‘– â† 0.
14: while ğ‘– < ğ‘ do
15:
16:
17:
18:
19:
Compute ğ‘— = ğ‘šğ‘–ğ‘›{ğ‘˜ :ğ‘˜
Append the first object ğ‘œ = âŸ¨ğ‘œğ‘–ğ‘‘ , ğ‘§âŸ© in ğ¶ to the trace ğ‘†.
Sample stack distance ğ‘  from ğ‘ƒ (ğ‘ ).
if ğ‘  is not âˆ then
Remove ğ‘œ from ğ¶.
ğ‘–=1 ğ‘§ğ‘˜ â‰¥ ğ‘ }; where ğ‘§ğ‘– is the size of the
Re-insert object ğ‘œ at position ğ‘— in ğ¶ by moving objects at posi-
object at ğ¶[ğ‘–].
tions â‰¥ ğ‘— by a step.
20:
else// âˆ means a new object was introduced in the trace.
Remove the object ğ‘œ that is at the first index in ğ¶.
Create new object ğ‘œâ€² and assign it a size ğ‘§ sampled from ğ‘†ğ‘ .
Add object ğ‘œâ€² at the end of the list ğ¶.
21:
22:
23:
24:
25:
26:
27: end while
28: Assign timestamps to requests in ğ‘† using ğœ† from bFD.
29: return ğ‘†
end if
ğ‘– â† ğ‘– + 1
THEOREM 3. Given a FD, âŸ¨ğœ†, ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡), ğ‘ƒğ‘(ğ‘ , ğ‘¡)âŸ©, and a size distri-
bution ğ‘†ğ‘ of an original trace Î , Algorithm 2 produces a synthetic
trace ğ‘† = {ğ‘Ÿ1, . . . , ğ‘Ÿğ‘ }, where ğ‘Ÿğ‘– is a tuple âŸ¨ğ‘¡ğ‘–, ğ‘œğ‘–, ğ‘§ğ‘–âŸ© of timestamp,
object id and object size and ğ‘ is the synthetic trace length. As
ğ‘ â†’ âˆ, the rHRC of traces ğ‘† and Î  for an LRU cache are approxi-
mately equal.
372
PROOF. Let ğ‘ƒ(ğ‘ ) =ğ‘¡ ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡), where ğ‘ƒğ‘Ÿ (ğ‘ , ğ‘¡) is the reuse subse-
IMC â€™21, November 2â€“4, 2021, Virtual Event, USA
quence descriptor function of trace Î . Consider the synthetic trace
ğ‘† = {ğ‘Ÿ1, . . . , ğ‘Ÿğ‘ }. In each iteration ğ‘– of the algorithm, we sample a
stack distance ğ‘ ğ‘– from ğ‘ƒ(ğ‘ ) and request ğ‘Ÿğ‘– is added to the synthetic
trace ğ‘†. Let request ğ‘Ÿğ‘– be made for an object ğ‘œ. We know ğ‘ ğ‘– can either
be a finite quantity or be âˆ. We consider both cases and show that
in either case ğ‘ ğ‘– is approximately represented in the synthetic trace.
Case 1: ğ‘ ğ‘– is finite. In the ğ‘–ğ‘¡â„ iteration, let ğ‘˜ be the smallest index
in ğ¶ such that the sum of the sizes of the objects from position 1
to ğ‘˜ in ğ¶ is greater than or equal to ğ‘ ğ‘–. Let ğ‘§ğ‘˜ be the size of the
object at position ğ‘˜. As ğ‘œ is inserted at the position ğ‘˜ in ğ¶, it is
inserted at a stack distance that is at least ğ‘ ğ‘– and at most ğ‘ ğ‘– + ğ‘§ğ‘˜
(line 19, Algorithm 2). Now, if ğ‘Ÿ ğ‘— is the subsequent request in ğ‘† that
was made for object ğ‘œ, the request subsequence ğœƒ = {ğ‘Ÿğ‘–, . . . , ğ‘Ÿ ğ‘—} is
a reuse request subsequence in ğ‘†. The unique objects in ğœƒ are the
objects present at positions 1 to ğ‘˜ in ğ¶ in the ğ‘–ğ‘¡â„ iteration of the
algorithm. We know the sum of the sizes of these objects is at least
ğ‘ ğ‘– and at most ğ‘ ğ‘– + ğ‘§ğ‘˜. Since the number of objects in the trace is
typically large, the reuse request sequences often have many unique
objects, hence ğ‘ ğ‘– â‰« ğ‘§ğ‘˜. Therefore, the number of unique bytes in ğœƒ
is approximately ğ‘ ğ‘– and the sampled stack distance ğ‘ ğ‘– is represented