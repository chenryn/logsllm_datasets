       void* kern_text_phys_end = rkp_get_pa(etext);
       rkp_debug_log("DEFERRED INIT START", 0, 0, 0);
       if (etext & 0x1FFFFF)
           rkp_debug_log("Kernel range is not aligned", 0, 0, 0);
       if (!rkp_s2_range_change_permission(kern_text_phys_start, kern_text_phys_end, 128, 1, 1))
           rkp_debug_log("Failed to make Kernel range RO", 0, 0, 0);
       ...
    }
上面突出显示的函数调用用于修改给定PA内存范围的阶段2访问权限。使用这些参数调用函数将导致给定的内存范围在阶段2转换中被标记为只读。这意味着在引导EL1内核后不久，RKP确实锁定了对内核代码范围的写访问。
…但是，还是有些东西还在这里。记住，RKP不仅应该防止内核的代码被修改，而且还旨在防止攻击者在EL1中创建新的可执行代码。好吧，虽然内核的代码确实被标记为只读在阶段2翻译表，这是否必然阻止我们创建新的可执行代码？
回想一下，我们以前遇到过KASLR的存在，其中内核的基地址（在内核的VAS和相应的物理地址中）被一个随机化的“滑动”值移动。此外，由于Linux内核假定内核地址的虚拟到物理偏移是恒定的，这意味着相同的滑动值用于虚拟地址和物理地址。
然而，这里有一个小小的障碍 –
我们前面研究的地址范围，标记为RWX的同一个是第一阶段和第二阶段翻译表，比内核的文本段大得多。这部分地是为了在确定KASLR幻灯片之后允许将内核放置在该区域内的某处。然而，正如我们刚才看到的，在选择KASLR幻灯片之后，RKP只保护从“_text”到“_etext”的范围，也就是说，在应用KASLR幻灯片之后，只保留包含内核文本的区域。
这使我们有两个大的区域：[0x80000000，“_text”]，[“_etext”，0x81400000]，在阶段1和阶段2翻译表中留下标记为RWX！
因此，我们可以简单地向这些区域写入新代码，并在EL1的上下文中自由执行，因此绕过代码加载缓解。 我包括一个小PoC，演示这个问题，在这里。
**Mitigation #3 – 绕过EL1内存控制**
正如我们刚刚在上一节中看到的，RKP的某些目标需要的内存控制不仅在阶段2翻译中实施，而且还直接在EL1使用的阶段1翻译中实施。例如，RKP旨在确保除内核代码之外的所有页面都标记为PXN。这些目标要求RKP对阶段1翻译表的内容具有某种形式的控制。
那么RKP究竟如何保证这些类型的保证？这是通过使用组合的方法;首先，阶段1翻译表被放置在阶段2翻译表中被标记为只读的区域中。这实际上不允许EL1代码直接修改转换表本身。其次，内核被检测（一种半虚拟化的形式），以使其意识到RKP的存在。执行该仪器，使得对在阶段1翻译过程（PGD，PMD或PTE）中使用的数据结构的每个写入操作将改为调用RKP命令，通知它请求的改变。
将这两种防御结合在一起，我们得出的结论是，对阶段1翻译表的所有修改必须通过RKP，这反过来可以确保它们不违反其任何安全目标。
虽然这些规则确实防止了阶段1翻译表的当前内容的修改，但是它们不防止攻击者使用存储器管理控制寄存器来规避这些保护。
例如，攻击者可以尝试直接修改TTBR1_EL1的值，将其指向任意（且不受保护）的内存地址。
显然，RKP不允许这样的操作。 为了允许管理程序处理这种情况，可以利用“管理程序配置寄存器”（HCR）。
回想一下，HCR允许管理程序不允许在EL1下执行某些操作。 可以捕获的一种这样的操作是修改EL1存储器管理控制寄存器。
在Exynos设备上的RKP的情况下，虽然它没有设置HCR_EL2.TRVM（即它允许对存储器控制寄存器的所有读访问），但它确实设置了HCR_EL2.TVM，允许它捕获对这些寄存器的写访问。
因此，虽然我们已经确定RKP正确地捕获对控制寄存器的写访问，但这仍然不能保证它们保持受保护。 这实际上是一个微妙的情况 –
Linux内核需要一些访问许多这些寄存器，以执行常规操作。
这意味着虽然某些访问可以被RKP拒绝，但是在允许其继续之前，需要仔细检查其他操作，以确保它们不违反RKP的安全保证。
再次，我们需要反向工程RKP的代码来评估情况。
正如我们可以看到的，尝试修改翻译表本身的位置，导致RKP正确地验证整个翻译表，确保它遵循允许的第1阶段翻译策略。
相比之下，有几个关键的内存控制寄存器，当时，它们不被RKP截获 – TCR_EL1和SCTLR_EL1！
在ARM参考手册中检查这些寄存器揭示了它们都可以对阶段1翻译过程具有深远的影响。
首先，EL1的系统控制寄存器（SCTLR_EL1）对EL1中的系统（包括存储器系统）提供顶级控制。
在我们的场景中一个至关重要的位是SCTLR_EL1.M位。
该位表示用于EL0和EL1中的级1转换的MMU的状态。 因此，只要取消设置此位，攻击者就可以禁用MMU进行阶段1转换。
一旦未置位，EL1中的所有存储器转换都直接映射到IPA，但更重要的是 –
这些存储器转换没有启用任何访问权限检查，有效地使所有存储器范围在阶段1转换中被视为RWX。
这反过来绕过了几个RKP的保证，例如确保只有内核的文本没有标记为PXN。
至于EL1的翻译控制寄存器（TCR_EL1），它的效果略微更微妙。 不是完全禁用阶段1翻译的MMU，该寄存器控制执行翻译的方式。
事实上，更仔细地观察这个寄存器，发现攻击者可以利用它以规避RKP第1阶段保护的某些关键方法。
例如，取决于系统在其下操作的转换颗粒，AARCH64存储器转换表可以采取不同的格式。 通常，AARCH64 Linux内核使用4KB的转换粒度。
这个事实在RKP中被承认。
例如，当EL1中的代码改变转换表的值（例如，TTBR1_EL1）时，RKP必须在阶段2转换中保护该PGD，以便确保EL1不能获得对它的访问。
确实，颠倒RKP中的相应代码揭示了它只是：
然而，如我们在上面的图片中可以看到的，阶段2保护仅在4KB区域（单页）上执行。 这是因为当使用4KB转换颗粒时，转换机制具有4KB的转换表大小。
然而，这是我们作为攻击者进入的地方。如果我们通过修改TCR_EL1.TG0和TCR_EL1.TG1来将翻译颗粒的值改为64KB呢？
在这种情况下，翻译机制的翻译表现在也将是64KB，而不是在以前的制度下的4KB。
由于RKP在保护转换表时使用硬编码值4KB，底部60KB保持不受RKP保护，允许EL1中的攻击者自由修改它以便指向任何IPA，更重要的是具有任何访问权限，
UXN / PXN值。
最后，应该再次注意到，虽然访问这些寄存器的小工具在内核的映像中并不丰富，但是它们存在于Exynos设备上的嵌入式RKP二进制文件中。
因此，我们可以简单地在EL1中执行这些小工具，以修改上面的寄存器。 我写了一个小PoC，通过禁用阶段1 MMU在EL1中演示此问题。
**Mitigation #4 – 访问阶段2未映射内存**
除了操作系统的存储器之外，存在可能包含不应当由在EL0和EL1中运行的代码访问的潜在敏感信息的若干其它存储器区域。例如，SoC上的外设可以将其固件存储在“正常世界”中，在物理存储器范围中，Android应该从不能访问它。
为了实施这样的保护，RKP显式地从阶段2转换表中取消映射几个存储器范围。通过这样做，任何尝试访问EL0或EL1中的这些PA范围将导致翻译错误，从而崩溃内核并重新启动设备。
此外，RKP自己的内存范围也应该使得较小特权代码不可访问。这是至关重要的，以便保护RKP免受EL0和EL1的修改，但也用于保护在RKP中处理的敏感信息（例如“cfprop”键）。实际上，启动后，RKP显式地取消映射它自己的内存范围，以防止这种访问：
不可否认，阶段2翻译表本身被放置在从阶段2翻译表未映射的非常区域内，因此确保EL1中的代码不能修改它。
然而，也许我们可以找到另一种方法来控制阶段2的映射，但利用RKP本身。
例如，如我们之前所见，某些操作（如设置TTBR1_EL1）会导致对阶段2转换表的更改。 组合RKP二进制，我们遇到一个这样的操作，如下：
    __int64 rkp_set_init_page_ro(unsigned args* args_buffer)
    {
     unsigned long page_pa = rkp_get_pa(args_buffer->arg0);
     if ( page_pa = rkp_get_pa(etext) )
     {
       if ( !rkp_s2_page_change_permission(page_pa, 128, 0, 0) )
         return rkp_debug_log("Cred: Unable to set permission for init cred", 0LL, 0LL, 0LL);
     }
     else
     {
       rkp_debug_log("Good init CRED is within RO range", 0LL, 0LL, 0LL);
     }
     rkp_debug_log("init cred page", 0LL, 0LL, 0LL);
     return rkp_set_pgt_bitmap(page_pa, 0);
    }
正如我们所看到的，这个命令从EL1接收一个指针，验证它不在内核的文本段内，如果是这样，继续调用rkp_s2_page_change_permission，以便在阶段2翻译表中修改这个范围的访问权限。
深入了解函数揭示了这组参数用于将区域表示为只读和XN。
但是，如果我们要提供一个驻留在当前没有映射到stage 2翻译的地方的页面，例如RKP自己的内存范围呢？
好吧，在这种情况下，rkp_s2_page_change_permission将很乐意为给定页面创建一个翻译条目，有效地映射到以前未映射的区域！
这允许我们从EL1重新映射任何阶段2未映射区域（尽管为只读和XN）。
我写了一个小PoC，通过阶段2重新映射RKP的物理地址范围并从EL1读取它来演示该问题。
**设计改进RKP**
在看到这篇博文中的一些具体问题后，强调了RKP的不同防御机制如何被攻击者颠覆，让我们思考一下，考虑一些设计选择，以加强RKP的安全态势，防止未来的攻击。
首先，Exynos设备上的RKP当前正由EL1代码引导。这与Qualcomm设备上使用的模型形成了对比，EL2代码由引导加载程序进行验证，随后由EL3引导。理想情况下，我认为Exynos也应该采用在高通设备上使用的相同型号。
以此顺序执行引导会自动修复其他相关的安全问题，例如在内核文本段中存在RKP的二进制文件。正如我们所看到的，这个看似无害的事实在我们在本文中强调的几种情况下对于攻击者是非常有用的。此外，它消除了其他风险，例如攻击者在引导过程中早期利用EL1内核，并利用该访问来颠覆EL2的初始化。
在临时改进中，RKP决定在初始化期间清零在EL1代码中驻留的RKP二进制。这种改进将在三星设备的下一个Nougat里程碑版本中推出，并解决攻击者利用二进制小工具的问题。然而，它没有解决关于潜在的早期利用EL1内核颠覆EL2的初始化的问题，这需要更广泛的修改。
第二，RKP的代码段目前在TTBR0_EL2中标记为可写和可执行。这与SCTLR_EL2.WXN未设置的事实相结合，允许攻击者使用EL2中的任何内存破坏原语，以便直接覆盖EL2代码段，从而更容易利用虚拟机管理程序。
虽然我没有选择在博客文章中包括这些问题，但我发现几个内存损坏，其中任何可以用于修改RKP上下文中的内存。将这两个事实结合在一起，我们可以得出结论，任何这些内存损坏都可以被攻击者用来直接修改RKP的代码本身，从而获得代码执行。
简单地设置SCTLR_EL2.WXN并将RKP的代码标记为只读不会阻止攻击者访问RKP，但是它可以利用这样的内存损坏更难以利用并且更加耗时。
第三，RKP应锁定所有存储器控制寄存器，除非它们绝对必须由Linux内核使用。这将防止滥用这些寄存器，这些寄存器可能会对系统的行为产生影响，并且这样做会违反RKP关于内核的假设。当这些寄存器必须由EL1修改时，RKP应该验证只有适当的位被访问。
RKP已经锁定了访问这个博客文章中提到的两个寄存器。这是朝着正确方向迈出的一个很好的一步，不幸的是，必须保留对这些寄存器中的一些寄存器的访问权，所以简单地撤销对它们的访问不是一个可行的解决方案。因此，防止对其它存储器控制寄存器的访问仍然是长期目标。
最后，应该有一些区别，第二阶段未映射区域，从来没有映射，和那些明确映射出来。这可以通过存储与明确未映射区域相对应的存储器范围并且不允许将导致在RKP内重新映射它们的任何修改来实现。虽然我强调的问题现在是固定的，实施这个额外的步骤将防止未来出现类似的问题。