### 优化后的文本

```c
void* kern_text_phys_end = rkp_get_pa(etext);
rkp_debug_log("DEFERRED INIT START", 0, 0, 0);
if (etext & 0x1FFFFF)
    rkp_debug_log("Kernel range is not aligned", 0, 0, 0);
if (!rkp_s2_range_change_permission(kern_text_phys_start, kern_text_phys_end, 128, 1, 1))
    rkp_debug_log("Failed to make Kernel range RO", 0, 0, 0);
...
}
```

上述代码中的函数调用用于修改给定物理地址（PA）范围的第二阶段访问权限。通过这些参数调用该函数将使指定的内存范围在第二阶段转换中被标记为只读。这意味着在引导EL1内核后不久，RKP确实锁定了对内核代码范围的写访问。

然而，这并不完全解决问题。RKP不仅需要防止内核代码被修改，还需要防止攻击者在EL1中创建新的可执行代码。虽然内核代码在第二阶段翻译表中被标记为只读，但这是否足以阻止创建新的可执行代码呢？

回顾一下，我们之前遇到过KASLR（内核地址空间布局随机化），其中内核的基地址（包括虚拟地址和相应的物理地址）被一个随机化的“滑动”值移动。由于Linux内核假设内核地址的虚拟到物理偏移是恒定的，因此相同的滑动值用于虚拟地址和物理地址。

这里有一个小问题：我们之前研究的地址范围，在第一阶段和第二阶段翻译表中标记为RWX（读写执行）的部分比内核的文本段大得多。这部分是为了在确定KASLR滑动值后允许将内核放置在该区域内的某处。然而，正如我们所见，在选择KASLR滑动值之后，RKP仅保护从`_text`到`_etext`的范围，即应用KASLR滑动值后包含内核文本的区域。

这给我们留下了两个大的未受保护区域：`[0x80000000, _text]` 和 `[_etext, 0x81400000]`，这些区域在第一阶段和第二阶段翻译表中仍标记为RWX！因此，我们可以简单地向这些区域写入新代码，并在EL1上下文中自由执行，从而绕过代码加载缓解措施。我附上了一个小的PoC来演示这个问题。

### 缓解措施 #3 – 绕过EL1内存控制

正如我们在上一节中看到的，RKP的某些目标需要在第一阶段和第二阶段翻译中实施内存控制。例如，RKP旨在确保除内核代码之外的所有页面都标记为PXN（特权执行从不）。为了实现这些目标，RKP采用了以下方法：

1. **只读区域**：第一阶段翻译表被放置在第二阶段翻译表中被标记为只读的区域。这实际上不允许EL1代码直接修改翻译表本身。
2. **内核检测**：内核被检测以使其意识到RKP的存在。这种检测使得对第一阶段翻译过程（PGD、PMD或PTE）使用的数据结构的每个写操作都会调用RKP命令，通知它请求的更改。

结合这两种防御机制，所有对第一阶段翻译表的修改必须通过RKP，从而确保它们不会违反任何安全目标。然而，这些规则不能防止攻击者使用内存管理控制寄存器来规避这些保护。例如，攻击者可以尝试直接修改TTBR1_EL1的值，将其指向任意且不受保护的内存地址。

显然，RKP不允许这样的操作。为了允许管理程序处理这种情况，可以利用“管理程序配置寄存器”（HCR）。HCR允许管理程序禁止在EL1下执行某些操作。可以捕获的一种操作是修改EL1内存管理控制寄存器。在Exynos设备上的RKP情况下，虽然它没有设置HCR_EL2.TRVM（即允许对内存控制寄存器的所有读访问），但它设置了HCR_EL2.TVM，允许它捕获对这些寄存器的写访问。

尽管RKP正确地捕获了对控制寄存器的写访问，但并不能保证它们保持受保护。这是因为Linux内核需要访问许多这些寄存器以执行常规操作。因此，虽然某些访问可以被RKP拒绝，但其他操作需要仔细检查，以确保它们不违反RKP的安全保证。

再次，我们需要反向工程RKP的代码来评估情况。尝试修改翻译表本身的位置会导致RKP验证整个翻译表，确保其遵循允许的第一阶段翻译策略。相比之下，有几个关键的内存控制寄存器在当时没有被RKP截获——TCR_EL1和SCTLR_EL1！

在ARM参考手册中检查这些寄存器揭示了它们都可以对第一阶段翻译过程产生深远影响。首先，EL1的系统控制寄存器（SCTLR_EL1）对EL1中的系统（包括内存系统）提供顶级控制。其中一个至关重要的位是SCTLR_EL1.M位，表示用于EL0和EL1中的第一级转换的MMU状态。只要取消设置此位，攻击者就可以禁用MMU进行第一阶段转换。一旦未置位，EL1中的所有内存转换都直接映射到IPA，更重要的是，这些内存转换没有启用任何访问权限检查，有效地使所有内存范围在第一阶段转换中被视为RWX。

至于EL1的翻译控制寄存器（TCR_EL1），它的效果更为微妙。不是完全禁用第一阶段转换的MMU，该寄存器控制执行翻译的方式。更仔细地观察这个寄存器，发现攻击者可以利用它以规避RKP第一阶段保护的某些关键方法。例如，取决于系统在其下操作的转换颗粒，AARCH64内存转换表可以采取不同的格式。通常，AARCH64 Linux内核使用4KB的转换粒度。这个事实在RKP中被承认。例如，当EL1中的代码改变转换表的值（例如，TTBR1_EL1）时，RKP必须在第二阶段转换中保护该PGD，以确保EL1不能获得对它的访问。

然而，如果我们通过修改TCR_EL1.TG0和TCR_EL1.TG1来将翻译颗粒的值改为64KB呢？在这种情况下，翻译机制的翻译表现在也将是64KB，而不是以前的4KB。由于RKP在保护转换表时使用硬编码值4KB，底部60KB保持不受RKP保护，允许EL1中的攻击者自由修改它以便指向任何IPA，更重要的是具有任何访问权限，如UXN/PXN值。

最后，应该再次注意到，虽然访问这些寄存器的小工具在内核映像中并不丰富，但它们存在于Exynos设备上的嵌入式RKP二进制文件中。因此，我们可以简单地在EL1中执行这些小工具，以修改上面的寄存器。我写了一个小PoC，通过禁用第一阶段MMU在EL1中演示此问题。

### 缓解措施 #4 – 访问第二阶段未映射内存

除了操作系统的内存之外，还存在若干其他内存区域，可能包含不应由在EL0和EL1中运行的代码访问的潜在敏感信息。例如，SoC上的外设可以将其固件存储在“正常世界”中，在物理内存范围中，Android应该无法访问它。

为了实施这样的保护，RKP显式地从第二阶段转换表中取消映射几个内存范围。通过这样做，任何尝试访问EL0或EL1中的这些PA范围将导致翻译错误，从而崩溃内核并重新启动设备。此外，RKP自己的内存范围也应该使较小特权代码不可访问。这是至关重要的，以保护RKP免受EL0和EL1的修改，同时也保护在RKP中处理的敏感信息（例如“cfprop”键）。实际上，启动后，RKP显式地取消映射它自己的内存范围，以防止这种访问。

不可否认，第二阶段翻译表本身被放置在从第二阶段翻译表未映射的非常区域内，从而确保EL1中的代码不能修改它。然而，也许我们可以找到另一种方法来控制第二阶段的映射，但利用RKP本身。例如，如我们之前所见，某些操作（如设置TTBR1_EL1）会导致对第二阶段转换表的更改。组合RKP二进制文件，我们遇到一个这样的操作，如下所示：

```c
__int64 rkp_set_init_page_ro(unsigned args* args_buffer)
{
    unsigned long page_pa = rkp_get_pa(args_buffer->arg0);
    if (page_pa == rkp_get_pa(etext)) {
        if (!rkp_s2_page_change_permission(page_pa, 128, 0, 0)) {
            return rkp_debug_log("Cred: Unable to set permission for init cred", 0LL, 0LL, 0LL);
        }
    } else {
        rkp_debug_log("Good init CRED is within RO range", 0LL, 0LL, 0LL);
    }
    rkp_debug_log("init cred page", 0LL, 0LL, 0LL);
    return rkp_set_pgt_bitmap(page_pa, 0);
}
```

正如我们所看到的，这个命令从EL1接收一个指针，验证它不在内核的文本段内，如果是这样，继续调用`rkp_s2_page_change_permission`，以便在第二阶段转换表中修改这个范围的访问权限。深入了解函数揭示了这组参数用于将区域表示为只读和XN。

但是，如果我们要提供一个驻留在当前没有映射到第二阶段翻译的地方的页面，例如RKP自己的内存范围呢？在这种情况下，`rkp_s2_page_change_permission`将很乐意为给定页面创建一个翻译条目，有效地映射到以前未映射的区域！这允许我们从EL1重新映射任何第二阶段未映射区域（尽管为只读和XN）。我写了一个小PoC，通过第二阶段重新映射RKP的物理地址范围并从EL1读取它来演示该问题。

### 设计改进RKP

在看到这篇博文中的一些具体问题后，强调了RKP的不同防御机制如何被攻击者颠覆，让我们思考一些设计选择，以加强RKP的安全态势，防止未来的攻击。

1. **引导顺序**：目前，Exynos设备上的RKP由EL1代码引导。这与Qualcomm设备上使用的模型形成对比，EL2代码由引导加载程序进行验证，随后由EL3引导。理想情况下，Exynos也应该采用在高通设备上使用的相同模型。以此顺序执行引导会自动修复其他相关的安全问题，例如在内核文本段中存在RKP的二进制文件。此外，它消除了其他风险，例如攻击者在引导过程中早期利用EL1内核，并利用该访问来颠覆EL2的初始化。

   在临时改进中，RKP决定在初始化期间清零在EL1代码中驻留的RKP二进制。这种改进将在三星设备的下一个Nougat里程碑版本中推出，并解决攻击者利用二进制小工具的问题。然而，它没有解决关于潜在的早期利用EL1内核颠覆EL2的初始化的问题，这需要更广泛的修改。

2. **代码段保护**：RKP的代码段目前在TTBR0_EL2中标记为可写和可执行。这与SCTLR_EL2.WXN未设置的事实相结合，允许攻击者使用EL2中的任何内存破坏原语，直接覆盖EL2代码段，从而更容易利用虚拟机管理程序。虽然我没有选择在博客文章中包括这些问题，但我发现几个内存损坏，其中任何可以用于修改RKP上下文中的内存。将这两个事实结合在一起，我们可以得出结论，任何这些内存损坏都可以被攻击者用来直接修改RKP的代码本身，从而获得代码执行。

   简单地设置SCTLR_EL2.WXN并将RKP的代码标记为只读不会阻止攻击者访问RKP，但它可以使这样的内存损坏更难以利用并且更加耗时。

3. **锁定内存控制寄存器**：RKP应锁定所有内存控制寄存器，除非它们绝对必须由Linux内核使用。这将防止滥用这些寄存器，这些寄存器可能会对系统的行为产生影响，并且这样做会违反RKP关于内核的假设。当这些寄存器必须由EL1修改时，RKP应该验证只有适当的位被访问。

   RKP已经锁定了访问本文中提到的两个寄存器。这是朝着正确方向迈出的一个很好的一步，不幸的是，必须保留对这些寄存器中的一些寄存器的访问权，所以简单地撤销对它们的访问不是一个可行的解决方案。因此，防止对其它内存控制寄存器的访问仍然是长期目标。

4. **区分未映射区域**：应该有一些区别，第二阶段未映射区域，从来没有映射，和那些明确映射出来。这可以通过存储与明确未映射区域相对应的内存范围并且不允许将导致在RKP内重新映射它们的任何修改来实现。虽然我强调的问题现在是固定的，实施这个额外的步骤将防止未来出现类似的问题。