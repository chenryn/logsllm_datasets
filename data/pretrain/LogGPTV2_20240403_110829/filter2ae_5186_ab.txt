**安全建议：** 对函数的逻辑流程、参数的设置与定义、修饰器的使用、修饰词的使用严格把控。
## 0x03条件竞争
#### 条件竞争的概念
条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。  
由于以太坊区块链是公开的，每个人都可以看到其他人未决交易的内容。这意味着，如果某个用户提交了一个有价值的解决方案，恶意用户可以窃取该解决方案并以较高的费用复制其交易，以抢占原始解决方案。
### ERC20中的条件竞争问题
在ERC20代币合约中有这样个函数——approve：  
该函数的主要功能是授权给第三方让其代替当前账户转账给其他账户，但是在这个函数当中却存在“事务顺序依赖性问题”，简要描述如下：  
假设有两个用户：用户A,用户B  
1.用户A通过调用approve函数允许用户B代其转账的数量为N（N>0）;  
2.经过一段时间后，用户A决定将N改为M（M>0），所以再次调用approve函数；  
3.用户B在第二次调用被矿工处理之前迅速调用transferFrom函数转账N数量的token；  
4.用户A对approve的第二次调用成功后，用户B便可再次获得M的转账额度，即用户B通过交易顺序攻击获得了N+M的转账额度。  
当然这个漏洞的利用难度还是有点高的！
### 条件竞争问题引起的讨论
对于“条件竞争”这个问题，曾引发的广泛的讨论：  
首先是Ethereum官方给出了一个建议：  
上面的主要意思是限制approve函数在将配额从N修改为M时，只能先从N修改为0，再从0修改为M，可以通过以下语句进行限制：  
随后就有人提出上面的这种安全建议可以解决“事务顺序依赖性”，但是如果加了require进行限制，那么合约就不符合ERC20标准规范了，具体详情可以参考下面的链接：  
之后openzeppelin也给出了另外一个安全建议：  
使用increaseApproval函数和decreaseApproval函数来代替approve函数，同时由于ERC20标准性问题合约当中也必须要有approve（没有添加require），具体代码如下：  
这里的increaseApprove的含义是在原有的“配额”基础上再增加“配额”  
这里的decreaseApprove的含义是在原有的“配额”基础上再减少“配额”  
笔者认为如果将approve以及increaseApprove、decreaseApprove三个函数放到一个合约当中，而且这三个函数都是public，approve函数当中也没有安全判断，那么如果用户仍然可以调用Approve进行“配额”划分，此时的increaseApprove和decreaseApprove和没存在基本上是一模一样的，在这种情况下合约仍然存在“事务顺序依赖性问题”。  
笔者在做智能合约审计的过程中发现有不少合约分别采用了以下三种对于“approve事务顺序依赖性”问题的处理方法：  
1.在approve当中增加Require进行安全判断  
例如：  
……..  
2.使用increasApprove和decreaseApprove函数替代approve函数，Approve函数保持ERC20标准，不增加require进行安全防范  
例如：  
…….  
3.使用increaseApprove和decreaseApprove函数替代Approve函数，Approve函数当中使用require进行安全防范。  
例如：  
……..  
以上的解决方案在众多的智能合约当中都可以见到，其中第一种、第二种居多，第三中偏少。  
对于“事务顺序依赖性”问题的解决方案可以从以下两个角度来看：  
**从安全角度看：**  
第一种、第三种都可以成功的解决“事务顺序依赖性”问题，而第二种仍然无法有效的解决“事务顺序依赖性”问题。  
**从ERC20标准来看：**  
第一种、第三种都违反了ERC20标准规范，第二种符合ERC20标准规范。  
**小思考：**  
加了“require”判断是为了安全，不加是为了标准，你会如何抉择？(虽然该类型的漏洞利用难度比较高)
## 0x04 总结
合约的开发者应当建立一套开发标准规范，同时尽可能的搜集网络上公开的现有的合约的漏洞的类型以及利用方法和安全补救方法，之后不断的完善自己的开发体系，而且在合约上线之前建议还是找专门的公司进行合约的安全审计，对合约做一次评估为好。
**道路千万条，安全第一条。  
编码不规范，亲人两行泪~**