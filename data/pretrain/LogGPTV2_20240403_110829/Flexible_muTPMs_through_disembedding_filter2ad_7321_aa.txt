title:Flexible muTPMs through disembedding
author:Klaus Kursawe and
Dries Schellekens
Flexible µTPMs through Disembedding
Klaus Kursawe
Philips Research Europe
High Tech Campus 34
5656 AE Eindhoven
The Netherlands
PI:EMAIL
Dries Schellekens
ESAT/SCD-COSIC and IBBT
Katholieke Universiteit Leuven
Kasteelpark Arenberg 10
3001 Heverlee, Belgium
PI:EMAIL
ABSTRACT
With the utilization of TPM-based trusted platforms in real
applications, and the subsequent adaption of the speciﬁca-
tion to the experience gained from such utilization, it in-
creasingly appears that the TPM architecture has some fun-
damental ﬂaws that result in more and more complex and
expensive hardware requirements. In this paper, we propose
a new architecture that resets the trust boundary to a much
smaller scale, thus allowing for much simpler and more ﬂex-
ible TPM implementations, without sacriﬁcing the security
gains from a classical TPM.
Categories and Subject Descriptors
C.2 [Computer Systems Organization]: Special-Purpose
and Application-Based Systems—Real-time and embedded
systems; K.6.5 [Management of Computing and In-
formation Systems]: Security and Protection
General Terms
Design, Measurement, Security
Keywords
Trusted Computing, secure coprocessor, Trusted Platform
Module, Mobile Trusted Module
1.
INTRODUCTION
Trusted Platform Modules (TPMs) were introduced by
the Trusted Computing Platform Alliance (TCPA) to pro-
vide a low cost, universal building block on which platforms
could build systems to provide a certain level of trust to
the platform. This is done primarily by providing trustwor-
thy measurement of the platform’s boot sequence, as well
as secure storage. Initially, TPMs were designed as separate
chip; later versions have become integrated more closely into
a platform’s chipset.
Over time, the TPM speciﬁcation has gained substantially
in scope and complexity to accommodate diﬀerent functional
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS’09, March 10-12, 2009, Sydney, NSW, Australia
Copyright 2009 ACM 978-1-60558-394-5/09/03 ...$5.00.
requirements. A study by Sadeghi et al. [12] has revealed
that some vendors already struggle with the corresponding
implementation complexity; also, for the more cost sensitive
mobile world, a diﬀerent speciﬁcation (the Mobile Trusted
Module or MTM [9]) was required to keep the complexity
to a manageable level.
In this, current TPM implementations have moved away
from the original philosophy of the TCPA, namely, a sim-
ple, easy to implement and verify module that serves as a
foundation for trust in the platform. In addition, thanks to
increasing interest and utilization of TPMs, more require-
ments for additional functionality are generated, e.g., sup-
port of multiple executions for virtualized machines [2], sup-
port for distributed protocols, etc.
In this paper, we investigate how TPM functionality can
be achieved with simpler hardware, and with greater ﬂexibil-
ity towards supporting specialized application demands. To
this end, we re-investigate which of the functionality needs
to be implemented inside the trust boundary (i.e., in the
trusted hardware), and which parts can safely be external-
ized onto the host platform. By externalizing large parts
of the TPM implementation, we arrive at a hardware base
that is smaller in size, more ﬂexible to use, and simpler to
implement and verify.
1.1 Related work
Chevallier-Mames et al. [4] propose a theoretical blueprint
of a ROM-less smart card called Externalized Microproces-
sor (XµP). All the executable code of the smart card is
stored in the terminal and program instructions are fetched
when needed. They propose a number of public key oriented
alternatives to authenticate the externalized code: veriﬁca-
tion per instruction, batch veriﬁcation with RSA screening,
and veriﬁcation of code sections. In the extended version of
the paper [5] MAC based variants are given.
In order to embed a TPM in a reconﬁgurable System-on-
Chip (SoC) design, Eisenbarth et al. [8] deﬁne a new FPGA
architecture that includes a minimal root of trust called Bit-
stream Trust Engine (BTE). This trust component records
the partial conﬁguration bitstreams that are loaded on the
reconﬁgurable logic, in Hardware Conﬁguration Registers
(HCRs), and limits access to the internal non-volatile mem-
ory (NVM) that stores the TPM’s persistent state. Their
solution allows ﬁeld update of the TPM bitstream.
Recently, Costan et al. [6] proposed the Trusted Execu-
tion Module (TEM) as a more ﬂexible alternative for TPMs.
The TEM can execute arbitrary general purpose applica-
tions, split in executable fragments called closures. The clo-
sures are encrypted with the TEM’s public encryption key,
116guaranteeing that only designated modules can run the ap-
plication. The idea to split an application in atomic tasks
is similar to our work. However, in this paper we focus on
the orthogonal issue of veriﬁed execution, which proves to
an external entity that a result is produced in a secure en-
vironment.
1.2 Structure of the paper
The paper is structured as follows. We start with a mo-
tivation for our alternative TPM architecture in Section 2.
Section 3 describes the µTPM scheme to disembed the TPM
ﬁrmware. In Section 4 we compare the security of our µTPM
proposal to that of traditional TPMs. Section 5 discusses
how to further minimize the µTPM’s memory footprint. We
end with a conclusion in Section 6.
2. TOWARDS AN ALTERNATIVE TPM AR-
CHITECTURE
With the work on trusted computing progressing over the
last ten years, the design of current TPM implementations
is starting to show the ﬁrst limitations. The primary prob-
lem is that the hardware is supporting both too much and
too little functionality. In attempting to accommodate all
requirements from diﬀerent users of the technology, the “one-
size-ﬁts-it-all” approach towards TPMs has lead to huge im-
plementations, making the hardware complex, hard to ver-
ify, and expensive. Each of those issues has already started
to cause problems – a diﬀerent speciﬁcation was required
for more cost-sensitive mobile devices [9], the complexity
has been diﬃcult to manage for some manufacturers [12],
and governments keep worrying about veriﬁability of the
security critical component [3]. With future speciﬁcations,
this problem is likely to get only bigger rather than smaller
– while few commands are likely to disappear, experience
with TPMs in real platforms has lead to new requirements
that future versions will have to accommodate (e.g., crypto-
graphic algorithm agility and advanced virtualization sup-
port).
We see that one way to approach these issues is to re-
deﬁne the trust boundaries of the TPM architecture. By
putting more functionality of a TPM outside of the trusted
hardware, we increase ﬂexibility (as outside mechanism can
easily be adapted, and usually have more resources at their
disposal than functionality implemented inside the TPM),
and reduce the size of the critical hardware components we
need to protect. To this end, we propose to remove the en-
tire TPM code base – i.e., the implementation of the TPM
functionality – outside of the secure hardware. As with other
TPM related storage, there is no security requirement to
store this data inside the trusted hardware, as long as the
TPM can authenticate it properly1. The TPM trust bound-
ary then only needs to incorporate the authentication key
as well as enough RAM memory to store the command code
during execution.
While this approach does require new mechanisms for
code authentication and attestation, the functionality of the
hardware can now be reduced to a very small number of
commands, and future extensions to the functionality can
be added without needing to modify the hardware speciﬁca-
1For protection of intellectual property, a producer may also
want to encrypt the data; for the TPM security functionality
this is not required though.
tion. More importantly though, externalizing the code from
the hardware adds a new degree of ﬂexibility that can han-
dle most of the limitations current TPM implementations
face:
Veriﬁability. Given that the TPM executes security rele-
vant code, users (especially government related users)
do want assurance that the TPM is implemented prop-
erly. By separating code and hardware, the hardware
becomes substantially easier to verify, while it can be
assured that the code has not been modiﬁed for a
particular TPM; also, it is possible to separate code
and hardware implementation, allowing for alternative
implementations. If the standard proposes a generic
programming language – e.g., basing the TPM on a
JavaCard [7] – it is even possible for pure software ven-
dors or the open source community to provide diﬀerent
TPM implementations. In addition, users with special
security need can use their own, individual code.
Customizability. TPM functionality becomes easier to ex-
tend or to limit. Current TPMs suﬀer from the fact
that platform producers demand an increasing amount
of functionality, while TPM manufacturers want to de-
crease the implementation complexity. With external-
ized commands, each platform can supply the com-
mands needed for its particular operation, and omit
functionality designed for diﬀerent platforms; this even
allows very special purpose commands in the TPM,
or even freely programmable code. The only limit
here is that guarantees given by the TPM according
to the TCG speciﬁcation – e.g., the protection of cer-
tain keys – are never violated. This is assured by
having one manufacturer authenticate their (external)
ﬁrmware, and not allowing other processes to access
the resources of that implementation.
Upgrades. TPM code can easily be updated in the ﬁeld;
the real hardware does not carry any functionality any-
more, allowing to ﬁx implementation bugs, retire un-
safe protocols (such as SHA-1), or upgrading to newer
versions of the TPM speciﬁcation. To upgrade the
TPM code, the old code simply can be replaced by
(authenticated) new code.
It must be taken care of
though that the two versions cannot be mixed, as this
may cause unpredictable behavior.
Specialized TPM implementations. Current TPMs are
designed in a way that basically the same hardware
is used in high-end servers and low-end embedded de-
vices. In our proposed settings, low-end TPMs can im-
plement the minimal hardware necessary to run, while
high-end server TPMs can oﬀer more memory, com-
mand cache and faster process management hardware
to allow for rapid context switches.
It is also possi-
ble for very low-end devices to build a TPM that does
not have the resources for all commands in the TCG
standard, but supports the commands required for the
particular platform; while such a device can not claim
TCG compliance, it can reuse hardware components
and interface with TCG compliant software.
While the goal is to add ﬂexibility to and simplify the
hardware of the TPM functionality, one requirement for our
117architecture is to allow for a functionality similar to cur-
rent TPMs, i.e., the trust model and functionality of the
TPM speciﬁcation must be compatible with the new hard-
ware architecture. We extend the TPM requirements by
allowing the architecture to support parallel, independent
processes, i.e., it is possible to run several diﬀerent security
co-processors in one hardware block without interference.
This is relevant in the areas of virtualization, where one
hardware TPM needs to support a number of virtual ma-
chines, each of which needs its own virtual TPM, or for the
support of multiple TPMs in one platform acting on behalf
of diﬀerent stakeholders. The latter is for example proposed
in the MTM speciﬁcation, where separate logical TPMs are
proposed to protect the mobile operator, the service provider
and the end user, respectively. Allowing diﬀerent logical
TPMs with diﬀerent code bases takes this approach further,
even allowing individual applications (e.g., a banking appli-
cation) to have a dedicated, specialized trusted module.
As with classical TPMs, performance is not a priority –
TPMs are not meant to work as cryptographic accelerators,
but as slow and reliable building blocks. Nevertheless, the
rather small communication bandwidth of current TPMs
makes communicating large code segments a relatively inef-
ﬁcient operation. We would argue, though, that this is not
a real problem; most frequently used commands are rather
simple, and thus have relatively short implementations – in
the open source TPM emulator [14], most commands can
be implemented in few lines of C-code – with the notable
exception of the DAA implementation, which, however, is
so far not used in any real setting. As TPMs were never
meant to perform fast, the additional delay is usually toler-
able. An approach to speed up the scheme is to allow for a
library of basic functions – e.g., the hash function – to be
either pre-installed, or loaded into the TPM at startup and
cached for future use.
3. THE µTPM ARCHITECTURE
We propose a new TPM architecture called µTPM which
builds upon the XµP concept [4] and the BTE proposal [8]
mentioned in the introduction. As motivated above, the
ﬁrmware is stored outside the trust perimeter of the µTPM
and authenticated on a command granularity. We deﬁne a
hardware root of trust that measures and reports the code
running in the µTPM environment and controls access to
the internal resources (e.g., NVM). Our solution can execute
multiple processes – either TPM instances or even arbitrary
general purpose code – in parallel.
3.1 Architecture overview
The µTPM requires similar hardware components like a
regular TPM (see Figure 1): a microcontroller (µC) possi-
bly supported by a cryptographic coprocessor, volatile mem-
ory (RAM) and multiple-time-programmable (MTP) non-
volatile memory (NVM). However, the major diﬀerence is
the lack of read-only memory (ROM). For current TPMs,
the ROM contains the ﬁrmware that implements the ﬁxed
functionality deﬁned by the TCG speciﬁcations2.
We deﬁne a new trust anchor called Firmware Trust En-
gine (FTE). This component deals with the ﬁrmware exter-
2The TCG speciﬁes an optional TPM FieldUpgrade com-
mand to update the ﬁrmware. This implies that the
ﬁrmware can be stored (partially) in reprogrammable NVM.
Figure 1: µTPM architecture. The Firmware Trust
Engine (FTE) controls the processes running on the
microcontroller (µC): it stores the ﬁrmware iden-
tiﬁer C for each process (identiﬁed by a process
identiﬁer pID) in a Firmware Conﬁguration Regis-
ter (FCR), authenticates externalized code (using
the key kAuth) and controls access to the non-volatile
memory. The unique Hardware Endorsement Key
(HEK) is certiﬁed by the µTPM manufacturer and
signs the content of the FCR during remote attesta-
tion. The IO and XIO interface are used to transfer
data and code respectively.
nalization and manages the multiple execution contexts. It
plays the role of the TCG roots of trust inside the µTPM,
namely:
• Root of Trust for Storage (RTS) by providing shielded
locations to store for instance key material (see Sec-
tion 3.2);