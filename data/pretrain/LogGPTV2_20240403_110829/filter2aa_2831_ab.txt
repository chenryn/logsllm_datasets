# ATL - The Choice for Servers

## Table of Contents
1. Basic Templates
2. A Simple Template Example
3. Template Classes
4. Native Compiler Directives
5. The #IMPORT Directive
6. Namespace Declarations
7. Smart Interface Pointers
8. Smart Pointer Classes
9. Watch Out for Destructors
10. Smart Pointer Error Handling
11. How the #IMPORT Directive Works
12. Raw and Wrapper Methods
13. Summary

---

## Chapter 16: Other Topics

### Errors
- **Information Code**
- **Facility Code**
- **Customer Code Flag and Reserved Bits**
- **Severity Code**
- **Looking Up HRESULTS**
- **SCODES**
- **Displaying Error Messages**
- **Using FormatMessage**

### Aggregation and Containment
- **Building a COM Object with MFC**
- **Adding Code for the Nested Classes**
- **Accessing the Nested Class**

### Appendix: COM Error Handling
- **Sources of Information**
- **Common Error Messages**
- **DCOM Errors**
- **Troubleshooting Tips**
  - Get It Working Locally
  - Be Sure You Can Connect
  - Try Using a TCP/IP Address
  - Use TRACERT
  - Windows 95/98 Systems Will Not Launch Servers
  - Security is Tough
  - Using the OLE/COM Object Viewer

### Index

---

## Preface

The primary goal of this book is to make COM (Component Object Model) and DCOM (Distributed Component Object Model) comprehensible to the average developer. If you have attempted to learn COM and found its complexity overwhelming, or if you have worked with COM code and felt it required advanced knowledge, this book is designed to simplify these concepts.

To achieve this, the book takes a different approach compared to other resources:
1. **Clarity Over Complexity**: The fundamental principles of COM are straightforward, and this book presents them in a clear, easy-to-understand manner.
2. **Simple Examples**: Each chapter focuses on one concept at a time, using the simplest possible examples. For instance, Chapter 2 demonstrates that a fully functional COM client can be created with just 10 lines of code.
3. **Concise Content**: This book is not excessively long, allowing you to read through all the examples and concepts in a short period. By the end, you will have a solid understanding of COM and DCOM.

### Overview of Chapters
- **Chapter 1**: Introduction to COM vocabulary and concepts.
- **Chapter 2**: Simple, working COM client example.
- **Chapter 3**: Creating a complete COM server with the ATL wizard.
- **Chapter 4**: Recap and additional error-handling techniques.
- **Chapter 5**: Exploring the code generated by the ATL wizard.
- **Chapter 6**: Detailed interaction between client and server.
- **Chapter 7**: Introduction to MIDL and IDL language.
- **Chapter 8**: Using MIDL to pass various parameters.
- **Chapter 9**: Accessing COM servers from VB and other languages.
- **Chapter 10**: Clarification of COM threading models.
- **Chapter 11**: Link between COM and the registry.
- **Chapter 12**: Demystifying COM callbacks.
- **Chapter 13**: Explanation of connection points.
- **Chapter 14**: Network usage and security topics.
- **Chapter 15**: Further clarification on ATL, smart pointers, and import libraries.
- **Chapter 16**: Additional information on COM error codes and MFC support.
- **Error Appendix**: Debugging strategies for COM applications.

### Recommended Reading
Read the book twice. The first reading will help you grasp individual concepts and techniques, while the second will allow you to integrate these into a cohesive understanding. After completing the book, you will find COM and DCOM much more accessible and easier to use in your daily work.

For more information and updates, visit our website: [http://www.iftech.com/dcom](http://www.iftech.com/dcom)

---

## Chapter 1: The Basics of COM

### Understanding COM
COM can initially seem intimidating due to its unique vocabulary and new concepts. To master these, it helps to compare COM objects with C++ objects, highlighting similarities and differences. This comparison provides a comfortable starting point for understanding COM's fundamental concepts.

#### Classes and Objects
Consider a simple C++ class `xxx` with member functions `MethodA`, `MethodB`, and `MethodC`. The class declaration is as follows:

```cpp
class xxx {
public:
    int MethodA(int a);
    int MethodB(float b);
    float MethodC(float c);
};
```

To use this class, you create an instance of the object, either as a variable or dynamically using the `new` statement. For example:

```cpp
xxx *px;            // pointer to xxx class
px = new xxx;       // create object on heap
px->MethodA(1);     // call method
delete px;          // free object
```

COM follows a similar object-oriented model, with classes, member functions, and instantiations. However, instead of using `new` and `delete`, COM uses the COM API to create and destroy objects. Here’s an example in pseudo-COM code:

```cpp
ixx *pi;                     // pointer to COM interface
CoCreateInstance(,,,,&pi);   // create interface
pi->MethodA();               // call method
pi->Release();               // free interface
```

### Differences Between COM and C++
COM is not C++, and this distinction is necessary due to network considerations. Key differences include:
- **Process and Network Capabilities**: COM objects can run across processes or networks, while C++ objects run in the same process space.
- **Global Uniqueness**: COM objects must be unique globally, unlike C++ objects which are unique within a process.
- **Language Independence**: COM servers can be written in various languages and run on different operating systems.

### COM Vocabulary
Understanding the terminology is crucial. Here’s a comparison table:

| Concept         | Conventional (C++/OOP)                             | COM                                      |
|-----------------|----------------------------------------------------|------------------------------------------|
| Client          | A program that requests services from a server.     | A program that calls COM methods.        |
| Server          | A program that "serves" other programs.             | A program that makes COM objects available. |
| Interface       | None.                                              | A pointer to a group of functions.       |
| Class           | A data type defining methods and data.              | Definition of an object implementing interfaces. |
| Object          | An instance of a class.                            | An instance of a coclass.                |
| Marshaling      | None.                                              | Moving data between client and server.  |

### The Interface
In COM, an interface is a named collection of functions. It is a ghostlike entity that never has a concrete existence, similar to an abstract class but with specific rules and behaviors.

By following this structured and simplified approach, this book aims to make COM and DCOM accessible and understandable to all developers.