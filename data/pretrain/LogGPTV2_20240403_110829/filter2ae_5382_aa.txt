**作者：ze0r @360A-TEAM  
公众号：[360安全监测与响应中心](https://mp.weixin.qq.com/s/ogKCo-Jp8vc7otXyu6fTig
"360安全监测与响应中心")  
相关阅读：[[下篇]从补丁diff到EXP--CVE-2018-8453漏洞分析与利用](https://paper.seebug.org/798/
"\[下篇\]从补丁diff到EXP--CVE-2018-8453漏洞分析与利用")**
在本篇文章中，我们将对CVE-2018-8453（Windows win32kfull.sys内核提权漏洞）进行深入分析。
因国内外各大安全公司和平台主观和客观上的各种原因，该漏洞的技术分析一直模糊不清，甚至带有故意的错误，为还原真实，我们以漏洞为主，卡巴斯基的分析文章为辅进行分析。现将分析过程和利用对外分享发布，以供学习参考。
### 前言
CVE-2018-8453漏洞是一个Windows内核提权漏洞，由卡巴斯基官方于野外发现用于APT中攻击中东地区国家。在微软发布了更新补丁后，卡巴斯基也于第二天发布了关于这个漏洞的更加详细的分析，但仍然讳莫如深，以及多个故意错误（可能是因为卡巴斯基担心该漏洞可能被作为Nday利用）。此外，国内两大安全平台关于该漏洞的描述文章，也为谷歌直接翻译。故意错误加上翻译错误，让人无法清楚的知道该漏洞的原理和利用。
为了还原真实，我们以直面漏洞为主、卡巴分析文章为辅的方式对该漏洞进行分析和学习。
相关链接：
微软官方的补丁和漏洞简介可以看链接：
卡巴斯基的分析文章链接：
### 正文内容
下载该漏洞的单独补丁用bindiff与历史补丁进行查看，可发现主要变化如下(新旧变化主要用上一个补丁日的win32k.sys来比较，下同)：
![
](https://images.seebug.org/content/images/2019/01/d4d3aad0-db68-410c-a5a9-864329953b72.png-w331s)
在底部，看到颜色差异比较大的就是一个叫NtUserSetWindowFNID的函数，比较一下：
![
](https://images.seebug.org/content/images/2019/01/bd8f3368-f1d0-4814-aa7b-93cc8d94cbc9.png-w331s)
![
](https://images.seebug.org/content/images/2019/01/dcc1be0e-d0b4-4e63-9c44-3308092579f6.png-w331s)
可见判断流程中，多了一个IsWindowBeingDestroyed函数调用：
![
](https://images.seebug.org/content/images/2019/01/8a399898-3a2c-49d7-9301-d1cff056550b.png-w331s)
也就是说，主要在设置改变窗口的一个成员时，多了一个检查。那么就意味着，本漏洞的原因是设置成员时，没有判断某成员造成，从名字上看，这个成员为FNID。
那么，问题在于，FNID这个成员没有检查又会造成什么影响呢？我们查看一下这个成员的作用，在win2000的部分源代码中，我们可以搜索FNID来探明FNID是什么意义。
![
](https://images.seebug.org/content/images/2019/01/02e615bc-b1bc-44b2-b1e0-97398464fb8f.jpg-w331s)
这个FNID成员是用来标识本窗口是一个什么样的窗口，比如是一个按钮还是一个编辑框，这一点从文章里也可以印证。而从补丁修改后新加的函数名IsWindowBeingDestroyed来看，这里是要判断本窗口是否已经准备删除了。从文章中说的查看ReactOS代码，可知道准备删除标记就是添加上FNID_FREE（0x8000）的标记。关键在于，不检查FREE之后的窗口是如何触发漏洞呢？
通过卡巴的文章，我们整理出来大致利用思路：代码先HOOK KernelCallbackTable->产生一个主窗口->在USER32!
**fnINLPCREATESTRUCT回调中去查找并取消掉sysShadow窗口->以主窗口作为父窗口产生一个滚动条窗口SrollBar->发送WM_LBUTTONDOWN消息->系统处理消息时会发生USER32!**fnDWORD回调，在USER32!
**fnDWORD回调中销毁主窗口->这将导致主窗口销毁从而产生USER32!**fnNCDESTROY回调->USER32!__fnNCDESTROY回调中调用NtUserSetWindowFNID更改掉FNID->至此文章中开始语焉不详，文章中说重用了sysShadow，但我们根本理解不了如何发生得重用。所以需要我们自己来动手实现。
首先我们来实现漏洞函数得调用，仔细观察：
![
](https://images.seebug.org/content/images/2019/01/9b5b067d-eab0-43d4-9b69-1c2ea3fbdb7b.png-w331s)
可以看到，要想成功更改FNID，需要满足几个条件，我们不可能只设置为0x4000（这个只是打个标记，不产生实际作用）。至于新FNID得值，我们可以按照文章中说的直接设置为0x2a1即可。而对于后面的条件，要求我们要设置的窗口原来不能有FNID（除0x4000和0x8000外，但这两个标记我们打了没用）。这里经过多次测试，发现三种情况会时FNID为空：一种是在任意类型窗口刚建立时，这时系统在用户态主动调用NtUserSetWindowFNID来设置FNID（user32.dll中自动实现），而此时，如果没有设置完FNID，则窗口还没有设置消息处理函数，也就没有处理消息的能力。而文章中提到了WM_LBUTTONDOWN消息，则可以肯定是在Scrollbar窗口完全创建之后。故此种情况不行。二种是用户注册的窗口类所产生的窗口，此窗口一直到销毁，都没有设置FNID。第三种就是文章中所说的sysShadow窗口，此窗口的作用只是产生阴影效果，但是确实FNID为空。也正是由于这个特性，本人被文章误导很长时间。后来请教leeqwind才知道，根本不是重用的sysShadow，而是SBTrack结构。另外也可以看文章截图：
![
](https://images.seebug.org/content/images/2019/01/0b80a6e3-6fb0-497f-8c9a-82dc9707b06b.png-w331s)
由于本人注意力全放在了文章触发中，还未关注利用，没注意后面的内容，其实这里已经泄露了真相（深刻检讨反思！）。从截图的红框中可看到，标记是Usst，分配者又是win32k!xxxSBTrackInit。所以很明显可知要被重用的是SBTrack。
文章中说明了需要在FNID设置为0x8000之后，再调用漏洞函数更改FNID。我们知道，一个窗口销毁的用户态接受到的最后消息是WM_NCDESTORY，在win32k中，这是在xxxFreeWindow函数中发送给窗口的：
![
](https://images.seebug.org/content/images/2019/01/21cd7e2a-cb0f-4095-ba4d-cde1fa5d5615.jpg-w331s)
可以看到在106行发送了0x82（WM_NCDESTORY）号消息，所以我们需要在106行之后想办法回到用户态。但同时有另外一个问题，就是注意第134行，这行把FNID打上0x4000的标记，而文章中完全是0x8000直接变成了0x82a1，没有0x4000的标记，所以我们如果再WM_NCDESTORY消息中去更改FNID，那么确实可以马上更改掉FNID，但是这时窗口还并没有打上0x8000的标记（到136行中才被标记），这与文章明显不符。所以文中所说的在USER32!__fnNCDESTROY中去调用NtUserSetWindowFNID更改FNID的做法为故意错误。
![
](https://images.seebug.org/content/images/2019/01/218960d5-c6df-4d07-ad2c-878b21cb54a9.png-w331s)
经过本人用pykd动态测试发现，窗口在426行的调用后，窗口句柄将不存在，NtUserSetWindowFNID函数的ValidateHwnd函数将返回0从而直接跳过FNID设置。也就是我们想要实现文章中直接将0x8000设置成0x82a1的效果，需要我们在134行到426行之间，找到一个回到用户态的调用。
这里插播一点题外话。本人一开始是在WINDOWS7的win32k.sys做分析，结果搜索很长时间未能成功找到，直到某天twitter上有人提到该漏洞在win8.1之后可利用，在看了win10的win32kfull.sys后恍然大悟，教训深刻！
回到正题，之后我们可以看到这里：
![
](https://images.seebug.org/content/images/2019/01/4b10f5c5-118e-47ec-a292-46918bb3614b.png-w331s)
上面这张截图为win10下的win32kfull.sys的IDA分析结果。我们可以看到，在256行改为了0x8000后，在266行有一个xxxClientFreeWindowClassExtraBytes函数调用：
![
](https://images.seebug.org/content/images/2019/01/3e4453ca-c920-4d1c-8c34-879757aff0ce.png-w331s)
该函数中很直接的调用了KeUserModeCallback！毫无条件的直接回到了用户态。所以我们只要符合进入到xxxClientFreeWindowClassExtraBytes函数的条件即可。仔细查看代码，发现258行的判断，主要是判断窗口是否具有扩展字节（正如xxxClientFreeWindowClassExtraBytes函数名字所暗示的那样），有的话则调用xxxClientFreeWindowClassExtraBytes函数释放掉，由于扩展字节是分配在用户空间中的，所以该函数返回到用户态让用户态代码去释放掉（至少要通知）。所以只要我们在注册窗口类的时候，cbWndExtra成员不为0即可。在窗口销毁时，就会在设置了0x8000之后，又回到了用户态。当窗口以0x8000回到用户态后，我们更改FNID为0x82a1，返回到内核态后，xxxFreeWindow继续往后执行。
回到xxxFreeWindow函数：
![
](https://images.seebug.org/content/images/2019/01/0bb62233-cef1-4dc5-b4ec-593b053d4ca5.png-w331s)
其中这里，可以看到代码判断了FNID的值，从而决定要不要调用USER32!