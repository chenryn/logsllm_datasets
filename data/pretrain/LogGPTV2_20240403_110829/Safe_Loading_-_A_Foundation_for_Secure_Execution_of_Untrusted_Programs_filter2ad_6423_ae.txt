veriﬁed targets.
The secure loader only implements bare-bones functional-
ity needed to load and relocate applications on a single plat-
form. No inter-platform operability, no debugging features,
no runtime-conﬁgurable settings, and no runtime-changeable
settings are implemented. This bare bone paradigm drasti-
cally reduces the total number of lines of code needed to
implement the loader functionality.
The standard loader executes extra checks that disable
some features for privileged applications. These checks can
contain bugs [17], [33], [34] that enable an arbitrary user
to execute code as privileged user. These features are not
available in the secure loader and cannot be exploited.
The combination of a secure loader with a sandbox
offers several advantages. The secure loader enables a clean
foundation to implementing a secure sandbox, unmodiﬁed
binary applications are safely executed in the unprivileged
application domain. Any requests for system calls, indirect
control ﬂow transfers, or functionality of the dynamic loader
trap into the sandbox domain. The application domain has
no privileges to map executable code. The sandbox ensures
that no untrusted application code is executed outside of the
sandbox. Any calls into the loader trap into handler functions
in the privileged sandbox domain where the parameters can
be checked and veriﬁed.
D. Limitations of the current implementation
TRuE protects from all code injection based attacks (on
the stack and on the heap). Regular code sections of the
application are mapped read-only and only translated appli-
cation code in the code cache is executable. Other memory
pages of the application are never mapped executable.
The shadow stack protects the return instruction pointer
using a privileged shadow stack in the sandbox domain. This
guard protects from all stack-oriented attacks (return to libc
attacks and return-oriented programming [44]).
A limitation of the current approach is that jump-oriented
programming attacks [10] and data-only attacks (application
data is over-written using a malicious write to a memory
page) are still possible. Jump-oriented attacks and data-only
attacks can redirect the control ﬂow to alternate locations
in the code but the attacks can never introduce new code or
break out of the sandbox. Only translated code is executable
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:47:59 UTC from IEEE Xplore.  Restrictions apply. 
and all outgoing edges at the end of a basic block in the code
cache are either patched to other translated basic blocks or
trigger a fallback into the sandbox to translate previously
untranslated code.
Similar to libdetox [37] we can use a system call policy
to ensure that the application code cannot break out of the
sandbox and to protect from jump-oriented attacks and data
attacks at the more coarse-grained system-call level. An
advantage of moving the loader into the sandbox domain
is that we do not need to consider the system calls needed
by the loader in our application policy. The policy can
be reduced to the functionality actually needed by the
application and is not polluted by system calls that are
needed for loader functionality.
A second limitation that is shared with libdetox is the
inability to securely support self-modifying code (i.e., JIT
compilers). A JIT compiler can generate arbitrary code.
TRuE uses a privileged sandbox domain to handle code
generation and module loading. If an application contains
a JIT compiler then it is placed in the untrusted application
domain. The application domain is not allowed to generate
new code. If the application domain was allowed to generate
new code then a JIT compiler would not be distinguishable
from a code injection attack. A possible solution for appli-
cations that need a JIT compiler is to either promote the JIT
compiler to the sandbox domain or to deﬁne a secure API
that is used by the JIT compiler in the application domain to
notify the sandbox domain of newly generated correct code.
This extension is a topic for future work.
VIII. RELATED WORK
This section presents information about related work.
Many different sandboxing techniques already exist. Most
dynamic techniques use either an LD_PRELOAD based
approach or rely on trusted application code to initialize the
sandbox. Policy-based system call authorization checks all
system calls and system call parameters of an application.
Policy-based system call authorization can be used as an
extension of sandboxing or by itself.
Sandboxing uses binary translation to encapsulate run-
ning code [11], [30], [32], [45]. Libdetox [37], Vx32 [22],
Strata [43], [42], and program shepherding [29] implement
software-based fault isolation using binary translation. Ad-
ditional guards like non-executable memory regions, stack
protection, and system call policies can be added during the
dynamic translation of the machine code.
The basic SFI framework must be fast, extensible, and
secure. Many different instrumentation frameworks exist and
one must be aware of the limitations that several optimiza-
tions pose to security.
Policy-based system call authorization stops the applica-
tion when system calls are executed. The arguments and
the location of the system call are then matched against a
given policy. The program is terminated if a policy violation
n
o
i
t
a
l
s
n
a
r
t
t
n
e
r
a
p
s
n
a
r
t
d
e
d
e
e
n
e
l
u
d
o
m
-
l
e
n
r
e
k
)
c
b
i
l
2
t
e
r
(
n
o
i
t
c
e
t
o
r
p
y
t
i
r
g
e
t
n
i
w
o
ﬂ
t
i
o
l
p
x
e
d
e
d
e
e
n
s
e
g
n
a
h
c
n
o
i
t
a
c
i
l
p
p
a
n
o
i
t
i
s
o
p
r
e
t
n
i
s
e
i
c
i
l
o
p
a
d
e
s
u
d
e
t
r
o
p
p
u
s
A
S
I
?
?
S
x
x
l
l
u
F
l
l
a
c
m
e
t
s
y
S
l
l
a
c
m
e
t
s
y
S
s
e
u
q
i
n
h
c
e
k
c
a
t
l
a
i
c
e
p
s
l
o
r
t
n
o
C
y
l
e
t
e
l
p
m
o
o
N
C
x x
x (x) x x
x (x) (x) (x) x x
c
?
o
N
1 x
1 x
1 x
1 x
Product/Feature T
TRuE
libdetox [37]
x
Vx32 [22]
Strata [43], [42]
x x
Prog. sheph. [29] 1 x (x)d x x (x)e (x) x x
3 x
x x
Janus [26]
AppArmor [6]f
3 x
x
SysTrace [39]
x
3 x
Switchblade [21] 3 x
3 x
Ostia [24]
2
NaCl [47]
PittSField [31]
2
CFI/XFI [1], [20] 2
4
StackGuard [16]
4
libverify [4]
4
Propolice [27]
PointGuard [14]
4
x
x
x x
x
x
x
x
x
x
x (x)
x (x)
x (x)
x (x)
x
x
x
x
x
x
x
x
g
s
d
r
a
u
g
-
e
f
a
s
g