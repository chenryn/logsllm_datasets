abort if mac,(y,  7) # S 
  t Dsk,,, (7) 
abort if P # b  V  valid(c)  = 0 
w  t select(c) 
U t w”2  modp 
r  t R  Z g  
U‘  t w r  mod p 
e t hzkp() 
s e x2e + r  mod q 
77  t P @   
77 e- 
t
~
~
p
w  t select(c) 
abort if  e # hzkp() 
Figure 3. D-ELG decryption protocol 
Here we assume that f outputs an element of (0, 1}21ql.  The 
values  U ,  a, y2,  T ,  pkdvc, plc,,,  and  t  are  saved  on  stable 
storage in  the device.  All  other values,  including U ,  b, z, 
21,  22, and  TO, are deleted from the device.  The values t 
and r should be backed up offline for use in disabling if the 
need arises. The value T  is the device’s “ticket” that it uses 
to access the service. 
5.2.2. Decryption protocol 
Figure  3 describes  the  protocol  by  which  the  device  de- 
crypts a ciphertext c generated using the device’s public key 
in an EICamal-like encryption scheme. The input provided 
to the device for this protocol  is the input password  n, the 
ciphertext c,  and all of the values saved on stable storage in 
The reader should  observe in Figure 3 that the device’s 
decryption  function  is  implemented jointly  by  dvc  and 
svr.  Moreover,   constitutes a noninteractive zero- 
knowledge proof  from svr  (the “prover”) to dvc (the “ver- 
ifier”) that svr  constructed its contribution  U correctly.  As 
before, P is a value that proves the device’s knowledge of  T 
to the server.  y is an encryption of c,  /3,  and p to securely 
transport  them to the server.  S is a message authentication 
code computed using a, to show the server that this request 
originated from the device. 
Decryption  via the  D-ELG protocol  is somewhat more 
costly  than  decryption in  the  underlying EICamal-like en- 
cryption  scheme.  As in  S-RSA, we recommend that  dvc 
compute /I while  awaiting  a response  from svr  in order to 
parallelize computation between the two. 
19 
5.2.3. Kev disabling 
Like  S-RSA, the  D-ELG protocol  also  supports  key  dis- 
abling. Assuming that the user backed up t and T before the 
device was stolen, the user can send t ,  T to the server. Upon 
recovering    t Dsksv, (T), the  server 
verifies that U  = hdsbl(t) and, if so, records T on a disabled 
list.  Subsequently, the  server should  refuse  to  respond  to 
any request containing the ticket  T .  We remind the reader 
that this requires the server to store T (or a hash of it) on a 
“blacklist”. Rather than storing T forever, though, the server 
can discard 7-  once there is no danger that pkdvc will be used 
subsequently (e.g., once the public key has been revoked). 
5.2.4. Choices for ElGamal-like encryption 
There are several possibilities for EIGamal-like encryption 
schemes that,  when  used  to  instantiate  the  description  of 
Figure 3, result in a protocol that provably satisfies goals I- 
IV.  That said, the precise  senses in which a particular  in- 
stance can  satisfy  goal  IV  deserve  some discussion.  The 
most natural  definition of security  for key disabling is that 
an  adversary  in  Ar)v({dvc, n o ) )  who  is  presented  with  a 
ciphertext c after  the  key  has been  disabled will  be unable 
to decrypt e.  A stronger definition for key disabling could 
require  that  c remain indecipherable even if  c were given 
to the adversary before  key disabling occurred, as long as c 
were not sent to svr before disabling. 
If  the  original  ElCamal  scheme is secure  against indif- 
ferent chosen ciphertext attacks [37], then  the protocol  of 
Figure 3 can be proven secure in the former sense when in- 
stantiated with original EIGamal.  However, the security  of 
ElCamal in  this  sense has  not  been  established,  and  is  an 
active area of research (e.g., see [34]). There are, however, 
EIGamal-like  encryption  schemes  that  suffice  to  achieve 
even the  latter, stronger security property,  such as the fol- 
lowing proposal from [39] called TDHI. In this scheme, q 
is a Ic-bit prime factor of p  - 1. Encryption of a message m 
proceeds as follows: 
E  ( m ) :  
+R  z q  
c1  t hl(yk mod p) @ m 
c2  t g k  m o d p  
a t R  z, 
.9/  +- h2() 
c 3  t ( g l ) k  modp 
cj t e + kc4 mod q 
c4 
h z k p (  )  
The tuple    is the ciphertext.  Above, hl 
outputs a value from (0, l)lmi, and hz  outputs an element 
of the subgroup of Zz generated by g. For example, this can 
be achieved by defining h2(z) = (h’(z))(P-’)/q  mod p for 
some other hash function h‘. Decryption takes the following 
form: 
valid(c):   t c 
w1  t g ” ( ~ 2 ) - ‘ ~  mod p 
9’ + h2() 
w2 t (g’)c5(c3)-c4 mod p 
return  (cq  = hzkp()) 
select(c):   t c 
return c2 
reveal(z,c):   t c 
return h l ( z )  @ c1 
A second proposal from [39], called TDH2, can also be 
used to instantiate our protocol and achieve the stronger ver- 
sion of goal IV. 
,--. Proof of security for S-RSA 
In  this section we provide a formal proof of security for 
the S-RSA system in the random oracle model. 
6.1. Definitions 
In  order to state and prove security of our protocol  for- 
mally, we must first state requirements for the security of a 
pseudorandom function, of an encryption scheme, of a sig- 
nature scheme, and of S-RSA. 
Pseudorandom  functions  A  pseudorandom  function 
family  is a  family  of  functions  fu  parameterized by  a  se- 
cret value  U ,  which has the following security property:  It 
is computationally infeasible to distinguish between an ora- 
cle for the fu function, where v  is chosen randomly, and an 
oracle for a perfectly random function (with the same input 
and output ranges).  See [20] for a formal definition. 
Security for  encryption  schemes  We  specify  adaptive 
chosen-ciphertext  security  [37]  for an  encryption  scheme 
& = (G,,,,  E ,  D). (For more detail, see [3, Property IND- 
CCA21.)  An  attacker  A  is  given  pk,  where  ( p k , s k )  t 
Genc(lA). A  is allowed to query  a decryption oracle that 
takes  a  ciphertext  as  input  and  returns  the  decryption  of 
that ciphertext (or I if the input is  not a valid ciphertext). 
At  some  point  A  generates  two  equal  length  strings  X O  
and  X1  and  sends  these  to  a  test  oracle,  which  chooses 
b  +-R  (0, 1}, and returns Y = E p k ( X b ) .  Then A contin- 
ues as before,  with  the one restriction that it cannot query 
the decryption oracle on Y. Finally  A outputs b’,  and suc- 
ceeds  if  b’  = b.  We  say  an  attacker A  (q,c)-breaks &  if 
the attacker makes q  queries to the decryption oracle, and 
2 .  Pr(A succeeds) - 1 2 E .  Note that this implies 
Pr(A guesses 0 I b = 0) - Pr(A guesses 0 I b = 1) 2 E. 
20 
Security  for  signature  schemes  We  specify  existential 
unforgeability versus chosen message attacks [21] for a sig- 
nature  scheme  S  =  (Gsigl S ,  V ) .  A  forger is  given p k ,  
where  (pk, s k )  t G,ig(lX), and tries  to  forge signatures 
with  respect  to p k .   It  is  allowed  to  query a signature ora- 
cle (with  respect  to  s k )  on messages of  its choice.  It suc- 
ceeds if after this it can output a valid forgery (m, a ) ,  where 
V,k(m, a )  = I, but nz  was not one of the messages signed 
by  the  signature oracle.  We  say  a  forger  (q,c)-breaks a 
scheme if  the  forger makes y  queries to  the  signature ora- 
cle, and succeeds with probability at least E. 
that disables the device's ticket 7. 
Let qdvc  be the number of start queries to the device. Let 
qsvr be the number of server serve queries. For Theorem 6.2, 
where we model h and f as random oracles, let qh and q f  be 
the number of queries to the respective random oracles. Let 
qo be the number of other oracle queries not counted above. 
Let Q  = (qdvc,  qsvr, qo, qh, 45). In a slight abuse of notation, 
k t  IQ1  = qdvc + qsvr  -t qo + qh + q f ,  i.e., the total  number 
of oracle queries.  We  say a forger (Q, €)-breaks S-RSA if 
it makes 
oracle queries (of the respective type and to the 
respective oracles) and succeeds with probability at least E. 
Security  for  S-RSA  Let  S-RSA[&,D] denote  an  S- 
RSA  system  based  on  an  encryption  scheme  &  and 
dictionary  2).  A  forger  is  given     where 
(,  )  t G R S A ( ~ ~ ) ,  
the  public data 
generated  by  the  initialization  procedure for  the  protocol, 
and  certain  secret  data  of  the  device,  server,  and/or  the 
user's  password  (depending on  the  type  of  forger).  The 
goal of  the  forger is  to forge RSA signatures with respect 
to   .   There is a dvc  oracle, a disable oracle, a svr 
oracle, and (possibly) random oracles h and  f .  A random 
oracle may be queried at any time.  It takes an input and re- 
turns a random hash of that input, in the defined range. The 
disable oracle  may  be  queried with  getVals.  It  responds 
with a value t and the device's ticket T .  
The svr  oracle may  be  queried with  serve and  disable. 
On  a serve(y, 6 , ~ )  query, which  represents  the  receipt  of 
a message in  the  S-RSA protocol  ostensibly  from  the de- 
vice,  it either aborts or returns  an  output message 77  (with 
respect to the secret server data generated by the initializa- 
tion procedure). On a disable(t, 7 )  query, which represents 
a  disable request, the  svr  oracle rejects  all  future queries 
with the ticket  T  if t corresponds to T  (see Section 5.1.3). 
The dvc oracle may be queried with start and finish. We 
assume there  is  an  implicit  notion  of  sessions so that  the 
dvc oracle can determine the start query corresponding to 
a finish query.  On a start(m) query, which represents a re- 
quest to initiate the S-RSA protocol, the dvc returns an out- 
put  message  ,   and  sets  some internal  state (with 
respect  to  the  secret  device  data and  the  password  gener- 
ated by  the initialization  procedure). On the corresponding 
finish(q) query, which  represents the  device's receipt  of  a 
response  ostensibly  from  the  server,  the  dvc  oracle either 
aborts or returns a valid signature for the message m given 
as input to the previous start query. 
A  forger of  type  ADV({svr:no}),  ADv({dvc,svr}),  or 
ADV({dvc})  succeeds  if  after  this  it  can  output  a  pair 
(m, )  where  se  EN  encode(m,r) and,therc was 
no  start(m) query.  A  type  ADv({dvc,no})  forger  siic- 
ceeds  if  after this  it can  output  a pair  ( m ,  ) where 
encode(m, T )  and there was no serve(?, 6 , ~ )  query, 
se 
where Dsl;,,,(y) = , before a disable(t, T )  query 
21 
6.2. Theorems 
Here we prove that if a forger breaks the S-RSA system 
with  probability  non-negligibly more  than  what  is  inher- 
ently possible in a system of this kind then either the under- 
lying RSA  signature scheme or the underlying  encryption 
scheme used  in  S-RSA can be broken  with  non-negligible 
probability.  This  implies that  if  the  underlying RSA  sig- 
nature  scheme  and the  underlying encryption scheme are 
secure, our system will be as secure as inherently possible. 
We prove security separately for the different types of at- 
tackers  from  Section  3.1.  The idea behind  each proof  is a 
simulation  argument. We assume that a forger F  can break 
the  S-RSA system, and then  attempt to construct a forger 
F'  for the underlying RSA signature scheme. Basically F' 
will  run  F  over a  simulation of  the  S-RSA system,  and 
when F  succeeds in  breaking S-RSA (in  a way not inher- 
ently possible, as discussed above), then F* will succeed in 
breaking the underlying RSA signature scheme. 
In  the  security  proof  against  a  device-compromising 
forger F ,  there  is  a  slight  complication.  If  F  were  able 
to break  the  encryption scheme of  the server,  a  forger F" 