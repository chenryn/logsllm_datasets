contain a lot of information which is not relevant for all diagnostic
programs. Furthermore, the Server’s algorithm scales linearly with
the number of nodes in the branching program, which is as good as
one can realistically hope to achieve.
Scaling behavior of the User’s algorithm is shown in Figures 4
and 5. As is the case with the Server, the User’s online computation
time depends linearly on the size of the branching program, but is
independent of the number of attributes in the attribute vector. Un-
like the Server, the User’s ofﬂine computation time and bandwidth
requirements do depend on the number of attributes. This is be-
cause the User must encrypt the entire attribute vector ofﬂine, and
then transmit it as part of the protocol.
We also evaluate our prototype implementation on several real
applications, as shown in Table 3. These benchmarks have been
chosen because they are common, heavily-used programs that ei-
ther contain security vulnerabilities which would be revealed by
the diagnostic program (e.g., gzprintf), or report misleading er-
ror messages (or none at all) for non-exotic error conditions, and
therefore would beneﬁt the most from remote diagnosis. As our di-
agnostic programs, we used classiﬁcation trees generated by Clar-
Figure 1: Diagnostic branching program for the mpg321
benchmark. Dotted lines are taken when the attribute (nor-
malized count of the feature value) is less than or equal to the
threshold listed in the box, while the solid line is taken when it
is greater than the threshold. The threshold is determined au-
tomatically for each benchmark by the decision tree algorithm,
and can be different for each node in the tree. Clear boxes are
decision nodes. Shaded boxes are classiﬁcation nodes.
At the root,
error (trying to play a wav ﬁle as if it were an mp3), corrupted tag
(mp3 metadata, e.g., artist name is stored in ID3 format tags), and
corrupted mp3 frame data. The diagnostic branching program dis-
tinguishes between these three failure modes and normal execution.
the function mad layer III provides almost
perfect discriminative information for the wav error class (trying
to play a wav as if it were an mp3): the mad layer III routine
is part of the libmad library and is called when the audio frame
decoder runs. Since the wav format is among the formats not
supported by mpg321, it will not successfully decode any audio
frames, and the libmad library will never call mad layer III.
The id3 tag delete routine differentiates between the
corrupted tag and and other classes. The ID3 tag parser in the
libid3tag library dynamically allocates memory to represent
tags and frees them with id3 tag delete. If tag parsing fails,
the memory for a tag is not allocated. Since no tag parsing suc-
ceeds in the corrupted frames case, id3 tag delete is never
called to free the tag memory, making its absence discriminative
for that class. The libmad audio library’s default error handler
error default is used if the application does not specify one.
mpg321 does not specify its own error handler, so the presence
of the function indicates corrupted audio frames, and its absence
indicates corrupted id3 tags. Finally, III freqinver, which
performs subband frequency inversion for odd sample lines, is
called very frequently as part of normal decoding of audio frame
data. When there are corrupted frames, this function is called less
frequently, and the decision tree algorithm ﬁnds an appropriate
threshold value to separate the normal from the corrupted case.
Table 2 shows the parameters of diagnostic programs for several
benchmark applications.
6. PERFORMANCE
We evaluated our prototype implementation using PCs with an
Intel Pentium D 3 GHz processor, 2 GB of RAM, and 2MB cache.
This is a realistic approximation of what the User might use, but we
expect that the Server would maintain a more powerful dedicated
server to process remote diagnostics requests.
In our analysis of scaling behavior, we created artiﬁcial data sets
with varying numbers of nodes and attributes, and measured the
ofﬂine and online time separately. Ofﬂine time includes all cal-
culations that can be performed independently of the other party,
Server's bandwidth and computation time
 (63-node diagnostic program)
Server's bandwidth and computation time
 (1000-attribute User vector)
Seconds
Online Time
Offline Time
Bandwidth
MB
Seconds
Online Time
Offline Time
Bandwidth
12
10
8
6
4
2
0
1.2
1.0
0.8
0.6
0.4
0.2
0.0
70
60
50
40
30
20
10
0
10
20
50
100
200
500
1000
2000
5000
7
15
31
63
127
255
511
Number of attributes in User's vector
Number of nodes in diagnostic program
MB
10.0
9.0
8.0
7.0
6.0
5.0
4.0
3.0
2.0
1.0
0.0
Figure 2: Server algorithm: scaling with the number of at-
tributes.
Figure 3: Server algorithm: scaling with the size of the diag-
nostic program.
User's bandwidth and computation time
 (63-node diagnostic program)
User's bandwidth and computation time
 (1000-attribute User vector)
Seconds
Online Time
Offline Time
Bandwidth
MB
Seconds
Online Time
Offline Time
Bandwidth
MB
45
40
35
30
25
20
15
10
5
0
1.4
1.2
1.0
0.8
0.6
0.4
0.2
0.0
120
100
80
60
40
20
0
3.5
3.0
2.5
2.0
1.5
1.0
0.5
0.0
10
20
50
100
200
500
1000
2000
5000
7
15
31
63
127
255
511
Number of attributes in User's vector
Number of nodes in diagnostic program
Figure 4: User algorithm: scaling with the number of at-
tributes.
Figure 5: User algorithm: scaling with the size of the diagnos-
tic program.
ify [9, 17], and as attribute vectors 32-bit invocation counters for
each function of the application.
For all applications, the computation and communication cost
of executing our privacy-preserving protocol is acceptable in many
practical scenarios.
7. CONCLUSIONS
We presented a practical, provably secure protocol which enables
a User to evaluate the Server’s branching program on the User’s lo-
cal data without revealing any information except the diagnostic
label. We applied our prototype implementation to several real-
istic benchmarks, using diagnostic decision trees produced by the
Clarify system as our branching programs, and demonstrated that
it performs well in many practical scenarios.
An interesting topic of future research is applying the techniques
for oblivious evaluation of branching programs developed in this
paper to other problems in privacy-preserving computation.
Acknowledgements. This material is based upon work supported
by the National Science Foundation under grants CNS-0509033,
IIS-0534198 and CNS-0615104, and the ARO grant W911NF-06-
1-0316.
8. REFERENCES
[1] R. Agrawal and R. Srikant. Privacy-preserving data mining.
In Proc. ACM SIGMOD International Conference on
Management of Data, pages 439–450. ACM, 2000.
[2] D. Beaver. Foundations of secure interactive computing. In
Proc. Advances in Cryptology - CRYPTO 1991, volume 576
of LNCS, pages 377–391. Springer, 1992.
[3] I. Blake and V. Kolesnikov. Strong conditional oblivious
transfer and computing on intervals. In Proc. Advances in
Cryptology - ASIACRYPT 2004, volume 3329 of LNCS,
pages 515–529. Springer, 2004.
[4] A. Blum, C. Dwork, F. McSherry, and K. Nissim. Practical
privacy: the SuLQ framework. In Proc. 24th ACM
SIGMOD-SIGACT-SIGART Symposium on Principles of
Database Systems (PODS), pages 128–138. ACM, 2005.
[5] P. Broadwell, M. Harren, and N. Sastry. Scrash: A system for
generating secure crash information. In Proc. 12th USENIX
Security Symposium, pages 273–284. USENIX, 2003.
[6] J. Camenisch and V. Shoup. Practical veriﬁable encryption
and decryption of discrete logarithms. In Proc. Advances in
Cryptology - CRYPTO 2003, volume 2729 of LNCS, pages
126–144. Springer, 2003.
[7] R. Canetti. Security and composition of multiparty
cryptograpic protocols. J. Cryptology, 13(1):143–202, 2000.
[8] R. Canetti, Y. Ishai, R. Kumar, M. Reiter, R. Rubinfeld, and
R. Wright. Selective private function evaluation with
applications to private statistics. In Proc. 20th ACM
Symposium on Principles of Distributed Computing
(PODC), pages 293–304. ACM, 2001.
[9] J. Davis, J. Ha, C. Rossbach, H. Ramadan, and E. Witchel.
Cost-sensitive decision tree learning for forensic
classiﬁcation. In Proc. 17th European Conference on
Machine Learning (ECML), volume 4212 of LNCS, pages
622–629. Springer, 2006.
[10] J. Feigenbaum, Y. Ishai, T. Malkin, K. Nissim, M. Strauss,
and R. Wright. Secure multiparty computation of
approximations. In Proc. 28th International Colloquium on
Automata, Languages and Programming (ICALP), volume
2076 of LNCS, pages 927–938. Springer, 2001.
[11] J. Feigenbaum, B. Pinkas, R. Ryger, and F. Saint-Jean.
Secure computation of surveys. In Proc. EU Workshop on
Secure Multiparty Protocols, 2004.
[12] M. Freedman, K. Nissim, and B. Pinkas. Efﬁcient private
matching and set intersection. In Proc. Advances in
Cryptology - EUROCRYPT 2004, volume 3027 of LNCS,
pages 1–19. Springer, 2004.
[13] Gateway. System management services agreement.
http://www.gateway.com/about/legal/
warranties/20461r10.pdf, 1999.
[14] E. Goh, L. Kruger, D. Boneh, and S. Jha. Secure function
evaluation with ordered binary decision diagrams. In Proc.
13th ACM Conference on Computer and Communications
Security (CCS), pages 410–420. ACM, 2006.
[15] O. Goldreich. Foundations of Cryptography: Volume II
(Basic Applications). Cambridge University Press, 2004.
[16] O. Goldreich, S. Micali, and A. Wigderson. How to play any
mental game. In Proc. 19th Annual ACM Symposium on
Theory of Computing (STOC), pages 218–229. ACM, 1987.
[17] J. Ha, C. Rossbach, J. Davis, I. Roy, H. Ramadan, D. Porter,
D. Chen, and E. Witchel. Improved error reporting for
software that uses black box components. In Proc. ACM
SIGPLAN Conference on Programming Language Design
and Implementation (PLDI), pages 101–111. ACM, 2007.
[18] Q. Huang, D. Jao, and H. Wang. Applications of secure
electronic voting to automated privacy-preserving
troubleshooting. In Proc. 12th ACM Conference on
Computer and Communications Security (CCS), pages
68–80. ACM, 2005.
[19] Y. Ishai and A. Paskin. Evaluating branching programs on
encrypted data. In Proc. 4th Theory of Cryptography
Conference (TCC), volume 4392 of LNCS, pages 575–594.
Springer, 2007.
[20] S. Jarecki and V. Shmatikov. Efﬁcient two-party secure
computation on committed inputs. In Proc. Advances in
Cryptology - EUROCRYPT 2007, volume 4515 of LNCS,
pages 97–114. Springer, 2007.
[23] Y. Lindell and B. Pinkas. A proof of Yao’s protocol for
secure two-party computation.
http://eprint.iacr.org/2004/175, 2004.
[24] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay – a
secure two-party computation system. In Proc. 13th USENIX
Security Symposium, pages 287–302. USENIX, 2004.
[25] G. McGraw and J. Viega. Making your software behave:
Security by obscurity. http://www.ibm.com/
developerworks/java/library/s-obs.html,
2000.
[26] Microsoft. Privacy statement for the Microsoft error
reporting service. http://oca.microsoft.com/
en/dcp20.asp, 2006.
[27] Microsoft. Reporting and solving computer problems.
http://windowshelp.microsoft.com/
Windows/en-US/Help/d97ba15e-9806-
4ff3-8ead-71b8d62123fe1033.mspx, 2006.
[28] Microsoft. How to: Conﬁgure microsoft error reporting.
http://msdn2.microsoft.com/en-us/
library/bb219076.aspx, 2007.
[29] M. Naor and K. Nissim. Communication preserving
protocols for secure function evaluation. In Proc. 33rd ACM
Symposium on Theory of Computing (STOC), pages
590–599. ACM, 2001.
[30] M. Naor and B. Pinkas. Efﬁcient oblivious transfer protocols.
In Proc. 12th Annual ACM-SIAM Symposium on Discrete
Algorithms (SODA), pages 448–457. SIAM, 2001.
[31] M. Naor, B. Pinkas, and R. Sumner. Privacy preserving
auctions and mechanism design. In Proc. 1st ACM
Conference on Electronic Commerce, pages 129–139. ACM,
1999.
[32] R. Naraine. Dr. Watson’s Longhorn makeover raises
eyebrows. http://www.eweek.com/article2/0,
1759,1822142,00.asp, 2005.
[33] Oracle. Oracle sues SAP. http://www.oracle.com/
sapsuit/index.html, 2007.
[34] P. Paillier. Public-key cryptosystems based on composite
degree residuosity classes. In Proc. Advances in Cryptology -
EUROCRYPT 1999, volume 1592 of LNCS, pages 223–238.
Springer, 1999.
[35] M. Rabin. How to exchange secrets by oblivious transfer.
Technical Report TR-81, Aiken Computation Laboratory,
Harvard University, 1981.
[36] T. Sander, A. Young, and M. Yung. Non-interactive
CryptoComputing for NC1. In Proc. 40th Annual IEEE
Symposium on Foundations of Computer Science (FOCS),
pages 554–566. IEEE, 1999.
[37] B. Stone. A lively market, legal and not, for software bugs.
New York Times, Jan 30 2007.
[38] H. Wang, Y.-C. Hu, C. Yuan, Z. Zhang, and Y.-M. Wang.
Friends troubleshooting network: Towards
privacy-preserving, automatic troubleshooting. In 3rd
International Workshop on Peer-to-Peer Systems (IPTPS),
volume 3279 of LNCS, pages 184–194. Springer, 2004.
[21] J. Kilian. Founding cryptography on oblivious transfer. In
[39] J. Weideman. Automated problem reports. https://wiki
Proc. 20th Annual ACM Symposium on Theory of Computing
(STOC), pages 20–31. ACM, 1988.
.ubuntu.com/AutomatedProblemReports, 2006.
[40] A. Yao. How to generate and exchange secrets. In Proc. 27th
[22] Y. Lindell and B. Pinkas. Privacy preserving data mining. J.
Cryptology, 15(3):177–206, 2002.
Annual IEEE Symposium on Foundations of Computer
Science (FOCS), pages 162–167. IEEE, 1986.