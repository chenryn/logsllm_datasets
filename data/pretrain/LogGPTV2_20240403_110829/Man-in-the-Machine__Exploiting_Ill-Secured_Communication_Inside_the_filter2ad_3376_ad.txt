attention [26] because it was found that rogue web pages
open in the user’s browser could connect to it and issue
malicious commands to take over the computer. The at-
tack circumvented the same-origin policy in the browser
with DNS rebinding [31]. The solution was to check
that the Host header on the incoming HTTP requests is
localhost and not something else.
We see a deeper problem behind the vulnerability:
there is no access control to limit which processes can
connect to the update agent, and the implemented solu-
tion trusts the client process to provide the correct in-
formation (Host header). We implemented a MitMa at-
tacker client that spoofs the Host header and, thus, has
no problems issuing commands to the update agent. This
naturally enables the same kind of privilege escalation
for the MitMa attacker as the earlier-reported vulnerabil-
ity enabled for rogue websites.
6.2 Transmission
Transmission [9] is an open-source BitTorrent client. It
includes a background service that handles all torrent-
related activities. The service runs an HTTP server on
port 9091 and accepts connections by default only from
the localhost. The user can, optionally, set up a user-
name and password for authenticating connections to the
server. The client posts commands, such as adding, stop-
ping and removing torrents, to the HTTP server.
This service has also been found vulnerable to DNS
rebinding [27]. Again, the proposed solution of check-
ing the Host header is insufﬁcient to stop MitMa attacks
because the attacker’s background process can spoof the
header. Moreover, the MitMa attacker can hijack the
server port and capture the username and password from
the client, before releasing the port and waiting for the
legitimate server to start. The attacker will then have full
access to the user’s Transmission account.
6.3 Spotify
Spotify, a music streaming service, runs an HTTP server
on the localhost port 4381 to accept streaming com-
mands, such as playing a song. The server whitelists
clients based on the Origin header in order to allow se-
lected web pages to open in the user’s browser to access
the HTTP API. This access-control mechanism does not
prevent MitMa attacks. The reason is that the MitMa at-
tacker can lie about the Origin hostname. The attacker
can then the disturb the victim by telling the server to
play arbitrary songs.
7 Other client-server applications
This section will analyze two more client-server applica-
tions that make use of named pipes for the IPC.
7.1 MySQL
MySQL server on Windows can be conﬁgured so that
the clients connect to it using named pipes. This may be
more efﬁcient than TCP when the client and server are on
the same host [39]. The MySQL server simply creates a
named-pipe instance with the name MySQL. This named
pipe allows everyone to connect to it with full access.
When a client connects, a new instance is created to wait
for the next client.
Attacks. The MitMa attacker can perform a man-in-the-
middle attack on MySQL connections as follows. Sup-
pose that the server has started and it has created the
ﬁrst instance of the named pipe. First, the attacker cre-
ates another instance of the named pipe. This is possible
due to the unrestricted DACL of the pipe. The attacker
then connects to the ﬁrst instance as a client. Next, the
MySQL server will create a new instance to wait for a
new client. However, if a legitimate client now tries to
connect, it will be connected to the attacker’s instance
because it is the oldest unconnected instance. After this,
the attacker can act as the man in the middle and forward
messages between the two pipe instances.
The above attack allows the attacker to read all mes-
sages between the client and the server and to modify the
1520    27th USENIX Security Symposium
USENIX Association
SQL queries and responses. Furthermore, the attacker
can inject its own queries to the session.
7.2 Keybase
Keybase [5] is an open-source messaging app with end-
to-end encryption, which is available for both phones and
desktop computers. On the latter, the Keybase app has
a client-server architecture. The app launches a back-
ground process that handles all of the application’s tasks,
such as encrypting and sending messages.
On Windows, the client accepts commands from the
user and sends them to the Keybase background pro-
cess over a named pipe. The background process creates
the pipe with the name keybased.sock at startup. The
named pipe’s access control list grants full access for the
current active user and administrators, while other users
have only read access. Also, the pipe is created with the
FILE FLAG FIRST PIPE INSTANCE ﬂag. Thus, the back-
ground process will not start if the named pipe already
exists.
To use Keybase on a new device, the user must ﬁrst
sign in to the Keybase background process with his Key-
base credential and then approve the new device from
a previously registered device. After that, the Keybase
background process on the new device has full access to
the user’s Keybase account.
Attacks.
We see that the MitMa attacker cannot
set itself between legitimate client and server because
of the FILE FLAG FIRST PIPE INSTANCE ﬂag. There is
also no point for the MitMa attacker to impersonate the
client without having write access, which is required for
two-directional communication. However, the attacker
can impersonate the Keybase background process to the
client by starting it before the legitimate one. This causes
the legitimate background process to fail silently. Since
the Keybase is open source, the attacker can simply mod-
ify the Keybase source code so that the named pipe al-
lows full access from everyone. The attacker then runs
the modiﬁed service in the background and waits for the
victim’s ﬁrst login. When the victim signs in, approval
is given to the malicious Keybase instance instead of the
intended one.
8 Mitigation mechanisms
In this section, we discuss potential prevention and mit-
igation mechanisms for the MitMa threats. The goal is
to present a taxonomy that brings order to the concepts,
rather than to cover all technical details.
Spatial and temporal separation of user sessions.
MitMa attacks are performed by leaving a malicious pro-
cess running in the background when the victim logs in
to the system. The most straightforward countermeasure
is to limit the number of users that have access to each
computer. Ideally, each computer would be personal to
one user. If that is not feasible, the administrator of a
multi-user system may implement the principle of least
privilege so that users can only log into the computers
that they really need to access. This includes disabling
the guest account.
A slightly less drastic solution is to enforce tempo-
ral separation, i.e. to allow only one user’s processes to
be running on the computer at any one time. On Linux
and macOS, this requires disabling fast user switching
and remote access and killing any rogue processes that
might have been left behind. On Windows, disabling
user switching is not effective because the attacker can
easily bypass it, for example, with the built-in Windows
Instead, the Shared PC mode
system tool tsdiscon.
[54] should be enabled, which prohibits multiple simul-
taneous login sessions.
Security-conscious users can also take some protec-
tive measures by themselves. They can manually verify
that there are no other active login sessions in the back-
ground, e.g. with the Windows command query user.
The most reliable way is to reboot the computer before
logging in, so that any active user sessions and processes
are ﬂushed out. Naturally, these measures help only if
all remote access methods, such as SSH, have been dis-
abled.
Access control. The developers of IPC applications
should make use of OS access-control features such as
Unix permissions or Windows DACLs on named pipes.
Unfortunately, operating systems do not provide simi-
lar access controls for network sockets. As we have
seen, access control for USB communication in Win-
dows is also lacking. Furthermore, the cases studies
in this paper show that it is easy to make mistakes
with access control.
For example, when creating a
named pipe on Windows, the server needs to specify the
FILE FLAG FIRST PIPE INSTANCE ﬂag or check after the
creation who is the owner of the securable pipe object.
Any checks made before the pipe creation are not reli-
able because of possible race conditions.
Attack detection. Once a named IPC channel has been
created, the communicating endpoints can use operating-
system APIs to check whether they are communicating
securely with the correct entity. With Windows named
pipes, the client and server can query the session and pro-
cess identiﬁers of the other endpoint. This makes it pos-
sible to check that the client and server are in the same
login session. Based on the process id, they can query
further attributes of the process at the other end of the
pipe, such as the user and the path to the process binary,
which can then be compared to a whitelist. The critical
USENIX Association
27th USENIX Security Symposium    1521
trick here to perform the checks both at the server for the
client and at the client for the server.
JavaScript clients running in a web browser, includ-
ing browser extensions, pose special challenges for such
attack detection. First, they do not have access to OS
APIs and are therefore unable to perform most checks on
the server process to which they connect. This limitation
means that it is difﬁcult to establish secure communica-
tion between a web browser extension and a stand-alone
app. Second, web browsers are highly scriptable. As we
have seen, some IPC servers check that the client binary
is a signed version of a well-known web browser. This
check alone is not reliable because the attacker could be
using the legitimate binary for malicious purposes. At
minimum, the server should check the owner of the client
process.
Cryptographic protection. Authentication methods for
communication over insecure channels have been studied
widely [15,18,30] and can be applied also to IPC. These
protocols require distribution of shared or public keys to
the IPC clients and servers. For example, F-Secure Key
authorizes access to the password database by transfer-
ring a secret token to the client through a user-assisted
out-of-band channel (in this case, Windows clipboard,
which has its own weaknesses). Lessons for more se-
cure user-assisted pairing methods could be learned, for
example, from Bluetooth device pairing and other user-
assisted out-of-band authentication and pairing protocols
[12, 16, 45].
Another approach is to assume that all IPC takes place
remotely over the Internet and to use the standard TLS-
based protocols for protecting it. The necessary infras-
tructure, including certiﬁcation authorities, may be an
overkill when the goal is authorization of the server and
client processes rather than binding them to strong iden-
tities. Even OAuth 2.0, which deﬁnes bearer tokens
for client authorization and therefore seems suitable for
IPC clients, depends on certiﬁcates for authenticating the
server.
In any case, cryptographic protection requires
careful design and, as we have seen once again in this
paper, ad-hoc implementations tend to have weaknesses.
Architectural changes to software. Some password
managers do not have a stand-alone app but connect di-
rectly from the browser extension to a cloud service,
which provides the server functions. This kind of archi-
tecture avoids inter-process communication altogether
but is not feasible for all applications.
Another way to avoid the vulnerabilities of IPC meth-
ods is to redesign software to run related software com-
ponents in the same process. This does not necessarily
mean loss of software modularity or use of third-party
components. For example, SQLite does not require IPC
in the same way as MySQL does because it is linked to
the application as a library. The safe IPC methods (un-
named pipes and socket pairs, see Section 3.4) can still
be used between related processes without exposing the
applications to MitMa attacks.
Such architectural solutions work well when they are a
good match for the goals of the application developer. In
many cases, however, the developer would not be will-
ing to give up common software patterns like separating
software into a frontend UI and backend business logic
and database that run on the same computer, or commu-
nicating with a web API between these components.
9 Discussion and future work
The described vulnerabilities are fundamentally caused
by carelessly-designed or poorly-written software. This
conclusion is supported by the fact that there are also se-
cure, well-designed applications that make use of IPC.
As a further case study, we looked at cloud-storage ap-
plications (e.g. Dropbox, SpiderOak, Box), which tend
to have a local backend component that is accessed over
IPC. We found this class of software to be more prudent
about security than the ones discussed in this paper. Be-
cause of such positive examples, our view of the future
is not entirely bleak.
The well-designed applications set up strict DACLs or
permissions to ensure that the IPC channel is accessi-
ble only to the authorized user(s) and conﬁgure the IPC
channel options carefully rather than relying on the de-
fault settings. They also query the OS APIs to check that
the login session, user and executable ﬁle of the other
endpoint have the expected values. Named pipes provide
more such control and seem easier to secure than net-
work sockets. The advantage of network sockets is that
the same web APIs work without code changes locally
and across the Internet, but the cost is that the available
web security mechanisms do not take advantage of the
locality and are usually considered too heavy for local
IPC.
The explanation why the problems with IPC are so
widespread is probably twofold. First, developers are in-
clined to consider the localhost a trusted environment.
Second, the best practices for secure IPC are not doc-
umented, and therefore developers may simply be un-
aware of the threats and solutions. We therefore believe
that the best way to address both of these potential ex-
planations is to raise awareness about the attacks and
defenses, as we attempt to do in this paper. Over time,
better tools such as safe APIs and security test benches
could help eradicate entire classes of problems. Fully au-
tomated vulnerability scanning, however, does not seem
possible because the automated tools cannot not evalu-
ate the security of application-level cryptographic pro-
tection.
1522    27th USENIX Security Symposium
USENIX Association
In some sense, the idea of protecting the users of a
multi-user computer system from each other takes us
back to the early days of computer security. With per-
sonal computers, this has not been perceived as so im-
portant.
It has also become common wisdom among
information-security experts that, if the attackers can run
a process on the computer, they always can ﬁnd a path
to privilege escalation [32, 44, 55] and gain full admin-
istrative access. There is, however, the opposite trend
towards greater isolation of applications from each other
and containing malicious applications. This trend started
in mobile devices, but desktop operating systems are be-
ginning to provide similar protections (UWP AppCon-
tainers in Windows 10 [40] or application sandboxing
in macOS [11]). The MitMa attacks are one way for
a non-privileged process to circumvent isolation bound-
aries within the computer, and we believe that the obser-
vations of this paper will prove useful in the design of
application-isolation mechanisms.
We have focused on the threat model where the at-
tacker and victim are two nonprivileged users. One di-
rection of further work is to look at similar MitMa vul-
nerabilities in server software where a non-administrator
attacker exploits IPC for privilege escalation. Attacks
between applications of the same user may also deserve
a look. Even though current desktop applications will
not present much resistance to such attacks, it is good to
question the status quo. Such threats have earlier been
studied in the context of Mac OS X [55] and mobile
OSs [22,46,55], which, as mentioned above, already pro-
vide isolation for user-space apps.
10 Related work
This section summarizes the research literature related to