OneHot′ is strongly stackable.
□
Procedure:
and 𝑏 ∈ {0, 1}𝑚.
Input: Parties input shared bitstrings(cid:74)𝑎(cid:75),(cid:74)𝑏(cid:75) where 𝑎 ∈ {0, 1}𝑛
Output: Parties output a shared matrix(cid:74)𝑎 ⊗ 𝑏(cid:75).
gates output(cid:74)𝑎 ⊕ 𝛼(cid:75),(cid:74)𝑏 ⊕ 𝛽(cid:75), and(cid:74)𝛼(cid:75).
• Parties release to 𝐸 𝑎 ⊕ 𝛼 and 𝑏 ⊕ 𝛽 for uniform 𝛼 ∈
{0, 1}𝑛, 𝛽 ∈ {0, 1}𝑚 via Color gates. Notably, the Color
• Parties agree on a “chunk size” 𝑘 which is at most logarith-
mic in the overall circuit input size. The parties split the
input vectors into ⌈𝑛/𝑘⌉ 𝑘-bit subvectors to avoid expen-
sive exponential scaling.
via a one-hot gate (by Lemma 4.1). Notice that the parties
do not split 𝑏 into chunks. The parties then vertically con-
catenate the ⌈𝑛/𝑘⌉ resultant matrices into a single matrix
• For each 𝑘-bit subvector(cid:74)𝑎 ⊕ 𝛼(cid:75)𝑖..𝑖+𝑘, the parties compute:
T (id)⊺ ·(cid:74)H((𝑎 ⊕ 𝛼))𝑖..𝑖+𝑘 ⊗ 𝑏(cid:75) =(cid:74)(𝑎 ⊕ 𝛼)𝑖..𝑖+𝑘 ⊗ 𝑏(cid:75)
(cid:74)(𝑎 ⊕ 𝛼) ⊗ 𝑏(cid:75).
• Symmetrically, the parties compute(cid:74)(𝑏 ⊕ 𝛽) ⊗ 𝛼(cid:75) by split-
ting(cid:74)𝑏 ⊕ 𝛽(cid:75) into ⌈𝑛/𝑘⌉ 𝑘-bit chunks.
• 𝐺 locally computes 𝛼 ⊗ 𝛽 and injects(cid:74)𝛼 ⊗ 𝛽(cid:75) as a constant.
(cid:74)(𝑎 ⊕ 𝛼) ⊗ 𝑏(cid:75) ⊕(cid:74)(𝑏 ⊕ 𝛽) ⊗ 𝛼(cid:75)⊺ ⊕(cid:74)𝛼 ⊗ 𝛽(cid:75) =(cid:74)𝑎 ⊗ 𝑏(cid:75)
• Parties compute and output:
(see Figure 5 for proof of above equality).
B APPLICATIONS – EXTENDED
In this appendix, we expand on details deferred from Section 5.
B.1 General Binary Outer Products – Extended
In Section 7.2 we explained our general outer product technique,
but we did not formalize it. Figure 8 provides the formal module.
Figure 8: Efficient general outer product module. The module
implements the function 𝑎, 𝑏 ↦→ 𝑎 ⊗ 𝑏. Unlike Figure 5, this
module handles outer products for input vectors of arbitrary
length.
method [WMK16]6. For sake of example, consider 𝑛 = 4 and exam-
ine the computation done by the schoolbook method:
B.2 Binary Matrix Multiplication – Extended
It is well known that outer products can be used to efficiently
compute matrix products. Specifically, the binary matrix product
of input matrices 𝑎 and 𝑏 can be expressed by (1) for each 𝑖 taking
the outer product of column 𝑖 of 𝑎 with row 𝑖 of 𝑏 and (2) XORing
the resulting matrices.
Notice that this technique does not use our low level primitives
directly, and instead uses our outer product module as a black box.
Hence, we need not formalize a module for matrix multiplication.
Because our technique reduces the cost of outer products by
factor 𝑘 (see Section 7.2), we similarly reduce the cost of binary
matrix multiplication by factor 𝑘. That is, for input matrices with
dimension 𝑛 × 𝑚 and 𝑚 × 𝑙, we require O(𝑛𝑚𝑙/𝑘) communication
rather than the standard O(𝑛𝑚𝑙). Formally, 𝑘 is a logarithmic factor;
in practice we instantiate 𝑘 with small constants.
We implemented matrix multiplication; Figure 9 plots our im-
provement over the standard approach.
B.3 Integer Multiplication – Extended
Consider the multiplication of two 𝑛-bit numbers 𝑎 and 𝑏. Stan-
dard GC techniques multiply such numbers using the schoolbook
Notice that each summand can be expressed by bits in the outer
product of 𝑎 and 𝑏. Hence, we improve multiplication by using our
general outer product module (Section 7.2). Each summand must
still be added inside GC; we do so by traditional GC means. This
addition is now the bottleneck of multiplication performance. We
leave potential improvements, perhaps by incorporating arithmetic
GC techniques [BMR16], to future work.
Our integer multiplication technique does not use our lowest
level primitives directly, so we need not formalize a module.
B.4 Binary Field Inverses – Extended
We now describe our field inverse module in detail. We first com-
pute and release to 𝐸 𝑎 · 𝛼. To do so, we use a Reveal gate to sample
6There exist asymptotically more efficient multiplication algorithms, but these are
inefficient in practice.
a0·(a1·(a2·(a3·(b3b2b1b0b2b1b0b1b0b0+(ab)0(ab)1(ab)2(ab)3)))000000)Session 2D: Secure Multiparty ComputationCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea591Input: Parties input shared bitstring(cid:74)𝑎(cid:75) where 𝑎 ∈ {0, 1}𝑛.
Output: Let 𝑓 : {0, 1}𝑛 → {0, 1}𝑛 be defined as follows:
(cid:40)0
𝑓 (𝑥) ≜
if 𝑥 = 0
otherwise
𝑥−1
Procedure:
Parties output a shared bitstring(cid:74)𝑓 (𝑎)(cid:75).
• The parties first compute(cid:74)𝑧(cid:75) ≜(cid:74)𝑎 == 0(cid:75). This is achieved
using a circuit with 𝑛 − 1 AND gates.
• The parties next compute a Reveal gate to mask 𝑎 ⊕ 𝑧. The
gate samples a uniform non-zero element 𝛼 from GF(2𝑛).
The Reveal gate’s internal circuit is itself a module that
computes 𝑥 ↦→ 𝑥 · 𝛼; it is implemented as follows:
– The internal module takes as arguments 𝑎 and 𝛼. Via
a Color gate, it reveals 𝑎 ⊕ 𝛾 to 𝐸 where 𝛾 is a uniform
mask.
– Note, 𝐺 knows 𝛾 ⊗𝛼 and hence can inject it as a constant.
The parties compute the following by a one-hot gate:
T (id)⊺ ·(cid:74)H(𝑎 ⊕ 𝛾) ⊗ 𝛼(cid:75) ⊕(cid:74)𝛾 ⊗ 𝛼(cid:75)
=(cid:74)(𝑎 ⊕ 𝛾) ⊗ 𝛼(cid:75) ⊕(cid:74)𝛾 ⊗ 𝛼(cid:75)
=(cid:74)(𝑎 ⊗ 𝛼) ⊕ (𝛾 ⊗ 𝛼)(cid:75) ⊕(cid:74)𝛾 ⊗ 𝛼(cid:75)
=(cid:74)𝑎 ⊗ 𝛼(cid:75)
– The internal module then computes(cid:74)𝑎 · 𝛼(cid:75) via a linear
function (see Section 7.5) and outputs the result.
• The above Reveal gate releases (𝑎 ⊕ 𝑧) · 𝛼 to 𝐸. This is se-
cure because both 𝑎 ⊕ 𝑧 and 𝛼 are non-zero field elements
and because 𝛼 is uniform; hence the product is indistin-
guishable from a uniform non-zero field element.
• The parties compute the following by a one-hot gate:
T ((·)−1)⊺ ·(cid:74)H((𝑎 ⊕ 𝑧) · 𝛼) ⊗ 𝛼(cid:75) =(cid:74)((𝑎 ⊕ 𝑧) · 𝛼)−1 ⊗ 𝛼(cid:75)
• Finally, the parties compute the following via a linear func-
tion (see Section 7.5) and output the result:
(cid:74)((𝑎 ⊕ 𝑧) · 𝛼)−1 · 𝛼) ⊕ 𝑧(cid:75) =
(cid:40)(cid:74)0(cid:75)
(cid:74)𝑎−1(cid:75) otherwise
if 𝑧 = 1
Figure 10: Our binary field inverse module.
computes the following expression:
(cid:74)(𝑎 ⊕ 𝑧)−1 ⊕ 𝑧(cid:75)
If 𝑎 is indeed zero, then this expression takes the inverse of one,
which is itself one, and then XORs one, resulting in the desired
output zero. Otherwise, this expression computes 𝑎−1.
S-Boxes – Extended. In Section 7.6, we discussed the 8-bit
B.4.1
AES S-Box. 16-bit S-Boxes, based on an inversion in GF(216), have
also been proposed for some applications [KKK+15]. The state-of-
the-art Boolean circuit uses 226 ciphertexts (113 AND gates) [BMP13].
Our approach produces an S-Box that consumes only 122 cipher-
texts, a ∼ 45% improvement. Unfortunately, this application is less
practical in terms of wall clock time since the parties must each
compute a 216 × 16 one-hot outer product matrix.
Figure 9: We used our implementation to compute the bit-
wise matrix product of two 128 × 128 square bit matrices. We
plot total communication consumption (top) and wall clock
runtime (bottom). We instantiated our approach with various
“chunking factors” 𝑘 (see Figure 8). At 𝑘 = 6, we improve over
standard by 6.2× (communication) and 5× (time).
uniform non-zero mask 𝛼 ∈ GF(2𝑛). Recall that a Reveal gate may
use an arbitrary circuit to apply the mask to its argument; we use
a circuit that computes 𝑎 · 𝛼 where · denotes field multiplication.
This circuit uses the technique described in Section 7.5 to reduce
field multiplication to an outer product. Because 𝐺 knows the mul-
tiplicand 𝛼, the Reveal gate’s internal circuit can compute the outer
product more efficiently than as described in Section 7.1. Namely
the parties compute the following, where 𝛾 ∈ {0, 1}𝑛 is a uniform
mask:
T (id)⊺ ·(cid:74)H(𝑎 ⊕ 𝛾) ⊗ 𝛼(cid:75) ⊕(cid:74)𝛾 ⊗ 𝛼(cid:75) =(cid:74)𝑎 ⊗ 𝛼(cid:75)
𝐺 injects(cid:74)𝛾 ⊗ 𝛼(cid:75) as a constant. The parties apply a linear function
to this outer product to obtain(cid:74)𝑎 · 𝛼(cid:75).
The above gate reveals 𝑎 · 𝛼 to 𝐸, so we must prove this secure.
This holds straightforwardly: because 𝛼 is uniform and because
GF(2𝑛) is a field, this value is indistinguishable from a uniform
non-zero field element.
Next, we use the revealed value 𝑎 · 𝛼 to compute the inverse. Let
(·)−1 be the function that takes the field inverse of its argument.
The parties use a one-hot gate to compute the following:
T ((·)−1)⊺ ·(cid:74)H(𝑎 · 𝛼) ⊗ 𝛼(cid:75) =(cid:74)(𝑎 · 𝛼)−1 ⊗ 𝛼(cid:75)
from the outer product the field product(cid:74)(𝑎 · 𝛼)−1 · 𝛼(cid:75) =(cid:74)𝑎−1(cid:75).
The parties use the reduction described in Section 7.5 to compute
Our module must account for the possibility that the input 𝑎 is
zero. The typical approach, which we also adopt, is to map input
zero to output zero. To do so, we first compute an auxiliary bit 𝑧
that indicates if 𝑎 = 0. We use a regular Boolean circuit with ANDs
and XORs to compute(cid:74)𝑧(cid:75) ≜(cid:74)𝑎 == 0(cid:75). At the top-level, the module
Lemma 3.3
Session 2D: Secure Multiparty ComputationCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea592B.5 Modular Reduction – Extended
Figure 11 lists the module for our modular reduction technique.
The module makes use of two key ideas:
First, consider 𝑥 and 𝑦 that are both statically known to be less
than ℓ. In this case, the operation (𝑥 + 𝑦) mod ℓ is a special case
and can be computed using linear communication: simply add the
numbers, compare the sum to ℓ, and conditionally subtract ℓ.
Second, we use the two following equalities:
(𝑥 + 𝑦) mod ℓ = ((𝑥 mod ℓ) + (𝑦 mod ℓ)) mod ℓ
𝑥 mod ℓ = (𝑥 mod (𝑚 · ℓ)) mod ℓ
Based on these ideas, we split the input 𝑎 into chunks, reduce
each chunk modulo ℓ, and then efficiently add the results.
B.6 Exponentiation – Extended
We now describe our module that computes(cid:74)ℓ𝑎(cid:75) for publicly agreed
constant ℓ. We take advantage of the following property of expo-
nents:
𝑥 𝑦 · 𝑥𝑧 = 𝑥 𝑦+𝑧
The module is formalized in Figure 12.
The key idea is that we can split 𝑎 into “chunks” and then easily
compute ℓ(·) for each chunk. We still need to then multiply each of
these results inside GC, but the number of required multiplications
is proportional only to the number of chunks. Notice also that
we can use our improved multiplication technique (Section 7.4) to
further improve the module.
Input: Parties input shared bitstring(cid:74)𝑎(cid:75) where 𝑎 ∈ {0, 1}𝑛. Par-
Output: Parties output a shared bitstring(cid:74)ℓ𝑎 mod 2𝑛(cid:75).
ties agree on a public constant ℓ.
Procedure:
uniform, this revelation is secure.
• The parties use a Reveal gate to (1) sample uniform 𝛼, (2)
compute(cid:74)𝑎 − 𝛼(cid:75), and (3) reveal 𝑎 − 𝛼 to 𝐸. Because 𝛼 is
• The parties view(cid:74)𝑎 − 𝛼(cid:75) as the concatenation of ⌈𝑛/𝑘⌉ 𝑘-
bit “chunks”. For each 𝑖th chunk(cid:74)𝑐𝑖(cid:75), the parties compute:
T (ℓ(·)≪(𝑖·𝑘)) ·(cid:74)H(𝑐𝑖) ⊗ 1(cid:75) = ℓ𝑐𝑖 ≪(𝑖·𝑘)
• The parties compute and output:
(cid:32)
(cid:33)
ℓ𝑐𝑖 ≪(𝑖·𝑘)
· ℓ𝛼
𝑖
= (ℓ𝑎−𝛼) · ℓ𝛼
= ℓ𝑎
Note ℓ𝛼 is a constant known to 𝐺. Each multiplication is
computed via the technique described in Section 7.4.
Figure 12: Our integer exponent of a public constant module.
Input: Parties input shared bitstring(cid:74)𝑎(cid:75) where 𝑎 ∈ {0, 1}𝑛. Par-
Output: Parties output a shared bitstring(cid:74)𝑎 mod ℓ(cid:75).
ties agree on a public constant ℓ.
Procedure:
• Parties agree on a parameter 𝑚 such that 𝑚 · ℓ > 2𝑛.
• The parties use a Reveal gate to (1) sample uniform mask
𝑎 + 𝛼 mod 𝑚 · ℓ to 𝐸. Because 𝛼 is uniform, this revelation
is secure.
𝛼 ∈ Z𝑚·ℓ, (2) compute(cid:74)𝑎 + 𝛼 mod 𝑚 · ℓ(cid:75), and (3) reveal
• The parties view(cid:74)𝑎 + 𝛼 mod 𝑚 · ℓ(cid:75) as the concatenation
of 𝑘-bit “chunks”. For each 𝑖th chunk(cid:74)𝑐𝑖 mod (𝑚 · ℓ)(cid:75), the
parties compute:
= (𝑐𝑖 ≪ (𝑖 · 𝑘)) mod ℓ
T (((·) ≪ (𝑖 · 𝑘)) mod ℓ) ·(cid:74)H(𝑐𝑖) ⊗ 1(cid:75)
(cid:32)(cid:32)∑︁
• The parties compute and output:
(𝑐𝑖 ≪ (𝑖 · 𝑘)) mod ℓ
Where ≪ denotes a left bit shift. That is, the parties com-
pute (·) mod ℓ on each 𝑘-bit chunk of the masked input.
mod ℓ
+ 𝛼
(cid:33)
(cid:33)
𝑖
= ((𝑎 + 𝛼) − 𝛼) mod ℓ
= 𝑎 mod ℓ
Each addition is computed by an AND-gate based circuit
that efficiently computes (𝑥 +𝑦) mod ℓ for 𝑥, 𝑦 strictly less
than ℓ.
Figure 11: Our public modular reduction module.
Session 2D: Secure Multiparty ComputationCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea593