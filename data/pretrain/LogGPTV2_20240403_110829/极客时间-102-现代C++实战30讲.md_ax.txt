# 22 \| 处理数据类型变化和错误：optional、variant、expected和Herbception你好，我是吴咏炜。我们之前已经讨论了异常是推荐的 C++ 错误处理方式。不过，C++里有另外一些结构也很适合进行错误处理，今天我们就来讨论一下。optional在面向对象（引用语义）的语言里，我们有时候会使用空值 null表示没有找到需要的对象。也有人推荐使用一个特殊的空对象，来避免空值带来的一些问题\[1\。可不管是空值，还是空对象，对于一个返回普通对象（值语义）的C++ 函数都是不适用的------空值和空对象只能用在返回引用 /指针的场合，一般情况下需要堆内存分配，在 C++里会引致额外的开销。C++17 引入的 `optional` 模板 \[2\可以（部分）解决这个问题。语义上来说，`optional`代表一个"也许有效""可选"的对象。语法上来说，一个 `optional`对象有点像一个指针，但它所管理的对象是直接放在 `optional`里的，没有额外的内存分配。构造一个 `optional`对象有以下几种方法：1.       不传递任何参数，或者使用特殊参数           `std::nullopt`（可以和        `nullptr`    类比），可以构造一个"空"的         `optional`    对象，里面不包含有效值。        2.       第一个参数是         `std::in_place`，后面跟构造        `T`    所需的参数，可以在         `optional` 对象上直接构造出        `T`    的有效值。        3.       如果         `T` 类型支持拷贝构造或者移动构造的话，那在构造           `optional` 时也可以传递一个        `T`    的左值或右值来将         `T` 对象拷贝或移动到        `optional`    中。    对于上面的第 1 种情况，`optional` 对象里是没有值的，在布尔值上下文里，会得到`false`（类似于空指针的行为）。对于上面的第 2、3两种情况， `optional`对象里是有值的，在布尔值上下文里，会得到`true`（类似于有效指针的行为）。类似的，在 `optional`对象有值的情况下，你可以用 `*` 和 `->`运算符去解引用（没值的情况下，结果是未定义行为）。虽然  `optional` 是C++17 才标准化的，但实际上这个用法更早就通行了。因为 `optional`的实现不算复杂，有些库里就自己实现了一个版本。比如 cpptoml\[3\就给出了下面这样的示例（进行了翻译和重排版），用法跟标准的 `optional`完全吻合：     auto val = config->      get_as("my-int");    // val  是  cpptoml::option    if (val) {      // *val  是  "my-int"  键下的整数值    } else {      // "my-int"  不存在或不是整数    }cpptoml 里只是个缩微版的 `optional`，实现只有几十行，也不支持我们上面说的所有构造方式。标准库的 `optional`为了方便程序员使用，除了我目前描述的功能，还支持下面的操作：1.  安全的析构行为        2.  显式的         `has_value` 成员函数，判断        `optional`    是否有值        3.  `value` 成员函数，行为类似于        `*`，但在        `optional`    对象无值时会抛出异常         `std::bad_optional_access`4.  `value_or` 成员函数，在         `optional`    对象无值时返回传入的参数        5.  `swap` 成员函数，和另外一个        `optional`    对象进行交换        6.  `reset` 成员函数，清除         `optional`    对象包含的值        7.  `emplace` 成员函数，在         `optional`    对象上构造一个新的值（不管成功与否，原值会被丢弃）        8.  `make_optional` 全局函数，产生一个        `optional`    对象（类似         `make_pair`、        `make_unique`    等）    9.  全局比较操作        10. 等等    如果我们认为无值就是数据无效，应当跳过剩下的处理，我们可以写出下面这样的高阶函数：    template     constexpr bool has_value(      const optional& x) noexcept    {        return x.has_value();    }    template     constexpr bool has_value(      const optional& first,      const optional&... other) noexcept    {      return first.has_value() &&             has_value(other...);    }    template     auto lift_optional(F&& f)    {      return [f = forward(f)](               auto&&... args) {        typedef decay_t(args)            .value()...))>          result_type;        if (has_value(args...)) {          return optional(            f(forward(                args)                .value()...));        } else {          return optional();        }      };    }`has_value` 比较简单，它可以有一个或多个 `optional`参数，并在所有参数都有值时返回真，否则返回假。`lift_optional`稍复杂些，它接受一个函数，返回另外一个函数。在返回的函数里，参数是一个或多个 `optional`类型， `result_type`是用参数的值（`value()`）去调用原先函数时的返回值类型，最后返回的则是 `result_type` 的 `optional`封装。函数内部会检查所有的参数是否都有值（通过调用`has_value`）：有值时会去拿参数的值去调用原先的函数，否则返回一个空的 `optional`对象。 这个函数能把一个原本要求参数全部有效的函数抬升（lift）成一个接受和返回 `optional`参数的函数，并且，只在参数全部有效时去调用原来的函数。这是一种非常函数式的编程方式。使用上面函数的示例代码如下：    #include     #include     #include     #include     #include     using namespace std;    //  需包含  lift_optional  的定义    constexpr int increase(int n)    {        return n + 1;    }    //  标准库没有提供  optional  的输出    ostream&    operator(x))    {      if (x) {        os ());      cout ())           ())             > `(Nothing)`>>>  > `(42)`>>>  > `(Nothing)`>>>  > `(42)`>variant`optional`是一个非常简单而又好用的模板，很多情况下，使用它就足够解决问题了。在某种意义上，可以把它看作是允许有两种数值的对象：要么是你想放进去的对象，要么是`nullopt`（再次提醒，联想`nullptr`）。如果我们希望除了我们想放进去的对象，还可以是 `nullopt`之外的对象怎么办呢（比如，某种出错的状态）？又比如，如果我希望有三种或更多不同的类型呢？这种情况下，`variant` \[4\可能就是一个合适的解决方案。在没有  `variant`类型之前，你要达到类似的目的，恐怕会使用一种叫做带标签的联合（taggedunion）的数据结构。比如，下面就是一个可能的数据结构定义：    struct FloatIntChar {      enum {        Float,        Int,        Char      } type;      union {        float float_value;        int int_value;        char char_value;      };    };这个数据结构的最大问题，就是它实际上有很多复杂情况需要特殊处理。对于我们上面例子里的POD 类型，这么写就可以了（但我们仍需小心保证我们设置的 `type`和实际使用的类型一致）。如果我们把其中一个类型换成非 POD类型，就会有复杂问题出现。比如，下面的代码是不能工作的：    struct StringIntChar {      enum {        String,        Int,        Char      } type;      union {        string string_value;        int int_value;        char char_value;      };    };编译器会很合理地看到在 union 里使用 `string`类型会带来构造和析构上的问题，所以会拒绝工作。要让这个代码工作，我们得手工加上析构函数，并且，在析构函数里得小心地判断存储的是什么数值，来决定是否应该析构（否则，默认不调用任何union里的析构函数，从而可能导致资源泄漏）：      ~StringIntChar()      {        if (type == String) {          string_value.~string();        }      }这样，我们才能安全地使用它（还是很麻烦）：    StringIntChar obj{      .type = StringIntChar::String,      .string_value = "Hello world"};    cout  obj{      "Hello world"};    cout (obj)     #undef _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS    #undef _LIBCPP_AVAILABILITY_BAD_VARIANT_ACCESS    #define _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS    #define _LIBCPP_AVAILABILITY_BAD_VARIANT_ACCESS    #endif原因是苹果在头文件里把 `optional` 和 `variant` 在早期版本的 macOS上禁掉了，而上面的代码去掉了这几个宏里对使用`bad_optional_access` 和`bad_variant_access`的平台限制。我真看不出使用这两个头文件跟 macOS的版本有啥关系。😞expected和前面介绍的两个模板不同，`expected` 不是 C++标准里的类型。但概念上这三者有相关性，因此我们也放在一起讲一下。我前面已经提到，`optional`可以作为一种代替异常的方式：在原本该抛异常的地方，我们可以改而返回一个空的 `optional`对象。当然，此时我们就只知道没有返回一个合法的对象，而不知道为什么没有返回合法对象了。我们可以考虑改用一个`variant`，但我们此时需要给错误类型一个独特的类型才行，因为这是 `variant`模板的要求。比如：    enum class error_code {      success,      operation_failure,      object_not_found,      …    };    variant      get_object(…);这当然是一种可行的错误处理方式：我们可以判断返回值的`index()`，来决定是否发生了错误。但这种方式不那么直截了当，也要求实现对允许的错误类型作出规定。AndreiAlexandrescu 在 2012 年首先提出的 Expected 模板\[6\，提供了另外一种错误处理方式。他的方法的要点在于，把完整的异常信息放在返回值，并在必要的时候，可以"重放"出来，或者手工检查是不是某种类型的异常。他的概念并没有被广泛推广，最主要的原因可能是性能。异常最被人诟病的地方是性能，而他的方式对性能完全没有帮助。不过，后面的类似模板都汲取了他的部分思想，至少会用一种显式的方式来明确说明当前是异常情况还是正常情况。在目前的expected 的标准提案 \[7\ 里，用法有点是 `optional` 和 `variant` 的某种混合：模板的声明形式像`variant`，使用正常返回值像`optional`。下面的代码展示了一个 expected 实现\[8\ 的基本用法。    #include     #include     #include     #include     using namespace std;    using tl::expected;    using tl::unexpected;    //  返回  expected  的安全除法    expected    safe_divide(int i, int j)    {      if (j == 0)        return unexpected(          "divide by zero"s);      if (i == INT_MIN && j == -1)        return unexpected(          "integer divide overflows"s);      if (i % j != 0)        return unexpected(          "not integer division"s);      else        return i / j;    }    //  一个测试函数    expected    caller(int i, int j, int k)    {      auto q = safe_divide(j, k);      if (q)        return i + *q;      else        return q;    }    //  支持  expected  的输出函数    template     ostream& operator& exp)    {      if (exp) {        os   > `unexpected: divide by zero: Are you serious?`>>>  > `unexpected: not integer division`>>>  > `42: Ha, I got you!`>一个  `expected`差不多可以看作是 `T` 和 `unexpected` 的`variant`。在学过上面的 `variant`之后，我们应该很容易看明白上面的程序了。下面是几个需要注意一下的地方：1.  如果一个函数要正常返回数据，代码无需任何特殊写法；如果它要表示出现了异常，则可以返回一个        `unexpected`    对象。    2.  这个返回值可以用来和一个正常值或 unexpected    对象比较，可以在布尔值上下文里检查是否有正常值，也可以用        `*`    运算符来取得其中的正常值------与        `optional`    类似，在没有正常值的情况下使用        `*`    是未定义行为。        3.  可以用         `value` 成员函数来取得其中的正常值，或使用        `error`    成员函数来取得其中的错误值------与        `variant`    类似，在         `expected` 中没有对应的值时产生异常           `bad_expected_access`。        4.  返回错误跟抛出异常比较相似，但检查是否发生错误的代码还是要比异常处理啰嗦。        Herbception上面的用法初看还行，但真正用起来，你会发现仍然没有使用异常方便。这只是为了解决异常在错误处理性能问题上的无奈之举。大部分试图替换C++ 异常的方法都是牺牲编程方便性，来换取性能。只有 Herb Sutter提出了一个基本兼容当前 C++ 异常处理方式的错误处理方式\[9\，被戏称为Herbception。上面使用 expected 的示例代码，如果改用 Herbception的话，可以大致如下改造（示意，尚无法编译）：    int safe_divide(int i, int j) throws    {      if (j == 0)        throw arithmetic_errc::          divide_by_zero;      if (i == INT_MIN && j == -1)        throw arithmetic_errc::          integer_divide_overflows;      if (i % j != 0)        throw arithmetic_errc::          not_integer_division;      else        return i / j;    }    int caller(int i, int j,               int k) throws    {      return i + safe_divide(j, k);    }    #define CHECK(expr)               \      try {                           \        int result = (expr);          \        cout     #include     #include     using namespace std;    int main()    {      //  代表位置的向量      arma::vec pos{1.0, 0.0};      //  旋转矩阵      auto& pi = arma::datum::pi;      double angle = pi / 2;      arma::mat rot = {        {cos(angle), -sin(angle)},        {sin(angle), cos(angle)}};      cout ` 和           `Mat`    的缩写别名。        4.  Armadillo 支持使用 C++11    的列表初始化语法来初始化对象。        5.  Armadillo    支持使用流来输出对象。        上面代码的输出为：>  > `Current position:`>>>  > `1.0000`>>>  > `0`>>>  > `Rotating 90 deg`>>>  > `New position:`>>>  > `6.1232e-17`>>>  > `1.0000e+00`>输出里面的 `6.1232e-17` 是浮点数表示不精确的后果，把它理解成 0就对了。 我们上面已经提到了 `vec` 实际上是 `Col`，双精度浮点数类型的列矢量。自然，Armadillo也有行矢量  `rowvec`（即`Row`），也可以使用其他的数字类型，如 `int`、 `float` 和`complex`。此外，除了大小不确定的线性代数对象之外，Armadillo也提供了固定大小的子类型，如 `vec::fixed` 和`mat::fixed`；为方便使用，还提供了不少别名，如 `imat22` 代表`Mat::fixed`等。固定大小的对象不需要动态内存分配，使用上有一定的性能优势。Armadillo 是一个非常复杂的库，它的头文件数量超过了 500个。我们今天不可能、也不必要描述它的所有功能，只能稍稍部分列举一下：1.  除了目前提到的列矢量、行矢量和矩阵外，Armadillo    也支持三维的数据立方体，        `Cube` 模板。        2.  Armadillo 支持稀疏矩阵，        `SpMat`    模板。    3.  除了数学上的加、减、乘运算，Armadillo    支持按元素的乘法、除法、相等、不等、小于比较等（使用           `%`、        `/`、        `==`、        `!=`、        `）：    cout   > `New position:`>>>  > `0.0000`>>>  > `1.0000`>记得我们说过 `vec` 是 `Col`的别名，因此输出是多行的。我们要输出成单行的话，转置（transpose）一下就可以了：    cout   > `New position:`>>>  > `0.0000 1.0000`>表达式模板如果你奇怪前面 `dgemv_` 为什么有 11个参数，这里有个我没有提的细节是，它执行的实际上是个复合操作：  .ps} {slate-type="block-katex" ]{.strutstyle="height:0.63888em;vertical-align:-0.19444em;"}[[y]{.mord .mathbfstyle="margin-right:0.01597em;"}]{.mord}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[←]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}]{.base}[[]{.strutstyle="height:0.68611em;vertical-align:0em;"}[α]{.mord .mathdefaultstyle="margin-right:0.0037em;"}[[A]{.mord .mathbf}]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[⋅]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:0.66666em;vertical-align:-0.08333em;"}[[x]{.mord.mathbf}]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[+]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:0.8888799999999999em;vertical-align:-0.19444em;"}[β]{.mord.mathdefault style="margin-right:0.05278em;"}[[y]{.mord .mathbfstyle="margin-right:0.01597em;"}]{.mord}]{.base}]{.katex-htmlaria-hidden="true"}]{.katex}]{.katex-display} {.ps__rail-x style="left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 0px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}如果你只是简单地做乘法的话，就相当于 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[α]{.mord .mathdefaultstyle="margin-right:0.0037em;"}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}slate-type="inline-katex"  为1、 [[[]{.strutstyle="height:0.8888799999999999em;vertical-align:-0.19444em;"}[β]{.mord.mathdefault style="margin-right:0.05278em;"}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}slate-type="inline-katex"  为 0的特殊情况。那么问题来了，如果你真的写了类似于上面这样的公式的话，编译器和线性代数库能不能转成合适的调用、而没有额外的开销呢？答案是，至少在某些情况下是可以的。秘诀就是表达式模板（expressiontemplate）\[8\。那什么是表达式模板呢？我们先回过去看我上面的例子。有没有注意到我写的是：    arma::vec new_pos = rot * pos;而没有使用 `auto` 来声明？其中部分的原因是，`rot * pos` 的类型并不是`vec`，而是：    const Glue, Col, glue_times>换句话说，结果是一个表达式，而并没有实际进行计算。如果我用 `auto`的话，行为上似乎一切都正常，但我每次输出这个结果时，都会重新进行一次矩阵的乘法！而我用 `arma::vec`接收的话，构造时就直接进行了计算，存储了表达式的结果。上面的简单例子不能实际触发对 `dgemv_`的调用，我用下面的代码实际验证出了表达式模板产生的优化（`fill::randu`表示对矢量和矩阵的内容进行随机填充）：    #include     #include     using namespace std;    using namespace arma;    int main()    {      vec x(8, fill::randu);      mat r(8, 8, fill::randu);      vec result = 2.5 * r * x;      cout ,                   eop_scalar_times>,               Col, glue_times>当使用这个表达式构造 `vec` 时，就会实际发生对 `dgemv_`的调用。我也确实跟踪到了，在将要调用 `dgemv_`时，标量值 2.5 确实在参数 `alpha`指向的位置上（这个接口的参数都是指针）。从上面的描述可以看到，表达式模板是把双刃剑：既可以提高代码的性能，又能增加代码被误用的可能性。在可能用到表达式模板的地方，你需要注意这些问题。平台细节Armadillo 的文档里说明了如何从源代码进行安装，但在 Linux 和 macOS下通过包管理器安装可能是更快的方式。在 CentOS 下可使用`sudo yum install armadillo-devel`，在 macOS 下可使用`brew install armadillo`。使用包管理器一般也会同时安装常见的依赖软件，如ARPACK 和 OpenBLAS。在 Windows 上，Armadillo 的安装包里自带了一个基本版本的 64 位 BLAS 和LAPACK 库。如果需要更高性能或 32位版本的话，就需要自己另外去安装了。除非你只是做一些非常简单的线性代数计算（就像我今天的例子），那直接告诉Armadillo不要使用第三方库也行。>  > `cl /EHsc /DARMA_DONT_USE_BLAS /DARMA_DONT_USE_LAPACK …`>Boost.Multiprecision众所周知，C 和C++（甚至推而广之到大部分的常用编程语言）里的数值类型是有精度限制的。比如，上一讲的代码里我们就用到了`INT_MIN`，最小的整数。很多情况下，使用目前这些类型是够用的（最高一般是64 位整数和 80位浮点数）。但也有很多情况，这些标准的类型远远不能满足需要。这时你就需要一个高精度的数值类型了。有一次我需要找一个高精度整数类型和计算库，最后找到的就是Boost.Multiprecision \[9\。它基本满足我的需求，以及一般意义上对库的期望：1.  正确实现我需要的功能        2.  接口符合直觉、易用        3.  有良好的性能        正确实现功能这点我就不多讲了。这是一个基本出发点，没有太多可讨论的地方。在我上次的需求里，对性能其实也没有很高的要求。让我对Boost.Multiprecision满意的主要原因，就是它的接口了。接口易用性我在  [\[第 12讲\]  提到了 CLN。它对我来讲就是个反面教材。它的整数类型不仅不提供 `%`运算符，居然还不提供 `/`运算符！它强迫用户在下面两个方案中做出选择：1.  使用         `truncate2`    函数，得到一个商数和余数        2.  使用         `exquo`    函数，当且仅当可以整除的时候        不管作者的设计原则是什么，这简直就是易用性方面的灾难了------不仅这些函数要查文档才能知晓，而且有的地方我真的只需要简单的除法呀......哦，对了，它在 Windows 编译还很不方便，而我那时用的正是Windows。 Boost.Multiprecision的情况则恰恰相反，让我当即大为满意：1.  使用基本的         `cpp_int` 对象不需要预先编译库，只需要 Boost    的头文件和一个好的编译器。        2.  常用运算符         `+`、        `-`、        `*`、        `/`、        `%`    一个不缺，全部都有。        3.  可以自然地通过整数和字符串来进行构造。        4.  提供了用户自定义字面量来高效地进行初始化。        5.  在使用 IO 流时，输入输出既可以使用十进制，也可以通过        `hex`    来切换到十六进制。        下面的代码展示了它的基本功能：    #include     #include     #include     using namespace std;    int main()    {      using namespace boost::        multiprecision::literals;      using boost::multiprecision::        cpp_int;      cpp_int a =        0x123456789abcdef0_cppi;      cpp_int b = 16;      cpp_int c{"0400"};      cpp_int result = a * b / c;      cout   > `123456789abcdef`>>>  > `81985529216486895`>我们可以看到，`cpp_int` 可以通过自定义字面量（后缀`_cppi`；只能十六进制）来初始化，可以通过一个普通整数来初始化，也可以通过字符串来初始化（并可以使用 `0x` 和 `0`前缀来选择十六进制和八进制）。拿它可以正常地进行加减乘除操作，也可以通过IO 流来输入输出。性能Boost.Multiprecision 使用了表达式模板和 C++11的移动来避免不必要的拷贝。后者当然是件好事，而前者曾经坑了我一下------我第一次使用Boost.Multiprecision 时非常困惑为什么我使用 `half(n - 1)`调用下面的简单函数居然会编译不过：    template     inline N half(N n)    {      return n / 2;    }我的意图当然是 `N` 应当被推导为 `cpp_int`，`half` 的结果也是`cpp_int`。可实际上，`n - 1` 的结果跟上面的 Armadillo展示的情况类似，是另外一个单独的类型。我需要把 `half(n - 1)`改写成  `half(N(n - 1))`才能得到期望的结果。我做的计算挺简单，并不觉得表达式模板对我的计算有啥帮助，所以我最后是禁用了表达式模板：    typedef boost::multiprecision::      number,        boost::multiprecision::et_off>        int_type;类似于 Armadillo 可以换不同的 BLAS 和 LAPACK实现，Boost.Multiprecision 也可以改换不同的后端。比如，如果我们打算使用GMP \[10\ 的话，我们需要包含利用 GMP 的头文件，并把上面的 `int_type`的定义修正一下：    #include     typedef boost::multiprecision::      number        int_type;注意，我并不是推荐你换用GMP。如果你真的对性能非常渴求的话，应当进行测试来选择合适的后端。否则缺省的后端易用性最好------比如，使用GMP后端就不能使用自定义字面量了。我当时寻找高精度算术库是为了做 RSA加解密。计算本身不复杂，属于编程几小时、运行几毫秒的情况。如果你有兴趣的话，可以看一下我那时的挑选过程和最终代码\[11\。Boost 里好东西很多，远远不止这一样。下一讲我们就来专门聊聊Boost。 内容小结本讲我们讨论了两个进行计算的模板库，Armadillo 和Boost.Multiprecision，并讨论了它们用到的表达式模板技巧和相关的计算库，如BLAS、LAPACK 和 GMP。可以看到，使用 C++你可以站到巨人肩上，轻松写出高性能的计算代码。课后思考性能和易用性往往是有矛盾的。你对性能和易用性有什么样的偏好呢？欢迎留言与我分享。参考资料\[1\] Wikipedia, "Basic Linear Algebra Subprograms".https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprogramsslate-object="mark"} \[2\] Wikipedia, "LAPACK". slate-object="mark"}https://en.wikipedia.org/wiki/LAPACKslate-object="mark"} \[3\] Wikipedia, "ARPACK". slate-object="mark"}https://en.wikipedia.org/wiki/ARPACKslate-object="mark"} \[4\] Zhang Xianyi et al., OpenBLAS.https://github.com/xianyi/OpenBLASslate-object="mark"} \[5\] Intel, Math Kernel Library.https://software.intel.com/mklslate-object="mark"} \[6\] Ilya Yaroshenko, mir-glas.https://github.com/libmir/mir-glasslate-object="mark"} \[7\] Conrad Sanderson and Ryan Curtin, "Armadillo: C++ library forlinear algebra & scientific computing".http://arma.sourceforge.net/slate-object="mark"} \[8\] Wikipedia, "Expression templates".https://en.wikipedia.org/wiki/Expression_templatesslate-object="mark"} \[9\] John Maddock, Boost.Multiprecision.https://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.htmlslate-object="mark"} \[10\] The GNU MP bignum library.https://gmplib.org/slate-object="mark"} \[11\] 吴咏炜, "Choosing a multi-precision library for C++---acritique". https://yongweiwu.wordpress.com/2016/06/04/choosing-a-multi-precision-library-for-c-a-critique/slate-object="mark"} 