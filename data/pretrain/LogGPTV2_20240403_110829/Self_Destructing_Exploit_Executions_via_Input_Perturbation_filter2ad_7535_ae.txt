17m 21s
4m 20s
12m 41s
8m 19s
1m 38s
2m 17s
6m 9s
2m 58s
8m 17s
7m 41s
20m 35s
8m 21s
12m 51s
2m 43s
14m 5s
0s
5s
1h 40m
31m 14s
6h 21m
1h 28m
1h 56m
5h 41m
4Static Analysis Phase
A. Performance
Performance for Programs with Vulnerabilities (i.e., those
in Table II). To evaluate the runtime overhead of A2C, we
run both the original program and the instrumented version 10
times and take the average. We use large inputs. For example,
we use document ﬁles that are larger than 10MB to test ﬁle
processing programs unrtf, Xerces-C, and gif2png. As
such, the native executions usually last for more than a few
10
seconds. For the programs that require user interactions, we
force them to quit after they load, process, and render the
inputs, and before they take any user interactions. We manually
identify the locations in the source ﬁles that indicate such
status (e.g., before calling a function to change the status bar to
show the input is successfully loaded and rendered) and insert
exit() to these locations. We then measure the overhead
for these shortened executions. Note that, this usually leads
to over-approximation of the overhead as our instrumentation
largely lies in the initial input loading and parsing logic.
Fig. 11. Normalized Overhead on Programs in Table II.
Fig. 11 shows the result. The average overhead is 6.11%.
In most cases, the overhead is less then 6%. There are a
few exceptions. Programs dedicated to processing and parsing
input ﬁles such as make, Xerces-C, unrtf, and gif2png
have relatively higher overhead. This is because the instru-
mented statements are being executed throughout the execu-
tion. Also, the programs that require interactions, e.g., mupdf,
chemtool, and vfu, have relatively higher overhead. This
is because of the way we measure the overhead. apache has
the highest overhead (9.84%) due to the complex structure of
input ﬁlters that leads to many constant strings being encoded.
Fig. 12. Normalized Overhead on SPEC CPU2006.
SPEC CPU2006. We also evaluate the performance of A2C
on SPEC CPU2006. We run both the original and instrumented
programs 10 times using the reference inputs. Fig. 12 shows
the result. The average overhead is 8.18%. 401.perlbench,
403.gcc, and 483.xalancbmk have relatively higher over-
head because they process inputs intensively. 456.hmmer has
9.94% overhead as it processes inputs even during the execu-
tion of its main algorithm. 429.mcf and 462.libquantum
have extremely low overhead, less than 1.5%. This is because
they process inputs once at the very beginning. As such, A2C
only needs to decode at the beginning and the rest of the
execution does not cause any overhead. The average overhead
for all 30 programs including programs in Table II and SPEC
CPU2006 is 6.94% and the geometric mean is 5.94%.
0%2%4%6%8%10%6.11% 0%2%4%6%8%10%12%14%8.18% TABLE III.
EVALUATION RESULTS FOR ATTACK PREVENTION.
# of Inputs
(Mal./Benign)
# of
Vulnerabilities
# of Payloads
(Shellcode/ROP)
# of Crashes
(Mal./Benign)
# of ins. exec.
in Payloads
# of ROP Gadgets
Exec. in Payloads
Precision/Recall
Program
mupdf
mcrypt
sftp
yops
nginx
ngircd
unrar
prozilla
gif2png
mp3info
fcrackzip
chemtool
vfu
unrtf
rarcrack
make
Xerces-C
apache#
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
10 / 20
1 (CVE-2014-2013)
1 (EDB-ID: 9264)
1 (EDB-ID: 14976)
1 (CVE-2013-2028)*
1 (EDB-ID: 17611)
1 (CVE-2009-5018)
1 (CVE-2006-2465)
1 (EDB-ID: 14904)
1 (EDB-ID: 36024)
1 (EDB-ID: 35450)
1 (CVE-2004-1297)
1 (EDB-ID: 34164)
1 (CVE-2015-0252)
21
22
23
24
25
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
50 / 50
2(CVE: 2005-0226, 2005-0199)
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
1000 / 0
3.62
3.62
3.6
3.62
3.62
3.62
3.62
3.6
3.62
3.62
3.62
3.6
3.61
3.62
3.62
3.62
3.62
3.6
0.1
0.18
0.08
0.05
0.09
0.11
0.18
0.09
0.09
0.05
0.05
0.18
0.18
0.18
0.05
0.18
0.07
0.13
3(CVE: 2005-0523, 2004-1120)
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
100% / 100%
1(CVE: 2012-4409, 2012-4527)
4(EDB-ID: 15062, 15054)
5(CVE: 2004-0940, 2006-3747)
*This CVE includes multiple vulnerabilities
#Version 1.3.31
B. Effectiveness
To evaluate the effectiveness of A2C in preventing attacks
and allowing benign executions, for each program, we prepare
10 exploits and 20 other benign inputs. For each exploit input,
we prepare 100 different malicious payloads, including 50
shellcodes and 50 ROP payloads.
The shellcodes are generated from [51], and we use ROP
attack creators [52], [53] to generate 50 different ROP payloads
for each vulnerable application. Thus, we have 1,000 attack
executions and 20 benign executions for each program. Note
that, as shown in Table III Column 3, some programs have
more than one vulnerability, which require unique exploit
inputs. The table also shows the results. Observe in the ﬁfth
column, A2C successfully crashes all the attacks and allows
all the benign inputs to proceed to normal termination and
produce the expected outcomes. The next two columns show
the average number of payload/gadget instructions that got
executed before crashing. They are all in very small numbers.
As such, they can hardly cause any damage to the system.
Decoding Frontier (DF) Operation Classiﬁcation. We fur-
ther analyze the DF operations for all the subject programs and
classify them into a few categories. Fig. 13 shows the results,
from which we have the following observations.
Fig. 13. Different Types of Decoding Frontiers.
First, 63% operations on DFs are Comparative Operations.
Note that comparative operations are mostly conducted on
individual buffer elements (of primitive types), A2C only
decodes the element needed by the operation. The decoded
value is dead (e.g., overwritten) right after the operation.
Such DF operations cannot be exploited. Second, 19% DF
operations are Terminal Operations. For a terminal operation,
11
A2C ﬁrst copies the original buffer to a temporary buffer, and
then decodes the temporary buffer. Also, after the terminal
operation, A2C releases the temporary buffer to minimize
the attack window. Third, we also identify a few kinds of
Uncontrollable Transformative Operations. In particular, Type
Widening expands each element in a buffer by padding it
with some speciﬁc byte(s) such as 0x00. Note that we use
the constraint solver to determine whether each case of type
widening is controllable as not all type widening cases are
uncontrollable. In fact, casting a one-byte data type to a two-
byte data type is solvable in many cases. Note that some binary
operations (e.g., multiplication) of values with smaller types
yield a value of a large type. These are not type-widening as the
bits in the resulting value are often fully/largely controllable.
Irreversible Calculation means arithmetic transformations that
cause intensive correlations among values so that the solver
returns UNSAT for all tests. An example can be found in
Section IV-A. Primitive type conversion means that a buffer el-
ement is converted to a value of primitive type (e.g., atof())
and this value is not stored to any array/buffer. Since single
primitive values can hardly be exploited to inject payloads
due to the size, decoding is safe. Note that A2C protects
consecutive primitive values if they can form a region larger