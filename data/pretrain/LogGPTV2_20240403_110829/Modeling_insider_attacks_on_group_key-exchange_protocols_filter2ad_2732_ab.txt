with possibly di(cid:11)erent groups of participants; following [2],
we model this via the use of instances, and denote instance
i of player U as (cid:5)i
U . We treat session IDs in a di(cid:11)erent
manner than [7, 23], and follow [4, 13, 14] in assuming that
unique session IDs are provided by some higher-level proto-
col when the group key-exchange protocol is (cid:12)rst initiated.
Thus, all members taking part in a given execution of a pro-
tocol will de facto have the same session ID. Besides being
more in line with the way session IDs are handled in the UC
framework, this also simpli(cid:12)es matters in the group setting
where each player’s view (i.e., transcript) of a single execu-
tion of the protocol may be di(cid:11)erent (this is in contrast to
the two-party setting, where two players executing a proto-
col (without interference from the adversary) obtain identi-
cal transcripts and hence the session ID can be de(cid:12)ned as
some function of this common transcript). Moreover, since
a single player may be running multiple instances of a group
key-exchange protocol concurrently, players in practice need
a way to distinguish the sessions to which incoming messages
belong. Thus, in some sense, pre-de(cid:12)ned session IDs are im-
plicit in the models of [7, 23] anyway.
U (denoted pidi
U is denoted sidi
The session ID of instance (cid:5)i
U . The part-
ner ID of instance (cid:5)i
U ) is a set containing
the identities of the players in the group with whom (cid:5)i
U
intends to establish a session key, including U itself. The
value of pidi
U , when instance
(cid:5)i
U (cid:12)rst initiates the protocol. Session IDs and partner IDs
are public information.
U is established, along with sidi
We say an instance (cid:5)i
U accepts when it computes a valid
session key ski
U . (An instance may also terminate without
accepting, and in this case it does not output any session key
at all. Whether or not a particular instance has accepted or
has instead terminated without acceptance is public infor-
mation.) If an instance computes a session key ski
U , we as-
sume it outputs (sidi
U ). Once an instance accepts,
it remains in an accepting state. Finally, we say instances
U 0 (with U 6= U 0) are partnered i(cid:11) (1) they have
(cid:5)i
both accepted; (2) sidi
U and (cid:5)j
U ; pidi
U ; ski
U = sidj
U 0 ; and (3) pidi
U = pidj
U 0 .
Correctness. We de(cid:12)ne correctness following [7, 8, 9, 23]
by requiring that if the adversary honestly forwards all mes-
sages between instances of players in a given set pid, and
each such instance holds the same value sid, then these in-
stances all accept and output identical session keys.
Adversarial model. Actions of an adversary are modeled
using various oracles:
(cid:15) Execute(sid; pid) prompts a complete execution of the
protocol between unused instances of players in pid
(using session ID sid), and outputs a transcript of the
execution. This models passive attacks.
(cid:15) Send(U; i; M ) sends message M to instance (cid:5)i
U and
outputs the response. The query Send(U; i; (sid; pid))
is used to prompt (cid:5)i
U to initiate the protocol using
session ID sid and partner ID pid (where we require
U 2 pid).
(cid:15) Reveal(U; i) provides the adversary with the session
U , assuming this instance has
U of instance (cid:5)i
key ski
accepted.
(cid:15) Corrupt(U ) outputs the long-term secret key SKU of
player U . This models corruption of the long-term
state of this player, or corruption of this player at a
time when it is not currently executing the protocol.
(cid:15) Test(U; i) does not correspond to any real-world action,
but provides a means of de(cid:12)ning security (see below).
This query is allowed only when (cid:5)i
U has accepted. In
response to this oracle call, a random bit b is chosen.
If b = 0 a random session key is output, while if b = 1
the session key ski
U is output. The adversary is allowed
to access this oracle once, at any time.
For Execute and Send queries, we require that any sid is
used by at most a single instance of a given player. The
above de(cid:12)nition of the Corrupt oracle corresponds to the so-
called weak corruption model. It is also possible to consider
the strong corruption model whereby Corrupt(U ) returns the
internal state of any active instances of U in addition to U ’s
long-term secret key.
U is associated with session (sid; pid) if sidi
AKE security. We de(cid:12)ne AKE-security following [7, 23].
Say instance (cid:5)i
U =
sid and pidi
U = pid. We say a player U is corrupted if the
adversary queries Corrupt(Ui). We de(cid:12)ne two notions2 of
freshness: in the weak corruption model, an instance (cid:5)i
U as-
sociated with session (sid; pid) is considered unfresh if (1) the
adversary queried Reveal(U 0; j) for any instance (cid:5)j
U 0 asso-
ciated with (sid; pid), or (2) the adversary corrupted some
player in pid before every instance associated with (sid; pid)
had terminated. In the strong corruption model, instance
(cid:5)i
U is considered unfresh if (1) as above, or (2) the adversary
corrupted some player in pid before (cid:5)i
U terminated. (Note
that the strong corruption model is strictly stronger than
the weak corruption model.) All other instances are consid-
ered fresh. The adversary succeeds (denoted by event Succ)
if it queries the Test oracle regarding a fresh instance, and
correctly guesses the value of the bit b used by the Test ora-
cle in answering this query. De(cid:12)ne the advantage of adver-
sary A attacking protocol (cid:25) to be Advake
2 j.
A;(cid:25)
2Our compiler will be applied to protocols secure in the weak
corruption model, and will result in protocols secure in the
strong corruption model. Thus, we provide a relatively weak
de(cid:12)nition of the former but a strong de(cid:12)nition of the latter.
= j Pr[Succ] (cid:0) 1
def
Protocol (cid:25) is said to be AKE-secure if, for any poly-time ad-
versary A, the advantage Advake
A;(cid:25) is negligible (as a function
of the security parameter). Note that our de(cid:12)nition of fresh-
ness automatically ensures that AKE-security encompasses
forward secrecy.
The protocol of [23], in particular, is shown there to be
AKE-secure in the weak corruption model.
2.1 Modeling Insider Attacks within the Above
Framework
Here, we provide de(cid:12)nitions of insider attacks within the
AKE-security model of the previous section. Although the
de(cid:12)nitions given here will be superseded by the de(cid:12)nitions
of the following section, these de(cid:12)nitions may be of inde-
pendent interest as they appear to be the (cid:12)rst formal def-
initions of insider security for group key exchange within
the AKE-security framework. We (cid:12)rst de(cid:12)ne a notion of
agreement and then de(cid:12)ne security against insider imper-
sonation attacks. The (cid:12)rst notion was suggested in [23],
and is also implicit in the security de(cid:12)nitions of [13, 14] (for
the two-party case). Our de(cid:12)nition of insider impersonation
attacks is stronger than the numerous varieties of insider at-
tacks considered in [27, 16] (in particular, a protocol secure
against our notion of insider impersonation attacks is also
secure with respect to all the notions considered in [19, 27,
16]) with the exception that we do not consider so-called
key compromise impersonation (KCI) attacks in which an
adversary corrupts a player U and then impersonates other
(uncorrupted) players to (uncorrupted instances of) U . The
primary reason we do not consider such attacks is a tech-
nical one: when we move to the UC framework a player
is either corrupted or not and so such an attack no longer
makes sense (namely, there is no longer any such thing as
an \uncorrupted instance" of a corrupted player U ). We
remark, however, that our compiler of Section 4.2 is easily
seen to prevent KCI attacks.
Our notion of agreement requires that any partnered in-
stances (of uncorrupted players) agree on the session key
they output.
(Recall that if two instances are partnered,
then by de(cid:12)nition they have accepted. Agreement does not
require that either all parties involved in an execution of the
protocol accept or else no parties accept; this is impossible
to achieve in an asynchronous model in which the adversary
controls all communication in the network.)
De(cid:12)nition 1 An adversary A violates agreement if there
U ; (cid:5)j
exist partnered instances (cid:5)i
U 0 such that (1) neither U
U 6= skj
nor U 0 are corrupted, but (2) ski
U 0 . We say a protocol
guarantees agreement if the probability that any poly-time
adversary violates agreement is negligible.
}
U ; pidi
U 0 with (sidj
U 0 ; pidj
U accepts, and (3) U 0 2 pidi
We say that an adversary impersonates U 0 to (cid:5)i
U if (1) U 0
is uncorrupted, (2) (cid:5)i
U , but
(4) there does not exist any instance (cid:5)j
U 0 ) =
(sidi
U ). Before describing notions of security against in-
sider impersonation attacks, we (cid:12)rst provide for comparison
a notion of security against outsider impersonation attacks
which does not take into account insider attacks yet is not
implied by AKE-security (see Claim 1 below).
De(cid:12)nition 2 An adversary A succeeds in an outsider im-
personation attack if there exist a party U 0 and an instance
(cid:5)i
U and (2) no play-
ers in pidi
U accepts. We say
U such that (1) A impersonates U 0 to (cid:5)i
U are corrupted at the time (cid:5)i
a protocol is secure against outsider impersonation attacks
if the probability that any poly-time adversary succeeds in
the above attack is negligible.
}
We now extend the above to encompass insider attacks.
U such that (1) A impersonates U 0 to (cid:5)i
De(cid:12)nition 3 An adversary A succeeds in an insider im-
personation attack if there exist a party U 0 and an instance
(cid:5)i
U and (2) nei-
ther U nor U 0 is corrupted at the time (cid:5)i
U accepts. We say
a protocol is secure against insider impersonation attacks if
the probability that any poly-time adversary succeeds in the
above attack is negligible.
}
Note that security against insider impersonation attacks im-
plies security against outsider impersonation attacks.
As useful shorthand, we will say that a protocol is secure
against insider attacks if it is AKE-secure, secure against
insider impersonation attacks, and guarantees agreement.
It is not hard to see that an AKE-secure protocol need not
be secure against insider attacks: In fact, an AKE-secure
protocol does not even guarantee security against outsider
impersonation attacks.
Claim 1. There exists (under standard cryptographic as-
sumptions) an AKE-secure protocol which is neither secure
against outsider impersonation attacks nor guarantees agree-
ment.
Proof. We describe a \silly" protocol which is AKE-
secure but which is not secure against outsider imperson-
ation attacks (we remark that there are more \natural" pro-
tocols with the same properties, but it is easiest to prove the