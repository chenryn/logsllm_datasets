# 删除key hello    $ etcdctl del  hello    1    
# 删除后指定查询版本号3,获得了hello删除前的值    $ etcdctl get hello --rev=3    hello    world2整体架构在详细和你介绍 etcd 如何实现 MVCC 特性前，我先和你从整体上介绍下 MVCC 模块。下图是 MVCC 模块的一个整体架构图，整个 MVCC 特性由 treeIndex、Backend/boltdb 组成。当你执行 MVCC 特性初体验中的 put 命令后，请求经过 gRPC KVServer、Raft 模块流转，对应的日志条目被提交后，Apply模块开始执行此日志内容。![](Images/e7e11f432ad92b7781c3cbf6367c7458.png)savepage-src="https://static001.geekbang.org/resource/image/f5/2c/f5799da8d51a381527068a95bb13592c.png"}Apply 模块通过 MVCC 模块来执行 put 请求，持久化 key-value 数据。MVCC模块将请求请划分成两个类别，分别是读事务（ReadTxn）和写事务（WriteTxn）。读事务负责处理range 请求，写事务负责 put/delete 操作。读写事务基于treeIndex、Backend/boltdb 提供的能力，实现对 key-value的增删改查功能。treeIndex 模块基于内存版 B-tree 实现了 key 索引管理，它保存了用户 key与版本号（revision）的映射关系等信息。Backend 模块负责 etcd 的 key-value 持久化存储，主要由ReadTx、BatchTx、Buffer 组成，ReadTx 定义了抽象的读事务接口，BatchTx 在ReadTx 之上定义了抽象的写事务接口，Buffer是数据缓存区。etcd 设计上支持多种 Backend 实现，目前实现的 Backend 是boltdb。boltdb 是一个基于 B+ tree 实现的、支持事务的 key-value嵌入式数据库。treeIndex 与 boltdb 关系你可参考下图。当你发起一个 get hello命令时，从 treeIndex 中获取 key 的版本号，然后再通过这个版本号，从boltdb 获取 value 信息。boltdb 的 value 是包含用户key-value、各种版本号、lease信息的结构体。![](Images/66caf1ad6f32bd653e72e89932a18c20.png)savepage-src="https://static001.geekbang.org/resource/image/e7/8f/e713636c6cf9c46c7c19f677232d858f.png"}接下来我和你重点聊聊 treeIndex模块的原理与核心数据结构。treeIndex 原理为什么需要 treeIndex 模块呢?对于 etcd v2 来说，当你通过 etcdctl 发起一个 put hello 操作时，etcdv2 直接更新内存树，这就导致历史版本直接被覆盖，无法支持保存 key的历史版本。在 etcd v3 中引入 treeIndex模块正是为了解决这个问题，支持保存 key 的历史版本，提供稳定的 Watch机制和事务隔离等能力。那 etcd v3 又是如何基于 treeIndex 模块，实现保存 key的历史版本的呢?在 02 节课里，我们提到过 etcd 在每次修改 key时会生成一个全局递增的版本号（revision），然后通过数据结构 B-tree保存用户 key 与版本号之间的关系，再以版本号作为 boltdb key，以用户的key-value 等信息作为 boltdb value，保存到boltdb。 下面我就为你介绍下，etcd 保存用户 key 与版本号映射关系的数据结构B-tree，为什么 etcd使用它而不使用哈希表、平衡二叉树？从 etcd 的功能特性上分析， 因 etcd支持范围查询，因此保存索引的数据结构也必须支持范围查询才行。所以哈希表不适合，而B-tree 支持范围查询。从性能上分析，平横二叉树每个节点只能容纳一个数据、导致树的高度较高，而B-tree每个节点可以容纳多个数据，树的高度更低，更扁平，涉及的查找次数更少，具有优越的增、删、改、查性能。Google 的开源项目 btree，使用 Go 语言实现了一个内存版的B-tree，对外提供了简单易用的接口。etcd 正是基于 btree 库实现了一个名为treeIndex 的索引模块，通过它来查询、保存用户 key与版本号之间的关系。下图是个最大度（degree \> 1，简称 d）为 5 的 B-tree，度是 B-tree中的一个核心参数，它决定了你每个节点上的数据量多少、节点的"胖"、"瘦"程度。从图中你可以看到，节点越胖，意味着一个节点可以存储更多数据，树的高度越低。在一个度为d 的 B-tree 中，节点保存的最大 key 数为 2d -1，否则需要进行平衡、分裂操作。这里你要注意的是在 etcd treeIndex模块中，创建的是最大度 32 的 B-tree，也就是一个叶子节点最多可以保存 63个 key。 ![](Images/ea62937701f722e67fc933f78721ca93.png)savepage-src="https://static001.geekbang.org/resource/image/44/74/448c8a2bb3b5d2d48dfb6ea585172c74.png"}从图中你可以看到，你通过 put/txn 命令写入的一系列 key，treeIndex模块基于 B-tree 将其组织起来，节点之间基于用户 key比较大小。当你查找一个 key k95 时，通过 B-tree的特性，你仅需通过图中流程 1 和 2 两次快速比较，就可快速找到 k95所在的节点。在 treeIndex 中，每个节点的 key 是一个 keyIndex 结构，etcd就是通过它保存了用户的 key与版本号的映射关系。那么 keyIndex结构包含哪些信息呢？下面是字段说明，你可以参考一下。    type keyIndex struct {       key         []byte //用户的key名称，比如我们案例中的"hello"       modified    revision //最后一次修改key时的etcd版本号,比如我们案例中的刚写入hello为world1时的，版本号为2       generations []generation //generation保存了一个key若干代版本号信息，每代中包含对key的多次修改的版本号列表    }keyIndex 中包含用户的 key、最后一次修改 key 时的 etcd 版本号、key的若干代（generation）版本号信息，每代中包含对 key的多次修改的版本号列表。那我们要如何理解generations？为什么它是个数组呢?generations 表示一个 key 从创建到删除的过程，每代对应 key的一个生命周期的开始与结束。当你第一次创建一个 key 时，会生成第 0代，后续的修改操作都是在往第 0 代中追加修改版本号。当你把 key删除后，它就会生成新的第 1 代，一个 key不断经历创建、删除的过程，它就会生成多个代。generation结构详细信息如下：    type generation struct {       ver     int64    //表示此key的修改次数       created revision //表示generation结构创建时的版本号       revs    []revision //每次修改key时的revision追加到此数组    }generation 结构中包含此 key 的修改次数、generation创建时的版本号、对此 key的修改版本号记录列表。你需要注意的是版本号（revision）并不是一个简单的整数，而是一个结构体。revision结构及含义如下：    type revision struct {       main int64    // 一个全局递增的主版本号，随put/txn/delete事务递增，一个事务内的key main版本号是一致的       sub int64    // 一个事务内的子版本号，从0开始随事务内put/delete操作递增    }revision 包含 main 和 sub 两个字段，main 是全局递增的版本号，它是个etcd 逻辑时钟，随着 put/txn/delete 等事务递增。sub是一个事务内的子版本号，从 0 开始随事务内的 put/delete操作递增。 比如启动一个空集群，全局版本号默认为 1，执行下面的 txn事务，它包含两次 put、一次 get操作，那么按照我们上面介绍的原理，全局版本号随读写事务自增，因此是 main为 2，sub 随事务内的 put/delete 操作递增，因此 key hello 的 revison为{2,0}，key world 的 revision为{2,1}。     $ etcdctl txn -i    compares:    success requests (get，put，del):    put hello 1    get hello    put world 2介绍完 treeIndex 基本原理、核心数据结构后，我们再看看在 MVCC特性初体验中的更新、查询、删除 key 案例里，treeIndex 与 boltdb是如何协作，完成以上 key-value操作的? MVCC 更新 key 原理当你通过 etcdctl 发起一个 put hello 操作时，如下面的 put事务流程图流程一所示，在 put 写事务中，首先它需要从 treeIndex 模块中查询key 的 keyIndex 索引信息，keyIndex 中存储了 key的创建版本号、修改的次数等信息，这些信息在事务中发挥着重要作用，因此会存储在boltdb 的 value 中。在我们的案例中，因为是第一次创建 hello key，此时 keyIndex索引为空。 ![](Images/b6dd0669594419948d289330ef7a6022.png)savepage-src="https://static001.geekbang.org/resource/image/84/e1/84377555cb4150ea7286c9ef3c5e17e1.png"}其次 etcd 会根据当前的全局版本号（空集群启动时默认为 1）自增，生成put hello 操作对应的版本号 revision{2,0}，这就是 boltdb 的key。 boltdb 的 value 是 mvccpb.KeyValue 结构体，它是由用户key、value、create_revision、mod_revision、version、lease组成。它们的含义分别如下：1.  create_revision 表示此 key 创建时的版本号。在我们的案例中，key    hello 是第一次创建，那么值就是 2。当你再次修改 key hello    的时候，写事务会从 treeIndex 模块查询 hello    第一次创建的版本号，也就是 keyIndex.generations\[i\].created    字段，赋值给 create_revision    字段；    2.  mod_revision 表示 key 最后一次修改时的版本号，即 put    操作发生时的全局版本号加    1；    3.  version 表示此 key 的修改次数。每次修改的时候，写事务会从    treeIndex 模块查询 hello 已经历过的修改次数，也就是    keyIndex.generations\[i\].ver 字段，将 ver 字段值加 1 后，赋值给    version 字段。        填充好 boltdb 的 KeyValue 结构体后，这时就可以通过 Backend 的写事务batchTx 接口将 key{2,0},value 为 mvccpb.KeyValue 保存到 boltdb的缓存中，并同步更新buffer，如上图中的流程二所示。此时存储到 boltdb 中的 key、value数据如下： ![](Images/8dd7df7be50c550f06b3b21f0c8574c6.png)savepage-src="https://static001.geekbang.org/resource/image/a2/ba/a245b18eabc86ea83a71349f49bdceba.jpg"}然后 put 事务需将本次修改的版本号与用户 key 的映射关系保存到treeIndex模块中，也就是上图中的流程三。因为 key hello 是首次创建，treeIndex 模块它会生成 key hello 对应的keyIndex对象，并填充相关数据结构。keyIndex填充后的结果如下所示：    key hello的keyIndex:    key:     "hello"    modified:     generations:    [{ver:1,created:,revisions: []} 我们来简易分析一下上面的结果。1.  key 为 hello，modified 为最后一次修改版本号 \，key hello    是首次创建的，因此新增一个 generation    代跟踪它的生命周期、修改记录；        2.  generation 的 ver 表示修改次数，首次创建为    1，后续随着修改操作递增；        3.  generation.created 表示创建 generation 时的版本号为    \；        4.  revision 数组保存对此 key    修改的版本号列表，每次修改都会将将相应的版本号追加到 revisions    数组中。        通过以上流程，一个 put操作终于完成。但是此时数据还并未持久化，为了提升 etcd的写吞吐量、性能，一般情况下（默认堆积的写事务数大于 1万才在写事务结束时同步持久化），数据持久化由 Backend 的异步 goroutine完成，它通过事务批量提交，定时将 boltdb页缓存中的脏数据提交到持久化存储磁盘中，也就是下图中的黑色虚线框住的流程四。![](Images/896a7a97d98c05e3fa638c6f35f1894e.png)savepage-src="https://static001.geekbang.org/resource/image/5d/a2/5de49651cedf4595648aeba3c131cea2.png"}MVCC 查询 key 原理完成 put hello 为 world1 操作后，这时你通过 etcdctl 发起一个 gethello 操作，MVCC 模块首先会创建一个读事务对象（TxnRead），在 etcd 3.4 中Backend 实现了 ConcurrentReadTx，也就是并发读特性。并发读特性的核心原理是创建读事务对象时，它会全量拷贝当前写事务未提交的buffer 数据，并发的读写事务不再阻塞在一个 buffer资源锁上，实现了全并发读。![](Images/be776632eaa0baa77123ba69e5521d7b.png)savepage-src="https://static001.geekbang.org/resource/image/55/ee/55998d8a1f3091076a9119d85e7175ee.png"}如上图所示，在读事务中，它首先需要根据 key 从 treeIndex模块获取版本号，因我们未带版本号读，默认是读取最新的数据。treeIndex模块从 B-tree 中，根据 key 查找到 keyIndex 对象后，匹配有效的generation，返回 generation 的 revisions数组中最后一个版本号{2,0}给读事务对象。读事务对象根据此版本号为 key，通过 Backend的并发读事务（ConcurrentReadTx）接口，优先从 buffer中查询，命中则直接返回，否则从 boltdb 中查询此 key 的 value信息。 那指定版本号读取历史记录又是怎么实现的呢？当你再次发起一个 put hello 为 world2 修改操作时，key hello 对应的keyIndex 的结果如下面所示，keyIndex.modified 字段更新为\，generation 的 revision 数组追加最新的版本号 \，ver 修改为2。     key hello的keyIndex:    key:     "hello"    modified:     generations:    [{ver:2,created:,revisions: [,]}boltdb 插入一个新的 key revision{3,0}，此时存储到 boltdb 中的key-value 数据如下：![](Images/fd8c4e0b026d14e036dc24ace3466fe8.png)savepage-src="https://static001.geekbang.org/resource/image/8b/f7/8bec06d61622f2a99ea9dd2f78e693f7.jpg"}这时你再发起一个指定历史版本号为 2 的读请求时，实际是读版本号为 2的时间点的快照数据。treeIndex 模块会遍历 generation内的历史版本号，返回小于等于 2的最大历史版本号，在我们这个案例中，也就是 revision{2,0}，以它作为boltdb 的 key，从 boltdb 中查询出 value即可。 MVCC 删除 key 原理介绍完 MVCC 更新、查询 key 的原理后，我们接着往下看。当你执行 etcdctldel hello 命令时，etcd 会立刻从 treeIndex 和 boltdb中删除此数据吗？还是增加一个标记实现延迟删除（lazydelete）呢？答案为 etcd 实现的是延期删除模式，原理与 key更新类似。 与更新 key 不一样之处在于，一方面，生成的 boltdb key版本号{4,0,t}追加了删除标识（tombstone, 简写 t），boltdb value变成只含用户 key 的 KeyValue 结构体。另一方面 treeIndex 模块也会给此 keyhello 对应的 keyIndex 对象，追加一个空的 generation对象，表示此索引对应的 key被删除了。 当你再次查询 hello 的时候，treeIndex 模块根据 key hello 查找到keyindex 对象后，若发现其存在空的 generation对象，并且查询的版本号大于等于被删除时的版本号，则会返回空。etcdctl hello 操作后的 keyIndex的结果如下面所示：    key hello的keyIndex:    key:     "hello"    modified:     generations:    [    {ver:3,created:,revisions: [,,(t)]}，                 {empty}    boltdb 此时会插入一个新的 key revision{4,0,t}，此时存储到 boltdb 中的key-value 数据如下：![](Images/3b422c780a1ebe9c5e517604b6712b15.png)savepage-src="https://static001.geekbang.org/resource/image/da/17/da4e5bc5033619dda296c022ac6yyc17.jpg"}那么 key打上删除标记后有哪些用途呢？什么时候会真正删除它呢？一方面删除 key 时会生成 events，Watch 模块根据 key的删除标识，会生成对应的 Delete事件。 另一方面，当你重启 etcd，遍历 boltdb 中的 key 构建 treeIndex内存树时，你需要知道哪些 key 是已经被删除的，并为对应的 key 索引生成tombstone 标识。而真正删除 treeIndex 中的索引对象、boltdb 中的 key是通过压缩 (compactor)组件异步完成。正因为 etcd 的删除 key操作是基于以上延期删除原理实现的，因此只要压缩组件未回收历史版本，我们就能从etcd 中找回误删的数据。小结最后我们来小结下今天的内容，我通过 MVCC特性初体验中的更新、查询、删除 key 案例，为你分析了 MVCC整体架构、核心模块，它由 treeIndex、boltdb组成。 treeIndex 模块基于 Google 开源的 btree 库实现，它的核心数据结构keyIndex，保存了用户 key 与版本号关系。每次修改 key都会生成新的版本号，生成新的 boltdb key-value。boltdb 的 key为版本号，value 包含用户 key-value、各种版本号、lease 的 mvccpb.KeyValue结构体。 当你未带版本号查询 key 时，etcd 返回的是 key最新版本数据。当你指定版本号读取数据时，etcd实际上返回的是版本号生成那个时间点的快照数据。删除一个数据时，etcd 并未真正删除它，而是基于 lazy delete实现的异步删除。删除原理本质上与更新操作类似，只不过 boltdb 的 key会打上删除标记，keyIndex 索引中追加空的 generation。真正删除 key 是通过etcd的压缩组件去异步实现的，在后面的课程里我会继续和你深入介绍。基于以上原理特性的实现，etcd 实现了保存 key 历史版本的功能，是高可靠Watch 机制的基础。基于 key-value 中的各种版本号信息，etcd可提供各种级别的简易事务隔离能力。基于 Backend/boltdb 提供的 MVCC机制，etcd 可实现读写不冲突。思考题你认为 etcd 为什么删除使用 lazy delete 方式呢？ 相比同步 delete,各有什么优缺点？当你突然删除大量 key 后，db大小是立刻增加还是减少呢？感谢你的阅读，如果你认为这节课的内容有收获，也欢迎把它分享给你的朋友，谢谢。