}
Figure 10: False positive, flagged as a prodigal contract.
because real executions may only return a single value (say true)
when the call succeeds.
(ii) Maian may assign values to symbolic variables related to block
state (e.g., blocknumber) in cases where these values are used to
decide the control flow. Thus, we may get false positives because
those values may be different at the concrete validation stage. For
instance, in Figure 10, the _guess value depends on the values of
block parameters, which cannot be forced to take on the concrete
values found by our analyzer.
Greedy contracts. The large share of false positives is attributed
to two causes:
(i) Detecting a trace which leads to release of Ether may need three
or more function invocations. For instance, in Figure 9, the func-
tion confirmTransaction has to be executed by the majority of
owners for the contract to execute the transaction. Our default
661ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Nikoli´c et al.
invocation depth is the reason for missing a possible reachable
state.
(ii) The tool is not able to recover the subtype for the generic bytes
type in the EVM semantics.
(iii) Some contracts release funds only if a random number (usually
generated using transaction and block parameters) matches a
predetermined value unlike in the case of the contract in Fig-
ure 10. In that contract the variable _guess is also a symbolic
variable, hence, the solver can find a solution for condition on
line 7. If there is a concrete value in place of _guess, the solver
times out since the constraint involves a hash function (hard to
invert by the SMT solver).
5.4 Summary and Observations
The symbolic execution engine of Maian flags 34, 200 contracts.
With concrete validation engine or manual inspection, we have
confirmed that around 97% of prodigal, 97% of suicidal and 69% of
greedy contracts are true positive. The importance of analyzing
the bytecode of the contracts, rather than Solidity source code, is
demonstrated by the fact that only 1% of all contracts have source
code. Further, among all flagged contracts, only 181 have verified
source codes according to the widely used platform Etherscan, or
in percentages only 1.06%, 0.47% and 0.49%, in the three categories
of prodigal, suicidal, and greedy, respectively. We refer the reader
to Table 1 for the exact summary of these results.
Furthermore, the maximal amount of Ether that could have been
withdrawn from prodigal and suicidal contracts, before the block
height BH, is nearly 4, 905 Ether, or 3.4 million US dollars8 according
to the exchange rate at the time of this writing. In addition, 6, 239
Ether (4.3 million US dollars) is locked inside posthumous contracts
currently on the blockchain, of which 313 Ether (216, 000 US dollars)
were sent to dead contracts after they have been killed.
Finally, the analysis given in Table 2 shows the number of flagged
contracts for different invocation depths from 1 to 4. We tested
25, 000 contracts being for greedy, and 100, 000 for remaining cate-
gories, inferring that increasing depth improves results marginally,
and an invocation depth of 3 is an optimal tradeoff point. Table 2
clearly shows that reasoning about contract traces, rather than a
single contract invocation, reveals more vulnerabilities of prodigal
and suicidal type. Compared to a single invocation, analysis based
on two invocations detects an additional 10% − 20% contracts with
potential bugs. Besides this quantitative increase, there is as well a
particular qualitative increase of flagged contracts. Specifically, con-
tracts that can be exploited by executing a two-invocation trace on
average tend to be more complex and thus finding the vulnerability
manually requires more effort.
Note, we have contacted the Ethereum Foundation for an ethical
disclosure procedure, and we have given then the full list of found
vulnerable contracts.
6 RELATED WORK
Security and safety properties of smart contracts have received a lot
of attention since several costly bugs and exploits took place [2, 10].
Dichotomy of smart contract bugs. The majority of the bugs in
Ethereum-style smart contracts are due to the de-facto high-level
Inv. depth
1
2
3
4
Prodigal
131
156
157
157
Suicidal
127
141
141
141
Greedy
682
682
682
682
Table 2: The table shows number of contracts flagged for var-
ious invocation depths. This analysis is done on a random
subset of 25, 000–100, 000 contracts.
implementation language, Solidity [42], whose runtime behaviour
that diverge from the “intuitive understanding” of the language by
the developers.
The early work by Delmolino et al. [11] distinguishes the fol-
lowing classes of problems: (a) contracts that do not refund their
users, (b) missing encryptions of sensitive user data and (c) lack
of incentives for the users to take certain actions. The property
(a) is the closest to our notion of greedy. While that outlines the
problem and demonstrates it on series of simple examples taught in
a class, they do not provide a systematic approach for detection of
smart contracts prone to this issue. Later works on contract security
identify potential bugs, related to the concurrent transactions [40],
mishandled exceptions [26], overly extensive gas consumption [7]
and implementations of fraudulent financial schemes [5].9
In contrast to all those work, which focus on bad implementation
practices or misused language semantics, we believe, our character-
isation of several classes of contract bugs, such as greedy, prodigal,
etc, is novel, as they are stated in terms of properties execution
traces rather than particular instructions taken/states reached.
Reasoning about smart contracts. Several tools have been pro-
posed to automatic detection of vulnerabilities in smart contracts,
as well as for formal contract verification.
Oyente [26, 33] was the first tool that provided analysis targeting
several specific issues: (a) mishandled exceptions, (b) transaction-
ordering dependence, (c) timestamp dependence and (d) reentrancy [41],
thus remedying the corner cases of Solidity/EVM semantics as well
as some programming anti-patterns.
Other tools for symbolic analysis of EVM and/or Solidity have
been developed more recently: Manticore [27], Mythrill [30, 31],
Securify [39], teEther [25], and KEVM [21, 38], all focusing on
detecting low-level safety violations and vulnerabilities, such as
integer overflows, reentrancy, and unhandled exceptions, etc, nei-
ther of them requiring reasoning about contract execution traces.
While it does not seem impossible to extend all these frameworks
for handling trace-based properties discussed in this work, this
has not been done yet, thus we cannot conduct a formal compari-
son. A very recent work by Grossman et al. [19] similar to our in
spirit and providing a dynamic analysis of execution traces, focuses
exclusively on detecting non-callback-free contracts (i.e., prone to
reentrancy attacks)—a vulnerability that is by now well studied.
Concurrently with our work, Kalra et al. developed Zeus [24],
a framework for automated verification of smart contracts using
abstract interpretation and symbolic model checking, accepting
user-provided policies to verify for. Unlike Maian, Zeus conducts
8Calculated at 693 USD/ETH [12].
9See the works [4, 8] for a survey of known contract issues.
662Finding The Greedy, Prodigal, and Suicidal Contracts at Scale
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
policy checking at a level of LLVM-like intermediate representation
of a contract, obtained from Solidity code, and leverages a suite of
standard tools, such as off-the-shelf constraint and SMT solvers [9,
20, 28]. Although Zeus also flags some contracts as “suicidal” (due to
incorrect uses of selfdestruct), it does not provide a framework for
checking other trace properties, or under-approximating liveness
properties, i.e., for detecting prodigal or greedy contracts.
Various versions of EVM semantics [43] were implemented in
Coq [23], Isabelle/HOL [3, 22], F⋆ [6, 18], Idris [35], and Why3 [14,
37], followed by subsequent mechanised contract verification ef-
forts. However, none of those efforts considered trace properties in
the spirit of what we defined in Section 3.
7 CONCLUSION
We characterize vulnerabilities in smart contracts that are checkable
as properties of an entire execution trace (possibly infinite sequence
of their invocations). We show three examples of such trace vulner-
abilities, leading to greedy, prodigal and suicidal contracts. and built
a symbolic analysis tool Maian to find these. Analyzing 970, 898
contracts, Maian flags thousands of contracts vulnerable at a high
true positive rate. At a scale of nearly one million contracts, Maian
flags thousands of contracts as vulnerable, and successfully gener-
ates exploits for 69–99% of the subset we sample for validation.
ACKNOWLEDGMENTS
We thank Shruti Tople, Loi Luu, Shweta Shinde, Muoi Tran, Andreea
Costea, Teodora Baluta, and the anonymous reviewers of the paper
for their feedback. Ivica Nikolić is supported by the Ministry of
Education, Singapore under Grant No. R-252-000-560-112. Aquinas
Hobor was partially supported by Yale-NUS College grant R-607-
265-322-121. This work is supported in part by the Crystal center
at the National University of Singapore.
REFERENCES
[1] Anthony Akentiev. 2018. Parity Multisig Github. https://github.com/paritytech/
parity/issues/6995
[2] JD Alois. 2017. Ethereum Parity Hack May Impact ETH 500,000 or $146 Million.
[3] Sidney Amani, Myriam Bégel, Maksym Bortin, and Mark Staples. 2018. Towards
Verifying Ethereum Smart Contract Bytecode in Isabelle/HOL. In CPP. ACM,
66–77.
[4] Nicola Atzei, Massimo Bartoletti, and Tiziana Cimoli. 2017. A Survey of Attacks
on Ethereum Smart Contracts (SoK). In POST (LNCS), Vol. 10204. Springer, 164–
186.
[5] Massimo Bartoletti, Salvatore Carta, Tiziana Cimoli, and Roberto Saia. 2017.
Dissecting Ponzi schemes on Ethereum: identification, analysis, and impact.
CoRR abs/1703.03779 (2017).
[6] Karthikeyan Bhargavan, Antoine Delignat-Lavaud, Cédric Fournet, Anitha Gol-
lamudi, Georges Gonthier, Nadim Kobeissi, Natalia Kulatova, Aseem Rastogi,
Thomas Sibut-Pinote, Nikhil Swamy, and Santiago Zanella-Béguelin. 2016. Formal
Verification of Smart Contracts: Short Paper. In PLAS. ACM, 91–96.
[7] Ting Chen, Xiaoqi Li, Xiapu Luo, and Xiaosong Zhang. 2017. Under-optimized
smart contracts devour your money. In IEEE 24th International Conference on
Software Analysis, Evolution and Reengineering, SANER. 442–446.
[8] ConsenSys Diligence. 2018. Ethereum Smart Contract Security Best Practices.
https://consensys.github.io/smart-contract-best-practices
[9] Leonardo Mendonça de Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT
[10] Michael del Castillo. June 17, 2016. The DAO Attacked: Code Issue Leads to $60
Solver. In TACAS (LNCS), Vol. 4963. Springer, 337–340.
Million Ether Theft.
[11] Kevin Delmolino, Mitchell Arnett, Ahmed E. Kosba, Andrew Miller, and Elaine
Shi. 2016. Step by Step Towards Creating a Safe Smart Contract: Lessons and
Insights from a Cryptocurrency Lab. In FC 2016 International Workshops (LNCS),
Vol. 9604. Springer, 79–94.
[12] Etherscan 2018. https://etherscan.io/
[13] Etherscan verified source codes 2018. Etherscan verified source codes. https:
//etherscan.io/contractsVerified
[14] Jean-Christophe Filliâtre and Andrei Paskevich. 2013. Why3 - Where Programs
Meet Provers. In ESOP (LNCS), Vol. 7792. Springer, 125–128.
[15] Go-ethereum 2018. https://github.com/ethereum/go-ethereum
[16] Patrice Godefroid. 2011. Higher-order Test Generation. In PLDI. ACM, 258–269.
[17] Governmental bug 2018. GovernMental’s 1100ET H jackpot payout is stuck
because it uses too much gas. https://www.reddit.com/r/ethereum/comments/
4ghzhv/
[18] Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. 2018. A Semantic
Framework for the Security Analysis of Ethereum Smart Contracts. In POST
(LNCS), Vol. 10804. Springer, 243–269.
[19] Shelly Grossman, Ittai Abraham, Guy Golan-Gueta, Yan Michalevsky, Noam
Rinetzky, Mooly Sagiv, and Yoni Zohar. 2018. Online detection of effectively
callback free objects with applications to smart contracts. PACMPL 2, POPL
(2018), 48:1–48:28.
[20] Arie Gurfinkel, Temesghen Kahsai, Anvesh Komuravelli, and Jorge A. Navas.
2015. The SeaHorn Verification Framework. In CAV, Part I (LNCS), Vol. 9206.
Springer, 343–361.
[21] Everett Hildenbrandt, Manasvi Saxena, Nishant Rodrigues, Xiaoran Zhu, Philip
Daian, Dwight Guth, Daejun Park, Yi Zhang, Brandon Moore, and Grigore Rosu.
2018. KEVM: A Complete Semantics of the Ethereum Virtual Machine. In CSF.
IEEE. To appear.
[22] Yoichi Hirai. 2017. Defining the Ethereum Virtual Machine for Interactive The-
orem Provers. In 1st Workshop on Trusted Smart Contracts (LNCS), Vol. 10323.
Springer, 520–535.
[23] Yoichi Hirai. 2017. Ethereum Virtual Machine for Coq (v0.0.2). Published online
on 5 March 2017. https://goo.gl/DxYFwK
[24] Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. 2018. Zeus:
Analyzing Safety of Smart Contracts. In NDSS. To appear.
[25] Johannes Krupp and Christian Rossow. 2018. teEther: Gnawing at Ethereum
to Automatically Exploit Smart Contracts. In 27th USENIX Security Symposium
(USENIX Security 18). USENIX Association, Baltimore, MD, 1317–1333. https:
//www.usenix.org/conference/usenixsecurity18/presentation/krupp
[26] Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor. 2016.
Making Smart Contracts Smarter. In CCS. ACM, 254–269.
[27] Manticore 2018. https://github.com/trailofbits/manticore
[28] Kenneth L. McMillan. 2007.
[29] Mortal 2018.
VMCAI (LNCS), Vol. 4349. Springer, 89–90.
0x4671ebe586199456ca28ac050cc9473cbac829eb#code
Contract mortal.
Interpolants and Symbolic Model Checking. In
https://etherscan.io/address/
[30] Bernhard Mueller. January 2018. How Formal Verification Can Ensure Flawless
Smart Contracts. https://goo.gl/9wUFE1
[31] Mythril 2018. https://github.com/b-mueller/mythril/
[32] Satoshi Nakamoto. 2008. Bitcoin: A peer-to-peer electronic cash system. http:
//bitcoin.org/bitcoin.pdf
com/melonproject/oyente
[33] Oyente 2018. Oyente: An Analysis Tool for Smart Contracts. https://github.
[34] Parity bug 2018. The guy who blew up Parity didn’t know what he was doing.
https://www.reddit.com/r/CryptoCurrency/comments/7beos3/
[35] Jack Pettersson and Robert Edström. 2016. Safer Smart Contracts through Type-
Driven Development. Master’s thesis. Chalmers University of Technology, Swe-
den.
[36] George Pîrlea and Ilya Sergey. 2018. Mechanising blockchain consensus. In CPP.
[37] Christian Reitwiessner. 2015. Formal Verification for Solidity Contracts. https://
forum.ethereum.org/discussion/3779/formal-verification-for-solidity-contracts
[38] Grigore Rosu. December 2017. ERC20-K: Formal Executable Specification of
ACM, 78–90.
ERC20. https://runtimeverification.com/blog/?p=496
[39] Securify 2018. Securify: Formal Verification of Ethereum Smart Contracts. http:
[40] Ilya Sergey and Aquinas Hobor. 2017. A Concurrent Perspective on Smart
Contracts. In 1st Workshop on Trusted Smart Contracts (LNCS), Vol. 10323. Springer,
478–493.
http://
[41] Emin Gün Sirer. 2016. Reentrancy Woes in Smart Contracts.
hackingdistributed.com/2016/07/13/reentrancy-woes/
[42] Solidity 2018. Solidity: High-Level Language for Implementing Smart Contracts.
[43] Gavin Wood. 2014. Ethereum: A Secure Decentralised Generalised Transaction
http://solidity.readthedocs.io/
Ledger. https://ethereum.github.io/yellowpaper/paper.pdf
//securify.ch/
663