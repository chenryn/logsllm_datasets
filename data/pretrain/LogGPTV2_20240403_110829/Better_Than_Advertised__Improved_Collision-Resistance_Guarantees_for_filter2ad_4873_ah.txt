We make no value statement on how likely the improved memory
usage of Bmem is to matter in practice. Our point is simply that it
is more memory efficient and that these differences are hidden by
proofs in which the explicit reduction algorithms are not provided.
The proof of the theorem mirrors that of Theorem 5.3, only re-
quiring arguing that Bmem also correctly returns a collision when-
ever AH does.
Proof. (of Theorem 9.1) It is clear that the time and memory
complexity of adversary Ah are as stated in the theorem.
Let k ∈ h.Keys, s ∈ S be the values sampled when Ah is executed
and M1, M2 ∈ Split.Inp be the values returned by AH. We have
Split(M1) (cid:65) Split(M2) and Split(M2) (cid:65) Split(M1), so if they form a
collision for H(k,s), then they fulfill the conditions of Lemma 5.2 so
Bcr would be guaranteed to return a collision for hk. It is clear from
examining the code that if Bcr finds a collision on any input, then
Bmem will find a collision on the same input (though they might
output different collisions). As an immediate result Equation (6)
holds, completing the proof.
□
In Fig. 16 we present an analogous memory efficient algorithm
Bmem2 and the corresponding Ah which would obtain the same
sorts of memory savings for Theorem 6.4 and Theorem 7.2. For
notational convenience, the presented pseudocode of Bmem2 uses
vectors c1 and c2, but we note that they can easily be computed
only as needed using constant memory. Furthermore, we use the
Session D4:  Crypto PrimitivesCCS’17, October 30-November 3, 2017, Dallas, TX, USA904Algorithm Bmem((k, s), M1, M2)
m1 ← Split(M1) ; m2 ← Split(M2) ; n1 ← |m1| ; n2 ← |m2|
n ← min(n1, n2)
c1 ← s; c2 ← s
If (n1 > n2) then
If (n2 > n1) then
For i = 1, . . . , n do
For i = 1, . . . , n1 − n2 do c1 ← hk((m1[i], c1))
For i = 1, . . . , n2 − n1 do c2 ← hk((m2[i], c2))
1 ← hk((m1[n1 − n + i], c1))
c′
2 ← hk((m2[n2 − n + i], c2))
c′
If (c′
1 = c′
Return ((m1[n1 − n + i], c1), (m2[n2 − n + i], c2))
c1 ← c′
Return ⊥
Adversary Ah(k, ε)
s ←$ S ; (M1, M2) ← AH((k, s), ε)
Return Bmem((k, s), M1, M2)
2) and (m1[n1 − n + i], c1) (cid:44) (m2[n2 − n + i], c2) then
1; c2 ← c′
2
Figure 15: Memory efficient algorithm Bmem and adversary
Ah used for Theorem 9.1.
For i = 1, . . . , n do
Algorithm Bmem2((k, s), M1, M2)
m1 ← Split(M1) ; m2 ← Split(M2) ; n1 ← |m1| ; n2 ← |m2|
c1[1] ← s ; c2[1] ← s; n ← min(n1, n2)
If (n1 > n2) then
For i = 1, . . . , n1 − n2 do c1[i + 1] ← hk((m1[i], c1[i]))
For i = 1, . . . , n2 − n1 do c2[i + 1] ← hk((m2[i], c2[i]))
m1 ← m1[n1 − n + i]; c1 ← c1[n1 − n + i]
m2 ← m2[n2 − n + i]; c2 ← c2[n2 − n + i]
1 ← hk((m1, c1))
c′
2 ← hk((m2, c2))
c′
If (c′
1 = c′
a1 ← (m1[n1 − n + i − 1], c1[n1 − n + i − 1])
a2 ← (m2[n2 − n + i − 1], c2[n2 − n + i − 1])
Return ((m1, c1), (m2, c2), a1, a2)
2) and (m1, c1) (cid:44) (m2, c2) then
If (n2 > n1) then
c1[n1 − n + i + 1] ← c′
1
c2[n2 − n + i + 1] ← c′
2
Return ⊥
Adversary Ah(k, s)
(M1, M2) ← AH((k, s), ε)
Return Bmem2((k, s), M1, M2)
Figure 16: Memory efficient algorithm Bmem2 and adversary
Ah to improve Theorem 6.4 and Theorem 7.2.
convention that out of bounds accesses to an array are accesses
to its first element (this simplifies notation for the case that the
initialization vector is part of the collision).
We note that ACFK [4] make the claim that collision-resistance
is not a memory sensitive problem, saying for example “t-collision-
resistance is not memory sensitive for t = 2.” This seems to imply
that there is no reason to worry about memory tightness in our
setting because we are doing a reduction to collision resistance.
However, this statement is somewhat deceptive. When one unpacks
this statement, the actual claim they are making is that the best
known generic attack does not require much memory. This tells
us nothing about whether there may exist better, not yet known,
generic attacks or whether there exist better non-generic attacks
against specific hash functions for which memory is a dominating
factor.
We also observe that, as a community, there is much work to
be done in this setting to determine how the memory usage of an
adversary “should” be measured to best capture the reality. For
example, in their work ACFK observe that many reductions in the
random oracle model are highly inefficient in terms of memory
complexity. They then show that, in some cases, a PRF can be used
to make reductions more tight. However, the value of these points
depends heavily on the fact that they adopt a convention of the
memory used by the underlying game not counting towards the
memory complexity of the adversary. When using our convention
that the memory complexity of the adversary includes the memory
used by the game in which it is executed (this way of measuring of
memory complexity is referred to as LocalMem in their work), the
value of this observation disappears. In this setting, the straight-
forward security reductions typically being done in the literature
would already be memory-tight. By giving our reduction algorithms
explicitly, we aim to make it easy for their memory complexity to
be analyzed using whichever convention one desires.
10 CONCLUSION
This paper revisited the MD transform to unify prior work and
variants, improve security guarantees and formalize folklore re-
sults. We introduced the RS security framework for hash functions
with which we simultaneously capture several standard notions
of security for hash functions and introduce our new notion of
constrained collision resistance. Our new security notion allows us
to understand ways in which an MD hash function can satisfy col-
lision resistance despite collisions being known for its underlying
compression function. In more detail, we have considered a param-
eterized MD transform that constructs a hash function H = MD[h,
Split, S] from a compression function h, splitting function Split, and
set S of starting points. We have then comprehensively investigated
what assumptions on h and Split guarantee collision resistance
(CR) of H. We have shown that MD is better than advertised in
the sense that conditions on h weaker than CR, formalized in our
RS framework as constrained collision resistance (RccrS), suffice
for H to be CR. This strengthens guarantees on hash functions
and partially explains why, historically, attacks on compression
functions have not immediately translated to attacks on the hash
functions. The consequences are the usual benefits of weakening
assumptions, namely that weaker compression functions are easier
to design, harder to break and more likely to last. Furthermore, we
have also shown how to speed up hashing by using very simple
Split functions.
REFERENCES
[1] Elena Andreeva, Bart Mennink, and Bart Preneel. 2011. Security Reductions of
the Second Round SHA-3 Candidates. In ISC 2010 (LNCS), Mike Burmester, Gene
Session D4:  Crypto PrimitivesCCS’17, October 30-November 3, 2017, Dallas, TX, USA905Tsudik, Spyros S. Magliveras, and Ivana Ilic (Eds.), Vol. 6531. Springer, Heidelberg,
39–53.
[2] Elena Andreeva, Gregory Neven, Bart Preneel, and Thomas Shrimpton. 2007.
Seven-Property-Preserving Iterated Hashing: ROX. In ASIACRYPT 2007 (LNCS),
Kaoru Kurosawa (Ed.), Vol. 4833. Springer, Heidelberg, 130–146.
[3] Elena Andreeva and Martijn Stam. 2011. The Symbiosis between Collision and
Preimage Resistance. In 13th IMA International Conference on Cryptography and
Coding (LNCS), Liqun Chen (Ed.), Vol. 7089. Springer, Heidelberg, 152–171.
[4] Benedikt Auerbach, David Cash, Manuel Fersch, and Eike Kiltz. 2017. Memory-
Tight Reductions. In CRYPTO 2017, Part I (LNCS), Jonathan Katz and Hovav
Shacham (Eds.), Vol. 10401. Springer, Heidelberg, 101–132. https://doi.org/10.
1007/978-3-319-63688-7_4
[5] Michael Backes, Gilles Barthe, Matthias Berg, Benjamin Grégoire, César Kunz,
Malte Skoruppa, and Santiago Zanella Béguelin. 2012. Verified security of merkle-
damgård. In Computer Security Foundations Symposium (CSF), 2012 IEEE 25th.
IEEE, 354–368.
[6] Mihir Bellare. 2006. New Proofs for NMAC and HMAC: Security without
Collision-Resistance. In CRYPTO 2006 (LNCS), Cynthia Dwork (Ed.), Vol. 4117.
Springer, Heidelberg, 602–619.
[7] Mihir Bellare, Daniel J. Bernstein, and Stefano Tessaro. 2016. Hash-Function Based
PRFs: AMAC and Its Multi-User Security. In EUROCRYPT 2016, Part I (LNCS),
Marc Fischlin and Jean-Sébastien Coron (Eds.), Vol. 9665. Springer, Heidelberg,
566–595. https://doi.org/10.1007/978-3-662-49890-3_22
[8] Mihir Bellare, Ran Canetti, and Hugo Krawczyk. 1996. Keying Hash Functions
for Message Authentication. In CRYPTO’96 (LNCS), Neal Koblitz (Ed.), Vol. 1109.
Springer, Heidelberg, 1–15.
[9] Mihir Bellare, Ran Canetti, and Hugo Krawczyk. 1996. Pseudorandom functions
revisited: The cascade construction and its concrete security. In 37th FOCS. IEEE
Computer Society Press, 514–523.
[10] Mihir Bellare and Thomas Ristenpart. 2006. Multi-Property-Preserving Hash
Domain Extension and the EMD Transform. In ASIACRYPT 2006 (LNCS), Xuejia
Lai and Kefei Chen (Eds.), Vol. 4284. Springer, Heidelberg, 299–314.
[11] Mihir Bellare and Phillip Rogaway. 2006. The Security of Triple Encryption and
a Framework for Code-Based Game-Playing Proofs. In EUROCRYPT 2006 (LNCS),
Serge Vaudenay (Ed.), Vol. 4004. Springer, Heidelberg, 409–426.
[12] John Black, Phillip Rogaway, and Thomas Shrimpton. 2002. Black-Box Analysis of
the Block-Cipher-Based Hash-Function Constructions from PGV. In CRYPTO 2002
(LNCS), Moti Yung (Ed.), Vol. 2442. Springer, Heidelberg, 320–335.
[13] Daniel R. L. Brown. 2002. Generic Groups, Collision Resistance, and ECDSA.
Contributions to IEEE P1363a. (Feb. 2002). Updated version for “The Exact
Security of ECDSA.” Available from http://grouper.ieee.org/groups/1363/.
[14] Ivan Damgård. 1988. Collision Free Hash Functions and Public Key Signature
Schemes. In EUROCRYPT’87 (LNCS), David Chaum and Wyn L. Price (Eds.),
Vol. 304. Springer, Heidelberg, 203–216.
[15] Ivan Damgård. 1990. A Design Principle for Hash Functions. In CRYPTO’89
(LNCS), Gilles Brassard (Ed.), Vol. 435. Springer, Heidelberg, 416–427.
[16] Hans Dobbertin. 1996. Cryptanalysis of MD5 Compress. (1996).
[17] Yevgeniy Dodis and Prashant Puniya. 2008. Getting the Best Out of Existing Hash
Functions; or What if We Are Stuck with SHA?. In ACNS 08 (LNCS), Steven M.
Bellovin, Rosario Gennaro, Angelos D. Keromytis, and Moti Yung (Eds.), Vol. 5037.
Springer, Heidelberg, 156–173.
[18] Yevgeniy Dodis, Thomas Ristenpart, and Thomas Shrimpton. 2009. Salvaging
Merkle-Damgård for Practical Applications. In EUROCRYPT 2009 (LNCS), Antoine
Joux (Ed.), Vol. 5479. Springer, Heidelberg, 371–388.
[19] Peter Gaži, Krzysztof Pietrzak, and Michal Rybár. 2014. The Exact PRF-Security
of NMAC and HMAC. In CRYPTO 2014, Part I (LNCS), Juan A. Garay and Rosario
Gennaro (Eds.), Vol. 8616. Springer, Heidelberg, 113–130. https://doi.org/10.1007/
978-3-662-44371-2_7
[20] Jonathan Katz and Yehuda Lindell. 2014. Introduction to modern cryptography.
CRC press.
[21] G. Laccetti and G. Schmid. 2004. On a Probabilistic Approach to the Security
Analysis of Cryptographic Hash Functions. Cryptology ePrint Archive, Report
2004/324. (2004). http://eprint.iacr.org/2004/324.
[22] Alfred J Menezes, Paul C Van Oorschot, and Scott A Vanstone. 1996. Handbook
[23] Ralph C. Merkle. 1990. A Fast Software One-Way Hash Function. Journal of
of applied cryptography. CRC press.
Cryptology 3, 1 (1990), 43–58.
[24] Ralph C. Merkle. 1990. One Way Hash Functions and DES. In CRYPTO’89 (LNCS),
Gilles Brassard (Ed.), Vol. 435. Springer, Heidelberg, 428–446.
[25] NIST. August 2015. FIPS 180-4, Secure Hash Standard. (August 2015).
[26] Ronald Rivest. 2004. The MD5 message-digest algorithm, 1992. RFC1321, Internet
Engineering Task Force (2004).
[27] Ronald L. Rivest. 1991. The MD4 Message Digest Algorithm. In CRYPTO’90 (LNCS),
Alfred J. Menezes and Scott A. Vanstone (Eds.), Vol. 537. Springer, Heidelberg,
303–311.
[28] Phillip Rogaway and Thomas Shrimpton. 2004. Cryptographic Hash-Function Ba-
sics: Definitions, Implications, and Separations for Preimage Resistance, Second-
Preimage Resistance, and Collision Resistance. In FSE 2004 (LNCS), Bimal K. Roy
and Willi Meier (Eds.), Vol. 3017. Springer, Heidelberg, 371–388.
[29] Marc Stevens, Elie Bursztein, Pierre Karpman, Ange Albertini, and Yarik Markov.
2017. The First Collision for Full SHA-1. In CRYPTO 2017, Part I (LNCS), Jonathan
Katz and Hovav Shacham (Eds.), Vol. 10401. Springer, Heidelberg, 570–596. https:
//doi.org/10.1007/978-3-319-63688-7_19
[30] Marc Stevens, Pierre Karpman, and Thomas Peyrin. 2016. Freestart Collision for
Full SHA-1. In EUROCRYPT 2016, Part I (LNCS), Marc Fischlin and Jean-Sébastien
Coron (Eds.), Vol. 9665. Springer, Heidelberg, 459–483. https://doi.org/10.1007/
978-3-662-49890-3_18
[31] Douglas R Stinson. 2005. Cryptography: theory and practice. CRC press.
[32] Douglas R Stinson. 2006. Some observations on the theory of cryptographic hash
functions. Designs, Codes and Cryptography 38, 2 (2006), 259–277.
[33] Xiaoyun Wang, Dengguo Feng, Xuejia Lai, and Hongbo Yu. 2004. Collisions
for Hash Functions MD4, MD5, HAVAL-128 and RIPEMD. Cryptology ePrint
Archive, Report 2004/199. (2004). http://eprint.iacr.org/2004/199.
[34] Xiaoyun Wang and Hongbo Yu. 2005. How to Break MD5 and Other Hash
Functions. In EUROCRYPT 2005 (LNCS), Ronald Cramer (Ed.), Vol. 3494. Springer,
Heidelberg, 19–35.
Session D4:  Crypto PrimitivesCCS’17, October 30-November 3, 2017, Dallas, TX, USA906