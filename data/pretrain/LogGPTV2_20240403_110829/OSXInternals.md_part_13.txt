Depending on available hardware, Core Image uses GPU-based acceleration and vector processing to
improve performance. It supports 32-bit floating-point pixels for enhanced accuracy. It also uses other, more
fundamental graphical technologies such as OpenGL,[43] Quartz, and QuickTime for optimal image
processing.
[43] Even when you use Core Image, it is OpenGL that eventually rasterizes the data.
Core Image uses a plug-in architecture[44] for accessing filters, transitions, and effects packagesthese are
called Image Units. Developers can use the various Image Units shipped with Core Image or create their
own by describing filters and effects using dynamically compiled expressions. Examples of bundled Image
Units include filters for blurring and sharpening, color adjustment, compositing, distortion, gradients,
halftones, tiling, and transitions. Figure 224 shows a conceptual view of image processing with Core Image.
The key components of Core Image include the following:
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhF139.htm 20.08.2007
Chapter 2. An Overview of Mac OS X Page 41 of 80
[44] The Core Image plug-in architecture is inspired by the Core Audio plug-in architecture.
Context (CIContext) a destination for images to be drawn, say, one created from an OpenGL context
Image (CIImage) an image that theoretically extends to infinity, with a subrectangle as the region of
interest
Filter (CIFilter) an object that encapsulates an image-processing kernel and represents an effect or
transition, with a parameter-passing interface
Sampler (CISampler) an accessor object that is used (typically by a kernel) to retrieve samples
(pixels) from an image
Kernel (CIKernel) an object that lives within a filter and contains the per-pixel instructions that
actually apply the filter's image-processing effect
Figure 224. Image processing with Core Image
[View full size image]
Core Video applies concepts similar to Core Image to video, allowing video filters and effects to benefit
from hardware acceleration. It could be seen as a bridge between QuickTime and the graphics hardware for
processing video data by enhancing performance and lowering CPU requirements. Figure 225 shows a
conceptual overview of using both Core Image and Core Video in an instance of the QuickTime video-
rendering pipeline.
Figure 225. Core Image and Core Video in the QuickTime video-rendering pipeline
[View full size image]
Core Image and Core Video are both parts of the Quartz Core framework.
Quartz Composer
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhF139.htm 20.08.2007
Chapter 2. An Overview of Mac OS X Page 42 of 80
Mac OS X 10.4 introduced a visual development tool called Quartz Composer, which allows
rapid creation of graphical applications using several Mac OS X graphics technologies such as
Core Image, OpenGL, Quartz 2D, and QuickTime. Besides graphical content, Quartz
Composer can also use Rich Site Summary (RSS) content and MIDI System Services. For
example, by simply dragging and dropping graphical building blocks into a grid, and
"connecting" the blocks appropriately, you can rapidly create, say, a rotating cube with a
different image rendered onto each of its faces, with custom lighting effects.
2.10.1.5. QuickTime
QuickTime is both a graphics environment and an application environment. It provides features for working
with interactive multimedia. Depending on the media type, QuickTime allows you to manipulate media in
several ways, such as:
Accessing media (open, play, or display)
Capturing media from an external device
Compressing media
Creating certain types of mediafor example, author panorama movies, object movies, and scenes using
QuickTime Virtual Reality (QTVR)
Editing and enhancing media, including synchronizing multiple media to a single timeline
Streaming media over a local network or the Internet using protocols such as HTTP, RTP (Real-Time
Transport Protocol), and RTSP (Real-Time Streaming Protocol)
Translating between media formats
QuickTime works with several types of media such as video, graphics, animation, virtual reality, audio, and
textin a variety of file and streaming formats. The media could reside on a local disk, be accessed over the
network in its entirety, or be streamed in real time.
The QuickTime architecture is modular and extensible. QuickTime components can be written to implement
support for new media types, to implement a new codec, and to interact with custom media capture
hardware. As indicated in Figure 225, beginning with Mac OS X 10.4, QuickTime cooperates with Core
Image and Core Video to improve performance.
Besides being an integrated technology in Mac OS X, QuickTime is available for other platforms such as
Java, Mac OS 9, and several versions of Microsoft Windows.
2.10.1.6. Core Audio
The Core Audio layer (see Figure 219) allows management of audio software and hardware. It uses a plug-in
architecture in which a plug-in can perform software operations on audio data or interact with audio
hardware. Core Audio's hardware abstraction layer hides unnecessary details of the underlying hardware
from applications. Core Audio APIs provide functionality for performing operations such as the following:
Accessing and manipulating audio files
Aggregating multiple audio devices into a single "virtual" device, which can be seamlessly made
available to all applications
Working with multichannel audio, including channel mixing
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhF139.htm 20.08.2007
Chapter 2. An Overview of Mac OS X Page 43 of 80
Converting audio data between various formats
Developing audio codecs
Providing low-level access to audio hardware, including device sharing between multiple applications
Synthesizing audio using software
Using MIDI hardware and software
Apple's AU Lab digital mixing application (AULab.app) allows blending audio from multiple sources: the
input of an audio device, audio generated by an Audio Unit Instrument, and audio generated from an Audio
Unit Generator. It supports multiple outputs.
OpenAL
The Open Audio Library (OpenAL) is a cross-platform 3D audio API for use in games or other applications
that require high-quality spatialized audio. It is available for systems such as BSD, IRIX, Linux, Solaris,
Microsoft Windows, Mac OS 8, Mac OS 9, Sony PlayStation 2, Microsoft Xbox/Xbox360, and Nintendo
GameCube. On Mac OS X, OpenAL is implemented using Core Audio as the underlying device. In the
OpenAL specification, which is inspired by the OpenGL specification for graphics, a device is defined as an
implementation-dependent entity that can be a hardware device, a daemon, or a system service.
2.10.2. Other Application Services
The Application Services umbrella framework contains subframeworks that facilitate development of many
types of applicationshence the name. The following are examples of this framework's subframeworks.
AE allows creation and manipulation of events in the Apple Events mechanism for interapplication
communication.
ATS allows font layout and management using Apple Type Services.
ColorSync is used for color matching using Apple's integrated color management system, which is
also called ColorSync.
CoreGraphics provides the Core Graphics API.
FindByContent provides an interface for searching specific volumes or directories for files containing
specified content.
HIServices provides human-interface services such as Accessibility, Icon Management, Copy and
Paste, Process Management, Translation Management, and Internet Configuration.
LangAnalysis provides an interface to the Language Analysis Manager that lets you analyze
morphemes[45] in text.
[45] A morpheme is a meaningful linguistic unita distinctive collection of phonemes
having no smaller meaningful parts. A phoneme is an indivisible phonetic unit in a
language.
LaunchServices provides an interface for opening URLs and starting applications, including opening
documents with either a specified application or the default.
PrintCore provides an interface to the printing subsystem.
QD provides the QuickDraw API.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhF139.htm 20.08.2007
Chapter 2. An Overview of Mac OS X Page 44 of 80
SpeechSynthesis provides an interface for generating synthesized speech.
2.11. Application Environments
Most of the typical application development occurs in the Application Environments layer. Mac OS X has
multiple application environments, each providing features that may appeal to certain types of developers.
For example, those interested in programming using "plain old" Unix APIs are equally well served on Mac
OS X as those who wish to use visual tools for rapid prototyping, creation of complex graphical user
interfaces, and object-oriented development. Of the vast number of portable programming language
implementations in existence, many are readily accessible on Mac OS X, and some are bundled by Apple. In
particular, Apple's own programming environment offers rich APIs for Mac OS Xspecific development.
Although it would be impractical to enumerate all types of applications that can run on or be developed on
Mac OS X, let us consider the following examples:
Unix-style command-line tools and X Window applications written entirely using portable interfaces
such as POSIX
Carbon-based GUI and command-line applications written in C
Cocoa-based GUI and command-line applications written in Objective-C, Java, or AppleScript
AWT-based and Swing-based applications[46] written in Java
[46] Java's Abstract Windowing Toolkit (AWT) provides facilities for creating GUIs and
for drawing graphics. Swing is a relatively more modern GUI toolkit that evolved from
AWT.
Generic command-line applicationsor toolswritten in C++ or C that may link with one or more
frameworks such as Core Foundation, Core Services, Foundation, and I/O Kit
We saw earlier that the Mac OS X kernel understands only the Mach-O binary executable format. Although
Mach-O is the preferred runtime architecture, it is possible to run certain legacy format binaries on Mac OS
X.
The Mac OS X kernel could be seen as an application environment for specialized applicationsdynamically
loadable kernel extensionsthat execute in the kernel's address space.
2.11.1. BSD
The BSD application environment in Mac OS X is similar to, but not the same as, a traditional user-level
environment on a BSD-based Unix system. It provides POSIX APIs, BSD-specific APIs, and some Unix-
flavored APIs that export Mac OS Xspecific functionality. You can use the BSD environment for writing
Unix tools, daemons, and shell scripts. In many cases, programs targeted for the Mac OS X BSD
environment would be readily portable to other Unix systems and vice versa. The standard libraries and
headers for the BSD environment reside in their traditional Unix locations: /usr/lib/ and /usr/include/,
respectively.
Technically, many header files in /usr/include/ are part of the System framework. However, the
System.framework directory neither contains nor links to these headers since the C compiler searches
in /usr/include/ by default.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhF139.htm 20.08.2007
Chapter 2. An Overview of Mac OS X Page 45 of 80
2.11.2. The X Window System
The X Window System could be seen as a graphical extension to the BSD environment. Mac OS X includes
an optimized X Window server (/usr/X11R6/bin/Xquartz) along with a modern X Window environment.
The X server is integrated with the Mac OS X Quartz subsystem. It conceptually sits atop the native Core
Graphics APIs, tying into the native Mac OS X event system. Through this architecture, the X server enjoys
hardware acceleration.
The environment includes quartz-wman X Window manager with the native Mac OS X look-and-feel that
allows X applications to run alongside native Mac OS X programs. quartz-wm provides Aqua window
controls, drop shadows, integration with the Dock, and so on. Although the X server's default operating
mode is rootless, it can also be run in full-screen mode.
Even though the Mac OS X user interface does not use focus-follows-mouse mode, it is possible to
configure quartz-wm to enable this mode for X Window applications. With this mode, X application
windows can be focused by simply moving the mouse pointer over them. To enable this mode, the wm_ffm
Boolean property must be set to true in the com.apple.x11.plist file.
Because of the availability of the BSD and X Window environments, it is usually straightforward to port
existing Unix applications to Mac OS X simply by recompiling them, with little or no source modification.
2.11.3. Carbon
The Carbon application environment contains APIs based on the original Mac OS 9 APIs. In fact, some of
Carbon's constituent interfaces date back to Mac OS 8.1. The Carbon interfaces are procedural in nature and
are implemented in the C programming language. Carbon was originally designed to provide an easy
development migration path from Mac OS 8 and Mac OS 9 to newer systems. It allows a compliant
application, one that uses only features supported on both Mac OS 9 and Mac OS X, to run natively on both
systems. It is implemented as a framework (Carbon.framework) on Mac OS X, whereas it is implemented
as a system extension (CarbonLib) on Mac OS 9.
2.11.3.1. Support for CFM Binaries
The Code Fragment Manager (CFM) was a part of older Mac OS versions. It loaded fragments of PowerPC
code from Preferred Executable Format (PEF) files into memory and prepared them for execution. A
fragment is an arbitrarily sized basic unit of executable code and its associated data. It has certain well-
defined properties and a method of addressing its contents. The following are examples of fragments:
An application
A system extension
A shared library, which could be an import library or a plug-in
Any other block of code and associated data
Besides mapping fragments into memory, the CFM's responsibilities included releasing fragments when
they were no longer needed, resolving references to symbols imported from other fragments, and providing
support for special initialization and termination routines.
The Mac OS X native runtime architecture (dyld/Mach-O) is not the same as that on Mac OS 9 (CFM/PEF).
All Mac OS X libraries, including those that are part of Carbon, use the Mach-O format. However, Carbon
supports the CFM on Mac OS X for Mac OS 9 compatibilityit is possible to create and run CFM
applications on Mac OS X. In fact, an application that must run on both systems either must be compiled
separately for the two systems or must be a CFM application. Carbon uses the LaunchCFMApp helper
application[47] to run programs created for the CFM. LaunchCFMApp can run only native PowerPC code. It
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhF139.htm 20.08.2007
Chapter 2. An Overview of Mac OS X Page 46 of 80
does not support resource-based fragments. Moreover, Carbon provides a one-way bridge to CFM
applications to link to Mach-O code. Using this bridge, a CFM application can call a Mach-O library, but
not vice versa.
[47] LaunchCFMApp resides in the Support subdirectory of the Carbon framework.
2.11.3.2. Carbon APIs
Carbon does not include all of the old APIs, but it contains a subset (about 70%) that covers most of the
functionality used by typical applications. APIs that are not critical, or are no longer applicable due to
radical differences between Mac OS X and earlier systems, have been dropped in Carbon. These include
APIs that were specific to the 68K architecture, those that accessed the hardware directly, and those that
were replaced by improved APIs. The following are noteworthy features of Carbon.
Some of the APIs included in Carbon have been modified or extended to benefit from the more
modern nature of Mac OS X, which uses preemptive multitasking and protected memory as
fundamental features. In contrast, such features were retrofittedwith limited applicabilityin Mac OS 9.
Some new APIs were added to Carbon and made available on Mac OS 9. Several new APIs in Carbon
are available only on Mac OS X.
Carbon applications running on Mac OS X have the system's native look-and-feel.
The New "Old" API
Although Carbon is best understood as an overhaul of several older APIs that were pruned,
extended, modified, and supplemented with new APIs to run in the modern Mac OS X
environment, it does not represent an obsolete set of interfaces. Not only does Carbon support
standard Aqua user-interface elements, but Carbon user interfaces can even be designed using
the Interface Buildersimilar to Cocoa applications. Carbon functionality is widely used in Mac
OS X and is critical for C-based development. Some parts of Carbon are complementary to
object-oriented APIs such as Cocoa.
The following are examples of Carbon's subframeworks.
CarbonSound provides Carbon Sound Manager interfaces.
CommonPanels provides interfaces for displaying commonly used GUI panels,[48] such as the Color
window and the Font window.
[48] A panel is a special kind of window that usually serves an auxiliary function in an
application.
Help provides interfaces for using Apple Help in applications.
 HIToolbox[49] provides interfaces for the HIToolbox object, the Carbon Event Manager, and others.
This framework provides various objects (such as HIObject and HIView) for organizing windows,
controls, and menus in Carbon applications. The "view" objects provided by the HIToolbox
framework benefit from native Quartz rendering (with automatic layering), the ability to be hidden,
and the ability to be attached or detached from windows.
[49] HIToolbox stands for Human Interface Toolbox.
HTMLRendering provides interfaces for rendering HTML content. However, the Web Kit framework
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhF139.htm 20.08.2007
Chapter 2. An Overview of Mac OS X Page 47 of 80
has superseded it.
ImageCapture provides interfaces for capturing images from digital cameras.
Ink provides interfaces for handwriting recognition based on input from pen-based devices. Features
provided by this framework include programmatic enabling or disabling of handwriting recognition,
direct access to Ink data, the ability to toggle between deferred and on-demand recognition, and the
ability to manipulate text directly through gestures. Moreover, a programmer can incorporate custom
correction models that allow incoming handwriting data to be interpreted in alternative ways.
NavigationServices provides interfaces for file navigation.
OpenScripting contains AppleScript and Open Scripting Architecture (OSA) interfaces.
Print provides print dialog interfaces.
SecurityHI provides security dialog interfaces.