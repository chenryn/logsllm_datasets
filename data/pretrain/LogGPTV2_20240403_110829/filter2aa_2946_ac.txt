线程上下文是指某一时间点CPU寄存器和程序计数器的内容，如果想要设置、获取线程上下文就需要先将线程
挂起。
10.3.1 GetThreadContext函数
GetThreadContext函数用于获取线程上下文，其语法格式如下：
BOOL GetThreadContext(
1
  HANDLE hThread,       // handle to thread with context 句柄
2
  LPCONTEXT lpContext   // context structure
3
);
4
滴水逆向课程笔记  –  Win32
线程控制  –  38
第一个参数就是线程句柄，这个很好理解，重点是第二个参数，其是一个CONTEXT结构体，该结构体包含指定
线程的上下文，其ContextFlags成员的值指定了要设置线程上下文的哪些部分。
当我们将CONTEXT结构体的ContextFlags成员的值设置为CONTEXT_INTEGER时则可以获取edi、esi、ebx、edx、
ecx、eax这些寄存器的值：
如下代码尝试获取：
HANDLE hThread;
1
hThread = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
2
3
SuspendThread(hThread);
4
5
CONTEXT c;
6
c.ContextFlags = CONTEXT_INTEGER;
7
GetThreadContext(hThread, &c);
8
9
printf("%x %x \n", c.Eax, c.Ecx);
10
滴水逆向课程笔记  –  Win32
线程控制  –  39
10.3.2 SetThreadContext函数
GetThreadContext函数是个设置修改线程上下文，其语法格式如下：
我们可以尝试修改Eax，然后再获取：
BOOL SetThreadContext(
1
  HANDLE hThread,            // handle to thread
2
  CONST CONTEXT *lpContext   // context structure
3
);
4
滴水逆向课程笔记  –  Win32
线程控制  –  40
HANDLE hThread;
1
hThread = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
2
3
SuspendThread(hThread);
4
5
CONTEXT c;
6
c.ContextFlags = CONTEXT_INTEGER;
7
c.Eax = 0x123;
8
SetThreadContext(hThread, &c);
9
10
CONTEXT c1;
11
c1.ContextFlags = CONTEXT_INTEGER;
12
GetThreadContext(hThread, &c1);
13
14
printf("%x \n", c1.Eax);
15
滴水逆向课程笔记  –  Win32
线程控制  –  41
滴水逆向课程笔记  –  Win32
临界区  –  42
11 临界区
11.1 线程安全问题
每个线程都有自己的栈，局部变量是存储在栈中的，这就意味着每个进程都会有一份自己的“句柄变
量”（栈），如果线程仅仅使用自己的“局部变量”那就不存在线程安全问题，反之，如果多个线程共用一个全
局变量呢？那么在什么情况下会有问题呢？那就是当多线程共用一个全局变量并对其进行修改时则存在安全问
题，如果仅仅是读的话没有问题。
如下所示代码，我们写了一个线程函数，该函数的作用就是使用全局变量，模拟的功能就是售卖物品，全局变
量countNumber表示该物品的总是，其值是10，而如果有多个地方（线程）去卖（使用）这个物品（全局变
量），则会出现差错：
如图，我们运行了代码，发现会出现重复售卖，并且到最后总数竟变成了-1：
#include 
1
2
int countNumber = 10;
3
4
DWORD WINAPI ThreadProc(LPVOID lpParameter) {
5
    while (countNumber > 0) {
6
        printf("Sell num: %d\n", countNumber);
7
        // 售出-1
8
        countNumber--;
9
        printf("Count: %d\n", countNumber);
10
    }
11
    return 0;
12
}
13
14
int main(int argc, char* argv[])
15
{
16
    HANDLE hThread;
17
    hThread = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
18
19
    HANDLE hThread1;
20
    hThread1 = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
21
22
    CloseHandle(hThread);
23
24
    getchar();
25
    return 0;
26
}
27
滴水逆向课程笔记  –  Win32
临界区  –  43
出现这样的问题其本质原因是什么呢？因为多线程在执行的时候是同步进行的，并不是按照顺序来，所以就都
会窒息，自然就会出现这种情况。
11.1.1 解决问题
想要解决线程安全问题，就需要引伸出一个概念：临界资源，临界资源表示对该资源的访问一次只能有一个线
程；访问临界资源的那一段程序，我们称之为临界区。
那么我们如何实现临界区呢？第一，我们可以自己来写，但是这需要一定门槛，先不过多的去了解；第二，可
以使用WIndows提供的API来实现。
11.2 实现临界区
首先会有一个令牌，假设线程1获取了这个令牌，那么这时候令牌则只为线程1所有，然后线程1会执行代码去
访问全局变量，最后归还令牌；如果其他线程想要去访问这个全局变量就需要获取这个令牌，但当令牌已经被
取走时则无法访问。
假设你自己来实现临界区，可能在判断令牌有没有被拿走的时候就又会出现问题，所以自己实现临界区还是有
一定的门槛的。
滴水逆向课程笔记  –  Win32
临界区  –  44
1.
2.
3.
11.3 线程锁
线程锁就是临界区的实现方式，通过线程锁我们可以完美解决如上所述的问题，其步骤如下所示：
创建全局变量：CRITICAL_SECTION cs;
初始化全局变量：InitializeCriticalSection(&cs);
实现临界区：进入 → EnterCriticalSection(&cs); 离开 → LeaveCriticalSection(&cs);
我们就可以这样改写之前的售卖物品的代码：
在使用全局变量开始前构建并进入临界区，使用完之后离开临界区：
滴水逆向课程笔记  –  Win32
临界区  –  45
#include 
1
2
CRITICAL_SECTION cs; // 创建全局变量
3
int countNumber = 10;
4
5
DWORD WINAPI ThreadProc(LPVOID lpParameter) {
6
    while (1) {
7
        EnterCriticalSection(&cs); // 构建临界区，获取令牌
8
        if (countNumber > 0) {
9
            printf("Thread: %d\n", *((int*)lpParameter));
10
            printf("Sell num: %d\n", countNumber);
11
            // 售出-1
12
            countNumber--;
13
            printf("Count: %d\n", countNumber);
14
        } else {
15
            LeaveCriticalSection(&cs); // 离开临临界区，归还令牌
16
            break;  
17
        }
18
        LeaveCriticalSection(&cs); // 离开临临界区，归还令牌
19
    }
20
21
    return 0;
22
}
23
24
int main(int argc, char* argv[])
25
{
26
27
    InitializeCriticalSection(&cs); // 使用之前进行初始化
28
29
    int a = 1;
30
    HANDLE hThread;
31
    hThread = CreateThread(NULL, NULL, ThreadProc, (LPVOID)&a, 0, NULL);
32
33
    int b = 2;
34
    HANDLE hThread1;
35
    hThread1 = CreateThread(NULL, NULL, ThreadProc, (LPVOID)&b, 0, NULL);
36
37
    CloseHandle(hThread);
38
39
    getchar();
40
    return 0;
41
}
42
滴水逆向课程笔记  –  Win32
临界区  –  46
滴水逆向课程笔记  –  Win32
互斥体  –  47
12 互斥体
12.1 内核级临界资源怎么办？
上一章中我们了解了使用线程锁来解决多个线程共用一个全局变量的线程安全问题；那么假设A进程的B线程和
C进程的D线程，同时使用的是内核级的临界资源（内核对象：线程、文件、进程...）该怎么让这个访问是安全
的？使用线程锁的方式明显不行，因为线程锁仅能控制同进程中的多线程。
那么这时候我们就需要一个能够放在内核中的令牌来控制，而实现这个作用的，我们称之为互斥体。
12.1.1 互斥体的使用
创建互斥体的函数为CreateMutex，该函数的语法格式如下：
我们可以模拟一下操作资源然后创建：
HANDLE CreateMutex(
1
  LPSECURITY_ATTRIBUTES lpMutexAttributes,  // SD 安全属性，包含安全描述符
2
  BOOL bInitialOwner,                       // initial owner 是否希望互斥体创建出来就有信号，或者说就可以
使用，如果希望的话就为FALSE；官方解释为如果该值为TRUE则表示当前进程拥有该互斥体所有权
3
  LPCTSTR lpName                            // object name 互斥体的名字
4
);
5
滴水逆向课程笔记  –  Win32
互斥体  –  48
我们可以运行两个进程来看一下互斥体的作用：
#include 
1
2
int main(int argc, char* argv[])
3
{
4
    // 创建互斥体
5
    HANDLE cm = CreateMutex(NULL, FALSE, "XYZ");
6
    // 等待互斥体状态发生变化，也就是有信号或为互斥体拥有者，获取令牌
7
    WaitForSingleObject(cm, INFINITE);
8
9
    // 操作资源
10
    for (int i = 0; i 
1
2
int main(int argc, char* argv[])
3
{
4
    // 创建互斥体
5
    HANDLE cm = CreateMutex(NULL, TRUE, "XYZ");
6
    // 判断互斥体是否创建失败
7
    if (cm != NULL) {
8
        // 判断互斥体是否已经存在，如果存在则表示程序被多次打开
9
        if (GetLastError() == ERROR_ALREADY_EXISTS) {
10
            printf("该程序已经开启了，请勿再次开启！");
11
            getchar();
12
        } else {
13
            // 等待互斥体状态发生变化，也就是有信号或为互斥体拥有者，获取令牌
14
            WaitForSingleObject(cm, INFINITE);
15
            // 操作资源
16
            for (int i = 0; i < 5; i++) {
17
                printf("Process: A Thread: B -- %d \n", i);
18
                Sleep(1000);
19
            }
20
            // 释放令牌
21
            ReleaseMutex(cm);
22
        }
23
    } else {
24
        printf("CreateMutex 创建失败! 错误代码: %d\n", GetLastError());
25
    }
26
27
    return 0;
28
}
29
滴水逆向课程笔记  –  Win32
事件  –  51
13 事件
事件本身也是一种内核对象，其也是是用来控制线程的。
13.1 通知类型
事件本身可以做为通知类型来使用，创建事件使用函数CreateEvent，其语法格式如下：
那么通知类型到底是什么？我们可以写一段代码来看一下：
HANDLE CreateEvent(
1
  LPSECURITY_ATTRIBUTES lpEventAttributes, // SD 安全属性，包含安全描述符
2
  BOOL bManualReset,                       // reset type 如果你希望当前事件类型是通知类型则写TRUE，反之
FALSE
3
  BOOL bInitialState,                      // initial state 初始状态，决定创建出来时候是否有信号，有为
TRUE，没有为FALSE
4
  LPCTSTR lpName                           // object name 事件名字