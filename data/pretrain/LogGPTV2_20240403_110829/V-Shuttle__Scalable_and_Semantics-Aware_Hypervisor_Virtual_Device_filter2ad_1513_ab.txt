9
0
5
29(72.5%)
4
12
10
7
7
40(100%)
2.3 Core Challenge-Nested Structures
The hypervisor is designed to transfer data from/to guest mem-
ory for device-driver communication. This transfer operation is al-
ways performed through specific APIs related to DMA mechanisms,
MMIO Space                                       Memory SpaceCoadRegisterBase AddressRegister…        CommandRing BufferData③Execute TransactionsHostGuest                                         Command Guest Kernel Driver①AccessRegisterthrough MMIO②Copy Pre-allocated Bufferin Guest through DMA  HypervisorSession 7B: Fuzzing CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2199pointer values are usually fixed, pointing to meaningful content,
and are not expected to be mutated. The lack of semantics at the
node level also makes it difficult to construct nested structures.
As a result, the fuzzer needs to understand the semantics of data
organization (hierarchically nested pattern) and be aware of internal
semantics imposed in every single node (which field is the pointer).
2) Node Type Awareness. Since the devices support various
data types according to the specifications, fine-grained semantic
knowledge about the nested nodes is desired. The nested structures
are linked by different types of nodes. Each node has one or more
pointers to different data types. The connection relationship of dif-
ferent nodes is regular and specified according to specifications (i.e.,
the packet descriptor points to the packet body), which requires us
to establish a correct pointing relationship between nodes. More-
over, precise pointing relationships can only be known at runtime
in many cases: Some fields are used to indicate the exact type of
data structure the pointer refers to, since the same pointer can
reference multiple types of data; Some fields are used to indicate
whether the current node is a termination node. If the pointer has
its termination bit set, it assumes there is no more work to complete
for the current node and all its children. Hence, the random combi-
nation of arbitrary nodes generated by fuzzing does not satisfy the
semantic requirements of the devices, which would be rejected at
an early stage of processing and heavily limits the fuzzers to find
deep bugs. At the node level, the fuzzer requires to extract pointers
from given nodes and needs to be aware of the semantics of the
pointer (referred node types).
To better illustrate how these nested structures are supported
by the hypervisor, the following is the common case of how the
hypervisor handles a nested structure: 1) Starting from the root
node, the hypervisor first obtains a pointer (specified by an address
register) pointing to a data structure A located in the guest memory;
2) the hypervisor dynamically allocates the buffer to hold the copy
of A; 3) the hypervisor copies A from guest memory to this allocated
buffer using pci_dma_read; 4) referring to a pointer field within A,
which indicates its child node B, the hypervisor allocates another
buffer to hold the copy of B; 5) the hypervisor performs another
pci_dma_read to copy B from guest memory to its allocated buffer;
6) Following the pointer within structure B, the hypervisor performs
next pci_dma_read again to copy the next structure C. As above,
the hypervisor recursively traverses the tree and moves down until
it reaches the termination node, at each node holding a copy of the
user-supplied structure.
Without prior knowledge about such a complex nested form
of structures, traditional fuzzing cannot properly fuzz the entire
data structure as it hardly figures out complex data formats behind
each object. Such nested structures are heavily used in hypervisor
implementation, severely hindering traditional testing schemes
from extending code coverage. We utilize the USB_UHCI protocol as
an example to demonstrate the nested structures in the hypervisor.
Example: Nested Structures in USB-UHCI. Universal Host
Controller Interface (UHCI) is responsible for providing virtual
USB devices to guests in modern hypervisors, which is Intel’s
spec for USB 1.0 [12]. Figure 2 presents a simplified function
uhci_process_frame, which processes USB packet transmitted
to USB endpoints. The function, scheduled in each cycle, requires a
tree-structured memory buffer which is initially indicated by the
Figure 2: An example presenting nested structures in Universal Host
Controller Interface (UHCI). Here td, qh, buf represent three different types
of objects, respectively (td and qh are the structures containing the amounts
of metadata, while buf is the raw data).
such as pci_dma_read and pci_dma_write in QEMU. Specifically,
pci_dma_read copies a block of data from guest memory into a
host buffer while pci_dma_write does the opposite procedure. By
specifying address arguments, those DMA operations can target
any location of the guest’s physical memory.
We observed that data objects transferred via the DMA mech-
anism are often constructed as nested structures (i.e., structure
A contains a pointer to structure B), where this nested feature is
being supported by the above-mentioned pci_dma_read. More im-
portantly, this nested feature could be multi-layer and multi-type,
as the hypervisor organizes these structures in a hierarchical or tree
structure starting with a root node. Specifically, this feature blocks
fuzzing in exploring hypervisor code mainly due to the following
two reasons:
1) Nested Form Construction. It is challenging for fuzzing
techniques to construct a nested data object with multiple levels
of data or sub-objects, which can be arbitrarily complex. (1) In
terms of the overall organization, the devices’ data structures can
be represented as a hierarchy of nested nodes like a tree. The nodes
are blocks of certain data, and pointers establish the links between
nodes. Notice that the nested level of this tree could be rather deep,
far more than one layer. Also, these tree-like structures can be
viewed as recursive data structures because a tree may have other
trees as elements. In the tree, a node includes the subtree with all its
descendant nodes. Random fuzzing techniques struggle to come up
with such a recursively defined data structure, which requires more
domain knowledge about the device specifications. (2) At the node
level, each node can be regarded as a combination of metadata and
pointers. However, the offset of the pointer in a node is uncertain
and varies according to the definition of different data structures.
Given a node as mutation input, a coverage-guided fuzzer mutates
the whole node and treats all fields equally, which results in a
random pointer to an invalid or unmapped page. Unlike metadata,
1.  typedef struct UHCI_TD {2.     uint32_t link;3.    …//    various kinds of metadata4.    uint32_t buffer;5.  } UHCI_TD;6.  typedef struct UHCI_QH {7.    uint32_t link;8.     uint32_t el_link;9.  } UHCI_QH;10.  staticvoid uhci_process_frame(UHCIState*s){11.     uint32_t link;12.     UHCI_TD td;13.     UHCI_QH qh;14.     uint8_t *buf;15.     …16.     pci_dma_read(&s->dev, s->frame_addr, &link, 4);17.     …18.     for(; is_valid(link);) {        // unknown nested level19.         …20.         if (is_qh(link)) {21.             pci_dma_read(&s->dev, link, &qh, sizeof(qh));22.             …23.             continue;24.         }25.         pci_dma_read(&s->dev, link, &td, sizeof(td));26.         …27.         pci_dma_read(&s->dev, td.buffer, buf, td.len);28.         …29.         /*    main usbpacket processing    */30.         link = td.link;31.     }32. }td...bufmemory viewUnknown at static timelinkFrametdNested levelQEMU source codelinkMeta.bufferlink (null)Meta.bufferlinkel_link(null)link(null)el_linkqhqh...bufSession 7B: Fuzzing CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2200device’s address register (i.e., s->frame_addr). At line 16, the first
entity is copied into the allocated hypervisor buffer link. A specific
field in link determines the type of next referenced node, either
TD or QH, which indirectly influences the control flow to different
blocks. (1) If the indicated type is QH (Queue Head), the data struc-
ture pointed by link will be copied into allocated buffer qh (line
21). (2) If the indicated type is TD (Transfer Descriptor), then the
data structure pointed by link will be copied into allocated buffer
td (line 25). Next, a subsequent memory copy, pointed by a field
member of previously copied buffer (i.e., td.buffer), occurs with
a certain size (i.e., td.len) at line 27. After performing the USB
transactions (line 29), the function continues to traverse the tree
recursively during the execution of the entire loop (line 18). Noted
here that without built-in knowledge of such a nested form of data
structures, the hypervisor cannot be tested thoroughly in two as-
pects: (1) The execution likely stops due to invalid memory access
where the hypervisor cannot fetch meaningful data, before reach-
ing its main functionality (line 29). (2) It is hard to trigger the deep
logic that handles recursively defined structures in the hypervisor.
Without constructing recursive data structures, we cannot test the
program’s behavior completely since each recursion accumulates
the program’s state.
A straightforward way to handle nested structures is to use
structure-aware fuzzing techniques. These techniques require de-
velopers to create a formal model that precisely captures the speci-
fication of devices. The model-based methods follow pre-defined
rules to generate corresponding types of structures and concatenate
them together. Based on the model, fuzzing techniques enumerate
all possible nested forms of structures to verify the functionalities
of hypervisors or find bugs. However, structure-aware fuzzing tools
have significant drawbacks as they are time-consuming and error-
prone processes, thus not scalable for hypervisor testing. Typically,
protocol specifications contain hundreds of pages, requiring a non-
trivial amount of manual effort to extract the definition of structure.
Humans tend to make mistakes in such tedious work of under-
standing the specification. Besides, the implemented protocol may
not entirely correspond to the specification since developers may
add new functionalities. Thus, it is not plausible for the large-scale
testing of the hypervisor. As a result, an automatic way to handle
nested structures is desired. To the best of our knowledge, no prior
work handles nested structures automatically, which is essential to
apply an efficient and scalable fuzzing to the hypervisor.
3 V-SHUTTLE DESIGN
This section describes the design of V-Shuttle. At a high level,
V-Shuttle is designed to be a scalable, semantics-aware, and light-
weight hypervisor fuzzing framework, combining coverage-guided
fuzzing and static analysis techniques. Moreover, in order to address
the hypervisor-specific challenges in fuzzing, V-Shuttle designs
two different approaches: 1) redirecting the DMA-related functions;
2) semantics-aware fuzzing via seedpools; We start by providing a
threat model for hypervisor security. Based on this threat model,
we describe our fuzzing approach.
Figure 3: The overview of V-Shuttle.
3.1 Threat Model
We assume that the attacker is a privileged guest user with full
memory access inside the virtual machine, which, in turn, can
send arbitrary data to its device. This assumption is reasonable
because each user has root privileges on his own virtual machine
in the public cloud scenario. If the hypervisor does not take care of
untrusted data from the guest user, security problems like denial-
of-service (DoS), information leakage, or privilege escalation may
happen. Once attackers exploit the vulnerability in the hypervisor
to escape the VM, they could take over other VMs on the same host,
enabling further access to sensitive data outside of the exploited
VM.
3.2 System Overview
Fig 3 shows a high-level overview of V-Shuttle, which leverages a
fuzzing agent integrated into the hypervisor to feed random input
to the virtual device - the fuzzing target. The fuzzing agent runs
in the hypervisor, persistently sending read/write requests to the
tested virtual device. The following list summarizes the high-level
functionalities of its main components.
The fuzzer is placed outside this hypervisor. Moreover, we lever-
age persistent mode to enable in-process fuzzing, which means we
do not restart a new instance for each new input. This is mainly
because: (1) Restarting a hypervisor process or reverting a snapshot
is prohibitively expensive in terms of run-time. Even with the fork-
server optimization, each new input still incurs the cost of fork().
(2) Hypervisor is an event-based system, which is designed to sup-
port long-running interaction. Empirically, most bugs are found by
repeated fuzz testing of discovered branches. That is because deep
states in hypervisor are less likely to be reached by one test case,
relying on multiple interactions to build prior states. This technique
not only enhances the overall fuzzing performance but also helps
to explore deep interactive states.
The fuzzing agent is the core component of V-Shuttle placed
inside the hypervisor, which (1) drives the fuzzing loop interacting
with both the fuzzer as well as the virtual device, and (2) man-
ages the DMA/MMIO allocation contexts. To adapt the traditional
application-fuzzing way to hypervisors, we redirect all data inter-
actions from the guest system to the fuzzed inputs. The fuzzing
agent emulates an attacker-controlled malicious guest kernel driver
Host SystemKernel Driver(KVM etc)Fuzzing AgentVirtual DeviceHypervisorFuzzerFuzzerGenerated InputCoverage FeedbackSeed Pool…Session 7B: Fuzzing CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2201in real-world scenarios, intercepting all DMA and IO read/write
instructions from the device. Every read/write operation from the
hypervisor device is dispatched to a registered function in the
fuzzing agent implementation, which performs actions and returns
fuzzer-generated data to the device. Note that the fuzzing agent is
a general component integrated into the hypervisor, which can be
adapted to almost all types of devices. When deploying the fuzzing
process on the new device, no additional human labor is required.
1 // before hooking
2 pci_dma_read(dev, buffer_addr, &buf, size);
3
4 // after hooking
5 if (fuzzing_mode)
6
read_from_testcase(&buf, size);
Listing 1: Conversion to fuzzed inputs.
3.3 DMA Redirection
As described in Section 2.3, heavy use of nested structures makes
fuzzing ineffective, as it requires precise memory layout of complex
nested structures, which is unfriendly to traditional fuzzing. Specif-
ically, when the fuzzer generates random data structures, including
the random pointer field, which indicates the following structure,
the execution likely stops due to invalid memory access. However,
providing syntactically valid structure info for mutators requires
lots of manual effort and is not scalable because different virtual
devices have different data structure specifications.
To this end, we design a generic DMA redirection approach to
flatten the nested structures by intercepting the device’s access to
the guest’s memory. Operating based on the source code of the
hypervisor, V-Shuttle hooks into the hypervisor’s DMA mecha-
nism and converts DMA transferring to reading from fuzzed input.
Specifically, we select the DMA-related APIs (e.g., pci_dma_read
and its wrapped function) as patterns and insert macros into the
target device’s source code. Then all DMA-related APIs are replaced
by macros with methods that read data from files. Thus all memory
reads can be redirected to file-based fuzzed inputs during fuzzing.
Listing 1 summarizes the simplified code of the DMA redirection.
The reason why V-SHUTTLE focuses on the DMA-related functions
is that they are responsible for delivering data between guest and
host, constituting the key mechanism in constructing the nested
data structures. In this way, the operation of DMA addressing is
eliminated completely. Since we have full control over the DMA
mechanism, any DMA request will be responded with a fuzzed in-
put generated by the traditional coverage-guided fuzzer, no matter
where the pointer points to, even address 0. Note that V-Shuttle
only manipulates the data that the devices read from the guest’s
memory, but not the data they write, because the devices are more
attackable by malformed guest input. When facing the DMA read
request in the run time, the following procedure is performed: 1)
V-Shuttle ensures that DMA read function call originates from
the target device we are monitoring. This is because we’re not
interested in DMA transfer requests from other internal system
components, which are not controlled by guest users. 2) Given the
host process buffer and the buffer’s size, V-Shuttle fetches appro-
priate data from the seed file generated by fuzzer directly, instead
of reading from the guest’s memory.
Figure 4 shows the flattened data structure graphically based
on DMA redirection. Contrary to the traditional fuzzing method
that generates well-structured inputs tediously in guest space, V-
Shuttle directly provides a flattened sequence of DMA data for
hypervisor fuzzing. This approach transforms all nested structures
into one-dimensional vectors while maintaining the semantics of
nested structures, such that all underlying code blocks are reachable
Figure 4: Flatten the nested structures into one-dimensional vectors
through DMA redirection.
through redirected DMA. For each fuzzing iteration, the fuzzer
engine first generates the sequences of mutated DMA data. Then
the device starts traversing the tree, in which each DMA request is
redirected to the fuzzed input, taking a block of data from the DMA
sequence in order. Thus, all code paths containing DMA requests
are able to be covered smoothly, rather than stuck somewhere the
device cannot fetch anything from the guest’s memory.
DMA redirection is an approach that only flattens the nested data
while leaving the semantics of the structure intact, which removes
the need for higher-level tree structures like the one in Firgure 2.
We eliminate the pointer in each node while still maintaining the
pointing dependence information implied by each node, so this will
not break the normal execution of the device. Benefiting from this
design, V-SHUTTLE does not rely on pointers to address data but
rather directly takes it from the fuzzed inputs. V-SHUTTLE treats
all data structures as a bunch of metadata without caring about
the pointers, just like userspace programs (ring 3). The content of
each node in a higher-level tree structure is generated randomly,
including the pointer field. As shown in Figure 2, the pointer to
a buffer and the pointer link between nodes are both randomly
generated. Each time a pointer is addressed, it will be redirected
to the fuzzed inputs. This design choice makes the fuzzing process
fully automatic to test the hard-to-trigger path requiring nested
structures, and does not require any user assistance. As compared
with state-of-the-art methods, our approach is fully scalable as well
as domain knowledge-free and thus provides better extensibility.
3.4 Semantics-Aware Fuzzing via SeedPools
Using the above-mentioned DMA redirection that flattens the
nested structure, we successfully automate the fuzzing process to
cover the primary execution paths. However, this intuitive method
does not take the node type into account when organizing DMA se-
quences, which introduces a low-efficiency problem. As described
Device EmulatorsGuest MemoryDATA1DMADATA2DATA3. . .redirectedDMAHypervisorFuzzed InputSession 7B: Fuzzing CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2202in Section 2.3, the node types in nested structures are dynami-
cally determined, which means the program’s control flow changes
dynamically depending on previously consumed DMA test cases.
However, the above-proposed method only organizes DMA data
into one-dimensional vectors in order, without classifying the type
of each node. Since the combination sequence of DMA requests
differs significantly in different fuzzing iterations, simply concate-
nating the node sequences leads to the loss of fuzzing semantics
for each node. Suppose the hypervisor requests structure A first
and then structure B in the current iteration. This renders coverage-
guided fuzzer teaching itself to generate seed with semantics close
to the combination sequence of A and B. However, if the hypervisor
requests structure A first and then structure C in the next iteration,
the execution flow will pass the path with A but fail in the path
with C. This fuzzer-generated structure B would be rejected by the
hypervisor, since structure B presents semantically invalid to the
requested structure C. Such an indeterministic process without clear
feedback guidance degenerates coverage-guided fuzzing into dumb
fuzzing, as the fuzzer would be confused about which direction to
evolve. Compared to the coverage-guided fuzzer, a semantics-blind
dumb fuzzer will waste time in the mutation process, resulting in
low test efficiency.