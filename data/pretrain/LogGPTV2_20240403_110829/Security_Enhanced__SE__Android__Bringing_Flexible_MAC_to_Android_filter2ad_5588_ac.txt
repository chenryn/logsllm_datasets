for apps and is the most mature mechanism.
Our install-time MAC mechanism applies install-time
checks of the permissions requested by an app, or implic-
itly granted by the system, against a MAC policy conﬁgu-
ration. This mechanism allows a policy-driven approach to
authorizing app installation that preserves the all-or-nothing
contract that Android presently offers to apps. Install-time
MAC differs from Android’s existing permission model in
that it ensures that policy has ﬁnal determination when
installing apps rather than the user. This approach en-
ables enforcement of organizational limits on the maximum
permissions for apps. The policy is expressed in a new
mac permissions.xml conﬁguration ﬁle described in Sec-
tion 3.3.2, and is enforced by extensions to the Android
PackageManagerService (PMS).
Integration of install-time MAC into the Android PMS
ensures that the policy checks are unbypassable and always
applied when apps are installed and when they are loaded
during system startup. As a result, restrictions can be ap-
plied even to pre-installed system apps via this mechanism,
in which case the app is completely disabled from running
if it is not authorized by the policy. For conventional third
party app installs, installation of the app is aborted if the
policy denies one of the requested permissions.
3.2.8. Runtime policy management. SE Android policy is
integrated into the Android build process and included in
the ramdisk image placed within the boot partition so that
it can be loaded by init very early in boot, before starting
any other processes. This approach ensures that all subse-
quent processes and ﬁles are labeled properly when created
and that policy is enforced as early as possible. However,
this approach does not directly allow runtime changes to the
policy without updating the entire boot image.
In order to support basic SELinux management function-
ality, we ﬁrst developed SELinux JNI bindings to support
setting of the SELinux enforcing mode and policy booleans
by the system server or system UID apps, which must be
signed by the platform certiﬁcate. We developed a SEAn-
droidManager app to permit user management of these set-
tings. This mechanism however does not support modifying
policy beyond setting policy booleans.
In order to support runtime policy management, we
added support for reloading any of the policy ﬁles from
the standard Android /data/system directory that is already
used for various runtime system conﬁguration data. This
directory is only writable by the system UID and thus these
conﬁguration ﬁles can only be updated by the Android sys-
tem server or system UID apps. Once the updated pol-
icy ﬁles have been written to /data/system, a policy reload
is initiated by setting a new Android system property, the
selinux.reload policy property, which also can only be set
by system UID processes. The ability to write these ﬁles
and set this property can be further restricted using SE An-
droid policy.
Each time the property is set, the init process reloads the
kernel policy as well as any other policy conﬁguration ﬁles
it uses, e.g. the ﬁle contexts and property contexts conﬁgu-
rations. The init process then executes any triggers deﬁned
for the selinux.reload policy property in the init.rc conﬁg-
uration. We added a trigger to the init.rc conﬁguration to
restart the ueventd and installd daemons so that they also
reload the policy conﬁguration ﬁles relevant to their opera-
tion. We conﬁrmed that restarting of these daemons at run-
time does not cause any problems for Android. An alterna-
tive approach would have been to notify the daemons of the
policy reload via their existing socket interfaces and allow
them to reload policy without restarting.
With this support in place, we created device admin APIs
to allow management of the SELinux settings and provi-
sioning of alternate policy conﬁgurations via a device ad-
min app. We also created a sample device admin app, SE-
AndroidAdmin, to demonstrate these APIs. The code from
this sample app could be leveraged by MDM vendors as a
starting point for integrating support for SE Android man-
agement.
3.3. Policy conﬁguration
Policy conﬁguration for SE Android can be divided into
two categories. The kernel layer MAC mechanism is gov-
erned by the SELinux policy conﬁguration, which includes
both the kernel policy and various conﬁguration ﬁles lever-
aged by userspace to look up SELinux security contexts.
The middleware MAC mechanisms are governed by their
own conﬁgurations. This section describes each conﬁgura-
tion for SE Android.
3.3.1. SELinux policy conﬁguration. Our goal for SE An-
droid was to apply SELinux to enforce a small set of plat-
form security goals in a manner that would avoid any user-
visible or app developer-visible changes. Recognizing that
Android was unlikely to discard its existing DAC model
altogether, we focused on using SELinux to reinforce the
DAC model and to address the gaps left by the DAC model.
Primarily, we wanted a policy that would conﬁne the priv-
ileged daemons in Android, ensure that the Android mid-
dleware components could not be bypassed, and strongly
isolate apps from each other and from the system.
As explained in Section 2.3, the SELinux reference pol-
icy was not suitable as a starting point for Android SELinux
policy conﬁguration.
Instead, we created a small policy
from scratch tailored to Android’s userspace software stack
and to our security goals. The Type Enforcement (TE) por-
tion of the policy was conﬁgured to deﬁne conﬁned domains
for the system daemons and apps. The Multi-Level Secu-
rity (MLS) portion of the policy was conﬁgured to isolate
app processes and ﬁles from each other based on MLS cat-
egories. This approach yielded a small, ﬁxed policy at the
kernel layer with no requirement for policy writing by An-
droid app developers. As with the existing DAC model, the
kernel layer MAC is normally invisible to users and to apps,
only manifesting if an app violates one of the security goals.
Size
Domains
Types
Allows
Transitions
Unconﬁned
SE Android Fedora
4828K
71K
702
39
182
3197
96010
1251
14963
65
3
61
Table 3. Policy size and complexity.
The SE Android policy is signiﬁcantly smaller and sim-
pler than the SELinux policies used in conventional Linux
distributions. Table 3 shows some statistics for the SE An-
droid policy compared to the Fedora SELinux policy. The
SE Android policy is notably smaller in terms of the binary
policy size, the number of domains (subjects), the number
of types (objects), the number of allow rules, and the num-
ber of type transitions. The SE Android policy also differs
in that it deﬁnes very few unconﬁned domains (i.e. domains
that are allowed all permissions); in particular, only the do-
mains for kernel threads, the init process, and the su pro-
gram (which is only included in debug builds) are uncon-
ﬁned. No app domains are unconﬁned in SE Android. The
source ﬁles for the SE Android policy can be found within
the external/sepolicy directory of the Android Open Source
Project (AOSP) master branch.
Two new conﬁguration ﬁles were added to the Android
SELinux policy conﬁguration for use by applications. The
property contexts conﬁguration is used to specify the secu-
rity context of Android system properties. This conﬁgura-
tion is used by the init property service as described in Sec-
tion 3.2.6. The seapp contexts conﬁguration is used to label
app processes and app package directories. This conﬁgura-
tion is used by the Dalvik VM and by installd as described
in Section 3.2.5.
3.3.2. Middleware policy. The mac permissions.xml con-
ﬁguration for the install-time MAC mechanism is written in
XML format and follows the conventions of other Android
system conﬁguration ﬁles. Recognizing that managing ac-
cess control policies for potentially hundreds of apps on a
per-app basis was infeasible, we provided a scalable policy
that does not require a new policy for each app. In order
to express app-permission authorizations without having to
specify per-app rules, we devised a method to specify X.509
certiﬁcates as part of our policy. Android already requires
each installed app to be signed with such a certiﬁcate. We
leveraged this existing attribute of Android apps by identi-
fying groups of apps in our conﬁguration by their certiﬁcate.
The mac permissions.xml conﬁguration uses the AOSP
signing keys to organize apps into equivalence classes and
to allow or deny, based on whitelist/blacklist logic, an ap-
propriate permission set. Each entry in the conﬁguration
can also contain a seinfo tag to specify the seinfo string used
for app security labeling. Individual apps can be speciﬁed
when appropriate by package name in addition to specify-
ing their certiﬁcate. As enumerating all possible third party
app certiﬁcates is infeasible, we provide a default tag that is
used to match any apps that are not otherwise speciﬁed by
the conﬁguration.
4. Analysis
This section surveys a set of previously published ex-
ploits and vulnerabilities for Android and describes the re-
sults of analysis and testing performed to assess the effec-
tiveness of SE Android in addressing the threats of ﬂawed
and malicious apps. It then provides a general discussion
of the threats that can and cannot be mitigated by SE An-
droid. The analysis and testing was performed using the ini-
tial SE Android policy conﬁguration developed before read-
ing about any of these speciﬁc exploits or vulnerabilities in
Android. The policy conﬁguration was developed based on
normal Android operation and SELinux policy development
practices.
4.1. Root exploits
The ﬁrst class of exploits and vulnerabilities that was
evaluated were Android root exploits. These exploits esca-
late privilege from an unprivileged app or user shell to gain
full root access to the device, enabling the exploit to then
perform arbitrary actions on the device. Often these root
exploits are developed by the Android modding community
for the purpose of enabling them to modify their own de-
vices for customization and optimization. However, these
exploits can also be leveraged by malware to gain complete
control of a user’s device.
4.1.1. GingerBreak and Exploid. The Android volume
daemon or vold is a system service that runs as root on An-
droid and manages the mounting of the SDcard (and in An-
droid 4.0 and later, the mounting of the encrypted storage).
In order to support this functionality, vold listens for mes-
sages on a netlink socket in order receive notiﬁcations from
the kernel.
CVE-2011-1823 identiﬁes a vulnerability in vold’s han-
dling of the netlink messages [33]. First, vold did not verify
that the netlink messages originated from the kernel, and it
was possible for unprivileged applications to generate mes-
sages on these sockets. Second, vold used a signed integer
from the message as an array index, checking only for an
upper bound but not whether the integer was non-negative.
The GingerBreak exploit demonstrated how to exploit
this vulnerability in order to gain root access from a user
shell [23]. The exploit has also been packaged as an An-
droid app and has shown up in the wild in Android malware
in the GingerMaster malware [19].
The GingerBreak exploit code is able to dynamically sur-
vey the device in order to ﬁnd all of the information it re-
quires to mount a successful attack on vold. It obtains the
PID of the vold process from the proc ﬁlesystem, and it ob-
tains information required to craft the malicious payload by
reading several ﬁles from the system partition. It also makes
use of access to the Android logging facility (logcat) in or-
der to dynamically observe the effect of its attacks on vold
and reﬁne its attack incrementally until successful.
Once GingerBreak has found the vold process and
crafted the malicious payload, it sends the payload to vold
via a netlink socket. The payload triggers execution of the
exploit binary by vold and the exploit code is then running
with full root privileges. The exploit code then proceeds to
create a setuid-root shell, and the original GingerBreak pro-
cess executes this setuid-root shell to give the user a root
shell.
We performed an analysis and testing of the impact of
SE Android on GingerBreak. During the information col-
lection stage of GingerBreak, the policy denied the exploit’s
attempt to read the proc information for the vold process,
and it denied the exploit’s attempt to read the vold binary to
discover the target address range. This caused the exploit
to fail immediately. However, we assumed for the sake of
further analysis that the exploit writer could have rewritten
the exploit based on prior knowledge of the target, and al-
lowed the corresponding permissions for the sake of further
testing.
Next, the policy denied GingerBreak’s attempt to create
the netlink socket, as there is no legitimate need for user
shells or apps to create this type of socket. Thus, the exploit
could not even reach the vulnerable code in vold. This pro-
vided unbypassable protection for the vulnerability; how-
ever, we allowed the necessary permissions and continued
our analysis.
GingerBreak was then able to send the malicious pay-
load to vold. However, this merely triggered an attempt to
execute the exploit binary from vold, which was also de-
nied by policy. There was no legitimate case where vold
executed non-system binaries, so the attempt to execute a
binary from the data partition was not allowed by the policy
we had developed. The exploit again failed, but we assumed
for the sake of further analysis that the exploit writer could
have rewritten the exploit to avoid executing a separate bi-
nary from the ﬁlesystem and simply allowed this permis-
sion.
Once running as root, the exploit code then attempts to
create a setuid-root shell. SE Android denied the attempt to
set the ownership and mode of the exploit ﬁle (or any ﬁle
writable by the exploit). We allowed these permissions for
the sake of further testing.
In its ﬁnal act, assuming all of the previous denials were
allowed, GingerBreak then executed the setuid-root shell.
This did provide the user with a uid 0 shell, but the SELinux
security context remained the same, and the shell was still
limited to the same set of permissions with no superuser
privileges allowed by SELinux.
In summary, SE Android would have blocked the exploit
at many points in its execution and would have forced the
exploit writer to tailor the exploit to the target rather than
being able to survey the target device at runtime for all of the
necessary information. SE Android also would have made
the underlying vulnerability in vold completely unreachable
from an app or an unprivileged user shell.
A similar vulnerability was discovered in Android’s
ueventd daemon. The vulnerability was the same ﬂaw re-
ported as CVE-2009-1185 [30] for the Linux udev imple-
mentation, simply replicated in Android’s ueventd imple-
mentation. The Exploid exploit demonstrated how to ex-
ploit this vulnerability in order to gain root access from a
user shell [22]. In our analysis and testing of Exploid on
SE Android, we found that Exploid would have been com-
pletely blocked in at least two ways by SE Android. SE
Android would have blocked not only these two speciﬁc
vulnerabilities, but all vulnerabilities that fall into the same
class, i.e. vulnerabilities in netlink socket message handling
in privileged daemons.
4.1.2. Zimperlich and RageAgainstTheCage. The An-
droid zygote is a system service that runs as root and is
responsible for spawning all Android apps. The zygote re-
ceives requests to spawn apps over a local socket. The zy-
gote forks a child process for each app and the child process
uses setuid() to switch to the unprivileged UID for the app
before executing any app code. The particular code imple-
menting this logic lives in the Dalvik VM.
However, the Dalvik VM did not check for failure on
the setuid() call, as this call normally does not fail for root
processes, and therefore did not abort the process on a failed
setuid(). The Zimperlich [24] exploit demonstrated how to
exploit this vulnerability in order to gain root access from
an Android app. It achieves this access by inducing a failure
in the setuid() call through a subtle interaction with Linux
resource limits.
First, the exploit code forks itself repeatedly in order to
reach the maximum number of processes allowed per uid
(RLIMIT NPROC) for the app UID. It then issues a request
to the zygote over the local socket to spawn one of its com-
ponents in a new process. When the zygote forks a child
process and attempts to set the app UID, the setuid() call
fails due to reaching the resource limit. As the Dalvik VM
did not abort in this situation, execution proceeds and the
malicious app’s code is run in the same UID as the zygote,
i.e. as a root process. The Zimperlich exploit then proceeds
to re-mount the system partition read-write and creates a
setuid-root shell in the system partition for later use in ob-
taining root access at any time.
In our analysis and testing of Zimperlich on SE Android,
we found that although the malicious app succeeds in run-
ning with the root UID, the SELinux security context is still
correctly set by the Dalvik VM based on the app’s creden-
tials, as this operation is not subject to a resource limit. Con-
sequently, the app runs in an unprivileged security context
with no superuser capabilities and is unable to re-mount the
system partition or perform other privileged actions.
A similar vulnerability was discovered in the An-
droid debug bridge daemon or adbd. The RageAgainst-