FreeBSD
zone_mbuf:[0, 256)=*
Linux
ip_dst_cache:[64, 68)=*
kmalloc-96:[0, 8)=kaddr
kmalloc-96:[8, 16)=kaddr
NA
kmalloc-64:[0, 8)=kaddr:
[8, 16)=kaddr:[16, 18)<238:[18, 64)=*
kmalloc-96:[0, 11)=*:[11, 12)=’\0’
kmalloc-4096:[2160, 2168)=*
Suitable
objects #
1
0
3
0
12 + (1)
2
0
Security
Impact
BA, AR 6
NA
SC, HC, BA
NA
SC, HC
BA, AR
HC, BA
NA
XNU
kalloc.192:[0, 192)=*
kalloc.256:[0, 256)=*
4 + (1)
3
HC, BA, AR
HC, BA
Table 2: Exploitability summary sampled from Table 7. #
in the third column indicates # of elastic objects useful for
the exploitation of the corresponding vulnerability. # in the
parentheses indicates # of elastic objects useful for exploita-
tion, but the paths to their leaking anchors include variables.
In the last column, SC, HC, and BA signify, the vulnerability
could disclose stack canary, heap cookie, and base address,
respectively. AR indicates it could perform arbitrary kernel
read.
anchor. As such, as we can observe from Table 1, only the object
ip_options provides a vulnerability with the potential to disclose
data not only from the kernel heap but also from the kernel stack.
From the column “Constraints” in Table 1, 4, 5 and 6, we can
also observe that there are a few kernel objects (marked with a
dagger symbol), the constraint sets of which involve variables. As
we specify in Section 4, when pairing objects with vulnerability, we
conservatively discard the paths associated with these constraints
and ignore the corresponding kernel objects accordingly. While
this inevitably reduces the total number of elastic objects available
for exploitation, their influence upon exploit mitigation bypassing
is negligible because the elastic objects falling into this category
are minimal (10 out of 74).
5.3 Results of Experiment II
Summary of effectiveness in bypassing mitigation. Due to
the page limit, we only sample some vulnerabilities from Table 7
and show them in Table 2. The results in both tables indicate the
exploitability of the vulnerabilities under the facilitation of elastic
kernel objects. As we can observe from Table 7, about 67.5% (27
out of 40) vulnerabilities successfully demonstrate the ability to
bypass not only KASLR but also heap cookie protector. Among
these 27 vulnerabilities, 12 vulnerabilities also provide us with the
ability to uncover stack canary and 8 vulnerabilities also exhibit the
capability of performing arbitrary kernel read. These observations
indicate that elastic kernel objects could generally make existing
kernel protection futile.
Exploit diversity. From Table 2 & 7, we can also observe that
for all exploitable vulnerabilities (except for the one indicated by
CVE-2017-2370), there are more than one elastic kernel objects
useful for exploitation and mitigation circumvention. For some
vulnerabilities, the number of useful kernel objects is even larger
6FreeBSD has no heap cookie protection and thus no security impact on heap protector.
(e.g., the one indicated by CVE-2017-7184 listed in Table 7). From
the column “Capability” in both tables, we can discover that this
richness results from ❶ the ability to corrupt kernel heap data in
various caches/zones and ❷ the ability to overwrite elastic objects
with less restriction.
In this work, we argue that the richness of the elastic objects
could also be very disconcerting. On the one hand, it is because more
elastic objects offer more opportunities to bypass mitigations (e.g.,
the vulnerability tied to CVE-2017-8890 demonstrating the ability
to bypass various mitigations). On the other hand, it is because the
richness potentially diversifies the way to craft a working exploit,
making the pattern-based exploitation detection more challenging.
Analysis of failure cases. For the 13 vulnerabilities that ELOISE
fails to pinpoint a suitable object, we perform a manual diagno-
sis and have the following discovery. As of the vulnerabilities
tied to CVE-2018-5703, CVE-2018-12233, CVE-2018-1000112, and
3d67[68], their PoC programs only demonstrate the ability to over-
write the data inside the vulnerable object. These vulnerabilities
naturally fall short of the power of manipulating any fields in elas-
tic objects. For vulnerabilities corresponding to CVE-2018-18559,
CVE-2017-15649, CVE-2017-10661, CVE-2019-6225, and 422a[69],
while their PoC programs demonstrate the ability to corrupt some
data in general caches/zones, ELOISE cannot track down any ker-
nel object with its length field overlapping with the corrupted re-
gion. For the vulnerability indicated by CVE-2018-4243, although
ELOISE identifies objects overlapping with the corrupted region, the
vulnerability provides only the ability to overwrite the length field
with all zeros. Regarding vulnerabilities associated with CVE-2019-5603,
CVE-2019-5596, and bf96[74], the corruption happens in special
caches/zones in which no elastic objects are available for further
exploitation.
5.4 Results of Experiment III
The A/B test experiment results show that Group A, equipped with
ELOISE, succeeded in disclosing the base address of kernel image
and bypassing KASLR for all 5 vulnerabilities, whereas Group B
failed all. To get insights on this significant difference, we reviewed
the surveys gathered from both groups while they analyzed vulner-
abilities and developed exploits. For more detailed results, readers
could refer to Appendix A.5.
From our collected survey results, we found that it took roughly
0.5∼2 hours for the two groups to finish exploring the capability of
one vulnerability. On the one hand, it indicates that the two groups
have no apparent difference in expertise level. On the other hand,
this result shows that the capability exploration is not a heavy
workload for security analysts with Linux kernel debugging experi-
ence. This conclusion aligns with our post-test survey, in which all
participants stated that the capability exploration is not a challeng-
ing task when the corresponding PoC program is provided. They
reported that after the PoC program is given, they can rely on the
built-in debugging features in the kernel (e.g., KASAN) to quickly
learn which cache is corrupted and which part of the memory is
corrupted. Then, they can disable KASAN, use GDB to trace kernel
execution, and thus determine the value of overwritten data under
their control.
From our collected survey (summarized in Table 9), we also dis-
covered that under the guidance of our tool ELOISE, Group A could
complete the identification of elastic objects in less than 0.5 hours.
In contrast, Group B was stuck in this identification stage and made
no progress for any of these 5 vulnerabilities in 24 hours. This signif-
icant difference implies the ELOISE’s benefits in identifying elastic
objects in the kernel and facilitating the exploitation. Following
this observation, we also reviewed our post-test survey results. We
observed that Group B thought the most challenging part of the
exploitation is searching for the elastic objects and ”felt frustrated”
when facing the large codebase. For Group A, the post-test survey
indicates that the most challenging part for exploit development is
how to stabilize exploitation. They stated that unexpected kernel
activities could intervene in the heap layout manipulation, mak-
ing the disclosed data useless for bypassing KASLR. For example,
Group A reported that their exploits leak all zero or other trash
value from time to time. They put lots of effort into taming noisy
kernel activities.
Based on our A/B test experiment, we argue that ELOISE is ben-
eficial for exploit development. Although it is not an end-to-end
automation tool, it could save security analysts’ efforts to search
for the elastic objects in the kernel and match them with the vul-
nerabilities. Using ELOISE, analysts could craft a working exploit
more efficiently.
6 DEFENSE MECHANISM
In this section, we first discuss existing defense mechanisms. Then,
we describe the design, implement and evaluation of our defense
approach. Due to the space limit, we leave alternative defense mech-
anisms and future research in Appendix A.4.
6.1 Existing Defense Mechanisms
Recall that the exploitation method discussed in this paper requires
manipulating the kernel heap layout. Intuition suggests that the
existing defense most likely to mitigate this exploitation method
is heap freelist randomization [16, 23]. However, this approach
cannot be an effective solution to our problem. One is because re-
search [16] has already demonstrated that freelist randomization
has no effects on mitigating exploitation against use-after-free and
double-free vulnerabilities. The other is because there have already
been many techniques proposed for bypassing this mitigation ef-
fectively (e.g., [6, 28, 44]).
In addition to memory layout manipulation, the exploitation
method also needs to accurately locate and modify the length field
in an elastic object. As a result, another possible existing defense
is structure layout randomization [15], which shuffles the fields in
a data structure at the compilation phase for preventing attackers
from predicting the offset of sensitive data within the structure.
In this work, we argue this defense is also not likely to be useful
nor practical for our problem because it relies upon a random seed
to perform randomization, and the protection of this seed is not
trivial. For example, Linux distros [35] have to expose the random
seed to their users for building third-party kernel modules. Besides,
there are intensive on-going discussions about how to prevent a
random seed from being accessed by unprivileged users on the
same machine [32].
Apart from above defenses, both Linux and XNU kernel import
"USERCOPY" checking [22] from PaX/Grsecurity team. This hard-
ening ensures that the length argument does not exceed the size of
cache/zone slot or stack frame. While this technique can mitigate
the threat of some elastic objects, it suffers from two problems. On
the one hand, it only enforces the length checking for copy_{from/
(cid:44)→ to}_user() and copyout(). Other critical kernel functions for data
transferring are not included. On the other hand, the legit length
range is not restricted enough. It is still possible to leak sensitive
data residing in the cache/zone slot or stack frame.
6.2 Our Defense Approach
Design. To mitigate the threat of elastic objects, we propose a new
defense mechanism. It isolates elastic objects that ELOISE identifies
into individual shadow caches/zones. To be specific, we create
an isolated shadow cache/zone (e.g., kmalloc-isolated-16) for each
general cache/zone (e.g., kmalloc-16). Using shadow caches/zones,
we store elastic objects with the corresponding sizes. For example,
the elastic object ldt_struct originally allocated in kmalloc-16 will
be assigned in kmalloc-isolated-16 after the isolation mechanism is
enabled.
With the isolation mechanism, an adversary has little chance to
leverage the vulnerability tied to other objects to manipulate the
length (and pointer) field in elastic objects. Besides, common heap
spray objects and kernel objects with sensitive information like
function pointers are also isolated from the elastic objects. They
could not be used for heap Fengshui and spraying. Admittedly,
an elastic object itself could also be potentially vulnerable, which
provides attackers with the ability to overwrite other elastic objects
sharing the same isolated shadow cache/zone. However, as showed
in the following section, vulnerable elastic objects are relatively
fewer than non-elastic vulnerable objects. Therefore, the cache-
isolation-based defense dramatically raises the bar for launching
the exploitation method and reduces leaked data’s significance. Note
that our defense approach is very different from a recently proposed
isolation mechanism – xMP [58]. xMP provides page granularity
isolation. With such isolation granularity, overwrite/overread still
work, and the exploitation method is still effective.
Implementation. We implemented and prototyped the proposed
isolation-based mitigation in the Linux kernel. To be specific, we
added the support of our mitigation method by creating the shadow
caches and other caches at the boot time. Further, we modified the
kernel source code by adding one more flag (e.g., __GFP_ISOLATE). In
our implementation, we used this flag as an additional argument
for the functions that allocate kernel objects (e.g., kmalloc()). Using
this flag as an indicator, our modified kernel could determine if
the allocated objects should be placed in the shadow caches. To
determine which allocation should happen at the shadow cache, we
use the output of ELOISE. It indicates which calls indeed allocate
elastic objects. In this way, we can ensure that the elastic objects
can be isolated from other kernel objects physically.
Performance Evaluation. We evaluate the performance overhead
of the proposed mitigation on a machine with a 1.6 GHz CPU, 16GB
RAM, and 500 GB HDD. Our hardened kernel is modified from
a plain Linux kernel, which is v5.5.3 (same as the kernel version
used in our previous experiment). We conducted the measurements
using three sets of benchmarks. The first set is micro-benchmarks
from LMbench v3.0 [51], which tests the latency and bandwidth of
common system calls and I/O operations. The second set is macro-
benchmarks from Phoronix Test Suite 9.8 [1], which runs five real-
world applications. To prevent the overhead from being hidden
behind sophisticated kernel execution, we especially designed the
third set benchmark to stress-test the impact of our mitigation ap-
proach. This set of customized benchmarks uses the system call
sequences to reach elastic object allocation and corresponding data
leakage intensively. In our experiment setup, we ran the three sets
of benchmarks for three rounds and calculated the average. Due
to the space limit, we list the detailed results in Table 8 (in the
Appendix). Overall, we could observe that the performance over-
head is negligible, with the average 0.19% performance drop. From
Table 8, we could also find that for TCP socket I/O throughput, the
hardened kernel even performs better (6.29% improvement). This
fluctuation is presumably because our mitigation approach changes
the hit rate of hardware cache, and the deviation of benchmarks
adds uncertainty to the measurement.
Security Evaluation. We also evaluated the security of our pro-
posed mitigation approach by re-pairing the vulnerabilities with
elastic objects. For all Linux vulnerabilities shown in Table 7 (ex-
cept for CVE-2017-7184 and CVE-2017-17053), ELOISE no longer reports
elastic objects available for performing the exploitation after our
isolation mechanism is applied. It is because the elastic objects and
vulnerable objects are mostly different. They are isolated into two
caches. There is no longer a possibility to use vulnerable objects to
manipulate the length field of an elastic object. For vulnerable ob-
jects in CVE-2017-7184 and CVE-2017-17053, they are also elastic objects
allocated in the shadow caches. Technically, they can be leveraged
to overwrite data in the isolated caches and thus manipulate the
length field of an elastic object for data disclosure. However, we
argue that, even if this situation exists, it does not dilute our pro-
posed defense method because the disclosed data is not likely to
be useful for bypassing kernel mitigation. Taking the practice of
circumventing KASLR using CVE-2017-17053 as an example, to use
the vulnerable object to reveal a kernel base address, in addition to
leveraging the elastic object, an attacker usually has to identify a
general object that encloses a function pointer. Then, the attacker
needs to place the object in the same isolated cache. However, due
to general and elastic kernel object isolation, such an object is no
longer available for this isolated cache.
7 RELATED WORK
The works most relevant to ours include escalating exploitability
for bypassing exploit mitigation and designing automated methods
to facilitating exploit development. Here, we summarize and discuss
them below.
Escalating exploitability. Side-channel based attack [24, 34] is
one common approach for exploitability escalation. Technically, it
leverages hardware features to disclose critical information from
the kernel. For example, by taking advantage of Intel TSX, Jang et
al. present a highly stable timing attack against KASLR [37]. Gruss et
al. propose to utilize pre-fetch instructions to circumvent KASLR
without triggering SMEP/SMAP protection [27]. Lipp et al. intro-
duce a method to read arbitrary kernel memory from userland by
exploiting out-of-order execution in modern processors [46].
Another exploitability escalation method is through new ex-
ploitation approaches. For example, ret2dir [39] injects exploita-
tion payload to physmap instead of user space to circumvent SMEP
and SMAP. To bypass a series of Linux kernel protection (except
for KASLR), the technique KEPLER [79] first transforms a control-
flow hijacking primitive into a stack overflow. Then, it utilizes that
overflow to enable an ROP attack in the Linux kernel. To avoid
being caught by CFI, Data-only attack [9] exploits the vulnerable
software through corrupting data flow instead of triggering critical
control flow examination.
Facilitating exploit development. Researchers have proposed
many exploitation automation techniques, ranging from the works
that assemble exploits fully automatically (e.g., [4, 7, 8, 33, 62,
63, 66]) to the works that partially facilitate exploit development
(e.g., [5, 29, 30, 36, 59, 78, 82]). However, they can barely tackle
the unique challenges in the kernel. Presumably, as such, we re-
cently witnessed many research efforts on the kernel exploitation
facilitation.
For example, Xu et al. propose two memory collision attack mech-
anisms [81] to assist heap spray in kernel Use-After-Free exploita-
tion. Lu et al. introduce a deterministic stack spraying exploitation
method and a reliable exhaustive memory spraying technique to
facilitate the exploitation of Use-Before-Initialization vulnerabil-
ities in the Linux kernel [49]. Following this, Cho et al. further
extend the stack spraying method in [14]. To expedite the explo-
ration of useful primitives for kernel Use-After-free exploitation,
FUZE [80] searches exploitable machine states by utilizing under-
context fuzzing along with symbolic execution. Chen et al. design
a capability-guided fuzzing technique that extracts the capability
for out-of-bound write vulnerabilities in the Linux kernel [10]. To
obtain the desired heap layout for kernel exploitation, SLAKE [11]
proposes a method to navigate kernel objects and then an algorithm
to elastic kernel layout automatically.
Uniqueness of our work. First, rather than exploiting hardware
features, we explore exploitability escalation by exploiting the capa-
bility demonstrated by kernel vulnerabilities as well as the nature of
kernel objects. Second, instead of developing yet another method to
circumventing exploit mitigation such as SMEP/SMAP, we focus on
the exploitation method that could bypass KASLR and heap/stack
cookies or perform arbitrary read in the kernel. Third, different
from the works that facilitate exploit development without consid-
ering mitigation circumvent, our proposed techniques facilitate an
attacker’s ability to assemble a working exploit with the capabil-
ity of bypassing widely deployed kernel mitigation. Last but not
least, rather than focusing on one particular type of vulnerability,
this work targets exploitability escalation and exploitation facili-
tation for all types of vulnerabilities that could demonstrate data
corruption on the kernel heap.
8 CONCLUSION
Using elastic objects to bypass kernel protection is a commonly
adopted exploitation practice. However, no systematic research
has been conducted to study the effectiveness of this exploitation
method. As such, it has not yet raised sufficient awareness and
motivates the development of a defense against such exploitation.
In this work, we show that elastic objects could nearly always
facilitate a kernel vulnerability to bypass exploitation mitigation
such as KASLR, heap cookie protector, and stack canary. Taking
a close look at existing kernel defense mechanisms, we discover