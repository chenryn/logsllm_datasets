6.4.1 Sensitive Data Lifespan
A common defense employed to reduce the effective-
ness of data-oriented attacks is to limit the lifespan of
security-critical data [19, 20]. This case study highlights
the difﬁculty of doing it correctly. In the implementa-
tion of SSHD, the program explicitly zeros out sensi-
tive data, such as the RSA private keys, as soon as they
are not in use. For password authentication on Linux,
getspnam() provided by glibc is often used to ob-
tain the password hash. Rather than using the password
hash directly, SSHD makes a local copy of the password
USENIX Association  
24th USENIX Security Symposium  189
13
hash on stack for its use. Although the program makes
no special effort is to clear the copy on the stack, the
password on stack is eventually overwritten by subse-
quent function frames before it can be leaked. The devel-
oper explicitly deallocates the original hash value using
endspent() [1] in the glibc internal data structures.
However, glibc does not clear the deallocated memory
after endspent() is called and this allows FLOW-
STITCH to successfully leak the hash from the copy held
by glibc. Hence, this case study highlights that sensitive
information should not be kept by the program after us-
age, and that identifying all copies of sensitive data in
memory is difﬁcult at the source level.
6.4.2 Multi-edge Stitch – ghttpd CGI Directory
The ghttpd application is a light-weight web server
supporting CGI. A stack buffer overﬂow vulnerability
was reported in version 1.4.0 - 1.4.3, allowing remote at-
tackers to smash the stack of the vulnerable Log() func-
tion. During the security-sensitive data identiﬁcation,
FLOWSTITCH detects execv() is used to run an exe-
cutable ﬁle. One of execv()’s arguments is the address
of the program path string. Controlling it allows attack-
ers to run arbitrary commands. FLOWSTITCH is unable
to ﬁnd a new data dependency edge using single-edge
stitching, since there is no security-sensitive data on the
stack frame to corrupt. FLOWSTITCH then proceeds to
search for a multi-edge stitch. For the program path pa-
rameter of execv(), FLOWSTITCH identiﬁes its ﬂow,
which includes use of a series of stack frame-base point-
ers saved in memory. The temporal constraints of the
memory error exploit only allow the saved %ebp of the
Log() function to be corrupted. Once the Log() func-
tion returns, the saved %ebp is used as a pointer, refer-
ring to all the local variables and parameters of Log()
caller’s stack frame. FLOWSTITCH corrupts the saved
%ebp to change the variable for the CGI directory used
in execv() system call. This attack is a four-edge stitch
by composing two pointer stitches.
Chen et al. [19] discussed a data-oriented attack with
the same vulnerability, which was in fact a two-edge
stitch. However, that attack no longer works in our exper-
iment. The ghttpd program compiled on our Ubuntu
12.04 platform does not store the address of command
string on the stack frame of Log(). Only the four-edge
stitching can be used to attack our ghttpd binary.
6.4.3 Bypassing ASLR – orzhttpd Attacks
The orzhttpd web server has a format string vulnera-
bility which the attacker can exploit to control almost the
whole memory space of the vulnerable program. FLOW-
STITCH identiﬁes the deterministic memory region and
the randomized address on stack under fprintf()
frame. The ﬁrst attack which bypasses ASLR is a privi-
lege escalation attack. This attack corrupts the web root
directory with single-edge stitching and memory address
reuse. The root directory string is stored on the heap,
which is allocated at runtime. FLOWSTITCH identiﬁes
the address of the heap string from the stack and reuses it
to directly change the string to / based on the pre-deﬁned
goal (Section 4.2). The second attack is an information
leakage attack, which leaks randomized addresses in the
.got.plt section. FLOWSTITCH identiﬁes the deter-
ministic memory region from the binary and performs
a multi-edge stitch. The stitch involves modifying the
pointer of an HTTP protocol string stored in a determin-
istic memory region. FLOWSTITCH changes the pointer
value to the address of .got.plt section and a sub-
sequent call to send the HTTP protocol string leaks the
randomized addresses to attackers.
6.4.4 Privilege Escalation – Nginx Root Directory
The Nginx HTTP server 1.3.9-1.4.0 has a buffer over-
ﬂow vulnerability [4]. FLOWSTITCH checks the local
variables on the vulnerable stack and identiﬁes two data
pointers that can be used to perform arbitrary memory
corruption. The memory inﬂuence of the overwriting is
limited by the program logic. FLOWSTITCH identiﬁes
the web root directory string from the conﬁguration data.
It tries single-edge stitching to corrupt the root directory
setting. The root directory string is inside the memory in-
ﬂuence of the arbitrary overwriting. FLOWSTITCH over-
writes the value 0x002f into the string location, thus
changing the root directory into /. FLOWSTITCH veri-
ﬁes the attack by requesting /etc/passwd ﬁle. As a
result, the server sends the ﬁle content back to the client.
Information Leakage – httpdx Password
6.4.5
The httpdx server has a format string vulnerability be-
tween version 1.4 to 1.5 [3]. The vulnerable tolog()
function records FTP commands and HTTP requests into
a server-side log ﬁle. Note that direct exploitation of this
vulnerability does not leak information. Using the error-
exhibiting trace, FLOWSTITCH identiﬁes the memory er-
ror instruction and ﬁgures out that there is almost no lim-
itation on the memory range affected by attackers. From
the httpdx binary, FLOWSTITCH manages to ﬁnd a to-
tal of 102MB of deterministic memory addresses. From
the benign trace, FLOWSTITCH generates data ﬂows of
the root user passwords. This is the secret to be leaked
out. The FLOWSTITCH generates the necessary data ﬂow
which reaches the send() system call automatically.
Starting from the memory error instruction, FLOW-
STITCH searches backwards in the secret data ﬂow and
identiﬁes vertices inside the deterministic memory re-
gion. FLOWSTITCH successfully ﬁnds two such mem-
ory locations containing the “admin” password: one is a
190  24th USENIX Security Symposium 
USENIX Association
14
buffer containing the whole conﬁguration ﬁle, and an-
other only contains the password. At the same time,
FLOWSTITCH searches forwards in the output ﬂow to
ﬁnd the vertices that affect
the buffer argument of
send(). Our tool identiﬁes vertices within the deter-
ministic memory region. The solver gives one possible
input that will trigger the attack. FLOWSTITCH conﬁrms
this attack by providing the attack input to the server and
receiving the “admin” user password.
7 Related Work
Data-Oriented Attack. Several work [21, 32, 36, 38, 41,
43, 44] has been done to improve the practicality of CFI,
increasing the barrier to constructing control ﬂow hijack-
ing attacks. Instead, data-oriented attacks are serious al-
ternatives. Data-oriented attacks have been conceptually
known for a decade. Chen et al. constructed non-control-
data exploits to show that data-oriented attack is a real-
istic threat [19]. However, no systematic method to de-
velop data-oriented attacks is known yet. In our paper,
we develop a systematic way to search for possible data-
oriented attacks. This method searches attacks within the
candidate space efﬁciently and effectively.
Automatic Exploit Generation. Brumley et al. [17] de-
scribed an automatic exploit generation technique based
on program patches. The idea is to identify the difference
between the patched and the unpatched binaries, and
generate an input to trigger the difference. Avgerinos et
al. [13] discussed Automatic Exploit Generation(AEG)
to generate real exploits resulting in a working shell. Fel-
metsger et al. [24] discussed automatic exploit genera-
tion for web applications. The previous work focused
on generating control ﬂow hijacking exploits. FLOW-
STITCH on the other hand generates data-oriented at-
tacks that do not violate the control ﬂow integrity. To
our knowledge, FLOWSTITCH is the ﬁrst tool to system-
atically generate data-oriented attacks.
Defenses against Data-Oriented Attacks.
Data-
oriented attacks can be prevented by enforcing data-ﬂow
integrity (DFI). Existing work enforces DFI through dy-
namic information tracking [23, 39, 40] or by legitimate
memory modiﬁcation instruction analysis [18,42]. How-
ever, DFI defenses are not yet practical, requiring large
overheads or manual declassiﬁcation. An ultimate de-
fense is to enforce the memory safety to prevent the at-
tacks in their ﬁrst steps. Cyclone [27] and CCured [31]
introduce a safe type system to the type-unsafe C lan-
guages. SoftBound [29] with CETS [30] uses bound
checking with fat-pointer to force a complete memory
safety. Cling [11] enforces temporal memory safety
through type-safe memory reuse. Data-oriented attack
prevention requires a complete memory safety.
8 Conclusion
In this paper, we present a new concept called data-
ﬂow stitching, and develop a novel solution to systemati-
cally construct data-oriented attacks. We discuss novel
stitching methods, including single-edge stitch, multi-
edge stitch, stitch with deterministic addresses and stitch
by address reuse. We build a prototype of data-ﬂow
stitching, called FLOWSTITCH. FLOWSTITCH gener-
ates 19 data-oriented attacks from eight vulnerable pro-
grams. Sixteen attacks are previously unknown attacks.
All attacks bypass DEP and the CFI checks, and 10 by-
pass ASLR. The result shows that automatic generation
of data-oriented exploits exhibiting signiﬁcant damage is
practical.
Acknowledgments. We thank R. Sekar, Shweta Shinde,
Yaoqi Jia, Xiaolei Li, Shruti Tople, Pratik Soni and
the anonymous reviewers for their insightful comments.
This research is supported in part by the National Re-
search Foundation, Prime Minister’s Ofﬁce, Singapore
under its National Cybersecurity R&D Program (Award
No. NRF2014NCR-NCR001-21) and administered by
the National Cybersecurity R&D Directorate, and in part
by a research grant from Symantec.
References
[1] Endspent(3C).
https://docs.oracle.com/cd/
E36784 01/html/E36874/endspent-3c.html.
[2] How Effective is ASLR on Linux Systems?
http:
//securityetalii.es/2013/02/03/how-
effective-is-aslr-on-linux-systems/.
[3] HTTPDX tolog() Function Format String Vulnerability.
http://cve.mitre.org/cgi-bin/cvename.cgi?
name=CVE-2009-4769.
[4] Nginx HTTP Server 1.3.9-1.4.0 Chunked Encoding Stack Buffer
Overﬂow. http://mailman.nginx.org/pipermail/
nginx-announce/2013/000112.html.
[5] OrzHTTPd.
orzhttpd/.
https://code.google.com/p/
[6] Subverting without EIP.
http://mallocat.com/
subverting-without-eip/.
[7] The Heartbleed Bug. http://heartbleed.com/.
[8] Visual Studio 2015 Preview: Work-in-Progress Security Fea-
ture. http://blogs.msdn.com/b/vcblog/archive/
2014/12/08/visual-studio-2015-preview-
work-in-progress-security-feature.aspx.
[9] Sudo Format String Vulnerability. http://www.sudo.ws/
sudo/alerts/sudo debug.html, 2012.
[10] ABADI, M., BUDIU, M., ERLINGSSON, U., AND LIGATTI, J.
Control-ﬂow Integrity. In Proceedings of the 12th ACM Confer-
ence on Computer and Communications Security (2005).
[11] AKRITIDIS, P. Cling: A Memory Allocator to Mitigate Dangling
Pointers. In Proceedings of the 19th USENIX Security Symposium
(2010).
[12] ANDERSEN, S., AND ABELLA, V. Changes to Functionality in
Microsoft Windows XP Service Pack 2, Part 3: Memory protec-
tion technologies, Data Execution Prevention. Microsoft TechNet
Library, September 2004.
USENIX Association  
24th USENIX Security Symposium  191
15
[13] AVGERINOS, T., CHA, S. K., HAO, B. L. T., AND BRUMLEY,
D. AEG: Automatic Exploit Generation. In Proceedings of the
18th Annual Network and Distributed System Security Sympo-
sium (2011).
[14] BACKES, M., HOLZ, T., KOLLENDA, B., KOPPE, P.,
N ¨URNBERGER, S., AND PEWNY, J. You Can Run but You Can’t
Read: Preventing Disclosure Exploits in Executable Code.
In
Proceedings of the 21st ACM Conference on Computer and Com-
munications Security (2014).
[15] BHATKAR, S., DUVARNEY, D. C., AND SEKAR, R. Address
Obfuscation: An Efﬁcient Approach to Combat a Broad Range
of Memory Error Exploits. In Proceedings of the 12th USENIX
Security Symposium (2003).
[16] BRUMLEY, D., JAGER, I., AVGERINOS, T., AND SCHWARTZ,
E. J. BAP: A Binary Analysis Platform. In Proceedings of the
23rd International Conference on Computer Aided Veriﬁcation
(2011).
[17] BRUMLEY, D., POOSANKAM, P., SONG, D., AND ZHENG, J.
Automatic Patch-Based Exploit Generation is Possible: Tech-
niques and Implications. In Proceedings of the 29th IEEE Sym-
posium on Security and Privacy (2008).
[18] CASTRO, M., COSTA, M., AND HARRIS, T. Securing Soft-
ware by Enforcing Data-Flow Integrity.
In Proceedings of the
7th Symposium on Operating Systems Design and Implementa-
tion (2006).
[19] CHEN, S., XU, J., SEZER, E. C., GAURIAR, P., AND IYER,
R. K. Non-Control-Data Attacks Are Realistic Threats. In Pro-
ceedings of the 14th USENIX Security Symposium (2005).
[20] CHOW, J., PFAFF, B., GARFINKEL, T., AND ROSENBLUM, M.
Shredding Your Garbage: Reducing Data Lifetime Through Se-
cure Deallocation. In Proceedings of the 14th USENIX Security
Symposium (2005).
[21] CRISWELL, J., DAUTENHAHN, N., AND ADVE, V. KCoFI:
Complete Control-Flow Integrity for Commodity Operating Sys-
tem Kernels.
In Proceedings of the 35th IEEE Symposium on
Security and Privacy (2014).
[22] DE MOURA, L., AND BJØRNER, N. Z3: An Efﬁcient SMT
Solver. In Proceedings of the Theory and Practice of Software,
14th International Conference on Tools and Algorithms for the
Construction and Analysis of Systems (2008).
[23] ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG,
J., MCDANIEL, P., AND SHETH, A. N.
TaintDroid: An
Information-ﬂow Tracking System for Realtime Privacy Monitor-
ing on Smartphones. In Proceedings of the 9th USENIX Confer-
ence on Operating Systems Design and Implementation (2010).
[24] FELMETSGER, V., CAVEDON, L., KRUEGEL, C., AND VIGNA,
G. Toward Automated Detection of Logic Vulnerabilities in Web
Applications. In Proceedings of the 19th USENIX Security Sym-
posium (2010).
[25] GODEFROID, P., LEVIN, M. Y., AND MOLNAR, D. A. Auto-
mated whitebox fuzz testing. In Proceedings of the 15th Annual
Network and Distributed System Security Symposium (2008), In-
ternet Society.
[26] GODEFROID, P., AND TALY, A. Automated Synthesis of Sym-
bolic Instruction Encodings from I/O Samples. In Proceedings of
the 33rd ACM SIGPLAN Conference on Programming Language
Design and Implementation (2012).
[27] JIM, T., MORRISETT, J. G., GROSSMAN, D., HICKS, M. W.,
CHENEY, J., AND WANG, Y. Cyclone: A Safe Dialect of
C. In Proceedings of the USENIX Annual Technical Conference
(2002).
[28] LUK, C.-K., COHN, R., MUTH, R., PATIL, H., KLAUSER, A.,
LOWNEY, G., WALLACE, S., REDDI, V. J., AND HAZELWOOD,
K. Pin: Building Customized Program Analysis Tools with Dy-
namic Instrumentation.
In Proceedings of the 2005 ACM SIG-
PLAN Conference on Programming Language Design and Im-
plementation (2005).
[29] NAGARAKATTE, S., ZHAO,
J., MARTIN, M. M., AND
ZDANCEWIC, S. SoftBound: Highly Compatible and Complete
Spatial Memory Safety for C. In Proceedings of the 30th ACM
SIG-PLAN Conference on Programming Language Design and
Implementation (2009).
[30] NAGARAKATTE, S., ZHAO,
J., MARTIN, M. M., AND
ZDANCEWIC, S. CETS: Compiler Enforced Temporal Safety for
C. In Proceedings of the 9th International Symposium on Mem-
ory Management (2010).
[31] NECULA, G. C., MCPEAK, S., AND WEIMER, W. CCured:
Type-safe Retroﬁtting of Legacy Code.
In Proceedings of the
29th ACM SIGPLAN-SIGACT Symposium on Principles of Pro-
gramming Languages (2002).
[32] NIU, B., AND TAN, G. Modular Control-ﬂow Integrity. In Pro-
ceedings of the 35th ACM SIGPLAN Conference on Program-
ming Language Design and Implementation (2014).
[33] PAX TEAM.
PaX Address Space Layout Randomization
(ASLR). http://pax.grsecurity.net/docs/aslr.
txt, 2003.
[34] PAYER, M., AND GROSS, T. R. String Oriented Programming:
When ASLR is Not Enough.
In Proceedings of the 2nd ACM
SIGPLAN Program Protection and Reverse Engineering Work-
shop (2013).
[35] SERNA, F. J. The Info Leak Era on Software Exploitation. Black
Hat USA (2012).
[36] TICE, C., ROEDER, T., COLLINGBOURNE, P., CHECKOWAY,
S., ERLINGSSON, U., LOZANO, L., AND PIKE, G. Enforcing
Forward-edge Control-ﬂow Integrity in GCC & LLVM. In Pro-
ceedings of the 23rd USENIX Security Symposium (2014).
[37] UBUNTU. List of Programs Built with PIE, May 2012. https:
//wiki.ubuntu.com/Security/Features#pie.
[38] WANG, Z., AND JIANG, X. HyperSafe: A Lightweight Ap-
proach to Provide Lifetime Hypervisor Control-Flow Integrity.
In Proceedings of the 31st IEEE Symposium on Security and Pri-
vacy (2010).
[39] XU, W., BHATKAR, S., AND SEKAR, R. Taint-Enhanced Policy
Enforcement: A Practical Approach to Defeat a Wide Range of
Attacks. In Proceedings of the 15th USENIX Security Symposium
(2006).
[40] YIP, A., WANG, X., ZELDOVICH, N., AND KAASHOEK, M. F.
Improving Application Security with Data Flow Assertions. In
Proceedings of the ACM SIGOPS 22nd Symposium on Operating
Systems Principles (2009).
[41] ZENG, B., TAN, G., AND ERLINGSSON, U. Strato: A Retar-
getable Framework for Low-level Inlined-reference Monitors. In
Proceedings of the 22nd USENIX Security Symposium (2013).
[42] ZENG, B., TAN, G., AND MORRISETT, G. Combining Control-
Flow Integrity and Static Analysis for Efﬁcient and Validated
Data Sandboxing. In Proceedings of the 18th ACM conference
on Computer and Communications Security (2011).
[43] ZHANG, C., WEI, T., CHEN, Z., DUAN, L., SZEKERES, L.,
MCCAMANT, S., SONG, D., AND ZOU, W. Practical Control
Flow Integrity and Randomization for Binary Executables.
In
Proceedings of the 34th IEEE Symposium on Security and Pri-
vacy (2013).
[44] ZHANG, M., AND SEKAR, R. Control Flow Integrity for COTS
Binaries. In Proceedings of the 22nd USENIX Security Sympo-
sium (2013).
192  24th USENIX Security Symposium 
USENIX Association
16