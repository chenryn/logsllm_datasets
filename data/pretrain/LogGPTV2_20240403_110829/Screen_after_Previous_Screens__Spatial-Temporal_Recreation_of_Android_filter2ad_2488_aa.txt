# Title: Spatial-Temporal Recreation of Android App Displays from Memory Images

## Authors:
- Brendan Saltaformaggio, Rohit Bhatia, Xiangyu Zhang, and Dongyan Xu (Purdue University)
- Golden G. Richard III (University of New Orleans)

## Abstract
Smartphones are increasingly involved in both cyber and real-world crime investigations. In this paper, we introduce RetroScope, a powerful smartphone memory forensics technique that recovers multiple previous screens of an Android app, in the order they were displayed, from a phone’s memory image. Unlike traditional memory forensics, RetroScope enables spatial-temporal forensics, revealing the progression of user interactions with the app, such as banking transactions, online chats, or document editing sessions. RetroScope achieves near-perfect accuracy in both screen recreation and temporal ordering. Additionally, it is app-agnostic, requiring no knowledge of an app's internal data definitions or rendering logic. RetroScope leverages two key observations: (1) app-internal data on previous screens persists longer in memory than the GUI data structures that package them, and (2) apps can perform context-free redrawing of their screens upon command from the Android framework. Based on these, RetroScope employs a novel interleaved re-execution engine to selectively reanimate an app’s screen redrawing functionality from within a memory image. Our evaluation shows that RetroScope can recover full temporally-ordered sets of screens (each with 3 to 11 screens) for a variety of popular apps on different Android devices.

## 1. Introduction
As smartphones become more pervasive, they are increasingly involved in cyber and real-world crimes. Among the many types of evidence held by a phone, an app’s prior screen displays may be the most intuitive and valuable, revealing the intent, targets, actions, and other contextual evidence of a crime.

In this paper, we demonstrate a powerful forensic capability for Android phones: recovering multiple previous screens displayed by each app from the phone’s memory image. This capability enables spatial-temporal forensics by revealing what the app displayed over a time interval, rather than at a single time instance. For example, investigators can recover multiple screens of a banking transaction, deleted messages from an online chat, and even a suspect’s actions before logging out of an app.

Our previous work, GUI-TAR [35], provides a related but less powerful capability: recovering the most recent GUI display of an Android app from a memory image, which we call Screen 0. Unfortunately, GUI-TAR cannot reconstruct the app’s previous screens, which we refer to as Screens -1, -2, -3, etc., reflecting their reverse temporal order. If a user has logged out of an app before the phone’s memory image is captured, GUI-TAR will only recover the "log out" screen, which is far less informative than the previous screens showing actual app activities and their progression.

To address this limitation, we present RetroScope, a novel spatial-temporal solution that reconstructs an Android app’s previous GUI screens (i.e., Screens 0, -1, -2, ..., -N, where N > 0). RetroScope is app-agnostic and does not require any app-specific knowledge (i.e., data structure definitions and rendering logic). More importantly, RetroScope achieves near-perfect accuracy in terms of reconstructed screen display and temporal order of the reconstructed screens. To achieve these properties, RetroScope overcomes significant challenges. As indicated in [35], GUI data structures for previous screens are almost completely overwritten as soon as a new screen is rendered. This is why GUI-TAR cannot reconstruct Screen -i (i > 0), as it cannot find GUI data structures belonging to the previous screens. In other words, GUI-TAR is capable of "spatial" but not "spatial-temporal" GUI reconstruction. This limitation motivated us to seek a fundamentally different approach for RetroScope.

During our research, we observed that although GUI data structures for app screens dissolve quickly, the actual app-internal data displayed on those screens (e.g., chat texts, account balances, photos) have a much longer lifespan. Section 2 presents our profiling results to demonstrate this observation. However, if we follow the traditional memory forensics methodology of searching for [16,25,26,41] and rendering [35–37] instances of those app data, our solution would require app-specific data structure definitions and rendering logic, breaking the highly desirable app-agnostic property.

We then turned our attention to the (app-agnostic) display mechanism supplied by the Android framework, which revealed the most critical (and interesting) idea behind RetroScope. A smartphone displays the screen of one app at a time; hence, the apps' screens are frequently switched in and out of the device’s display, following the user’s actions. Further, when the app is brought back to the foreground, its entire screen must be redrawn from scratch: first, by repackaging the app’s internal data to be displayed into GUI data structures, and then rendering the GUI data structures according to their layout on the screen. Now, recall that the "old" app-internal data (displayed on previous screens) are still in memory. Therefore, we propose redirecting Android’s "draw-from-scratch" mechanism to those old app data. Intuitively, this would cause the previous screens to be rebuilt and rendered. This turns out to be both feasible and highly effective, thus enabling the development of RetroScope.

Based on the observations above, RetroScope is designed to trigger the re-execution of an app’s screen-drawing code in-place within a memory image—a process we call selective reanimation. During selective reanimation, the app’s data and drawing code from the memory image are logically interleaved with a live symbiont app, using our interleaved re-execution engine and state interleaving finite automata (Section 3.2). This allows RetroScope (within a live Android environment) to issue standard GUI redrawing commands to the interleaved execution of the target app, until the app has redrawn all different (previous) screens that its internal data can support. In this way, RetroScope acts as a "puppeteer," steering the app’s code and data (the "puppet") to reproduce its previous screens.

We have performed extensive evaluation of RetroScope, using memory snapshots from 15 widely used Android apps on three commercially available phones. For each of these apps, RetroScope accurately recovered multiple (ranging from 3 to 11) previous screens. Our results show that RetroScope-recovered app screens provide clear spatial-temporal evidence of a phone’s activities with high accuracy (only missing 2 of 256 recoverable screens) and efficiency (10 minutes on average to recover all screens for an app). We have open-sourced RetroScope to encourage reproduction of our results and further research into this new memory forensics paradigm.

## 2. Problem and Opportunity
Unlike typical desktop applications, frequent user interactions with Android apps require their screen displays to be highly dynamic. For example, nearly all user interactions (e.g., clicking the “Compose Email” button on the Inbox screen) and asynchronous notifications (e.g., a pop-up for a newly received text message) lead to drawing an entirely new screen. Despite such frequent screen changes, an earlier study [35] shows that every newly rendered app screen destroys and overwrites the GUI data structures of the previous screen.

This observation, however, seems counterintuitive, as Android apps are able to very quickly render a screen that is similar or identical to a previous screen. For example, consider how seamlessly a messenger app returns to the “Recent Conversations” screen after sending a new message. Given that the previous screen’s data structures have been destroyed, the app must be able to recreate GUI data structures for the new screen. More importantly, we conjecture that the raw, app-internal data (e.g., chat texts, dates/times, and photos) displayed on previous screens must exist in memory long after their corresponding GUI data structures are lost.

To confirm our conjecture about the lifespans of (1) GUI data structures (short) and (2) app-internal data (long), we performed a profiling study on a variety of popular Android apps (those in Section 4). Via instrumentation, we tracked the allocation and destruction (i.e., overwriting) of the two types of data following multiple screen changes of each app. Figure 1 presents our findings for TextSecure (also known as Signal Messenger). It is evident that the creation of every new screen causes the destruction of the previous screen’s GUI data, whereas the app-internal data not only persists but accumulates with every new screen. We observed this trend across all evaluated apps.

Considering that a memory image reflects the memory’s content at one time instance, Figure 1 illustrates a limitation of existing memory forensics techniques (background on memory image acquisition can be found in Appendix A). Specifically, given the memory image taken after Screen 0 is rendered (as marked in Figure 1), our GUI-TAR technique [35] will only have access to the GUI data for Screen 0. Meanwhile, the app’s internal data are maintained by the app itself for as long as the app’s implementation allows (e.g., we never observed TextSecure deallocating its messages because they may be needed again). However, without app-specific data definitions or rendering logic, it is impossible for existing app-agnostic techniques [6,36,41] to meaningfully recover and redisplay the app’s internal data on Screens -1 to -5 in Figure 1.

It turns out that the Android framework instills the “short-lived GUI structures and long-lived app-internal data” properties in all Android apps. Specifically, Android apps must follow a “Model/View” design pattern, which intentionally separates the app’s logic into Model and View components. As shown in Figure 2, an app’s Model stores its internal runtime data, while its View is responsible for building and rendering the GUI screens that present the data. For example, the MessageItem, Conversation, and ContactList (Model) classes in Figure 2 store raw, app-internal data, which are then formatted into GUI data structures and drawn on the screen by the MessageListView class. This design allows the app’s View screens to respond quickly to highly dynamic user-phone interactions, while delegating slower operations (e.g., fetching data updates from a remote server) to background Model threads.

Further, the Android framework provides a Java class (aptly named View) which apps must extend to implement their own GUI screens. As illustrated by Figure 2’s MessageListView class, each of the app’s screens corresponds to an app-customized View object and possibly many sub-Views drawn within the top-level View. Most importantly, each View object defines a `draw` function. `draw` functions are prohibited from performing blocking operations and may be invoked by the Android framework whenever that specific screen needs to be redrawn. This makes any screen’s GUI data (e.g., formatted text, graphics buffers, and drawing operations which build the screen) easily disposable, because the Android framework can quickly recreate them by issuing a redraw command to an app at any time.

This design pattern provides an interesting opportunity for RetroScope, which will intercept and reuse the context of a live redraw command to support the reanimation of `draw` functions in a memory image.

## 3. Design of RetroScope
RetroScope’s operation is fully automated and requires only a memory image from the Android app being investigated (referred to as the target app) as input. From this memory image, RetroScope will recreate as many previous screens as the app’s internal data (in the memory image) can support. However, without app-specific data definitions, RetroScope is unable to locate or understand such internal data. But recall from Section 2 that the Android framework can cause the app to draw its screen by issuing a redraw command, without handling the app-internal data directly. This is possible because the app’s `draw` functions are invoked in a context-free manner: The Android framework only supplies a buffer (called a Canvas) to draw the screen into, and the `draw` function obtains the app’s internal data via previously stored, global, or static variables—similar to starting a car with a key (the redraw command) versus manually cranking the engine (app internals). Thus, RetroScope is able to leverage such commands, avoiding the low-level “dirty work” as in previous forensics/reverse engineering approaches [36, 37].

RetroScope mimics this process within the target app’s memory image by selectively reanimating the app’s screen drawing functions via an interleaved re-execution engine (IRE). RetroScope can then inject redraw commands to goad the target app into recreating its previous screens. An app’s `draw` functions are ideal for reanimation because they are (1) functionally closed, (2) defined by the Android framework (thus we know their interface definition), and (3) prevented from performing I/O or other blocking operations, which would otherwise require patching system dependencies. Finally, RetroScope saves the redrawn screens in the temporal order that they were previously displayed, unless the `draw` function crashes—indicating the app-internal data could not support that screen.

To support selective reanimation, RetroScope leverages the open-source Android emulator to start, control, and modify the execution of a symbiont app, a minimal implementation of an Android app which will serve as a “shell” for selective reanimation.

### 3.1 Selective Reanimation
Before selective reanimation can begin, RetroScope must first set up enough of the target app’s runtime environment for re-executing the app’s `draw` functions. Therefore, RetroScope first starts a new process in the Android emulator, which will later become the symbiont app and the IRE (Section 3.2). RetroScope then synthetically recreates a subset of the target app’s memory space from the subject memory image. Specifically, RetroScope loads the target app’s data segments (native and Java) and code segments (native C/C++ and Java code segments) back to their original addresses (Lines 1-4 of Algorithm 1)—this would allow pointers within those segments to remain valid in the symbiont app’s memory space. RetroScope then starts the symbiont app, which will initialize its native execution environment and Java runtime. Note that the IRE will not be activated until later when state interleaving (Section 3.2) is needed.

**Isolating Different Runtime States.** The majority of an Android app’s runtime state is maintained by its Java runtime environment. For RetroScope, it is not sufficient to simply reload the target app’s memory segments. Instead, the symbiont app’s Java runtime must also be made aware of the added (target app’s) runtime data prior to selective reanimation. Later, the IRE will need to dynamically switch between the target app’s runtime state and that of the symbiont app to present each piece of interleaved execution with the proper runtime environment.

RetroScope traverses a number of global Java runtime data structures from the subject memory image with information such as known/loaded Java classes, app-specific class definitions, and garbage collection trackers (Lines 5–9 of Algorithm 1). Such data are then copied and isolated into the symbiont app’s Java runtime by inserting them (via the built-in Android class-loading logic) into duplicates of the Java runtime structures in the symbiont app. Note that, at this point, the duplicate runtime data structures will not affect the execution of the symbiont app, but they must be set up during the symbiont app’s initialization so that any app-specific classes and object allocations from the memory image can be handled later by the IRE.

At this point, the symbiont app’s memory space contains (nearly) two full applications (shown in Figure 4). The symbiont app has been initialized naturally by the Android system with its own execution environment. In addition, RetroScope has reserved and loaded a subset of the target app’s memory segments (those required for selective reanimation) and isolated the necessary old (target app’s) Java runtime data into the new (symbiont app’s) Java runtime. The remainder of RetroScope’s operation is to (1) mark the target app’s View `draw` functions so that they can receive redraw commands and (2) reanimate those drawing functions inside the symbiont app via the IRE.

**Marking Top-Level Draw Functions.** RetroScope traverses the target app’s loaded classes to find top-level Views (Lines 10–17 in Algorithm 1). Top-level Views are identified as those which inherit from Android’s parent View class `ViewParent` and are not drawn inside any other Views. As described in Section 2, top-level Views are default Android classes which contain app-customized sub-Views. Further, we know that all Views must implement a `draw` function (which invokes the sub-Views’ `draw` functions). Thus, RetroScope marks each top-level `draw` function as a reanimation starting point.

```algorithm
Algorithm 1: RetroScope Selective Reanimation
Input: Target App Memory Image M
Output: GUI Screen Ordered Set S

1. Rebuild the Target App runtime environment.
2. Remap memory segments.
3. for Segment S ∈ M do
4.   if isNeededForReanimation(S) then
5.     Map(S.startAddress, S.length, S.content)
6. SymbiontApp.initialize()
7. JavaGlobalStructs G ← ∅  // Isolate the Target App runtime state.
8. for Segment S ∈ M do
9.   if containsJavaGlobals(S) then
10.    G ← getJavaGlobals(S)
11.    break
12. Mark top-level draw functions.
13. for Class C ∈ LoadedClasses do
14.   if C inherits from ViewParent and not drawn inside other Views then
15.     Mark C.draw as reanimation starting point.
```

This algorithm outlines the steps RetroScope takes to selectively reanimate the app’s screen drawing functions, ensuring that the app’s previous screens can be accurately and efficiently recovered.