Figure 2. An internal-state triggered backdoor example.
and force L() to directly return T RU E.
• G-triggered backdoor. Global states G, such as
system times and MAC addresses, can also be
used. For example, between 4:00am and 4:01am,
L() directly returns T RU E regardless of user’s
response.
• I-triggered backdoor. Internal states I can be a kind
of trigger. For example, L() can record the login
failure frequency and return T RU E if the failure
frequency falls into a speciﬁed range.
Note that all these three kinds of trigger conditions
and their combinations can be used to implement
backdoors. We can eliminate this type of backdoors
if we ensure that the response comparison cannot be
bypassed.
Type T2: Controlling computation of expected re-
sponse (Response(cid:2) = Response): In this category, the
response comparison is not bypassed, but the response-
computation component is affected by attackers. Recall
that the response-computation function f () generates a
response Response(cid:2), which is compared to Response
to decide whether the user (or attacker) can login.
However, as the developer who writes f (), the attacker
can plant backdoors to make the response generated by
f () predictable. Ideally, the expected response should
only depend on the challenge and the user’s password.
Based on how the backdoor in the response-computation
function affects the expected response, we further classi-
fy this type of RCA backdoors into two sub-categories.
• Type T2a: Response computation depends on
information other than challenge and password.
In this category, when given a speciﬁc pair of
password pw and challenge cha,
the response-
computation function can generates different
responses, depending on the value of (U, G, I).
The attacker can predicate the response if when a
special condition is planted in the login module.
For example, the attacker can plant a hard-coded
pair of username and password in f (). When the
hard-coded username is supplied in U, f () uses
6
the hard-coded password to compute a response,
which makes the response predictable by the
attacker.
a
generates
is the bit-wise inverse of
Figure 2 shows another example. The response
computing function f
response
the challenge
that
every ten login attempts (i.e.
internal states).
So the backdoor attacker can always send the
bit-wise inverse of the challenge to the server
and authenticate successfully with a probability of
1/10.
This type of backdoor can be eliminated if the
computation function f () is assured to depend only
on cha and pw, i.e., for a given pw and cha, f ()
always generates the same response. Therefore,
the response-computation function f () should only
perform pure computation, without side-effect
and dependencies to external or persistent internal
states. This requirement can be satisﬁed if we
ensure that the response-computation function is a
pure function, which is introduced in Section II-C.
• Type T2b: Response computation has collision-
based backdoors.
f ()
the
In this category, when given speciﬁc password
pw and challenge cha, the response-computation
function
response
generates
Response(cid:2). Response(cid:2)
is determined by the
password pw, which is set by the normal user and
is unknown to the attacker. Therefore, the attacker
cannot predicate the exact response generated by
f ().
same
Given a challenge, if the output of f () is different
for different passwords (i.e. f ()’s value space
is uniform distributed),
the attacker can only
login successfully with a probability equals to
that of guessing the right password. However, the
malicious developer can implement a function with
a high weak-collision probability. For example,
given a challenge cha0, f () may output res0
for half of possible passwords, which allows the
attacker to login successfully with a probability of
1/2 using the response res0.
This kind of backdoor, called collision-based back-
door, can hardly be detected by traditional program
analysis methods, but it can be eliminated if we
can measure the computation function’s collision
probability. Again, it requires that f () is assured
to depend only on cha and pw.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:49:58 UTC from IEEE Xplore.  Restrictions apply. 
A(User)
B(Server)
password 
database
idA
(login request)
idA
.
.
.
.
.
.
.pwA
.
.
.
.
.
Challenge
Generator
cha
(challenge)
cha
pwA
NaPu
f
=
no
res
yes
ACCEPT
res
(response)
memory
exception
REJECT
NaPu
Deterministic 
Memory 
Allocator
Memory 
Wiper
Input
Interface
NaCl 
Sandbox
Response 
Computing 
Function
Interface
Output
Pure Runtime 
Interfaces
Instruction 
Validator
Figure 4. NaPu architecture.
Figure 3. New RCA framework.
A. New RCA framework
From the above discussion, we can see that ensur-
ing the response-computation function to perform pure
computation is the basic to prevent Type T2 backdoors.
Next, we introduce the concept of pure function.
C. Pure function
A function is called pure, if the following two prop-
erties hold [14]:
i.e.,
• It has no side effects,
the evaluation does
not have any visible effects other than generating
the function results. Functions those modify argu-
ments, global states or hard disk ﬁle are not free
of side effects.
• Its execution is deterministic, i.e., given the same
set of function arguments, it always generates the
same result.
Pure functions introduce important features to simpli-
fy security analysis. For example, the password encrypt
function crypt() in POSIX should be a pure function.
Given a plain password and a salt, cyrpt() should return
a ﬁxed encrypted password. Moreover, cyrpt() should
be side-effect free, e.g., it should never modify any ﬁles
on the disk or modify other global variables in the caller
procedure’s address space.
There are many solutions to provide pure function
assurance. For example, Finifter et al. [14] presents a
technique to implement veriﬁable pure functions in Java.
III. SYSTEM DESIGN
In this section, we introduce our new RCA frame-
work, which uses a function-purifying sandbox to pre-
vent backdoors. We introduce the framework in general,
describe its key component — the NaPu sandbox, and
illustrate the steps to eliminate backdoor from RCA
login modules.
7
A backdoor takes effect when it affects the decision
of an authentication module. Strictly speaking, the au-
thentication decision of an RCA module should only
be based on a user’s credentials on the server and the
user’s response to challenges. Other requirements, such
as the valid time period to login, are not part of the core
authentication process. However, when a system treats
the authentication module as a blackbox, it is impossible
to know how the decision is made.
To address this problem, we design an approach that
partitions the RCA into components and ensures that
the computation in each component is not affected by
backdoors: Speciﬁcally, some components are trusted,
such as the interfaces provided by the operating system;
simple components can be veriﬁed by code analysis;
other components are put into a sandbox environment
to guarantee they are not affected by backdoors.
Figure 3 shows our new RCA framework. It ﬁrst
makes the response comparison explicit, so that it can be
veriﬁed as a simple component. It also identiﬁes other
simple components that can be veriﬁed, such as lookup
of password databases. Other components, including
the response-computation function f is puriﬁed by the
NaPu sandbox.
Based on this framework, we make formal analysis of
the upper bound of backdoor usability (Section IV-B)
and use a collision testing to estimate the maximum
probability of a backdoor. If the probability is low
enough, the backdoor cannot be practically used by
attackers; Otherwise, our approach detects the backdoor.
B. NaPu: A native sandbox for purifying functions
The key component of our approach is a function-
purifying sandbox called NaPu, a function-level sand-
box environment for native binaries. It consists of an
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:49:58 UTC from IEEE Xplore.  Restrictions apply. 
Backdoors
Backdoors
Backdoors
T1
T2a
T2b
Explicit response 
comparison
T2a
T2b
T2b
Function 
purification
Secure function
testing
Unsecure Login 
program
Transparency
Enhancing
Vulnerability 
Isolation
Internal State
Resetting
Global State
Isolation
Weak Function
Detection
Secure Login 
program
Decomposition
Sandboxing
Collision Testing
Figure 5. Countermeasures of defeating backdoors in RCA.
inner sandbox and four components: deterministic mem-
ory allocator, memory wiper, pure function interfaces
and instruction validator, shown in Figure 4. We use the
Native Client Sandbox [37] to provide a vulnerability
isolation environment. The instruction validator of NaPu
further makes sure that only deterministic instructions
are allowed. For example, CPUID and RDTSC are
prohibited. We use additional components to provide
two additional properties.
Global state isolation. The pure function interfaces
and instruction validator prevent the untrusted module
from getting the global states that can be used as a
trigger, such as the system time. If the function running
in NaPu calls the special APIs or instructions to get
global states, NaPu will throw an exception.
Internal state reset. The deterministic memory al-
locator and memory wiper will initialize the program
states before every invocation of the untrusted module,
to prevent backdoor from being triggered by persistent
internal states. For each login request, if the allocated
memory address is different, this address could be used
to break the pure function requirement. Therefore we
use the deterministic memory allocator to make sure
that, for each login request, NaPu will start a new
segment from a ﬁxed address, and for each function
executed in NaPu, its memory address is a ﬁxed value.
We also using the memory wiper to ensure all new al-
located memory buffers are ﬁlled with zero to eliminate
the uncertainty in memory allocation.
With these properties, the only two parameters that
the NaPu receives are challenge, cha, generated by
server and password, pw, from password database. Then
we can conﬁrm the response-computation function f is
a pure function, which means the internal behavior of
f is always the same no matter what input is. For the
same cha and pw pairs, the computed response must be
identical.
Such a sandbox can prevent a malicious developer
from triggering backdoors using controllable inputs. It
also makes sure the return value of f is only affected by
cha and pw, which are not controllable by the malicious
developer. So the backdoor tester and the malicious
developer are in the same position and we can use
collision testing to get the maximum probability of the
backdoor.
C. Steps to eliminate backdoors using our RCA frame-
work
Based on the framework and the NaPu sandbox,
Figure 5 shows the overall process of securing RCA
modules against backdoors, which consists of three
steps:
1) Explicit response comparison: Explicit response
comparison is used to make sure that the return value
of L() is derived from comparison of expected response
and the actual user response.
We divide the veriﬁcation process L() into two step-
s: response computation and response comparison —
to increase the execution transparency. Note that the
response-computation function f usually contains a lot
of cryptographic computations and is backdoor-prone.
We put it in NaPu to prevent control ﬂow hijacking
(e.g. through exploiting vulnerabilities in f). This step
can guarantee that the comparison statement cannot be
bypassed, and eliminates T1-type backdoors directly.
the
inputs (i.e.
2) Function
puriﬁcation: Once
response-
computation function f is put
in NaPu, and it can
only take the explicit
the challenge and
password) as its arguments. Furthermore, for each run
of the response calculating function f, this framework
resets the memory used by the function and allocates
memory in a ﬁxed manner. In this way, it prevents
backdoors from taking advantage of global or internal
states. As a result, the computation function is pure
and thus T2a-type backdoors are eliminated.
8
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:49:58 UTC from IEEE Xplore.  Restrictions apply. 
3) Backdoor usability testing: For T2b-type back-
doors, we use collision testing to verify whether the
response computing function f is consistent and has no
special characteristics such as high collision probability.
According to theorem and corollary in Section IV-B,
our testing method is straightforward. We compute the
upper bound of a backdoor usability. If the upper bound
is lower than a practical threshold, we assert that there
is no usable backdoor in the login module.
As long as the f can only receive challenge cha and
password pw, both of which are random to malicious
developers or testers, we randomly generate plenty of
cha, and for each cha, randomly generate plenty of
pw,
to check the weak collision probability of the
response computing function. For different cha or pw,
the response weak collision probability should be small
enough to prevent a malicious developer from authen-
ticating to the system. If the probability is abnormally
high, we detect the backdoor. For example, if the login
program has the backdoor shown in Figure 2, when
the challenge is ﬁxed, we will get 1/10 of the response
are the inversed challenge, although we feed different
passwords.
IV. SECURITY ANALYSIS