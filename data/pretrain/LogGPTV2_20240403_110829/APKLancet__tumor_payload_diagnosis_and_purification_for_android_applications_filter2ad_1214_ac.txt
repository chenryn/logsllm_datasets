DroidDream
DroidKungFu
DroidKungFu2
Geinimi Variant.A
Geinimi Variant.B
PJAPPS
Classes
resected
Items
resected in
manifest ﬁle
Resources
resected
Reference
patching
Entry
point
patching
25
17
69
20
10
13
13
105
85
22
5
0
10
3
3
3
3
4
3
3
0
1
3
4
5
5
5
0
0
0
No
Yes
Yes
Yes
No
Yes
Yes
Yes
No
No
No
Yes
Yes
No
Yes
No
No
Yes
Yes
No
Table 1: Characteristic of Diﬀerent Tumor Payload
3.5 Veriﬁcation
APKLancet introduces a veriﬁcation process to assure that
the puriﬁed app is able to work properly and the puriﬁca-
tion process does remove the unwanted behavior. It evalu-
ates the puriﬁcation from the aspects of both feasibility and
eﬀectiveness.
3.5.1 Feasibility
APKLancet adopts a very conservative strategy, which
does not allow new exception to crash the host app after the
puriﬁcation. The veriﬁcation work for puriﬁed app contains
two steps. First, the tested app is launched before puriﬁca-
tion and operated manually, and the Android’s logcat output
is collected. Second, after the puriﬁcation the tested app is
launched again with the same operation. APKLancet will
check the logcat output and compare it with the previous
record to determine whether the application is being exe-
cuted normally or throws any exception or crashes due to
the puriﬁcation.
APKLancet does not adopt random test methodology such
as testing using Android Monkey. Instead, to assure the pu-
riﬁed APK is still able to work properly, APKLancet needs
the involvement with manual test to deal with complex GUI
interactions such as password login.
3.5.2 Effectiveness
APKLancet evaluates the eﬀectiveness of the tumor code
excision both statically and dynamically. The static evalu-
ation approach adopted by APKLancet takes advantage of
online malicious code analysis engine. The puriﬁed APK,
if containing tumor code beforehand, is submitted to Virus-
Total[7] to check whether the malicious feature still exists.
This approach evaluates whether the puriﬁcation does iden-
tify the malicious feature. The puriﬁed app is also executed
on real device for APKLancet to collect logcat output and
verify whether the features such as advertising is resected.
4. EVALUATION
4.1 General Testing
We tested APKLancet with repackaged apps from online
sandbox system Sanddroid[6]. Table 1 shows the result that
how APKLancet splits the typical tumor payloads. The re-
sult shows that for each payload at least 10 classes are re-
sected during the puriﬁcation process. To be more clear, we
deﬁne diﬀerent puriﬁcation results of one malware family as
diﬀerent variants and label it in the form of Variant.A, etc.
From the results, we can see that nearly all the malwares
added or modiﬁed entry point of the original apps and it
is quite common for malwares to conduct simple modiﬁca-
tion to benign part of the original app or add extra resource
ﬁles such as native libraries or jar ﬁles to inject malicious
behaviors.
In order to further eﬀectively evaluate APKLancet, we
randomly choose 16 apps from each malware family in our
malware collection (we elaborately avoid those samples we
used to build feature databases though the malware family
they belong to should be included in our feature databases).
The characteristic of the chosen apps is that not only do
they contain either malicious code or third-party libraries
(some of them contain both), but all of these apps are also
able to execute well on latest version of the Android OS on
mainstream devices. We evaluate the sophisticated result
of malicious code puriﬁcation. First, all of the tested apps
worked properly and did not terminate by exception accord-
ing to our manual test and Android’s logcat output. Also,
as Table 2 shows (malware family information given by Aeg-
isLab Antivirus), all of the samples experience a dramatic
decrease in VirusTotal detection result after the puriﬁca-
tion, which means the tumor payload puriﬁcation is eﬀective
and malicious behaviors are resected from these malwares to
some extent. Although more than half of the samples are
not detected by any anti-virus engines in VirusTotal, we
also notice that a few anti-virus engines in VirusTotal still
regard the puriﬁed apps as malicious. After manually check-
ing those puriﬁed samples, we ﬁnd that the same anti-virus
engine classiﬁes the sample as a diﬀerent malware family in
most cases. The root cause for the alert information is that
some third-party libraries such as analytics plugins and ad
libraries are still remained in the app, but are not deﬁned
as tumor payload either by APKLancet or other majority of
Antivirus. Therefore, we treat this as false positive alert.
We also evaluate the eﬀectiveness of resecting typical ad
libraries. After puriﬁcation of the tested app with AdMob li-
brary, advertisement in app’s UI is gone.(See Fig 3). What’s
more, such outputs (i.e., URL of AdMob or Javascript code)
that indicate the existence of AdMob, are not found in logcat
output after puriﬁcation. At the meantime, other log infor-
mation created by benign code generally appears repeatedly
before and after the puriﬁcation. Another case is app with
Package Name
Malware Family Before Puriﬁcation After Puriﬁcation
com.appspot.swisscodemonkeys.steam
com.bytedroid.liveprints
com.caiping
com.computertimeco.minishot.android
com.game
com.hyxen.taximeter.app
com.power.SuperSolo
super.mobi.eraser
com.andtutu.stetris
com.eguan.update
com.bottleworks.dailymoney
com.allen.txthej
chaire1.mm
com.aac.cachemate
com.electricsheep.dj
cn.jingling.motu.photowonder
ADRD
ADRD
BaseBridge
BaseBridge
BaseBridge
BaseBridge
DroidDream
DroidDream
DroidKungFu
DroidKungFu
DroidKungFu2
DroidKungFu2
Geinimi
Geinimi
Geinimi
PJAPPS
26/47
35/47
30/45
32/48
34/48
34/48
38/47
37/47
33/47
34/47
35/47
36/47
33/47
33/47
33/48
32/47
Table 2: VirusTotal Detection Result
3/47
0/44
1/48
0/47
0/47
0/45
0/46
3/47
0/46
0/47
3/46
4/46
0/48
1/47
1/47
0/46
class, the BaseAActivity class, which is not declared in the
manifest ﬁle, is suspicious and connected to the feature of
BaseBridge malware family.
.class public Lcom/caiping/caiping;
.super Lcom/android/view/custom/BaseAActivity;
.source "caiping.java"
That means the malicious code modiﬁes the class inher-
itance to make the BaseAActivity class execute before the
original entry point class. If APKLancet simply resects the
BaseAActivity class, the inheritance of caiping class is bro-
ken. APKLancet thus redirects the base class of caiping
class to the base class of BaseAActivity, android.app.Activity.
After ﬁxing the original inheritance of the main entry
point class, APKLancet checks references in benign code
and ﬁnds 4 method-invoking references (onCreate, ,
onCreateOptionsMenu and onOptionsItemSelected ) of the
BaseAActivity class in benign code. All of these references
locate in the main entry points class com.caiping.caiping.
As we mentioned above, class caiping is a derived class of
the malicious class BaseAActivity, and the base class of
BaseAActivity is android.app.Activity. These 4 method-
invoking references should point to the methods in class
android.app.Activity, APKLancet hence patches the invok-
ing instruction through replacing the invoked method’s class
from BaseAActivity to android.app.Activity. For the tumor
object reference in this app, no data-dependent relationship
is found and APKLancet just resects any direct reference
of Lcom/android/view/custom/BaseAActivity in the benign
code. APKLancet also cleans the declaration of the tumor
code class in manifest ﬁle.
Finally, according to the string searched in smali code,
const-string v0, "androidterm"
invoke-static {v0},
Ljava/lang/System;->
loadLibrary(Ljava/lang/String;)V
The related androidterm library (libandroidterm.so) should
be resected.
After the puriﬁcation and repackaging, the new app is
able to work. However, the test result of VirusTotal demon-
strates that 15 out of 47 antivirus engines still report the app
Figure 3: Advertisement Resection
Flurry library. If the Flurry library is loaded, logcat outputs
the following information:
D/FlurryAgent: Starting new session
D/FlurryAgent: Sending report to: http://data.flurry.com/aar.do
D/FlurryAgent: Report successful
Such information would not be found in the puriﬁed app
even for the same user operation is performed.
4.2 Case Study I: BaseBridge and Wooboo
The ﬁrst case we studied is a repackaged app com.caiping.
APKLancet extracts the fuzzy hashing feature of every entry
point class of the apps. Compared with the feature database
built before, in this app 10 classes (com.android.view.custo-
m.* ) are detected to be tumor code index classes. Then
APKLancet identiﬁes the payload using Algorithm 1 taking
these index classes as input, and ﬁnds out class jackpal.and-
roidterm.Exec and all classes of com.sec.android.providers.d-
rm.* are also tumor code.
After locating tumor code payload, APKLancet discov-
ers that the direct base class of main entry point caiping
as malware and most of them classiﬁed it as Wooboo mal-
ware. We manually check the app and ﬁnd that it contains
an unauthorized advertising library Wooboo. So we add the
Wooboo library’s feature into APKLancet’s database and re-
execute the puriﬁcation process. Relying on the knowledge
of Wooboo directly, we regard the WoobooAdView as its in-
dex class and label the whole package where the index class
locates as the payload. This time APKLancet partitions all
classes of com.wooboo.adlib android.* as tumor payload.
In benign code APKLancet ﬁnd four references of the
tumor payload. All these references directly refer to the
class com.wooboo.adlib android.WoobooAdView, hence AP-
KLancet recursively resects dependent instructions and def-
initions. After the puriﬁcation, the puriﬁed app still works
properly under manual testing. And all 47 engines of Virus-
Total report no threat for this puriﬁed app.
4.3 Case Study II: Geinimi
The second case is an app com.electricsheep.dj contain-
ing malicious code of Geinimi malware family. According
to APKLancet’s feature database, the following classes are
identiﬁed as the index classes,
com.geinimi.AdServiceReceiver;
com.geinimi.AdService;
com.geinimi.custom.Ad1020_102001;
Then, using the index classes as input, APKLancet exe-
cutes Algorithm 1 and partitions classes com.geinimi.* as
the tumor code payload. After the partitioning of tumor
code payload, APKLancet checks references in benign code
and ﬁnds no reference to the tumor code payload. However,
APKLancet ﬁnds that in manifest ﬁle the main entry point
will be missing if the tumor code is resected. According
to the ﬁxing policy of APKLancet, the replaced main entry
point should be ﬁrst found in all launcher classes declared in
its manifest ﬁle(See Fig 4). In this case, APKLancet ﬁnds
DroidJumpActivity is the proper candidate and deﬁnes it as
the new main entry point class. Further analysis shows that
the inserted malicious entry point class will ﬁrst perform its
own function, and then starts the DroidJumpActivity class.
The code fragments selected from several smali ﬁles to illus-
trate the behavior of launching the original entry point is
showed as followed(code fragment of exception handler part
is omitted):
AdService.smali:
...
const-string v0,
"com.electricsheep.dj.DroidJumpActivity"
sput-object v0,
Lcom/geinimi/AdService;->a:Ljava/lang/String;
...
AdActivity.smali: