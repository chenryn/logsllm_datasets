author of the code to later log into the system on which
picturepages was run.) Using our GUI, it was easy to
spot the change to this ﬁle. The run was aborted, leaving
the ﬁle system in its original state.
Malicious code. Email attachments and WWW links are
a common source of viruses and other malware. We used an
SEE to protect systems from such malware. Speciﬁcally, we
modiﬁed the MIME type handler conﬁguration ﬁle used by
Mozilla so that executables, as well as viewers launched to
process documents (e.g., ghostscript and xpdf) fetched
over the Internet, were run within SEE. We fetched sample
malicious PostScript and Perl code over the network using
this approach. This code was executed inside the SEE. Us-
ing our GUI, we were able to see that these programs were
performing unexpected actions, e.g., creating a huge ﬁle
in the user’s home directory. These actions were aborted.
Also, at the time of writing this paper, there are several im-
age ﬂaw exploits (JPEG virus) that have captured the at-
tention of many researchers. Running such image viewers
inside an SEE will help eliminate this potential danger, be-
cause any malicious activity from the exploits will be iso-
lated from affecting the main system.
Some kinds of malicious code are written to recognize
typical sandbox environments, and if so, not display their
malicious behavior. This can cause a user to develop trust
in the code and then execute it outside of sandbox, when
the malcode will deliver its payload. With our approach,
we point out that running the code inside SEE does not in-
cur signiﬁcant inconvenience for the user, thereby making
it easy for the user to always use it. In this case, the code
will always display benign behavior.
Software installation. Another experiment performed a
trial installation of mozilla browser. During the installa-
tion, an incorrect directory name /usr/bin was chosen as
the location for installation, instead of the default directory
/usr/local/mozilla. Under normal circumstances, this
causes Mozilla to copy a number of ﬁles into /usr/bin,
thereby “polluting” the directory. After running the pro-
gram in an SEE, the user interface indicated that a large
number of ﬁles (some are non-executables) were added to
/usr/bin, which was not desirable. Aborting this installa-
tion, we ran the installation program a second time, this time
with /usr/local/mozilla as the location for installa-
tion. At the end of installation, we restarted the browser, and
visited several sites to make sure that the program worked
as expected. (For this experiment, the system call restric-
tion layer was modiﬁed to allow all WWW accesses.) Fi-
nally, we committed the installation, and from that point on,
we were able to use the new installation of the browser suc-
cessfully, outside of SEE.
Upgrading and testing a server. Speciﬁcally, we wanted
to upgrade our web server so that it can support SSL. We
started a command shell under SEE, and used it to up-
grade the apache software installation. We then ran the
new server. To enable it to run, we used static redirection
for network operations, so that a bind operation to port 80
was redirected to port 3080. We then ran a browser that
accessed this server by connecting to this port. We veri-
ﬁed that the new server worked correctly. Meanwhile, the
original server was still accessible to every one. Thus, SEE
allowed the software upgrade to be tested easily and conve-
niently, without having to shutdown the original server.
After verifying the operation of the new server, we at-
tempted to commit the results. Unfortunately, this produced
conﬂicts on some ﬁles such as the access and error log ﬁles
used by the server. We chose to ignore updates to such out-
put ﬁles that were made within the SEE, and commit only
the rest of the ﬁles, which could be done successfully.
6.2. Performance Evaluation
All performance results reported in this paper were ob-
tained from a laptop running Red Hat Linux 7.3 with a
1.0GHz AMD Athlon4 processor, 512MB memory and a
20GB, 4200rpm IDE hard disk. The primary metric was
elapsed time.
 20
)
%
Overhead for applications running in SEE
Isolation
Commit
(
d
a
e
h
r
e
v
O
f
o
 15
 10
e
g
a
t
n
e
c
r
e
P
 5
 0
ghostview
tar
postmark Am−utils
(a) Utility applications
)
%
(
n
o
i
t
a
d
a
r
g
e
D
f
o
e
g
a
t
n
e
c
r
e
P
 5
 4
 3
 2
 1
 0
Degradation for httpd server running in SEE
Connection Rate
Average Response Time
2−clients
16−clients
30−clients
(b) Apache httpd server
Figure 2. Performance Results for Program Execution in SEE
For performance evaluation, we considered the following
Log-based Commit
classes of examples:
(cid:15) Utility programs.
In this category, we studied
ghostview and tar utilities. Speciﬁcally, we per-
formed ghostview on a 31M ﬁle, with no ﬁle modi-
ﬁcation operations; and tar to generate a tarball from
a 26M directory, and the only modiﬁcation operations
involved was the creation of this archive. From Fig-
ure 2, we can see a 3-12% overhead incurred for such
applications during isolation phase, and a negligible
commit time overhead.
(cid:15) Servers. We measured the performance overhead on
the Apache web server using WebStone [35], a stan-
dard web server benchmark. We used version 2.5 of
this benchmark, and ran it on a separate computer that
is connected to the server through a 100Mbps network.
We ran the benchmark with two, sixteen and thirty
clients. In the experiments, the clients were simulated
to access the web server concurrently. They randomly
fetch html ﬁles whose size is from 500 bytes to 5M.
The benchmark was run for a duration of 30 minutes,
and the results were averaged across ten such runs. The
results are shown in Figure 2.
(cid:15) File system benchmarks. We used Postmark [9] and
Am-Utils [18] benchmarks to get the benchmark data
for IFS. Postmark is a ﬁle system benchmark to mea-
sure the performance for ﬁle system used by Internet
applications, such as email.
In this experiment, we
conﬁgured Postmark to create 500 ﬁles in a ﬁle pool,
with ﬁle sizes ranging from 500 bytes to 500KB. A to-
tal of 2000 ﬁle system operations were performed. In
total, 1515 ﬁles were created, 1010 ﬁles read, 990 ﬁle
written, and 1515 ﬁles deleted. The tests were repeated
ten times. The results are as depicted in ﬁgure 2. Over-
all, a 18% performance degradation is observed, and
commit overhead is near zero. Am-Utils is a CPU-
intensive benchmark result by building the Am-Utils
ghostview
tar
postmark
Am-utils
Time
0.03
0.14
225
16.9
Speedup
State-based Commit
Time
0.03
0.03
0.07
0.35
3214.3
48.3
1
4.7
Figure 3. Comparison for Log-based Commit
and State-based Commit. All numbers are in
seconds.
package, which contains 7.6M lines of C code and
scripts. The building process creates 152 ﬁles and 19
directories, as well as 6 rename and 8 setattr opera-
tions. We ran this experiment in both original ﬁle sys-
tem and IFS. The results, shown in Figure 2, indicate
a low isolation overhead of under 2% and a negligible
commit overhead.
In addition, we also collected results in Figure 3 to show
the efﬁciency of our state-based commit approach. An im-
plementation that used log based committing was compared
with our state based committing implementation, and the
performance of both of the approaches were compared for
applications such as tar, postmark and Am-utils. The
results project the advantage of using a state based commit
approach, particularly illustrating the advantage of having
accumulative effects for ﬁle objects. For instance, the large
number of temporary ﬁles created then deleted in Am-utils
compilation and all the ﬁles created then deleted in Post-
mark execution, are not considered in the committing stage
as candidates, while log-based commit still needs to per-
form the whole set of operations (e.g. write) to all these
ﬁles, so there is a signiﬁcant difference between the two ap-
proaches in terms of commit time.
7. Related Work
Sandboxing. Sandboxing based approaches [7, 6, 1, 21,
27, 22] involve observing a program’s behavior and block-
ing actions that may compromise the system’s security.
Janus [7] incorporates a proc ﬁle system based system call
interposition technique for the Solaris operating system. A
more recent version has been implemented on Linux, and
uses a kernel module for interposition. Chakravyuha [6]
uses a kernel interception mechanism. MAPbox [1] is a
sandboxing mechanism where the goal is to make the sand-
box more conﬁgurable and usable by providing a template
for sandbox policies based on a classiﬁcation of application
behaviors.
[21] creates the policy sandbox for programs
(such as web browser) by ﬁrst tracking the ﬁle requests
made by the programs. This approach, however, requires
a training phase, in which users need to run the programs
using “normal” inputs, so that the policy sandbox can cap-
ture a complete set of ﬁles accessed by the programs. But
in the case of untrusted code, the choice of such inputs may
not be clear. Safe Virtual Execution (SVE) [27] uses Soft-
ware Dynamic Translation, a technique for modifying bi-
naries as they execute, is used to implement sandboxing.
Systrace [22] is a sandboxing system that notiﬁes the user
about all system calls that an application tries to execute and
then uses the response from the user to generate a policy for
the application.
The main drawback of sandboxing based approaches is
the difﬁculty of policy selection, i.e, determining what ac-
tions are permissible for a given piece of software. Note that
malicious behavior may not only involve accessing unau-
thorized resources, but also accessing authorized resources
in unauthorized ways. For instance, a program that creates
a compressed version of a ﬁle may instead create a ﬁle that
contains no useful data, which is equivalent to deleting the
original ﬁle. It is unlikely that a practical system can be de-
veloped that can allow users to conveniently state policies
that allow write access to the ﬁle while ensuring that the ﬁle
is replaced with its compressed version. In contrast, an SEE
permits manual inspection, aided by helper applications, to
be used to determine if a program behaved as expected. This
approach is much more ﬂexible. Indeed, it is hard to imag-
ine that tasks such as verifying whether a software package
has been installed properly can even be formally speciﬁed
using any sandbox-type policy.
[28, 38] extend sandboxing by allowing operations to be
disallowed silently, i.e., by returning a success code to the
program. The goal of the approaches is deception, i.e.,
making a malicious program believe that it is succeeding
in its actions so as to observe its behavior. In our termi-
nology, these approaches use restriction rather than redirec-
tion. As we observed earlier, use of restriction is likely to
break many benign applications, as well as alert malicious
applications very quickly to the effect that their actions are
not succeeding. For instance, if a write operation is silently
suppressed, the application can easily detect this by reading
back the contents.
Isolation approaches. Two-way isolation between a host
and guest operating system forms the basis of security in
virtual machine based approaches for realizing SEEs. The
“playground” approaches developed for Java programs in
[15, 4] also belong to this general category — untrusted pro-
grams are run on a physically isolated system, while their
display is redirected to the user’s desktop. Note that the
ﬁle system on the user’s computer cannot directly be ac-
cessed on the playground system, which means that there is
two way isolation being employed in this case. Covirt [3]
proposes that most of applications be run inside virtual ma-
chine instead of host machines. Denali [36] is another vir-
tual machine based approach that runs untrusted distributed