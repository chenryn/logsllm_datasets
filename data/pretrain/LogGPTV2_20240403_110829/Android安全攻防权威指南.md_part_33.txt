套接字域
状态文件
PF_UNIX
/proc/set/unix
PF_INET (SOCK_STR&AM)
/proc/net/tcp
/proc/set/udp
PF_NETLINK
/proc/net/netlink
第一个也是最常使用的套接字域是PP_UNIX域，许多服务通过这个域的套接字暴露IPC功
能，而暴露的在文件系统中的端点可以使用传统的用户、用户组和权限机制进行安全加固。因为
条目存在于文件系统中，所以在使用5.5.1节中讨论的方法时，就可以发现这种类型的套接字。
除了传统的PF_UNIX域套接字以外，Android实现了一种特殊的套接字，称为“抽象命名空
间套接字”（AbstractNamespaceSocket）。几个核心系统服务使用这一域的套接字来暴露IPC功
能。这些套接字与PF_UNIX套接字是类似的，但并不会在文件系统上包含一个条目，面是仅仅
通过一个字符串来进行标识，标识字符串通常采用@socketName的形式。例如，/system/bin/
debuggerd程序创建一个名为Gandroid：Gebuggerd的抽象套接字。这种套接字在创建
PF_UNIX套接字时，通过指定NUL字节作为第一个字符来创建，随后的字符指明了套接字的名
称。因为这种套接字并不包含文件系统条目，因此无法使用传统PF_UNIX套接字的那种方法对
---
## Page 147
5.5本地攻击面
其进行安全加固。这一事实让抽象套接字端点成为值得进一步探索的有趣目标。
任何希望与互联网上主机通信的应用都需要使用PP_INET套接字。在少数情况下，服务与
应用使用PP_INET套接字来进行IPC通信。前面已经介绍过，这一套接字域又包括使用TCP协
议和UDP协议的通信。要想创建这种套接字，进程必须能够访问inet的AndroidID（AID），
这是由于我们已经在第2章中讨论的AndroidParanoidNetworking特性。这些类型的套接字在被
IPC通信使用，或者用于实现暴露在网络上的服务时，都是值得特别关注的。
Android中的最后一种通用套接字是PF_NETLINK套接字。这种套接字经常用于内核空间和
用户空间之间的通信。用户空间进程，如/system/bin/vold，会监听从内核发来的一些消息，
然后进行处理。在第3章中讨论过，GingerBreak漏洞利用代码依赖于vold服务在处理恶意构造
的NETLINK消息时的安全漏润。与PF_NETLINK套接字相关的攻击面是非常值得关注的，因为
它们同时存在于内核空间和特权用户空间进程中。
·找到套接字背后的代码
在一个典型的Linux系统中，你可以使用lsof命令或者带有-p选项的netstat命令来将
进程映射到套接字上。遗憾的是，这种方法在Android设备上并不是立即可行的。只有在一个root
过的设备上安装一个恰当构建的BusyBox二进制程序后，才能达成这一任务：
uni×2
DGRAM
5361 184/mpdecision
/dev/socket/pb
使用前面这条指令，你可以发现/dev/socket/pb被进程号为184的mpdecision进程所使用。
如果没有恰当构建的BusyBox，你可以通过简单的三步来完成这一任务。首先，你需要使用
proc文件系统目录中的特定条目，来找出拥有这一套接字的进程：
rootenako:/data/1ocal/tmp  . /buaybox head -1 /proc/net/unix
rootemako:/data/1ocal/tmpgrep/dev/socket/pb/proe/net/unix
Num
RefCount Protocol FlagsType St Inode Path
00000000: 00000002 00000000 00000000 0002 01 5361 /dev/socket/pb
在这个例子中，你可以查看特殊的/proc/net/unix文件中的/dev/socketpb条目，路径前面的那
个数字是文件系统条目的inode编号。使用这个inode编号，你可以看到哪个进程拥有这个套接
字的打开的文件描述符。
rootemako:/data/1ocal/tmp = . /busybox 1s -1 /proc/[091*/fd/* |grep 5361
[-.-]
1rwx-*
1rootroot
64 Jan2 22:03 /proe/184/fd/7 ->
socket: [5361]
有时这一命令会显示，不止一个进程在使用这个套接字。但是幸运的是，在这些情况下，通
常都能很明显地看出哪个进程是使用套接字的服务。在知道进程ID后，再找关于这个进程的更
多信息就简单了。
rootemako:/data/local/tmp  ps 184
US&R
ffffffff b6ea0908 S /system/bin/mpdecision
WCHANPC
NAE
root
1841
7208492
---
## Page 148
132第5章理解Android的攻击面
无论使用BusyBox方法还是上述的三步法，你现在都知道从哪里开始查看代码了。
套接字代表着一个重要的本地攻击面，因为它能和特权进程进行通信。实现了不同类型套接
字的内核空间代码可能会导致权限提升。用户空间中暴露出套接字端点的服务和应用也可能导致
特权提升。这些攻击面代表着查找安全漏洞值得关注的位置。通过定位到代码，你可以更近距离
地查看这些攻击面，并开始对更深攻击面的探索旅程。
3.Binder
Binder驱动及依赖于它的软件代表着Android特有的一个攻击面。之前已经在第2章中提到
并在第4章中进一步介绍，Binder驱动是Intent的基础，面Intent是用来在应用层Android组件
之间进行通信的。Binder驱动本身在内核空间中实现，并通过/dev/binder字符设备暴露出一个攻
击面。然后Dalvik应用通过基于之上的几层抽象进行相互通信。尽管从原生应用发送Intent不被
支持，但可以直接在Binder基础上实现一个原生代码服务。因为Binder可以被以多种方式使用，
研究更加深人的攻击面可能会找到最终导致权限提升的安全漏润。
4.共享内存
尽管Android设备并不使用传统的POSIX共享内存，但是它们包含了儿种共享内存机制。与
Android中的许多功能类似，是否支持某种特定的机制取决于具体的设备。第2章介绍过，Android
实现了一种名为“匿名共享内存”（简称ashmem）的定制共享内存机制。可以通过查看/proc文
件系统中的打开文件描述符，来找出哪些进程正在使用ashmem机制进行通信。
\|/P3/[6-01 /soad/ pt- st xoq/snq/.du/te3ot/eep/:oyeugoox
grep /dev/ashmem I ./busybox awk -P/*(print $3) * I./busybox sort -u
176
31897
31915
96S
686
9S8
除了ashmem机制，其他一些共享内存机制，如谷歌的pmem、英伟达的NvMap和ION，只
在特定的一组Android设备中存在。无论使用了哪一机制，用于IPC的共享内存都代表着一个潜
在的攻击面。
5.基带接口
Android智能手机中包含第二个操作系统，也就是基带。在某些设备中，基带运行在一个完
全独立的物理CPU上。在其他设备中，它则运行在一个专属CPU核心的隔离环境中。无论是哪
种情况，Android操作系统必须能与基带进行通信，来拨出和接听电话，发送和接收文本消息、
移动数据以及其他通过移动网络进行的通信。其中暴露出的端点依设备而不同，被认为是基带本
身的攻击面。对这些端点进行访问通常需要提升后的权限，比如radio用户或用户组的权限。通
过查看rild进程，可以确定基带暴露出哪些攻击面。对于Android手机通信栈，也就是对基带
访问的抽象，我们将在第11章中详细讨论。
---
## Page 149
5.6物理攻击面
133
6.攻击硬件支持的服务
大多数的Android设备还有大量的外设，包括GPS接收器、环境光传感器和陀螺仪等。Android
框架层中暴露了一些高层API，让Android应用访问由这些外设提供的信息。这些API也代表着
值得关注的攻击面，因为传递给它们的数据会被一些特权服务甚至外设自身进行处理。面任何给
定外设的体系结构则取决于不同的设备。由于在AP1与外设驱动之间也拥有多个层次，因此暴露
出的API攻击面也是说明更深人攻击面是如何隐藏于浅层攻击面之下的好案例。对这组攻击面更
彻底的审查已经超出了本书的范围。
5.6物理攻击面
需要物理接触设备的攻击被认为是依赖于物理攻击面，物理攻击面与先前提到的物理相邻并
不相同，物理相邻只需要在目标特定范围之内，而不需要实际接触到目标。使用物理攻击面攻击
移动设备看起来并不够酷炫，而且比其他攻击更容易。事实上，大部分人认为物理攻击是不可能
进行防御的。相应地，你可能会将这类攻击归为严重性较低的一类攻击。然面这些攻击会导致非
常严重的影响，特别是当它们可以在非常短的时间内执行，或者不会让目标用户发觉时。
在过去几年里，研究人员发现了一些利用物理攻击面的真实攻击方法。最早针对iOS设备的
几次越狱都需要对设备有USB连接。另外，取证分析人员严重依赖物理攻击面来恢复数据，或
者暗中获取手机的访问。2013年年初，研究人员发布了一个报告，详细说明了他们如何发现一
些公共手机充电站对指定设备发起攻击以安装恶意软件。恶意软件安装后，它会在感染的移动设
备连接宿主计算机时尝试攻击计算机。这样的攻击案例还有很多，事实上物理攻击要比你原本以
为的要多得多，也严重得多。
为了对物理攻击面进一步分类，我们考虑如下几个标准。首先，我们确定拆解目标设备是否
可以接受。拆解设备有损坏的风险，因面是不可取的。虽然如此，这种攻击从本质上说是非常强
大的，不应该排除在外。接下来，我们来分析不需要拆解设备的可能攻击面。这种攻击向量包括
任意的外设访问，比如USB端口和可扩展的存储媒介（通常是microSD卡）插槽。本节剩余部
分会讨论这些攻击向量以及它们之下的攻击面。
5.6.1拆解设备
对目标设备进行拆解，就能够对目标设备中的硬件发起攻击。许多设备制造商认为计算机硬
件和电子工程的神秘感足以充分保护设备。因为拆解一个Android设备来探测所暴露的攻击面，
需要小众的技能和专业的硬件，所以厂商通常不会充分地保护硬件。因此，研究拆开设备后暴露
的物理攻击面将非常有利。打开一个硬件设备通常会发现：
口暴露的串口，允许接收调试消息，或者在某些情况下，提供设备的shell访问；
口暴露的JTAG调试端口，允许对设备的固件进行调试、重刷或访问。
极少数情况下，攻击者无法找到这些通用接口，但是其他攻击仍然是可能的。一个非常实用
和真实的攻击是物理性地移除闪存或核心CPU（通常包含着内部闪存）。一且被移除，攻击者可
---
## Page 150
134第5章理解Android的攻击面
以轻易地从设备中读取引导装载程序、启动配置和完整的闪存文件系统。攻击者完全占有设备后，
可以实施许多攻击，这些只是其中的一部分。
你很幸运，本书不会像其他很多书籍一样，只是泛泛地提及这些攻击，面是在第13章中详
细演示说明这些技术。但本章不会深人介绍这些物理攻击。
5.6.2USB
USB是Android设备与其他设备进行交互的标准化有线接口。尽管iPhone有它专属的苹果连
接线，大部分Android设备使用标准化的microUSB端口，作为基础的有线接口，USB暴露了几
种不同类型的功能，这些功能与Android设备的多功能性是直接相关的。
USB接口的功能取决于设备处于什么模式，或者在设备配置中启用了哪些选项。通常支持的
模式有ADB、fastboot、下载模式、大容量存储、媒体设备和网络共享等。并非所有的设备都支
持所有模式，有些设备默认启用了其中一些模式，如大容量存储或媒体传输协议（MTP）模式。
其他USB模式，如fastboot和下载模式，取决于在启动时按住的特定组合键。此外，一些设备还
有一个菜单，让你在连接USB设备时选择进入哪种模式。图5-7显示了一部HTCOneV手机上
USB连接类型的菜单项。
Changeonlyecik drhe
图5-7HTC One V手机的 USB模式菜单
暴露的USB攻击面取决于设备处在哪种模式或启用了哪些特性。对于所有模式，引导装载
程序或Linux内核中的驱动都支持USB硬件。在这些设备驱动上层，有一些额外的软件处理使
用各类功能的特定网络协议进行的通信。在Android4.0之前，许多设备默认启用大容量存储模
式，面一些设备需要在屏幕上单击一个按钮才能启用。Android4.x及之后版本完全移除了对大容
量存储模式的支持。在此之前，宿主计算机在访间SD卡时，需要先从设备卸载/sdcard分区，操
作起来非常烦琐。于是，后续设备默认使用了MTP模式。
---
## Page 151
5.6物理攻击面
135
1.枚举USB攻击面
在文献中，USB设备经常被称为一种功能，也就是说，USB设备是向系统提供一些附加功
能的。实际上，一个USB设备就可以拥有许多不同的功能。每个USB设备有一种或多种配置，
面每种配置又有至少一个接口。一个接口中包含一组端点，这些端点说明了与特定功能进行通信
的方式。数据只能单向流出或流向端点，因此如果某个设备功能需要进行双向通信，那么它必须
定义两个端点。
使用像1susb这样的工具和 libusb库，我们可以在USB所连接的主机上进一步枚举USB所
暴露的攻击面。1susb工具可以显示出一个设备所支持的接口和端点的详细信息。以下代码片段
显示了在一部HTCOneX+手机上ADB的接口和端口。
dev;~# 1susb -v -d 0bb4 : 0dfc
Bus 001 Device 067: ID 0bb4:0dfc Bigh Tech Comguter Corp.
Device Descriptor:
[...]
Idvendor
0x0bb4 High Tech Computer Corp.
1dProduct
0x0dfc