[root@bbs /etc]#
下面，我们以以 Web Server 的端口 80 做例子来看看这份单子说明了些什么？：
它在 services 文件中的那一行是这样的：
www             80/tcp          http            # WorldWideWeb HTTP
大家可以看到这一行分 3 部分：
www 代表 HTTP 协议的端口名（也就是缺省的 Web Browser 连接服务器时的端
口）。
80/tcp 这一部分是用 ＂／＂ 号分开的，前半部分表示的是端口号（这里的 HTTP
协议的端口是 80），后半部分表示是一个 TCP 连接（也就是有连接的套接字，相对应的是
UDP）。
http 代表是 HTTP 协议。
# WorldWideWeb HTTP 最后大家看到的这个是以“ ＃” 号打头的，是一些注释。
我们所在意的其实只有 HTTP 和 80 ．通过这个规律，大家可以看到这个 RedHat 6.0
自己所定义的保留端口（其中包括一些大于 1024 的端口）
这个文件只是定义了每个服务所使用的端口和它的别名。假如你运行
$telnet 127.0.0.1 www
那么你就连接到了本地的 Web 服务器上（当然，前提是你已经启动了这个 Web 服务
器）。
自己编程的时候应该尽量避免自己的服务器所使用的端口和系统的 Services 文件中已
经声明的端口重叠。避免的方法除了参考系统的 Services 文件以外，你还可以直接对系统
进行 telnet 来进行测试。
比如你的程序想使用 4000 端口进行监听网络连接，你为了确定是否已经有程序使用
了 4000 端口，可以像下面这样操作：
$telnet 127.0.0.1 4000
第 6 章  berkeley 套接字
- 179 -
如果系统给出了错误信息：
[root@bbs /etc]# telnet 127.0.0.1 4000
Trying 127.0.0.1...
telnet: Unable to connect to remote host: Connection refused
那么说明系统中没有程序使用 4000 端口，你可以放心的使用了。
技巧：如果你自己写了一个 Server 和 Client ，但是 Client 却无法连上 Server 而你又不知道究竟是哪
个有问题的时候，你可以使用系统的工具 telnet 来帮助你。如果你的 Server 监听的端口是 4000 ，那么可
以直接使用 telnet 去连接 4000 端口。如果使用 telnet 连接正常，那么你就可以确定你的 Server 运行正常．
6.10 五种 I/O模式
下面我们简单的介绍一个各种 I/O 操作模式。在 Linux/UNIX 下，有下面这五种 I/O 操
作方式：
阻塞 I/O
非阻塞 I/O
I/O 多路复用
信号驱动 I/O（SIGIO）
异步 I/O
这章讲述了一些 I/O 的细节，你可以在第一次阅读的时候跳过这部分，然后在第二次
阅读本书的时候再来读这一节。
一般来说，程序进行输入操作有两步：
1．等待有数据可以读
2．将数据从系统内核中拷贝到程序的数据区。
对于一个对套接字的输入操作，第一步一般来说是等待数据从网络上传到本地。当数
据包到达的时候，数据将会从网络层拷贝到内核的缓存中；第二步是从内核中把数据拷贝
到程序的数据区中。
6.10.1  阻塞 I /O模式
阻塞 I/O 模式是最普遍使用的 I/O 模式。大部分程序使用的都是阻塞模式的 I/O 。缺
省的，一个套接字建立后所处于的模式就是阻塞 I/O 模式。
对于一个 UDP 套接字来说，数据就绪的标志比较简单：
已经收到了一整个数据报
没有收到。
而 TCP 这个概念就比较复杂，需要附加一些其他的变量。
在图 6-4 中，一个进程调用 recvfrom ，然后系统调用并不返回知道有数据报到达本地
系统，然后系统将数据拷贝到进程的缓存中。（如果系统调用收到一个中断信号，则它的
调用会被中断）
我们称这个进程在调用 recvfrom一直到从 recvfrom 返回这段时间是阻塞的。当recvfrom
正常返回时，我们的进程继续它的操作。
- 180 -
Linux网络编程
图 6-4  tcp 连接的简单示例
6.10.2  非阻塞模式 I /O
当我们将一个套接字设置为非阻塞模式，我们相当于告诉了系统内核：“ 当我请求的
I/O 操作不能够马上完成，你想让我的进程进行休眠等待的时候，不要这么做，请马上返
回一个错误给我。”
我们可以参照图 6-5 来描述非阻塞模式 I/O 。
我们开始对 recvfrom 的三次调用，因为系统还没有接收到网络数据，所以内核马上返
回一个 EWOULDBLOCK的错误。第四次我们调用 recvfrom 函数，一个数据报已经到达了，
内核将它拷贝到我们的应用程序的缓冲区中，然后 recvfrom 正常返回，我们就可以对接收
到的数据进行处理了。
当一个应用程序使用了非阻塞模式的套接字，它需要使用一个循环来不听的测试是否
一个文件描述符有数据可读（称做 polling）。应用程序不停的 polling 内核来检查是否 I/O
操作已经就绪。这将是一个极浪费 CPU 资源的操作。这种模式使用中不是很普遍。
第 6 章  berkeley 套接字
- 181 -
图 6-5  非阻塞模式 I/O
6.10.3  I /O多路复用
在使用 I/O 多路技术的时候，我们调用 select()函数和 poll()函数，在调用它们的时候
阻塞，而不是我们来调用 recvfrom（或 recv）的时候阻塞。图 6-6 说明了它的工作方式。
当我们调用 select 函数阻塞的时候，select 函数等待数据报套接字进入读就绪状态。当
select 函数返回的时候，也就是套接字可以读取数据的时候。这时候我们就可以调用 recvfrom
函数来将数据拷贝到我们的程序缓冲区中。
和阻塞模式相比较，select()和 poll()并没有什么高级的地方，而且，在阻塞模式下只需
要调用一个函数：读取或发送，在使用了多路复用技术后，我们需要调用两个函数了：先
调用 select()函数或 poll()函数，然后才能进行真正的读写。
多路复用的高级之处在于，它能同时等待多个文件描述符，而这些文件描述符（套接
字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。
- 182 -
Linux网络编程
图 6-6  I/O 多路复用
假设我们运行一个网络客户端程序，要同时处理套接字传来的网络数据又要处理本地
的标准输入输出。在我们的程序处于阻塞状态等待标准输入的数据的时候，假如服务器端
的程序被 kill（或是自己 Down 掉了），那么服务器程端的 TCP 协议会给客户端（我们这端）
的 TCP 协议发送一个 FIN 数据代表终止连接。但是我们的程序阻塞在等待标准输入的数
据上，在它读取套接字数据之前（也许是很长一段时间），它不会看见结束标志．我们就
不能够使用阻塞模式的套接字。
IO 多路技术一般在下面这些情况中被使用：
当一个客户端需要同时处理多个文件描述符的输入输出操作的时候（一般来说是
标准的输入输出和网络套接字）， I/O 多路复用技术将会有机会得到使用。
当程序需要同时进行多个套接字的操作的时候。
如果一个 TCP 服务器程序同时处理正在侦听网络连接的套接字和已经连接好的套
接字。
如果一个服务器程序同时使用 TCP 和 UDP 协议。
如果一个服务器同时使用多种服务并且每种服务可能使用不同的协议（比如 inetd
就是这样的）。
I/O 多路服用技术并不只局限与网络程序应用上。几乎所有的程序都可以找到应用 I/O
多路复用的地方。
6.10.4  信号驱动 I /O模式
我们可以使用信号，让内核在文件描述符就绪的时候使用 SIGIO 信号来通知我们。我
们将这种模式称为信号驱动 I/O 模式。
使用这种模式，我们首先需要允许套接字使用信号驱动 I/O ，还要安装一个 SIGIO 的
第 6 章  berkeley 套接字
- 183 -
处理函数。在这种模式下，系统调用将会立即返回，然后我们的程序可以继续做其他的事
情。当数据就绪的时候，系统会向我们的进程发送一个 SIGIO 信号。这样我们就可以在SIGIO
信号的处理函数中进行 I/O 操作（或是我们在函数中通知主函数有数据可读）。
我们现在还不必对 SIGIO 信号处理函数做过多的了解（在下一章中我们会介绍信号的
有关内容）。对于信号驱动 I/O 模式，它的先进之处在于它在等待数据的时候不会阻塞，程
序可以做自己的事情。当有数据到达的时候，系统内核会向程序发送一个 SIGIO 信号进行
通知，这样我们的程序就可以获得更大的灵活性，因为我们不必为等待数据进行额外的编
码。
图 6-7 信号驱动 I/O
信号 I/O 可以使内核在某个文件描述符发生改变的时候发信号通知我们的程序。异步
I/O 可以提高我们程序进行 I/O 读写的效率。通过使用它，当我们的程序进行 I/O 操作的时
候，内核可以在初始化 I/O 操作后立即返回，在进行 I/O 操作的同时，我们的程序可以做
自己的事情，直到 I/O 操作结束，系统内核给我们的程序发消息通知。
基于 Berkeley 接口的 Socket 信号驱动 I/O 使用信号 SIGIO。有的系统 SIGPOLL 信号，
它也是相当于 SIGIO 的。
为了在一个套接字上使用信号驱动 I/O 操作，下面这三步是所必须的。
（1）一个和 SIGIO 信号的处理函数必须设定。
（2）套接字的拥有者必须被设定。一般来说是使用 fcntl 函数的 F_SETOWN 参数来
进行设定拥有者。
（3）套接字必须被允许使用异步 I/O。一般是通过调用 fcntl 函数的 F_SETFL 命令，
O_ASYNC 为参数来实现。
注意：我们在设置套接字的属主之前必须将 SIGIO 的信号处理函数设好，SIGIO 的缺省动作是被忽
略。因此我们如果以相反的顺序调用这两个函数调用，那么在 fcntl 函数调用之后，signal 函数调用之前就
- 184 -
Linux网络编程
有一小段时间程序可能接收到 SIGIO 信号。那样的话，信号将会被丢弃。在 SVR4 系统中，SIGIO 在
 头文件中被定义为 SIGPOLL，而 SIGPOLL 信号的缺省动作是终止这个进程。所以我们一
定要保证这两个函数的调用顺序：先调用 signal 设置好 SIGIO 信号处理函数，然后在使用 fcntl 函数设置
套接字的属主。
虽然设定套接字为异步 I/O 非常简单，但是使用起来困难的部分是怎样在程序中断定
产生 SIGIO 信号发送给套接字属主的时候，程序处在什么状态。
1．UDP 套接字的 SI GI O信号
在 UDP 协议上使用异步 I/O 非常简单．这个信号将会在这个时候产生：
套接字收到了一个数据报的数据包。
套接字发生了异步错误。
当我们在使用 UDP 套接字异步 I/O 的时候，我们使用 recvfrom()函数来读取数据报数
据或是异步 I/O 错误信息。
2．TCP 套接字的 SI GI O信号
不幸的是，异步 I/O 几乎对 TCP 套接字而言没有什么作用。因为对于一个 TCP 套接
字来说， SIGIO 信号发生的几率太高了，所以 SIGIO 信号并不能告诉我们究竟发生了什
么事情。在 TCP 连接中， SIGIO 信号将会在这个时候产生：
在一个监听某个端口的套接字上成功的建立了一个新连接。
一个断线的请求被成功的初始化。
一个断线的请求成功的结束。
套接字的某一个通道（发送通道或是接收通道）被关闭。
套接字接收到新数据。
套接字将数据发送出去。
发生了一个异步 I/O 的错误。
举例来说，如果一个正在进行读写操作的 TCP 套接字处于信号驱动 I/O 状态下，那么
每当新数据到达本地的时候，将会产生一个 SIGIO 信号，每当本地套接字发出的数据被远
程确认后，也会产生一个 SIGIO 信号。对于我们的程序来讲，是无法区分这两个 SIGIO 有
什么区别的。在这种情况下使用 SIGIO，TCP 套接字应当被设置为无阻塞模式来阻止一个
阻塞的 read 和 write（recv 和 send）操作。我们可以考虑在一个只进行监听网络连接操作
的套接字上使用异步 I/O，这样当有一个新的连接的时候，SIGIO 信号将会产生。
一个对信号驱动 I/O 比较实用的方面是 NTP（网络时间协议 Network Time Protocol）
服务器，它使用 UDP。这个服务器的主循环用来接收从客户端发送过来的数据报数据包，
然后再发送请求。对于这个服务器来说，记录下收到每一个数据包的具体时间是很重要的。
因为那将是返回给客户端的值，客户端要使用这个数据来计算数据报在网络上来回所花费
的时间。图 6-8 表示了怎样建立这样的一个 UDP 服务器。
第 6 章  berkeley 套接字
- 185 -
图 6-8  NTP 服务器
大多数的 UDP 服务都被设计成图左边的模式。但是 NTP 服务器使用的是图右边的技
术。当有一个新的数据报到达的时候，SIGIO 的处理函数会取出它放入一个程序等待读取
的队列，主程序会从这个队列中读取数据。虽然这样会增加程序代码的长度，但是它能够
获取数据包到达服务器程序的准确时间．
6.10.5  异步 I /O模式
当我们运行在异步 I/O 模式下时，我们如果想进行 I/O 操作，只需要告诉内核我们要
进行 I/O 操作，然后内核会马上返回。具体的 I/O 和数据的拷贝全部由内核来完成，我们
的程序可以继续向下执行。当内核完成所有的 I/O 操作和数据拷贝后，内核将通知我们的
程序。
异步 I/O 和 信号驱动 I/O 的区别是：
信号驱动 I/O 模式下，内核在操作可以被操作的时候通知给我们的应用程序发送
SIGIO 消息。
异步 I/O 模式下，内核在所有的操作都已经被内核操作结束之后才会通知我们的
应用程序。
如下图，当我们进行一个 IO 操作的时候，我们传递给内核我们的文件描述符，我们
的缓存区指针和缓存区的大小，一个偏移量 offset，以及在内核结束所有操作后和我们联
系的方法。这种调用也是立即返回的，我们的程序不需要阻塞住来等待数据的就绪。我们
可以要求系统内核在所有的操作结束后（包括从网络上读取信息，然后拷贝到我们提供给
内核的缓存区中）给我们发一个消息。
- 186 -
Linux网络编程
图 6-9  异步 I/O
6.10.6  几种 I /O模式的比较
下面这个表格对这几种 I/O 模式进行了对比。
表 6-1  几种 I/O 模式的对比
阻塞模式
非阻塞模式
I/O 多路复用
信号驱动 I/O
异步 I/O
初始化
 结束
 检查
 检查
 检查
 检查
 检查
 检查
 检查
 检查
 检查
 结束
 检查
 就绪
 初始化
 结束
 信号通知
  初始化
  结束
 初始化
 信号通知
我们可以从中清楚的看出各个模式的差别，自己的程序可以挑选合适的模式来使用。
6.10.7  f cnt l ( ) 函数
阻塞．你应该明白它的意思。简单的说，阻塞就是＂睡眠＂的同义词．你也许注意到
阻塞
等
待
数据
将 数 据
从 内 核
拷 贝 给
用 户 程
序
第 6 章  berkeley 套接字
- 187 -
你运行上面的 listener 的时候，它只不过是简单的在那里等待接收数据。它调用 recvfrom()
函数，但是那个时候（listener 调用 recvfrom()函数的时候），它并没有数据可以接收．所以
recvfrom()函数阻塞在那里（也就是程序停在 recvfrom()函数处睡大觉）直到有数据传过来。