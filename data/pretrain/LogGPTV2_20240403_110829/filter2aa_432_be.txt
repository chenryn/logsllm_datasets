### 6.10 五种 I/O 模式

在本节中，我们将简要介绍 Linux/UNIX 系统中的五种 I/O 操作模式：

1. **阻塞 I/O**
2. **非阻塞 I/O**
3. **I/O 多路复用**
4. **信号驱动 I/O（SIGIO）**
5. **异步 I/O**

#### 6.10.1 阻塞 I/O 模式

阻塞 I/O 是最常见的 I/O 模式。在这种模式下，当进程调用一个 I/O 函数（如 `recvfrom`）时，如果数据尚未准备好，进程将被挂起，直到数据准备好为止。

- **UDP 套接字**：数据就绪的标志是收到完整的数据报。
- **TCP 套接字**：需要更多的变量来判断数据是否就绪。

##### 示例
```plaintext
进程调用 recvfrom -> 数据未到达 -> 进程阻塞
数据到达 -> 内核将数据拷贝到进程缓冲区 -> recvfrom 返回 -> 进程继续执行
```

#### 6.10.2 非阻塞 I/O 模式

在非阻塞 I/O 模式下，当进程请求的 I/O 操作不能立即完成时，内核会立即返回一个错误（如 `EWOULDBLOCK`），而不是让进程进入阻塞状态。

##### 示例
```plaintext
进程调用 recvfrom (三次) -> 数据未到达 -> 内核返回 EWOULDBLOCK
进程再次调用 recvfrom -> 数据到达 -> 内核将数据拷贝到进程缓冲区 -> recvfrom 返回
```

这种模式通常需要通过轮询（polling）来不断检查文件描述符的状态，这会导致 CPU 资源的浪费。

#### 6.10.3 I/O 多路复用

I/O 多路复用允许进程同时监视多个文件描述符，并在任何一个描述符就绪时进行操作。常用的函数有 `select()` 和 `poll()`。

##### 示例
```plaintext
进程调用 select() -> 阻塞等待任意一个文件描述符就绪
某个文件描述符就绪 -> select() 返回 -> 进程调用 recvfrom() 读取数据
```

多路复用的优势在于可以同时处理多个文件描述符，适用于需要同时处理网络连接和标准输入输出的场景。

#### 6.10.4 信号驱动 I/O 模式

在信号驱动 I/O 模式下，进程设置一个信号处理函数（如 `SIGIO`），并在数据就绪时由内核发送信号通知进程。

##### 示例
```plaintext
设置 SIGIO 信号处理函数 -> 允许套接字使用信号驱动 I/O
数据就绪 -> 内核发送 SIGIO 信号 -> 信号处理函数被调用 -> 进行 I/O 操作
```

这种模式在等待数据时不会阻塞进程，提高了程序的灵活性。

#### 6.10.5 异步 I/O 模式

在异步 I/O 模式下，进程发起 I/O 请求后立即返回，内核在完成所有 I/O 操作后通知进程。

##### 示例
```plaintext
进程发起异步 I/O 请求 -> 立即返回 -> 内核完成 I/O 操作 -> 通知进程
```

与信号驱动 I/O 不同，异步 I/O 在所有操作完成后才通知进程，而信号驱动 I/O 只在数据就绪时通知。

#### 6.10.6 几种 I/O 模式的比较

| 模式          | 初始化 | 结束 | 检查 | 就绪 | 信号通知 |
|---------------|--------|------|------|------|----------|
| 阻塞 I/O      |        |      |      | √    |          |
| 非阻塞 I/O    |        |      | √    |      |          |
| I/O 多路复用  |        |      | √    | √    |          |
| 信号驱动 I/O  |        |      | √    |      | √        |
| 异步 I/O      |        |      |      |      | √        |

根据具体需求，可以选择合适的 I/O 模式来优化程序性能。

#### 6.10.7 `fcntl()` 函数

`fcntl()` 函数用于修改或查询文件描述符的属性。在信号驱动 I/O 中，`fcntl()` 用于设置套接字的所有者和启用异步 I/O。

##### 示例
```c
// 设置 SIGIO 信号处理函数
signal(SIGIO, signal_handler);

// 设置套接字的所有者
fcntl(sockfd, F_SETOWN, getpid());

// 启用异步 I/O
fcntl(sockfd, F_SETFL, O_ASYNC);
```

确保先设置信号处理函数，再设置套接字的所有者，以避免信号丢失。

通过这些 I/O 模式的理解和应用，可以有效地管理和优化网络编程中的 I/O 操作。