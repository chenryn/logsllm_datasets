#include 
You must add this #include before , otherwise you’ll get compilation errors. In fact,
you can remove  entirely, as it’s included by .
Here is the definition for PsLookupThreadByThreadId:
NTSTATUS PsLookupThreadByThreadId(
_In_
HANDLE ThreadId,
_Outptr_
PETHREAD *Thread);
Again, we see that a thread ID is required, but its type is HANDLE - but it is the ID that we need nonetheless.
The resulting pointer is typed as PETHREAD or pointer to ETHREAD. ETHREAD is completely opaque.
Regardless, we seem to have a problem since KeSetPriorityThread accepts a PKTHREAD rather than
PETHREAD. It turns out these are the same, because the first member of an ETHREAD is a KTHREAD (the
member is named Tcb). We’ll prove all this in the next chapter when we use the kernel debugger. Here is
the beginning of the definition of ETHREAD:
typedef struct _ETHREAD {
KTHREAD Tcb;
// more members
} ETHREAD;
The bottom line is we can safely switch PKTHREAD for PETHREAD or vice versa when needed without a
hitch.
Now we can turn our thread ID into a pointer:
PETHREAD thread;
status = PsLookupThreadByThreadId(ULongToHandle(data->ThreadId),
&thread);
if (!NT_SUCCESS(status))
break;
The call to PsLookupThreadByThreadId can fail, the main reason being that the thread ID does not
reference any thread in the system. If the call fails, we simply break and let the resulting NTSTATUS
propagate out of the “loop”.
We are finally ready to change the thread’s priority. But wait - what if after the last call succeeds, the
thread is terminated, just before we set its new priority? Rest assured, this cannot happen. Technically,
the thread can terminate (from an execution perspective) at that point, but that will not make our pointer
a dangling one. This is because the lookup function, if successful, increments the reference count on the
kernel thread object, so it cannot die until we explicitly decrement the reference count. Here is the call to
make the priority change:
Chapter 4: Driver from Start to Finish
69
auto oldPriority = KeSetPriorityThread(thread, data->Priority);
KdPrint(("Priority change for thread %u from %d to %d succeeded!\n",
data->ThreadId, oldPriority, data->Priority));
We get back the old priority, which we output with KdPrint for debugging purposes. All that’s left to do
now is decrement the thread object’s reference; otherwise, we have a leak on our hands (the thread object
will never die), which will only be resolved in the next system boot. The function that accomplishes this
feat is ObDereferenceObject:
ObDereferenceObject(thread);
We should also report to the client that we used the buffer provided. This is where the information
variable is used:
information = sizeof(data);
We’ll write that value to the IRP before completing it. This is the value returned as the second to last
argument from the client’s WritewFile call. All that’s left to do is to close the while “loop” and complete
the IRP with whatever status we happen to have at this time.
// end the while "loop"
} while (false);
//
// complete the IRP with the status we got at this point
//
Irp->IoStatus.Status = status;
Irp->IoStatus.Information = information;
IoCompleteRequest(Irp, IO_NO_INCREMENT);
return status;
}
And we’re done! For reference, here is the complete IRP_MJ_WRITE handler:
NTSTATUS BoosterWrite(PDEVICE_OBJECT, PIRP Irp) {
auto status = STATUS_SUCCESS;
ULONG_PTR information = 0;
auto irpSp = IoGetCurrentIrpStackLocation(Irp);
do {
if (irpSp->Parameters.Write.Length (Irp->UserBuffer);
if (data == nullptr
|| data->Priority Priority > 31) {
status = STATUS_INVALID_PARAMETER;
break;
}
PETHREAD thread;
status = PsLookupThreadByThreadId(
ULongToHandle(data->ThreadId), &thread);
if (!NT_SUCCESS(status)) {
break;
}
auto oldPriority = KeSetPriorityThread(thread, data->Priority);
KdPrint(("Priority change for thread %u from %d to %d succeeded!\n",
data->ThreadId, oldPriority, data->Priority));
ObDereferenceObject(thread);
information = sizeof(data);
} while (false);
Irp->IoStatus.Status = status;
Irp->IoStatus.Information = information;
IoCompleteRequest(Irp, IO_NO_INCREMENT);
return status;
}
Installing and Testing
At this point, we can build the driver and client successfully. Our next step is to install the driver and test
its functionality. You can try the following on a virtual machine, or if you’re feeling brave enough - on
your development machine.
First, let’s install the driver. Copy the resulting booster.sys file to the target machine (if it’s not your
development machine). On the target machine, open an elevated command window and install the driver
using the sc.exe tool as we did back in chapter 2:
c:\> sc create booster type= kernel binPath= c:\Test\Booster.sys
Make sure binPath includes the full path of the resulting SYS file. The name of the driver (booster) in the
example is the name of the created Registry key, and so must be unique. It doesn’t have to be related to
the SYS file name.
Now we can load the driver:
Chapter 4: Driver from Start to Finish
71
c:\> sc start booster
If all is well, the driver would have started successfully. To make sure, we can open WinObj and look for
our device name and symbolic link. Figure 4-1 shows the symbolic link in WinObj.
Figure 4-1: Symbolic Link in WinObj
Now we can finally run the client executable. Figure 4-2 shows a thread in Process Explorer of a cmd.exe
process selected as an example for which we want set priority to a new value.
Chapter 4: Driver from Start to Finish
72
Figure 4-2: Original thread priority
Run the client with the thread ID and the desired priority (replace the thread ID as needed):
c:\Test> boost 768 25
Chapter 4: Driver from Start to Finish
73
If you get an error trying to run the executable (usually it’s a Debug build), you may need to set
the runtime library to a static one instead of a DLL. Go to Project properties in Visual Studio for
the client application, C++ node, Code Generation, Runtime Library, and select Multithreaded
Debug. Alternatively, you can compile the client in Release build, and that should run without
any changes.
And voila! See figure 4-3.
You should also run DbgView and see the output when a successful priority change occurrs.
Chapter 4: Driver from Start to Finish
74
Figure 4-3: Modified thread priority
Summary
We’ve seen how to build a simple, yet complete, driver, from start to finish. We created a user-mode client
to communicate with the driver. In the next chapter, we’ll tackle debugging, which is something we’re
bound to do when writing drivers that may not behave as we expect.
Chapter 5: Debugging and Tracing
Just like with any software, kernel drivers tend to have bugs. Debugging drivers, as opposed to user-mode
debugging, is more challenging. Driver debugging is essentially debugging an entire machine, not just
a specific process. This requires a somewhat different mindset. This chapter discussed user-mode and
kernel-mode debugging using the WinDbg debugger.
In this chapter:
• Debugging Tools for Windows
• Introduction to WinDbg
• Kernel Debugging
• Full Kernel Debugging
• Kernel Driver Debugging Tutorial
• Asserts and Tracing
Debugging Tools for Windows
The Debugging Tools for Windows package contains a set of debuggers, tools, and documentation focusing
on the debuggers within the package. This package can be installed as part of the Windows SDK or the
WDK, but there is no real “installation” done. The installation just copies files but does not touch the
Registry, meaning the package depends only on its own modules and the Windows built-in DLLs. This
makes it easy to copy the entire directory to any other directory including removable media.
The package contains four debuggers: Cdb.exe, Ntsd.Exe, Kd.exe, and WinDbg.exe. Here is a rundown of
the basic functionality of each debugger:
• Cdb and Ntsd are user-mode, console-based debuggers. This means they can be attached to processes,
just like any other user-mode debugger. Both have console UI - type in a command, get a response,
and repeat. The only difference between the two is that if launched from a console window, Cdb uses
the same console, whereas Ntsd always opens a new console window. They are otherwise identical.
• Kd is a kernel debugger with a console user interface. It can attach to the local kernel (Local
Kernel Debugging, described in the next section), or to another machine for a full kernel debugging
experience.
• WinDbg is the only debugger with a graphical user interface. It can be used for user-mode debugging
or kernel debugging, depending on the selection performed with its menus or the command line
arguments passed to it when launched.
Chapter 5: Debugging and Tracing
76
A relatively recent alternative to the classic WinDbg is Windbg Preview, available through the Microsoft
store. This is a remake of the classic debugger with a much better user interface. It can be installed on
Windows 10 version 1607 or later. From a functionality standpoint, it’s similar to the classic WinDbg. But
it is somewhat easier to use because of the modern, convenient UI, and in fact has also solved some bugs
that still plague the classic debugger. All the commands we’ll see in this chapter work equally well with
either debugger.
Although these debuggers may seem different from one another, the user-mode debuggers are essentially
the same, as are the kernel debuggers. They are all based around a single debugger engine implemented
as a DLL (DbgEng.Dll). The various debuggers are able to use extension DLLs, that provide most of the
power of the debuggers by loading new commands.
The Debugger Engine is documented to a large extent in the Debugging tools for Windows documentation,
which makes it possible to write new debuggers (or other tools) that utilize the debugger engine.
Other tools that are part of the package include the following (partial list):
• Gflags.exe - the Global Flags tool that allows setting some kernel flags and image flags.
• ADPlus.exe - generate a dump file for a process crash or hang.
• Kill.exe - a simple tool to terminate process(es) based on process ID, name, or pattern.
• Dumpchk.exe - tool to do some general checking of dump files.
• TList.exe - lists running processes on the system with various options.
• Umdh.exe - analyzes heap allocations in user-mode processes.
• UsbView.exe - displays a hierarchical view of USB devices and hubs.
Introduction to WinDbg
This section describes the fundamentals of WinDbg, but bear in mind everything is essentially the same
for the console debuggers, with the exception of the GUI windows.
WinDbg is built around commands. The user enters a command, and the debugger responds with text
describing the results of the command. With the GUI, some of these results are depicted in dedicated
windows, such as locals, stack, threads, etc.
WinDbg supports three types of commands:
• Intrinsic commands - these commands are built-in into the debugger (part of the debugger engine),
and they operate on the target being debugged.
• Meta commands - these commands start with a period (.) and they operate on the debugging
environment, rather than directly on the target being debugged.
Chapter 5: Debugging and Tracing
77
• Extension commands (sometimes called bang commands) - these commands start with an ex-
clamation point (!), providing much of the power of the debugger. All extension commands are
implemented in external DLLs. By default, the debugger loads a set of predefined extension DLLs,
but more can be loaded from the debugger directory or another directory with the .load meta
command.
Writing extension DLLs is possible and is fully documented in the debugger docs. In fact, many such DLLs
have been created and can be loaded from their respective source. These DLLs provide new commands
that enhance the debugging experience, often targeting specific scenarios.
Tutorial: User mode debugging basics
If you have experience with WinDbg usage in user-mode, you can safely skip this section.
This tutorial is aimed at getting a basic understanding of WinDbg and how to use it for user-mode
debugging. Kernel debugging is described in the next section.
There are generally two ways to initiate user-mode debugging - either launch an executable and attach to
it, or attach to an already existing process. We’ll use the latter approach in this tutorial, but except for this
first step, all other operations are identical.
• Launch Notepad.
• Launch WinDbg (either the Preview or the classic one. The following screenshots use the Preview).
• Select File / Attach To Process and locate the Notepad process in the list (see figure 5-1). Then click
Attach. You should see output similar to figure 5-2.
Chapter 5: Debugging and Tracing
78
Figure 5-1: Attaching to a process with WinDbg
Figure 5-2: First view after process attach
The Command window is the main window of interest - it should always be open. This is the one showing
Chapter 5: Debugging and Tracing
79
the various responses of commands. Typically, most of the time in a debugging session is spent interacting
with this window.
The process is suspended - we are in a breakpoint induced by the debugger.
• The first command we’ll use is ∼, which shows information about all threads in the debugged
process:
0:003> ~
0
Id: 874c.18068 Suspend: 1 Teb: 00000001`2229d000 Unfrozen
1
Id: 874c.46ac Suspend: 1 Teb: 00000001`222a5000 Unfrozen
2
Id: 874c.152cc Suspend: 1 Teb: 00000001`222a7000 Unfrozen
.
3
Id: 874c.bb08 Suspend: 1 Teb: 00000001`222ab000 Unfrozen
The exact number of threads you’ll see may be different than shown here.
One thing that is very important is the existence of proper symbols. Microsoft provides a public symbol
server, which allows locating symbols for most modules by produced by Microsoft. This is essential in any
low-level debugging.
• To set symbols quickly, enter the .symfix command.
• A better approach is to set up symbols once and have them available for all future debugging sessions.
To do that, add a system environment variable named _NT_SYMBOL_PATH and set it to a string
like the following:
SRV*c:\Symbols*http://msdl.microsoft.com/download/symbols
The middle part (between asterisks) is a local path for caching symbols on your local machine; you
can select any path you like (including a network share, if sharing with a team is desired). Once this
environment variable is set, next invocations of the debugger will find symbols automatically and load
them from the Microsoft symbol server as needed.
The debuggers in the Debugging Tools for Windows are not the only tools that look for this
environment variables. Sysinternals tools (e.g. Process Explorer, Process Monitor), Visual Studio,
and others look for the same variable as well. You set it once, and get its benefit using multiple
tools.
• To make sure you have proper symbols, enter the lm (loaded modules) command:
Chapter 5: Debugging and Tracing
80
0:003> lm
start
end
module name
00007ff7`53820000 00007ff7`53863000
notepad
(deferred)
00007ffb`afbe0000 00007ffb`afca6000
efswrt
(deferred)
...
00007ffc`1db00000 00007ffc`1dba8000
shcore
(deferred)
00007ffc`1dbb0000 00007ffc`1dc74000
OLEAUT32
(deferred)
00007ffc`1dc80000 00007ffc`1dd22000
clbcatq
(deferred)
00007ffc`1dd30000 00007ffc`1de57000
COMDLG32
(deferred)
00007ffc`1de60000 00007ffc`1f350000
SHELL32
(deferred)
00007ffc`1f500000 00007ffc`1f622000
RPCRT4
(deferred)
00007ffc`1f630000 00007ffc`1f6e3000
KERNEL32
(pdb symbols)
c:\symbols\ker\
nel32.pdb\3B92DED9912D874A2BD08735BC0199A31\kernel32.pdb
00007ffc`1f700000 00007ffc`1f729000
GDI32
(deferred)
00007ffc`1f790000 00007ffc`1f7e2000
SHLWAPI
(deferred)
00007ffc`1f8d0000 00007ffc`1f96e000
sechost
(deferred)
00007ffc`1f970000 00007ffc`1fc9c000
combase
(deferred)
00007ffc`1fca0000 00007ffc`1fd3e000
msvcrt
(deferred)
00007ffc`1fe50000 00007ffc`1fef3000
ADVAPI32
(deferred)
00007ffc`20380000 00007ffc`203ae000