We also note that it is important that security holds under “adversarially chosen” public keys
(i.e. we need to prove or assume that the adversary cannot generate a public key such that it gives
him and advantage in the MtA protocol).
6.2 Other multiplicative to share conversions.
Our threshold DSA scheme works with any MtA protocol, i.e. any protocol that allows two parties
to convert their multiplicative shares of a secret into additive shares.
In particular the classic approach based on oblivious transfer by Gilboa [21] can be used. The
original protocol in [21] is secure only against semi-honest adversaries, but it can be strengthened
against a malicious adversary (see the literature on SPDZ or the recent work on threshold DSA in
[12]).
6.3 Simulation-Based Security
Our proof uses the game-based deﬁnition of unforgeability. The main technical reason is that
the simulator cannot detect if the current execution is semi-correct or not, and therefore has to
guess. This prevents us from achieving the stronger notion of simulation-based security (where
each execution of the protocol can be fully simulated).
While in the real world it is unfeasible to decide if an execution is semi-correct or not, the
simulator can do that if it were able to “extract” the bad players’ inputs to the MtA protocols.
Indeed that would allow the simulator to check that the values δi, Γi sent by the bad players
in Phases 3 and 4 are consistent with the inputs entered in the MtA protocols. If they are, the
execution is semi-correct, if they are not then the execution is not semi-correct. Once the simulator
knows which execution it is, it can choose the correct simulation strategy.
We note that in our current simulation, the simulator can already extract the input ki (since
it knows the decryption key of the bad players, having it extracted it during the key generation
simulation) and the input wi (the share of the secret key, which it also extracted during key
generation). But in our current simulation it is not able to extract γi since we do not require the
players to prove knowledge of it.
The best way to solve this is to require Pi, Pj to run MtAwc also when interacting on inputs
ki, γj, since MtAwc forces the respondent (which runs on input γi) to prove knowledge of its input.
In turn this will allow the simulator to extract γi for the bad players and detect what kind of
execution it is being run.
We note that the maliciously secure OT-based MtA protocol from [12] also allows for input
extraction, and therefore if used in our protocol, it will yield a fully simulatable protocol.
6.4 Deterministic Key Generation
A very popular feature of Bitcoin wallets is deterministic key generation. Introduced in Bitcoin-
Improvement-Proposal 32 (BIP32), the idea of this scheme is to allow one to deterministicly gen-
erate many keys from a single ECDSA key. Our key sharing is compatible with BIP32 public
derivations, and we leave it as future work to prove security in this setting.
22
Rosario Gennaro and Steven Goldfeder
7
Implementation, Benchmarks, and Evaluation
We implemented both the key generation and signature generation of our protocol, and we conﬁrm
that they are highly eﬃcient and fast enough to be used in practice. We benchmarked the version of
our protocol from Section 5 that does not contain the range proofs, but relies on the Paillier-ECR
assumption. We compare the performance of our protocol to the runtimes of Gennaro et al. [17]
and Boneh et al. [4]. All benchmarks were single-threaded and run on an an Intel quad-core i7-6700
CPU @ 3.40GHz and 64GB of RAM. We ran the code [17] and [4] on our benchmark machine to
get an accurate comparison. It should be noted that we implemented our scheme in C while theirs
is a Java implementation which calls native C libraries for the heaviest arithmetic computations.
All benchmarks were taken over the secp256k1 curve, which is is the curve used in Bitcoin and
more recently a NIST standard.
For the curve operations, we used libsecp256k1.8 We implemented the MtA protocol with Paillier
using the implementation from libhcs.9.
7.1 Benchmarking the data complexity
When compared to [17, 4], we reduce the amount of data transmitted. All ﬁgures in this section
were measured empirically from the respective implementations, and thus it is possible that they
may be further optimized in practice. For a threshold of t (i.e. when there are t + 1 participants
in the signing protocol), the total data d in bytes sent and received by a given player to/from all
other players during the signing protocol is given by: ’
dours(t) = 2, 328 + t × 5, 024 Bytes
In contrast, the data sent to/from a given player in [17] is given by:
dGennaro(t) = (t + 1) × 34, 578 Bytes
And the data transmitted per player in [4] is given by:
dBoneh(t) = (t + 1) × 38, 189 Bytes
Lastly, we mention that for the 2-of-n case, we have dours(t = 1) = 3, 976 B. In contrast, the
recent protocol of [12] requires far more than that with 86.7 KiB for 2-of-2 signing and 106.7 KiB
for 2-of-n signing. Lindell’s scheme [27] only requires 769 B to be communicated in the 2-of-2 case
(but does not support 2-of-n).
7.2 Benchmarking signature generation time
Following the methodology of [4, 17], we benchmark the raw computation time of a single player
without counting network costs. Since each player runs their computation in parallel, this represents
the running time of the entire protocol other than network latency. We ﬁnd that our protocol
signiﬁcantly outperforms both of [4, 17] when using this metric.
As in [4, 17], the protocol running time has a ﬁxed cost that is independent of the number of
players plus a linear marginal cost as the threshold increases. We stress that the signing time only
depends on the number of active participants (t + 1), but does not depend on n, the total number
of players. All times are given on a single core, and were averaged over 1000 iterations.
Our protocols running time is given by:
rours(t) = 29 + (t) × 24 milliseconds
8 https://github.com/bitcoin-core/secp256k1
9 https://github.com/tiehuis/libhcs
Fast Multiparty Threshold ECDSA with Fast Trustless Setup
23
The running time of [17] is given by:
rGennaro(t) = 142 + (t) × 52 milliseconds
The running time of [4] is given by:
rBoneh(t) = 397 + (t) × 91 milliseconds
Fig. 1. Comparison of the raw computation time as the threshold increases between this work
and previous schemes.
We can see that our protocol signiﬁcantly outperforms both previous schemes. See Figure 1 for
a comparison of the concrete raw computation times for thresholds up to 20.
8 Conclusion
We have presented a threshold ECDSA protocol that is an improvement over the existing schemes
by every metric. Although [17] has been available for some time, there are still to our knowledge
no Bitcoin services or user wallets that oﬀer threshold-signature security. We believe that this is
due to the impracticality of their distributed key generation protocol. Having to rely on a trusted
dealer to distribute key shares exposes a single point of failure for the system and in doing so runs
contrary to the entire premise of using threshold signatures in the ﬁrst place.
We solve this problem by presenting and implementing a new scheme with a highly eﬃcient
distributed key generation protocol. Together with our reduction in running time and data trans-
ferred, we believe that ECDSA threshold signatures are ﬁnally mature enough for adoption.
9 Acknowledgements
We thank Harry Kalodner, Yehuda Lindell, Ariel Nof, Ben Riva, and Omer Shlomovits for useful
feedback and discussions and for pointing out errors in earlier drafts.
Rosario Gennaro is supported by NSF Grant 1565403. Steven Goldfeder is supported by an NSF
Graduate Research Fellowship under grant number DGE 1148900 and NSF award CNS-1651938.
24
Rosario Gennaro and Steven Goldfeder
References
1. Bar-Ilan, J., Beaver, D.: Non-cryptographic fault-tolerant computing in constant number of rounds
of interaction. In: Proceedings of the eighth annual ACM Symposium on Principles of distributed
computing. pp. 201–209. ACM (1989)
2. Bari´c, N., Pﬁtzmann, B.: Collision-free accumulators and fail-stop signature schemes without trees. In:
International Conference on the Theory and Applications of Cryptographic Techniques. pp. 480–494.
Springer (1997)
3. Boneh, D.: Digital signature standard. In: Encyclopedia of cryptography and security, pp. 347–347.
Springer (2011)
4. Boneh, D., Gennaro, R., Goldfeder, S.: Using level-1 homomorphic encryption to improve threshold
dsa signatures for bitcoin wallet security. In: Latincrypt (2017)
5. Boudot, F.: Eﬃcient proofs that a committed number lies in an interval. In: International Conference
on the Theory and Applications of Cryptographic Techniques. pp. 431–444. Springer (2000)
6. Canetti, R., Gennaro, R., Jarecki, S., Krawczyk, H., Rabin, T.: Adaptive security for threshold cryp-
tosystems. In: Annual International Cryptology Conference. pp. 98–116. Springer (1999)
7. Canetti, R., Goldwasser, S.: An eﬃcient Threshold public key cryptosystem secure against adaptive
chosen ciphertext attack. In: Advances in Cryptology - EUROCRYPT ’99, International Conference
on the Theory and Application of Cryptographic Techniques, Prague, Czech Republic, May 2-6, 1999,
Proceeding. pp. 90–106 (1999)
8. Damgard, I., Groth, J.: Non-interactive and reusable non-malleable commitment schemes. In: Proceed-
ings of the thirty-ﬁfth annual ACM symposium on Theory of computing. pp. 426–437. ACM (2003)
9. Damg˚ard, I., Keller, M., Larraia, E., Miles, C., Smart, N.P.: Implementing aes via an actively/covertly
secure dishonest-majority mpc protocol. In: International Conference on Security and Cryptography
for Networks. pp. 241–263. Springer (2012)
10. Di Crescenzo, G., Ishai, Y., Ostrovsky, R.: Non-interactive and non-malleable commitment. In: Pro-
ceedings of the thirtieth annual ACM symposium on Theory of computing. pp. 141–150. ACM (1998)
11. Di Crescenzo, G., Katz, J., Ostrovsky, R., Smith, A.: Eﬃcient and non-interactive non-malleable com-
mitment. In: International Conference on the Theory and Applications of Cryptographic Techniques.
pp. 40–59. Springer (2001)
12. Doerner, J., Kondi, Y., Lee, E., et al.: Secure two-party threshold ecdsa from ecdsa assumptions. In:
IEEE Symposium on Security and Privacy. p. 0. IEEE (2018)
13. Dolev, D., Dwork, C., Naor, M.: Non-malleable cryptography,”. In: Proceedings of the 23rd Annual
Symposium on the Theory of Computing, ACM (1991)
14. Fujisaki, E., Okamoto, T.: Statistical zero knowledge protocols to prove modular polynomial relations.
In: Annual International Cryptology Conference. pp. 16–30. Springer (1997)
15. Gennaro, R.: Multi-trapdoor commitments and their applications to proofs of knowledge secure under
concurrent man-in-the-middle attacks. In: Annual International Cryptology Conference. pp. 220–236.
Springer (2004)
16. Gennaro, R., Goldfeder, S.: Fast multiparty threshold ecdsa with fast trustless setup. In: Proceedings
of the 2018 ACM SIGSAC Conference on Computer and Communications Security. pp. 1179–1194.
ACM (2018)
17. Gennaro, R., Goldfeder, S., Narayanan, A.: Threshold-optimal dsa/ecdsa signatures and an application
to bitcoin wallet security. In: International Conference on Applied Cryptography and Network Security.
pp. 156–174. Springer (2016)
18. Gennaro, R., Jarecki, S., Krawczyk, H., Rabin, T.: Robust threshold dss signatures. In: International
Conference on the Theory and Applications of Cryptographic Techniques. pp. 354–371. Springer (1996)
19. Gennaro, R., Jarecki, S., Krawczyk, H., Rabin, T.: Robust threshold dss signatures. Information and
Computation 164(1), 54–84 (2001)
20. Gennaro, R., Micali, S.: Independent zero-knowledge sets. In: International Colloquium on Automata,
Languages, and Programming. pp. 34–45. Springer (2006)
21. Gilboa, N.: Two party rsa key generation. In: Advances in Cryptology - CRYPTO ’99. pp. 116–129
(1999)
22. Goldwasser, S., Micali, S., Rivest, R.L.: A digital signature scheme secure against adaptive chosen-
message attacks. SIAM Journal on Computing 17(2), 281–308 (1988)
23. Hazay, C., Mikkelsen, G.L., Rabin, T., Toft, T.: Eﬃcient rsa key generation and threshold paillier in
the two-party setting. In: Cryptographers’ Track at the RSA Conference. pp. 313–331. Springer (2012)
Fast Multiparty Threshold ECDSA with Fast Trustless Setup
25
24. Jarecki, S., Lysyanskaya, A.: Adaptively secure threshold cryptography: Introducing concurrency, re-
moving erasures. In: International Conference on the Theory and Applications of Cryptographic Tech-
niques. pp. 221–242. Springer (2000)
25. Keller, M., Pastro, V., Rotaru, D.: Overdrive: making spdz great again. In: Annual International
Conference on the Theory and Applications of Cryptographic Techniques. pp. 158–189. Springer (2018)
26. Kravitz, D.W.: Digital signature algorithm (Jul 27 1993), uS Patent 5,231,668
27. Lindell, Y.: Fast secure two-party ecdsa signing. In: Annual International Cryptology Conference. pp.
613–644. Springer (2017)
28. Lindell, Y., Nof, A.: Fast secure multiparty ecdsa with practical distributed key generation and appli-
cations to cryptocurrency custody. In: Proceedings of the 2018 ACM SIGSAC Conference on Computer
and Communications Security. pp. 1837–1854. ACM (2018)
29. MacKenzie, P., Reiter, M.K.: Two-party generation of dsa signatures. In: Annual International Cryp-
tology Conference. pp. 137–154. Springer (2001)
30. MacKenzie, P., Yang, K.: On simulation-sound trapdoor commitments. In: International Conference
on the Theory and Applications of Cryptographic Techniques. pp. 382–400. Springer (2004)
31. Paillier, P.: Public-key cryptosystems based on composite degree residuosity classes. In: International
Conference on the Theory and Applications of Cryptographic Techniques. pp. 223–238. Springer (1999)
32. Poupard, G., Stern, J.: Short proofs of knowledge for factoring. In: Public Key Cryptography, Third
International Workshop on Practice and Theory in Public Key Cryptography, PKC 2000, Melbourne,
Victoria, Australia, January 18-20, 2000, Proceedings. pp. 147–166 (2000)
33. Rivest, R.L., Shamir, A., Adleman, L.: A method for obtaining digital signatures and public-key
cryptosystems. Communications of the ACM 21(2), 120–126 (1978)
34. Schnorr, C.: Eﬃcient signature generation by smart cards. J. Cryptology 4(3), 161–174 (1991)
35. Shamir, A.: How to share a secret. Communications of the ACM 22(11), 612–613 (1979)
A The ZK Proofs for the MtA protocol
In this section we describe the ZK proofs that are needed in the MtA protocol (see Section 3). The
proofs are based on similar ones from [29]: speciﬁcally we prove statements that are simpler than
the ones needed in [29].
In these proofs the Veriﬁer uses an auxiliary RSA modulus ˜N which is the product of two safe
primes ˜P = 2˜p + 1 and ˜Q = 2˜q + 1 with ˜p, ˜q primes. The Veriﬁer also uses two values h1, h2 ∈ Z∗
˜N
according to the commitment scheme in [14]. Security is based on the assumption that the Prover
cannot solve the Strong RSA problem over ˜N .
Therefore our initialization protocol must be augmented with each player Pi generating an
additional RSA modulus ˜Ni, and values h1i, h2i, together with a proof that they are of the correct
form (see [14]).
A.1 Range Proof
This proof is run by Alice (the initiator) in both MtA and MtAwc protocols.
m ∈ Zq and r ∈ Z∗
The input for this proof is a Paillier public key N, Γ and a value c ∈ ZN 2. The prover knows
At the end of the protocol the Veriﬁer is convinced that m ∈ [−q3, q3].
– The Prover selects α ∈R Zq3, β ∈R Z∗
N such that c = Γ mrN mod N 2, where q is the order of the DSA group.
N , γ ∈R Zq3 ˜N and ρ ∈R Zq ˜N .
1 hρ
1 hγ
The Prover computes z = hm
The Prover sends z, u, w to the Veriﬁer.
2 mod ˜N , u = Γ αβN mod N 2, w = hα
– The Veriﬁer selects a challenge e ∈R Zq and sends it to the Prover.
– The Prover computes s = reβ mod N , s1 = em + α and s2 = eρ + γ and sends s, s1, s2 to the
– The Veriﬁer checks that s1 ≤ q3, u = Γ s1sN c−e mod N 2 and hs1
2 z−e = w mod ˜N .
2 mod ˜N .