PostgreSQL Tutorial
The PostgreSQL Development Team
Edited by
Thomas Lockhart
PostgreSQL Tutorial
by The PostgreSQL Development Team
Edited by Thomas Lockhart
PostgreSQL
is Copyright © 1996-9 by the Postgres Global Development Group.
Table of Contents
Summary......................................................................................................................................i
1. Introduction............................................................................................................................1
What is Postgres?................................................................................................................1
A Short History of Postgres................................................................................................2
The Berkeley Postgres Project..................................................................................2
Postgres95.................................................................................................................2
PostgreSQL...............................................................................................................3
About This Release.............................................................................................................3
Resources............................................................................................................................4
Terminology........................................................................................................................5
Notation..............................................................................................................................5
Y2K Statement....................................................................................................................6
Copyrights and Trademarks................................................................................................6
2. SQL..........................................................................................................................................8
The Relational Data Model.................................................................................................8
Relational Data Model Formalities.....................................................................................9
Domains vs. Data Types..........................................................................................10
Operations in the Relational Data Model..........................................................................10
Relational Algebra...................................................................................................10
Relational Calculus.................................................................................................13
Tuple Relational Calculus.......................................................................................13
Relational Algebra vs. Relational Calculus.............................................................13
The SQL Language...........................................................................................................14
Select.......................................................................................................................14
Simple Selects................................................................................................14
Joins .............................................................................................................16
Aggregate Operators......................................................................................16
Aggregation by Groups..................................................................................17
Having............................................................................................................18
Subqueries......................................................................................................18
Union, Intersect, Except.................................................................................19
Data Definition........................................................................................................20
Create Table...................................................................................................20
Data Types in SQL........................................................................................21
Create Index...................................................................................................21
Create View...................................................................................................22
Drop Table, Drop Index, Drop View.............................................................22
Data Manipulation...................................................................................................23
Insert Into.......................................................................................................23
Update............................................................................................................24
Delete.............................................................................................................24
System Catalogs......................................................................................................24
Embedded SQL.......................................................................................................24
i
3. Architecture..........................................................................................................................26
Postgres Architectural Concepts.......................................................................................26
4. Getting Started.....................................................................................................................28
Setting Up Your Environment..........................................................................................28
Starting the Interactive Monitor (psql)..............................................................................29
Managing a Database........................................................................................................29
Creating a Database.................................................................................................29
Accessing a Database..............................................................................................30
Destroying a Database.............................................................................................31
5. The Query Language............................................................................................................32
Interactive Monitor...........................................................................................................32
Concepts...........................................................................................................................32
Creating a New Class........................................................................................................33
Populating a Class with Instances.....................................................................................33
Querying a Class...............................................................................................................33
Redirecting SELECT Queries...........................................................................................34
Joins Between Classes......................................................................................................35
Updates.............................................................................................................................36
Deletions...........................................................................................................................36
Using Aggregate Functions...............................................................................................36
6. Advanced Postgres SQL Features.......................................................................................38
Inheritance........................................................................................................................38
Non-Atomic Values..........................................................................................................39
Arrays......................................................................................................................39
Time Travel......................................................................................................................40
More Advanced Features..................................................................................................41
Bibliography.............................................................................................................................42
ii
List of Figures
3-1. How a connection is established.........................................................................................27
iii
List of Examples
2-1. The Suppliers and Parts Database.........................................................................................9
2-2. An Inner Join.......................................................................................................................11
2-3. A Query Using Relational Algebra.....................................................................................12
2-4. Simple Query with Qualification........................................................................................14
2-5. Aggregates..........................................................................................................................16
2-6. Aggregates..........................................................................................................................17
2-7. Having.................................................................................................................................18
2-8. Subselect.............................................................................................................................18
2-9. Union, Intersect, Except......................................................................................................19
2-10. Table Creation...................................................................................................................20
2-11. Create Index......................................................................................................................21
iv
Summary
Postgres, developed originally in the UC Berkeley Computer Science Department, pioneered
many of the object-relational concepts now becoming available in some commercial databases.
It provides SQL92/SQL3 language support, transaction integrity, and type extensibility.
PostgreSQL is a public-domain, open source descendant of this original Berkeley code.
i
Chapter 1. Introduction
This document is the user manual for the PostgreSQL (http://postgresql.org/) database
management system, originally developed at the University of California at Berkeley.
PostgreSQL is based on Postgres release 4.2
(http://s2k-ftp.CS.Berkeley.EDU:8000/postgres/postgres.html). The Postgres project, led by
Professor Michael Stonebraker, was sponsored by the Defense Advanced Research Projects
Agency (DARPA), the Army Research Office (ARO), the National Science Foundation (NSF),
and ESL, Inc.
What is Postgres?
Traditional relational database management systems (DBMSs) support a data model consisting
of a collection of named relations, containing attributes of a specific type. In current
commercial systems, possible types include floating point numbers, integers, character strings,
money, and dates. It is commonly recognized that this model is inadequate for future data
processing applications. The relational model successfully replaced previous models in part
because of its "Spartan simplicity". However, as mentioned, this simplicity often makes the
implementation of certain applications very difficult. Postgres offers substantial additional
power by incorporating the following four additional basic concepts in such a way that users
can easily extend the system:
classes
inheritance
types
functions
Other features provide additional power and flexibility:
constraints
triggers
rules
transaction integrity
These features put Postgres into the category of databases referred to as object-relational. Note
that this is distinct from those referred to as object-oriented, which in general are not as well
suited to supporting the traditional relational database languages. So, although Postgres has
some object-oriented features, it is firmly in the relational database world. In fact, some
commercial databases have recently incorporated features pioneered by Postgres.
1
Chapter 1. Introduction
A Short History of Postgres
The Berkeley Postgres Project
Implementation of the Postgres DBMS began in 1986. The initial concepts for the system were
presented in The Design of Postgres and the definition of the initial data model appeared in The
Postgres Data Model. The design of the rule system at that time was described in The Design
of the Postgres Rules System. The rationale and architecture of the storage manager were
detailed in The Postgres Storage System.
Postgres has undergone several major releases since then. The first "demoware" system became
operational in 1987 and was shown at the 1988 ACM-SIGMOD Conference. We released
Version 1, described in The Implementation of Postgres, to a few external users in June 1989.
In response to a critique of the first rule system (A Commentary on the Postgres Rules System),
the rule system was redesigned (On Rules, Procedures, Caching and Views in Database
Systems) and Version 2 was released in June 1990 with the new rule system. Version 3
appeared in 1991 and added support for multiple storage managers, an improved query
executor, and a rewritten rewrite rule system. For the most part, releases since then have
focused on portability and reliability.
Postgres has been used to implement many different research and production applications.
These include: a financial data analysis system, a jet engine performance monitoring package,
an asteroid tracking database, a medical information database, and several geographic
information systems. Postgres has also been used as an educational tool at several universities.
Finally, Illustra Information Technologies (http://www.illustra.com/) (since merged into
Informix (http://www.informix.com/)) picked up the code and commercialized it. Postgres
became the primary data manager for the Sequoia 2000
(http://www.sdsc.edu/0/Parts_Collabs/S2K/s2k_home.html) scientific computing project in late
1992. Furthermore, the size of the external user community nearly doubled during 1993. It
became increasingly obvious that maintenance of the prototype code and support was taking up
large amounts of time that should have been devoted to database research. In an effort to reduce
this support burden, the project officially ended with Version 4.2.
Postgres95
In 1994, Andrew Yu (mailto:PI:EMAIL) and Jolly Chen
(http://http.cs.berkeley.edu/~jolly/) added a SQL language interpreter to Postgres, and the code
was subsequently released to the Web to find its own way in the world. Postgres95 was a
public-domain, open source descendant of this original Berkeley code.
Postgres95 is a derivative of the last official release of Postgres (version 4.2). The code is now
completely ANSI C and the code size has been trimmed by 25%. There are a lot of internal
changes that improve performance and code maintainability. Postgres95 v1.0.x runs about
30-50% faster on the Wisconsin Benchmark compared to v4.2. Apart from bug fixes, these are
the major enhancements:
The query language Postquel has been replaced with SQL (implemented in the server). We
do not yet support subqueries (which can be imitated with user defined SQL functions).
Aggregates have been re-implemented. We also added support for ‘‘GROUP BY’’. The
libpq interface is still available for C programs.
2
Chapter 1. Introduction
In addition to the monitor program, we provide a new program (psql) which supports GNU
readline.
We added a new front-end library, libpgtcl, that supports Tcl-based clients. A sample shell,
pgtclsh, provides new Tcl commands to interface tcl programs with the Postgres95 backend.
The large object interface has been overhauled. We kept Inversion large objects as the only
mechanism for storing large objects. (This is not to be confused with the Inversion file
system which has been removed.)
The instance-level rule system has been removed. Rules are still available as rewrite rules.
A short tutorial introducing regular SQL features as well as those of ours is distributed with
the source code.
GNU make (instead of BSD make) is used for the build. Also, Postgres95 can be compiled
with an unpatched gcc (data alignment of doubles has been fixed).
PostgreSQL
By 1996, it became clear that the name Postgres95 would not stand the test of time. A new
name, PostgreSQL, was chosen to reflect the relationship between original Postgres and the
more recent versions with SQL capability. At the same time, the version numbering was reset
to start at 6.0, putting the numbers back into the sequence originally begun by the Postgres
Project.
The emphasis on development for the v1.0.x releases of Postgres95 was on stabilizing the
backend code. With the v6.x series of PostgreSQL, the emphasis has shifted from identifying
and understanding existing problems in the backend to augmenting features and capabilities,
although work continues in all areas.
Major enhancements include:
Important backend features, including subselects, defaults, constraints, and triggers, have
been implemented.
Additional SQL92-compliant language features have been added, including primary keys,
quoted identifiers, literal string type coersion, type casting, and binary and hexadecimal
integer input.
Built-in types have been improved, including new wide-range date/time types and additional
geometric type support.
Overall backend code speed has been increased by approximately 20-40%, and backend
startup time has decreased 80% since v6.0 was released.
About This Release
PostgreSQL is available without cost. This manual describes version 6.5 of PostgreSQL.
We will use Postgres to mean the version distributed as PostgreSQL.
Check the Administrator’s Guide for a list of currently supported machines. In general,
Postgres is portable to any Unix/Posix-compatible system with full libc library support.
3
Chapter 1. Introduction
Resources
This manual set is organized into several parts:
Tutorial
An introduction for new users. Does not cover advanced features.
User’s Guide
General information for users, including available commands and data types.
Programmer’s Guide
Advanced information for application programmers. Topics include type and function
extensibility, library interfaces, and application design issues.
Administrator’s Guide
Installation and management information. List of supported machines.
Developer’s Guide
Information for Postgres developers. This is intended for those who are contributing to the
Postgres project; application development information should appear in the Programmer’s
Guide. Currently included in the Programmer’s Guide.
Reference Manual
Detailed reference information on command syntax. Currently included in the User’s
Guide.
In addition to this manual set, there are other resources to help you with Postgres installation
and use:
man pages
The man pages have general information on command syntax.
FAQs
The Frequently Asked Questions (FAQ) documents address both general issues and some
platform-specific issues.
READMEs
README files are available for some contributed packages.
Web Site
The Postgres (postgresql.org) web site has some information not appearing in the
distribution. There is a mhonarc catalog of mailing list traffic which is a rich resource for
many topics.
4
Chapter 1. Introduction
Mailing Lists
The Postgres Questions (mailto:PI:EMAIL) mailing list is a good place to
have user questions answered. Other mailing lists are available; consult the web page for
details.
Yourself!
Postgres is an open source product. As such, it depends on the user community for
ongoing support. As you begin to use Postgres, you will rely on others for help, either
through the documentation or through the mailing lists. Consider contributing your
knowledge back. If you learn something which is not in the documentation, write it up and
contribute it. If you add features to the code, contribute it. Even those without a lot of
experience can provide corrections and minor changes in the documentation, and that is a
good way to start. The Postgres Documentation (mailto:PI:EMAIL) mailing list
is the place to get going.
Terminology
In the following documentation, site may be interpreted as the host machine on which Postgres
is installed. Since it is possible to install more than one set of Postgres databases on a single
host, this term more precisely denotes any particular set of installed Postgres binaries and
databases.
The Postgres superuser is the user named postgres who owns the Postgres binaries and
database files. As the database superuser, all protection mechanisms may be bypassed and any
data accessed arbitrarily. In addition, the Postgres superuser is allowed to execute some support
programs which are generally not available to all users. Note that the Postgres superuser is not
the same as the Unix superuser (which will be referred to as root). The superuser should have a
non-zero user identifier (UID) for security reasons.
The database administrator or DBA, is the person who is responsible for installing Postgres
with mechanisms to enforce a security policy for a site. The DBA can add new users by the
method described below and maintain a set of template databases for use by createdb.
The postmaster is the process that acts as a clearing-house for requests to the Postgres system.
Frontend applications connect to the postmaster, which keeps tracks of any system errors and
communication between the backend processes. The postmaster can take several command-line
arguments to tune its behavior. However, supplying arguments is necessary only if you intend
to run multiple sites or a non-default site.
The Postgres backend (the actual executable program postgres) may be executed directly from
the user shell by the Postgres super-user (with the database name as an argument). However,
doing this bypasses the shared buffer pool and lock table associated with a postmaster/site,
therefore this is not recommended in a multiuser site.
Notation
... or /usr/local/pgsql/ at the front of a file name is used to represent the path to the Postgres
superuser’s home directory.
5
Chapter 1. Introduction
In a command synopsis, brackets ([ and ]) indicate an optional phrase or keyword. Anything in
braces ({ and }) and containing vertical bars (|) indicates that you must choose one.
In examples, parentheses (( and )) are used to group boolean expressions. | is the boolean
operator OR.
Examples will show commands executed from various accounts and programs. Commands
executed from the root account will be preceeded with >. Commands executed from the
Postgres superuser account will be preceeded with %, while commands executed from an
unprivileged user’s account will be preceeded with $. SQL commands will be preceeded with
=> or will have no leading prompt, depending on the context.
Note: At the time of writing (Postgres v6.5) the notation for flagging commands is not
universally consistant throughout the documentation set. Please report problems to the
Documentation Mailing List (mailto:PI:EMAIL).
Y2K Statement
Author: Written by Thomas Lockhart (mailto:PI:EMAIL) on 1998-10-22.
The PostgreSQL Global Development Team provides the Postgres software code tree as a
public service, without warranty and without liability for it’s behavior or performance.
However, at the time of writing:
The author of this statement, a volunteer on the Postgres support team since November,
1996, is not aware of any problems in the Postgres code base related to time transitions
around Jan 1, 2000 (Y2K).
The author of this statement is not aware of any reports of Y2K problems uncovered in
regression testing or in other field use of recent or current versions of Postgres. We might
have expected to hear about problems if they existed, given the installed base and the active
participation of users on the support mailing lists.
To the best of the author’s knowledge, the assumptions Postgres makes about dates
specified with a two-digit year are documented in the current User’s Guide
(http://www.postgresql.org/docs/user/datatype.htm) in the chapter on data types. For
two-digit years, the significant transition year is 1970, not 2000; e.g. 70-01-01 is interpreted
as 1970-01-01, whereas 69-01-01 is interpreted as 2069-01-01.
Any Y2K problems in the underlying OS related to obtaining "the current time" may
propagate into apparent Y2K problems in Postgres.
Refer to The Gnu Project (http://www.gnu.org/software/year2000.html) and The Perl Institute
(http://language.perl.com/news/y2k.html) for further discussion of Y2K issues, particularly as it
relates to open source, no fee software.
Copyrights and Trademarks