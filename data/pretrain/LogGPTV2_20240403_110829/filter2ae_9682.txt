## 0x00 前言
该漏洞来源于一个真实案例。尽管在最初的攻击中并未利用到此漏洞，但在对thinkcmf版本进行审计时发现了它，可以说是一种巧合。thinkcmf已经很久没有更新了，根据GitHub上的记录，最后一次更新是在四年前，即2014年。

## 0x01 前台SQL注入

### 漏洞描述
前台登录方法存在SQL注入风险。thinkcmf基于ThinkPHP 3.2开发，具体问题出现在`application/User/Controller/LoginController.class.php`中的`dologin`方法。通过使用`extract`函数，可以将`$where`数组直接传递给`where`方法，未经过滤的参数会导致表达式注入。

### 利用方式
由于验证码的存在，编写批量脚本较为困难，但可以通过引入打码工具解决。成功注入后，下一步是尝试登录后台。为了实现这一目标，需要了解thinkcmf管理员密码的加密机制。查看`install/index.php`文件中的`sp_password`方法，可以发现：

- 密码存储格式：`表前缀MD5值的前12位 + 密码MD5值 + 表前缀MD5值的后四位`
- 示例：`c535018ee946e10adc3949ba59abbe56e057f20f883e89af`

知道了加密算法后，可以获取管理员密码的MD5值，并通过碰撞获取实际密码。

### 登录后台后的操作
成功登录后台后，接下来的目标是获取shell。然而，仔细分析thinkcmf的后台代码，似乎并没有直接可利用的地方。

## 0x02 权限验证处的任意代码执行

### 漏洞描述
在权限验证过程中发现了一个潜在的风险点。`application/Common/Lib/iAuth.class.php`中的`check`方法使用了`eval`来执行条件语句。这些条件数据存储在`sp_auth_rule`表的`condition`字段中，在安装时已写入数据库。如果能够修改这些数据，就可以触发任意代码执行。

### 利用方式
前面提到的SQL注入漏洞可以帮助我们修改数据库中的`condition`字段。ThinkPHP 3系列使用PDO作为数据库连接驱动，因此可以利用注入点执行多条SQL语句。例如，可以修改管理员的`user_email`字段或密码哈希值。

#### 触发条件
权限验证由`AdminbaseController`类负责，在其初始化函数中会调用`sp_auth_check`方法。只有低权限用户（非管理员）访问特定URL时才会触发鉴权过程。通过在`sp_auth_rule`表中插入恶意代码并以低权限用户身份访问相应URL，即可执行任意代码。

#### 实际操作
1. 创建一个低权限用户`hack`。
2. 通过SQL注入修改`sp_auth_rule`表中对应URL的`condition`字段，插入恶意代码。
3. 使用`hack`用户登录后台，访问指定URL触发代码执行。

示例payload:
```sql
where[id][0]=exp&where[id][1]=in (1);update sp_auth_rules set `condition`='1);phpinfo();die();//' where id=30#
```

请求：
```http
http://127.0.0.1/index.php?g=Portal&m=AdminPage&a=add
```

### 相关思考
进一步研究发现，这种权限验证逻辑源自ThinkPHP框架本身。因此，在使用TP3框架且存在注入点的情况下，应特别注意此类任意代码执行的风险。

## 0x03 总结
整个利用流程如下：
1. 通过前台SQL注入获取后台权限（获取管理员密码或修改密码哈希值）。
2. 登录后台并创建低权限用户。
3. 再次利用SQL注入向`sp_auth_rule`表中插入恶意代码。
4. 以低权限用户身份登录后台，访问包含恶意代码的URL，触发任意代码执行。

在实际情况中，如果已有低权限用户，则可以直接跳过创建用户的步骤。总体而言，虽然仍需登录后台才能完成攻击，但这种利用方式展示了如何巧妙地结合多个漏洞实现最终目标。