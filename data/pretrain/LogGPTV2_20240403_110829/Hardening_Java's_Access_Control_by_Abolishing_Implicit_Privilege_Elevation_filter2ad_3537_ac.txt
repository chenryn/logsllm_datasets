retrieving
implement
information
required to be
stack, which is
functionality to retrieve information about
call
able
There is, however, one common property shared by
shortcuts. They all make
all methods
the
use of
current
to
check constraints on speciﬁc callers on the stack. The
task
not
delegated to helper methods. By manually reviewing
shortcuts we already knew, we found that they either use
or
sun.reflect.Reflection.getCallerClass
java.lang.SecurityManager.getClassContext.
We thus implemented a simple static analysis using the Soot
framework [17] to ﬁnd all methods that contain call sites
for these two methods. We only used the Soot framework
to locate the speciﬁc bytecode instructions conveniently. The
analysis does not need a call graph nor does it consider data
ﬂows. One could as well have used a text-based matching
tool such as grep, but using Soot helps avoiding mistakes
in the process. Our analysis yielded 86 candidate methods
in total, which we reviewed manually to ﬁnd the subset of
methods that actually implement a shortcut. These are the
results:
• Out of the 86 candidates, 35 methods do indeed im-
plement a shortcut. They check constraints on the call
stack and skip a permission check if these constraints are
satisﬁed.
• Further 6 methods do not implement shortcuts in the strict
sense, because they do not call a check* method on the
SecurityManager to trigger stack inspection under
any circumstances. Because of this, we consider them to
be out of scope. They are noteworthy, however, because
they deny access to functionality if the immediate caller’s
classloader is unable to load a speciﬁc class involved
in the desired action. Such code implements a kind of
undocumented poor man’s approach to access control.
implement a shortcut
in
the strict sense, but it checks if the immediate caller’s
classloader is the bootstrap classloader, and throws a
SecurityException otherwise.
• One method does also not
• The remaining 44 methods are caller-sensitive, but use
stack inspection for purposes other than shortcuts.
We matched our ﬁndings with the relevant sections in the
JSCG, 9.8, 9.9, 9.10, which provide a list of 75 caller-sensitive
methods that have to be used with special care. The methods
listed in JSCG constitute a subset of the 86 candidate methods
we found by static analysis. The additional 11 methods that
we found, which are not covered by the relevant sections in
the JSCG, include 9 methods that do not perform permission
checking, 1 deprecated method, and 1 method which is part
of sun.misc.Unsafe, and thus not ofﬁcially supported.
From this, we conclude that the JSCG sufﬁciently covers the
current set of methods that implement shortcuts. For 41 out
of the total 75 methods included in the JSCG, we found
no indication for shortcuts. In most cases,
these methods
implement dynamic access checks in the context of reﬂection,
or provide dynamic loading capabilities involving the imme-
diate caller’s classloader. Both is caller-sensitive behavior that
requires special attention from developers, and might even
bring along a potential for vulnerabilities, which is also the
reason why they are discussed in the JSCG. We leave these
methods out of the scope of this paper, since our focus is
on shortcuts, but may be worth investigating further in future
work.
B. Removing shortcuts
Out of the 35 methods that we identiﬁed to implement a
shortcut to bypass proper permission checking, we manually
modiﬁed 32 of these methods to remove any conditionals
that involved properties of the call stack, which may have
prevented a permission check from being performed. We found
that most shortcuts use getCallerClass to retrieve the
immediate caller, and check if its deﬁning classloader matches
a speciﬁc instance, or is null, i.e., the bootstrap classloader.
By removing shortcuts, we transformed 28 out of these 32
methods from caller-sensitive to caller-insensitive methods,
guarding their functionality by a well-deﬁned permission
check. We left the remaining 4 methods caller-sensitive after
modiﬁcation because —apart from their original shortcuts—
they implement additional functionality, such as visibility
checks in the context of reﬂective access. It
is important
to stress that caller-sensitivity and the notion of shortcuts,
as we deﬁned it, are two separate concepts: Our notion of
shortcuts always implies caller-sensitivity but the inverse does
not always hold.
As stated above, we removed shortcuts from only 32 out of
35 methods that we found. One of the three remaining meth-
ods (SecurityManager.checkMemberAccess) we de-
cided to remove entirely from the code base, because it is
deprecated and not used by any other method in the JCL.
and
two
The
other
remaining methods,
Class.-
Class.newInstance,
getDeclaredField
could not be modiﬁed, due to circular dependencies. After an
initial attempt to modify them, we encountered errors during
VM initialization, because using either of the two methods
causes a permission check, within which the method itself is
called again, which in turn triggers another permission check,
and so on. In the original code, the shortcuts in the two
methods prevented this call sequence, because, eventually,
newInstance and getDeclaredField would simply
skip the permission check and succeed. We did not further
investigate whether the use of reﬂection in the call sequence
initiated by a permission check is inevitable. At the same
time, we could not come up with a clean solution that would
allow the shortcuts to be removed, without making substantial
changes to the JCL. We thus decided to keep these two
shortcuts and leave all calls to getDeclaredField and
newInstance unmodiﬁed.
1032
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:24:58 UTC from IEEE Xplore.  Restrictions apply. 
C. Adapting all callers
The last step of our proposed solution is to adapt all
immediate calls to modiﬁed methods. In the original code,
many of the JCL’s callers are able to access functionality
guarded by a shortcut, even when there is untrusted code on the
call stack, because the shortcut bypasses the permission check.
After modiﬁcation, however, the same call sequence would
fail because the permission check now executes, taking into
account the full call stack. To retain backward compatibility
whenever possible, all immediate calls to modiﬁed methods
have to be wrapped into a privileged action. As we will
explain, the calls to modiﬁed methods have to be adapted
differently, depending on whether the modiﬁed method is still
caller-sensitive after modiﬁcation, or not.
Modifying calls to the 28 methods that lost their caller-
sensitivity through modiﬁcation works as follows. First, we use
static analysis to ﬁnd all immediate calls to any of the modiﬁed
methods. For this, we adapted and reapplied the approach used
to locate shortcuts as described above. As a result, we found
1,399 calls in the JCL that required a modiﬁcation. For 1 out
of the 28 modiﬁed methods, we were not able to ﬁnd even
a single caller within the JCL itself, which means that our
transformation regarding this method is already complete at
this point.
We then used Javassist [18] to implement a bytecode
modiﬁcation tool that automatically adapts all calls. It adds
one or more private helper methods to each calling class, each
of which instantiates a privileged action that wraps the original
target method call and then calls doPrivileged. Next, the
modiﬁcation redirects all calls targeting a modiﬁed method to
one of the newly added helper methods. Note that each helper
method wraps a call to one speciﬁc modiﬁed method only,
which is why multiple helper methods are added to calling
classes that target more than one modiﬁed method. Privileged
actions have to be implemented in separate classes (in source
code one would normally use an anonymous inner class),
but instead of adding one individual implementation for each
generated helper method, we added a small set of commonly
accessible privileged actions to java.lang.Class, shared
among all helper methods. By this, we avoid having to add
hundreds of additional classes, which would bloat the code
base.
The calls
We decided to use bytecode modiﬁcation instead of source-
code modiﬁcation, because at the time we did our experiments,
we were not aware of any publicly available source-code
modiﬁcation libraries that would have allowed us to perform
the required modiﬁcations in an automated fashion.
that
remained
caller-sensitive
shortcuts had to
be modiﬁed differently. This is because those methods
vary their behavior depending on the immediate caller,
which (as can be seen in ”case 2” in Listing 4) would
be the run method of a privileged action if apply-
ing the modiﬁcation we applied before.
In the JCL
only AtomicReferenceFieldUpdater.newUpdater
the 4 methods
removal of
to one of
the
after
// case 1: without modification
CallerClass.method // immediate caller
AtomicReferenceFieldUpdater.newUpdater
// case 2: with "regular" bytecode modification
CallerClass.method
CallerClass.x_newUpdater
AccessController.doPrivileged
PrivilegedActionImpl.run // immediate caller
AtomicReferenceFieldUpdater.newUpdater
// case 3: alternative modification strategy
CallerClass.method
CallerClass.x_newUpdater
AccessController.doPrivileged
PrivilegedActionImpl.run
CallerClass.x_getUpdater // immediate caller
AtomicReferenceFieldUpdater.newUpdater
Listing 4. Illustrating the effects the different modiﬁcation strategies have on
the call stack
We
two
private
added
applied
implementing
a modiﬁcation
out of the 4 methods is actually called and this single method
has only 3 callers, i.e., we only have to modify 3 callers. It
seemed reasonable to modify these 3 callers manually.
a
form
see ”case 3” in Listing 4. First,
of double dispatch,
we manually
helper methods,
x_newUpdater and x_getUpdater, to each calling class
of
AtomicReferenceFieldUpdater.newUpdater.
x_newUpdater instantiates a privileged action, whose run
method calls x_getUpdater. x_getUpdater,
in turn,
calls AtomicReferenceFieldUpdater.newUpdater.
Finally, we replaced all original calls to newUpdater by
calls to x_newUpdater. The effects of this alternative
modiﬁcation strategy on the call stack can be seen in
”case 3” in Listing 4. By routing the call
sequence
instead of immediately calling
through x_getUpdater,
newUpdater in the privileged action, we ensure that the
immediate caller of newUpdater is the original calling
class, not the privileged action. As newUpdater is caller-
sensitive to the calling class and not
the speciﬁc calling
method it behaves appropriately, i.e., as before.
D. Effects on security and maintainability
The technique presented above removes shortcuts within
methods of the JCL. The beneﬁts of these changes are twofold.
First, the resulting JCL code is easier to maintain, and in
consequence it will be harder to introduce new confused-
deputy vulnerabilities in future versions of Java. Second, some
of the existing attack vectors that depend on shortcuts will
become infeasible.
Enabling security-preserving code evolution
The beneﬁt w.r.t. facilitating security-preserving evolution
of the JCL were already highlighted in the background section
by discussing the code in Listing 1 and the result of the
adaptation by our approach in Listing 2. The desired positive
effect of our conversion is that now, if an unprivileged attacker
calls openFileFromRoot, the permission check will fail,
because Util, having been added later, was not subject to
our modiﬁcation. This prevents the previous vulnerability.
1033
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:24:58 UTC from IEEE Xplore.  Restrictions apply. 
By trading implicit elevation of privileges with shortcuts for
explicit privilege elevation with doPrivileged as described
above, we retain backward compatibility to a large extent. This
has, however, a downside: It will retain confused-deputy vul-
nerabilities that already existed in the code base at the time of
its modiﬁcation. Consider again the example code in Listing 1.
If the vulnerability caused by Util is already part of the code
base at the time we apply our program transformation, the
call to openFile in openFileFromRoot will be wrapped
in a privileged action, just like the call in readProp. As
a result, the openFileFromRoot method will continue to
expose critical functionality to attackers even after program
transformation.
It is not easy to decide which method calls under privileged
regime are legitimate, and which ones represent a vulnerability.
With the current proof-of-concept implementation of our
approach, we reduce the possibilities of potentially illegitimate
privilege elevation to explicit ones only, but still leave the
identiﬁcation of insecure uses of critical functions out of the
scope. In the future, we plan to extend our proposal by a
security review of all callers and a decision on a case-by-case
basis whether the introduced explicit privilege elevation with
doPrivileged is appropriate or not. By mapping implicit
elevations to explicit ones, the transformation presented in
this paper does facilitate such an analysis - as we already
argued, the explicit privilege elevations are easier to identify
and reason about.
Rendering existing attack vectors infeasible
The good news is that even in its current state of the devel-
opment, our transformation effectively renders existing attack
vectors infeasible. This is, because a large number of attacks
that exploited previously shortcut-containing methods did not
call these methods directly (like Util), but rather by abusing
an insecure use of reﬂection or invokedynamic [19]. The
proposed transformation does not modify such kinds of calls,
as doPrivileged-wrappers are only placed around direct
method calls. After the shortcuts are removed, any such attack
will therefore be successfully thwarted: The permission check
in the reﬂectively called method, from which the shortcut was
removed, will now trigger a stack walk, preventing the action
if the call sequence was initiated by untrusted code.
As already mentioned, we found four examples of such
kinds of attacks in a sample set provided by Security Ex-
plorations [12]. They leverage vulnerabilities involving the
insecure use of reﬂection to call shortcut-containing methods
through a trusted system class. We veriﬁed through debugging
that performing permission checks instead of taking the short-
cuts will result in access-control exceptions, thus effectively
preventing these attacks. Interestingly, after Security Explo-
rations reported three of those vulnerabilities to the vendor,
a ﬁx was released that did not reliably prevent the attacks.
In fact, it was ﬂawed in many ways, but most importantly,
because it still allowed an attacker to make use of shortcuts
and other caller-sensitive methods [20]. Consequently, Security
Explorations was able to still run three of the four exploits
successfully by only changing them slightly.
In conclusion, these ﬁndings (a) demonstrate that our pro-
posed solution does increase the security of the Java platform,
and (b) also support our claim that shortcut-containing code