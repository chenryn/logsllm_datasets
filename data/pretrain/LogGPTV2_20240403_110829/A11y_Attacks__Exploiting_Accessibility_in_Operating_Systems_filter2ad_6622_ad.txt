AT-SPI. The security checks at the OS level are incomplete. For
a password box, there exists an API call, gettextvalue(), on
the Linux Desktop Testing Project (LDTP, a wrapper over AT-SPI
and ATK). It throws a “Not Implemented” exception when called,
meaning that reading passwords through this API is unavailable.
However, AT-SPI missed security checks on a critical accessibility
function of a password box: copytext(). Although physically
or synthetically pressing Ctrl-C does not copy the value of a pass-
word box, copytext() from AT-SPI does copy the plaintext of
a password to the clipboard. The clipboard then can provide the
plaintext content of a password. Figure 10 shows a sudo dialog that
is vulnerable to this attack. Once the sudoer’s password is acquired
in this manner, malware can easily gain root privileges.
4.4.3 Android
While Android prohibits reading of password content from its ac-
cessibility service, this can be disabled via user preferences. In
conjunction with the vulnerability of input validation (attack #10),
this restriction can easily be bypassed.
Attack #12: keylogger on Android. Although Android provides
protections for accessing the plaintext of a password, incomplete
protections at the OS-level lead to a vulnerability. Once an app is
enabled as an AT (see Attack #10 for detail), the app can change
any settings on the device without user consent. Android provides
an option called “Speak passwords” in its accessibility settings. If
enabled, keystrokes on a password box are delivered through the text-
to-speech (TTS) processor. We register malware as a TTS output
application. Once registered, the malware can receive password
contents via the OS-level accessibility service.
5 Discussion
In this section, we explain how accessibility libraries are making
it possible to implement our attacks, discuss the limitations of our
attacks, analyze the root causes of the vulnerabilities, and consider
open problems for future work.
5.1 Complexity of Accessibility Attacks
As we mentioned in section §2, accessibility libraries provide three
capabilities: 1) obtaining events representing UI change, 2) provid-
ing a way of programmatically probing/accessing UI widgets, and
3) synthesizing inputs to UI widgets.
With these functionalities, an attacker can create malware capable
of performing successful attacks with a degree of relative ease when
compared to other non-AT methods that achieve the same ends. As
an example, we will describe how the “Password Eye” attack (#3)
can be implemented using accessibility libraries. To achieve the
“Password Eye” attack, malware needs to: 1) detect when the user
types a password, 2) identify the UI “eye” and click on it, and 3) lo-
cate the password ﬁeld to grab its text in a screenshot. To determine
whether the user is typing password, we can use the ﬁrst capability
of the accessibility libraries to keep track of which UI component
is currently focused. In particular, on the Windows platform, this
can be easily achieved by registering an event handler in the plat-
form’s accessibility framework that receives the focused UI element
at any change of focus. After being handed a focused element, we
can check whether the element is a password box with an “eye” by
assessing its properties reported by the accessibility libraries. For ex-
ample, a TRUE value of isPassword property indicates a password
box. Once we determine that the focused element is a password box,
we can use the second capability of the accessibility libraries to get
the “eye” button. In particular, since we know the relative position
of the focused text box and the “eye” button, we can walk the UI
widget tree provided by the accessibility library and calculate the
position of the “eye”. Then, we can use the third capability to click
it. Finally, the handle to the focused password box we obtained
in the ﬁrst step can also be used to retrieve the location of the box
on screen, and allow us to grab the actual password typed from a
screenshot. A point worth noting here is that developing attacks
using accessibility libraries is very similar to how one manipulates
DOM (Document Object Model) objects using Javascript in a web
page.
One may point out that the same attack can be achieved on the
Windows platform by sending traditional Windows Messages (such
as WM_CLICK), or using tools such as AutoIt. However, we argue
that the use of the accessibility library greater ease and reliability.
In particular, without the ﬁrst capability of the accessibility libraries,
one may need to constantly probe the current state of UIs to deter-
mine if the user is typing a password. Secondly, while it maybe
trivial to use a hardcoded coordinate to click the “eye” button in a
testing environment such as AutoIt, this strategy will be very fragile
in a real attack; factors such as variation in screen size and resizing/-
moving of the target window may break the hardcoded approach in
a real attack. Using hardcoded locations to extract a password from
screenshots will face a similar issue. Even though it may be possible
to reliably implement our attacks without accessibility libraries, this
implementation would be more complex and require greater eﬀort
on the part of the author.
5.2 Limitations of the Attacks
Since attacks through accessibility libraries perform actions over
user interfaces, they have an inherent limitation in that they are not
stealthy. For example, if the target application is running in the
foreground when an attack is unfolding, the user may recognize
visual cues of the attack, such as button presses, opening of a new
UI window, etc. Furthermore, attacks via voice commands play
sounds, and are thus audible; or they fail if the speaker is turned oﬀ.
However, we argue that these attacks can be launched in a stealthy
way. First, malware can detect whether the user is using the device
or not. For desktop machines, the presence of a user can be detected
by monitoring physical keystroke or mouse movement. Malware
can exploit a time period when the user is absent to launch UI-
intensive attacks. If necessary, the malware can blank the screen
when launching the attack, because screen sleep after some period
of non-use is a natural and expected behavior of the system. For
mobile devices, prior researches [17, 31, 35] discussed how to track
the user’s behavior using an app on the device. With the help of
various sensors, such as the camera, face proximity detector, GPS
location, accelerometer, etc., malware can determine when the user
is not watching the screen, away from the device, or when the device
is in the user’s pocket. It can then launch an attack without being
exposed.
Second, UI actions can be delivered in the background for some
platforms. Thus, an attack can be carried out even when the user is
actively using the device. In Windows, once a handle to a UI widget
is obtained while it is in the foreground, it can still be manipulated
111even when it is in the background or minimized. In Linux, probing
the UI of a minimized application is possible. Furthermore, in the
worst case, malware can move a window to nearly oﬀ the screen, so
that the user does not notice any UI change. In our experiment, if
any pixel of an app is visible on the screen7, there is no limitation
on probing or performing actions on it.
Third, it is possible to make the attacks on natural language user
interfaces stealthy with the help of hardware. Common audio de-
vices such as the Realtek HD Audio device and other sound card
devices’ drivers provide functionality called Stereo Mix. Stereo
Mix sends the output of system sound to an internal microphone
input. Enabling this functionality does not require any special priv-
ilege. Malware can play audio internally to deliver text-to-speech
audio to a natural language user interface. The attack succeeds
without outputting audio to speakers, and also works when there is
no speaker device at all.
Finally, our experience with OS vendors shows that these threats
will be taken seriously.
In May, 2013, before presenting an at-
tack [19] that takes advantage of private APIs for synthesizing
touches and taking screenshots on iPhone, we informed Apple of
our attack. In Aug, 2013, the exploited vulnerabilities were removed
from the then newly-released iOS 7.
5.3 Root Causes, and Design Trade-offs
We strongly believe that to fundamentally eliminate a11y-related
vulnerabilities, a new architecture for providing accessibility fea-
tures is necessary. However, proposing such an architecture is out of
the scope of this paper; instead, we present the ﬁndings of our root
cause analysis to illustrate why security checks spread across the AT,
OS, and application tend to fail, and to show some of the trade-oﬀs
taken in the current implementation of accessibility features.
The ﬁrst identiﬁed root cause is the emphasis of availability/com-
patibility of a11y support in all the studied systems. In every case
we have studied, native UI widgets include logic to handle requests
from accessibility libraries, and UI widgets provided by OS are
usually built to reuse the same interfaces/channels to handle both
real user inputs and a11y inputs. As a result, it is very hard for an
application to distinguish a11y inputs from real user inputs. This
design choice enables many attacks by accepting and processing
synthesized input as if it is a real input (A28). For instance, in An-
droid, physically tapping an UI widget with a ﬁnger will invoke the
performClick() function. Equally, on an a11y request, the same
performClick() function is invoked (see Example 1 in Appendix
for details). In Windows, just like user real input, clicks generated
by UIAutomation are delivered as a Windows Message WM_CLICK.
Similarly, for Ubuntu and iOS, a11y requests take the same path as
I/O requests within the UI widget. While this means all applications
that use the native UI widgets automatically and naturally work with
the requests from accessibility libraries, such design also imposes
a default security policy that makes every widget available to all
ATs. As we can see in attack #2 and #3, this is too permissive a
policy. Furthermore, in all the studied systems, if the application/UI
developers were to instead implement their own policy regarding
how an application should process requests from accessibility li-
braries, they would have to implement their own UI widgets (usually
by “subclassing” the native ones), and this comes with a non-trivial
cost.
Second, from both technical and economic perspectives, it is
challenging to perform complete validation and authentication for
certain inputs introduced by AT. As a result, new attack vectors
7For example, only one pixel of the window is visible, while all
others are invisible.
8Please refer to section §3.1 New Attack Paths for details.
become available due to missing security checks on processing
input (A2) and output (A3) requests from ATs or accessibility li-
braries. For example, in attack #11, simply pressing Ctrl-C will call
gtk_entry_copy_clipboard in which there is a security check
for preventing text in a password ﬁeld from being copied (see Ex-
ample 2 in Appendix for details). However, a diﬀerent function
copytext() will be executed in ATK, which takes a diﬀerent exe-
cution path without security checks, potentially leading to password
leakages. We suspect that the ATK code was added to the OS by a
group of developers who were not aware of the principles of input
validation and complete mediation, or that the ATK code was added
to the OSs only recently and has thus not been through rigorous
security code review and testing when compared to older portions
of the OS.
There are also technical and economic reasons for a lack of valida-
tion and authentication. For example, for the cases of attack #1 and
#9, the AT needs to check whether the voice input actually comes
from a real user, and also needs to further authenticate the authorized
user. Voice based validation and authentication requires non-trivial
technical support, with potentially high research and development
costs.
Finally, to improve the usability of ATs, OSs usually have weak
access control on accessibility libraries; while this makes the instal-
lation and use of ATs (their intended purpose) easy, it is not a good
security practice. In particular, accessibility libraries can usually be
accessed by any application on a system. For example, in Windows,
iOS 6, and Linux, any program can be an AT without any autho-
rization. This also opens paths for attack so that any (malicious)
program can abuse accessibility functionalities to launch the attacks
described in this paper. The exception is Android; it has a setup
menu for enabling an app’s use of the accessibility library, though
this check is only performed at initial app setup.
5.4 Recommendations and Open Problems
Based on the root cause analysis in Section §5.3, we present rec-
ommendations on how to alleviate (if not eliminate) the security
risks created by a11y support. Our recommendations are intended
to work with the current architecture for supporting accessibility
features, and thus are limited by the inherent diﬃculties that come
with this architecture; nonetheless, we believe they will help the
community to improve security for a11y before the introduction of
a complete a11y security policy occurs. We will also discuss some
open problems involved in implementing these recommendations.
Our ﬁrst recommendation is to have ﬁne-grained access control
over which program can access speciﬁc functionality of the accessi-
bility library. From our study, we ﬁnd that both Linux and iOS have
no such access control at all, while Windows allows all programs
to use the accessibility library to control/read the content of any
other program with the same integrity level. Android appears to
be the only system that has access control policy speciﬁc for the
accessibility library: the user has to speciﬁcally grant the AT the
privilege to use the accessibility library. However, once this privi-
lege is granted, the AT has full access to all the capabilities of the
accessibility library. In many cases, this violates the principle of
least-privileged access. For example, a screenreader will only need
to read the content of other apps through the accessibility library,
but it does not need to be able to interact with other apps. Based on
this observation, we recommend the privilege of using the accessi-
bility library be at least split into two, one for reading the content of
other apps and one for the more privileged capability of interacting
and controlling other apps. While this may present an extra hurdle
for users who need AT, it will only incur a one-time set up cost,
112which we feel is an acceptable trade-oﬀ for the extra security against
misuse of the accessibility library.
Our second recommendation is to provide mechanisms for a
UI developer to ﬂag how diﬀerent widgets in their UI will handle
various requests from the AT, rather than requiring the UI developer
to handle this task themselves. For example, in many UI libraries, a
developer can ﬂag a text ﬁeld as a password ﬁeld, and the underlying
logic of the UI will make the content in the ﬁeld invisible to both
the display and the ATs. However, this generally appears to be the
only instance of such a ﬂag, and it only applies to text ﬁelds. We
believe more such ﬂags should be available to specify various a11y
related security policies, and such ﬂags should be made applicable
to various kinds of widgets (e.g. attack #2 and #3 can be easily
eliminated if a security ﬂag is applicable to buttons). As future
work, we will study what kind of a11y related security policies UI
developers usually need to specify, and what language features are
needed for specifying such policy as attributes of widgets in the UI.
Our ﬁnal recommendation can be considered a new security com-
ponent in the current a11y architecture, and can signiﬁcantly limit
the damage caused by exploitation of a11y-related vulnerabilities.
We propose to extend accessibility support to user-driven access
control mechanisms like UAC in Windows or Remote View in iOS.
While this recommendation may not be directly derived from our
root cause analysis, we believe it will fundamentally eliminate many
a11y related security issues discussed in this paper. In particular,
OS vendors should develop versions of access control mechanisms
to support various disabilities. For example, for visually impaired
users, the system can read out (through the speaker) the message
seeking permission, and have the user conﬁrm or abort by clicking
the “F” or “J” button on the keyboard (which are tactilely diﬀerent
from all other keys on the keyboard), and for the users who lack
ﬁne motor skills, the permission granting can be driven by voice
recognition. We note that while this approach is not general enough
to support the need for all users with diﬀerent kinds of disabilities, it
will signiﬁcantly improve the security for all users that are covered.
Furthermore, in the case of voice recognition, the introduction of
a mechanism speciﬁcally designed for seeking vocal permission
may signiﬁcantly simplify the task of authenticating user input (only
“yes” or “no” need be veriﬁed, rather than performing general voice
recognition), and thus move the burden of performing voice recogni-
tion from the AT developer to the OS vendor (who may have more
resources to research and develop a mechanism that is robust against
attack #1 and #9).
Finally, we acknowledge that our analysis requires signiﬁcant
manual eﬀort and reverse engineering work and thus is not exhaus-
tive. We will leave it as an open problem to design systems that can
automatically ﬁnd a11y related vulnerabilities. We believe this will
be a challenging problem for the several reasons. First, automatically
detecting a11y functions and analyzing their related vulnerabilities
requires whole system analysis. Since an a11y request is regarded
as an I/O event, it is processed asynchronously. As a result, it is very
hard to ﬁnd entry points. The complicated execution of a11y logic
extends to many diﬀerent low-level modules, which usually make
use of many (function) pointers. Proprietary OSs do not provide
source code, and so researchers can only perform analysis with the
compiled binary, which makes the task even harder. Second, unlike
general programming errors, conﬁrming a11y related vulnerabilities
requires a deep understanding of the semantics of an application,
which signiﬁcantly limits the scalability of such analysis. We hope
that our work can motivate further studies toward this direction.
6 Related Work
Attacks on Windows. In 2007, it was reported that an attacker