### Signature Matcher
The generated code is a C++ class that extends one of the parser superclasses. The class definition is split into two files, `myparser.h` and `myparser.cc`, which together specify the generated parser subclass.

### 5.2 Parser Classes
Generated C++ classes for both binary and text parsers share a similar structure but differ in their interaction with matching primitives. We have optimized the layout and performance of this code, using inlined functions and macros to reduce unnecessary function call overhead. For example, we use a bit vector to store the expected state set during deployment.

For string matchers, we utilize the `sfutil` library from Snort, which efficiently implements the Ahoâ€“Corasick (AC) algorithm. Since constructing a keyword trie for the AC algorithm can be time-consuming, we generate a separate reusable class containing the pre-built AC trie. Our text matcher is not tightly coupled to this specific multi-string matching implementation; we have also prototyped it with the `libSpare` AC implementation.

We use `binpac` to generate a binary traverser for our parsers. The compiler expects a `binpac` specification for the binary protocol, including all record types and basic analyzer, connection, and flow types. We then use the `refine` feature of `binpac` to embed extraction functions and callbacks into our parser. Since `binpac` handles simple extractions automatically, additional processing code is often unnecessary. Similar to the AC algorithm for text parsers, the binary parser is not heavily tied to the binary traversal algorithm or implementation. For some protocols, we have developed hand-coded replacements for `binpac` binary traversal.

### 5.3 Binary Traversal-Optimized Binpac
We have made several modifications to the `binpac` parser generator to enhance its performance for binary traversal. The primary enhancement is a change in the default model for in-memory structures. Originally, `binpac` allocated a C++ class for each non-primitive type, leading to an excessive number of `new` calls. To address this, we modified `binpac` to pre-allocate all non-primitive types in a single object, using the `datauint` type to store possible subtypes. We added an `init(params...)` function to each non-primitive type, which contains the same code as the constructor and is called wherever a new object would have been created. This function accepts any arguments the constructor takes, allowing fields to be propagated between objects. We restrict `binpac` specifications to pass only primitive types between objects, which, while reducing compatibility with existing specifications, is easily adjusted.

Some objects in `binpac` must be specified using a pointer to a dynamically created object and cannot be pre-allocated. For example, in the Bro DNS `binpac` specification, a DNS name is composed of DNS labels, and a DNS label type may contain a DNS name object if the label is a pointer to another name. This circular dependency is not possible with statically sized classes. We added the `&pointer` attribute modifier to the `binpac` language to allow authors to mark objects that must be dynamically allocated.

Finally, we modified `binpac` to handle arrays of objects more efficiently. The original version created a vector for each array and stored each element separately. Since binary traversal only needs to access data as it is being parsed, we eliminated the vector types and changed `binpac` to store only the current element using a pre-allocated object. If the author needs to store data from each element, they must explicitly store it outside of `binpac` in the VESPA parser class using a handler function.

### 6 Evaluation
We evaluated VESPA with vulnerabilities in both text and binary protocols, implementing matchers for HTTP, DNS, and IPP. We focused on scenarios where traditional exploit signatures would fail. Like Cui et al. did with GAPA, we found the process of writing a vulnerability signature for a protocol similar to writing one for a file format. Thus, we used our system to develop a binary parser for the Windows Metafile Format (WMF).

Our experiments were conducted on an Ubuntu 7.10 Linux system with a dual-core 2.6 GHz AMD Athlon 64 processor and 4GB of RAM. We tested HTTP and DNS on real traffic traces from the UIUC Coordinated Science Laboratory network, collected WMF files from freely available clipart websites, and used a small set of representative messages for IPP. We repeated the trace tests 10 times and processed the IPP messages 1 million times to normalize timing perturbations, showing the standard deviation with error bars in the charts.

### 6.1 Micro-benchmarks of Matching Primitives
To evaluate the performance of fast string matching primitives, we implemented our parser using two different AC algorithm implementations: `sfutil` from Snort and `Spare Parts`. We compared their performance in searching for the same strings as our vulnerability matcher, without control logic or constraint checking. We found that for either AC implementation, the performance of a basic HTTP vulnerability matcher was very close to that of the string matching primitive. If the vulnerability signature is simple enough to be expressed as a string match, our system matches it with comparable performance to a pattern-based IDS.

### 6.2 Signature Matching Performance
We evaluated the throughput of our vulnerability signature matching algorithms against the `binpac` parser generator. `Binpac` is the most efficient freely available automated protocol parser generator. We added vulnerability constraint checking to the `binpac` protocol specifications. In the following sections, we describe the protocols and vulnerabilities tested and show the results in Figure 3.

#### HTTP/IPP
The Common Unix Printing System (CUPS) illustrates design choices that complicate exploit-signature writing. The vulnerability in CVE-2002-0063 occurs due to the way the Internet Printing Protocol (IPP) specifies textual key-value pairs, allowing attribute lengths to vary. CUPS reads the specified number of bytes into a buffer, but the buffer is only 8192 bytes long, enabling an attacker to overflow the buffer and execute arbitrary code. A signature for this attack must check that each attribute length is less than 8192. IPP is a binary protocol encapsulated inside chunked HTTP, making it difficult to detect attacks with pattern-based signatures. We also tested the negative content length vulnerability.

We designed a text-based vulnerability signature matcher for HTTP, supporting standard and chunked message bodies. We used VESPA to match the Content-Length vulnerability in CUPS/IPP and extract the message body for further processing. Despite a bug in `binpac`'s buffering system, VESPA was considerably faster than the equivalent `binpac` parser. We also measured the message processing rates for various types of HTTP messages, finding them adequate for a busy website (Table 2).

We implemented a binary IPP vulnerability matcher to be used with our HTTP parser. The VESPA IPP matcher ran four times as fast as the `binpac` version, largely due to improved state management techniques. We also developed a hand-coded replacement for the `binpac` binary traverser, achieving an order of magnitude improvement in performance (Table 1).

**Table 2. HTTP Message Rate**
| HTTP Message Type | Message Rate (msgs per sec) |
|-------------------|-----------------------------|
| Requests          | 370,005                     |
| Responses         | 196,897                     |
| Chunked           | 41,644                      |
| Overall           | 314,797                     |

**Figure 2. Micro-benchmarks**
- **(a)** Comparison between string matching primitive and parsing for HTTP requests
- **(b)** Dynamic memory usage for a single message for standard `binpac` vs. binary traversal

**Figure 3. Throughput Results**
- **DNS**
- **IPP**
- **WMF**