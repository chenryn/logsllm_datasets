signature matcher. The generated code is a C++ class which extends one of the parser
super classes. The class deﬁnition consists of two ﬁles (following the example above,
myparser.h and myparser.cc), which jointly specify the generated parser subclass.
5.2 Parser Classes
Generated C++ classes for both binary and text parsers are structurally very similar, but
differ in how they interface with the matching primitives. We have optimized the layout
and performance of this code. We use inlined functions and code whenever possible.
Many extraction helper functions are actually macros to reduce unnecessary function
call overhead. We store the expected state set with deploy using a bit vector.
For string matchers, we use the sfutil library from Snort [17], which efﬁciently imple-
ments the Aho–Corasick (AC) algorithm [11]. Because the construction of a keyword
trie for the AC algorithm can be time-consuming, we generate a separate reusable class
which contains the pre-built AC trie. Our text matcher is not strongly tied to this par-
ticular multi-string matching implementation, and we have also prototyped it with the
libSpare AC implementation [18].
We use binpac to generate a binary traverser for our parsers. As input, the com-
piler expects a binpac speciﬁcation for the binary protocol. This should include all the
record types in the protocol as well as the basic analyzer, connection, and flow
binpac types. We then use the refine feature of binpac to embed the extraction func-
tions and callbacks to our parser. Since binpac does simple extractions automatically,
it is often unnecessary to write additional code that processes the ﬁeld before it is as-
signed. Like the AC algorithm for text parsers, the binary parser is not heavily tied to the
binary traversal algorithm or implementation. For a few protocols, we have developed
hand-coded replacements for binpac binary traversal.
5.3 Binary Traversal-Optimized Binpac
We have made several modiﬁcations to the binpac parser generator to improve its per-
formance for binary traversal. The primary enhancement we made is to change the
default model for the in-memory structures binpac keeps while parsing. The original
binpac allocated a C++ class for each non-primitive type it encountered while parsing.
This resulted in an excessive number of calls to new, even for small messages. To alle-
viate this problem, we changed the default behavior of binpac to force all non-primitive
types to be pre-allocated in one object. We use the datauint type in binpac to store
all the possible subtypes that binpac might encounter. To preserve binpac semantics,
we added a new function, init(params...), to each non-primitive type in binpac.
The init function contains the same code as the constructor, and we call it wherever a
new object would have been created. It also accepts any arguments that the constructor
takes to allow ﬁelds to be propagated from one object to another. We restrict binpac
speciﬁcations to be able to pass only primitive types from object to object. While this
166
N. Schear, D.R. Albrecht, and N. Borisov
reduces our compatibility with existing binpac speciﬁcations, it is easy to change them
to support this limitation.
Some objects in binpac must be speciﬁed using a pointer to a dynamically created
object and cannot be pre-allocated. For example, in the Bro DNS binpac speciﬁcation,
a DNS name is composed of DNS labels. A DNS label type also contains a DNS name
object if the label is a pointer to another name. This circular dependency is not possible
with statically sized classes. We added the &pointerattribute modiﬁer to the binpac
language to allow the author to speciﬁcally mark objects that must be dynamically
allocated.
The ﬁnal modiﬁcation we made to binpac was to change the way that it handled
arrays of objects. The original version of binpac created a vector for each array and
stored each element separately. Because binary traversal only needs to access the data
as it is being parsed, we do not need to store the entire array, only the current element.
We eliminated the vector types entirely and changed binpac to only store the current
element in the array using a pre-allocated object. If the author needs to store data from
each element in the array, he must explicitly store it outside of binpac in the VESPA
parser class using a handler function.
6 Evaluation
We evaluated VESPA with vulnerabilities in both text and binary protocols. We imple-
mented matchers for vulnerabilities in the HTTP, DNS, and IPP protocols. We searched
for exploitable bugs in network-facing code, focusing especially on scenarios where
traditional exploit signatures would fail. Like Cui et al. did with GAPA [19], we found
the process of writing a vulnerability signature for a protocol very similar to writing one
for a ﬁle format. Thus, we used our system develop to a binary parser for the Windows
Meta-ﬁle Format (WMF).
We ran all our experiments on an Ubuntu 7.10 Linux (2.6.22-14-x86 64) system with
a dual-core 2.6 GHz AMD Athlon 64 processor and 4GB of RAM (our implementation
is single-threaded so we only utilized one core). We ran the tests on HTTP and DNS on
traces of real trafﬁc collected from the UIUC Coordinated Science Laboratory network.
We collected WMF ﬁles from freely available clipart websites. Since we did not have
access to large volumes of IPP trafﬁc, we tested using a small set of representative
messages. We repeated the trace tests 10 times, and we repeated processing the IPP
messages 1 million times to normalize any system timing perturbations. We show the
standard deviation of these runs using error bars in the charts.
6.1 Micro-benchmarks of Matching Primitives
To evaluate the performance of using fast string matching primitives, we implemented
our parser using two different implementations of the Aho–Corasick (AC) algorithm
and compared their performance (Figure 2a). We used the sfutil library, which is part
of the Snort IDS [17], and the Spare Parts implementation of AC [18]. We used those
base implementations to search for the same strings as our vulnerability matcher does,
but without any of the control logic or constraint checking. We found that for either AC
High-Speed Matching of Vulnerability Signatures
167
implementation, the performance of a basic HTTP vulnerability matcher (which handles
optional bodies and chunking) was very close to that of the string matching primitive.
The performance of string matching alone approximates (generously) the perfor-
mance of a simple pattern-based IDS. If the vulnerability signature is simple enough
to be expressed using a simple string match (e.g., the IPP vulnerability for a negative
Content-Length), our system is able to match it with comparable performance to a
pattern based IDS.
)
s
/
s
t
i
b
M
(
t
u
p
h
g
u
o
r
h
T
 900
 800
 700
 600
 500
 400
 300
 200
 100
 0
VESPA
string matching alone
Snort
SpareParts
(a) Comparison between string matching
primitive and parsing for HTTP requests
Parser Type
Num calls
to new
539
14
33
6
94
6
Bytes
allocated
DNS (binpac)
15,812
DNS (traversal) 2,296
1,360
IPP (binpac)
432
IPP (traversal)
WMF (binpac)
3,824
WMF (traversal) 312
(b) Dynamic memory usage for a sin-
gle message for standard binpac
vs. binary traversal
Fig. 2. Micro-benchmarks
We next investigated the performance of binary traversal in binpac. One of the pri-
mary changes we made to binpac was to change its default memory and allocation
behavior. We instrumented the original version of binpac and a parser built with our bi-
nary traversal-optimized version to assess the effectiveness of this change (Figure 2b).
We saw an overall reduction in memory usage despite pre-allocating types that may
not be present in the message. We were also able to cut the number of calls to new by
a substantial factor for all three binary protocols we implemented. Our IPP and WMF
traversers do not contain any explicit pointer types (speciﬁed with &pointer), so the
number of allocated blocks is constant for any protocol message. The number of times
the DNS parser calls the new allocator is proportional to the number of name pointers
in the message.
6.2 Signature Matching Performance
We evaluated the throughput of our vulnerability signature matching algorithms com-
pared to the binpac parser generator. Binpac is the most efﬁcient freely available au-
tomated protocol parser generator. We do not evaluate against GAPA because it has
not been publicly released. Furthermore, binpac far exceeds GAPA in performance be-
cause it directly generates machine code rather than being interpreted [1]. Since binpac is
not speciﬁcally designed for vulnerability signatures, we added vulnerability constraint
checking to the binpac protocol speciﬁcations. In each of the following sections we de-
scribe the protocol and vulnerabilities we tested against. We show the results in Figure 3.
168
N. Schear, D.R. Albrecht, and N. Borisov
HTTP/IPP. The Common Unix Printing System (CUPS), with its protocol encapsula-
tion and chunk-capable HTTP parser, illustrates several design choices which confound
exploit-signature writers. The vulnerability given in CVE-2002-0063 [10] occurs be-
cause of the way the Internet Printing Protocol (IPP) speciﬁes a series of textual key–
value pairs, called attributes. The protocol allows attribute lengths to vary, requiring the
sender to use a 16-bit unsigned integer to specify the length of each attribute. CUPS
reads the speciﬁed number of bytes into a buffer on the stack, but the buffer is only
8192 bytes long, allowing an attacker to overﬂow the buffer and execute arbitrary code
with the permissions of the CUPS process. A signature for this attack must check that
each attribute length is less than 8192. IPP is a binary protocol but it is encapsulated
inside of chunked HTTP for transport. Attackers can obfuscate the exploit by splitting
it across an arbitrary number of HTTP chunks, making it very hard to detect this attack
with pattern-based signatures. We also tested the negative content length vulnerability
that we have discussed previously.
We designed a text-based vulnerability signature matcher for HTTP. In addition to
vulnerabilities in HTTP itself, many protocols and ﬁle formats which are encapsulated
inside of HTTP also have vulnerabilities. We use VESPA to match the Content-Length
vulnerability in CUPS/IPP, as well as to extract the body of the message to pass it to an-
other layer for processing. We support standard and chunked message bodies and pass
them to a null processing layer. Unfortunately, we were unable to make a direct compar-
ison to binpac for chunked HTTP messages due to a bug in binpac’s buffering system:
binpac will handle such a message but fail to extract data from each individual chunk.
Despite this, we found that VESPA was considerably faster than the equivalent binpac
parser. Since much of the HTTP message body is ignored by both VESPA and binpac,
the throughputs we observed are very high because the size of the body contributes to
the overall number of bytes processed. We also measured the message processing rates
for various types of HTTP messages and found them to be adequate to process the trafﬁc
of a busy website (Table 2).
We implemented a binary IPP vulnerability matcher to be used in conjunction with
our HTTP parser. The VESPA IPP matcher ran four times as fast as the binpac ver-
sion, largely due to the improved state management techniques we described earlier.
We also developed a hand-coded drop-in replacement for our binpac binary traverser
of the IPP protocol. Using this replacement, we were able to achieve an order of mag-
nitude improvement over the performance of the binpac binary traversal (see Table 1).
Table 2. HTTP Message Rate
HTTP Message Type Message Rate
(msgs per sec)
370,005
196,897
41,644
314,797
Requests
Responses
Chunked
Overall
High-Speed Matching of Vulnerability Signatures
169
)
s
/
s
t
i
b
M
(
t
u
p
h
g
u
o
r
h
T
 500
 400
 300
 200
 100
 0
DNS
)
s
/
s
t
i
b
G
(
t
u
p
h
g