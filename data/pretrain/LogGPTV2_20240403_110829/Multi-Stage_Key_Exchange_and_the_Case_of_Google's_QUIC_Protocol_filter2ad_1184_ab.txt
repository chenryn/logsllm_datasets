freshly from the previous master secret, not from the previous session key).3
Finally, in order to be able to reason about protocols where only one participant in a session is authen-
ticated, our model captures both unilateral as well as mutual authentication of participants.
As in [Brz13, BFWW11], we model security according to two games, one for key indistinguishability,
and one for matching. The former is the classical notion of random-looking keys, reﬁned according to key
(in)dependence, (stage-j) forward secrecy, and unilateral or mutual authentication. The Match-property
gives straightforward security guarantees, such as identical keys in partnered sessions, authenticity of the
partner, and collision-freeness of session identiﬁers.
2.2 Preliminaries
We denote by U the set of identities used to model the participants in the system, each identiﬁed by some
U ∈ U and associated with a long-term public key pkU and corresponding secret key skU . Sessions of a
protocol are uniquely identiﬁed (on the administrative level of the model) using a label label ∈ LABELS =
U × U × N, where (U, V, k) indicates the k-th local session of identity U (the session owner ) with V as the
intended communication partner.
For each session, a tuple with the following information is maintained as an entry in the session list
ListS, where values in square brackets indicate the respective default/initial value:
• label ∈ LABELS: the (administrative) session label
• U ∈ U: the session owner
• V ∈ U: the communication partner
• role ∈ {initiator, responder}: the session owner’s role in this session (initiator or responder)
• kidU : the key identiﬁer of the session owner (see below)
• kidV : the key identiﬁer of the communication partner
• stexec ∈ (RUNNING ∪ ACCEPTED ∪ REJECTED): the state of execution [running0], where RUNNING =
{runningi | i ∈ N0}, ACCEPTED = {acceptedi | i ∈ N}, REJECTED = {rejectedi | i ∈ N}
• stage ∈ {0, . . . , M}: the current stage [0], where M is the maximum stage4 and stage is incremented
to i when stexec reaches acceptedi resp. rejectedi
• sid ∈ ({0, 1}∗ ∪ {⊥})M: the session identiﬁers [(⊥)M], where sidi indicates the session identiﬁer in
stage i (cid:54)= 0
• K ∈ ({0, 1}∗ ∪ {⊥})M: the established session keys [(⊥)M], where Ki indicates the established session
key in stage i (cid:54)= 0
3One could even go further and consider key dependence with respect to each stage individually. We do not do so in order
to keep the model simple.
4We ﬁx a maximum stage M only for ease of notation. Note that M can be arbitrary large in order to cover protocols
where the number of stages is not bounded a priori.
6
• stkey ∈ {fresh, revealed}M: the states of the session keys [(fresh)M], where stkey,i indicates the state of
the session key in stage i (cid:54)= 0
• tested ∈ {true, false}M: the test indicator [(false)M], where testedi = true means that Ki has been
tested
By convention, if we add a partly speciﬁed tuple (label, U, V, role, kidU , kidV ) to ListS, then the other tuple
entries are set to their default value.
We identify key material used to interact within one or several protocol executions by some unique,
administrative key identiﬁer kid, pointing to some entry in the key list ListK, where the following associated
information is stored:
• kid: the key identiﬁer
• U ∈ U: the identity associated with this key
• tpk: a temporary public key
• tsk: the corresponding temporary secret key
As labels and key identiﬁers are unique, we write as a shorthand label.sid for the element sid in the
tuple with label label in ListS, and kid.tpk for the element tpk in the tuple with key identiﬁer kid in ListK.
2.3 Adversary Model
We consider a probabilistic polynomial-time (PPT) adversary A which controls the communication between
all parties, enabling interception, injection, and dropping of messages. Moreover, as illustrated earlier, we
distinguish diﬀerent levels of the following three (orthogonal) security aspects of a multi-stage key exchange
scheme: key dependence, forward secrecy, and authentication.
Key dependence. We distinguish key-dependent and key-independent protocols, where key dependence
means that the session key Ki+1 of some stage i + 1 depends on the session key Ki of the previous stage i in
a way that disclosure of Ki before Ki+1 has been established compromises the latter. As mentioned earlier,
Google’s QUIC protocol is an example of a key-dependent scheme, whereas SSL/TLS with resumption is
key independent.
We reﬂect key dependence in our model by restricting the disclosure of the current stage’s session
key via Reveal queries in the case of key-dependent security. Note that we however allow compromises
of a session key Ki after key Ki+1 of the next stage has been established—even in combination with
simultaneous attacks (i.e., testing) on Ki+1. This models the intuitive requirement that session keys in
a multi-stage key exchange can (or often should) become stronger with increasing stage. In particular,
Ki+1 should not depend trivially on Ki as, e.g., in Ki+1 = Hash(Ki). We require that in fact Ki+1 is still
indistinguishable from random given the revealed previous session key Ki or even all preceding session keys
Kj with j ≤ i.
Forward secrecy. The well-established notion of forward secrecy requires that established (i.e., ac-
cepted) session keys remain secure even if the long-term secrets are exposed. Classical forward secrecy is
a binary notion: a single-stage key exchange scheme can be either forward-secret or non-forward-secret.
In the setting of multi-stage key exchange, however, a protocol might achieve forward secrecy only from
a certain stage onwards, i.e., session keys in lower stages become insecure on exposure of long-term keys
while keys of this stage (and higher stages) remain secure.
7
Therefore, we diﬀerentiate in our model between non-forward-secret and stage-j-forward-secret proto-
cols, where stage-j forward secrecy indicates that session keys Ki established at some stage i ≥ j remain
secure when the involved long-term secrets get exposed, whereas keys at stages i  stage,
or testedi = true, then return ⊥. Otherwise, set stkey,i to revealed and provide the adversary with Ki.
If there is a tuple (label(cid:48), V, U, role(cid:48), kidV , kidU , st(cid:48)
key, tested(cid:48)) in ListS with sidi =
sid(cid:48)
key,i is set to revealed as well. This means that the i-th session keys of all
partnered sessions (if already established) are considered revealed as well.
i and stage(cid:48) ≥ i, then st(cid:48)
exec, stage(cid:48), sid(cid:48), K(cid:48), st(cid:48)
As above, in the case of key-dependent security, since future keys depend on the revealed key, we
cannot ensure their security anymore (neither in this session in question, nor in partnered sessions).
Therefore, if i = stage, set stkey,j = revealed for all j > i, as they depend on the revealed key. For
the same reason, if a partnered session label(cid:48) with sidi = sid(cid:48)
i has stage(cid:48) = i, then set st(cid:48)
key,j = revealed
for all j > i. Note that if however stage(cid:48) > i, then keys K(cid:48)
j for j > i derived in the partnered session
are not considered to be revealed by this query since they have been accepted previously without
adversarial interaction.
• Corrupt(U ): Provide (skU , pkU ) to the adversary. No further queries are allowed to sessions owned
by U .
In the non-forward-secret case, for all sessions (label, U, V, role, kidU , kidV , stexec, stage, sid, K, stkey,
tested) and all i ∈ {1, . . . , M}, set stkey,i to revealed.
In this case, all (previous and future) ses-
sion keys are considered to be disclosed.
In the case of stage-j forward secrecy, stkey,i is set to revealed only if i  stage. This
means that sessions keys before the j-th stage (where forward secrecy kicks in) as well as keys that
have not yet been established are potentially disclosed.
Independent of the forward secrecy aspect, in the case of key-dependent security, setting the relevant
key states to revealed for some stage i is done by internally invoking Reveal(label, i), ignoring the
response and also the restriction that a call with i > stage would immediately return ⊥. This
ensures that follow-up revocations of keys that depend on the revoked keys are carried out correctly.
Note that we do not reﬂect leakage of temporary keys here, which can be considered a possible
extension of our model. Concerning QUIC, though, disclosure of the temporary keys indeed exposes
all ephemeral key material and thus trivially renders forward secrecy unachievable.
• Test(label, i): Tests the session key of stage i in the session with label label. In the security game
below this oracle will be given a test bit btest as state which is ﬁxed throughout the game.
If there is no tuple (label, U, V, role, kidU , kidV , stexec, stage, sid, K, stkey, tested) in ListS or if label.stexec (cid:54)=
acceptedi, return ⊥. If there is a tuple (label(cid:48), V, U, role(cid:48), kidV , kidU , st(cid:48)
key, tested(cid:48))
exec (cid:54)= acceptedi, return ⊥. This ensures that keys can only be tested
in ListS with sidi = sid(cid:48)
if they have just been accepted (and not used yet), in particular if there is a partnered session that
already established this key.
exec, stage(cid:48), sid(cid:48), K(cid:48), st(cid:48)
i, but st(cid:48)
9
KI,1-FS,M
KI,2-FS,M
KI,M-FS,M
KI,NFS,M
KI,1-FS,U
KI,2-FS,U
KI,M-FS,U
KI,NFS,U
KD,1-FS,M
KD,2-FS,M
KD,M-FS,M
KD,NFS,M
KD,1-FS,U
KD,2-FS,U
KD,M-FS,U
KD,NFS,U
Figure 2: Hierarchy of the Multi-Stage security ﬂavors key-independent (KI) and key-dependent (KD), stage-n-forward-secret
(n-FS) and non-forward-secret (NFS), as well as mutual authentication (M) and unilateral authentication (U) for a multi-stage
key exchange protocol with M stages. A solid arrow from A to B denotes that A implies B, the dotted arrows indicates that
intermediate ﬂavors are omitted.
If label.testedi = true, return Ki, ensuring that repeated queries will be answered consistently.
In the case of unilateral authentication, if label.role = responder and there is no tuple (label(cid:48), V, U,
i and role(cid:48) = initiator, return
role(cid:48), kidV , kidU , st(cid:48)
⊥. This means the adversary is not allowed to test responder (i.e., authenticated) sessions that
do not communicate with a genuine initiator. Note that ListS entries are only created for honest
sessions, i.e., sessions generated by NewSession queries.
key, tested(cid:48)) in ListS with sidi = sid(cid:48)
exec, stage(cid:48), sid(cid:48), K(cid:48), st(cid:48)
$← D at random, where
Otherwise, set label.testedi to true. If the test bit btest is 0, sample label.Ki
D is the session key distribution. This means that we substitute the session key by a random
and independent key which is also used for future deployments within the key exchange protocol.
key, tested(cid:48)) in ListS
Moreover, if there is a tuple (label(cid:48), V, U, role(cid:48), kidV , kidU , st(cid:48)