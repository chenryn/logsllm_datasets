Core i7-7700K
Core i7-5775C
C. Discussion
Our experiments show that the memory controller-based
RowHammer mitigations are deployed only in speciﬁc families
of Intel processors. While we ﬁnd that pTRR and other
mitigations (e.g., double refresh) are used in high-end Xeon
servers, our results show that neither DDR3 nor DDR4 con-
sumer systems appear to enable any MC-based mitigation. In
Figure 7, we reconstruct a timeline of RowHammer mitiga-
tions on Intel platforms based on the results of our analysis.
With both DDR3 and DDR4, only server platforms appear to
beneﬁt from mitigations inside the memory controller while
consumer platforms do not. Based on earlier reports of bit
ﬂips using standard RowHammer patterns on consumer DDR4
memory [27], [56], [66], we can speculate that in-DRAM
mitigations are widely-deployed only since 2016 (i.e., the ear-
liest manufacturing date of a DRAM module with MAC set to
unlimited among all modules that we list in Table II). In other
words, DRAM manufacturers’ promises of a RowHammer-
less future [63], [70] hinge entirely on the security of their
undocumented in-DRAM TRR mitigations. Unfortunately, as
we show in the next sections, analyzing and understanding
such mitigations can reveal signiﬁcant weaknesses that can be
exploited to mount RowHammer attacks on modern DDR4
DRAM chips.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
751
(cid:9)(cid:9)(cid:10)(cid:3) (cid:11)(cid:12) (cid:13)(cid:15)(cid:19) (cid:16)(cid:17)(cid:20)
(cid:21)(cid:22)(cid:10)(cid:10)
(cid:9)(cid:9)(cid:10)(cid:5)
(cid:11)(cid:12) (cid:13)(cid:9)(cid:10)(cid:14)(cid:15) (cid:16)(cid:17)(cid:18)(cid:19)(cid:20)
(cid:11)(cid:12) (cid:13)(cid:15)(cid:19) (cid:16)(cid:17)(cid:20)
(cid:1)(cid:2)(cid:4)
(cid:1)(cid:2)(cid:3)
(cid:1)(cid:2)(cid:5)
(cid:1)(cid:2)(cid:6)
(cid:1)(cid:2)(cid:7)
(cid:1)(cid:2)(cid:8)
(cid:17) (cid:23) (cid:17)(cid:24)(cid:25)(cid:26)(cid:24)(cid:25)
(cid:19) (cid:23) (cid:19)(cid:27)(cid:12) (cid:28)(cid:29)(cid:30) (cid:24)(cid:25)
Fig. 7: TRR Timeline. Timeline of deployment of TRR as RowHam-
mer mitigation. MC-based mitigations are deployed in both DDR3
and DDR4 server systems since 2013 [46]. In contrast, in-DRAM
mitigations appear with DDR4 for both consumer and server sys-
tems [63], [70].
V. INSIDE THE DRAM CHIPS
We dig deeper to understand the RowHammer protection
that the DRAM vendors implement inside recent DRAM chips,
which are advertised as RowHammer-free [63], [70]. So far,
the DRAM vendors have not publicly shared the details of
the exact RowHammer protection mechanisms they implement
in the form of TRR. Therefore, we experiment with and
analyze real DRAM chips to shed light on the inner workings
of the TRR mechanisms implemented by different vendors
in different DRAM chip generations. Performing such an
analysis using a general-purpose CPU is extremely challenging
because the memory controller provides a very high-level
interface to the CPU (i.e., the programmer can interface with
the DRAM using only load/store instructions). However, to
perform accurate experiments, we need ﬁne-grained control
over the low-level commands sent to the DRAM. Therefore,
we leverage an open-source FPGA-based memory controller,
SoftMC [31], [80], which enables the programmer to issue
arbitrary DRAM commands in a cycle-accurate manner. We
extend SoftMC to support experimental studies on DDR4
modules. We ﬁrst discuss our hypotheses for potential ways of
implementing in-DRAM TRR. Then, we present case studies
for two DRAM modules from different manufacturers. Our
results show that different manufacturers implement vastly
different TRR mitigations.
A. Building Blocks and Hypotheses
While literature indicates that each manufacturer may im-
plement its own variant of TRR [34], [38], [45], [49], [65],
[74], [75], [95], we abstract the implementation details and
unravel the two main requirements for supporting TRR: the
sampler and the inhibitor. We deﬁne these requirements as
building blocks and present a series of hypotheses that we
verify in the next sections.
The Sampler. A sampling mechanism is required to track
which aggressor rows are being hammered. Solutions vary
from basic frequency-based sampling to more complex
designs that
track activations per row. In frequency-based
implementations, sampling occurs at ﬁxed periods in time
within a refresh interval [34], [74], [95]. For example, a
TRR implementation may determine aggressor
rows by
monitoring every 3rd and 4th access after a REFRESH. The
more complex designs that track accesses on a per-row basis,
keep activation counters for a number of rows [45], [65]
and select aggressors based on their individual activation
counts. Despite differences in its implementation, the goal of
the sampler remains the same: track which rows are being
hammered in order to identify their target victim rows.
Our ﬁrst hypothesis is that the sampler has a limited size
s. In other words, there is a maximum number of aggressor
rows that the sampler can track. Phrased differently, the TRR
mitigation can protect only a limited number of victim rows.
The Inhibitor. Once the sampler is aware of the aggressor
rows, the mitigation must thwart the hammering process. As
the name Target Row Refresh suggests (and different designs
conﬁrm [34], [74], [95]), an effective solution consists of
generating extra refreshes for the victim rows. Nonetheless,
more sophisticated designs incorporate the possibility of row
remapping [38], [48], [67].
Our second hypothesis is that the inhibitor acts at refresh
time—based on the literature [34], [74], [95]. Refresh oper-
ation is the responsibility of the memory controller, which
issues one REFRESH command every 7.8 μs (tREFI). Since
DDR is a synchronous protocol [40], [44], the memory con-
troller must remain idle for a ﬁxed period of time (tRFC)
before it can send subsequent commands to the bank. Any,
possibly additional, targeted refreshes must still respect these
timing constraints for the DRAM module to be compliant with
the DDRx standard. That is, only a limited number of target
rows can be refreshed.
Goals. Based on the aforementioned assumptions we deﬁne
the following questions that we want to answer.
• What is the size of the sampler?
• How does the sampler track aggressor rows? For example,
does it record row activation commands at a constant
frequency or based on a function of time?
• How does the inhibitor work? Can it prevent bit ﬂips?
In the following, we try to answer these questions by
analyzing TRR via two different case studies.
B. Case I: Module C12
Our ﬁrst study examines a module from manufacturer C. We
ﬁrst ﬁnd the minimum number of activations that are required
to trigger bit ﬂips on this module. To do so, we disable refresh,
which prevents TRR from performing refresh on victim rows,
and perform a double-sided RowHammer sweep of a single
DRAM bank. The results, plotted in Figure 8, show that we can
trigger bit ﬂips with as few as 50K activations. This indicates
that DRAM cells in DDR4 are generally considerably weaker
compared to DRAM cells in the predecessor DDR3 standard,
which requires at least ∼139K activations [51]. Nonetheless,
for future experiments reported in this paper we use a higher
activation count so that we can observe more bit ﬂips and draw
stronger conclusions.
Mastering refresh. Knowing the physical
limitations of
the DRAM module, we now reintroduce the REFRESH
command. We decide to batch refresh operations together
with the goal of understanding the relationship between them
and the effectiveness of the TRR mitigation. We perform a
series of hammers (i.e., activations of aggressors) followed
by r refreshes for ten rounds—we carry out 8K hammers per
round. In Figure 9, we report the results of this experiment
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
752
(cid:16)
(cid:28)(cid:25)(cid:17)
(cid:27)
(cid:25)(cid:26)
(cid:24)
(cid:12)
(cid:3)(cid:4)(cid:4)
(cid:3)(cid:4)
(cid:3)
(cid:2)
(cid:1)
(cid:2)
(cid:4)
(cid:3)
(cid:2)
(cid:1)
(cid:3)
(cid:2)
(cid:4)
(cid:5)
(cid:2)
(cid:1)
(cid:5)
(cid:2)
(cid:6)
(cid:5)
(cid:2)
(cid:7)
(cid:5)
(cid:2)
(cid:8)
(cid:5)
(cid:2)
(cid:9)
(cid:5)
(cid:12) (cid:13)(cid:14)(cid:15)(cid:16) (cid:17)(cid:18)(cid:19)(cid:20)(cid:21)(cid:21)(cid:19)(cid:18)(cid:16)(cid:16)(cid:22)(cid:19)(cid:19)(cid:22)(cid:23)
(cid:2)
(cid:4)
(cid:10)
(cid:2)
(cid:1)
(cid:10)
(cid:2)
(cid:4)
(cid:2)
(cid:1)
(cid:11)
(cid:11)
(cid:2)
(cid:4)
(cid:1)
Fig. 8: Bit ﬂips vs. number of activations. Module C12: We can
observe bit ﬂips with as few as 25K activations per aggressor row
(i.e., 50K activations in total due to double-sided hammering).
for RowHammer conﬁgurations with different numbers of
aggressors. Let us ﬁrst consider only the third column of the
plot: double-sided RowHammer. We observe that adding a
single refresh causes the number of bit ﬂips to drop from
2,866 to only one (for r = 1), and then to zero (for any
r ≥ 2). This experiment provides an insightful result: since
sending multiple REFRESH commands varies the number
of bit ﬂips, the TRR mitigation must act on every refresh
command.
Observation 1: The TRR mitigation acts (i.e., carries out a
targeted refresh) on every refresh command.
Next, we take a closer look at the sampler size s to ﬁnd
how many rows the mitigation can handle. We increase the
number of aggressors n while keeping the number of ACTs
per aggressor row constant. For every additional aggressor
row, we have an additional victim row. For example, with
3 aggressor rows,
the hammering conﬁguration looks like
VAVAVAV where V stands for a victim row and A stands for
an aggressor row. The fourth column in Figure 9 shows the
behavior when hammering three aggressors (n = 3). Here we
observe something different: the number of bit ﬂips decreases
signiﬁcantly when introducing up to two refreshes. However,
(cid:1)(cid:16)(cid:17)(cid:18)(cid:19)(cid:20)(cid:17)(cid:8) (cid:6)
(cid:3)(cid:6)(cid:1)(cid:1)(cid:1)
(cid:3)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:6)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:6)(cid:1)(cid:1)(cid:1)
(cid:1)
(cid:8)
(cid:9)
(cid:10)
(cid:12)
(cid:11)
(cid:10)
(cid:9)
(cid:5)
(cid:5)
(cid:3)
(cid:8)
(cid:6)
(cid:3)
(cid:7)
(cid:6)
(cid:3)
(cid:4)(cid:5)
(cid:3)
(cid:2)
(cid:1)
(cid:9)
(cid:8)
(cid:7)
(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:1)
(cid:1)
(cid:2)
(cid:3)
(cid:5)
(cid:7)
(cid:4)
(cid:1)(cid:13)(cid:14)(cid:14)(cid:5)(cid:3)(cid:6)(cid:6)(cid:9)(cid:5)(cid:2)(cid:9)(cid:15)(cid:6)
(cid:6)
Fig. 9: Refreshes vs. Bit Flips. Module C12: Number of bit ﬂips
detected when sending r refresh commands to the module. We report
this for different number of aggressor rows (n). For example, when
hammering 5 rows, followed by sending 2 refreshes, we ﬁnd 1,710
bit ﬂips. This ﬁgure shows that the number of bit ﬂips stabilizes for
r ≥ 4, implying that the size of the sampler may be 4.
it plateaus for r ≥ 3 without going down to zero. Notice that
when hammering both 2 and 3 rows, the plateaus happen
when r = n. This suggests that the TRR mitigation samples
more than one aggressor within a refresh interval while it can
refresh only one victim per refresh operation. The DRAM can
refresh only one of the victim rows likely as a consequence of
the tight timing constraints imposed by the tRFC parameter.
Moreover, we can deduce from the remaining non-zero bit
ﬂips that the sampler is likely to discard the aggressor row
from its table once one of its victims has been refreshed.
We can recover the size of the sampler by performing the
for different numbers of aggressors n.
same experiment
While increasing n, we search for the scenario where the
number of bit ﬂips stabilizes for r 5, the num-
ber of bit ﬂips decreases drastically compared to 5-sided
RowHammer—suggesting that the sampler selects rows in a
speciﬁc fashion. While we tried to understand this behavior
of the sampler, the lack of visibility inside the DRAM chip
made it challenging. Regardless, this additional information is
not necessary given that hammering 5 aggressors in standard
conditions already bypasses the in-DRAM mitigation.
Fig. 10: Bit ﬂips vs. number of aggressor rows. Module C12:
Number of bit ﬂips in bank 0 as we vary the number of aggressor
rows. Using SoftMC, we refresh DRAM with standard tREFI and
run the tests until each aggressor rows is hammered 500K times.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
753
(cid:16)
(cid:24)(cid:21)(cid:25)
(cid:23)
(cid:21)(cid:22)
(cid:20)
(cid:11)
(cid:6)(cid:19)
(cid:4)(cid:19)
(cid:2)(cid:19)
(cid:10)
(cid:1) (cid:2) (cid:3) (cid:4) (cid:5) (cid:6) (cid:7) (cid:8) (cid:9)
(cid:10)
(cid:1)
(cid:1)
(cid:1)
(cid:2)
(cid:1)
(cid:3)
(cid:1)
(cid:4)
(cid:1)
(cid:5)
(cid:1)
(cid:6)