FACE AREAS
Memory alignment is commonly adopted in modern operating
systems for better memory performance. With memory alignment,
a memory block allocated for a process cannot start from arbitrary
addresses. Instead, the addresses must be multiples of the align-
ment size deﬁned by the system.
In this section, we analyze the memory allocation behavior of the
Windows platform and its implication on heap-spraying attacks.
Then we describe a new attack technique that can evade existing
heap-spraying detection mechanisms. Note that other operating
3.1 Windows memory allocation granularity
Windows memory alignment is controlled by the allocation gran-
ularity. On all existing Windows platforms, the value of alloca-
tion granularity1 is always 64K [33]. This size 64K was chosen
in part for supporting future processors with large page sizes [22],
as well as solving relocation problems on existing processors [3].
The memory allocation granularity only affects user-mode code;
kernel-mode code can allocate memory at the granularity of a sin-
gle page [22]. As a result of the Windows memory allocation gran-
ularity, almost all of the base addresses of non-free regions are
aligned with 64K boundaries. In a process’s memory space, only
few regions (allocated by kernel-mode code [33]) are not aligned.
Even with ASLR enabled [40], the alignment of memory region ad-
dresses is not affected. On Linux systems, the memory allocation
granularity is 4K bytes.
Therefore, taking Windows as an example, all heap blocks al-
located by user-mode code start from 64K boundaries. Note that
heap objects allocated by HeapAlloc can still start at random ad-
dresses in a heap block, but we have an interesting observation:
when a heap object is bigger than a certain threshold, 512K in
our experiment, Windows always allocates a separate heap block
for this object. That is, the addresses of large heap objects are
also aligned according to the allocation granularity, thus more pre-
dictable.
What is the implication of such a memory allocation behavior
on heap-spraying attacks? Recall that in the second step of a heap-
spraying attack, after the attacker triggers a control-hijacking ex-
ploit successfully, the victim process’s EIP register is loaded with
a value assigned by the attacker. If the starting addresses of heap
objects are fully random, the EIP can fall anywhere in a heap ob-
ject. For example, when the heap object’s size is 512K bytes, the
hijacked EIP can point to any byte of the 512K bytes. This is the
main reason for requiring a large amount of NOP-like instructions
in heap-spraying attacks. However, the Windows memory alloca-
tion granularity makes large heap objects’ addresses much more
predictable.
If an EIP assigned by an attacker have few possi-
ble locations in a large heap object, the attacker only need to put
jump-equivalent instructions at those locations to guide the victim
process to execute malicious shell code, which breaks the assump-
tions, relied on by previous defense mechanisms. As a result, the
large block of NOP sled is no longer necessary for a heap-spraying
attack with high chances to succeed.
In fact, an EIP assigned by an attacker can only point to EIGHT
possible locations in a 512K-byte heap object, which is explained
in Figure 2 using the address 0x0c0c0c0c. Due to the 64K
(0x10000) Windows memory allocation granularity, a 512K-byte
heap object covering the address 0x0c0c0c0c can only start from
0x0c050000, 0x0c060000, ..., 0x0c0c0000. Therefore, the
offset of the address 0x0c0c0c0c0 inside the object have eight
possible values: 0x70c0c, 0x60c0c, ..., 0x00c0c. On each
of these offsets, if the attacker puts a few bytes, say 20 bytes (the
unconditional jump instruction takes ﬁve bytes on 32-bit x86), of
jumping instructions, the resulting surface area is very little: 160
bytes out of a 512K-byte object.
1It can be retrieved by the GetSystemInfo API
dwAllocationGranularity member
SYSTEM_INFO structure).
the
of
(the
returned
Figure 2: Possible offset of 0x0c0c0c0c in a 512KB heap blocks.
Figure 3: Structures of new heap-spraying memory blocks.
3.2 Structure of malicious heap objects with
little surface area
As is discussed in the previous section, given a speciﬁc address
addr in the heap region, the landing action can only start at few
offsets in a large heap object. Executable code at other offsets will
never be the direct jump target when the process transfers control
to the address addr. With this new insight, we describe a few new
structures of malicious heap objects that result in very little surface
area.
The general idea is to put jump-equivalent instructions at possi-
ble landing positions to guide execution into attackers’ shellcode.
The shellcode is a small piece of code connected by jump-family
instructions, which can evade the approaches that detect valid in-
struction sequences. Figure 3 shows three types of the new heap
block structures that have little surface area. In this ﬁgure, each
rectangle with bold boundary stands for a heap object. The shadow
areas are bytes with random values. The possible landing positions
are represented as solid dots. Shellcode is represented as white
rectangles, with a circle indicating its entry point.
• In the Type A structure, attackers ﬁrst copy the block of ma-
licious shellcode into the heap object. The landing positions
are chained together to reach the shellcode entry. That is,
each landing position is a set of jump-equivalent instructions
that point to the next landing position. The instructions at the
last landing position lead to the shellcode entry.
• In the Type B structure, attackers put jump-equivalent in-
structions at the possible landing positions. Each group of
jump instruction will jump to the shellcode entry.
• In the Type C structure, the malicious shellcode is directly
put at each landing position. By using this kind of memory
blocks, the landing action is eliminated and the shellcode is
executed immediately after the exploit is triggered.
In the Type C structure, although there are several copies of
shellcode, the surface area is as small as one copy because the
copies of shellcode are not connected. The Type C structure re-
quires the shellcode size to be smaller than the alignment granular-
ity. To launch such an attack on an operating system using a small
alignment granularity, say 32 bytes, we introduce the Type D heap
object structure, which is an improved Type C structure.
Shown in Figure 4, the main idea of this structure is that we
can split the shellcode into pieces and link these pieces with jump
instructions. We place jump instructions at each landing point to
jump to the shellcode. Similar to the Type C structure, although
there are lots of shellcode copies in the heap block, the measurable
surface area is small. We illustrate this type of structure by an ex-
ample. Assuming the memory allocation granularity is 32 bytes,
we construct a 512K-byte heap block using the Type D structure,
which includes 1024 copies of shellcode. In the heap block, we
need to create 512K/32 = 16384 landing points. Each landing
point connects to one of the shellcode copies sequentially or arbi-
Memory address512KB blocks64KB0x0c050000offset=0x70c0c0x0c0c0c0coffset=0x60c0coffset=0x50c0coffset=0x40c0coffset=0x30c0coffset=0x20c0coffset=0x10c0coffset=0x00c0cshellcode64KB cycle64KB cycle64KB cycle64KB cycle64KB cycle64KB cycle64KB cycleLanding positionShellcode entryType APassing the flower  Shellcode entryType BJumping all together Landing positionshellcodeShellcode entryType CReturning homeA 512 KB memory blockA 512 KB memory blockshellcodeshellcodeshellcodeshellcodeshellcodeshellcodeshellcodeshellcode64KB cycle64KB cycle64KB cycle64KB cycle64KB cycle64KB cycle64KB cycleLanding positionA 512 KB memory blockFigure 4: Type D layout ‘Dropping around’
trarily. This transformation is still a “sled construction” technique,
which plants landing points inside the shellcode. The shellcode
features are not changed after these landing points inserted.
Type D structures can be created using the following technique.
Given a piece of shellcode2, we ﬁrst split it into pieces, where each
piece is less than or equal to 25 bytes. If a piece is less than 25
bytes, we append a few NOP-like instructions to it to make the size
of all pieces 25 bytes. To connect the shellcode pieces, we enclose
each shellcode piece between a prologue and an epilogue, shown
in Step 2 of the ﬁgure. The prologue is called “header (hdr) jump”
and it’s a jump instruction (5 bytes, jump near, relative, displace-
ment relative to next instruction) pointing to the shellcode’s starting
position. We need to distribute the header jumps to the start of 1024
copies of shellcode evenly. In the attack, the prologues are put at
landing points. The epilogue is called “tail jump” and it’s a jump
instruction (2 bytes, jump short, relative, displacement relative to
next instruction). In the attack, the epilogues connect the shellcode
pieces. The tail jump only jumps 2 + 5 = 7 bytes forward. So
with the prologue and epilogue, each shellcode piece is extended to
25 + 5 + 2 = 32 bytes. In the third step, we combine 16 such 32-
byte pieces to form shellcode of 16 × 32 = 512 bytes. We call it a
512-byte linked shellcode. To ﬁt the selected original shellcode into
such a block, the shellcode size should be less than 25 × 16 = 400
bytes. Finally, we merge 1024 linked shellcode pieces into one
heap memory block. There are 1024 × 16 = 16384 header jumps
inside the heap memory block and they are the landing positions.
The ﬁnal heap memory block will be used in our new heap-
spraying attack. The possible landing positions are at each 32 byte
2The size of shellcode ranges from dozens to hundreds [12].
Alignment size Type A Type B Type C Type D
64 kbytes
32 bytes
8 bytes
4 bytes
√
√
√
√
√
√
√
×
√
×
×
×
√
√
×
×
Table 1: Relationship between layout types and alignment size.
boundary. So we could exploit to address such as 0x0c0c0c20,
0x0c0c0c40, 0x0c0c0c60, and etc. When the execution starts
from any one of the landing positions, it will reach the shellcode.
We summarize the relationship between four heap object struc-
tures and the memory alignment boundaries in table 1. When the
alignment size is 64K bytes, all four heap object structures can be
used. More generally, all four heap object structures can be used as
long as the alignment size is larger than the size of the shellcode.
When the alignment size is smaller than the size of the shellcode,
the Type C layout does not work anymore, but the Type D is still
effective.
In the new attack discussed in this paper, the sprayed heap ob-
jects are mostly ﬁlled with bytes that cannot be treated as NOP sled
or bytes that cannot be interpreted as legal x86 instructions. NOZ-
ZLE can only ﬁnd memory blocks that have a normalized surface
area much lower than its threshold.
3.3 Surface area calculation
Our calculation involves the following variables: heap mem-
ory block size sizeblock, alignment size sizealignment, shellcode
size sizesc, and normalized attack Surface Area N SA. We use
N SAtypeX to represent the normalized attack surface area of Type
X.
Shellcode(no more than 400bytes)1024 linked shellcodes (512k bytes)ShellcodepieceShellcode piece......ShellcodepieceShellcode piece400 bytes25 byteShellcode piece25 bytehdrjump tailjumpShellcode piece25 bytehdrjumptailjumpto a shellcode startto next shellcode piecefrom previoustail jumpto another shellcode start32 byte32 byte......512 bytes linked shellcode1234..................3.4 Detecting Heap Taichi attacks
Enhanced NOZZLE detection.
From the above discussion, we can see that the assumptions made
by NOZZLE are not necessary for a reliable heap-spraying attack.
NOZZLE can be enhanced to detect some of the new attacks by
considering the effect of memory allocation granularity. The key is
that all the landing positions should not be treated as the same. In-
stead, an enhanced NOZZLE algorithm should count the numbers of
landing positions on each offset inside an “alignment-size segment”
and record these numbers into an array. For example, on a 64K-byte
aligned system, in a 1M-byte heap memory block, the three land-
ing positions at 0x00c0c, 0x10c0c, 0x20c0c number the
count at 0x0c0c as three. In the example of case study, the array
at offset 0x0c0c is counted as 8. Then we calculate the success
rate on each offset. In the example of case study, the success rate
on 0x0c0c is 8 ÷ 8 = 100% and on other positions the success
rates are 0 ÷ 8 = 0%. Any success rate over 50% means a poten-
tial threat that may trigger a shellcode with a high success rate. The
improved NOZZLE report a potential heap-spraying attack when it
ﬁnds an offset with success rate over 50%.
However, the enhanced algorithm cannot deal with the Type C
and D attack, where there are many copies of shellcode in one
heap memory block. The landing positions are different from each
other when analyzed statically because that they connect to differ-
ent shellcode copies and these shellcode copies are not connected
in the CFG. So, in Type C and D attack, the enhanced NOZZLE
calculates the success rate at offset 0x0c0c as 1 ÷ 8 = 12.5%.
We report our evaluation results of this enhanced algorithm in Sec-
tion 4.2.
Heap memory allocation in ﬁner granularity.
The main problem behind this new type of attack is the pre-
dictability of heap addresses resulted from the coarse granularity
of memory allocation. So a natural solution to prevent Heap Taichi
attacks and similar attacks is to aligning memory allocation at a
smaller-sized boundary. But we found it not easy to achieve in our
experiments, because several application-level libraries align allo-
cated memory objects by themselves.
There are many heap managers on different levels of a program,
each of which has its own heap management strategy. For exam-
ple, at the kernel level, there are “heap manager” in Windows,
“SLUB allocator” in Linux, and Address Space Layout Permuta-
tion (ASLP) [26] in Linux. At the library level, there are libraries
like jemalloc [23] and tcmalloc [35]. At the program level, we
found that Firefox implemented a memory allocator based on ob-
ject lifetimes named “JSArena” [25]. The heap manager on each
level always manages its own “chunks” and also tries to get the
chunks aligned on its own boundaries. Therefore, the granular-
ity enforced by lower levels may be ignored in higher levels. For
instance, jemalloc wraps VirtualAlloc and keeps its chunks
aligned at 2M-byte boundaries.
If the VirtualAlloc returns
a memory block not aligned at the 2M-byte boundary, jemalloc
frees the chunk and repeats the allocation until the returned mem-
ory block is aligned at the 2M-byte boundary.
To our understanding, the main reason for user-level alignment
is performance. However, our performance evaluation (discussed
in Section 4.3) showed that the gain in performance by the user-
level alignment is not signiﬁcant (less than 5% in our experiment).
Therefore, memory managers at all levels should use ﬁner memory
allocation granularity for better security, a trade-off by sacriﬁcing
a limited amount of performance.
Figure 5: Normalized attack surface.
N SAtypeA ≈ N SAtypeB
≈
=