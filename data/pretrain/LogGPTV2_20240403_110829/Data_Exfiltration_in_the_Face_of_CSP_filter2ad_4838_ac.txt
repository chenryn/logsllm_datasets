the web page online:
HTTP or HTTPS.
The web developer has the following options when placing
• The way in which the web page is served, either over
• How the automatic DNS prefetching policy is set, if
it is set at all. It can be set through a header in the
HTTP response, or using a  header
in HTML, possibly added through JavaScript.
• What the automatic DNS prefetching policy is set to,
if not the default value.
To maximize the attacker’s own odds, we assume that the
attacker always tries to enable automatic DNS prefetching
because it may facilitate the exﬁltration of information. To
carry out the attack, an attacker has a number of options:
• How the  header is injected that
sets the automatic DNS prefetching policy to “on”.
This can be accomplished by injecting plain HTML
or by document.write() or addChild() in JavaScript.
• The HTML element used to leak the information: an
 element or a  element with relationship
“dns-prefetch”, “prefetch”, “prerender”, “preconnect”,
“preload”, “subresource”, “next” or “prev”.
• How this leaky HTML element is injected: by injecting
plain HTML or by document.write() or addChild()
in JavaScript.
For every possible combination of scenario options, a web
page is automatically generated that tests whether the vic-
tim’s browser will leak information for this set of options.
The information to be exﬁltrated through the leaky HTML
element is unique for every combination of scenario parame-
ters. The web page is then loaded into the victim’s browser
and displayed for ﬁve seconds, while the attacker monitors
DNS and web traﬃc to his servers. After these ﬁve seconds,
the web page redirects the victim’s browser to visit the web
page with the next set of scenario parameters.
If a scenario’s unique identiﬁer is observed at the attacker
side, the attack is considered successful, meaning that the
CSP was unable to prevent data exﬁltration through this
particular combination of scenario parameters.
For this experiment, our list of browsers consisted of the
most popular desktop and mobile browsers according to Stat-
Counter [23]. These browsers are listed in Table 1.
5.2 Results
Table 1 summarizes all results for this experiment, indi-
cating which HTML elements allow an attacker to leak in-
formation through either DNS requests or HTTP requests.
The results for each browser in this experiment were pro-
cessed with the WEKA machine learning tool, resulting in
the data in Table 1.
In Table 1, we diﬀerentiate between
leaks that were always observed and those that occur under
certain circumstances, indicated by • and ◦ respectively.
Automatic DNS prefetching, for instance, does not always
leak information to an attacker because DNS prefetching
can be disabled by the web developer through the X-DNS-
Prefetch-Control HTTP header.
DNS prefetching can be forced through a link element with
the rel attribute set to “dns-prefetch”. If set, most browsers
then ignore the X-DNS-Prefetch-Control HTTP header:
Google Chrome, Microsoft Internet Explorer (MSIE), Mi-
crosoft Edge, Apple Safari and Google Chrome Mobile. The
only exception is Mozilla Firefox, which respects the HTTP
header despite this link element. MSIE and MS Edge will
only perform forced DNS prefetching for these link elements
if they are present in the original HTML code of the parent
web page, and not when added by JavaScript later on.
Strangely, Mozilla Firefox will perform DNS prefetching
and resource prefetching of other relationships, but only if
they were not added using addChild().
For rel=prefetch, MSIE and Edge will only leak through
DNS and HTTP requests when the parent web page is served
over HTTPS. Using rel=prefetch in MSIE, we observed a
single DNS and HTTP request from an HTTP web page,
but were enable to reproduce this later.
Document pre-rendering using rel=prerender leaks DNS
and HTTP requests in Chrome, Chrome Mobile and MSIE.
MSIE issued a DNS request when the parent web page was
served over HTTPS, but no actual resource was requested
from the web server. Chrome triggered DNS requests for all
tests, but only some resulted in a resource being retrieved
from the web server. We are unsure of why this happens.
For rel=subresource, Chrome Mobile and Opera Mobile
only prefetched resources when the parent web page was
served over HTTP.
Interestingly, Firefox is the only one to leak through rel=next.
No browser leaked through “preconnect”, “preload” or “prev”,
so the corresponding columns are not shown in Table 1.
5.3 Discussion
Table 1 shows that all tested browsers allow an attacker
to exﬁltrate information from a web page through DNS or
resource prefetching, despite the strict CSP policy.
The impact of an attack depends on the browser used by
the victim and what kind of information an attacker can
inject into a given web page. We distinguish all three sce-
narios: URL injection, HTML injection and JavaScript in-
jection. Table 1 indicates for each scenario whether a certain
browser is vulnerable in all cases ((cid:4)), vulnerable under some
conditions ((cid:3)) or not vulnerable (—).
URL injection From Table 1 we can see that Chrome,
Firefox, Safari, Chrome Mobile and Safari Mobile leak DNS
requests through automatic DNS prefetching, allowing an
attacker to determine whether a victim has visited the web
page containing the attacker’s URL.
An attacker in this scenario is not guaranteed to be able to
exﬁltrate data through automatic DNS prefetching, because
this mechanism is by default disabled for HTTPS web pages
and the X-DNS-Prefetch-Control HTTP header oﬀers web
developers the option to disable it altogether.
HTML injection For this scenario we can see that all
tested browsers, except UCBrowser, will allow an attacker
to leak information through DNS requests to an attacker-
controlled DNS server. Furthermore, the same browsers,
minus Safari and Safari Mobile, allow an attacker to leak in-
formation through HTTP requests via resource prefetching.
Since MSIE, MSIE Mobile and UCBrowser do not sup-
port CSP, they are vulnerable since an attacker may use
any HTML element to exﬁltrate information.
Edge can leak information through rel=dns-prefetch and
dns=prefetch, and our data shows that both cases have
859.
f
e
r
p
S
N
D
.
o
t
u
A
e
c
i
v
e
D
/
S
O
OSX ◦
Google Chrome 42.0.2311.90
W81
Microsoft Internet Explorer 11
Microsoft Edge 12 (Project Spartan) W10
OSX ◦
Mozilla Firefox 37.0.2
OSX
Opera 28.0.1750.51
OSX ◦
Apple Safari 8.0.5
◦
Google Chrome Mobile 42.0.2311.111 MG2
Android browser
AL5
Microsoft Internet Explorer Mobile 11 WP8
MG2
Opera Mobile 29.0.1809.92117
IP6
Apple Safari Mobile 8.0
UCBrowser 10.4.1.565
MG2
◦
DNS
request
via
GET request
via
h
c
t
e
f
e
r
p
-
s
n
d
•
◦
◦
◦
•
•
r
e
d
n
e
r
e
r
p
•
◦
•
•
h
c
t
e
f
e
r
p
•
◦
◦
◦
•
•
•
•
•
e
c
r
u
o
s
e
r
b
u
s
•
•
•
•
•
h
c
t
e
f
e
r
p
-
s
n
d
t
x
e
n
◦
t
x
e
n
◦
r
e
d
n
e
r
e
r
p
◦
•
h
c
t
e
f
e
r
p
•
◦
◦
◦
•
•
•
•
•
e
c
r
u
o
s
e
r
b
u
s
•
•
◦
•
◦
n
o
i
t
c
e
j
n
i
t
r
o
p
p
u
s
P
S
C
o
N
n
o
i
t
c
e
j
n
i
L
M
T
H
n
o
i
t
c
e
j
n
i
S
J
L