title:A Systematic Study of Elastic Objects in Kernel Exploitation
author:Yueqi Chen and
Zhenpeng Lin and
Xinyu Xing
A Systematic Study of Elastic Objects in Kernel Exploitation
Yueqi Chen
PI:EMAIL
The Pennsylvania State University
Zhenpeng Lin
PI:EMAIL
The Pennsylvania State University
Xinyu Xing
PI:EMAIL
The Pennsylvania State University
ABSTRACT
Recent research has proposed various methods to perform kernel
exploitation and bypass kernel protection. For example, security
researchers have demonstrated an exploitation method that utilizes
the characteristic of elastic kernel objects to bypass KASLR, dis-
close stack/heap cookies, and even perform arbitrary read in the
kernel. While this exploitation method is considered a commonly
adopted approach to disclosing critical kernel information, there
is no evidence indicating a strong need for developing a new de-
fense mechanism to limit this exploitation method. It is because
the effectiveness of this exploitation method is demonstrated only
on anecdotal kernel vulnerabilities. It is unclear whether such a
method is useful for a majority of kernel vulnerabilities.
To answer this question, we propose a systematic approach. It
utilizes static/dynamic analysis methods to pinpoint elastic ker-
nel objects and then employs constraint solving to pair them to
corresponding kernel vulnerabilities. In this work, we implement
our proposed method as a tool - ELOISE. Using this tool on three
popular OSes (Linux, FreeBSD, and XNU), we discover that elastic
objects are pervasive in general caches. Evaluating the effective-
ness of these elastic objects on 40 kernel vulnerabilities across three
OSes, we observe that they can enable most of the vulnerabilities
to bypass KASLR and heap cookie protector. Besides, we also ob-
serve that these elastic objects can even escalate the exploitability
of some vulnerabilities allowing them to perform arbitrary read in
the kernel. Motivated by these observations, we further introduce
a new defense mechanism to mitigate the threat of elastic kernel
objects. We prototype our defense mechanism on Linux, showing
this mechanism introduces negligible overhead.
CCS CONCEPTS
• Security and privacy → Operating systems security; Software
security engineering.
KEYWORDS
OS Security; Vulnerability Exploitation
ACM Reference Format: Yueqi Chen, Zhenpeng Lin, and Xinyu
Xing. 2020. A Systematic Study of Elastic Objects in Kernel Ex-
ploitation. In roceedings of the 2020 ACM SIGSAC Conference on
Computer and Communications Security (CCS’20), November 9–13,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS’20, November 9–13, 2020, Virtual Event, USA
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-7089-9/20/11...$15.00
https://doi.org/10.1145/3372297.3423353
2020, Virtual Event, USA. ACM, New York, NY, USA, 20 pages.
https://doi.org/10.1145/3372297.3423353
1 INTRODUCTION
Over the past years, security researchers have introduced many
defense mechanisms to harden the kernel, preventing it from being
exploited (e.g., [18, 58, 77]). Under the protection of these tech-
niques, common exploitation methods are no longer useful. For
example, the design of KASLR no longer allows an attacker to hijack
the control flow of the kernel and thus reliably jump to a particular
exploited function in memory.
Responding to the effort of kernel defense development, secu-
rity researchers recently devote significant energy to developing
methods to circumvent exploitation mitigation and kernel protec-
tion commonly adopted by OSes (e.g., [3, 20, 24, 27, 31, 34, 37, 41–
43, 45, 46, 57, 61]). Among all these efforts, one commonly adopted
approach is to leverage an overwriting primitive to manipulate
an elastic kernel object and thus bypass KASLR. Technically, this
method first leverages an overwriting capability to manipulate a
length field in a kernel object. The length field indicates the bound-
ary of an elastic buffer enclosed in the kernel object. By manipu-
lating this field, the attacker can trick the kernel into authorizing
him/her to read a memory region that he/she otherwise cannot be
entitled to. As we elaborate in Section 2, by placing a pointer in the
overread region referencing a global variable, the attacker could
utilize a disclosure channel to uncover that pointer to the userspace
and compute the kernel base address accordingly.
In the past, security researchers have utilized anecdotal kernel
vulnerabilities to demonstrate the effectiveness of this exploitation
practice in bypassing KASLR. They even show that this method
can be extended, potentially helping an attacker disclose a stack-
/heap cookie and even perform arbitrary read. However, by far, it is
unclear whether this exploitation approach is useful for a majority
of kernel vulnerabilities1. As such, we have no clue whether this
method should raise our serious concern and motivate us to develop
a new kernel defense to mitigate the threat of elastic kernel objects.
To answer this question, one instinctive reaction is to demon-
strate exploitability by manually crafting exploits of many kernel
vulnerabilities. However, given the sophistication of the kernel code,
this approach inevitably introduces a significant amount of manual
effort, limiting the possibility of scaling this approach to various
OSes. Moreover, given the complexity of kernel exploitation, the
conclusion drawn through this manual approach might heavily rely
upon the expertise of security researchers.
In this work, we design and develop a systematic method to
explore the effectiveness of the exploitation method mentioned
above. Our basic idea is to utilize static/dynamic analysis to identify
1Note that without further clarification, the kernel vulnerabilities we refer to are those
that corrupt (or, in other words, manipulate) data on a heap area. The vulnerabilities
with only a read capability are excluded.
Figure 1: The illustration of the anecdotal exploit perform-
ing buffer overread and uncovering the function pointer f_op
referencing the kernel function ext4_file_operations.
elastic kernel objects and then employ constraint solving to pair
elastic objects with corresponding kernel vulnerabilities. We im-
plement this approach as a tool and name it after ELOISE standing
for “ExploitabLe Object dIScovEry”. Using this tool, we show that
elastic kernel objects are pervasive in the kernel implementation
across three popular OSes (Linux, XNU, and FreeBSD). For many
vulnerabilities identified in these OSes, our tool could track down
at least one elastic kernel object (and sometimes more), which al-
lows an attacker to disclose heap/stack cookie, bypass KASLR, or
perform arbitrary read. Motivated by this observation, we further
introduce a new defense mechanism to mitigate the threat of elastic
kernel objects. Our basic idea is to isolate elastic kernel objects in
independent caches. In this way, most of the kernel vulnerabilities
are no longer able to manipulate the data in an elastic object and
thus trick the kernel into disclosing the critical information to the
userspace.
In summary, this paper makes the following contributions.
• We design and develop a systematic method, demonstrating that
a commonly adopted exploitation method is a severe threat to
existing kernel defenses. It allows a majority of kernel vulnera-
bilities to disclose heap/stack cookie or bypass KASLR (27 out of
40). Besides, it enables some vulnerabilities to perform arbitrary
read in the kernel (8 out of 40).
• We implement our systematic method as a tool – ELOISE that
facilitates the discovery of elastic kernel objects and their pair-
ing with corresponding vulnerabilities. A user study shows that
the tool could significantly expedite the development of kernel
exploits.
• We design and prototype a new defense mechanism on Linux to
mitigate the threat of elastic kernel objects. Experiments show
that the new defense significantly mitigates the threat of elastic
objects and, more importantly, introduces negligible overhead to
an OS (0.19%).
2 BACKGROUND
In this section, we define elastic kernel objects. Then, we briefly
describe how to use these objects to perform exploitation and thus
bypass kernel mitigations, followed by the challenges of this ex-
ploitation method. Finally, we discuss the threat model.
What is an elastic object? An elastic object always contains a
length field that controls the size of an elastic kernel buffer. When
the kernel access the data in the buffer, the length field indicates the
range of the data that the kernel can read or write. As is summarized
in the Appendix A.1, the implementation of an elastic structure/ob-
ject is very diverse. For example, an elastic object could be a kernel
object that encloses the elastic buffer as part of the object (see the
1st in Figure 5) or an object that contains a pointer referencing a
buffer outside the object (see the 2nd in Figure 5). Using elastic ob-
jects, the kernel developers could minimize their need for manually
managing allocated memory [21] and, more importantly, upgrade
the performance of kernel execution by improving the cache hit
rate [64].
How to use an elastic object to bypass exploit mitigation? We
use a real-world example to illustrate how to leverage an elastic
object to perform kernel exploitation and bypass mitigation. As is
depicted in Figure 1, xfrm_replay_state_esn is an elastic kernel object
that contains an elastic buffer bmp at the end of the kernel object.
bmp_len is a length field that controls how many bytes the system
call recvmsg could read data from bmp and return to the userland.
To perform exploitation, an attacker could utilize the overwriting
ability from the vulnerability to enlarge the value of bmp_len and
thus obtain the ability to disclose the data in bmp buffer and the
kernel object adjacent to xfrm_replay_state_esn. As is illustrated in
Figure 1, the kernel object next to xfrm_replay_state_esn contains
a function pointer referencing ext4_file_operations. Through the
buffer overread, the attacker could disclose the address of the func-
tion, calculate the base address of kernel code, and eventually bypass
KASLR.
In addition to bypassing KASLR, an elastic object can also facili-
tate the disclosure of stack/heap cookies and even enable arbitrary
read. For example, if the elastic buffer is located on the stack, an
overread of this buffer can cause access to unauthorized data on the
stack (such as stack cookie). If the buffer is located on the heap and
its adjacent slot is in free status, the overread could unveil the freed
slot’s metadata and thus leak the encoded heap cookie accordingly.
For some vulnerabilities, an attacker can tamper the value of the
pointer arbitrarily. In this case, the attacker can access nearly any
memory addresses, and an arbitrary read can be easily granted.
Challenges of using elastic objects for kernel exploitation.
To perform the exploitation described above, an adversary first has
to ensure a kernel implementation uses the elastic kernel objects.
However, given the complexity of kernel code and the diversity
of kernel versions, it is extremely labor-intensive to track down
such kernel objects by auditing kernel code manually. Second, even
if a kernel implementation relies upon elastic kernel objects, the
adversary also has to guarantee the existence of leaking channel.
Through this channel, he/she could pass the data stored in the elastic
buffer (i.e., the buffer the size of which is indicated by the length
fields in the kernel object) back to a userland process. However,
there has not yet been a systematic approach to pinpointing the link
between elastic kernel objects and the userland process. Third, after
identifying the elastic kernel objects with the potential to leak data
to userland, it does not imply the adversary could utilize that object
to leak critical kernel information. Given a vulnerability corrupting
data in a particular cache/zone, an attacker cannot guarantee he/she
could allocate his desired kernel object to the same cache. Even if
both the vulnerable and elastic objects share the same cache/zone,
the attacker still needs to ensure the vulnerability gives him a
sufficient ability to manipulate the length field tied to the elastic
buffer.
Threat model & assumptions. In addition to the defense mecha-
nisms that the exploitation method aims to bypass, this work first
…vul objbmpf_opxfrm_replay_state_esnbmp_lenbmp_lenoverwriteoverreadext4_file_operationsassumes that the kernel is armed with other exploitation mitiga-
tions and kernel protection mechanisms, such as SMEP and SMAP
protection [17], KPTI protection [19], and W⊕R. These protections
and mitigations are the kernel defenses most commonly enabled
and adopted in FreeBSD, Linux, and XNU. Second, we assume the
kernel heap freelist has been randomized on both Linux and XNU
(FreeBSD has no such protection). However, since there have al-
ready been exploitation methods [6, 28, 44] decisively bypassing
kernel freelist randomization, without further clarification, this
research does not consider it the obstacle of the general exploita-
tion method. Third, it is very typical that an attacker has only one
zero-day vulnerability in hand. Therefore, we do not assume the
attacker has additional vulnerabilities to facilitate the exploitation
and thus the mitigation circumvention. Finally, the capability of a
vulnerability used in this work indicates at which memory region
an adversary could overwrite data freely. Since an attacker can
obtain a vulnerability capability from a PoC program which only
panics kernel, we conservatively assume an attacker cannot find
capabilities other than that manifested through the PoC program.
For example, if a PoC program overwrites only four bytes of kernel
memory on the heap at the time of kernel panic, we conservatively
assume the attacker could obtain only the four-byte overwriting
capability.
3 TECHNICAL APPROACH
To tackle the challenges mentioned above, we first introduce a
method to identify a set of elastic object candidates in the kernel.
Then, we specify how to filter out the elastic objects useful for
bypassing exploitation mitigation. Finally, we introduce the method
for pairing kernel vulnerabilities with corresponding elastic objects.
3.1 Identifying Elastic Object Candidates
Tracking down elastic structure candidates. Recall that an elas-
tic object has to contain a length field. As a result, we first examine
the existence of an integer variable in kernel structures. Due to the
complexity of kernel implementation, the definition of a structure
could involve other structural variables. To ease the integer variable
identification and reduce possible mistakes, before looking for the
integer field in structures, we go through each of the field members
in the structure and flatten that structure as follows.
Given a structure S, if its field member fi is a structural variable,
we replace fi with all its field members [fi1, fi2, ..., fin]. If the
field member fi is an array with more than two dimensions, we
compute its total size and replace it with a single-dimensional
array accordingly. If the field member fi is a union variable or a
nested union, we duplicate the corresponding field member lists by
copying the field members in each union and thus obtain a set of
new structures {S1, S2, ..., Su} where u is the number of different
definitions inside the union.
In this work, we repeat the process above recursively until no
more operations above can be further applied. Intuition suggests
that by following the recursive procedure to pre-process a structure,
each of the field members in that structure can be turned into either
an ordinary data type (e.g., char, int*) or a single-dimensional ar-
ray. With this, we can easily pinpoint integer variables in structures
and deem a structure with an integer field as our candidate.
Pinpointing elastic object candidates at allocation sites. With
the candidate structures in hand, our next step is to first track
down all the sites of heap memory allocation. Then, we examine
whether allocated objects at these sites are in the types of candidate
structures. Finally, we examine whether reaching these allocation
sites requires any root privilege. In this work, we preserve all the
objects that survive the checks above, and treat them as our elastic
object candidates.
To pinpoint the sites of heap memory allocation, we search
for critical kernel functions in the kernel source code. In Linux,
FreeBSD, and XNU, there are two types of kernel functions respon-
sible for allocating memory on the heap. One is kmalloc, kalloc, and
malloc series which are used for object allocation on the general
cache/zone. The other is kmem-cache, mcache_alloc and uma_zalloc se-
ries which are designed for allocation on the special cache/zone. In
our design, we deem the invocation of these functions in the kernel
code as the sites of memory allocation.
To determine the type of objects allocated at these sites, we
analyze the return values of these functions. The reasons are ❶
their return values are always pointers referencing the objects
allocated, and ❷ by analyzing the type of the return value, we can
easily point out whether the type of an allocated object is within
the set of candidate structures. To be more specific, when analyzing
the types of return values, we follow a use-def chain and resolve
memory alias. As is stated in Section 4, we implement our use-
def chain analysis by using LLVM. As a result, when performing
use-def analysis, we keep track of those instructions relevant to
type casting, pointer dereferencing, and argument passing. The
operands of these instructions explicitly reveal the object type. By
using this information, we can easily infer and conclude the type
of each allocated object accordingly.
To determine the privilege required to allocate a kernel object,
we check that, in between, whether there is at least one path that
does not involve the kernel function call capable(CAP_SYS_ADMIN) for
Linux, priv_check, priv_check_cred for FreeBSD, and priv_check_cred()
for XNU. The reason is that a call to any of these functions on the
paths toward an allocation site indicates root permission and the
failure of exploitation2. Besides, we also check whether any of the
callee functions along the path towards an allocation site accesses
a device that only privileged users can visit. The reason behind
this is that access to privileged devices implies a high privilege
for corresponding object allocation. In this work, we examine the
function’s access to privileged devices by using device operator
structure (e.g., struct cdevsw). Such a structure contains a function
pointer through which we can obtain the access control list of the
corresponding devices. If the device’s permission is root, we will
exclude corresponding allocation sites and candidate objects.
Profiling elastic object candidates. Recall that our proposed
method includes a component that pairs a vulnerability with cor-
responding elastic kernel objects for mitigation circumvention. To
enable this component, as we will discuss in Section 3.3, we need to
know the property of elastic objects (e.g., the cache/zone to which
an elastic object belongs). As a result, we further perform analysis
and profile kernel object as follows.
2Note that system calls without the root permission requirement can also be in the
privilege category. However, they do not tie to the highest permission. In this work,
we, therefore, treat them as unprivileged ones.
a kernel buffer nor that they support data disclosure. As a result, we
further narrow down objects with such properties. To do this, we
summarize a set of critical kernel functions (Table 3 in the Appendix)
and deem the calling sites of these functions as the leaking anchors
through which an attacker could potentially uncover data in a
kernel buffer to the userspace. With these leaking anchors in hand,
we then perform a backward data flow analysis, filtering out the
candidate objects that satisfy the properties mentioned above.
As is shown in Table 3 (presented in the Appendix), all the critical
kernel functions contain two important parameters. One indicates
the length of kernel data to be disclosed to the userland (e.g., the
second argument attrlen in the function nla_put_nohdr()). The other
specifies the address from which the kernel data would be retrieved
(e.g., the last argument data in the function nla_put_nohdr()). In this
work, we take both of these arguments as the taint sources and
perform interprocedural backward taint analysis for each of the
taint sources individually.
Starting from the taint sources indicating the length of kernel
data (e.g., the argument n in Figure 2), we keep track of the data
flow reversely and examine the memory regions from which these
arguments originate. If the value of the length argument originates
from a variable allocated on the stack or global memory region, we
discard the invocation site of the corresponding kernel function
because, as is mentioned earlier, the success of the exploitation
relies upon the power of overwriting data on the kernel heap. A
length argument originating from a stack, or global variable does
not hold the requirement of launching the attack successfully. For
the length argument tied to a variable on the kernel heap region