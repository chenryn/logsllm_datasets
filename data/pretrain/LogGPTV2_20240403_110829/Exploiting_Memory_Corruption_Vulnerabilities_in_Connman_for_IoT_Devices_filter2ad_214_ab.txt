Type A or Type AAAA responses. We select Type A for
its universality. A basic DNS server is created to respond to
requests. The DNS responses must appear legitimate, other-
wise Connman dumps the packet as a bad response and never
enters the vulnerable portion of code. Our DNS server must
ﬁrst craft a legitimate response header to each DNS query,
then place the exploit code into the returned record itself. A
simple Python DNS server is created to perform this function,
which copies the relevant portions of the query from the target
machine’s packet, inserts the proper ﬂags, and encodes the
malicious code into the record response.
A. No Protections Enabled
1) Intel x86: Our ﬁrst experiment constitutes a code-
injection exploit on the x86 architecture. W⊕X, ASLR, and
stack protectors (canaries) are all disabled through compilation
options. With no system protections enabled, we utilize a
standard buffer-overﬂow attack [30]. Upon conﬁrmation that
Connman does crash as expected with the oversized DNS
Type A response, we begin examining Connman’s runtime
activities using a debugging tool. The tool we select for
use is the GNU Project debugger, gdb, in Ubuntu. Using
gdb, we are able to isolate the sections of memory oc-
cupied by the stack of the parse_response function.
After discovering these memory locations, we construct a
payload to exploit the vulnerability. This payload consists
of a NOP sled [30], consisting of repeated \x90 (xchg
eax, eax) instructions, followed by assembly instructions to
execute execve("/bin/sh", ["/bin/sh"], NULL),
and ﬁnishes with repeating new return addresses pointing
at the NOP sled. We pass this payload to Connman via
our man-in-the-middle DNS server, and successfully spawn
a root shell on the targeted machine. Subsequently, the same
attack is successfully carried out against Connman on the x86
architecture without the aid of the gdb debugging tool.
2) ARMv7: : In the next exploit, we recreate the Intel x86
buffer-overﬂow attack on ARMv7 architecture. We make the
following small changes to adapt the x86 attack to ARMv7
(Raspberry Pi v3b+). Unlike x86, ARMv7 does not have
a single-byte NOP command. Instead, we use a 4-byte code
string, \x01\x10\xa0\xe1, which on ARMv7 translates
to mov r1, r1, an effect-free operation. We modify the
shellcode to utilize ARMv7 assembly instructions instead of
x86. On the ARMv7 platform, a few memory locations that are
overwritten which Connman expects to be NULL in a check
prior to the pop {pc} command in parse_response. We
must place NULL values in these locations for the ARMv7
exploit. This exploit is successful on a default conﬁguration
of Connman, installed with developer provided CFLAGS and
ASLR disabled.
B. W⊕X Enabled
1) Intel x86: Our next experiment
targets a successful
exploit with stack execution protections enabled. We use a
return-to-libc [50] attack to create the attack on x86. A
return-to-libc attack leverages the fact that, without ASLR
enabled, the location of libc in system memory is static.
In this manner, functions can be accessed through the libc
library that the target executable does not call. In our case,
it allows us to utilize system(), which is not referenced
within the Connman program. With access to the victim
machine, we again utilize gdb to examine the memory layout
of Connman as it executes. Using gdb, we ﬁnd the location
of the libc functions system() and exit(), allowing us
to construct the payload. This payload utilizes explicit calls to
the __libc_system() function to execute "/bin/sh"
This attack is successful against x86 architecture.
2) ARMv7: Our next experiment is against the ARMv7
architecture with W⊕X protection. Unlike Intel x86, ARMv7
does not pass arguments directly from the stack. Therefore, a
traditional return-to-libc attack is not possible, as the attack
does not have the ability to manipulate registers. Instead, we
utilize a gadget-based approach for this exploit. Gadgets [50]
are small blocks of assembly code, ending in ret commands
(Intel x86), or a branch or pop pc command (ARMv7), that
chain several instruction sequences together.
249
Our approach can be delineated into three steps: (1) we
locate a gadget
that can be used to load arguments into
registers; (2) we use this gadget to load the r0 and r1 registers
with the appropriate arguments; and (3) we load the pc register
with the memory address of execlp@plt, the function we
utilize to switch Connman’s execution and spawn a root shell.
To ﬁnd an appropriate gadget to load the needed registers,
we utilize the open-source program ropper [51]. Among
other functionality, this program allows an easy way to display
information about a binary, including it’s compiled assembly
instructions (gadgets). With ropper, a suitable gadget is
found, in our case pop {r0, r1, r2, r3, r5, r6,
r7, pc}.
Next, we use this gadget to load the r0 and r1 registers
with the appropriate arguments. For our exploit, these argu-
ments are "/bin/sh" and NULL, respectively. The gadget
in step (1) is used to pop these values from the stack into the
correct registers.
Finally, we utilize the gadget to invoke execlp@plt, a
Procedure Linkage Table (PLT) reference. The PLT allows the
program to make calls from its shared text section to external
functions by loading the memory location of libraries at run-
time and linking to speciﬁc functions using their offset from
the start of the memory block [52]. This allows the program
to make external function calls without knowing the memory
address of the program, a requirement for an executable to
function with ASLR enabled. While ASLR is not enabled for
this exploit, making a call in this manner allows us to utilize
the same code in our following ASLR exploit. This call is
made by using the gadget in step (1) to pop the value into the
pc register.
1
2
3
4
5
6
7
8
9
. . .
+ ’\xb1\x12\x01\x00 ’ #Pop r0−r7 , pc
+ ’\ xe4\x53\xd8\x76 ’ 1 r0 ,
s t a t i c
+ ’\x00\x00\x00\x00 ’ # r1 , NULL t o t e r m i n a t e
e x e c l p argument a r r a y
+ ’\x88\ xe9\ x f f \ x7e ’ # r2
+ ’\x97\ x f f \ x f f \ x f f ’ # r3
+ ’\ xc4\xd2\ x f f \ x7e ’ # r5
+ ’\x59\x58\ xf0\x76 ’ # r6
+ ’\x00\x00\x00\x00 ’ # r7 p l a c e h o l d e r s
+ ’\xd0\xb2\x01\x00 ’ )
# pc t o e x e c l p @ p l t
/ bin / sh
Listing 2. execlp ROP chain for ARMv7
Listing 2 shows the code for this exploit. Line 1 shows the
explicit call to the gadget to load registers r0, r1, and pc.
This gadget pops the next 32 bytes of memory, separating
each 4 bytes and placing them into separate registers. The
gadget loads many more registers than are needed simply to
call execlp@plt. However, utilizing a gadget with fewer
registers results in a SIGSEV in the parse_rr function, as
the locations occupied by line 7 and line 8 overwrite portions
of memory required for a mvn.w call in parse_rr. This
gadget is selected to overcome that obstacle.
Line 2 and Line 3 are the 4 byte values assigned to r0 and
r1 respectively. Line 2 is the static memory location of the
full string /bin/sh, loaded into r0. This string is located
in the libc portion of memory, and is not randomized with
ASLR disabled. Line 3 is a 4 byte NULL sequence, loaded into
250
r1. These two arguments, /bin/sh and NULL, are loaded
into r0 and r1 to be passed to execlp@plt.
The next 20 bytes (Lines 4-8) are placeholder values.
Starting at line 4, the gadget pops these values into r2, r3,
r5, r6, and r7 respectively. We select the values for these
placeholders after examining the parse_rr function during
run-time, and seeing the expected values for those positions.
Finally, the gadget loads the pc with Connman’s PLT
reference to execlp, which is the 4 bytes located on Line 9.
This executes the execlp@plt function call. execlp is a
member of the exec family, similar to execve. The main
differences are execlp allows the use of relative rather than
explicit addresses for the ﬁle to be executed, and allows a
variable number of arguments to be passed. For this reason,
the ﬁnal argument must be a NULL to indicate the end of the
passed arguments [53], which is the reason for line 3.
With this exploit, we successfully spawn a root shell in
Connman utilizing gdb. The exploit is then successful on
a default installation of Connman without the aid of gdb
and with the developer default CFLAGS enabled. ASLR is not
enabled for this exploit.
C. W⊕X and ASLR Enabled
1) Intel x86: Our third experiment involves constructing an
exploit with both W⊕X and ASLR enabled. Enabling ASLR
prevents our previous attack strategy, ret-to-libc, from
working, as ASLR randomizes the location of libc at run-
time. Without a memory leak exposing the current position
of the library, it becomes difﬁcult for an attacker to reliably
guess the position of needed functions within the library to
make explicit calls.
To circumvent this protection, we employ a return-oriented
programming (ROP) attack [50]. ROP attacks work by chain-
ing gadget calls to redirect the execution of a program to
cause arbitrary actions. Each of these gadgets ends in a ret
instruction, allowing these gadgets to be chained together to
perform complicated, multi-step instructions similar to a code-
injection.
(2) using these gadgets
Our ROP attack is conducted in three steps:
(1) we
locate necessary gadgets and the characters "/bin/sh"
in Connman memory;
and
memcpy@plt, we copy the characters into .bss memory
block to form the string /bin/sh; and (3) we invoke
execlp@plt using the crafted string to spawn a root shell.
On ARMv7, we utilize the program ropper to ﬁnd the
required gadgets, as discussed in §III-B2. On x86, we use an
open-source program called ROPgadget [54]. ROPgadget
provides similar functionality to ropper, displaying com-
piled binary information. To successfully craft this exploit,
a gadget in the form of pop pop pop ret is found. This
gadget is selected for its ability to remove the next 16 bytes
from the stack. The gadget reference comes directly after the
memcpy@plt reference, allowing the instruction pointer to
remove the arguments (Listing 3 Lines 3-6) before proceeding
on to the next call. The ﬁrst three pop commands remove the
arguments from the stack, and the ﬁnal pop removes four
1
2
3
4
. . .
+ ’\ xf0\x29\x05\x08 ’ # e x e c l p @ p l t
+ ’\x14\x14\x14\x14 ’ # random b y t e s
+ ’\x01\x02\x12\x08 ’ # b s s
+ ’\x00\x00\x00\x00 ’ # arg a r r a y ( n u l l )
s t r i n g (\ b i n\ sh )
Listing 4. memcpy chain ROP exploit
bytes of random values following the memcpy arguments,
required for the add esp, 0xc; pop ebp; at the end
of the memcpy function.
Next, we combine this gadget with memcpy@plt calls to
craft the string /bin/sh in the .bss portion of memory.
Common practice is to use strcpy to accomplish this
goal. However, Connman contains no references to strcpy,
instead replacing them on compilation with _strpy_chk.
Fortunately, since Connman contains references to memcpy,
we still can craft the needed string. The memcpy function
takes three arguments: src, dest, and length. With the
x86 architecture, these variables can be passed via the stack.
Utilizing memcpy, our goal is to put the string "/bin/sh"
somewhere in Connman’s memory. The .bss section is
selected, as it
is uninitialized memory and therefore not
randomized with ASLR. Single character references are found
in Connman using the -memstr argument in ROPGadget.
Using these locations as the source, offsets from the beginning
of the .bss section of memory as the destination, and a length
argument of 1, we successfully craft the "/bin/sh" string
in the .bss.
1
2
3
4
5
6
. . .
+ memcpy #memcpy@plt
r e f e r e n c e
+ ppppr # pop pop pop pop r e t
+ ’\x01\x02\x12\x08 ’ # b s s + 1
+ ’\x54\x81\x04\x08 ’ # ’ / ’
+ i n t v a l # i n t = 1
+ g a r b a g e # garbage f o r add esp , 0xC ; pop ebp
; @ memcpy end
Listing 3. memcpy chain ROP exploit
Listing 3 shows the memcpy portion of the ROP chain.
The +memcpy and +pppr references are to .text mem-
ory locations of these gadgets, +int_val is a variable with a
hex value of one (0x00000001), and +garbage is 4 bytes
of random values, speciﬁcally \xAA\xAA\xAA\xAA. These
random values are required for the aforementioned code at
the end of memcpy. The code snippet in Listing 3 shows
the portion of code used to copy the "/" character into the
.bss portion of memory. This code block is repeated for
each character of the string /bin/sh, increasing the .bss
offset by one each time until the entire string is copied into