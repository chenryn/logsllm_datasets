    0000000194ce701c t 
    0000000194ce7090 t 
    0000000194ce70c4 t 
    0000000194ce71e4 t 
    0000000194ce72e0 t 
    0000000194ce72e8 t 
    0000000194ce72f0 t 
    0000000194ce735c t 
    0000000194ce7444 t 
    ...
不过，首先让我们对提取的iOS dylib进行重新定位，以便它们的地址(在反汇编程序/反编译器中查看时)与崩溃报告中的地址相匹配。
要对每个提取的dylib进行重新定位，我们使用崩溃报告中的基地址(例如CoreEmoji的0x1886a6000)。在Hopper中，可以通过Modify
-> Change File Base Address…来重新建立二进制文件的基地址：
[](https://p4.ssl.qhimg.com/t012c57ac7295f94a20.png)
一旦重设好了，我们就可以解决符号的问题了。
我不确定这样做的最佳方式，所以我只是利用了每个dylib的MacOS版本。具体来说，我将符号化的x64汇编(MacOS)与无符号的ARM64汇编(iOS)“匹配”。虽然有手动过程，但这工作得很好！
例如，以地址0x0000000196862c00(来自调用堆栈中的第9帧)为例。下面是方法的完整反编译(在IOS ResponseKit
dylib中)，其中包含地址0x00000196862c00：
    //iOS ResponseKit
    int _194d0ab58(int arg0) {
        r25 = loc_19147d5e0(r2);
        r22 = loc_19147d5e0(r4);
        loc_19147d5e0(r5);
        r27 = *_RKMessageResponseDontOverrideLanguageID | r7;
        loc_19147d5e0(r6);
        loc_19147d5d8(arg0, 0x1b3e37900, r25, r3, r22, r5, &var_58, 0x0, r27);
        loc_19147d5e8();
        loc_19147d5dc(r26);
        loc_19147d5dc(r22);
        loc_19147d5dc(r25);
        loc_19147d5e0(var_58);
        loc_19147d5dc(r20);
        loc_19147d5dc(r21);
        r0 = loc_19147d7cc(r19);
        return r0;
    }
如果我们反编译MacOS的ResponseKit(/System/Library/PrivateFrameworks/ResponseKit.framework)，我们可以在RKMessageResponseManager
responsesForMessageImp：maximumResponses：forConversationHistory：forContext：withLanguage：options：方法中找到“匹配的”x64反编译(请注意对RKMessageResponseDontOverrideLanguageID符号的引用)：
    * @class RKMessageResponseManager */
    -(void *)responsesForMessageImp:(void *)arg2 maximumResponses:(unsigned long long)arg3 forConversationHistory:(void *)arg4 forContext:(void *)arg5 withLanguage:(void *)arg6 options:(unsigned long long)arg7 {
        r14 = [arg2 retain];
        r15 = [arg4 retain];
        var_38 = [arg5 retain];
        var_30 = arg6;
        rbx = *_RKMessageResponseDontOverrideLanguageID;
        r13 = [arg6 retain];
        rax = [self responsesForMessageWithLanguageDetectionImp:r14 maximumResponses:arg3 forConversationHistory:r15 forContext:arg5 withLanguage:&var_30 inputModes:0x0 options:rbx | arg7];
        [var_38 release];
        [r15 release];
        [r14 release];
        r14 = [rax retain];
        rbx = [var_30 retain];
        [r13 release];
        [rbx release];
        rax = [r14 autorelease];
        return rax;
    }
现在我们知道iOS ResponseKit dylib中的int_194d0ab58方法实际上是RKMessageResponseManager
responsesForMessageImp：maximumResponses：forConversationHistory：forContext：withLanguage：options：方法(注意对RKMessageResponseDontOverrideLanguageID符号的引用)。
一旦对dylib进行了重新基和(手动)符号化，就更容易理解这个bug了，因为方法名对它们的用途有相当的描述性。
我们将从分析崩溃线程(线程6)的调用堆栈中的地址开始，以揭示这个远程iOS bug的根本原因。
跳过对libDispatch.dylib的调用，从堆栈帧#10开始，并将每个地址映射到它所属的符号化方法(或块)：
    #10  ResponseKit   0x00000001968619f0
    -[RKMessageResponseManager responsesForMessage:maximumResponses:forContext:withLanguage:options:completionBlock:]
    #9 ResponseKit  0x0000000196862c00
    -[RKMessageResponseManager responsesForMessageImp:maximumResponses:forConversationHistory:forContext:withLanguage:options:]
    #8 ResponseKit  0x0000000196862e78
    -[RKMessageResponseManager responsesForMessageWithLanguageDetectionImp:maximumResponses:forConversationHistory:forContext:withLanguage:inputModes:options:]:
    #7 ResponseKit  0x00000001968739b4
     +[RKMessageClassifier messageClassification:withLanguageIdentifier:conversationTurns:]:
    #6 ResponseKit  0x0000000196872e9c
    -[NSLinguisticTagger languageOfRange:withAdditionalContext:withPreferredLanguages:]
    #5 ResponseKit  0x00000001968754ac
    +[RKUtilities removeEmoji:]
    #4 CoreEmoji  0x00000001886a8ebc
    CEMStringContainsEmoji
    #3 CoreEmoji  0x00000001886b2c80
    unnamed subroutine
    #2 CoreEmoji  0x00000001886b2354
    unnamed subroutine
    #1 CoreEmoji  0x00000001886b2354
    unnamed subroutine
    #0 CoreFoundation  0x0000000182922efc
    CFStringCompare + 0x38
好吧发生什么事了？看起来是这样的，当接收到消息时，ResponseKit会对消息进行分类，并且(如果某些分类是真的话)调用+[RKUtilities
removeEmoji:]方法。这方法调用CoreEmoji动态库来执行实际的表情符号移除。
> iOS为什么要删除表情符号？我们很快就会讲到的！
在调用一些未命名的子程序后，CoreEmoji调用CFStringCompare函数，该函数在地址0x0000000182922efc处的指令处崩溃。
>
> 地址0x0000000182922efc是故障指令的地址。它是调用堆栈(即帧#0)中的最终地址，也是崩溃报告“ARM线程状态”部分中的pc(程序计数器)寄存器中的最终地址。
CFStringCompare在0x0000000182922efc有什么指令？
    0000000180dcaefc         ldr        x8, [x21]
ldr
arm指令将“程序相对偏移或外部地址加载到寄存器”([arm](http://infocenter.arm.com/))。在这里，它试图取消引用，并将值从x21寄存器加载到x8寄存器中。
查看崩溃报告中的“ARM线程状态”部分，可以看到x21寄存器在崩溃时是空的(0x00000000000000)：
    Thread 6 crashed with ARM Thread State (64-bit):
        x0: 0x0000000000000000   x1: 0x00000001add1ad38   x2: 0x0000000000000000   x3: 0x00000001ad364438
        x4: 0x0000000000000000   x5: 0x0000000000000001   x6: 0x0000000000000000   x7: 0x0000000000000000
        x8: 0x0000000000000000   x9: 0x00000001b4e15930  x10: 0x0000000ffffffff8  x11: 0x0000000000000040
       x12: 0xffffffffffffffff  x13: 0x0000000000000001  x14: 0x0000000000000000  x15: 0x00002d0000002d00
       x16: 0x0000000000000000  x17: 0x0000000000002d00  x18: 0x0000000000000000  x19: 0x0000000000000000
       x20: 0x00000001add1ad38  x21: 0x0000000000000000  x22: 0x0000000000000000  x23: 0x00000001c4864cc0
       x24: 0x00000001000404ef  x25: 0x0000000000050000  x26: 0x0000000103d059e4  x27: 0x0000000103d059e4
       x28: 0x0000000000000000   fp: 0x000000016f1a5b20   lr: 0x00000001886b2354
        sp: 0x000000016f1a5b00   pc: 0x0000000182922efc cpsr: 0x80000000
如果试图取消引用空地址(指针)，这将与EXC_BAD_ACCESS(SIGSEGV)一起崩溃，这正是崩溃报告中给出的确切原因：
    Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
    Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000
那么x21中的值应该是什么呢？很明显，一个有效地址。
但是，查看故障指令之前的指令(在CFStringCompare函数中)的arm64反汇编代码，我们可以看到它是传递给CFStringCompare的第一个参数。
    _CFStringCompare:
    0000000182922ec4         stp        x22, x21, [sp, #-0x30]!                     
    0000000182922ec8         stp        x20, x19, [sp, #0x10]
    0000000182922ecc         stp        x29, x30, [sp, #0x20]
    0000000182922ed0         add        x29, sp, #0x20
    0000000182922ed4         mov        x19, x2
    0000000182922ed8         mov        x20, x1
    0000000182922edc         mov        x21, x0
    0000000182922ee0         tbz        x21, 0x3f, loc_182922efc        ;take this
    loc_182922ee4:
    0000000182922ee4         adrp       x8, #0x1b3519000                            
    0000000182922ee8         ldr        x1, [x8, #0x308]                            
    0000000182922eec         mov        x0, x21
    0000000182922ef0         bl         0x181c1c900
    0000000182922ef4         mov        x3, x0
    0000000182922ef8         b          loc_182922fd0
    loc_182922efc:
    0000000182922efc         ldr        x8, [x21]                       ; b00m, we crash as x21 is NULL
也许反编译更能说明问题：
    _CFStringCompare
    r21 = theString1;
    if ((r21 & 0xffffffff80000000) != 0x0) {
         r3 = loc_181c1c900(r21, *0x1b3519308);
    }
    else
    {
         r8 = *r21; //b00m, we crash as this is NULL
    }
反汇编0x0000000182922edc，我们可以看到第一个参数(在X0寄存器中传递)被移动到x21寄存器中：
    mov        x21, x0
在0x0000000182922ee0(检测指针是否被“标记”)的测试之后，代码跳转到地址0x0000000182922efc，在那里取消对空x21寄存器的引用，从而导致崩溃。
> 寄存器x21上的检查(在此程序集指令中实现；TBZ x21、0x3f、loc_182922efc)是检查指针是否“标记”的检查。  
>  标记指针是在iOS
> 7和MacOSX10.7中为64位架构引入的.带标记的指针是一种特殊的指针，它将数据直接存储到指针中，而不是进行内存分配。这具有明显的性能优势。[blog.timac.org](https://blog.timac.org/2016/1124-testing-> if-an-arbitrary-pointer-is-a-valid-objective-c-object/)