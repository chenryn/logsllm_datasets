did any of the existing IDS sensors pick up exploit-based attacks. Therefore,
this dataset is ideal to measure the false positive rates as well running times of
our algorithm. In order to speciﬁcally measure detection rates, we used exploits
generated using the Metasploit framework [3].
6.1 Detection
When performing detection against live network traﬃc, the exploit code detec-
tion sensor did not report the presence of exploit code in any of the network ﬂows.
The live traﬃc which was collected contained mostly HTTP ﬂows and these ﬂows
had the potential to raise false positives due to the ASCII text and branch in-
struction problem mentioned earlier. However, since we use further control and
data ﬂow analysis, none of the CFGs survived the process of elimination to raise
any alarms. The other types of network ﬂows were either binary or encrypted
and the reduced CFGs were far smaller in size and number, which were quickly
discarded as well. However, we warn against hastily inferring that our approach
has a zero false positive rate. This is not true in general because our technique
is probabilistic in nature and although the probability of a false positive may be
very small, it is still not zero. But this is already a signiﬁcant result since one of
the downsides of deploying an IDS is the high rate of false positives.
Next we studied detection eﬃcacy and possible ways in which false nega-
tives can occur. Using the Metasploit framework [3], it is possible to handcraft
not only several types of exploit code but also targeted for diﬀerent platforms.
There are three main components in the Metasploit framework - a NOOP sled
generator with support for metamorphism, a payload generator, and a pay-
load encoder to encrypt the payload. Therefore, one can potentially generate
hundreds of real exploit code versions. We are interested only in Intel-based
exploits targeted for Windows and Linux platforms. We discuss the interesting
representative test cases.
Metamorphic Exploit Code. Due to the nature of our detection process, the
payload of metamorphic code is not very diﬀerent from any other vanilla exploit
A Fast Static Analysis Approach
303
code. The Metasploit framework allows the generation of metamorphic NOOP
sleds. The following is the relevant code segment which is the output of the ’Pex’
NOOP sled generator combined with the ’Windows Bind Shell’ payload. Note
the diﬀerent single-byte opcodes which form the NOOP sled. We have also shown
portions of the payload which were a part of the ﬁrst valid chain encountered
when analyzing the ﬂow containing the exploit code. The corresponding signa-
ture which was generated was: 60 .* E3 30 .* 61 C3. Note that stack frame
which was created using pusha was popped oﬀ using popa, but just the mere
presence of stack-based instructions in the chain is deemed adequate evidence.
push esi
xchg eax,edi
dec eax
inc edi
00000001 56
00000002 97
00000003 48
00000004 47
. . .
00000009 60
0000000A 8B6C2424 mov ebp,[esp+0x24]
0000000E 8B453C mov eax,[ebp+0x3c]
00000011 8B7C0578 mov edi,[ebp+eax+0x78]
pusha
. . .
0000001F E330
. . .
00000051 61
00000052 C3
jecxz 0x51
popa
ret
Polymorphic Exploit Code. We generated a polymorphic exploit code using
the ’PEX encoder’ over the ’Windows Bind Shell’ payload. This encoder uses a
simple XOR-based scheme with the key encoded directly in the instruction. We
highlight the following segment of code, where 0xfd4cdb57 at oﬀset 0000001F
is the key. The encrypted payload starts at oﬀset 0000002B. Our approach was
able to detect this polymorphic code because of the conditions satisﬁed by the
loop instruction with esi register being initialized before the loop and refer-
enced within the loop. The corresponding signature which was generated was:
5E 81 76 0E 57 DB 4C FD 83 EE FC E2 F4. A caveat is that this signature is
very speciﬁc to this exploit code instance due to the key being included in the
signature. If the key is excluded then, we have a more generic signature for the
decryptor body. However, this requires additional investigation and part of our
future work.
call 0x1C
inc eax
pop esi
00000018 E8FFFFFF
0000001C FFC0
0000001E 5E
0000001F 81760E57DB4CFD xor dword [esi+0xe],0xfd4cdb57
00000026 83EEFC
00000029 E2F4
0000002B C7
sub esi,byte -0x4
loop 0x1F
db 0xC7
304
R. Chinchani and E. van den Berg
Worm Code. We used Slammer/Sapphire as the test subject. The worm code
follows a very simple construction and uses a tight instruction cycle. The whole
worm code ﬁts in one UDP packet. The payload used was an exploit against
the MS SQL server. Again, both versions of our approach were able to detect
the worm code and generated the signature: B8 01 01 01 01 .* 50 E2 FD,
which corresponds to the following portion of the worm code [4]. This is the ﬁrst
executable segment which satisﬁes the process of elimination and our algorithm
exits after raising an alert.
xor ecx,ecx
mov cl,0x18
push eax
loop 0x16
0000000D B801010101 mov eax,0x1010101
00000012 31C9
00000014 B118
00000016 50
00000017 E2FD
In our experience, both variations of our exploit code detection algorithm
were equally eﬀective in detecting the above exploit code versions. This was
mainly because the payload consisted of continuous instruction streams. How-
ever, carefully placed data bytes can defeat the fast disassembly scheme, making
the accurate scheme more relevant.
6.2 Performance Overheads
We compared our approach against a signature-based detection system - Snort.
Several factors contribute to the runtime overheads in both approaches. For
Snort, the overheads can be due to network packet reassembly, signature table
lookups, network ﬂow scanning and writing to log ﬁles. On the other hand, for
our approach, overheads are be caused by network packet reassembly, binary dis-
assembly and static analysis. We are mainly interested in understanding running-
time behavior, and therefore, implemented and compared only the core detection
algorithms. Moreover, since we conducted our experiments in an oﬄine setting,
all aspects of a complete implementation cannot be meaningfully measured.
The single most important factor is the network ﬂow size. In order to cor-
rectly measure running time for this parameter only, we either eliminated or
normalized other free parameters. For example, Snort’s pattern matching algo-
rithm also depends on the size of the signature repository while in our approach
signatures are a non-factor. We normalized it by maintaining a constant Snort
signature database of 100 signatures throughout the experiment. The bulk of
these signatures were obtained from http://www.snort.org and the rest were
synthesized. All experiments were performed on 2.6 GHz Pentium 4 with 1 GB
RAM running Linux (Fedora Core 3).
Figure 6 shows the results obtained by running both variations of our approach
against Snort’s pattern matching. We considered four kinds of network ﬂows
based on ﬂow content. As is evident from the plots, pattern matching is extremely
fast and network ﬂow size does not appear to be a signiﬁcant factor. In contrast,
the running time of our approach shows a non-negligible dependence on the size
of network ﬂows. Both variations of our approach display a linear relationship,
Fast Disassembly
Fast Disassembly
Accurate Disassembly
Accurate Disassembly
Snort
Snort
 0
 0
 5
 5
 10
 10
 15
 15
 20
 20
 30
 30
 35
 25
 25
 35
Flow size (KB)
Flow size (KB)
 40
 40
 45
 45
 50
 50
 55
 55
 60
 60
(a) HTTP (port 80)
Fast Disassembly
Fast Disassembly
Accurate Disassembly
Accurate Disassembly
Snort
Snort
)
)
s
s
c
c
e
e
s
s
(
(
e
e
m
m
T
T
i
i
)
)
s
s
c
c
e
e
s
s
(
(
e
e
m
m
T
T
i
i
 60
 60
 55
 55
 50
 50
 45
 45
 40
 40
 35
 35
 30
 30
 25
 25
 20
 20
 15
 15
 10
 10
 5
 5
 0
 0
 40
 40
 35
 35
 30
 30
 25
 25
 20
 20
 15
 15
 10
 10
 5
 5
 0
 0
A Fast Static Analysis Approach
305
Fast Disassembly
Fast Disassembly
Accurate Disassembly
Accurate Disassembly
Snort
Snort
 0
 0
 5
 5
 10
 10
 15
 15
 20
 20
 30
 30
 35
 25
 25
 35
Flow size (KB)
Flow size (KB)
 40
 40
 45
 45
 50
 50
 55
 55
 60