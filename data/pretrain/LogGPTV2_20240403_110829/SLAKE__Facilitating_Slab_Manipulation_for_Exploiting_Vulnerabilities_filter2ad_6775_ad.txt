on the stack and barely migrate them to the slab. While the shortage
of spray objects might influence the way to perform heap spray and
4Linux kernel has 314 system calls. The 257 system calls are those tied to the kernel
image we built.
Modules
Static Analysis
Dynamic Analysis
Static Analysis
Dynamic Analysis
# of v/s
avg. syscall #
# of alloc/free/deref
avg. time (min)
# of v/s
avg. syscall #
# of alloc/free/deref
avg. time (min)
Prototype-matching call graph
KINT-based call graph
Essential Part
AIO
ASSOCIATIVE_ARRAY
BLOCK
CGROUPS
EPOLL
EXT4_FS
FILE_LOCKING
FS_POSIX_ACL
FSNOTIFY
INET
IP_MROUTE
IPV6
ISO9660_FS
FAT_FS
JBD2
KEYS
NET
NETLABEL
PID_NS
POSIX_TIMERS
PROC_FS
SECCOMP
SECURITY_SELINUX
SND_HRTIMER
SND_SEQUENCER
SND_TIMER
SYSVIPC
TIMERFD
TTY
USB_MON
UTS_NS
Total
39/0
3/0
1/0
0/0
1/0
3/0
8/0
1/0
1/0
1/0
13/1
1/0
6/0
0/0
0/0
2/0
5/2
13/0
1/0
1/0
1/0
3/0
1/0
2/0
1/0
3/0
2/0
2/1
1/0
4/0
3/0
1/0
124/4
257
257
257
-
257
257
257
257
257
257
257
257
257
-
-
257
257
257
257
257
257
257
257
257
257
257
257
257
257
257
257
257
257
15/3/5
1/0/0
1/1/1
-
1/1/1
0/0/0
1/0/0
0/0/0
1/1/1
1/0/0
0/0/0
1/0/0
0/0/0
-
-
1/0/0
3/0/1
4/1/0
1/0/0
1/0/0
1/0/0
1/0/0
1/0/0
2/0/0
1/0/0
1/0/0
2/0/0
0/0/0
1/1/1
3/1/1
1/0/0
0/0/0
46/9/11
46
23
5
-
11
-
5
-
18
73
-
34
-
-
-
23
33
28
41
14
64
16
39
48
56
23
50
-
6
26
31
-
34
23/0
3/0
1/0
0/0
1/0
3/0
8/0
1/0
1/0
1/0
13/1
1/0
6/0
0/0
0/0
2/0
5/2
12/0
1/0
1/0
1/0
2/0
1/0
2/0
1/0
3/0
2/0
2/1
1/0
3/0
2/0
1/0
104/4
40
2
1
-
1
3
140
4
19
1
3
1
6
-
-
72
1
119
43
1
1
58
1
17
72
93
71
28
95
73
72
1
68
16/5/6
2/1/2
1/1/1
-
1/1/1
1/0/0
3/0/0
1/0/0
1/1/1
1/1/1
8/2/3
1/0/0
1/0/0
-
-
2/0/0
7/0/3
6/1/1
1/0/0
1/1/1
1/0/1
3/0/0
1/0/0
2/1/2
1/0/0
3/1/1
2/0/0
3/0/0
1/1/1
3/3/3
1/0/0
1/0/0
75/20/29
3
2
2
-
2
1
3
2
2
1
5
1
2
-
-
3
4
4
2
1
1
3
1
2
2
1
1
4
2
1
3
2
2
Table 1: The performance of SLAKE under the guidance of prototype-matching call graph and KINT-based call graph. # of v/s
denotes the number of victim and spray objects identified by using static analysis; avg. syscall # represents the average number
of syscalls, through reachability analysis, which can potentially reach to a site of our interest; # of alloc/free/deref indicates
the number of syscalls through which one can truly allocate an object, free an object or dereference a function pointer; avg.
time stands for the average amount of time that our dynamic analysis spends on finding each syscall.
Public
victim: file, subprocess_info, ccid, seq_file,
tty_struct, ip_mc_socklist, key, sock
spray: load_msg, SyS_add_key()
Additional
victim: seq_operations, perf_event_context, linux_binprm,
vmap_area, kioctx_table, kioctx, assoc_array_edit,
cgroup_namespace, ext4_allocation_context, ip_options_rcu,
ip_mc_list, ip_sf_socklist, request_key_auth, pid_namespace,
k_itimer, avc_node, sk_security_struct, snd_seq_timer,
timerfd_ctx, tty_ldisc, tty_file_private
spray: ip_options_get_from_user(), keyctl_update_key()
Table 2: The types of kernel objects identified by SLAKE. Note
taht the łvictimž indicates those types of objects that SLAKE
not only successfully pinpoints syscall(s) to allocate but also
identifies syscall(s) to dereference the pointer enclosed. The
łpublicž indicates that these objects are also used in pub-
lic exploits; the ładditionalž indicates the objects that have
never been used in public exploits.
thus the exploitation of UAF and double free vulnerabilities, as we
will show below, this does not restrict us from diversifying working
exploits for real-world UAF and Double Free vulnerabilities.
Comparison between SLAKE and manual efforts. To examine
how effective SLAKE is in terms of identifying kernel objects for ex-
ploitation, ideally, we would like to manually examine each system
call and the objects they can (de)allocate and dereference. However,
this is not possible even for a single system call. In the Linux kernel,
in addition to kernel threads, software and hardware interrupts
could occur at any time. They all can change the execution state of
kernel and thus influence the kernel object that a system call could
operate. To truly identify the set of objects pertaining to a system
call manually, one must consider software/hardware interrupts and
kernel threads at millions of sites over super complicated contexts.
To the best of our knowledge, there has not yet been previous re-
search or engineering efforts demonstrating the success of such
manual analysis. Therefore, instead of doing manual analysis to
figure out a ground-truth object set and then compare it with the
results that SLAKE identifies, we utilize a different method below.
For the 27 test cases used in our experiment, we extensively
searched their exploits publicly available. Then, we identified all
the objects that have been used in these exploits and appeared in
our examined kernel modules (32 kernel modules + 1 core kernel).
Since these objects are summarized by security researchers, we
treat them as the objects identified by manual efforts. In this work,
we compared these objects with the ones that SLAKE identifies. In
Table 2, we show the comparison results. As we can observe, SLAKE
successfully identifies not only all the 10 objects from the public
CVE-ID
N/A[47]
2010-2959
2018-6555
2017-1000112
2017-2636
2014-2851
2015-3636
2016-0728
2016-10150
2016-4557
2016-6187
2016-8655
2017-10661
2017-15649
2017-17052
2017-17053
2017-6074
2017-7184
2017-7308
2017-8824
2017-8890
2018-10840
2018-12714
2018-16880