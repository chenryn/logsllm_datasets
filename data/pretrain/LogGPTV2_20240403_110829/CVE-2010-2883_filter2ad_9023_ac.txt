> AL
> 0x0C`），`0x0D`等等，不管是`NOP`还是`0C`，它们的共同特点就是不会影响`shellcode`的执行。[[8]](https://www.anquanke.com/post/id/204319)
其实就是塞入一大段恶意代码(由nop（或者其他无意义代码）和shellcode合成)，而且重复的塞进栈里面，进行蛮力操作，最后迫使程序在不覆盖EIP时执行shellcode。
## 静态分析
因为我们这里不是漏洞挖掘者的角度，所以我们知道漏洞带你在哪里。当然，漏洞挖掘所涉及的只是太多、太杂、太难。就不在这里赘述了。
已知我们的函数报错在 **CoolType.dll**
，其中使用`strcat`函数时未对`uniqueName`字段的字符串长度进行检测，直接复制到固定大小的栈空间，最终导致栈溢出。
这里为快速定位漏洞点，有网上的资料可以得到（这个自己查看官方文档也行）
>
> 文件偏移0x11C为SING表数据结构所处位置。SING表偏移0x10处为uniqueName域，uniqueName域大小为28字节。strcat会把从“58
> E0 8D AD”（在test.pdf处是“4A E0 CE
> 68”，都是文件偏移0x0000012C处）开始的数据复制到指定位置，直到遇见NULL。此处的TTF文件已经是包含了触发栈溢出的数据[[7]](https://blog.csdn.net/wangtiankuo/article/details/82994280)
  * **1.** 在ida中使用字符串定位法(shift+f12)找到字符串`SING`，再使用’x’查看引用
  * **2.** 逐个排查函数再`sub_803DBF2`找到危险函数`strcat`，并将函数重命名为`vuln`
  * **3.** 对该函数具体分析再IDA中，选中函数后’f5’可以获得伪源代码以便于我们理解 
        int v18; // [sp+40h] [bp-24h][@4](https://github.com/4 "@4")
    ..........
    char v24; // [sp+64h] [bp+0h][@7](https://github.com/7 "@7")
    ..........
    if ( v18 )
          {
            if ( !(*(_DWORD *)v18 & 0xFFFF) || (*(_DWORD *)v18 & 0xFFFF) == 0x100 )
            {
              v24 = 0;
              strcat(&v24, (const char *)(v18 + 0x10));
              sub_8001243(&v24);
              v6 = v18;
            }
            v22 = 1;
          }
    ..........
其中， **v18 + 0x10** 是 **uniqueName** 相对于 **SING** 的偏移量
## 动态分析
有了之前的静态分析，我们可以看快速的找到断点
**0x803DCA4** 调用了`strcat`，所以在这里下个断点。
  * 我用的是 **x32dbg** ，可以直接下输入模块名称，然后在模块的入口断点
断点->添加DLL断点(右键召唤)->CoolType.dll
点进去就可以直接DLL找到了
  * 这里可以同步静态分析（老动静结合了），从IDA中可以看出这个地址是DllEntryPoint，所以可以在 **0x803DCA4** 下断点了（因为没有偏移）
  * 通过在x32dbg中找到`SING`的引用并设置断点，运行到断点处（这里我过滤勾选了正则，这样找到的个数要少一些）
因为第二个恰好在我们漏洞函数`strcat`之前的最近，对它的影响也是最大的
先经过这几个步骤过后， **EAX** 的寄存器变成了 **04889F4C**
，那么我们在下面的内存1跳转到04889F4C看看，发现文件被全部加载进了内存。
涉及到的汇编
    0803DC6D | 68 4CDB1908  | push cooltype.819DB4C          | 819DB4C:"SING"
    0803DC72 | 57           | push edi                       |
    0803DC73 | 8D4D DC      | lea ecx,dword ptr ss:[ebp-24]  | [ebp-24]:&L"=::=::\\"
    0803DC76 | E8 433EFEFF  | call cooltype.8021ABE          |
    0803DC7B | 8B45 DC      | mov eax,dword ptr ss:[ebp-24]  | [ebp-24]:&L"=::=::\\"
    0803DC7E | 3BC6         | cmp eax,esi                    | eax:&L"=::=::\\"
>
> 以上的指令主要就是将SING表的tag名传入到08021B06函数中通过表目录来获取到SING表的入口地址，而目前eax的值0x046BE598即是SING表的入口地址。分析SING表的这些数据，我们就能知道样本到底做了些什么
从之前的分析知道，第10个文件体是payload，就是 **strcat** 的时候我们“输入”的是这串字符
其中`14 A7 82 4A 0C 0C 0C 0C`、`C6 08 8A 4A`这些地址就是我们在ret处插入的一些指令，来帮助我们实现跳转来绕过
**DEP** 保护，也就是前文提到的 **ROP)**技术。
执行后，具体在内存中如下
这时候我们已经通过`strcat`把函数写到栈上面了，就等着调用 **SING表** 的时候的攻击了
多次调试发现在 **0808B2FA** 执行后，程序结束，弹出计算器。
汇编代码是
    0808B2FA | FF10    | call dword ptr ds:[eax]
在栈溢出前
在栈溢出后
我们再下个断点 **4A80CB38**
    4A80CB38 | 81C5 94070000 | add ebp,794
    4A80CB3E | C9            | leave      
    4A80CB3F | C3            | ret
寄存器是这样的
这里的指令相当于 **栈迁移** 的技巧，将程序流迁移到4A82A712
  * 迁移过后call eax+0x5C的位置，就是call 0x0c0c0c0c
  * 执行shellcode顺着刚才地的放继续调试下去就会发现：  
> shellcode使用了CreateFile
> 、CreateFileMapping、MapOfViewMap创建了文件iso885，并把该文件映射到了内存中。使用memcpy函数将shellcode复制到了0x3FA0000处。
然后等待shellcode自身解密，解完后就能看到要执行的CMD命令： **calc.exe**
  * 最后命令被成功时执行
## 参考文章
[[1]CVE-2010-2883](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2883)
[[2]细说CVE-2010-2883从原理分析到样本构造](https://www.anquanke.com/post/id/179681)
[[3]百度百科-pdf](https://baike.baidu.com/item/pdf/317608?fr=aladdin)
[[4]Adobe
Reader栈溢出漏洞(CVE-2010-2883)分析](https://blog.csdn.net/qq_38474570/article/details/91346316)
[[5]Heap Spray原理浅析](https://blog.csdn.net/magictong/article/details/7391397)
[[6]【技术分享】Windows
Exploit开发系列教程——堆喷射（一）](https://www.anquanke.com/post/id/85586)
[[7]CVE-2010-2883分析](https://blog.csdn.net/wangtiankuo/article/details/82994280)
[[8]Kernel Pwn 学习之路 – 番外](https://www.anquanke.com/post/id/204319)