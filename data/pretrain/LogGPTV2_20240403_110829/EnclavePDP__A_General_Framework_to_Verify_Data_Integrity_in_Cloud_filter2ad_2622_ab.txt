[23], etc.). Therefore, these libraries must be ported into Intel
SGX before implementing PDP schemes inside the enclave.
Currently, two libraries have been ported into enclave: (i)
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    197
Intel SGX SSL [21] library to support OpenSSL and (ii) In-
tel GMP [22] library to support the GNU multiple precision
arithmetic (GMP) library. However, the PBC [23] library de-
manded by many BLS-based PDP schemes (e.g., PPPAS [19],
DHT-PA [18], SEPAP [17], etc.) has not been ported into en-
clave yet. We provided a lightweight enclave-supported PBC
library by trimming and porting the native PBC library into
the enclave (Section 5.1).
Memory usage. In the current implementation of Intel
SGX, the EPC that can be used by the enclave is limited to
128 MB, and only 93 MB is usable for applications. When
enclave uses memory beyond the EPC size limit, SGX swaps
some EPC pages to unprotected DRAM, which incurs high
performance overhead. Therefore, when developing applica-
tions running in enclave, reducing the memory footprint is
crucial. Especially when implementing PDP schemes, neces-
sary support, i.e., cryptography libraries, needs to be ported
into enclave as well, which further increases the overall mem-
ory consumption. We addressed this problem by trimming
the unnecessary modules in cryptography libraries (Section
5.1) and running only the critical code of PDP schemes in
enclave (Section 4.1). We also quantitatively measured the
code base in enclave in our evaluation (Section 6.2), which
demonstrates reasonable memory footprint.
Runtime performance. When the non-enclave code needs
to execute a trusted function (running inside the enclave),
it invokes the SGX ecall primitive to switch the execu-
tion ﬂow into the enclave. Such enclave transitions (i.e.,
switching control between enclave and non-enclave) will im-
pose high runtime overhead [37]. Therefore, the number of
ocalls/ecalls needs to be carefully managed to avoid se-
vere performance overhead. In Section 5 and Section 6,
we discussed and evaluated the impact on practicality of En-
clavePDP introduced by the enclave transitions overhead.
4 The Approach of EnclavePDP
4.1 The Architecture of EnclavePDP
Generally, there are ﬁve major functionalities that should be
fulﬁlled by PDP schemes: KeyGen, Tag, Challenge, Proof
and Verify. Brief description of each operation is as follows.
• KeyGen. During the initialization phase, the client gener-
ates public and private keys for the other functionalities.
• Tag. The ﬁle is divided into n blocks, and a tag is gener-
ated for each block using the private key1.
• Challenge. After choosing a random set of ﬁle blocks to
audit, a challenge is generated using the private key.
• Proof. When receiving a challenge, a proof of data pos-
session is computed using the public key.
1The original ﬁle and all the tags will be uploaded to the remote cloud
storage servers.
Figure 1: The Architecture of EnclavePDP
• Verify. A received proof will be veriﬁed against the chal-
lenge using the private key or public key depending on
the speciﬁc PDP schemes.
KeyGen and Tag are running on the client side, so the
integrity of these two functionalities depends on the client.
Proof is conducted by the prover, i.e., the cloud storage server.
For existing PDP schemes, Challenge and Verify functionali-
ties are performed by either the client or the TPA. To ensure
the correctness of the data integrity veriﬁcation, the private
key used to generate challenges and verify proofs should never
be exposed to the cloud platforms. In addition, challenge and
veriﬁcation results must be protected against being tampered
with or forged. Therefore, these security-sensitive operations
(i.e., Challenge and Verify) should be executed in the enclave
and the security-sensitive data (e.g., the private key) should
be placed in the enclave as well.
Figure 1 shows the architecture of EnclavePDP. The Chal-
lenger running inside the enclave generates challenges for
PDP schemes. EnclavePDP also makes a backup of the chal-
lenge to defeat potential rollback attacks2. The Veriﬁer inside
the enclave is responsible for verifying proofs generated by
the Prover, a regular (non-SGX) application running on the
cloud storage server, entitled to access the data to be audited to
generate proofs of data possession on behalf of the cloud stor-
age services. The Private Key Loader is designed to securely
load private keys into the enclave (see Section 4.3.2). Request
handler is a SGX application (as described in Section 2.2),
which is responsible for receiving/sending messages (e.g.,
veriﬁcation request, challenge, proof, etc.) from/to the other
modules. It invokes ecalls provided by the Challenger or
the Veriﬁer to generate challenges or verify proofs.
4.2 The Workﬂow of EnclavePDP
As shown in Figure 2, the workﬂow of EnclavePDP mainly
consists of two phases: an initialization phase and a veriﬁca-
tion phase.
2For example, an untrusted cloud storage server may provide a fake proof
based on an outdated challenge as the response to the current challenge.
198    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
ChallengerSGXEnclavePrivate Key LoaderVerifierEnclavePDPecalls/ocallsRequest handlerbacdeProverSGX Applicationsockets) to the Request handler (step a(cid:13) in Figure 1). Note that
the client can also directly issue PDP requests to EnclavePDP.
The request then will be forwarded to the Challenger via ecall
interface, and the Challenger generates a challenge (step b(cid:13)
in Figure 1) for the ﬁle indicated in the request (typically via
ﬁle name or ﬁle path). The Request handler will transmit the
challenge to the Prover, a regular application (i.e., non-SGX
application) that can access the data stored in the cloud storage
servers. Note that the cloud storage services can entitle the
Prover to access data directly or provide APIs for the Prover
to access data indirectly. The Prover reads the data from the
cloud storage servers, and uses such data (i.e., ﬁle blocks,
tags) and the challenge to generate a proof of data possession.
The proof will be sent back to the Request handler (step c(cid:13) in
Figure 1) and then forwarded to the Veriﬁer (step d(cid:13) in Figure
1). The Veriﬁer uses the proof to verify whether the cloud
storage servers actually possess the correct data, and returns
a veriﬁcation response encrypted using the symmetric key sk
to the Request handler. Finally, the client will receive (step
e(cid:13) in Figure 1) and decrypt the veriﬁcation response using
the same sk to ensure the conﬁdentiality and integrity of it.
Note that the Request handler is also designed to be able to
generate veriﬁcation requests periodically on behalf of the
client, and forward these requests to the Challenger, followed
by other steps mentioned as above. Finally, EnclavePDP will
create a tamper-free (encrypted by the enclave) veriﬁcation
log that will be forwarded to the client if necessary.
4.3 Key Management
4.3.1 Private Key Protecting
The private key used by the PDP schemes can never be ex-
posed to the cloud storage services. In the initialization phase,
the client establishes a secure channel to upload the private
key and EnclavePDP encrypts the private key using SGX Seal-
ing technique. The conﬁdentiality and integrity of the keys
are guaranteed by two conditions: (i) the ECDH protocol is
executed in the enclave, which guarantees the conﬁdentiality
and integrity of the ECDH computation; (ii) The sealed pri-
vate key is bound to a signing authority (developer), so only
the enclave signed by the same authority can unseal it.
4.3.2 Private Key Loading
Before performing challenge or veriﬁcation operations, the
request handler (running outside of the enclave) ﬁrstly reads
the sealed private key from the disk and invokes ecalls pro-
vided by Private Key Loader to unseal the private key inside
the enclave. Note that the symmetric key sk is also loaded
and unsealed in the enclave. When generating challenge (or
veriﬁcation), the Challenger (or the Veriﬁer) uses the unsealed
private key to generate challenges (or verify the proof). To
reduce enclave transitions caused by ecalls, the private keys
used recently are stored in the private key buffer. Thus, the
Figure 2: The workﬂow of EnclavePDP
EnclavePDP Initialization. In the initialization phase,
clients (data owners) cooperate with EnclavePDP to complete
the necessary setup:
(1) Key Generation: Several keys will be generated by
the client, i.e., a pair of public key (pub_k) and private key
(pri_k), as well as a symmetric key (sk). The public key
is available to the cloud storage services and will be used to
generate proofs, while the private key, owned by the client and
EnclavePDP, is used to generate tags as well as challenges,
and verify proofs. EnclavePDP uses the symmetric key to
encrypt the veriﬁcation result and sends it back to the client.
(2) Data Tagging: The client generates tags for the original
data using the private key. For some PDP schemes (e.g., DHT-
PA [18]), the client also generates additional data structures
(e.g., Dynamic Hash Table) to record extra information, e.g.,
data version, timestamp, etc., to support dynamic auditing.
(3) Remote Attestation: The client can upload the En-
clavePDP executable to the cloud server running on Intel
SGX, and start the EnclavePDP remotely. After starting En-
clavePDP, the client attests it using Intel SGX remote attes-
tation to verify the code integrity of EnclavePDP, and sub-
sequently performs ECDH [38] protocol to create a secure
communication channel for the following operations.
(4) Secrets Uploading: The private key and the symmetric
key will be sent to EnclavePDP via the secure channel estab-
lished in Step (3). Other security-sensitive data (e.g., dynamic
hash table of DHT-PA schemes [18]) used to support dynamic
auditing will also be uploaded to EnclavePDP.
(5) Sealing: When EnclavePDP receives the private key
and the symmetric key, it encrypts them using Intel SGX
Sealing technique and stores the sealed (i.e., encrypted) keys
on disk. Other security-sensitive data, (e.g., dynamic hash
table of DHT-PA [18]), should be sealed in the same way.
(6) Data Uploading: The client uploads the public key, the
data and all the tags to the cloud storage services (CSS).
EnclavePDP Veriﬁcation. In the veriﬁcation phase, the
client issues a PDP request (e.g., via HTTP) to the cloud
storage service, which forwards the request (e.g., via TCP
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    199
ClientEnclavePDPCSSKeyGenTagUpload data, tag, public keysRequestChallengeProofGenerating challengeVerifyingVerificationEstablish secure channel, verify enclaveGenerating proof12Upload private keys, symmetric keys46abcde5SealingPerform remote attestation3InitializationVerificationSGX ApplicationNon-SGX ApplicationTable 1: A brief comparison of the ten PDP schemes
Dynamic
Retrievability
Public
Encryption
MACPDP
APDP [9]
MRPDP [11]
SEPDP [10]
CPOR [12]
DPDP [40]
X
X
X
X
X
(cid:88)
(cid:88)
X
(cid:88)
(cid:88)
PDP
PDP
PDP
PDP
POR
PDP
PDP
PDP
PDP
PDP
X
X
X
X
X
X
X
(cid:88)
(cid:88)
(cid:88)
Sym.
Asym.
Asym.
Sym.
Sym.
Asym.
Asym.
Asym.
Asym.
Asym.
FlexDPDP [8]
PPPAS [19]
SEPAP [17]
DHT-PA [18]
* Note: "(cid:88)" means "support"; "X" means "not support"; "Sym." means
symmetric encryption; "Asym." means asymmetric encryption.
Private Key Loader will ﬁrstly check if the required private
key already exists in the private key buffer. If so, it returns
the private key directly. Otherwise, it will demand the request
handler to load the sealed private key from the disk and un-
seal the private key into the private key buffer. To save the
enclave memory, the LRU (Least Recently Used) strategy is
utilized to refresh the private key buffer.
5 Implementation
We implemented a prototype of EnclavePDP on a Linux plat-
form, based on Intel SGX SDK 2.4, Intel SGX Driver 1.0,
Intel SGX SSL library integrated with OpenSSL 1.1.0i, In-
tel SGX GMP library and an enclave-supported PBC library
trimmed based on pbc-0.5.14. For generality and scalability,
the Request handler utilizes Linux epoll [39] mechanism to
provide support for multi-thread execution and concurrent re-
sponses. The requests to verify data integrity are encapsulated
into TCP sockets and forwarded to EnclavePDP, which eases
the deployment of EnclavePDP on third party cloud services.
5.1 Porting PDP Schemes
PDP Implementation. We chose 10 representative PDP
schemes, which cover the taxonomy described in Section 2.1
as in Table 1. Most of the PDP schemes can be implemented
in Intel SGX quite straightforward, but the following issues
need to be addressed for other PDP schemes.
(1) For MAC-PDP, to avoid frequent I/O operations from
the enclave and reduce the EPC memory consumption. the
MAC of the ﬁle blocks to be veriﬁed is not re-computed inside
the enclave. Instead, the prover (running on the cloud storage
server) re-computes the MAC and also loads the encrypted
tags (i.e., MACs of ﬁle blocks encrypted by the private key
and uploaded to the cloud storage server during the initial-
ization phase) associated with these ﬁle blocks into non-EPC
memory. Then the veriﬁer (inside the EnclavePDP) decrypts
the tags to get the original MAC and compares it with the
MAC computed by the prover.
(2) Some PDP schemes (e.g., SEPAP and DHT-PA) design
an extra data structure to record the data property information
(e.g., timestamp, version) used to perform dynamic auditing
3. Such additional data structures should be uploaded to the
TPA (when involved), protecting their integrity from the cloud
storage server. In contrast, EnclavePDP encrypts these data
structures using the private key and upload them to the remote
cloud server during the initialization phase. In the veriﬁcation
phase, EnclavePDP decrypts them in the enclave and uses
them to verify the proofs.
(3) During the initialization phase, DPDP generates root
metadata based on the Rank-Based Authenticated Skiplist
(RBASL) to verify its integrity, while FlexDPDP generates
root metadata based on FlexList to verify its integrity. Similar
as (2), EnclavePDP also encrypts the root metadta and uploads
it to the cloud storage server, and then decrypts it inside the
enclave in the veriﬁcation phase.
Trimming Intel SGX SSL library. Intel SGX SSL [21]
is to provide cryptographic service for enclave applications
based on OpenSSL library. It includes lots of functionalities
that are unnecessary to implement PDP schemes, e.g., des, rc2