### 当匹配不到动态类型时进行虚调用（仅在 Graal 中使用。）在 C2 中，如果类型 Profile是不完整的，即时编译器压根不会进行条件去虚化，而是直接使用内联缓存或者方法表。
## 总结与实践今天我介绍了即时编译器去虚化的几种方法。完全去虚化通过类型推导或者类层次分析，将虚方法调用转换为直接调用。它的关键在于证明虚方法调用的目标方法是唯一的。条件去虚化通过向代码中增添类型比较，将虚方法调用转换为一个个的类型测试以及对应该类型的直接调用。它将借助Java 虚拟机所收集的类型 Profile。今天的实践环节，我们来重现因类加载导致去优化的过程。    // Run with java -XX:CompileCommand='dontinline JITTest.test' -XX:+PrintCompilation JITTestpublic class JITTest {  static abstract class BinaryOp {      public abstract int apply(int a, int b);  }   static class Add extends BinaryOp {      public int apply(int a, int b) {          return a + b;      }  }   static class Sub extends BinaryOp {      public int apply(int a, int b) {          return a - b;      }  }   public static int test(BinaryOp op) {    return op.apply(2, 1);  }   public static void main(String[] args) throws Exception {    Add add = new Add();    for (int i = 0; i  在 Java 9 之前，字符串是用 char> 数组来存储的，主要为了支持非英文字符。然而，大多数 Java> 程序中的字符串都是由 Latin1> 字符组成的。也就是说每个字符仅需占据一个字节，而使用 char> 数组的存储方式将极大地浪费内存空间。>> Java 9 引入了 Compact Strings\[1\] 的概念，当字符串仅包含 Latin1> 字符时，使用一个字节代表一个字符的编码格式，使得内存使用效率大大提高。假设我们调用`String.indexOf`方法的调用者以及参数均为只包含 Latin1字符的字符串，那么该方法的关键在于对`StringLatin1.indexOf`方法的调用。下面我列举了`StringLatin1.indexOf`方法的源代码。你会发现，它并没有使用特别高明的算法，唯一值得注意的便是方法声明前的`@HotSpotIntrinsicCandidate`注解。``{=html}    @HotSpotIntrinsicCandidatepublic static int indexOf(byte[] value, byte[] str) {    if (str.length == 0) {        return 0;    }    if (value.length == 0) {        return -1;    }    return indexOf(value, value.length, str, str.length, 0);} @HotSpotIntrinsicCandidatepublic static int indexOf(byte[] value, int valueCount, byte[] str, int strCount, int fromIndex) {    byte first = str[0];    int max = (valueCount - strCount);    for (int i = fromIndex; i >> 1) & 0x55555555);    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);    i = (i + (i >>> 4)) & 0x0f0f0f0f;    i = i + (i >>> 8);    i = i + (i >>> 16);    return i & 0x3f;}我们可以看到，`Integer.bitCount`方法的实现还是很巧妙的，但是它需要的计算步骤也比较多。在X86_64 体系架构中，我们仅需要一条指令`popcnt`，便可以直接统计出 int 值中1 的个数。
## intrinsic 与方法内联HotSpot 虚拟机中，intrinsic 的实现方式分为两种。一种是独立的桩程序。它既可以被解释执行器利用，直接替换对原方法的调用；也可以被即时编译器所利用，它把代表对原方法的调用的IR 节点，替换为对这些桩程序的调用的 IR 节点。以这种形式实现的 intrinsic比较少，主要包括`Math`类中的一些方法。另一种则是特殊的编译器 IR节点。显然，这种实现方式仅能够被即时编译器所利用。在编译过程中，即时编译器会将对原方法的调用的 IR 节点，替换成特殊的 IR节点，并参与接下来的优化过程。最终，即时编译器的后端将根据这些特殊的 IR节点，生成指定的 CPU 指令。大部分的 intrinsic 都是通过这种方式实现的。这个替换过程是在方法内联时进行的。当即时编译器碰到方法调用节点时，它将查询目标方法是不是intrinsic。如果是，则插入相应的特殊 IR节点；如果不是，则进行原本的内联工作。（即判断是否需要内联目标方法的方法体，并在需要内联的情况下，将目标方法的IR 图纳入当前的编译范围之中。）也就是说，如果方法调用的目标方法是intrinsic，那么即时编译器会直接忽略原目标方法的字节码，甚至根本不在乎原目标方法是否有字节码。即便是native 方法，只要它被标记为 intrinsic，即时编译器便能够将之 \" 内联 \"进来，并插入特殊的 IR 节点。事实上，不少被标记为 intrinsic 的方法都是 native 方法。原本对这些 native方法的调用需要经过 JNI（Java NativeInterface），其性能开销十分巨大。但是，经过即时编译器的 intrinsic优化之后，这部分 JNI 开销便直接消失不见，并且最终的结果也十分高效。举个例子，我们可以通过`Thread.currentThread`方法来获取当前线程。这是一个native 方法，同时也是一个 HotSpot intrinsic。在 X86_64 体系架构中，R13寄存器存放着当前线程的指针。因此，对该方法的调用将被即时编译器替换为一个特殊IR 节点，并最终生成读取 R13 寄存器指令。
## 已有 intrinsic 简介最新版本的 HotSpot 虚拟机定义了三百多个 intrinsic。在这三百多个 intrinsic中，有三成以上是`Unsafe`类的方法。不过，我们一般不会直接使用`Unsafe`类的方法，而是通过`java.util.concurrent`包来间接使用。举个例子，`Unsafe`类中经常会被用到的便是`compareAndSwap`方法（Java 9+更名为`compareAndSet`或`compareAndExchange`方法）。在 X86_64体系架构中，对这些方法的调用将被替换为`lock cmpxchg`指令，也就是原子性更新指令。除了`Unsafe`类的方法之外，HotSpot 虚拟机中的 intrinsic还包括下面的几种。1.  `StringBuilder`和`StringBuffer`类的方法。HotSpot    虚拟机将优化利用这些方法构造字符串的方式，以尽量减少需要复制内存的情况。2.  `String`类、`StringLatin1`类、`StringUTF16`类和`Arrays`类的方法。HotSpot    虚拟机将使用 SIMD 指令（single instruction multiple    data，即用一条指令处理多个数据）对这些方法进行优化。\    举个例子，`Arrays.equals(byte[], byte[])`方法原本是逐个字节比较，在使用了    SIMD 指令之后，可以放入 16 字节的 XMM 寄存器中（甚至是 64 字节的 ZMM    寄存器中）批量比较。3.  基本类型的包装类、`Object`类、`Math`类、`System`类中各个功能性方法，反射    API、`MethodHandle`类中与调用机制相关的方法，压缩、加密相关方法。这部分    intrinsic    则比较简单，这里就不详细展开了。如果你有感兴趣的，可以自行查阅资料，或者在文末留言。如果你想知道 HotSpot 虚拟机定义的所有 intrinsic，那么你可以直接查阅OpenJDK 代码 \[2\]。（该链接是 Java 12 的 intrinsic 列表。Java 8 的intrinsic 列表可以查阅这一链接 \[3\]。）
## 总结与实践今天我介绍了 HotSpot 虚拟机中的 intrinsic。HotSpot虚拟机将对标注了`@HotSpotIntrinsicCandidate`注解的方法的调用，替换为直接使用基于特定CPU 指令的高效实现。这些方法我们便称之为 intrinsic。具体来说，intrinsic的实现有两种。一是不大常见的桩程序，可以在解释执行或者即时编译生成的代码中使用。二是特殊的IR 节点。即时编译器将在方法内联过程中，将对 intrinsic的调用替换为这些特殊的 IR 节点，并最终生成指定的 CPU 指令。HotSpot 虚拟机定义了三百多个intrinsic。其中比较特殊的有`Unsafe`类的方法，基本上使用java.util.concurrent 包便会间接使用到`Unsafe`类的intrinsic。除此之外，`String`类和`Arrays`类中的 intrinsic也比较特殊。即时编译器将为之生成非常高效的 SIMD 指令。今天的实践环节，你可以体验一下`Integer.bitCount` intrinsic带来的性能提升。    // time java Foopublic class Foo {  public static int bitCount(int i) {    // HD, Figure 5-2    i = i - ((i >>> 1) & 0x55555555);    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);    i = (i + (i >>> 4)) & 0x0f0f0f0f;    i = i + (i >>> 8);    i = i + (i >>> 16);    return i & 0x3f;  }  public static void main(String[] args) {    int sum = 0;    for (int i = Integer.MIN_VALUE; i \\[2\\\[3\![](Images/a500044f1e4938fb43719f802cba82d8.png){savepage-src="https://static001.geekbang.org/resource/image/2a/d5/2a62e58cbdf56a5dc40748567d346fd5.jpg"}
# 23 \| 逃逸分析我们知道，Java 中`Iterable`对象的 foreach 循环遍历是一个语法糖，Java编译器会将该语法糖编译为调用`Iterable`对象的`iterator`方法，并用所返回的`Iterator`对象的`hasNext`以及`next`方法，来完成遍历。    public void forEach(ArrayList list, Consumer f) {  for (Object obj : list) {    f.accept(obj);  }}举个例子，上面的 Java 代码将使用 foreach循环来遍历一个`ArrayList`对象，其等价的代码如下所示：    public void forEach(ArrayList list, Consumer f) {  Iterator iter = list.iterator();  while (iter.hasNext()) {    Object obj = iter.next();    f.accept(obj);  }}这里我也列举了所涉及的`ArrayList`代码。我们可以看到，`ArrayList.iterator`方法将创建一个`ArrayList$Itr`实例。    public class ArrayList ... {  public Iterator iterator() {    return new Itr();  }  private class Itr implements Iterator {    int cursor;       // index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    ...    public boolean hasNext() {      return cursor != size;    }    @SuppressWarnings("unchecked")    public E next() {      checkForComodification();      int i = cursor;      if (i >= size)        throw new NoSuchElementException();      Object[] elementData = ArrayList.this.elementData;      if (i >= elementData.length)        throw new ConcurrentModificationException();      cursor = i + 1;      return (E) elementData[lastRet = i];    }    ...    final void checkForComodification() {      if (modCount != expectedModCount)        throw new ConcurrentModificationException();    }  }}因此，有同学认为我们应当避免在热点代码中使用 foreach循环，并且直接使用基于`ArrayList.size`以及`ArrayList.get`的循环方式（如下所示），以减少对Java 堆的压力。    public void forEach(ArrayList list, Consumer f) {  for (int i = 0; i `{=html}