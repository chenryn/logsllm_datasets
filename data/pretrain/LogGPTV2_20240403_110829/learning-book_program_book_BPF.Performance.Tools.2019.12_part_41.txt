statsnoop(8)a is a BCC and bpftrace tool similar to opensnoop(8) but for the stat(2) family syscalls
stat(2) returns file statistics. This tool is useful for the same reasons as opensnoop(8): discovering
file locations, finding performance issues of load, and troubleshooting missing files. Example
proxluction output, with : for timestamps:
statsnoop -t
TIME (≤)
PID
COMM
FD ERR PATH
LE99 E000 * 0
9118
statsnoop
-1
2 /usz/1ib/python2, T/encodings/asc11
0, 238452415
744
sys temd-resolve
0 /etc/resolv,conf
744
systemd-resolve
0 /run/systend/resolve/resolv,conf
0, 238470518
744
systead-resolve
0 /run/systend/resolve/stub-resolv-conf
0. 238497017
744
systemd-zesolve
0 /etc/resolv.conf
0, 238506760
744
sys temd-resolve
0 /run/systend/resolve/resolr,conf
0.238514099
744
systemd-zesolve
0 /run/systend/reaolve/stub=resolv ,con.f
0 . 238645046
744
sys temd-resolve
0/etc/resolv,conf
0,238659277
744
system.d-zeso1ve
0 /run/systend/xesolve/resolv,conf
0. 238667182
744
systemd-resolve
0
0 /run/syatend/resolve/stub-resolv,conf
[.--]
on the same three files in a loop.
This output shows systemd-resolve (which is really *systemd-resolved* truncated) calling stat(2)
I found a number of occasions when stat(2)s were called tens of thousands of times per second on
production servers without a good reason; fortunately, it’s a fast syscall, so these were not causing
major performance issues. There was one exception, however, where a Netflix microservice hit
100% disk utilization, which I found was caused by a disk usage monitoring agent calling stat(2)
continually on a large file system where the metadata did not fully cache, and the stat(2) calls
became disk I/O.
This tool works by tracing stat(2) variants via tracepoints: statfs(2), statx(2), newstat(2), and
newlstat(2). The overhead of this tool is expected to be negligible, unless the stat(2) rate was
very high.
BCC
Command line usage
[guoTqdo]  dcousqeqs
7 0rigin: 1 first created this using DTrsce on 9-Sep-2007 as a com
8-Feb-2016 and bpftrace on 8-Sep-2018.
---
## Page 329
292
Chapter S File Systems
Options include:
 x: Show only failed stats
• t: Incluxde a column of timestamps (seconds)
p PID: Measure this process only
bpftrace
The following is the code for the bpftrace version, which summarizes its core functionality. This
version does not support options.
+1/usz/local/bin/bpftrace
BEGIN
printf (*Tracing stat syscalls... Hit CtrlC to end. n*)
printf(*-6s s-16s s3s 与sn", "PID", "COMH*, ERR", "PATH*
1
tracepointisyscallsisys_enter_statfs
Bfilenane[tid] = args->pathnane]
tracepoint:syscalls:sys_enter_statx,
tracepointisyscalls1sys_enter_nexstat,
txacepoint:syscalls:sys_enter_nexlstat
B[ilenane [tid]= azgs=>1lenane;
tracepointisyscalls1sys_exit_statfs,
tracepoint:syscalls:sys_exit_statx,
tracepointisyscalls1sys_exit_nevstat,
tracepoint:syacalls:sys_exit_nevlstat
/Bfilename [tid] /
$ret = args->ret
Serrno = $ret >= 0 ? 0 : - Sret;
printf (*s=6d 116s s3d 4s^n*, pld, corm, $ezrno,
str(efilename [tid])1
delete (@Cllenane [tid]):
END
clear (8filenane) 
---
## Page 330
8.3 BPF Tools
293
details.
8.3.3
syncsnoop
syncsnoo(8) is a BCC and bpftrace tol to show sync(2 all with timestamps. sync(2 flushes
dlirty data to dlisk. Here is some output from the bpftrace version:
qdooussus
Attach.ing 7 pzobes...
Tracing sync syscalls... Hit Ctrl-C to end.
TIME
PID
CONM
EVENT
08:48:31
14172
TaskSchedulerFo
tracepoint:sysca1ls1sys_enter_fdatasymc
08 :48 : 31
14172
TaskSchedulerFo
TaskSchedulerFo
tracepoint:syscalls:ays_nter_fdatasymc
08:48: 31
14172
tracepoint:syscalls1sys_enter_fdatasync
08 :48 : 31
14172
TaskSchedulerFo
tracepoint:syscalls:sys_enter_fdatasync
08 :48 : 31
14172
TaskSchedulerFo
tracepointisyscallsisys_enter_fdatasync
622841018=80
tracepoint:syscalls:ays_enter_aync
[...]
This output shows *TaskSchedulerFo* (a truncated name) calling fdatasync(2) five times in a row.
sync(2) calls can trigger bursts of disk I/O, perturbing performance on the system. Timestamps
are printed so that they can be correlated with performance issues seen in monitoring software,
which would be a clue that sync(2) and the disk I/O it triggers is responsible.
This tool works by tracing sync(2) variants via tracepoints: sync(2), syncfs(2), fsync(2),
fdatasync(2), sync_file_range(2), and msync(2). The overhead of this tool is expected to be
negligible, as the rate of sync(2) is typically very infrequent.
BCC
The BCC version currently does not support options, and works similarly to the bpftrace version.
bpftrace
The following is the code for the bpftrace version:
1/usr/local/bin/bpftrace
BEGIN
printf(*Tracing sync syscalls... Hit Ctrl-C to end. n*1 
printf (*9s =6s 16s s′,n", "FIYE*, *PID", "cOM*, *EVENT*)
pananb uesp speau xs(p 9ueqm *savde ksueje) uo(jeoljldde Jlu(snes ssuie jo senssl paflnqep 9A,) lsed asp u) :uglu0 8
behind a bunch of writes from the sync. These syncs are usualy infrequent, so it's always been suficient to have the
second offset of when they ocoured to oelate with erfmnce monitoring dshbords. I created tistoolf CC
on 13-Aug-2015 and bpftrace on 6-Sep-2018,
---
## Page 331
p67
Chapter 8 File Systems
tracepoint:sysca1ls1ays_enter_sync,
tracepoint:ayscalls:ays_nter_syncfs,
tracepoint1syscalls1sys_enter_fsync,
tracepoint:syacalls:sys_enter_fdatasync,
tracepointisyscalls1sys_enter_sync_file_range,
tracepoint:syscalls:ays_enter_nsync
tise (*8:X:S *)/
printf (*-fd $-16s esn*, pid, comm, probe)
If sync(2) related calls were found to be a problem, they can be examined further with custom
bpftrace, showing the arguments and return value, and issued disk I/O.
8.3.4mmapfiles
mmapfiles(8)? traces mmap(2) and frequency counts the file that is mapped to memory address
ranges. For example:
 nmapfiles.bt
Attaching 1 probe...
^C
e[usr, bin, x86_64linux=gnu-ar] : 2
e[1ib, x85_6411nux=gnu, 11breadl1ne,so. 6.3| : 2
[use, bin, x86_641inux=gnu=objcopy] : 2
[.--]
[usr, bin, make] : 226
?[1ib, x86_6411nux=gnu, 1ibz,so.1 .2.8] : 296
[xB6_641inux=gnu, gconv, gconv-nodules-cache| : 365
e[/, bin, bash] : 670
e[1ib, x8 6_641inux=gnu, 1ibtin.fo.so.5. 9| : 672
[/, bin, cat]: 1152
e[1ib, x86_641inux=gnu, libdl2.23,so] : 1240
e[1ib, locale, locale-azchive] : 1424
[/, etc, ld.so.cache] : 1449
e[1ib, x86_64-11nux-gnu, 1d-2.23,so]: 2879
e[1ib, x86_641inux=gnu, libc-2 .23.so] : 2879
e, , ]: 8384
This example has traced a software build. Each file is shown by the filename and two parent
dlirectories. The last entry in the output above has no names: it is anonymous mappings for
program private data.
9 Origin: 1 created this for DTrace on 18-0ct-2005, and this bpftrace version for this book on 26-Jan-2019.
---
## Page 332
8.3  BPF Tools
295
The source to mmapfiles(8) is:
#1/usx/local/bin/bpctrace
#Include 
deuws"op: 9qo.xdx
$f1le = [atruct rile *)azg0;
$nane = $fi1e=>f_path,dent.ry
uexed pd_parent
 [str ($dix2->d_nane -nane) , str ($dir1=>d_nane -nane) ,
str {$name=>d_nane,n.ame) ] = count () =
It uses kprobes to trace the kernel do_mmap() function, and reads the filename from its struct
file * argument, via a struct dentry (directory entry). The dentry only has one component of the
path name, so to provide more context on where this file is located, the parent directory and
grandparent directory are read and included in the output.  Since the mmap(0 callis expected to
be relatively infrequent, the overhead of this tool is expected to be negligible,
The aggregation key can be easily moxdified to include the process name, to show who is
making these mappings (*@[comm, ..]°), and the user-level stack as well to show the code path
(*@[comm, ustack, .]*).
(g)doousdeuru :[oo sis
#include 
include 
traoepointisyscallsiays_enter_resd
$task = (struct task_struct *) curtask;
[pf_path, dentry=>d_namename) ] = count. 1} 
This pulls the filename from the file descriptor table.
File Descriptor to Filename
This tool has also been included as an example of fetching the filename from a file descriptor (FD)
integer. There are at least two ways to do this:
1. Walk from the task_struct to the file descriptor table, and use the FD as the index to find
the struct file. The filename can then be found from this struct. This is used by scread(2).
This is an unstable technique: the way the file descriptor table is found (task->files->fdt->fd)
refers to kernel internals that may change between kernel versions, which would break this
script,12
2. Trace the open(2) syscall(s), and build a lookup hash with the PID and FD as the keys, and
the file/pathname as the value. This can then be queried during read(2) and other syscalls.
While this adds additional probes (and overhead), it is a stable technique.
There are many other tools in this book (fmapfault(8), filelife(8), vfssize(8), etc.) that refer to
the filename for different operations; however, those work by tracing via the VFS layer, which
provides the struct file immediately. While that is also an unstable interface, it makes it possible
to find the filename string in fewer steps. Another advantage of VFS tracing is that there is usually
only one function per type of operation, whereas with syscalls there can be variants (e.g., read(2),
readv(2), preadv(2), pread64(), etc.) that may all need to be traced.
12 Some changes are already being considered. Dave Watson has been considering reaanging it to improve
perfomance. Matthew Wilox is also working on changing it to task_struct->files_struct->maple_node->fd[i], [85] [86]
---
## Page 334
8.3 BPF Tools
297
8.3.6 fmapfault
fmapfault(8) traces page faults for memory mapped files, and counts the process name and
filename. For example:
fmapfault.bt
Attach.ing 1 probe..*
[diename, l1bc=2,23,so] : 1
[date, libc-2.23,so] : 1
[..-]
e[cat, libc-2.23,so] : 901
e[sh, 1ibtinfo,so.5.9}: 962
[sed, 1d2.23,so] : 984
e[sh, 11bc-2.23.so] : 997
[cat, 1d2.23,so]: 1252
[sh, 1d=2,23,ao]: 1427
9 [as, 1ibbfd2.26 .1-systen. so] : 3984
e[as, 1ibopcodes=2 .26.1=syatem, so] : 68455
This traced a software build, and shows the build processes and libraries in which they were
faulting.
Later tools in this book, such as filetop(8), fileslower(8), xfsslower(8), and ext4idist(8), show file
I/O via the read(2) and write(2) syscalls (and their variants). But these are not the only way that
files can be read and written to: file mappings are another method, which avoids explicit syscalls.
fmapfault(8) provides a view of their use, by tracing file page faults and the creation of new page
maps. Note that the actual reads and writes to a file may be far higher than the fault rate.
The source to fmapfault(8) is:
1/usr/local/bin/bpftrace
include 
kprobe:filenap_faul t
$vf = (struct vm_fault *)arg0;
11e = §vf=>vma=>vn_f11e=>f_path, dent.ry=>d_nase ,nane;
 [conm, str ($file)] = count ()
This works by using kprobes to trace the filemap_fault() kernel function and, from its struct vm_
fault argument, determine the filename forthe mapping These details will need to be updated as
the kernel changes. The overhead of this tool may be noticeable for systems with high fault rates.
1.3 0rigin: I crested it for this book on 26-Janr-2019.
---
## Page 335
298
Chapter S File Systems
8.3.7
filelife
filelife(8)# is a BCC and bpftrace tool to show the lifespan of short-lived files: those that were
created and then deleted while tracing.
The following shows filelife(8) from BCC, during a software build:
+filelife
TIME
PID
COH
AGE (s)FILE
17:04:51 3576
gcc
0 . 02
kernel_release. tsp
cc97ENsb . 5
17:04:51 3632
rn
0 .00
17:04:51 3656
0 . 00
version,h. tnp
17:04:51 3678
rn
0 .00
utsrelease,h,crp
17:04:51 3698
gcc
0 . 01
ccTtEADr-5
17:04:51 3701
rn
0 . 00
dsn°L69E*
17:04:51 736
systend-udevd
0 . 00
queve
E0LE ts+0t
gcc
0 .16
cc05cPSx.s
17:04:51 3708
h
0 .01
-purgatory,o.d
17:04:51 3711
gcc
0 . 01
ccqk4xE .3
17:04:51 3715
n
0 .01
-atack,o.d
17:04:51 3718
gcc
0 .01
ccPIKOgD.s
17:04:51 3722
cf
0 . 01
-setup-x86_64,o.d
[..-]
This output shows the many short-lived files created during the build process, which were
removed at an age (°AGE(s)°) of less than one second.
This tool has been used to find some small performance wins: discovering cases where
applications were using temporary files which could be avoided.
This works by using kprobes to trace file creation and deletion via the VFS calls vfs_create()
and vfs_unlink(. The overhead of this tool should be negligible as the rate of these should be
relatively low.
BCC
Command line usage:
filelife [options]
Options include:
•=p PID: Measure this process only
14 Origin: Ifist ereated it for BCC on 8-Feb-2015 to debug short-lived file usage, and forbpftrace forthis book on
31-Jan-2019. Its inspired by my fslife.d tool from the 2011 DTrace book [Gregg 11].
---
## Page 336