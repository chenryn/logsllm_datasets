(6)
5 PROTOCOL FOR OBLIVIOUS OPE
In this section we present our scheme Î OOPE that consists of an
initialization step and a computation step. The initialization step
generates the server state and is run completely by the Data Owner.
The server state and the ciphertexts are sent to the CSP afterward.
5.1 Order-Preserving Encoding
We instantiate the Ope.Encode function of Definition 4.2 with
mOPE2.Encode, which is now presented in more details. The client
chooses a range{0, . . . , M} for the order and maintains for each
plaintext x a pairâˆï¸€x, yÌƒï¸€ in the encoding state Sc (stored at the client),
Anselme Tueno and Florian Kerschbaum
âœ32â¨†ï¸
0
1
âœ25â¨†ï¸
(a) OPE-treeğ’¯
y
4
7
11
14
21
0
âœ10â¨†ï¸
âœ20â¨†ï¸
âœxâ¨†ï¸
âœ10â¨†ï¸
âœ20â¨†ï¸
âœ25â¨†ï¸
âœ32â¨†ï¸
âœ69â¨†ï¸
1
âœ69â¨†ï¸
âˆï¸€x, yÌƒï¸€
âˆï¸€32, 14Ìƒï¸€
âˆï¸€20, 7Ìƒï¸€
âˆï¸€25, 11Ìƒï¸€
âˆï¸€69, 21Ìƒï¸€
âˆï¸€10, 4Ìƒï¸€
(b) OPE-table T
(c) Data Owner State
Figure 3: Example initialization
new plaintext works as follows:
where yâˆˆ{0, . . . , M} is the OPE encoding of x. The encoding of a
â— findâˆï¸€xi , yiÌƒï¸€,âˆï¸€xi+1, yi+1Ìƒï¸€âˆˆ Sc with xiâ‰¤ x 1 then compute y= yi+[ï¸‚ yi+1âˆ’yi
âŒ‰ï¸‚.
2
For the new plaintext x the client sends only the OPE encoding y
to the database stored at the server.
Remark 5.1. The reason of using mOPE2.Encode instead of
mOPE1.Encode is that after our OOPE protocol, the DA will re-
ceive the OPE encoding. Its binary representation, when using
mOPE1.Encode, reveals the corresponding path in the tree, allow-
ing the DA to infer additional information. In contrast, mOPE2
allows the DO to choose not just the length of the OPE encoding,
but also the order range like 0, . . . , M. If log2 M is larger than the
needed length of the OPE encoding and M is not a power of two,
then for a ciphertextâˆï¸€âœxâ¨†ï¸, yÌƒï¸€, y does not reveal the position ofâœxâ¨†ï¸
h= 3, the order of 25 (i.e. 011 = 3) reveals the corresponding path.
However, with mOPE2 and M= 28, 25 has order 11 = 1011. A second
in the tree. In Figure 3a for instance, when applying mOPE1 with
and more important reason is that in Section 7, we extend OOPE to
the case of mOPE3, which is more secure and builds on mOPE2.
5.2 Initialization
runs Ope.Encode from Definition 4.2 (using mOPE2) and sends the
generated OPE-table to the CSP.
Let D={x1, . . . , xn} be the unordered DOâ€™s dataset and h= log2 n.
The DO chooses a range 0, . . . , M such that log2 M> h (Remark 5.1),
For example, if D={10, 20, 25, 32, 69} is the data set, M= 28 and
ecuting algorithm Ope.Encode areâˆï¸€âœ32â¨†ï¸, 14Ìƒï¸€,âˆï¸€âœ20â¨†ï¸, 7Ìƒï¸€,âˆï¸€âœ25â¨†ï¸, 11Ìƒï¸€,
âˆï¸€âœ69â¨†ï¸, 21Ìƒï¸€,âˆï¸€âœ10â¨†ï¸, 4Ìƒï¸€. The OPE-tree, the OPE-table and the DO state
the insertion order is 32, 20, 25, 69, 10. Then the ciphertexts after ex-
of this example initialization are depicted in Figure 3.
Efficient Secure Computation of Order-Preserving Encryption
Figure 4: Overview of the protocol
5.3 Algorithms
In the following, we present our main protocol that repeatedly
makes calls to a sub-protocol (Protocol 6). Both protocols run
between the three parties. During the protocolâ€™s execution the
CSP runs Algorithm 7 to traverse the tree and Algorithm 8 to com-
pute the order (as in mOPE2). We will deal with mOPE3 in Section
7. An overview of the protocol is illustrated in Figure 4.
Our OOPE Protocol. Protocol 5 is executed between the three
parties. First the CSP retrieves the root of the tree and sets it as
current node. Then the protocol loops h(= log2 n) times. In each
step of the loop the CSP increments the counter and the parties run
an oblivious comparison protocol (Protocol 6) whose result enables
the CSP to traverse the tree (Algorithm 7). If the inputs are equal
or the next node is empty then the traversal stops. However, the
CSP uses the current node as input to the next comparison until the
counter reaches the value h. After the loop the result is either the
order of the current node in case of equality or it is computed by the
CSP using Algorithm 8. In the last step, the DA computesâœxâ¨†ï¸ using
DOâ€™s public key pk and sends it to the CSP as argued in Remark
4.7. Alternatively, the DA could generate an unique identifier (UID)
for each element that is being inserted and send this UID instead.
So if the corresponding node is later involved in a comparison step,
the result is computed by the DA alone.
comparison GC is run between the DA and DO and they are not
Oblivious Comparison Protocol. Protocol 6 runs between the
three parties as well, with input(âœxâ¨†ï¸, x, sk) for the CSP, the DA and
the DO respectively. It outputs two bits bĞ´=(i f x> x then 1 else 0)
and be = (i f x â‰  x then 1 else 0) to the server. As the actual
â€²
â€²
a),(bo, b
allowed to learn the result, they use masking bits(ba, b
o)
First the CSP randomizes its input, with a random integer r âˆˆ
{0, . . . , 2l+k}4, toâœx+ râ¨†ï¸â†âœxâ¨†ï¸â‹…âœrâ¨†ï¸, by first computingâœrâ¨†ï¸ with
k is the security parameter that determines the statistical leakage [14], e.g., k= 40.
in the GC protocol.
4
ASIA CCS â€™20, October 5â€“9, 2020, Taipei, Taiwan
Functionality : OOPE(S, x, sk)
Input (CSP, DA, DO):(S, x, sk)
Output (CSP, DA, DO):(âˆï¸€âœxâ¨†ï¸, yÌƒï¸€ , y,âˆ…)
1: CSP : retrieve rootâœxrootâ¨†ï¸ ofğ’¯
2: CSP : letâœxâ¨†ï¸â†âœxrootâ¨†ï¸
3: CSP : let countâ† 0
(âˆï¸be , bĞ´Ìƒï¸ ,âˆ…,âˆ…)â† Compare(âœxâ¨†ï¸, x, sk)
CSP : if beâ‰  0 then
âœxnextâ¨†ï¸â† Traverse(bĞ´,âœxâ¨†ï¸)
ifâœxnextâ¨†ï¸â‰  NIL then
letâœxâ¨†ï¸â†âœxnextâ¨†ï¸
CSP : let countâ† count+ 1
retrieveâˆï¸€âœxâ¨†ï¸, yÌƒï¸€ and let yâ† y
yâ† Encode(bĞ´,âœxâ¨†ï¸)
13: until count= h
14: CSP : if be= 0 then
4: repeat
5:
6:
7:
8:
9:
10:
11:
12:
CSP :
CSP :
CSP :
CSP :
CSP : end if
15: CSP :
16: CSP : else
17: CSP :
18: CSP : end if
end if
19: CSPâ†’ DA: send y
20: DAâ†’ CSP: sendâœxâ¨†ï¸
â–· meaning xâ‰  x
â–· meaning x= x
Protocol 5: Oblivious OPE Protocol Î OOPE
DOâ€™s public key, such that the DO will not be able to identify the
as described in Section 6. For simplicity, the garbled circuit is imple-
mented in Protocol 6 as ideal functionality. In reality the DO gener-
ates the garbled circuit and the DA evaluates it. The DA and the DO
position in the tree, and it sendsâœx+ râ¨†ï¸ to the DO and r to the
â€²
o, x+ r) and the DA with input
DA. Then the DO with input(bo, b
â€²
(ba, b
a, x+ r) engage in a garbled circuit protocol for comparison
â€²
â€²
aâŠ•b
o) as output of this computation and
receive(beâŠ•baâŠ•bo, bĞ´âŠ•b
â€²
â€²
â€²
â€²
resp. send(ba, b
a, beâŠ•bo, bĞ´âŠ•b
o) and(bo, b
a) to
o, beâŠ•ba, bĞ´âŠ•b
the CSP. Finally the CSP evaluates Equation 7 and outputsâˆï¸be , bĞ´Ìƒï¸.
)ï¸€âŒ‰ï¸€âŒ‰ï¸€âŒ‹ï¸€âŒ‰ï¸€âŒ‰ï¸€]ï¸€be
= beâŠ• boâŠ• bo= beâŠ• baâŠ• ba
â€²
â€²
â€²
â€²
bĞ´ = bĞ´âŠ• b
oâŠ• b
o= bĞ´âŠ• b
aâŠ• b
This will be used to traverse the OPE-tree.
(7)
a
Tree Traversal Algorithm. The tree traversal (Algorithm 7)
runs only at the CSP. Depending on the output of the oblivious
comparison the CSP either goes to the left (line 2) or to the the
right (line 4). If the comparison step returns equality there is no
need to traverse the current node and the protocol returns the cor-
responding ciphertext.
Encoding Algorithm. Algorithm 8 runs at the CSP as well and
is called only if the tree traversal (Algorithm 7) has to stop. Then
the compared values are strictly ordered and depending on that
the algorithm finds the closest element to the current node in the
OPE-table. This element is either the predecessor (Pred) if DAâ€™s
input is smaller (line 4) or the successor (Succ) if DAâ€™s input is
ASIA CCS â€™20, October 5â€“9, 2020, Taipei, Taiwan
Input (CSP, DA, DO):(âœxâ¨†ï¸, x, sk)
Output (CSP, DA, DO):(âˆï¸be , bĞ´Ìƒï¸ ,âˆ…,âˆ…)
Functionality : Compare(âœxâ¨†ï¸, x, sk)
1: CSP: choose(l+ k)-bits random r and computeâœx+ râ¨†ï¸
2: CSPâ†’ DO: sendâœx+ râ¨†ï¸
3: CSPâ†’ DA: send r
â€²
4: DO: decryptâœx+ râ¨†ï¸ and choose masking bits bo, b
â€²
5: DA: compute x+ r and choose masking bits ba, b
â€²
6: DOâ†’ GC: send(bo, b
o, x+ r)
â€²
7: DAâ†’ GC: send(ba, b
a, x+ r)
â€²
â€²
o)
aâŠ• b
8: GCâ†” DA: send(beâŠ• baâŠ• bo, bĞ´âŠ• b
â€²
â€²
aâŠ• b
9: GCâ†” DO: send(beâŠ• baâŠ• bo, bĞ´âŠ• b
o)
â€²
â€²
10: DAâ†’ CSP: send(ba, b
o)
a, beâŠ• bo, bĞ´âŠ• b
â€²
â€²
11: DOâ†’ CSP: send(bo, b
o, beâŠ• ba, bĞ´âŠ• b
a)
12: CSP: compute be= beâŠ• boâŠ• bo= beâŠ• baâŠ• ba
â€²
â€²
â€²
â€²
o= bĞ´âŠ• b
13: CSP: compute bĞ´= bĞ´âŠ• b
aâŠ• b
oâŠ• b
14: CSP: outputâˆï¸be , bĞ´Ìƒï¸
a
a
o
6:
4:
2:
else
Protocol 6: Oblivious Comparison Protocol
function Traverse(bĞ´,âœxâ¨†ï¸)
if bĞ´= 0 then
âœxnextâ¨†ï¸â† LeftChildNode(âœxâ¨†ï¸)
âœxnextâ¨†ï¸â† RightChildNode(âœxâ¨†ï¸)
returnâœxnextâ¨†ï¸
â–· traverse to left
â–· traverse to right
Algorithm 7: Tree Traversal at Nodeâœxâ¨†ï¸ (run by CSP)
function Encode(bĞ´,âœxâ¨†ï¸)
retrieveâˆï¸€âœxâ¨†ï¸, yÌƒï¸€ from the OPE-table
if bĞ´= 0 then
â€²Ìƒï¸â† Pred(âˆï¸€âœxâ¨†ï¸, yÌƒï¸€)
â€²â¨†ï¸, y
âˆï¸âœx
â€² and yr â† y
let yl â† y
â€²â€²â¨†ï¸, y
â€²â€²Ìƒï¸â† Succ(âˆï¸€âœxâ¨†ï¸, yÌƒï¸€)
elseâˆï¸âœx
â€²â€²
let yl â† y and yr â† y
if yrâˆ’ yl = 1 then
yâ† yl+]ï¸‚ yrâˆ’yl2
{ï¸‚
â€²< y
â–· y
â€²â€²
â–· y< y
rebalance the OPE-tree
10:
2:
4:
6:
8:
12:
return y
Algorithm 8: Encryption at Nodeâœxâ¨†ï¸ (run by CSP)
larger (line 7). Then if necessary (line 9) re-balance the tree and
compute the ciphertext as in line 11.
5.4 Optimization
One can reduce the number h of homomorphic decryptions by using
plaintexts packing [40]. Letâœxâ¨†ï¸ be a node at the level 2i, 0â‰¤ iâ‰¤ h2 ,