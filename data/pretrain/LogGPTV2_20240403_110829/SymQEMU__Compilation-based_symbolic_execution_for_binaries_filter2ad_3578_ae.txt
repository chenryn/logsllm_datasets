T
i
1
0.8
0.6
0.4
0.2
0
)
d
e
z
i
l
a
m
r
o
n
(
e
m
T
i
1
0.8
0.6
0.4
0.2
0
Q
S
Y
S
y
S
y
m
m
M
Q
E
C
C
M
U
Q
S
Y
S
y
S
y
m
m
M
Q
E
C
C
M
U
Q
S
Y
S
y
S
y
m
m
M
Q
E
C
C
M
U
OpenJPEG
libarchive
tcpdump
Execution
Solving
Fig. 14. Time spent in execution and SMT solving, respectively, averaged across concolic execution of a ﬁxed set of test cases (1000 cases per target, chosen
at random and analyzed in each of the three symbolic executors). Times are normalized to the total execution time of the slowest engine per target to show the
differences in the overall amount of time required to complete the benchmark.
2)
An alternative is to build symbolic versions of the
helpers automatically. To this end, SymCC could be
used to compile symbolic tracing into the helpers,
whose source code is available as part of QEMU.
The resulting binaries would be compatible with
SymQEMU because SymCC uses the same backend
for symbolic reasoning. S2E follows a similar ap-
proach when compiling the helpers to LLVM bitcode
for interpretation in KLEE.
Since such improvements would provide beneﬁt mainly
for very speciﬁc targets that make heavy use of complex
instructions, we leave them to future work.
VI. RELATED WORK
We now place SymQEMU in the context of previous work.
A. Binary-only symbolic execution
Angr [25], S2E [6], QSYM [28] and SymCC [20] have
all been described in Section II, and we have compared
them to SymQEMU in Section III-D. Mayhem [5] is a high-
performance interpreter-based implementation of symbolic ex-
ecution that won the DARPA CGC competition; unfortunately,
it is not publicly available for comparison. Triton [22] has
a symbolic execution component
that can operate in two
different modes: one uses binary translation (like QSYM),
the other works with CPU emulation (like S2E and angr).
Eclipser [7] covers some middle ground between fuzzing
and symbolic execution by assuming linear relations between
branch conditions and input data; the constraint simpliﬁcation
increases the system’s performance at the cost of reasoning
power, so that Eclipser cannot ﬁnd all the paths that conven-
tional symbolic execution can. In a similar vein, Redqueen [1]
searches for correspondence between branch conditions and
input bytes using a number of heuristics. SymQEMU,
in
contrast, implements “full” symbolic execution.
B. Run-time bug detection
Hybrid fuzzing relies on the fuzzer and sanitizers to detect
bugs. Address sanitizer [23] is a very popular sanitizer that
checks for certain memory errors. Since it requires source
code to produce instrumented target programs, Fioraldi et al.
have recently proposed QASan [8], a QEMU-based system that
implements similar checks for binaries. There is a plethora
of other sanitizers, often requiring source code [26]. We
conjecture that it would be possible to use many of them
on binaries via emulation in the spirit of QASan. They could
complement hybrid fuzzing with SymQEMU, but such work
is orthogonal to what we present here.
C. Hybrid fuzzing
Driller [27] is a hybrid fuzzer based on angr, similar in
concept to QSYM but slower because of its Python implemen-
tation and interpreter-based approach [19], [28]. In comparison
with QSYM and SymQEMU, it uses a more elaborate strategy
to coordinate fuzzer and symbolic executor: it monitors the
fuzzer’s progress and switches to symbolic execution when-
ever the fuzzer appears to encounter obstacles that it cannot
overcome on its own. In a similar spirit, the recently proposed
Pangolin [10] enhances the fuzzer’s beneﬁt from symbolic
execution by providing the fuzzer not only with new test
cases but also with an abstraction of the symbolic constraints,
along with a fast sampling method; using those, the fuzzer can
generate new inputs that have a high probability of fulﬁlling
the path constraints determined by symbolic execution.
We believe that more sophisticated coordination strategies
between fuzzer and symbolic executor can greatly enhance the
performance of hybrid fuzzing. However, since such improve-
ments are orthogonal to the speed of the symbolic executor
(which is the main concern of SymQEMU), they are outside
the scope of this paper.
VII. CONCLUSION
We have presented SymQEMU, a novel approach to ap-
ply compilation-based symbolic execution to binaries. Our
evaluation shows that SymQEMU signiﬁcantly outperforms
state-of-the-art binary symbolic executors and even keeps up
with source-based techniques. Moreover, SymQEMU is easy
to extend to many target architectures, requiring just a handful
lines of code to support any architecture that QEMU can
handle. Finally, we have demonstrated SymQEMU’s real-
world use by discovering a previously unknown memory error
in the heavily tested libarchive library.
AVAILABILITY
The source code for SymQEMU is publicly avail-
at http://www.s3.eurecom.fr/tools/symbolic execution/
able
13
symqemu.html. At the same location, we also provide detailed
instructions to reproduce our experiments, and we share the
raw results of our own evaluation.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their thoughtful
feedback and suggestions which helped us to increase the
quality of the paper. This work has been supported partly
by the DAPCODS/IOTics ANR 2016 project (ANR-16-CE25-
0015) and partly by the Defense Advanced Research Projects
Agency (DARPA) under agreement number FA875019C0003.
REFERENCES
[1] C. Aschermann, S. Schumilo, T. Blazytko, R. Gawlik, and T. Holz,
“Redqueen: Fuzzing with input-to-state correspondence.” in Network
and Distributed System Security Symposium (NDSS), vol. 19, 2019, pp.
1–15.
[2] R. Baldoni, E. Coppa, D. C. D’Elia, C. Demetrescu, and I. Finocchi,
“A survey of symbolic execution techniques,” ACM Computing Surveys
(CSUR), vol. 51, no. 3, p. 50, 2018.
[3] F. Bellard, “QEMU, a fast and portable dynamic translator,” in USENIX
Annual Technical Conference, FREENIX Track, vol. 41, 2005, p. 46.
[4] C. Cadar, D. Dunbar, and D. R. Engler, “KLEE: Unassisted and auto-
matic generation of high-coverage tests for complex systems programs,”
in OSDI, vol. 8, 2008, pp. 209–224.
[5] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing
Mayhem on binary code,” in 2012 IEEE Symposium on Security and
Privacy.
IEEE, 2012, pp. 380–394.
[6] V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: A platform for
in-vivo multi-path analysis of software systems,” in ACM SIGARCH
Computer Architecture News, vol. 39, no. 1. ACM, 2011, pp. 265–
278.
J. Choi, J. Jang, C. Han, and S. K. Cha, “Grey-box concolic testing
on binary code,” in 2019 IEEE/ACM 41st International Conference on
Software Engineering (ICSE).
IEEE, 2019, pp. 736–747.
[7]
[8] A. Fioraldi, D. C. D’Elia, and L. Querzoni, “Fuzzing binaries
for memory safety errors with QASan.” [Online]. Available: https:
//andreaﬁoraldi.github.io/assets/qasan-secdev20.pdf
“Toward the
[9] E. Gustafson, M. Muench, C. Spensky, N. Redini, A. Machiry,
Y. Fratantonio, D. Balzarotti, A. Francillon, Y. R. Choe, C. Kruegel,
and G. Vigna,
embedded ﬁrmware
through automated re-hosting,” in 22nd International Symposium
on Research in Attacks,
Intrusions and Defenses (RAID 2019).
Chaoyang District, Beijing: USENIX Association, Sep. 2019, pp. 135–
150. [Online]. Available: https://www.usenix.org/conference/raid2019/
presentation/gustafson
analysis of
[10] H. Huang, P. Yao, R. Wu, Q. Shi, and C. Zhang, “Pangolin:
Incremental hybrid fuzzing with polyhedral path abstraction,” in
2020 IEEE Symposium on Security and Privacy
Los
Alamitos, CA, USA: IEEE Computer Society, May 2020, pp. 1613–
1627. [Online]. Available: https://doi.ieeecomputersociety.org/10.1109/
SP40000.2020.00063
(SP).
[11] S. Kim, M. Faerevaag, M. Jung, S. Jung, D. Oh, J. Lee, and S. K. Cha,
“Testing intermediate representations for binary analysis,” in Proceed-
ings of the 32nd IEEE/ACM International Conference on Automated
Software Engineering.
J. C. King, “Symbolic execution and program testing,” Communications
of the ACM, vol. 19, no. 7, pp. 385–394, 1976.
IEEE Press, 2017, pp. 353–364.
[12]
[13] G. Klees, A. Ruef, B. Cooper, S. Wei, and M. Hicks, “Evaluating
fuzz testing,” in Proceedings of the 2018 ACM SIGSAC Conference
on Computer and Communications Security, 2018, pp. 2123–2138.
[14] C. Lattner and V. Adve, “LLVM: A compilation framework for lifelong
program analysis & transformation,” in Proceedings of the International
Symposium on Code Generation and Optimization: Feedback-Directed
and Runtime Optimization.
IEEE Computer Society, 2004, p. 75.
14
[15] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: Building customized
program analysis tools with dynamic instrumentation,” in Acm sigplan
notices, vol. 40, no. 6. ACM, 2005, pp. 190–200.
[16] M. Muench, J. Stijohann, F. Kargl, A. Francillon, and D. Balzarotti,
“What you corrupt is not what you crash: Challenges in fuzzing embed-
ded devices,” in Network and Distributed System Security Symposium
(NDSS), 2018.
[17] N. Nethercote and J. Seward, “Valgrind: A framework for heavyweight
dynamic binary instrumentation,” in ACM SIGPLAN 2007 Conference
on Programming Language Design and Implementation (PLDI 2007),
vol. 42, no. 6. ACM, 2007, pp. 89–100.
[18] C. Pang, R. Yu, Y. Chen, E. Koskinen, G. Portokalidis, B. Mao, and
J. Xu, “SoK: All you ever wanted to know about x86/x64 binary
disassembly but were afraid to ask,” arXiv preprint arXiv:2007.14266,
2020.
[19] S. Poeplau and A. Francillon, “Systematic comparison of symbolic
execution systems: Intermediate representation and its generation,”
in Proceedings of the 35th Annual Computer Security Applications
Conference. ACM, 2019, pp. 163–176.
[20] ——, “Symbolic execution with SymCC: Don’t interpret, compile!”
in 29th USENIX Security Symposium (USENIX Security 20).
Boston, MA: USENIX Association, 2020. [Online]. Available: https:
//www.usenix.org/conference/usenixsecurity20/presentation/poeplau
[21] N. A. Quynh and D. H. Vu, “Unicorn – the ultimate CPU emulator,”
https://www.unicorn-engine.org/, 2015.
[22] F. Saudel and J. Salwan, “Triton: A dynamic symbolic execution frame-
work,” in Symposium sur la s´ecurit´e des technologies de l’information
et des communications, SSTIC, Rennes, France, June 3-5 2015. SSTIC,
2015, pp. 31–54.
[23] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, “Address-
Sanitizer: A fast address sanity checker,” in USENIX Annual Technical
Conference (USENIX ATC 12), 2012, pp. 309–318.
[24] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna,
“Firmalice – automatic detection of authentication bypass vulnerabili-
ties in binary ﬁrmware,” in Network and Distributed System Security
Symposium (NDSS), 2015.
[25] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel et al., “Sok:
(state of) the art of war: Offensive techniques in binary analysis,” in
2016 IEEE Symposium on Security and Privacy (SP).
IEEE, 2016, pp.
138–157.
[26] D. Song, J. Lettner, P. Rajasekaran, Y. Na, S. Volckaert, P. Larsen, and
M. Franz, “SoK: Sanitizing for security,” in 2019 IEEE Symposium on
Security and Privacy (SP).
IEEE, 2019, pp. 1275–1295.
[28]
[27] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting
fuzzing through selective symbolic execution,” in Network and Dis-
tributed System Security Symposium (NDSS), vol. 16, 2016, pp. 1–16.
I. Yun, S. Lee, M. Xu, Y. Jang, and T. Kim, “QSYM: A practical
concolic execution engine tailored for hybrid fuzzing,” in 27th USENIX
Security Symposium (USENIX Security 18), 2018, pp. 745–761.
J. Zaddach, L. Bruno, A. Francillon, and D. Balzarotti, “AVATAR: A
framework to support dynamic security analysis of embedded systems’
ﬁrmwares.” in Network and Distributed System Security Symposium
(NDSS), vol. 14, 2014, pp. 1–16.
[29]
APPENDIX A
S2E RESOURCE CONSUMPTION
We encountered a few challenges related to resource
consumption when setting up S2E for our experiments (see
Section IV-B). While they are not essential to the discussion,
we still think they are interesting to document.
A. Parallel S2E
S2E has a parallel mode,
in which it starts multiple
processes and assigns each a dedicated portion of the state
low-performing fuzzers are based on. Similarly, SymQEMU
depends on the fuzzer to identify promising test cases, so
when the fuzzer’s instrumentation fails it cannot make progress
either.
tree.14 Initially, we tried to use this mode to compensate for
the fact that the other symbolic executors in our comparison
each use 3 CPU cores. However, in our setup, parallel mode
was prone to deadlocks and crashes that turned out to be hard
to debug. As a workaround, we started 3 independent S2E
instances, relying on randomization of the search strategy to
prevent them from exploring the same paths. This is not ideal
but seemed the fairest approach given the circumstances.
B. Memory limits
Like the other systems in the comparison, we attempted
to execute S2E with 2 GB of RAM per CPU core (i.e., per
S2E process). Setting a hard limit via cgroups, as we did
for the other systems,
turned out impossible because S2E
runs the entire analysis in a single long-running process—if
the operating system terminates that process due to excessive
memory consumption, the analysis fails. (In contrast, AFL,
SymQEMU, QSYM and SymCC create many short-lived anal-
ysis processes; if one of them fails, the analysis just continues
with the next one.)
S2E provides the ResourceMonitor plugin for such cases.15
Its task is to monitor memory consumption (with the limit
deﬁned via a cgroup) and prevent further forking or termi-
nate execution states as consumption approaches the limit.
Unfortunately, in our experiments, the plugin did not reduce
memory consumption aggressively enough—while the anal-
ysis ran slightly longer, it would still eventually exceed the
memory limit and trigger the operating system’s OOM killer.
We experimented with adjusting the plugin’s threshold (e.g.,
trigger earlier than the default
threshold of 95 % memory
consumption) but could not ﬁnd a conﬁguration that would
permit the analysis to run for 24 hours.
Finally, we resorted to the following strategy: instead of
enforcing 2 GB per S2E instance, we only imposed a total limit
on the cumulative memory consumption of all S2E processes.
As a result, some processes were terminated by the operating
system whereas others were allowed to consume signiﬁcantly
more than 2 GB of RAM and thus analyze the target for
24 hours. The reason that this strategy did not result in higher
variance of the results for S2E (see Figure 11) is that most
execution states were forked in the ﬁrst few minutes of the
analysis, i.e., before any process hit the memory limit.
APPENDIX B
FUZZBENCH REPORT
The ﬁgures below show the respective ranking of the
fuzzers and our SymQEMU/AFL hybrid fuzzer on the 21
FuzzBench targets (see Section IV-A). We cannot include the
full report for space reasons, but you can ﬁnd the report
rendered on our website;16 in addition to the mere rankings, it
shows coverage over time, statistical signiﬁcance and coverage
distribution across the different trials for each target.
According to the authors of the FuzzBench suite, the low
performance of all but ﬁve fuzzers on the libpcap target is due
to a deﬁciency in AFL’s code instrumentation, which all the
14http://s2e.systems/docs/Howtos/Parallel.html
15http://s2e.systems/docs/FAQ.html#how-to-keep-memory-usage-low
16http://www.s3.eurecom.fr/tools/symbolic execution/symqemu.html
15
16
17
18