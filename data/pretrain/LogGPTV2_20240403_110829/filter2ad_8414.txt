# hancitor unpack
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## intro
日前在与某外国师傅的交流中，感受到了恶意代码的魅力，因此沉迷于学习逆向知识，近期常在[malware-traffic-analysis](https://www.malware-traffic-analysis.net/)和[MalShare](https://malshare.com/)看到hancitor装载器的出现，苦于虽然有着现有的unpack技术，但是没有手动unpack的能力，对某文章进行学习复现并有了以下的分析文章。
## 关于Hancitor.exe的unpack的一个复现
MD5 (Hancitor – Packed): c07661bd4f875b6c6908f2d526958532  
MD5 (Hancitor – Unpacked, Unmapped): 5fe47865512eb9fa5ef2cccd9c23bcbf
在entrypoint处发现了几个call，比较引人注意的是call ebx。在call ebx处打下断点。
进入之前首先来到ebx处查看，是通过mov指令生成的shellcode，我们按p生成函数，生成失败，但是把大部分的数据都转换成了code，说明此处并不是函数，而是一个类似跳转到shellcode的作用。
那么我们进入该shellcode，能看到是非常多的jmp，jno指令
进行简单步入，发现基本上是一个汇编指令进行jmp一次，我们跟踪后发现其通过一次一指令的方式生成了VirtualProtect函数，并在00406126地址处通过call
eax 调用。
我们越过这个call，跟踪到了一段XOR，自增，比较。
然后就是不断的重复，我们可以在jb处打下断点，因为循环时都是完成跳转到loc_4061BE，我们直接运行到jno loc_406137即可。
然后就是jmp eax，经典的shellcode跳转语句
跳转完成后生成函数得到如下代码（这里的pusha也许也是开始恢复代码的标志）
紧接着我们会来到此处，此处的call
$+5代表着什么呢？运行可以得到我们跳转到了0x40a316地址处，简单的混淆代码，没什么作用，实际上就是执行下一条命令。
继续执行发现寄存器界面中开始输出GetProcAddress函数，这里其实是一个导入函数的过程。
往下翻即可找到一些函数，这个部分加载了不同的dll和函数，并不是我们需要关注的点，我们可以直接到最后打断点并运行，跳过这些让我们心烦的导入函数。
然后运行到jmp eax，我们可以在0040A63C处打下断点，如下，也就是我们这个函数的ret地址。
然后我们会到达这个函数，同样我们直接到达底部的jmp处
然后我们会到达一个rc4的解密程序，（虽然一眼看不出这是一个rc4，这里可以通过伪c代码进行观察，但是数据也是非常的多和杂，我们可以直接跳过）程序ret到了004015F0地址处。
sub_4011F0函数可以看到一些解密代码，对我们的code进行分组异或解密，然后进行DecompressBuffer函数操作，不得不说这是一个比较好的混淆方式，恶意代码在某些地方的技术确实比较先进。
我们直接跳过这些代码，在sub_401610函数中能够找到最重要的一部分代码，也就是最后的三个函数
**GetMessageA** , **TranslateMessage** , and **DispatchMessageA**.
而我们要做的就是在程序打断点在程序退出前dump下解密后的代码，可能需要一点时间。
虽然没有命中该函数的ret指令，它回到了00401298地址处的ret，但是我们的malware代码已经解压完成了，此时我们需要知道解压后的memory存储在什么位置，实际上它是解压到了，我们可以通过dump出内存慢慢找也可以利用ida的字符串搜索功能（虽然我的ida在此期间崩溃了）
我们通过process hacker 打开 程序的内存并找到0x460000内存出进行dump
然后双击dump出内存
于此同时，我们与文章中unpack得到的内存进行check，发现我们并没有dump错内存。
#####  unmap
那么接下来我们需要做的就是进行unmap操作了，这里同样使用pe bear
> As we dumped the payload from memory, it is mapped, so we need to unmap it.
> Open the dumped file in PE-Bear and go to the Section Headers option, as
> shown in the image. You need to change the value of the Raw Addr. so that it
> matches the value of the Virtual Addr. You then need to change the Raw size
> of each of the sections, except for the last section, which is **.reloc**
> here.
我们需要更改的地址是Raw Addr
修改过Raw Size 后
至于为什么要这么修改呢？unmap 的根据是什么呢？这里我并不熟悉，仅提出解决的方法，期待日后对PE结构详细学习。
一是根据原有的Raw Address 然后凑整即可（猜的）。二是可以用010Editor进行选中它会告诉我们真正的Raw Size
，然后我们再根据数据进行计算即可。
最后，因此我们的导入函数表也完成了恢复
然后我们dump下来的文件就已经修复完毕了，接下来我们就可以看到完整的恶意代码了。
## 收尾
以上文章的内容皆是通过学习如下链接进行复现，感谢观看。