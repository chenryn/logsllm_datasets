b
退出sed，不再处理更多的文本行。如果不指定-n选项，输
出当前行。
Q
退出sed，不再处理更多的文本行。
s/regexp/replace-
只要找到一个regexp匹配项，就替换为replacement 的内
ment/
容。replacement可能包括特殊字符&，其等价于由regexp
匹配的文本。另外，replacement可能包含序列\1到\9，其
是regexp中相对应的子表达式的内容。更多信息，查看下
面back references 部分的讨论·在replacement 末尾的斜杠
之后，可以指定一个可选的标志，来修改s命令的行为。
y/set1/set2
执行字符转写操作，通过把set1中的字符转变为相对应的
set2中的字符。注意不同于tr程序，sed要求两个字符集合
具有相同的长度。
表21-8：sed基本编辑命令
到目前为止，这个s命令是最常使用的编辑命令。我们将仅仅演示一些它的功能，通过编辑
我们的distros.txt文件。我们以前讨论过distros.txt文件中的日期字段不是“友好地计算机”
模式。文件中的日期格式是MM/DD/YYYY.但如果格式是YYYY-MM-DD会更好一些（利
于排序）。手动修改日期格式不仅浪费时间而且易出错，但是有了sed，只需一步就能完成修改：
[ne1inuxbox ]$ seds/\([09]\{2\}1)/\([0-9]\{21)/([09]\{4\)s/3\1-2/distros.txt
3S0S
10.2
20061207
Fedora
10
20081125
SUSE
11.0
20080619
Ubuntu
8.04
20080424
Fedora
8
20071108
3S0S
10.3
20071004
Ubuntu
6.10
20061026
Fedora
7
20070531
Ubuntu
7.10
2007-1018
Ubuntu
7.04
20070419
3S0S
10.1
20060511
302
---
## Page 304
Fedora
6
20061024
Fedora
9
20080513
Ubuntu
6.06
20060601
Ubuntu
8.10
20081030
Fedora
5
20060320
哇！这个命令看起来很丑随。但是它起作用了。仅用一步，我们就更改了文件中的日期格
式。它也是一个关于为什么有时候会开玩笑地把正则表达式称为是“只写”媒介的完美的例
子。我们能写正则表达式，但是有时候我们不能读它们。在我们恐惧地忍不住要逃离此命令之
前，让我们看一下怎样来构建它。首先，我们知道此命令有这样一个基本的结构：
sed 's/regexp/replacenent/' distros.txt
我们下一步是要弄明白一个正则表达式将要孤立出日期。因为日期是MM/DD/YYYY格
式，并且出现在文本行的末尾，我们可以使用这样的表达式：
[09] 2]/[09]{2]/[09]{4}$
此表达式匹配两位数字，一个斜杠，两位数字，一个斜杠，四位数字，以及行尾。如此关心
功能，它出现在一些使用BRE的应用程序中。这个功能叫做逆参照，像这样工作：如果序列
An出现在replacement中，这里n是指从1到9的数字，则这个序列指的是在前面正则表达
式中相对应的子表达式。为了创建这个子表达式，我们简单地把它们用圆括号括起来，像这样
([09]{2})/ ([09] {2})/ ([09] {4})$
现在我们有了三个子表达式。第一个表达式包含月份，第二个包含某月中的某天，以及第三
个包含年份。现在我们就可以构建replacement，如下所示：
\3\1-\2
303
---
## Page 305
此表达式给出了年份，一个短划线，月份，一个短划线，和某天。
现在我们的命令看起来像下面这样：
sed *s/([09]{2})/([09]{2})/([09]{4})$/^3\12/′ distros .txt
我们还有两个问题。第一个是当sed试图解释这个s命令的时候在我们表达式中额外的斜
杠将会使sed迷惑。第二个是由于sed默认情况下只接受基本的正则表达式，在表达式中的几
个字符会被当作文字字面值，而不是元字符。我们能够通过反斜杠的自由应用来转义令人不快
的字符解决这两个问题，：
seds/[09]2/[09]{2)([09]{4)s/312/distros.txt
你掌握了吧！
8命令的另一个功能是使用可选标志，其跟随替代字符串。一个最重要的可选标志是g标
志，其指示sed对某个文本行全范围地执行查找和替代操作，不仅仅是对第一个实例，这是默
认行为。这里有个例子：
/8/q/s, pas 1 ,3soqqqeee, owpa $[- xoqxnuteou]
aaaBbbccc
我们看到虽然执行了替换操作，但是只针对第一个字母“b”实例，然而剩余的实例没有更
改。通过添加g标志，我们能够更改所有的实例：
8/g/q/s, pas 1 ,oqqqeee,oqa s[- xoqxutsou]
aaaBBBccc
目前为止，通过命令行我们只让sed执行单个命令。使用-f选项，也有可能在一个脚本文件
中构建更加复杂的命令。为了演示，我们将使用sed和distros.txt文件来生成一个报告。我们
的报告以开头标题，修改过的日期，以及大写的发行版名称为特征。为此，我们需要编写一个
脚本，所以我们将打开文本编辑器，然后输入以下文字：
304
---
## Page 306
# sed script to produce Linux
1i\
Linux Distributions Report\
s/([09]{2)([09]2)/([09]{4)$/3\12/
y/abcdefghi jklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXY2/
我们将把sed脚本保存为distros.sed文件，然后像这样运行它：
[ne@linuxbox -]$ sed -f distros.sed distros.txt
Linux Distributions Report
SUSE 10.2 2006-12-07
FEDORA 10
20081125
SUSE 11.0 2008-06-19
UBUNTU 8.04 2008-04-24
FEDORA 8
20071108
SUSE 10.3 2007-10-04
UBUNTU 6.10 2006-10-26
FEDORA 7
20070531
UBUNTU 7.10 20071018
UBUNTU 7.04 200704-19
SUSE 10.1 2006-0511
FEDORA 6
2006-1024
FEDORA 9
20080513
正如我们所见，我们的脚本文件产生了期望的结果，但是它是如何做到的呢？让我们再看一
下我们的脚本文件。我们将使用cat来给每行文本编号：
[ne@linuxbox -]$ cat -n distros.sed
1 # sed script to produce Linux distributions report
2
3 1 i\
4\
305
---
## Page 307
5 Linux Distributions Report\
7 ≤/092[092[09]{)/312/
8 y/abcdefghijklmmopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
我们脚本文件的第一行是一条注释。如同Linux系统中的许多配置文件和编程语言一样
注释以#字符开始。然后是人类可读的文本。注释可以被放到脚本中的任意地方（虽然不在命
令本身之中）．且对任何可能需要理解和/或维护脚本的人们都很有帮助。
第二行是一个空行。正如注释一样，添加空白行是为了提高程序的可读性。
许多sed命令支持行地址。这些行地址被用来指定对输入文本的哪一行执行操作。行地址
可能被表示为单独的行号，行号范围，以及特殊的行号“s”，它表示输入文本的最后一行。
从第三行到第六行所包含地文本要被插入到地址1处，也就是输入文本的第一行中。这个
i命令之后是反斜杠回车符，来产生一个转义的回车符，或者就是所谓的连行符。这个序列能
够被用在许多环境下，包括shell脚本，从而允许把回车符嵌入到文本流中，而没有通知解释
器（在这是指sed解释器）已经到达了文本行的末尾·这个i命令，同样地，命令a（追加文
本，而不是插入文本）和e（取代文本）命令都允许多个文本行，只要每个文本行，除了最后一
行，以一个连行符结束。实际上，脚本的第六行是插入文本的末尾，它以一个普通的回车符结
尾，而不是一个连行符，通知解释器i命令结束了。
注意：一个连行符由一个反斜杠字符其后紧跟一个回车符组成。它们之间不允许有空白字
符。
第七行是我们的查找和替代命令。因为命令之前没有添加地址，所以输入流中的每一行文
本都得服从它的操作。
第八行执行小写字母到大写字母的字符替换操作。注意不同于tr命令，这个sed中的y命
令不支持字符区域（例如，[a-z），也不支持POSIX字符集。再说一次，因为y命令之前不带
地址，所以它会操作输入流的每一行。
喜欢sed的人们也会喜欢。
306
---
## Page 308
sed是一款非常强大的程序，它能够针对文本流完成相当复杂的编辑任务。它最
常用于简单的行任务，而不是长长的脚本。许多用户喜欢使用其它工具，来执行较
大的工作。在这些工具中最著名的是awk和perl。它们不仅仅是工具，像这里介绍
的程序，且延伸到完整的编程语言领域。特别是perl，经常被用来代替shell脚本，
来完成许多系统管理任务，同时它也是一款非常流行网络开发语言。awk更专用一
些。其具体优点是其操作表格数据的能力。awk程序通常逐行处理文本文件，这点
类似于sed，awk使用了一种方案，其与sed中地址之后跟随编辑命令的概念相似。
虽然关于awk和perl的内容都超出了本书所讨论的范围，但是对于Linux命令行
用户来说，它们都是非常好的技能。
21.5.3aspell
我们要查看的最后一个工具是aspell，一款交互式的拼写检查器。这个aspell程序是早先ispell
程序的继承者，大多数情况下，它可以被用做一个替代品。虽然aspell程序大多被其它需要拼
写检查能力的程序使用，但它也可以作为一个独立的命令行工具使用。它能够智能地检查各种
类型的文本文件，包括HTML文件，C/C++程序，电子邮件和其它种类的专业文本。
拼写检查一个包含简单的文本文件。可以这样使用aspell：
aspell check textfile
这里的textfile是要检查的文件名。作为一个实际例子，让我们创建一个简单的文本文件
叫做foo.txt，包含一些故意的拼写错误：
[ne@linuxbox -]$ cat > foo.txt
The quickt brown fox jinped over the laxy dog
下一步我们将使用aspell来检查文件：
[ne@linuxbox-]$ aspel1check foo.txt
因为aspell在检查模式下是交互的，我们将看到像这样的一个屏幕：
307
---
## Page 309
The quick brown fox jinped over the laxy dog.
1) junped
6)vinped
2)ginped
7)canped
3) conped
padunq(8
4)1inped
9) inpede
5)pinped
0)unped
i) Ignore
I) Ignore al1
r)Replace
R)Replace a11
a) Add
1)Add Lower
b) Abort
x)Exit
？
在显示屏的顶部，我们看到我们的文本中有一个拼写可疑且高亮显示的单词。在中间部分，
我们看到十个拼写建议，序号从0到9，然后是一系列其它可能的操作。最后，在最底部，我
们看到一个提示符，准备接受我们的选择。
如果我们按下1按键，aspell会用单词“jumped”代替错误单词，然后移动到下一个拼写
错的单词，就是“laxy”。如果我们选择替代物“lazy”，aspell会替换“laxy”并且终止。一旦
aspell结束操作，我们可以检查我们的文件，会看到拼写错误的单词已经更正了。
[ne@linuxbox -]$ cat foo.txt
The quick brown fox junped over the lazy dog.
除非由命令行选项--dont-backup 告诉aspell，否则通过追加扩展名.bak到文件名中，aspell
会创建一个包含原始文本的备份文件。
为了炫耀sed的编辑本领，我们将还原拼写错误，从而能够重用我们的文件：
xs oog /podztC/podum/= 1/≤xet/Kzet/=,- pos s[- xoqxnutou]
这个sed选项-i，告诉sed在适当位置编辑文件，意思是不要把编辑结果发送到标准输出
中。sed会把更改应用到文件中，以此重新编写文件。我们也看到可以把多个sed编辑命令放
在同一行，编辑命令之间由分号分隔开来。
下一步，我们将看一下aspell怎样来解决不同种类的文本文件。使用一个文本编辑器，例
如vim（胆大的人可能想用sed），我们将添加一些HTML标志到文件中：
308
---
## Page 310
Mispelled HTML file
dog.
现在，如果我们试图拼写检查我们修改的文件，我们会遇到一个问题。如果我们这样做：
[ne@linuxbox -]$ aspell check foo.txt
我们会得到这些：
Mispe1led HTML file
The quick broun fox jinped over the laxy dog.
1) HTML
4) Hame1
2) ht m1
5) Hami1