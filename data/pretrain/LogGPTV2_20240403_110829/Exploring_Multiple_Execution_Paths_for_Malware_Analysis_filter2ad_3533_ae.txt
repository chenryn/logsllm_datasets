  5:      run_ddos_attack();
Blaster Denial-of-Service Attack
  0:   // receive line from network --> store in array a[]
  1:   // a[0] = command, a[1] = arg1, a[2] = arg2, ...
  2:
  3:   if (strcmp("crash", a[0]) == 0) {
  4:       strcmp(a[5],"crash"); // yes, this will crash.
  5:       return 1;
  6:   }
  7:   else if (strcmp("getcdkeys", a[0]) == 0) {
  8:       getcdkeys(sock,a[2],notice);
  9:       return 1;
10:   }
11:   else if (strcmp("driveinfo", a[0]) == 0) {
12:       DriveInfo(sock, a[2], notice, a[1]);
13:       return 1;
14:   }
rxBot Command Loop
Figure 4. Blaster and rxBot source code snippets.
ory and the constraint system. During our experiments, we
determined that the size of a state was equal to about three
times the amount of memory that a process has allocated.
On average, the size of a state was about 3.5 MB, and it
never exceeded 10 MB. The time needed to create or re-
store a snapshot was 4 milliseconds on average, with a small
variance (on an Intel Pentium IV with 3.4 GHz and 2 GB
RAM). As mentioned in Section 4.2, a timeout of 20 sec-
onds was set for the exploration of each individual program
path. In addition, we set a timeout of 100 seconds for the
complete analysis run of each sample. This tight, additional
time limit was introduced to be able to handle a large num-
ber of samples in case certain malware instances would cre-
ate many paths. In our experiments, we observed that 58%
of the malware programs ﬁnished before the timeout ex-
pired. The remaining 42% of the samples had unexplored
paths left when the analysis process was terminated. As a
result, by increasing the total timeout, we would expect to
achieve an even larger increase in code coverage than that
reported in the previous paragraphs. The trade-off is that it
would take longer until results are available.
The size of a state could be signiﬁcantly reduced if we
exploited the fact that the majority of memory locations
and entries in the shadow memory are 0. Also, we could
attempt to create incremental snapshots that only store the
difference between the current and previous states. In the-
ory, the number of concurrently active states can be as high
as the number of branching points encountered. However,
we observed that this is typically not the case, and the num-
ber of concurrently active states during the experiments was
lower. More precisely, our system used on average 31 con-
current states (the maximum was 469). Note that these num-
bers also represent the average and maximum depths of the
search trees that we observed, as we use a depth-ﬁrst search
strategy. The total number of states were on average 32,
with a maximum of 1,210. Given the number of concur-
rently active states, we deemed it not necessary to develop
more sophisticated algorithms to create program snapshots.
Moreover, in a synthetic benchmark, we veriﬁed that our
system can handle more than thousand active states.
6 Related Work
Malicious code analysis. Analyzing malicious executa-
bles is not a new problem; consequently, a number of solu-
tions already exist. These solutions can be divided into two
groups: static analysis and dynamic analysis techniques.
Static analysis is the process of analyzing a program’s code
without actually executing it. This approach has the advan-
tage that one can cover the entire code and thus, possibly
capture the complete program behavior, independent of any
single path executed during run-time. In [8], a technique
was introduced that uses model checking to identify parts of
a program that implement a previously speciﬁed, malicious
code template. This technique was later extended in [9],
allowing more general code templates and using advanced
static analysis techniques. In [21], a system was presented
that uses static analysis to identify malicious behavior in
kernel modules that indicate a rootkit. Finally, in [20], a
behavioral-based approach was presented that relies heavily
on static code analysis to detect Internet Explorer plug-ins
that exhibit spyware-like behavior. The main weakness of
static analysis is that the code analyzed may not necessarily
be the code that is actually run. In particular, this is true for
self-modifying programs that use polymorphic or metamor-
phic techniques [27]. Also, malware can draw from a wide
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007range of obfuscation mechanisms [22, 30] that may make
static analysis very difﬁcult.
Because of the many ways in which code can be obfus-
cated and the fundamental limits in what can be decided
statically, we ﬁrmly believe that dynamic analysis is a nec-
essary complement to static detection techniques. In [4], a
behavior-based approach was presented that aims to dynam-
ically detect evasive malware by injecting user input into
the system and monitoring the resulting actions. In addi-
tion, a number of approaches exist that directly analyze the
code dynamically. Unfortunately, the support for dynamic
code analysis is limited; often, it only consists of debug-
gers or disassemblers that aid a human analyst. Tools such
as CWSandbox [29], the Norman SandBox [25], TTAna-
lyze [2], or Cobra [28] automatically record the actions per-
formed by a code sample, but they only consider a single
execution path and thus, might miss relevant behavior. To
address this limitation and to capture a more comprehensive
view of a program’s behavior, we developed our approach
to explore multiple execution paths.
A very recent work that addresses the detection of hid-
den, time-based triggers in malware is described in [13].
In their work, the authors attempt to automatically discover
time-dependent behavior by setting the system time to dif-
ferent values. The problem is that time-based triggers can
be missed when the system time is not set to the exact time
that the malware expects. In our approach, we do not at-
tempt to provide an environment such that trigger condi-
tions are met, but explore multiple code paths independent
of the environment. Thus, we have a better chance of ﬁnd-
ing hidden triggers. In addition, our approach is more com-
prehensive, as we can detect arbitrary triggers.
Finally, in their technical report [5], the authors present
a system that is similar to ours in its goal to detect trigger-
based malware behavior. The main differences are the sys-
tem design, which is based on mixed execution of binary
code using elements of symbolic execution, and a less com-
prehensive evaluation (on four malware samples).
Software testing. The goal of our work is to obtain a
more complete picture of the behavior of a malicious code
sample, together with the conditions under which certain
actions are performed. This is analogous to software testing
where one attempts to ﬁnd inputs that trigger bugs.
A number of test input generation systems [6, 15, 16]
were presented that analyze a program and attempt to ﬁnd
input that drives execution to a certain program point. The
difference to our approach is that the emphasis of these
systems is to reach a certain point, and not to explore the
complete program behavior. Other tools were proposed that
explore multiple paths of a program to detect implementa-
tion errors. For example, model checking tools [10, 17, 18]
translate programs into ﬁnite state machines and then rea-
son whether certain properties hold on these automata. The
systems that are closest to our work are DART [14] and
EXE [7]. Both systems use symbolic execution [19]. That
is, certain inputs are expressed as symbolic variables, and
the system explores in parallel both alternative execution
paths when a conditional operation is found that uses this
symbolic input. Similar to our approach, these systems can
explore multiple execution paths that depend on interest-
ing input. Also, the conditions under which certain paths
are selected can be calculated (and are subsequently used
to generate test cases). The main differences to our tech-
nique are the following. First, the goal of these systems is
to explore programs for program bugs while our intent is to
create comprehensive behavioral proﬁles of malicious code.
Second, we do not have the possibility of using source code
and operate directly on hostile (obfuscated) binaries. This
leads to a signiﬁcantly different implementation in which
interesting inputs are dynamically tracked by taint propaga-
tion. Also, the problem we are addressing is complicated
by the fact that we are not able to utilize built-in operating
system mechanisms (e.g., fork) to explore alternative pro-
gram paths. Hence, we require an infrastructure to save and
restore snapshots of the program execution.
Speculative execution.
In [24], a system was presented
that uses process snapshots to implement speculative execu-
tion. In distributed ﬁles systems, processes typically have to
wait until remote ﬁle system operations are completed be-
fore they can resume execution. With speculative execution,
processes continue without waiting for remote responses,
based on locally available data only. When it later turns out
that the remote operation returns data that is different from
the local one, the process is reset to its previously stored
snapshot. The concept of snapshots used in speculative ex-
ecution is similar to the one in our work. The difference is
that we use snapshots as a means to explore alternative exe-
cution paths, which requires consistent memory updates.
7 Conclusions
In this paper, we presented a system to explore multi-
ple execution paths of Windows executables. The goal is to
obtain a more comprehensive overview of the actions that
an unknown sample can perform. In addition, the tool au-
tomatically provides the information under which circum-
stances a malicious action is triggered.
Our system works by tracking how a program processes
interesting input (e.g., the local time, ﬁle checks, reads from
the network). In particular, we dynamically check for con-
ditional branch instructions whose outcome depend on cer-
tain input values. When such an instruction is encountered,
a snapshot of the current execution state is created. When
the program later ﬁnishes along the ﬁrst branch, we reset
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007it to the previously saved state and modify the argument of
the condition such that the other branch is taken. When
performing this rewrite operation, it is important to consis-
tently update all memory locations that are related to the
argument value. This is necessary to prevent the program
from executing invalid or impossible paths.
Our experiments demonstrate that, for a signiﬁcant frac-
tion of malware samples in our evaluation set, the system is
indeed exploring multiple paths. In these cases, our knowl-
edge about a program’s behavior is extended compared to
a system that observes a single run. We also show for a
number of real-world malware samples that the actions that
were discovered by our technique reveal important and rel-
evant information about the behavior of the malicious code.
Acknowledgments
This work was supported by the Austrian Science Foun-
dation (FWF) under grant P18157,
the FIT-IT project
Pathﬁnder, and the Secure Business Austria competence
center. We would like to thank our shepherd Andrew Myers
and the anonymous referees for the valuable comments.
References
[1] P. Baecher, M. Koetter, T. Holz, M. Dornseif, and F. Freil-
ing. The Nepenthes Platform: An Efﬁcient Approach To
Collect Malware.
In Recent Advances in Intrusion Detec-
tion (RAID), 2006.
[2] U. Bayer, C. Kruegel, and E. Kirda. TTAnalyze: A Tool for
Analyzing Malware. In 15th Annual Conference of the Eu-
ropean Institute for Computer Antivirus Research (EICAR),
2006.
[3] F. Bellard. Qemu, a Fast and Portable Dynamic Translator.
In Usenix Annual Technical Conference, 2005.
[4] K. Borders, X. Zhao, and A. Prakash. Siren: Catching Eva-
sive Malware (Short Paper). In IEEE Symposium on Security
and Privacy, 2006.
[5] D. Brumley, C. Hartwig, Z. Liang, J. Newsome, D. Song,
and H. Yin. Towards Automatically Identifying Trigger-
based Behavior in Malware using Symbolic Execution
and Binary Analysis. Technical Report CMU-CS-07-105,
Carnegie Mellon University, 2007.
[6] D. Brumley, J. Newsome, D. Song, H. Wang, and S. Jha.
Towards automatic generation of vulnerability-based signa-
tures. In IEEE Symposium on Security and Privacy, 2006.
[7] C. Cadar, V. Ganesh, P. Pawlowski, D. Dill, and D. Engler.
EXE: Automatically Generating Inputs of Death. In Confer-
ence on Computer and Communication Security, 2006.
[8] M. Christodorescu and S. Jha. Static Analysis of Executa-
bles to Detect Malicious Patterns. In Usenix Security Sym-
posium, 2003.
[9] M. Christodorescu, S. Jha, S. Seshia, D. Song, and
R. Bryant. Semantics-aware Malware Detection. In IEEE
Symposium on Security and Privacy, 2005.
[10] J. Corbett, M. Dwyer, J. Hatcliff, S. Laubach, C. Pasare-
anu, Robby, and H. Zheng. Bandera: Extracting Finite-State
Models from Java Source Code. In International Conference
on Software Engineering (ICSE), 2000.
[11] M. Costa, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou,
L. Zhang, and P. Barham. Vigilante: End-to-End Contain-
ment of Internet Worms. In 20th ACM Symposium on Oper-
ating Systems Principles (SOSP), 2005.
[12] J. Crandall and F. Chong. Minos: Architectural support for
software security through control data integrity. In Interna-
tional Symposium on Microarchitecture, 2004.
[13] J. Crandall, G. Wassermann, D. Oliveira, Z. Su, F. Wu, and
F. Chong. Temporal Search: Detecting Hidden Malware
Timebombs with Virtual Machines. In Conference on Archi-
tectural Support for Programming Languages and OS, 2006.
[14] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed au-
tomated random testing. In Programming Language Design
and Implementation (PLDI), 2005.
[15] A. Gotlieb, B. Botella, and M. Rueher. Automatic test data
In ACM
generation using constraint solving techniques.
Symposium on Software Testing and Analysis, 1998.
[16] N. Gupta, A. Mathur, and M. Soffa. Automated test data
generation using an iterative relaxation method. In Sympo-
sium on Foundations of Software Engineering (FSE), 1998.
[17] T. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Software
Veriﬁcation with Blast. In 10th SPIN Workshop, 2003.
[18] G. Holzmann. The model checker spin. Software Engineer-
ing, 23(5), 1997.
[19] J. King. Symbolic Execution and Program Testing. Com-
munications of the ACM, 1976.
[20] E. Kirda, C. Kruegel, G. Banks, G. Vigna, and R. Kemmerer.
Behavior-based Spyware Detection. In Usenix Security Sym-
posium, 2006.
[21] C. Kruegel, W. Robertson, and G. Vigna. Detecting Kernel-
Level Rootkits Through Binary Analysis. In Annual Com-
puter Security Application Conference (ACSAC), 2004.
[22] C. Linn and S. Debray. Obfuscation of Executable Code to
Improve Resistance to Static Disassembly. In ACM Confer-
ence on Computer and Communications Security, 2003.
[23] J. Newsome and D. Song. Dynamic taint analysis for au-
tomatic detection, analysis, and signature generation of ex-
ploits on commodity software. In 12th Annual Network and
Distributed System Security Symposium (NDSS), 2005.
[24] E. Nightingale, P. Chen, and J. Flinn. Speculative Execution
in a Distributed File System. In 20th Symposium on Operat-
ing Systems Principles (SOSP), 2005.
[25] Norman.
Normal Sandbox.
http://sandbox.
norman.no/, 2006.
[26] Symantec.
Internet Security Threat Report: Volume
http://www.symantec.com/enterprise/
X.
threatreport/index.jsp, 2006.
[27] P. Szor. The Art of Computer Virus Research and Defense.
Addison Wesley, 2005.
[28] A. Vasudevan and R. Yerraballi. Cobra: Fine-grained Mal-
ware Analysis using Stealth Localized-Executions. In IEEE
Symposium on Security and Privacy, 2006.
[29] C. Willems. CWSandbox: Automatic Behaviour Analysis
of Malware. http://www.cwsandbox.org/, 2006.
[30] G. Wroblewski. General Method of Program Code Obfusca-
tion. PhD thesis, Wroclaw University of Technology, 2002.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007