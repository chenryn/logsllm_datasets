precise, it is narrowly focused on IOs at the memory allocation
sites and cannot scale up to big programs like OS kernels.
Another
line of work on detecting IOs
including
IntScope [35], IntFlow [29], IntEq [33], Osiris [34], and In-
tRepair [28], trying to detect IO using various techniques.
IntScope [35] and IntFlow [29] use taint analysis to locate
the overﬂow affected by untrusted input source under the
observation that the harmful integer errors often stem from un-
trusted input and the triggered error must affect certain sensitive
functions e.g. memcpy. Osiris [34] targets the IOs in the smart
contract. IntRepair [28] aims at automatically detecting and
repairing IO through program rewriting. IntEq [33] formally
deﬁnes what’s a benign IO and achieves high accuracy in
distinguishing benign IOs from harmful ones. This idea is a
great complement to our post-bug analysis to mute more false
positives, however since it also requires the overﬂowed value
to ﬂow into a critical sink which might be far from the UB
instruction, it still has the problem of not being able to ﬁnd a
meaningful sink. This might not be a big problem for small
program, but for code as complex as the kernel, how to locate
the sink is an issue.
Idea-wise, our motivation to focus on input from userspace
agrees with their observation that user-input affected UB is
critical, but KUBO distinguishes from these works in that
1). Prior works [29] use a ﬂow-based method which only
utilized coarse-grained data-ﬂow analysis while KUBO strictly
distinguishes userspace input from under-constrained memory
and assert that only when a UB is solely affected by userspace
input can it be regarded as a true bug, for other likely cases,
we use BTI to model the likelihood. 2). Their observation
in [35], [29], [33] that only the overﬂows whose value affects
sensitive functions can be regarded as meaningful, might be
generally true for userspace code. For kernel, however, given the
compactness of semantics an integer could represent and how
critical certain integers could be, any unintended or unintended
undeﬁnedness and wrap-around are worth being paid attention
13
to. As a result, the scope should not be limited to a set of pre-
deﬁned sensitive functions. Lastly, the benchmark adopted in all
of these works are generally small to medium sized userspace
program which is an indicator that they might not scale to large
codebase like the kernel. As stated in IntRepair [28] which
neither has false positive nor false negative, "we expect that in
even more complex and large real-world programs, INTREPAIR
would report false positives.
C. Symbolic execution for bug ﬁnding
Symbolic execution has been widely used with SMT
solvers [16] for ﬁnding bugs [19], [12], [30], [26], [14], [11].
These works, along with the aforementioned STACK and
KINT, made great progress towards analyzing large codebases.
However, there is always a trade-off between scalability and
precision. In particular, works like UCKLEE and KINT tried
to gain better scalability by performing symbolic execution on
partial program paths starting from certain interesting functions
within the kernel and carry on forward. As a result, they suffer
from high false detection rates. KUBO also adopts the general
approach of symbolic execution and path constraint solving.
However, KUBO differs from previous works in that it focuses
on each instrumented bug and analyzes its triggerability via
an efﬁcient backward inter-procedural analysis, enabled by on-
demand call chain upwalk and per-function taint summaries.
This analysis scales to the whole kernel and combats path
explosion through actively pruning potential UBs that are not
triggerable by userspace input.
D. Non-UB bug detection in kernel
KMiner [20] is a static analysis tool for detecting memory
corruption bugs in the Linux kernel. It is based on value
ﬂow analysis and can reason about potential wrong operations
on memory, e.g. free on speciﬁc memory objects. PEX [42]
generates a whole-kernel call graph and uses static call chain
analysis to detect privilege checking errors in the kernel.
APISan [41] and Unisan [25] aims at ﬁnding API misuse.
However, their intra-procedural analysis suffers from high false
detection rates, especially when used for detecting integer
overﬂows, due to the inability of tracking where and how API
parameters ﬂow into the API. Unlike these previous works,
KUBO uses a scalable and efﬁcient inter-procedural analysis
and is focused on detecting critical UB that can be triggered
by userspace inputs.
V I I I . C O N C L U S I O N
This paper presents KUBO, a precise and scalable static
analysis framework to detect undeﬁned behavior bugs in OS
kernel. KUBO identiﬁes UB bugs that are triggerable by
userspace inputs. By using a novel inter-procedural analysis
that tracks data and control dependencies across function calls,
KUBO can produce highly precise results. By only analyzing
paths that are directly affected by userspace inputs, and with
the on-demand, incremental call chain analysis, KUBO can
signiﬁcantly reduce the number of paths to analyze. Going
beyond triggering the UBs, KUBO also tracks the post-bug
triggering paths in order to ﬁlter out UBs that have been handled
and does not pose security implication to the system. KUBO
can ﬁnish analyzing 27.8 million lines of code in the latest
Linux kernel under 33 hours. In total, KUBO found 23 UBs,
including 17 critical ones, 14 of them are quickly accepted or
patched.
A C K N O W L E D G M E N T
The authors would like to thank the anonymous reviewers
for their insightful comments and Meng Xu for his releasing
the DEADLINE source code and consultation during our
development of KUBO prototype.
This project was supported by the National Science Founda-
tion (Grant#: CNS-1748334) and the Ofﬁce of Naval Research
(Grant#: N00014-18-1-2660). Any opinions, ﬁndings, and con-
clusions or recommendations expressed in this paper are those
of the authors and do not necessarily reﬂect the views of the
funding agencies.
R E F E R E N C E S
[1] Common
vulnerabilities
and
exposures
about
linux
kernel.
https://nvd.nist.gov/vuln/search/statistics?form_type=Advanced&
results_type=statistics&search_type=all&cpe_vendor=cpe%3A%2F%
3Alinux&cpe_product=cpe%3A%2F%3Alinux%3Alinux_kernel.
Accessed: 2020-6-18.
[2] Common
vulnerability
cve-2018-
https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?name=
13053.
CVE-2018-13053&vector=AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:
L&version=3.0&source=NIST.
system calculator
scoring
[3] Cve-2018-8781. https://nvd.nist.gov/vuln/detail/CVE-2018-8781.
[4] Undeﬁned behavior sanitizer - clang documentation. http://clang.llvm.
org/docs/UndeﬁnedBehaviorSanitizer.html#ubsan-checks.
[5] The undeﬁned behavior sanitizer - ubsan. https://www.kernel.org/doc/
[6]
[7]
[8]
html/v4.14/dev-tools/ubsan.html.
speciﬁcation of integer overﬂow. https://www.gnu.org/software/autoconf/
manual/autoconf-2.64/html_node/Integer-Overﬂow-Basics.html, 2020.
syzkaller - kernel fuzzer. https://github.com/google/syzkaller, 2020.
syzkaller - usb fuzzer. https://github.com/google/syzkaller/blob/master/
docs/linux/external_fuzzing_usb.md, 2020.
[9] A N S I / I S O. Iso/iec 9899:2018. https://www.iso.org/standard/74528.
html, 2018.
[10] B R U M L E Y, D . , S O N G , D . X . , C H I U E H , T. C . , J O H N S O N , R . ,
A N D L I N , H . Rich: Automatically protecting against integer-based
vulnerabilities. In Network & Distributed System Security Symposium
(2007).
[11] C A D A R , C . , D U N B A R , D . , A N D E N G L E R , D . Klee: Unassisted
and automatic generation of high-coverage tests for complex systems
programs. In Proceedings of the 8th USENIX Conference on Operating
Systems Design and Implementation (USA, 2008), OSDI’08, USENIX
Association, p. 209–224.
[12] C A D A R , C . , G A N E S H , V. , PAW L O W S K I , P. M . , D I L L , D . L . ,
A N D E N G L E R , D . R . Exe: Automatically generating inputs of death.
ACM Trans. Inf. Syst. Secur. 12, 2 (Dec. 2008).
[13] C H E N , Y. , L I , P. , X U , J . , G U O , S . , Z H O U , R . , Z H A N G , Y. ,
W E I , T. , A N D L U , L . Savior: Towards bug-driven hybrid testing. In
2020 IEEE Symposium on Security and Privacy (SP) (Los Alamitos,
CA, USA, may 2020), IEEE Computer Society, pp. 2–2.
[14] C U I , H . , H U , G . , W U , J . , A N D YA N G , J . Verifying systems
In Proceedings of
rules using rule-directed symbolic execution.
the Eighteenth International Conference on Architectural Support for
Programming Languages and Operating Systems (New York, NY, USA,
2013), ASPLOS ’13, Association for Computing Machinery, p. 329–342.
[15] D E M O U R A , L . , A N D B J Ø R N E R , N . Z3: An efﬁcient smt solver.
In Tools and Algorithms for the Construction and Analysis of Systems
(Berlin, Heidelberg, 2008), C. R. Ramakrishnan and J. Rehof, Eds.,
Springer Berlin Heidelberg, pp. 337–340.
[16] D E M O U R A , L . , A N D B J Ø R N E R , N . Satisﬁability modulo theories:
Introduction and applications. Commun. ACM 54, 9 (Sept. 2011), 69–77.
[17] D I E T Z , W. , L I , P. , R E G E H R , J . , A N D A D V E , V. Understanding
integer overﬂow in c/c++. ACM Trans. Softw. Eng. Methodol. 25, 1
(Dec. 2015).
[18] D ’ S I LVA , V. , PAY E R , M . , A N D S O N G , D . The correctness-
In 2015 IEEE Security and
security gap in compiler optimization.
Privacy Workshops (2015), pp. 73–87.
[19] E N G L E R , D . , A N D D U N B A R , D . Under-constrained execution:
Making automatic code destruction easy and scalable. In Proceedings
of the 2007 International Symposium on Software Testing and Analysis
(New York, NY, USA, 2007), ISSTA ’07, Association for Computing
Machinery, p. 1–4.
[20] G E N S , D . , S C H M I T T, S . , D AV I , L . , A N D S A D E G H I , A . - R .
K-miner: Uncovering memory corruption in linux. In NDSS (2018).
[21] H AT H H O R N , C . , E L L I S O N , C . , A N D R O U N D E F I N E D U , G .
In Proceedings of the 36th ACM
Deﬁning the undeﬁnedness of c.
SIGPLAN Conference on Programming Language Design and Imple-
mentation (New York, NY, USA, 2015), PLDI ’15, Association for
Computing Machinery, p. 336–345.
[22] L E E , J . , K I M , Y. , S O N G , Y. , H U R , C . - K . , D A S , S . , M A J N E -
M E R , D . , R E G E H R , J . , A N D L O P E S , N . P. Taming undeﬁned
behavior in llvm. In Proceedings of the 38th ACM SIGPLAN Conference
on Programming Language Design and Implementation (New York,
NY, USA, 2017), PLDI 2017, Association for Computing Machinery,
p. 633–647.
[23] L O N G , F. , S I D I R O G L O U - D O U S K O S , S . , K I M , D . , A N D R I -
N A R D , M . Sound input ﬁlter generation for integer overﬂow errors.
In Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (New York, NY, USA, 2014),
POPL ’14, Association for Computing Machinery, p. 439–452.
[24] L U , K . , A N D H U , H . Where does it go? reﬁning indirect-call
targets with multi-layer type analysis. In Proceedings of the 2019 ACM
SIGSAC Conference on Computer and Communications Security (New
York, NY, USA, 2019), CCS ’19, Association for Computing Machinery,
p. 1867–1881.
[25] L U , K . , S O N G , C . , K I M , T. , A N D L E E , W. Unisan: Proactive
kernel memory initialization to eliminate data leakages. In Proceedings
of the 2016 ACM SIGSAC Conference on Computer and Communica-
tions Security (New York, NY, USA, 2016), CCS ’16, Association for
Computing Machinery, p. 920–932.
[26] M A , K . - K . , Y I T P H A N G , K . , F O S T E R , J . S . , A N D H I C K S ,
M . Directed symbolic execution. In Static Analysis (Berlin, Heidelberg,
2011), E. Yahav, Ed., Springer Berlin Heidelberg, pp. 95–111.
[27] M A C H I R Y, A . , S P E N S K Y, C . , C O R I N A , J . , S T E P H E N S , N . ,
K R U E G E L , C . , A N D V I G N A , G . Dr. checker: A soundy analysis
for linux kernel drivers. In Proceedings of the 26th USENIX Conference
on Security Symposium (USA, 2017), SEC’17, USENIX Association,
p. 1007–1024.
[28] M U N T E A N , P. , M O N P E R R U S , M . , S U N , H . , G R O S S K L A G S ,
Informed repairing of integer
J . , A N D E C K E R T, C .
overﬂows. IEEE Transactions on Software Engineering (2019), 1–1.
Intrepair:
[29] P O M O N I S , M . , P E T S I O S , T. , J E E , K . , P O LY C H R O N A K I S , M . ,
A N D K E R O M Y T I S , A . D . Intﬂow: Improving the accuracy of arith-
metic error detection using information ﬂow tracking. In Proceedings of
the 30th Annual Computer Security Applications Conference (New York,
NY, USA, 2014), ACSAC ’14, Association for Computing Machinery,
p. 416–425.
[30] R A M O S , D . A . , A N D E N G L E R , D . Under-constrained symbolic
execution: Correctness checking for real code. In 24th USENIX Security
Symposium (USENIX Security 15) (Washington, D.C., Aug. 2015),
USENIX Association, pp. 49–64.
[31] S I D I R O G L O U - D O U S K O S , S . , L A H T I N E N , E . , R I T T E N -
H O U S E , N . , P I S E L L I , P. , L O N G , F. , K I M , D . , A N D R I N A R D ,
M . Targeted automatic integer overﬂow discovery using goal-directed
In Proceedings of the Twentieth
conditional branch enforcement.
International Conference on Architectural Support for Programming
Languages and Operating Systems (New York, NY, USA, 2015),
ASPLOS ’15, Association for Computing Machinery, p. 473–486.
[32] S O N G , D . , H E T Z E LT, F. , D A S , D . , S P E N S K Y, C . , N A , Y. ,
V O L C K A E R T, S . , V I G N A , G . , K R U E G E L , C . , S E I F E R T, J . -
P. , A N D F R A N Z , M . PeriScope: An effective probing and fuzzing
14
framework for the hardware-OS boundary. In Network and Distributed
System Security Symposium (NDSS) (2019).
[33] S U N , H . , Z H A N G , X . , Z H E N G , Y. , A N D Z E N G , Q .
Inteq:
Recognizing benign integer overﬂows via equivalence checking across
multiple precisions. In Proceedings of the 38th International Conference
on Software Engineering (New York, NY, USA, 2016), ICSE ’16,
Association for Computing Machinery, p. 1051–1062.
[34] T O R R E S , C . F. , S C H Ü T T E , J . , A N D S TAT E , R . Osiris: Hunting
In Proceedings of the
for integer bugs in ethereum smart contracts.
34th Annual Computer Security Applications Conference (New York,
NY, USA, 2018), ACSAC ’18, Association for Computing Machinery,
p. 664–676.
[35] WA N G , T. , W E I , T. , L I N , Z . , A N D Z O U , W.
Intscope: Auto-
matically detecting integer overﬂow vulnerability in x86 binary using
symbolic execution.
[36] WA N G , X . , C H E N , H . , C H E U N G , A . , J I A , Z . , Z E L D O V I C H ,
N . , A N D K A A S H O E K , M . F. Undeﬁned behavior: What happened
to my code? In Proceedings of the Asia-Paciﬁc Workshop on Systems
(New York, NY, USA, 2012), APSYS ’12, Association for Computing
Machinery.
[37] WA N G , X . , C H E N , H . , J I A , Z . , Z E L D O V I C H , N . , A N D
Improving integer security for systems with
K A A S H O E K , M . F.
In Proceedings of the 10th USENIX Conference on Operating
kint.
Systems Design and Implementation (USA, 2012), OSDI’12, USENIX
Association, p. 163–177.
[38] WA N G , X . , Z E L D O V I C H , N . , K A A S H O E K , M . F. , A N D
S O L A R - L E Z A M A , A . Towards optimization-safe systems: Analyzing
the impact of undeﬁned behavior. In Proceedings of the Twenty-Fourth
ACM Symposium on Operating Systems Principles (New York, NY, USA,
2013), SOSP ’13, Association for Computing Machinery, p. 260–275.
[39] WA N G , X . , Z E L D O V I C H , N . , K A A S H O E K , M . F. , A N D
S O L A R - L E Z A M A , A . A differential approach to undeﬁned behavior
detection. ACM Trans. Comput. Syst. 33, 1 (Mar. 2015).
[40] X U , M . , Q I A N , C . , L U , K . , B A C K E S , M . , A N D K I M , T. Pre-
cise and scalable detection of double-fetch bugs in os kernels. pp. 661–
678.
[41] Y U N , I . , M I N , C . , S I , X . , J A N G , Y. , K I M , T. , A N D N A I K ,
M . Apisan: Sanitizing api usages through semantic cross-checking. In
Proceedings of the 25th USENIX Conference on Security Symposium
(USA, 2016), SEC’16, USENIX Association, p. 363–378.
[42] Z H A N G , T. , S H E N , W. , L E E , D . , J U N G , C . , A Z A B , A . M . ,
A N D WA N G , R . Pex: A permission check analysis framework for
linux kernel. In 28th USENIX Security Symposium (USENIX Security
19) (Santa Clara, CA, Aug. 2019), USENIX Association, pp. 1205–1220.
[43] Z H A N G , Y. , S U N , X . , D E N G , Y. , C H E N G , L . , Z E N G , S . , F U ,
Y. , A N D F E N G , D .
Improving accuracy of static integer overﬂow
detection in binary. In Research in Attacks, Intrusions, and Defenses
(Cham, 2015), H. Bos, F. Monrose, and G. Blanc, Eds., Springer
International Publishing, pp. 247–269.
15