率。RISC出现后，人们很自然地把与RISC相对的另一类指令集称为复
杂指令集计算机（Complex Instruction Set Computer，CISC）。
RISC处理器的典型代表有SPARC处理器、PowerPC处理器、惠普公
司的PA-RISC处理器、MIPS处理器、Alpha处理器和ARM处理器等。
CISC处理器的典型代表有x86处理器和DEC VAX-11处理器等。第
一款x86处理器是英特尔公司于1978年推出的8086，其后的8088、
80286、80386、80486、奔腾处理器及AMD等公司的兼容处理器都是兼
容8086的，因此人们把基于该架构的处理器统称为x86处理器。
2.1.1 基本特征
下面将以比较的方式来介绍RISC处理器和CISC处理器的基本特征
和主要差别。除非特别说明，我们用ARM处理器代表RISC处理器，用
x86处理器代表CISC处理器。
第一，大多数RISC处理器的指令都是等长的（通常为4个字节，即
32比特），而CISC处理器的指令长度是不确定的，最短的指令是1个字
节，有些长的指令有十几个字节（x86）甚至几十个字节（VAX-11）。
定长的指令有利于解码和优化，其缺点是目标代码占用的空间比较大
（因为有些指令没必要用4字节）。对于软件调试而言，定长的指令有
利于实现反汇编和软件断点，我们将在4.1节详细介绍软件断点。这里
简要介绍一下反汇编。对于x86这样不定长的指令集，反汇编时一定要
从一条有效指令的第一个字节开始，依次进行，比如下面3条指令是某
个函数的序言。
0:000> u 47f000
image00400000+0x7f000:
0047f000 55              push    ebp
0047f001 8bec            mov     ebp,esp
0047f003 6aff            push    0FFFFFFFFh
上面是从正确的起始位置开始反汇编，结果是正确的，但是如果把
反汇编的起点向前调整两个字节，那么结果就会出现很大变化。
0:000> u 47effd
image00400000+0x7effd:
0047effd 0000            add     byte ptr [eax],al
0047efff 00558b          add     byte ptr [ebp-75h],dl
0047f002 ec              in      al,dx
0047f003 6aff            push    0FFFFFFFFh
这就是所谓的指令错位。为了减少这样的问题，编译器在编译时，
会在函数的间隙填充nop或者int 3等单字节指令，这样即使反汇编时误
从函数的间隙开始，也不会错位，可以帮助反汇编器顺利“上手”。而上
面的例子来自某个做过加壳保护的软件，这样的软件不愿意被反汇编，
所以故意在函数的间隙或者某些位置加上0来迷惑反汇编器。
第二，RISC处理器的寻址方式（addressing mode）比CISC要少很
多，我们稍后将单独介绍。
第三，与RISC相比，CISC处理器的通用寄存器（general register）
数量较少。例如16位和32位的x86处理器都只有8个通用寄存器：
AX/EAX、BX/EBX、CX/ECX、DX/EDX、SI/ESI、DI/EDI、BP/EBP、
SP/ESP（E开头为32位，为Extended之缩写），而且其中的BP/EBP和
SP/ESP常常被固定用来维护栈，失去通用性。64位的x86处理器增加了8
个通用寄存器（R8～R15），但是总量仍然远远小于RISC处理器（通常
多达32个）。寄存器位于CPU内部，可供CPU直接使用，与访问内存相
比，其效率更高。
第四，RISC的指令数量也相对较少。就以跳转指令为例，8086有
32条跳转指令（JA、JAE、JB、JPO、JS、JZ等），而ARM处理器只有
两条跳转指令（BLNV和BLEQ）。跳转指令对流水线执行很不利，因
为一旦遇到跳转指令，CPU就需要做分支预测（branch prediction），而
一旦预测失败，就要把已经执行的错误分支结果清理掉，这会降低CPU
的执行效率。但是丰富的跳转指令为编程提供了很多方便，这是CISC
处理器的优势。
第五，从函数（或子程序）调用（function/procedure call）来看，
二者也有所不同。RISC处理器因具有较多的寄存器，通常就有足够多
的寄存器来传递函数的参数。而在CISC中，即使用所谓的快速调用
（fast call）协定，也只能将两个参数用寄存器来传递，其他参数仍然需
要用栈来传递。从执行速度看，使用寄存器的速度更快。我们将在后面
关于调用协定的内容中进一步讨论函数调用的细节。
鉴于以上特征，RISC处理器的实现相对来说简单一些，这也是很
多低成本的供嵌入式系统使用的处理器大多采用RISC架构的一个原
因。关于RISC和CISC的优劣，一直存在着很多争论，采用两种技术的
处理器也在相互借鉴对方的优点。比如从P6系列处理器的第一代产品
Pentium Pro开始，英特尔的x86处理器就开始将CISC指令先翻译成等长
的微操作（micro-ops或µops），然后再执行。微操作与RISC指令很类
似，因此很多时候又被称为微指令。因此可以说今天的主流x86处理器
（不包括那些用于嵌入式系统的x86处理器）的内部已经具有了RISC的
特征。此外，ARM架构的v4版本引入了Thumb指令集，允许混合使用16
位指令和32指令，指令的长度由单一一种变为两种，程序员可以根据需
要选择短指令和长指令，不必再拘泥于一种长度，这样可使编译好的目
标程序更加紧凑。
2.1.2 寻址方式
指令由操作码（opcode）和0到多个操作数组成。寻址方式定义了
得到操作数的方式，是指令系统乃至CPU架构的关键特征。下面以x86
汇编语言为例简要介绍常见的寻址方式。
（1）立即寻址（immediate addressing）：操作数直接跟在操作码
之后，作为指令的一部分存放在代码段里，比如在MOV AL, 5（机器码
B0 05）这条指令中，源操作数采用的就是立即寻址方式。
（2）寄存器寻址（register addressing）：操作数被预先放在寄存器
中，指令中指定寄存器号，比如在MOV AX, BX（机器码8A C3）中，
源操作数使用的是寄存器寻址方式。
（3）直接寻址（direct addressing）：操作数的有效地址（Effective
Address，EA）直接作为指令的一部分跟在操作码之后，比如在MOV
AX, [402128H]（机器码B8 28 21 40 00）指令中，源操作数采用的就是
直接寻址方式。
（4）寄存器间接寻址（register indirect addressing）：操作数的地
址被预先放在一个或多个寄存器中，比如ADD AX, [BX]这条指令是把
BX寄存器所代表地址中的值累加到AX寄存器中的，源操作数采用的就
是寄存器间接寻址方式。
间接寻址方式还有几种，这里不再一一列举。间接寻址方式为处理
表格和字符串等数据结构带来了很大的方便。例如，可以把表格或字符
串的起始地址放入一个基地址寄存器中，然后用一个变址寄存器指向各
个元素。但间接寻址带来的问题就是使指令格式变得复杂，导致解码和
优化的难度增大。为了避免这样的问题，RISC处理器通常只支持简单
的寻址方式，不支持间接寻址，不支持在一条指令中既访问内存又进行
数学运算（比如从内存中读出并累加到目标操作数，即ADD AX,
[BX]）。
进一步来说，在ARM等RISC处理器中，运算指令在执行过程中是
不访问内存的，运算指令的所有操作数要么是立即数，要么就是被预先
加载（称为Load）寄存器中，而且执行结果也是先保存到寄存器中，然
后再根据需要写回内存（称为Store）。这种先加载再回存的模式是很多
RISC处理器的显著特征。因此，在ARM的官方文档中，我们可以看到
这样的说法——ARM是一种加载/回存的RISC架构（ARM is a load /
store RISC architecture）。这种设计模式的优点是涉及内存访问的指令
变得很少，有利于提高CPU执行流水线（pipeline）的效率。
2.1.3 指令的执行过程
图2-1以英特尔P6系列CPU（后文有详细介绍）为例简单显示了指
令在CPU中的执行过程。
图2-1 指令在CPU中的执行过程（P6处理器）
箭头1代表取指/解码单元（Fetch/Decode Unit）从高速缓存中读取
指令并解码成等长的微操作后放入指令池中（箭头2）。箭头3代表分
发/执行单元（Dispatch/Excute Unit）从指令池中挑选出等待执行的指令
分发到合适的执行单元中进行执行，执行单元执行后把结果再放回到指
令池中（箭头4）。箭头5代表回收单元（Retire Unit）检查指令池中的
指令状态，根据程序逻辑将临时执行结果按顺序永久化。《P6系列处理
器硬件开发者手册》[9]更详细地描述了以上过程，感兴趣的读者可以从
英特尔网站下载和阅读。
老雷评点
CPU厂商对CPU内部设计大多讳莫如深，以开放著称的英特
尔也不例外，P6实为一特例，英特尔官方发布了包含较多内部细
节的技术文档，此后不再有。这大概与P6团队的风格有关，老雷
于2003年加入英特尔时，公司中还流传着很多关于此团队的传奇
故事。
本节介绍了RISC和CISC指令集的概况，目的主要是让读者对整个
CPU世界有个概括性的了解。本节之后的小节将先详细介绍x86阵营中
的英特尔架构处理器和PC系统，然后介绍ARM架构。2.2节将先对英特
尔架构处理器做概括性的介绍。
2.2 英特尔架构处理器
英特尔架构（Intel Architecture，IA）处理器是对英特尔设计和生产
的x86系列32位和64位微处理器的总称。早期的32位架构通常称为IA-
32（或IA32），是Intel Architecture 32-bit的缩写，用来指代所有IA-32处
理器所使用的架构和共同特征。今天的大多数IA架构CPU都支持64位工
作模式，故称为Intel 64位技术，有时也称为Intel 64架构。本书用IA来
泛指IA-32和Intel 64架构。值得说明的是，Intel 64不同于IA-64，因为
IA-64指的是安腾（Itanium）架构。简单来说，IA = IA-32 + Intel 64，即
IA != IA-32 + IA-64。
老雷评点
此处名字别扭的根源是IA-64这个好名字被安腾架构占去，
只能一叹。
IA处理器的典型代表有80386、80486、Pentium（奔腾）、Pentium
Pro、PentiumⅡ、PentiumⅢ、Pentium 4（简称P4）、Pentium M、Core
Duo、Core 2 Duo及Celeron（赛扬）和Xeon（至强）处理器。其中
Pentium Pro、PentiumⅡ和PentiumⅢ因为都是基于共同的P6处理器内核
的，所以又被统称为P6系列处理器。赛扬和至强处理器分别是P6（奔腾
Ⅱ和奔腾Ⅲ）和P4等处理器针对低端和服务器市场的改进版本，从指令
和架构上看并没有根本的变化。于2006年推出的Core 2 Duo处理器采用
了针对多核特征设计的Intel Core Architeture，代表了CPU向多核方向发
展的趋势。
综上所述，我们可以把迄今为止的IA处理器概括为386系列、486系
列、奔腾系列、P6系列、P4系列和酷睿（Core）系列。因为本章及后面
的章节还经常要提到这些处理器，下面便按时间顺序简要概括它们的特
征。需要特别强调的是，以下介绍的只是与本书内容密切相关的特征，
并不是全部特征。
老雷评点
x86之名始于1978年6月8日发布的8086。2018年6月，在8086
发布40周年之际，英特尔特别限量发行主频高达5GHz的第8代酷
睿i7处理器，将其型号特别定义为8086K，并在6月8日以抽奖形
式赠送8086颗，以作纪念。
2.2.1 80386处理器
1985年10月，英特尔在推出80286三年半之后推出了80386（简称
386），它是x86系列处理器中的第一款32位处理器，被视为IA-32架构
的开始。尽管286最先引入了保护模式的概念，为运行多任务操作系统
打下了基础，但是386的推出才真正使基于x86处理器的多任务操作系统
（Windows）流行起来。386处理器引入的新特性主要如下。
32位地址总线，可以最多支持4GB的物理内存。
平坦内存模型（flat memory model），即每个应用程序可以使用地
址0～2321来索引4GB的平坦内存空间。因为4GB足以容纳大多数应
用程序的所有代码和数据，所以采用此模型后，可以把程序的所有
代码都放在一个段内，这样在跳转时便都是段内跳转，而不必考虑
段的界限。此前的实模式下一个段最大只有64KB，程序要维护多
个代码段和多个数据段，不得不考虑段间跳转和段边界等棘手问
题。
分页机制（paging），即以页为单位来组织内存，通过页表进行管
理，暂时不用的页可以交换到硬盘等外部存储器上，需要时再交换
回来。分页机制是实现虚拟内存的硬件基础。在386处理器中，每
个内存页的大小为4KB，Pentium处理器引入了大页面支持，可以
建立4MB的大内存页。分页机制是目前所有主流操作系统必须依赖
的硬件功能。值得说明的是，在Windows系统中禁用专门的分页文
件（paging file），并不代表Windows就不再依赖分页机制，文件映
射、栈增长等机制还是要依赖CPU的分页机制的。
调试寄存器，支持更强大的调试功能，我们将在第4章（见4.2节）
讨论其细节。
虚拟8086模式，使16位的8086/8088程序可以更高效地在32位处理
器中执行。
老雷评点
80386，英特尔崛起时的开山力作，奠定IA架构格局之经
典，前无古人，后亦少来者，其后各代多在提升速度，鲜有根本
之拓展。421页的80386编程手册（《Programmer’s Reference
Manual》），可谓字字珠玑,至今仍是学习IA的珍贵素材。
2.2.2 80486处理器
于1989年推出的80486处理器引入了以下特性。
在CPU内部集成高速缓存（cache）。486是第一个在芯片内部集成
一级高速缓存（L1 Cache）的IA-32处理器，此后的所有IA-32处理
器内部都有集成的一级高速缓存。
将数学协处理器（FPU）集成到CPU内。
内存对齐检查异常（alignment check exception，exception 17）。我