简直就是“龟速”啊！后来终于将这个程序停止不用了， 以自己写的一个小程序来取代，呵呵！这样才让 CPU 的负载 （loading） 整个降下来～
用起来顺畅多了！ ^_^
这个工作管理 （job control） 是用在 bash 环境下的，也就是说：“当我们登陆系统取得 bash shell 之后，在单一终端机接口下同时进行
多个工作的行为管理 ”。举例来说，我们在登陆 bash 后， 想要一边复制文件、一边进行数据搜寻、一边进行编译，还可以一边进行 vim 程序
撰写！ 当然我们可以重复登陆那六个文本界面的终端机环境中，不过，能不能在一个 bash 内达成？ 当然可以啊！就是使用 job control 啦！
^_^
从上面的说明当中，你应该要了解的是：“进行工作管理的行为中， 其实每个工作都是目前 bash 的子程序，亦即彼此之间是有相关性
的。 我们无法以 job control 的方式由 tty1 的环境去管理 tty2 的 bash ！” 这个概念请你得先创建起来，后续的范例介绍之后，你就会清楚的了
解啰！
或许你会觉得很奇怪啊，既然我可以在六个终端接口登陆，那何必使用 job control 呢？ 真是脱裤子放屁，多此一举啊！不要忘记了呢，
我们可以在 /etc/security/limits.conf （第十三章） 里面设置使用者同时可以登陆的连线数，在这样的情况下，某些使用者可能仅能以一个连线
来工作呢！ 所以啰，你就得要了解一下这种工作管理的模式了！此外，这个章节内容也会牵涉到很多的数据流重导向，所以，如果忘记的话，
务必回到第十章 BASH Shell 看一看喔！
由于假设我们只有一个终端接口，因此在可以出现提示字符让你操作的环境就称为前景 （foreground），至于其他工作就可以让你放入
背景 （background） 去暂停或运行。要注意的是，放入背景的工作想要运行时， 他必须不能够与使用者互动。举例来说， vim 绝对不可能在
背景里面执行 （running） 的！因为你没有输入数据他就不会跑啊！ 而且放入背景的工作是不可以使用 [ctrl]+c 来终止的！
总之，要进行 bash 的 job control 必须要注意到的限制是：
这些工作所触发的程序必须来自于你 shell 的子程序（只管理自己的 bash）；
前景：你可以控制与下达指令的这个环境称为前景的工作 （foreground）；
背景：可以自行运行的工作，你无法使用 [ctrl]+c 终止他，可使用 bg/fg 调用该工作；
背景中“执行”的程序不能等待 terminal/shell 的输入（input）
接下来让我们实际来管理这些工作吧！
如前所述，bash 只能够管理自己的工作而不能管理其他 bash 的工作，所以即使你是 root 也不能够将别人的 bash 下面的 job 给他拿过
来执行。此外，又分前景与背景，然后在背景里面的工作状态又可以分为“暂停 （stop）”与“运行中 （running）”。那实际进行 job 控制的指令
有哪些？下面就来谈谈。
直直接接将将指指令令丢丢到到背背景景中中“执执行行”的的 &
如同前面提到的，我们在只有一个 bash 的环境下，如果想要同时进行多个工作， 那么可以将某些工作直接丢到背景环境当中，让我们
可以继续操作前景的工作！那么如何将工作丢到背景中？ 最简单的方法就是利用“ & ”这个玩意儿了！举个简单的例子，我们要将 /etc/ 整个备
份成为 /tmp/etc.tar.gz 且不想要等待，那么可以这样做：
[root@study ~]# tar -zpcf /tmp/etc.tar.gz /etc &
[1] 14432  /tmp/log.txt 2>&1 &
[1] 14547
[root@study ~]#
呵呵！如此一来，输出的信息都给他传送到 /tmp/log.txt 当中，当然就不会影响到我们前景的作业了。 这样说，您应该可以更清楚数据
流重导向的重要性了吧！^_^
Tips
工作号码 （job number） 只与你这个 bash 环境有关，但是他既然是个指令触发的咚咚，所以当然一定是一个程序， 因此你会观察到有 job
number 也搭配一个 PID ！
将将“目目前前”的的工工作作丢丢到到背背景景中中“暂暂停停”：：[ctrl]-z
想个情况：如果我正在使用 vim ，却发现我有个文件不知道放在哪里，需要到 bash 环境下进行搜寻，此时是否要结束 vim 呢？呵呵！
当然不需要啊！只要暂时将 vim 给他丢到背景当中等待即可。 例如以下的案例：
[root@study ~]# vim ~/.bashrc
# 在 vim 的一般模式下，按下 [ctrl]-z 这两个按键
[1]+ Stopped vim ~/.bashrc
[root@study ~]#  /tmp/text.txt 后，立刻丢到背景去暂停！
[root@study ~]# find / -perm /7000 > /tmp/text.txt
# 此时，请立刻按下 [ctrl]-z 暂停！
[3]+ Stopped find / -perm /7000 > /tmp/text.txt
范例二：让该工作在背景下进行，并且观察他！！
[root@study ~]# jobs ; bg %3 ; jobs
[1] Stopped vim ~/.bashrc
[2]- Stopped find / -print
[3]+ Stopped find / -perm /7000 > /tmp/text.txt
[3]+ find / -perm /7000 > /tmp/text.txt &
[1]- Stopped vim ~/.bashrc
[2]+ Stopped find / -print
[3] Running find / -perm /7000 > /tmp/text.txt &
看到哪里有差异吗？呼呼！没错！就是那个状态列～以经由 Stopping 变成了 Running 啰！ 看到差异点，嘿嘿！指令列最后方多了一个
& 的符号啰！ 代表该工作被启动在背景当中了啦！ ^_^
管管理理背背景景当当中中的的工工作作：： kill
刚刚我们可以让一个已经在背景当中的工作继续工作，也可以让该工作以 fg 拿到前景来， 那么，如果想要将该工作直接移除呢？或者
是将该工作重新启动呢？这个时候就得需要给予该工作一个讯号 （signal） ，让他知道该怎么作才好啊！此时， kill 这个指令就派上用场啦！
[root@study ~]# kill -signal %jobnumber
[root@study ~]# kill -l
选项与参数：
-l ：这个是 L 的小写，列出目前 kill 能够使用的讯号 （signal） 有哪些？
signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知：
-1 ：重新读取一次参数的配置文件 （类似 reload）；