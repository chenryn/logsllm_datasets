systematic technique for randomizing instruction content by
encrypting them. In practice, it has proved diﬃcult to de-
velop encryption schemes that provide adequate performace
for ISR, while resisting attacks to reverse-engineer the key.
Consequently, recent eﬀorts [33] have avoided encryption,
instead replacing an instruction with a functionally equiva-
lent one, or using techniques such as register reassignment.
Layout randomization, e.g., ASLR, can block ROP at-
tacks by making gadget locations unpredictable. Since coarse-
grained ASLR can often be defeated by leaking a single code
or data address, Bhatkar et al [5] developed ﬁne-grained
techniques that randomly re-orders all data objects as well
as functions. Note that purely compile-time permutations
are ineﬀective, unless existing binary and patch distribution
models are changed: otherwise, the attacker will have access
to the same randomized binary as the victim. For this rea-
son, Bhatkar et al [5] use compile-time code transformations
to generate the information required for load-time random-
ization. More recent works such as binary stirring [44] and
ILR [22] can operate without compiler help, and moreover,
can reorder basic blocks rather than functions.
JIT-ROP attacks [41], which rely on memory disclosure
vulnerabilities to scan code sections, can defeat ﬁne-grained
randomization by discovering gadgets at runtime. Several
recent works [13, 11] have developed defenses to JIT-ROP.
In general, randomization techniques can eﬀectively block
unintended gadgets, but disrupting the use of gadgets be-
ginning at legitimate indirect control-ﬂow targets (i.e., tar-
gets permitted by CFI schemes) can be diﬃcult. One rea-
son is that programs store such targets in memory, thereby
making them vulnerable to information disclosure. Indeed,
most binary instrumentation techniques don’t change the
original values of code pointers, so information disclosure is
not even necessary with these schemes. A second reason is
that the targeted code has legitimate invokers that expect
a certain semantics from it, including the contents of regis-
ters, caller-callee conventions, and so on. This signiﬁcantly
limits the scope of what is achievable using randomization
without breaking legitimate functionality.
In any case, it
is safe to say that shadow stack schemes such as ours en-
force as strong a policy on returns as any other random-
ization scheme, and moreover, provide deterministic rather
than probabilistic protection.
Shadow Stack. Shadow stack schemes [16, 8] were ﬁrst
proposed as a defense for stack smashing attacks. However,
only the legitimate returns were checked, so ROP attacks
using unintended returns were possible. CFI enforcement,
which prevents the use of unintended instructions, provides
one way to block this attack avenue. A second approach,
used in DBT-based techniques (e.g., ROPdefender [15]), is
to instrument all returns before their execution.
The beneﬁts of shadow stack for strengthening CFI [2],
and to defeat ROP, have long been recognized. However,
its practical deployment has been limited by the prevalence
of non-standard returns that violate shadow stack checks.
While RAD [8] addressed the cases of longjmp and signals,
ROPdefender [15] identiﬁed two other non-standard uses:
C++ exceptions and lazy-binding of calls to shared library
functions. It handled them by manually identifying instruc-
tions that save a return address on the stack, and pushing
a copy on the shadow stack. Thus, their runtime policy
follows the return capability model used in our approach.
A drawback of ROPdefender was its signiﬁcant runtime
overhead. Zhang et al [50] discuss how dynamic binary
instrumentation techniques, while displaying good perfor-
mance on SPEC benchmarks, tend to perform poorly on
large, real-world applications. Being based on static instru-
mentation, Zhang et al were able to achieve signiﬁcantly
better performance than ROPdefender.
Lockdown [35] is a recent eﬀort combining shadow stack
and CFI in dynamic instrumentation, while focusing on re-
ducing runtime overhead. However, unlike our approach,
they do not focus improving compatibility. Moreover, as
disscussed earlier, on the common benchmarks, our over-
head is about half of theirs.
Dang et. al surveyed existing shadow stack systems and
designed a “parallel shadow stack” scheme [12] to eliminate
the need for shadow stack pointer save and restore. They
avoided register clobbers in their intrumentation, applied
peephole optimizations, and achieved great performance. How-
ever, this comes with some trade-oﬀs on security. In fact,
StackDeﬁler [10] describes an attack that leaks shadow stack
address. As a comparison, we maintain strong security by
enforcing CFI, protecting RCAP-stack, and precisely man-
aging return capabilities.
In summary, the primary contributions of this paper over
previous works are (a) the development of a systematic ap-
proach for identifying and handling non-standard returns
without the need for manual eﬀort, (b) demonstrating that
this approach can handle complex and low-level binaries,
and (c) achieving low overheads.
Binary vs Source-code Based Defenses. Most of the
techniques discussed above, including bounds-checking [24,
45, 46, 3, 29, 20, 26], ﬁne-grained CFI [43, 30, 31], and
many ﬁne-grained randomization techniques [5, 11] and oth-
ers [32], are based on compilers and operate only on source
code. With such approaches, it is diﬃcult to protect low-
level code that uses inline assembly, as well as third-party
code that only available in binary form. Unfortunately, se-
curity is usually dependent on the “weakest link,” and even
one unprotected module can render the defense bypassable.
In contrast, binary-based defenses extends to all code, re-
gardless of the programming language or the compiler.
8. Conclusions
In this paper, we presented a principled approach for ROP
defense. Our approach accurately infers and enforces pro-
gram intended control ﬂow, which breaks one mandatory re-
quirement for ROP: repeatedly subverting control ﬂows. To
that end, we developed static analysis techniques and uti-
lized static binary instrumentation for enforcement. Exper-
imental evaluations have shown that our approach provides
precise control ﬂow guarantees, yet eﬃcient and compatible
with real-world applications.
9. References
[1] HT editor 2.0.20 - buﬀer overﬂow (ROP PoC).
https://www.exploit-db.com/exploits/22683/.
[2] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.
Control-ﬂow integrity principles, implementations, and
applications. ACM TISSEC, 2009.
[3] P. Akritidis, M. Costa, M. Castro, and S. Hand. Baggy
bounds checking: An eﬃcient and backwards-compatible
defense against out-of-bounds errors. In USENIX Security,
2009.
[4] E. G. Barrantes, D. H. Ackley, T. S. Palmer, D. Stefanovic,
and D. D. Zovi. Randomized instruction set emulation to
disrupt binary code injection attacks. In ACM CCS, 2003.
[29] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic.
Softbound: Highly compatible and complete spatial memory
safety for c. In PLDI, 2009.
[5] S. Bhatkar, R. Sekar, and D. DuVarney. Eﬃcient techniques
for comprehensive protection from memory error exploits.
In USENIX Security, 2005.
[6] N. Carlini and D. Wagner. ROP is still dangerous: Breaking
modern defenses. In USENIX Security, 2014.
[7] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng.
ROPecker: A generic and practical approach for defending
against ROP attacks. In NDSS, 2014.
[8] T. Chiueh and F. Hsu. RAD: A compile-time solution to
buﬀer overﬂow attacks. In ICDCS, 2001.
[9] T. Chiueh and M. Prasad. A binary rewriting defense
against stack based overﬂows. In USENIX ATC, 2003.
[10] M. Conti, S. Crane, L. Davi, M. Franz, P. Larsen,
C. Liebchen, M. Negro, M. Qunaibit, and A. Sadeghi.
Losing control: On the eﬀectiveness of control-ﬂow integrity
under stack attacks. In CCS, 2015.
[11] S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen,
A. Sadeghi, S. Brunthaler, and M. Franz. Readactor:
Practical code randomization resilient to memory disclosure.
In IEEE S&P, 2015.
[12] T. H. Dang, P. Maniatis, and D. Wagner. The performance
cost of shadow stacks and canaries. In ASIACCS, 2015.
[13] L. Davi, C. Liebchen, A. Sadeghi, K. Z. Snow, and
F. Monrose. Isomeron: Code randomization resilient to
(just-in-time) return-oriented programming. In NDSS, 2015.
[14] L. Davi, A. Sadeghi, D. Lehmann, and F. Monrose.
Stitching the gadgets: On the ineﬀectiveness of
coarse-grained control-ﬂow integrity protection. In USENIX
Security, 2014.
[15] L. Davi, A. Sadeghi, and M. Winandy. ROPdefender: A
detection tool to defend against return-oriented
programming attacks. In ASIACCS, 2011.
[16] M. Frantzen and M. Shuey. Stackghost: Hardware
facilitated stack protection. In USENIX Security, 2001.
[17] E. G¨okta¸s, E. Athanasopoulos, H. Bos, and G. Portokalidis.
Out of Control: Overcoming control-ﬂow integrity. In IEEE
S&P, 2014.
[18] E. G¨okta¸s, E. Athanasopoulos, M. Polychronakis, H. Bos,
and G. Portokalidis. Size does matter: Why using
gadget-chain length to prevent code-reuse attacks is hard.
In USENIX Security, 2014.
[19] N. Hasabnis. Automatic Synthesis of Instruction Set
Semantics and its Applications. PhD thesis, Stony Brook
University, 2015.
[20] N. Hasabnis, A. Misra, and R. Sekar. Light-weight bounds
checking. In CGO, 2012.
[21] N. Hasabnis and R. Sekar. Automatic generation of
assembly to IR translators using compilers. In AMAS-BT,
2015.
[22] J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and
J. Davidson. ILR: Where’d my gadgets go? In IEEE S&P,
2012.
[23] D. Jang, Z. Tatlock, and S. Lerner. SafeDispatch: Securing
C++ virtual calls from memory corruption attacks. In
NDSS, 2014.
[24] R. W. M. Jones, P. H. J. Kelly, M. C, and U. Errors.
Backwards-compatible bounds checking for arrays and
pointers in C programs. In AADEBUG, 1997.
[25] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Countering
code-injection attacks with instruction-set randomization.
In ACM CCS, 2003.
[26] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar,
and D. Song. Code-pointer integrity. In OSDI, 2014.
[27] longld. Payload already inside: Data reuse for ROP
exploits. https://media.blackhat.com/bh-us-
10/whitepapers/Le/BlackHat-USA-2010-Le-Paper-Payload-
already-inside-data-reuse-for-ROP-exploits-wp.pdf.
[28] C. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood. Pin:
Building customized program analysis tools with dynamic
instrumentation. In PLDI, 2005.
[30] B. Niu and G. Tan. Modular control-ﬂow integrity. In
PLDI, 2014.
[31] B. Niu and G. Tan. RockJIT: Securing just-in-time
compilation using modular control-ﬂow integrity. In CCS,
2014.
[32] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and
E. Kirda. G-Free: Defeating return-oriented programming
through gadget-less binaries. In ACSAC, 2010.
[33] V. Pappas, M. Polychronakis, and A. D. Keromytis.
Smashing the gadgets: Hindering return-oriented
programming using in-place code randomization. In IEEE
S&P, 2012.
[34] V. Pappas, M. Polychronakis, and A. D. Keromytis.
Transparent ROP exploit mitigation using indirect branch
tracing. In USENIX Security, 2013.
[35] M. Payer, A. Barresi, and T. R. Gross. Fine-grained
control-ﬂow integrity through binary hardening. In DIMVA,
2015.
[36] M. Payer, T. Hartmann, and T. R. Gross. Safe loading - a
foundation for secure execution of untrusted programs. In
IEEE S&P, 2012.
[37] A. Prakash, X. Hu, and H. Yin. vfGuard: Strict protection
for virtual function calls in COTS C++ binaries. In NDSS,
2015.
[38] P. Saxena, R. Sekar, and V. Puranik. Eﬃcient ﬁne-grained
binary instrumentation with applications to taint-tracking.
In CGO, 2008.
[39] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A. Sadeghi,
and T. Holz. Counterfeit object-oriented programming: On
the diﬃculty of preventing code reuse attacks in C++
applications. In IEEE S&P, 2015.
[40] H. Shacham. The geometry of innocent ﬂesh on the bone:
Return-into-libc without function calls (on the x86). In
CCS, 2007.
[41] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko,
C. Liebchen, and A. Sadeghi. Just-In-Time code reuse: On
the eﬀectiveness of ﬁne-grained address space layout
randomization. In IEEE S&P, 2013.
[42] L. Szekeres, M. Payer, T. Wei, and R. Sekar. Eternal war in
memory. S&P Magazine, 2014.
[43] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway,
U. Erlingsson, L. Lozano, and G. Pike. Enforcing
forward-edge control-ﬂow integrity in GCC & LLVM. In
USENIX Security, 2014.
[44] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin. Binary
stirring: Self-randomizing instruction addresses of legacy
x86 binary code. In CCS, 2012.
[45] W. Xu, D. C. DuVarney, and R. Sekar. An eﬃcient and
backwards-compatible transformation to ensure memory
safety of C programs. In FSE, 2004.
[46] Y. Younan, P. Philippaerts, L. Cavallaro, R. Sekar,
F. Piessens, and W. Joosen. PAriCheck: an eﬃcient pointer
arithmetic checker for C programs. In ASIACCS, 2010.
[47] B. Zeng, G. Tan, and G. Morrisett. Combining control-ﬂow
integrity and static analysis for eﬃcient and validated data
sandboxing. In CCS, 2011.
[48] C. Zhang, C. Song, K. Z. Chen, Z. Chen, and D. Song.
VTint: Defending virtual function tables’ integrity. In
NDSS, 2015.
[49] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres,
S. McCamant, D. Song, and W. Zou. Practical control ﬂow
integrity and randomization for binary executables. In IEEE
S&P, 2013.
[50] M. Zhang, R. Qiao, N. Hasabnis, and R. Sekar. A platform
for secure static binary instrumentation. In VEE, 2014.
[51] M. Zhang and R. Sekar. Control ﬂow integrity for COTS
binaries. In USENIX Security, 2013.
[52] M. Zhang and R. Sekar. Control ﬂow and code integrity for
COTS binaries: An eﬀective defense against real-world ROP
attacks. In ACSAC, 2015.