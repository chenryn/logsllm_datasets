有时候需要设定一个新的从库：也许是为了增加副本的数量，或替换失败的节点。如何确保新的从库拥有主库资料的精确副本？
简单地将资料档案从一个节点复制到另一个节点通常是不够的：客户端不断向资料库写入资料，资料总是在不断地变化，标准的档案复制会看到资料库的不同部分在不同的时间点的内容，其结果可能没有任何意义。
可以透过锁定资料库（使其不可用于写入）来使磁碟上的档案保持一致，但是这会违背高可用的目标。幸运的是，设定新从库通常并不需要停机。从概念上讲，其过程如下所示：
1. 在某个时刻获取主库的一致性快照（如果可能，不必锁定整个资料库）。大多数资料库都具有这个功能，因为它是备份必需的。对于某些场景，可能需要第三方工具，例如用于 MySQL 的 innobackupex【12】。
2. 将快照复制到新的从库节点。
3. 从库连线到主库，并拉取快照之后发生的所有资料变更。这要求快照与主库复制日志中的位置精确关联。该位置有不同的名称，例如 PostgreSQL 将其称为 **日志序列号（log sequence number，LSN）**，MySQL 将其称为 **二进位制日志座标（binlog coordinates）**。
4. 当从库处理完快照之后积累的资料变更，我们就说它 **赶上（caught up）** 了主库，现在它可以继续及时处理主库产生的资料变化了。
建立从库的实际步骤因资料库而异。在某些系统中，这个过程是完全自动化的，而在另外一些系统中，它可能是一个需要由管理员手动执行的、有点神秘的多步骤工作流。
### 处理节点宕机
系统中的任何节点都可能宕机，可能因为意外的故障，也可能由于计划内的维护（例如，重启机器以安装核心安全补丁）。对运维而言，能在系统不中断服务的情况下重启单个节点好处多多。我们的目标是，即使个别节点失效，也能保持整个系统执行，并尽可能控制节点停机带来的影响。
如何透过基于领导者的复制实现高可用？
#### 从库失效：追赶恢复
在其本地磁碟上，每个从库记录从主库收到的资料变更。如果从库崩溃并重新启动，或者，如果主库和从库之间的网路暂时中断，则比较容易恢复：从库可以从日志中知道，在发生故障之前处理的最后一个事务。因此，从库可以连线到主库，并请求在从库断开期间发生的所有资料变更。当应用完所有这些变更后，它就赶上了主库，并可以像以前一样继续接收资料变更流。
#### 主库失效：故障切换
主库失效处理起来相当棘手：其中一个从库需要被提升为新的主库，需要重新配置客户端，以将它们的写操作传送给新的主库，其他从库需要开始拉取来自新主库的资料变更。这个过程被称为 **故障切换（failover）**。
故障切换可以手动进行（通知管理员主库挂了，并采取必要的步骤来建立新的主库）或自动进行。自动的故障切换过程通常由以下步骤组成：
1. 确认主库失效。有很多事情可能会出错：崩溃、停电、网路问题等等。没有万无一失的方法来检测出现了什么问题，所以大多数系统只是简单使用 **超时（Timeout）** ：节点频繁地相互来回传递讯息，如果一个节点在一段时间内（例如 30 秒）没有响应，就认为它挂了（因为计划内维护而故意关闭主库不算）。
2. 选择一个新的主库。这可以透过选举过程（主库由剩余副本以多数选举产生）来完成，或者可以由之前选定的 **控制器节点（controller node）** 来指定新的主库。主库的最佳人选通常是拥有旧主库最新资料副本的从库（以最小化资料损失）。让所有的节点同意一个新的领导者，是一个 **共识** 问题，将在 [第九章](ch9.md) 详细讨论。
3. 重新配置系统以启用新的主库。客户端现在需要将它们的写请求传送给新主库（将在 “[请求路由](ch6.md#请求路由)” 中讨论这个问题）。如果旧主库恢复，可能仍然认为自己是主库，而没有意识到其他副本已经让它失去领导权了。系统需要确保旧主库意识到新主库的存在，并成为一个从库。
故障切换的过程中有很多地方可能出错：
* 如果使用非同步复制，则新主库可能没有收到老主库宕机前最后的写入操作。在选出新主库后，如果老主库重新加入丛集，又该如何处理这些老主库尚未复制的写入？在此期间，新主库可能已经收到了与老主库尚未复制的写入相冲突的写入。最常见的解决方案是简单丢弃老主库未复制的写入，这很可能打破客户对于资料永续性的期望。
* 如果资料库需要和其他外部储存相协调，那么丢弃写入内容是极其危险的操作。例如在 GitHub 【13】的一场事故中，一个过时的 MySQL 从库被提升为主库。资料库使用自增 ID 作为主键，因为新主库的计数器落后于老主库的计数器，所以新主库重新分配了一些已经被老主库分配掉的 ID 作为主键。这些主键也在 Redis 中使用，主键重用使得 MySQL 和 Redis 中的资料产生不一致，最后导致一些私有资料泄漏到错误的使用者手中。
* 发生某些故障时（见 [第八章](ch8.md)）可能会出现两个节点都以为自己是主库的情况。这种情况称为 **脑裂（split brain）**，非常危险：如果两个主库都可以接受写操作，却没有冲突解决机制（请参阅 “[多主复制](#多主复制)”），那么资料就可能丢失或损坏。一些系统采取了安全防范措施：当检测到两个主库节点同时存在时会关闭其中一个节点 [^ii]，但设计粗糙的机制可能最后会导致两个节点都被关闭【14】。
  [^ii]: 这种机制称为 **屏障（fencing）**，或者更充满感情的术语是：**爆彼之头（Shoot The Other Node In The Head, STONITH）**。我们将在 “[领导者和锁](ch8.md#领导者和锁)” 中对屏障进行详细讨论。
* 主库被宣告死亡之前的正确超时应该怎么配置？在主库失效的情况下，超时时间越长意味著恢复时间也越长。但是如果超时设定太短，又可能会出现不必要的故障切换。例如，临时的负载峰值可能导致节点的响应时间增加到超出超时时间，或者网路故障也可能导致资料包延迟。如果系统已经处于高负载或网路问题的困扰之中，那么不必要的故障切换可能会让情况变得更糟糕。
这些问题没有简单的解决方案。因此，即使软体支援自动故障切换，不少运维团队还是更愿意手动执行故障切换。
节点故障、不可靠的网路、对副本一致性、永续性、可用性和延迟的权衡，这些问题实际上是分散式系统中的基本问题。[第八章](ch8.md) 和 [第九章](ch9.md) 将更深入地讨论它们。
### 复制日志的实现
基于领导者的复制在底层是如何工作的？实践中有好几种不同的复制方式，所以先简要地看一下。
#### 基于语句的复制
在最简单的情况下，主库记录下它执行的每个写入请求（**语句**，即 statement）并将该语句日志传送给从库。对于关系资料库来说，这意味著每个 `INSERT`、`UPDATE` 或 `DELETE` 语句都被转发给每个从库，每个从库解析并执行该 SQL 语句，就像直接从客户端收到一样。
虽然听上去很合理，但有很多问题会搞砸这种复制方式：
* 任何呼叫 **非确定性函式（nondeterministic）** 的语句，可能会在每个副本上生成不同的值。例如，使用 `NOW()` 获取当前日期时间，或使用 `RAND()` 获取一个随机数。
* 如果语句使用了 **自增列（auto increment）**，或者依赖于资料库中的现有资料（例如，`UPDATE ... WHERE `），则必须在每个副本上按照完全相同的顺序执行它们，否则可能会产生不同的效果。当有多个并发执行的事务时，这可能成为一个限制。
* 有副作用的语句（例如：触发器、储存过程、使用者定义的函式）可能会在每个副本上产生不同的副作用，除非副作用是绝对确定性的。
的确有办法绕开这些问题 —— 例如，当语句被记录时，主库可以用固定的返回值替换掉任何不确定的函式呼叫，以便所有从库都能获得相同的值。但是由于边缘情况实在太多了，现在通常会选择其他的复制方法。
基于语句的复制在 5.1 版本前的 MySQL 中被使用到。因为它相当紧凑，现在有时候也还在用。但现在在预设情况下，如果语句中存在任何不确定性，MySQL 会切换到基于行的复制（稍后讨论）。VoltDB 使用了基于语句的复制，但要求事务必须是确定性的，以此来保证安全【15】。
#### 传输预写式日志（WAL）
在 [第三章](ch3.md) 中，我们讨论了储存引擎如何在磁碟上表示资料，我们也发现了通常会将写操作追加到日志中：
* 对于日志结构储存引擎（请参阅 “[SSTables 和 LSM 树](ch3.md#SSTables和LSM树)”），日志是主要的储存位置。日志段在后台压缩，并进行垃圾回收。
* 对于覆写单个磁碟块的 [B 树](ch3.md#B树)，每次修改都会先写入 **预写式日志（Write Ahead Log, WAL）**，以便崩溃后索引可以恢复到一个一致的状态。
在任何一种情况下，该日志都是包含了所有资料库写入的仅追加位元组序列。可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁碟之外，主库还可以透过网路将其传送给从库。