If, however, there is a line in the nginx error log file that contains the string [error] ,
then the test fails. Below is such an example.
…. # Failed test ‘TEST 1: simple test - pattern “[error]” should not match any line in
error.log but matches line “2016/02/01 11:59:50 [error] 1788#0: *1 lua entry
thread aborted: runtime error: content_by_lua(nginx.conf:42):2: bad”’ ….
This is a great way to find the details of the error quickly by just looking at the test
report.
Like error_log , this section also supports Perl array values and Perl regex values
though the eval filter.
==== Grep Tests
The error_log and no_error_log sections are very handy in quickly checking the
appearance of contain patterns in the NGINX error log file. But they have serious
limitations in that it is impossible to impose stronger constraints on the relative
order of the messages containing the patterns nor on the number of their
occurrences.
To address such limitations, Test::Nginx::Socket provides an alternative way to
check NGINX error logs in a way similar to the famous UNIX tool, grep . The
sections grep_error_log and grep_error_log_out are used for this purpose. The test
writer uses the grep_error_log section to specify a pattern, with which the test
framework scans through the NGINX error log file and collect all the matched parts
of the log file lines along the way, forming a final result. This aggregated log data
result is then matched against the expected value specified as the value of the
grep_error_log_out section, in a similar way as with the response_body section
discussed above.
It is easiest to explain with a simple example.
[source,test-base]
=== TEST 1: simple grep test for error logs — config location = /t {
content_by_lua_block { print(“it is matched!”) print(“it is matched!”) print(“it is
matched!”) } } — request GET /t — grep_error_log: it is matched! —
grep_error_log_out it is matched! it is matched! it is matched! —-
Openresty中文编程网 User Guide Page 33
测试前的准备 PDF last generated: November 08, 2016
Here we use the Lua function print() provided by the link:https://github.com/
openresty/lua-nginx-module#readme[ngx_http_lua] module to generate NGINX error
log messages at the notice level. This test case tests the number of the log
messages containing the string it is matched! . It is important to note that only the
matchedpart of the log file lines are collected in the final result instead of the
whole log lines. This simplifies the comparison a lot since NGINX error log
messages can contain varying details like timestamps and connection numbers.
A more useful form of this test is to specify a Perl regex pattern in the
grep_error_log section. Consider the following example.
[source,test-base]
=== TEST 1: simple grep test for error logs — config location = /t {
content_by_lua_block { print(“test: before sleeping…”) ngx.sleep(0.001) – sleeping
for 1ms print(“test: after sleeping…”) } } — request GET /t — grep_error_log eval:
qr/test: .*?.../ — grep_error_log_out test: before sleeping… test: after sleeping…
—-
We specify a Perl regex pattern, test: .*?\.\.\. , here to filter out all the error log
messages starting with test: and ending with ... . And naturally in this test we also
require the relative order of these two messages, that is, before sleeping must
appearbefore after sleeping . Otherwise, we shall see failure reports like below:
…. # Failed test ‘TEST 1: simple grep test for error logs - grep_error_log_out (req 0)’
# at …./lib/Test/Nginx/Socket.pm line 1048. # got: “test: after
sleeping…\x{0a}test: before sleeping…\x{0a}” # length: 49 # expected: “test:
before sleeping…\x{0a}test: after sleeping…\x{0a}” # length: 49 # strings begin to
differ at char 7 (line 1 column 7) ….
As with the response_body section, we can also call the no_long_string() Perl
function before run_tests() in the test file prologue, so as to disable the long string
output mode and enable the diff mode. Then the test failure would look like this:
…. # Failed test ‘TEST 1: simple grep test for error logs - grep_error_log_out (req 0)’
# at …/lib/Test/Nginx/Socket.pm line 1044. # @@ -1,2 +1,2 @@ # -test: before
sleeping… # test: after sleeping… # +test: before sleeping… ….
Obviously, for this test case, the diff format looks better.
==== Extra Delay Before Log Checks
By default, Test::Nginx::Socket performs the NGINX error log checks not long after it
receives the complete HTTP response for the test request. Sometimes, when the
log messages are generated by the server after sending out the response, the error
log checks may be carried out too early that the messages are not yet written into
the log file. In this case, we can specify an extra delay via the wait data section for
the test scaffold to wait for the error log messages. Here is an example:
Openresty中文编程网 User Guide Page 34
测试前的准备 PDF last generated: November 08, 2016
[source,test-base]
=== TEST 1: wait for the timer — config location = /t { content_by_lua_block { local
function f(premature) print(“HERE!”) end assert(ngx.timer.at(0.1, f)) } } — request
GET /t — error_log HERE! — no_error_log [error] — wait: 0.12 —-
Here we create a timer via the ngx.timer.at Lua function, which expires after 0.1
seconds. Due to the asynchronous nature of timers, the request handler does not
wait for the timer to expire and immediately finishes processing the current request
and sends out a response with an empty body. To check for the log message
HERE! generated by the timer handler f , we have to specify an extra delay for the
test scaffold to wait. The 0.12 seconds time is specified in this example but any
values larger than 0.1 would suffice. Without the wait section, this test case would
fail with the following output:
…. # Failed test ‘TEST 1: wait for the timer - pattern “HERE!” matches a line in
error.log (req 0)’ ….
Obviously the test scaffold checks the error log too soon, even before the timer
handler runs.
=== Section Review
Test::Nginx::Socket offers a rich set of data sections for specifying various different
input data and expected output data, ranging from NGINX configuration file
snippets, test requests, to expected responses and error log messages. We have
already demonstrated the power of data driven testing and declarative test case
crafting. We want to achieve multiple goals at the same time, that is, not only to
make the tests self-contained and highly readable, but also to make the test report
easy to interpret and analyze when some of the tests fail. Raw files automatically
generated by the test scaffold, like t/servroot/conf/nginx.conf and
t/servroot/logs/error.log , should be checked frequently when manually debugging
the test cases. The next section extends the discussion of this section with a focus
on testing erroneous cases.
Openresty中文编程网 User Guide Page 35
测试错误用例 PDF last generated: November 08, 2016
测试错误用例
SSuummmmaarryy:: 在可靠软件的开发过程中，错误处理占用了大部分时间。程
序员们需要在设计测试时关注各种边界条件和错误场景，力图最大化测
试覆盖。
== 测试错误用例
在可靠软件的开发过程中，错误处理占用了大部分时间。程序员们需要在设计测试
时关注各种边界条件和错误场景，力图最大化测试覆盖。
上一节介绍了 Test::Nginx::Socket 中的数据节（比如用于检查 NGINX 错误日志的
error_log ）。 它们是测试程序正确性的得力助手。 有时我们还需要测试更加极端
的场景，比如服务器启动错误、格式错误的响应、错误请求，还有形形色色的超时
错误。
=== 期望服务器启动错误
有些场景下，我们期望服务器在启动时出错而非继续运行，比如使用了错误的配置
指令，抑或没能满足初始化阶段的一些硬性要求。 如果我们想要测试这种情况，特
别是要检查错误日志中是否有某个特定的错误信息，可以使用 must_die 数据节，
告知测试脚手架我们期望NGINX 在这次测试中启动失败。
下面的例子测试在 ngx_http_lua 模块的 init_by_lua_block 上下文抛出 Lua 异常的情
况。
[source,test-base]
=== TEST 1: dying in init_by_lua_block — http_config init_by_lua_block { error(“I am
dying!”) } — config — must_die — error_log I am dying! —-
init_by_lua_block 中的 Lua 代码会在 NGINX 主进程加载 NGINX 配置文件时运行。 在
此抛出 Lua 异常会立刻终止 NGINX 的启动过程。 must_die 告诉测试脚手架，仅当
NGINX 启动失败，测试才算通过。 而 error_log 确保服务器确实是因为抛出了“I am
dying!”异常而退出的。
如果我们从上面的测试块移除 --- must_die ，那么该测试甚至不能成功运行：
…. t/a.t .. nginx: [error] init_by_lua error: init_by_lua:2: I am dying! stack traceback:
[C]: in function ‘error’ init_by_lua:2: in main chunk Bailout called. Further testing
stopped: TEST 1: dying in init_by_lua_block - Cannot start nginx using command
“nginx -p …/t/servroot/ -c …/t/servroot/conf/nginx.conf > /dev/null”. ….
Openresty中文编程网 User Guide Page 36
测试错误用例 PDF last generated: November 08, 2016
默认情况下测试脚手架会把 NGINX 服务器启动失败当作测试中的致命错误。 然而
must_die 的存在，会把它变成一项常规检查。
=== 期望格式错误的响应
HTTP 响应理论上应是格式良好的。不幸的是，梦想很丰满，现实很骨感。 有时候出
于某些意外， HTTP 响应会被截断，类似这样导致响应格式错误的情况还有很多。
作为设计错误用例的人，我们总是想要正常地测试像这样的异常情况。
通常来说， Test::Nginx::Socket 默认会检查从测试服务器收到的响应的完整性， 把
来自 NGINX 的格式错误的响应当作一种错误。 对于期望是格式错误或者被截断的响
应，我们需要通过 ignore_response 告知测试脚手架不去检查响应的格式。
考虑下面这个例子，服务器在发送了响应体的开头部分后立刻关闭了下游的连接。
[source,test-base]
=== TEST 1: aborting response body stream — config location = /t {
content_by_lua_block { ngx.print(“hello”) ngx.flush(true) ngx.exit(444) } } — request
GET /t — ignore_response — no_error_log [error] —-
content_by_lua_block 语句块中的 ngx.flush(true) 确保 NGINX 中缓冲的所有响应数据
确实被刷入系统的发送缓冲区了。 对于运行在本地的客户端而言，这就意味着收到
了响应数据。 紧接着， ngx.exit(444) 关闭了当前下游的连接，对于 HTTP 1.1 的分
块传输编码（chunked encoding），这将导致响应体被截断。 不要忽略
--- ignore_response 这一行，它告诉测试脚手架不要在意响应的完整性。 如果缺了这
一行，我们会在运行 prove 时看到这样的错误：
…. # Failed test ‘TEST 1: aborting response body stream - no last chunk found - 5 #
hello # ‘ ….
显然，测试脚手架会抱怨，说缺乏标记分块传输编码数据流结束的“last chunk”。 由
于在发送响应体数据的中途断开了连接，服务器没法发送分块传输编码所需的完整
响应体。
=== 测试超时错误
超时错误是现实生活中最常见的网络问题之一。 导致超时的原因有很多，比如线路
上的丢包，抑或接收端的连接问题，以及耗时操作阻塞了事件循环等等。 大多数应
用想要确保超时保护机制能正常工作，避免长时间地等待下去。
在一个自包含的测试框架中，测试和模拟超时异常通常要有特别的技巧。 毕竟，测
试时所使用的网络通信仅经过本地的回环网络设备，在延迟和带宽上不会有什么问
题。 接下来我们会看到，为了稳定地模拟五花八门的超时错误，测试套件中使用的
各种技巧。
==== 连接超时
Openresty中文编程网 User Guide Page 37
测试错误用例 PDF last generated: November 08, 2016
模拟 TCP 连接中的超时是最简单的。 仅需通过防火墙配置或其他方法，准备一个会
丢弃所有接收到的 SYN 包的远程地址，然后跟它建立连接。 我们在 agentzh.org 域
名的 12345 端口提供了这样的“黑洞”服务。如果你的测试运行环境允许连外网，那
么你就可以用上它。 考虑下下面的测试用例：
[source,test-base]
=== TEST 1: connect timeout — config resolver 8.8.8.8; resolver_timeout 1s;
location = /t {
content_by_lua_block {
local sock = ngx.socket.tcp()
sock:settimeout(100) -- ms
local ok, err = sock:connect("agentzh.org", 12345)
if not ok then
ngx.log(ngx.ERR, "failed to connect: ", err)
return ngx.exit(500)
end
ngx.say("ok")
}
} --- request GET /t --- response_body_like: 500 Internal Server Error --- error_code: 50
0 --- error_log failed to connect: timeout ----
这里我们配置了 resolver ，因为需要在请求时通过 Lua 代码解析域名 agentzh.org
。 我们使用 error_log 检查 NGINX 错误日志中是否含有 cosocket 对象的 connect()
方法返回的错误信息。
注意在测试用例中设置的超时限制要相对短一些，这样就不会花过多的时间在等待
测试结束。 毕竟测试需要被反复运行。运行测试的次数越多，我们从自动化测试获
取的收益就越多。
值得说明的是，测试脚手架的 HTTP 客户端也有一个超时限制，默认 3 秒。 如果你
的请求耗时超过 3 秒，你会在测试报告中看到这个错误信息：
…. ERROR: client socket timed out - TEST 1: connect timeout ….
如果注释了示例中的 settimeout ，依赖 cosocket 默认 60 秒的超时限制， 我们就
会收到这个信息。
通过设置 timeout 数据节的值，我们可以改变测试脚手架客户端默认的超时限制，
像这样：
[source,test-base]
— timeout: 10 —-