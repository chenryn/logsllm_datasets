寄存器名
名称
主要功能
eax
累加寄存器
运算
ebx
基址寄存器
存储内存地址
ecx
计数寄存器
计算循环次数
edx
数据计数器
存储数据
esl
源基址寄存器
存储数据发送源的内存地址
edi
目标基址寄存器
存储数据发送目标的内存地址
ebp
扩展基址指针寄存器
存储数据存储领域基点的内存地址
esp
扩展栈指针寄存器
存储栈中最高位数据的内存地址
①表10-2中表示的寄存器名称是x86自带的寄存器名称。在第1章中表1-1
列出的寄存器名称是一般叫法。两者有些不同，例如，x86的扩展基址指
针寄存器就相当于第1章中介绍的基址寄存器。
②x86系列32位CPU的寄存器名称中，开头都带了一个字母e，例如eax
ebx、ccx、edx等。这是因为16位CPU 的寄存需名称是ax、bx、cx、dx
等。32位CPU寄存器的名称中的e，有扩展（exlended）的意思。我们也
可以仅利用32位寄存器的低16位，此时只需把要指定的寄存器名开头的
字母e去掉即可。
---
## Page 199
10.6对找进行push和pop
10.5最常用的mov指令
指令中最常使用的是对寄存器和内存进行数据存储的mov指令。
mov指令的两个操作数，分别用来指定数据的存储地和读出源。操作
数中可以指定寄存器、常数、标签（附加在地址前），以及用方括号
（□）围起来的这些内容。如果指定了没有用方括号围起来的内容，
就表示对该值进行处理；如果指定了用方括号围起来的内容，方括号
中的值则会被解释为内存地址，然后就会对该内存地址对应的值进行
读写操作。接下来就让我们来看一下代码清单10-2中用到的mov指
令部分。
mov ebp, esp
mov eax,dvord ptr [ebp+8]
movebp.esp中，esp寄存器中的值被直接存储在了ebp寄存器中。
esp 寄存器的值是100时cbp寄存器的值也是100。面在mov eax.dword
ptr[ebp+8]的情况下.cbp寄存器的值加8后得到的值会被解释为内存
地址。如果cbp寄存器的值是100的话，那么eax寄存器中存储的就是
100+8=108地址的数据。dword ptr（double wordpointer）表示的是从
指定内存地址读出4字节的数据。像这样，有时也会在汇编语言的操
作数前附带dword ptr这样的修饰语。
10.6对栈进行push和pop
程序运行时，会在内存上申请分配一个称为栈的数据空间。栈
（stack）有“干草堆积如山”的意思。就如该名称所表示的那样，数据
在存储时是从内存的下层（大的地址编号）逐渐往上层（小的地址编
号）累积，读出时则是按照从上往下的顺利进行（图10-3）的。
---
## Page 200
第10章通过汇编语宜了解程序的实际构成
push指令存储
pop指令读出
低位地址
数据的顺序
数据的顺序
未使用的空间
push
用于栈的
esp寄存器指示
内存空间
的内存地址
数据
数据
数据
高位地址
数据
图10-3栈的模型
栈是存储临时数据的区域，它的特点是通过push指令和pop指令
进行数据的存储和读出。往栈中存储数据称为”入找”，从栈中读出数
据称为“出栈”。32位x86系列的CPU中，进行1次push或pop，即
可处理32位（4字节）的数据。
push指令和pop指令中只有一个操作数。该操作数表示的是“push
的是什么及pop的是什么”，而不需要指定“对哪一个地址编号的内存
进行push或pop”。这是因为，对栈进行读写的内存地址是由esp寄存
器（栈指针）进行管理的。push指令和pop指令运行后，esp寄存器的
值会自动进行更新（push指令是-4，pop命令是+4）.因而程序员就没
有必要指定内存地址了。
代码清单10-2中多次用到了push指令和pop指令。push指令运行
后，操作数中指定的值就会被自动push人栈，pop指令运行后，最后
存储在栈中的值就会被pop到指定的操作数中出栈。就如第4章中所
---
## Page 201
10.7函数调用机制
介绍的那样，这种数据的存储顺序称为LIFO（LastInFirstOut）
方式。
10.7函数调用机制
前面说了这么多，至此我们终于把阅读汇编语言源代码的准备工
作完成了。让我们再来回顾一下代码清单10-2的内容。首先，让我们从
MyFunc函数调用AdNum函数的汇编语言部分开始，来对函数的调用
机制进行说明。函数调用是栈发挥大作用的场合。把代码清单10-2中的
C语言源代码部分去除，然后再在各行追加注释，这时汇编语言的源代
码就如代码清单10-4所示。这也就是MyFunc函数的处理内容。
代码清单104函数调用的汇编语言代码
_MyPune
proc
near
push
ebp
：将ebp寄存器的值存入栈中
mov
ebp，eap：将ebp寄存器的值存入ebp寄存器
1456入栈
12
push
push
456
123
123入核
ca11
AddNun:
调用Addum函数
add
ebp.8
：读出栈中的数值存入eBp寄存器
eep寄存器的值加0
ret
pop
ebp
：结束MyPune函数，返回到调用源
_MyPune
endp
（1）（2）（7）（8）的处理适用于C语言中所有的函数，我们会
在后面展示AddNum函数处理内容时进行说明。这里希望大家先关注
一下（3）～（6）部分，这对了解函数调用的机制至关重要。
（3）和（4）表示的是将传递给AddNum函数的参数通过push人
栈。在C语言的源代码中，虽然记述为函数AddNum（123，456），但
①在函数的入口处把寄存器ebp的值入栈保存（代码清单10-4（1）），在函数
的出口处出我（代码清单10-4（7）），这是C语言编译器的规定。这样做是
为了确保函数调用前后ebp寄存器的值不发生变化。
更多资料请关注裁的新浪薄客http：//blog
---
## Page 202
第10章通过汇编语言了解程序的实际构成
人栈时则会按照456、123这样的顺序，也就是位于后面的数值先人
栈。这是C语言的规定。（5）的call指令，把程序流程跳转到了操作
数中指定的AddNum函数所在的内存地址处。在汇编语言中，函数名
表示的是函数所在的内存地址。AddNum函数处理完毕后，程序流程
必须要返回到编号（6）这一行。call指令运行后，call指令的下一行
（（6）这一行）的内存地址（调用函数完毕后要返回的内存地址）会自动
地push人栈。该值会在AddNum 函数处理的最后通过ret指令pop出
栈，然后程序流程就会返回到（6）这一行。
（6）部分会把栈中存储的两个参数（456和123）进行销毁处理，也
就是在第5章提到的栈清理处理。虽然通过使用两次pop指令也可以实
现，不过采用esp寄存器加8的方式会更有效率（处理1次即可）。对栈进
行数值的输入输出时，数值的单位是4字节。因此，通过在负责栈地址管
理的csp寄存器中加上4的2倍8，就可以达到和运行两次pop命令同样
的效果。虽然内存中的数据实际上还残留着，但只要把esp寄存器的值
更新为数据存储地址前面的数据位置，该数据也就相当于被销毁了。
前面已经提到，push指令和pop指令必须以4字节为单位对数据
进行入栈和出栈处理。因此，AddNum函数调用前和调用后栈的状态
变化就如图10-4所示。长度小与4字节的123和456这些值在存储时，
也占用了4字节的栈区域。
代码清单10-1中列出的C语言源代码中，有一个处理是在变量c
中存储AddNum函数的返回值，不过在汇编语言的源代码中，并没有
与此对应的处理。这是因为编译器有最优化功能。最优化功能是编译
器在本地代码上费尽功夫实现的，其目的是让编译后的程序运行速度
更快、文件更小。在代码清单10-1中，由于存储着AddNum函数返回
值的变量c在后面没有被用到，因此编译器就会认为“该处理没有意
88
---
## Page 203
10.8面数内部的处理
义”，进面也就没有生成与之对应的汇编语言代码。在编译代码清单
10-1的代码时，应该会出现“警告W8004Sample4.c11:c的赋值未被
使用（函数MyFunc）这样的警告消息。
[a）AddNum函数调用前
（e）从AddNum返图后（f）MyFunc函数处理完毕时
未使用的空间
未使用的空间
返回目的地的内存地址
未使用的空间
123
123
（清理处理）
456
456
ebp寄存器的值
ebp寄存器的值
图10-4AddNum函数调用前后栈的状态变化
10.8函数内部的处理
接下来，让我们透过执行AddNum函数的源代码部分，来看一下
参数的接收、返回值的返回等机制（代码清单10-5）。
代码清单10-5函数内部的处理
_AddNum
proc
near
push
ebp
mov
ebp,esp
1
nov
eax, dvord ptr [ebp+12]
eax,dvord ptr [ebp+8]
add
pop
ebp
AddNun
ret
endp
更多资料请关注我的新浪薄客tt
---
## Page 204
第10章通过汇编语言了解程序的实际构成
ebp寄存器的值在（1）中入栈，在（5）中出栈。这主要是为了把
函数中用到的ebp寄存器的内容，恢复到函数调用前的状态。在进人
函数处理之前，无法确定ebp寄存器用到了什么地方，但由于函数内
部也会用到ebp寄存器，所以就暂时将该值保存了起来。CPU拥有的
寄存器是有数量限制的。在函数调用前，调用源有可能已经在使用ebp
寄存器了。因而，在函数内部利用的寄存器，要尽量返回到函数调用
前的状态。为此，我们就需要将其暂时保存在栈中，然后再在函数处
理完毕之前出栈，使其返回到原来的状态。
（2）中把负责管理栈地址的esp寄存器的值赋值到了ebp寄存器
中。这是因为，在mov指令中方括号内的参数，是不允许指定esp寄
存器的。因此，这里就采用了不直接通过esp.而是用cbp寄存器来读
写栈内容的方法
（3）是用[ebp+8]指定栈中存储的第1个参数123，并将其读出到
cax寄存器中。像这样，不使用pop指令，也可以参照栈的内容。而之
所以从多个寄存器中选择了cax寄存器，是因为cax寄存器是负责运算
的累加寄存器
通过（4）的add指令，把当前cax寄存器的值同第2个参数相加
后的结果存储在cax寄存器中。[ebp+12]是用来指定第2个参数456
的。在C语言中，函数的返回值必须通过cax寄存器返回，这也是规
定。不过，和ebp寄存器不同的是，eax寄存器的值不用还原到原始状
态。至此，我们进行了很多细节的说明，其实就是希望大家了解“函数
的参数是通过栈来传递，返回值是通过寄存器来返回的”这一点。
（6）中ret指令运行后，函数返回目的地的内存地址会自动出栈，
据此，程序流程就会跳转返回到代码清单10-4的（6）（Call_AddNum
的下一行）。这时，AddNum函数人口和出口处栈的状态变化，就如图
---
## Page 205
10.9始终确保全局变量用的内存空间
10-5所示。将图10-4和图10-5按照（a）（b）（c）（d）（e）（f）的顺
序来看的话，函数调用处理时栈的状态变化就会很清楚了。由于（a）
状态时处理跳转到AddNum函数，因此（a）和（b）是同样的。同理，
在（d）状态时，处理跳转到了调用源，因此（d）和（e）是同样的。在