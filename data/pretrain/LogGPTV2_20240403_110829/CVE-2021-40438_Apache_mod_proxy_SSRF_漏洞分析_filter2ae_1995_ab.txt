        port = def_port = (is_ssl) ? DEFAULT_HTTPS_PORT : DEFAULT_HTTP_PORT;
        ...
        switch (r->proxyreq) {
        default: /* wtf are we doing here? */
        case PROXYREQ_REVERSE:
            if (apr_table_get(r->notes, "proxy-nocanon")) {
                path = url;   /* this is the raw path */
            }
            else {
                path = ap_proxy_canonenc(r->pool, url, strlen(url),
                                         enc_path, 0, r->proxyreq);
                search = r->args;
            }
            break;
        case PROXYREQ_PROXY:
            path = url;
            break;
        }
        if (path == NULL)
            return HTTP_BAD_REQUEST;
        if (port != def_port)
            apr_snprintf(sport, sizeof(sport), ":%d", port);
        else
            sport[0] = '\0';
        // host pass
        if (ap_strchr_c(host, ':')) { /* if literal IPv6 address */
            host = apr_pstrcat(r->pool, "[", host, "]", NULL);
        }
        // 最终拼接赋值给 r->filename
        r->filename = apr_pstrcat(r->pool, "proxy:", scheme, "://", host, sport,
                                  "/", path, (search) ? "?" : "", search, NULL);
        return OK;
    }
结合注释，可以看到最终只有 `path` 和 `search` 是我们可控的，`r->filename` 后半部分可控也恰恰是 `|` 后的后端地址。
####  UDS 解析过程
之前在代码注释中也提到过，`uds_path` 就是 `unix:` 与 `|` 之间的部分，在 poc 中就是那近 7000 的字符。
    char *sockpath = ap_runtime_dir_relative(r->pool, urisock.path);
    // 将 uds_path 键值对添加到 r->notes
    apr_table_setn(r->notes, "uds_path", sockpath);
先来看 `ap_runtime_dir_relative` 做了什么。
server/config.c
    // ap_runtime_dir_relative(r->pool, urisock.path)
    AP_DECLARE(char *) ap_runtime_dir_relative(apr_pool_t *p, const char *file)
    {
        char *newpath = NULL;
        apr_status_t rv;
        const char *runtime_dir = ap_runtime_dir ? ap_runtime_dir : ap_server_root_relative(p, DEFAULT_REL_RUNTIMEDIR);
        rv = apr_filepath_merge(&newpath, runtime_dir, file,
                                APR_FILEPATH_TRUENAME, p);
        if (newpath && (rv == APR_SUCCESS || APR_STATUS_IS_EPATHWILD(rv)
                                          || APR_STATUS_IS_ENOENT(rv)
                                          || APR_STATUS_IS_ENOTDIR(rv))) {
            return newpath;
        }
        else {
            return NULL;
        }
    }
可以看到调用了 apr 库的 `apr_filepath_merge` 这个函数。
apr/file_io/unix/filepath.c
    // apr_filepath_merge(&newpath, runtime_dir, file,APR_FILEPATH_TRUENAME, p)
    APR_DECLARE(apr_status_t) apr_filepath_merge(char **newpath,
                                                 const char *rootpath,
                                                 const char *addpath,
                                                 apr_int32_t flags,
                                                 apr_pool_t *p)
    {
        ...
        rootlen = strlen(rootpath);
        maxlen = rootlen + strlen(addpath) + 4; /* 4 for slashes at start, after
                                                 * root, and at end, plus trailing
                                                 * null */
        if (maxlen > APR_PATH_MAX) {
            return APR_ENAMETOOLONG;
        }
        ...
    }
`apr_filepath_merge` 这个函数简单描述就是将 `addpath` 合并到预先处理的 `rootpath` 上，在这里就是 `file`
合并到 `runtime_dir` 。
对省略的部分解释一下，这里的 `flags` 因为是 `APR_FILEPATH_TRUENAME`（这是合并的规则），流程大概就是检查 `file` 这个
`addpath` 是否包含一些平台不支持的通配符（ `*` 、`?`），其他情况是处理绝对 / 相对路径的一些规则。
可以看到我们截取出来的部分，如果 `maxlen` 也就是 `rootpath` 和 `addpath` 长度 + 4 如果大于
`APR_PATH_MAX`（ linux 与 win 不同，是4096），就会返回一个 `APR_ENAMETOOLONG` 的错误，这个错误赋值给
`rv` ，在 `ap_runtime_dir_relative` 中是最后会进入 else 分支 **return NULL** 的。
之后在 modules/proxy/proxy_util.c 中 `ap_proxy_determine_connection` 确定后端主机名和端口。
    PROXY_DECLARE(int)
    ap_proxy_determine_connection(apr_pool_t *p, request_rec *r,
                                  proxy_server_conf *conf,
                                  proxy_worker *worker,
                                  proxy_conn_rec *conn,
                                  apr_uri_t *uri,
                                  char **url,
                                  const char *proxyname,
                                  apr_port_t proxyport,
                                  char *server_portstr,
                                  int server_portstr_size)
    {
        ...
        // 这里是不是很熟悉？
        // 还记得之前有这句 apr_table_setn(r->notes, "uds_path", sockpath); 将 uds_path 键值对添加到 r->notes 吗？
        // 这里就是在检验 uds_path 的值
        uds_path = (*worker->s->uds_path ? worker->s->uds_path : apr_table_get(r->notes, "uds_path"));
        if (uds_path) {
            if (conn->uds_path == NULL) {
                /* use (*conn)->pool instead of worker->cp->pool to match lifetime */
                conn->uds_path = apr_pstrdup(conn->pool, uds_path);
            }
            if (conn->uds_path) {
                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02545)
                             "%s: has determined UDS as %s",
                             uri->scheme, conn->uds_path);
            }
            else {
                /* should never happen */
                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02546)
                             "%s: cannot determine UDS (%s)",
                             uri->scheme, uds_path);
            }
            /*
             * In UDS cases, some structs are NULL. Protect from de-refs
             * and provide info for logging at the same time.
             */
            if (!conn->addr) {
                apr_sockaddr_t *sa;
                apr_sockaddr_info_get(&sa, NULL, APR_UNSPEC, 0, 0, conn->pool);
                conn->addr = sa;
            }
            conn->hostname = "httpd-UDS";
            conn->port = 0;
        }
        else{
            ...
        }
        ...
    }
对照注释，如果我们发送超长字符，导致 `uds_path` 为 `NULL` 的话，就会进入 else 分支，它们具体处理大致是这样一个情况：
    if (uds_path) { 
        // Prepare UDS request…
        // 用 UDS 继续通信
    }
    else {
        // Prepare standard proxy request…
        // 转而用 TCP 通信
    }
这里结合所有内容就可以看出来了，进入 else 分支把请求最终解释成了标准代理请求如 http:// ，就导致了可以向内部网络任意
Apache 服务器发送请求，请求执行成功，SSRF 触发。
###  漏洞利用
有时会报 503 的错误，多试几次就行了。
## 0x04 参考
[Building a POC for CVE-2021-40438 – Firzens Blog](https://firzen.de/building-a-poc-for-cve-2021-40438)
[Apache SSRF: an all-you-can-eat reverse proxy > Cydrill Software
Security](https://cydrill.com/owasp/apache-ssrf-an-all-you-can-eat-reverse-proxy/)
[Apache mod_proxy SSRF（CVE-2021-40438）的一点分析和延伸 | 离别歌
(leavesongs.com)](https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html#)