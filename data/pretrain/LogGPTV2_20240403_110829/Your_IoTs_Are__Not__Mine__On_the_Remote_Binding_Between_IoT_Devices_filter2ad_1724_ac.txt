(cid:47)(cid:381)(cid:100)(cid:3)(cid:24)(cid:286)(cid:448)(cid:349)(cid:272)(cid:286)
(cid:3)(cid:1992)(cid:3)(cid:17)(cid:349)(cid:374)(cid:282)(cid:100)(cid:381)(cid:364)(cid:286)(cid:374)
(cid:104)(cid:400)(cid:286)(cid:396)(cid:3)(cid:4)(cid:393)(cid:393)
(c) Capability-based binding
Fig. 4: Binding Creation
• Device-initiated binding. For this design, ﬁrst, the user
credential (i.e. the username U serId and the password
U serP w) is delivered to the device during local conﬁg-
uration. Next, the device submits a binding message that
contains both the user credential and the device ID to
the cloud. After receiving the message, the cloud creates
a binding relationship. However, delivering the user’s
credential to the device might put the user account in
danger if the device is compromised.
Interestingly, in some ACL-based binding designs, we ﬁnd
that after the binding message is submitted to the cloud, the
user and the device will execute an extra step for the post-
binding authorization, which could prevent device hijacking
attacks (see Section V-E). More speciﬁcally, when the binding
messages are submitted to the cloud, a random token will
be returned to both the user and the device by the cloud.
In the subsequent interactions, this token will be included in
227
every message of the device and the user app5. With such a
mechanism, even if an attacker can forge a binding message
that indicates the binding between the attacker and the victim’s
device, hijacking a victim’s device is infeasible. The reason is
that the attacker is unable to force the target device to submit
the same token (as the attacker’s). Note that, although the
involvement of a random token can prevent the forgery of user
messages and device messages in the control state, it cannot
prevent the forgery of binding messages.
Capability-based binding. Under our adversary model, a
secure binding mechanism should rely on the capability-based
authorization, in which an authorization token (in this case,
the binding message is: Bind : BindT oken) is delivered from
the cloud to the user app and then locally transmitted to the
device [3]. After that, the device submits this token back to
the cloud, to conﬁrm the binding with that user. This design
could guarantee the user’s ownership of the device: to bind
with a device remotely, the user must be locally bound with
the device.
Our assessment: A signiﬁcant misunderstanding of binding
creation is the use of ACL-based binding, in which ven-
dors combine devId and U serT oken to conﬁrm binding
relationships. This design could result
in the “ambient
authoritya” [1] and open the door to a series of attacks (as
demonstrated in Section V). Instead, the best practice is to
use capability-based binding, such as the solution of Sam-
sung SmartThings [3]. That is, a binding token BindT oken
represents the actual authority, and the authorization step is
only achieved by locally communicating with that speciﬁc
device (i.e., ownership conﬁrmation).
aThe device ID itself does not including authorizing information and
could potentially be used by other users.
C. Binding Revocation
A binding is revoked when the device is reset or the user
removes the device in her account6. We found that there are
three kinds of unbinding messages to revoke bindings in the
cloud (assuming that device i is bound with user j in the
cloud):
• Type 1: U nbind : (DevIdi, U serT okenj). To revoke
the binding, the user or the device sends an unbinding
message with the user token and the device ID to the
cloud. When receiving such a message, the cloud ﬁrst
veriﬁes the user token and then revokes the corresponding
binding according to the submitted device ID. Besides,
the cloud needs to check whether the message sender
has been already bound with the device.
• Type 2: U nbind : DevIdi. Alternatively, an unbinding
message can be sent from the IoT device. Since one
5For the device, such a token means the device token that we previously
discussed.
6There could be multiple ways to achieve physical device reset. For
example, a message can be sent from the device if the device has been
physically reset and connects to the Internet. This message informs the cloud
that the previous binding should be revoked.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:41 UTC from IEEE Xplore.  Restrictions apply. 
device only belongs to a speciﬁc user, an unbinding
message only containing the device identiﬁer can also
achieve unbinding function. This approach can bring
convenience to the user because the unbinding message
can be sent during the device reset and no extra action
is needed. Unfortunately, this approach could also bring
security risks because anyone obtaining the device ID can
forge an unbinding message and revoke the binding.
• Type 3: Bind : (DevIdi, U serT okenn). An interesting
ﬁnding is that there is one device that does not support
unbinding operations, and the user has to use new bind-
ing to replace the previous one in the cloud. In other
words, whenever a binding message is received, the cloud
replaces the bound user i with the new user n. This
design decreases the development efforts for developers,
but inevitably introduces new security risks: the attacker
can forge binding messages to replace a user’s binding,
which could cause device unbinding or device hijacking
(see Section V).
Our assessment: Binding revocation is also a critical autho-
rization procedure that is often misunderstood or neglected
by developers. Our study concludes that not only should
it be correctly designed (e.g., using authorization token to
manipulate cloud-side resources), but also the cloud should
enforce strict policy to check whether a message sender
indeed has the permission to revoke the claimed binding
relationship.
V. SECURITY VULNERABILITIES
In this section, we analyze the security risks lying in the
remote binding. Notably, we show how the design and im-
plementation choices can be abused to launch several attacks,
ranging from binding denial-of-service to device hijacking.
A. Overview
We aim to investigate the security risks in remote binding
with respect to the procedures that we described earlier. To
this end, we systematically explore potential attack surfaces by
considering that all three types of messages could be forged
and sent to the cloud in all states of a device shadow:
• When status messages are forged, the attacker could act
as the user’s device. As such, fake device data can be
injected and user data can be stolen in the control state
and the bound state. We call it data injection and stealing
attack.
• When binding messages are forged, the attacker could
create a binding with the user’s device before the user
binds with it. This causes binding denial-of-service at-
tacks. Or alternatively, if the user is already bound with
her device, the binding could be replaced by the attacker’s
binding. In this case, it is possible for the attacker to
disconnect the user with her device or take control of the
user’s device.
• When unbinding messages are forged, the attacker could
revoke the user’s binding. This causes device unbinding
to the user. Note that this attack could also be combined
with binding message forgery to further hijack the user
device.
The attacks can be categorized into four types: data stealing
and injection, binding occupation, device unbinding, and de-
vice hijacking. We give a taxonomy in Table II and describe
them in details in the following.
B. Data Injection and Stealing (A1)
This attack occurs when the user’s device shadow is in
the control state or the bound state. The attacker can forge
status messages with the user’s device ID. As a result, data
from the “device” cannot be trusted, and the user data could
also be leaked to the “device”. One consequence is that the
attacker can inject the sensor data to the cloud and the user.
For example, if the user owns a ﬁre alarm, the attacker can
inject fake data to trigger alerts and annoy the user. Even
worse, it will have a cascade effect when data from the device
is involved in rules (e.g., IFTTT [9]). For instance, when
an air conditioning system is associated with a temperature
sensor, fake data of the sensor may turn on or turn off the air
conditioning system. On the other hand, the attacker can also
forge device messages to retrieve private user data from the
cloud, for example, when the user sets a schedule for a smart
lock, the attacker is able to obtain the opening and closing
time of the door.
C. Binding Denial-of-Service (A2)
Binding denial-of-service occurs when the attacker occupies
the binding of a user’s device before the user binds with the
device. The forged binding message consists of the attacker’s
token and the user’s device ID. Once the attack is successfully
launched, the user is unable to create the binding with her own
device. Unfortunately, given that some vendors use sequential
device IDs for its products, attackers can enumerate or brute-
force the device IDs, and it could even cause scalable denial-
of-service attacks to the entire product series of a vendor [14],
[18].
D. Device Unbinding (A3)
The attacker can also leverage unbinding messages, binding
messages or status messages to disconnect the user with the
user’s device. Speciﬁcally, For unbinding message forgery, the
message U nbind : DevId with the user’s device ID can be
utilized to revoke the user’s binding in the cloud (A3-1). For
unbinding message type U nbind : (DevId, U serT oken), the
attacker will succeed only if the cloud does not check whether
the submitted user token is the bound user (A3-2). On the
other hand, binding messages can also be leveraged to cause
device unbinding (A3-3). In this case, the attacker sends a
binding message to replace the user’s binding if the cloud does
not check whether the device is already bound with a user.
Therefore, after the attacker’s binding is created, the device
will disconnect with the user. In addition to that, forgery of
status messages can also cause device unbinding (A3-4). In
this case, the cloud takes the attacker as a new device and
228
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:41 UTC from IEEE Xplore.  Restrictions apply. 
TABLE II: The Taxonomy of Attacks in Remote Binding
Attacks
Forged message types
Targeted states
End states
Consequences
A1: Data injection and stealing
Status : DevId
Control state
and bound state
Control state
The attacker can inject fake device data
or steal private user data.
A2: Binding denial-of-service
Bind :(DevId, U serT oken)
Initial state
Bound state
The attacker can cause denial-of-service to the
user’s binding operation.
A3: Device
unbinding
A4: Device
hijacking
A3-1
A3-2
A3-3
A3-4
A4-1
A4-2
A4-3
U nbind : DevId
U nbind :(DevId, U serT oken)
Bind :(DevId, U serT oken)
Status : DevId
Bind :(DevId, U serT oken)
 U nbind : DevId
or (DevId, U serT oken)
 Bind :(DevId, U serT oken)
Control state
Online state
The attacker can disconnect the device with
the user.
Control state
Online state
Control state
Control state
Control state
Control state
The attacker can take absolute control of
the device.
disconnect with the real device. Such attacks can cause denial-
of-service to the user’s operation of her devices, which may
lead to serious consequences. For example, a user’s property
may be put in danger if a smart lock or a ﬁre alarm stop
reporting status to the user.
E. Device Hijacking (A4)
For this attack, the attacker can take absolute control of the
device. In particular, there are three ways to achieve device
hijacking. On the one hand, the attacker can send a binding
message with the attacker’s token and the user’s device ID to
the cloud. In this case, we consider the user’s device shadow
can be in two states: the control state and the online state.
When the user is in the control state, the attack occurs (A4-1)
if the cloud does not check the message sender and the bound
user. This could either be an implementation ﬂaw in which the
cloud directly manipulate the existing binding without checks
or a design ﬂaw of unbinding in which a previous user’s
binding is designed to be replaced by a new binding. Note
that such an attack happens in the entire control state, instead
of the perfect timing of binding operations. When the user is
in the online state, the attacker can bind with the user’s device
before the user does, by exploiting the time window during
user’s device setup (A4-2).
On the other hand, device hijacking can also be achieved
(A4-3) by combining two vulnerabilities. In particular, the
attacker ﬁrst sends an unbinding message to disconnect the
user and the device (A3-1). This turns the device into the
online state. Next, the attacker can send a binding message
to bind with the device and take control of it (A4-2). Note
that above device hijacking attacks will fail if device tokens
are used for device authentication. Because the device cannot
authenticate to the cloud without receiving a device token from
the attacker.
VI. EXPERIMENTAL RESULTS
In this section, we ﬁrst describe our experiment setup to
evaluate the devices and perform our attacks. Then we give our
evaluation results of the attacks. In the end, we further clarify
the misunderstandings and discuss why existing designs fail.
A. Experiment Procedures
In our experiments, the user and the attacker have different
network access (the attacker’s access point
is set up on
an Ubuntu host machine with 8G RAM and Intel Core i7
2.81 GHz), different Android smartphones (Samsung Galaxy
S5, Android 5.0) and different accounts. We installed the
companion apps of the devices in both smartphones and logged
in the apps with the user’s account and the attacker’s account
respectively. Then we setup the devices and conﬁgure them
with the corresponding apps.
As the ﬁrst step, we need to identify device IDs of users’
devices. Among the 10 devices that we studied, 6 of them
directly attach the device IDs on the devices. 5 of them
use MAC addresses (the ﬁrst 3-bytes are ID number of the
manufacturer) as their device IDs. For the rest, device IDs
can be observed from the trafﬁc or be easily obtained with a
differential analysis of the messages.
Next, to launch the attacks, we substitute the user’s device
IDs with the attacker’s device IDs in the targeted messages. To
this end, we ﬁrst identify the binding and unbinding messages
through manual dynamic analysis of the apps (9 devices
send binding messages by apps). To capture and analyze the
HTTP/HTTPS messages from the attacker’s app, we use a
Man-in-the-Middle proxy [6]. Then we generate fake requests
using the tool Postman [11]. For unknown protocols, we use