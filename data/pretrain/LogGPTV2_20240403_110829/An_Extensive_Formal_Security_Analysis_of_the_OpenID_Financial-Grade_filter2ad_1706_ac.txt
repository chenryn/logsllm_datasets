(1)
It contains both the Token Binding ID (i.e., essentially kB,S) and
the signed EKM value from the TLS connection, as speciﬁed
in [39]. The server S checks the signature using kB,S as included
in this message and then creates a token and associates it with
the Token Binding ID as the unique identiﬁer of the browser.
When B wants to redeem the token in a new TLS connection
to S, B creates a new Token Binding Message using the same
Token Binding ID, but signs the new EKM value:
TB-Msg[kB,S, sig(EKM,k
(cid:2)
B,S)]
(2)
As the EKM values are unique to each TLS connection, S
concludes that the sender of the message knows the private
key of the Token Binding ID, and as the sender used the same
Token Binding ID as before, the same party that requested the
token in the ﬁrst request is using it now.
The above describes the simple situation that B wants to
redeem the token received from S again at S, i.e., from the
same origin. In this case, we call the token binding message
in (1) a provided token binding message. If B wants to redeem
the token received from S at another origin, say at C, then
instead of just sending the provided token message in (1), B
would in addition also send the so-called referred token binding
message, i.e., instead of (1) B would send
(cid:2)
B,S)],
TB-prov-Msg[kB,S, sig(EKM,k
(cid:2)
TB-ref-Msg[kB,C, sig(EKM,k
B,C)].
(3)
Note that the EKM is the same in both messages, namely the
EKM value of the TLS connection between B and S (rather
than between B and C, which has not happened yet anyway).
Later when B wants to redeem the token at C, B would use
kB,C in its (provided) token message to C.
2) Token Binding for OAuth: In the following, we explain
how token binding is used in OAuth in the case of app clients.
The case of web server clients is discussed below.
The ﬂow is shown in Figure 2. Note that in this case, token
binding is used between the OAuth client and the authorization
and resource servers; the browser in Figure 1 is not involved.
The client has two token binding key pairs, one for the AS
and one for the RS (if these key pairs do not already exist,
the client creates them during the ﬂow). When sending the
authorization request (Step 2 of Figure 2), the client includes
the hash of the Token Binding ID it uses for the AS as a PKCE
challenge (cf. Section II-B). When exchanging the code for
an access token in Step 7 , the client proves possession of the
private key of this Token Binding ID, and the AS only accepts
the request when the hash of the Token Binding ID is the
same as the PKCE challenge. Therefore, the code can only be
exchanged by the participant that created the authorization
Browser
Client
Authorization Server
1 POST /start
POST /start
Create (kC,AS,k
Create (kC,AS,k
Create (kC,RS,k
Create (kC,RS,k
(cid:2)
(cid:2)
C,AS
C,AS
(cid:2)
(cid:2)
C,RS
C,RS
)
)
)
)
2 Response
Response
Redirect to AS /authorization_endpoint
Redirect to AS /authorization_endpoint
(client_id, . . . , hash(kC,AS))
(client_id, . . . , hash(kC,AS))
3 GET /authorization_endpoint
GET /authorization_endpoint
(client_id, . . . , hash(kC,AS))
(client_id, . . . , hash(kC,AS))
4 resource owner authenticates
resource owner authenticates
5 Response
Response
Redirect to C /redirect_uri (code, state)
Redirect to C /redirect_uri (code, state)
6 GET /redirect_uri
GET /redirect_uri
(code, state)
(code, state)
7 POST /token_endpoint
POST /token_endpoint
TB-prov-Msg[kC,AS,sig1], TB-ref-Msg[kC,RS,sig
TB-prov-Msg[kC,AS,sig1], TB-ref-Msg[kC,RS,sig
(code, . . . ,
(code, . . . ,
(cid:2)
(cid:2)
1])
1])
8 Response
Response
(access token)
(access token)
Authorization Server
Resource Server
GET /resource
9 GET /resource
(access token, TB-prov-Msg[kC,RS,sig2])
(access token, TB-prov-Msg[kC,RS,sig2])
10 Response
Response
(resource)
(resource)
Browser
Client
Resource Server
Figure 2. OAUTB for App Clients
request. Note that for this purpose the AS only takes the
provided token binding message sent to the AS in Step 7
into account. However, the AS also checks the validity of the
referred token binding message (using the same EKM value)
and associates kC,RS with the token issued by the AS in Step 8 .
The token binding ID kC,RS is used in Step 9 by the client to
redeem the token at the RS. The RS then checks if this is the
same token binding ID that is associated with the access token.
This information can be contained in the access token if it is
structured and readable by the RS or via token introspection.
Altogether, Token Binding for OAuth (in the case of app
clients) is supposed to bind both the authorization code and
the access token to the client. That is, only the client who
initiated the ﬂow (in Step 2 ) can redeem the authorization
code at the AS and the corresponding access token at the RS,
and hence, get access to the resource at the RS.
3) Binding Authorization Codes for Web Server Clients:
In the case that the client is a web server, the binding of
the authorization code to the client is already done by client
(cid:21)(cid:22)(cid:25)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:17 UTC from IEEE Xplore.  Restrictions apply. 
authentication, as a web server client is always conﬁdential (cf.
Section II-A1). Therefore, the client does not include the hash
of a Token Binding ID in the authorization request (Step 2 of
Figure 2). Instead, the mechanism deﬁned in OAUTB aims at
binding the authorization code to the browser/client pair. (The
binding of the access token to the client is done in the same
way as for an app client).
More precisely, for web server clients, the authorization code
is bound to the token binding ID that the browser uses for the
client. For this purpose, the client includes an additional HTTP
header in the ﬁrst response to the browser (Step 2 of Figure 2),
which signals the browser that it should give the token binding
ID it uses for the client to the authorization server. When
sending the authorization request to the authorization server in
Step 3 , the browser thus includes a provided and a referred
token binding message, where the referred message contains
the token binding ID, that the browser later uses for the
client (say, kB,C). When generating the authorization code, the
authorization server associates the code with kB,C.
When redirecting the code to the client in Step 6 , the
browser includes a token binding message for kB,C, thereby
proving possession of the private key.
When sending the token request
the client
includes kB,C. We highlight that the client does not send a
token binding message for kB,C since the client does not know
the corresponding private key (only the browser does).
in Step 7 ,
The authorization server checks if this key is the same
token binding ID it associated the authorization code with, and
therefore, can check if the code was redirected to the client
by the same browser that made the authorization request. In
other words, by this the authorization code is bound to the
browser/client pair.
F. JWT Secured Authorization Response Mode
The recently developed JWT Secured Authorization Re-
sponse Mode (JARM) [40] aims at protecting the OAuth
authorization response (Step 5 of Figure 1) by having the AS
sign (and optionally encrypt) the response. The authorization
response is then encoded as a JWT (see Section II-C). The
JARM extension can be used with any OAuth 2.0 ﬂow.
In addition to the regular parameters of the authorization
response, the JWT also contains its issuer (identifying the AS)
and its audience (client id). For example, if combined with
the Authorization Code Flow, the response JWT contains the
issuer, audience, authorization code, and state values.
By using JARM, the authorization response is integrity pro-
tected and injection of leaked authorization codes is prevented.
III. THE OPENID FINANCIAL-GRADE API
The OpenID Financial-grade API [5] currently comprises
two implementer’s drafts. One deﬁnes a proﬁle for read-
only access, the other one for read-write access. Building on
Section II, here we describe both proﬁles and the various
conﬁgurations in which these proﬁles can run (see Figure 3).
Furthermore, we explain the assumptions made within the FAPI
standard and the underlying OAuth 2.0 extensions.
FAPI
Read-Only
Read-Write
Web Server
App
Client
Authentication
Holder of Key
Mechanism
OAUTB for
Code Binding
Code Flow
JARM (Code Flow)
Hybrid Flow
pub
conf
pub
conf
JWS
mTLS
JWS
mTLS
OAUTB
OAUTB
mTLS
App TB
App TB
Web Server TB
PKCE
Figure 3. Overview of the FAPI. One path (terminated by a box with
rounded corners) describes one possible conﬁguration of the FAPI.
The paths marked with PKCE use PKCE. JARM and Hybrid ﬂows
both allow for the conﬁgurations shown.
A. Financial-grade API: Read-Only Proﬁle
In the following, we explain the Read-Only ﬂow as described
in [41]. The Read-Only proﬁle aims at providing a secure way
for accessing data that needs a higher degree of protection
than regular OAuth, e.g., for read access to ﬁnancial data.
The Read-Only ﬂow is essentially an OAuth Authorization
Code ﬂow (cf. Section II). Additionally, the client can request
an ID Token (see Section II-A2) from the token endpoint by
adding a scope parameter to the authorization request (Step 2
of Figure 1) with the value openid.
In contrast to regular OAuth and OpenID Connect, the client
is required to have a different set of redirection URIs for
each authorization server. This separation prevents mix-up
attacks, where the authorization response (Step 6
in Figure 1)
comes from a different AS than the client expects (see [6] and
[42] for more details on mix-up attacks). When receiving the
authorization response, the client checks if the response was
received at the redirection URI speciﬁed in the authorization
request (Step 2
in Figure 1).
One of the main additions to the regular OAuth ﬂow is
the use of PKCE as explained in Section II-B. The PKCE
challenge is created by hashing a nonce.
The FAPI furthermore requires conﬁdential clients to
authenticate at the token endpoint (in Step 7 of Figure 1)
using either JWS Client Assertions (cf. Section II-C) or
Mutual TLS (cf. Section II-D). Public clients do not use client
authentication.
B. Financial-grade API: Read-Write Proﬁle
The Read-Write proﬁle [43] aims at being secure under
stronger assumptions than the Read-Only proﬁle, in order to
(cid:21)(cid:22)(cid:26)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:17 UTC from IEEE Xplore.  Restrictions apply. 
be suitable for scenarios such as write access to ﬁnancial data.
The full set of assumptions is described in Section III-C.
in Figure 1) and the token response (Step 8
The ﬂow can be either an OpenID Connect
(OIDC)
Hybrid ﬂow, which means that both the authorization response
(Step 5
in
Figure 1) contain an id token (see Section II-A2), or any other
OAuth-based ﬂow used together with JARM (see Section II-F).
When using the Hybrid ﬂow, the FAPI proﬁle also requires
that the hash of the state value is included in the ﬁrst id token.
In addition to the parameters of the Read-Only ﬂow, the au-
thorization request prepared by the client (Step 2 of Figure 1)
is required to contain a request JWS, which is a JWT, signed
by the client, containing all request parameters together with
the audience of the request (cf. Section II-C).
One of the main security features of the proﬁle is the
binding of the authorization code and the access token
to the client, which is achieved by using either mTLS
(cf. Section II-D) or OAUTB (OAuth 2.0 Token Binding, see
Section II-E). A public client is required to use OAUTB, while
a conﬁdential client can use either OAUTB or mTLS.
If the client is a conﬁdential client using mTLS, the request
does not contain a PKCE challenge. When using OAUTB, the
client uses a variant of PKCE, depending on whether the
client is a web server client or an app client (cf. Section II-E).