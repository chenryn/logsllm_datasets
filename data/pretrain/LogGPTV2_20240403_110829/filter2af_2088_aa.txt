作者： [Hcamael@知道创宇404实验室](http://0x48.pw)  
发布时间：2017-07-25
fastbin相关的堆知识我一年前就学过了，但是都没写啥记录文档，又咸鱼了好长一段时间，要捡回来这块的知识，又重新开始学习了一遍，这篇博文中记录下我对fastbin的个人理解。
#### 基础知识研究
当使用malloc函数第一次向系统申请小于128kb的内存时，会通过sys_brk申请132kb的内存，这块内存就称为堆。
写个测试代码，对着测试代码进行分析(64位系统)：
    # test.c
    # gcc test.c -o test
    #include 
    #include 
    int main(void)
    {
        char *q;
        char *p;
        int x;
        char input[3];
        while(1) {
            read(0,input,3);
            x = atoi(input);
            q = (char *)malloc(x);
            read(0,input,3);
            x = atoi(input);
            p = (char *)malloc(x);
            free(q);
            free(p);
        }
        return 0;
    }
然后使用gdb进行调试(使用peda和libheap插件，这两个都可以在github上搜到)，当第一次调用malloc(0x10)之后，查看内存信息：
    gdb-peda$ vmmap
    ....
    0x00602000         0x00623000         rw-p  [heap]
    ....
可以看到堆的大小为132kb
先来说下基础概念：
fast
chunk表示正在使用的长度在`32-160`(32位系统是`16-80`)的堆块，而fastbin表示长度在`32-180`范围内的已经释放的堆块
我们可以看源码中的定义：
    1570    /* The maximum fastbin request size we support */
    1571    #define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)
其中`SIZE_SZ`根据操作系统决定，32位系统为4, 64位系统为8
所以之后又定义了一个fastbin数组，用来存在fastbin：
    1659      /* Fastbins */
    1660      mfastbinptr fastbinsY[NFASTBINS];
其中`NFASTBINS`是宏定义，一般算出来是10，所以这个数组的长度为10，值为地址，储存fastbin的地址，比如fastbinsY[0]的值为最新释放出来的长度为32的fastbin的地址，fastbin是根据长度存放数组的，所以index=1存放的是48，2->64,
3->80, 4->96, 5->112, 6->128, 7->144, 8->160, 而fastbinsY[9]却用不上，我也不知道为啥.....
但是我却解决了这里的另一个坑，如果我们进行测试，就会发现我们最大malloc(120)，size=128的chunk才是fast
chunk，free后可以放到fastbinsY[6]中去，但是如果我们malloc(128)，free后却放到了unsortbin中去，也就是说index=7
or 8也是用不上的，这里我们看代码:
    729 #ifndef DEFAULT_MXFAST
    730 #define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)
    731 #endif
这里代码还定义了默认fast的大小为128(32位的为64)，而这个值我们是可以修改的，详情见：
           M_MXFAST (since glibc 2.3)
                  Set the upper limit for memory allocation requests that are
                  satisfied using "fastbins".  (The measurement unit for this
                  parameter is bytes.)  Fastbins are storage areas that hold
                  deallocated blocks of memory of the same size without merging
                  adjacent free blocks.  Subsequent reallocation of blocks of
                  the same size can be handled very quickly by allocating from
                  the fastbin, although memory fragmentation and the overall
                  memory footprint of the program can increase.
                  The default value for this parameter is 64*sizeof(size_t)/4
                  (i.e., 64 on 32-bit architectures).  The range for this
                  parameter is 0 to 80*sizeof(size_t)/4.  Setting M_MXFAST to 0
                  disables the use of fastbins.
所以默认情况下，fastbin数组的最后3个是不会存储数据的
了解了长度的问题后来说说chunk和bin的问题
一个在使用中的堆就是chunk，当我们free了这个chunk后，就会放入相应的bin中，也就是说当free了fast
chunk，将会把这个chunk存放到fastbin中，如何存放后面说。
我们再来看下面的内容：
    gdb-peda$ heapls
    [!] No gdb frame is currently selected.
               ADDR             SIZE            STATUS
    sbrk_base  0x602000
    chunk      0x602000         0x20            (inuse)
    chunk      0x602020         0x20fe0         (top)
    sbrk_end   0x623000
    gdb-peda$ x/16gx 0x602000
    0x602000:   0x0000000000000000  0x0000000000000021
    0x602010:   0x0000000000000000  0x0000000000000000
    0x602020:   0x0000000000000000  0x0000000000020fe0
还有一个chunk名叫top chunk，这么说吧，在使用的chunk + bin + top chunk的大小就为132kb，看上面的fast
chunk的size=0x20加上top chunk的size=0x20fe0的和为0x21000，也就是sys_brk申请下来132kb的堆大小。
三者之间的逻辑是这样的(默认64位系统，之后都默认了)，首先调用malloc(0x10)，首先去判断fastbinsY[0]是否为空，如果存在一个地址，然后去检测一些有效性啥的，比如size是否为0x20(size
>> 3 fd`
如果fastbinsY[0]=0的话，则去判断top chunk的大小是否够，如果够就从top chunk中取出，操作大概是这样的:
    top->size -= 32
    *(top+32) = top->size
    top->size = 0x21
    ret = top + 16
    top = top + 32
    return ret
然后就是free的操作了
PS: 此文只讲fastbin
    p = malloc(16)
    free(p) ->
    p->fd = fastbinsY[0]
    fastbinsY[0] = p
很简单，fastbin是一个单链表，从上面可以看出这是一个LIFO( _Last in, first out_ 后进先出)
当初我还想了半天为啥使用LIFO，为啥新free的chunk不直接插到屁股，因为我们只有一个fastbinsY[0]指针，如果直接插到屁股的话每次都要迭代到最后一个chunk然后把它的fd赋值为新的chunk的地址，而使用LIFO，我们只需要修改fastbinsY[0]指针的值和新的chunk的值，花费在fastbin链有很多的时候肯定是更少的
#### 结构
原理应该差不多了，然后讲讲结构
我们可以使用libheap来查看现在堆的一些信息：
    gdb-peda$ heap
    Arena(s) found:
      arena @ 0x7ffff7dd1b20
    gdb-peda$ fastbins
    [!] No gdb frame is currently selected.
    fastbins
    [ fb 0 ] 0x7ffff7dd1b28  -> [ 0x0 ] 
    [ fb 1 ] 0x7ffff7dd1b30  -> [ 0x0 ] 
    [ fb 2 ] 0x7ffff7dd1b38  -> [ 0x0 ] 
    [ fb 3 ] 0x7ffff7dd1b40  -> [ 0x0 ] 
    [ fb 4 ] 0x7ffff7dd1b48  -> [ 0x0 ] 
    [ fb 5 ] 0x7ffff7dd1b50  -> [ 0x0 ] 
    [ fb 6 ] 0x7ffff7dd1b58  -> [ 0x0 ] 
    [ fb 7 ] 0x7ffff7dd1b60  -> [ 0x0 ] 
    [ fb 8 ] 0x7ffff7dd1b68  -> [ 0x0 ] 
    [ fb 9 ] 0x7ffff7dd1b70  -> [ 0x0 ] 
首先是arena是什么，这个地址表示的是啥？这个我没找到相关的文章，我是自己解决的，首先我使用`vmmap`先查看这个地址属于哪:
    gdb-peda$ vmmap
    Start              End                Perm  Name
    ......
    0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p  /lib/x86_64-linux-gnu/libc-2.23.so
    ......
然后发现这个地址是属于libc的，然后猜测应该是malloc相关的，再加上发现arena+8是fastbin，然后我在malloc.c中找到了一个结构体：
    1651    struct malloc_state
    1652    {
    1653      /* Serialize access.  */
    1654      __libc_lock_define (, mutex);
    1655    
    1656      /* Flags (formerly in max_fast).  */
    1657      int flags;
    1658    
    1659      /* Fastbins */
    1660      mfastbinptr fastbinsY[NFASTBINS];
    1661    
    1662      /* Base of the topmost chunk -- not otherwise kept in a bin */
    1663      mchunkptr top;
    1664    
    1665      /* The remainder from the most recent split of a small request */
    1666      mchunkptr last_remainder;
    1667    
    1668      /* Normal bins packed as described above */
    1669      mchunkptr bins[NBINS * 2 - 2];
    1670    
    1671      /* Bitmap of bins */
    1672      unsigned int binmap[BINMAPSIZE];
    1673    
    1674      /* Linked list */
    1675      struct malloc_state *next;
    1676    
    1677      /* Linked list for free arenas.  Access to this field is serialized
    1678         by free_list_lock in arena.c.  */
    1679      struct malloc_state *next_free;
    1680    
    1681      /* Number of threads attached to this arena.  0 if the arena is on
    1682         the free list.  Access to this field is serialized by
    1683         free_list_lock in arena.c.  */
    1684      INTERNAL_SIZE_T attached_threads;
    1685    
    1686      /* Memory allocated from the system in this arena.  */
    1687      INTERNAL_SIZE_T system_mem;
    1688      INTERNAL_SIZE_T max_system_mem;
    1689    };
然后发现：
    gdb-peda$ x/16gx 0x7ffff7dd1b20
    0x7ffff7dd1b20 :    0x0000000000000000  0x0000000000602000
    0x7ffff7dd1b30 : 0x0000000000000000  0x0000000000000000
    0x7ffff7dd1b40 : 0x0000000000000000  0x0000000000000000
    0x7ffff7dd1b50 : 0x0000000000000000  0x0000000000000000
    0x7ffff7dd1b60 : 0x0000000000000000  0x0000000000000000
    0x7ffff7dd1b70 : 0x0000000000000000  0x0000000000602040
`0x7ffff7dd1b78`的值为top chunk的地址然后就知道我应该是没找错了，这块区域就是各类bin的链首，其他的small, large,
unsort bin之类的都是存储在`mchunkptr bins[NBINS * 2 - 2];`之中，找到一篇文章中是有介绍的:
>   * Bin 1 – Unsorted bin
>   * Bin 2 to Bin 63 – Small bin
>   * Bin 64 to Bin 126 – Large bin
>
这些以后研究，继续看fastbin
我们再来看chunk的结构，定义在malloc.c中：
    1040    struct malloc_chunk {
    1041    
    1042      INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
    1043      INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
    1044    
    1045      struct malloc_chunk* fd;         /* double links -- used only if free. */
    1046      struct malloc_chunk* bk;
    1047    
    1048      /* Only used for large blocks: pointer to next larger size.  */
    1049      struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
    1050      struct malloc_chunk* bk_nextsize;
    1051    };
    ......
    1068        An allocated chunk looks like this:
    1069    
    1070    
    1071        chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1072                |             Size of previous chunk, if unallocated (P clear)  |
    1073                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1074                |             Size of chunk, in bytes                     |A|M|P|
    1075          mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1076                |             User data starts here...                          .
    1077                .                                                               .
    1078                .             (malloc_usable_size() bytes)                      .
    1079                .                                                               |
    1080    nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1081                |             (size of chunk, but used for application data)    |
    1082                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1083                |             Size of next chunk, in bytes                |A|0|1|
    1084                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ......
    1094        Free chunks are stored in circular doubly-linked lists, and look like this:
    1095    
    1096        chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1097                |             Size of previous chunk, if unallocated (P clear)  |
    1098                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1099        `head:' |             Size of chunk, in bytes                     |A|0|P|
    1100          mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1101                |             Forward pointer to next chunk in list             |
    1102                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1103                |             Back pointer to previous chunk in list            |
    1104                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1105                |             Unused space (may be 0 bytes long)                .
    1106                .                                                               .
    1107                .                                                               |
    1108    nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1109        `foot:' |             Size of chunk, in bytes                           |
    1110                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    1111                |             Size of next chunk, in bytes                |A|0|0|
    1112                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
上面这么代码和注释这么多是针对整体的chunk来说的，而我这篇文章中是针对fast chunk和fast bin进行研究.
对于fast
chunk其实就一个有用的字段，就是size，表示当前chunk的大小，然后size的低三bit位是标志位，为什么size的最后三bit能是标志位，因为在32位系统中，chunk永远是8的倍数，然后写代码的人秉持了不浪费任何一bit的原则，这最后3bit就被哪来做标志位了，不过在64位系统中，chunk是16的倍数，所以讲道理，在64位系统中size的低4bit都是能拿来做标志位的，但是我猜测，应该是64位系统和32位相比没有多啥需要标志位的功能，所以任然是使用低三bit做标志位。
然后在做Pwn的时候就标志位P有用吧，表示上一个chunk是否在使用中，不过在fast
chunk/bin中P标志位永远是1，free操作并不会修改fastbin的标志位，所以pre_size，前一个不在使用中的chunk的大小，因为P=1，所以在fastbin中这个字段可以说是没用的，其实还是有用的，后面说。
因为chunk总是16的倍数，所以当我们malloc(0-16)的时候，得到的chunk的size就是存放数据的16byte加上chunk
header，也就是8byte的pre_size，和8byte的size，所以malloc得到的最小的chunk大小为32byte。
但是当我测试的时候发现，我malloc(0-24)得到的chunk大小都为0x20,
当我malloc(25-40)得到的chunk大小为0x30，按我的理解，这是因为malloc的作者是告诉你可以把pre_size利用起来
当我malloc(24)的时候，得到size=0x20的chunk，其中有0x10的chunk
header，然后有0x10的地方存放data，然后仔细研究会发现，还有8byte的下一个chunk的pre_size可以存放数据，因为当前chunk肯定是使用中的，所以下一个chunk的标志位P=1，pre_size没用，所以可以被上一个chunk利用，当free的时候，再往下一个chunk的pre_size设置值，所以按作者的想法应该是这样能达到最大利用率。
然后就是fastbin了，其实fastbin和fast
chunk比，就是多了一个fd，在fastbin单链表中起作用，前面已经说了。因为是单链表，所以bk没用。
写了这么多，个人感觉应该是写清楚了，就留了一个坑吧——fastbinsY[9]有啥作用？
#### 在Pwn题中fastbin的利用
    # mistake.c
    # gcc mistake.c -z execstack -o mistake
    #include 
    #include 
    typedef struct chunk{
        char buffer[0x10];
        int len;
    }chunk;
    chunk* list[0x30];
    int chunk_number;
    void menu()
    {
        write(1,"1.create\n",9);
        write(1,"2.read\n",7);