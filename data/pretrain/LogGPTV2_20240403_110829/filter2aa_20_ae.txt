POST 方法
此处显示的是从图 3-9 的请求消息中摘取的一些重要内容。
POST /31/31-003.php HTTP/1.1
Referer: http://example.jp/31/31-002.php
Content-Type: application/x-www-form-urlencoded
Content-Length: 70
Host: example.jp
                                                                消息体
 ┐
name=%E5%BE%B3%E4%B8%B8%E6%B5%A9&mail=PI:EMAIL&gender=%E7%94%B7┘
请求行开头处的方法变成了 POST。与 GET 不同的是，空行下面所填写的值也被发送了。而这部分内容就被称为消息体（Message Body）。
消息体
通过 POST 方法发送的请求消息中包含消息体。与响应消息一样，消息头和消息体用空行相隔。要通过 POST 方法发送的值被放在请求的消息体中。
与 POST 发送值相关的消息头为 Content-Length 和 Content-Type。
Content-Length 为消息体的字节数。
Content-Type 为发送值的 MIME 类型，可通过 HTML 的 form 元素设置。默认为 application/x-www-form-unlencoded。这种类型的格式为，“名称 = 值”的组合通过 & 相连，其中，名称和值都经过了百分号编码（Percent-Encoding）。
百分号编码
中文和特殊符号等不能直接用于 URL，而如果要将它们用在 URL 上的话就需要经过百分号编码。百分号编码是将字符以字节为单位转换成 %xx 的形式。xx 为该字节的十六进制写法。例如，将图 3-8 中输入的文字“德”进行 UTF-8 编码，可得到 E5 BE B3 字节列，百分号编码后即为 %E5%BE%B3。
根据百分号编码的规则，空格应为 %20，但在 application/x-www-form-unlencoded 的情况下，空格则被特殊处理为 +3
 。所以，将“I'm a programmer”进行百分号编码的话，结果就为 I%27m+a+programmer（撇号变成了 %27）。
Referer
请求消息中有时含有 Referer 头信息。它能告诉我们当前请求是从哪个页面链接过来的，值就是那个页面的 URL。除了通过 form 元素发送的请求，a 元素生成的链接或 img 元素的图像等也会产生 Referer 头信息。
Referer 头信息有时是提升安全性的帮手，有时却能成为问题之源。
Referer 有益的一面体现在，当我们为了确保安全性而主动检验 Referer 头信息时，通过查看 Referer，能够确认应用程序的跳转是否跟预期一样。但是，同其他头信息一样，Referer 也能由访问者本人通过 Fiddler 之类的工具修改，或者被浏览器插件和其他安全方面的软件修改或删除，所以未必会正确显示链接的来源 4
 。
当 URL 中包含敏感信息时，Referer 就可能会引发安全问题。比如，URL 中包含的会话 ID 通过 Referer 泄漏给外界，从而使自己的身份被他人恶意冒名顶替，就是一个典型的案例。具体情况将在 4.6.3 节详述。
要点
  URL 中包含重要信息时，就有被 Referer 头信息泄密的风险。
GET 和 POST 的使用区别
如何区别使用 GET 方法和 POST 方法呢？
HTTP 1.1 协议的规范文档 RFC26165
 的第 9 章和第 15 章中，记载了区别使用两者的注意点。
GET 方法仅用于查阅（获取资源）
GET 方法被认为没有副作用
发送敏感数据时应使用 POST 方法
这里出现了“副作用”这个概念。副作用是指，除了获取资源（内容）以外的其他操作。比如，追加 / 更新 / 删除服务器端的数据、购买商品、注册 / 删除用户等操作。换言之，更新类的页面必须使用 POST 方法。
另外，GET 方法使用的是 URL 后紧跟查询字符串的形式来传递参数，但由于浏览器和服务器能够处理的 URL 长度是有限的 6
 ，所以，当传递的信息量很大时，使用 POST 方法更安全。
敏感信息应使用 POST 发送，这是因为 GET 方法有下列风险。
URL 中指定的参数经由 Referer 泄漏
URL 中指定的参数残留在访问日志（Access Log）中
为解决以上问题，当所发送的请求符合以下任一条件时就应使用 POST 方法，都不符合时才使用 GET 方法。
请求中包含数据更新等副作用时
发送敏感信息时
发送的信息量很多时
hidden 参数能够被更改
继续刚才的输入表单（图 3-8），点击“确认”按钮后浏览器的页面如图 3-10 所示。
图 3-10 确认画面
虽然在页面上看不到，但用户在前页面输入的值会以 hidden 参数的形式在 HTML 源代码中记录下来。
与 FTP 协议或 telnet 协议不同，HTTP 协议无法记忆客户端的当前状态。这种特性被称为 HTTP 的无状态性 7
 。因此，状态的记忆需要借助响应（HTML）中的 hidden 参数。
在页面上点击“注册”按钮后，hidden 参数将被发送给 Web 服务器。此时，在向服务器发送数据之前，我们可以尝试使用 Fiddler 改变 hidden 参数的值。
首先，在 Fiddler 的 Rules 菜单中，选择“Automatic Breakpoints”-“Before Requests”（图 3-11）。
图 3-11 在 Rules 菜单中选择“Automatic Breakpoints”-“Before Requests”
此状态下，点击“注册”按钮后，Fiddler 的界面就变成了图 3-12 所示的情形（选择右侧上方的“WebForms”）。现在，Fiddler 截获到了浏览器的请求消息，并且还未将其传送给服务器。
图 3-12 Fiddler 接收浏览器的请求消息
编辑方框中的内容，如图 3-13 所示。
图 3-13 变更浏览器的请求消息
接下来，点击“Run to Completion”按钮，变更后的请求就会被发送给服务器。此时，IE 上会显示图 3-14 的页面（虽然显示了“成功注册”的消息，但事实上并没有进行注册处理）。
图 3-14 浏览器显示了变更后的信息
以上试验说明，在 HTTP 层面，文本框、单选框的选择项，以及 hidden 参数都被同等对待，在浏览器上无法改变的值（如单选框的选择项和 hidden 参数）也能够被更改。
要点
  浏览器发送的值都能够被变更
通过实际体验 hidden 参数的变更可以得知，一旦处理 hidden 参数的地方存在安全隐患，就会有被 Fiddler 等代理工具实施篡改和攻击的风险。
将 hidden 参数的更改比作对话
接下来让我们以对话的形式来再现一下刚才变更 hidden 参数的情形。
顾客与店员的对话
顾客：我想要申请会员。
店员：请提供您的姓名、邮箱地址、性别（男或女）。
顾客：姓名为德丸浩，邮箱地址为 PI:EMAIL，性别为男。
店员：好的。姓名为德丸浩，邮箱地址为 PI:EMAIL，性别为男。请您确认。
顾客：不对。姓名为德丸玛利亚，邮箱地址为 PI:EMAIL，性别为女。请注册。
店员：姓名为德丸玛利亚，邮箱地址为 PI:EMAIL，性别为女。您的会员身份已注册完毕。
hidden 参数的优点
前面介绍了 hidden 参数的一些隐患，那么 hidden 参数有什么优点呢？虽然 hidden 参数的值能被用户自己改写，但在面对信息泄漏以及被第三方篡改等危险时，hidden 参数却坚不可摧。
与 hidden 参数形成鲜明对比的是后面将要介绍的 Cookie 和会话（Session）变量。Cookie 和会话变量的缺点是容易招致会话固定攻击。尤其是在尚未登录、并且又使用了地域型域名的情况下，受到 Cookie Monster Bug 的影响，根本就没有有效的办法来防止会话变量的泄漏（参考 4.6.4 节）。
因此，像认证和授权信息这样需谨防被用户自己更改的信息，应当保存在会话变量中（参考 5.1 节和 5.3 节）。而除此以外的信息，则首先应考虑能否保存在 hidden 参数中。特别是在登录前的状态下，由于不存在与认证、授权相关的信息，因此，原则上要避免使用会话变量，而是应该使用 hidden 参数，从而来防止信息泄漏等。
3
 百分号编码属于 URL（URI）的规范，application/x-www-form-unlencoded 属于 HTML 的规范，所以两者存在细微差别。
4
 关于使用 Fiddler 来改变参数，后面讲 hidden 参数时会进行详述。
5
http://tools.ietf.org/html/rfc2616
6
 虽然 RFC2616、RFC1738 及 RFC3986 中并未规定 URL 的长度上限，但各个浏览器都存在上限值。
7
 与此相反，像 FTP 和 telnet 这种能够记忆当前状态的特性，叫作有状态性。
无状态的 HTTP 认证
HTTP 支持认证功能。HTTP 认证根据实现方式可细分为 Basic 认证、NTLM 认证和 Digest 认证等。正如 HTTP 是无状态的协议一样，HTTP 认证同样也是无状态的。
下面让我们看一下 HTTP 认证中最简单的 Basic 认证。
体验 Basic 认证
Basic 认证的概要如图 3-15 所示。Basic 认证下，当浏览器请求一个需要认证的网页时，服务器会先向浏览器返回“401 Unauthorized（未认证）”状态码。浏览器收到此状态码后，会显示要求输入 ID 和密码的画面，然后再将输入的 ID 和密码添加到请求信息中，再次向服务器发送。
图 3-15 Basic 认证的概要
Basic 认证大多通过设置 Web 服务器来实现，而也能通过 PHP 来编写代码。以下为使用 PHP 的 Basic 认证的例子。
代码清单 /31/31-010.php
已通过认证 
用户名 :
密码 : 
以上代码仅用于试验，所以 ID 和密码输入任意值都能通过认证，而 ID 或密码任意一方为空白就会认证失败。认证失败时，按照 Basic 认证的规定会输出以下头信息。
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Basic realm="Basic Authentication Sample"
如果要在虚拟机上运行，可以点击 /31/ 菜单的“31-010：Basic 认证试验”。第一次请求时浏览器没有发送 ID 和密码，所以 31-010.php 返回了 401 状态码。这时，HTTP 信息的截图如图 3-16 所示。浏览器收到 401 状态码后，就会显示要求输入 Basic 认证的 ID 和密码的对话框（图 3-17）。
图 3-16 返回 401 状态码的 HTTP 消息
图 3-17 Basic 认证的 ID 和密码输入对话框
这次我们来尝试一下输入 ID“user1”和密码“pass1”，输入完毕后点击 OK 按钮，HTTP 请求消息再次被发送。这次会附带以下的 Authorization 头信息。
Authorization: Basic dXNlcjE6cGFzczE=
Basic 后面的字符串内容，是 ID 和密码以冒号相隔组成的字符串、再经过 Base64 编码后的结果。可以使用 Fiddler 的 Encoder 功能进行解码确认。在 Fiddler 的 Tools 菜单中选择“Text Encode/Decode”，就会显示出 TextWizard 对话框，然后将 dXNlcjE6cFGzczE= 复制进去，点击对话框左边的“From Base64”单选按钮（图 3-18），就能在画面中央的文本框中看到“user1:pass1”字符串。
图 3-18 使用 Fiddler 附带的 TextWizard 来解码 Base64
而这时，浏览器上显示的就是下图所示的画面。可以看出，PHP 脚本成功读取了 Basic 认证的 ID 和密码。
图 3-19 认证成功
Basic 认证成功一次以后，再向 http://example.jp/31/
 下面的目录发送请求时，浏览器就会自动附带 Authorization 消息头。因此，认证对话框只在最初的时候显示一次，看上去认证状态似乎被记住了，但实际上每次请求时都会发送 ID 和密码，认证状态并没有被保存在任何地方。换言之，Basic 认证也是无状态的。而正是因为 Basic 认证的无状态性，所以也就不存在注销（Logout）的概念。
Basic 认证可以被比喻为银行业务柜台的对话。
顾客：请帮我查一下账户余额。
柜员：请提供您的银行卡号和密码。
顾客：请帮我查一下账户余额。卡号为 12345，密码为 9876。
柜员：余额为 5 万元。
顾客：请向卡号 23456 转账 3 万元。卡号为 12345，密码为 9876。
柜员：转账完毕。
顾客和柜员之间的交流是无状态的。无关上下文，顾客每一次都要提供所有必要的信息。因此，就算一开始就进行转账也能正常处理。
专栏：认证与授权
至此我们未经特别说明就一直使用着“认证”（Authentication）这个术语。认证是指，通过一些方法手段来确认操作者确实是其本人。Web 应用常见的认证方法除了 Basic 认证，还有通过 HTML 表单使用户填写 ID 和密码的表单认证，以及使用 SSL 客户端证书的客户端认证等。
与认证相对的术语是“授权”（Authorization）。授权是指，授予已经通过认证的用户一些权限。具体表现为，让用户能够对数据进行阅览 / 更新 / 删除、在线转账、在线购物等。
由于页面上并不会特意区分认证与授权，所以用户很容易将两者混为一谈。Web 应用的普遍流程为，在用户输入 ID 和密码通过认证以后，立刻就会被授予一些权限。但是，在开发应用及考虑安全性时，最好能明确认证与授权这两者的区别，并养成区别使用的习惯。
关于认证和授权，5.1 节和 5.3 节会分别进行详述。
Cookie 与会话管理
前面我们已经提到，由于 HTTP 协议的无状态性，服务器端不能保存客户端的状态。但是，在应用程序中，保持客户端的状态却是相当常见的需求。
比如，在线购物网站中的“购物车”就是一个典型的案例。购物车记住了用户在哪些商品上点击了“购买”按钮。
另外，记住用户登录后的认证状态也是一种常见的需求。虽然使用 HTTP 认证就能使浏览器记住 ID 和密码，但不使用 HTTP 认证时，记忆认证状态的任务就落在了服务器身上。而像这种记忆应用程序状态的功能就叫作“会话管理”。
为了实现会话管理，HTTP 引入了名为 Cookie 的机制。Cookie 相当于服务器下达给浏览器的命令，让其记住发送给它的“名称 = 变量”这种格式的值。由于 Cookie 会被用于实现会话管理，因此，下面就让我们结合 PHP 中的会话管理来对其进行说明。
下面的示例应用是用户认证和用户信息显示的简化版。由以下 3 个页面构成：ID 和密码输入页面（31-020.php）、ID 和密码认证页面（31-021.php）、个人信息（ID）显示页面（31-022.php）。在虚拟机上执行时，可在 /31/ 菜单中点击“31-020: 使用 Cookie 的会话管理”。
代码清单 /31/31-020.php
 请登录 