states larger than k will not be inlined. To retain accuracy,
the hybrid model must transform the source program to add
guards to calls of non-inlined functions, in the same manner
as the Dyck model. Thus, assuming that the program con-
tains a call to f() (and that this is the 23rd call site to that
function) and the NFA for f is larger than k, the following
program transformation is applied:
f();
=⇒
pre("f",23);
f();
post("f",23);
Clearly, k has an impact on performance: at the extreme if
k is 1 then hIAM would degenerate into an instance of the
Dyck model.
6. Deterministic Markers
A high degree of non-determinism results in large fan-
outs for the automaton states. A larger fan-out translates
to greater runtime overhead for the monitoring algorithm
which has to check every successor state for matching tran-
sition symbols. Furthermore, although the monitoring algo-
rithm starts with a single current state (entry of main), non-
determinism and the existence of several successor states
for the same transition symbol quickly introduce ambigu-
ity about the current state. This causes the monitoring al-
gorithm to maintain a set of current states and check suc-
cessors for each of them at runtime. The overhead intro-
duced because of this can be signiﬁcant for a program like
gnatsd which has a high average fan-out and a low aver-
age unique transition symbol per state (see Figure 9). We
introduce the concept of deterministic markers as a solution
to reduce such overhead.
Deterministic markers are unique transition symbols intro-
duced in the program text to reduce the search space (cur-
rent states and successors) of the runtime monitoring algo-
rithm. Conceptually, they are similar to the renaming and
null call insertion techniques described in [3, 4, 1]. The
difference is that they are not needed for determining the
calling context (inlining takes care of that) but for disam-
biguating the current state (program counter) and reducing
the fan-out of frequently occurring high fan-out states (such
as a library function call in a loop followed by severe non-
determinism).
Currently, we use such markers only for gnatsd along the
paths exercised by the workloads. Eleven sites were man-
ually identiﬁed and null library calls were introduced. The
performance gains were substantial for the minimal effort
involved in identifying instrumentation sites. It is reason-
able to assume that the selection of instrumentation sites can
be automated at model construction time. This can be done
by detecting high fan-out and high ambiguity states in the -
free IAM and by maintaining a mapping of the model states
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
Program
cat
htzipd
lhttpd
gnatsd
Workload
Concatenate 38 ﬁles totaling 500 MB to a ﬁle
Service 500 client requests simultaneously, transferring 152.2 MB of data in total
Service a single client request, transferring 151.7 MB of data
Service 2000 commands requested by a client
Table 3. Workloads.
Program Unmonitored
cat
58.95
13.22
htzipd
29.17
lhttpd
gnatsd
35.61
Base Monitored %
59.14
0
8.3
13.35
0.9
28.82
36.29
0
59.04
14.46
29.08
34.36
Table 4. Program runtime in seconds.
Program Code
cat
1,232
1,840
htzipd
1,888
lhttpd
gnatsd
1,992
Unoptimized
Automaton
3.44
132.3
5.9
32,243
Compacted
Automaton
0.8
77.1
4.3
8,966
%
0.1
4.1
0.2
450
%
0.2
7.1
0.3
1,618
Table 5. Memory usage in KB.
% Runtime Overhead
% Memory Overhead
Program Dyck VPStatic
32
cat
htzipd
97
56
135
IAM Dyck VPStatic
194
183
0
8.3
49
38
IAM
0.2
7.1
Table 6. Comparing models.
to program points to help identify instrumentation sites in
program text. Automating the selection of instrumentation
sites and evaluating its impact on model size is part of future
work.
7. Evaluation
Program models for on-the-ﬂy intrusion detection can be
evaluated on two criteria: accuracy and efﬁciency. Greater
accuracy makes these models useful by reducing false neg-
atives and increased efﬁciency makes them usable by re-
ducing time and space overheads. The IAM model has a
runtime efﬁciency equal to that of a NFA model, which is
the most efﬁcient model possible.
We demonstrate the efﬁciency of our model by testing it
with the four real-world programs shown in Table 1. For
comparison purposes, we have chosen programs used in the
literature. Tests were run on a Sun V100 550MHz Ultra-
SPARC II with 256MB of RAM and running Solaris 9. Ta-
ble 3 shows the workloads used in testing. Table 4 shows
the runtime overhead for our model. Runtime is measured
using the UNIX time utility. Time measurements are cal-
culated over several runs. The base runtime represents the
cost of library interposition and the monitored runtime in-
cludes the cost of operating the automaton. The monitored
runtime does not include the setup time needed to load the
program model from the disk (except in the case of cat).
The difference between the base runtime and the monitored
runtime represents the model operation overhead. The per-
centages compare this overhead against the base runtime.
We attribute the slight variations between expected times
(because of interposition and monitoring) and actual times
to measurement noise. Except for htzipd, the runtime
overhead for the programs is negligible. We are conﬁdent
that the runtime overhead for htzipd can be reduced by
using deterministic markers. Note that our solution scales
efﬁciently to gnatsd which is a 32K program.
Table 5 shows the memory usage of the programs. The
unmonitored memory usage of the code is obtained using
the pmap command, which displays information about the
address space of a process. The percentages compare the
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
automaton overhead against the unmonitored memory us-
age of the code. The automaton overhead is signiﬁcant for
gnatsd when compared to others. But this can be reduced
by as much as 72.19% by including -transitions and delta
successor states as described in Section 5. Also, note that
the same automaton can be used if multiple instances of the
program are running at the same time. Table 6 compares the
runtime and memory overheads of the Dyck, VPStatic, and
IAM models for common test programs. The IAM model is
clearly more time and space efﬁcient for these programs.
7.1. Discussion
In this paper, we demonstrated the efﬁciency of the IAM
model by monitoring library calls instead of system calls as
done in previous work. This choice is motivated by prag-
matic considerations. Analyzing the source code of C li-
braries is a challenging task [17] (other approaches typically
analyze statically-linked binaries [3, 4, 1]). The static anal-
ysis infrastructure used in our prototype was simply not able
to handle these libraries; we plan to address this problem in
future work. But, we also believe that switching to system
calls will not affect our results. Library functions give a
ﬁner grained program model as they are usually more fre-
quent. It is thus likely that overheads reported here are an
upper bound on the costs of the approach. However, from
an effectiveness perspective, monitoring the library inter-
face alone is not sufﬁcient for intrusion detection.
There are several approaches to handling recursion. The
simplest solution is of course to allow imprecision at re-
cursion points in the model based on the assumption that
the actual loss of accuracy is small. The implication of this
to mimicry attacks has to be considered. Furthermore, re-
cursion is only a problem if there are library calls in the
unwinding phase (i.e.
if a library call is reachable in the
control ﬂow graph between the recursive call site and the
function’s exit), if not the attacker would gain absolutely
nothing by following impossible paths. Thus, if a function
g() is recursive and has library calls in an unwinding path,
its calls can be transformed into guarded calls in the hybrid
model. However, this can have an impact on the perfor-
mance (which is why the Dyck model does not instrument
recursive calls). None of the existing approaches, ours in-
cluded, demonstrate an efﬁcient way of handling recursion.
Our implementation has targeted C programs and extending
it to object-oriented languages with dynamic binding raises
concerns for accuracy and scalability. This is because, in
C++ for example, virtual methods are invoked through func-
tion pointers and thus we would have to inline all possible
implementations of the method at every call site. Static pro-
gram analysis techniques can help. Experience with Java
programs suggests that upwards from 90% of call sites can
be devirtualized [15], i.e. it is possible to determine unam-
biguously which implementation will be invoked.
8. Limitations
The existing approaches to anomaly detection address only
a part of the IDS problem: accurate and efﬁcient monitoring
of system call sequences. This is the simplest, yet impor-
tant, concern for intrusion detection because an attacker has
to use system calls to interact with the underlying operating
system to cause harm (with the possible exception of DoS
attacks). By accurately modeling the acceptable sequences
of system calls, the models limit the attacker to only those
expected system call sequences. However, there are several
limitations that diminish the precision of these models.
Path Sensitivity. All the proposed models, ours included,
treat branches in a conservative manner without evaluat-
ing the branch predicates because it needs more sophisti-
cated static and dynamic program analysis. Such a path-
insensitive modeling can be exploited by an attacker as il-
lustrated in [1].
Granularity of Events. Granularity of events is a trou-
blesome issue. Ideally, an IDS would monitor every single
statement executed by the target program and validate each
machine instruction. Clearly this is not possible and exist-
ing models are approximations at different levels of gran-
ularity. The coarser the approximation, the easier it is to
mount a mimicry attack. So for example, restricting the ob-
servable events to system calls, means that library function
calls are not captured in the model. Yet, library functions
are common entry points for attackers because of their sus-
ceptibility to buffer overﬂow and format string vulnerabili-
ties. Some vulnerable library functions such as the string
family of functions do not make any system calls. Thus, a
coarse model may not be able to observe the deviant be-
havior at the library interface and would have to rely on an
out-of-sequence system call to detect an intrusion.
Library interposition techniques, such as the one used in this
paper, allow to monitor the library functions called by a tar-
get program. However, an IDS based solely on library inter-
position will not be effective because if an attacker manages
to exploit a vulnerability without setting off the IDS then he
can further evade the IDS by directly issuing system calls
in the “attack code.” Therefore, coupling library interposi-
tion with kernel-level system call interposition is necessary.
Such a combined IDS appears feasible, it requires two su-
pervisors that must match up; one supervisor will monitor
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
library calls and the other system calls. A single program
model can be used for both. A detailed discussion of this
issue is beyond the scope of this paper.
Data ﬂow Analysis. Data ﬂow support is another require-
ment for more robust IDSs. It is well documented [17, 4]
that even a naive approach that incorporates data ﬂow by
looking at arguments with constant values can dramatically
improve the accuracy of models. To protect against mimicry
attacks, it may be necessary to have more powerful predi-
cates about the values of arguments. As an example, con-
sider the case of a call that opens a ﬁle; if the leading part
of the ﬁle name can be determined statically (even though
the full name is constructed dynamically) then an IDS could
prevent attempts to open ﬁles outside of the intended direc-
tory. Such predicates can be obtained by program analysis,
but are likely to increase the runtime costs of monitoring,
which is further reason to keep the costs of the basic pro-
gram model low.
9. Conclusions
We have proposed an efﬁcient and scalable solution to the
problem of constructing conservative approximations of le-
gal program behaviors for the purpose of host-based intru-
sion detection. Our approach based on an inlined automa-
ton model (IAM) is context-sensitive and does not suffer
from false positives. Constructing a basic IAM is simple
and the resulting model is easy to understand. The over-
head of monitoring programs based on an IAM is low and
thus suggests that this technique could be deployed in pro-
duction environments. The IAM construction algorithm has
been shown to scale to a 32K line program with a substantial
space overhead. We then show how to reduce this overhead
with automaton compaction techniques.
Acknowledgments
We thank Barbara Ryder and Atanas Rountev for providing
the PROLANGS Analysis Framework (PAF) used to imple-
ment our prototype and answering our questions. We also
thank the authors of [1] for providing us with the htzipd
source code and answering questions about their work. Fi-
nally, we thank the anonymous referees for their sugges-
tions. This work was supported by sponsors of CERIAS,
which is gratefully acknowledged, and in part by grant NSF
TC #0209083.
References
[1] H. Feng, J. Gifﬁn, Y. Huang, S. Jha, W. Lee, and B. Miller.
Formalizing sensitivity in static analysis for intrusion detec-
tion.
In IEEE Symposium on Security and Privacy, May
2004.
[2] H. Feng, O. Kolesnikov, P. Fogla, W. Lee, and W. Gong.
In IEEE
Anomaly detection using call stack information.
Symposium on Security and Privacy, May 2003.
[3] J. Gifﬁn, S. Jha, and B. Miller. Detecting manipulated re-
In 11th USENIX Security Symposium,
mote call streams.
August 2002.
[4] J. Gifﬁn, S. Jha, and B. Miller. Efﬁcient context-sensitive
intrusion detection. In 11th Annual Network and Distributed
Systems Security Symposium, February 2004.
[5] S. A. Hofmeyr, S. Forrest, and A. Somayaji. Intrusion detec-
tion using sequences of system calls. Journal of Computer
Security, 6(3):151–180, 1998.
[6] J. E. Hopcroft, R. Motwani, and J. D. Ullman.
Introduc-
tion to automata theory, languages, and computation, 2nd
edition. ACM Press, 2001.
[7] A. Jones and Y. Lin. Application intrusion detection us-
ing language library calls. In Proceedings of the 17th An-
nual Computer Security Applications Conference (ACSAC),
2001.
[8] C. Ko, G. Fink, and K. Levitt. Automated detection of vul-
nerabilities in privileged programs by execution monitoring.
In Proceedings of the 10th Annual Computer Security Appli-
cations Conference (ACSAC), 1994.
[9] B. Kuperman and E. H. Spafford. Generation of application
level audit data via library interposition. CERIAS TR 99-11,
COAST Laboratory, Purdue University, Oct. 1998.
[10] T. Lane and C. E. Brodley. Temporal sequence learning and
data reduction for anomaly detection. ACM Transactions on
Information and System Security, 2(3):295–331, 1999.
[11] W. Lee, S. J. Stolfo, and K. W. Mok. A data mining frame-
work for building intrusion detection models. In IEEE Sym-
posium on Security and Privacy, 1999.
[12] R. Sekar, M. Bendre, D. Dhurjati, and P. Bollineni. A fast
automaton-based method for detecting anomalous program
behaviors.
In IEEE Symposium on Security and Privacy,
2001.
[13] K. Tan, K. Killourhy, and R. Maxion. Undermining an
anomaly-based intrusion detection system using common
exploits. In Recent Advances in Intrusion Detection (RAID),
2002.
[14] K. Tan, J. McHugh, and K. Killourhy. Hiding intrusions:
From the abnormal to the normal and beyond. In Fifth Inter-
national Workshop on Information Hiding, 2002.
[15] F. Tip and J. Palsberg. Scalable propagation-based call graph
construction algorithms. In Proceedings of the Conference
on Object-Oriented Programming Languages, Systems and
Applications (OOPSLA), 2000.
[16] D. Wagner. Static Analysis and Computer Security: New
Techniques for Software Assurance. PhD thesis, University
of California, Berkeley, 2000.
[17] D. Wagner and D. Dean. Intrusion detection via static anal-
ysis. In IEEE Symposium on Security and Privacy, 2001.
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
[18] D. Wagner and P. Soto. Mimicry attacks on host based intru-
sion detection systems. In Ninth ACM Conference on Com-
puter and Communications Security, 2002.
[19] A. Wespi, M. Dacier, and H. Debar.
Intrusion detection
using variable-length audit trail patterns. In Third Interna-
tional Workshop on Recent Advances in Intrusion Detection
(RAID), 2000.
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE