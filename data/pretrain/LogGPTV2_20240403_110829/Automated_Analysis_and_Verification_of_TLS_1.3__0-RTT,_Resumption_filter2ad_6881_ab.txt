The server’s Finished message comprises a MAC over
the entire handshake using a handshake key derived from
the DH key shares. Finally, if the client received a request
for authentication, the client either sends its own certiﬁcate
(Certificate) and a signature on the whole handshake
thus far (CertificateVerify), or a blank certiﬁcate
representing no authentication. As in the server’s case, the
client’s Finished is a MAC over the entire handshake
using a handshake key derived from the DH key shares. The
purpose of the Finished messages is to provide integrity
of the handshake as well as key conﬁrmation.
If the client does not supply an appropriate key share
in its ﬁrst ﬂight (it may suggest groups that are unac-
ceptable to the server, for instance), the server transmits
a HelloRetryRequest message in order to entice the
client to change its key share offer. Upon receipt of this
message, the client should send a newly generated key
share. These messages are indicated as dashed arrows
in Figure 2. If no common parameters can be agreed
upon, the server will send a handshake_failure or
insufficient_security alert and the session will be
aborted.
0-RTT. Following the initial handshake in which the
server provides the client with a semi-static (EC)DH
share, the client is able to use this share to encrypt early
data. Figure 3 depicts the 0-RTT handshake. The client’s
EarlyDataIndication value signals a 0-RTT hand-
shake, which the server can choose to ignore (the server
will not process the early data and a 1-RTT handshake will
ensue). Braces of the type ( ) indicate encryption under the
early trafﬁc keys derived from the server’s semi-static key
share and the client’s ephemeral key share.
Figure 1. Key computation hierarchy for draft-10. Image from [49].
Another input to the HKDF is the handshake_hash.
This consists of a hash of all the handshake messages,
including all client and server messages, up to the present
time but excluding the Finished messages. The ﬁnal value
of the handshake_hash is called the session_hash.
As such, the session keys established are cryptographically
bound to both of the shared secrets negotiated, and rely
on both parties having a matching view of the handshake
transcript.
2.2. New handshake modes
Some of the most signiﬁcant changes in TLS 1.3 are due
to the newly introduced handshake mechanisms. Here we
provide a brief overview of these different modes, starting
with a description of the regular, initial handshake.
Initial (EC)DHE handshake. The solid message ﬂows in
Figure 2 represent this handshake. Every protocol message
followed by an asterisk can be omitted if only unilateral
(server) authentication is required. Braces of the type { }
indicate encryption under the handshake trafﬁc keys, whereas
braces of the type [ ] indicate encryption under the application
trafﬁc keys.
including a client nonce,
A client sends a server an offer of cryptographic pa-
rameters,
that are later used
to establish session keys (ClientHello), and freshly
generated Difﬁe-Hellman (DH) key shares along with
the associated set of groups (ClientKeyShare). The
server responds with its choice of cryptographic parame-
ters, including a server nonce and a selected group from
among those offered by the client (ServerHello). The
server also sends its own freshly generated DH key share
(ServerKeyShare), extensions not used for key establish-
ment (EncryptedExtensions) and an optional semi-
static (EC)DH key share to be used in later handshakes
(ServerConfiguration). Also included in the server’s
ﬁrst ﬂight are its public key certiﬁcate for authentication
purposes (Certificate), an optional request for the
client’s certiﬁcate in the case that mutual authentication
473473
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:43 UTC from IEEE Xplore.  Restrictions apply. 
C
S
ClientHello, ClientKeyShare, EarlyDataIndication,
(EncryptedExtensions), (Certiﬁcate*), (Certiﬁcate Verify*),
(ApplicationData)
ServerHello, ServerKeyShare, EarlyDataIndication,
{EncryptedExtensions}, {ServerConﬁguration†},{Certiﬁcate},
{CertiﬁcateRequest*}, {CertiﬁcateVerify}, {Finished}
{Finished}
[Application data]
Figure 3. 0-RTT handshake
PSKs and session resumption. TLS 1.3 effectively merges
the PSK and session resumption functionalities of TLS 1.2
into a single handshake mode. There are two possible sources
of PSKs: session tickets and out-of-band mechanisms. While
the former are speciﬁed in draft-10, the latter have not
yet been entirely clariﬁed with regards to their intended
implementation or assumed security properties. Figure 4
depicts a PSK handshake following an initial handshake.
Note that a new session ticket is sent by the server directly
after receiving the client’s Finished message in the initial
handshake.
C
S
Initial handshake (see Figure 2)
[NewSessionTicket]
[Application data]
ClientHello, ClientKeyShare, PreSharedKeyExtension
ServerHello, PreSharedKeyExtension, {EncryptedExtensions},
{Finished}
{Finished}
[Application data]
Figure 4. PSK-resumption handshake (after an initial handshake)
The client sends a key share in its ﬁrst ﬂight of the
resumption handshake to allow for the server to decline
resumption and fall back to the full (EC)DHE handshake. The
PreSharedKeyExtension value indicates the identity
of the PSK to be used in the exchange. We note that a
PSK handshake need not only take the form of a resumption
handshake. If a client and a server share an existing secret,
a PSK handshake may be an initial handshake. PSKs may
also be used in conjunction with an EC(DHE) exchange so
as to provide forward secrecy; the corresponding mode is
called PSK-DHE.
2.3. Stated goals and security properties
The TLS record protocol is claimed to provide conﬁden-
tiality and integrity of application data. The TLS handshake
protocol is claimed to allow unilateral or, optionally, mutual
entity authentication, as well as establishing a shared secret
that is unavailable to eavesdroppers and adversaries who
can place themselves in the middle of the connection. The
handshake is claimed to be reliable: no adversary can modify
the handshake messages without being detected by the
communicating parties.
The security properties thus inferred from draft-10
include:
unilateral authentication of the server (mandatory),
•
• mutual authentication (optional),
•
conﬁdentiality and perfect forward secrecy of session
keys, and
integrity of handshake messages.
•
These properties form the focus of our analysis. Table 1
outlines the full set of desired properties from “Appendix
D: Security Analysis” of [48]. However, we note that this
appendix contains the disclaimer “Todo: Entire security
analysis needs a rewrite”, and has not been updated since
the major changes in draft-07, and hence we expect this
set of properties to be updated in future revisions.
Covered by analysis
Security property
Unilateral authentication (server)
Mutual authentication
Total anonymity
Conﬁdentiality of ephemeral secret
Conﬁdentiality of static secret
Perfect forward secrecy
Integrity of handshake messages
Protection of application data
Denial of service
Version rollback
∗ speciﬁcation refers to outdated master_secret
Y
Y
N
Y
Y
Y
Y
N
N
N
TABLE 1. TLS 1.3 D R A F T-10 PROPERTIES.
Source
D.1.1
D.1.1
D.1.1
D.1.1∗
D.1.1∗
D.1.1.1
D.1.3
D.2
D.3
D.1.2
In addition to the stated goals, there are a few caveats
which are encountered in the speciﬁcation. For example, the
0-RTT application data and possible client authentication
both come with a warning notice. In the 0-RTT handshake,
the client is the only party to have provided freshness,
therefore these early data messages may be replayed. In
addition, the security of the early data depends on the semi-
static (EC)DH share, which may have a considerable validity
period, and therefore a large attack window. For these reasons,
early data cannot be considered to be forward secure.
474474
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:43 UTC from IEEE Xplore.  Restrictions apply. 
3. Formally modelling the protocol behaviour
We build a formal model of the handshake and record
protocols of draft-10 in the framework of the Tamarin
prover [51]. Tamarin is well-suited for this type of analy-
sis for several reasons. First, Tamarin’s multiset-rewriting
semantics enable a direct speciﬁcation of the complex state
machines of TLS, including the complex interactions between
all the handshakes, in a straightforward fashion. Second,
its state-of-the-art support for Difﬁe-Hellman key exchange
allows for a high degree of precision. Third, its property
speciﬁcation language (a fragment of ﬁrst-order logic with
quantiﬁcation over time-points) lets us model the security
properties intuitively and accurately.
3.1. Tamarin fundamentals
Here we provide a brief introduction to Tamarin. For a
more detailed introduction, we suggest reading the Tamarin
manual found at [52], the PhD thesis of Schmidt [50], or
the PhD thesis of Meier [42].
Rules. The Tamarin semantics are based on multiset-
rewriting. A Tamarin model deﬁnes a transition system
whose state is a multiset of facts. The allowed transitions
are speciﬁed by rules. At a very high level, Tamarin rules
encode the behaviour of participants, as well as adversarial
capabilities. In modelling cryptographic protocols, these
rules play a role similar to oracles in Bellare-Rogaway style
models.
Tamarin rules have a left-hand side (premises), actions,
and a right-hand side (conclusions). The left-hand and right-
hand sides of rules respectively contain multisets of facts.
Facts can be consumed (when occurring in premises) and
produced (when occurring in conclusions). Each fact can
be either linear or persistent (marked with an exclamation
point). While linear facts model limited resources that cannot
be consumed more times than they are produced, persistent
facts model unlimited resources, which can be consumed
any number of times once they have been produced.
A rule can only be executed if its left-hand side can be
matched with facts that are available for consumption in the
current state. For instance, the Fresh rule depicted here
rule Fresh:
[ ]--[ ]->[ Fr(x) ]
has no premises or actions, and every execution of it produces
a single linear Fr(x) fact. Note that only the Fresh rule
can produce Fr facts, each of them unique.
Actions do not inﬂuence the transitions, but are “logged”
when rules are triggered as a means of incrementally con-
structing observable action traces that in turn represent a
record of a speciﬁc execution. As we will later see, actions
(as part of action traces) form the glue between the deﬁned
transition system and the property speciﬁcation language.
Cryptographic primitives. The ability to model crypto-
graphic protocols requires the representation of cryptographic
primitives. In Tamarin, symmetric encryption, for instance,
475475
is modelled using two binary functions, senc and sdec,
and an equation of the form
sdec(senc(m, k), k) = m,
where k is a shared secret key and m is a message. As certain
primitives are used repeatedly across many cryptographic
protocols, there are built-in deﬁnitions for them. The Tamarin
builtins include equational theories for Difﬁe-Hellman group
operations, asymmetric encryption, symmetric encryption,
digital signatures and hashing.
The symmetric encryption builtin, for instance, could be
used in this simple rule that models sending encrypted data
out to a network:
rule Send:
[Fr(˜k), Fr(˜data)]--[Send(˜data)]->[Out(senc(˜data,˜k))]
The use of the builtin Out fact, as depicted in the Send rule,
denotes that a message has been sent out to the network, i.e.
senc(˜data,˜k) becomes known to the adversary. Re-
ceiving a message from the network is denoted by the corre-
sponding In fact. In other words, In(senc(˜data,˜k))
could form a premise of the rule which models receiving
encrypted data from the network. Use of the ∼ symbol
denotes a variable of the type Fresh. Other variable types
include Public, denoted by $, and Temporal, denoted
by #.
Security properties as lemmas. Tamarin formulas are spec-
iﬁed in a fragment of ﬁrst-order logic and therefore offer the
usual connectives (where & and | denote and and or, respec-
tively), quantiﬁers All and Ex, and timepoint ordering  x = y".
We typically use axioms to avoid traces where:
•
•
•
protocol participants initiate sessions with them-
selves,
large numbers of key pairs are generated for a single
protocol participant, or,
unnecessary features appear when constructing traces
without these features.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:43 UTC from IEEE Xplore.  Restrictions apply. 
3.2. Constructing a protocol abstraction
The ﬁrst step in the modelling process is to construct an
abstraction of the handshake and record protocols which will
in turn become the subject of our analysis. We attempt
to strike a balance between a completely accurate, yet
potentially complex model, and capturing only the most
important cryptographic and algorithmic aspects of the
protocols.
Perfect cryptography. We discussed the modelling of cryp-
tography through builtins in Section 3.1. This results in the
abstraction that our cryptographic primitives are perfect. For
example, the encryption mechanism reveals nothing about
the underlying plaintext.2 Similarly, we assume:
•
•
signatures are unforgeable,
hash functions act as random oracles (with zero
collision probability),
• MACs are unforgeable, and
•
all parties generate truly random values.
This is one of the possibilities for extending our analysis;
while the builtins assume perfect cryptography, we can
easily weaken these primitives by introducing rules which,
for example, let the adversary create signature and MAC
forgeries.
Conﬁguration parameters. We also note that we sim-
plify our model by treating certain parameters as ab-
stract quantities within the model. For example,
the
EncryptedExtensions message of a client in the 0-
RTT handshake will be logically bundled together with all