either a guess for attacking conﬁdentiality, or one for attack-
ing unforgeability.
• Conﬁdentiality guess: The adversary outputs a guess
b(cid:48) ∈ {0, 1}. The adversary wins the game if b = b(cid:48).
We deﬁne its advantage in attacking the scheme to be
2|.
| Pr[b = b(cid:48)] − 1
• Unforgeability guess: The adversary outputs
(cid:48)
(m, L, L
, SG, SM , σ).
We deﬁne its advantage in attacking the scheme as
the probability that no sign or redact query has been
issued for any document m(cid:48) satisfying m(cid:48) (cid:31) m or m(cid:48) (cid:31)
mb in Phase 1 or 2, and that Verify(m, L, L(cid:48), SG, SM , σ)
is true.
Theorem 1. Assume that H is a collision-free hash func-
tion, S is a digital signature scheme that is secure against
existential forgery, C is a secure commitment scheme, and
G is a secure pseudorandom generator. Then the algorithm
presented in §3 is an eﬃcient secure redactable-signature
scheme.
We sketch the proof of this theorem in §5.2 below. The
algorithm’s eﬃciency is described in §3 and §4.
5.2 Security analysis
The security is proved based on the security of collision-
free hash functions, commitment schemes with hiding and
binding properties, and signature schemes secure against ex-
istential forgery. Next we give informal deﬁnitions of secu-
rity for the cryptographic primitives that we use, omitting
their formal deﬁnitions.
Security of collision-free hash function: a polynomial-time
adversary has negligible probability of ﬁnding two diﬀerent
messages m (cid:54)= m(cid:48) with identical hash values.
Security of commitment scheme with binding and hiding
properties: a polynomial-time adversary has negligible prob-
ability of breaking the hiding property by identifying from
a commitment its corresponding message, randomly chosen
as one of the two messages of her choice, and has negligible
probability of breaking the binding property by ﬁnding a
commitment that can be opened to two diﬀerent messages
[9].
Security of signature scheme with existential unforgeabil-
ity: a polynomial-time adversary has negligible probability
of forging a valid signature S of a signer on a message m
such that the signer has never signed m [7].
Proof of Theorem 1: Let A be an adversary that has
a non-negligible advantage against our redactable-signature
scheme. We will construct an adversary B that uses A to
gain advantage against the collision-free hash function, the
secure commitment scheme, the secure signature scheme, or
the secure pseudorandom generator. The adversary B acts
as the challenger for A and uses A’s outputs as her own
outputs. B proceeds as follows.
Setup: B’s challenger chooses hash function H, commit-
ment scheme C, signature scheme S, and pseudorandom
generator G for B to break. B’s challenger gives B a public
key P K of the signature scheme S. B then gives the ad-
versary A the resulting public parameters (P K, H, C, S, G).
Note that B does not know the private key SK of signature
scheme S.
Phase 1: B answers A’s queries as follows. The queries
may be asked adaptively. Also, the queried document at
each query may be distinct.
1. commit query (m): B runs the ﬁrst several operations
in the Sign algorithm on input m, including buliding
a GGM tree and computing commitments, building
a Merkle hash tree over commitments, and gathering
auxiliary information that would be included in the
extended signature. All of these values are given to
the adversary A.
2. sign query (h): B cannot sign the root hash h of any
Merkle tree that she calculates, because she does not
have the private key. Therefore, B submits a signing
query on the root hash to her challenger (of the sig-
nature scheme to break), and obtains a signature σ.
(The game deﬁnition for security of signature schemes
is not given here; please see [7]). Signature σ is given
to the adversary A.
B can similarly request a signature for any hash value
h of her choice.
3. redact query (m, L, L(cid:48)): B runs a commit query and a
sign query on m to obtain the signature σ, along with
the seed needed for the GGM tree that would be part
of the extended signature for m. Then, B runs the
Redact algorithm, following the instructions in L and
L(cid:48) to redact or mark as nonredactable the appropriate
subdocuments in m, and computes the appropriate ex-
tended signature.
Once A decides that Phase 1 is over, if she chooses she
can issue a challenge for attacking conﬁdentiality.
Conﬁdentiality challenge: A outputs two equal-length
documents m0, m1 on which to be challenged, such that m0
and m1 are identical except in the i∗th subdocument (along
with Redact instruction lists L, L(cid:48), with i∗ ∈ L). B will
attempt to use A’s advantage in its conﬁdentiality guess to
break the hiding property of the commitment scheme. B
needs to embed his commitment challenge in the challenge
of A. The i∗th subdocuments in m0 and m1 are B’s two
messages of choice for breaking the hiding property of com-
mitment scheme C. B’s challenger generates a challenge for
B as follows. B’s challenger picks a random bit b ∈ {0, 1},
and computes a commitment of the i∗th subdocument in
mb. Denote this challenge as C∗
b as the commit-
ment of the i∗th subdocument in mb. B then computes the
commitments of the other subdocuments in mb (using either
m0 or m1) and obtains the root hash of the commitments.
Now B has embedded his commitment challenge at the
i∗th position of A’s challenge. For completeness, B asks
her challenger to sign the root hash (as in a sign query),
and obtains signature σ∗. And for auxiliary information
(SG, SM ), B chooses at random according to the protocol
speciﬁcations.
b . B uses C∗
Finally, B runs Redact(mb, L, L(cid:48), SG, SM , σ∗) in order to
redact the i∗th subdocument in mb, which can be computed
without knowing the actual content of the subdocument.
B gives adversary A the outputs of the Redact operation,
to be used as the conﬁdentiality challenge to adversary A.
Readers can verify that the veriﬁcation should be successful,
even though B does not know b.
Phase 2: The adversary issues more queries, and B re-
sponds as in Phase 1.
Guess: Adversary A outputs either a conﬁdentiality guess
or an unforgeability guess. B uses A’s outputs to attack one
of the cryptographic primitives used: the hash function, the
digital signature scheme, the commitment scheme, or the
pseudorandom generator.
Conﬁdentiality guess: If adversary A outputs a guess
b(cid:48) ∈ {0, 1}, then B outputs b(cid:48) as his guess for breaking the
commitment scheme. Because of the way in which B con-
structed his own commitment-scheme challenge, B’s guess
will be correct exactly when A’s guess is correct.
Unforgeability guess: Adversary A outputs
(cid:48)
(m, L, L
, SG, SM , σ),
where we assume without loss of generality that no sign
query has been issued for (the root hash corresponding to)
any document ¯m satisfying ¯m (cid:31) m or ¯m (cid:31) mb in Phase 1 or
2. A’s advantage in attacking the scheme is the probability
that Verify(L, M, SG, SM , σ) is true.
Suppose ﬁrst that σ is not equal to any of the signatures
¯σ that were returned to A in response to a previous query
in Phase 1 or Phase 2. To convert A’s output into a
signature forgery, B constructs the Merkle hash tree for the
redacted document m, and obtains the root hash hr. Let h1
and h2 be the hash values at the two child nodes of the root
node. In this case, σ is a correct signature for the message
h1|h2 with respect to the public key P K, B can successfully
attack the digital signature scheme.
We are left with the case that signature σ is equal to a
signature ¯σ that has been given to A in a previous query in
Phase 1 or Phase 2, corresponding to extended signature
( ¯m, ¯L, ¯L(cid:48), ¯SG, ¯SM , ¯σ).
B compares the Merkle hash tree constructed for m with
the Merkle hash tree constructed for ¯m.
If the two trees
diﬀer in their root nodes, then B can use this to produce a
forgery for P K. If the two trees diﬀer anywhere below the
root, then B has found a hash collision.
Next, B compares the two GGM trees constructed respec-
tively for m and for ¯m. If B ﬁnds any index i with subdoc-
uments mi (cid:54)= ¯mi, then B has found a pair of messages that
he can use to break the binding property of the commitment
scheme.
Because of our stipulation that m (cid:54)≺ ¯m, the only remain-
ing case is that for some index i, one of the following is true:
• i ∈ ¯L but i (cid:54)∈ L (so that A has computed a subdocu-
ment of m that was already redacted from ¯m); B can
use this case either to break the hiding property of the
commitment scheme, or to break the pseudorandom
generator.
• i ∈ ¯L(cid:48) but i ∈ L (so that A has redacted a subdocu-
ment of m already marked as nonredactable in ¯m); B
can use this case either to break the one-way property
of the hash function, or to break the pseudorandom
generator.
6. REFERENCES
[1] G. Ateniese, D. H. Chou, B. de Medeiros, and
G. Tsudik. Sanitizable signatures. In European
Symposium on Research in Computer Security
(ESORICS) 2005, volume 3679 of Lecture Notes in
Computer Science. Springer-Verlag, 2005.
[2] G. Ateniese and B. de Medeiros. On the key-exposure
problem in chameleon hashes. In SCN ’04, volume
3352 of Lecture Notes in Computer Science.
Springer-Verlag, 2004.
[3] A. Buldas and M. Saarepera. On provably secure
time-stamping schemes. In Advances in Cryptology —
ASIACRYPT 2004, volume 3329 of Lecture Notes in
Computer Science, pages 500–514, October 2004.
[4] A. Buldas and M. Saarepera. Do broken hash
functions aﬀect the security of time-stamping
schemes? In 4th Internatioanl Conf. on Applied
Cryptography and Network Security – ACNS ’06,
volume 3989 of Lecture Notes in Computer Science,
pages 50–65, 2006.
[5] O. Goldreich, S. Goldwasser, and S. Micali. How to
construct random functions. Journal of the ACM,
33(4):792–807, 1986.
[6] S. Goldwasser and S. Micali. Probabilistic encryption.
Journal of Computer and System Sciences,
28(2):270–299, April 1984.
[7] S. Goldwasser, S. Micali, and R. Rivest. A digital
signature scheme secure against adaptively chosen
message attacks. SIAM Journal on Computing,
17(2):281–308, 1988.
[8] S. Haber and W. Stornetta. Secure names for
bit-strings. In Proceedings of the 4th ACM Conference
on Computer and Communication Security, pages
28–35. ACM Press, April 1997.
[9] S. Halevi and S. Micali. Practical and provably-secure
commitment schemes from collision-free hashing. In
N. Koblitz, editor, Advances in Cryptology —
CRYPTO ’96, volume 1109 of Lecture Notes in
Computer Science, pages 201–215. Springer-Verlag,
1996.
[10] T. Izu, N. Kanaya, M. Takenaka, and T. Yoshioka.
PIATS: A partially sanitizable signature scheme. In
ICICS 2005, volume 3783 of Lecture Notes in
Computer Science, pages 72–83. Springer-Verlag, 2005.
[11] T. Izu, M. Sano, N. Kunihiro, K. Ohta, and
M. Takenaka. Sanitizable signature schemes based on
aggregate signature. In Proceedings of the Symposium
on Cryptography and Information Security
(SCIS2007), 2007. (In Japanese).
[12] R. Johnson, D. Molnar, D. Song, and D. Wagner.
Homomorphic signature schemes. In Proceedings of the
RSA Security Conference Cryptographers Track,
volume 2271 of Lecture Notes in Computer Science.
Springer-Verlag, February 2002. Available at
http://www.ece.cmu.edu/~dawnsong/papers/hom-
rsa02.pdf.
[13] A. Menezes, P. van Oorschot, and S. Vanstone.
Handbook of Applied Cryptography. CRC Press, 1996.
[14] K. Miyazaki, G. Hanaoka, and H. Imai. Digitally
signed document sanitizing scheme from bilinear maps.
In 2005 Symposium on Cryptography and Information
Security (SCIS2005), pages 1471–1476, January 2005.
[15] K. Miyazaki, G. Hanaoka, and H. Imai. Bit-by-bit
sequence sanitizable digitally signed document
sanitizing scheme. In Proceedings of the Symposium on
Cryptography and Information Security (SCIS2006),
2006. (In Japanese).
[16] K. Miyazaki, G. Hanaoka, and H. Imai. Digitally
signed document sanitizing scheme based on bilinear
maps. In Proceedings of the 2006 ACM Symposium on
Information, Computer and Communications Security
(ASIACCS), 2006.
[17] K. Miyazaki, M. Iwamura, T. Matsumoto, R. Sasaki,
and H. Yoshimura. Digital documents sanitizing
problem. Technical Report ISEC2003-20, 2003. IEICE
Technical Report.
[18] K. Miyazaki, M. Iwamura, T. Matsumoto, R. Sasaki,
H. Yoshimura, S. Tezuka, and H. Imai. Digitally signed
document sanitizing scheme with disclosure condition
control. IEICE Transactions on Fundamentals of
Electronics, Communications and Computer Sciences,
E88-A(1):239–246, January 2005. Available at
http://ietfec.oupjournals.org/cgi/reprint/E88-
A/1/239.
[19] C. Rackoﬀ and D. Simon. Non-interactive
zero-knowledge proof of knowledge and chosen
ciphertext attack. In J. Feigenbaum, editor, Advances
in Cryptology — CRYPTO ’91: Proceedings, volume
576 of Lecture Notes in Computer Science, pages
433–444. Springer-Verlag, 1992.
[20] M. Sano, T. Izu, N. Kunihiro, K. Ohta, and
M. Takenaka. On sanitizable and deletable signature
schemes. In Proceedings of the Symposium on
Cryptography and Information Security (SCIS2007),
2007. (In Japanese).
[21] R. Steinfeld, L. Bull, and Y. Zheng. Content
extraction signatures. In 4th International Conference
on Information Security and Cryptology — ICISC
2001, volume 2288 of Lecture Notes in Computer
Science, pages 285–304. Springer-Verlag, December
2001.
[22] M. Suzuki, T. Ishiki, and K. Tanaka. Sanitizable
signature with secret information. In Proceedings of
the Symposium on Cryptography and Information
Security (SCIS2006), 2006.
[23] L. Sweeney. k-anonymity: A model for protecting
privacy. International Journal of Uncertainty,
Fuzziness and Knowledge-Based Systems,
10(5):557–570, 2002.
[24] L. Sweeney. Achieving k-anonymity privacy protection
using generalization and suppression. International
Journal of Uncertainty, Fuzziness and
Knowledge-Based Systems, 10(5):571–588, 2002.