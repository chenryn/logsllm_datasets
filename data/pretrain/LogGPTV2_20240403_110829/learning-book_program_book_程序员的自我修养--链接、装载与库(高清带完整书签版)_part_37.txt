动态链接还有一个特点就是程序在运行时可以动态地选择加载各种程序模块，这个优点
就是后来被人们用米制作程序的插件（Plug-in）。
比如某个公司开发完成了某个产品，它按照一定的规则制定好程序的接口，其他公司或
开发者可以按照这种接口来编写符合要求的动态链接文件，该产品程序可以动态地载入各种
由第三方开发的模块，在程序运行时动态地链接，实现程序功能的扩展。
动态链接还可以加强程序的兼容性。一个程序在不同的平台运行时可以动态地链接到由
程序员的自我修养一链接、装载与库
---
## Page 206
7.1为什么要动态链接
183
操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统之间增加了一个中间
层，从而消除了程序对不同平台之间依的差异性。比如操作系统A和操作系统B对于
printfO的实现机制不同，如果我们的程序是静态链接的，那么程序需要分别链接成能够在A
运行和在B运行的两个版本并且分开发布：但是如果是动态链接，只要操作系统A和操作
系统B都能提供一个动态链接库包含printfO，并且这个printfO使用相同的接口，那么程序
只需要有一个版本，就可以在两个操作系统上运行，动态地选择相应的printfO的实现版本。
当然这只是理论上的可能性，实际上还存在不少问题，我们会在后面继续探讨关于动态链接
模块之间兼容性的问题。
从上面的描述来看，动态链接是不是一种“万能膏药”，包治百病呢？很遗憾，动态链
接也有诸多的问题及令人烦恼和费解的地方。很常见的一个问题是，当程序所依赖的某个模
块更新后，由于新的模块与旧的模块之间接口不兼容，导致了原有的程序无法运行。这个间
题在早期的Windows版本中尤为严重，因为它们缺少一种有效的共享库版本管理机制，使
得用户经常出现新程序安装完之后，其他某个程序无法正常工作的现象，这个问题也经常被
棕为“DLLHell"
动态键接的基本实现
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它
们链接在一起形成一个完整的程序，而不是像静态链接一样把所有的程序模块都链接成一个
个单独的可执行文件。那么我们能不能按照前面例子中所描述的那样，直接使用目标文件进
行动态链接呢？这个问题的答案是：理论上是可行的，但实际上动态链接的实现方案与直接
使用目标文件稍有差别。我们将在后面分析目标文件和动态链接文件的区别。
动态链接涉及运行时的链接及多个文件的装载，必需要有操作系统的支持，因为动态链
接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、
内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。目前主流的操作系统几乎
都支持动态链接这种方式，在Linux系统中，ELF动态链接文件被称为动态共享对象（DSO，
Dynamic Shared Objects），简称共享对象，它们一般都是以“so”为扩展名的一些文件：
而在Windows系统中，动态链接文件被称为动态链接库（DynamicalLinkingLibrary），它
们通常就是我们平时很常见的以“dl”为扩展名的文件。
从本质上讲，普通可执行程序和动态链接库中都包含指令和数据，这一点没有区别。
在使用动态链接库的情况下，程序本身被分为了程序主要模块（Program1）和动态链
接库（Lib.so），但实际上它们都可以看作是整个程序的一个模块，所以当我们提到程
序模块时可以指程序主模块也可以指动态链接库。
在Linux中，常用的C语言库的运行库glibc，它的动态链接形式的版本保存在“/lib"
程序员的自我修养——链接、装载与库
---
## Page 207
184
第7章动态链接
目录下，文件名叫做“ibc.so”。整个系统只保留一份C语言库的动态链接文件“libc.so”，
而所有的C语言编写的、动态链接的程序都可以在运行时使用它，当程序被装载的时候，
系统的动态链接器会将程序所需要的所有动态链接库（最基本的就是libc.so）装载到进程的
地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。
程序与libc.so之间真正的链接工作是由动态链接器完成的，而不是由我们前面看到过
的静态链接器Id完成的。也就是说，动态链接是把链接这个过程从本来的程序装载前被推
迟到了装载的时候。可能有人会间，这样的做法的确很灵活，但是程序每次被装载时都要进
行重薪进行链接，是不是很慢？的确，动态链接会导致程序在性能的一些损失，但是对动态
链接的链接过程可以进行优化，比如我们后面要介绍的延退绑定（LazyBinding）等方法，
可以使得动态链接的性能损失尽可能地减小。据估算，动态链接与静态链接相比，性能损失
大约在5%以下，当然经过实践的证明，这点性能损失用来换取程序在空间上的节省和程序
构建和升级时的灵活性，是相当值得的。
7.2简单的动态链接例子
Windows 平台下的 PE 动态链接机制与Linux下的 ELF 动态链接稍有不同，ELF 比 PE
从结构上来看更加简单，我们先以ELF作为例子来描述动态链接的过程，接着我们将会单
独描述Windows平台下PE动态链接机制的差异。
首先通过一个简单的例子来大致地感受一下动态链接，我们还是以图7-2中的Programl
和Program2来做演示。我们分别需要如下几个源文件：“Program1.c”、“Program2.e”、“Lib.c”
和“Lib.h”。它们的源代码如清单7-1所示。
清单 7-1SimpleDynamicalLinking
finclude *Lib.h*
/* Progranl.c */
int main()
foobar (1) ;
return 0;
include *Lib.h*
/* Program2.c */
Int main()
foobar (21 ;
return 0;
程序员的自我修养一链接、装载与库
---
## Page 208
7.2简单的动态链接例子
185
include 
/* Lib.c */
void foobar (int i)
printf(*Printing from Lib.so ed\n*, i):
#ifndef LIB_H
/* Lib.h */
#define LIB_H
void foobar (int i1;
#endif
程序很简单，两个程序的主要模块Programl.c和 Program2.c分别调用了Lib.c里面的
foobar(函数，传进去一个数字，foobarO函数的作用就是打印这个数字。然后我们使用GCC
将Lib.c编译成一个共享对象文件：
gcc -fPIC -shared -o Lib.so Lib.c
解释，这里暂且略过。
这时候我们得到了一个Lib.so文件，这就是包含了Lib.c的foobar(函数的共享对象文
件。然后我们分别编译链接 Program1.c 和 Program2.c:
gcc -o Program1 Program1.c ./Lib.so
gcc -o Program2 Program2.c ./Lib.s0
这样我们得到了两个程序Program1和Program2，这两个程序都使用了Lib.so里面的
foobar(函数。从Programl的角度看，整个编译和链接过程如图7-3所示。
Lib.e
Lib.0
→
C Run
Liorawy
Linker
Lib.s0
Program1.c
Program1.o-
Program
图7-3动态链接过程
程序员的自我修养—链接、装载与库
---
## Page 209
186
第7章动态链接
Lib.c被编译成Lib.so共享对象文件，Programl.c被编译成Programl.o之后，链接成为
可执行程序Programl。图7-3中有一个步骤与静态链接不一样，那就是Program1.o被连接
成可执行文件的这一步。在静态链接中，这一步链接过程会把Programl.o和Lib.o链接到一
起，并且产生输出可执行文件Programl。但是在这里，Lib.o没有被链接进来，链接的输入
目标文件只有Programl.o（当然还有C语言运行库，我们这里暂时忽略）。但是从前面的命
令行中我们看到，Lib.so也参与了链接过程。这是怎么回事呢？
关于模块（M）
在静态链接时，整个程序最终只有一个可执行文件，它是一个不可以分割的整体：但
是在动态链接下，一个程序被分成了若干个文件，有程序的主要部分，即可执行文件
[Program1）和程序所依赖的共享对象（Lib.so），很多时候我们也把这些部分称为模
块，即动态链接下的可执行文件和共享对象都可以看作是程序的一个模块。
让我们再回到动态链接的机制上来，当程序模块Programl.c被编译成为Programl.o时，
编译器还不不知道foobarO函数的地址，这个内容我们已在静态链接中解释过了。当链接器
将 Programl.o链接成可执行文件时，这时候链接器必须确定Programl.o中所引用的 foobarO
函数的性质。如果foobar)是一个定义与其他静态目标模块中的函数，那么链接器将会按照
静态链接的规则，将Programl.o中的foobar地址引用重定位：如果foobarO是一个定义在某
个动态共享对象中的函数，那么链接器就会将这个符号的引用标记为一个动态链接的符号，
不对它进行地址重定位，把这个过程留到装载时再进行。
号？这实际上就是我们要用到Lib.so的原因，Lib.so中保存了完整的符号信息（因为运行时
进行动态链接还须使用符号信息），把Lib.so也作为链接的输入文件之一，链接器在解析符
号时就可以知道：foobar是一个定义在Lib.so的动态符号，这样链接器就可以对foobar的引l
用做特殊的处理，使它成为一个对动态符号的引用。
动态链接程序运行时地址空间分布
对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，那就是可执行文件
本身，我们在前面的章节已经介绍了静态链接下的进程虚拟地址空间的分布。但是对于动态
链接米说，除了可执行文件本身之外，还有它所依赖的共享目标文件，那么这种情况下，进
程的地址空间分布文会怎样呢？
我们还是以上面的Programl为例，但是当我们l试图运行Program1并且查看它的进程空
间分布时，程序一运行就结束了。所以我们得对程序做适当的修改，在Lib.c中的foobarO
函数里面加入sleep函数：
程序员的自我修养—链接、装载与库
---
## Page 210
7.2简单的动态链接例子
187
include 
void foobar(int i)
printf(*Printing from Lib.so ed\n*, i);
sleep(-1) ;
然后就可以查看进程的虚拟地址空间分布：
$./Programl &
Printing from Lib.so 1
[1]12985
08048000-08049000 r-xp 00000000 08:01 1343432
$cat/proc/12985/mape
08049000-0804a000
rwxp 00000000 08:01 1343432
./Program1
, /Progran1
b7e83000-b7e84000
rwxp b7e83000 00:00 0
/1ib/t1s/1686/cmov/1ibc-2.6.1.8o
b7fc8000-b7fc9000 r-xp 00143000 08:01 1488993
b7fc9000-b7fcb000 rwxp 00144000 08:011488993
/1ib/t18/i686/cnov/1ibc-2.6.1.so
b7fcb000-b7fce000 rwxp b7fcb000 00:00 0
/1ib/tls/1686/cnov/1ibc-2,6.1.so
b7fd8000-b7fd9000 rwxp
b7fd9000-b7fda000 r-xp
b7fd8000 00:00 0
b7Eda000-b7Edb000 rwxp
00000000 08:01 1343290
./Lib.80
b7fdb000-b7fdd000 rwxp
00000000 08:01 1343290
./Lib.80
b7fdd000-b7ff7000r-xp
b7fdb000 00:00 0
00019000 08:01
10:80 00000000
1455332
/1ib/1d-2.6.1.80
1455332
/11b/1d-2.6.1.s0
ffffe000-fffffoo0r-xp 0o000ooo 00:000
bf965000-bf97b000 rw-p
bf965000 00:00
0
[stack]
$ ki11 12985
[vdso]
[1] + Terminated
. /Program1
我们看到，整个进程虚拟地址空间中，多出了儿个文件的映射。Lib.so与Programl
样，它们都是被操作系统用同样的方法映射至进程的虚拟地址空间，只是它们占据的虚拟地
址和长度不同。Programl除了使用Lib.so以外，它还用到了动态链接形式的C语言运行库
libc-2.6.1.so。另外还有一个很值得关注的共享对象就是ld-2.6.so，它实际上是Linux下的动
态链接器，动态链接器与普通共享对象一样被映射到了进程的地址空间，在系统开始运行
Program1之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把
控制权交给Program1，然后开始执行。
我们通过readelf工具来查看Lib.so的装载属性，就如我们在前面查看普通程序一样：
$ readelf -1 Lib.80
E1f file type is DYN (Shared object file)
There are 4 program headers, 8tarting at offset 52
Entry point 0x390
Program Headers:
Type
offset
VirtAddr
PhysAddr
FileSiz MemSiz F1g Align
程序员的自我修养—链接、装载与库
---
## Page 211
188
第7章动态链接
LOAD
0x0004e0 0x000014e0 0x000014e0 0x0010c 0x00110 RW
0001X0 3 ￥ 09+00X0 09900×0 00000000X0 00000000X0000000X0
L0AD
0x0004f4 0x000014f4 0x000014f4 0x000c8 0x000c8RW0x4
0x1000
DYNAMIC
GNU_STACK
0x000000 0x00000000 0x00000000 0x00000 0x00000 RW0x4
Section to Segment mapping:
00.hash .gnu.hash .dynsym -dynstr gnu.version ,gnu.version_r .rel.dyn
Segment Section8.
01
.ctors .ditors .jcr ,dynamic .got .got.plt .data .bss
,rel.plt .init .plt .text .fini