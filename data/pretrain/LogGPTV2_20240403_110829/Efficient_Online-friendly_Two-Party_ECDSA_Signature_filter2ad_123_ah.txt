ğœ’ğ‘ + Ë†ğœ’ Ë†ğ‘ to Bob.
â€¢ Bob aborts if ğœ’tğµ ğ‘— + Ë†ğœ’Ë†tğµ ğ‘— â‰  bğ‘—ğ‘¢ âˆ’ rğ‘— for any ğ‘— âˆˆ [1, 2ğœ… + 2ğ‘ ].
â€¢ Alice and Bob compute their output shares respectively, i.e.,
ğ›¼ =ğ‘— âˆˆ[1,2ğœ…+2ğ‘ ] gğ‘— tğ´ğ‘—, and ğ›½ =ğ‘— âˆˆ[1,2ğœ…+2ğ‘ ] gğ‘— tğµ ğ‘—.
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea571D MTA FROM PAILLIER
We recall the MtA protocol from Paillier encryption, which has
appeared many times before [6, 12, 19, 25â€“27].
Paillier is a well-known additive homomorphic encryption scheme.
Let ğ‘ğ‘˜ = ğ‘ and ğ‘ ğ‘˜ = ğœ™(ğ‘) be the public and secret keys of Paillier
encryption respectively. Denote the encryption of message ğ‘š with
randomness ğ‘Ÿ by Enc(ğ‘ğ‘˜, ğ‘š, ğ‘Ÿ) = ğ‘Ÿ ğ‘ (1+ğ‘)ğ‘š mod ğ‘ 2, the decryp-
tion of ciphertext ğ‘ by Dec(ğ‘ ğ‘˜, ğ‘). For simplicity, we may eliminate
the randomness ğ‘Ÿ and denote encryption as Enc(ğ‘ğ‘˜, ğ‘š). We denote
by ğ‘1 âŠ• ğ‘2 = ğ‘1ğ‘2 mod ğ‘ 2 the addition of the plaintext in cipher-
texts ğ‘1 and ğ‘2, and by ğ‘ âŠ™ ğ‘ = ğ‘ğ‘ mod ğ‘ 2 the multiplication of
the plaintext in ğ‘ by a scalar ğ‘.
Zero-knowledge proofs for the following relation are needed for
the Paillier-based MtA.
Proof correct Paillier keypair generation Define the relation
RP = {(ğ‘ , ğœ™(ğ‘))| gcd(ğ‘ , ğœ™(ğ‘)) = 1}
of valid Paillier public keys. We remark that standard Paillier is
defined for ğ‘ = ğ‘ğ‘ with ğ‘, ğ‘ prime. As did in [25], we only require
gcd(ğ‘ , ğœ™(ğ‘)) = 1 since all we need is the additive homomorphic
property. The proof ZKPoKRP for RP was proposed in [22, Sec.3.3]
and [25, Appendix A] which (for a soundness error 2âˆ’ğ‘¡) requires
3ğ‘¡ Paillier encryption and 4ğ‘¡ GCD computation. Please refer to [25,
Appendix A] for the description of ZKPoKRP.
ZKPoK for Paillier Encryption with Range Proof. Define the
relation
RPwR := {(ğ‘ , ğ‘, ğ‘; ğ‘š, ğ‘Ÿ)|ğ‘ = ğ‘Ÿ
ğ‘ (1 + ğ‘)ğ‘¥ mod ğ‘ 2 âˆ§ ğ‘¥ âˆˆ Zğ‘}
of Paillier encryption with range proof. Lindell [25, Appendix A]
proposed a rather expensive ZKPoK for RPwR based on a proof
from [5, Sec.1.2.2]. Later, Lindell et al. [26], Gennaro and Goldfeder
[19], and Canetti et al. [6] gave an efficient proof with slack under
Strong-RSA assumption and proved that the proof with slack is
enough for MtA. Please refer to D.1 for a ZKPoK for RPwR with
slack.
ZKPoK for Range-Bounded Affine Operation. Define the rela-
tion RAffRan as
{(ğ‘ğ‘˜, ğ‘, ğ‘ğ´, ğ‘ğµ; ğ‘, ğ›¼)|ğ‘ğ´ = ğ‘ âŠ™ ğ‘ğµ âŠ• Enc(ğ‘ğ‘˜, ğ›¼) âˆ§ ğ‘ âˆˆ Zğ‘ âˆ§ ğ›¼ âˆˆ Zğ¾}
of Paillier encryption with range proof. We may also define the
relation Râ€²AffRan as
{(ğ‘ , ğ‘, ğ‘ğ´, ğ‘ğµ; ğ‘, ğ›¼)|ğ‘ğ´ = (ğ‘ğµ)ğ‘(1 + ğ‘)ğ›¼ mod ğ‘ 2
âˆ§ ğ‘ âˆˆ Zğ‘ âˆ§ ğ›¼ âˆˆ Zğ¾}.
(resp. ZKPoKRAffRan) be the ZKPok proof forRâ€²AffRan
Let ZKPoKRâ€²AffRan
(resp. RAffRan). Please refer to D.2 for this proof with slack.
With those ZKPoKs, the Paillier-based MtA works as in the
following. We remark that all the ZKPoKs are transferred to non-
interactive using the Fiat-Shamir paradigm [18]. Its security relies
on the semantic security of Paillier encryption. As noted by [19,
25], ğœ‹ğ´ could be eliminated under the non-standard Paillier-EC
assumption which is recalled in D.3.
In the setup phase,
â€¢ ğ‘ƒ2 generates a Paillier key-pair ğ‘ğ‘˜ = ğ‘ , ğ‘ ğ‘˜ = ğœ™(ğ‘).
ğ‘ƒ2 respectively.
â€¢ ğ‘ƒ2 computes a ZKPoKRP proof for the correctness of Paillier
public key.
â€¢ ğ‘ƒ2 sends ğ‘ğ‘˜, ZKPoKRP to ğ‘ƒ1 who will verify the proof.
In the multiplication phase, let ğ‘, ğ‘ âˆˆ Zğ‘ be the input of ğ‘ƒ1 and
â€¢ ğ‘ƒ2 initiates the protocol
â€“ Compute ğ‘ğµ = Enc(ğ‘ğ‘˜, ğ‘) and a ZKPoKRPwR proof ğœ‹ğµ.
â€“ Send (ğ‘ğµ, ğœ‹ğµ) to ğ‘ƒ1.
â€¢ On receiving ğ‘ğµ, ğœ‹ğµ, ğ‘ƒ1 do the following
â€“ Verify ğœ‹ğµ, and abort if it fails.
â€“ Choose ğ›¼â€² â† Zğ¾. Set output ğ›¼ = âˆ’ğ›¼â€² mod ğ‘.
â€“ Compute the ciphertext ğ‘ğ´ = ğ‘ âŠ™ ğ‘ğµ âŠ• Enc(ğ‘ğ‘˜, ğ›¼â€²), and
a ZKPoKRAffRan proof ğœ‹ğ´ with witness ğ‘, ğ›¼â€². (or Compute
ğ‘ğ´ = ğ‘âŠ™ğ‘ğµ(1+ğ‘)ğ›¼â€² mod ğ‘ 2), and a ZKPoKRâ€²AffRan
proof
ğœ‹ğ´.)
â€“ Send (ğ‘ğ´, ğœ‹ğ´) to ğ‘ƒ2.
â€¢ Upon receiving (ğ‘ğ´, ğœ‹ğ´), ğ‘ƒ2 do the following
â€“ Verify ğœ‹ğ´, and abort if it fails.
â€“ Compute ğ›½â€² = Dec(ğ‘ ğ‘˜, ğ‘ğ´) and output ğ›½ = ğ›½â€² mod ğ‘.
D.1 Range Proof for Paillier with Slack under
Strong-RSA Assumption
We recall the range proof for Paillier with slack, i.e. the following
relation RPwR) proposed in [26, Sec.6.2.6].
ğ‘ (1 + ğ‘)ğ‘¥ mod ğ‘ 2 âˆ§ ğ‘¥ âˆˆ Zğ‘}.
RPwR := {(ğ‘ , ğ‘, ğ‘; ğ‘š, ğ‘Ÿ)|ğ‘ = ğ‘Ÿ
The soundness only guarantees that ğ‘¥ âˆˆ [âˆ’2ğ‘¡+ğ‘™ğ‘,âˆ’2ğ‘¡+ğ‘™ğ‘]. As an-
alyzed in [26, Sec. 6.2], the following range proof with slack is
enough for Paillier-based MtA by adding 2ğ‘¡+ğ‘™ğ‘ to ğ‘ and setting
ğ¾ = 2ğ‘¡+ğ‘™+ğ‘ ğ‘2.
Let ğ‘¡, â„“, ğ‘  be security parameters. In the implementation, we
set ğ‘¡ = ğ‘  = 128 and â„“ = 80 for 80 bits statistical security. Let ğ‘0
be the modulus for Pedersen, and ğ‘”, â„ âˆˆ ğ‘„ğ‘…ğ‘0 be random. The
Pedersen commitment of ğ‘¥ with randomness ğœŒ is ğ‘”ğ‘¥â„ğœŒ mod ğ‘0.
It is assumed that the Paillier modulus ğ‘ was generated by the
Prover and the Pedersen parameters (ğ‘0, ğ‘”, â„) were generated by
the Verifier. We instruct the parties, in the setup phase, to prove in
zero-knowledge that all the parameters were generated correctly.
In the setup phase, the verifier ğ‘‰ sends the prover ğ‘ƒ parame-
ters ğ‘0, ğ‘”, â„ and zero-knowledge proof that all the parameters are
generated correctly.
â€¢ Proverâ€™s first message: ğ‘ƒ chooses ğœŒ, ğ›¾, ğœ â† Zğ‘0, ğ›¼, ğ‘ âˆˆ Z2ğ‘¡+â„“ğ‘,
ğ›½ â† Zğ‘ and computes Ëœğ¶ = ğ‘”ğ‘¥â„ğœŒ mod ğ‘0, ğ´ = ğ›½ğ‘ (1+ğ‘)ğ›¼
mod ğ‘ 2, ğµ = ğ‘”ğ›¼â„ğ›¾ mod ğ‘0, and ğ· = ğ‘”ğ‘â„ğœ mod ğ‘0. Then
Prover sends ( Ëœğ¶, ğ´, ğµ, ğ·) to ğ‘‰ .
â€¢ Challenge: ğ‘‰ chooses ğ‘’ âˆˆ {0, 1}2ğ‘¡ and ğ‘’1 âˆˆ Z2ğ‘¡ and sends
them to ğ‘ƒ.
â€¢ Proverâ€™s second message: ğ‘ƒ computes ğ‘§1 = ğ›¼ + ğ‘’ğ‘¥ (over
the integer), ğ‘§2 = ğ›½ğ‘Ÿğ‘’ mod ğ‘ , ğ‘§3 = ğ›¾ + ğœŒğ‘’, ğ‘§4 = ğ‘ + ğ‘¥ğ‘’1,
ğ‘§5 = ğœ + ğ‘’1ğœŒ. ğ‘ƒ sends (ğ‘§1, ğ‘§2, ğ‘§3, ğ‘§4, ğ‘§5) to ğ‘‰ .
â€¢ Verification: Accept if and only if
2 (1 + ğ‘)ğ‘§1 = ğ´(ğ¶)ğ‘’ mod ğ‘ 2
â€“ ğ‘§ğ‘
â€“ ğ‘”ğ‘§1â„ğ‘§3 = ğµ( Ëœğ¶)ğ‘’ mod ğ‘0
â€“ ğ‘§4 âˆˆ [2ğ‘¡ğ‘, 2ğ‘¡+â„“ğ‘)
â€“ ğ‘”ğ‘§4â„ğ‘§5 = ğ·( Ëœğ¶)ğ‘’1 mod ğ‘0
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea572Table 6: The CL encryption scheme.
Encğ‘ğ‘™ (pk, ğ‘š)
Pick ğ‘Ÿ â† [0, ğ‘†]
Return (ğ‘”ğ‘Ÿ
ğ‘, pkğ‘Ÿ ğ‘“ ğ‘š)
Decğ‘ğ‘™ (sk, ğ‘1, ğ‘2)
Compute ğ‘€ = ğ‘2/ğ‘sk
1
Return logğ‘“ (ğ‘€)
D.2 Proof of Paillier-Pedersen Range-Bounded
Affine Operation
We recall the proof for affine operation over Paillier ciphertext in
given range, i.e. for relation Râ€²AffRan) proposed in [26, Sec.6.2.7].
Râ€²AffRan is defined as
{(ğ‘ , ğ‘, ğ‘ğ´, ğ‘ğµ; ğ‘, ğ›¼)|ğ‘ğ´ = (ğ‘ğµ)ğ‘(1 + ğ‘)ğ›¼ mod ğ‘ 2
âˆ§ ğ‘ âˆˆ Zğ‘ âˆ§ ğ›¼ âˆˆ Zğ‘22ğ‘¡+â„“+ğ‘  }
Let ğ‘¡, â„“, ğ‘  be security parameters. In the implementation, we
set ğ‘¡ = ğ‘  = 128 and â„“ = 80 for 80 bits statistical security. The
proof works as follows. In the setup phase, the verifier ğ‘‰ sends the
prover ğ‘ƒ parameters ğ‘0, ğ‘”, â„ and zero-knowledge proof that all the
parameters are generated correctly. (In our specific usage to MtA,
ğ‘0 = ğ‘ since the verifier generates ğ‘ .)
â€¢ Proverâ€™s first message: ğ‘ƒ chooses ğ‘ âˆˆ Z2ğ‘¡+â„“ğ‘, ğ›½ â† Z22ğ‘¡+2â„“+ğ‘ ğ‘2,
ğµ(1 + ğ‘)ğ›½ mod ğ‘ 2,
ğœŒ1, ğœŒ2, ğœŒ3, ğœŒ4 â† Zğ‘ . ğ‘ƒ computes ğ´ = ğ‘ğ‘
ğµ1 = ğ‘”ğ‘â„ğœŒ1 mod ğ‘ , ğµ2 = ğ‘”ğ›½â„ğœŒ2 mod ğ‘ , ğµ3 = ğ‘”ğ‘â„ğœŒ3
mod ğ‘ , ğµ4 = ğ‘”ğ›¼â„ğœŒ4 mod ğ‘ . ğ‘ƒ sends (ğ´, ğµ1, ğµ2, ğµ3, ğµ4) to
ğ‘‰ .
â€¢ Challenge: ğ‘‰ sends a random ğ‘’ âˆˆ Z2ğ‘¡ to ğ‘ƒ.
â€¢ Proverâ€™s second message: ğ‘ƒ computes and sends ğ‘§1 = ğ‘ + ğ‘’ğ‘,
ğ‘§2 = ğ›½ + ğ‘’ğ›¼, ğ‘§3 = ğœŒ1 + ğ‘’ğœŒ3, ğ‘§4 = ğœŒ2 + ğ‘’ğœŒ4 to ğ‘‰ .
â€¢ Verification: Accept if and only if
â€“ ğ‘§1 âˆˆ [2ğ‘¡ğ‘, 2ğ‘¡+â„“ğ‘)
â€“ ğ‘§2 âˆˆ [22ğ‘¡+â„“+ğ‘ ğ‘2, 22ğ‘¡+2â„“+ğ‘ ğ‘2)
â€“ ğ‘
â€“ ğ‘”ğ‘§1â„ğ‘§3 = ğµ1(ğµ3)ğ‘’ mod ğ‘
â€“ ğ‘”ğ‘§2â„ğ‘§4 = ğµ2(ğµ4)ğ‘’ mod ğ‘
ğµ (1 + ğ‘)ğ‘§2 = ğ´(ğ‘ğ´)ğ‘’ mod ğ‘ 2
ğ‘§1
D.3 Paillier-EC Assumption
The Paillier-EC assumption states the security of encryption even
the adversary is given a restricted oracle. Concretely, it says that
any PPT adversary A can only win the following experiment (i.e.
the experiment outputs 1) with 1/2 plus a negligible probability.
â€¢ Generate a Paillier key pair (ğ‘ğ‘˜, ğ‘ ğ‘˜)
â€¢ Choose ğ‘¤0, ğ‘¤1 â† Zğ‘ and compute ğ‘„0 = ğ‘¤0 Â· ğ‘ƒ
â€¢ Choose a random ğ‘ â† {0, 1} and compute ğ‘ = Enc(ğ‘ğ‘˜, ğ‘¤ğ‘)
â€¢ Let ğ‘â€² = AO(Â·,Â·,Â·)(ğ‘ğ‘˜, ğ‘, ğ‘„0), where O(ğ‘, ğ‘, ğ‘) = 1 iff Dec(ğ‘) =
ğ‘ + ğ‘ğ‘¤ğ‘ mod ğ‘ and the oracle O holds once it returns 0.
â€¢ The experiment returns 1 if and only if ğ‘â€² = ğ‘.
E THE CL-ENCRYPTION, ZKPOK FOR
CL-ENCRYPTION AND GAME-BASED
THRESHOLD UNFORGEABILITY.
We recall the CL encryption [9] and ZKPoK for CL encryption from
[8].
Let (Ëœğ‘ , ğ‘“ , Ë†ğ‘”ğ‘, ğ‘”ğ‘, Ë†ğº, ğ¹, ğ‘) be public parameters of CL encryption
(as defined in [8]), where ğ¹ = âŸ¨ğ‘“ âŸ© is the subgroup of Ë†ğº with order ğ‘,
ğ‘”ğ‘ is a random element in âŸ¨ Ë†ğ‘”ğ‘âŸ©. Denote by sk, pk = ğ‘”skğ‘ secret-public
key pair. CL encryption and decryption works as Table 6, where ğ‘†
is an integer to be determined.
We denote by ğ‘ âŠ• Ë†ğ‘ the addition of the plaintext in ciphertexts
ğ‘ and Ë†ğ‘, and by ğ‘ âŠ™ ğ‘ the multiplication of the plaintext in ğ‘ by a
scalar ğ‘.
E.1 ZKPoK for correctness of CL encryption
We recall the zero-knowledge argument of knowledge for correct-
ness of ciphertext from [8]. Define relation
ğ‘…CL := {(pk, ğ‘1, ğ‘2; ğ‘š, ğ‘Ÿ)|pk âˆˆ Ë†ğº, ğ‘Ÿ âˆˆ [0, ğ‘†],
ğ‘ âˆ§ ğ‘2 = pkğ‘Ÿ
ğ‘Ÿ
ğ‘1 = ğ‘”
ğ‘“
ğ‘š}.
Let C be the challenge space and ğ¶ = |C|. In the setup, the prover
should send public parameters to verifier and proves ğ‘”ğ‘ is a random
element of âŸ¨ Ë†ğ‘”ğ‘âŸ© (using the proof given in [8, Sec. 3.2]).
â€¢ Proverâ€™s first message: ğ‘ƒ chooses ğ‘Ÿ1 â† [0, 280 Ëœğ‘ ğ¶], ğ‘Ÿ1 â† Zğ‘,
ğ‘Ÿ1
ğ‘ , ğ‘¡2 = pkğ‘Ÿ1 ğ‘“ ğ‘Ÿ1. ğ‘ƒ sends (ğ‘¡1, ğ‘¡2) to ğ‘‰ .
computes ğ‘¡1 = ğ‘”
â€¢ Challenge: ğ‘‰ sends a random ğ‘’ â† C to ğ‘ƒ.
â€¢ Proverâ€™s second message: ğ‘ƒ computes and sends ğ‘§1 = ğ‘Ÿ1 + ğ‘’ğ‘Ÿ,
ğ‘§2 = ğ‘Ÿ1 + ğ‘’ğ‘š to ğ‘‰ .
â€¢ Verification: Accept if and only if
â€“ ğ‘§1 âˆˆ [0, 240 Ëœğ‘ ğ¶(240 + 1)]
â€“ ğ‘§2 âˆˆ Zğ‘
ğ‘§1
ğ‘ = ğ‘¡1ğ‘ğ‘’
â€“ ğ‘”
1
â€“ pkğ‘§2 ğ‘“ ğ‘§2 = ğ‘¡2(ğ‘2)ğ‘’
E.2 Game-based Threshold Unforgeability
We recall the definition of game-based threshold unforgeaility given
in [8, Sec. 2.2], and specify it to two-party case.
Definition E.1 (Two-party signature unforgeability). Consider a
two-party signature (Keygen, Sign, Verify), and a PPT algorithm
A, having corrupted one of two parties, and which is given the
view of two-party protocols Keygen and Sign on input messages
of its choice (chosen adaptively) as well as signatures on these
messages. Let ğ‘€ be the set of aforementioned messages. The two-
party signature is said to be unforgeable under chosen message
attack if for any such A the probability that A can produce a
signature on a message ğ‘š âˆ‰ ğ‘€ is negligible.
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea573