𝜒𝑎 + ˆ𝜒 ˆ𝑎 to Bob.
• Bob aborts if 𝜒t𝐵 𝑗 + ˆ𝜒ˆt𝐵 𝑗 ≠ b𝑗𝑢 − r𝑗 for any 𝑗 ∈ [1, 2𝜅 + 2𝑠].
• Alice and Bob compute their output shares respectively, i.e.,
𝛼 =𝑗 ∈[1,2𝜅+2𝑠] g𝑗 t𝐴𝑗, and 𝛽 =𝑗 ∈[1,2𝜅+2𝑠] g𝑗 t𝐵 𝑗.
Session 2D: Secure Multiparty Computation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea571D MTA FROM PAILLIER
We recall the MtA protocol from Paillier encryption, which has
appeared many times before [6, 12, 19, 25–27].
Paillier is a well-known additive homomorphic encryption scheme.
Let 𝑝𝑘 = 𝑁 and 𝑠𝑘 = 𝜙(𝑁) be the public and secret keys of Paillier
encryption respectively. Denote the encryption of message 𝑚 with
randomness 𝑟 by Enc(𝑝𝑘, 𝑚, 𝑟) = 𝑟 𝑁 (1+𝑁)𝑚 mod 𝑁 2, the decryp-
tion of ciphertext 𝑐 by Dec(𝑠𝑘, 𝑐). For simplicity, we may eliminate
the randomness 𝑟 and denote encryption as Enc(𝑝𝑘, 𝑚). We denote
by 𝑐1 ⊕ 𝑐2 = 𝑐1𝑐2 mod 𝑁 2 the addition of the plaintext in cipher-
texts 𝑐1 and 𝑐2, and by 𝑎 ⊙ 𝑐 = 𝑐𝑎 mod 𝑁 2 the multiplication of
the plaintext in 𝑐 by a scalar 𝑎.
Zero-knowledge proofs for the following relation are needed for
the Paillier-based MtA.
Proof correct Paillier keypair generation Define the relation
RP = {(𝑁 , 𝜙(𝑁))| gcd(𝑁 , 𝜙(𝑁)) = 1}
of valid Paillier public keys. We remark that standard Paillier is
defined for 𝑁 = 𝑝𝑞 with 𝑝, 𝑞 prime. As did in [25], we only require
gcd(𝑁 , 𝜙(𝑁)) = 1 since all we need is the additive homomorphic
property. The proof ZKPoKRP for RP was proposed in [22, Sec.3.3]
and [25, Appendix A] which (for a soundness error 2−𝑡) requires
3𝑡 Paillier encryption and 4𝑡 GCD computation. Please refer to [25,
Appendix A] for the description of ZKPoKRP.
ZKPoK for Paillier Encryption with Range Proof. Define the
relation
RPwR := {(𝑁 , 𝑞, 𝑐; 𝑚, 𝑟)|𝑐 = 𝑟
𝑁 (1 + 𝑁)𝑥 mod 𝑁 2 ∧ 𝑥 ∈ Z𝑞}
of Paillier encryption with range proof. Lindell [25, Appendix A]
proposed a rather expensive ZKPoK for RPwR based on a proof
from [5, Sec.1.2.2]. Later, Lindell et al. [26], Gennaro and Goldfeder
[19], and Canetti et al. [6] gave an efficient proof with slack under
Strong-RSA assumption and proved that the proof with slack is
enough for MtA. Please refer to D.1 for a ZKPoK for RPwR with
slack.
ZKPoK for Range-Bounded Affine Operation. Define the rela-
tion RAffRan as
{(𝑝𝑘, 𝑞, 𝑐𝐴, 𝑐𝐵; 𝑎, 𝛼)|𝑐𝐴 = 𝑎 ⊙ 𝑐𝐵 ⊕ Enc(𝑝𝑘, 𝛼) ∧ 𝑎 ∈ Z𝑞 ∧ 𝛼 ∈ Z𝐾}
of Paillier encryption with range proof. We may also define the
relation R′AffRan as
{(𝑁 , 𝑞, 𝑐𝐴, 𝑐𝐵; 𝑎, 𝛼)|𝑐𝐴 = (𝑐𝐵)𝑎(1 + 𝑁)𝛼 mod 𝑁 2
∧ 𝑎 ∈ Z𝑞 ∧ 𝛼 ∈ Z𝐾}.
(resp. ZKPoKRAffRan) be the ZKPok proof forR′AffRan
Let ZKPoKR′AffRan
(resp. RAffRan). Please refer to D.2 for this proof with slack.
With those ZKPoKs, the Paillier-based MtA works as in the
following. We remark that all the ZKPoKs are transferred to non-
interactive using the Fiat-Shamir paradigm [18]. Its security relies
on the semantic security of Paillier encryption. As noted by [19,
25], 𝜋𝐴 could be eliminated under the non-standard Paillier-EC
assumption which is recalled in D.3.
In the setup phase,
• 𝑃2 generates a Paillier key-pair 𝑝𝑘 = 𝑁 , 𝑠𝑘 = 𝜙(𝑁).
𝑃2 respectively.
• 𝑃2 computes a ZKPoKRP proof for the correctness of Paillier
public key.
• 𝑃2 sends 𝑝𝑘, ZKPoKRP to 𝑃1 who will verify the proof.
In the multiplication phase, let 𝑎, 𝑏 ∈ Z𝑞 be the input of 𝑃1 and
• 𝑃2 initiates the protocol
– Compute 𝑐𝐵 = Enc(𝑝𝑘, 𝑏) and a ZKPoKRPwR proof 𝜋𝐵.
– Send (𝑐𝐵, 𝜋𝐵) to 𝑃1.
• On receiving 𝑐𝐵, 𝜋𝐵, 𝑃1 do the following
– Verify 𝜋𝐵, and abort if it fails.
– Choose 𝛼′ ← Z𝐾. Set output 𝛼 = −𝛼′ mod 𝑞.
– Compute the ciphertext 𝑐𝐴 = 𝑎 ⊙ 𝑐𝐵 ⊕ Enc(𝑝𝑘, 𝛼′), and
a ZKPoKRAffRan proof 𝜋𝐴 with witness 𝑎, 𝛼′. (or Compute
𝑐𝐴 = 𝑎⊙𝑐𝐵(1+𝑁)𝛼′ mod 𝑁 2), and a ZKPoKR′AffRan
proof
𝜋𝐴.)
– Send (𝑐𝐴, 𝜋𝐴) to 𝑃2.
• Upon receiving (𝑐𝐴, 𝜋𝐴), 𝑃2 do the following
– Verify 𝜋𝐴, and abort if it fails.
– Compute 𝛽′ = Dec(𝑠𝑘, 𝑐𝐴) and output 𝛽 = 𝛽′ mod 𝑞.
D.1 Range Proof for Paillier with Slack under
Strong-RSA Assumption
We recall the range proof for Paillier with slack, i.e. the following
relation RPwR) proposed in [26, Sec.6.2.6].
𝑁 (1 + 𝑁)𝑥 mod 𝑁 2 ∧ 𝑥 ∈ Z𝑞}.
RPwR := {(𝑁 , 𝑞, 𝑐; 𝑚, 𝑟)|𝑐 = 𝑟
The soundness only guarantees that 𝑥 ∈ [−2𝑡+𝑙𝑞,−2𝑡+𝑙𝑞]. As an-
alyzed in [26, Sec. 6.2], the following range proof with slack is
enough for Paillier-based MtA by adding 2𝑡+𝑙𝑞 to 𝑎 and setting
𝐾 = 2𝑡+𝑙+𝑠𝑞2.
Let 𝑡, ℓ, 𝑠 be security parameters. In the implementation, we
set 𝑡 = 𝑠 = 128 and ℓ = 80 for 80 bits statistical security. Let 𝑁0
be the modulus for Pedersen, and 𝑔, ℎ ∈ 𝑄𝑅𝑁0 be random. The
Pedersen commitment of 𝑥 with randomness 𝜌 is 𝑔𝑥ℎ𝜌 mod 𝑁0.
It is assumed that the Paillier modulus 𝑁 was generated by the
Prover and the Pedersen parameters (𝑁0, 𝑔, ℎ) were generated by
the Verifier. We instruct the parties, in the setup phase, to prove in
zero-knowledge that all the parameters were generated correctly.
In the setup phase, the verifier 𝑉 sends the prover 𝑃 parame-
ters 𝑁0, 𝑔, ℎ and zero-knowledge proof that all the parameters are
generated correctly.
• Prover’s first message: 𝑃 chooses 𝜌, 𝛾, 𝜏 ← Z𝑁0, 𝛼, 𝑎 ∈ Z2𝑡+ℓ𝑞,
𝛽 ← Z𝑁 and computes ˜𝐶 = 𝑔𝑥ℎ𝜌 mod 𝑁0, 𝐴 = 𝛽𝑁 (1+𝑁)𝛼
mod 𝑁 2, 𝐵 = 𝑔𝛼ℎ𝛾 mod 𝑁0, and 𝐷 = 𝑔𝑎ℎ𝜏 mod 𝑁0. Then
Prover sends ( ˜𝐶, 𝐴, 𝐵, 𝐷) to 𝑉 .
• Challenge: 𝑉 chooses 𝑒 ∈ {0, 1}2𝑡 and 𝑒1 ∈ Z2𝑡 and sends
them to 𝑃.
• Prover’s second message: 𝑃 computes 𝑧1 = 𝛼 + 𝑒𝑥 (over
the integer), 𝑧2 = 𝛽𝑟𝑒 mod 𝑁 , 𝑧3 = 𝛾 + 𝜌𝑒, 𝑧4 = 𝑎 + 𝑥𝑒1,
𝑧5 = 𝜏 + 𝑒1𝜌. 𝑃 sends (𝑧1, 𝑧2, 𝑧3, 𝑧4, 𝑧5) to 𝑉 .
• Verification: Accept if and only if
2 (1 + 𝑁)𝑧1 = 𝐴(𝐶)𝑒 mod 𝑁 2
– 𝑧𝑁
– 𝑔𝑧1ℎ𝑧3 = 𝐵( ˜𝐶)𝑒 mod 𝑁0
– 𝑧4 ∈ [2𝑡𝑞, 2𝑡+ℓ𝑞)
– 𝑔𝑧4ℎ𝑧5 = 𝐷( ˜𝐶)𝑒1 mod 𝑁0
Session 2D: Secure Multiparty Computation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea572Table 6: The CL encryption scheme.
Enc𝑐𝑙 (pk, 𝑚)
Pick 𝑟 ← [0, 𝑆]
Return (𝑔𝑟
𝑞, pk𝑟 𝑓 𝑚)
Dec𝑐𝑙 (sk, 𝑐1, 𝑐2)
Compute 𝑀 = 𝑐2/𝑐sk
1
Return log𝑓 (𝑀)
D.2 Proof of Paillier-Pedersen Range-Bounded
Affine Operation
We recall the proof for affine operation over Paillier ciphertext in
given range, i.e. for relation R′AffRan) proposed in [26, Sec.6.2.7].
R′AffRan is defined as
{(𝑁 , 𝑞, 𝑐𝐴, 𝑐𝐵; 𝑎, 𝛼)|𝑐𝐴 = (𝑐𝐵)𝑎(1 + 𝑁)𝛼 mod 𝑁 2
∧ 𝑎 ∈ Z𝑞 ∧ 𝛼 ∈ Z𝑞22𝑡+ℓ+𝑠 }
Let 𝑡, ℓ, 𝑠 be security parameters. In the implementation, we
set 𝑡 = 𝑠 = 128 and ℓ = 80 for 80 bits statistical security. The
proof works as follows. In the setup phase, the verifier 𝑉 sends the
prover 𝑃 parameters 𝑁0, 𝑔, ℎ and zero-knowledge proof that all the
parameters are generated correctly. (In our specific usage to MtA,
𝑁0 = 𝑁 since the verifier generates 𝑁 .)
• Prover’s first message: 𝑃 chooses 𝑏 ∈ Z2𝑡+ℓ𝑞, 𝛽 ← Z22𝑡+2ℓ+𝑠𝑞2,
𝐵(1 + 𝑁)𝛽 mod 𝑁 2,
𝜌1, 𝜌2, 𝜌3, 𝜌4 ← Z𝑁 . 𝑃 computes 𝐴 = 𝑐𝑏
𝐵1 = 𝑔𝑏ℎ𝜌1 mod 𝑁 , 𝐵2 = 𝑔𝛽ℎ𝜌2 mod 𝑁 , 𝐵3 = 𝑔𝑎ℎ𝜌3
mod 𝑁 , 𝐵4 = 𝑔𝛼ℎ𝜌4 mod 𝑁 . 𝑃 sends (𝐴, 𝐵1, 𝐵2, 𝐵3, 𝐵4) to
𝑉 .
• Challenge: 𝑉 sends a random 𝑒 ∈ Z2𝑡 to 𝑃.
• Prover’s second message: 𝑃 computes and sends 𝑧1 = 𝑏 + 𝑒𝑎,
𝑧2 = 𝛽 + 𝑒𝛼, 𝑧3 = 𝜌1 + 𝑒𝜌3, 𝑧4 = 𝜌2 + 𝑒𝜌4 to 𝑉 .
• Verification: Accept if and only if
– 𝑧1 ∈ [2𝑡𝑞, 2𝑡+ℓ𝑞)
– 𝑧2 ∈ [22𝑡+ℓ+𝑠𝑞2, 22𝑡+2ℓ+𝑠𝑞2)
– 𝑐
– 𝑔𝑧1ℎ𝑧3 = 𝐵1(𝐵3)𝑒 mod 𝑁
– 𝑔𝑧2ℎ𝑧4 = 𝐵2(𝐵4)𝑒 mod 𝑁
𝐵 (1 + 𝑁)𝑧2 = 𝐴(𝑐𝐴)𝑒 mod 𝑁 2
𝑧1
D.3 Paillier-EC Assumption
The Paillier-EC assumption states the security of encryption even
the adversary is given a restricted oracle. Concretely, it says that
any PPT adversary A can only win the following experiment (i.e.
the experiment outputs 1) with 1/2 plus a negligible probability.
• Generate a Paillier key pair (𝑝𝑘, 𝑠𝑘)
• Choose 𝑤0, 𝑤1 ← Z𝑞 and compute 𝑄0 = 𝑤0 · 𝑃
• Choose a random 𝑏 ← {0, 1} and compute 𝑐 = Enc(𝑝𝑘, 𝑤𝑏)
• Let 𝑏′ = AO(·,·,·)(𝑝𝑘, 𝑐, 𝑄0), where O(𝑐, 𝑎, 𝑏) = 1 iff Dec(𝑐) =
𝑎 + 𝑏𝑤𝑏 mod 𝑞 and the oracle O holds once it returns 0.
• The experiment returns 1 if and only if 𝑏′ = 𝑏.
E THE CL-ENCRYPTION, ZKPOK FOR
CL-ENCRYPTION AND GAME-BASED
THRESHOLD UNFORGEABILITY.
We recall the CL encryption [9] and ZKPoK for CL encryption from
[8].
Let (˜𝑠, 𝑓 , ˆ𝑔𝑞, 𝑔𝑞, ˆ𝐺, 𝐹, 𝑞) be public parameters of CL encryption
(as defined in [8]), where 𝐹 = ⟨𝑓 ⟩ is the subgroup of ˆ𝐺 with order 𝑞,
𝑔𝑞 is a random element in ⟨ ˆ𝑔𝑞⟩. Denote by sk, pk = 𝑔sk𝑞 secret-public
key pair. CL encryption and decryption works as Table 6, where 𝑆
is an integer to be determined.
We denote by 𝑐 ⊕ ˆ𝑐 the addition of the plaintext in ciphertexts
𝑐 and ˆ𝑐, and by 𝑎 ⊙ 𝑐 the multiplication of the plaintext in 𝑐 by a
scalar 𝑎.
E.1 ZKPoK for correctness of CL encryption
We recall the zero-knowledge argument of knowledge for correct-
ness of ciphertext from [8]. Define relation
𝑅CL := {(pk, 𝑐1, 𝑐2; 𝑚, 𝑟)|pk ∈ ˆ𝐺, 𝑟 ∈ [0, 𝑆],
𝑞 ∧ 𝑐2 = pk𝑟
𝑟
𝑐1 = 𝑔
𝑓
𝑚}.
Let C be the challenge space and 𝐶 = |C|. In the setup, the prover
should send public parameters to verifier and proves 𝑔𝑞 is a random
element of ⟨ ˆ𝑔𝑞⟩ (using the proof given in [8, Sec. 3.2]).
• Prover’s first message: 𝑃 chooses 𝑟1 ← [0, 280 ˜𝑠𝐶], 𝑟1 ← Z𝑞,
𝑟1
𝑞 , 𝑡2 = pk𝑟1 𝑓 𝑟1. 𝑃 sends (𝑡1, 𝑡2) to 𝑉 .
computes 𝑡1 = 𝑔
• Challenge: 𝑉 sends a random 𝑒 ← C to 𝑃.
• Prover’s second message: 𝑃 computes and sends 𝑧1 = 𝑟1 + 𝑒𝑟,
𝑧2 = 𝑟1 + 𝑒𝑚 to 𝑉 .
• Verification: Accept if and only if
– 𝑧1 ∈ [0, 240 ˜𝑠𝐶(240 + 1)]
– 𝑧2 ∈ Z𝑞
𝑧1
𝑞 = 𝑡1𝑐𝑒
– 𝑔
1
– pk𝑧2 𝑓 𝑧2 = 𝑡2(𝑐2)𝑒
E.2 Game-based Threshold Unforgeability
We recall the definition of game-based threshold unforgeaility given
in [8, Sec. 2.2], and specify it to two-party case.
Definition E.1 (Two-party signature unforgeability). Consider a
two-party signature (Keygen, Sign, Verify), and a PPT algorithm
A, having corrupted one of two parties, and which is given the
view of two-party protocols Keygen and Sign on input messages
of its choice (chosen adaptively) as well as signatures on these
messages. Let 𝑀 be the set of aforementioned messages. The two-
party signature is said to be unforgeable under chosen message
attack if for any such A the probability that A can produce a
signature on a message 𝑚 ∉ 𝑀 is negligible.
Session 2D: Secure Multiparty Computation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea573