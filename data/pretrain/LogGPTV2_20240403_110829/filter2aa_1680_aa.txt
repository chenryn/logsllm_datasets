Breaking Secure Bootloaders
Talk Outline
Smartphones often use signature verification to protect their firmware
This is implemented in bootloaders, which can also provide facilities for firmware updates
Weaknesses in these update protocols can be exploited to bypass signature protections
The core SoC and peripheral chips are both potential targets for attack
Biography
Christopher Wade
Security Consultant at Pen Test Partners
@Iskuri1
https://github.com/Iskuri
https://www.pentestpartners.com
Project One – The SDM660 Android Bootloader
I had purchased an Android phone to do mobile research
I needed root access in order to use all of my testing tools
This required unlocking the bootloader, which disables signature verification protection
This required an unlock tool from the manufacturer
Custom Bootloader Unlock Functionality
Some smartphone manufacturers modify the bootloader to require custom tools for 
bootloader unlocking, or to remove bootloader unlocking entirely
This often requires creating a user account and waiting for a period of time
Unlocks are performed using custom USB fastboot commands
There are numerous reasons why these restrictions are placed on their hardware:
• Inexperienced users will not be tricked into deliberately weakening phone security
• Third parties can’t load the devices with malware before sale
• The manufacturer can track who is unlocking their bootloaders
Common Android Bootloader Protection
Analysis of an unlock on the phone was performed using 
USBPCAP
An 0x100 byte signature was downloaded from the 
manufacturer’s servers and sent to the phone
This was verified by the bootloader, which unlocked its 
restrictions
I decided to use an older phone to analyse this functionality
I set myself a challenge to break this functionality before the 
end of the seven day waiting period
Target Device
Mid-range phone released in 2017
Uses a Qualcomm Snapdragon 660 chipset – ARM64 architecture
I had previously unlocked the bootloader, but could lock it again for the project
Bootloader had been modified to add further custom functionality
Fastboot
Command interface for most Android bootloaders
Uses a basic USB interface – commands and responses are raw text
reboot
flash:
download:
oem device-info
oem unlock
etc
Implementing Fastboot
Easy to implement using standard USB libraries
Sends ASCII commands and data via a USB bulk 
endpoint
Returns human-readable responses back 
asynchronously via a bulk endpoint
Libraries exist for this purpose, but are 
unnecessary
ABL Bootloader
Provides Fastboot USB interface
Verifies and executes Android Operating System
Accessed via ADB, or button combinations on boot
Stored in “abl” partition on device
Qualcomm’s base bootloader has source code available, but can be modified by vendors
Analysing The Bootloader
Bootloader is stored as an ELF file in partition
This contains no executable code, but does contain a UEFI filesystem
This could be extracted with the tool “uefi-firmware-parser”, to find a Portable Executable
These can be directly loaded into IDA
Analysing The Bootloader - Commands
Fastboot commands are stored in a table as text 
commands and function callbacks
This can aid in identifying any hidden or non-standard 
commands
Changes in functionality of commands is also easy to 
identify
Logging strings in code help with identifying 
functionality
Identifying A Potential Bootloader Weakness
The “flash:” command usually only flashes partitions on unlocked bootloaders
The command had been modified by the manufacturer to allow flashing of specific custom 
partitions when the bootloader was locked
These partitions were handled differently from those implemented directly by Qualcomm
There was potential for memory corruption or partition overwrites in this custom functionality
Implementing the flash: command
I made assumptions about the command sequence:
I accidentally left an incorrect “flash:” command after my command sequence
This resulted in the bootloader crashing after sending this second “flash:” command
The lack of a “download:” command before the payload was the likely cause
Actual command sequence:
• download:
• 
• flash:
My command sequence:
• flash:
• 
Analysis Of Crash
USB connectivity stopped functioning entirely
The phone required a hard reset – volume down + power for ten seconds
A smaller payload size was attempted – this did not crash the phone
A binary search approach was used to identify the maximum size without a crash
By rebooting the phone and sending sizes between a minimum and maximum value, the 
minimum size was found - 0x11bae0
Overwriting Memory
Due to the unusual memory size, this was assumed to be a buffer overflow
With no debugging available for the phone, identifying what memory was being overwritten 
would be difficult
The bootloader used stack canaries on all functions, which could potentially be triggered
The next byte was manually identified – 0x11bae1 bytes of data were sent, and the last byte 
value was incremented, if the phone didn’t crash it was valid
The next byte was identified to be 0xff
Overwriting Memory
By constantly power cycling, incrementing the byte value, and moving to the next byte in 
the sequence, a reasonable facsimile of the memory could be generated
This would not be the exact memory in use, but enough to not crash the bootloader
Once this was generated, it could potentially be modified to gain code execution
A way of automating this process to retrieve more bytes was required
Automated Power Cycling
It was suggested that removal of the phone battery and a 
USB relay could automate power cycling the phone
This would require removing glue from the phone case to 
access the battery
Instead, a hair tie was wrapped around the power and 
volume down buttons
This caused a boot loop which allowed USB access for 
sufficient time to test the overflow
Memory Dumping
The custom fastboot tool was modified to attempt this memory dumping
It verified two key events – a “flashing failed” response from the command being sent to 
the phone, and whether it crashed afterwards
Each iteration took 10-30 seconds
Memory Dumping
The phone was left overnight performing this loop
This generated 0x34 bytes of data which did not crash the phone
The repeated byte values and lack of default stack canary meant 
that this was likely not to be the stack
All of the 32-bit words were found to be valid ARM64 opcodes
FF 43 02 51 
60 02 00 0C 
60 02 00 0C 
60 02 00 0C 
60 02 00 0C 
E8 00 00 B0 
34 00 00 10 
01 00 00 0A 
08 0D 40 F9 
00 00 00 08 
C0 00 04 0B 
60 02 00 0A 
D3 9F FF 97 
Unknown Memory Analysis
Most opcodes, while valid operations, would not be the same as in the bootloader
Stack management and branch operations would have to be almost exact
Searching for the “SUB WSP” and “BL” opcodes in the bootloader yielded no results
ARM64 Features
ARM64 operations can often have unused bits flipped without altering functionality
Registers can be used in both 32-bit (Wx) and 64-bit (Xx) mode
Branch instructions can have conditions for jumping
These features could superficially allow for changes to the stack and branch handling 
instructions without altering functionality
Identifying Similar Instructions
I decided to use the “BL” instruction, it was likely to be less common than the stack
I performed a text search, removing the first nybble from the opcode
This would find branches in a similar relative address space to the dumped opcode
This identified a single valid instruction in the “crclist” parser, and opcodes that were similar 
to the memory dump
Outline Of Buffer Overflow
Analysis of the offsets showed that the bootloader was overwritten after 0x101000 bytes 
of data
The bootloader is executed from RAM, as demonstrated by this overflow 
The original bootloader binary, found in the partition, could be fully written using the 
overflow to prevent any subsequent crashes
This binary could be modified to run any required unsigned code
Unlocking The Bootloader
To unlock the bootloader, it was necessary to jump to the 
code after the RSA check
A simple branch instruction could be generated to jump to 
the relative address of the bootloader unlock function
Online ARM64 assemblers are available to rapidly generate 
these opcodes
This process would be difficult to debug, but 
success would be easy to identify
Buffer Overflow Implications
Rooting the phone and deploying custom recovery images would now be possible
Qualcomm chips can encrypt the “userdata” partition on locked bootloaders, even 
without a password – unlocking the bootloader completely disallows access to this data
Some limited RAM dumping would be possible with this code execution and cold boot 
attacks, but would not allow access to any user data
Development, analysis and exploitation was achieved over four days
Attempts to replicate the vulnerability on the newer phone, using an SDM665, were not 
effective
Replicating The Vulnerability
I was able to procure a second smartphone which also used an SDM660
All bootloader unlocking functionality was disabled by the manufacturer on this device
It was identified to use a similar signature verification approach to the original phone
Custom Bootloader Unlock
Using an OTA image, the bootloader was analysed
This showed the code which blocked the bootloader 
unlock
No hidden bootloader commands were identified on 
the device, however some OEM commands were noted
Differences In Memory Layout
Initially, the old crash was attempted
The device still functioned, implying the vulnerability may not be present
A much larger payload size was sent – 8MB
This crashed the phone, implying that the memory layout was different to the original
Manual analysis demonstrated that the bootloader was overwritten after 0x403000 bytes, 
different to the 0x101000 on the first device
With this, a bootloader unlock could be rapidly developed
Patching Bootloader Unlock
A single branch instruction was identified, which sent an error response or unlocked the 
bootloader, depending on whether the signature was accurate
This could be replaced with a NOP instruction, bypassing this check
This allowed the bootloader to be unlocked, 
and the phone to be rooted
The vulnerability was disclosed directly to 
Qualcomm, due to its potential 
existence on all SDM660 based phones
Removing Unauthorised Bootloader Access
Bootloader access is not required for users in contexts where unlocking is not permitted
It is possible to disable fastboot access entirely in order to prevent attacks against it
Fastboot can then be reactivated via Engineering apps in the main Android OS
Manufacturers who disable bootloader unlocking by consumers often use this approach
Reading Back Memory
The “download:” function could be patched to return 
memory from arbitrary addresses
This could read back the bootloader code, stack and 
heap, but could not read arbitrary memory
This restricted the potential for any cold boot attacks on 
memory
Bypassing Qualcomm’s Userdata Protection
Qualcomm’s chips encrypt the “userdata” partition, even when no passwords or PINs are 
used
This prevents forensic chip-off analysis, and access to users’ data via bootloader unlocking
If an unlocked bootloader tries to access the partition, it is identified as being “corrupted” 
and is formatted
Bypass of this protection could allow access to user data via physical access
Bypassing Qualcomm’s Userdata Protection
Using Qualcomm’s source code, this encryption process could be analysed
Encryption keys are intentionally inaccessible, even with code execution
The code uses an internal EFI API to decrypt the partition, which was unmodifiable
The API verifies whether it is unlocked, and whether the firmware is signed
Time Of Check To Time Of Use