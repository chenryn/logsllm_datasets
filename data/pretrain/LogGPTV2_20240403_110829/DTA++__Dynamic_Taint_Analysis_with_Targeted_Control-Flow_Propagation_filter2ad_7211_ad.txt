# 优化后的文本

## 执行跟踪与隐式流分析

### 隐式流执行跟踪示例
- **WordPad中的隐式流执行跟踪**
  - `%ax = 0x007b` (未受污染)
  - `%dl = 0x7b` (未受污染)
  - `0x4b44dacb`
  - `%edi = 0x4b4043a0` (未受污染), `%ecx = 0x4b4043a2` (未受污染)
  - 图7. WordPad中隐式流的执行跟踪

- **AbiWord中的隐式流执行跟踪**
  - `0x101eb130: movsbl %bl, %eax`
  - `0x101eb133: sub $0x26, %eax`
  - `0x101eb136: je 0x101eb13c`
  - `0x101eb13c: sub $0x16, %eax`
  - `0x101eb13f: je 0x101eb20e`
  - `0x101eb20e: push $0x10281978`
  - `%bl = 0x3c` (受污染)
  - `%eax = 0x0000003c` (受污染)
  - `%eax = 0x00000016` (受污染)
  - 图8. AbiWord中隐式流的执行跟踪

### 污点传播与约束公式
在使用污点创建路径约束的符号值时，如果通过受污染的索引访问数组，则从数组中复制的值也应标记为符号。最精确的方法是在访问时将整个数组内容复制到约束公式中，但这存在实际问题：
1. 在二进制级别上确定数组边界通常很困难。
2. 大型查找表会使公式过大或求解时间过长。

因此，在我们的实现中，我们将从符号输入读取的值视为自由变量，即没有约束的新输入值。这种放松可能会导致工具错过一些隐式流，但在我们的实验中这不是问题。我们将在未来的工作中解决如何更准确地处理这种传播的问题。

### 符号间接跳转
当污点传播到间接跳转使用的地址时，也可能会发生类似的情况。类似于上述符号索引的情况，很难符号化表示所有可能的跳转行为，并且它们在控制流图的构建中也是有问题的。尽管我们在任何示例中都没有遇到受污染的间接跳转，但它们最有可能出现在用于实现switch语句的跳转表中。对于这种情况，识别常见的switch语句指令模式可能是可行的。

### 负向隐式流
负向隐式流是指受污染的控制流影响后续数据，因为某个值未被修改。一些作者将“隐式流”一词保留给这种情况；而我们将其称为负向隐式流。图9展示了这种流动如何在文本转换中发生，它模仿了我们在CryptEdit中观察到的代码。

负向隐式流可以通过我们的技术进行诊断，但需要更复杂的方法来生成传播规则。不仅要在分支内写入的位置进行污点标记，还要分析如果分支未被采取时可能写入的值（例如，图9中缺失的i增量）并对其进行污点标记。当前实现仅在这些情况与循环退出条件相关时处理，我们应用了BitBlaze的循环扩展符号执行实现。未来我们计划扩展实现以处理更多负向隐式流，至少在最常见的非嵌套分支、数组或间接引用的情况下。

### 动态方法的局限性
与静态分析不同，动态方法只能诊断我们在程序执行实例中观察到的污点不足问题。这意味着动态方法无法探索程序的所有可能执行路径，从而遗漏了一些污点不足问题。然而，静态方法往往受限于可能的程序状态和路径约束的复杂性。

我们认为基于测试用例的动态方法在这种领域是实用的，因为导致污点不足的代码位置相对较少，并且污点不足是由代码结构引起的，不需要复杂的先决条件触发。这些直觉得到了我们案例研究的支持。另一种可能性是应用测试生成技术，例如使用符号执行或其他技术自动探索新路径并检查其是否存在污点不足。

### 前向与后向方法
我们的诊断技术基于从输入数据开始的污点传播信息，因此在某种程度上是一种前向切片。然而，由于我们可以获取整个执行跟踪并知道输出数据的哪部分应该被污点标记，也可以反向进行。当我们发现一个预期被污点标记但实际上未被污点标记的输出字节时，可以尝试从接收端进行后向切片以追踪回相应的污点输入数据。然而，后向切片不能解决本文关注的隐式流问题。在切片文献中，相同的程序构造通常被称为控制依赖关系，它们在切片中也会引起类似的难题：忽略控制依赖关系会导致切片太小，而包括所有控制依赖关系则会导致切片太大。如何平衡这些权衡也是切片研究的主题，产生了如“薄切片”等方法。

在实际层面，对我们来说，前向分析比后向分析的一个关键优势是，前向污点传播可以在原始前向执行的同时进行，因此我们的执行跟踪只需要记录受污染的指令。后向切片需要完整的执行跟踪，这会大得多：在某些示例中超过1GB。

### 恶意软件组件
尽管我们只评估了良性应用程序，但恶意软件组件中的隐式流也可能导致污点不足。例如，这种污点不足可能会影响Panorama等恶意软件分析平台的使用。然而，这些问题更难解决，因为恶意软件作者可以故意生成和嵌入大量条件分支，引发受污染输入数据的隐式流。至少，这违反了我们的假设，即隐式流相对罕见，使我们提出的技术变得不切实际。此外，当前实现的其他特性也可能被利用以产生误报或漏报错误。据我们所知，这些逃避技术尚未在野外出现，但如果恶意软件作者认为有必要，它们不会很难实现。这表明系统应该区分已知良性的软件组件和可能恶意的组件，并对潜在恶意组件应用不同的、更保守的污点传播策略。

## 结论
我们提出了DTA++，一种增强的动态污点分析技术，它还沿着目标子集的控制流依赖关系传播污点。DTA++允许动态污点分析在数据转换中发生隐式流时避免污点不足。通过诊断罪魁祸首的隐式流并在信息保持转换中进行额外传播，DTA++解决了污点不足而不引起过度污点。我们展示了DTA++如何应用于现成的Windows二进制文件。在一个涉及8个应用程序的案例研究中，DTA++防止了可能导致错误结果的污点不足，同时引入的污点量比以前的系统（如DYTAN）少几个数量级。

## 致谢
感谢Kevin Chen、Daniel Reynaud和Aravind Iyer对本文提出的改进建议。Min Gyung Kang和Pongsin Poosankam在UC Berkeley访学期间完成了这项工作。该材料部分由美国国家科学基金会、空军科学研究办公室、陆军研究办公室和海军研究办公室资助。本文的观点、发现和结论或建议仅代表作者个人观点，不代表资助机构的观点。