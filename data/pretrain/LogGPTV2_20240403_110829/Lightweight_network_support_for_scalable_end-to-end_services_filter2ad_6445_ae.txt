collision were handled through chaining, while new bindings
used the next pointer and the cleaner used the last pointer.
A separate thread was scheduled to periodically (e.g. every
tenth of a lifetime) check whether the entry pointed to by the
last pointer had expired. To measure performance when the
hash table becomes full, we artiﬁcially loaded the table and
then measured its performance. As expected, the latency of
the ﬁnd() operation depends on the chain size in the hash
table (Table 1). Table 1 shows the cost of the ESS func-
tions for the SRAM implementation when the hash table
is essentially empty (i.e., chain lengths of 1). Since the ac-
tual access time depends on the length of the chain, we also
show the number of memory accesses required as a function
of the chain length cl. The find create() only takes ﬁve
more 32-bit access than find() because the hash table and
the tag/data table must both be modiﬁed. The simplicity of
ESP instructions means that the majority of the processing
costs are attributed to ESS performance. As shown here,
our initial numbers indicate that the ESS is capable of op-
erating near or at linespeeds.
We also measured performance using diﬀerent size hash
tables. In particular, we tried h ratios ranging from 0.5 to
2 (h = hash table size/tag table size). Fig. 11 shows the
eﬀect that diﬀerent hash table and tag table sizes have on
the ﬁnd() performance. Our results show that even when
the store is full, the average access time remains constant if
the hash table has twice as many entries as the data table.
Even when the hash table is only half the size of the data
table, the average access time still remains below 3 µsec per
packet.
ESS calls
ﬁnd()
ﬁnd create()
read()
write()
0.5 µsec
1.4 µsec
0.1 µsec
0.1 µsec
Time
Number of 32-bit
using SRAM Memory Accesses
5 × cl
5 + 5 × cl
2
2
Table 1: Access times for ESS operations. cl=Chain
Length
hash table size = 1/2 x tag table size
hash table size = tag table size
hash table size = 2 x tag table size
4
3.5
3
2.5
2
1.5
1
0.5
)
c
e
s
u
(
y
c
n
e
t
a
l
)
(
d
n
i
f
0
0
0.2
0.4
Fraction of ESS Occupied
0.6
0.8
1
Figure 11: The average ﬁnd() function latency when
fraction of the ESS is ﬁlled
The IXP1200 provides diﬀerent access capability to SRAM
and SDRAM memory. The SRAM has a 32-bit wide bus and
runs at the core clock frequency (232MHz). The SDRAM
has a 64-bit wide bus and operates at half of the SRAM fre-
quency (116MHz). The SRAM’s fast access is intended for
crucial router state such as the routing table. The SDRAM’s
wider bus is designed for packet I/O and buﬀering. Al-
though smaller in size, the IXP1200’s SRAM oﬀers the per-
formance we desired for ESS storage and with up to 8 MB
of space was suﬃciently large to support a reasonable-sized
prototype ESS. However, for comparison we measured the
performance of our ESS design using the SRAM and then
the SDRAM.
Functions
compare
count
Avg. Latency (µsec)
SRAM SDRAM SRAM & SDRAM
3.98
2.62
6.49
3.54
4.99
3.47
Table 2: Latency of various ESS operations with
ESS located in SRAM, SDRAM or both
Table 2 shows the latency ESP instructions incur. These
measurements are taken on the StrongARM processor and
factor out the cost of transferring data to/from the core, so
they are representative of what we expect to see if they were
executed at the µengine level.
The table also shows the instruction latency when ESS
is implemented in diﬀerent levels of the memory hierarchy.
As we expected, the SRAM implementation performed the
best. The SDRAM implementation did not perform as well
since SDRAM data is transferred in 64-bit blocks (32-bit for
276SRAM) at half of the SRAM frequency. In many cases, the
ESS access is to data smaller than 64 bits. To fully utilize
the speed of the SRAM, as well as the size of the SDRAM,
we placed part of the ESS on the SRAM (the hash table)
and the other part on the SDRAM (the tag table). Because
access to the tag table usually involves larger than 32-bit
reads, SDRAM seems to be more suitable for the tag table.
Although the performance is not as good as the SRAM-only
implementation, it trades oﬀ the beneﬁt of a larger ESS for
slightly slower access times.
Functions
compare
count
Throughput (Kpps)
SRAM SDRAM SRAM & SDRAM
232
340
146
259
188
263
Table 3: Estimated Throughput of ESP instructions
We also measured certain costs of processing on the µengine,
namely the ESP packet classiﬁcation and the hardware hash
operations performed on tags. We used the cycle-accurate
hardware emulator provided by the IXP1200. The µengine
processing times averaged 75 cycles per packet (about 0.32
microseconds). Based on this number and the latency in-
formation from Table 2, the estimated packet rates for vari-
ous ESP instructions in terms of number of minimum-sized
packets per second processed are shown in Table 3.
We are currently pushing the code completely into the
µengines in order to avoid the performance penalty of trans-
ferring data to the core for processing. Our prototype imple-
mentation did not take advantage of some µengine features
that would almost certainly increase the eﬀective through-
put, including multiprocessing, hardware multithreading, and
optimized memory access. Nevertheless, our preliminary
measurements show that ESP processing can support band-
widths of up to 169 Mbps, even going through the Stron-
gARM core.
7. RELATED WORK
A number of research eﬀorts have aimed to place some
form of extended function or programmability in the net-
work. Compared to ESP, these generally either target more
speciﬁc end-to-end services, or provide “heavyweight” com-
putational capabilities oﬀering greater computational power.
The PGM [5] and BCFS [30] protocols extend router func-
tionality speciﬁcally to support end-to-end reliable multi-
cast. Generic Router Assist (GRA) [2] is a set of capabilities
intended to generalize these protocols to support other ser-
vices. These protocols use soft-state techniques to maintain
and process state information for multicast sessions. This
state information can be used for, among other things, sub-
casting and NACK suppression. In its current state, GRA
is more narrowly focused than ESP, and does not share its
scalability characteristics.
Protocol boosters [4] was an early eﬀort to place support
for end-to-end services in the network. Unlike ESP, pro-
tocol boosters could operate on all parts of the packet, and
could generate packets in the middle of the network. Among
the example applications was on-the-ﬂy addition of payload
redundancy for forward error correction.
Active networks oﬀer an alternative model of network pro-
grammability. For example, ANTS [29] provides users with
more or less complete control of packet processing, by as-
sociating a program to each packet, or capsule. ANTS also
allows packets to deposit and retrieve information in an as-
sociative store for a limited time; however, the time bound
is not ﬁxed as in ESP, but depends on other factors such as
distance traveled by the packet. Overall, the design goals
of ANTS are oriented more toward ﬂexibility than those of
ESP.
SNAP [13] allows packets to carry small programs ex-
pressed in a restrictive programming language that ensures
that the computing resources consumed by a packet are
strictly bounded. SNAP’s focus is more on computing re-
sources than storage, however. It does not explicitly provide
for packets to exchange information in the network.
Some active network services target speciﬁc needs, espe-
cially for group applications. The concast service [3] pro-
vides a many-to-one communication channel in which in-
formation sent to a common destination from the group is
combined in routers along the way, according to a merge
speciﬁcation supplied by the receiver. Compared to the sim-
ple packet elimination capabilities possible with ESP, con-
cast can perform more complicated (heavyweight) packet
manipulation, possibly generating completely new and dif-
ferent sized payloads.
The “Smart Packets”project from BBN [21] applies active
network technology to the problem of network management;
it also focused on a small set of primitives to be invoked
by packets. However, the designers of the Smart Packets
mechanism explicitly ruled out having packets leave state at
a node; thus while computations may involve multiple nodes
they cannot involve multiple packets.
8. CONCLUSIONS
We have proposed a new approach to placing support for
end-to-end services inside routers. Ephemeral state process-
ing is a building-block service designed under minimal as-
sumptions about applications. A key aspect of our design is
the use of an associative store with a ﬁxed lifetime. This con-
straint beneﬁts the network by ensuring that state resources
are freed at the same rate they are allocated; this makes it
possible to build stores that can process allocation requests
at “wire speed”. It beneﬁts the user (service designer) by
ensuring that all trace of a computation disappears from the
network within a ﬁxed time.
We have designed ESP to be implemented on, or near, the
fast path of a modern router, and to have scalability and
robustness characteristics similar to those of the Internet
Protocol. Our experience with an initial prototype imple-
mentation on the IXP1200 network processor suggests that
ESP should easily be able to process packets at line speeds
in excess of hundreds of megabits per second. By exploiting
available parallelism, pipelining, and special-purpose hard-
ware, we expect performance can be increased substantially
beyond that.
Our current design is based on a small set of parameter-
ized instructions that suﬃce for a broad set of end-to-end
services that are primarily of an auxiliary nature. However,
we expect that as new ways to use ESP are found, the need
for new instructions will arise. This brings up the question
of how to add new instructions once ESP is deployed. One
possibility would be to allow packets to carry “microcode”—
perhaps coded in a restricted language like SNAP [13]—
which would be interpreted at each node. However, it is not
277[14] Christos Papadopoulos, Guru Parulkar, and George
Varghese. An Error Control Scheme for Large-Scale
Multicast Applications. In Proceedings of the INFOCOM
’98 Conference, 1998.
[15] K. Park and H. Lee. On the Eﬀectiveness of Route-Based
Packet Filtering for Distributed DoS Attack Prevention in
Power-Law Internets. In ACM SIGCOMM, San Diego, CA,
August 2001.
[16] S. Paul, K. Sabnani, J. Lin, and S. Bhattacharyya. Reliable
Multicast Transport Protocol (RMTP). The IEEE Journal
on Selected Areas of Communication, 1996. (see also the
Proceedings of IEEE INFOCOM’96).
[17] Vern Paxson. End-to-end routing behavior in the Internet.
IEEE/ACM Transactions on Networking, 5(5):601–615,
1997.
[18] K. K. Ramakrishnan, S. Floyd, and D. Black. The Addition
of Explicit Congestion Notiﬁcation (ECN) to IP,
September 2001. RFC 3168.
[19] S. Savage, D. Wetherall, A. Karlin, and T. Anderson.
Practical Network Support for IP Traceback. In ACM
SIGCOMM, Stockholm, Sweden, August 2000.
[20] H. Schulzrinne, S. Casner, R. Frederick, and V. Jacobson.
RTP: A Transport Protocol for Real-time Applications,
January 1996. RFC-1889.
[21] Beverly Schwartz, Wenyi Zhou, Alden Jackson,
W. Timothy Strayer, Dennis Rockwell, and Craig
Partridge. Smart Packets for Active Networks. ACM
Transactions on Computer Systems, 18(1), February 2000.
[22] Jonathan Shapiro, Jim Kurose, Don Towsley, and Stephen
Zabele. Topology discovery service for router-assisted
multicast transport. In IEEE OpenArch 2002, New York,
June 2002.
[23] S. Sikka and G. Varghese. Memory-Eﬃcient State Lookups
with Fast Updates. In ACM SIGCOMM, Stockholm,
Sweden, August 2000.
[24] A.C. Snoeren, C.E. Jones, F. Tchakountio, S.T. Kent, and
W.T. Strayer. Hash-Based IP Traceback. In ACM
SIGCOMM, San Diego, CA, August 2001.
[25] Ion Stoica, Dan Adkins, Shelley Zhuang, Scott Shenker,
and Sonesh Surana. Internet Indirection Infrastructure. In
SIGCOMM 2002, Pittsburg, PA, August 2002.
[26] Ion Stoica, T.S. Eugene Ng, and Hui Zhang. REUNITE: A
Recursive Unicast Approach to Multicast. In IEEE
INFOCOM, pages 1644–1653, Tel-Aviv, Israel, March 2000.
[27] Su Wen, James Griﬃoen, and Kenneth Calvert. Building
Multicast Services from Unicast Forwarding and Ephemeral
State. Computer Networks, 38(3):327–345, February 2002.
[28] Su Wen, James Griﬃoen, and Kenneth Calvert. CALM:
Congestion-Aware Layered Multicast. In IEEE OpenArch,
New York, June 2002.
[29] David Wetherall. Active network vision and reality:
Lessons from a capsule-based system. In 17th ACM
Symposium on Operating Systems Principles (SOSP),
Kiawah Island, SC, December 1999.
[30] Koichi Yano and Steven McCanne. The Breadcrumb
Forwarding Service: A Synthesis of PGM and EXPRESS to
Improve and Simplify Global IP Multicast. ACM Computer
Communication Review, 30(2), April 2000.
at all clear that such ﬂexibility is necessary. An alterna-
tive would be to extend the instruction set through a formal
standardization process. This would allow the ﬂexibility and
simplicity of the instruction set to be carefully maintained.
In either case, allowing the instruction set to be extended
provides for the ESP service to evolve over time.
In addition to various engineering choices that should be
evaluated through experience—the particular value of τ , the
size of stored values, and so forth—we ﬁnd some further is-
sues worthy of future study. One is dynamic adaptation
of robust ESP computations to network conditions, so that
they use network resources (bandwidth and storage) as ef-
ﬁciently as possible. Another is the development of a secu-
rity architecture for ESP that provides enhanced protection
while preserving the lightweight nature of the service.
Although we are optimistic that ESP is both sound in de-
sign and useful in application, it represents just one point
on a spectrum of approaches to extending network function-
ality. We hope others will both consider additional ways to
use ESP and also explore diﬀerent parts of that spectrum.
Acknowledgements
This paper has beneﬁted greatly from the constructive com-
ments of the anonymous referees and especially our shep-
herd, David Wetherall. The authors also acknowledge with
thanks the technical support of the IXP1200 group at Intel
Architecture Labs.
9. REFERENCES
[1] Burton Bloom. Space/time trade-oﬀs in hash coding with
allowable errors. Communications of the ACM,
13(7):422–426, July 1970.
[2] Brad Cain, Tony Speakman, and Don Towsley. Generic
router assist (GRA) for multicast transport protocols, June
2002. Internet Draft (work in progress).
[3] K. Calvert, J. Griﬃoen, B. Mullins, A. Sehgal, and S. Wen.
Concast: Design and implementation of an active network
service. IEEE Journal on Selected Areas of
Communications, 19(3):426–437, March 2001.
[4] D.C. Feldmeier et al. Protocol boosters. IEEE Journal on
Selected Areas of Communications, 16(3):437–444, April
1998.
[5] T. Speakman et al. PGM Reliable Transport Protocol
Speciﬁcation. RFC 3208, December 2001.
[6] Sally Floyd, Van Jacobson, Ching-Gung Liu, Steven
McCanne, and Lixia Zhang. Reliable Multicast Framework
for Light-weight Sessions and Application Level Framing.
In ACM SIGCOMM, Cambridge, MA, September 1995.
[7] Michael Hicks, Pankaj Kakkar, T. Moore, Carl A. Gunter,
and Scott Nettles. PLAN: A Packet Language for Active
Networks. 1998. International Conference on Functional
Programming.
[8] H. Holbrook and B. Cain. Source-speciﬁc multicast for IP,
November 2001. Internet Draft (work in progress).
[9] Hugh W. Holbrook and David R. Cheriton. IP Multicast
Channels: EXPRESS Support for Large-Scale Single
Source Applications. In ACM SIGCOMM, Cambridge, MA,
August 1999.
[10] John Janotti. Network Layer Support for Overlay
Networks. In IEEE OpenArch, New York, June 2002.
[11] D. Katz. IP router alert option, February 1997. RFC 2113.
[12] S. Kent and R. Atkinson. IP encapsulating security payload
(ESP), November 1998. RFC 2406.
[13] Jonathan T. Moore, Michael Hicks, and Scott Nettles.
Practical Programmable Packets. In IEEE INFOCOM,
Anchorage, AK, April 2001.
278