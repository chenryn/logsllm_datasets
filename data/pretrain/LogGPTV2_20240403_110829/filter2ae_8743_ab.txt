没能弄清为什么这个目录表现为空后，我们做了另一个尝试。
首先，我们检查了与硬盘上的/Core/关联的分区：
下一步是使用Linux“dd”实用程序拍摄这个分区的图像，这个实用程序会完全忽略文件系统，并获取分区的原始映像，将其保存到本地文件中。
最后，应用一种称为“file
carving”的技术，这种技术通常用于硬盘部分发生故障或文件系统已损坏时的数据恢复。我们使用的工具称为“scalpel”，指定一个配置文件，它可以“分解”在原始磁盘图像“image.bin”中找到的任何可疑的DLL文件。结果看来有数百个DLL文件，其中许多是无效的，并且所有文件都有一个数字而不是文件名：
由于我们最感兴趣的是.NET
DLL的文件，因此可以使用“monodis”工具来尝试反汇编每个DLL，只打印有效的DLL文件及其名称列表。虽然脚本的输出很混乱，但足以证实我们已经提取了正在寻找的DLL文件：
#### 五、固件和惠普软件“解决方案”逆向
通过访问设备上运行的代码，我们可以开始深入了解打印机中的一些功能，找到是否可能导致远程代码执行，特别是与惠普软件“解决方案”安装和固件更新相关的功能。
惠普软件解决方案利用惠普的OXP平台和SDK来扩展打印机的功能，第三方公司可以开发这些解决方案，但访问SDK由惠普严格控制，任何由SDK开发的软件最终版本必须由惠普签署才能安装在打印机上，如果能找到解决这些控制的方法，就可以创建适用于所有现代惠普打印机的恶意解决方案。
过去，恶意固件更新是在各种打印机上获得代码执行的一种方法。惠普已经转向了新的固件更新平台和文件格式，似乎没有安全研究人员详细地审查过。
##### BDL格式逆向工程
惠普解决方案和固件更新都包含一个带“.BDL”（捆绑）扩展名的单个文件。这是一种专有的二进制格式，没有公开的文档，我们决定对这种文件格式进行逆向工程，它可以让我们深入了解固件更新和软件解决方案的组成。
由于固件文件庞大而复杂，为了简单起见，我们从获取第三方软件解决方案“ThinPrint”的副本开始着手，与81MB的固件更新文件相比，这个解决方案的“BDL”文件有2.1MB。首先，我们在BDL文件上使用了一个叫binwalk的工具，它用于检查二进制文件并尝试提取其中包含的任何已知文件格式。binwalk被专门开发用于对这些类型的包进行逆向工程，工具输出单个ZIP文件包含以下内容：
我们在十六进制编辑器中手动检查了压缩文件和BDL文件，以确定ZIP文件在BDL文件中的位置：
（ZIP文件由binwalk在十六进制编辑器中提取，并显示CRC-32校验和）
（BDL文件高亮显示ZIP部分并计算CRC-32）
请注意，在上面两个截图中，我们已经计算了十六进制编辑器中选定部分的“CRC-32”校验和。在第一种情况下，对于ZIP文件，CRC-32校验和是在整个文件中计算的。在第二种情况下，对于BDL文件，CRC-32是根据我们怀疑包含压缩文件的部分进行计算的（基于前几个字节匹配）。当两个CRC-32校验和达到相同的“6D
AC 9A 2F”值时，我们猜想得到了证实。
还要考虑上面十六进制编辑器中用红色圈起来的部分，注意“2F 9A AC
6D”就出现在ZIP文件开始之前，只是ZIP文件的CRC-32校验和，其字节顺序相反。
看到这个，我们对zip文件做了一个小修改（只是修改了其中一个文件的内容），计算了修改过的ZIP的CRC-32校验和，并用修改的ZIP文件替换了BDL中的ZIP文件。BDL文件中的CRC-32校验和进行更新以匹配新修改的ZIP文件，并将BDL文件上传到打印机。
不幸的是没有成功，出现了以下错误：
进一步调查在打印机调试日志文件中发现了以下内容：
很明显，当ZIP文件被替换时，还有额外的CRC校验和被损坏。经过调查，包括编写自定义python脚本以识别文件中的CRC-32校验和后，ThinPrint
BDL文件中推导出了以下字段：
  * 0x14-0x17 = CRC32 of 0x929 to 0x938 (IPKG header)
  * 0x931-0x934 = Length of IPKG structure
  * 0x94d-0x950 = CRC32 of 0xd76 to 0xe89 (ZIP header)
  * 0x929-0x92a = Distance of IPKG structure from the start of the BDL file
  * 0xe76-0xe77 = Distance of ZIP from IPKG header
  * 0xe7e-0xe81 = Length of ZIP file
  * 0xe86-0xe89 = CRC32 of 0xe8b-EOF (ZIP file binary)
有以上知识还是不够的，当BDL文件上传到打印机时，更新上面列出的所有校验和、长度，仍然导致某种校验和失败。
在这里我们决定采取替代路径，理论上可以创建一个和原始ZIP文件同样长度和CRC-32校验和的ZIP文件，如果创建完成，就不需要更新BDL文件中的任何字段！
我们用Python编写了一个自定义工具来完成这项工作，放在我们Github的[知识库](https://github.com/foxglovesec/HPwn)中。这个工具允许修改原始BDL文件，通过替换一个相同长度和CRC-32校验和但任意不同内容的ZIP文件。这个工具有点破解，可能只适用于ThinPrint
BDL。
以这种方式修改的BDL文件上传到了打印机并确认可用，但是还没对代码进行恶意更改。当我们试图替换任何ZIP中的DLL文件时，我们得到了DLL签名验证错误。
#### 六、逆向工程固件签名验证
一旦对BDL文件的工作原理有了总体的了解，我们就开始检查固件更新过程和周围的安全控制。首先，我们只是在一个十六进制编辑器中检查惠普的固件更新文件，相关的文件类型是“.BDL”，有人指出，在文件末尾存在一个签名块：
这个签名块不在“ThinPrint”解决方案BDL中，这说明软件解决方案包和固件可能会以不同方式处理。
根据签名块中的信息判断，似乎正在使用该文件的行业标准签名验证，特别是使用SHA256的RSA。但是，正在使用安全加密算法并不意味着该文件有安全验证。一些常见的执行错误都可能导致签名验证不安全。
为了找出代码中签名验证执行的地方，我们上传一个仔细操作的固件文件到设备，注意不要以与ThinPrint解决方案相似的方式，使校验和或长度无效。进行到这里，从打印机的调试日志中产生了以下错误：
查看从打印机中提取的反编译代码，确定这个消息是在类文件`HP.Mfp.Services.Installation.Fim.Fim`中生成的：
进一步的逆向带我们到了正在执行签名验证的位置，快速审查代码后，我们没有发现严重的错误能容许绕过或操纵固件签名验证。
##### 惠普解决方案包的DLL签名验证逆向工程
我们已经对BDL格式进行了部分逆向，在打印机上执行恶意代码的第一步，显然是用修改过的DLL文件替换在BDL中打包的DLL文件之一，然而并没有成功，在打印机调式日志中，出现了如下的错误：
这个详细的错误信息，直接为我们指向了正在执行签名验证的代码位置，“HP.ExtLib.Package.Process”：
深入探索一下，我们检查了“signedObject.ValidatePeSignature”下的代码：
快速审查这段代码，我们怀疑这里可能会出现一些问题。在第11行，从DLL文件的第60个字节读取了一个数，在第14行和第15行，从DLL文件读取了另外两个数字读入变量int32_2和int32_3。在第19-22行，这两个新变量用于指定一部分加载到名为numArray2的数组中的DLL文件。从第22行开始，其余代码在numArray2上运行。
仔细检查上述过程，我们怀疑可能可以这种方式操作读入int32_2和int32_3的数字，因为验证签名的DLL文件部分可以与打印机上运行的实际可执行代码分离。
#### 七、构建恶意解决方案
##### 打破惠普对DLL文件的数字签名验证
为了验证上述怀疑，我们用C＃重新实现了打印机上执行签名验证的算法的一个接近完全副本。然后，该程序在Visual
Studio调试器中运行，并使用由惠普签名的有效DLL文件作为输入。在上面“ValidatePeSignature”的代码示例（下面新程序中的第65行）中，执行在第22行中断了，这是从DLL文件中读取numArray2的位置：
请注意，这时我们可以在上面的调试窗口中看到int32_1，int32_2，int32_3和numArray2的值，numArray2的内容被转储到磁盘上的文件“Foo.txt”中：
我们的计划不需要了解这些内容的实际含义，因此没有分析。
接下来，在HxD十六进制编辑器中复制粘贴，将文件“Foo.txt”追加到名为“HPwn.dll”的自定义未签名的.NET
DLL的末尾，红色字体的字节是新加的：
接下来必须小心操作DLL文件，以便惠普签名验证算法将文件末尾定义的新字节加载到numArray2中。仔细分析上面的ValidatePeSignature代码，并结合十六进制编辑器中相应的字节值，显示以下内容：
  * int32_2 is loaded from the DLL at offset = int32_1 + 152 = 128 + 152 = 280 = 118 hex
  * int32_3 is loaded from the DLL at offset = int32_1 + 156 = 128 + 156 = 284 = 11C hex