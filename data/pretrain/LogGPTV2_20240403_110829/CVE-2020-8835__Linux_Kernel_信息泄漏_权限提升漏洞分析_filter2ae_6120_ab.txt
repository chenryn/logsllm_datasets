        for (i = 0; i var_off.value &
                              src_reg.var_off.value);
                break;
            }
            /* We get our minimum from the var_off, since that's inherently
             * bitwise.  Our maximum is the minimum of the operands' maxima.
             */
            dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);// ****
              ……
实际上的AND操作是在tnum_and中进行：
    struct tnum tnum_and(struct tnum a, struct tnum b)
    {
        u64 alpha, beta, v;
        alpha = a.value | a.mask;
        beta = b.value | b.mask;
        v = a.value & b.value;
        return TNUM(v, alpha & beta & ~v);
    }
该操作前的寄存器状态为：
    $12 = {type = 0x1, {range = 0x0, map_ptr = 0x0, btf_id = 0x0, raw = 0x0}, off = 0x0, id = 0x0, 
      ref_obj_id = 0x0, var_off = {value = 0x0, mask = 0x7f00000000}, smin_value = 0x2000000000, 
      smax_value = 0x4000000000, umin_value = 0x2000000000, umax_value = 0x4000000000, parent = 0xffff88801f97ab40, 
      frameno = 0x0, subreg_def = 0x0, live = 0x0, precise = 0x1}
tnum_and操作后的状态为：
    $16 = {type = 0x1, {range = 0x0, map_ptr = 0x0, btf_id = 0x0, raw = 0x0}, off = 0x0, id = 0x0, 
      ref_obj_id = 0x0, var_off = {value = 0x0, mask = 0x0}, smin_value = 0x2000000000, smax_value = 0x4000000000,
      umin_value = 0x0, umax_value = 0xffffffff, parent = 0xffff88801f97ab40, frameno = 0x0, subreg_def = 0x0,
      live = 0x4, precise = 0x1}
tnum_and操作导致var_off.value=0, var_off.mask=0。
之后调用 __update_reg_bounds函数时，导致reg->smin_value=0，reg->smax_value=0
    $48 = {type = 0x1, {range = 0x0, map_ptr = 0x0, btf_id = 0x0, raw = 0x0}, off = 0x0, id = 0x0, 
      ref_obj_id = 0x0, var_off = {value = 0x0, mask = 0x0}, smin_value = 0x0, smax_value = 0x0, umin_value = 0x0,
      umax_value = 0x0, parent = 0xffff88801f97c340, frameno = 0x0, subreg_def = 0x0, live = 0x4, precise = 0x1}
这里相当于在检查时寄存器的值为0，而实际运行时寄存器是正常值。 进而绕过检查，可以对map指针进行加减操作，导致越界读写：
     adjust_ptr_min_max_vals():
     case PTR_TO_MAP_VALUE:
                    if (!env->allow_ptr_leaks && !known && (smin_val code == (BPF_ALU64 | BPF_ADD | BPF_X) ||
                insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {
                const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;
                const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;
                struct bpf_insn insn_buf[16];
                struct bpf_insn *patch = &insn_buf[0];
                bool issrc, isneg;
                u32 off_reg;
                aux = &env->insn_aux_data[i + delta];
                if (!aux->alu_state ||
                    aux->alu_state == BPF_ALU_NON_POINTER)
                    continue;
                isneg = aux->alu_state & BPF_ALU_NEG_VALUE;
                issrc = (aux->alu_state & BPF_ALU_SANITIZE) ==
                    BPF_ALU_SANITIZE_SRC;
                off_reg = issrc ? insn->src_reg : insn->dst_reg;
                if (isneg)
                    *patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);
                *patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);
                *patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);
                *patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);
                *patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);
                *patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);
上述代码的效果实际上是添加了以下指令，来对加减的寄存器范围作了限制，防止越界：
我们可以通过对指针进行不停累加，进而绕过该补丁。但我们在实际编写利用过程中，有数据的地址离map太远，累加次数过多，而bpf又限制指令的数量。
所以我们转而对栈指针进行越界读写，发现可以做到栈溢出。之后覆盖返回地址即可，但需要通过rop技术绕过smep、smap和kpti保护机制。
漏洞利用提权成功效果图：
## 0x04 时间线
**2020-03-19** ZDI 展示该漏洞攻击成果
**2020-03-30** CVE 收录该漏洞
**2020-03-31** 360CERT发布预警
**2020-04-21** 360CERT完成漏洞利用并发布漏洞分析报告
## 0x05 参考链接
  1. 
  2. 
  3. 
  4. 