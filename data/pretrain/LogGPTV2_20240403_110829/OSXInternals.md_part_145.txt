diskimages-helper resides in the Resources directory of the Disk Images framework.
The disk image appears as a virtual disk with /dev/disk10 being its block device node. The pdisk utility
can dump partition information from this disk just as in the case of a real disk.
$ pdisk /dev/rdisk10 -dump
Partition map (with 512 byte blocks) on '/dev/rdisk10'
#: type name length base ( size )
1: Apple_partition_map Apple 63 @ 1
2: Apple_HFS disk image 65456 @ 64 ( 32.0M)
3: Apple_Free 16 @ 65520
Device block size=512, Number of Blocks=65536 (32.0M)
Detaching a disk unmounts and ejects it.
$ hdiutil detach disk10
"disk10" unmounted.
"disk10" ejected.
By default, hdiutil uses a disk image format called Universal Disk Image Format (UDIF). Moreover, the
default partition layout contains a partition map with space for 63 map entries, a single data partition of
type Apple_HFS, and a trailing free partition containing 16 blocks. This layout is called Single Partition
UDIF (SPUD). hdiutil also supports other partition layouts, for example:
$ hdiutil create -size 32m -volname HFSJ_UCD \
-fs HFSJ -layout "UNIVERSAL CD" /tmp/hfsj_ucd.dmg
...
$ hdiutil attach /tmp/hfsj_ucd.dmg
/dev/disk10 Apple_partition_scheme
/dev/disk10s1 Apple_partition_map
/dev/disk10s2 Apple_Driver43
/dev/disk10s3 Apple_Driver43_CD
/dev/disk10s5 Apple_Driver_ATAPI
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 18 of 90
/dev/disk10s6 Apple_Driver_ATAPI
/dev/disk10s7 Apple_Patches
/dev/disk10s9 Apple_HFS
In particular, a partition layout of type NONE creates an image with no partition map.
$ hdiutil create -size 32m -volname HFSJ_NONE \
-fs HFSJ -layout NONE /tmp/hfsj_none.dmg
...
$ hdiutil attach /tmp/hfsj_none.dmg
...
/dev/disk11
Note that a single device entry is listed when the image is attachedthere are no slices. pdisk will not dump
partition information in the absence of a partition map, but hdiutil's pmap verb can be used instead.
$ hdiutil pmap /dev/rdisk11
Partition List
## Dev_______ Type_______________ Name_____________ Start___ Size____ End_____
-1 disk11 Apple_HFS Single Volume 0 65536 65535
Legend
- ... extended entry
+ ... converted entry
Type 128 partition map detected.
Block0.blockSize 0x0200
NativeBlockSize 0x0200
...
11.4.2. RAM Disks
A memory-backed virtual disk device can be created using hdiutil as follows:
$ hdiutil attach -nomount ram://1024
/dev/disk10
Given ram://N as the device argument, hdiutil creates a RAM disk with N sectors, each 512 bytes. As
with disk-backed disk images, we can partition a RAM disk, create file systems on it, and so on.
$ newfs_hfs -v RAMDisk /dev/rdisk10
Initialized /dev/rdisk10 as a 512 KB HFS Plus volume
$ mkdir /tmp/RAMDisk
$ mount_hfs /dev/disk10 /tmp/RAMDisk
$ df /tmp/RAMDisk
File system 512-blocks Used Avail Capacity Mounted on
/dev/disk10 1024 152 872 15% /private/tmp/RAMDisk
Detaching a RAM disk frees any physical memory associated with it.
$ umount /tmp/RAMDisk
$ hdiutil detach disk10
hdiutil and the Disk Images framework have several other interesting features, such as the ability to use
disk images specified with HTTP URLs, support for encrypted disk images, and support for shadowing,
wherein all writes to an image are redirected to a shadow file (when a read occurs, blocks in the shadow
file have precedence).
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 19 of 90
11.4.3. The BSD Vnode Disk Driver
As we have seen, hdiutil automatically attaches a virtual device node under /dev to a disk image file and
prints the dynamically assigned device name. Mac OS X provides another mechanism, the BSD vnode disk
driver, which allows files to be treated as disks by attaching them to specific "vn" device nodes.
The /usr/libexec/vndevice command-line program is used to control this mechanism.
$ hdiutil create -size 32m -volname HFSJ_VN \
-fs HFSJ -layout NONE /tmp/hfsj_vn.dmg
...
$ sudo /usr/libexec/vndevice attach /dev/vn0 /tmp/hfsj_vn.dmg
$ mkdir /tmp/mnt
$ sudo mount -t hfs /dev/vn0 /tmp/mnt
$ df -k /tmp/mnt
Filesystem 1K-blocks Used Avail Capacity Mounted on
/dev/vn0 32768 8720 24048 27% /private/tmp/mnt
$ sudo umount /tmp/mnt
$ sudo /usr/libexec/vndevice detach /dev/vn0
11.4.4. Creating a Virtual Disk from Scratch
Although we will mostly use hdiutil to create disk images with automatically constructed partition
layouts and file systems, it is instructive to look at an example that starts with a "blank disk." The latter is
simply a zero-filled filesay, one created using the mkfile program.
$ mkfile 64m blankhd.dmg
So far, we have seen that attaching a disk image using hdiutil also mounts the volumes within the image.
We can instruct hdiutil to only attach the image and not mount any volumes, thereby giving us block and
character devices to use as we please.
$ hdiutil attach -nomount /tmp/blankhd.dmg
/dev/disk10
Since this disk has no partitions yet, nor even a partition scheme, pdisk will not display any partition
information for it. We can initialize a partition map using pdisk.
$ pdisk /dev/rdisk10 -dump
pdisk: No valid block 1 on '/dev/rdisk10'
$ pdisk /dev/rdisk10 -initialize
$ pdisk /dev/rdisk10 -dump
Partition map (with 512 byte blocks) on '/dev/rdisk10'
#: type name length base ( size )
1: Apple_partition_map Apple 63 @ 1
2: Apple_Free Extra 131008 @ 64 ( 64.0M)
Device block size=512, Number of Blocks=131072 (64.0M)
...
As we saw earlier, in the Apple partitioning scheme, a disk partition map entry is 512 bytes in size. Our
partition map occupies 63 blocks, each 512 bytes. Therefore, it has room for 63 map entries. Since the first
entry is used for the partition map itself, we have room for as many as 62 new partition map entries, or 61,
if the last entry is used for any trailing free space. Let us use, say, 31 of them[5] to create partitions, even
though it is rather uncommon to actually need so many partitions. The following shell script attempts to
create 31 partitions, assigning 1MB of disk space to each.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 20 of 90
[5] The Mac OS X 10.4 kernel panics if all 61 entries are used.
#! /bin/zsh
# usage: createpartitions.zsh 
DISK=$1
base=64
foreach pnum ({1..31})
pdisk $DISK -createPartition Partition_$pnum Apple_HFS $base 2048
base=$[base + 2048]
end
Let us run the script with the name of our blank disk's raw device node as an argument. Note that pdisk
prints the number of the map entry it uses while creating a partition.
$ ./createpartitions.zsh /dev/rdisk10
2
3
...
31
32
$ pdisk /dev/rdisk10 -dump
Partition map (with 512 byte blocks) on '/dev/rdisk10'
#: type name length base ( size )
1: Apple_partition_map Apple 63 @ 1
2: Apple_HFS Partition_1 2048 @ 64 ( 1.0M)
3: Apple_HFS Partition_2 2048 @ 2112 ( 1.0M)
4: Apple_HFS Partition_3 2048 @ 4160 ( 1.0M)
...
32: Apple_HFS Partition_31 2048 @ 61504 ( 1.0M)
33: Apple_Free Extra 67520 @ 63552 ( 33.0M)
...
We can now create file systems on each of the Apple_HFS data partitions. Note that at this point, the block
and character device nodes corresponding to each partition will already exist in the /dev directory.
#! /bin/zsh
# usage: newfs_hfs.zsh 
DISK=$1
foreach slicenum ({2..32}) # first data partition is on the second slice
fsnum=$[slicenum - 1]
newfs_hfs -v HFS$fsnum "$DISK"s$slicenum
end
Again, we run our script with the virtual disk's raw device as an argument.
$ ./newfs_hfs.zsh /dev/rdisk10
Initialized /dev/rdisk10s2 as a 1024 KB HFS Plus volume
Initialized /dev/rdisk10s3 as a 1024 KB HFS Plus volume
...
Initialized /dev/rdisk10s31 as a 1024 KB HFS Plus volume
Initialized /dev/rdisk10s32 as a 1024 KB HFS Plus volume
$ hdiutil detach disk10
$ open /tmp/blankhd.dmg
...
At this point, all 31 volumes should be mounted under /Volumes. Detaching the disk will unmount all of
them.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 21 of 90
Let us also look at an example of creating GUID-based partitions using the gpt command. We will assume
that we already have a blank disk image attached, with /dev/rdisk10 being its raw device node.
$ gpt show /dev/rdisk10 # we have nothing on this 64MB disk
start size index contents
0 131072
$ gpt create /dev/rdisk10 # create a new (empty) GPT
$ gpt show /dev/rdisk10
start size index contents
0 1 PMBR
1 1 Pri GPT header
2 32 Pri GPT table
34 131005
131039 32 Sec GPT table
131071 1 Sec GPT header
$ gpt add -s 1024 -t hfs /dev/rdisk10 # add a new partition
$ gpt show /dev/rdisk10
start size index contents
0 1 PMBR
1 1 Pri GPT header
2 32 Pri GPT table
34 1024 1 GPT part - 48465300-0000-11AA-AA11-00306543ECAC
1058 129981
131039 32 Sec GPT table
131071 1 Sec GPT header
$ gpt add -i 8 -s 1024 -t ufs /dev/rdisk10 # add at index 8
$ gpt show /dev/rdisk10
...
34 1024 1 GPT part - 48465300-0000-11AA-AA11-00306543ECAC
1058 1024 8 GPT part - 55465300-0000-11AA-AA11-00306543ECAC
...
11.5. Files and File Descriptors
At the system call level, Mac OS X represents open files in a process by using integral file descriptors,
each of which is an index into the process's file descriptor table in the kernel. When a user program uses a
file descriptor in a system call, the kernel uses the file descriptor to find the corresponding file data
structure, which in turn contains informationsuch as a function-pointer tableusing which I/O can be
performed on the file. This scenario is conceptually the same across Unix and Unix-like systems. However,
the specific data structures involved are often different. Figure 1111 shows the primary file-related kernel
data structures in Mac OS X.
Figure 1111. How a file descriptor leads to a file in Mac OS X
[View full size image]
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 22 of 90
Let us assume there is a file descriptor called fd in a process with ID pid. Each process structure (struct
proc) contains a pointer (p_fd) to a filedesc structure, which holds information about the process's open
files. In particular, it contains pointers to two arrays: an array of fileproc structures (fd_ofiles) and an
array of open file flags (fd_ofileflags). In the case of our file descriptor fd, the elements with index fd
in both these arrays will correspond to the file fd represents. If a descriptor is released (because it has no
remaining references), that index in both arrays becomes free. The fd_freefile field of the filedesc
structure is used to store a hint that the kernel uses while searching for a free file descriptor.
As Figure 1111 shows, each entry of the fd_ofiles array is a fileproc structure. The fg_ops and
fg_data fields of this structure point to data structures whose contents depend on the file descriptor's type.
Besides files, the kernel uses file descriptors to represent several types of entities, which are listed in Table
111. Figure 1111 assumes that fd corresponds to a file. Therefore, fg_ops points to a table of vnode
operations[6] (the global data structure vnops), whereas fg_data points to a vnode structure. If the
descriptor represented a socket instead, fg_ops would point to a table of socket operations, and fg_data
would point to a socket structure.
[6] There are far more vnode operations than are contained in a fileops structure, which is
more relevant for "nonfile" file descriptorsvnode operations can be accessed through the vnode
structure itself.
Table 111. Types of File Descriptors in Mac OS X
fg_data Points to an Instance of fg_ops Points to This
File Type This Structure Operation Table
DTYPE_VNODE struct vnode vnops
DTYPE_SOCKET struct socket socketops
DTYPE_PSXSHM struct pshmnode pshmops
DTYPE_PSXSEM struct psemnode psemops
DTYPE_KQUEUE struct kqueue kqueueops
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 23 of 90
DTYPE_PIPE struct pipe pipeops
DTYPE_FSEVENTS struct fsevent_handle fsevents_ops
11.6. The VFS Layer
Mac OS X provides a virtual file system interfacethe vnode/vfs layeroften referred to simply as the VFS
layer. First implemented by Sun Microsystems, the vnode/vfs concept is widely used by modern operating
systems to allow multiple file systems to coexist in a clean and maintainable manner. A vnode (virtual
node) is an in-kernel representation of a file, whereas a vfs (virtual file system) represents a file system.
The VFS layer sits between the file-system-independent and file-system-dependent code in the kernel,
thereby abstracting file system differences from the rest of the kernel, which uses VFS-layer functions to
perform I/Oregardless of the underlying file systems. Beginning with Mac OS X 10.4, a VFS kernel
programming interface (KPI) is implemented in bsd/vfs/kpi_vfs.c.
The Mac OS X VFS is derived from FreeBSD's VFS, although there are numeroususually minor in
conceptdifferences. An area of major difference is the file system layer's integration with virtual memory.
The unified buffer cache (UBC) on Mac OS X is integrated with Mach's virtual memory layer. As we saw
in Chapter 8, the ubc_info structure associates Mac OS X vnodes with the corresponding virtual memory
objects.
Figure 1112 shows a simplistic visualization of the vnode/vfs layer. In object-oriented parlance, the vfs is
akin to an abstract base class from which specific file system instances such as HFS Plus and UFS are
derived. Continuing with the analogy, the vfs "class" contains several pure virtual functions that are defined
by the derived classes. The vfsops structure [bsd/sys/mount.h] acts as a function-pointer table for these
functions, which include the following (listed in the order they appear in the structure):
 vfs_mount()implements the mount() system call
 vfs_start()called by the mount() system call to perform any operations that the file system wishes
to perform after a successful mount operation
 vfs_unmount()implements the unmount() system call
vfs_root()retrieves the root vnode of the file system
 vfs_quotactl()implements the quotactl() system call (handles quota operations on the file
system)
 vfs_getattr()populates a vfs_attr structure with file system attributes
 vfs_statfs()implements the statfs() system call (retrieves file system statistics by populating a
statfs structure)
vfs_sync()synchronizes in-memory dirty data with the on-disk data
vfs_vget()retrieves an existing file system object given its IDfor example, the catalog node ID in
the case of HFS Plus (see Chapter 12)
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 24 of 90
vfs_fhtovp()translates a file handle to a vnode; used by the NFS server
vfs_init()performs one-time initialization of the file system
vfs_sysctl()handles file-system-level sysctl operations specific to this file system, for example,
enabling or disabling the journal on an HFS Plus volume
vfs_setattr()sets file system attributes, if any can be set, for example, the volume name in the
case of HFS Plus
Figure 1112. An overview of the vnode/vfs layer's role in the operating system
[View full size image]
Similarly, a vnode is an abstract base class from which files residing on various file systems are
conceptually derived. A vnode contains all the information that the file-system-independent layer of the
kernel needs. Just as the vfs has a set of virtual functions, a vnode too has a (larger) set of functions
representing vnode operations. Normally, all vnodes representing files on a given file system type share the
same function-pointer table.
As Figure 1112 shows, a mount structure represents an instance of a mounted file system. Besides a pointer
to the vfs operations table, the mount structure also contains a pointer (mnt_data) to instance-specific
private datawhich is private in that it is opaque to the file-system-independent code. For example, in the
case of HFS Plus, mnt_data points to an hfsmount structure, which we will discuss in Chapter 12.
Similarly, a vnode contains a private data pointer (v_data) that points to a file-system-specific per-file