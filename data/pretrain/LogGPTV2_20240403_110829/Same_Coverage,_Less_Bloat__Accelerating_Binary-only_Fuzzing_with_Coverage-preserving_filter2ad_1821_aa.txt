title:Same Coverage, Less Bloat: Accelerating Binary-only Fuzzing with Coverage-preserving
Coverage-guided Tracing
author:Stefan Nagy and
Anh Nguyen-Tuong and
Jason D. Hiser and
Jack W. Davidson and
Matthew Hicks
Same Coverage, Less Bloat: Accelerating Binary-only Fuzzing
with Coverage-preserving Coverage-guided Tracing
Stefan Nagy
Jason D. Hiser
Virginia Tech
Blacksburg, Virginia
PI:EMAIL
Anh Nguyen-Tuong
University of Virginia
Charlottesville, Virginia
PI:EMAIL
University of Virginia
Charlottesville, Virginia
PI:EMAIL
Jack W. Davidson
University of Virginia
Charlottesville, Virginia
PI:EMAIL
ABSTRACT
Coverage-guided fuzzing’s aggressive, high-volume testing has
helped reveal tens of thousands of software security flaws. While
executing billions of test cases mandates fast code coverage tracing,
the nature of binary-only targets leads to reduced tracing perfor-
mance. A recent advancement in binary fuzzing performance is
Coverage-guided Tracing (CGT), which brings orders-of-magnitude
gains in throughput by restricting the expense of coverage tracing
to only when new coverage is guaranteed. Unfortunately, CGT
suits only a basic block coverage granularity—yet most fuzzers re-
quire finer-grain coverage metrics: edge coverage and hit counts. It is
this limitation which prohibits nearly all of today’s state-of-the-art
fuzzers from attaining the performance benefits of CGT.
This paper tackles the challenges of adapting CGT to fuzzing’s
most ubiquitous coverage metrics. We introduce and implement
a suite of enhancements that expand CGT’s introspection to fuzz-
ing’s most common code coverage metrics, while maintaining its
orders-of-magnitude speedup over conventional always-on cover-
age tracing. We evaluate their trade-offs with respect to fuzzing
performance and effectiveness across 12 diverse real-world binaries
(8 open- and 4 closed-source). On average, our coverage-preserving
CGT attains near-identical speed to the present block-coverage-
only CGT, UnTracer; and outperforms leading binary- and source-
level coverage tracers QEMU, Dyninst, RetroWrite, and AFL-Clang
by 2–24×, finding more bugs in less time.
CCS CONCEPTS
• Security and privacy → Software and application security.
KEYWORDS
Fuzzing, Binaries, Code Coverage
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea.
© 2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3484787
Matthew Hicks
Virginia Tech
Blacksburg, Virginia
PI:EMAIL
ACM Reference Format: Stefan Nagy, Anh Nguyen-Tuong, Jason D. Hiser,
Jack W. Davidson, and Matthew Hicks. 2021. Same Coverage, Less Bloat: Ac-
celerating Binary-only Fuzzing with Coverage-preserving Coverage-guided
Tracing. In Proceedings of the 2021 ACM SIGSAC Conference on Computer
and Communications Security (CCS’21), November 15–19, 2021, Virtual Event,
Republic of Korea. ACM, New York, NY, USA, 15 pages.
https://doi.org/10.1145/3460120.3484787
1 INTRODUCTION
Coverage-guided fuzzing has become one of the most popular and
successful techniques for software security auditing. Its aggressive,
high-volume testing strategy has revealed countless security vul-
nerabilities in software, and helped proactively secure many of the
world’s most popular codebases [8]. Today, software projects of
all sizes rely on fuzzing to root out bugs and vulnerabilities both
throughout and beyond the software development cycle.
Fuzzing consists of three main steps: (1) test case generation,
(2) code coverage tracing, and (3) test case triage. Many works im-
prove fuzzing at the generation level by incorporating input gram-
mars [21], path prioritization [34], better mutators [36], or con-
straint solving [3]; while others focus on refining triage with sani-
tizers [15] or other heuristics. However, given fuzzing’s core goal
of producing—and eventually executing—a large volume of test
cases, maintaining high-performance test case execution is critical
to effective fuzzing. Recent work shows both “dumb” and “smart”
fuzzers spend the majority of their time executing test cases and
collecting their coverage traces [37]. However, in binary-only fuzz-
ing contexts, the semantically-poor and opaque nature of a binary
prevents the tight integration of coverage-tracing routines that is
possible in source-available contexts. This inflates the tracing over-
head by up to two orders of magnitude compared to compiler-based
instrumentation of source code. Even in an ideal world where black-
box instrumenters approach compiler-level performance, recent
work shows that coverage tracing increases test case execution
time by roughly 30% [15]. To address this performance gap and
the time wasted by needless coverage tracing, many binary-only
fuzzing efforts [18, 23, 30, 51] are eschewing conventional always-
on coverage tracing for an on-demand tracing strategy known as
Coverage-guided Tracing (CGT) [37]. CGT restricts the expense of
tracing to only when new coverage is guaranteed (roughly 1 test
case in every 10,000), thereby increasing fuzzing throughput by
500–600% over the leading binary-only tracers.
Session 2A: Fuzzing and Bug Finding CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea351While some practitioners are leveraging the idea of CGT [18, 23,
30], we are not aware of any fuzzer that has adopted it as a replace-
ment for always-on tracing. Our survey of 27 fuzzers reveals why
such performance benefits sit unrealized: CGT only supports basic
block coverage (instruction sequences ending in control-flow trans-
fer), but most fuzzers rely on finer-grained coverage metrics. Specif-
ically, our study shows 25/27 adopt edges (transitions between
blocks), and 26/27 further track block or edge hit counts (execution
frequencies). This lack of support for the most common coverage
metrics inhibits CGT’s adoption in nearly all fuzzers. While CGT’s
near-0% tracing overhead is ideal for fuzzing’s high-throughput
needs, its coverage deficiencies force today’s state-of-the-art fuzzers
to instead rely on orders-of-magnitude slower, always-on tracing—
leaving their full performance potential unrealized.
This paper tackles the challenge of extending CGT to fuzzing’s
most ubiquitous coverage metrics—edges and hit counts—making
high-performance tracing available for all existing (and future)
fuzzers. At the core of our efforts are binary-level and fuzzing en-
hancements that broaden CGT’s coverage while maintaining its
orders-of-magnitude speedup: for edge coverage, we introduce a
zero-overhead strategy called jump mistargeting that addresses the
most common (statically and dynamically) form of critical edges
while keeping control flow intact. To maintain completeness of
edge coverage, we back jump mistargeting with a low-overhead
binary-only implementation of a control-flow transformation that
eliminates critical edges through block insertion called branch split-
ting (e.g., LLVM’s SanitizerCoverage [50]). To extend CGT to hit
count coverage, we exploit the observation that execution frequency
changes are highly localized to loops, devising a bucketed unrolling
strategy to encode them with a minimally-invasive hit count track-
ing mechanism congruent with current fuzzers [18, 59].
We implement our coverage-preserving Coverage-guided Tracing,
HeXcite, and evaluate it against the current block-coverage-only
CGT implementation UnTracer [37]; the leading binary-only fuzz-
ing coverage tracers QEMU [59], Dyninst [26], and RetroWrite [15];
and the popular source-level coverage tracing via AFL-Clang [59].
In evaluations across 12 diverse real-world binaries (8 open- and
4 closed-source), HeXcite attains a throughput near identical to
UnTracer’s; 3–24× that of conventional always-on binary-only trac-
ers QEMU, Dyninst, and RetroWrite; and 2.8× that of source-level
tracing with AFL-Clang. HeXcite’s coverage-preserving transfor-
mations further enable it to find 12–749% more unique bugs than
UnTracer as well as always-on binary- and source-level tracers
in standard coverage-guided grey-box fuzzing integrations—while
finding 16 known bugs and vulnerabilities in 32–52% less time.
Through the following contributions, this paper enables the
use of the fastest tracing approach in fuzzing—Coverage-guided
Tracing—by the majority of today’s fuzzers:
always-on binary- and source-level tracers—in edge cover-
age, loop coverage, and bug-finding fuzzing effectiveness.
• We show that coverage-preserving CGT’s speed is nearly
indistinguishable from that of block-only CGT, and—despite
being a binary-only technique—is >2× the speed of even
source-level tracing approaches.
• We open-source HeXcite, our implementation of binary-
only coverage-preserving CGT, and our evaluation bench-
marks at: https://github.com/FoRTE-Research/HeXcite.
2 BACKGROUND
To understand our improvements to Coverage-guided Tracing, it is
crucial to understand the core details of coverage-guided fuzzing, its
code coverage metrics, and the high-performance tracing strategy
known as Coverage-guided Tracing.
2.1 Software Fuzzing
Software fuzzing broadly represents one of today’s most popular
software quality assurance approaches. Unlike other forms of soft-
ware testing that vet functionality (e.g., unit testing, mutational
testing), fuzzing’s primary focus is security auditing; test cases are
generated and fed to the target program with their effects moni-
tored for signs of security violations. Many software vulnerabilities
have been (and continue to be) uncovered via fuzzing, and its use
among developers large and small continues to grow each year [18].
Fuzzing encompasses a variety of techniques accommodating
specific use cases, with the most common distinction being search
strategy; directed fuzzers constrain testing to specific code or paths
(e.g., newly-patched [6] or likely-vulnerable code [11]), while guided
fuzzers aim to maximize the program’s state space along some pre-
specified metric (e.g., memory accesses or code coverage). By far
the most common and successful form of fuzzing is coverage-guided
fuzzing [59] which, as the name implies, aims to maximize test
cases’ code coverage to uncover hidden program bugs.
2.2 Coverage-guided Fuzzing
Coverage-guided fuzzing’s scalability, easy adoption, and time-
tested effectiveness have made it widely popular among both de-
velopers and security practitioners. As shown in Figure 1, given a
target program, a typical coverage-guided fuzzing workflow con-
sists of the following recurring steps:
• We introduce jump mistargeting: a control-flow redirection
strategy which alters the common-case of edge instructions
such that they self-report edge coverage at native speed.
• We introduce bucketed unrolling: a technique which clones
loop conditions at discrete intervals, enabling the self-reporting
of loop hit-count coverage at near-native speed.
• We demonstrate that with these techniques, our coverage-
preserving CGT eclipses block-only CGT—and conventional
Figure 1: The high-level steps of coverage-guided fuzzing.
(1) Generation. Genetic algorithms (typically a mix of random
and deterministic byte mutations) create batches of candidate
test cases from one or more ancestors.
CoverageTracing andExecutionMonitoring2TestCaseTriageTestCaseGen.13new crashnew coveragediscardedtest casesinstrumented targetseed for mutationSession 2A: Fuzzing and Bug Finding CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea352(2) Coverage Tracing & Execution Monitoring. Lightweight
statically- or dynamically-inserted instrumentation captures
each test case’s runtime code coverage given some pre-specified
coverage metric(s), while monitoring their other execution
behavior (e.g., terminating signal).
(3) Triage. Candidates are grouped based on observed execution
behavior; those increasing coverage are preserved for future
mutation, while those triggering crashes are deduplicated in
anticipation of manual bug analysis.
Coverage-guided fuzzing’s balance of feedback-guided auditing
and aggressive, high-volume testing continues to reign supreme
over other automated security testing methodologies; its effective-
ness is evidenced by the deep (and ever-growing) vulnerability
trophy cases held by prominent fuzzers such as Google’s AFL [59],
honggFuzz [49], and libFuzzer [45]; and its fundamental principles
form the core of today’s most state-of-the-art fuzzing efforts.
2.3 Fuzzing’s Code Coverage Metrics
To maximally vet the target application, coverage-guided fuzzing
collects a test case’s dynamic code coverage and subsequently mu-
tates only those which attain new coverage. In our efforts to under-
stand fuzzing’s current coverage landscape, we survey 27 of today’s
state-of-the-art coverage-guided fuzzers (Table 1) and identify three
universal coverage metrics: basic blocks, edges, and hit counts. We
discuss these coverage metrics in detail below.
bit representing one of eight ranges (0–1, 2, 3, 4–7, 8–15, 16–31,
32–127, 128+); test cases are seeded if they jump from one bucket
to another for any block/edge. While tracking exact hit counts (e.g.,
VUzzer and TIFF) reveals finer-grained state changes, it risks over-
saturating the fuzzer seed pool with needless test cases (e.g., one
per new loop iteration), and is hence seldom used.
2.4 Coverage-guided Tracing
Many recent works improve fuzzing with smarter test case gen-
eration or triage. But despite these advancements, the maximal
performance of both standard and state-of-the-art coverage-guided
fuzzers is subject to a key constraint: code coverage is traced for all
test cases, yet less than 1 in 10,000 actually increase coverage [37].
While this has little impact in use cases where tracing instrumenta-
tion is already fast (i.e., open-source software), it is the principal
bottleneck for those where tracing is costly—i.e., closed-source
software. For this reason, a number of binary-only fuzzing ef-
forts [18, 23, 30, 51] are instead adopting a lighter-weight strategy
called Coverage-guided Tracing (CGT), which restricts the expense
of tracing to only the < 0.01% of test cases that increase coverage.
Cov Hit Name
Cov Hit
Name
AFL [59]
➤
AFL++ [18]
➤
AFLFast [7]
➤
AFLSmart [41] ➤
Angora [9]
➤
CollAFL [19]
➤
DigFuzz [60]
➤
Driller [48]
➤
Eclipser [13]
➤
✔
✔
✔
✔
✔
✔
✔
✔
✔
Cov Hit Name
EnFuzz [12]
➤
FairFuzz [34]
➤
honggFuzz [49] ➤
GRIMORE [5]
➤
lafIntel [1]
➤
libFuzzer [45]
➤
Matryoshka [10] ➤
MOpt [36]
➤
NEUZZ [46]
➤
ProFuzzer [57] ➤
QSYM [58]
➤
REDQUEEN [3] ➤
SAVIOR [11]
➤
SLF [56]
➤
Steelix [35]
➤
Superion [53] ➤
TIFF [29]
■
VUzzer [43]
■
✔
✔
✗
✔
✔
✔
✔
✔
✔