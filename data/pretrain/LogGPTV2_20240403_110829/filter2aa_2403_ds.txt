83.1.1 Trixter 的 42 字节程序 ............. 813 
83.1.2 笔者对 Trixter 算法的改进： 
27 字节 ..................................... 814 
83.1.3 从随机地址读取随机数 ........... 814 
83.1.4 其他 .......................................... 815 
83.2 曼德博集合 ......................................... 815 
83.2.1 理论 .......................................... 816 
83.2.2 demo 程序 ................................ 820 
83.2.3 笔者的改进版 .......................... 822 
第九部分 文件分析 
第 84 章 基于 XOR 的文件加密 .............. 827 
84.1 Norton Guide：单字节 XOR 加密 
实例 ..................................................... 827 
信息熵 .................................................... 828 
84.2 4 字节 XOR 加密实例 ........................ 828 
84.3 练习题 ................................................. 830 
第 85 章 Millenium 游戏的存档文件 .... 831 
第 86 章 Oracle 的.SYM 文件................. 835 
第 87 章 Oracle 的.MSDB 文件 ............. 842 
总结 ................................................................ 845 
第十部分 其他 
第 88 章 npad ................................................. 849 
第 89 章 修改可执行文件 .......................... 851 
89.1 文本字符串 ......................................... 851 
89.2 x86 指令 .............................................. 851 
第 90 章 编译器内部函数 .......................... 852 
第 91 章 编译器的智能短板 ...................... 853 
第 92 章 OpenMP ........................................ 854 
92.1 MSVC .................................................. 856 
92.2 GCC ..................................................... 858 
第 93 章 安腾指令 ......................................... 860 
第 94 章 8086 的寻址方式 ......................... 863 
第 95 章 基本块重排 .................................... 864 
95.1 PGO 的优化方式 ................................. 864 
第十一部分 推荐阅读 
第 96 章 参考书籍 ......................................... 869 
96.1 Windows .............................................. 869 
96.2 C/C++................................................... 869 
96.3 x86/x86-64 ........................................... 869 
96.4 ARM .................................................... 869 
96.5 加密学.................................................. 869 
第 97 章 博客 .................................................. 870 
97.1 Windows 平台 ..................................... 870 
第 98 章 其他内容 ......................................... 871 
第十二部分 练习题 
第 99 章 初等难度练习题 ........................... 875 
99.1 练习题 1.4 ............................................ 875 
第 100 章 中等难度练习题 ........................ 876 
100.1 练习题 2.1 .......................................... 876 
100.1.1 Optimizing MSVC 2010 x86 .... 876 
100.1.2 Optimizing MSVC 2012 x64 .... 877 
100.2 练习题 2.4 .......................................... 877 
100.2.1 Optimizing MSVC 2010 ......... 877 
100.2.2 GCC 4.4.1................................ 878 
100.2.3 Optimizing Keil（ARM 
mode） .................................... 879 
100.2.4 Optimizing Keil（Thumb 
mode） .................................... 880 
100.2.5 Optimizing GCC 4.9.1 
（ARM64） .............................. 880 
100.2.6 Optimizing GCC 4.4.5 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
目    录 
5 
（MIPS） ................................. 881 
100.3 练习题 2.6 ......................................... 882 
100.3.1 Optimizing MSVC 2010 ......... 882 
100.3.2 Optimizing Keil（ARM 
mode） ................................... 883 
100.3.3 Optimizing Keil（Thumb 
mode） ................................... 884 
100.3.4 Optimizing GCC 4.9.1 
（ARM64） ............................. 884 
100.3.5 Optimizing GCC 4.4.5 
（MIPS） ................................. 885 
100.4 练习题 2.13 ....................................... 885 
100.4.1 Optimizing MSVC 2012 ......... 886 
100.4.2 Keil（ARM mode） ............... 886 
100.4.3 Keil（Thumb mode） ............ 886 
100.4.4 Optimizing GCC 4.9.1 
（ARM64） ............................. 886 
100.4.5 Optimizing GCC 4.4.5 
（MIPS） ................................. 887 
100.5 练习题 2.14 ....................................... 887 
100.5.1 MSVC 2012 ............................ 887 
100.5.2 Keil（ARM mode） ............... 888 
100.5.3 GCC 4.6.3 for Raspberry Pi 
（ARM mode） ....................... 888 
100.5.4 Optimizing GCC 4.9.1 
（ARM64） ............................. 889 
100.5.5 Optimizing GCC 4.4.5 
（MIPS） ................................. 890 
100.6 练习题 2.15 ....................................... 891 
100.6.1 Optimizing MSVC 2012 x64 .... 892 
100.6.2 Optimizing GCC 4.4.6 x64 ..... 894 
100.6.3 Optimizing GCC 4.8.1 x86 ..... 895 
100.6.4 Keil（ARM 模式）：面向 
Cortex-R4F CPU 的代码 ........ 896 
100.6.5 Optimizing GCC 4.9.1 
（ARM64） ............................. 897 
100.6.6 Optimizing GCC 4.4.5 
（MIPS） ................................. 898 
100.7 练习题 2.16 ....................................... 899 
100.7.1 Optimizing MSVC 2012 x64 .... 899 
100.7.2 Optimizing Keil（ARM 
mode） ................................... 899 
100.7.3 Optimizing Keil（Thumb 
mode） ................................... 900 
100.7.4 Non-optimizing GCC 4.9.1 
（ARM64） .............................. 900 
100.7.5 Optimizing GCC 4.9.1 
（ARM64） .............................. 901 
100.7.6 Non-optimizing GCC 4.4.5 
（MIPS） ................................. 904 
100.8 练习题 2.17 ........................................ 905 
100.9 练习题 2.18 ........................................ 905 
100.10 练习题 2.19 ...................................... 905 
100.11 练习题 2.20 ...................................... 905 
第 101 章 高难度练习题 ............................. 906 
101.1 练习题 3.2 .......................................... 906 
101.2 练习题 3.3 .......................................... 906 
101.3 练习题 3.4 .......................................... 906 
101.4 练习题 3.5 .......................................... 906 
101.5 练习题 3.6 .......................................... 907 
101.6 练习题 3.8 .......................................... 907 
第 102 章 Crackme/Keygenme ................ 908 
附录 A x86 ...................................................... 909 
A.1 数据类型 ............................................... 909 
A.2 通用寄存器 ........................................... 909 
A.2.1 RAX/EAX/AX/AL ..................... 909 
A.2.2 RBX/EBX/BX/BL ...................... 910 
A.2.3 RCX/ECX/CX/CL ...................... 910 
A.2.4 RDX/EDX/DX/DL ..................... 910 
A.2.5 RSI/ESI/SI/SIL ........................... 910 
A.2.6 RDI/EDI/DI/DIL ........................ 910 
A.2.7 R8/R8D/R8W/R8L ..................... 911 
A.2.8 R9/R9D/R9W/R9L ..................... 911 
A.2.9 R10/R10D/R10W/R10L ............. 911 
A.2.10 R11/R11D/R11W/R11L ............ 911 
A.2.11 R12/R12D/R12W/R12L ........... 911 
A.2.12 R13/R13D/R13W/R13L ........... 911 
A.2.13 R14/R14D/R14W/R14L ........... 912 
A.2.14 R15/R15D/R15W/R15L ........... 912 
A.2.15 RSP/ESP/SP/SPL ..................... 912 
A.2.16 RBP/EBP/BP/BPL .................... 912 
A.2.17 RIP/EIP/IP ................................ 912 
A.2.18 段地址寄存器 CS/DS/ES/SS/ 
FS/GS ........................................ 913 
A.2.19 标识寄存器 .............................. 913 
A.3 FPU 寄存器 .......................................... 913 
A.3.1 控制字寄存器（16 位） ........... 914 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
6 
逆向工程权威指南（下册） 
A.3.2 状态字寄存器（16 位） ........... 914 
A.3.3 标记字寄存器（16 位） ........... 915 
A.4 SIMD 寄存器 ....................................... 915 
A.4.1 MMX 寄存器 ............................ 915 
A.4.2 SSE 与 AVX 寄存器 .................. 915 
A.5 FPU 调试寄存器 .................................. 915 
A.5.1 DR6 规格 ................................... 916 
A.5.2 DR7 规格 ................................... 916 
A.6 指令 ...................................................... 917 
A.6.1 指令前缀 ................................... 917 
A.6.2 常见指令 ................................... 917 
A.6.3 不常用的汇编指令 .................... 922 
A.6.4 FPU 指令 ................................... 927 
A.6.5 可屏显的汇编指令（32 位） ..... 928 
附录 B ARM .................................................. 931 
B.1 术语 ...................................................... 931 
B.2 版本差异 .............................................. 931 
B.3 32 位 ARM（AArch32） ..................... 931 
B.3.1 通用寄存器 ................................ 931 
B.3.2 程序状态寄存器/CPSR ............. 931 
B.3.3 VFP（浮点）和 NEON 
寄存器 ....................................... 932 
B.4 64 位 ARM（AArch64） ..................... 932 
通用寄存器 ............................................ 932 
B.5 指令 ...................................................... 933 
Conditional codes 速查表 ...................... 933 
附录 C MIPS ................................................. 934 
C.1 寄存器 .................................................. 934 
C.1.1 通用寄存器 GPR ....................... 934 
C.1.2 浮点寄存器 FPR ........................ 934 
C.2 指令 ...................................................... 934 
转移指令 ................................................ 935 
附录 D 部分 GCC 库函数 .......................... 936 
附录 E 部分 MSVC 库函数 ....................... 937 
附录 F 速查表 ................................................ 938 
F.1 IDA ........................................................ 938 
F.2 OllyDbg ................................................. 939 
F.3 MSVC 选项 ........................................... 939 
F.4 GCC ....................................................... 939 
F.5 GDB ....................................................... 940 
附录 G 练习题答案 ....................................... 941 
G.1 各章练习 ............................................... 941 
第 3 章 .................................................... 941 
第 5 章 .................................................... 941 
第 7 章 .................................................... 941 
第 13 章 .................................................. 942 
第 14 章 .................................................. 942 
第 15 章 .................................................. 942 
第 16 章 .................................................. 942 
第 17 章 .................................................. 943 
第 18 章 .................................................. 943 
第 19 章 .................................................. 944 
第 21 章 .................................................. 945 
第 41 章 .................................................. 946 
第 50 章 .................................................. 946 
G.2 初级练习题 ........................................... 947 
G.2.1 练习题 1.1 .................................. 947 
G.2.2 练习题 1.4 .................................. 947 
G.3 中级练习题 ........................................... 947 
G.3.1 练习题 2.1 .................................. 947 
G.3.2 练习题 2.4 .................................. 948 
G.3.3 练习题 2.6 .................................. 949 
G.3.4 练习题 2.13 ................................ 949 
G.3.5 练习题 2.14 ................................ 949 
G.3.6 练习题 2.15 ................................ 949 
G.3.7 练习题 2.16 ................................ 950 
G.3.8 练习题 2.17 ................................ 950 
G.3.9 练习题 2.18 ................................ 950 
G.3.10 练习题 2.19 .............................. 950 
G.3.11 练习题 2.20............................... 950 
G.4 高难度练习题 ....................................... 950 
G.4.1 练习题 3.2 .................................. 950 
G.4.2 练习题 3.3 .................................. 950 
G.4.3 练习题 3.4 .................................. 950 
G.4.4 练习题 3.5 .................................. 950 
G.4.5 练习题 3.6 .................................. 951 
G.4.6 练习题 3.8 .................................. 951 
G.5 其他练习题 ........................................... 951 
G.5.1 “扫雷（Windows XP）” ......... 951 
参考文献 .............................................................. 952
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 4477 章
章    字
字符
符串
串剪
剪切
切  
我们经常需要去除字符串里的开始符号或者结束符号。 
本章介绍的程序，专门用于去除字符串的结尾部分的回车和换行字符 CR/LF。 
#include  
#include  
char* str_trim (char *s) 
{ 
          char c; 
          size_t str_len; 
          // work as long as \r or \n is at the end of string 
          // stop if some other character there or its an empty string' 
          // (at start or due to our operation) 
          for (str_len=strlen(s); str_len>0 && (c=s[str_len-1]); str_len--) 
          { 
                    if (c=='\r' || c=='\n') 
                              s[str_len-1]=0; 
                    else 
                              break; 
          }; 
          return s; 
}; 
int main() 
{ 
          // test 
          // strdup() is used to copy text string into data segment, 
          // because it will crash on Linux otherwise, 
          // where text strings are allocated in constant data segment, 
          // and not modifiable. 
          printf ("[%s]\n", str_trim (strdup(""))); 
          printf ("[%s]\n", str_trim (strdup("\n"))); 
          printf ("[%s]\n", str_trim (strdup("\r"))); 
          printf ("[%s]\n", str_trim (strdup("\n\r"))); 
          printf ("[%s]\n", str_trim (strdup("\r\n"))); 
          printf ("[%s]\n", str_trim (strdup("test1\r\n"))); 
          printf ("[%s]\n", str_trim (strdup("test2\n\r"))); 
          printf ("[%s]\n", str_trim (strdup("test3\n\r\n\r"))); 
          printf ("[%s]\n", str_trim (strdup("test4\n"))); 
          printf ("[%s]\n", str_trim (strdup("test5\r"))); 
          printf ("[%s]\n", str_trim (strdup("test6\r\r\r"))); 
}; 
输入参数总能正常返回并退出。当你需要对串进行批量处理时会非常方便，就像这里的 main()函
数一样。 
在该程序循环体的 for()语句里有两个判断条件表达式：一个条件表达式是 str_len>0（字符串的长度大
于零）；另外一个是 c=s[str_len-1]（意思是取出的值不为 0、不是终止符）。循环判断语句“str_len>0 && 
(c=s[str_len-1])”实际上利用了所谓“逻辑短路”的执行特性，因此可以这样书写第二个判断表达式（可以
参考 Yur13:p.1.3.8）。C/C++编译器自左至右的逐一检测判断条件。因为逻辑操作符是“&&”（与），所以
异步社区会员 dearfuture(15918834820) 专享 尊重版权
486 
逆向工程权威指南（下册） 
一旦第一个条件表达式的值为假，计算机就不用再判断（执行）第二个条件判断表达式。实际上，第二个
条件表达式是一种只能在相应的条件下才可以运行的语句。笔者综合利用了第一个条件表达式、逻辑操作
符“&&”的逻辑含义以及“逻辑短路”的特性，为第二个条件判断表达式限定了执行条件。 
47.1  x64 下的 MSVC 2013 优化 
指令清单 47.1  x64 下的 MSVC 2013 优化 
s$ = 8 
str_trim PROC 
; RCX is the first function argument and it always holds pointer to the string 
; this is strlen() function inlined right here: 
; set RAX to 0xFFFFFFFFFFFFFFFF (-1) 
          or   
rax, -1 
$LL14@str_trim: 
          inc  
rax 
          cmp  
BYTE PTR [rcx+rax], 0 
          jne  
SHORT $LL14@str_trim 
; is string length zero? exit then 
          test  
eax, eax 
$LN18@str_trim: 
          je   
SHORT $LN15@str_trim 
; RAX holds string length 
; here is probably disassembler (or assembler printing routine) error, 
; LEA RDX... should be here instead of LEA EDX... 