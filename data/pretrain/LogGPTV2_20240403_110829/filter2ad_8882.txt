# **漏洞概述**
CVE-2019-0808是微软在2019年3月修补的内核漏洞，该漏洞只影响Windows 7和Windows Server
2008，漏洞允许攻击者提升权限并在内核模式下执行任意代码。在谷歌威胁分析团队的报告中发现该漏洞用于进行Chrome沙箱逃逸，和CVE-2019-5786
Chrome 远程代码执行漏洞配合使用。
# **补丁分析**
通过对Win7上3月份的补丁进行对比可以知道问题出现在xxxMNFindWindowFromPoint函数中，这次的补丁只要对xxxSendMessage函数的返回值进行了检查，如果返回的不是菜单窗口就失败，还检查了tagPOPUPMENU和tagPOPUPMENU中的spmenu是否为空，为空则失败。所以导致漏洞的原因很可能就是tagPOPUPMENU或者tagPOPUPMENU中的spmenu为空。通过对xxxMNFindWindowFromPoint、NtUserMNDragOver和MNGetpItemFromIndex函数进行引用分析，知道可以通过拖动菜单项来触发相关漏洞函数。漏洞成因可以参考360的报告，这里不做详细分析。
# **漏洞利用**
可利用性分析  
通过分析漏洞触发流程知道xxxMNUpdateDraggingInfo函数获得窗口对象后，会通过MNGetpItem函数访问其成员tagPOPUPMENU对象，MNGetpItem函数又会继续访问tagPOPUPMENU对象的spmenu成员，从而造成零指针解引用漏洞。在MNGetpItem中会调用函数MNGetpItemFromIndex，该函数接受菜单对象指针和请求的菜单项索引为参数，根据菜单对象提供的信息返回一个菜单项。  
在MNGetpItem中调用函数MNGetpItemFromIndex，而MNGetpItemFromIndex参数a1就是传入的tagPOPUPMENU对象的spmenu成员，spmenu成员是一个tagMENU结构。在漏洞触发的情况下spmenu成员为空，所以MNGetpItemFromIndex中的`*(_DWORD
*)(a1 + 52)`会触发零指针解引用漏洞。在Windows7 32位的系统中还未引入零页内存保护机制，所以在Windows7
32位的系统中可以通过申请零地址并赋值来通过MNGetpItemFromIndex代码中的取值以及后续代码取值和校验。通过申请零地址可以对零地址的值进行控制，也就可以控制`*(_DWORD
*)(a1 +
52)`的值，a2的值也可以通过全局的消息钩子函数来获取或者修改值，达到控制MNGetpItemFromIndex返回任意值的目的。对于申请零地址，常规的内存申请函数像VirtualAlloc是不允许在小于0x00001000的地址分配内存，只有使用函数NtAllocateVirtualMemory来完成对零地址的分配。通过上面的分析知道MNGetpItemFromIndex返回值result是可控的，而返回的值又是一个菜单项，所以result是一个指向菜单项结构的指针。如果在后续的代码中能找到修改菜单项数据的代码，就可以先通过修改零地址的值来控制result指向任意地址，再通过后续代码修改任意地址的数据，来达到任意代码写的目的。  
对MNGetpItemFromIndex后续的代码进行分析，MNGetpItemFromIndex返回后回到MNGetpItem函数，在MNGetpItem函数中未对返回值进行任何操作直接返回。MNGetpItem函数返回后回到xxxMNUpdateDraggingInfo函数，对xxxMNUpdateDraggingInfo函数进行分析，只发现有对result指针进行取值判断的代码，没有发现对result指向数据进行修改的代码。虽然没有直接修改的代码，但是分析发现在xxxMNUpdateDraggingInfo函数的结尾会调用xxxMNSetGapState函数两次，在第二次会传入pMenuWnd的指针和`*(v3
+ 0x3C)`，而`*(v3 +
0x3C)`也是上图调用MNGetpItem函数的参数。现在知道了如何修改数据，现在分析如何通过代码来准确的控制result的值。通过MNGetpItemFromIndex函数知道result的值是由两个变量运算后相加得到，而这两个变量都可以控制，其中a1是菜单对象指针，a2是菜单项的索引。简单的想法就是直接把a2设置为0，直接把任意地址赋给`*(a1
+ 0x34)`，因为a1为零地址所以`*(a1 + 0x34)`的可以修改为任意值。但是在实际的测试中发现这样做并不行，因为后面会对`*(a1 +
0x34)`当成菜单项指针获取数据用于验证，若`*(a1 +
0x34)`为任意地址则附近的数据不可控，这样可能导致后面的验证不通过。最好的办法就是让`*(a1
+ 0x34)`在零页内存上，这样可以控制`*(a1 +
0x34)`的数据用于后续的验证。假设任意地址的值为addr，可以按如下来设置a1和a2的值。  
任意地址读写  
上文的代码可以实现任意地址与0x80000000进行或运算，直接看可能意义不大，但是可以把这个值转到其它数据结构中去看，比如可以用来修改其它结构表示大小的字段，这样或许就能使该结构覆盖其它数据，再通过一些结构的函数就可以完成任意读写。  
在这里使用tagWND结构体的cbWNDExtra成员，该成员8字节表示窗口附加数据的大小，默认情况下cbWNDExtra大小为0。在之前需要获取cbWNDExtra成员在内核中的偏移。为了获取cbWNDExtra成员的偏移，可以创建了两个窗口WindowA和WindowB，将这两个窗口的窗口类的cbWndExtra成员设置为不同的值。而窗口类的cbWNDExtra正好对应tagWND的
cbWNDExtra成员，创建窗口之后就是获取cbWNDExtra成员在tagWND结构体中的偏移。首先就要获取tagWND结构的地址，获取tagWND可以使用HMValidateHandle函数，这个函数在很多内核漏洞利用代码中都会使用，这里就不单独进行说明。在获取tagWND的地址后，通过扫描WindowA和WindowB的cbWNDExtra成员的值来获取cbWNDExtra成员的偏移。  
获取了cbWNDExtra的偏移，还需要获取保存额外数据的偏移。可以使用SetWindowLong函数向窗口写入额外数据，在使用与获取cbWNDExtra偏移相同的方法来扫描写入的额外数据，进而获取额外数据的偏移。提权  
有了任意地址读写就可以获取system进程的Token，再使用system进程的Token覆盖当前进程的Token，完成提权操作。有了任意读写的能力后替换Token的办法有很多，可以覆盖ntoskrnl!HalDispatchTable表中第二项的hal!HaliQuerySystemInformation()
函数指针后，调用NtQueryIntervalProfile函数执行shellcode，在shellcode中去完成提权。也可以通过tagWND对象来一层层去获取EPROCESS，在EPROCESS中就能获取ActiveProcessLinks，UniqueProcessId，Token，就可以遍历进程获取Token，通过写操作完成提权。