title:Transparency Overlays and Applications
author:Melissa Chase and
Sarah Meiklejohn
Full version of an extended abstract published in ACM CCS 2016.
Transparency Overlays and Applications
Melissa Chase
Microsoft Research Redmond
PI:EMAIL
Sarah Meiklejohn
University College London
PI:EMAIL
Abstract
In this paper, we initiate a formal study of transparency, which in recent years has become an increas-
ingly critical requirement for the systems in which people place trust. We present the abstract concept of
a transparency overlay, which can be used in conjunction with any system to give it provable transparency
guarantees, and then apply the overlay to two settings: Certiﬁcate Transparency and Bitcoin. In the latter
setting, we show that the usage of our transparency overlay eliminates the need to engage in mining and
allows users to store a single small value rather than the entire blockchain. Our transparency overlay is
generically constructed from a signature scheme and a new primitive we call a dynamic list commitment,
which in practice can be instantiated using a collision-resistant hash function.
1 Introduction
In the past decade, the trust that society places in centralized mechanisms run by government, network
operators, and ﬁnancial institutions has been eroding, with various incidents demonstrating that high integrity
cannot be achieved solely through trust in one or a handful of parties. As a reaction to this erosion in trust,
two alternative architectures have emerged: users have either taken matters into their own hands and ﬂocked
to systems that have no central point of trust, or they have increased pressure on central entities to provide
more openness and accountability.
A prominent example of a system with no central point of trust is Bitcoin [28], which was deployed in
January 2009. Bitcoin is a monetary system that is not backed by any government and is managed through a
consensus mechanism over a peer-to-peer network; there is thus no single entity that issues bitcoins or validates
individual transactions, and users of Bitcoin operate using pseudonyms that are not inherently tied to their
real-world identity. Bitcoin has achieved staggering success: as of this writing, its market capitalization is over
8 billion USD and its underlying structure has inspired hundreds of alternative cryptocurrencies; payment
gateways such as Bitpay and Coinbase allow thousands of vendors to accept it; a number of governments have
taken steps to legitimize Bitcoin via interfaces with traditional ﬁnancial and regulatory infrastructures; and
major ﬁnancial institutions such as JPMorgan Chase [30] and Nasdaq [29] have announced plans to develop
Bitcoin-based technologies.
Bitcoin and its variants have achieved a large degree of success, but denying all forms of central authority
arguably limits their ability to achieve widespread adoption. Thus, technological solutions have emerged
that instead seek to provide more visibility into currently centralized systems. One key example of such a
system is Certiﬁcate Transparency (CT) [21], which addresses shortcomings with SSL certiﬁcate authorities
(CAs) — which have ranged from failing to verify the identity of even major website owners such as Google
before issuing a cryptographic certiﬁcate [10, 19] to suﬀering major hacks [25] that result in hundreds of forged
certiﬁcates being issued [22] — and empowers users to verify for themselves the correct functioning of a system
with which they interact many times a day (e.g., any time they log in to a secure website, such as their email
provider). Unlike Bitcoin’s approach, CT does not substantially alter the underlying infrastructure (i.e., the
issuance of a certiﬁcate is largely unchanged), but instead provides a way for anyone to monitor and audit
the activities of CAs to ensure that bad certiﬁcates can be detected quickly, and misbehaving authorities
identiﬁed and excluded.
While Bitcoin and Certiﬁcate Transparency provide solutions in diﬀerent settings, they in fact share some
common features; most notably, they rely on transparency as a means to achieve integrity. In Bitcoin, the
ledger of transactions — called the blockchain — is completely transparent, meaning all Bitcoin transactions
are globally visible. A similar property is provided in Certiﬁcate Transparency, in which a distributed set of
servers each maintain a globally visible log of all the issued certiﬁcates of which they are aware.
Furthermore, both Bitcoin and CT adopt a distributed solution, which is essential to avoid placing trust
in any single entity. Indeed, relying on one party creates (at worst) a system in which this central party has
1
unilateral control over the information that is released, or (at best) a system with one central point of failure
on which attackers could target their eﬀorts. By using a solution that is both transparent and distributed,
these systems intuitively provide some notion of public auditability: individual users can check for themselves
that only “good” events have taken place (e.g., in the case of Bitcoin, that all bitcoins have been spent at most
once) and detect misbehavior on the part of all actors within the system. Understanding the link between
transparency and the types of misbehavior that can be detected across a variety of settings is one of the main
motivations behind this work.
1.1 Our contributions.
Systems such as Bitcoin and CT seem to provide important transparency beneﬁts (namely, the public au-
ditability mentioned above), but the similarities and diﬀerences between their beneﬁts are not well understood,
and no formal analysis has demonstrated either the level of transparency that they provide or how this trans-
parency provides the intended beneﬁts. In this paper, we initiate such a formal study. In doing so, we seek to
not only compare the diﬀerent guarantees provided by these systems (although our analysis does accomplish
this), but more importantly to create an abstract transparency overlay that may be used to provide these
guarantees in a variety of applications beyond ﬁnancial transactions and certiﬁcate issuance.
Before we can analyze these protocols or construct a transparency overlay, we must ﬁrst consider the
crucial components that make up these systems. Our ﬁrst step is thus to formalize — in Section 3.2 — a
primitive that we call a dynamic list commitment (DLC); a DLC can be thought of as a generalization of a
rolling hash chain or hash tree, and serves as the foundation for our construction of a transparency overlay.
After deﬁning this underlying primitive, we then go on to present transparency overlays in Section 4; here
our design is heavily inspired by the design of CT. We begin with a formal model for transparency overlays,
and then go on to present an abstract transparency overlay and prove its security.
Armed with this abstract secure transparency overlay, we go on in Section 5 to demonstrate that CT is
a secure transparency overlay. We also demonstrate that our formal notion of security implies more intuitive
notions of security in this setting (i.e., that users should accept only “good” certiﬁcates) and discuss some
practical considerations.
In Section 6, we continue by turning our attention to the Bitcoin protocol. Here, we do not use the
protocol directly (as we argue that it clearly cannot satisfy our notions of security), but rather plug crucial
components of the protocol into our abstract transparency overlay. While this allows us to achieve a provably
secure transparency overlay for Bitcoin, it more importantly also implies that “regular” Bitcoin users (i.e.,
users interested only in transacting in bitcoin, rather than engaging in the mining process) can operate
signiﬁcantly more eﬃciently, provided they are willing to outsource some trust to a distributed set of parties.
This result demonstrates that, in any setting in which users are willing to trust any distributed set of parties,
the full decentralization of Bitcoin is not needed, and the same goals can in fact be accomplished by a CT-
like structure, in which regular users store signiﬁcantly less information about the transaction ledger and the
mining process is superﬂuous; i.e., the quadrillion hashes per second expended on Bitcoin mining (as of March
2016) can be eliminated without sacriﬁcing security. Our formal analysis thus reveals the ﬁne line separating
fully decentralized (and expensive) solutions like Bitcoin from distributed (and relatively cheap) solutions like
CT, and we hope that our results can help to inform future decisions about which protocol to adopt.
1.2 Related work.
We consider research that is related both in terms of the applications of Bitcoin and Certiﬁcate Transparency,
and in terms of the underlying primitives used to construct our transparency overlay.
An emerging line of work has both formalized some of the properties provided by the Bitcoin network and
bootstrapped Bitcoin to obtain provably secure guarantees in other settings. Garay et al. [17] analyzed the
so-called “backbone” protocol of Bitcoin and prove that it satisﬁes two important properties as long as the
adversary controls some non-majority percentage of the hashing power. Similarly, Bentov and Kumaresan [8]
provided a two-party computation built on top of (an abstracted version of) Bitcoin that provably achieves
a notion of fairness, and Andrychowicz et al. [3] used Bitcoin to build a provably fair system for multi-party
computation. Andrychowicz and Dziembowski [2] further formalized some of the fairness properties they
require from Bitcoin (and more generally from systems based on proof-of-work) and used them to construct a
broadcast protocol. Finally, on the privacy side, the Zerocash project [6] provides a cryptocurrency that has
provable anonymity guarantees, and Garman et al. [18] showed how to adapt the decentralized approach of
Bitcoin to achieve anonymous credentials. To the best of our knowledge, ours is the ﬁrst paper to focus on
the transparency property of Bitcoin, rather than its privacy or fairness guarantees.
2
(a) Certiﬁcate issuance.
(b) Bitcoin.
Figure 1: The basic structure for each of the settings in which we apply transparency.
Aside from CT, a number of other solutions exist for changing the way we interact with certiﬁcate au-
thorities; many of these solutions require a ground-up redesign of the CA ecosystem, which is why we chose
to examine CT instead and use it as our inspiration for an overlay system. Fromknecht et al. [16] propose
a decentralized PKI, based on Bitcoin and Namecoin, that eliminates the trust in centralized authorities
altogether. CONIKS [24] provides an approach to logging certiﬁcates that diﬀers from CT in two key ways:
it focuses on user rather than website certiﬁcates, and largely because of this it provides a privacy-preserving
solution, in which certain aspects of the stored certiﬁcates (e.g., usernames) are kept hidden. The Accountable
Key Infrastructure [20] and the related ARPKI [4] both require a distributed infrastructure for not only the
storage of issued certiﬁcates (as CT does), but also for their issuance, thus focusing on the prevention rather
than just detection of misbehavior. Ryan [33] demonstrated how to extend CT to handle revocation of certiﬁ-
cates. In a concurrent work, Dowling et al. [15] provided a diﬀerent security model for CT and demonstrated
that if various properties of the underlying Merkle trees are satisﬁed then CT is provably secure in their
model. Although somewhat overlapping with our own work, their paper is focused ﬁrmly on CT and not on
the abstract properties of transparency overlays and how they can be applied across a variety of settings.
Finally, the main primitive underlying our transparency overlay (a dynamic list commitment) is primarily
a generalization of a Merkle tree [26], and is similar to the deﬁnition of a tamper-evident log given by Crosby
and Wallach [13]. It is also related to the notion of an authenticated data structure (ADS) [1, 32, 31] and the
notion of a cryptographic accumulator [7, 12, 11, 23]; indeed the application of ADSs to Bitcoin has already
been touched on in previous work [27] (but from the perspective of programming languages, and thus without
any consideration of security). Dynamic list commitments diﬀer from these related primitives in terms of the
security model, however, and as a result we can provide more eﬃcient constructions while still satisfying a
notion of provable security.
2 Background
2.1 Certiﬁcate Transparency
Certiﬁcate Transparency (CT) was proposed in 2011 by Ben Laurie and Adam Langley as a way to increase
transparency in the process of issuing certiﬁcates, so that certiﬁcate authorities (CAs) can be held responsible
for their actions and bad certiﬁcates can be caught and revoked early on. The basic process of issuing
certiﬁcates operates as depicted in Figure 1a: a CA issues a certiﬁcate to a website operator, who then
publishes this certiﬁcate so that users can check it. Certiﬁcate Transparency then provides an extra layer
on top of this basic interaction to provide transparency; in fact, as we will see in Section 4, our design of a
transparency overlay is heavily inspired by the CT design.
Brieﬂy, CT introduces three additional actors: a log server, who is responsible for keeping track of issued
certiﬁcates, an auditor, who is responsible (on behalf of the client) for keeping track of whether given certiﬁ-
cates are in the log or not, and a monitor, who is responsible for checking the quality of the certiﬁcates in
the log. As we use these additional actors in our general transparency overlay, we defer further discussion of
their roles and actions to Section 4.1. In Section 5, we prove that CT provides a provably secure transparency
overlay, thus (provably) providing the intuitive security properties that one would hope to achieve.
2.2 Bitcoin
Bitcoin is a decentralized cryptocurrency that was introduced in 2008 [28] and deployed on January 3 2009.
We brieﬂy sketch the main properties of Bitcoin and its underlying blockchain technology here, and refer the
3
CAsiteusercertcertminersenderreceivertxtxblockCAsiteusercertcertminersenderreceivertxtxblockreader to Bonneau et al. [9] for a more comprehensive overview.
Brieﬂy, Bitcoin operates as depicted in Figure 1b. A sender, identiﬁed using a pseudonym or address, has
some number of bitcoins stored with this address; i.e., within the Bitcoin network, this address is acknowledged
as the owner of these bitcoins. To transfer ownership of these bitcoins to some receiver, the sender ﬁrst creates
a transaction to send them to the receiver, as identiﬁed by whichever address she has given to the sender.
The transaction is signed to ensure that only the sender can give away his own bitcoins.
After forming this transaction, the sender broadcasts it to the Bitcoin network, where it eventually reaches
a miner, who acts to seal the transaction into a block. The miner broadcasts this block, containing the
transaction, to the network, where it eventually reaches the receiver, who can conﬁrm the transaction and
its position within the Bitcoin ledger (i.e., the blockchain) to satisfy herself that she is now the owner of the
bitcoins.
Because the Bitcoin blockchain is globally visible, it already provides a degree of transparency that is
higher than that of traditional ﬁnancial transactions. In Section 6, we apply a transparency overlay on top
of Bitcoin and demonstrate that it provides a signiﬁcantly more eﬃcient way for Bitcoin users to participate
in transactions and allows hashing to be eliminated from the system.
3 Deﬁnitions and Notation
In this section, we deﬁne various notions that will be used throughout the rest of the paper. In particular,
we formalize dynamic list commitments in Section 3.2, which can be thought of as a generalization of Merkle
trees and allow us to construct high-integrity logs.
3.1 Preliminaries
If x is a binary string then |x| denotes its bit length. If S is a ﬁnite set then |S| denotes its size and x r←− S
denotes sampling a member uniformly from S and assigning it to x. λ ∈ N denotes the security parameter
and 1λ denotes its unary representation. ε denotes the null value.
Algorithms are randomized unless explicitly noted otherwise. “PT” stands for “polynomial-time.” By
y ← A(x1, . . . , xn; R) we denote running algorithm A on inputs x1, . . . , xn and random coins R and assigning
its output to y. By y r←− A(x1, . . . , xn) we denote y ← A(x1, . . . , xn; R) for coins R sampled uniformly at
random. By [A(x1, . . . , xn)] we denote the set of values that have positive probability of being output by A
on inputs x1, . . . , xn. Adversaries are algorithms.
For interactive protocols, we use the notation of Bellare and Keelveedhi [5]. For completeness, we include
the formal notion of deﬁning and executing interactive protocols in Appendix A. Brieﬂy, the behavior of a
stateful participant party that is given m during the i-th round of the j-th execution of a protocol Prot can
r←− Prot[party, i, j](1λ, stateparty, m), where p indicates the party to which
be deﬁned as (stateparty, m(cid:48), p, out)
it is sending m(cid:48); the execution of the entire interactive protocol can be deﬁned by outputs r←− Run(1λ, Prot,
Parties, inputs); and the message sent during the protocol (i.e., the transcript) can be deﬁned by M r←−
Msgs(1λ, Prot, Parties, inputs).
We use games in security deﬁnitions and proofs. A game G has a main procedure whose output is the
output of the game. Pr[G] denotes the probability that this output is true.
3.2 Dynamic list commitments
We deﬁne a dynamic list commitment (DLC), which allows one to commit to a list of elements in such a way
that (1) the list represented by the commitment can be updated only by having new elements appended to
the end, and (2) given just the list commitment, one can eﬃciently prove both the append-only property of
the list and that a given element is in the list.
One common example of a DLC is a hash tree, and in particular a Merkle tree, in which the root hash
acts as the commitment and one can use the hashes of intermediate nodes to prove the above properties.
(Indeed, this is what CT uses.) Our basic formalization is similar to the deﬁnition of a tamper-evident history
system [13], but we also include an augmented version that considers additional properties one can use when
operating on ordered lists.
3.2.1 A basic formalization for general lists.
We deﬁne a dynamic list commitment DLC as a collection of the following algorithms:
4
to list;
• c ← Com(list) creates the commitment c and 0/1 ← CheckCom(c, list) checks that c is a commitment
• cnew ← Append(list∆, cold) updates the commitment to take into account the new elements in list∆;
• π ← ProveAppend(cold, cnew, list) proves that cnew was obtained from cold solely by appending elements
• π ← ProveIncl(c, elmt, list) proves that elmt is in list (as represented by c); and 0/1 ← CheckIncl(c, elmt,
to an earlier version of list and 0/1 ← CheckAppend(cold, cnew, π) checks this proof;
π) checks this proof.
Deﬁnition 3.1. A DLC is correct if the following properties are satisﬁed for all lists list and list∆, for all
elmt ∈ list, and for c ← Com(list):
• CheckCom(c, list) = 1;
• CheckIncl(c, elmt, ProveIncl(c, elmt, list)) = 1;
• Append(list∆, c) = Com(list(cid:107)list∆); and
• CheckAppend(c, Append(list∆, c), ProveAppend(c, Append(list∆, c), list)) = 1.
We say that a DLC is compact if Com(list)| (cid:28) |list| for all suﬃciently long lists list. For security, intuitively