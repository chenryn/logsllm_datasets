根据ECMAScript语言特性（http://www.ecma-international.org/ecma-262/5.1/#sec-8）第8章的内容，JavaScript中只含有6种类型。
ECMAScript类型的值是由使用ECMAScript语言的程序员直接操作的。ECMAScript语言类型包括：
Undefined, Null；
Boolean, String, Number；
Object。
因此，从技术上讲，构造函数虽然会有各自的实例，但是它们不会引入新的类型。
8.1.2 静态与动态
在编程语言的语义和类型体系环境中，静态一般是指“编译时”或者“非运行时”，动态指的是“运行时”。
8.1.3 静态类型与动态类型
在静态类型语言中，变量、参数和对象成员（JavaScript称它们为属性）都有编译器编译时能识别的类型。编译器可以通过这些信息执行类型检查和优化编译的代码。
即使在动态类型语言中，变量依然有一个动态的类型，是指在执行的某一时刻变量值的类型。动态类型不同于静态类型。例如（Java）：
foo的静态类型是Object；它的动态类型是String。
JavaScript是动态类型的语言；变量的类型在编译的时候是不确定的。
8.1.4 静态类型检查和动态类型检查
如果你有类型信息，你可以检查操作中的变量（调用函数、执行某个操作等等）是否有正确的类型。静态类型检查语言会在编译期间进行检查，动态类型检查语言会在执行期间进行检查。一种语言可以同时做静态类型检查和动态类型检查。如果检查失败了，程序会抛出错误或者异常。
JavaScript可以执行非常有限的动态类型检查。
然而，大多数情况下，操作都是默默地进行，无论执行成功或者失败。例如，如果访问一个不存在的属性值，将会得到undefined。
8.1.5 强制转换
在JavaScript中，处理变量类型不适配的情况，最主要的方法是将它强制转换为正确的类型。强制转换意味着隐式的类型转换。大多数操作会强制转换类型：
JavaScript内置的转换机制只支持布尔值、数字、字符串和对象。没有标准的方法将某个构造函数的实例转换为另一个构造函数的实例。
警告：
 强类型和弱类型没有通常意义上的定义（http://bit.ly/1oO7t1p）。它们经常被使用，但通常来说是不正确的。最好使用静态类型和静态类型检查已等方式。
8.2 原始值和对象
JavaScript中，对值的区分有点自由：
原始值包括布尔值、数字、字符串、null和undefined。
其他的值都是对象。
两者之间最主要的区别是类别内是如何互相比较的。每一个对象有唯一的标识符并且只（严格）和自身相等：
相反，所有的原始值，只要编码值相同，则被认为相等：
后面两节将更详细地介绍原始值和对象。
8.2.1 原始值
以下即为所有的原始值（或简称为primitives）。
布尔值：true，false（参见第10章）。
数字：1736，1.351（参见第11章）。
字符串：'abc'，"abc"（参见第12章）。
两个“空值”：undefined，null（参见8.3“undefined和null”）。
原始值具有以下特点。
（1）按值进行比较
内容比较：
（2）不可改变
其属性不能被改变、添加或移除：
（读取一个未知属性时，总会返回undefined。）
（3）固定类型的组合
你不能够自定义原始值。
8.2.2 对象
所有的非原始值都是对象。最常见的对象如下。
简单对象，可以通过对象字面量来创建（参见第17章）。
上述对象有两个属性，属性firstName的值是Jane，属性lastName的值是Doe。
数组，可以通过数组字面量来创建（参见第18章）。
上面的数组有3个元素，可以通过数字索引来访问它们。比如，'apple'的索引是0。
正则表达式，可以通过正则表达式字面量来创建（参见第19章）。
对象具有以下特点。
（1）按引用进行比较
每个值都有各自的身份标识，比较引用时会比较对象的身份标识；：
（2）默认可变
对象属性可以很自由地被改变、添加和移除（参见17.1.3“点运算符(.)：通过固定键值访问属性”）：
（3）用户可扩展
构造函数（参见17.10“第3层：构造函数——实例工厂”）可以被看作是自定义类型（类似于其他函数中的类）的补充。
8.3 undefined和null
JavaScript有两个“空值”用来表示信息缺失，undefined和null。
undefined表示“没有值”（既不是原始值也不是对象）。访问未初始化的变量、缺失的参数，以及缺失的属性会返回这个空值。并且如果函数中没有任何显式的返回值时，则会隐式地返回undefined。
null的意思是“没有对象”。在用到对象的时候它表示空值（比如参数、对象链中的最后一个元素等）。
undefined和null是仅有的在访问任何属性抛出异常时都会得到的值。
undefined更多的时候是表示不存在的元数据。相反的，null表示空值。例如，访问一个JSON节点时（参见22.4“通过节点访问函数转换数据”）返回值的意义如下。
undefined表示删除一个对象属性或者数组元素。
null表示将属性或者元素设置为空。
8.3.1 undefined和null的出现场景
我们回顾一下undefined和null出现的各种场景。
undefined出现的场景
未初始化的变量是undefined：
缺失的参数是undefined：
如果访问一个不存在的属性，会返回undefined：
如果函数中没有显式地返回任何值，函数会隐式返回undefined：
null的出现场景
null是原型链最顶端的元素（由对象组成的链条，参见17.4“第.2层：对象间的原型关系”）：
当字符串中没有匹配到正则表达式的结果时，RegExp.prototype.exec()会返回null：
8.3.2 检测undefined和null
在下面的内容中我们会回顾一下如何分别检测undefined和null，以及如何检测它们是否存在。
检测null
通过严格相等检测null：
检测undefined
通过严格相等（===）检测undefined，它是一种规范的检测方法：
你也可以通过typeof运算符检测undefined（参见9.8.1小节的“typeof：判断原始值”），但是最好使用上面提到的方法。
检测undefined或null
大多数函数允许使用undefined或null来表示缺省值。有一种显式的比较方式可以用来检测它们。
另一种检测方式是利用undefined和null都可被认为是false的特性（参见10.1.2“真值和假值”）：
警告：
 false，0，NaN和 '' 也可以被认为是false。
8.3.3 undefined和null的历史
undefined和null两者都可以作为一个简单的空值。为什么JavaScript有两个这样的值呢？这是有历史原因的。
JavaScript采用了Java中将变量分为原始值和对象的处理方式。同时也使用Java中表示“非对象”的值null。遵循C语言的先例，null在强制转换为数字时会变为0（Java不会这样）。
值得注意的是，JavaScript的第一个版本没有异常处理。因此，在遇到未初始化的变量和缺失的参数等异常情况时需要通过一个值来表示。null是一个很好的选择，但是Brendan Eich想要在这个时候避免两种情况。
这个值不应该具有指向性，因为它表达的不仅仅是一个对象。
这个值的强制转换不应该为0，因为这会使错误难以发现。
因此，Eich将undefined作为另外一个空值加进了JavaScript。它会强制转换为NaN：
8.3.4 修改undefined
undefined是全局对象（http://bit.ly/10OqpXM）的一个属性（同时也是一个全局变量，参见16.8“全局对象”）。在ECMAScript 3中，看到undefined时需要特别注意，因为很轻易地就会改变它的值。在ECMAScript 5中就没有必要，因为undefined是只读的。
有两种很流行的技巧可以用来防止改变undefined（它们对于老的JavaScript引擎还是很有意义的）：
（1）技巧一
隐藏全局undefined（因为它可能是错误的值）。
在上面的代码中，undefined保证会是正确的值，因为它的值不是由函数调用时所提供的。
（2）技巧二
和'void 0'进行比较，'void 0'总是undefined（参见9.7.3小节的“void运算符”）。
8.4 原始值的包装对象
布尔值、数字和字符串这三种原始值都有相应的构造函数：Boolean，Number，String。它们的实例（称为包装对象）包含原始值。这些构造函数有两种用法。
作为构造函数，它们创建的对象和它们包装的原始值有很大的不同。
作为函数，它们会将值转换为相应的原始值（参见8.5.2“转换成布尔值、数字、字符和对象的函数”）。这是推荐的转换方法。
提示：
 避免包装对象被认为是一种最佳实践。你或许并不会用到它，因为没有什么事情是对象能做而原始值不能的（修改除外）。（这与Java不同，JavaScript中继承了原始值和对象的不同。）
8.4.1 包装对象不同于原始值
原始值（比如'abc'）从根本上与包装实例有很大差别（比如new String('abc')）：
包装实例是对象，而在JavaScript中没有比较对象的方法，即使是通过宽松相等==（参见9.1.4“等号运算符：===和==”）。
8.4.2 原始值的包装与去包装
有一种使用包装对象的场景：在你需要对一个原始值增加属性时，首先要对这个原始值进行包装并且给包装后的对象增加属性，而当你要使用值之前需要先对它进行去包装。
通过调用包装构造函数来对原始值进行包装：
通过调用valueOf()来对原始值进行去包装。所有的对象都有这个方法（参见17.15.1“转换为原始值”）。
将包装对象转换为原始值时只能正确地提取出数字和字符串，而布尔值则不能。
本书在10.1“转换成布尔值”中解释了这个问题。
8.4.3 原始值从包装器借调方法
原始值没有私有方法，但是它们会从各自的包装器中借调方法：
宽松模式和严格模式会以不同的方式处理“借调”过程。在宽松模式中，原始值会在运行过程中转换为包装器：
在严格模式中，对包装器原型方法的调用是透明的。
8.5 强制类型转换
强制类型转换指的是值从一种类型隐式地转换成另外一种类型。JavaScript的大多数运算符、函数、方法会将调用的运算数和参数强制转换为它们需要的类型。例如，乘法运算符（*）的运算数会强制转换为数字：
另一个例子，在加法运算中，如果其中一个运算数为字符串，加法运算符（+）会将另一个运算数转换为字符串：
8.5.1 强制类型转换会隐藏bug
有鉴于此，JavaScript中很少听到关于类型错误的抱怨。例如，程序接受的用户输入（通过在线表单或者GUI小部件）为字符串，即使输入的是一个数字也没关系。如果将一个字符串类型的数字作为数字使用，也不会得到警告，但这不是我们所期望看到的。例如：
像上面这样的例子，应该提前将变量转换为合适的类型：
8.5.2 转换成布尔值、数字、字符串和对象的函数
推荐使用下面的函数将值转换为布尔值、数字、字符串和对象：
Boolean()（参见10.1“转换成布尔值”）
转换为布尔值。下面的值都将被转换为false；它们也被称为“假值”：
undefined, null
false
0, NaN
''
其他值被称为“真值”并且会被转换为'true'（包括所有的对象）。
Number()（参见11.2“转换成数字”）
转换为数字：
undefined会转换成NaN。
null会转换成0。
false会转换成0，true会转换成1。
字符串会被解析。
对象会先转换为原始值（很快会讲到），然后再转换为数字。
String()（参见12.4“转换为字符串”）
转换为字符串。所有原始值转换为字符串的结果显而易见。例如：
对象会先转换为原始值（马上会讲到），然后再转换为字符串。
Object()（参见17.2“把任意值转换为对象”）
对象会转换为它们自身，undefined和null会转换成空对象，而原始值会转换为包装后的原始值。例如：
注意这里'Boolean()', 'Number()', 'String()'和'Object()'是作为函数调用，而不是作为构造函数。它们创建了各自的实例（参见8.4“原始值的包装对象”）。
8.5.3 算法：ToPrimitive()——将值转换为原始值
要将任意值转换为数字或者字符串，首先会被转换为任意的原始值，然后再转换为最终的结果（参见8.5.2“转换成布尔值、数字、字符串和对象的函数”）。
ECMAScript规范中有一个内部函数，ToPrimitive()（JavaScript中不能访问）,能够实现这个功能。理解ToPrimitive()能帮助你理解对象是如何转换为数字和字符串的。该函数形如：
可选参数PreferredType表明转换后的类型：它可以是Number或String，具体取决于ToPrimitive的结果是希望转换成数字还是字符串。
如果PreferredType是Number，会执行以下步骤。
（1）如果input是原始值，返回这个值（没有其他需要做的）。
（2）否则，如果input是对象，调用input.valueOf()。如果结果是原始值，返回结果。