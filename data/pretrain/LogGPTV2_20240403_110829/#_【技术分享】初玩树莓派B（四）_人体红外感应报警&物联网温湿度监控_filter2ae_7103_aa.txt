# 【技术分享】初玩树莓派B（四） 人体红外感应报警&物联网温湿度监控
|
##### 译文声明
本文是翻译文章，文章来源：IamHuskar@看雪论坛
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
**传送门**
* * *
[](http://bobao.360.cn/learning/detail/3051.html)
[**【技术分享】初玩树莓派B（一） 基本介绍
&安装操作系统**](http://bobao.360.cn/learning/detail/3085.html)
[**【技术分享】初玩树莓派B（二） 实用配置(vnc和串口)
&GPIO操作点亮LED灯**](http://bobao.360.cn/learning/detail/3087.html)
[**【技术分享】初玩树莓派B（三） 控制蜂鸣器演奏乐曲**](http://bobao.360.cn/learning/detail/3093.html)
**  
**
**人体红外感应报警**
前面的LED灯我们操作使用的GPIO的输出功能,这次我们终于需要用到GPIO的输入功能了。由于这个人体红外感应模块的使用比较简单。所以我们实验完毕以后配合前面的蜂鸣器一起，做一个简单的人体感应报警器。
**1\. HC-SR501 感应模块简介**
我们采用 HC-SR501型号的人体红外感应器来探测人体。更加详细的参数参考模块的使用说明书。
对照前面的参数以及电路图，找到下面的左右针脚正负极，中间的PIN为感应输出，感应到人体时，输出3.3V高电平，检测不到信号时输出0。同时还要求工作电压在4.5V-20V之间。恰好树莓派的P1编号中第2，4号PIN都是5V的电压，满足要求，所以这次我们要接5V的电压。
参数调节旋钮是用来扭动控制一些参数的。比如探测的延时时间，灵敏度等等。具体可以参看 HC -SR501的说明书。这里我们都使用默认值。
但是有一个关键的L H模式调节阀门要介绍一下，右上角有三个针脚，按照我实物照片，假定从上到下为123 。还有一个黄色的套接头，图中套接头接通了2
3号，代表了H模式，这个套接头是可以拔下来的，然后插到上面来，接通1 2号，代表了L模式。
L模式是不可重复触发，当探测到一次人体时，输出一次高电平，保持一段时间恢复低电平，在此期间如果还是检测到了人体也不再延长这个高电平的时间。等到低电平的封锁时间（前面默认是2.5S）过了以后才又开始检测。
H模式是可以重复触发，如果一直感应到人体时，会一直输出高电平，直到探测不到人体后保持小段时间然后恢复低电平。
**2\. GPIO输入的上拉和下拉**
对于学习软件的人来说，软件的世界只有0和1，所以我接触硬件之前也是这么认为的。所以我在使用人体红外感应的时候遇到了一个问题，我认为只要设置GPIO的模式为INPUT，后面只需要读取针脚的状态0,1就行了。结果我遇到一个问题。当我在设置比如pin22（wiringpi标号为6）为INPUT模式，接上一根线后，这一条线另一端什么都不接，按理说这时应该输入为0V，但是我尝试读取发现并不是一直保持低电平，而是一会儿高，一会低，用手握住另外一端就会输出高电平。当我接pin3（wiringPi
标号为8）却始终是高电平。不得不查询各种资料，发现还有上拉和下拉这种说法。
当我们给一个针脚接入GND，那么就是低电平，如果我们给一个针脚3.3V，那么就是高电平，状态是很确定的。如果我们什么都不接，那么这个针脚处于悬浮状态，很容易受到外接的干扰，可能是高也可能是低，也可能是处于高和低之间的状态。这时候我们就要明确指定这个针脚应该处于高或者低，不能让他处于悬浮状态。接入一个上拉电阻能够让这个针脚处于明确的高电平状态，接入一个下拉电阻能够让他处于明确的低电平状态。前面我们用作输出的时候都是明确给定了输出的高低状态。关于上拉电阻和下拉电阻，有一篇英文解释写的很不错，我也是参考这篇来看的，里面的测试大家也可以用树莓派测试一下。（）。
PIN3始终处于高电平状态是因为。这个PIN口是用于树莓派I2C设备的，内部外接了一个物理的上拉电阻。所以他的状态一直是高电平，作为INPUT不能使用这个PIN。
PIN22
时高时低就是由于处于悬浮状态。所以我们要使用这个PIN就比如为他明确指定悬浮的时候是高还是低。wiringpi通过pullUpDnControl来控制这个变量。
**3\. 接线以及测试**
模块左边的针脚1接P1编号的PIN2 为5V的正极，模块右边的针脚3的负极接PIN6，模块中间的针脚2输出线接PIN22（wiringPi就是标号6）。
接线图如下：
图中我连蜂鸣器也接上去了。当我们检测到人体的时候。使用前一节的beep函数发出警告声音。我们先初步检测一下模块有没有工作正常。测试HC-SR501不同的模式。选择的H模式，套接头接下面两个脚。也就是可以重复触发，检测到人体，一直处于高电平。
可以看出中间是连续的检测，也就是高电平的时间随着人的活动延长了。
如果选择的L模式，套接头接上面两个脚。也就是不可以重复触发，检测到人体，输出高电平一段时间，后续一小段时间内检测到也不再延长这个高电平时间，必须等到锁定时间过了才会再次检测。
可以看出中间高电平的时间不是持续的。
检测的代码很简单：
代码:
    #include  
    #include  
    #include  
    #include  
    #define INFRAREDPIN 6 
    int main() 
    { 
     int AnyBodyHere=0; 
     wiringPiSetup(); 
    //设置为输入模式
     pinMode(INFRAREDPIN,INPUT); 
     //很重要。控制默认情况下此PIN处于下拉低电平状态
     pullUpDnControl(INFRAREDPIN,PUD_DOWN); 
     while(true) 
     { 
      //每一秒检测依次状态
      delay(1000); 
      //读取当前pin的输入状态
      AnyBodyHere=digitalRead(INFRAREDPIN); 
      if(AnyBodyHere) 
      { 
         printf("There is somebody heren"); 
      } 
      else 
      { 
         printf("There is no one heren"); 
      } 
     } 
    }
我们稍微修改一下。在检测到人体的时候使用第五节的beep函数执行报警的操作，这里我们选择使用H模式，持续感应，感应到以后使用beep发声。这样就简单实现了人体感应后自动报警。
具体代码下载infrared.c参考。
**物联网温湿度监控**
这一节用温湿度传感器接入中移动物联网上报家中的温湿度。
**1\. dht11传感器使用简介**
DHT11数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器。我购买的dht11只有三个针脚分别是 VCC DATA
GND，(有些是四阵脚的,多一个NC空脚)。
常用电路图：
前面我们已经玩了一些常用模块，接线都比较熟悉了。正极接3.3V，负极接GND，DATA(OUT)针脚我接了物理的11号针脚，对应于WiringPi标号是0,同时为DATA针脚接入一个5K欧姆的上拉电阻，使得空闲状态的时候为高电平。
对于之前使用的一些模块，我们只需要知道高低电平就可以了，现在要得到的是温度和湿度的具体数据，那么如何通过DATA针脚得到温度和湿度呢？通过DATA针脚采用单总线格式进行数据通讯。依次完整的数据传输为40bit，先读出来的是高位的数据。40bit数据的格式是：8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据+8bit校验和。如果数据是准确的，那么8bit湿度整
8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据的结果的末8位等于8bit校验和。
通讯过程如下，主机首先向传感器发送开始信号，等开始信号发送完毕以后。dht11发送响应信号，依次传回40bit的数据，随后进入空闲状态。
沟通握手过程如下，初始空闲状态DATA为高电平，主机将DATA拉低等待DHT11响应，拉低的时间必须大于18ms保证DHT11可以检测到这个状态。随后dht11等待开始信号结束，主机可以通过拉高电平20-40us表明信号结束。以后就可以准备读取dht11的响应信号了。dht11会发送80us的低电平来响应然后dht11再次将电平拉高持续80us表示后面的数据传输要开始了。
通讯过程如下：dht11每次传输1bit数据的过程是先拉低电平50us。随后拉高电平，高电平的时间长短决定了这1bit的数据是0还是1。当最后一个bit的数据传输完毕以后，dht11拉低电平50ms。随后上拉电阻拉高进入空闲状态。一次数据传输过程完毕。
传输0的过程：
传输1的过程：
关键部分代码如下。
代码:
    /*
    当检测到的状态不是state的时候就返回。
    如果参数state是HIGH，那么需要等到检测到LOW的时候返回。
    返回值代表了状态改变所用的时间计数。
    返回值如果是-1 表明和设备通讯出现了错误，需要重新开始通讯。
    */
    int loopCheckUntilStateChange(int state)
    {
      //初始时间计数为0
      int count=0;
      //读取针脚的状态
      while(digitalRead(DHT11PIN)==state)
      {
        //如果状态没变那么计数加1
        count++;
        //如果计数超过了最大的计数，表明通讯错误，需要重新开始
        if(count>MAX_COUNT)
          return -1;
        //延时1微秒。
        delayMicroseconds(1);
      } 
      return count;
    }
    /*
    读取DHT11。如果读取成功，返回true，否则false。将温度放到 ptemp，将湿度放到
    phumi
    */
    bool readDHT11(float* ptemp,float* phumi)
    {
      int count=0,ibit=0;
      bool bret=false;
      //保存电平改变所用的时间计数
      int bitsz[40]={0};
      //保存读取到的4个温湿度数据和1个校验码
      int data[5]={0};
      //首先设置为输出模式
      pinMode(DHT11PIN,OUTPUT);
      //写入低电平
            digitalWrite(DHT11PIN,LOW);
      //低电平至少持续18ms。保证能够DHT检测到这个初始信号
      delay(20);
      //随后主机将电平拉高，通知DHT信号结束
      digitalWrite(DHT11PIN,HIGH);
      //将针脚转为输入模式，等待DHT的响应。
      pinMode(DHT11PIN,INPUT);
      //经过20-40us，我们需要等待DHT将电平从高电平拉低
      if(loopCheckUntilStateChange(HIGH)<0)
      {
        return bret;
      }
      //DHT的响应信号低电平持续80us，等待DHT再次由低拉高
      if(loopCheckUntilStateChange(LOW)<0)
      {
        return bret;
      }
      //高电平将持续80us,等待DHT将高电平拉低。开始传输数据
      if(loopCheckUntilStateChange(HIGH)<0)
      {
        return bret;
      }
      //数据传输开始。每次传输一个bit。一共40bit。5字节
      for(ibit=0;ibit<40;ibit++)
      {
        //每个bit传输由50us的低电平开始。变为高电平就是开始传输0或者1了。
        if(loopCheckUntilStateChange(LOW)<0)
        {