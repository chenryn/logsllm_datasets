and ehlo are both valid command codes.
2. By using different SMTP extensions, clients might
add different parameters to the commands they
send.
3. Servers typically accept commands that do not com-
ply with the strict SMTP deﬁnitions. Therefore,
a client might implement the protocol in slightly
wrong ways while still succeeding in sending email
messages.
We call different implementations of the SMTP pro-
tocol SMTP dialects. A dialect D is deﬁned as a state
machine
D =,
where Σ is the input alphabet (composed of server
replies), S is a set of states, s0 is the initial state, and
T is a set of transitions. Each state s in S is labeled with
a client command, and each transition t in T is labeled
with a server reply. Fg ⊆ S is a set of good states, which
represent successful SMTP conversations, while Fb ⊆ S
is a set of bad states, which represent failed SMTP con-
versations.


Email a d d r e s s : ?
IP a d d r e s s : \[?\ d{1 ,3}\.\ d{1 ,3}\.\ d{1 ,3}\.\ d{1 ,3}\]?
[\w−]+\.[\w−]+\.\w[\w−]+
F u l l y q u a l i f i e d domain name :
[\w−]+\.[\w−]+
Domain name :
Number :
Hostname :
[\w−]{5}[\w−]+


Figure 2: Simpliﬁed state machines for Outlook Express (left) and Bagle (right).
The state machine D captures the order in which com-
mands are sent in relation to server replies by that partic-
ular dialect.
Since SMTP messages are not always constant, but
contain variable ﬁelds (e.g., the recipient email address
in an RCPT command), we abstract commands and
replies as templates, and label states and transitions with
such templates.
We do not require D to be deterministic. The reason
for this is that some clients show a non-deterministic
behavior in the messages they exchange with SMTP
servers. For example, bots belonging to the Lethic mal-
ware family use EHLO and HELO interchangeably when
responding to a server 220 reply. Figure 2 shows two
example dialect state machines (Outlook Express and
Bagle, a spambot).
3.1 Message Templates
As explained previously, we label states and transitions
with message templates. We deﬁne the templates of the
messages that belong to a dialect as regular expressions.
Each message is composed of a sequence of tokens. We
deﬁne a token as any sequence of characters separated by
delimiters. We deﬁne spaces, colons, and equality sym-
bols as delimiters. We leverage domain knowledge to
develop a number of regular expressions for the variable
elements in an SMTP conversation. In particular, we de-
ﬁne regular expressions for email addresses, fully qual-
iﬁed domain names, domain names, IP addresses, num-
bers, and hostnames (see Figure 3 for details). Every to-
ken that does not match any of these regular expressions
is treated as a keyword.
An example of a message template is
MAIL From: ,
where email-addr is a regular expression that
matches email addresses.
Given two dialects D and D’, we consider them differ-
ent if their state machines are different. For example, the
two dialects in Figure 2 differ in the sequence of com-
mands that the two clients send: Bagle sends a RSET
[0−9]{3}[0−9]+
Figure 3: Regular expressions used in message tem-
plates.
command after the HELO, while Outlook Express sends
a MAIL command directly. Also, the format of the com-
mands of the two dialects differs: Outlook Express puts
a space between MAIL FROM: and the sender email ad-
dress, while Bagle does not.
In Section 4, we show how we can learn the dialect
spoken by an SMTP client. In Section 5, we show how
these learned dialects can be matched against an SMTP
conversation, which is crucial for performing spam miti-
gation, as we will show in Section 7.
4 Learning Dialects
To distinguish between different SMTP speakers, we re-
quire a mechanism that learns which dialect is spoken by
a particular client. To do this, we need a set of SMTP
conversations C generated by the client. Each conver-
sation is a sequence of  pairs, where
command can be empty if the client did not send any-
thing after receiving a reply from the server.
It is important to note that the state machine learned
for the dialect is affected by the type of conversations in
C. For example, if C only contains successful SMTP
conversations, the portion of the dialect state machine
that we can learn from it is very small.
In the typ-
ical SMTP conversation listed in Figure 1, the client
ﬁrst connects to the SMTP server, then announces itself
(i.e., sends a HELO command), states who the sender of
the email is (i.e., sends a MAIL command), lists recipi-
ents (by using one or more RCPT commands), and starts
sending the actual email content (by sending a DATA
command). Observing this type of communication gives
no information on what a client would do upon receiv-
ing a particular error, or a speciﬁc SMTP reply from the
server. To mitigate this problem, we collect a diverse
set of SMTP conversations. We do this by directing the
client to an SMTP server under our control, and sending
speciﬁc SMTP replies to it (see Section 4.2).
Even though sending speciﬁc replies allows us to ex-
plore more states than the ones we could explore other-
wise, we still cannot be sure that the dialects we learn are
complete. In Section 7, we show how the inferred state
machines are usually good enough for discriminating be-
tween different SMTP dialects. However, in some cases,
we might not be able to distinguish two different dialects
because the learned state machines are identical.
4.1 Learning Algorithm
Analyzing the set C allows us to learn part of the dialect
spoken by the client. Our learning algorithm processes
one SMTP conversation from C at a time, and iteratively
builds the dialect state machine.
4.1.1 Learning the Message Templates
For each message observed in a conversation Con in
C, our algorithm generates a regular expression that
matches it. The regular expression generation algorithm
works in three steps:
Step 1: First, we split the message into tokens. As men-
tioned in Section 3.1, we consider the space, colon, and
equality characters as delimiters.
Step 2: For each token, we check if it matches a known
regular expression. More precisely, we check it against
all the regular expressions deﬁned in Figure 3, from the
most speciﬁc to the least speciﬁc, until one matches (this
means that we check the regular expressions in the fol-
lowing order: email address, IP address, fully qualiﬁed
domain name, domain name, number, hostname).
If a token matches a regular expression, we substitute
the token with the matched regular expression’s identiﬁer
(e.g., ). If none of the regular expres-
sions are matched, we consider the token a keyword, and
we include it verbatim in the template.
Step 3: We build the message template, by concatenating
the template tokens (which can be keywords or regular
expressions) and the delimiters, in the order in which we
encountered them in the original message.
Consider, for example, the command:
MAIL FROM:
First, we break the command into tokens:
[MAIL, FROM, ]
The only token that matches one of the known regular
expressions is the email address. Therefore, we consider
the other tokens as keywords. The ﬁnal template for this
command will therefore be:
MAIL FROM:
Notice that, by deﬁning message format templates as we
described, we can be more precise than the SMTP stan-
dard speciﬁcation and detect the (often subtle) differ-
ences between two dialects even though both might com-
ply with the SMTP RFC. For example, we would build
two different message format templates (and, therefore,
have two dialects) for two clients that use different case
for the EHLO keyword (e.g., one uses EHLO as a key-
word, while the other uses Ehlo).
4.1.2 Learning the State Machine
We incrementally build the dialect state machine by start-
ing from an empty initial state s0 and adding new transi-
tions and states as we observe more SMTP conversations
from C. For each conversation Con in C, the algorithm
executes the following steps:
Step 1: We set the current state s to s0.
Step 2: We examine all
tuples  in Con.
An example of a tuple is .
Step 3: We apply the algorithm described in 4.1.1 to ri
and ci, and build the corresponding templates tr and tc.
In the example, tr is 220 hostname and tc is HELO
domain. Note that ci could be empty, because the client
might not have sent any command after a reply from the
server. In this case tc will be an empty string.
Step 4: If the state machine has a state sj labeled with tc,
we check if there is a transition t labeled with tr going
from s to sj. (i) If there is one, we set the current state s
to sj, and go to Step 6. (ii) If there is no such transition,
we connect s and sj with a transition labeled with tr, set
the current state s to sj, and go to Step 6. (iii) If none of
the previous conditions hold, we go to Step 5.
Step 5: If there is no state labeled with tc, we create a
new state sn, label it with tc , and connect s and sn with
a transition labeled tr. We then set the current state s to
sn. Following the previous example, if we have no state
labeled with HELO domain, we create a new state with
that label, and connect it to the current state s (in this
case the initial state) with a transition labeled with 220
hostname. If there are no tuples left in Con, and tc is
empty, we set the current state as a failure state for the
current dialect, and add it to Fb. We then move to the
next conversation in C, and go back to Step 2 2. Other-
wise, we go to Step 6.
Step 6: If s is labeled with DATA, we mark the state as
a good ﬁnal state for this dialect, and add it to Fg. Else,
if s is labeled with QUIT, we mark s as a bad ﬁnal state
and add it to Fb. We then move to the next conversation
in C, and we go back to Step 2.
2By doing this, we handle cases in which the client abruptly termi-
nates the connection
4.2 Collecting SMTP Conversations
To be able to model as much of a dialect as possible, we
need a comprehensive set of SMTP conversations gener-
ated by a client.
As previously discussed, the straightforward approach
to collect SMTP conversations is to passively observe the
messages exchanged between a client and a server. In
practice, this is often enough to uniquely determine the
dialect spoken by a client (see Section 7 for experimen-
tal results). However, there are cases in which passive
observation is not enough to uniquely identify a dialect.
In such cases, it would be beneﬁcial to be able to send
speciﬁcally-crafted replies to a client (e.g., malformed
replies), and observe its responses.
To perform this exploration, we set up a testing envi-
ronment in which we direct clients to a mail server we
control, and we instrument the server to be able to craft
speciﬁc responses to the commands the client sends.
The SMTP RFCs deﬁne how a client should respond
to unexpected SMTP replies, such as errors and mal-
formed messages. However, both legitimate clients and
spam engines either exhibit small differences in the im-
plementation of these guidelines, or they do not imple-
ment them correctly. The reason for this is that imple-
menting a subset of the SMTP guidelines is enough to
be able to perform a correct conversation with a server
and successfully send an email, in most cases. There-
fore, there is no need for a client to implement the full
SMTP protocol. Of course, for legitimate clients, we ex-
pect the SMTP implementation to be mature, robust, and
complete — that is, corner cases are handled correctly.
In contrast, spambots have a very focused purpose when
using SMTP: send emails as fast as possible. For spam-
mers, taking into account every possible corner case of
the SMTP protocol is unnecessary; even more problem-
atic, it could impact the performance of the spam engine
(see Section 7.4 for more details).
In summary, we want to achieve two goals when ac-
tively learning an SMTP dialect. First, we want to learn
how a client reacts to replies that belong to the language
deﬁned in the SMTP RFCs, but are not exposed during
passive observation. Second, we want to learn how a
client reacts to messages that are invalid according to the
SMTP RFCs.
We aim to systematically explore the message struc-
ture as well as the state machine of the dialect spoken by
a client. To this end, the variations to the SMTP protocol
we use for active probing are of two types: (i) variations
to the protocol state machine, which modify the sequence
or the number of the replies that are sent by the server;
and (ii) variations to the replies, which modify the struc-
ture of the reply messages that are sent by the server.
In the following, we discuss how we generate varia-
tions of both the protocol state machine and the replies.
Protocol state machine variations. We use four types
of protocol variation techniques:
Standard SMTP replies: These variations aim at expos-
ing responses to replies that comply with the RFCs, but
are not observable during a standard, successful SMTP
conversation, like the one in Figure 1. An example is
sending SMTP errors to the commands a client sends.
Some dialects continue the conversation with the server
even after receiving a critical error.
Additional SMTP replies: These variations add replies to
the SMTP conversation. More precisely, this technique
replies with more than one message to the commands the
client sends. Some dialects ignore the additional replies,
while others will only consider one of the replies.
Out-of-order SMTP replies: These variations are used to
analyze how a client reacts when it receives a reply that
should not be sent at that point in the protocol (i.e., a state
transition that is not deﬁned by the standard SMTP state