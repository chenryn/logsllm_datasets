](https://images.seebug.org/content/images/2019/09/23900530-fba5-4302-b509-7877abb13ea6.png-w331s)
![
](https://images.seebug.org/content/images/2019/09/6b6be4bd-c053-404f-872e-10328d4149f1.png-w331s)
传入我们发送的数据后，通过函数数组调用`rdpdr!DrSession::RecognizePacket`进行读取
![
](https://images.seebug.org/content/images/2019/09/6f5e5ff7-614f-4eb4-90c2-c70b4db7af61.png-w331s)
判断头部标志是否为（RDPDR_CTYP_CORE）0x7244
![
](https://images.seebug.org/content/images/2019/09/181261d4-46e3-4297-acbd-c94914406e8c.png-w331s)
接着将会读取函数vftable第二个地址，进行转发
![
](https://images.seebug.org/content/images/2019/09/c7603d2b-45f7-4f2f-aeb4-fbef6dd7e897.png-w331s)
如下图可以看到rdpdr的数据包处理逻辑
![
](https://images.seebug.org/content/images/2019/09/7e33ca52-2bc8-4e9d-8128-8086442b99b8.png-w331s)
rdpdr经过一系列数据包处理后最终进入了我们关心的地方，将会传入channelstruct通过调用`termdd!
_IcaQueueReadChannelRequest`进行标志位的处理
![
](https://images.seebug.org/content/images/2019/09/a0bf25fe-5fda-456c-9c0f-47511855f53f.png-w331s)
最初rdpdr的channelstruct的标志位如下
![
](https://images.seebug.org/content/images/2019/09/b6235f61-e054-4480-b38e-fcf46568495f.png-w331s)
经过函数`termdd!
_IcaQueueReadChannelRequest`对此标志的处理后变成如下，所以下一个数据依然会进入`termdd!_IcaCopyDataToUserBuffer`，导致我们进行池喷射的失败
![
](https://images.seebug.org/content/images/2019/09/0fa6fa69-256e-4d0d-b1f1-95feec938229.png-w331s)
回到rdpdr头部处理函数`rdpdr!DrSession::RecognizePacket`，我们发现在链表遍历失败后将会进行跳转，最后将会进入读取失败处理函数`rdpdr!DrSession::ChannelIoFailed`，然后直接return了
![
](https://images.seebug.org/content/images/2019/09/83bc202f-7751-4e61-bb03-17f10a07e884.png-w331s)
![
](https://images.seebug.org/content/images/2019/09/8778d2de-c15d-4345-852f-2fba56509e0a.png-w331s)
我们构造一个头部异常的数据包发送，头部标志我们构造的是0x7240，将会导致`rdpdr!DrSession::RecognizePacket`判断失败，之后将会继续遍历链表依次再取出两张函数数组
![
](https://images.seebug.org/content/images/2019/09/66d3c183-76d0-4ac1-b363-7c71a6240008.png-w331s)
最后两个函数数组依次调用`rdpdr!DrExchangeManager::RecognizePacket`和`rdpdr!DrDeviceManager::RecognizePacket`，都会判断错误的头部标志0x7240，最后导致链表遍历完后进行错误跳转，直接绕过了`termdd!
_IcaQueueReadChannelRequest`对标志位的修改，将会打破循环
![
](https://images.seebug.org/content/images/2019/09/b9df7ddf-76d9-442d-8c1f-49f3a98506fa.png-w331s)
![
](https://images.seebug.org/content/images/2019/09/e3f58def-e74e-43bc-9c71-ce123cbb46c0.png-w331s)
最后我们连续构造多个错误的数据包后将会进入`ExAllocatePoolWithTag`，分配到我们需要的非分页内存！
 ![
](https://images.seebug.org/content/images/2019/09/3d61f243-08c0-4057-a5e4-1c40ef462bd5.png-w331s)
### 0x02 win7 EXP 池喷射简要分析
首先被释放的MS_T120池大小包括是0x170,池的标志是TSic
![
](https://images.seebug.org/content/images/2019/09/c1956b9b-ff90-469d-a174-4a724f6f81fc.png-w331s)
分析Win7 exp
可以知道数据占位是用的rdpsnd信道，作者没有采用rdpdr信道，应该也和喷射的稳定性有关，rdpsnd喷射是再建立完了rdpdr初始化后开始的，在free掉MS_T120结构体前，发送了1044个数据包去申请0x170大小的池内存，这样做可以说应该是为了防止之后被free掉的内存被其他程序占用了，提高free后内存被我们占用的生存几率
![
](https://images.seebug.org/content/images/2019/09/8a2e70ca-8ac4-40bf-b549-28b9101ef206.png-w331s)
占位被free的实际数据大小为0x128,利用的中转地址是0xfffffa80ec000948
![
](https://images.seebug.org/content/images/2019/09/b1cdaa40-460f-4ccc-b00c-48b97257b0fd.png-w331s)
之后开始池喷射，将payload喷射到可以call [rax] ==
0xfffffa80ec000948的地方，喷射的payload大小基本是0x400，总共喷射了200mb的数据大小，我们先来看下喷射前带标志TSic总共占用池内存大小是58kib左右
![
](https://images.seebug.org/content/images/2019/09/bdbffa6a-6b0e-49a5-9cfd-444e4728ebff.png-w331s)
![
](https://images.seebug.org/content/images/2019/09/7c52de99-c79d-445d-be20-45fab5e57ede.png-w331s)
喷射完后带TSic标志池内存大小大约就是201mb，池内存喷射基本是成功的，我的win7是sp1，总共内存大小是1GB，再喷射过程中也没有其他干扰的，所以喷射很顺利
![
](https://images.seebug.org/content/images/2019/09/96856048-421f-4c67-9737-0a504d62b0d1.png-w331s)
![
](https://images.seebug.org/content/images/2019/09/d16d25b1-12e6-438f-87f7-0b576bac3875.png-w331s)
图中可以发现基本已经很稳定的0x400大小的池喷射payload，地址越高0x400大小的内存基本就很稳定了
![
](https://images.seebug.org/content/images/2019/09/8cc4c922-8d96-49ac-910b-4a37a865d0b6.png-w331s)
最后断开连接时候，被free的内存已经被我们喷射的0x128大小的数据给占用了
执行call指令后稳定跳转到了我们的payload，成功执行！
![
](https://images.seebug.org/content/images/2019/09/1baf39cf-8334-4bdb-9942-d773a393c780.png-w331s)
参考链接：  
[0]   
[1]   
[2]
* * *