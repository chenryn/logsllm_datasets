As demonstrated, the number of scheduled tasks can go up to 18K
per second during an normal computer usage session. We measured
the time requirements for the policy-to-automata conversion for
the typical linear temporal logic-based system speciﬁcation poli-
cies [1]. Figure 2(c) shows the results for individual temporal se-
curity policies. As shown in the ﬁgure, Sechduler completed the
conversion for individual temporal requirements in approximately
0.58 seconds on average. This suggests that Sechduler can scale
well for real-world settings where many requirements may be in-
volved in the ﬁnal logic-based predicate.
Case Study: Sensitive File Modiﬁcation. We show how Sech-
duler protects a target host system once the system is hit by a sen-
sitive ﬁle modiﬁcation attack. Samhain was deployed as the attack
consequence detection system. Speciﬁcally, we modiﬁed its conﬁg-
uration, i.e., /etc/samhain/samhainrc, to monitor the ﬁles and
directories in which we are interested, and conﬁgured it to report
events with at least crit severity level.
Initially, we created its
initial database, i.e., /var/state/samhain/samhain_file, us-
ing samhain -t init, and its database was updated, using -t
update. During the operational mode of the system, Samhain
was conﬁgured to check the marked sensitive ﬁles and directories
1466(a) Automata for Frequently Used Speciﬁca-
tions
(b) Kernel-level Scheduled Tasks Statistics (c) Automaton Generation Time Require-
ment
(d) Scheduling Statistics of the Trojan Fire-
fox
(e) Statistics on a Sechduler-Enabled Kernel (f) Overall Sechduler Performance Overhead
Figure 2: Sechduler Evaluation Results
against its database and ﬁre an alert upon identifying a modiﬁca-
tion or access (depending on the policy deﬁned in the conﬁguration
ﬁle).
To simulate an attack, we implemented a trojan Firefox that mod-
iﬁed sensitive user ﬁles that had been marked to be monitored by
Samhain. Figure 2(d) shows the malware’s scheduling activity statis-
tics within a non-Sechduler aware kernel. Consequently, Samhain
ﬁred the alert, and Sechduler performed three tasks. It 1) called the
setsec system call and lowers the Firefox’s security level variable
within the kernel; 2) spawned a comprehensive ClamAV virus scan
on the Firefox’s executable; and 3) compiled the triggered alert’s
corresponding policy module and loaded it on the kernel dynami-
cally.
Enforcing the loaded policy, Sechduler manipulated the task se-
lection procedure within the kernel scheduler to ensure that (from
its point of view) the potentially malicious Firefox process did not
get CPU access and waited for the ClamAV’s green light. However,
in our experiments, ClamAV triggered an alert denoting that the ex-
ecutable contains malicious content. Consequently, the suspended
Firefox process was terminated by Sechduler and its executable
was removed. Figure 2(e) a different run of the trojan Firefox on a
Sechduler-enabled Linux kernel. As shown on the graph, Sechduler
denies its requests for execution since the 69-th seconds and ﬁnally
terminates the process. We implemented the process termination as
a single countermeasure action; however, more complicated actions
can be deﬁned by policies and implemented.
It is important that Sechduler performs the runtime system secu-
rity veriﬁcation efﬁciently such that the system’s overall throughout
is not affected signiﬁcantly. We measured the Sechduler’s overall
performace overhead on our testbed system’s overall throughput. In
particular, we employed the ab Apache Webserver benchmarking
toolset to measure the system throughout. To make the webpage
processing more CPU-intensive, we designed a very simple HTML
webpage. For our server system, we deﬁne the overall performance
measure as the number of requests that can be processed per sec-
ond. Figure 2(f) shows how the system’s throughput is affected by
the runtime veriﬁcation of individual task scheduling decisions. We
believe that the overall performance overhead of the Sechduler so-
lution can be further reduced by optimizing our code. For instance,
several data structures that are searched frequently, with O(n) com-
plexity, can be redesigned for logarithmic search, and overal system
performance improvement.
Acknowledgments
The authors would like to thank the Ofﬁce of Naval Research (Grant
N000141210462) for their support.
1. REFERENCES
[1] DWYER, M. B., AVRUNIN, G. S., AND CORBETT, J. C.
Patterns in property speciﬁcations for ﬁnite-state veriﬁcation.
In Proceedings of the 21st international conference on
Software engineering (New York, NY, USA, 1999), ICSE ’99,
ACM, pp. 411–420.
[2] JIANG, K., AND JONSSON, B. Using spin to model check
concurrent algorithms, using a translation from c to promela.
In Proc. 2nd Swedish Workshop on Multi-Core Computing
(2009), Department of Information Technology, Uppsala
University, pp. 67–69.
[3] KING, S. T., AND CHEN, P. M. Backtracking intrusions. In
Proceedings of the Nineteenth ACM symposium on Operating
systems principles (2003), vol. 37, pp. 223–236.
[4] PABLA, C. S. Completely fair scheduler. Linux J. 2009, 184
(Aug. 2009).
[5] ROUTRAY, R., ZHANG, R., EYERS, D., WILLCOCKS, D.,
PIETZUCH, P., AND SARKAR, P. Policy generation
framework for large-scale storage infrastructures. In IEEE
Symposium on Policies for Distributed Systems and Networks
(2010), pp. 65–72.
[6] SATO, H., AND YAKOH, T. A real-time communication
mechanism for rtlinux. In Annual Confjerence of the IEEE
Industrial Electronics Society (2000), vol. 4, pp. 2437 –2442
vol.4.
[7] WOTRING, B., POTTER, B., RANUM, M., AND
WICHMANN, R. Host Integrity Monitoring Using Osiris and
Samhain. Syngress Publishing, 2005.
[8] ZONOUZ, S. A., JOSHI, K. R., AND SANDERS, W. H.
Floguard: cost-aware systemwide intrusion defense via online
forensics and on-demand ids deployment. In International
conference on Computer safety, reliability, and security
(2011), pp. 338–354.
0 5 10 15 20 25 30 35 40 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 Total Number of Automaton States Typical Temporal Security Specification Patterns 0 2000 4000 6000 8000 10000 12000 14000 16000 18000 20000 0 50 100 150 200 250 #Scheduled Kernel Tasks Time (seconds) 0	
  100	
  200	
  300	
  400	
  500	
  600	
  700	
  800	
  1	
  6	
  11	
  16	
  21	
  26	
  31	
  36	
  41	
  46	
  51	
  Automaton	
  Genera,on	
  (msec)	
  Typical	
  Temporal	
  Security	
  Speciﬁca,on	
  Pa9erns	
  0	
  200	
  400	
  600	
  800	
  1000	
  1200	
  1400	
  0	
  10	
  20	
  30	
  40	
  50	
  60	
  70	
  80	
  90	
  #Scheduled	
  Firefox	
  Tasks	
  Time	
  (seconds)	
  0	
  200	
  400	
  600	
  800	
  1000	
  1200	
  1400	
  0	
  10	
  20	
  30	
  40	
  50	
  60	
  70	
  80	
  90	
  #Scheduled	
  Firefox	
  Tasks	
  Time	
  (seconds)	
  0	
  1000	
  2000	
  3000	
  4000	
  5000	
  6000	
  1	
  2	
  3	
  4	
  5	
  6	
  7	
  8	
  9	
  10	
  #Processed	
  Requests/sec	
  #Concurrent	
  Server	
  Threads	
  1467