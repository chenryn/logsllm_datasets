ated by the formal type system have been met.
model  presented  here  supports  the  development  of  a
useful class of systems.
Our formal model is specified in PVS, and proofs of
the putative theorems have been mechanically verified
with the PVS system. We have also formally specified
the  essential  interfaces  of  an  example  reconfigurable
system (see section 7) and shown that this example has
the necessary properties of our architecture. The result
is  an  assurance  argument  based  on  proof.  In  this  sec-
tion, we present the model and its properties.
6.1 Model assumptions
Assuring real-time properties is difficult in general;
although PVS is a powerful specification and proving
system, real-time properties of complex systems can be
nontrivial. In this work, in order to enable the specifi-
cation  and  proof  structure  that  we  seek,  we  make  the
following general assumptions on applicable systems:
• Each  application  operates  with  synchronous,  cyclic
processing and with a fixed real-time frame length.
• All  applications  operate  with  the  same  real-time
frame length.
• The  real-time  frames  for  all  applications  are  syn-
chronized to start together.
• Each application completes one unit of work in each
real-time frame (where that unit of work can be nor-
mal function, halting an application and restoring its
state,  preparing  an  application  to  transition  to
another  specification,  or  initializing  data  such  as
control system gains).
• Each application commits results to stable storage at
the end of each computation cycle (real-time frame).
• Any dependencies between applications require only
that the independent application be halted before the
dependent application computes its precondition.
These  assumptions  impose  restrictions  on  a  system
to  facilitate  analysis.  Despite  these  assumptions,  the
6.2 Application model
During  normal  operation,  each  application  reads
data values produced by other applications from stable
storage  at  the  start  of  each  computational  cycle  and
then  performs  its  computation.  It  commits  its  results
back to stable storage at the end of each computational
cycle.  Should  reconfiguration  become  necessary,  the
AFTAs are not able to execute their recovery protocols
immediately  or  independently  because  they  depend
both on their own state and on other system state. Each
must wait, therefore, for the SCRAM to coordinate all
of the currently executing AFTAs.
The  SCRAM  communicates  with  applications
through variables in stable storage. When reconfigura-
tion is necessary, it sets the configuration_status vari-
able  to  a sequence  of values  on  three  successive  real-
time  frames.  The  three  values  are:  halt, prepare,  and
initialize.  At  the  beginning  of  each  real-time  frame,
each application reads its configuration_status variable
and completes the required action during that frame as
shown in Table 1.
6.3 System model
The  SCRAM  effects  a  system  reconfiguration  by
reconfiguring  all  of  the  applications  in  the  system
using the sequence of actions shown in Table 1. In the
table, application i has failed, and the new system con-
figuration will be Ct. The various sequences are coordi-
nated  by  the  SCRAM  to  ensure  that  dependencies
among AFTAs are respected.
This  approach  differs  slightly  from  the  approach
taken by Schlichting and Schneider. In their approach,
system  processing  is  achieved  by  the  execution  of  a
sequence of FTAs where the recovery for a given FTA
Frame Message
Action
Predicate
Table 1: SFTA Phases
0 (start)
Application i:
failure signal(cid:111) SCRAM
SCRAM:
halt (cid:111) all apps
None
None 
1
2
3
(end)
None
Applications cease execution
Application postconditions
SCRAM:
prepare(Ct) (cid:111) all apps
Applications prepare to transi-
Application transition condi-
tion to Ct
tions for Ct
SCRAM:
initialize (cid:111) all apps
Applications initialize, estab-
lish operating state for Ct
Application preconditions for Ct
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:09:48 UTC from IEEE Xplore.  Restrictions apply. 
is  executed  after  the  associated  action  if  it  is  inter-
rupted.  In  our  approach,  the  recovery  for  a  system
fault-tolerant action that is interrupted consists of three
parts:  (Frame  1)  each  executing  AFTA  establishes  a
required  postcondition  and  reaches  a  halted  state;
(Frame 2) each executing AFTA establishes the condi-
tion to transition to operation under the new state; and
(Frame 3) each executing AFTA establishes its precon-
dition: all state associated with the AFTA has been ini-
tialized, and the application is functioning normally.
The  functional  aspects  of  the  SCRAM  will  remain
constant, unless changes are needed because of specific
dependencies.  This  simplifies  subsequent  verification,
since  the  SCRAM  need  only  be  verified  once.  The
SCRAM must, however, be provided with application-
specific data that is created and verified separately:
• An interface to one or more applications that moni-
tor environmental characteristics.   These  applica-
tions calculate the effective state of the environment.
defines
potential  system  configurations  and  maps  system
configurations into application specifications.
• A table of potential configurations.   This 
• A function to choose a new configuration.   The
function  maps  current  configuration  and  environ-
ment  state  to  a  new  configuration.  This  function
implicitly includes information on valid transitions.
• An interface to each application.   This  contains  the
configuration variable for the application.
Our  formal  system  model  includes  an  overarching
function  in  the  PVS  specification  to  coordinate  and
control application execution. This is a mechanism that
is present as part of the PVS structure; in practice, tim-
ing  analysis  and  synchronization  primitives  would  be
used to achieve frame coordination. Variables in stable
storage  shared  between  the  SCRAM  and  the  relevant
application ensure synchronization during reconfigura-
tion stages; the synchronization, in turn, ensures pres-
ervation of data dependencies.
The  SCRAM’s  synchronization  mechanism  can  be
extended  to  support  richer  application  interdependen-
cies, as long as the dependencies are acyclic and time
permits.  Given  a  specification  of  dependencies,  it
could  preserve  them  by  checking  each  cycle  to  see  if
the  independent  application  has  completed  its  current
configuration phase. Only after that phase is complete
would the SCRAM signal the dependent application to
begin  its  next  stage.  Dependencies  could  also  be
relaxed  by  removing  any  unnecessary  intermediate
stages or allowing the applications to complete multi-
ple sequential stages without signals from the SCRAM.
Since  we  make  no  distinction  between  failures  and
other  environmental  changes,  the  status  of  a  compo-
nent is modeled as an element of the environment, and
a  failure  is  simply  a  change  in  the  environment.  Any
environmental factor whose change could necessitate a
reconfiguration can have a virtual application to moni-
tor its status and generate a signal if the value changes.
6.4 Formal definition of reconfiguration
Using  the  above  model,  we  now  outline  the  high-
level  properties  we  require  of  any  reconfiguration.
Defining these properties in an abstract sense allows us
to  argue  that  the  general  requirements  needed  for
assured reconfiguration have been met. The model was
constructed to enable proof of these properties.
In previous work, we informally defined reconfigu-
ration of a single application as:
the process through which a system halts opera-
tion under its current source specification Si and
begins operation under a different target specifi-
cation Sj [10].
For  the  multiple  application  case,  we  define  recon-
figuration informally as:
through  which  a 
the  operation 
function
f: Apps (cid:111) S  of  interacting  applications  A  that
operate  according  to  certain  specifications  in  S
transitions to a function f': Apps (cid:111) S of interact-
ing applications Apps that operate according to
different specifications in S.
An SFTA is thus comprised of correct execution of
all applications ai under their respective specifications
f(ai).  System  reconfiguration  is  only  necessary  if  ai
cannot mask the failure, but must transition to an alter-
native  specification  in  order  to  complete  its  AFTA.  If
only ai must reconfigure, then(cid:3)(cid:5)aj (cid:122) ai, f'(aj) = f(aj).
For our system model, including application specifi-
cation  and  system  configuration  types,  we  created
properties that we use to define “correct” reconfigura-
tion, shown in Table 2. To represent them, we include:
reconfiguration: TYPE =
[# start_c: cycle, end_c: cycle #]
— execution  cycle  in  which  the  reconfiguration
starts and ends
sys_trace : TYPE =
— possible state traces
[# ...
sp: reconf_spec,
— sp‘apps is the set of system applications
tr: [cycle -> s: sys_state],
— function from system cycle to system state
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:09:48 UTC from IEEE Xplore.  Restrictions apply. 
Table 2: Formal Properties of System Reconfiguration
Informal Description
SP1: R  begins  at  the  same
time any application in the
system  is  no  longer  oper-
ating  under  Ci and  ends
when  all  applications  are
operating under Cj
Formal Property
FORALL (s: sys_trace, r: (get_reconfigs(s))) :
(EXISTS (app: (s`sp`apps)) : 
s`tr(r`start_c)`reconf_st(app) = interrupted) AND
(FORALL (app: (s`sp`apps)) :
s`tr(r`start_c-1)`reconf_st(app) = normal) AND
(FORALL (app: (s`sp`apps)) :
s`tr(r`end_c)`reconf_st(app) = normal) AND
(FORALL (c: cycle, app: (s`sp`apps)) :
r`start_c  
s`tr(c)`reconf_st(app) /= normal)
SP2: Cj  is  the  proper  choice
for the target system spec-
ification  at  some  point
during R
FORALL (s: sys_trace, r: (get_reconfigs(s))) : 
EXISTS (c: real_time) :
r`start_c <= c AND c <= r`end_c AND
s`tr(r`end_c)`svclvl =
s`sp`choose(s`tr(r`start_c)`svclvl, 
s`env(c*cycle_time))
SP3: R  takes  less  than  or
FORALL (s: sys_trace, r: (get_reconfigs(s))) :
equal to Tij time units
(r`end_c - r`start_c + 1)*cycle_time <=
s`sp`T(s`tr(r`start_c)`svclvl, s`tr(r`end_c)`svclvl)
SP4: The  precondition  for  Cj
is true at the time R ends
FORALL (s: sys_trace, r: (get_reconfigs(s))) :
pre?(s, r`end_c)
env: valid_env_trace(sp`E, sp`R) #]
— given environmental states
get_reconfigs(s: sys_trace) : 
set[reconfiguration]