intermediate data generated when GPU kernels of a victim
program are executing. GPU computing models discourage
long-running GPU kernels because current GPUs do not
support preemptive scheduling. Long-running GPU pro-
grams thereby use either several kernels or the same kernel
repeatedly and process the intermediate results. The main
targets of this attack are frequently accessed data stored in
the per-CU local memory and the per-PE private memory.
For example, libgpucrypto, a cryptography library of
SSLShader [12], loads secret keys, AES S-box, and the p
and q values of RSA into the local and private memories
in order to increase performance. If a victim program does
not clear the local and private memories at the end of each
kernel execution, an attacker can easily read the data.
2) Attack Procedure: Algorithm 3 shows the EoK attack.
In this algorithm, we execute kernels that attempt to read
the local and private memories of a GPU, and copy the
results to CPU memory. We also check the differences
in available memory size to determine whether a victim
program dynamically releases some of its global memory.
When we detect such memory release, we also attempt to
dump it. The loop for reading the local and private memories
terminates when the victim program exits from the GPU, and
we lastly perform the EoC attack.
3) L1 Data Cache of NVIDIA GPUs: The EoK attack
can also acquire sensitive data kept in the L1 data cache
of NVIDIA GPUs. NVIDIA GPUs utilize a portion of their
per-CU local memory as an L1 data cache of the global
Figure 6. A sample kernel to ﬂush L1 data cache.
memory. Programmers can ﬂexibly conﬁgure the size of
the local memory and the L1 data cache: 16 KB for the
local memory and 48 KB for the L1 data cache or vice
versa. However, this conﬁguration allows attackers to read
the 32 KB overlapped region used by the L1 data cache of
a victim program.
Figure 5 shows the layouts of the local memory and
the L1 data cache, veriﬁed by conducting the following
experiment. We ﬁrst execute a victim program that writes
zeros into its 16 KB of local memory and reads 512 MB of
global memory ﬁlled with 0x11111111. We then execute
an attack program that reads and dumps its 48 KB of
local memory. We detect that the lower 16 KB of the local
memory is ﬁlled with zeros and the upper 32 KB of the local
memory is ﬁlled with 0x11111111. Therefore, attackers
can obtain the lower 2/3 of the L1 data cache from a victim
GPU program if the victim uses a 48 KB L1 data cache.
A GPU program can clear cached data by reading the
contiguous 48 KB global memory block ﬁlled with a dummy
value because the L1 data cache of NVIDIA GPUs is a set-
associative, write-evict cache [2], [30]. Figure 6 shows an
example of a CUDA code that ﬂushes the L1 data cache.
It prepares a 48 KB array ﬁlled with zeros in the global
memory in advance and reads zeros from the array to clear
the L1 data cache.
4) Multiple Victims: The limitation of the EoK attack is
that it can only read the local and private memories of a
victim kernel which uses the GPU just before an attack
kernel. This implies that when multiple victim programs
compete to use a GPU, the attack kernel can only see one
24
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:59:35 UTC from IEEE Xplore.  Restrictions apply. 
OverlappedL1 CacheLocalMemoryLocalMemoryL1 Cache16384049152ORLowerHigher65536// prepare global memory filled with zerosint*zero_mem;cudaMalloc((void**)&zero_mem, 49152);cudaMemset(zero_mem, 0, 49152);…__device__ void flushL1(int*zero_mem) {for (inti=0; i< 49152/sizeof(int); ++i) {zero_mem[i] = zero_mem[49152/sizeof(int)-(i+1)];}} PLATFORMS WE TEST THE PROPOSED ATTACKS.
Table I
GPU (Generation)
NVIDIA
GeForce 210 (GT200)
Tesla C2050 (Fermi)
GeForce GTX 780 (Kepler)
AMD
Radeon HD 7850 (Pitcairn)
FirePro W9000 (Tahiti)
GPU Mem. Driver
OS
Kernel CPU
CPU Mem.
0.5 GB
2.6 GB
3.0 GB
1.8 GB
6.0 GB
319.37
304.108
325.15
Ubuntu 12.04
CentOS 6.3
Ubuntu 12.04
13.1
CentOS 6.4
12.104.2 CentOS 6.4
3.5.0
2.6.32
3.5.0
2.6.32
2.6.32
Intel Pentium Dual-Core E6300
Intel Xeon X5650*2
Intel Core i7-2600
Intel Xeon E5430*2
Intel Xeon E5430*2
4 GB
24 GB
8 GB
8 GB
8 GB
of their data kept in local and private memories.
E. Attacks on AMD GPU
1) Differences and Increased Vulnerability: The attacks
on AMD GPUs slightly differ from the attacks on NVIDIA
GPUs due to dynamic memory management of AMD GPUs
and OpenCL2. Unlike NVIDIA GPUs, AMD GPUs and
OpenCL provide no APIs to check available memory size as
they dynamically manage the global memory. When a new
GPU program requests large memory blocks exceeding the
available global memory size, while an old GPU program
occupying a portion of global memory is inactive, AMD
GPUs automatically move the old GPU program’s data back
to CPU memory to fulﬁll the new program’s requirements.
NVIDIA GPUs do not provide this functionality, although
they support OpenCL.
However, we detect that the AMD GPU driver does not
nullify GPU memory for the new program. An attacker can
read the global memory of a victim program when he or
she requests memory before the victim program deletes and
deallocates its GPU memory.
Instead of checking the available GPU memory sizes, we
use the changes in kernel execution timing for determining
whether a victim program uses GPUs. GPU kernels of
different programs share a GPU in a time-sharing fashion,
so that the execution time of a GPU kernel varies according
to other kernels using the GPU.
2) Attack Procedure: Algorithm 4 shows the EoK attack
on AMD GPUs. We execute a dummy kernel and measure
its execution time to know whether a victim program uses
the GPU. If a victim program exists, the execution time of
the dummy kernel certainly increases because current GPUs
cannot concurrently execute different GPU programs [18].
When an attacker detects a victim, the attacker executes
kernels for reading the local and private memories. Fur-
thermore, the attacker can also acquire the entire global
memory because of the dynamic memory management of
AMD GPUs. Consequently, the EoC attack is unnecessary
when attacking AMD GPUs.
2http://devgurus.amd.com/message/1296453
sleep()
time ← kernelDummy()
Algorithm 4 End-of-Kernel Attack on AMD GPUs
Input: own ← the size of memory occupied by attacker
1: context ← createGP U Context()
2: time ← kernelDummy()
3: while time < threshold do
4:
5:
6: end while
7: while time ≥ threshold do
8:
9:
10:
11:
12:
13:
14: end while
local priv ← kernelReadLocalP rivM em()
memoryCopyDeviceT oHost(local priv)
alloc ← allocateM emory(total − own)
memoryCopyDeviceT oHost(alloc)
sleep()
time ← kernelReadData()
// no victim exists
// victim works
F. Test Platforms
We test ﬁve different platforms to check the coverage of
the proposed attacks (Table I). The test platforms include
NVIDIA GeForce 210, NVIDIA Tesla C2050, NVIDIA
GeForce GTX 780, AMD Radeon HD 7850, and AMD
FirePro W9000 GPUs on Linux operating systems with
various driver versions. We verify that our attacks succeed
in the test platforms without errors.
G. Attacks on “Real” Programs
So far, we explain our attacks to disclose GPU memory
used by an experimental GPU program we made that only
handles meaningless data. To show that our attacks are not
only highly applicable, but also crucial threats to both GPUs
and their users, we have to attack a real program that (1) uses
GPU APIs, (2) deals with sensitive data, and (3) is popular.
Recent web browsers, such as Chromium and Firefox, fulﬁll
all the requirements: (1) they use graphics APIs for efﬁcient
webpage rendering, (2) they handle a user’s private data
such as browsing history, and (3) they are extremely popular.
Therefore, we choose them as our attack targets and discuss
the results in the next section.
V. INFERRING WEB BROWSING HISTORY FROM GPUS
In this section, we explain our attacks on web browsers
to infer web browsing history of a victim user using data
extracted from GPUs by leveraging the attacks explained in
Section IV. Recent web browsers, such as Chromium and
25
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:59:35 UTC from IEEE Xplore.  Restrictions apply. 
We identify that webpage textures remain not
Firefox, support GPU-accelerated webpage rendering so we
expect that rendered webpage textures may remain in GPU
memory. Our inference attacks match the GPU memory
dump with either known webpage dumps or known webpage
snapshots to infer which webpages a victim user has visited.
in the
local and private memories, but in the global memory. The
content of the local and private memories does not change
according to which webpages a victim has visited, but
changes according to which web browsers a victim uses.
Hence, we focus on attacking the global memory to infer
web browsing history.
A. Web Browsers and Conﬁgurations
We use the Chromium web browser version 30 and
Firefox web browser version 25 in this case study. For
the Chromium web browser, we enable the “GPU com-
positing of all page” option to use GPU-accelerated
webpage composition. For
the Firefox web browser,
we enable the layers.offmainthreadcomposition.enabled and
layers.acceleration.force-enabled options, and disable the
layers.use-deprecated-textures option. We execute the web
browsers on three Linux systems with NVIDIA GeForce
210, NVIDA GeForce GTX 780, and AMD FirePro W9000
GPUs (Table I). The Linux systems with the NVIDIA GPUs
use Xfce 4.8, and another Linux system with the AMD GPU
uses Gnome 2.28.2.
B. GPU Memory Dump and Texture Rearrangement
dump
examine
When we
a GPU memory
of
google.com extracted from the Chromium web browser
with an NVIDIA GeForce GTX 780 GPU obtained by
performing the EoC attack, we ﬁnd a number of 32-bit
values that seem to represent colors, such as 0x00ffffff,
0x00404040, 0x00e85947, and 0x00da3d29. Starting
from the most signiﬁcant bit, we treat each two bytes as
blank, red, green, and blue color values, respectively. We
construct Figure 1b by judging each value with the rule
while ignoring black (zeros).
GPU memory dumps of known webpages extracted from the
same GPU a victim uses and tries to compare them with a
GPU memory dump of an unknown webpage. We conﬁrm
that this attack can correctly infer up to 95.4% of randomly
selected 100 front pages of Alexa Top 1000 websites.
Second, we assume an attacker who prepares image
snapshots of known webpages and tries to compare them
with a GPU memory dump of an unknown webpage. Unlike
the ﬁrst attack, this attack does not require that the attacker
and victims use the same GPU. This attack correctly infers
∼50% of the randomly selected 100 front pages.
Third, we assume an attacker trying to attack a victim
who simultaneously opens multiple webpages using either
multiple tabs or windows. We observe that the attacker can
accurately infer the webpages of the front tab or the lastly
rendered window.
D. Attack using Known GPU Memory Dump
In this attack, an attacker prepares GPU memory dumps
of famous webpages to compare them with a new GPU
memory dump of a victim web browser. We choose front
pages of Alexa Top 1000 websites as our dataset. We visit
each of them using the Chromium and Firefox web browsers
with NVIDIA and AMD GPUs, respectively, and close the
browsers 60 second later while recording GPU memory
dumps using the EoC attack. We repeat these procedures
10 times to average out the results.
We use three matching methods for comparing GPU
memory dumps: pixel sequence matching, RGB histogram
matching, and a combination of them.
1) Pixel Sequence Matching: The pixel sequence match-
ing compares non-black and non-white contiguous pixel
sequence sets extracted from two GPU memory dumps using
Jaccard Index (JI). We ignore (1) black pixels because we
cannot distinguish them with zero in memory and (2) white
pixels because most webpages have a large number of white
pixels.
For example, if a GPU memory dump contains the fol-
lowing pixels
As Figure 1 shows, GPUs store textures on GPU memory