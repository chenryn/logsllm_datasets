---
## Page 77
中的Python语法。如果有人把你的代码在老版本的PCRE下进行了重新编译，而代码
中的正则表达式突然就不工作了，那么他们肯定会很不高兴。当你把一个正则表达式
从.NET复制到Ruby中时，删掉一些P，应该不是太困难。
PCRE7和Perl5.10的文档中几乎没有提到Python语法，但是它背定不是要被淘汰的。
正相反，我们实际上推荐在PCRE和PHP使用Python语法。
命名反向引用
有了命名捕获之后，紧接着就有了命名反向引用。正如命名捕获分组与编号捕获分组
的功能完全相同一样，命名反向引用与编号反向引用的功能也是完全相同的。它们只
是更加易于阅读和维护。Python使用语法和k'name'。这两个变体在功能上是完全相同的，因此
也可以随意混着使用。使用尖括号语法创建的命名分组可以采用引号语法来进行引用，
反之亦然。
我们强烈推荐你不要在同一个正则表达式中混合使用命名和编号分组。不同流派对于
出现在命名分组之间的非命名分组的编号方法会遵循不同的规则。Perl5.10和Ruby1.9
沿用了.NET的语法，但是它们并没有遵循.NET对于命名捕获分组，或者是混合使用编
号捕获分组与命名分组进行编号的方式。与其在这里解释其中的差别，我们选择推荐
大家不要把命名和编号分组混合使用。应当避并可能的混淆，给所有未命名的分组一
个名称，或者把它们变成非捕获的。
参见
实例2.9、2.10、2.21和3.9
2.12把正则表达式的一部分重复多次
问题描述
创建正则表达式来匹配下列种类的数字。
·一个g0ogol（一个100位的十进制整数)。
·一个32位的十六进制整数。
·一个32位的十六进制整数，带有一个可选的h后缀。
·一个浮点数，包含可选的整数部分、必需的小数部分和可选的指数部分。每个部
分都允许任意多个数字。
正则表达式的基本技巧
61
www.TopSage.com
---
## Page 78
解决方案
Googol
\b\d{100}\b
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python.Ruby
十六进制整数
\b[a-f0-9]{1,8}\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
带可选后缀的十六进制整数
\b[a-f0-9](1,8}h?\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
浮点数
\b\d*\.Id+(e\d+)？
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
固定次数重复
量词（quantifier）（{n))，其中n是一个正整数，用来重复之前的正则记号n次。在中的会匹配一个包含100个数字的字符串。你也可以通过把重复之前的记号一次，这样和没有任何量词是等价的。（ab{1}c）与（abc>是同样的
正则表达式。
（{0}>重复之前的记号0次，实际上也就是把它从正则表达式中删除。（ab{0}c与（ac）
是同样的正则表达式。
可变次数重复
对于可变次数重复，我们使用量词，其中n是一个正整数，并且m大于n。
\b[a-f0-9]{1,8}\b>匹配-一个包含1～9个数字的十六进制整数。对于可变次数重复的情
形，其中所有选择分支重复的顺序就会产生影响。这会在实例2.13中详细加以讲解。
如果n和m是相等的，那么我们就会得到固定次数的重复。（\b\d{100,100)\b>与
\b\d{100\b>是同样的正则表达式。
62第2章
www.TopSage.com
---
## Page 79
无限次数重复
量词（n,>，其中n是一个正整数，支持无限次数重复。实际上，无限次数重复是个
没有上限的可变次数重复。
\d{1，>匹配一个或多个数字，\d+>也一样。在一个不是量词的正则记号之后添加一个
加号，意味着“一次或多次”。实例2.13会讲解在量词之后跟加号的含义。
（\d{0，}>匹配0个或多个数字，（d*也一样。星号永远都意味着“0次或多次”。除了支
持无限次数重复之外，（{0，和星号还把之前的记号变成了可选的。
把一些内容变成可选
如果我们使用可变次数重复，并把n设置为0，那么我们事实上就是把在该量词之前的
记号变成了可选的。匹配一次或者根本不存在。如果不存在h的话，那么
会得到-一个长度为0的匹配。如果你使用h{0,1}自已来作为一个正则表达式，那么它
会在目标文本中每个不是h的字符之前找到一个长度为0的匹配。每个h则会得到包
含一个字符（也就是h）的匹配。
与ch(0,1)）的效果是一样的。在一个合法和完整的非量词正则记号之后的问号意味
着“0或1次”。下一个实例会解释在量词之后的问号的含义。
提示
在一个起始括号之后使用问号或者任意其他量词，都是一个语法错误。
讲解了非捕获分组和命名捕获分组，它们都使用了在起始括号之后的问
号来作为其语法的一部分。这些问号根本不是量词；它们只是属于非捕
获分组和命名捕获分组的语法中的一部分。随后的实例中会讲解使用《?>
语法的更多分组风格。
重复分组
如果在分组的结束括号之后放一个量词的话，那么整个分组就会被重复。（(?:abc){3}>
与abcabcabc>是相同的。
量词还可以进行嵌套。（e\d+)?>匹配一个e之后跟着一个或多个数字，或者是一个长度
为0的匹配。在我们的浮点数的正则表达式中，这是可选的指数部分。
捕获分组也可以重复。在实例2.9中解释过，分组的匹配在每次引擎退出该分组的时候
被捕获，并会覆盖该分组在之前匹配的任何文本。会匹配一个包含2个、4
个和6个数字的字符串。引擎会退出该分组3次。当这个正则表达式匹配到123456的
时候，捕获分组中保存的是56，因为该分组的最后一次循环存储的是56。另外两次分
组匹配，也就是12和34，是无法被获取的。
正则表达式的基本技巧
www.TopSage.com
---
## Page 80
会与捕获相同的文本。如果想要用捕获分组来捕获所有两个、
四个或六个字符，而不只是最后两个，那么就必须把捕获分组和量词一起使用，而不
只是重复该捕获分组：((?：\d\d){1,3}））。这里我们用了一个非捕获分组取代了捕获分组
的分组功能。我们也可以使用两个捕获分组：((dd){1,3)。当这最后一个正则表达
式匹配123456的时候，1>中保存的是123456，而在2>中则保存了56。
只有.NET的正则表达式引擎才支持获取一个重复捕获分组的所有循环。如果直接查找
该分组的Value属性，它会返回一个字符事，而你会得到56，就像所有其他正则表达
式引擎一样。在正则表达式中的反向引用和替代文本也会替代56，但是如果使用分组
的CaptureCollection，那么你就会得到一个栈，其中包含56、34和12。
参见
实例2.9、2.13、2.14。
2.13选择最小和最大重复次数
问题描述
匹配一对XHTML标记和，以及二者之间的所有文本。在标记之间的文本也可
以包含其他XHTML标记。
解决方案
.*？
正则选项：点号匹配换行符
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
在实例2.12中讨论的所有量词都是贪心的（greedy），意味着它们会试图重复尽量多次，
只有当剩余的正则表达式不能匹配的时候才会返回结果。
这对于把XHTML（它是XML的一个版本，因此要求每个起始标记都存在匹配的结束
标记）中的标记进行配对来说，可能会出现困难。考虑如下一个简单的XHTML片段：
The very first task is to find the beginning of a paragraph.
Then you have to find the end of the paragraph
在该断码片段中，存在两个起始标记和两个结束标记。你想要把第一个与
第一个进行匹配，因为它们标记了一个段落。注意这个段落还包括了一个标
64第2章
www.TopSage.com
---
## Page 81
记，因此该正则表达式不能是遇到.*
正则选项：点号匹配换行符
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
这个错误解客中唯一的区别是它缺少了在星号之后的额外问号。这个不正确的答案中
使用了在实例2.12中讲解的同样的贪心星号。
在匹配了自标文本中的第一个之后，引擎会到达.*。其中的点号可以匹配任意字
符，其中也包括换行符。星号则把它重复0次或更多次。这里的星号是贪心的，因此.*
会匹配直到目标文本结束的所有内容。需要再重申一遍：（.*会吃掉你的整个XHTML
文件，从第一段开始。
当.*把肚子吃饱之后，引擎才会试图去匹配在目标文本末尾的可以
被整个匹配为止。
那么问题在哪里呢？因为星号是贪心的，所以上面给出的不正确的正则表达式会匹配
在XHTML文件中的第-一个到最后一个/p>之间的所有内容。但是要想正确地匹配一
个XHTML段落，我们需要的是匹配第一个p>与跟在其后的第一个/p>。
这个时候，我们就需要使用懒情（lazy）量词了。你可以在其后放一个问号来使任何量
词变成懒情的：、（+?>、和{7,42}?>都是懒情量词。
的次数，然后保存一个回溯位置，并且允许正则表达式继续。如果剩余的正则表达式
匹配失败了，那么引擎会进行回溯，此时懒情量词会再重复一次。如果正则表达式持
续回溯，那么量词会扩展直到它充许的最大重复次数，或者直到它所重复的正则记号
正则表达式的基本技巧65
www.TopSage.com
---
## Page 82
匹配失败。
(.*?>使用了一个懒情量词来正确地匹配一个XHTML段落。当>匹配成功的
时候，.*?>作为懒情量词，最初什么也不做，只是稍作停顿。如果（在之后立
即出现，那么就会匹配一个空段落。如果不是这样，那么引擎会回溯到.*?>，这次会匹
配一个字符。如果（还是匹配失败，.*？>会接着匹配下一个字符。这个过程会继
续进行下去，直到>匹配成功，或者*？扩展失败。因为点号会匹配任意字符，
所以直到匹配完了所有内容，到达XHTML文件结束的时候，（.*?才会宣布匹配失败。
量词*和*？允许所有相同的正则表达式匹配。唯一的区别是这些可能匹配被尝试的
顺序不同。贪心量词会找到最长可能的匹配。懒情量词则会找到最短可能的匹配。
如果可能的话，最佳解决方案是确保只存在-一个可能的匹配。在实例2.12中，如果你
把所有量词都变成懒情的，用来匹配数字的正则表达式还会匹配相同的数字。原因是
这些正则表达式中拥有量词的部分和紧跟其后的部分是互斥的。d匹配一个数字，而
只有当下一个字符不是数字（或字符）的时候才会匹配之后的位置。
为了有助于更好地理解贪心和懒情量词重复的操作过程，我们可以比较一下和
\d+?b在几个不同目标文本之上的表现。贪心和懒情版本会产生相同的结果，但是却
会按照不同的顺序来检查目标文本。
如果我们使用来匹配1234，（\d+>那么会匹配所有的数字。接着匹配，然后
就会找到一个完整匹配。如果我们使用，那么首先只会匹配1。{\b>在1
和2之间匹配失败。还是会失败。这将一直继续，直到，依然会让（\d+>先匹配1234。
但是接着会匹配失败。（\d+>回溯到123。还是会匹配失败。这会继续下去，直
到d+>回溯到最小可能的1，b>还是会匹配失败。这样整个匹配尝试就会宣告失败。
如果我们使用来匹配1234X，那么d+？首先只会匹配1。在1和2之间匹
配失败。（d+?>会扩展到12，但是还是会失败。这将一直继续，直到匹配1234，
\b还是匹配失败。正则引擎会试图再-次扩展，但是d>无法匹配X。整个匹
配尝试就会宣告失败。
如果我们把d+>放到单词边界之中，那么它必须匹配在目标文本中的所有数字，否则
它就会匹配失败。把量词变成懒情的，并不会影响最后的正则匹配最终是成功还是失
败。事实上，不用任何回溯会更好。下一个实例会解释如何可以使用一个占有
量词\b\d++\b>来达到这个目标，至少在某些流派中是可行的。
参见