        for(var i=0; i>> for(var j=0; j>> for(var j=0; j>> // nothing yet
    >>> for(var j=0; j>> // nothing yet, let's call it again
    >>> for(var j=0; j>> Generated JIT code for fixup arity:
        Code at [0x59920a601880, 0x59920a601900]
        ...
        //Baseline JIT
        ...
        Optimized liveoverflow#...
这下可以了！这里的调用次数使其进入Baseline JIT优化级别。接下来，我们将再次提高调用次数，以触发更高的JIT优化级别。
    >>> for(var j=0; j>> for(var j=0; j
    void AbstractInterpreter::clobberWorld()
    {
        clobberStructures();
    }
函数clobberWorld()会调用clobberStructures(), 其定义位于同一个文件中.
    // JavascriptCore/dfg/DFGAbstractInterpreterInlines.h
    template 
    void AbstractInterpreter::clobberStructures()
    {
        m_state.clobberStructures();
        m_state.mergeClobberState(AbstractInterpreterClobberState::ClobberedStructures);
        m_state.setStructureClobberState(StructuresAreClobbered);
    }
所以，JIT为了防止出现副作用，就必须谨慎对待能够改变对象的结构的代码。例如，假设代码访问对象的属性obj.x后，又突然删除了该属性，那么，JIT必须将这个结构标记为“已更改”，以防止经过JIT处理的代码再访问它；否则，可能会导致内存破坏问题。
好了，本文就说到这里了。在下一篇文章中，我们将研究Linus的exploit，它利用的就是这种漏洞。
## Resources
  * [JavaScriptCore CSI: A Crash Site Investigation Story](https://webkit.org/blog/6411/javascriptcore-csi-a-crash-site-investigation-story/ "JavaScriptCore CSI: A Crash Site Investigation Story")
  * [Inverting your assumptions: A Guide to JIT comparisons](https://www.thezdi.com/blog/2018/4/12/inverting-your-assumptions-a-guide-to-jit-comparisons "Inverting your assumptions: A Guide to JIT comparisons")
  * [Video Explanation](https://www.youtube.com/watch?v=45wMEIIPsPA "Video Explanation")