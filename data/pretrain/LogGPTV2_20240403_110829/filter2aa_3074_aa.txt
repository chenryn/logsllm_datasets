HTTP认证方案
Author：h0ld1rs，Reclu3e
前言
因为HTTP协议是开放的，可以任人调用。所以，如果接口不希望被随意调用，就需要做访问权限的控
制，认证好的用户，才允许调用API。
本篇文章在郁离歌师傅的指导下，参考RFC对HTTP常用的认证方案做了归纳总结
Form认证
最常见的一种认证方式，即表单认证，表单认证一般都会配合cookie+sessiond的使用，现在绝大多数
的Web站点都是使用此认证方式。用户在登录页中填写用户名和密码，服务端认证通过后会将sessionId
返回给浏览器端，浏览器会保存sessionId到浏览器的Cookie中。因为Http是无状态的，所以浏览器使用
Cookie来保存sessionId。下次客户端发送的请求中会包含sessionId值，服务端发现sessionId存在并认
证过则会提供资源访问。
值得一提的是：Cookie+Session 认证属于Form认证，Form认证并不属于HTTP标准验证。
Basic(RFC7617)
• 传输：将凭据作为用户 ID/ 传输密码对，使用 Base64 编码。
• 是基于客户端类型最基本的认证方案
• 服务器只有在可以验证时才会为请求提供服务，申请的保护空间的用户名和密码 请求的资源。
• 特征：response: Unauthorized  Authorization头中数据 Basic 
请求头数据
WWW-Authorization
 ￮ 认证方式 Basic
 ￮ realm
  ▪ 安全域
base64(username:password)
数据包举例
 HTTP
HTTP/1.1 401 Unauthorized
Date: Mon, 04 Feb 2014 16:50:53 GMT
WWW-Authenticate: Basic realm="WallyWorld"
//其中“WallyWorld”是服务器分配的用于标识保护空间的字符串。
认证方法
1. 客户端发送请求，服务器端接受请求后，判断如果请求的资源需要认证，则返回401状态，并在
response headers中加入WWW-Authenticate头部，要求客户端带上认证信息以后再发一次请求
2. 客户端收到401返回信息后，重新向服务器发送请求，并在request headers中加入Authoriaztion
头部，用来说明认证的用户名、密码、算法等信息
3. 服务器端从用户那里取得用户ID与密码
• 但用户ID与密码不得包含任何控制字符
• 包含冒号字符的用户ID是无效的
• 许多用户代理会在不检查
• 用户提供的用户 ID 是否包含冒号的情况下生成用户传递字符串； 然后，收件人会将输入的用户
名的一部分视为密码的一部分
4. 通过冒号(:)连接用户ID，来构造用户通行证，字符和密码
5. 将用户密码编码为八字节序列
6. 通过使用base64，使得方式转化为US-ASCLL字符序列
7. 服务器再次收到请求后，判断以上认证信息无误，返回200，并在response headers中加入
Authorization-Info头部
缺陷
1. 此认证方案的原始定义未能指定用于将用户密码转化为八位字节序列的字符串编码方案
2. 大多数实现取决于特定的环境编码，例如：ISO-8859-1,UTF-8
3. 出于向后兼容的原因，该规范继续保留未定义的默认编码，只要他与US-ASCLL兼容
4. 假冒服务器很容易骗过认证，诱导用户输入用户名和密码。
5. 即使密码被强加密，第三方仍可通过加密后的用户名和密码进行重放攻击。
为了传输安全，需要配合SSL使用。
代理授权
出现在RFC 7235上，还是属于basic认证。
HTTP Proxy-Authorization请求标头包含用于向代理服务器认证用户代理的凭证，通常在服务器响应
407 Proxy Authentication Required状态和Proxy-Authenticate标题后。
如:Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
实际举例
如下图，就是基本的http认证,浏览器弹出基本的对话框
如果认证失败，则返回如下
当请求成功的时候，返回的数据包如下
HTTP服务器在每次收到请求包后，根据协议取得客户端附加的用户信息（BASE64编码的用户名和密
码），解开请求包，对用户名及密码进行验证，如果用 户名及密码正确，则根据客户端请求，返回客户
端所需要的数据;否则，返回错误代码或重新要求客户端提供用户名及密码。
实现
Apache
要对Apache服务器上的目录进行密码保护， 你需要一个 .htaccess 和 a .htpasswd 文件.
该 .htaccess 文件格式通常看起来像这样:
该 .htaccess 文件引用一个 .htpasswd 文件,其中每行用冒号（“：”）分隔的用户名和密码. 你不能看到真
实的密码因为它们是 encrypted (在这个例子中是使用了 MD5). 你可以命名.htpasswd 文件 为你所喜欢
的名字, 但是应该保证这个文件不被其他人访问. (Apache通常配置阻止访问 .ht* 类的文件).
AuthType Basic
AuthName "Access to the staging site"
AuthUserFile /path/to/.htpasswd
Require valid-user
Nginx
在nginx配置中，对需要保护的location你需要做如下配置：auth_basic指令提供密码保护域的名称；
auth_basic_user_file指令指定包含用户密文的证书的文件（与apache例子中一致）
在 nginx 中, 你需要指定一个保护区域和该 auth_basic 指令提供的保护区域名字. 然后该 
auth_basic_user_file 指令指向一个.htpasswd 包含加密用户凭据的文件, 就像上面的 apache 例子.
URL(已废弃)
如下：
https://username:PI:EMAIL/
Bearer(RFC6750)
Bearer即Bearer Token
为了验证使用者的身份，需要客户端向服务器端提供一个可靠的验证信息，称为Token，这个token通常
由Json数据格式组成，通过hash散列算法生成一个字符串，所以称为Json Web Token（Json表示令牌
的原始值是一个Json格式的数据，web表示是在互联网传播的，token表示令牌，简称JWT)
关于JWT，师傅们可以看这篇文章入门
认识JWT - 废物大师兄 - 博客园
Bearer的关键点有以下：
• OAuth使客户端能通过获取的访问令牌来访问受保护的资源。
• Bearer验证中的凭证称为BEARER_TOKEN，或者是access_token，它的颁发和验证完全由我们自己的
应用程序来控制，而不依赖于系统和Web服务器
• 特征：Authorization :Bearer
• 适用场景：分布式站点的单点登录（SSO）场景
数据包
认证方法
aladdin:$apr1$ZjTqBB3f$IF9gdYAGlMrs2fuINjHsz.
user2:$apr1$O04r.y2H$/vEkesPhVInBByJUkXitA/
location /status {                                       
    auth_basic           "Access to the staging site";
    auth_basic_user_file /etc/apache2/.htpasswd;
}
HTTP
GET /resource HTTP/1.1
Host: server.example.com
Authorization: Bearer mF_9.B5f-4.1JqM
• 客户端：从资源服务器请求受保护的资源，并通过提供访问令牌进行身份的验证。
• 资源服务器：验证访问令牌，如果有效，则为请求提供服务
• 当客户端以使用access_token参数将访问的令牌添加到请求正文中，必须满足以下条件：
 ￮ HTTP 请求实体标头包括设置为“application/x-www-form-urlencoded”的“Content-Type”标头字
段。
 ￮ 协议主体遵守HTML定义的application/x-www-form-urlencoded”内容类型的编码要求。
 ￮ 请求实体主体是单部分的。
 ￮ 实体正文中编码内容必须完全由ASCLL字符组成
 ￮ 不得使用GET方法
• 使用access_token参数：其他参数必须以&符号连接
缺陷
• 使用保留的查询参数的名称，与URI命名空间背道而驰
• 如果受保护的资源请求不包括身份验证凭证，或不包含允许访问受保护资源的访问令牌，资源服务器
必须包含 HTTP “WWW-Authenticate”响应头字段；它也可以包含它以 响应其他条件。
• 必须使用Bearer，该方案必须后跟一个或多个 auth-param 值
• “scope”属性不能出现多次。该 “范围”值是为程序中使用，并不意味着要显示给最终用户。
• 回显的错误信息，容易被攻击者利用
• 攻击者会伪造或者修改现有令牌的内容，导致不正确的权限访问
JWT可以存在伪造攻击，举例如CTFhub 中的题目
HTTP
 POST /resource HTTP/1.1 
 Host: server.example.com 
 Content-Type: application/x-www-form-urlencoded 
 access_token=mF_9.B5f-4.1JqM 
HTTP
GET /resource?access_token=mF_9.B5f-4.1JqM&p= HTTP/1.1 
Host: server.example.com
防范
• 为了处理令牌重定向，授权服务器必须在令牌中包含预期接受者的身份。
• 授权服务器必须实现TLS，为了防止令牌泄露，必须使用TLS和提供机密性和完整性保护的密码套件来
应用机密性保护。
• 不记名令牌不得存储在可以明文发送的 cookie 中
• 加强前后端的检验
Digest(RFC7616)
这次是摘要认证
•  Digest 方案基于简单的质询-响应范例
• 一个可选的头域允许服务器指定算法用于创建未加密的摘要或摘要。该文件增加了SHA-256 和 SHA-
512/256 算法。
认证方法
1. 客户端请求受保护资源
2. 服务器返回 401 状态和 WWW-Authenticate 响应头(由于需要Digest认证，服务器返回了两个重要
字段nonce（随机数）和realm)
3. 客户端接收到401状态表示需要进行认证，根据相关算法生成一个摘要，将摘要放到Authoriization
的请求头中，重新发送命令给服务器
HTTP
POST http://127.0.0.1:8087/digest/auth HTTP/1.1 
Accept: application/json 
cache-control: no-cache 
Postman-Token: 0d4e957a-f8ab-4b01-850f-4967ff10b8a0 
User-Agent: PostmanRuntime/7.6.0 
Connection: keep-alive
HTTP
HTTP/1.1 401 
WWW-Authenticate: Digest realm="digest#Realm", qop="auth", 
nonce="MTU1NTMzMDg2MDA4MDo5MTdiMGI4ZmIwMDc2ZTgzOWU5NzA4YzEyZWEwNzlmMg==" 
Cache-Control: no-cache, no-store, max-age=0, must-revalidate 
Pragma: no-cache 
Content-Type: application/json;charset=UTF-8
4. 服务器从 Header 中取出 digest 摘要信息，根据其中信息重新计算新的摘要，然后跟客户端传输的
摘要进行比较（就是比较 response 的值是否相等）；因为服务器拥有与客户端同样的信息，因此
服务器可以进行同样的计算，以验证客户端提交的 response 值的正确性。
WWW-Authenticate响应头字段
realm: 显示给客户端的字符串 
nonce: 服务端生成唯一的、不重复的随机值
 algorithm: 默认MD5算法
qop: auth/auth-int 会影响摘要的算法
stale:密码随机数nonce过期
Authorization请求头字段
response: 客户端根据算法算出的摘要值
username: 要认证的用户名
realm: 认证域,可取任意标识值
uri: 请求的资源位置
qop: 保护质量
HTTP
POST http://127.0.0.1:8087/digest/auth HTTP/1.1 
Accept: application/json 