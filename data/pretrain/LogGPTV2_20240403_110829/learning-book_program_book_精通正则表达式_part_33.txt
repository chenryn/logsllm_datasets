保证匹配文本之前（以及之后）不出现（\w.1能匹配的字符。如果不支持环视，在首尾添
加（~1)（$）也能够应付某些情况。=
---
## Page 216
190
第5章：正则表达式实用技巧
处理文件名
Working with Filenames
处理文件名和路径，例如Unix下的/usr/local/bin/Perl或者Windows下的\Program
Files\Yahoo！\Messenger，很适合用来讲解正则表达式的应用。因为“动手（using）”比
“观摩（reading）”更有意思，我会同时用Perl、PHP（preg程序）、Java和VB.NET来讲解。
如果你对其中的某些语言不感兴趣，不妨完全跳过那些代码一一其中蕴含的思想才是最重
要的。
去掉文件名开头的路径
第一个例子是去掉文件名开始的路径，例如把/usr/local/bin/gcc变成gcc。从本质层面
来考虑问题是成功的一半。在本例中，我们希望去掉在最后的斜线（含）之前（在Windows
中是反斜线）的任何字符。如果没有斜线最好，因为什么也不用干。我曾说过，、*常常被
滥用，但是此处我们需要匹配优先的特性。.*/中的.*可以匹配一整行，然后回退（也
就是回溯）到最后的斜线，来完成匹配。
下面是四种语言的代码，去掉变量f中的文件名中开头的路径。对于Unix的文件名：
语言
代码
Perl
$f=~8{.*/}{）;
PHP
Sf=preg_replace((.*/)，，Sf);
java.util.regex
f = f.replaceFirst(".*/","");
VB.NET
f=Regex.Replace（f，“*/"，""）;
正则表达式（或者说用来表示正则表达式的字符串）以下画线标注，正则表达式相关的组
件则由粗体标注。
下面是处理Windows文件名的代码，Windows中的分隔符是反斜线而不是斜线，所以要用
正则表达式.*\\。在正则表达式中，我们需要在反斜线前再加一个反斜线，才能表示转
义的反斜线，不过，在中间两段程序中添加的这个反斜线本身也需要转义：
语言
代码
Perl
sf=~s/.*y//:
PHP
Sf=preg_replace（/.\/,,St）
java.util.regex
f=f.replaceFirst（*\l,"）
VB.NET
f=Regex.Replace（f,".*\,""）
从中很容易看出各种语言的差异，尤其是Java中那4个反斜线（101）。
---
## Page 217
若干简单的例子
191
有一点请务必记住：别忘了时常想想匹配失败的情形。在本例中，匹配失败意味着字符串
中没有斜线，所以不会替换，字符审也不会变化，而这正是我们需要的。
为了保证效率，我们需要记住NFA引擎的工作原理。设想下面这种情况：我们忘记在正则
表达式的并头添加符号（这个符号很容易忘记），用来匹配一个恰好没有斜线的字符事。
同样，正则引擎会在字符串的起始位置开始搜索。.★抵达字符串的末尾，但必须不断回退，
以找到斜线或者反斜线。直到最后它交还了匹配的所有字符，仍然无法匹配。所以，正则
引擎知道，在字符串的起始位置不存在匹配，但这远远没有结束。
接下来传动装置开始工作，从在目标字符串的第2个字符开始，依次尝试匹配整个正则表
达式。事实上，它需要在字符事的每个位置（从理论上说）进行扫描-回溯。文件名通常很
短，因此这不是个问题，但原理确实如此。如果字符串很长，就可能存在大量的回溯（当
然，DFA不存在这个问题）。
在实践中，经过合理优化的传动装置能够认识到，对几乎所有以".*开头的正则表达式来
说，如果在某个字符串的起始位置不能匹配，也就不能在其他任何位置匹配，所以它只会
在字符串的起始位置（246）尝试一次。不过，在正则表达式中写明这一点更加明智，在
例子中我们正是这样做的。
从路径中获取文件名
另一种办法是忽略路径，简单地匹配最后的文件名部分。最终的文件名就是从最后-个斜
线开始的所有内容：（~/]*$1。这一次，锚点不仅仅是一种优化措施，我们确实需要在结尾
设置一个锚点。现在我们可以这样做，以Perl来说明：
SWholePath=~m{（[^/]*）$}；#利用正则表达式检测SwholePath
$Filename = S1;
#记录匹配内容
你也许注意到了，这里并没有检查这个正则表达式能否匹配，因为它总是能匹配。这个表
达式的唯一要求就是，字符串有s能够匹配的结束位置，而即使是空字符串也有一个结束位
置。因此，我用s1来引用括号内的表达式匹配的文本，因为它必定包括某些字符（如果文
件名以斜线结尾，结果就是空字符）。
这里还需要考虑到效率：在NFA中，[^/]*S的效率很低。仔细想想NFA引擎的匹配过程，
你会明白它包括了太多的回溯。即使是短短的/usr/local/bin/perl’，在获得匹配结果
---
## Page 218
192
第5章：正则表达式实用技巧
之前，也要进行四十多次回溯。考虑从…1oca1…开始的尝试。（~/1*一直匹配到第二个1，
之后匹配失败，然后对1、a、c、0、1的存储状态依次尝试S：（都无法匹配）。如果这还不
够，又会从.1ocal/..开始重复这个过程，接着从.….1ocal/..开始，不断重复。
这个例子不应该消耗我们太多的精力，因为文件名一般都很短（40次回溯几乎可以忽略不
计一4000万次回溯才真正要紧）。再一次，重要的是理解问题本身，这样才能选择合适的
通用规则来解决具体的问题。
需要指出的是，纵然本书是关于正则表达式的，但正则表达式也不总是最优解。例如，大
多数程序设计语言都提供了处理文件名的非正则表达式函数。不过为了讲解正则表达式，
我仍会继续下去。
所在路径和文件名
下一步是把完整的路径分为所在路径和文件名两部分。有许多办法做到这一点，这取决于
我们的要求。开始，你可能想要用（.*）/（.*)$i的S1和$2来提取这两者。看起来这个正
则表达式非常直观，但知道了匹配优先量词的工作原理之后，我们知道第一个.*会首先
捕获所有的文本，而不给/和$2留下任何字符。第一个.*能交还字符的唯一原因，就是
在尝试匹配/（.*）$时进行的回溯。这会把“交还的”部分留给后面的.*。因此，$1就
是文件所在的路径，$2就是文件的名字。
需要注意的是，我们依靠开头的（.*）/来确保第二个（.*）不会匹配任何斜线。理解匹配
优先之后，我们知道这没问题。如果要做的更精确，可以使用（^/*来捕捉文件名。于是
这个表达式有个问题，它要求字符串中必须出现一个斜线，如果我们用它来匹配file.txt，
因为无法匹配，所以没有结果。如果我们希望精益求精，可以这样：
）（i（[/]）/（）~=yeouM）
#能够匹配--S1和S2都合法
SLeadingPath =$1;
SFileName =$2;
}else（
#无法匹配，文件名中不包含”
SLeadingPath="."；#所以"file.txt"应该是"./file.txt”（"."表示当前路径）
$FileName = SWholePath;
---
## Page 219
若干简单的例子
193
匹配对称的括号
Matching Balanced Sets of Parentlieses
对称的圆括号、方括号之类的符号匹配起来非常麻烦。在处理配置文件和源代码时，经常
需要匹配对称的括号。例如，解析C语言代码时可能需要处理某个函数的所有参数。函数
的参数包含在函数名称之后的括号里，而这些参数本身又有可能包含嵌套的函数调用或是
算式中的括号。我们先不考虑嵌套的括号，你或许会想到bfoo\（[~])*\，但这行不通。
秉承C的光荣传统，我把示范函数命名为foo。表达式中的标记部分是用来捕获参数的。
对于foo（2，·4.0）和foo（somevar，·3.7）之类的参数，这个表达式完全没问题。但是，它
也可以匹配foo（bar（somevar），·3.7），这可不是我们需要的。所以要用到比[^）】*更聪
明的办法。
为了匹配括号部分，我们可以尝试下面的这些正则表达式：
1. \(,*\)
括号及括号内部的任何字符。
2.\（[^）]*\）从一个开括号到最近的闭括号。
3．\（[^（）】*\）从一个开括号到最近的闭括号，但是不容许其中包含开括号。
图5-1显示了对一行简单代码应用这些表达式的结果。
需要匹配的部分
val= foo(bar（this),3.7)
+2*（that-1）;
正则表达式2匹配的部分
正则表达式1匹配的部分
图5-1：三个表达式的匹配位置
我们看到，第一个正则表达式匹配的内容太多（注2），第二个正则表达式匹配的内容太少，
第三个正则表达式无法匹配。孤立地看，第三个正则表达式能够匹配（this）”，但是因为
表达式要求它必须紧接在foo之后，所以无法匹配。所以，这三个表达式都不合格。
注2：.*很容易出问题，所以使用.*时必须格外谨慎，明确是否真的需要用一个星号来约束
点号。有时候确实必须这么做，不过通常：*都不是合适的选择。
---
## Page 220
194
第5章：正则表达式实用技巧
真正的问题在于，大多数系统中，正则表达式无法匹配任意深度的嵌套结构。在很长的时
间内，这是放之四海而皆准的规则，但是现在Perl、.NET和PCRE/PHP都提供了解决的办
法（参见第328、436、475页）。但是，即使不用这些功能，我们也可以用正则表达式来匹
配特定深度的嵌套括号，但不是任意深度的嵌套括号。处理单层嵌套的正则表达式是：
(\（+[（(）}(\[(）])\）[（）]
这样类推下去，更深层次的嵌套就复杂得可怕。但是，下面的Per程序，在指定嵌套深度
sdepth之后，生成的正则表达式可以匹配最大深度为sdepth的嵌套括号。它使用的是Perl
的“stringxcounr”运算符，这个运算符会把string重复count次：
Sregex='\（′.(？:[^(）]1\（xSdepth.*[^（)]*.*\))*xSdepth.*\）*；
这个表达式留给读者分析。
防备不期望的匹配
Natclhting Out for Ulnwanted Matches
有个问题很容易忘记，即，如果待分析的文本不符合使用者的预期，会发生什么。假设你
需要编写一个过滤程序，把普通文本转换为HTML，你希望把一行连字符号转换为HTML
中代表一条水平线的。如果使用搜索-替换命令S/-*//，它能替换期望替换的文
本，但只限于它们在行开头的情况。很奇怪吗？事实上，S/-*//会把添加到每一
行的开头，而无论这些行是否以连字符开头。
请记住，如果某个元素的匹配没有硬性规定任何必须出现的字符，那么它总能匹配成功。-*
从字符事的起始位置开始尝试匹配，它会匹配可能的任何连字符。但是，如果没有连字符，
它仍然能匹配成功，这完全符合星号的定义。
在某位我非常尊重的作者的作品中出现过类似的例子，他用这个例子来讲解正则表达式匹
配一个数，或者是整数或者是浮点数。在它的正则表达式中，这个数可能以负数符号开头，
然后是任意多个数字，然后是可能的小数点，再是任何多的数字。他的正则表达式是
确实，这个正则表达式可以匹配1、-272.37、129238843.、.191919，甚至是-.0这样的
数。这样看来，它的确是个不错的正则表达式。
但是，你想过这个表达式如何匹配“this•has'no"number’‘nothing·here’或是空字符串
吗？仔细看看这个正则表达式一每一个部分都不是匹配必须的。如果存在-个数，如果
正则表达式从在字符串的起始位置开始，的确能够匹配，但是因为匹配没有任何必须元素。
---
## Page 221
若干简单的例子
195
此正则表达式可以匹配每个例子中字符事开头的空字符。实际上它甚至可以匹配num·123
并头的空学符，因为这个空字符比数字出现得更早。
所以，把真正意图表达清楚是非常重要的。一个浮点数必须要有至少一位数字，否则就不
是一个合法的值。我们首先假设，在小数点之前至少有一位数字（之后我们会去掉这个条
件）。如果是，我们需要用加号来控制这些数字-？[0-9]+]。
如果要用正则表达式来匹配可能存在的小数点（及其后的数字），就必须认识到，小数部分
必须紧接在小数点之后。如果我们简单地用.？[0-9]*，那么无论小数点是否存在，
[0-9]*都可能匹配。
解决的办法还是厘清我们的意图：小数点（以及之后的数字）是可能出现的：（\.[0-9）*）？1。
这里，问号限定（也可以叫“统治governs”或者“控制controls"）的不再是小数点，而是
小数点和后面的小数部分。在这个结合体内部，小数点是必须出现的，如果没有小数点，
[0-9]*根本谈不上匹配。
把它们结合起来，就得到‘-？[0-9]+（\.[0-9]*）？]。这个表达式不能匹配.007”，因为它
要求整数部分必须有一位数字。如果我们作些修改，容许整数部分为空，就必须同时修改
小数部分，否则这个表达式就可以匹配空字符（这是我们一开始就准备解决的问题）。
解决的办法是为无法覆盖的情况添加多选分支：-？[0-9]+（\.[0-9]*）？1？\.[0-9]t1。这
样就能匹配以小数点开头的小数（小数点是必须的）。仔细看看，仔细看看。你注意到了吗？
第二个多选分支同样能够匹配负数符号开头的小数？这很容易忘记。当然，你也可以把-？
提出来，放到所有多选结构的外面：-?（[0-9]+（\.[0-9]*）？|\.[0-9]+）]。
虽然这个表达式比最开始的好得多，但它仍然会匹配“2003.04.12’这样的数字。要想真
正匹配期望的文本，同时忽略不期望的文本，求得平衡，就必须了解实际的待匹配文本。
我们用来提取浮点数的正则表达式必须包含在一个大的正则表达式内部，例如用.S或者
num\s*=\s*.-$)
款
---
## Page 222
196
第5章：正则表达式实用技巧
匹配分隔符之内的文本
Matcling DelimitedText
匹配用分隔符（以某些字符表示）之类的文本是常见的任务，之前的匹配双引号内的文本
和IP地址只是这类问题中的两个典型例子。其他的例子还包括：
·匹配/’和‘/”之间的C语言注释。
·匹配一个HTMLtag，也就是尖括号之内的文本，例如。
中的‘super exciting。
·匹配.mailrc文件中的一行内容。这个文件的每一行都按下面的数据格式来组织：
alias简称电子邮件地址
例如‘PI:EMAIL’（在这里，分隔符是每个部分之间的空白
和换行符）。
needs a“2\*x3\*likeness"of the holder'。
·解析CSV（逗号分隔值，comma-separatedvalues）文件。
总的来说，处理这些任务的步骤是：
1.匹配起始分隔符（openingdelimiter）。
2.匹配正文（main text，即结束分隔符之前的所有文本）。
3.匹配结束分隔符。
我曾经说过，如果结束分隔符不只一个字符，或者结束分隔符能够出现在正文中，这种任
务就很难完成。
容许引文字符串中出现转义引号
来看2\"x3\"的例子，这里的结束分隔符是一个引号，但正文也可能包含转义之后的引号。
匹配开始和结束分隔符很容易，诀窍就在于，匹配正文的时候不要超越结束分隔符。
仔细想想正文里能够出现的字符，我们知道，如果一个字符不是引号，也就是说如果这个
字符能由[^"]匹配，那么它肯定属于正文。不过，如果这个字符是一个引号，而它前面
又有一个反斜线，那么这个引号也属于正文。把这个意思表达出来，使用环视（?133）功
能来处理“如果之前有反斜线”的情况，就得到”（{"]1（？<=\\）"）*"，这个表达式完全
能够匹配2\"x3\"。