要低效得多。
在计算机领域，我们同样会遇到各种高效和拙劣的算法。衡量算法好坏
的重要标准有两个。
·时间复杂度
·空间复杂度
具体的概念会在本章进行详细讲解。
---
## Page 21
算法的应用领域多种多样。
算法可以应用在很多不同的领域中，其应用场景更是多种多样，例如下
面这些。
1.运算
有人或许会觉得，不就是数学运算吗？这还不简单？
其实还真不简单。
例如求出两个数的最大公约数，要做到效率的极致，的确需要动一番脑
筋。
再如计算两个超大整数的和，按照正常方式来计算肯定会导致变量溢
出。这又该如何求解呢？
426709752318
+
95481253129
522191005447
2.查找
当你使用谷歌、百度搜索某一个关键词，或在数据库中执行某一条SQL
语句时，你有没有思考过数据和信息是如何被查出来的呢？
Bai百度法
百座一1
页资图片知文库贴吧采地图更多
法百度百的
航你批是说，你对一定规还的编入，在有用时间内民碑所量的
出，加是一个其法有成不通合于星个间
baloha
3.排序
---
## Page 22
排序算法是实现诸多复杂程序的基石。例如，当浏览电商网站时，我们
期望商品可以按价格从低到高进行排序；当浏览学生管理网站时，我们
期望学生的资料可以按照学号的大小进行排序。
排序算法有很多种，它们的性能和优缺点各不相同，这里面的学问可大
着呢。
4.最优决策
有些算法可以帮助我们找到最优的决策。
例如在游戏中，可以让AI角色找到迷宫的最佳路线，这涉及A星寻路算
法。
---
## Page 23
LEVEL
品
88
CHIPS
LEFT
888
LESSON1
Password:BDHP
再如对于一个容量有限的背包来说，如何决策才可以使放入的物品总价
值最高，这涉及动态规划算法。
5.面试（如果这条也算的话）
凡是已走上工作岗位的程序员，在面试过程中多多少少都经历过算法问
题的考查。
为什么面试官那么喜欢考查算法呢？
考查算法问题，一方面可以检验程序员对计算机底层知识的了解，另一
方面也可以衡量一下程序员的逻辑思维能力。
1.1.3
什么是数据结构
算法的概念我大致明白了，那数
---
## Page 24
据结构又是什么呢？
数据结构是算法的基石。如果把算法
比喻成美丽灵动的舞者，那么数据结构就是舞者脚下广阔而坚实的
舞台。
数据结构，对应的英文单词是datastructure，是数据的组织、管理和
存储格式，其使用目的是为了高效地访问和修改数据。
数据结构都有哪些组成方式呢？
1.线性结构
线性结构是最简单的数据结构，包括数组、链表，以及由它们衍生出来
的栈、队列、哈希表。
249376
2.树
树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生
出了二叉堆之类的数据结构。
---
## Page 25
2
3
3.图
图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系。
2
9
3
4.其他数据结构
除上述所列的几种基本数据结构以外，还有一些其他的千奇百怪的数据
结构。它们由基本数据结构变形而来，用于解决某些特定问题，如跳
表、哈希链表、位图等。
有了数据结构这个舞台，算法才可以尽情舞蹈。在解决问题时，不同的
算法会选用不同的数据结构。例如排序算法中的堆排序，利用的就是二
叉堆这样一种数据结构：再如缓存淘汰算法LRU（Least
Recently
Used，最近最少使用），利用的就是特殊数据结构哈希链表。
关于算法在不同数据结构上的操作过程，在后续的章节中我们会一一进
---
## Page 26
行学习。
想不到算法和数据结构包括这么
多丰富多彩的内容，大黄，我以后要好好跟你混！
嘿嘿，我所掌握的也只是广阔的算法
海洋中的一个小水洼，让我们一步一步来体验算法的无穷魅力吧！
1.2
时间复杂度
1.2.1
算法的好与坏
大黄，通过你之前的讲
解。我大体了解了算法的
意义，那么，怎样来衡量
个算法的好坏呢？
---
## Page 27
衡量算法的好坏有很多标
准，其中最重要的两大标
准是算法的时问复杂度和
空间复杂度，
时间复杂度和空间复杂度究竞是什么呢？首先，让我们来想象一个场
景。
某一天，小灰和大黄同时加入了同一家公司。
小放，大黄，我给你们分
别布置一个需求，你们要
用代码实现出表。
一天后，小灰和大黄交付了各自的代码，两人的代码实现的功能差不
多。
大黄的代码运行一次要花100ms，占用内存5MB
小灰的代码运行一次要花100s，占用内存500MB。
于是....
小东，收拾东西“走人”
吧, 明天不用束上班了 1
---
## Page 28
在上述场景中，小灰虽然也按照老板的要求实现了功能，但他的代码存
在两个很严重的问题。
1.运行时间长
运行别人的代码只要100ms，而运行小灰的代码则要100s，使用者肯定
是无法忍受的。
2.占用空间大
别人的代码只消耗5MB的内存，而小灰的代码却要消耗500MB的内存，
这会给使用者造成很多麻烦。
由此可见，运行时间的长短和占用内存空间的大小，是衡量程序好坏的
重要因素。
可是，如果代码都还没有运行，
我怎么能预知代码运行所花的时间呢？
---
## Page 29
由于受运行环境和输入规模的影响，
代码的绝对执行时间是无法预估的。但我们却可以预估代码的基本
操作执行次数。
1.2.2
基本操作执行次数
关于代码的基本操作执行次数，下面用生活中的4个场景来进行说明。
场景1给小灰1个长度为10cm的面包，小灰每3分钟吃掉1cm，那么吃掉
整个面包需要多久？
答案自然是3×10即30分钟。
如果面包的长度是ncm呢？
此时吃掉整个面包，需要3乘以n即3n分钟。
如果用一个函数来表达吃掉整个面包所需要的时间，可以记作T(m)=3n
，n为面包的长度。
场景2给小灰1个长度为16cm的面包，小灰每5分钟吃掉面包剩余长度的
一半，即第5分钟吃掉8cm，第10分钟吃掉4cm，第15分钟吃掉2cm..
---
## Page 30
那么小灰把面包吃得只剩1cm，需要多久呢？
这个问题用数学方式表达就是，数字16不断地除以2，那么除几次以后
的结果等于1？这里涉及数学中的对数，即以2为底16的对数log216。
（注：本书下文中对数函数的底数全部省略。）
因此，把面包吃得只剩下1cm，需要5xlog16即20分钟。
如果面包的长度是ncm呢？
此时，需要5乘以logn即5logn分钟，记作T（n)=5logn。
场景3给小灰1个长度为10cm的面包和1个鸡腿，小灰每2分钟吃掉1个
鸡腿。那么小灰吃掉整个鸡腿需要多久呢？
答案自然是2分钟。因为这里只要求吃掉鸡腿，和10cm的面包没有关
系。
如果面包的长度是ncm呢？
无论面包多长，吃掉鸡腿的时间都是2分钟，记作T(n)=2。
场景4给小灰1个长度为10cm的面包，小灰吃掉第1个1cm需要1分钟
时间，吃掉第2个1cm需要2分钟时间，吃掉第3个1cm需要3分钟时
间......每吃1cm所花的时间就比吃上一个1cm多用1分钟。那么小灰吃掉
整个面包需要多久呢？
答案是从1累加到10的总和，也就是55分钟。
---
## Page 31
如果面包的长度是ncm呢？
根据高斯算法，此时吃掉整个面包需要1+2+3+...+(n-1)+n即(1+n)xn/2
分钟，也就是0.5n²+0.5n分钟，记作T(n)=0.5n²+0.5n。
怎么除了吃还是吃啊？这还不得
撑死？
上面所讲的是吃东西所花费的时间，这一思想同样适用于对程序基本操
作执行次数的统计。设T(n)为程序基本操作执行次数的函数（也可以认
为是程序的相对执行时间函数），n为输入规模，刚才的4个场景分别对
应了程序中最常见的4种执行方式。
场景1T(n)=3n，执行次数是线性的。
1. void eat1(int n){
2.
for(int i=0; i1; i/=2){
---
## Page 32
3.
System.out.println("等待1分钟"）;
4.
System.out.println("等待1分钟"）;
5.
System.out.println（"等待1分钟"）;
6.
System.out.println（"等待1分钟"）;
7.
System.out.println（"吃一半面包"）;
8.
9.}
场景3
T(n)=2，执行次数是常量。
1. void eat3(int n){
2.
System.out.println（"等待1分钟"）;
3.
System.out.println（"吃1个鸡腿"）;
4.}
场景4
T(n)=0.5n²+0.5n，执行次数是用多项式计算的。
1. void eat4(int n){
2.
for(int i=0; i<n; i++){
3.
for(int j=0; j<i; j++){
4.
System.out.println（"等待1分钟"）;
5.
6.
System.out.println("吃1cm 面包"）;
7.
8.}
1.2.3
渐进时间复杂度
---
## Page 33
有了基本操作执行次数的函数T(n)，是否就可以分析和比较代码的运行
时间了呢？还是有一定困难的。
例如算法A的执行次数是T(n)=100n，算法B的执行次数是T(n)=5n²，
这两个到底谁的运行时间更长一些呢？这就要看n的取值了。
因此，为了解决时间分析的难题，有了渐进时间复杂度（asymptotic
timecomplexity）的概念，其官方定义如下。
若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于
零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为
O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。
因为渐进时间复杂度用大写0来表示，所以也被称为大0表示法。
这个定义好晦涩呀，看不明白。
直白地讲，时间复杂度就是把程序的
相对执行时间函数T(n)简化为一个数量级，这个数量级可以是n、n
2、n3等。
如何推导出时间复杂度呢？有如下几个原则。
·如果运行时间是常数量级，则用常数1表示
---
## Page 34
·只保留时间函数中的最高阶项
·如果最高阶项存在，则省去最高阶项前面的系数
让我们回头看看刚才的4个场景。
场景1
T(n)=3n,
最高阶项为3n，省去系数3，则转化的时间复杂度为：T(n)=0(m)。
场景2
T(n) = 5logn,
最高阶项为5logn，省去系数5，则转化的时间复杂度为：T(m)=0(logn)
---
## Page 35
场景3
T(n)=2,
只有常数量级，则转化的时间复杂度为：T(n)=0(1)。
场景4
T(n) = 0.5n ² + 0.5n,
最高阶项为0.5n²，省去系数0.5，则转化的时间复杂度为：T(n)=0(n²)
---
## Page 36
这4种时间复杂度究竞谁的程度执行用时更长，谁更节省时间呢？当n的
取值足够大时，不难得出下面的结论：
0(1)<0(logn)<0(n)<0(n²)
在编程的世界中有各种各样的算法，除了上述4个场景，还有许多不同
形式的时间复杂度，例如：
O(nlogn)、O(n²)、O(mn)、O(2")、O(n!)
今后当我们邀游在代码的海洋中时，会陆续遇到上述时间复杂度的算
法。
1.2.4时间复杂度的巨大差异
---
## Page 37
大黄，我还有一个问题，现在计
算机硬件的性能越来越强了，我们为什么还这么重视时间复杂度
呢？
问得很好，让我们用两个算法来做一
个对比，看一看高效算法和低效算法有多大的差距。
举例如下。
算法A的执行次数是T(n)=100n，时间复杂度是O(n)。
算法B的执行次数是T(n)=5n²，时间复杂度是O(n²)。
算法A运行在小灰家里的老旧电脑上，算法B运行在某台超级计算机
上，超级计算机的运行速度是老旧电脑的100倍。
那么，随着输入规模n的增长，两种算法谁运行速度更快呢？
---
## Page 38
T（n）=100nX100
T（n）=5n
n=1
10000
5
n=5
50 000
125
n=10
100000
500
n=100
1000000
50000
n=1000
10 000000
5 000000
n=10000
100 000000
500 000000
n=100000
1 000 000000
50 000000000
n=1000000
10 000 000 000
5000000000000
从上面的表格可以看出，当n的值很小时，算法A的运行用时要远大于
算法B：当n的值在1000左右时，算法A和算法B的运行时间已经比较接
近：随着n的值越来越大，甚至达到十万、百万时，算法A的优势开始
显现出来，算法B的运行速度则越来越慢，差距越来越明显。
这就是不同时间复杂度带来的差距。
要想学好算法，就必须理解时间复杂
度这个重要的基础概念。有关时间复杂度的知识就介绍到这里，我
们下一节再见！
1.3
空间复杂度
1.3.1
什么是空间复杂度
---
## Page 39
大黄，时问复杂度我基本
上弄明白了，那么空间复
杂度又是什么呢？
简单来说，时问复杂度是
执行算法的时间成本，空
间复杂度是执行算法的空
问成本。
在运行一段程序时，我们不仅要执行各种运算指令，同时也会根据需
要，存储一些临时的中间数据
，以便后续指令可以更方便地继续执
行。
在什么情况下需要这些中间数据呢？让我们来看看下面的例子。
给出下图所示的n个整数，其中有两个整数是重复的，要求找出这两个
重复的整数。
31254972
对于这个简单的需求，可以用很多种思路来解决，其中最朴素的方法就
是双重循环，具体如下。
遍历整个数列，每遍历到一个新的整数就开始回顾之前遍历过的所有整
数，看看这些整数里有没有与之数值相同的。
第1步，遍历整数3，前面没有数字，所以无须回顾比较。
---
## Page 40
第2步，遍历整数1，回顾前面的数字3，没有发现重复数字。
第3步，遍历整数2，回顾前面的数字3、1，没有发现重复数字。
1121514191712
2
5
4
419712
后续步骤类似，一直遍历到最后的整数2，发现和前面的整数2重复，
03,1,2比较
03,1,2,5比
03,1.2,5,4比较
03,1,2,5,4,9比较
514191712
03,1,2,5,4,9,7较
发现整数2重最！
双重循环虽然可以得到最终结果，但它显然并不是一个好的算法。
它的时间复杂度是多少呢？
根据上一节所学的方法，我们不难得出结论，这个算法的时间复杂度
是0(n²）。
那么，怎样才能提高算法的效率
呢？