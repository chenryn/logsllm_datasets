information stated in all the transitions triggered by a method
into a pre-condition and post-condition for that method, as
shown in the Listing 1.
Similarly, the post-condition states that if the pre-condition
for invoking a method is true then its post-condition should
also be true. We say that the post-condition of the method m
is true if the conjunction of the state invariant of the target
state of t and the effect on the transition t is true provided its
pre-condition is true. Listing 1 shows the post-condition for
DELETE(volume) method. The implication principle encom-
passes the stateful behavior since the same method can be Ô¨Åred
from different states of the system and have different results.
Thus, if the method is Ô¨Åred with a certain pre-condition then
the corresponding post-condition for that method should also
be established.
Since an execution of a method might change the state of
a resource, to evaluate the pre-condition, we need to store the
resource state before the method execution. To achieve this,
we save the resource state before the method execution in the
local variables of the monitor implementation. The values of
these variables are later used to calculate the post-condition.
We believe this is not computationally expensive because
we do not need to save the copy of the whole resource(s)
but only the values that constitute the guards and invariants
that are evaluated. Usually, this only requires a few bits of
storage per method. The pre- and post-conditions generated
from behavioral model and security requirements table in OCL
are shown in Listing 1.
P r e C o n d i t i o n (DELETE ( . . . / v3 /{ p r o j e c t
[ ( p r o j e c t . id ‚àí>s i z e ( ) =1 and p r o j e c t . volumes‚àí>s i z e ( ) >=1 and
p r o j e c t . volumes  ‚Äô in‚àíuse ‚Äô and u s e r . id . g r o u p s = ‚Äô admin ‚Äô ) or
( p r o j e c t . id ‚àí>s i z e ( ) =1 and p r o j e c t . volumes‚àí>s i z e ( ) >=1 and
i d }/ volumes ) ) :
p r o j e c t . volumes s i z e ( ) >1 and volume . s t a t u s <>
‚Äô in‚àíuse ‚Äô and u s e r . id . g r o u p s = ‚Äô admin ‚Äô ) or
or
( p r o j e c t . id ‚àí>s i z e ( ) =1 and p r o j e c t . volumes‚àí>s i z e ( ) >=1 and
p r o j e c t . volumes = q u o t a s e t s . volume and volume . s t a t u s
<> ‚Äô in‚àíuse ‚Äô and u s e r . id . g r o u p s = ‚Äô admin ‚Äô ) ]
P o s t C o n d i t i o n (DELETE ( . . . / v3 /{ p r o j e c t
[ ( ( p r o j e c t . id ‚àí>s i z e ( ) =1 and p r o j e c t . volumes‚àí>s i z e ( ) >=1
i d }/ volumes ) ) :
and p r o j e c t . volumes  ‚Äô in‚àíuse ‚Äô and u s e r . id . g r o u p s = ‚Äô admin ‚Äô )
==> p r o j e c t . id ‚àí>s i z e ( ) =1 and
p r o j e c t . volumes‚àí>s i z e ( ) >=0 ) or
( ( p r o j e c t . id ‚àí>s i z e ( ) =1 and p r o j e c t . volumes‚àí>s i z e ( ) >=1 and
p r o j e c t . volumes s i z e ( ) >1 and volume . s t a t u s <>
‚Äô in‚àíuse ‚Äô and u s e r . id . g r o u p s = ‚Äô admin ‚Äô ) ==> p r o j e c t . id
‚àí>s i z e ( ) =1 and p r o j e c t . volumes‚àí>s i z e ( ) >=1 and
p r o j e c t . volumes s i z e ( ) s i z e ( ) ) )
or
( ( p r o j e c t . id ‚àí>s i z e ( ) =1 and p r o j e c t . volumes‚àí>s i z e ( ) >=1 and
p r o j e c t . volumes = q u o t a s e t s . volume and volume . s t a t u s
<> ‚Äô in‚àíuse ‚Äô and u s e r . id . g r o u p s = ‚Äô admin ‚Äô )==> p r o j e c t . id
‚àí>s i z e ( ) =1 and p r o j e c t . volumes‚àí>s i z e ( ) >=1 and
p r o j e c t . volumes s i z e ( ) s i z e ( ) ) ) ]
Listing 1. Example of pre- and post-conditions
A detailed description of how to generate contracts from
UML diagrams (without REST features and security require-
ments) can be found in [33].
VI. TOOL ARCHITECTURE OF CLOUD MONITOR
Section III described the main concepts and architecture of
the cloud monitor (CM). In this section, we present details
of CM implementation. CM is implemented as a proxy inter-
face (wrapper). We implemented our monitoring mechanism
in Django web framework [22]. Figure 4 shows the tool
architecture. The dotted and solid arrows show the manual
and automated steps correspondigly. The starting point of
our approach is the speciÔ¨Åcation document along with the
description of the security policy. The system analyst should
create the resource and behavioral models using some of the
available UML tools. In this work, we have used MagicDraw
UML [7]. We generate XML Metadata Interchange (XMI) of
the behavioral model from this tool and save it into a Ô¨Åle. The
XMI Ô¨Åles are given as the input to CM.
The tool gathers the necessary information from the input
models and creates appropriate data structures. Django can be
understood with its three basic Ô¨Åles that support separation of
concerns, as follows: the Ô¨Åle models.py contains descriptions
of the database tables, views.py contains the business logic and
urls.py speciÔ¨Åes which URIs map to which view. A detailed
530
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:49:51 UTC from IEEE Xplore.  Restrictions apply. 
	
%	!!




#$
	




#$
	

!






	







"!
"!
"!
"!
	
	

 





 "!
 "!


 "!
 "!











Fig. 4. Cloud Monitor
description of the Django web framework can be found in [18]
and [21].
The current implementation continues our work on develop-
ing the wrapper [34]. It focuses on validation of the authoriza-
tion policy and its implementation in the cloud environment.
The main steps in our implementation are as follows:
‚Ä¢ We look for the resources in the class diagram to imple-
ment database tables in models.py. For each resource we
create a table in the database, and analyze its associations
to deÔ¨Åne their relationships with their keys. This creates
a local copy of the resource structures as required by our
monitor.
‚Ä¢ urls.py contains the relative URLs of each resource and
ways to access their respective views. This information is
fully deÔ¨Åned in the class diagram. By traversing the tags
on the associations between the resources, we compose
the paths of each resource. We always start from the
corresponding collection, especially if we are referencing
an item in the collection.
‚Ä¢ The views.py Ô¨Åle contains the main functionality of the
system, i.e., the code that will run when accessing a
resource through its URL according to the request (GET,
PUT, POST or DELETE). These concepts are deÔ¨Åned in
the state machine diagram. The population of views.py
is done in four steps: 1) add information regarding the
permitted methods over the resources; 2) extract the func-
tional contracts from the behavioral model as explained
in section V and add them to the appropriate views; 3)
add the authorization information from the guards into
the appropriate views; 4) read security requirements from
the comments on the transitions and add them as the
corresponding variables in the code.
‚Ä¢ Export to code all the information, i.e., create the Ô¨Åle
structure needed to run the system for the Django web
framework.
In the Ô¨Ånal result, we obtain the necessary Django project
Ô¨Åles. As mentioned above, we need the intervention of the
user in some parts of the views.py Ô¨Åle. The user should Ô¨Åll
in the skeleton code of the functions with the desired method
implementation code. The use of the cloud monitor is very
simple:
uml2django ProjectName DiagramsFileinXML
where ProjectName denotes the name of our project in Django
and DiagramsFileinXML will contain the diagrams required in
XML format.
The users can rely on cURL to invoke URIs if they want to
use the cloud monitor. The cURL tool runs an HTTP client
and supports most of the HTTP methods, authentication
mechanisms, headers etc.
invoking a DELETE
method on volume resource on a local server, the following
command can be used in cURL:
curl ‚àí X DELET E ‚àí d id = 4 http : //127.0.0.1 :
8000/ cmonitor/volumes/4
[4]. For
Alternatively, the users can also use REST clients available
as plugins for different browsers or write test scripts.
A. Used Technologies
We have used the standard UML to model REST behavioral
interface of private cloud. The UML standard provides many
beneÔ¨Åts to the system developers supported by a large user
base and mature and sophisticated tools that constantly im-
prove with time. In addition, these models can serve as a part
of the speciÔ¨Åcation document. We use MagicDraw to deÔ¨Åne
our diagrams. Our work uses XML 2.1 and UML 2.0. Our
compiler is implemented in Python programming language. It
is written in Python 2.7 and requires lxml [5] module. In order
to invoke methods on private cloud via code-skeletons, we
use urllib2, a Python module that is used to fetch URLs [10].
Finally, to run the cloud monitor modeled, we have chosen
Django web framework that uses Python too.
B. Limitations
Our approach is not fully automatic because we require
the user intervention in Ô¨Ålling in the missing lines of code
in the generated code skeletons. This has been done to keep
the models readable and avoid cluttering them with too many
low-level details. Such an approach can make it harder to
establish an equivalence between the speciÔ¨Åcation models and
the implementation code. The alternative approaches would be
either to use the transformation languages or to enable fully au-
tomatic generation by deteriorating readability of the models.
In our implementation, we chose to create a Python compiler
with a greater capacity for compilation and processing of data
structures enabling an analysis of the different parts of the
code.
531
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:49:51 UTC from IEEE Xplore.  Restrictions apply. 
Another limitation, rather typical to the model-driven ap-
proaches, is the need to maintain the correspondence between
the models and the code,
i.e., whenever the changes are
introduced, they should be done in both the models and the
code. However, this is the price to be paid for enabling an
automated model-based veriÔ¨Åcation of functional and security
requirements.
Ensuring scalability and managing complexity of the models
is also a challenge associated with any modelling approach. In-
deed, our models are enriched with fairly complex behavioral
information deÔ¨Åned in terms of state invariants. To reduce the
complexity, we do not require the system analyst to model the
entire functional and security behavior of private cloud in one
diagram. Our approach can be used to represent and validate
only those scenarios that are considered to be critical by the
experts. Similarly, the number of methods that are selected for
the implementation in the cloud monitor can be reduced by
focusing only on those resources that are considered to be the
main assets. We are planning to address these limitations in
our future work by proposing a support for splitting the models
into several parts via slicing or aspect-oriented approaches.
C. Implementation
For Cinder
service, we exemplify implementation of
DELETE method on volume resource. The Listing 2 shows
the view for volume and volume delete.
def volume ( r e q u e s t , volume id ) :