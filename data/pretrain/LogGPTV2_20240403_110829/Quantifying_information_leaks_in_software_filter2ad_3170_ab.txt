condition generated by the bounded model checker for the
policy in Program 1 is:
o1 != o2 =⇒ (o3 == o1 || o3 == o2)
Where the bounded model checker tries to ﬁnd a counter-
example (execution path) using the negated claim such that
the following holds
o1 != o2 ∧ o3 != o1 ∧ o3 != o2
Point (1) is proved in [4], (2) in [12] and (3) is a consequence
of proposition 2 whose proof is in [8]. Hence a lower bound
on | (cid:39)P | provides a lower bound on the channel capacity of
the program P .
Hence, because of proposition 3 the inequality | (cid:39)P | > N ,
which is at the heart of our analysis, can be rephrased to the
following statement:
in a setting where the distribution of
the secret is the most favourable for the attacker then the
leakage is at least log2(N ) bits.
3. ENCODING DISTINCTION-BASED POLICIES
Recall that for a program P a quantitative policy is a
natural number N which limits the cardinality of (cid:39)P to N .
3The channel capacity is the maximum possible leakage
where we consider all possible probability distributions on
the inputs [12]
i.e. that there are three distinctions possible.
Another possibility is that the function func does not even
make two distinctions, such that the assume statement at
point (A) is always false, which leads to proving the policy
(or any policy) vacuously true, because for any assertion Q
the veriﬁcation condition is true, i.e. false =⇒ Q.
3.1 Bounded Model Checking
We use the bounded model checker CBMC to verify or
falsify a policy. CBMC encodes an ANSI-C program into a
propositional formula by unwinding the transition relation
Input: Function func, types t,t’,t”, comparison eq_t,
bound k, threshold N
Output: Driver.c
t o_1, . . ., o_n, o_n+1;
t’ h_1, . . ., h_n, h_n+1;
t’’ l;
h_1 = input(); . . . h_n = input();
l = input();
o_1 = func(h_1, l);
.
.
.
o_n = func(h_n, l);
assume(!eq_t(o_1, o_2) && !eq_t(o_1, o_3) && . . .);
o_n+1 = func(h_n+1, l);
assert(eq_t(o_n+1, o_1) || eq_t(o_n+1, o_2) || . . .);
Algorithm 1: Template to syntactically generate a
driver for an N distinction policy
and user deﬁned speciﬁcations up to some bound. This for-
mula is only satisﬁable if there exists an error trace violating
the speciﬁcation.
The tool can also check if the unwinding bound is suf-
ﬁcient by introducing unwinding assertions, which are as-
sertions on the negated loop guards. This ensures that no
longer counterexample can exist than the used bound. To
prove any properties the analysis has to pass unwinding
assertions, otherwise it can only be used as a way to ﬁnd
counterexamples up to the unwinding bound.
The C program gets encoded into constraints C and the
property – user deﬁned assertions – are encoded in P . Then
the model checker tries to ﬁnd a satisﬁable assignment to
the formula
C ∧ ¬P
where P is an accumulation of the assumptions and asser-
tions made in the program text. Thus if there are two assume
statements in the driver with expressions E1 and E2 and one
assert statement with expression Q then P is
P ≡ E1 ∧ E2 =⇒ Q
3.2 Driver
A general template for a driver is described in Algorithm
1. The inputs to the algorithm are the function func to
be analysed, possibly up to three diﬀerent types for the in-
put/output pair (cid:104)(h, l), o(cid:105), and a comparison function eq_t
which returns true if the arguments of type t are equal,
where t is the type of the observation of function func. This
comparison function could be as simple as == of C, or a more
complex function, such as memcmp, if t is an array or string.
Also note, that the observations o_i do not need to be only
return values, but can also be pointer arguments to func.
Proposition 4
(Correctness of driver template).
If the driver template in Algorithm 1 is successfully veriﬁed
up to a bound k (i.e. the negated claim is unsatisﬁable) then
the function func does not make more than N distinctions
on the output within the bound k. Formally, we state that
the validity of the driver implies the validity of the following
implication
o1 (cid:54)= o2 ∧ o1 (cid:54)= o3 ∧ ··· ∧ on−1 (cid:54)= on
=⇒ on+1 = o1 ∨ ··· ∨ on+1 = on
Thus, we can make the following claims on the result of
the model checking process: For a given bound k and a
policy,
• if the model checker ﬁnds a counterexample then the
policy is violated, i.e. the program makes more dis-
tinctions than speciﬁed
• if the process ends with a successful veriﬁcation of the
policy without unwinding assertions then the policy
holds up to an unwinding of k.
• if the process ends with a successful veriﬁcation of the
policy with unwinding assertions then the policy holds
for any number of iterations.
4. CHECKING QUANTITATIVE POLICIES
The steps in checking a program or function for the com-
pliance with a quantitative policy are as follows: (1) Deﬁne
the input state (h, l) and output state o in the code, i.e.
the conﬁdential input h, the low input l and the observa-
tion o (2) Deﬁne the maximum number of distinctions in
the policy and an unwinding factor k (3) Generate a driver
function using the template in Algorithm 1 (4) Run CBMC
on the driver. If the driver is successfully veriﬁed, poten-
tially increase the unwinding factor.
4.1 Modelling Low Input
A crucial aspect of our analysis is to model low user input,
which is most of the time responsible for triggering a bug
which causes the information leak. These bugs only happen
on a very restricted number of execution paths and could be
exploited by a malicious user choosing a special user input.
This scenario generally applies when studying many CVE
reported information leakage vulnerabilities.
Let us look at the following simpliﬁed code in Program 2,
which contains an integer underﬂow, taken from the vulner-
ability CVE-2007-2875 in the linux kernel.
typedef long long loff_t;
typedef unsigned int size_t;
int underflow(int h, loff_t ppos) {
int bufsz;
size_t nbytes;
bufsz=1024;
nbytes=20;
if (ppos + nbytes > bufsz) // (A)
nbytes = bufsz - ppos; // (B)
if(ppos + nbytes > bufsz) {
return h; // (C)
} else {
return 0;
}
}
Program 2: Integer underﬂow causing a leak
At ﬁrst, it seems not possible that the point (C) where the
secret h gets returned is ever executed, because exactly that
check is done in (A) which reduces the variable nbytes to
be within the bound bufsz. However, due to wrong choice
and combination of types, the subtraction in (B) causes an
underﬂow in nbytes for a very large ppos value. And unfor-
tunately, ppos is a user controlled input variable, such that
when its value is chosen correctly, point (C) is reached.
In this case, a state in the system is the tuple (h, l) which
represents the arguments to the function underflow, i.e. the
formal parameters h and ppos; observations are the return
values of this function. The generated driver can automat-
ically ﬁnd the low part of a state which triggers such sub-
sequent information leaks, because the analysis instructs the
model checker to ﬁnd any possible execution path satisfy-
ing the assumptions and assertions on the outputs, given
nondeterministic high values and ﬁxed low inputs. As SAT-
based model checking is precise down to the individual bit,
it will ﬁnd a low input which triggers the underﬂow and
uncovers the leak.
CBMC generates a counterexample falsifying a policy of
e.g. no leakage and thereby having triggered the integer
underﬂow. The following excerpt of the counterexample
State 14 file underflow.c line 40 function main
----------------------------------------------------
underflow::main::1::l=1706688912 (00000000...
....
State 35 file underflow.c line 13 function underflow
----------------------------------------------------
underflow::underflow::1::nbytes=4027596816 (11110000...
shows that a low input of l=1706688912 lead to an nbytes
which underﬂowed from the previous value 20.
Clearly, for such leaks to be detected it needs bit-level pre-
cise reasoning, just like SAT-based bounded model checkers
support.
4.2 Environment
In model checking, the environment, like library function
calls or generally functions and data structures which have
no implementation, need to be modelled in a way which al-
lows for the property to be veriﬁed. Out of the box, CBMC
replaces function calls with no implementation with non-
deterministic values.
As our analysis needs to check for equality on inputs and
outputs of functions a certain number of common library
functions have to be modelled in a way which preserves their
original semantics. For example, the usual library C func-
tions memcmp, and strcmp are implemented in a way which
return 0 if their arguments are equal and a value not equal
to 0 if they are not equal. The functions memset and memcpy
actually set an array of integers or characters to a certain
value or to the content of another array. The same applies
to linux kernel utility functions such as copy_to_user and
copy_from_user which copy memory blocks to or from user-
space.
For example, a memcmp implementation is shown in Pro-
gram 3.
int memcmp(char *s1, char *s2, unsigned int n) {
int i;
for(i=0;i log2(N ) means that more than log2(N ) bits leaked,
the policy N has been violated; equally, ≤ log2(N )
i.e.
means the policy N has been veriﬁed. These two cases cor-
respond to lower and upper bounds on the leakage.
5.1 Linux Kernel
We deﬁne information leakage in the kernel always as parts
of the kernel memory which gets mistakenly copied to user
space, i.e. the virtual memory allocated to conventional ap-
plications. Clearly, this should not happen as anything al-
located in the kernel space is not meant to be seen by users
(except within the bounds of normal user/kernel interac-
tions), especially in multi-user systems like Linux. Thus, in
all examples the kernel memory is modelled as nondetermin-
istic values.
The interface between user and kernel space are system
calls or syscalls in short. Syscalls, like normal functions,
have a number of arguments and a return value where the
kernel can transfer data structures or single values back and
forth. This is the crucial point in the system where inform-
ation leakage is most common.
AppleTalk. The speciﬁc vulnerability CVE-2009-3002
in the appletalk network code shows a quite common cause
of information leakage: a user requests, by a syscall, that a
structure gets ﬁlled with values and returned to user land.
The developer however forgot to assign values to all ﬁelds in
the struct, thus these missing ﬁelds get “ﬁlled” with unspe-
ciﬁed kernel memory, as it is allocated on the stack. This
CVE security bulletin actually comprises six diﬀerent vul-
nerable network protocol implementations, all following the
same leakage pattern. We will only present the aﬀected code
of the AppleTalk implementation – the same kind of analysis
applies to all six vulnerabilities.
In this case the structure returned to the user is shown
in Program 4. The leaking function is atalk_getname in
struct sockaddr_at {
u_char sat_len, sat_family, sat_port;
struct at_addr
union {
sat_addr;
struct netrange r_netrange;
char
r_zero[8];
} sat_range;
};
#define sat_zero sat_range.r_zero
Program 4: Complex observation struct leads to leak from
sat_zero.
net/appletalk/ddp.c is shown in Program 5.
In the function, the structure sat gets ﬁlled with values
provided by the kernel, at the end the whole structure is
copied via memcpy to the address of the uaddr pointer, which
is indirectly, via the syscall getsockname copied back to user
land. However, the ﬁeld sat.sat_zero has not been initial-
ised, thus a number of bytes of kernel memory get copied
back to the user.
The secret is implicitly modelled by allocating the sat
structure with nondeterministic values; observations are also
Description
CVE Bulletin
LOC
AppleTalk
tcf ﬁll node
sigaltstack
cpuset†
CVE-2009-3002
CVE-2009-3612
CVE-2009-2847
CVE-2007-2875
SRP getpass
login unix
–
–
237
146
199
63
93
128
k(cid:63)
64
64
128
64
8
8
Patch Proof
log2(N )
Time
(cid:88)
(cid:88)
(cid:88)
×
(cid:88)
–
>6 bit
>6 bit
>7 bit
>6 bit
≤1 bit
≤2 bit
1h39m
3m34s
49m50s
1m32s
0.128s
8.364s
Table 1: Experimental Results. (cid:63) Number of unwindings † From Section 4.1
int atalk_getname(struct socket *sock,
struct sockaddr *uaddr, int *uaddr_len, int peer) {
struct sockaddr_at sat;
// Official Patch. Comment out to trigger leak
//memset(&sat.sat_zero, 0, sizeof(sat.sat_zero));
.
.
. // sat structure gets filled