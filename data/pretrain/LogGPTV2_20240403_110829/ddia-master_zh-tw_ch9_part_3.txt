* 在客户端 A 从资料库收到响应之前，客户端 B 的读取返回 `1` ，表示写入值 `1` 已成功。这也是可以的：这并不意味著在写之前读到了值，这只是意味著从资料库到客户端 A 的正确响应在网路中略有延迟。
* 此模型不假设有任何事务隔离：另一个客户端可能随时更改值。例如，C 首先读取到 `1` ，然后读取到 `2` ，因为两次读取之间的值被 B 所更改。可以使用原子 **比较并设定（cas）** 操作来检查该值是否未被另一客户端同时更改：B 和 C 的 **cas** 请求成功，但是 D 的 **cas** 请求失败（在资料库处理它时，`x` 的值不再是 `0` ）。
* 客户 B 的最后一次读取（阴影条柱中）不是线性一致的。该操作与 C 的 **cas** 写操作并发（它将 `x` 从 `2` 更新为 `4` ）。在没有其他请求的情况下，B 的读取返回 `2` 是可以的。然而，在 B 的读取开始之前，客户端 A 已经读取了新的值 `4`  ，因此不允许 B 读取比 A 更旧的值。再次，与 [图 9-1](../img/fig9-1.png) 中的 Alice 和 Bob 的情况相同。
  这就是线性一致性背后的直觉。正式的定义【6】更准确地描述了它。透过记录所有请求和响应的时序，并检查它们是否可以排列成有效的顺序，以测试一个系统的行为是否线性一致性是可能的（尽管在计算上是昂贵的）【11】。
> ### 线性一致性与可序列化
>
> **线性一致性** 容易和 [**可序列化**](ch7.md#可序列化) 相混淆，因为两个词似乎都是类似 “可以按顺序排列” 的东西。但它们是两种完全不同的保证，区分两者非常重要：
>
> ***可序列化***
>
> **可序列化（Serializability）** 是事务的隔离属性，每个事务可以读写多个物件（行，文件，记录）—— 请参阅 “[单物件和多物件操作](ch7.md#单物件和多物件操作)”。它确保事务的行为，与它们按照 **某种** 顺序依次执行的结果相同（每个事务在下一个事务开始之前执行完成）。这种执行顺序可以与事务实际执行的顺序不同。【12】。
>
> ***线性一致性***
>
> **线性一致性（Linearizability）** 是读取和写入暂存器（单个物件）的 **新鲜度保证**。它不会将操作组合为事务，因此它也不会阻止写入偏差等问题（请参阅 “[写入偏差和幻读](ch7.md#写入偏差与幻读)”），除非采取其他措施（例如 [物化冲突](ch7.md#物化冲突)）。
>
> 一个数据库可以提供可序列化和线性一致性，这种组合被称为严格的可序列化或 **强的单副本可序列化（strong-1SR）**【4,13】。基于两阶段锁定的可序列化实现（请参阅 “[两阶段锁定](ch7.md#两阶段锁定)” 一节）或 **真的序列执行**（请参阅 “[真的序列执行](ch7.md#真的序列执行)”一节）通常是线性一致性的。
>
> 但是，可序列化的快照隔离（请参阅 “[可序列化快照隔离](ch7.md#可序列化快照隔离)”）不是线性一致性的：按照设计，它从一致的快照中进行读取，以避免读者和写者之间的锁竞争。一致性快照的要点就在于 **它不会包括该快照之后的写入**，因此从快照读取不是线性一致性的。
### 依赖线性一致性
线性一致性在什么情况下有用？观看体育比赛的最后得分可能是一个轻率的例子：滞后了几秒钟的结果不太可能在这种情况下造成任何真正的伤害。然而对于少数领域，线性一致性是系统正确工作的一个重要条件。
#### 锁定和领导选举
一个使用单主复制的系统，需要确保领导者真的只有一个，而不是几个（脑裂）。一种选择领导者的方法是使用锁：每个节点在启动时尝试获取锁，成功者成为领导者【14】。不管这个锁是如何实现的，它必须是线性一致的：所有节点必须就哪个节点拥有锁达成一致，否则就没用了。
诸如 Apache ZooKeeper 【15】和 etcd 【16】之类的协调服务通常用于实现分散式锁和领导者选举。它们使用一致性演算法，以容错的方式实现线性一致的操作（在本章后面的 “[容错共识](#容错共识)” 中讨论此类演算法）[^iii]。还有许多微妙的细节来正确地实现锁和领导者选举（例如，请参阅 “[领导者和锁](ch8.md#领导者和锁)” 中的防护问题），而像 Apache Curator 【17】这样的库则透过在 ZooKeeper 之上提供更高级别的配方来提供帮助。但是，线性一致性储存服务是这些协调任务的基础。
[^iii]: 严格地说，ZooKeeper 和 etcd 提供线性一致性的写操作，但读取可能是陈旧的，因为预设情况下，它们可以由任何一个副本提供服务。你可以选择请求线性一致性读取：etcd 称之为 **法定人数读取（quorum read）**【16】，而在 ZooKeeper 中，你需要在读取之前呼叫 `sync()`【15】。请参阅 “[使用全序广播实现线性一致的储存](#使用全序广播实现线性一致的储存)”。
分散式锁也在一些分散式资料库（如 Oracle Real Application Clusters（RAC）【18】）中有更细粒度级别的使用。RAC 对每个磁碟页面使用一个锁，多个节点共享对同一个磁碟储存系统的访问许可权。由于这些线性一致的锁处于事务执行的关键路径上，RAC 部署通常具有用于资料库节点之间通讯的专用丛集互连网路。
#### 约束和唯一性保证
唯一性约束在资料库中很常见：例如，使用者名称或电子邮件地址必须唯一标识一个使用者，而在档案储存服务中，不能有两个具有相同路径和档名的档案。如果要在写入资料时强制执行此约束（例如，如果两个人试图同时建立一个具有相同名称的使用者或档案，其中一个将返回一个错误），则需要线性一致性。
这种情况实际上类似于一个锁：当一个使用者注册你的服务时，可以认为他们获得了所选使用者名称的 “锁”。该操作与原子性的比较与设定（CAS）非常相似：将使用者名称赋予宣告它的使用者，前提是使用者名称尚未被使用。
如果想要确保银行账户余额永远不会为负数，或者不会出售比仓库里的库存更多的物品，或者两个人不会都预定了航班或剧院里同一时间的同一个位置。这些约束条件都要求所有节点都同意一个最新的值（账户余额，库存水平，座位占用率）。
在实际应用中，宽松地处理这些限制有时是可以接受的（例如，如果航班超额预订，你可以将客户转移到不同的航班并为其提供补偿）。在这种情况下，可能不需要线性一致性，我们将在 “[及时性与完整性](ch12.md#及时性与完整性)” 中讨论这种宽松的约束。
然而，一个硬性的唯一性约束（关系型资料库中常见的那种）需要线性一致性。其他型别的约束，如外来键或属性约束，可以不需要线性一致性【19】。
#### 跨通道的时序依赖
注意 [图 9-1](../img/fig9-1.png) 中的一个细节：如果 Alice 没有惊呼得分，Bob 就不会知道他的查询结果是陈旧的。他会在几秒钟之后再次重新整理页面，并最终看到最后的分数。由于系统中存在额外的通道（Alice 的声音传到了 Bob 的耳朵中），线性一致性的违背才被注意到。
计算机系统也会出现类似的情况。例如，假设有一个网站，使用者可以上传照片，一个后台程序会调整照片大小，降低解析度以加快下载速度（缩图）。该系统的架构和资料流如 [图 9-5](../img/fig9-5.png) 所示。
影象缩放器需要明确的指令来执行尺寸缩放作业，指令是 Web 伺服器透过讯息伫列传送的（请参阅 [第十一章](ch11.md)）。Web 伺服器不会将整个照片放在伫列中，因为大多数讯息代理都是针对较短的讯息而设计的，而一张照片的空间占用可能达到几兆位元组。取而代之的是，首先将照片写入档案储存服务，写入完成后再将给缩放器的指令放入讯息伫列。
![](../img/fig9-5.png)