EAX	
RET	
0xf000f000	
rsp+16	
   *(cfa-­‐16)	
*(cfa-­‐8)	
0xf000f001	
rsp+16	
   *(cfa-­‐16)	
*(cfa-­‐8)	
0xf000f002	
   rbp+16	
   *(cfa-­‐16)	
eax=edi	
   *(cfa-­‐8)	
…	
…	
…	
…	
…	
…	
0xf000f00a	
   rbp+16	
   *(cfa-­‐16)	
   *(cfa-­‐24)	
   eax=edi	
   *(cfa-­‐8)	
Dwarf	
  Expressions	
• 
To	
  not	
  an'cipate	
  all	
  unwinding	
  mechanisms	
  of	
  a	
  system,	
  the	
  standard	
deﬁnes	
  ﬂexibility:	
–  DW_CFA_expression	
  R	
  EXPRESSION	
  R	
  receives	
  the	
  value	
  from	
  the	
  EXPRESSION	
  result	
–  DW_CFA_val_expression	
  R	
  EXPRESSION	
  R	
  restored	
  to	
  result	
  of	
  EXPRESSION	
• 
Expressions	
  have	
  their	
  own	
  instruc'ons:	
–  Constant	
  Values:	
  DW_OP_constu,	
  DW_OP_const8s,	
  etc	
–  Arithme'c:	
  DW	
  OP	
  plus,	
  DW	
  OP	
  mul,	
  DW_OP_and,	
  DW_OP_xor,	
  etc	
–  Memory	
  read:	
  DW_OP_deref	
–  Register	
  read:	
  DW_OP_bregx	
–  Flow	
  Control:	
  DW_OP_le,	
  DW_OP_skip,	
  DW_OP_bra,	
  etc	
Katana	
Emit	
  a	
  dwarfscript	
Ø  $e=load	
  "demo"	
Loaded	
  ELF	
  "demo"	
Ø  dwarfscript	
  emit	
  ".eh_frame"	
  $e	
  "demo.dws"	
Wrote	
  dwarfscript	
  to	
  demo.dws	
Dwarfscript	
  assembler	
Ø  $ehframe=dwarfscript	
  compile	
  "demo.dws"	
Ø  replace	
  sec'on	
  $e	
  ".eh_frame"	
  $ehframe[0]	
Replaced	
  sec'on	
  ".eh_frame"	
Ø  save	
  $e	
  "demo_rebuilt"	
Saved	
  ELF	
  object	
  to	
  "demo_rebuilt"	
Ø  !chmod	
  +x	
  demo_rebuilt	
So	
  what?	
•  With	
  Katana	
  you	
  can	
  see	
  and	
  modify	
  unwind	
tables	
  in	
  an	
  easy	
  way	
– Control	
  the	
  unwinding	
  ﬂow	
  (how	
  the	
  call	
  stack	
  is	
handled)	
– Avoid	
  an	
  excep'on	
  handler	
  to	
  execute	
  another	
one	
– Redirect	
  excep'ons	
– Find/solve	
  symbols	
– Calculate	
  reloca'ons	
Example	
•  If	
  func'on	
  foo	
  is	
  responsible	
  for	
  an	
  excep'on	
–  Change	
  ﬂow	
  to	
  func'on	
  bar	
–  Thru	
  sta'c	
  analysis,	
  we	
  see	
  that	
  bar	
  is	
  at	
  0x600DF00D	
–  In	
  the	
  FDE,	
  we	
  change:	
DW_CFA_oﬀset	
  r16	
  1	
–  To:	
DW_CFA_val_expression	
  r16	
begin	
  EXPRESSION	
DW_OP_constu	
  0x600DF00D	
dnd	
  EXPRESSION	
.gcc_except_table	
•  So	
  far,	
  redirected	
  only	
  to	
  ‘catch’	
  blocks	
•  The	
  .gcc_except_table	
  hold	
  language-­‐speciﬁc	
data	
  (where	
  the	
  excep'on	
  handlers	
  are)	
– Interpreted	
  by	
  the	
  personality	
  rou'nes	
– We	
  can	
  stop	
  an	
  excep'on	
  at	
  any	
  'me	
– Unlike	
  the	
  .eh_frame,	
  do	
  not	
  have	
  standards	
– There	
  is	
  no	
  documenta'on,	
  so	
  let’s	
  see	
  the	
  code	
  ;)	
Assembly	
• 
While compiling a program using GCC, do: 
--save-temps –fverbose-asm –dA  
 .section .gcc_except_table,"a",@progbits  
 .align 4 
 .LLSDA963:  
 .byte 0xff # @LPStart format (omit) 
 .byte 0x3 # @TType format (udata4) 
 .uleb128.LLSDATT963−.LLSDATTD963 # @TType base offset  
.LLSDATTD963: 
 .byte 0x1 # call−site format (uleb128) 
 .uleb128 .LLSDACSE963−.LLSDACSB963 # Call−site table length  
.LLSDACSB963: 
 .uleb128 .LEHB0−.LFB963 # region 0 start .uleb128 .LEHE0−.LEHB0 # 
length .uleb128 .L6−.LFB963 # landing pad .uleb128 0x1 # action 
 .uleb128 .LEHB1−.LFB963 # region 1 start .uleb128 .LEHE1−.LEHB1 # 
length .uleb128 0x0 # landing pad 
 .uleb128 0x0 # action 
 .uleb128 .LEHB2−.LFB963 # region 2 start .uleb128 .LEHE2−.LEHB2 # 
length .uleb128 .L7−.LFB963 # landing pad .uleb128 0x0 # action  
.LLSDACSE963: 
 .byte 0x1 # Action record table .byte 0x0 
 .align 4 
 .long _ZTIi  
Layout	
Excep'on	
  Handling	
  Flow	
Excep'ons	
  are	
  not	
  asynchronous	
•  Func'ons	
  that	
  call	
  throw()	
  just	
  call:	
– __cxa_allocate_excep'on()	
  -­‐>	
  To	
  allocate	
  space	
using	
  malloc	
  (or	
  buﬀers	
  in	
  the	
  .bss	
  if	
  malloc	
  fails	
  –	
gcc-­‐xxx/libstd++v3/libsupc++/eh_alloc.:84)	
– And	
  then	
  __cxa_throw()	
  -­‐>	
  That	
  will	
  go	
  thru	
  the	
frames	
  un'l	
  a	
  handler	
  for	
  the	
  excep'on	
  is	
  found	
Proving	
  (assembly)	
Dump	
  of	
  assembler	
  code	
  for	
  func'on	
  main:	
  ...	
  :	
  mov	
  $0x4,%edi	
  #	
  std::size_t	
  thrown_size	
  #	
  Allocates	
  a	
  new	
  "__cxa_refcounted_excep'on"	
  followed	
  by	
  4	
bytes;	
  we	
  #	
  do	
  a	
  "throw(1)",	
  1	
  being	
  an	
  "int"	
  occupies	
  4	
  bytes.	
  :	
  callq	
  0x400930	
  ...	
  :	
  mov	
  $0x0,%edx	
  #	
  void	
  (*dest)	
  (void	
  *)	
  :	
  mov	
  $0x6013c0,%esi	
  #	
  std::type_info	
  *'nfo	
  :	
  mov	
  %rax,%rdi	
  #	
  void	
  *obj	
  :	
  callq	
  0x400940	
__cxa_allocate_excep'on()	
•  Returns	
  a	
  pointer	
  to	
  a	
– struct	
  __cxa_refcounted_excep'on,	
  which	
  helds	
  a	
reference	
  to	
  an	
  object	
  __cxa_excep'on	
•  __cxa_throw()	
  is	
  then	
  executed	
  to:	
– Ini'alize	
  the	
  current	
  context	
  (register	
  values)	
– Iterate	
  in	
  the	
  stack	
  un'l	
  it	
  ﬁnds	
  the	
  excep'on	
handler	
What	
  We've	
  Shown	
  Before	
•  Ret-­‐into-­‐libc	
•  Used	
  the	
  dynamic-­‐linker	
  already	
  in	
  Dwarf	
  to	
  ﬁnd	
execvpe	
•  Used	
  Dwarf	
  to	
  prepare	
  the	
  stack	
•  In	
  less	
  than	
  200	
  bytes	
  and	
  less	
  than	
  20	
  words	
  in	
the	
  stack	
  (showing	
  that	
  a	
  64-­‐stack	
  word	
limita'on	
  is	
  not	
  an	
  obstacle)	
•  Started	
  in	
  an	
  oﬀset	
  of	
  execvpe	
  where	
  they	
  can	
control	
  the	
  Dwarf	
  registers	
  (and	
  not	
  in	
  the	
func'on	
  beginning)	
What	
  else	
  can	
  be	
  done?	
•  Old	
  GCC	
  had	
  both,	
  the	
  .eh_frame	
  and	
the	
  .gcc_except_table	
  as	
  +W	
•  Well…	
–  Libgcc/libstdc++	
  need	
  to	
  ﬁnd	
  those	
  areas	
  in	
  memory,	
right?	
–  The	
  program	
  header,	
  GNU_EH_FRAME	
  contains	
the	
  .eh_frame	
  loca'on	
  (dl_iterate_phdr	
  is	
  the	
func'on	
  that	
  ﬁnds	
  it)	
–  Libgcc	
  caches	
  the	
  value!	
Fake	
  EH	
•  If	
  we	
  can	
  overwrite	
  the	
  cached	
  value,	
  we	
  are	
able	
  to	
  control	
  the	
  excep'ons	
  and	
  leverage	
everything	
  already	
  explained	
•  Libgcc	
  does	
  not	
  export	
  symbols,	
  so	
  we	
  need	
  to	
ﬁnd	
  an	
  heuris'c/reverse	
  to	
  ﬁnd	
  what	
  to	
overwrite	
Caching	
•  The	
  pointer	
  caching	
  is	
  done	
  in:	
  unwind-­‐dw2-­‐fde-­‐glibc.c:	
#deﬁne	
  FRAME_HDR_CACHE_SIZE	
  8	
...	
sta'c	
  struct	
  frame_hdr_cache_element	
{	
  _Unwind_Ptr	
  pc_low;	
  _Unwind_Ptr	
  pc_high;	
  _Unwind_Ptr	
  load_base;	
  const	
  ElfW(Phdr)	
  *p_eh_frame_hdr;	
  const	
  ElfW(Phdr)	
  *p_dynamic;	
  struct	
  frame_hdr_cache_element	
  *link;	
}	
  frame_hdr_cache[FRAME_HDR_CACHE_SIZE];	
Caching	
• 