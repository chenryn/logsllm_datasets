Moto X (2014)






























N/A1
N/A1
N/A1










Samsung Note 8.0
LG G3







TABLE II: Impact of Android Data Residue Vulnerability in Practice
should coexist on the device. Actually, it is quite common for
developers to submit multiple apps to the appstore. According
to [5] in 2011, the average number of apps submitted per
developer is 6.6 in the Android Market. With the recent auto-
update feature on Android, the exploit likelihood increases.
V. EVALUATION
In this section, we evaluate how the data residue attacks
may potentially affect the real world. To this end, we plan to
evaluate (1) the impact of the attack on real-world apps, (2)
the feasibility for the malicious apps to be uploaded to app
markets, such as GooglePlay, Amazon Appstore and Samsung
Appstore, and (3) how the vendor customization affects the
attack. Since the damage of the mock-location residue and the
Debug setting residue is marginal, we exclude them from our
analysis. Our evaluation results are summarized in Table II. In
the rest of this section, we report the details of our evaluation.
Analysis on Real-world Apps We perform a large-scale
analysis on 2,373 unique apps (top 100 free apps in 27
categories) collected from GooglePlay in March 2015. Our
static analysis is built upon the AndroGuard framework [3]
and consists of two steps. The ﬁrst one is to detect apps
with the usage of Android system services that are vulnerable
to the data residue attacks. This can be done by matching
speciﬁc permission and component declarations from apps’
manifest ﬁles or Android APIs from decompiled source code.
For instance, the declaration of a service component listen-
ing to SpellCheckerService-typed intent action with
BIND_TEXT_SERVICE permission requirement makes this
app a spell checker. The second step is to examine whether
the triggering conditions can be applied to this particular
app. To illustrate, consider the DownloadManager service.
We ﬂag an app as providing the download functionality if
the DownloadManager.enqueue() API is found in its
codebase. However, in order for it to be exploitable, the app
needs to save the downloaded ﬁles in the default directory. As a
result, we further excluded apps with APIs that can customize
the download directory.
The ﬁnal results in Table II(I) indicate that numerous
Android apps can be affected by the data residue vulnera-
bility. As each app comes with millions of downloads, the
damage is quite signiﬁcant. Among these apps, 131 apps
act as authenticators and 63 apps use Android Keystore,
so if they are uninstalled from the device, user’s creden-
tials can be stolen by adversaries. Another attack with se-
vere damages is the capability intruding attack via Android
Clipboard. This attack requires the target app to contain a
content provider with the grantUriPermissions ﬂag
set
to true. In our analysis, 92 apps satisfy this require-
ment, and can be the victim of the data residue attacks.
The data that can be leaked are quite sensitive, including
ﬁles in the cloud (OneDrive, Box, Dropbox Photos),
ﬁnancial statements (Chase, Walmart, Progressive),
social information (Tango, Contacts+), etc. Moreover, the
settings impersonating attack affects 40 apps, including 16
spell checkers and 24 dream providers; the history peeking
attack affects 66 apps, including 17 apps due to the download
feature and 49 apps due to the printing feature.
Assessment on App-store Defense
A closer look at all
the data residue instances reveals that, Android’s existing
protection implicitly depends on the uniqueness of several
attributes. We map out the essential attributes for successful
attacks in Table II(II). Our experiments have demonstrated the
possibility to break the uniqueness on the device. However, it
is unclear whether the uniqueness is preserved when apps are
uploaded to app markets. Because the defense of app markets
can only check the static information in the apk ﬁle, attributes
that are dynamically determined during the installation (e.g.
UID) are beyond its control. Therefore, we focus on these three
attributes: account type of authenticator, authority of content
provider, and package name of app.
Our assessment results indicate that, none of the appstores
perform uniqueness checks on account type or authority. To be
more speciﬁc, we are able to detect existing authenticators with
the same account type, and upload apps to all three appstores
with duplicated authority names. At the same time, we have
observed that individual appstore will preserve the uniqueness
11
of package name. However, the target package name may exist
only in particular appstores, allowing attackers to upload apps
with the same package name to other appstores.
Measurement on Device Customization
As we have
mentioned before, our study is based on the analysis of the
ofﬁcial Android Lollipop codebase, which, however, may be
customized extensively by various vendors to ﬁt their needs. To
measure how the vendor customization affects the data residue
attacks, we repeated 8 attacks on 10 different devices running
different versions of Android. The test results are summarized
in Table II(III).
Not all features are available on every device. For example,
DreamService was ﬁrst introduced in version 4.2.2, while
the printer support was recently added in KitKat. Moreover,
some vendors remove certain features from their devices. For
example,
the spell checker feature is removed from most
Samsung devices. Because of these reasons, there are only
65 valid attack attempts. Among them, 54 (83%) attacks are
successful. For the 11 failed attempts, 10 of them are caused
by the ﬁxes introduced in Lollipop (regarding the Download
and Keystore residues). Actually, the exploits on download
residue still have the chance to succeed on devices running
Android 5.0.0 and above, but only if the device is set up
for multiple users. As a result, we do not consider them as
successful attempts. The only case not caused by these ﬁxes is
the Clipboard exploit on Samsung Note 8. The customization
on this device reduces the power of URI permissions, which
results in security exceptions during our attacks.
VI. DISCUSSION
Data residue in the Android system is a challenging and
unique problem to solve. To see why it is unique, let us
compare with the traditional desktop environment. First, the
data residue problem is created when a user is deleted from
a system. In the traditional environment, deleting users is not
very frequent, but in Android, each app acts as a different user,
so app uninstallation basically involves deleting an existing
user; such user-deletion occurs much more frequently than
in the traditional computing environment. Second, in mobile
systems, apps work in a much more collaborative manner than
those in the traditional systems. Namely, mobile apps depend
on other apps to fulﬁll some of the functionalities, such as
spell check and authentication, instead of implementing those
functionalities all by themselves. Android provides many sys-
tem services to facilitate such a collaboration, which inevitably
leads to app data (i.e. user data) being stored outside the app’s
storage space.
The high frequency of “user” deletion and the wide spread-
ing of “user” data across the system make data cleanup a
very challenging task during app uninstallation. Therefore,
data residue is more likely to occur in Android (and other
mobile systems) than in the traditional systems. It is imperative
that the design of system services should explicitly address
the data residue problem. The design should clearly specify
whether there is a potential data residue, whether app’s data
are removed when their owner apps are uninstalled, and if not,
what security consequence might occur if the data are inherited
by other apps.
Android has addressed the data residue concern in the
design of some of the system services. For instance, the recent
Android version, Lollipop, has ﬁxed the residue problem inside
the Download and Keystore services. However, without a
systematic study on all residue instances in the system and
their fundamental causes, the solutions are ad hoc and only
work for individual cases. For example, while the above two
instances are ﬁxed, a new data residue problem has been
created with the introduction of TrustAgent service. A
generic solution should be based on a thorough understanding
of the problem. Our research made the ﬁrst attempt towards a
systematic understanding of the data residue problem in the
Android system. Clearly, signiﬁcant additional efforts need
to be made to solve the problem completely. We hope that
the research community can build upon our understanding,
and develop effective solutions. In the following part of this
section, we present some of our thoughts towards this goal.
Fundamental Causes
There are two conditions for data
residue to become vulnerabilities: the existence of data residue
and ﬁnding ways to exploit it. Therefore, if we can remove
any of the conditions, the problem is ﬁxed. To avoid leaving
data residue requires better software engineering practice,
guidelines, development support, and detection tools. This is
one direction to pursue in research. Another direction is to
identify what can prevent data residue, even if they exist in the
system, from being exploited. Android has made reasonable
efforts in protecting those data in system services, because it
needs to ensure that an app can only access its own data. The
protection can be generalized as attribute-based access control,
i.e., Android associates each data entry with a corresponding
attribute, and then allows the access by the apps that possess
the attribute. This access control implicitly assumes that these
attributes are unique to individual apps; otherwise, multiple
apps can access the same data. Unfortunately, although the
attributes in this assumption seem to be unique in the system,
there is no guarantee by Android. For example, uninstallation
and device reboot can invalidate the assumptions, leading to
the re-association of some attributes to a different app. We
have already presented the essential attributes used by Android
in Table II(II). Here we further summarize their underlying
assumptions, protection effectiveness, and breaking conditions
in Table III.
Built upon Linux kernel, Android extensively utilizes the
UID at the framework level for access control and policy en-
forcement. The underlying assumption is that two apps cannot
possess the same UID at any time. This is true in individual
device cycle, i.e., Android does not reuse an app’s UID after it
is uninstalled, but the assumption does not hold across device
cycles. It is possible for a newly installed app to possess a
previous app’s UID value after device reboots. For package
names, Android ensures that apps with the same package name
cannot be installed on the same device at the same time, except
for the multi-user scenario. However, this does not prevent a
newly installed app to use the same package name as the one
that was already uninstalled. Android also uses component-
based attributes to protect app data. App usually consists
of multiple components, which are labeled with component
names. For components that provide speciﬁc functionalities,
such as authentication and structured data storage, Android
introduces customized attributes to uniquely identify each of
12
Layers
Framework
Application
Component
Attributes
UID
package
Assumptions
UID exclusion
package exclusion
Protection Effectiveness Breaking Conditions
individual device cycle
individual device state
account type
authority
customized-id exclusion
customized-id exclusion
Invalid
individual device state
device rebooting
(un)installation
(un)installation
(un)installation
TABLE III: Security Examination of Android Attributes Used in Protecting Data Residue
them. Unfortunately, the underlying assumptions are either
invalid from the very beginning or only effective at speciﬁc
conditions.
Defense
Based on the above analysis on the fundamental
causes of the data residue problem in Android, defense can
be implemented in two places: frontend and backend. The
frontend protection aims at preventing unauthorized access to
the data still left in the system after its owner app is uninstalled.
To achieve this goal, the uniqueness of all essential attributes
should be preserved across device states and cycles. Such a
property requires a record of all the attribute values from the
installed apps. When there is an attribute conﬂict between a
newly installed app and an uninstalled app, the user will be
presented with an alert and be asked to approve or disapprove.
The frontend protection serves as a signature-based preventive
system, and its effectiveness relies on the completeness of the
signature database. In the data residue case, each signature
refers to individual attribute associated with the data. We have
explored this idea based on all attributes uncovered in our
research, and we are able to defeat all exploits presented in this
paper. More importantly, our research urges system architects
to carefully select attributes used in restricting the access to
sensitive data.
The backend protection aims at eliminating all data residue
in system designs. As the ﬁrst to bring the awareness of the
data residue problem to the public, our manual analysis on
Android system services may miss sophisticated data residue
instances. On one hand, the existing static and dynamic anal-
ysis tools on Android mostly stay at the app level and do not
ﬁt our needs for examining the framework-level code. On the
other hand, some data residue instances can only be triggered
under certain orders of conditions, making the automatic
detection more challenging. Moreover, all data residue in-
stances uncovered in our research are based on Android AOSP
codebase. Although section V shows that vendor customization
is mostly based on Android AOSP codebase, and naturally
inherits all defects in handling app uninstallation, it remains
unclear whether the heavy customization from various vendors
at different levels [53], [58] can make the data residue problem
worse. Thus, our study intends to provide the baseline of the
data residue problem in the Android ecosystem. We expect
that a more accurate and comprehensive automatic detection
system will be explored by both the academia and the industry
in the near future.
VII. RELATED WORK
The popularity of Android has attracted lots of interests
from researchers. The main research focus falls on under-
standing the security landscape of the Android ecosystem,
uncovering vulnerabilities in Android apps and system, and
enhancing the security architecture of Android. In this section,
we review the related prior studies from these three directions
and compare them with our work.
Android Security Demystiﬁcation The Android ecosystem