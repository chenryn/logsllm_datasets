### 0.16秒，仅2,310次探测
在部署SafeHidden的情况下，所有探测均在成功前被捕获。图6(b)显示了被捕捉前的探测次数分布情况。该分布集中在[50, 300]范围内，远低于第二次实验中的数值。造成这种情况的原因有两点：1）其他线程的本地安全区域成为了当前线程的屏蔽区域，增加了探测被捕捉的概率；2）每次探测后所有安全区域都会随机化，从而迅速增加陷阱区域的数量。

在第四次实验中，我们使用基于[46]的工具Revanc [54]模拟了一种针对页表的缓存侧信道攻击。此工具分配一个内存缓冲区，并反复测量该缓冲区内不同页面的访问时间，以推断该缓冲区的基地址。为了利用这种攻击方法针对IH（假设为某种保护机制），我们通过修改源代码强制对该内存缓冲区的所有访问都通过%gs寄存器的偏移量进行，从而将该内存缓冲区保持在一个安全区域内。当未部署SafeHidden时，攻击能够获得正确的缓冲区基地址；而一旦部署了SafeHidden，攻击就会失败。

### 6.2 性能评估
我们分别从CPU计算、网络I/O和磁盘I/O三个方面评估了SafeHidden对应用程序性能的影响。对于CPU计算实验，我们运行了SPEC CPU2006基准测试（采用ref输入）和多线程Parsec-2.1基准测试（使用原生输入并配置8个线程）。在网络I/O实验中，我们选择了Apache Web服务器httpd-2.4.38和Nginx-1.14.2 Web服务器。Apache被配置为mpm-worker模式，在一个工作进程中运行8个线程。Nginx则配置为使用4个工作进程。在磁盘I/O实验中，我们选用了Bonnie++（版本1.03e）作为基准测试工具。对于每个基准测试，我们都准备了两个版本：(1) 由SS保护；(2) 由OCFI保护。我们评估了使用SS和OCFI防护措施保护这些基准测试的性能开销以及部署SafeHidden以增强SS和OCFI防护措施所带来的额外开销。

#### 6.2.1 CPU密集型性能评估
图7展示了OCFI和SS防御措施的性能开销，以及应用SafeHidden来增强OCFI和SS防御措施时的性能开销。对于SPEC基准测试，可以看到OCFI和SS导致的几何平均性能开销分别为4.94%和5.79%。对于Parsec基准测试，OCFI和SS导致的几何平均性能开销分别为7.23%和6.24%。一些应用程序（如perlbench、povray、Xalancbmk和blacksholes）的开销较高，因为这些应用程序频繁执行直接函数调用和间接控制转移指令，触发对安全区域的访问。需要注意的是，这些开销是由安全区域访问引起的。

表3列出了当应用SafeHidden来增强SS和OCFI防御措施以保护SPEC CPU2006和Parsec-2.1基准测试时的统计信息。

| 程序 | #randomization | OCFI | SS | #brk() | #mmap() | #tlb miss |
| --- | --- | --- | --- | --- | --- | --- |
| bzip2 | 3,260 | 150,550 | 757 | 192 | 435,637 | 685,788 |
| gcc | 108 | 108 | 287 | 11,884 | 60 | 474 |
| bwaves | 10,062 | 53,113 | 168,463 | 168,463 | 168,463 | 168,463 |
| ... | ... | ... | ... | ... | ... | ... |

（注：表格数据仅为示例，实际数据请参考完整报告）

通过以上实验结果可以看出，尽管引入了额外的安全机制，但整体性能开销仍处于可接受范围内，且显著提升了系统的安全性。