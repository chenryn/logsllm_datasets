different focus. Indeed, the Sonatype developers have concentrating on major underlying infrastructure
changes around, among other areas, Maven integration, the dependency injection framework and the
plugin architecture.
1.5. Should I Use Jenkins or Hudson?
So should you use Jenkins or Hudson? Since this is a book on Jenkins, here are a few reasons why you
might want to opt for Jenkins:
• Jenkins is the new Hudson. In fact, Jenkins is simply the old Hudson with a new name, so if you
liked Hudson, you’ll like Jenkins! Jenkins uses the Hudson code base, and the development team
and project philosophy remain the same. In a nutshell, the original developers, who wrote the vast
majority of the Hudson core, simply resumed business as usual after the fork working on the Jenkins
project.
• The Jenkins community. Like many of the more successful Open Source projects, much of
Hudson’s strength came from its large and dynamic community, and its massive adoption. Bugs
are identified (and generally fixed) much more rapidly, and, if you have a problem, chances are
someone else will have had it too! If you run into trouble, post a question on the mailing list or
IRC channel—there’s sure to be someone who can help.
• The fast development pace. Jenkins continues the rapid release cycles that typified Hudson, which
many developers love. New features, new plugins and bug fixes come out weekly, and the turn-
around time for bug fixes can be very short indeed. And, if you prefer more stability, there are
always the LTS releases
And, in the interest of balance, here are some reasons you might prefer to stick with Hudson:
• If it ain’t broke, don’t fix it. You already have a Hudson installation that you are happy with, and
don’t feel the need to upgrade to the latest version.
• Enterprise integration and Sonatype tools. Hudson is likely to place a strong emphasis on
integration with enterprise tools such as LDAP/Active Directory, and the Sonatype products such
4
as Maven 3, Nexus and M2Ecipse, whereas Jenkins is more open to other competing tools such
as Artifactory and Gradle.
• Plugin architecture. If you intend to write your own Jenkins/Hudson plugins, you should be aware
that Sonatype is working on providing JSR-330 dependency injection for Hudson plugins. New
developers may find this approach easier to use, though it does raise issues about future plugin
compatibility between Jenkins and Hudson.
The good news is, no matter whether you are using Jenkins or Hudson, the products remain very similar,
and the vast majority of techniques and tips discussed in this book will apply equally well to both.
Indeed, to illustrate this point, many screenshots in this book refer to Hudson rather than Jenkins.
1.6. Introducing Continuous Integration into Your
Organization
Continuous Integration is not an all-or-nothing affair. In fact, introducing CI into an organization takes
you on a path that progresses through several distinct phases. Each of these phases involves incremental
improvements to the technical infrastructure as well as, perhaps more importantly, improvements in the
practices and culture of the development team itself. In the following paragraphs, I have tried to paint
an approximate picture of each phase.
1.6.1. Phase 1—No Build Server
Initially, the team has no central build server of any kind. Software is built manually on a developer’s
machine, though it may use an Ant script or similar to do so. Source code may be stored in a central
source code repository, but developers do not necessarily commit their changes on a regular basis. Some
time before a release is scheduled, a developer manually integrates the changes, a process which is
generally associated with pain and suffering.
1.6.2. Phase 2—Nightly Builds
In this phase, the team has a build server, and automated builds are scheduled on a regular (typically
nightly) basis. This build simply compiles the code, as there are no reliable or repeatable unit tests.
Indeed, automated tests, if they are written, are not a mandatory part of the build process, and may well
not run correctly at all. However developers now commit their changes regularly, at least at the end of
every day. If a developer commits code changes that conflict with another developer’s work, the build
server alerts the team via email the following morning. Nevertheless, the team still tends to use the build
server for information purposes only—they feel little obligation to fix a broken build immediately, and
builds may stay broken on the build server for some time.
1.6.3. Phase 3—Nightly Builds and Basic Automated Tests
The team is now starting to take Continuous Integration and automated testing more seriously. The build
server is configured to kick off a build whenever new code is committed to the version control system,
5
and team members are able to easily see what changes in the source code triggered a particular build,
and what issues these changes address. In addition, the build script compiles the application and runs
a set of automated unit and/or integration tests. In addition to email, the build server also alerts team
members of integration issues using more proactive channels such as Instant Messaging. Broken builds
are now generally fixed quickly.
1.6.4. Phase 4—Enter the Metrics
Automated code quality and code coverage metrics are now run to help evaluate the quality of the code
base and (to some extent, at least) the relevance and effectiveness of the tests. The code quality build also
automatically generates API documentation for the application. All this helps teams keep the quality
of the code base high, alerting team members if good testing practices are slipping. The team has also
set up a “build radiator,” a dashboard view of the project status that is displayed on a prominent screen
visible to all team members.
1.6.5. Phase 5—Getting More Serious About Testing
The benefits of Continuous Integration are closely related to solid testing practices. Now, practices
like Test-Driven Development are more widely practiced, resulting in a growing confidence in the
results of the automated builds. The application is no longer simply compiled and tested, but if the tests
pass, it is automatically deployed to an application server for more comprehensive end-to-end tests and
performance tests.
1.6.6. Phase 6—Automated Acceptance Tests and More Automated
Deployment
Acceptance-Test Driven Development is practiced, guiding development efforts and providing high-
level reporting on the state of the project. These automated tests use Behavior-Driven Development
and Acceptance-Test Driven Development tools to act as communication and documentation tools
and documentation as much as testing tools, publishing reports on test results in business terms that
non-developers can understand. Since these high-level tests are automated at an early stage in the
development process, they also provide a clear idea of what features have been implemented, and which
remain to be done. The application is automatically deployed into test environments for testing by the QA
team either as changes are committed, or on a nightly basis; a version can be deployed (or “promoted”)
to UAT and possibly production environments using a manually-triggered build when testers consider it
ready. The team is also capable of using the build server to back out a release, rolling back to a previous
release, if something goes horribly wrong.
1.6.7. Phase 7—Continuous Deployment
Confidence in the automated unit, integration and acceptance tests is now such that teams can apply the
automated deployment techniques developed in the previous phase to push out new changes directly
into production.
6
The progression between levels here is of course somewhat approximate, and may not always match
real-world situations. For example, you may well introduce automated web tests before integrating code
quality and code coverage reporting. However, it should give a general idea of how implementing a
Continuous Integration strategy in a real world organization generally works.
1.7. Where to Now?
Throughout the remainder of this book, as we study the various features Jenkins has to offer, as well
as the practices required to make the most of these features, we will see how we can progress through
each of these levels with Jenkins. And remember, most of the examples used in the book are available
online (see http://www.wakaleo.com/books/jenkins-the-definitive-guide for more details), so you can
get your hands dirty too!
7
Chapter 2. Your First Steps with
Jenkins
2.1. Introduction
In this chapter, we are going to take a quick guided tour through some of Jenkins’s key features. You’ll
get to see first-hand just how easy it is to install Jenkins and set up your first Jenkins automated build
job. We won’t dwell on the details too much—there are more details to come in the following chapters,
as well as a detailed chapter on Jenkins Administration at the end of the book (Chapter 13, Maintaining
Jenkins). This chapter is just an introduction. Still, by the end of the chapter, you will also be keeping
tabs on test results, generating javadoc and publishing code coverage reports! We’ve got a lot of ground
to cover, so let’s get started!
2.2. Preparing Your Environment
There are two ways you can tackle this chapter. You can read through it without touching a keyboard,
just to get an overview of what Jenkins is about. Or you can get your hands dirty, and follow along on
your own machine.
If you do want to follow along at home, you may need to set up some software on your local machine.
Remember, the most basic function of any Continuous Integration tool is to monitor source code in
a version control system and to fetch and build the latest version of your source code whenever any
changes are committed. So you’ll need a version control system. In our case, we’ll be using Git1. The
central source code repository for our simple project is stored on GitHub2. Don’t worry about messing
up this repository with your own changes, though: you’ll be creating your own fork of the repository
that you can use as you wish. If you haven’t used Git and/or don’t have an account on GitHub yet,
don’t worry, we’ll walk through the basics, and the whole installation process is well documented on
the GitHub website. We’ll explain how to set it all up in great detail further on.
In this chapter, we’ll be using Jenkins to build a Java application using Maven. Maven is a widely-used
build tool in the Java world, with many powerful features such as declarative dependency management,
convention over configuration, and a large range of plugins. For our build, we will also be using recent
versions of the Java Development Kit (JDK) and Maven, but if you don’t have these installed on your
machine, don’t fret! As we will see, Jenkins will install them for you.
1 http://git-scm.com
2 https://github.com
2.2.1. Installing Java
The first thing you will need to install on your machine is Java. Jenkins is a Java web application, so
you will need at least the Java Runtime Environment, or JRE to run it. For the examples in this chapter,
you will need a recent version of Java 6 (these examples were written with Java 6 update 17, and the
latest release at the time of writing was Java 6 update 19). If you are not sure, you can check this from
the command line (by opening a DOS console on Windows), and running java -version. If Java is
installed on your machine should get something like this:
$ java -version
java version "1.6.0_17"
Java(TM) SE Runtime Environment (build 1.6.0_17-b04-248-10M3025)
Java HotSpot(TM) 64-Bit Server VM (build 14.3-b01-101, mixed mode)
If you don’t have a version already installed, or if your version is an older one, download and install the
latest JRE installer from the Java website3, as shown in Figure 2.1, “Installing Java”.
Figure 2.1. Installing Java
3 http://java.sun.com/javase/downloads/index.jsp
10
2.2.2. Installing Git
Since we will be using Git, you will need to install and configure Git on your machine. If you are new
to Git, you might want to run through the basics on the Git Reference website4. And if you get lost, the
whole process is well documented on the GitHub help pages5.
First of all, you need to install Git on your machine. This involves downloading the appropriate installer
for your operating system from the Git website6. There are packaged installers for both Windows and
Mac OS X. If you are using Linux, you are in Git’s home ground: most Linux distributions. On Ubuntu
or some other Debian-based distribution, you could run something like:
$ sudo apt-get install git-core
On Fedora or another RPM-based distribution, you could use yum instead:
$ sudo yum install git-core
And, being Linux, you also have the option of installing the application from source. There are
instructions on how to do this on the Git website.
Once you are done, check that Git is installed and available by invoking it from the command line:
$ git --version
git version 1.7.1
2.2.3. Setting Up a GitHub Account
Next, if you don’t already have one, you will need to create a GitHub account. This is easy and (for our
purposes, at least) free of charge, and all the cool kids have one. Go to the GitHub signup page7 and
choose the “Create a free account” option. You will just need to provide a username, a password, and
your email address (see Figure 2.2, “Signing up for a GitHub account”).
4 http://gitref.org
5 http://help.github.com
6 http://git-scm.com
7 https://github.com/plans
11
Figure 2.2. Signing up for a GitHub account
2.2.4. Configuring SSH Keys
GitHub uses SSH keys to establish a secure connection between your computer and the GitHub servers.
Setting these up is not hard, but involves a bit of work: fortunately there are clear and detailed instructions
for each operating system on the GitHub website8.
2.2.5. Forking the Sample Repository
As we mentioned earlier, all the sample code for this book is stored on GitHub, at the following URL:
https://github.com/wakaleo/game-of-life. This is a public repository, so you can freely view the source
code online and check out your own working copy. However, if you want to make changes, you will
need to create your own fork. A fork is a personal copy of a repository that you can use as you wish.
To create a fork, login to your GitHub account and navigate to the repository URL9. Then click on the
Fork button (see Figure 2.3, “Forking the sample code repository”). This will create your own personal
copy of the repository.
Once you have forked the repository, you should clone a local copy to make sure everything is set up
correctly. Go to the command line and run the following command (replacing  with your
own GitHub username):
8 http://help.github.com/set-up-git-redirect
9 https://github.com/wakaleo/game-of-life
12
$ git clone PI:EMAIL:/game-of-life.git
This will “clone” (or check out, in Subversion terms) a copy of the project onto your local drive:
git clone PI:EMAIL:john-smart/game-of-life.git
Initialized empty Git repository in /Users/johnsmart/.../game-of-life/.git/
remote: Counting objects: 1783, done.
remote: Compressing objects: 100% (589/589), done.
remote: Total 1783 (delta 1116), reused 1783 (delta 1116)
Receiving objects: 100% (1783/1783), 14.83 MiB | 119 KiB/s, done.
Resolving deltas: 100% (1116/1116), done.
You should now have a local copy of the project that you can build and execute. We will be using this
project later on to trigger changes in the repository.
Figure 2.3. Forking the sample code repository
13
2.3. Starting Up Jenkins
There are several ways to run Jenkins on your machine. One of the easiest ways to run Jenkins for the
first time is to use Java Web Start. Java Web Start is a technology that lets you start up a Java application
on your local machine via a URL on a web page—it comes bundled with the Java JRE. In our case,
this will start a Jenkins server running on your machine, and let you experiment with it as if it were
installed locally. All you need for this to work is a recent (Java 6 or later) version of the Java Runtime
Environment (JRE), which we installed in the previous section.
For convenience, there is a link to the Jenkins Java Web Start instance on the book resources page10.
Here you will find a large orange Launch button in the Book Resources section (see Figure 2.4, “Running
Jenkins using Java Web Start from the book’s website”). You can also find this link on the Meet Jenkins
page on the Jenkins website11, where, if you scroll down far enough, you should find a Test Drive section
with an identical Launch button.
Figure 2.4. Running Jenkins using Java Web Start from the book’s website
10 http://www.wakaleo.com/books/jenkins-the-definitive-guide
11 http://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins
14
Java Web Start seems to work best on Firefox. When you click on the Launch button on either of these
sites in Firefox, the browser will ask if you want to open a file called jenkins.jnlp using Java Web
Start. Click on OK—this will download Jenkins and start it up on your machine (see Figure 2.5, “Java
Web Start will download and run the latest version of Jenkins”).
Figure 2.5. Java Web Start will download and run the latest version of Jenkins
In other browsers, clicking on this button may simply download the JNLP file. In Internet Explorer, you
may even need to right click on the link and select “Save Target As” to save the JNLP file, and then run
it from Windows Explorer. However, in both of these cases, when you open the JNLP file, Java Web
Start will download and start Jenkins.
Java Web Start will only need to download a particular version of Jenkins once. From then on, when
you click on the “Launch” button again, Java Web Start will use the copy of Jenkins it has already
downloaded (that is, until the next version comes out). Ignore any messages your operating system or
anti-virus software may bring up—it is perfectly safe to run Jenkins on your local machine.
Once it has finished downloading, it will start up Jenkins on your machine. You will be able to see it
running in a small window called “Jenkins Console” (see Figure 2.6, “Java Web Start running Jenkins”).
To stop Jenkins at any time, just close this window.
Figure 2.6. Java Web Start running Jenkins
15
There are also installers available for the principal operating systems available on the Jenkins website12.
Or, if you are an experienced Java user versed in the ways of WAR files, you may prefer to simply
download the latest version of Jenkins and run it from the command line. Jenkins comes in the form of
an executable WAR file—you can download the most recent version from the Jenkins website home
page13. For convenience, there is also a link to the latest version of Jenkins in the Resources section
of this book’s website14.
Once downloaded, you can start Jenkins from the command line as shown here:
$ java -jar jenkins.war
Whether you have started Jenkins using Java Web Start or from the command line, Jenkins should now
be running on your local machine. By default, Jenkins will be running on port 8080, so you can access
Jenkins in your web browser on http://localhost:8080.
Alternatively, if you are familiar with Java application servers such as Tomcat, you can simply deploy
the Jenkins WAR file to your application server—with Tomcat, for example, you could simply place the
jenkins.war file in Tomcat’s webapps directory. If you are running Jenkins on an application server,
the URL that you use to access Jenkins will be slightly different. On a default Tomcat installation, for
example, you can access Jenkins in your web browser on http://localhost:8080/jenkins.