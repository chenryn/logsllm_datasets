for each of  the categories presented in Section 3 and their 
corresponding 95%  confidence intervals are  given  in  the 
table together with the observed number of  errors (#). The 
results  show  that  most  of  the  undetected  wrong  results 
caused  by  bit-flips  in  the CPU were  minor value  failures 
having  no  or  minor  impact  on  the  controlled  object 
(4.48%  of  all  faults  injected).  However,  0.54%  of  the 
faults injected had  severe impact on the controlled  object 
to 
(severe  undetected  wrong  results)  corresponding 
10.73% of  all the value failures produced. 
The results also show that faults injected into the data 
cache of Thor produced a higher percentage of  undetected 
wrong  results  (6.06%)  than  faults  injected  into  the 
registers  (0.91 %).  A  detailed  investigation  revealed  that 
most  of  the  severe undetected  wrong results were caused 
by  faults  injected  into  the  cache  lines  where  the  global 
variable  x  representing  the  state,  see  Algorithm  I,  is 
stored.  Since  x  represents  the  state,  any  errors  in  x  will 
propagate to the next  iteration of the algorithm and cause 
a permanent  or  semi-permanent  value failure,  see Figure 
7 and 8. 
4.1.2. Non-effective  errors. The  non-effective errors are 
errors,  which  could  not  be  identified  as  either  Detected 
errors  or  Undetected  wrong  results. 
These  errors  are 
classified  into  latent  or  overwritten 
errors: 
the 
after 
Latent  errors: The  fault  injection 
experiments  where  differences 
between  the  correct  system  state 
logged 
reference 
execution  and  the  system  state 
logged  after  the  fault  injection 
experiment  terminated  could  be 
observed,  but  which  could  not  be 
identified as either Detected errors 
or Undetected wrong results. 
Overwritten  errors:  The 
fault 
injection  experiments  for  which 
no  difference  between  the  correct 
the 
system  state 
reference 
the 
system state  logged after the  fault 
injection  experiment 
terminated 
could be observed. 
logged  after 
and 
execution 
I 
Part of CPU fault injected 
(no. of state elements) 
~ y p e  of Errors and Wrong Result! 
atent trmts 
Ovemritten Enors 
Total (Non Effective Errors) 
Address  Ermr 
Data Enor 
Instruction Ermr 
Jump Error 
Constraint Check 
Access Check 
Storage Ermr 
m o w  
Illegal Operation 
Control Flow Errors 
Other Errws 
Undetected Wmng Results (Sebere) 
Undetected Wrong Results (Minor) 
Total (Effective Errors) 
Total (Faults Injected) 
Total (Undetected Wrong Results) 
Coverage 
353 
Tat 
? 2.  Results for Algorithm 1. 
Cache 
(1824) 
1 
o) 
72.28% f +  1.02% )  5358  19.98% ( f  1.81%  )  375  61.71% ( * 0.99%  )  5733 
72,33%(f  1,02%) 5362  79,97%(i 1 3 1 %  ) 15011  73,88%( i 0,8996  ) 68631 
Regislers 
(426) 
Total 
I 
I 
I 
16.84% ( f 0.85% 
0.00% ( f 0,00% 
1.50% ( i 0.28% 
0.07% ( +  0.06% 
0.01% ( i  0,03% 
0.01 %  ( f 0.03% 
0.13%  ( i  0.08% 
0.00% ( *   0.00% 
2.29% ( i  0.34% 
0,71% (t 0.19% 
0.01% (f 0.03% 
0.66% ( f  0.18% 
5.40% ( *  0.51% 
27,67% ( t 1.02% 
W,W% 
1248 
0 
111 
5 
1 
1 
10 
0 
170 
53 
1 
49 
400 
2051 
6,06%(t 0,54%)  449 
9334% ( t O,W% ) 
4.37% ( *  0.92% 
0.37% ( i  0.28% 
2.08% ( * 0.65% 
0.05% ( i  0.10% 
0.00%  ( f 0.00% 
0.27% ( f 0.23% 
9.80% ( i  1,35% 
0,11% (f 0,15% 
0.80% ( i  0.40% 
1.07% ( f 0.46% 
0.32% ( i  0.26% 
0.05% ( f 0.10% 
0.85% (i 0.42% 
20,03%(t  1,81% 
82 
7 
39 
1 
0 
5 
184 
2 
15 
20 
6 
1 
16 
376 
0.06% ( * 0,05%  ) 
0.71%  )  1330 
14.32% ( 
0.08% (  f 0,06% ) 
7 
1.61% (  i 0.26%  )  150 
6 
0.06% (  f 0.05%  ) 
0.01% (  f 0.02%  ) 
1 
6 
2.09% (  -t  0.29%  )  194 
0,02% (  i 0.03%  ) 
2 
0.79%( * 0.18%  ) 
1.99% (  t 0.28%  )  185 
73 
0.08%  (  +  0,06% ) 
7 
0.54% (  i 0.15%  ) 
50 
4.48% (  i 0,42% )  416 
26,12%( f 0,89% ) 2427 
7413 100,00% 
I 
94.09% ( * 0.43% ) 
0,91%(i 043%)  17 
1877  100.00% 
92901 
5.020/.( i 0,44%)  466 
94.98%(  f 0,449: ) 
I 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:07:27 UTC from IEEE Xplore.  Restrictions apply. 
4.3. Adding executable assertions and best effort 
recovery 
in 
The results for Algorithm I show that errors in the state 
variables  stored  in  the  data  cache  caused  severe  value 
failures.  One  way  to  avoid  single  bit-flips  affecting  the 
sensitive  data  stored  in  the  cache  is  to  use  a  parity 
protected cache.  Since parity protected  caches may not be 
available 
(COTS) 
microprocessors  and  the  cost  for  using  custom-designed 
microprocessors  with  parity  protected  caches  may  be 
unacceptable,  a cost-effective  software-based  solution  for 
reducing the amount of  severe value  failures is presented. 
The solution is based on protecting the state variables  and 
output  signals  with  executable  assertions  and  best  effort 
recovery mechanisms. 
off-the-shelf 
commercial 
Three  approaches  where  adopted to  make  the  control 
algorithm  more  robust  with  respect  to  severe  value 
failures: 
iteration  of 
The  state  variable  and  output  were  protected  by 
executable  assertionsâ€™  to  detect  errors  using  the 
physical  constraints  of  the  controlled  object.  The 
constraints  used  in  this  study  are  based  on  the 
physical  limitations  of  the engine throttle. Assertions 
are  made  on  the  state  variable  x  and  the  limited 
just  before  a  back-up  of  the 
output  signal  u-lint 
variables is made, thereby  reducing the probability of 
error propagation. 
When an  incorrect  state is detected  by  an executable 
assertion  during  one 
the  control 
algorithm,  a  recovery  is  made  by  using  the  state 
backed-up  during 
the 
calculations  instead.  Note  that  this  is  not  a  true 
recovery,  since the  input  to the controller may differ 
from  the  input  used  in  the  previous  iteration.  This 
may  result  in the output  being  slightly different  from 
the  fault-free  output,  thus  creating  a  minor  value 
failure. We therefore call this a best effort recovery. 
When  an 
is  detected  by  an 
executable  assertion,  recovery  is made  by  delivering 
the output produced in  the previous  iteration instead. 
The  state  variable  is  also  set  to  the  state  of  the 
previous  iteration  that  corresponds  to  the  delivered 
output.  This  approach  is  also  a  best  effort  recovery 
since the effects on the output  will be similar to those 
of approach 2. 
incorrect  output 
the  previous 
iteration 
in 
Changes from the original Algorithm I  are in bold: 
x  :  float 
%-old,  u-old  : f l o a t  
function PI-Controller(r, y  :  float) 
Kp, T  :  constant  float  --  constants 
e, U .  U-lim:  float 
--  state of the controller 
--  two back-up states 
begin 
e = r - y  
i f   not  in-range(x) 
else 
x =  x-old 
x-old  =  x 
else 
Ki  =  0.0 
Ki  =  integral-gain 
end if 
x =  x +  T *  e *  Ki 
i f   not  in-range(u-lim) 
u-lim  =  u-old 
x =  x-old 
end  i f  
u p l d  =  U-lim 
return u-lim 
end 
end if 
U  =  e *  Kp +  x 
U-lim  =  limit-output(u)  --  range check of U 
if anti-windup-activated  then 
--  controller variables 
--  calculate control error 
-- x  out of limits? 
-- ERROR! recover state x 
--  save state x 
--  calculate output  signal 
-- disable integration 
--  enable integration 
--  integrate, update x 
--  U - l i m   out of limits? 
--  ERROR!  get last output 
--  and corresponding state 
--  save output 
Algorithm II.  The PI controller algorithm 
with executable assertions and best effort 
recovery mechanisms. 
A  general  approach  for  making  a  control  algorithm 
with  an  arbitrary  number  of  states  variables  and  an 
arbitrary  number  of  output  signals  more  robust  can  be 
summarized as: 
Before  making  a  back-up  of  any  statexfk), 0  < i  < 
totalNrOfStates, an  assertion  is  made  validating  the 
correctness of x,(k). If  an erroneous value is detected, 
then  a  best  effort  recovery  is  made  by  executing 
x , ( k )  = At(k  -  I),  0 < i  < totalNrOfStates, otherwise 
the state is backed-up  by  executing x,(k -  1) = x,(k), 0 
< i < totalNrOfStates. 
Before  returning  the  output  results,  u,(k), 0  < j  < 
totalNrOfOutputs, an  assertion  is made validating  the 
correctness of  u,(k), 0 < J  < totalNrOfOutputs. If  an 
incorrect  output  result  is  detected,  a  best  effort 
recovery  is made  by  executing u,(k) = u,(k  -  I),  0 < j  
<  totalNrOfOutputs and  x,(k) = x,(k  -  I),  0  < i  < 
totalNrOfStates . 
Back-up 
u,fk -  1)  = u,(k), 0 < j < totalNrOfOutputs. 
Return 
totalNrOf0utpirts. 
signals  u,(k),  0  <  j  < 
the  output 
executing 
signals 
output 
the 
by 
4.4. Results for Algorithm I1 