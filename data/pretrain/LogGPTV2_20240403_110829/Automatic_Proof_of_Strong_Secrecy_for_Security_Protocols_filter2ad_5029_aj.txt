that (cid:11)(cid:2)(cid:0) (cid:0) (cid:9)(cid:0), considering elements of (cid:16)(cid:17)(cid:8) as vari-
ables.
(cid:0)(cid:4) (cid:8) (cid:8) (cid:8) (cid:4) (cid:0)
(cid:0)(cid:4) (cid:8) (cid:8) (cid:8) (cid:4) (cid:0)
We can also extend this to the case in which the se-
crets can take values among bound names. That is, we
prove (cid:15)(cid:16)(cid:0) (cid:8) (cid:8) (cid:8) (cid:15)(cid:16)(cid:10)(cid:1) (cid:9) (cid:15)(cid:16)(cid:0) (cid:8) (cid:8) (cid:8) (cid:15)(cid:16)(cid:10)(cid:0)(cid:1), so that
(cid:16)(cid:0)(cid:4) (cid:8) (cid:8) (cid:8) (cid:4) (cid:16) may occur in the image of (cid:10) and (cid:10)(cid:0). We proceed
as for proving (cid:10)(cid:1) (cid:9) (cid:10)(cid:0)(cid:1), except that the adversary does
not have (cid:16)(cid:0)(cid:4) (cid:8) (cid:8) (cid:8) (cid:4) (cid:16): the clause (cid:0)(cid:16)(cid:0)(cid:9) (cid:10) for (cid:2) (cid:0) (cid:1)(cid:11)(cid:4) (cid:8) (cid:8) (cid:8) (cid:4) (cid:2)
is removed.
Treatment of Equations We have extended our technique to
the case when cryptographic primitives are deﬁned by equa-
tions. For example, Difﬁe-Hellman key agreements can be
modeled using two constructors (cid:0) and (cid:18), with the equa-
tion (cid:0) (cid:7)(cid:4) (cid:18)(cid:19) (cid:8) (cid:0) (cid:19)(cid:4) (cid:18)(cid:7) [5]. We encode equations
with destructors, as in [15]. For instance, the previous equa-
tion can be modeled by having a destructor (cid:0) deﬁned by
(cid:0) (cid:7)(cid:4) (cid:18)(cid:19) (cid:11) (cid:0) (cid:0)(cid:19)(cid:4) (cid:18)(cid:7) and (cid:0) (cid:7)(cid:4) (cid:19) (cid:11) (cid:0) (cid:7)(cid:4) (cid:19). This en-
coding is sound for strong secrecy. (This technique is lim-
ited to rather simple equations; more complex ones could
be handled by uniﬁcation modulo the equational theory.)
7. Experimental Results
The veriﬁer shows automatically that the protocol of
Section 2 preserves the strong secrecy of (cid:7). As further small
examples, we can consider variants of this protocol. If we
add a Message 2’: (cid:20) (cid:11) (cid:21) : (cid:1)(cid:7)(cid:0)(cid:2)(cid:4), the veriﬁer ﬁnds an at-
tack against strong secrecy of (cid:7) and (cid:7)(cid:0). Precisely, it ﬁnds
that (cid:3)(cid:0)(cid:4) is derivable, and the derivation of (cid:3)(cid:0)(cid:4) describes
an attack, which may in general be a false attack because
of our approximations. In this example, it is a real attack.
Indeed, an attacker can test whether (cid:7) (cid:8) (cid:7)(cid:0) by compar-
ing the ciphertexts (cid:1)(cid:7)(cid:2)(cid:4) and (cid:1)(cid:7)(cid:0)(cid:2)(cid:4). In contrast, if we re-
place shared-key encryption with probabilistic shared-key
encryption, the veriﬁer now shows that the protocol pre-
serves the strong secrecy of (cid:7) and (cid:7)(cid:0). If we replace Mes-
sages 2 and 2’ with (cid:1)(cid:22)(cid:1)(cid:4) (cid:7)(cid:2)(cid:4) and (cid:1)(cid:22)(cid:0)
(cid:1)(cid:4) (cid:7)(cid:0)(cid:2)(cid:4) respectively,
the veriﬁer shows that the protocol preserves the strong se-
crecy of (cid:7) and (cid:7)(cid:0), both with deterministic and probabilistic
shared-key encryption. Indeed, the ciphertexts are always
different, even when (cid:7) (cid:8) (cid:7)(cid:0).
We have also proved strong secrecy results for the pro-
tocols of Otway-Rees [38], Yahalom [21], and Skeme [32].
The total runtime for these tests is less than 2 s on an In-
tel Xeon 1.7 GHz.
As a more substantial example, we have proved proper-
ties of the JFK protocol [11]. This protocol is a proposed
replacement for IKE, the key exchange protocol of IPsec.
It allows an initiator  to establish a security association
(in particular, a session key) with a responder (cid:3). We have
used the technique described in this paper for proving iden-
tity protection properties of JFK. The protocol has two vari-
ants, JFKi and JFKr, that differ by these properties:
1. JFKi guarantees that an active attacker cannot know
the identity of the initiator (when it accepts connec-
Proceedings of the 2004 IEEE Symposium on Security and Privacy (S&P’04)  
1081-6011/04 $ 20.00 © 2004 IEEE 
tions only with honest principals). Accordingly, we
show the observational equivalence of conﬁgura-
tions in which two initiators (cid:0) and (cid:0) have their secret
keys among (cid:1) (cid:1) and (cid:1) (cid:0) (so their public keys, which
we identify with their identities, among (cid:1) (cid:1) (cid:1)
and (cid:1) (cid:1) (cid:0)). Hence, an adversary cannot distin-
guish a conﬁguration in which an initiator uses (cid:1) (cid:1)
from one in which it uses (cid:1) (cid:0), and it cannot tell
whether two initiators use the same secret key. Tech-
nically, using the extension of Section 6, we show that
(cid:1)(cid:1) (cid:1)(cid:1)(cid:1) (cid:0)(cid:2)(cid:2) (cid:0) (cid:1)(cid:1) (cid:1)(cid:1)(cid:1) (cid:0)(cid:2) (cid:0)(cid:2) where the
process (cid:2) models the protocol, (cid:2) and (cid:2)(cid:0) map the vari-
ables (cid:1) (cid:0) and (cid:1) (cid:1), secret keys of (cid:1) and (cid:0) respec-
tively, to elements of (cid:1)(cid:1) (cid:1)(cid:4) (cid:1) (cid:0)(cid:2).
Importantly, the attacker knows all public keys of
the principals ((cid:1) (cid:1) (cid:1), (cid:1) (cid:1) (cid:0), . . . ), but we show
that it does not know which ones the principals actu-
ally use. Such a property cannot be satisfactorily ap-
proximated by a standard secrecy property.
2. JFKr protects the identity of responders against ac-
tive attacks. Accordingly, we show the observational
equivalence of conﬁgurations in which two responders
(cid:5)(cid:1) and (cid:5)(cid:0) have their secret keys among (cid:1) (cid:1) and (cid:1) (cid:0).
JFKr also protects all identities against passive at-
tacks. So, we show the observational equivalence of
conﬁgurations in which two responders and two initia-
tors can have their secret keys among (cid:1) (cid:1), . . . , (cid:1) (cid:3), and
the attacker can listen but not send messages.
These conﬁgurations of course contain other responders and
initiators, with other keys. For simplicity, for JFKi, all ini-
tiators (resp. for JFKr, all responders) accept connections
only from honest principals. These tests took 2 s for JFKi
and 1 min 30 s for JFKr, on an Intel Xeon 1.7 GHz. The
case study of the JFK protocol has been done in collabora-
tion with Mart´ın Abadi and C´edric Fournet [4].
The veriﬁer is available at http://www.di.ens.fr/
˜blanchet/crypto-eng.html and more information on
the study of the JFK protocol is available at http://www.
di.ens.fr/˜blanchet/crypto/jfk.html.
8. Conclusion
This work provides an efﬁcient, automatic technique for
proving a particular case of observational equivalence for
cryptographic protocols, namely strong secrecy. It is much
more ﬂexible than the rare previous works that already tack-
led this problem, and has already been useful in the study
of real protocols such as JFK.
For future work, it would be interesting to verify more
general classes of process equivalences, since they can be
used to formalize a wide variety of security properties. This
is however a difﬁcult task, especially when the equivalent
processes have a different structure.
Proceedings of the 2004 IEEE Symposium on Security and Privacy (S&P’04)  
1081-6011/04 $ 20.00 © 2004 IEEE 
Acknowledgments
We would like to thank Mart´ın Abadi, J´erˆome Feret,
David Monniaux, Andrew Myers, and the anonymous re-
viewers for very helpful comments on this work.
References
[1] M. Abadi. Secrecy by Typing in Security Protocols.
In
Theoretical Aspects of Computer Software, volume 1281 of
LNCS, pages 611–638. Springer, 1997.
[2] M. Abadi.
Security Protocols and their Properties.
In
Foundations of Secure Computation, NATO Science Series,
pages 39–60. IOS Press, 2000. Volume for the 20th Interna-
tional Summer School on Foundations of Secure Computa-
tion, held in Marktoberdorf, Germany (1999).
[3] M. Abadi and B. Blanchet. Analyzing Security Proto-
In 29th
cols with Secrecy Types and Logic Programs.
ACM Symposium on Principles of Programming Languages
(POPL’02), pages 33–44, Jan. 2002.
[4] M. Abadi, B. Blanchet, and C. Fournet. Just Fast Keying in
the Pi Calculus. In Programming Languages and Systems:
13th European Symposium on Programming (ESOP’04),
LNCS. Springer, Mar. 2004.
[5] M. Abadi and C. Fournet. Mobile Values, New Names, and
Secure Communication. In 28th ACM Symposium on Prin-
ciples of Programming Languages (POPL’01), pages 104–
115, Jan. 2001.
[6] M. Abadi and A. D. Gordon. A Bisimulation Method for
Cryptographic Protocols. Nordic Journal of Computing,
5(4):267–303, Winter 1998.
[7] M. Abadi and A. D. Gordon. A Calculus for Cryptographic
Protocols: The Spi Calculus. Information and Computation,
148(1):1–70, Jan. 1999.
[8] M. Abadi and J. J¨urjens. Formal Eavesdropping and its Com-
putational Interpretation. In Theoretical Aspects of Computer
Software (TACS’01), volume 2215 of LNCS, pages 82–94.
Springer, Oct. 2001.
[9] M. Abadi and R. Needham. Prudent Engineering Practice
for Cryptographic Protocols. IEEE Transactions on Software
Engineering, 22(1):6–15, Jan. 1996.
[10] M. Abadi and P. Rogaway. Reconciling two views of cryp-
tography (The computational soundness of formal encryp-