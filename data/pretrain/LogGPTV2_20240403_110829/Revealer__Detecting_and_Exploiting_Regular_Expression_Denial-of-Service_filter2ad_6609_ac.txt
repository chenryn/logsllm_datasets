regular expression:
1) the regular expression applies repetition to a complex
subexpression;
2) for the repeated subexpression, there exists a match, which
is also a suffix of another valid match.
Fig. 2: Loop in Loop vulnerable structure. A dashed curve arrow
denotes a matching path starting with an inclusion transition, and a
solid curve arrow denotes a matching path starting with a connection
transition.
Definition 3 (Loop state). A state v is a loop state if its
maximum allowed match count cmax
Definition 4 (Branch state). A state v is a branch state if v
has more than one outgoing inclusion transition.
v > 1.
We then introduce a theorem that only these two types of
states could lead to the super-linear matching behavior in any
e-NFA. The proof of the theorem is provided in Appendix §A2.
Theorem 1 (States that construct the vulnerable structure). If
an e-NFA has neither loop states nor branch states, then the
e-NFA match process runs in linear time.
Theorem 1 does not suggest that loop states and branch
states can lead to super linear matching time. We will show that
in §IV-C. Knowing that the vulnerable structure could consist
of only loop states and branch states, we analyze how regex
features fall into these two types:
• Loop state: “classical quantifiers ∗ +”, “Greedy quantifiers
{m, n}{n}{m,}”5 and “Lazy quantifiers ?? ∗? +? {}?”6.
• Branch state: “classical branch |” and “Lazy ?”.
“Lazy ?” can be considered as a special case of classical
feature “Branch |”. Greedy quantifiers and lazy quantifiers are
also similar to the ordinary quantifiers ‘*’ and ‘+’ in the
context of ReDoS, because the attack string is crafted to match
toward their maximum repetition limits. Therefore, we can
consider all loop states as classical quantifiers and all branch
states as classical branches, and refer to the complexity theory
of NFA to propose ours.
C. Vulnerable e-NFA Patterns
We define each vulnerable e-NFA pattern as a structure
composed of loop states and/or branch states. The "Loop in
Loop", "Branch in Loop", and "Loop after Loop" vulnerable
e-NFA structures are shown in Figure 2, Figure 3, and Figure 4,
respectively. In these pattern representations, we only remain the
crucial states and simplify the others into subexpressions (e.g.,
Figure 2 represents regexes with the format r0(r1(r2)∗r3)∗r4,
in which ∗ can be replaced by other quantifiers). There is a
special case of “Loop after Loop” vulnerable structure, that is
“Loop in Branch” structure, which has the same polynomial
complexity. We do not provide it here due to page limit.
We provide the proofs of the theorems in Appendix §A3.
Theorem 2 (Loop-in-Loop vulnerable e-NFA pattern). An e-
NFA pattern has exponential worst-case complexity if there
exist two loop states vi and vi+1 that vi+1 can be reached
Inspired by [26], we consider all states in an e-NFA that
possibly meet the above conditions, and categorize them into
the following two categories.
1472
5They instruct the engine to match as many instances of the quantified
subpattern as possible, thus are called greedy quantifiers.
6They instruct the engine to match as few instances of the quantified
subpattern as needed, thus are called lazy quantifiers.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
vi:Loopvi+1:Loopr2r3r1r0r4Fig. 3: Branch in Loop vulnerable structure.
Fig. 4: Loop after Loop vulnerable structure.
via a matching path starting with an inclusion transition from
vi, such that the two subexpressions r1r2r3 and r1r3 have a
common match string.
Theorem 3 (Branch-in-Loop vulnerable e-NFA pattern). An
e-NFA pattern has exponential worst-case complexity if there
exist a loop state vi and a branch state vi+1 that vi+1 can
be reached via a matching path starting with an inclusion
transition from vi, such that the two subexpressions r1r2r4 and
r1r3r4 have a common match string.
Theorem 4 (Loop-after-Loop vulnerable e-NFA pattern). An
e-NFA pattern has polynomial worst-case complexity if there
exist two loop states vi and vi+1 that neither can be reached
via a matching path starting with an inclusion transition from
the other, such that (i) there exists a transition from vi to vi+1
either indirectly through a subexpression r2 or directly (where
r2 = ϵ), and (ii) if r2 = ϵ the two subexpressions r1 and r3
have a common match string, otherwise three subexpressions
r1, r2 and r3 have a common match string.
D. Vulnerable Attack String Patterns
The attack string pattern of vulnerable e-NFA structures
can be represented by s0.sk.s1, where s0, s1 and s are the
prefix, suffix, and attack core, respectively. We can also locate
the vulnerable structure from two special states: 1) prefix tail,
the last state on the prefix matching path; and 2) suffix head,
the first state on the suffix matching path.
The attack string patterns are constructed as follows: 1)
for all three vulnerable e-NFA patterns, s0 is a match string
of r0, and s1 makes s0.sk.s1 fail to match the entire regex;
2) for Loop in Loop patterns, s is a common match string of
subexpressions r1r3 and r1r2r3, vi is both the prefix tail and
the suffix head; 3) for Branch in Loop patterns, s is a common
match string of subexpressions r1r2r4 and r1r3r4, vi is both
the prefix tail and the suffix head; and 4) for Loop after Loop
patterns, s is a common match string of subexpressions r1, r2
and r3, vi is the prefix tail and vi+1 the suffix head.
V. REVEALER
In this section, we present REVEALER, a hybrid system
based on the theory in the last section to detect and exploit
ReDoS vulnerabilities. The workflow of REVEALER is shown
in Figure 5. REVEALER first locates vulnerable e-NFA patterns
with a simplified e-NFA structure called E-TREE in static
analysis (§V-B). It then finds a common match string (i.e.,
the attack core) in its dynamic analysis (§V-C), and generates
the attack prefix and the attack suffix to form an entire attack
string (§V-D). It finally validates whether the attack string can
trigger super-linear matching behavior (§V-E). We next discuss
an overview and the novelty of REVEALER in §V-A. We will
also discuss some of its limitations in §V-F.
A. Overview
As we had introduced in §II, both existing static approaches
and dynamic approaches have their limitations in detecting
ReDoS vulnerabilities in extended regexes. On the one hand,
the existing formalization of static approaches, regardless of
the design details, belongs to context-free grammar, which
prevents them from supporting all extended features that can be
described only by context-sensitive grammars. The difficulty of
adopting a context-sensitive grammar lies in not only developing
corresponding theories for formally modeling the problem
(which we did in §III-A and §IV-C), but also solving the
problem of attack string generation that is NP-hard7. On the
other hand, dynamic approaches can be very inefficient in
finding the attack strings especially for complex patterns, as
most fuzzers use only basic genetic methods for generating
inputs, which are unlikely to trigger the vulnerabilities.
We overcome such limitations by proposing a hybrid
approach. First, we design a static analysis to identify the
vulnerable patterns in an e-NFA representation for support-
ing the context-sensitive grammar. Second, we reduce the
problem of attack string generation to one with a polynomial-
time solution by introducing extra constraints—the maximum
string length and the minimum matching step count—on the
generated attack string. To meet the constraints, we design
a dynamic analysis as the constraint solver to generate the
attack core by simulating the existing matching mechanisms
of extended regexes. By leveraging the regex structures, our
dynamic analysis can directly generate the right attack cores
for exploitation in a more intelligent and efficient manner.
B. Static Analysis
Our static analysis consists of two parts. First, we introduce
E-TREE: our simplified data structure of e-NFA; Next, we
traverse the E-TREE to find a set of vulnerable patterns P ,
in which each pattern p is represented by two e-NFA states
⟨v, w⟩.
1) E-TREE: The Java 8 regex engine parses a regex into an
e-NFA A. E-TREE is a simplified representation of A. It reduces
the complexity of searching certain states from in a graph (the
Java e-NFA Figure 1a) to in a tree (the E-TREE Figure 1b).
Searching the loop/branch states for finding vulnerable patterns
on E-TREE is simpler than on the original Java e-NFA data
structure.
To build an E-TREE, we first remove the state ‘Exit’ and its
corresponding transitions from A, because it does not represent
any regex feature. We keep all the other states in E-TREE. Next,
we determine the transitions in E-TREE.
Existing e-NFA implementation does not differentiate the in-
clusion transitions from the connection transitions, but includes
the logic of selecting a transition inside the transition function
7It is equivalent to regex matching, whose difficulty was proved in [16].
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1473
vi:Loopvi+2:BranchEndr2r4r1r0r5vi+1:Branchr3εvi:Loopvi+1:Loopr1r2r0r3r4Fig. 5: An architecture overview of REVEALER.
δ′
v. In Figure 1a, all transitions are treated equally, making it
hard to determine a traversal order. We extract the transition
types statically in E-TREE. A solid arrow and a dashed arrow
represent a connection transition and an inclusion transition in
Figure 1b, respectively. Most states, except for ‘BranchEnd’
and states after a ‘GroupTail’ and before a ‘GroupHead’, have
only one incoming transition. For the two types of states, we
keep only one incoming transition in E-TREE. ‘BranchEnd’ has
an incoming connection transition from the ‘Branch’ state, and
one from each branch. We remain the one from the ‘Branch’
state and omit the others (e.g., v5 → v6, v8 → v6). The
second-type states have an incoming connection transition from
‘GroupTail’ and an outgoing inclusion transition to ‘GroupHead’.
We remove such transitions from ‘GroupTail’ (e.g., v7 → v2).
2) Vulnerable Structure Detection: We define the E-TREE
traversal algorithm T raverse for finding states related to
is basically a depth-first search.
vulnerable patterns.
From a state v, T raverse first
takes the inclusion tran-
sitions and then the connection transitions to visit other
states. For example, T raverse(v0) visits all states in order
v0, v1, v2, v3, v4, v5, v8, v6, v7, v10, v11.
It
Since all vulnerable patterns start from a loop state, we
collect all loop states into a list L from T raverse(v0). We
then traverse from each state in L and find other loop/branch
states to get a set P of pairs ⟨v, w⟩ where v is a loop state
and w is a loop or branch state. A pair is a “Loop in Loop” or
“Branch in Loop” pattern, if w can be (indirectly) reached by
taking a direct inclusion transition from v (i.e., w represents
a subpattern of that represented by v). Similarly, a pair is a
“Loop after Loop” pattern, if w can be (indirectly) reached
through a direct connection transition from v.
C. Dynamic Analysis
The static analysis finds a set of potential vulnerable patterns
P = {⟨v0, w0⟩,⟨v1, w1⟩, . . .}. The dynamic analysis functions
as a constraint solver, i.e., for each vulnerable pattern p ∈ P ,
it verifies whether the corresponding subexpressions r0, r1, r2
(defined in §IV-C) have a common match string s. For example,
in Figure 1a, there is only one “Branch in Loop” pattern ⟨v2, v4⟩.
Its corresponding subexpressions are: r0 =., r1 =[^"], r2 = ϵ.
In §V-C1, we propose the algorithm SingM atch that
generates a match string s for a matching path τ. The algorithm
is based on the existing matching mechanisms in the e-NFA
A. In §V-C2, we present CommM atch, which generates a
common match string s of several matching paths {τ0, τ1, . . .}.
In §V-C3, we demonstrate how dynamic analysis is performed
on top of the algorithm CommM atch.
1) The Single Match Algorithm: The single match algorithm
SingM atch generates a match string s for a single matching
path τ by progressively building s from sub-match string s′.
We defined in §III-A that a state v may have a corresponding
acceptable string set ASv. The match function δv : (s, p, t) →
(Sv, p′, t′) would search if there exists p′ such that s[p : p′] ∈
ASv. We change the “match” logic into “generation” by starting
with s = ϵ, p = 0, finding a valid match s′ from ASv, extending
s with s′ (i.e., s = s.s′), and then executing the match function
δv. After these operations, δv would match the pre-selected
substring s′ naturally, and p′ would become the length of the
new s. Iteratively, s becomes a match string of the matching
path τ when v successfully reaches the end state.
Take the matching path τ = v2, v3, v4, v8 as an example.
The algorithm follows the transitions along τ until it needs
to generate a match string at state v8. It randomly selects a
symbol as s′ from ASv8, which includes any symbol in the
alphabet Σ except ‘"’. For example, it selects “a” as s and
sets p as 0 in match function δv8, and would cause a successful
match. Since v8 is the last state in τ, the algorithm ends with
a valid match string “a”.
2) The Common Match Algorithm: The CommM atch
algorithm generates a common match string s of several
matching paths. Here we discuss only cases with three match-
ing paths: τ0, τ1, τ2; other cases work similarly. It performs
SingM atch on each matching path simultaneously and syncs
on the substring s′ generated in each step.
∩ ASv′
1
0
∩ ASv′
CommM atch holds a current state vector V , which stores
the current states for all matching paths. It
is initialized
by the first states of all the matching paths: e.g., V0 =
[τ0[0], τ1[0], τ2[0]]. Let v′ represent a possible next state v
can transit to if the algorithm can find a substring s′ ∈ ASv′.
The common s′ is therefore determined by the intersection of
ASv′ for each state v in V . Let V = [v0, v1, v2], the common
acceptable strings ASV would be ASv′
. The
algorithm selects one string s′ from ASV for building the
common match string s. CommM atch terminates with a
failure when ASV = Φ and outputs ϵ. It ends successfully
when s can match all matching paths for at least one repetition.
In our example, r2 = ϵ, so we only need to consider r0 and
r1 and run CommM atch(τ0, τ1, ϵ). The only matching paths
of r0 and r1 are τ0 = [v2, v3, v4, v5] and τ1 = [v2, v3, v4, v8],
respectively. We initialize V0 ← [v2, v2], conduct transitions
on τ0 and τ1 simultaneously, until V = [v4, v4]. The next
common acceptable strings for both matching paths would be:
= {α ∈ Σ|α ̸= ”}. If the algorithm
ASV = ASv′
randomly selects “a” from ASV as the common s′, then s =
“a” would lead to two successful matches. Now that τ0 and
∩ ASv′
2
5
8
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1474
e-NFAregexTreeConstructorE-TREEPotential Vulnerable Structure Detectorpotential vulnerabilityVulnerability ValidatorPrefix GeneratorSuffix Generatorattack coreprefix tailsuffix headattack prefixattack suffixAttack Sting GeneratorAttack Validatorattack stringattack resultsuccessfailINPUTSTATIC ANALYSISDYNAMIC ANALYSISGENERATIONVALIDATIONτ1 both get matched once, the CommM atch algorithm ends
successfully and outputs a common match string “a”.
3) Performing Dynamic Analysis: We present the entire
dynamic analysis in Algorithm 1. It takes the set of possible
vulnerable patterns found in the static analysis as input. For each
pattern, it extracts the matching paths of the three corresponding
subexpressions, and leverages the CommM atch algorithm to
find a common match string. The common match string will
be repeated as the attack core for many times for generating
the attack string in §V-D.
m of the common match string.
However, each subexpression could have numerous match-
ing paths, resulting in numerous path combinations for each
group of three subexpressions. Our analysis may spend much
time on analyzing path combinations (especially those including
long matching paths) that might not lead to DoS. Further, we
need a shorter common match string s because more repetitions
of s lead to (exponentially) more backtrackings. To limit the
search space and find more powerful attack strings, we set a
maximum length l′
We derive l′
m from two thresholds—maximum attack
string length lm and minimum matching step count γ—for
vulnerability validation. We set lm as 128 and γ as 105 as we
will explain in §VI-A. Let l denote the length of the attack
string (l ≤ lm) , and l′ denote the length of the common match
string s (l′ ≤ l′
m). Let n denote the number of repetitions of s
in the attack string, we have n ≤ nm = ⌊ lm
l′ ⌋. The maximum
condition happens when both attack prefix and suffix are ϵ.
We set an, a ∈ N∗ as the maximum matching complexity
a vulnerable pattern can trigger, where a is the number of
choices in each backtracking step. One feature (state) can
match multiple characters, and in general at most three states
(feature start, match, feature ends) are used to match a character.