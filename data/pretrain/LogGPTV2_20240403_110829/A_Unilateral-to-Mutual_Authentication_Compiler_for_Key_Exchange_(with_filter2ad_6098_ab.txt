treplication-security notion as a formal basis for studying
channel binding and related notions. Finally, we point out
that our “functional” approach from Section 6.1 bears re-
semblance to Shoup’s model [34] and to the “suitable for”
notion from [8].
2. THE UA AND MA KE MODELS
This section presents an abridged description of the Canetti-
Krawczyk security model for key-exchange protocols [9, 10]
which serves as the basis for the formal security treatment
in this paper. Please consult [9] for complete details.
2.1 Mutual Authentication (MA) KE Model
We start by presenting the original CK model for mutual
authenticated KE, and then specialize this model to the case
of unilateral authentication. For the purpose of this paper
we will refer to this model as MA (for mutual authentication)
and diﬀerentiate it from the unilateral authentication model
denoted UA.
A key-exchange (KE) protocol is run in a network of in-
terconnected parties (all of which, including adversaries, are
modeled as probabilistic polynomial-time machines) where
each party can be activated to run an instance of the pro-
tocol called a session. Within a session a party can be ac-
tivated to initiate the session or to respond to an incoming
message. As a result of these activations, and according
to the speciﬁcation of the protocol, the party creates and
maintains a session state, generates outgoing messages, and
eventually completes the session by outputting a session key
sk and erasing the session state. A session may not com-
plete (e.g., if authentication fails) in which case it is aborted
without generating a session key (output sk =⊥). A KE
session is associated with its owner (the party at which the
session exists), a peer (the party with which the session key
is intended to be established), and a session identiﬁer, de-
noted sid. A KE protocol deﬁnes the contents of sid, typi-
cally including nonces and other transcript information. We
name sessions by their owner and sid, and if the session peer
is identiﬁed then also by the peer identity. For example,
(S, sid) for a session at party S or (S, C, sid) if the peer to
the session is identiﬁed as C. It is assumed (and enforced
by the protocol) that any two sessions at the same (honest)
party have diﬀerent identiﬁers.
Credentials. We consider the public key setting where
parties possess public keys of their choice and parties can
verify the authentic binding between identities and public
keys, be it either a certiﬁcation authority (CA) or other
means such as out-of-band distribution. We also consider
the “pre-shared key setting” where pairs of parties share a
secret symmetric key that they use for authentication.
The attacker, denoted A, is an ac-
Attacker model.
tive “man-in-the-middle” adversary with full control of the
communication links between parties. A can intercept and
modify messages sent over these links, it can delay or pre-
vent their delivery, inject its own messages, interleave mes-
sages from diﬀerent sessions, etc. (Formally, it is A to whom
parties hand their outgoing messages for delivery.) A also
schedules all session activations and session-message deliv-
ery.
the attacker is allowed access to secret
information via the following attacks:
In addition,
• A Reveal query can be performed against an individ-
ual session after completion and the result is that the
attacker learns the corresponding session key sk.
• A Corrupt against a party means that the attacker
learns the long-term secret of that party; in addition,
from the moment a party is corrupted all its actions
may be controlled by the attacker. Non-corrupted par-
ties are referred to as uncorrupted or honest.
For simplicity, in the current presentation we do not consider
the CK StateReveal query.
Basic security (mutual authentication).
To deﬁne
security, we establish a notion of matching deﬁned via session
identiﬁers. If session (C, S, sid) completes at party C, then
session (S, C, sid), if it exists at S and completes, is said to be
matching to (C, S, sid) (note the correspondence of peers and
equality of sid and that only complete session have matching
sessions).
Sessions against which any one of the attacks Reveal or
Corrupt is performed (including sessions compromised via
party corruption) are called exposed. A session is called fresh
if it is complete and not exposed, and its matching session
(if it exists) is also not exposed.
The security of session keys generated in fresh sessions is
captured via the inability of the attacker A to distinguish
the session key of a test session, chosen by A among all
fresh sessions in the protocol, from a random value. This is
captured via a Test query. This query may only be asked
once during the security game. It sets K0 := sk (or random
if sk =⊥) as the real session key, and sets K1 ←r {0, 1}λ.
Then, it picks b ←r {0, 1} and returns Kb. The attacker
can continue with the regular actions against the protocol
also after the Test query; at the end of its run A outputs a
bit b(cid:48), which is meant as a guess for the value of b.
attackers A running against π it holds:
A key-exchange protocol π is secure if for polynomial-time
1440SIGMAC applied to UA protocol Π1 uses the following components:
• A key derivation function KDF applied to session keys output by Π1 for producing two keys Ka and Ks (this can be as
simple as computing Ka = fK (0) and Ks = fK (1) where f is a PRF, or any other derivation of mutually pseudorandom
values Ka, Ks).
• A signature algorithm and a MAC algorithm (with the usual chosen message security requirements for both).
• A value sid∗ deﬁned for each session in Π1 and consisting of the concatenation of the session id sid and a subset of
transcript information, called a transcript core, speciﬁcally deﬁned for each protocol Π1 (see Section 4).
• Identities and keys for clients: Clients are anonymous in Π1, but in Π2 they have identities and signature keys whose
public keys other parties can obtain and validate. Servers have same identities and keys as in Π1.
MA protocol Π2 is deﬁned identically to Π1 except for the following extension:
• When a client C completes a session (C, S, sid) in Π1 with peer S and outputs a session key K, it performs the following
operations in Π2.
It derives keys Ka and Ks from K using KDF; sends a message, denoted CSM, consisting of a
signature on the value sid∗ and a MAC value, MACKa (C, S), on the identities C and S; it erases Ka and completes
session (C, S, sid) in Π2 with session key Ks.
• When a server S would establish a session (S, sid) with session key K according to Π1, in Π2 it does not complete the
session but computes K and keeps it in the session’s state. When a CSM message (allegedly) from client C is delivered
to a session (S, sid), S checks that a key K was previously computed for this session and if so it derives keys Ka and Ks
form K using KDF. It then checks that the incoming signature is valid (under the public key of C) and that it covers
the appropriate value sid∗ (including the session id sid). Finally, it veriﬁes that the MAC computed with key Ka covers
the client identity C and its own identity S. If all checks succeed, S completes session (S, C, sid) with session key Ks.
Figure 1: The SIGMAC Compiler.
1. If two uncorrupted parties complete matching sessions
in a run of protocol π under attacker A then they out-
put the same key (except for a negligible probability).
2. The probability that A wins the Test experiment, namely,
it outputs a correct guess b = b(cid:48) is at most 1/2 plus a
negligible fraction.2
We note that this model is general enough to capture pro-
tocols with implicit or explicit authentication and with and
without key conﬁrmation (or liveness). This is important
since it makes our results more general, showing that our
compiler applies to a UA protocol with any of the above
characteristics.
A key-exchange protocol is said to achieve perfect forward
secrecy (PFS) if it satisﬁes the above deﬁnition when relaxing
the notion of fresh sessions to allow a Corrupt query against
the owner of the session but only upon completion of the
session.
2.2 Unilateral Authentication (UA) KE Model
The model as described above is intended to capture pro-
tocols where both peers authenticate to each other. Here
we specialize this model to the case of unilateral authenti-
cation (UA), namely, when only one party authenticates to
its peer (but the second party remains “anonymous”). The
treatment is similar to [25].
The unilateral setting is best described by client-server
terminology. We denote by C, S the client-server parties
to the protocol as well as their identities, and refer to the
authenticating party as the server. In the public key setting
servers have public keys and in the case of a server and client
sharing a symmetric key (the pre-shared key setting) we
assume that the client associates the key to a server identity
but not (necessarily) the other way. Sessions at a client are
denoted as triples (C, S, sid) as in the regular MA model but
2We use asymptotic, polynomial-time, terminology through-
out the paper as it simpliﬁes presentation. Moving to a con-
crete security setting is mostly straightforward.
sessions at servers do not have a named peer hence they are
denoted (S, sid).
The essential characteristic of the UA model is that only
(fresh) client sessions are allowed as test sessions.3 Thus,
matching is deﬁned only for client sessions, namely, if session
(C, S, sid) exists and completes, and session (S, sid) exists
and completes then (S, sid) is called a matching session to
(C, S, sid).
3. THE SIGMAC COMPILER
We present our signature-based compiler that we call SIG-
MAC and which augments a UA-secure protocol Π1 into a
MA-secure protocol Π2. Roughly, protocol Π2 is obtained
via the SIGMAC compiler by adding to Π1 a single message
sent from client C to server S upon completion of a session in
Π1, where the message, denoted CSM (for “client sign-and-
mac”), comprises a signature of C and a MAC (with a key
derived from Π1’s session key). The signature is applied to
a value sid∗ deﬁned for Π1 while the MAC is applied on the
identities of C and S. The compiler is presented in Figure 1.
We stress that the value sid∗ plays an essential role in the
security of SIGMAC and its requirements are presented in
detail in Section 4 via the notions of a transcript core and
treplication security. We simplify some of our treatment
by assuming that the session identiﬁers sid in protocol Π1
include unique random nonces contributed by C and S.
Another simpliﬁcation in our treatment is that we assume
that the signature keys used by clients for the SIGMAC
signature are not used for other purposes or as part of pro-
tocol Π1. This limitation is not essential as long as diﬀerent
uses are properly insulated via domain separation or similar
methods.
3Restricting test sessions to client sessions only reﬂects the
fact that there is no requirement on the security of session
keys at a server as these may have the attacker as the uniden-
tiﬁed peer. One could allow to also test server sessions that
have a matching fresh client session, but this would be equiv-
alent to our simpler deﬁnition.
1441More generally, we require that no two sessions at a party
will have the same sid (except for negligible probability);
also, we assume that sid∗ includes a fresh session-speciﬁc
value from S (needed, in particular, against replay attacks).
Note on preserving the session key from Π1. The above spec-
iﬁcation of SIGMAC deﬁnes the keys Ka, Ks used by Π2 as
derived from the session key K output by Π1. Alternatively,
one can specify that Π1 outputs Ka, Ks, where Ks serves as
the session key in both Π1 and Π2 while Ka is only used in
Π2 as a MAC key. We chose the former approach as it allows
us to keep Π1 unmodiﬁed and is somewhat more convenient
in the formal treatment. On the other hand, if one requires
that Π1 and Π2 use the exact same session key, one needs
to accommodate the generation of key Ka already as part
of Π1 (this would be the case in TLS 1.3).
Note on (not) signing the server’s identity.
If one wants
to provide some deniability against a passive adversary as
discussed in the introduction, one should avoid entering the
identity of S into the signature (i.e., into sid∗).
On (hashing) the identities included under SIGMAC’s
MAC. The identities C and S included under the MAC
computation in SIGMAC can have diﬀerent forms, e.g., a
subject name in a public key certiﬁcate, a whole certiﬁcate,
an email address, etc. However, we note that an identity
of a party X can be replaced, for the sake of including it
under the SIGMAC MAC, by H(X) if H is a collision re-
sistant function (this is similar to the use of hash functions
for generating inputs to digital signatures). Moreover, hash-
ing X with additional information is also acceptable as long
as the parsing of the input to the hash function is deﬁned
as to uniquely determine the identity included in the hash.
Such hashing of identities is used in many protocols includ-
ing TLS. As a subtle example, resumption mode of TLS 1.3,
replaces the server’s identity included in the client’s Finished
message (that implements the SIGMAC’s MAC functional-
ity) with a unique value, resumption_context, computed as
a hash of the server’s identity and carried from a prior ex-
change between this client and server. For this to be secure
one has to assume that the function used to compute re-
sumption_context is collision resistant. In the case of TLS
1.3 this function is based on HKDF-Expand which can be
shown to be collision resistant if the underlying hash is col-
lision resistant. We stress that it is imperative in all uses of
hashed identities that the output from the hash function not
be truncated in a way that weakens the collision resistance
property.
3.1 Rationale and examples
As explained in the introduction, the intuition behind
SIGMAC is that the matching of the same client identity
as the signer as well as under the MAC creates the needed
binding between the client and the session key. Adding
the server’s identity to the MAC is needed to prevent UKS
attacks (see below), namely, ensuring the server that the
client’s view of the peer is correct. Alternatively, one can
include the server’s identity under the signature which raises
some privacy issues as discussed earlier.
The actual considerations in analyzing the compiler are
more subtle particularly with respect to what needs to be
covered by the signature. In some cases, even covering the
whole transcript is insuﬃcient to ensure mutual authenti-
cation via SIGMAC while in other cases covering part of
the transcript is enough. We strive to identify the essential
parts of a transcript that need to be signed (this adds to the
generality of the compiler and to our understanding of this
mechanism, and can help achieving some level of deniabil-
ity).
We illustrate some of the subtleties through some impor-