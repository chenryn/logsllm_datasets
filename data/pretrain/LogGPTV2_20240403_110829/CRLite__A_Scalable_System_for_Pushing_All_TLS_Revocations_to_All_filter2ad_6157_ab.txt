that bind identities (i.e., domain names) to cryptographic keys.
These leaf certiﬁcates are cryptographically signed by a CA,
forming a signature chain that may include zero or more
intermediate certiﬁcates, and eventually terminating at a self-
signed root certiﬁcate. Servers present this chain to clients
during the TLS handshake, who must then validate it.
Certiﬁcate Validation.
As mentioned above, clients must
validate certiﬁcates that are presented to them, e.g., by verify-
ing the signatures, looking at the certiﬁcates’ expiration dates,
etc. In this work, we focus on the challenges of checking
for certiﬁcate revocations, but researchers have identiﬁed other
issues related to certiﬁcate validation, such as bugs in popu-
lar TLS libraries [8], in browsers [49], and in non-browser
software [29]. This has motivated researchers to develop
novel certiﬁcate validation schemes that leverage advanced
cryptographic techniques [17].
Certiﬁcate Transparency.
Because any CA can issue a
certiﬁcate for any domain, there are signiﬁcant concerns about
CAs improperly issuing certiﬁcates (e.g., after a private key
compromise [2]). The Certiﬁcate Transparency (CT) project
has created public, auditable, append-only logs of certiﬁcates,
with the idea that all newly issued certiﬁcates will be added
to the log by CAs. Google is encouraging adoption of CT
by CAs through Chrome policies: in January 2015, Chrome
began requiring that new EV certiﬁcates include an SCT
record that is signed by a well-known CT log [43]. In October
2017, Chrome will require all new certiﬁcates to contain SCT
records [66], and Firefox is planning to adopt these policies
as well [54].
Measuring the TLS Ecosystem.
As HTTPS has grown
in importance, many studies have empirically examined as-
pects of the HTTPS ecosystem. Several studies have broadly
investigated certiﬁcates on the web [20], [23], [36] with recent
work demonstrating that IPv4 scans and CT logs are sufﬁcient
to gain broad visibility of valid certiﬁcates [73]. Chung et al.
instead examine the hundreds of millions of invalid certiﬁcates
that linger on the web [15]. Other work has examined the root
certiﬁcates trusted by clients [58], [72] and the costs of HTTPS
security [56]. Lastly, two studies have speciﬁcally examined
the security implications of distributing private keys across
Content Delivery Networks (CDNs) [48], [11].
B. TLS Certiﬁcate Revocation
the owner of a certiﬁcate may request
Revocation is a crucial component of the web’s PKI.
At any time,
that
their CA revoke the certiﬁcate, which produces a pub-
lic, cryptographically-veriﬁable attestation that the certiﬁcate
should no longer be trusted (even if it has not expired). There
are many reasons why a certiﬁcate may be revoked, such as
if it uses a weak key [75], but the most important cases occur
when a private key is (potentially) compromised [76], [19],
or when a certiﬁcate is issued erroneously. In these cases, an
attacker can misuse the compromised certiﬁcate to conduct
MiTM or phishing attacks until it expires. Thus, it is vital that
such certiﬁcates be revoked, and that clients check to see if
certiﬁcates they are offered in the TLS handshake are revoked.
There are two primary protocols for distributing revocations:
CRLs.
A Certiﬁcate Revocation List (CRL) is a list of serial
numbers from revoked certiﬁcates that is signed by a CA.
CAs are responsible for including a URL in each certiﬁcate
they sign that points to the associated CRL. In turn, clients
are responsible for downloading the CRLs associated with
observed certiﬁcates to check if they are revoked. CRLs are
signed by the CA to protect their integrity, and contain a
validity period during which they may be cached (up to a
maximum of 10 days [10]).
OCSP.
The successor to CRL is OCSP. OCSP is a web
service protocol that allows clients to query a CA for the
revocation status of a single certiﬁcate. CAs are responsible
for inserting a URL into each certiﬁcate they sign that points
to the corresponding OCSP responder. Similar to CRLs, OCSP
responses are signed by the CA, and contain a validity period
during which they may be cached.
Recent measurement studies demonstrate that revocation is
prevalent in the web’s PKI [49]. More than 99% of valid
certiﬁcates available on the web contain a reachable CRL
URL, while 95% include a reachable OCSP responder. Liu
et al. observe that 8% of all valid certiﬁcates are revoked (6%
if we focus just on valid EV certiﬁcates) [49], with the bulk
of these revocations occurring due to Heartbleed [76], [19].
541
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:23:56 UTC from IEEE Xplore.  Restrictions apply. 
C. Revocation Checking
Clients are responsible for checking all leaf and intermediate
certiﬁcates they are offered during a TLS handshake for
revocations. This can be done by downloading the certiﬁcates’
CRLs or contacting their OCSP servers, depending on what in-
formation is provided in the certiﬁcates. Alternatively, servers
may push revocation information to the client by “stapling” an
OCSP response to the certiﬁcate via the OCSP Stapling TLS
extension [22], although as of 2015, only 3–5% of certiﬁcates
on the web were served by hosts that supported stapling [49].
Revocation Checking in Practice.
Unfortunately, work
by Liu et al. shows that browsers do an extremely poor
job of checking for revocations [49]. For example, Firefox
no longer supports CRLs, while Chrome only issues online
requests for EV certiﬁcates. Most alarmingly, no major mobile
browsers perform any online revocation checks. As a result,
users may end up as victims of MitM or phishing attacks due
to compromised certiﬁcates.
Browser vendors have chosen not to implement thorough re-
vocation checking for a variety of reasons. First, downloading
CRLs and making OCSP requests adds delay to the establish-
ment of HTTPS connections. CRLs in particular can become
quite large (Apple has a CRL that is over 76 MB! [49]). Sec-
ond, using OCSP has privacy implications for users, because
OCSP requests enable CAs to passively observe the domains
users browse to. Although stapling addresses OCSP’s privacy
problem, stapling is vulnerable to downgrade attacks: an in-
network attacker can strip the staple from a certiﬁcate, which
forces the client to resort to a traditional CRL or OCSP check.
To address stapling downgrade attacks, RFC 7633 deﬁnes
the OCSP “must-staple” extension, which allows a certiﬁcate
to require that the server provide a stapled OCSP response
during the TLS handshake [34]. Must-Staple effectively ad-
dresses latency, privacy, and fail-open issues, but only for
certiﬁcates that include the new extension; it does not apply
to the millions of certiﬁcates already in existence. Moreover,
this protocol requires that HTTPS servers and browsers be
upgraded to support it.
Fail-open vs. Fail-closed.
No currently-deployed ap-
proaches to disseminating revocations push all revocations
to clients. As a result, clients must sometimes make an
external request to obtain the revocation status for a certiﬁcate
(assuming they bother to check at all). However, clients must
decide what to do if this request is not answered (e.g., due to
transient network error, server failure at the CA, or a MitM
attack). All existing systems that we know of adopt a fail-
open model, whereby they accept a certiﬁcate if revocation
information cannot be obtained. Browser vendors argue that
choosing this model is necessary, as a fail-closed model would
cause an unacceptable level of failures [41]. However, the fail-
open model provides little additional security, as an attacker
who can ﬁlter the client’s trafﬁc can block the revocation status
request and cause a revoked certiﬁcate to be accepted.
CRLite aims to sidestep this conundrum by ensuring clients
have have up-to-date revocation information available for all
certiﬁcates. As a result, clients need not be faced with a
decision between availability and security.
CRLSet and OneCRL.
To mitigate the performance and
privacy issues surrounding CRL and OCSP, browser vendors
have begun pushing partial
lists of certiﬁcate revocations
directly to users’ browsers. Google’s CRLSet, introduced in
2013, contains between 14K–25K revocations (depending on
the date) [49]; this list is updated daily and pushed to Chrome
browsers. Google’s CRLSet documentation lays out some of
the inclusion/exclusion criteria used to decide which revoca-
tions appear in the list [40], but prior work has shown that
the inclusion criteria remain opaque [49]. Similarly, Mozilla
introduced OneCRL in 2015, and it has grown to include
357 revocations. However, OneCRL only includes revoked
intermediate certiﬁcates [31].
Adam Langley, from the Chrome security team, has in-
vestigated the possibility of using compressed, probabilistic
data structures for distributing all revocations to clients [39].
Although Google does use compressed data structures in
other applications (e.g., SafeBrowsing [63]), no browser that
we are aware of has adopted this approach for distributing
revocations.
D. Other Revocation Distribution Schemes
Many classic proposals have been made for alternative
certiﬁcate revocation mechanisms, such as Micali’s Certiﬁ-
cate Revocation System [51], multi-certiﬁcate revocation [1],
revocation trees [38], [55], [52], or combinations of these
techniques [28], [25]. Recent work has explored extending
certiﬁcate transparency initiatives [45], [13] to also incorporate
revocations [44], [62]. Others have focused on scaling up
revocation infrastructure in the face of byzantine failures [77].
Unfortunately, these systems still require clients to perform
online revocation checks, thus adding latency to connections.
Additionally, several of these schemes require clients to query
a central server for every single certiﬁcate, which reveals
users’ browsing behavior.
The Perspectives project aims to obviate the need for
revocation (and indeed any form of centralized trust) by
relying on multiple, independent observations to determine the
veracity of certiﬁcates [4]. The assumption is that legitimate
certiﬁcates will be seen by many users, while fraudulent or
stolen certiﬁcates will only be seen by a small subset of
users who are under attack. However, the security guarantees
offered by this approach are probabilistic, and as of 2016, this
initiative has failed to gain traction.
Other approaches have proposed more signiﬁcant modiﬁca-
tions to existing systems to enable better revocation dissemina-
tion. Chariton et al. propose to distribute revocations through
DNS [12], much like how DANE uses DNS to distribute
certiﬁcates [35]. Szalachowski et al. propose to distribute
revocations to middleboxes in the network that observe TLS
handshakes and insert up-to-date revocation information for
observed certiﬁcates [68]. However,
these systems require
signiﬁcant buy-in before they will be practical (from CAs and
clients for the former, and from CAs and CDNs for the latter).
542
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:23:56 UTC from IEEE Xplore.  Restrictions apply. 
In contrast, CRLite is built so that end users can opt-in via a
browser extension today.
Schulman et al. design a system to distribute revocations
through FM radio broadcasts [65]. Although they show that
radio broadcasts are an ideal medium for large-scale dissemi-
nation of revocations, all clients would need to install FM radio
receivers for the scheme to be deployed. Lastly, proposals
like AKI [37], PoliCert [70], ARPKI [3], and PKISN [69]
aim to replace the existing PKI with a new hierarchy that
avoids centralizing trust, is transparent, and supports seamless
revocation. However, as with any clean-slate proposal, future
adoption of these techniques is uncertain because they necessi-
tates changes to CAs, clients, and (in some cases) certiﬁcates.
In contrast, one of our goals is to develop a system that
is immediately deployable by not requiring changes to CAs
and certiﬁcates. Interestingly, the authors of PKISN suggest
pushing all revocations to clients, but they do not address
the problem of encoding this data such that the size is not
prohibitive for clients [69].
III. FILTER CASCADES
There has been considerable work regarding how best
disseminate certiﬁcate revocations. This has largely involved
exploring many different data structures, including lists in
the standard CRL [16], Merkle trees [38], [44], [28], [55],
[25], [1], Bloom ﬁlters [49], and variants thereof [39]. The
broadly accepted conclusion amongst this wide-ranging work
has been that the trade-offs between timeliness (getting all new
revocations to clients as quickly as possible) and bandwidth
are too great to be realistic—some going so far as to suggest
eliminating revocation lists altogether [61], [50]. As a result,
today’s browsers are restricted to a tiny subset of the web’s
revocations, often checking no revocations whatsoever [49].
In parallel,
there have been impressive efforts to make
publicly available the set of all live certiﬁcates on the web.
Notably, the CT project [45] and various Internet-wide scan-
ning efforts [21], [60] have brought us to the point that we
can reasonably assume that we have a nearly complete view
of the entire certiﬁcate ecosystem [73]. We demonstrate in this
section how to use this new information to compactly represent
all outstanding revocations.
What stymied prior efforts to create a compact view of
revocations was that, ultimately, there is only so much that an
arbitrary set of millions (or more) objects can be compressed.
We are not subjected to the same constraints. Our insight is that
our data structure need not support queries for any arbitrary
data item—rather it needs to successfully support queries only
for the ﬁnite set of unexpired certiﬁcates.
A. Insight
To see why this subtle difference is so powerful, we ﬁrst
recall Bloom ﬁlters [6]. A Bloom ﬁlter is a probabilistic
data structure that permits inserting arbitrary data items d ∈
{0, 1}∞, and testing for membership of arbitrary data. They
operate by maintaining a bit vector of size m and k hash
functions hi : {0, 1}∞ → Zm for i = 1, . . . , k. To insert a
data item d, one sets each hi(d) bit to one (in a traditional
Bloom ﬁlter, there is no deletion). Testing the set membership
of a data item d(cid:4) checks bits hi(d(cid:4)
); if any of them are zero,
then d(cid:4) is deﬁnitively not in the ﬁlter, otherwise it may be.
That is, although Bloom ﬁlters have no false negatives, they
have some false positive rate 0 < p < 1 determined by the
ﬁlter’s size, occupancy, and number of hash functions.
Consider a Bloom ﬁlter BF with false positive rate p. How
many false positives can BF have? Because Bloom ﬁlters
support insertion and membership queries for arbitrary bit
strings, there are an inﬁnite number of false positives. In other
words, the set of false positives for a Bloom ﬁlter is always
larger than the set stored in the ﬁlter itself.
However, suppose we knew that all set membership queries
were going to come from a ﬁnite set U . In that case, if R ⊆ U
(e.g., the set of all revoked certiﬁcates) were stored in BF, then
the expected number of false positives would be p · |U \ R|.
This is a strictly smaller set than the one that BF was supposed
to support membership queries for (U). Thus, if membership
queries come only from a known, ﬁnite set of items, then the
resulting set of false positives will be even smaller.
The key insight is that this small set of false positives can
be stored in another Bloom ﬁlter, and so on, until the number
of false positives is zero. In traditional settings, one may not
be able to assume that membership queries will come from
a constrained set. However, because we can now know the
set of virtually all certiﬁcates at any time, and because CAs
are increasingly adopting CT, we believe we can at last safely
make this assumption.
B. Filter Cascade Design
This notion of using a sequence of Bloom ﬁlters to store
increasingly smaller sets of false positives was originally intro-
duced by Chazelle et al. in what they referred to as Bloomier
ﬁlters [14], and reﬁned by subsequent work to develop ﬁlter
cascades [74], [64]. For completeness, we describe the design
of a Bloom ﬁlter cascade5, and show how it achieves zero
false positives despite being compact.
Suppose that we wish to store a set R ⊆ U of data items, and
that R ∪ S = U.
Insertion into a ﬁlter cascade begins by creating a ﬁrst-level
Bloom ﬁlter (BF1) with the optimal size and number of hash
functions to achieve a given false positive rate 0 < p < 1 (we
show how to optimize p at each level in § III-C; for ease of
exposition, assume for now that there is a ﬁxed p across all
levels). Into BF1, we insert each element of R, as normal. If
some data item u is not in BF1, then it is deﬁnitively not in
R, but not vice versa. Thus, the set of ﬁrst-level false positives
(FP1) contains the elements of S that also appear in BF1. In
expectation, |FP1| = p · |S|.