这篇文章中主要讲一个在前端中出现的有意思的变量劫持漏洞。
## 0x1 基础知识
当页面存在`iframe`的时候，父页面和子页面是可以相互获取到对方的`window`对象的,主要利用下面的方法。  
(本文不考虑 `iframe` 的 `sandbox` 属性,所有测试都是在不添加任何`sandbox`的限制下进行。)
父访问子:
    document.getElementById("iframe1").contentWindow; // 获取iframe的window对象
    window.frames[0]; // 获取iframe的window对象
    window[0] ; // 这个比较有意思， window 是本页面的window对象，window[0] 是子页面的window对象
子访问父：
    window.parent;  //获取上一级的window对象，如果还是iframe则是该iframe的window对象
    window.top ;   // 获取最顶级容器的window对象，即，就是你打开页面的文档
如果父和子页面是同源的，那么可以通过这个window对象获取到任何你想获取的内容，包括但是不限于 document,name,location
等。但是在非同源的情况下，iframe的window对象大多数的属性都会被同源策略block掉，但是有两个属性比较特殊。
  1. frames 可读，但是不可写。 意味着可以读取不同域的子页面里面的iframe的window对象
  2. location 可写，但是不可读。意味着父子可以相互修改彼此的 location 
**结合以上两点可以推导出，爷可以修改孙(孙可以修改爷)的location。(父页面可以获取子页面的window对象，然后通过frames获取孙页面的window对象，然后修改location)**
爷修改孙，演示如下：
        Document
## 0x2 重新审视一下 id 属性
我们知道在浏览器中有如下特点，我们定义的所有全局变量，都被存储在window对象中，作为window的属性来被访问的。
下面在console中验证一下：
    > content = "i am content storage in window";
     window.content 
     window.content == content
然后再console里访问一下:
    > test
    > window.test
这时候想到一个问题，既然 id 属性会被注册成全局变量，那么它会不会覆盖掉已经存在的全局变量呢？我们写如下的测试代码：
    test
    test2
在console中输入：
    > test
     test2
    > test2
**事实证明无法覆盖已经定义的变量，但是却可以定义新的变量**
**怎么让页面中出现未定义的全局变量呢？别忘了 chrome 74之后 默认的 xss auditor
从block模式编程了filter模式，可以利用这个删除掉页面中的代码。(此问题文章最后演示)**
另外我们知道，如果在页面中定义两个id一样的元素之后，这样使用 `document.getElementById`
就无法获取到这个id了，但是并不意味着着全局变量就不存在了，看下面这个实验。
    > test 
在console里验证一下
    > viewer 
在console里面输入:
    > test
     test == document.getElementsByTagName('iframe')[0].contentWindow
     test == document.getElementsByTagName('iframe')[1].contentWindow
    > test 
    > test 
    click me
利用的poc如下,修改A.html如下：
然后访问 A.com/A.html ，就会发现 B.com/B.html 中的 `VUL` 已经被劫持了。
## 0x6 结尾
但是好像就算变量劫持了，可以利用的面还是很小啊，只能将一个变量劫持为window对象，期待师傅们一起来挖掘新的利用场景。