about it. Axiom A7 relates the knowing and being informed
operators, stating the obvious that if A knows that K is
Table 1: Speech-Acts Forms
Request
Sender: A
Role of Sender: ρ
Receiver: B
RoleOfReceiver: τ
Type: t
Content: Con
Reply-With: n
Reply
Sender: A
Role of Sender: ρ
Receiver: B
RoleOfReceiver: τ
Type: t
Content: Con
Reply-To: n
Inform
Sender: A
Role of Sender: ρ
Receiver: B
RoleOfReceiver: τ
Type: t
Content: Con
a fresh session key between B,C generated by D then A is
also informed about it. The axioms and proof rule in modal
system S5 [17, 12] are adapted to KL as follows:
KnowA,ρF → F
KnowA,ρF ∧ KnowA,ρ(F → G) → KnowA,ρG
KnowA,ρF → KnowA,ρKnowA,ρF
¬KnowA,ρF → KnowA,ρ¬KnowA,ρF
From (cid:5) F infer (cid:5) KnowA,ρF
2.2 Speech Acts and Well Designed Protocols
We introduce a set of speech acts consisting of Request,
Reply and Inform acts that we believe form a core of prim-
itives that capture the most essential structures in security
protocols. This set is extensible to capture further struc-
tures with new acts.
There are two types of speech acts: newkey, keyconﬁrm.
Intuitively, an act of type newkey is used for distributing a
new key while an act of type keyconﬁrm is used for conﬁrm-
ing the knowledge of a new key. For example, the ﬁrst (resp.
last) three acts in the abstract protocol in example 1 are of
type newkey (resp. keyconﬁrm).
Speech acts are deﬁned as speech act forms that contain
no variables. The structure of speech act forms are given
in the table 1 where A,B are principal terms, ρ, τ are roles
, n is a nonce term, t ∈ {newkey, keyconf irm}, and Con
represents the content of the acts. It is required that the
roles of sender and receiver in an act must be diﬀerent, i.e.
ρ (cid:6)= τ . The nonce n in a request act is generated randomly
by A when A performs the act.
The content of a request of type newkey has the form
Key(?,A,C,B) stating that A requests B to generate a new
session key for A to communicate with C.
The content of a request of type keyconﬁrm has the form
Key(K,A,B,C) stating that A asks B to conﬁrm that B
knows that K is a fresh session key between A and B gener-
ated by C.
In a reply or inform act of type newkey, the sender A sends
the receiver B a freshly generated session key for communi-
cation with C. If the key has not been generated, then the
sender has to generate it ﬁrst and then sends it. In this case
the content of the act has the form νK.Key(K, B, C, A).
Otherwise it has the form Key(K, B, C, A) in a reply act
or the form Key(K, B, C, A) or Key(K, B, A, C) (depend-
ing on whether K is generated by A or by C) in an inform
act.
The content of a reply or inform act of type keyconﬁrm
is simply of the form Key(K, A, B, C) aﬃrming that K is
indeed a fresh session key between A and B generated by C.
The declarative semantics of speech acts is speciﬁed by
their preconditions and eﬀects. The preconditions describe
the necessary information and knowledge a honest principal
should have to be able to send the acts and for the receiver
to accept and process it without leaking any secret infor-
mation or being fooled by the penetrator. The eﬀects of a
speech act describe the information and knowledge a princi-
pal gains after sending it (for the sender) or receiving it (for
the receiver). Regular principals are assumed to be honest.
Let S be a speech act form as deﬁned above. The precon-
ditions and eﬀects of the event of sending (resp. receiving) S
are denoted by Pre(+S) and Eﬀect(+S) (resp. Pre(-S) and
Eﬀect(-S)) and formalized in the tables 2-5 below.
The deﬁnition of key exchange protocols is based on a
notion of conversation form where a conversation form
is a pair (Req, Rep) of request and reply act forms of the
same type and with the same nonce such that 1) the sender
(resp. receiver) and its role in Req coincide with the receiver
(resp. sender) and its role in Rep respectively, and 2) if the
acts in the conversation are of type keyconﬁrm then their
contents coincide, and 3) if the acts in the conversation are
of type newkey and the content of the request has the form
Key(?,A,C,B) then the content of the reply has the form
Key(K,A,C,B) or νK.Key(K, A, C, B)
Deﬁnition A speech act oriented key exchange proto-
col (or simply key exchange protocol) is a sequence of speech
act forms S1, . . . , Sk such that
1) For each request (resp. reply) Si, there is exactly one
reply (resp. request) Sj, j > i (resp. j < i) such that Si, Sj
(resp. Sj, Si) form a conversation form.
2) Each principal term has at most one role, i.e. for each
principal term P in AP, if there exist Si, Sj such that P
appears as a sender or receiver in both Si and Sj then P has
the same role in both acts. 2
3) Every role in AP is occupied by exactly one principal
term, i.e. for all principal terms P,Q in AP, if there exist
Si, Sj and ρ ∈ RO such that P has role ρ in Si and Q has
role ρ in Sj then P = Q.
4) Variables representing nonces of diﬀerent conversation
forms are diﬀerent.
5) The penetrator identiﬁer does not appear in any Si.
6) There is exactly one key term appearing in the protocol
and the ﬁrst act in which it appears is a reply or inform act
of type newkey that is also the only act in the protocol with
a content of the form νK.Key(K, A, B, C)
Now we can introduce well-designed protocols. For each
speech act form S, deﬁne P re(S) = P re(+S) ∧ P re(−S)
and Ef f ect(S) = Ef f ect(+S) ∧ Ef f ect(−S).
Deﬁnition A key exchange protocol AP = S1, . . . , Sk is said
to be well-designed if speech acts are scheduled for execu-
tion only when their preconditions are satisﬁed, that means
following conditions are satisﬁed:
1) P re(S1) = T rue
2) For each 2 ≤ i ≤ k: Ef f ect(S1)∧. . .∧Ef f ect(Si−1) (cid:5)
P re(Si)
It is not diﬃcult to see that the abstract protocol in ex-
ample 1 is well-designed. The following example illustrates
how a violation of the well-designed condition could lead to
serious ﬂaws.
(cid:1)
1, S
(cid:1)
2, S
= S
(cid:1)
4 = S6 and S
Let S1, . . . , S6 be the acts of the abstract protocol in ex-
(cid:1)
(cid:1)
(cid:1)
(cid:1)
ample 1. Consider a new protocol P
4, S
3, S
i = Si for i ∈ {1, 2, 3} and S
5
(cid:1)
(cid:1)
deﬁned by S
5 is an
inform act of type keyconﬁrm from A to B to conﬁrm the
receipt of K. P’ is in fact an abstraction of the Needham-
Schroeder protocol with symmetric key (NSPS) [8]. P
is
(cid:1)
not well-designed as the preconditions of S
4 do not follow
from the eﬀects of the previous acts in it. Similar to NSPS,
P’ is subjected to a replay attack in which the penetrator
(cid:1)
replays an old message S
3 to B whose key K has become
(cid:1)
stale. The penetrator then intercepts the message S
4 that
(cid:1)
B sends to A and then sends S
5 to B as speciﬁed by the
protocol. B is then tricked into falsely believing that it has
a secret common key for communicating with A generated
by S.
(cid:1)
3.
PROTOLOG: A LOGIC FOR WELL-
DESIGNED PROTOCOLS
We introduce now ProtoLog, a protocol logic, for reason-
ing about the mental states of principals participating in
well-designed protocols. Let ρ ∈ RO be a role in a proto-
col AP = S1, . . . , Sn. The ρ-track of AP is the sequence
APρ = σi1 Si1 , . . . , σik Sik where σij ∈ {+,−}, 1 ≤ i1 <
i2 < . . . < ik ≤ n, such that for each 1 ≤ j ≤ n, +Sj ∈ APρ
(resp.−Sj ∈ APρ) iﬀ ρ is the role of the sender (resp. re-
ceiver) in Sj. For illustration, the initiator-track of the
abstract protocol in example 1 is +S1,−S2,−S4, +S5,−S6
while its responder-track is −S3, +S4,−S5, +S6. A run of
principal A in the role ρ according to a protocol AP is a
ground instance of a preﬁx of the ρ-track APρ of AP in
which A is the principal having the role ρ. A is also called the
principal of such run. A proper-regular run is a run where
the penetrator PE does not appear in any of its acts. Let
R = E1 . . . Ek be a run. Deﬁne Ef f ect(R) = Ef f ect(E1) ∧
. . . ∧ Ef f ect(Ek). Note that Ef f ect(nil) = T rue.
To reason about the eﬀects of runs of protocols , we intro-
duce new formulas called protocol formulas of the form
AP.R [F] stating that formula F holds after run R accord-
ing to AP has been executed (by the principal of R).
Let AP be a protocol, E be an event of sending or receiv-
ing a speech act, R be a proper-regular run of A in a role ρ
according to AP, and F,F’ be formulas. Further let A,B,C,D
be regular principal identiﬁers and X be a principal identi-
ﬁer. Protolog extends KPL with following axioms and proof
rules:
A9 Key(K, B, C, A) → GKA,ρ1 (K, B, C) ∨ . . .
∨ GKA,ρk (K, B, C)
(cid:1)
where RO = {ρ1, . . . , ρk}
A10 GKA,ρ(K, B, C) ∧ GKA(cid:1),ρ(cid:1) (K, B
(cid:1)
, C
) ∧ (B, C) = (B
(cid:1)
(cid:1)
, ρ
)
A11 A (cid:6)= B∧A (cid:6)= C∧A (cid:6)= D → ¬Inf ormedA,ρ(K, B, C, D)
A12 Key(K, B, C, A) ∧ X (cid:6)= A ∧ X (cid:6)= B ∧ X (cid:6)= C →
¬Access(X, K)
(A, ρ) = (A
) →
, C
(cid:1)
(cid:1)
2This condition does not forbid a principal to play more than
one role in an actual run of a protocol (when two diﬀerent
principal variables are instantiated by the same principal
identiﬁer), but it ensures that normally diﬀerent principals
have diﬀerent roles in a run of the protocol.
Eﬀect Rule
——————————
(cid:5) AP.R [Ef f ect(R)]
Consequence Rule
(cid:5) AP.R [F ], (cid:5) F → F
——————————–
(cid:1)
(cid:5) AP.R [F
(cid:1)
]
Table 2: Request Acts
Act
S
newkey
Request
keyconﬁrm
Pre(+S)
True
Inf ormedA,ρ(K, A, B, C)
Eﬀect(+S) GNA,ρ(n)
GNA,ρ(n)
Pre(-S)
Eﬀect(-S) HNB,τ (n) KnowB,τ Inf ormedA,ρ(K, A, B, C) ∧ HNB,τ (n)
KnowB,τ Key(K, A, B, C)
True
Table 3: Reply Acts
Reply
Act
S
Con ≡ νK.Key(K, B, C, A) Con ≡ Key(K, B, C, A)
newkey
keyconﬁrm
KnowA,ρKey(K, A, B, C) ∧
HNA,ρ(n)
True
GNB,τ (n) ∧
Inf ormedB,τ (K, A, B, C)
KnowB,τ HNA,ρ(n) ∧
KnowBτ KnowAρKey(K, A, B, C)
Pre(+S)
HNA,ρ(n)
HNA,ρ(n) ∧
GKA,ρ(K, B, C)
Eﬀect(+S)
GKA,ρ(K, B, C)
True
Pre(-S)
Eﬀect(-S)
GNB,τ (n)
KnowB,τ GKA,ρ(K, B, C) ∧
KnowB,τ HNA,ρ(n)
Table 4: Inform Acts
Inform
Act