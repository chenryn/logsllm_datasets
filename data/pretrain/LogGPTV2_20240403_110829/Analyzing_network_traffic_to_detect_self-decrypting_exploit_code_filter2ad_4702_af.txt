ploit Framework [4]. This is a powerful open source frame-
work for the construction and execution of exploits. This
framework has also been used in other research [10, 19, 23].
The ﬁrst experiment was as follows. 10 exploits were
downloaded from Milw0rm (http://www.milw0rm.com). For
each exploit, 10 polymorphic instances were generated, using
the above tools (ADMmutate and Clet). ADMmutate may
be the ﬁrst well-known polymorphic engine. It can generate
a simple metamorphic NO-OP sled with one-byte instruc-
tions, and a metamorphic decryption routine using several
advanced obfuscation techniques. These include using mul-
tiple code paths for an operational instruction and inserting
non-operational “junk” instructions. Clet can generate a
metamorphic NO-OP sled using English words. It also uses
“cramming” bytes to make the byte frequency of the re-
sulting polymorphic exploit codes resemble that of normal
network traﬃc.
Each of these exploit instances was then input to the pro-
posed detection method. All 100 instances were successfully
identiﬁed as exploit code. Both of these polymorphic en-
gines generate encrypted exploit codes with an obvious NO-
OP sled of suﬃcient length, as well as an obvious decryption
loop. Previously-proposed detection methods [10, 23, 19, 22,
9] may also be able to detect such exploits. The existence
of a suﬃciently long NO-OP sled will help them cope with
the non-obvious starting location of the decryption routine.
The second experiment simulated remote exploit attacks,
using the Metasploit Framework. The target service was an
unpacked Windows XP host running the Serv-U ftp server
v4.0. Attacks were launched from a Windows host using
polymorphic exploits for the following vulnerabilities:
• Serv-U FTPD MDTM Overﬂow 3
• Microsoft RPC DCOM MS03-026 4
• Microsoft LSASS MSO4-011 Overﬂow5
• Microsoft ASN.1 Library Bitstring Heap Overﬂow 6
For each vulnerability, we launched multiple attacks from
the Metasploit console interface, using the following encoders
(encryption methods):
1. Pex
2. PexFnstenvSub
3. PexFnstenvMov
4. Countdown
3http://www.osvdb.org/4073
4http://www.osvdb.org/2100
5http://www.osvdb.org/5248
6http://www.microsoft.com/technet/security/bulletin/MS04-
007.mspx
5. JmpCallAdditive
6. Alpha2
7. ShikataGaNai
These were combined with two NO-OP sled generation meth-
ods: Pex, and Opty. Pex generates a NO-OP sled with
one-byte instructions. Opty generates a NO-OP sled with
multiple-byte instructions, as well as a “trampoline” sled,
which transfers control using relative addressing directly to
the exploit code. The traﬃc capture tool Ethereal was used
to capture the network traﬃc generated by Metasploit. This
traﬃc was then input to the prototype implementation of
the proposed detection method.
The proposed approach successfully detected all of the
polymorphic exploits generated using encoders Pex, PexFn-
stenvSub, PexFnstenvMov, Countdown, and JmpCallAdditive.
These encoders generate static decryption code with the
properties identiﬁed in section 3.3. They do not employ self-
modiﬁcation on decryption routines. Figure 2, for example,
shows the disassembly of the decryption code produced by
the Countdown and JmpCallAdditive encoders. The under-
lines mark the major functional decryption instructions: the
seeding instruction of the GetP C code, the memory-write
instruction for decrypting the encoded payload and the in-
struction for updating the address of encoded byte.
More impressively, the proposed method successfully de-
tected 100% of the exploits generated by the Alpha2 and
ShikataGaNai encoders. These methods generate self-modif-
ying decryption routines. The decryption loop is changed or
patched “on the ﬂy” (during execution) before it is used to
decrypt the exploit. For illustration, ﬁgure 3 shows the dis-
assembly of the self-modifying decryption code for Shikata-
GaNai encoder. Figure 3(a) shows the original decryption
routine before execution. Figure 3(b) demonstrates the re-
sults after execution of the self-modifying decryption rou-
tine. The underlined instructions in (b) have the same ef-
fects as those shown in ﬁgure 2. In addition, the underlined
bytes identify the modiﬁed instructions before and after exe-
cution. In the appendix, we also present the disassembly re-
sults of the self-modifying decryption routine for the Alpha2
encoder.
The polymorphic exploit code for attacking Serv-U FTPD
MDTM Overﬂow vulnerabilities do not use a NO-OP sled.
This has been veriﬁed by inspection of the outputs gen-
erated under diﬀerent conﬁgurations, and by inspection of
the Metasploit source code. The absence of a NO-OP sled
will likely defeat several proposed methods which speciﬁcally
look for NO-OP sled [22, 9]. The network-level emulation
method (e.g., [19]) is also likely to have problems identifying
the start of the decryption routine. One of its heuristic for
performance optimization is to skip several bytes (e.g. 50
bytes) after a zero byte is detected at a byte oﬀset. Without
the compensation eﬀect of the NO-OP sled, instructions of
the decryption routine code could be missed by the method.
Sigfree [23] cannot detect polymorphic exploit code gener-
ated by small-sized decryption routines, such as Countdown,
as mentioned in [23].
It also cannot detect polymorphic
exploits that use self-modifying decryption routines, such
as the exploit codes generated by encoder ShikataGaNai.
The method proposed by Chinchani et al. [10] also cannot
detect polymorphic exploits with self-modifying decryption
routines.
In summary, the proposed method achieves a 100% de-
tection rate on polymorphic exploit code, with or without
NO-OP sleds, and with or without self-modifying decryp-
tion routines. No previous method of static analysis has
been able to achieve this. The emulation method [19] can
deal with the polymorphic exploit code with self-modifying
decryption routines. However they are not robust against
those without NO-OP sleds.
4.2 False Positives
We also tested the proposed method on normal (non-
exploit) network traﬃc, and on Windows binary executa-
bles. A detection method should indicate in both cases that
the traﬃc does not contain exploits. Indicating otherwise is