(b)
(c)
Figure 7: Installation time overhead for apps with different complexity
is the creation of the target ﬁle, to which a security context
inherited from the parent directory is assigned (see ﬂow A ,
B of Figure 6). Since Android 9, the separation between ﬁles
of different apps is enforced at MAC level (a unique context
based on UID and SELinux category is assigned); however,
all the ﬁles stored in the same app folder are labeled with the
app_data_file type.
To make the most out of SELinux, SEApp complements
Android with the implementation of a new service, which
we called restorecon (to recall the SELinux restorecon.c
tool). The restorecon service is spawned by init at boot,
and works in its own SELinux domain. Its role is to cre-
ate and label ﬁles as speciﬁed by the developer in the local
file_contexts. To ease development, we implemented the
new android.os.File abstraction, which exposes an inter-
face equal to that of java.io.File, and transparently han-
dles the call to our service. Figure 6 details the new control
ﬂow. A component running in a SEApp-enhanced process
(highlighted in green in Figure 6) invokes android.os.file,
and triggers a new ﬁle creation request ( 1 ). The new API
ﬁrst interacts with the ServiceManager ( 2 ) to get a han-
dle of the restorecon service ( 3 ), then it interacts with
the service using the AIDL [5] interface we deﬁned for
it, informing the restorecon of the target path ( 4 ). The re-
storecon service veriﬁes whether the caller is the legitimate
owner of the path, it reads the file_contexts ﬁle located
at /data/selinux/packageName ( 5 ), and ﬁnally it creates
the target ﬁle enforcing the correct labeling ( 6 ).
We also investigated three other implementation ap-
proaches:
(i) change of the default security context
inheritance behavior for the ext4 ﬁlesystem, (ii) execution of
the SELinux restorecon operation by the app, once the ﬁle is
successfully created, and (iii) use of restorecond [25]. The
ﬁrst option would change the default behavior system-wide.
As it might cause compatibility issues, we decided not to
choose it. The second option is not ideal from a security
standpoint, as it requires to grant the application too many
permissions (e.g., relabelfrom, relabelto, as well as
read/write access to selinuxfs to check the validity of
the SELinux context). The third option refers to the use of
restorecond, a system daemon that watches (inodes of) a
conﬁgurable list of ﬁles and checks that they are labeled
as stated in the system file_contexts. Although it may
realize the control, restorecond was meant for a few system
ﬁles, therefore its performance would hardly scale, especially
considering that SEApp needs to manage all ﬁles created
by SEApp-aware apps. Another major issue is that this
approach is exposed to race conditions, because there is a
delay between ﬁle creation and its relabeling.
7 Performance
We now present a performance evaluation of SEApp. The
experiments have been conducted on both Android 9 and 10,
each with Linux kernel v4.9. However, all the measurements
shown refer to Android 10 (release android-10.0.0_r41). The
device used to run the tests is a Google Pixel 3 (blueline),
in which the four gold cores frequency was set to 2.8 GHz,
while the four silver ones were disabled. The change in CPU
conﬁguration has been performed to reduce the variability of
measures. The conﬁdence intervals provided have an associ-
ated conﬁdence level of 99%.
7.1 App installation
The introduction of dedicated app policies implies further
steps to be executed at app installation time, as each SEApp
module has to be validated, compiled, and loaded. To evaluate
the impact on performance, we wrote dedicated tests to stress
the installation procedure with multiple application samples.
To build representative samples of a typical consumer sce-
nario, we ﬁrst downloaded the 150 most popular free apps
from Google Play (retrieved in October 2020) [52]. The apps
were subsequently divided into three buckets: basic, ordinary
and huge apps, according to the weighted normalized aver-
age of the .apk size, the number of Android activities and
the number of services. Based on the bucket, each app was
equipped with one of the following policy conﬁgurations: (i)
basic, 1 domain and 1 type per policy module, (ii) ordinary,
10 domains and 25 types, and (iii) huge, 20 domains and 100
types. The rationale is that larger apps can gain considerable
USENIX Association
30th USENIX Security Symposium    3623
installationorder(fromGooglePlay)051015202530installationtime[s]basicappspolicyoverheadnormalinstallationinstallationorder(fromGooglePlay)051015202530installationtime[s]ordinaryappspolicyoverheadnormalinstallationinstallationorder(fromGooglePlay)051015202530installationtime[s]hugeappspolicyoverheadnormalinstallationFigure 8: Cumulative install time overhead when installing
the top 100 free apps on Google Play Store with our policies
Figure 9: Install time overhead for the three policy sizes
beneﬁt from the use of a large policy. The basic conﬁguration
mimics how third-party apps are currently handled, but with
some key improvements, as it permits to deﬁne the subset of
services the domain can use, and it permits to enforce app iso-
lation, not only based on MAC category, but also through the
speciﬁcation of its own type. The ordinary and huge policy
conﬁgurations are meant to take full advantage of intra-app
isolation and ﬂexibility via the deﬁnition of multiple domains.
Each test was repeated ﬁve times, measuring the time each
package took to install. The measurements were done with
the *nix date utility.
Test I. To measure the overhead caused by the presence of the
policy module, we performed on device installation of each
of the previously described app buckets (basic, ordinary and
huge) via Android Debug Bridge (adb) [13].
The results of Test I are illustrated in Figure 7. In detail, it
shows in blue (i.e., the lower part of the bar) the time required
by the system to install the current package without the dedi-
cated policy module, while in orange (i.e., the top of the bar)
the overhead caused by the presence of the policy module.
The data report that a limited overhead is associated with apps
with huge policies, at most 3.59± 0.04s, while basic and or-
dinary policy conﬁgurations exhibit a negligible slowdown,
never exceeding 1.22± 0.02s.
Test II. To evaluate the overall impact of SEApp in a typical
consumer scenario, we performed a test evaluating cumulative
installations. At ﬁrst, we repeated the installation of the top
100 apps on Google Play Store with the same policy conﬁgu-
ration as in Test I (see Figure 8). In this case, we measured
an overhead of 20.98± 1,31% on total installation time.
As explained in Section 6, each time a new application is
installed, all policy fragments stored in the device have to be
recompiled to produce the new binary policy. The installation
time overhead then grows with the increase in the number
of installed policy modules. To further analyze this aspect,
we repeated the installation of the top 100 free apps adding
to all the packages in three separate experiments the same
basic, ordinary, and huge policy conﬁgurations. The experi-
mental results illustrated in Figure 9, show that only the use
of huge policy modules introduces a non-negligible overhead
(45.35± 2.44% on total installation time). However, this pol-
icy conﬁguration simulates an edge case, as we do not expect
to ﬁnd 100 of them in a real scenario. To give a comparison,
the huge policy declares 100 types; public/file.te, i.e.,
the ﬁle used to deﬁne all the ﬁle types of the system, declares
314 types in Android 10.
In Table 3 we report the sizes of the overall policies for the
three scenarios considered in this experiment. We report the
number of MAC types, the number of produced AV rules, and
the overall size in KBytes of the binary policy.
Table 3: Policy size
policy
system
system + 100 basic
system + 100 ordinary
system + 100 huge
#types
1536
1836
6036
15536
#avrules
29228
47028
213228
417228
KB
596
867
3512
7064
7.2 Runtime performance
We now evaluate the runtime overhead for an app taking
full advantage of SEApp. We focus on the creation of pro-
cesses and ﬁles, as they are the entities directly affected by the
changes made in the implementation. The data shown refer to
the creation time of each resource. The measurements have
been acquired via System.nanoTime and have been repeated
100 times for each test. Also, all outliers diverging more than
3 standard deviations from the mean have been suppressed.
7.2.1 Processes
As discussed in Section 6, in SEApp the creation of a process
is originated from the request of execution of an Android
component. Thus, the slowdown occurs between the request
for the component and the execution of the method onCreate,
which is the time interval subject to measurement. Our evalu-
ation is limited to activities and services, as these are the com-
3624    30th USENIX Security Symposium
USENIX Association
120406080100#installedapps020040060080010001200cumulativeinstallationtime[s]policyoverheadnormalinstallation120406080100#installedapps0%20%40%60%80%100%overheadhugepolicyordinarypolicybasicpolicyTable 4: Cold and warm start performance for activities and services
Cold start (ms)
SEApp
σ
Stock OS
σ
µ
Warm start (ms)
SEApp
Component
LocalActivity
RemoteActivity
SEApp Activity
LocalService
RemoteService
IsolatedService
SEApp Service
Stock OS
µ
σ
39.102
123.468
-
19.164
105.467
103.923
-
1.094
3.176
-
1.444
2.800
2.425
-
µ
38.689
124.649
127.356
18.835
106.935
104.260
106.925
0.980
3.526
3.542
1.392
2.565
3.727
3.774
21.052
15.722
-
1.399
2.617
-
-
6.046
2.682
-
0.208
0.879
-
-
µ
18.685
15.933
15.188
1.328
2.676
-
σ
5.001
3.256
2.394
0.208
0.593
-
2.528
0.675
Table 5: File creation
performance
File creation
Test
Stock OS
SEApp
SEApp +
restorecon
µ (µs)
57.077
60.696
σ (µs)
5.174
6.782
431.472
109.494
ponents most used by developers. Our analysis showed iden-
tical behavior for broadcast receivers and content providers,
the other two components supporting the android:process
attribute in the manifest.
Separate test cases have been identiﬁed based on the type
of process that supports the component. We refer to Local,
Remote, Isolated or SEApp components when we run compo-
nents respectively in the current process, in another process,
in another process with the isolated_app domain (using
the isolatedprocess we described in Section 3.1.3), or in a
package speciﬁc domain (declared in the app policy module).
Furthermore, we cover cold and warm start scenarios. The
cold start corresponds to the ﬁrst time the application brings
up the component, and the warm start to the subsequent times
the app reuses a previously instantiated one.
The results shown in Table 4 demonstrate that the perfor-
mance of a stock version of the OS and SEApp are equiv-
alent. Also, we observe that apps willing to beneﬁt of the
intra-app isolation feature get from the use of SEApp the
same performance they would get from the use of remote
components. Our approach also proves to outperform the Iso-
latedService, as the isolatedprocess option forces the creation
of a new process every time an IsolatedService that was previ-
ously unBind-ed is activated. This introduces a slowdown of
102± 1ms compared to the SEAppService warm start, which
instead beneﬁts from the system caching mechanism.
7.2.2 Files
Alongside the usual creation method, SEApp introduces in
Android the possibility of creating ﬁles with a security do-
main deﬁned by the app dedicated file_contexts. Table 5
shows the time required to create a ﬁle, for each of the meth-
ods discussed. We observe no overhead on direct ﬁle creation,
but the overall execution time becomes larger due to the invo-
cation, as described in Section 6.2, of the restorecon service,
which requires approximately 374±30µs. This overhead only
occurs at ﬁle creation and every subsequent operation on the
ﬁle does not exhibit any performance degradation.
8 Related work
In traditional desktop operating systems signiﬁcant effort has
been spent in retroﬁtting legacy code for authorization pol-
icy enforcement leveraging MAC. An approach is to place
reference monitor calls to mediate sensitive access locations
through the use of static and dynamic analysis [49, 59]. An
evolution of this solution is the multi-layer reference mon-
itor [54], in which the MAC policy is enforced at different
levels (e.g., application, OS, Virtual Machine Manager). An-
other approach is to identify integrity-violating permissions
through the use of information-ﬂow analysis [64].
Android’s open source nature and popularity made it the
target of careful security investigations (e.g., [1, 42, 43, 47])