198 Target Monitoring
0x00003844 in compile_regex (options=0, oldims=0,
brackets=0xbffff474,
codeptr=0xbffff46c, ptrptr=0xbffff468, errorcodeptr=0xbffff470,
lookbehind=0, skipbytes=0, firstbyteptr=0xbffff47c,
reqbyteptr=0xbffff478, bcptr=0x0, cd=0xbffff424) at
pcre_compile.c:2354
2354 *code = OP_KET;
So, if when fuzzing this particular library, the tester was only using the simple
method of attaching a debugger and waiting for crashes, he or she would miss these
two critical (and exploitable) bugs. If the tester was monitoring the program with
Guard Malloc, he or she would have found both bugs. Plus, this program is small
enough that there was no observable slowdown in performance when running with
Guard Malloc. Therefore, in this case, it is difficult to think of a reason not to use
this additional monitoring when fuzzing.
6.7.2 Valgrind
This real-world example confirms what we saw in the test program in the last sec-
tion. Valgrind again finds the two vulnerabilites and gives even more useful infor-
mation than Guard Malloc.
[cmiller@LinuxForensics pcre-6.2]$ valgrind ./pcredemo ‘[[**]]’ a
==12840== Invalid write of size 1
==12840== at 0x804B5ED: compile_regex (pcre_compile.c:3557)
==12840== by 0x804C50F: pcre_compile2 (pcre_compile.c:4921)
==12840== by 0x804CA94: pcre_compile (pcre_compile.c:3846)
==12840== by 0x804864E: main (pcredemo.c:76)
==12840== Address 0x401F078 is 0 bytes after a block of size 80
alloc’d
==12840== at 0x40053D0: malloc (vg_replace_malloc.c:149)
==12840== by 0x804C40C: pcre_compile2 (pcre_compile.c:4877)
==12840== by 0x804CA94: pcre_compile (pcre_compile.c:3846)
==12840== by 0x804864E: main (pcredemo.c:76)
==12840==
==12840== Invalid write of size 1
==12840== at 0x804C545: pcre_compile2 (pcre_compile.c:4935)
==12840== by 0x804CA94: pcre_compile (pcre_compile.c:3846)
==12840== by 0x804864E: main (pcredemo.c:76)
==12840== Address 0x401F079 is 1 bytes after a block of size 80
alloc’d
==12840== at 0x40053D0: malloc (vg_replace_malloc.c:149)
==12840== by 0x804C40C: pcre_compile2 (pcre_compile.c:4877)
==12840== by 0x804CA94: pcre_compile (pcre_compile.c:3846)
==12840== by 0x804864E: main (pcredemo.c:76)
Another interesting thing that occurs is that, unlike Guard Malloc, it is able to
continue past the first bug to find another (related) problem. A similar result is
found for the other bug,
6760 Book.indb 198 12/22/17 10:50 AM
6.7 Case Study: PCRE 199
[Linux pcre-6.2]$ ./pcredemo ‘(?P)(?P>a){1}’ a
==12857== Invalid write of size 1
==12857== at 0x804B5ED: compile_regex (pcre_compile.c:3557)
==12857== by 0x804C50F: pcre_compile2 (pcre_compile.c:4921)
==12857== by 0x804CA94: pcre_compile (pcre_compile.c:3846)
==12857== by 0x804864E: main (pcredemo.c:76)
==12857== Address 0x401F068 is 1 bytes after a block of size 63
alloc’d
==12857== at 0x40053D0: malloc (vg_replace_malloc.c:149)
==12857== by 0x804C40C: pcre_compile2 (pcre_compile.c:4877)
==12857== by 0x804CA94: pcre_compile (pcre_compile.c:3846)
==12857== by 0x804864E: main (pcredemo.c:76)
==12857==
==12857== Invalid write of size 1
==12857== at 0x804C545: pcre_compile2 (pcre_compile.c:4935)
==12857== by 0x804CA94: pcre_compile (pcre_compile.c:3846)
==12857== by 0x804864E: main (pcredemo.c:76)
==12857== Address 0x401F069 is 2 bytes after a block of size 63
alloc’d
==12857== at 0x40053D0: malloc (vg_replace_malloc.c:149)
==12857== by 0x804C40C: pcre_compile2 (pcre_compile.c:4877)
==12857== by 0x804CA94: pcre_compile (pcre_compile.c:3846)
==12857== by 0x804864E: main (pcredemo.c:76)
6.7.3 Insure++
In order to build the pcredemo program for use with Insure++, we need to tell it to
use Insure as the compiler. The following commands will build pcredemo for use
with Insure++:
./configure CC=insure
make
insure -g -I. pcredemo.c -o pcredemo .libs/libpcre.a
After this, running pcredemo will bring up the Insure console, which will display
any problems identified. Insure++ finds both vulnerabilities and correctly indicates
where they can be found in the source code (Figure 6.10).
6.7.4 AddressSanitizer
To enable AddressSanitizer for the pcredemo program, we need to add
-fsanitize=address for our configure CFLAGS and CXXFLAGS, and for our pcre-
demo compile command:
./configure CFLAGS=”-fsanitize=address”
CXXFLAGS=”-fsanitize=address”
make
gcc -fsanitize=address -g -I. pcredemo.c -o pcredemo .libs/
libpcre.a
6760 Book.indb 199 12/22/17 10:50 AM
200 Target Monitoring
Figure 6.10 Insure++ outlines the two PCRE bugs.
Once we have AddressSanitizer enabled, we can run the pcredemo normally.
[attekett@Ubuntu ~]$ ./pcredemo ‘ab.d’ ABCDabcdABCD
Match succeeded at offset 4
0: abcd
No named substrings
With the inputs that trigger our heap buffer overflows we see that AddressSanitizer
catches the bug once it is triggered.
[attekett@Ubuntu ~]$ ./pcredemo ‘[[**]]’ a
=================================================================
==5717==ERROR: AddressSanitizer: heap-buffer-overflow on address
0x60800000bff8 at pc 0x00000040b9d1 bp 0x7ffd3bf5f480
sp 0x7ffd3bf5f470
WRITE of size 1 at 0x60800000bff8 thread T0
#0 0x40b9d0 in compile_regex /pcre-6.2/pcredemo+0x40b9d0)
#1 0x40f585 in pcre_compile2 (/pcre-6.2/pcredemo+0x40f585)
#2 0x40c73c in pcre_compile (/pcre-6.2/pcredemo+0x40c73c)
#3 0x40132f in main /pcre-6.2/pcredemo.c:76
#4 0x7fde41e2282f in __libc_start_main (/lib/x86_64-
linux- gnu/libc.so.6+0x2082f)
#5 0x400fd8 in _start (/pcre-6.2/pcredemo+0x400fd8)
.
6760 Book.indb 200 12/22/17 10:50 AM
6.8 Summary 201
[attekett@Ubuntu ~]$ ./pcredemo ‘[[**]]’ a
=================================================================
==5741==ERROR: AddressSanitizer: heap-buffer-overflow on address
0x60700000dff7 at pc 0x00000040b97b bp 0x7ffd1aaee380
sp 0x7ffd1aaee370
WRITE of size 1 at 0x60700000dff7 thread T0
#0 0x40b97a in compile_regex (/pcre-6.2/pcredemo+0x40b97a)
#1 0x40f585 in pcre_compile2 (/pcre-6.2/pcredemo+0x40f585)
#2 0x40c73c in pcre_compile (/pcre-6.2/pcredemo+0x40c73c)
#3 0x40132f in main /pcre-6.2/pcredemo.c:76
#4 0x7f46ea7d982f in __libc_start_main (/lib/x86_64-linux-
gnu/libc.so.6+0x2082f)
#5 0x400fd8 in _start (/pcre-6.2/pcredemo+0x400fd8)
.
Again we have a very similar report than what Valgrind gave, but AddressSanitizer
exits the program instantly when an issue is detected, so we are not detecting the
second (related) problem.
6.8 Summary
Fuzzing without watching for errors will not find vulnerabilities. Furthermore, it
is important to understand the types of errors you can expect to find with fuzzing.
We discussed some of the more common security vulnerabilities and how you might
detect them. We then outlined some of the various methods. These methods include
sending valid test cases between fuzzed inputs, monitoring system resources, both
locally and remotely, as well as changing the way the application executes. The closer
you monitor the target, and the more sophisticated tools used for the monitoring,
the more likely you will find those hard-to-locate vulnerabilities.
6760 Book.indb 201 12/22/17 10:50 AM
6760 Book.indb 202 12/22/17 10:50 AM
C h a p t e r 7
Advanced Fuzzing
So far, we’ve talked about how to set up fuzzing and some of the problems you may
run into. One of the themes of the book is that intelligent, generation-based fuzz-
ing is most effective but can take a tremendous amount of effort and time to set
up. This chapter discusses some advanced research topics and trends on the field
of fuzz testing. The first topic we present attempts to automatically determine the
structure of protocols, both network and file formats, removing this obstacle to
generation-based fuzzing. The other topics we discuss are different approaches at
trying to utilize the information from the application itself to improve test-case gen-
eration. For example, by knowing which paths through a program a particular set
of fuzzed inputs took, can we use that information to generate even better inputs?
Then we discuss trending tools for code coverage guided fuzz testing. And last, we
discuss the topic of cloud fuzzing frameworks.
7.1 Automatic protocol Discovery
Generation of model-based fuzzers is time-consuming. But imagine if a tool could
simply watch data being consumed by an application, automatically determine the
type of each data, and insert appropriate smart fuzz tests into the messages. For
example, take some data from a file or network protocol that looks like this:
“\x01\x00\x0aGodisGood\n”
From this data it is probably clear that 01 = type, 000a = length, and
“GodisGood\n” is the data. However, note that a “\n” is a \x0a in hex (see an
ASCII/HEX table if this is unclear; “man ascii” in Linux). Thus, it can be a bit chal-
lenging for prefuzzing parsing code to automatically determine the types. There are
multiple ways to deal with this issue. For example, tokAids in GPF allow the tester
to inform GPF how to tokenize stored sessions. But, since it’s easier for humans to
perform pattern recognition than computers, a graphical tool could be constructed
that would allow for field tagging.1 One could pop open a file or network capture,
highlight each field, and manually mark it accordingly. This would likely end up
more accurate than computer-generated code.
1 Charlie Miller has developed such a tool.
203
6760 Book.indb 203 12/22/17 10:50 AM
204 Advanced Fuzzing
Some work has been done to try to automate this to discover such protocols.
PolyGlot is one such work.2 This tool watches as a program consumes an input.
Based on the assembly instructions used to read bytes from the data stream,
some basic grouping of the input can be made. For example, does the program
treat a particular section of bytes as a byte, word, or dword? Next, by watching
how these bytes are processed within the control flow graph of the program, these
individual elements (bytes, words, dwords) can be grouped into structures. For
example, if a function loops, and in each loop 2 bytes and 4 dwords are consumed,
it can be assumed that those 18 bytes belong together in some fashion. The authors
of the paper use the tool to successfully automatically reverse engineer a number of
network protocols including DNS, HTTP, IRC, SMB, and ICQ.
Another example of automated protocol discovery is included with the com-
mercial beSTORM fuzzer. It does this by examining the valid test cases or inputs.
It automatically tries to find length value pairs in binary data and can decode
protocols based on ASN.1 (more on this in Chapter 8). It tries many models and
assigns percentages to how much of the structure it can account for in the actual
data. For text-based inputs, it can break apart the data based on a number of dif-
ferent separators (for example, Tab, Comma) as well as user-defined separators. It
has custom modules for those inputs based on HTTP and XML. Finally, it provides
a graphical user interface to help the tester describe the protocol (i.e., specify the
location of length fields).
7.2 Automatic Generation of a Model-Based Fuzzer
As described in Chapter 5, there are fundamental differences between model-based
fuzzing and sample-based fuzzing. Sample-based fuzzing tools rarely understand
the type and semantics of the data elements, and as explained in Section 7.1, some
automation of this is possible. Understanding message sequences, data structures,
and data syntax has been built into tools such as network analyzers. Could this
information be used to generate smart model-based fuzzers? Such a tool, called
Traffic Capture Fuzzer, was released by Codenomicon in 2009.3
This section is structured based on information provided by Tuomo Untinen
from Synopsys, and describes the use of current Defensics SDK as a framework for
creating a model-based fuzzer from network capture samples such as PCAP record-
ings. This allows combining the best benefits from both model-based and sample-
based approaches through creation of a quick and simple behavioral model from the
samples, resulting in more effective fuzz test cases for specific target compared to
dumb mutation tests with no understanding of the semantics or syntax of the tested
interface. The tests can also reach areas that pure specification-based models would
2 J. Caballero, H. Yin, Z. Liang, D. Song, “Polyglot: Automatic Extraction of Protocol Message For-
mat Using Dynamic Binary Analysis,” In Proceedings of the 14th ACM Conference on Computer
and Communication Security, Alexandria, VA, October 2007.
3 http://www.businesswire.com/news/home/20091105006102/en/Codenomicon-Releases-Software
-Based-General-Purpose-Security.
6760 Book.indb 204 12/22/17 10:50 AM
7.2 Automatic Generation of a Model-Based Fuzzer 205
not reach as the captured samples could contain vendor-specific data and features
that might not be available in publicly known protocol or file format specifications.
7.2.1 Defensics SDK with Suite Wizard
The Suite Wizard is part of the Defensics SDK, and is a tool that reads a PCAP
capture of the network traffic with Wireshark’s4 TShark tool, and creates a PDML
model from the network capture. Wireshark dissectors are used to creating the
structural model for the protocol messages, and therefore if Wireshark does not
recognize the protocol then created model will be very simple. On the other hand,
for proprietary protocols a custom dissector for Wireshark can be created and used
when creating the model.
Defensics SDK with Suite Wizard also creates sequences based on the network
capture. This is done on the message level, so it can recognize TCP and UDP mes-
sages as would Wireshark. The same goes as well for any other message levels.
Suite Wizard is also able to create stub Java or Python project depending on which
programming language you prefer to use. Suite Wizard tries to recognize possible
rule positions from field names such as length values or check-sums. It also tries to
recognize length and count fields and marking a comment on the location of rec-
ognized fields. After this stub project for Fuzzer has been created it is much easier
to start editing the protocol fuzzer as needed.
7.2.2 Example project Created with Suite Wizard
Project will consist of four or five files depending on programming language and
settings. For Java projects Suite Wizard can create build.gradle file to help build-
ing the Java project and creating IDE integrations automatically (see Figure 7.1).
README.md file contains generic information about the project, how to run
the new fuzzer, and how to pack it into distributable form. This file is written in
Markdown, which is used in modern wiki systems (see Figure 7.2).
The third file is the properties file, which is used when packing the new fuzzer
into distributable form. Properties file tells the packer where to find compiled class
files or Python scripts. This file also tells where to find the SDK JAR file (the generic
Defensics engine code), the SDK suite file (the fuzzer-specific code), and the required
fuzzer resource files. The properties file also contains the fuzzer name and version
(see Figure 7.3).
The fourth file is the actual model file. This model is now generated based on
the network capture file, and it contains comments where the Suite Wizard assumes
that there could be dynamic data such as those generated by length or count rules.
Placing all the rules is responsibility of the fuzzer developer (see Figure 7.4).
The fifth file is the Python or Java file. This file extends the FuzzerBuilder class.
FuzzerBuilder is the main class for creating a new fuzzer with Defensics SDK. This
file specifies which model files needs to be loaded and what kind of settings are
4 https://www.wireshark.org/.
6760 Book.indb 205 12/22/17 10:50 AM
206 Advanced Fuzzing
Figure 7.1 Example of build.gradle generated from HTTP traffic capture.
Figure 7.2 Example of README.md file generated by Suite Wizard.
6760 Book.indb 206 12/22/17 10:50 AM
7.2 Automatic Generation of a Model-Based Fuzzer 207
Figure 7.3 Example of properties file generated by Suite Wizard.
Figure 7.4 Example of an HTTP model generated from an HTTP traffic capture.
6760 Book.indb 207 12/22/17 10:50 AM
208 Advanced Fuzzing
needed for the fuzzer. Class file includes the test sequence that was created accord-
ing to the sequences seen in the network capture file (see Figure 7. 5).
7.2.3 Fuzzer Modeling
Defensics SDK uses a variant of Backus-Naur Form (BNF) for modeling. This
is very close to ABNF,5 which is used in many RFCs for example for the HTTP
specification. Everything done in ABNF can be done also with Defensics BNF and
converting from ABNF is pretty straightforward. There are just minor changes in
syntax. For example, the symbol in ABNF is “/” and in Defensics it is “|”. Strings
and characters in ABNF are inside double quotes but in Defensics they are in single
quotes. Binary values in ABNF are presented with %xNN and NN is hexadecimal
value of byte. In Defensics BNF these are presented with 0xNN. Using RFCs where