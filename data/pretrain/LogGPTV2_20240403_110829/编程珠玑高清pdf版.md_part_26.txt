return n
report函数在O(n）时间内将所有元素（除了标记元素）复制到输出数组中：
void report(v)
for=[0，n)
v[i] =x[1]
如果事先知道集合的大小，那么数组这种结构用来比较适合实现集合。因为数组是
有序的，所以能用二分查找建立-个运行时间为O(logn)的成员函数。在本节结尾部分
将详细讨论数组的运行时间，
bbs.theithome.com
---
## Page 143
第13章查找
129
如果事先不知道集合的大小，那么链表将是表示集合的首选：链表消除了插入时元
素移动的成本。
he639
类IntSetList将使用该私有数据：
private:
int n;
struct node 
int val;
node +next;
node(int v, node *p){val = v; next = p;}
node whead，+sentinel;
链表中的每个结点都具有一个整型值和--个指向链表中下一结点的指针。Node构造函数
将其两个参数的值赋给那两个字段。
跟有序数组的原理一样，链表也必须有序。就像在数组中一样，链表将使用标记结
点，它的值大于所有真实的值。构造函数建立这样-一个结点，并让head指向它。
IntSetList(maxelements,maxval)
sentinel=head= new node(maxva1,0)
0=u
report函数遍历链表，将排好序的元素放在输出向量中：
void report(int v)
j =0
for (p =head;p 1= sentinel;p = p->next)
[Avalnext =rinsert(p->next，t)
else if p->val > t
p = new node(t， p)
n++
return p
bbs.theithome.com
---
## Page 144
130
第3部分产品
当编程问题隐藏在众多特殊情况下，使用递归通常能够简化代码，如上所示。
当使用上面两个结构生成m个随机整数时，平均来说，m个查找中的每一次运行时
间和m成正比。因此，每个结构的总时间和m²成正比。我认为链表版本要比数组版本
相对快一些：它使用了额外的空间（指针用的）米避免超出数组的上界。下面是n为
1000000，m为10000到40000之间时的运行时间：
结构
集合大小（m）
10000
20000
40000
数组
0.6
2.6
11.1
简单链表
5.7
31.2
170.0
链表（消除递归）
1.8
12.6
73.8
链麦（组分配）
1.2
5.7
25.4
跟我所预计的一样，数组的运行时间成平方数增加，带有一个非常合理的常量。但
是我实现的第一个链表，其开始时的增长幅度小于数组，但后来增长得比n要快。
肯定有哪个地方存在问题。
我的第一个反应就是将问题归结于递归。除了递归调用的开销外，rinsert函数的
递归深度就是找到元素的位置，为O（n）。在整个递归中，代码将原来的值赋回给几乎
所有的指针。当我将递归函数转换成答案4中介绍的选代版本时，运行时间几乎降低了
3倍。
我的下一个反应就是使用问题5中的技术改变存储分配：构造函数分配了一个具有
m个结点的单个块，insernt根据需要获取它们，而不是为每个插入分配一个新的结点。
这在下面两个不同的方面都是很大的改进：
附录3中的时间成本模型表明跟简单的操作相比，存储分配所消耗的时间要高出两
个数量级。我们使用一个操作替换掉了m个昂贵的操作。
附录3中的空间成本模型表明，如果将结点作为块来分配，每个结点只需消耗8个
字节（4个用于整数，4个用于指针）：40000个结点消耗320个千字节，我机器的二级
缓存正好够用。然面，如果单独分配结点，则每个结点就要消耗48个字节，它们总共要
消耗1.92兆字节，这超出了二级缓存的容量。
在具有更高效率的分配器的不同系统中，消除递归能够将加速系数变为5，但是当
使用单独分配仅能减少10%。类似于很多代码优化技巧，缓存和递归消除有时会带来很
多好处，但是有的时候却没什么用处。
数组插入算法查找整个队列，以找到插入目标值的合适位置，然后再压入更大的值。
链表插入算法只完成了第一部分，并没有完成第二部分。所以，如果链表只是完成了一
bbs.theithome.com
---
## Page 145
第13章查找
131
半工作，那为什么它需要两倍的时间呢？部分原因是它需要两倍的内存：大链表必须将
8个字节的结点读入高速缓存以便来访问4个字节的整数。另一部分原因是，可以很容
易地预测数组对数据的访问，而链表的访问模式则可能占用所有的内存。
13.3二分查找树
下面要从线性结构转向支持快速查找和播入的结构。下图是插入整数31、41、59
和26之后的二分查找树，顺序为：
root:
59
IntSetBST类定义了结点和根：
private:
int n，*v, vn;
struct node {
int va1;
node 1eft，*right;
node（int i){val=i;left=right =0;}
}；
node +root;
初始化该树的时候将根设为空，并通过调用递归函数执行其他操作。
IntSet8ST（int maxelements, int maxval){root=0:n =0;}
voidinsert（int t){root=rinsert（root,t);}
voidreport（int+x){vx;vn=0;traverse（root);}
插入函数遍历这棵树，直到找到所需的值（查找结束），或在整棵树中没有找到所
需的值（插入结点）：
node rinsert(p，t)
1f p  0
p= new node(t)
else if t val
n++
p->left =rinsert(p->left，t)
else if t > p->val
p->right =rinsert(p->right，t)
// do nothing if p->val == t
return p
bbs.theithome.com
---
## Page 146
132
第3部分产品
由于应用程序中的元素是按随机顺序插入的，所以不用担心复杂的平衡方法（问题1表
明随机集合上的其他算法会导致树的极大不平衡）。
inorder遍历首先处理左子树，然后输出结点本身，接着处理右子树：
void traverse(p)
1f p == 0
return
traverse(p->left)
v[vn++]=p->va]
traverse(p->right)
它使用变量vn来索引向量v中下一个可用元素。
这张表给出了在第13.1节中看到的STLset结构、二分查找树以及下一节中要介绍
的其他几个结构的运行时间（这是我机器上运行的情况）。最大的整数为n=10，m可以
尽可能地大，直到系统内存不够而必须使用磁盘时为止。
集合大小（m）
结构
1000000
5000000
10000000
秒
MB
秒
MB
秒
MB
STL（标准模板库）
9.38
72
二分查找树
7.30
56
二分查找树*
3.71
16
25.26
08
桶
2.36
60
植*
1.02
16
5.55
80
位向量
3.72
16
5.70
32
8.36
52
这些时间都没有包含输出结果的时间，包含了输出结果后的时间要略微大于STL实现所
需的时间。简单的二分查找树避免了STL所使用的复杂的平衡方法（STL规范能够保证
在最差情况下获得较好的性能），因此，它会稍微快一些，同时使用的空间也更少一些。
当m=1600000时，STL就开始崩溃了，而第一个BST则在m=1900000时崩溃。标为“BST*
的行介绍了结合几个优化后的二分查找树运行情况。最重要的是它一下子就分配所有的
结点（如问题5）。这就大大降低了树的空间需求，运行时间大致降低了三分之一。该代
码也将递归转化为选代（如问题4），同时使用了问题7中介绍的标记结点，这些大概能
提速25%
没有了，然后我款贵怪写优化器的人、后来我发现，问题出在，当我快道编写遍历代码时，我忘了对p造行是否为mal
的证判新，优化暴尽量将尾谣归转化为循环，当不能找到一个判断终止循环时款会死捕。
bbs.theithome.com
---
## Page 147
第13章查找
133
13.4整数结构
下面来介绍最后两个现实中常用的结构，它们利用集合来代表整数。位向量是第1
章的老内容了，下面是它们的私有数据和函数：
enum{BITSPERWORD=32,SHIFT-5,MASK=Ox1F }:
int n,hi，*x;