e depend on a randomly sampled encryption key. If Z can
The commitment values câˆ—, râˆ—
obtain the value zâˆ— and decrypt it to xâˆ— (cid:54)= x, it can distinguish the executions. Since the
underlying commitment scheme used to generate câˆ— fullls the hiding property, Z cannot
retrieve zâˆ— from these commitment values. Thus, Z cannot distinguish the two executions
based on these commitment values.
In the second round, honest Seller may abort the protocol execution. In this case, FL
icfe
leaks (abort, id,S) to Sim, which internally runs (aborted, id) â† GL,H
(abort, id). In the
hybrid world and in the ideal world, the abort- and aborted -messages are identical and hence
indistinguishable. Furthermore, honest Buyer B outputs the message (aborted, id) towards
Z, which equals the message (aborted, id) sent from FL
icfe to Z through ËœB in case of the
abort.
Instead of Seller's abort, Buyer may accept the exchange oer. By providing a (buy, id, Ï†)-
message to B, Z initiates the acceptance. Honest Buyer sends a (accept, id)-message to
GL,H
outputs (initilized, id). The exact same messages are
generated by Sim in the ideal world by running (initialized, id) â† GL,H
(accept, id). Hence,
Z cannot distinguish the executions in the second round.
Honest Buyer may abort the protocol execution in the third round. The result in the
protocol execution Î  is S outputting (aborted, id) and terminating. Sim simulates the same
messages exchanged with GL,H
after FL
icfe leaks (abort, id,B) and terminates the simulation.
Again, the ideal functionality FL
icfe sends (aborted, id) to Z through ËœS, which guarantees the
same output behavior.
If Buyer does not abort the execution in the third round, honest Seller reveals his encryption
key. He sends (reveal, id, k, d) to GL,H
, where Open(c, d, k) = 1. Sim simulates the key reveal-
â†
running
ing
GL,H
(reveal, id, kâˆ—, dâˆ—), where Open(câˆ—, dâˆ—, kâˆ—) = 1. Since both keys k and kâˆ— are sampled
randomly using the Gen-algorithm, Z cannot distinguish between the two keys. It might be
possible to use the commitment values râˆ—
e from the initialization-phase to extract further
information. Since the opening values for these two Merkle tree commitments are not re-
vealed by honest Seller, it requires to break the hiding property of the commitment scheme
in order to gain additional information.
Honest Buyer also outputs the obtained witness x in the third round of the protocol exe-
cution. The ideal functionality FL
icfe sends the value set by Z at the beginning of the ideal
world execution to the dummy Buyer, which forwards the value. In both cases, Z receives
the value set as input to S and ËœS, respectively.
(revealed, id, kâˆ—, dâˆ—)
z , râˆ—
by
jc
jc
jc
jc
and outputs (bought, id, x).
jc
In round 4, honest Buyer sends a (f inalize, id)-message to GL,H
jc
Honest Seller receives a message from GL,H
and outputs (sold, id). Both output messages
are sent by FL
icfe in the ideal world and Sim simulates the judge smart contract. Hence, the
identical messages are sent within this round. After these messages, the hybrid world and
the ideal world terminate the execution.
It remains to show that the money is locked and unlocked in the same rounds. In the
protocol Î , p coins are locked from Buyer B in the second round if B accepts the fair
exchange oer. The acceptance is signaled by the (buy, id, Ï†)-message and is successfully
executed only if B has enough funds. In the ideal world, the ideal functionality FL
icfe freezes p
coins in the second round after it received a (buy, id, Ï†)-message from B. Again, the money
is only locked if B controls enough money. If honest Buyer aborts in round 3 before the
encryption key is revealed, the money is transferred back to B by GL,H
in the hybrid world
jc
36
jc
icfe unlocks the money in favor of S in round 4.
and by FL
icfe in the ideal world. After the encryption key is revealed, the money can only be
unlocked in favor of honest Seller, since he provided a correct witness. In the hybrid world,
GL,H
sends the money to S in round 4 after it received the (f inalize, id)-message from B.
In the ideal world, FL
Finally, it is easy to see that the simulator Sim dened before runs in polynomial time.
After all, when considering an environment Z that does not corrupt any party, it is shown
that there exists an ecient simulator such that no environment can distinguish between the
execution of the hybrid world and the execution of the ideal world. It is shown that the money
is locked and unlocked in the same rounds and the environment Z cannot distinguish the
transcripts of both executions unless it breaks the hiding property of the used commitment
schemes.
Simulation with Corrupted Seller
When considering a corrupted Seller, its internal state and program code is fully under the
control of the environment Z. Especially, corrupted Seller Sâˆ— may deviate from the protocol
at any point in time during the protocol execution. In the ideal world, the simulator SimS
becomes more complex. In addition to simulate the execution of protocol Î  and generating a
transcript of this execution, he needs to create all outputs of the corrupted Seller ËœSâˆ— towards
the environment Z and towards the ideal functionality FL
icfe. In particular, each input sent
from Z to the corrupted dummy party ËœSâˆ— is forwarded by ËœSâˆ— to SimS . When receiving an
input from Z through ËœSâˆ—, the simulator needs to create the input to FL
icfe.
In the following, a detailed simulator SimS is given and it is argued why this simulator
achieves indistinguishability. Since a corrupted Seller is also able to follow the protocol
throughout the whole execution, it is not argued that the simulation works in this case,
which is identical to the honest case. This means, the dierences between the honest case as
described beforehand and the case of a corrupted Seller are emphasized. The proof makes
use of the observability features of the global random oracle H. The same trick is used in
the proof in [14].
Claim. There exists an ecient algorithm SimS such that for all ppt environments Z that
only corrupt the Seller it holds that the execution of Î  in the (GL,H
,L,H)-hybrid world in
presence of adversary A is computationally indistinguishable from the ideal world execution
of FL
icfe with the ideal adversary SimS .
jc
Proof. To show indistinguishability a sequence of games is used as explained at the be-
ginning of this section. Before presenting Game2, which equals the ideal world execution,
Game1 is given, which represents a hybrid simulation with the usage of SimS
1 . In addition
to controlling the inputs and outputs of the corrupted Seller, SimS
1 also controls inputs and
outputs of the honest Buyer. This simplication is eliminated in Game2, which makes use
of the full simulator SimS .
The construction of simulator SimS
1 is given in the following. This simulator is used in
Game1. Furthermore, it is shown that no ppt environment Z can distinguish between the real
1 , i.e., Game0 â‰ˆ Game1. Afterwards,
world execution and the hybrid simulation using SimS
the full simulator SimS is stated to construct Game2, which equals the ideal world execution.
Again, indistinguishability between Game1 and Game2 is shown, i.e., Game1 â‰ˆ Game2. At
the end, the two results can be merged to show that the real world execution is indistin-
guishable from the ideal world execution.
The structure of this proof is strongly related to the proof of the malicious Seller scenario
in [14] and is deliberately chosen to simplify the comparison and readability of the following
proof. The dierences are highlighted explicitly.
37
Simulator SimS
1 for hybrid simulation with corrupted Seller.
received
jc
jc
jc
1
ËœSâˆ—,
jc
jc
(accept, id).
jc
SimS
1
SimS
1
through
Furthermore,
1. Upon receiving (sell, id, z, Ï†) through ËœSâˆ— in the rst round, SimS
3. If ËœB aborts the execution in the third round, FL
2. Upon receiving (abort, id) through ËœSâˆ— in the second round, SimS
1 terminates the simulation.
1 sends (abort, id)
(abort, id)
1 receives (buy, id, ËœB) from FL
sam-
(initialize, id, c, rz, re, rÏ†, aÏ†, p, fS , fB)
If message
also
1
round
sends
to FL
simulates
icfe.
execution of Î  by running (active, id, c, rz, re, rÏ†, aÏ†, p, fS , fB) â†
(initialize, id, c, rz, re, rÏ†, aÏ†, p, fS , fB).
ples xâˆ— â† {0, 1}nÃ—Î».
is
in
(sell-f ake, id, xâˆ—, Ï†, p, fS , fB)
the
GL,H
If not both messages sell and initialize are received through ËœSâˆ— in round one,
the SimS
to FL
and terminating the simulation.
If SimS
acceptance of ËœB by running (initialized, id) â† GL,H
icfe. Furthermore, he simulates Î  by running (aborted, id) â† GL,H
1 simulates the abort by executing (aborted, id) â† GL,H
icfe in the second round, he simulates the
icfe leaks (abort, id, ËœB) to SimS
1 .
Then, SimS
(abort, id)
and terminating the simulation.
Upon receiving (reveal, id, k, d) from ËœSâˆ— in round 3 such that Open(c, d, k) =
1, SimS
1 simulates the revealing of the encryption key. Therefore, he runs
(revealed, id, k, d) â† GL,H
icfe sends
(revealed, id, xâˆ—) to ËœB. Since SimS
1 controls the inputs and outputs of ËœB, he re-
places the message (revealed, id, xâˆ—) with (revealed, id, x), where x = Dec(k, z).
If no message (reveal, id, k, d) from ËœSâˆ— is received in round 3 such that
icfe in the name of ËœSâˆ— and waits
Open(c, d, k) = 1, SimS
one round. Then, he simulates the refund to ËœB by running (aborted, id) â†
GL,H
honest Buyer within the real world by running (sold, id) â† GL,H
sending (abort, id, 0) in the name of ËœB to FL
Ï†(x) (cid:54)= 1, SimS
he sets R = âˆ… and executes the following steps alternately starting with (a):
(a) SimS
1 simulates the nalization of the fair exchange executed by
(f inalize, id),
icfe, and terminating. Otherwise, if
1 needs to simulate the dispute resolution sub-protocol. Therefore,
(reveal, id, k, d). In the same round, FL
1 sends (abort, id) to FL
(abort, id) and terminating the simulation.
4. If Ï†(x) = 1, SimS
jc
jc
(b) Upon receiving (respond, id, Rq) from ËœSâˆ—, SimS
1 checks whether or not honest Buyer is able to generate a valid proof
of misbehavior by computing Ï€ â† GenerateProof(k, Ï†, R). If Ï€ (cid:54)= false, SimS
1
simulates a valid proof of misbehavior by running GL,H
(prove, id, Ï€), send-
ing (abort, id, 0) in the name of ËœSâˆ— to FL
icfe, outputting (not sold, id) through
ËœSâˆ—, and terminating the simulation. Otherwise, if Ï€ = false, SimS
1 com-
putes Q â† NextChallenge(Ï†, R) and simulates a challenge query by running
(challenged, id, Q) â† GL,H
(challenge, id, Q). He sends (f reeze, id, ËœB,|Q|) to
FL
icfe, sets Qr = Q, and continues with step (b) in the next round.
1 runs (responded, id, Rq) â†
GL,H
icfe, and waits one
round. If ValidateResponse(Qr, Rq, re) = true, SimS
1 continues immediately
with step (a). Otherwise, if ValidateResponse(Qr, Rq, re) = false, he simulates
a complain-message by running GL,H
1 un-
locks the coins in favor of ËœB by sending (abort, id, 0) in the name of corrupted
Seller ËœSâˆ— to FL
icfe. Then, he outputs (not sold, id) through ËœSâˆ— and terminates
the simulation.
If no (respond, id, Rq) message is received from ËœSâˆ—, SimS sends (abort, id, 1)
(respond, id, Rq), sends (f reeze, id, ËœSâˆ—,|Rq|) to FL
(complain, id). Furthermore, SimS
jc
jc
jc
38
ËœSâˆ—
to FL
icfe and waits one round. Then, he runs
(respond timeout, id), outputs (not sold, id) through ËœSâˆ—, and terminates
in the name of
GL,H
the simulation.
jc
jc
jc
By internally running the hybrid functionality GL,H
In round 1, SimS
on either inputs given from Z or
honest Buyer B, the generated transcript and outputs are identical in both executions.
1 forwards the sell -message received from ËœSâˆ— to Buyer and uses the
initialize-message to run GL,H
. Moreover, he creates a sell-fake-message which is sent to
FL
icfe. The value xâˆ— sent within this message does not necessarily have to be the decryption
of z, since the (revealed, id, xâˆ—)-message in round 3 is replaced by (revealed, id, x), where
x = Dec(k, z). This means, the witness received by the honest Buyer is set by the simulator
after Seller revealed his key in round 3. Therefore, the environment Z only sees the correct