e depend on a randomly sampled encryption key. If Z can
The commitment values c∗, r∗
obtain the value z∗ and decrypt it to x∗ (cid:54)= x, it can distinguish the executions. Since the
underlying commitment scheme used to generate c∗ fullls the hiding property, Z cannot
retrieve z∗ from these commitment values. Thus, Z cannot distinguish the two executions
based on these commitment values.
In the second round, honest Seller may abort the protocol execution. In this case, FL
icfe
leaks (abort, id,S) to Sim, which internally runs (aborted, id) ← GL,H
(abort, id). In the
hybrid world and in the ideal world, the abort- and aborted -messages are identical and hence
indistinguishable. Furthermore, honest Buyer B outputs the message (aborted, id) towards
Z, which equals the message (aborted, id) sent from FL
icfe to Z through ˜B in case of the
abort.
Instead of Seller's abort, Buyer may accept the exchange oer. By providing a (buy, id, φ)-
message to B, Z initiates the acceptance. Honest Buyer sends a (accept, id)-message to
GL,H
outputs (initilized, id). The exact same messages are
generated by Sim in the ideal world by running (initialized, id) ← GL,H
(accept, id). Hence,
Z cannot distinguish the executions in the second round.
Honest Buyer may abort the protocol execution in the third round. The result in the
protocol execution Π is S outputting (aborted, id) and terminating. Sim simulates the same
messages exchanged with GL,H
after FL
icfe leaks (abort, id,B) and terminates the simulation.
Again, the ideal functionality FL
icfe sends (aborted, id) to Z through ˜S, which guarantees the
same output behavior.
If Buyer does not abort the execution in the third round, honest Seller reveals his encryption
key. He sends (reveal, id, k, d) to GL,H
, where Open(c, d, k) = 1. Sim simulates the key reveal-
←
running
ing
GL,H
(reveal, id, k∗, d∗), where Open(c∗, d∗, k∗) = 1. Since both keys k and k∗ are sampled
randomly using the Gen-algorithm, Z cannot distinguish between the two keys. It might be
possible to use the commitment values r∗
e from the initialization-phase to extract further
information. Since the opening values for these two Merkle tree commitments are not re-
vealed by honest Seller, it requires to break the hiding property of the commitment scheme
in order to gain additional information.
Honest Buyer also outputs the obtained witness x in the third round of the protocol exe-
cution. The ideal functionality FL
icfe sends the value set by Z at the beginning of the ideal
world execution to the dummy Buyer, which forwards the value. In both cases, Z receives
the value set as input to S and ˜S, respectively.
(revealed, id, k∗, d∗)
z , r∗
by
jc
jc
jc
jc
and outputs (bought, id, x).
jc
In round 4, honest Buyer sends a (f inalize, id)-message to GL,H
jc
Honest Seller receives a message from GL,H
and outputs (sold, id). Both output messages
are sent by FL
icfe in the ideal world and Sim simulates the judge smart contract. Hence, the
identical messages are sent within this round. After these messages, the hybrid world and
the ideal world terminate the execution.
It remains to show that the money is locked and unlocked in the same rounds. In the
protocol Π, p coins are locked from Buyer B in the second round if B accepts the fair
exchange oer. The acceptance is signaled by the (buy, id, φ)-message and is successfully
executed only if B has enough funds. In the ideal world, the ideal functionality FL
icfe freezes p
coins in the second round after it received a (buy, id, φ)-message from B. Again, the money
is only locked if B controls enough money. If honest Buyer aborts in round 3 before the
encryption key is revealed, the money is transferred back to B by GL,H
in the hybrid world
jc
36
jc
icfe unlocks the money in favor of S in round 4.
and by FL
icfe in the ideal world. After the encryption key is revealed, the money can only be
unlocked in favor of honest Seller, since he provided a correct witness. In the hybrid world,
GL,H
sends the money to S in round 4 after it received the (f inalize, id)-message from B.
In the ideal world, FL
Finally, it is easy to see that the simulator Sim dened before runs in polynomial time.
After all, when considering an environment Z that does not corrupt any party, it is shown
that there exists an ecient simulator such that no environment can distinguish between the
execution of the hybrid world and the execution of the ideal world. It is shown that the money
is locked and unlocked in the same rounds and the environment Z cannot distinguish the
transcripts of both executions unless it breaks the hiding property of the used commitment
schemes.
Simulation with Corrupted Seller
When considering a corrupted Seller, its internal state and program code is fully under the
control of the environment Z. Especially, corrupted Seller S∗ may deviate from the protocol
at any point in time during the protocol execution. In the ideal world, the simulator SimS
becomes more complex. In addition to simulate the execution of protocol Π and generating a
transcript of this execution, he needs to create all outputs of the corrupted Seller ˜S∗ towards
the environment Z and towards the ideal functionality FL
icfe. In particular, each input sent
from Z to the corrupted dummy party ˜S∗ is forwarded by ˜S∗ to SimS . When receiving an
input from Z through ˜S∗, the simulator needs to create the input to FL
icfe.
In the following, a detailed simulator SimS is given and it is argued why this simulator
achieves indistinguishability. Since a corrupted Seller is also able to follow the protocol
throughout the whole execution, it is not argued that the simulation works in this case,
which is identical to the honest case. This means, the dierences between the honest case as
described beforehand and the case of a corrupted Seller are emphasized. The proof makes
use of the observability features of the global random oracle H. The same trick is used in
the proof in [14].
Claim. There exists an ecient algorithm SimS such that for all ppt environments Z that
only corrupt the Seller it holds that the execution of Π in the (GL,H
,L,H)-hybrid world in
presence of adversary A is computationally indistinguishable from the ideal world execution
of FL
icfe with the ideal adversary SimS .
jc
Proof. To show indistinguishability a sequence of games is used as explained at the be-
ginning of this section. Before presenting Game2, which equals the ideal world execution,
Game1 is given, which represents a hybrid simulation with the usage of SimS
1 . In addition
to controlling the inputs and outputs of the corrupted Seller, SimS
1 also controls inputs and
outputs of the honest Buyer. This simplication is eliminated in Game2, which makes use
of the full simulator SimS .
The construction of simulator SimS
1 is given in the following. This simulator is used in
Game1. Furthermore, it is shown that no ppt environment Z can distinguish between the real
1 , i.e., Game0 ≈ Game1. Afterwards,
world execution and the hybrid simulation using SimS
the full simulator SimS is stated to construct Game2, which equals the ideal world execution.
Again, indistinguishability between Game1 and Game2 is shown, i.e., Game1 ≈ Game2. At
the end, the two results can be merged to show that the real world execution is indistin-
guishable from the ideal world execution.
The structure of this proof is strongly related to the proof of the malicious Seller scenario
in [14] and is deliberately chosen to simplify the comparison and readability of the following
proof. The dierences are highlighted explicitly.
37
Simulator SimS
1 for hybrid simulation with corrupted Seller.
received
jc
jc
jc
1
˜S∗,
jc
jc
(accept, id).
jc
SimS
1
SimS
1
through
Furthermore,
1. Upon receiving (sell, id, z, φ) through ˜S∗ in the rst round, SimS
3. If ˜B aborts the execution in the third round, FL
2. Upon receiving (abort, id) through ˜S∗ in the second round, SimS
1 terminates the simulation.
1 sends (abort, id)
(abort, id)
1 receives (buy, id, ˜B) from FL
sam-
(initialize, id, c, rz, re, rφ, aφ, p, fS , fB)
If message
also
1
round
sends
to FL
simulates
icfe.
execution of Π by running (active, id, c, rz, re, rφ, aφ, p, fS , fB) ←
(initialize, id, c, rz, re, rφ, aφ, p, fS , fB).
ples x∗ ← {0, 1}n×λ.
is
in
(sell-f ake, id, x∗, φ, p, fS , fB)
the
GL,H
If not both messages sell and initialize are received through ˜S∗ in round one,
the SimS
to FL
and terminating the simulation.
If SimS
acceptance of ˜B by running (initialized, id) ← GL,H
icfe. Furthermore, he simulates Π by running (aborted, id) ← GL,H
1 simulates the abort by executing (aborted, id) ← GL,H
icfe in the second round, he simulates the
icfe leaks (abort, id, ˜B) to SimS
1 .
Then, SimS
(abort, id)
and terminating the simulation.
Upon receiving (reveal, id, k, d) from ˜S∗ in round 3 such that Open(c, d, k) =
1, SimS
1 simulates the revealing of the encryption key. Therefore, he runs
(revealed, id, k, d) ← GL,H
icfe sends
(revealed, id, x∗) to ˜B. Since SimS
1 controls the inputs and outputs of ˜B, he re-
places the message (revealed, id, x∗) with (revealed, id, x), where x = Dec(k, z).
If no message (reveal, id, k, d) from ˜S∗ is received in round 3 such that
icfe in the name of ˜S∗ and waits
Open(c, d, k) = 1, SimS
one round. Then, he simulates the refund to ˜B by running (aborted, id) ←
GL,H
honest Buyer within the real world by running (sold, id) ← GL,H
sending (abort, id, 0) in the name of ˜B to FL
φ(x) (cid:54)= 1, SimS
he sets R = ∅ and executes the following steps alternately starting with (a):
(a) SimS
1 simulates the nalization of the fair exchange executed by
(f inalize, id),
icfe, and terminating. Otherwise, if
1 needs to simulate the dispute resolution sub-protocol. Therefore,
(reveal, id, k, d). In the same round, FL
1 sends (abort, id) to FL
(abort, id) and terminating the simulation.
4. If φ(x) = 1, SimS
jc
jc
(b) Upon receiving (respond, id, Rq) from ˜S∗, SimS
1 checks whether or not honest Buyer is able to generate a valid proof
of misbehavior by computing π ← GenerateProof(k, φ, R). If π (cid:54)= false, SimS
1
simulates a valid proof of misbehavior by running GL,H
(prove, id, π), send-
ing (abort, id, 0) in the name of ˜S∗ to FL
icfe, outputting (not sold, id) through
˜S∗, and terminating the simulation. Otherwise, if π = false, SimS
1 com-
putes Q ← NextChallenge(φ, R) and simulates a challenge query by running
(challenged, id, Q) ← GL,H
(challenge, id, Q). He sends (f reeze, id, ˜B,|Q|) to
FL
icfe, sets Qr = Q, and continues with step (b) in the next round.
1 runs (responded, id, Rq) ←
GL,H
icfe, and waits one
round. If ValidateResponse(Qr, Rq, re) = true, SimS
1 continues immediately
with step (a). Otherwise, if ValidateResponse(Qr, Rq, re) = false, he simulates
a complain-message by running GL,H
1 un-
locks the coins in favor of ˜B by sending (abort, id, 0) in the name of corrupted
Seller ˜S∗ to FL
icfe. Then, he outputs (not sold, id) through ˜S∗ and terminates
the simulation.
If no (respond, id, Rq) message is received from ˜S∗, SimS sends (abort, id, 1)
(respond, id, Rq), sends (f reeze, id, ˜S∗,|Rq|) to FL
(complain, id). Furthermore, SimS
jc
jc
jc
38
˜S∗
to FL
icfe and waits one round. Then, he runs
(respond timeout, id), outputs (not sold, id) through ˜S∗, and terminates
in the name of
GL,H
the simulation.
jc
jc
jc
By internally running the hybrid functionality GL,H
In round 1, SimS
on either inputs given from Z or
honest Buyer B, the generated transcript and outputs are identical in both executions.
1 forwards the sell -message received from ˜S∗ to Buyer and uses the
initialize-message to run GL,H
. Moreover, he creates a sell-fake-message which is sent to
FL
icfe. The value x∗ sent within this message does not necessarily have to be the decryption
of z, since the (revealed, id, x∗)-message in round 3 is replaced by (revealed, id, x), where
x = Dec(k, z). This means, the witness received by the honest Buyer is set by the simulator
after Seller revealed his key in round 3. Therefore, the environment Z only sees the correct