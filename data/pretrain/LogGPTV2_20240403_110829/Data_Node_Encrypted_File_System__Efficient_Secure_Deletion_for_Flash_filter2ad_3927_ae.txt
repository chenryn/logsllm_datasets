Since, with high probability, each
randomly-generated key in the KSA is unique, we
can use a block cipher in ECB mode to allow
rapid decryption of randomly accessed oﬀsets with-
out storing additional initialization vectors [20].
Encrypted storage media are already quite pop-
ular, as they provide conﬁdentiality of stored data
13
against computationally-bounded non-coercive at-
tackers, e.g., thieves, provided the master secret is
unavailable in volatile memory when the attack oc-
curs [13]. It is therefore important to oﬀer our en-
crypted ﬁle system design to avoid users doubly-
encrypting their data: ﬁrst as an encrypted ﬁle sys-
tem and then for secure deletion.
6 Related Work
Secure deletion for magnetic media is a well-
researched area. Various solutions exist at diﬀer-
ent levels of system integration. User-level solutions
such as shred [29] open a ﬁle and overwrite its en-
tire content with insensitive data. This requires that
the ﬁle system performs in-place updates, otherwise
old data still remains. As such, these solutions are
inappropriate for ﬂash memory.
Kernel-level secure deletion has been designed and
implemented for various popular block-structured
ﬁle systems [2, 17]. These solutions typically change
the ﬁle system so that whenever a block is discarded,
its content is ﬁrst sanitized before it is added to the
list of free blocks. This ensures that even if a ﬁle is
truncated or the user forgets to use a secure deletion
tool, the data is still sanitized. It is also beneﬁcial
for journalled ﬁle systems where in-place updates do
not immediately occur, so overwriting a ﬁle may not
actually overwrite the original content. The saniti-
zation of discarded blocks still requires in-place up-
dates, and is therefore inapplicable to ﬂash memory.
The use of encryption to delete data was originally
proposed by Boneh and Lipton [3], where they used
the convenience of deleting small encryption keys to
computationally-delete data from magnetic backup
tapes. Peterson et al. [28] used this approach to im-
prove the eﬃciency of secure deletion in a versioned
backup system on a magnetic storage medium. They
encrypt each data block with an all-or-nothing cryp-
tographic expansion transformation [33] and colo-
cate the resulting key-sized tags for every version of
the same ﬁle in storage. They use in-place updates
to remove tags, and keys are colocated to reduce
the cost of magnetic disk seek times when deleting
all versions of a single ﬁle. DNEFS also colocates
keys separately to improve the eﬃciency of secure
deletion. However, DNEFS is prohibited from per-
forming in-place updates, and our design focuses on
minimizing and levelling erasure wear.
Another approach is Perlman’s Ephemerizer [27],
a system that allows communication between par-
ties where messages are securely deleted in the pres-
ence of a coercive attacker. Data is encrypted with
ephemeral keys that are manged by the eponymous
trusted third party. Each message is given an ex-
piration time at creation, and an appropriate key
is generated accordingly. The Ephemerizer stores
the keys and provides them when necessary to the
communicating parties using one-time session keys.
When the expiration time passes, it deletes any ma-
terial required to create the key, thus ensuring se-
cure deletion of the past messages. Perlman’s work
is a protocol using secure deletion as an assumed
primitive oﬀered by the storage medium. Indeed, if
this approach is implemented on a ﬂash-based smart
card, DNEFS can be used to implement it.
Reardon et al. [32] have shown how to securely
delete data from log-structured ﬁle systems from
user-space—that is, without modifying the hardware
or the ﬁle system—provided that the user can ac-
cess the ﬂash directly and is not subjected to disk
quota limitations. Their proposal is to ﬁll the stor-
age medium to capacity to ensure that no wasted
space remains on the storage medium, thus ensuring
the secure deletion of data. This is a costly approach
in terms of ﬂash memory wear and execution time,
but from user-space it is the only solution possible.
They also showed that occupying a large segment of
the storage medium with unneeded data improves
the expected time deleted data remains on the stor-
age medium, and reduces the amount of space that
needs to be ﬁlled to guarantee deletion.
Swanson et al. [36] considered veriﬁable sanitiza-
tion for solid state drives—ﬂash memory accessed
through an opaque FTL. They observed that the
manufacturers of the controller are unreliable even
when implementing their own advertised sanitiza-
tion procedure, and that the use of cryptography
is insuﬃcient when the ultimate storage location of
the cryptographic key cannot be determined from
the logical address provided by the FTL. They pro-
pose a technique for static sanitization of the entire
ﬂash memory—that is, all the storage medium’s con-
tained information is securely removed. It works by
originally encrypting all the data on the drive be-
fore being written. When a sanitize command is is-
sued, ﬁrst the memory containing the keys is erased,
and then every page on the device is written and
erased. Our solution focuses on the more typical case
of a user wanting to securely delete some sensitive
data from their storage media but not wanting to
completely remove all data available on the device.
Our solution requires access to the raw ﬂash, or a
security-aware abstraction such as UBI that oﬀers
the ubi_flush() function to synchronously remove
all previous versions (including copies) of a particu-
lar LEB number.
Wei et al. [39] have considered secure deletion on
14
ﬂash memory accessed through an FTL (cf. Sec-
tion 2). They propose a technique, called scrubbing,
which writes zeros over the pages of ﬂash memory
without ﬁrst erasing the block. This sanitizes the
data because, in general, ﬂash memory requires an
erasure to turn a binary zero to a binary one, but
writes turn ones into zeros. Sun et al. [35] pro-
pose a hybrid secure deletion method built on Wei
et al.’s scheme, where they also optimize the case
when there is less data to copy oﬀ a block then data
to be zero overwritten.
Scrubbing securely deletes data immediately, and
no block erasures must be performed. However, it re-
quires programming a page multiple times between
erasures, which is not appropriate for ﬂash mem-
ory [22]. In general, the pages of an erase block must
be programmed sequentially [26] and only once. An
option exists to allow multiple programs per page,
provided they occur at diﬀerent positions in the
page; multiple overwrites to the same location oﬃ-
cially result in undeﬁned behaviour [26]. Flash man-
ufacturers prohibit this due to program disturb [21]:
bit errors that can be caused in spatially proximate
pages while programming ﬂash memory.
Wei et al. performed experiments to quantify
the rate at which such errors occur: they showed
that they do exist but their frequency varies widely
among ﬂash types, a result also conﬁrmed by Grupp
et al. [12]. Wei et al. use the term scrub budget to re-
fer to the number of times that the particular model
of ﬂash memory has experimentally allowed multi-
ple overwrites without exhibiting a signiﬁcant risk
of data errors. When the scrub budget for an erase
block is exceeded, then secure deletion is instead per-
formed by invoking garbage collection: copying all
the remaining valid data blocks elsewhere and eras-
ing the block. Wei et al. state that modern densely
packed ﬂash memories are unsuitable for their tech-
nique as they allow as few as two scrubs per erase
block [39]. This raises serious concerns for the fu-
ture utility of Wei et al.’s approach and highlights
the importance of following hardware speciﬁcations.
Lee et al. [19] propose secure deletion for YAFFS.
They encrypt each ﬁle with a diﬀerent key, store
the keys in the ﬁle’s header, and propose to modify
YAFFS to colocate ﬁle headers in a ﬁxed area of the
storage medium. They achieve secure deletion by
erasing the erase block containing the ﬁle’s header,
thus deleting the entire ﬁle. More recently, Lee et
al. [18] built on this approach by extending it to per-
form standard data sanitization methods prescribed
by government agencies (e.g., NSA [25], DoD [24])
on the erase blocks containing the keys.
We can only compare our approach with theirs in
15
design, as their approaches were not implemented.
First, the approach causes an erase block deletion
for every deleted ﬁle. This results in rapid wear
for devices that create and delete many small cache
ﬁles. Reardon et al. [32] observed that the Android
phone’s normal usage created 10,000 such ﬁles a day;
if each ﬁle triggers an erase block erasure, then this
solution causes unacceptable wear on the dedicated
segment of the ﬂash memory used for ﬁle headers.
Their proposal encrypts the entire ﬁle before writ-
ing it to the storage medium with a single key and
without mention of the creation or storage of IVs.
(See Section 4.3 for more analysis on per-ﬁle versus
per-data-node encryption.) Our solution diﬀers from
theirs by batching deletions and purging based on an
interval, by considering the eﬀect on wear levelling,
by allowing ﬁne-grained deletions of overwritten and
truncated data, and by being fully implemented.
7 Conclusions
DNEFS and its instance UBIFSec are the ﬁrst fea-
sible solution for eﬃcient secure deletion for ﬂash
memory operating within ﬂash memory’s speciﬁca-
tion. It provides guaranteed secure deletion against
a computationally-bounded peek-a-boo attacker by
encrypting each data node with a diﬀerent key
and storing the keys together on the ﬂash storage
medium. The erase blocks containing the keys are
logically updated to remove old keys, replacing them
with fresh random data that can be used as keys for
new data. It is ﬁne-grained in that parts of ﬁles that
are overwritten are also securely deleted.
We have implemented UBIFSec and analyzed it
experimentally to ensure that it is eﬃcient, requiring
a small evenly-levelled increase in ﬂash memory wear
and little additional computation time. UBIFSec
was easily added to UBIFS, where cryptographic op-
erations are added seamlessly to UBIFS’s read/write
data path, and changes to key state are handled by
UBIFS’s existing index of data nodes.
Acknowledgments
This work was partially supported by the Zurich In-
formation Security Center. It represents the views
of the authors. We would like to thank our anony-
mous reviews for their many helpful comments and
Artem Bityutskiy for his help integrating UBIFSec
into UBIFS.
References
[1] Ban, A. Flash ﬁle system. US Patent, no. 5404485, 1995.
[2] Bauer, S., and Priyantha, N. B. Secure Data Dele-
tion for Linux File Systems. Usenix Security Symposium
(2001), 153–164
[3] Boneh, D., and Lipton, R. J. A revocable backup
system.
the 6th conference on
USENIX Security Symposium, Focusing on Applications
of Cryptography - Volume 6 (Berkeley, CA, USA, 1996),
USENIX Association, pp. 91–96.
In Proceedings of
[4] Charles Manning. How YAFFS Works. 2010.
[5] Chow, J., Pfaff, B., Garfinkel, T., and Rosenblum,
M. Shredding Your Garbage: Reducing Data Lifetime
through Secure Deallocation. In Proceedings of the 14th
conference on USENIX Security Symposium - Volume
14 (Berkeley, CA, USA, 2005), SSYM’05, USENIX As-
sociation.
[6] Chung, T.-S., Park, D.-J., Park, S., Lee, D.-H., Lee,
S.-W., and Song, H.-J. A survey of Flash Translation
Layer. Journal of Systems Architecture 55, 5-6 (2009),
332–343.
[7] Cormen, T., Leiserson, C., and Rivest, R. Introduc-
tion to Algorithms. McGraw Hill, 1998.
[8] Gal, E., and Toledo, S. Algorithms and Data Struc-
tures for Flash Memories. ACM Computing Surveys 37
(2005), 138–163.
[9] Garfinkel, S., and Shelat, A. Remembrance of Data
Passed: A Study of Disk Sanitization Practices. IEEE
Security & Privacy (January 2003), 17–27.
[10] Gleixner, T., Haverkamp, F., and Bityutskiy, A.
UBI - Unsorted Block Images. 2006.
[11] Google, Inc. Google Nexus Phone.
[12] Grupp, L. M., Caulfield, A. M., Coburn, J., Swan-
son, S., Yaakobi, E., Siegel, P. H., and Wolf, J. K.
Characterizing ﬂash memory: anomalies, observations,
and applications.
In Proceedings of the 42nd Annual
IEEE/ACM International Symposium on Microarchitec-
ture (New York, NY, USA, 2009), MICRO 42, ACM,
pp. 24–33.
[13] Halderman, J. A., Schoen, S. D., Heninger, N.,
Clarkson, W., Paul, W., Calandrino, J. A., Feld-
man, A. J., Appelbaum, J., and Felten, E. W. Lest we
remember: cold-boot attacks on encryption keys. Com-
munications of the ACM 52 (May 2009), 91–98.
[14] Hunter, A. A Brief Introduction to the Design of
UBIFS. 2008.
[15] Intel Corporation. Understanding the Flash Transla-
tion Layer (FTL) Speciﬁcation. 1998.
[16] Intel Corporation. Intel Solid-State Drive Optimizer.
2009.
[17] Joukov, N., Papaxenopoulos, H., and Zadok, E. Se-
cure Deletion Myths, Issues, and Solutions. ACM Work-
shop on Storage Security and Survivability (2006), 61–
66.
[18] Lee, B., Son, K., Won, D., and Kim, S. Secure Data
Deletion for USB Flash Memory. Journal of Information
Science and Engineering 27 (2011), 933–952.
[19] Lee, J., Yi, S., Heo, J., and Park, H. An Eﬃcient
Secure Deletion Scheme for Flash File Systems. Journal
of Information Science and Engineering (2010), 27–38.
[20] Menezes, A. J., van Oorschot, P. C., and Vanstone,
S. A. Handbook of Applied Cryptography. CRC Press,
2001.
[21] Micron, Inc. Design and Use Considerations for NAND
Flash Memory Introduction. 2006.
[22] Micron Technology, Inc. Technical Note: Design and
Use Considerations for NAND Flash Memory. 2006.
[23] Memory Technology Devices (MTD): Subsystem for
Linux. 2008.
[24] National Industrial Security Program Operating Manual.
July 1997.
[25] NSA/CSS Storage Device Declassiﬁcation Manual.
November 2000.
[26] Open NAND Flash Interface. Open NAND Flash In-
terface Speciﬁcation, version 3.0. 2011.
[27] Perlman, R. The Ephemerizer: Making Data Disap-
pear. Tech. rep., Mountain View, CA, USA, 2005.
[28] Peterson, Z., Burns, R., and Herring, J. Secure
Deletion for a Versioning File System. USENIX Con-
ference on File and Storage Technologies (2005).
[29] Plumb, C. shred(1) - Linux man page.
[30] P¨opper, C., Basin, D., Capkun, S., and Cremers,
C. Keeping Data Secret under Full Compromise using
Porter Devices. In Computer Security Applications Con-
ference (2010), pp. 241–250.
[31] Provos, N. Encrypting virtual memory. In Proceedings
of the 9th USENIX Security Symposium (2000), pp. 35–
44.
[32] Reardon, J., Marforio, C., Capkun, S., and Basin,
D. Secure Deletion on Log-structured File Systems. 7th
ACM Symposium on Information, Computer and Com-
munications Security (2012).
[33] Rivest, R. L. All-Or-Nothing Encryption and The Pack-
age Transform.
In Fast Software Encryption Confer-
ence (1997), Springer Lecture Notes in Computer Sci-
ence, pp. 210–218.
[34] Rosenblum, M., and Ousterhout, J. K. The Design
and Implementation of a Log-Structured File System.
ACM Transactions on Computer Systems 10 (1992), 1–
15.
[35] Sun, K., Choi, J., Lee, D., and Noh, S. Models and De-
sign of an Adaptive Hybrid Scheme for Secure Deletion
of Data in Consumer Electronics. IEEE Transactions on
Consumer Electronics 54 (2008), 100–104.
[36] Swanson, S., and Wei, M. SAFE: Fast, Veriﬁable San-
itization for SSDs. October 2010.
[37] UBIFSec Patch.
[38] Voris, J., Saxena, N., and Halevi, T. Accelerome-
ters and randomness: perfect together. In Proceedings
of the fourth ACM conference on Wireless network se-
curity (New York, NY, USA, 2011), WiSec ’11, ACM,
pp. 115–126.
[39] Wei, M., Grupp, L. M., Spada, F. M., and Swanson,
S. Reliably Erasing Data from Flash-Based Solid State
Drives.
In Proceedings of the 9th USENIX conference
on File and Storage Technologies (Berkeley, CA, USA,
2011), pp. 105–117.
[40] Woodhouse, D. JFFS: The Journalling Flash File Sys-
tem. In Ottawa Linux Symposium (2001).
16