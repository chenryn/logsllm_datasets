How to Find 12 Kernel 
Information Disclosure 
Vulnerabilities in 3 Months
Tanghui Chen, Long Li | Baidu Security Lab
2019
Contents
0. Who am I?
1. Understanding Vulnerabilities
2. Vulnerability Analysis
•
Heap and stack data poisoning
•
Vulnerability detection techniques
•
CVE Analysis
3. Results
Who am I?
•
Senior Security R&D Engineer at 
Baidu Security Lab 
•
Has been engaged in Windows 
Kernel Security Development for 
years
•
Rootkit expert
•
Accidentally involved in the field 
of vulnerability research
Tanghui Chen
PI:EMAIL
What is the Kernel Information Disclosure 
Vulnerability?
There are many information disclosure vulnerabilities in Windows 
kernel that may lead to the ASLR bypass or critical system 
information disclosure, which can be exploited by attackers to reveal 
confidential information such as: 
•
Encryption keys 
•
Kernel objects 
•
Key kernel module addresses 
•
…
Root Causes of the Vulnerability
CVE-2018-8443
1. Call ZwDeviceIoControlFile (..., 0x7d008004, Output,…) in 
user mode
2. ZwDeviceIoControlFile switches to kernel mode after 
system call
3. Output contains the uninitialized data in kernel stack after 
returning to the user mode 
System 
Calls
Information 
Disclosure
Memory 
Space
API/Interface
Interface
Uninitialized 
data
Kernel Object 
Pointer
Module Base 
Address
…
Existing Vulnerability Mining Techniques
• BochsPwn
❑ CPU emulator
• DigTool
❑ Heavyweight VT techniques
• Instrumentation
Discovering Information Disclosure Vulnerability
1.Poison kernel heap and stack 
data, and fill padding flag data
2.Data is checked at a certain time 
when the application layer 
memory is written. If there is 
padding flag data in the memory, 
it’s possible a vulnerability exists.
3. Analyze and confirm the 
vulnerability
Memory
Checkpoint
Detect
1. Stack/Heap 
Poisoning
2. Data Detection
3. Vulnerability 
Analysis
Step 1: Heap/Stack Data Poisoning Techniques
•
Hook KiFastCallEntry, Kernel Stack Poisoning
•
Hook ExAllocatePoolWithTag, Kernel Heap Poisoning
•
Fill the heap and stack memory data with padding flag data, such 
as AA
In the Hook KiFastCallEntry, get kernel stack memory by IoGetStackLimits, and 
fill padding flag data
IoGetStackLimits(&LowLimit, &HighLimit);
__asm{
xor eax, eax;
mov al, g_cFlags; //0xAA
mov edi, LowLimit;
mov ecx, Esp_Value;
sub ecx, LowLimit;
cld;
rep stosb;
}
Stack Poisoning
Fill padding flag data when calling ExAllocatePoolWithTag to allocate memory
PVOID NTAPI HOOK_ExAllocatePoolWithTag(...)
{
PVOID Buffer = NULL; 
Buffer = pfn_ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
if (Buffer){
memset(Buffer, g_cFlags, NumberOfBytes); 
//将内存初始化特殊数据，如0xAA
}
return Buffer;
}
Heap Poisoning
Thoughts on Heap and Stack Data Poisoning
•
Heap and stack data poisoning techniques are relatively simple, 
there is no good or bad techniques
•
If the memory has data that is the same as the poisoned data, it’s 
possible to receive false positives.
•
Therefore, using variable padding flag data for poisoning can 
help reduce false positives.
Step 2: Research on Data Detection Techniques
Currently we have CPU emulator and VT data detection 
techniques.
Are there more and better techniques?
Data Detection Techniques Research
We came up with three techniques for data detection based on our 
research:
•
Nirvana (first time being used in kernel information 
disclosure vulnerability mining)
•
memcpy/memmove, referred to as memcpy (most lightweight 
technique)
•
movs
Nirvana is a lightweight, dynamic translation framework provided by Microsoft that 
can be used to monitor and control the (user mode) execution of a running process 
without needing to recompile or rebuild any code in that process (from Hooking 
Nirvana@Alex Ionescu). This is the first time Nirvana being used in kernel information 
disclosure vulnerability mining.
Nirvana can be used to set the callback function when the system call returns to the 
user mode, and the stack data can be detected in the callback function.
ZwSetInformationProcess(NtCurrentProcess(),ProcessInstrumentationCallback,&Info64,sizeof(Info64));
typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION{
ULONG_PTR Version;
ULONG_PTR Reserved;
ULONG_PTR Callback;
}PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION
Nirvana: Overview
__declspec (naked) VOID InstrumentationCallback()
{
__asm{
//The code is omitted...
mov eax, fs:[0x8];
mov edi, fs:[0x4];
__loop:
cmp dword ptr[eax], g_cFlag; //如0xAAAAAAAA
jz __find;
add eax, 4;
cmp eax, edi;
//The code is omitted...
jmp dword ptr fs : [0x1B0];
}
}
Nirvana: Implementation
The scene captured by Nirvana
16
Nirvana: Pros
•
Nirvana is supported by Windows Vista and later systems
•
Implementation is easy by using the system provided interface
•
Good compatibility
Nirvana: Cons
•
Can only detect stack data, almost impossible to detect heap data
•
It is relatively difficult to analyze and develop POC without 
catching the real-time disclosure of information
memcpy: Overview
•
memcpy/memmove is being used for copying data from 
kernel space
kernel space
user space
用户态内存
内核态内存
memcpy(dst, src, size);
检测
Hook memcpy/memmove，detect whether dst is user mode address and whether the data 
includes padding flag data
void * __cdecl HOOK_memcpy( void * dst, void * src, size_t count)
{
//代码有省略...
if ((ULONG_PTR)dst < MmUserProbeAddress){
pOffset = (PUCHAR)src;
while (pOffset <= (PUCHAR)src + count - sizeof(DWORD)){
if (*(DWORD *)pOffset == g_dwDwordFlags){
//checked
}
}}
//代码有省略...
}
memcpy: Implementation
memcpy: Features
•
Easy to implement, outstanding performance with almost no 
performance loss
•
Good compatibility
•
Being able to catch the first scene of the vulnerability, analyzing and 
writing POC is simple
•
Outstanding advantages, few flaws
Memcpy in-depth study
•
If size is a variable，nt calls  memcpy directly
•
If size is constant, memcpy is optimized
•
If size is a large constant, memcpy is 
optimized to movsd
•
Memmove will not be optimized
Exploring movs
•
memcpy optimizations
•
Eventually compiled into movs instructions
•
Detecting data using mpvs can resolve the insufficient memcpy
coverage problem in some rare cases
movs: Implementation
•
movs dst, src; (F3A5) int 20h; (CD20) are two bytes
•
Scan the nt module and replace all movs with int 20h
•
Customize int 20h interrupt handler, KiTrap20
•
Detecting memory data in KiTrap20
if (*(WORD *)pOffset == 0xA5F3){ //rep movs dword ptr es:[edi],dword ptr [esi] 
MdlBuffer = GetMdlBuffer(&Mdl, pOffset, 2); 
*(WORD *)MdlBuffer = 0x20CD;//int 20
}
__declspec (naked) VOID HOOK_KiTrap20()
{       
__asm {
//The code is omitted...
pushfd;
pushad; 
call DetectMemory;
popad;
popfd; 
rep movs dword ptr es:[edi], dword ptr[esi];
iretd; }
//The code is omitted...
}
movs: Implementation
VOID 
DetectMemory(PVOID DestAddress, PVOID SrcAddress, SIZE_T Size)
{
//The code is omitted...
if ((ULONG_PTR)DestAddress < MmUserProbeAddress){
pOffset = (PUCHAR)SrcAddress;
if (*(ULONG_PTR *)pOffset == g_dwDwordFlags){
//checked
}
//The code is omitted...
}
}
movs: Implementation
movs: Features
•
Data detection is more comprehensive than memcpy coverage
•
Ability to capture the vulnerability real-time and easy to 
analyze/develop the POC
Step 3: Vulnerability Analysis
•
Use live debugging for analysis and confirmation when a 
vulnerability is captured.
•
Switch to user mode. If the padding flag data exists in user 
mode memory, it is safe to confirm a kernel information 
disclosure vulnerability exists.
•
Develop PoC based on analysis of callstack and reverse 
engineering of user mode code that issues the syscall.
Vulnerability Analysis
•
Memories were copied multiple times for some of the 
vulnerabilities, which makes the POC analysis and development 
very difficult.
•
We implemented a set of memory tracking tools to assist our 
analysis, which can:
•
Memory trace
•
Memory conditional breakpoint
CVE-2018-8443, a vulnerability detected in win10 17134 x64 
CVE Analysis
Go back to mpssvc.dll and verify that user-mode memory contains special tags.
CVE Analysis
Go back to mpssvc.dll and find the code that triggered the vulnerability
CVE Analysis
CVE Analysis
Final completion of the POC
CVE Analysis
We discovered 12 windows kernel information disclosure vulnerability in three months, all have 
CVE assigned.
7 of the CVEs received the maximum bounty award $5,000
Results
Thinking
•
Just so…
•
User mode memory read-only (remove PTE write bit)
•
Reverse tracking
•
…
？
Thank you
Tanghui Chen
PI:EMAIL