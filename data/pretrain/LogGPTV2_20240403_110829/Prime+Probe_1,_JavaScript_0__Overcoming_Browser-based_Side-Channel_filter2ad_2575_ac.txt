Intel
i5-3470
87.5
45.8
50.8
72.0
50.1
Samsung
Exynos 2100
Intel
i5-3470
84.5
69.7
5.8
60.2
—
97.0
74.3
78.5
90.6
78.6
Top-5 Accuracy (%)
AMD Ryzen 9 Apple
M1
97.8
98.1
83.5
97.9
32.6
3900X
91.4
82.9
16.3
85.5
—
Samsung
Exynos 2100
95.3
91.5
37.1
85.5
—
Attack Technique
Cache Occupancy
Sweep Counting
DNS Racing
String and Sock
CSS Prime+Probe
Table 2: Closed-world accuracy (percent) across different microarchitectures.
Attack Technique
Cache Occupancy
Sweep Counting
DNS Racing
String and Sock
CSS Prime+Probe
Intel
i5-3470
AMD Ryzen 9
3900X
Apple
M1
Samsung
Exynos 2100
2.9 ms
100.0 ms
20.3 ms
1.5 ms
0.3 ms
6.0 ms
100.0 ms
1.8 ms
2.9 ms
6.7 ms
6.3 ms
100.0 ms
7.2 ms
2.6 ms
0.3 ms
4.0 ms
100.0 ms
2.9 ms
2.5 ms
33.8 ms
Table 3: Temporal accuracy of attack techniques across differ-
ent microarchitectures.
3.5 Empirical Results
We now present the classiﬁcation results of the attacks de-
scribed in this section across different CPU architectures.
Table 2 summarizes the accuracy of the most likely predic-
tion of the classiﬁer (Top-1), as well as the likelihood that
the correct answer is one of the top 5 results (Top-5). Finally,
Table 3 shows the temporal resolution of each measurement
method, calculated as the time it takes to capture the entire
trace, divided by the number of points in the trace.
Cache Occupancy. This method uses JavaScript code both
to iterate over the eviction buffer, and to measure time. The
JavaScript code goes iterates over the buffer using the tech-
nique of Osvik et al. [58] to avoid triggering the prefetcher,
and is written to prevent speculative reordering from trigger-
ing the timing measurement before the eviction is completed.
As can be seen from the results, this approach provides good
accuracy on all of the targets we evaluated, obtaining a top-5
accuracy of over 90% across all platforms.
Sweep Counting. This method is designed for situations
with lower clock resolution, but still uses JavaScript both for
cache eviction and for timing measurement. As the results
show, this added limitation translates to a loss in accuracy for
most targets, with the Apple M1 target the least affected by
the reduced timer resolution.
DNS Racing. This method uses JavaScript for cache evic-
tion, but switches to the network for timing measurements.
This added limitation translates to a loss in accuracy for most
targets, largely due to the added jitter of the network. The
targets most severely affected by the added jitter were the
ARM-based mobile phones, which were connected to the net-
work using a wireless link, and the AMD devices, which were
located in a third-party data center whose network conditions
were beyond our direct control. We hypothesize that these net-
working circumstances led to jitter related to DNS responses,
causing the severe loss of accuracy for these targets.
String and Sock.
This is the ﬁrst method which repur-
poses the browser’s string-handling code for cache eviction.
Unlike the adversary-controlled code used for mounting the
cache occupancy attack described earlier, this third-party code
naturally makes no attempt to trick the processor’s cache man-
agement heuristics, and, as such, we expected it to have lower
performance than the JavaScript-based code.
As we see, this was indeed the case for the Intel, AMD and
Samsung targets. The Apple M1 target, on the other hand, did
not encounter a loss in accuracy. It seems that, on this target,
naïvely accessing a large block of memory is an efﬁcient way
to evict the cache, and more advanced approaches for tricking
the processor’s prefetcher are not necessary.
CSS Prime+Probe.
As CSS Prime+Probe requires no
JavaScript, we test this attack in the presence of the NoScript
[51] extension, applying the countermeasure only to our at-
tacker website. As our attack does not use JavaScript at all,
NoScript does nothing to prevent it. The accuracy we obtained
using this attack was comparable to the one obtained by the
String and Sock attack, showing that there is no need for
JavaScript, or any other mobile code, to mount a successful
side-channel attack.
When running this attack on the Intel target, the accuracy is
similar to DNS racing, which uses JavaScript for cache evic-
tions. On the M1 target, there was still a signiﬁcant amount
of data leaked by the attack, but the accuracy was less than
the DNS racing attack. On the ARM and AMD targets, we
are unable at the present to extract any meaningful data using
this method. As our CSS Prime+Probe also relies on DNS
packets, we conjecture that this is due to the network condi-
tions of the devices under test, or due to particular aspects
of the micro-architecture of these devices which make cache
eviction less reliable.
Architectural Agnosticism. As the results show, we were
able to mount our side-channel attack across a large variety
of diverse computing architectures. In particular, the Intel,
USENIX Association
30th USENIX Security Symposium    2869
AMD, ARM and Apple target architectures all incorporate
different design decisions concerning different cache sizes,
cache coherency protocols and cache replacement policies, as
well as related CPU front-end features such as the prefetcher.
The reduced requirements of our attack made it immediately
applicable to all of these targets, with little to no tuning of
the attack’s parameters, and without the need of per-device
microarchitectural reverse engineering.
Attacking Apple’s M1 Architecture.
To the best of our
knowledge, this is the ﬁrst side-channel attack on Apple’s M1
CPU. The memory and cache subsystem of this new architec-
ture have never been studied in detail, leading one to hope for
a “grace period” where attackers will ﬁnd this target difﬁcult
to conquer. As this work shows, the novelty and obscurity
of this new target do little to protect it from side-channel at-
tacks. The M1 processor is rumored to toggle between two
completely different memory ordering mechanisms, based
on the program it is executing. Another noteworthy outcome
from the M1 evaluation is that both the native arm64 binary of
Chrome, as well as the standard MacOS Intel x64 Chrome bi-
nary running under emulation, were vulnerable to the attacks
we described here.
Finally, observing Table 2, it can be seen that our attacks
are, somewhat ironically, more effective on M1 architecture,
than they are on other architectures, including the relatively
well studied Intel architecture. Intel x86 CPUs are known
to have advanced cache replacement and prefetcher policies,
which are have been shown in other works to anticipate and
mitigate the effect of large memory workloads on cache per-
formance [8, 62, 76]. We hypothesize that the M1 architecture
makes use of less advanced cache heuristics, and that, as a
result, the simplistic memory sweeps our attack performs are
more capable of ﬂushing the entire cache on these devices
than they are on the Intel architecture. This in turn results in
a higher signal-to-noise ratio for the attack on these newer
targets, and therefore in a higher overall accuracy.
4 Attack Scenarios
We now turn our focus to a deeper investigation of the two
new attacks we present, String and Sock and CSS Prime+
Probe, on the Intel targets. Table 4 provides a summary of the
results discussed in this section.
Attack Scenario
Closed World
Open World
Artiﬁcial Jitter
Tor Browser
DeterFox
String and Sock
74.5±1.6
80.2±1.1
40.6±1.9
19.5±8.7
—
CSS Prime+Probe
48.8±1.6
60.9±1.4
26.6±1.4
—
65.7±1.2
Table 4: Attack accuracy (%) with 95% conﬁdence intervals.
4.1 Closed World Evaluation on Newer Intel
Architectures
We begin by reproducing the closed world methodology
and the results of Section 3 albeit on a newer Intel proces-
sor. Speciﬁcally, we perform the experiments on an Apple
Macbook Pro featuring an Intel Core i5-7267 CPU with a
4 MiB last-level cache, and 16 GiB memory, running macOS
10.15 and Chrome version 81. Despite the microarchitectural
changes across 4 CPU generations and the different cache
size, the results are very similar to those achieved on the older
i5-3470 (72.0±1.3% for String and Sock and 50.1±2.3 for
CSS Prime+Probe), with the difference being well inside the
statistical conﬁdence levels. We thus argue that our results
transfer across a verity of Intel architectures.
4.2 Open-World Evaluation
A common criticism of closed-world evaluations is that the
attacker is assumed to know the complete set of websites
the victim might visit, allowing the attacker to prepare and
train classiﬁers for these websites [38]. For a more realistic
scenario, we follow the methodology proposed by Panchenko
et al. [59] and perform an open-world evaluation, collecting
5000 traces of different websites used in [63], in addition to
the Alexa Top 100 websites collected in the closed-world
setting. We use the same data collection setting as for the
closed-world collection. (See Section 4.1.)
Here, the attacker’s goal in this setting is to ﬁrst detect if
the victim visits one of the Alexa Top 100 sites, and secondly
to identify the website if it is indeed in the list. We note that
in this case, a naive classiﬁer can always claim that the site is
not one of the Alexa Top 100, achieving a base rate of 30%,
resulting in slightly higher accuracy scores for any classiﬁer.
In this open-world setting, the String and Sock and CSS
Prime+Probe attacks obtain accuracy results of 80% and 61%,
respectively. The data in this setting is unbalanced – there
are more traces from “other” web sites than from each of
the Alexa Top 100 sites. For such data, the F1 score may be
more representative than accuracy. The F1 scores are 67% and
45%, for String and Sock and CSS Prime+Probe, respectively.
These are similar to those of the closed-world settings (70%
and 48%). We can therefore conclude that our attacks are as
effective in the open-world as in the closed-world setting.
4.3 Robustness to Jitter
As DNS racing, String and Sock, and CSS Prime+Probe use
an external server for time measurement, these techniques are
inherently sensitive to jitter naturally present on the network
between the victim and the web server.
Measuring Network Jitter. We measure the network jit-
ter in two scenarios. First, we perform a local measurement,
where the target and an attacker-controlled WebSockets server
2870    30th USENIX Security Symposium
USENIX Association
(a) String and Sock
(b) CSS Prime+Probe
(c) DNS Racing (note different scale)
Figure 4: Attack classiﬁers performance with additional jitter.
are located on the same institutional network at Ben Gurion
University, Israel. Next, we also perform an inter-continental
measurement, where the attacker is located in Israel, while the
server is located in the United States (University of Michigan).
Figure 5 shows the distribution of the jitter observed while
sending 100 packets per second for 30 seconds to the Web-
Sockets servers. We ﬁnd that the jitter in the local network
has a standard deviation of 0.17 ms, whereas the jitter to the
cross-continent server has standard deviation of 0.78 ms.
Figure 5: Measured Jitter of the WebSockets server response.
Evaluating Robustness to Jitter. Having established the
typical jitter between the target and the external server, we
now evaluate the robustness of our techniques to various lev-
els of jitter. To that aim, we artiﬁcially inject different amounts
of jitter to the closed-world dataset of Section 4.1. The jit-
ter is injected by adding random noise to the timing of the
monitored events. This noise is selected at random from a
normal distribution with a mean zero and a standard deviation
that varies from 1 to 25 milliseconds, with higher standard
deviation corresponding to larger jitter.
As Figure 4 shows, both the String and Sock and the CSS
Prime+Probe attacks still retain most of their accuracy even
if the jitter is an order of magnitude larger than the ones we
measured on a real network. We ﬁnally note that the DNS
Racing attack is more sensitive to added jitter, as it relies on a
binary race condition to determine timing.
5 Analysis of an API-based Defense
Having established the efﬁcacy of our techniques on various
microarchitectures, in this section we evaluate our attacks in
the presence of increasing levels of browser hardening.
To that aim, we make use of Chrome Zero [67], a Chrome
extension that supports per-website restrictions on JavaScript
browser API features. We begin by presenting an overview of
Chrome Zero’s JavaScript implementation and security objec-
tives, focusing on a subset of Chrome Zero’s features which
are relevant to this work. We next describe how we modiﬁed
Chrome Zero to offer more comprehensive protection, at the
cost of usability and performance. Finally, we show that even
with these modiﬁcations, Chrome Zero is unable to offer side
channel protections against the techniques presented in this
paper. Unless stated otherwise, we use the current version at
Chrome Zero’s Git repository.*
5.1 Chrome Zero Overview
Chrome Zero implements a list-based access control policy,
which dictates actions to be taken when a website invokes
a JavaScript function or accesses an object property. When
an access is detected, Chrome Zero either allows the access,
modiﬁes it, or completely blocks the access based on the
policy chosen for the particular website.† Chrome Zero also
supports the option of asking the user about the action to take.
Default Policies. Chrome Zero offers ﬁve preset protection
policies for the user to choose from: None, Low, Medium, High,
and Paranoid. ‡ As it progresses through protection policy
levels, Chrome Zero makes increasingly severe restrictions
on JavaScript capabilities and resources, including blocking
them altogether. Table 5 summarizes which capabilities and
resources are available at each protection level.
Performance. Schwarz et al. [67] claim that Chrome Zero
blocks all of the building blocks required for successful side-
channel attacks, including high resolution timers, arrays and
access to hardware sensors. Moreover, they claim that Chrome
Zero prevents many known CVEs and 50 percent of zero-day
exploits published since chrome 49. Finally, Schwarz et al.
[67] benchmark Chrome Zero’s performance and perform a
*https://github.com/IAIK/ChromeZero