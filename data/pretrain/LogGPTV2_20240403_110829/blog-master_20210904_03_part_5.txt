SINGLE TABLE ACCESS PATH .........................................................................................................................................1  
Column: ENAME Col#: 2 Table: EMP Alias: EMP.....................................................................2  
NDV: 42 NULLS: 0 DENS: 2.3810e-002 ...........................................................................3  
TABLE: EMP ORIG CDN: 7213 CMPTD CDN: 172 ........................................................................................4  
Access path: tsc Resc: 6 Resp: 6............................................................................................................5  
Access path: index (equal) ...............................................................................................................................6  
INDEX#: 23575 TABLE: EMP ...........................................................................................................................7  
CST: 39 IXSEL: 0.0000e+000 TBSEL: 2.3810e-002.......................................................................8  
BEST_CST: 6.00 PATH: 2 Degree: 1..............................................................................................................9  
我们看一下上面是什么意思。首先CBO列出了ename列的统计信息(第2，3行),这些统计信息来自dba_tab_columns。  
列的统计信息和dba_tab_columns中对应的列名如下  
Trace label                dba_tables column  
NDV                     NUM_DISTINCT     列的不重复值数  
NULLS                   NUM_NULLS        列的空行数  
DENS                    DENSITY           列密度，没有直方图的情况下= 1/NDV  
LO                       LOW_VALUE        列的最小值 (只对数字列)  
HI                        HIGH_VALUE      列的最大值 (只对数字列)  
第4行出现了表的行数ORIG CDN和计算过的行数 CMPTD CDN (computed cardinality). 计算公司如下，  
CMPTD CDN = ORIG CDN * FF  
在这里 FF 表示过滤因子（Filter Factor）。我们稍后再来看FF是什么及如何计算的。  
第5行表示了全表扫描的成本。 这里的成本是62, 是由NBLKS和db_file_multi_block_read_count初始化参数计算出来的。.  
第6－8行是索引访问的成本。  
第9行是总结了以上信息并选出了最优的访问路径为全表扫描，成本为6。  
表扫描成本  
让我们来看一下全表扫描成本(tsc)是如何计算的 这里有其他两个大表的基本统计信息。  
TOTAL :: CDN: 115630 NBLKS: 4339 TABLE_SCAN_CST: 265 AVG_ROW_LEN: 272  
TOTAL :: CDN: 454503 NBLKS: 8975 TABLE_SCAN_CST: 548 AVG_ROW_LEN: 151  
你可能曾经看到过全表扫描成本= 访问的块数目/ db_file_multi_block_read_count. 看起来这个等式很有意义因为oracle在做全表扫描时每个I/O请求将会读取db_file_multi_block_read_count个块。但是，我们计算以上统计信息得到  
NBLKS / TABLE_SCAN_CST = 4339 / 265 = 16.373 ≠ db_file_multi_block_read_count(这里的值是32，可以看前面参数那一页)  
另外一个表为  
NBLKS / TABLE_SCAN_CST = 8975 / 548 = 16.377  
全表扫描成本和db_file_multi_block_read_count  
CBO将会根据NBLKS和db_file_multiblock_read_count来估计全表扫描成本，但是db_file_multiblock_read_count通常会被打上折扣。实际上我们可以认为等式会是  
TABLE_SCAN_CST = NBLKS / k  
我们来看一下k和db_file_multiblock_read_count 究竟有什么规律可寻。我们来做一个实验，使用不同的  
db_file_multiblock_read_count值4, 6,8, 12,16, 24,32来测试。  
横轴为db_file_multiblock_read_count，纵轴为K。  
注意参数K仅仅用在全表扫描或快速索引扫描上，实际的I/O成本还与其他因数有关，比如说需要访问的表已经在内存中的块及块的数量。  
过滤因子(FF)  
为了理解索引访问成本我们需要了解一下过滤因子。 过滤因子是一个介于0和1之间的数字，反映了记录的可选择性。如果一个列有10种不同的值，我们需要查询等于其中某一个值的记录时，如果这10种值平均分布的话，你将得到1/10的行数。如果没有直方图，过滤因子为FF = 1/NDV = density  
再来看一下过滤因子和查询条件的关系  
不使用绑定变量的情况:  
predicate Filter factor  
c1 = value 1/c1.num_distinct4  
c1 like value 1/c1.num_distinct  
c1 > value (Hi - value) / (Hi - Lo)  
c1 >= value (Hi - value) / (Hi - Lo) + 1/c1.num_distinct  
c1  | >= | < | <=} :b1 {5.0000e-02 | col1.density }5  
col1 between :b1 and :b2 5.0000e-02 * 5.0000e-02  
包含and和or的情况:  
predicate Filter factor  
predicate 1 and predicate 2 FF1 * FF2  
predicate 1 or predicate 2 FF1 + FF2 – FF1 * FF2  
包含直方图的列：  
如果一个列包含了直方图信息，那么它的density就来自于直方图。关于直方图的内容请参考官方手册，这里不在细述。由于直方图的存在FF并不是简单的等于1/NDV,而是来自于直方图中各个列的density，所有有直方图的话CBO将可能采取不一样的执行路径。  
索引访问成本：  
现在我们知道了聚合因子的概念，我们再来看一看索引访问的成本  
SINGLE TABLE ACCESS PATH .........................................................................................................................................1  
Column: ENAME Col#: 2 Table: EMP Alias: EMP.....................................................................2  
NDV: 42 NULLS: 0 DENS: 2.3810e-002 ...........................................................................3  
TABLE: EMP ORIG CDN: 7213 CMPTD CDN: 172 ........................................................................................4  
Access path: tsc Resc: 6 Resp: 6............................................................................................................5  
Access path: index (equal) ...............................................................................................................................6  
INDEX#: 23575 TABLE: EMP ...........................................................................................................................7  
CST: 39 IXSEL: 0.0000e+000 TBSEL: 2.3810e-002.......................................................................8  
BEST_CST: 6.00 PATH: 2 Degree: 1..............................................................................................................9  
我们来看6-8行，这里表示了索引访问的成本。第6行表示这里采取索引equal的方法来访问，再来回忆一下索引的基本统计信息  
INDEX#: 23575 COL#: 2  
TOTAL :: LVLS: 1 #LB: 48 #DK: 42 LB/K: 1 DB/K: 36 CLUF: 1534  
根据索引成本计算公式  
blevel + FF*leaf_blocks + FF*clustering_factor  
1 + 2.3810e-002-2*48 + 2.3810e-002-2*1534 = 1 + 1.1429 + 36.5245 = 38.6674  
这里的FF就等于TBSEL=DENS=2.3810e-002,由于我们的查询条件为ename = :b1所以得出FF为ENAME列的DENS，  
其实索引访问方式的成本计算公式  
? Unique scan blevel+1  
? Fast full scan leaf_blocks / k ( k = 1.6765x0.6581 )  
? Index-only blevel + FF*leaf_blocks  
让我们用别的例子证明一下索引成本计算，语句为  
select … from tbl a  
where a.col#1 = :b1  
and a.col#12 = :b2  
and a.col#8 = :b3  
索引和列的基本统计数据如下  
INDEX#     COL#      LVLS      #LB        #DK     LB/K      DB/K      CLUF  
8417         27,1       1      13100     66500     1        22     1469200  
8418       1,12,7      2       19000    74700     1        15     1176500  
8419       3,1,4,2     2       31000    49700     1         2     118000  
15755      1,12,8      1       12600    18800     1        30     1890275  
8416   1,2,33,4,5,6   2        25800   1890300   1         1      83900  
Col#: 1 NDV: 10 NULLS: 0 DENS: 1.0000e-001-1  
Col#: 12 NDV: 8 NULLS: 0 DENS: 1.2500e-001  
Col#: 8 NDV: 33 NULLS: 0 DENS: 3.0303e-001  
Access path: index (scan)...................................................................................................................................1  
INDEX#: 8418 CST: 14947 IXSEL: 1.2500e-002 TBSEL: 1.2500e-002 ........................................2  
Access path: index (equal) ...............................................................................................................................3  
INDEX#: 15755 CST: 7209 IXSEL: 0.0000e+000 TBSEL: 3.7879e-003 ......................................4  
Access path: index (scan) .................................................................................................................................5  
INDEX#: 8416 CST: 10972 IXSEL: 1.0000e-001 TBSEL: 1.0000e-001 ........................................6  
5个索引中，索引(#8417 and #8419) 将不会被考虑因为他们的首列不出现在查询条件中。.  
INDEX# 8418  
索引包含的3个列中只有2列出现在查询条件中，所以只用2列的DENS来计算过滤因子  
FF = 1.0000e-001 * 1.2500e-001= 1.2500e-002  
cost = lvl + FF*#LB + FF*clustering factor  
= 2 + 19,000*1.2500e-002 + 1176500*1.2500e-002  
= 2 + 237.5 + 14706.25 = 14945.75  
INDEX# 15755  
索引包含的3列都出现在查询条件中，用3列的DENS计算过滤因子  
FF = 1.0000e-001 * 1.2500e-001 * 3.0303e-001 = 3.7879e-003  
cost = lvl + FF*#LB + FF*clustering factor  
= 1 + 12,600*3.7879e-003 + 1,890,275*3.7879e-003  
= 2 + 47.73 + 7160.13 = 7208.86  
INDEX# 8416  
索引包含的3个列中只有1列出现在查询条件中，所以只用1列的DENS来计算过滤因子  
FF = 1.0000e-001  
cost = lvl + FF*#LB + FF*clustering factor  
= 2 + 25,800*1.0000e-001+ 83,900*1.0000e-001  
= 2 + 2580 + 8390 = 10972  
虽然索引8416只有一列出现在查询条件中，但是它的成本还是低于索引8418，因为它的聚合因子(clustering factor)比较低，所以统计出来成本也比较低。关于聚合因子可以参考oracle官方文档。  
综合计划：  
这一部分开始是10053最大的一部分，在这里CBO会评估各种JOIN方式及顺序的成本。  
1. NL - NESTED LOOP JOIN  
join cost = cost of accessing outer table  
+ (row number of outer table * cost of accessing inner table )  
2. SM – SORT MERGE JOIN  
join cost = (cost of accessing outer table + outer sort cost)  
+ (cost of accessing inner table + inner sort cost)  
3. HA – HASH JOIN  
join cost = (cost of accessing outer table)  
+ (cost of building hash table)  
+ (cost of accessing inner table )  
JOIN ORDER [N]  
Join order[1]: DEPT [DEPT] EMP [EMP]  
Now joining: EMP [EMP] *******  
JOINS – NL  
NL Join ..............................................................................................................................................................................1  
Outer table: cost: 1 cdn: 16 rcz: 13 resp: 1..................................................................................2  
Inner table: EMP ......................................................................................................................................................3  
Access path: tsc Resc: 6 ...............................................................................................................................4  
Join resc: 97 Resp: 97 ...............................................................................................................................5  
Access path: index (join stp) ...........................................................................................................................6  
INDEX#: 23575 TABLE: EMP ...........................................................................................................................7  
CST: 39 IXSEL: 0.0000e+000 TBSEL: 2.3810e-002.......................................................................8  
Join resc: 625 resp:625 .............................................................................................................................9  
Access path: index (join index).....................................................................................................................10  
INDEX#: 23576 TABLE: EMP .........................................................................................................................11  
CST: 37 IXSEL: 0.0000e+000 TBSEL: 8.3333e-002.....................................................................12  
Join resc: 593 resp:593 ...........................................................................................................................13  
Access path: and-equal...................................................................................................................................14  
CST: 19 ...............................................................................................................................................................15  
Join resc: 305 resp:305 ...........................................................................................................................16  
Join cardinality: 172 = outer (16) * inner (172) * sel (6.2500e-002) [flag=0].................17  
Best NL cost: 97 resp: 97...............................................................................................................................18  
第1行为JOIN方式  
第2行为驱动表的成本，行数，行大小。这里的行数为16，平均行长原本为20，但是因为DEPT表包含(DEPTNO, DEPT, and LOC)3列但仅有DEPTNO,DEPT等2列需要被join，所以计算后平均行长为16，所以在这里也被称为low row size.  
第3行到16行通过NL JOIN的成本计算公式，计算出几种不同join方法的成本。  