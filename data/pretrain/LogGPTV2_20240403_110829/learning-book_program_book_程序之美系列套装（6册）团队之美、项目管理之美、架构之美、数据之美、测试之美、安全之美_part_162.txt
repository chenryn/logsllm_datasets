很清楚，并发者对它们不满意，直到将它们处理掉为止。同样，我
们看到了并发者对设计的品质负责。
单元测试打造了设计
关于代码集的一项核心决定就是所有代码都要有单元测试（这也是
在XP开发中强制要求做到的）。单元测试带来了许多好处，其中一
点就是能够修改软件的一些部分，而不必担心在修改的过程中破坏
其他的东西。我们对“设计之城”内部结构的某些部分进行了相当激
进的返工，单元测试给了我们信心，让我们相信系统的其他部分没
有被破坏。例如，线程模型和音频管道的内部连接接口都进行了彻
底的改变。这是在子系统并发较晚的时候发生的严重设计变更，但
与音频通道接口的其他代码仍然执行得很好。单元测试让我们能够
改变设计。随着“设计之城”的逐渐成熟，这种类型的“主要”设计变
更越来越少了。在经过一些设计返工之后，情况稳定下来，此后只
有一些不重要的设计变更。系统开发得很快：以选代的方式进行，
每一次选代都改进了设计，直到它达到了相对稳定的状态。
注意：你的系统应该有一组不错的自动化测试，它们让你在进行根
本的架构变更时风险最小。这为你提供了工作的空间。
909
---
## Page 911
计：它们实际上迫使我们实现好的结构。每个小的代码组件都被定
型成定义良好的实体，可以独立存在，因为它必须能够在单元测试
中构造出来，不需要围绕它构造系统的其他部分。编写单元测试确
保了每个代码模块的内聚性，也确保了与系统其他部分之间的松耦
合。单元测试道使我们仔细考虑每个单元的接口，确保该单元的
API是有意义的，内部是一致的。
注意：对你的代码进行单元测试将带来更好的软件设计，所以设计
时要考虑可测试性。
设计时间
“设计之城"成功的另一个因素是分配的并发时间段，它既不长也不
短（就像金发歌蒂的粥，既不热也不冷，刚刚好）。项目需要一个
有利的坏境才能获得成功。
如果时间太多，程序员常常会想创建他们的巨作（那种总是快要好
了，但永远不会实现的东西）。有一点压力是好事，紧道感有助于
完成事情。但是，如果时间太少，就不可能得到任何有价值的设
计，你只会得到半生不熟的解决方案，就像“大都市"那样。
注意：好的项目计划将带来优质的设计。分配足够的时间来创建架
构杰作，它们不会立即出现。
与设计同行
尽管代码集很大，但它是一致而易于理解的。新的程序员可以比较
容易地拿起代码并开始工作。不需要去理解不必要的复杂内部关
系，也不需要面对奇怪的遗留代码。
由于代码中产生的问题比较少，工作起来有乐趣，所以团队人员的
流失率很低。这是因为并发者们负责设计，并不断希望改进它。
的项目原则规定没有人“拥有"哪一部分设计，这意味着任何并发者
都可以改动系统的所有地方。每个人都应该写出高品质的代码。
“大都市"是许多不协作的、互相争斗的程序创造的一团混乱，而"设
计之城"则是由密切合作的同事创建的一组干净、一致、密切合作
910
---
## Page 912
的软件组件。在很大程度上，Conway法则（注）反过来也生效，团
队的组织方式就像软件的组织方式一样。
注意：团队的组织方式必然对它产生的代码有影响。随着时间的推
移，架构也会影响到团队协作的好坏。当团队瓦解时，代码的交互
就很糟糕。当团队协作时，架构就集成得很好。
2.2.3现状
在一段时间之后，“设计之城”的架构如图2-4所示。也就是说，它与
最初的设计非常相似，同时也包含了一些值得注意的变更。此外，
它还包含了大量的经验，证明这个设计是正确的。健康的并发过
程，小的、更善于思考的并发团队，适当注意确保一致性，带来了
极为简单、清晰、一致的设计。这种简单性为“设计之城"带来了好
处，得到了可扩展的代码和快速开发的产品。
在编写本书时，“设计之城”项目已走过了3年。代码集仍在使用，
而且扩展出了一些成功的产品。它还在并发、成长、扩展，还在每
关发生变化。下一个月它的设计可能与这个很不同，但也司能没有
不同。
我要澄清一点：这些代码并不完美。有些地方存在着技术争论，但
是它们在整洁的背景下显得特别突出，会在将来得到解决。没有什
么是一成不变的，由于适应性强的架构和灵活的代码结构，这些问
题都可以解决。几乎所有东西都各就各位，因为架构很好。
注：Conway法则指出，代码结构符合团队的结构。简而言之，“如
果你让4个小组开发一个编译器，就会得到一个4阶段编译器。”
116
---
## Page 913
用户界面
控制
外部控制器
存储管理
音频通道
OS/音频编解码
图2-4：“设计之城”的最终架构
2.3说明什么问题
等那完全的来到，这有限的必归于无有了。
《哥林多前书》第13章10节
这个关于两个软件系统的简单故事当然不是软件架构的全面介绍，
但我已展示了架构如何对软件项目产生深远的影响。架构几乎会影
响所有与之相关的人和事，它决定了代码集的健康，也决定了相关
领域的健康。就像一个繁荣的城市会为当地带来成功和声望，好的
软件架构将帮助项目获得发展，为依赖于它的人带来成功。
好的架构是很多因素的结果，包括以下方面（但不限于此）：
确实进行有意为之的前端设计。（许多项目甚至还没开始，就因为
这一点而失败了。）
设计者的素质和经验。（以前犯过一些错误是有帮助的，这能在下
一次为你指出正确方向！“大都市"项目肯定教会了我一些东西。）
授权团队负责软件的整体设计，而团队也承担起这一责任。
在开发过程中，保持清晰的设计观点。
912
---
## Page 914
不要害怕改变设计：没有什么是一成不变的。
让合适的人加入到团队中，包括设计者、程序员和经理，确保并发
团队的规模合适。确保他们具有健康的工作关系，因为这些关系将
不可避免地影响代码的结构。
在合适的时候做出设计决定，当你知道所有必要信息时再做出决
定。延迟那些暂时不能做出的决定。
好的项目管理，以及合适的最后期限。
2.4轮到你了
绝不要失去神圣的好奇心。
一阿尔伯特·爱因斯坦
你正在读这本书是因为你对软件架构感兴趣，而且你对改进自已的
软件感兴趣。所以这里就有一个极好的机会。对于你目前的软件经
验，请考虑以下简单的问题：
1.什么是你看到过的最好的系统架构？
你怎么知道它是好的？
这个架构在代码集之内和之外带来了什么结果？
你从中学到了什么？
2.什么是你看到过的最差的系统架构？
你怎么知道它是差的？
这个架构在代码集之内和之外带来了什么结果？
你从中学到了什么？
参考文献
Beck,Kent,with Cynthia Andres.2004.Extreme Programming
Explained,Second Edition.Boston,MA: Addison-Wesley Professional.
913
---
## Page 915
Fowler,Martin.1999.Refactoring: Improving the Design of Existing
Code.Boston,MA: Addison-Wesley Professional.
Hunt,Andrew,and David Thomas. 1999.The Pragmatic
Programmer.Boston,MA:Addison-Wesley Professional
第二部分企业级应用架构
第3章
伸缩性架构设计
第4章
记忆留存
第5章
面向资源的架构：在Web中
第6章
数据增长：Facebook平台的架构
第3章
伸缩性架构设计JimWaldo
原则与特性
结构
功能多样性
模块
概念完整性
V依赖关系
修改独立性
进程
自动传播
√数据访问
可构建性
增长适应性
914
---
## Page 916
熵增抵抗力
3.1简介
在设计系统架构时，一个比较有趣的问题就是确保系统在伸缩时的
弹性。随着越来越多的系统运行在网络上或在互联网上提供访问，
伸缩性正变得越来越重要。对于这样的系统，如果你希望误差的范
围在几个数量级以内，那么容量规划的想法显然是荒谬的。如果你
架起一个网站，然后它火了，你可能会突然发现有儿百万的用户访
问你的站点。同样容易出现的情况是，你架起了一个网站，却发现
没有人感兴趣，你投入的所有设备都闲置着，消耗着能源和管理成
本，浪费钱财（这同样是一种灾难）。在网络世界里，一个站点可
以在几分钟内从其中一种状态转变成另一种状态。
只要是将系统连接到网络上，每个人都会遇到伸缩性问题，但是
“大型多人在线游戏”（MMO）和虚拟世界特别关注这一点。这些系
统必须具备伸缩性，以满足大量的用户。Web服务器的用户常常读
取的是静态的内容，而且彼此之间没有交互，但MMO中的玩家或
虚拟世界中的居民则不同，他们既需要与所处的世界进行交互（这
改变了世界的基本信息），也需要彼此之间的交互。这些交互行为
使得这类系统基础设施的伸缩性问题变得更复杂，因为用户与系统
的交互几乎是独立的（除了那些不独立的情况），而且不会让世界
的状态改变太多。对于一个世界里的任意两个参与者，他们在某个
时刻进行交互的几率是非常小的。但是，几乎所有玩家在所有时候
都在与他人交互。结果是这种系统并行程度非常高，但只有少数的
交互是互相依赖的。
由于这些系统所培育起来的文化，MMO和虚拟世界的伸缩性问题
进一步复杂化了。MIMO和虚拟世界都源自于视赖游戏产品。这是
一种从PC游戏和游戏机游戏传统中成长起来的文化，在这种传统
中，程序员会假定游戏运行在一台独立的机器或游戏机上。在这样