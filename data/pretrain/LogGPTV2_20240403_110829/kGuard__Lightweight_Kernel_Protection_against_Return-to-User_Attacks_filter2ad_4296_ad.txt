Vulnerability
Description
CVE-2009-1897
CVE-2009-2692
CVE-2009-2908
CVE-2009-3547
CVE-2010-2959
CVE-2010-4258
EDB-15916
CVE-2009-3234
NULL function pointer dereference in drivers/net/tun.c due to compiler optimization
NULL function pointer dereference in net/socket.c due to improper initialization
NULL data pointer dereference in fs/ecryptfs/inode.c due to a negative reference
counter (function pointer affected via tampered data ﬂow)
data pointer corruption in fs/pipe.c due to a use-after-free bug (function pointer under
user control via tampered data structure)
function pointer overwrite via integer overﬂow in net/can/bcm.c
function pointer overwrite via arbitrary kernel memory nulliﬁcation in kernel/exit.c
NULL function pointer overwrite via a signedness error in Phonet protocol (function
pointer affected via tampered data structure)
ret2usr via kernel stack buffer overﬂow in kernel/perf_counter.c (return address is
overwritten with user space memory)
Impact
2.6.30–2.6.30.1
2.6.0–2.6.30.4
2.6.31
≤ 2.6.32-rc6
2.6.{27.x, 32.x, 35.x}
≤ 2.6.36.2
2.6.34
2.6.31-rc1
x86
√
√
√
√
√
√
√
√
Exploit
x86-64
—
√
√
√
—
√
√
√
√: detected and prevented successfully —: exploit unavailable
Table 1: Effectiveness evaluation suite. We instrumented 10 x86/x86-64 vanilla Linux kernels, ranging from v2.6.18 to v2.6.34,
for assessing kGuard. We successfully detected and prevented all the listed exploits.
5.3 Performance Overhead
The injected CFAs also introduce runtime latency. We
evaluated kGuard to quantify this overhead and estab-
lish a set of performance bounds for different types of
system services. Moreover, we used the overhead im-
posed by PaX (i.e., UDEREF [53] and KERNEXEC) as
a reference. Mind you that on x86, PaX offers protection
against ret2usr attacks by utilizing the segmentation unit
for isolating the kernel from user space. In x86-64 CPUs,
where segmentation is not supported by the hardware, it
temporarily remaps user space into a different location
with non-execute permissions.
Macro benchmarks We begin with the evaluation of
kGuard using a set of real-life applications that repre-
sent different workloads. In particular, we used a kernel
build and two popular server applications. The Apache
web server, which performs mainly I/O, and the MySQL
RDBMS that is both I/O driven and CPU intensive. We
run all the respective tests over a vanilla Linux kernel
v2.6.32.39, the same kernel patched with PaX, and in-
strumented with kGuard.
First, we measured the time taken to build a vanilla
Linux kernel (v2.6.32.39), using the Unix time utility.
On the x86, the PaX-protected kernel incurs a 1.26%
run-time overhead, while on the x86-64 the overhead is
2.89%. In contrast, kGuard ranges between 0.93% on
x86-64, and 1.03% on x86. Next, we evaluated MySQL
v5.1.49 using its own benchmark suite (sql-bench).
The suite consists of four different tests, which assess
the completion time of various DB operations, like table
creation and modiﬁcation, data selection and insertion,
and so forth. On average, kGuard’s slowdown ranges
from 0.85% (x86-64) to 0.93% (x86), while PaX lies
between 1.16% (x86) and 2.67% (x86-64). Finally, we
measured Apache’s performance using its own utility ab
and static HTML ﬁles of different size. We used Apache
v2.2.16 and conﬁgured it to pre-fork all the worker pro-
cesses (pre-forking is a standard multiprocessing mod-
ule), in order to avoid high ﬂuctuations in performance,
due to Apache spawning extra processes for handling the
incoming requests at the beginning of our experiments.
We chose ﬁles with sizes of 1KB, 10KB, 100KB, and
1MB, and measured the average throughput in requests
per second (req/sec). All other options were left to their
default setting. The kernel patched with PaX incurs an
average slowdown that ranges between 0.01% and 0.09%
on the x86, and 0.01% and 1.07% on x86-64. In antithe-
sis, kGuard’s slowdown lies between 0.001% and 0.01%.
Overall, our results indicate that in both x86 and x86-64
Linux the impact of kGuard in real-life applications is
negligible (≤1%).
Micro benchmarks Since the injected CFAs are dis-
tributed throughout many kernel subsystems, such as the
essential net/ and fs/, we used the LMbench [50] mi-
crobenchmark suite to measure the impact of kGuard
on the performance of core kernel system calls and
facilities. We focus on both latency and bandwidth.
For the ﬁrst, we measured the latency of entering the
OS, by investigating the null system call (syscall)
and the most frequently used I/O-related calls: read,
write, fstat, select, open/close. Addition-
ally, we measured the time needed to install a signal
with sigaction, inter-process communication (IPC)
latency with socket and pipe, and process creation
latency with fork+{exit, execve, /bin/sh}.
Figure 3 summarizes the latency overhead of kGuard
in contrast to the vanilla Linux kernel and a kernel with
the PaX patch applied and enabled. Note that the time
is measured in microseconds (µsec). kGuard ranges
from 2.7% to 23.5% in x86 (average 11.4%), and 2.9%
to 19.1% in x86-64 (average 10.3%).
In contrast, the
PaX-protected kernel exhibits a latency ranging between
5.6% and 257% (average 84.5%) on the x86, whereas on
x86-64, the latency overhead ranges between 19% and
531% (average 172.2%). Additionally, kGuard’s over-
head for process creation (in both architectures) lies be-
tween 7.1% and 9.7%, whereas PaX ranges from 8.1%
to 56.3%.
vanilla
PaX
kGuard
)
c
e
s
µ
(
y
c
n
e
t
a
L
 14
 13
 12
 11
 10
 9
 8
 7
 6
 5
 4
 3
 2
 1
 0
syscall()
read()
write()
fstat()
sigaction()
(a) x86
vanilla
PaX
kGuard
select ()-10 fds
select()-100 fds
open/close()
socket()
pipe()
)
c
e
s
µ
(
y
c
n
e
t
a
L
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0
vanilla
PaX
kGuard
)
c
e
s
µ
(
y
c
n
e
t
a
L
 14
 13
 12
 11
 10
 9
 8
 7
 6
 5
 4
 3
 2
 1
 0
syscall()
read()
write()
fstat()
sigaction()
(b) x86-64
vanilla
PaX
kGuard
select ()-10 fds
select()-100 fds
open/close()
socket()
pipe()
Figure 3: Latency overhead incurred by kGuard and PaX on essential system calls (x86/x86-64 Linux).
x86-64
vanilla
PaX
kGuard
6 Discussion and Future Work
)
c
e
s
µ
(
y
c
n
e
t
a
L
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0
 8000
 7000
 6000
 5000
 4000
 3000
 2000
 1000
 0
)
s
/
B
M
i
(
h
t
d
w
d
n
a
B
x86
vanilla
PaX
kGuard
Socket (PF_INET)
Socket (PF_UNIX)
Pipe
)
s
/
B
M
i
(
h
t
d
w
d
n
a
B
 8000
 7000
 6000
 5000
 4000
 3000
 2000
 1000
 0
Socket (PF_INET)
Socket (PF_UNIX)
Pipe
Figure 4: IPC bandwidth achieved by kGuard and PaX, using
TCP (PF_INET), Unix sockets (PF_UNIX), and pipes.
As far as bandwidth is concerned, we measured the
degradation imposed by kGuard and PaX in the maxi-
mum achieved bandwidth of popular IPC facilities, such
as sockets and pipes. Figure 4 shows our results (band-
width is measured in MB/s). kGuard’s slowdown ranges
between 3.2% – 10% on x86 (average 6%), and 5.25%
– 9.27% on x86-64 (average 6.6%). PaX’s overhead
lies between 19.9% – 58.8% on x86 (average 37%),
and 21.7% – 78% on x86-64 (average 42.8%). Overall,
kGuard exhibits lower overhead on x86-64, due to the
fewer CFAM guards (see Table 2). Recall that CFAR con-
ﬁnement can be performed with just 3 additional instruc-
tions, and hence incurs less run-time overhead, whereas
CFAM might need up to 10 (e.g., when we cannot opti-
mize). However, the same is not true for PaX, since the
lack of segmentation in x86-64 results in higher perfor-
mance penalty.
Custom violation handlers kGuard’s default violation
handler appends a message in system log and halts the
OS. We coerce assertion violations into a kernel fail-stop
to prevent brute-force attempts and to avoid leaving the