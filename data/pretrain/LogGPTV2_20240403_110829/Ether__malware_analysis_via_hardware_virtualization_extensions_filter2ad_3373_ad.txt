on host-based time sources.
Additionally, the Intel VT architecture has a special ﬁeld,
called the TSC_OFFSET, which the processor will automat-
ically add to any queries of the time stamp counter. This
value must be set to the calculated value of ∆′
A,t. Any other
clock sources, all of which are under control of Ether, can
be adjusted accordingly.
As Ether can only mitigate in-guest timing detection at-
tacks, a class of detection attacks utilizing time from ex-
ternal inputs is still possible. However, preventing such at-
tacks would require detecting covert channels over a shared
medium, which is known to be undecidable [45].
Attacks which detect virtualization itself, and not the
presence of Ether, will cease to be relevant in the future.
As virtualization spreads to home computers and enterprise
desktops, detecting virtualization will no longer be indica-
tive of detecting an analysis environment. As a consequence,
any malware which would not run in virtualized environ-
ments would preclude itself from infecting an increasing per-
centage of legitimate targets.
4.6 Architectural Limitations
Intel VT suﬀers from some architectural limitations which
may allow Ether to be detected under certain circumstances.
Diﬀerent hardware virtualization extensions exist that do
not suﬀer from such limitations.
Intel VT suﬀers from two main ﬂaws which allow the cur-
rent implementation to be detected by observing implicit
changes to the memory hierarchy. The ﬁrst ﬂaw is that
Intel VT ﬂushes the TLB on every VMExit. A detection
method such as the one proposed by [37] can detect this
implicit change. A hypervisor could run in non-paged mode
with caches oﬀ in an eﬀort to avoid using the extended mem-
ory hierarchy at all. Intel VT’s second ﬂaw is that paging
mode must be turned on before entering VMX Root Mode.
AMD’s competing virtualization solution, AMD-V, does not
suﬀer from either of these limitations. A hypervisor which
did not use paging and ran with caches oﬀ would be unde-
tectable by these memory hierarchy detection methods.
5. EXPERIMENTS AND EVALUATION
In this section, we describe two tools based on Ether:
EtherUnpack and EtherTrace. EtherUnpack traces mem-
ory writes and single instructions (i.e., ﬁne-grained tracing),
while EtherTrace traces system calls (i.e., coarse-grained
tracing). We use these tools to evaluate Ether and compare
it against current approaches.
5.1 Fine-Grained Tracing: Unpacking
To measure the eﬀectiveness of ﬁne-grained tracing on real
malware, we used Ether to create a generic, automated un-
packer called EtherUnpack. Before presenting the results
of experiments using EtherUnpack, we describe why an un-
packer is a ideal test for Ether’s resiliency against current
malware threats when performing ﬁne-grained tracing.
5.1.1 Methodology
Packing is a term used to describe the obfuscation and
encryption of program code to thwart static analysis. The
result of packing is that signature-based approaches fail to
identify packed malware as malicious. Opposite to packers,
unpackers are programs which attempt to obtain the original
code hidden by the packer.
To prevent unpacking, many current packers also attempt
to thwart dynamic analysis by using anti-debugging and
anti-VM techniques. Therefore, an Ether-based unpacker
serves as an excellent testbed for the framework, since pack-
ers will attempt to expose any lack of transparency exhibited
by Ether’s approach or implementation. In addition, given
the ﬁne-grained nature of automated unpacking, packers are
likely to have the greatest chance of exposing Ether’s poten-
tial weaknesses.
5.1.2 Packer Use in Current Malware
To evaluate EtherUnpack against current packed malware,
we obtained a recent malware corpus. Samples were col-
lected between January and March 2008 from honeypots,
mail ﬁlters, proxy monitors, web crawling, ﬁle sharing net-
works, and other sources. To classify the samples, we sur-
veyed them using PEiD [7], a signature-based packer detec-
tor, and a PEiD signature database from SANS ISC [8]. The
resulting set consisted of 25,118 malware instances, unique
according to MD5 value. The distribution of packers used to
obfuscate packed malware in the corpus appears in Figure 3.
Of note, the Other section in Figure 3 represents a multi-
tude of packers, where each comprises less than one percent
of the total collection.
5.1.3 Effectiveness
As used in Renovo, we deﬁne unpack-execution to occur
when a process executes memory it previously wrote. De-
tection is performed by monitoring memory writes and ex-
ecuted instructions. Whenever a program’s execution goes
to an area of memory previously written, EtherUnpack ﬂags
that area as dynamically generated code and extracts it.
Note that some samples contain multiple packing layers,
which may require Ether to perform additional, subsequent
unpacking even after it ﬁrst detected dynamically generated
code.
The samples used for unpacking in the above comparison
were the exact same set evaluated in Renovo. EtherUn-
pack was able to recover hidden code from all tested sam-
ples, which also represent the vast majority of packers from
Figure 3: Distribution of obfuscation of tools used
to transform malware.
our obfuscation tool survey. In contrast, PolyUnpack failed
on many of the samples due to being detected by various
in-guest detection techniques (e.g, detecting that an API
had been hooked). Renovo could not unpack the Obsidium
and Armadillo samples due to incorrect processor emulation,
while its reason for failing to unpack Themida with VM is
unclear.
To determine whether EtherUnpack successfully processed
packed samples, we compared the unpacked layers to original
program code. Speciﬁcally, we checked the unpacked layers
for an identifying string. The string consists of 32 bytes
starting at a ﬁxed oﬀset in the original program code. This
oﬀset was not chosen at random. We selected code that was
guaranteed to always be executed, but that did not contain
any Windows API calls. Certain packers will replace calls
to Windows API functions with new code having identical
functionality – the original code will never be executed by
the obfuscated program. Before testing, we veriﬁed that the
search string does not appear in the packed test binaries.
To compare EtherUnpack against current approaches, we
tested it alongside two other automated unpacking tools.
These were PolyUnpack, a generic in-guest unpacking tool
and Renovo, an external unpacker based on the BitBlaze
Binary Analysis Platform. The results of our testing are
shown in Table 1.
5.1.4 Performance
Ether’s ﬁne-grained tracing, on which EtherUnpack is
based, is not meant to be used for real-time analysis. While
tracing an application one instruction at a time makes Ether
extremely accurate, such tracing induces a signiﬁcant per-
formance penalty. Ether’s ﬁne-grained tracing is most useful
as a forensic tool.
5.1.5 Emulator Resistant Malware
Malware authors, aware that emulated environments are
used to analyze their creations, have begun incorporating
anti-VM techniques into malware to evade emulated envi-
ronments. Examples include Armadillo [2] and Themida [10],
which are highly emulation and virtualization resistant. Sub-
sequent to experimentation with EtherTrace, we performed
a cursory examination of our malware corpus to identify ad-
Packing Tool
Armadillo
Aspack
Asprotect
FSG
MEW
Molebox
Morphine
Obsidium
PECompact
Themida
Themida VM
UPX
UPX S
WinUPack
yoda’s Prot.
EtherUnpack Renovo PolyUnpack
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
no
yes
yes
yes
yes
yes
yes
no
yes
yes
no
yes
yes
yes
yes
no
no
yes
yes
yes
no
yes
no
no
no
no
yes
yes
no
no
Table 1: Eﬀectiveness of generic unpackers.
ditional samples which would not run in QEMU. We selected
QEMU because many novel, external malware analysis tools
(e.g., Anubis, Renovo, and Panorama) are based on QEMU
or one of its derivatives.
All of our testing was done on QEMU version 0.9.1, the
latest stable release as of this writing. In testing, we found
least three diﬀerent categories of samples that failed to exe-
cute properly in QEMU. In addition, an analysis of emula-
tion detection techniques present in these emulator-resistant
samples reveals all exploit incorrect CPU emulation.
The ﬁrst category contained any sample packed with the
tElock tool; we identiﬁed 442 such samples in our corpus.
These samples comprise well known malware, such as RBot,
SDBot and the Spy.Banker trojan. Binary analysis showed
that tElock uses an undocumented opcode, F1, which causes
interrupt vector 1 to be issued by the processor on normal
hardware. However, in QEMU, this instruction had the ef-
fect of freezing the entire guest OS, rendering the guest un-
usable even when tElock is executed from guest userspace.
The second category was represented by a new, in-the-
wild sample provided to us by CERT-LEXSI. As outlined
in [35], the CERT-LEXSI sample exploits the diﬀerence
between real hardware and emulated hardware values of re-
served FPU Control Word bits. Lastly, we found a version of
PCPrivacyTool (a fake anti-spyware program) that failed to
operate correctly. The PCPrivacyTool sample encountered
an invalid memory access while executing the LDDQU instruc-
tion in QEMU; the same instruction executes without issue
on a real CPU.
Other currently non-utilized methods exist to reliably de-
tect QEMU. To demonstrate, we created a synthetic QEMU
detection method that relies on improper emulation. Our
detector uses the multi REP preﬁx detection method outlined
in [26]. The detection relies on placing 15 REP preﬁxes be-
fore a single-byte instruction. This conﬁguration makes the
total instruction length 16 bytes – illegal on x86 where the
maximum instruction length is 15 bytes. On real hardware,
an illegal instruction exception is generated by the CPU.
QEMU does not generate such an exception. Even though
public release of this detection occurred in late 2006, the
issue has remained unresolved and the method still reliably
detects QEMU. The source code for our QEMU detector
appears in Appendix A.
In conclusion, EtherUnpack was able to reveal hidden code
Packing Tool
None
Armadillo
UPX
Upack
Themida
PECompact
ASPack
FSG
ASProtect
WinUpack
tElock
PKLITE32
yoda’s Prot.
NsPack
MEW
nPack
RLPack
RCryptor
EtherTrace Anubis Norman
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
no
yes
yes
yes
yes
yes
yes
no
yes
no
yes
yes
yes
yes
yes
yes
yes
yes
no
yes
yes
yes
yes
yes
yes
yes
yes
yes