# 如何对以太坊dApps进行渗透测试

## 译文声明
本文为翻译文章，原文来源于：https://arvanaghi.com/。译文仅供参考，具体内容及含义请以原文为准。

## 一、前言
以太坊（Ethereum）去中心化应用（decentralized application, dApp）是指基于共识协议交互的应用。在本文中，我们将探讨dApp最常见的应用场景之一：与一个或多个智能合约（smart contracts）交互的常规Web应用。

当我们通过Web访问某个dApp时（例如使用MetaMask等浏览器扩展），我们可以用自己的私钥与网站交互，并通过Web接口对交易进行签名。典型的dApp如图所示，这里我们使用了包含以太坊钱包的Chrome扩展来购买Cryptokitty（区块链养猫游戏）。

当浏览器与常规Web应用交互时，该应用可能会与其他内部服务器、数据库或云端服务进一步交互。整个过程看似简单，但对于dApp来说，除了这些步骤外，还涉及到第三个公开元素：所有人都可以访问的智能合约。与Web应用的某些交互涉及读写以太坊区块链上的一个或多个智能合约。

## 二、多管齐下的渗透测试方法
dApp的出现是为了让用户更方便地与智能合约互动。然而，并没有规定要求我们必须通过dApp的Web界面来与智能合约交互。由于智能合约是公开可访问的，因此我们可以直接与其交互，绕过Web服务器可能施加的限制。

目前，我们可以采用以下两种方式进行渗透测试：
1. 标准Web应用渗透测试，涵盖身份验证、访问控制和会话管理等方面。
2. 智能合约审计。

换句话说，我们可以检查Web应用和智能合约中的处理逻辑，寻找其中存在的逻辑错误。此外，由于以太坊支持modifiers（修改器）特性，我们还可以探索第三种渗透测试方法。

## 三、Modifiers
在以太坊中，我们可以编写只能由特定地址调用才能执行的函数。`onlyOwner`就是一个典型示例，如果正确实现了`onlyOwner`修饰符，则只有合约所有者才能运行某些函数。

```solidity
contract mortal {
    address owner;
    
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    function writeData(bytes32 data) public onlyOwner returns (bool success) {
        // 只有当owner发送交易时才会运行
    }
}
```

虽然我们可以直接与智能合约交互，但如果正确实现了类似`onlyOwner`这样的modifier，我们就无法执行某些函数。然而，在处理dApp时，Web服务器通常保存着特权地址的私钥，并且Web应用具有特定逻辑，接受用户输入并通过其中一个私钥调用智能合约中的特权函数。

鉴于dApp确实可以访问这些特权以太坊地址，我们的第三个渗透测试分支变为：“如何让dApp帮助我们向智能合约中的这些特权函数写入数据？”

考虑到这一点，我们现在面临的攻击面包括：
1. 标准Web应用评估（身份验证、访问控制、会话管理）。这可能不涉及智能合约，只涉及横向或纵向权限提升、数据库注入、XSS等。
2. 智能合约审计。包括权限问题、溢出漏洞、竞争条件等。
3. 尝试通过Web接口伪造智能合约的写入权限。我们是否能找到一种方式，使Web应用以非预期的方式与智能合约交互？

我曾这样描述dApp的攻击面：
> 想象一下一个普通的Web应用，可能带有各种安全漏洞。现在，想象一下一款从头开始构建自己的数据库软件、将这些数据库对外开放、有时存储真实价值资产的应用程序。这就是以太坊dApp开发者所面临的安全挑战。
>
> — Brandon Arvanaghi ([@arvanaghi](https://github.com/arvanaghi)) [2018年5月28日](https://twitter.com/arvanaghi/status/1000925430898184192?ref_src=twsrc%5Etfw)

## 四、使用Burp拦截请求
当我们注册Cryptokitties账户时，Web应用的逻辑会从用户的MetaMask扩展中提取公开的以太坊地址，然后要求我们输入电子邮件地址和用户名。

接下来的关键步骤是：由于dApps面向以太坊账户，因此基于公钥认证而非密码认证。因此，Cryptokitties会要求我们签名一条消息（“Cryptokitties”），以确保我们拥有与该地址对应的私钥。

如果我们拦截这个请求，可以看到如下数据：

理论上，Cryptokitties会验证**sign**参数中的数据（即已签名的“Cryptokitties”消息）是否与**address**参数中的数据（即我们的以太坊地址）匹配。

这个验证过程位于Web应用的逻辑中。我之前遇到过一些dApp未能正确处理签名验证的情况，因此我可以将请求中的以太坊地址替换为与签名不匹配的地址，从而发起拒绝服务攻击或伪造账户身份。

## 五、登录过程
[Bloom](https://bloom.co/)是一款高级的dApp，允许用户创建去中心化的身份标识。其原理是将身份与用户的以太坊地址绑定，避免像社会安全号码（SSN）那样被窃取或伪造。Bloom是迄今为止最成熟的dApp之一，强烈推荐大家尝试创建自己的[BloomID](https://app.bloom.co/signup)。

Bloom在认证处理方面非常严格。注册账户后，后续登录过程中需要签名一条包含操作意图（“我正在登录”）、电子邮件地址和当前时间的消息。

Bloom为何考虑对这些字段进行签名？原因如下：
1. **操作意图**：明确签名的具体内容，防止用户在不知情的情况下签名并发送数据。
2. **电子邮件地址**：从签名中恢复电子邮件地址，验证其是否与签署消息的以太坊地址的注册邮箱匹配。如果匹配，则此次登录有效。
3. **时间戳**：防止重放攻击。如果签名中未包含当前时间信息，攻击者可以随时重放数据，冒充目标用户的身份。成功签名后，如果Web应用在几分钟内收到签名数据，Bloom会认为这是有效的。

如果任何一个字段被篡改，就会显示错误信息，表明Bloom在认证机制上处理得当。

## 六、智能合约漏洞
前面讨论了直接分析智能合约是否存在安全漏洞的方法。接下来，我们来看看实际环境中发现的一些漏洞。

### batchOverflow
`batchOverflow`漏洞是一种溢出漏洞。我进行了一次小测试，看看大家是否能找到利用此漏洞的方法。在查看答案之前，大家可以尝试自己找到具体的利用方法。详细分析过程请参见[此处链接](#)。

### 重新初始化钱包所有者
尽管我不将其归类为“黑客攻击”，但Parity确实因为未正确实现某个modifier而遭受重大损失。此时，任何人都可以调用`initWallet`函数，将自己的地址设置为钱包的所有者。

通常情况下，钱包（或合约）的所有者应在合约构造函数中设置，构造函数只会被调用一次。如果要更改所有者地址，需要在某个函数的逻辑中操作，并且该函数需要原所有者的签名。但由于缺乏此类modifier，攻击者可以随时调用`initWallet`。详细分析过程请参见[此处链接](https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7)。

## 七、智能合约审计工具
在审计智能合约代码方面，已经有一些强大的开源工具，如Trail of Bits的[Manticore](https://github.com/trailofbits/manticore)和ConsenSys的[Mythril](https://github.com/ConsenSys/mythril.git)。我将在另一篇文章中详细介绍这些工具。

## 八、总结
希望本文能让您更好地理解dApp的攻击面以及dApp与标准Web应用之间的差异。如果您想了解更多关于以太坊或区块链安全的信息，请关注我的[推特](https://twitter.com/arvanaghi)，我会定期更新相关内容。