图11-1 市场中的某个应用锁App
下载这个apk之后使用aapt查看它的AndroidManifest.xml内容：
在拿到一个apk的时候，如果想知道apk中的一些资源和配置信息，aapt命令是个不错的选择，同时，它能够删除apk中的一些资源，添加一些资源到apk中都是可以的，查看结果如图11-2所示。
因为AndroidManifest.xml内容有点多，就重定向到一个txt文件中，看到allowBackup属性为true，因为非0的都是true。说明applock.apk这个应用是可以使用adb backup命令进行隐私数据的备份的。接下来就看一下如何进行备份。
第一步：进行数据的备份
代码如下：
·[-system|-nosystem] 这个指令是告诉adb在备份时是否要连同系统一起备份。若没有打的话默认是-system表示会一起备份系统。若连系统一起备份，在还原的时候会复盖系统档案对于已经升级后的手机是非常不好的。我不知道在没有root的情况下adb是否有权限去还原系统档案，但就算如此，还是不建议这样做。因此-nosystem是建议一定要打上的指令。
图11-2 aapt命令查看应用的AndroidManifest.xml
·-all 这个指令除非只是要备份单一App不然是一定要打上去的。这个是问你是否要备份全部的App，若有加上-nosystem的指令。那么就只会备份你目前已经安装上去的App而不会连系统App一起备份。
·[-apk|-noapk] 默认是-noapk，这个参数的意思是，是否连安装的apk一起备份。若为-noapk，则只会备份apk的资料档（像是游戏存盘、设定之类的）。
·[-shared|-noshared] 默认是-noshared，这个会问你是否连手机储存空间或是SD卡的档案一起备份。关于这个应用的包名，可以直接从上面dump出来的AndroidManifest.xml中获取即可，如图11-3所示。
图11-3 查看AndroidManifest.xml文件
获取包名之后，就可以执行命令，把导出来的文件保存到当前目录下：applock.ab，如下所示，注意这里的格式是ab，这个也是Android中备份文件的格式要求：
当执行这个命令的时候，设备端会出现一个提示页面，如图11-4所示。
这时候会提示输入备份密码，为了简单可以不输入，直接点击备份即可，备份完之后的文件如图11-5所示。
图11-4 备份截图
图11-5 备份之后的文件
第二步：abe工具来解析ab文件
还需要借助一个工具来解析这个ab文件。这个工具是开源的，用Java语言写的。源码位于：https://github.com/nelenkov/android-backup-extractor
这里没有直接下载源码，然后编译了，直接在网上下载了一个编译好的工具，工具下载地址如下。
提示：工具下载地址：
http://download.csdn.net/detail/jiangwei0910410003/9523470
用法也很简单，看到使用unpack参数来将ab文件转化成tar文件：
再用解压缩软件查看内容，如图11-6所示。
图11-6 压缩软件打开备份文件
现在如果想知道它的密码，可以直接查看SharePreferences
文件即可，因为一般都会把密码放到这里保存，当然这是一个非常危险的操作，如果再没有对密码进行加密的话，那更是危险了，如图11-7所示，是应用的沙盒中XML数据。
查看SmartLockConfig.xml内容，如图11-8所示。
被猜中了，它竟然把手势密码以明文的方式保存在这里。这里它用的是九宫格手势方式加密，03678代表的应该是一个L，可以对照图11-9九宫格图查看。
图11-7 SharedPreference文件
图11-8 存储密码文件
到这里就成功破解了应用锁应用的加密App的功能，而且是在设备没有root的情况下。下面来总结一下：
图11-9 九宫格图
1）这个App现在在市场的下载量还是蛮高的，但是看到它一不留神把allowBackup属性设置成true，就导致了数据可能被外泄，更为有趣的是，在使用几个IDE工具，默认新建的工程之后，这个属性的值也是true，如下所示（Eclipse和AndroidStudio开发工具）。
上面就是现在比较常用的两个IDE工具：Eclipse和AndroidStudio。可以看到当新建一个工程时，默认把这个属性设置成true，那么当不设置这个属性时，也是可以进行备份的，因为默认值是true。也许Google的想法是为了防止数据的丢失，就留了这个功能，便于用户备份数据。但是这里会隐含一些安全问题，在开发时如果不去注意这个属性的话，就会产生很大风险。以后在开发的过程中一定要记得把这个属性设置成false，特别是非常重要的需要账号登录的App。
2）上面分析了应用锁的App，并非只是一个案例，其实现在很多App都有这个问题，看看某市场App，如下所示：
它也是没有手动改变这个属性为false，所以它的数据也是可以导出来的。再看看某视频App，如下所示：
也是一样，不过像这些App，它们的账号登录密码的信息肯定不是放在本地的，而是放到服务端进行验证的，不像应用锁这样的，它不需要联网也是可以进行操作，所以密码必须放到本地。但是只要这个属性allowBackup为true的话，就会被查看到沙盒数据，就是不安全的。最后再来看看某社交App的5.0版本也有这个问题，不过它在6.0之后已经把allowBackup设置成false了，如下所示：
这里看到它没有设置allowBackup属性，但是刚刚说了，默认值就是true，所以还是可以导出来的，下面可以使用上面的导出步骤进行操作，如图11-10所示。
图11-10 社交数据库信息
其实社交App把通讯录和聊天记录都是保存到数据库中，但是这个数据库是加密的。数据库加密，其实是需要反编译App才知道，然后动态调试跟踪代码破解，因为通讯录和聊天内容是没有网络就可以查看的，那么加解密肯定是放在本地做的，只要是放在本地做的就可以进行破解。
不过可以看到这个App在后续的版本已经修复了这个问题，6.0版本之后就不能导出来数据了，那么5.0的用户其实还是会受影响的。
3）还是回到这个应用锁App中来，其实在这里还是想说一番的，作为下载量蛮高的App，竟然把密码用明文保存到XML中，这种做法其实是对用户的不负责，首先这里完全可以使用MD5来做密码验证就可以了，为何要暴露明文；其次是为什么把这么重要的数据保存到XML中，稍微加点破解难度考虑放到so中也是可以的。
4）开发的过程中，最后一步发包的时候一定要检查一下这个属性是否为false，因为它牵涉到应用的太多隐私信息了。
11.3 如何恢复应用数据
可以使用adb backup命令来做一下操作，就是在开发过程中，如果遇到手机没有root的，但是又想查看沙盒数据，那么这个也是一种方式，当然可以使用run-as命令来操作。
与上面的adb backup命令相对应的还有一个就是adb restore命令，它是用来恢复数据的，具体用法：
这时候也会在客户端出现确认页面，如图11-11所示。
点击恢复数据即可。现在如果想改了这个应用锁的密码，直接修改XML中密码数值，如下所示：
然后再保存成ab文件进行还原，密码就被修改了。比如有些应用把一些隐私的链接URL这样的信息保存到XML中，就可以导出来数据，然后修改URL为自己的URL再还原，而这些URL如果是一些上报、或者是登录的URL，就可以在这里做手脚，达到想要的目的了。
图11-11 数据还原
11.4 本章小结
从本章内容可以看到，对一个属性不留意会带来多大的风险，这个属性也是很容易忽视的，它默认值是true，必须手动设置成false才可以。这个属性导致现在市场上很多App都存在这样的风险。本章主要分析了一个应用锁应用的信息，发现它犯了一个最大的错误就是把密码用明文的方式保存在XML中，破解难度为0。所以开发者在开发一个App的时候，不仅考虑是用户体验，而且要对用户的隐私负责。用户在下载和安装一些App的时候也需要多留点心。
第12章 Android中的签名机制
Android开发者对于签名校验机制应该不陌生，就是为了安全，不让别人修改apk，防止恶意破解者在反编译apk之后再重新安装。如果重新安装系统会提示安装失败，因为apk的内容发生改变，签名结果不一样，Android系统中是不允许安装同一个包名但是签名不一样的apk程序的。
12.1 基本概念
在讲Android签名之前，需要了解几个知识点：
·数据摘要（数据指纹）、签名文件、证书文件。
·jarsign工具和signapk工具。
·keystore文件和pk8文件、x509.pem文件的关系。
·如何手动签名apk。
1.数据摘要
数据摘要其实也是一种算法，就是对一个数据源进行一个算法操作之后得到一个摘要，也叫作数据指纹，不同的数据源，数据指纹肯定不一样，就和人一样。
消息摘要算法（Message Digest Algorithm）是一种能产生特殊输出格式的算法，其原理是根据一定的运算规则对原始数据进行某种形式的信息提取，提取出的信息就称为原始数据的数据摘要。
著名的数据摘要算法有RSA公司的MD5算法和SHA-1算法及其大量的变体。
数据摘要的主要特点有：
·无论输入的消息有多长，计算出来的数据摘要的长度总是固定的。例如应用MD5算法摘要的消息有128位，用SHA-1算法摘要的消息最终有160位。
·一般来说（不考虑碰撞的情况下），只要输入的原始数据不同，对其进行摘要以后产生的数据摘要也必不相同，即使原始数据稍有改变，输出的数据摘要便完全不同。但是，相同的输入必会产生相同的输出。
·具有不可逆性，即只能进行正向的数据摘要，而无法从摘要中恢复出任何的原始消息。
2.签名文件和证书文件
签名文件和证书文件是成对出现的，二者不可分离，而且后面通过源码可以看到，这两个文件的名字也是一样的，只是后缀名不一样。
数字签名要确保可靠通信，必须要解决两个问题：首先，要确定消息的来源确实是其申明的那个人；其次，要保证信息在传递的过程中不被第三方篡改，即使被篡改了，也可以发觉出来。
所谓数字签名，就是为了解决这两个问题而产生的，它是对前面提到的非对称加密技术与数字摘要技术的一个具体的应用。
对于消息的发送者来说，先要生成一对公私钥对，将公钥给消息的接收者。
如果消息的发送者有一天想给消息接收者发消息，在发送的信息中，除了要包含原始的消息外，还要加上另外一段消息。这段消息通过如下两步生成：
1）对要发送的原始消息提取数据摘要。
2）对提取的数据摘要用自己的私钥加密。
通过这两步得出的消息，就是所谓的原始信息的数字签名。
而对于信息的接收者来说，他所收到的信息，将包含两个部分，一是原始的消息内容，二是附加的那段数字签名。他将通过以下三步来验证消息的真伪：
1）对原始消息部分提取数据摘要，注意这里使用的数据摘要算法要和发送方使用的一致。
2）对附加上的那段数字签名，使用预先得到的公钥解密。
3）比较前两步所得到的两段消息是否一致。如果一致，则表明消息确实是期望的发送者发的，且内容没有被篡改过；相反，如果不一致，则表明传送的过程中一定出了问题，消息不可信。
这种数字签名技术确实可以有效解决可靠通信的问题。如果原始消息在传送的过程中被篡改了，那么在消息接收者那里，对被篡改的消息提取的摘要肯定和原始的不一样。并且，由于篡改者没有消息发送方的私钥，即使他可以重新算出被篡改消息的摘要，也不能伪造出数字签名。
综上所述，数字签名其实就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。
不知道大家有没有注意，前面讲的这种数字签名方法，有一个前提，就是消息的接收者必须要事先得到正确的公钥。如果一开始公钥就被别人篡改了，那坏人就会被你当成好人，而真正的消息发送者给你发的消息会被你视作无效的。而且，很多时候根本就不具备事先沟通公钥的信息通道。那么如何保证公钥的安全可信呢？这就要靠数字证书来解决了。
数字证书一般包含以下一些内容：
·证书的发布机构（Issuer）
·证书的有效期（Validity）
·消息发送方的公钥
·证书所有者（Subject）
·数字签名所使用的算法
·数字签名
可以看出，数字证书其实也用到了数字签名技术。只不过要签名的内容是消息发送方的公钥，以及一些其他信息。但与普通数字签名不同的是，数字证书中签名者不是随随便便一个普通的机构，而是要有一定公信力的机构。这就好像你的大学毕业证书上签名的一般都是德高望重的校长一样。一般来说，这些有公信力机构的根证书已经在设备出厂前预先安装到了你的设备上了。所以，数字证书可以保证数字证书里的公钥确实是这个证书的所有者的，或者证书可以用来确认对方的身份。数字证书主要是用来解决公钥的安全发放问题。
综上所述，总结一下，数字签名和签名验证的大体流程如图12-1所示。
图12-1 签名过程
3.jarsign和signapk工具
了解到完了签名中的三个文件的知识点之后，下面继续来看Android中签名的两个工具：jarsign和signapk
开始使用这两个工具很容易混淆，它们到底有什么区别吗？其实这两个工具很好理解，jarsign是jdk本身自带的一个工具，它可以对jar进行签名。而signapk是后面专门为了Android应用程序apk进行签名的工具，它们的签名算法没什么区别，主要是签名时使用的文件不一样。
4.keystore文件和pk8、x509.pem文件的区别
上面了解到了jarsign和signapk两个工具都可以进行Android中的签名，那么它们的区别在于签名时使用的文件不一样：
·jarsign工具签名时使用的是keystore文件。
·signapk工具签名时使用的是pk8、x509.pem文件。
在使用Eclipse工具编写程序出debug包的时候，默认用的是jarsign工具进行签名的，而且Eclipse中有一个默认签名文件，如图12-2所示。
图12-2 Eclipse中默认签名文件
有默认签名的keystore文件，当然也可以选择指定的keystore文件。看到上面有MD5和SHA1的摘要，这个就是keystore文件中私钥的数据摘要，这个信息也是在申请很多开发平台账号的时候需要填入的信息，比如申请百度地图、微信SDK等，会需要填写应用的MD5或者SHA1信息。