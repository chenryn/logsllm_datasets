1
Jna加载ShellCode优化
起因
修改
最后
@yzddmr6 
蚁剑最开始实现java加载shellcode是通过jna的⽅式，这个做法是来源于⼀个apt组织的⽅法 
https://norfolkinfosec.com/jeshell-an-oceanlotus-apt32-backdoor/ 
但是不是很⽅便的⼀点是这个shellcode loader体积⼤于2m，超过了tomcat默认上传最⼤⻓度。所以之
前⼀直的做法都是先把编译好的jar上传到⽬标服务器，然后⽤URLClassLoader去加载⽂件。虽然⼀开
始jar⼏乎是全⽹免杀的，但是落地还是增加了被识别的⻛险。 
后来发现新版哥斯拉4也增加了jna，⽤来加载pe⽂件。研究了⼀下发现他的jna加载器⾮常⼩，只有不
到1m。 
研究了⼀下发现beichen师傅的做法很秀，简单来说就是低版本jna+删除⼀把梭。 
先是选取了⼀个低版本的jna，⼤概是4.1.0版本。这个版本的jna只有1.4m左右，⽽我⼀开始⽤的⽐较新
的jna版本是5.5.0，体积⼤概位2.5m左右。但是经过测试，旧版本对于加载shellcode是没有影响的。 
起因 
2
除此之外，beichen师傅还删掉了⼀些⽤不到的其他平台的扩展。 
可以看到原版jna⾥还有对很多linux平台下的⽀持： 
3
但是shellcode加载器⼀般只在win下使⽤，所以在哥斯拉中都统统删掉了 
4
除此之外，还有⼀些elf⽂件解析的类，还有加载shellcode时候⽤不到的类也都通通删掉。 
还有⼀些可能是⽤不到的类也删掉了 
5
修改的话可以直接把jar当作压缩⽂件打开，不需要解压，然后删除不需要的⽬录。或者最简单的，可以
直接引⽤哥斯拉的loader 
按照beichen师傅的做法修改后，我们loader的体积已经⼩于1m了。 
这个时候就可以通过内存加载jar，⽽⽆需⽂件落地了。 
除此之外，还顺⼿修改了⼀些loader的逻辑。原来插件中遇到32位的java会注⼊⾃⼰，但是为了⻛险考
虑，新版本已经全部修改成了注⼊其他进程，防⽌⼿⼀抖就把站给搞坏了。 
新版插件增加了随机注⼊进程，还有⼿动选择注⼊⽬标进程的选项。 
另外现在⽀持打64位的shellcode了 
修改 
6
注⼊指定进程时，填写进程的绝对路径。 
7
getpid查看当前进程pid位4356 
ps⼀下，发现就是我们启动的arp.exe 
有了这个迷你版jna之后，我们就可以⽆⽂件实现所有其他shellcode加载器能够实现的操作。在插件的
默认版本⾥，只是会粗暴的CreateProcess然后往⾥⾯写shellcode。但其实在jna中只要继承
最后 
8
StdCallLibrary这个接⼝，就可以调⽤kernel32中的函数。这⾥仅仅是抛砖引⽟，师傅们可以⽤各种姿
势定制化属于⾃⼰的加载器。