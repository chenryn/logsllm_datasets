title:LegoSNARK: Modular Design and Composition of Succinct Zero-Knowledge
Proofs
author:Matteo Campanelli and
Dario Fiore and
Ana&quot;ıs Querol
LegoSNARK: Modular Design and Composition of
Succinct Zero-Knowledge Proofs
Matteo Campanelli1, Dario Fiore1, and Anaïs Querol1,2
1 IMDEA Software Institute
2 Universidad Politécnica de Madrid
PI:EMAIL
PI:EMAIL
PI:EMAIL
Full Version
Abstract. We study the problem of building non-interactive proof
systems modularly by linking small specialized “gadget” SNARKs in
a lightweight manner. Our motivation is both theoretical and practi-
cal. On the theoretical side, modular SNARK designs would be ﬂexi-
ble and reusable. In practice, specialized SNARKs have the potential
to be more eﬃcient than general-purpose schemes, on which most
existing works have focused. If a computation naturally presents
diﬀerent “components” (e.g. one arithmetic circuit and one boolean
circuit), a general-purpose scheme would homogenize them to a sin-
gle representation with a subsequent cost in performance. Through
a modular approach one could instead exploit the nuances of a com-
putation and choose the best gadget for each component.
Our contribution is LegoSNARK, a “toolbox” (or framework) for
commit-and-prove zkSNARKs (CP-SNARKs) that includes:
1) General composition tools: build new CP-SNARKs from proof
gadgets for basic relations simply.
2) A “lifting” tool: a compiler to add commit-and-prove capabilities
to a broad class of existing zkSNARKs eﬃciently. This makes them
interoperable (linkable) within the same computation. For example,
one QAP-based scheme can be used prove one component; another
GKR-based scheme can be used to prove another.
3) A collection of succinct proof gadgets for a variety of relations.
Additionally, through our framework and gadgets, we are able to
obtain new succinct proof systems. Notably:
– LegoGro16, a commit-and-prove version of Groth16 zkSNARK,
that operates over data committed with a classical Pedersen vector
commitment, and that achieves a 5000× speedup in proving time.
– LegoUAC, a pairing-based SNARK for arithmetic circuits that has
a universal, circuit-independent, CRS, and proving time linear in
the number of circuit gates (vs. the recent scheme of Groth et al.
(CRYPTO’18) with quadratic CRS and quasilinear proving time).
– CP-SNARKs for matrix multiplication that achieve optimal prov-
ing complexity.
4) A codebase written in C++ for highly composable zkSNARKs with
commit-and-prove capabilitiesa.
a Available at https://github.com/imdea-software/legosnark .
Table of Contents
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1 Our Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Roadmap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1 Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Commitment Schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Zero-Knowledge SNARKs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3 Building the LegoSNARK Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1 Commit and Prove SNARKs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Composition Properties of CP-SNARKs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Commit-Carrying SNARKs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 Existing CP-SNARKs and cc-SNARKs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 Bootstrapping our Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4 CP-SNARKs for Pedersen-like Commitments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1 CP-SNARK for Pedersen Veriﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 CP-SNARK for Linear Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5 Eﬃcient CP-SNARKs for Polynomial Commitments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1 Preliminaries and Building Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 A CP-SNARK for Sum-Check . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 A CP-SNARK for Hadamard Products . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.4 A CP-SNARK for Self Permutation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.5 A CP-SNARK for Linear Properties of Committed Vector . . . . . . . . . . . . . . . . . . . . . . . .
5.6 A CP-SNARK for Matrix Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6 LegoSNARK Applications and Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.1 Preliminaries and Building Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.2 Arithmetic Circuit Satisﬁability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.3 Parallel Computation on Joint Inputs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7 Experimental Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.1 Commit-and-Prove SNARKs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.2 Matrix Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.3 LegoAC1 for Arithmetic Circuits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.4 Parallel Checks on Joint Inputs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
6
7
9
9
10
10
10
12
12
13
14
17
18
19
20
22
23
23
25
27
28
31
32
35
35
36
38
40
40
41
41
43
44
A Security proof of CP-SNARK composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.1 Proof of Knowledge Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.2 Proof of Zero-Knowledge . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B Proofs for the General Compiler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B.1 Proof of Knowledge Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B.2 Proof of Zero-Knowledge . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C Supplementary Results on CPlink . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C.1 Proof of CPlink Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C.2 An extension of CPlink for Preﬁxes of a Committed Vector . . . . . . . . . . . . . . . . . . . . . . . .
D A zkSNARK for Linear Subspaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
E A Construction of PolyCom and CPpoly from zk-vSQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F Additional Material on CP-SNARKs for PolyCom. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F.1 Proof of our CPsc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F.2 Proof of Security of CPhad . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F.3 Proof of CPsfprm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F.4 Proof of CPlin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F.5 A CP-SNARK for Data-Parallel Computations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
G A CP-SNARK for Internal Products from Thaler’s Protocol . . . . . . . . . . . . . . . . . . . . . . . . . .
G.1 CMT Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
G.2 Thaler’s Protocol for Trees of Multiplications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
G.3 Adapting zk-vSQL to Thaler’s Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H Commit and Prove SNARKs from existing schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H.1 “Adaptive Pinocchio” [Vee17]. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H.2 Lipmaa’s Hadamard Product Argument [Lip16] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H.3 zk-vSQL [ZGK+17b]
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H.4 Geppetto [CFH+15] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H.5 cc-SNARKs based on Groth’s SNARK . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
48
50
50
50
53
55
55
56
56
58
59
59
60
61
62
63
64
64
65
65
67
68
68
68
69
70
3
1
Introduction
Zero-knowledge proofs (ZKPs), introduced by Goldwasser, Micali and Rackoﬀ [GMR89], let a prover
convince a veriﬁer of a statement without revealing more information than its validity. This power of
ZKPs—simultaneously providing integrity (the prover cannot cheat) and privacy (the veriﬁer does
not learn any of the prover’s secrets)—has found countless applications, including multiparty com-
putation [GMW87], signature schemes [Sch91], public-key encryption [NY90], and, more recently,
blockchain systems [BCG+14, AJ18].
Some zero-knowledge proof systems—called succinct or simply zkSNARKs, zero-knowledge Suc-
cinct Non-interactive Argument of Knowledge—have short and eﬃciently veriﬁable proofs [Mic00,
GW11, BCCT12]. Succinctness is desirable in general but is especially critical in applications where
veriﬁers would not invest signiﬁcant computational resources (e.g. if they are unwilling to do it for
reasons of scalability and cost, or if they are computationally weak).
Motivation. The last years have seen remarkable progress in the construction of zkSNARKs.
Diﬀerent lines of work (cf. Section 1.2 for a detailed review) have built a variety of schemes that are
highly expressive, supporting general computations in the class NP. The general-purpose nature of
these schemes makes them very attractive to practitioners. At the same time, this high expressivity
comes at a cost in terms of performance. To achieve generality, these constructions abstract speciﬁc
features of computation by assuming one single unifying representation (e.g., boolean or arithmetic
circuits, state-machine transitions, RAM computations), and this abstraction is often a source of
overhead, for two main reasons.
First, general-purpose zk-SNARKs may miss opportunities for signiﬁcant optimizations by not
exploiting the nuances of a computation. In contrast, specialized solutions can gain eﬃciency by
exploiting speciﬁc structural properties. For example, recent works [CMT12, WTas+17] show how to
highly optimize the GKR protocol[GKR08] for the case of parallel computations. A further example
is the specialized protocol for the multiplication of n × n matrices we propose in Section 5.6. Here,
our prover runs in O(n2) time as opposed to any circuit-based approach running in at least O(n3)
time.
Second, computation tends to be heterogeneous, often consisting of several subroutines of dif-
ferent nature, e.g. both arithmetic and boolean components. If we design SNARKs assuming one
single general representation then we will not be able to provide the best match for all the diﬀerent
subroutines. In this context specialized protocols are clearly not an answer either as they fail when-
ever faced with a non homogeneous computation. As a concrete example, the GKR-like protocols
mentioned above are highly eﬃcient when executed on parallel computations, but they fail to be
succinct if a computation also includes heavily sequential subroutines (e.g. iterated block ciphers).
In contrast, specialized solutions can gain eﬃciency by exploiting speciﬁc structural proper-
ties. For example, recent works [CMT12, WTas+17] show how to highly optimize the GKR proto-
col[GKR08] for the case of parallel computations. A further example is the specialized protocol for
the multiplication of n × n matrices we propose in Section 5.6. Here, our prover runs in O(n2) time
as opposed to a circuit-based approach running in at least O(n3) time.
A Modular Approach for zk-SNARKs. In this paper we study an alternative approach to the
design of zkSNARKs that would gain the advantages of specialized proof systems without inheriting
their shortcomings when applied to heterogeneous computations. With this goal in mind we propose
to build zkSNARKs by proceeding in a modular “bottom-up” fashion. Most current works use a “top-
down” approach: they build general-purpose schemes adopting one single representation that must
4
be shared across all the diﬀerent subroutines in the program. On the other hand, in this work
we consider designing a “global” SNARK for a computation C through a (lightweight) linking of
“smaller” specialized SNARKs for the diﬀerent subroutines composing C. We call these interlinked
specialized SNARKs proof gadgets, as they act as basic building blocks that one can compose and
reuse according to the situation.
The modular approach has multiple beneﬁts.3 First, it allows for reducing complexity: instead of
focusing on handling arbitrary computation using a single representation, one can focus on a smaller,
more speciﬁc problem (e.g., log-depth computation, membership proof, range proof, algebraic group
relation etc.), and exploit its nuances to get a more eﬃcient solution. This way, one could maximize
eﬃciency by letting each subroutine of C be handled by a diﬀerent proof system, specialized and
eﬃcient for that type of computation. Second, modularity allows for ﬂexibility and costs reduction:
a proof gadget can be reused in several systems and one can easily plug in a new solution, or replace
an old one.
Modularity from Commit-and-Prove SNARKs. To realize this modular approach we rely on
the well known commit-and-prove (CP) methodology [Kil89, CLOS02]. With a CP scheme one can
prove statements of the form “cck(x) contains x such that R(x, w)” where cck(x) is a commitment.
To see how the CP capability can be used for modular composition consider the following example
of sequential composition in which one wants to prove that ∃w : z = h(x; w), where h(x; w) :=
g(f (x; w); w). Such a proof can be built by combining two CP systems Πf and Πg for its two building
blocks, i.e., respectively f and g: the prover creates a commitment cck(y) of y, and then uses Πf
(resp. Πg) to prove that “cck(y) contains y = f (x; w) (resp. contains y such that z = g(y; w))”.
Challenges of the CP modular composition. The composition idea sketched above implicitly
assumes that Πf and Πg work on the same commitment cck(y). Namely, in order to be composed,