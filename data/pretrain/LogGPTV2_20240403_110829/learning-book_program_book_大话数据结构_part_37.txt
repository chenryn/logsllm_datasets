26
图 7-6-7
于是克鲁斯卡尔（Kruskal）算法代码如下，左侧数字为行号。其中MAXEDGE为
边数量的极大值，此处大于等于15即可，MAXVEX为顶点个数最大值，此处大于等
于9即可。现在假设我们自已就是计算机，在调用MiniSpanTree_Kruskal函数，输入
图7-6-3右图的邻接矩阵后，看看它是如何运行并打印出最小生成树的。
/*Kruskal算法生成最小生成树*/
1
void MiniSpanTree_Kruskal（MGraph G）/·生成最小生成树*/
2
3
inti,n,m;
4
Edgeedges[MAXEDGE]：/·定义边集数级*/
intparent[MAXVEX]：/·定义一数组用来判断边与边是否形成环路*/
此处省略将邻接蜓阵G转化为边集数组edges并按权由小到大排序的代码*/
6
for（i-0;10)
23
f-parent[f];
24
return f;
25
201
1.程序开始运行，第5行之后，我们省略掉颜占篇幅但却很容易实现的将邻接矩
阵转换为边集数组，并按权值从小到大排序的代码1，也就是说，在第5行开
始，我们已经有了结构为edge，数据内容是图7-6-7的右图的一维数组
edges.
2.第5~7行，我们声明一个数组parent，并将它的值都初始化为0，它的作用
我们后面慢慢说。
3.第8~17行，我们开始对边集数组做循环遍历，开始时，i=0。
4.第10行，我们调用了第19~25行的函数Find，传入的参数是数组parent和
当前权值最小边（vv）的begin：4。因为parent中全都是0所以传出值使
得n=4。
5.第11行，同样作法，传入（v4v）的end：7。传出值使得m=7。
6.第12~16行，很显然n与m不相等，因此parent[4]=7。此时parent数组值
为{0，0，0，0，7，0，0，0，0}，并且打印得到“（4，7）7”。此时我们已
经将边（v4v）纳入到最小生成树中，如图7-6-8所示。
注：详细代码，本书提供下载。
253
---
## Page 278
大话
数据结构
图7-6-8
7.循环返回，执行10~16行，此时i=1，edge[1]得到边（v2vs），n=2，m=8，
parent[2]=8，打印结果为“（2，8）8”，此时parent数组值为（0，0，8，0，
7，0，0，0，0}，这也就表示边（v4V）和边（v2va）已经纳入到最小生成
树，如图7-6-9所示。
图7-6-9
8.再次执行10~16行，此时i=2，edge[2]得到边（vov），n=0，m=1，
parent[0]=1，打印结果为“（0，1）10"，此时parent 数组值为（1，0，8，
0，7，0，0，0，0），此时边（v4v）、（vzva）和（vavi）已经纳入到最小生
成树，如图7-6-10所示。
图7-6-10
254
---
## Page 279
第7章图
9.当i=3、4、5、6时，分别将边（vavs）、（vVg）、（v3v7）、（vVs）纳入到最
小生成树中，如图7-6-11所示。此时parent数组值为{1，5，8，7，7，8，
0，0，6，怎么去解读这个数组现在这些数字的意义呢？
-
i=5
i=6
图 7-6-11
从图7-6-11的最右图i=6的粗线连线可以得到，我们其实是有两个连通的边集合
A与B中纳入到最小生成树中的，如图7-6-12所示。当parent[0]=1，表示vo和v1
已经在生成树的边集合A中。此时将parent[0]=1的1改为下标，由parent[1]=5，表
示v和vs在边集合A中，parent[5]=8表示vs与va在边集合A中，parent[8]=6表
示v与v在边集合A中，parent[6]=0表示集合A暂时到头，此时边集合A有vo、
Vi、Vs、Vs、V6。我们查看parent中没有查看的值，parent[2]=8表示v2与va在一个
集合中，因此v2也在边集合A中。再由parent[3]=7、parent[4]=7和parent[7]=0可
知V3、V4、V在另一个边集合B中。
255
---
## Page 280
大语数保结构
边集合A
一此连线造成边集合A
形成环路
此连线造成边集合A
形成环路
3
边集合B
i=6
图 7-6-12
10.当i=7时，第10行，调用Find函数，会传入参数edges[7].begin=5。此时第
21行，parent[5]=8>0，所以f=8，再循环得parent[8]=6。因parent[6]=0所
以Find返回后第10行得到n=6。而此时第11行，传入参数edges[7].end=6
得到m=6。此时n=m，不再打印，继续下一循环。这就告诉我们，因为边
（vsv）使得边集合A形成了环路。因此不能将它纳入到最小生成树中，如图
7-6-12所示。
11.当i=8时，与上面相同，由于边（vV2）使得边集合A形成了环路。因此不
能将它纳入到最小生成树中，如图7-6-12所示。
12.当i=9时，边（vv7），第10行得到n=6，第11行得到m=7，因此
parent[6]=7，打印“（6，7）19°。此时parent数组值为（1，5，8，7，7，
8，7，0，6}，如图7-6-13所示。
13.此后边的循环均造成环路，最终最小生成树即为图7-6-13所示。
V
V4
YA
V
图 7-6-13
256
---
## Page 281
第7章图
好了，我们来把克鲁斯卡尔（Kruskal）算法的实现定义归纳一下结束这一节的讲
解。
假设N=（V.（E））是连通网，则令最小生成树的初始状态为只有n个顶点而无边的
非连通图T={V0)，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若
该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而
选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。
此算法的Find函数由边数e决定，时间复杂度为O（oge)，而外面有一个for循环
e次。所以克鲁斯卡尔算法的时间复杂度为0（ebge)。
对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，
所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更
好一些。12
7.7最短路径
我们时常会面临着对路径选择的决策问题。例如在北京、上海、广州等城市，因其
城市面积较大，乘地铁或公交都要考虑从A点到B点，如何换乘到达？比如图7-7-1
这样的地铁网图，如果不是专门去做研究，对于刚接触的人来说，都会犯迷糊。
现实中，每个人需求不同，选择方案就不尽相同。有人为了省钱，它需要的是路
程最短（定价以路程长短为标准），但可能由于线路班次少，换乘站间距离长等原因并
不省时间；而另一些人，为了要赶飞机火车或者早晨上班不迟到，他最大的需求是总
时间要短；还有一类人，如老人行动不便，或者上班族下班，忙碌一天累得要死，他
们都不想多走路，哪怕车子绕远路耗时长也无所谓，关键是换乘要少，这样可以在车
上好好休息一下（有些线路方案换乘两次比换乘三四次耗时还长）。这些都是老百姓的
需求，简单的图形可以靠人的经验和感觉，但复杂的道路或地铁网就需要计算机通过
算法计算来提供最佳的方案。我们今天就要来研究关于图的最短路径的问题。
注”：关于该算法详细讲解，请参考（翼泌导论）第六部分图算法的232节
257
---
## Page 282
图7-7-1
在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，
所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；面对于网图来说，
最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第
一个顶点是源点，最后一个顶点是终点。显然，我们研究网图更有实际意义，就地图
来说，距离就是两顶点间的权值之和。而非网图完全可以理解为所有的边的权值都为
1的网。
我们要讲解两种求最短路径的算法。先来讲第一种，从某个源点到其余各顶点的
最短路径问题。
你能很快计算出图7-7-2中由源点vo到终点vg的最短路径吗？如果不能，没关
系，我们一同来研究看如何让计算机计算出来。如果能，哼哼，那仅代表你智商还不
错，你还是要来好好学习，毕竞真实世界的图可没这么简单，人脑是用来创造而不是
做枯燥复杂的计算的。好了，我们开始吧。
258
---
## Page 283
第7章图
图7-7-2
7.7.1迪杰斯特拉（Dijkstra）算法
这是一个按路径长度递增的次序产生最短路径的算法。它的思路大体是这样的。
比如说要求图7-7-3中顶点vo到顶点v的最短距离，没有比这更简单的了，答案
就是1，路径就是直接v连线到V1
图7-7-3
由于顶点v还与v2、V3、v4连线，所以此时我们同时求得了V-V1→V2=1+3=4，
Vo→V1→V=1+7=8,Vo→V1→V4=1+5=6。
现在，我问vo到v2的最短距离，如果你不假思索地说是5，那就犯错了。因为边
上都有权值，刚才已经有vo→V1→V2的结果是4，比5还要小1个单位，它才是最短
距离，如图7-7-4所示。
图7-7-4
由于顶点v2还与v、vs连线，所以此时我们同时求得了vo→Vz-V4其实就是vo
259
---
## Page 284
大语数据结构
V1→Vz→V4=4+1=5，Vo→V2→Vs=4+7=11。这里vo→V2我们用的是刚才计算出来的较
小的4。此时我们也发现vo→V1→V2→V=5要比ve→V1→V=6还要小。所以vo到v4
目前的最小距离是5，如图7-7-5所示。
V
图 7-7-5
当我们要求vo到v的最短距离时，通向vs的三条边，除了v没有研究过外，Vo
→V1→v3的结果是8，而vo→V4→vy=5+2=7。因此，vo到vs的最短距离是7，如图7-
7-6所示。
图7-7-6
好了，我想你大致明白，这个迪杰斯特拉（Dijkstra）算法是如何干活的了。它并
不是一下子就求出了vo到v的最短路径，而是一步步求出它们之间顶点的最短路
径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终
得到你要的结果。
如果还是不太明白，不要紧，现在我们来看代码，从代码的模拟运行中，再次去
理解它的思想。
define MAXVEX9
define INFINITY 65535
/*用于存储最短路径下标的数组·/
typedetintShortPathTable[MAXVEX]:/*用子存储到各点最姓路径的权值和*/
/DijkstEa算法，求有向网G的v顶点到其余项点v最短路径P[v]及带权长度D[v]*/
260
---
## Page 285
第7章图
/P[v]的值为前驱顶点下标，D[v]表示v。到v的最短路径长度和。*/
void ShortestPath_Dijkstra (MGraph G,int Ve,Pathmatirx *P,
ShortPathTable*D)
2
3
int v,w,k,min;
4
intfinal[MAxVEx];/·final[w]-1表示求得项点vg至v的最短路径*/
5
for（v-0;v<G.numVertexes;v++）
/*初始化数据*/
6
7
final[v]-0;
/*全部顶点初始化为未知最短路径状态/
8
（D）[v]=G.matirx[vo][v]：/·将与vg点有连线的项点加上权值·/
9
10-[a]（a）
/*初始化路径数组P为0*/
10
11
（*D）[v]=0
/*v至v路径为0*/
12
final[vs]-1;