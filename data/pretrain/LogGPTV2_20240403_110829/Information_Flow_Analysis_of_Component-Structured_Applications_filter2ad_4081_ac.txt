and selects one depending of its costs and its level of pro-
tection. Since countermeasures may contain vulnerabilities
themselves, the analysis iterates the third and forth phases.
If the newly calculated risks can be accepted as bearable,
the analysis terminates. Otherwise, new countermeasures
are suggested and further iterations take place.
5. Information Flow Analysis
In order to apply the object-oriented security analysis
approach for evaluation of security ﬂows of component-
structured software, we had to develop new class libraries
and graph rewrite systems. The ﬁve classes Component,
Channel, Data, DataStruct, and Permission were added to
the class library for the design of system models. These
classes are multiply inherited from basic application resp.
data classes (cf. Sec. 4) and from a new class InfoFlow.
They inherit the properties describing security levels from
the basic classes while InfoFlow introduces two new prop-
erties modeling an acts for-hierarchy and a label (cf. Sec 3).
Moreover, the class library is extended by the association
classes Sends, Receives, Transfers, Stores, Permits, and
Contains specifying relations between objects.
Fig. 2 delineates an example system for the manage-
ment of patient records in a hospital which is explained
in Sec. 6. It consists of four software components speci-
ﬁed by the objects HospDB, Declass, D1, and D2 of class
Component. Objects of class Channel model simplex infor-
mation channels between two components (e.g., the object
HospDB-Declass models information ﬂow from HospDB to
Declass). The channel object is linked with the transmit-
ting component by an edge of association type Sends and
with the receiving component by a Receives association.
Data units stored in components or transferred via chan-
nels are speciﬁed by objects of class Data. In particular,
one can deﬁne data structures utilizing instances of the class
DataStruct which is inherited from Data. The data objects
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:09:06 UTC from IEEE Xplore.  Restrictions apply. 
Figure 3. Properties of object PP1
particular domain, however, only the conﬁdentiality level
is used. The acts for-hierarchy is deﬁned in the next prop-
erty in which the operator (cid:3) is represented by the symbol
(cid:19). Beneath, one can set the label of object PP1. In contrast
to other objects, instances of class Permission contain two
further properties for deﬁning declassiﬁcation policy rules.
By Add Readers the assignment of new readers in sub-labels
is speciﬁed. In this example, the component Declass stor-
ing the permission may add the reader (cid:20)(cid:6) to sub-labels with
owners (cid:6) or (cid:21) in the label of object P1Data. The dele-
tion of sub-labels is modeled by the property RemoveOwn-
ers which contains a list of principal identiﬁers. Sub-labels
owned by list members may be deleted.
The instantiation of these properties, moreover, is sup-
ported by two graph rewrite systems. The user has to set
the conﬁdentiality level for data objects only. By applying
rules of one rewrite system the conﬁdentiality levels of the
components and channels are set to the maximum security
level of the stored or transferred data units. Likewise, the la-
bels need to be adjusted for components and data units only.
By the rules of the other rewrite system consistent labels of
other system elements are ﬁxed. For instance, the label of
a data structure will be set to the Join of the data objects
deﬁning the structure (cf. Sec. 3).
The vulnerabilities and threats to the assets are modeled
by a second class library containing two different types for
describing vulnerabilities. The one class indicates incon-
sistent label settings which may cause eavesdropping of in-
formation. For instance, a component (cid:1) may store a data
unit (cid:2) with a stricter read access policy than (cid:1) itself. Thus,
at least one principal may exist which may access (cid:1) but
not (cid:2). By accessing (cid:1) this principal, however, may read
the stored data unit (cid:2), too. Vulnerabilities due to inconsis-
tent label settings are modeled by the class IncorrectLabels
and inherited classes describing certain kinds of inconsis-
tencies. The other vulnerability describes potential informa-
tion leaks due to malicious component behavior. This vul-
nerability is assigned to components containing data which
must not be transferred to each successor component. It is
speciﬁed by an instance of class IncorrectInfoFlow. A vul-
nerability of an asset leads to a threat on the conﬁdential-
Figure 2. Patient records management exam-
ple
forming the data structure are linked to the DataStruct in-
stance by edges of type Contains. In Fig. 2, for instance,
P1Data models a data structure consisting of the data ob-
jects P1DPatConﬁd and P1DHospConﬁd. A data or data
structure object may be associated to a channel by an edge
of class Transfers modeling that the data unit is transferred
via this channel. Likewise, it may be linked to a component
by a Stores association stating that the component stores
the data. Another class inherited from Data is Permission
which contains certain rules for declassifying data units (cf.
Sec. 3). It is linked with the data object to be declassiﬁed
by an edge of class Permits. In our example the object PP1
is a permission object stating that the component Declass
may declassify the data structure P1Data according to its
declassiﬁcation rules.
After system design one deﬁnes the security levels and
the read access policies of the system assets as well as the
declassiﬁcation rules of the permission objects by setting
corresponding object properties. Moreover, one ﬁxes the
acts for-hierarchy which is modeled by identical property
settings in all objects. We assume that this hierarchy is
ﬁxed during the whole security analysis process. Since,
according to [32], hierarchy revocations occur only infre-
quently, after each change a new analysis can be expected.
This corresponds to the fact that a security analysis has to
be repeated from time to time in order to react to new at-
tack strategies. As an example, Fig. 3 shows the property
of object PP1. Besides the object name one sets the se-
curity levels for conﬁdentiality, integrity, and availability
objectives to a number between one and seven. For the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:09:06 UTC from IEEE Xplore.  Restrictions apply. 
of (cid:1) is a relabeling of (cid:2).
Afterwards, one evaluates the seriousness of the vulnera-
bilities and threats in the system model which is performed
by a graph rewrite system, too. Incorrect label settings refer
to an inconsistent security policy which may easily be ex-
ploited by malicious intruders. Therefore, the seriousness
of instances of class IncorrectLabels and inherited classes
are always rated to the maximum value (cid:7). In contrast, the
likelihood of a successful attack caused by a malicious com-
ponent depends on the selected countermeasures. Accord-
ing the regulations of the CC [21] the property is set to (cid:6)
if the component was scrutinized by a source code analy-
sis. In case of a byte code veriﬁcation we apply the value (cid:8)
while due to the danger of steganography the application of
security wrappers leads to a seriousness value of (cid:9). Finally,
the application of components without any protection leads
to the setting (cid:7).
The creation of risk objects and the calculation of the risk
level according to the matrix in Tab. 1 is also performed by
a graph rewrite system. Moreover, rules are available which
may be combined to a rewrite system fulﬁlling a certain risk
assessment policy (e.g., the acceptance of all risks with a
level of (cid:6) or (cid:8)).
Countermeasures are imposed in two different ways. In
order to get rid of vulnerabilities due to incorrect label set-
tings, one applies a graph rewrite system making system
unit labels stricter. For instance, the rewrite system reacts
on the object DataExComponentL created by the rule out-
lined in Fig. 4 by replacing the label of component (cid:1) by the
Join of the previous label of (cid:1) and of the label of data unit
(cid:2). Due to the deﬁnition of Join the new label is a relabeling
of the label of (cid:2) and therefore fulﬁlls the read access policy
of (cid:2).
To reduce vulnerabilities due to malicious components,
a countermeasure class library was designed. Currently, it
consists of the classes SecurityWrapper, ByteCodeVeriﬁca-
tion, and SourceCodeAnalysis. The protection level prop-
erties of class instances are initialized according to rules of
the CC evaluation assessment levels while the initial cost
settings are estimated. For the security wrapper both prop-
erties are set to (cid:10) reﬂecting the low deployment costs and
the danger of Steganography.
In contrast, the properties
of the byte code veriﬁcation, which is more laborious and
therefore more expensive but provides a higher degree of
protection, are rated to (cid:11). Finally, for the source code anal-
ysis the protection value is set to (cid:12) since disguising of infor-
mation ﬂows is harder in source code than in compiled byte
code. Due to the usually enormous source code costs for
commercial software the costs are rated to (cid:7), here. In spe-
cial cases (e.g., freely available source code) these values
may be changed manually. Moreover, for this domain two
further graph rewrite systems were developed facilitating
the selection of suitable countermeasures with a sufﬁcient
Figure 4. Pre- and post-pattern of a graph
rewrite rule
ity of data which is modeled by objects of class Informa-
tionLeakOut. Moreover, the class contains two association
classes. Edges of type To are used to describe the relation
between a vulnerability and the corresponding asset while
the link between vulnerabilities and threats are speciﬁed by
edges of the class Exploiting.
The vulnerability and threat analysis is automatically
performed by application of a further graph rewrite system.
With respect to incorrect label settings one has to prove that
each data unit (cid:2) in the system is propagated to components
and channels with read access policies which are at least as
strict than that of (cid:2). Thus, the label of each system unit
passed by (cid:2) has to be a relabeling of the data unit label.
If (cid:2), however, is assigned with a permission  enabling
its declassiﬁcation, the test is more subtle. The analysis
has to check if (cid:2) passed already a component permitted
to classify it. Then the relabeling check has to include the
label of (cid:2) relaxed by the classiﬁcation rules deﬁned by  .
The check for potentially malicious components is also per-
formed by relabeling tests. Here, for each — possibly de-
classiﬁed — data unit (cid:2) passing a component (cid:1) one has to
examine whether the labels of all successor components of
(cid:1) are relabelings of the label of (cid:2). If the result of this ex-
amination is false, the component is dangerous and the tool
indicates it by an object of type IncorrectInfoFlow.
As an example, Fig. 4 outlines the pre- and post pattern
of one rule of the rewrite system. The rule states that a label
setting is wrong if the label of data unit (cid:2) is stricter than
the label of a component (cid:1) receiving (cid:2) from a transfer via
channel (cid:1)(cid:21). The scenario of (cid:1), (cid:1)(cid:21), and (cid:2) is listed in the
pre-pattern on the left side of the ﬁgure. Moreover, this pre-
pattern contains some inhibitory objects and edges which
must not be in the subgraph mapping this pattern. In par-
ticular, (cid:2) must not be associated to a permission  since
declassiﬁed data is modeled by other rules. Furthermore,
the scenario must not contain the vulnerability object to be
added in order to avoid iteration of this rule. The right side
of Fig. 4 delineates the post-pattern in which the vulnera-
bility object DataExCompomentL, an instance of a class in-
herited from IncorrectLabels, and the corresponding edges
are enclosed to (cid:1), (cid:1)(cid:21), and (cid:2). In addition, the rule contains
an application condition avoiding its execution if the label
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:09:06 UTC from IEEE Xplore.  Restrictions apply. 
protection level as well as selecting a cost-efﬁcient counter-
measure.
In order to realize support for information ﬂow analy-
sis of component-based software, we developed 21 classes
by inheriting already existing classes. Moreover, we cre-
ated nine graph rewrite systems consisting of altogether
45 rewrite rules. The total design time including pro-
gramming the operators of the decentralized labeling model
amounted to eight working days for a single person.
6. Example Application
As an example to clarify our approach we use the pa-
tient records managing system delineated in Fig. 2 which is
a simpliﬁed version of the example outlined in [32]. In this
system the basic idea is to prevent that every physician in
the hospital may read the record of each patient. Instead,
a doctor shall have access only to the records of patients
treated by herself. To specify this security policy, the model
uses the following principal roles: (cid:21) refers to the hospital
owner, (cid:6) and (cid:8) to two single patients,  to the set of all
patients, (cid:20)(cid:6) and (cid:20)(cid:8) to separate doctors, and (cid:20) to the set of
all doctors. These roles are related by the acts for-hierarchy
(cid:21) (cid:3) (cid:6)(cid:3) (cid:21) (cid:3) (cid:8)(cid:3) (cid:6) (cid:3) (cid:3) (cid:8) (cid:3) (cid:3) (cid:20)(cid:6) (cid:3) (cid:20)(cid:3) (cid:20)(cid:8) (cid:3) (cid:20). The hier-
archy elements (cid:21) (cid:3) (cid:6) and (cid:21) (cid:3) (cid:8) reﬂect that the hospital
owner (cid:21) keeps track of the records in behalf of the patients
and therefore must be allowed to act for each patient. The
other elements state that  describes the set of all patients
and that each single patient may act for this role. Likewise,
each doctor may act for the set of all doctors (cid:20).
The patient records of (cid:6) and (cid:8) are modeled by the data
structures D1Data resp. D2Data. D1Data consists of the
data units P1DPatConﬁd and P1DHospConﬁd. P1DPat-
Conﬁd models a patient record part which, before select-
ing a treating doctor, may be only read by patient (cid:6) him-
self and the hospital owner (cid:21) (e.g., (cid:6)’s medical record),
while data unit P1DHospConﬁd describes conﬁdential in-
formation which may be accessed by (cid:21) only. P1Data is
associated to a permission object PP1 facilitating its de-
classiﬁcation in order to make the patient record readable
for (cid:6)’s particular doctor (in this example (cid:20)(cid:6)). Similarly,
the patient record D2Data of patient (cid:8) is composed from
the data units P2DPatConﬁd and P2DHospConﬁd and may
be accessed by doctor (cid:20)(cid:8) due to the declassiﬁcation pol-
icy stated in permission PP2. The system is coupled from
four software components: The patient records are stored
in the database component HospDB. The assignment of pa-
tient records to particular doctors in order to enable treat-
ment of patients is realized by the component Declass. In
order to fulﬁll this task, Declass has to declassify the patient
records and therefore stores the permission objects PP1 and
PP2. The components (cid:2)(cid:6) and (cid:2)(cid:8) allow the doctors (cid:2)(cid:6) and
(cid:2)(cid:8) to read patient records. The transfer of patient records
from HospDB via Declass to (cid:2)(cid:6) or (cid:2)(cid:8) is modeled by the
channels HospDB-Declass, Declass-D1, and Declass-D2.
After designing the system model, one has to deﬁne
component and data unit labels, data unit conﬁdentiality se-
curity levels, and declassiﬁcation rules in the permissions.
The access policy to the patient records is constrained by the
patients themselves as well as by the hospital owner. The