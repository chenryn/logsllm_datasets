### 4. Countermeasure Selection and Iterative Analysis
The selection of an appropriate countermeasure depends on its cost and the level of protection it provides. Since countermeasures themselves may contain vulnerabilities, the analysis iterates through the third and fourth phases. If the newly calculated risks are deemed acceptable, the analysis concludes. Otherwise, new countermeasures are proposed, and the process continues with further iterations.

### 5. Information Flow Analysis
To apply the object-oriented security analysis approach to evaluate the security flows of component-structured software, we developed new class libraries and graph rewrite systems. The following five classes were added to the class library for system model design: `Component`, `Channel`, `Data`, `DataStruct`, and `Permission`. These classes inherit properties from both basic application and data classes (as discussed in Section 4) and a new class `InfoFlow`. The `InfoFlow` class introduces two new properties: an "acts-for" hierarchy and a label (refer to Section 3).

Additionally, the class library was extended with association classes: `Sends`, `Receives`, `Transfers`, `Stores`, `Permits`, and `Contains`, which specify relationships between objects.

**Figure 2** illustrates an example system for managing patient records in a hospital, which is explained in Section 6. This system comprises four software components represented by the `Component` class objects: `HospDB`, `Declass`, `D1`, and `D2`. Objects of the `Channel` class model simplex information channels between two components. For instance, the `HospDB-Declass` channel models the information flow from `HospDB` to `Declass`. The channel object is linked to the transmitting component via a `Sends` association and to the receiving component via a `Receives` association.

Data units stored in components or transferred via channels are specified by `Data` class objects. Data structures can be defined using instances of the `DataStruct` class, which inherits from `Data`. In **Figure 2**, `P1Data` models a data structure consisting of the data objects `P1DPatConﬁd` and `P1DHospConﬁd`. A data or data structure object can be associated with a channel via a `Transfers` association, indicating that the data unit is transferred through this channel. Similarly, it can be linked to a component via a `Stores` association, indicating that the component stores the data.

The `Permission` class, inherited from `Data`, contains rules for declassifying data units (as discussed in Section 3). It is linked to the data object to be declassified via a `Permits` association. In our example, the `PP1` object is a permission object that allows the `Declass` component to declassify the `P1Data` data structure according to its declassification rules.

After designing the system, one defines the security levels and read access policies for the system assets, as well as the declassification rules for the permission objects, by setting corresponding object properties. The "acts-for" hierarchy is modeled by identical property settings across all objects and is assumed to remain fixed during the entire security analysis process. According to [32], hierarchy revocations occur infrequently, so after each change, a new analysis can be expected. This aligns with the need to periodically repeat security analyses to address new attack strategies.

**Figure 3** shows the properties of the `PP1` object. Besides the object name, one sets the security levels for confidentiality, integrity, and availability objectives to a number between one and seven. In this particular domain, only the confidentiality level is used. The "acts-for" hierarchy is defined in the next property, where the operator (cid:3) is represented by the symbol (cid:19). Below, one can set the label of the `PP1` object. Unlike other objects, instances of the `Permission` class contain two additional properties for defining declassification policy rules: `Add Readers` and `RemoveOwners`.

The instantiation of these properties is supported by two graph rewrite systems. The user needs to set the confidentiality level for data objects. By applying rules from one rewrite system, the confidentiality levels of the components and channels are set to the maximum security level of the stored or transferred data units. Similarly, labels need to be adjusted for components and data units. By applying rules from the other rewrite system, consistent labels for other system elements are fixed. For instance, the label of a data structure will be set to the Join of the data objects defining the structure (refer to Section 3).

### 6. Vulnerability and Threat Modeling
Vulnerabilities and threats to the assets are modeled using a second class library containing two types of classes for describing vulnerabilities. One class, `IncorrectLabels`, indicates inconsistent label settings that may cause eavesdropping. For example, a component (cid:1) may store a data unit (cid:2) with a stricter read access policy than (cid:1) itself. This inconsistency can lead to a principal accessing (cid:1) but not (cid:2), and thus potentially reading the stored data unit (cid:2). Such vulnerabilities are modeled by the `IncorrectLabels` class and its inherited classes.

The other vulnerability, `IncorrectInfoFlow`, describes potential information leaks due to malicious component behavior. This vulnerability is assigned to components containing data that must not be transferred to each successor component. A vulnerability in an asset leads to a threat on the confidentiality of the system.

### 7. Risk Evaluation and Countermeasure Application
The evaluation of the seriousness of vulnerabilities and threats is performed by a graph rewrite system. Incorrect label settings, which indicate an inconsistent security policy, are always rated to the maximum value (cid:7) because they can be easily exploited by malicious intruders. The likelihood of a successful attack caused by a malicious component depends on the selected countermeasures. According to the Common Criteria (CC) [21], the seriousness is set to (cid:6) if the component was scrutinized by a source code analysis, (cid:8) if a byte code verification was performed, and (cid:9) if security wrappers were applied. Components without any protection are rated (cid:7).

Risk objects are created, and the risk level is calculated according to the matrix in Table 1, using a graph rewrite system. Rules are available that can be combined into a rewrite system to fulfill a specific risk assessment policy, such as accepting all risks with a level of (cid:6) or (cid:8).

Countermeasures are imposed in two ways:
1. To correct vulnerabilities due to incorrect label settings, a graph rewrite system makes system unit labels stricter.
2. To reduce vulnerabilities due to malicious components, a countermeasure class library was designed, including `SecurityWrapper`, `ByteCodeVerification`, and `SourceCodeAnalysis`. The protection level properties of class instances are initialized according to CC evaluation assessment levels, while the initial cost settings are estimated.

### 8. Example Application
As an example, we use the patient records management system shown in **Figure 2**, which is a simplified version of the example outlined in [32]. The goal is to prevent every physician in the hospital from reading the record of each patient. Instead, a doctor should have access only to the records of patients they treat. The model uses the following principal roles: (cid:21) for the hospital owner, (cid:6) and (cid:8) for two single patients,  for the set of all patients, (cid:20)(cid:6) and (cid:20)(cid:8) for separate doctors, and (cid:20) for the set of all doctors. These roles are related by the "acts-for" hierarchy (cid:21) (cid:3) (cid:6)(cid:3) (cid:21) (cid:3) (cid:8)(cid:3) (cid:6) (cid:3) (cid:3) (cid:8) (cid:3) (cid:3) (cid:20)(cid:6) (cid:3) (cid:20)(cid:3) (cid:20)(cid:8) (cid:3) (cid:20).

The patient records of (cid:6) and (cid:8) are modeled by the data structures `D1Data` and `D2Data`. `D1Data` consists of the data units `P1DPatConﬁd` and `P1DHospConﬁd`. `P1DPatConﬁd` models a patient record part that, before selecting a treating doctor, can only be read by patient (cid:6) and the hospital owner (cid:21). `P1DHospConﬁd` describes confidential information accessible only by (cid:21). `P1Data` is associated with a permission object `PP1` to facilitate its declassification, making the patient record readable for (cid:6)'s particular doctor (in this example, (cid:20)(cid:6)). Similarly, the patient record `D2Data` of patient (cid:8) is composed of the data units `P2DPatConﬁd` and `P2DHospConﬁd` and can be accessed by doctor (cid:20)(cid:8) due to the declassification policy stated in permission `PP2`.

The system is composed of four software components: the database component `HospDB` stores patient records, the `Declass` component assigns patient records to particular doctors, and the components (cid:2)(cid:6) and (cid:2)(cid:8) allow doctors (cid:2)(cid:6) and (cid:2)(cid:8) to read patient records. The transfer of patient records from `HospDB` via `Declass` to (cid:2)(cid:6) or (cid:2)(cid:8) is modeled by the channels `HospDB-Declass`, `Declass-D1`, and `Declass-D2`.

After designing the system model, one defines component and data unit labels, data unit confidentiality security levels, and declassification rules in the permissions. The access policy to the patient records is constrained by the patients themselves and the hospital owner.