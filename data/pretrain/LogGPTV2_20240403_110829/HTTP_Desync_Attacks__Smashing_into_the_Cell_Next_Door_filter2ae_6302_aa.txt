# HTTP Desync Attacks: Smashing into the Cell Next Door
文章转载议题:)
James Kettle - PI:EMAIL - @albinowax
## 写在前面
第一次译是在议题出来的第二天，然而当时也有很多的地方看不懂，所以有的地方是完全按照ppt的英文句意来译了。后来师傅们发现存在很多bug的地方，在这里只能说句对不起了。最近自己也去看了很多关于smuggle的案例。个人感觉漏洞的成因是后端使用一个socket去处理http请求从而达到向别人http报文偷毒的可能。在文中大部分内容是介绍如何在真实环境中验证走私但不危害别人的请求，我觉得大致有两个前提：1.前后端处理消息长度的方式不一样，并且后端要能够识别Transfer-Encoding，并依此来分割http请求。2.找到一个存储post请求的地方，最好是能够对post的参数进行反射，为了验证我们是否将别人的请求带回。
如果文中还有不妥的地方，烦请各位师傅指出
## Abstract
传统上，HTTP请求被视为独立的独立实体。在本文中，我将探讨一种远程、未经身份验证的攻击者能够打破这种隔离并将其请求转接到其他人身上的技术。通过这种技术，我可以在众多商业和军事系统的WEB基础应用上扮演一位操作者，在他们的虚拟环境中使用漏洞，并且在bug
bounties中获得超过6万美元
将这些目标作为案例研究，我将向您展示如何巧妙地修改受害者的请求，以将其路由到恶意领域，调用有害的响应。我还将演示在您自己的请求中使用后端重组，攻击基于前端的各种信任，获得对内部API的最大特权访问，投毒Web缓存，并危及paypal的登录页面。
HTTP Request
Smuggling(后文称为请求走私)最初是由WatchFire1于2005年记录下来的，但由于其困难和附带损害的可怕名声，使得当Web服务的敏感性增常期间，它大多被忽视。除了新的攻击变种和利用途径之外，我将帮助您使用定制的开源工具和一种改进的方法来处理这一遗留问题，以最小的风险进行可靠的黑盒检测、评估和利用
## Core concepts
自HTTP/1.1以来，通过一个底层TCP或SSL/TLS套接字发送多个HTTP请求被广泛支持。这个协议非常简单——HTTP请求只需背靠背地放置，服务器解析报头就可以知道每个报头的结束位置和下一个报头的开始位置。这经常与HTTP
pipeline2混淆，后者是少见的类型，在本文的攻击描述中不予介绍。
这本身是无害的。然而，现代网站是由一系列的系统组成的，都是通过HTTP进行对话的。此多层体系结构接收来自多个不同用户的HTTP请求，并通过单个TCP/TLS连接将其路由：  
这意味着，后端与前端关于“每条消息在哪里结束”达成一致是至关重要的。否则，攻击者可能会发送一条不明确的消息，使后端将其解释为两个不同的HTTP请求
这使攻击者能够在下一个合法用户请求开始时预先处理任意内容。在本文中，走私内容将被称为“前缀”，并以橙色突出显示。
让我们假设前端浏览器优先处理第一个内容长度头，后端优先处理第二个内容长度头。从后端的角度来看，TCP流可能看起来像：
在引擎中，前端浏览器将蓝色和橙色数据转发到后端，后端在发出响应之前只读取蓝色内容。这使得后端套接字受到橙色数据的污染。当合法的绿色请求到达时，它最终附加到橙色内容上，导致意外的响应。
在这个例子中，注入的“G”会破坏绿色用户的请求，他们可能会得到“未知方法GPOST”的响应。
本文中的每个攻击都遵循这个基本格式。WatchFire论文描述了一种称为“反向请求走私”的替代方法，但这依赖于前端和后端系统之间的管道连接，因此很少有选择。
在现实生活中，双重content-length技术很少起作用，因为许多系统明智地拒绝具有多个内容长度头的请求。相反，我们将使用分块编码攻击系统-这次我们利用RFC2616规范：
**如果接收的消息同时包含传输编码头字段(Transfer-Encoding)和内容长度头(Content-Length)字段，则必须忽略后者**
由于规范默许可以使用Transfer-Encoding和Content-Length处理请求，因此很少有服务器拒绝此类请求。每当我们找到一种方法，将Transfer-Encoding隐藏在服务端的一个chain中时，它将会回退到使用Content-Length去发送请求。因此我们可以取消整个系统的同步。
您可能不太熟悉分块编码，因为像Burp
Suite这样的工具会自动将分块的请求/响应缓冲到常规消息中，以便于编辑。在分块的消息中，正文由0个或多个分块组成。每个块由块大小、换行符和块内容组成。消息以0大小的块终止。以下是使用分块编码进行的简单失步(desynchronisation)攻击：
在这种情况，我们没有在这里隐藏传输编码头(Transfer-Encoding
header)，因此此漏洞主要适用于前端根本不支持分块编码的系统，这在使用Akamai cdn(content delivery
network)的许多网站上都可以看到。
如果后端不支持分块编码，我们需要翻转偏移量：  
这种技术在相当多的系统上都起作用，但是我们可以让传输编码头难以被发现，从而利用更多的资源，这样一个系统就“看不到它”。这可以通过使用服务器的HTTP解析的差异来实现。下面是一些只有部分服务识别传输编码的请求示例：分块头(Transfer-Encoding)。在本研究中，每个都成功地用于攻破至少一个系统：
如果前端和后端服务器都有这些处理，那么每个处理都是无害的，否则都是一个重大威胁。有关更多技术，请查看Regilero正在进行的research4.。我们稍后将使用其他技术查看实际示例。
## Methodology
请求走私背后的理论是直截了当的，但是不受控制变量的数量和我们对前端所发生事情的完全不了解会导致复杂的情况。
我已经开发了应对这些挑战的技术和工具，并将它们组合成以下简单的方法，我们可以利用这些方法来追查请求的走私漏洞并证明其影响：  
## Detect
检测请求走私漏洞的明显方法是发出一个含糊不清的请求，然后发出一个正常的“受害者”请求，然后观察后者是否得到意外的响应。但是，这极易受到干扰；如果另一个用户的请求在受害者请求之前击中中毒的套接字，那么他们将得到损坏的响应，我们将不会发现该漏洞。这意味着，在流量很大的网站，如果不在过程中利用大量用户去测试，就很难证明存在
**请求走私** 漏洞。即使在没有其他流量的站点上，您也会面临应用程序级异常终止连接所导致的风险。
为了解决这个问题，我开发了一种检测策略，它使用一系列请求包，使得易受攻击的后端系统挂起并超时连接。这种技术几乎没有误报，可以抵抗应用程序级的行为从而导致的误报，最重要的是，它几乎没有影响其他用户的风险。
假设前端服务器使用Content-Length头，后端使用Transfer-Encoding头。我简称这个目标为cl.te。我们可以通过发送以下请求来检测潜在的请求走私：
由于内容长度较短，前端将只转发蓝色文本，后端将在等待下一个块大小时超时。这将导致可观察到的时间延迟。
如果两个服务器都是同步的（te.te或cl.cl），则前端将拒绝该请求，或者两个系统都将无害地处理该请求。最后，如果从另一个角度（te.cl）执行去同步，由于块大小“q”无效，前端将拒绝消息而不将其转发到后端。这可以防止后端套接字中毒。
我们可以使用以下请求安全地检测te.cl去同步：  
由于“0”分块的终止，前端将只转发蓝色文本，后端将超时等待X到达。
如果Desync以另一种方式发生（cl.te），那么这种方法将使用"X"毒害后端套接字，可能会危害合法用户。幸运的是，通过始终运行首先检测方法，我们可以排除这种可能性。
这些请求可以针对头解析中的任意差异进行调整，并用于通过Desyn chronize5自动识别请求走私漏洞-一个开发用于帮助此类攻击的开源Burp Suite
扩展。它们现在也用于Burp
Suite的scanner。尽管这是一个服务器级的漏洞，但单个域上的不同端点通常路由到不同的目标，因此该技术应单独应用于每个端点。
## Confirm
在这一点上，你已经尽了最大努力，而不会给其他用户带来副作用的风险。然而，许多客户不愿意在没有进一步证据的情况下认真对待报告，所以这就是我们将要克服的。证明请求走私的全部危害的下一步是证明后端套接字中毒是可能的。为此，我们将发出一个旨在毒害后端套接字的请求，然后发出一个希望成为毒害受害者的请求，明显地改变了响应。
如果第一个请求导致错误，后端服务器可能会决定关闭连接，丢弃中毒缓冲区并破坏攻击。尝试通过将设计用于接受POST请求的端点作为目标，并保留任何预期的GET/POST参数来避免这种情况。
有些站点有多个不同的后端系统，前端查看每个请求的方法、URL和头，以决定将其路由到何处。如果受害者请求路由到与攻击请求不同的后端，那么攻击将失败。因此，“攻击”和“受害者”请求最初应尽可能相似。