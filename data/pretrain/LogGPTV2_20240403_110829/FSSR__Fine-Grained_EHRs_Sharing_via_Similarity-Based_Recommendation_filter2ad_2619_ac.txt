6,k,i)υk )
∏
k∈Ω(gλ(cid:26)(k)u(t0tρ(k))ur
∑
ai∈W T υk
2 )
k∈Ω υk·r
e(C3,
′
k )
υk )
∏
∑
ai∈W ti)u
k∈Ω υk·r
′
k )
ai∈U\{ρ(k)} tur
i
′
k
)υk )
(7)
Proof:
∏
e(C2, T0·∏
∏
e(gs, gα(β−u)·H(q)·∏
k∈Ω(D
e(C3,
′
4,k
=
=
∏
e(gs, gα(β−u)·H(q)·gαu(t0
e((t0
ai∈W ti)s, gu
=e(gs, gαβ)e(gs, H(q))
e(C2, T0·∏
∏
∏
k∈Ω(T1
e(C3,
ai∈W T υk
2 )
′s · e(g, H(w)s) = C4
= Z
Finally, this algorithm outputs the transformed cipher-
text K.
Decrypt: This algorithm inputs the transformed cipher-
text K, the ciphertext component C1 and the user secret key
U SK, then it recovers the data M sg by computing
M sg = C1 · K
1
u
(6)
6 SECURITY ANALYSIS
6.1 Correctness
Theorem 1: The proposed LABSE scheme can correctly search
the desired ciphertext if it inputs the valid trapdoor.
The following equation holds only if q = w,
ai∈U\{ρ(k)} T3)υk )
′s · e(g, H(q)s)
= Z
(8)
then CT = (W, C1, C2, C3, C4) is deemed as the de-
sired ciphertext.
Theorem 2: The proposed LABSE scheme can correctly recov-
′
3,k,i)πk )
k∈Ω(gurk )πk )
ai∈W\{ρ(k)} trk
er the message.
e(gs,
e((t0
e(C2,
∏
∏
′
2,k)πk )
Proof: M sg = K 1
e(C3,
′
k∈Ω(D
1,k
k∈Ω(D
ai∈W\{ρ(k)} D
∏
u · C1
∏
∏
{
∏
{
∏
{
∏
·(M sg·Z s)
{
e((t0
∏
e(gs, guα · (t0
∏
ai∈W ti)u
· e(g, g)α·s · M sg = M sg
ai∈W ti)s,
∑
ai∈W ti)s, gu
∑
ai∈W ti)u
∑
ai∈W ti)u
k∈Ω(guλ(cid:26)(k)(t0tρ(k))urk
∑
k∈Ω rkπk )
e(gs, (t0
∏
e((t0
1
k∈Ω rkπk , gs)
k∈Ω rkπk ))
=
=
=
=
=
e(guα, gs) 1
u
} 1
u ·(M sg·Z s)
} 1
u
i )πk )
} 1
u ·(M sg·Z s)
} 1
u ·(M sg·Z s)
(9)
k∈Ω rkπk )e(guα, gs))
∏
C1 =M sg · C
C3 =(t0
ai∈W
′
′
2,
1, C2 = C
′
ti)s, C4 = C
4
· e(C
′
2, H(w))
(2)
This
algorithm outputs
the
ciphertext CT =
(W, C1, C2, C3, C4).
OSKGen: This algorithm takes as input the secret key
SK(M,ρ), the public parameter M P K and the master secret
key M SK, then it randomly selects u ∈ Zp, and computes
D
′
0 = gα(β−u)
′
1,k = (D1,k)u = guλ(cid:26)(k)(t0tρ(k))urk
D
′
2,k = (D2,k)u = gurk
D
{D
}ai∈U\{ρ(k)}
′
3,k,i = (D3,k,i)u = turk
′
4,k = (D4,k)u = guλ(cid:26)(k)(t0tρ(k))ur
D
′
5,k = (D5,k)u = gur
D
{D
′
6,k,i = (D6,k,i)u = tur
algorithm assembles
′
k
′
k
i
i
′
k
′
6,k,i
′
0, D
′
1,k, D
′
4,k, D
}ai∈U\{ρ(k)}
the
2,k,{D
′
This
OSK(M,ρ) = ((M, ρ), D
5,k,{D
′
, D
key U SK = u.
(3)
outsourcing key
}ai∈U\{ρ(k)}
}ai∈U\{ρ(k)})k∈[1,l] and the user secret
TrapGen: Take as input the outsourcing key OSK(M,ρ)
· H(q),
and the query q, this algorithm computes T0 = D
′
6,k,i and assembles
T1 = D
the trapdoor T D = (T0, T1, T2, T3) that associated with the
query q.
′
5,k and T3 = D
′
4,k, T2 = D
′
3,k,i
TKGen: This algorithm takes the outsourcing key
′
OSK as input,
1,k, T K2 =
′
′
3,k,i then outputs the transformation key
D
2,k, T K3 = D
T K = ((M, ρ), T K1, T K2, T K3).
then it sets T K1 = D
Search: This algorithm takes the public parameter
M P K, the ciphertext CT and the trapdoor T D as input,
then it follows the steps as below.
′
0
1). Implement the Reconstruct algorithm to generate a
k∈Ω λρ(k) · υk =
set of constant {υk} ∈ Zp such that
(1, 0, ..., 0).
2). Examines whether the following equation holds
∑
e(C2, T0 ·∏
∏
∏
k∈Ω(T1
ai∈U\{ρ(k)} T3)υk )
e(C3,
ai∈W T2
υk )
= C4
(4)
where Ω denotes the collection of all k that satisﬁes
ρ(k) ∈ W . It implies there exists q = w if the above equation
holds, then the ciphertext would be forwarded to the data
user. Otherwise, it outputs ⊥, which indicates that CT is not
the desired ciphertext.
Transform: This algorithm takes as input the ciphertext
CT and the transformation key T K, then executes the
following steps.
1). Check whether the attribute set W corresponds to
the ciphertext CT satisﬁes the LSSS access structure
(M, ρ). If not,
it runs the
following steps.
it outputs ⊥, otherwise,
2327-4662 (c) 2021 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:21:45 UTC from IEEE Xplore.  Restrictions apply. 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2021.3063846, IEEE Internet of
Things Journal
IEEE, VOL., NO.,
6.2 Semantic security
Theorem 3: The LABSE scheme is selectively IND-CPA-CKA
′
W
, gs) or a random value in GT .
secure under the q-DBDH assumption.
Proof : If our LABSE scheme can be compromised
by a PPT adversary A with a non-negligible probabil-
then there exists a PPT challenger C, who can
ity ε,
solve the n-DBDH problem by interacting with the ad-
versary A. The challenger C is given a (2n + 2)-tuple
(g, gs, g1, ..., gn−1, gn+1, ..., g2n, Y ), where s ∈ Zp and gy =
gay , then C is required to output its decision whether
Y = e(gan+1
Initialize. The adversary A assigns a target attribute set
∗ ⊆ U, where U is the attribute universe generated by the
Setup. The challenger C randomly selects α
, a ∈ Zp,
∏
′ · e(g1, gn) to implicitly set α =
and deﬁnes Z = e(g, g)α
+ aq+1. C samples γ0,{γi} ∈ Zp for each attribute ai ∈ U,
′
α
and ti = gγi gn+1−i.
then it computes t0 = gγ0
Finally, the challenger C forwards to the adversary A the
public parameter M P K = (G, GT , g, e, p, Z, t0,{ti}i∈[1,n]).
Phase 1. The adversary A issues a sequence of queries
to the challenger C, and C responds A’s queries in the
following way.
challenger C.
ai∈W ∗ t
−1
i
′
2, ..., v
∈ Z m−1
1).Secret key query. Suppose there is a LSSS access struc-
ture (M, ρ) such that the target attribute set W
does not
satisfy it, where M is a l × m LSSS matrix. Deﬁne a vector
such that ⃗Mk · ⃗φ = 0. C then
⃗φ = (−1, φ2, ..., φm) ∈ Z m−1
, and implicitly sets v =
randomly selects v
+ an+1,−(α
2, ...,−(α
′
′
′
p
+ an+1)φ2 + v
m),
(α
thus ⃗v = −(α
′
′
′