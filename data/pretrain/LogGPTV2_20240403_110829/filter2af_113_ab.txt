上图展示了我如何将`gremlin`与后续数组元素一起使用。布置好后，ar1(gremlin)`上会放置 **目标对象的地址** 。
## 第二部分：从内存控制到代码执行
传统上，此时的下一步是利用我们的 **内存读写**
功能来进行`ROP`，最终导致本机的代码执行。但是，这些方法已经得到了很好的探索。我很想尝试一些更具创新性的东西。
我受到了[tombkeeper](https://twitter.com/tombkeeper)在2014年描述的[Vital Point
Strike](https://www.blackhat.com/docs/us-14/materials/us-14-Yu-Write-Once-Pwn-Anywhere.pdf) [PDF幻灯片]技术的启发。该攻击的基本思想是 **使用内存读/写功能** 来 **定位和更改内存中的数据结构**
，从而关闭`SafeMode`。完成后，脚本可以简单地实例化任意`ActiveX`对象，如`WScript.Shell`，并利用它提供的丰富功能。
自2014年`blackhat`演讲以来，微软已经为`tombkeeper`的原始演示文稿的“生命点”添加了强大的篡改保护，所以我不相信这是一种可行的技术。但问题仍然是关于可以找到其他“关键点”的问题。
我猜想，一旦攻击者对进程的地址空间进行 **任意读/写访问** ，总会有一些方法 **在内存中构造危险对象** ，从而 **简化代码执行**
。考虑到这一点，我开始寻找一种简洁的新技术，可以在今天用于`Internet
Explorer`，轻松实现代码执行，而无需使用任何`ROP`或`shellcode`。
我决定采用的想法是 **颠覆调度机制** 。在对象上调用方法或属性时，调度机制打包脚本提供的参数，将它们转换为基于本机堆栈的参数，最后调用
实现所需方法或属性的 本机函数。因此，调度机制完成了从脚本到本机函数过程中所需的所有繁重工作。我们可以颠覆它以调用我们选择的本机代码吗？
事实上，更改调度的本机目标地址是很容易的部分。通常，在调度期间，可以通过在`vtable`中查找来找到目标函数。通过读写内存的能力，我们可以
**创建一个虚假的vtable**
，其中一些条目已被更改为指向我们选择的`本机API`。我认为这`WinExec`是一个可以最容易用于代码执行的API。通过将`vtable`条目更改为指向`WinExec`，我们实际上可以通过脚本调度来调用此API。
但是，该计划存在一个主要问题： **功能签名并不完全正确**
。每当通过`dispatch`调用一个函数时，第一个参数将是一个指向调用该方法的`COM`对象的指针（`this`参数）。这对我们来说是个坏消息，因为我们通常需要完全控制传递给目标`API`的
**第一个堆栈参数** 。当然，情况就是如此`WinExec`，其中第一个堆栈参数是指向要执行的命令字符串的指针。
我对这个问题的解决方案是正面的：我在内存中准备的`COM`对象需要同时是可用的，也是一个有效的`ANSI`命令字符串——一种内存中的多语言。这比听起来简单得多。考虑一下：当我们准备`WinExec`通过伪造的`vtable`调用时，我们不再需要`COM`对象处于运行状态。不会调用`COM`对象的任何方法，正是因为`WinExec`将执行代替对象的原始方法。因此，我们可以随意覆盖内存中`COM`对象的所有字段。我们必须小心保持`COM`对象的唯一部分是调度机制本身正常运行所需的那些字段。
我选择了`ActiveX`对象[`Scripting.Dictionary`](https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/dictionary-object)。我认为它是一个很好的选择，因为它简单，特别是由于它有一个相对简单的实现`IDispatch`。
尝试`Scripting.Dictionary`实例的内存布局会显示以下内容：
> 上图为 _Scripting.Dictionary的Dispatch-critical字段_
整个对象的大小为`0x40`字节，只有三个`DWORD`大小的字段对于调度机制至关重要。
第一个，以红色显示，是主要的`vtable`指针。我们将用 **指向伪造vtable的指针** 替换它，其中一个函数指针已被替换为`WinExec`。
第二个，以蓝色显示，是 **参考计数器** 。在调度调用的持续时间内，这将增加1。它的精确值并不重要。
最后一个字段以绿色显示，是一个指向小结构（大小为`0xc`）的指针，它似乎被称为`Pld`。采取有根据的猜测，我认为这代表`Per-LCID
Dispatch`。
总的来说，这表明我们处于相当不错的状态。我们可以用我们选择的几乎任何东西覆盖整个对象，除了第一个和最后一个字段，它们必须分别指向可用（伪造）`vtable`和完整的`pld`结构。回想一下，为了进行攻击，此`COM`对象的内存也必须是要传递给`WinExec`的有效`ANSI命令字符串`。
我们的第一个挑战是：在第一个字段中，我们如何编写一个同时是`vtable`指针的4字节值以及`ANSI命令字符串`的前四个字符？
我的解决方案是编写对象的前8个字节，如下所示：
看看我在那里做了什么？前四个字节可以作为指针值`0x28282828`读取，我们可以将伪造的`vtable`放在该位置。但是，当读作`ANSI字符`时，它们代表字符串`((((`。这是一个
**有效的Win32路径组件** 。之后，我们`\..\`使用路径遍历放置字符串以取消 **虚假路径** 组件`((((`。
请注意，磁盘上不需要存在名为`((((`的文件夹。我推荐读者阅读[James Forshaw
](https://twitter.com/tiraniddo)[撰写的这篇文章](https://googleprojectzero.blogspot.com/2016/02/the-definitive-guide-on-win32-to-nt.html)，以便对Windows中路径处理的细微处理进行出色的处理。
要清除的下一个障碍是 **引用计数**
，如上图的蓝色所示，但由于它确实是一个低位。我们放在那里的任何值都是可以接受的，只要我们记住`DWORD`将在调用之前递增`WinExec`。因此，我们将预先缩小的数据放在那里，以便将其增加到我们想要的值。我决定要运行一些`PowerShell`，因此我们到目前为止所做的是：
其中`.ewe`将递增，以便读取`.exe`（字节`0x77`是字符`w`，这是在上面所示的`DWORD`的低位字节`199e3fd4`）。
在此之后，我们开始放置PowerShell脚本。不幸的是，到现在为止我们的空间已经不多了。在我们达到第三个障碍（即`pld`指针）之前，只有`0x1c`可用字节。我们如何防止`pld`指针的出现破坏`PowerShell`脚本的文本？我通过打开`PowerShell
Comment`解决了这个问题：
之后，我们可以关闭`PowerShell`命令并编写所需的`PowerShell`脚本，而不受任何进一步的限制。那时我们将会在`Scripting.Dictionary`内存的末尾之后再写入一些值，但只要我们正确地准备堆，这就不会造成任何问题。
确实出现的一个问题是`pld`指针有时会包含一个字节，如`0x00`或`0x22`（双引号），这会过早地终止`PowerShell`命令。为了防止这种情况，我写了一些脚本来复制`pld`结构并在0x28281020的固定位置重写它。然后我将`0x28281020`作为`pld`指针放入`Scripting.Dictionary`。
在完成这个细节之后，当从一个最原始的进程开始时，该漏洞利用完全可靠。
# 惊喜奖金
我在`Windows 7`开发了这个漏洞利用，因为在`Windows 10`上不允许使用`VBScript`。不久之后，James Forshaw
发布了他发现同样允许`VBScript`在`Windows
10`上运行的[研究成果](https://bugs.chromium.org/p/project-zero/issues/detail?id=1738&can=1&q=CVE-2019-0768&colspec=ID Status Restrict
Reported Vendor Product Finder Summary)。这让我可以在`Windows
10`上为IE编写一个漏洞利用版本。微软已经修补了由[CVE-2019-0768](https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2019-0768)引发的漏洞，但我们仍然可以用它进行此演示。
在`Windows 10`上，代码执行前有一条最后的防线：[CFG](https://docs.microsoft.com/en-us/windows/desktop/secbp/control-flow-guard)。`CFG`会阻止试图`WinExec`从`vtable`
进行函数调用吗？很可惜它并没有，似乎微软认为不适合使用`CFG`来
**限制`WinExec`调用`GetProcAddress`以及一些用于开发的API**。我不会因为这个决定而对他们提出错误。一旦攻击者对进程的内存空间具有
**完全读/写访问权限** ，尝试锁定代码执行的所有可能途径就不值得冒险。
此处显示的是2019年2月补丁级别的`Windows 10 1809`上`Internet
Explorer`的完整漏洞。此`PoC`也可以在我们的[GitHub存储库中](https://github.com/thezdi/PoC/tree/master/ZDI-19-359)找到。从最初始的进程开始，它非常可靠。
**增强保护模式** 可以关闭或打开（但不是在具有64位渲染器进程的增强保护模式下）。启用增强保护模式后，生成的代码执行将受到`IE EPM
AppContainer`的约束。
# 结论
我感觉我们只是通过使用 **对地址空间的读/写访问** 来解决可能实现的问题。这种访问级别使得可以 **任意破坏数据结构**
，甚至可以预先手动创建内存中不存在的新对象实例。攻击者可以使用它来实现他们的目标，而 **无需执行任何单一的机器级指令** 。