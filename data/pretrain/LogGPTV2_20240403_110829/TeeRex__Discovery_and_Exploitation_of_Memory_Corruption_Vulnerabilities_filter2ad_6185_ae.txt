Thereafter, we place a fake TLSSession object such that the
last byte of the object is still part of enclave memory (i.e.,
the overlapping case). This construction bypasses the vali-
dation at  since the memory is not strictly outside enclave
memory. However, the important part—the address of the
vtable—is still stored in untrusted host memory. Hence, we
can fully control the target of an indirect jump and launch
a code-reuse attack. Our ﬁndings demonstrate that using a
memory-safe language like Rust does not automatically en-
sure memory-safe enclaves. That is, the entire software stack
must be guaranteed to be memory-safe.
The developers of the Rust SGX SDK acknowledged the
problem and promptly updated their code. Akin to our sugges-
tions to the developers, the enclave code now utilizes session
identiﬁers instead of pointers to identify TLS sessions; similar
to using ﬁle descriptors on Unix-like systems. Upon session
creation in tls_client_new, the pointer to the TLS session
object is now inserted into a hashmap, which is then used to
map the identiﬁer in subsequent ECALLs. Hence, no pointers
are passed on the host-to-enclave boundary. This drastically
reduces the attack surface of the enclave and eradicates both
the vulnerability pattern Returning pointers to enclave mem-
ory (P2) and Pointers to Overlapping Memory (P3).
sgx_is_outside_enclave(A, sz) == true
sgx_is_within_enclave(A, sz) == false
sgx_is_outside_enclave(B, sz) == false
sgx_is_within_enclave(B, sz) == true
sgx_is_outside_enclave(C, sz) == false
sgx_is_within_enclave(C, sz) == false
Figure 7: Possible buffer locations in SGX.
5.4 TaLoS
The open-source enclave TaLoS supports terminating TLS
inside of SGX enclaves within production webservers such as
the Apache webserver [24]. To achieve this, TaLoS introduces
SGX speciﬁc patches to the libressl TLS implementation. The
enclave exposes almost the entire TLS API of libressl over
the ECALL interface, which utilizes many pointers that are
marked as [user_check]. As such, this enclave contains the
vulnerability patterns Passing Data-Structures with Pointers
(P1) and Returning pointers to enclave memory (P2). How-
ever, the enclave does not simply return a raw pointer as it
is the case for the enclaves WolfSSL Example Enclave (Sec-
tion 5.2) and Rust SGX SDK’s tlsclient/server (Section 5.3).
Instead, it uses a shadowing mechanism that synchronizes se-
lected ﬁelds (e.g. of the primary SSL data structure) between
the trusted and untrusted world. This allows the host applica-
tion to access some ﬁelds of the data structure, while keeping
the actual copy in enclave memory [2]. This design choice
was taken to allow unmodiﬁed web servers to interact with the
SGX wrapped TLS API. In principle, the shadowing mecha-
nism is a legitimate pointer validation mechanism and allows
the enclave to verify pointers passed by the untrusted host
application. However, the exposed API is quite comprehen-
sive and TEEREX discovered an ECALL that uses a function
pointer in its data structure, where shadowing was missing.
This underlines the need for automated analysis tools, such as
TEEREX, to automatically identify missing pointer validation
code. Furthermore, we identiﬁed many potential sources for
vulnerabilities in the code that handled the shadowing mecha-
nism. The shadowing mechanism failed to take into account
that the NULL pointer is a valid pointer in the SGX context.
P4: NULL-Pointer Dereferences. The special NULL (or
nullptr) value is used in C/C++ code to signal that a pointer
is not referencing any object. However, it is represented by
the numeric value 0, but on x86 systems (using virtual mem-
ory) the address 0 is a valid address. Typically, there is no
valid memory mapped to address 0. Hence, any accidental
NULL pointer dereference results in a crash of the process
(SEGFAULT). However, a malicious host program or OS can
map valid data at the page at address 0. Thus, a NULL pointer
dereference turns into a valid load and a bogus value from
the page at address 0 is read instead of crashing the enclave.
USENIX Association
29th USENIX Security Symposium    851
Address SpaceABCCEnclave MemoryBIO* ecall_SSL_get_rbio(SSL *out_s) {
 // out_s is not checked, can be in enclave memory
/** Shadowing Mechanism **/
hashmap* m = get_ssl_hardening();
// returns NULL for invalid out_s
 SSL* in_s = hashmapGet(m, out_s);
// copy arbitrary enclave memory to the NULL page
 SSL_copy_fields_to_in_struct(in_s, out_s);
 /* [...] libressl logic */
// copy from the NULL page to arbitrary enclave memory
 SSL_copy_fields_to_out_struct(in_s, out_s); // [...]
Figure 8: Relevant parts of the EDL deﬁnition and C source
code of the TaLoS enclave.
This is similar to the kernel scenario, where the address 0 is
typically a valid address in the user space. As a mitigation,
many OS kernels disallow mapping any memory at address 0.
However, for NULL pointer dereferences inside of SGX en-
claves, there is currently no mitigation available, since the OS
is considered untrusted in the SGX threat model. As such, an
enclave must assume that the page at address 0 is mapped
into the address space.
Figure 8 shows the relevant code that contains a NULL-
pointer dereference. This snippet contains two mistakes: ﬁrst,
the pointer parameter out_s is supposed to point to the out-
side version of the TLS structure. However, the enclave does
not validate that the out_s actually points to outside enclave
memory (). As such, an attacker can simply pass some mem-
ory location inside of the enclave memory. The function call
at  retrieves the shadowed SSL object that is within enclave
memory. However, when passing a bogus pointer this function
will return a NULL-pointer to signal an error, which is not
checked by the enclave. The function call at  is the synchro-
nization function that copies selected ﬁelds from the outside
SSL structure to the inside structure. In case of an attack, the
out_s pointer does point to an arbitrary location inside of the
enclave, e.g., a secret key and in_s points to the NULL-page.
Thus, the enclave copies arbitrary data from enclave memory
to the NULL-page resulting in an arbitrary read exploit.
Furthermore, the same bugs shown in Figure 8 can also
be turned into an arbitrary write exploit primitive: for the
function call marked with , the enclave synchronizes back
the ﬁelds of the inside structure to the outside copy. In our
NULL-pointer dereference attack, the variable in_s points
to the NULL-page, while the variable out_s points to some
arbitrary enclave memory location. However, we have to over-
come a race condition challenge to also control the value
that is written. Recall that the enclave ﬁrst reads the value
from enclave memory and thereafter writes the value to the
NULL-page (). Hence, it would write back the same value
to enclave memory that was copied to the NULL-page. To
tackle the race condition, we execute a different thread in the
host application and change the contents of the NULL-page
while the code between the two synchronization functions ()
is executed. This effectively gives an attacker the arbitrary
write capability. Note that prior research has shown that it is
trivial to win race conditions in the SGX threat model. Since
the attacker is in full control of the OS and the scheduling of
the enclave’s thread, the attacker can even single-step through
the enclave code [64].
P5: Time-of-Check Time-of-Use. Enclaves run in an envi-
ronment where it is easy to introduce Time-of-Check Time-
of-Use (TOCTOU) bugs. While the enclave developer can
limit how many threads can concurrently enter an SGX en-
clave, the enclave developer has no control over the untrusted
and possibly malicious OS. When accessing host applica-
tion memory, the enclave must assume that a separate host
application thread can always change any content in the un-
trusted memory area. As a consequence, an enclave cannot
validate any data structures outside of the enclave memory.
In the TaLoS example, we utilized a race condition similar to
TOCTOU bugs to exploit the enclave.
5.5 Synaptics SynaTEE Driver
Synaptics recently started to utilize SGX enclaves to securely
process ﬁngerprint data on Windows in Lenovo laptops. The
closed-source ﬁngerprint driver contains a user space compo-
nent with an SGX enclave. TEEREX discovered a control-ﬂow
hijacking primitive that can be exploited due to a NULL-
pointer dereference (cf. TaLoS in Section 5.4). The enclave
utilizes a pointer in the global state, which is initialized as
a NULL pointer. Normally, this pointer would be initialized
to point to a data structure inside enclave memory, but the
attacker could potentially load the enclave and trigger the
NULL pointer dereference without initializing this pointer.
We chose not to exploit the NULL-pointer dereference
since the latest Windows versions strictly prohibit mapping
a page at address 0. That being said, the SGX threat model
assumes that the attacker has full control over the OS, i.e., an
attacker with OS privileges can disable this mitigation in the
Windows kernel. We demonstrated the feasibility of this in
the our PoC exploit for the Goodix enclave (see Section 5.6).
To avoid having to patch the Windows kernel and therefore
increase the portability of our PoC exploit, we Instead we
utilize a second ﬁnding of TEEREX: a limited write exploit
primitive due to an improperly sanitized pointer heavy data
structure that is passed to the enclave. This exploit primitive
allowed us to write a ﬁxed byte-value to an arbitrary address.
We used this in our PoC exploit to ﬁrst corrupt the pointer in
the global state of the enclave to make it point to a ﬁxed ad-
dress in untrusted host application memory. Next, we mapped
our exploit payload to this ﬁxed address thereby avoiding
allocation of a page at address 0.
We chained two exploit primitives in our PoC Exploit, both
discovered by TEEREX. The vulnerabilities we identiﬁed
are due to the code patterns Passing Data-Structures with
Pointers (P1) (cf. Intel GMP Example in Section 5.1) and
NULL-Pointer Dereferences (P4) (cf. TaLoS in Section 5.4).
852    29th USENIX Security Symposium
USENIX Association
5.6 Goodix Fingerprint Driver
The ﬁngerprint reader driver is shipped on recent Dell lap-
tops and uses SGX enclaves to process biometric data. The
black-box analysis of TEEREX discovered multiple limited
controllable write primitives to arbitrary addresses. For our ex-
ploit, we combined two of them to achieve a full control-ﬂow
hijack.
The ﬁrst primitive, denoted as C16, discovered by TEEREX
copies a 16 bit value loaded from a NULL-pointer (see Sec-
tion 5.4) to the address supplied in the ECALL argument by
an attacker. We patched the Windows kernel using a kernel
debugger and disabled the check that prevents Windows user
space applications to map the address 0, allowing us to exploit
the NULL-pointer dereference in the enclave. While the at-
tacker controls the value and the address in the ﬁrst primitive
C16, due to the limited size of the controlled value, this prim-
itive can only partially overwrite the instruction pointer. Al-
though this partial overwrite is often sufﬁcient [23], we com-
bine it with a second primitive also discovered by TEEREX
to achieve a full (64-bit) arbitrary write. The second primi-
tive, denoted as F64, is a limited write primitive that copies a
64 bit value loaded from a ﬁxed address A that is within se-
cure memory to an attacker-controlled pointer in the ECALL
argument. We execute primitive C16 four times to copy a full
64 bit value in 16 bit chunks to the address A, which is used in
primitive F64. This gives us control over the 64 bit value that
is written by F64. Subsequently, we can then use primitive F64
to overwrite, e.g., a return address in secure memory.
The analysis of this enclave demonstrates that the vulner-
ability report produced by TEEREX (cf. Section 4) provides
sufﬁcient information to easily create a PoC exploit for en-
claves where source code is not available. We only needed to
combine two primitives and for both TEEREX reported the
source and target addresses of the writes and the necessary
ECALL arguments.
5.7 Vulnerability Disclosure
We provided the developers of all the vulnerable enclaves a
detailed report explaining the problematic code patterns, a
working PoC exploit, and suggested ﬁxes. All of them con-
ﬁrmed our ﬁndings. We supported the enclave developers
by validating the patched versions with TEEREX. Table 1
shows the version number of the ﬁxed enclave code, as far as
they were available to us. As a response to our report, Intel
changed the code of the Intel GMP Example enclave to use
a serialization-based approach for parameters crossing the
host-to-enclave boundary. Since serialization avoids passing
raw object pointers at the host-to-enclave boundary, the vul-
nerabilities were successfully ﬁxed. The developers of both,
the WolfSSL Example Enclave and the Rust SGX SDK’s
tlsclient, followed our suggestions and stopped using point-
ers as resource references. Both enclaves now utilize integer
Figure 9: Runtime and memory usage of the benchmarked
enclaves.
identiﬁers to look up the respective TLS session objects in
a table inside of enclave memory. The original developer of
the TaLoS acknowledged our ﬁndings, but notiﬁed us that
he lacks the resources to develop ﬁxes. As such, this project
must now be considered a deprecated and abandoned research
project. Synaptics issued CVE-2019-18619 for the vulnera-
bilities we reported. Given the high sensitivity of biometric
data, they promptly developed a patch. A coordinated dis-
closure with OEM vendors and patch release is scheduled
for approximately Q3, 2020. The security team of Goodix
developed a patch that we successfully veriﬁed with TEEREX.
A release of the patched version is anticipated at the latest in
August, 2020. Currently, Goodix has not yet allocated a CVE
number.
6 Performance and Accuracy
In this section, we analyze the efﬁciency and effectiveness of
TEEREX. We focus our analysis on the three enclaves Intel
GMP Example, Rust SGX SDK’s tlsclient, and WolfSSL Ex-
ample Enclave since for these (1) the source code is available,
and (2) a patched version already exists. These insights allow
us to compare TEEREX’ behavior on the vulnerable and ﬁxed
enclaves and reason about the occurrences of false alarms.
6.1 Performance and Memory Usage
Our strategy is as follows: We analyze each ECALL using
TEEREX for a maximum of 20 min using one CPU core up
to a memory limit of 24 GB. The analysis was conducted on
an AMD EPYC Processor with 3.7 GHz and 100 GB RAM
allowing us to analyze up to 4 ECALLs in parallel. TEEREX
utilizes angr version 8.20.1.7 running on CPython 3.6.9 and
Ubuntu 18.04.4. All the exploitable primitives that we utilized
USENIX Association
29th USENIX Security Symposium    853
010203040506070Less than 10s runtimeOut of MemoryTimeoutFinishedwithinlimitsintel-fixedintel-vulnrust-fixedrust-vulnwolfssl-fixedwolfssl-vuln020040060080010001200Runtime (s)05101520Memory usage (GB)RuntimeMemory usagein our PoC exploits are discovered within our time window
of 20 min.
For the three enclaves (Intel GMP Example, Rust SGX
SDK’s tlsclient, and WolfSSL Example Enclave), we analyzed
the 73 ECALLs in detail. The results are depicted in Figure 9:
the average memory usage over all ECALLs of those enclaves
is 8.8 GB (σ = 9.8GB). The signiﬁcant deviation for memory
usage is mainly due to the highly variable size and complexity
of the ECALLs. Out of the analyzed ECALLs 40 % ﬁnished
within 10 s, 52 % ﬁnished within the given limits, and 48 %
exceeded the limits (23 % by time, also 23 % by memory, and
1 % by time and memory).
Our analysis in Section 5 demonstrates that using this analy-
sis strategy is sufﬁcient to successfully uncover problematic
code patterns. While symbolic execution is a powerful analy-
sis technique, it requires high computing resources (CPU time
and memory) to explore the state space of a program. Hence,
it is only natural that the analysis of some of the ECALLs
hits the resource limits we deﬁned for the benchmarking ex-