### 文本优化

**B. Olden Overheads**

技术手段如Oscar [7] 和Dhurjati及Adve [6] 提出的，通过为每次分配使用一个页表条目来强制执行释放后安全（use-after-free safety），在指针密集的工作负载中可能会导致更严重的成本增加。由于TLB压力，这些技术会导致性能显著下降。然而，在Olden [27] 的评估中（见图9），MarkUs却可以高效地执行，即使是在这种复杂的情况下也能保持良好表现。尽管Dhurjati和Adve面临高达11倍的开销，且Oscar也可能因采用类似策略而遭受类似的开销（但无从验证，因为没有可用的源代码），MarkUs的最大减速不超过1.4倍（平均1.1倍）。

**C. SPEC 2017 OpenMP Overheads**

图10显示了由于MarkUs作为并行、并发垃圾收集器和分配器[16]的一个扩展实现，因此对于多线程工作负载同样适用。将MarkUs应用于SPECspeed 2017与OpenMP时，仅造成13%的速度减慢。受影响的工作负载与它们在SPEC 2006中的对应部分相似：gcc因分配器而减速（而其他一些如lbm, xz, 和nab则因此加速），xalancbmk和omnetpp则因标记过程而减速。在较新的工作负载中，只有wrf和roms显著减速，前者是因为标记过程的影响，后者则是由于虚拟页面重用减少导致的元数据开销。不过，典型的开销非常低，与单线程SPEC 2006的结果一致。

**D. BBench Overheads**

图11(a)表明，对于复杂的、高度并行化的浏览器工作负载，其开销是相似的，平均而言，在Firefox中加载BBench [28] 所包含网页的性能开销仅为15%。由于BBench测量的是整个进程调用期间短暂的单个页面加载时间，因此我们确实观察到了一些变化，这是因为在多次加载同一页面的过程中，标记过程会在不同时间被触发。尽管如此，这种变化相对有限，最坏情况下也远低于2倍，并且一个更加成熟的实现可以通过更多地将任务卸载到其他线程以及采取更为增量式的收集策略来进一步限制这一问题。

鉴于可以在同一个Firefox进程中多次重复运行BBench，我们可以利用这一点来观察MarkUs在长时间执行情况下的表现。从图11(b)可以看出，尽管在重复运行BBench过程中页面渲染时间有很大差异，但在连续迭代之间并没有总体趋势——即第20次迭代中页面的加载情况与第一次迭代时相似。

**E. 内存-性能权衡**

由于我们知道自上次标记过程以来应用程序已释放了多少数据，正如第三节所讨论的那样，我们可以根据隔离列表的大小调整标记频率。这为我们提供了一个内存利用率与性能之间的权衡，我们在图12中对此进行了探讨。正如预期的那样，隔离列表的最大尺寸越大，平均内存消耗的增长就越高。dealII是一个例外，在这里大部分分配都是针对大对象进行的，这些对象可以在释放时立即解除映射，因此无论标记频率如何，都会观察到类似的内存开销。

在性能方面，dealII再次显示出平坦曲线，仅在非常小的隔离列表尺寸下略有增加，此时标记过程的频率开始影响执行。由于大多数分配都是针对大对象进行的，这些对象可以在释放时立即解除映射，因此隔离列表的大小增长缓慢，所有中间大小的隔离列表都表现出相同的性能，CPU开销相对稳定，不受设置的影响。Perlbench在极端设置下由MarkUs造成的减速适中，最大也只有1.5倍，并且随着隔离列表尺寸增大，开销变得可以忽略不计。同样地，Boehm-Demers-Weiser收集器并行运行的额外标记过程带来的CPU开销也是微不足道的，除非收集非常频繁。相比之下，Xalancbmk和omnetpp则代表了一种更明显的权衡关系，允许更高的内存消耗可以直接提高性能：较小的隔离列表尺寸会导致显著降低的性能，同时给其他核心带来显著负担。

**F. 优化对开销的影响**

MarkUs包括了一些旨在改进性能的功能，超越了基本的隔离列表与垃圾回收式标记过程相结合的方法，这些功能在第三节中有所描述。在图13中，我们展示了每项优化在性能、内存和CPU利用率开销方面的意义，并依次考虑了来自SPEC CPU2006 [24] 的四个分配密集型基准测试，这些基准测试是由Dang等人[7]确定的。我们看到，即使垃圾回收在C和C++中是安全的，其性能开销也是不可接受的：MarkUs带来的优化对于实际应用来说是必要的。

**未优化的情况**

对于SPEC CPU2006 [24] 中的分配密集型基准测试，基本收集器在性能和CPU利用率方面的开销过高，使得该技术变得不值得采用。例如，xalancbmk（见图13(b)）经历了超过30倍的减速，以及超过两倍的CPU利用率。这是因为Boehm-Demers-Weiser收集器在内存耗尽时会执行标记过程，即使没有任何分配可以释放，因为它没有足够的信息来做更好的判断。令人惊讶的是，内存开销也可能不利，perlbench（见图13(a)）和dealII（见图13(d)）分别遭受了2.5倍和7.5倍的增加，这是由于大量分配存在悬空指针导致的内存泄漏，以及频繁标记导致在分配密集区域花费大量时间，从而显著降低了性能。相比之下，具有许多小分配的基准测试xalancbmk和omnetpp，由于高频率的收集和小分配保守指针别名的可能性较低，因此内存开销很低。

**页面解除映射**

对于涉及大量内存分配的基准测试（dealII和perlbench），通过在大型分配释放后立即解除虚拟页面映射，情况得到了显著改善。这防止了任何显著的内存泄漏，因为那些最容易受到保守指针别名和悬空指针影响的大对象的物理内存成本被消除了。此外，由于分配器可以在标记过程之前使用新的虚拟地址重新映射未映射的页面，因此标记的开销大大减少了。然而，对于小于一页的小分配工作负载，标记过程仍然频繁，性能低下，特别是对于xalancbmk。

**标记频率优化**

当我们将标记过程延迟到程序员尝试释放足够多的数据之后再进行时，像xalancbmk和omnetpp这样的基准测试过于频繁的标记行为得到了大幅减少。这种额外的知识，对于垃圾收集器是不可用的，使我们能够将xalancbmk的开销从超过30倍降至1.7倍。由于我们故意以牺牲内存消耗来换取性能，我们可以预期平均内存利用率会上升，这对perlbench和omnetpp来说确实如此。尤其是这些工作负载不仅因为故意的权衡而遭受显著开销，还因为延迟标记过程导致在两次标记过程之间创建了许多每个大小的对象页面。这些页面被返回到单独大小的自由列表中，而不是主池中，从而造成了显著开销。然而，我们也看到了相反的情况，dealII在标记频率优化后的开销比没有优化时更低。这是因为我们可以使用隔离列表的大小来触发或阻止标记过程。因此，在程序耗尽已分配内存之前提前进行标记过程可以减少开销。

**所有四个分配密集型基准测试都通过将所有完全空闲的对象块返回到通用池中，从而提高了内存消耗。这样，标记过程之间生成的许多对象块的开销只是暂时的，而不是在整个程序执行过程中持续存在。对于某些程序，即使有频繁的标记过程，只要在每次新内存分配时触发，我们仍然可以在某些分配阶段使用对象块，而在其余时间浪费掉。**

**虽然小对象块扫描增加了标记过程结束时所需的计算量，但它通常对性能的影响较小，特别是xalancbmk可以看到减速。然而，dealII由于显著减少了内存消耗，从而减少了标记过程的数量并改善了数据局部性，因此性能有所提升。**

**G. 分配器开销**

并非我们样本实现的所有MarkUs开销都可以归因于标记过程。图14...（此处省略了原文档的剩余部分，因为它是截断的。如果有更多信息，请继续提供以便进一步优化。）

---

以上是对原文档内容的优化，使其更加清晰、连贯和专业。希望对你有所帮助！如果需要进一步修改或补充，请告诉我。