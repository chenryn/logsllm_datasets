to 264 instructions in an application.
Using the error log we can create a patched executable
with minimal instrumentation. The patched executable only
contains instrumentation for allocations sites and memory
accesses that appear in the error log. However, for some
memory access we still need to mask the upper 16 bits of
the pointer value; sometimes we do not know at compile
time whether the accessed pointer will contain meta data at
runtime.
Our approach does not only protect against a speciﬁc
attack, but against all attacks exploiting a speciﬁc vulnera-
bility. We call this approach vulnerability speciﬁc patching.
To patch multiple vulnerabilities multiple logs can be easily
merged by concatenating them.
VII. EVALUATION
Our evaluation focuses on the performance overhead of
Boundless and on its memory safety and availability. In
Section VII-A we compare the performance overhead of
Boundless (without automatic patching) with SoftBound.
Next, we show that Boundless can tolerate real world mem-
ory errors in Section VII-B. In Section VII-C we present per-
formance gains caused by our automatic patching approach.
We present our measurement of the availability of the HTTP
proxy squid in Section VII-D. Finally, we motivate our use
of FastPointer. We show that trading computational power
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:46:38 UTC from IEEE Xplore.  Restrictions apply. 
21(a) STAMP benchmark suite.
(b) Olden benchmark suite.
Figure 7.
SoftBound some values are missing because of false positives.
Performance slowdown of Boundless and SoftBound. For
WE USE 5 DIFFERENT APPLICATIONS CONTAINING MEMORY ERROR TO
Table I
EVALUATE BOUNDLESS.
Name
Bug
polymorph-0.4.0
global array and stack overﬂow
libpng-1.2.4
gzip-1.2.4
squid-2.3
ssca2
stack overﬂow
global array overﬂow
heap overﬂow
heap overﬂow
benchmarks suite [22]. Furthermore, we evaluate a known
bug in libpng [23]. The error in libpng propagates
through libpng and ﬁnally manifests in zlib. In order
to tolerate this error, we statically link zlib with libpng
and instrument both. Finally, ssca2 contains a previously
unknown bug which we found using our tool. With carefully
chosen arguments ssca2 underestimates the necessary size
of a heap object. The allocated object is too small for later
accesses. This bug has been conﬁrmed by the maintainers
of STAMP.
Boundless detects all errors and redirects all out-of-
bounds accesses into the out-of-bounds store. All exe-
cutions proceed normally. Subsequent runtime checks in
gzip, libpng, and polymorph detect an error condition
and terminate the application gracefully. Both, squid and
ssca2, continue operation, terminate normally, and return
the correct result.
Figure 8. Performance slowdown for the automatic patching process.
Figure 9. Tolerance of attacks to the squid web proxy. We inject an attack
each 1000 requests. The point in time we inject an attack is marked with
a vertical, dashed line.
C. Automatic Patching
For all 5 applications in Table I we automatically create
patches. We measure the runtime slowdown caused by the
patch relative to the uninstrumented version. We measure
gzip by compressing a 1 MB large text ﬁle. For libpng
we used pngtest and process a 5 MB large ﬁle. We
evaluate polymorph by operating on a directory containing
1000 ﬁles. All ﬁles names are uppercase and are renamed
by polymorph. We send 10.000 request sequentially to
a patched squid instance via a 100 Mbps network link.
Instead of using real HTTP traces, we use an artiﬁcial
benchmark: We request 13 different binary ﬁles in a round
robin manner. The ﬁles have the following sizes: 100 byte,
1kB, 5kB, 10kB, 15kB, 20kB, 25kB, 50kB, 75kB, 100kB,
150kB, 200kB, 250kB. The round robin approach ensures
that all pages are in the cache after the ﬁrst iteration. As a
result we do not add the latency of potential cache misses
to our measurement. Since every request, except the ﬁrst 13,
results in a cache hit, the measurement shows the worst case
slowdown one should expect. All ﬁles are fetched from a
locally running Apache server. Finally, we measured ssca2
using the documented, non-simulation workload. We present
the results in Figure 8. For comparison we also included the
runtime of the full tolerance relative to the uninstrumented
version. The runtime overhead of our automatically gener-
ated patches ranges from 0.0 (polymorph) to 0.32 (gzip).
The average runtime overhead is 14.2% which is 2.6% of
the runtime overhead caused by full tolerance.
D. Availability: Fail-stop vs. Tolerance
In Figure 9 we compare the throughput of an uninstru-
mented version of the squid server with a patched version.
We use the same request pattern as in the measurement
above. However, we insert an attack every 1000 requests.
During normal operation the patched version of squid
has a smaller throughput than the uninstrumented one. This
is caused by the runtime overhead of the patch. When
an attack hits the uninstrumented version of squid the
processing thread crashes. Squid spawns a new thread
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:46:38 UTC from IEEE Xplore.  Restrictions apply. 
bayesgenomeintruderkmeanslabyrinthssca2vacationyadamean0.01.02.03.04.05.06.0NormalizedExecutionTimebhbisortem3dhealthmstperimeterpowertreeaddtspmeanBoundlessSoftBoundgzippngtestpolymorphsquidssca20.01.02.03.04.05.06.07.08.09.010.0Normalized Execution Time4.798.836.513.284.221.321.221.01.111.06Full InstrumentationPatched00:00:5000:01:4000:02:3003:46:40Time[hh:mm:ss]010203040506070uninstrumentedpatchedThroughput[requestspersec]22Figure 10. The experienced slowdown decreases as a function of the last
level cache misses.
to substitute the crashed one. As a result the throughput
decreases at each attack.
During an attack the throughput of the patched version
decreases only slightly. This is caused by the fact that the
attack itself is within the FTP authentication process: squid
does not cache those requests. Attacks always result
in
a cache miss and thus the throughput naturally decrease.
After more than 3.75 hours both versions still have a stable
throughput. We terminated the measurement at this point in
time.
We also measured the behavior with an increased attack
frequency. Instead of sending an attack every 1000 requests,
we sent an attack every 500 requests. The uninstrumented
version of squid cannot handle this high frequency of
attacks: The main thread terminates deterministically during
the 6th attack. Thus, the whole application terminates and
the throughput drops to 0. Boundless is able to cope with
this high frequency of attacks and continues to operate until
we terminate the measurement again after about 3.75 hours.
In sum, Boundless dramatically increases the availability
of squid under high attack loads, e.g., denial-of-service
attacks.
E. Pointer Representation
We measured the ratio between last level cache misses
and unhalted core cycles using perfmon [24]. We used
this ratio to sort the STAMP benchmarks. Figure 10 plots
the runtime slowdown as a function of this ratio. We
plot the slowdown twice: Once for a version without our
compiler optimizations and once with all our compile time
optimizations enabled. The experienced slowdown declines
as a function of the last level cache misses.
An increasing frequency of last level cache misses trans-
lates to a higher load on the memory bus. It also means the
processor adds more bubbles into the pipeline. Boundless
can use these bubbles to perform some of the extra calcu-
lations caused by the different runtime pointer representa-
tions. Boundless trades computation for memory accesses.
It increases the computational load and minimizes the load
on the memory subsystem. As a result, Boundless performs
best for applications with high utilization of the memory
bus.
(a) Slowdown of SlowPointer only. (b) Average search depth in the meta
data store3.
Figure 11. Comparison of Boundless with a SlowPointer-only approach.
Since the memory gap is widening, the utilization of the
memory bus will increase. We believe Boundless will expe-
rience even smaller runtime overheads on future, upcoming
processors.
The FastPointer representation is crucial for the perfor-
mance of Boundless. Figure 11(a) compares the performance
overhead of Boundless with a SlowPointer only approach.
Except for ssca2 our combination of SlowPointer with
FastPointer performs dramatically better that a SlowPointer
only approach. Figure 11(b) demonstrates another positive
effect of FastPointers. When many pointers are represented
as FastPointer the SlowPointer meta data store is much less
ﬁlled as with a SlowPointer only approach.
Additionally, FastPointer decrease the probability for false
negatives with SlowPointer dramatically. With FastPointer
most buckets of the SlowPointer meta data store contain at
most on record. Hence, false negatives are very unlikely.
VIII. CONCLUSION
Boundless is a novel approach that increases the memory
safety and availability of applications with spatial memory
errors. Our measurements show that Boundless can dramati-
cally increase the availability of server applications with spa-
tial memory errors. We exploit spare bits on current x86 64
to track meta data directly in the pointer value. We use
two different pointer representations and we switch between
them at runtime. Boundless chooses the representation best
suited for the current needs dynamically. Boundless is safe,
complete, and has a competitive low overhead.
REFERENCES
[1] “2010 CWE/SANS top 25 most dangerous software
errors,” The MITRE Corporation, Mar. 2011.
[2] S. Nagarakatte,
J. Zhao, M. M. Martin,
and
S. Zdancewic, “SoftBound: Highly compatible and
complete spatial memory safety for C,” in Proceedings
of the 2009 ACM SIGPLAN conference on Program-
ming language design and implementation (PLDI’09).
New York, NY, USA: ACM, 2009.
3Average search depths smaller than 1 can appear when most accesses
to the meta data store are caused by deallocations of FastPointers that have
never been converted to SlowPointers (cf. Section IV-B).
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:46:38 UTC from IEEE Xplore.  Restrictions apply. 
0.00.0010.0020.0030.004NormalizedNumberofLastLevelCacheMisses0.02.04.06.08.010.012.0NormalizedExecutionTimealloptimizationsnooptimizationsssca2bayesgenomeintruderkmeanslabyrinthssca2vacationyada1101001000NormalizedExecutionTimeSlow-andFastPointerSlowPointeronly0110100AverageSearchDepth1101001000NormalizedExecutionTimeSlow-andFastPointerSlowPointeronly23and W. S. Beebee, “Enhancing server availability and
security through failure-oblivious computing,” in Pro-
ceedings of the 6th Symposium on Operating Systems
Design and Implementation (OSDI’04), 2004.
[16] M. Rinard, C. Cadar, D. Dumitran, D. M. Roy, and
T. Leu, “A dynamic technique for eliminating buffer
overﬂow vulnerabilities (and other memory errors),”
in Proceedings of the 2004 Annual Computer Security
Applications Conference, 2004.
[17] J. Newsome, D. Brumley, and D. Song, “Vulnerability-
speciﬁc execution ﬁltering for exploit prevention on
commodity software,” in Proceedings of the 13th Sym-
posium on Network and Distributed System Security
(NDSS’06), 2006.
[18] M. Costa, J. Crowcroft, M. Castro, A. Rowstron,
L. Zhou, L. Zhang, and P. Barham, “Vigilante: End-
to-end containment of internet worms,” in Proceedings
of the 20th ACM Symposium on Operating Systems
Principles (SOSP’05). New York, NY, USA: ACM,
2005.
[19] W. Weimer, “Patches as better bug reports,” in Pro-
ceedings of the 5th international conference on Gen-
erative Programming and Component Engineering
(GPCE’06). New York, NY, USA: ACM, 2006.
[20] C. Cao Minh, J. Chung, C. Kozyrakis, and K. Oluko-
tun, “STAMP: Stanford Transactional Applications for
Multi-Processing,” in Proceedings of
the IEEE In-
ternational Symposium on Workload Characterization
(IISWC’08), September 2008.
[21] M. C. Carlisle, “Olden: parallelizing programs with
dynamic data structures on distributed-memory ma-
chines,” Ph.D. dissertation, Princeton University,
Princeton, NJ, USA, June 1996.
[22] S. Lu, Z. Li, F. Qin, L. Tan, P. Zhou, and Y. Zhou,
“BugBench: Benchmarks for evaluating bug detection
tools,” in Workshop on the Evaluation of Software
Defect Detection Tools, 2005.
[23] C.
Evans,
overﬂow and
“libpng
buffer
http://scary.beasts.org/security/CESA-2004-001.txt,
2004.
other
code
1.2.5
stack-based
concerns,”
[24] S. Eranian, “The perfmon2 interface speciﬁcation,” HP
Laboratories, Tech. Rep., Feb. 2005.
[3] P. Akritidis, M. Costa, M. Castro, and S. Hand,
“Baggy Bounds Checking: An efﬁcient and backwards-
compatible defense against out-of-bounds errors,” in
Proceedings of the 18th USENIX Security Symposium,
Montreal, Canada, August 2009.
[4] C. Lattner and V. Adve, “LLVM: A compilation frame-
work for lifelong program analysis and transforma-
tion,” in Proceedings of the 2004 International Sympo-
sium on Code Generation and Optimization (CGO’04),
Palo Alto, California, Mar 2004.
[5] R. W. M. Jones and P. H. J. Kelly, “Backwards-
compatible bounds checking for arrays and pointers in
C programs,” in AADEBUG, 1997.
[6] ISO/IEC 9899-1999: Programming Languages—C,
International Organization for Standardization, Dec.
1999.
[7] AMD64 Architecture Programmer’s Manual Volume
2: System Programming, 3rd ed., Advanced Micro
Devices, September 2007.
[8] O. Ruwase and M. S. Lam, “A practical dynamic buffer
overﬂow detector,” in Proceedings of the 11th Network
and Distributed System Security Symposium, 2004.
[9] D. Dhurjati and V. Adve, “Backwards-compatible array
bounds checking for C with very low overhead,” in
Proceedings of the 28th international conference on
Software engineering (ICSE’06).
New York, NY,
USA: ACM, 2006.
[10] E. D. Berger and B. G. Zorn, “DieHard: probabilistic
memory safety for unsafe languages,” in Proceedings
of the 2006 ACM SIGPLAN conference on Program-
ming language design and implementation (PLDI’06).
New York, NY, USA: ACM, 2006.
[11] B. Salamat, T. Jackson, A. Gal, and M. Franz, “Or-
intrusion detection using parallel execution
chestra:
and monitoring of program variants in user-space,”
in Proceedings of the 4th ACM European Conference
on Computer systems (EuroSys’09). New York, NY,
USA: ACM, 2009.
[12] G. Novark, E. D. Berger, and B. G. Zorn, “Extermina-
tor: Automatically correcting memory errors with high
probability,” in Proceedings of the 2007 ACM SIG-
PLAN Conference on Programming Language Design
and Implementation (PLDI’07). New York, NY, USA:
ACM, 2007.
[13] F. Qin, J. Tucek, Y. Zhou, and J. Sundaresan, “Rx:
Treating bugs as allergies - a safe method to survive
software failures,” ACM Transactions on Computer
Systems, vol. 25, no. 3, 2007.
[14] Q. Gao, W. Zhang, Y. Tang, and F. Qin, “First-
Aid: surviving and preventing memory management
bugs during production runs,” in Proceedings of the
4th ACM European Conference on Computer Systems
(EuroSys’09). New York, NY, USA: ACM, 2009.
[15] M. Rinard, C. Cadar, D. Dumitran, D. M. Roy, T. Leu,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:46:38 UTC from IEEE Xplore.  Restrictions apply. 
24