Upon receiving a mobile SNMP agent, a hosting system
conﬁrms the agent has a resource skeleton and a simpliﬁed
usage certiﬁcate. Then the on-line checker is invoked to per-
form safety enforcement by taking advantage of the guaran-
tees of the off-line checker and by run-time monitoring.
At the static veriﬁcation stage, the on-line checker ﬁrst
validates the supplied resource skeleton and usage cer-
tiﬁcate, and detects any violation against safety policy
on resource utilization limits.
In the case of the scalar
agent, the on-line checker checks that all resource anno-
tations (=@B1...=,... =@B7 ... =) are correctly in-
serted and the loop bound for L4 is provided by the user
as well. Given the validity of the annotations, the on-line
checker calculates the actual resource bound with instan-
tiated policies on service calls.
In other words, the vari-
ables of tsnmp enable stderrlog, msnmp enable stderrlog,
tds set boolean, etc., are replaced with actual values in the
hosting system. The resource usage bound of the post-
condition (i.e., POS5) of main() code is checked against the
corresponding rule for a session of a mobile agent.
If no violation is found, the complete usage certiﬁcate is
restored from the certiﬁcate skeleton, and the proof checker
veriﬁes the supplied usage certiﬁcate against the speciﬁca-
tions within the PVS system. The proof checking procedure
is as simple as a validation run of PVS in batch mode and
automatically reruns all the proofs in the usage certiﬁcate.
An invalid usage certiﬁcate will generate errors which will
be caught by the proof checker by examining the run log
ﬁle.
The untrusted user-provided assertions, if any, on loop
bounds and function argument ranges are translated into
TINMAN has been implemented by a set of tools that
support resource bound prediction and certiﬁcate genera-
tion and validation. In this section, we shall present some
experimental results obtained by using our tools. We use the
example AgentX sub-agents (a.k.a mobile agents) provided
by the NET-SNMP packages as the benchmark programs.
They are typical mobile agents for SNMP management. A
summary of the programs’ properties is given in Table 1.
Program
scalar int
data set
delayed instance
notiﬁcation
#Services
#Tasks
6
20
26
14
6
6
23
7
Table 1. Program properties of tested mobile code
We have extended the security policies for mobile agent-
based NET-SNMP applications by deﬁning their resource
usage of SNMP APIs (library functions). There are eight
agent modules with more than two hundreds APIs, and even
more SNMP APIs other than agent modules that could be
used in mobile agent applications. Currently we only tested
all of the twenty-ﬁve NET-SNMP APIs that are called in
the benchmark. The code executes on a Intel Pentium III
running Debian Linux and were analyzed and monitored
with regard to their execution time and memory alloca-
tion. The benchmark agents were submitted for analysis to
the TINMAN tools which produced resource bound anno-
tations and a usage certiﬁcate for each agent, given the loop
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:29:18 UTC from IEEE Xplore.  Restrictions apply. 
Program
scalar int
data set
delayed instance
notiﬁcation
Source Code
Resource Skeleton
1818
3472
5340
2590
2154
4432
6979
3112
Increase
18.5%
27.6%
30.6%
20.1%
Full Certiﬁcate
Certiﬁcate Skeleton
4242
4244
13673
4946
319
321
1078
349
Decrease
92.5%
92.4%
92.1%
92.9%
Table 2. Size of Resource Skeleton and Certiﬁcate (in bytes)
Program
scalar int
data set
delayed instance
notiﬁcation
Speciﬁcation Generation
21.0ms
21.7ms
57.2ms
30.5ms
Off-line Certiﬁcate Construc-
tion + Validation
0.93s + 10.08s
1.28s + 10.05s
2.87s + 30.51s
1.31s + 11.25s
On-line
Veriﬁcation
Annotation
28ms
44ms
103ms
27ms
On-line
Check
Certiﬁcate
10.09s
10.11s
32.1s
11.54s
Table 3. Cost of off-line checker and on-line checker
bound in main() as 1000. The on-line checker validated
an agent by applying the extended policies on services and
agent sessions.
The purpose of the experiments is to demonstrate the ef-
fectiveness and performance of TINMAN system applied
to mobile SNMP agents. The summary of the experimental
results and our observations are given as follows:
(cid:15) Code size augmentation due to insertion of the anno-
tations and generation of usage certiﬁcates depends on
the control structure and the number of tasks of a pro-
gram. As shown in Table 2, the programs with resource
skeletons are between 18.5% and 30.6% larger than the
original ones. We also observed that the certiﬁcate size
is signiﬁcantly decreased by up to 92.9% by using a
certiﬁcate skeleton. The size of a certiﬁcate skeleton is
less than 13.7% of total size of the annotated program.
(cid:15) The certiﬁcates of all example programs are gener-
ated completely automatically. As shown in Table 3,
certiﬁcate validation (veriﬁcation of resource usage
bounds) is an order of magnitude slower than certiﬁ-
cate construction (conversion of resource skeleton to
PVS-friendly formal speciﬁcation). The overhead is
two-fold. First, a certiﬁcate consists of PVS rules that
are interpreted by the PVS prover interactively. Sec-
ond, the current proof strategy for loops and compound
choice tasks involves catch-all prover commands like
GRIND which is timing consuming. An interesting
ﬁnding is that these SNMP agents follow a common
programming style (program structures, a series of
SNMP APIs calls, actions to operation requests for
MIBs, etc.). So developing new proof strategies for
certain coding patterns will improve the (automatic)
proof generation and validation.
(cid:15) The overhead of running a mobile program with
annotations comes from run-time monitoring of
programmer-provided information and the communi-
cation between the annotated program and the on-line
checker during the execution. All of them have small
monitoring overheads.
5 Related Work
Some novel frameworks on integration of SNMP man-
agement with mobile agents have been proposed [17, 12,
14] by past authors. However, they did not provide resource
security at the application level to deter malicious mobile
agent from mounting DoS attacks. On the other hand, some
researchers have developed resource management systems
for mobile agents at the operating systems level [3].
In
Bellavista’s work [3], the resource usage of mobile agents
is monitored and controlled on-line. Certain security poli-
cies are enforced to restrict resource utilization of mobile
agent execution. This approach may incur signiﬁcant run-
time overhead which is an issue in resource-critical system
like SNMP network devices.
The SNMP management in active network environments
has attracted quite a bit of attention in recent years. Ex-
tant resource safety efforts for mobile agents usually fall
into two levels: at the programming language level and at
the run-time system level. For example, Smart Packets [15]
checks the CPU and memory usage of active packets writ-
ten in Sprocket and enforces the limits on the number of
instructions executed, amount of memory used, and access
to MIB variables. The KeyNote in PLANet has a simi-
lar mechanism [2, 6]. This usually comes at the price of
reduced expressiveness of the programming language (e.g.
Sprocket, PLAN) and may turn off programmers who are
unwilling to adopt a restrictive language just for their mo-
bile SNMP applications. In addition, not all these systems
provide resource utilization prediction and thus resource-
usage safety policies are difﬁcult to enforce at run-time.
Our certiﬁed-code approach is similar in spirit to the
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:29:18 UTC from IEEE Xplore.  Restrictions apply. 
Proof Carrying Code (PCC) [10] and Typed Assembly Lan-
guage (TAL) [9, 8]. In practice, PCC has been used to ver-
ify low-level safety properties, and it does not address the
resource bound security problems in terms of resource be-
havior prediction and program termination. Walker [16] has
developed an extension of TAL that derives the type system
from security automata which can specify and enforce ex-
pressive security policies. Unlike PCC and TAL, TINMAN
concentrates on resource security assurance at a higher level
to prevent DoS attacks by buggy or malicious codes with in-
ﬁnite loops or improper arguments to services calls. More
importantly, we provide full coverage by means of a com-
bination of off-line veriﬁcation and on-line monitoring. We
want the resource security policy to be ﬂexible and con-
ﬁgurable at the code recipient site. In addition, the proof
system constructed using the PVS system makes it easier
for proof construction and validation for more complicated
mobile applications.
6 Conclusions
In this paper, we explain how the TINMAN architec-
ture for securing resource safety is applied to mobile SNMP
agents. We demonstrate the effectiveness and efﬁciency of
the TINMAN suite of tools which provide complete cover-
age on enforcing resource usage bound limits of a mobile
SNMP agent. This is achieved by cooperation between the
programmer of mobile agent code and the hosting code re-
cipient. The division of labor is in such a way that the pro-
grammer can interactively provides certiﬁcates for resource
safety off-line and the code recipient can efﬁciently validate
the certiﬁcates against resource bound safety policy on-line.
TINMAN is a platform-independent architecture and
does not require modifying the underlying library and op-
erating system. It makes TINMAN applicable to a variety
of mobile SNMP agents frameworks by extending the ex-
isting policy rules for SNMP APIs. Moreover, our certiﬁed-
code approach of static checking a resource usage certiﬁcate
avoids much of performance overheads, a prime concern for
SNMP management in network nodes.
We recognize, however, that many mobile codes are
shipped in a “bytecode” format to the code recipient. With
more experience gained from applying the TINMAN archi-
tecture, we hope to be able to customize this framework for
some versions of byte-code for C and for Java.
References
[1] TINMAN project. www.cs.utexas.edu/wjyu/tinman/tutorial.
[2] D. S. Alexander, K. G. Anagnostakis, W. A. Arbaugh, A. D.
Keromytis, and J. M. Smith. The Price of Safety in an Active
Network. Technical Report MS-CIS-99-02, University of
Pennsylvania, January 1999.
[3] P. Bellavista, A. Corradi, and C. Stefanelli. How to monitor
and control resource usage in mobile agent systems.
In 3
rd IEEE Int. Symp. on Distributed Objects and Applications
(DOA’01), Italy, Sep 2001.
[4] S. Z. Guyer, D. A.
Jimnez,
Us-
ing C-Breeze.
Technical report, Department of Com-
puter Sciences, The University of Texas, January 2001.
http://www.cs.utexas.edu/users/lin/cbz/index.html.
and C. Lin.
[5] W. Hardaker. The net-snmp project. http://netsnmp. source-
forge.net.
[6] M. W. Hicks, P. Kakkar, J. T. Moore, C. A. Gunter, and
S. Nettles. PLAN: A packet language for active networks.
In International Conference on Functional Programming,
pages 86–93, 1998.
[7] J. Hooman. Correctness of real time systems by construc-
tion.
In FTRTFTS: Formal Techniques in Real-Time and
Fault-Tolerant Systems, pages 19–40. LNCS 863, Springer-
Verlag, 1994.
[8] G. Morrisett, K. Crary, N. Glew, D. Grossman, R. Samuels,
F. Smith, D. Walker, S. Weirich, and S. Zdancewic. TALx86:
A Realistic Typed Assembly Language.
In Second ACM
Workshop on Compiler Support for System Software, pages
25–35, Atlanta, GA, May 1999.
[9] G. Morrisett, D. Walker, K. Crary, and N. Glew. From Sys-
tem F to typed assembly language. In IEEE Symposium on
Principles of Programming Languages, January 1998.
[10] G. C. Necula. Proof-Carrying Code.
106–119, Paris, France, January 1997.
In POPL’97, pages
[11] S. Owre, J. Rushby, and N. Shankar. PVS: A prototype ver-
iﬁcation system. In 11th International Conference on Auto-
mated Deduction, pages 748–752. Lecture Notes in Artiﬁ-
cial Intelligence, Springer Verlag, 1992.
[12] B. Pagurek, Y. Wang, and T. White. Integration of mobile
agents with snmp: Why and how. In 2000 IEEE/IFIP Net-
work Operations and Management Symposium, pages 609–
622, Honolulu, Hawaii, USA, April 2000.
[13] C. Park and A. C. Shaw. Experiments with a program tim-
ing tool based on source-level timing schema. Computer,
25(5):48–57, May 1991.
[14] A. Puliaﬁto and O. Tomarchio. Using mobile agents to im-
plement ﬂexible network management strategies. Computer
Communication Journal, 23(8):708–719, April 2000.
[15] B. Schwartz, A. W. Jackson, W. T. Strayer, W. Zhou,
D. Rockwell, and C. Partridge. Smart Packets: Applying
Active Networks to Network Management. ACM Transac-
tions on Computer Systems, 18(1):67–88, 2000.
[16] D. Walker. A type system for expressive security policies.
In Symposium on Principles of Programming Languages,
pages 254–267, 2000.
[17] M. Zapf and K. Herrmann. Decentralized snmp manage-
ment with mobile agents. In IFIP/IEEE Conference on Inte-
grated Network Management, pages 623–635, Boston, May
1999.
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:29:18 UTC from IEEE Xplore.  Restrictions apply.