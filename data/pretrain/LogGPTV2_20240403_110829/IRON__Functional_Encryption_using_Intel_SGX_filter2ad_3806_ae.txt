observe how HW responds. We need to ensure that anything
ğ’œ observes in the real experiment can be simulated in the
ideal experiment.
(2) We use IND-CCA2 public key encryption to secure communi-
cation between enclaves that is intercepted by ğ’œ. ğ’® will need
to simulate this communication. Proving that ğ’œ cannot dis-
tinguish this involves a reduction to the IND-CCA2 security
game, showing that if ğ’œ can distinguish the real and sim-
ulated communication then it would break the IND-CCA2
security. The IND-CCA2 adversary will need to simulate
the entire FE system for ğ’œ without knowledge of the corre-
sponding secret keys for the public keys that the enclaves are
using to secure their communication. In particular, it must
see if ğ’œ tampers with messages in a way that would cause
the system to abort). This is what necessitates an extra layer
of authentication on the communication between enclaves
(3) The final challenge is that the adversary can also load modi-
fied programs of its choice into different enclaves and test
their behavior with honest or tampered inputs. This aspect
in particular makes the security proof challenging because
the FE simulator in the ideal world has to identify whether
honest attested programs are running inside the enclaves,
and produce simulated outputs only for those enclaves. This
gets tricky as there are three enclaves each with multiple
entry points.
7.1 Security proof
Theorem 7.1. If S is an EUF-CMA secure signature scheme, PKE
is an IND-CCA2 secure public key encryption scheme and HW is a
secure hardware scheme, then F E is a secure functional encryption
scheme according to Definition 5.2.
Proof. We will construct a simulator ğ’® for the FE security game
in Definition 5.2. ğ’® is given the length |msgâˆ—| and an oracle access
to Umsgâˆ— (Â·) (such that Umsgâˆ— (P ) = P (msgâˆ—)) after the adversary
provides its challenge message msgâˆ—. ğ’® can use this Umsgâˆ— oracle
on the programs queried by the adversary ğ’œ to FE.Keygen. ğ’® has to
simulate the pre-processing phase and a ciphertext corresponding
Session D1:  Functional Encryption and ObfuscationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA774to the challenge message msgâˆ— along with answering the adver-
saryâ€™s queries to the KeyGen, HW and the KM oracles.
Pre-processing phase: ğ’® simulates the pre-processing phase simi-
lar to the real world. ğ’® runs HW.Setup(1Î» ) and records (skquote,
skreport) generated during the process.ğ’® measures and stores tagDE.
ğ’® also creates empty lists ğ’¦,â„›,ğ’© , LK M , LDE , LDE2, LF E which
will be used later.
FE.Keygenâˆ— (msk, P ). When ğ’œ makes a query to the FE.Keygen
oracle, ğ’® responds the same way as in the real world except that ğ’®
now stores all the tagP corresponding to the Pâ€™s queried in a list ğ’¦.
FE.Encâˆ— (mpk, 1|msgâˆ—| ). ğ’® outputs ctâˆ— â† PKE.Enc(pk, 0|msgâˆ—| )
and stores ctâˆ— in the list â„›.
(cid:16)
(cid:16)
HW oracle. For ğ’œâ€™s queries to the algorithms of the HW oracle,
ğ’® runs the corresponding HW algorithms honestly and outputs
their results except for the following oracle calls.
â€¢ HW.Run(hdlK ME , â€œprovisionâ€, quote, params): When a provision
(cid:17)
query is made to KME, ğ’® parses quote =
mdhdl, tagQ , in, out,
and outputs âŠ¥ if out (cid:60) LDE2. Else, it honestly runs the HW
Ïƒ
algorithm and then replaces ctsk with PKE.Enc(pk, 0|skpke|
). ğ’®
also generates and replaces Ïƒsk for the modified ctsk. Finally, ğ’®
stores (sid, ctsk ) in LK M .
â€¢ HW.Load(params, Q ): When the load algorithm is run for a Q
corresponding to that of a DE, ğ’® runs the load algorithm honestly
and outputs hdlDE. In addition, it stores hdlDE in the list ğ’Ÿ.
When the load algorithm is run for a Q of the form QF E (P ),
ğ’® adds the output handle hdlP to the list ğ’¦ as follows. ğ’® first
checks if the tagP corresponding to this has an entry in ğ’¦, and if
it exists ğ’® appends hdlP to its handle list. Else, ğ’® adds the tuple
(0, tagP , hdlP ) to ğ’¦.
â€¢ HW.Run(hdlDE , â€œinit setupâ€, vksign): When an init setup query
is made to a hdlDE âˆˆ ğ’Ÿ, ğ’® checks if vksign matches with the one
in mpk. Else, it removes hdlDE from ğ’Ÿ. ğ’Ÿ will remain as the list
of handles for DEs with the correct vksign fed as input. Then, ğ’®
runs HW.Run honestly on the given input and outputs the result.
It also adds (sid, pkra) to the list LDE2.
â€¢ HW.Run(hdlDE , â€œcomplete setupâ€, sid, ctsk , Ïƒsk ): When a com-
plete setup query is made to a hdlDE âˆˆ ğ’Ÿ, ğ’® outputs âŠ¥ if (sid,
ctsk ) (cid:60) LK M . Else, it honestly executes HW.Run. Similar changes
are made for HW.Run&Report and HW.Run&Quote on this set
of inputs.
â€¢ HW.Run(hdlDE , â€œprovisionâ€, report, sig): When a provision query
(cid:17)
is made to a hdlDE âˆˆ ğ’Ÿ, ğ’® parses report =
mdhdl, tagQ , in, out,
and outputs âŠ¥ if out (cid:60) LF E. Else, it honestly executes
mac
HW.Run. At the end, ğ’® adds the output (sid, ctkey ) to LDE.
â€¢ HW.Run(hdlP , â€œinitâ€): When an init query is made to a hdlP âˆˆ ğ’¦
whose tuple in ğ’¦ has the honest bit set, ğ’® runs HW.Run&Report
honestly and outputs the result. It also adds (sid, pkla) to the list
LF E.
â€¢ HW.Run(hdlP , â€œrunâ€, reportsk , ctmsĞ´ ): When a run query is made
to hdlP âˆˆ ğ’¦ whose tuple in ğ’¦ has the honest bit set, ğ’® first parses
and outputs âŠ¥ if out (cid:60)
reportsk =
LDE. Else, it runs HW.Run on the given inputs. If the output is
âŠ¥, ğ’® outputs âŠ¥. Else, it parses out as (sid, ctkey ) and retrieves
mdhdl, tagQ , in, out, mac
(cid:16)
(cid:17)
skpke from msk. If ctmsĞ´ (cid:60) â„›, ğ’® computes x â† PKE.dec(skpke,
ctmsĞ´ ), runs P on x and outputs out := P (x ). If ctmsĞ´ âˆˆ â„›, ğ’®
queries its Umsgâˆ— oracle on P and outputs the response.
â€¢ For the HW.Run&Report and HW.Run&Quote queries, similar
changes are made as in the respective HW.Runs above. But,
report and quote are generated for unmodified tagâ€™s of the un-
modified programs descriptions. (This is to prevent the adversary
from being able to distinguish the change in hybrids just by
looking at the report or quote.)
KM oracle. For ğ’œâ€™s queries to the KM oracle with input quote,
ğ’® uses the provision queries to HW.Run for KME with the changes
mentioned above.
Now, for this polynomial time simulator ğ’® described above, we
(msg, Î± )real
will show that for experiments in Definition 5.2,
câ‰ˆ (msg, Î± )ideal
(1)
We prove this by showing that the view of the adversary ğ’œ in the
real world is computationally indistinguishable from its view in the
ideal world. It can be easily checked that the algorithms KeyGenâˆ—,
Encâˆ— and oracle KMâˆ— simulated by S correspond to the ideal world
specifications of Definition 5.2 (because the only information that ğ’®
obtains about msgâˆ— is through the Umsgâˆ— (Â·) oracle which it queries
on the FE.Keygen queries made by ğ’œ). We will prove through a
series of hybrids that ğ’œ cannot distinguish between the real and
the ideal world algorithms and oracles.
FE (1Î» ) is run.
Hybrid 0 Expreal
Hybrid 1 As in Hybrid 0, except that FE.Keygenâˆ— run by ğ’® is
used to generate secret keys instead of FE.Keygen. Also, the ctâˆ—
returned by FE.Enc for the encryption of the challenge message
msgâˆ— is stored in the list â„›. Also, when HW.Load(params, Q ) is
run for the Q of a DE, store the output in the list ğ’Ÿ, and when
HW.Run(hdlDE , â€œinit setupâ€, vksign) is run with a vksign different
from that in mpk, remove hdlDE from ğ’Ÿ. Also, when HW.Load is
run for a Q of the form QF E (P ), the output handle hdlP is added to
the list ğ’¦ in the tuple corresponding to tagP . If tagP does not have
an entry in ğ’¦, the entire tuple (0, tagP , hdlP ) is added to ğ’¦.
Here, FE.Keygenâˆ— and FE.Keygen are identical. And storing in
lists does not affect the view of ğ’œ. Hence, Hybrid 1 is indistinguish-
able from Hybrid 0.
Hybrid 2 As in Hybrid 1, except that when the HW.Run&Report
is queried with (hdlDE , (â€œprovision", report, sig)) for hdlDE âˆˆ ğ’Ÿ,
ğ’® outputs âŠ¥ if tagP that is part of report does not have an entry in
ğ’¦ with the honest bit set.
If sig is not a valid signature of tagP , then the S.Verify step
during the execution of HW.Run&Report(hdlDE ,Â·) would make
it output âŠ¥. Hence, Hybrid 2 differs from Hybrid 1 only when
a valid signature sig for tagP is part of the â€œprovisionâ€ query to
HW.Run&Report(hdlDE ,Â·) with a hdlDE that has the correct vksign
in its state and with a P that ğ’œ has not queried to FE.Keygenâˆ—. But,
if ğ’œ does make a query of this kind to HW.Run&Report with a
Session D1:  Functional Encryption and ObfuscationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA775valid sig, Lemma C.1 shows that this can be used to break the exis-
tential unforgeability of the signature scheme S.
Hybrid 3.0 As in Hybrid 2, except that ğ’® maintains a list LK M
of all the â€œprovisionâ€ query responses from KM i.e., the (sid, ctsk )
tuples. Then, on any call to HW.Run(hdlDE , â€œcomplete setupâ€, sid,
ctk , Ïƒk ) for hdlDE âˆˆ ğ’Ÿ, if (sid, ctsk ) (cid:60) LK M , ğ’® outputs âŠ¥.
The proof at a high level will be similar to the previous one.
HW.Run(hdlDE , â€œcomplete setupâ€,Â·) already outputsâŠ¥ in Hybrid 2
if Ïƒsk is not a valid signature of (sid, ctsk ) or if an entry for the
session ID sid is not in state. So, Hybrid 3.0 differs from Hybrid 2
only when ğ’œ can produce a valid signature Ïƒsk on a (sid, ctsk ) pair
for a sid which it has seen before in the communication between
KM and a DE whose handle is in ğ’Ÿ. This is proved in Lemma C.2.
Hybrid 3.1 As in Hybrid 3.0, except that ğ’® maintains a list LDE
of all the â€œprovisionâ€ query responses from hdlDE âˆˆ ğ’Ÿ i.e., the
(mdhdl, tagQDE , (report, sig), (sid, ctkey )) tuples. And, on call to
HW.Run(hdlP , reportsk , ctmsĞ´ ) with hdlP having an entry in ğ’¦
with its honest bit set, ğ’® outputs âŠ¥ if reportsk =
mdhdl, tagQ , in,
with tagQ = tagDE, sid having an entry in state
(sid, ctkey ), mac
and (sid, ctkey ) (cid:60) LDE.
(cid:17)
(cid:16)
(cid:16)
(cid:17)
Local attestation helps in proving the indistinguishability of the
hybrids. For honest hdlP s, HW.Run(hdlP , reportsk , ctmsĞ´ ) already
outputs âŠ¥ in Hybrid 3.0 if for reportsk =
mdhdl, tagDE , (report,
, mac is not a valid MAC on (mdhdl, tagDE ,
sig), (sid, ctkey ), mac
(report, sig), (sid, ctkey )), or if sid does not have an entry in state.
So, the only change in Hybrid 3.1 is that HW.Run also outputs
âŠ¥ if mac is a valid MAC but on a (sid, ctkey ) (cid:60) LDE. Hence, ğ’œ
can distinguish between the hybrids only when it produces a valid
mac on a tuple with (sid, ctsk ) not in LDE. But this happens with
negligible probability due to the security of local attestation.
Hybrid 4 As in Hybrid 3.1, except that when HW.Run is queried
with (hdlP , â€œrun", reportsk , ctmsĞ´ ) where reportsk is a valid MAC
of a tuple containing an entry in LDE and hdlP âˆˆ ğ’¦ with the
honest bit set. If ctmsĞ´ âˆˆ â„›, ğ’® uses the Umsgâˆ— oracle to answer
the HW.Run query. If ctmsĞ´ (cid:60) â„›, ğ’® uses the skpke from FE.Setup
to decrypt ctmsĞ´ instead of the one got by decrypting ctkey i.e.,
â€¢ On input (â€œrun", reportsk, ctmsĞ´ ):
(4) If ctmsĞ´ (cid:60) â„›, retrieve skpke from msk. Compute
x â† PKE.dec(skpke, ctmsĞ´ ). Run P on x and record
the output out := P (x ). Output out.
(5) If ctmsĞ´ âˆˆ â„›, query Umsgâˆ— (P ) and output the re-
sponse.
In Hybrid 3.1, the decryption of ctkey is used by ğ’® to decrypt
ctmsĞ´ while running HW.Run(hdlP ,Â·). This ctkey is a valid encryp-
tion of skpke because Hybrid 3.0 and Hybrid 3.1 ensure that the
encryption of skpke sent from KME to DE and then the one from DE
to FE both reach FE unmodified. Hence, the skpke got by decrypting
ctmsĞ´ is same as the one from msk. Thus, Hybrid 4 is indistin-
guishable from Hybrid 3.1 for any ctmsĞ´ (cid:60) â„›. Now, let us consider
the case of ctmsĞ´ âˆˆ â„›. ğ’® has the restriction that it can use the
Umsgâˆ— oracle only for a P for which tagP âˆˆ ğ’¦. From Hybrid 3.1, we
(cid:16)
(cid:17)
know that HW.Run(hdlP ,Â·) does not output âŠ¥ only when run with
a valid reportsk =
mdhdl, tagDE , (report, sig), (sid, ctkey ), mac
which is output by a DE â€œprovisionâ€ query. Hence, sig is a valid
signature of the tagP contained in report. Also, tagP âˆˆ ğ’¦ with
the honest bit set, as ensured in Hybrid 2. So, when a HW.Run
â€œrunâ€ query is made for hdlP , ğ’® is allowed use its Umsgâˆ— oracle to
output the FE.Dec result. Thus, Hybrid 4 is indistinguishable from
Hybrid 3.1 for any ctmsĞ´.
The following set of hybrids will help ğ’® replace an encryption
of skpke with an encryption of zeros. In order to prove the indistin-
guishability, we will argue that all the FE algorithms run indepen-
dent of the skpke encrypted in ctsk, and that ğ’œ does not get any
information about the value encrypted in ctsk.
Hybrid 5.0 As in Hybrid 4, except that ğ’® maintains a list LDE2 of
all (sid, pkra) that are part of quote = (mdhdl, tagDE , â€œinit setupâ€,
(sid, pkra), Ïƒ ) output by HW.Run&Quote(hdlDE , â€œinit setupâ€,Â·) for
hdlDE âˆˆ ğ’Ÿ. And now, when HW.Run(hdlK ME , â€œprovisionâ€, quote,
params) is called ğ’® outputs âŠ¥ when (sid, pkra) (cid:60) LDE2.
The Remote Attestation security ensures that ğ’œ can provide a
fake quote on a pkra not provided by DE only with negligible proba-
bility (Lemma C.4). Thus ensures that KME provides an encryption
of skpke only under a public key pkra generated inside QDE âˆˆ ğ’Ÿ
i.e., when HW.Run(hdlK ME , â€œ provisionâ€, quote, params) is called
with a valid quote output by a valid instance of DE.
Hybrid 5.1 As in Hybrid 5.0, except that ğ’® maintains a list LF E
of all (sid, pkla) that are part of report = (mdhdl, tagP , (â€œinitâ€, sid,
pkla), mac) output by HW.Run&Report(hdlP , â€œinitâ€,Â·) for hdlP âˆˆ
ğ’¦ with the honest bit set. And when HW.Run&Report(hdlDE ,
â€œprovisionâ€, report, sig) is called for a hdlDE âˆˆ ğ’Ÿ, ğ’® outputs âŠ¥
when report contains tagP âˆˆ ğ’¦ but (sid, pkla) (cid:60) LF E.
This is ensured by the Local Attestation security (Lemma C.5).
And, this shows that QDE only outputs skpke encrypted under some
pkla that was generated by a QF E (hdlP ,Â·) running a program P
that has been queried to FE.Keygen.
Hybrid 5.2 As in Hybrid 5.1, except that when the KM oracle
calls HW.Run(hdlK ME , (â€œprovision",Â·,Â·)), ğ’® replaces ctsk in the
output with PKE.Enc(0|skpke|
).
Lemma C.4 and Lemma C.5 ensure that skpke is encrypted only
under pkra and pkla generated by valid enclaves and ğ’œ has no ac-
cess to the corresponding secret keys. Now, Lemma C.6 will use
the IND-CCA2 security gameto argue that ğ’œ cannot distinguish
whether ctsk has an encryption of zeros or skpke under pkra of the
DE, and whether ctkey is an encryption of zeros or skpke under
pkla of a valid FE.
Hybrid 6 As in Hybrid 5.2, except that FE.Encâˆ— is used instead
of FE.Enc.
Session D1:  Functional Encryption and ObfuscationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA776We are now ready to use the IND-CCA2 security property of
PKE to replace ctmsĞ´ which was an encryption of msg) with an
encryption of zeros, as shown in Lemma C.7.
8 EXTENSIONS AND FUTURE WORK
Private Key MIFE. There is a private key variant of MIFE where
producing a valid ciphertext for the ith input to a function requires
a secret encryption key eki. Invoking the decryption algorithm on
inputs produced with an invalid key does not reveal any informa-