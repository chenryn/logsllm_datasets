somewhat straightforward. With around 200 lines of Java code
and some trial-and-error to determine that the apps were using
the Electronic Codebook (ECB) mode of AES, we conrm that the
contents can be decrypted using the suspected secret key. We have
veried this attack with a paid purchase of a recent issue in the My
MS-UK app, and free trial issues in the Business Money, Artists &
Illustrators, The MagPi and Popshot Magazine apps.
4.4 Raw Content on Internal Storage
Given that the ocial Android development training material claims
les stored on internal storage are “accessible by only your app” and
“neither the user nor other apps can access your le” [5], it is perhaps
unsurprising that some apps are making strong assumptions about
the condentiality guarantees provided by the internal storage.
Such assumptions, however, can be invalidated with AInS(R).
Content Extraction Aacks. For concrete examples, we again
look at the 70 group-3 apps discussed in Sections 3.2 and 3.3. In their
designs, each page of the publication is a JPEG image of about 0.7
megapixel. After downloading the content ZIP le of an authorized
issue, the app extracts from it the content images and have them
stored on the app’s internal storage. The app then acts like an image
viewer for displaying each page for the user to read. As the images
of each issue are left inside the internal storage without further
scrambling [CWE-313], an AInS(R) adversary can easily access and
make copies of the magazine issues, attacking (AS3).
Through the in-app free previews, we found that the 16 group-
8 apps also has each page of an issue saved as a JPEG image on
the internal storage. In fact, we found that even though the free
previews should allow only a small number of pages, all the other
pages of the selected issue are already downloaded. Consequently,
with AInS(R), one can easily bypass the preview limit and access
the saved pages directly.
4.5 Raw Encryption Key on Internal Storage
Similarly, developers might put encryption keys on the internal
storage assuming condentiality [CWE-313], however, in the face
of the AInS(R) capability, such a design manifests into an exploitable
weakness on (AS2).
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Key Extraction Aacks. We use the Counter Intelligence Plus
app (group-2) as an example, which is also made by Apazine. Inter-
estingly, despite being older than the other group-1 apps discussed
before, the Counter Intelligence Plus app appears to be doing a
slightly better job in terms of hiding the secret key used in content
encryption. In this case, instead of putting it on the “world-readable”
external storage, the key is stored on the device’s internal storage.
However, with the AInS(R) capability, we have managed a key ex-
traction attack similar to what is described in Section 4.3.
4.6 Direct Content Source on Internal Storage
Leaving direct links to contents that do not enforce authentica-
tion and authorization [CWE-452] on Internal Storage is another
exploitable weakness on (AS2).
Purchase Bypass Aacks. With the exception of the The Rebel
Media app, all the other 24 group-4–5 apps that oer articles (e.g.,
the Bloomberg Businessweek+ app) or video clips (e.g., the Outside
TV Features app), leave direct URLs to their corresponding contents
on the apps’ Internal Storage, organized by the dierent issues,
allowing an AInS(R) adversary to easily crawl for those and access
contents without paying.
4.7 Client-Side Authorization
The assumptions on internal storage indeed presents an interesting
attack vector. In addition to condentiality, one might also assume
that the internal storage provides strong integrity guarantees. Such
an assumption can be invalidated with AInS(R+W).
Purchase Bypass Aacks. Each of the 70 group-3 apps discussed
in Section 3.2 also keeps a local database of published and available
issues on the app’s internal storage. For each issue, the database
keeps a record about the name and date of the issue, a brief de-
scription, price, and some other metadata, including the purchase
status. With the AInS(R+W) capability, we have veried that one can
modify the database and replace the default value of the purchase
status column with some appropriate values [CWE-642] to trick
the app into granting access to magazine issues that were not paid
for.
This shows that the authorization of those apps is localized and
done unilaterally on the client’s device, and does not involve the
back-end content distribution server [CWE-603]. Consequently,
the robustness of such authorization mechanism hinges on the
assumption that the internal storage guarantees integrity [CWE-
654], which does not hold given an AInS(R+W) adversary.
4.8 Raw Encryption Key in Memory
Even if raw secret keys are not left in the clear on permanent stor-
ages, they might be loaded into the memory, which presents another
opportunity for attacking (AS4). As a concrete example, we look at
the Amazon Music app (version 6.5.3), which oers both streaming
and oine playback of music to its subscribers. There are two tiers
of subscription: Amazon Prime and Amazon Music Unlimited, with
the only dierence being the size of the collection accessible (2
million versus 40 million songs). Both tiers allow subscribers to
download music available from their corresponding collections for
oine playback. The downloaded songs are stored on the external
storage of the Android device.
242
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
S. Chau et al.
Storage Inspection. A quick inspection of the downloaded les
shows that regardless of the subscription tier, songs appear to be
encrypted and contain a human readable PlayReadyHeader XML
object in their metadata [37], suggesting that this entire streaming
service is using the Microsoft PlayReady DRM framework. With
the contents already available on the external storage, we choose
to focus on devising a key extraction attack.
We rst leverage the AInS(R) capability to inspect the internal
storage and see if one can attack (AS2). As there exists quite a few
secret key candidates (e.g., Base64 strings that decode into binary
values of various lengths), we soon run into the problem of not
knowing how to verify whether a key candidate is the right one for
content decryption.
Key Verication Oracle. Fortunately, the limited documentation
publicly available regarding the PlayReadyHeader [37] turns out to
be quite useful. The PlayReadyHeader metadata object contains the
key ID, content encryption algorithm (in this case AES CTR mode)
and the key length (16-byte), so we know what we are searching for.
Better yet, it also contains a checksum used by the framework to
protect against mismatched keys. According to the documentation,
this is meant to prevent the case where decryption is done with
an incorrect key, the subsequent output of which might damage
audio equipments during playback. Since the checksum is simply
the rst 8 bytes of encrypting the 16-byte key ID with the key in
AES ECB mode, which is easily computable, we now have an oracle
for verifying key extraction correctness, without having to rely on
decrypting the contents themselves.
A quick trial-and-error showed that none of our initial suspects
were the right content encryption key. The publicly available docu-
mentation regarding the PlayReady framework [36] suggests that
the content decryption keys are contained inside licenses. We then
turned our attention into nding the license instead. We realized
that there exists a .hds le, which according to some discussion
about Silverlight [1], seems to contain the licenses. Without doc-
umentations on how to parse and interpret this le, the format
of licenses, and whether this le is obfuscated or encrypted, key
extraction from it seems could be quite complicated.
Key Extraction Aacks. Instead, we switch our focus to attack
surface (AS4). The intuition is that, even if the local license store
on internal storage has complex protection mechanisms in place,
the content encryption key would still need to be read from the
license store and might be loaded into the memory in clear. Hence
we upgrade the adversary capability to AMem+BinIns, by using
the Frida 5 dynamic instrumentation framework. While we were
able to trace the app’s le read operations by hooking the read()
system calls with AMem+BinIns, including those that reads from the
license store, it remains unclear how to interpret the bytes being
read. Since tracing and interpreting the preparation phase seems
to be quite messy, we take a slightly dierent approach. With the
intuition that sensitive information (e.g., content encryption key),
if they were indeed loaded into the memory, might exhibit some
recognizable structure and would need to be released at some point
(e.g., after content playback), we try to hook deallocation functions
instead. While it might also work to hook the free() function calls,
a quick inspection of the native libraries used by the app shows
that they are exporting some functions that seem to be used for
deallocating sensitive information. Intercepting the entrance to
some of those functions, tracing appropriate pointers, and then
dumping a large enough portion of memory pointed by those, we
successfully extracted the content encryption key, which veries
against the oracle discussed earlier.
Unlike in previous work where PlayReady protected video con-
tents were reported to be partially encrypted [53], in this case we
have observed that the entire original content is encapsulated in
a so-called envelope le. Though we were unable to obtain docu-
mentations regarding the metadata (besides the PlayReadyHeader
object), based on some header les publicly available on Github
[35], we were able to guess and parse the metadata correctly. In the
end it took us about 260 lines of Java code to parse the envelope
le and decrypt with AES CTR using the extracted secret key to
get the raw audio tracks out.
One might also wonder why AMem alone is not strong enough.
We note that the key extraction problem has a two-dimensional
search space, spanning memory layout and time. While ultimately
it is the memory inspection that gets us the key, without binary
instrumentation, however, it is dicult to pinpoint the exact timing,
especially if the implementation tries to minimize key exposure by
actively releasing and overwriting memory regions containing the
secret key, a practice also recommended by previous work [27]. Not
knowing when to dump the memory would make it hard for AMem
to extract the key. Interestingly, in this app, we have observed a
behavior that sensitive information deallocation happens as early
as the actual music playback starts. Our speculation is that, since
the CTR mode generates keystream blocks by encrypting the next
counter values, after a long enough keystream has been generated
to allow decryption of the entire content, the app removes the
key from memory as soon as possible to minimize exposure time.
This is exactly why AMem+BinIns has an advantage in reducing
uncertainties along the time dimension.
We further found that the Audible app (version 2.25.0) is also
susceptible to this attack. Specically, members are oered premium
podcasts that can be downloaded for oine playback, in which case
they are encrypted in the same manner as songs in Amazon Music.
It appears that the PlayReady implementations in the 2 apps are
quite similar, as our key extraction attack also worked. Since the
downloaded Audible podcast tracks are partially encrypted isma
les, instead of using our decryption code for Amazon Music, we
used the Bento4 tookit 6 for successful decryption.
Key Scanning Heuristics. Curious readers might wonder how
we recognized the 16-byte key from memory dumps. As explained
in previous work, besides loading the raw secret key into mem-
ory, many cryptographic implementations speed up computation
by precomputing the key schedules made of the dierent round
keys [27]. This is because typical block ciphers, including AES, go
through multiple rounds of operations to encrypt/decrypt a block,
and each round involves a round key derived from the raw secret
key. Having to repeatedly expand the raw key into the same key
schedules for each block could be quite inecient. It turns out
that the key schedule observation also applies to this particular
PlayReady implementation. Using the keyfind program [27], we
5 https://www.frida.re
6 https://www.bento4.com/
243
Why Johnny Can’t Make Money With His Contents:
Pitfalls of Designing and Implementing Content Delivery Apps
were able to conrm the mathematical relation between the sus-
pected raw key and the derived round keys, strongly suggesting
that those bytes found in the memory dump indeed constitute a
key schedule.
One key to rule them all. Based on the handful of songs that
we sampled in our proof-of-concept experiments, Amazon Music
appears to be reusing content encryption keys across songs and
dierent accounts, despite the fact that the PlayReady framework
allows a much more granular key binding (e.g., per individual item),
as noted in a previous work [53]. We speculate that this is to lower
the load and management overhead on the back-end servers, though
we are not sure whether the entire ecosystem uses only one single
key, or are keys dierent across data centers in various locations.
Consequently, songs made available for oine playback from many
dierent albums across artists, regardless of which tier of subscrip-
tion and user accounts they came from, might all be decrypted with
the same key. This puts the whole collection of 40 million songs
available on Amazon Music in excessive risk.
While the attack we presented is agnostic to key granularity and
can be performed over and over again to exhaust all the possible
keys, however, a more ne-grained key binding (e.g. per album or
even per song) would have at least required more eort from an
attacker, and hinder automatic mass decryption of a large number
of songs. Sharing keys across many accounts does not seem to be
a good practice, as it is easy to have a single key leaked (e.g., by
an insider) and cause large damage to the ecosystem. Interestingly,
unlike Amazon Music, Audible seems to be much more granular
with its content encryption keys. It appears that for each podcast
track, a new key is used for encryption.
5 DISCUSSIONS
5.1 Responsible Disclosure and Aftermath
We have notied the content distributors of our ndings and pro-
vided them with sucient details to understand and reproduce the
attacks. In all cases, we have given the vendors more than 90 days
before this paper is made public.
In response to our initial report sent in Feb 2018 regarding bypass
attacks with AInS(R+W) (Section 4.7), developers at Maz Systems
implemented the use of encrypted database on newer versions of
some of the group-3 apps. This is a solution that we do not endorse,
as it does not change the client-only nature of the authorization
mechanism, so the pattern of [CWE-603] still holds. We followed up
with reports on group-4–6 apps in Jun 2018. They have expressed
gratitude to our eorts, and are working on app improvements.
We sent several reports to Apazine in Feb, Apr and Sep 2018
regarding weaknesses in their group-1–2 apps. They have replied
in Sep 2018 suggesting that the magazines are in public domain and
do not contain any sensitive or valuable information, so our implied
expectation of robustness is not relevant. We point out that if the
contents indeed have no market values then not using encryption
can improve user experience, and that some publications in print
(e.g., Business Money and My MS-UK) do not seem to be available
for free.
Developers at Pugpig have been notied in Jul 2018. They have
since acknowledged and conrmed our ndings, and replied that
they are aware of the weaknesses, and that the apps are designed
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
that way by choice to accommodate anonymous sharing of maga-
zine pages, a feature requested by their clients (publishers).
Amazon has been notied about the key extraction attack against
the Amazon Music app in Jan 2018. They responded to our report
with several new versions of their music app, implementing new
obfuscation strategies and oine playback restrictions on rooted
devices. However, despite our recommendation of considering the
secret key compromised and switching over to a new key, as of Jun
2018, we have noticed that recent new releases are still encrypted
using the same old key. The KEA against Audible was reported
to Amazon in Jun 2018, and new versions implementing various
obfuscation strategies have since been released.
5.2 Possible Countermeasures and Challenges
Bilateral Policy Enforcement. While a stateless sever allows for a
more simplistic deployment, as [CWE-603] has noted, a client-only
authorization is weak and can potentially be bypassed, especially on
an environment where execution/code can be reverse-engineered
and tampered with. Since local adversaries are not able to directly
tamper with the execution state of a remote server, considering
the threats of AInS(R+W) and AMem+BinIns, policy enforcement
can be done more robustly involving the back-end servers. For
example, to avoid the attacks discussed in Sections 3.2, 3.4 and 4.7.
the authorization logic should be shifted to the back-end server.
Then client-side modication of prices and purchase status would
result in detectable discrepancies with records on the server, and
the latter can refuse to serve contents in such cases.
Direct Content Sources. To hinder the attacks discussed in Sec-
tions 3.2, 4.1 and 4.6, content source URLs should not be left in a log
le [CWE-532] and also not on a storage that an adversary has un-
limited access to [CWE-921]. Instead of explicitly saving the URLs,
it would perhaps be better to have them constructed dynamically
during runtime, and the servers should request extra authentication
and authorization. An AMem+BinIns adversary might still be able
to gure out the URLs and the accompanying parameters, but it
would be an improvement comparing to the current deployments.
Certicate Pinning. To hinder the ANet(TLSInt) attacks discussed
in Sections 3.3 and 3.4, instead of trusting the system CA store,
the apps could adopt some forms of key/certicate pinning 7. Even
though AInS(R+W) and AMem+BinIns might still be used in tandem
to defeat pinning, it would at least make ANet(TLSInt) more dicult
to achieve than in the current implementations.
Denying services to rooted devices. One might propose for the
apps to stop providing services on rooted devices, as on unrooted
ones the adversary capabilities are greatly limited. This approach
however has its own challenges. First, while a concrete global num-
ber of rooted devices is not available, it has been suggested that the
number could be quite high in certain communities [6, 17]. Various
rooting tools have reported millions of downloads [14, 33], and
the superuser access management app has hundreds of millions of
installs [3]. A content distributor denying service on rooted devices
risks losing these customers. Second, determining whether a device
is “rooted” is an on-going arms race. Depending on the heuristics
7 https://www.owasp.org/index.php/Certicate_and_Public_Key_Pinning
244
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
S. Chau et al.
used and how the checks were implemented, binary instrumenta-
tion might be able to bypass those as well [44]. We have observed
that, as of version 7.5.4, the new Amazon Music restriction of no
oine playback on rooted devices can be bypassed with RootCloak
[34], a popular system modication module.
Google has since introduced the SafetyNet service for developers
to detect if a device has been tampered with. Android Pay, Netix,
and Pokemon Go are some examples that would deny service if
SafetyNet nds the devices is rooted. However, the cat-and-mouse
game between SafetyNet and the Magisk systemless rooting tech-
nique in 2017 has been well documented [45, 46], and there are
reports suggesting that on legacy Android versions various bypass
and attacks against SafetyNet are possible [15].
Anti-Debugging and Anti-Instrumentation. Another possibil-
ity is to implement anti-debugging and anti-instrumentation tech-
niques in the apps to hinder analysis, potentially on even rooted
systems. Depending on what heuristics are being used, some might
still be bypassable [41]. With the advancements of artifact detec-
tion [38], anti-instrumentation [23, 32], and transparent debugging
[19, 42], this line of defense appears to be an on-going cat-and-
mouse-game, similar to root detection.
Obfuscating keys in memory. While relying solely on obscurity
for security lacks robustness [CWE-656], however, in the case where
content encryption keys must be inevitably loaded into the memory,
one possibility is to make it harder for key scanning heuristics to
identify secret keys in memory dumps.
Various TEE implementations have been made available in recent
years, especially on mobile platforms, where it has been reported
Heuristics used in identifying memory regions of interests (e.g.,
those that contain content fragments and cryptographic keys) typi-
cally assume their targets to occupy a contiguous region of memory
[27, 53]. Additionally, they might also leverage the mathematical
relation between the raw secret key and its derived key schedules
to pinpoint the targets [27]. It remains to be seen whether obfus-
cations can be used to defeat these assumptions and make it more
dicult for an attacker to recover secret keys from the memory.
Watermarking. An orthogonal line of protection is to use water-
marking to make the origin of piracy traceable. Over the years, there
are techniques developed to watermark multimedia like audios [11]
and motion pictures [10], as well as textual contents [26, 52]. In
some cases, however, attackers can remove trivially detectable wa-
termarks. Resilience against detection and removal remains the
main objectives of watermarking research.
Another weakness of relying on watermarking for piracy track-
ing is that detection often relies on the content being leaked and
shared on the Internet, and it remains dicult to detect oine
sharing and contents that are stolen but not shared at all.
Trusted Execution Environments. A potential game changer is
the use of Trusted Execution Environments (TEEs), Since the tradi-
tional execution environment could potentially be under adversarial
control, TEE vendors typically leverage separation mechanisms en-
forced by the hardware platform to create an isolated execution
environment, the internal execution state of which not even the OS
can inspect, though depending on implementations, cryptographic
code running inside an isolated environment like Intel SGX might
still be susceptible to cache timing attacks [13, 25].
that there are multiple vendors oering various TEE solutions that
do not seem to conform to the same API standard [20], which might
have made it hard for developers to implement a one-size-ts-all
solution that is universally deployable across brands of devices,
potentially hindering adoption.
In the TEE trust model, the vendors would typically serve as the