elif key.type
elif key.type
elif key.type == List:
#根据键的类型对键进行重写
if key.is_expired(): continue
着忽略已过期的键
rewrite_sorted_set (key)
 rewrite_hash (key)
指定数据库号码
String:
= LRANGE (key, 0, -1)
Hash
第11章AOF持久化·145
---
## Page 150
146◆第二部分单机数据库的实现
所以新 AOF 文件不会浪费任何硬盘空间。
expires
redisDb
dict
id
因为 aof_rewrite 函数生成的新AOF 文件只包含还原当前数据库状态所必须的命令，
def rewrite_expire_time(key) :
def rewrite_sorted_set (key):
def rewrite_set (key);
timestamp = get_expire_time_in_unixstamp (key)
#获取毫秒精度的键过期时间戳
memberN)
f.write_command(zADD, key, scorel, memberl, score2, member2, ..., scoreN,
"WITHSCORES")
memberl,
#使用 SADD 命令重写集合键
#使用 SMEMBERS 命令获取集合键包含的所有元素
f.write_command (HMSET,
使用 PEXPIREAT 命令重写键的过期时间
使用 ZADD 命令重写有序集合键
使用ZRANGE命令获取有序集合键包含的所有元素
Stringobject
Stringobject
Stringobject
 Stringobject
Stringobject
"alphabet"
"alphabet"
valueN)
"book"
dict
"bookn
dict
scorel, member2, score2,
key;
1388556000000
1385877600000
"hello world"
Stringobject
Stringobject
 Stringobject
"publisher"
Stringobject
图11-3
 long long
long long
Hashobject
Stringobject
"author"
"aweu.
fieldl, valuel, field2, value2, ·.., fieldN,
一个数据库
memberN, scoreN = ZRANGE (key, O, -1,
...， elemN)
"Josiah L. Carlson"
"Redis in Action"
Listobject
 Stringobject
 Stringobject
 Stringobject
"
"c'
---
## Page 151
因为Redis 服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite
任务，但是，因为这个函数会进行大量的写人操作，所以调用这个函数的线程将被长时间阻塞，
11.3.2AOF后台重写
表键。
保存这个列表，并且每条命令设置的项数量也为64个：
集合，并且每条命令设置的元素数量也为64 个：
说，如果一个集合键包含了超过64个元素，那么重写程序会用多条 SADD 命令来记录这个
值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。
量，如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD 常量的
哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数
注意
命令：
上面介绍的 AOF 重写程序 aof_rewrite 函数可以很好地完成创建一个新 AOF 文件的
重写程序使用类似的方法处理包含多个元素的有序集合键，以及包含多个键值对的哈希
在目前版本中，REDIS_AOF_REWRITE_ITEMS_PER_CMD 常量的值为64，这也就是
在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、
例如，对于图11-3 所示的数据库，aof_rewrite 函数产生的新 AOF 文件将包含以下
RPUSH
RPUSH   
另一方面如果一个列表键包含了超过64 个项，那么重写程序会用多条 RPUSH命令来
SADD   
以上命令就是还原图11-3所示的数据库所必须的命令，它们没有一条是多余的。
EXPIREAT b00k 1388556000000
EXPIREAT alphabet 1385877600000
RPUSH alphabet "a" "b" "c"
SELECT 0
SADD 
SEr message "hello world"
"Josiah L. Carlson"
"Manning"
...
.，
第11章AOF持久化·147
---
## Page 152
148·第二部分单机数据库的实现
到AOF 重写缓冲区。
到AOF 缓冲区。
需要执行以下三个工作：
行 AOF 重写期间，服务器进程
个写命令发送给 AOF 缓冲区和 AOF 重写缓冲区，如图 11-4 所示。
在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个写命令之后，它会同时将这
个键。
新的 AOF 文件只保存了k1一个键的数据，而服务器数据库现在却有 k1、k2、k3、k4 四
了 k2、k3、k4 三个键，因此，重写后的AOF 文件和服务器当前的数据库状态并不一致，
有 k1一个键，但是当子进程完成AOF文件重写之后，服务器进程的数据库中已经新设置
服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致。
进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得
目的：
理请求，所以 Redis 决定将 AOF 重写程序放到子进程里执行，这样做可以同时达到两个
函数的话，那么在重写 AOF文件期间，服务期将无法处理客户端发来的命令请求。
3）将执行后的写命令追加
表 11-2展示了一个 AOF 文件重写例子，当子进程开始进行文件重写时，数据库中只
很明显，作为一种辅佐性的维护手段，Redis 不希望AOF 重写造成服务器无法处
这也就是说，在子进程执
2）将执行后的写命令追加
1）执行客户端发来的命令。
为了解决这种数据不一致问题，Redis 服务器设置了一个AOF 重写缓冲区，这个缓冲区
不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF 重写期间，服务器
口子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的
口子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。
情况下，保证数据的安全性。
址
3
u
L
时间
表11-2AOF文件重写时的服务器进程和子进程
执行命令 SET k422222
执行命令 SETk3 12345
执行命令 SET k2 10086
创建子进程，执行AOF文件重写
执行命令 SET k1v3
执行命令 SETk1v2
执行命令 SET k1v1
图11-4
服务器进程
客户端
服务器同时将命令发送给AOF文件和AOF重写缓冲区
发送命令
命令处理器
完成AOF文件重写
执行重写操作
执行重写操作
开始AOF文件重写
追加命令
追加命令
服务器
子进程
AOF重写缓冲区
AOF缓冲区
---
## Page 153
的影响降到了最低。
成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将 AOF 重写对服务器性能造成
个AOF文件的替换。
数据库状态将和服务器当前的数据库状态一致。
之后，会调用一个信号处理函数，并执行以下工作：
2）对新的 AOF文件进行改名，原子地（atomic）覆盖现有的 AOF 文件，完成新旧两
时间
1）将AOF 重写缓冲区中的所有内容写人到新AOF文件中，这时新AOF 文件所保存的
以上就是AOF后台重写，也即是 BGREWRITEAOF命令的实现原理。
T8
1
2
L
口在子进程向服务器进程发送信号之后，服务器进程会将保存在AOF重写缓冲区里面
口当子进程开始重写时，服务器进程（父进程）的数据库中只有k1一个键，当子进程
举个例子，表11-3展示了一个AOF文件后台重写的执行过程：
在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造
这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。
当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号
口从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。
口 AOF 缓冲区的内容会定期被写人和同步到AOF文件，对现有 AOF 文件的处理工作
这样一来可以保证：
完成AOF文件重写之后，服务器进程的数据库中已经多出了k2、k3、k4三个新键。
会如常进行。
替换旧 AOF文件，完成 AOF 文件后台重写操作。
记录的 k2、k3、k4 三个键的命令追加到新 AOF 文件的末尾，然后用新 AOF 文件
的末尾
用新 AOF 文件覆盖旧 AOF文件
接收到子进程发来的信号，将命令 SETk210086、
执行命令 SET k422222
执行命令SETk312345
执行命令 SET k210086
创建子进程，执行AOF文件重写
执行命令 SETk1v3
执行命令 SET k1v2
执行命令 SET k1 v1
服务器进程（父进程）
表11-3AOF文件后台重写过程
完成 AOF 文件重写，向父进程发送信号
执行重写操作
执行重写操作
开始 AOF 文件重写
子进程
第11章AOF持久化·149
---
## Page 154
150·第二部分单机数据库的实现
11.4
口 在执行BGREWRITEAOF 命令时，Redis 服务器会维护一个AOF 重写缓冲区，该缓
口 AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程
口 AOF重写可以产生一个新的 AOF文件，这个新的 AOF 文件和原有的 AOF 文件所
口服务器只要载人并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。
口 命令请求会先保存到 AOF 缓冲区里面，之后再定期写人并同步到 AOF 文件。
口AOF文件中的所有命令都以 Redis 命令请求协议的格式保存。
口AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
序无须对现有 AOF 文件进行任何读人、分析或者写人操作。
保存的数据库状态一样，但体积更小。
的 AOF 文件替换旧的AOF文件，以此来完成AOF文件重写操作。
文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新
成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF
冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完
有很大的影响。
重点回顾
---
## Page 155
同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。
字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他
理器(file event handler ）:
12.1
件事件和时间事件的。
们的实现方法，以及处理这些事件的API 等等。
Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处
本章最后将对服务器的事件调度方式进行介绍，说明 Redis 服务器是如何安排并执行文
虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接
口当被监听的套接字准备好执行连接应答（accept）、读取（read）、写人（write）、关
口文件事件处理器使用IO多路复用（multiplexing）程序来同时监听多个套接字，并
本章将对文件事件和时间事件进行介绍，说明这两种事件在 Redis 服务器中的应用，它
口文件事件（file event）：Redis 服务器通过套接字与客户端（或者其他 Redis 服务器）
Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
根据套接字目前执行的任务来为套接字关联不同的事件处理器。
要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。
会调用套接字之前关联好的事件处理器来处理这些事件。
闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就
文件事件
完成一系列网络通信操作。
他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来
进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其
事
第12章
---
## Page 156
152·第二部分单机数据库的实现
底层实现是可以互换的，如图 12-3 所示。
对应一个单独的文件，比如 ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。
和 kqueue 这些 I/O 多路复用函数库来实现的，每个 I/O 多路复用函数库在 Redis 源码中都
它们定义了某个事件发生时，服务器应该执行的动作。
型，调用相应的事件处理器。
程序才会继续向文件事件分派器传送下一个套接字，如图12-2所示。
生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），IO多路复用
（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产
生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步
12.1.2
现，但I/O多路复用程序总是会将所有产
套接字。
并向文件事件分派器传送那些产生了事件的
件有可能会并发地出现。
通常会连接多个套接字，
就会产生一个文件事件。
（accept）、写人、读取、关闭等操作时,
每当一个套接字准备好执行连接应答
事件处理器。
序、文件事件分派器（dispatcher），以及
12.1.1文件事件处理器的构成
因为 Redis 为每个 IO 多路复用函数库都实现了相同的 API，所以 IO 多路复用程序的
Redis 的 I/O 多路复用程序的所有功能都是通过包装常见的 select、epoll、evport
IO 多路复用程序负责监听多个套接字，
服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，
尽管多个文件事件可能会并发地出
文件事件是对套接字操作的抽象
Redis 在 I/O 多路复用程序的实现源码中用 #include 宏定义了相应的规则，程序会在
图12-1展示了文件事件处理器的四个组成部分，它们分别是套接字、I/O 多路复用程
文件事件分派器接收1VO 多路复用程序传来的套接字，
I/0 多路复用程序的实现
套接字SN
图12-2IO多路复用程序通过队列向文件事件分派器传送套接字
套接字sN-1