因为Shell是它的父进
 僵尸进程都立刻被
 这时的进程状态
，然后彻底清除掉
576
进
内
---
## Page 577
这两个函数的区别是：
若调用成功则返回清理掉的子进程id，若调用出错则返回-1。父进程调用wait或waitpid时可能会：
wait和waitpid函数的原型是：
如果一个父进程终止,
在./a.out命令后面加个&表示后台运行，
在后台运行这个程序，然后用ps命令查看:
了。思考一下，用什么办法可以清除掉僵尸进程？
僵尸进程是不能用kil1命令清除掉的，
子进程终止，init就会调用wait函数清理它。
是/sbin/init，进程id是1，
父进程的pid是6130，子进程是僵尸进程，pid是6131，ps命令显示僵尸进程的状态为z，在命令行
会进一步解释前台（Foreground）和后台（Backgroud）的概念。
u命令结束时Shell进程又重新回到前台。
一栏还显示。
·出错立即返回（如果它没有任何子进程）。
·带子进程的终止信息立即返回（如果一个子进程已终止，正等待父进程读取其终止信息）。
·阻塞（如果它的所有子进程都还在运行）。
则这些子进程的父进程改为init进程。init是系统中的一个特殊进程，
pid 
pid_t wait(int *status);
#include 
#include 
akaedu
akaedu
akaedu
COMMAND
a.out]
11
t
 waitpid(pid_t pid,
return 0;
/* child */ 
if(pid>0) { /* parent */ 
6163
 61310.0
6136 9:2 
6016
PID %CPU %MEM
而它的子进程还存在（这些子进程或者仍在运行，
while(l);
，在系统启动时负责启动各种系统服务，之后就负责清理子进程，只要有
 用户在终端的输入会被Shell读取，后台进程是读不到终端输入
0.0
0.0
 int *status, int options);
，因为ki11命令只是用来终止进程的，而僵尸进程已经终止
，Shel不等待这个进程终止就立刻打印提示符并等待用户输
2620
在第33章信号和第34章终端、作业控制与守护进程将
VSZ
 1000 pts/0
%/a 8e 
284
 RSS TTY
 0 pts/0
R+
STAT START
08:59
08:4
08:44
 或者已经是僵尸进程
通常程序文件 
0:00 ps u
14:33
00:0
0:00 bash
TIME
，等到ps
5
---
## Page 578
1、请读者修改例30.6“waitpid"的代码和实验条件，使它产生"Child terminated abnormally"的输
习题请点评
信号的编号。作为练习，请读者从头文件里查一下这些宏做了什么运算，
如果子进程是收到信号而异常终止的，WIFSIGNALED取出的字段值非零，
子进程的终止信息在一个int中包含了多个字段，
可见，
·wait等待第一个终止的子进程，
，如果只是为了同步而不关心子进程的终止信息，
，起到进程间同步的作用。如果参数status不是空指针，
如果父进程的所有子进程都还在运行，
在options参数中指定wNoHANG可以使父进程不阻塞而立即返回0。
例 30.6. waitpid
abnormally, signal %d\n",
int main(void)
#include
#include 
return 0;
} else
(pid 
int stat_val;
exit(3);
for
int
(o>
而waitpia可以通过pid参数指定等待哪一个子进程。
（i
(WIFSIGNALED(Stat_Val))
sleep(i);
printf(
3;i > 0; i--) 
，调用wait将使父进程阻塞，
val
WTERMSIG(stat_val));
用宏定义可以取出其中的每个字段：如果子进程
("This is the child\n");
，可以将status参数指定为NULL。
则子进程的终止信息通过这个参数传
，还可以使父进程阻塞等待子进程终
 0);
，WTERMSIG取出的字段值就是
而调用waitpid时如果
，是如何取出字段值的。
578
---
## Page 579
这个文件描述符。该标志默认为0，可以用fcnt1函数将它置1，本书不讨论该标志为1的情况。
2.环境变量
[37]事实上，
上一页
 在每个文件描述符中有一个close-on-exec标志，
全国嵌入式人才培训基地
起始页
上一级
 如果该标志为1，
则调用exec时关闭
4.进程间通信
579
下一页
---
## Page 580
开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。
调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，
4.1.管道请点评
程之间要交换数据必须通过内核,
4.进程间通信 请点评
冲区。pipe函数调用成功返回0，调用失败返回-1。
的文件，通过read(filedes[0]);或者write(filedes[1l);向这个文件读写数据其实是在读写内核缓
的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开
管道是一种最基本的IPC机制，由pipe函数创建:
（IPC，InterProcess Communication）。如下图所示。
冲区，
每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，
，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信
图30.7.管道
图 30.6.进程间通信
int pipe(int filedes[2]);
#include 
进程1
进程2
内核
 在内核中开辟一块缓冲区,
ffffffff
cO000000
00000000
全国嵌入式人才培训基地
第 30章进程
4.进程间通信
，进程1把数据从用户空间拷到内核缓
，它有一个读端一个写端，然后通
，filedes[1]指向管道
所以进
580
下一页
---
## Page 581
3
2.1
1.
读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。
父进程关闭管道读端，
父进程调用fork创建子进程，那幺子进程也有两个文件描述符指向同一管道。
父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。
例30.7.管道
3.父进程关闭fd[0]，子进程关闭fd[1]
2.父进程fork出子进程
1.父进程创健管道
fd[1]=4
fd[0]=3
fd[1]=4
fd[0]=3
fd[1]=4
fd[0]=3
int main(void)
#define MAXLINE 80
#include 
#include 
N
父进程
父进程
int n;
tty
tty
子进程关闭管道写端。父进程可以往管道里写，
读端
读端
管道
管道
管道
1
写端
写端
写端
fd[1]=4
fd[0]=3
fd[1]=4]
E=[0]p↓
2
N
二
子进程
子进程
子进程可以从管道里
→
---
## Page 582
使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置o_NONBLOck标志）：
使用管道有一些限制：
4.如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0）
3．如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0）
2．如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0）
·管道的读写端通过打开的文件描述符来传递,
·两个进程通过一个管道只能实现单向通信，
．如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0）
次write会阻塞，直到管道中有空位置了才写入数据并返回。
进程也没有从管道中读数据，
号会讲到怎样使SIGPIPE信号不终止进程。
取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。
进程也没有向管道中写数据，
末尾一样。
从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，
总之需要通过fork传递文件描述符使两个进程都能访问同一管道，
通信，也可以父进程fork两次，
那里继承管道文件描述符。
父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，
候也需要子进程写父进程读，就必须另开-
信？
return 0;
char line[MAXLINE];
pid_
int fd[2];
 else
(pid 
上面的例子是父进程把文件描述符传给子进程之后父子进程之间
u
close(fd[
wait (NULL)
write(
close(fd[
，这时有进程向管道写端写数据，
，这时有进程从管道读端读数据，那么管道中剩余的数据都被读
，把文件描述符传给两个子进程，
read(
(fdi
child */
一个管道。请读者思考，
比如上面的例子，
"hello world\n", 12);
 因此要通信的两个进程必须从它们的公共祖先
line, MAXLINE);
，那么在管道被写满时再
父进程写子进程读，
，然后两个子进程之间通信，
它们才能通信。
 为什么不能实现双向通
如果只开一个管道，
而持有管道读端的
 而持有管道写端的
 这时有进程向
，就像读到文件
，而仍然有进程
如果有时
582
但是
---
## Page 583
文件类型s表示socket，这些文件在磁盘上也没有数据块。UNIX Domain Socket是目前最广泛使用
要一个特殊的socket文件来标识内核中的通道，例如/var/run目录下有很多系统服务的socket文
4.2.其它IPC机制请点评
现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：
的IPC机制，到后面讲socket编程时再详细介绍。
和常规文件不一样）
FIFO文件在磁盘上没有数据块,
用mkfifo命令创建一个FIFO文件：
FIFO和UNIX Domain Socket这两种IPC机制都是利用文件系统中的特殊文件来标识的。可以
进程都可以访问它？文件系统中的路径名是全局的，各进程都可以访问，
进程间通信必须通过内核提供的通道，
2、请读者修改例 30.7“管道"的代码和实验条件，验证我上面所说的四种特殊情况。
1、在例30.7“管道"中，
习题请点评
特性。
承文件描述符，
·几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步
·子进程结束时，父进程调用wait可以得到子进程的终止信息
·父进程通过fork可以将打开文件的描述符传递给子进程
synaptic.socket
srw-rw-rw- 1 root
acpid.socket
srw-rw-rw- 1 root
prw-r--r-
S
 mkfifo hello
ls -l hello
实际上是在读写内核通道（根本原因在于这个file结构体所指向的read、write函数
，它们怎么通信呢？内核提供一条通道不成问题，
/var/run/
 这样就实现了进程间通信。UNIX Domain Socket和FIFO的原理类似，也需
 1 akaedu akaedu 0 2008-10-30 10:44 hello
，父进程只用到写端，因而把读端关闭，
，仅用来标识内核中的一条通道，各进程可以打开这个文件进
，而且必须有一种办法在进程中标识内核提供的某个通道，
root
root
root
root
0 2008-10-30 00:42
0 2008-10-30 00:24 sdp
0 2008-10-30 00:25 gdm_socket
0 2008-10-30 00:24
，问题是如何标识这条通道才能使各
，子进程只用到读端，
因此可以用文件系统中的
，因而把写端关
583
---
## Page 584
3.进程控制
·SYSVIPC，以前的SYSVUNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，
·mmap函数，几个进程可以映射同一内存区
·FIFO
·管道
·进程之间互发信号，一般使用sIGUSR1和sIGUSR2实现用户自定义功能
·UNIX Domain Socket，目前最广泛使用的IPC机制
现在已经基本废弃
全国嵌入式人才培训基地
起始页
上一级
5.练习：实现简单的Shell
---
## Page 585
表示零个或多个空格，表示一个或多个空格
2、识别和处理以下符号：
5.练习：实现简单的Shell点评
4.进程间通信
ocatoofile1o
ols △-I△-Ro>ofile1o
你的程序应该可以处理以下命令：
行完成后再次给出提示符。
1、给出提示符，让用户输入一行命令，识别程序名和参数并调用适当的exec函数执行程序，待执
用讲过的各种C函数实现一个简单的交互式Shell，要求:
上一页
·简单的标准输入输出重定向（）：仿照例30.5“wrapper"，
一页
待两个子进程终止。
准输入，
关闭读端,
，两个子进程分别调用exec执行程序，而Shell进程把管道的两端都关闭，调用wait等
，调用dup2把写端赋给标准输出，
5.练习：实现简单的Shell
全国嵌入式人才培训基地
全国嵌入式人才培训基地
第 30 章进程
起始页
上一级
，另一个子进程关闭写端，调用dup2把读端赋给标
，然后fork出两个子进程,
，先dup2然后exec。
第31章 Shell脚本
一个子进程
585
下一页
下一页
---
## Page 586
6. Shell脚本的调试方法
5.Shell脚本语法
4.bash启动脚本
3.Shell的基本语法
2.Shell如何执行命令
5.练习：实现简单的Shell
1. Shell的历史
第 31章 Shell脚本请点评
录
5.7.函数
5.6.位置参数和特殊变量
 5.2. if/then/elif/else/fi
5.1.条件测试：test[
4.4.以sh命令启动
4.3.非交互启动
4.2.以交互非登录Shell启动
4.1.作为交互登录Shell启动，或者使用--login参数启动
3.7. 双引号
3.6.单引号
3.5.转义字符\
3.4.算术代换：$(())
3.3.命令代换：或$()
3.1.变量
2.2.执行脚本
2.1.执行交互式命令
页
部分II. Linux系统编程
全国嵌入式人才培训基地