for the elliptic curve computation required for private set in-
tersection. Both libraries are open source with multiple years
of vetting. Here, we discuss the details behind our extension,
the design of our warning dialogues, and the telemetry the
extension collects.
Detecting login events: At present, Chrome does not export
an API for detecting login events. Instead, our extension reg-
isters a callback function to interpose on all webRequests
that contain form data. When triggered, the extension re-
lies on heuristics to detect whether the form contains a user-
name or password ﬁeld, such as matching on ﬁeld names like
password and passwd. If the heuristic fails to detect both
a username and password, nothing is sent to our API. We
manually tested our detection on the Alexa US Top 50: we
successfully captured login events for 40 pages and failed for
4, while the remaining 6 did not have login forms. For the
failures, login information was either obfuscated (e.g., a byte
blob of all ﬁeld data), or part of the payload body rather than
form data. We are thus cautious when discussing data from
our real world deployment in Section 6 that not every domain
will be covered by our technique.
Warning design: Our extension modiﬁes the DOM of the
page where a user entered their breached credential to show
a warning similar to Figure 2. In the browser tray, users can
reach an extension popup that displays a stateful warning
–similar to Figure 3. This gives users a way to see past warn-
ings, in the event that they closed their browser tab before re-
viewing the warning (or due to a DOM refresh that overwrites
our modiﬁcations). Additionally, this serves as a secure UI
element that runs in isolation of other extensions and pages.
Both styles of warning never reveal information about the
username or password found in a breach. This design deci-
sion limits the context we can provide users, but allows us to
avoid storing sensitive credential material that might make
persistent local storage a target for attacks.
In designing our warning, we followed emerging advice
about data breach notiﬁcations [20], proven terminology
around data breaches [1,28], and historical studies of browser
1562    28th USENIX Security Symposium
USENIX Association
Figure 2: In-page warning generated by our extension when
we detect that a credential is no longer secure due to a breach.
warnings related to phishing and unsafe network connec-
tions [2, 15]. In particular, we provided a clear action—
"Change your password"—along with context for the danger
behind the event. At the same time, we minimized unnec-
essary or overly technical information. We also provided a
“Learn More” link that explained in greater detail the root
cause of the warning and security best practices. In particular,
users should (1) reset their password for the affected page;
(2) reset their password wherever it was reused; (3) consider
a password manager; and (4) consider adopting two-factor
authentication. We collected feedback from 550 early testers
from our organization before settling on the ﬁnal design and
language of our dialogue.
Compared to other browser warnings where the safest ac-
tion is to close the tab, breached passwords require users to
follow a series of unguided, proactive next steps. We empha-
size unguided as there is no canonical account security page
for every site to simplify password resetting. While there are
industry initiatives to create common reset paths [41], these
have yet to materialize. As such, we consider a more formal
usability study of the warning experience—and automating
the password change process—as future work. We provide a
deeper treatment of the effectiveness of our warnings in terms
of successful password resets later in Section 6 (in short, a
quarter of warnings result in a reset during our observation
period).
Identifying user actions: By default, our extension contin-
uously triggers a warning each time the user authenticates
with a breached credential. Given the computation and net-
work overhead involved for each API query, if the extension
detects a breached credential, it caches a 12-byte preﬁx of
the Argon2 credential hash to avoid generating a new API
query for the same credential. This also reduces the latency
between a user entering a credential and observing a warning
on all subsequent logins to the same domain. Conversely, if a
credential was previously not present in a breach, we avoid
caching any verdict and perform a new API query on each
login. In the future, caching here is also possible if the cache
were invalidated upon the server announcing the arrival of a
new breach.
Figure 3: Stateful icon tray warning message to remind users
which accounts need their attention. This avoids the transient
nature of in-page warnings, which we use to provide better
context to users.
For low-value accounts that a user might deem unnecessary
to secure, we provide an option to ignore our warning on a
per-domain basis as shown in Figure 2 and Figure 3. The
extension manages this state by caching a local copy of the
domain involved and a 12-byte preﬁx of the Argon2 hash of
the credential that the user ignored (which is necessary in the
event the user has multiple accounts on the domain).
We detect when a user resets their exposed password in
order to provide a positive feedback signal to the user that
their account is no longer at risk. We also purge all cached in-
formation about the now stale credential. To do this, we cache
a 12-byte Argon2 preﬁx of an account’s username (with only
an 8MB memory requirement)—used only locally— along
with a 12-byte preﬁx of the Argon2 credential hash. If the
credential hash changes for the same username, this indicates
the user signed in with a new password and that all local state
for the credential should be reset. In the event a user merely
mistyped their breached password, correct password entry
will trigger a new warning and refresh the cache.
Telemetry: We instrument our extension to report anony-
mous telemetry pertaining to the volume of lookups against
our API that result in a breach warning, along with whether
users ignore our warnings or reset their passwords. All of
these events lack any form of user identiﬁer, precluding the
possibility of correlating events or understanding per-user
experiences. Each event also includes the domain of the login
page involved, which we use to estimate our compatibility
with popular sites and to estimate the prevalence of breached
passwords across the Internet. For password changes related
to breached credentials, we also report the strength of the old
and new password to understand whether users as a whole mi-
grate to stronger passwords. We use zxcvbn [57] for strength
USENIX Association
28th USENIX Security Symposium    1563
Ignore for this siteCloseLearn moreYou should change your password now.Password Checkup detected that your password for github.com is no longer safe due to a data breach.Change your passwordPassword CheckupPassword Checkup Extension detected that the following 1 account has a password that is no longer safe due to a data breach.You should change your password now.Learn moreIgnoregithub.comAdvanced settingsestimation as it is entirely client-side and open source. This
telemetry forms the basis of our analysis of the impact of pass-
word breach warnings in the wild, discussed in Section 6. We
disclose the data we collect upfront to users in the description
of our Chrome Webstore listing.6 We had all of our teleme-
try reviewed by a group of internal experts and followed our
organization’s ethics review process.
4.2 Storage
We partitioned our pre-computed, blinded and hashed cre-
dential corpus (totaling roughly 110GB) into 216 slices. We
stored each slice as a static ﬁle in Google Cloud Storage. We
restricted access to these ﬁles so that only the server handling
requests could fetch content from storage. We also stored the
key material necessary to re-blind client-blinded hashes in the
same storage system.
4.3 Server
The stateless nature of our credential breach protocol allowed
us to implement our serving using Google Cloud Functions.
The primary beneﬁt of this approach is that we could scale
arbitrarily to the volume of incoming requests while also
avoiding dormant compute cycles on pre-requisitioned cloud
instances. This design also allowed us to avoid having to
reason about the side-effects across requests. We implemented
our Cloud Function using the same JavaScript elliptic curve
library as our Chrome extension (recall that hashing is not
part of the server protocol). We avoid application-layer denial
of service attacks—such as sending an arbitrary length string
for the server to blind—by blocking malformed requests that
do not adhere to the ﬁxed-length blinded hash we expect from
a client.
5 Deployment
We made our extension publicly available via the Chrome
Web Store and announced it through major media channels.
In total, 667,716 users installed our extension over a measure-
ment period of February 5, 2019–March 4, 2019 (UTC).
User demographics: Based on aggregate statistics provided
by the Chrome Web Store, 48% of the users who installed our
extension were from North America, 29% from Europe, 17%
from Asia, and the remaining 6% from around the world. In
terms of operating systems, 71% of users who installed the
extension used Windows, 14% used MacOS, 13% ChromeOS,
and 2% Linux. We note that extensions are unavailable on
mobile devices and thus are not present in our device break-
down.
6 https://chrome.google.com/webstore/detail/password-
checkup/pncabnpcffmalkkjpajodfhijclecjno
Figure 4: Volume of logins scanned by our extension every
100 seconds. Requests to our API scaled from 0.11 queries
per 100 seconds in early testing, to a peak of 2,192 queries
per 100 seconds at the end of our measurement window. The
dips in the graph reﬂect lower activity during weekends.
Scaling to requests: Over the course of our measurement
window, the lookup volume to our API scaled gracefully from
0.11 lookups per 100 seconds during early testing to a peak
of 2,043 lookups per 100 seconds as shown in Figure 4. The
diurnal pattern present reﬂects the geographic concentration
of users in North America and Europe. The periodic dips
reﬂect lower login activity over the weekend. By compar-
ing query volume with active user metrics provided by the
Chrome Web store, we estimate that an average user generates
3 API requests (e.g., logins) per weekday, and 1.5 requests per
weekend. Critically, the diurnal cadence and lack of bursty
behavior indicates a lack of large-scale abuse during our mea-
surement window which might otherwise pollute our analysis
later in Section 6.
Client overhead: We present a breakdown of the computa-
tional overhead and network latency incurred by clients that
query our API in Table 2. Overall, a median query took 8.5
seconds to return a verdict, during which a user would con-
tinue browsing uninterrupted. Roughly half of this time was
spent strongly hashing the user’s credential, while the remain-
ing time was spent downloading potential credential matches.
Our username hash (used for locally caching state) took a
median of 100ms and was a negligible part of this delay. For
10% of users, the overall query time exceeded 18 seconds,
half of which was spent in network latency. While part of
this lookup overhead can be optimized—credential hashing in
native code takes an average of 0.7 seconds—the only way to
reduce network latency would be to download fewer breached
records, thus reducing the k-anonymity set of our protocol.
As such, our current privacy constraints likely remain out of
reach for resource-constrained devices, at least for near real
time detection.
1564    28th USENIX Security Symposium
USENIX Association
Duration
Argon2 username hash
Argon2 credential hash
End-to-end API query
Median
0.1s
4.4s
8.5s
90% 95%
0.3s
0.3s
12.7s
9.8s
18.8s
26.9s
Table 2: Time spent performing API operations including
hashing and downloading potentially matching breached cre-
dentials.
Metric
Extension users
Logins analyzed
Domains covered
Breached credentials found
Warnings ignored
Passwords reset
Value
667,716
21,177,237
746,853
316,531
81,368 (26%)
82,761 (26%)
Cost modeling: A practical reality of running a breach de-
tection service is cost. In our case, cost is intrinsically tied
to the k-anonymity privacy that we provide. Every 1,000
invocations of our API costs approximately $0.19 at the cur-
rent volume of credentials in our storage and for a 2-byte
k-anonymity preﬁx. Data serving makes up 94% of this cost,
while the CPU and memory necessary to ﬁeld requests and
to re-encrypt client credentials makes up only 5%. Based on
our query volume per user, operating our service for an esti-
mated 500,000 users would cost $85,500 a year. Caching the
status of negative breach verdicts would substantially reduce
expenses. Our goal in documenting these details is to provide
other members of the community a benchmark for the costs
of any improved privacy scheme. For our protocol, adding a
single bit of privacy nearly doubles our operating expenses
while also doubling the network latency for clients.
6 Analysis
We analyzed the anonymous telemetry reported during our
measurement window to understand the state of breached
passwords across the Internet. Facets we consider include
the frequency that users log in with a breached password, the
types of sites where reuse is most common, and ultimately
whether displaying warnings helps users to address the risk
of credential stufﬁng. We provide a high-level statistical sum-
mary of our telemetry in Table 3 . We note that our telemetry
is biased towards the users who installed our extension, which
is a non-random sample of the Internet population.
6.1 Credential stufﬁng risk and remediation
Frequency of breached credential reuse: Overall, our API
ﬁelded 21,177,237 lookup requests, where a lookup maps to
a single login attempt performed by an anonymous user. We
detected that 316,531 logins involved breached credentials—
roughly 1.5% of all logins. We caution this is a lower bound
as we only generate telemetry for breached credentials once
before caching the result locally, whereas lookups to non-
breached credentials generate telemetry upon each new login.
Our detection rate is lower than the 6.9% reported by Thomas
et al. [51] for 751 million Google accounts and 1.9 billion
breached credentials. Possible reasons include the user popu-
Table 3: Summary of the anonymous telemetry data reported
over the course of our analysis window from February 5–
March 4, 2019.
lation that adopted our extension is more security conscious—
thus avoiding reuse as a behavior—or that dormant accounts
have a higher reuse rate, which by nature our extension can-
not observe as we perform checks at login time. During our
28 day measurement window, if we assume that logins and
warnings are uniformly distributed across users, 47.3% of our
users received a warning. Our anonymous reporting precludes
more detailed per-user statistics. Taken as a whole, our results
reveal that global Internet users regularly access accounts that
are vulnerable to credential stufﬁng.
Ignoring breached credentials: Users opted to ignore
81,368—or 25.7%—of the breach warnings we surfaced. We
consider three possible explanations. Users may be making an
explicit risk assessment that the value of their account is not
worth the effort of adopting a new password. Alternatively,
users may not be in full control of the account (e.g., a shared
household account) [37]. Finally, as our extension does not
automate the process of password resetting, users may ig-
nore our warning out of frustration due to a lack of guidance.
Regardless of the underlying cause, ignored warnings leave
accounts vulnerable to credential stufﬁng. That said, there is
an opportunity here for identity providers to take action and
guide users through the password resetting process.
Remediation of breached passwords: Our warnings re-
sulted in users resetting 82,761—or 26.1%—of their breached
passwords. Critically, we ﬁnd that users used this opportunity
to migrate to stronger passwords. On average, the passwords
we detected as breached had a zxcvbn strength of 1.6. After
remediation, this score increased to an average of 2.9. We
present a more detailed summary of strength before and after
resetting in Figure 5. For context, a score of one indicates
a “weak password” that an attacker can guess in under 106
attempts. A score of two reﬂects a password that an attacker
can guess in under 108 attempts, and a score of three 1010
attempts and is considered “strong”.
Overall, 94% of password changes led to a stronger or
equal zxcvbn score, while just 6% of changes resulted in a
regression to a weaker password. Our results indicate that
users of our extension understand stronger password compo-