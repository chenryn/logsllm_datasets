if T = ∅ then return ∅
return node(PublicKeys(L), PublicKeys(R)), gk
13: function Copath(T, i) // where i is the index of the leaf and
if i  0).
Test(u, i, t) Given (u, i, t), let k0 denote the key computed by user u at stage t of
session (u, i), and let k1 denote a uniformly randomly sampled key
:= Uniform({0, 1})
from the challenger. The challenger ﬂips a coin b
and returns kb.
Guess(b(cid:48)) The adversary immediately terminates its execution after this query.
$
Deﬁnition 9 (Partnering experiment). We deﬁne the partnering experiment as follows. At
the start of the game, the challenger initialises all parties as in the security experiment. The
adversary then asks a series of Create, ASend or ARecv queries, and eventually terminates. There
is no additional model state and no other queries are permitted.
When the game ends, the adversary wins if and only if for any session (u, i, t) with
(u, i, t).σ.status = accept, any of the following hold.
(i) disagreement on group members: there exists another stage (v, j, s) deriving the same key
as (u, i, t) but with (u, i, t).IDs (cid:54)= (v, j, s).IDs
(ii) incorrect peer: there exists a stage (v, j, s) deriving the same key as (u, i, t) with v (cid:54)= u
and v /∈ (u, i, t).IDs
(iii) repeated session key: there exists another session (u, i(cid:48), t(cid:48)), i(cid:48) (cid:54)= i, deriving the same key
as (u, i, t)
(iv) too many copies of a peer: for any peer identity v appearing n > 0 times in (u, i, t).IDs,
v (cid:54)= u, there exist n + 1 stages (v,·,·) deriving the same key as (u, i, t)
Theorem 2. In ART, when the KDF is modelled as a random oracle, the probability that any
PPT adversary wins the partnering game is negligible in the security parameter.
Proof sketch. The result follows directly from the fact that π.IDs is an argument to the KDF
when deriving stage keys. If the KDF is a random oracle its output values do not collide, and
30
thus equal output values imply equal input values, which is enough to rule out the cases in the
partnering security experiment.
Suppose there exists an adversary A which wins the partnering security game. By deﬁnition,
it wins if one of the four cases occurs and we consider each one in turn.
First, suppose that it wins because there exist two stages (u, i, t) and (v, j, s) deriving
the same key but with (u, i, t).IDs (cid:54)= (v, j, s).IDs. The stage key is derived as π.sk :=
KDF(π.sk , π.tk , π.IDs, π.T ). In particular, equality of stage keys implies equality of IDs (except
with negligible probability of collisions in the random oracle), so this case is impossible.
Second, suppose that it wins because there exists a stage (v, j, s) deriving the same key as
(u, i, t) but with v /∈ (u, i, t).IDs. As in the ﬁrst case, we know that (u, i, t).IDs = (v, j, s).IDs,
and thus v /∈ (v, j, s).IDs. However, this contradicts the fact that agents always believe they are
in their own groups, so this case is impossible.
Third, suppose that there exist two sessions (u, i, t) and (u, i(cid:48), t(cid:48)) deriving the same key.
Recall that each stage derives an ephemeral key, and each stage’s own ephemeral key is included
in its local key derivation. For the derived keys to be equal, therefore, the ephemeral keys
generated by both agents would have to be equal as well, which would require a DH collision.
This happens only with negligible probability (formally, we make a game hop to a game which
aborts if there is a DH collision, and bound the diﬀerence between the games; this argument
appears in the proof sketch below), and hence this case is impossible unless i = i(cid:48).
Fourth and ﬁnally, suppose that it wins because there exist n + 1 stages (v,·,·) deriving the
same key as (u, i, t) while there are only n copies of v in (u, i, t).IDs. Since there are only n
copies of v in (u, i, t).IDs, either
(i) one of the n + 1 must have v.idx not equal to an index of v in (u, i, t).IDs, or
(ii) two of the stages (v,·,·) must “collide”, having the same v.idx.
In the ﬁrst case, the disagreement implies that (u, i, t).IDs (cid:54)= (v, j, s).IDs and hence that the
derived keys are distinct, which is a contradiction. In the second case we again use uniqueness
of ephemeral keys: the two colliding stages must have derived distinct ephemeral keys, at most
one of which is the key appearing (u, i, t).IDs, and hence the stages must derive distinct keys.
We have ruled out all cases, and thus are done.
Theorem 1. Let nP, nS and nT denote bounds on the number of parties, sessions and stages in
the security experiment respectively. Under the PRF-ODH assumption with KDFs modeled as
random oracles, the success probability of any PPT adversary against the security experiment
for our protocol is bounded above by
(cid:0)nPnSnT
(cid:1)
1
2
+
2
q
+ γ(nPnSnT
2)γ (PRF-ODH + 1/q) + negl(λ)
where PRF-ODH bounds the advantage of a PPT adversary against the PRF-ODH game. (This
bound depends only on PRF-ODH and not KeyExchange because it is unauthenticated.)
Proof. Security in this sense means that no eﬃcient adversary can break the key indistinguisha-
bility game against the protocol. Suppose for contradiction that A is such an adversary. By
the deﬁnition of the security experiment, it can only win if it issues a Test(u, i, t) query against
some stage t of a session i at agent u such that (u, i, t) is fresh, and subsequently issues a correct
Guess(b) query with non-negligible advantage above 1/2.
By the deﬁnition of freshness, (u, i, t) is fresh (Deﬁnition 7) precisely when
31
(i) it has status accept,
(ii) the adversary has not issued a RevSessKey(u, i, t) query,
(iii) there does not exist (v, j, s) such that the adversary has issued a query RevSessKey(v, j, s)
whose return value is sk, and
(iv) one of the following criteria holds:
(a) t > 0 and session (u, i, t − 1) is fresh, or
(b) the current copath is fresh.
The proof is a case distinction based on adversarial behaviour. We will also construct a
sequence of related games as per the game hopping proof technique [48]. Let Game 0 denote the
game from the original security experiment. Let Advi denote the maximum over all adversaries
A of the advantage of A in game i. Our goal is to bound Adv0, the advantage of any adversary
against the security experiment.
Recall that due to technical limitations of key indistinguishability models we are unable
to faithfully model the explicit MACs which ART uses in group creation and key update
messages. Instead, for the remainder of the proof we omit them from the protocol, and specify
authentication “by ﬁat” through our freshness predicate—that is, we rule out attacks in which
the authentication of these messages is violated.