have been repeatedly proven to be vulnerable against deter-
mined adversaries [27, 52, 54, 18]. In addition, some of the
above techniques have limitations when applied to large and
complex applications due to diﬃculties in static analysis [20,
38], or performance [26]. Nevertheless, the wide deployment
of ASLR, together with DEP has raised the bar for exploit
development. To bypass DEP, today’s exploits employ a
code reuse attack as a prelude to code injection. This code
reuse attack phase has now become the new battleﬁeld for
many low level attacks and defenses.
Control ﬂow integrity [16] provides a foundation for
defending against code-reuse attacks. Several recent research
eﬀorts [66, 63, 49, 24] can signiﬁcantly restrict an attacker’s
ability to launch code reuse attacks. Unfortunately, CFI-
permitted gadgets may still be enough to achieve DEP by-
pass and launch a code injection attack [25, 32, 31, 22]. Even
ﬁne-grained CFI approaches [46, 57, 43, 58] have been shown
to be bypassable [28].
A substantial fraction of the defense techniques described
above, including all bounds-checking techniques, and ﬁne-
grained randomization [21, 20, 23] and ﬁne-grained CFI [46,
57, 43] operate only on source code. In particular, low-level
code that relies on inline assembly will not be protected. Fi-
nally, any code that is available only in binary form cannot
be protected. Unfortunately, even if a single module is not
compiled for bounds-checking, no security guarantees can be
provided for any code. Thus, the “weakest link” can poten-
tially derail the entire the application. In contrast, CFCI’s
protection extends to all code, regardless of the language in
which it is written, or the compiler used to compile it.
Code integrity. Nanda et. al. [41] proposes an approach to
detect foreign code in Windows. They enforce a code loading
policy inside the kernel. Their implementation is based on
BIRD [40]. Similarly, Seshadri et. al. [50] proposes a code
loading policy for OS kernel. Their policy is enforced by a
tiny hypervisor.
MIP [45] and MCFI [46] also incorporate some code in-
tegrity features, implemented using policy checks on mmap
and mprotect. However, their policy is weak in that it
only aims to ensure existing code is never writable and ex-
ecutable. Moreover, the policy is insuﬃcient to overcome
challenges of dynamic loader and code patching. Attack-
ers can divert control ﬂow to dynamic loader or loader code
statically linked into a code module to bypass their policy.
Securing loaders. Realizing the importance of prevent-
ing abuse of code loading privileges, Payer et.al. [48] devel-
oped TRuE, a system that replaces the standard loader with
their secure version. The need to replace the system loader
poses challenges for real-world deployment, as OS vendors
are reluctant to change core platform components. There
is a strong interdependence between the loader and glibc,
and as a result, a replacement of the loader also requires
changes to the glibc package. Another diﬃculty with their
approach is that the secure loader achieves security in part
by restricting the functionality of the loader. Our approach
avoids these drawbacks by permitting continued use of the
standard loader. Security is achieved by a small and inde-
pendent policy enforcement layer that operates outside the
loader, and simply checks the security-relevant operations
made by the loader.
Writing secure loaders is a very diﬃcult task, as demon-
strated by the numerous vulnerabilities reported in produc-
tion loaders [3, 12, 13, 4, 5, 9]. Thus, trusting the complete
loader codebase for code integrity leads to a large trusted
computing base (TCB). In contrast, CFCI implementation
uses a very small reference monitor whose size is no more
than 300 lines, including C and x86 assembly code. In com-
parison, a typical dynamic loader is 28KLoC.
7. CONCLUSIONS
In this paper, we presented an eﬀective countermeasure
against the threat of ROP attacks. Our approach is based
on the observation that the goal of real-world code-reuse
attacks is to disable DEP and launch a native code injection
attack. Our defense combines coarse-grained control-ﬂow
integrity with a comprehensive defense against native code
injection in order to defeat these attacks. Our approach
tracks code loading process through every step, and ensures
that code integrity is preserved at every step. Consequently,
it can ensure a strong property that only authorized (native)
code can ever be executed by any process protected by our
system, CFCI. A key beneﬁt of our approach is that its
security relies on a relatively simple state model for loading,
and a few simple system call policies. It is fully compatible
with existing applications as well libraries and loaders, and
does not require any modiﬁcations at all. CFCI introduces
almost no additional overheads at runtime over CFI, making
it a promising candidate for deployment.
8. REFERENCES
[1] CVE-2000-0854: Earliest side-loading attack.
[2] CVE-2007-3508: Integer overﬂow in loader. http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3508.
[3] CVE-2010-0830: Integer signedness error in loader. http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0830.
[4] CVE-2010-3847: privilege escalation in loader with $origin
for the ld audit environment variable. http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3847.
[5] CVE-2010-3856: privilege escalation in loader with the
ld audit environment. http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3856.
[6] CVE-2011-0562: Untrusted search path vulnerability in
adobe reader.
[7] CVE-2011-0570: Untrusted search path vulnerability in
adobe reader. http://www.cve.mitre.org/cgi-bin/cvename.cgi?
name=CVE-2011-0570.
[8] CVE-2011-0588: Untrusted search path vulnerability in
adobe reader. http://www.cve.mitre.org/cgi-bin/cvename.cgi?
name=CVE-2011-0588.
[9] CVE-2011-1658: privilege escalation in loader with $origin
in rpath. http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1658.
[10] CVE-2011-2398: privilege escalation in loader. http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-2398.
[11] CVE-2012-0158: Side loading attack via microsoft oﬃce.
http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
2012-0158.
[12] CVE-2013-0977: overlapping segments. http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-0977.
[13] CVE-2014-1273: text relocation. http:
//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1273.
[14] LibJIT. https://code.google.com/p/libjit-linear-scan-
register-allocator/.
[15] WinSxS: Side-by-side assembly.
http://en.wikipedia.org/wiki/Side-by-side assembly.
[16] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.
Control-ﬂow integrity. In CCS, 2005.
[17] P. Akritidis, M. Costa, M. Castro, and S. Hand. Baggy
bounds checking: An eﬃcient and backwards-compatible
defense against out-of-bounds errors. In USENIX Security,
2009.
[18] M. Backes and S. N¨urnberger. Oxymoron: Making
ﬁne-grained memory randomization practical by allowing
code sharing. In USENIX Security, 2014.
[19] E. Bendersky. LibJIT Samples.
https://github.com/eliben/libjit-samples, 2013.
[20] S. Bhatkar and R. Sekar. Data space randomization. In
DIMVA, 2008.
[21] S. Bhatkar, R. Sekar, and D. DuVarney. Eﬃcient techniques
for comprehensive protection from memory error exploits.
In USENIX Security, 2005.
[22] N. Carlini and D. Wagner. ROP is still dangerous: Breaking
modern defenses. In USENIX Security, 2014.
[23] S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen,
A.-R. Sadeghi, S. Brunthaler, and M. Franz. Readactor:
Practical code randomization resilient to memory disclosure.
In S&P, 2015.
[24] L. Davi, R. Dmitrienko, M. Egele, T. Fischer, T. Holz,
R. Hund, S. N ˜Aijrnberger, and A. reza Sadeghi. MoCFI: a
framework to mitigate control-ﬂow attacks on smartphones.
In NDSS, 2012.
[25] L. Davi, D. Lehmann, A.-R. Sadeghi, and F. Monrose.
99
in elf: A spotlight on the underappreciated metadata. In
USENIX WOOT, 2013.
[54] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko,
C. Liebchen, and A.-R. Sadeghi. Just-in-time code reuse:
On the eﬀectiveness of ﬁne-grained address space layout
randomization. In S&P, 2013.
[55] C. Song, C. Zhang, T. Wang, W. Lee, and D. Melski.
Exploiting and protecting dynamic code generation. In
NDSS, 2015.
[56] A. Stewart. DLL side-loading: A thorn in the side of the
anti-virus industry, 2014. http:
//www.ﬁreeye.com/resources/pdfs/ﬁreeye-dll-sideloading.pdf.
[57] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway,
´U. Erlingsson, L. Lozano, and G. Pike. Enforcing
forward-edge control-ﬂow integrity in gcc & llvm. In
USENIX Security, 2014.
[58] V. van der Veen, D. Andriesse, E. Goktas, B. Gras,
L. Sambuc, A. Slowinska, H. Bos, and C. Giuﬀrida.
Practical context-sensitive cﬁ. In CCS, 2015.
[59] W. Xu, D. C. DuVarney, and R. Sekar. An eﬃcient and
backwards-compatible transformation to ensure memory
safety of c programs. 2004.
[60] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth,
T. Ormandy, S. Okasaka, N. Narula, and N. Fullagar.
Native Client: a sandbox for portable, untrusted x86 native
code. In S&P, 2009.
[61] Y. Younan, P. Philippaerts, L. Cavallaro, R. Sekar,
F. Piessens, and W. Joosen. Paricheck: an eﬃcient pointer
arithmetic checker for c programs. In ACM ASIACCS, 2010.
[62] B. Zeng, G. Tan, and G. Morrisett. Combining control-ﬂow
integrity and static analysis for eﬃcient and validated data
sandboxing. In CCS, 2011.
[63] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres,
S. McCamant, D. Song, and W. Zou. Practical control ﬂow
integrity & randomization for binary executables. In S&P,
2013.
[64] M. Zhang. PSI: Platform for Static binary Instrumentation.
http://seclab.cs.sunysb.edu/seclab/download.html.
[65] M. Zhang, R. Qiao, N. Hasabnis, and R. Sekar. A platform
for secure static binary instrumentation. In ACM VEE,
2014.
[66] M. Zhang and R. Sekar. Control ﬂow integrity for COTS
binaries. In USENIX Security, 2013.
[67] M. Zhang and R. Sekar. Squeezing the dynamic loader for
fun and proﬁt.
http://seclab.cs.sunysb.edu/seclab/pubs/seclab15-12.pdf,
2015.
Stitching the gadgets: On the ineﬀectiveness of
coarse-grained control-ﬂow integrity protection. In USENIX
Security, 2014.
[26] L. Davi, C. Liebchen, A.-R. Sadeghi, K. Z. Snow, and
F. Monrose. Isomeron: Code randomization resilient to
(just-in-time) return-oriented programming. In NDSS, 2015.
[27] T. Durden. Bypassing pax aslr protection. Technical report,
Phrack Magazine, vol. 0x0b, no. 0x3b, 2002.
[28] I. Evans, F. Long, U. Otgonbaatar, H. Shrobe, M. Rinard,
H. Okhravi, and S. Sidiroglou-Douskos. Control jujutsu: On
the weaknesses of ﬁne-grained control ﬂow integrity. In
CCS, 2015.
[29] A. D. Federico, A. Cama, Y. Shoshitaishvili, C. Kruegel,
and G. Vigna. How the elf ruined christmas. In USENIX
Security, 2015.
[30] B. Ford and R. Cox. Vx32: lightweight user-level
sandboxing on the x86. In USENIX ATC, 2008.
[31] E. G¨okta¸s, E. Athanasopoulos, M. Polychronakis, H. Bos,
and G. Portokalidis. Size does matter: Why using
gadget-chain length to prevent code-reuse attacks is hard.
In USENIX Security, 2014.
[32] E. G ˜A˝ukta, E. Athanasopoulos, H. Bos, and
G. Portokalidis. Out of control: Overcoming control-ﬂow
integrity. In S&P, 2014.
[33] N. Hasabnis, A. Misra, and R. Sekar. Light-weight bounds
checking. In ACM CGO, 2012.
[34] R. W. M. Jones, P. H. J. Kelly, M. C, and U. Errors.
Backwards-compatible bounds checking for arrays and
pointers in c programs. In AADEBUG, 1997.
[35] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar,
and D. Song. Code-pointer integrity. In OSDI, 2014.
[36] L. Li, J. E. Just, and R. Sekar. Address-space
randomization for windows systems. In ACSAC, 2006.
[37] S. McCamant and G. Morrisett. Evaluating SFI for a CISC
architecture. In USENIX Security, 2006.
[38] V. Mohan, P. Larseny, S. Brunthalery, K. W. Hamlen, and
M. Franz. Opaque control-ﬂow integrity. In NDSS, 2015.
[39] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic.
SoftBound: highly compatible and complete spatial memory
safety for c. In PLDI, 2009.
[40] S. Nanda, W. Li, L.-C. Lam, and T.-c. Chiueh. BIRD:
binary interpretation using runtime disassembly. In CGO,
2006.
[41] S. Nanda, W. Li, L.-C. Lam, and T.-c. Chiueh. Foreign code
detection on the windows/x86 platform. In ACSAC, 2006.
[42] Nergal. The advanced return-into-lib(c) exploits: PaX case
study. Phrack Magazine, 2001.
[43] B. Niu and T. Gang. Per-input control-ﬂow integrity. In
CCS, 2015.
[44] B. Niu and G. Tan. RockJIT: Securing just-in-time
compilation using modular control-ﬂow integrity.
[45] B. Niu and G. Tan. Monitor integrity protection with space
eﬃciency and separate compilation. In CCS, 2013.
[46] B. Niu and G. Tan. Modular control-ﬂow integrity. In
PLDI, 2014.
[47] PaX. Address space layout randomization.
http://pax.grsecurity.net/docs/aslr.txt, 2001.
[48] M. Payer, T. Hartmann, and T. R. Gross. Safe loading - a
foundation for secure execution of untrusted programs. In
S&P, 2012.
[49] J. Pewny and T. Holz. Control-ﬂow Restrictor:
Compiler-based CFI for iOS. In ACSAC, 2013.
[50] A. Seshadri, M. Luk, N. Qu, and A. Perrig. Secvisor: A tiny
hypervisor to provide lifetime kernel code integrity for
commodity oses. In SOSP, 2007.
[51] H. Shacham. The geometry of innocent ﬂesh on the bone:
return-into-libc without function calls (on the x86). In CCS,
2007.
[52] H. Shacham, M. Page, B. Pfaﬀ, E.-J. Goh, N. Modadugu,
and D. Boneh. On the eﬀectiveness of address-space
randomization. In CCS, 2004.
[53] R. Shapiro, S. Bratus, and S. W. Smith. ”weird machines”
100