the attacker does not subvert the intended control-ﬂow in
the server. WIT detects the attack when the wrapper for the
recv call is about to write to the guard object at the end of
the buffer. The example in Section 2 is inspired by this.
Stunnel is a generic tunnelling service that encrypts
TCP connections using SSL. We studied a format string vul-
nerability in the code that establishes a tunnel for SMTP [4].
An attacker can overﬂow a stack buffer by sending a mes-
sage that is passed as a format string to the vsprintf func-
tion. WIT detects the attack when vsprintf attempts to
write the guard object at the end of the buffer.
Libpng is a library for processing images in the PNG ﬁle
format [3]. Many applications use Libpng to display im-
ages. We built a test application distributed with Libpng
and attacked it using the vulnerability described in [31]. The
attacker can supply a malformed image ﬁle that causes the
application to overﬂow a stack buffer. WIT detects the at-
tack when a guard object is about to be written.
8. Related work
Type safe languages like Java and C# eliminate memory
errors. However, there is a large amount of software written
in unsafe languages like C and C++, and these languages are
still widely used to develop new software. So memory er-
rors will remain a problem in the foreseeable future. There
is a large body of work on techniques to protect C and C++
programs from attacks that exploit memory errors.
Some techniques use static analysis to identify vulnera-
bilities, for example, [42, 29, 14]. They have the advantage
of removing vulnerabilities from software before it ships
and they do not introduce any runtime overhead. How-
ever, static analysis techniques are not sufﬁcient because
they are imprecise: they can miss vulnerabilities and raise
false alarms. Too many false alarms are an issue because
they may cause developers to stop using the tools.
Many techniques to prevent attacks that exploit memory
errors are not widely used. We believe there are two reasons
for this: requiring non-trivial changes to the source code or
the language runtime, or incurring high overhead. For ex-
ample, CCured [33] and Cyclone [24] proposed memory
safe dialects of C. They can prevent all memory errors but
require a signiﬁcant effort to port C applications to the safe
dialects, and require major changes to the runtime. For ex-
ample, they replace free by a garbage collector. Their run-
time overhead is also signiﬁcantly higher than WIT’s.
Other techniques can be applied to C and C++ programs
without modiﬁcations. Several systems detect attacks us-
ing dynamic taint analysis, e.g., [34, 17], which can prevent
many attacks that exploit memory errors and other types of
attacks. They work with binaries and do not require source
code. However, their overhead is several orders of magni-
tude higher than WIT’s. Xu et al [44] describe a dynamic
taint analysis technique that is implemented as a source-to-
source transformation on C programs. Their overheads are
an order of magnitude lower than previous techniques but
they are still above 100% when preventing memory error
exploits on CPU-intensive benchmarks.
There are several bounds checkers for C. For example,
the Jones and Kelly [25] bounds checker does not require
changes to the pointer format. It instruments pointer arith-
metic to ensure that the result and original pointers point
to the same object. To ﬁnd the target object of a pointer,
it uses a splay tree that keeps track of the base address
and size of heap, stack, and global objects. CRED [37]
is similar but provides support for some common uses of
out-of-bounds pointers in existing C programs. These tech-
niques have high overhead, for example, CRED can slow
down applications by up to a factor of 12. Xu et al [45]
describe a technique that improves the coverage of the pre-
vious bounds checkers and reduces their overhead. Their
average overhead when preventing only spatial errors in the
Olden benchmarks is 12 times larger than WIT’s.
Some techniques to prevent memory error exploits de-
fend from attacks that overwrite speciﬁc targets, such as re-
turn addresses, pointers, or other control data (e.g., [20, 19,
39]), or that exploit speciﬁc vulnerabilities, such as format
string vulnerabilities (e.g., [18]). These techniques have
low overhead but they cannot defend from other attacks.
Techniques inspired by StackGuard [20] are widely used.
However, there are memory error exploits that they cannot
catch [43]. For example, they provide no protection from
overﬂows of heap and static variables [35]. WIT has similar
performance and broader coverage than these techniques.
The concept of control-ﬂow integrity generalizes the
work of Wagner and Dean [41] and was introduced in [28,
6]. However, attackers can exploit memory errors to exe-
cute arbitrary code without violating control-ﬂow integrity.
There are examples of several attacks of this type in [15].
CFI [6] and Program Shepherding [28] cannot detect this
type of attack. WIT can and it also detects all attacks that
violate control-ﬂow integrity. Additionally, WIT has lower
overhead because it avoids control-ﬂow integrity checks on
returns. For example, CFI has an average overhead of 15%
and a maximum overhead of 45% on the SPEC benchmarks
where we overlap. The average overhead grows to 24% with
the version of CFI that uses a shadow call stack to ensure
that functions return to their caller. WIT has an average
overhead of 10% and a maximum of 25% and it also en-
sures functions return to their caller.
DFI [13] combines static points-to analysis with runtime
instrumentation like WIT. For each instruction that reads a
value, it uses static analysis to compute the instructions that
are allowed to write the value. Then it instruments writes
and reads to ensure that the values read at runtime were
written by allowed instructions. Its coverage is similar to
WIT’s. It can detect some out-of-bounds reads and reads
after free but it does not have guards to improve coverage
when the analysis is imprecise. DFI’s average overhead on
the SPEC benchmarks where we ovelap is 104%.
The technique described by Yong et al. [46] has some
similarities with WIT. It assigns colors to objects and
checks a color table on writes. However, it has worse cov-
erage than WIT because it uses only two colors, it does not
insert guards, and it does not enforce control-ﬂow integrity.
The two colors distinguish between objects that can be writ-
ten by an unsafe pointer and those that cannot. Yong et al.
incur an average overhead ten times larger than WIT on the
SPEC benchmarks where we overlap.
In concurrent work, Clause et al [16] describe a tech-
nique that assigns colors to objects and pointers dynami-
cally. It assigns a random color to memory objects when
they are allocated and, when a pointer to an object is cre-
ated, it assigns the color of the object to the pointer. Then
it propagates pointer colors on assignment and arithmetic.
On reads and writes to memory, it checks if the color of the
pointer and the memory match. Their software-only version
slows down SPEC INT by a factor of 100 or more. With
special hardware and 256 colors, their average overhead on
SPEC INT is 7%. WIT has similar overhead without special
hardware support.
There are several techniques that insert guard zones or
pages around objects, for example, [36, 22]. WIT achieves
better coverage by combining guard objects with runtime
enforcement of write and control-ﬂow integrity.
Some techniques randomize the layout of objects in
memory to make it harder for attackers to exploit memory
errors. The most comprehensive randomization technique
that we know [11] has an overhead of 17% on gzip and WIT
has an overhead of 7%. DieHard [10] randomizes the loca-
tion of objects in the heap and the order in which objects are
reused after being freed. The geometric mean of their over-
head on SPEC INT is 12% but their maximum overhead is
109% (on twolf). WIT’s overhead on twolf is 3%. Other
techniques do instruction set randomization [27] but have
high overhead without hardware support.
The fastest software-only technique with coverage simi-
lar to WIT was presented by Dhurjati et al [21]. WIT can
prevent attacks that cannot be prevented by this technique.
For example, Dhurjati et al cannot prevent attacks that over-
ﬂow a buffer inside a structure to overwrite a pointer ﬁeld
in the same structure, or attacks that exploit dereferences
of pointers in objects that are freed and reused [7]. These
attacks can use corrupt pointers to write to arbitrary mem-
ory locations or to invoke arbitrary code. WIT’s write and
indirect call checks severely restrict the use of these cor-
rupt pointers. On the other hand, Dhurjati et al can prevent
most out-of-bounds reads and writes. WIT does not prevent
out-of-bounds reads and it may fail to prevent some out-of-
bounds writes as discussed earlier.
The technique of Dhurjati et al is similar to CRED but in-
troduces several optimizations that reduce runtime overhead
dramatically. For example, it uses points-to analysis to par-
tition objects into pools and uses a splay tree for each pool.
These splay trees can be looked up more efﬁciently than
the large splay tree used by previous approaches and each
pool has a cache for even faster lookups. This technique
has an average overhead of 12% and a maximum overhead
of 69% in the Olden benchmarks. WIT’s average overhead
on the same benchmarks is 4% and the maximum overhead
is 13%. WIT is three times faster than the fastest technique
with similar coverage.
9. Conclusion
We presented WIT, a new technique to prevent memory
error exploits. WIT uses a combination of static analysis
and runtime instrumentation to enforce two safety proper-
ties: write integrity ensures that instructions do not write
to unintended storage locations, and control-ﬂow integrity
ensures that control is not transferred to unintended targets.
WIT can prevent all memory error exploits that enable arbi-
trary code execution that we know about. We have an efﬁ-
cient implementation of WIT: the average space overhead in
our benchmarks is 13% and the average runtime overhead
is 7%. We believe this overhead is low enough for WIT to
be deployed widely.
Acknowledgments
We would like to thank the anonymous reviewers and
the following people for discussions and comments on the
work described in this paper: Martin Abadi, Andy Ay-
ers, Paul Barham, Richard Black, Tim Burrel, Chris Haw-
blitzel, Nitin Kumar Goel, Joshua Goodman, Steve Kruy,
Ronald Laeremans, Scott Lambert, Butler Lampson, John
Manferdelli, Jean-Philippe Martin, Chris McKinsey, Matt
Miller, Matt Moore, Marcus Peinado, Herb Sutter, Damien
Watkins, Chris Walker, James Whittaker, and Ben Zorn.
References
[1] GHttpd Log() Function Buffer Overﬂow Vulnerability.
http://www.securityfocus.com/bid/5960.
[2] Null HTTPd Remote Heap Overﬂow Vulnerability.
http://www.securityfocus.com/bid/5774.
[3] Portable Network Graphics (PNG) Speciﬁcation and Exten-
sions. http://www.libpng.org/pub/png/spec/.
[4] STunnel Client Negotiation Protocol Format String Vulnera-
bility. http://www.securityfocus.com/bid/3748.
[5] Smashing the stack for fun and proﬁt. Phrack 7, 49 (Nov.
1996).
[6] ABADI, M., BUDIU, M., ERLINGSSON, U., AND LIGATTI,
J. Control-Flow Integrity: Principles, Implementations, and
Applications. In ACM Conference on Computer and Com-
munications Security (Nov. 2005).
[7] AFEK, J., AND SHARABANI, A. Dangling Pointer: Smash-
ing the pointer for fun and proﬁt. Watchﬁre white paper,
Aug. 2007.
[8] ANDERSEN, L. Program analysis and specialization for the
C programming language. PhD thesis, University of Copen-
hagen, 1994.
[9] AVOTS, D., DALTON, M., LIVSHITS, V. B., AND LAM,
Improving software security with a C pointer anal-
In ACM/IEEE International Conference on Software
M. S.
ysis.
Engineering (May 2005).
[10] BERGER, E., AND ZORN, B. DieHard: Probabilistic Mem-
ory Safety for Unsafe Languages.
In ACM Conference on
Programming Language Design and Implementation (June
2006).
[11] BHATKAR, S., SEKAR, R., AND DUVARNEY, D. Efﬁcient
techniques for comprehensive protection from memory error
exploits. In USENIX Security Symposium (July 2005).
[12] CARLISLE, M. C. Olden: Parallelizing Programs with Dy-
namic Data Structures on Distributed-Memory Machines.
PhD thesis, Princeton University, 1996.
[13] CASTRO, M., COSTA, M., AND HARRIS, T. Securing
software by enforcing data-ﬂow integrity. In USENIX Sym-
posium on Operating Systems Design and Implementation
(Nov. 2006).
[14] CHEN, K., AND WAGNER, D. Large-scale analysis of for-
mat string vulnerabilities in Debian Linux.
In Workshop
on Programming Languages and Analysis for Security (June
2007).
[15] CHEN, S., XU, J., SEZER, E. C., GAURIAR, P., AND IYER,
In
R. K. Non-control-data attacks are realistic threats.
USENIX Security Symposium (July 2005).
[30] MICROSOFT.
Phoenix
compiler
framework.
http://research.microsoft.com/phoenix/
phoenixrdk.aspx.
[16] CLAUSE, J., DOUDALIS, I., ORSO, A., AND PRVULOVIC,
M. Effective Memory Protection Using Dynamic Tainting.
In International Conference on Automated Software Engi-
neering (Nov. 2007).
[17] COSTA, M., CROWCROFT, J., CASTRO, M., ROWSTRON,
A., ZHOU, L., ZHANG, L., AND BARHAM, P. Vigilante:
End-to-End Containment of Internet Worms. In Symposium
on Operating System Principles (Oct. 2005).
[18] COWAN, C., BARRINGER, M., BEATTIE, S., KROAH-
HARTMAN, G., FRANTZEN, M., AND LOKIER, J. Format-
Guard: automatic protection from printf format string vul-
nerabilities. In USENIX Security Symposium (Aug. 2001).
[31] MITRE CORPORATION. Multiple buffer overﬂows in libpng
1.2.5. CVE-2004-0597, June 2004.
[32] MOORE, D., PAXSON, V., SAVAGE, S., SHANNON, C.,
Inside the Slammer
STANIFORD, S., AND WEAVER, N.
worm. IEEE Security and Privacy 1, 4 (July 2003).
[33] NECULA, G., CONDIT, J., HARREN, M., MCPEAK, S.,
AND WEIMER, W. CCured: Type-Safe Retroﬁtting of
Legacy Software. ACM Transactions on Programming Lan-
guages and Systems 27, 3 (May 2005).
[34] NEWSOME, J., AND SONG, D. Dynamic taint analysis for
automatic detection, analysis and signature generation of ex-
ploits on commodity software. In NDSS (Feb. 2005).
[19] COWAN, C., BEATTIE, S., JOHANSEN, J., AND WAGLE, P.
Pointguard: Protecting pointers from buffer overﬂow vulner-
abilities. In USENIX Security Symposium (Aug. 2003).
[35] PINCUS, J., AND BAKER, B. Beyond stack smashing: Re-
cent advances in exploiting buffer overruns. IEEE Security
and Privacy 2, 4 (2004), 20–27.
[20] COWAN, C., PU, C., MAIER, D., HINTON, H., WADPOLE,
J., BAKKE, P., BEATTIE, S., GRIER, A., WAGLE, P., AND
ZHANG, Q. Stackguard: Automatic detection and preven-
tion of buffer-overrun attacks. In USENIX Security Sympo-
sium (Jan. 1998).
[21] DHURJATI, D., AND ADVE, V. Backwards-compatible ar-
ray bounds checking for C with very low overhead.
In
ACM/IEEE International Conference on Software Engineer-
ing (May 2006).
[22] DHURJATI, D., AND ADVE, V. Efﬁciently Detecting All
Dangling Pointer Uses in Production Servers.
In Inter-
national Conference on Dependable Systems and Networks
(June 2006).
[23] HEINTZE, N., AND TARDIEU, O. Ultra-fast Aliasing Anal-
ysis using CLA: A Million Lines of C Code in a Second.
In ACM Conference on Programming Language Design and
Implementation (June 2001).
[24] JIM, T., MORRISETT, G., GROSSMAN, D., HICKS, M.,
CHENEY, J., AND WANG, Y. Cyclone: A safe dialect of
C. In USENIX Annual Technical Conference (June 2002).
[25] JONES, R., AND KELLY, P. Backwards-Compatible Bounds
Checking for Arrays and Pointers in C Programs. In Work-
shop on Automated Debugging (May 1997).
[26] JP. Advanced Doug Lea’s malloc exploits. Phrack, 61 (Sep.
2003).
[27] KC, G. S., KEROMYTIS, A. D., AND PREVELAKIS, V.
Countering code-injection attacks with instruction-set ran-
domization. In ACM CCS (Oct. 2003).
[28] KIRIANSKY, V., BRUENING, D., AND AMARASINGHE,
S. P. Secure execution via program shepherding. In USENIX
Security Symposium (Aug. 2002).
[29] LAROCHELLE, D., AND EVANS, D. Statically detecting
In USENIX Security
likely buffer overﬂow vulnerabilities.
Symposium (Aug. 2001).
[36] ROBERTSON, W., KRUEGEL, C., MUTZ, D., AND
VALEUR, F. Run-time Detection of Heap-based Overﬂows.
In USENIX conference on System administration (2003).
[37] RUWASE, O., AND LAM, M. A practical dynamic buffer
overﬂow detector. In NDSS (Feb. 2004).
[38] SHANKAR, U., TALWAR, K., FOSTER, J. S., AND WAG-
NER, D. Detecting format string vulnerabilities with type
qualiﬁers. In USENIX Security Symposium (Aug. 2001).
[39] SMIRNOV, A., AND CHIUEH, T. DIRA: Automatic detec-
tion, identiﬁcation, and repair of control-hijacking attacks.
In NDSS (Feb. 2005).
[40] SPEC. SPEC Benchmarks. http://www.spec.org.
[41] WAGNER, D., AND DEAN, D. Intrusion Detection via Static
Analysis. In IEEE Symposium on Security and Privacy (May
2001).
[42] WAGNER, D., FOSTER, J. S., BREWER, E. A., AND
AIKEN, A. A ﬁrst step towards automated detection of buffer
overrun vulnerabilities. In NDSS (2000).
[43] WILANDER, J., AND KAMKAR, M. A comparison of pub-
licly available tools for dynamic buffer overﬂow prevention.
In NDSS (Feb. 2003).
[44] XU, W., BHATKAR, S., AND SEKAR, R. Taint-enhanced
policy enforcement: A practical approach to defeat a wide
range of attacks. In USENIX Security (2006).
[45] XU, W., DUVARNEY, D. C., AND SEKAR, R. An efﬁcient
and backwards-compatible transformation to ensure mem-
ory safety of c programs. SIGSOFT Softw. Eng. Notes 29,
6 (2004), 117–126.
[46] YONG, S. H., AND HORWITZ, S. Protecting C programs
from attacks via invalid pointer dereferences. In European
Software Engineering Conference (2003).
[47] YONG, S. H., AND HORWITZ, S. Pointer-Range Analysis.
In Static Analysis Symposium (2004).