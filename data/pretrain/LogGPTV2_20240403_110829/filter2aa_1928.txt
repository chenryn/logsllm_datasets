Dance with Apple Core
盘古安全实验室
关于我们
• 专业的移动安全研究团队
• 专注物联时代安全
• 专心与最新的安全技术
Apple内核101
• 内核 (XNU)是Mach/BSD的混合体
• 运行的驱动程序在单独分离的一套框架
• “DriverKit”也就是现在的IOKit
Apple内核101
• BSD
• XNU的最上层是POSIX/BSD体系
• 采用FreeBSD6.0的代码
• 提供files, processes/pthread, signals等等
• Apple扩展: 增加了很多独有的syscalls
• Mach
• 内核中的微内核
• NeXTSTEP时代的遗留产物
• 提供task, thread, memory以及IPC通讯机制的实现
• 处理底层的异常，中断及陷入
Apple内核101
• IOKit (DriverKit)
• 自主的驱动程序环境
• 移植自NextSTEP时代的DriverKit
• 采用面向对象，并且受限制的C++框架
• 采用复杂的多层机制”IORegistry”
• 采用它自身的IPC子系统(mach)
• 在内核中parse XML(!!!)
• 内核中主要的attack surface
IOKit 101
• 自包含的运行环境
• IO* API封装着内核态的API
• 驱动相对容易移植
• C++运行库由libkern提供
• 驱动通过IORegistry注册并且分类
• 用户态的API由IOKit.framework提供
• 映射内存至用户态
• 对Userclient提供方法和属性设置接口
IOKit 101
• IOService
• 自动向IORegistry注册驱动
• 在驱动生命周期内提供callback
• 支持notification
• 支持中断处理
• 并且提供Userclient机制和用户态API进行通讯
IOKit 101
• IOKit User Clients
• 直接和用户态交互的接口
• 并非所有驱动都提供User Clients
• 通过继承IOUserClient实现
• 调用的方法保存在vtable
• IOKit会校验对应方法的参数(类型, size)
• Struct / Scalar (二进制数据，以及整数或者内存地址)
IOKit 漏洞举例
• 内核中提供XML解析
• 其中OSUnserializeBinary用于反序列化二进制XML数据
• OSUnserializeBinary 通过动态数组的方式来手动管理OSobject的
指针
• 存在多个漏洞
IOKit 漏洞举例
• CVE-2016-1828 use-after-free漏洞
• 当我们在XML字典中两次设置同一个key的时候，
会导致前一个key的对象指针指向的内容被释
放掉
• 但是OSUnserializeBinary内部动态数组中还保
存了前一个对象的指针
• 当这个指针被引用的时候，导致UAF
IOKit 漏洞举例
• CVE-2016-4655 / CVE-2016-4680
• 内核info-leak漏洞
• 在处理kOSSerializeNumber时，二进制内
容中的长度直接传递给
OSNumner::withNumber函数
IOKit 漏洞举例
• OSNumber
• 实际上长度不能大于64字节
• 但是代码在初始化size的时候并没有对用户输入做验证
• 会影响调用size getter函数numberOfBits()/numberOfBytes()
IOKit 漏洞举例
• is_io_registry_entry_get_property_bytes
• 该函数用于获取指定key的数据
• Bytes=&offsetBytes 指向栈上的数据
• 长度是我们控制的
• bcopy调用会导致泄露栈上的数据
• 函数返回地址/堆地址/cookie
IOKit/MIG 漏洞举例
• IOSurfaceRootUserClient port UAF (CVE-2017-13861)
• UserClient异步调用的时候会释放一个传入的port结构
• IOConnectCallAsyncStructMethod(connect, 17, port, &references, 1, input, sizeof(input), 
NULL, NULL);
• 17号调用中的releaseAsyncReference64操作，从而引发iokit_release_port_send释放传入
的port结构
IOKit/MIG 漏洞举例
• IOSurfaceRootUserClient port UAF (CVE-2017-13861)
• 返回至上层的MIG代码时会继续对这个已经释放过port进行清理操作，导致UAF
• ipc_kmsg_destroy->ipc_kmsg_clean->ipc_kmsg_clean_body
• 详细分析：http://blog.pangu.io/iosurfacerootuserclient-port-uaf/
• GP0 wake_port exploit：https://bugs.chromium.org/p/project-
zero/issues/detail?id=1417
IOKit 漏洞挖掘思路
• 堆栈溢出
• 整数溢出
• IOSurface 分配surface对象
• 数组越界
• 数组索引的时候长度用户可控
• TOCTTOU/Double Fetch
• 很多IOService会map一段内存与用户态进程共享，这段共享数据是否会存在问题
• 类型混淆
• Race condition/UAF
• IOService是允许有多个UserClient的，是否正确的设置锁
协处理器的安全问题
• 除了AP之外的其他处理器
• 相机
• Wifi
• SEP
• 固件升级流程是否存在安全问题
• 相机固件才有crc32校验
• SEP芯片内置GID key
协处理器的安全问题
• 协处理器架构 (以SEP为例)
• 采用RTOS 
• 和AP通讯采用mailbox机制
• OS之上运行各种app 
• 指纹识别
• 认证服务
• 缺少一定的安全防护机制
• 没有ASLR
协处理器的安全问题
• GP0 Wifi漏洞/Broadpwn 通过协处理器打到系统AP
• Broadcom Wifi SoC(System on Chip)架构
• 运行Broadcom修改的RTOS
• 网上可能还能找到一些相似的代码(VMG-1312)
• 与AP(应用处理器)的接口
• SDIO
• PCIE
• 获得Wifi代码芯片执行权限后，再通过PCIE读写物理内存
• PCIE->DART (Device Address Resolution Table)
• 详细细节可以参考： https://googleprojectzero.blogspot.co.id/2017/10/over-air-
vol-2-pt-3-exploiting-wi-fi.html
THANKS
Q&A