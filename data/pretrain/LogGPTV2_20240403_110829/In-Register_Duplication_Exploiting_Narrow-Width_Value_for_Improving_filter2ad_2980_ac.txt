t
o
r
64
68
Parity Encoding
Parity Encoding
2
66
n1
n0
32
32
Parity Encoding
Parity Encoding
2
RF Read
Exec/Bypass/P_Chk
Dcache Acc./P_Enc
Figure 5. The augmented datapath integrating in-register duplication and parity coding to support
both error detection and error recovery.
To integrate parity coding with in-register duplication,
we need to add a separate pipeline stage to perform parity
encoding after the execution stage. Figure 5 shows the mod-
iﬁed datapath supporting both error detection and recovery.
The parity bit for each 32-bit half is generated in the parity
encoding (P Enc) stage. Parity checking (P Chk) for input
operands is overlapped with the ﬁrst cycle of the execution
stage such that the branch resolution loose loop [3] is not
increased. This also guarantees that detected errors in input
operands are signaled before the erroneous result is written
back to the register ﬁle since many ALU operations take just
one cycle to complete. Input operands read from the regis-
ter ﬁle come with the parity bits for the two 32-bit halves.
Parity checking basically regenerates the parity bit for each
32-bit half and compares it against the one with the data
value. However, operands retrieved from the ﬁrst stage of
the bypass network do not have parity bits generated yet. In
such a case, both parity encoding (P Enc stage) and parity
regenerating (in P Chk stage) are performed simultaneously
and the parity bits from the P Enc stage are bypassed to the
P Chk stage for parity bit checking since the comparison
happens in the later stage of P Chk. Here, we use the sec-
ond strategy presented early. If the two parity bits for the
lower 32-bit half match, no error is detected. Otherwise,
the lower half has been corrupted by errors and a stall cycle
is inserted. Now if the parity bits for the upper 32-bit half
match, then the upper half is copied back to the lower half to
recover the corrupted data. The instruction is then replayed
with the recovered inputs. However, if the upper half is also
corrupted and error-detected, an exception is raised for the
higher level systems to solve the problem.
Since parity encoding takes one additional cycle, one de-
sign issue raised here is when to write back the result value
and the parity bits. If the value and parity bits are written
back to the register ﬁle in two consecutive cycles, additional
write ports must be provided for writing parity bits, which
violates the spirit of in-register duplication since it deterio-
rates the access latency and power consumption of the reg-
ister ﬁle. Otherwise, the result writeback can be delayed by
one cycle till the parity bits are available. However, delay-
ing writeback increases the stages of the bypass network,
thus increasing the complexity and number of wires of the
bypass network. To address these issues, we propose to use
a special bit-addressable parity register to hold two parity
bits for each entry in the register ﬁle. Notice that the data
cache interface uses the ﬁrst strategy (comparing two 32-bit
halves for error detection) to avoid storing error-corrupted
data into the cache.
5.4. Protecting the Regular Values
As a side beneﬁt of in-register duplication, regular values
(cannot be represented by 32 bits plus 2 ﬂag bits) are also
protected by the 2 parity bits. For a detected regular value,
the 2 ﬂag bits n1n0 are reset to 00. During the P Enc stage,
two parity bits are generated for the two 32-bit halves in the
same way as for narrow-width values. Once a regular value
reaches the input of a functional unit, the ﬂags bits n1n0
(=00) enforce parity checking for both 32-bit halves to ver-
ify the absence of soft errors. If any half fails the parity
check, an error signal is raised. However, the hardware it-
self is not capable of recovering the error-corrupted regular
value. Notice that a similar scheme as in [17] can be ap-
plied to exploit free registers for duplicating a replica of the
regular value, which provides recovery capability. In such a
scheme, the mapping information between the original reg-
ister and the copy register shall be maintained in order to
locate the copy register during recovery. Due to signiﬁcant
modiﬁcations required in the register renaming logic, the
register ﬁle, and the issue queue, we do not explore further
this idea in the following discussion.
6. Error Model and Soft Error Injection
To evaluate the error resilience of our schemes, we con-
ducted soft error injection during execution-driven simula-
tion. The software error injection ﬂips one bit or multiple
bits in a selected register value. Since the multiple-bit error
rate is several magnitudes lower than the single-bit error rate
[12], we assume a single-bit error model in this study. Our
error injection scheme simulates single-event upsets (SEUs)
in the register ﬁle, the bypass network, and the result write-
back bus. At each clock cycle, a uniformly distributed ran-
dom function is called to locate a register and a speciﬁc bit
in that register. Then, an error is injected with a given prob-
ability (e.g., 10−7 [12]), i.e., single-bit soft error rate. Dur-
ing error injection, if the selected register is receiving a new
Int/FP issue queue
Load/Store Queue
Active list (ACL)
Int/FP Register File
Datapath width
Function Units
Branch Predictor
L1 I/DCache
L2 UCache
Memory
TLB
Processor Core
128 entries
256 entries
512 entries
128/512 registers
8 instructions per cycle
8 IALU, 2 IMULT/IDIV, 4 FALU
2 FMULT/FDIV/FSQRT, 4 MemPorts
Branch Predictor
tournament predictor with a 4K meta-table,
a 4K bimodal predictor table, and a 2-level
gshare predictor with 12-bit history
2048-entry, 4-way BTB, and 32-entry RAS
Memory Hierarchy
64KB, 2 ways, 64B blocks, 2 cycle latency
4MB, 8 ways, 128B blocks, 12 cycle latency
225 cycles ﬁrst chunk, 12 cycles rest
fully-assoc., 128 entries, 30-cycle miss penalty
Table 1. Parameters for the simulated micro-
processor.
value which is also being bypassed to the next execution
stage, we ﬂip the bit wire in the bypass network instead of
the bit cell in the register ﬁle. Thus error detection and re-
covery can be immediately exercised at the P Chk stage. If
the selected value is transmitting over the result bus, error
injection also ﬂips the corresponding bit wire in the result
bus and the error is propagated to the register entry in the
register ﬁle once the value is written. Otherwise, a bit cell
in the register ﬁle is ﬂipped to reﬂect the error-corrupted
bit value. Notice that each register ﬁle write clears out the
errors previously injected into that particular register entry.
To avoid crashing the simulation, each injected error is
logged using a bitmap for each register entry instead of ﬂip-
ping the real bit value and the error history is also recorded.
During the simulation, the soft error bitmap and error his-
tory information of a given register value are used to per-
form error detection and recovery at the execution/P Chk
stage.
7. Evaluation
7.1. Experimental Setup
We derive our simulators from SimpleScalar V3.0 [5]
to model a contemporary high-performance microproces-
sor similar to Alpha 21464 [23]. Table 1 shows the detailed
conﬁguration of the simulated microprocessor. For experi-
mental evaluation, we use SPEC CINT2000 suite compiled
for the Alpha instruction set architecture using “-arch ev6
-non shared” option with “peak” tuning. We use the refer-
ence input sets for this study. Each benchmark is ﬁrst fast-
forwarded to its early single simulation point (gap uses the
standard single simulation point instead of the very large
early single simulation point) speciﬁed by SimPoint [27].
We use the last 100 million instructions during the fast-
forwarding phase to warm-up the caches if the number of
skipped instructions is more than 100 million. Then, we
simulate the next 100 million instructions in detail.
7.2. Duplication Rates and Performance
Impact
The ability to recover register values from detected er-
rors depends on the availability and correctness of the du-
plicate copies. We use the write-with-duplicate (WWD) rate
as ﬁrst-order estimation to measure the capability of a reli-
able scheme to duplicate the register values,
W W D Rate =
#W rite w/ Duplicate
#T otal W rites
,
and use the read-with-duplicate (RWD) rate as ﬁrst-order
estimation to approximate the reliable read of register val-
ues against soft errors,
RW D Rate =
#Reads w/ Duplicate
#T otal Reads
.
Considering
a
Figure 6 (a) shows that by exploiting narrow-width val-
ues alone, in-register duplication achieves a WWD rate of
94% and a RWD rate of 95%, an average across SPEC
CINT2000 benchmarks, without any performance loss.
This RWD rate is signiﬁcantly improved over the results
(78% for CE, and 84% for AG at a 0.2% performance loss)
reported in [17]. In the mean time, our in-register dupli-
cation scheme avoids the hardware complexity of the latter
schemes.
full-duplication
scheme
(Full Duplication) that allocates a copy register
for each result register at the register renaming stage,
the hardware implementation is much more complexity-
effective than the CE/AG schemes [17] since the copy
register is implied. The Full Duplication scheme
achieves a rate of 100% for both WWD and RWD, how-
ever, suffers from a signiﬁcant performance loss, 7.7%
on the average, as shown in Figure 6 (b). Our in-register
duplication IRD scheme duplicates the narrow-width value
within the same register and requires no additional copy
register, thus incurring no performance overhead. Figures
6 (a) and (b) together show that our schemes are very
effective in providing a high error coverage for applications
where the performance and cost are highly constrained.
7.3. Error Behavior under Soft Error Injec-
tion
To further evaluate the effectiveness of the reliable
schemes proposed in this work, we perform experiments for
error detection and recovery under error injection. For error
injection, we use a uniformly distributed random function
to locate a particular bit in a selected register at each clock
cycle, and then use a second random function to control the
error injection with respect to a given soft error rate. We
evaluated the IRD schemes with two soft error rates of 10−5
(shown as “e-5”) and 10−4 (“e-4”), given the limited sim-
ulation of 100 million instructions. Notice that these again
are accelerated rates for the very rare single-event upsets
(SEUs).
Understanding the error behavior is of critical impor-
tance towards designing a complexity- and cost-effective
(a)
(b)
Figure 6. (a) Write-with-duplicate rate (left bar) and read-with-duplicate rate (right bar) of the in-
register duplication scheme. (b) Performance comparison of various schemes.
reliable system. Table 2 shows the characterization of soft
errors being injected into the register ﬁle system. We clas-
sify the targets of error injection into two groups, active and
inactive register entries. Active registers include registers
in their lifetime of between being written and being freed.
Errors happened in the bypass network or the result bus are
also counted in this group. Errors in active registers once
being readin by later dependent instructions have the poten-
tial to crash the execution or corrupt the memory hierarchy.
On the other hand, inactive registers are free registers and
registers allocated but not written yet. Errors injected into
inactive registers have no impact on the correctness of the
program execution since inactive registers do not contain a
valid value. From Table 2, we ﬁnd that on the average 56%
of the errors happen in the inactive registers and another
44% in the active registers, which are of concern. In some
cases, if an error happens in exactly the same bit position
as some previous instance, the bit error is cleared automat-
ically. We call this self-recovery. The results from Table 2
show that self-recovery is rare.
Erroneous input operands can be either read from the
register ﬁle or retrieved from the bypass network. This ex-
periment tries to identify the contributions of these two er-
ror sources. Notice that erroneous reads are instances of re-
trieved input operands with errors, which are different from
the cumulative bit errors in the input operands. For exam-
ple, an input value with multiple bits ﬂipped due to soft
errors (multiple-bit errors) is only counted as one instance
of erroneous read. Figure 7 (a) shows that the majority of
the erroneous reads, 92% (91%) at soft error rate e-5 (e-4),
on the average, are due to the corrupted value read from
the register ﬁle. The remaining 8% (9%) are due to wire
ﬂips when the value is being forwarded from the bypass net-
work. Thus, the register ﬁle is still the major source of erro-
neous reads. Figure 7 (b) breaks down erroneous reads into
those with single-bit errors and multiple-bit errors. Our re-
sults also show that most readin errors are single-bit errors,
99.7% (99.2%) at this very high error rate e-5 (e-4). This is
because the live time (between writeback and the last read)
of a register value is quite short [10], during which the same
register entry is rarely hit by multiple errors.
7.4. Error Detection and Recovery from
Detected Soft Errors
The in-register duplication (IRD) scheme alone provides
error detection for narrow-width values by comparing the
two 32-bit halves. If the two halves match each other, the
data value is assumed to be correct. Otherwise, the data
is assumed to be corrupted by soft errors. However, this
detection scheme is not applicable to regular values. Once
integrated with parity coding, IRD checks the parity bits for
both 32-bit halves at the ﬁrst stage of execution. If any half
fails this check, erroneous data is detected. This scheme
covers both narrow-width values and regular values. How-
ever, this (even) parity coding scheme is not capable of de-
tecting an even number of bit errors in a 32-bit half. Figure
8 compares the error detection capability of these two op-
tions. Both ﬁgures show results at two error rates, e-5 and
e-4.
In Figure 8 (a), IRD Detected represents the de-
tection rate for narrow-width values using duplicate value
comparison, Fail Detection is for the case where the
error patterns are exactly the same for the upper and lower
halves and this comparison-base detection fails, and Reg-
ular Value represents erroneous reads of regular val-
ues that cannot be detected by this scheme. The results
show that using duplicate value comparison IRD detects all
readin errors in narrow-width values. Figure 8 (b) presents
results for IRD using parity checking. P H Detected
and P F Detected correspond to detected readin errors
in narrow-width values and regular values, and P H Fail
and P F Fail represent undetected readin errors, respec-
tively. IRD using parity checking detects all readin errors in
regular values and only fails less than 0.3% of the time for
narrow-width values.
As discussed in Section 5.3, duplicate value compari-
son and parity checking for both 32-bit halves detect more
readin errors than necessary. Notice that our in-register du-
plication scheme restores the full 64-bit value of a narrow-
width input by only using its lower 32-bit half. This is to
say, that for narrow-width values, the IRD scheme is further
tuned to use the parity checking result of the lower 32-bit
half to detect soft errors and the parity checking of the upper
half to determine whether it can be used to recover the value
once the lower half is detected as error-corrupted. As shown
in Figure 9 (a), using this revised IRD detection scheme,
gzip
vpr