heap
over-
https://sourceforge.
buffer
[11] jasper
1.900.12
assertion-failure
patch
https://github.com/
changelog.
jasper-software/jasper/commit/
d91198abd00fc435a397fe6bad906a4c1748e9cf.
[12] libFuzzer.
html.
https://llvm.org/docs/LibFuzzer.
[13] libtiff 4.0.7 tiff2ps.c:2487 patch changelog. https:
//gitlab.com/libtiff/libtiff/-/commit/
ebf0864306f4f24ac25011cf5d752b94c897faa1.
[14] libtiff
4.0.7
tif_fax3.c:413
patch
changelog.
https://github.com/vadz/libtiff/commit/
9657bbe3cdce4aaa90e07d50c1c70ae52da0ba6a.
3572    30th USENIX Security Symposium
USENIX Association
[15] libtiff
4.0.9
overflow patch
gitlab.com/libtiff/libtiff/-/commit/
9171da596c88e6a2dadcab4a3a89dddd6e1b4655.
pal2rgb.c:196
changelog.
heap-buffer-
https://
[16] Mercurial SCM.
org/.
https://www.mercurial-scm.
[17] Whole program LLVM in Go. https://github.com/
SRI-CSL/gllvm.
[18] yasm 1.3.0 use-after-free patch changelog. https:
//github.com/PeterJohnson/yasm/commit/
25547a595db288cba1e2aac6e3b1fc3e1c72614e.
[19] Cornelius Aschermann, Tommaso Frassetto, Thorsten
Holz, Patrick Jauernig, Ahmad-Reza Sadeghi, and
Daniel Teuchert. NAUTILUS: Fishing for deep bugs
with grammars. In Proceedings of the 26th Network and
Distributed System Security Symposium, 2019.
[20] Tim Blazytko, Cornelius Aschermann, Moritz Schlögel,
Ali Abbasi, Sergej Schumilo, Simon Wörner, and
Thorsten Holz. GRIMOIRE: Synthesizing structure
while fuzzing. In Proceedings of the 28th USENIX Se-
curity Symposium, 2019.
[21] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen,
and Abhik Roychoudhury. Directed greybox fuzzing. In
Proceedings of the ACM SIGSAC Conference on Com-
puter and Communications Security, 2017.
[22] Hongxu Chen, Yinxing Xue, Yuekang Li, Bihuan Chen,
Xiaofei Xie, Xiuheng Wu, and Yang Liu. Hawkeye:
Towards a desired directed grey-box fuzzer. In Proceed-
ings of the ACM SIGSAC Conference on Computer and
Communications Security, 2018.
[23] Peng Chen and Chen Hao. Angora: Efficient fuzzing
by principled search. In Proceedings of the 2018 IEEE
Symposium on Security and Privacy, 2018.
[24] Peter Dinges and Gul Agha. Targeted test input gener-
ation using symbolic-concrete backward execution. In
Proceedings of the 29th ACM/IEEE International Con-
ference on Automated Software Engineering, 2014.
[25] Brendan Dolan-Gavitt, Patrick Hulin, Engin Kirda, Tim
Leek, Andrea Mambretti, Wil Robertson, Frederick Ul-
rich, and Ryan Whelan. LAVA: Large-scale automated
vulnerability addition. In Proceedings of the 2016 IEEE
Symposium on Security and Privacy, 2016.
[27] Brittany Johnson, Yoonki Song, Emerson Murphy-Hill,
and Robert Bowdidge. Why don’t software developers
use static analysis tools to find bugs? In Proceedings
of the 35th International Conference on Software Engi-
neering, 2013.
[28] Chris Lattner and Vikram Adve. LLVM: A compilation
framework for lifelong program analysis & transforma-
tion. In Proceedings of the International Symposium on
Code Generation and Optimization: Feedback-Directed
and Runtime Optimization, 2004.
[29] Hongliang Liang, Lin Jiang, Lu Ai, and Jinyi Wei. Se-
quence directed hybrid fuzzing. In Proceedings of the
IEEE 27th International Conference on Software Analy-
sis, Evolution and Reengineering, 2020.
[30] Hongliang Liang, Yini Zhang, Yue Yu, Zhuosi Xie, and
Lin Jiang. Sequence coverage directed greybox fuzzing.
In Proceedings of the 27th International Conference on
Program Comprehension, 2019.
[31] Kin-Keung Ma, Khoo Yit Phang, Jeffrey S. Foster, and
Michael Hicks. Directed symbolic execution. In Pro-
ceedings of the 10th Static Analysis Symposium, 2003.
[32] Barton P. Miller, Louis Fredriksen, and Bryan So. An
empirical study of the reliability of unix utilities. 1990.
[33] Nicholas Nethercote and Julian Seward. Valgrind: A
framework for heavyweight dynamic binary instrumen-
tation. In Proceedings of the 28th ACM SIGPLAN Con-
ference on Programming Language Design and Imple-
mentation, 2007.
[34] Manh-Dung Nguyen, S’ebastien Bardin, Richard Boni-
chon, Roland Groz, and Matthieu Lemerre. Binary-level
directed fuzzing for use-after-free vulnerabilities. 2020.
[35] Damien Octeau, Somesh Jha, Matthew Dering, Patrick
McDaniel, Alexandre Bartel, Li Li, Jacques Klein, and
Yves Le Traon. Combining static analysis with prob-
abilistic models to enable market-scale android inter-
component analysis. In Proceedings of the 43rd Annual
ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, 2016.
[36] Sebastian Österlund, Kaveh Razavi, Herbert Bos, and
Cristiano Giuffrida. ParmeSan: Sanitizer-guided grey-
box fuzzing. In Proceedings of the 29th USENIX Secu-
rity Symposium, 2020.
[26] Xiaoning Du. Marvel: A generic, scalable and effective
vulnerability detection platform. In Proceedings of the
41st International Conference on Software Engineering:
Companion Proceedings, 2019.
[37] Rohan Padhye, Caroline Lemieux, Koushik Sen, Lau-
rent Simon, and Hayawardh Vijayakumar. FuzzFactory:
Domain-specific fuzzing with waypoints. Proceedings
of the ACM on Programming Languages, 2019.
USENIX Association
30th USENIX Security Symposium    3573
[38] Jiaqi Peng, Feng Li, Bingchang Liu, Lili Xu, Binghong
Liu, Kai Chen, and Wei Huo. 1dVul: Discovering 1-day
vulnerabilities through binary patches. In Proceedings
of the 49th Annual IEEE/IFIP International Conference
on Dependable Systems and Networks, 2019.
[39] Konstantin Serebryany, Derek Bruening, Alexander
Potapenko, and Dmitry Vyukov. AddressSanitizer: A
fast address sanity checker. In Proceedings of the 2012
USENIX Conference on Annual Technical Conference,
2012.
[40] Dongdong She, Kexin Pei, Dave Epstein, Junfeng Yang,
Baishakhi Ray, and Suman Jana. NEUZZ: Efficient
fuzzing with neural program smoothing. In Proceedings
of the 2019 IEEE Symposium on Security and Privacy,
2019.
[41] Evgeniy Stepanov and Konstantin Serebryany. Memo-
rySanitizer: fast detector of uninitialized memory use in
C++. In Proceedings of the 2015 IEEE/ACM Interna-
tional Symposium on Code Generation and Optimiza-
tion, 2015.
[42] Nick Stephens, John Grosen, Christopher Salls, Andrew
Dutcher, Ruoyu Wang, Jacopo Corbetta, Yan Shoshi-
taishvili, Christopher Kruegel, and Giovanni Vigna.
Driller: Augmenting fuzzing through selective symbolic
In Proceedings of the 23rd Network and
execution.
Distributed System Security Symposium, 2016.
[43] Valentin Wüstholz and Maria Christakis. Targeted grey-
box fuzzing with static lookahead analysis. In Proceed-
ings of the 42nd International Conference on Software
Engineering, 2020.
[44] Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang,
Xiaojing Liao, Pan Bian, and Bin Liang. SemFuzz:
Semantics-based automatic generation of proof-of-
concept exploits. In Proceedings of the ACM SIGSAC
Conference on Computer and Communications Security,
2017.
[45] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and
Taesoo Kim. QSYM : A practical concolic execution
engine tailored for hybrid fuzzing. In Proceedings of
the 27th USENIX Security Symposium, 2018.
[46] Michal Zalewski. American Fuzzy Lop: a security ori-
ented fuzzer. http://lcamtuf.coredump.cx/afl/.
[47] Peiyuan Zong, Tao Lv, Dawei Wang, Zizhuang Deng,
Ruigang Liang, and Kai Chen. FuzzGuard: Filtering out
unreachable inputs in directed grey-box fuzzing through
In Proceedings of the 29th USENIX
deep learning.
Security Symposium, 2020.
A Definition of Constraint Language
A.1 Basic Syntax
Figure 12 shows the context-free grammar of the constraint
language. A constraint description (ConstrDesc) consists of
multiple ordered constraints (Constr) enumerated in the re-
quired satisfaction order. A constraint has a head (Constr-
Head) that specifies its name and a body (ConstrBody) that
specifies the target site and the data conditions. A constraint
is considered to be satisfied if the target site is reached and all
data conditions are satisfied in the order of appearance, if any.
A.2 Constraint Body
A constraint body (ConstrBody) specifies a target site (Tar-
getSite) and data conditions (DataCond). Multiple data con-
ditions need to be satisfied in the specified order. Data con-
ditions are optional, so if no data condition is specified, the
constraint is considered to be satisfied when the target site is
reached.
A.2.1 Target Site
A target site (TargetSite) specifies a targeted source location
(Location). It includes the file name followed by the column
and line numbers (String:Int:Int). When reached, the con-
straint captures the variables used by the source-level expres-
sion pointed by the location. The variables may be captured
at a different source location if it is annotated ([Location]).
A target site may specify multiple target source locations
((|| Location)∗). In that case, the target site is considered to be
reached if any one of the source locations is reached. The vari-
ables are not captured if some source locations have different
expression types.
A.2.2 Data Condition
A data condition (DataCond) specifies a condition expression
(ConditionExpr) that must be satisfied at the target site. A data
condition can be declared in two types; cond and assert.
If a data condition is declared as cond, the distance of the
data condition follows the distance derived from the specified
condition. If it is declared as assert, the distance of the data
condition is maxed out unless the condition is satisfied and
has zero distance.
A.3 Condition Expressions
A condition expression (ConditionExpr) represents a boolean
condition in terms of given value expressions. The distance
of a condition expression is zero when it is satisfied, other-
wise follows the operator-specific distance rules (CmpOp).
Condition expressions may be combined with logical oper-
ators (LogicOp), where the distance is calculated based on
3574    30th USENIX Security Symposium
USENIX Association
ConstrDesc → Constr∗
Constr → ConstrHead: ConstrBody
ConstrHead → CONSTRAINT ConstrNameExpr
ConstrNameExpr → %S tring
DataCond → (cond | assert) "ConditionExpr"
ConditionExpr → (ConditionExpr) | none |
ValueExpr CmpOp ValueExpr |
ConditionExpr LogicOp ConditionExpr
ConstrBody → TargetS ite DataCond∗
TargetS ite → site Location (|| Location)∗ |
Location → S tring:Int:Int
Int → -?(0-9)+,
site Location [Location]
Hex → 0x(0-9 | a-f | A-F)+,
ValueExpr → (ValueExpr) | Int | Hex | Variable |
ValueExpr ArithOp ValueExpr
Variable → ConstrNameExpr.VarIdent
VarIdent → value | ret | size | addr | readdr |
endaddr | lhs | rhs | argInt
S tring → (a-z | A-Z | _)(a-z | A-Z | 0-9 | _)∗
ArithOp → + | - | / | *,
CmpOp → == | != | = | >,
LogicOp → && | ||
Figure 12: Context-free grammar of constraint description.
the distances of original expressions. See Appendix B for the
distance definitions.
A.4 Value Expressions
A value expression (ValueExpr) represents an arithmetic value
that can be used with comparison operators. It can be further
manipulated by the arithmetic operators (ArithOp) when it
is evaluated. All values have a canonical 64-bit integer type;
pointers are regard as regular 64-bit integers, and floating-
point values are casted to fixed-point values before captured.
A.4.1 Variable
A variable (Variable) indicates a captured value by the spec-
ified constraint. It consists of a constraint name expression
that specifies the name of the containing constraint (Constr-
NameExpr), and the variable identifier that specifies the value
to be referenced from the constraint (VarIdent).
A variable identifier indicates a variable by its place in the
expression where it has been captured (argInt). For example,
arg0 may be the 0th argument of a call expression or the left-
hand-side operand of a division expression. Some identifiers
are reserved with specific semantic meanings, such as ret
being the return value if the expression is a call expression.
Other reserved identifiers are listed below.
• value indicates the resulting value produced by the ex-
pression, such as the loaded value if the expression is a
dereference expression. This is also an alias of ret.
• addr indicates the dereferenced address if the expression
is a dereference expression.
• size and endaddr indicate the size and the end address
of the allocated memory respectively, if the expression
is the recognizable allocation function, such as malloc.
• readdr indicates the reallocated address if the expres-
sion is the recognizable reallocation function, such as
realloc.
• lhs and rhs indicate the value of left-hand-side and
right-hand-side operands if the expression is a binary
expression.
B Distance of Condition Expressions
B.1 Comparison Operators
The distance of the condition expression n1(cid:50) n2, where n1
and n2 are integers and (cid:50) is a comparsion operator, is cal-
culated based on the absolute difference between n1 and n2.
Specifically, the distance is the absolue difference if it is not
satisfied, or 0 otherwise. The detailed rationales behind the
distance of each comparison operator are as follows.
• The distances of ==, >= and  and = and 
n2 ⇒ n1 >= n2 + 1)
• The distance of != is the distance when it is reformulated
with > and  n2 || n1 < n2)
The formalized distance of each comparison operator is
shown in Table 1.
B.2 Logical Operators
The distance of the condition expression e1(cid:35)e2, where e1 and
e2 are also condition expressions and(cid:35) is a logical operator,
is decided by the rules below.
USENIX Association
30th USENIX Security Symposium    3575
(a) yasm 1.3.0 (Use after free)
(b) nasm 2.14rc0 (Use after free)
(c) libming 0.4.7 (Heap buffer overflow)
Figure 13: Minimum observed seed distance change of three representative programs. ccon and cdata are assumed to 1000 and 100, respectively.
• The distance of && takes the maximum distance of two
condition expressions.
condition expressions.
• The distance of || takes the minimum distance of two
Formally, if e′ is a condition expression where e′ = e1(cid:35) e2
and ˆd(cid:35)(e′) is the distance of e′, ˆd&&(e′) = max( ˆd(e1), ˆd(e2))
and ˆd||(e′) = min( ˆd(e1), ˆd(e2))
C Constraint Generation Algorithm for
Changelogs
Algorithm 1 shows the algorithm to find a proper constraint
with a given patch changelog. Given a set of changed loca-
tions, first it classifies each location with pre-defined cases
described in §5.2. It then takes a set of locations classified as
an earlier case to select target sites and generate data condi-
tions. The algorithm finally ties all selected target sites with a
sentinel function to make them into one target site.
D Analysis on Minimum Distance Change
Figure 13 shows the change of the minimum observed seed
distance during the fuzzing session of three representative
programs in Table 3 and Table 4. To visualize how the mini-
mum observed seed distance changes in various settings, we
select one trial and scale the time dimension to the average
time of its setting. While the distance change is from one trial,
the trends of the distance change were similar in every trial.
To describe the distance change more clearly, we convert the
original seed distance with ccon = 1000 and cdata = 100.
Figure 13a describes the minimum seed distance change of
the yasm 1.3.0 use-after-free crash. AFLGo and CAFL with
1T quickly reach the use location as soon as they begins, but
they are stuck at the use location for a long time, as most of
the seeds bypass the free location. On the other hands, CAFL
with nT attempts to reach the use location after reaching
the free location, and successfully reaches the use location
after 15 minutes. By prioritizing the seeds that reaches both in
Algorithm 1: FindConstraints
Input Ls: Set of changed locations. (pre: pre-patch, post:post-patch)
Output Tuple of a target site and data conditions.
foreach L in Ls do
if IsNewCond(L.post) and BodyContainsExcept(L.post) then
C1Tars ← L
else if AreBothConds(L) and AreNotEqualConds(L) then
C2Tars ← L
else if OneVarChanged(L) then C3Tars ← L
else C4Tars ← L
if not Empty(C1Tars) and AllSameCondExpr(C1Tars.post) then
TSs = GetCondLocs(C1Tars.pre)
DCs = GetConds(C1Tars.post)
else if not Empty(C2Tars) and AllSameCondExpr(C2Tars.pre) and
AllSameCondExpr(C2Tars.post) then
TSs = GetCondLocs(C2Tars.pre), C = GetConds(C2Tars)
DCs = CreateXorCond(C.pre, C.post)
else if not Empty(C3Tars) and AllSameChangedVars(C3Tars) then
TSs = GetChangedVarLocs(C3Tars.pre)
V = GetChangedVar(C3Tars)
DCs = CreateNECond(V.pre, V.post)
else
TSs = C4Tars, DCs = []
TS = TieTargetSites(TSs)
return (TS, DCs)
order, CAFL with nT reproduces the use-after-free crash after
another 17 minutes. nasm 2.14rc0 in Figure 13b exhibits the
similar behavior to yasm 1.3.0, where the crash is reproduced
faster by CAFL with nT even if CAFL with 1T first reaches
the use location.
Figure 13c describes the minimum distance change of
CAFL with three different constraint settings in libming 0.4.7.
1T quickly get zero seed distance by reaching the access loca-
tion, but it does not reproduce the crash as the seeds may not
reach the allocation site, nor satisfy the data conditions. nT
spends around 10 minutes to find the seeds that pass through
both the allocation and access locations, but it waste another
17 minutes at the access location as it does not recognize
the data conditions. nT+D spends about the same time to
reach the allocation site and the access location in order, and
it gradually converges to the solution of the data condition. As
a result, nT+D successfully reproduces the crash only after
another 5 minutes.
3576    30th USENIX Security Symposium
USENIX Association
0100020003000050100150200250Minimum Seed DistanceTime (minutes)CAFL/1TCAFL/2TAFLGo/2T200010000CrashFree locationUse locationnn005001000Minimum Seed DistanceTime (minutes)CAFL/1TCAFL/2T100CrashUse locationn005001000Minimum Seed DistanceTime (minutes)CAFL/1TCAFL/2T100CrashUse site010002000300040005000050100150Minimum Seed DistanceTime (minutes)CAFL/1TCAFL/2TCAFL/2T+D110010000Crash200100~~Alloc. siteAccess loc. w/condAccess loc.nn