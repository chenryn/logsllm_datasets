    https：//waf.party/xss/xss.php？x =
然后在等号之后输入以下代码：
在repeater请求中选择alert(1)，然后启用Hackvertor
BApp，右键单击所选文本，接着单击Hackvertor，然后单击XSS，最后单击throw_eval。这会将标记添加到请求中，如果你点击go，你会看到这样的回复：
如果你想检查它是否实际地在工作，你只需要右键单击请求编辑器并从菜单和Copy
URL中选择Hackvertor，然后在转换所有标签后生成一个URL。如果您使用Burp's copy URL命令，那么这将仅复制带有标记的URL。
## 解码rotN
这一切都源于我的女儿。我从2016年开始穿着一件带有'Sides
Manchester'标记的T恤，前面有一些二进制字符，她问“爸爸这些数字是什么意思？”。我告诉她这是二进制代码，并询问她是否要将它解码。然后我们开始在Hackvertor中输入它们，我注意到一旦二进制字符被解码，它会呈现出一个base64编码的字符串，类似于一个rot编码字符串。我们强制执行了rot编码并对结果进行了解码，但这不禁让我想到，Hackvertor也许可以自动解码一个rot的编码字符串。
它必须从一堆类似于胡言乱语的话当中识别出像英语那样的单词，因此我开始创建一个is_like_english标签，起初我以为可以使用二元语法和三元语法模型，并且只需要在它们后面的的常用字母来确定类似于英语单词那样的词组，但它并不像我想象的那么简单。然后在谷歌搜索后，我找到了一个非常棒的网站。他们使用四元语法模型来表示四个字母序列及其在英语中的使用频率。该网站还有一些简单的python代码，它们可以根据对单词的分析生成一个得分，我用Java重写了代码并在Hackvertor中实现了它。
下一步是改进自动解码器。自动解码器是一种标签，它可以自动尝试确定字符串的编码方式，并且对其进行多次解码。我添加了一个简单的正则表达式，用于查找更多的a-z字符，这些字符后跟这空格、逗号或连字符，然后循环25次以暴力破解rot编码的字符串，并从每个字符串中得到一个分数，我计算它们每个的平均值，如果最佳的分数比平均值多二十，它将自动解码rot编码的字符串。我不会告诉你二进制解码的内容，我会让你自己找出来。这是由Santi模仿的T恤图片。
    01010111 01101101 00110101 01101000 01100011 01001000 01010110 01111001 01011010 01101101 01100100 01111001 01011010 01010011 01000010 01000111 01100101 01101101 00110101 00110101 01100101 01010011 00110001 01000111 01100011 01000111 00110101 00110101 01100011 01101001 01000010 01010011 01100001 00110010 01001110 01111001 01011010 01011000 01011010 00110110 01100011 01101101 01000110 01101110 01100010 01101110 01101011 01100111 01010111 01101101 00110101 01110111 01100100 01011000 01011010 01101000 01100011 01100111 00111101 00111101
James还有一个带有扬声器的衬衫，上面有一些不同的代码，所以我进入了Hackvertor，看看它是否会将它们自动解码。事实证明它是很有效的，你自己可以尝试着将以下内容粘贴到输入框中。
    01011010 01101110 01100001 01110000 01110101 01110010 01100110 01100111 01110010 01100101 00101100 00100000 01100110 01100010 00100000 01111010 01101000 01110000 01110101 00100000 01100111 01100010 00100000 01101110 01100001 01100110 01101010 01110010 01100101 00100000 01110011 01100010 01100101
毋庸置疑，如果自动rotN可以破解任何代码，这将会变得非常有趣。
## 重复密钥以解密XOR
我本来打算结束我的文章，但是James向我发起挑战，要我解码重复加密的XOR。我使用了加密站点Practical
cryptography，并学习了所有关于XOR和频率分析的知识。第一步是确定密钥长度，您可以为每个关键候选项使用频率分析来执行此操作，我将30作为最大密钥长度。我将这些字符存储在频率表中，并在它们在密文中出现时递增它们。当您拥有所有频率时，您可以计算每个列和频率的重合指数(或汉明距离)。一旦得到每个关键候选的重合索引，就取其前七名，并通过除以密钥长度对IC进行统一化，然后用IC对前七名进行排序，并将第一名作为猜测的密钥进行返回。
我花了很多时间来尝试提高关键猜测的准确性，并且多次重写了代码。Trusted signal
blog博客证实，你可以通过使用前5-6个候选结果当中的最大公分母来提高确定的键长的准确性，但是在我的测试中，我无法提高准确性。无论如何，一旦你有了密钥长度，您只需通过循环密文和每个字符，然后根据结果为其分配一个分数即可。我将大部分代码建立在Alexey
Hellman 的cool python utility中。
最后，无论转换成功与否，我将重新使用我的is_like_english函数来确定文本的分数。这适用于小块文本，更大的文本就不行了，这是因为你输入越多的文本，你获得的ngram分数就会越低，所以我将固定值更改为平均差值的一个百分比，这样无论密文长度如何都可以起作用。对于非常小的密文，XOR解密将会失败，我认为这是因为没有足够的密文来执行频率分析，从而正确地确定解密的每个字符的密钥长度和分数。如果您想到了一种改进方法，您可以向我们提交您的想法。
为了演示自动解码，我用一个密钥进行了XOR，然后对其进行了十六进制编码。当您在输入框中输入时，Hackvertor将自动解码十六进制，预估密钥长度，然后自动解密XOR加密，甚至提供正确的标签来再现编码。
    1C090C1E05041C101C523D296324212F000D020C04061D001C216F36383668231619064521010606376F3724732E080D0F561617171A003B3B3A6B3630110C18031717074F1037292C39366808174C0545061B00523E2E372E7D68231A4B03161B1A0852313A373F3A26064E0E120217541C1133212D223D2F41170E150D1C1B031D35366F6B2A27144308170B521D0B173C3B2A2D2A68150B0E5613170616523E2E372E203C41151E1A0B17060E103B232A3F3A2D124D4B391000541D17212A22393020041118560300111E07372137272A68140D08191317064F10202E2D2F732604144B00101E1A0A00332D2A273A3C1843081A0401070A01723B2B2A276823161906451B074F063A2A632D3A3A12174B020A52060A023D3D3765
重复的XOR时不时会被使用，所以希望这个功能能够防止某些应用程序逃脱看似合法的加密。
    原文地址：
    https://www.zerodayinitiative.com/blog/2018/9/27/cve-2018-15421-examining-a-stack-based-overflow-in-the-cisco-webex-network-recording-player
    https://portswigger.net/blog/bypassing-wafs-and-cracking-xor-with-hackvertor