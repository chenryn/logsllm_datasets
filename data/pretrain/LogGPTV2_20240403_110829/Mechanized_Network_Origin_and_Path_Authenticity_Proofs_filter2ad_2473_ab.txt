sonable model as our attackers represent malicious network nodes
(e.g., ISPs).
2.2.2 Key Setup (DRKey Protocol)
The key setup protocol of the OPT protocol is called Dynami-
cally Recreatable Key (DRKey) protocol. The pseudo code of the
DRKey protocol is listed in Figure 1. We write S to denote the
source node and D to denote the destination node. The source
fverify(path, keysigs, pk, pk−1 , dir) =
match (path, keysigs) with (), () ⇒ ret()
| (path(cid:48), rt), (keysigs(cid:48), (c, sig)) ⇒
k = dec(c, pk−1 );
verify(sig, (k , pk , dir), pk(rt));
keys = fverify(path(cid:48), keysigs(cid:48), pk, pk−1 , dir);
ret(k , keys)
| _ ⇒ stuck
source() =
(D, pkS , pkS −1 , pkD, path) = pickSession();
send(S , D, pkS , pkD, path, (), ());
keysigsS = recv;
keysS = fverify((path, D), keysigsS, pkS, pkS −1 , upstream);
acceptS(self, D, path, keysS, pkS)
dest() =
(S , D, pkS , pkD, path, keysigsS , keysigsD) = recv;
(path(cid:48), S (cid:48), pkS (cid:48), pkD−1 ) = lookupSession(pkD, self);
if path(cid:48) = path && pkS = pkS (cid:48) && S = S (cid:48)
then keysD = fverify(path, keysigsD, pkD,
pkD−1 , downstream);
acceptD(S, self, path, keysD, pkD);
kS = prf(SVS(self), hash(pkS));
ckS = enc(kS, pkS);
sigS = sign((kS , pkS , upstream), pk−1(self));
send((keysigsS, (ckS, sigS)))
router() =
(S , D, pkS , pkD, path, keysigsS , keysigsD) = recv;
kS = prf(SVS(self), hash(pkS));
ckS = enc(kS, pkS);
sigS = sign((kS , pkS , upstream), pk−1(self));
kD = prf(SVD(self), hash(pkD));
ckD = enc(kD, pkD);
sigD = sign((kD, pkD, downstream), pk−1(self));
send(S, D, pkS, pkD, path,
(keysigsS, (kS,sigS)), (keysigsD, (kD, sigD)))
Figure 1: Key setup.
could choose different paths to send packets to the destination. To
distinguish between these paths, the protocol uses the notion of ses-
sions. For each session, the source chooses a path to forward pack-
ets along and generates a public-private key pair (pkS, pkS −1 );
and the destination generates the pair (pkD, pkD−1 ). pkS −1 and
pkD−1 are kept secret. Subsequently, pkS and pkD are used to
generate the symmetric keys between the source and each router,
and between the destination and each router, respectively.
Each session is uniquely identiﬁed by the tuple (S, D, pkS, pkD,
path ). The source and the destination exchange pkS and pkD at
the beginning of the key setup phase by exchanging signatures of
relevant ﬁelds of the session tuple using their long-term key pairs.
The source continues the key setup phase by sending the session
tuple to the ﬁrst router on the intended path. When the router re-
ceives the packet, it generates a symmetric key (kS) for the source
and a symmetric key (kD) for the destination as follows.
kS = prf(SVS(self), hash(pkS ))
kD = prf(SVD(self), hash(pkD))
Here, “self” refers to the identity of the principal that runs this pro-
gram. Each router R has two local secrets, SVS(R) and SVD(R).
The former is used to compute the symmetric key shared with the
source and the latter the key shared with the destination. We write
prf to denote pseudo random functions. The advantage of gener-
ating keys in this manner is that routers do not need to store these
keys, as they can be efﬁciently recomputed on the ﬂy, assuming
that pkS and pkD are contained in each packet header.
The router then encrypts the keys using the session public keys
of the source and the destination, pkS and pkD, respectively, and
signs the keys to attest to their authenticity. The router signs two
triples: (kS, pkS, upstream) and (kD, pkD, downstream), where
downstream and upstream indicate for whom the key is intended
(i.e., upstream for the source, and downstream for the destina-
tion). The router appends the pair of the encrypted key and sig-
nature to the list of key and signature pairs already in the packet
header and sends the packet to the next router.
When the destination receives a packet, it ﬁrst checks that the
session information (the source, the path, and source’s session pub-
lic key) contained in the packet is valid. Then, it decrypts the keys
and veriﬁes the signatures of the keys. If the veriﬁcation succeeds,
the destination accepts all the keys in the packet denoted keysD.
The destination then generates a symmetric key for the source and
sends to the source the pair of the encryption and signature of this
key (kS, sigS), together with the encryption and signature pairs
generated by routers. Similarly, the source only accepts the keys
after successfully verifying all the signatures in keysigsS.
2.2.3 Forwarding
A code snippet of the forwarding protocol is presented in Fig-
ure 2. There are three main data structures: (1) PVFS (path valida-
tion ﬁeld for the source), (2) OPV (origin and path validation ﬁeld
for the routers), and (3) PVFD (origin and path validation ﬁeld for
the destination). Each data structure is indexed with a natural num-
ber i corresponding to its position on the intended path. Given a
path R1, R2,..., Rn, we write KSi to denote the symmetric key that
the source and router Ri have shared during key setup. We write
KD to denote the symmetric key that the source and the destination
share. We write KDi to denote the symmetric key that the destina-
tion and router Ri share. Validation ﬁelds are computed as follows.
PVFS0 = mac(KD, (hash(pkt)))
PVFSi = mac(KSi, (PVFSi−1))
OPVi
PVFD0 = PVFS0
PVFDi = mac(KDi, (PVFDi−1, Ri−1, hash(pkt)))
= mac(KSi, (PVFSi−1, Ri−1, hash(pkt)))
The source S computes PVFS0, PVFD0, and all the OPVi
ﬁelds, and includes them in the packet header. The recursive func-
tion compPvfOpvs (on the 3rd line) uses the keys shared between
the source and the routers to compute the OPVi and PVFSi ﬁelds.
S sends a packet that includes in its header: S, D, path , the hash
of the source public key (hash(pkS )), the hash of the destination
public key (hash(pkD)), PVFS0, PVFD0, the list of OPVi for all
routers on the path (opvs), and the payload of the packet pkt.
When router Ri receives a packet, it ﬁrst recomputes the sym-
metric keys based on the key hash ﬁelds in the header as follows:
KSi = prf(SVS(Ri), kSh), and KDi = prf(SVD(Ri), kDh). Then
Ri computes its orgin path veriﬁcation ﬁeld opv: opv = mac(KSi,
(pvfS, R, hash(pkt))), where pvfS is the path validation ﬁeld in
the header and R is the preceding router.
Ri only accepts the packet if opv is the same as the origin path
validation ﬁeld included in the header. Finally, Ri computes PVFSi
and PVFDi using the pvfS and pvfD ﬁelds and sends out the
packet with updated pvfS (cid:48) and pvfD(cid:48).
When the destination receives a packet, it searches its local state
and ﬁnds the keys shared with the routers and the source, based
source() =
(pkt, pkS, pkD, D, path, keys, kD) = pick;
pvf0 = mac(kD, hash(pkt));
(pvfS , opvs) = compPvfOpvs(path, keys, pkt, self, pvf0 );
send(self, D, path, hash(pkS), hash(pkD),
pvf0 , pvf0 , opvs, pkt)
router() =
R = pickNeighbor;
(S, D, path , kSh, kDh, pvfS, pvfD, opvs, pkt) = recvFrom(R);
fCkVrf (opvs, mac((prf(SVS(self), kSh)), (pvfS, R, hash(pkt)));
acceptRt(pkt, pvfS, R, kSh);
pvfS (cid:48) = mac((prf(SVS(self), kSh)), pvfS);
pvfD(cid:48) = mac((prf(SVD(self), kDh)), (pvfD, R, hash(pkt)));
send(S, D, path , kSh, kDh, pvfS (cid:48), pvfD(cid:48), opvs, pkt)
dest() =
R = pickNeighbor
(S, D(cid:48), path(cid:48), kSh, kDh, pvfS, pvfD, opvs, pkt) = recvFrom(R);
keys = SessionlookUp(S, self, kSh, kDh, path(cid:48));
(pvfD(cid:48), _) = fCkPvfD(pkt, mac(prf(SVS(self), kSh), hash(pkt)),
If self = D(cid:48) && path(cid:48) = (path 1,R) && pvfD = pvfD(cid:48)
then acceptDst(S, path , keys, pkt, pvfD, kSh, kDh,
keys, path(cid:48), S);
(prf(SVS(self), kSh));
else stuck
Figure 2: Code snippet for origin and path validation.
on the path, the source, and the hashes of the public keys in the
packet. The destination computes PVFDn based on the path, the
hash of the payload, and the list of keys using a recursive function
fCkPvfD. The destination accepts the packet only if the computed
PVFDn is the same as the one in the packet header.
3. ENCODING OF LS2 AND PCL
We now present the encoding of LS2 and deﬁnitions and axioms
speciﬁc to analyzing protocols.
3.1 Shallow Embedding of LS2
LS2 inference rules derive invariant and partial correctness prop-
erties of a program that interacts with adversaries. There are two
approaches to encode LS2 in Coq. One is to deﬁne all constructs
of LS2 in Coq, and the other is via shallow-embedding, which uses
much of Coq’s logical reasoning capability directly and places LS2-
speciﬁc reasoning rules in a monad. The main advantage of the
latter is that many of Coq’s built-in libraries and automation tech-
niques can be straightforwardly applied, and thus eases the pro-
cess of constructing LS2 proofs. One drawback is that the proof of
the soundness of LS2 cannot itself be encoded using this encoding
scheme. However, this aspect is beyond the scope of this paper. The
soundness of LS2 has been proven manually by Garg et al. [23].
ST monad. LS2 has four kinds of judgments: assertions about
invariant properties of a program, assertions about partial correct-
ness properties of a program, assertions about invariant properties
of threads that remain idle (i.e., do not perform any actions such as
sending, or signing messages), and ﬁrst-order logic inference rules.
Rules for the ﬁrst three are encoded in Coq using a monad. For the
fourth, we directly use Coq’s ﬁrst-order reasoning rules.
A state monad, denoted ST P Q, speciﬁes properties of a pro-
gram, where P is the invariant property and Q is the partial cor-
rectness property. Core deﬁnitions of the ST monad are shown in
Figure 3. First we deﬁne the type tprop, which takes a thread ID
and a beginning and an ending time point as arguments and returns
a Coq proposition. tprop is the basic building block for specify-
ing the trace properties of programs. An invariant property has
type Inv, which is precisely tprop. The partial correctness type,
denoted Pc, takes as an additional argument the type of the return
value of a program. A program e has type ST (fun i ub ue ⇒
ϕ1) (fun (x : A) i ub ue ⇒ ϕ2), if any trace containing unﬁn-
ished execution of e by thread I between time UB and UE satisﬁes
ϕ1[UB, UE, I/ub, ue, i], and any trace containing completed ex-
ecution of e by thread I between time UB and UE satisﬁes the
formula ϕ2[UB, UE, I, v/ub, ue, i, x] provided that e returns v at
time UE.
Assertions for silent threads are encoded using the type Silent.
A proof of the type Silent (fun i ub ue ⇒ ϕ) means that formula
ϕ[UB, UE, I/ub, ue, i] is true on any trace where thread I idles be-
tween time UB and UE. The silent assertions are needed because in
a distributed system threads execute interleavingly and are allowed
to idle while other threads make progress.
STReturn is the assertion for the return statement. The invariant
property states that before the return, the thread is idle. The par-
tial correctness property states that this thread doesn’t perform any
actions while this return statement is being evaluated, and that the
value being returned is v. STWeakening weakens trace properties.
Both the invariant and partial correctness properties of program e
can be weakened, as long as proofs can be constructed to show that
the resulting properties are logically implied by the original proper-
ties. STBind is the assertion for sequencing statements. The partial
correctness of a sequencing statement is the conjunction of the par-
tial correctness properties of both statements, since the trace con-
taining the complete execution of the sequence contains the com-
plete execution of both statements. The invariant property is the
disjunction of three cases: the program is idle, the ﬁrst statement
has not ﬁnished, and the ﬁrst one ﬁnished but the second one has
not. We use STFix to encode a ﬁxed point function. Finally, we use
the following syntactic sugar for ease of presentation: x ← c1; c2
for sequencing and {{{c}}} for weakening.
Protocols are encoded using these monads. Each instruction is
encoded as a ST monad specifying its properties. These instruc-
tions are then sequentially composed using STBind. For instance,
the following is the encoding of a fragment of the destination’s key
setup program that encrypts and signs the key shared between the
destination and the source, and sends the list of keys to the source.
ckS ← STAsymEnc (symkeyToMsg (msgToSymKey keyS)) pks;
sigS ← STSign (pair (prinToMsg upstream)
(pair (symkeyToMsg (msgToSymKey keyS))
(sk p);
(pkeyToMsg pks)))
x ← STSend (pair keysigsS (pair ckS sigS));
STReturn unitMsg