## Page 87
过写成下面这样来得到预想的行为：
另一个特殊操作符PROGN可以按顺序执行任意数量的形式并返回最后一个形式的值。因此可以通
在将其标记为垃圾的同时更新垃圾数据库，那么你不能这样写：
一些语法形式进行封装。举个例子，假如在一个垃圾过滤程序中，当一个消息是垃圾时，你想要
限制必须是单一的Lisp形式。这意味着如果想在每个子句中执行一系列操作，则必须将其用其他
返回NIL。
有else-form，它将被求值并返回其结果。如果condition是NIL并且没有else-form，那么IF
那么执行y；否则执行z。
7.1
功用。
使用它们时，你不必在意它们是作为宏实现的，尽管如此，它们的确可以很好地展示出宏的一些
讨论，既而缓慢进入该主题。它们都是那些如果Lisp没有宏，就必须构造在语言核心里的东西。
因。为了避免触发任何宏恐惧症反应，我们将从CommonLisp所定义的几种标准控制构造宏开始
多半是来自学习其他“宏”系统时的不良经历。简单地对未知事物的恐惧无疑也是其中一部分原
义类的层次体系，却被这种可以定义新的句法抽象的思想给吓到了。通常，这种宏恐惧症的原因
有实际使用过Lisp宏的人，他们可以为了解决编程问题而日复一日地去创建新的函数型抽象或定
解决方案的语言。
那么，利用另一种方式来拓展语言的好处似乎是显而易见的。但出于某些原因，对于大量没
70
①另一个重要的用宏来定义的语言构造类别是所有的定义性构造，诸如DEFUN、DEFPARAMETER以及DEFVAR。
(if (spam-p current-message)
尽管如此，IF事实上并不是什么伟大的句法构造，因为每个then-form和else-form都被
condition被求值，.如果其值非NL，那么then-form会被求值并返回其结果。否则，如果
如前所述，最基本的条件执行形式是由IF特殊操作符提供的，其基本形式是：如果x成立，
(if condition then-form [else-form])
在第24章里你将定义自己的定义性宏，从而可以简洁地编写可以用来读写二进制数据的代码。
WHEN 和 UNLESS
、“下一章将说明如何定义你自己的宏。
(progn
(file-in-spam-folder current-message)
(>
第7章宏：标准控制构造
(update-spam-database current-message)))
(file-in-spam-folder current-message)
m
2
adoN←(uadoNdn(E
"dn←（doNdn
"Yup")
→NIL
www.TopSage.com
---
## Page 88
不太好看。
否则如果b成立那么执行y；否则执行z。只用IF来写这样的条件表达式链并没有逻辑问题，只是
何被更大规模地用于创建完整的特定领域的嵌人式语言。首先来介绍一下标准控制构造宏。
宏来获得小而重要的清晰性，并随后通过不断地使用而无限放大。第24、26和31章将展现宏是如
重要的观点：由于宏系统是直接构建在语言之中的，所以可以写出像WHEN和UNLESS这样简单的
层面约定俗成的细节，从而允许你更加清晰地表达你的真实意图。它们的极度简单性产生了一个
体。换句话说：
了第3章中讨论过的反引号：?
你写成这样：
所组成的模式，并且希望可以有一种方式来抽象所有细节而不是每次都将它们写出来。
为真时，做这个、那个以及其他-些事情’？”换句话说，你很快将注意到这种由IF加上PROGN
厌倦它。你可能会自问：“为什么Lisp没有提供一种方式来做我真正想做的事，也就是说，‘当x
这正是宏所能够提供的功能。在这个案例中，Common Lisp提供了一个标准宏wHEN，可以让
① 其实不能将这个定义输人到Lisp中，因为重定义WHEN所在的COMMON-LISP包中的名字是非法的。如果你真想写
必须承认，这些都是相当简单的宏。这里没有什么高深的道理，它们只是抽象掉了一些语言
如果需要在then子句中包括多个形式，那就需要用到PROGN，而那样事情就会变得更糟。因
当遇到多重分支的条件语句时，原始的IF表达式再一次变得丑陋不堪:如果a成立那么执行x,
如果它没有被内置到标准库中，你也可以像下面这样用一个宏来自己定义WHEN，这里用到
(if a
(defmacro unless (condition &rest body)
与WHEN宏同系列的另一个宏是UNLESS，
(when (spam-p current-message)
这样做并不算太坏。但假如不得不多次使用这样的写法，不难想象你将在一段时间以后开始
出这样一个宏，则需要改变名字，例如my-when。
^(if ,condition (progn ,@body)))
(update-spam-database current-message))
COND
(if (not ,condition) (progn ,@body)))
(file-in-spam-folder current-message)
(if b
(do-x)
(do-z)）)
(do-y)
www.TopSage.com
，它取相反的条件，只有当条件为假时才求值其形式
7.2
COND
7
---
## Page 89
还是一门关于宏所提供的“鱼和熊掌兼得”的编程风格的有趣课程。
7.4循环
返回NIL。下面是一些例子：
表达式求值到非NIL，它就立即停止并返回当前子表达式的值。如果没有子表达式求值到真，OR
有子表达式都求值到非NIL，那么它将返回最后一个子表达式的值。而对于OR来说，只要一个子
表达式进行求值。这样，只要AND的一个子表达式求值为NIL，它就立即停止并返回NIL。如果所
便支持“短路”特性。也就是说，它们仅以从左到右的顺序对用于检测整体真值的必要数量的子
数并对其真值取反，当参数为NIL时返回T，否则返回NIL。
操作符AND、OR和NOT。
7.3AND、OR 和 NOT
以像下面这样用COND来写出前面的嵌套IF表达式：
写成带有条件T。虽然任何非NIL的值都可以使用，但在阅读代码时，T标记确实有用。这样就可
将返回该条件形式的值。习惯上，那个用来表示if/else-if链中最后一个else子句的分支将被
个形式的值将作为整个COND的返回值。如果该分支在条件形式之后不再含有其他形式，那么就
依次求值，直到它们中的一个求值为真。这时，该分支中的其余形式将被求值，且分支中最后一
以及零或多个当该分支被选择时将被求值的形式。这些条件形式按照分支在主体中出现的顺序被
AND和OR则是宏。它们实现了对任意数量子表达式的逻辑合取和析取操作，并被定义成宏以
严格来讲，NOT这个函数并不属于本章讨论范畴，但它跟AND和OR紧密相关。它接受单一参
72
循环构造是另外一类主要的控制构造。Common Lisp的循环机制，除了更加强大和灵活以外，
在使用IF、WHEN、UNLESS和COND形式编写条件语句时，经常用到的三个操作符是布尔逻辑
初看起来，Lisp的25个特殊操作符中没有一个能够直接支持结构化循环，所有的Lisp循环控
主体中的每个元素都代表一个条件分支，并由一个列表所构成，列表中含有一个条件形式，
（or(=12)(=33))
(not nil)
(cond (a (do-x))
(cond
(test-N form*})
(test-1 form*)
第7章宏：标准控制构造
.1）)
(do-z)))
(do-y)）
(= 3 3))
→
NIL
www.TopSage.com
---
## Page 90
在这种方式下，
值一次，同时用变量var保存当前项的值。例如：
行循环体。?下面是其基本形式（去掉了一些比较难懂的选项)：
7.5
无论你倾向于哪一方，LOOP本身都是为语言增加新构造的宏展示其强大威力的突出示例。
它用了一种简洁的方式来表达特定的常用循环构造。而贬低者们不喜欢它则是因为它不太像Lisp。
的语言来表达循环构造。一些Lisp黑客热爱LoOP，其他人则讨厌它。LOOP爱好者们喜欢它是因为
造
那样，对于那些DOLIST和DOTIMES无法满足需要的情形，还可以在DO之上构建自定义的循环构
造，而DOLIST和DOTIMES则提供了两种易用却不那么通用的构造。并且如同在下一章将看到的
因此，在由CommonLisp特殊操作符所提供的底层原语之上，Do提供了一种基本的结构化循环构
持。尽管一个实现可以用任何方式来实现这些宏，但它们被典型实现为展开到等价Do循环的宏。
和DOTIMES。它们不像DO那样灵活，却提供了对于常见的在列表元素上循环和计数循环的便利支
他的通用抽象一样，在应用于简单情形时显得过于复杂。因此Lisp还提供了另外两个宏，DOLIST
Lisp的循环宏构建在以那两个特殊操作符为基础的一组分层抽象之上。OD
制构造都是构建在一对提供原生goto机制的特殊操作符之上的宏。°和许多好的抽象或句法一样，
底层（不考虑特殊操作符）是一个非常通用的循环构造DO。尽管非常强大，但Do和许多其
①为了满足你的好奇心，这两个特殊操作符是TAGBODY和GO。现在无需讨论它们，第20章会介绍它们。
当循环开始时，1ist-form被求值一次以产生一个列表。然后循环体在列表的每一项上求
(dolist(var list-form)
DOLIST在一个列表的元素上循环操作，使用一个依次持有列表中所有后继元素的变量来执
最后，LooP宏提供了一种成熟的微型语言，它用一种非Lisp的类似英语（或至少类似Algol)
NIL
CL-USER>（dolist（x'（123））（printx））
先从易于使用的DOLIST和DOTIMES宏开始。
一个CommonLisp程序员在五分钟里可以自行解决的麻烦问题却会困扰Java程序员几年时间。
个新版本的Java，他们也仍然可能无法使用这个新特性，直到被允许打破与旧版本Java的源代码级兼容性。因此，
之后，所有的编译器作者都将升级其编译器以支持新的特性，并且就算那个Java程序员所喜爱的编译器支持了这
后Sun将会发布一个JSR并组织一个业界专家组来推敲其细节。按照Sun的说法，这一过程平均耗时18个月。在那
式的源代码级抽象。一个注意到同样模式的Java程序员只能建议Sun说，这种特定的抽象值得添加到语言之中，然
强型循环构造。注意到宏所带来的区别：一个注意到代码中常见模式的Lisp程序员可以写出一个宏来获得对该模
body-form*)
DOLIST和DOTIMES
DOLIST这种形式本身求值为NIL。
www.TopSage.com
7.5DOLIST和DOTIMES
---
## Page 91
并可以提供一个形式，在循环结束时进行求值来为DO表达式整体生成一个返回值。基本模板如下
都不能满足需求，那还可以用更通用的Do循环。
行循环多个变量该怎样做？要是使用任意表达式来测试循环的末尾呢？如果DOLIST和DOTIMES
7.6DO
义的完整形式是一个含有三个元素的列表。
所示。
并且变量值在每次循环中的改变方式也是完全可控的也可以定义测试条件来决定何时终止循环
例如，为了打印出从1×1=1到20×20=400的乘法表，可以写出下面这对嵌套的DOTIMES循环：
和DOLIST一样，也可以使用RETURN来提前中断循环。
那个数小1的每一个后继整数。例如：
其中的count-form必须要能求值为一个整数。通过每次循环，var所持有的整数依次为从0到比
由于DOLIST和DOTIMES的循环体中可以包含任何类型的表达式，因此也可以使用嵌套循环。
74
每一个variable-definition引l入了一个将存在于循环体作用域之内的变量。单一变量定
(do (variable-definition*)
尽管DOLIST和DOTIMES方便且易于使用，却没有灵活到可用于所有循环。例如，如果想并
(dotimes (x 20)
NIL
CL-USER> (dotimes (i 4) (print i))
DOTIMES是用于循环计数的高级循环构造，其基本模板和DOLIST非常相似。
(var init-form step-form)
NIL
CL-USER> (dolist (x‘(1 2 3))(print x) (if (evenp x) (return)))
如果想在列表结束之前中断一个DOLIST循环，则可以使用RETURN。
statement*)
body-form*)
(dotimes (var count-form)
(dotimes (y 20)
(end-test-form result-form*)
(format t
第7章宏：标准控制构造
"~3d "{*(1+ x）(1+y)}))
www.TopSage.com
---
## Page 92
来写这个循环会更简单。
将总是一致的。下面是一些框架用黑体表示的Do循环的例子。
号，例如变量定义总是以列表形式存在，而测试形式则通常是一个函数调用。不过Do循环的框架
测试形式和结果形式，以及一对用来围住整个表达式。DO中的其他形式可能需要它们自己的括
达式的最佳方式是记住其基本模板：
这种灵活性正是DO表达式有点儿嗨涩难懂的原因。所有这些括号都该放在哪里？理解一个DO表
个循环体。其他时候，尤其在只是把循环用作控制构造时，则可能会省略结果形式。尽管如此，
是一种计算第11个斐波那契数的特别有效的方式。）
长形式都被求值以后，这些变量才被指定其新的值。（有数学天赋的读者可能会注意到，这其实
其步长形式(1+n）、next和（+cur next)均使用n、cur和next的旧值来求值。只有当所有步
这意味着可以在步长形式里引用其他任何循环变量。“比如在下列循环中。
式的值将被作为DO表达式的值返回。
值为NIL，迭代过程就会继续，依次求值所有的statement。
是，你可以将一个只含有名字的列表简化成一个简单的变量名来使用。
变量定义一样，如果init-form没有给出，那么变量将被绑定到NIL。另外和LET的情形一样的
出，那么变量将在迭代过程中保持其值不变，除非在循环体中显式地为其赋予新值。和LET中的