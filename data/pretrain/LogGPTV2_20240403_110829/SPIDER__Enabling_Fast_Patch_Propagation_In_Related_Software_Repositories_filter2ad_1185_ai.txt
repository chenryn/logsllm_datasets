以下是经过优化后的文本，使其更加清晰、连贯和专业：

---

### 参考文献

[64] S. Raghavan, R. Rohana, et al. Dex: 一种用于研究大型代码库变更的语义图差异工具. IEEE 软件维护国际会议 (ICSME). 2004.

[65] S. Rastkar 和 G. C. Murphy. 为什么这段代码发生了变更? 国际软件工程大会 (ICSE) 会议记录. 2013.

[66] B. Ray 和 M. Kim. 分叉项目中跨系统移植的案例研究. 基础软件工程联合会议 (FSE) 会议记录. 2012.

[67] E. Raymond. 大教堂与集市. 知识、技术与政策, 12(3): 23–49, 1999.

[68] E. Rescorla. 安全漏洞... 谁在乎? USENIX 安全研讨会 (SEC) 会议记录. 2003.

[69] E. A. Santos 和 A. Hindle. 从提交信息熵推断 Travis-CI 的构建状态. 国际软件仓库挖掘大会 (MSR) 会议记录. 2016.

[70] G. Schryen. 开源与闭源软件的安全性: 已发布漏洞的经验比较. 美洲信息系统会议 (AMCIS) 会议记录. 2009.

[71] S. Son, K. S. McKinley, et al. 修复 Web 应用程序中的访问控制漏洞. ISOC 网络与分布式系统安全研讨会 (NDSS) 会议记录. 2013.

[72] Y. Tao, Y. Dang, et al. 软件工程师如何理解代码变更? 一个工业界的探索性研究. 基础软件工程联合会议 (FSE) 会议记录. 2012.

[73] Y. Tian 和 B. Ray. 自动诊断和修复 C 语言中的错误处理漏洞. 基础软件工程联合会议 (FSE) 会议记录. 2017.

[74] D. Votipka, R. Stevens, et al. 黑客 vs 测试人员: 软件漏洞发现过程的比较. IEEE 安全与隐私研讨会 (SP) 会议记录. 2018.

[75] P. Wadler. 函数式编程的本质. ACM 编程语言原理研讨会 (POPL) 会议记录. 1992.

[76] R. Wu, H. Zhang, et al. Relink: 恢复 Bug 与变更之间的链接. 基础软件工程联合会议 (FSE) 会议记录. 2011.

[77] F. Yamaguchi, N. Golde, et al. 使用代码属性图建模和发现漏洞. IEEE 安全与隐私研讨会 (SP) 会议记录. 2014.

[78] T. Zhang, M. Song, et al. 针对系统变更的交互式代码审查. 国际软件工程大会 (ICSE) 会议记录. 2015.

[79] Y. Zhou 和 A. Sharma. 从提交信息和 Bug 报告中自动识别安全问题. 基础软件工程联合会议 (FSE) 会议记录. 2017.

[33] R. Clarke, D. Dorwin, et al. 开源软件是否更安全? 国土安全/网络安全, 2009.

[34] L. De Moura 和 N. Bjørner. Z3: 一个高效的 SMT 求解器. 国际工具和算法构造及分析系统会议 (TACAS) 会议记录. 2008.

[35] J.-R. Falleri, F. Morandat, et al. 细粒度且准确的源代码差异. ACM 国际自动化软件工程会议 (ASE) 会议记录. 2014.

[36] J. Ferrante, K. J. Ottenstein, et al. 程序依赖图及其在优化中的应用. ACM 编程语言与系统事务 (TOPLAS), 1987.

[37] D. Gao, M. K. Reiter, et al. Binhunt: 自动查找二进制程序中的语义差异. 国际信息与通信安全会议 (ICICS) 会议记录. 2008.

[38] E. Giger, M. Pinzger, et al. 比较细粒度源代码变更和代码变动以进行 Bug 预测. 国际软件仓库挖掘大会 (MSR) 会议记录. 2011.

[39] A. E. Hassan. 软件仓库挖掘的未来之路. IEEE 国际软件维护会议 (FOSM) 会议记录. 2008.

[40] Z. Huang, D. Lie, et al. 使用安全属性生成漏洞补丁. IEEE 安全与隐私研讨会 (SP) 会议记录. 2019.

[41] J. Jang, A. Agrawal, et al. Redebug: 在整个操作系统发行版中查找未修补的代码克隆. IEEE 安全与隐私研讨会 (SP) 会议记录. 2012.

[42] Y. Kang, B. Ray, et al. Apex: 自动推断 C API 的错误规范. 基础软件工程联合会议 (FSE) 会议记录. 2016.

[43] P. Kreutzer, G. Dotzler, et al. 自动聚类代码变更. 国际软件仓库挖掘大会 (MSR) 会议记录. 2016.

[44] S. K. Lahiri, C. Hawblitzel, et al. Symdiff: 一种针对命令式程序的语言无关语义差异工具. 国际计算机辅助验证会议 (CAV) 会议记录. 2012.

[45] S. K. Lahiri, K. Vaswani, et al. 差分静态分析: 机遇、应用和挑战. FSE/SDP 未来软件工程研究研讨会 (FoSER) 会议记录. 2010.

[46] W. Landi. 静态分析的不可判定性. ACM 编程语言与系统事务 (LOPLAS), 1(4): 323–337, 1992.

[47] C. Lattner. LLVM 和 Clang: 新一代编译器技术. BSD 会议, 第 1-2 页. 2008.

[48] F. Li 和 V. Paxson. 安全补丁的大规模实证研究. ACM 计算机与通信安全会议 (CCS) 会议记录. 2017.

[49] H. Li, H. Kwon, et al. 基于安全补丁的可扩展漏洞发现方法. 国际信息安全应用和技术会议 (ATIS) 会议记录. 2014.

[50] Z. Li, D. Zou, et al. Vulpecker: 基于代码相似性分析的自动漏洞检测系统. 年度计算机安全应用会议 (ACSAC) 会议记录. 2016.

[51] F. Long, P. Amidon, et al. 自动推断代码转换和搜索空间以实现自动补丁生成系统. 基础软件工程联合会议 (FSE) 会议记录. 2017.

[52] P. D. Marinescu 和 C. Cadar. Katch: 高覆盖率测试软件补丁. 基础软件工程联合会议 (FSE) 会议记录. 2013.

[53] M. A. McQueen, T. A. McQueen, et al. 0day 漏洞的经验估计和观察. 夏威夷国际系统科学会议 (HICSS) 会议记录. 2009.

[54] N. Meng, M. Kim, et al. 系统化编辑: 从示例生成程序转换. ACM SIGPLAN 通知, 46(6): 329–342, 2011.

[55] M. Monperrus. 自动软件修复: 书目. 里尔大学, 技术报告 hal-01206501, 2015.

[56] A. Murgia, G. Concas, et al. 一种基于机器学习的 CVS 上修复问题提交的文本分类方法. ACM-IEEE 经验软件工程与测量国际研讨会 (ESEM) 会议记录. 2010.

---

### 附录

#### A. SP 形式主义的不足

根据我们在第 II-B 节中的定义，移除所有功能的补丁被视为 SP。这是因为没有任何输入会执行通过程序，换句话说，所有输入最终都会进入错误基本块。公式 1 和 2 显然成立，因为对于所有输入 (i → fp) 评估为假。

我们忽略所有对局部变量的更新，因为它们不是函数输出的一部分。考虑如清单 9 所示的补丁，该补丁移除了一个看似无用的 `memset`。这是有效且通常被称为死存储消除 [32]。然而，仔细检查后，可以认识到 `memset` 可能是必需的，因为它可能会清理某些秘密数据以避免信息泄露。我们当前的 SP 定义无法处理这些情况。

```c
int main(int argc, char **argv) {
    ...
    if (argc > 0) {
        return -1;
    }
}
```

**清单 7**: 移除所有功能的补丁

1. **补丁大小**: 图 6 中的图表显示了所研究提交的大小分布以及 SPIDER 识别为 SP 的补丁。可以看出，42.9% 的被识别为 SP 的补丁（即 28,873 个）影响超过五行代码（受影响的行数是根据 git diff 工具计算的添加和删除行数之和），5.6% 的补丁影响超过 20 行代码。我们手动检查了一些这些大的补丁，并确认它们确实是 SP。大多数这些补丁都是在一个简单的问题上进行了多次修改，从而导致大量受影响的行数。

2. **假阴性**: 可以想象，SPIDER 可能会有假阴性，即将某些补丁分类为非 SP，而实际上它们是 SP。这并不是一个大问题，因为找到所有的 SP 并不是 SPIDER 的目标。然而，在我们的手动调查中，我们发现了一些有趣的 SP 补丁，它们违反了我们在第 III 节中解释的条件。

   清单 8 显示了一个修复内存泄漏的补丁，理想情况下它是一个 SP，但不满足公式 2。在这里，除了其他更改外，补丁还更改了函数 `copy_from_user` 的第三个参数（从第 2 行到第 10 行）。由于我们将调用的参数视为函数的输出，因此清单 8 中的补丁更改了函数的输出，因此不会被认为是 SP。然而，对修补函数的仔细分析以及对 `copy_from_user` 函数行为的理解表明，此补丁不会影响输出（对于所有有效输入），因此是一个 SP。事实上，这个补丁是 CVE-2016-6130 的安全修复。

   ```c
   + copied = PAGE_SIZE −
   +
   1
   2
   3
   4
   + if
   +
   +
   5
   +
   6
   + }
   7
   8 − if
   9 −
   10 − if
   11 −
   + if
   12
   +
   13
   sccb_header,
   copy_from_user(sccb, u64_to_uptr(ctl(
   offset_of(struct
   size_of(sccb->length) > copied ||
   rc = -EFAULT;
   goto out_free;
   (sccb->length > PAGE_SIZE ||
   return -EINVAL;
   (copy_from_user(sccb, u64_to_uptr(ctl(
   rc = -EFAULT;
   (sccb->length length > copied) {
   sccb->length length)) {
   ```

   **清单 8**: 违反公式 2 的 SP 补丁片段 (532c34b5fbf1687df63b3fcd5b2846312ac943c6) 从主线 Linux 内核 (ID 1) 中获取。

   这证实了我们的直觉，即我们的 SP 定义对于补丁成为 SP 是充分的，但不是必要的。

   ```c
   int decrypt(...) {
       ...
       ... − memset(secret_buff, 0, sizeof(secret_buff));
   }
   char secret_buff[4096];
   ```

   **清单 9**: 可能引入安全漏洞的优化补丁。

   ```c
   a_v_priv_report_missing_feature(s->avctx, "Lowres for weird subsampling");
   if ((AV_RB32(s->upscale_v) || AV_RB32(s->upscale_h)) && s->progressive && s->avctx->pix_fmt == AV_PIX_FMT_GBRP) {
       a_v_priv_report_missing_feature(s->avctx, "progressive for weird subsampling");
       return AVERROR_PATCHWELCOME;
   }

   + if (s->l_s) {
   +     memset(s->upscale_h, 0, sizeof(s->upscale_h));
   +     memset(s->upscale_v, 0, sizeof(s->upscale_v));
   }
   ```

   **清单 10**: FFmpeg (ID 21) 中的一个非 CVE 安全补丁 (commit ee1e3ca5eb1)，其提交信息中有触发输入。

   ```c
   const struct sadb_msg *hdr, void *parse_exthdrs(struct sk_buff *skb, ...) {
       ...
       uint16_t ext_type;
       int len;
       ext_len;
       + if (ext_len < sadb_ext_len)
   }
   ```

   **清单 11**: 主内核 (ID 1) 中的一个非 CVE 安全补丁 (commit 4e7REDACTED)，在 Qualcomm (ID 4) 内核中缺失。

   | 总计 |
   | --- |
   | 提交数 | 341,767 |
   | NoEB | 64,682 (18.93%) |
   | NoPP | 63,463 (18.57%) |
   | SP (%) | 60,878 (17.81%) |
   | 默认 | 67,408 (19.72%) |

   **表 IV**: 在表 II 列出的所有项目中运行 SPIDER 在各种模式下检测到的 SP 数量和百分比的摘要。每个项目的详细分解可以在我们扩展版本 [7] 的表 IV 中找到。

#### B. 控制依赖与控制流

控制依赖的概念不同于更常用的控制流概念。控制流捕获可能的执行流，而控制依赖捕获执行到达特定语句时必须满足的必要条件。考虑图 2b 中修补函数的 PDG。我们可以看到从第 3 行对应的节点到第 15 行有一个标签为 F 的控制依赖边。这意味着第 3 行的条件必须为假才能使执行到达第 15 行。这是正确的，因为如果第 3 行的条件为真，则执行将立即从函数返回（第 4 行）。另一方面，考虑图 1 中修补函数的控制流图。BB1（包含第 3 行）与 BB5（包含第 15 行）之间没有直接边。这是因为执行不会直接从 BB1 到达 BB5，因为中间还有其他指令（在 BB3 和 BB4 中）。

#### C. SP 检测率低的原因

有些项目中检测到的 SP 百分比较低，例如 ID 15 和 ID 16。经过手动调查这些补丁的子集后，我们发现了以下原因：

- **复杂代码**: 某些项目主要包含具有嵌套循环中数据依赖关系的复杂函数。具体来说，Python (ID 15) 和 PHP (ID 16) 解释器，以及 cURL (ID 24)。虽然补丁本身很简单，但数据依赖增加了约束的复杂性，导致 SPIDER 无法证明条件 C1（第 III-B3 节）的蕴涵，从而导致较低的 SP 检测率。
- **复杂补丁**: 在 libpng (ID 30) 和 OpenVPN (ID 28) 等项目中，提交往往很复杂，因为它们涉及媒体文件格式和加密协议。因此，SPIDER 无法证明条件 C2 的等价性。

#### D. 修复密码学问题的补丁

OpenSSL 中的大多数 CVE 修复了与密码操作相关的安全问题，这些操作以复杂的方式影响控制流。一些 OpenSSL CVE 修复了针对时间侧信道攻击的密码实现，而 SPIDER 无法对其进行推理。例如，OpenSSL 存储库中的提交哈希 ae50d8270026edf5b3c7f8aaa0c6677462b33d97 [13] 修复了 SSLv2 的 Bleichenbacher 攻击 [27]。我们未能将其识别为 SP，因为更改不符合我们的 SP 定义（参见第 II-B 节）。

#### E. SP 示例

清单 12 显示了一个被识别为 SP 的补丁，在这种情况下，补丁只是通过 case 语句添加了一个错误基本块，满足条件 C1 和 C2，因为有效的输入空间（匹配 case 语句）是受限的，并且函数输出对有效输入没有变化。

```c
+ case MEM_AREA_SHM_VASPACE:
+ /* Find VA from PA in dynamic SHM is not yet supported */
+ va = map_pa2va(find_map_by_type_and_pa(m, pa), pa);
+ va = NULL;
+ break;
default:
...
return va;
```

**清单 12**: 在 OPTEE (commit 388302877d413) 中识别的 SP，其中更改只是添加了一个错误基本块。

清单 13 显示了 Redis 中识别为 SP 的一个提交，其中没有影响任何条件（条件 C1 成立），并且仅对局部变量进行了更改，因此不影响函数输出（条件 C2 成立）。

```c
int HelloRepl1_RedisCommand(RedisModuleCtx *ctx, ...) {
    ...
    - RedisModuleCallReply *reply;
    - reply = RedisModule_Call(ctx, "INCR", "c!", "foo");
    + RedisModule_Call(ctx, "INCR", "c!", "foo");
    - reply = RedisModule_Call(ctx, "INCR", "c!", "bar");
    + RedisModule_Call(ctx, "INCR", "c!", "bar");
    RedisModule_ReplyWithLongLong(ctx, 0);
    return REDISMODULE_OK;
}
```

**清单 13**: 在 Redis (commit 6798736909b7) 中识别的 SP，其中更改仅对局部变量进行了更改，不影响函数输出。

#### F. 在 PDG 中移除回边

在本节中，我们论证当补丁不直接修改循环内的语句时，移除回边是安全的。

原则上，移除 PDG 中的回边相当于展开 [31] 对应的循环一次。循环内计算值的符号表达式将如同循环执行了一次。如果函数的输出不依赖于循环的迭代次数，则展开一次或多次都不会影响我们的输出等价性检查，因此是安全的。

正如第 III-B4 节所述，我们使用符号表达式（表 I）来检查函数的输出等价性。现在，考虑函数的输出依赖于循环的迭代次数的情况，且原始函数和修补函数的输出符号表达式相同。这意味着循环在原始函数和修补函数中的迭代次数相同，因此输出也应相同。

因此，当补丁不直接修改循环内的语句时，移除回边并使用符号表达式进行输出等价性检查是安全的。然而，如果补丁直接修改了循环内的语句，移除回边会阻止信息的反向传播，从而导致计算出可能错误的符号输出约束对，因此是不安全的。

#### G. 概括库函数

如第 IV-E 节所述，我们维护了一份易于概括的知名库函数列表。这些函数的类别包括：

- **打印和日志记录函数**（例如，`printf`（不带 `%n` 格式说明符）、`printk`），我们忽略了它们的影响，因为它们用于日志记录。
- **内存初始化和释放函数**（例如，`kmemset`、`memset`、`kfree`、`free`），被视为对相应变量的写入。
- **内核同步函数调用**（例如，`spin_lock`、`spin_unlock`、`mutex_lock`、`mutex_unlock`）。类似于日志记录函数，这些函数不会影响输出。然而，不当使用的同步函数可能导致死锁。为了避免这种情况，我们需要检查任何 `_lock` 或 `_unlock` 函数都应有相应的 `_unlock` 或 `_lock` 函数。为此，对于任何插入的基本块 BB 中的 `_lock` 或 `_unlock` 函数，我们检查是否存在相应的 `_unlock` 或 `_lock` 函数在 BB 的后支配或前支配基本块之一中。

**C 安全敏感函数调用**（例如，`strcpy`、`strncpy`、`strlcpy`、`memcpy`、`sprintf`、`sscanf` 及其变体）。我们将这些视为赋值。例如，调用 `strcpy(dst, src)` 将被视为赋值 `dst=src`。

#### H. 处理多重定义

原则上，当多个变量定义可以到达某个语句时，有两种基本情况。我们在本节中展示了这两种情况都被我们的公式 5 处理。

第一种情况如下所示。在这种情况下，第 1 行或第 3 行的定义都可以到达第 5 行的语句：

```c
v = d1;
if (c) {
}
y = v + x;
v = d2;
```

所有到达第 3 行的执行都应该已经执行了第 1 行。换句话说，第 3 行由更严格的条件保护。此外，如果条件 c 表示的约束得到满足，则第 3 行定义的值（即 d2）将到达第 5 行。这由公式 5 的第一种情况捕捉到。

考虑第二种情况，其中第 2 行或第 3 行的定义都可以到达第 6 行：

```c
if (c) {
    v = d1;
} else {
    v = d2;
}
y = v + x;
```

在这种情况下，两个语句是互斥的，并且根据条件 c 表示的约束是否为真或假，第 2 行或第 4 行的定义将到达第 6 行。这由公式 5 的第二种情况捕捉到。

#### I. 我们假设的影响

尽管 SPIDER 力求在检测 SP 时保持健全性，但它有一些假设（第 V 节）和启发式方法（第 IV-D 节），这些可能不适合某些用户。在本节中，我们评估在禁用每个假设或启发式方法时技术的有效性。具体来说，我们以以下模式运行 SPIDER：

- **NoEB**: 如第 IV-D 节所述，我们忽略属于错误处理基本块 (BBerr) 的受影响语句。BBerr 通过某些可能不适用于某些项目的启发式方法检测。错误识别 BBerr 可能会导致某些不安全的补丁被错误地分类为 SP。在 NoEB 模式下，我们不排除任何受影响的语句，即使它们属于 BBerr 也会分析所有语句。
- **NoPP**: 我们使用 unifdef 工具处理预处理器指令。然而，如第 V 节所述，如果代码是 `#if-then-else` 结构的一部分，这可能导致某些代码被忽略。在 NoPP 模式下，如果补丁影响的函数有任何受预处理器指令控制的代码，则不会被视为 SP。

表 IV 显示了在所有项目中启用每种模式时 SPIDER 的整体有效性。检测率在各项目之间没有显著变化。每个项目的详细分解可以在我们扩展版本 [7] 的表 IV 中找到。列 NoEB ∪ NoPP 显示了同时启用两种模式的结果。我们还显示了在所有模式都关闭时，即默认模式下的有效性。所有模式下的检测率变化不大，这表明 SPIDER 使用的技术的有效性并不严重依赖于假设和启发式方法。

#### J. 关于 SPIDER 需求的匿名调查

为了了解像 SPIDER 这样的工具的实用性，我们对 Ubuntu、OpenSUSE、Linaro、OpenBSD 和 VLC 等各种开源软件项目的维护者和开发人员进行了匿名调查。完成调查的 39 名参与者中有 32 名（82%）同意这样的工具非常有用，并愿意在其项目中使用它。有趣的是，只有 OpenBSD 开发人员（其余 7 名参与者）表达了担忧，因为这样的系统也可能传播类似 Apple 的 `goto fail` [3] 的 Bug 引入补丁，但他们同意这仍然可以帮助专家开发人员优先处理他们的工作。这项匿名调查免于 IRB 批准 [9]，因为没有收集或使用用户的私人信息。

#### K. 未能识别所有错误处理基本块的影响

重要的是要注意，风险较高的错误是我们（错误地）将非错误基本块识别为错误块。在这种情况下，我们可能会错误地将补丁识别为 SP。将错误处理块误认为非错误处理块则相对不太有问题或更安全。原因是这种错误可能会导致我们的系统分析不必要的更多语句，这可能会导致将安全补丁丢弃为不安全，但不会将不安全的补丁识别为安全。因此，我们认为我们的方法是保守安全的。

---

希望这些优化后的文本能够更好地传达您的意图，并提高整体的专业性和可读性。