Programming Languages and Systems (TOPLAS), 2000.
[64] S. Raghavan, R. Rohana, et al. Dex: A semantic-graph differencing tool
In Proceedings of the IEEE
for studying changes in large code bases.
International Conference on Software Maintenance (ICSME). 2004.
[65] S. Rastkar and G. C. Murphy. Why did this code change? In Proceedings
of the International Conference on Software Engineering (ICSE). 2013.
[66] B. Ray and M. Kim. A case study of cross-system porting in forked projects.
In Proceedings of the Joint Meeting on Foundations of Software Engineering
(FSE). 2012.
[67] E. Raymond. The cathedral and the bazaar. Knowledge, Technology & Policy,
12(3):23–49, 1999.
[68] E. Rescorla. Security holes... who cares? In Proceedings of the USENIX
Security Symposium (SEC). 2003.
[69] E. A. Santos and A. Hindle. Judging a commit by its cover: correlating
commit message entropy with build status on travis-ci. In Proceedings of the
International Conference on Mining Software Repositories (MSR). 2016.
[70] G. Schryen. Security of open source and closed source software: An empirical
In Proceedings of the Americas
comparison of published vulnerabilities.
Conference on Information Systems (AMCIS). 2009.
[71] S. Son, K. S. McKinley, et al. Fix me up: Repairing access-control bugs
in web applications. In Proceedings of the ISOC Network and Distributed
System Security Symposium (NDSS). 2013.
[72] Y. Tao, Y. Dang, et al. How do software engineers understand code changes?:
An exploratory study in industry. In Proceedings of the Joint Meeting on
Foundations of Software Engineering (FSE). 2012.
[73] Y. Tian and B. Ray. Automatically diagnosing and repairing error handling
bugs in c. In Proceedings of the Joint Meeting on Foundations of Software
Engineering (FSE). 2017.
[74] D. Votipka, R. Stevens, et al. Hackers vs. testers: A comparison of software
vulnerability discovery processes. In Proceedings of the IEEE Symposium
on Security and Privacy (SP). 2018.
[75] P. Wadler. The essence of functional programming.
In Proceedings of
the ACM SIGPLAN Symposium on Principles of Programming Languages
(POPL). 1992.
[76] R. Wu, H. Zhang, et al. Relink: Recovering links between bugs and changes.
In Proceedings of the Joint Meeting on Foundations of Software Engineering
(FSE). 2011.
[77] F. Yamaguchi, N. Golde, et al. Modeling and discovering vulnerabilities with
code property graphs. In Proceedings of the IEEE Symposium on Security
and Privacy (SP). 2014.
[78] T. Zhang, M. Song, et al. Interactive code review for systematic changes. In
Proceedings of the International Conference on Software Engineering (ICSE).
2015.
[79] Y. Zhou and A. Sharma. Automated identification of security issues from
commit messages and bug reports. In Proceedings of the Joint Meeting on
Foundations of Software Engineering (FSE). 2017.
[33] R. Clarke, D. Dorwin, et al. Is open source software more secure? Homeland
Security/Cyber Security, 2009.
[35]
[34] L. De Moura and N. Bjørner. Z3: An efficient smt solver. In Proceedings
of the International conference on Tools and Algorithms for the Construction
and Analysis of Systems (TACAS). 2008.
J.-R. Falleri, F. Morandat, et al. Fine-grained and accurate source code
differencing.
In Proceedings of the ACM International Conference on
Automated Software Engineering (ASE). 2014.
J. Ferrante, K. J. Ottenstein, et al. The program dependence graph and its
use in optimization. ACM Transactions on Programming Languages and
Systems (TOPLAS), 1987.
[36]
[37] D. Gao, M. K. Reiter, et al. Binhunt: Automatically finding semantic
In Proceedings of the International
differences in binary programs.
Conference on Information and Communications Security (ICICS). 2008.
[38] E. Giger, M. Pinzger, et al. Comparing fine-grained source code changes and
code churn for bug prediction. In Proceedings of the International Conference
on Mining Software Repositories (MSR). 2011.
[39] A. E. Hassan. The road ahead for mining software repositories. In Proceedings
of the IEEE International Conference on Software Maintenance (FOSM).
2008.
[40] Z. Huang, D. Lie, et al. Using safety properties to generate vulnerability
patches. In Proceedings of the IEEE Symposium on Security and Privacy
(SP). 2019.
J. Jang, A. Agrawal, et al. Redebug: finding unpatched code clones in entire
os distributions. In Proceedings of the IEEE Symposium on Security and
Privacy (SP). 2012.
[41]
[42] Y. Kang, B. Ray, et al. Apex: Automated inference of error specifications
for c apis. In Proceedings of the Joint Meeting on Foundations of Software
Engineering (FSE). 2016.
[43] P. Kreutzer, G. Dotzler, et al. Automatic clustering of code changes.
In
Proceedings of the International Conference on Mining Software Repositories
(MSR). 2016.
[44] S. K. Lahiri, C. Hawblitzel, et al. Symdiff: A language-agnostic semantic diff
tool for imperative programs. In Proceedings of the International Conference
on Computer Aided Verification (CAV). 2012.
[45] S. K. Lahiri, K. Vaswani, et al. Differential static analysis: Opportunities,
applications, and challenges. In Proceedings of the FSE/SDP Workshop on
Future of Software Engineering Research (FoSER). 2010.
[46] W. Landi. Undecidability of static analysis. ACM Letters on Programming
Languages and Systems (LOPLAS), 1(4):323–337, 1992.
[47] C. Lattner. Llvm and clang: Next generation compiler technology. In The
BSD Conference, pp. 1–2. 2008.
[48] F. Li and V. Paxson. A large-scale empirical study of security patches.
the ACM SIGSAC Conference on Computer and
In Proceedings of
Communications Security (CCS). 2017.
[49] H. Li, H. Kwon, et al. A scalable approach for vulnerability discovery based
In Proceedings of the International Conference on
on security patches.
Applications and Techniques in Information Security (ATIS). 2014.
[50] Z. Li, D. Zou, et al. Vulpecker: an automated vulnerability detection system
based on code similarity analysis. In Proceedings of the Annual Conference
on Computer Security Applications (ACSAC). 2016.
[51] F. Long, P. Amidon, et al. Automatic inference of code transforms and search
spaces for automatic patch generation systems. In Proceedings of the Joint
Meeting on Foundations of Software Engineering (FSE). 2017.
[52] P. D. Marinescu and C. Cadar. Katch: high-coverage testing of software
patches. In Proceedings of the Joint Meeting on Foundations of Software
Engineering (FSE). 2013.
[53] M. A. McQueen, T. A. McQueen, et al. Empirical estimates and observations
of 0day vulnerabilities. In Proceedings of the Hawaii International Conference
on System Sciences (HICSS). 2009.
[54] N. Meng, M. Kim, et al. Systematic editing: generating program transfor-
mations from an example. ACM SIGPLAN Notices, 46(6):329–342, 2011.
[55] M. Monperrus. Automatic software repair: a bibliography. University of Lille,
Tech. Rep. hal-01206501, 2015.
[56] A. Murgia, G. Concas, et al. A machine learning approach for text
categorization of fixing-issue commits on cvs.
In Proceedings of the
ACM-IEEE International Symposium on Empirical Software Engineering and
Measurement (ESEM). 2010.
[57] A. Nappa, R. Johnson, et al. The attack of the clones: A study of the impact of
1576
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply. 
Total commits
sps
Perc.
100
80
60
40
37.4
57.1
20
0
24.3
19.5
11.1
9.1
6.5
3.6
0-5
5-10
15-20
Commit size (lines affected)
10-15
25.4
5.6
20+
of the size of all the commits studied and sp identified by SPIDER.
Fig. 6: The distribution
copy_from_user to PAGE_SIZE (line 2)
from sccb-
>length (line 10). Since we consider the arguments to a call to
be the output of a function, the patch in Listing 8 changes the output
of the function and thus will not be considered as a sp. However, a
careful analysis of the patched function along with an understanding
of the behavior of function copy_from_user would clarify
that this patch doesn’t affect the output (for all valid inputs) and
hence is a sp. In fact, this patch is a security fix for CVE-2016-6130.
+ copied = PAGE SIZE −
+
1
2
3
4
+ i f
+
+
5
+
6
+ }
7
8 − i f
9 −
10 − i f
11 −
+ i f
12
+
13
sccb header ,
copy from user
( sccb , u64 to uptr ( c t l
( o f f s e t o f ( s t r u c t
s i z e o f
( sccb−>length ) > copied ||
rc = −EFAULT;
goto o u t
f r e e ;
( sccb−>length > PAGE SIZE ||
return −EINVAL;
( copy from user
( sccb , u64 to uptr ( c t l
rc = −EFAULT;
( sccb−>length length > copied ) {
sccb−>length length ) ) {
APPENDIX
A. Shortcomings of the sp formalism
According to our definition in Section II-B, a patch that removes
all the functionality as shown in Listing 7 is an sp. This is because
none of the inputs execute through the program or in other words
all the inputs will end up in an error basic block. Equation 1 and
2 trivially hold as for all the inputs (i(cid:2)→fp) evaluates to false.
We ignore all the updates to local variables as they are not part of
the function output. Consider the patch as shown in Listing 9, which
removes a seemingly useless memset. This is valid and commonly
known as dead-store elimination [32]. However, on closer inspection,
one can recognize that the memset may be required as it would
potentially clean up some secret data to avoid information leaks.
Our current definition of sp does not handle these cases.
i n t main ( i n t argc , char ∗∗argv ) {
+
+
+
. . .}
i f ( argc > 0) {
return −1;
}
Listing 7: a patch that removes all the functionalities
1) Patch sizes: The plot in Figure 6 shows the distribution of the
size of the studied commits as well as those that SPIDER identified
as sps. One can see that 42.9% of the patches identified as sps (i.e.,
28,873 of them) affect more than five lines of code (the affected
lines are the sum of the lines added and deleted according to the git
diff tool), and 5.6% of the patches affect more than 20 lines of code.
We manually checked a few of these large patches and verified that
these are in fact sps. Most of these patches fix a simple issue across
multiple functions, resulting in large amounts of affected lines.
2) False negatives: One can imagine that SPIDER could have
false negatives i.e., it could classify certain patches as non-sps where
as they were in reality sp. This is not a major problem, as finding
all sps is not the goal of SPIDER. However, during our manual
investigation, we found certain interesting sps patches which violate
our conditions as explained in Section III.
Listing 8 shows a patch which fixes a memory leak and
ideally is an sp but does not satisfy the Equation 2. Here, among
other things, the patch changes the third argument to the function
1577
Listing 8: Snippet
from a sp patch (532c34b5fbf1687df63b3fcd5b2846312ac943c6
(fix potential information leak with /dev/sclp))
from mainline linux kernel (ID 1) that violate Equation 2.
This ratifies our intuition that, our definition of sp is sufficient
but not necessary for a patch to be an sp.
i n t decrypt ( . . ) {
. . .
. . .− memset ( s e c r e t b u f f , 0 ,
}
char s e c r e t b u f f [ 4 0 9 6 ] ;
s i z e o f ( s e c r e t b u f f ) ) ;
an optimizing patch that may induce a security vulnerability.
Listing 9:
a v p r i v r e p o r t m i s s i n g f e a t u r e
( s−>avctx , ”Lowres
for weird subsampling ”) ;
( (
return AVERROR PATCHWELCOME;
}
i f
|| AV RB32( s−>upscale v ) ) && s−>
AV RB32( s−>upscale h )
p r o g r e s s i v e && s−>avctx−>pix fmt == AV PIX FMT GBRP) {
a v p r i v r e p o r t m i s s i n g f e a t u r e
( s−>avctx , ” p r o g r e s s i v e
return AVERROR PATCHWELCOME;
}
for weird subsampling ”) ;
+
+
+
+
i f
( s−>l s ) {
memset ( s−>upscale h , 0 ,
memset ( s−>upscale v , 0 ,
s i z e o f ( s−>upscale h ) ) ;
s i z e o f ( s−>upscale v ) ) ;
Listing 10: A non-CVE security patch (commit ee1e3ca5eb1)
in FFmpeg (ID 21) that has triggering input in the commit message.
const
s t r u c t
sadb msg ∗hdr , void ∗
parse exthdrs ( s t r u c t
sk buff ∗skb ,
. . .
type ;
u i n t 1 6 t ext
i n t
l e n ;
e x t
( len sadb ext
+
+
i f
e x t
len ;
Listing 11: A non-CVE security patch (commit 4e7REDACTED)
in Main kernel (ID 1) that is missing in Qualcomm (ID 4) kernel.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply. 
Total across all projects
Commits
341,767
NoEB
64,682 (18.93%)
63,463 (18.57%)
sps (% over commits)
NoPP
NoEB ∪ NoPP
60,878 (17.81%)
Default
67,408 (19.72%)
TABLE IV: The summary of the number and percentage of sps detected by running SPIDER in various modes
across all the projects listed in Table II. Detailed break down across each of the projects can be found in Table IV of our extended version [7].
B. Control dependency versus control flow
The concept of control dependency is different from the more
commonly-used concept of control flow. Control flow captures
possible flows of execution, while control dependency captures the
necessary conditions that must hold for the execution to reach a
particular statement. Consider the PDG of the patched function
in Figure 2b. We can see a control dependency edge from the
node (that corresponds to the instruction) at Line 3 to Line 15 with
label F. This means that the condition at Line 3 must evaluate to
false for the execution to reach Line 15. This is correct because
if the condition at Line 3 evaluates to true, then the execution will
immediately return from the function (Line 4). On the other hand,
consider the control-flow graph of the patched function in Figure 1.
There is no direct edge from BB1 (that contains Line 3) to BB5
(that contains Line 15). This is because the execution does not
flow directly from BB1 to BB5 as there are other instructions in
between (in BB3 and BB4).
C. Reasons for low detection rate of sps
There are certain projects where the percentage of detected sps
is low, such as IDs 15 and 16. After manual investigation of the
subset of these patches, we found the following reasons:
Complex code: There are certain projects that mostly contains
complex functions with data-dependencies inside nested loops.
Specifically, the Python (ID 15) and PHP (ID 16) interpreters,
and cURL (ID 24). Here, although the patches themselves are
simple, the data dependencies increase the complexity of constraints,
resulting in SPIDER failing to prove implication for the condition
C1 (Section III-B3) resulting in a smaller sp detection rate.
Complex patches: In projects such as libpng (ID 30) and,
OpenVPN (ID 28), the commits tend to be complex as they deal
with media file formats and cryptographic protocols. Consequently,
SPIDER fails to prove the equivalence for the condition C2.
D. Patches fixing cryptographic issues
Most of the CVEs in OpenSSL fix security issues related to
cryptographic operations that affect the control flow in complex
ways. A few OpenSSL CVEs fix cryptographic implementations
against time side-channel attacks, which SPIDER is unable to reason
about. For instance, the commit hash ae50d8270026edf5b3c7f8aaa0
c6677462b33d97 [13] for CVE-2016-0703 of the OpenSSL
repository
the
Bleichenbacher [27] attack. We fail to identify this as an sp because
the changes does not satisfy our definition of sp (refer Section II-B).
implementation
against
fixes
SSLv2
E. Examples of sps
The Listing 12 shows a patch identified as sp, in this case,
the patch just adds an error basic block through a case statement,
satisfying conditions C1 and C2, as the valid input space (matching
the case statement) is restricted, and the function output does
not change for the valid inputs. Listing 13 shows a commit in Redis
identified as an sp, where there are no conditions affected (condition
1578
C1 holds) and changes are made only to a local variable thus not
affecting the function output (condition C2 holds).
+ case MEM AREA SHM VASPACE:
+ /∗ Find VA from PA in dynamic SHM i s not yet
+
+
supported ∗/
va = map pa2va ( find map by type and pa (m, pa ) , pa ) ;
va = NULL;
break ;
d e f a u l t :
}
. . .
return va ;
}
Listing 12: An sp identified in OPTEE (commit
388302877d413) where the changes just add an error basic block.
i n t HelloRepl1 RedisCommand ( RedisModu
. .− RedisModuleCallReply ∗ reply ;
. .− reply = RedisModule Call ( ctx , ” INCR” ,” c !” ,” foo ”) ;
+ RedisModule Call ( ctx , ” INCR” ,” c !” ,” foo ”) ;
− reply = RedisModule Call ( ctx , ” INCR” ,” c !” ,” bar ”) ;
+ RedisModule Call ( ctx , ” INCR” ,” c !” ,” bar ”) ;
RedisModule ReplyWithLongLong ( ctx , 0 ) ;
return REDISMODULE OK;
}
Listing 13: An sp
identified in Redis (commit 6798736909b7) where the changes are
only to local variables and do not affect the output of the function.
F. Removing back edges in the PDG
In this section, we argue that removing back-edges is safe when
a patch does not directly modify a statement within a loop.
In principle, removing back-edges in the PDG unrolls [31] the
corresponding loop once. The symbolic expression of the values
computed inside the loop will be as if the loop is executed once.
If the output of the function does not depend on the number of
iterations of a loop then unrolling the loop once or multiple times
does not affect our output equivalence checking, and hence it is safe.
As explained in Section III-B4, we use symbolic expressions (Ta-
ble I) to check the output equivalence of the functions. Now, consider
the case where the output of the function depends on the number of
iterations of a loop, and the symbolic expressions of the output are
same in the original and the patched function. This means that the
number of iterations of the loop will be the same in the original and
patched function, and consequently, the output should be the same.
Hence, our approach of removing the back-edges and using
symbolic expressions for output equivalence checking is safe
when a patch does not directly modify a statement within a loop.
However, if the patch directly modifies a statement within a loop,
the removal of the back-edges prevents the back-propagation of this
information resulting in computation of potentially wrong symbolic
output-constraint pairs, thus is not safe.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply. 
G. Summarizing library functions
As mentioned in Section IV-E, we maintain a list of well-known
library functions which could be easily summarized. The categories
of the functions are:
•
•
Print and logging functions (e.g., printf (without the
%n format specifier), printk), we ignore its affects as
they are used for logging.
• Memory initialization and release functions
(e.g.,
kmemset, memset, kfree, free), are considered
as writes to the corresponding variables.
• Kernel synchronization function calls (e.g., spin_lock,
spin_unlock, mutex_lock, mutex_unlock).
Similar to the logging functions, these do not affect
the output. However, improperly used synchronization
functions could cause deadlocks. To avoid this, we need
to check that any *_lock or *_unlock function
should have corresponding *_unlock or *_lock
respectively. To do this, for any inserted *_lock or
*_unlock function in a basic block BB, we check
that there exists corresponding *_unlock or *_lock
function in one of the post-dominator or pre-dominator
basic blocks of BB respectively.
C security-sensitive function calls
strncpy, strlcpy, memcpy, sprintf,
sscanf and their variants). We model
these are
assignments. For instance, the callstrcpy(dst, src)
will be treated as the assignment dst=src.
(e.g., strcpy,
H. Handling multiple definitions
In principle, there are two basic cases when multiple definitions
of a variable can reach a statement. We show in this section that
both of the cases are handled by our Equation 5.
The first case is shown below. In this case, the definitions at
both line 1 or 3 can reach can the statement at line 5:
v = d1 ;
i f ( c ) {
}
y = v + x ;
v = d2 ;
All the executions that reach line 3 should have executed line 1. In
other words, line 3 is guarded by a stricter condition. Furthermore, if
the constraint represented by the condition c is satisfied, then the
value defined at line 3 (i.e., d2) will reach line 5. This is captured
by the first case of the Equation 5.
Consider the second case, where the definitions at line 2 or 3
can reach line 6:
i f ( c ) {
v = d1 ;
} e l s e {
v = d2 ;
}
y = v + x ;
1
2
3
4
5
1
2
3
4
5
6
In this case, both statements are mutually exclusive, and, depending
on whether the constraint represented by the condition c is true
or false, the definitions at line 2 or line 4 reach line 6. This is
captured by the second case of the Equation 5.
1579
I.
Impact of our assumptions
Although, SPIDER tries to be sound in detecting sps, it has a few
assumptions (Section V) and uses heuristics (Section IV-D) which
may not be desirable for certain users. In this section, we evaluate
the effectiveness of our technique when each of these assumptions
or heuristics is disabled. Specifically, we run SPIDER in following
modes:
•
NoEB: As explained in Section IV-D, we ignore the
affected statements that are part of a error-handling basic
block (BBerr). The BBerrs are detected using certain
heuristics that may not hold for certain projects. Incorrect
identification of BBerrs might cause certain non-safe
patches to be wrongly classified as sps. In NoEB mode,
we do not ignore any affected statements and analyze all
the statements even if they belong to an BBerr.
NoPP: We use the tool unifdef to handle preprocessor
directives. However, as explained in Section V, this
could cause certain code to ignored if it is part of a
#if-then-else construct. In NoPP mode, if a patch
affects a function which has any code controlled by a
preprocessor directive it will not be considered as a sp.
•
Table IV shows the overall effectiveness of SPIDER across all the
projects with each of these modes turned on. The detection rate did
not vary much across the projects. The detailed breakdown for each
project is provided in Table IV of our extended version [7]. The
column NoEB ∪ NoPP shows the results when both the modes are
enabled. We also show the effectiveness when all of these modes
are turned off, i.e., the Default mode. The detection rate does not
vary much across all the modes, which shows that the effectiveness
of the techniques used by SPIDER does not largely depend on the
assumptions and heuristics.
J. Anonymous survey on the requirement of SPIDER
To get a feeling for the utility of a tool like SPIDER, we
performed an anonymous survey of maintainers and developers
of various open-source software projects,
including Ubuntu,
OpenSUSE, Linaro, OpenBSD, and VLC. 82% of those who
completed the survey (32 out of 39 participants) agreed that such a
tool would be very useful, and they were prepared to use it for their
projects. Interestingly, only OpenBSD developers (the remaining
7 participants) expressed concerns, as such a system might also
propagate bug-inducing patches like Apple’s goto fail [3], but they
agree that it could still help expert developers to prioritize their
efforts. This anonymous survey is exempted from IRB approval [9],
as there is no collection or use of user private information.
K. Impact of not identifying all error-handling basic blocks
It is important to observe that the risky mistakes are those where
we (incorrectly) identify non-error basic blocks as error blocks. In
such cases, we could falsely identify a patch as an sp. It is much
less problematic or safer to misidentify an error-handling block as
a non-error-handling block. The reason is that such a mistake might
cause our system to analyze more statements than necessary which
could result in discarding a safe patch as unsafe, but it does not
introduce unsafe patches as safe. Thus, we consider our approach
safely conservative.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply.