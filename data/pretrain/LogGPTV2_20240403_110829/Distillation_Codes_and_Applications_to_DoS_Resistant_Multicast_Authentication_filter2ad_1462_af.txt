In Advances in
functions for message authentication.
Cryptology – CRYPTO ’96, volume 1109 of Lecture Notes
in Computer Science, pages 1–15, 1996.
[6] M. Bellare and C. Namprempre. Authenticated encryp-
tion: Relations among notions and analysis of the generic
composition paradigm. In Advances in Cryptology – ASI-
ACRYPT ’00, volume 1997 of Lecture Notes in Computer
Science, pages 531–545, 2000.
[7] M. Bellare and P. Rogaway. Collision-resistant hash-
ing: Towards making UOWHFs practical. In Advances in
Cryptology – CRYPTO ’97, volume 1294 of Lecture Notes
in Computer Science, pages 470–484, 1997.
[8] J. Benaloh and M. de Mare. One way accumulators: A
decentralized alternative to digital signatures. In Advances
in Cryptology – EUROCRYPT ’93, volume 765 of Lecture
Notes in Computer Science, pages 274–285, 1993.
[9] J. Camenisch and A. Lysyanskaya. Dynamic accumula-
tors and application to efﬁcient revocation of anonymous
credentials.
In Advances in Cryptology – CRYPTO ’02,
volume 2442 of Lecture Notes in Computer Science, pages
61–76, 2002.
[10] V. Gligor. Guaranteeing access in spite of service-ﬂooding
In Proceedings of the Security Protocols Work-
attacks.
shop, Apr. 2003.
[11] P. Golle and N. Modadugu. Authenticating streamed data
in the presence of random packet loss. In Proceedings of
the Symposium on Network and Distributed Systems Se-
curity (NDSS 2001), pages 13–22. Internet Society, Feb.
2001.
[12] M. Goodrich, R. Tamassia, and J. Hasic. An efﬁcient dy-
namic and distributed cryptographic accumulator. In Pro-
ceedings of Information Security Conference (ISC 2002),
volume 2433 of Lecture Notes in Computer Science, pages
372–388, 2002.
[13] B. Kaliski and M. Robshaw. Message authentication with
MD5. RSA Cryptobytes, 1(1):5–8, Spring 1995.
[14] H. Krawczyk. Distributed ﬁngerprints and secure informa-
tional dispersal. In Proceedings of 13th ACM Symposium
on Principles of Distributed Computing, pages 207–218.
ACM, 1993.
[15] M. Luby. LT codes. In Proceedings of the 43rd Annual
IEEE Symposium on Foundations of Computer Science
(FOCS ’02), pages 271–282, 2002.
[16] M. Luby, M. Mitzenmacher, A. Shokrollahi, D. Spielman,
and V. Stemann. Practical loss-resilient codes.
In Pro-
ceedings of 29th Annual ACM Symposium on Theory of
Computing (STOC ’97), pages 150–159, May 1997.
[17] R. Merkle. Protocols for public key cryptosystems. In Pro-
ceedings of the IEEE Symposium on Research in Security
and Privacy, pages 122–134, Apr. 1980.
[18] S. Miner and J. Staddon. Graph-based authentication of
digital streams.
In Proceedings of the IEEE Symposium
on Research in Security and Privacy, pages 232–246, May
2001.
[19] M. Naor and M. Yung. Universal one-way hash functions
and their cryptographic applications.
In Proceedings of
the 21st Annual ACM Symposium on Theory of Computing
(STOC ’89), pages 33–43, May 1989.
[20] K. Nyberg. Fast accumulated hashing. In Fast Software
Encryption – Third International Workshop, volume 1039
of Lecture Notes in Computer Science, pages 83–87, 1996.
[21] A. Pannetrat and R. Molva. Efﬁcient multicast packet au-
thentication. In Proceedings of the Symposium on Network
and Distributed System Security Symposium (NDSS 2003).
Internet Society, Feb. 2003.
[22] J. M. Park, E. Chong, and H. J. Siegel. Efﬁcient mul-
ticast packet authentication using erasure codes. ACM
Transactions on Information and System Security (TIS-
SEC), 6(2):258–285, May 2003.
[23] J. M. Park, E. K. Chong, and H. J. Siegel. Efﬁcient multi-
cast packet authentication using signature amortization. In
Proceedings of the IEEE Symposium on Research in Secu-
rity and Privacy, pages 227–240, May 2002.
[24] A. Perrig. The BiBa one-time signature and broadcast au-
thentication protocol. In Proceedings of the Eighth ACM
Conference on Computer and Communications Security
(CCS-8), pages 28–37, Philadelphia PA, USA, Nov. 2001.
[25] A. Perrig, R. Canetti, D. Song, and J. D. Tygar. Efﬁcient
In Pro-
and secure source authentication for multicast.
ceedings of the Symposium on Network and Distributed
Systems Security (NDSS 2001), pages 35–46. Internet So-
ciety, Feb. 2001.
[26] A. Perrig, R. Canetti, J. D. Tygar, and D. Song. Ef-
ﬁcient authentication and signature of multicast streams
over lossy channels. In Proceedings of the IEEE Sympo-
sium on Research in Security and Privacy, pages 56–73,
May 2000.
[27] A. Perrig and J. D. Tygar. Secure Broadcast Communica-
tion in Wired and Wireless Networks. Kluwer Academic
Publishers, 2002.
[28] M. Rabin. Efﬁcient dispersal of information for security,
load balancing, and fault tolerance. Journal of the ACM,
36(2):335–348, 1989.
[29] I. Reed and G. Solomon. Polynomial codes over certain
ﬁnite ﬁelds. Journal of the Society for Industrial and Ap-
plied Mathematics, 8(2):300–304, 1960.
[30] L. Reyzin and N. Reyzin. Better than BiBa: Short one-
time signatures with fast signing and verifying. In Seventh
Australasian Conference on Information Security and Pri-
vacy (ACISP 2002), July 2002.
[31] L. Rizzo. Effective erasure codes for reliable computer
communication protocols. ACM Computer Communica-
tion Review, 27(2):24–36, Apr. 1997.
[32] T. Sander. Efﬁcient accumulators without trapdoor ex-
tended abstracts. In Information and Communication Se-
curity, Second International Conference – ICICS ’99, vol-
ume 1726 of Lecture Notes in Computer Science, pages
252–262, 1999.
[33] D. Song, D. Zuckerman, and J. D. Tygar. Expander graphs
for digital stream authentication and robust overlay net-
works.
In Proceedings of the IEEE Symposium on Re-
search in Security and Privacy, pages 258–270, May 2002.
[34] H. Weatherspoon, C. Wells, P. R. Eaton, B. Y. Zhao, and
J. D. Kubiatowicz. Silverback: A global-scale archival
system. Technical Report UCB//CSD-01-1139, University
of California at Berkeley, 2000.
[35] C. Wong and S. Lam. Digital signatures for ﬂows and
multicasts. In Proceedings on the 6th International Con-
ference on Network Protocols (ICNP ‘98), pages 198–209.
IEEE, October 1998.
A. Security Analysis of Distillation Codes:
Authenticity
We will show that if the TAG(·) and VALIDATE(·) algo-
rithms satisfy integrity of plaintext, then a distillation code
using these algorithms also satisﬁes integrity of plaintext.
We will adapt Bellare and Namprempre’s notion of in-
tegrity of plaintext (INT-PTXT) [6] to the public key set-
ting. Note that their deﬁnition was in the context of en-
cryption and decryption algorithms, while we frame ours
in terms of encoding and decoding algorithms.
Deﬁnitions & Notation We deﬁne a public key encod-
ing scheme PKE = (K,E,D) to consist of three al-
gorithms. The randomized key generation algorithm K
takes a natural number k ∈  as its security parame-
ter and outputs a public key Kpub and private key Kpriv:
(Kpub, Kpriv) R←− K(k). The encoding algorithm E uses
the private key Kpriv to encode a message M into a code-
text C, possibly using a randomization source: C R←−
EKpriv(M). The decoding algorithm D uses the public
key Kpub to authenticate the codetext C.
It returns a
plaintext if it can authenticate the codetext, or ⊥ if it
cannot validate the codetext: P ⊥ ← DKpub(C) where
P ⊥ ∈ {⊥} ∪ {0, 1}∗
. For all encoding schemes, we re-
quire M = DKpub(EKpriv(M))
We now provide an authenticity deﬁnition for a public
key encoding scheme PKE(K,E,D). A veriﬁcation algo-
rithm D∗
Kpub takes a codetext and returns a boolean value
indicating whether the decoding was successful:
Kpub : C ∈ {0, 1}∗ (cid:15)→ {0, 1}
ALGORITHM D∗
if DKpub(C) (cid:4)=⊥ return 1
return 0
We allow an adversary access to Kpub, an encoding ora-
cle, as well as a veriﬁcation oracle in order to try to break
the encoding scheme. The adversary is able to violate
the integrity of the encoding scheme if it can produce a
codetext whose plaintext was never passed to the encod-
ing algorithm EKpub(·).
If it is computationally difﬁcult
for an adversary to produce such a plaintext, the encoding
scheme is said to offer integrity of plaintext, abbreviated
INT-PTXT.
Deﬁnition 2. Integrity of a public key encoding scheme
Let PKE(K,E,D) be a public key encoding scheme.
Let k ∈  and A be an adversary that has access to an en-
coding oracle E(·) and a veriﬁcation oracle D∗(·). Then,
consider the following experiment:
EXPERIMENT ExpPKE,A : k ∈  (cid:15)→ {0, 1}
(·)(k, Kpub) makes a query
(Kpub, Kpriv) R←− K(k)
if AEKpriv (·),D∗
to D∗
Kpub(·) such that:
Kpub(C) = 1 and DKpub(C) was
D∗
never a query to EKpriv(·)
Kpub
then return 1
else return 0
The advantage of the adversary is the probability that the
adversary can produce a query to the decoder that returns
success for which the corresponding plaincode was never
passed to the encoder. Speciﬁcally:
AdvPKE,A(k)  Pr
ExpPKE,A(k) = 1
(cid:1)
(cid:2)
We deﬁne the advantage function of the scheme in terms
of τ, the running time of the adversary, q e, the number of
queries the adversary makes to the encoding algorithm E
with total length µe, and qd, the number of queries the ad-
versary makes to the veriﬁcation algorithm D∗
with total
length µd as:
{AdvPKE,A(k)}
AdvPKE(k, τ, qe, qd, µe, µd)  maxA
The scheme PKE satisﬁes INT-PTXT if AdvPKE,A(k)
is negligible for any adversary A with time-complexity
polynomial in k.
Distillation Codes We now brieﬂy present distillation
codes in the public key encoding framework. Distilla-
tion codes use an underlying public key encoding scheme
PKE V = (KV ,E V ,DV ) that provides integrity protec-
tion. To refer to an instantiation of a particular distillation
code, we write PKE DC = (KDC ,E DC ,DDC). This dis-
tillation code uses the underlying code PKE V to provide
integrity protection. The key generation algorithm K DC
returns a public-private keypair (K DC
priv ). Since the
pub
distillation code can decode despite symbol loss, the de-
coding algorithm takes a string composed of either sym-
, K DC
bols or ⊥ to represent a missing symbol: s⊥
where s⊥
i ∈ {⊥, si}.
1
||s⊥
2
|| . . .||s⊥
n
We set r to be the input message size; (n, t) represent
the erasure coding parameters: n the number of encoded
symbols per message, and t the maximum number of sym-
bols that can be lost for successful reconstruction; m to be
the size of the encoded erasure symbols; and f the maxi-
mum attack factor, as deﬁned in Section 2.5. We consider
all of these as ﬁxed parameters for a particular instantia-
tion of PKE V .
We abstract distillation code key generation, encoding,
and decoding algorithms from Figures 2 and 3. We deﬁne
the algorithm DE(·) to be steps 2-3 of DISTILLATION
ENCODE that erasure encodes the authenticated data and
augments them with the accumulator values. We deﬁne
the algorithm DC(·) to be steps 1-3 of DISTILLATION
DECODE from Figure 3 that returns a set of candidate re-
constructions.
ALGORITHM KDC : k ∈  (cid:15)→ (K DC
, K DC
priv )
pub
K V
priv
KDC
priv
K ← KV (k)
return K
ALGORITHM E DC
C ← DE(E V
return C
ALGORITHM DDC
R ← DC(C)
for each R ∈ R
if DV
return ⊥
KDC
pub
K V
priv
: M ∈ {0, 1}r (cid:15)→ {s}n
(M))
: C ∈ {⊥} ∪ {0, 1}m (cid:15)→
{0, 1}r ∪ {⊥}
(R) (cid:4)=⊥ return DV
(R)
K V
priv
Theorem 3.
PTXT secure,
(KDC ,E DC ,DDC) is also INT-PTXT secure.
If PKE V = (KV ,E V ,DV ) is INT-
then the distillation code PKE DC =
an
that
exists
Proof. Assume
adversary
there
AE DC (·),D∗DC(·) that can violate the INT-PTXT property
of a distillation code PKE DC
. Then, we will provide a
construction for an adversary BE V (·),D∗V (·) that can break
any INT-PTXT secure encoding scheme PKE V . In other
words, we will create an adversary B that makes a query
CV to D∗V (·) such that DV (CV ) (cid:4)=⊥ and DV (CV ) was
never a query to E V (·). We will prove that the advantage
for adversary B will be at least as large as that held by
adversary A.
AdvPKEDC ,A(k) ≤ AdvPKE V ,B(k)
(1)
Furthermore, if A runs in time t using q e encoding
queries of total length µe and qd veriﬁcation queries
of total length µd, then B will run in the same query
size parameters µe and µd making qe encoding and ≤
(cid:3)
n−t(cid:7) + 1
(cid:6) f n
qd veriﬁcation queries.
(cid:4)
The adversary B will use the adversary A to break
PKE V .
It will emulate the distillation code encoding
and veriﬁcation process fully so that A will believe that
it is interacting with a true distillation encoder and veri-
ﬁer. Thus, B will take in the security parameter k and a
public key and will output a codetext C. Speciﬁcally:
ADVERSARY BE V (·),D∗V : Kpub × k ∈  (cid:15)→ {0, 1}
for i = 1 . . . (qd + qe) do
when A makes a query M to its encoding
oracle E DC(·),
do A ⇐ DE(E V (M))
when A makes a query T to its veriﬁcation
oracle D∗DC(·),
do {R1, . . . , Rl} ← DC(T )
for j = 1, . . . , l
if D∗V
K V
pub
(Rj) = 1
A ⇐ 1; return
A ⇐ 0
Suppose, in the course of its run, adversary A has ad-
vantage α = AdvPKEDC ,A. In other words, it succeeds
in breaking the distillation code in an α fraction of its
executions. Consider such an execution. In this execu-
tion, let C denote the ﬁrst query that A makes to the ver-
iﬁcation oracle D∗DC(C) for which it has never made
the query E DC(DDC(C)) with DDC(C) (cid:4)=⊥. By con-
struction of DDC
, this means that there exists some Ri
and for which DV (Ri) (cid:4)=⊥. Now, to show this violates
the INT-PTXT property of PKE V , we need to verify that
DV (Ri) was never a query to to E V (·). We know that
DV (Ri) = DDC(C) and DDC(C) was never a query
to E DC(·). This means that DV (Ri) was never a query
to E V (·). Thus, the advantage that adversary B has in
breaking PKE V is at least as large as A has in breaking
PKE. Thus we have a contradiction since we assumed
that PKE V is INT-PTXT, implying that there can be no
adversary that breaks PKE with non-negligible probabil-
ity.
We note that B will make more queries to the decoding
oracle than A. Since a given codetext can produce many
candidate reconstructions, each of which needs to be val-
idated, B will make more queries to its validation oracle.
In fact, as argued in Section 3.4.3, there will be at most
n−t(cid:7) + 1 candidate reconstructions. Thus, if A makes
(cid:6) f n
(cid:4)
qd validation oracle calls, B will make ≤
qd
validation oracle calls.
(cid:3)
(cid:6) f n
n−t(cid:7) + 1