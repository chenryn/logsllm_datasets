  ---------------------- ---------------------------- ----------------- ------------------
#### **对策**
防范 eval 注入漏洞的对策如下。
> -   不使用 `eval` 或与 `eval` 相当的功能
>
> -   避免 `eval` 的参数中包含外界传入的参数
>
> -   限制外界传入 `eval` 的参数中只包含字母和数字
-   **不使用 eval**
    首先请考虑是否可以不使用 `eval` 以及与 `eval`
    相当的功能。比如，如果是为了序列化，那么除了 `eval`
    以外，还有以下函数可供选择。
    -   `implode/explode`
    -   `serialize/unserialize`
    `implode`
    函数的参数为数组，通过在各元素之间插入分割字符而将其转换为字符串。`explode`
    函数的行为则与之相反。这对组合能够胜任简单的序列化处理。
    `serialize` 的自由度更高，能够序列化对象。但是，`unserialize`
    会生成任意的对象，在对象被销毁时被称为析构函数，有时会成为安全隐患产生的原因
    [73]{.注释编号} 。
    而出于序列化之外的其他目的时，也同样应该调查是否有 `eval`
    以外的实现方法。多数情况下，即使不使用 `eval`
    及与其相当的功能，也都是能够实现相同处理的。例如，使用
    `preg_replace_callback` 来取代附带修饰符 `e` 的 `preg_replace`
    ，就能有效提高安全性。
-   **避免 eval 的参数中包含外界传入的参数**
    而使用 `eval` 的情况下，只要外界无法指定其参数就同样无法实施攻击。以
    4e-002.php 为例，如果使用会话变量取代 hidden
    参数来传递值，外界就无法注入脚本，从而也就保证了安全性。
    然而，脚本的注入途径并不局限于 HTTP
    请求，通过文件或数据库等途径也同样有可能注入脚本，因此，如果能够通过这些途径注入，那么就不能使用本对策。
-   **限制外界传入 eval 的参数中只包含字母和数字**
    如果能够限制外界传入 `eval`
    的参数中只包含字母和数字，那么就杜绝了脚本注入需要用到的符号字符（如分号
    `;` 、逗号 `,` 和引号等），因此也就能够防止脚本注入。
-   **参考：Perl 的 eval 代码块形式**
    Perl 语言的 `eval` 具有两种形式。分别为 `eval`
    后面接表达式的形式，和 `eval`
    后面接代码块（Block）的形式。由于后者能够杜绝 eval
    注入攻击，因此便能够放心使用。
    首先我们来看如下脚本，该脚本中使用了 `eval`
    后面跟表达式这一形式，其中含有 eval 注入漏洞。脚本中使用 `eval`
    的目的在于捕捉除以零值时的异常。
    ``` 代码无行号
    eval("\$c = $a / $b;"); # 除数有可能为零
    ```
    根据以上讲解的内容，如果此处将变量 `$b` 指定为如下字符串，就会使
    /sbin 目录下的文件一览显示出来。
    ``` 代码无行号
    $b = '1;system("ls /sbin")';
    ```
    而如果像下面的脚本那样采用 `eval` 的代码块形式，就消除了 eval
    注入漏洞。
    > **代码清单 eval 代码块形式的使用示例（摘要）**
    ``` 代码无行号
    eval {
      $c = $a / $b;   # 除数有可能为零
    };
    if ($@) {  # 出错的情况下
      # 错误处理
    }
    ```
    `eval` 代码块形式之所以不会产生 eval
    注入漏洞，是因为代码块内部的代码是固定不变的。
[73]{.注释编号下} CakePHP
中就曾经被曝出过这样的漏洞。参考：
（日文）
#### **总结**
本节介绍了 `eval`
这类能够将字符串解释为脚本代码并执行的功能中产生的安全隐患。`eval`
的功能很强大，但引发漏洞后的影响也同样是非常巨大的。世界上也有很多语言不提供
`eval` 功能，因此，强烈推荐写代码时不使用 `eval` 。
#### **继续深入学习**
寺田健的博客文章《通过 `preg_replace`
执行代码》\[2\]，详细讲述了附带修饰符 `e` 的 `preg_replace`
可能产生的漏洞。其中的内容非常有深度，据此还能够学到使用正则表达式来注入脚本等宝贵知识。
GIJOE 所著的《PHP 网络攻击方法》\[1\] 中也介绍了使用 `preg_replace`
来进行攻击的例子。其中还提到了因误用 WordPress 中的
`call_user_func_array` 而导致漏洞的相关内容。
> **参考文献**
>
> 写作本节时参考了以下资料。
>
> \[1\] GIJOE .（2005）.《PHP サイバーテロ》（《PHP 网络攻击方法》）.
> ソシム .
>
> \[2\] 寺田健 .（2008 年 6 月 6 日）. preg_replace
> によるコード実行（通过 preg_replace 执行代码）. 参考日期：2010 年 12
> 月 19 日 , 参考网址：T.Terada の日记 :
> 
>
> \[3\] 小邨孝明 .（2004 年 10 月 11 日）. PHP と Web
> アプリケーションのセキュリティについてのメモ（关于 PHP 与 Web
> 应用安全的笔记）. 参考日期：2010 年 12 月 19
> 日，参考网址：个人的なメモと备忘录 :
> 
## **4.15 共享资源相关的问题** {#text00000.html#nav_point_57}
由于 Web
应用能同时处理多个请求，因此会在并行处理中出现问题，特别是当操作涉及共享资源时，问题发生的几率尤大。而本节就将讲述因对共享资源的处理不完善而导致的代表性的安全隐患------竞态条件（Race
Condition）漏洞。
### **4.15.1 竞态条件漏洞** {#text00000.html#nav_point_58}
#### **概要**
共享资源是指，被多个进程或线程同时使用的变量、共享内存、文件、数据库等。如果针对共享资源的互斥锁不完善，就可能会导致竞态条件漏洞。
竞态条件漏洞的影响很多，其中，应用中由竞态条件问题而引起的典型的影响有以下几种。
-   页面上显示其他用户的个人信息（他人问题）
-   数据库信息不一致
-   文件内容被破坏
竞态条件漏洞的对策有如下两项，实施其中一项即可。
-   尽量不使用共享资源
-   针对共享资源实施完善的互斥锁
**竞态条件漏洞总览**
![{%}](Image00180.jpg)
#### **攻击手段与影响**
接下来我们就来看一下竞态条件漏洞引起问题的流程及其影响。此处介绍的案例都是突发性事件，而非蓄意攻击。示例应用由
Java Servlet 编写而成。本书的试验环境的虚拟机中没有准备 Servlet
的运行环境，如果想运行该示例可以安装 Tomcat 等 Servlet
容器。笔者已确认该示例在 Tomcat6.0 中运行正常。
Servlet 的源码如下。
> **代码清单 C4f-001.java**
``` 代码无行号
import java.io.*;
import javax.servlet.http.*;
public class C4f_001 extends HttpServlet {
 String name; // 定义为实例变量
 protected void doGet(HttpServletRequest req,
                      HttpServletResponse res)
    throws IOException {
  PrintWriter out = res.getWriter();
  out.print("name=");
  try {
    name = req.getParameter("name"); // 查询字符串 name
    Thread.sleep(3000); // 等待 3 秒（模拟耗时的处理）
    out.print(escapeHTML(name));  // 显示用户名
  } catch (InterruptedException e) {
    out.println(e);
  }
  out.println("");
  out.close();
 }
}
```
该 Servlet 从查询字符串中接收了 `name` 的值并将其赋值给实例变量 `name`
，等待 3 秒钟后，再在页面上显示实例变量 `name` 。等待 3
秒钟是为了模拟耗时很长的处理。`escapeHTML` 函数的作用在于防范
XSS（此处省略了该函数的定义）。
接下来，我们使用以下方法执行该
Servlet。打开两个浏览器窗口，在一个窗口中先使用 `name=yamada`
打开页面。1 秒钟后，再在另一个窗口中使用 `name=tanaka` 打开页面。
浏览器的显示如下图所示。
![{%}](Image00181.jpg)
**图 4-124 执行示例应用**
虽然两边都是要将查询字符串中指定的名字显示在页面上，但两个浏览器上都显示了
tanaka
这个名字。这种现象被称为他人问题。显示的不是自己输入的个人信息，而是其他人的信息，这也是一种个人信息的泄漏。
为了理解这个问题，首先要知道 Servlet
类的实例变量是共享资源。默认设置下，每个 Servlet
类只生成一个实例（对象），所有的请求都由这个唯一的实例来处理。因此，实例变量也只有一个，所有的请求处理都共享这个变量（即共享资源）。
下面我们将 yamada 和 tanaka 的处理以时间轴的形式进行整理，如下图所示。
![{%}](Image00182.jpg)
**图 4-125 示例的内部处理**
首先，yamada 的处理被启动，变量 `name` 被赋值为 `"yamada"` 。1
秒钟后，tanaka 的处理也开始进行，变量 `name` 的值被覆盖为 `"tanaka"`
。由于此后也一直为 `"tanaka"` ，因此两个浏览器中都显示了 `"tanaka"`
这个名字。
#### **安全隐患的产生原因**
安全隐患的产生原因有如下两点。
-   `name` 是共享变量
-   没有对共享变量 `name` 加上互斥锁
如果没有意识到 Servlet
类的实例变量是共享资源，那么就很可能会在不知不觉中埋下隐患。
#### **对策**
竞态条件漏洞的对策有如下两项，实施其中一项即可。
> -   尽量不使用共享资源
>
> -   针对共享资源实施完善的互斥锁
下面我们来看看如何对上面的示例实施防范策略。
-   **避免使用共享资源**
    其实上面的示例根本没有必要使用共享资源的变量 `name`
    ，使用非共享的局部变量就能解决问题。下面为修改后的代码摘要。
    ``` 代码无行号
    try {
      String name = req.getParameter("name"); // 定义为局部变量
      Thread.sleep(3000); // 等待 3 秒（模拟耗时的处理）
      out.print(escapeHTML(name));  // 显示用户名
    } catch (InterruptedException e) {
      out.println(e);
    }
    ```
-   **使用互斥锁**
    Java 的多线程处理中可以使用 `synchronized` 语句或 `synchronized`
    方法来进行互斥锁。下面展示的就是使用 `synchronized`