操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address 
Space Layout Randomization (ASLR) ），这样程序每次运行时函数返回地址会随机变化。反之如
果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址
会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件
中找到返回地址的位置，从而确定 shellcode 的起始地址。
PWN基础入门
看起来并不复杂对吧？但这种方
法生效的一个前提是在函数调用
栈上的数据（shellcode）要有可
执行权限(NX关闭)，另一个前提
是上面提到的关闭内存布局随机
化(ASLR关闭)。很多时候操作系
统会关闭函数调用栈的可执行权
限，这样 shellcode 的方法就失
效了，不过我们还可以尝试使用
内存里已有的指令或函数，毕竟
这些部分本来就是可执行的，所
以不会受上述执行权限的限制。
这就包括 return2libc 和 ROP 两
种方法(return2libc从属于ROP方
法）
Ø 栈溢出利用之ret2shellcode
PWN基础入门
Ø 栈溢出利用之Return2libc
Return2libc方法的思想是修改返回地址，让其指向内存中已有的某个函数
我们需要做到: 在内存中确定某个函数的地址，并用其覆盖掉返回地址。由于 
libc 动态链接库中的函数被广泛使用，所以有很大概率可以在内存中找到该动态
库。同时由于该库包含了一些系统级的函数(例如 system() 等),所以通常使用这
些系统级函数来获得当前进程的控制权。鉴于要执行的函数可能需要参数，比如
调用 system() 函数打开 shell 的完整形式为 system(“/bin/sh”) ，所以溢出数据也
要包括必要的参数。下面就以执行 system(“/bin/sh”) 为例，先写出溢出数据的组
成，再确定对应的各部分填充进去。
PWN基础入门
Ø 栈溢出利用之Return2libc
padding1 处的数据可以随意填充（注意不
要包含 “\x00” ，否则向程序传入溢出数据
时会造成截断），长度应该刚好覆盖函数的
基地址。address of system() 是 system() 
在内存中的地址，用来覆盖返回地址。
padding2 处的数据长度为4（32位机），对
应调用 system() 时的返回地址。因为我们
在这里只需要打开 shell 就可以，并不关心
从 shell 退出之后的行为，所以 padding2 
的内容可以随意填充。address of “/bin/sh” 
是字符串 “/bin/sh” 在内存中的地址，作为
传给 system() 的参数。
PWN基础入门
Ø 栈溢出利用之Return2libc
根据上面的构造，我们要解决个问题。
1. 返回地址之前的填充数据（padding1）应该多长？
解决方法和 shellcode 中提到的答案一样。
2. system() 函数地址应该是多少？
要回答这个问题，就要看看程序是如何调用动态链接库中的
函数的。当函数被动态链接至程序中，程序在运行时首先确
定动态链接库在内存的起始地址，再加上函数在动态库中的
相对偏移量，最终得到函数在内存的绝对地址。说到确定动
态库的内存地址，就要回顾一下 shellcode 中提到的内存布
局随机化（ASLR），这项技术也会将动态库加载的起始地
址做随机化处理。所以，如果操作系统打开了 ASLR，程序
每次运行时动态库的起始地址都会变化，也就无从确定库内
函数的绝对地址。在 ASLR 被关闭的前提下，我们可以通过
调试工具在运行程序过程中直接查看 system() 的地址，也
可以查看动态库在内存的起始地址，再在动态库内查看函数
的相对偏移位置，通过计算得到函数的绝对地址。
最后，“/bin/sh” 的地址在哪里？
可以在动态库里搜索这个字符串，如果存在，就可以按照动
态库起始地址＋相对偏移来确定其绝对地址。如果在动态库
里找不到，可以将这个字符串加到环境变量里，再通过 
getenv() 等函数来确定地址。
PWN基础入门
Ø 栈溢出利用之ROP
－－修改返回地址，让其指向内存中已有的一段指令
根据上面副标题的说明，要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。可是既
然可以覆盖返回地址并定位到内存地址，为什么不直接用上篇提到的 return2libc 呢？因为有时目标函数
在内存内无法找到，有时目标操作并没有特定的函数可以完美适配，这时就需要在内存中寻找多个指令片段，
拼凑出一系列操作来达成目的(可以理解为多级返回、多级跳板，类似于内网渗透中的多级跳板，利用系统提
供的指令进行拼接正大光明做坏事)。假如要执行某段指令（我们将其称为“gadget”，意为小工具），溢出
数据应该以下面的方式构造（padding 长度和内容的确定方式参见上篇）：
payload : padding + address of gadget
如果想连续执行若干段指令，就需要每个 gadget 执行
完毕可以将控制权交给下一个 gadget。所以 gadget 
的最后一步应该是 RET 指令，这样程序的控制权（eip）
才能得到切换，所以这种技术被称为返回导向编程
( Return Oriented Programming )。要执行多个 
gadget，溢出数据应该以下面的方式构造：
payload : padding + address of gadget 
1 + address of gadget 2 + ...... 
+ address of gadget n
PWN基础入门
Ø 栈溢出利用之ROP
现在任务可以分解为：针对程序栈溢出所要实现的效果，
找到若干段以 ret 作为结束的指令片段，按照上述的构
造将它们的地址填充到溢出数据中。所以我们要解决以
下几个问题。
首先，栈溢出之后要实现什么效果？
ROP 常见的拼凑效果是实现一次系统调用，Linux系统
下对应的汇编指令是 int 0x80。执行这条指令时，被调
用函数的编号应存入 eax，调用参数应按顺序存入 ebx，
ecx，edx，esi，edi 中。例如，编号125对应函数
mprotect (void *addr, size_t len, int prot)
PWN基础入门
Ø 栈溢出利用之ROP
PWN基础入门
Ø 栈溢出利用之Hijack GOT
--修改某个被调用函数的地址，让其指向另一个函数
根据上面副标题的说明，要完成的任务包括：在内存中修改某个函数的地址，使其指向另一个函数。为了
便于理解，不妨假设修改 printf() 函数的地址使其指向 system()，这样修改之后程序内对 printf() 
的调用就执行 system() 函数。要实现这个过程，我们就要弄清楚发生函数调用时程序是如何“找到”被
调用函数的。
程序对外部函数的调用需要在生成可执行文件时将外部函数链接到程序中，链接的方式分为静态链接和动
态链接。静态链接得到的可执行文件包含外部函数的全部代码，动态链接得到的可执行文件并不包含外部
函数的代码，而是在运行时将动态链接库（若干外部函数的集合）加载到内存的某个位置，再在发生调用
时去链接库定位所需的函数。
可程序是如何在链接库内定位到所需的函数呢？这个过程用到了两张表－－GOT 和 PLT。GOT 全称是全局
偏移量表（Global Offset Table），用来存储外部函数在内存的确切地址.GOT 存储在数据段（Data 
Segment）内，可以在程序运行中被修改,类似于windows中PE结构的IAT,只不过windows中IAT中的函数
地址是写保护的,没办法利用,但是GOT是可写的,我们可以将其中的函数地址覆盖为我们的shellcode地址,
在程序后面调用这个函数时就会调用我们的shellcode了.PLT 全称是程序链接表（Procedure Linkage 
Table），用来存储外部函数的入口点（entry），换言之程序总会到 PLT 这里寻找外部函数的地址。
PLT 存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改，所以 PLT 并不会知道
程序运行时动态链接库被加载的确切位置。那么 PLT 表内存储的入口点是什么呢？就是 GOT 表中对应条
目的地址。
PWN基础入门
Ø 栈溢出利用之Hijack GOT
第一次调用函数时解析函数地址并存入 GOT 表
再次调用函数时直接读取 GOT 内的地址
PWN基础入门
Ø 栈溢出利用之Hijack GOT
上述实现遵循的是一种被称为 LAZY 的设计思想，它将需要完成的操作（解析外部函数的内存地
址）留到调用实际发生时才进行，而非在程序一开始运行时就解析出全部函数地址。这个过程也
启示了我们如何实现函数的伪装，那就是到 GOT 表中将函数 A 的地址修改为函数 B 的地址。这
样在后面所有对函数 A 的调用都会执行函数 B。
那么我们的目标可以分解为如下几部分：确定函数 A 在 GOT 表中的条目位置，确定函数 B 在内
存中的地址，将函数 B 的地址写入函数 A 在 GOT 表中的条目。
首先，如何确定函数 A 在 GOT 表中的条目位置？
程序调用函数时是通过 PLT 表跳转到 GOT 表的对应条目，所以可以在函数调用的汇编指令中找
到 PLT 表中该函数的入口点位置，从而定位到该函数在 GOT 中的条目。
例如
call 0x08048430 
就说明 printf 在 PLT 表中的入口点是在 0x08048430，所以 0x08048430 处存储的就是 GOT 表
中 printf 的条目地址。
PWN基础入门
Ø 栈溢出利用之Hijack GOT
其次，如何确定函数 B 在内存中的地址？
如果系统开启了内存布局随机化，程序每次运行动态链接库的加载位置都是随机的，就很难通过调试工具直
接确定函数的地址。假如函数 B 在栈溢出之前已经被调用过，我们当然可以通过前一个问题的答案来获得
地址。但我们心仪的攻击函数往往并不满足被调用过的要求，也就是 GOT 表中并没有其真实的内存地址。
幸运的是，函数在动态链接库内的相对位置是固定的，在动态库打包生成时就已经确定。所以假如我们知道
了函数 A 的运行时地址（读取 GOT 表内容），也知道函数 A 和函数 B 在动态链接库内的相对位置，就
可以推算出函数 B 的运行时地址。
最后，如何实现 GOT 表中数据的修改？
很难找到合适的函数来完成这一任务，不过我们还有强大的 ROP（DIY大法好）。假设我们可以找到以下若
干条 gadget（继续钦点），就不难改写 GOT 表中数据，从而实现函数的伪装。ROP 的具体实现请回看上
一章，这里就不再赘述了。
pop eax; ret; 
# printf@plt -> eax
mov ebx [eax]; ret;
# printf@got -> ebx
pop ecx; ret; 
# addr_diff = system - printf -> ecx
add [ebx] ecx; ret; 
# printf@got += addr_diff
从修改 GOT 表的过程可以看出，这种方法也可以在一定程度上绕过内存随机化。
PWN基础入门
Ø 汇编基础(参考REVERSE,这里不细述)
Ø 栈溢出
Ø Linux漏洞安全防护机制与绕过
Ø 其他漏洞(整数溢出、格式化字符串等）
Ø 堆漏洞
Ø ……..
PWN基础入门
Ø 栈溢出漏洞防护(利用缓解)
防护技术
防护说明
Stack Canary
这里是一种缓冲区溢出攻击缓解手段,启用栈保护后，函数开始执行的时候会先往栈里
插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就
停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈
保护检查失败而阻止shellcode的执行。在Linux将cookie信息称为Canary，等同于
windows下的GS机制。
NX
NX(No Execute)缓解机制开启后，使某些内存区域不可执行，并使可执行区域不可写。
示例:使数据，堆栈和堆段不可执行，而代码段不可写。
PIE
PIE全称是position-independent executable，中文解释为地址无关可执行文件，
该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）
等固定地址的一个防护技术(编译器选项)，如果程序开启了PIE保护的话，在每次加载
程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。由于受到堆
栈和libc地址可预测的困扰，ASLR被设计出来并得到广泛应用。因为ASLR技术的出现，
攻击者在ROP或者向进程中写数据时不得不先进行leak，或者干脆放弃堆栈，转向bss
或者其他地址固定的内存块。而PIE(position-independent executable, 地址无关
可执行文件)技术正是一个针对代码段.text, 数据段.*data，.bss等固定地址的一个
防护技术,一定程度上增强系统的ASLR防护能力。
PWN基础入门 
Ø Checksec检查项说明
防护技术
防护说明
1
2
3
PWN基础入门
Ø 栈溢出漏洞防护Canary绕过--泄露Canary
l 方法: 利用格式化字符串漏洞，泄露出canary的值，然后填到canary相应的位置
从而绕过保护实现栈溢出。
PWN基础入门
Ø 栈溢出漏洞防护Canary绕过--泄露Canary(格式化字符串)
l 思路: 利用格式化字符串漏洞，泄露出canary的值，然后填到canary相应的位置
从而绕过保护实现栈溢出。
PWN基础入门
Ø 格式化字符串漏洞
格式化字符串漏洞是PWN题常见的考察点，仅次于栈溢出漏洞。漏洞原因：程序使用了格式化字符串作为
参数，并且格式化字符串为用户可控。其中触发格式化字符串漏洞函数主要是printf、sprintf、fprintf、prin
等C库中print家族的函数:
printf（“格式化字符串“,参数...)
%c：输出字符，配上%n可用于向指定地址写数据。
%d：输出十进制整数，配上%n可用于向指定地址写数据。
%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节
长的16进制数据，32bit和64bit环境下一样。
%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，
可通过输出字节的长度来判断目标环境是32bit还是64bit。
%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字
符串,在32bit和64bit环境下一样，可用于读取GOT表等信息。如果在栈中保存有指向我们感兴趣数据的指
针，我们就可以在打印指针的时候使用一个%s来打印别的地方的内容。而且一般的程序都会将用户输入
的数据储存在栈上。这就给了我们一个构造指针的机会，再结合格式化字符串漏洞，几乎可以得到所有内
存数据。
%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100×10$n表示将
0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表
示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接
写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。
%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合
%n写数据
format参考列表
PWN基础入门
Ø 格式化字符串漏洞
char str[100];