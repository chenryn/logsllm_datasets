ğ‘š1 and ğ‘š2 can be sent simultaneously (or in either order), and we
say that the key agreement protocol is one-round.
3.1 Security Properties
Different instantiations of our PSI protocol will require the fol-
lowing security properties of a key agreement protocol. Note that
Definition 3.4 and strongly uniform KA (SU-KA) [22] are similar,
but our definition is specialized to 1-round KA.
Party 1
ğ‘ â† KA.R
ğ‘š1 = KA.msg1(ğ‘)
Party 2
ğ‘š1
ğ‘ â† KA.R
ğ‘š2 = KA.msg2(ğ‘, ğ‘š1)
output KA.key2(ğ‘, ğ‘š1)
output KA.key1(ğ‘, ğ‘š2)
Figure 3: Generic 2-round key agreement protocol
ğ‘š2
Definition 3.1. A KA scheme is correct if, when executed hon-
estly as shown in Figure 3, the two parties give identical output. In
other words, for all ğ‘, ğ‘ âˆˆ KA.R:
KA.key1(ğ‘, KA.msg2(ğ‘, KA.msg1(ğ‘))) = KA.key2(ğ‘, KA.msg1(ğ‘))
Definition 3.2. A KA scheme is secure against an eavesdropper
if the following distributions are indistinguishable:
ğ‘, ğ‘ â† KA.R
ğ‘š1 = KA.msg1(ğ‘)
ğ‘š2 = KA.msg2(ğ‘, ğ‘š1)
ğ‘˜ = KA.key2(ğ‘, ğ‘š1)
return (ğ‘š1, ğ‘š2, ğ‘˜)
ğ‘, ğ‘ â† KA.R
ğ‘š1 = KA.msg1(ğ‘)
ğ‘š2 = KA.msg2(ğ‘, ğ‘š1)
ğ‘˜ â† KA.K
return (ğ‘š1, ğ‘š2, ğ‘˜)
Definition 3.3. A KA scheme is non-malleable if it is secure
(in the sense of Definition 3.2) against an eavesdropper that has
oracle access to KA.key1(ğ‘, Â·), provided the eavesdropper never
queries the oracle on ğ‘š2. Formally, the following distributions are
indistinguishable, for every PPT A that never queries its oracle on
input ğ‘š2:
ğ‘, ğ‘ â† KA.R
ğ‘, ğ‘ â† KA.R
ğ‘š1 = KA.msg1(ğ‘)
ğ‘š1 = KA.msg1(ğ‘)
ğ‘š2 = KA.msg2(ğ‘, ğ‘š1)
ğ‘š2 = KA.msg2(ğ‘, ğ‘š1)
ğ‘˜ = KA.key2(ğ‘, ğ‘š1)
ğ‘˜ â† KA.K
return AKA.key1(ğ‘,Â·)(ğ‘š1, ğ‘š2, ğ‘˜)
return AKA.key1(ğ‘,Â·)(ğ‘š1, ğ‘š2, ğ‘˜)
Definition 3.4. A KA scheme has pseudorandom second mes-
sages if ğ‘š2 is indistinguishable from random, even to someone
who chooses ğ‘š1 adversarially. Formally, the following distributions
are indistinguishable for all PPT A:
(ğ‘£ğ‘–ğ‘’ğ‘¤,(cid:101)ğ‘š1) â† A
ğ‘š2 = KA.msg2(ğ‘,(cid:101)ğ‘š1)
ğ‘ â† KA.R
return (ğ‘£ğ‘–ğ‘’ğ‘¤, ğ‘š2)
(ğ‘£ğ‘–ğ‘’ğ‘¤,(cid:101)ğ‘š1) â† A
ğ‘š2 â† KA.M
return (ğ‘£ğ‘–ğ‘’ğ‘¤, ğ‘š2)
3.2 Diffie-Hellman Instantiation
The classic Diffie-Hellman key agreement protocol is a one-round
KA protocol (meaning that the two messages can be sent simulta-
neously). It is parameterized by a cyclic group G = âŸ¨ğ‘”âŸ© of order ğ‘,
and defined as:
â€¢ KA.R = Zğ‘ (space of private randomness)
â€¢ KA.M = G (space of second partyâ€™s protocol messages)
â€¢ KA.msg1(ğ‘) = ğ‘”ğ‘
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1170CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Mike Rosulek and Ni Trieu
â€¢ KA.msg2(ğ‘) = ğ‘”ğ‘
In this work we consider the â€œhashedâ€ variant of DH which is secure
under the computational Diffie-Hellman (CDH) assumption in the
random oracle model. Let ğ» : G â†’ {0, 1}â„“ be a random oracle,
then:
â€¢ KA.K = {0, 1}â„“ (space of output keys)
â€¢ KA.key1(ğ‘, ğ‘”ğ‘) = ğ»((ğ‘”ğ‘)ğ‘)
â€¢ KA.key2(ğ‘, ğ‘”ğ‘) = ğ»((ğ‘”ğ‘)ğ‘)
Elligator DHKA. Modern applications of DHKA use elliptic curves
for the underlying cyclic group, due to their compact size (e.g.,
group elements with representations roughly 2ğœ… bits, for ğœ… bits of
security). However, encodings of elliptic curve elements are rather
conspicuous, and can easily be distinguished from uniformly dis-
tributed strings. Our PSI protocols require the KA protocol messages
(specifically, ğ‘š2) to be pseudorandom as strings.
In [6], Bernstein et al. explicitly consider the question of encoding
elliptic curve elements so that the resulting Diffie-Hellman protocol
has pseudorandom messages (viewed as strings). Formally, they
define an encoding mechanism called elligator with the following
properties:
â€¢ There are efficient encoding/decoding functions dec, enc which
are inverses, where im(enc) âŠ† {0, 1}ğ‘¡ is a set of strings and
im(dec) âŠ† E is a subset of elliptic curve points.
â€¢ The size of im(enc) is very close to 2ğ‘¡, so that the uniform dis-
tribution over encodings is indistinguishable from the uniform
distribution over {0, 1}ğ‘¡
â€¢ The size of im(dec) is a constant fraction (typically close to 1/2)
â€¢ It is possible to efficiently test for membership in im(enc) (and
of the size of the elliptic curve.
hence also in im(dec)).
After defining such an elligator encoding method for Edwards
curves, Bernstein et al. propose to modify Diffie-Hellman key agree-
ment as follows:
â€¢ KA.R = {ğ‘Ÿ âˆˆ Zğ‘ | ğ‘”ğ‘Ÿ âˆˆ im(dec)}.
â€¢ KA.M = {0, 1}ğ‘¡
â€¢ KA.msg1(ğ‘) = enc(ğ‘”ğ‘)
â€¢ KA.msg2(ğ‘) = enc(ğ‘”ğ‘)
â€¢ KA.key1(ğ‘, ğ‘ ğ‘) = ğ»(dec(ğ‘ ğ‘)ğ‘)
â€¢ KA.key2(ğ‘, ğ‘ ğ‘) = ğ»(dec(ğ‘ ğ‘)ğ‘)
In other words, the parties condition their randomness to always
sample a point in the â€œelligator subsetâ€ im(dec) of the curve. In prac-
tice, each party would repeatedly sample an exponent ğ‘Ÿ â† Zğ‘ and
retry until finding one in the elligator subset. Since |im(dec)|/|E| is
constant, only a constant number of trials is needed before success-
fully hitting im(dec). Furthermore, the concrete security of DHKA
is degraded by only a small constant factor.
Due to the desired properties of the elligator encoding, the pro-
tocol messages are uniform in im(enc) and hence pseudorandom
in {0, 1}ğ‘¡.
Security properties. The security of hashed DHKA against an eaves-
dropper (Definition 3.2) is standard and follows from the CDH
assumption.
The â€œpseudorandom second messagesâ€ property (Definition 3.4)
of the elligator-DHKA protocol follows from the properties of el-
ligator discussed above. Note that in DHKA, ğ‘š2 doesnâ€™t depend
on ğ‘š1, so the adversaryâ€™s ability to choose ğ‘š1 in Definition 3.4 is
irrelevant.
Finally, the â€œnon-malleableâ€ property (Definition 3.3) of hashed
DHKA is equivalent to the oracle DH (ODH) assumption proposed
by Abdalla, Bellare, and Rogaway [2]. Roughly speaking, the ODH
assumption is that ğ‘”ğ‘, ğ‘”ğ‘, ğ»(ğ‘”ğ‘ğ‘) is indistinguishable from random
in the presence of an oracle for ğ‘‹ â†¦â†’ ğ»(ğ‘‹ ğ‘), as long as the distin-
guisher doesnâ€™t query that oracle on ğ‘”ğ‘. Here ğ» is the hash function
/ random oracle used in hashed DHKA. In [2] it is shown that the
ODH assumption holds in the generic group model when ğ» is a
random oracle.
4 MALICIOUS PSI FROM KEY AGREEMENT
In this section we present our main result, a malicious 2-party PSI
protocol. Our protocol requires the following building blocks:
â€¢ A 2-round KA protocol KA. Recall that KA.M is the space of
possible protocol messages. We require KA.M = F for some finite
field F, and that the KA protocol has pseudorandom messages in
this field. We also require the KA protocol to be non-malleable
in the sense of Definition 3.3.
â€¢ Parties have oracle access to an ideal permutation Î , Î âˆ’1 defined
over the same field F. We write Î Â± to refer to the two functions
Î , Î âˆ’1 collectively. Parties also have access to random oracles
ğ»1, ğ»2.
As a concrete example, we can choose hashed DHKA with elligator
encodings (see Section 3.2), whose protocol messages are pseudo-
random in {0, 1}â„“, and then set F be to the field ğºğ¹(2â„“). Under the
ODH assumption, hashed DHKA is also non-malleable. We give
more details about instantiating our protocol with Diffie-Hellman
in Section 5.
Protocol Overview. Following the overview given in Section 1, the
sender sends the first KA message. Intuitively, the receiver prepares
a polynomial ğ‘ƒ such that ğ‘ƒ(ğ‘¦ğ‘–) is a KA response that it chooses,
for each ğ‘¦ğ‘– in its set. If KA responses are pseudorandom then the
polynomial ğ‘ƒ hides the identities of the ğ‘¦ğ‘–-values.
However, for technical reasons we make the receiver prepare a
polynomial such that ğ‘ƒ(ğ»1(ğ‘¦ğ‘–)) = Î âˆ’1(ğ‘šğ‘–) where ğ»1 is a random
oracle, Î  is an ideal permutation, and ğ‘šğ‘– is the KA response. The
presence of random oracle ğ»1 helps the simulator extract from a
corrupt receiver (from observing its ğ»1-queries). The presence of
the ideal permutation helps the simulator (against both corrupt
parties), by programming Î  to output KA messages chosen by the
simulator.
Finally, the sender can interpret Î (ğ‘ƒ(ğ»1(ğ‘¥ğ‘–))) as a KA response,
for each ğ‘¥ğ‘– in its set, and compute the corresponding KA output
ğ‘˜ğ‘–. For each ğ‘¥ğ‘–, the sender sends ğ»2(ğ‘¥ğ‘–, ğ‘˜ğ‘–) to the receiver. The
presence of this random oracle again helps the simulator extract
from a corrupt sender.
The protocol is described formally in Figure 4. interpolF denotes
polynomial interpolation over field F, as discussed in Section 2.3.
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1171Compact and Malicious Private Set Intersection for Small Sets
CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Parameters: finite field F
KA protocol KA with KA.M = F and |KA.K| â‰¥ 2ğœ…
ideal permutation Î , Î âˆ’1 : F â†’ F
random oracles ğ»1 : {0, 1}âˆ— â†’ F,
ğ»2 : {0, 1}âˆ— Ã— F â†’ {0, 1}2ğœ…
Receiver
ğ‘Œ = {ğ‘¦1, . . . , ğ‘¦ğ‘›} âŠ† {0, 1}âˆ—
Sender
ğ‘‹ = {ğ‘¥1, . . . , ğ‘¥ğ‘›} âŠ† {0, 1}âˆ—
1. ğ‘ â† KA.R
2. ğ‘š = KA.msg1(ğ‘)
ğ‘š
3.
4.
ğ‘ƒ
for ğ‘– âˆˆ [ğ‘›]:
ğ‘ğ‘– â† KA.R
ğ‘šâ€²
ğ‘– = KA.msg2(ğ‘ğ‘–, ğ‘š)
ğ‘“ğ‘– = Î âˆ’1(ğ‘šâ€²
ğ‘–)
ğ‘ƒ = interpolF
(cid:16){(ğ»1(ğ‘¦ğ‘–), ğ‘“ğ‘–) | ğ‘¦ğ‘– âˆˆ ğ‘Œ}(cid:17)
(abort if deg(ğ‘ƒ) < 1)
5. for ğ‘– âˆˆ [ğ‘›]:
ğ‘˜ğ‘– = KA.key1(ğ‘, Î (ğ‘ƒ(ğ»1(ğ‘¥ğ‘–))))
ğ‘˜â€²
ğ‘– = ğ»2(ğ‘¥ğ‘–, ğ‘˜ğ‘–)
1, . . . , ğ‘˜â€²
ğ‘›} (shuffled)
ğ¾
6. ğ¾ = {ğ‘˜â€²
output(cid:110)ğ‘¦ğ‘–
(cid:12)(cid:12)(cid:12) ğ»2
(cid:16)ğ‘¦ğ‘–,KA.key2(ğ‘ğ‘–, ğ‘š)(cid:17) âˆˆ ğ¾(cid:111)
7.
Figure 4: Our malicious PSI protocol.
Lemma 4.1. The protocol of Figure 4 is UC-secure against a mali-
cious sender, if KA has pseudorandom messages (Definition 3.4), Î Â±
is an ideal permutation, and ğ»2 is a random oracle.
Before giving the proof, we first sketch the main idea of the
simulator. When the simulator sees the set ğ¾ provided by the ad-
versary, it needs to extract a set of items that â€œexplainsâ€ the effect
of ğ¾ on the honest party. The elements of ğ¾ are supposed to have
the form ğ»2(ğ‘¥ğ‘–, ğ‘˜ğ‘–), where ğ‘˜ğ‘– is the â€œcorrectâ€ KA output for item
ğ‘¥ğ‘–. The simulator observes all queries to ğ»2, so it can see which
ğ»2-outputs are placed into ğ¾ â€” but how can the simulator check
that some ğ‘˜ğ‘– is the â€œcorrectâ€ KA output corresponding to item ğ‘¥ğ‘–?
To do this, we let the simulator program Î  so that every output of
Î  is a KA message for which it knows the randomness. Now for
any ğ‘¥, the simulator can compute the corresponding KA output,
using the KA randomness it associates with Î (ğ‘ƒ(ğ»1(ğ‘¥))).
Proof. We first describe the behavior of the simulator.
â€¢ The simulator honestly plays the role of random oracle ğ»2. For ev-
ery query ğ»2(ğ‘¥, ğ‘˜) made by the adversary, the simulator records
the input-output tuple (ğ‘¥, ğ‘˜, ğ»2(ğ‘¥, ğ‘˜)) in a set O2.
â€¢ For every query of the form Î (ğ‘“ ) made after the message ğ‘š is
sent, the simulator chooses a random ğ‘ ğ‘“ â† KA.R and simulates
KA.msg2(ğ‘ ğ‘“ , ğ‘š) as the output of Î (ğ‘“ ).
â€¢ In step 4, the simulator sends a uniform polynomial ğ‘ƒ.
â€¢ Upon receiving ğ¾ in step 6, the simulator defines the set
Ëœğ‘‹ = {ğ‘¥ | âˆƒğ‘˜â€² :(cid:16)ğ‘¥, KA.key2(ğ‘ğ‘ƒ (ğ»1(ğ‘¥)), ğ‘š), ğ‘˜â€²(cid:17) âˆˆ O2 and ğ‘˜â€² âˆˆ ğ¾}
and sends Ëœğ‘‹ to the ideal PSI functionality (which causes the
honest receiver to obtain output Ëœğ‘‹ âˆ© ğ‘Œ).
We prove that this simulation is indistinguishable from the real
interation via the following sequence of hybrids.
Hybrid 0: The real interaction, with the receiver running honestly
with input ğ‘Œ and giving its output to the environment according to
the protocol specification.
Hybrid 1: Same as the previous hybrid, except for how Î Â± is
simulated. A query to Î  (resp. Î âˆ’1) is fresh if it was never made
before, and its value is not determined by previous queries to Î âˆ’1
(resp. Î ) and the fact that Î /Î âˆ’1 are inverses. In this hybrid, all
fresh queries (by either the adversary or honest party) to Î  and Î âˆ’1
are answered with a uniformly random response. The interaction
aborts if this leads to Î  or Î âˆ’1 repeating an output. This change is
indistinguishable from the standard permutation switching lemma.
Hybrid 2: Same as the previous hybrid, except for how ğ‘ƒ is gen-
erated. In step 3, ğ‘ƒ is generated by interpolating through points
of the form Î âˆ’1(KA.msg2(ğ‘ğ‘–, ğ‘š)). In this hybrid we abort if these
queries to Î âˆ’1 are not fresh â€” i.e., if KA.msg2(ğ‘ğ‘–, ğ‘š) previously
occurred as either an adversaryâ€™s query to Î âˆ’1 or as an output of
an adversaryâ€™s query to Î .
If the KA.msg2(ğ‘ğ‘–, ğ‘š) terms were independently and uniformly
random, then this abort would happen with probability bounded by
ğ‘›ğ‘/|F|, when the adversary makes ğ‘ oracle queries. By the pseudo-
random property of the KA scheme, each KA.msg2(ğ‘ğ‘–, ğ‘š) is indistin-
guishable from random, so the abort probability is negligibly close
to ğ‘›ğ‘/|F|. Either way, the probability is negligible, so the hybrids
are indistinguishable.
Now conditioned on not aborting, we have that each Î âˆ’1(KA.msg2(Â· Â· Â·))
is a fresh and uniform value. Hence, ğ‘ƒ is distributed as a uniform
polynomial, independent of the ğ‘¦ğ‘– values. Then this interaction is
identical to one in which we first choose a uniform polynomial ğ‘ƒ
and then later program Î (ğ‘ƒ(ğ»1(ğ‘¦ğ‘–))) = KA.msg2(ğ‘ğ‘–, ğ‘š) for each
ğ‘¦ğ‘– âˆˆ ğ‘Œ (aborting if Î  is already programmed on this point).
Hybrid 3: Same as the previous hybrid, except for how Î  is simu-
lated. For every fresh query Î (ğ‘“ ) made after the adversary sends ğ‘š,
sample ğ‘ ğ‘“ â† KA.R and respond with KA.msg2(ğ‘ ğ‘“ , ğ‘š) (instead of
responding with a uniform result). This change is indistinguishable
by the pseudorandomness property of KA.
Note that we have already been simulating Î (ğ‘ƒ(ğ»1(ğ‘¦ğ‘–))) in this
way for ğ‘¦ğ‘– âˆˆ ğ‘Œ, but with different variable names (randomness ğ‘ğ‘–
rather than ğ‘ ğ‘“ for ğ‘“ = ğ‘ƒ(ğ»1(ğ‘¦ğ‘–))). If we rename randomness ğ‘ğ‘– (for
ğ‘¦ğ‘– âˆˆ ğ‘Œ) to ğ‘ğ‘ƒ (ğ»1(ğ‘¦ğ‘–)) then we program Î  in the same way for all
inputs, with no special case for the elements of ğ‘Œ. In doing so, the
honest partyâ€™s output is computed via:
(cid:16)ğ‘¦ğ‘–, KA.key2(ğ‘ğ‘ƒ (ğ»1(ğ‘¦ğ‘–)), ğ‘š)(cid:17) âˆˆ ğ¾}
{ğ‘¦ğ‘– âˆˆ ğ‘Œ | ğ»2
Hybrid 4: The honest receiver queries ğ»2 to determine its final
output (in the expression above). In this hybrid we abort if one of
those ğ»2 queries is fresh (meaning that the adversary did not make
that query) and yet the result is in ğ¾. The probability of a fresh
queryâ€™s output being an element of ğ¾ is |ğ¾|/|F| = ğ‘›/|F|, which is
negligible. Therefore this change is indistinguishable.
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1172CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Mike Rosulek and Ni Trieu
Suppose the final hybrid maintains the list O2 as described earlier
â€” i.e., (ğ‘¥, ğ‘˜, ğ‘˜â€²) âˆˆ O2 means that the adversary queried ğ»2(ğ‘¥, ğ‘˜) and
got a result ğ‘˜â€². Since the receiver only â€œrecognizesâ€ values that the
adversary has already queried to ğ»2, this final hybrid is identical
to one in which the receiverâ€™s output is computed as:
{ğ‘¦ğ‘– âˆˆ ğ‘Œ | âˆƒğ‘˜â€² :(cid:16)ğ‘¦ğ‘–, KA.key2(ğ‘ğ‘ƒ (ğ»1(ğ‘¦ğ‘–)), ğ‘š), ğ‘˜â€²(cid:17) âˆˆ O2 and ğ‘˜â€² âˆˆ ğ¾}
ğ‘Œ âˆ© {ğ‘¥ | âˆƒğ‘˜â€² :(cid:16)ğ‘¥, KA.key2(ğ‘ğ‘ƒ (ğ»1(ğ‘¥)), ğ‘š), ğ‘˜â€²(cid:17) âˆˆ O2 and ğ‘˜â€² âˆˆ ğ¾}
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
But this is logically equivalent to:
Ëœğ‘‹
Here Ëœğ‘‹ is the set that the simulator can define. Hence this hybrid
is identical to the ideal interaction involving the simulator defined
earlier.
â–¡
Lemma 4.2. The protocol of Figure 4 is UC-secure against a ma-
licious receiver, if KA is non-malleable (Definition 3.3), |KA.K| â‰¥ 2ğœ…,