## HTTP 请求的发送 {#15.html#http-}HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过stream 二进制流的方式传给对方。当然，到了 TCP层，它会把二进制流变成一个的报文段发送给服务器。在发送给每个报文段的时候，都需要对方有一个回应ACK，来保证报文可靠地到达了对方。如果没有回应，那么 TCP这一层会进行重新传输，直到可以到达。同一个包有可能被传了好多次，但是HTTP 这一层不需要知道这一点，因为是 TCP 这一层在埋头苦干。TCP层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到IP 头里面，交给 IP 层进行传输。IP 层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送 ARP协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC头，发送出去即可；如果不在同一个局域网，就需要发送到网关，还要需要发送ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC头，发送出去。网关收到包发现 MAC 符合，取出目标 IP地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC地址，将包发给下一跳路由器。这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送ARP，获得这个目标地址的 MAC 地址，将包发出去。目标的机器发现 MAC 地址符合，就将包收起来；发现 IP 地址符合，根据 IP头中协议项，知道自己上一层是 TCP 协议，于是解析 TCP的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个ACK，如果不是就丢弃。TCP 头里面还有端口号，HTTP的服务器正在监听这个端口号。于是，目标机器自然知道是 HTTP服务器这个进程想要这个包，于是将包发给 HTTP 服务器。HTTP服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。
## HTTP 返回的构建 {#15.html#http-}HTTP 的返回报文也是有一定格式的。这也是基于 HTTP 1.1 的。![](Images/265b1b8949727795297dcdfcd26d7e4e.png){savepage-src="https://static001.geekbang.org/resource/image/1c/c1/1c2cfd4326d0dfca652ac8501321fac1.jpg"}状态码会反应 HTTP请求的结果。"200"意味着大吉大利；而我们最不想见的，就是"404"，也就是"服务端无法响应这个请求"。然后，短语会大概说一下原因。接下来是返回首部的**key value**。这里面，**Retry-After**表示，告诉客户端应该在多长时间以后再次尝试一下。"503错误"是说"服务暂时不再和这个值配合使用"。在返回的头部里面也会有**Content-Type**，表示返回的是 HTML，还是 JSON。构造好了返回的 HTTP 报文，接下来就是把这个报文发送出去。还是交给 Socket去发送，还是交给 TCP 层，让 TCP 层将返回的HTML，也分成一个个小的段，并且保证每个段都可靠到达。这些段加上 TCP 头后会交给 IP层，然后把刚才的发送过程反向走一遍。虽然两次不一定走相同的路径，但是逻辑过程是一样的，一直到达客户端。客户端发现 MAC 地址符合、IP 地址符合，于是就会交给 TCP层。根据序列号看是不是自己要的报文段，如果是，则会根据 TCP头中的端口号，发给相应的进程。这个进程就是浏览器，浏览器作为客户端也在监听某个端口。当浏览器拿到了 HTTP 的报文。发现返回"200"，一切正常，于是就从正文中将HTML 拿出来。HTML是一个标准的网页格式。浏览器只要根据这个格式，展示出一个绚丽多彩的网页。这就是一个正常的 HTTP 请求和返回的完整过程。
## HTTP 2.0 {#15.html#http-2-0}当然 HTTP 协议也在不断地进化过程中，在 HTTP1.1 基础上便有了 HTTP 2.0。HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP的头，而且不考虑 pipeline模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。为了解决这些问题，HTTP 2.0 会对 HTTP的头进行一定的压缩，将原来每次都要携带的大量 key value在两端建立一个索引表，对相同的头只发送索引表中的索引。另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。HTTP 2.0还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有**Header帧**，用于传输 Header 内容，并且会开启一个新的流。再就是**Data帧**，用来传输正文实体。多个 Data 帧属于同一个流。通过这两种机制，HTTP 2.0的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送，然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。我们来举一个例子。假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。![](Images/dc01bd67b9b1c3ecf5eefc5898437f0f.png){savepage-src="https://static001.geekbang.org/resource/image/0b/7a/0bc51f8f887aae04ef89a1a88cb5a17a.jpg"}HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP连接中。![](Images/8c2e5aada0f9cd74a33aef90a273f16e.png){savepage-src="https://static001.geekbang.org/resource/image/03/dd/03d4a216c024a9e761ed43c6787bf7dd.jpg"}HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg等通过一个数据链接进行传输，能够加快页面组件的传输速度。
## QUIC 协议的"城会玩" {#15.html#quic-}HTTP 2.0 虽然大大增加了并发性，但还是有问题的。因为 HTTP 2.0 也是基于TCP 协议的，TCP 协议在处理包时是有严格顺序的。当其中一个数据包遇到问题，TCP连接需要等待这个包完成重传之后才能继续进行。虽然 HTTP 2.0 通过多个stream，使得逻辑上一个 TCP连接上的并行内容，进行多路数据的传输，然而这中间并没有关联的数据。一前一后，前面stream 2 的帧没有收到，后面 stream 1 的帧也会因此阻塞。于是，就又到了从 TCP 切换到 UDP，进行"城会玩"的时候了。这就是 Google 的QUIC 协议，接下来我们来看它是如何"城会玩"的。
### 机制一：自定义连接机制 {#15.html#-}我们都知道，一条 TCP 连接是由四元组标识的，分别是源 IP、源端口、目的IP、目的端口。一旦一个元素发生变化时，就需要断开重连，重新连接。在移动互联情况下，当手机信号不稳定或者在WIFI 和移动网络切换时，都会导致重连，从而进行再次的三次握手，导致一定的时延。这在 TCP 是没有办法的，但是基于 UDP，就可以在 QUIC自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP或者端口变化的时候，只要 ID 不变，就不需要重新建立连接。
### 机制二：自定义重传机制 {#15.html#-}前面我们讲过，TCP为了保证可靠性，通过使用**序号**和**应答**机制，来解决顺序问题和丢包问题。任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包。那怎么样才算超时呢？还记得我们提过的**自适应重传算法**吗？这个超时是通过**采样往返时间RTT**不断调整的。其实，在 TCP 里面超时的采样存在不准确的问题。例如，发送一个包，序号为100，发现没有返回，于是再发送一个 100，过一阵返回一个ACK101。这个时候客户端知道这个包肯定收到了，但是往返时间是多少呢？是 ACK到达的时间减去后一个 100 发送的时间，还是减去前一个 100发送的时间呢？事实是，第一种算法把时间算短了，第二种算法把时间算长了。QUIC也有个序列号，是递增的。任何一个序列号的包只发送一次，下次就要加一了。例如，发送一个包，序号是100，发现没有返回；再次发送的时候，序号就是 101 了；如果返回的 ACK100，就是对第一个包的响应。如果返回 ACK 101 就是对第二个包的响应，RTT计算相对准确。但是这里有一个问题，就是怎么知道包 100 和包 101发送的是同样的内容呢？QUIC 定义了一个 offset 概念。QUIC既然是面向连接的，也就像 TCP一样，是一个数据流，发送的数据在这个数据流里面有个偏移量offset，可以通过 offset 查看数据发送到了哪里，这样只要这个 offset的包没有来，就要重发；如果来了，按照 offset 拼接，还是能够拼成一个流。![](Images/93cb0f855680d96b32122d87bb741fd3.png){savepage-src="https://static001.geekbang.org/resource/image/da/c4/da2af1e419db66929dc85107c7250fc4.jpg"}
### 机制三：无阻塞的多路复用 {#15.html#-}有了自定义的连接和重传机制，我们就可以解决上面 HTTP 2.0 的多路复用问题。同 HTTP 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP请求。但是，QUIC 是基于 UDP 的，一个连接上的多个 stream之间没有依赖。这样，假如 stream2 丢了一个 UDP 包，后面跟着 stream3的一个 UDP 包，虽然 stream2 的那个包需要重传，但是 stream3的包无需等待，就可以发给用户。