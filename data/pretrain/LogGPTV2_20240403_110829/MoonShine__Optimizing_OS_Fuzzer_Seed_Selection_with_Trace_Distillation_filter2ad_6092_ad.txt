Distillation
Method
Mutations/sec
I+E
E
RANDOM
Default
24,230
23,140
19,120
18,200
95.0%
91.6%
75.7%
72.1%
Default
MoonShine(E)
Moonshine(I+E)
Undistilled
335
305
296
160
Table 3: Coverage recovered from original traces after 30 min-
utes of fuzzing. I+E refers to Moonshine(I+E) strategy and E
refers to MoonShine(E).
Table 5: Syzkaller’s executions/sec measured after 2 hours of
fuzzing across seeds generated from our different distillation
algorithms. Our seed programs included LTP, Kselftests, Glibc
teststuites, and Posix testsuites
Trace w/
Coverage
(mins)
Trace w/o
Coverage
(mins)
Distillation
(mins)
3.8
13.3
7.7
25.2
4.3
8.5
10.5
18.3
Source
L+K
G
P
8.5
28.4
20.4
Combined
61.3
Table 4: Breakdown of MoonShine performance across three
seed program groups. The ﬁrst is a combined LTP (L) +
Kselftests(K), followed by Glibc (G) and ﬁnally Posix Test
Suite (P).
Result 4: MoonShine collects and distills 110 giga-
bytes of raw program traces in under 80 minutes.
5.6
Is distillation useful? (RQ5)
We now evaluate our claim that without distillation the
performance of the fuzzer will decrease signiﬁcantly.
We construct 5 different sets of seeds where the aver-
age number of calls for each seed increases by 146 but
the number of seeds stay ﬁxed at 500. We then in-
strument Syzkaller to record any mutations it performs
on its programs. Each of our sets of seeds is used by
Syzkaller as it fuzzes Linux 4.14-rc4 for 2 hours. Figure
6 shows the number of mutations it performs over the two
hours. We observe that as the average length increases,
the number of mutations decrease signiﬁcantly. When
using seeds whose average call length is 730, Syzkaller
performed less than 100 mutations in one hour, which is
prohibitively slow.
We now assess the impact that MoonShine’s seeds
have on Syzkaller’s overall performance. We measured
the mutations per second achieved by Syzkaller through-
out its 2 hour execution when using seeds generated
by Moonshine(I+E), MoonShine(E), and with undis-
tilled seeds. The results are summarized in Table 5.
Syzkaller’s baseline performance was 335 mutations per
second. When using seeds generated by MoonShine(E)
and Moonshine(I+E), the performance only decreased
10%. However, when Syzkaller used undistilled seeds,
its mutation rate decreased by 53%.
Result 5: Running Syzkaller with undistilled seeds
slows the mutation rate by 53%. Running Syzkaller
on distilled seeds only reduces the mutation rate to
88.4% of what is achieved by default Syzkaller.
738    27th USENIX Security Symposium
USENIX Association
alloc_len, Thread 2 calls rename which performs
a memcpy to change dentry->d_name.name. When
Thread 1 resumes, dentry->d_name.name is different
so the subsequent strcpy will overﬂow the struct if the
size of the name has increased.
After 4.5 hours of fuzzing with seeds distilled using
Moonshine(I+E), Syzkaller reported a KASAN: slab out
of bounds in strcpy crash in inotify_handle_event().
The program that triggered the bug is listed in Figure 8.
Lines 2 and 3 initialize an inotify instance to watch
the current directory for all events. Line 5 creates a ﬁle
named "short" and line 6 closes it.
In line 7, the ﬁle
is renamed to the longer name "long_name." The rea-
son Syzkaller triggered this bug is because it will ran-
domly schedule calls on different threads. In this case,
the rename and close were run in parallel.
How Distilled Seeds Helped. The program in Fig-
ure 8 is from the inotify02 testcase in LTP. The goal
of the test case was to test the close, create, and rename
events to ensure correct semantic behavior. When using
only its manual rules, Syzkaller never generated the rel-
evant sequence of calls for this bug to trigger. This is
because its manual rules are weighted to select calls that
share semantic types.
In this case, the rename, close
and inotify_add_watch did not share semantic types,
but MoonShine’s distillation algorithm could detect that
each of these calls contributed new coverage as during
their control paths each triggered an inotify event. Fur-
thermore, MoonShine observed inotify_add_watch is
an implicit dependency of both rename and close so the
calls were merged into one program.
6.2 Integer Overﬂow in fcntl
The pipe system call creates an undirected data channel
that allows communication between two processes. By
default, the size of a pipe is the same as the system limit
which is typically 4096 bytes. The size can be increased
by calling fcntl with the command F_SETPIPE_SZ.
However, calling this command with size 0 causes an
unsigned long long overﬂow. Figure 9 shows the rel-
evant excerpts from the call stack.
The root cause of the error happens in line 12. Since
size is 0, nr_pages is also set to 0 which means that
fls_long(-1) returns 64, resulting in the undeﬁned ex-
pression (1UL d_name.name). After computing
USENIX Association
27th USENIX Security Symposium    739
Thread 1: fs/notify/inotify/inotify_fsnotify.c
int i n o t i f y _ h a n d l e _ e v e n t ()
{
s t r u c t i n o t i f y _ e v e n t _ i n f o * event ;
int len = 0;
int a l l o c _ l e n = s i z e o f ( s t r u c t
i n o t i f y _ e v e n t _ i n f o ) ;
if ( dentry - > d _ n a m e . name ) {
len = s t r l e n ( dentry - > d _ n a m e . name ) ;
a l l o c _ l e n += len + 1;
}
/* I n t e r r u p t e d by T h r e a d 2 */
Thread 2: fs/dcache.c
s t a t i c void c o p y _ n a m e ()
{
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
long p i p e _ f c n t l (...) {
...
case F _ S E T P I P E _ S Z :
p i p e _ s e t _ s i z e ( pipe , arg ) ; // arg = 0
...
long p i p e _ s e t _ s i z e ( pipe , 0) {
...
...
r o u n d _ p i p e _ s i z e (0) ;
u n s i g n e d int r o u n d _ p i p e _ s i z e (0) {
...
n r _ p a g e s = ( size + P A G E _ S I Z E - 1) >>
P A G E _ S H I F T ; // = 0 UL
r e t u r n (1 UL  d_iname , target - > d _ n a m e . name ,
target - > d _ n a m e . len + 1) ;
dentry - > d _ n a m e . name = dentry - > d _ i n a m e ;
Figure 9: fcntl undeﬁned behavior when called with com-
mand F_SETPIPE_SZ and size of 0.
}
}
Thread 1 (continued)
/* E x e c u t i o n R e s u m e d */
event = k m a l l o c ( alloc_len , G F P _ K E R N E L ) ;
event - > n a m e _ l e n = len ;
if ( len )
s t r c p y ( event - > name , dentry - > d _ n a m e . name ) ;
7:
inotify_handle_event()
bug
in
Figure
fs/notify/fsnotify.c.
computes
alloc_len, Thread 2 increases the length of ﬁlename by
copying a larger string to dentry->d_name.name, causing the
overﬂow in strcpy.
After Thread
1
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
int main (...)
{
int p i p e _ f d s [2] , t e s t _ f d ;
...
for ( lc = 0; T E S T _ L O O P I N G ( lc ) ; lc ++) {
pipe ( p i p e _ f d s ) ;
t e s t _ f d = p i p e _ f d s [1];
TEST ( fcntl ( test_fd , F _ G E T P I P E _ S Z ) ) ;
o r i g _ p i p e _ s i z e = T E S T _ R E T U R N ;
TEST ( fcntl ( test_fd , F _ S E T P I P E _ S Z ,
n e w _ p i p e _ s i z e ) ) ;
...
}
...
}
1:
2:
3:
4:
5:
6:
7:
mmap (...)
r0 = i n o t i f y _ i n i t ()
r1 = i n o t i f y _ a d d _ w a t c h ( r0 ,
&(0 x 7 f 0 0 0 0 0 0 0 0 0 0 ) = " 2 e " , 0 xfff )
chmod (&(0 x 7 f 0 0 0 0 0 0 1 0 0 0 ) = " 2 e " , 0 x1ed )
r2 = creat (&(0 x 7 f 0 0 0 0 0 0 2 0 0 0 ) = " short " ,
0 x1ed )
close ( r2 )
r e n a m e (&(0 x 7 f 0 0 0 0 0 0 a 0 0 0 ) = " short " ,
&(0 x 7 f 0 0 0 0 0 0 6 0 0 0 -0 xa ) = " l o n g _ n a m e " )
8:
close ( r0 )
Figure 8: Syzkaller program that caused the bug. We have in-
creased readability by truncating arguments and changing the
ﬁlenames from hex strings to "long_name" and "short." Criti-
cally, "long_name" is longer than "short."
a ﬁle descriptor corresponding to pipe. When execut-
ing the command, Syzkaller randomly chooses from the
collection of previously opened ﬁle descriptors so in or-
der to trigger this bug it must select both fcntl with the
command F_SETPIPE_SZ and ensure that pipe has al-
Figure 10: Relevant excerpt from fcntl30.c. Traces from this
program were distilled to form the fcntl pipe bug.
ready been executed. Whereas for the seed programs,
the application already knows that the fcntl command
should be associated with pipe so those two commands
are already in the same program.
7 Discussion
We have demonstrated that trace distillation can improve
kernel security by discovering new vulnerabilities efﬁ-
ciently. In this section, we describe some of the limita-
tions of our current prototype implementation and some
future directions that can potentially minimize these is-
sues.
7.1 Limitations
Lack of Inter-Thread Dependency Tracking. Moon-
Shine’s dependency tracking algorithm assumes that all
740    27th USENIX Security Symposium
USENIX Association
dependencies of a call are produced by the same thread
or a parent process. However, if a call depends on a
resource produced by a parallel thread or process, then
the current implementation of MoonShine cannot track
the dependency. While the programs producing the
traces used in this paper contained very few such inter-
process/thread dependencies, more complex programs