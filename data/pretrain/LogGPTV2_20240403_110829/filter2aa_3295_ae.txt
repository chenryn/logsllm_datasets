variable names for username and password.  Enter the login URL into the “Tar-
get form” box, and click “Learn form settings.”  A new dialog box will appear.  If
more than one form is available on the page, the auditor will need to select the
correct on from the “form name” pull-down list.  In the field list, find the form field
for the username, click on it, and then click on “Username” below.  Do the same
for the password field and button.  This instructs Brutus to use those two fields.
Click on the “Accept” button on that dialog box to return to Brutus’ form definition
screen.
Next the auditor needs to put in text that will appear on a successful login screen,
which will need to be obtained from the site owner.  This is required so that Bru-
tus will know when it has seen a successful login.  If possible, the auditor can
enter text which will only appear after a successful administrator-level login.  En-
ter this text in the “Primary response” field, and select the “this response is posi-
tive” option.  Click “OK” to return to the main Brutus screen.
© SANS Institute 2004, Author retains full rights.
Key fingerprint = AF19 FA27 2F94 998D FDB5 DE3D F8B5 06E4 A169 4E46
© SANS Institute 2004,
As part of GIAC practical repository.
Author retains full rights.
Herschel Gelman SANS GSNA Practical Assignment
Version 3.1 — Option 1
29
At this point Brutus is ready to scan the site.  Click on “Start” at the top of the
window.  Progress will be shown at the bottom of the screen.  Once Brutus has
finished its scan, the “Positive Authentication Results” section will show all user-
names and passwords that gave a successful login.  These should be verified
outside of Brutus, by attempting to actually log into the web application using
them.
If any usernames and passwords are found by Brutus, and they are verified to
work on the web application, the site fails this test.  If none are found, or if they
are found to be false positives, the site passes this test.
In addition, if there does not appear to be any account lockout procedures after a
number of incorrect login attempts, the site owner should receive a warning.
Test nature: Objective
Evidence: To be determined
Findings: To be determined
2.10  Verify Security of any Client-Side Javascript
Checklist Item Number: 010
Checklist Item Name: Verify Security of any Client-Side Javascript
Reference: OWASP Guide to Building Secure Web Applications and Web Serv-
ices, pages 32-33.
Risk: This test addresses vulnerability number 15 in section 1.2.3 of this docu-
ment.  Many web applications use Javascript that executes in the client’s browser
as a means of providing security.  For example, the Javascript could validate in-
put to ensure that invalid responses are never passed to the web server, or, in
the worst case, could actually check passwords.  Since it is trivial to view,
change, or remove these checks, they offer no real security.  For example, code
to check password in Javascript would require the correct password to appear in
the code sent to the browser.  The degree of exposure is considered to be me-
dium.  Many web sites have made this mistake, and it is extremely easy to ex-
ploit.  The severity of a successful exploit is medium-high.  In the worst case
scenario, poorly written Javascript controls could give an attacker administrative
access to the web site.
The net risk is therefore medium-high (3.5).
Testing Procedure/Compliance Criteria: For this test we will once again use
the mirror of the web site that we obtained with wget in test 007.  In this test, the
© SANS Institute 2004, Author retains full rights.
Key fingerprint = AF19 FA27 2F94 998D FDB5 DE3D F8B5 06E4 A169 4E46
© SANS Institute 2004,
As part of GIAC practical repository.
Author retains full rights.
Herschel Gelman SANS GSNA Practical Assignment
Version 3.1 — Option 1
30
auditor will use the same methods to search the files that was described in that
testing procedure, but in this case the search is for the string 
function validateInput () {
if (document.form.year.value 
If any such client-side scripting is found, the auditor should then see what hap-
pens if it is bypassed.  The easiest way to test this is to simply turn off Javascript
in the web browser so that it cannot run the validation functions.  If the applica-
tion is poorly written and relies on having client-side scripting enabled, then the
page will need to be edited, either by editing the mirrored copies on the auditor’s
computer, or through a intercepting proxy such as WebScarab or Achilles.  The
auditor can then assess what occurs when the form is used with invalid inputs,
and the protective Javascript code is no longer available.  It may be that server-
side processing checks all inputs again, or it may be that since the server-side
code never expected to see these invalid inputs, the application break in some
way that may be leveraged to gain additional access to the site.
If client-side scripting is used for security, and the subsequent testing shows that
the server-side scripting is not double-checking the input, the site fails this test.  If
client-side scripting is used, but the server appears to be double-checking the
© SANS Institute 2004, Author retains full rights.
Key fingerprint = AF19 FA27 2F94 998D FDB5 DE3D F8B5 06E4 A169 4E46
© SANS Institute 2004,
As part of GIAC practical repository.
Author retains full rights.
Herschel Gelman SANS GSNA Practical Assignment
Version 3.1 — Option 1
31
input as an extra level of protection, the site passes, but the site owner should be
warned.  If no client-side scripting is being used for protection, the site passes
this test.
Test nature: Objective
Evidence: To be determined
Findings: To be determined
© SANS Institute 2004, Author retains full rights.
Key fingerprint = AF19 FA27 2F94 998D FDB5 DE3D F8B5 06E4 A169 4E46
© SANS Institute 2004,
As part of GIAC practical repository.
Author retains full rights.
Herschel Gelman SANS GSNA Practical Assignment
Version 3.1 — Option 1
32
3 Audit Testing, Evidence, and Findings
The following sections describe the testing of the checklist items listed in section
2, as well as all findings from these tests.
3.1 Check For Hidden Comments in HTML
As described in section 2.1, WebScarab was used to spider the site and find all
files that have HTML comments within them.
3.1.1 Evidence
Below is a screenshot showing the results of the WebScarab spider of the site:
As shown in the results, eight files in the application contained HTML comments.
For each of these, right-clicking on the filename and selecting “View comments”
displayed a window containing all comments within that file.  All of these files had
identical comments; below is a screenshot of one of these files:
© SANS Institute 2004, Author retains full rights.
Key fingerprint = AF19 FA27 2F94 998D FDB5 DE3D F8B5 06E4 A169 4E46
© SANS Institute 2004,
As part of GIAC practical repository.
Author retains full rights.
Herschel Gelman SANS GSNA Practical Assignment
Version 3.1 — Option 1
33
3.1.2 Findings
As all comments were harmless, merely separating various sections of the
page—vertical menu bars from main content—there was no further testing re-
quired.
RESULT: PASS
3.2 Session Hijacking Via Cookie Manipulation
In this case, before beginning the test procedure given in section 2.2, I first cre-
ated a new user profile in Mozilla, the web browser used for this test.  This al-
lowed me to start with a clean slate, so to speak; the browser had all default set-
tings and not a single cookie had been set.  Following this, I used the procedure
described in section 2.2.
3.2.1 Evidence
I logged into an existing account on the site that had no special privileges.  After
logging in, the following cookie was set:
© SANS Institute 2004, Author retains full rights.
Key fingerprint = AF19 FA27 2F94 998D FDB5 DE3D F8B5 06E4 A169 4E46
© SANS Institute 2004,
As part of GIAC practical repository.
Author retains full rights.
Herschel Gelman SANS GSNA Practical Assignment
Version 3.1 — Option 1
34
3.2.2 Findings
As described in the compliance criteria section in the audit checklist, this cookie
shows that the site is using PHP’s built-in session management functions.  PHP’s
session management technique is well known, and is not vulnerable to hijacking
by manipulating the cookie data.  There are still session management issues to
be aware of, though.  For example, by default PHP stores the session data in the
shared temporary directory (/tmp) on the web server.  In a shared hosting envi-
ronment, the web hosting company needs to ensure that other web sites on the
same server do not have read access to other sites’ user session data.  If these
precautions are not taken, anyone webmaster using that same server could view
the cookie contents of any session on any web site.  As a supplemental test, I
checked the security settings of these files:
This screenshot shows that each session file is owned by the user associated
with that web site.  The permissions column shows that only the file owner is al-
lowed to read or write the file.  Therefore, other users are not able to view the
contents of AuditApp’s session files.  There is also no way to correlate the user-
name shown with a web site in order to set the session cookie to the value
shown in the filename.  Therefore, the web host has sufficiently protected the
session files.
RESULT: PASS
3.3 SQL Injection
The site owner gave us read access to the PHP source files that make up the
site, and I “grepped” them for calls to the mysql_query function.  After finding all
of the SQL queries, I then analyzed their safety.
3.3.1 Evidence
The very first query I saw in the code was an excellent example of unsafe coding
practices, in a file called authenticate.php.  It is expected to be called using a
© SANS Institute 2004, Author retains full rights.
Key fingerprint = AF19 FA27 2F94 998D FDB5 DE3D F8B5 06E4 A169 4E46
© SANS Institute 2004,
As part of GIAC practical repository.
Author retains full rights.
Herschel Gelman SANS GSNA Practical Assignment
Version 3.1 — Option 1
35
URL such as http://web.site.name/authenticate.php?auth=authstring.  The code
in question is below:
$auth = $_GET['auth'];
$result = @mysql_query("SELECT * FROM user_auth WHERE
auth='$auth'");
When 
the 
user 
visits 
the 
example 
URL 
given 
earlier 
(authenti-
cate.php?auth=authstring), the $auth variable in this code would be set to ‘auth-
string’.  This variable supplied by the user is then inserted directly into a SQL
query with no sanitization.  As the function of this script is to ensure that the user
knows the correct authentication string stored in the database, it is definitely vul-
nerable to attack.  If the user could set auth to be ’ OR 1=1, the SQL query
would become
SELECT * FROM user_auth WHERE auth='' OR 1=1
Instead of the desired result where the SQL results would be the row containing
the authentication string passed from the browser, the result set would be every
row in the user_auth table, since 1 is always equal to 1.  This is because the user
was allowed to send that single quote, closing the string that the site was trying
to test, and add a new clause to the query.  The code then checks to see if any
results were returned from this query, and if a result was returned, the code be-
lieves that the user supplied a valid authentication string.  In the modified version
of the query, there will always be rows returned from the query, because of the
1=1 clause.  This is a classic SQL injection security hole.
Because of the existence of this hole, I then created the phpinfo.php file dis-
cussed in the testing procedures, and viewed the setting for magic_quotes_gpc:
Because it is set to on, PHP should be automatically sanitizing all GET, POST,
and cookie data sent from the browser.
To verify this, I then attempted to exploit the hole found above.  I entered the fol-
lowing URL in the browser:
http://web.site.name/authenticate.php?auth='%20OR%201=1
As spaces are not legal characters in an HTTP request, they must be replaced
by the ‘%20’ string.  The resulting page from the site was an error page indicating
that I could not be authenticated.  To test this further, the site owner and I cre-
ated an alternate version of the authentication file, named authenticate2.php. 
© SANS Institute 2004, Author retains full rights.
Key fingerprint = AF19 FA27 2F94 998D FDB5 DE3D F8B5 06E4 A169 4E46
© SANS Institute 2004,
As part of GIAC practical repository.
Author retains full rights.
Herschel Gelman SANS GSNA Practical Assignment
Version 3.1 — Option 1
36
This one displayed the SQL query string on the page rather passing it to the
MySQL server (essentially, replacing the mysql_query function with a print-to-
page function).  For the purposes of this report, we also removed all site headers
and graphics from the document, leaving just the SQL query on the page.  After
trying the URL request again against this new version of the script, the server
gave the following page:
As the displayed string shows, the magic_quotes_gpc option escaped the single
quote at the beginning of our query.  Therefore, instead of ending that string and
allowing us to add an additional clause to the SQL query, MySQL would actually
be testing for the existence of the string \’ OR 1=1.  This therefore makes it
impossible to inject unexpected SQL queries.
Some MySQL users feel that they are already protected against SQL injection
attacks because MySQL does not allow for multiple commands in a single func-
tion call.  For example, we would not have been able to change the function to
SELECT * FROM user_auth WHERE auth=''; DROP TABLE users; for
example.  That injection attempt uses a semi-colon after closing the “auth” string
to add additional SQL commands—in this case, erasing all user information.  A
more likely malicious attack might be to create a new account with full permis-
sions to the site.  However, as the example found in this audit shows, even
though MySQL is automatically immune to this type of attack, there are certainly
other instances where SQL injection attacks can be used.  Using MySQL as the
database server does not automatically protect the site from all SQL injection
attacks.
3.3.2 Findings
Because the magic_quotes_gpc option was enabled, AuditApp is not currently
vulnerable to SQL injection attacks.  However, the code itself is not very safe; I
found many more examples of insecure SQL queries such as the one above.
Therefore, if the site owner ever switches to a different web host, he must be ex-
tremely careful that they turn magic_quotes_gpc on by default, or allow him to
enable it for his site.  In addition, he is also placing the security of his site in his
current web host’s configuration management process.  If they rebuild his server
and do not set this option, his site would instantly be vulnerable to a number of
SQL injection attacks.
© SANS Institute 2004, Author retains full rights.
Key fingerprint = AF19 FA27 2F94 998D FDB5 DE3D F8B5 06E4 A169 4E46
© SANS Institute 2004,
As part of GIAC practical repository.
Author retains full rights.
Herschel Gelman SANS GSNA Practical Assignment
Version 3.1 — Option 1
37
It is recommended that the code be modified to be safe regardless of this site
setting.  It is possible to write a short function that every PHP page calls before
processing any user data that checks the site’s magic_quotes_gpc setting.  If it is
enabled, the function does nothing.  If it is disabled, then the function escapes all
dangerous characters.
RESULT: PASS
3.4 Test for Adequate Safeguards Against Bandwidth Theft
As described in the testing procedure in section 2.4, I sent the following requests
directly to port 80 on the web server being tested:
GET /go.gif HTTP/1.1