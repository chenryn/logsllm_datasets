title:HookFinder: Identifying and Understanding Malware Hooking Behaviors
author:Heng Yin and
Zhenkai Liang and
Dawn Song
HookFinder: Identifying and Understanding Malware Hooking Behaviors
Heng Yin†‡
PI:EMAIL
Zhenkai Liang†
Dawn Song§†
PI:EMAIL PI:EMAIL
†Carnegie Mellon University, Pittsburgh, PA, USA
‡College of William and Mary, Williamsburg, VA, USA
§UC Berkeley, Berkeley, CA, USA
Abstract
Installing various hooks into the victim system is an
important attacking strategy employed by malware, in-
cluding spyware, rootkits, stealth backdoors, and others.
In order to defeat existing hook detectors, malware writ-
ers keep exploring new hooking mechanisms. However,
the current malware analysis procedure is painstak-
ing, mostly manual and error-prone.
In this paper,
we propose the ﬁrst systematic approach for automat-
ically identifying hooks and extracting hooking mech-
anisms. We propose a uniﬁed approach, ﬁne-grained
impact analysis, to identify malware hooking behaviors.
Our approach does not rely on any prior knowledge of
hooking mechanisms, and thus can identify novel hook-
ing mechanisms. Moreover, we devise a method using
semantics-aware impact dependency analysis to provide
a succinct and intuitive graph representation to illus-
trate hooking mechanisms. We have developed a proto-
type, HookFinder, and conducted extensive experiments
using representative malware samples from various cat-
egories. We have demonstrated that HookFinder can
correctly identify the hooking behaviors of all samples,
and provide accurate insights about their hooking mech-
anisms.
1 Introduction
The arms race between malware writers and malware
defenders is escalating. In order to evade malware de-
fense techniques, malware writers are always striving to
explore novel attacking techniques. In response, mal-
ware defenders must accurately and responsively under-
stand malware’s attacking vectors to gain an upper hand.
One important malware attacking vector is its hook-
ing mechanism. Malicious programs implant hooks for
many different purposes. Spyware may implant hooks to
get notiﬁed of the arrival of new sensitive data. For ex-
ample, keyloggers may install hooks to intercept users’
keystrokes; password thieves may install hooks to get
notiﬁed of the input of users’ passwords; network snif-
fers may install hooks to eavesdrop on incoming net-
work trafﬁc; and BHO-based adware may also install
hooks to capture URLs and other sensitive information
from incoming web pages.
In addition, rootkits may
implant hooks to intercept and tamper with critical sys-
tem information to conceal their presence in the system.
Malware with a stealth backdoor may also place hooks
on the network stack to establish a stealthy communica-
tion channel with remote attackers.
Several tools [4, 13, 24] detect hooking behaviors by
checking known memory regions for suspicious entries.
However, they need prior knowledge of how existing
malware implants hooks. Therefore, they become fu-
tile when malware uses new hooking mechanisms. This
concern is not hypothetical. Recently, new stealthy ker-
nel backdoors (deepdoor [26] and uay [30]) are reported
to employ a novel hooking mechanism for intercepting
the network stack. To set up hooks, they overwrite only a
small portion in NDIS data block. Without knowing this
particular hooking mechanism, we can hardly notice this
kind of hooks. In fact, all existing hook detection meth-
ods have failed to detect this kind of hooks.
In response to rapidly evolving malware techniques,
we need an effective and efﬁcient mechanism, to dis-
cover new hooking behaviors and understand their hook-
ing mechanisms. Unfortunately, the existing malware
analysis procedure is painstaking, mostly manual and
error-prone. Various code obfuscation techniques used
in malware make this manual process even more difﬁ-
cult. In this paper, we propose the ﬁrst systematic ap-
proach to this research problem.
In particular, given
an unknown malicious binary, we aim to identify if this
code installs any hooks into the system, and if so, pro-
vide detailed information about how it installs the hooks.
The intuition of our approach is that a hook implanted
by a piece of malicious code is one of the impacts (in
terms of memory and registers) that the malicious code
has made to the whole system, and this impact even-
tually affects the execution ﬂow of the system to jump
into the malicious code. In order to capture this distinct
behavior, we propose a novel approach, ﬁne-grained im-
pact analysis.
It works by identifying all the impacts
made by the malicious code, and keeping track of the
impacts ﬂowing across the whole system.
If the con-
trol ﬂow is affected by one of these impacts to jump into
the malicious code, then we determine that this transi-
tion is caused by a hook, which is installed by the mali-
cious code. To understand how this hook is implanted,
we devise a semantics-aware impact dependency analy-
sis mechanism. It performs dependency analysis on the
history of impact propagation, leveraged with OS-level
semantics.
We have prototyped our approach into a tool called
HookFinder, and evaluated it with eight malware pro-
grams. In the experiment, HookFinder identiﬁed hook-
ing behaviors of each malware sample within minutes.
For each identiﬁed hooking behavior, HookFinder gave
valuable insights and details about the underlying hook-
ing mechanism. The efﬁciency and effectiveness of
HookFinder makes it possible to automatically catego-
rize hooking behaviors of the large volume of malware
samples received by anti-virus companies everyday, and
instantly realize and respond to novel hooking mecha-
nisms.
In summary, this paper makes the following contri-
butions:
• We propose ﬁne-grained impact analysis as a uni-
ﬁed approach to identifying the hooking behavior
of malicious code. Since it does not rely on any
prior knowledge of hooking mechanisms, our ap-
proach is well suited for identifying novel hooking
mechanisms.
• In order to provide valuable insights about how
malware implants hooks, we devise a semantics-
aware impact dependency analysis method, which
provides a succinct and intuitive graphical repre-
sentation to help malware analysts understand the
hooking mechanism employed by a piece of mal-
ware.
• We have designed and developed HookFinder to
demonstrate the feasibility of our approach. We
have conducted extensive experiments with repre-
sentative malware samples from various categories,
and demonstrated that HookFinder could correctly
identify their hooking behaviors, and provide accu-
rate insights about their hooking mechanisms.
The paper is structured as follows. The next section
gives an overview of our approach. Section 3 describes
details on the design and implementation of HookFinder.
Section 4 presents the experimental results. Section 5
discusses some related issues. Section 6 surveys related
work and Section 7 concludes the paper.
2 Problem Statement and Our Approach
In this section, we formalize the problem of hook-
ing behavior detection and analysis, and give a brief
overview of our approach.
2.1 Problem Statement
Given a malware sample, our approach ﬁrst deter-
mines whether it contains hooking behaviors. A hooking
behavior can be formalized as follows. A malicious pro-
gram C attempts to change a memory location L of the
operating system, to implant a hook H. When a certain
event happens, the operating system will load the hook
H, and then starts to execute malicious code F in pro-
gram C. We refer to the address of F as hook entry, and
L as hook site. Figure 1(a) shows a piece of pseudo code
that hooks an entry in the System Service Descriptor Ta-
ble (SSDT) of Windows system. This hooking mech-
anism is used in many kernel-mode malware samples,
such as the Sony Rootkit [27]. In this example, the hook
entry F is NewZwOpenKey, and the hook site L is the
entry for ZwOpenKey in the service descriptor table,
and the hook H is the address of NewZwOpenKey, as
illustrated in Figure 1(b).
If our approach detects hooking behaviors in a mal-
ware sample, it outputs a graph representation of the
hooking mechanism, hook graph. The hook graph tells
us two main characteristics of a hooking mechanism:
hook type and implanting mechanism.
#define SYSTEMSERVICE(_function) \
KeServiceDescriptorTable.ServiceTableBase \
[*(PULONG)((PUCHAR)_function+1)]
void HookSyscalls() {
...
OldZwOpenKey = SYSTEMSERVICE(ZwOpenKey);
SYSTEMSERVICE(ZwOpenKey) = NewZwOpenKey;
...
}
(a)
C: Malicious Program
F: NewZwOpenKey
L: Hook Site
H: Hook
SSDT
ZwOpenKey
(b)
Figure 1. An SSDT Hooking Example. This code attempts to hook ZwOpenKey, by writing
the address of its own function NewZwOpenKey into the corresponding entry of the SSDT
KeServiceDescirptorTable.
Hook Type Depending how it is interpreted by the
CPU, a hook H can be either a data hook or a code
hook. A data hook is interpreted as data by the CPU,
and is used as the destination address of some control
transfer instruction to jump into the hook entry F . For
example, the hook in Figure 1 is a data hook, because
it is the address of the hook entry, and is interpreted as
the jump target. A code hook is interpreted as code by
the CPU. A code hook contains a jump-like instruction
(such as jmp and call), and is injected to overwrite
some system code (such as kernel modules and common
DLLs). When a code hook is activated, the execution is
redirected into the malicious code F . We need to detect
hooking behaviors in both cases, and we should be able
to tell what kind of hook it is when we detect one. As
we will see later, the policies used to detect hooking be-
haviors are different between these two categories due
to their different nature.
Implanting Mechanism Malware has two choices
to install H into L. First, it may directly write H
into L using its own code. Second,
it may call a
function to achieve it on its behalf. Windows sys-
tem provides several APIs for applications to regis-
ter various event handlers (i.e., hooks). For example,
SetWindowsHookEx allows an application to regis-
ter a hook for certain Windows event, such as keystroke
events. Whenever a keystroke is entered into the sys-
tem, Windows will call the hook function provided by
this application. In addition, functions like memcpy and
WriteProcessMemory can overwrite a memory re-
gion on behalf of their callers. Thus, once we identify a
hook, we need to determine which method the malware
used to register the hook.
If the malware directly modiﬁes L to install H, we
need to understand where L is, and how the malware
sample obtains L. Since L is usually not located in
a ﬁxed place, malware has to ﬁnd it from some static
point. This static point can be a global system sym-
bol, or the result of a function call. After obtaining
this static point, malware may walk through the data
structures referenced by it to eventually locate L. The
example in Figure 1 makes use of this method, and
the hook site L is calculated from a global symbol
KeServiceDescriptorTable. For this type of
implanting mechanism, the hook graph answers the fol-
lowing questions:
• Where is the static point?
• How does the malware obtain the static point?
• How does it infer the ﬁnal location L from the static
point?
If the malware invokes an external function to reg-
ister H, we need to identify the function’s address and
name.
In addition, we need to know the actual argu-
ments that are used to call this function. The function
call and its argument list can give semantic information
about how the hook and what kind of hook is registered.
For example, if we identify that a malicious program
calls SetWindowsHookEx to register a hook, we are
able to tell from the ﬁrst argument what type of hook is
registered. For this type of implanting mechanism, the
hook graph answers the following questions:
• What is the external function, including its entry
address and its name?
• What arguments does the malware use to invoke
this function?
2.2 Our Approach
Since most malware programs are equipped with var-
ious code obfuscation techniques to foil static analysis,
our approach is based on dynamic analysis. That is, we
actually monitor the execution of the malware in a spe-
cial environment, and use the obtained information to
derive how it implants the hook, and how the hook is
activated by the operating system. Note that our ap-
proach is designed for analysis, not on-line detection.
Our approach is divided into two steps: hook detection
and hooking mechanism analysis.
Hook Detection: Fine-grained Impact Analysis Our
approach is based on the following intuition. Malicious
code makes changes, including memory and the other
machine state changes, to the execution environment as
it runs. We call these changes impacts. Obviously, a
hook H is one of the impacts made by the malicious
code, and this impact ﬁnally redirects the execution con-
trol ﬂow into the malicious code. Hence, if we are able
to identify all the impacts of the malicious code, and ob-
serve one of the impacts being used to cause the execu-
tion to be redirected into the malicious code, we can de-
termine a hook installed by the malicious code. Further-
more, we are also interested in how an impact is formu-
lated, for the purpose of understanding hooking mecha-
nism. Therefore, we identify initial impacts, the newly
introduced impacts by the malicious code, and then keep
track of the impacts propagating over the system.
Based on this intuition, we propose ﬁne-grained im-
pact analysis. We mark all the initial impacts made by
the malicious code at byte level. The initial impacts in-
clude data written directly by the malicious code, and