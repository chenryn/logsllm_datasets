Chapter 21 n A Web Application Hacker’s Methodology 809
other users, particularly administrative users, which may enable you
escalate privileges.
4.7.3 If you perform any automated password-guessing attacks against other
user accounts, look for any accounts that appear to have more than one
valid password, or multiple accounts that appear to have the same pass-
word. This may indicate the presence of a backdoor password, which
administrators can use to access the application as any user.
4.8 Test Username Uniqueness
4.8.1 If the application has a self-registration function that lets you specify
a desired username, attempt to register the same username twice with
different passwords.
4.8.2 If the application blocks the second registration attempt, you can exploit
this behavior to enumerate registered usernames.
4.8.3 If the application registers both accounts, probe further to determine its
behavior when a collision of username and password occurs. Attempt
to change the password of one of the accounts to match that of the
other. Also, attempt to register two accounts with identical usernames
and passwords.
4.8.4 If the application alerts you or generates an error when a collision of
username and password occurs, you can probably exploit this to perform
an automated guessing attack to discover another user’s password. Target
an enumerated or guessed username, and attempt to create accounts
that have this username and different passwords. When the applica-
tion rejects a specifi c password, you have probably found the existing
password for the targeted account.
4.8.5 If the application appears to tolerate a collision of username and pass-
word without an error, log in using the colliding credentials. Determine
what happens and whether the application’s behavior can be leveraged
to gain unauthorized access to other users’ accounts.
4.9 Test Predictability of Autogenerated Credentials
4.9.1 If the application automatically generates usernames or passwords, try
to obtain several values in quick succession and identify any detectable
sequences or patterns.
4.9.2 If usernames are generated in a predictable way, extrapolate backwards
to obtain a list of possible valid usernames. You can use this as the basis
for automated password-guessing and other attacks.
cc2211..iinndddd 880099 88//1199//22001111 1122::2222::0022 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 810
810 Chapter 21 n A Web Application Hacker’s Methodology
4.9.3 If passwords are generated in a predictable way, extrapolate the pattern
to obtain a list of possible passwords issued to other application users.
This can be combined with any lists of usernames you obtain to perform
a password-guessing attack.
4.10 Check for Unsafe Transmission of Credentials
4.10.1 Walk through all authentication-related functions that involve trans-
mission of credentials, including the main login, account registration,
password change, and any page that allows viewing or updating of
user profi le information. Monitor all traffi c passing in both directions
between the client and server using your intercepting proxy.
4.10.2 Identify every case in which the credentials are transmitted in either
direction. You can set interception rules in your proxy to fl ag messages
containing specifi c strings.
4.10.3 If credentials are ever transmitted in the URL query string, these are
potentially vulnerable to disclosure in the browser history, on-screen,
in server logs, and in the Referer header when third-party links are
followed.
4.10.4 If credentials are ever stored in a cookie, these are potentially vulnerable
to disclosure via XSS attacks or local privacy attacks.
4.10.5 If credentials are ever transmitted from the server to the client, these
may be compromised via any vulnerabilities in session management or
access controls, or in an XSS attack.
4.10.6 If credentials are ever transmitted over an unencrypted connection, these
are vulnerable to interception by an eavesdropper.
4.10.7 If credentials are submitted using HTTPS but the login form itself is
loaded using HTTP, the application is vulnerable to a man-in-the-middle
attack that may be used to capture credentials.
4.11 Check for Unsafe Distribution of Credentials
4.11.1 If accounts are created via some out-of-band channel, or the applica-
tion has a self-registration function that does not itself determine all of
a user’s initial credentials, establish the means by which credentials are
distributed to new users. Common methods include sending a message
to an e-mail or postal address.
cc2211..iinndddd 881100 88//1199//22001111 1122::2222::0022 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 811
Chapter 21 n A Web Application Hacker’s Methodology 811
4.11.2 If the application generates account activation URLs that are distributed
out-of-band, try to register several new accounts in close succession,
and identify any sequence in the URLs you receive. If a pattern can
be determined, try to predict the URLs sent to recent and forthcom-
ing users, and attempt to use these URLs to take ownership of their
accounts.
4.11.3 Try to reuse a single activation URL multiple times, and see if the appli-
cation allows this. If it doesn’t, try locking out the target account before
reusing the URL, and see if the URL still works. Determine whether this
enables you to set a new password on an active account.
4.12 Test for Insecure Storage
4.12.1 If you gain access to hashed passwords, check for accounts that share
the same hashed password value. Try to log in with common passwords
for the most common hashed value.
4.12.2 Use an offl ine rainbow table for the hashing algorithm in question to
recover the cleartext value.
4.13 Test for Logic Flaws
4.13.1 Test for Fail-Open Conditions
4.13.1.1 For each function in which the application checks a user’s credentials,
including the login and password change functions, walk through the
process in the normal way, using an account you control. Note every
request parameter submitted to the application.
4.13.1.2 Repeat the process numerous times, modifying each parameter in turn
in various unexpected ways designed to interfere with the application’s
logic. For each parameter, include the following changes:
n Submit an empty string as the value.
n Remove the name/value pair.
n Submit very long and very short values.
n Submit strings instead of numbers, and vice versa.
n Submit the same named parameter multiple times, with the same
and different values.
cc2211..iinndddd 881111 88//1199//22001111 1122::2222::0022 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 812
812 Chapter 21 n A Web Application Hacker’s Methodology
4.13.1.3 Review closely the application’s responses to the preceding requests. If
any unexpected divergences from the base case occur, feed this obser-
vation back into your framing of further test cases. If one modifi cation
causes a change in behavior, try to combine this with other changes to
push the application’s logic to its limits.
4.13.2 Test Any Multistage Mechanisms
4.13.2.1 If any authentication-related function involves submitting credentials
in a series of different requests, identify the apparent purpose of each
distinct stage, and note the parameters submitted at each stage.
4.13.2.2 Repeat the process numerous times, modifying the sequence of requests
in ways designed to interfere with the application’s logic, including
the following tests:
n Proceed through all stages, but in a different sequence than the one
intended.
n Proceed directly to each stage in turn, and continue the normal
sequence from there.
n Proceed through the normal sequence several times, skipping each
stage in turn, and continuing the normal sequence from the next stage.
n On the basis of your observations and the apparent purpose of each
stage of the mechanism, try to think of further ways to modify the
sequence and to access the different stages that the developers may
not have anticipated.
4.13.2.3 Determine whether any single piece of information (such as the user-
name) is submitted at more than one stage, either because it is captured
more than once from the user or because it is transmitted via the client
in a hidden form fi eld, cookie, or preset query string parameter. If so, try
submitting different values at different stages (both valid and invalid)
and observing the effect. Try to determine whether the submitted item
is sometimes superfl uous, or is validated at one stage and then trusted
subsequently, or is validated at different stages against different checks.
Try to exploit the application’s behavior to gain unauthorized access
or reduce the effectiveness of the controls imposed by the mechanism.
4.13.2.4 Look for any data that is transmitted via the client that has not been
captured from the user at any point. If hidden parameters are used
cc2211..iinndddd 881122 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 813
Chapter 21 n A Web Application Hacker’s Methodology 813
to track the state of the process across successive stages, it may be
possible to interfere with the application’s logic by modifying these
parameters in crafted ways.
4.13.2.5 If any part of the process involves the application’s presenting a ran-
domly varying challenge, test for two common defects:
n If a parameter specifying the challenge is submitted along with the
user’s response, determine whether you can effectively choose your
own challenge by modifying this value.
n Try proceeding as far as the varying challenge several times with
the same username, and determine whether a different challenge
is presented. If it is, you can effectively choose your own chal-
lenge by proceeding to this stage repeatedly until your desired
challenge is presented.
4.14 Exploit Any Vulnerabilities to Gain
Unauthorized Access
4.14.1 Review any vulnerabilities you have identifi ed within the various authen-
tication functions, and identify any that you can leverage to achieve
your objectives in attacking the application. This typically involves
attempting to authenticate as a different user — if possible, a user with
administrative privileges.
4.14.2 Before mounting any kind of automated attack, note any account
lockout defenses you have identifi ed. For example, when performing
username enumeration against a login function, submit a common
password with each request rather than a completely arbitrary value
so as not to waste a failed login attempt on every username discovered.
Similarly, perform any password-guessing attacks on a breadth-fi rst,
not depth-fi rst, basis. Start your word list with the most common weak
passwords, and proceed through this list, trying each item against
every enumerated username.
4.14.3 Take account of the password quality rules and the completeness of
password validation when constructing word lists to use in any password-
guessing attack to avoid impossible or superfl uous test cases.
4.14.4 Use the techniques described in Chapter 14 to automate as much
work as possible and maximize the speed and effectiveness of your
attacks.
cc2211..iinndddd 881133 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 814
814 Chapter 21 n A Web Application Hacker’s Methodology
5 Test the Session Management Mechanism
5.1. Understand the mechanism
Token generation Token handling
5.2. Test for meaning 5.4. Check for insecure transmission
5.3. Test for predictability 5.5. Check for disclosure in logs
5.6. Test mapping of tokens to sessions
5.7. Test session termination
5.8. Test for session fixation
5.9. Check for CSRF
5.10. Check cookie scope
Figure 21-6: Testing the session management mechanism
5.1 Understand the Mechanism
5.1.1 Analyze the mechanism used to manage sessions and state. Establish
whether the application uses session tokens or some other method of
handling the series of requests received from each user. Note that some
authentication technologies (such as HTTP authentication) may not
require a full session mechanism to reidentify users post-authentication.
Also, some applications use a sessionless state mechanism in which all
state information is transmitted via the client, usually in an encrypted
or obfuscated form.
5.1.2 If the application uses session tokens, confi rm precisely which pieces
of data are actually used to reidentify users. Items that may be used to
transmit tokens include HTTP cookies, query string parameters, and
hidden form fi elds. Several different pieces of data may be used collec-
tively to reidentify the user, and different items may be used by different
back-end components. Often, items that look like session tokens may
not actually be employed as such by the application, such as the default
cookie generated by the web server.
cc2211..iinndddd 881144 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 815
Chapter 21 n A Web Application Hacker’s Methodology 815
5.1.3 To verify which items are actually being employed as session tokens,
fi nd a page or function that is certainly session-dependent (such as a
user-specifi c My Details page). Then make several requests for it, sys-
tematically removing each item you suspect is being used as a session
token. If removing an item stops the session-dependent page from being
returned, this may confi rm that the item is a session token. Burp Repeater
is a useful tool for performing these tests.
5.1.4 Having established which items of data are actually being used to reiden-
tify users, for each token confi rm whether it is being validated in its
entirety, or whether some subcomponents of the token are ignored.
Change the token’s value 1 byte at a time, and check whether the modi-
fi ed value is still accepted. If you fi nd that certain portions of the token
are not actually used to maintain session state, you can exclude these
from further analysis.
5.2 Test Tokens for Meaning
5.2.1 Log in as several different users at different times, and record the tokens
received from the server. If self-registration is available and you can choose
your username, log in with a series of similar usernames that have small
variations, such as A, AA, AAA, AAAA, AAAB, AAAC, AABA, and so
on. If other user-specifi c data is submitted at the login or is stored in user
profi les (such as an e-mail address), perform a similar exercise to modify
that data systematically and capture the resulting tokens.
5.2.2 Analyze the tokens you receive for any correlations that appear to be
related to the username and other user-controllable data.
5.2.3 Analyze the tokens for any detectable encoding or obfuscation. Look
for a correlation between the length of the username and the length of
the token, which strongly indicates that some kind of obfuscation or
encoding is in use. Where the username contains a sequence of the same
character, look for a corresponding character sequence in the token,
which may indicate the use of XOR obfuscation. Look for sequences in
the token that contain only hexadecimal characters, which may indicate
hexadecimal encoding of an ASCII string or other information. Look for
sequences ending in an equals sign and/or containing only the other
valid Base64 characters: a to z, A to Z, 0 to 9, +, and /.
5.2.4 If you can identify any meaningful data within your sample of session
tokens, consider whether this is suffi cient to mount an attack that attempts
to guess the tokens recently issued to other application users. Find a
page of the application that is session-dependent, and use the techniques
cc2211..iinndddd 881155 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 816
816 Chapter 21 n A Web Application Hacker’s Methodology
described in Chapter 14 to automate the task of generating and testing
possible tokens.
5.3 Test Tokens for Predictability
5.3.1 Generate and capture a large number of session tokens in quick succes-
sion, using a request that causes the server to return a new token (for
example, a successful login request).
5.3.2 Attempt to identify any patterns within your sample of tokens. In all
cases you should use Burp Sequencer, as described in Chapter 7, to
perform detailed statistical tests of the randomness properties of the
application’s tokens. Depending on the results, it may also be useful to
perform the following manual analysis:
n Apply your understanding of which tokens and subsequences the
application actually uses to reidentify users. Ignore any data that is
not used in this way, even if it varies between samples.
n If it is unclear what type of data is contained in the token, or in any
individual component of it, try applying various decodings (for exam-
ple, Base64) to see if any more meaningful data emerges. It may be
necessary to apply several decodings in sequence.
n Try to identify any patterns in the sequences of values contained in
each decoded token or component. Calculate the differences between
successive values. Even if these appear to be chaotic, there may be a
fixed set of observed differences, which narrows down the scope of
any brute-force attack considerably.
n Obtain a similar sample of tokens after waiting for a few minutes,
and repeat the same analysis. Try to detect whether any of the tokens’
content is time-dependent.
5.3.3 If you identify any patterns, capture a second sample of tokens using
a different IP address and a different username. This will help you
identify whether the same pattern is detected and whether tokens
received in the fi rst exercise could be extrapolated to guess tokens
received in the second.
5.3.4 If you can identify any exploitable sequences or time dependencies,
consider whether this is suffi cient to mount an attack that attempts
to guess the tokens recently issued to other application users. Use the
techniques described in Chapter 14 to automate the task of generating
and testing possible tokens. Except in the simplest kind of sequences,
it is likely that your attack will need to involve a customized script
of some kind.
cc2211..iinndddd 881166 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 817