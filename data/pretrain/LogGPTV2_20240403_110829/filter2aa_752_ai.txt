调用命令来完成这一操作。 
代码列表 3.4 （fork-exec.c）将 fork 和 exec 结合使用 
#include  
#include  
#include  
#include  
/* 产生一个新进程运行新的程序。PAORGAM 是要运行的程序的名字；系统会在
执行路径中搜索这个程序运行。ARG_LIST 是一个以 NULL 指针结束的字符串列表，
用作程序的参数列表。返回新进程的 ID。 */ 
int spawn (char* program, char** arg_list) 
{ 
  pid_t child_pid; 
  /* 复制当前进程。*/ 
www.AdvancedLinuxProgramming.com 
41
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
  child_pid = fork (); 
  if (child_pid != 0) 
    /* 这里是父进程。*/ 
    return child_pid; 
  else { 
    /* 现在从执行路径中查找并执行 PROGRAM。*/ 
    execvp (program, arg_list); 
    /* execvp 函数仅当出现错误的时候才返回。*/ 
    fprintf (stderr, "an error occurred in execvp\n"); 
    abort (); 
  } 
} 
int main () 
{ 
  /* 准备传递给 ls 命令的参数列表 */ 
  char* arg_list[] = { 
    "ls",     /* argv[0], 程序的名称 */ 
    "-l",  
    "/",  
    NULL      /* 参数列表必须以 NULL 指针结束 */ 
  }; 
  /* 建立一个新进程运行 ls 命令。忽略返回的进程 ID */ 
  spawn ("ls", arg_list); 
  printf ("done with main program\n"); 
  return 0; 
} 
3.2.3 进程调度 
Linux 会分别独立地调度父子进程；不保证进程被调度的先后顺序，也不保证被调度的
进程在被另外一个（或系统中其它进程）打断之前会运行多久。具体来说，ls命令也许在父
进程结束之前根本没有被调度运行，也可能是ls命令运行了一部分或者全部完成之后主进程
才结束执行
２。Linux保证每个程序都会得到运行——不会有某个进程因为缺乏资源而无法运
行。 
你可以将一个进程标记为次要的；给进程指定一个较高的 niceness 值会给这个进程分配
较低的优先级。默认情况下，每个进程的 niceness 均为 0。较高的 niceness 值代表了较低的
进程优先级；相应的，较低的 niceness 值（负值）表示较高的进程优先级。 
www.AdvancedLinuxProgramming.com 
42
２ 3.4.1 节（“等待进程终止”）展示了一种序列化两个进程顺序的方法。 
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
使用 nice 命令的-n 参数允许用户以一个指定的 niceness 值运行特定程序。例如，要执
行“sort input.txt > output.txt”这个会执行较长时间的排序命令，可以通过下面
的命令降低它的优先级，使它不会过度地影响系统的运行： 
% nice -n 10 sort input.txt > output.txt 
你可以使用 renice 命令从命令行调整一个正在运行的程序的 niceness 值。 
可以通过调用 nice 函数以编程的方法调整一个运行中的进程的优先级。它的参数会被
加在调用进程的 niceness 值上。记住，大于 0 的值会提高进程的 niceness 值，从而降低进程
优先级。 
需要注意的是，只有当一个进程以 root 权限运行的时候才能以负的 niceness 值运行其它
程序，或降低一个进程的 niceness 值。这表明，只有当你以 root 身份登陆的时候，你才可以
用负数做参数调用 nice 和 renice 命令，而只有当一个进程以 root 身份运行的时候才可以
以负值作参数调用 nice 函数。这种限制可以防止普通用户从其它用户的手中夺取程序运行
优先级。 
3.3 信号 
信号（Signal）是 Linux 系统中用于进程之间相互通信或操作的一种机制。信号是一个
相当广泛的课题；在这里，我们仅仅探讨几种最重要的信号以及利用信号控制进程的技术。 
信号是一个发送到进程的特殊信息。信号机制是异步的；当一个进程接收到一个信号时，
它会立刻处理这个信号，而不会等待当前函数甚至当前一行代码结束运行。信号有几十种，
分别代表着不同的意义。信号之间依靠它们的值来区分，但是通常在程序中使用信号的名字
来表示一个信号。在 Linux 系统中，这些信号和以它们的名称命名的常量均定义在 
/usr/include/bits/signum.h 文件中。（通常程序中不需要直接包含这个头文件，而应
该包含。） 
当一个进程接收到信号，基于不同的处理方式（disposition），该进程可能执行几种不同
操作中的一种。每个信号都有一个默认处理方式(default disposition)，当进程没有指定自己
对于某个信号的处理方式的时候，默认处理方式将被用于对对应信号作出响应。对于多数种
类的信号，程序都可以自由指定一个处理方式——程序可以选择忽略这个信号，或者调用一
个特定的信号处理函数。如果指定了一个信号处理函数，当前程序会暂停当前的执行过程，
同时开始执行信号处理函数，并且当信号处理函数返回之后再从被暂停处继续执行。 
Linux 系统在运行中出现特殊状况的时候也会向进程发送信号通知。例如，当一个进程
执行非法操作的时候可能会收到 SIGBUS（主线错误），SIGSEGV（段溢出错误）及 SIGFPE
（浮点异常）这些信号。这些信号的默认处理方式都是终止程序并且产生一个核心转储文件
（core file）。 
一个进程除了响应系统发来的信号，还可以向其它进程发送信号。对于这种机制的一个
最常见的应用就是通过发送SIGTERM或SIGKILL信号来结束其它进程。
３#3 除此之外，它
还常见于向运行中的进程发送命令。两个“用户自定义”的信号SIGUSR1 和SIGUSR2 就是
专门作此用途的。SIGHUP信号有时也用于这个目的——通常用于唤醒一个处于等待状态的
进程或者使进程重新读取配置文件。 
www.AdvancedLinuxProgramming.com 
43
系统调用 sigaction 用于指定信号的处理方式。函数的第一个参数是信号的值。之后两
个参数是两个指向 sigaction 结构的指针；第一个指向了将被设置的处理方式，第二个用于
３ 有什么区别？SIGTERM 信号要求进程中止；进程可以修改请求或者直接忽略这个信号。SIGKILL 信
号会立即中止进程，因为进程无法忽略或修改对 SIGKILL 信号的响应。 
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
保存先前的处理方式。这两个 sigaction 结构中最重要的都是 sa_handler 域。它可以是下面
三个值： 
· SIG_DFL，指定默认的信号处理方式 
· SIG_IGN，指定该信号将被忽略 
· 一个指向信号处理函数的指针。这个函数应该接受信号值作为唯一参数，
且没有返回值。 
因为信号处理是异步进行的，当信号处理函数被调用的时候，主程序可能处在非常脆弱
的状态，并且这个状态会一直保持到信号处理函数结束。因此，应该尽量避免在信号处理函
数中使用输入输出功能、绝大多数库函数和系统调用。 
信号处理函数应该做尽可能少的工作以响应信号的到达，然后返回到主程序中继续运行
（或者结束进程）。多数情况下，所进行的工作只是记录信号的到达。而主程序则定期检查
是否有信号到达，并且针对当时情况作出相应的处理。 
信号处理函数也可能被其它信号的到达所打断。虽然这种情况听起来非常罕见，一旦出
现，程序将非常难以确定问题并进行调试。（这是竞争状态的一个例子。在第四章“线程”
第 4.4 节“同步及临界段”中进行了讨论。）因此，对于你的信号处理函数进行哪些工作一
定要进行慎重的考虑。 
甚至于对全局变量赋值可能也是不安全的，因为一个赋值操作可能由两个或更多机器指
令完成，而在这些指令执行期间可能会有第二个信号到达，致使被修改的全局变量处于不完
整的状态。如果你需要从信号处理函数中设置全局标志以记录信号的到达，这个标志必须是
特殊类型 sig_atomic_t 的实例。Linux 保证对于这个类型变量的赋值操作只需要一条机器指
令，因此不用担心可能在中途被打断。在 Linux 系统中，sig_atomic_t 就是基本的 int 类型；
事实上，对 int 或者更小的整型变量以及指针赋值的操作都是原子操作。不过，如果你希望
所写的程序可以向任何标准 UNIX 系统移植，则应将所有全局变量设为 sig_atomic_t 类型。 
如下所示，代码列表 3.5 中的简单程序中，我们利用信号处理函数统计程序在运行期接
收到 SIGUSR1 信号的次数。SIGUSR1 信号是一个为应用程序保留的信号。 
代码列表 3.5 （sigusr1.c）使用信号处理函数 
#include  
#include  
#include  
#include  
#include  
sig_atomic_t sigusr1_count = 0; 
void handle (int signal_number) 
{ 
  ++sigusr1_count; 
} 
int main () 
{ 
  struct sigaction sa; 
www.AdvancedLinuxProgramming.com 
44
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
  memset (&sa, 0, sizeof (sa)); 
  sa.sa_handler = &handler; 
  sigaction (SIGUSR1, &sa, NULL); 
  /* 这里可以执行一些长时间的工作。*/ 
  /* ... */ 
  printf ("SIGUSR1 was raised %d times\n", sigusr1_count); 
  return 0; 
} 
3.4 进程终止 
通常，进程会以两种情况的之一结束：调用 exit 函数退出或从 main 函数返回。每个
进程都有退出值（exit code）：一个返回给父进程的数字。一个进程退出值就是程序调用 exit
函数的参数，或者 main 函数的返回值。 
进程也可能由于信号的出现而异常结束。例如，之前提到的 SIGBUS，SIGSEGV 和
SIGFPE 信号的出现会导致进程结束。其它信号也可能显式结束进程。当用户在终端按下
Ctrl+C 时会发送一个 SIGINT 信号给进程。SIGTERM 信号由 kill 命令发送。这两个信号
的默认处理方式都是结束进程。进程通过调用 abort 函数给自己发送一个 SIGABRT 信号，
导致自身中止运行并且产生一个 core file。最强有力的终止信号是 SIGKILL，它会导致进程
立刻终止，而且这个信号无法被阻止或被程序自主处理。 
这里任何一个信号都可以通过指定一个特殊选项，由 kill 命令发送；例如，要通过发
送 SIGKILL 中止一个出问题的进程，只需要执行下面的命令（这里 pid 是目标进程号）： 
% kill -KILL pid 
要从程序中发送信号，使用 kill 函数。第一个参数是目标进程号。第二个参数是要发
送的信号；传递 SIGTERM 可以模拟 kill 命令的默认行为。例如，你可以利用 kill 函数，
像这样从父进程中结束子进程的运行（这里 child_pid 包含的是子进程的进程号）： 
% kill (child_pid, SIGTERM); 
需要包含和头文件才能在程序中调用 kill 函数。 
根据习惯，程序的退出代码可用来确认程序是否正常运行。返回值为 0 表示程序正确运
行，而非零的返回值表示运行过程出现错误。在后一种情况下，返回值可能表示了特定的错
误含义。通常应该遵守这个约定，因为 GNU/Linux 系统的其它组件会假设程序遵循这个行
为模式。例如，当使用 &&（逻辑与）或 ||（逻辑或）连接多个程序的时候，shell 根据这
个假定判断逻辑运算的结果。因此，除非有错误发生，你都应该在 main 结束的时候明确地
返回 0。 
对于多数 shell 程序，最后运行的程序的返回值都保存在特殊环境变量$?中。在下面这
个例子中 ls 命令被执行了两次，并且每次运行之后会输出返回值。第一次，ls 运行正常并
且返回 0。第二次，ls 运行出现一个错误（因为命令行参数指定的文件不存在）且返回了
一个非零值。 
% ls 
www.AdvancedLinuxProgramming.com 
45
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
bin   coda  etc   lib         misc  nfs  proc  sbin  usr 
boot  dev   home  lost+found  mnt   opt  root  tmp   var 
% echo $? 
0 
% ls bogusfile 
ls: bogusfile: No such file or directory 
% echo $? 
1 