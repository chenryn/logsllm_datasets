Inner-script analysis (see Section 4.2)
mainly provides program information on ASTs or function
calls with security risks. Function call patterns and inter-
script analysis (see Section 4.3) focus on the classiﬁcation of
attack types. The malicious sample s1 in Figure 3, which
is an obfuscated type I attack that loads external scripts, is
used as an illustrative example.
Note that we annotate features only for detection with
†, features only for attack type classiﬁcation with ‡, and
features for both purposes with ∗.
4.1 Textual Analysis
Textual analysis is applied to indicate both obfuscation
and maliciousness, as it can tell the diﬀerence between ob-
fuscated malicious scripts and obfuscated benign ones [16].
Longest word size†. Obfuscated JavaScript code usu-
ally contains long words, which signals the existence of en-
coding or encryption that is used for parameters of the func-
tion like eval. A script with very long word size (e.g., larger
than 350 words [16]) is likely to be obfuscated. For example,
in the obfuscated code in Figure 3(a), the size of the longest
word is 814. After tokenization, the longest token size is
calculated.
Entropy†. Entropy is a measure of unpredictability of in-
formation content, and it is used to analyze the distribution
of diﬀerent characters. Entropy is calculated as follows:
X = {xi, i = 0, 1, ..., N}
T =(cid:80)N
i=1 xi
(1)
H(X) = − N(cid:88)
(
xi
T
)log10(
xi
T
)
i=1
(cid:40)
where xi is the count of each characters and T counts all
characters. Note that we omit the calculation of the count
for space character since it is not part of the JavaScript
code contents. The obfuscated code typically has low en-
tropy than normal code, since it often contains repeated
characters. It has been experimented that the entropy for
obfuscated code is usually lower than 1.2, while the standard
code has entropy from 1.2–2.1 [16]. The obfuscated code of
s1 has entropy of 1.1.
Byte occurrence frequency of speciﬁc character†.
As obfuscated malicious code usually uses customized encod-
ing, and it tends to use excessively speciﬁc characters. We
use 1-gram model among n-gram model, to examine the oc-
currence frequency of characters (excluding the space char-
acter), which is equivalent to byte occurrence frequency. The
byte occurrence is then divided by total characters for nor-
malization. For example, in the obfuscated code in Figure
3(a), the comma character represents the most frequently
used character (total of 232 characters), which represents a
quarter of the total characters.
(a) The original obfuscated version
(b) The HtmlUnit unpacked version
Figure 3: A malicious sample s1 of attack Type I
Commenting style†. There are two kinds of comment
annotations in JavaScript. ‘‘//’’ is for single-line comments
and ‘‘” for multiple-line or block comments. A
basic evasion technique involves the mixture of these two
kinds of comments. For example, the code in Figure 3(a)
uses a pair of tags , which is expected to be
commented out for execution, nevertheless, it is executed
due to the fault-tolerance of the browser. The value of this
feature records the occurrence frequency of such commenting
style, e.g., there is one occurrence for the code in Figure 3(a).
4.2 Inner-Script Program Analysis
A web-page contains multiple JavaScript snippets, some
are embedded (internal scripts), while some others are links
to other JavaScript ﬁes (external scripts). Analysis of the
internal scripts are inner-script analysis, which is considered
heavy weight for analysis of all JavaScript snippets. We
delay the analysis of external scripts for inter-script analysis
(see Section 4.3).
For the unpacked code in Figure 3(b), features about the
program information are extracted to characterize the mali-
cious behaviors. The program information includes HTML
properties and Document Object Model (DOM) operations,
the API usage pattern (i.e., the pattern of function calls)
and AST-based features.
Function calls with security risks∗. Malicious Java-
Script are usually accomplished by means of code genera-
tion, redirecting and DOM operations at runtime. In Fig-
ure 4, we list the functions that are with security risks by
allowing dynamic code generation, loading or redirecting.
Nevertheless, the functions are not used alone but together
with some other assistant string operation functions (e.g.,
concat(), charCodeAt()) that can hide the malicious inten-
tion by encoding or encryption. We record the number of
occurrences of a function call as a numeric feature, e.g., fea-
ture String.fromCharCode() and feature eval() in Figure 3(b)
both have a value 1, as they are called only once.
AST features∗. We also consider hierarchical features
extracted from the ASTs of unpacked code, e.g. the depth of
the AST, the diﬀerence between the deepest depth of its sub-
trees and the shortest depth of its subtrees, the maximum
112Function Name
Function Type
Possible Threats
eval()
window.setInterval()
window.setTimeout()
location.replace()
location.assign()
getUserAgent()
getAppName()
getCookie()
setCookie()
Dynamic code execution Dynamic code generation
Change current URL
Redirect to malicious URL
Check browser
Target speciﬁc browser
Cookie access
Manipulate Cookie
document.addEventListener()
element.addEventListener()
Intercepting Events
Block user’s operation or
emulating
document.write()
element.changeAttribute()
document.writeln()
element.innerHTML()
element.insertBefore()
element.replaceChild()
element.appendChild()
String.charAt()
String.charCodeAt()
String.fromCharCode()
String.indexOf()
String.split()
DOM operation
Embed malicious script,
invisible java applets,
invisible iframe,
invisible silverlight, etc.
String operation
Hide intension, by
encoding and encryption
Figure 4: Functions with security risks
breadth and the versions of the AST during the generation
of the ﬁnal unpacked code.
There exists many similar assignments and function calls
in the ASTs of malicious scripts—this reason leads to a large
value of AST depth and maximum breadth. Furthermore,
malicious scripts also use multiple levels of dynamic code
generation like eval(), i.e., the parameter of one eval function
call contains some other function call(s) like eval or docu-
ment.write. During the process of unpacking these functions
that support dynamic code generation, each time one such
function like eval is parsed and interpreted, a new version of
AST is built. Thus, by analysing the versions of ASTs, we
can calculate the times of doing unpacking for functions that
support dynamic code generation and loading in a script. Fi-
nally, the code in Figure 3(b) has an AST with a depth of
21, a width of 20 and a version number of 5.
Function call patterns‡. Diﬀerent malicious attacks
take advantage of distinct vulnerability and have their own
behavior models. As API usage (or functional call) pattern
is usually adopted to model program behavior, function call
patterns can serve as the features predicating a possible type
of attack. For the diﬀerent attack types of samples in the
training set, we apply frequent itemset mining on the func-
tion calls extracted from ASTs. A mined frequent itemset is
a set of function calls that appear together with a support
probability greater than a certain threshold. Speciﬁcally, we
separately apply frequent itemset mining for samples of each
attack type, and record all the maximum frequent itemsets
with support greater than 20% for each attack type. Finally,
10 mined patterns are manually conﬁrmed as valid function
call patterns for the eight attack types.
In Figure 5, we show an example of function call patterns
found common in Figure 3(b) for type I attack. As the func-
tion newActiveXObject() and createXMLHTTPRequest() are
widely used by malware targeting vulnerability in ActiveX
components, this pattern captures behaviors of such attack.
4.3 Inter-Script Program Analysis
In inter-script analysis, we count external scripts from
other domains.
In JSDC, we report malicious JavaScript
code at the unit of a code snippet inside .
In
our training set, we ﬁnd some of malicious samples are self-
contained in one code snippet of  and do not re-
fer to other scripts to realize malicious intention. However,
Function call pattern:
unescape()
eval()
GetCookie()
dateObject.toGMTString()
SetCookie()
document.write()
document.createElement()
element.appendChild()
newActiveXObject()
createXMLHTTPRequest()
Intension:
obfuscation to evade checking
dynamic generation
check Cookie
generate time String used in cookie
set cookie to mark
generate dynamic document content
create new document element
append new element to current one
create new Active object
download exploit ﬁle to local system
Figure 5: An exemplar function call pattern from
mining frequent itemsets in function calls
Figure 6: A malicious sample s2 that involves mul-
tiple JavaScript snippets
some malicious ones do not contain the actual malicious
code. Instead, they just exploit the vulnerability and call
some other third party scripts to accomplish the attack. For
this type of attack that relies on some other scripts, we pro-
pose to adopt the inter-script program analysis.
We extract the times of referring to external scripts as
numeric features. Besides, times of external function calls
or variable access are also recorded as diﬀerent numeric fea-
tures. Our extension of HtmlUnit enables to parse and in-
terpret the external scripts referred by the current one. As
shown in Figure 6, the malicious attack refers to an exter-
nal script “a.js”, and it adds the “a.js” into its DOM as an
element. Meanwhile, the function b is actually calling the
malicious function a in “a.js” to launch the attack.
Miscellaneous and derived features‡. Given a suspi-
cious script, to characterize the dynamically generated code
or external scripts from other domains, we propose some
features for attack type classiﬁcation:
feature changeSRC
counts the number of changing of the src attribute (e.g.,
for  tag); feature changeSRC counts the
number of invocation of navigator.userAgent; derived statis-
tic feature domAndDynamicUsageCnt counts the number of
invocation for APIs that change DOM structure or support-
ing dynamic execution of JavaScript code in Figure 4; fea-
ture dynamicUsageContentLen stores the length of contents
that are passed as arguments to APIs that support dynamic
execution of JavaScript; lastly, feature referenceError counts
the number of failures in its reference of external scripts.
The usefulness of these features are discussed in Section 8.
Note that the inter-script program analysis is more com-
putationally costly, compared with inner-script program anal-
ysis, due to the increased size of scripts that need to be an-
alyzed. As inter-script analysis is only applicable to feature
extraction for classiﬁcation of detected malware, the over-
heads in analysing the comparatively small size of detected
malicious are still acceptable in our approach.
1135. DYNAMIC CONFIRMATION
To capture the attack behaviors of JavaScript malware at
runtime, we propose to model and analyze JavaScript pro-
gram behaviors by focusing on browser-level system calls.
As system calls or actions (high level abstraction of simi-
lar system calls) are the interactions of a program with its
environment (i.e., the browser in our study), it is eﬀective
to model program behaviors (including attack behaviors)
based on system calls or actions [19]. Further, we propose
to use Deterministic Finite Automata (DFA) to model at-
tack behaviors, which is motivated by the work on detecting
anomalous program behaviors based on Finite State Auto-
mate (FSA) [35]. The transitions of the DFA are actions,
i.e., the high-level abstraction of system calls.
In [35], the dynamic analysis approach has been presented
to automatically infer an FSA from a set of execution traces
of binary executables. In this study, we have the similar idea,
but we are modelling the attack behaviors of JavaScript mal-
ware based on browser-level system calls. Speciﬁcally, we
instrument Mozilla Firefox and capture the method calls to
Cross Platform Component Object Model (XPCOM) [10] as
browser-level system calls. So our implementation is Firefox
speciﬁc. The work-ﬂow of dynamic conﬁrmation is shown in
Figure 7. First, we execute malicious JavaScript samples to
get the training set of (both benign and malicious) execution
traces. One good thing to web-based malware detection is
no need for triggering. Generally, web-based malware are
triggered automatically once the web page is loaded. Sec-
ond, we perform a preprocessing to simplify these traces by
removing security irrelevant system calls (those are not re-
lated to security or permission issues). For a common system
call that happens in all malicious traces of the same attack
type, we wrap it as an action. Then, the simpliﬁed traces
are converted into action sequences. Finally, given all the
actions as the alphabetic in a DFA and the existing action
sequences as the training set, we adopt an oﬀ-line learning
algorithm, i.e., regular positive negative inference (RPNI)
[30], to infer a DFA from these execution traces. During the
oﬀ-line learning, human experts (the authors) are involved
to give some positive or negative counterexamples to reﬁne
the DFA step by step.
To identify the attack type of a possibly malicious script,
we collect its execution traces and check them against these
learned attack behaviour models in the form of DFA. If any
trace is accepted by a certain DFA, the related script is
considered as an instance of this attack type. If the traces
of a script are not matched with any predeﬁned or inferred
behaviour model, JSDC suggests that this script is probably
Figure 7: The work-ﬂow of learning and detecting
an attack type in dynamic conﬁrmation
System calls
nsISupportsString.data
nsICommandLine.resolveURI
nsIObserverService.notifyObservers
nsIWebNavigation.loadURI
nsIScriptableUnicodeConverter.convertToByteArray
nsICryptoHash.update
nsILocalFile.append
nsITimer.initWithCallback
nsIIOService2.newURI
nsIScriptableUnicodeConverter.convertToInputStream
nsIBoxObject.setProperty
Actions
⇒ a
⇒ b
⇒ c
⇒ d
⇒ e
⇒ f
⇒ g
Figure 8: An execution trace and the actions
{a, b, c, d, e, f, g} that appear in traces of type I attack
Figure 9: The illustrative DFA of the attack of s1,
which is a part of the actual DFA of type I attack
of a new attack type, or a benign script due to false positive