# 小结今天我们从上一篇文章的课后问题说起，提到了全表扫描的加锁方式。我们发现即使给所有的行都加上行锁，仍然无法解决幻读问题，因此引入了间隙锁的概念。我碰到过很多对数据库有一定了解的业务开发人员，他们在设计数据表结构和业务SQL语句的时候，对行锁有很准确的认识，但却很少考虑到间隙锁。最后的结果，就是生产库上会经常出现由于间隙锁导致的死锁现象。行锁确实比较直观，判断规则也相对简单，间隙锁的引入会影响系统的并发度，也增加了锁分析的复杂度，但也有章可循。下一篇文章，我就会为你讲解InnoDB 的加锁规则，帮你理顺这其中的"章法"。作为对下一篇文章的预习，我给你留下一个思考题。![](Images/26a5ea9e90c00ae67039294416d1ac4f.png){savepage-src="https://static001.geekbang.org/resource/image/0d/3d/0d796060073668ca169166a8903fbf3d.png"}```{=html}```图 9 事务进入锁等待状态]{.reference}```{=html}```如果你之前没有了解过本篇文章的相关内容，一定觉得这三个语句简直是风马牛不相及。但实际上，这里session B 和 session C 的 insert 语句都会进入锁等待状态。你可以试着分析一下，出现这种情况的原因是什么？这里需要说明的是，这其实是我在下一篇文章介绍加锁规则后才能回答的问题，是留给你作为预习的，其中session C被锁住这个分析是有点难度的。如果你没有分析出来，也不要气馁，我会在下一篇文章和你详细说明。你也可以说说，你的线上 MySQL配置的是什么隔离级别，为什么会这么配置？你有没有碰到什么场景，是必须使用可重复读隔离级别的呢？你可以把你的碰到的场景和分析写在留言区里，我会在下一篇文章选取有趣的评论跟大家一起分享和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。
# 上期问题时间我们在本文的开头回答了上期问题。有同学的回答中还说明了读提交隔离级别下，在语句执行完成后，是只有行锁的。而且语句执行完成后，InnoDB就会把不满足条件的行行锁去掉。当然了，c=5 这一行的行锁，还是会等到 commit 的时候才释放的。评论区留言点赞板：> \@薛畅> 、@张永志同学给出了正确答案。而且提到了在读提交隔离级别下，是只有行锁的。\> \@帆帆帆帆帆帆帆帆、@欧阳成> 对上期的例子做了验证，需要说明一下，需要在启动配置里面增加> performance_schema=on，才能用上这个功能，performance_schema> 库里的表才有数据。![](Images/48edcb93fb03e3e52d7e7099be6b5cb3.png){savepage-src="https://static001.geekbang.org/resource/image/09/77/09c1073f99cf71d2fb162a716b5fa577.jpg"}
# 21 \| 为什么我只改一行的语句，锁这么多？在上一篇文章中，我和你介绍了间隙锁和 next-key lock的概念，但是并没有说明加锁规则。间隙锁的概念理解起来确实有点儿难，尤其在配合上行锁以后，很容易在判断是否会出现锁等待的问题上犯错。所以今天，我们就先从这个加锁规则开始吧。首先说明一下，这些加锁规则我没在别的地方看到过有类似的总结，以前我自己判断的时候都是想着代码里面的实现来脑补的。这次为了总结成不看代码的同学也能理解的规则，是我又重新刷了代码临时总结出来的。所以，**这个规则有以下两条前提说明：**1.  MySQL    后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即    5.x 系列 \`{=html}我还是以上篇文章的表 t 为例，和你解释一下这些规则。表 t的建表语句和初始化语句如下。    CREATE TABLE `t` (  `id` int(11) NOT NULL,  `c` int(11) DEFAULT NULL,  `d` int(11) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `c` (`c`)) ENGINE=InnoDB; insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);接下来的例子基本都是配合着图片说明的，所以我建议你可以对照着文稿看，有些例子可能会"毁三观"，也建议你读完文章后亲手实践一下。
# 案例一：等值查询间隙锁第一个例子是关于等值条件操作间隙：![](Images/f5fe73e462cf97bec71aa31a746cf262.png){savepage-src="https://static001.geekbang.org/resource/image/58/6c/585dfa8d0dd71171a6fa16bed4ba816c.png"}```{=html}```图 1 等值查询的间隙锁]{.reference}```{=html}```由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：1.  根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是    (5,10\]；2.  同时根据优化 2，这是一个等值查询 (id=7)，而 id=10    不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是    (5,10)。所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C修改 id=10 这行是可以的。
# 案例二：非唯一索引等值锁第二个例子是关于覆盖索引上的锁：![](Images/77c2972ec74bf6e6ebd007c1010ac6c9.png){savepage-src="https://static001.geekbang.org/resource/image/46/65/465990fe8f6b418ca3f9992bd1bb5465.png"}```{=html}```图 2 只加在非唯一索引上的锁]{.reference}```{=html}```看到这个例子，你是不是有一种"该锁的不锁，不该锁的乱锁"的感觉？我们来分析一下吧。这里 session A 要给索引 c 上 c=5 的这一行加上读锁。1.  根据原则 1，加锁单位是 next-key lock，因此会给 (0,5\] 加上 next-key    lock。2.  要注意 c 是普通索引，因此仅访问 c=5    这一条记录是不能马上停下来的，需要向右遍历，查到 c=10    才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10\] 加 next-key    lock。3.  但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5    这个等值条件，因此退化成间隙锁 (5,10)。4.  根据原则 2    ，**只有访问到的对象才会加锁**，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么    session B 的 update 语句可以执行完成。但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10)锁住。需要注意，在这个例子中，lock in share mode 只锁覆盖索引，但是如果是 forupdate 就不一样了。 执行 for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用 lockin share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将session A 的查询语句改成 select d from t where c=5 lock in sharemode。你可以自己验证一下效果。