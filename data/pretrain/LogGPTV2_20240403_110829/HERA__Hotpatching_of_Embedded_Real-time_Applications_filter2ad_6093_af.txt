### Verification of Transaction Abort Consistency

To verify that the transaction abort, which requires a single instruction fetch, is constant and independent of the aborted instruction, we conducted measurements by replacing various instructions. The results, including the pin overhead and the overhead to branch to and return from the `jump_section` with the respective instruction, are presented in Table II. The chosen instructions are common and cover a wide range of execution costs. 

**Table II: Time Required to Abort Different Instructions**

| Instruction | Cycles | Duration (µs) |
|-------------|--------|---------------|
| NOP         | 1      | 1.644         |
| PUSH {lr}   | 2      | 1.644         |
| LDR         | 2      | 1.644         |
| B.n         | 2      | 1.644         |
| UDIV        | 2-12   | 1.644         |

The no-operation (NOP) instruction takes a single CPU cycle, the PUSH instruction takes two cycles, and a division (UDIV) can take up to 12 cycles to complete. The measured duration, which includes the execution time, remained consistent across different instructions. This confirms that the transaction abort is constant and independent of the instruction being replaced by the trampoline. The pin overhead is also constant and amounts to 1.384 µs for this measurement setup. Detailed breakdowns of the cost per instruction can be found in the ARM Cortex-M4 processor reference manual [23].

### Further Measurements

In general, patches can consist of multiple parts as several issues may need to be fixed in a single hotpatch. HERA supports the use of multiple trampolines, making it easy to handle such scenarios. We evaluated the time required to execute multiple patches in sequence. The Flash Patch and Breakpoint (FPB) unit on the Cortex-M4 processor supports up to six breakpoints [23]. However, we used only five in our evaluation, reserving one breakpoint for the measurement setup. The setup consists of a while-loop containing NOP instructions, which were replaced step by step with trampolines by configuring the FPB breakpoints.

**Figure 7: Measured Times for Each Number of Breakpoints**

A single measurement represents a loop cycle with the previously configured number of breakpoints. The reference baseline, i.e., the overhead due to the pin triggering, is indicated by zero breakpoints. Each measurement was repeated five times. As expected, we did not measure any deviation, as the switches by the FPB unit are atomic instructions with fixed execution time. It can be safely stated that the duration per breakpoint is constant, and multiple trampolines can be inserted with a known and constant overhead.

### Full End-to-End Experiment on Syringe Pump

To validate that the patching process using HERA works correctly in practice, we performed a full end-to-end experiment on a syringe pump. We measured the timings of the full hotpatching process during the operation of the syringe pump using an oscilloscope. The syringe pump applies 1 mL with 1-second pauses in a continuous process. First, the normal operation of the unpatched program was measured. Then, during an idle phase, the patch was applied and activated. The operation continued seamlessly. Using the oscilloscope, we verified that the timings were not affected by either the hotpatch or the patch application. The patch application, which was automatically scheduled during the idle-time, did not cause any delay.

**Figure 6: Experiment and Measured Results on Syringe Pump**

### Case Study: Patching FreeRTOS

In our second case study, we used the HERA framework to patch an existing vulnerability in FreeRTOS. CVE-2018-16601 [56] describes a vulnerability in the TCP/IP stack of FreeRTOS, allowing memory corruption and enabling a remote attacker to execute code remotely or perform a denial-of-service (DoS) attack. This vulnerability is caused by a missing bounds check, as the size of the IP header is not validated at any point [57]. FreeRTOS versions up to 10.0.1 are affected, with a CVSSv3 score of 8.1 (high). This is a severe vulnerability that should be patched immediately. However, updating a device interrupts its service, leading to delayed patches. Therefore, we developed a hotpatch that works without impairing the device or its service, following our previously described guidelines.

We compiled two binaries: the first is a vulnerable release of FreeRTOS, and the second is a patched version. We integrated the HERA framework such that the patch is automatically applied to the first, vulnerable binary. Specifically, we developed a prototype based on FreeRTOS Labs 160919, which uses FreeRTOS 9.0.0 with the vulnerable TCP/IP stack [68]. We linked the HERA library to the vulnerable FreeRTOS and compiled it into a binary. We then backported the fix from the recent FreeRTOS 10.0.3 with TCP/IP stack V2.2.1 to the vulnerable FreeRTOS 9.0.0. Using Radare2, we performed a binary diff from the two binaries and derived a hotpatch. We implemented a low-priority updater task that automatically applies the update as soon as the system is in IDLE status. Details on the development process and implementation of this hotpatch have been described in Sections VI-C and VI-E.

This case study demonstrates that the HERA framework is suitable for hotpatching practical security vulnerabilities.

### Conclusion of Evaluation

Our case studies on medical devices show that HERA can be used to hotpatch critical embedded systems. The hotpatch for CVE-2018-16691, a serious vulnerability in FreeRTOS, is an example of an existing vulnerability that can be hotpatched. Through extensive measurements, we provide evidence that the performance overhead induced by HERA is negligible both in theory and practice. The overhead for a Control Flow Redirection is on a sub-instructional level, and the Atomic Switch Time is only a single assembly instruction, which is either executed to completion or disregarded by the CPU. The design of the trampolines is the minimal number of instructions required to jump to the patch. It is possible to insert multiple trampolines with constant, predictable, and negligible overhead, which was verified in a full end-to-end experiment. This makes HERA suitable for patching systems with hard real-time properties, i.e., the most strict and critical requirements. In particular, our case studies on real-world medical device software demonstrate that HERA provides an efficient and effective mechanism to hotpatch resource-constrained embedded devices with real-time constraints.

### Related Work

The need for hotpatching arises from high availability constraints. The concept of hotpatching or dynamic software updating has been around for some time, focusing primarily on traditional software [12]. Research has made significant efforts to apply hotpatching to traditional software, especially server applications [13]–[15]. Gu, Cao, Xu, et al. optimized a Java VM using a lazy updating approach to avoid a disruptive halt and restart cycle [69]. Even the multi-threaded nature of server applications has been considered [15], [70]. While traditional updates, where programs or systems are restarted, erase the system state, in hotpatching, this state must be maintained. A main challenge in hotpatching is applying changes and transferring this state. Makris and Bazzi discuss a stack reconstruction algorithm that allows the update of active functions [71]. Other work focuses on a checkpoint model, i.e., putting the program into a state where state transfer is easily achievable. The Kitsune framework [17] uses such update points, which need to be specified by the programmer. This model has been extended to support arbitrary complex software updates [13]. Giuffrida, Iorgulescu, Kuijsten, et al. present a fault-tolerant state transfer approach [72]. The POLUS framework targets server software and introduces a state synchronization model to eliminate the need for specific update points. It maintains the new and old data structures in parallel and gradually shifts towards the new data structure through synchronization [15]. However, not all updates require a complex state transfer mechanism. In contrast to generic program updates, security patches are often "small, isolated, and feature-less" [51]. The prevalent model for applying hotpatching is the relocation of executables [16], [17], [73].

In general, hotpatching, also called dynamic software updates, can be categorized by the used model and the effect of the software update [34]. With the rise of the Internet of Things (IoT) and the spread of cyber-physical systems, hotpatching has been considered as an approach to address security issues. Cyber-physical systems and IoT devices represent distributed systems that interact with real-world entities, often requiring real-time or high availability constraints. Park, Kim, Kim, et al. describe an architecture for gathering and distributing updates [74]. Felser, Kapitza, Kleinöder, et al. also present a special architecture for patching sensor nodes [75]. It includes the automatic calculation of differences and image creation to update the sensor node incrementally. Current research focuses on the domain of smart devices and their application fields, e.g., energy management or smart cities. In sensor nodes, energy consumption is often a critical factor. This challenge is addressed by Zhang, Ahn, Zhang, et al. in the context of energy-harvesting devices [40]. Mugarza, Amurrio, Azketa, et al. describe the application and deployment of a hotpatch and live update framework, Cetratus [39], in the smart city domain [76]. Salls, Shoshitaishvili, Stephens, et al. present Piston, a framework that allows hotpatching on devices not designed for such hotpatching by using exploits [77].

Real-time requirements introduce further challenges to hotpatching [41]–[43]. Wahler, Richter, and Oriol describe a generic software-based hotpatching for real-time systems and its components [41]. They investigate how to identify suitable times for the update process and propose a state transfer model. The key assumption is that the critical update process has a linear time amount, fitting within one cycle. Furthermore, the state transfer assumes a shared memory space that an updated component can take over. The main limitation is that the state transfer must fit within one cycle. Therefore, Wahler, Richter, Kumar, et al. propose a state synchronization algorithm to synchronize two components, i.e., the old and new components. An atomic switchover occurs at the full synchronization point, allowing updates with arbitrarily large states [42]. Wahler and Oriol present FASA (Future Automation System Architecture), implementing the component-based updating model [43].

An important additional aspect in high-availability systems is often fault-tolerance. Besides availability, many systems also need fault-resistance. A measure to achieve fault-tolerance is redundancy or replication. Various replication schemes exist and can be integrated into hard real-time applications [78]. Replicated systems can be patched one at a time, as they usually substitute each other during downtime. There are multiple solutions to achieve replication [79]. While this is a good solution if multiple, redundant instances are already available, it is not a general solution. Redundancy is costly and requires hardware and resources not present in limited embedded systems. Therefore, hotpatching embedded systems is often the only viable solution.

### Conclusion and Summary

Current research has not yet fully addressed the challenges of applying hotpatches on embedded devices, particularly the low resource availability due to the need for low-energy consumption, guaranteed availability, and the simultaneous need for hard real-time capabilities. In this paper, we present HERA, the first framework to tackle these challenges, allowing the application of hotpatches to real-time constrained embedded systems using commercial off-the-shelf hardware. Patches in HERA are processed during idle-time and activated within just a single processor instruction, ensuring that patching does not interfere with the application or other processes. The patch itself is added by the on-board debugging unit during runtime with negligible and exactly predictable overhead, verified by oscilloscope measurements. This makes HERA suitable for systems with the most stringent real-time requirements. In a case study, we used HERA to hotpatch two medical devices with a critical vulnerability. Additionally, we developed hotpatches for HERA to patch a real-world vulnerability in the TCP/IP stack of FreeRTOS. This demonstrates the effective and efficient applicability of HERA to hotpatch real-time critical embedded systems.

### Acknowledgment

This work has been partially funded by the DFG as part of project S2 within the CRC 1119 CROSSING. This work was supported by the DFG Priority Program SPP 2253 Nano Security (Project RAINCOAT). We thank our shepherd Jeyavijayan Rajendran and the anonymous reviewers for their valuable feedback.

### References

[1] O. Alrawi, C. Lever, M. Antonakakis, and F. Monrose, “SoK: security evaluation of home-based IoT deployments,” in IEEE Symposium on Security and Privacy (SP), IEEE, 2019. DOI: 10.1109/SP.2019.00013.

[2] D. Halperin, T. S. Heydt-Benjamin, B. Ransford, S. S. Clark, B. Defend, W. Morgan, K. Fu, T. Kohno, and W. H. Maisel, “Pacemakers and implantable cardiac defibrillators: Software radio attacks and zero-power defenses,” in IEEE Symposium on Security and Privacy (SP), IEEE, 2008. DOI: 10.1109/SP.2008.31.

[3] US Food and Drug Administration, Firmware update to address cybersecurity vulnerabilities identified in Abbott’s (formerly St. Jude Medical’s) implantable cardiac pacemakers: FDA safety communication, Oct. 18, 2017. [Online]. Available: https://www.fda.gov/medical-devices/safety-communications/firmware-update-address-cybersecurity-vulnerabilities-identified-abbotts-formerly-st-jude (visited on 06/25/2020).

[4] D. B. Kramer and K. Fu, “Cybersecurity concerns and medical devices: Lessons from a pacemaker advisory,” JAMA, vol. 318, no. 21, 2017.