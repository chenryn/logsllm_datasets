    00042: REVERT
    00043: JUMPDEST
    00044: CALLVALUE
    00045: DUP1
    00046: ISZERO
    00047: PUSH1 0x4e
    00049: JUMPI
    0004a: PUSH1 0x00
    0004c: DUP1
    0004d: REVERT
    0004e: JUMPDEST
    0004f: POP
    00050: PUSH1 0x58
    00052: PUSH1 0x04
    00054: CALLDATALOAD
    00055: PUSH1 0x73
    00057: JUMP
    00058: JUMPDEST
    00059: PUSH1 0x40
    0005b: DUP1
    0005c: MLOAD
    0005d: SWAP3
    0005e: ISZERO
    0005f: ISZERO
    00060: DUP4
    00061: MSTORE
    00062: PUSH1 0x20
    00064: DUP4
    00065: ADD
    00066: SWAP2
    00067: SWAP1
    00068: SWAP2
    00069: MSTORE
    0006a: DUP1
    0006b: MLOAD
    0006c: SWAP2
    0006d: DUP3
    0006e: SWAP1
    0006f: SUB
    00070: ADD
    00071: SWAP1
    00072: RETURN
    00073: JUMPDEST
    00074: PUSH1 0x00
    00076: DUP1
    00077: SLOAD
    00078: DUP3
    00079: ADD
    0007a: DUP1
    0007b: DUP3
    0007c: SSTORE
    0007d: DUP2
    0007e: SWAP1
    0007f: DUP4
    00080: GT
    00081: ISZERO
    00082: PUSH1 0x86
    00084: JUMPI
    00085: Missing opcode 0xfe
    00086: JUMPDEST
    00087: SWAP2
    00088: POP
    00089: SWAP2
    0008a: JUMP
    0008b: STOP
我们从第一条指令开始分析构建基本块的过程。00000地址处的指令是程序的第一条指令，根据构建基本块的第一个原则，将其作为新的基本块的第一条指令；0000b地址处是一条跳转指令，根据构建基本块的第二个原则，将其作为新的基本块的最后一条指令。这样我们就把从地址00000到0000b的代码构建成一个基本块，为了之后方便描述，把这个基本块命名为基本块1。
接下来0000c地址处的指令，我们作为新的基本块的第一条指令。0003d地址处是一条跳转指令，根据构建基本块的第二个原则，将其作为新的基本块的最后一条指令。于是从地址0000c到0003d就构成了一个新的基本块，我们把这个基本块命名为基本块2。
以此类推，我们可以遵照构建基本块的三个原则构建起所有的基本块。构建完成后的基本块如下图所示：
基本块
图中的每一个矩形是一个基本块，矩形的右半部分是为了后续描述方便而对基本块的命名(当然你也可以命名成自己喜欢的名字)。矩形的左半部分是基本块所包含的指令的起始地址和结束地址。当所有的基本块都构建完成后，我们就把之前的反编译代码转化成了11个基本块。接下来我们将构建基本块之间的边。
###  3.3 构建基本块之间的边
简单来说，基本块之间的边就是基本块之间的跳转关系。以基本块1为例，其最后一条指令是条件跳转指令，如果条件成立就跳转到基本块3，否则就跳转到基本块2。所以基本块1就存在基本块1->基本块2和基本块1->基本块3两条边。基本块6的最后一条指令是跳转指令，该指令会直接跳转到基本块8，所以基本块6就存在基本块6->基本块8这一条边。
结合反编译代码和基本块的划分，我们不难得出所有边的集合E：
{  
‘基本块1’: [‘基本块2′,’基本块3’],  
‘基本块2’: [‘基本块3′,’基本块4’],  
‘基本块3’: [‘基本块11’],  
‘基本块4’: [‘基本块5′,’基本块6’],  
‘基本块5’: [‘基本块11’],  
‘基本块6’: [‘基本块8’],  
‘基本块7’: [‘基本块8’],  
‘基本块8’: [‘基本块9′,’基本块10’],  
‘基本块9’: [‘基本块11’],  
‘基本块10’: [‘基本块7’]  
}
我们把边的集合E用python中的dict类型表示，dict中的key是基本块，key对应的value值是一个list。还是以基本块1为例，因为基本块1存在基本块1->基本块2和基本块1->基本块3两条边，所以’基本块1’对应的list值为[‘基本块2′,’基本块3’]。
###  3.4 构建控制流图
在前两个小节中我们构建完成了基本块和边，到此构建控制流图的准备工作都已完成，接下来我们就要把基本块和边整合在一起，绘制完整的控制流图。
控制流图
上图就是完整的控制流图，从图中我们可以清晰直观的看到基本块之间的跳转关系，比如基本块1是条件跳转，根据条件是否成立跳转到不同的基本块，于是就形成了两条边。基本块2和基本块1类似也是条件跳转，也会形成两条边。基本块6是直接跳转，所以只会形成一条边。
在该控制流图中，只有一个起始块(基本块1)和一个结束块(基本块11)。当流程走到基本块11的时候，表示整个流程结束。需要指出的是，基本块11中只包含一条指令STOP。
###  3.5 总结
本章先介绍了控制流图中的基本概念，之后根据基本块的构建原则完成所有基本块的构建，接着结合反编译代码分析了基本块之间的跳转关系，画出所有的边。当所有的准备工作完成后，最后绘制出控制流图。在下一章中，我们将对构建好的控制流图，采用z3对其进行约束求解。
## 第四章 从控制流图开始约束求解
在本章中我们将使用z3对第三章中生成的控制流图进行约束求解。z3是什么，约束求解又是什么呢？下面将会给大家一一解答。
约束求解：求出能够满足所有约束条件的每个变量的值。
z3： z3是由微软公司开发的一个优秀的约束求解器，用它能求解出满足约束条件的变量的值。
从3.4节的控制流图中我们不难发现，图中用菱形表示的跳转条件左右着基本块跳转的方向。如果我们用变量表示跳转条件中的输入数据，再把变量组合成数学表达式，此时跳转条件就转变成了约束条件，之后我们借助z3对约束条件进行求解，根据求解的结果我们就能判断出基本块的跳转方向，如此一来我们就能模拟整个程序的执行。
接下来我们就从z3的基本使用开始，一步一步的完成对所有跳转条件的约束求解。
###  4.1 z3的使用
我们以z3的python实现z3py为例介绍z3是如何使用的[[3]](https://ericpony.github.io/z3py-tutorial/guide-examples.htm)。
**4.1.1 基本用法**
    from z3 import *
    x = Int('x')
    y = Int('y')
    solve(x > 2, y  2, y  5)
在z3中除了可以创建位向量变量之外，也可以创建位向量常量。下面代码中的BitVecVal(-1, 16)创建了一个长度为16位，值为1的位向量常量。
    from z3 import *
    a = BitVecVal(-1, 16)
    b = BitVecVal(65535, 16)
    print simplify(a == b)
**4.1.4 求解器**
    from z3 import *
    x = Int('x')
    y = Int('y')
    s = Solver()
    s.add(x > 10, y == x + 2)
    print s
    print s.check()
在上面代码中，Solver()创建了一个通用的求解器，之后调用add()添加约束，调用check()判断是否有满足约束的解。如果有解则返回sat，如果没有则返回unsat
###  4.2 使用z3进行约束求解
对于智能合约而言，当执行到CALLDATASIZE、CALLDATALOAD等指令时，表示程序要获取外部的输入数据,此时我们用z3中的BitVec函数创建一个位向量变量来代替输入数据;当执行到LT、EQ等指令时，此时我们用z3创建一个类似If(ULE(xx,xx),
0, 1)的表达式。
4.2.1 **生成数学表达式**
接下来我们以3.2节中的基本块1为例，看看如何把智能合约的指令转换成数学表达式。
在开始转换之前，我们先来模拟下以太坊虚拟机的运行环境。我们用变量stack=[]来表示以太坊虚拟机的栈，用变量memory={}来表示以太坊虚拟机的内存，用变量storage={}来表示storage。
基本块1为例的指令码如下:
    00000: PUSH1 0x80
    00002: PUSH1 0x40
    00004: MSTORE
    00005: PUSH1 0x04
    00007: CALLDATASIZE
    00008: LT
    00009: PUSH1 0x3e
    0000b: JUMPI
PUSH指令是入栈指令，执行两次入栈后，stack的值为[0x80,0x40]
MSTORE执行之后，stack为空，memory的值为{0x40:0x80}
CALLDATASIZE指令表示要获取输入数据的长度，我们使用z3中的BitVec(“Id_size”,256),生成一个长度为256位，名为Id_size的变量来表示此时输入数据的长度。
LT指令用来比较0x04和变量Id_size的大小，如果0x04小于变量Id_size则值为0，否则值为1。使用z3转换成表达式则为：If(ULE(4,
Id_size), 0, 1)
JUMPI是条件跳转指令，是否跳转到0x3e地址处取决于上一步中LT指令的结果，即表达式If(ULE(4, Id_size), 0,
1)的结果。如果结果不为0则跳转，否则不跳转，使用z3转换成表达式则为:If(ULE(4, Id_size), 0, 1) != 0
至此，基本块1中的指令都已经使用z3转换成数学表达式。
**4.2.2 执行数学表达式**
执行上一节中生成的数学表达式的伪代码如下所示：
    from z3 import *