to use secure hardware. Intel’s LaGrande [25], AMD’s
platform for trustworthy computing [2], and Copilot
[36] all propose hardware that can be used to develop
and deploy low-layer security software that would run
beneath a VMBR.
Another way to gain control below the VMBR is to
boot from a safe medium such as a CD-ROM, USB
drive or network boot server. This boot code can run
on the system before the VMBR loads and can view
the VMBR’s quiescent disk state. Strider GhostBuster
is an example of security software that uses a bootable
CD-ROM to gain control before the OS boots [48]. As
we point out in Section 3.4, VMBRs can avoid booting
from safe medium by emulating system shutdowns and
reboots, thus we recommend physically unplugging the
machine before attempting to boot from a safe medium.
A third way to gain control below the VMBR is to
use a secure VMM [17]. Like alternative bootable me-
dia, secure VMMs gain control of the system before
the operating system boots. Running a secure VMM
does not by itself stop a VMBR, as a VMBR can still
insert itself between the VMM and the operating sys-
tem. However, a secure VMM does retain control over
the system as it runs and could easily add a check to
stop a VMBR from modifying the boot sequence above
the secure VMM.
Using a secure VMM, we implemented an enhanced
version of secure boot which can prevent VMBR in-
stallations. The goal of our secure boot system is to
provide attestation for existing boot components, such
as the disk’s master boot record, the ﬁle system’s boot
sector, and the OS’s boot loader and also to allow le-
gitimate updates of these components. All attempted
updates of these components are veriﬁed (by checking
the cryptographic signature) before they are allowed to
complete. The veriﬁcation code resides in a separate
virtual machine, so it is protected from malicious code
running within the guest. We implement this secure
boot system using a Virtual PC VMM and a Windows
XP guest operating system.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
5.2. Security software above the VMBR
While running detection software below a VMBR is
the best way to detect the VMBR, it is generally incon-
venient to run software at such a low level. For exam-
ple, booting from a safe medium can detect a VMBR,
but such a reboot may only occur infrequently. In this
section, we explore the question of whether software
running above the VMBR (i.e., in the target system)
can detect the presence of the VMBR.
There are several reasons why traditional techniques
(e.g., having the target system scan memory or disk)
may not be able to detect a VMBR. First, the target
system is conﬁned to its virtual machine. Since the
VMBR stores its state outside that virtual machine,
the target system will see no suspicious changes in its
own state. Second, even if the target system did see
something amiss, the VMBR could tamper with the
execution of the detector and force it to report incorrect
results.
With these limitations in mind, we analyze the pos-
sible perturbations that a detector could notice while
running inside the virtual machine.
A fundamental perturbation of the VMBR is that
it uses machine resources such as CPU time, memory
and disk space, and possibly network bandwidth. A
VMBR adds CPU overhead to trap and emulate priv-
ileged instructions, as well as to run any malicious
services. These timing diﬀerences can be noticed by
software running in the virtual machine by comparing
the running time of benchmarks against wall-clock time
[42, 28]. A VMBR can make the detector’s task more
diﬃcult by slowing down the time returned by the sys-
tem clock, but the detector can overcome this by using
a clock that can be read without interference from the
VMBR (e.g., the user’s wristwatch).
In addition to CPU overhead, a VMBR uses memory
and disk space. A detector can detect this overhead by
running a program that requires the entire machine’s
memory or disk space. A VMBR can hide its space
overhead in several ways. It can hide its memory over-
head by mapping target pages with the same contents
to the same physical page [47] or by paging some data
to disk. While this extra paging activity may increase
the running time of the program, the memory overhead
of VMware was too small to measure in our tests. A
VMBR can hide its disk overhead by compressing a
portion of the disk, sharing disk blocks with the same
contents, or pretending that the disk space it uses have
bad sectors. We implemented the bad sector trick for
Windows XP target systems; if the target system at-
tempts to use these sectors, we emulate bad sectors by
squashing writes and returning random data on reads.
Another type of perturbation is caused by the vari-
ety of I/O devices on the computer. Recall that a VMM
typically virtualizes all I/O devices. However, virtual-
izing the I/O device without changing the target’s view
of the device requires one to understand the interface
and semantics of each device. This is a formidable
task, given the wide variety of I/O devices present on
today’s computing platforms. Instead, current VMMs
emulate a small number of virtual devices (often with
customized interfaces to improve performance [1, 34]).
The target OS must then use the drivers for the em-
ulated virtual devices. For example, when targeting
Windows XP systems, we had to update ntoskrn.exe
and hal.sys drivers to match the virtual hardware.
Intrusion detectors can observe the change in devices
that occurs when the VMBR is installed. A VMBR
can simplify the task of emulating all devices by choos-
ing to virtualize only those devices that are required
to protect its state (e.g., the boot disk) or to carry out
malicious activity (e.g., network card). The VMBR
can allow the target OS to access remaining devices
directly [32]. This solves the problem of virtualizing
all devices, but on today’s x86 platform it potentially
exposes VMBR state because target OS drivers with
direct access to devices can access all physical memory
through DMA.
A ﬁnal source of perturbations are caused by the im-
perfect virtualization of today’s x86 processors. Sen-
sitive, non-privileged instructions like sidt leak infor-
mation about the VMM yet do not trap to the VMM
[31, 37]. Commercial VMMs use binary translation to
emulate these instructions, but only when they are exe-
cuted at the processor’s highest privilege level (ring 0).
An intrusion detector can execute these instructions at
a lower processor privilege level (rings 1 - 3) to detect
a VMBR. In Section 3.3, we describe how we defend
against a common virtual-machine detection technique
(redpill) that uses such an instruction. However, de-
fending against all invocations of this instruction would
require binary translation for all instructions, not just
ring 0 instructions, which may slow performance.
We expect future enhancements to the x86 plat-
form to reduce these perturbations. Upcoming virtu-
alization support from Intel [45] and AMD [7] will en-
able more eﬃcient virtualization. These enhancements
eliminate sensitive, non-privileged instructions so they
cannot be used from the CPU’s user-mode to detect
the presence of a VMM. These enhancements may also
accelerate transitions to and from the VMM, and this
may reduce the need to run specialized guest drivers.
In addition to virtualization support, I/O MMUs [6]
provide the ability to protect physical memory pages
from device DMA. This protection will enable a VMBR
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
to emulate a subset of devices and allow the target OS
to drive all other hardware directly. As a result, the
devices visible to the target can be similar or identical
to the underlying physical hardware.
6. Trends toward virtualization
In this section we discuss how the trend of hardware
virtualization support and the trend of widespread
VMM adoption might aﬀect VMBRs.
First,
future enhancements to the x86 hardware
platform may make VMBRs more practical. As we
point out in Section 5, limitations to the current x86
hardware platform force VMM designers to introduce
perturbations into the system which make it straight-
forward to detect the presence of VMMs; future en-
hancements to the x86 platform should help reduce
these perturbations. This trend toward hardware vir-
tualization support might also make VMBRs more
practical by reducing the amount of state needed to
support VMBRs, reducing the amount of time needed
to boot VMBRs, and allowing hardware devices to per-
form at full capacity. For example, if a VMBR gives the
target OS video driver direct access to the underlying
video card, the VMM could omit all video drivers and
graphics subsystems (e.g., X), thus reducing the size of
the VMBR payload. Also, the VMM would not have
to initialize the video card since the target OS video
driver will take the appropriate initialization steps, re-
sulting in faster boot time. Finally, all features of the
hardware video card would be available to the target
system, so high-end video applications, like 3D games,
would not suﬀer any performance degradation like they
might if the VMBR used a virtualized video card.
Second, the trend towards widespread VMM use
might help defenders detect and prevent VMBRs, but
simply running a VMM will not avert the threat. It
might be possible for VMBRs to reside in between the
VMM and the target OS, thus still asserting full con-
trol over the target system. In fact, since the target OS
is already expecting to run above a VMM, not phys-
ical hardware, inserting a VMBR in between a VMM
and a target OS might be easier than inserting one
between physical hardware and an operating system.
This task might be easier because the interface to the
virtual hardware will likely be much simpler than the
interface to physical hardware. Fortunately, having a
secure VMM in place gives defenders the advantage
since it runs beneath VMBRs and has complete con-
trol over software running above. Also, a secure VMM
is ﬂexible enough to support the development and de-
ployment new security services designed to thwart the
VMBR threat.
7. Related work
Our work on VMBRs is related to four areas of prior
work:
layer-below attacks, using virtual machines to
enhance security, detecting the presence of VMMs, and
inserting new software layers into existing systems.
Layer-below attacks are a well-known technique for
compromising the security of a system [21]. By ac-
cessing or controlling a layer of software that is be-
low a defense mechanism, an attacker can avoid and
disable that mechanism. For example, rootkits imple-
mented in the operating system kernel are a common
layer-below attack [22, 41]. While kernel-level rootkits
can hide easily from user-level intrusion detection sys-
tems, kernel-level detectors like VICE [11] and Klister
[38] can detect kernel-level rootkits because both run
at the same privilege level and in the same memory
space. Shadow Walker hides some of the memory foot-
print of a standard kernel-level rootkit by manipulating
the page table, TLB data, and page fault handler [43].
While this resembles some of the techniques used in
virtual machines, Shadow Walker only partially virtu-
alizes the OS; for example, the OS still runs in kernel
mode and can see and restore the modiﬁed page fault
handler and page tables. In contrast, VMBRs operate
below any kernel-level detector and thus can hide all
their state and events from these detectors.
A second area of research related to VMBRs are
projects that use virtual machines to enhance security.
Researchers have used virtual machines to detect intru-
sions [18, 8, 27], isolate services [33], encrypt network
traﬃc [33], analyze intrusions [14], and implement hon-
eypots [26, 46]. These services leverage the advantages
of virtual machines, in particular isolation and interface
compatibility, to enhance the security of systems with-
out requiring the cooperation or correctness of higher
levels of software. VMBRs exploit these same features
to protect and hide malicious software from operating
system and application-level security services. Besides
diﬀerent goals, VMBRs diﬀer from past VM-based ser-
vices in how they are installed. VMBRs must install
themselves beneath a system while preserving the per-
sistent state of that system.
In contrast, prior VM-
based services have assumed that a system would be
installed into a virtual machine rather than being mi-
grated from a non-virtual machine.
A third area of related research are projects that
detect the presence of VMMs by observing timing per-
turbations. Pioneer [42] attempts to detect the exis-
tence of a VMM by measuring the amount of time it
takes to execute a specialized checksum over the code
of its veriﬁcation function. This checksum is designed
to be optimal for the particular processor it runs on
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:48:08 UTC from IEEE Xplore.  Restrictions apply. 
and includes sensitive, non-privileged instructions in
its computation. Because sensitive, non-privileged in-
structions must be emulated by the VMM, this com-
putation will be sub-optimal when run within a virtual
machine. Pioneer uses a remote dispatcher machine
to measure timing, so the timing does not rely on the
local clock which is under the control of the VMBR.
Finally, VMBRs apply the general idea of inserting
a new layer into an existing system. Other applications
of this idea include virtual machines [15], stackable ﬁle
systems [23], and preserve compatibility with existing
systems by not modifying the network ﬁrewalls. A key
feature of all these applications is that they preserve
compatibility with existing systems by not modifying
interfaces of the existing layers. For example, a virtual-
machine monitor is inserted between the hardware and
the operating system, and an operating system running
on an ideal VMM sees the same hardware interface as
an operating system running directly on the hardware.
8. Conclusions
Traditional malicious software is limited because it
has no clear advantage over intrusion detection systems
running within a target system’s OS. In this paper, we
demonstrated how attackers can gain a clear advan-
tage over intrusion detection systems running in a tar-