must have received missing shares corresponding to the blame mes-
sages it received and forwarded (which includes share for ğ‘ğ‘–). Thus,
all the honest nodes shares to reconstruct the proposed secrets.
We note that both eVSS and iVSS schemes guarantee secrecy
(see Definition 2.4) only when the dealer is honest. If ğ‘¡ Byzantine
nodes send a blame message, then an honest but curious node can
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3510commitment VSS.C to the secret ğ‘  on the bulletin board.
bulletin board, each node ğ‘ğ‘– âˆˆ P does the following:
Let VSS be the VSS scheme being used. Let VSS.pp be the public VSS parameters. Let ğ¿ be a dealer with secret ğ‘ . Assuming the existence of a
1. Post commitment. If ğ‘ğ‘– is ğ¿, then generate shares for every node by running (VSS.(cid:174)ğ‘†, VSS. (cid:174)ğ‘Š , VSS.C) â† VSS.ShGen(ğ‘ ), and post the
2. Send shares. If ğ‘ğ‘– is ğ¿, then send shares VSS.sğ‘— âˆˆ VSS.(cid:174)ğ‘† and witness VSS.ğœ‹ ğ‘— âˆˆ VSS. (cid:174)ğ‘Š over the confidential channel to all nodes ğ‘ ğ‘— âˆˆ P.
3. Send blames. Post
if
4. Open shares. For all blames âŸ¨blame, ğ¿âŸ©ğ‘–, if ğ‘ğ‘– is ğ¿, post their shares VSS.sğ‘— and witnesses VSS.ğœ‹ ğ‘— on the bulletin board.
5. Decide. If the published share and witness satisfies VSS.ShVrfy(VSS.sğ‘˜, VSS.ğœ‹ğ‘˜, VSS.C) = 1 for every blame, and there are only up to
âŸ¨blame, ğ¿âŸ©ğ‘– on the bulletin board,
VSS.ShVrfy(VSS.sğ‘–, VSS.ğœ‹ğ‘–, VSS.C) = 0.
ğ‘“ â‰¤ ğ‘¡ blames on the bulletin board, then commit VSS.sğ‘—. Otherwise, abort, i.e., output âŠ¥.
complaints
if no valid share is
received privately or
Figure 5: eVSS [32] protocol description. This scheme is to secret share one secret.
Let VSS be the VSS scheme being used. Let VSS.pp be the public VSS parameters. Let ğ¿ be a dealer with ğ‘› secrets ğ‘† := {ğ‘ 1, . . . , ğ‘ ğ‘›} it wishes to secret share
with nodes P. Assuming the existence of a bulletin board, each node ğ‘ğ‘– âˆˆ P does the following:
is ğ¿, run (VSS.(cid:174)ğ‘†ğ‘–, VSS. (cid:174)ğ‘Šğ‘–, VSS.Cğ‘–) â† VSS.ShGen(ğ‘ ğ‘–) for all ğ‘ ğ‘–
âˆˆ ğ‘†. Build the commitment vector VSS. (cid:174)ğ¶ :=
1. Post commitment. If ğ‘ğ‘–
{VSS.C1, . . . , VSS.Cğ‘›} which contain commitments VSS.Cğ‘– for ğ‘ ğ‘–. Post VSS. (cid:174)ğ¶ on the bulletin board.
2. Send shares. If ğ‘ğ‘– is ğ¿, collect shares and witnesses (VSS.sğ‘— , VSS.ğœ‹ ğ‘—) for every node ğ‘ ğ‘— âˆˆ P, and secret ğ‘ ğ‘– âˆˆ ğ‘†, and build VSS.(cid:174)ğ‘† ğ‘— , VSS. (cid:174)ğ‘Šğ‘— . Send
(VSS.(cid:174)ğ‘† ğ‘— , VSS. (cid:174)ğ‘Šğ‘—) to node ğ‘ ğ‘— âˆˆ P.
If ğ‘ğ‘– âˆˆ P is not the dealer ğ¿, then wait to obtain (VSS.(cid:174)ğ‘†ğ‘–, VSS. (cid:174)ğ‘Šğ‘–) from the dealer ğ¿, and ensure that VSS.ShVrfy(VSS.sğ‘— , VSS.ğœ‹ ğ‘— , VSS. (cid:174)ğ¶ ğ‘—) = 1 holds for
VSS.sğ‘— âˆˆ VSS.(cid:174)ğ‘†ğ‘–, and VSS.ğœ‹ ğ‘— âˆˆ VSS. (cid:174)ğ‘Šğ‘–.
3. Send blames. If invalid/no shares are received from the dealer ğ¿, then send âŸ¨blame, ğ¿âŸ©ğ‘– to all the nodes. Collect similar blames from other nodes.
4. Private open. Send all the collected blames to the dealer ğ¿. If ğ‘ğ‘– is the leader, then for every blame âŸ¨blame, ğ¿âŸ©ğ‘˜ received from node ğ‘ ğ‘— , send
5. Ack and decide. If ğ‘ğ‘– received â‰¤ ğ‘¡ blames and the leader responded with valid shares (VSS.(cid:174)ğ‘† ğ‘— , VSS. (cid:174)ğ‘Šğ‘—) for every âŸ¨blame, ğ¿âŸ©ğ‘— it forwarded, then send an
(VSS.(cid:174)ğ‘†ğ‘˜, VSS. (cid:174)ğ‘Šğ‘˜) to node ğ‘ ğ‘— .
If ğ‘ğ‘– is not ğ¿, then ensure that VSS.ShVrfy(VSS.sğ‘— , VSS.ğœ‹ ğ‘— , VSS. (cid:174)ğ¶ ğ‘—) = 1 for every âŸ¨blame, ğ¿âŸ©ğ‘— , VSS.sğ‘— âˆˆ VSS.(cid:174)ğ‘† ğ‘— , and VSS.ğœ‹ ğ‘— âˆˆ VSS. (cid:174)ğ‘Šğ‘— .
ack message to the dealer ğ¿.
If ğ‘ğ‘– is ğ¿, then post ack certificate (denoted by AC(VSS. (cid:174)ğ¶)) on the bulletin board.
If there is an ack certificate AC(VSS. (cid:174)ğ¶) on the bulletin board, commit VSS. (cid:174)ğ¶, and send (VSS.(cid:174)ğ‘† ğ‘— , VSS. (cid:174)ğ‘Šğ‘—), if received from ğ¿.
6. Reconstruction. Each node ğ‘ğ‘– âˆˆ P does the following:
(a) If there is a share VSS.sğ‘–, VSS.ğœ‹ğ‘–, send the share and witness to all the nodes.
(b) On receiving ğ‘¡ + 1 valid shares in VSS.(cid:174)ğ‘†, reconstruct the secret ğ‘  using ğ‘  â† VSS.Recon(VSS.(cid:174)ğ‘†). Send ğ‘  to all the nodes.
(c) On receiving an opened secret ğ‘ , ensure that VSS.ComVrfy(VSS.C, ğ‘ ) = 1 and output ğ‘ .
On receiving a share and witness (VSS.sğ‘— , VSS.ğœ‹ ğ‘—) from ğ‘ ğ‘— , ensure that VSS.ShVrfy(VSS.sğ‘— , VSS.ğœ‹ ğ‘— , VSS.C) = 1.
Figure 6: iVSS - Improved eVSS protocol description
violate secrecy, however this was also possible in the bulletin board
based protocol and can be easily solved by assuming an additional
honest node, i.e., ğ‘› > 2ğ‘¡ + 1.
4.2.2 Random Beacon for BRandPiper. In this section, we instanti-
ate bulletin boards using our SMR protocol (Section 3) and present a
random beacon protocol, we call BRandPiper, using the iVSS scheme.
If we use our SMR protocol with rotating leaders, we can commit
blocks of size ğ‘‚(ğœ…ğ‘›) within ğ‘¡ +1 epochs while incurring ğ‘‚(ğœ…ğ‘›2) bits
of communication per epoch. To obtain 1-absolute unpredictability,
we need to reconstruct at least ğ‘¡ + 1 secrets from distinct nodes in
each epoch. For simplicity, we reconstruct one secret from all nodes
that have not been removed. Using the round-robin leader selection
rule, every node can share secrets at least once every ğ‘› epochs. If in
every epoch, the leader proposes commitments to ğ‘› secrets using
SMR protocol, we can use these secrets for the next ğ‘› epochs in
the reconstruction. Our beacon output step can take advantage of
the homomorphic properties of the underlying VSS scheme VSS to
combine secret shares for multiple secrets from different nodes into
an ğ‘‚(ğœ…)-sized share which can be efficiently broadcast to all nodes.
Honest nodes collect ğ‘¡ + 1 homomorphic shares to reconstruct the
common randomness ğ‘…ğ‘’. Such reconstructed randomness is guar-
anteed to be unbiasable since an adversary cannot know the secrets
of honest nodes until reconstructed, and an adversary cannot pre-
vent reconstruction. For the same reason, our BRandPiper protocol
ensures 1-absolute unpredictability, even for a rushing adaptive
adversary.
Protocol Details. Leader selection. We employ a round robin leader
selection policy. If an epoch leader ğ‘ğ‘– fails to commit within ğ‘¡ + 1
epochs, it is added to the set of removed nodes Pğ‘Ÿ and is prevented
from being a future leader. The remaining nodes P \ Pğ‘Ÿ propose in
a round robin manner.
Setup. During the setup phase, all the nodes are provided with
VSS parameters VSS.pp required for using the VSS scheme VSS.
Each node maintains ğ‘› queues Q(ğ‘ğ‘–), for ğ‘ğ‘– âˆˆ P. Each queue
Q(ğ‘ğ‘–) holds tuples with each tuple containing a secret share, its
witness and commitment proposed by node ğ‘ğ‘– when node ğ‘ğ‘– was
an epoch leader. During the setup phase, each queue Q(ğ‘ğ‘–) is filled
with ğ‘š = ğ‘› + ğ‘¡ tuples containing secret shares, witnesses and
commitments for ğ‘š secrets. This ensures that all honest nodes have
common secret shares in Q(ğ‘ğ‘›) and can perform Dequeue(Q(ğ‘ğ‘›))
10
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3511up to epoch ğ‘› + ğ‘¡ even if ğ‘ğ‘› does not propose in epoch ğ‘›. This is
because honest nodes perform Dequeue(Q(ğ‘ğ‘›)) (explained later)
in each epoch unless node ğ‘ğ‘› has been removed. If node ğ‘ğ‘› does
not propose in epoch ğ‘›, it is removed only in epoch ğ‘› + ğ‘¡.
Buffer ğ‘¡ + 1 shares
ğ‘1
ğ‘2
ğ‘3
ğ‘4
ğ‘5
ğ‘£1,1
ğ‘£2,1
ğ‘£3,1
ğ‘£4,1
ğ‘£5,1
Â· Â· Â· ğ‘£1,3
Â· Â· Â· ğ‘£2,3
Â· Â· Â· ğ‘£3,3
Â· Â· Â· ğ‘£4,3
Â· Â· Â· ğ‘£5,3
ğ‘£1,4
ğ‘£2,4 ğ‘£2,5
ğ‘£3,4 ğ‘£3,5 ğ‘£3,6
â† Q(3)
ğ‘£4,4 ğ‘£4,5 ğ‘£4,6 ğ‘£4,7
ğ‘£5,1
â† ğ‘£5,4 ğ‘£5,5 ğ‘£5,6 ğ‘£5,7 ğ‘£5,8
Figure 7: An example illustration of BRandPiper for ğ‘› = 5 and ğ‘¡ = 2
in epoch ğ‘’ = 5. The region marked in red are the shares that will be
homomorphically combined in every epoch for reconstruction. In
general, in every epoch, shares from the left-most column will be
used for reconstruction. The region marked in yellow is the addition
of ğ‘› new shares by the leader ğ¿ğ‘’ = ğ‘5.
Example. Consider an example scenario as shown in Figure 7. In
epoch 5, ğ‘5 proposes and adds ğ‘› VSS shares to the system which
will be committed within ğ‘¡ + 1 = 3 epochs. If ğ‘5 is Byzantine, by the
end of epoch 8, all the nodes will remove ğ‘5 from future proposals,
thus guaranteeing outputs for every epoch. Until epoch 8 observe
that we have shares for ğ‘5.
Block validation protocol. BRandPiper uses a block validation
protocol to generate valid blocks for use in the SMR. A valid block
in BRandPiper is a vector of VSS commitments VSS. (cid:174)ğ¶ along with
acks from ğ‘¡ +1 nodes. The block validation protocol is essentially an
instance of iVSS where the leader ends up with ğ‘¡ + 1 votes for a VSS
commitment vector VSS. (cid:174)ğ¶. The commitment and ack certificate
is then input to the SMR protocol to ensure that all honest nodes
agree on a single commitment vector. During the SMR protocol,
the honest nodes vote only if a valid block is produced via the
block validation protocol. The block validation protocol guarantees
that if a block is certified, then all the honest nodes have sharings
for all the secrets committed in VSS. (cid:174)ğ¶. When these commitments
are committed via SMR, all the honest nodes use the secret shares
in the commitments in different epochs to generate the common
randomness.
The block validation protocol (refer Figure 8) is executed in par-
allel with SMR protocol. The leader ğ¿ğ‘’ of epoch ğ‘’ executes the
block validation protocol while in epoch ğ‘’ âˆ’ 1 to generate an ack
certificate for commitments to be proposed in epoch ğ‘’. The protocol
consists of following steps:
Distribute. Leader ğ¿ğ‘’ creates ğ‘› commitments VSS. (cid:174)ğ¶ correspond-
ing to ğ‘› secrets {ğ‘ 1, . . . , ğ‘ ğ‘›} it wishes to share using VSS.ShGen
algorithm for secrets {ğ‘ ğ‘–|âˆ€1 â‰¤ ğ‘– â‰¤ ğ‘›}, along with shares VSS.(cid:174)ğ‘† ğ‘—
:= {VSS.ğœ‹1,ğ‘— ,
. . . , VSS.ğœ‹ğ‘›,ğ‘—}, for all ğ‘ ğ‘— âˆˆ P. We define a block containing ğ‘› com-
mitments VSS. (cid:174)ğ¶ as ğ‘†ğµ := âŸ¨Commitment, VSS. (cid:174)ğ¶, ğ‘’, ğ‘§ğ‘ ğ‘’âŸ©ğ¿ğ‘’ . The leader
:= (cid:8)VSS.s1,ğ‘— , . . . , VSS.sğ‘›,ğ‘—(cid:9) and witnesses VSS. (cid:174)ğ‘Šğ‘—
ğ¿ğ‘’ sends VSS.(cid:174)ğ‘† ğ‘—, VSS. (cid:174)ğ‘Šğ‘—, and ğ‘†ğµ to node ğ‘ ğ‘—, for all ğ‘ ğ‘— âˆˆ P. Simi-
lar to the SMR protocol, the leader signs the tuple âŸ¨Commitment,
ğ»(VSS. (cid:174)ğ¶)), ğ‘’, ğ‘§ğ‘ ğ‘’âŸ© and sends VSS. (cid:174)ğ¶ separately to facilitate efficient
equivocation checks. It is important to note that commitment VSS. (cid:174)ğ¶,
shares VSS.(cid:174)ğ‘† ğ‘—, and witness VSS. (cid:174)ğ‘Šğ‘— are ğ‘‚(ğ‘›)-sized and the shares
VSS.sğ‘— are only sent to node ğ‘ ğ‘—. Sending only the required shares
to designated nodes reduces communication complexity.
Blame/Forward. If a node ğ‘ğ‘– receives a valid secret share VSS.(cid:174)ğ‘†ğ‘–,
witness VSS. (cid:174)ğ‘Šğ‘–, and sharing block ğ‘†ğµ := âŸ¨Commitment, VSS. (cid:174)ğ¶,
ğ‘’, ğ‘§ğ‘ ğ‘’âŸ©ğ¿ğ‘’ within 3Î” time in epoch ğ‘’ âˆ’ 1, it then calls the function-
ality Deliver(Commitment, ğ‘†ğµ, ğ‘§ğ‘ ğ‘’, ğ‘’). The valid share must satisfy
VSS.ShVrfy(VSS.sğ‘— , VSS.ğœ‹ ğ‘— ,
VSS. (cid:174)ğ¶ ğ‘—) = 1, âˆ€ğ‘— âˆˆ [ğ‘›]. Otherwise, node ğ‘ğ‘– broadcasts âŸ¨blame, ğ‘’âŸ©ğ‘–
to all nodes.
Request open. Node ğ‘ğ‘– waits for 6Î” time in epoch ğ‘’ âˆ’ 1 to collect
any blames sent by other nodes. If no blames or equivocation by
ğ¿ğ‘’ has been detected within that time, ğ‘ğ‘– sends âŸ¨ack, ğ»(ğ‘†ğµ), ğ‘’âŸ©ğ‘– to
ğ¿ğ‘’. If up to ğ‘¡ blames are received, ğ‘ğ‘– forwards the blames to ğ¿ğ‘’.
Private open. If ğ¿ğ‘’ receives any blames from node ğ‘ğ‘–, it sends valid
VSS.(cid:174)ğ‘† ğ‘—, witness VSS. (cid:174)ğ‘Šğ‘— for every blame âŸ¨blame, ğ‘’âŸ©ğ‘— received from
node ğ‘ğ‘–.
Ack. If node ğ‘ğ‘– forwarded any blames and received valid secret
shares VSS.(cid:174)ğ‘† ğ‘— and witness VSS. (cid:174)ğ‘Šğ‘— for every blame âŸ¨blame, ğ‘’âŸ©ğ‘— it
forwarded and detects no equivocation, node ğ‘ğ‘– sends a signed ack
âŸ¨ack, ğ»(ğ‘†ğµ), ğ‘’âŸ©ğ‘– to ğ¿ğ‘’. In addition, node ğ‘ğ‘– forwards secret shares
VSS.(cid:174)ğ‘† ğ‘— and witness VSS. (cid:174)ğ‘Šğ‘— for every blame âŸ¨blame, ğ‘’âŸ©ğ‘— it received.
Thus, if an honest node sends an ack for the sharing block ğ‘†ğµ, then
all honest nodes have their respective secret shares corresponding
to sharing block ğ‘†ğµ (more details in Lemma B.17).
Equivocation. At any time in epoch ğ‘’ âˆ’ 1, if a node ğ‘ğ‘– detects an
equivocation, it broadcasts equivocating hashes signed by ğ¿ğ‘’ and
stops participating in epoch ğ‘’ âˆ’ 1 block validation protocol.
Beacon protocol. We now present the beacon protocol (refer Fig-
ure 9) in BRandPiper. It consists of the following rules for an epoch
ğ‘’. Here, an epoch corresponds to an epoch in SMR protocol.
Generate Blocks. The leader ğ¿ğ‘’ of an epoch ğ‘’ chooses ğ‘› secrets uni-
formly at random and invokes the block validation protocol while
in epoch ğ‘’ âˆ’1 to obtain an ack certificate (denoted by ACğ‘’(ğ‘†ğµ)), to
generate a valid block ğ‘†ğµ corresponding to the ğ‘› secrets. In epoch ğ‘’,
the leader proposes block ğµâ„ with ğ‘â„ := (ğ»(ğ‘†ğµ), ACğ‘’(ğ‘†ğµ)) where
ACğ‘’(ğ‘†ğµ) is an ack certificate for commitment ğ‘†ğµ using the SMR
protocol obtained from the block validation protocol. We redefine
valid blocks for the SMR protocol with an additional constraint to
contain an ack certificate created in epoch ğ‘’ âˆ’ 15 and all honest
nodes vote in the SMR protocol as long as the proposed block meets
this additional constraint. As mentioned before, an ack certificate
for a sharing block ğ‘†ğµ implies all honest nodes have secret shares
required to reconstruct the secrets corresponding to commitments
in ğ‘†ğµ. Thus, it is safe for honest nodes to vote in the SMR protocol
although they sent blame during the block validation phase.
Update. At the end of epoch ğ‘’, node ğ‘ğ‘– updates Q(ğ¿ğ‘’âˆ’ğ‘¡) as follows.
If ğ¿ğ‘’âˆ’ğ‘¡ proposed a valid block ğµğ‘™ in epoch ğ‘’ âˆ’ ğ‘¡ and ğµğ‘™ has been
committed by epoch ğ‘’, node ğ‘ğ‘– replaces the contents of Q(ğ¿ğ‘’âˆ’ğ‘¡)
with ğ‘› tuples with each tuple containing secret shares, witnesses
5For the first epoch, an ack certificate can be created during the setup phase.
11
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3512This protocol is executed in parallel with BFT SMR protocol in Figure 1 using the round-robin leader selection. Let ğ¿ğ‘’ be the leader of epoch ğ‘’ and the current
epoch be ğ‘’ âˆ’ 1. Node ğ‘ğ‘– performs following operations while in epoch ğ‘’ âˆ’ 1:
(cid:8)VSS.ğœ‹ğ‘–,1, . . . , VSS.ğœ‹ğ‘–,ğ‘›(cid:9).
:= (cid:8)VSS.sğ‘–,1, . . . , VSS.sğ‘–,ğ‘›(cid:9), and VSS. (cid:174)ğ‘Šğ‘–
1. Distribute. ğ¿ğ‘’ waits for Î” time after entering epoch ğ‘’ âˆ’ 1 and then does the following:
â€¢ Let {ğ‘ 1, . . . , ğ‘ ğ‘›} be ğ‘› random numbers chosen uniformly from the input space of VSS.