# CVE-2019-8635：macOS提权及任意代码执行漏洞分析
##### 译文声明
本文是翻译文章，文章原作者 trendmicro，文章来源：blog.trendmicro.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
我们在macOS中发现了一个双重释放（double
free）漏洞（编码为[CVE-2019-8635](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8635)），该漏洞由AMD组件的内存破坏缺陷所导致。如果成功利用该漏洞，攻击者可以实现权限提升，以`root`权限在系统上执行恶意代码。我们向Apple反馈了漏洞情况，厂商后面也发布了相应[补丁](https://support.apple.com/en-us/HT210119)。
这个CVE编号实际上覆盖了两个缺陷：[discard_StretchTex2Tex](https://www.zerodayinitiative.com/advisories/ZDI-19-539/)方法以及`AMDRadeonX400_AMDSIGLContext`这个AMD
Radeon类中对边带令牌（sindeband
token）的[处理逻辑](https://www.zerodayinitiative.com/advisories/ZDI-19-543/)。`AMDRadeonX400_AMDSIGLContext`派生自`IOAccelGLContext2`类，而后者由`IOAccelContext2`类扩展而来。这些类用来在macOS主机上渲染图像。
漏洞位于`discard_StretchTex2Tex`以及`AMDSIGLContext::process_StretchTex2Tex`函数中，这两个函数是`AMDRadeonX4000_AMDSIGLContext`类的函数，我们可以使用`AMDRadeonX4000_AMDSIGLContext`
userclient以及selector
2对应的函数`IOAccelContext2::submit_data_buffers`来访问这个类，使用connect type
1来打开`AMDRadeonX4000_AMDGraphicsAccelerator`客户端。
## 0x01 AMDRadeonX4000_AMDSIGLContext discard_StretchTex2Tex双重释放权限提升漏洞
攻击者可以利用该漏洞在用户空间上执行代码。为了利用该漏洞，攻击者首先必须具备在目标macOS系统上执行低权限代码的能力。
该缺陷是因为系统没有对用户提供的数据进行适当的验证，导致读取操作超出已分配数据结构的末尾地址。攻击者可以利用这一点，再与其他漏洞结合起来，将权限提升至内核级别。
## 0x02 AMDRadeonX4000_AMDSIGLContext双重释放权限提升漏洞
同一个AMD类对边带令牌的处理过程中也存在一个双重释放漏洞。本地攻击者可以利用该漏洞在受影响的macOS上执行任意命令。与上一个漏洞一样，攻击者首先必须具备在目标系统上执行低权限代码的能力，才能进一步利用该漏洞。
虽然前一个漏洞位于`AMDRadeonX4000_AMDSIGLContext:discard_StretchTex2Tex`函数中，但这个漏洞位于`AMDRadeonX4000_AMDSIGLContext::process_StretchTex2Tex`函数中。漏洞成因在于系统在对目标对象执行操作前，没有去验证该对象是否存在。攻击者可以利用该漏洞将权限提升至内核级别。
从本质上讲，这两个漏洞在可能的利用途径方面比较相似，但在于具体利用的函数方面有所区别。
## 0x03 漏洞分析
图1. `AMDRadeonX4000_AMDSIGLContext:
discard_StretchTex2Tex`函数伪代码片段（上图），`AMDRadeonX4000_AMDSIGLContext::process_StretchTex2Tex`函数伪代码片段（下图）
如图1（上图）所示，如果`(cmdinfo+32)`等于`0x8c00`，那么`IOAccelResource`
`v10`以及`v11`都会从`IOAccelShared2`中取值，对应的索引分别为`*(shareMem_start_address_187_offset16+8)`
以及`*(shareMem_start_address_187_offset16+12)`。该函数随后会使用`IOAccelResource2::clientRelease()`函数来释放两个加速器资源。然而攻击者可以从用户空间中，通过内存映射，使用`IOAccelContext2`
userclient来直接控制这两个索引。如果用户空间为`lookupResource`函数映射相同的索引，那么`clientRelease`就会两次释放相同的资源客户端，此时就会出现双重释放漏洞。
如图1（下）所示，如果`v15`等于`0x8c00`，那么`accelResource_offset8`以及`accelResource_offset12`都会从`IOAccelShared2`中取值，以共享内存偏移24及28的值作为索引。最终，该函数会从`IOAccelShared2
_rst`释放`accelResource_offset12`，如果`accelResource_offset8->member2`不等于`10`，该函数也会从`IOAccelShared2`释放`accelResource_offset8`。然而将共享内存偏移24及28对应的值设成相同值，就会导致系统两次释放同一个`accelResource`。
在`process_StretchTex2Tex()`函数中，完成stretch操作时会使用`IOAccelResource2::clientRelease()`函数来释放两个资源客户端。然而，这两个`accelResource2`源自`AMDRadeonX4000_AMDSIGLContext`类中的`accelShare2`共享内存，使用对应的索引通过`IOAccelShared2::lookupResource`函数来获取。攻击者可以从用户空间中，通过`IOAccelContext2`用户客户端，利用内存映射来控制这些索引值。如果用户空间对`lookupResource`函数映射相同的索引，那么`clientRelease`就会两次释放相同的资源客户端，最终出现双重释放漏洞。
根据这两处代码执行流，共享内存地址指向的都是`commandStreamInfo +
24`。然而，`commandStreamInfo`缓冲区实际上在`IOAccelContext2::processSidebandBuffe`函数中设置，如下图所示。在图2中，`v5`指向的是`shareMem
+ 16`，而`this->member196`指向的是`commandStreamInfo + 24`。
图2. `IOAccelContext2::processSidebandBuffer`伪代码片段
`IOAccelContext2::clientMemoryForType`函数的伪代码片段如图3所示。该函数由已知的`IOConnectMapMemory64`
API来调用，而后者会将一个用户缓冲区映射到内核空间中。在使用`IOConnectMapMemory64`函数时，我们需要设置连接对象、内存类型以及其他一些参数。此处连接对象为`IOAccelContext2`的实例，内存类型为`0`，如图3所示。当我们将内存类型设置为`0`时，`clientMemoryForType`函数会创建一个缓冲区内存描述符，返回用户空间的起始地址。此外，该函数还会将缓冲区内存地址设置为`shareMem_start_vm_address_187`变量（我们设置的变量名，非原始代码使用的变量名），该变量实际上正是在`IOAccelContext2::processSidebandBuffer`函数中使用的值。
根据该代码流程，我们可以控制共享缓冲区，以类似的方式设置这两个资源索引，随后触发双重释放漏洞。
图3. `IOAccelContext2::clientMemoryForType`函数伪代码片段
应用崩溃日志中的回溯信息如下所示，其中如果使用`discard_StretchTex2Tex`函数，那么只有`AMDRadeonX4000`AMDRadeonX4000_AMDSIGLContext::process_StretchTex2Tex`以及`process_StretchTex2Tex(IOAccelCommandStreamInfo&)
+ 2893`函数偏移有所区别。
    * thread #1, stop reason = signal SIGSTOP
    frame #0: 0xffffff7f8d7adc37 IOAcceleratorFamily2`IOAccelResource2::clientRelease(IOAccelShared2*) + 13
    frame #1: 0xffffff7f8d880dad AMDRadeonX4000`AMDRadeonX4000_AMDSIGLContext::process_StretchTex2Tex(IOAccelCommandStreamInfo&) + 2893
    frame #2: 0xffffff7f8d79b5d5 IOAcceleratorFamily2`IOAccelContext2::processSidebandBuffer(IOAccelCommandDescriptor*, bool) + 273
    frame #3: 0xffffff7f8d8885e4 AMDRadeonX4000`AMDRadeonX4000_AMDSIGLContext::processSidebandBuffer(IOAccelCommandDescriptor*, bool) + 182
    frame #4: 0xffffff7f8d79bae7 IOAcceleratorFamily2`IOAccelContext2::processDataBuffers(unsigned int) + 85
    frame #5: 0xffffff7f8d7a2380 IOAcceleratorFamily2`IOAccelGLContext2::processDataBuffers(unsigned int) + 804
    frame #6: 0xffffff7f8d798c30 IOAcceleratorFamily2`IOAccelContext2::submit_data_buffers(IOAccelContextSubmitDataBuffersIn*, IOAccelContextSubmitDataBuffersOut*, unsigned long long, unsigned long long*) + 1208
    frame #7: 0xffffff800b027a3c kernel.development`::shim_io_connect_method_structureI_structureO(method=, object=, input=, inputCount=, output=, outputCount=0xffffff8742023968) at IOUserClient.cpp:0 [opt]
    frame #8: 0xffffff800b025ca0 kernel.development`IOUserClient::externalMethod(this=, selector=, args=0xffffff87420239b8, dispatch=0x0000000000000000, target=0x0000000000000000, reference=) at IOUserClient.cpp:5459 [opt]
    *frame #9: 0xffffff800b02ebff kernel.development`::is_io_connect_method(connection=0xffffff80b094e000, selector=2, scalar_input=, scalar_inputCnt=, inband_input=, inband_inputCnt=136, ool_input=0, ool_input_size=0, inband_output=””, inband_outputCnt=0xffffff80b0d81e0c, scalar_output=0xffffff8742023ce0, scalar_outputCnt=0xffffff8742023cdc, ool_output=0, ool_output_size=0xffffff80ab5c7574) at IOUserClient.cpp:3994 [opt]
    frame #10: 0xffffff7f913044c2
    frame #11: 0xffffff800a9bbd64 kernel.development`_Xio_connect_method(InHeadP=, OutHeadP=0xffffff8742023ce0) at device_server.c:8379 [opt]