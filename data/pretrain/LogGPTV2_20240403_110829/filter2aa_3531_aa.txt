Stitching numbers 
Alex Moneger 
Security Engineer 
10th of August 2014 
Generating ROP payloads from in memory numbers 
Cisco Con!dential 
2 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Work for Cisco Systems 
!  Now a developer in the Cloud Web Security Business Unit (big cloud 
based security proxy) 
!  Used to be a networking security architect 
!  Helped design the next generation datacenters for CWS 
!  Interested mostly in bits and bytes 
!  CCIE #36086 
Who am I? 
Cisco Con!dential 
3 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
1.  Brief ROP overview 
2.  Automating ROP payload generation 
3.  Number Stitching 
1. 
Goal 
2. 
Finding gadgets 
3. 
Coin change problem 
4.  Pros, Cons, Tooling 
5.  Future Work 
Agenda 
Cisco Con!dential 
4 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
Introduction 
Cisco Con!dential 
5 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Generate payloads using numbers found in memory 
!  Solve the coin change problem to automatically generate ROP 
payloads 
!  If possible, use no gadgets from the target binary, only gadgets 
generated by libc stubs 
!  Automate the process 
TL;DR 
Cisco Con!dential 
6 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
ROP overview 
Cisco Con!dential 
7 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Re-use instructions from the vulnerable binary 
!  Control #ow using the stack pointer 
!  Multi-staged: 
1.  Build the payload in memory using gadgets 
2.  Transfer execution to generated payload 
!  Only way around today’s OS protections 
Principle 
Cisco Con!dential 
8 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Useful instructions => gadgets 
!  Disassemble backwards from “ret” instruction 
!  Good tools available 
!  Number of gadgets to use is dependent upon target binary 
Finding instructions 
Cisco Con!dential 
9 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Once payload is built in memory 
!  Transfer control by “pivoting” the stack 
!  Allows to redirect execution to a stack crafted by the attacker 
!  Useful gadgets: 
!  leave; ret 
!  mv esp, addr; ret 
!  add esp, value; ret 
Transfer control to payload 
Cisco Con!dential 
10 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
Automating payload generation 
Cisco Con!dential 
11 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Find required bytes in memory 
!  Copy them to a controlled stack 
!  Use either: 
!  A mov gadget (1, 2 or 4 bytes) 
!  A  copy function (strcpy, memcpy, …) (variable byte length) 
Classic approach 
Cisco Con!dential 
12 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Availability of a mov gadget 
!  Can require some GOT dereferencing 
!  Availability of some bytes in memory 
!  May require some manual work to get the missing bytes 
Potential problems 
Cisco Con!dential 
13 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Shellcode requires “sh” (\x73\x68) 
!  Got it! What about “h/” (\x68\x2f)? 
Finding bytes 
someone@something:~/somewhere$#sc="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e
\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80”#
someone@something:~/somewhere$#ROPgadget#abinary#Bopcode#"\x73\x68"#
Gadgets#information#
============================================================#
0x08048321:#"\x73\x68”#
someone@something:~/somewhere$#hexdump#BC#abinary.text|#grep#BBcolor#"73#68"#
00000320##75#73168#00#65#78#69#74##00#73#74#72#6e#63#6d#70##|ush.exit.strncmp|#
someone@something:~/somewhere$#hexdump#BC#hbinary5Bmem.txt#|#grep#BBcolor#"68#2f"#
someone@something:~/somewhere$##
Cisco Con!dential 
14 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Very small binaries do not seem to have many mov gadgets 
!  In the case of pop reg1; mov [ reg2 ], reg1: 
!  Limitation on the charset used 
!  Null byte can require manual work 
mov gadget 
Cisco Con!dential 
15 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
Number stitching 
Cisco Con!dential 
16 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Is exploiting a “hello world” type vulnerability possible with: 
!  RELRO 
!  X^W 
!  ASLR 
!  Can the ROP payload be built only from libc introduced stubs? 
!  In other words, is it possible not to use any gadgets from the target 
binary code to build a payload? 
Initial problem 
Cisco Con!dential 
17 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
Program anatomy 
Cisco Con!dential 
18 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  What other code surrounds the “hello world” code? 
!  Does libc add anything at link time? 
Libc static functions 
someone@something:~/somewhere$#pygmentize#abinary.c#
#include##
#
int#main(int#argc,#char#**argv,#char**#envp)#{#
#printf("Hello#world!!\n");#
}#
someone@something:~/somewhere$#objdump#Bd#Bj#.text#BM#intel#abinary|#egrep#':'#
08048510#:#
080489bd#:#
080489f0#:#
08048a00#:#
08048a5a#:#
Cisco Con!dential 
19 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  At link time “libc.so” is used 
!  That’s a script which both dynamically and statically links libc: 
!  Looks libc_nonshared.a statically links some functions: 
Where does this come from? 
someone@something:~/somewhere$#cat#libc.so#
/*#GNU#ld#script#
###Use#the#shared#library,#but#some#functions#are#only#in#
###the#static#library,#so#try#that#secondarily.##*/#
OUTPUT_FORMAT(elf32Bi386)#
GROUP#(#/lib/i386BlinuxBgnu/libc.so.6#/usr/lib/i386BlinuxBgnu/libc_nonshared.a##AS_NEEDED#(#/lib/i386B
linuxBgnu/ldBlinux.so.2#)#)#
Cisco Con!dential 
20 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Quite a few functions are: 
What is statically linked?  
someone@something:~/somewhere$#objdump#Bd#Bj#.text#BM#intel##/usr/lib/i386BlinuxBgnu/libc_nonshared.a#|#egrep#
':'#
00000000#:#
00000010#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
00000000#:#
Cisco Con!dential 
21 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Those functions are not always included 
!  Depend on compile options (-fstack-protector, -pg, …) 
!  I looked for gadgets in them. 
!  Fail… 
Gadgets in static functions 
Cisco Con!dential 
22 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Is there anything else added which is constant: 
!  get_pc_thunk.bx() used for PIE, allows access to GOT 
!  _start() is the “real” entry point of the program 
!  There are also a few “anonymous” functions (no symbols) 
introduced by libc 
!  I didn’t look much further, but I think those functions relate to 
pro!ling 
!  Looking for gadgets in that, yields some results! 
!  Only works for libc 2.11 (and before?) 
Anything else added? 
Cisco Con!dential 
23 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  What I get to work with: 
!  Control of ebx in an “anonymous” function: pop#ebx#;#pop#ebp#;;#
!  Stack pivoting in “anonymous” function: leave#;;  
!  Write to mem in “anonymous” function: add#[ebx+0x5d5b04c4]#eax#;;#
!  Write to mem in “anonymous” function: add#eax#[ebxB0xb8a0008]#;#add#
esp#0x4#;#pop#ebx#;#pop#ebp#;; 
!  In short, attacker controls: 
!  ebx 
!  That’s it… 
!  Can anything be done to control the value in eax? 
Useful gadgets against libc 2.11.3 
Cisco Con!dential 
24 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
Shellcode to numbers 
Cisco Con!dential 
25 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Useful gadget: add#[ebx+0x5d5b04c4]#eax#;;#
!  Ebx is under attacker control 
!  Gadget allows to add a value from a register to memory 
!  If attacker controls eax in someway, this is a write-anywhere 
Accumulating 
Cisco Con!dential 
26 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Choose a spot in memory to build a stack: 
!  .data section is nice 
!  Choose a shellcode to write to the stack: 
!  As an example, use a setreuid shellcode 
!  Nothing unusual in all this 
Approach 
Cisco Con!dential 
27 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
1.  Next, cut the shellcode into 4 byte chunks 
2.  Interpret each chunk as an integer 
3.  Keep track of the index of each chunk position 
4.  Order them from smallest to biggest 
5.  Compute the di$erence between chunks 
6.  There is now a set of monotonically increasing values representing 
the shellcode 
Chopping shellcode 
Cisco Con!dential 
28 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
Visual chopping 
\x04\x03\x02\x01 
\x08\x07\x06\x05 
\x0d\x0c\x0b\x0a 
0x01020304 
0x05060708 
0x0a0b0c0d 
1
3
2
1
2
3
0x01020304 
0x04040404 
0x05050505 
3
2
1
0x05060708 – 
0x01020304 
2
0x0a0b0c0d – 
0x05060708 
1
Shellcode 
Chunks 
Deltas 
Monotonically 
increasing 
Cisco Con!dential 
29 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  Shellcode is represented as increasing deltas 
!  Add delta n with n+1 
!  Dump that delta at stack index 
!  Repeat 
!  We’ve copied our shellcode to our stack 
Reverse process 
Cisco Con!dential 
30 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
1. 
Find address of number 0x01020304 in memory 
2. 
Load that address into ebx 
3. 
Add mem to reg. Eax contains 0x01020304 
4. 
Add reg to mem. Fake stack contains “\x04\x03\x02\x01” 
5. 
Find address of number 0x04040404 in memory and load into ebx 
6. 
Add mem to reg. Eax contains 0x01020304 + 0x04040404 = 0x05060708 
7. 
Add reg to mem. Fake stack contains “\x08\x07\x06\x05\x04\x03\x02\x01” 
8. 
Repeat 
Example 
Cisco Con!dential 
31 
© 2013-2014  Cisco and/or its a"liates. All rights reserved. 
!  How easy is it to !nd the shellcode “numbers” in memory? 
!  Does memory contain numbers such as: 
!  0x01020304 
!  "\x6a\x31\x58\x99” => 0x66a7ce96 (string to 2’s complement integer) 
!  If not, how can we build those numbers to get our shellcode? 
Problem 
Cisco Con!dential 
32 