# Stitching Numbers: Generating ROP Payloads from In-Memory Numbers

**Author:** Alex Moneger  
**Role:** Security Engineer  
**Date:** August 10, 2014  
**Confidentiality:** Cisco Confidential

---

## Abstract
This document discusses the process of generating Return-Oriented Programming (ROP) payloads using numbers found in memory. The goal is to solve the "coin change problem" to automatically generate ROP payloads, ideally without using gadgets from the target binary, but instead using gadgets generated by libc stubs. This process is automated to streamline the generation of these payloads.

---

## About the Author
- **Current Role:** Developer in the Cloud Web Security Business Unit (CWS), a large cloud-based security proxy.
- **Previous Role:** Networking Security Architect.
- **Contributions:** Helped design next-generation data centers for CWS.
- **Interests:** Bits and bytes, security, and networking.
- **Certification:** CCIE #36086.

---

## Agenda
1. Brief ROP Overview
2. Automating ROP Payload Generation
   - Goal
   - Finding Gadgets
   - Coin Change Problem
   - Pros, Cons, and Tooling
   - Future Work
3. Introduction
4. TL;DR
5. ROP Overview
6. Finding Instructions
7. Transferring Control to Payload
8. Automating Payload Generation
9. Potential Problems
10. Finding Bytes
11. MOV Gadget
12. Number Stitching
13. Initial Problem
14. Program Anatomy
15. Libc Static Functions
16. Gadgets in Static Functions
17. Anything Else Added?
18. Useful Gadgets Against libc 2.11.3
19. Shellcode to Numbers
20. Accumulating
21. Approach
22. Chopping Shellcode
23. Visual Chopping
24. Reverse Process
25. Example
26. Problem

---

## 1. Brief ROP Overview
- **Principle:** Reuse instructions from the vulnerable binary and control flow using the stack pointer.
- **Stages:**
  1. Build the payload in memory using gadgets.
  2. Transfer execution to the generated payload.
- **Protection Bypass:** ROP is a common method to bypass modern OS protections.

---

## 2. Automating ROP Payload Generation
### 2.1 Goal
- Generate payloads using numbers found in memory.
- Solve the coin change problem to automatically generate ROP payloads.
- Use only gadgets generated by libc stubs, if possible.
- Automate the entire process.

### 2.2 Finding Gadgets
- **Useful Instructions:** Identify useful instructions (gadgets) by disassembling backwards from the "ret" instruction.
- **Tools:** Utilize available tools to find and use these gadgets.
- **Dependency:** The number of gadgets used depends on the target binary.

### 2.3 Coin Change Problem
- **Objective:** Find the smallest set of numbers that can be combined to form the required shellcode.
- **Process:** Convert shellcode into a series of increasing values and use them to build the payload.

### 2.4 Pros, Cons, and Tooling
- **Pros:**
  - Automated process.
  - Uses in-memory numbers, reducing the need for external gadgets.
- **Cons:**
  - Limited availability of mov gadgets.
  - May require manual work to handle null bytes and other constraints.
- **Tooling:** Tools like `ROPgadget` and `objdump` are essential for finding and using gadgets.

### 2.5 Future Work
- Explore more advanced techniques for gadget discovery and payload generation.
- Investigate methods to further automate the process and reduce manual intervention.

---

## 3. Introduction
- **Context:** This document aims to provide a detailed guide on how to generate ROP payloads using in-memory numbers.
- **Objective:** Enable security researchers and developers to understand and implement this technique effectively.

---

## 4. TL;DR
- **Summary:** The goal is to generate ROP payloads using numbers found in memory, solving the coin change problem, and automating the process. The approach avoids using gadgets from the target binary and instead uses libc stubs.

---

## 5. ROP Overview
- **Reuse Instructions:** Reuse instructions from the vulnerable binary.
- **Control Flow:** Control the flow using the stack pointer.
- **Multi-Stage Process:**
  1. Build the payload in memory.
  2. Transfer execution to the generated payload.
- **Bypass Protections:** ROP is a common method to bypass modern OS protections.

---

## 6. Finding Instructions
- **Gadgets:** Useful instructions are identified as gadgets.
- **Disassembly:** Disassemble backwards from the "ret" instruction to find gadgets.
- **Tools:** Good tools are available for finding and using gadgets.
- **Dependency:** The number of gadgets used depends on the target binary.

---

## 7. Transferring Control to Payload
- **Payload Construction:** Once the payload is built in memory.
- **Stack Pivoting:** Transfer control by pivoting the stack to redirect execution to a stack crafted by the attacker.
- **Useful Gadgets:**
  - `leave; ret`
  - `mov esp, addr; ret`
  - `add esp, value; ret`

---

## 8. Automating Payload Generation
- **Classic Approach:**
  - Find required bytes in memory.
  - Copy them to a controlled stack.
  - Use either:
    - A `mov` gadget (1, 2, or 4 bytes).
    - A copy function (e.g., `strcpy`, `memcpy`) for variable byte lengths.

### 8.1 Potential Problems
- **Availability of `mov` Gadget:**
  - May require GOT dereferencing.
- **Byte Availability:**
  - May require manual work to get missing bytes.

---

## 9. Finding Bytes
- **Example:**
  - Shellcode requires specific bytes (e.g., `\x73\x68` for "sh").
  - Use tools like `ROPgadget` and `hexdump` to find these bytes in memory.

---

## 10. MOV Gadget
- **Small Binaries:**
  - Small binaries may not have many `mov` gadgets.
- **Constraints:**
  - Limitation on the character set used.
  - Null bytes may require manual handling.

---

## 11. Number Stitching
- **Initial Problem:**
  - Is it possible to exploit a "hello world" type vulnerability with RELRO, X^W, and ASLR?
  - Can the ROP payload be built only from libc introduced stubs?

### 11.1 Program Anatomy
- **Libc Static Functions:**
  - Analyze the code surrounding the "hello world" code.
  - Determine what functions are added by libc at link time.

### 11.2 Gadgets in Static Functions
- **Static Linking:**
  - Some functions are statically linked, depending on compile options.
  - Search for gadgets in these static functions.

### 11.3 Additional Functions
- **Constant Additions:**
  - `get_pc_thunk.bx()` for PIE, allowing access to GOT.
  - `_start()` as the real entry point of the program.
  - Anonymous functions introduced by libc.
- **Gadget Discovery:**
  - Look for gadgets in these additional functions, which yield some results.

### 11.4 Useful Gadgets Against libc 2.11.3
- **Controlled Registers:**
  - `ebx` is under attacker control.
  - Stack pivoting and write-to-memory operations are possible.
- **Limitations:**
  - Need to control the value in `eax` to perform writes.

---

## 12. Shellcode to Numbers
- **Accumulation:**
  - Use the `add [ebx+0x5d5b04c4] eax;;` gadget to add a value from a register to memory.
  - If `eax` is controlled, this allows writing anywhere in memory.

### 12.1 Approach
- **Memory Section:**
  - Choose a spot in memory (e.g., `.data` section) to build the stack.
- **Shellcode:**
  - Use a setreuid shellcode as an example.
  - Cut the shellcode into 4-byte chunks and interpret each chunk as an integer.
  - Order the chunks and compute the differences to create a set of monotonically increasing values.

### 12.2 Chopping Shellcode
- **Visual Representation:**
  - Convert shellcode into chunks and compute the differences.
  - Represent the shellcode as a series of increasing deltas.

### 12.3 Reverse Process
- **Copy Shellcode:**
  - Add each delta to the previous one and dump it at the stack index.
  - Repeat until the shellcode is copied to the stack.

### 12.4 Example
- **Step-by-Step:**
  - Find the address of the first number in memory and load it into `ebx`.
  - Add the memory value to `eax` and then add `eax` to the memory location.
  - Repeat for each number in the shellcode.

### 12.5 Problem
- **Finding Numbers:**
  - Determine if the required numbers (e.g., `0x01020304`) are present in memory.
  - If not, explore methods to build these numbers to generate the shellcode.

---

## Conclusion
This document provides a comprehensive guide on generating ROP payloads using in-memory numbers. By solving the coin change problem and automating the process, it offers a robust method to bypass modern OS protections and execute arbitrary code. Future work will focus on further automation and advanced techniques for gadget discovery and payload generation.

---

**Confidentiality Notice:** Â© 2013-2014 Cisco and/or its affiliates. All rights reserved.