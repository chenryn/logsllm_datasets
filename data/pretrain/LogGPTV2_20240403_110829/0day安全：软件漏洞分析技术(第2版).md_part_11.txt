79
40
00
8BCB：
0.3见胶.xy0.
00001110h:
81
E1
FF
DO
B9
OD
54
79
40
00
C1E10803：金
...?Tye.龄..
00001120h:
CA
58
OS
79
40
QO
C1
EB
10
A3
4C
64
40006A：簧.Py8.凌.
9A00;.轴...YOPu..铠
00001130h:
OQ
EB
71
1.D
Q0
59
S0
CO
75
OB
6A
1C
EO
00001140b:
00
00
55
FC
00
BO
00
Q0
15 00
60；.....
40
1A
00
00
A3
28
79
40;8.
牌.期...7ye
00001160b:
D0001150h:
00 EB
00
40
0O
00
00
6S
00
00E8CE140000;.?......栉..
00001170b:
A1
68
6L
400013
y9.y9.P
5'y9
1
DOS
Mod:9/13/20079:33:01PM
图1.4.12修改PE文件
将这一个字节的74（JE）修改成75（JNE），保存后重新运行可执行文件，如图1.4.13
所示。原本正确的密码“1234567”现在反而提示错误了。
"7433
图1.4.13成功破解密码验证
37
---
## Page 63
第2章栈溢出原理与实践
-Failwest
2.1系统栈的工作原理
2.1.1内存的不同用途
如果您关注网络安全问题，那么一定听过缓冲区溢出这个术语。简单说来，缓冲区溢出就
是在大缓冲区中的数据向小缓冲区复制的过程中，由于没有注意小缓冲区的边界，“撑爆”了
较小的缓冲区，从而冲掉了和小缓冲区相邻内存区域的其他数据而引起的内存问题。缓冲溢
出是最常见的内存错误之一，也是攻击者入侵系统时所用到的最强大、最经典的一类漏洞利
用方式。
成功地利用缓冲区溢出漏洞可以修改内存中变量的值，甚至可以劫持进程，执行恶意代码，
最终获得主机的控制权。要透彻地理解这种攻击方式，我们需要回顾一些计算机体系架构方面
的基础知识，搞清楚CPU、寄存器、内存是怎样协同工作而让程序流畅执行的。
根据不同的操作系统，一个进程可能被分配到不同的内存区域去执行。但是不管什么样的
操作系统、什么样的计算机架构，进程使用的内存都可以按照功能大致分成以下4个部分。
（1）代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并
执行。
（2）数据区：用于存储全局变量等。
（3）堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态
分配和回收是堆区的特点。
（4）栈区：用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到母函
数中继续执行。
题外话：这种简单的内存划分方式是为了让您能够更容易地理解程序的运行机制。《深
入理解计算机系统）一书中有更详细的关于内存使用的论述，如有兴趣可参考之。
在Windows平台下，高级语言写出的程序经过编译链接，最终会变成第1章介绍过的PE
文件。当PE文件被装载运行后，就成了所谓的进程。
---
## Page 64
第
PE文件代码段中包含的二进制级别的机器代码会被装入内存的代码区（.text），处理器将
2
到内存的这个区域一条一条地取出指令和操作数，并送入算术逻辑单元进行运算：如果代码中
章
请求开辟动态内存，则会在内存的堆区分配一块大小合适的区域返回给代码区的代码使用：当
栈
函数调用发生时，函数的调用关系等信息会动态地保存在内存的栈区，以供处理器在执行完被
溢
调用函数的代码时，返回母函数。这个协作过程如图2.1.1所示。
原
ESP
理与实
进程的虚拟内
当前函数的
存空间
EBP
函数找顿
函数找帧
践
函数栈情
函数栈帧
XOREBX,EBX
MOV BH,4
PE文件
SUBESP,EBX
MOVBX.3233
EIP
PUSHEBX
PUSH
数据区
72657375
（全局变量）
PUSH ESP
XOREDX,EDX
图2.1.1进程的内存使用示意图
如果把计算机看成一个有条不素的工厂，我们可以得到如下类比。
●CPU是完成工作的工人。
●数据区、堆区、栈区等则是用来存放原料、半成品、成品等各种东西的场所。
·存在代码区的指令则告诉CPU要做什么，怎么做，到哪里去领原材料，用什么工具来
做，做完以后把成品放到哪个货舱去。
●值得一提的是，栈除了扮演存放原料、半成品的仓库之外，它还是车间调度主任的办
公室。
程序中所使用的缓冲区可以是堆区、栈区和存放静态变量的数据区。缓冲区溢出的利用方
法和缓冲区到底属于上面哪个内存区域密不可分，本章主要介绍在系统栈中发生溢出的情形。
2.1.2栈与系统栈
从计算机科学的角度来看，栈指的是一种数据结构，是一种先进后出的数据表。栈的最常
见操作有两种：压栈（PUSH）、弹栈（POP）：用于标识栈的属性也有两个：栈顶（TOP）、栈
39
---
## Page 65
day
0
底（BASE）。
安
可以把栈想象成一擦扑克牌。
全
·PUSH：为栈增加一个元素的操作叫做PUSH，相当于在这擦扑克牌的最上面再放上
：
一张。
软
件
·POP：从栈中取出一个元素的操作叫做POP，相当于从这擦扑克牌取出最上面的一张。
漏
·TOP：标识栈顶位置，并且是动态变化的。每做一次PUSH操作，它都会自增1：相
洞
反，每做一次POP操作，它会自减1。栈顶元素相当于扑克牌最上面一张，只有这张
分
牌的花色是当前可以看到的。
析
技
·BASE：标识栈底位置，它记录着扑克牌最下面一张的位置。BASE用于防止栈空后继
术
续弹栈（牌发完时就不能再去揭牌了）。很明显，一般情况下，BASE是不会变动的。
（第
内存的栈区实际上指的就是系统栈。系统栈由系统自动维护，它用于实现高级语言中函数
的调用。对于类似C语言这样的高级语言，系统栈的PUSH、POP等堆栈平衡细节是透明的。
2
一般说来，只有在使用汇编语言开发程序的时候，才需要和它直接打交道。
版
注意：系统栈在其他文献中可能曾被叫做运行栈、调用栈等。如果不加特别说明，本
书中所涉及的栈都是指系统栈这个概念。请您注意将其与编写非递归函数求解“八皇
后”问题时，在自己程序中所实现的数据结构区分开来。
2.1.3函数调用时发生了什么
我们下面就来探究一下高级语言中函数的调用和递归等性质是怎样通过系统栈巧妙实现
的。请看如下代码：
intfunc_B(int arg_B1,int arg_B2)
int.var_B1,var_B2;
var_Bl=arg_B1+arg_B2;
var_B2=arg_B1-arg_B2;
return var_B1*var_B2;
intfunc_A（int arg_Al,int arg_A2)
int var_A;
return var_A;
int main（int argc,char **argv,char **envp)
int var_main;
var_main=func_A(4,3);
40
---
## Page 66
第
returnvar_main;
2
章
这段代码经过编译器编译后，各个函数对应的机器指令在代码区中可能是这样分布的，如
栈
图2.1.2所示。
溢
根据操作系统的不同、编译器和编译选项的不同，同一文件不同函数的代码在内存代码区
出
中的分布可能相邻，也可能相离甚远，可能先后有序，也可能无序，：但它们都在同一一个PE文
原
件的代码所映射的一个“节”里。我们可以简单地把它们在内存代码区中的分布位置理解成是
理与实践
散乱无关的。
当CPU在执行调用func_A函数的时候，会从代码区中main函数对应的机器指令的区域
跳转到func_A函数对应的机器指令区域，在那里取指并执行：当func_A函数执行完闭，需要
返回的时候，又会跳回到main函数对应的指令区域，紧接着调用func_A后面的指令继续执行
main函数的代码。在这个过程中，CPU的取指轨迹如图2.1.3所示。
处理器跳转去unc_A的代码空间去继续执行
func_A
（其他指令）
(func_B的指令)
跳转去func_B的代码空间
取指执行
Callfunc_B
(msini函数指令）
func_B
后续的指令
Main
两数入门
两数入口
返国指令
返国指令
（其他指令）
Callfunc_A
后续的指令
返回到上层函数的代码空间，
（func_A的指令）
紧接着执行函数调用的后续指令
返国指令
图2.1.2函数代码在代码区
图2.1.3CPU在代码区中的取指轨迹示意图
中的分布示意图
那么CPU是怎么知道要去func_A的代码区取指，在执行完func_A后又是怎么知道跳回
到main函数（而不是func_B的代码区）的呢？这些跳转地址我们在C语言中并没有直接说明，
CPU是从哪里获得这些函数的调用及返回的信息的呢？
原来，这些代码区中精确的跳转都是在与系统栈巧妙地配合过程中完成的。当函数被调用
时，系统栈会为这个函数开辟一个新的栈顿，并把它压入栈中。这个栈顿中的内存空间被它所
属的函数独占，正常情况下是不会和别的函数共享的。当函数返回时，系统栈会弹出该函数所
对应的栈帧。
如图2.1.4所示，在函数调用的过程中，伴随的系统栈中的操作如下。
---
## Page 67
0
day
在main函数调用func_A的时候，首先在自已的栈帧中压入函数返回地址，然后为
安全：
func_A创建新栈帧并压入系统栈。
func_B
用弹出的返
软件漏洞分析技术
栈帧
回地址回溯
出上一个函
数的代码空
局部变量
国
返回地址
func_A
func_A
用弹出的返
栈帧
栈帧
回地址回测
出上一个函
局部变量
局部变量
数的代码空
间
2
返回地址
栈顶方向
返回地址
版
(TOP)
aln函数
wein质效
aln函数
栈帧
找献
找械
找献
栈帧
其他函数
其他函数
其他码敏
其他函数
其他面数
找帧
战快
找赖
找横
栈底方向
(BASE)
代码空间：程
代码空间：执行
代码空间：执
代码空同：fumc_B
代码空间：
序被装入，由
ain代码区的
行到fumc_A代
代码执行完毕，弹
func_A代码执行
ain函数代码
call指令时，院
码区的ca11指
出自己的栈帧并从