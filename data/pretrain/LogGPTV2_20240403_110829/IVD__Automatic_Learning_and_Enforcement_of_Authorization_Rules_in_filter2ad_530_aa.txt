title:IVD: Automatic Learning and Enforcement of Authorization Rules in
Online Social Networks
author:Paul Marinescu and
Chad Parry and
Marjori Pomarole and
Yuan Tian and
Patrick Tague and
Ioannis Papagiannis
2017 IEEE Symposium on Security and Privacy
IVD: Automatic Learning and Enforcement of
Authorization Rules in Online Social Networks
Paul Marinescu†, Chad Parry†, Marjori Pomarole†, Yuan Tian‡, Patrick Tague‡, Ioannis Papagiannis†
†Facebook. {pau, cparry, mpomarole, yiannis}@fb.com
‡Carnegie Mellon University. {yuan.tian, patrick.tague}@sv.cmu.edu
moderator, depending on policy, should be allowed to add
people to the conversation. Furthermore, messages may be
edited in a short time interval after they were sent, but only by
the same person who sent them. Users may also interact by
posting content to their personal page, usually unrestricted, or
to a group, usually only after being explicitly accepted in the
group. They may also create connections (e.g. befriend, follow,
connect, become a fan, add to circles) with other users, which
often gives them additional ways to interact.
Abstract—Authorization bugs, when present in online social
networks, are usually caused by missing or incorrect autho-
rization checks and can allow attackers to bypass the online
social network’s protections. Unfortunately, there is no practical
way to fully guarantee that an authorization bug will never
be introduced—even with good engineering practices—as a web
application and its data model become more complex. Unlike
other web application vulnerabilities such as XSS and CSRF,
there is no practical general solution to prevent missing or
incorrect authorization checks.
In this paper we propose INVARIANT DETECTOR (IVD), a
defense-in-depth system that automatically learns authorization
rules from normal data manipulation patterns and distills them
into likely invariants. These invariants, usually learned during
the testing or pre-release stages of new features, are then used to
block any requests that may attempt to exploit bugs in the social
network’s authorization logic. IVD acts as an additional layer of
defense, working behind the scenes, complementary to privacy
frameworks and testing.
We have designed and implemented IVD to handle the unique
challenges posed by modern online social networks.
IVD is
currently running at Facebook, where it infers and evaluates
daily more than 200,000 invariants from a sample of roughly
500 million client requests, and checks the resulting invariants
every second against millions of writes made to a graph database
containing trillions of entities. Thus far IVD has detected several
high impact authorization bugs and has successfully blocked
attempts to exploit them before code ﬁxes were deployed.
I. INTRODUCTION
Modern online social networks
(OSNs) handle large
amounts of user data. These data are often generated by
users, are associated with their accounts and are subject to
access control rules governing who can read, create, modify,
and delete them. Because OSNs enable many types of user
interactions, with different levels of permissions, writing and
enforcing these rules quickly becomes nontrivial. Developers
need to ﬂawlessly consider all possible interactions and cor-
rectly implement the appropriate checks while at the same time
iterate quickly to satisfy business needs.
OSNs are constantly evolving, with new features being
added regularly, often in an arms race to offer their users an
improved experience and more ways to express themselves,
which often concretizes in new types of interactions. For
example, users may use private messaging for a one-to-one
or a group conversation, in which case only the participants
should be allowed to send and receive messages associated
with the conversation and only participants or the conversation
© 2017, Paul Marinescu. Under license to IEEE.
DOI 10.1109/SP.2017.33
1094
Authorization becomes even more difﬁcult when multiple
types of entities and delegation are involved. For example,
an OSN can support personal users, businesses, and a many-
to-many business administrator relation between them. Users
connected by the business administrator relation are authorized
to act on behalf of the business in matters such as changing the
business address or answering customer messages. In addition
to this, a different relation, business owner, allows users to
merge two businesses into a single entity. Proper authorization
for the merge requires checking that the logged-in user is the
owner of both businesses.
Failing to perform correct authorization checks leads to
authorization bugs. Attackers can exploit them to impersonate
other users, perform actions on their behalf and gain access
to data. While all businesses can be negatively affected by
such bugs, OSNs are particularly sensitive: they contain large
amounts of user data, e.g. their pictures, personal interests,
job applications, physical location, and are home to their users’
online personas. In consequence, an OSN’s reputation depends
heavily on user trust.
However, missing or incorrect authorization checks are a
common issue. The Open Web Application Security Project
(OWASP) lists authorization bugs as the cause of two of the
top ten most common and important classes of web application
vulnerabilities [1]. In addition, authorization bugs are easy to
exploit if found. Typically, a malicious actor approaches such
an attack by trial and error: they ﬁrst understand the API of
a web application by inspecting its normal functionality, they
identify the arguments that these APIs receive, and ﬁnally send
requests with systematically modiﬁed arguments and check
whether the application performed any action on the object
identiﬁed by the recently modiﬁed argument. The low success
rate of each attempt is balanced out by the short time needed
to devise the attack, the possibility of automating it, and by
its simplicity and accessibility.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:23:44 UTC from IEEE Xplore.  Restrictions apply. 
r
e
t
s
e
t
/
r
e
s
u
e
t
a
m
i
t
i
g
e
L
r
e
s
u
s
u
o
c
i
i
l
a
M
N
S
O
User
requests
IVD
Unsupervised
learning
Likely invariants
x
Database
writes
DB
Fig. 1: INVARIANT DETECTOR distills normal behavior into
invariants that it then uses to blocks malicious requests.
We believe that writing, maintaining and consistently en-
forcing correct authorization checks in a quickly-evolving,
complex application is difﬁcult, even with privacy frameworks
and engineering best practices. Developers need a holistic
understanding of the application and good programming dis-
cipline to avoid introducing bugs, and new contributors need
to be particularly careful
to fully understand the privacy
implications of their changes.
To mitigate this problem, we propose INVARIANT DE-
TECTOR (IVD), a defense-in-depth system based on dynamic
invariant detection, that provides a safety net against missing
or incorrect authorization checks. As shown in Figure 1, IVD
intercepts requests made by an OSN to its database. It mines
likely invariants from the database writes the application code
performs and blocks database writes which break existing
invariants. IVD has a short learning period, usually covered by
internal testing, dogfooding, or a pre-release period, making
it ready to act by the time a new product feature is made
available to users. As we explain in more detail later (§III),
IVD’s design allows it to adapt automatically to OSN changes
by continuously learning invariants, without requiring manual
intervention or explicit training data sets.
While dynamic invariant detection has been previously
proposed for testing [2], [3], [4] and attack detection [5],
[6], most approaches have targeted the network or application
layer. Our experience shows that inferring invariants at the
database layer may instead offer more advantages by allowing
both expressive invariants and unprecedented scalability.
OSNs pose unique challenges to a dynamic invariant detec-
tion system. Some challenges stem from the sheer scale of an
OSN’s day-to-day operations; many popular OSNs have well
over 100 million active users, going up to 1.8 billion. This
leads to a large number of requests that have to be checked in
real time and a potentially huge invariants learning corpus. The
problem is compounded by the highly interconnected nature
of an OSN’s data, which can result in multiple objects being
involved in the ﬁnal decision of an authorization check, a
characteristic that has to play a role in the invariant design.
The scale also reﬂects in the impact of false positives, causing
even false positive rates as low as 0.000001% to be impractical
due to the number of affected users and false alarms requiring
human attention.
Other challenges have to do with the complexity of an
OSN’s codebase. Any practical invariant-based system work-
ing at this scale must provide, along with its alerts, sufﬁcient
information to allow engineers to quickly understand whether
they are facing a bug or a false positive. In case of a bug, the
information should facilitate debugging, while in the case of a
false positive there must be a straightforward way to blacklist
the spurious invariant. Black-box systems [7] have inherent
difﬁculties to offer this information as they are completely
agnostic to the application logic. IVD, on the other hand, is
positioned between the OSN’s code and its database. It can
both make use of the database schema to get insights into the
data, and access and report the application’s state, e.g. the call
stack at the time of a data access.
This paper presents our experience with running an invariant
detection system at the scale of an OSN and the set of trade-
offs between performance, invariant complexity and mining
technique required to make this possible. To our knowledge,
our system handles orders of magnitude more data than
previous invariant detection systems.
The main contributions of this paper are:
• A scalable distributed dynamic invariant detection system
for highly interconnected data.
• A two-step invariant generation mechanism and a set of
design and implementation choices that allow the system
to scale and to achieve negligible runtime overhead.
• A set of domain-speciﬁc enforcement excuses that tackle
the inherent susceptibility to false positives of invariant
detection systems.
• Results showing that dynamic invariant detection can
effectively identify incorrect authorization checks and
prevent attackers from exploiting them in a real-world
OSN.
This paper is organized as follows: we start with background
information pertaining to the data model that we target and ex-
isting practices and techniques for authorization enforcement
(§II). We then provide a high level description of IVD (§III),
after which we present implementation choices, focusing on
scalability and performance (§IV). We continue by evaluating
IVD’s effectiveness and performance (§V), and ﬁnally, we
present related work (§VI) and conclude (§VIII).
II. BACKGROUND
In this section we discuss the classic approach for avoiding
authorization bugs in web applications and where this fails. We
speciﬁcally look at a graph data model, we then describe how
an attacker can discover and take advantage of authorization
bugs and what IVD does to prevent this.
A. Graph Data Model
A graph data model structures data into interconnected
objects that form a graph. This organization of data is useful
1095
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:23:44 UTC from IEEE Xplore.  Restrictions apply. 
for any application domain that needs to efﬁciently generate
ﬁne-grained customized content from highly interconnected
data, and is particularly popular among OSNs [8], [9], [10].
In this paper we use an attributed graph model [11], which
we brieﬂy describe below for completeness.
The two fundamental entities of a graph data model are
objects and associations, corresponding respectively to the
nodes and edges of the underlying graph. Objects have a
unique identiﬁer (ID) and a type (OTYPE) while associations
are identiﬁed by their source object (ID1), destination object
(ID2), and type (ATYPE). In addition,
in attributed graph
models, both objects and associations may have properties in
the form of KEY (cid:2)→ VALUE pairs. To summarize,
Object: (ID) (cid:2)→ (OTYPE, (KEY (cid:2)→ VALUE)*)
Association: (ID1, ATYPE, ID2) (cid:2)→ (KEY (cid:2)→ VALUE)*
where the Kleene star (*) denotes zero or more. In other words,
the graph data model maps object identiﬁers to their type and
properties, and maps object pairs along with an association
type to the properties of that association. When an object or
association does not exist, the mappings are not deﬁned.
An OSN might use objects to represent users, business
proﬁles, groups, or photos, and associations to represent owner
relationships, friendships, follower-followee relationships, or
like relationships.
The fundamental operations
supported by the graph
database are retrieval, creation, deletion, and mutation of
objects and associations.
While this paper focuses on a graph data model, the ideas
underpinning IVD naturally transfer to other data models which
use similar concepts. For example, a relational database model
replaces objects with records, object ids with primary keys,
object attributes with attributes and relationships with foreign
keys, while an object-oriented databases exposes similar con-
cepts through objects, object ids, attributes and pointers.
B. Reads vs. Writes
To understand IVD’s applicability, it is important to distin-
guish between how authorization checks are performed for
read and write operations. The main insight into their differ-
ence is that authorization checks often rely on information
contained in the graph, and therefore fundamentally need to
happen after reads. In other words legitimate object reads may
happen even if the user triggering them is not authorized to see
the information being read. Writes, on the other hand, should
always be preceded by any needed authorization checks since
writing data to the graph gives it legitimacy. As a result, writes
expose clearer authorization patterns that can be learned by a
system such as IVD.
To better understand this, we consider a simple hypothetical
OSN where people can create friend relationships, post
pictures to their friends’ proﬁles and see all pictures posted to
their friends’ proﬁles. Pictures are graph objects which hold
the identiﬁer of the user on whose proﬁle the picture was
posted and the URL to the content distribution network which
stores the actual image ﬁle. A simpliﬁed implementation of
input : picture object pic
graph.write(pic)
1 u = logged-in user;
2 if graph.associationExists(u, friend, pic.target) then
3
Algorithm 1: A simpliﬁed implementation of the authoriza-
tion checks required for picture posting in an OSN where
users are only allowed to post on their friends’ proﬁles.
input : picture identiﬁer pic id
return pic
1 u = logged-in user;
2 pic = graph.getObject(pic id);
3 if graph.associationExists(u, friend, pic.target) then
4
5 else
6
Algorithm 2: A simpliﬁed implementation of the authoriza-
tion checks required for picture retrieval in an OSN where
users are only allowed to see pictures posted on their friends’