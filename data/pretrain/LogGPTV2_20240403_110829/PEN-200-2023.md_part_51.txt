rule functions, which are used to modify existing passwords contained in a wordlist. An individual
rule consists of one or more rule functions. We will often use multiple rule functions in each rule.
In order to leverage a rule-based attack, we’ll create a rule file containing one or more rules and
use it with a cracking tool.
In a simple example, we could create a rule function that appends fixed characters to all
passwords in a wordlist, or modifies various characters in a password.
Note that rule-based attacks increase the number of attempted passwords tremendously
although we now know that modern hardware can easily handle common passwords with less
than eight characters.
y
For the following example, we’ll assume that we face a password policy that requires an upper
case letter, a special character, and a numerical value. Let’s check the first 10 passwords of
rockyou.txt to determine if they fit this requirement. We’ll usek the head command to display the
first 10 lines of the wordlist.
s
kali@kali:~$ head /usr/share/wordlists/rockyou.txt
123456
12345 o
123456789
password
iloveyou n
princess
1234567
i
rockyou
12345678 z
abc123
Listing 265 - Displaying the first 10 passwords of rockyou.txt
D
The listing shows that none of the first ten passwords of rockyou.txt fulfill the requirements of the
password policy of this example.
We could now use rule functions to mutate the wordlist to fit the password policy. But before we
mutate a complex wordlist like rockyou.txt, let’s first familiarize ourselves with rule functions and
how to use them with a more basic example.
In order to demonstrate rule functions such as capitalization, let’s copy the 10 passwords from
Listing 265 and save them to demo.txt in the newly-created passwordattacks directory. Then,
we’ll remove all number sequences (which don’t fit the password policy) from demo.txt by using
sed with ^1 referring to all lines starting with a “1”, deleting them with d, and doing the editing in
place with -i.
kali@kali:~$ mkdir passwordattacks
kali@kali:~$ cd passwordattacks
kali@kali:~/passwordattacks$ head /usr/share/wordlists/rockyou.txt > demo.txt
628 (Hashcat, 2022), https://hashcat.net/wiki/doku.php?id=rule_based_attack
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 393
Made in Morocco
Penetration Testing with Kali Linux
kali@kali:~/passwordattacks$ sed -i '/^1/d' demo.txt
kali@kali:~/passwordattacks$ cat demo.txt
password
iloveyou
princess
rockyou
abc123
Listing 266 - Contents and location of demo.txt
We now have five passwords in our demo.txt wordlist. Let’s mutate these passwords to fit the
password policy, which must include a numerical value, a special character, and an uppercase
letter.
The Hashcat Wiki629 provides a list of all possible rule functions withy examples. If we want to add
a character, the simplest form is to prepend or append it. We can use the $ function to append a
character or ^ to prepend a character. Both of these functions expect one character after the
k
function selector. For example, if we want to prepend a “3” to every password in a file, the
corresponding rule function would be ^3.
s
When generating a password with a numerical value, many users simply add a “1” at the end of an
existing password. Therefore, let’s create a rule file containing $1 to append a “1” to all passwords
o
in our wordlist. We’ll create a demo.rule with this rule function. We need to escape the special
character “$” to echo it into the file correctly.
n
kali@kali:~/passwordattacks$ echo \$1 > demo.rule
Listing 267 - Rule function to add a “1” to all passwords
i
Now, we can use hashcat with ozur wordlist mutation, providing the rule file with -r, and --stdout,
which starts Hashcat in debugging mode. In this mode, Hashcat will not attempt to crack any
hashes, but merely display the mutated passwords.
D
kali@kali:~/passwordattacks$ hashcat -r demo.rule --stdout demo.txt
password1
iloveyou1
princess1
rockyou1
abc1231
Listing 268 - Using Hashcat in debugging mode to display all mutated passwords
The listing shows that a “1” was appended to each password due to the rule function $1.
If you receive the error “Not enough allocatable device memory for this attack”,
shut down your Kali VM and add more RAM to it. 4GB is enough for the examples
and exercises.
629 (Hashcat, 2022), https://hashcat.net/wiki/doku.php?id=rule_based_attack
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 394
Made in Morocco
Penetration Testing with Kali Linux
Now, let’s address the upper case character of the password policy. When forced to use an upper
case character in a password, many users tend to capitalize the first character. Therefore, we’ll
add the c rule function to our rule file, which capitalizes the first character and converts the rest to
lower case.
Let’s try an example using two rule files: demo1.rule and demo2.rule. We will format these files
differently.
In demo1.rule, the rule functions are on the same line separated by a space. In this case, Hashcat
will use them consecutively on each password of the wordlist. The result is that the first character
of each password is capitalized AND a “1” is appended to each password.
In demo2.rule the rule functions are on separate lines. Hashcat interprets the second rule
function, on the second line, as new rule. In this case, each rule is used separately, resulting in two
mutated passwords for every password from the wordlist.
y
kali@kali:~/passwordattacks$ cat demo1.rule
$1 c k
kali@kali:~/passwordattacks$ hashcat -r demo1.rule --stdout demo.txt
s
Password1
Iloveyou1
Princess1 o
Rockyou1
Abc1231
n
kali@kali:~/passwordattacks$ cat demo2.rule
$1
c i
z
kali@kali:~/passwordattacks$ hashcat -r demo2.rule --stdout demo.txt
password1
D
Password
iloveyou1
Iloveyou
princess1
Princess
...
Listing 269 - Using two rule functions separated by space and line
Good! We have adapted the demo1.rule rule file to two of the three password policies. Let’s work
on the third and add a special character. We’ll start with “!”, which is a very common special
character.
Based on this assumption, we’ll add $! to our rule file. Since we want all rule functions applied to
every password, we need to specify the functions on the same line. Again, we will demonstrate
this with two different rule files to stress the concept of combining rule functions. In the first rule
file we’ll add $! to the end of the first rule. In the second rule file we’ll add it at the beginning of the
rule.
kali@kali:~/passwordattacks$ cat demo1.rule
$1 c $!
kali@kali:~/passwordattacks$ hashcat -r demo1.rule --stdout demo.txt
Password1!
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 395
Made in Morocco
Penetration Testing with Kali Linux
Iloveyou1!
Princess1!
Rockyou1!
Abc1231!
kali@kali:~/passwordattacks$ cat demo2.rule
$! $1 c
kali@kali:~/passwordattacks$ hashcat -r demo2.rule --stdout demo.txt
Password!1
Iloveyou!1
Princess!1
Rockyou!1
Abc123!1
Listing 270 - Adding the rule function to the beginning and end of our current rule
y
The output shows that demo1.rule mutates passwords by appending first the “1” and then “!”. The
other rule file, demo2.rule, appends “!” first and then the “1”. This shows us that the rule functions
are applied from left to right in a rule. k
The rule contained in demo1.rule mutates the passwords of our wordlist to fulfill the
s
requirements of the password policy.
Now that we have a basic understanding of rules oand how to create them, let’s crack a hash with
a rule-based attack. In this demonstration, let’s assume that we retrieved the MD5 hash
“f621b6c9eab51a3e2f4e167fee4c6860” from a target system. We’ll use the rockyou.txt wordlist,
n
and modify it for a password policy requiring an upper case letter, a numerical value, and a special
character.
i
Let’s create a rule file to address this password policy. As before, we’ll use the c rule function for
z
the capitalization of the first letter. Furthermore, we also use “!” again as special character. For the
numerical values we’ll append the (ever-popular) “1”, “2”, and “123” followed by the special
D
character.
kali@kali:~/passwordattacks$ cat crackme.txt
f621b6c9eab51a3e2f4e167fee4c6860
kali@kali:~/passwordattacks$ cat demo3.rule
$1 c $!
$2 c $!
$1 $2 $3 c $!
Listing 271 - MD5 Hash and rule file
Next, we can run Hashcat. We will disable debugging by removing the --stdout argument. Instead,
we’ll specify -m, which sets the hash type. In this demonstration, we want to crack MD5, which is
hash type 0, which we retrieved from the Hashcat hash example page. After the hash type, we’ll
provide the target MD5 hash file (crackme.txt) and the rockyou.txt wordlist. Then, we’ll specify -r
to provide our demo3.rule. As our Kali VM doesn’t have access to a GPU, we’ll also enter --force to
ignore related warnings from Hashcat.
kali@kali:~/passwordattacks$ hashcat -m 0 crackme.txt /usr/share/wordlists/rockyou.txt
-r demo3.rule --force
hashcat (v6.2.5) starting
...
Dictionary cache hit:
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 396
Made in Morocco
Penetration Testing with Kali Linux
* Filename..: /usr/share/wordlists/rockyou.txt
* Passwords.: 14344385
* Bytes.....: 139921507
* Keyspace..: 43033155
f621b6c9eab51a3e2f4e167fee4c6860:Computer123!
Session..........: hashcat
Status...........: Cracked
Hash.Mode........: 0 (MD5)
Hash.Target......: f621b6c9eab51a3e2f4e167fee4c6860
Time.Started.....: Tue May 24 14:34:54 2022, (0 secs)
Time.Estimated...: Tue May 24 14:34:54 2022, (0 secs)
Kernel.Feature...: Pure Kernel
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Mod........: Rules (demo3.rule) y
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........: 3144.1 kH/s (0.28ms) @ Accel:256 Loops:3 Thr:1 Vec:8
Recovered........: 1/1 (100.00%) Digests k
...
Listing 272 - Cracking a MD5 Hash with Hashcat and a mutated rockyou.txt wordlist
s
In this case, we cracked the “Computer123!” password, which was not included in the default
rockyou.txt file. This only took Hashcat a few secoonds despite running on the CPU.
When attempting to create rules to mutate an existing wordlist, we should always consider
human behavior and convenience with regnard to passwords. Most users use a main word and
modify it to fit a password policy, perhaps appending numbers and special characters. When an
upper case letter is required, most users capitalize the first letter. When special characters are
i
required, most users add the special character at the end of the password and rely on characters
z
on the left side of the keyboard since these digits are easy to reach and type.630
Instead of creating rules ouDrselves, we can also use rules provided by Hashcat or other sources.
Hashcat includes a variety of effective rules in /usr/share/hashcat/rules:
kali@kali:~/passwordattacks$ ls -la /usr/share/hashcat/rules/
total 2588
-rw-r--r-- 1 root root 933 Dec 23 08:53 best64.rule
-rw-r--r-- 1 root root 666 Dec 23 08:53 combinator.rule
-rw-r--r-- 1 root root 200188 Dec 23 08:53 d3ad0ne.rule
-rw-r--r-- 1 root root 788063 Dec 23 08:53 dive.rule
-rw-r--r-- 1 root root 483425 Dec 23 08:53 generated2.rule
-rw-r--r-- 1 root root 78068 Dec 23 08:53 generated.rule
drwxr-xr-x 2 root root 4096 Feb 11 01:58 hybrid
-rw-r--r-- 1 root root 309439 Dec 23 08:53 Incisive-leetspeak.rule
-rw-r--r-- 1 root root 35280 Dec 23 08:53 InsidePro-HashManager.rule
-rw-r--r-- 1 root root 19478 Dec 23 08:53 InsidePro-PasswordsPro.rule
-rw-r--r-- 1 root root 298 Dec 23 08:53 leetspeak.rule
-rw-r--r-- 1 root root 1280 Dec 23 08:53 oscommerce.rule
-rw-r--r-- 1 root root 301161 Dec 23 08:53 rockyou-30000.rule
-rw-r--r-- 1 root root 1563 Dec 23 08:53 specific.rule
-rw-r--r-- 1 root root 64068 Dec 23 08:53 T0XlC-insert_00-99_1950-
630 (Washington Post, 2017), https://www.washingtonpost.com/national/health-science/you-added--or-1-to-your-password-thinking-
this-made-it-strong-science-says-no/2017/09/08/0f244e2a-9260-11e7-89fa-bb822a46da5b_story.html
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 397
Made in Morocco
Penetration Testing with Kali Linux
2050_toprules_0_F.rule
...
Listing 273 - Listing of Hashcat’s rule files
These predefined rules cover a broad variety of mutations and are most useful when we don’t
have any information about the target’s password policy. We’ll use the predefined rules in the
upcoming demonstrations and examples. However, it’s always most efficient to discover
information about existing password policies, or to look up typically-used default policies for the
target software environment.
Let’s briefly summarize what we did in this section. We began by discussing rule-based attacks
and why they are preferred over dictionary attacks. Then, we discussed rules and used them to
mutate wordlists to crack an MD5 hash. At the end of this section we briefly introduced the
predefined rule files provided by Hashcat.
y
In the next section we’ll discuss a basic methodology for cracking, which we can use as an outline
for demonstrations and exercises.
k
13.2.3 Cracking Methodology
s
In the next sections, we’ll walk through the various phases of a real-world password-cracking
session, beginning with an overview of a solid methodology.
o
We can describe the process of cracking a hash with the following steps:
1. Extract hashes n
2. Format hashes
i
3. Calculate the cracking time
z
4. Prepare wordlist
5. Attack the hash D
The first step is to extract the hashes. In a penetration test we’ll find hashes in various locations.
For example, if we get access to a database system, we can dump the database table containing
the hashed user passwords.
The next step is to format the hashes into our tool’s expected cracking format. To do this we’ll
need to know the hashing algorithm used to create the hash. We can identify the hash type with
hash-identifier631 or hashid,632 which are installed on Kali. Depending on the hashing algorithm and
the source of the hash, we may need to check if it is already in the correct format for our cracking
tool. If not, then we need to use helper tools to change the representation of the hash into the
expected format of our cracking tool.
In the third step, we will determine the feasibility of our cracking attempt. As we discussed before,
the cracking time consists of the keyspace divided by the hash rate. If the calculated cracking
time exceeds our expected lifetime, we might reconsider this approach!
631 (Kali Tools, 2022), https://www.kali.org/tools/hash-identifier/
632 (Kali Tools, 2022), https://www.kali.org/tools/hashid/
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 398
Made in Morocco
Penetration Testing with Kali Linux
More realistically, we should consider the duration of the current penetration test considering that
we are likely obliged to stop the session (along with other clean-up activity) when the test is