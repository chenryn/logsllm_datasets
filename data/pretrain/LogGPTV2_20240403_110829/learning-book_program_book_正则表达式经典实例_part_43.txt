月在日前面：
DateTime foundDate;
Match matchResult = Regex.Match(SubjectString,
"(?[0-3]？[0-9])/(?[0-3]?[0-9])/"
（（{[6-0]（{}[6-0]:））
if (matchResult.Success) {
int year = int.Parse(matchResult.Groups ["year"].Value);
if (year [0-3]？[0-9]）/(?[0-3]？[0-9])/"
（$（{[6-0{{}[6-0]:)）
if (matchResult.Success) {
int year = int.Parse(matchResult.Groups["year"].Value)
if (year =1 && $day =1&& $month=1 && $day= 1 66 $day =1&& $month = 1 &6 Sday0?2)/(?[12][0-9]10?[1-9])
30-day months
(?0?[469]111)/(?301[12][0-9]10?[1-9])
31-day months
220
辜L
www.TopSage.com
---
## Page 237
6-]0160]]10]>)/(0]1]0>)
）
Year
/ (?(?:[0-9]{2})?[0-9]{2})$
正则选项：宽松排列
正则流派：.NET
^(?：
#February (29 days every year)
(0?2)/([12][0-9]10?[1-9])
#30-day months
([61]01[60][]10)/(1[69]0)
#31-day months
Year
/((?:[0-9]{2))?[0-9]{2})$
正则选项：宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
(?: (0?2) /([12] [0-9]10?[1-9])1(0?[469]111) /(301[12][0-9]10?[1-9]) 1
(0?[13578]11[02])/(3[01]1[12][0-9]10?[1-9])) /((?: [0-9]{2})?[0-9]{2})$
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
日在月前面：
~ (? :
February (29 days every year)
(?[12][0-9]10?[1-9])/(?0?2)
#30-day months
(?301[12][0-9]10?[1-9])/(?0?[469]111)
31-day months
(?3[01]1[12][0-9]10?[1-9])/(?0?[13578]11[02])
Year
/(?(?:[0-9]{2})?[0-9]{2})$
正则选项：
宽松排列
正则流派：.NET
^(? :
#February (29 days every year)
([12][0-9]10?[1-9])/(0?2)
30-day months
([69])/([6-]01[60][]10)
# 31-day months
合法性验证和格式化
221
www.TopSage.com
---
## Page 238
）
#Year
/((?:[0-9]{2})?[09]{2}) $
正则选项：宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
(?:([12][0-9]10?[1-9]) /(0?2)1(301[12][0-9]10?[1-9])/([469]111)1
(3[01]1[12][0-9]10?[1-9]) /(0?[13578]11[02])) /((?: [0-9]{2})?[0-9]{2}) $
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
本质上来说，使用正则表达式来精确验证日期可以有两种方式。一种是使用一个简单
的的正则式，只是捕获看起来像是一个“年/月/日”组合的一组数字，然后使用过程代
码来检查该日期是否正确。我们使用了前一个实例中的第一个正则式，充许在月和日
中出现0～39的任意数字。这样就会很容易把日期格式从mm/dd/yy转换为dd/mm/yy，
因为我们只需要改变一下哪个捕获分组被当作是月就可以了。
这种方法的主要好处是可以很容易添加额外的限制，例如把日期限制为某个特定时期。
许多编程语言都提供了处理日期的特定支持。C#解决方案中使用了.NET中的
DateTime结构来检查日期是否合法，并且把日期以一种有用的格式返回，这些都可以
在一步之内完成。
另外一种方法是使用正则表达式来完成所有任务。如果我们可以把每年都当作闰年，
这种解决方案也是可行的。我们可以使用同样的技巧来罗列多选结构，就像我们在前
一个实例中的最后几个方案中所给的解答一样。
使用单个正则表达式的问题在于它无法干净地把月和日都捕获到一个捕获分组中。现
在，我们使用了3个捕获分组来处理月，用来处理日的也需要有3个分组。当正则表
达式匹配到一个日期时，在正则式中的7个捕获分组中只有3个会真的捕获到内容。
如果月是二月，分组1和2会捕获月和日。如果该月有30天，那么分组3和4会返回
月和日。如果该月有31天，那么分组5和6会起作用。分组7总是会捕获到年份。
在这种情况下，只有.NET正则流派对我们有帮助。.NET支持给多个命名分组（参考实
例2.11）使用同一个名称，并且会为拥有相同名称的分组使用同一个存储空间。如果
你使用前面给出的只适合.NET的命名捕获解决方案，那么你可以从分组“month”和
“day”匹配的文本中得到结果，而不用去担心一个月到底有多少天。但本书中讨论的
所有其他流派或者不支持命名捕获，或者不支持两个分组拥有相同名称，或者是只会
为任何给定名称返回最后一个分组所捕获的文本。对于这些流派来说，编号分组是唯
一的解决方法。
只有当遇到必须只能使用一个正则表达式的情形，例如你使用的程序只提供一个输入
222第4章
www.TopSage.com
---
## Page 239
框来敲人正则表达式的时候，才有必要采用完全正则表达式的解决方案。在编程的时
候，多用一点儿代码会更加容易。而且如果你想要随后在日期之上再添加一些额外检
查，那么使用代码也会非常有帮助。下面是一个用来匹配2May2007～29August2008
的任意日期的一个纯正则表达式解决方案：
#2 May 2007 ti11 29 August 2008
~(？：
2 May 2007 ti11 31 December 2007
(?：
#2 May ti11 31 May
(?3[01] 1[12][0-9]10?[2-9]) / (?0?5) / (?2007)
#1 June till 31 December
(? :
#30-day months
(?301[12][0-9]10?[1-9])/(?0?[69]111)
# 31-day months
(?3[01]1[12][0-9]10?[1-9]) /(?0?[78]11[02])
/ (?2007)
1
#1 January 2008 ti11 29 August 2008
)
#1 August till 29 August
(?[12][0-9]10?[1-91)/(?0?8)/(?2008)
#1 Janary ti11 30 June
(?:
#February
(?[12][0-9]10?[1-9]) /(?0?2)
#30-day months
([9]0)/([6-]01[6-0][]10)
1
31-day months
(?3[01]1[12][0-9]10?[1-9])/(?0?[1357])
/(?2008)
）
) $
正则选项：宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
参见
实例4.4、4.6和4.7。
合法性验证和格式化
223
www.TopSage.com
---
## Page 240
4.6传统时间格式的合法性验证
问题描述
你想要验证各种不同传统时间格式的时间数据，例如hh:mm和hh:mm:ss，并且要包括
12小时制和24小时制两种时间格式。
解决方案
小时和分钟，12小时制：
（6-0][-0]):（[6-]01[-0])
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
小时和分钟，24小时制：
 (2[0-3]1[01] ?[0-9]) :([0-51?[0-9]) $
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby