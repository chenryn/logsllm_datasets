title:Enemy of the State: A State-Aware Black-Box Web Vulnerability Scanner
author:Adam Doup&apos;e and
Ludovico Cavedon and
Christopher Kruegel and
Giovanni Vigna
Enemy of the State:
A State-Aware Black-Box Web Vulnerability Scanner
Adam Doup´e, Ludovico Cavedon, Christopher Kruegel, and Giovanni Vigna
University of California, Santa Barbara
{adoupe, cavedon, chris, vigna}@cs.ucsb.edu
Abstract
Black-box web vulnerability scanners are a popular
choice for ﬁnding security vulnerabilities in web appli-
cations in an automated fashion. These tools operate in
a point-and-shoot manner, testing any web application—
regardless of the server-side language—for common se-
curity vulnerabilities. Unfortunately, black-box tools
suffer from a number of limitations, particularly when
interacting with complex applications that have multi-
ple actions that can change the application’s state.
If
a vulnerability analysis tool does not take into account
changes in the web application’s state, it might overlook
vulnerabilities or completely miss entire portions of the
web application.
We propose a novel way of inferring the web applica-
tion’s internal state machine from the outside—that is, by
navigating through the web application, observing dif-
ferences in output, and incrementally producing a model
representing the web application’s state.
We utilize the inferred state machine to drive a black-
box web application vulnerability scanner. Our scanner
traverses a web application’s state machine to ﬁnd and
fuzz user-input vectors and discover security ﬂaws. We
implemented our technique in a prototype crawler and
linked it to the fuzzing component from an open-source
web vulnerability scanner.
We show that our state-aware black-box web vulnera-
bility scanner is able to not only exercise more code of
the web application, but also discover vulnerabilities that
other vulnerability scanners miss.
1 Introduction
Web applications are the most popular way of delivering
services via the Internet. A modern web application is
composed of a back-end, server-side part (often written
in Java or in interpreted languages such as PHP, Ruby,
or Python) running on the provider’s server, and a client
part running in the user’s web browser (implemented in
JavaScript and using HTML/CSS for presentation). The
two parts often communicate via HTTP over the Internet
using Asynchronous JavaScript and XML (AJAX) [20].
The complexity of modern web applications, along
with the many different technologies used in various ab-
straction layers, are the root cause of vulnerabilities in
web applications. In fact, the number of reported web
application vulnerabilities is growing sharply [18, 41].
The occurrence of vulnerabilities could be reduced
by better education of web developers, or by the use
of security-aware web application development frame-
works [10, 38], which enforce separation between struc-
ture and content of input and output data. In both cases,
more effort and investment in training is required, and,
therefore, cost and time-to-market constraints will keep
pushing for the current fast-but-insecure development
model.
A complementary approach for ﬁghting security vul-
nerabilities is to discover and patch bugs before mali-
cious attackers ﬁnd and exploit them. One way is to use
a white-box approach, employing static analysis of the
source code [4, 15, 17, 24, 28]. There are several draw-
backs to a white-box approach. First, the potential ap-
plications that can be analyzed is reduced to only those
applications that use the target programming language.
In addition, there is the problem of substantial false pos-
itives. Finally, the source code of the application itself
may be unavailable.
The other approach to discovering security vulnera-
bilities in web applications is by observing the applica-
tion’s output in response to a speciﬁc input. This method
of analysis is called black-box testing, as the applica-
tion is seen as a sealed machine with unobservable in-
ternals. Black-box approaches are able to perform large-
scale analysis across a wide range of applications. While
black-box approaches usually have fewer false positives
than white-box approaches, black-box approaches suffer
view.php
index.php
index.php
S_0
login.php
S_1
view.php
login.php
index.php
Figure 2: State machine of a simple web application.
Figure 1: Navigation graph of a simple web application.
2 Motivation
from a discoverability problem: They need to reach a
page to ﬁnd vulnerabilities on that page.
Classical black-box web vulnerability scanners crawl
a web application to enumerate all reachable pages and
then fuzz the input data (URL parameters, form values,
cookies) to trigger vulnerabilities. However, this ap-
proach ignores a key aspect of modern web applications:
Any request can change the state of the web application.
In the most general case, the state of the web applica-
tion is any data (database, ﬁlesystem, time) that the web
application uses to determine its output. Consider a fo-
rum that authenticates users, an e-commerce application
where users add items to a cart, or a blog where visitors
and administrators can leave comments. In all of these
modern applications, the way a user interacts with the
application determines the application’s state.
Because a black-box web vulnerability scanner will
never detect a vulnerability on a page that it does not
see, scanners that ignore a web application’s state will
only explore and test a (likely small) fraction of the web
application.
In this paper, we propose to improve the effectiveness
of black-box web vulnerability scanners by increasing
their capability to understand the web application’s inter-
nal state. Our tool constructs a partial model of the web
application’s state machine in a fully-automated fashion.
It then uses this model to fuzz the application in a state-
aware manner, traversing more of the web application
and thus discovering more vulnerabilities.
The main contributions of this paper are the following:
• A black-box technique to automatically learn a
model of a web application’s state.
• A novel vulnerability analysis technique that lever-
ages the web application’s state model to drive
fuzzing.
• An evaluation of our technique, showing that both
code coverage and effectiveness of vulnerability
analysis are improved.
Crawling modern web applications means dealing with
the web application’s changing state. Previous work in
detecting workﬂow violations [5, 11, 17, 30] focused on
navigation, where a malicious user can access a page that
is intended only for administrators. This unauthorized
access is a violation of the developer’s intended work-
ﬂow of the application.
We wish to distinguish a navigation-based view of the
web application, which is simply derived from crawling
the web application, from the web application’s internal
state machine. To illustrate this important difference, we
will use a small example.
Consider a simple web application that has only three
pages, index.php, login.php, and view.php. The
view.php page is only accessible after the login.php
page is accessed. There is no logout functionality. A
client accessing this web application might make a series
of requests like the following:
hindex.php, login.php, index.php, view.php,
index.php, view.phpi
Analyzing this series of requests from a navigation
perspective creates a navigation graph, shown in Fig-
ure 1. This graph shows which page is accessible from
every other page, based on the navigation trace. How-
ever, the navigation graph does not represent the infor-
mation that view.php is only accessible after accessing
login.php, or that index.php has changed after re-
questing login.php (it includes the link to view.php).
What we are interested in is not how to navigate the
web application, but how the requests we make inﬂuence
the web application’s internal state machine. The sim-
ple web application described previously has the internal
state machine shown in Figure 2. The web application
starts with the internal state S 0. Arrows from a state
show how a request affects the web application’s inter-
nal state machine. In this example, in the initial state,
index.php does not change the state of the application,
however, login.php causes the state to transition from
S 0 to S 1. In the new state S 1, both index.php and
view.php do not change the state of the web applica-
tion.
The state machine in Figure 2 contains important in-
formation about the web application. First, it shows that
login.php permanently changes the web application’s
state, and there is no way to recover from this change.
Second, it shows that the index.php page is seen in two
different states.
Now the question becomes: “How does knowledge of
the web application’s state machine (or lack thereof) af-
fect a black-box web vulnerability scanner?” The scan-
ner’s goal is to ﬁnd vulnerabilities in the application, and
to do so it must fuzz as many execution paths of the
server-side code as possible1. Consider the simple appli-
cation described in Figure 2. In order to fuzz as many
code paths as possible, a black-box web vulnerability
scanner must fuzz the index.php page in both states S 0
and S 1, since the code execution of index.php can fol-
low different code paths depending on the current state
(more precisely, in state S 1, index.php includes a link
to view.php, which is not present in S 0).
A black-box web vulnerability scanner can also use
the web application’s state machine to handle requests
that change state.
For example, when fuzzing the
login.php page of the sample application, a fuzzer will
try to make several requests to the page, fuzzing different
parameters. However, if the ﬁrst request to login.php
changes the state of the application, all further requests to
login.php will no longer execute along the same code
path as the ﬁrst one. Thus, a scanner must have knowl-
edge of the web application’s state machine to test if the
state was changed, and if it was, what requests to make
to return the application to the previous state before con-
tinuing the fuzzing process.
We have shown how a web application’s state machine
can be leveraged to improve a black-box web vulnerabil-
ity scanner. Our goal is to infer, in a black-box manner,
as much of the web application’s state machine as possi-
ble. Using only the sequence of requests, along with the
responses to those requests, we build a model of as much
of the web application’s state machine as possible.
In
the following section, we describe, at a high level, how
we infer the web application’s state machine. Then, in
Section 4, we provide the details of our technique.
3 State-Aware Crawling
In this section, we describe our state-aware crawling ap-
proach. In Section 3.1, we describe web applications and
deﬁne terms that we will use in the rest of the paper.
Then, in Section 3.2, we describe the various facets of
the state-aware crawling algorithm at a high level.
1Hereinafter, we assume that the scanner relies on fuzzer-based
techniques. However, any other automated vulnerability analysis tech-
nique would beneﬁt from our state-aware approach.
3.1 Web Applications
Before we can describe our approach to inferring a web
application’s state, we must ﬁrst deﬁne the elements that
come into play in our web application model.
A web application consists of a server component,
which accepts HTTP requests. This server component
can be written in any language, and could use many
different means of storage (database, ﬁlesystem, mem-
cache). After processing a request, the server sends back
a response. This response encapsulates some content,
typically HTML. The HTML content contains links and
forms which describe how to make further requests.
Now that we have described a web application at a
high level, we need to deﬁne speciﬁc terms related to
web applications that we use in the rest of this paper.
• Request—The HTTP request made to the web ap-
plication. Includes anything (typically in the form
of HTTP headers) that is sent by the user to the web
application: the HTTP Method, URL, Parameters
(GET and POST), Cookies, and User-Agent.
• Response—The response sent by the server to the
Includes the HTTP Response Code and the
user.
content (typically HTML).
• Page—The HTML page that is contained in the re-
sponse from a web application.
• Link—Element of an HTML page that tells the
browser how to create a subsequent request. This
can be either an anchor or a form. An anchor al-
ways generates a GET request, but a form can gener-
ate either a POST or GET request, depending on the
parameters of the form.
• State—Anything that inﬂuences the web applica-
tion’s server-side code execution.
3.1.1 Web Application Model
We use a symbolic Mealy machine [7] to model the web
application as a black-box. A Mealy machine is an au-
tomaton where the input to the automaton, along with
the current state, determines the output (i.e., the page
produced by the response) and the next state. A Mealy
machine operates on a ﬁnite alphabet of input and out-
put symbols, while a symbolic Mealy machine uses an
inﬁnite alphabet of input and output symbols.
This model of a web application works well because
the input to a web application, along with the current
state of the web application, determines the output and
the next state. Consider a simple e-commerce web appli-
cation with the state machine show in Figure 3. In this
state graph, all requests except for the ones leaving a state
S_0
POST /login.php
GET /logout.php
no_items
POST /add_item.php
GET /delete_item.php
item_in_cart
GET /logout.php
POST /login.php
POST /purchase.php
S_1
purchased_item
GET /logout.php
POST /login.php
S_2
Figure 3: The state machine of a simple e-commerce application.
bring the application back to the same state. Therefore,
this state graph does not show all the request that can be
made to the application, only the subset of requests that
change the state.
For instance, in the initial state S 0, there is only
one request that will change the state of the applica-
tion, namely POST /login.php. This change logs
the user into the web application.
From the state
no items, there are two requests that can change the
state, GET /logout.php to return the user to state S 0
and POST /add item.php to add an item to the user’s
shopping cart.
Note that
the graph shown in Figure 3 is not a
strongly connected graph—that is, every state cannot
be reached by every other state.
In this example, pur-
chasing an item is a permanent action, it irrecoverably
changes the state (there is no link from purchased item
to item in cart). Another interesting aspect is that
one request, GET /logout.php, leads to three differ-
ent states. This is because once the web application’s
state has changed, logging out, and then back in, does
not change the state of the cart.
3.2 Inferring the State Machine
Inferring a web application’s state machine requires the
ability to detect when the state of the web application has
changed. Therefore, we start with a description of the
state-change detection algorithm, then explain the other
components that are required to infer the state machine.
The key insight of our state-change algorithm is the
following: We detect that the state of the web application
has changed when we make an identical request and get
a different response. This is the only externally visible
effect of a state-change: Providing the same input causes
a different output.
Using this insight, our state-change detection algo-
rithm works, at a high level, as follows: (1) Crawl the
web application sequentially, making requests based on
a link in the previous response. (2) Assume that the state
stays the same, because there is no evidence to the con-
trary. (3) If we make a request identical to a previous
request and get a different response, then we assume that
some request since the last identical request changed the
state of the web application.
The intuition here is that a Mealy machine will, when
given the same input in the same state, produce the same
output. Therefore, if we send the same request and get a
different output, the state must have changed. By detect-
ing the web application’s state changes only using inputs
and outputs, we are agnostic with respect to both what
constitutes the state information and where the state in-
formation is located. In this way, we are more generic
than approaches that only consider the database to hold
the state of the application, when in fact, the local ﬁle
system or even memory could hold part of the web ap-
plication’s state.
The state-change detection algorithm allows us to infer
when the web application’s state has changed, yet four
other techniques are necessary to infer a state machine:
the clustering of similar pages, the identiﬁcation of state-
changing requests, the collapsing of similar states, and
navigating.
Clustering similar pages. We want to group together
pages that are similar, for two reasons: To handle inﬁnite
sections of web applications that are generated from the
same code (e.g., the pages of a calendar) and to detect
when a response has changed.
Before we can cluster pages, we model them using the
links (anchors and forms) present on the page. The in-
tuition here is that the links describe how the user can
interact with the web application. Therefore, changes to
what a user can do (new or missing links) indicate when
the state of the web application has changed. Also, in-
ﬁnite sections of a web application will share the same
link structure and will cluster together.
With our page model, we cluster pages together based
on their link structure. Pages that are in different clusters
are considered different. The details of this approach are
described in Section 4.1.
Determining the state-changing request. The state-
change detection algorithm only says that the state has
changed, however we need to determine which request
actually changed the state. When we detect a state
change, we have a temporal list of requests with identical
requests at the start and end. One of the requests in this
list changed the state. We use a heuristic to determine
which request changed the state. This heuristic favors
newer requests over older requests, POST requests over
GET requests, and requests that have previously changed
the state over those that have never changed the state.
The details are described in Section 4.2.