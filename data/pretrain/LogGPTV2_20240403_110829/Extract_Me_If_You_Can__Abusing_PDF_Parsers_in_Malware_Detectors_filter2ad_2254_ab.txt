shellcode and heap-spray detection techniques[26]. While the
authors are able to mitigate all of these parsing issues, they
are only able to hook one version of Adobe Reader, and do
not present any technique for identifying the points to hook
the binary or describe how they did so. In the absence of
this information, one must assume they did so through manual
analysis, which is an arduous task for a program as large and
complex as Adobe Reader, and which must be repeated for
every new version of Adobe Reader.
C. Summary and Hypotheses
As presented in Table I, prior PDF classiﬁers have been
evolving to grasp the semantics of malicious payloads to defeat
rudimentary attacks which create polymorphic malware or
imitate benign ﬁle structures.
Hypothesis 1: A key observation is that all previous
detection methods rely on parsing and interpreting PDF ﬁles
to a certain extent. Consequently,
their detection accuracy
critically depends on the quality of their PDF parsing and
JavaScript extraction. Thus, we hypothesize that a delicate
attack can be launched to evade all these classiﬁers, provided
it can successfully confuse the PDF parsers that are utilized in
detection.
Hypothesis 2: We also realize that, in order to perform
accurate and robust PDF classiﬁcation, it is crucial to actually
examine the embedded JavaScript payloads in PDF ﬁles. As
a result, we hypothesize that the improvement of JavaScript
3
execution traces. In the end, we perform ofﬂine analysis on
the traces to identify three tap points that are associated
with JavaScript extraction, PDF processing termination and
processing error. We can then create the reference JavaScript
extractor by modifying Adobe Reader at these three tap points.
In particular, we identify these points by comparing the dis-
tinctive traces of multiple classes. By processing the memory
access traces of well-formed PDFs with automatically execut-
ing JavaScript, we identify JavaScript extraction tap points,
where embedded JavaScript code is extracted and executed.
By examining the divergent execution traces of well-formed
and malformed ﬁles, we discover processing termination tap
points and processing error tap points, which represent the end
of ﬁle processing in these two classes, respectively.
It is worth noting that we deﬁne the well-formedness of
a PDF ﬁle based on the behavior of Adobe Reader when
opening ﬁle. We do not rely on the PDF speciﬁcation for such
a determination, because 1) some speciﬁcation items are vague
and cannot be easily interpreted, and 2) the implementation of
Adobe Reader in fact deviates from the speciﬁcation in order to
increase compatibility. Thus, we consider PDFs which Adobe
Reader opens successfully to be well-formed. Conversely, we
consider a PDF to be malformed if Adobe Reader opens an
alert indicating it was unable to open the sample. The sample
sets used to perform our analysis were manually constructed
by opening samples with Adobe Reader to determine if they
are well-formed or malformed according to our deﬁnition, and
through manual analysis to determine whether or not they
contained any automatically executing JavaScript.
the technique focuses on extracting all
While we use an existing work as the basis for JavaScript
extraction [15], this technique is insufﬁcient for the devel-
opment of the reference extractor for three reasons. Firstly,
because it relies on an execution monitor for extraction it
is too slow to process any signiﬁcant number of samples.
Secondly,
targeted
information while the monitoring system is run and so provides
no mechanism for determining when all of the data has been
extracted, which we need in order to expediently process
samples. Lastly, the technique does not handle the situation
where no targeted information exists or it cannot be extracted,
i.e. a PDF contains no JavaScript or Adobe Reader fails to
process the PDF because it is malformed.
To address these limitations, our technique is different from
the previous one in three aspects. Firstly, in contrast to this
previous work, which focuses on the instructions that access
data and thus performs analysis solely on memory traces, we
take into account both data accesses and control transfers. The
addition of control ﬂow analysis is necessary because not all
of the information we wish to extract from Adobe Reader can
always be determined by monitoring only memory accesses.
For example, determining if Adobe Reader has encountered
an error or has ﬁnished opening a PDF can likely only be
determined by examining the program’s state. Secondly, this
previous work monitors memory accesses on an “operation”
level and only groups contiguous memory accesses within a
ﬁxed number of memory accesses. However, this grouping is
not well-suited to segmented memory access patterns, which
are likely to appear in JavaScript processing. We instead
keep track of memory access on the granularity of “operation
groups” so as to capture contiguous operations spread over
Fig. 1: Tap Point Identiﬁcation.
extraction can facilitate the detection of malicious documents
that are not detected by existing JavaScript-based PDF classi-
ﬁers.
III. REFERENCE JAVASCRIPT EXTRACTOR
To verify our hypothesis, we need to develop a reference
JavaScript extractor so as to quantitatively measure the discrep-
ancies between existing PDF parsers deployed in detectors and
Adobe Reader.
A. The Need For a New Technique
MPScan demonstrated that a JavaScript extraction tap
point can be manually identiﬁed in Adobe Reader. While the
amount of effort required is not described, given the size and
complexity of Adobe Reader–IDA Pro identiﬁes 91,753 and
133,835 functions in the main AcroRd32.dll component alone,
for the 9.5.0 and 11.0.08 versions of Adobe Reader we worked
with, respectively–it could not have been a simple task.
Since a reference extractor can only precisely mimic the
behavior of a single version of Adobe Reader, our three tap
points must be identiﬁed for each version of Adobe Reader
that is to be protected, making the manual application of this
technique infeasible as a general solution to the problem of
malicious PDF detection. By developing a technique which is
repeatable and automatable we can reliably produce reference
extractors for many versions of Adobe Reader with minimal
effort. Such a technique can also conceivably be applied
to extract executable code from other ﬁle formats, such as
embedded VBA macros in Microsoft Ofﬁce documents. While
we are unable to automate this process completely, we have
been able to automate the majority of the analysis. Overall,
we have found that once the technique has been implemented
to develop one reference extractor, it only takes a few hours
of manual effort develop a new reference extractor based on a
different version.
B. Overview
Figure 1 depicts the workﬂow to build our reference
extractor. We ﬁrst open three classes of labeled PDF samples
(i.e., well-formed PDFs with JavaScript, well-formed PDFs
without JavaScript and malformed PDFs) with Adobe Reader
in an execution monitor [20] to collect memory access and
4
PDFswithJSWell-FormedPDFsMalformedPDFsJSExtractionTapPointProcessingError/ProcessingTerminationTapPointsExecutionTracesOfflineAnalysiscesmany access. Lastly, the original technique selects instructions
as tap points, which can only yield the targeted data to a full
system emulator. In the interest of performance we adapt the
technique to locate functions so that existing function hooking
techniques can be used.
Detailed explanations are presented in the following sub-
sections. In all, we have tailored the existing technique to
identify the JavaScript extraction tap point and extended it to
identify the new processing error and processing termination
tap points which are needed by the reference extractor.
C. JavaScript Extraction Tap Points
Deﬁnition. We consider a JavaScript extraction tap point to
be a function, in which Adobe Reader extracts and executes
JavaScript code from PDF documents. Formally, such a tap
point is deﬁned as a triple:
(caller, f unction entry point, argument number),
where the caller indicates the calling context of the function
and the argument number is the index of the function parameter
which holds a reference to a null-terminated string containing
JavaScript.
We maintain the calling context of the tap point function
to increase the accuracy of identiﬁcation. Some common
functions, such as memcpy, are likely to be invoked by multiple
callers in a program. Only some of these calls are associated
with JavaScript operations, however, so the introduction of
context awareness can signiﬁcantly help eliminate false iden-
tiﬁcation.
We deﬁne tap points at the function level instead of the
instruction level because function entry points are more re-
silient to conditional execution and provide a cleaner interface
for hooking. For example, depending on the length of a string,
different instructions in memcpy are used to copy the string.
Despite the advantage of function-level tap points, in prac-
tice, we have to initially identify instruction-level tap points,
which we call raw tap points. Each raw tap point is deﬁned
formally as a pair:
(caller, program counter1),
where the caller is also the caller of the host function and
the program counter uniquely represents the address of the
instruction.
Once a raw tap point is discovered, data-ﬂow analysis is
needed to correlate the identiﬁed instruction with a certain
argument of the host function. Hence, we can eventually
retrieve the function-level tap points.
Memory Access Trace. The identiﬁcation of raw JavaScript
extraction tap points is performed by analyzing the memory
accesses made by Adobe Reader while opening PDFs which
contain automatically executing JavaScript. All of these mem-
ory accesses are logged in a memory trace, where each access
m is formatted as a tuple:
m = (caller, program counter, type, data, addr)
1For the brevity of presentation, we assume Address Space Layout Random-
ization (ASLR) is disabled. When ASLR is enabled, we in fact use module
name plus offset to specify this raw tap point.
Fig. 2: A Comparison of Identifying Contiguous Memory
Operations between Prior and This Work
That is, the calling context, the address of the instruction
producing the access, the type of the access (either a read
or a write),
the data written or read, and the address of
memory being accessed. In the cases where one layer of calling
context is not sufﬁcient, we can increase context sensitivity
by adding another layer of caller information. We refer to
the set of memory traces collected for these samples as
MJS = [M0, M1, ..., Mn], where each Mi denotes the trace
for an individual sample.
Identiﬁcation of Raw Tap Points. Once the memory traces in
MJS have been collected, we perform ofﬂine analysis in two
steps to identify the raw tap points. First, we group the memory
accesses in each trace into contiguous memory operations then
we examine these memory operations to search for JavaScript
strings.
We keep track of memory accesses on the “operation
group” level instead of the individual operation level in order
to tolerate intermittent memory accesses that often happen in
JavaScript processing where strings are likely to be parsed and
executed segment by segment. The prior work only monitors
a limited window (i.e., ﬁve) of operations at once and any
operations beyond this limit, even if contiguous to a previous
one, cannot be correlated with the previous operations. Fig-
ure 2 demonstrates the advantage of our approach compared
to the prior work [15]. In this example, only three groups
(i.e., {1,2}, {100...1000} and {3,4}) are identiﬁed by the prior
work, though the accesses to memory region 3 and 4 continue
the operations on 1 and 2. To address this limitation, we
keep track of memory operations at a higher granularity and
directly monitor several access groups at the same time. Thus,
the sequential accesses to the memory regions from 100 to
1000 becomes one single group; both accesses to {1,2} and
{3,4} can be observed within a window and therefore can
be further grouped as one. While it is possible for the prior
work to increase the window size in order to properly group
the segmented memory accesses, this drastically increases the
computation overhead.
We deﬁne contiguous memory operations as a list of
instructions with the same calling context which access consec-
utive locations in memory in the same way. Formally, a group
of contiguous memory operations, g, is deﬁned as a triple:
g = (start, end, m list),
where the start and end are the beginning and ending addresses
of the contiguous access, respectively, and m list is a list of
the individual memory accesses [mstart, ..., mend]. To group
these memory operations, we present Algorithm 1.
5
1, 2, 100, 101, 102, … , 999, 1000, 3, 4Prior work:Our technique:Group 1Group 2Group 3Group 1Group 2Memory Access Sequence:The algorithm takes a memory access trace M as an input
and outputs a list of contiguous memory access groups. We
also introduce a working list, W Q, which serves as a LRU
cache to store a ﬁxed number of access groups. In practice,
a cache size of ten was sufﬁcient, though it is possible that
potential tap points are lost as a result of being prematurely
pushed out of the cache. While this size can be increased,
it increases the amount of memory necessary to perform the
analysis.
To identify these groups, we iterate over each memory
operation m in the trace M. If a read operation m matches an
existing group, g in cache W Q in terms of calling context and
the address read by m exactly succeeds the last one accessed
by g, we perform Extend(), which inserts m at the end of g. If
a read operation m falls in the middle of an existing group we
move that group to the front of the cache to avoid discarding
groups which have been recently accessed. Otherwise, m falls
out of the boundary of each existing group which indicates the
presence of a new contiguous memory access group. We create
this new group using m and add it to the front of the cache,
removing and saving the least recently used group if necessary.
In the cases where m in fact writes into an existing group g
in the cache, we invalidate the old group by removing it from
the cache and saving it to output.
Once the contiguous memory operations have been col-
lected for a sample, they are examined to ﬁnd the automatically
executed JavaScript code. Since the in-memory encoding of
the JavaScript is not known, both UTF-8 and UTF-16 repre-
sentations have to be searched for. If a JavaScript string is
discovered, these memory operations are considered to be raw
tap points.
Algorithm 1 Contiguous Memory Operation Identiﬁcation
1: M ← [m0, m1, ...mn]
2: W Q ← an empty list of g
3: for each memory operation m in M do
4:
5:
if ∃g ∈ W Q | g.end+1 = m.addr and g.caller =
if m.type = read then
m.caller then
6:
7:
Extend(g, m)
else if ∃g ∈ W Q | g.start ≤ m.addr ≤ g.end
and g.caller = m.caller then
else
W Q.move to f ront(g)
#m falls out of all g in W Q.
gnew ← CreateN ewGroup(m)
W Q.add to f ront(gnew)
end if
if ∃g ∈ W Q | g.start ≤ m.addr ≤ g.end then
#m is a write.
W Q.remove and save(g)
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18: end for
else
end if
end if
Tap Points Reﬁnement. Once raw tap points are discovered,
we conduct a use-def chain analysis to see if the identiﬁed
memory operations can be traced back to any function argu-
ments. If so, the candidates of JavaScript extraction tap points
are found. Since static analysis may introduce inaccuracy, we
then perform runtime testing to validate these candidates.
6
The search for candidates is repeated for every memory
trace with the set of potential tap points being reduced to
those which produce the embedded JavaScript in all memory
traces processed. A small amount of manual analysis is then
used to determine which of these candidates is to be used and
how the JavaScript can be extracted from them. In practice,
this amounts to examining the tap points in a disassembler to
identify one which easily yields the JavaScript. If no suitable
tap point can be found, this ofﬂine analysis can be repeated
including an additional level of calling context.
D. Processing Termination and Processing Error
Deﬁnition. In addition to the extraction of automatically
executing JavaScript, it is also necessary to determine if Adobe
Reader can successfully open a ﬁle or if will fail to do so
because of some error. We deﬁne these states as