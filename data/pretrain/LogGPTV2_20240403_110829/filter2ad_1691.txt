title:Discovering Semantic Data of Interest from Un-mappable Memory with
Confidence
author:Zhiqiang Lin and
Junghwan Rhee and
Chao Wu and
Xiangyu Zhang and
Dongyan Xu
DIMSUM: Discovering of Semantic Data of Interest 
from Un-mappable Memory with Confidence 
Zhiqiang Lin1 , Junghwan Rhee2, Chao Wu3, Xiangyu Zhang3 
Dongyan Xu3(cid:1)
 1University of Texas at Dallas 
2NEC Laboratories America 
3Purdue University 
The Problem: Memory Forensics 
  Given: 
  A set of memory pages 
  A data structure of interest (e.g., contact, cookie, 
chat history) 
  Identifying: 
pages 
  Instances of that data structure in the memory 
  Assuming: 
  No memory mapping information (e.g., page table) 
Observation: 
Dead Pages Left by Terminated Processes 
State of the Art 
  Value invariant-based approaches 
  Klist [Rutkowska,2003] 
  GREPEXEC [bugcheck, 2006] 
  Volatility [Walters, 2006] [Schuster, 2006]  
  Robust signatures [Dolan-Gavitt et al., CCS’09] 
  Pointer navigation-based approaches 
  KOP [Carbone et al.,CCS’09], CRASH [USENIX’05] 
  SigGraph [Lin et al., NDSS’11]  
Use of Memory Mapping Information 
000001f0: 08 80 04 08 
Where is (0x08048008) pointing to? 
08048  008 
Virtual  
Page  
number 
Page 
Offset 
Page Table 
Virtual Page 
Number  
Physical Page 
Number 
+ 
Physical 
Address 
DIMSUM Overview 
Discovering InforMation with  
Semantics from Un-mappable Memory 
Physical 
Memory Pages 
Primitive 
Pointer 
Probabilistic 
Inference 
Structural 
Same Page 
Data Structure 
Definition 
Semantic 
Staged 
Results 
Constraints 
Structural Constraint 
type = struct passwd { 
     char *pw_name;     //00 
     char *pw_passwd;   //04 
     __uid_t pw_uid;    //08 
     __gid_t pw_gid;    //12 
     char *pw_gecos;    //16 
     char *pw_dir;      //20 
     char *pw_shell;    //24 
} 
p(pw_name) ∧ p(pw_passwd)  
∧ I(pw_uid) ∧ I(pw_gid)  
∧ p(pw_gecos) ∧ p(pw_dir)  
∧ p(pw_shell)  
Semantic Constraint 
type = struct passwd { 
     char *pw_name;     //00 
     char *pw_passwd;   //04 
     __uid_t pw_uid;    //08 
     __gid_t pw_gid;    //12 
     char *pw_gecos;    //16 
     char *pw_dir;      //20 
     char *pw_shell;    //24 
} 
p(pw_name) ∧ p(pw_passwd)  
∧ I(pw_uid) ∧ I(pw_gid)  
∧ p(pw_gecos) ∧ p(pw_dir)  
∧ p(pw_shell)  
(pw_uid >=0) ∧ (pw_gid >=0) 
Same-Page (SP) Constraint 
type = struct passwd { 
     char *pw_name;     //00 
     char *pw_passwd;   //04 
     __uid_t pw_uid;    //08 
     __gid_t pw_gid;    //12 
     char *pw_gecos;    //16 
     char *pw_dir;      //20 
     char *pw_shell;    //24 
} 
SP(*pw_name, *pw_passwd, *pw_gecos, *pw_dir, *pw_shell) 
p(pw_name) ∧ p(pw_passwd) ∧ I
(pw_uid) ∧ I(pw_gid)  
∧ p(pw_gecos) ∧ p(pw_dir)  
∧ p(pw_shell)  
(pw_uid >=0) ∧ (pw_gid >=0) 
00000970  00 00 00 00 70 ac e6 08  75 ac e6 08 00 00 00 00 
00000980  00 00 00 00 7b ac e6 08  80 ac e6 08 86 ac e6 08 
00000990  00 04 00 00 00 00 00 00  00 00 00 00 00 00 00 00 
00000c70  72 6f 6f 74 00 78 00 30  3a 30 3a 72 6f 6f 74 00 
00000c80  2f 72 6f 6f 74 00 2f 62  69 6e 2f 62 61 73 68 00 
00000c90  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00 
Probabilistic Inference Model 
Probabilistic Inference Model (Cont.) 
Probabilistic Inference Model (Cont.) 
Evaluation Results with Linux-based Applications 
Data Structure 
of Interest 
Login record  
(last) 
Browser cookies 
(chromium) 
Address book 
(pine-4.64) 
Contact list 
(pidgin) 
% of 
Memory 
Pages 
100.0 
66.7 
33.3 
100.0 
66.7 
33.3 
100.0 
66.7 
33.3 
100.0 
66.7 
33.3 
True 
Instances 
SigGraph+ 
FP% 
FN% 
DIMSUM 
FP% 
FN% 
8 
6 
0 
25 
19 
9 
124 
96 
63 
300 
198 
98 
0.0 
0.0 
0.0 
69.5 
66.1 
79.1 
48.5 
50.1 
56.8 
38.8 
22.8 
23.0 
25.0 
66.7 
0.0 
0.0 
0.0 
      0.0 
4.8 
10.4 
39.7 
0.0 
0.0 
0.0 
0.0 
0.0 
100.0* 
44.4 
50.0 
43.8 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
18.5 
17.7 
33.3 
1.0 
1.0 
1.0 
Case Study: Login Record utmp in last 
struct utmplist { 
00: short int ut_type; 
04: pid_t ut_pid; 
08: char ut_line[32]; 
40: char ut_id[4]; 
44: char ut_user[32]; 
76: char ut_host[256]; 
332: long int ut_etermination; 
336: long int ut_session; 
340: struct timeval ut_tv; 
348: int32_t ut_addr_v6[4]; 
364: char __unused[20]; 
384: struct utmplist *next; 
388: struct utmplist *prev; 
} 
All Dead Pages Available  
Byte Offset in Memory Dump 
Results with Android 2.1 Applications 
Data Structure  
of Interest 
Cookie 
(Browser) 
Phone  
Contact 
(Messaging)  
Message 
Conversation 
(Messaging) 
% of 
Mem. 
Pages 
100.0 
66.7 
33.3 
100.0 
66.7 
33.3 
100.0 
66.7 
33.3 
True 
Instances 
SigGraph+ 
FN% 
FP% 
DIMSUM 
FP% 
FN% 
31 
25 
6 
117 
79 
36 
101 
60 
40 
77.0 
75.5 
85.8 
0.9 
0.0 
2.9 
0.0 
0.0 
0.0 
0.0 
0.0 
16.7 
4.3 
3.8 
5.6 
2.0 
1.7 
2.5 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
0.0 
Other Related Work 
  ColdBoot [Halderman et al, USENIX Security’08] 
  Laika [Cozzie et al, OSDI’08] 
  DEC0DE [Walls et al, USENIX Security’11] 
Conclusion 
  DIMSUM recognizes data structure instances from 
memory pages 
  Without memory mapping information 
  Based on probabilistic inference 
  Solving constraints about type/structural/semantic 
properties 
  More accurate than non-probabilistic approaches 
Thank	
  you	
67% of Dead Pages Available 
Byte Offset in Memory Dump 
33% of Dead Pages Available  
Byte Offset in Memory Dump 
An Android-Specific Constraint