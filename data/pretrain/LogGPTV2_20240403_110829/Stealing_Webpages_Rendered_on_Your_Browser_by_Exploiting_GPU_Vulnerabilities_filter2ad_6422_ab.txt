Windows, Linux, Android, and iOS. Among its several
functions, we focus on texture functions as textures are
sensitive image data of victims.
Texture mapping is a technique to make objects look
realistic by mapping images or colors to 2D/3D objects.
OpenGL provides a set of functions for texture mapping,
such as glGenTextures() for generating a texture ob-
ject, glBindTexture() for loading the texture object,
and glTexImage2D() for specifying an image array of
the texture object. Programmers either load an image ﬁle
or generate some image data for glTexImage2D(). Once
the texture object is uploaded to GPU memory, programmers
21
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:59:35 UTC from IEEE Xplore.  Restrictions apply. 
(cid:38)(cid:82)(cid:80)(cid:83)(cid:88)(cid:87)(cid:72)(cid:3)(cid:39)(cid:72)(cid:89)(cid:76)(cid:70)(cid:72)(cid:38)(cid:82)(cid:80)(cid:83)(cid:88)(cid:87)(cid:72)(cid:3)(cid:56)(cid:81)(cid:76)(cid:87)(cid:47)(cid:82)(cid:70)(cid:68)(cid:79)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:51)(cid:85)(cid:76)(cid:89)(cid:68)(cid:87)(cid:72)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:51)(cid:40)(cid:51)(cid:85)(cid:76)(cid:89)(cid:68)(cid:87)(cid:72)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:51)(cid:40)(cid:1710)(cid:1710)(cid:38)(cid:82)(cid:80)(cid:83)(cid:88)(cid:87)(cid:72)(cid:3)(cid:56)(cid:81)(cid:76)(cid:87)(cid:47)(cid:82)(cid:70)(cid:68)(cid:79)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:51)(cid:85)(cid:76)(cid:89)(cid:68)(cid:87)(cid:72)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:51)(cid:40)(cid:51)(cid:85)(cid:76)(cid:89)(cid:68)(cid:87)(cid:72)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:51)(cid:40)(cid:1710)(cid:1710)(cid:1710)(cid:42)(cid:79)(cid:82)(cid:69)(cid:68)(cid:79)(cid:18)(cid:38)(cid:82)(cid:81)(cid:86)(cid:87)(cid:68)(cid:81)(cid:87)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:3)(cid:39)(cid:68)(cid:87)(cid:68)(cid:3)(cid:38)(cid:68)(cid:70)(cid:75)(cid:72)(cid:38)(cid:82)(cid:80)(cid:83)(cid:88)(cid:87)(cid:72)(cid:3)(cid:39)(cid:72)(cid:89)(cid:76)(cid:70)(cid:72)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:42)(cid:79)(cid:82)(cid:69)(cid:68)(cid:79)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:38)(cid:82)(cid:81)(cid:86)(cid:87)(cid:68)(cid:81)(cid:87)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:42)(cid:51)(cid:56)(cid:38)(cid:82)(cid:80)(cid:83)(cid:88)(cid:87)(cid:72)(cid:3)(cid:56)(cid:81)(cid:76)(cid:87)(cid:47)(cid:82)(cid:70)(cid:68)(cid:79)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:51)(cid:85)(cid:76)(cid:89)(cid:68)(cid:87)(cid:72)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:51)(cid:40)(cid:51)(cid:85)(cid:76)(cid:89)(cid:68)(cid:87)(cid:72)(cid:3)(cid:48)(cid:72)(cid:80)(cid:82)(cid:85)(cid:92)(cid:51)(cid:40)(cid:1710)(cid:1710)a prevention becomes the third major security concern of
GPUs.
III. SYSTEM AND ATTACK MODELS
We assume a system that equips a GPU for graphics
operations and computations. The system is a multi-user
system so that a number of users can share the equipped
GPU. A victim is a normal user of the system who often
executes programs using the GPU, such as 3D rendering
software, web browsers, and ﬁnancial data analysis tools.
The victim occupies screens to locally use the graphics
APIs. An attacker is another normal user of the system
(a local attacker) who cannot attack the victim at
the
operating system level due to insufﬁcient privilege as many
attacks dealing with multi-user systems assume [28], [29].
The attacker, however, can freely access the GPU via the
computing APIs, as any user of the system can use the APIs.
Consequently, the attacker attempts to exploit the GPU to
disclose the victim’s sensitive data possibly remaining in
GPU memory.
In addition, we consider a remote GPU system using
VirtualGL [19], which is basically the same as the preceding
system. Here, a victim has a right to use VirtualGL [19] to
remotely use the graphics APIs, whereas an attacker has no
right to use VirtualGL. Therefore, the attacker also need to
exploit the GPU to attack the victim’s data kept in GPU
memory. As the attack methods for both systems are the
same, we do not distinguish them in this work.
IV. DISCLOSING GPU MEMORY
In this section, we explain our attacks to disclose sensitive
data in GPU memory exploiting the uninitialized memory
problem. We propose two attacks to steal sensitive data
of a victim program both at the right after its termination
and during its execution. We further discuss real attacks on
security-sensitive GPU programs in the later section.
A. Basic Attack
We identify that current GPUs have uninitialized memory
problems by performing a basic attack that attempts to
read the entire global memory after a victim GPU context
terminates. First, we execute a simple victim program that
writes 1 GB of 0x11111111 on the 3 GB of global
memory of an NVIDIA GeForce GTX 780 GPU. Right after
the victim program terminates, we execute a simple attack
program that reads the entire global memory. When no active
GPU program exists, the memory dump read by the attack
program contains not the victim’s data but dummy data. We
expect that a GPU driver turns GPUs to a sleep mode for
saving power, so that the data written in the global memory
disappear. In contrast, when at least one active GPU program
(e.g., a Gnome desktop) exists, the memory dump contains
not only the 1 GB data written by the victim program,
but also other important data, such as a kernel code. We
(a) Normal GPU execution ﬂow.
(b) End-of-Context (EoC) attack.
(c) End-of-Kernel (EoK) attack.
Figure 3. Overview of proposed attacks.
expect that uncleared data remain in GPU memory, as the
GPU driver does not automatically delete them to avoid
possible performance degradation [20]. We perform a similar
attack on the local and private memories, and detect that
GPUs also do not automatically clear them. Accordingly, we
conclude that current GPUs ignore the uninitialized memory
problems.
B. Overview of Advanced Attacks
We introduce attacks to acquire data stored in the global,
local, and private memories of GPUs. We consider two
attack points: the end of the GPU context and the end
of the GPU kernel. Figure 3 provides an overview of the
proposed attacks. Normal GPU execution ﬂow creates a
GPU context (CC), allocates GPU memory (AM), copies
data from CPU to GPU (HD), executes a kernel (EK), copies
back data from GPU to CPU (DH), frees GPU memory
(FM), and destroys context (DC) (Figure 3a). In the case
of graphics applications, copying results to video frame
buffer replaces DH. When the victim follows the same
execution ﬂow, the End-of-Context (EoC) attack and the
End-of-Kernel (EoK) attack steal data at different moments.
The EoC attack dumps all GPU memory after the victim
frees its memory (Figure 3b). The EoK attack steals the local
and private memories of the victim’s kernel right after the
victim’s kernel terminates (Figure 3c). We mainly explain
the proposed attacks using NVIDIA GPUs, and discuss
differences between NVIDIA and AMD GPUs in terms of
performing the proposed attacks.
C. End-of-Context (EoC) Attack
1) Attack Description: The EoC attack aims to obtain
data released after the destruction of a victim program’s
GPU context. A GPU program can either explicitly de-
stroy its GPU context by calling API
functions (e.g.,
clReleaseContext() and cudaDeviceReset()) or
implicitly destroy its GPU context by its termination. The
22
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:59:35 UTC from IEEE Xplore.  Restrictions apply. 
(cid:87)(cid:76)(cid:80)(cid:72)CCAMHDEKDHFMDC(cid:87)(cid:76)(cid:80)(cid:72)CCAMHDEKDHFMDCCCEoC(cid:57)(cid:76)(cid:70)(cid:87)(cid:76)(cid:80)(cid:36)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:72)(cid:85)(cid:36)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:72)(cid:85)(cid:3)(cid:70)(cid:85)(cid:72)(cid:68)(cid:87)(cid:72)(cid:86)(cid:3)(cid:75)(cid:76)(cid:86)(cid:3)(cid:70)(cid:82)(cid:81)(cid:87)(cid:72)(cid:91)(cid:87)(cid:3)(cid:69)(cid:72)(cid:73)(cid:82)(cid:85)(cid:72)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:89)(cid:76)(cid:70)(cid:87)(cid:76)(cid:80)(cid:284)(cid:86)(cid:3)(cid:39)(cid:38)(cid:17)(cid:87)(cid:76)(cid:80)(cid:72)CCAMHDEKDHFMDC(cid:57)(cid:76)(cid:70)(cid:87)(cid:76)(cid:80)(cid:36)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:72)(cid:85)EoKCC(cid:36)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:72)(cid:85)(cid:3)(cid:70)(cid:85)(cid:72)(cid:68)(cid:87)(cid:72)(cid:86)(cid:3)(cid:75)(cid:76)(cid:86)(cid:3)(cid:70)(cid:82)(cid:81)(cid:87)(cid:72)(cid:91)(cid:87)(cid:3)(cid:69)(cid:72)(cid:73)(cid:82)(cid:85)(cid:72)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:89)(cid:76)(cid:70)(cid:87)(cid:76)(cid:80)(cid:284)(cid:86)(cid:3)(cid:78)(cid:72)(cid:85)(cid:81)(cid:72)(cid:79)(cid:3)(cid:87)(cid:72)(cid:85)(cid:80)(cid:76)(cid:81)(cid:68)(cid:87)(cid:72)(cid:86)(cid:17)sleep()
available ← getAvailableM emoryInf o()
Algorithm 1 End-of-Context Attack
Input: own ← the size of memory occupied by attacker
1: context ← createGP U Context()
2: total ← getT otalM emoryInf o()
3: available ← getAvailableM emoryInf o()
4: while available + own = total do
5:
6:
7: end while
8: available ← getAvailableM emoryInf o()
9: while available + own (cid:54)= total do
10:
11:
12: end while
13: alloc ← allocateM emory(total − own)
14: memoryCopyDeviceT oHost(alloc)
sleep()
available ← getAvailableM emoryInf o()
// victim works
// no victim exists
// victim exits
memory
Algorithm 2 End-of-Context Attack on Multiple Victims
Input: own ← the size of memory occupied by attacker
1: context ← createGP U Context()
2: total ← getT otalM emoryInf o()
3: available ← getAvailableM emoryInf o()
4: while available + own = total do
5:
6:
7: end while
8: available ← getAvailableM emoryInf o()
9: while available + own (cid:54)= total do
10:
11:
12:
sleep()
avail new ← getAvailableM emoryInf o()
if avail new > available then
sleep()
available ← getAvailableM emoryInf o()
// no victim exists
// victims work
// victims deallocate
13:
14:
15:
alloc ← allocateM emory(avail new)
if kernelDetectInstruction(alloc) = true then
memoryCopyDeviceT oHost(alloc)
// only
copy memory with code
end if
f illM emory(alloc)
deallocateM emory(alloc)
16:
17:
18:
19:
20:
21: end while
22: alloc ← allocateM emory(total − own)
23: memoryCopyDeviceT oHost(alloc)
end if
available ← getAvailableM emoryInf o()
// victims exit
Figure 4. Changes of the available global memory size according to a
victim program’s activities. The total size of global memory is 2687 MB
(NVIDIA Tesla C2050 GPU).
main target of this attack is the results of kernel computa-
tions, such as decrypted plaintext and rendered images. If
a victim program does not clear its global memory before
releasing its GPU context, an attacker can easily obtain
the computation results using this attack. Furthermore, we
observe that the GPU context destruction also releases other
important data, such as kernel code, constant data, and call-
by-value arguments of kernels. Current GPUs provide no
methods to delete such data.
2) Attack Procedure: Algorithm 1 shows the EoC at-
tack. NVIDIA GPUs provide functions to examine the
available and total GPU memory size of the GPUs, such
as cudaMemGetInfo(). By continuously examining the
changes in the available memory size using such func-
tions, an attacker can discern whether a victim program
destroyed its GPU context. Figure 4 shows the changes in
available memory size according to the victim’s activities.
The attacker can learn when the victim starts to use GPUs,
allocates and deallocates global memory, and exits from the
GPUs by leveraging the memory usage history. If the victim
no longer uses GPUs, the attacker tries to dump the entire
global memory of the GPUs.
3) Reducing Analysis Space: We suggest a technique
to reduce the analysis space in memory dumps because
(1) usual victim programs only use a small portion of the
global memory and (2) investigating several gigabytes of the
global memory requires unnecessary efforts. Our technique
is to ﬁll the global memory with sufﬁciently long binary
sequences before a victim comes and ignore the sequences
when analyzing dumps of the global memory. We modify
the attack program to ﬁll the global memory of a GPU
with a predeﬁned 1024-bit integer before a victim program
arrives. When analyzing memory dump ﬁles, we ignore the
1024-bit integer in the ﬁles. The probability that a victim
program has the predeﬁned 1024-bit integer in its memory
is negligible. We test
this technique with simple victim
programs allocating 64, 128, 256, 512, and 1024 MB of
global memory, respectively. On average, the size of analysis
space is only 1.3 MB larger than the allocated memory for
storing kernel codes and constant data.
4) Multiple Victims: The EoC attack in Algorithm 1 does
not work when multiple victims are consecutively using the
GPUs. To solve the problem, we modify the attack to deal
with multiple victims (Algorithm 2). Whenever the size of
available GPU memory increases, this algorithm attempts to
allocate all the available memory to obtain the recently deal-
located memory. However, dumping all the available mem-
ory whenever deallocations occur requires much storage and
transmission overhead. The algorithm avoids the overhead
by launching a kernel to verify whether the recent memory
deallocation is due to the destruction of a GPU context.
It is possible by checking whether the deallocated memory
includes instructions (e.g., 0x85800000001c3c02 which
is the NOP instruction of NVIDIA Kepler GPUs). Lastly, the
algorithm copies memory containing instructions to the host
23
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:59:35 UTC from IEEE Xplore.  Restrictions apply. 
7580859095100123456789111133155177199221243265287309331353375397419Available memory (%)Time (ms)attacker’s memoryvictim comesvictim allocates memory (512 MB)victim deallocatesmemoryvictim exitsAlgorithm 3 End-of-Kernel Attack
Input: own ← the size of memory occupied by attacker
1: context ← createGP U Context()
2: total ← getT otalM emoryInf o()
3: available ← getAvailableM emoryInf o()
4: while available + own = total do
5:
6:
7: end while
8: available ← getAvailableM emoryInf o()
9: while available + own (cid:54)= total do
10:
11:
12:
13:
local priv ← kernelReadLocalP rivM em()
memoryCopyDeviceT oHost(local priv)
avail new ← getAvailableM emoryInf o()
if avail new > available and avail new+own (cid:54)= total
sleep()
available ← getAvailableM emoryInf o()
// no victim exists
// victim works
then
14:
15:
16:
17:
18:
19: end while
// victim releases some global memory
alloc ← allocateM emory(avail new)
memoryCopyDeviceT oHost(alloc)
deallocateM emory(alloc)
end if
available ← avail new
Figure 5. Memory layouts of conﬁgurable local memory and L1 data
cache (NVIDIA GPUs).
and ﬁlls the memory with a dummy value before releasing
it, to avoid redundant detections of the same instructions.
D. End-of-Kernel (EoK) Attack
1) Attack Description: The EoK attack aims to obtain