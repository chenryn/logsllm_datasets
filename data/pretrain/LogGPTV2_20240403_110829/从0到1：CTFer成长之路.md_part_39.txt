5.4常见算法识别
在CTF的逆向工程题目中，某些成熟的算法出现频率非常高，如果能识别出这些算法，必然能够大大
提高进行逆向工程的效率。本节介绍常见的算法识别技巧。
5.4.1特征值识别
很多常见算法，如AES、DES等，在运算过程中会使用一些常量，而为了提高运算的效率，这些常量
往往被硬编码在程序中。通过识别这些特征常量，可以对算法进行一个大致的快速判断。表5-4-1是
常见算法需要使用的常量
表5-4-1
通过这种简单的识别法，许多开发者为各种分析工具开发了常量查找插件，如IDA的FindCrypt、
PE
的KANAL等，在可执行文件的分析中非常方便。图5-4-1展示的是使用FindCrypt插件对一个使用了
AES（Rijndael）和MD5算法的程序进行分析的结果。
显然，对这种分析方法的对抗是非常简单的，即故意对这些常量进行修改。因此，特征值识别只能作
为一种快速判断的手段，做出判断后，还需要进行算法复现或动态调试，来验证算法的判断是否正
确。
图5-4-1
5.4.2特征运算识别
当特征值不足以识别出算法时，我们可以深入二进制文件内部，通过分析程序是否使用了某些特征运
https:/weread.q.com/web/reader/77d32500721a485577d8eeek19c3222022419ca14e7eef7
---
## Page 242
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
算来推测程序是否使用了某些算法。表5-4-2给出了CTF逆向工程题目中常见算法的特征运算。
表5-4-2
算法
特征活算（伪代母）
i= (i + 1)% 256;
j=+%256
] dens
流密钥生成
RC4
1=（s[]+x]%256;
j  (j + s[] + k[i] % 256
S盒变换
新环256次
Base64
b3 =(c2& 0xF） c2)(c3>> 6);
8位变6位
b4 = c3 & 0x3F:
TEA系列
(Kx + (s >x)
轮函数
(X&Y)I((X)&Z)
F的数
MD5
(X&Z)(Y&(Z))
G函数
xyZ
日函数
((Z-）X）A
1两数
AES
行移位
整体环4次
DES
L=R
R F(R, K) ~L
Feistel 结构
特征运算识别也是一种快速判断的方法，需要经过动态调试或算法复现等手段确认后才能下定论。
5.4.3第三方库识别
为了提高编程效率，对于一些常用的算法，很多人会选择使用现成的库，如系统库或第三方库。对于
动态链接的库，函数名的符号信息可以被轻易地识别：而对于静态链接的第三方库来说，识别这些信
息则比较困难。本节介绍在IDA中识别第三方库的方法。
1.字符串识别
很多第三方库会将版权信息和该库使用的其他字符串（如报错信息等）以字符串的形式写入库中。在
静态编译时，这些字符串会被一并放入二进制文件。通过寻找这些字符串，可以快速判断使用了哪些
第三方库，以便进一步分析。图5-4-2是通过字符串信息判断某程序使用了MIRACL库的例子。
dst00400000014
Bo sedules definedla
dstx:00400000015
alined -Mocsllto mirtynNJn
dst0000000024
Flssh to dobls corertios fsilurla
图5-4-2
2.函数签名识别
有时，确定了程序所使用的库后，还需要进一步识别具体的函数。本书在前面章节中简要介绍了如何
使用IDA的签名识别功能识别C语言运行库函数，实际上这个功能不仅能对C语言的运行库进行识别：
https:/weread.qq.com/web/reader/77d32500721a485577d8eeek19c3222022419ca14e7eef7
2/4
---
## Page 243
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
每个二进制函数都可以有自己的签名，对同样由二进制机器代码构成的第三方库函数来说，IDA也可
以通过对应签名库快速匹配函数名、参数等信息。IDA中自带了很多除C语言运行库以外的常见库的签
名文件，如VisualC++MFC库等。
读者可以使用前面介绍的方式加载函数签名，也可以在IDA文件菜单中选择“LoadFile→FLIRT
Sig
file”，出现的内容见图5-4-3和图5-4-4。
图5-4-3
unknown_libname_53
tex
std::ios_base::copyfmt(std::ios_base o**
.tex
f
std::locale::operator=(std::locale con"
f
std::ios_base::exceptions(int)
tex
std::ios_base::iword(int)
tex
std::ios_base::pword(int)
tex
std::ios_base::imbue(std::locale const*"
.tex
f
std::ios_base::register_callback(void .".
std::ios_base::_Fnarray::_Fnarray(int,
tex
std::ios_base::ios_base(void)
tex
std::ios_base::_Callfns(std::ios_base:.
tex
std::ios_base::_Findarr(int)
tex
std:ios_base::_Iosarray::_Iosarray(in*.
tex
std::ios_base::_Addstd(void)
tex
std::ios_base::_Ini t(void)
tex
std::ios_base::_Tidy(void)
tex
图5-4-4
如果IDA没有预置需要识别的库函数签名，那么可以在网上查找相应的签名库，如https://github.
/pushOebp/sig-database和https://github.com/Maktm/FLIRTDB等，也可以自己利用IDA
中提供的FLAIR工具，根据已有的.a、.lib等静态库文件自己创建一份签名，放入sig文件夹，然后
在IDA中加载。关于FLAIR工具的使用请读者自行查阅相关资料。
3.二进制比对识别
由于编译环境等各种情况的差异，签名有时无法完全匹配库函数。即使编译环境有一定区别，使用同
一个库编译的二进制文件中的库函数也会存在许多相同之处。如果能够确定程序编写者使用了某个已
知库，并且我们能够获得一份含有符号且同样使用了该库的静态编译二进制文件，我们便可以利用二
https:/weread.qq.com/web/reader/77d32500721a485577d8eeek19c3222022419ca14e7eef7
3/4
---
## Page 244
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
进制比对的方法来具体地确定每个库函数。
二进制比对的常用工具是BinDiff（https://www.zynamics.com/bindiff.html），其最初由
开发，后被Google收购，并被改为免费软件。该工具既可以独立使用，也可以作为IDA的插件使
Zyn
用，功能非常强大。
当我们准备好待逆向文件和自己编译的带符号文件后，便可以在IDA中加载BinDif，再分别加载这两
个文件的IDB，稍等片刻即可看到比对结果，见图5-4-5。
Cenfids Changr EA Prim
EA Secor
iame Seco
5285595885888885855555555555558
图5-4-5
比对的结果中会显示两个函数的相似度、变动和各自的函数名，双击即可具体跳转到某个函数。如果
能够人工确定某两个函数的确是相同的，那么可以利用快捷菜单将函数进行重命名。一般情况下，如
果比较结果显示两个函数几乎没有改动（Similarity极高，Change没有或只有l）且它们不是空函数，
那么它们有很大的可能是同一个函数：有小部分改动的（Similarity在0.9左右，Change有2～3
项），则需要具体查看之后再确定。
下一章
https:/weread.qq.com/web/reader/77d32500721a485577d8eeek19c3222022419ca14e7eef7
---
## Page 245
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
5.5二进制代码保护和混淆
在现实生活中，攻与防的博奔无处不在，为了防止自己编写的二进制程序被逆向分析，许多软件会采
取各种手段，为程序加上重重壁垒。二进制代码的保护手段种类繁多，且运用极其灵活，例如：对汇
编指令进行一定程度的混消变换，可以干扰静态分析中的反汇编过程：在程序中穿插各种反调试技
术。能有效地抵御动态分析：对程序中的关键算法进行虚拟化保护，可以给逆向工作者带来极大的阻
力。这些保护手段造就了逆向工程的漫漫坎坷路，本节将结合CTF与实际生产环境中常见的保护手
段，探讨二进制代码保护与混淆的相关内容。
5.5.1抵御静态分析
无论是逆向工程中常用的IDAPro等工具，还是如Ghidra之类的新兴工具，在载入二进制程序后，它
们首先进行的工作是对程序进行反汇编：将机器码转换为汇编指令，在反汇编结果的基础上开展进一
步的分析。显然，如果反汇编的结果受到干扰，那么静态分析就会变得非常困难。此外，反汇编结果
正确与否将直接影响到诸如Hex-RaysDecompiler等反编译工具反编译的正确性。因此，许多开发者
会选择对汇编指令本身做一些处理，使得反编泽器无法生成逻辑清晰的伪代码，从而增加逆向选手们
的工作量。
干扰反汇编器最简单的方法就是在代码中增加花指令。所谓花指令，是指在程序中完全余，不影响
程序功能却会对逆向工程产生干扰的指令。花指令没有固定的形式，泛指用于干扰逆向工作的无用指
令。下面介绍一段花指令的示例（如无特别说明，本节涉及的汇编代码均为x8632位汇编）。考虑以
下汇编代码：
该片段为常见的函数头，反汇编器经常以此作为判断函数起始地址的依据，也以此进行栈指针分配的
计算。如果在其中加入一些互相挺消的操作，如
那么该代码复杂度明显提升，但实际进行的操作效果并没有变化。此外，pushfd和popfd等指令会
让一些解析栈指针的逆向工具产生错误。
另一种常见的干扰静态分析的方法是在正常的指令中插入一个特定的字节，并在该字节前加入向该字
节后的跳转语句，以保证实际执行的指令效果不变。对于这一特定的字节，要求其是一条较长指令的
首字节（如0xEB为cal指令的首字节）。插入的这个字节被称为脏字节。由于xB6是不定长指令集，
如果反汇编器没有正确地从每条指令的起始位置开始解析，就会出现解析错误乃至完全无法开展后续
分析的情况
前文曾经介绍过线性扫描和递归下降这两种最具代表性的反汇编算法。对于以OIlyDBG和WinDBG为
代表的线性扫描反汇编工具，由于它们只是从起始地址开始一条一条地线性向下解析，我们可以简单
地使用一条无条件跳转指令实现脏字节的插入。对于前文的代码片段，我们在第一条和第二条指令之
间插入一个跳转指令，并且加入0xE8字节，如下所示：
https:/weread.q.com/web/reader/77d32500721a485577d8eeeka5b32500225a5bfc9e0772d
---
## Page 246
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
根据线性扫描反汇编算法，当反汇编器解析完jmpaddr1指令后，会紧接着从下一个0xE8开始进行解
析。而0xE8为call指令的起始字节，就会导致反汇编器认为从0xE8开始的5字节为一条cal指令。从而
让后续的指令全部被错误解析。
而对于以IDAPro为代表的递归下降反汇编器，由于递归下降反汇编算法在遇到无条件跳转时，会转
向跳转的目标地址递归地继续解析指令。就会导致插入的0xE8字节直接被跳过。然而，递归下降反汇
编器尽管部分地模拟了程序执行的控制流过程，但它并不是真正运行，所以不能获取到所有的信息。
我们可以利用这一点，将上面的代码修改如下：
即将一条无条件跳转语句改为两条成功条件相反的条件跳转语句。由于递归下降反汇编算法不能获取
到程序运行中的上下文信息，遇到条件跳转语句时，它会递归地将跳转的分支与不跳转的分支都进行
反汇编。显然，在反汇编完jnz语句后，它不跳转的分支就是下一地址，从而使0xE8开头的“指令
酸解析。
在实际操作过程中，为了达到更好的效果，往往会将这些跳转目标代码的顺序打乱，即“乱序”，从
而达到类似控制流混淆的效果。例如：
还有一种常见的静态混淆方式是指令替换，又称为“变形”。在汇编语言中，大量的指令都可以设法
使用其他指令来实现相同或类似的功能。例如，函数调用指令cal可以使用其他指令替换，如以下指
令
可以替换为如下代码段：
而函数返回指令ret，也可以替换为以下代码段：
注意，该替换破坏了ecx寄存器，因此我们需要保证此时ecx没有正在被程序使用，在实际操作中，可
以根据程序的上下文情况自由调整。在CTF中，出题人通常选择替换涉及函数调用与返回的指令。如
上述call、ret等，这样可以导致IDAPro等工具解析出的函数地址范围与调用关系出现错误，从而干
扰静态分析。
下面给出两个在CTF中出现过的使用相关混淆手段的示例。图5-5-1使用了条件相反的跳转指令。并在
其后插入一个脏字节，从而达到了干扰IDA静态分析的目的。图中跳转的目标地址为402669+1，但
从402669开始解析了指令。对于这种情况，只需在IDA中先将402669开始地址的内容设为数据
再将402669+1开始地址的内容设为代码，就可以正确地解析这一段内容。
https:/weread.qq.com/web/reader/77d32500721a485577d8eeeka5b325d0225a5bfc9e0772d