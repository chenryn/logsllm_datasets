+fdef CONFIG_SYSCTL
加入java编程群：524621833
---
## Page 729
Linux程序设计
kendif
这就起到了定义检查的保护作用。否则，如果我们使用的内核在建立时没有带上syscu支持
一但这种情况是极其少见的，这个模块就会编译失败：
2.可写数据项
Schar注册的条目只向用户提供信息，也就是说，它们是只读性的。但我们设置的模式其实
是允许执行写操作的。在下面的代码里，用户写人的字符串将被简单地输出到系统日志记录里
去。如下所示：
if {write){
MSG(*proc:someone wrote u bytes\n°,*lenp）;
it（tmp)(
if (1eopy_from_user(tmp.buffer.*lenp))
free_page((unsigned long) tap) ;
MSG（*proc:s*,tnp);
f1le->f_pos +s *lenp;
return 0:
一个write参数被传递到注册了的处理器，它指明了这次访问进行的是读操作还是写操作，
如果是后一种情况，写人数据就会拷员给我们并打印出来
要增加一个函数来分析输人并对配置情况嫩相应的调整并不困难。另一个办法是创建许多
个条目，每个条目对应一个Schar的配置选项（就象/proc/sys条目一样），这就使用户能够简单地
使用echo命令直接修改各个“文件”：甚至还可以用proc_dostring来同时完成输人和输出
sysctl调用的信息提取功能在这一方面走得更远，但对这两种方法的学习将为你今后对proc文件
系统进一步的研究准备好必要的工具。这其实是个合二为一的买卖，因为注册sysctl表会同时照
顾到设置相应的proc文件系统条目：文件kermel/sysctl.h是查找进一步资料的好地方：
21.3.16Schar的执行情况
Schar把schar_pool变量用做一个内部的计数器，它的值对应着设备供应或者请求的字节个数
一个负数值表示读数据进程需要schar_pool个字节的数据，而一个正数值则表示有schar_pool个
字节等待读数据进程读取。对设备进行的写操作将给数据池增加一定数量的字节以备随后的耗
用。Schar里有一个持续运行的内核定时器，在这个定时器的控制下，每经过SCHAR_TIMER
_DELAY的时间间隔就给schar_pool增加SCHR_INC个字节：而在这期间，一个读数据进程将等
待有数据可读。对设备进行的写操作永远会成功；可如果某个读数据进程请求的数据比数据池
里的现有数据还要多的话，它就将被添加到Schar的等持队列里，等待队列里的进程会在定时器
处理器每次运行的时候被唤醒一次。它把相应的信息输出到系统的日志记录里。大家不妨把这
个模块插人到内核里试试，亲身体验一下它的工作情况。
Schar用一个空闲的内存页面做为自已的内部缓冲区，读出和写人的数据都是从那里拷贝进
出的，这个页面除了演示数据在内核空间与用户空间之间的移动情况外没有什么其他的特殊目
的，内存方面的问题我们一会儿还会做进一步讨论。
—
加入jaVa编程群：524621833
---
## Page 730
第21章设备驱动程序713
Schar本身并没有什么真正的用处，它只是一个字符驱动设备的驱动程序的基本框架。我们
利用一个内核计时器向数据池里馈送数据，通过这个办法模仿一个字符设备的调度情况。如果
设备不能以中断的形式向驱动程序提供反馈，就必须要使用调度。中断概念我们将在中断驱动
的学符设备部分进行讨论。
21.3.17小结
在这一节里，我们学习了字符设备是如何通过register_chrdev函数把白已注册到内核的设备
切换表里去的。它们给这个函数传递去一个file_operations结构，而这个结构定义了我们在驱动
程序里都提供了哪些访问方法。模块的使用计数确保驱动程序在有人使用时不会被卸载，它的
取值要用MOD_INC_USE_COUNT和MOD_DEC_USE_COUNT宏命令来改变、
我们学习了Schar实现的读文件操作和写文件操作，学习了如何利用等待队列对当前进程进
行“催眠”和“唤醒”。这是一个非常重要的概念，在每一个字符设备驱动程序电都可以看到它
的险用。
接下来，我们学习了驱动程序在读、写功能以外提供的其他文件操作人口点。第一个是通
过lliseek实现的设置读写位置功能；事实上，如果我们没有在模块里自己编写出能够实现这一功
能的代码，llseek系统调用就会成为驱动程序在这方面的缺省调用功能。我们还介绍了如何禁止
下一个是ioctl命令，即1/O控制命令。我们知道怎样把调用分为两个部分：一个基地址和一
个命令。Schar驱动程序里的ioctl命令处理差不多完全是用一个switch语句来实现的，如果用户
应用程序调用了一个未知的ioct命令，驱动程序仅返回“-ENOTTY”。并不是任何用户都能使用
所有的ioctl调用。特定权限可以用capable函数米核查。
poll提供了一个使读数据进程在等待数据准备好的同时进入休眠状态的办法。Schar里的实
现只对读数据进程进行检查，因为它随时能够接受写数据进程写来的数据、虽然在Schar里只测
试读数据进程，但我们把其他调度掩码也介绍给了大家。
再往后，我们简单地介绍了设定模块参数方面的知识，然后学习了如何在Schar里设管proc
文件系统的注册项目。我们介绍了完整的设置过程，并且给出了一个sysctl设置项-一它既可以
通过读取/proc/sys/dev/schar里的项目来查看，也可以通过syscu系统调用来查看。
最后，我们简单地介绍了数据拷贝进出Schar设备时它的执行情况。我们建议大家自行编译
这个模块并运行它试试，这样才能全面掌握它的作用和原理。
21.4定时和时基：jiffies变量
内核把时间计数保存在全局性的jiffies变量里。你可以把它想象为内核的心跳，时间每流逝
一个单位时间（即时基），jiffies就增加一个值。常数定义“HZ”控制着时间计数的额率，它是
在头文件asm/param.h里定义的、你可以按自己的意患修改它。但修改这个常数需要重新编译所
有现有的模块（当然也包括内核），并且会产重影响依赖于“HZ”缺省值的应用程序。除了采用
Alpha体系结构的计算机以外，其他各种平台都把这个值设置为100，也就是说，每个时间计数
代表着10毫秒。增大这个值将会以在进程调度器身上花费更多时间为代价提高系统的交互性能，
加入iaVa编程群：524621833
---
## Page 731
Linux程序设计
但让它保持为100可能是更安全的做法：许多人认为应该修改“HZ”常数，因为它们自Linux出
现之日起就一直是这个值，从来没有改变过：这样的争论时不时地就会出现，但直到处理器芯
片速度已经大幅度提高的今天，增加这个值能否改善计算机的性能仍然没有定论。
在编写设备驱动程序的时候，你可以会遇到需要检测某个操作是否已经在给定的时间单完
成了的情况。有些设备不支持在操作完成时产生中断，它们必须通过针对其状态而采取的某种
形式的调度方案来处理。这通常只涉及到一些老式或设计不良的硬件产品：现代化的设备都应
该支持某种形式的事件通知功能。繁忙福环在设备驱动程序的设计实践里从没有被认为是好的
做法。如果你不得不使用这些“损招”、就--定只能用在设备检测或类似情况等老套路里。在这
种情况下，最经常使用的程序框架都是下面这段代码的变体：
unsigned long timeout = jiffies + PRCBE_TIMEOUT;
dof
)while (stat == BuSY && time_beforelfiffies. timeout1);
if (time_after_eg{jiffies, timeout))
printk(*operation timed out.\n*1;
你可能会对time_before和tiem_after_eq这两个函数的作用产生质疑，为什么不直接比较
timeout和jiffies这两个值呢？是这样的，Linux是一-个非常稳定的系统，在两次重启动之间计算
机运行了相当长的时间并不希奇：可jiffies变量是被定义为一个不带正负号的长整数的，它终将
会溢出归零，然后又从零重新开始计时。如果在对jiffies和PROBE_TIMEOUT做加法时出现了时
间计数溢出归零的现象，那么下面这个简单的测试：
1op
do_connand (PROBE);
while (stat = BUSY ss (jiffies x”比较
tine_before_eq(jiffies,x)
考虑了澄出归零问题的“jiies 0)(
are waiting for data.*/
wake_up_interruptible(kschar_poll_read):
return;
这段代码涉及到的语法现象并不复杂，我们就不对它做过多解释了。我们只用这个处理器
函数负责管理了-个定时器，所以Schar里没有用到定时器的data参数。但我们可以让读数据进
器（SCHAR_READER）还是写数据进程的定时器（SCHAR_WRITER）。data的用法还有许多
一一它是做为一个参数传递到定时器的处理函数里去的，因此你可以按照自己的想法随意使用它。
此外，如果不把expires与当前时间结合起来，定时器也就没有什么价值一一你必须明确地给它和
加入jaVa编程群：524621833
---
## Page 734
第21章设备驱动程序
717
jiffies变量做加法。
定时器会在它们失效时被自动检测出来，但如果模块被卸载后还把它们留在内核里处于挂
起状态，就会造成内核的挂起一一这是个挂起内核的好办法。这也意味着你可以在定时器处理函
数里再次添加同一个定时器。cleanup_module调用timer_pending来检查定时器是否已经失效、如
果定时器尚未失效，它返回true；否则返回false。仍在运行中的定时器可以用del_timer明确地删
除掉，但很少有必要这样做；对已经失效的定时器调用del_timer不会产生什么副作用。很少会
出现需要调用del_timer的情况，我们在这里介绍它的目的是为了把与定时器有关的各种函数都
告诉大家。
如果你需要修改定时器的设置值以加大计时时间，就要使用mod_timer，不必使用下面这样
的代码：
del_timer (atimerl1 :
timerl.expires = jitfies + new_value;
add_tiner (&timerl) :
你可以用下面这一条语句就完成了操作：
mod_cimer(&timerl, new_value );
两种做法效果相同，可后一种更简单也更易于阅读理解。如果在调用mod_timer的时候定时
器已经失效了，它的作用就象add_timer一样会让这个定时器再投入使用。
动手试试：在Schar里实现的定时器功能
Schar利用一个内核定时器周期性地把数据添加到自己的数据池里。其时间间隔既可以通过
一个iocti调用来完成，也可以通过修改schar.h文件里的SCHAR_TIMER_DELAY来实现
定时器是在有读数据进程打开了这个设备时投入使用的，并且会在读数据过程中在定时器
处理器里被反复添加，直到读数据的操作结束为止。
Scp/dev/achar out_file
schar: opened for_reading
scbaz: putting proceee with pid 889 to sleep
schar: major: 42 minor: 0
schar: setting tiner up again, :024 data now
0ts0 688 pd  ssod 6aad es
schar: setting timer up again, 2048 data now
schar: putting process with pid 889 to sleep
schar: setting timer up again. 3072 data nov
schar: putting process with pid 889 to sleep