### 4. Efficient Query Evaluation in a Fragment of EON

Under certain assumptions, we can show that query evaluation in EON can be reduced to simple query evaluation in Datalog. This transformation is independent of the previous sections and offers significant efficiency benefits. While checking the satisfiability of Datalog programs may take exponential time in the worst case, evaluating Datalog programs typically takes only polynomial time.

#### Requirements for the Transformation
1. **No (In)Equality Constraints**: There should be no (in)equality constraints over variables. Specifically, variables cannot be repeated in the head of a clause.
2. **No Negations on Non-Base Relations**: Negations are allowed only on base relations, not on non-base (derived) relations.

These conditions are reasonable in practice. For example, our models of Vista and Asbestos in Section 5 satisfy these conditions, and most of our queries on these models also meet these criteria.

We assume that sequencing is compiled away as in our original reduction, and we consider only basic queries. Additionally, we assume that no constants appear in the EON program itself. (The transformation can be extended to allow constants in a straightforward manner.)

#### Intuition Behind the Transformation
Let \( E = \{B_1, \ldots, B_k\} \). The atomic state of a constant \( c \) can be represented as a vector \((v_1, \ldots, v_k)\), where \( v_i \) is 1 if \( B_i(c) \) is true and 0 otherwise. Two constants \( c \) and \( c' \) are considered similar if they have the same atomic state. In our case, a Datalog program cannot distinguish between similar constants; it is not possible to define a query \( R(x) \) that is satisfied by \( c \) but not by \( c' \).

Thus, we can define a new query \( \lfloor R \rfloor(x_1, \ldots, x_k) \) which is true if and only if \( R(x) \) is true for any \( x \) with atomic state \((x_1, \ldots, x_k)\) generated by the EON program.

#### Transformation Process
For every non-base relation \( R \) of arity \( r \), we define a new relation \( \lfloor R \rfloor \) of arity \( rk \). Given any Datalog clause \( C \), we replace it with a transformed clause \( \lfloor C \rfloor \) as follows:
- For every variable \( x \) in the clause, introduce \( k \) new variables \( x_1, \ldots, x_k \).
- Every literal of the form \( R(y_1, \ldots, y_r) \), where \( R \) is a non-base relation, is transformed into a corresponding literal \( \lfloor R \rfloor(y_{11}, \ldots, y_{1k}, \ldots, y_{r1}, \ldots, y_{rk}) \) by replacing each occurrence of a variable \( y_j \) with the vector of variables \( y_{j1}, \ldots, y_{jk} \).
- Every literal of the form \( B_i(x) \) is transformed into the literal \( \text{True}(x_i) \), and every literal of the form \( \neg B_i(x) \) is transformed into \( \text{False}(x_i) \). (The auxiliary predicates True and False are defined by the facts \( \text{True}(1) \) and \( \text{False}(0) \).)
- For every variable \( x \) in the head of the clause, add the condition \( \text{Reachable}(x_1, \ldots, x_k) \) to the body of the transformed clause. (As an optimization, this reachability condition may be added only if no non-base relation is applied to \( x \) in the body of the clause.)

For example, the clause:
\[ R(x, y) \leftarrow R'(x), \neg B_1(x), B_2(y) \]
yields the transformed clause:
\[ \lfloor R \rfloor(x_1, x_2, y_1, y_2) \leftarrow \lfloor R' \rfloor(x_1, x_2), \text{False}(x_1), \text{True}(y_2), \text{Reachable}(y_1, y_2) \]

Further, every clause of the form "new B :- R." is transformed to:
\[ \text{Reachable}(z_1, \ldots, z_k) \leftarrow \lfloor R \rfloor \]
where \( z_i \) is 1 if \( B_i \in B \) and 0 otherwise.

Every clause of the form "next B(x), \(\neg\) B′(x) :- R(x)." is transformed to:
\[ \text{Reachable}(z_1, \ldots, z_k) \leftarrow \lfloor R \rfloor(x_1, \ldots, x_k), \text{Reachable}(x_1, \ldots, x_k), \text{Update}(x_1, z_1), \ldots, \text{Update}(x_k, z_k) \]
where \( \text{Update}(x_i, z_i) \) is \( \text{True}(z_i) \) if \( x_i \) is in \( B \), \( \text{False}(z_i) \) if \( x_i \) is in \( B' \), and \( z_i = x_i \) otherwise.

#### Theorem
**Theorem 3.** Given an EON program \( P \) with the above restrictions, a query \( Q \) is true in \( P \) if and only if the query \( \lfloor Q \rfloor \) is true in the Datalog program \( \lfloor P \rfloor \).

Proof details for all our results appear separately in [7] and are omitted here due to space constraints.

### 5. Experiments with the EON Tool

The transformations described in Sections 3 and 4 are implemented in the EON tool [7]. The back end includes implementations of satisfiability and evaluation algorithms over Datalog, and the front end supports some syntax extensions over EON, such as embedded scripts [7].

We now present a series of examples that illustrate how the EON tool can be used to model and analyze dynamic access control systems.

#### 5.1 Windows Vista

Windows Vista's access control model aims to maintain boundaries around trusted objects to protect them from less trusted processes. Trust levels are denoted by integrity labels (ILs), such as High, Med, and Low. Each object and process has an IL. A process can spawn new processes, create new objects, and change their ILs based on its own IL. Specifically, a process with IL \( PL \) can:
- Lower an object’s IL from \( OL \) only if \( OL \sqsubseteq PL \).
- Raise an object’s IL to \( OL \) only if \( OL \sqsubseteq PL \) and the object is not a process.
- Read an object.
- Write an object with IL \( OL \) only if \( OL \sqsubseteq PL \).
- Execute an object with IL \( OL \) by lowering its own IL to \( PL \sqcap OL \).

Below is an excerpt of a model of such a system in EON. The unary base relations in the model have the following informal meanings: \( P \) contains processes; \( \text{Obj} \) contains objects (including processes); and \( \text{Low} \), \( \text{Med} \), \( \text{High} \), etc., contain processes and objects with those ILs.

With `new` and `next` clauses, we specify how an unbounded number of processes and objects of various kinds can be created:
```eon
new Obj, Low.
new Obj, Med.
new Obj, High.
next P(x) :- Obj(x).
```

With `next` clauses, we specify how ILs of processes and objects can be changed. For instance, a Med process can raise the IL of an object from Low to Med if that object is not a process; it can also lower the IL of an object from Med to Low. A High process can lower its own IL to Med (e.g., to execute a Med object).

```eon
next Med(y), !Low(y) :- Low(y), !P(y), Med(x), P(x).
next Low(y), !Med(y) :- Med(y), Med(x), P(x).
next Med(x), !High(x) :- High(x), P(x).
```

The full model contains several other rules that are implemented by the system. Specifying these rules manually can be tedious and error-prone; instead, EON allows us to embed scripts in our model (as syntax extensions) that generate these rules automatically [7].

Finally, with Datalog clauses, we specify how processes can Read, Write, and Execute objects. A process \( x \) can Read an object \( y \) without any constraints. In contrast, \( x \) can Write \( y \) only if the IL of \( x \) is Geq (greater than or equal to) the IL of \( y \). Conversely, \( x \) can Execute \( y \) only if the IL of \( y \) is Geq the IL of \( x \).

```eon
Read(x, y) :- P(x), Obj(y).
Write(x, y) :- P(x), Geq(x, y).
Execute(x, y) :- P(x), Geq(y, x).
Geq(x, y) :- Med(x), Med(y).
Geq(x, y) :- Med(x), Low(y).
Geq(x, y) :- Low(x), Low(y).
```

#### 5.1.1 Integrity Vulnerabilities on Windows Vista

We now ask some queries on the model above. For instance:
- Can a Med object be read by a Med process after it is written by a Low process?
- Can an object that is written by a Low process be eventually executed by a High process by downgrading to Med?

```eon
? Med(y); Low(x), Write(x, y); Med(z), Read(z, y).
? Low(x), Write(x, y); High(z); Med(z), Execute(z, y).
```

The former encodes a simple data-flow integrity vulnerability, while the latter encodes a simple privilege-escalation vulnerability. When we run these queries, we obtain several exploits for those vulnerabilities. For each exploit, our tool shows a derivation tree; from that tree, we find a sequence of `new`, `next`, and other clauses that lead the system to an insecure state and derive the query.

For example, the former query is derived as follows: first, a Med object \( y \) is created; next, \( y \) is downgraded to Low by a Med process; next, \( y \) is written by a Low process \( x \); finally, \( y \) is read by a Med process \( z \). The latter query is derived as follows: first, a Low object \( y \) is created; next, \( y \) is written by a Low process \( x \); next, \( y \) is upgraded to Med by a Med process; next, a High process \( z \) is downgraded to Med; finally, \( y \) is executed by \( z \).

Thus, EON can be quite effective as a debugging tool—if there is a bug, EON is guaranteed to find it. If there are no bugs, EON will terminate without finding any, making it equally effective as a theorem-proving tool. We now prove that the vulnerabilities above cannot be exploited if suitable constraints are imposed on the model. In practice, these constraints may be implemented either by static analysis or by runtime monitoring on programs running in the system.

#### 5.1.2 An Usage Discipline to Recover Integrity

We attach to each object a label \( S\text{High} \), \( S\text{Med} \), or \( S\text{Low} \), indicating a static lower bound on the integrity of the contents of that object. We also attach to each process a label \( D\text{High} \), \( D\text{Med} \), or \( D\text{Low} \), indicating a dynamic lower bound on the integrity of the values known to that process. These labels are maintained as invariants by the model. Specifically, these labels are initialized as follows:

```eon
new Obj, Low, SLow.
new Obj, Med, SMed.
new Obj, High, SHigh.
next P(x), DHigh(x) :- Obj(x).
```

Whenever an object’s IL is lowered, the IL should not fall below the static label of the object:

```eon
next Low(y), !Med(y) :- Med(y), SLow(y), Med(x), P(x).
```

A process’s dynamic label may be lowered to reflect that it may know the contents of an object with a lower static label:

```eon
next DLow(x), !DHigh(x) :- DHigh(x), SLow(y).
```

Now, a process \( x \) can Read an object \( y \) only if the dynamic label of \( x \) is DSLeq (less than or equal to) the static label of \( y \). Conversely, \( x \) can Write \( y \) only if the dynamic label of \( x \) is DSGeq (greater than or equal to) the static label of \( y \). In contrast, \( x \) can Execute \( y \) only if its own IL is lowered to or below the static label of \( y \). This condition, \( S\text{Geq}(y, x) \), subsumes the earlier condition \( \text{Geq}(y, x) \).

```eon
Read(x, y) :- P(x), Obj(y), DSLeq(x, y).
DSLeq(x, y) :- DLow(x), SLow(y).
DSLeq(x, y) :- DLow(x), SMed(y).
DSLeq(x, y) :- DMed(x), SMed(y).

Write(x, y) :- P(x), Obj(y), Geq(x, y), DSGeq(x, y).
DSGeq(x, y) :- DLow(x), SLow(y).
DSGeq(x, y) :- DMed(x), SMed(y).
DSGeq(x, y) :- DMed(x), SLow(y).

Execute(x, y) :- P(x), Obj(y), SGeq(y, x).
SGeq(y, x) :- SLow(y), Low(x).
SGeq(y, x) :- SMed(y), Low(x).
SGeq(y, x) :- SMed(y), Med(x).
```

Finally, recall the temporal queries we asked above. We reformulate the former query for this model—instead of constraining the IL of \( z \), we now constrain its dynamic label, which is a better approximation of its runtime taint:

```eon
? Med(y) ; Write(x, y), Low(x) ; Read(z, y), DMed(z).
```

This query evaluates to false, showing that the encoded data-flow integrity vulnerability cannot be exploited. The latter query also evaluates to false, showing that the encoded privilege-escalation vulnerability cannot be exploited. The full constrained model appears in [7].