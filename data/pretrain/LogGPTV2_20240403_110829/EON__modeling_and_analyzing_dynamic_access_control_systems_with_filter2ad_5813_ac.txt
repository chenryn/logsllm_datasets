. . .
next Done(x)
:− S.
We then evaluate the query Done(x), S1 # . . . # Sn on the aug-
mented EON program.
More generally, we add a next clause with a fresh Done relation
for each variable shared by S and Q, and augment Q accordingly
to account for those variables. On the other hand, if S and Q do not
share any variable, we add a new clause with a fresh Done relation,
and augment Q with Done(z), where z is a fresh variable.
4. EFFICIENT QUERY EVALUATION
IN A FRAGMENT OF EON
Under further assumptions, we now show that query evaluation
in EON can be reduced to simple query evaluation in Datalog. This
result is independent of what we present above. The main advan-
tage of this transformation is efﬁciency—while checking satisﬁa-
bility of Datalog programs may take exponential time in the worst
case, evaluating Datalog programs takes only polynomial time.
The requirements for this transformation are as follows. There
should be no (in)equality constraints over variables. In particular,
variables cannot be repeated in the head of a clause. Next, there
should be no negations on non-base (derived) relations, although
there may be negations on base relations. These conditions turn out
to be quite reasonable in practice. In particular, our models of of
Vista and Asbestos in Section 5 satisfy these conditions, and most
of our queries on these models satisfy these conditions as well.
We assume that sequencing is compiled away as in our origi-
nal reduction, and consider only basic queries. Further, we assume
that no constants appear in the EON program itself. (The trans-
formation can be extended in a straightforward way to allow con-
stants.) The intuition behind the transformation is as follows. Let
E = {B1, . . . , Bk}. We can represent the atomic state of a con-
stant c as the vector (v1, . . . , vk) where vi is 1 if Bi(c) is true and
0 otherwise. We say that two constants c and c′ are similar if they
have the same atomic state. Now in our case, a Datalog program
cannot distinguish between similar constants, i.e., it is not possible
to deﬁne a query R(x) that is satisﬁed by c and not c′. (More gen-
erally, if ci is similar to c′
i for 1 ≤ i ≤ r, then R(c1, . . . , cr) is
true iff R(c′
r) is true in the program.) Thus we can deﬁne a
query ⌊R⌋(x1, . . . , xk) which is true iff R(x) is true for any x with
atomic state (x1, . . . , xk) that is generated by the EON program.
1, . . . , c′
For every non-base relation R of arity r, we deﬁne a new re-
lation ⌊R⌋ of arity rk. Given any Datalog clause C, we re-
place it with a transformed clause ⌊C⌋ as follows.
For ev-
ery variable x in the clause, we introduce k new variables
x1, . . . , xk. Then, every literal of the form R(y1, . . . , yr), where
R is a non-base relation, is transformed into a corresponding lit-
eral ⌊R⌋(y11, . . . , y1k, . . . , yr1, . . . , yrk) by replacing every oc-
currence of a variable yj by the corresponding vector of variables
yj1, . . . , yjk. Further, every literal of the form Bi(x) is trans-
formed into the literal True(xi) and every literal of the form
!Bi(x) is transformed into False(xi).
(The auxiliary predi-
cates True and False are deﬁned by the facts True(1) and
False(0).) Finally, for every variable x in the head of the clause,
we add the condition Reachable(x1, . . . , xk) to the body of the
transformed clause. (As an optimization, we may consider adding
this reachability condition only if no non-base relation is applied to
x in the body of the clause.) For example, the clause
R(x, y)
:− R′(x), !B1(x), B2(y).
yields the transformed clause:
⌊R⌋(x1, x2, y1, y2)
:−
⌊R′⌋(x1, x2), False(x1), True(y2), Reachable(y1, y2).
Now, every clause of the form “new B :− R." is transformed to
Reachable(z1, . . . , zk)
:− ⌊R⌋.
where zi is 1 if Bi ∈ B and 0 otherwise.
Further, every clause of the form “next B(x), !B′(x) :− R(x)."
is transformed to
Reachable(z1, . . . , zk)
⌊R⌋(x1, . . . , xk),
Reachable(x1, . . . , xk),
Update(x1, z1), . . . ,Update(xk, zk).
:−
where Update(xi, zi) is True(zi) if xi is in B, False(zi) if xi
is in B′, and zi = xi otherwise. (The literal zi = xi is imple-
mented by replacing zi with xi in the clause.)
We then have the following result.
THEOREM 3. Given an EON program P with the above restric-
tions, a query Q is true in P iff the query ⌊Q⌋ is true in the Datalog
program ⌊P⌋.
Proof details for all our results appear separately in [7], and are
omitted here due to lack of space.
5. EXPERIMENTS WITH THE EON TOOL
The transformations described in Sections 3 and 4 are imple-
mented in the EON tool [7]. Further, the back end includes imple-
mentations of satisﬁability and evaluation algorithms over Datalog,
and the front end supports some syntax extensions over EON, such
as embedded scripts [7].
We now present a series of examples that illustrate how the EON
tool can be used to model and analyze dynamic access control sys-
tems. We begin with Windows Vista’s access control model (Sec-
tion 5.1). We automatically ﬁnd some integrity vulnerabilities in
this model. Then, we automatically prove that exploits for those
vulnerabilities can be eliminated by enforcing a certain usage dis-
cipline on the model (via static analysis or runtime monitoring).
Roughly, this means that a user can be informed about potentially
unsafe authorization decisions in this model. Next, we consider
Asbestos’s access control model (Section 5.2). We automatically
validate some secrecy properties of that model. Finally, we model a
full-ﬂedged webserver that runs on Asbestos (as described in [11]),
and automatically prove a secrecy guarantee for the webserver.
5.1 Windows Vista
The goal of Windows Vista’s access control model is to maintain
boundaries around trusted objects, in order to protect them from
less trusted processes. Trust levels are denoted by integrity labels
(ILs), such as High, Med, and Low. Every object has an IL. Fur-
ther, every process is itself an object, and has an IL. A process can
spawn new processes, create new objects, and change their ILs,
based on its own IL. In particular, a process with IL PL can2:
– lower an object’s IL from OL only if OL ⊑ PL;
– raise an object’s IL to OL only if OL ⊑ PL and the object is not
a process;
– read an object;
– write an object with IL OL only if OL ⊑ PL;
– execute an object with IL OL by lowering its own IL to PL ⊓OL.
Below, we present an excerpt of a model of such a system in
EON. (The full model appears in [7].) The unary base relations
in the model have the following informal meanings: P contains
processes; Obj contains objects (including processes); and Low,
Med, High, etc. contain processes and objects with those ILs.
With new and next clauses, we specify how an unbounded num-
ber of processes and objects, of various kinds, can be created.
new Obj,Low.
new Obj,Med.
new Obj,High.
next P(x) :- Obj(x).
...
Further, with next clauses, we specify how ILs of processes and
objects can be changed. For instance, a Med process can raise the
IL of an object from Low to Med if that object is not a process; it
can also lower the IL of an object from Med to Low. A High pro-
cess can lower its own IL to Med (e.g., to execute a Med object).
2In fact, the capabilities of a process may be further constrained by Win-
dows Vista’s discretionary access control model. However, we ignore this
model because it is rather weak; see [7] for a detailed discussion.
next Med(y),!Low(y) :- Low(y),!P(y),Med(x),P(x).
next Low(y),!Med(y) :- Med(y),Med(x),P(x).
next Med(x),!High(x) :- High(x),P(x).
...
The full model contains several other rules that are implemented
by the system. Specifying these rules manually can be tedious and
error-prone; instead, EON allows us to embed scripts in our model
(as syntax extensions) that generate these rules automatically [7].
Finally, with Datalog clauses, we specify how processes can
Read, Write, and Execute objects. A process x can Read an
object y without any constraints. In contrast, x can Write y only
if the IL of x is Geq (greater than or equal to) the IL of y. Con-
versely, x can Execute y only if the IL of y is Geq the IL of x.
Read(x,y) :- P(x),Obj(y).
Write(x,y) :- P(x),Geq(x,y).
Execute(x,y) :- P(x),Geq(y,x).
Geq(x,y) :- Med(x),Med(y).
Geq(x,y) :- Med(x),Low(y).
Geq(x,y) :- Low(x),Low(y).
...
5.1.1 Integrity vulnerabilities on Windows Vista
We now ask some queries on the model above. For instance,
can a Med object be read by a Med process after it is written by a
Low process? Can an object that is written by a Low process be
eventually executed by a High process by downgrading to Med?
? Med(y); Low(x),Write(x,y); Med(z),Read(z,y).
? Low(x),Write(x,y); High(z); Med(z),Execute(z,y).
The former encodes a simple data-ﬂow integrity vulnerability;
the latter encodes a simple privilege-escalation vulnerability. (In
the full model, we study some more complicated vulnerabilities.)
When we run these queries, we obtain several exploits for those
vulnerabilities. (See, e.g., [6, 8], for more details on such vulner-
abilities.) For each exploit, our tool shows a derivation tree; from
that tree, we ﬁnd a sequence of new, next, and other clauses that
lead the system to an insecure state and derive the query. For in-
stance, the former query is derived as follows: ﬁrst, a Med object y
is created; next, y is downgraded to Low by a Med process; next, y
is written by a Low process x; ﬁnally, y is read by a Med process
z. The latter query is derived as follows: ﬁrst, a Low object y is
created; next, y is written by a Low process x; next, y is upgraded
to Med by a Med process; next, a High process z is downgraded
to Med; ﬁnally, y is executed by z.
Thus, EON can be quite effective as a debugging tool—if there
is a bug, EON is guaranteed to ﬁnd it. But recall that if there are
no bugs, EON is also guaranteed to terminate without ﬁnding any!
That is, EON can be just as effective as a theorem-proving tool. In
particular, we now prove that the vulnerabilities above cannot be
exploited if suitable constraints are imposed on the model. In prac-
tice, these constraints may be implemented either by static analysis
or by runtime monitoring on programs running in the system.
5.1.2 An usage discipline to recover integrity
Basically, we attach to each object a label SHigh, SMed, or
SLow, which indicates a static lower bound on the integrity of the
contents of that object; further, we attach to each process a label
DHigh, DMed, or DLow, which indicates a dynamic lower bound
on the integrity of the values known to that process. The seman-
tics of these labels are maintained as invariants by the model. In
particular, these labels are initialized as follows.
new Obj,Low,SLow.
new Obj,Med,SMed.
new Obj,High,SHigh.
next P(x),DHigh(x) :- Obj(x).
...
Now, whenever an object’s IL is lowered, the IL should not fall
below the static label of the object.
next Low(y),!Med(y) :- Med(y),SLow(y),Med(x),P(x).
...
A process’s dynamic label may be lowered to reﬂect that it may
know the contents of an object with a lower static label.
next DLow(x),!DHigh(x) :- DHigh(x),SLow(y).
...
Now, a process x can Read an object y only if the dynamic label
of x is DSLeq (less than or equal to) the static label of y. Con-
versely, x can Write y only if the dynamic label of x is DSGeq
(greater than or equal to) the static label of y. In contrast, x can
Execute y only if its own IL is lowered to or below the static
label of y. This condition, SGeq(y, x), subsumes the earlier con-
dition Geq(y, x).
Read(x,y) :- P(x),Obj(y),DSLeq(x,y).
DSLeq(x,y) :- DLow(x),SLow(y).
DSLeq(x,y) :- DLow(x),SMed(y).
DSLeq(x,y) :- DMed(x),SMed(y).
...
Write(x,y) :- P(x),Obj(y),Geq(x,y),DSGeq(x,y).
DSGeq(x,y) :- DLow(x),SLow(y).
DSGeq(x,y) :- DMed(x),SMed(y).
DSGeq(x,y) :- DMed(x),SLow(y).
...
Execute(x,y) :- P(x),Obj(y),SGeq(y,x).
SGeq(y,x) :- SLow(y),Low(x).
SGeq(y,x) :- SMed(y),Low(x).
SGeq(y,x) :- SMed(y),Med(x).
...
Finally, recall the temporal queries that we ask above. We re-
formulate the former query for this model—instead of constraining
the IL of z, we now constrain its dynamic label, which is a better
approximation of its runtime taint.
? Med(y) ; Write(x,y),Low(x) ; Read(z,y),DMed(z).
This query evaluates to false, showing that the encoded data-ﬂow
integrity vulnerability cannot be exploited. The latter query also
evaluates to false, showing that the encoded privilege-escalation
vulnerability cannot be exploited. The full constrained model ap-