一般的堆栈溢出利用那样利用该漏洞了，这里不
号整数，假设提供一个负数的len，这样可以绕过[1]
再多讲。
的检测但是这个值同样被使用在[2]的mempy函数
尽管这样的例子在实际中几乎不出现，但它却
的参数里面，en可能被转换成一个非常大的正整
有效地演示了由整数溢出导致堆栈溢出的原理和过
淄客安全网WwW.176Ku.CoM
---
## Page 59
免责申请：本站所供资料仅供学习之用，任何人不得将之他用或者进行传播，否则应当自行向实际权利人承担法律责任。因本站部分资料
来源于其他媒介，如存在没有标注来激或来激标注错误导致侵犯阁下权利之处，敬请告知，我将立即予以处理。请购买正版书籍，支持国
内网络安全。
初级篇
《黑客防线）2009缓冲区溢出攻击与防范专辑
serfiee]
洞来说吧.除了上面的JPEG处理漏洞外，还有
Loadlmage API溢出漏润、PuTTY SFTP客户端包解
析整数澄出漏洞、camel-lock-helper整数溢出漏润
等.其中camel-lock-helper漏洞来自于Evolution，
这是一款类似MicrosoftOutlook的GNOME应用程
序，Evolution包含的camel-lock-helper应用程序存
rlu
在一个整数溢出，本地和远程攻击者可以利用这
个漏润获得“mai组特权，利用这个漏洞本地
攻击者可以提升特权，运程攻击者可以设置一恶
意POP服务器诱使用户使用Evolution连接，可导致
以”mai1组权限在系统上执行任意指令。而且
在Linux等其他操作系统下也有不少这样的漏润。
图3
下面简单介绍一下Loadmage API溢出漏洞的触发
3·用程序错误
原理。
内存，请内存不能
Windows的USER32库的Loadimage系统API存在
着整数溢出触发的缓冲区溢出漏洞，这个API允许加
载一个bmp.cur.ico.ani格式的图标来进行显示
并根据图片格式里说明的大小加4来进行数据的复
图4
制，如果将图片格式里说明的大小设置为oOxffic-
程，对于以后我们分析真实的漏润会有所帮助。
0x1fff.则将触发整数溢出导致堆缓冲区被覆盖。
攻击者可以构造恶意的bmg.curico.ani格式的文
由整数溢出导政的瑶滋出的示例代码如图5
功利用该漏洞则可获得系统的权限。
所示。
出的典型例子，相关技术细节如图6所示。
prigai
(n5ee) *6r 
%
eLE hrap - ipe
出导的康中区息，功者
可不的
图6
图5
小结
细心的读者很快就可以发现，上面这个例子
和PEG堆溢出漏润的原理其实差不多，当输入为1
大家平时都注重普通的缓冲区溢出，特别是堆
时.用于分配内存的参数sAlloc为-1.但unsigned
栈溢出技术，对于整数溢出等其他技术更多的是避
shart类型却无法识别负数，从而认为是正数fff
而不谈，本文的目的是和大家一起来对整数溢出有
分别了超大的内存块，从而覆盖了后面的堆管理
个初步的认识，因此讲得大多是基础性的东西，举
结构。
的例子也很简单，同时介绍了一些真实的整数溢出
翻开最近一年内的漏洞公告，发现关于整数
漏洞，有兴趣的朋友可以进行调试和利用，说不定
溢出方面的漏洞还真不少，就拿Windows下的漏
会有很多新发现。
ID
60）
淄客安全网WwW.176Ku.CoM
---
## Page 60
免责申请：本站所供资料仅供学习之用，任何人不得将之他用或者进行传播，否则应当自行向实际权利人承担法律责任。因本站部分资料
来源于其他媒介，如存在没有标注来激或来激标注错误导致侵犯阁下权利之处，敬请告知，我将立即予以处理。请购买正版书籍，支持国
内网络安全。
4《黑客防线）2009缓冲区溢出攻击与防范专辑
初级篇
溢出漏洞扫描技术
文/图军/daggai27
写了多篇溢出技术方面的文章，内容更多的是
率，因为很多软件升级之后以前的漏润就不存在
涉及调润调试、分析利用以及纯种的SnelICode编写
了，面升级之前的版本用户可能又疏于打调洞补
技巧，其实要掌握好一个溢出漏洞，漏洞的扫描技
丁.Serv_UMDTM溢出漏洞的扫描技术就是这样一个
术也是同样重要的，本文我将和大家一起来简单讨
例子，Serv_U5.0.0.9及以下版本都有这样的漏洞.而
论一下常见的溢出漏洞扫描技术，并结合新老两个
更高的版本则不存在，该漏洞比较老了，其扫描代
温洞例子SOLResolution溢出漏润和PNP溢出滑
码我这里不再呼嗦，有兴趣的朋友可以和我联系。
洞（MS05-039）分别讲解。
31直接爆破，将直接攻击作为扫描，如果攻
Windows下溢出漏洞扫描方法
击成功，则说明存在漏测，假设你无路可走，不妨
试试这一招，如果你只想做安全检测而不想破坏服
对于漏洞扫描我们常用的方法为以元儿种
务的话最好不步采用速种方式，否则直接攻击可
1）检测服务端日开故与否，这是最基本，也
能导致目标服务死掉，其实很多端虫不就是采用的
是准确率最低的一种方战直接向目标机器的指
w种方t76k1.com
端口发送带有SYN标志的TCP数据包，以检测端口是
4）根据安装补丁前后的响应报文的不同之处
否开放，如果端口开放，则认为漏洞存在，否则认
进行判断。这种方法最为安全、准确，实现难度也
为不存在调洞，在无法通过其他方式进行扫描的时
最大，要求分析者对漏洞白身的机制要很熟悉，很
候可以采用这种方法，我在写CCProxy溢出的漏洞扫
多存在漏洞的服务软件，在打补丁前后，我们发送
描代码的时候就是这样做的。
应用层请求后，返回的报文内容是有细微的差别
//选接目标机器808洁口
而我们恰恰就可以通过分析这一点点差别来判断溢
SOCKET codk:
出漏润的存在，我在写DCOMRPC、SOL
chock sckeAP_INET,SOCK_STREAM);
Resolution,LSAPNP等多数漏润的扫描都是这样头
dv -x uu
现的，大家可能要问了，这种方法的难点何在呢？
targit.sin adr.s adklr  dwDestlpx
其实难点就在于对特定服务的实现细节的理解和应
targct.sin_port = htons(808);
用层通信协议（特别是SMB.RPC等协议）的分析。
int ret conmect(csock. (sockaddr )&target, s
这部分做得不好的话，是写不出有效的Client
(target);
ifret - 0)
的。更多的时候我们很难清楚了解服务软件内部机
制，特别是对于微软的一些服务软件，这种情况之
prinCPy际目标机无
下，我们可以拿到别人的未公布源代码的扫描工
具，通过反汇编、跟踪分析网络数据包等方式进向
21获取服务软件的Banner信息，我们通过客户
还原出工具的代码，大家还没有能力对系统底层进
端与服务端进行连接的过程中，有时服务进程会返
行深入分析的时候，更多的采用这种方式是明智
回相关的Banner信息，这些信息里面包含了服务软件
的，只有知识一步步积累多了，我们才能做更加深
的版本等内容，通过Bame信息来判断服务软件是否
入的分析。
存在溢出漏洞是一种常用的方式，也有一定的准确
好了，光是纸上谈兵是没用的，我们还是来看
淄客安全网WwW.176Ku.CoM
---
## Page 61
免责申请：本站所供资料仅供学习之用，任何人不得将之他用或者进行传播，否则应当自行向实际权利人承担法律责任。因本站部分资料
来源于其他媒介，如存在没有标注来激或来激标注错误导致侵犯阁下权利之处，敬请告知，我将立即予以处理。请购买正版书籍，支持国
内网络安全。
初级篇
（黑客防线）2009缓冲区溢出攻击与防范专辑
看两个实际的例子吧。
名管道+RPC接口的形式向外提供服务的，也就是
SQI.和PNP漏洞扫描代码实现
说，要访问远程机器上的PNP服务，首先要通过TCP
139或445端口与目标机器建立IPC空连接，进而获取
SOL Servr 2000 SP2及以前的版本中的Resoltion
PNP服务进程中创建的命名管道“Browser的客户
服务存在漏洞，如果向服务主机UDP的1434端口发
端句柄，获取了管道句柄后，再通过该命名管道与
送以0x4开头的报文，则服务会返回当前运行的SQL
PNP服务进程中的RPC接口进行通信，完成对服务的
Serve实例，但如果发送的该报文长度过长，则发生
访问，在对PNP漏洞进行攻击的时候，通常是采用这
堆栈溢出，此外，如果发送其他格式的报文，例如
样一个通信流程，在漏润扫描的时候我们也可以按
以0xa开头的请求，则服务进程会将该请求作为错误
照这样一个步骤，由于我对SMB和RPC协议暂时还没
的请求报文处理，漏洞细节和利用我就不多说了
有完全分析清楚，所以填充的应用层数据包也是直
网上有现成的代码，这里我们来看看漏洞的扫描。
接从网络数据包中截获而来，而这些数据包呢，正
通过拦截数据包并分析，我们发现在打补丁前后
是在分析Mecfee公布的扫描工具时候得到的，通过
向服务进程发送错误请求（0xa开头的）后，返回的
分析，发现打补丁前后返回数据报内客刚好存在一
报文内容是不一样的，如果仍然逐回以0xs开头的报
个宁节的差别，呵呵，还原漏润扫描代码就易如反
文.则证明是存在漏润的，否则不存在漏润，主要
掌了。下面给出部分代码。
代码如下。
建立空连接：
建立空连接：
SOCKET CliemntSock;
//探润线程品款
sockaddr_in ClientAdr
UINT LitenThrsxPrc(LPVOID) pPram)
umsigned char szRecv[0x100e]
int lenc
ClientSock
socketCAF.INET.SOCK_STREAM
=[0
Total_Param *tgc
IPPROTO_TCP);
tp  (Total_Param *
AEINET:
SOCKADDR_IN Udptoc
安全
445
ing lo 445
int iError;
siCA）
if(sendtotpsock. tp>bufSend, siaoftp>bufSend)
0. (sockaddr)&tp>addr_in,sizeof(tp>addr_in))
printi(°Cann't coonecting to 445
SOCKET_ERROR)
ClientAddrsn_pothos（139)
or wsAGetLastrr:
(Cliock(c sckadr&CliAd
co(ClientAddr) bufRecv);
Int n recrotpsock, pbufecv, siaoftp->
ifsend(CSSock, (cnt char +)NBSS, siaof(qBSS)
//发进72节的reqN5SS
bue), 0 (sckar &Udrm &U
(0>（01
in > 0 && (p>bfRe0] --xa
/ /printf(*%s\i". tp>bufReev),
p ssu p d
tpvulnele  te
closesocket(CllentSodk);
brak; 1
retum-l;
1
km ev(ClitSodk, (car oev, olieRev)  1. )
retum 0;
ifUem < 0)
printf(°2n);
这个漏洞的扫描代码实现起来很简单，大家可
以直接提取上面的代码。
relum-1: