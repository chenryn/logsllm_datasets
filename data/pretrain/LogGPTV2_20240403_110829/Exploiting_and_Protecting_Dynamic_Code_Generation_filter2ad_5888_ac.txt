(DOM). Since many vulnerabilities exist within the rendering
engine rather than the JS engine, this means only the main
thread (which has the access to the DOM) can exploit those
vulnerabilities.
4) Reliability of the Race Condition: One important ques-
tion for any race-condition-based attack is its reliability. The
6
ﬁrst factor that can affect
the reliability of our attack is
synchronization, i.e., the synchronization primitive should be
fast enough so that the two threads can carry out the attack
within the relatively small attack window. To measure the
speed of the synchronization between the worker and the main
thread, we ran another simple experiment:
safety to a large, complex program (e.g., a web browser) would
be very high. Second, implementing the ﬁrst choice requires
signiﬁcant engineering effort.
i) The main thread creates a worker thread;
ii) The worker thread gets a timestamp and sends it to the
iii) Upon receiving the message, the main thread sends an
iv) Upon receiving the message, the worker thread sends back
main thread;
echo to the worker;
an echo;
v) The main thread and the worker repeatedly send echoes
vi) The main thread obtains another timestamp and computes
to each other 1,000 times.
the time difference.
The result shows that the average synchronization delay is
around 23 µs. The average attack window (t2−t1 in Figure 2)
of our ﬁne-grained naive W⊕X protection is about 43 µs. Thus,
in theory, the postMessage method is sufﬁciently fast to
launch a race condition attack.
The second and more important factor that can affect the
reliability of our attack is task scheduling. Speciﬁcally, if the
thread under the SDT context (e.g., the worker thread) is de-
scheduled by the OS while the attacking thread (e.g., the main
thread) is executing, then the attack window will be increased.
The only way to change the code cache’s memory permission
is through a system call, and a context switch is likely to
happen during the system call. For example, the system call for
changing memory access permissions on Linux is mprotect.
During the invocation of mprotect, since we are using ﬁne-
grained protection, the virtual memory area needs to be split
or merged. This will trigger the thread to be de-scheduled. As
a result, the main thread (with higher priority than the worker)
can gain control to launch attacks.
Considering these two factors, we tested our attack against
the Chrome browser 100 times. Of these 100 tests, 91 suc-
ceeded.
IV. SYSTEM DESIGN
In this section, we present the design of SDCG. We have
two design goals: 1) SDCG should prevent all possible code
injection attacks against the code cache under our adversary
model; and 2) SDCG should introduce acceptable performance
overhead. In addition, SDCG is designed to be integrated with
the targeted SDT, and we assume that the source code of the
SDT is available.
A. Overview and Challenges
Since the root cause of the attack is a writable code
cache (either permanently or temporarily), we can prevent
such attacks making one of two design choices: 1) ensure
that nothing but the SDT can write to the code cache, e.g.,
through SFI or memory safety; and 2) ensure that the memory
occupied by the code cache is always mapped as RX. We
selected the second option for two reasons. First, we expect
that the performance overhead of applying SFI or memory
7
Fig. 3: Overview of SDCG’s multi-process-based architecture.
The gray memory areas are shared memory, others are mapped
as private (copy-on-write). Depending on the requirement, the
SDT’s code and data can be mapped differently.
Figure 3 shows the high level design of SDCG. The key
idea is that through shared memory, the same memory content
will be mapped into two (or more) different processes, with
different access permissions. In the untrusted process(es), the
code cache will be mapped as RX; but in the SDT process,
it will be mapped as WR. By doing so, SDCG prevents any
untrusted code from modifying the code cache. At the same
time, it allows the SDT to modify the code cache as usual.
Whenever the SDT needs to be invoked (e.g., to install a new
code fragment), the request will be served through a remote
procedure call (RPC) instead of a normal function call.
To build and maintain this memory model, we need to solve
following technical and engineering challenges. the
i) Memory Map Synchronization. Since the memory regions
occupied by the code cache are dynamically allocated and
can grow and shrink freely, we need an effective way
to dynamically synchronize memory mapping between
the untrusted process(es) and the SDT process. More
importantly, to make SDCG’s protection mechanism work
transparently, we have to make sure that the memory
is mapped at exactly the same virtual address in all
processes.
ii) Remote Procedure Call. After relocating the SDT to
another process, we need to make it remotely invocable by
wrapping former local invocations with RPC stubs. Since
RPC is expensive, we need to reduce the frequency of
invocations, which also reduces the attack surface.
iii) Permission Enforcement. Since SDCG’s protection is based
on memory access permissions, we must make sure that
untrusted code cannot tamper with our permission scheme.
Speciﬁcally, memory content can be mapped as either
writable or executable, but never both at the same time.
B. Memory Map Synchronization
Synchronizing memory mapping between the untrusted
process(es) and the SDT process is a bi-directional issue. On
one hand, when the SDT allocates a new code fragment in the
SDT process, we should map the same memory region in the
untrusted process(es) at exactly the same address; otherwise
the translated code will not work correctly (e.g., create an
incorrect branching target). On the other hand, the untrusted
process may also allocate some resources that are critical to
the SDT. For example, in the scenario of binary translation,
when the untrusted process loads a dynamically linked module,
we should also load the same module at the same address
in the SDT process; otherwise the SDT will not be able to
locate the correct code to be translated. Moreover, we want this
synchronization to be as transparent to the SDT as possible,
to minimize code changes.
When creating shared memory,
there are two possible
strategies: on-demand and reservation-based. On-demand map-
ping creates the shared memory at the very moment a new
memory region is required, e.g., when the SDT wants to add
a new memory region to the code cache. However, as the
process address space is shared by all modules of a program,
the expected address may not always be available in both
the untrusted process and the SDT process. For this reason,
we choose the reservation-based strategy. That is, when the
process is initialized, we reserve (map) a large chunk of
shared memory in both the untrusted process(es) and the SDT
process. Later, any request for shared memory will be allocated
from this shared memory pool. Note that in modern operating
systems, physical memory resources are not mapped until the
reserved memory is accessed, so our reservation-based strategy
does not impose signiﬁcant memory overhead.
Once the shared memory pool is created, synchronization
can be done via inter-process communication (IPC). Specif-
ically, when the SDT allocates a new memory region for
the code cache, it informs the untrusted process(es) about
the base address and the size of this new memory region.
Having received this event, the untrusted process(es) maps a
memory region with the same size at the same base address
with the expected permission (RX). Similarly, whenever the
untrusted process allocates memory that needs to be shared, a
synchronization event is sent to the SDT process.
C. Remote Procedure Call
Writing RPC stubs for the SDT faces two problems:
argument passing and performance. Argument passing can
be problematic because of pointers. If a pointer points to a
memory location that is different between the untrusted process
and the SDT process, then the SDT ends up using incorrect
data and causes run-time errors. Vice versa, if the returned
value from the SDT process contains pointers that point to
data not copied back, the untrusted code ends up running
incorrectly. One possible solution for the stub to serialize
the object before passing it to the remote process instead of
simply passing the pointer. Unfortunately, not all arguments
have built-in serialization functionality. In addition, when
an argument is a large object, performing serialization and
copy for every RPC invocation introduces high performance
overhead. Thus, in general, stub generation is not easy without
support from the SDT or from program analysis.
To avoid this problem, SDCG takes a more systematic ap-
proach. Speciﬁcally, based on the observation that a majority of
data that the SDT depends on is either read-only or resides in
dynamically mapped memory, we extend the shared memory to
also include the dynamic data the SDT depends on. According
to the required security guarantee, the data should be mapped
with different permissions. By default, SDCG maps the SDT’s
dynamic data as read-only in the untrusted process, to prevent
tampering by the untrusted code. However, if non-control data
attacks are not considered, the SDT’s dynamic data can be
mapped as WR in the untrusted process. After sharing the data,
we only need to handle a few cases where writable data (e.g.,
pointers within global variables) is not shared/synchronized.
Since RPC invocations are much more expensive than
normal function calls, we want to minimize the frequency
of RPC invocation. To do so, we take a passive approach.
That is, we do not convert an entry from the SDT to RPC
unless it modiﬁes the code cache. Again, we try to achieve
this goal without involving heavy program analysis. Instead,
we leverage the regression tests that are usually distributed
along with the source code. More speciﬁcally, we begin with
no entries being converted to RPC and gradually convert them
until all regression tests pass.
While our approach can be improved with more automation
and program analysis, we leave these as future work because
our main goal here is to design and validate that our solution
is effective against the new code cache injection attacks.
D. Permission Enforcement
To enforce mandatory W⊕X, we leverage the delegation-
based sandbox architecture [21]. Speciﬁcally, we intercept
all system calls related to virtual memory management, and
enforce the following policies in the SDT process:
(I) Memory can not be mapped as both writable and exe-
(II) When mapping a memory region as executable, the base
address and the size must come from the SDT process,
and the memory is always mapped as RX.
(III) The permission of non-writable memory cannot be
cutable.
changed.
E. Security Analysis
In this section, we analyze the security of SDCG under
our threat model. First, we show that our design can enforce
permanent W⊕X policy. The ﬁrst system call policy ensures
that attackers cannot map memory that is both writable and
executable. The second policy ensures that attackers cannot
switch memory from non-executable to executable. The combi-
nation of these two policies guarantees that no memory content
can be mapped as both writable and executable, either at the
same time or alternately. Next, the last policy ensures that if
there is critical data that the SDT depends on, it cannot be
modiﬁed by attackers. Finally, since the SDT is trusted and
its data is protected, the second policy can further ensure that
only SDT-veriﬁed content (e.g., code generated by the SDT)
can be executable. As a result, SDCG can prevent any code
injection attack.
8
V.
IMPLEMENTATION
We implemented two prototypes of SDCG, one for the
Google V8 JS engine [24], and the other for the Strata
DBT [48]. Both prototypes were implemented on Linux. We
chose these two SDTs for the following reasons. First, JS
engines are one of the most widely deployed SDTs. At the
same time, they are also one of the most popular stepping
stones for launching attacks. Among all JS engines, we chose
V8 because it is open source, highly ranked, and there is
a disclosed exploit [43]. Second, DBTs have been widely
used by security researchers to build various security solu-
tions [8, 12, 25, 26, 36]. Among all DBTs, we chose Strata
because 1) it has been used to implement many promising se-
curity mechanisms, such as instruction set randomization [26],
instruction layout randomization [25], etc.; and 2) its academic
background allowed us to have access to its source code, which
is required for implementation of SDCG.
A. Shared Infrastructure
The memory synchronization and system call ﬁltering
mechanisms are speciﬁc to the target platform, but they can
be shared among all SDTs.
1) Seccomp-Sandbox: Our delegation-based sandbox is
built upon the seccomp-sandbox [22] from Google Chrome.
Although Google Chrome has switched to a less complicated
process sandbox based on seccomp-bpf [1], we found that
the architecture of seccomp-sandbox serves our goal better.
Speciﬁcally, since seccomp only allows four system calls once
enabled, and not all system calls can be fulﬁlled by the broker
(e.g., mmap), the seccomp-sandbox introduced a trusted thread
to perform system calls that cannot be delegated to the broker.
To prevent attacks on the trusted thread, the trusted thread
operates entirely on CPU registers and does not trust any
memory that is writable to the untrusted code. When the trusted
thread makes a system call, the system call parameters are
ﬁrst veriﬁed by the broker, and then passed through a shared
memory that is mapped as read-only in the untrusted process.
As a result, even if the other threads in the same process are
compromised, they cannot affect the execution of the trusted
thread. This provides a perfect foundation to securely build our
memory synchronization mechanism and system call ﬁltering
mechanism.
To enforce the mandatory W⊕X policy, we modiﬁed the
sandbox so that before entering sandbox mode, SDCG enu-
merates all memory regions and converts any WRX region to
RX.
For RPC invocation, we also reused seccomp-sandbox’s
domain socket based communication channel. However, we did
not leverage the seccomp mode in our current implementation
for several reasons. First, it is not compatible with the new
seccomp-bpf-based sandbox used in Google Chrome. Second,
it intercepts too many system calls that are not required by
SDCG. More importantly, both Strata and seccomp-bpf provide
enough capability for system call ﬁltering.
2) Shared Memory Pool: During initialization, SDCG re-
serves a large amount of consecutive memory as a pool. This
pool is mapped as shared (MAP_SHARED), not ﬁle backed
(MAP_ANONYMOUS) and with no permission (PROT_NONE).
After this, any mmap request from the SDT allocates memory
from this pool (by changing the access permission) instead
of using the mmap system call. This guarantees any SDT
allocated region can be mapped at exactly the same address in
both the SDT process and the untrusted process(es).
After the sandbox is enabled, whenever the SDT calls
mmap, SDCG generates a synchronized request
to the un-
trusted process(es), and waits until the synchronization is done
before returning to the SDT. In the untrusted process, the
synchronization event is handled by the trusted thread. It reads
a synchronization request from the IPC channel and then
changes the access permission of the given region to the given
value. Since the parameters (base address, size and permission)
are passed through the read-only IPC channel and the trusted
thread does not use a stack, it satisﬁes our security policy for
mapping executable memory.
Memory mapping in the untrusted process(es) is forwarded
to the SDT process by the system call interception mechanism
of the sandbox. The request ﬁrst goes through system call
ﬁltering to ensure the security policy is enforced. SDCG then
checks where the request originated. If the request is from
the SDT, or is a special resource the SDT depends on (e.g.,
mapping new modules needs to be synchronized for Strata),
the request is fulﬁlled from the shared memory pool. If it is
a legitimate request from the untrusted code, the request is
fulﬁlled normally.
3) System Call Filtering: SDCG rejects the following types
of system calls.
(PROT_EXEC) permission.
a protected memory region.
• mmap with writable (PROT_WRITE) and executable
• mprotect or mremap when the target region falls into
• mprotect with executable (PROT_EXEC) permission.
SDCG maintains a list of protected memory regions. After
the SDT process is forked, it enumerates the memory mapping
list
is
executable is included in the list. During runtime, when a new
executable region is created, it is added to the list; when a
region is unmapped, it is removed from the list. If necessary,
the SDT’s dynamic data can also be added to this list.
through /proc/self/maps, and any region that
For Strata, this ﬁltering is implemented by intercepting the
related system calls (mmap, mremap, and mprotect). For
V8 (integrated with the Google Chrome browser), we rely on
the seccomp-bpf ﬁltering policies.