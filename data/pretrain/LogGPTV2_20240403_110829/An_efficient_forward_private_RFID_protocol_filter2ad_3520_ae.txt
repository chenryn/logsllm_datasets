Thus, for any ﬁxed a, the occurrence probability pa of a
collision involving Tj veriﬁes pa ≤ (N − 1)ω22−m + N ωg
and so pc ≤ (N − 1)ω22−m + N ωg, which implies:
p ≤ (N − 1)ω22
−m + N ωg + ω(g + 2
−l + (1 + 2q)) ,
and concludes the proof.
6.
IMPLEMENTING PFP EFFICIENTLY
The previous section not only proved that cryptographic
hash functions are not mandatory to design forward private
protocols but also provided concrete security bounds in the
standard model. This allows to select practical instances of
both pseudo-random number generators and universal hash
functions families to meet the security requirements at a
very low implementation cost. This section discusses some
natural choices for the instantiation of these two primitives.
6.1 Efﬁcient number generators
Recent developments in stream ciphers brought by the
eSTREAM project [13] led to various eﬃcient designs to
choose from. A detailed survey of the diﬀerent designs from
the hardware eﬃciency point of view is available in [16].
50Grain v1, Trivium, and Decim seem to be among the most
promising. Grain v1 uses 1294 GE, Trivium needs 2580 GE,
and Decim80 requires 2603 GE, all reaching a security level
of 80 bit. Note that since only a PRNG (or equivalently an
IV-less stream cipher) is needed here, it is not required to
implement the key and IV loading of such stream ciphers.
This allows to achieve some savings in the gate complexity
and to use a PRNG input size of 160 bits.
m−1, vc
1, v0, vr
1, . . . , vr
1, . . . , vc
1, . . . , vr
m−2, . . . , vc
A few PRNGs also exist with security proofs together with
eﬃcient implementations. Let us mention the PRNG under-
lying QUAD [8] which allows hardware implementations in
less than 3000 GE for a security level of 80 bits, see [1].
6.2 Efﬁcient universal hash functions
An m×l Toeplitz matrix M is a matrix which entries Mi,j
verify Mi1,j1 = Mi2,j2 for indices such that i2 − i1 = j2 − j1.
(That is, all elements in the same diagonal are identical.)
Hence a Toeplitz matrix can be speciﬁed by its top row
and its ﬁrst column alone. To any (l + m − 1)-bit vector
v = (vc
l−1), we associate the
Toeplitz matrix Tv with ﬁrst row (v0, vr
l−1) and ﬁrst
column (v0, vc
m−1). It is well known [25] that Toeplitz
mappings {x (cid:55)→ Tv(x)}v∈{0,1}l+m−1 form a universal family
of hash functions and {x (cid:55)→ Tv(x)+w}v∈{0,1}l+m−1,w∈{0,1}m
forms a strongly universal family of hash functions.
Given v ∈ {0, 1}l+m−1 and w ∈ {0, 1}m, the computa-
tion of Tvx ⊕ w for x ∈ {0, 1}l can implemented using a
shift-register that describes successively each column of the
matrix Tv and an accumulator which originally contains w.
Depending on the bits of the public value x, the current
column of Tv is accumulated into w or not. This strategy
requires m clock cycles, 12(m + l − 1) GE to implement the
shift-register, and 12m GE for the accumulator.
6.3 Typical parameter values
Let us roughly estimate typical orders of magnitude for
the parameters of the proposed RFID scheme: N ≈ 220 le-
gitimate tags, q ≈ 225 maximum authentication exchanges
launched (and potentially disturbed) by an adversary, and
ω ≈ 228 maximum (disturbed or undisturbed) authentica-
tions in the lifetime of a tag can be claimed to represent re-
alistic values if we consider that an authentication exchange
typically takes more than 0.1s and discard attacks requiring
more than a year of continuous authentication exchanges of a
single tag. Our security theorems indicate that if the PRNG
is strong enough and we consider adversaries of computing
time upper-bounded by T ≈ 280, Toeplitz matrix sizes such
as m = 86 and l = 38 lead to correctness, security, and pri-
vacy levels c, s, and p upper bounded by 2−10, and to an
order of magnitude of 2500 GE for the Toeplitz matrix com-
putations. This leads to an overall gate count of less than
4000 GE including the PRNG computations if the stream ci-
pher Grain v1 is used. Slightly less conservative parameter
values lead to an overall complexity of about 3000 GE.
7. CONCLUSION
We introduced a low-footprint privacy preserving RFID
authentication protocol supported by strong provable secu-
rity arguments. Our construction is based on less complex
cryptographic building blocks than previous RFID proto-
cols, and represents another illustration—in a context that
has little to do with the well known example of Carter-
Wegman message authentication codes—of the advantages
that may result, both in theoretical and practical terms,
from the combined use of a strongly (or almost strongly) uni-
versal hash functions family and a computationally secure
component such as a pseudo-random number generator.
8. REFERENCES
[1] D. Arditti, C. Berbain, O. Billet, and H. Gilbert.
Compact FPGA implementations of QUAD. In F. Bao
and S. Miller, editors, ASIACCS 2007. ACM, 2007.
[2] Auto-ID Center. 860MHz 960MHz Class I Radio
Frequency Identiﬁcation Tag Radio Frequency&
Logical Communication Interface Speciﬁcation, v1.0.0.
Research Report MIT-AUTOID-TR-007, 2002.
[3] G. Avoine. Privacy Issues in RFID Banknote
Protection Schemes. In J.-J. Quisquater, P. Paradinas,
Y. Deswarte, and A. Abou El Kadam, editors,
CARDIS 2004, pages 33–48. Kluwer, 2004.
[4] G. Avoine. Adversarial model for radio frequency
identiﬁcation. Cryptology ePrint Archive, Report
2005/049, http://eprint.iacr.org/, 2005.
[5] G. Avoine, E. Dysli, and P. Oechslin. Reducing Time
Complexity in RFID Systems. In B. Preneel and
S. Tavares, editors, SAC 2005, LNCS. Springer, 2005.
[6] G. Avoine and P. Oechslin. A Scalable and Provably
Secure Hash Based RFID Protocol. In PerSec 2005.
IEEE Computer Society Press, 2005.
[7] G. Avoine and P. Oechslin. RFID traceability: A
multilayer problem. In A. Patrick and M. Yung,
editors, FC’05, LNCS. Springer, 2005.
[8] C. Berbain, H. Gilbert, and J. Patarin. QUAD: A
Practical Stream Cipher with Provable Security. In
S. Vaudenay, editor, EUROCRYPT 2006, LNCS.
Springer, 2006.
[9] S. Canard and I. Coisel. Data Synchronization in
Privacy-Preserving RFID Authentication Schemes. In
Conference on RFID Security, 2008.
[10] CASPIAN. http://www.spychips.com.
[11] I. Damg˚ard and M. Østergaard. RFID Security:
Tradeoﬀs between Security and Eﬃciency. Cryptology
ePrint Archive, Report 2006/234, 2006.
[12] T. Dimitriou. A Lightweight RFID Protocol to protect
against Traceability and Cloning attacks. In
SECURECOMM ’05. IEEE Computer Society, 2005.
[13] ECRYPT. The eSTREAM Project, 2008.
http://www.ecrypt.eu.org/stream/index.html.
[14] Electronic Product Code Global Inc.
http://www.epcglobalinc.com.
[15] M. Feldhofer and C. Rechberger. A Case Against
Currently Used Hash Functions in RFID Protocols. In
R. Meersman, Z. Tari, and P. Herrero, editors,
OTM 2006, volume 4277 of LNCS. Springer, 2006.
[16] T. Good and M. Benaissa. Asic hardware performance.
In M. Robshaw and O. Billet, editors, New Stream
Cipher Designs, LNCS, pages 267–293. Springer, 2008.
[17] M. Hellman. A Cryptanalytic Time-Memory
Trade-Oﬀ. IEEE Transactions on Information Theory,
26(4):401–406, July 1980.
[18] J. E. Hennig, P. B. Ladkin, and B. Sieker. Privacy
Enhancing Technology Concepts for RFID Technology
Scrutinised. RVS-RR-04-02, Univ. of Bielefeld, 2004.
[19] D. Henrici and P. Muller. Hash-based Enhancement of
51Location Privacy for Radio-Frequency Identiﬁcation
Devices using Varying Identiﬁers. In Pervasive
Computing and Communications Workshops, 2004.
[20] International Organisation for Standardisation.
http://www.iso.org.
[21] A. Juels. Minimalist Cryptography for Low-Cost
RFID Tags. In SCN 2004, LNCS. Springer, 2004.
[22] A. Juels and R. Pappu. Squealing Euros: Privacy
Protection in RFID-Enabled Banknotes. In R. N.
Wright, editor, FC ’03, LNCS. Springer, 2003.
[23] A. Juels, R. Rivest, and M. Szydlo. The Blocker Tag:
Selective Blocking of RFID Tags for Consumer
Privacy. In V. Atluri, editor, ACM CCS, 2003.
[24] A. Juels and S. Weis. Deﬁning strong privacy for
RFID. Cryptology ePrint Archive, Report 2006/137.
[25] Y. Mansour, N. Nisan, and P. Tiwari. The
computational complexity of universal hashing. In
STOC ’90, pages 235–243. ACM, 1990.
[26] D. Molnar and D. Wagner. Privacy and security in
library RFID: Issues, practices, and architectures. In
B. Pﬁtzmann and P. Liu, editors, ACM CCS, pages
210–219. ACM Press, 2004.
[27] P. Oechslin. Making a faster cryptanalytic
time-memory trade-oﬀ. In D. Boneh, editor,
CRYPTO 2003, volume 2729 of LNCS. Springer, 2003.
[28] O.Goldreich and L.Levin. A hard-core predicate for all
one way-functions. In STOC. ACM press, 1989.
[29] M. Ohkubo, K. Suzuki, and S. Kinoshita.
Cryptographic Approach to “Privacy-Friendly” Tags.
In RFID Privacy Workshop, 2003.
[30] M. Ohkubo, K. Suzuki, and S. Kinoshita. Eﬃcient
hash-chain based RFID privacy protection scheme. In
Ubiquitous Computing – Privacy Workshop, 2004.
[31] M. Robshaw and O. Billet, editors. New Stream Cipher
Designs: The eSTREAM Finalists. Springer, 2008.
[32] Stop RFID. http://www.stoprfid.de/en/.
[33] S. Vaudenay. On Privacy Models for RFID. In
K. Kurosawa, editor, ASIACRYPT 2007, volume 4833
of LNCS, pages 68–87. Springer, 2007.
[34] S. Weis, S. Sarma, R. Rivest, and D. Engels. Security
and Privacy Aspects of Low-Cost Radio Frequency
Identiﬁcation Systems. In D. Hutter, G. M¨uller,
W. Stephan, and M. Ullmann, editors, SPC 2003,
LNCS. Springer, 2003.
[35] J. Wolkerstorfer, S. Dominikus, and M. Feldhofer.
Strong authentication for RFID systems using the
AES algorithm. In M. Joye and J.-J. Quisquater,
editors, CHES 2004, LNCS. Springer, 2004.
APPENDIX
A. PROOF OF THEOREM 1
We prove Theorem 1 by showing that, if for a given λ ≥ 1
there exists an algorithm A able to distinguish the genera-
tor Gλ associated with λ iterations of g in time T (cid:48) with an
advantage of at least , then there is an algorithm B able to
distinguish the generator g with an advantage of at least 
and in time lower than T (cid:48) + (λ + 1)Tg. We use a classical
λ
proof technique relying on hybrid probability distributions.
For 0 ≤ i ≤ λ, let Di be the probability distribution over
1
1
(x)), gi
1(x)), . . . , g2(gi−1
1(x)), . . . , g2(gi−1
{0, 1}n+λm associated with the random variables
F i(x) =`r1, . . . , rλ−i, g2(g0
`g2(g0
1(x)´ ,
(x))´ is the empty string for i = 0.
where the rj and x are random and independent uniformly
distributed values of {0, 1}(k−1)n and {0, 1}n respectively.
By convention, (r1, . . . , rλ−i) is the empty string for i = λ,
We see that D0 is the uniform distribution over {0, 1}n+λm,
Dλ is the output distribution of Gλ, and the Di are inter-
mediate between D0 and Dλ. Let pi denote the probabil-
ity that A accepts an input sequence distributed according
to Di. The hypothesis about algorithm A amounts to as-
suming that A distinguishes between D0 and Dλ with an
advantage of , in other words that |p0 − pλ| ≥ .
On input (u, v) ∈ {0, 1}n×{0, 1}m, algorithm B randomly
selects an integer i such that 0 ≤ i ≤ λ − 1 and constructs
the n + λm-bit vector Z(u, v) deﬁned as:
1(u)), . . . , g2(gi−1
`r1, . . . , rλ−i−1, v, g2(g0
1(u)´ .
(u)), gi
1
If (u, v) is distributed according to the uniform distribution,
then Z(u, v) is distributed according to Di. On the other
hand, if (u, v) is distributed according to the output dis-
tribution of g, that is (u, v) = g(x) = (g1(x), g2(x)) for a
uniformly distributed value x, then Z(u, v) reads
(x)´
`r1, . . . , rλ−i, g2(g0
1(x)), . . . , g2(gi
1(x)), gi+1
1
and is distributed according to Di+1.
˛˛Pru,v
In order to distinguish the output distribution of g from
the uniform distribution, algorithm B calls algorithm A with
input Z(u, v) and outputs the value returned by A. Hence
ˆB(g(x)) = 1˜˛˛ can be written as
ˆB(u, v) = 1˜ − Prx
˛˛˛˛˛ =
˛˛˛˛˛ 1
λX
|p0 − pλ| ≥ 
λ
pi − 1
λ
λ−1X
1
λ