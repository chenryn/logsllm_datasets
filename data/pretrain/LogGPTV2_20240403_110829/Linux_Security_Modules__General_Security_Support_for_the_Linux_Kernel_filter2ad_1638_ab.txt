nel may create function would be insufﬁcient since it
would still lack precise information about the type of op-
eration and the mode. Hence, a hook was inserted with
the same interface as the corresponding inode operation.
An alternative to inserting these two hooks into
vfs mkdir would be to interpose on the dir->i op-
>mkdir call. Interposing on internal kernel interfaces
would provide equivalent functionality for some of the
LSM hooks. However, such interposition would also
permit much more general functionality to be imple-
mented via kernel modules. Since kernel modules have
historically been allowed to use licenses other than the
GPL, an approach based on interposition would likely
create political challenges to the acceptance of LSM by
the Linux kernel developers.
4.1.2 Calls to Security Hook Functions
As discussed in the previous subsection, LSM provides
a set of calls to security hooks to manage the security
ﬁelds of kernel objects. It also provides a set of calls to
security hooks to mediate access to these objects. Both
sets of hook functions are called via function pointers in
a global security ops table. This structure consists
of a collection of substructures that group related hooks
based on kernel object or subsystem, as well as some
top-level hooks for system operations. Each hook is de-
ﬁned in terms of kernel objects and parameters, and care
has been taken to avoid userspace pointers.
Figure 3 shows the vfs mkdir kernel function after the
4.1.3 Security System Call
LSM provides a general security system call that
allows security modules to implement new calls for
security-aware applications. Although modules can ex-
port information and operations via the /proc ﬁlesys-
tem or by deﬁning a new pseudo ﬁlesystem type, such
an approach is inadequate for the needs of some security
modules. For example, the SELinux module provides
extended forms of a number of existing system calls that
permit applications to specify or obtain security infor-
mation associated with kernel objects and operations.
The security system call
plexor
fashioned after
etcall system call.
is a simple multi-
the existing Linux sock-
It
takes the following ar-
guments: (unsigned int id, unsigned int
call, unsigned long *args). Since the mod-
ule deﬁnes the implementation of the system call, it can
choose to interpret the arguments however it likes. These
arguments are intended to be interpreted by the modules
as a module identiﬁer, a call identiﬁer, and an argument
array. By default, LSM provides a sys security en-
try point function that simply calls a sys security
hook with the parameters. A security module that does
not provide any new calls can deﬁne a sys security
hook function that returns -ENOSYS. Most security
modules that want to provide new calls can place their
call implementations in this hook function.
In some cases, the entry point function provided by LSM
may be inadequate for a security module. For example,
one of the new calls provided by SELinux requires ac-
cess to the registers on the stack. The SELinux module
implements its own entry point function to provide such
access, and replaces the LSM entry point function with
this function in the system call table during module ini-
tialization.
4.1.4 Registering Security Modules
The LSM framework is initialized during the kernel’s
boot sequence with a set of dummy hook functions that
enforce traditional UNIX superuser semantics. When a
security module is loaded, it must register itself with the
LSM framework by calling the register security
function. This function sets the global security ops
table to refer to the module’s hook function pointers,
causing the kernel to call into the security module for
access control decisions. The register security
function will not overwrite a previously loaded module.
Once a security module is loaded, it becomes a policy
decision whether it will allow itself to be unloaded.
If a security module is unloaded, it must unregister with
the framework using unregister security. This
simply replaces the hook functions with the defaults so
the system will still have some basic means for security.
The default hook functions do not use the opaque secu-
rity ﬁelds, so the system’s security should not be com-
promised if the module does a poor job of resetting the
opaque ﬁelds.
As mentioned in Section 3, general composition of poli-
cies is intractable. While arbitrary policy composition
gives undeﬁned results, it is possible to develop secu-
rity modules such that they can compose with deﬁned
results. To keep the framework simple, it is aware of
only one module, either the default or the registered
module – the primary module. A security module may
register itself directly with the primary module using
the mod reg security interface. This registration is
controlled by the primary module, so it is a policy deci-
sion whether to allow module stacking. With this simple
interface, basic module stacking can be supported with
no complexity in the framework.
4.1.5 Capabilities
The Linux kernel currently provides support for a sub-
set of POSIX.1e capabilities. One of the requirements
for the LSM project was to move this functionality to
an optional security module, as mentioned in Section 2.
POSIX.1e capabilities provides a mechanism for par-
titioning traditional superuser privileges and assigning
them to particular processes.
By nature, privilege granting is a permissive form of ac-
cess control, since it grants an access that would ordi-
narily be denied. Consequently, the LSM framework
had to provide a permissive interface with at least the
same granularity of the Linux capabilities implementa-
tion. LSM retains the existing capable interface used
within the kernel for performing capability checks, but
reduces the capable function to a simple wrapper for
a LSM hook, allowing any desired logic to be imple-
mented in the security module. This approach allowed
LSM to leverage the numerous (more than 500) existing
kernel calls to capable and to avoid pervasive changes
to the kernel. LSM also deﬁnes hooks to allow the
logic for other forms of capability checking and capabil-
ity computations to be encapsulated within the security
module.
A process capability set, a simple bit vector, is stored
in the task struct structure. Because LSM adds an
opaque security ﬁeld to the task struct and hooks
to manage the ﬁeld, it would be possible to move the
existing bit vector into the ﬁeld. Such a change would
be logical under the LSM framework but this change
has not been implemented in order to ease stacking with
other modules. One of the difﬁculties of stacking se-
curity modules in the LSM framework is the need to
share the opaque security ﬁelds. Many security modules
will want to stack with the capabilities module, because
the capabilities logic has been integrated into the main-
stream kernel for some time and is relied upon by some
applications such as named and sendmail. Leaving
the capability bit vector in the task struct eases this
composition at the cost of wasted space for modules that
don’t need to use it.
The Linux kernel support for capabilities also includes
two system call calls: capset and capget. To remain
compatible with existing applications, these system calls
are retained by LSM but the core capabilities logic for
these functions has been replaced by calls to LSM hooks.
Ultimately, these calls should be reimplemented via the
security system call. This change should have little
impact on applications since the portable interface for
capabilities is through the libcap library rather than
direct use of these calls.
The LSM project has developed a capabilities security
module and migrated much of the core capabilities logic
into it; however, the kernel still shows vestiges of the
pre-existing Linux capabilities. Moving the bit vector
from the task struct proper to the opaque security
ﬁeld and relocating the system call interface are the only
major steps left to making the capability module com-
pletely standalone.
4.2 Task Hooks
LSM provides a set of task hooks that enable security
modules to manage process security information and to
control process operations. Modules can maintain pro-
cess security information using the security ﬁeld of the
task struct structure. Task hooks provide control
over inter-process operations, such as kill, as well as
control over privileged operations on the current pro-
cess, such as setuid. The task hooks also provide
ﬁne-grained control over resource management opera-
tions such as setrlimit and nice.
4.3 Program Loading Hooks
Many security modules, including Linux capabilities,
DTE, SELinux, and SubDomain require the ability to
perform changes in privilege when a new program is ex-
ecuted. Consequently, LSM provides a set of program-
loading hooks that are called at critical points during
the processing of an execve operation. The security
ﬁeld of the linux binprm structure permits modules
to maintain security information during program load-
ing. One hook is provided to permit security modules to
initialize this security information and to perform access
control prior to loading the program, and a second hook
is provided to permit modules to update the task security
information after the new program has been successfully
loaded. These hooks can also be used to control inher-
itance of state across program executions, for example,
revalidating open ﬁle descriptors.
4.4
IPC Hooks
Security modules can manage security information and
perform access control for System V IPC using the LSM
IPC hooks. The IPC object data structures share a com-
mon substructure, kern ipc perm, and only a pointer
to this substructure is passed to the existing ipcperms
function for checking permissions. Hence, LSM adds
a security ﬁeld to this shared substructure. To support
security information for individual messages, LSM also
adds a security ﬁeld to the msg msg structure.
LSM inserts a hook into the existing ipcperms func-
tion so that a security module can perform a check for
each existing Linux IPC permission check. However,
since these checks are not sufﬁcient for some security
modules, LSM also inserts hooks into the individual IPC
operations. These hooks provide more detailed informa-
tion about the type of operation and the speciﬁc argu-
ments. They also support ﬁne-grained control over indi-
vidual messages sent via System V message queues.
4.5 Filesystem Hooks
For ﬁle operations, three sets of hooks were deﬁned:
ﬁlesystem hooks, inode hooks, and ﬁle hooks. LSM
adds a security ﬁeld to each of the associated kernel
data structures: super block, inode, and file.
The ﬁlesystem hooks enable security modules to con-
trol operations such as mounting and statfs. LSM
leverages the existing permission function by insert-
ing an inode hook into it, but LSM also deﬁnes a num-
ber of other inode hooks to provide ﬁner-grained control
over individual inode operations. Some of the ﬁle hooks
allow security modules to perform additional checking
on ﬁle operations such as read and write, for exam-
ple, to revalidate permissions on use to support privi-
lege bracketing or dynamic policy changes. A hook is
also provided to allow security modules to control re-
ceipt of open ﬁle descriptors via socket IPC. Other ﬁle
hooks provide ﬁner-grained control over operations such
as fcntl and ioctl.
An alternative to placing security ﬁelds in the inode
and super block structures would have been to place
them in the dentry and vfsmount structures. The
inode and super block structures correspond to the
actual objects and are independent of names and names-
paces. The dentry and vfsmount structures con-
tain a reference to the corresponding inode or su-
per block, and are associated with a particular name
or namespace. Using the ﬁrst pair of structures avoids
object aliasing issues. The use of these structures also
provides more coverage of kernel objects, since these
structures also represent non-ﬁle objects such as pipes
and sockets. These data structures are also readily avail-
able at any point in the ﬁlesystem code, whereas the sec-
ond set of structures is often unavailable.
4.6 Network Hooks
Application layer access to networking is mediated us-
ing a set of socket hooks. These hooks, which in-
clude the interposition of all socket system calls, provide
coarse mediation coverage of all socket-based protocols.
Since active user sockets have an associated inode
structure, a separate security ﬁeld was not added to the
socket structure or to the lower-level sock structure.
As the socket hooks allow general mediation of net-
work trafﬁc in relation to processes, LSM signiﬁcantly
expands the kernel’s network access control framework
(which is already handled at the network layer by Netﬁl-
ter [36]). For example, the sock rcv skb hook allows
an inbound packet to be mediated in terms of its destina-
tion application, prior to being queued at the associated
userspace socket.
Additional ﬁner-grained hooks have been implemented
for the IPv4, UNIX domain, and Netlink protocols,
which were considered essential for the implementation
of a minimally useful system. Similar hooks for other
protocols may be implemented at a later stage.
Network data traverses the stack in packets encapsulated
by an sk buff (socket buffer) structure. LSM adds a
security ﬁeld to the sk buff structure, so that security
state may be managed across network layers on a per-
packet basis. A set of sk buff hooks is provided for
lifecycle management of this security ﬁeld.
Hardware and software network devices are encapsu-
lated by a net device structure. A security ﬁeld was
added to this structure so that security state can be main-
tained on a per-device basis.
Coverage of low level network support components,
such as routing tables and trafﬁc classiﬁers is somewhat
limited due to the invasiveness of the code which would
be required to implement consistent ﬁne-grained hooks.
Access to these objects can be mediated at higher levels
(for example, using ioctl), although granularity may
be reduced by TOCTTOU issues.
4.7 Other Hooks
LSM provides two additional sets of hooks: module
hooks and a set of top-level system hooks. Module hooks
can be used to control the kernel operations that create,
initialize, and delete kernel modules. System hooks can
be used to control system operations, such as setting the
system hostname, accessing I/O ports, and conﬁguring
process accounting. The existing Linux kernel provides
some control over many of these operations using the
capability checks, but those checks only provide coarse-
grained distinctions among different operations and do
not provide any argument information.
5 Testing and Functionality
Section 5.1 surveys modules that have been created for
LSM so far. Section 5.2 describes our performance test-
ing of LSM. While we have tested LSM kernels by boot-
ing and running them, we have not engaged in system-
atic testing. However, other members of the LSM com-
munity [45] have developed systematic LSM correctness
testing procedures [13, 14].
5.1 Modules
LSM provides only the mechanism to enforce enhanced
access control policies. Thus, it is the LSM modules that
implement a speciﬁc policy and are critical in proving
the functionality of the framework. Below are brieﬂy
described a few of these LSM modules:
• SELinux A Linux implementation of the Flask [41]
ﬂexible access control architecture and an exam-
ple security server that supports Type Enforcement,
Role-Based Access Control, and optionally Multi-
Level Security. SELinux was originally imple-
mented as a kernel patch [29] and was then reim-
plemented as a security module that uses LSM.
SELinux can be used to conﬁne processes to least
privilege, to protect the integrity and conﬁdential-
ity of processes and data, and to support application
security needs. The generality and comprehensive-
ness of SELinux helped to drive the requirements
for LSM.
• DTE Linux An implementation of Domain and
Type Enforcement [4, 5] developed for Linux [23].
Like SELinux, DTE Linux was originally imple-
mented as a kernel patch and was then adapted to
LSM. With this module loaded, types can be as-
signed to objects and domains to processes. The
DTE policy restricts access between domains and
from domains to types. The DTE Linux project
also provided useful input into the design and im-
plementation of LSM.
• LSM port of Openwall kernel patch The Open-
wall kernel patch [12] provides a collection of se-
curity features to protect a system from common at-
tacks, e.g. buffer overﬂows and temp ﬁle races. A
module is under development that supports a subset
of the Openwall patch. For example, with this mod-
ule loaded a victim program will not be allowed to
follow malicious symlinks.
• POSIX.1e capabilities The POSIX.1e capabili-
ties [42] logic was already present in the Linux ker-
nel, but the LSM kernel patch cleanly separates this
logic into a security module. This change allows
users who do not need this functionality to omit it
from their kernels and it allows the development of
the capabilities logic to proceed with greater inde-
pendence from the main kernel.
5.2 Performance Overhead
The LSM framework imposes minimal overhead when
compared with a standard Linux kernel. The LSM ker-
nel used for benchmarking this overhead included the
POSIX.1e capabilities security module in order to pro-
vide a fair comparison between an unmodiﬁed Linux
kernel with built-in capabilities support and a LSM ker-
nel with a capabilities module.
The LSM framework is designed to enable sophisticated
access control models. The overhead imposed by such a
model is a composite of the LSM framework overhead
and the actual policy enforcement overhead. Policy en-
forcement is outside the scope of the LSM framework,
however the performance impact of an enhanced access
control module is still of interest. The SELinux mod-
ule is benchmarked and compared against a standard
Linux kernel with Netﬁlter enabled to show an example
of module performance in Section 5.2.3.
Process tests, times in µseconds, smaller is better:
Test Type
null call
null I/O
stat
open/close
select TCP
sig inst
sig handl
fork proc
exec proc
sh proc
2.5.15
0.49
0.89
5.39
6.94
39
1.18
4.10
187
705
3608
2.5.15-lsm
0.48
0.91
5.49
7.13
41
1.19
4.09
187
706
3611
% Overhead
with LSM
-2.0%
-2.2%
1.9%
2.7%
5.1%
0.8%
-0.2%
0%
0.1%
0.1%
File and VM system latencies in µseconds,
smaller is better:
Test Type
0K ﬁle create
0K ﬁle delete
10K ﬁle create
10K ﬁle delete
mmap latency
prot fault