title:Universal forgery of the identity-based sequential aggregate signature
scheme
author:Jung Yeon Hwang and
Dong Hoon Lee and
Moti Yung
Universal Forgery of the Identity-Based Sequential
Aggregate Signature Scheme
Jung Yeon Hwang
Graduate School of
Dong Hoon Lee
Graduate School of
Information Management and
Information Management and
Security
Korea University
PI:EMAIL
Security,CIST
Korea University
PI:EMAIL
Moti Yung
Dept. of Computer Science
Columbia University
PI:EMAIL
ABSTRACT
At CCS’07, a novel identity-based sequential aggregate sig-
nature scheme was proposed and the security of the scheme
was proven under the hardness assumption of a new com-
putational problem called modiﬁed LRSW problem. In the
paper, unfortunately, we show that the scheme is universally
forgeable, i.e., anyone can generate forged signatures on any
messages of its choice. In addition, we show that the compu-
tational assumption is not correct by concretely presenting
a constant-time algorithm solving the problem. The contri-
bution of the new scheme and assumption is a natural step
in cryptologic research that calls for further investigation,
which is a step we perform in the current work.
Categories and Subject Descriptors
E.3 [Security and Protection]: Authentication, Crypto-
graphic controls
General Terms
Security
Keywords
Identity-based cryptography, Sequential aggregate signature,
Universal forgery
1.
INTRODUCTION
Various information and communication systems frequently
treat many signatures generated by many users on (distinct)
messages. For a primary example, we can consider the Se-
cure Border Gateway Protocol(S-BGP) (and its variants)
[9, 1, 7] which is currently under consideration for standard-
ization by the IETF. In S-BGP, a router should process n
signatures attesting to a path of length n in the network.
One of the main concerns in these contexts is to ﬁnd an
eﬀective method for compressing a list of signatures to ob-
tain savings on bandwidth and storage while preserving the
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS ‘09, March 10-12, 2009, Sydney, NSW, Australia
Copyright 2009 ACM 978-1-60558-394-5/09/03 ...$5.00.
validity of the signatures. To handle this problem, sequen-
tial aggregate signature schemes have been proposed [6, 11,
12].
In a sequential aggregate signature scheme, multiple
signers can sequentially and incrementally generate a short
signature on their own messages such that the single sig-
nature convinces the veriﬁer that the signer indeed signed
the original message. To simplify a public-key manage-
ment, the research on combining identity-cryptography[13]
with the notion of a sequential aggregate signature has been
conducted [8, 2, 3]. An identity-based sequential aggregate
signature(IBSAS) scheme provides the functionality of a se-
quential aggregate signature only using a signer identity such
as an IP address as a public key.
In an IBSAS, veriﬁca-
tion information is reduced and so this feature makes IBSAS
schemes practical.
Despite of the (practical and potential) worth of an IBSAS
scheme, the construction of a secure IBSAS scheme is not
simple. In principle, an identity-based signature scheme is
designed in a “2-level hierarchical” signature scheme: That
is, a trusted key generation center generates a signature to
authenticate an identity of a signer and the signer uses the
signature as his private signing key to generate his signature
on a message. Note that the use of randomness is necessary
in order to appropriately hide the secret signing key in an
IBSAS scheme. As observed in [8], the main diﬃculty in
constructing an IBSAS scheme is caused by the problem
to (non-interactively) aggregate all the randomness used by
signers to generate their signatures. Recently, a novel IB-
SAS scheme was proposed using a design principle that a
message in a signature is tied between a secret signing key
and a randomness [2, 3]. For the security of the proposed
IBSAS scheme, a so-called modiﬁed LRSW(M-LRSW) prob-
lem was introduced and the hardness of this problem was
justiﬁed in the generic bilinear group model of [4, 5]. (This
model provides the conﬁdence that it is not helpful to ex-
ploit group representation or speciﬁc properties of a group
beyond the deﬁnition of a bilinear group in solving a com-
putational problem based on the group.)
Unfortunately, though the reduction (not the proof) of [2,
3] is correct, in the paper, we show that the IBSAS scheme is
universally forgeable, that is, anyone can forge the signature
of any messages of its choice. To show this, we concretely
present a forgery algorithm that makes two signing queries
on two messages and generates a forged signature on any
message, which is not one of the two messages, by using the
two valid signatures. Furthermore, we point out that the M-
LRSW problem on which the security of the IBSAS scheme
157is based, is not correctly constructed. Despite of justiﬁcation
for the hardness of the problem in the generic bilinear group
model in [2, 3], the problem is inherently easy under the
deﬁnition of a (algebraic) group. To show that the problem
is not hard, we present a simple constant-time solver to the
problem. Like the forgery algorithm, this only uses two or-
acle queries. The development of assumptions and schemes
based on them and the further scrutiny of assumptions and
schemes is a natural development in cryptography. Thus, we
believe the contribution of [2, 3] in their attempt to increase
our primitives and assumptions is a very valid research step
that we appreciated and view as a step in the natural de-
velopment of cryptographic research. Our contribution is a
natural step in this line of research where newly suggested
methods are being further validated or invalidated.
The rest of this paper is organized as follows: In Section 2,
we review the CCS07-scheme. In Section 3, we present the
scheme is universally forgeable. In Section 4, we show that
the computational assumption for the scheme is not correct.
Finally, we conclude in Section 5.
2. A REVIEW OF THE CCS07-SCHEME
In this section we brieﬂy review the IBSAS scheme in [2,
3]. For more details, refer to [2, 3]. Before presenting the
scheme, we ﬁrst review bilinear maps and its associated bi-
linear groups.
2.1 Bilinear Pairings
Consider the following setting: G and GT are cyclic groups
of prime order p and g is a generator of G. e : G×G → GT is
an eﬃciently computable map with the following properties:
• Bilinear : For all u, v ∈ G and a, b ∈ Zp. e(ua, vb) =
e(u, v)ab.
• Non-degenerate : For all h ∈ G \ {1G}, e(h, h) (cid:54)= 1GT .
• Computable: There exists an eﬃcient algorithm to
compute e(u, v) for all u, v ∈ G.
We call an algorithm G that outputs (p, G, GT , e) a bilinear-
group generator and G a bilinear group.
2.2 The IBSAS Scheme
The scheme consists of four algorithms, Setup, Key Deriva-
tion, Signing, and Veriﬁcation.
- Setup: The algorithm ﬁrst runs a bilinear-group genera-
tor G on random coins to obtain output (p, G, GT , e)
and chooses a random generators u, v, g ∈ G, and a
random α ∈ Zp, and cryptographic hash functions
H1 : {0, 1}∗ → G and H2 : {0, 1}∗ → Zp. It returns
mpk = (p, G, GT , e, u, v, g, gα, H1, H2) as its master
public key and msk = α as the corresponding mas-
ter secret key.
- Key Derivation: On input the master secret key msk and
an identity ID ∈ {0, 1}∗, the algorithm returns skID =
H1(ID)α as a user’s private key corresponding to ID.
- Signing: On inputs a user’s secret key skIDi , a message
mi, a list L = ((ID1, m1), ..., (IDi−1, mi−1)), and a
signature σ corresponding to L, the algorithm parses
σ as (X, Y, Z) ∈ G × G × G.
(This is skipped for
if i = 1, for whom σ is deﬁned
a ﬁrst signer, i,e.
It chooses r ∈ Zp at random. For
as (1G, 1G, 1G).)
a list ((ID1, m1), ..., (IDn, mj)), we let sj denote the
string ID1||m1||...||IDj||mj for all j = 1, 2, ..., n. The
algorithm computes:
(cid:48) ← urΠi
l=1H2(sl) · H1(IDi)α,
X
(cid:48) ← vr · H1(IDi)α.
Y
Finally, it returns
(X · X
, Y 1/H2(si) mod p · Y
(cid:48)
(cid:48)
, Z 1/H2(si) mod p · gr).
- Veriﬁcation: On input public parameters mpk, a list L =
((ID1, m1), ..., (IDn, mn)), and a signature σ corre-
sponding to L, the algorithm ﬁrst returns 0 if all of
ID1, ..., IDn are not distinct. Then it parses σ as
(X, Y, Z) and veriﬁcation proceeds as follows. First,
it checks if
e(Y, g) ?= e(v, Z) · e(
j=i+1H2(sj )), gα).
H1(IDi)1/(Πn
n(cid:89)
i
If not, the algorithm returns 0. If the equation holds,
it computes Z(cid:48) ← Z Πn
(cid:48)
i=1H2(si) and then checks if
, u) · e(
e(X, g) ?= e(Z
H1(IDi), gα).
n(cid:89)
i
If the equation does not hold, the algorithm returns 0.
If the equation holds, it returns 1.
3. SECURITY ANALYSIS
In this section we demonstrate that the IBSAS scheme
above is universally forgeable, that is, anyone can forge the
signature of any messages of its choice. Furthermore, we
point out that the hardness assumption for the scheme is
not correct.
3.1 Universal Forgery of the IBSAS Scheme
To show that the IBSAS scheme is universally forgeable,
we construct a concrete forgery method for a signer using
two signatures generated by the signer:
A forger F randomly selects a target identity ID. We
assume that the forger F obtains two signatures σ1 and σ2
for ID on any messages m1 and m2, respectively. This is
a typical attack environment to measure the security of a
signature scheme. Next F freely selects a message m∗ on
which a forged signature will be generated.
For all i = 1, 2, let si = ID||mi and the given signatures
σi = (Xi = uriH2(si)H1(ID)α and Yi = vri H1(ID)α, Zi =
gri ). The forger proceeds to generate a forged signature on
the message m∗ as follows:
• For i = 1, 2, the forger F computes wi = H2(si)−1
(mod p) and
Ti = X wi
i = (uriH2(si)H1(ID)α)H2(si)−1
= uri H1(ID)αwi .
• The forger computes w∗ = H2(ID||m∗)−1 (mod p)
and a pair (β1, β2) satisfying the relation,
(cid:181)
w1β1 + w2β2 = w∗
(mod p)
β1 + β2 = 1
(mod p)
(cid:182)(cid:181)
(cid:182)
(cid:181)
⇔
w1 w2
1
1
β1
β2
=
(cid:182)
.
w∗
1
158We assume that w1 (cid:54)= w2. Because w1 and w2 are
outputs of a collision-resistant hash function H2, the
case w1 (cid:54)= w2 occurs with overwhelming probability.
Because the determinant of the above coeﬃcient ma-
trix is nonzero, that is, w1 − w2 (cid:54)= 0 and (w1 − w2)−1
(mod p) exists, one can easily computes (β1, β2) using
Linear Algebra as follows;
(cid:182)(cid:181)
(cid:182)
w∗
1
(cid:181)
(cid:182)
β1
β2
(cid:181)
(cid:195)
=
=
−w2
w1−w2
w1
w1−w2
(cid:33)
.
1
w1−w2
−1
w1−w2
w∗−w2
w1−w2
−w∗+w1
w1−w2