These results show that USB-based machine ﬁngerprinting
methodologies are resistant to concept drift over long spans
of time, which contrasts with previous work [8] that showed
inconsistent characteristics after a two-week period.
VI. DISCUSSION
A. Towards Commodity Deployment
In an effort to encourage the further exploration of USB
Fingerprinting, we are releasing the two Android applications
that were developed in this study (see Section VIII). While
these apps greatly simplify USB collection and analysis, we
stress that our methodologies are generally employable using
any device that can record USB timing events at sufﬁcient
granularity. For example, we replicated the results of Section
IV-B using Gumstix, an inexpensive embedded device. We
imagine a variety of potential applications for USB Finger-
printing, from attesting personal computers with our Android
app, to datacenter-wide monitoring using dedicated hardware.
Android USB Analyzer:
this application rapidly collects
USB enumeration data from USB-enabled hosts and embedded
devices. The app requires approximately 2 seconds to record
and conclude a single enumeration period. In most of our
experiments, we collected 50 traces from each machine. If
an organization employing USB Fingerprinting used our col-
lection procedure, this app would allow a single administrator
to collect from as many as 260 host machines in a typical
eight-hour day. The app does not require human intervention
after initial connection to the target host, allowing the admin-
istrator to perform other tasks during data collection. The app
also stores the attribute information of previously collected
machines, shown in Figure 8, minimizing the amount of data
entry required prior to data collection.
Android USB Identiﬁer: this distributed application performs
real-time machine identiﬁcation using a previously generated
ﬁngerprint model. This model can be generated in Weka using
the traces collected from Android USB Analyzer by following
the procedures in Section IV-C. The client app sends USB
enumeration traces to a remote server, building a testing set that
is used to verify the previously generated machine ﬁngerprint.
The server performs the Chi-Squared test described in Section
IV-C, and then notiﬁes the client app of the result. Once the
machine is labeled as either target or other, a notiﬁcation
message is displayed to the user. Sample notiﬁcations are also
displayed in Figure 8.
B. Attacks against USB Fingerprinting
In this section, we explore how USB Fingerprinting might
perform in the presence of a strong adversary. With sufﬁcient
knowledge of our approach, an attacker-controlled machine
may attempt
to evade detection through manipulating the
behavior of its own USB stack. Let us consider the case in
which the attacker has replaced a victim’s machine with one
that is identically speciﬁed but under attacker control, and
seeks to trick the victim’s USB Fingerprinting model into
incorrectly identifying the device as safe for use. The attacker
can attempt this feat by 1) altering the sequence or presence
of descriptor requests, 2) sending invalid data to the device
that violates the USB protocol, 3) launching a mimicry attack
Fig. 8: Screenshots from our Android machine ﬁngerprinting
apps: attribute entry (left), and machine identity notices (right).
USB Fingerprinting would need to preserve a single collection
device for the lifetime of each machine. When this device fails
or is lost, they would need to re-ﬁngerprint all machines with
a new device. Such a constraint would seriously undermine
the adoptability of our approach.
To test classiﬁer robustness across different devices, we
collected data from the same machines using two identical
Samsung Galaxy Nexus phones. The phones both collected
traces for each machine within minutes of each other. We
collected 3750 traces from 75 different machines: 27 Apple
iMac 10, 27 Dell Optiplex 750, and 21 Dell Optiplex 980;
in previous trials, we were able to identify these machines
with upwards of 96% accuracy. We used the dataset from
one of the phones to train a Random Forest classiﬁer to
detect the Model Number attribute. When evaluated against the
dataset from the second, the model achieved 100% accuracy.
This test demonstrates the feasibility of using multiple USB
Fingerprinting devices within an enterprise.
D. Resistance to Concept Drift
We now consider the resiliency of USB Fingerprinting
against concept drift, the well-known machine learning prob-
lem in which a model’s performance degrades over time.
Concept drift would undermine our arguments regarding the
adoptability of USB Fingerprinting, as ideally system admin-
istrators will be able to re-use machine learning models for
months or years before re-training is required. Our study tested
for concept drift by re-evaluating one of our models against
new data that was collected 3 months after our original trials.
Using the Model Number classiﬁer described in Section IV-B,
we attempted to predict the label of newly collected traces from
20 Dell Latitude e6500’s and 11 Apple iMac 10.1’s. These
machines were selected due to ease of access, and because their
computer labs had not seen much machine turnover during
the 3 month span. The old Model Number classiﬁer achieved
10
that relays USB messages from the victim’s true machine, or
4) within certain constraints, altering the timing information
of his messages to the device.
1) Our approach offers strong assurances against spoofed
descriptor requests. This is because, in contrast to previous
work [9], [11], our scheme does not rely on the presence
or absence of certain descriptor sequences to identify host
attributes. We demonstrate this via a proof-of-concept attack
against Davis’s Windows ﬁngerprint [9], which searches for
the presence of 3 GetDescriptor (Configuration)
requests. On a dual-booted desktop, we trained a classiﬁcation
model on a small set of traces from two OS’s: Windows 7 SP1,
and a Red Hat Linux 2.6.32 kernel. We then modiﬁed the Linux
kernel source, causing the usb new device function in hub.c to
issue an additional GetDescriptor (Configuration)
request at the end of enumeration. Running the newly built
Linux kernel, we then collected a set of test traces. While
Davis’ scheme as described in [9] would identify the traces as
belonging to a Windows host, our classiﬁer correctly identiﬁes
the test traces as belonging to a Linux distribution.
2) If the invalid data causes enumeration to fail, the attacker
is detected. If enumeration completes, the attacker may be
able to trigger unexpected results, injecting confusion into
the classiﬁcation process. Our scheme as described does not
prevent this attack; it would need to be modiﬁed to include
fail-safe mechanisms in the event of unexpected host behavior.
Adding a preliminary check similar to those used by Stavrou et
al. and Davis would help here, as it would force the attackers
inputs to conform to those of known OS behaviors [11], [9].
3) The compromised host may attempt to leverage a remote
host acting as a proxy helper in order to mislead a USB
Fingerprinting veriﬁer, e.g., performing a mimicry attack. The
challenges of overcoming the latency imposed by such an
attack were well-deﬁned by Li et al. [36]; the colluding hosts
can trick the veriﬁer if they are able to keep the round-trip
time to the helper (T local
recv ) and the helper’s computation
(T helper
comp ) within the same time bound as the local host’s com-
putation (T local
comp). We will conservatively assume that T helper
comp
is zero because of the helper’s vast computational resources.
In the values of our USB enumeration feature vectors, it was a
common to observe transactions within 122µs of one another,
which we adopt as a time bound for USB Fingerprinting to
detect an anomaly. Previous work has shown that an optimized
Linux network stack has a maximum request-response rate of
processing 7985 IP packets per second, a per-packet processing
time of 125 µs receiving each USB transaction over the
wire [37]. If the local host is bound by this value, it will
require at least 250 µs to relay packets to the proxy helper
(T local
recv > 250µs). As this latency is well above
the inter-IRQ time that is captured by many of our features, a
mimicry attack will be detected.
4) The attacker can cause arbitrary message delay; if this is suf-
ﬁcient to mislead the classiﬁer, the attack will go undetected.
More likely, though, the attacker will need to speed up some
messages or precisely control the spacing between messages,
which is signiﬁcantly more complicated. This would require
modiﬁcation of host behavior near the USB Bus Interface level.
One method of reliably controlling message spacing would
be to statically replay the correct USB enumeration. If the
attacker had access to the victim’s uncompromised machine,
send + T local
send ,T local
they could statically compile the full enumeration process
expected by the collection apparatus, then execute it in place
of allowing the typical interactions between the upper layer of
the USB stack from the serial interface engine (SIE). This
attack would go undetected by the Android USB Identiﬁer
application. One method of strengthening our scheme against
this attack would be to incorporate Stavrou et al.’s method
of emulating randomly selected USB peripherals [11]. This
would alter the characteristics of the collection device, forcing
the attacker to guess which enumeration to replay.
C. Future Work
We will undertake a variety of additional USB Fingerprint-
ing trials, including the investigation of the impact of system
load and quiescence. Although the vector in our current scheme
offers over 150 features, we believe that additional contextual
information can be mined from the USB protocol, both through
continued passive observation as well as active analysis. These
features may help to improve USB Fingerprinting results for
machine identiﬁcation; our preliminary results, while promis-
ing, do not offer sufﬁcient machine coverage for general use. In
spite of this, we feel that USB Fingerprinting in its current state
can serve as a point of reference in a variety of applications,
which we intend to explore. While we have shown that USB
Fingerprinting is robust against particular forms of tampering,
a full security analysis was outside the scope of this work.
We intend to demonstrate that a modiﬁed version of USB
Fingerprinting is fully secure against active adversaries.
VII. RELATED WORK
A. Fingerprinting
Fingerprinting has become a popular method for device
identiﬁcation, and has been used to identify home electron-
ics [38], websites [39], [40], [41], [42], [43], [44], the op-
erating system of VMs [45], [46], and the source of phone
calls [47]. The concept of ﬁngerprinting stems from leverag-
ing measurable signals caused by hardware imperfections in
analog circuitry to uniquely identify devices. Fingerprinting
has been extensively studied and used for identifying RFID
smart cards [48], Ethernet cards [49] and 802.11 devices [15],
[50], [51], [12], [52], as well as users [53].
Remote ﬁngerprint techniques identify devices using only
characteristics of their communication [48]. Identifying ma-
chines remotely has been a popular method, resulting in tools
like Nmap [54] and Xprobe [55] that detect operating systems
by examining network trafﬁc. While effective in some cases,
network ﬁngerprints can be fooled by systems that spoof
operating systems at the network layer, such as Honeyd [19].
Other remote schemes, such as work by Kohno et al. [56]
and Jana et.al. [57], identify machines using clock skew data.
However, it has been shown that TCP and ICMP timestamps
can be disabled or manipulated [18], [14], [58]. Semi-persistent
network data has also been used to ﬁngerprint devices [59],
[53] and browsers [60], [61]. Services to ﬁngerprint browsers
are available commercially, and are of particular interest to
advertising agencies [62]. Eckersly employs similar methods
of feature evaluation in his work on browser ﬁngerprinting
[13]. His highly instructive method of plotting ﬁngerprint
surprisal distribution is sadly not applicable to our feature
11
vector due to its size and use of noisy continuous variables.
Machine learning classiﬁcation techniques have been also been
deployed to create accurate ﬁngerprinting schemes for user
re-authentication in smartphones. Li et al. [63] used feature
extraction and SVMs to recognize an individual smartphone
user’s ﬁnger movements.
While many remote ﬁngerprinting methods exist, there has
been little previous exploration into host identiﬁcation using
USB trafﬁc through a physical connection. A recent work by
Wang et al. [11] uses USB-equipped smart phones to identify
host operating systems. However, their approach of reading
the contents of the URB ﬁeld from packets is not effective
against a knowledgeable adversary, who can manipulate packet
data. Butler et al. [8] employ a USB protocol analyzer to
inspect
the timing of bus states. In ignoring the contents
and timing of USB protocol events, their approach sacriﬁces
critical information gain, is subject to concept drift, and fails
to differentiate between basic host attributes such as model
number. In contrast, we demonstrate over a 10-times larger
machine corpus that USB Fingerprinting is resistant to concept
drift, easily distinguishes between similar machine models,
and can even be used to differentiate between hosts in a
set of identically speciﬁed machines. Finally, our collection
mechanism is a freely available app for commodity devices,
while their study relied on an expensive specialty device that
requires a ﬁeld expert to operate competently.
Our approach offers several beneﬁts over existing machine
classiﬁcation methods. Work proposed by Desmond et al. [15],
can take one hour at a minimum to collect enough data
to perform classiﬁcation. With our scheme, we can collect
data and make a decision in a matter of minutes. Device
identiﬁcation work by Gerdes et al. [49] and Brik et al. [12]
differentiates unique network cards of the same model, but
is only applicable to network devices. Our ﬁngerprinting
technique is applicable to any device using the USB protocol.
Network-based OS classiﬁcation methods such as Richardson
et al.’s [64] suffer from more noise than our USB approach.
By using the same classiﬁers investigated by these authors, we
distinguish between individual OSes with 100% accuracy.
B. Compromise Detection
Network-based (NIDS) and host-based (HIDS) intrusion
detection systems [65], [66], [67], [68] can be used for compro-
mise detection. NIDS analyze incoming and outgoing network
trafﬁc in order to determine if a system has been infected.
HIDS usually refers to software that examines audit
logs
for suspicious activity, looking for changes in user behavior.
However, an attacker with kernel control will be able to
manipulate all software on the computer, including HIDS.
Garriss et al.’s trustworthy kiosk system [16] uses a smart-
phone to remotely verify system integrity based on trusted
computing techniques. A disadvantage of this approach is the
fact that a separate visual identiﬁcation channel is required.
Butler et al.’s Kells system [69] provides similar guarantees,
but uses a USB ﬂash drive as a remote veriﬁer. Ensuring
physical interaction with the target machine eliminates the
need for a visual channel, but the approach is still susceptible
to relay attacks, such as Parno’s “cuckoo” attack [1].
C. Distance Bounding
Distance bounding protocols have been used in numerous
systems, from computers to radio. Rasmussen et al. [70]
demonstrate the need for fast processing speeds on any system
implementing such protocols to prevent distance spooﬁng.
Ramaswamy et al. [71] showed that processing delay within
networks has become a signiﬁcant concern, and an individual
packet can experience increasing delays. Since our method per-
forms the ﬁngerprinting task over a direct physical connection,
we are able to obtain more accurate timing measurements than
possible over a network. VIPER [36] demonstrates software at-
testation with embedded systems, and also shows resilience to
similar relay or proxy attacks. Our discussion in Section VI-B
demonstrates our robustness against the attacks on distance
bounding protocols, including distance hijacking [72].
VIII. CONCLUSION