Recovery 
Patterns 
Step 1. 
Increase auto 
scaling 
group’s 
desired 
capacity by 12 
Step 2. Wait 
for the auto 
scaling group 
to start 
additional 12 
instances 
Step 3. 
Register these 
12 instances 
with the load 
balancer 
Recovery 
Point 1 
Recovery 
Point 2 
Selected 
Recovery 
Action(Pareto 
Set) 
Attach ASG 
with the correct 
LC; 
Terminate the 6 
wrong 
instances; 
Wait for ASG 
to launch 6 new 
instances; 
Monetary 
Cost 
(Pareto Set) 
$0.0186 
Selected 
Recovery 
Action(User 
Constraints) 
Attach ASG 
with the correct 
LC; 
Terminate the 6 
wrong 
instances; 
Wait for ASG 
to launch 6 new 
instances; 
(Reparation) 
 (Reparation) 
Monetary 
Cost (User 
Constraints) 
$0.0186 
6 instances 
with wrong 
AMI 
RP1, 
RP2, 
RP3, 
RP4, RP5 
6 instances 
not in ELB 
RP1, 
RP3, 
RP5, 
RP6, RP8 
Register the 6 
instances with 
the load 
balancer; 
$0 
Register the 12 
instances with 
the load 
balancer again; 
$0 
(Reparation) 
 (Direct Redo) 
120 
3)  Satisfying Recovery Requirement R4 
The recovery monetary cost of the selected recovery action is the optimal/acceptable one, which 
means that its recovery monetary cost is relatively small compared to all other recovery actions. 
Such  selection  and  optimization  mechanism  guarantees  that  the  recovery  monetary  cost  can 
meet the recovery monetary cost objective set by stakeholders. Hence, the requirement that the 
recovery should reduce monetary cost is achieved. 
E.  Recovery from Errors without Known Causes  
1)  Experimental Procedure 
POD-Recovery does not require a known cause: its recovery plan generation dynamically finds 
a  plan  from  the  current  erroneous  state  to  a  desired  state  –  be  it  a  captured  earlier  state  or  an 
expected future state. To study this aspect in detail, we performed additional experiments with 
other faults. We ran scale-up operation, injected various faults, and triggered recovery without 
providing the error causes. Per type of injected fault, we performed 30 runs. 
2)  Experimental Results 
Table  33  summarizes  the  results  of  these  experiments,  by  showing  the  number  of  successful 
recoveries for each injected fault. As can be seen, recovery is successful for all injected faults. 
Table 33.  Recovery without Known Causes 
Recovery Point 
Error Occurred 
Fault Injected 
(Cause) 
# Successful 
Recoveries 
Recovery Point 1 
6 instances with 
wrong AMI 
Recovery Point 2 
6 instances not in 
ELB 
3)  Satisfying Recovery Requirement R5 
Launch  configuration 
(LC) changed 
Wrong 
instances 
attached by other team 
“RegisterInstancesWit
hELB” call fails 
Other  team    detaches 
the  new 
instances 
from ELB 
30 
30 
30 
30 
Due  to  the  dynamic  recovery  plan  generation,  our  method  can  recover  from  errors  without 
known cause – as long as the error cause is included in the resource space and can be recovered 
through API calls. If the cause is not included or the API cannot be reached (e.g. cloud system 
disconnected), our method cannot recover from the error. Hence, the cause of the error does not 
affect the recovery although it may affect whether the error remains or reoccurs. 
121 
F.  Dealing with False Positives of Error Detection 
1)  Experimental Procedure 
To  test  the  reaction  of  POD-Recovery  to  false  positives  of  error  detection,  we  trigger  the 
recovery  service  without  injecting  an  error,  and  observe  whether  POD-Recovery  takes  any 
action.  For  each  recovery  point  (RP)  we  do  this  50  times.  Since  error  detection  triggers  the 
recovery  service,  and  since  POD-Recovery  does  not  consider  any  causes  offered  by  the 
triggering  message,  we  do  not  investigate  any  more  complex  false  positives.  Also,  as  argued 
above, if a transient error disappears before recovery starts, we consider it to be a false positive 
from the viewpoint of recovery. 
2)  Experimental Results 
Table 34 shows the recovery service’s ability to handle false positives from the error detection 
service. We can see that all the false positives were successfully detected: in all 100 runs of our 
experiment, no recovery action was taken. 
Table 34.  Handling False Positives of Error Detection 
Recovery Point 
# False Positives 
# No Recovery 
RP 1 
RP 2 
50 
50 
50 
50 
3)  Satisfying Recovery Requirement R6 
Due  to  the  design  of  our  recovery  method,  with  its  dynamic  plan  generation,  false  positives 
from error detection will not cause unnecessary recovery actions. 
G.  Recovery for Recovery Itself  
1)  Experimental Procedure 
To test POD-Recovery’s behaviour when errors occur during the execution of the recovery plan, 
I performed the scale-up operation, injected faults into each determined recovery point to trigger 
POD-Recovery, waited for the selected recovery action to execute, and then manually injected 
additional  faults  into  the  recovery  action  to  trigger  the  “recovery  of  recovery”  block.  I 
performed  30  runs  of  this test  of  “recovery  for  recovery  itself”  for  each  recovery  point  of  the 
scale-up operation. 
2)  Experimental Results 
Table  35  shows  the  recovery  time  of  “recovery  for  recovery”  on  the  scale-up  operation.  The 
relative standard deviation is at most 2.3%. 
122 
Table 35.  Recovery Time of “Recovery for Recovery” 
Recovery 
Point 
Process Step 
Errors 
Recovery 
Point 1 
Step 1. Increase 
auto scaling 
group’s desired 
capacity by 12 
Step 2. Wait for 
the auto scaling 
group to start 
additional 12 
instances 
6 instances 
with wrong 
AMI 
Recovery 
Point 2 
Step 3. Register 
these 12 instances 
with the load 
balancer 
6 instances 
not in ELB 
Time of 
Recovery 
for 
Recovery 
(Pareto 
Set) 
55.78 s 
Selected 
Recovery 
Action(Pareto 
Set) 
Attach ASG 
with the correct 
LC; 
Terminate the 6 
wrong 
instances; 
Wait for ASG 
to launch 6 new 
instances; 
Selected 
Recovery 
Action(User 
Constraints) 
Attach ASG 
with the correct 
LC; 
Terminate the 6 
wrong 
instances; 
Wait for ASG 
to launch 6 new 
instances; 
(Reparation) 
 (Reparation) 
Time of 
Recovery for 
Recovery 
(User 
Constraints) 
60.55 s 
Register the 6 
instances with 
the load 
balancer; 
7.14 s 
Register the 12 
instances with 
the load 
balancer again; 
7.09 s 
(Reparation) 
 (Direct Redo) 
3)  Satisfying Recovery Requirement R7 
We can see that the maximum recovery time of “recovery for recovery” is 60.55 seconds. Hence, 
the time for the original recovery and the “recovery for recovery” in total is much less than the 
specified  time  gap  between  two  adjacent  recovery  points.  Thus,  the  requirement  of  “recovery 
for recovery” is achieved by POD-Recovery. 
8.4  Case Study 4-Recovery for Scale-down Operation on Cloud 
In  this  section,  we  present  the  evaluation  results  of  POD-Recovery  by  using  the  scale-down 
operation on cloud as the case study. The purposes of this experiment are three-fold: 1) showing 
the  result  of  recovery  points  determination  for  scale-down;  2)  presenting  the  workload  of 
resource  state  management  for  scale-down;  3)  demonstrating  POD-Recovery’s  capability  of 
satisfying recovery requirements using scale-down. The experimental environment is described 
in Fig. 26 above. 
8.4.1  Recovery Points Determination 
The  scale-down  operation  also  has  3  steps:  1)  deregister  12  instances  from  the  elastic  load 
balancer; 2) decrease auto scaling group’s desired capacity by  12; 3) wait for  the auto scaling 
group  to  terminate  12  instances.  Fig.  36  shows  the  sections  resulting  from  recovery  points  at 
different  levels  of  granularity.  First,  Fig.  36(a)  is  obtained  by  applying  Recovery  Actions 
Identifiable to the steps of scale-down operation. Fig. 36(b) combines some sections with low 
123 
failure  rates.  The  recovery  points  are  determined  to  be  after  step  1  and  step  3  based  on  the 
recovery point determination criterion and failure rate consideration.  
Fig. 36.  Determining Recovery Points for Scale-down Operation. 
8.4.2  Workload of Resource Space Determination 
The  determined  resource  space  contains  four  resource  types:  Instance  (i.e.  VM),  Launch 
Configuration  (LC),  Auto  Scaling  Group  (ASG),  and  Elastic  Load  Balancer  (ELB).  Each 