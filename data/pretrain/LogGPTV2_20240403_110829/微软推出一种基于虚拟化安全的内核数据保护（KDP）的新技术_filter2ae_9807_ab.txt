address（GPA或ARM64中的IPA）的中间物理地址。这种转换仍然由页表管理，有Guest操作系统管理的CR3控制寄存器寻址。转换的最终结果返回给处理器一个GPA，并在Guest页表中指定访问保护。请注意，只有在内核模式下运行的软件才能与页表交互。rootkit通常在内核模式下运行，并且确实可以修改中间物理页的保护。
hypervisor使用扩展(或嵌套)页表帮助处理器转换GPA。在非slat系统上，当TLB中没有虚拟地址时，处理器需要查阅层次结构中的所有页表，以重建最终的物理地址。如下图所示，虚拟地址被分成四个部分(在LA48系统上)。每个部分表示层次结构页表中的索引。初始PML4表的物理地址由CR3寄存器指定。这解释了为什么处理器总是能够转换地址并获得层次结构中下一个表的下一个物理地址。需要注意的是，在层次结构的每个页表条目中，NT内核通过一组属性指定了一个页保护。只有在每个页表条目中指定的保护的总和允许的情况下，才可以访问最终的物理地址。
当SLAT打开时，需要将Guest的CR3寄存器中指定的中间物理地址转换为真实的系统物理地址(SPA)。机制类似:hypervisor将表示当前执行VM的活动虚拟机控制块(VMCB)的nCR3字段配置为嵌套(或扩展)页表的物理地址(注意，该字段在Intel体系结构中称为“EPT
pointer”)。嵌套页表是以类似于标准页表的方式构建的，因此处理器需要扫描整个层次结构以找到正确的物理地址，如图2所示。在图中，“n”表示层次结构中嵌套的页表，由hypervisor管理，而“g”表示Guest页表，由NT内核管理。
如图所示，Guest虚拟地址到系统物理地址的最终转换需要两种转换类型：GVA到GPA（由Guest
VM的内核配置）和GPA到SPA（由hypervisor配置）。请注意，在最坏的情况下，转换涉及所有四个页面层次结构级别，这将导致20个表查找。该机制可能会很慢，并通过处理器对增强TLB的支持来缓解。在TLB条目中，还包含了另一个标识当前正在执行的VM的ID（在Intel系统中称为虚拟处理器标识符或VPID，在AMD系统中称为地址空间ID或ASID），因此处理器可以缓存属于两个不同VM的虚拟地址的转换结果，而不会发生任何冲突。
如上图所示，一个NPT条目指定了多个访问保护属性。这允许hypervisor进一步保护系统物理地址（除了hypervisor本身之外，任何其他实体都不能访问NPT）。当处理器试图读、写或运行NPT不允许访问的地址时，会引发NPT冲突（Intel体系结构中的EPT冲突），并生成VM出口。NTP违反生成的VM退出并不经常发生。通常，它是在嵌套配置中产生的，或者在HVCI中使用MBEC软件时产生的。如果由于其他原因而发生不扩散冲突，Microsoft
Hypervisor将向当前虚拟处理器(VP)注入访问冲突异常，该虚拟处理器由Guest操作系统以不同的方式管理，但如果没有异常处理程序选择处理该异常，则通常通过错误检查进行管理。
###  静态KDP实现
SLAT保护是允许KDP存在的主要原理。在Windows中，动态和静态KDP实现是相似的，它们都由安全内核管理。安全内核是唯一能够向hypervisor发出ModifyVtlProtectionMask
hypercall的实体，其目标是修改映射在较低VTL0中的物理页面的SLAT访问保护。
对于静态KDP，NT内核验证驱动程序不是会话驱动程序或映射了大页面。如果存在这些条件之一，或者该节是可丢弃的节，则不能应用静态KDP。  
如果调用MmProtectDriverSection
API的实体没有请求目标映像不可加载，则NT内核将执行对安全内核的第一次调用，该内核将锁定与驱动程序关联的正常地址范围（NAR）。
“pinning”操作防止驱动程序的地址空间被重用，使驱动程序不可卸载。然后，NT内核将属于该部分的所有页面放入内存，并使它们私有化（即原型pte没有寻址）。
然后，在叶PTE结构中，页面被标记为只读（在图2中突出显示为“gPTE”）。在这个阶段，NT内核最终可以通过SLAT调用安全内核来保护底层物理页面。安全内核分两个阶段应用保护：
    1. 通过在数据库中添加适当的NTEs(普通表地址)并更新属于VTL1的底层安全pfn，注册属于该节的所有物理页并将它们标记为“属于VTL0”。这允许安全内核跟踪物理页面，这些页面仍然属于NT内核。
    2. 对VTL0 SLAT table应用只读保护。hypervisor为每个VTL使用一个SLAT表和VMCB。
目标Image的部分现在受到保护。VTL0中的任何实体都不能写入属于该节的任何页。如前所述，这个场景中的安全内核保护了一些最初由VTL0中的NT内核分配的内存页。
## 动态KDP实现
动态KDP使用新段堆提供的服务从安全池中分配内存，该池几乎完全由安全内核管理。
在引导过程的早期阶段，NT内存管理器计算安全池使用的512GB区域的随机虚拟基址，该区域恰好跨越256个内核PML4条目中的一个。在第1阶段的后期，NT内存管理器会发出一个安全调用，其内部名为INITIALIZE_SECURE_POOL，其中包括计算过的内存区域，并允许安全内核初始化安全池。
安全内核创建一个NAR，表示属于不安全NT内核的整个512GB虚拟区域，并初始化属于NAR的所有相对NTEs。安全内核中的安全池虚拟地址空间是256GB，这意味着它的PML4映射与一些其他内容共享，并且与NT相比不在相同的基址上。因此，在初始化安全池描述符时，安全内核还会计算一个增量值，即安全内核中的安全池基址与NT内核中保留的基址之间的差值（如下图所示）。这很重要，因为它允许安全内核向NT内核指定映射属于安全池的物理页面的位置。
当运行在VTL0内核中的软件请求从安全池分配一些内存时，对安全内核进行安全调用，该安全调用调用内部的RtlpHpAllocateHeap函数，该函数在两个VTLs中都公开。如果段堆计算出安全池中已经没有空闲内存段了，它就调用SkmmAllocatePoolMemory例程，该例程为池分配新的内存页。如果不需要，堆总是试图避免提交新的内存页。
与NT内核公开的NtAllocateVirtualMemory API一样，SkmmAllocatePoolMemory
API支持两种操作:保留和提交。保留操作允许安全内核的内存管理器保留池分配所需的一些pte。提交操作实际上分配空闲的物理页。
物理页面是从属于安全内核(其安全pfn处于安全状态)的一组空闲页面中分配的，并映射到VTL 1的页表中，这意味着分配了所有VTL
1分页表层次结构。与静态KDP一样，安全内核向hypervisor发送“ModifyVtlProtectionMask”的调用。其目标是将VTL0
SLAT表中的物理页映射为只读。VTL0可以访问这些页面之后，安全内核将复制调用者指定的数据并回调NT。
NT内核使用内存管理器提供的服务来映射VTL0中的客户物理页面。请记住，VTL0和VTL1的整个root分区物理地址空间都映射为标识映射，这意味着在VTL0中有效的客户物理页码在VTL1中也有效。安全内核要求NT内存管理器通过准确地知道应该将页面映射到哪个虚拟地址来映射属于安全池的页面。这要感谢之前在阶段1中计算的增量值(图4)。
分配返回给VTL0中的调用者。与静态KDP一样，底层页面不再可以从VTL0中的任何实体写入。
精明的读者会注意到，上面对KDP的描述只涉及为支持给定受保护内存区域的Guest物理地址建立SLAT保护。KDP不强制保护区域的虚拟地址范围映射是如何转换的。今天，安全内核只定期验证受保护内存区域是否转换为适当的、受SLAT保护的GPA。KDP的设计允许将来扩展对受保护内存区域的地址转换层次结构进行更直接的控制。
## KDP在inbox组件中的应用
为了演示KDP如何为两个inbox组件提供价值，我们将着重介绍在CI.dll和[Windows Defender System
Guard](https://www.microsoft.com/security/blog/2018/04/19/introducing-windows-defender-system-guard-runtime-attestation/) 的具体实现
首先,CI.dll使用KDP的目的是在初始化（即从注册表读取或在启动时生成）后保护内部策略状态。这些数据结构对于保护至关重要，就好像它们被篡改了一样——一个经过适当签名但易受攻击的驱动程序可能会攻击策略数据结构，然后在系统上安装一个未签名的驱动程序。使用KDP可以确保策略数据结构不会被篡改，从而减轻这种攻击。
其次，Windows Defender System
Guard为了提供运行时证明，认证代理只允许连接到证明驱动程序一次。这是因为状态存储在VTL1存储器中。驱动程序将连接状态存储在其内存中，需要对其进行保护，以防止攻击尝试使用可能被篡改的代理重置连接。KDP可以锁定这些变量，并确保只能在代理和驱动程序之间建立一个连接。
代码完整性和Windows Defender System Guard是 Secured-core
PCs机的两个关键特征。KDP增强了对这些重要安全系统的保护，使得攻击者的攻击变得更困难。
这些只是几个示例，说明将内核和驱动程序内存保护为只读对于系统的安全性和完整性是多么有用。随着KDP被更广泛地采用，我们希望能够扩大保护的范围，因为我们希望更广泛地保护数据破坏攻击。
## KDP入门
除了运行基于虚拟化的安全性所需的需求外，动态和静态KDP都没有任何进一步的要求。在理想情况下，VBS可以在任何支持以下操作的计算机上启动：
    1. 英特尔、AMD或ARM虚拟化扩展
    2. 二级地址转换:AMD的NPT, Intel的EPT, ARM的第二阶段地址转换
    3. 可选的硬件MBEC，它降低了与HVCI相关的性能成本
更多关于VBS要求的信息可以在[这里](https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs)找到。在[ Secured-core
PCs](https://www.microsoft.com/en-us/windowsforbusiness/windows10-secured-core-computers?SilentAuth=1)上，支持基于虚拟化的安全性，默认情况下启用硬件支持的安全功能。客户可以从各种合作伙伴供应商处找到安全的核心PC，这些产品具有全面的安全功能，这些功能现在由KDP增强。