The most significant cost of WRK protocol is due to the prepara-
tion phase (called Fpre) that generates the authenticated multiplica-
tive triples. The improved preparation protocol Wang et al. pro-
posed to realize Fpre is similar to batched style of cut-and-choose,
hence able to achieve asymptotic efficiency similar to LEGO proto-
cols. While the focus of the original WRK paper was on designing
authenticated garbling and proving its security, techniques pro-
vided in our work helps to scale up their scheme to run arbitrary
How to efficiently find the best B
Input: ε, n.
Output: the smallest B that satisfies Form (2)≤ ε.
Set t (cid:66) ∞, b0 (cid:66) ⌊− log2 ε⌋, B (cid:66) 2, and repeat the steps
below until it exits from Step 2:
(1) Use the recurrence above to compute PB(n, k) for all
(2) If maxk ∈{1, ...,b0} 2−k · PB(n, k) ≤ ε, then output B and
(3) If B > n, exit with output ⊥.
0 ≤ k ≤ b0.
halt; otherwise, set B (cid:66) B + 1.
Figure 8: Parameter Search for Pool-WRK
size computations with no preparation delay and limited storage
(independent of the circuit size).
Pool Analysis Adapted to WRK. WRK’s expensive preparation
phase also used the ideas of bucketing and batched cut-and-choose,
except that it not only detects faults in the generation of every
multiplicative triple with probability 1/2, but also allows all checked
triples to be used to form buckets. Thus, to specialize our pool analysis
for WRK, we set rc = 1 (since all triples are checked) and rd = 1/2.
Therefore, assuming the bucket size B is a constant, the success
rate (Form (1) of Section 4) of the best attacking strategy becomes
(2)
2−b · PB(n, b)
max
b
where b can be any positive integer (but essentially bounded by
⌊log1−rc rd ε⌋) and the analysis of PB(n, b) is identical to that ap-
peared in Section 4, because like JIMU [38], WRK only requires a
single honestly generated multiplicative triple in each bucket to
guarantee security. As rc is now fixed to 1, the parameter selec-
tion procedure can be significantly simplified to the one described
in Figure 8:
Finally, assuming the bucket size needs to be constant, B calcu-
lated as above is known to be optimal.
y
t
i
r
u
c
e
s
l
a
c
i
t
s
i
t
a
t
s
t
i
b
-
0
4
y
t
i
r
u
c
e
s
l
a
c
i
t
s
i
t
a
t
s
t
i
b
-
4
6
y
t
i
r
u
c
e
s
l
a
c
i
t
s
i
t
a
t
s
t
i
b
-
0
8
WRK
WRK
with
Pool
WRK
WRK
with
Pool
WRK
WRK
with
Pool
Table 6: Compare WRK and Pooled WRK in terms of Fpre.
5
4
3
Bucket Size
Minimal circuit size1
(by # of logical-ANDs)
Minimal circuit size2
(by # of leaky-ANDs)
Minimal pool size3
(by # of leaky-ANDs)
Circuit-size
constraint
Minimal circuit size1
(by # of logical-ANDs)
Minimal circuit size2
(by # of leaky-ANDs)
Minimal pool size3
(by # of leaky-ANDs)
Circuit-size
constraint
Minimal circuit size1
(by # of logical-ANDs)
Minimal circuit size2
(by # of leaky-ANDs)
Minimal pool size3
(by # of leaky-ANDs)
Circuit-size
constraint
280K
3.1K
320
840K
12400
1600
479K
7673
1073
No size constraints
1.2B
780K
21K
3.6B
3120K
105K
1.96B
1963K
68.3K
No size constraints
300B
31M
330K
900B
124M 1650K
501.8B 79.15M 1093K
No size constraints
Benefits. The main benefit the pool brings to the WRK scheme
is improved scalability. Compared to plain WRK, when executing
large circuits the long stalls and the big storage requirement of
the preparation phase are no longer needed. We have listed the
pool parameters and compared them to the plain WRK (Table 6).
A pool allows us to completely drop the circuit-size constraint for
achieving a particular efficiency level. Also, note that the minimal
pool-sizes needed in our approach are only about 60% of the minimal
circuit sizes required by plain WRK. An intuitive explanation of
this phenomenon is that, as the total number of bad entries used
by an attacker is bound by − log2 ε, the probability of having a bad
bucket has to be smaller than an inverse polynomial of the size of
the pool when a pool is employed. Without a pool, however, that
probability will continually increase as the pre-computed leaky-
ANDs are consumed for evaluating circuits. So it requires fewer
leaky-ANDs in the pool to achieve the same level of efficiency.
9 OTHER RELATED WORK
Kreuter et al. [17] proposed a technique to run arbitrarily large-
scale secure computations against malicious adversaries. The basic
1 These numbers are quoted from WRK [36].
2 Each of these numbers is obtained by multiplying the minimal
number of logical AND gates in the circuit and its corresponding
bucket size.
3 Pool size is measured by the number of leaky-ANDs instead of
logical ANDs because the notion of logical-ANDs is less relevant
until a bucket of leaky-ANDs are picked from the pool.
idea is to use an additional set of oblivious transfers to allow the
evaluator to secretly learn either the seed for verifying a circuit or
the input wire-labels for evaluating the circuit. Although Kreuter
et al.’s original protocol was based on MajorityCut, the idea is later
adopted by Wang et al. in their SingleCut protocol [35], which is
by far the most efficient SingleCut protocol in the single-execution
setting. The heavily optimized WMK [35] is able to process 227K
logical-ANDs per second and roughly 50K input/output wires per
second and seems able to run circuits of any size without signifi-
cant preprocessing. In comparison, Pool executes the gates 1.5–2x
slower but is 2.4x, 24x, and 600x faster in handling the evaluator’s
input, garbler’s input, and outputs, and scales up very well. Finally,
it seems clumsy to use [17, 35] to handle RAM-based secure compu-
tations because their underlying cut-and-choose mechanisms are
not very compatible with reactive computations.
Motivated by the need for secure computation as a commodity
service, researchers have conceived asymptotically more efficient
BatchedCut protocols aiming at efficient iterative execution of a
function with different inputs [12, 18]. Lindell et al. proposed an
efficient symmetric-key operation based input consistency enforce-
ment technique and gave the first implementation of such a pro-
tocol [19]. More recently, Rindal and Rosulek [27] have pushed
Kolesnikov et al.’s work on Dual-Execution protocols [11, 15] into
the offline/online setting with an efficient method for input con-
sistency and a lightweight PSI, both tailored to the dual-execution
paradigm. Both works exploited parallel hardware support for min-
imizing the online and offline times. In contrast, our work aims to
batch the cut-and-choose procedure at the basic-gates level and
focuses on single-thread implementations to minimize the num-
ber of CPU cycles required by our protocol. Unlike our approach,
it would be unrealistic to support RAM-based computation using
these protocols.
Damgård et al. proposed SPDZ [5, 6], a protocol capable of sup-
porting more than two participants in computing arithmetic cir-
cuits. It consists of a somewhat homomorphic cryptosystem-based
constant-round offline stage and a linear-round (in circuit depth)
online stage. These protocols would be useful to compute shallow
circuits in low network latency environments but less competitive
comparing to state-of-the-art constant-round LEGO protocols.
10 CONCLUSION
Running gate-level BatchedCut secure computation protocols with
a pool leads to a number of benefits including consistent, faster ex-
ecution of any-size circuits with nearly zero offline processing. We
instantiated this idea with two state-of-the-art secure computation
schemes and incorporated it into a software framework that offers
several valuable properties for delivering actively-secure computa-
tion as an on-demand service. We hope Pool will help spur interest
in developing and deploying practical secure computation services.
ACKNOWLEDGMENTS
We thank Xiao Wang for suggestions on efficient implementa-
tions. This work is supported by NSF award #1464113 and NIH
1U01EB023685-01.
REFERENCES
[1] Arash Afshar, Zhangxiang Hu, Payman Mohassel, and Mike Rosulek. 2015. How
to efficiently evaluate RAM programs with malicious security. In EUROCRYPT.
[2] Donald Beaver, Silvio Micali, and Phillip Rogaway. 1990. The round complexity
of secure protocols. In STOC.
[3] Ran Canetti. 2000. Security and composition of multiparty cryptographic proto-
cols. Journal of Cryptology 13, 1 (2000), 143–202.
[4] Ran Canetti. 2001. Universally composable security: A new paradigm for crypto-
graphic protocols. In FOCS.
[5] Ivan Damgård, Marcel Keller, Enrique Larraia, Valerio Pastro, Peter Scholl, and
Nigel Smart. 2013. Practical covertly secure MPC for dishonest majority–or:
breaking the SPDZ limits. In ESORICS.
[6] Ivan Damgård, Valerio Pastro, Nigel Smart, and Sarah Zakarias. 2012. Multiparty
computation from somewhat homomorphic encryption. In CRYPTO.
[7] Jack Doerner, David Evans, and Abhi Shelat. 2016. Secure Stable Matching at
Scale. In ACM CCS.
[8] Tore Frederiksen, Thomas Jakobsen, Jesper Nielsen, Peter Nordholt, and Claudio
Orlandi. 2013. Minilego: Efficient secure two-party computation from general
assumptions. In EUROCRYPT.
[9] Tore Frederiksen, Thomas Jakobsen, Jesper Nielsen, and Roberto Trifiletti. 2015.
TinyLEGO: An Interactive Garbling Scheme for Maliciously Secure Two-party Com-
putation. http://eprint.iacr.org/2015/309
[10] Yan Huang, David Evans, Jonathan Katz, and Lior Malka. 2011. Faster Secure
Two-Party Computation Using Garbled Circuits. In USENIX Security Symposium.
[11] Yan Huang, Jonathan Katz, and David Evans. 2012. Quid-pro-quo-tocols: Strength-
ening semi-honest protocols with dual execution. In IEEE Symposium on Security
and Privacy.
[12] Yan Huang, Jonathan Katz, Vladimir Kolesnikov, Ranjit Kumaresan, and Alex
Malozemoff. 2014. Amortizing garbled circuits. In CRYPTO.
[13] Yuval Ishai, Joe Kilian, Kobbi Nissim, and Erez Petrank. 2003. Extending oblivious
transfers efficiently. In CRYPTO.
[14] Marcel Keller, Emmanuela Orsini, and Peter Scholl. 2015. Actively secure OT
extension with optimal overhead. In CRYPTO.
[15] Vladimir Kolesnikov, Payman Mohassel, Ben Riva, and Mike Rosulek. 2015. Richer
efficiency/security trade-offs in 2PC. In TCC.
[16] Vladimir Kolesnikov and Thomas Schneider. 2008. Improved garbled circuit: Free
XOR gates and applications. In International Colloquium on Automata, Languages,
and Programming.
[17] Benjamin Kreuter, Abhi Shelat, and Chih-Hao Shen. 2012. Billion-Gate Secure
Computation with Malicious Adversaries. In USENIX Security Symposium.
[18] Yehuda Lindell and Ben Riva. 2014. Cut-and-choose Yao-based secure computa-
tion in the online/offline and batch settings. In CRYPTO.
[19] Yehuda Lindell and Ben Riva. 2015. Blazing fast 2pc in the offline/online setting
with security for malicious adversaries. In ACM CCS.
[20] Chang Liu, Xiao Wang, Kartik Nayak, Yan Huang, and Elaine Shi. 2015. Oblivm: A
programming framework for secure computation. In IEEE Symposium on Security
and Privacy.
[21] Dahlia Malkhi, Noam Nisan, Benny Pinkas, and Yaron Sella. 2004. Fairplay-Secure
Two-Party Computation System. In USENIX Security Symposium.
[22] Moni Naor and Benny Pinkas. 2001. Efficient oblivious transfer protocols. In
[23] Kartik Nayak, Xiao Wang, Stratis Ioannidis, Udi Weinsberg, Nina Taft, and Elaine
Shi. 2015. GraphSC: Parallel secure computation made easy. In IEEE Symposium
on Security and Privacy.
[24] Jesper Nielsen and Claudio Orlandi. 2009. LEGO for two-party secure computa-
SODA.
tion. In TCC.
[25] Jesper Nielsen, Thomas Schneider, and Roberto Trifiletti. 2017. Constant Round
Maliciously Secure 2PC with Function-independent Preprocessing using LEGO.
In NDSS.
[26] Chris Peikert, Vinod Vaikuntanathan, and Brent Waters. 2008. A framework for
efficient and composable oblivious transfer. In CRYPTO.
[27] Peter Rindal and Mike Rosulek. 2016. Faster malicious 2-party secure computation
with online/offline dual execution. In USENIX Security Symposium.
[28] Ebrahim Songhori, Siam Hussain, Ahmad-Reza Sadeghi, Thomas Schneider, and
Farinaz Koushanfar. 2015. Tinygarble: Highly compressed and scalable sequential
garbled circuits. In IEEE Symposium on Security and Privacy.
[29] Stefan Tillich and Nigel Smart. 2014. Circuits of Basic Functions Suitable For MPC
and FHE. http://www.cs.bris.ac.uk/Research/CryptographySecurity/MPC/
[30] Xiao Wang, Hubert Chan, and Elaine Shi. 2015. Circuit oram: On tightness of
the goldreich-ostrovsky lower bound. In ACM CCS.
[31] Xiao Wang, Yan Huang, Hubert Chan, Abhi Shelat, and Elaine Shi. 2014. SCORAM:
oblivious RAM for secure computation. In ACM CCS.
[32] Xiao Wang, Yan Huang, Yongan Zhao, Haixu Tang, XiaoFeng Wang, and Diyue
Bu. 2015. Efficient genome-wide, privacy-preserving similar patient query based
on private edit distance. In ACM CCS.
[33] Xiao Wang, Chang Liu, Yan Huang, Kartik Nayak, Elaine Shi, and Michael Hicks.
2015. ObliVM. https://github.com/oblivm
[34] Xiao Wang, Alex Malozemoff, and Jonathan Katz. 2016. EMP-toolkit: Efficient
MultiParty computation toolkit. https://github.com/emp-toolkit
[35] Xiao Wang, Alex Malozemoff, and Jonathan Katz. 2017. Faster Secure Two-Party
Computation in the Single-Execution Setting. In EUROCRYPT.
[36] Xiao Wang, Samuel Ranellucci, and Jonathan Katz. 2017. Authenticated garbling
and efficient maliciously secure two-party computation. In ACM CCS.
[37] Samee Zahur, Xiao Wang, Mariana Raykova, Adrià Gascón, Jack Doerner, David
Evans, and Jonathan Katz. 2016. Revisiting square-root oram: Efficient random
access in multi-party computation. In IEEE Symposium on Security and Privacy.
[38] Ruiyu Zhu and Yan Huang. 2017. JIMU: Faster LEGO-based Secure Computation
using Additive Homomorphic Hashes. In ASIACRYPT.
[39] Ruiyu Zhu, Yan Huang, Abhi Shelat, and Jonathan Katz. 2016. The Cut-and-
Choose Game and its Application to Cryptographic Protocols. In USENIX Security
Symposium.