# Adobe ColdFusion：CVE-2017-3066漏洞的其他利用思路
|
##### 译文声明
本文是翻译文章，文章原作者 Matthias Kaiser ，文章来源：https://codewhitesec.blogspot.hk/
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 一、前言
在最近一次渗透测试任务中，我的小伙伴Thomas遇到了几台服务器，这几台服务器上运行着Adobe ColdFusion
11以及12平台，其中某些服务器存在CVE-2017-3066漏洞，但无法通过TCP协议外连，因此无法利用这个漏洞。Thomas向我求助，问我是否有办法帮他获取SYSTEM权限的shell，因此我把我所做的工作汇成这篇文章与大家一起分享。
## 二、Adobe ColdFusion & AMF简介
在讨论技术细节之前，我先简单介绍一下Adobe ColdFusion（CF）。Adobe
ColdFusion是类似ASP.net之类的应用程序开发平台（Application Development
Platform），然而诞生时间要更为久远。开发者可以使用Adobe ColdFusion来搭建网站、SOAP以及REST Web服务，使用Action
Message Format（AMF）与Adobe Flash进行交互。
AMF协议是一种自定义的二进制序列化协议。该协议有两种格式：AMF0以及AMF3。一个Action
Message由头部（header）以及主体（body）所组成。AMF0以及AMF3中支持多种数据类型。比如，AMF3格式支持的协议元素以及类型标识符如下所示：
    Undefined      - 0x00
    Null           - 0x01
    Boolean        - 0x02
    Boolean        - 0x03
    Integer        - 0x04
    Double         - 0x05
    String         - 0x06
    XML            - 0x07
    Date           - 0x08
    Array          - 0x09
    Object         - 0x0A
    XML End        - 0x0B
    ByteArray      - 0x0C
如果想了解AMF0以及AMF3二进制消息格式的详细内容，大家可以查阅相关[维基百科](https://en.wikipedia.org/wiki/Action_Message_Format)页面。
不同语言中关于AMF的具体实现也有所不同。对于Java来说，我们可以使用Adobe BlazeDS（现在是Apache BlazeDS），Adobe
ColdFusion中也用到了这个技术。
BlazeDS AMF序列化器（serializer）可以序列化复杂的对象图（object graph）。序列化器会从根对象（root
object）开始处理，递归序列化根对象成员。
在序列化复杂对象方面，BlazeDS支持两种常用的序列化技术：
1、序列化Bean属性（AMF0以及AMF3）；
2、使用Java的`java.io.Externalizable`接口来序列化（AMF3）。
###  序列化Bean属性
这种技术需要待序列化的对象具有公开的无参数构造函数，每个成员都拥有公开的Getter以及Setter方法（符合JavaBeans规范）。
为了收集某个对象所有的成员值，AMF序列化器会在序列化过程中调用所有的Getter方法。成员名、成员值以及对象的类名存放在Action消息的body区中。
在反序列化过程中，程序会从Action消息中获取类名，构造新的对象，然后以成员值作为参数调用每个成员名对应的set方法。这一个过程由专门的方法来实现，比如`flex.messaging.io.amf.Amf3Input`类中的`readScriptObject()`方法或者`flex.messaging.io.amf.Amf0Input`类中的`readObjectValue()`方法。
### 使用`java.io.Externalizable`接口序列化
如果某些类实现（implement）了`java.io.Externalizable`接口（继承自`java.io.Serializable`），BlazeDS还支持这些类的复杂对象的序列化。
    public abstract interface Externalizable
      extends Serializable
    {
      public abstract void writeExternal(ObjectOutput paramObjectOutput)
        throws IOException;
      public abstract void readExternal(ObjectInput paramObjectInput)
        throws IOException, ClassNotFoundException;
    }
实现这一接口的每个类都需要自己提供反序列化逻辑，调用相关方法来处理`java.io.ObjectInput`对象，读取序列化后的类型及字符串（比如`method
read(byte[] paramArrayOfByte)`）。
在AMF3中对某个对象（类型标识符为0xa）进行反序列化时，会调用`flex.messaging.io.amf.Amf3Input`类的`readScriptObject()`方法。在如下代码的759行，`readExternalizable`方法会被调用，该方法会在待反序列化的对象上调用`readExternal()`方法。
    /*      */   protected Object readScriptObject()
    /*      */     throws ClassNotFoundException, IOException
    /*      */   {
    /*  736 */     int ref = readUInt29();
    /*      */     
    /*  738 */     if ((ref & 0x1) == 0) {
    /*  739 */       return getObjectReference(ref >> 1);
    /*      */     }
    /*  741 */     TraitsInfo ti = readTraits(ref);
    /*  742 */     String className = ti.getClassName();
    /*  743 */     boolean externalizable = ti.isExternalizable();
    /*      */     
    /*      */
    /*      */
    /*  747 */     Object[] params = { className, null };
    /*  748 */     Object object = createObjectInstance(params);
    /*      */     
    /*      */
    /*  751 */     className = (String)params[0];
    /*  752 */     PropertyProxy proxy = (PropertyProxy)params[1];
    /*      */     
    /*      */
    /*  755 */     int objectId = rememberObject(object);
    /*      */     
    /*  757 */     if (externalizable)
    /*      */     {
    /*  759 */       readExternalizable(className, object); //<- call to readExternal
    /*      */     }
    /*      */     //...
    /*      */   }
阅读上述文字后，大家应该对Adobe ColdFusion以及AMF有了基本的了解。
## 三、已有成果
Chris Gates（[@Carnal0wnage](https://github.com/Carnal0wnage
"@Carnal0wnage")）之前发表过一篇[文章](http://www.carnal0wnage.com/papers/LARES-ColdFusion.pdf)，详细介绍了如何渗透测试ColdFusion，是难得的一篇好文。
Wouter Coekaerts（[@WouterCoekaerts](https://github.com/WouterCoekaerts
"@WouterCoekaerts")）也在自己的[博客](http://wouter.coekaerts.be/2011/amf-arbitrary-code-execution)中提到，反序列化不可信的AMF数据是非常危险的一种行为。
如果在Flexera/Secunia数据库中查找历史上已有的Adobe
ColdFusion漏洞信息，你会发现这些漏洞大多数为XSS、XXE或者信息泄露漏洞。
最近的几个漏洞为：
    通过RMI实现不可信数据的反序列化（CVE-2017-11283/4 by @nickstadb）
    XXE（CVE-2017-11286 by Daniel Lawson of @depthsecurity）
    XXE（CVE-2016-4264 by @dawid_golunski）
## 四、CVE-2017-3066
2017年，AgNO3 GmbH的Moritz Bechler以及我的小伙伴Markus Wulftange各自独立发现了Apache
BlazeDS中的CVE-2017-3066漏洞。
这个漏洞的要点是Adobe Coldfusion中没有采用可信类的白名单机制。因此如果某个类位于Adobe
ColdFusion的类路径（classpath）中，只要这些类符合Java
Beans规范或者实现了`java.io.Externalizable`，那么就可以发送到服务器进行反序列化。Moritz和Markus两个人都发现，实现了`java.io.Externalizable`接口的JRE类（`sun.rmi.server.UnicastRef2`以及`sun.rmi.server.UnicastRef`）会在AMF3反序列化过程中触发一个TCP出站连接。当成功连接到攻击者的服务器后，程序会使用Java的原生反序列化方法（`ObjectInputStream.readObject()`）来反序列化服务器的响应数据。这两个人都找到了一个非常好的“桥梁”，可以将AMF反序列化与Java的原生反序列化过程结合起来，这样许多公开的利用代码就可以用在这种场景中。大家可以访问Markus的[博客](http://codewhitesec.blogspot.de/2017/04/amf.html)了解关于该漏洞的详细信息。Apache通过`flex.messaging.validators.ClassDeserializationValidator`类引入了一种验证机制，其中包含一个默认的白名单，但也可以使用配置文件来进行配置。详细信息可以查阅Apache
BlazeDS的发行[说明](http://www.apache.org/dist/flex/BlazeDS/4.7.3/RELEASE_NOTES)。
## 五、CVE-2017-3066的其他利用思路
本文开头提到过，我的小伙伴Thomas向我请求帮助，希望能够在没有出站连接的条件下同样能够利用这个漏洞。
先前我已经快速阅读过 Moritz Bechler发表的研究论文（[Java Unmarshaller
Security](https://github.com/mbechler/marshalsec/blob/master/marshalsec.pdf)），论文中他分析了几种“Unmarshaller”，其中就包括BlazeDS。Moritz
Bechler所提供的漏洞利用载荷不适用我们这种场景，因为classpath中缺少相关的库。
因此我还是决定按照自己常用的方法来挖掘。面对Java时，我首先会想到我最喜欢的“逆向工程工具”：Eclipse。Eclipse配上强大的反编译插件[JD-Eclipse](https://github.com/java-decompiler/jd-eclipse)就足以应付动态以及静态分析场景。之前我也是一名开发者，习惯于使用IDE，这样开发起来能够更加方便，使非常低效且容易出错的反编译工作能够顺利推进。我新建了一个Java工程，将Adobe