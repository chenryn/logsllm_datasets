site logins.
https:
//scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-
logins.html. (August 2008).
[14] Daniel Fett, Ralf Kuesters, and Guido Schmitz. 2014. An Expressive Model for the
Web Infrastructure: Definition and Application to the BrowserID SSO System.
(2014). arXiv:cs.CR/1403.1866
[15] I. Fette and A. Melnikov. 2011. The WebSocket Protocol. RFC 6455. IETF. http:
//tools.ietf.org/rfc/rfc6455.txt
[16] Nethanel Gelernter and Amir Herzberg. 2015. Cross-site search attacks. In
Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications
Security. ACM, 1394–1405.
[17] Thomas Gross, Birgit Pfitzmann, and Ahmad-Reza Sadeghi. 2005. Browser Model
for Security Analysis of Browser-Based Protocols. IACR Cryptology ePrint Archive
2005, 127. https://doi.org/10.1007/11555827_28
[18] Jeremiah Grossman. 2012.
I Know What Websites You Are Logged-In To
(Login-Detection via CSRF). http://blog.whitehatsec.com/i-know-what
-websites-you-are-logged-in-to-login-detection-via-csrf/. (October
2012).
[19] Chong Guan, Kun Sun, Zhan Wang, and WenTao Zhu. 2016. Privacy breach by ex-
ploiting postmessage in html5: Identification, evaluation, and countermeasure. In
Proceedings of the 11th ACM on Asia Conference on Computer and Communications
Security. 629–640.
[20] Gabor Gyorgy Gulyas, Doliere Francis Some, Nataliia Bielova, and Claude Castel-
luccia. 2018. To extend or not to extend: on the uniqueness of browser extensions
and web logins. In Proceedings of the 2018 Workshop on Privacy in the Electronic
Society. 14–27.
[21] Mario Heiderich. 2020. HTTPLeaks. https://github.com/cure53/HTTPLeaks.
[22] Mario Heiderich, Alex Inführ, Fabian Fäßler, Nikolei Krein, Masato Kinugawa,
Tsang-Chi Hong, Dario Weißler, and Paula Pustulka. 2017. Cure53’s Browser Se-
curity White Paper. (2017). https://raw.githubusercontent.com/cure53/browser-
sec-whitepaper/master/browser-security-whitepaper.pdf
[23] Luan Herrera. 2020. XS-Leaks in redirect flows. https://docs.google.com/
presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og.
(January 2020).
[24] Gareth Heyes. 2015. Abusing Chrome’s XSS auditor to steal tokens. https:
//portswigger.net/research/abusing-chromes-xss-auditor-to-steal-tokens. (Au-
gust 2015).
[25] Gareth Heyes. 2019. XS-Leak: Leaking IDs using focus. https://portswigger.net/
research/xs-leak-leaking-ids-using-focus. (October 2019).
(June 2020).
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1783[26] Raymond Hill. 2020. Blocking mode uBlock Wiki. https://github.com/gorhill/
uBlock/wiki/Blocking-mode. (October 2020).
[27] Egor Homakov. 2013. Disclose domain of redirect destination taking adven-
tadge of CSP. https://bugs.chromium.org/p/chromium/issues/detail?id=313737.
(October 2013).
[28] Ian Jacobs, Zach Koch, Domenic Denicola, Roy McElmurry, Rouslan Solomakhin,
and Marcos Caceres. 2019. Payment Request API. Candidate Recommenda-
tion. W3C. https://www.w3.org/TR/2019/CR-payment-request-20191212/#show-
method.
[29] Arvind Jain, Zhiheng Wang, Anderson Quach, Jatinder Mann, and Todd
Reifsteck. 2017.
Candidate Recommendation.
W3C. https://www.w3.org/TR/2017/CR-resource-timing-1-20170330/#resources-
included.
Resource Timing Level 1.
[30] Artur Janc, Krzysztof Kotowicz, Lukas Weichselbaum, and Roberto Clapis. 2020.
Information Leaks via Safari’s Intelligent Tracking Prevention. https://arxiv.org/
abs/2001.07421. (January 2020).
[31] Artur Janc and Mike West. 2020. Oh, the Places You’ll Go! Finding Our Way Back
from the Web Platform’s Ill-conceived Jaunts. In 2020 IEEE European Symposium
on Security and Privacy Workshops (EuroS&PW). IEEE, 673–680.
[32] Soroush Karami, Panagiotis Ilia, and Jason Polakis. 2021. Awakening the Web’s
Sleeper Agents: Misusing Service Workers for Privacy Leakage. In Network and
Distributed System Security Symposium (NDSS).
[33] Soroush Karami, Panagiotis Ilia, Konstantinos Solomos, and Jason Polakis. 2020.
Carnus: Exploring the Privacy Threats of Browser Extension Fingerprinting. In
27th Annual Network and Distributed System Security Symposium, NDSS 2020, San
Diego, California, USA, February 23-26, 2020. The Internet Society.
[34] Eiji Kitamura. 2020. Gaining security and privacy by partitioning the cache. https:
//developers.google.com/web/updates/2020/10/http-cache-partitioning. (Octo-
ber 2020).
[35] Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss, Werner
Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, et al. 2019.
Spectre attacks: Exploiting speculative execution. In 2019 IEEE Symposium on
Security and Privacy (SP). IEEE, 1–19.
[36] Sangho Lee, Hyungsub Kim, and Jong Kim. 2015. Identifying Cross-origin Re-
source Status Using Application Cache. In 22nd Network and Distributed System
Security Symposium (NDSS 2015). https://www.microsoft.com/en-us/research/
publication/identifying-cross-origin-resource-status-using-application-cache/
[37] Sebastian Lekies, Ben Stock, Martin Wentzel, and Martin Johns. 2015. The
Unexpected Dangers of Dynamic JavaScript. In 24th USENIX Security Symposium
(USENIX Security 15). 723–735. https://publications.cispa.saarland/987/ pub_id:
1055 Bibtex: lekies2015unexpected URL date: None.
[38] Ron Masas. 2019. Browser Side Channels. https://github.com/xsleaks/xsleaks/
wiki/Browser-Side-Channels. (September 2019).
[39] Ron Masas. 2019. Server Side Redirect Detection. https://xsleaks.github.io/
xsleaks/examples/redirect/. (September 2019).
[40] MDN web docs. 2020. Fetch API. https://developer.mozilla.org/en-US/docs/Web/
API/Fetch_API. (June 2020).
[41] Seyed Mirheidari, Sajjad Arshad, Kaan Onarlioglu, Bruno Crispo, Engin Kirda,
and William Robertson. 2019. Cached and Confused: Web Cache Deception in
the Wild. (12 2019).
[42] Shravan Narayan, Craig Disselkoen, Tal Garfinkel, Nathan Froyd, Eric Rahm,
Sorin Lerner, Hovav Shacham, and Deian Stefan. 2020. Retrofitting Fine Grain
Isolation in the Firefox Renderer. In 29th USENIX Security Symposium (USENIX
Security 20). USENIX Association, 699–716. https://www.usenix.org/conference/
usenixsecurity20/presentation/narayan
[43] Marcus Niemietz and Jörg Schwenk. 2018. Out of the Dark: UI Redressing and
Trustworthy Events. In Cryptology and Network Security, Srdjan Capkun and
Sherman S. M. Chow (Eds.). Springer International Publishing, Cham, 229–249.
[44] Lukasz Olejnik, Claude Castelluccia, and Artur Janc. 2012. Why johnny can’t
browse in peace: On the uniqueness of web browsing history patterns. In 5th
Workshop on Hot Topics in Privacy Enhancing Technologies (HotPETs 2012).
[45] S. Roth, Timothy Barron, S. Calzavara, Nick Nikiforakis, and Ben Stock. 2020.
Complex Security Policy? A Longitudinal Analysis of Deployed Content Security
Policies. In NDSS.
[46] Jörg Schwenk, Marcus Niemietz, and Christian Mainka. 2017. Same-origin policy:
Evaluation in modern browsers. In 26th USENIX Security Symposium (USENIX
Security 17). 713–727.
[47] Michael Smith, Craig Disselkoen, Shravan Narayan, Fraser Brown, and Deian
Stefan. 2018. Browser history re: visited. In 12th USENIX Workshop on Offensive
Technologies (WOOT 18).
[48] Jungkee Song, Alex Russell, Marijn Kruisselbrink, and Jake Archibald.
Candidate Recommendation. W3C.
2019.
https://www.w3.org/TR/2019/CR-service-workers-1-20191119/.
Service Workers
[49] Web Platform Tests / Open Source. 2021. Web Platform Tests Github Page. (2021).
1.
https://github.com/web-platform-tests/wpt
[50] Cristian-Alexandru Staicu and Michael Pradel. 2019. Leaky images: targeted
privacy attacks in the web. In 28th USENIX Security Symposium (USENIX Security
19). 923–939.
[51] Avinash Sudhodanan, Soheil Khodayari, and Juan Caballero. 2020. Cross-Origin
State Inference (COSI) Attacks: Leaking Web Site States through XS-Leaks. In
27nd Network and Distributed System Security Symposium (NDSS 20).
Security: XSS filter information leak.
[52] Takeshi Terada. 2014.
https://
bugs.chromium.org/p/chromium/issues/detail?id=396544. (July 2014).
[53] Terjanq. 2019. Mass XS-Search using Cache Attack. https://medium.com/
@terjanq/massive-xs-search-over-multiple-google-products-416e50dd2ec6. (No-
vember 2019).
[54] terjanq. 2019.
Protected tweets exposure through the URL.
https://
hackerone.com/reports/491473. (April 2019).
[55] terjanq. 2019. Twitter: Detect X-Frame-Options header in Chrome. https://
twitter.com/terjanq/status/1111600071014080517. (March 2019).
[56] terjanq. 2020. Issue 1157818: performance API reveals information about redirects
(XS-Leak). https://crbug.com/1157818. (December 2020).
[57] Tom Van Goethem, Wouter Joosen, and Nick Nikiforakis. 2015. The clock is
still ticking: Timing attacks in the modern web. In Proceedings of the 22nd ACM
SIGSAC Conference on Computer and Communications Security. ACM, 1382–1393.
[58] Tom Van Goethem, Christina Pöpper, Wouter Joosen, and Mathy Vanhoef. 2020.
Timeless timing attacks: Exploiting concurrency to leak secrets over remote
connections. In 29th {USENIX} Security Symposium ({USENIX} Security 20).
1985–2002.
http:
//sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html. (March
2019).
HTTP Cache Cross-Site Leaks.
[59] Eduardo Vela.
[60] Markus Vervier, Michele Orrù, Berend-Jan Wever, and Eric Sesterhenn. 2017.
Cure53’s Browser Security White Paper. (2017). https://browser-security.x41-
dsec.de/X41-Browser-Security-White-Paper.pdf
[61] MDN web docs. 2019. CSP: frame-ancestors. https://developer.mozilla.org/en-US/
docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors. (November
2019).
[62] MDN web docs. 2020. Web APIs: History. https://developer.mozilla.org/en-
2019.
US/docs/Web/API/History. (February 2020).
[63] Mike West. 2013. Cross-origin leakage with securitypolicyviolation events
and paths in source expressions. https://lists.w3.org/Archives/Public/public-
webappsec/2013May/0022.html. (May 2013).
[64] Mike West. 2018. Content Security Policy Level 3. W3C Working Draft. W3C.
https://www.w3.org/TR/2018/WD-CSP3-20181015/.
[65] Mike West. 2020. Fetch Metadata Request Headers. https://w3c.github.io/
webappsec-fetch-metadata/. (April 2020).
[66] Web Hypertext Application Technology Working Group (WHATWG). 2020.
https://
Fetch - Living Standard: Cross-Origin-Resource-Policy header.
fetch.spec.whatwg.org/#cross-origin-resource-policy-header. (August 2020).
[67] Web Hypertext Application Technology Working Group (WHATWG). 2020. Fetch
- Living Standard: HTTP-redirect fetch. https://fetch.spec.whatwg.org/#http-
redirect-fetch. (August 2020).
[68] Web Hypertext Application Technology Working Group (WHATWG). 2020. Fetch
- Living Standard: Requests. https://fetch.spec.whatwg.org/#requests. (August
2020).
[69] Web Hypertext Application Technology Working Group (WHATWG). 2020.
HTML - Living Standard: contentDocument. https://html.spec.whatwg.org/
multipage/iframe-embed-object.html#dom-iframe-contentdocument. (August
2020).
[70] Web Hypertext Application Technology Working Group (WHATWG).
2020.
https:
//html.spec.whatwg.org/multipage/browsing-the-web.html#scroll-to-fragid.
(August 2020).
HTML - Living Standard: Navigating to a fragment.
[71] XS-Leaks Wiki. 2020. CORB Leaks. https://xsleaks.com/docs/attacks/browser-
features/corb/. (October 2020).
features/corp/. (October 2020).
[72] XS-Leaks Wiki. 2020. CORP Leaks. https://xsleaks.com/docs/attacks/browser-
[73] John Wilander. 2019.
https:
//webkit.org/blog/9661/preventing-tracking-prevention-tracking/. (December
2019).
Preventing Tracking Prevention Tracking.
[74] John Wilander. 2020. Full Third-Party Cookie Blocking and More. https:
//webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/. (March
2020).
[75] Gilbert Wondracek, Thorsten Holz, Engin Kirda, and Christopher Kruegel. 2010.
A practical attack to de-anonymize social network users. In 2010 IEEE Symposium
on Security and Privacy. IEEE, 223–238.
[76] Takashi Yoneuchi. 2019. XS-Leak with Resource Timing API and CSP Embedded
Enforcement. https://crbug.com/1105875. (July 2019).
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1784A OVERVIEW OF XS-LEAK ATTACKS
A.1 Detectable Difference: Status Code
An attacker is able to distinguish different HTTP response status
codes to detect server errors, client errors, authentication errors, or
server redirects cross-origin.
Leak Technique: Event Handler. Event handlers can be at-
tached to an HTML tag which includes a cross-origin resource.
Depending on the status code, content-type, and other response
headers, different events handlers are triggered (e.g., onload or
onerror) [50, 51]. By using event handler as a leak technique, an
attacker is allowed to detect the presence of headers, HTTP errors,
and media types.
Leak Technique: MediaError. In FF, it is possible to accurately
leak a cross-origin request’s status code by using an error message
leak technique generated by a video or audio element as inclusion
methods.
A.2 Detectable Difference: API Usage
An attacker is able to detect the usage of Web APIs cross-origin.
Service Worker. Service workers are event-driven script con-
texts that run at an origin [48]. They run in the background of a
web page and can intercept, modify, and cache resources to create
offline web application. Karami et al. [32] introduced leak tech-
niques to detect if a service worker is registered for a specific origin.
They used iframes as an inclusion method on resources that have
previously been cached by a service worker.
A.3 Detectable Difference: Redirects
It is possible to detect if a web application has navigated the user to
a different page. This is not limited to HTTP redirects but redirects
triggered by JavaScript or HTML code can also be detected.
Fetch Redirect. The Fetch API provides an interface for fetching
resources by using JavaScript code. The API allows various config-
uration options. One of these options is the redirect mode [68]. If
it is set to manual, redirects are not automatically followed. Based
on the discussion of Janc et al. [30], browsers like GC and SA allow
the attacker to check the response’s type as a leak technique after
the redirect is finished.
URL Max Length. Web applications may not adequately handle
long URLs. Usually, web servers reject a request when the URL
exceeds a specific limit and return an error with status code 414
URI Too Long or 413 Payload Too Large. Modern browsers can
typically handle longer URLs, although 2 megabytes are a common
limit. If a web application redirects, it may try to preserve any
query parameters that are attached to the original request (e.g., as
implemented by twitter.com). Additionally, the URL length may
increase in size when a redirect occurs. By considering a global limit
as a leak technique, an attacker can consequently craft a request
that exceeds the server’s URL character limit to trigger an error
once redirected. As an example, Masas [38, 39] showed how an
attacker could gather the length of a URL that triggers an error on
a specific server to be used within an XS-Leak.
Max Redirect Browsers try to prevent infinite redirect loops.
The Fetch standard specifies that after twenty redirects a network
error should be returned [67]. Herrera [23] showed that this limit
can be abused to detect the number of redirects of a cross-origin
resource. For example, an attacker can redirect nineteen times
before redirecting to the target site that may potentially redirect. If
it redirects, an error is triggered that can then be detected by the
attacker page.
History Length. The History API allows JavaScript code to
manipulate the browser history, which saves the pages visited by a
user [62]. An attacker can use the length property as an inclusion
method: to detect JavaScript and HTML navigation. Multiple works
have studied the browser history and show how to abuse it to
determine whether a user has accessed a certain website [44, 47,
54, 75].
CSP Violation. An XS-Leak can use the CSP [64] to detect if a
cross-origin site was redirected to a different origin. This leak can
detect the redirect, but additionally, the domain of the redirect target
leaks. These techniques were discussed by West [63] and Homakov
[27]. The basic idea of this attack is to allow the target domain on
the attacker site. Once a request is issued to the target domain, it
redirects to a cross-origin domain. CSP blocks the access to it and
creates a violation report used as a leak technique. Depending on
the browser, this report may leak the target location of the redirect.
CSP Detection. Newer browsers do not leak the target location
of the redirect in the violation report. However it is still possible
to detect if a cross-origin redirect occurred, because the request is
still blocked by the CSP, i.e., the violation report can be used as a
leak technique.
A.4 Detectable Difference: Page Content
An attacker can detect content in HTML documents or resources.
The detection includes HTML attributes, embedded resources, and
CSS rules.
Cache. For avoiding unnecessary data transfers and server re-
quests, browsers implement HTTP caching to increase performance
when loading web pages. Vela [59] discovered that most browsers
use one shared cache for all websites. Regardless of their origin, it
is possible to deduct whether a target page has requested a specific
file. To detect this request, the attacker page executes the following
leak technique it clears the file from the cache, it opens the target
page in a pop-up or iframe, and finally, it checks if the file is present
in the cache again.
Frame Count. HTML iframe elements can be used to embed
other documents within the current one. Developers use them to
isolate third-party content or to include widgets and advertisements.
Although JavaScript APIs only allow limited access to cross-origin
window objects, the number of frames on a page can still be read. As
shown by Grossman [18] and Masas [38], an attacker can use this
length to detect state differences if the number of frames changes
between them. A target web page may include a different number
of frames depending on the user state. With readable attributes as
a leak technique, properties like length help an attacker to leak
the frame number if it is possible to obtain a window handle to the
target. A window handle can be obtained by the following inclusion
methods: embedding the target page in an iframe or by opening a
pop-up using window.open.
Media Dimensions. Media elements, such as video and image,
can sometimes differ in size. Web applications may dynamically
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1785This allows an attacker to detect specific CSP directive of a cross-
origin page, if it is possible to detect the error page. This leak was
reported to GC by Takashi Yoneuchi [76]. Although, this bug is now
marked as fixed, we found a new leak technique that can detect the
error page, because the underlying problem was never fixed.
CORP. The CORP header is a relatively new web platform secu-
rity feature that when set blocks no-cors cross-origin requests to
the given resource (cf. Section 7). The presence of the header can
be detected, because a resource protected with CORP will throw
an error when fetched.
CORB. CORB is an algorithm in the browser that blocks dubious
cross-origin resource requests before they reach the webserver
(cf. Section 7). This feature can be used to detect the presence
of Content-Type and Content-Type-Options headers, because
CORB is only enforced for specific content-types together with the
nosniff option. An attacker can use a combination of event handlers
as a leak technique to detect CORB.
ContentDocument XFO. In Chrome, when a page is not al-
lowed to be embedded on a cross-origin page, because the X-Frame-
Options (XFO) header is set to deny or same-origin, an error page
is shown instead. For objects, this error page can be detected by
checking the contentDocument property [69]. Typically, this prop-
erty returns null because access to a cross-origin embedded docu-
ment is not allowed. However, due to Chrome’s rendering of the
error page, an empty document object is returned instead. This
does not work for iframes or in other browsers. Developers may
forget to set X-Frame-Options for all pages and especially error
pages often miss this header. As a leak technique, an attacker may
be able to differentiate between different user states by checking
for it.
Download Detection. The Content-Disposition header in-
dicates if the browser is either supposed to downloaded content
or displayed it inline. Masas [38] has demonstrated with a leak
technique that an attacker can detect downloads by using the in-
clusion method: iframe. If the iframe is still accessible, the file was
downloaded; this is the case because in most browsers a down-
load does not trigger a navigation and the iframe is still considered
same-origin. This attack also works with pop-ups created with
window.open.
generate media files depending on user information or add water-
marks that change media size. An attacker can use standard DOM
APIs to detect these differences [38]. For example, media resources
can be embedded cross-origin with  or  HTML tags
and properties such as the dimensions for image elements can be
read.
Media Duration. Similarly, the duration of audio and video
elements can be read cross-origin.
Id Attribute. Hyperlinks are often used to link to specific parts
of a document, and browsers will automatically scroll to them when
the identifier is specified in the fragment part of a URL [70]. This
behavior can be used to detect if a specific identifier is present on
a page. For certain HTML elements as inclusion methods, GC and
SA will not only scroll to them but also focus them. For example,
 will gain focus when the fragment of the
URL is set to leakme. In GC, this even works in cross-origin iframes.
However, an attacker can not directly detect that the element got
focused because of the SOP. To get around this, an onblur handler
can be registered on the attacker page. Once the iframe receives
focus, the attacker page will lose focus and a blur event triggers.
Heyes [25] discovered this leak technique and it can be used to
detect login pages or to leak sensitive data from the id or name
attribute.
CSS Property. Web applications may change website styling de-
pending on the status of the user. As described by Evans [13], these
changes can be used to detect differences in Cascading Style Sheets
(CSS) rules. Cross-origin CSS files can be embedded on the attacker