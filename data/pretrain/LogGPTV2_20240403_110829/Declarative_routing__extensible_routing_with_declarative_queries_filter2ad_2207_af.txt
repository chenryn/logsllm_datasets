 120
 100
 80
 60
 40
 20
 0
AvgPathRTT
AvgLinkRTT
 0  5  10  15  20  25  30  35  40  45
Time (min)
)
s
m
(
T
T
R
 120
 100
 80
 60
 40
 20
 0
AvgPathRTT
AvgLinkRTT
 0  5  10  15  20  25  30  35  40  45
Time (min)
Figure 10: AvgPathRTT
during query execution.
Figure 11: Query Band-
width utilization.
Figure 12: RTTs during
query execution.
Figure 13: RTTs (with
smoothing).
Figure 11 shows the per-node communication overhead for
the same experiments.
Initially, the per-node communica-
tion overhead increases steadily peaking at 8 KBps, and 11
KBps, respectively. As more shortest paths are discovered,
the communication overhead starts to decrease steadily after
15 sec. The average communication overhead over the entire
query execution period is 2:6 KBps for Sparse-Random, and
4:7 KBps for Dense-Random, respectively. While in the case
of the Dense-Random topology the query has a higher over-
head, it also produces paths with lower RTTs (see Table 1).
9.2.3 Path Adaptation
In this section, we consider the continuous version of the all-
pairs shortest (RTT) paths query. After the initial query has
computed all-pairs shortest paths, we begin to update the link
RTT measurements every (cid:12)ve minutes, and incrementally re-
compute new shortest paths as described in Section 8.
In
order to avoid ping congestion we spread the measurements
uniformly across each (cid:12)ve minute interval.
Figure 12 shows a representative experiment for the Dense-
Random topology over a 50 minute interval during a busy
period on PlanetLab. The AvgPathRTT value (solid line)
follows the (cid:13)uctuations of AvgLinkRTT (dotted line), which
suggests that our system is able to recompute the shortest
paths quickly as the underlying link RTTs change.
There is an inherent trade-o(cid:11) between quickly reacting to
changes in the link RTTs, and the stability of the paths.
When the query reacts to any changes in the link RTTs, the
computed paths become less stable. This instability is quan-
ti(cid:12)ed by the (cid:12)rst two lines of Table 3, which shows results
for the Sparse-Random and Dense-Random topologies. Only
33% and 22% of all paths remain unchanged after the ini-
tial query execution, and the shortest path between each pair
of nodes changes on average 3:8, and 4:4, respectively. The
denser topology is less stable, as there are more link updates
per unit time.
The per-node communication overheads in steady state for
Sparse-Random and Dense-Random are 586 Bps and 813 Bps,
respectively. Despite the path instabilities, these overhead
numbers represent only 22% and 17% of the overhead in-
curred by executing the complete query from scratch (see
Section 9.2.2). Thus, recomputing the query results incre-
mentally is both more e(cid:14)cient and faster than periodically
reissuing the entire query.
To increase the stability of the computed paths, we use the
classic Jacobson/Karels algorithm [20] to smooth the RTT
values. For each link, we compute the mean deviation of the
estimated RTT, and only send an update to the query pro-
cessor if the latest estimated RTT exceeds the last reported
by more than the mean standard deviation. We note that
this estimation algorithm can be easily expressed in Datalog.
As shown in Table 3, smoothing the link RTTs is e(cid:11)ective:
the percentage of stable paths doubles, while the number of
changes per path decreases by up to three times. Smoothing
also leads to a reduction of the overhead as fewer paths need
to be recomputed. The average per-node bandwidth utiliza-
tion in steady state for Sparse-Random and Dense-Random
decrease to 175 Bps and 270 Bps, respectively. Finally, Fig-
ure 13 shows another 50 minute experimental run conducted
roughly during the same period as the experiment in Fig-
ure 12 using smoothed RTT values. When using smoothing,
AvgPathRTT is more stable despite similar RTT (cid:13)uctuations.
9.2.4 Path Robustness under Churn
In this section, we study the performance of the continuous
version of our query under churn.
In addition, to our two
metrics (per-node communication overhead and convergence
latency), we add a third metric, recovery time. The recovery
time of a path represents the time it takes the query to com-
pute an alternate path from the moment it has detected the
failure of the path. Note that the recovery time does not in-
clude the time to detect the failure. While detecting a failure
is an important and non-trivial problem, we do not consider
it in this paper.
)
s
m
(
T
T
R
h
t
a
P
g
v
A
 160
 140
 120
 100
 80
 60
 40
 20
 0
20% Nodes
10% Nodes
5% Nodes
 10
 15
Time (min)
 20
 25
 0
 5
)
s
m
(
T
T
R
h
t
a
P
g
v
A
 105
 100
 95
 90
 85
 80
20% Nodes
10% Nodes
5% Nodes
 6  6.5  7  7.5  8  8.5  9  9.5  10
Time (min)
Figure 14: AvgPathRTT
during query execution.
Figure 15: Close-up view
of Figure 14.
We conduct our experiments on the Dense-Random and
Dense-UUNET topologies. In all experiments, we use smoothed
link RTT values. We induce churn by alternately injecting
fail and join events every 150 sec. At each fail event, a ran-
dom set of nodes (chosen from either 5%, 10% or 20% of
the nodes) experience fail-stop failures. This is followed by a
join event where the previously failed nodes rejoin the net-
work. The failure of each node will cause neighboring nodes
to invalidate their neighbor entries. This generates link tu-
ples with in(cid:12)nite costs and results in paths being invalidated
as described in Section 8.
Figure 14 shows three experimental runs, for churn events
consisting of 5%, 10% and 20% of all nodes of the Dense-
UUNET topology. Each fail event corresponds to the sharp
rise in AvgPathRTT, as longer routes are computed to avoid
the failed nodes. Conversely, each subsequent join event
causes the drop in AvgPathRTT, as new shorter routes are
discovered. The higher the percentage of node failures, the
greater the change in AvgPathRTT induced by a churn event.
Figure 15 shows the same results as Figure 14 over a four
minute interval when a fail event is followed by a join event.
Right after the failures, AvgPathRTT increases sharply as a
large number of paths are invalidated and recomputed. How-
ever, AvgPathRTT decreases steadily as better paths are dis-
covered and stabilizes. In the worst case, the communication
overhead is 18% of that required for recomputing the query.
A large fraction of paths recover almost instantly. The me-
dian recovery time is less than 1 sec, and the average recovery
time is 2(cid:0)2:2 sec. Only 1(cid:0)3% of paths take more than 10
sec to recover.
10. RELATED WORK
There have been many recent proposals for increasing the
(cid:13)exibility of routing in the context of the Internet. Proposed
solutions include enabling end-hosts to choose paths at the AS
level [28], separating routing from the forwarding infrastruc-
ture [19, 15], centralizing some of the routing decisions [15],
and building extensible routers such as XORP [16]. Our pro-
posal is mostly complementary to these e(cid:11)orts. The increased
(cid:13)exibility provided by a declarative interface can enhance the
usability and programmability of these systems. Our pro-
posal is also orthogonal to the separation of the control plane
and the data plane. As discussed in Section 2, our system
can be fully centralized, distributed or partially centralized.
Several type-safe languages have been proposed to improve
the security and robustness of Active Networks. Two ex-
amples are PLAN-P [26] and SafetyNet [3]. Compared to
these languages, Datalog is particularly attractive because of
its strong theoretical foundations, the fact that it is a side-
e(cid:11)ect-free language sandboxed within a query engine, and its
elegance in expressing routing protocols in a compact way.
Unlike previous proposals, as a declarative query language,
Datalog is also amenable to query optimization techniques
from the database literature. Finally, we use Datalog exclu-
sively for the control plane, and not for the data plane.
11. CONCLUSION
We propose declarative routing, which aims to strike a better
balance between the extensibility of a routing infrastructure
and its robustness. The basic idea of our solution is to express
routing protocols using recursive query languages developed
for deductive databases. Our solution can be viewed as an
application of database techniques to the domain of network-
ing, and is based on the key observation that recursive queries
are a natural (cid:12)t for expressing routing protocols.
We implemented a prototype system built on top of PIER,
a distributed relational query processor. Using transit-stub
simulations and actual deployment on PlanetLab, we demon-
strate that our system imposes no fundamental limits relative
to traditional protocols, is amenable to query optimizations,
and can e(cid:14)ciently sustain long-lived routes.
As future work, we will further explore the synergies be-
tween query optimization and network routing. We have
identi(cid:12)ed a few well-known query optimization techniques
and show how they can be used to generate e(cid:14)cient protocols.
While these optimization techniques mimic well-known opti-
mizations for routing protocols, it will be interesting to see
how they can help inform new routing protocol designs. We
intend to explore the use of an automatic query plan genera-
tor that not only optimizes each query individually, but also
applies multi-query optimization techniques to automatically
identify sharing opportunities among di(cid:11)erent queries.
We also plan to explore other uses of declarative queries
in the network domain. These include a detailed study on
expressing BGP inter-domain routing policies, and specifying
declarative overlay networks.
12. REFERENCES
[1] GT-ITM. http://www.cc.gatech.edu/projects/gtitm/.
[2] PIER. http://pier.cs.berkeley.edu.
[3] SafetyNet. http://www.cogs.susx.ac.uk/projects/safetynet/.
[4] WorldComâ€™s Global UUNET Internet network.
http://library.mobrien.com/manuals/mprm group/uunet.jpg.
[5] S. Abiteboul, R. Hull, and V. Vianu. Foundations of Databases.
Addison-Wesley, 1995.
[6] R. Agrawal. Alpha: An Extension of Relational Algebra to
Express a Class of Recursive Queries. In IEEE Transactions on
Software Engineering, volume 14, 1988.
[7] H. Balakrishnan, M. F. Kaashoek, D. Karger, R. Morris, and
I. Stoica. Looking Up Data in P2P Systems. Communications of
the ACM, Vol. 46, No. 2, Feb. 2003.
[8] I. Balbin and K. Ramamohanarao. A Generalization of the
Di(cid:11)erential Approach to Recursive Query Evaluation. Journal of
Logic Programming, 4(3):259{262, 1987.
[9] T. Ballardie, P. Francis, and J. Crowcroft. Core Based Trees
(CBT): An Architecture for Scalable Inter-Domain Multicast
Routing. In SIGCOMM, 2003.
[10] C. Beeri and R. Ramakrishnan. On the Power of Magic. In
PODS, 1987.
[11] B. Bershad, S. Savage, P. Pardyak, E. G. Sirer, D. Becker,
M. Fiuczynski, C. Chambers, and S. Eggers. Extensibility, Safety
and Performance in the SPIN Operating System. In SOSP, 1995.
[12] D. Calvanese, G. D. Giacomo, and M. Y. Vardi. Decidable
Containment of Recursive Queries. In ICDT, 2003.
[13] W. F. Clocksin and C. S. Melish. Programming in Prolog.
Springer-Verlag, 1987.
[14] D. Tennenhouse and J. Smith and W. Sincoskie and D.
Wetherall and G. Minden. A Survey of Active Network Research.
In IEEE Communications Magazine, 1997.
[15] N. Feamster, H. Balakrishnan, J. Rexford, A. Shaikh, and
J. van der Merwe. The Case for Separating Routing From
Routers. In FDNA, 2004.
[16] M. Handley, A. Ghosh, P. Radoslavov, O. Hodson, and
E. Kohler. Designing IP Router Software. In NSDI, 2005.
[17] D. B. Johnson and D. A. Maltz. Dynamic Source Routing in Ad
Hoc Wireless Networks. In Mobile Computing, volume 353. 1996.
[18] R. Krishnamurthy, R. Ramakrishnan, and O. Shmueli. A
Framework for Testing Safety and E(cid:11)ective Computability. J.
Comput. Syst. Sci. 52(1), pages 100{124, 1996.
[19] T. V. Lakshman, T. Nandagopal, R. Ramjee, K. Sabnani, and
T. Woo. The SoftRouter Architecture. In HotNets-III, 2004.
[20] L. Peterson and B. Davie. Computer Networks: A Systems
Approach. Morgan-KaufMann, 2003.
[21] PlanetLab. http://www.planet-lab.org/.
[22] R. Ramakrishnan, K. A. Ross, D. Srivastava, and S. Sudarshan.
E(cid:14)cient Incremental Evaluation of Queries with Aggregation. In
SIGMOD, 1992.
[23] R. Ramakrishnan and J. D. Ullman. A Survey of Research on
Deductive Database Systems. Journal of Logic Programming,
23(2):125{149, 1993.
[24] M. Stonebraker. Inclusion of New Types in Relational Data Base
Systems. In ICDE, 1986.
[25] S. Sudarshan and R. Ramakrishnan. Aggregation and Relevance
in Deductive Databases. In VLDB, 1991.
[26] S. Thibault, C. Consel, and G. Muller. Safe and E(cid:14)cient Active
Network Programming. In 17th IEEE Symposium on Reliable
Distributed Systems, 1998.
[27] A. van Deursen, P. Klint, and J. Visser. Domain-Speci(cid:12)c
Languages: An Annotated Bibliography. SIGPLAN Notices,
35(6), 2000.
[28] X. Yang. NIRA: A New Internet Routing Architecture. In
Proceedings of FDNA-03, 2003.