SFPK =
) and R can use gt∗
1)t∗
1 ,
SFPK)−bm∗ =
SFPK · (Sig2
1 )−bm∗
ga·b·t∗
1 , (gb
(gt∗
1
1
)r∗(cid:17) · (gr∗
(cid:16)
20
– outputs 1 iﬀ
e(ga·b·t∗
1
2) = e(gt∗
, gc
1 , gd
2 ).
It is easy to see that the probability that R successfully solves the bilinear decisional Diﬃe-
Hellman problem depends on the advantage of A and the probability that R’s simulation succeeds.
Since the programmable hash function PHF is (1, poly(λ))-programmable and because this is a type
3 adversary, we conclude that this probability is non-negligible. Note that since in this case we use
A3, M∗ is distinct from all M ’s used in O1 and O2, which is not the case for type 1 and type 2
adversaries.
Theorem 2 (Adaptive Class-Hiding with Key Corruption). Scheme 2 is adaptively class-
hiding with key corruption in the common reference string model, assuming the decisional Diﬃe-
Hellman assumption holds.
Proof. In this proof we will use the game based approach. We start with GAME0 which is the
original class-hiding experiment and let S0 be an event that the experiment evaluates to 1, i.e. the
adversary wins. We will use Si to denote the event that the adversary wins the class-hiding experi-
ment in GAMEi.
Let pkSFPK = (A, B) be the public key given to the adversary, pk0 = (A0, B0) = (g1, gx0
1 ) be the public keys that are returned by SFPK.KeyGen, sk0 = (Y x0
1 ) and
1 , pk0)
1 , pk1) the corresponding secret keys given to the adversary and ˆb be the bit chosen
pk1 = (A0, B1) = (g1, gx1
and sk1 = (Y x1
by the challenger.
GAME0: The original class-hiding game.
GAME1: In this game we do not use the SFPK.ChgSK algorithm to compute skSFPK and pkSFPK but
compute them as pkSFPK = (Q, Qxˆb ), and skSFPK = ((Qxˆb )y, pkSFPK), where Y1 = gy
1 is part of the
common reference string ρ generated by the challenger. In other words, instead of using the exponent
r to randomize the public key and secret key, we use a group element Q to do it.
Since the distribution of the keys does not change, it follows that Pr[S1] = Pr[S0]. Note that the
oracle can still use skSFPK to compute valid signatures.
GAME1: In this game instead of computing pkSFPK = (Q, Qxˆb ) as in GAME1, we sample B(cid:48) ←$ G1
and set pkSFPK = (Q, B(cid:48)).
Let (gα
1 , gγ
p and sets B0 = (gα
We will show that this transition only lowers the adversaries advantage by a negligible fraction.
This can be show by construction using a reduction R that uses an adversary A that can distinguish
between those two games to break the decisional Diﬃe-Hellman assumption in G1.
1 ) be an instance of this problem in G1. R samples r0, r1 ←$ Z∗
1 , gβ
1 )r0 ,
1 )r1 . Note that in such a case, we also have to set sk0 = ((B0)y, pk0) and sk1 = ((B1)y, pk1).
1 )rˆb ). Note that the
1 )rˆb )y, pkSFPK) to generate signatures and answer
Now γ = α·β then pkSFPK has the same distribution as in GAME1 and otherwise as in GAME2.
B1 = (gα
Additionally, the reduction uses Q = gβ
reduction can use the secret key skSFPK = (((gγ
signing queries.
Thus, it follows that |Pr[S2] − Pr[S1]| ≤ AdvddhA (λ).
1 and the public key pkSFPK = (Q, (gγ
21
We will now show that we have Pr[S2] = 1
(Q, B(cid:48)) and signatures of the form SigSFPK = ((B(cid:48))y·(PHF.Eval(KPHF, m))r, gr
and Q, B(cid:48), which are independent from the bit ˆb. Thus, we have Advadaptc-h
2 . This follow from the fact that we have pkSFPK =
2, s) for some r ∈ Z∗
p
A,SFPK(λ) = Pr[S0] ≤ AdvddhA (λ).
1, gr
5 Our Group Signatures
In this section we formalize the group signature proposed in the introduction. We present the algo-
rithms related to key generation and group management in Figure 3 and the algorithms related to
signature creation, veriﬁcation, tracing and judgment in Figure 4.
To securely instantiate our scheme we require the following components:
– a digital signature scheme DS which is existentially unforgeable under chosen message attacks,
– a structure-preserving signature scheme on equivalence classes SPS-EQ with message space of
dimension (cid:96) = 2 which is existentially unforgeable under chosen message attacks and perfectly
adapts signatures,
– a compatible signature scheme with ﬂexible public keys SFPK which has canonical represen-
tatives, is strongly existentially unforgeable under chosen message attacks and has adaptive
class-hiding with key corruption,
– a public key encryption scheme PKE which is IND − CPA secure and has key-privacy under
chosen message attacks,
– a proof system ΠPPE for pairing product equations which is a witness-indistinguishable proof of
knowledge,
– a second proof system ΠGS.Judge which is zero-knowledge.
GS.Setup(1λ)
(ρSFPK, ·) ←$ SFPK.CRSGen(1λ)
BG = (p, G1, G2, GT , e, g1, g2) ←$ SPS.BGGen(1λ)
ρJ ←$ ΠGS.Judge.Setup(1λ); K2 ←$ G2; τ := 0
return param := (1λ, BG, ρSFPK, ρJ , K2)
GS.KGenM(param)
(skDS, pkDS) ←$ DS.KeyGen(1λ)
(skSPS, pkSPS) ←$ SPS.KGen(BG, 2)
info := (pkSPS, DS.Sign(skDS, pkSPS), ∅)
return (msk := (skDS, skSPS),
mpk := pkDS, info)
GS.KGenT (param)
ω ←$ coin;
(ρΠ , τΠ ) ← ΠPPE.ExtGen(1λ; ω)
return (tsk := (τΠ , ω),
tpk := ρΠ )
GS.Issue(infoτcurrent , msk, uid, upk[uid])
GS.UpdateGroup(gpk, msk, infoτcurrent ,S, reg)
msk = (skDS, skSPS), upk[uid] = (pkSFPK, pkEnc)
infoτcurrent [uid] = (pkSPS, σDS, Active)
if ¬IsCanonical(pkSFPK) then return ⊥
k ←$ coin; c ←$ PKE.Enc(pkEnc, k);
σSPS ←$ SPS.Sign(SFPK.ChgPK(pkSFPK, k), skSPS)
Active
:= Active ∪ {(c, σSPS)}
(cid:48)
infoτcurrent [uid] := (pkSPS, σDS, Active
reg[uid] := upk[uid]
(cid:48)
)
msk = (skDS, skSPS)
(cid:48)
SPS, pk
(cid:48)
SPS) ←$ SPS.KGen(BG, 2)
(sk
(cid:48)
msk := (skDS, sk
SPS)
infoτcurrent = (·, ·, Active); A := {i| user i is active}
foreach i ∈ A \ S
reg[uid] = (pki
SFPK, pki
k ←$ coin; c ←$ Enc(pki
σSPS ←$ SPS.Sign(SFPK.ChgPK(pki
Active
SFPK, k), skSPS)
(cid:48) ∪ (c, σSPS)
:= Active
Enc, k);
Enc)
(cid:48)
return infoτnew = (pk
(cid:48)
SPS, DS.Sign(skDS, pk
(cid:48)
SPS), Active
(cid:48)
)
GS.UKGen(1λ)
(skSFPK, pkSFPK) ←$ SFPK.KeyGen(1λ)
(skEnc, pkEnc) ←$ PKE.KeyGen(1λ)
return (usk[uid] := (skSFPK, skEnc),
upk[uid] := (pkSFPK, pkEnc))
Fig. 3. Algorithms related to key generation and group management.
22
GS.Vf(gpk, infoτ , m, Σ)
infoτ = (pkSPS, σDS, ·); mpk = pkDS
Σ = (pkSFPK, σSPS, ΠSFPK, SigSFPK)
// xSign is the same statement as in GS.Sig
if DS.Verify(pkDS, pkSPS, σDS) = 0 or
ΠPPE.Verify(ρΠ , xSign, ΠSFPK) = 0 or
SPS.Verify(pkSPS, pkSFPK, σSPS) = 0
then return 0
return SFPK.Verify(pkSFPK, m||τ||pkSFPK||σSPS||ΠSFPK, SigSFPK)
GS.Sig(gpk, gsk[uid], infoτ , m)
infoτcurrent = (pkSPS, ·, Active)
gsk[uid] = (skSFPK, skEnc); gpk[uid] = (pkSFPK, pkEnc)
if ¬∃ (c, σSPS) ∈ Active s. t.
k ← PKE.Dec(c, skEnc) and
SPS.Verify(SFPK.ChgPK(pkSFPK, k), σSPS, pkSPS) = 1
then return ⊥
(cid:48)
(cid:48)
SFPK ←$ SFPK.ChgPK(pkSFPK, r); sk
SFPK ←$ SFPK.ChgSK(skSFPK, r)
−1, pkSPS)
r ←$ coin; pk
(cid:48)
SPS ←$ SPS.ChgRep(pkSFPK, σSPS, r · k
σ
ΠSFPK ←$
ΠPPE.Prove(ρΠ , xSign, w = (pkSFPK, r, 1G1 , 1G2 )) for xSign:
∃ (pkSFPK, r, w1, w2) s. t.
SFPK ∧ IsCanonical(pkSFPK)
(cid:48)
SFPK.ChgPK(pkSFPK, r) = pk
∨ e(w1, K2) = e(w2, g2)
(cid:48)
(cid:48)
SFPK, m||τcurrent||pk
SigSFPK ←$ SFPK.Sign(sk
SFPK||σ
(cid:48)
(cid:48)
return Σ := (pk
SPS, ΠSFPK, SigSFPK)
SFPK, σ
(cid:48)
SPS||ΠSFPK)
GS.Trace(gpk, tsk, infoτ , reg, m, Σ)
GS.Judge(gpk, uid, infoτ , πTrace, upk[uid], m, Σ)
Σ = (pkSFPK, σSPS, ΠSFPK, SigSFPK); tsk = (τΠ , ω)
(pkSFPK, r, ·, ·) ←$ ΠPPE.Extract(τΠ , ΠSFPK)
if ¬∃uid s. t. reg[uid] = (pkSFPK, ·)
then return ⊥
π ←$
ΠGS.Judge.Prove(ρJ , xTrace, w = (τΠ , ω)) for xTrace:
∃ (τΠ , ω) s. t.
(pkSFPK,·,·,·) ←$ ΠPPE.Extract(τΠ , ΠSFPK) ∧
(ρΠ , τΠ ) ← ΠPPE.ExtGen(1λ; ω)
return (uid, π)
if GS.Vf(gpk, infoτ , m, Σ) = 0
then return 0
Σ = (·, ·, ΠSFPK, ·); upk[uid] = (pkSFPK, ·)
// Statement xTrace as in GS.Trace
return ΠGS.Judge.Verify(ρJ , x, π)
Fig. 4. Algorithms related to creating and processing signatures.
Theorem 3 (Traceability). Our group signature construction is traceable if the decisional Diﬃe-
Hellman assumption holds in G2, the SPS-EQ signature scheme is existential unforgeable under
chosen-message attacks, the SFPK scheme is existential unforgeable and the digital signature scheme
used by the Issuer is existential unforgeable under chosen-message attacks.
Proof. We will use the game base approach. Let us denote by Si the event that the adversary
∗
∗
∗
wins the traceability experiment in GAMEi. Let (m∗, Σ∗ = (pk
SFPK, σ∗
SFPK), info
τ =
∗
SPS, σ∗
(pk
)) be the forgery outputted by the adversary. Moreover, let u be the maximum
number of oracle queries to UpdateGroup made by the adversary and n the number of queries to the
AddU oracle.
SPS, Π∗
DS, Active
SFPK, Sig
∗
23
GAME0: The original experiment.
GAME1: We abort in the case that VerifyDS(pkDS, pk
DS was
not created by the UpdateGroup oracle. Informally, we exclude the case that the adversary creates a
custom SPS-EQ public key and uses it to create his own epoch information.
DS) = accept but the signature σ∗
∗
SPS, σ∗
It is easy to see that this change only decreases the adversary’s advantage by a negligible fraction.
In particular, we can simply use any adversary A to break the existential unforgeability of the digital
signature scheme used by the Issuer. Thus, it follows that |Pr[S1] − Pr[S0]| ≤ Adveuf−cma
(λ).
GAME2: We abort in case the witness extracted by the tracing authority from Π∗
such that w1 (cid:54)= 1G1 and w2 (cid:54)= 1G1.
A,DS
SFPK is (·,·, w1, w2)
Again, this change only decreases the adversary’s advantage by a negligible fraction. We will
show that we can use A to break the decisional Diﬃe-Hellman assumption in G2. Let (gα
2 , gγ
2 )
be an instance of this problem. We set K2 = gα
2 . Since we always have that e(w1, K2) = e(w2, g2),
which follows from the fact that the tracing authority can extract such a witness and this implies
that w2 = (w1)α. Thus, we can return e(w2, gβ