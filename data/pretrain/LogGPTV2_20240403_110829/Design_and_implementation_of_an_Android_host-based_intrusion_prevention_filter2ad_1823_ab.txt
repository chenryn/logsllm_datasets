written in C or C++) to implement some functionalities,
application repackaging cannot monitor these native library
calls. Hence, application repackaging cannot fully prevent
malware intrusion. Furthermore, malware writers can ex-
ploit bugs in the disassembling tools [50, 3] to conceal their
malicious functions.
In summary, application repackaging
cannot fully prevent malware intrusion.
3.3 API Hooking
Generally, API hooking is to intercept API calls in order
to inspect the behaviors of a calling app. For Android, apps
must go through the Binder to call other services, so the
hooking method can be implemented on the Binder commu-
nication. The basic ﬂow of using API hooking to implement
HIPS can be summarized as: (1) gaining root or system
privilege; (2) injecting a shared library object ﬁle (i.e., so
ﬁle) to the target process; (3) carrying out hooking on tar-
get APIs; (4) loading policy enforcement function. Let us
describe in detail the Android API hooking process.
3.3.1 Overview of API Hooking
Due to the sandboxing protection, API hooking requires
root or system privilege to hook on functions in the libraries
of the target processes. There are several approaches [1, 29]
to gain root or system privileges. Basically, these tools ex-
ploit the Android system and get root or system privileges.
In order to ensure the security, the tools will also install an
app called Superuser on the phones to manage the autho-
rizations of higher privileges to certain apps. Furthermore,
the system loopholes can be easily patched by using hook-
ing methodology [41]. Hence, malware cannot exploit the
loopholes to infect system.
The hooking operation has to be conducted in the native
code. To achieve this, we inject a shared library ﬁle (so ﬁle)
to achieve the hooking. Inline hooking [34] and ptrace are
two methods to inject an so ﬁle. However, the implemen-
tation of inline hooking on ARM platform is more diﬃcult
than on the x86 platform. Therefore, we use ptrace to at-
tach the target process so as to modify the registers in the
target process to execute our shellcode. In the shellcode, we
utilize dlopen and dlsym functions to inject an so ﬁle into
the target memory. The shellcode will also invoke an entry
function in the injected so ﬁle to carry out API hooking.
We can use the API hooking on Android to intercept any
Java method. In particular, we can modify the global ob-
ject (gDvm) in the libdvm.so library of DVM to intercept a
target method. gDvm maintains the structure of every class
and method at runtime. There is a variable called insns
in gDvm for each method specifying the address of the corre-
sponding Java method. So, we can ﬁnd the target method in
the loaded classes (gDvm->loadedClasses) and replace the
method insns to point to the function in the injected so’s li-
brary. Hence, when one calls the intercepted APIs, the DVM
will execute our own methods. After executing our meth-
ods, we can call back the original APIs. One can implement
policy checking and enforcement in Java and compile them
into a jar package. So the injected library can easily load
the logics in the jar ﬁle.
Most of existing HIPS on mobile devices are implemented
by “hooking on the client side”. Let us elaborate on this
approach and we will also illustrate its deﬁciency.
3.3.2 API Hooking on the Client Side
In Section 2, we explain the client-server model in the
Binder communication. To realize HIPS via API hooking
on the client side is to hook the shared libraries of the nor-
mal apps so as to perform policy enforcement. To do this, we
need to ﬁrst understand the workﬂow of the Binder trans-
action on the client side. To illustrate, consider that we use
the following codes to send an SMS message:
SmsManager smsManager = SmsManager.getDefault();
smsManager.sendTextMessage(
"phoneNumber", null, "message", null, null
);
Figure 3: Call graph of ISms Binder transaction on
the client side.
The ﬁrst line is to query the ISms service (ISms handler)
from the Service Manager. When calling the sendTextMes-
sage, the system will call the sendText method of the ISms
handler. Figure 3 depicts the partial function call graph
of a Binder transaction for sending an SMS message. On
the call path, there is a JNI method, native transact,
which bridged with the android_os_BinderProxy_transact
on the side of the native code. Finally, the transaction will
end with the talkWithDriver function on the client side.
Because the native transact method is the last method
at the Java level, we can intercept it for hooking. Because
it is a JNI method, the insns pointer in gDvm points to
the address of the corresponding native function (android_
os_BinderProxy_transact). Thus, we can store the origi-
nal address, and replace the method pointer with our imple-
mentation inside the injected so ﬁle. After inspecting this
transaction using our policy enforcement module, we can call
back the original API, android_os_BinderProxy_transact.
As shown in Figure 2, all apps are forked by a process called
zygote. Therefore, instead of injecting an so ﬁle into any
app, we can simply inject it to zygote at booting time. By
using this approach, we can perform policy enforcement on
any transactions which use the intercepted method.
Although the implementation of API hooking on the client
side is straightforward and has been implemented in com-
mercial systems [10, 9], this approach has a severe security
limitation. This approach cannot ensure the security of the
HIPS because the hooking operations are done in the same
sandbox of the app. This implies that every operation can
be modiﬁed and bypassed by the app itself. Therefore, it
is dangerous if the malware writer discovers this HIPS im-
plementation. Let us now demonstrate how to bypass this
popular HIPS implementation.
3.4 Vulnerability of Existing HIPS Products
There are a number of existing HIPS products (e.g., [10,
In here, we show how to by-
9]) available in the market.
pass these HIPS and elaborate on the vulnerability of the
client-based hooking architecture (or Client HIPS ). Client
HIPS is one of the most popular Android anti-virus and
protection architecture. For example, some HIPS products
(e.g., LBE [10]) have more than ten million users. Moreover,
Client HIPS has been pre-installed in a number of Android
phones (e.g., Xiaomi smartphone).
By examining the memory structure of the installed apps
and the services, we can determine whether app processes
have been injected with an so ﬁle and a jar ﬁle. Figure 4
illustrates the memory structure of a normal app. There
are injected so ﬁle and jar ﬁle which do not belong to
the app. This implies that the Client HIPS is using the
Figure 4: Memory structure of an app.
Figure 5: Workﬂow to bypass client HIPS.
client side API hooking to perform policy enforcement. By
checking the insns value in the gDvm, the pointing address
of native transact is 0x6CC4FED8. In addition, from the
mapped memory regions of apps, we ﬁnd that the address of
native transact resides in 0x6CC47000-0x6CC52000 region
which mapped to /data/data/com.client_hips/app_hips/
libclient.so ﬁle. Therefore, we can conﬁrm that the sys-
tem intercepts the native transact method in android.os.
Binder class and points to the injected library.
Based on the discussion in Section 3.3, we know that the
Client HIPS is in the same sandbox with the app. There
are several ways to bypass the HIPS system. Firstly, we can
modify the insns back to the original one to make sure that
the transaction will not go through the policy enforcement.
Secondly, because the native transact method is inter-
cepted, malware writers can create their own transact imple-
mentation to bypass all the interceptions. Figure 5 demon-
strates the workﬂow to bypass the Client HIPS. We imple-
ment our native pwnTransact method to send transactions
to the target service directly. Therefore, Client HIPS cannot
capture these transactions through intercepting transact
method. In summary, malware writers can use the technique
described above to determine the existence of Client HIPS
(by examining the current mapped memory region /proc/
[pid]/maps ﬁle). This shows that hooking on the client side
cannot eﬀectively prevent intrusions.
4. PATRONUS
In this section, we present our system, Patronus, a secure
architecture which can prevent suspicious transactions and
dynamically detect malware based on runtime transaction
information. One advantage of Patronus is that we do not
need to modify the Android system or repackage apps, and
this facilitates easy deployment of our system. We present
the system design of Patronus, and the methodologies used
for intrusion prevention and dynamic detection.
4.1 API Hooking on the Server Side
As stated in Section 3.4, API hooking on the client side
has a number of deﬁciencies. We also illustrated how to
bypass detection if HIPS is implemented via API hooking on
the client side. To overcome these security issues, Patronus
complements the API hooking by realizing it both on the
client side and the server side. Let us ﬁrst present our design
Figure 6: Call graph of ISms Binder transaction on
the server side.
and implementation of API hooking on the server side.
There are two approaches to conduct API hooking on the
server side. The ﬁrst approach is via the Java API hooking,
and the second approach is to hook the Service Manager.
Figure 6 shows that the transaction goes through the Binder
driver from the client side to the server side and will be exe-
cuted by the ISms service. There is a JNI between the native
method and the Java method. Therefore, the ﬁrst approach
of Java API hooking is to replace the address of this Java
method, execTransact, in the DVM global object to our
policy enforcement functions. Afterward, the hooking func-
tion will call back the original function if our policy accepts
this transaction. Note that using this approach, some of the
services could not be protected by the policy enforcement.
Because we only hook the Java method of JNI, the intercep-
tion will be invalid when the service uses native codes (e.g.,
camera service in Android is only implemented by the native
codes). Therefore, this hooking method can only intercept
subset of API calls.
The second approach of API hooking provides a more
comprehensive solution, which is to intercept the Service
Manager. In Section 2, we explained that the Service Man-
ager manages all registered services. When an app wants
to utilize a service, it should ﬁrst communicate with the
Service Manager to query for the handler of the service.
Therefore, we can intercept the Service Manager and reply
back to the app with a handler which points to the service of
HIPS for policy enforcement. Figure 6 shows the basic ﬂow
of hooking on the Service Manager (as illustrated in red
lines). When an app queries the ISms Service from the in-
tercepted Service Manager, it will get the handler of HIPS’
hooked Service, and when an app uses the handler to send
an SMS message, the hooked Service will ﬁrst check with
the Policy Service, then an accepted transaction will return
to the original ISms service to complete the SMS message
sending operation.
Note that many malware have the network capability.
However, hooking the Binder cannot monitor the network
APIs because network function in Android relies on socket
IPC, and the network APIs of Android (e.g., Apache HTTP
Client and HTTPURLConnection) use socket to setup HTTP
connections with servers. Hence, any app can communi-
cate with a remote server without using the Binder if they
have declared the android.permission.INTERNET permis-
sion in the AndroidManifest.xml. One approach to mon-
itor network behaviors is to intercept socket related APIs.
For example, java.net.Socket is a class used by other in-
ternet APIs. In Patronus, we use the technique of hooking
on the client side to intercept the connect method in the
java.net.Socket class to monitor the behaviors. Note that
apps can also use network via the native socket function
policy in the database which resides on the client side. By
checking the transaction policy, Patronus can inspect and
prevent intrusions before they arrive at the server side. Us-
ing the approach of API hooking on the server side which
we explained in Section 4.1, the injected ﬁles on the server
side will intercept execTransaction method of the Service
Manager. So whenever there is any query from the client
side, it will reply the Patronus service handler back to all
queries. Therefore the transactions on the server side will
ﬁrst arrive at the Patronus Service, and they will be checked
based on the policy database before dispatching these trans-
actions to the corresponding servers. In our current imple-
mentation, we implement our policy checking and enforce-
ment in API hooking, and use the Android SDK (e.g., Popup
Window class to show a popup window on the apps).
• Policy database: This database contains the policy en-
forcement rules for each type of transaction of all apps. In
our current implementation, we store these rules in an XML
ﬁle. Using the Patronus Service, users can block transactions
from some untrusted apps. Speciﬁcally, Patronus App com-
municates with Patronus Service to write the user-deﬁned
policy into the policy database. Users can enable some
trusted apps (e.g., Google apps) or deny some transactions
(e.g., sendText, requestLocationUpdates) if they do not
intend to request these sensitive services. Due to the secu-
rity consideration, this policy database belongs to the Pa-
tronus Service user and can only be modiﬁed by the trusted
Patronus Service. Hence, with the protection of Linux ﬁle
system, malicious app cannot destroy the policy database.
With these four components, Patronus can inspect the
transactions either on the client side or on the server side.
By analyzing each transaction, Patronus can prevent intru-
sions and detect malware.
4.3
Intrusion Prevention
Patronus can inspect transactions dynamically and will
notify users if it encounters some intrusive transactions. In
the Android system, there are hundreds of transaction types.
The intrusive transactions are the transactions which can
invoke some dangerous behaviors, for example, some mal-
ware subscribe premium service by sending an SMS mes-
sage, and some spyware steal the location information using
GPS service. Table 1 lists some intrusive transactions with
the transaction descriptors, codes and codes name. For in-
stance, the requestLocationUpdates transaction in the an-
droid.location.ILocationManager can gain the location
information based on GPS. When this intrusive transaction
is not initiated by users or without users’ permissions, Pa-
tronus will alert the users using a popup window so that the
users can pay attention to this transaction. Users can also
deny this transaction at runtime. Patronus will monitor the
transaction stream based on the intrusive transaction list. It
is important to note that users or security analysts can add
and/or delete rules in the Patronus policy database to ignore
some intrusive transaction from some apps. For example, a
third-party SMS mobile app can send, read and write SMS
messages. If users are certain about the authenticity and se-
curity of this mobile app, users can delete rules for this SMS
related intrusive transactions in order to eliminate the popup
alerts. Also, the list is deﬁned by the system (i.e., anti-virus
software) which contains the sensitive transactions. Legiti-
mate transactions (e.g., opening window, changing Activity
status) will not have any malicious behaviors.
Figure 7: Architecture of Patronus.
call. Although we can use ptrace to inspect the socket and
connect functions to cover this case, this will bring much
overhead. Because we want to create a HIPS on mobile
phones which are resource constrained, we use the technique
of hooking on the client side to intercept the connect method
in the java.net.Socket class to monitor the behaviors.
4.2 System Design of Patronus
In Section 3, we presented and demonstrated the weak-
nesses of existing host-based intrusion prevention system on
Android. In order to overcome these security problems and
provide better functionalities, we set the following two de-
sign goals for Patronus: (1) It should dynamically prevent
suspicious malware intrusions and can detect malware using
runtime information (i.e., transaction information); (2) the
architecture needs to be extensible and provides a ﬂexible
methodology to detect malware without modifying Android
system or the need to repackage apps. Figure 7 depicts the
architecture of Patronus. The system consists of four com-
ponents: (a) Patronus application, (b) Patronus service, (c)
injected ﬁles and (d) policy database.
• Patronus Application: A process which is responsible
for displaying the user interface, initiates the Patronus Ser-
vice and injects so or jar ﬁles. Speciﬁcally, Patronus Ap-
plication uses the ptrace to inject a shellcode so as to load
the so or jar ﬁles, which will be injected in the zygote on
the client side and the Service Manager on the server side.
• Patronus Service: A process which is launched as the
start of the system and it is a sticky service, which means
that the service will not be killed by the system even in
the condition with limited memory resources. Hence, this
process is always available and we use it to detect any mal-
ware which registers at installation. Patronus Service will
intercept all transactions on the server side by receiving the
redirected transactions from the hooked Service Manager so
as to perform policy enforcement and dynamic detection.
Furthermore, Patronus Service is the owner of the policy
database process and it has permission to read and write
the database. For malware, they cannot modify the policy
database due to the ﬁle system protection of Linux system.
Patronus Service will also record all runtime information
(i.e., transaction parcels) in a temporary ﬁle so that the sys-
tem can perform the dynamic detection.
• Injected ﬁles: There are two types of injected ﬁles. In-
jected ﬁles on the client side and injected ﬁles on the server
side. Because malware can access injected ﬁles on the client
side, these injected ﬁles only have the read permission on
the policy database so as to avoid modiﬁcation by the mal-
ware. The injected ﬁles on the client side use the method
explained in Section 3.3.2 to intercept the native transact
method. These injected ﬁles will ﬁrst check the transaction
Table 1: Intrusive Transaction List
TC TC Name
TD
com.android.internal
.telephony.ISms
com.android.internal
.telephony.ITelephony