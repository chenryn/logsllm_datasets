1) DH priv key = gen DH priv key()
2) DH pub key = comp DH pub key(DH priv key)
3) sess key = comp sess key(DH priv key,
srvr DH pub key)
4) sess IDi = comp sess ID(sess key, clnt version,
srvr version, clnt kexinit, srvr kexinit, ...)
5) sym keys = derive sym keys(sess IDi, sess key)
6) srvr pub keyi = verify srvr pub key(srvr pub key,
known hosts ﬁle)
7) verify sig(sess IDi, srvr pub keyi, sig)
Private key monitor
1) sig = priv key sign(priv key, sess IDi, user name,
service, auth mode, ...)
Figure 6: Privileged operations performed by the two client monitors.
Sensitive data appear in bold, and are accessible only by the monitor
compartment in which they appear. Untrusted parameters provided by
unprivileged compartments are not in bold. xi denotes that sensitive
data x is exported to an unprivileged compartment read-only.
socket, create a pseudo-terminal device, &c. We use this
domain to initialize the client application and connect to
the requested SSH server. At this point, the client has
not yet processed any data from the server. Before ex-
changing any SSH protocol messages, the client creates
two new processes (compartments): a privileged session
monitor that performs privileged operations on sensitive
data that can compromise only a single SSH session,
and a private key monitor that performs authentication
operations with the client’s private keys. This ensemble
of three compartments (represented by ovals) appears in
Figure 5. The use of two distinct monitors is motivated
by Principle 9.
The session monitor runs in the ssh monitor t domain,
a domain we have deﬁned that conﬁnes the process to
access only the known hosts ﬁle; to read/write UNIX
sockets for communicating with the private key monitor
and an unprivileged process running untrusted code (de-
scribed below); and to read/write a terminal device. The
unprivilegedprocess(ssh_nobody_t)networkterminalknown_hosts ﬁleprivate key ﬁlesprivate keymonitor(ssh_pkey_t)session monitor(ssh_monitor_t)UNIX socketUNIX socketand can trick the client into connecting to a server he
controls, instead of to the bona ﬁde server intended by
the client. Suppose further that the attacker exploits the
client. To authenticate the server, the client must verify
the server’s public key against the list of trusted public
keys in the known hosts ﬁle, and then validate the
server’s signature on the session ID. Once the attacker
exploits the client, if the exploited compartment of the
client implementation allows invocation of signature ver-
iﬁcation operation with the session ID or server’s public
key provided by this compartment then the attacker may
be able to force signature veriﬁcation to succeed, and
thus spoof the bona ﬁde server to the client. To see why,
note the arguments to the signature veriﬁcation routine
verify sig() in the session monitor in Figure 6. If the at-
tacker controls the values of the signature argument and
either the session ID argument or the server public key
argument, he can provide inputs that will cause the signa-
ture to verify. That is, he can either sign a benign sess ID
with his own private key and supply his own correspond-
ing srvr pub key, or supply a bogus sess ID signed by
the bona ﬁde server (readily obtained from the attacker’s
own connection to the bona ﬁde server), along with the
bona ﬁde server’s true srvr pub key.
To prevent this veriﬁcation oracle, we must not al-
low an unprivileged compartment (at risk for exploit)
to provide either srvr pub key or sess ID to verify sig().
We thus perform signature veriﬁcation in the session
monitor, and isolate sess ID and srvr pub key within
the monitor. In actuality, the untrusted compartment
provides srvr pub key to the session monitor, but the
session monitor validates it against
the contents of
the known hosts ﬁle before verifying the signature.
Note that sess ID is entangled with trusted random bits
generated by the client every new session, originat-
ing from the client’s DH priv key via comp sess key()
and comp sess ID(). This construction, speciﬁed by the
OpenSSH protocol, implicitly applies Principle 6, which
further prevents an attacker from forcing sess ID to
match that from a past eavesdropped session.
We now turn our attention to the next steps taken by
the client. In the OpenSSH protocol, session key nego-
tiation and server authentication, which establishes the
user privilege barrier, are intertwined. Therefore, our par-
titioning of OpenSSH needs no distinct pre-authenticated
stage, and the SKN stage proceeds immediately to the
post-authenticated stage.
Post-authenticated Stage After computing symmet-
ric keys and authenticating the server, the client kills
the untrusted compartment from the SKN stage and cre-
ates a new untrusted compartment, also conﬁned to the
ssh nobody t domain, to execute operations in the post-
authenticated stage. This new compartment is granted ac-
cess to the session’s symmetric keys so that it can per-
form encryption and decryption operations. It may in-
voke privileged operations in the session monitor, and
the session monitor can invoke privileged operations on
the client’s private keys by the private key monitor. To do
so, the private key monitor executes with the privilege to
read private key ﬁles.
In the post-authenticated stage, the server authenti-
cates the client. Our prototype supports password and
public key authentication. Password authentication does
not require any further partitioning of the client to pro-
tect against a malicious server, as the SSH protocol re-
quires that the client sends the password to the server.
However, we can apply ﬁne-grained privilege separation
to deny the server access to the client’s private key(s).
There is no need for the untrusted compartment to have
direct access to the keys, and if it does, a malicious server
that the user logs in may exploit the client and obtain its
private keys, and thus obtain sensitive information from
other SSH servers where the user authenticates himself
using the same private keys. Therefore, we isolate the
client private keys from the post-authentication stage’s
untrusted compartment by placing them in a privileged
private key monitor. To prevent a private key signing or-
acle in the client, we do not allow the untrusted compart-
ment to directly invoke signing data of its own choice
using the private key. The untrusted compartment passes
untrusted input (user name, service name, authentication
mode, &c.) via the session key monitor. Note that we rely
on session key monitor to supply the trusted session ID
computed earlier in the key exchange protocol to the pri-
vate key monitor as shown in Figure 6. Recall that the
session ID has been entangled with trusted random bits
generated by the client for the current session. Thus, the
signature produced by the private key monitor will not
be valid in any session but the current one, and a private
key oracle has been disseminated.
To support session key rekeying, the unprivileged pro-
cess is permitted to invoke privileged rekeying operations
implemented by the session monitor.
5.2 Hardened OpenSSH Server
In accordance with Principle 9, we extend the baseline
privilege-separated OpenSSH server with an extra ses-
sion monitor process that handles sensitive data related
to a single user’s session while preventing an SKD at-
tack and both private key signing and signature veriﬁ-
cation oracles, as shown in Figure 7. The private key
monitor is the original monitor process from the baseline
privileged-separated OpenSSH server, which performs
operations that require root privilege.
The session monitor, the unprivileged SKN process,
and the unprivileged process of the pre-authentication
stage all run in a chrooted environment with an unused
tion, the session monitor calls into the privileged private
key monitor and supplies the required trusted sess ID to
sign.
Pre-authenticated and Post-authenticated Stages
The baseline privilege-separated OpenSSH server sepa-
rates the pre-authenticated and post-authenticated stages.
It performs user authentication operations such as pass-
word veriﬁcation and signature validation (in public key
authentication) in the monitor. However, this architec-
ture allows an SKD attacker to compromise the password
during password authentication, as it is encrypted with
the session key obtainable by the attacker. During public
key authentication, the untrusted compartment supplies
the data used for user signature veriﬁcation, again allow-
ing oracle attacks against user authentication. The mon-
itor validates the signature against the session ID sup-
plied earlier when the untrusted compartment requested
the server’s signature on this session ID. Thus the un-
trusted compartment can control the session ID used in
public key authentication of the user. In order for an at-
tacker to impersonate the client, she must provide some
session ID signed by the client for the server’s veriﬁca-
tion operation. It is unlikely that the attacker can force a
user to sign arbitrary data with his private key. However,
an SKD attacker can compromise the user’s session and
log its session ID and signature pair. She can then replay
these data to the server’s signature veriﬁcation compart-
ment. Because the server’s signature veriﬁcation routine
does not check whether the provided session ID is valid
within the current session, the veriﬁcation routine will re-
port that the client has authenticated successfully. In this
way, the attacker successfully impersonates the user.
In our implementation, we ﬁx this problem by making
sure that the session ID used for signature veriﬁcation is
produced by the session monitor, as done in operation 4
in Figure 6, and entangled with trusted random bits pro-
vided by the server. Our SKN stage also ensures the se-
crecy of user passwords by thwarting SKD attacks.
Discussion: Trusted Code Base Figure 8 compares
the trusted code bases of Provos et al.’s baseline
privilege-separated OpenSSH server and our hardened
OpenSSH server. The latter implements two monitors,
in accordance with Principle 9, and as described in Fig-
ure 7: one private key monitor that implements code re-
quired for user authentication and accessing the server’s
private key, and one session key monitor that contains
the privileged code for processing the sensitive state for
a user’s session. Consider operations 1–5 in Figure 6,
which are essential to protection against SKD and oracle
attacks. In our partitioning, the session monitor imple-
ments these ﬁve operations, while in baseline OpenSSH,
the untrusted compartment implements them.
Figure 7: Architecture of hardened OpenSSH server.
UID, under a restrictive SELinux policy that allows only
the system calls implied in Figure 7, and prohibits all
others, including dangerous ones such as ptrace and
connect. The process for the post-authenticated stage
runs with the UID of the authenticated user and is not
restricted with any SELinux policy, as with the baseline
OpenSSH server.
Session Key Negotiation Stage The session monitor
implements the privileged operations required for the
SKN stage, and we ensure that the pre-authenticated
stage does not start unless the unprivileged compartment
of the SKN stage terminates (in accordance with Princi-
ple 2). Because the Difﬁe-Hellman key exchange proto-
col is symmetric between the server and client, we im-
plement operations 1–5 from Figure 6 in the server’s ses-
sion monitor just as in the client’s. The SKD attack is
an equally serious threat for client and server; as both
parties share the same session key, an SKD attacker can
compromise either party’s code to disclose it.
During the SKN stage, the server authenticates itself
to the client by signing a session ID. The monitor in the
baseline privilege-separated OpenSSH server signs any
data supplied by the untrusted compartment, thus allow-
ing an oracle attack. A man-in-the-middle attacker can
interpose himself between a client and a bona ﬁde server
and employ a signing oracle on the server to impersonate
the server by producing valid signatures on session IDs
corresponding to the attacker’s session with the client.
We prevent such attacks by constraining the private key
monitor to sign only data provided by the trusted session
monitor—speciﬁcally, the current session ID entangled
with trusted random bits provided by the server, as shown
in Figure 4, as suggested by Principle 6. The server’s ses-
sion monitor produces this sess ID in operation 4 in Fig-
ure 6, just as the client’s does. This signed sess ID can-
not be used to impersonate the server as it is only valid
within the current session. To perform the signing opera-
pre-auth stageUID: nobodychrootednetworkprivate key ﬁles/etc/shadowprivate keymonitorUID: rootUNIX socketSKN stageUID: nobodychrootedsession monitorUID: nobodychrootedpost-auth stageUID: userUNIX socketauthorized_keysHellman key exchange, client and server authentication,
and session caching. The OpenSSL partitioning is in fact
similar in structure to that of SSH, as these protocols
protect against similar threat models. When an applica-
tion invokes SSL accept (on the server) or SSL connect
(on the client), we instantiate private key monitor, session
key monitor, and unprivileged SKN compartments. Our
implementation scrubs the server’s private key from the
session key monitor process and the unprivileged SKN
compartment before reading any input from the network.
Within the SKN stage, we apply the same principles and
mechanisms as we did to OpenSSH to prevent SKD and
oracle attacks. As SSL/TLS supports only public key au-
thentication, its partitioning omits the pre-authentication
stage. We apply simple SELinux policies (whose details
we elide in the interest of brevity) to limit the privilege of
the untrusted SKN compartment and the session monitor
in applications that do not run as root. When the SKN
stage completes, the unprivileged compartment and ses-
sion monitor are terminated, and execution continues in
the application’s fully privileged compartment. The pri-
vate key monitor preserves the privileges of the appli-
cation before entering the SSL accept and SSL connect
library calls. Therefore, this compartment continues exe-
cution of the application’s code and can use the symmet-
ric key computed during the SSL handshake to perform
MAC and encryption/decryption operations on the estab-
lished SSL/TLS session.
We have tested this hardened OpenSSL library with
a number of client-side and server-side applications,
including the server and client sides of stunnel, the
mutt and mailx mail agents (for IMAP and POP3 over
SSL/TLS), the dovecot IMAP and POP3 server, the
client and server sides of the sendmail mail transfer agent
(for SMTP over SSL/TLS), and the Apache HTTPS
server (versions 1.3.19 and 2.2.14).
Converting most of these applications was straight-
forward; it merely required replacing the OpenSSL li-
brary and making a one-line change to the application’s
SELinux policy, without any application code modiﬁca-
tions. Apache, however, required code modiﬁcations—
not to protect against SKD and oracle attacks, which the
partitioned OpenSSL library defends against, but to pro-
tect sensitive data after the SSL handshake completes. As
noted above, Apache reuses worker processes to serve
successive users’ requests. We modiﬁed Apache to en-
force inter-user isolation: to ensure that an attacker’s ex-
ploit of a worker cannot disclose the sensitive data of
the next user to connect to the same worker. We com-
pare two implementations of this isolation. The ﬁrst is a
naive one in which Apache kills a worker after it serves
one request and forks another to replace it. As the over-
head of fork is signiﬁcant, we compare against an op-
timized implementation based on checkpoint-restore, as
Figure 8: Relationship between privileged (shaded) and unprivileged
(unshaded) code in baseline and hardened OpenSSH server implemen-
tations.
At ﬁrst glance, one might remark that our partitioning
therefore incorporates more privileged code than base-
line OpenSSH. But that assessment is ﬂawed. Rather, the
sensitive state pertaining to a user’s session was incor-
rectly deemed non-sensitive data in baseline OpenSSH.
Hence, we show baseline OpenSSH’s untrusted pro-
cess as shaded—notation for privileged—because it is
already (albeit inappropriately) privileged to manipu-
late sensitive per-session data. Following the partitioning
principles we have offered leads to the correct treatment
of this data as sensitive, the creation of a new privileged
compartment that can exclusively manipulate this data
(the session monitor), and the reduction of privilege for
all remaining code from baseline OpenSSH’s untrusted
process (denoted in the ﬁgure as “unprivileged code”)!
6 Hardened OpenSSL Library
Toward demonstrating the generality of the partitioning
principles presented in Section 4, we have also applied
them to the SSLv3 and TLSv1 cryptographic protocol
implementations in the OpenSSL library. As partition-
ing in accordance with these principles requires a fair
amount of programmer effort, we found the OpenSSL
library a particularly attractive target; hardening the
library allows amortizing one partitioning effort over
a broad range of security-conscious applications. The
resulting hardened OpenSSL library is a drop-in re-
placement that renders any SSL/TLS application linked
against it immune to SKD and oracle attacks. We note,