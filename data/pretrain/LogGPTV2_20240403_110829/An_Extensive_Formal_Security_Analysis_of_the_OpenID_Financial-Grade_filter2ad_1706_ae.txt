### Vulnerability in PKCE Implementation for Public Clients

When considering a straightforward scenario where code leakage to an attacker occurs, and the attacker is unaware of the PKCE verifier, our analysis reveals that the protection can be bypassed by an attacker masquerading as a legitimate client. This vulnerability specifically impacts public clients using the Read-Only profile of the FAPI.

#### Attack Scenario (Refer to Figure 6)

1. **Initial Setup:**
   - Two applications are installed on a user's device: a legitimate app and a malicious app.
   - The legitimate app is registered with an honest Authorization Server (AS) using the client identifier `hon_client_id` and the redirection URI `hon_redir_uri`.
   - The malicious app is not registered with the AS.

2. **Attack Flow:**
   - The attack begins when the malicious app prompts the user to log in.
   - The malicious app prepares an authorization request containing the `hon_client_id` and `hon_redir_uri` of the legitimate app (Step 2).
   - The malicious app also generates a PKCE verifier and includes the corresponding challenge in the authorization request.

3. **Authorization Process:**
   - The flow continues until the browser receives the authorization response in Step 5.
   - Since the redirection URIs are pre-registered at the AS, the authorization response is redirected to the legitimate client after the browser receives it.

4. **Code Leakage:**
   - As described in Sections II-B and III-C1, the authorization response, including the authorization code, may leak to the attacker (Step 6).
   - The malicious app can now exchange the authorization code (associated with the legitimate client) at the token endpoint in Steps 7 and 8 because it knows the correct PKCE verifier. Since the legitimate app is a public client, no additional authentication to the AS is required.

#### Mitigation Strategy

To prevent this attack, the AS must ensure that the PKCE challenge was generated by the client with the `hon_client_id`. For public clients in the Read-Only flow, we propose using the same mechanism as the FAPI for public clients in the Read-Write flow, which involves including a signed JWT in the authorization request. This ensures that the client stated in the request actually made the request, thereby preventing other clients from knowing the PKCE verifier. Note that this approach assumes public clients can store some secrets, such as those protected by user passwords. Our fix is already included in the model, and our analysis (Section V) confirms its effectiveness.

### Authorization Request Leak Attacks

As explained in Section III-C2, the PKCE challenge is designed to work even if the authorization request leaks. However, if the authorization request leaks, both the PKCE challenge and the state value are exposed to the attacker. Our attack demonstrates that an attacker who knows the state value can bypass the CSRF protection provided by the state value. This results in the honest user being logged in under the attacker's identity, compromising session integrity. The details of this attack are presented in Appendix A.

This type of attack is well-known in plain OAuth flows [44], but it is crucial to highlight that the protections designed into the FAPI do not sufficiently protect most flows against such attacks, despite PKCE explicitly addressing this attack vector.

#### Preventing the Attack

To prevent this attack, one must effectively prevent CSRF forgery in this context. However, this is non-trivial due to the strong attacker model considered by the OpenID FAPI Working Group, which assumes leaks and misconfigurations can occur at various points. Simply assuming that the authorization request does not leak to the attacker would not generally solve the problem; one would also need to assume that the authorization response does not leak. These assumptions, however, contradict the FAPI Working Group's intention of providing security even in the presence of strong attackers.

Fortunately, we can prove that regular FAPI web server clients using OAUTB are not vulnerable to this attack, even with the strong attackers assumed by the OpenID FAPI Working Group. Specifically, we can prove session integrity for such clients, which excludes the above attack (see Section V). For all other types of clients, our attack remains effective, and there does not appear to be a fix that would not significantly alter the flows and standards, as discussed in Appendix A. In this sense, our results for session integrity represent the best achievable for the FAPI.

### Formal Security Analysis

In this section, we present a formal analysis of the FAPI. We start by briefly recalling the Web Infrastructure Model (WIM), followed by a sketch of our formal model of the FAPI, which uses the WIM as its basic web infrastructure model. We then introduce central security properties the FAPI is supposed to satisfy, along with our main theorem stating that these properties are met.

#### The Web Infrastructure Model (WIM)

The WIM, introduced by Fett, Küsters, and Schmitz in [22] and further developed in subsequent work, provides a detailed description of the model. It models HTTP(S) requests and responses, including headers like cookies, location, referer, authorization, STS, and origin. The model captures concepts of windows, documents, and iframes, as well as modern technologies like web storage, web messaging, and referrer policies. JavaScript is modeled abstractly through scripts that can create iframes, access other windows, and initiate XMLHttpRequests.

The WIM defines a general communication model and web systems consisting of browsers, DNS servers, and web servers, as well as web and network attackers. The main entities are processes, which listen to IP addresses and communicate via events. The Dolev-Yao approach is used, where messages are expressed as formal terms over a signature Σ. An attacker process records all messages and outputs all possible derivations, while an attacker script performs all possible actions within a browser.

#### Sketch of the Formal FAPI Model

A FAPI web system, denoted by FAPI, is a web system that can contain an unbounded number of clients, authorization servers, resource servers, browsers, and a network attacker. All processes are initially honest and can be dynamically corrupted by the attacker. Clients, authorization servers, and resource servers act according to the FAPI specification, and the model includes the fixes pointed out in Section IV to ensure security properties.

The primary goal of the FAPI is to provide a high degree of security, even in the presence of information leaks. We model this by sending the authorization response, access token, and authorization request to an arbitrary IP address. One FAPI web system contains all possible settings, including all OAuth 2.0 extensions used in the FAPI.

#### Security Properties and Main Theorem

We define the security properties the FAPI should fulfill, namely authorization, authentication, and session integrity. Our main theorem states that these properties are satisfied for all FAPI web systems, regardless of the number of clients and servers and their preconfigured information. There is no notion of time in the WIM, so tokens do not expire, which is a safe overapproximation giving the attacker more power.

For a detailed excerpt of the formal FAPI model, see Appendix C.