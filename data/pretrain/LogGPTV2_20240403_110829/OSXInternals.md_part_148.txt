and the names of the audio tracks on the disc. If it fails, "Audio CD" and " Audio Track"
are used as the album and track names, respectively. The mount utility uses the mount() system call to pass
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 40 of 90
these names to the cddafs kernel extension, which creates a file system view from the audio tracks on the
disc. Each track's filename has the format  .aiff, whereas the album
name is used as the volume's name. The kernel extension also creates an in-memory file
called .TOC.plist, which appears in the root directory along with the track files and contains XML-
formatted table-of-contents data for the disc.
[10] CD-DA stands for Compact Disc Digital Audio.
$ cat /Volumes/Joshua Tree/.TOC.plist
...
Sessions
First Track
1
Last Track
11
Leadout Block
226180
Session Number
1
Session Type
0
Track Array
...
11.7.13. deadfs
deadfs essentially facilitates revocation of accesssay, to the controlling terminal or to a forcibly unmounted
file system. The revoke() system call, which revokes access to a given pathname by invalidating all open
file descriptors that refer to the file, also causes the corresponding vnode to be dissociated from the
underlying file system. Thereafter, the vnode is associated with deadfs. The launchd program uses revoke
() to prepare a controlling terminal while starting a session.
The VFS layer (see Section 11.6) uses the vclean() function [bsd/vfs/vfs_subr.c] to dissociate the
underlying file system from a vnodeit removes the vnode from any mount list it might be on, purges the
name-cache entry associated with the vnode, cleans any associated buffers, and eventually reclaims the
vnode for recycling. Additionally, the vnode is "moved" to the dead file system (deadfs). Its vnode
operations vector is also set to that of the dead file system.
// bsd/vfs/vfs_subr.c
static void
vclean(vnode_t vp, int flags, proc_t p)
{
...
if (VNOP_RECLAIM(vp, &context))
panic("vclean: cannot reclaim");
...
vp->v_mount = dead_mountp; // move to the dead file system
vp->v_op = dead_vnodeop_p; // vnode operations vector of the dead file system
vp->v_tag = VT_NON;
vp->v_data = NULL;
...
}
Most operations in deadfs return an error, with a few exceptions, such as those listed here.
 close() trivially succeeds.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 41 of 90
 fsync() trivially succeeds.
 read() returns end-of-file for character devices but an EIO error for all others.
11.7.14. devfs
The device file system (devfs) provides access to the kernel's device namespace in the global file system
namespace. It allows device entries to be dynamically added and removed. In particular, the I/O Kit's
IOStorageFamily uses devfs functions to add and remove block and character nodes corresponding to
media devices as they are attached and detached, respectively.
devfs is allocated, initialized, and mounted from within the Mac OS X kernel during BSD initialization.
The kernel mounts it on the /dev/ directory by default. Additional instances of it can be mounted later,
from user space, using the mount_devfs program.
$ mkdir /tmp/dev
$ mount_devfs devfs /tmp/dev
$ ls /tmp/dev
bpf0 ptyte ttyr4
bpf1 ptytf ttyr5
...
$ umount /tmp/dev
During bootstrapping, VFS initialization iterates over each built-in file system, calling the file system's
initialization function, which is devfs_init() [bsd/miscfs/devfs/devfs_vfsops.c] in the case of
devfs. Shortly afterward, the kernel mounts devfs. devfs_init() creates device entries for the following
devices: console, tty, mem, kmem, null, zero, and klog.
devfs redirects most of its vnode operations to specfs (see Section 11.7.16).
11.7.15. fdesc
The fdesc file system, which is conventionally mounted on /dev/fd/, provides a list of all active file
descriptors in the calling process.[11] For example, if a process has descriptor number n open, then the
following two function calls will be equivalent:
[11] A process can access only its own open file descriptors using the fdesc file system.
int fd;
...
fd = open("/dev/fd/n", ...); /* case 1 */
fd = dup(n); /* case 2 */
In Mac OS X versions older than 10.4, the /etc/rc startup script mounts the fdesc file system as a union
mount on /dev/. Beginning with Mac OS X 10.4, fdesc is mounted by launchd instead.
// launchd.c
...
if (mount("fdesc", "/dev", MNT_UNION, NULL) == 1)
...
Note that the mount point in launchd's invocation of the mount() system call invocation is /dev/ (and
not /dev/fd/). The fd/ directory is maintained by the fdesc file system as one of the entries in its root
directory. Besides fd/, it also maintains three symbolic links: stdin, stdout, and stderr. The targets of
these links are fd/0, fd/1, and fd/2, respectively. Like devfs, there can be multiple instances of fdesc.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 42 of 90
$ mkdir /tmp/fdesc
$ mount_fdesc fdesc /tmp/fdesc
$ ls -l /tmp/fdesc
total 4
dr-xr-xr-x 2 root wheel 512 Oct 23 18:33 fd
lr--r--r-- 1 root wheel 4 Oct 23 18:33 stderr -> fd/2
lr--r--r-- 1 root wheel 4 Oct 23 18:33 stdin -> fd/0
lr--r--r-- 1 root wheel 4 Oct 23 18:33 stdout -> fd/1
The functionality of fdesc is similar to Linux's /proc/self/fd/ directory, which allows a process to
access its own open file descriptors. Linux systems also have /dev/fd/ symbolically linked
to /proc/self/fd/.
11.7.16. specfs and fifofs
Devices (the so-called special files) and named pipes (fifos) can reside on any file system that can house
such files. Although the host file system maintains the names and attributes of special files, it cannot easily
handle the operations that are performed on such files. In fact, many operations that are relevant for regular
files may not even make sense for special files. Moreover, multiple special files with the same major and
minor numbers may exist with different pathnames on a file system, or even on different file systems. It
must be ensured that each of these filesessentially a device aliasunambiguously refers to the same
underlying device. A related issue is that of multiple buffering, where the buffer cache could hold more
than one buffer for the same block on a device.
Ideally, accesses to device files should be directly mapped to their underlying devicesthat is, to the
respective device drivers. It would be unreasonable to require each file system type to include explicit
support for special file operations. The specfs layer, which was introduced in SVR4, provides a solution to
this problem: It implements special-file vnode operations that can be used by any file system. Consider the
example of a block or character special file on an HFS+ volume. When HFS+ needs a new vnode, say,
during a lookup operation, it calls hfs_getnewvnode() [bsd/hfs/hfs_cnode.c]. The latter checks
whether it is a fifo or a special file. If so, it arranges for the vnode to be created with a vnode operations
table other than the one for HFS+: hfs_fifoop_p and hfs_specop_p redirect appropriate operations to
fifofs and specfs, respectively.
// bsd/hfs/hfs_cnode.c
int
hfs_getnewvnode(struct hfsmount *hfsmp, ...)
{
...
if (vtype == VFIFO )
vfsp.vnfs_vops = hfs_fifoop_p; // a fifo
else if (vtype == VBLK || vtype == VCHR)
vfsp.vnfs_vops = hfs_specop_p; // a special file
else
vfsp.vnfs_vops = hfs_vnodeop_p; // use HFS+ vnode operations
...
if ((retval = vnode_create(VNCREATE_FLAVOR, VCREATESIZE, &vfsp, ...))) {
...
}
Note that both fifofs and specfs are file system layersnot file systems. In particular, they cannot be
mounted, unmounted, or seen by users.
11.7.17. synthfs
synthfs is an in-memory file system that provides a namespace for creation of arbitrary directory trees.
Therefore, it can be used for synthesizing mount pointssay, while booting from a read-only device that may
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 43 of 90
not have a spare directory for use as a mount point. Besides directories, synthfs also allows creation of
symbolic links (but not files).
Although synthfs source is part of the xnu source, the default Mac OS X kernel does not include synthfs as
a compiled-in file system. In the case of such a kernel, you must first compile synthfs.
Let us look at an example of using synthfs. Suppose you have a read-only file system mounted
on /Volumes/ReadOnly/, and you wish to synthesize a directory tree within /Volumes/ReadOnly/mnt/,
where mnt/ is an existing subdirectory. You can do so by mounting an instance of synthfs on top
of /Volumes/ReadOnly/mnt/. Thereafter, you can create directories and symbolic links within the mnt/
subdirectory.
$ lsvfs # ensure that synthfs is available
Filesystem Refs Flags
-------------------------------- ----- ---------------
ufs 0 local
...
synthfs 0
$ ls -F /Volumes/ReadOnly # a read-only volume
mnt/ root/ boot/ ...
$ ls -F /Volumes/ReadOnly/mnt # subdirectory of interest
$ sudo mkdir /Volumes/ReadOnly/mnt/MyDir # cannot create a new directory
mkdir: /Volumes/ReadOnly/mnt: No such file or directory
$ mount_synthfs synthfs /Volumes/ReadOnly/mnt # mount synthfs
$ mount
...
 on /Volumes/ReadOnly/mnt (nodev, suid, mounted by amit)
$ sudo mkdir /Volumes/ReadOnly/mnt/MyDir # try again
$ ls -F /Volumes/ReadOnly/mnt # now a directory can be created
MyDir/
$ umount /Volumes/ReadOnly/mnt # cannot unmount synthfs because of MyDir/
umount: unmount(/Volumes/ReadOnly/mnt): Resource busy
$ sudo rmdir /Volumes/ReadOnly/mnt/MyDir # remove MyDir/
$ umount /Volumes/ReadOnly/mnt # now synthfs can be unmounted
$
Note that if it is required to keep a synthfs mount point's existing contents visible, you can mount synthfs
with the union option (see Section 11.7.18).
11.7.18. union
The null mount file system (nullfs) is a stackable file system in 4.4BSD. It allows mounting of one part of
the file system in a different location. This can be used to join multiple directories into a new directory tree.
Thus, file system hierarchies on various disks can be presented as one directory tree. Moreover, subtrees of
a writable file system can be made read-only. Mac OS X does not use nullfs, but it does provide the union
mount file system, which conceptually extends nullfs by not hiding the files in the "mounted on"
directoryrather, it merges the two directories (and their trees) into a single view. In a union mount,
duplicate names are suppressed. Given a name, a lookup locates the logically topmost entity with that
name. Let us look at a sequence of commands that will illustrate the basic concepts behind union mounting.
First, we create two disk images with HFS+ file systems and attach them.
$ hdiutil create -size 16m -layout NONE -fs HFS+ \
volname Volume1 /tmp/Volume1.dmg
...
$ hdiutil create -size 16m -layout NONE -fs HFS+ \
volname Volume2 /tmp/Volume2.dmg
...
$ hdiutil attach -nomount /tmp/Volume1.img
/dev/disk10 Apple_HFS
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 44 of 90
$ hdiutil attach -nomount /tmp/Volume2.img
/dev/disk11 Apple_HFS
Next, we mount both images and create files on them: Volume1 will contain one file (a.txt), whereas
Volume2 will contain two files (a.txt and b.txt).
$ mkdir /tmp/union
$ mount -t hfs /dev/disk10 /tmp/union
$ echo 1 > /tmp/union/a.txt
$ umount /dev/disk10
$ mount -t hfs /dev/disk11 /tmp/union
$ echo 2 > /tmp/union/a.txt
$ echo 2 > /tmp/union/b.txt
$ umount /dev/disk11
Let us now union-mount both file systems by specifying the union option to the mount command.
$ mount -t hfs -o union /dev/disk10 /tmp/union
$ mount -t hfs -o union /dev/disk11 /tmp/union
Since Volume2 was mounted on top of Volume1, a filename that exists in botha.txt in our casewill be
suppressed in the latter. In other words, we will access the file on the logically topmost volume.
$ ls /tmp/union # contents will be union of Volume1 and Volume2
a.txt b.txt
$ cat /tmp/union/a.txt # this should come from Volume2 (the top volume)
2
$ umount /dev/disk11 # let us unmount Volume2
$ ls /tmp/union # we should only see the contents of Volume1
a.txt
$ cat /tmp/union/a.txt # this should now come from Volume1
1
$ umount /dev/disk10
We can also union-mount the volumes in the opposite order and verify whether doing so causes a.txt to
come from Volume1 instead.
$ mount -t hfs -o union /dev/disk11 /tmp/union
$ mount -t hfs -o union /dev/disk10 /tmp/union
$ ls /tmp/union
a.txt b.txt
$ cat /tmp/union/a.txt
1
If we wrote to a.txt now, it would modify only the top volume (Volume1). The file b.txt appears in the
union but is present only in the bottom volume. Let us see what happens if we write to b.txt.
$ cat /tmp/union/b.txt
2
$ echo 1 > /tmp/union/b.txt
$ cat /tmp/union/b.txt
1
$ umount /dev/disk10s2 # unmount top volume (Volume1)
$ cat /tmp/union/b.txt # check contents of b.txt in Volume2
2
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 45 of 90
We see that the bottom volume's b.txt is unchanged. Our writing to b.txt resulted in its creation as well,
because it did not exist in the union layer we were writing to. If we delete a file that exists in the top two
layers, the file in the topmost layer is deleted, and the one from the layer below shows up.
$ mount -t hfs -o union /dev/disk10 /tmp/union
$ cat /tmp/union/b.txt
1
$ rm /tmp/union/b.txt
$ cat /tmp/union/b.txt
2
The /etc/rc startup script on the Mac OS X installer disc uses union mounting to mount RAM disks on
top of directories that the installation process is likely to write to, such as /Volumes, /var/tmp,
and /var/run.
11.7.19. volfs
The volume ID file system (volfs) is a virtual file system that exists over the VFS of another file system. It
serves the needs of two different Mac OS X APIs: the POSIX API and the Carbon File Manager API.
Whereas the POSIX API uses Unix-style pathnames, the Carbon API specifies a file system object by a
triplet consisting of a volume ID, a containing folder ID, and a node name. volfs makes it possible to use
the Carbon API atop a Unix-style file system.
By default, volfs is mounted on the /.vol directory. Each mounted volume is represented by a
subdirectory under /.vol, provided the volume's file system supports volfs. HFS+ and HFS support volfs,
whereas UFS does not.
In Mac OS X versions prior to 10.4, volfs is mounted by /etc/rc during system startup. Beginning with
Mac OS X 10.4, it is mounted by launchd.
$ mount
/dev/disk1s3 on / (local, journaled)
devfs on /dev (local)
fdesc on /dev (union)
 on /.vol
...
$ ls -li /.vol
total 0
234881029 dr-xr-xr-x 2 root wheel 64 Oct 23 18:33 234881029
/.vol in this example contains only one entry, which corresponds to the root volume. In general, reading
directory entries at the topmost level in a volfs instance will return a list of all mounted volumes that
support volfs. Each directory's name is the decimal representation of the corresponding device number
(dev_t). Given a device's major and minor numbers, the value of dev_t can be constructed using the
makedev() macro.
// 
#define makedev(x,y) ((dev_t)(((x) << 24) | (y)))
Let us compute the device number of the disk in our current example and verify that its volfs entry indeed
has that name.
$ ls -l /dev/disk1s3
brw-r----- 1 root operator 14, 5 Oct 23 18:33 /dev/disk1s3
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh337D.htm 20.08.2007
Chapter 11. File Systems Page 46 of 90
$ perl -e 'my $x = (14 << 24) | 5; print "$x\n"'
234881029
If we know a file's ID and the volume ID of its containing volume, we can access the file through volfs. As
we will see in Chapter 12, a file's inode number (as reported by ls -i) is its HFS+ file ID in most cases.