       return 1;
    }
    if (this.Id > other.Id)
    {
       return 1;
    }
    if (this.Id  interface, refer to
Chapter 19.
9. In Solution Explorer, right-click the QueryBinaryTree project, point to
Add, and then click Reference. In the Reference Manager -
QueryBinaryTree dialog box, in the left pane, click Solution. In the
middle pane, select the BinaryTree project, and then click OK.
10. Display the Program.cs file for the QueryBinaryTree project in the Code
and Text Editor window, and verify that the list of using directives at the
top of the file includes the following line of code (it should be greyed
out as you have not yet written any code that uses types in this
namespace):
using System.Linq;
11. Add the following using directive to the list at the top of the Program.cs
file to bring the BinaryTree namespace into scope:
using BinaryTree;
12. In the doWork method in the Program class, remove the // TODO:
comment and add the following statements shown in bold to construct
and populate an instance of the BinaryTree class:
Click here to view code image
static void doWork()
{
    Tree empTree = new Tree(
        new Employee { Id = 1, FirstName = "Kim", LastName =
"Abercrombie",
Department = "IT"
    });
    empTree.Insert(
        new Employee { Id = 2, FirstName = "Jeff", LastName =
Download from finelybook PI:EMAIL
720
"Hay",
Department = "Marketing"
    });
    empTree.Insert(
        new Employee { Id = 4, FirstName = "Charlie", LastName =
"Herb",
Department = "IT"
    });
    empTree.Insert(
        new Employee { Id = 6, FirstName = "Chris", LastName =
"Preston",
Department = "Sales"
    });
    empTree.Insert(
        new Employee { Id = 3, FirstName = "Dave", LastName =
"Barnett",
Department = "Sales"
    });
    empTree.Insert(
        new Employee { Id = 5, FirstName = "Tim", LastName =
"Litton",
Department = "Marketing"
    });
}
13. Add the following statements shown in bold to the end of the doWork
method. This code invokes the Select method to list the departments
found in the binary tree.
Click here to view code image
static void doWork()
{
    ...
    Console.WriteLine("List of departments");
    var depts = empTree.Select(d => d.Department);
    foreach (var dept in depts)
    {
        Console.WriteLine($"Department: ");
    }
}
14. On the Debug menu, click Start Without Debugging.
Download from finelybook PI:EMAIL
721
The application should output the following list of departments:
Click here to view code image
List of departments
Department: IT
Department: Marketing
Department: Sales
Department: IT
Department: Marketing
Department: Sales
Each department occurs twice because there are two employees in each
department. The order of the departments is determined by the
CompareTo method of the Employee class, which uses the Id property of
each employee to sort the data. The first department is for the employee
with the Id value 1, the second department is for the employee with the
Id value 2, and so on.
15. Press Enter to return to Visual Studio 2017.
16. In the doWork method in the Program class, modify the statement that
creates the enumerable collection of departments as shown in bold in the
following example:
Click here to view code image
var depts = empTree.Select(d => d.Department).Distinct();
The Distinct method removes duplicate rows from the enumerable
collection.
17. On the Debug menu, click Start Without Debugging.
Verify that the application now displays each department only once, like
this:
Click here to view code image
List of departments
Department: IT
Department: Marketing
Department: Sales
18. Press Enter to return to Visual Studio 2017.
19. Add the following statements shown in bold to the end of the doWork
Download from finelybook PI:EMAIL
722
method. This block of code uses the Where method to filter the
employees and return only those in the IT department. The Select
method returns the entire row rather than projecting specific columns.
Click here to view code image
static void doWork()
{
    ...
    Console.WriteLine();
    Console.WriteLine("Employees in the IT department");
    var ITEmployees =
        empTree.Where(e => String.Equals(e.Department, "IT"))
        .Select(emp => emp);
    foreach (var emp in ITEmployees)
    {
        Console.WriteLine(emp);
    }
}
20. After the code from the preceding step, add the following code shown in
bold to the end of the doWork method. This code uses the GroupBy
method to group the employees found in the binary tree by department.
The outer foreach statement iterates through each group, displaying the
name of the department. The inner foreach statement displays the names
of the employees in each department.
Click here to view code image
static void doWork()
{
    ...
    Console.WriteLine("");
    Console.WriteLine("All employees grouped by department");
    var employeesByDept = empTree.GroupBy(e => e.Department);
    foreach (var dept in employeesByDept)
    {
        Console.WriteLine($"Department: {dept.Key}");
        foreach (var emp in dept)
        {
            Console.WriteLine($"\t{emp.FirstName}
{emp.LastName}");
        }
    }
}
21. On the Debug menu, click Start Without Debugging. Verify that the
Download from finelybook PI:EMAIL
723
output of the application looks like this:
Click here to view code image
List of departments
Department: IT
Department: Marketing
Department: Sales
Employees in the IT department
Id: 1, Name: Kim Abercrombie, Dept: IT
Id: 4, Name: Charlie Herb, Dept: IT
All employees grouped by department
Department: IT
        Kim Abercrombie
        Charlie Herb
Department: Marketing
        Jeff Hay
        Tim Litton
Department: Sales
        Dave Barnett
        Chris Preston
22. Press Enter to return to Visual Studio 2017.
Retrieve data from a BinaryTree by using query operators
1. In the doWork method, comment out the statement that generates the
enumerable collection of departments and replace it with the equivalent
statement shown in bold, using the from and select query operators:
Click here to view code image
// var depts = empTree.Select(d => d.Department).Distinct();
var depts = (from d in empTree
             select d.Department).Distinct();
2. Comment out the statement that generates the enumerable collection of
employees in the IT department and replace it with the following code
shown in bold:
Click here to view code image
// var ITEmployees =
//    empTree.Where(e => String.Equals(e.Department, "IT"))
//    .Select(emp => emp);
var ITEmployees = from e in empTree
                  where String.Equals(e.Department, "IT")
Download from finelybook PI:EMAIL
724
                  select e;
3. Comment out the statement that generates the enumerable collection that
groups employees by department and replace it with the statement
shown in bold in the following code:
Click here to view code image
// var employeesByDept = empTree.GroupBy(e => e.Department);
var employeesByDept = from e in empTree
                      group e by e.Department;
4. On the Debug menu, click Start Without Debugging. Verify that the
program displays the same results as before.
Click here to view code image
List of departments
Department: IT
Department: Marketing
Department: Sales
Employees in the IT department
Id: 1, Name: Kim Abercrombie, Dept: IT
Id: 4, Name: Charlie Herb, Dept: IT
All employees grouped by department
Department: IT
        Kim Abercrombie
        Charlie Herb
Department: Marketing
        Jeff Hay
        Tim Litton
Department: Sales
        Dave Barnett
        Chris Preston
5. Press Enter to return to Visual Studio 2017.
LINQ and deferred evaluation
When you use LINQ to define an enumerable collection, either by using the
LINQ extension methods or by using query operators, you should remember
that the application does not actually build the collection at the time that the
LINQ extension method is executed; the collection is enumerated only when
you iterate over it. This means that the data in the original collection can
change in the time between the execution of a LINQ query and when the data
that the query identifies is retrieved; you will always fetch the most up-to-
Download from finelybook PI:EMAIL
725
date data. For example, the following query (which you saw earlier) defines
an enumerable collection of companies in the United States:
Click here to view code image
var usCompanies = from a in addresses
                  where String.Equals(a.Country, "United States")
                  select a.CompanyName;
The data in the addresses array is not retrieved, and any conditions
specified in the Where filter are not evaluated, until you iterate through the
usCompanies collection:
Click here to view code image
foreach (string name in usCompanies)
{
    Console.WriteLine(name);
}
If you modify the data in the addresses array in the time between defining
the usCompanies collection and iterating through the collection (for example,
if you add a new company based in the United States), you will see this new
data. This strategy is referred to as deferred evaluation.
You can force the evaluation of a LINQ query when it is defined and
generate a static, cached collection. This collection is a copy of the original
data and will not change if the data in the collection changes. LINQ provides
the ToList method to build a static List object containing a cached copy of the
data. You use it like this:
Click here to view code image
var usCompanies = from a in addresses.ToList()
                  where String.Equals(a.Country, "United States")
                  select a.CompanyName;
This time, the list of companies is fixed when you create the query. If you
add more United States companies to the addresses array, you will not see
them when you iterate through the usCompanies collection. LINQ also
provides the ToArray method that stores the cached collection as an array.
In the final exercise in this chapter, you will compare the effects of using
deferred evaluation of a LINQ query to generating a cached collection.
Download from finelybook PI:EMAIL
726
Examine the effects of deferred and cached evaluation of a LINQ query
1. Return to Visual Studio 2017, display the QueryBinaryTree project, and
then edit the Program.cs file.
2. Comment out the contents of the doWork method apart from the
statements that construct the empTree binary tree, as shown here:
Click here to view code image
static void doWork()
{
    Tree empTree = new Tree(
        new Employee { Id = 1, FirstName = "Kim", LastName =
"Abercrombie",
Department = "IT"
});
    ...
    empTree.Insert(
        new Employee { Id = 5, FirstName = "Tim", LastName =
"Litton",
Department = "Marketing"
});
    /* comment out the rest of the method
    ...
    */
}
Tip You can comment out a block of code by selecting the entire
block in the Code and Text Editor window and then clicking the
Comment Out The Selected Lines button on the toolbar.
3. Add the following statements shown in bold to the doWork method,
after the code that creates and populates the empTree binary tree:
Click here to view code image
static void doWork()
{
    ...
Download from finelybook PI:EMAIL
727
    Console.WriteLine("All employees");
    var allEmployees = from e in empTree
                       select e;
    foreach (var emp in allEmployees)
    {
        Console.WriteLine(emp);
    }
    ...
}
This code generates an enumerable collection of employees named
allEmployees and then iterates through this collection, displaying the
details of each employee.
4. Add the following code immediately after the statements you typed in
the preceding step:
Click here to view code image
static void doWork()
{
    ...
    empTree.Insert(new Employee
    {
        Id = 7,
        FirstName = "David",
        LastName = "Simpson",
        Department = "IT"
    });
    Console.WriteLine();
    Console.WriteLine("Employee added");
    Console.WriteLine("All employees");
    foreach (var emp in allEmployees)
    {
        Console.WriteLine(emp);
    }
    ...
}
These statements add a new employee to the empTree tree and then
iterate through the allEmployees collection again.
5. On the Debug menu, click Start Without Debugging. Verify that the
output of the application looks like this:
Click here to view code image
Download from finelybook PI:EMAIL
728
All employees
Id: 1, Name: Kim Abercrombie, Dept: IT
Id: 2, Name: Jeff Hay, Dept: Marketing
Id: 3, Name: Dave Barnett, Dept: Sales
Id: 4, Name: Charlie Herb, Dept: IT
Id: 5, Name: Tim Litton, Dept: Marketing
Id: 6, Name: Chris Preston, Dept: Sales
Employee added
All employees
Id: 1, Name: Kim Abercrombie, Dept: IT
Id: 2, Name: Jeff Hay, Dept: Marketing
Id: 3, Name: Dave Barnett, Dept: Sales
Id: 4, Name: Charlie Herb, Dept: IT
Id: 5, Name: Tim Litton, Dept: Marketing
Id: 6, Name: Chris Preston, Dept: Sales
Id: 7, Name: David Simpson, Dept: IT
Notice that the second time the application iterates through the
allEmployees collection, the list displayed includes David Simpson,
even though this employee was added only after the allEmployees
collection was defined.
6. Press Enter to return to Visual Studio 2017.
7. In the doWork method, change the statement that generates the
allEmployees collection to identify and cache the data immediately, as
shown here in bold:
Click here to view code image
var allEmployees = from e in empTree.ToList()
                   select e;
LINQ provides generic and nongeneric versions of the ToList and
ToArray methods. If possible, it is better to use the generic versions of
these methods to ensure the type safety of the result. The data returned
by the select operator is an Employee object, and the code shown in this
step generates allEmployees as a generic List collection.
8. On the Debug menu, click Start Without Debugging. Verify that the
output of the application looks like this:
Click here to view code image
All employees
Id: 1, Name: Kim Abercrombie, Dept: IT
Id: 2, Name: Jeff Hay, Dept: Marketing
Download from finelybook PI:EMAIL
729
Id: 3, Name: Dave Barnett, Dept: Sales
Id: 4, Name: Charlie Herb, Dept: IT
Id: 5, Name: Tim Litton, Dept: Marketing
Id: 6, Name: Chris Preston, Dept: Sales
Employee added
All employees
Id: 1, Name: Kim Abercrombie, Dept: IT
Id: 2, Name: Jeff Hay, Dept: Marketing
Id: 3, Name: Dave Barnett, Dept: Sales
Id: 4, Name: Charlie Herb, Dept: IT
Id: 5, Name: Tim Litton, Dept: Marketing
Id: 6, Name: Chris Preston, Dept: Sales
Notice that the second time the application iterates through the
allEmployees collection, the list displayed does not include David
Simpson. In this case, the query is evaluated and the results are cached
before David Simpson is added to the empTree binary tree.
9. Press Enter to return to Visual Studio 2017.
Summary
In this chapter, you learned how LINQ uses the IEnumerable interface
and extension methods to provide a mechanism for querying data. You also
saw how these features support the query expression syntax in C#.
If you want to continue to the next chapter, keep Visual Studio 2017
running and turn to  Chapter 22, ”Operator overloading.”
If you want to exit Visual Studio 2017 now, on the File menu, click
Exit. If you see a Save dialog box, click Yes and save the project.
Quick reference
To
Do this
Project specified fields
from an enumerable
collection
Use the Select method and specify a lambda
expression that identifies the fields to project. For
example:
Click here to view code image
var customerFirstNames =