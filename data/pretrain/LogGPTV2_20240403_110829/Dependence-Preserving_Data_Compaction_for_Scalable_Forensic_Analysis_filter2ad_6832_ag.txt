7 Related Work
Information-flow Tracking. Numerous systems con-
struct dependence graphs [13, 9, 15, 22] or provenance
graphs [25, 24, 8, 4, 29] that capture information flow at
the coarse granularity of system calls. In particular, if a
subject reads from a network source, then all subsequent
writes by the subject are treated as (potentially) dependent
on the network source. This leads to a dependence explosion,
especially for long-running processes, as every output
operation becomes dependent on every input operation.
Fine-grained taint tracking [28, 41, 2, 12] can address this
problem by accurately tracking the source of each output
byte to a single input operation (or a few). Unfortunately,
these techniques slow down programs by a factor of 2
to 10 or more. BEEP [17, 21] developed an alternative
fine-grained tracking approach called unit-based execution
partitioning that is much more efficient. However, as
compared to taint-tracking techniques, execution partitioning
generally requires some human assistance, and moreover,
makes optimistic assumptions about the program behavior.
The main drawback shared by all fine-grained tracking
approaches is the need for instrumenting applications. In
enterprises that run hundreds of applications from multiple
vendors, this instrumentation requirement is difficult to meet,
and hence it is much more common for enterprises to rely
on coarse-grained tracking.
Log Reduction. BackTracker [13, 14, 15] pioneered the
approach of using system logs for forensic investigation of
intrusions. Their focus was on demonstrating effectiveness
of attack investigation, so they did not pursue log reduction
beyond simple techniques such as omitting “low-control”
(less important) events, such as changing a file’s access time.
LogGC [18] proposed an interesting approach for log
reduction based on the concept of garbage collection, i.e.,
removing operations involving removed files (“garbage”).
Additional restrictions were imposed to ensure that files of in-
terest in forensic analysis, such as malware downloads, aren’t
treated as garbage. They report remarkable log reduction with
this approach, provided it is used in conjunction with their
unit instrumentation. Without such fine-grained instrumenta-
tion, the savings they obtain are modest. To further evaluate
the potential of this approach, we analyzed the data set used
in this paper (Table 8). We found that less than 3% of the oper-
ations in this data set were on files that were subsequently re-
moved. Although not all of these files satisfy their definition
of “garbage,” 3% is an upper bound on the savings achievable
using this garbage collection technique on our data.
ProTracer [22] proposed another new reduction mecha-
nism that was based on logging only the write operations.
Read operations, as well as some memory-related operations
tracked by their unit instrumentation, were not logged. In
the presence of their unit instrumentation, they once again
show a dramatic reduction in log sizes using their strategy.
However, as discussed in the introduction, this strategy
of selective logging of writes can actually increase log
sizes in the absence of unit instrumentation. Indeed, our
experiments with this strategy11 resulted in more than an
order of magnitude increase in log sizes.
11In our experiment, we implemented the method detailed in Table I of
their paper [22]. Our implementation incorporated obvious optimizations
such as avoiding the logging of multiple write records when the subject’s
taint set hasn’t changed.
1738    27th USENIX Security Symposium
USENIX Association
Xu et al.’s notion of
full-trackability equivalence
(LCD-preservation in our terminology) [42] is similar to
our CD-preservation, as discussed in Section 3.2. We
implemented their LCD-preserving reduction algorithm and
found that our FD and SD optimizations achieve significantly
more reduction, as detailed in Section 6.3. The reasons for
this difference were also discussed in Section 6.3.
Provenance capture systems, starting from PASS [25],
incorporate simple reduction techniques such as the removal
of duplicate records. PASS also describes the problem of
cyclic dependencies and their potential to generate a very
large number of versions. They avoid cycles involving multi-
ple processes by merging the nodes for those processes. Our
cycle-collapsing optimization is based on a very similar idea.
ProvWalls [5] is targeted at systems that enforce
Mandatory Access Control (MAC) policies. It leverages
the confinement properties provided by the MAC policy
to identify the subset of provenance data that can be safely
omitted, leading to significant savings on such systems.
Winnower [38] learns compact automata-based behavioral
models for hosts running similar workloads in a cluster.
Only the subset of provenance records that deviate from
the model need to be reported to a central monitoring node,
thereby dramatically reducing the network bandwidth and
storage space needed for intrusion detection across the
cluster. These models contain sufficient detail for intrusion
detection but not forensics. Therefore, Winnower also stores
each host’s full provenance graph locally at the host. In
contrast, our system generates compact logs that preserve
all the information needed for forensics.
File Versioning. The main challenge for file versioning
systems is to control the number of versions, while the
challenge for forensic analysis is to avoid false dependencies.
Unfortunately, these goals conflict. Existing strategies that
avoid false dependencies, e.g., creating a new version of a file
on each write [33], generate too many versions. Strategies
that significantly reduce the number of versions, e.g., open-
close versioning [31],12 can introduce false dependencies.
Many provenance capture systems use versioning as
well. Like versioning file systems, they typically use either
simple versioning that creates many versions (e.g., [4, 29]) or
coarse-grained versioning that does not accurately preserve
dependencies (e.g., [25]).
In contrast, we presented an
approach that provably preserves dependencies, while
generating only a small number of versions in practice.
Provenance capture systems try to avoid cycles in the
provenance graph, since cyclic provenance is meaningless.
Causality-based versioning [24] discusses two techniques
for cycle avoidance. The first of these performs global cycle
detection across all objects and subjects on a system. The
second operates with a view that is local to an object. It
12With this technique, the first open of an existing file for writing causes
a new version to be generated. While the file remains open, subsequent
opens all update the same version.
uses a technique similar to our redundant edge optimization,
but is aimed at cycle avoidance rather than dependency
preservation. They do not consider the other techniques
we discuss in this paper, such as REO*, RNO, and SD
preservation, nor do they establish optimality results.
Graph Compression and Summarization. Several
techniques have been proposed to compress data provenance
graphs by sharing identical substructures and storing only
the differences between similar substructures, e.g., [6, 40, 7].
Bao et al.
[3] compress provenance trees for relational
query results by optimizing the selection of query tree nodes
where provenance information is stored. These compression
techniques, which preserve every detail of the graph, are
orthogonal to our techniques, which can drop or merge edges.
Graph summarization [27, 37] is intended mainly to
facilitate understanding of large graphs but can also be
regarded as lossy graph compression. However, these
techniques are not applicable in our context because they
do not preserve dependencies.
Attack Scenario Investigation. Several recent efforts
have been aimed at recreating the full picture of a complex,
multi-step attack campaign. HERCULE [30] uses community
discovery techniques to correlate attack steps that may
be dispersed across multiple logs. SLEUTH [10] assigns
trustworthiness and confidentiality tags to objects, and its
attack detection and reconstruction are both based on an
analysis of how these tags propagate. PrioTracker [20]
speeds up backward and forward analysis by prioritizing
exploration of paths involving rare or suspicious events.
RAIN [11] uses record-replay technology to support
on-demand fine-grained information-flow tracking, which
can assist in detailed reconstruction of low-level attack steps.
8 Conclusion
In this paper, we formalized the notion of dependency-
preserving data reductions for audit data and developed
efficient algorithms for dependency-preserving audit data
reduction. Using global context available in a versioned
graph, we are able to realize algorithms that are optimal
with respect to our notions of dependency preservation.
Our experimental results demonstrate the power and
effectiveness of our techniques. Our reductions that preserve
full dependence and source dependence reduce the number
of events by factors of 7 and 9.2, respectively, on average in
our experiments, compared to a factor 1.8 using an existing
reduction algorithm [42]. Our experiments also confirm that
our reductions preserve forensic analysis results.
References
[1] Paul Ammann, Sushil Jajodia, and Peng Liu. Recovery from
malicious transactions. IEEE Transactions on Knowledge and Data
Engineering, 2002.
[2] Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexan-
dre Bartel, Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick
USENIX Association
27th USENIX Security Symposium    1739
McDaniel. Flowdroid: Precise context, flow, field, object-sensitive and
lifecycle-aware taint analysis for android apps. SIGPLAN Not., 2014.
[3] Zhifeng Bao, Henning K¨ohler, Liwei Wang, Xiaofang Zhou, and
Shazia Sadiq. Efficient provenance storage for relational queries. In
CIKM, 2012.
[4] Adam Bates, Dave Jing Tian, Kevin RB Butler, and Thomas Moyer.
In
Trustworthy whole-system provenance for the Linux kernel.
USENIX Security, 2015.
[5] Adam Bates, Dave (Jing) Tian, Grant Hernandez, Thomas Moyer,
Kevin R. B. Butler, and Trent Jaeger. Taming the costs of trustworthy
provenance through policy reduction. ACM Trans. Internet Technol.,
2017.
[6] Adriane P. Chapman, H. V. Jagadish, and Prakash Ramanan. Efficient
provenance storage. In ACM SIGMOD, 2008.
[7] Chen Chen, Harshal Tushar Lehri, Lay Kuan Loh, Anupam Alur,
Limin Jia, Boon Thau Loo, and Wenchao Zhou. Distributed
provenance compression. In ACM SIGMOD, 2017.
[8] Ashish Gehani and Dawood Tariq. Spade: support for provenance
auditing in distributed environments. In International Middleware
Conference, 2012.
[9] Ashvin Goel, Kenneth Po, Kamran Farhadi, Zheng Li, and Eyal
de Lara. The Taser intrusion recovery system. In SOSP, 2005.
[10] Md Nahid Hossain, Sadegh M Milajerdi, Junao Wang, Birhanu Eshete,
Rigel Gjomemo, R Sekar, Scott D Stoller, and VN Venkatakrishnan.
Sleuth: real-time attack scenario reconstruction from cots audit data.
In USENIX Security, 2017.
[11] Yang Ji, Sangho Lee, Evan Downing, Weiren Wang, Fazzini Mattia,
Taesoo Kim, Alessandro Orso, and Wenke Lee. Rain: Refinable
attack investigation with on-demand inter-process information flow
tracking. In ACM CCS, 2017.
[12] Vasileios P. Kemerlis, Georgios Portokalidis, Kangkook Jee, and
Angelos D. Keromytis. Libdft: Practical Dynamic Data Flow
Tracking for Commodity Systems. SIGPLAN Not., 2012.
[13] Samuel T. King and Peter M. Chen. Backtracking intrusions. In
SOSP, 2003.
[14] Samuel T. King and Peter M. Chen. Backtracking intrusions. ACM
Transactions on Computer Systems, 2005.
[15] Samuel T. King, Zhuoqing Morley Mao, Dominic G. Lucchetti, and
Peter M. Chen. Enriching intrusion alerts through multi-host causality.
In NDSS, 2005.
[16] Srinivas Krishnan, Kevin Z. Snow, and Fabian Monrose. Trail of
bytes: Efficient support for forensic analysis. In ACM CCS, 2010.
[17] Kyu Hyung Lee, Xiangyu Zhang, and Dongyan Xu. High accuracy at-
tack provenance via binary-based execution partition. In NDSS, 2013.
[18] Kyu Hyung Lee, Xiangyu Zhang, and Dongyan Xu. LogGC: Garbage
collecting audit log. In ACM CCS, 2013.
[19] Zhenkai Liang, Weiqing Sun, V. N. Venkatakrishnan, and R. Sekar.
Alcatraz: An Isolated Environment for Experimenting with Untrusted
Software. In TISSEC, 2009.
[20] Yushan Liu, Mu Zhang, Ding Li, Kangkook Jee, Zhichun Li, Zhenyu
Wu, Junghwan Rhee, and Prateek Mittal. Towards a timely causality
analysis for enterprise security. In NDSS, 2018.
[21] Shiqing Ma, Juan Zhai, Fei Wang, Kyu Hyung Lee, Xiangyu Zhang,
and Dongyan Xu. MPI: Multiple perspective attack investigation with
semantic aware execution partitioning. In USENIX Security, 2017.
[22] Shiqing Ma, Xiangyu Zhang, and Dongyan Xu. ProTracer: Towards
practical provenance tracing by alternating between logging and
tainting. In NDSS, 2016.
[23] Robert Campbell McColl, David Ediger, Jason Poovey, Dan Campbell,
and David A Bader. A performance evaluation of open source graph
databases. In PPAA, 2014.
[24] Kiran-Kumar Muniswamy-Reddy and David A Holland. Causality-
based versioning. ACM Transactions on Storage (TOS), 2009.
[25] Kiran-Kumar Muniswamy-Reddy, David A Holland, Uri Braun, and
Margo I Seltzer. Provenance-aware storage systems. In USENIX ATC,
2006.
[26] Kiran-Kumar Muniswamy-Reddy, Charles P Wright, Andrew
Himmer, and Erez Zadok. A versatile and user-oriented versioning
file system. In USENIX FAST, 2004.
[27] Saket Navlakha, Rajeev Rastogi, and Nisheeth Shrivastava. Graph
summarization with bounded error. In ACM SIGMOD, 2008.
[28] James Newsome and Dawn Song. Dynamic taint analysis for
automatic detection, analysis, and signature generation of exploits
on commodity software. In NDSS, 2005.
[29] Thomas Pasquier, Xueyuan Han, Mark Goldstein, Thomas Moyer,
David Eyers, Margo Seltzer, and Jean Bacon. Practical whole-system
provenance capture. In SoCC, 2017.
[30] Kexin Pei, Zhongshu Gu, Brendan Saltaformaggio, Shiqing Ma, Fei
Wang, Zhiwei Zhang, Luo Si, Xiangyu Zhang, and Dongyan Xu.
HERCULE: Attack story reconstruction via community discovery
on correlated log graph. In ACSAC, 2016.
[31] Douglas S Santry, Michael J Feeley, Norman C Hutchinson, Alistair C
Veitch, Ross W Carton, and Jacob Ofir. Deciding when to forget in
the elephant file system. In SOSP, 1999.
[32] R. Sekar, V. Venkatakrishnan, S. Basu, S. Bhatkar, and D. C.
DuVarney. Model-carrying code: A practical approach for safe
execution of untrusted applications. 2003.
[33] Craig A Soules, Garth R Goodson, John D Strunk, and Gregory R
Ganger. Metadata efficiency in a comprehensive versioning file sys-
tem. Technical report, CARNEGIE-MELLON UNIV PITTSBURGH
PA SCHOOL OF COMPUTER SCIENCE, 2002.
[34] Weiqing Sun, R. Sekar, Gaurav Poothia, and Tejas Karandikar.
Practical Proactive Integrity Preservation: A Basis for Malware
Defense. In IEEE S&P, 2008.
[35] Wai-Kit Sze and R Sekar. A portable user-level approach for
system-wide integrity protection. In ACSAC, 2013.
[36] Wai Kit Sze and R Sekar. Provenance-based integrity protection for
windows. In ACSAC, 2015.
[37] Yuanyuan Tian, Richard A. Hankins, and Jignesh M. Patel. Efficient
aggregation for graph summarization. In ACM SIGMOD, 2008.
[38] Wajih Ul Hassan, Mark Lemay, Nuraini Aguse, Adam Bates,
and Thomas Moyer. Towards scalable cluster auditing through
grammatical inference over provenance graphs. In NDSS, 2018.
[39] V. N. Venkatakrishnan, Peri Ram, and R. Sekar. Empowering mobile
code using expressive security policies. In New Security Paradigms
Workshop, 2002.
[40] Yulai Xie, Dan Feng, Zhipeng Tan, Lei Chen, Kiran-Kumar
Muniswamy-Reddy, Yan Li, and Darrell D.E. Long. A hybrid
approach for efficient provenance storage. In CIKM, 2012.
[41] Wei Xu, Sandeep Bhatkar, and R. Sekar. Practical dynamic taint
analysis for countering input validation attacks on web applications.
Technical Report SECLAB-05-04, Department of Computer Science,
Stony Brook University, May 2005.
[42] Zhang Xu, Zhenyu Wu, Zhichun Li, Kangkook Jee, Junghwan Rhee,
Xusheng Xiao, Fengyuan Xu, Haining Wang, and Guofei Jiang. High
fidelity data reduction for big data security dependency analyses. In
ACM CCS, 2016.
[43] Ningning Zhu and Tzi-cker Chiueh. Design, implementation, and
In Dependable Systems and
evaluation of repairable file service.
Networks, 2003.
1740    27th USENIX Security Symposium
USENIX Association