title:FlowFox: a web browser with flexible and precise information flow
control
author:Willem De Groef and
Dominique Devriese and
Nick Nikiforakis and
Frank Piessens
FlowFox: a Web Browser with Flexible and Precise
Information Flow Control
Willem De Groef, Dominique Devriese, Nick Nikiforakis and Frank Piessens
IBBT–DistriNet, KU Leuven
Celestijnenlaan 200a, 3001 Heverlee, Belgium
ﬁPI:EMAIL
ABSTRACT
We present FlowFox, the ﬁrst fully functional web browser
that implements a precise and general information ﬂow con-
trol mechanism for web scripts based on the technique of se-
cure multi-execution. We demonstrate how FlowFox sub-
sumes many ad-hoc script containment countermeasures de-
veloped over the last years. We also show that FlowFox
is compatible with the current web, by investigating its be-
havior on the Alexa top-500 web sites, many of which make
intricate use of JavaScript.
The performance and memory cost of FlowFox is sub-
stantial (a performance cost of around 20% on macro bench-
marks for a simple two level policy), but not prohibitive.
Our prototype implementation shows that information ﬂow
enforcement based on secure multi-execution can be imple-
mented in full-scale browsers. It can support powerful, yet
precise policies reﬁning the same-origin-policy in a way that
is compatible with existing websites.
Categories and Subject Descriptors
H.4.3 [Information Systems Applications]: Com-
munications Applications—Information browsers; K.6.5
[Management of Computing and Information Sys-
tems]: Security and Protection
General Terms
Security, Design, Documentation, Veriﬁcation
Keywords
Web Security, Information Flow, Web Browser Architecture
1.
INTRODUCTION
A web browser handles content from a variety of origins,
and not all of these origins are equally trustworthy. More-
over, this content can be a combination of markup and ex-
ecutable scripts where the scripts can interact with their
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.
environment through a collection of powerful APIs that of-
fer communication to remote servers, communication with
other pages displayed in the browser, and access to user,
browser and application information including information
such as the geographical location, clipboard content, browser
version and application page structure and content. With
the advent of the HTML5 standards [22, 17], the collection
of APIs available to scripts has substantially expanded.
An important consequence is that scripts can be used to
attack the conﬁdentiality or integrity of that information.
Scripts can leak session identiﬁers [33], inject requests into
an ongoing session [7], sniﬀ the user’s browsing history, or
track the user’s behavior on a web site [23]. Such malicious
scripts can enter a web page because of a cross-site scripting
vulnerability [25], or because the page integrates third party
scripts such as advertisements, or gadgets. A recent study
has shown that almost all popular web sites include such
remotely-hosted scripts [32]. Barth et al. [8, 1] have pro-
posed the gadget attacker, as an appropriate attacker model
for this broad class of attacks against the browser.
The importance of these attacks has led to many counter-
measures being implemented in browsers. The ﬁrst line of
defense is the same-origin-policy (SOP) that imposes re-
strictions on the way in which scripts and data from dif-
ferent origins can interact. However, the SOP is known to
have holes [39], and all of the attacks cited above bypass
the SOP. Hence, additional countermeasures have been im-
plemented or proposed. Some of these are ad-hoc security
checks added to the browser (e.g. to defend against history-
sniﬃng attacks, browsers responded with prohibiting access
to the computed style of HTML elements [42]), others are
elaborate and well thought-out research proposals to address
speciﬁc subclasses of such attacks (e.g. AdJail [40] proposes
an architecture to contain advertisement scripts).
Several researchers [12, 30] have proposed information
ﬂow control as a general and powerful security enforcement
mechanism that can address many of these attacks, and
hence reduce the need for ad-hoc or purpose-speciﬁc counter-
measures. Several prototypes that implement some limited
form of information ﬂow control have been developed; we
discuss these in detail in Section 6. However, general, ﬂex-
ible, sound and precise information ﬂow control is diﬃcult
to achieve, and so far nobody has been able to demonstrate
a fully functional browser that enforces sound and precise
information ﬂow control for web scripts. As a consequence,
there was no evidence for the practicality of this approach
in the context of web applications, till now.
In this paper, we present FlowFox, the ﬁrst fully func-
748tional web browser (implemented as a modiﬁed Mozilla Fire-
fox) that implements a precise and general information ﬂow
control mechanism based on the technique of secure multi-
execution [18]. FlowFox can enforce general information
ﬂow based conﬁdentiality policies on the interactions be-
tween web scripts and the browser API. Information entering
or leaving scripts through the API is labeled with a conﬁ-
dentiality label chosen from a partially ordered set of labels,
and FlowFox enforces that information can only ﬂow up-
ward in a script.
We report on several experiments we performed with Flow-
Fox. We measured performance and memory cost, and we
show how FlowFox can provide (through suitable choice of
the policy enforced) the same security guarantees as many
ad-hoc browser security countermeasures. We also inves-
tigate the compatibility of some of these policies with the
top-500 Alexa web sites.
While the costs incurred by FlowFox are non-negligible, we
believe our prototype provides evidence of the suitability of
information ﬂow security in the context of the web, and fur-
ther improvements in design and implementation will reduce
performance, memory and compatibility costs. As an anal-
ogy, the reader might remember that the ﬁrst backwards-
compatible bounds-checkers for C [26] incurred a perfor-
mance cost of a factor of 10, and that a decade of further
research eventually reduced this to an overhead of 60% [2,
46].
In summary, this paper has the following contributions:
• We present the design and implementation of Flow-
Fox, the ﬁrst fully functional web browser with sound
and precise information ﬂow controls for JavaScript.
FlowFox is available for download, and can success-
fully browse to complex web sites including Amazon,
Google, Facebook, Yahoo! and so forth.
• We show how FlowFox can subsume many ad-hoc
security countermeasures by a suitable choice of policy.
• We evaluate the performance and memory cost of
FlowFox compared to an unmodiﬁed Firefox.
• We evaluate the compatibility of FlowFox with the
current web by comparing the output of FlowFox
with the output of an unmodiﬁed Firefox.
The remainder of this paper is organized as follows:
in
Section 2 we deﬁne our threat model, and give examples
of threats that are in scope and out of scope for this pa-
per. Section 3 gives a high-level overview of the design of
FlowFox, and Section 4 discusses key implementation as-
pects. In Section 5, we evaluate FlowFox with respect to
compatibility, security and performance. Section 6 discusses
related work, and Section 7 concludes.
2. THREAT MODEL
Our attacker model is based on the gadget attacker [8,
§2]. This attacker has two important capabilities. First, he
can operate his own web sites, and entice users into visiting
these sites. Second, he can inject content into other web
sites, e.g. because he can exploit a cross-site scripting (XSS)
vulnerability in the other site, or because he can provide
an advertisement or a gadget that will be included in the
other site. The attacker does not have any special network
privileges (he can’t eavesdrop on nor tamper with network
traﬃc).
The baseline defense against information leaking through
scripts is the SOP. However, it is well-known that the SOP
provides little to no protection against the gadget attacker:
scripts included by an origin have full access to all informa-
tion shared between the browser and that origin, and can
eﬀectively transmit that information to any third party e.g.
by encoding the information in a URL, and issuing a GET
request for that URL.
Not only conﬁdentiality of information is important; users
also care about integrity. But for the purpose of this paper,
we limit our attention to conﬁdentiality and leave the study
of enforcing integrity to future work.
For the rest of this paper, we consider users surﬁng the
web with a web browser. Typically, these users care about
the conﬁdentiality of the following types of information:
Application Data.
The user interacts with a variety of sites that he shares
sensitive information with. Prototypical examples of such
sites are banking or e-government sites. The user cares
about the conﬁdentiality of information (e.g. tax returns)
exchanged with these sites. Access to such information is
available to scripts through the Document Object Model
(DOM) API.
User Interaction Data.
Information about the user’s mouse movements and clicks,
scrolling behavior, or the selection, copying and pasting of
text can be (and is) collected by scripts to construct heat
maps, or to track what text is being copied from a site [23,
§5]. Collection of such information by scripts is implemented
by installing event handlers for keyboard and mouse activi-
ties.
Meta Data.
Meta information about the current web site (like cook-
ies), or about the browsing infrastructure (e.g. screen size).
Leakage of such information can enable other attacks, e.g.
session hijacking after leaking of a session cookie. Again,
scripts have access to this type of information through APIs
oﬀered by the browser.
With these information assets and attacker model
in
mind, we give concrete example threats that are in scope,
and threats we consider out-of-scope for this paper.
2.1 In-scope Threats
Here are some concrete examples of threats that can be
mitigated by FlowFox. We will return to these examples
further in the paper.
Session Hijacking through Session Cookie Stealing.
A gadget attacker can inject a script that reads the shared
session cookie between the browser and an honest site A, and
leak it back to the attacker, who can now hijack the session:
1 new Image().src = "http://attack/?=" + document.cookie;
Several ad-hoc countermeasures against this threat have
been proposed.
A representative example is Session-
Shield [33] that uses heuristics to identify what cookies are
749session cookies, and then blocks script access to these session
cookies.
Malicious Advertisements.
Web sites regularly include advertisements implemented
as web scripts in their pages. These advertisement scripts
then have access to application data in the page. This is
sometimes desirable, as it enables context-sensitive adver-
tising, yet it also exposes user private data to the advertise-
ment provider.
Again, several countermeasures have been developed. A
representative example is AdJail [40] that addresses conﬁ-
dentiality as well as integrity attacks by means of an isolation
mechanism that runs the advertisement code in a separate
hidden iframe.
History Snifﬁng and Behavior Tracking.
An empirical study by Jang et al. [23] shows that many
web sites (including popular web sites within the Alexa
global top 100) use web scripts to exﬁltrate user interaction
data and meta data, for example browsing history. This
kind of functionality is even oﬀered as a commercial service
by web analytics companies.
The adaptation of the Style API is an example of an ad-
hoc countermeasure speciﬁcally developed to mitigate the
history sniﬃng threat [6], but most of the privacy leaks de-
scribed by Jang et al. [23] are not yet countered in modern
browsers.
2.2 Out-of-scope Threats
Browser security is a broad ﬁeld, facing many diﬀerent
types of threats. We list threats that are not in scope for
the countermeasure discussed in this paper, and need to be
handled by other defense mechanisms.
Integrity Threats.
As discussed earlier, we focus only on conﬁdentiality-
related threats. Examples of integrity-related threats in-
clude user interface redressing attacks (e.g. clickjacking),
and cross-site request forgery (CSRF) attacks.
Implementation-level Attacks Against the Browser.
A browser is a complex piece of software with a large
network-facing attack surface.
Implementation-level vul-
nerabilities in the browser code may allow an attacker to
gain user-level or even administrator-level privileges on the
machine where the browser is running. A wide variety of
countermeasures to harden implementations against these
threats exist [45], and we don’t consider them in this pa-
per. Typical examples of attacks in this category include
heap-spraying attacks [16] or drive-by-downloads [35, 34].
Threats Not Related to Scripting.
This includes e.g. attacks at the network level (eavesdrop-
ping on or tampering with network traﬃc) or CSRF attacks
that do not make use of scripts [7].
3. FLOWFOX
In this section we describe the design of FlowFox. First,
we brieﬂy recap some notions of information ﬂow security
and the secure multi-execution (SME) enforcement mecha-
nism. Then we discuss how SME can be applied to browsers,
and we motivate our design where only scripts are multi-
executed instead of the full browser. Finally, we discuss
what policies can be enforced by FlowFox.
3.1 Information Flow Security
Information ﬂow security is concerned with regulating how
information can ﬂow through a program. One speciﬁes a
policy for a program by labeling all input and output op-
erations to the program with a security label. These labels
represent a conﬁdentiality level, and they are partially or-
dered where one label is above another label if it represents
a higher level of conﬁdentiality. One then tries to enforce
that information only ﬂows upward through the program.
This is often formalised as non-interference – a determin-
istic program is non-interferent if there are no two runs of
the program with inputs identical up to a level l but some
diﬀerent outputs at a level below l. While there has been
a substantial body of research on information ﬂow security
over the past decades, the JavaScript language, and the web
context bring signiﬁcant additional challenges, including e.g.
dealing with the dynamic nature of JavaScript.
For the remainder of this paper, we limit our attention to
the case where there are only two security labels: high (H)
for conﬁdential information, and low (L) for public informa-
tion. As we will show, many useful policies can be speciﬁed
with only these two levels. But this is not a fundamental
limitation: FlowFox scales to an arbitrary number of levels
(albeit at a considerable performance and memory cost).
3.2 Secure Multi-Execution
Secure multi-execution (SME) [18, 13]
is a new dy-
namic enforcement mechanism for information ﬂow security
with practical advantages when applied in the context of
JavaScript web applications [18, §VI.D].
The core idea of SME is to execute the program multiple
times – once for every security label, while applying speciﬁc
rules for input and output (I/O) operations in the program.
We summarize the SME I/O rules for the two element lattice
that we consider in this paper:
1. I/O operations are executed only in the executions at
the same security level as the operation. This ensures
that any I/O operation is only performed once.
2. Output operations at other levels are suppressed.
3. High input operations in the low execution are handled
as follows: the input operation is skipped, and returns
a default value of the appropriate type.
4. Low input operations in the high execution wait for the
low execution to perform this input, and then reuse the
value that was input at the low level.
It is relatively easy to see that executing a program un-
der the SME regime will guarantee non-interference: the
copy that does output at level L only sees inputs of level L
and hence the output could not have been inﬂuenced by in-
puts of level H. For a more general description of the SME
mechanism, and a soundness proof, the reader is referred to
Devriese and Piessens [18], and to Kashyap et al. [27].
3.3 In-Browser SME
An important design decision when implementing SME for
web scripts is how to deal with the browser API exposed to
750Script
Script
Script L
Script H
Browser L Browser H
Browser
Operating System
Operating System
Figure 1: Two design alternatives.
scripts. A ﬁrst option is to multi-execute the entire browser:
the API interactions would become internal interactions and
each SME copy of the browser would have its own copy of
the DOM. Both Bielova et al. [10] and Capizzi et al. [13]
applied this strategy in their implementations.
The alternate strategy is to only multi-execute the web
scripts and to treat all interactions with the browser API
as inputs and outputs. Both designs are shown in Figure 1.
Both designs have their advantages and disadvantages.
When multi-executing the entire browser, the information
ﬂow policy has to label inputs and outputs at the abstrac-
tion level provided by the operating system. The policy can
talk about I/O to ﬁles and network connections, or about
windows and mouse events. Multi-execution can be im-
plemented relatively easily by running multiple processes.
However, at this level of abstraction, the SME enforcement
mechanism lacks the necessary context information to give
an appropriate label to e.g. mouse events. The operating
system does not know to which tab, or which HTML element
in that tab a speciﬁc mouse click or key press is directed.
It can also not distinguish individual HTML elements that
scripts are reading from or writing to.
When multi-executing only the scripts, the information ﬂow
policy has to label inputs and outputs at the abstraction
level oﬀered by the browser API. The policy can talk about
reading from or writing to the text content of speciﬁc HTML
elements, and can assign appropriate labels to such in-
put and output operations. However, implementing multi-
execution is harder, as it now entails making cross-cutting
modiﬁcations to the source code of a full-blown browser –
e.g. a system call interface is cleaner from a design per-
spective than a prototypical web browser and as such easier
to modify. Also, policies become more complex, as there
are much more methods in the browser API than there are
system calls.
FlowFox takes the second approach, as the ﬁrst ap-
proach is too coarse grained and imprecise to counter rel-
evant threats. The ﬁrst approach (taken by [13, 10]) can
e.g. not protect against a script leaking an e-mail typed by
the user into a web mail application to any third party with
whom the browser has an active session in another tab, be-
cause the security enforcement mechanism cannot determine
to which origin the user text input is directed.
Hence, browser API interactions are treated as inputs and
outputs in FlowFox, and should be labeled with an appro-
priate security label. Based on a simple example, we show