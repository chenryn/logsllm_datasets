么意思吧。这个-1，我们一般称为“魔鬼数”，上帝遇到它也会发狂的。所以，我奉劝你
代码里一定不要出现“魔鬼数”。
第一章我们详细讨论了const 这个关键字，我们知道const 修饰的数据是有类型的，
而define 宏定义的数据没有类型。为了安全，我建议你以后在定义一些宏常数的时候用
const代替，编译器会给const 修饰的只读变量做类型校验，减少错误的可能。但一定要注
意const修饰的不是常量而是readonly 的变量，const 修饰的只读变量不能用来作为定义
数组的维数，也不能放在case 关键字后面。
3.1.2 字符串宏常量
除了定义宏常数之外，经常还用来定义字符串，尤其是路径：
A),#define ENG_PATH_1 E:\English\listen_to_this\listen_to_this_3
B),#define ENG_PATH_2 “E:\English\listen_to_this\listen_to_this_3”
噢，到底哪一个正确呢？如果路径太长，一行写下来比较别扭怎么办？用反斜杠接续符啊：
C), #define ENG_PATH_3 E:\English\listen_to_this\listen\
_to_this_3
还没发现问题？这里用了 4 个反斜杠，到底哪个是接续符？回去看看接续符反斜杠。反斜
杠作为接续符时，在本行其后面不能再有任何字符，空格都不行。所以，只有最后一个反斜
杠才是接续符。至于A)和B)，那要看你怎么用了，既然define 宏只是简单的替换，那给
ENG_PATH_1 加上双引号不就成了：“ENG_PATH_1”。
但是请注意：有的系统里规定路径的要用双反斜杠“\\”,比如：
#define ENG_PATH_4 E:\\English\\listen_to_this\\listen_to_this_3
- 57 -
3.1.3 用 define 宏定义注释符号？
上面对define 的使用都很简单，再看看下面的例子：
#define BSC //
#define BMC /*
#define EMC */
D),BSC my single-line comment
E),BMC my multi-line comment EMC
D)和E)都错误，为什么呢？因为注释先于预处理指令被处理,当这两行被展开成//…或
/*…*/时,注释已处理完毕,此时再出现//…或/*…*/自然错误.因此,试图用宏开始或结
束一段注释是不行的。
3.1.4 用 define 宏定义表达式
这些都好理解，下面来点有“技术含量”的：
定义一年有多少秒：
#define SEC_A_YEAR 60*60*24*365
这个定义没错吧？很遗憾，很有可能错了，至少不可靠。你有没有考虑在16 位系统下
把这样一个数赋给整型变量的时候可能会发生溢出？一年有多少秒也不可能是负数吧。修改
一下：
#define SEC_A_YEAR （60*60*24*365）UL
又出现一个问题，这里的括号到底需不需要呢？继续看一个例子：
定义一个宏函数，求x 的平方：
#define SQR (x) x * x
对不对？试试：假设x 的值为10，SQR (x)被替换后变成10*10。没有问题。
再试试：假设x 的值是个表达式10+1，SQR (x)被替换后变成10+1*10+1。问题来了，
这并不是我想要得到的。怎么办？括号括起来不就完了？
#define SQR (x) （（x）*（x））
最外层的括号最好也别省了，看例子：
求两个数的和：
#define SUM (x) （x）+（x）
如果x 的值是个表达式5*3,而代码又写成这样：SUM (x)* SUM (x)。替换后变成：（5*3）
+（5*3）*（5*3）+（5*3）。又错了！所以最外层的括号最好也别省了。我说过define 是
个演技高超的替身演员，但也经常耍大牌。要搞定它其实很简单，别吝啬括号就行了。
注意这一点：宏函数被调用时是以实参代换形参。而不是“值传送”。留四个问题：
A)，上述宏定义中“SUM”、“SQR”是宏吗？
B)，#define EMPTY
这样定义行吗？
C)，打印上述宏定义的值：printf（“SUM (x)”）；结果是什么？
D), “#define M 100”是宏定义吗？
- 58 -
3.1.5 宏定义中的空格
另外还有一个问题需要引起注意，看下面例子：
#define SUM （x） （x）+（x）
这还是定义的宏函数SUM（x）吗？显然不是。编译器认为这是定义了一个宏：SUM，其
代表的是（x） （x）+（x）。为什么会这样呢？其关键问题还是在于SUM 后面的这个空格。
所以在定义宏的时候一定要注意什么时候该用空格，什么时候不该用空格。这个空格仅仅在
定义的时候有效，在使用这个宏函数的时候，空格会被编译器忽略掉。也就是说，上一节定
义好的宏函数SUM（x）在使用的时候在SUM 和（x）之间留有空格是没问题的。比如：SUM
（3）和SUM （3）的意思是一样的。
3.1.6，#undef
#undef 是用来撤销宏定义的，用法如下：
#define PI 3.141592654
…
// code
#undef PI
//下面的代码就不能用PI 了，它已经被撤销了宏定义。
也就是说宏的生命周期从#define 开始到#undef 结束。很简单，但是请思考一下这
个问题：
#define X 3
#define Y X*2
#undef X
#define X 2
int z=Y;
z 的值为多少？
3.2 条件编译
条件编译的功能使得我们可以按不同的条件去编译不同的程序部分，因而产生不同的目
标代码文件。这对于程序的移植和调试是很有用的。条件编译有三种形式，下面分别介绍：
第一种形式：
#ifdef 标识符
程序段1
#else
程序段2
#endif
它的功能是，如果标识符已被#define 命令定义过则对程序段1 进行编译；否则对程
序段2进行编译。如果没有程序段2(它为空)，本格式中的#else 可以没有，即可以写为：
#ifdef 标识符
程序段
#endif
第二种形式：
#ifndef 标识符
- 59 -
程序段1
#else
程序段2
#endif
与第一种形式的区别是将‚ifdef‛改为‚ifndef‛。它的功能是，如果标识符未被
#define 命令定义过则对程序段1 进行编译，否则对程序段2 进行编译。这与第一种形式
的功能正相反。
第三种形式：
#if 常量表达式
程序段1
#else
程序段2
#endif
它的功能是，如常量表达式的值为真(非0)，则对程序段1 进行编译，否则对程序段2 进
行编译。因此可以使程序在不同条件下，完成不同的功能。至于#elif 命令意义与else if
相同，它形成一个if else-if 阶梯状语句，可进行多种编译选择。
3.3 文件包含
文件包含是预处理的一个重要功能，它可用来把多个源文件连接成一个源文件进行编
译，结果将生成一个目标文件。Ｃ语言提供#include 命令来实现文件包含的操作，它实际
是宏替换的延伸，有两种格式：
格式1：
#include 
其中，filename 为要包含的文件名称，用尖括号括起来，也称为头文件，表示预处理
到系统规定的路径中去获得这个文件（即C 编译系统所提供的并存放在指定的子目录下的头
文件）。找到文件后，用文件内容替换该语句。
格式2：
#include ‚filename‛
其中，filename 为要包含的文件名称。双引号表示预处理应在当前目录中查找文件名
为filename 的文件，若没有找到，则按系统指定的路径信息，搜索其他目录。找到文件后，
用文件内容替换该语句。
需要强调的一点是：#include 是将已存在文件的内容嵌入到当前文件中。
另外关于#include 的路径也有点要说明：include 支持相对路径，格式如
trackant(蚁迹寻踪)所写：
.代表当前目录，..代表上层目录。
3.4 #error 预处理
#error 预处理指令的作用是，编译程序时，只要遇到#error 就会生成一个编译错误
提示消息，并停止编译。其语法格式为：
#error error-message
注意，宏串error-message 不用双引号包围。遇到#error 指令时，错误信息被显示，
- 60 -
可能同时还显示编译程序作者预先定义的其他内容。关于系统所支持的error-message 信
息，请查找相关资料，这里不浪费篇幅来做讨论。
3.5 #line 预处理
#line 的作用是改变当前行数和文件名称，它们是在编译程序中预先定义的标识符命
令的基本形式如下：
#line number["filename"] //其中[]内的文件名可以省略。
例如： #line 30 a.h
其中，文件名a.h 可以省略不写。这条指令可以改变当前的行号和文件名，例如上面
的这条预处理指令就可以改变当前的行号为30，文件名是a.h。初看起来似乎没有什么用，
不过，他还是有点用的，那就是用在编译器的编写中，我们知道编译器对C 源码编译过程中
会产生一些中间文件，通过这条指令，可以保证文件名是固定的，不会被这些中间文件代替，
有利于进行分析。
3.6 #pragma 预处理
在所有的预处理指令中，#pragma 指令可能是最复杂的了，它的作用是设定编译器的
状态或者是指示编译器完成一些特定的动作。#pragma 指令对每个编译器给出了一个方法,
在保持与C 和C ++语言完全兼容的情况下,给出主机或操作系统专有的特征。依据定义,编
译指示是机器或操作系统专有的,且对于每个编译器都是不同的。
其格式一般为:
#pragma para
其中para 为参数，下面来看一些常用的参数。
3.6.1 #pragma message
message 参数：Message 参数是我最喜欢的一个参数，它能够在编译信息输出窗口中
输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为：
#pragma message(‚消息文本‛)
当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。
当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没
有正确的设置这些宏，此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判
断自己有没有在源代码的什么地方定义了_X86 这个宏可以用下面的方法
#ifdef _X86
#Pragma message(‚_X86 macro activated!‛)
#endif
当我们定义了_X86 这个宏以后，应用程序在编译时就会在编译输出窗口里显示‚_X86
macro activated!‛。我们就不会因为不记得自己定义的一些特定的宏而抓耳挠腮了。
- 61 -
3.6.2 #pragma code_seg
另一个使用得比较多的pragma 参数是code_seg。格式如：
#pragma code_seg( ["section-name"[,"section-class"] ] )
它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。
3.6.3 #pragma once
#pragma once (比较常用）
只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在
Visual C++6.0 中就已经有了，但是考虑到兼容性并没有太多的使用它。
3.6.4 #pragma hdrstop
#pragma hdrstop 表示预编译头文件到此为止，后面的头文件不进行预编译。BCB 可
以预编译头文件以加快链接的速度，但如果所有头文件都进行预编译又可能占太多磁盘空
间，所以使用这个选项排除一些头文件。
有时单元之间有依赖关系，比如单元A 依赖单元B，所以单元B 要先于单元A 编译。你
可以用#pragma startup 指定编译优先级，如果使用了#pragma package(smart_init) ，
BCB就会根据优先级的大小先后编译。
3.6.5 #pragma resource
#pragma resource "*.dfm"表示把*.dfm 文件中的资源加入工程。*.dfm 中包括窗
体外观的定义。
3.6.6 #pragma warning
#pragma warning( disable : 4507 34; once : 4385; error : 164 )
等价于：