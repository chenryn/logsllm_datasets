enriched one is not either. This is the same as in Section 5.2.
Proof. We apply Lemma 2 to get reader correctness.
Correctness of the tag output works as in [14].
In the simple security model where there is a single tag,
no corruption, and no Result queries, we replace the F
computations by using the lazy sampling technique as fol-
lows. First, we assume that the reader never picks the same
a twice and that the tag never picks the same b twice so all
computations hold on diﬀerent inputs. Then, we simulate
all c and d releases by random strings and show this does
not aﬀect the success probability of the adversary, thanks
to the PRF property. We can then easily show that the
success probability is 2−γ times the total number of session
instances on both sides. Since this is negligible, we deduce
simple security thus security from Lemma 1.
To prove weak privacy, we only prove narrow-weak privacy
and apply Lemma 3. The above lazy sampling technique is
also well ﬁtted to narrow-weak model, so a trivial blinder
which just picks random a, b, c, and d will work.
6.2 Narrow-Destructive Privacy in the Ran-
dom Oracle Model
We now enrich the protocol form [14] based on random
oracles. We use two oracles F and G implementing two
random functions from {0, 1}α+k+1 and {0, 1}k to {0, 1}k,
Tag
state: S
c = F (0, S, a)
d0 = F (1, S, a)
replace S by G(S)
check d = d0
output: OK iﬀ check
(S = K)
←−−−−−−−−−−−−−−− pick a ∈ {0, 1}α
a
System
{. . . , (ID, K), . . .}
−−−−−−−−−−−−−−−→ ﬁnd (ID, K) and i s.t.
c
←−−−−−−−−−−−−−−− d = F (1, K, a)
d
c = F (0, Gi(K), a) and i < t
replace K by Gi(K)
if not found, set K to random
output: ID or ⊥ if not found
Figure 2: A Narrow-Destructive-Private RFID Scheme based on a Random Oracle.
respectively. The tag generation SetupTag(ID) picks a ran-
dom k-bit key K and sets the initial state to S = K. The
protocol is depicted on Fig. 2.
1. The reader picks a random α-bit string a and sends it
to the tag.
2. The tag with state S sends the value c = F (0, S, a),
stores d0 = F (1, S, a) in temporary memory, then re-
freshes its state S with G(S).
3. The reader looks for (ID, K) in the database such that
c = F (0, Gi(K), a) with i < t, gets ID, sends d =
F (1, Gi(K), a) to the tag, and replaces entry (ID, K)
by (ID, Gi(K)) in the database.
4. The tag checks d = d0.
After t malicious queries to the tag, it is “grilled” because
its state and the database are de-synchronized. Thus, the
hypothesis of Lemma 3 is not fulﬁlled.
There exist many variants of this protocol [2, 4, 10, 11, 9].
Theorem 3. Assuming that the parameters k and t are
polynomially bounded and that 2−k is negligible, the above
scheme is a secure and narrow-destructive private RFID
scheme in the random oracle model.
As already seen, this protocol fails to be weak private. This
is the same as in Section 5.1.
Proof. We apply Lemma 2 to get reader correctness. In
cases where the tag was correctly identiﬁed by the reader,
tag correctness is rather trivial.
To prove security, we only have to prove simple reader
authentication and to apply Lemma 1. To do so, we assume
w.l.o.g. that the reader never picks the same a twice and
that iterating S ←− G(S) on the tag does not cycle during
the attack. We consider a protocol transcript (a, c, d) on the
tag side with no matching conversation with the reader and
we stop the adversary before sending d to the tag.
If a was not released by any protocol session, then the
query (1, S, a) was only made once to compute the expected
d0. Hence, the value of d0 is random and matches d with
negligible probability.
If a was released by a protocol session, from our assump-
tion it was selected only once in a session π. Let ˆc the value
If c 6= ˆc, the
sent back to the reader and ˆd its response.
reader cannot identify the tag thanks to simple tag authen-
tication. Hence, ˆd comes from a random query. So, the value
of d0 is random and matches d with negligible probability.
Finally, if c = ˆc, since conversations are not matching, we
have d 6= ˆd. If the reader does not identify the tag, we are
back to the previous case. Otherwise, we have d0 = ˆd thus
d 6= d0: the tag does not authenticate the reader.
Hence, we have a secure simple reader authentication. To
prove a secure simple tag authentication, we proceed simi-
larly.
The proof for narrow-destructive privacy from [14] also
works for the enriched protocol if we simulate d on the reader
side in the same way that we simulate c on the tag side:
following the lazy sampling technique.
6.3 Narrow-Strong+Forward Privacy
Finally, we enrich the protocol from [14] based on an IND-
CCA Public-Key Cryptosystem (PKC). A PKC includes a
key generator, an encryption algorithm, and a decryption
algorithm. Correctness ensures that the decryption of the
encryption of any x is always x. The scheme is IND-CCA-
secure if all polynomial-time adversaries win the IND-CCA
with negligible advantage. In the IND-CCA game, the ad-
versary receives a public key, does decryption queries, sub-
mits two plaintexts, receives the encryption of one of the
two, further do decryption queries except on the challenged
ciphertext, and tries to guess which plaintext was encrypted.
The reader setup algorithm ﬁrst generates a private/public
key pair (KS, KP ). The tag setup algorithm SetupTag(ID)
picks a k-bit key K and sets the initial state to
S = (KP , ID, K).
The parameter k and α must be polynomially bounded. The
protocol is depicted on Fig. 3.
1. The reader sends an identiﬁcation request with an α-
bit random a.
2. The tag picks a random β-bit b, stores it in tempo-
rary memory, and sends c = EncKP (ID||K||a||b) to the
reader.
3. The reader gets ID||K||a||d = DecKS (c) and checks
that a is correct and that (ID, K) is in database.1 If
not, d is sent to a random value. The reader then sends
d to the tag.
1As in [14] we can later use K = FKM (ID) with a PRF F
and a master secret KM as depicted on Fig. 3 to get rid
of the database. Thanks to the PRF property, this change
does not modify the privacy result.
Tag
state: KP , ID, K
pick b ∈ {0, 1}β
c = EncKP (ID||K||a||b)
check b = d
output: OK iﬀ check
System
(K = FKM (ID))
secret keys: KS, KM
a
←−−−−−−−−−−−−−−− pick a ∈ {0, 1}α
−−−−−−−−−−−−−−−→ parse DecKS (c) = ID||K||a0||d
c
check a = a0
check K = FKM (ID)
←−−−−−−−−−−−−−−− if fail, set d to random
d
output: ID or ⊥ if failed
Figure 3: A Narrow-Strong and Forward -Private RFID Scheme based on a PKC.
4. The tag checks that b = d.
8. REFERENCES
Theorem 4. If the public-key cryptosystem is IND-CPA-
secure then the above RFID scheme is narrow-strong private.
If the cryptosystem is IND-CCA-secure and 2−k is negligible,
the RFID scheme is further secure and forward private.
Namely, with an IND-CCA PKC, this RFID scheme achieves
privacy with respect to the class
FORWARD ∪ (NARROW ∩ STRONG).
Proof. Correctness of the protocol is trivial from the
correctness of the cryptosystem.
To prove security, we only have to prove simple security
and to apply Lemma 1.
We assume w.l.o.g. that the reader never picks the same
a twice. We consider a protocol transcript (a, c, d) on the
tag side with no matching conversation with the reader and
we stop the adversary before sending d to the tag. If (a, c)
has a matching conversation, then the reader released some ˆd
which must be diﬀerent from d so reader authentication fails.
Otherwise, sending c in any other reader protocol session
would not match the corresponding ˆa since it must diﬀer
from a, so the simulation of the reader for sending c is easy:
one just picks a random ˆd. So, we can simulate the reader by
using a decryption oracle that is never queried with c. If we
now simulate the tag by asking the encryption of ID||K||a
concatenated with a random b chosen by a challenger, we
obtain an IND-CCA adversary who guesses this b. Thanks
to IND-CCA security, it succeeds with negligible probability.
This proves simple reader authentication.
Simple tag authentication works as in the proof from [14].
The scheme is narrow-strong private, thus narrow-forward
private. Thanks to Lemma 3, we deduce that it is forward
private. So, we only have to prove narrow-strong privacy.
But the proof of [14] works the same in the enriched proto-
col.
7. CONCLUSION
We have shown how to formalize the notion of mutual
authentication in RFID schemes, as well as security and pri-
vacy. To address corruption, we must assume that tags have
temporary memory which erases itself when the tag does not
receive any power. We have identiﬁed protocols which fail
to provide privacy. We further enriched previously proposed
protocols to achieve mutual authentication. Finally, we let
open the problem of achieving weak and narrow-forward pri-
vacy based on no public-key cryptography.
[1] G. Avoine. Cryptography in Radio Frequency
Identiﬁcation and Fair Exchange Protocols. PhD
thesis, EPFL, Lausanne, Switzerland, December 2005.
http://library.epfl.ch/theses/?nr=3407.
[2] G. Avoine, E. Dysli, and P. Oechslin. Reducing time
complexity in RFID systems. In B. Preneel and
S. Tavares, editors, Selected Areas in Cryptography –
SAC 2005, volume 3897 of Lecture Notes in Computer
Science, pages 291–306, Kingston, Canada, August
2005. Springer-Verlag.
[3] M. Burmester, T. van Le, and B. de Medeiros.
Provably secure ubiquitous systems: Universally
composable RFID authentication protocols. In
Conference on Security and Privacy for Emerging
Areas in Communication Networks – SecureComm
2006, Baltimore, Maryland, USA, August-September
2006. IEEE.
[4] T. Dimitriou. A lightweight RFID protocol to protect
against traceability and cloning attacks. In Conference
on Security and Privacy for Emerging Areas in
Communication Networks – SecureComm 2005,
Athens, Greece, September 2005. IEEE.
[5] M. Feldhofer, S. Dominikus, and J. Wolkerstorfer.
Strong authentication for RFID systems using the
AES algorithm. In M. Joye and J.-J. Quisquater,
editors, Workshop on Cryptographic Hardware and
Embedded Systems – CHES 2004, volume 3156 of
Lecture Notes in Computer Science, pages 357–370,
Boston, Massachusetts, USA, August 2004. IACR,
Springer-Verlag.
[6] A. Juels and S. Weis. Deﬁning strong privacy for
RFID. Cryptology ePrint Archive, Report 2006/137,
2006.
[7] C. H. Lim and T. Kwon. Strong and robust RFID
authentication enabling perfect ownership transfer. In
P. Ning, S. Qing, and N. Li, editors, Conference on
Information and Communications Security – ICICS
2006, volume 4307 of Lecture Notes in Computer
Science, pages 1–20, Raleigh, North Carolina, USA,
December 2006. Springer-Verlag.
[8] D. Molnar and D. Wagner. Privacy and security in
library RFID: Issues, practices, and architectures. In
B. Pﬁtzmann and P. Liu, editors, Conference on
Computer and Communications Security – ACM CCS
2004, pages 210–219, Washington, DC, USA, October
2004. ACM, ACM Press.
[9] M. Ohkubo and K. Suzuki. RFID privacy issues and
technical challenges. Communications of the ACM,
48(9):66–71, 2005.
[10] M. Ohkubo, K. Suzuki, and S. Kinoshita.
Cryptographic approach to “privacy-friendly” tags. In
RFID Privacy Workshop 2003, MIT, MA, USA,
November 2003.
[11] M. Ohkubo, K. Suzuki, and S. Kinoshita. Eﬃcient
hash-chain based RFID privacy protection scheme. In
International Conference on Ubiquitous Computing –
Ubicomp 2004, Workshop Privacy: Current Status and
Future Directions, Nottingham, England, September
2004.
[12] G. Tsudik. A family of dunces: Trivial RFID
identiﬁcation and authentication protocols. In
N. Borisov and P. Golle, editors, Privacy Enhancing
Technologies – PET 2007, volume 4776 of Lecture
Notes in Computer Science, pages 45–61, Ottawa,
Canada, 2007. Springer-Verlag.
[13] T. van Le, M. Burmester, and B. de Medeiros.
Universally composable and forward secure RFID
authentication and authenticated key exchange. In
F. Bao and S. Miller, editors, ACM Symposium on
Information, Computer and Communications Security
– ASIACCS 2007, pages 242–252, Singapore, 2007.
ACM.
[14] S. Vaudenay. On privacy models for RFID. In
T. Okamoto, editor, Advances in Cryptology –
Asiacrypt 2007, volume 4833 of Lecture Notes in
Computer Science, pages 68–87, Kuching, Malaysia,
December 2007. Springer-Verlag.
[15] S. Weis, S. Sarma, R. Rivest, and D. Engels. Security
and privacy aspects of low-cost radio frequency
identiﬁcation systems. In D. Hutter, G. M¨uller,
W. Stephan, and M. Ullmann, editors, International
Conference on Security in Pervasive Computing –
SPC 2003, volume 2802 of Lecture Notes in Computer
Science, pages 454–469, Boppard, Germany, March
2003. Springer-Verlag.