they are generated in this manner, and we might want to
reduce the number of features provided there is no informa-
tion loss. Sometimes (as in the conjunction ﬁngerprints in
Section 4.2.1), we do not need to generate all these position-
substrings explicitly — our algorithm uses an equivalent set
in a more efﬁcient manner. We describe this implicit feature
space in Section 4.2.1.
We can also use domain information to reduce the fea-
ture set. We do this in this paper: we use the semantics
of the packet header to break the response string by proto-
col ﬁelds; so, each ﬁeld is treated as a separate position-
   ac
ax
{[1, 1, a], [2, 2, c], [1, 2, ac]}
{[1, 1, a], [2, 2, x], [1, 2, ax]}
{[1, 1, a], [2, 2, c], [2, 2, x],
  [1, 2, ac], [1, 2, ax]}
response strings
position−substring sets P
1 and P
2
ordered union of P
1  and P
2
v 1 [1, 1, 0, 1, 0]
v 2
 [1, 0, 1, 0, 1]
example vectors
Figure 2. Feature generation.
substring. This procedure generates many fewer features
than the original feature space, and further, using the packet
header semantics to generate features results in ﬁngerprints
that are much easier to understand. For this reason, in the
analysis of the ﬁngerprints that we present in Section 5, we
focus only on this reduced feature set.
Further, not all of the protocol ﬁelds contain only
implementation-speciﬁc information. For example, we term
dynamic ﬁelds to be protocol ﬁelds that might change from
one instance to another, such as session-speciﬁc ﬁelds (e.g.
session id, time-to-live); host-speciﬁc ﬁelds (e.g. hostname,
IP address, port); or conﬁguration-speciﬁc ﬁelds (e.g. DNS
answer). The values of these dynamic ﬁelds are based on
external information and are less likely to contain informa-
tion that helps to identify the implementation.
The training data should include instances of different
values for these dynamic ﬁelds; if it does not, they might
show up in the ﬁnal ﬁngerprint. For example, if we use the
same open TCP port for ﬁngerprinting all Windows hosts
(e.g. 139) and a different one for all Linux hosts (e.g. 22),
then the conjunction ﬁngerprint will include this ﬁeld. In
this paper, we remove the dynamic ﬁelds when generating
the ﬁngerprints, but keep them for approximate matching,
where we examine the effect of including these dynamic
ﬁelds.
4.2. Algorithms
Overview For each query, once we have transformed the re-
sponse from each training host into an instance, we need to
ﬁnd a classiﬁcation function that separates the implemen-
tation classes. We do this on the instances obtained using
the training hosts, and test the resulting classiﬁcation func-
tion on instances obtained from the testing hosts. Since we
cannot look through all possible classiﬁcation functions, we
search within families of classiﬁcation functions for a good
classiﬁcation function. The goal of the learning algorithm is
to ﬁnd a good function within a given family that separates
the different implementation classes.
We need classiﬁcation functions that are easy to in-
terpret, for understanding which queries are useful and
when they are useful. Therefore, we choose classiﬁca-
tion functions that are boolean functions of the features,
such as conjunctions, decision lists, decision trees, etc.
We choose these over classiﬁcation functions that are real-
valued weighted functions of their features (such as linear
separators, etc), because the ﬁngerprints generated by such
classiﬁcation functions cannot be interpreted directly, and
would need to be converted into a sequence of decision rules
in order to be interpreted meaningfully.
In this paper, we consider two families of classiﬁcation
functions: conjunctions and decision lists [17]. We do not
use decision trees, since (a) a restricted decision list has
lower sample complexity than a similarly restricted deci-
sion tree, and (b) a sufﬁciently complex decision list can
represent any decision tree. We discuss these two classes
of ﬁngerprints in more detail below. In Appendix A, we
present the mistake-bound model for the analysis of these
ﬁngerprints, and show improved bounds for the conjunction
ﬁngerprints.
Our approach to learn ﬁngerprints is the following: ﬁrst,
we learn a binary-ﬁngerprint for each implementation class,
which is a ﬁngerprint that can determine whether or not the
host belongs to that implementation class. Then we com-
bine many binary-ﬁngerprints to obtain the ﬁnal ﬁngerprint
that can classify hosts into one of multiple implementation
classes.
In the rest of this section, we focus on learning ﬁnger-
prints for a single query only. In the interest of readability,
we will use the terms ﬁngerprint and binary-ﬁngerprint to
refer to the classiﬁcation function associated with a single
query. We will distinguish explicitly the ﬁngerprint for a
single query from the overall ﬁnal ﬁngerprint when it is not
clear from the context.
4.2.1 Learning Conjunction Binary-Fingerprints
Given a query, there may be protocol ﬁelds in the response
from a host that exhibit values speciﬁc to the implemen-
tation, and thus are different across implementations. We
want to include all of them in the ﬁngerprint. For this rea-
son, we evaluate conjunctions of position-substrings as one
class of classiﬁcation functions.
A conjunction ﬁngerprint Cq,I for a set of implemen-
tation classes I = {Im}1≤m≤k is a query q and a set of
position-substrings {S(q,Im)}1≤m≤k such that for each im-
plementation class Im ∈ I, (a) all the position-substrings
in S(q,Im) are always present in the response from ev-
ery training host in the implementation class Im, but (b)
not all of the position-substrings in S(q,Im) are present in
any response from any host in another class Iz6=m for this
query q, i.e., they are distinctive with respect to the re-
sponses from an implementation class. Thus, the conjunc-
tion ﬁngerprint for a query q can be represented as Cq,I =
{S(q,I1), S(q,I2), . . . S(q,Ik)}, when I = {I1, I2 . . . Ik}.
Using conjunction ﬁngerprints A conjunction binary-
ﬁngerprint for class Im decides only whether a host be-
longs to class Im or not. To use a conjunction binary-
ﬁngerprint to classify whether a new host is in Im, we test
if all the position-substrings in Sq,Im in the conjunction
binary-ﬁngerprint are present in the response of that host
for the query q. If they are, the host belongs to the class
Im, otherwise it does not. We describe how to use the ﬁnal
conjunction ﬁngerprint in Section 4.3.
Learning conjunction ﬁngerprints Note that we describe
how to learn conjunction binary-ﬁngerprints here; in Sec-
tion 4.3, we show how to turn binary-ﬁngerprints into ﬁ-
nal ﬁngerprints. For this, we use the standard algorithm
to learn conjunctions from a set of labeled instances [17],
with the following modiﬁcation for efﬁciency. Instead of
explicitly converting each host’s response into an instance
as described in Section 4.1, our algorithm ﬁrst extracts the
longest common position-substring for each starting posi-
tion in each implementation class, while ensuring that there
is no overlap between the position-substrings. It then re-
moves common elements of these position-substrings that
are present in every implementation class. This way, the
algorithm is linear in the length of the response strings.
We illustrate the operation of the algorithm with an ex-
ample. Figure 3 shows response strings for four hosts in I1.
The position-substrings that we extract are [3, 8, cdef gh]
and [11, 12, kl]. Figure 4 shows the same process for four
hosts in a second class I2. The position-substrings that we
extract are [3, 8, stuf gw] and [11, 12, kl]. Then, in ﬁg-
ure 5 the algorithm removes [11,12,kl] and [6,7,f g] since
they are not useful for distinguishing between I1 and I2.
Thus, we are left with the position-substrings [3,5,cde] and
[8,8,h] for class I1, and [3,5,stu] and [8,8,w] for class I2.
While the conjunction ﬁngerprints are simple and easy to
interpret, they have limited expressivity, and in some cases,
they may not be sufﬁcient. There might, for instance, be
two kinds of responses generated for a particular query from
hosts within an implementation class, e.g., Windows hosts
may always have one of two values for the TCP window,
neither of which is present in any other implementation, and
therefore, we could use the presence of either of these val-
ues in a Windows ﬁngerprint. For such a query, if there are
no other bytes that uniquely distinguish the implementation
classes, we may not be able to ﬁnd a conjunction ﬁngerprint.
This type of behavior might occur because there may be
slight differences in the same implementation class. For ex-
ample, when collecting learning data one might think that
Windows XP SP2 hosts will behave identically but the net-
work behavior is affected by the patch level and language
version among others. Thus, in order to capture multiple be-
haviors in an implementation class, we need to use a more
general class of functions. In the next section, we will de-
scribe such a class, decision lists.
4.2.2 Learning Decision List Binary-Fingerprints
A decision list can be viewed as an ordered sequence of
multiple if-then-else statements, where a conjunction can be
viewed as a single if-then-else statement. We will use de-
cision lists to capture the presence of multiple behaviors in
a single implementation class, that are not present in other
implementation classes.
[17]
The standard deﬁnition of a decision list
is
as follows:
a decision list over n boolean variables
Y = {Y1, Y2, . . . , Yn} and k classes is a sequence L:
(c1, I1), (c2, I2), . . . , (ct, Ik), where ci is a conjunction on
Y and Ii denotes the class. We will refer to each pair (ci, Ii)
as a decision rule. A decision list is thus an ordered se-
quence of decision rules – the condition ci of each decision
rule is tested in the order of its appearance in L and the out-
put is the classiﬁcation Ii corresponding to the ﬁrst satisﬁed
decision rule. When none of the conditions are satisﬁed, the
decision list outputs unknown.
In our setting, for each query, we use boolean variables to
denote the presence of position-substrings in the response,
and each condition ci is equivalent to the presence of a list
of position-substrings in that response. Thus, a decision
list ﬁngerprint is a query and an ordered sequence of rules,
where each rule consists of a list of position-substrings and
an associated implementation class. To use the decision list
ﬁngerprint to classify a new host, we send the query to the
host and collect the response. We then test the response with
each rule in turn to see if all the position-substrings in that
rule are present in the response, and if they are, we output
the associated class.
As in the case of the conjunctions, we ﬁnd a decision list
ﬁngerprint for each query separately. We use the standard
algorithm to learn a decision list for a given set of responses
from different training hosts to a single query [17]. As with
the conjunctions, this decision list is a binary-ﬁngerprint; in
Section 4.3, we describe how to convert them into the ﬁnal
ﬁngerprint.
Note that decision lists are a more general class of func-
a
x
x
x
b
y
y
y
c
c
c
c
d
d
d
d
e
e
e
e
f
g
h
h
h
i
f
f
f
g
g
g
i
1
j
2
j
k
k
k
h
1
2
k
l
l
l
l
w a
s
t
x
b
x
x
c
d
s
s
s
t
t
t
u
u
u
u
f
g w 1
f
f
f
g
w
g
w
2
1
g
w
2
4
5
6
7
k
k
k
k
l
l
l
l
c
s
d
t
e
u
f
f
g
g
h
w
k
k
l
l
Figure 3. Responses from
class I1.
Figure 4. Responses from
class I2.
Figure 5. Removing com-
mon position-substrings.
tions than conjunctions, and thus, every time we have a con-
junction ﬁngerprint for a query we will also have a decision
list ﬁngerprint but the reverse is not always true. However,
since there is a larger space of candidate functions to be
explored, the algorithms for learning decision lists have a
higher space and time complexity than the algorithms that
learn conjunctions.
4.3. Obtaining the Final Fingerprint
Here we present the steps needed to obtain the ﬁnal ﬁn-
gerprint from the output of the learning algorithm.
Removing unusable queries As we explore the query
space, we may ﬁnd that some queries do not induce dis-
tinguishing behavior among the different implementation
classes, and therefore are not useful for ﬁngerprinting. For
conjunctions, this happens when a query fails to produce
different responses across different implementations and
thus an empty conjunction binary-ﬁngerprint is generated.
For decision lists, it happens when the binary-ﬁngerprint
generated for one query does not cover the complete set of
instances in a class, usually because there is not enough dis-
tinct behavior that separates all hosts in the class from hosts
in the other class. Our approach is to remove these queries
and their corresponding binary classiﬁcation functions from
the binary-ﬁngerprints during the Learning phase, leaving
only the usable queries.
Final ﬁngerprints for classifying multiple implementa-
tion classes The conjunction and decision list algorithms
as presented are designed for binary classiﬁcation of the
responses to a single query. However, we can use these
binary classiﬁcation algorithms for multi-class classiﬁca-
tion by repeating the following procedure for each imple-
mentation class Im. First, separate all hosts that belong
to Im as a single group, and all hosts that belong to any
other implementation class as a second group, Wm =
I \ {Im}. Then, generate the binary-ﬁngerprint BFm for
groups {Im, Wm}1≤m≤k, which will distinguish the imple-
mentation class Im from all other classes. Once this proce-
dure has been completed for all implementation classes, the
ﬁnal ﬁngerprint is the set of all the binary-ﬁngerprints.
For some queries, the ﬁnal ﬁngerprint may not contain
a binary-ﬁngerprint for every implementation class. If we
have enough queries with complete ﬁnal ﬁngerprints, we
can discard these ﬁngerprints; otherwise, we need to com-
bine multiple queries with partially-complete ﬁngerprints as
described below.
To classify a new host using a ﬁnal ﬁngerprint, we apply
each binary-ﬁngerprint BFm in turn to the responses from
the host, and store whether the host belongs in Wm or Im,
for each m ∈ [1, k]. Then, if there is only one m in which
the host belongs to Im, we output that class Im as the re-
sult, otherwise, we report that the class is unknown. We
describe an approximate matching we can use in this case
in Section 4.4.
Combining multiple queries The conjunction and decision
list ﬁngerprints generated in Sections 4.2.1 and 4.2.2 only
consider the responses for a single query. Once we have
removed the unusable queries, if the number of implemen-
tation classes is large, we may not be able to ﬁnd a single
query that can classify all implementation classes simulta-
neously.
In that case, we create ﬁngerprints for multiple
queries together, where each query is able to identify some
subset of the implementation classes, so that the combina-
tion can classify all the implementation classes. We can