30  08  
READ Response
TAG  
74  72  61  6c  69  67  68  74  3f  fe  00  00  e4  f2  e3  01  
READ - 03
30  03  
READ Response
TAG  
e1  10  06  00  03  17  d1  01  13  54  02  65  6e  73  75  70  
READ - 04
30  04  
READ Response
TAG  
03  17  d1  01  13  54  02  65  6e  73  75  70  2c  20  75  6c  
READ - 05
30  05  
READ - Response
TAG  
13  54  02  65  6e  73  75  70  2c  20  75  6c  74  72  61  6c  
READ - 06
30  06  
READ - Response
TAG  
6e  73  75  70  2c  20  75  6c  74  72  61  6c  69  67  68  74  
READ - 04
30  04  
READ - Response
TAG  
03  17  d1  01  13  54  02  65  6e  73  75  70  2c  20  75  6c  
READ - 05
30  05  
READ - Response
TAG  
13  54  02  65  6e  73  75  70  2c  20  75  6c  74  72  61  6c  
READ - 06
30  06  
READ - Response
TAG  
6e  73  75  70  2c  20  75  6c  74  72  61  6c  69  67  68  74  
READ - 07
30  07  
READ - Response
TAG  
2c  20  75  6c  74  72  61  6c  69  67  68  74  3f  fe  00  00  
READ - 08
Charlie Miller: Exploring the NFC Attack Surface 
30  08  
READ - Response
TAG  
74  72  61  6c  69  67  68  74  3f  fe  00  00  e4  f2  e3  01  
READ - 09
30  09  
READ - Response
TAG  
69  67  68  74  3f  fe  00  00  e4  f2  e3  01  e4  f2  e3  01  
READ - 0a
30  0a  
READ - Response
TAG  
3f  fe  00  00  e4  f2  e3  01  e4  f2  e3  01  30  00  00  00  
READ - 0b
30  0b  
READ - Response
TAG  
e4  f2  e3  01  e4  f2  e3  01  30  00  00  00  45  34  20  46  
READ - 0c
30  0c  
READ - Respnose
TAG  
e4  f2  e3  01  30  00  00  00  45  34  20  46  32  20  45  33  
READ - 0d
30  0d  
READ - Response
TAG  
30  00  00  00  45  34  20  46  32  20  45  33  04  e3  ef  80  
READ - 0e
30  0e  
READ - Response
TAG  
45  34  20  46  32  20  45  33  04  e3  ef  80  a2  ef  20  80  
READ - 0f
30  0f  
READ - Response
TAG  
32  20  45  33  04  e3  ef  80  a2  ef  20  80  ed  48  00  00  
SLP_REQ
50  00  
Pulling out the NDEF data read we ﬁnd:
03  17  d1  01  13  54  02  65  6e  73  75  70  2c  20  75  6c  74  72  61  6c  69  67  
68  74  3f  fe  00  00  e4  f2  e3  01  30  00  00  00  45  34  20  46  32  20  45  33  
04  e3  ef  80  a2  ef  20  80  ed  48  00  00 
Examining this NDEF data we can see the contents:
Charlie Miller: Exploring the NFC Attack Surface 
03 NDEF Message
17 length
Record 1
d1 - MB, ME, SR, TNF=”NFC Forum well-known type”
01 Type length
13 Payload length
54 Type - “T” 
02 - Status byte - Length of IANA lang code 
65 6e - language code = “en” 
73  75  70  2c  20  75  6c  74  72  61  6c  69  67  68  74  
3f = “sup, ultralight?” - text
Record 2
fe Terminator NDEF
Fuzzing the NFC stack
When considering the attack surface that the introduction of NFC to a device adds, the 
most obvious place to start is the NFC software stack itself,  the code responsible for 
parsing the NFC protocols mentioned in the last section.  Typically, this code will consist 
of a driver for the NFC chip, a library used to communicate with the driver, and then the 
OS code to deal with incoming NFC payloads including dealing with different types of 
NDEF messages that might arrive.  In Android, we see something like Figure 5, below. 
Figure 5: NFC handling code in Android.
Charlie Miller: Exploring the NFC Attack Surface 
In MeeGo it is similar, as in Figure 6, below.
Figure 6: NFC handling code in MeeGo
In such a complex stack, there certainly could be bugs lurking in any of this code that 
could allow remote compromise of NFC enabled devices.  Please note that in Android, 
some of the components are Java apps and so memory corruption is not a possibility, 
but this will vary from platform to platform.  There will always be some native code 
involved at the lowest levels, though.
There are various approaches to trying to ﬁnd vulnerabilities in the NFC stack.  A driver 
that is proprietary could still be reverse engineered and analyzed.  The library for the 
chip on Android, libnfc.so, is open source, and so could be audited.  However, one very 
effective way to get started is to set up a fuzzing environment and fuzz the NFC protocol 
stack.
Depending on exactly how this is to be carried out, different levels of the protocol stack 
can be attacked.  We considered various approaches such as doing it at the RF level 
(see [2-3]) or library injection (as was done for SMS in [16]).  After many trials and 
errors, we settled on using card emulation with a collection of off-the-shelf NFC 
hardware.  
Charlie Miller: Exploring the NFC Attack Surface 
For the tag types which had working card emulation functionality, we could fuzz the 
protocol level and application level.  We could potentially fuzz the Initialization, Anti-
Collision, and Protocol Activation layer but there isn’t much data there so it was 
determined not to be a good use of time.  We could not fuzz the RF layer without a fully 
working software deﬁned radio (SDR) NFC stack.  Figure 7, below, shows which 
protocols could be tested with this approach.
Figure 7: Fuzzing using this setup can fuzz any of the areas indicated above
Fuzzing setup
If you want to simulate various NFC tags, you need to do what is called card emulation.  
This is where an NFC device acts like a passive tag.  We were able to ﬁnd a couple of 
pieces of hardware that could perform card emulation in some circumstances.  Namely, 
an SCL 3711 Contactless Mobile Reader could be used with libnfc to do card emulation 
of a Type 2 Mifare UltraLight tag.  An ACS ACR122U can do card emulation using libnfc 
of a Type 4 Mifare DESFire.  Additionally, an SCL3711 can do LLCP transactions using 
nfcpy.  Unfortunately, there is no support for other types of tags using libnfc or nfcpy.  It 
would be interesting to add other tag types into libnfc for testing.
Charlie Miller: Exploring the NFC Attack Surface 
Sometimes the hardware devices would hang and need to be restarted.  This cannot be 
accomplished in software and has to be done in hardware.  In order to simulate 
unplugging and replugging the USB card reader into the computer, we use a USB hub 
that implements port power control.  In particular, we used a DLink DUB-H7 7-Port USB 
Hub.  Therefore, the hardware set-up looks something like that in Figure 8, below.
Figure 8: Fuzzing hardware setup
The ﬁnal step in fuzzing is to simulate someone placing the device onto the emulated 
tag.  In some cases, you cannot just emulate the tag with a device already in the RF 
ﬁeld of an NFC initiator.  In order to simulate a device entering the ﬁeld, a couple of 
options are available.  The ﬁrst is to kill the NFC process and restart it when the tag is 
being emulated.  A slightly nicer way is to issue the SIGSTOP and SIGCONT signals, 
respectively, to simulate removing/placing the Nexus S NFC reader.  A ﬁnal way was to 
enable and disable the NFC service,in the same way the Settings application does it in 
Android.  
Fuzzing test cases
In general, there are two ways to generate fuzzing test cases, generation based and 
mutation based.  For generation based, we create test cases from “scratch”, using the 
speciﬁcation as a guide.  For mutation based fuzzing, we take existing valid data and 
inject faults into it.  One of the interesting things about fuzzing is that it turns out using 
Charlie Miller: Exploring the NFC Attack Surface 
multiple fuzzers is often superior to using a single fuzzer.  Therefore, we use an 
approach to try to use both mutation and generation based fuzzers as well as 
incorporate a couple of different types of mutations to add to the valid data.  
Protocol layer fuzzing
On the protocol level, we used only a mutation-based approach since the ﬁelds being 
fuzzed were so simple.  We are constrained by the hardware and software which can do 
device emulation.  We only have the ability to emulate Type 2 and Type 4 tags as well 
as perform basic LLCP connections.  For these three types, we can fuzz at a low level, 
just after the anti-collision.  For other types of cards or transactions, we cannot fuzz at a 
low level.  In particular we cannot fuzz Type 1 (Topaz) or Type 3 (FeliCa) protocols at 
this time.  
For this low level fuzzing for tags, we used the nfc-emulate-forum-tag2 and nfc-emulate-
forum-tag4 programs which come with libnfc, modiﬁed to present different data before a 
valid NDEF was presented.  For fuzzing low level Type 2 tags, we fuzz the non-NDEF 
bytes in the MiFare Ultralight’s memory.  Namely, this includes the ﬁrst 16 bytes of the 
static memory structure (see section 2.1 in [7]). 
For type 4 tags, we fuzz the Capability Container ﬁle, see section 5.1 of [9].
For LLCP, we use modiﬁed versions of the nfcpy software suite.  In particular, we fuzz 
the CONNECT packet and the I (Information) packet (see 4.3.10 in [10]) of the 
connection.  For Android we used the nfcpy script npp-test-client and for for the Nokia 
N9, we used the snep-test-client.  NPP is the NDEF Push Protocol which is used by 
Android [17].  SNEP is the Simple NDEF Exchange Protocol used by Nokia and other 
devices [18].
Application layer fuzzing
Application layer fuzzing involves creating fuzzed NDEF messages and getting them to 
the device using one of the available low level protocols.  As in the low level protocols, 
we start with a mutation-based approach.  We took many different types of NDEF 
messages and added mutations to them.  
Additionally, we utilized a generation-based approach to create more specialized NDEF 
fuzzing test cases.  
For this, we utilize the Sulley Fuzzing Framework.  We created 11 different test case 
generation scripts (ndef_*.py) based on a modiﬁed version of Sulley.  Each will generate 
many thousands of NDEF test cases to STDOUT.  For example, 
$ ./ndef_short_uri.py | grep -v "^\[" 
D1010B550036333633393934373931
D1010B550136333633393934373931
D1010B550236333633393934373931
D1010B550336333633393934373931
Charlie Miller: Exploring the NFC Attack Surface 
D1010B550436333633393934373931
D1010B550536333633393934373931
D1010B550636333633393934373931
D1010B550736333633393934373931
D1010B550836333633393934373931
D1010B550936333633393934373931
...
In the above output, the ﬁfth byte is being mutated.  
$ ./ndef_short_uri.py | grep "total cases"
[10:08.08] fuzzed 0 of 1419 total cases
Sulley is designed to do everything from test case generation to sending and monitoring 
during fuzzing.  Since we tend to fuzz esoteric devices, it is not well suited for this, and 
so my modiﬁcations to Sulley are mostly to allow it to print out test cases in a way which 
are easily read by another program which will be responsible for sending the test cases 
and monitoring the test device.
Results - Nexus S
We fuzzed the NFC stack on a Nexus S phone running Android 2.3.3 with the above 
approaches.  This was the most current version when we started fuzzing and I believe is 
the most up to date version for an AT&T Nexus S using default methods of upgrade.
Protocol Layer
A total of 12,000 test cases were developed and tested against the low level NFC 
protocols, see below for details.
Device
Type
Test 
cases
Results/notes
Nexus S
Type 2 (UL)
4000
18 bytes of MiFare UL memory
MiFare 1k/4k
Cannot emulate at this time
Type 4 (DESFire)
4000
15 bytes of Capacity Container
ISO 14443 A-4 (PDU)
Nothing interesting to fuzz