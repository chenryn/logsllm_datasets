the protocol parse tree. A much simpler approach to search along
the trafﬁc for the wanted basic ﬁeld is sufﬁcient in dominant cases.
When a compound ﬁeld is needed in signature matching, it can be
constructed from the basic ones. However, it happens very infre-
quently and does not affect the overall performance signiﬁcantly.
For overhead (c), the extraction of all compound ﬁelds can be elim-
inated due to the same reason.
Unfortunately, these overheads are by design inherent to BinPAC
parser, and thus cannot be removed by implementation optimiza-
tion. Since there is no restriction on what the parsed ﬁelds are used
for, BinPAC parser must handle the worst case where the whole
protocol parse tree is required by other components in the system.
As a result, it must preserve a copy of the parsed ﬁelds, traverse the
protocol parse tree and parse all nodes.
5.3 Proposed Parsing State Machine
We devise the parsing state machine (called PSM later on) to
achieve stream parsing and to eliminate the identiﬁed unnecessary
overhead to the maximum extent. Please see § 7.2.1 for the experi-
mental results.
We have studied eight popular protocols: HTTP, FTP, SMTP,
eMule, BitTorrent, WINRPC, SNMP and DNS. We ﬁnd three com-
mon relationships among ﬁelds: sequential, branch and loop.
Sequential ﬁelds appear in the PDU one after another in a ﬁxed
order. For ﬁelds with branch relationship, one and only one will
appear. A condition called branch variable controls the branch. A
loop ﬁeld will appear repeatedly in the PDU until a termination
condition is satisﬁed. In addition, Type-II ﬁelds might derive pars-
ing variables which control the parsing process.
Based on these ﬁndings, we propose the PSM. A state is the basic
ﬁeld that is being parsed. The state transition marks the end of
parsing the previous ﬁeld and the start of parsing the next one in the
PDU. Before quitting a state, it will derive the parsing variables, if
any. We show the four basic building blocks of protocol parsing
state machine in Figure 5. A PSM is a combination of these basic
building blocks.
An Example. In Figure 6 we illustrate a simpliﬁed PSM for WIN-
RPC protocol. We merge the ﬁelds which are not related to Type-I
and Type-II ﬁelds as mergei ﬁelds to save space.
The parser continuously fetches the length of current ﬁeld and
moves the offset pointer in the input data segment accordingly. For
example, to parse the WINRPC header, the offset pointer increases
by 1, 1, 1, 1, 4, 2, 6 in each parsing step, respectively. Since the
ptype and frag_length are needed as parsing variables, they
are loaded into variables (Ri).
If ptype == BIND_ACK, we
can directly jump over the remaining payload (ﬁeld merge3) in the
285R1-16
merge3
Bind-ACK
Bind-ACK
8 merge2
1
rpc_vers
1 rpc_ver_minor
R0
1
ptype
Header
1
pfc_flags
R1
4
2
6
packed_drep
frag_length
merge1
R0
Bind
R2 ‹- 0
R3 ‹- ncontext
Bind
R2++
R2 R3
1
3
2
ncontext
padding
ID
R4
1 n_tran_syn
1
16
padding
UUID
4 UUID_ver
20*R4
tran_syn
Figure 6: A simpliﬁed parsing state machine for the WINRPC
protocol (not considering RPC reassembly).
PDU by frag_length − 16 bytes. If ptype == BIND, we go
through the parsing states in the lower right part of the graph.
5.4 Automatic Parsing State Machine Gener-
ation
Protocol 
Description
Abstract
Syntax
Tree
Parsing 
State 
Machine
Generated 
Code
Field_1:
 length = 5;
 goto field_5;
field_2:
 length = 10;
 goto field_6;
...
Binpac 
Frontend
Converting
Engine
Code 
Generator
Figure 7: Workﬂow of UltraPAC.
We leverage on the frontend of BinPAC and reuse the BinPAC
language. After that, our customized converting engine produces
the parsing state machine (PSM) for the input protocol. Figure 7
shows the workﬂow of UltraPAC. The code generation step is
straight forward, so we omit detailed description due to space lim-
itation.
5.4.1 Acquiring Abstract Syntax Tree
The ﬁrst component reads a program-like description of the pro-
tocol format, and constructs the abstract syntax tree (AST) out of it.
An AST is a tree-like representation of abstracted protocol format.
Note that it is different from a protocol parse tree. An AST gives
out all the ways that a legal PDU can possibly be built. It can be
determined by the protocol format description. On the contrary, a
protocol parse tree states how a given PDU is assembled from ba-
sic ﬁelds. It can only be determined during the runtime of a parsing
process.
We reuse BinPAC to acquire the AST. BinPAC constructs the
AST of a protocol in memory before it generates C++ code of the
parser. We keep the AST for further processing and discard the
code generation part. Accordingly, we keep the BinPAC language
for the protocol description.
5.4.2 Converting into PSM
A converting engine further converts the AST into the PSM. This
process is illustrated in Algorithm 4.
In Algorithm 4, root is the root node of the AST, which repre-
sents the whole PDU. S is the internal node space maintained by
UltraPAC. It contains all nodes that are to be processed. Record,
Case and Array are the three possible types of a parent node.
They indicate sequential, branch and loop relationship among its
children, respectively. The loop relation is handled as a special case
of branch relation, where the next protocol ﬁeld is either the current
ﬁeld itself or the subsequent ﬁeld of the parent. At the end of each
iteration, we add the logic of how to derive the parsing variables
into the PSM, so that the actual value of the parsing variables can
be determined during runtime using the logic. The iteration stops
when the node space contains only leaf nodes in the AST.
Algorithm 4 ParsingStateMachineGeneration()
S ← {root}
While ∃n, n ∈ S and n is inner node
children ← the set of n’s children
S ← S − n
S ← S ∪ children
If n is of RECORD type
assign sequential ordering among children
Elseif n is of CASE type
assign branch ordering among children
branch variable controls the branch
assign branch ordering between children and next
array terminating condition controls the branch
Endif
add logic to derive parsing variable from n
Else
Endwhile
UltraPAC can essentially handle arbitrarily complex protocol
format, since it supports sequential, branch and loop relation
among ﬁelds. One caveat is that attribute constraints, e.g., ﬁeld
length, may be applied to compound ﬁelds, whereas the PSM pro-
duced by UltraPAC works directly on basic ﬁelds. We tackle this
problem by breaking and distributing such attributes to the proper
children basic ﬁelds. It’s feasible because the set of children ﬁelds
is determined in the AST. In addition, we have studied the BinPAC
language and found that all the supported attributes can be properly
distributed, while preserving the original functionality.
5.5 Further Improvement
Multiple layer parsing. One application protocol may tunnel
through another and use the latter one as a transport layer. One
PDU body can be in multiple messages. Therefore it needs appli-
cation layer reassembly. For example, by treating WINRPC as two
sub-protocols and using two layers of PSM, we can solve the re-
assembly problem. Once the ﬁrst layer parses the header, we call
the second layer to parse the partial body and save the parsing states
as well as the offset pointer. Then, after the next message arrives,
we can continue parsing the remaining part of the PDU.
Combine the unnecessary ﬁelds. A data ﬂow analysis can be
adopted to combine the consecutive ﬁelds that are neither Type-I
nor Type-II ﬁelds into one ﬁeld whenever possible. This combi-
nation further simpliﬁes the parsing process without affecting the
signature matching.
IMPLEMENTATION
6.
6.1 Core Engine Implementation
Parsing: We implement UltraPAC partially based on BinPAC. As
shown in Figure 7, we reuse the BinPAC language and code to con-
struct the abstract syntax tree. Accordingly, we use the protocol
speciﬁcation distributed with BinPAC with minor revision. We im-
plement the converting engine and code generator with about 3,000
lines of C/C++ code.
Matching: We implement the three types of matchers and the CS
algorithm with about 6,800 lines of C/C++ code. We implement a
path-compressed trie for exact string matching and leverage binary
search for integer range checking. In addition, we use Ragel for
regex compilation and write our own code for regex matching.
6.2 Signature Rule Language
We design a language to describe the symbolic predicate signa-
tures. We want to make it simple, intuitive and sufﬁcient. To this
end, we have studied the vulnerabilities that the Snort and Cisco
rulesets target, as well as those studied in [9, 10, 12, 13, 29], and de-
velop the language features which meet the real-world needs. Here,
we brieﬂy introduce the core features.
286Identify 
vulnerability 
set
Snort 
rulesets
Get the 
vulnerability 
specifications 
and exploits
vulnerability signature creation
Write 
signatures
Cross 
check
Experimental 
verification
Figure 8: Manual vulnerability signature creation.
We support three types of Boolean operators: &&, ||, and !and
two basic data types: string and number. For the number type, we
support the following relationship operations: ==,>,=,300 means that if the
string length of the value corresponding to the key “host” in the
HTTP_Headers associative array is larger than 300, the condition
is true.
6.3 Vulnerability Signature Creation
It would be more objective to evaluate our approach with stan-
dardized vulnerability signature rulesets. Unfortunately, given no
available existing vulnerability rulesets or open-source vulnerabil-
ity signature generator, we have to manually create the vulnera-
bility rulesets on our own. To ﬁgure out which vulnerabilities we
should include in the ruleset, we target the vulnerabilities Snort
tries to detect. We focus on HTTP and WINRPC, because they cor-
respond to the two largest rule subsets of Snort ruleset. 794 HTTP
and 45 WINRPC vulnerability signatures3 are manually created
based on vulnerability information of 973 HTTP and 3,519 WIN-
RPC Snort rules (11/2007 version), following the workﬂow shown
in Figure 8. We ﬁrst identiﬁed the vulnerability CVE IDs of Snort
rules. Each CVE ID corresponds to a vulnerability, so we wrote
one rule for it. Next, we collected the vulnerability speciﬁcations
and exploit samples from various online vulnerability database and
hacker forums. We then wrote the signatures. After that, we cross
checked the signatures written by different people in our group and
found 94.8% agreements. For the remaining 5.2% debatable ones,
we set up a vulnerable host, modiﬁed the exploits with the similar
idea in [13], and further reﬁned the signatures.
6.4 Software Prototype and Deployment
We build a software NIDS prototype to demonstrate NetShield.
It currently runs on Windows. We have deployed the prototype at a
campus data center of Tsinghua University. We feed the live trafﬁc
from a Cisco router that manages the university-wide web servers
and computer labs. The average and peak trafﬁc rate are about
20Mbps and 106Mbps, respectively. We have continuously run our
prototype online without any identiﬁed packet loss.
7. EVALUATION
To evaluate the performance of NetShield prototype, we mea-
sure the throughput on different traces across different protocols,
networks and time. The results show that in all the traces Net-
Shield can achieve high throughput. For 794 HTTP vulnerability
signatures we can achieve 11+Gbps core engine throughput on an
eight-core machine. The UltraPAC generated parsers are about 3
∼ 12 times faster than those of BinPAC. The candidate selection
based matching is 8.8 to 11.7 times faster than sequential matching
for 794 signatures.
3sample signatures are available at www.nshield.org.
7.1 Evaluation Environment and Datasets
We evaluate the NetShield prototype using two platforms: a Pen-
tium IV 3.8GHz single core PC (P4) with 4GB memory, and an
eight-core Xeon E5520 2.2Ghz (XE) with 16GB memory. The
latter is mainly for evaluating the performance of NetShield on
multi-core platforms. Because for vulnerability signature match-
ing connections are independent from each other, we dispatch the
connections in trafﬁc roughly evenly to the different NetShield core
engines running on different CPU cores. The experiment results
show multi-core platforms can indeed boost the performance. The
overall throughput when using the eight cores is nearly 5.5 ∼ 7.1
times of the single core throughput.
Network traces: We captured traces from the aforementioned
router at Tsinghua university (TH) and the EECS departmental
gateway of Northwestern University (NU). The MIT DARPA 1998
Intrusion Detection Data Sets [1] is also used. Table 3 shows some
statistics of the traces. The NU HTTP trace exhibits much longer
average ﬂow length than the other two HTTP traces. We ﬁnd it has
less attack trafﬁc and HTTP signalling or error replies (status code
other than 200), which have usually short ﬂow length.
TH
NU