灵。
管理缺陷的第一步是定义缺陷
知己知彼，百战不殆。
—孙子《孙子兵法》，公元前6年
一个美丽的缺陷跟踪系统，应该是最终用户、技术支持人员、开发
和质量保证工程师之间的信息渠道。它应该帮助这些人在缺陷的解
决方案中合作。为了做到这一点，缺陷跟踪系统应维护关键的信
息，并阻止不必要或不正确的信息。一个缺陷的重要方面可以被归
结为侦探调查案件时提问的那几个种类：时间、地点、人物、事
件，以及原因。
人物
一个美丽的缺陷跟踪系统，必须满足多种用户的需求。缺陷报告是
缺陷的发现者和修复缺陷的专业人土之间的一个沟通渠道。所有的
缺陷跟踪系统都需要跟踪的有：谁报告了该缺陷，谁修复了该缺
陷，以及谁验证了已被修复的缺陷。一个美丽的缺陷跟踪系统要根
据不同的用户角色组织细节，尽可能地隐藏与某特定角色不相关的
信息。开发人员需要知道如何在正确的源代码库上重现这个缺陷。
质量保证人员则有兴趣将该缺陷与现有的或新写的测试断言联系在
一起。而该软件的用户最感兴趣的是该缺陷是否还存在于他的系统
1881
---
## Page 1883
中，如果存在，该缺陷是否有对应的补丁、升级包或者间接解决方
案存在。
同时要记住重要的一点是，缺陷的优先级和严重度取决于个人关注
的焦点。一个人可能会将一个缺陷定为优先级3，因为它只在一种类
型的硬件上出现，但对于一个数据中心依赖于该硬件的人来说，这
是一个优先级1的问题。质量保证工程师和开发人员将会诊讨论最终
用户报告的缺陷，并根据其所在的组织的缺陷政策来调整优先级和
严重度。对于某些类型的缺陷，现在可以跟踪错误出现的频率。一
个理想的缺陷跟踪系统在记录一个缺陷时，会自动寻找重复的缺陷
并增加其“得票数”（vote）。得票数将与优先级和严重度评级一起被
用于确定哪些缺陷应该先修复。GNOME项目上使用的BugBuddy应
用程序山l和Mozilla的breakpad[2]还尝试自动记录崩溃缺陷（crash
bug）。然而，由于结构和其他因素可能会导致栈跟踪十分不同，所
以这里仍然需要有人干预以确定记录的缺陷是否为现有的缺陷的重
复。
事件
一个美丽的缺陷报告应以一个简要说明开始，介绍缺陷的症状，以
及重现缺陷必要的条件。它通常至少包括以下内容：
说明
对缺陷的简要说明。
详细说明
这里应包含足够的细节，以便他人重现缺陷。例如：
软件版本（代码库）
操作系统环境
·硬件
其他先决条件
重现的测试用例（测试人员这样做时期待某事发生但却发生了其他
预料不到的事情。）
1882
---
## Page 1884
注意
遗憾的是，尽管早在20世纪40年代哈佛大学的工程师就意识到要将
缺陷#1与其测试用例关联起来，但直到2009年大多数工具仍然依靠
特别（ad-hoc）方法将缺陷和测试用例联系起来。
优先级
根据已公布的缺陷政策，该缺陷有多重要？通常P1最重要，而P4或
P5最不重要。
严重度
该缺陷有什么影响？这可能与缺陷的优先级相关，但并不完全是一
回事。例如，一个会导致用户界面崩溃的缺陷可能是高严重度（因
为它是一个崩溃），但如果缺陷只存在于极少数的环境中，它可能
被视为优先级较低的。
时间
同样的工具和流程被用于在整个产品生命周期中跟踪缺陷。然而，
“典型的缺陷"的粒度却随着产品生命周期而变化。例如，单元级别
的缺陷在产品开发的早期发现，通常可以直接追溯到缺陷所在的源
代码。但一个部署的产品的最终用户报告的缺陷可能只有在多个代
码库组件交互或运行在特定的硬件上时才会出现。修复一个在产品
生命周期较晚时候发现的缺陷比产品发布前发现的缺陷更加昂贵。
因此，如我们稍后将讨论的那样，区分哪些缺陷是QA测试期间发现
的，哪些缺陷是在产品发布后发现是十分重要的。
地点
系。一个精美简单的缺陷跟踪系统可以围绕如下假设来设计：可执
行对象代码中的每个缺陷都可以追溯到某几行源代码。对于小型或
专有项目，一般限于单一代码库，这种系统能很好地运作，因为每
个缺陷和包含该缺陷的源代码之间有明确的一对一关系。但是，对
于在公共的开源缺陷跟踪系统中的缺陷，其所在的代码库并不总是
显而易见的。缺陷可能是由不熟悉代码的人记录的。对于大多数现
1883
---
## Page 1885
实世界的系统，缺陷报告和源代码的版本之间的映射既不自动，也
不健壮。
既然缺陷可以跨数层软件栈，那么它还可以跨多个项目和代码库。
尽管对于最终用户和支持人员来说，用一个单独的缺陷数据库来追
踪这种“分布式缺陷”是有帮助的，同时将适当的信息传递给上游的
缺陷数据库也是必要的，这样，组件的领域专家可以专注于问题的
某个方面。遗憾的是，缺陷一旦向上游传递后，分发的最终用户和
支持人员就很难再继续跟踪缺陷的进展，特别是相对于他们的产
品。一个NautilusNFS交互缺陷仅仅在bugzilla.gnome.org被标记为
已修复，并不意味着该修复已被集成到你的分发中，且最终用户或
支持人员并没有简单的方法来确定这一点。因此，在缺陷记录、缺
陷跟踪以及测试方面都存在大量的重复劳动，这一点上并没有充分
利用开源协作的优势。
对开发人员来说，很清楚，缺陷存在于源代码之中
BugsEverywhere之类的工具使用一个很纯粹的理念运作：既然缺
陷最终都存在于源代码中，就将缺陷跟踪和代码放在一起，并使用
相同的版本控制系统（例如，CVS、SVN、Mercurial）。这的确有很
大的优势，尤其是对整个代码库可以放在一个版本控制系统中的小
型系统而言。当一个缺陷被修复时，打补丁的源代码和更新的缺陷
报告一起被签入版本控制系统，缺陷状态和缺陷报告状态之间保持
一致，并被自动正确地传播到源代码树的分支中去，无须开发人员
或软件质量保证人员维护一个临时的源代码树和缺陷数据库状态之
间的交叉引用集合。类似BugsEverywhere或Bugzilla的系统被用于上
游组件，因为此处缺陷仅局限于单一的代码库中（见图6-2）。
Distro1
Distro2
Distro3
Mozilla
Firefox2
Firefox3
上游缺陷跟踪系统
通常局限于单一的
Java 1.4
Java 1.6
Java1.6
代码库
GNOME2.6
GNOME2.20
GNOME2.24
Xsun
X.0rg
X.0rg
S10u5kernel
0S2008.05kernel
0S2008.11kernel
1884
---
## Page 1886
图6-2上游缺陷跟踪系统局限于单一的代码库
对最终用户或支持人员来说，缺陷存在于系统或者分发中
随着项目的发展和成熟，不同的代码库的各组件之间交互。代码和
缺陷之间的关系变得更加难以跟踪，因为发现缺陷的人与代码之间
的距离更加遥远了。各组织试图采用内部以分发为中心的缺陷数据
库来解决这个问题。
问题是，旨在支持企业产品（分发）最终用户的缺陷数据库，与交
互产生缺陷的各个组件的代码库之间的关系非常薄弱（图6-3）。开
源社区的开发人员，即组件代码库的领域专家，可能无法接触到以
分发为中心的数据库。社区和企业防火墙以内有关缺陷信息的沟通
效率非常低，有时根本不存在。
Distro1
Distro2
Distro3
Mozilla
Firefox2
Firefox3
上游缺陷跟踪系统
Java 1.4
Java 1.6
Java1.6
通常局限于单一的
代码库
GNOME2.6
GNOME2.20
GNOME2.24
Xsun
X.org
X.0rg
S10u5kernel
0S2008.05kernel
0S2008.11kernel
逐层向下查看发行版缺陷
数据库，但与代码脱节
图6-3发行版缺陷数据库与代码脱节
更好的办法是让单独的以代码为中心的缺陷跟踪系统按照它们自己
的方式运作，只提取最低限度的必要的信息来跟踪缺陷。这些信息
会被提取到一个本地的元缺陷（metabug）数据库中，作为键值链接
回社区项目数据库中原先的缺陷。例如：
最小的键值信息
（upstreambugdb,bugid）→上游数据库中完整的缺陷的键值。
为方便本地审查和排序，添加了额外字段的缺陷键值信息
1885
---
## Page 1887
（upstreambugdb,bugid,synopsis,priority,severity）→上游数据库中完整
的缺陷的键值。
该参考数据库可以向社区开放，用于查看和标记缺陷。添加到该元
缺陷数据库的标签和字段，并不需要与原始数据库中的字段相对
应。此方法允许社区成员创建任意标记，用于将来自多个数据库的
缺陷划分为角色、项目或个人定义的集合，不需要增加上游缺陷数
据库的复杂性。这种轻型“元缺陷"抽象层可以被加强，以改善一个
公司的质量保证支持，及其向开源开发社区贡献有意义的缺陷数据
的能力。
多代码库缺陷跟踪的一种方法。虽然时至今日仍然没有完美的“美丽
的缺陷跟踪系统"存在，但是对用于缺陷跟踪的工具和流程相对较小