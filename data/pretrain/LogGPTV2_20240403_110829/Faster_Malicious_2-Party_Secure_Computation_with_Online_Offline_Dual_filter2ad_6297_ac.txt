Input consistency. To achieve security against active ad-
versaries, GC-based protocols must ensure that parties
provide the same inputs to all circuits that are evaluated.
This is known as the problem of input consistency. The
protocol of [16] uses the input consistency mechanism of
shelat & Shen [32] which is unfortunately not compati-
ble with the online/ofﬂine setting. More details follow in
the next section.
5
In this section we describe a new, extremely lightweight
input-consistency technique that is tailored for the dual-
execution paradigm.
5.1 Consistency Between Alice’s & Bob’s
Input Consistency
Circuits
We start with the “classical” dual-execution scenario,
where Alice and Bob each generate one garbled circuit.
We describe how to force Alice to use the same input in
both of these garbled circuits (of course, the symmetric
steps are performed for Bob). The high-level idea is to
bind her behavior as OT receiver (when obtaining gar-
bled inputs for Bob’s circuits) to the commitments of her
garbled inputs in her own circuits.
It is well-known [2] that oblivious transfers on ran-
dom inputs can be performed ofﬂine, and later “deran-
domized” to OTs of chosen inputs. Suppose two parties
perform a random string OT ofﬂine, where Alice receives
c,mc and Bob receives m0,m1, for random c ∈ {0,1} and
m0,m1 ∈ {0,1}k. Later when the parties wish to per-
form an OT of chosen inputs c∗ and (m∗0,m∗1), Alice can
send d = c ⊕ c∗ and Bob can reply with m∗0 ⊕ md and
m∗1 ⊕ m1⊕d.
In the ofﬂine phase of our protocol, the parties perform
a random OT for each Alice-input wire of each circuit,
where Alice acts as the receiver. These will be later used
for Alice to pick up her garbled input for Bob’s circuit.
Let c denote the string denoting Alice’s random choice
bits for this collection of OTs.
Also in the ofﬂine phase, we will have Alice commit
to all of the possible garbled input labels for the circuits
that she generated. Suppose she commits to them in an
order determined by the bits of c; that is, the wire la-
bel commitments for the ﬁrst input wire are in the order
(false,true) if the ﬁrst bit of c is 0 and (true,false) other-
wise.
In the online phase with input x, Alice sends the OT
“derandomized” message d = x⊕ c. She also sends her
garbled inputs for the circuits she generated by opening
the commitments indexed by d; that is, she opens the
ﬁrst or second wire label of the ith pair, depending on
whether di = 0 or di = 1, respectively. Bob will abort if
Alice does not open the correct commitments.
Alice’s effective OT input is x = d ⊕ c, so she picks
up garbled input corresponding to x. If Alice did indeed
commit to her garbled inputs arranged according to c,
then she opens the commitments whose truth values are
also x = d ⊕ c. More formally,
Ofﬂine: Alice garbles the labels A0,A1 and Bob
garbles B0,B1 for Alice’s input. Alice receives OT
message mc and Bob holds m0,m1. Alice sends
(COMMIT, (sid,i),Ai⊕c) to Fcom for i ∈ {0,1}.
Online: Alice send d = c⊕ x to Bob and (OPEN, (sid,
d)) to Fcom. Bob receives (OPEN, (sid,d),Ax) from
Fcom and sends (B0 ⊕ md,B1 ⊕ m1⊕d) to Alice who
computes Bx = mc ⊕ (Bc⊕d ⊕ mc).
Figure 4: Input consistency on a single bit of Alice’s input for
“classic” dual-execution.
Looking ahead, we will use cut-and-choose to guar-
antee that there is at least one circuit for which Alice’s
garbled input commitments are correct in this way.
5.2 Aggregating Several OTs
In our protocol, both parties evaluate a bucket of several
circuits. Within the bucket, each of Alice’s circuits is
paired with one of Bob’s, as above. However, this im-
plies that Alice uses separate OTs to pick up her garbled
inputs in each of Bob’s circuits. To address this, we ag-
gregating several OTs together to form a single OT.
Suppose Alice & Bob have performed two random
string OTs, with Alice receiving c,c(cid:26),mc,m(cid:26)c(cid:26) and Bob re-
ceiving m0,m1,m(cid:26)0,m(cid:26)1, for random c,c(cid:26) ∈ {0,1}. Sup-
pose further that Alice sends δ = c⊕ c(cid:26) to Bob in an of-
ﬂine phase. To aggregate these two random OTs into
a single chosen-input OT with inputs c∗,m∗0,m∗1, Alice
can send d = c⊕ c∗, and Bob can reply with m∗0 ⊕ (md ⊕
m(cid:26)d⊕δ ) and m∗1 ⊕ (m1⊕d ⊕ m(cid:26)1⊕d⊕δ ).
The idea extends to aggregate any number B of dif-
ferent random OTs into a single one, with Alice sending
B− 1 different δ difference values. In our protocol, we
aggregate in this way the OTs for the same wire across
different circuits. Intuitively, Alice either receives wire
labels for the same value on each of these wires (by re-
porting correct δ values), or else she receives nothing for
this wire on any circuit.
5.3 Combining Everything with Cut-and-
Choose
Now consider a bucket of B circuits. In the ofﬂine phase
Alice acts as receiver in many random OTs, one collec-
tion of them for each of Bob’s circuits. Let c j be her
(string of) choice bits for the OTs associated with the jth
circuit. Alice is then supposed to commit to the garbled
inputs of her jth circuit arranged according to c j. Bob
will check this property for all circuits that are opened
during the cut-and-choose phase by Alice showing the
USENIX Association  
25th USENIX Security Symposium  303
7
corresponding OT messages.3 Hence with probability at
least 1 − 2−κb, at least one circuit in any given bucket
has this property. Alice also reports aggregation values
δ j = c1 ⊕ c j for these OTs.
In the online phase Alice chooses her input x and sends
d1 = c1 ⊕ x as the OT-derandomization message. This is
equivalent to Alice sending d j = δ j ⊕ d1 as the message
to derandomize the jth OTs. To send her garbled input
for the jth circuit, Alice is required to open her commit-
ments indexed by d j.
If Alice lies in any of the aggregation strings, then
she will be missing at least one of the B-out-of-B secret
shares which mask her possible inputs. Intuitively, Al-
ice’s two strategies are either to provide honest aggrega-
tion strings or not obtain any garbled inputs in the po-
sition that she lied. In the latter case, the simulator can
choose an arbitrary input for Alice in that position.
If we then consider the likely case where Bob’s jth
circuit is “good” and Alice provided honest aggregation
strings, then Alice will have decommitted to inputs for
the jth circuit that are consistent with her effective OT in-
put x∗1. From the discussion in Section 4.1, this is enough
to guarantee that the reconciliation phase leaks nothing.
Even if there are no “good” circuits in the bucket
(which happens with probability 1/2κb), it is still the
case that Alice learns no more than if she had received
consistent garbled input x∗1 for all of Bob’s circuits. So
the reconciliation phase can be simulated knowing only
whether Bob evaluates any circuit resulting in f (x∗1,x2).
This is a single bit of information about Bob’s input x2.
6 Selective Failure Attacks
In the garbled circuit paradigm, suppose Alice is acting
as evaluator of some garbled circuits. She uses OT to
pick up the wire labels corresponding to her input. A
corrupt Bob could provide incorrect inputs to these OTs,
so that (for instance) Alice picks up an invalid garbled
input if and only if the ﬁrst bit of her input is 0. By ob-
serving whether the evaluator aborts (or produces other-
wise unexpected behavior), Bob can deduce the ﬁrst bit
of Alice’s input. This kind of attack, where the adversary
causes the honest party to abort/fail with probability de-
pending on its private input is called a selective failure
attack.
A common way to prevent selective failure is to use
what is called a k-probe-resistant input encoding:
Deﬁnition 2 ([20, 32]). Matrix M ∈ {0,1}(cid:29)×n is called k-
probe resistant if for any L ⊆ {1,2, ...,n}, the Hamming
distance of(cid:31)i∈L Mi is at least k, where Mi denotes the
ith row vector of M.
3In fact, since the OT messages are long random strings, Alice can
prove that she had particular choice bits in many OTs by simply report-
ing the XOR of all of the corresponding OT messages.
The idea is for Alice to choose a random encoding ˜x1
of her logical input x1 satisfying M ˜x1 = x1. Then the par-
ties evaluate the function f (cid:23)( ˜x1,x2) = f (M ˜x1,x2). This
additional computation of M ˜x1 involves only XOR op-
erations, so it does not increase the garbled circuit size
when using the Free-XOR optimization [17] (it does in-
crease the number OTs needed).
Alice will now use ˜x1 as her choice bits to the OTs.
The adversary can probe any number of bits of ˜x1, by
inserting invalid inputs to the OT in those positions, and
seeing whether the other party aborts. For each position
probed, the adversary incurs a 1/2 probability of being
caught.4
The property of k-probe-resistance implies that prob-
ing k bits of the physical input ˜x1 leaks no information
about the logical input M ˜x1. However, probing k bits
incurs a 1 − 2−k probability of being caught. Hence,
our protocol requires a matrix that is κs-probe resistant,
where κs is the statistical security parameter. We refer
the reader to [23] for the construction details of k-probe
resistant matrices and their parameters.
6.1 Ofﬂining the k-probe computations
Using k-probe-resistant encodings, the encoded input ˜x1
is signiﬁcantly longer than the logical input x1. While
the computation of M ˜x1 within the garbled circuit can
involve no cryptographic operations (using Free-XOR),
it still involves a quadratic number of XOR operations.
Lindell & Riva [22] suggest a technique that moves
these computations associated with k-probe-resistant en-
codings to the ofﬂine phase. The parties will compute the
related function f (cid:23)( ˆx1,c,x2) = f ( ˆx1 ⊕ Mc,x2). In the of-
ﬂine phase, Alice will use OT to obtain wire labels for a
random string c. She can also begin to partially evaluate
the garbled circuit, computing wire labels for the value
Mc.
In the online phase, Alice announces ˆx1 = x1 ⊕ Mc
where x1 is her logical input. Then Bob directly sends
the garbled inputs corresponding to ˆx1. This introduces
an asymmetry into our input consistency technique. The
most obvious solution to maintain compatibility is to
always evaluate circuits of the form f (cid:23)( ˆx1,c1, ˆx2,c2) =
f ( ˆx1⊕ Mc1, ˆx2⊕ Mc2), so that Alice uses the same phys-
ical input (c1, ˆx1) in both hers and Bob’s circuits. How-
ever, we would prefer to let Alice use logical input x1
rather than its (signiﬁcantly longer) k-probe-encoded in-
put, to reduce the concrete overhead. It turns out that we
can accommodate this by exploiting the Z2-linearity of
the encoding/decoding operation.
Consider a bucket of circuits {1, . . . ,B}. For the jth
4Technically, the sender will commit to all garbled inputs, and then
the OTs will be used to transfer the decommitment values. That way,
the receiver can abort immediately if an incorrect decommitment value
is received.
304  25th USENIX Security Symposium 
USENIX Association
8
circuit, Alice acts as receiver in a set of random OTs,
and receives random choice bits c j. The number of OTs
per circuit is the number of bits in a k-probe-resistant
encoding of Alice’s input.
For Alice’s jth circuit, she must commit to her garbled
inputs in the order given by the string Mc j (rather than
just c j as before). This condition will be checked by Bob
in the event that this circuit is opened during cut-and-
choose. To assemble a bucket, Alice reports aggregation
values δ j = c1⊕c j as before. Imagine Alice derandomiz-
ing these OTs by sending an all-zeroes derandomization
message. This corresponds to her accepting the random
c1 as her choice bits. (Of course, an all-zeroes message
need not be actually sent.) Bob responds and uses the ag-
gregated OTs to send Alice the garbled inputs for c1 for
all of his garbled circuits (indeed, even in the jth circuit
Alice receives garbled inputs corresponding to c1).
In the online phase, Alice decides her logical input x1,
and she sends ˆx1 = Mc1 ⊕ x1. This value derandomizes
the ofﬂine k-probe-resistant encoding. Then in her own
jth circuit, Alice must open the garbled input commit-
ments indexed by the (public) string ˆx1 ⊕ Mδ j.
To see why this solution works, suppose that Alice’s
jth circuit is “good” (i.e., garbled correctly and input
commitments arranged by Mc j). As before, deﬁne her
effective OT input to the jth OTs as c∗ = c j ⊕ δ j (which
should be c1 if Alice did not lie about δ j). Even if Alice
lied about the δ values she surely learns no more than she
would have learned by being truthful about the δ values
and using effective input c∗ in all OTs. Hence, we can
imagine that she uses logical input x∗1 = ˆx1 ⊕ Mc∗ in all
of Bob’s garbled circuit.
Alice is required to open garbled inputs indexed by
ˆx1 ⊕ Mδ j = ˆx1 ⊕ M(c∗ ⊕ c j) =x ∗1 ⊕ Mc j. These are ex-
actly the garbled inputs corresponding to logical input x∗1,
since the commitments were arranged according to Mc j.
We see that Bob evaluates at least one correctly garbled
circuit with Alice using input x∗1, which is all that is re-
quired for weak input consistency.
7 Optimizing PSI Reconciliation
7.1 Weaker security.
Our main insight is that our PSI reconciliation step does
not require a fully (UC) secure PSI protocol. Instead, a
weaker security property sufﬁces. Recall that the ﬁnal
steps of the [16] protocol proceed as follows:
• Alice & Bob commit to their PSI inputs.
• The garbled-output
• The parties either abort or release the PSI output.
translations are opened and
For simplicity, assume for now that only one party re-
ceives the ﬁnal PSI output. We will address two-sided
output later.
checked.
Suppose Alice is corrupt and Bob is honest. Following
from the discussion of security in Section 4, Bob will use
as PSI input a collection of valid reconciliation values.
At the time Alice provides her PSI inputs, the authen-
ticity property of the garling scheme is in effect. This
means that Alice can predict a valid reconciliation value
only for the “correct” output y∗. All other valid recon-
ciliation values that might be part of Bob’s PSI input are
unpredictable.
Below we formalize a weak notion of security for in-
put distributions of this form:
Deﬁnition 3. Let Π be a two-phase protocol for set in-
n,(cid:30)
psi , Figure 12). We say that Π is weakly
tersection (F
malicious-secure if it achieves UC-security with respect
to environments that behave as follows:
(1) The adversary sends a value a∗ ∈{0,1}(cid:30) to the envi-
ronment along with the description of a distribution
D whose support is cardinality-(n − 1) subsets of
{0,1}(cid:30). We further require that D is unpredictable
in the sense that the procedure “A ← D; output a
uniformly chosen element of A” yields the uniform
distribution over {0,1}(cid:30) (the joint distribution of all
elements of A need not be uniform).
(2) The environment (privately) samples A ← D and
gives input A∪{a∗} to the honest party for the ﬁrst
phase of PSI.
(3) After the ﬁrst phase ﬁnishes (i.e., both parties’ in-
puts are committed), the environment gives the coins
used to sample A to the adversary.
(4) The environment then instructs the honest party to
perform the second phase of PSI to obtain output.
In this deﬁnition, the adversary knows only one value
in the honest party’s set, while all other values are essen-
tially uniform. We claim that when (cid:30) is large, the simu-
lator for this class of environments does not need to fully
extract the adversary’s PSI input! Rather, the following
are enough to ensure weakly-malicious security:
• The adversary is indeed committed to some (un-
known to the simulator) effective input during the
commit phase.
fective PSI input contains the special value a∗.
• The simulator can test whether the adversary’s ef-
With overwhelming probability, no effective input ele-
ment other than a∗ can contribute to the PSI output. Any
other values in the adversary’s effective input can simply
be ignored; they do not need to be extracted.
For technical reasons and convenience in the proof, we
have the environment give the adversary the coins used
to sample A, but only after the PSI input phase.
7.2 PSZ protocol paradigm.
We now describe an inexpensive protocol paradigm for
PSI, due to Pinkas et al. [30]. Their protocol is proven
USENIX Association  
25th USENIX Security Symposium  305
9