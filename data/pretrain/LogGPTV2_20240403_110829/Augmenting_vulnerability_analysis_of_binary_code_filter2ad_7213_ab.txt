(w0, b1) ← {(r0, b1), (r1, b1), (r0, b0), (r1, b0)}
(w0, b2) ← {(r0, b2), (r1, b2), (r0, b1), (r1, b1)}
(w0, b3) ← {(r0, b3), (r1, b3), (r0, b2), (r1, b2)}
f lags = (ZF, CF, OF, P F, AF, SF )
Figure 2: Syntactic speciﬁcation for the add reg32,
mem32 instruction
memory address x and then set S[x] = d. Direct sources are
typically functions such as read, recv and so on.
Alternatively, we may use IndirectTI when we consider
the data stored at x ∈ I to be indirectly under the control of
an attacker. Indirect sources of control are more diverse and
sometimes less obvious than their direct counterparts. Of-
ten indirect inﬂuence arises when an output from a function
has a control ﬂow dependency on a location x ∈ I for which
S[x] (cid:6)= N U LL. A straightforward example of this form of in-
direct inﬂuence is the strlen function. If a program contains
a call to strlen(s) where s is controlled by an attacker then
the return value is certainly inﬂuenced, albeit indirectly. For
such cases we can connect the new IndirectTI objects to
the TaintInformation objects of the data which induced
the control ﬂow dependency.
For other sources of indirect inﬂuence there may be no
clear data or control ﬂow dependency between the updated
location x ∈ I and another location y ∈ I for which S[y] (cid:6)=
N U LL. For instance, the return value of the recv function
can be indirectly controlled by an attacker based on the
number of bytes sent and also by closing the connection.
For such cases there is no parent TaintInformation instance
to connect the new IndirectTI instance to but as we are
not aiming to automatically generate new inputs this is not
problematic.
3.1.2 Propagating Taint Information
After the ﬁrst execution of a (fpre, fpost) pair that up-
dates S such that (∃x ∈ I | S[x] (cid:6)= N U LL) is true the taint
propagation mechanisms of DT are enabled. From that point
onwards every instruction executed is hooked to detect if
it operates on bytes that are tainted and, if so, to propa-
gate that taint information to any written registers, ﬂags or
memory locations. When this process starts a global tainted
instruction counter is initialized to zero and incremented on
each instruction that propagates tainted data. This is sim-
ply used later to assist in reconstructing traces.
For each instruction we deﬁne the set of outputs U ⊂ I
as the registers, ﬂags or memory locations that are modi-
ﬁed by the instruction. On the x86/x64 architectures each
instruction may have multiple outputs. Each output o ∈ U
is a function over a set of inputs N ⊂ I, where N may be
the empty set ∅.
If we deﬁne the set of tainted inputs T
as {i ∈ N | S[i] (cid:6)= N U LL} then taint propagation occurs
when, for a given output o, T (cid:6)= ∅. When these conditions
are met we propagate the information from T to o in S.
Before discussing propagation we must ﬁrst mention how
multi-byte operations are processed to produce the required
relationship between inputs and outputs. For each x86/x64
instruction that we handle we provide a map M that de-
scribes the relationships between inputs and outputs in terms
of the instruction’s operands. This is a syntactic description
of the relation from inputs to outputs with no semantic infor-
mation. For example, for the add reg32, mem32 instruction
201
the map looks as described in Figure 2.
(wn, bm) stands for the mth byte of the nth write operand
and (rn, bm) stands for the mth byte of the nth read operand.
If we inspect the mapping for the second output byte we can
see that it deﬁnes the output as a factor of both the second
bytes of both inputs and the ﬁrst bytes of both inputs. This
is to account for potential carrys in the addition. For in-
structions like shl reg32, cl, where we do not know exactly
which inputs may contribute the which output, we over-
approximate. Typically this is done by saying each output
o ∈ U is a factor all elements of N . The map also deﬁnes
the ﬂags that may be updated by the instruction.
We begin propagation by converting each (opn, bytem)
pair to an identiﬁer i ∈ I. For registers this is done by
means of another map which, for any register operand and
byte oﬀset, returns the correct identiﬁer used to reference
that particular subregister, or byte. For memory addresses
we can simply compute the identiﬁer by adding the byte oﬀ-
set to the base address. By iterating over M we can then
produce a set of tuples R = (o ∈ U, N ⊂ I) deﬁning the
byte level relationships between inputs and outputs. This
provides us with the required information to update S[o] for
each tuple.
Input Tracking.
DT allows for two diﬀerent taint propagation modes.
In
the ﬁrst mode, which we will call the tracking mode, each
instruction simply spreads the taint status of inputs through
to outputs without recording the instruction address, or any
other identifying information, responsible for the taint prop-
agation. In this mode, for any given location (i ∈ I | S[i] (cid:6)=
N U LL) we can tell which program input bytes may have
contributed to the value in location i. However, we cannot
tell the instructions that were responsible for manipulating
and moving that tainted data from the program input to
location i.
For each tuple (o ∈ U, N ⊂ I) ∈ R we begin by retrieving
the corresponding TaintInformation instances for each in-
put i ∈ N , producing a set of TaintInformation instances
V .
It is possible that an element of V is in fact a Com-
poundTI instance, representing the join of inﬂuence from
multiple input bytes. If this is the case we recursively replace
that CompoundTI instance with the members of its compo-
nents attribute. This is done to ensure that CompoundTI
instances that are created, used to inﬂuence a new location
and then overwritten can be safely deleted, thus minimizing
the amount of memory required. Once this has been per-
formed for all elements of V the ﬁnal set consists only of
DirectTI and IndirectTI instances.
If V contains two or more elements we create a Com-
poundTI instance and set its components attribute equal to
a vector constructed from V . The end result is that every
element of S is either a DirectTI/IndirectTI instance or a
CompoundTI instance with a components attribute consisting
of instances of these types.
Input Tracing.
In the second mode, which we will call the tracing mode,
each instruction creates new TraceTI instances for each out-
put, allowing us to track exactly which instructions were in-
volved in the computation of any given byte of tainted data.
Under this mode, for any given location (i ∈ I | S[i] (cid:6)=
N U LL) we can construct a tree by recursively traversing
202
the parents of each TraceTI instance. The leaves of this
tree will be DirectTI/IndirectTI instances and from it we
can present the user with a list of all instructions involved
in the computation of i.
To propagate the taint information we ﬁrst iterate over
the tuples (o ∈ U, N ⊂ I) ∈ R retrieving the corresponding
TaintInformation instances for each input i ∈ N , produc-
ing a set of TaintInformation instances V . In this mode, an
element of V may be a DirectTI, IndirectTI or TraceTI in-
stance. The key diﬀerence is that we do not expand TraceTI
instances like we did CompoundTI instances. Instead we cre-
ate a new TraceTI instance and set its parents attribute
equal to a vector constructed directly from V . This ensures
that for any element of S we have available the information
to construct the tree linking it back to input data. The other
diﬀerence is that TraceTI objects store the global tainted
instruction counter in the sequence_num attribute. This is
integral in later reconstructing the order in which updates
were made to values that are not derived from one another.
It is also used to align the individual byte updates performed
in a single multi-byte instruction when processing traces.
Value Constraints.
The above processes allow us to track or trace data be-
tween a taint source and a taint sink. However, it is also
desirable that we would be able to report on the constraints
imposed on this data. For example, if the current path
through the program contains a test instruction that op-
erates on tainted data, followed by a conditional jump, then
this may impose a restriction on the set of values that data
may have and still trigger the same path. Such informa-
tion is useful in diﬀerentiating safe from unsafe arithmetic
performed by a program.
In order to facilitate this, we allow a user to enable an op-
tional mode that propagates taint information to the CPU
ﬂags register. For each instruction that updates CPU ﬂags
and operates on tainted data we create a FlagUpdateTI in-
stance. The parents attribute of this instance is set to a
vector of all TaintInformation instances across all operands
of that instruction. For all ﬂag identiﬁers i ∈ I updated by
the given instruction, S is then updated by setting S[i] equal
to the FlagUpdateTI instance.
On a conditional jump instruction we then retrieve the
FlagUpdateTI instance for each ﬂag used and merge their
parents vectors together into a new set C. C is a set of all
TaintInformation instances that may aﬀect the outcome of
the conditional jump. A tuple (C, a, n) is then appended to
a list used to represent the path condition, where a is the
current instruction address and n is the current value of the
global tainted instruction counter. This list is periodically
ﬂushed to disk.
The Performance/Accuracy Tradeoff.
The primary downside to a syntactic, rather than seman-
tic, approach to data ﬂow speciﬁcation is related to accuracy.
Without access to the semantics of an instruction it is possi-
ble to conclude that a location in S is tainted when it is not.
As an example, consider the instruction xor eax, eax and
assume that the EAX register is tainted. If the handler for
XOR shares the speciﬁcation of other bitwise operators, like
AND and OR, we would incorrectly conclude that the EAX
register is still tainted after this instruction. Taking the XOR
of a location with itself in order to clear it is a common op-
eration however, and so we can speciﬁcally encode a handler
for this situation to avoid an erroneous result.
In general, such a solution is not possible without bit-level
taint tracking and semantic speciﬁcations for instructions.
As a result, in some situations there will be elements of S
that are incorrectly marked as tainted. The following code
is a contrived example but demonstrates the problem:
0:
1:
2:
cmp al, 0xf0
jne EXIT
and al, 0x0f
Assume that the AL register is tainted at address 0. The
task is to decide at address 2 whether this still holds. At 2
the only information available to DT is that S[AL] (cid:6)= N U LL
as there is no facility for reasoning about the semantics of
the path condition to detect the implied boundary on the
value of the AL register. We must therefore conclude that
it is possible for at least one of the lower four bits of AL to
be set and thus that S[AL] (cid:6)= N U LL still holds after the
execution of the instruction.
While this issue is worth noting, in our experience it is not
a common problem that interferes with the users conﬁdence
in the data presented. In the domain of concolic/symbolic
execution over-tainting can still occur [15], albeit for diﬀer-
ent reasons. Similar to our work however, this is rarely a
signiﬁcant problem.
3.1.3 Tainted Data Sinks
DT allows for conﬁgurable and on-demand sinks to exe-
cute a handler once they detect tainted data. The purpose
of these handlers is usually to inform the user once attacker
inﬂuenced data reaches code that may be of interest. We
provide handlers for common sinks e.g. memory alloca-
tion or data copying functions, like malloc and sprintf,
used with tainted parameters; instructions with a REP pre-
ﬁx and a tainted ECX register; conditional jumps based
on tainted ﬂags and so on. However, as one reverse engi-
neers an application it is common to want to set application-
speciﬁc handlers. We support this by allowing users to spec-
ify an (address, shared library) pair and inserting hooks
from their shared library at the address provided. This al-
lows monitoring of custom memory management routines,
third party libraries, and any other code without modiﬁca-
tion to the core of DT.
Depending on the type of sink, the number of hooks re-
quired and their interactions may diﬀer slightly but in gen-
eral they operate as follows. For a given sink k we deﬁne a
function pair (kcheck, kalert), where kcheck inspects a set of
program locations given by L ⊂ I and kalert logs suﬃcient
information to allow prioritization of results by static anal-
ysis and/or, importing of the results into IDA for inspection
by the user. Let T = {l | l ∈ L, S[l] (cid:6)= N U LL}, then kalert
is executed if T (cid:6)= ∅. kalert will typically log the address of
the sink along with the information on all members of T . If
the tracking propagation mode is in use then this informa-
tion will be limited to the tainted inputs that inﬂuenced the
members of T . However, if the tracing propagation mode is
in use kalert will have access to this information as well as
a trace of every instruction that modiﬁed those input bytes
between their introduction and the sink k. For each ele-
ment of T the sequence of parents back to the taint source
will be logged, including instruction addresses and the se-
quence_num attribute.
3.2 Post-Processing and User Interface
DT produces a variety of outputs containing information
useful in the processes of vulnerability identiﬁcation and re-
verse engineering. The following categories of information
are made available:
A Program Trace A user can choose to log each instruc-
tion the ﬁrst time it processes tainted data or, alterna-
tively, a log of each instruction every time it processes
tainted data.
Function Alerts Each (kcheck, kalert) pair as described above
may result in a log of inputs, or inputs and then mod-
ifying instructions, every time that function is called
with tainted parameters.
Instruction Alerts Certain instructions can also be hooked
with a (kcheck, kalert) pair and produce the same style
output as function hooks. Of particular interest are the
execution of REP preﬁxed instructions with a tainted
ECX register and conditional jumps that are inﬂu-
enced by tainted ﬂags.
The Path Constraints If this feature was enabled then
a log of the branch points conditional on user input,
as well as the bytes they were inﬂuenced by will be
available.
Applications that perform signiﬁcant processing on at-
tacker controlled inputs can result in large amounts of data
being logged across these categories. Table 2 shows the num-
ber of unique instructions acting on tainted data with per
tested application. These ﬁgures range from approximately
5000 instructions to upwards of 25,000. When working on
smaller targets it may be suﬃcient to simply display this
information in a table to the user. For larger targets how-
ever, such as those discussed in section 4, it is necessary
to process, rank and then display this information in such a
way as to focus the user on the most relevant results.
The processing and ranking functionality that makes up SA