第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B
由SYN=1知道，A要求建立联机；
第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack number=(主机 A 的
seq+1),syn=1,ack=1,随机产生seq=7654321的包
第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码
ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认
13/04/2018 Page 162 of 283
seq值与ack=1则连接建立成功。
9.1.3.3. 四次挥手
TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连
接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单
方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个
方向的连接。
1） 关闭客户端到服务器的连接：首先客户端 A发送一个FIN，用来关闭客户到服务器的数据传送，
然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u
2） 服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。
3） 关闭服务器到客户端的连接：也是发送一个FIN给客户端。
4） 客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。
首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
13/04/2018 Page 163 of 283
主机A发送FIN后，进入终止等待状态， 服务器B收到主机A连接释放报文段后，就立即
给主机A发送确认，然后服务器B就进入close-wait状态，此时TCP服务器进程就通知高
层应用进程，因而从A到B的连接就释放了。此时是“半关闭”状态。即A不可以发送给
B，但是B可以发送给A。此时，若B没有数据报要发送给A了，其应用进程就通知TCP释
放连接，然后发送给A连接释放报文段，并等待确认。A发送确认后，进入time-wait，注
意，此时TCP连接还没有释放掉，然后经过时间等待计时器设置的2MSL后，A才进入到
close状态。
9.1.4. HTTP原理
HTTP是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，
这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服
务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向
服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。
9.1.4.1. 传输流程
1：地址解析
如用客户端浏览器请求这个页面：http://localhost.com:8080/index.htm 从中分解出协议名、主机名、
端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：
协议名：http
主机名：localhost.com
端口：8080
对象路径：/index.htm
13/04/2018 Page 164 of 283
在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。
2：封装HTTP请求数据包
把以上部分结合本机自己的信息，封装成一个HTTP请求数据包
3：封装成TCP包并建立连接
封装成TCP包，建立TCP连接（TCP的三次握手）
4：客户机发送请求命
4）客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资
源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。
5：服务器响应
服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或
错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
6：服务器关闭TCP连接
服务器关闭TCP连接：一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连
接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送
后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求
建立新连接所需的时间，还节约了网络带宽。
9.1.4.2. HTTP状态
状态码 原因短语
消息响应
100 Continue(继续)
101 Switching Protocol(切换协议)
13/04/2018 Page 165 of 283
成功响应
200 OK(成功)
201 Created(已创建)
202 Accepted(已创建)
203 Non-Authoritative Information(未授权信息)
204 No Content(无内容)
205 Reset Content(重置内容)
206 Partial Content(部分内容)
重定向
300 Multiple Choice(多种选择)
301 Moved Permanently(永久移动)
302 Found(临时移动)
303 See Other(查看其他位置)
304 Not Modified(未修改)
305 Use Proxy(使用代理)
306 unused(未使用)
307 Temporary Redirect(临时重定向)
308 Permanent Redirect(永久重定向)
客户端错误
400 Bad Request(错误请求)
401 Unauthorized(未授权)
402 Payment Required(需要付款)
403 Forbidden(禁止访问)
404 Not Found(未找到)
405 Method Not Allowed(不允许使用该方法)
406 Not Acceptable(无法接受)
407 Proxy Authentication Required(要求代理身份验证)
408 Request Timeout(请求超时)
409 Conflict(冲突)
410 Gone(已失效)
411 Length Required(需要内容长度头)
412 Precondition Failed(预处理失败)
413 Request Entity Too Large(请求实体过长)
414 Request-URI Too Long(请求网址过长)
415 Unsupported Media Type(媒体类型不支持)
416 Requested Range Not Satisfiable(请求范围不合要求)
417 Expectation Failed(预期结果失败)
服务器端错误
500 Internal Server Error(内部服务器错误)
501 Implemented(未实现)
502 Bad Gateway(网关错误)
503 Service Unavailable(服务不可用)
504 Gateway Timeout (网关超时)
505 HTTP Version Not Supported(HTTP版本不受支持)
9.1.4.3. HTTPS
HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的
HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用
的端口号是443。 过程大致如下：
13/04/2018 Page 166 of 283
建立连接获取证书
1） SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握
手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算
法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所
需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书
的公司，公共秘钥）。
证书验证
2） Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公
共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。
数据加密和传输
3） 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务
器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。
9.1.5. CDN 原理
CND一般包含分发服务系统、负载均衡系统和管理系统
9.1.5.1. 分发服务系统
其基本的工作单元就是各个Cache服务器。负责直接响应用户请求，将内容快速分发到用户；同时还
负责内容更新，保证和源站内容的同步。
13/04/2018 Page 167 of 283
根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速
服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部
署的Cache集群组成。
在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个
Cache设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由
哪个Cache设备来响应用户的请求。
9.1.5.2. 负载均衡系统：
负载均衡系统是整个CDN系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问
地址。
使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。
GSLB根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过DNS
解析或者应用层重定向（Http 3XX重定向）的方式实现。
SLB主要负责节点内部的负载均衡。当用户请求从GSLB调度到SLB时，SLB会根据节点内各个
Cache设备的工作状况和内容分布情况等对用户请求重定向。SLB的实现有四层调度（LVS）、七层调
度（Nginx）和链路负载调度等。
9.1.5.3. 管理系统：
分为运营管理和网络管理子系统。
网络管理系统实现对CDN系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资
源的可视化的集中管理，通常用web方式实现。
运营管理是对CDN系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、
交付工作。包括用户管理、产品管理、计费管理、统计分析等。
13/04/2018 Page 168 of 283
10. 日志
10.1.1. Slf4j
slf4j的全称是Simple Loging Facade For Java，即它仅仅是一个为Java程序提供日志输出的统一接
口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不
能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带
的java.util.logging.Logger等。
10.1.2. Log4j
Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、
文件、GUI组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控
制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。
Log4j由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。
1.Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制
2.Appenders : 指定了日志将打印到控制台还是文件中
3.Layout : 控制日志信息的显示格式
Log4j中将要输出的Log信息定义了5种级别，依次为DEBUG、INFO、WARN、ERROR和FATAL，
当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况
下要输出的内容，而不需要更改代码。
10.1.3. LogBack
简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。
Logback 主要由三个模块组成：logback-core，logback-classic。logback-access
logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的
通用机制。
logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单
日志门面 SLF4J；
logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与
HTTP 访问相关的功能。
10.1.3.1. Logback优点
(cid:131) 同样的代码路径，Logback 执行更快
(cid:131) 更充分的测试