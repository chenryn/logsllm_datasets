implementations may use hardware support.
6.4.1.4. System Calls
The PowerPC system call instruction is used by programs to generate a system call exception, which
causes the processor to prepare and execute the system call handler in the kernel. The system call
exception is synchronous. Hundreds of system calls constitute a well-defined set of interfaces serving
as entry points into the kernel for user programs.
POSIX
A standard set of system calls, along with their behavior, error handling, return values,
and so on, is defined by a Portable Operating System Interface (POSIX) standard, which
defines an interface and not its implementation. Mac OS X provides a large subset of the
POSIX API.
The name POSIX was suggested by Richard Stallman. POSIX documentation suggests
that the word should be pronounced pahz-icks, as in positive, and not poh-six or other
variations.
To sum up, a hardware interrupt from an external device generates an external interrupt exception, a
system call generates a system call exception, and other situations result in a variety of exceptions.
6.4.2. Implementing System Entry Mechanisms
PowerPC exceptions are the fundamental vehicles for propagating any kind of interrupts (other than
ASTs), whether hardware- or software-generated. Before we discuss how some of these exceptions
are processed, let us look at the key components of the overall PowerPC exception-processing
mechanism on Mac OS X. These include the following, some of which we have come across in
earlier chapters:
The kernel's exception vectors that reside in a designated memory area starting at physical
memory address 0x0
PowerPC exception-handling registers
 The rfid (64-bit) and rfi (32-bit) system linkage instructions, which are used for returning
from interrupts
 The sc system linkage instruction, which is used to cause a system call exception
Machine-dependent thread state, including memory areas called exception save areas, which
are used for saving various types of context during exception processing
A system linkage instruction connects user-mode and supervisor-mode software. For example, by
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 25 of 137
using a system linkage instruction (such as sc), a program can call on the operating system to perform
a service. Conversely, after performing the service, the operating system can return to user-mode
software by using another system linkage instruction (such as rfid).
6.4.2.1. Exceptions and Exception Vectors
The __VECTORS segment of the kernel executable (Figure 65) contains the kernel's exception vectors.
As we saw in Chapter 4, BootX copies these to their designated location (starting at 0x0) before
transferring control to the kernel. These vectors are implemented in osfmk/ppc/lowmem_vectors.s.
Figure 65. The Mach-O segment containing the exception vectors in the kernel executable
$ otool -l /mach_kernel
...
Load command 2
cmd LC_SEGMENT
cmdsize 124
segname __VECTORS
vmaddr 0x00000000
vmsize 0x00007000
fileoff 3624960
filesize 28672
maxprot 0x00000007
initprot 0x00000003
nsects 1
flags 0x0
Section
sectname __interrupts
segname __VECTORS
addr 0x00000000
size 0x00007000
offset 3624960
align 2^12 (4096)
reloff 0
nreloc 0
flags 0x00000000
reserved1 0
reserved2 0
...
Table 51 lists various PowerPC processor exceptions and some of their details. Recall that most
exceptions are subject to one or more conditions; for example, most exceptions can occur only when
no higher-priority exception exists. Similarly, exceptions caused by failed effective-to-virtual address
translations can occur only if address translation is enabled. Moreover, depending on a system's
specific hardware, or whether the kernel is being debugged, some exceptions listed in Table 51 may
be inconsequential. Figure 66 shows an excerpt from lowmem_vectors.s. For example, when there is
a system call exception, the processor executes the code starting at the label .L_handlerC00 (vector
offset 0xC00).
Figure 66. The kernel's exception vectors
; osfmk/ppc/lowmem_vectors.s
...
#define VECTOR_SEGMENT .section __VECTORS, __interrupts
VECTOR_SEGMENT
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 26 of 137
.globl EXT(lowGlo)
EXT(lowGlo):
.globl EXT(ExceptionVectorsStart)
EXT(ExceptionVectorsStart):
baseR:
...
. = 0x100 ; T_RESET
.globl EXT(ResetHandler)
.L_handler100:
...
. = 0x200 ; T_MACHINE_CHECK
.L_handler200:
...
. = 0x300 ; T_DATA_ACCESS
.L_handler300:
...
. = 0xC00 ; T_SYSTEM_CALL
.L_handlerC00:
...
The exception vectors for the x86 version of Darwin are implemented in osfmk/i386/locore.s.
Exception Vectors in Early UNIX
The concept of exception vectors in early UNIX was very similar to the one being
discussed here, although there were far fewer vectors. The UNIX trap vectors were
defined in an assembly file called low.s or l.s, representing that the vectors resided in
low memory. Figure 67 shows an excerpt from the low.s file in the Third Edition UNIX
source.
Figure 67. Trap vectors in Third Edition UNIX
/ PDP-11 Research UNIX V3 (Third Edition), circa 1973
/ ken/low.s
/ low core
...
.globl start
. = 0^.
4
br 1f
/ trap vectors
trap; br7+0 / bus error
trap; br7+1 / illegal instruction
trap; br7+2 / bpt-trace trap
trap; br7+3 / iot trap
trap; br7+4 / power fail
trap; br7+5 / emulator trap
trap; br7+6 / system entry
. = 040^.
1: jmp start
. = 060^.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 27 of 137
klin; br4
klou; br4
...
6.4.2.2. Exception-Handling Registers
The Machine Status Save/Restore Register 0 (SRR0) is a special branch-processing register in the
PowerPC architecture. It is used to save machine status on interrupts and to restore machine status on
return from interrupts. When an interrupt occurs, SRR0 is set to the current or next instruction
address, depending on the nature of the interrupt. For example, if an interrupt is being caused due to
an illegal instruction exception, then SRR0 will contain the address of the current instruction (the one
that failed to execute).
SRR1 is used for a related purpose: It is loaded with interrupt-specific information when an interrupt
occurs. It also mirrors certain bits of the Machine State Register (MSR) in the case of an interrupt.
The special-purpose registers SPRG0, SPRG1, SPRG2, and SPRG3 are used as support registers (in
an implementation-dependent manner) in various stages of exception processing. For example, the
Mac OS X kernel uses SPRG2 and SPRG3 to save interrupt-time general-purpose registers GPR13
and GPR11, respectively, in the implementation of the low-level exception vectors. Furthermore, it
uses SPRG0 to hold a pointer to the per_proc structure.
6.4.2.3. System Linkage Instructions
System Call
When a system call is invoked from user space, GPR0 is loaded with the system call number, and the
sc instruction is executed. The effective address of the instruction following the system call
instruction is placed in SRR0, certain bit ranges of the MSR are placed into the corresponding bits of
SRR1, certain bits of the SRR1 are cleared, and a system call exception is generated. The processor
fetches the next instruction from the well-defined effective address of the system call exception
handler.
Return from Interrupt
rfid (return-from-interrupt-double-word) is a privileged, context-altering, and context-synchronizing
instruction used to continue execution after an interrupt. Upon its execution, among other things, the
next instruction is fetched from the address specified by SRR0. rfid's 32-bit counterpart is the rfi
instruction.
A context-altering instruction is one that alters the context in which instructions are executed, data is
accessed, or data and instruction addresses are interpreted in general. A context-synchronizing
instruction is one that ensures that any address translations associated with instructions following it
will be discarded if the translations were performed using the old contents of the page table entry
(PTE).
6.4.2.4. Machine-Dependent Thread State
We will examine the in-kernel thread data structure [osfmk/kern/thread.h] and related structures in
Chapter 7. Each thread contains a machine-dependent state, represented by a machine_thread
structure [osfmk/ppc/thread.h].
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 28 of 137
Figure 68 shows a portion of the machine_thread structure. Its fields include the following.
The kernel and user save area pointers (pcb and upcb, respectively) refer to saved kernel-state
and user-state contexts. The contents of a save area in xnu are analogous to those of the process
control block (PCB) in a traditional BSD kernel.
The current, deferred, and normal facility context structures (curctx, deferctx, and facctx,
respectively) encapsulate the contexts for the floating-point and AltiVec facilities. Note that the
save area holds only a normal context that does not include floating-point or vector contexts.
 The vmmCEntry and vmmControl pointers point to data structures related to the kernel's virtual
machine monitor (VMM) facility, which allows a user program to create, manipulate, and run
virtual machine (VM) instances. A VMM instance includes a processor state and an address
space. The VMM facility and its use are discussed in Section 6.9.
The kernel stack pointer (ksp) either points to the top of the thread's kernel stack or is zero.
 The machine_thread structure also contains several data structures related to the kernel's
support for the Blue Boxthat is, the Classic environment.
Figure 68. Structure for a thread's machine-dependent state
// osfmk/kern/thread.h
struct thread {
...
struct machine_thread machine;
...
};
// osfmk/ppc/thread.h
struct facility_context {
savearea_fpu *FPUsave; // FP save area
savearea *FPUlevel; // FP context level
unsigned int FPUcpu; // last processor to enable FP
unsigned int FPUsync; // synchronization lock
savearea_vec *VMXsave; // VMX save area
savearea *VMXlevel; // VMX context level
unsigned int VMXcpu; // last processor to enable VMX
unsigned int VMXsync; // synchronization lock
struct thread_activation *facAct; // context's activation
};
typedef struct facility_context facility_context;
...
struct machine_thread {
savearea *pcb; // the "normal" save area
savearea *upcb; // the "normal" user save area
facility_context *curctx; // current facility context pointer
facility_context *deferctx; // deferred facility context pointer
facility_context facctx; // "normal" facility context structure
struct vmmCntrlEntry *vmmCEntry; // pointer to current emulation context
struct vmmCntrlTable *vmmControl; // pointer to VMM control table
...
unsigned int ksp; // top of stack or zero
unsigned int preemption_count;
struct per_proc_info *PerProc; // current per-processor data
...
};
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 29 of 137
6.4.2.5. Exception Save Areas
Save areas are fundamental to xnu's exception processing. Important characteristics of the kernel's
save area management include the following.
Save areas are stored in pages, with each page logically divided into an integral number of save
area slots. Consequently, a save area never spans a page boundary.
The kernel accesses save areas using both virtual and physical addressing. A low-level interrupt
vector refers to a save area using its physical address, as exceptions (including PTE misses)
must not occur at that level. Certain queuing operations during save area management are also
performed using physical addresses.
Save areas can be permanent, or they can be dynamically allocated. Permanent save areas are
allocated at boot time and are necessary so that interrupts can be taken. The initial save areas
are allocated from physical memory. The number of initial save areas is defined in
osfmk/ppc/savearea.h, as are other save area management parameters. Eight "back-pocket"
save areas are also allocated at boot time for use in emergencies.
Save areas are managed using two global free lists: the save area free list, and the save area free
pool. Each processor additionally has a local list. The pool contains entire pages, with each slot
within a page being marked free or otherwise. The free list gets its save areas from pool pages.
The free list can be grown or shrunk as necessary. An unused save area from the free list is
returned to its pool page. If all slots in a pool page are marked free, it is taken off the free pool
list and entered into a pending release queue.
We can write a simple program as follows to display some save-area-related sizes used by the kernel.
$ cat savearea_sizes.c
// savearea_sizes.c
#include 
#include 
#define XNU_KERNEL_PRIVATE
#define __APPLE_API_PRIVATE
#define MACH_KERNEL_PRIVATE
#include 
int
main(void)
{
printf("size of a save area structure in bytes = %ld\n", sizeof(savearea));
printf("# of save areas per page = %ld\n", sac_cnt);
printf("# of save areas to make at boot time = %ld\n", InitialSaveAreas);
printf("# of save areas for an initial target = %ld\n", InitialSaveTarget);
exit(0);
}
$ gcc -I /work/xnu -Wall -o savearea_sizes savearea_sizes.c
$ ./savearea_sizes
size of a save area structure in bytes = 640
# of save areas per page = 6
# of save areas to make at boot time = 48
# of save areas for an initial target = 24
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 30 of 137
Structure declarations for the various save area types are also contained in osfmk/ppc/savearea.h.
// osfmk/ppc/savearea.h
#ifdef MACH_KERNEL_PRIVATE
typedef struct savearea_comm {
// ... fields common to all save areas
// ... fields used to manage individual contexts
} savearea_comm;
#endif
#ifdef BSD_KERNEL_PRIVATE
typedef struct savearea_comm {
unsigned int save_000[24];
} savearea_comm;
#endif
typedef struct savearea {
savearea_comm save_hdr;
// general context: exception data, all GPRs, SRR0, SRR1, XER, LR, CTR,
// DAR, CR, DSISR, VRSAVE, VSCR, FPSCR, Performance Monitoring Counters,
// MMCR0, MMCR1, MMCR2, and so on
...
} savearea;
typedef struct savearea_fpu {
savearea_comm save_hdr;
...