 和A1
 属于进程A，而线程B0
 和B1
 属于进程B。线程A0
 和B0
 在CPU 0上分时；而线程A1
 和B1
 在CPU 1上分时。线程A0
 和A1
 需要经常通信。其通信模式是，A0
 送给A1
 一个消息，然后A1
 回送给A0
 一个应答，紧跟的是另一个这样的序列。假设正好是A0
 和B1
 首先开始，如图8-14所示。
图 8-14 进程A的两个异步运行的线程间的通信
在时间片0，A0
 发给A1
 一个请求，但是直到A1
 在开始于100ms的时间片1中开始运行时它才得到该消息。它立即发送一个应答，但是直到A0
 在200ms再次运行时它才得到该应答。最终结果是每200ms一个请求-应答序列。这个结果并不好。
这一问题的解决方案是群调度（gang scheduling），它是协同调度（co-scheduling）（Outsterhout，1982）的发展产物。群调度由三个部分组成：
1)把一组相关线程作为一个单位，即一个群（gang），一起调度。
2)一个群中的所有成员在不同的分时CPU上同时运行。
3)群中的所有成员共同开始和结束其时间片。
使群调度正确工作的关键是，同步调度所有的CPU。这意味着把时间划分为离散的时间片，如图8-14中所示。在每一个新的时间片开始时，所有的CPU都重新调度，在每个CPU上都开始一个新的线程。在后续的时间片开始时，另一个调度事件发生。在这之间，没有调度行为。如果某个线程被阻塞，它的CPU保持空闲，直到对应的时间片结束为止。
有关群调度是如何工作的例子在图8-15中给出。图8-15中有一台带6个CPU的多处理机，由5个进程A到E使用，总共有24个就绪线程。在时间槽（time slot）0，线程A0
 至A6
 被调度运行。在时间槽1，调度线程B0
 、B1
 、B2
 、C0
 、C1
 和C2
 被调度运行。在时间槽2，进程D的5个线程以及E0
 运行。剩下的6个线程属于E，在时间槽3中运行。然后周期重复进行，时间槽4与时间槽0一样，以此类推。
图 8-15 群调度
群调度的思想是，让一个进程的所有线程一起运行，这样，如果其中一个线程向另一个线程发送请求，接受方几乎会立即得到消息，并且几乎能够立即应答。在图8-15中，由于进程的所有线程在同一个时间片内一起运行，它们可以在一个时间片内发送和接受大量的消息，从而消除了图8-14中的问题。
8.2 多计算机
多处理机流行和有吸引力的原因是，它们提供了一个简单的通信模型：所有CPU共享一个公用存储器。进程可以向存储器写消息，然后被其他进程读取。可以使用互斥信号量、信号量、管程（monitor）和其他适合的技术实现同步。惟一美中不足的是，大型多处理机构造困难，因而造价高昂。