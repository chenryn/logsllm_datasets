Figure 2: The interlinked blockchain. Each superblock is
drawn taller according to its level. A new block links to all
previous blocks that have not been overshadowed by higher
levels in the meantime.
Selecting the samples. Our sampling will be performed by only
keeping sufficiently high-level superblocks and throwing away blocks
of low levels. We will keep very high levels (so, very few blocks)
near genesis and far back in history. As we get closer to the present,
we will start including more and more samples, and so the thresh-
old in our superblock level will decrease. Near the tip (the most
recent block) of the blockchain, we will eventually get down to
level 0 and keep all blocks.
The samples that we keep will evolve as the blockchain grows. A
sample that was once selected for inclusion may be thrown away
later. However, any sample that is thrown away at some point will
never again be needed in the future. This property, of ensuring
that the sampling is safe and that no samples discarded will be
needed again in the future, is the online property of our protocol.
It will eventually allow us to build a protocol where no full chain
is needed, anywhere.
Our algorithm is parametrized by a security (or, inversely, com-
pression) parameter ğ‘š and the common prefix parameter ğ‘˜ (these
can be unified by conservatively setting ğ‘š = 3ğ‘˜). Given a chain C
that we wish to compress, first, we keep the most recent ğ‘˜ blocks
aside, and let us call them ğœ’. These are unstable and will need to
always be stored. Besides, any miner that wishes to synchronize
with us will need to look at them to arrive at a valid snapshot. For
the next part, we only consider the stable part of the chain. For
our sampling process, we begin by the highest level â„“ that has at
least 2ğ‘š blocks in it. We will include this level in earnest: All â„“-
superblocks will be included in our sampling. For every level below
â„“, we will include at least the 2ğ‘š most recently generated blocks of
that level, but occassionally more. To consider whether to include
0000000221111343Session 12D: Decentralized Cryptographic ProtocolsCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3491more blocks than 2ğ‘š blocks in a level ğœ‡, we look at the ğ‘šth most
recent block ğ‘ in the level ğœ‡ + 1 immediately above. We include all
ğœ‡-superblocks that are more recent than block ğ‘. Let us make this
description more precise by writing it out in pseudocode.
Notation. We will need some notation to describe our chain com-
pression algorithm. Let C denote an interlinked chain of blocks and
C[ğ‘–] denote its ğ‘–th (zero-based) element. We denote by C[ğ‘–:ğ‘—] the
blocks from the ğ‘–th (inclusive) to the ğ‘—ğ‘¡â„ block (exclusive). Omit-
ting ğ‘– means taking the chain from the beginning, and omitting ğ‘—
means taking the chain to the end. For example, C[:128] means
the chain from the beginning up to its 128th element. If ğ‘– and ğ‘—
are replaced by blocks ğ´ and ğ‘, instead of block indices, we write
C{ğ´:ğ‘} to designate the blocks of C from block ğ´ (inclusive) to
block ğ‘ (exclusive), and again any end can be omitted. A negative
ğ‘– or ğ‘— means to take blocks from the end instead of from the begin-
ning, so C[âˆ’1] is the tip. We write ğ´ âˆˆ C to mean that the block
ğ´ is in the chain C, and C1 âŠ† C2 to mean that all of C1â€™s blocks
are in C2. We write Câ†‘ğœ‡ to mean the subsequence of C containing
only its ğœ‡-superblocks (by the above definition, the Câ†‘ operator is
absolute: (Câ†‘ğœ‡)â†‘ğœ‡+ğ‘– = Câ†‘ğœ‡+ğ‘–). Because C is interlinked, Câ†‘ğœ‡ will be
a chain, too (links will exist between consecutive elements). Given
two chains C1 and C2 we write C1 âˆªC2 to denote the chain consist-
ing of all blocks in either, and C1âˆ©C2 to mean the chain consisting
of blocks only in both. Similarly we denote C1 \ C2 the chain con-
sisting of blocks in C1 but not in C2. The blocks must be ordered
chronologically and interlink pointers must be checked to ensure
that the union, intersection, and subtraction of chains is a chain
â€” they will not always be. The chain filtering operators â†‘, [Â·], and
{Â·} have a higher precedence than âˆª,âˆ©,\. We use juxtaposition no-
tation to append one chain to another: C1C2 means the big chain
obtained by taking all the blocks in C1 first and then all the blocks
in C2. For this to be valid, C2[0] must include a pointer to C1[âˆ’1].
We use the similar notation Cğ‘ to mean the block ğ‘ appended to
the end of the chain C to obtain a chain with one more block. Again
ğ‘ must include a pointer to C[âˆ’1].
The compression algorithm. Our chain compression algorithm
Compressğ‘š,ğ‘˜(C) is illustrated in Algorithm 2. It uses the helper
function Dissolveğ‘š,ğ‘˜(C) to obtain the highest level â„“, the unstable
suffix ğœ’ and a set D[ğœ‡] of blocks sampled from the stable part of
the chain at each level ğœ‡ â‰¤ â„“. All of these levels are combined into
a big chain ğœ‹, which is sparse at the beginning and dense towards
the end. The final compressed state consists of ğœ‹, the stable part,
and ğœ’, the unstable part. This big sequence ğœ‹ ğœ’ forms a chain, as
ğœ’[0] points to ğœ‹[âˆ’1]. Let us now examine the inner workings of
Dissolveğ‘š,ğ‘˜(C). This function separates the stable part Câˆ— of the
chain and the unstable part ğœ’. In the trivial case that our stable
chain has no more than 2ğ‘š blocks, all of them are included. Oth-
erwise, the highest level â„“ with at least 2ğ‘š blocks is extracted and
included in earnest. Then, the levels are traversed downwards. For
every level ğœ‡, the last 2ğ‘š blocks are always included. This is cap-
tured by the term Câˆ—â†‘ğœ‡ [âˆ’2ğ‘š:]. Additionally, we look at the ğ‘šth
most recent block ğ‘ from the end at level ğœ‡+1, that is Câˆ—â†‘ğœ‡+1 [âˆ’ğ‘š].
For level ğœ‡, we also include all the blocks succeeding ğ‘, that is
Câˆ—â†‘ğœ‡ {ğ‘:}.
It may not yet be clear why this selection of block headers will
lead to a secure protocol, but let us argue that this sampling is
polylogarithmic in |C|, considering that ğ‘š and ğ‘˜ are constants that
do not grow as the execution progresses.
ğ‘ â† Câˆ—â†‘ğœ‡+1 [âˆ’ğ‘š]
D[ğœ‡] â† Câˆ—â†‘ğœ‡ [âˆ’2ğ‘š:] âˆª Câˆ—â†‘ğœ‡ {ğ‘:}
Câˆ— â† C[: âˆ’ ğ‘˜]
D â† âˆ…
if |Câˆ—| â‰¥ 2ğ‘š then
â„“ â† max{ğœ‡ : |Câˆ—â†‘ğœ‡ | â‰¥ 2ğ‘š}
D[â„“] â† Câˆ—â†‘â„“
for ğœ‡ â† â„“ âˆ’ 1 down to 0 do
Algorithm 2 Chain compression algorithm for transitioning a full
miner to a logspace miner. Given a full chain, it compresses it into
logspace state.
1: function Dissolveğ‘š,ğ‘˜(C)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16: end function
17: function Compressğ‘š,ğ‘˜(C)
18:
19:
return ğœ‹ ğœ’
20:
21: end function
(D, â„“, ğœ’) â† Dissolveğ‘š,ğ‘˜(C)
else
end for
D[0] â† Câˆ—
end if
ğœ’ â† C[âˆ’ğ‘˜:]
return (D, â„“, ğœ’)
ğœ‹ â†âˆªâ„“
ğœ‡=0 D[ğœ‡]
Theorem 3.1 (Succinctness). The construction of Algorithm 2
samples a polylogarithmic number of blocks with respect to the length
of the chain C.
Sketch. Firstly, the number â„“ of levels of interest is Î˜(log |C|).
Next, each level ğœ‡ has either 2ğ‘š blocks or more. 2ğ‘š is a constant, so
this is irrelevant. But the more blocks cannot be many more either:
We are counting the ğœ‡-superblocks following the ğ‘šth most recent
block ğ‘ at the level ğœ‡ + 1 above. How many can these be? They are
indeed about 2ğ‘š. Because suppose for contradiction that they were
many more than 2ğ‘š. But every block of level ğœ‡ has a 1
2 probability
of also being a ğœ‡+1 level block. If there were, say, 4ğ‘š instead of 2ğ‘š
superblocks of level ğœ‡ following block ğ‘, then ğ‘ would not be the
ğ‘šth block from the end, but the 2ğ‘šth one! With high probability
(with foresight, utilizing a Chernoff bound), 4ğ‘š can be taken as an
upper bound. As such, there will be 2ğ‘š log(|C|)+ğ‘˜ blocks sampled
in expectation, and, with high probability, not many more.
â–¡
We make this bound and argument more precise in the Analysis
section.
4 FAST SYNCHRONIZATION
We have seen how a full miner can compress their state into a poly-
logarithmic sample ğœ‹ ğœ’ of blocks. But what is the use of this? We
will now build the other side of the protocol: A node, and future
miner, booting to the network for the first time, but holding only
genesis G. The node is also parametrized by the security parame-
ters ğ‘š and ğ‘˜. This node wishes to learn where to mine.
Session 12D: Decentralized Cryptographic ProtocolsCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3492For now, let us assume that the rest of the network consists of
full miners, and only one node is a light node. The first step of
the neophyte is to determine what the current tip and snapshot are.
The light miner can then start mining on top of that tip, extending
its application data snapshot. It does not need to know the blocks
preceding the tip! Of course, this node will not be helpful towards
bootstrapping yet more nodes, but no matter â€” it can still mine as
if it were a full miner, and just as securely, as long as the tip can be
correctly discerned.
The protocol works as follows. Initially, the newly booting node,
which we call a verifier in this context, connects to multiple full
nodes, which we call the provers. We assume at least one of the
provers is honest (this is a standard assumption in the analysis of
all blockchain protocols [20â€“23, 44]). Each of these full nodes com-
presses their state using Algorithm 2 and sends the compressed
state, or proof Î  = ğœ‹ ğœ’, to the verifier. More concretely, the full
node sends the block headers corresponding to the blocks in ğœ‹
(of size ğ‘ Â· ğ‘ğ‘œğ‘™ğ‘¦ log(ğ‘›)). For the blocks in ğœ’, the full node sends
the whole application snapshot (of size ğ‘) stored in ğœ’[âˆ’ğ‘˜] and the
transactions (of size ğ‘˜ğ›¿) stored in ğœ’. Naturally, the adversary can
send any string as a claimed proof. The verifier checks that Î  forms
a chain, i.e., that all blocks are connected with interlinks and so
they have been produced in the chronological order presented, and
also that the first block in Î  is the genesis block G that it knows. It
then extracts the last ğ‘˜ blocks as ğœ’ and the rest as ğœ‹. It inspects
the application data snapshot from ğœ’[âˆ’ğ‘˜] and ensures that the
transactions in ğœ’ can be cleanly applied. This allows it to obtain
the application state at the end of ğœ‹ ğœ’, which, in honest cases, is
the same as the application snapshot at the end of the underlying
blockchain. If any of these checks fail, the particular connection is
considered compromised and closed.
The verifier receives and verifies a series of such proofs, each
consisting of a stable part ğœ‹ and an unstable part ğœ’, with |ğœ’| = ğ‘˜.
Given multiple such proofs Î 1, Î 2, Â· Â· Â· , Î ğ‘£, the prover begins in-
specting the proofs and comparing one against the other in a pair-
wise fashion. First, Î 1 is compared against Î 2, and one of them
is deemed to be the best (using a mechanism we will soon study).
The process continues until only one of them remains. As long as
at least one proof was honestly generated, our protocol will arrive
at a suffix ğœ’ that is admissible. This means that our light node will
arrive at a snapshot which a full node miner booting for the first
time from genesis could also have arrived at. Upon taking this de-
cision, the light miner stores ğœ‹ ğœ’ in its state.
The light miner can then start mining on top of ğœ’[âˆ’1] to pro-
duce further blocks and to fully verify the validity of incoming
network transactions in its mempool. After all, it is holding onto
an application snapshot. These blocks can be broadcast to the net-
work and will be accepted by the rest of the miners, despite our
light miner not holding the full chain leading from genesis up to
the newly mined block. The light miner can also understand and
verify newly mined blocks of others. It can also deal with chain
reorganizations: In case a reorganization of up to ğ‘˜ blocks occurs,
the light miner holds the whole of ğœ’ and can verify the state transi-
tions completely. As for reorganizations of more than ğ‘˜ blocks long,
these will never occur (except with negligible probability) due to
the Common Prefix property [21].
As this miner is not interested in helping bootstrap others, it
can even throw away ğœ‹ once it has booted up. Furthermore, every
time a new block is mined (either by itself or by someone else), it
can append it to ğœ’ and then truncate ğœ’ to only keep the ğ‘˜ most
recent blocks. However, in the full protocol, described in the next
section, the miner will need to hold on to (and update) ğœ‹ to allow
others to bootstrap.
if Î  is not valid then
return Î â€²
end if
if Î â€² is not valid then
return Î 
end if
(ğœ’, â„“, D) â† Dissolveğ‘š,ğ‘˜(Î )
(ğœ’â€², â„“â€², Dâ€²) â† Dissolveğ‘š,ğ‘˜(Î â€²)
ğ‘€ â† {ğœ‡ âˆˆ N : D[ğœ‡] âˆ© Dâ€²[ğœ‡] â‰  âˆ…}
if ğ‘€ = âˆ… then
Algorithm 3 The state comparison algorithm.
1: function maxvalidğ‘š,ğ‘˜(Î , Î â€²)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
end if