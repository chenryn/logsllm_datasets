4813.028
1.381
0.874
0.644
13.409
Average
Ovh (%) Dev (%)
4.689
9.938
35.952
12.225
4.821
1.940
4.876
1.338
0.107
2.34
0.260
0.607
8.917
8.957
27.255
5.746
6.77
T1 (ms)
4.287
3.054
9960.311
5155.958
1.337
0.863
0.667
13.559
T2 (ms)
4.179
3.003
9815.837
5103.789
1.392
0.879
0.659
13.451
T3 (ms)
4.059
2.845
10146.534
5224.345
1.333
0.887
0.675
13.308
ther, the best known ORAM technique requires a constant private
storage for shufﬂing the data blocks [34]. In case of pigeonhole
attack in SGX, the private storage is not permanently available to
the enclave and the OS can probe operations on private memory
via page faults. Thus, additional hardware support is necessary for
ORAM based randomization to justify the assumption of a secure
constant private storage.
Self-Paging. Instead of relying on the OS for page management,
the enclaved execution can take the responsibility of managing its
memory. Applications can implement self-paging to deal with their
own memory faults using their own physical memory to store page
tables [26]. In self-paging CPU design, all the paging operations
are removed from the kernel; instead the kernel is simply respon-
sible for dispatching fault notiﬁcations. Given a ﬁxed amount of
physical memory, the enclave can decide which virtual addresses
are mapped to this memory, and which are swapped out. The prob-
lem with self-paging is — how can the enclave ensure that the OS
has allocated physical pages to it? To guarantee this, the enclave
should be able to pin certain physical memory pages, such that the
OS cannot swap them out. This directly opens the possibility for
a denial-of-service attack from the enclave, because it can refuse
to give up the pinned pages. A hardware reset would be the only
alternative to reclaim all the enclave pages, which is an undesirable
consequence for the OS. Another possibility is that the enclave per-
forms self-paging without assuming ﬁxed private physical memory.
But this is unsafe, since the OS still controls how much memory
to allocate to the enclave, retaining the ability to pigeonhole the
memory pages. In both the above alternatives, there is a dilemma
— should the enclave trust the OS and likewise. Hence, it is un-
clear how self-paging, with or without ﬁxed physical memory, can
defend against pigeonhole attacks.
8. RELATED WORK
Attacks on Enclaved Execution. Xu et al. have recently shown
that the OS can use the page fault channel on applications running
on SGX based systems to extract sensitive information [51]. The
attacks are limited to general user programs such as image and text
processing. On the contrary we study a cryptographic implemen-
tations which is speciﬁc class of applications more relevant in the
context of enclaves. More importantly, we show that the purported
techniques discussed are not effective against pigeonhole attacks.
As as a new contribution, we propose and measure the effective-
ness of concrete solutions to prevent against such attacks on cryp-
tographic implementations.
Side-channel Attacks. Yarom et al. study cache channel attacks
wherein the adversary has the power to ﬂush and reload the cache,
which can be used to attacks elliptic curve cryptographic routines
such as ECDSA [52]. Timing and cache attacks have been used
to by-pass kernel space ASLR [29], VMs [30], android applica-
tions [31], cloud servers [55] and users [40] both locally and re-
motely [14]. Even web browsers can be exploited remotely via
cache attacks on JavaScript [39].
Side-channel Detection & Defenses. Various detection mecha-
nisms have been explored for side channels ranging from instruc-
tion level analysis to compiler techniques [16, 23, 53]. Tools such
as CacheQuant can automatically quantify the bits of information
leaked via cache side-channels [33]. Techniques such as input
blinding, time bucketing are also available but are limited to spe-
ciﬁc algorithms [32]. Side channel attacks in hypervisors, cloud
VMs, kernel are mitigated using determinising strategies, control-
ﬂow independence and safe scheduling [9, 38, 50, 56]. Our deter-
ministic multiplexing defense is similar to memory-trace oblivious-
ness techniques proposed for secure computation [35].
Randomization & Self-paging Defenses. ORAM techniques are
widely used in secure computation and multi-party computations.
Recent work demonstrate safe language, compiler techniques, and
hypervisor based approaches which use ORAM. As discussed in
Section 7.2, ORAM techniques may be insufﬁcient without extra
hardware support. On the other hand, self-paging assumes that the
enclave will always have control over a ﬁxed size [26]. In case that
either party breaks this assumption, it opens a potential for DOS
from enclave and pigeonholing from the OS.
9. CONCLUSION
We systematically study pigeonhole attack, a new threat preva-
lent in secure execution platforms including Intel SGX, InkTag,
OverShadow and PodArch. By analyzing cryptographic implemen-
tation libraries, we demonstrate the severity of pigeonhole attacks.
We propose a purely software defense called deterministic mul-
tiplexing and build a compiler to make all our case studies safe
against pigeonhole attacks. It is practically deployable with mod-
est overhead. Finally, we present an alternative hardware-based
solution which incurs an average overhead of 6.77%.
10. ACKNOWLEDGMENTS
This research is supported in part by the National Research Foun-
dation, Prime Minister’s Ofﬁce, Singapore under its National Cy-
bersecurity R&D Program (Award No. NRF2014NCR-NCR001-
21) and administered by the National Cybersecurity R&D Direc-
torate. This work is supported in part by a research grant from
Symantec.
11. REFERENCES
[1] Clang: A C language family frontend for LLVM.
http://clang.llvm.org/.
[2] Libgcrypt - GNU Project - Free Software Foundation (FSF).
https://www.gnu.org/software/libgcrypt/.
[3] OpenSSL: The Open Source toolkit for SSL/TLS.
https://www.openssl.org/.
[4] Pin - A Dynamic Binary Instrumentation Tool.
https://software.intel.com/en-us/articles/pin-a-dynamic-binary-
instrumentation-tool.
[5] The GNU Privacy Guard. https://www.gnupg.org/.
[6] The LLVM Compiler Infrastructure. http://llvm.org/.
[7] Software Guard Extensions Programming Reference.
software.intel.com/sites/default/ﬁles/329298-001.pdf, Sept 2013.
[8] Software Guard Extensions Programming Reference Rev. 2.
software.intel.com/sites/default/ﬁles/329298-002.pdf, Oct 2014.
[9] A. Aviram, S. Hu, B. Ford, and R. Gummadi. Determinating Timing
Channels in Compute Clouds. In CCSW, 2010.
[10] A. Baumann, M. Peinado, and G. Hunt. Shielding Applications from
an Untrusted Cloud with Haven. In OSDI, 2014.
[11] D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and B. Yang.
High-speed high-security signatures. J. Cryptographic Engineering,
2(2):77–89, 2012.
[12] A. Bogdanov, D. Khovratovich, and C. Rechberger. Biclique
Cryptanalysis of the Full AES. ASIACRYPT, 2011.
[13] D. Bovet and M. Cesati. Understanding The Linux Kernel. Oreilly &
Associates Inc, 2005.
[14] D. Brumley and D. Boneh. Remote Timing Attacks are Practical. In
USENIX Security, 2003.
[15] E. Budianto, Y. Jia, X. Dong, P. Saxena, and Z. Liang. You Can’t Be
Me: Enabling Trusted Paths and User Sub-origins in Web Browsers.
RAID ’14.
[16] R. Callan, A. Zajic, and M. Prvulovic. A Practical Methodology for
Measuring the Side-Channel Signal Available to the Attacker for
Instruction-Level Events. In MICRO, 2014.
[17] S. Checkoway and H. Shacham. Iago attacks: Why the System Call
API is a Bad Untrusted RPC Interface. In ASPLOS, 2013.
[18] X. Chen, T. Garﬁnkel, E. C. Lewis, P. Subrahmanyam, C. A.
Waldspurger, D. Boneh, J. Dwoskin, and D. R. Ports. Overshadow: A
Virtualization-Based Approach to Retroﬁtting Protection in
Commodity Operating Systems. In ASPLOS, 2008.
[19] J. V. Cleemput, B. Coppens, and B. De Sutter. Compiler Mitigations
for Time Attacks on Modern x86 Processors. ACM Trans. Archit.
Code Optim., 2012.
[20] B. Coppens, I. Verbauwhede, K. De Bosschere, and B. De Sutter.
Practical Mitigations for Timing-Based Side-Channel Attacks on
Modern x86 Processors. In IEEE S&P, 2009.
[21] A. Dinh, P. Saxena, E. chien Chang, C. Zhang, and B. C. Ooi. M2R:
Enabling Stronger Privacy in MapReduce Computation. In USENIX
Security, 2015.
[22] X. Dong, Z. Chen, H. Siadati, S. Tople, P. Saxena, and Z. Liang.
Protecting Sensitive Web Content from Client-side Vulnerabilities
with CRYPTONS. CCS ’13.
[23] G. Doychev, D. Feld, B. Köpf, L. Mauborgne, and J. Reineke.
CacheAudit: A Tool for the Static Analysis of Cache Side Channels.
In USENIX Security, 2013.
[24] J. Geffner. VENOM Vulnerability, May 2015.
[25] O. Goldreich and R. Ostrovsky. Software Protection and Simulation
on Oblivious RAMs. Journal of the ACM (JACM), 1996.
[26] S. M. Hand. Self-paging in the Nemesis Operating System. In OSDI,
pages 73–86, 1999.
[27] M. Hoekstra, R. Lal, P. Pappachan, V. Phegade, and J. Del Cuvillo.
Using Innovative Instructions to Create Trustworthy Software
Solutions. In HASP, 2013.
[28] O. S. Hofmann, S. Kim, A. M. Dunn, M. Z. Lee, and E. Witchel.
InkTag: Secure Applications on an Untrusted Operating System.
ASPLOS, 2013.
[29] R. Hund, C. Willems, and T. Holz. Practical Timing Side Channel
Attacks Against Kernel Space ASLR. In IEEE S&P, 2013.
[30] G. Irazoqui, M. Inci, T. Eisenbarth, and B. Sunar. Wait a Minute! A
fast, Cross-VM Attack on AES. In Research in Attacks, Intrusions
and Defenses, LNCS, Springer. 2014.
[31] S. Jana and V. Shmatikov. Memento: Learning Secrets from Process
Footprints. In IEEE S&P, May 2012.
[32] B. Köpf and M. Dürmuth. A Provably Secure and Efﬁcient
Countermeasure Against Timing Attacks. In CSF, 2009.
[33] B. Köpf, L. Mauborgne, and M. Ochoa. Automatic Quantiﬁcation of
Cache Side-channels. In CAV, 2012.
[34] E. Kushilevitz, S. Lu, and R. Ostrovsky. On the (in)Security of
Hash-based Oblivious RAM and a New Balancing Scheme. In
SODA, 2012.
[35] C. Liu, M. Hicks, and E. Shi. Memory Trace Oblivious Program
Execution. In CSF, 2013.
[36] J. M. McCune, B. J. Parno, A. Perrig, M. K. Reiter, and H. Isozaki.
Flicker: An Execution Infrastructure for TCB Minimization. SIGOPS
Oper. Syst. Rev., 2008.
[37] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shaﬁ,
V. Shanbhogue, and U. R. Savagaonkar. Innovative Instructions and
Software Model for Isolated Execution. In HASP, 2013.
[38] D. Molnar, M. Piotrowski, D. Schultz, and D. Wagner. The Program
Counter Security Model: Automatic Detection and Removal of
Control-ﬂow Side Channel Attacks. In ICISC, 2006.
[39] Y. Oren, V. P. Kemerlis, S. Sethumadhavan, and A. D. Keromytis.
The Spy in the Sandbox - Practical Cache Attacks in Javascript.
CoRR, 2015.
[40] T. Ristenpart, E. Tromer, H. Shacham, and S. Savage. Hey, You, Get
off of My Cloud: Exploring Information Leakage in Third-party
Compute Clouds. In CCS, 2009.
[41] F. Schuster, M. Costa, C. Fournet, C. Gkantsidis, M. Peinado,
G. Mainar-Ruiz, and M. Russinovich. VC3: Trustworthy Data
Analytics in the Cloud. In IEEE S&P, 2015.
[42] E. Shi, T.-H. H. Chan, E. Stefanov, and M. Li. Oblivious RAM with
O ((logN) 3) worst-case cost. In Advances in
Cryptology–ASIACRYPT 2011, pages 197–214. Springer, 2011.
[43] S. Shinde, Z. L. Chua, V. Narayanan, and P. Saxena. Preventing Your
Faults from Telling Your Secrets: Defenses against Pigeonhole
Attacks. CoRR, abs/1506.04832, 2015.
[44] S. Shinde, S. Tople, D. Kathayat, and P. Saxena. PodArch: Protecting
Legacy Applications with a Purely Hardware TCB. Technical report.
[45] G. Smith. On the Foundations of Quantitative Information Flow. In
FOSSACS, 2009.
[46] E. Stefanov, M. van Dijk, E. Shi, C. Fletcher, L. Ren, X. Yu, and
S. Devadas. Path ORAM: An Extremely Simple Oblivious RAM
Protocol. In CCS, 2013.
[47] D. L. C. Thekkath, M. Mitchell, P. Lincoln, D. Boneh, J. Mitchell,
and M. Horowitz. Architectural Support for Copy and Tamper
Resistant Software. In ASPLOS, 2000.
[48] S. Tople and P. Saxena. On the Trade-Offs in Oblivious Execution
Techniques. Technical report.
[49] S. Tople, S. Shinde, Z. Chen, and P. Saxena. AUTOCRYPT: Enabling
Homomorphic Computation on Servers to Protect Sensitive Web
Content. CCS ’13.
[50] V. Varadarajan, T. Ristenpart, and M. Swift. Scheduler-based
Defenses Against cross-VM Side-channels. In USENIX Security,
2014.
[51] Y. Xu, W. Cui, and M. Peinado. Controlled-Channel Attacks:
Deterministic Side Channels for Untrusted Operating Systems. In
IEEE S&P, 2015.
[52] Y. Yarom and N. Benger. Recovering OpenSSL ECDSA Nonces
Using the FLUSH+RELOAD Cache Side-channel Attack. IACR
Cryptology ePrint Archive, 2014.
[53] D. Zhang, A. Askarov, and A. C. Myers. Language-based Control
and Mitigation of Timing Channels. In PLDI, 2012.
[54] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. Cross-VM Side
Channels and Their Use to Extract Private Keys. In CCS, 2012.
[55] Y. Zhang, A. Juels, M. K. R. Reiter, and T. Ristenpart. Cross-Tenant
Side-Channel Attacks in PaaS Clouds. In CCS, 2014.
[56] Y. Zhang and M. K. Reiter. Duppel: Retroﬁtting Commodity
Operating Systems to Mitigate Cache Side Channels in the Cloud. In
CCS, 2013.