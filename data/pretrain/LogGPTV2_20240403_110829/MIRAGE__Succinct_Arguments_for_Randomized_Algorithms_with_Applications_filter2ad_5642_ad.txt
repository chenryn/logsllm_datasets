â€¢ The veriï¬er parses Ï€ as [Ï€(cid:48) Ï€J], computes r = hash(x||Ï€J)
and runs {0,1} â† Verify(vrkL ,x||r,Ï€).
As in Section 3.1, if r is of size only polylogarithmic in
|w| (and polynomial in |x| and security parameter Î»), then the
resulting protocol is a succinct non-interactive argument. The
proverâ€™s runtime is asymptotically the same as that of Grothâ€™s
protocol ËœO(|L|).
4 A Universal Circuit Protocol
SNARKs
for
zk-
In this section, we adapt the protocol described above in the
context of universal circuits. We will use a simpliï¬ed ver-
sion of our universal circuit to make the representation less
involved. (Section 5 presents the circuit design in detail).
The goal is to deï¬ne a simple universal language Luniv that
captures the operations of any circuit C that has at most nâˆ—
multiplications and n+ additions, and its statement size is
bounded by ns. We use the following notation: Let li and l(cid:48)
i
refer to an index (label) of a variable in our construction. Let
zi and z(cid:48)
i refer to the values of the variables with indices li
and l(cid:48)
i respectively. An entry is a pair of label and value, e.g.,
(li,zi). Let spec be a vector that speciï¬es the functionality of
a custom circuit C, i.e., specC = (l1,l2, . . . ,lns+3nâˆ—+3n+). The
ï¬rst ns elements will correspond to the labels of the statement
variables, then the following 3nâˆ— and 3n+ elements will be
the labels of the variables used in multiplication and addition
constraints, respectively. Let stmt be a vector that includes the
values of the statement variables, i.e., stmt = (z1,z2, . . . ,zns ).
(Figure 1 illustrates an example)
Deï¬ne the language Luniv as follows: An instance
(specC,stmt) âˆˆ Luniv if and only if stmt is a satisfying as-
signment for the speciï¬cation of C, i.e.,
â€¢ There exists a vector (zns+1,zns+2, . . . ,zns+3nâˆ—+3n+) such
that zi+2 = zi Ã— zi+1 for all i âˆˆ {ns + 1, . . . ,ns + 3nâˆ— âˆ’ 2},
and zi+2 = zi +zi+1 for all i âˆˆ {ns +3nâˆ— +1, . . . ,ns +3nâˆ— +
3n+ âˆ’ 2}.
i) entries where i âˆˆ
â€¢ There exists a vector of (l(cid:48)
i,z(cid:48)
{1, . . . ,ns + 3nâˆ— + 3n+}, such that
â€“ It
permutation
entries
the
of
is
a
{(li,zi)}iâˆˆ{1,...,ns+3nâˆ—+3n+}.
i = l(cid:48)
i â‰¤ l(cid:48)
l(cid:48)
i+1, then z(cid:48)
i+1, and if l(cid:48)
i must be equal to z(cid:48)
â€“ (Consistency) For all i âˆˆ {1, . . . ,ns + 3nâˆ— + 3n+ âˆ’ 1},
i+1.
To check membership in Luniv, a randomized veriï¬er ap-
plies all the correctness and consistency constraints above,
and checks the permutation constraint as follows. Given two
uniformly selected random values r1 and r2 from Fq, the fol-
lowing must hold:
i=1
i=1
((l(cid:48)
i,z(cid:48)
i + r2z(cid:48)
i)âˆ’ r1)
ns+3nâˆ—+3n+âˆ
((li + r2zi)âˆ’ r1) =
ns+3nâˆ—+3n+âˆ
To show that Luniv âˆˆ MA 2, we argue about the complexity
of the veriï¬er and the probability of failure. Let Cuniv be a
circuit that encodes the veriï¬cation logic above. Note that the
size of the circuit will be linear in the size of the speciï¬cation.
A prover would send the circuit Cuniv to the veriï¬er along
with the values of all ziâ€™s and (l(cid:48)
i) entries. The veriï¬er can
then run the circuit given the proverâ€™s input, the speciï¬cation
specC, and two independently generated random values r1,r2.
Itâ€™s easy to observe that the veriï¬er runs in a polynomial time.
Completeness. If (specC,stmt) âˆˆ Luniv, i.e., the prover is hon-
est, it is easy to see that veriï¬cation will always succeed with
probability 1.
Soundness. If (specC,stmt) /âˆˆ Luniv, i.e., the prover is dishon-
est, to calculate the probability of successful veriï¬cation, we
can compute an upper bound based on the probability of the
following two events:
â€¢ The prover could cheat if for any i âˆˆ {1,2, . . . ,ns + 3nâˆ— +
3n+} and j âˆˆ {1,2, . . . ,ns +3nâˆ— +3n+}, the random value
r2 was equal to the root of the polynomial pi j(x) = li âˆ’
j + x(zi âˆ’ z(cid:48)
l(cid:48)
j. Let p1 denote
the probability of this event. It can be shown that p1 â‰¤
(ns+3nâˆ—+3n+)2
when zi (cid:54)= z(cid:48)
j), i.e., r2 =
l(cid:48)
jâˆ’li
ziâˆ’z(cid:48)
j
|Fq|
.
.
i=1
i=1
|Fq|
|Fq|
((l(cid:48)
i +r2z(cid:48)
â€¢ The prover could cheat if the random value r1 is a root
((li + r2zi)âˆ’ x)âˆ’
of the polynomial p(x) = âˆns+3nâˆ—+3n+
i)âˆ’x). Let p2 denote the probability
âˆns+3nâˆ—+3n+
of this event. Using the Schwartz-Zippel Lemma, it can
be shown that p2 â‰¤ ns+3nâˆ—+3n+
shown that pcheating â‰¤ p1 + p2,
Let pcheating be the total cheating probability.
It can
i.e., pcheating â‰¤
be
In our implementation, |Fq|
(ns+3nâˆ—+3n+)2+(ns+3nâˆ—+3n+)
is nearly 2254. For a cheating probability of 2âˆ’128,
(ns + 3nâˆ— + 3n+) has to exceed 260 which is way beyond
practical circuit sizes.
This shows that Luniv âˆˆ MA. Now we can apply our ef-
ï¬cient zk-SNARK for MA to verify membership in Luniv,
i.e., verify that the circuit Cuniv is satisï¬ed given a speciï¬ca-
tion and a statement. This to minimize the veriï¬erâ€™s effort
and enable zero-knowledge (hiding the values of intermediate
2We could also show that Luniv âˆˆ MA by showing that Luniv âˆˆ NP via
.
a quasi-linear deterministic veriï¬cation procedure.
2136    29th USENIX Security Symposium
USENIX Association
Figure 1: An example of a simple universal circuit and a speciï¬cation of a custom circuit. # indicates a variable label. Unused
entries are zeroed.
witnesses values). Appendix A illustrates how to apply our
Protocol 2 for Cuniv in detail. The following points highlight
few details about the mapping and the differences:
â€¢ The statement of Cuniv
is changed to also include
{l(cid:48)
i}iâˆˆ{1,...,ns+3n++3nâˆ—} besides {li}iâˆˆ{1,...,ns+3n++3nâˆ—} and
i} are known during the
{zi}iâˆˆ{1,...,ns}, as the values of {l(cid:48)
speciï¬cation of the custom circuit.
â€¢ The set J in Protocol 2 will include the set of indices cor-
responding to the wires carrying the witness values of
{zi}iâˆˆ{ns,...,ns+3n++3nâˆ—}, {z(cid:48)
i}iâˆˆ{1,...,ns+3n++3nâˆ—}. Note that the
prover will commit to both the values corresponding to the
set J and the statement, which includes {zi}iâˆˆ{1,...,ns}.
â€¢ To minimize the veriï¬erâ€™s effort, we introduce an untrusted
derive phase for computing the encoding of {li} and {l(cid:48)
i}
(or the circuit speciï¬cation in the general case). This hap-
pens only once per a custom new circuit, and can be both
computed and veriï¬ed in linear time. The encoding of the
speciï¬cation is just one group element (32 bytes) in our
setting (See vkspec in Appendix A).
â€¢ Finally, for efï¬ciency purposes, when computing the hash
of the statement and the witness commitment, instead of
computing Hash(x||Ï€ j) directly as described in Section 3,
we use the encoding of the statement x that is computed
during the zk-SNARK veriï¬cation algorithm.
5 Universal Circuit Design
In this section, we describe the approaches we investigated for
designing the universal circuit. In the rest of the discussion,
we use the term opcode to denote the type of an instruction or
operation. The cost of any component is measured in terms
of the number of constraints (multiplication gates) needed
to implement or verify its logic in the circuit. Note that the
cost of verifying a single instruction equals the cost of veri-
fying the operation itself (based on the logic corresponding
to the opcode) plus the cost of verifying the consistency of
the values of its entries with respect to the rest of the circuit
(the permutation and consistency check logic). For example,
for a multiplication or addition instruction as deï¬ned before,
the cost of verifying operation correctness is one constraint,
while the cost of verifying the consistency of the values of
the entries equals 15 constraints (5 per entry).
5.1 Single-opcode version
The circuit design we considered in the previous sections
included only two types of operations: addition and multi-
plication operations. This version can be slightly modiï¬ed
to be only a single-opcode circuit, with an additional binary
input with each instruction to choose which operation should
be activated (this additional input will belong to the specC
vector, and will be set during derivation). This will only add
one more constraint to the instruction cost, while enabling
more ï¬‚exible ranges of addition or multiplication operations.
Additionally, to avoid the cost of multiplying or adding con-
stants, this opcode can also be extended using additional input
that are speciï¬ed during the derivation.
More concretely, the specC vector will also include ad-
ditional values b j, c j,1,c j,2,c j,3,c j,4, for each instruction j
besides the labels of the variables li,li+1,li+2. For each in-
struction j, the circuit applies the following logic,
â€¢ If b j = 1, verify that zi+2 = (c j,1 + c j,2zi)(c j,3 + c j,4zi+1).
â€¢ If b j = 0, verify that zi+2 = c j,1 + c j,2zi + c j,3 + c j,4zi+1.
We call the additional variables b j, c j,1,c j,2,c j,3,c j,4 func-
tionality selectors. Note that they will also be set at the time
of specifying the computation like li and l(cid:48)
i.
Although the single-opcode circuit can represent any set
of arithmetic constraints, it would result into high overhead
when representing different kinds of basic operations:
1) Cost of intermediate variables. In many circuits/pro-
grams, intermediate variables are used only once. Using the
naive single-opcode version described earlier to compute
USENIX Association
29th USENIX Security Symposium    2137
+xx+#1#2Statement Entries (ğ‘›ğ‘ =6):1.(ğ‘™1,ğ‘§1)2.(ğ‘™2,ğ‘§2)3.(ğ‘™3,ğ‘§3)Multiplication Entries (ğ‘›âˆ—=3):1. ((ğ‘™7,ğ‘§7),(ğ‘™8,ğ‘§8),(ğ‘™9,ğ‘§9))2. ((ğ‘™10,ğ‘§10),(ğ‘™11,ğ‘§11),(ğ‘™12,ğ‘§12))3. ((ğ‘™13,ğ‘§13),(ğ‘™14,ğ‘§14),(ğ‘™15,ğ‘§15))Addition Entries (ğ‘›+=3):1. ((ğ‘™16,ğ‘§16),(ğ‘™17,ğ‘§17),(ğ‘™18,ğ‘§18))2.((ğ‘™19,ğ‘§19),(ğ‘™20,ğ‘§20),(ğ‘™21,ğ‘§21))3. ((ğ‘™22,ğ‘§22),(ğ‘™23,ğ‘§23),(ğ‘™24,ğ‘§24))Permuted Entries:(ğ‘™1â€²,ğ‘§1â€²), (ğ‘™2â€²,ğ‘§2â€²), â€¦ , (ğ‘™24â€²,ğ‘§24â€²)A Simple Universal Circuit4.(ğ‘™4,ğ‘§4)5.(ğ‘™5,ğ‘§5)6.(ğ‘™6,ğ‘§6)#3#4#5#6#7#8Custom Computation SpecificationMultiplication Labels:ğ‘™7=3,ğ‘™8=4,ğ‘™9=6ğ‘™10=5,ğ‘™11=6,ğ‘™12=7ğ‘™13=ğ‘™14=ğ‘™15= 0Statement Labels:ğ‘™1=1ğ‘™2=2ğ‘™3=3ğ‘™4=4ğ‘™5=8ğ‘™6=0Addition Labels:ğ‘™16=1,ğ‘™17=2,ğ‘™18=5ğ‘™19=7,ğ‘™20=4,ğ‘™21=8ğ‘™22=ğ‘™23=ğ‘™24= 0Permuted Labels:ğ’â€²=(0,0,0,0,0,0,0,1,1,2,2,3,3,4,4,4,5,5,6,6,7,7,8,8)A Sample Valid AssignmentMultiplication Values:ğ‘§7=10,ğ‘§8=2,ğ‘§9=20ğ‘§10=9,ğ‘§11=20,ğ‘§12=180ğ‘§13=ğ‘§14=ğ‘§15= 0Statement Values:ğ‘§1=5ğ‘§2=4ğ‘§3=10ğ‘§4=2ğ‘§5=182ğ‘§6=0Addition Values:ğ‘§16=5,ğ‘§17=4,ğ‘§18=9ğ‘§19=180,ğ‘§20=2,ğ‘§21=182ğ‘§22=ğ‘§23=ğ‘§24= 0Permuted Values:ğ’›â€²=(0,0,0,0,0,0,0,5,5,4,4,10,10,2,2,2,9,9,20,20,180,180,182,182)MULPermutation and Consistency Check(ğ‘™1â€²,ğ‘§1â€²)(ğ‘™24â€²,ğ‘§24â€²)...........(ğ‘™1,ğ‘§1)(ğ‘™6,ğ‘§6)..(ğ‘™7,ğ‘§7)..........(ğ‘™24,ğ‘§24)MULMULADDADDADDa sum or product of n variables, or compute a dot product
of two n-dimensional vectors for example will lead to re-
peated entries of intermediate variables (See l9 and l11 in
Figure 1 for an example). We will reduce the overhead of
this by enabling instructions to consider the output of the
previous operation that is speciï¬ed in the circuit as an addi-
tional operand. For example, to compute a dot product of two
n-elements vectors, nearly n instructions will be consumed
instead of 2n instructions. Instead of specifying a computa-
tion c = a1b1 + a2b2 + a3b3, as a1b1 = t1,a2b2 = t2,a3b3 =
t3,t1 +t2 = d1,d1 +t3 = c, we enable expressions to option-
ally include the last operand from the previous operation if
needed a1b1 = t1,a2b2 +t1 = t2,a3b3 +t2 = c (See opcode 1
in the next subsection).
2) Bit operations and binary constraints. In many zk-
SNARK circuits in practice, unpacking or splitting a variable
into bits is a necessary operation. Itâ€™s used for range checking,
comparisons, division/mod operations, bitwise operations, ex-
ponentiations and others. For example, verifying a bitwise
XOR operation would involve decomposing or splitting val-
ues into bits. For a variable x, this would require checking
equations of the form bibi = bi and checking x = âˆ‘2ibi in
the universal circuit, which will consume several instructions
and several variable entries for each single bit, therefore using
the single-opcode version described earlier will lead to a high
ampliï¬cation factor for such frequent checks. Instead, we
combine all similar bit operations within other opcodes (See
opcodes 2 and 3). Opcode 2 does not introduce entries for
bits, and handles bit operations and checks within its circuit.
Opcode 3 avoids the repeated entries for bit constraints, and
is for explicit extraction of bits in the universal circuit.
3) Using randomness. As our approach enables the usage
of random values in the circuit, these random values could be
used to verify other functionalities that are cheaper to verify
using a randomized check. In our circuit, we utilized this for
implementing the veriï¬cation of read/write memory accesses
when the indices are not known during the speciï¬cation time
(See opcode 4 in the next subsection).
5.2 Multi-opcode version
When designing a multi-opcode circuit, there is a trade-off
between the circuit utilization and the efï¬ciency of individual
basic operations. Adding an opcode per every possible basic
function will lead to many unused constraints if the program
being evaluated has a skewed opcode distribution. On the
other hand, using a single opcode version will guarantee high
utilization, but will be less effective in practice. Finding the
optimal point is a problem of independent interest, as it will
require careful workload characterization (See Section 7),
depending on the application set being considered.
In our design, we used the following criteria: 1) We add
a new opcode whenever any of the basic operations is sig-
niï¬cantly ampliï¬ed using the already available opcodes. By
basic operations, we mean the common operators provided by
high-level programming languages. This includes arithmetic
operations, bitwise operations (e.g., bitwise xor, shift, rotate,
.. etc), bit extraction, integer comparison, load and write oper-
ations to random memory locations, .. etc. If a certain basic
operation can be represented using few constant number of
calls to existing opcodes, we do not add a new opcode for that
operation. 2) We combine similar basic operations together
in one opcode when they share computation, or if they have
additional small overhead. For example, instead of having sep-
arate opcodes for basic bitwise operations like bitwise-and,
bitwise-xor and bitwise-or as in previous work, we observe
that these computations can share many of their intermediate
computations using a minimized circuit, and therefore, we
use only one opcode for them.
Figures 2 and 3 in Appendix B illustrate our design of
the multi-opcode circuit. In the following list, we provide a
high-level description for each opcode. Further details about
the functionality that can be veriï¬ed by each opcode can be
found in Table 6 in Appendix B.
â€¢ Opcode 1: This is an enhanced version of the basic opcode
in the single-opcode circuit. It aims to combine addition,
multiplication constraints, individual bit operations (OR,
AND, XOR), and equality testing. It can also include the
result from the previous opcode instruction as an additional
operand to reduce the cost of intermediate operations. Using
a minimized circuit, our opcode 1 circuit would cost 26
constraints (11 constraints for verifying the operation, and
15 constraints for the consistency of entry values).
â€¢ Opcode 2 (Integer Bitwise Operations): Using opcode 1