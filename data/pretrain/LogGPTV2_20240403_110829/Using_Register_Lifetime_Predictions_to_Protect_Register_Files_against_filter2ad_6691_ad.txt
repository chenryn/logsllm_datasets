0.2
0
Ultrashort
Short
Dead
Long
100
80
60
40
20
0
)
%
(
s
n
o
s
r
e
V
i
r
e
t
s
g
e
R
i
2
p
z
b
i
y
t
f
a
r
c
p
a
g
i
p
z
g
f
c
m
r
e
s
r
a
p
k
m
b
l
r
e
p
f
l
o
w
t
r
p
v
x
e
t
r
o
v
g
v
A
n
t
I
0
.
t
r
a
a
s
e
m
d
i
r
g
m
i
m
w
s
e
k
a
u
q
e
g
v
A
P
F
i
e
s
w
p
u
w
2
p
z
b
i
y
t
f
a
r
c
p
a
g
i
p
z
g
f
c
m
r
e
s
r
a
p
k
m
b
l
r
e
p
f
l
o
w
t
r
p
v
x
e
t
r
o
v
g
v
A
n
t
I
Figure 13. Impact of the number of ECC table ports
on the IPC.
Figure 15. Breakdown of the types of register ver-
sions predicted.
(6R,4W)
(3R,3W)
(2R,3W)
(1R,3W)
3
2.5
2
1.5
1
0.5
0
F
V
A
d
e
z
i
l
a
m
r
o
N
2
p
z
b
i
y
t
f
a
r
c
p
a
g
i
p
z
g
f
c
m
r
e
s
r
a
p
k
m
b
l
r
e
p
f
l
o
w
t
r
p
v
x
e
t
r
o
v
g .
v
A
n
t
I
t
r
a
a
s
e
m
d
i
r
g
m
i
m
w
s
e
k
a
u
q
e
g
v
A
P
F
i
e
s
w
p
u
w
Figure 14. Impact of the number of ECC table ports
on the integer register ﬁle AVF.
use 15.7% and 17.6% more area than FullECC, respec-
tively. This area increase is tolerable, given the power sav-
ings provided.
6.3. Sensitivity Analysis
To gain insight into the operation of Shield, we examine
the impact of the number of read and write ports in the ECC
table. Figures 13 and 14 show the IPC (Instructions Per
Cycle) and the integer register ﬁle AVF, respectively, when
we use x read ports and y write ports (xR, yW) in the ECC
table. For each application, the bars are normalized to the
(6R, 4W) conﬁguration.
Figure 13 shows that, as we go from (6R, 4W) — the
same number of ports and type as in the integer register
ﬁle — to (3R, 3W) — our design choice — the IPCs re-
main constant. This is because Shield performs the ECC
generation and checks off the critical path, queues requests
when necessary, and leverages the slack given by the ROB.
However, when we further reduce the number of read ports,
performance suffers. With (2R, 3W), the average IPC de-
creases by 6.9% for SPECint and by 4.2% for SPECfp.
With (1R, 3W), there is a 50% performance penalty because
now the ECC table becomes a major bottleneck.
Figure 14 shows the impact on the AVF of the integer
register ﬁle. With our design choice (3R, 3W), the AVF
changes negligibly over (6R, 4W). With (2R, 3W) and (1R,
3W), however, the AVF increases noticeably.
Overall, from this section and the previous one, we see
that the (3R, 3W) design corresponds to a good tradeoff be-
tween performance, AVF, and power.
6.4. Register Lifespan Prediction
Finally, we examine the accuracy of the register lifespan
predictor used in Shield (OptEffective). Figure 15 shows
Ultrashort
Short
Long
100
80
60
40
20
0
)
%
(
s
n
o
s
r
e
V
i
r
e
t
s
g
e
R
i
0
10
20
30
40
50
60
70
80
Useful lifespan (cycles) 
Figure 16. Cumulative distribution of useful lifes-
pan for Ultrashort, Short, and Long registers.
the fraction of integer register versions that OptEffective
predicts of each type. We can see that, on average, it pre-
dicts over 60% as Ultrashort and only 10% as Long. Fig-
ure 16 shows the cumulative distribution of the useful lifes-
pan for the register versions predicted as Ultrashort, Short,
and Long. From the ﬁgure, we see that OptEffective cor-
rectly separates the three types of registers. Indeed, most
register versions predicted as Long have over 30 cycles of
useful lifespan, while 95% of the register versions predicted
as Ultrashort have less than 10 cycles of useful lifespan.
However, OptEffective does not possess oracle knowl-
edge. Figure 17 compares Shield’s AVF using OptEffec-
tive and an oracle algorithm (Oracle) for register lifespan
prediction. For completeness, it also shows the AVF with
Ponomarev et al.’s predictor (Section 3.2.1). The ﬁgure
shows that, on average, OptEffective is very close to Ora-
cle. The remaining AVF largely results from the fact that,
for some parts of the applications, there are more registers
in Useful state than entries in the ECC table.
7. Related Work
Fully protected register ﬁles. Traditional fault-tolerant
designs protect the entire register ﬁle with parity or ECC.
The IBM S/390 G5 [18] uses duplicated,
lockstepped
pipelines to ensure that only correct data updates the ECC-
protected structure that stores the architectural state of the
processor. The ERC32 [3] is a SPARC processor with
parity-protected registers and buses that also performs pro-
gram control ﬂow, which imposes extra overhead. Like the
ERC32, the Intel Montecito [9] also utilizes parity to pro-
tect the whole register ﬁle. Both the ERC32 and the Intel
Montecito require software intervention to recover when a
fault is detected. Our ParShield design uses parity to de-
tect all single-bit errors, and the Shield concept to recover
from most single-bit errors — by selectively protecting the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:33:39 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007Ponomarev
Shield
Oracle
F
V
A
0.2
0.16
0.12
0.08
0.04
0
2
p
z
b
i
y
t
f
a
r
c
p
a
g
i
p
z
g
f
c
m
r
e
s
r
a
p
k
m
b
l
r
e
p
f
l
o
w
t
r
p
v
x
e
t
r
o
v
g
v
A
n
t
I
Figure 17. Comparing the AVF for different register
lifespan prediction algorithms.
register versions that contribute the most to the overall vul-
nerability of the register ﬁle. Processor performance is not
affected. The result is a design with a very cost-effective
tradeoff between DUE AVF and power.
Partially protected register ﬁles. Memik et al. [10]
proposed the duplication of actively-used physical registers
in unused register locations. While their approach can en-
hance reliability with minimal performance degradation, it
can only detect errors, but not recover from them. Yan et
al. [22] proposed using the compiler to assign the most
vulnerable variables to a set of ECC-protected registers.
ParShield does not need to re-compile the programs because
it offers a hardware-only solution.
Register lifetime analysis. Lozano and Gao [7] used
the compiler to identify short-lived variables and prevented
their values from going to the register ﬁle, thus reducing
register pressure. Sangireddy and Somani [15] reduced the
access time to the register ﬁle by exploiting useless peri-
ods in the register lifetime. Ponomarev et al. [12] used a
small dedicated register ﬁle to cache short-lived operands
to reduce the energy consumption in the ROB and the ar-
chitectural register ﬁle. ParShield differs from all these pro-
posals in that it proposes a hardware scheme to distinguish
between ultrashort-, short- and long-lived operands, and ex-
ploits the difference to enhance the register ﬁle reliability.
8. Conclusions
Register ﬁles are vulnerable to soft errors because they
are large and contain architectural state. Registers often
store data for long periods of time and are read frequently,
which increases the probability of spreading a faulty datum.
A cost-effective protection mechanism for soft errors in reg-
ister ﬁles should have no performance impact, keep the re-
maining AVF to a small value, consume modest power, and
use little area.
In this paper, we have proposed one such mechanism,
namely the ParShield design. ParShield relies on the Shield
concept, which selectively protects a subset of the regis-
ters by generating, storing, and checking the ECCs of only
the most vulnerable registers while they have useful data.
Shield reduces the AVF of the integer register ﬁle by an av-
erage of 73% to 0.040, and the AVF of the ﬂoating-point
register ﬁle by an average of 85% to 0.010. ParShield ex-
tends Shield with a parity bit for all the registers and the
re-use of the ECC circuitry for parity generation and check-
ing as well. As a result, ParShield has no SDC AVF (all
single-bit errors are detected), has a DUE AVF as low as
Shield’s AVF, and consumes on average only 81% and 78%
of the power of a design with full ECC for the SPECint and
SPECfp applications, respectively. Moreover, ParShield has
no performance impact and little area requirements.
References
[1] A. Biswas et al. Computing architectural vulnerability fac-
In International Sympo-
tors for address-based structures.
sium on Computer Architecture, June 2005.
[2] E. Czeck and D. Siewiorek. Effects of transient gate-level
faults on program behavior. In International Symposium on
Fault-Tolerant Computing, June 1990.
[3] J. Gaisler. Evaluation of a 32-bit microprocessor with built-
In International Symposium
in concurrent error-detection.
on Fault-Tolerant Computing, 1997.
[4] G. Hinton et al. The microarchitecture of the Pentium 4 pro-
cessor. Intel Technology Journal, 2001.
[5] Hspice User’s Manual. Applications and examples, 1996.
[6] S. Kim and A. K. Somani. Area efﬁcient architectures for
In International
information integrity in cache memories.
Symposium on Computer Architecture, 1999.
[7] L. A. Lozano and G. R. Gao. Exploiting short-lived variables
In International Symposium on
in superscalar processors.
Microarchitecture, 1995.
[8] W. MacKee et al. Cosmic ray neutron induced upsets as a
major contributor to the soft error rate of current and future
generation DRAMs. 1996 IEEE Annual International Reli-
ability Physics, 1996.
[9] C. McNairy and R. Bhatia. Montecito: A dual-core, dual-
thread Itanium processor. IEEE Micro, 2005.
[10] G. Memik et al. Increasing register ﬁle immunity to transient
errors. In Design, Automation and Test in Europe, 2005.
[11] S. Mukherjee et al. A systematic methodology to compute
the architectural vulnerability factors for a high-performance
microprocessor. In International Symposium on Microarchi-
tecture, 2003.
[12] D. Ponomarev et al. Isolating short-lived operands for energy
reduction. IEEE Trans. Comput., 2004.
[13] J. Ray et al. Dual use of superscalar datapath for transient-
fault detection and recovery. In International Symposium on
Microarchitecture, 2001.
[14] J. Renau et al.
SESC simulator,
January 2005.
http://sesc.sourceforge.net.
[15] R. Sangireddy and A. K. Somani. Exploiting quiescent states
in register lifetime. In ICCD, 2004.
[16] P. Shivakumar et al. Modeling the effect of technology trends
on the soft error rate of combinational logic. In International
Conference on Dependable Systems and Networks, 2002.
[17] K. Skadron et al. Temperature-aware microarchitecture. In
International Symposium on Computer Architecture, 2003.
[18] T. Slegel et al. IBM’s S/390 G5 microprocessor design. IEEE
Micro, 19, 1999.
[19] D. Tarjan et al. CACTI 4.0. Tech Report HPL-2006-86, 2006.
[20] N. J. Wang et al. Characterizing the effects of transient faults
on a high-performance processor pipeline. In International
Conference on Dependable Systems and Networks, 2004.
[21] C. Weaver et al. Techniques to reduce the soft error rate of a
high-performance microprocessor. In International Sympo-
sium on Computer Architecture, 2004.
[22] J. Yan and W. Zhang. Compiler-guided register reliability
improvement against soft errors. In International Conference
on Embedded Software, 2005.
[23] J. F. Ziegler et al. IBM experiments in soft fails in computer
electronics (1978-1994). IBM J. Res. Dev., 1996.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:33:39 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007