A5 - Security Misconfiguration
99
Request Filtering was introduced in IIS7 and it has replaced the functionality UrlScan add-on for IIS 6.0. This 
built-in security feature allows to filter undesired URL request but it is also possible to configure different kinds 
of filtering. To begin with, it is important to understand how the IIS pipeline works when a request is done. The 
following diagram shows the order in these modules
HTTP
RESPONSE
BEGIN REQUEST
AUTHENTICATE REQUEST
AUTHORIZE REQUEST
RESOLVE CACHE
END REQUEST
REQUEST FILTERING
(HIGH PRIORITY)
URL REWRITE MODULE
(MEDIUM PRIORITY)
HTTP
REQUEST
(Yakushev, 2008)
Figure 8: IIS Request FilteringFiles
A5 - Security Misconfiguration
100
Request filtering can be setup through the IIS interface or on the web.config file. Example:
(Yakushev, 2008)
Sample 11.18
using System;
 using System.Text;
 using Microsoft.Web.Administration;
 internal static class Sample
 {
    private static void Main()
    {
       using (ServerManager serverManager = new ServerManager())
       {
          Configuration config = serverManager.GetWebConfiguration(“Default Web Site”);
          ConfigurationSection requestFilteringSection = config.GetSection(“system.webServer/security  
          /requestFiltering”);
         ConfigurationElementCollection denyUrlSequencesCollection =   
         requestFilteringSection.GetCollection(“denyUrlSequences”);
         ConfigurationElement addElement = denyUrlSequencesCollection.CreateElement(“add”);
         addElement[“sequence”] = @”..”;
         denyUrlSequencesCollection.Add(addElement);
         ConfigurationElement addElement1 = denyUrlSequencesCollection.CreateElement(“add”);
         addElement1[“sequence”] = @”:”;
         denyUrlSequencesCollection.Add(addElement1);
         ConfigurationElement addElement2 = denyUrlSequencesCollection.CreateElement(“add”);
         addElement2[“sequence”] = @”\”;
         denyUrlSequencesCollection.Add(addElement2);
Sample 11.19
A5 - Security Misconfiguration
101
This can also be done through the application code, for example:
(Yakushev, 2008)
Filtering Double - Encoded Requests
This attack technique consists of encoding user request parameters twice in hexadecimal format in order to 
bypass security controls or cause unexpected behavior from the application. It’s possible because the web-
server accepts and processes client requests in many encoded forms.
By using double encoding it’s possible to bypass security filters that only decode user input once. The second 
decoding process is executed by the backend platform or modules that properly handle encoded data, but 
don’t have the corresponding security checks in place.
Attackers can inject double encoding in pathnames or query strings to bypass the authentication schema and 
security filters in use by the web application.
There are some common character that are used in Web applications attacks. For example, Path Traversal at-
tacks use “../” (dot-dot-slash) , while XSS attacks use “” characters. These characters give a hexadeci-
mal representation that differs from normal data.
For example, “../” (dot-dot-slash) characters represent %2E%2E%2f in hexadecimal representation. When the 
% symbol is encoded again, its representation in hexadecimal code is %25. The result from the double encod-
ing process ”../”(dot-dot-slash) would be %252E%252E%252F:
• The hexadecimal encoding of “../” represents “%2E%2E%2f” 
• Then encoding the “%” represents “%25” 
• Double encoding of “../” represents “%252E%252E%252F”
If you do not want IIS to allow doubled-encoded requests to be served, use the following (IIS Team,2007):
         serverManager.CommitChanges();
       }
    }
 }
Sample 11.20
A5 - Security Misconfiguration
102
Filter High Bit Characters
This allows or rejects all requests to IIS that contain non-ASCII characters . When this occurs error code 404.12. 
is displayed to the user . The UrlScan (IIS6 add-on) equivalent is AllowHighBitCharacters.
Filter Based on File Extensions
Using this filter you can allow IIS to a request based on file extensions, the error code logged is 404.7. The Al-
lowExtensions and DenyExtensions options are the UrlScan equivalents.
Filter Based on Request Limits
When IIS rejects a request based on request limits, the error code logged is:
• 404.13 if the content is too long.
• 404.14 if the URL is too large.
• 404.15 if the query string is too long.
This can be used to limit a long query string or too much content sent to an application which you cannot 
change the source code to fix the issue.
Sample 11.21
Sample 11.22
A5 - Security Misconfiguration
103
Filter by Verbs
When IIS reject a request based on this feature, the error code logged is 404.6. This corresponds to the UseAl-
lowVerbs, AllowVerbs, and DenyVerbs options in UrlScan.
In case you want the application to use only certain type of verb, it is necessary to firt set the allowUnlisted to 
‘false’ and then set the verbs that you would like to allow (see example)
Filter Based on URL Sequences
This feature defines a list of sequences that IIS can reject when it is part of a request. When IIS reject a request 
for this feature, the error code logged is 404.5.This corresponds to the DenyUrlSequences feature in UrlScan.
This is a very powerful feature. This avoids a given character sequence from ever being attended by IIS:
Sample 11.23
Sample 11.24
Sample 11.25
A5 - Security Misconfiguration
104
Filter Out Hidden Segments
In case you want IIS to serve content in binary directory but not the binary, you can apply this configuration.
Password protection and sensitive information
The web.config files might include sensitive information in the connection strings such as database passwords, 
mail server user names among others. 
Sections that are required to be encrypted are:
• . This section contains custom application settings.
• . This section contains connection strings.
• . This section can contain impersonation credentials.
• . This section contains the connection string for the out-of-process session state provider.
Passwords and user names contained in a  section should be encrypted. ASP.NET allows 
you to encrypt this information by using the functionality  aspnet_regiis .This utility is found in the installed 
.NET framework under the folder 
%windows%\Microsoft.NET\Framework\v2.0.50727
You can specify the section you need to encrypt by using the command:
aspnet_regiis -pef sectiontobeencryoted 
Encrypting sections in Web.Config file
Even though encrypting sections is possible, not all sections can be encrypted, specifically sections that are 
Sample 11.26
A5 - Security Misconfiguration
105
read before user code is run. The following sections cannot be encrypted:
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
Machine-Level RSA key container or User-Level Key Containers
Encrypting a single file using machine-level RSA key has its disadvantages when this file is moved to other 
servers. In this case, user-level RSA key container is strongly advised. The RSAProtectedConfigurationProvider 
supports machine-level and user-level key containers for key storage.
RSA machine key containers are stored in the following folder:
\Documents and Settings\All Users\Application Data\Microsoft\Crypto\RSA\MachineKeys
User Key Container
When the application that needs to be protected is in a shared hosting environment and protection of sensi-
tive data cannot be accessible to other applications, the user key container is strongly recommended. 
In this case each application should have a separate identity.
RSA user-level key containers are stored in the following folder:
\Documents and Settings\{UserName}\Application Data\Microsoft\Crypto\RSA
IIS configurations
Depending on the version of IIS that must be configured, it is important to revise some of its settings which 
can comprise security in the server.
Trust level
The trust level is a set of Code Access Security permissions granted to an application within a hosting environ-
ment. These are defined using policy files. Depending on the trust level that must be configured, it is possible 
to grant FULL, HIGH, MEDIUM, LOW or MINIMAL level. The ASP.NET host does not apply any additional policy 
to applications that are running at the full-trust level.
Example:
Sample 11.27
A5 - Security Misconfiguration
106
Lock Trust Levels
In the .NET framework web.config file is possible to lock applications from changing their trust level
This file is found at:
C:\Windows\Microsoft.NET\Framework\{version}\CONFIG
The following example shows how to lock 2 different application configuration trust levels (MSDN, 2013)
References
• Yakushev Ruslan , 2008 “IIS 7.0 Request Filtering and URL Rewriting “ available at http://www.iis.net/learn/
extensions/url-rewrite-module/iis-request-filtering-and-url-rewriting (Last accessed on 14 July, 2013)
• OWASP, 2009 “Double Encoding” available at https://www.owasp.org/index.php/Double_Encoding (Last  ac-
cessed on 14 July, 2013)
• IIS Team, 2007 “Use Request Filtering “  available at http://www.iis.net/learn/manage/configuring-security/ 
use-request-filtering  (Last accessed on 14 July, 2013)
• Aguilar Carlos ,2006 “The new Configuration System in IIS 7” available at http://blogs.msdn.com/b/carlosag/
archive/2006/04/25/iis7configurationsystem.aspx (Last accessed on 14 July, 2013)
• MSDN, 2013 . How to: Lock ASP.NET Configuration Settings available at http://msdn.microsoft.com/en-us/
library/ms178693.aspx (Last accessed on 14 July, 2013)
11.10 Strongly Named Assemblies
During the build process either QA or Developers are going to publish the code into executable formats. Usu-
ally this consists of an exe or and one or several DLL’s. During the build/publish process a decision needs to be 
made to sign or not sign the code. 
Signing your code is called creating “strong names” by Microsoft. If you create a project using Visual Studio and 
use Microsofts “Run code analysis” most likely your will encounter a Microsoft design error if the code is not 
strong named; “Warning     1 CA2210 : Microsoft.Design : Sign ‘xxx.exe’ with a strong name key.”
Sample 11.28
A5 - Security Misconfiguration
107
Code review needs to be aware if strong naming is being used, benefits and what threat vectors strong naming 
helps prevent or understand the reasons for not using strong naming.
A strong name is a method to sign an assembly’s identity using its text name, version number, culture informa-
tion, a public key and a digital signature. (Solis, 2012)
• Strong naming guarantees a unique name for that assembly.
• Strong names protect the version lineage of an assembly. A strong name can ensure that no one can  pro-
duce a subsequent version of your assembly. Users can be sure that a version of the assembly they are loading 
comes from the same publisher that created the version the application was built with.
The above two points are very important if you are going to use Global Assembly Cache (GAC).
• Strong names provide a strong integrity check and prevent spoofing. Passing the .NET Framework security 
checks guarantees that the contents of the assembly have not been changed since it was built. 
Note, however, that strong names in and of themselves do not imply a level of trust like that provided, for 
example, by a digital signature and supporting certificate. If you use the GAC assemblies remember the assem-
blies are not verified each time they load since the GAC by design is a locked-down, admin-only store.
What strong names can’t prevent is a malicious user from stripping the strong name signature entirely, modi-
fying the assembly, or re-signing it with the malicious user’s key. 
The code reviewer needs to understand how the strong name private key will be kept secure and managed. 
This is crucible if you decide strong name signatures are a good fit for your organization. 
If principle of least privilege is used so code is not or less susceptible to be access by the hacker and the GAC is 
not being used strong names provides less benefits or no benefits at all.
How to use Strong Naming
Signing tools
In order to create a strong name assembly there are a set of tools and steps that you need to follow
Using Visual Studio
In order to use Visual Studio to create a Strongly Named Assembly, it is necessary to have a copy of the public/