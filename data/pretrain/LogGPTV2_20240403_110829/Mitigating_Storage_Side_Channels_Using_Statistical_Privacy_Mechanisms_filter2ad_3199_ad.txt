a
r
u
c
c
A
1.0
0.8
0.6
0.4
0.2
0.0
0
1.0
0.8
0.6
0.4
0.2
y
c
a
r
u
c
c
A
3
6
9
12
15
0.0
0.00
0.02
0.04
0.06
0.08
0.10
ǫ
ǫ
(a) Keystroke timing attack
(b) Website inference attack
Figure 1: Multi-class classiﬁer accuracy under dif-
ferent ǫ settings; dashed horizontal lines show accu-
racies of blind guesses based only on knowledge of
the likelihood of each class
timings, the most likely class occurred roughly 44% of the
time, and so this baseline (shown by the horizontal dashed
line) is the accuracy that the adversary could achieve simply
by blindly guessing based on that distribution. As shown in
the graph, setting ǫ ∈ [1, 3] suﬃces to reduce the classiﬁer
to this baseline accuracy. By comparison, the classiﬁer was
perfect (an accuracy of 1.0) when no noise was added.
6.1.2 Mitigating Website Inference
The memory footprint of a browser can leak the website
it visits (as discussed in Sec. 3.1). In this experiment, we
instrumented the Google Chrome browser with a script to
visit a target website, chosen uniformly from the Alexa top-
10 websites. While this occurred, an attacker process re-
peatedly sampled the data resident size ﬁeld drs, calculated
as totalVM − sharedVM (using the labels deﬁned in Table 2),
by reading the /proc//statm of the browser process
every 500µs. To support this rate of sampling, dpprocfs
employed the heuristic method of invariant reestablishment
(Sec. 5.3), which returned results in roughly 50µs (in com-
parison to 8ms for the nearest solution). The sampling pe-
riod lasted for 3s, during which the attack process recorded
all the drs ﬁeld values read. As in Sec. 6.1.1, the attacker
estimated the true (unnoised) drs value corresponding to the
j-th read value in each 3s interval, using an empirical distri-
bution observed for these j-th values gathered by accessing
each of these 10 websites an equal number of times. The at-
tacker then constructed a histogram of these estimated drs
values binned into seven equal-width bins, and the vector of
bin counts (in N7) was used as a feature vector for classiﬁ-
cation. Each of the Alexa top-10 websites were visited 100
times; when used to train and test the SVM classiﬁer (with
m = 10 classes), 70% were used for training and 30% were
used for testing.
The resulting accuracy of the classiﬁer is shown in Fig. 1(b).
The most important distinction from the graph in Fig. 1(a)
is that the values of ǫ needed to interfere with the website
inference attack are much smaller, meaning that the noise
added was greater. This is primarily a function of the size
diﬀerences between drs readings from the m classes, which
were generally much greater than the diﬀerences between the
readings of the voluntary context switch counter nvcsw with
and without a keystroke. In terms of d∗, the distances be-
tween the classes in the website inference attack were much
greater than the distances between classes in the keystroke
attack. This is noteworthy because it implies that the set-
1589tings of ǫ needed for privacy will diﬀer per-ﬁeld and per-
application and, to some extent, will need to be informed
by known attacks. Still, however, several values tested for ǫ
decayed classiﬁcation accuracy to a signiﬁcant extent; with
no noise added, the classiﬁer reached 0.915 accuracy.
6.2 Utility Evaluation
We evaluate the utility of dpprocfs in two ways. First, we
measure the relative error of selected procfs outputs that
are calculated using ﬁelds protected by dpprocfs, under the
two methods discussed in Sec. 5.3 for enforcing invariants,
namely producing a heuristic solution and a nearest solution
to the invariants. Second, we report the impact of dpprocfs
to the ranking of processes according to certain features by
top, a common utility for monitoring and diagnosis. Here
we focus on dpprocfs outputs such as memory and CPU
usage, as these are generally useful systems diagnostics.
6.2.1 Relative Error
We begin our utility evaluation by measuring the relative
error of the drs ﬁeld, the same ﬁeld exploited by website in-
ference attackers (see Sec. 6.1.2). To calculate the relative
error of this ﬁeld under dpprocfs, we preserved access to an
unprotected version of procfs alongside the protected ver-
sion. Then, we extended our setup described in Sec. 6.1.2
to simultaneously query both the protected and unprotected
versions of the drs ﬁeld while the browser process was run-
ning. During the evaluation, the browser was instrumented
to repeatedly visit https://www.youtube.com, and the drs
ﬁeld was queried every 50ms for a total of 500 queries. We
repeated this experiment 200 times.
0.8
0.6
0.4
Queries
0.2
0.0
r
o
r
r
E
e
v
i
t
a
l
e
R
heuristic
nearest
invariant
1-100 101-200 201-300 301-400 401-500
Figure 2: Comparison be-
tween nearest and heuris-
tic invariant reestablish-
ment for drs ﬁeld; ǫ = 0.005
Fig. 2 shows the dis-
tribution of relative er-
ror for both the nearest
and heuristic solutions
for
reestab-
lishment, computed on
the same noised values
˜x produced by privfs,
for a parameter setting
(ǫ = 0.005) that pro-
vided good security for
the side-channel attack
tested in Sec. 6.1 (see
Fig. 1(b)). Each query
range on the horizontal
axis has two box-and-whiskers plots, one for nearest and
one for heuristic. The three horizontal lines forming each
box indicate the ﬁrst, second (median), and third quartiles,
and the whiskers extend to cover all points within 1.5×
the interquartile range. Outliers are indicated using plus
(“+”) symbols. A diﬀerent box-and-whiskers plot is shown
per 100-query block across the 200 runs (i.e., each boxplot
represents 20,000 points) because the noise increases as the
number of queries grows. The diﬀerences between the near-
est and heuristic distributions are nearly imperceptible, and
this trend holds for other parameter and procfs ﬁelds we
have explored, as well. That said, the heuristic solution re-
lies on hand-tuned algorithms and by default provides no
guarantees, and so in cases where the speed of computing
the nearest solution is acceptable—the nearest solution took
an average of 8ms to return, whereas our heuristic approach
completed in an average of 50µs—it might be preferable.
r
o
r
r
E
e
v
i
t
a
l
e
R
0.5
0.4
0.3
0.2
0.1
0.0
ǫ = 0.005
ǫ = 0.01
ǫ = 0.02
ǫ = 0.04
1-100
101-200
201-300
Queries
301-400
401-500
Figure 3: Relative error for drs ﬁeld under nearest
invariant reestablishment
r
o
r
r
E
e
v
i
t
a
l
e
R
0.8
0.6
0.4
0.2
0.0
ǫ = 1
ǫ = 2
ǫ = 4
ǫ = 5
1-100
101-200
201-300
Queries
301-400
401-500
Figure 4: Relative error for utime ﬁeld under nearest
invariant reestablishment
Fig. 3 and Fig. 4 represent the relative error in readings of
the drs ﬁeld and of the utime ﬁeld from the /proc//stat
ﬁle, respectively, for various values of ǫ. The values of ǫ
in Fig. 3 were chosen to overlap those used in the secu-
rity evaluation depicted in Fig. 1(b). The ǫ values tested in
Fig. 4 were chosen based on our simulation of the software-
keyboard side-channel attack of Lin et al. [28], which we
conducted on a Nexus 4 smartphone running Android 5.1
with kernel 3.4.0; based on this simulation, we estimated
that ranging ǫ over 1/2 ≤ ǫ ≤ 5 would result in curve simi-
lar to or better (with lower accuracy) than that in Fig. 1(a).6
In the tests in Fig. 4, the utime ﬁeld was queried every 50ms
while a video game was running. These graphs suggest that
the relative error is typically modest, e.g., with a third quar-
tile of < 15% in Fig. 3 and < 30% in Fig. 4, though outliers
can be large.
6.2.2 Rank Accuracy of top
The utility top is used by Linux administrators for per-
formance monitoring and diagnosis. By reading procfs, top
displays system information like memory and CPU usage of
running processes. The processes are ranked by top accord-
ing to a chosen ﬁeld. In this section, we evaluate the utility
of dpprocfs by measuring the rank accuracy of top when
run using dpprocfs in place of the original procfs.
To measure the rank accuracy, we ran two top processes
on one computer. These two top processes were started at
the same time and updated information with the same fre-
quency (every two seconds in our tests). The only diﬀerence
was that one top process read from dpprocfs (with heuristic
invariant reestablishment), and the other read from procfs
in its original form. To control the test workload in each ex-
periment, we ran a set of ten processes doing ﬂoating-point
6Lin et al. reported querying the utime ﬁeld of the software
keyboard process every 100ms to detect its increase. With
very rapid typing, the utime ﬁeld in our tests increased less
than 3 (jiﬃes) per 100ms interval, on average.
1590y
c
a
r
u
c
c
A
e
g
a
r
e
v
A
1.0
0.8
0.6
0.4
0.2
0.0
y
c
a
r
u
c
c
A
e
g
a
r
e
v
A
1.0
0.8
0.6
0.4
0.2
0.0
Top 1
Top 3
Top 5
Top 10
50 100 150 200 250 300 350 400 450 500
Queries