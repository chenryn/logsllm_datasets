# 【技术分享】利用GDB调试ARM代码
|
##### 译文声明
本文是翻译文章，文章来源：azeria-labs.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[shan66](http://bobao.360.cn/member/contribute?uid=2522399780)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
在本文中，我们将简要介绍如何利用GDB完成ARM二进制文件的编译和基本调试。当然，阅读过程中，如果读者想要对ARM汇编代码动手进行实验的话，则需要准备一个备用的ARM设备，或者在虚拟机中设置相应的实验室环境，具体操作请参考[How-To](https://azeria-labs.com/emulate-raspberry-pi-with-qemu/)这篇文章。
此外，您还将通过下面取自 [Part 7 – Stack and Functions](https://azeria-labs.com/functions-and-the-stack-part-7/)这篇文章中的代码来熟悉GDB的基本调试功能。
    .section .text
    .global _start
    _start:
        push {r11, lr}    /* Start of the prologue. Saving Frame Pointer and LR onto the stack */
        add r11, sp, #0   /* Setting up the bottom of the stack frame */
        sub sp, sp, #16   /* End of the prologue. Allocating some buffer on the stack */
        mov r0, #1        /* setting up local variables (a=1). This also serves as setting up the first parameter for the max function */
        mov r1, #2        /* setting up local variables (b=2). This also serves as setting up the second parameter for the max function */
        bl max            /* Calling/branching to function max */
        sub sp, r11, #0   /* Start of the epilogue. Readjusting the Stack Pointer */
        pop {r11, pc}     /* End of the epilogue. Restoring Frame pointer from the stack, jumping to previously saved LR via direct load into PC */
    max:
        push {r11}        /* Start of the prologue. Saving Frame Pointer onto the stack */
        add r11, sp, #0   /* Setting up the bottom of the stack frame */
        sub sp, sp, #12   /* End of the prologue. Allocating some buffer on the stack */
        cmp r0, r1        /* Implementation of if(a）
调试二进制代码：$ gdb ./file
检查内核（崩溃）文件：$ gdb -c ./core.3243
    $ gdb max
如果您安装了GEF，将会显示gef>提示符。
可以通过下列方式获取帮助：
(gdb) h
(gdb) apropos 
    gef> apropos registers
    collect -- Specify one or more data items to be collected at a tracepoint
    core-file -- Use FILE as core dump for examining memory and registers
    info all-registers -- List of all registers and their contents
    info r -- List of integer registers and their contents
    info registers -- List of integer registers and their contents
    maintenance print cooked-registers -- Print the internal register configuration including cooked values
    maintenance print raw-registers -- Print the internal register configuration including raw values
    maintenance print registers -- Print the internal register configuration
    maintenance print remote-registers -- Print the internal register configuration including each register's
    p -- Print value of expression EXP
    print -- Print value of expression EXP
    registers -- Display full details on one
    set may-write-registers -- Set permission to write into registers
    set observer -- Set whether gdb controls the inferior in observer mode
    show may-write-registers -- Show permission to write into registers
    show observer -- Show whether gdb controls the inferior in observer mode
    tui reg float -- Display only floating point registers
    tui reg general -- Display only general registers
    tui reg system -- Display only system registers
断点命令：
break (or just b) 
break 
break filename:function
break filename:line-number
break *
break +
break –
tbreak (设置一个临时断点）
del  （删除编号为x的断点）
delete (删除所有断点）
delete （删除指定编号范围内的断点）
disable/enable  (不删除断点，只是启用/禁用它们）
continue (or just c) – （继续执行，直到下一个断点）
continue  (继续，但忽略当前断点指定次数。对循环内的断点非常有用）
finish继续，直至函数末尾）
    gef> break _start
    gef> info break
    Num Type Disp Enb Address What
    1 breakpoint keep y 0x00008054 
     breakpoint already hit 1 time
    gef> del 1
    gef> break *0x0000805c
    Breakpoint 2 at 0x805c
    gef> break _start
这将删除第一个断点，并在指定的内存地址处设置一个断点。当您运行程序时，它将在这个指定的位置停下来。
如果不删除第一个断点，然后又设置一个断点并运行，则它还是在第一个断点处停下来。
启动和停止：
启动一个程序，从头开始执行
run
r
run 
停止程序的运行
kill
退出GDB调试器
quit
q
    gef> run
现在，我们的程序在指定的位置停下来了，这样就可以开始检查内存了。 命令“x”可以用来以各种格式显示内存内容。
语法 : x/
格式单位
x – 十六进制 b – 字节
d – 十进制h – 半字（2字节）
i – 指令w – 字（4字节）
t – 二进制（two）g – 巨字（8字节）
o – 八进制
u – 无符号整数
s – 字符串
c – 字符
    gef> x/10i $pc
    => 0x8054 : push {r11, lr}
     0x8058 : add r11, sp, #0
     0x805c : sub sp, sp, #16
     0x8060 : mov r0, #1
     0x8064 : mov r1, #2
     0x8068 : bl 0x8074 
     0x806c : sub sp, r11, #0
     0x8070 : pop {r11, pc}
     0x8074 : push {r11}
     0x8078 : add r11, sp, #0
    gef> x/16xw $pc
    0x8068 : 0xeb000001  0xe24bd000  0xe8bd8800  0xe92d0800
    0x8078 :     0xe28db000  0xe24dd00c  0xe1500001  0xb1a00001
    0x8088 :    0xe28bd000  0xe8bd0800  0xe12fff1e  0x00001741
    0x8098:             0x61656100  0x01006962  0x0000000d  0x01080206
用于单步调试的命令：单步执行下一条命令。可以进入函数内部
stepi