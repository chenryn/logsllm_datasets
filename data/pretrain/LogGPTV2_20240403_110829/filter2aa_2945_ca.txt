### Raising an Event

You can raise an event by invoking it like a method. When you raise an event, all the attached delegates are called in sequence. For example, consider the `TemperatureMonitor` class, which has a private `Notify` method that raises the `MachineOverheating` event:

```csharp
class TemperatureMonitor
{
    public delegate void StopMachineryDelegate();
    public event StopMachineryDelegate MachineOverheating;

    private void Notify()
    {
        if (this.MachineOverheating != null)
        {
            this.MachineOverheating();
        }
    }
}
```

This is a common pattern. The null check is necessary because an event field is implicitly null and only becomes non-null when a method subscribes to it using the `+=` operator. Attempting to raise a null event will result in a `NullReferenceException`. If the delegate defining the event expects parameters, the appropriate arguments must be provided when raising the event. You will see examples of this later.

**Important:** Events have a built-in security feature. A public event (such as `MachineOverheating`) can only be raised by methods within the class that defines it (in this case, `TemperatureMonitor`). Any attempt to raise the event outside the class results in a compiler error.

### Understanding User Interface Events

As mentioned earlier, .NET Framework classes and controls used for building GUIs extensively use events. For example, the `Button` class derives from the `ButtonBase` class, inheriting a public event called `Click` of type `RoutedEventHandler`. The `RoutedEventHandler` delegate expects two parameters: a reference to the object that caused the event to be raised, and a `RoutedEventArgs` object containing additional information about the event:

```csharp
public delegate void RoutedEventHandler(object sender, RoutedEventArgs e);
```

The `Button` class looks like this:

```csharp
public class ButtonBase
{
    public event RoutedEventHandler Click;
}

public class Button : ButtonBase
{
    // Additional members
}
```

The `Button` class automatically raises the `Click` event when the button is clicked on the screen. This arrangement makes it easy to create a delegate for a chosen method and attach it to the required event. The following example shows the code for a UWP form that contains a button named `okay` and the code to connect the `Click` event of the `okay` button to the `okayClick` method:

```csharp
partial class MainPage : 
    global::Windows.UI.Xaml.Controls.Page,
    global::Windows.UI.Xaml.Markup.IComponentConnector,
    global::Windows.UI.Xaml.Markup.IComponentConnector2
{
    public void Connect(int connectionId, object target)
    {
        switch (connectionId)
        {
            case 1:
                this.okay = (global::Windows.UI.Xaml.Controls.Button)target;
                ((global::Windows.UI.Xaml.Controls.Button)this.okay).Click += this.okayClick;
                break;
            default:
                break;
        }
        this._contentLoaded = true;
    }
}
```

This code is usually hidden from you. When you use the Design View window in Visual Studio 2017 and set the `Click` property of the `okay` button to `okayClick` in the XAML description of the form, Visual Studio generates this code for you. All you need to do is write your application logic in the event-handling method, `okayClick`, in the `MainPage.xaml.cs` file:

```csharp
public sealed partial class MainPage : Page
{
    private void okayClick(object sender, RoutedEventArgs e)
    {
        // Your code to handle the Click event
    }
}
```

Events generated by various GUI controls always follow the same pattern. The events are of a delegate type with a `void` return type and two arguments: the first argument is always the `sender` (the source) of the event, and the second argument is always an `EventArgs` argument (or a class derived from `EventArgs`).

With the `sender` argument, you can reuse a single method for multiple events. The delegated method can examine the `sender` argument and respond accordingly. For example, you can use the same method to subscribe to the `Click` event for two buttons. When the event is raised, the code in the method can examine the `sender` argument to determine which button was clicked.

### Using Events

In the previous exercise, you decoupled the auditing and shipping logic from the checkout process in the Wide World Importers application. The `CheckoutController` class invokes the auditing and shipping components using a delegate and has no knowledge about these components or the methods it is running. However, it might be useful for a component to alert the application when it has completed its processing, enabling the application to perform any necessary cleanup.

This might sound strange at firstâ€”surely when the application invokes the delegate in the `CheckoutController` object, the methods referenced by this delegate run, and the application only continues with the next statement when these methods have finished. But this is not necessarily the case! Chapter 24, "Improving Response Time by Performing Asynchronous Operations," demonstrates that methods can run asynchronously, and when you invoke a method, it might not have completed before execution continues with the next statement. This is especially true in UWP apps, where long-running operations are performed on background threads to keep the user interface responsive.

In the Wide World Importers application, in the `CheckoutButtonClicked` method, the code that invokes the delegate is followed by a statement that displays a dialog box with a message indicating that the order has been placed:

```csharp
private async void CheckoutButtonClicked(object sender, RoutedEventArgs e)
{
    try
    {
        // Perform the checkout processing
        this.checkoutController.StartCheckoutProcessing(this.order);

        // Display a summary of the order
        MessageDialog dlg = new MessageDialog(...);
        await dlg.ShowAsync();
    }
    catch (Exception ex)
    {
        // Handle exception
    }
}
```

There is no guarantee that the processing performed by the delegated methods has completed by the time the dialog box appears, so the message could be misleading. This is where an event is invaluable. The `Auditor` and `Shipper` components could both publish an event to which the application subscribes. This event would be raised by the components only when they have completed their processing. When the application receives this event, it can display the message, safe in the knowledge that it is now accurate.

In the following exercise, you will modify the `Auditor` and `Shipper` classes to raise an event that occurs when they have completed their processing. The application will subscribe to the event for each component and display an appropriate message when the event occurs.

#### Add an Event to the `CheckoutController` Class

1. Return to Visual Studio 2017 and open the Delegates solution.
2. In the `AuditService` project, open the `Auditor.cs` file in the Code and Text Editor window.
3. Add a public delegate called `AuditingCompleteDelegate` to the `Auditor` class. This delegate should specify a method that takes a `string` parameter called `message` and returns `void`.

```csharp
public class Auditor
{
    public delegate void AuditingCompleteDelegate(string message);
}
```

4. Add a public event called `AuditProcessingComplete` to the `Auditor` class, based on the `AuditingCompleteDelegate` delegate.

```csharp
public class Auditor
{
    public delegate void AuditingCompleteDelegate(string message);
    public event AuditingCompleteDelegate AuditProcessingComplete;
}
```

5. Locate the `AuditOrder` method. This is the method that is run using the delegate in the `CheckoutController` object. It invokes another private method called `doAuditing` to perform the audit operation.

```csharp
public void AuditOrder(Order order)
{
    this.doAuditing(order);
}
```

6. Scroll down to the `doAuditing` method. After the `catch` block, add a `finally` block that raises the `AuditProcessingComplete` event.

```csharp
private async void doAuditing(Order order)
{
    List<AgeRestrictedItem> ageRestrictedItems = findAgeRestrictedItems(order);
    if (ageRestrictedItems.Count > 0)
    {
        try
        {
            // Audit logic
        }
        catch (Exception ex)
        {
            // Handle exception
        }
        finally
        {
            if (this.AuditProcessingComplete != null)
            {
                this.AuditProcessingComplete($"Audit record written for Order {order.OrderID}");
            }
        }
    }
}
```

7. In the `DeliveryService` project, open the `Shipper.cs` file in the Code and Text Editor window.
8. Add a public delegate called `ShippingCompleteDelegate` to the `Shipper` class. This delegate should specify a method that takes a `string` parameter called `message` and returns `void`.

```csharp
public class Shipper
{
    public delegate void ShippingCompleteDelegate(string message);
}
```

9. Add a public event called `ShipProcessingComplete` to the `Shipper` class, based on the `ShippingCompleteDelegate` delegate.

```csharp
public class Shipper
{
    public delegate void ShippingCompleteDelegate(string message);
    public event ShippingCompleteDelegate ShipProcessingComplete;
}
```

10. Find the `doShipping` method, which performs the shipping logic. After the `catch` block, add a `finally` block that raises the `ShipProcessingComplete` event.

```csharp
private async void doShipping(Order order)
{
    try
    {
        // Shipping logic
    }
    catch (Exception ex)
    {
        // Handle exception
    }
    finally
    {
        if (this.ShipProcessingComplete != null)
        {
            this.ShipProcessingComplete($"Dispatch note generated for Order {order.OrderID}");
        }
    }
}
```

11. In the `Delegates` project, display the layout for the `MainPage.xaml` file in the Design View window. In the XAML pane, scroll down to the first set of `RowDefinition` items. Change the `Height` property of the final `RowDefinition` item to `2*` to make space available at the bottom of the form.

12. Add the following `ScrollViewer` and `TextBlock` elements before the penultimate `</Grid>` tag to display messages from the `Auditor` and `Shipper` components.

```xml
<ScrollViewer>
    <TextBlock x:Name="messageBar" />
</ScrollViewer>
```

13. Display the `MainPage.xaml.cs` file in the Code and Text Editor window. Find the `CheckoutButtonClicked` method and remove the code that displays the summary of the order.

```csharp
private async void CheckoutButtonClicked(object sender, RoutedEventArgs e)
{
    try
    {
        // Perform the checkout processing
        this.checkoutController.StartCheckoutProcessing(this.order);

        // Clear out the order details
        this.order = new Order
        {
            Date = DateTime.Now,
            Items = new List<Item>(),
            OrderID = Guid.NewGuid(),
            TotalValue = 0
        };
        this.orderDetails.DataContext = null;
        this.orderValue.Text = $"{this.order.TotalValue:C}";
        this.listViewHeader.Visibility = Visibility.Collapsed;
        this.checkout.IsEnabled = false;
    }
    catch (Exception ex)
    {
        // Handle exception
    }
}
```

14. Add a private method called `displayMessage` to the `MainPage` class. This method should take a `string` parameter called `message` and append it to the `Text` property of the `messageBar` `TextBlock` control.

```csharp
private void displayMessage(string message)
{
    this.messageBar.Text += $"{Environment.NewLine}{message}";
}
```

15. Find the constructor for the `MainPage` class and add the code to subscribe to the events exposed by the `Auditor` and `Shipper` objects.

```csharp
public MainPage()
{
    InitializeComponent();

    this.auditor = new Auditor();
    this.shipper = new Shipper();
    this.checkoutController = new CheckoutController();
    this.checkoutController.CheckoutProcessing += this.auditor.AuditOrder;
    this.checkoutController.CheckoutProcessing += this.shipper.ShipOrder;
    this.auditor.AuditProcessingComplete += this.displayMessage;
    this.shipper.ShipProcessingComplete += this.displayMessage;
}
```

16. Build and run the application. When the Wide World Importers form appears, select some items (including at least one age-restricted item), and click `Checkout`. Verify that the "Audit record written" and "Dispatch note generated" messages appear in the `TextBlock` at the bottom of the form.

17. Place further orders and note the new messages that appear each time you click `Checkout` (you might need to scroll down to see them when the message area fills up).

18. When you have finished, return to Visual Studio 2017 and stop debugging.

### Summary

In this chapter, you learned how to use delegates to reference and invoke methods, define lambda expressions, and use events to trigger the execution of methods. If you want to continue to the next chapter, keep Visual Studio 2017 open.