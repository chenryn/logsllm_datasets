Raising an event
You can raise an event by calling it like a method. When you raise an event,
all the attached delegates are called in sequence. For example, here’s the
TemperatureMonitor class with a private Notify method that raises the
MachineOverheating event:
Click here to view code image
class TemperatureMonitor
{
    public delegate void StopMachineryDelegate();
    public event StopMachineryDelegate MachineOverheating;
    ...
    private void Notify()
    {
        if (this.MachineOverheating != null)
        {
            this.MachineOverheating();
        }
    }
    ...
}
This is a common idiom. The null check is necessary because an event
field is implicitly null and only becomes nonnull when a method subscribes
to it by using the += operator. If you try to raise a null event, you will get a
NullReferenceException exception. If the delegate defining the event expects
any parameters, the appropriate arguments must be provided when you raise
the event. You will see some examples of this later.
Download from finelybook PI:EMAIL
685
Important Events have a very useful built-in security feature. A public
event (such as MachineOverheating) can be raised only by methods in
the class that define it (the TemperatureMonitor class). Any attempt to
raise the event outside the class results in a compiler error.
Understanding user interface events
As mentioned earlier, the .NET Framework classes and controls used for
building GUIs employ events extensively. For example, the Button class
derives from the ButtonBase class, inheriting a public event called Click of
type RoutedEventHandler. The RoutedEventHandler delegate expects two
parameters: a reference to the object that caused the event to be raised, and a
RoutedEventArgs object that contains additional information about the event:
Click here to view code image
public delegate void RoutedEventHandler(Object sender,
RoutedEventArgs e);
The Button class looks like this:
Click here to view code image
public class ButtonBase: ...
{
    public event RoutedEventHandler Click;
    ...
}
public class Button: ButtonBase
{
    ...
}
The Button class automatically raises the Click event when you click the
button on the screen. This arrangement makes it easy to create a delegate for
a chosen method and attach that delegate to the required event. The following
example shows the code for a UWP form that contains a button named okay
and the code to connect the Click event of the okay button to the okayClick
Download from finelybook PI:EMAIL
686
method:
Click here to view code image
partial class MainPage :
    global::Windows.UI.Xaml.Controls.Page,
    global::Windows.UI.Xaml.Markup.IComponentConnector,
    global::Windows.UI.Xaml.Markup.IComponentConnector2
{
    ...
    public void Connect(int connectionId, object target)
    {
        switch(connectionId)
        {
            case 1:
            {
                this.okay = (global::Windows.UI.Xaml.Controls.Button)
(target);
                ...
                ((global::Windows.UI.Xaml.Controls.Button)this.okay).Click
+= this.okayClick;
                ...
            }
            break;
            default:
            break;
        }
        this._contentLoaded = true;
    }
    ...
}
This code is usually hidden from you. When you use the Design View
window in Visual Studio 2017  and set the Click property of the okay button
to okayClick in the Extensible Application Markup Language (XAML)
description of the form, Visual Studio 2017 generates this code for you. All
you have to do is write your application logic in the event-handling method,
okayClick, in the part of the code to which you do have access, which is the
MainPage.xaml.cs file in this case:
Click here to view code image
public sealed partial class MainPage : Page
{
    ...
    private void okayClick(object sender, RoutedEventArgs e)
    {
        // your code to handle the Click event
    }
Download from finelybook PI:EMAIL
687
}
The events that the various GUI controls generate always follow the same
pattern. The events are of a delegate type whose signature has a void return
type and two arguments. The first argument is always the sender (the source)
of the event, and the second argument is always an EventArgs argument (or a
class derived from EventArgs).
With the sender argument, you can reuse a single method for multiple
events. The delegated method can examine the sender argument and respond
accordingly. For example, you can use the same method to subscribe to the
Click event for two buttons. (You add the same method to two different
events.) When the event is raised, the code in the method can examine the
sender argument to ascertain which button was clicked.
Using events
In the previous exercise, you amended the Wide World Importers application
to decouple the auditing and shipping logic from the checkout process. The
CheckoutController class that you built invokes the auditing and shipping
components by using a delegate and has no knowledge about these
components or the methods it is running; this is the responsibility of the
application that creates the CheckoutController object and adds the
appropriate references to the delegate. However, it might be useful for a
component to be able to alert the application when it has completed its
processing and enable the application to perform any necessary tidying up.
This might sound a little strange at first—surely when the application
invokes the delegate in the CheckoutController object, the methods
referenced by this delegate run, and the application only continues with the
next statement when these methods have finished. But this is not necessarily
the case! Chapter 24, “Improving response time by performing asynchronous
operations,” demonstrates that methods can run asynchronously, and when
you invoke a method, it might not have completed before execution continues
with the next statement. This is especially true in UWP apps in which long-
running operations are performed on background threads to enable the user
interface to remain responsive. In the Wide World Importers application, in
the CheckoutButtonClicked method, the code that invokes the delegate is
followed by a statement that displays a dialog box with a message indicating
Download from finelybook PI:EMAIL
688
that the order has been placed:
Click here to view code image
private void CheckoutButtonClicked(object sender, RoutedEventArgs e)
{
    try
    {
        // Perform the checkout processing
        this.checkoutController.StartCheckoutProcessing(this.order);
        // Display a summary of the order
        MessageDialog dlg = new MessageDialog(...);
        dlg.ShowAsync();
        ...
    }
    ...
}
In fact, there is no guarantee that the processing performed by the
delegated methods has completed by the time the dialog box appears, so the
message could actually be misleading. This is where an event is invaluable.
The Auditor and Shipper components could both publish an event to which
the application subscribes. This event could be raised by the components only
when they have completed their processing. When the application receives
this event, it can display the message, safe in the knowledge that it is now
accurate.
In the following exercise, you will modify the Auditor and Shipper classes
to raise an event that occurs when they have completed their processing. The
application will subscribe to the event for each component and display an
appropriate message when the event occurs.
Add an event to the CheckoutController class
1. Return to Visual Studio 2017 and display the Delegates solution.
2. In the AuditService project, open the Auditor.cs file in the Code and
Text Editor window.
3. Add a public delegate called AuditingCompleteDelegate to the Auditor
class. This delegate should specify a method that takes a string
parameter called message and that returns a void. The code in bold in the
following example shows the definition of this delegate:
Download from finelybook PI:EMAIL
689
Click here to view code image
public class Auditor
{
    public delegate void AuditingCompleteDelegate(string
message);
    ...
}
4. Add a public event called AuditProcessingComplete to the Auditor class,
after the AuditingCompleteDelegate delegate. This event should be
based on the AuditingCompleteDelegate delegate as shown in bold in
the following code:
Click here to view code image
public class Auditor
{
    public delegate void AuditingCompleteDelegate(string
message);
    public event AuditingCompleteDelegate
AuditProcessingComplete;
    ...
}
5. Locate the AuditOrder method. This is the method that is run by using
the delegate in the CheckoutController object. It invokes another private
method called doAuditing to actually perform the audit operation. The
method looks like this:
Click here to view code image
public void AuditOrder(Order order)
{
    this.doAuditing(order);
}
6. Scroll down to the doAuditing method. The code in this method is
enclosed in a try/catch block; it uses the XML APIs of the .NET
Framework class library to generate an XML representation of the order
being audited and saves it to a file. (The exact details of how this works
are beyond the scope of this chapter.)
After the catch block, add a finally block that raises the
AuditProcessingComplete event, as shown in the following in bold:
Click here to view code image
Download from finelybook PI:EMAIL
690
private async void doAuditing(Order order)
{
    List ageRestrictedItems =
findAgeRestrictedItems(order);
    if (ageRestrictedItems.Count > 0)
    {
        try
        {
            ...
        }
        catch (Exception ex)
        {
            ...
        }
        finally
        {
            if (this.AuditProcessingComplete != null)
            {
                this.AuditProcessingComplete($"Audit record
written for Order  {order.OrderID}");
            }
        }
    }
}
7. In the DeliveryService project, open the Shipper.cs file in the Code and
Text Editor window.
8. Add a public delegate called ShippingCompleteDelegate to the Shipper
class. This delegate should specify a method that takes a string
parameter called message and that returns a void. The code in bold in the
following example shows the definition of this delegate:
Click here to view code image
public class Shipper
{
    public delegate void ShippingCompleteDelegate(string
message);
    ...
}
9. Add a public event called ShipProcessingComplete to the Shipper class,
based on the ShippingCompleteDelegate delegate as shown in bold in
the following code:
Click here to view code image
public class Shipper
Download from finelybook PI:EMAIL
691
{
    public delegate void ShippingCompleteDelegate(string
message);
    public event ShippingCompleteDelegate
ShipProcessingComplete;
    ...
}
10. Find the doShipping method, which is the method that performs the
shipping logic. In the method, after the catch block, add a finally block
that raises the ShipProcessingComplete event, as shown here in bold:
Click here to view code image
private async void doShipping(Order order)
{
    try
    {
        ...
    }
    catch (Exception ex)
    {
        ...
    }
    finally
    {
        if (this.ShipProcessingComplete != null)
        {
            this.ShipProcessingComplete($"Dispatch note
generated for Order
{order.OrderID}");
        }
    }
}
11. In the Delegates project, display the layout for the MainPage.xaml file in
the Design View window. In the XAML pane, scroll down to the first
set of RowDefinition items. The XAML code looks like this:
Click here to view code image
Download from finelybook PI:EMAIL
692
        ...
12. Change the Height property of the final RowDefinition item to 2* as
shown in bold in the following code:
   ...
This change in the layout makes available a bit of space at the bottom of
the form. You will use this space as an area for displaying the messages
received from the Auditor and Shipper components when they raise their
events. Chapter 25, “Implementing the user interface for a Universal
Windows Platform app,” provides more detail on laying out user
interfaces by using a Grid control.
13. Scroll to the bottom of the XAML pane. Add the following ScrollViewer
and TextBlock elements shown in bold before the penultimate 
tag:
Click here to view code image
      ...
This markup adds a TextBlock control called messageBar to the area at
the bottom of the screen. You will use this control to display messages
from the Auditor and Shipper objects. Again, you will learn more about
grid layouts in Chapter 25.
14. Display the MainPage.xaml.cs file in the Code and Text Editor window.
Find the CheckoutButtonClicked method and remove the code that
displays the summary of the order. The try block should look like this
after you have deleted the code:
Click here to view code image
Download from finelybook PI:EMAIL
693
private void CheckoutButtonClicked(object sender,
RoutedEventArgs e)
{
    try
    {
        // Perform the checkout processing
        this.checkoutController.StartCheckoutProcessing(this.order);
        // Clear out the order details so the user can start
again with a new order
        this.order = new Order
        {
            Date = DateTime.Now,
            Items = new List(),
            OrderID = Guid.NewGuid(),
            TotalValue = 0
        };
        this.orderDetails.DataContext = null;
        this.orderValue.Text = $"{order.TotalValue:C}");
        this.listViewHeader.Visibility = Visibility.Collapsed;
        this.checkout.IsEnabled = false;
    }
    catch (Exception ex)
    {
        ...
    }
}
15. Add a private method called displayMessage to the MainPage class.
This method should take a string parameter called message and should
return a void. In the body of this method, add a statement that appends
the value in the message parameter to the Text property of the
messageBar TextBlock control, followed by a newline character, as
shown here in bold:
Click here to view code image
private void displayMessage(string message)
{
    this.messageBar.Text += $"{Environment.NewLine}";
}
This code causes the message to appear in the message area at the
bottom of the form.
16. Find the constructor for the MainPage class and add the code shown
here in bold:
Click here to view code image
Download from finelybook PI:EMAIL
694
public MainPage()
{
    ...
    this.auditor = new Auditor();
    this.shipper = new Shipper();
    this.checkoutController = new CheckoutController();
    this.checkoutController.CheckoutProcessing +=
this.auditor.AuditOrder;
    this.checkoutController.CheckoutProcessing +=
this.shipper.ShipOrder;
    this.auditor.AuditProcessingComplete += this.displayMessage;
    this.shipper.ShipProcessingComplete += this.displayMessage;
}
These statements subscribe to the events exposed by the Auditor and
Shipper objects. When the events are raised, the displayMessage method
runs. Notice that the same method handles both events.
17. On the Debug menu, click Start Debugging to build and run the
application.
18. When the Wide World Importers form appears, select some items
(include at least one age-restricted item), and then click Checkout.
19. Verify that the “Audit record written” message appears in the TextBlock
at the bottom of the form, followed by the “Dispatch note generated”
message:
Download from finelybook PI:EMAIL
695
20. Place further orders and note the new messages that appear each time
you click Checkout (you might need to scroll down to see them when
the message area fills up).
21. When you have finished, return to Visual Studio 2017 and stop
debugging.
Summary
In this chapter, you learned how to use delegates to reference methods and
invoke those methods. You also saw how to define lambda expressions that
can be run by using a delegate. Finally, you learned how to define and use
events to trigger execution of a method.
If you want to continue to the next chapter, keep Visual Studio 2017