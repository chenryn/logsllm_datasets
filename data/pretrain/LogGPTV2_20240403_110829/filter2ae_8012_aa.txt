翻译自：  
“ Wait a minute. Using an RX modulator, I might be able to conduct a mainframe
cell direct and hack the uplink to the download.” — [Hackerman, Kung
Fury](https://www.youtube.com/watch?v=1uvr7CJazqE "Hackerman, Kung Fury")
# **0x00 - 前言**
本文是白话二进制漏洞攻击方式系列文章的第二部分。  
在整篇文章中，我们将介绍：  
0x01 - 必备知识：权限和异常处理  
0x02 - 防御：Stack Canaries  
0x03 - 攻击：格式字符串漏洞  
0x04 - 攻击：SEH Overwrites  
0x05 - 防御：DEP/NX  
让我们开始吧！
# **0x01 - 必备知识：权限和异常处理**
随着您越来越多地使用计算机，您可能会经常听到Kernel(内核)和userland(用户态)这两个术语。如果我们尝试搜索内核的定义，我们会发现：  
_内核是操作系统的核心，可以完全控制系统上的所有内容（处理器，内存，芯片等）。每当程序需要做任何事情（即写入文件，打开网络连接等）时，它都会暂时将对用户空间处理的控制权交给内核。_  
虽然这个定义让我们对内核的内容有了很好的理解，但让我们快速看看我的第五篇文章[Explain Spectre and Meltdown Like I'm 5
](https://hackernoon.com/explain-spectre-and-meltdown-like-im-5-494a6ba61061
"Explain Spectre and Meltdown Like I'm 5 ")的解释：  
_每当蝙蝠侠和正义联盟的其他成员在与超级罪犯作战时，阿尔弗雷德（蝙蝠侠的管家）（内核）就会控制蝙蝠侠的基地（处理者），这样他能够提供重要信息并帮助正义联盟获胜。当正义联盟击败坏人时，蝙蝠侠解除并收回了阿尔弗雷德的控制权。_  
为了减轻负担，内核是操作系统为您的应用程序完成所有繁重的工作（即内存管理等）的后端。而另一方面，用户态是常规应用程序运行内存空间。就像蝙蝠侠和正义联盟一样，用户态应用程序在需要特权信息时将控制权移交给内核（阿尔弗雷德）。  
这种权限分离的方式在计算机中大量使用。然而，虽然蝙蝠侠和正义联盟只有两类特权，但计算机有4个独立的“戒指”特权。  
如您所见，应用程序在最低权限环中运行。但是，显然有时应用程序需要访问某些特权信息或功能（即建立网络连接，内存管理功能等）。在这种情况下，应用程序将使用称为syscalls的特定函数，它们充当不同特权环之间的桥梁。  
形容特权戒指的一种简单方法可能是视频游戏中的等级：  
为了提高整个游戏中的一般能力（无论是升级护甲或武器，进入不同的世界，还是最终从[尖刺的乌龟身上拯救公主](https://www.mariowiki.com/Bowser
"尖刺的乌龟身上拯救公主")），玩家必须通过不同的关卡。如果玩家试图跳过一个级别，他/她就没有足够的力量或资源在他们跳到的关卡中击败BOSS！ 他们会失败！  
当用户态应用程序尝试访问特权信息时，应用程序将失败并出现异常。这意味着应用程序将崩溃并输出崩溃报告。除了尝试从非特权（用户空间）环境访问特权内存或函数之外，由于许多原因，程序可能都会因异常而失败。例如，如果一个程序试图将某个数据除以0（我们都知道不能这样做），程序将失败并抛出ArithmeticException的异常。  
现在，虽然简单地理解程序可能失败的原因很重要，但我们需要讨论程序失败时实际发生的情况。这就是结构化异常处理（SEH）的用武之地。在我们讨论结构化异常处理程序是什么以及它们如何工作之前，让我们以[夺宝奇兵](https://en.wikipedia.org/wiki/Indiana_Jones_%28franchise%29
"夺宝奇兵")为例：  
在1981年的电影“夺宝奇兵之法柜奇兵”中，琼斯和他的团队继续寻找失落的约柜方舟。沿着他的路线，琼斯和他的团队遇到了许多陷阱，例如毒镖和巨石，这些陷阱是由秘密的压力板或开关触发的。琼斯和他的团队必须努力生存通过所有这些陷阱，以实现他们的目标。  
在夺宝奇兵之法柜奇兵中，琼斯和他的团队必须通过整个地牢和洞穴中设置陷阱。这些陷阱是在琼斯出生前几年设计的，用来保护这次冒险的中心的金色雕像。同样，程序有各自的陷阱，从权限不匹配和访问拒绝到逻辑和算术错误，程序有很多方法可以防止（处理）错误或错误的操作。此外，程序员能够通过函数来实现自定义异常处理程序如try-catch代码块，利用try尝试代码块，再使用catch捕捉处理他们时发生的任何错误或异常。  
在许多操作系统中（我们将更具体地讨论Microsoft的结构化异常处理），正好有一个系统来处理最初未被异常处理程序捕获的任何异常。也就是说，如果捕获到错误但未正确处理错误，操作系统将提升异常处理的方式将捕获的异常重定向到单独的结构化异常处理程序。如果异常继续无法正确处理，应用程序将崩溃。  
另外需要注意的一点是，当程序因异常而失败时，程序会非常短暂地获得对更高级别的访问权限，因为系统会检索有关崩溃的信息。
# **0x02 - 防御：Stack Canaries**
在[上一篇文章](https://xz.aliyun.com/t/3980
"上一篇文章")中，我们讨论了堆栈缓冲区溢出以及能够覆盖堆栈上数据的危险（或利益，取决于您在攻击中所处的角色）。多年来，为了防御这些攻击，已经在编译器和操作系统中执行了许多类型的防御。在本节中，我们将讨论Stack
Canaries，它是一种非常常见且极其基本的溢出防御形式。  
Stack Canaries实际上是参考the canary in a coal mine（煤矿中的金丝雀）命名的。  
_在1913年左右，John Scott
Haldane建议在深矿中使用金丝雀或其他温血动物以检测一氧化碳。理论认为，由于鸟类的身体对一氧化碳比人类的敏感度高得多，如果矿工看到鸟儿不行了，他们就会知道空气被一氧化碳污染了，因此，在受到气体的影响之前就可以离开洞穴了。_  
就像煤矿中的金丝雀一样，Stack
Canaries会警告程序有些事情是不对的，允许程序在任何恶意操作发生之前退出。这是通过在为局部变量分配空间之后在堆栈上放置一个长随机数并在函数返回之前检查长随机数来完成的。如果堆栈缓冲区溢出攻击覆盖堆栈的canary，程序将退出。  
虽然Stack Canaries是针对溢出攻击的常用性防御，但它们远非无敌。我们接下来看看一些攻击。
# **0x03 - 攻击：格式化字符串漏洞**
击败Stack
Canaries的一种简单的方法是找出它们在堆栈中的位置和随机值是什么，这样你就可以在溢出攻击期间完全覆盖Canaries。但是，正如我之前提到的，Stack
Canary值是大的随机数，因此，要“知道”堆栈canary的位置就非常困难。此外，在为应用程序发掘漏洞时，您无法调试（在另一个特殊的程序中运行上述程序并在运行时通过控制其操作，显示数据和信息）这个程序并简单的查看堆栈/手动搜索Canaries。那么我们究竟如何检索这些信息呢？  
好吧，这就是格式字符串漏洞的来源。在我们讨论实际漏洞之前，让我们先谈谈格式字符串是什么。  
在许多编程语言中（虽然我们将在本文中专门讨论C），但有一个名为printf（或类似的东西）的输出函数。printf是用于格式化和打印数据的函数。要使用此功能，程序员输入：  
printf（“格式”，变量）  
例如，如果程序员想要打印出整数变量intvar的值，他们只需执行：  