17.16.2 缺陷2：覆写会影响调用方法
函数getOwnProperty()对obj调用hasOwnProperty()方法。通常，这样是可行的：
然而，如果对obj添加键为hasOwnProperty的属性，那么这个属性会覆盖方法Object.prototype. hasOwnProperty()，getOwnProperty()就停止了工作。
你可以通过直接引用hasOwnProperty()解决此问题。这样避免了通过obj找到该方法：
我们称hasOwnProperty()是泛型的（详见17.15“泛型方法：借用原型方法”）。
17.16.3 缺陷3：特殊属性__proto__
在许多JavaScript引擎中，属性__proto__（详见17.4.5“特殊属性__proto__”）很特殊：获取它即获取一个对象的原型，设置它即改变一个对象的原型。这就是为什么对象不能在键为'__proto__'的属性中存储映射数据的原因。如果希望允许使用映射的键为'__proto__'，你把它用作属性键前，必须对它进行转义：
我们还需要避免'__proto__'的转义版本带来的冲突；这就是说，如果我们把键'__proto__'转义为'__proto__%'，那么也需要转义“__proto__%”键，因此这样不能取代'__proto__'。这就是行（1）所发生的。
Mark S. Miller在一封电子邮件中提到了这个缺陷的现实意义（http://mzl.la/1fwnd1l）：
认为这个问题只存在于学术中，不会出现在现实系统中？直到最近，观察到在所有的非IE浏览器中，如果你在新建的Google Doc最开始输入“__proto__”，你的Google Doc会挂起。这就追踪到了使用对象作为字符串映射的缺陷。
17.16.4 字典模式：没有原型的对象更适合用作映射
可以像下面这样创建没有原型的对象：
这样的对象比普通对象更适合用作映射（字典），这就是为什么该模式有时被称为字典模式的原因。让我们先来看看普通对象，然后找出为什么无原型的对象更适合用作映射。
普通对象
通常，你在JavaScript中创建的每个对象的原型链上至少都有Object.prototype。 Object. prototype的原型是null，因此这是大多数原型链的终点：
无原型的对象
无原型的对象作为映射有两个优点。
继承的属性（缺陷#1）不再是问题，因为根本就没有继承。因此，现在你可以自由使用in操作符来检测属性是否存在，也可以用方括号来读取属性。
不久，__proto__将不能使用。在ECMAScript 6中，如果Object.prototype不在对象的原型链上，特殊属性__proto__会不可用。你可以期望JavaScript引擎逐渐演化到这种行为，但这尚不常见。
唯一的缺点是你会失去Object.prototype提供的服务。例如，字典对象不能再自动转换为字符串了：
但这并不是真正的缺点，因为直接在字典对象上调用方法并不安全。
建议
使用字典模式来快速解决问题，并作为类库的基础。在生产环境（无类库）代码中，推荐使用类库，因为可以确保避免所有的缺陷。在下一节中列出了几个这样的类库。
17.16.5 最佳实践
有许多应用程序使用对象作为映射。如果所有的属性键都认为是静态的（在开发时），那么你只需要确保忽略继承，并只查找自有属性。如果可以使用任意键，你应该使用类库来避免本节提到的这些缺陷。下面有两个例子：
StringMap.js（http://bit.ly/1fwnp0E）by Google’s es-lab（http://code.google. com/p/es-lab/）
stringmap.js（http://github.com/olov/stringmap）by Olov Lassus
17.17 备忘录：对象的使用
本节是一个快速参考，引导至更详细深入的解释。
对象字面量（详见17.1.2“对象字面量”）。
点运算符（.）(详见17.1.3“点运算符(.)：通过固定键值访问属性”)。
中括号操作符([])（详见17.1.5“中括号操作符（[]）：通过计算出的键访问属性”）。
获取和设置原型（详见17.4.4“获取和设置原型”）。
属性的遍历和检测（详见17.5“遍历和检测属性”）。
通过描述符获取和定义属性（详见17.8.3“通过描述符获取和定义属性”）。
保护对象（详见17.9“保护对象”）。
所有对象的方法（详见17.14“所有对象的方法”）。
[1] 以这种方式使用map()是Brandon Benvie的一个技巧。
第18章 数组
数组是从索引（从零开始的自然数）到任意值的映射。这些值（映射的范围）称为数组的元素。创建数组最简便的方式是使用数组字面量。这种字面量枚举出数组元素，而元素的位置隐式地声明了它的索引。
在本章中，首先介绍基本的数组机制，如索引访问和length属性，然后介绍数组方法。
18.1 概述
本节是关于数组的快速概述。后续会详细讲解。
第一个例子，我们通过数组字面量创建了一个数组arr（参见18.2“创建数组”），并访问其中的元素（参见18.3“数组索引”）：
我们可以使用数组的length（参见18.4“长度”）属性添加或移除元素：
数组方法push()提供了添加元素的另一种方法：
18.1.1 数组是映射，不是元组
ECMAScript标准声明数组可以作为从索引到值的映射。换句话说，数组可能不是连续的，中间可能会有空缺。例如：
上面的数组有个空缺：索引1处没有元素。18.5“数组中的‘空缺’”会更详细地解释空缺。
注意，大多数JavaScript引擎内部优化了数组，去除了空缺，并连续存储元素。
18.1.2 数组也可以具有属性
数组仍然是对象，并且可以拥有对象的属性。但并不认为那些属性是实际数组的一部分；因为不认为它们是数组元素。
18.2 创建数组
通过数组字面量创建数组：
数组最后的逗号会被忽略：
18.2.1 数组构造函数
使用Array构造函数有两种方法：可以创建给定长度的空数组，或给定元素的数组。对于数组构造函数，new是可选的：作为普通函数调用（不使用new）和作为构造函数调用是相同的。
创建给定长度的空数组
给定长度的空数组其中只有空缺！因此这样使用构造函数没什么意义。
当用这种方式调用Array()时，一些引擎可能会预先分配连续的内存，这样可以稍微提高性能。不过，要确保这种增长和冗余是值得的！
用元素初始化数组（应该避免！）
这种调用Array的方式类似于数组字面量：
问题是你不能用单个数字创建数组，因为数字会被理解为创建数组的length：
18.2.2 多维数组
如果你需要多个维度的元素，必须嵌套数组。当你创建这样的嵌套数组时，最内层的数组可以根据需要增加。但如果想要直接访问这些元素，你至少需要创建外层的数组。在下面的例子中，我创建了一个3×3的井字型矩阵。这个矩阵完全用数据填充（而不是需要时增加行数）：
下面是输出结果：
我希望这个例子可以说明一般问题。显然，如果矩阵较小且维度固定，可以通过数组字面量来设置。
18.3 数组索引
在使用数组索引时，你必须牢记以下限制。
索引i是数字，范围是0≤ i < 232−1。
最大长度是232−1。
在这个范围之外的索引被视为普通的属性键（字符串！）。它们不会作为数组元素呈现，且不影响length属性。例如：
18.3.1 操作符in与索引
操作符in检测对象是否具有某个给定键的属性。但它也可以用来判断一个数组中是否存在给定的元素索引。
18.3.2 删除数组元素
除了删除属性，操作符delete也可以删除数组元素。删除元素会产生空缺（不会更新属性length）。
你也可以通过减少数组长度来删除数组尾部的元素（更多详情请参阅18.4“长度”）。为了移除元素而不产生空缺（即后续元素的索引递减），你可以使用 Array.prototype.splice()（参见18.8“添加和删除元素（破坏性地）”）。这个例子中，我们在索引1处移除了两个元素：
18.3.3 数组索引的细节
提示：
 本节是进阶部分。通常你不需要知道本节介绍的这些细节。
数组索引并不是我们看到的那样。直到现在，我都在假设数组索引是数字。而这就是JavaScript引擎内部如何实现数组。然而这与ECMAScript规范理解的索引不同。15.4部分（http://bit.ly/1fwoCFg）会有解释。
属性键P（字符串）是某个数组的索引当且仅当ToString(ToUint32(P))等于P且ToUint32(P)不等于232−1。稍后会做解释。
数组属性的键是数组索引，这个属性称为元素。
换句话说，在规范中所有方括号中的值，甚至是数字，都可以转换为字符串且解释为属性的键。下面演示了这种情况：
作为数组索引，属性键P（字符串）必须等于以下计算结果：
（1）把P转换为数字。
（2）把数字转化为32位无符号整型。
（3）把整型转化为字符串。
这意味着数组索引i必须是字符串化的整型，且在0≤ i < 232−1的32位范围内。上限在规范（如前面的引用）中有明确说明。这是预留的最大长度。想要了解规范是如何处理的，可以使用函数ToUint32()，参见11.7.3“通过位运算符得到32位整数”。
首先，字符串不能包含总是可以转化为0的数字，字符串化之后，并不等于字符串。
其次，范围之外的字符串化的整型也会转化成完全不同的整型，字符串化后并不等于这个字符串：
第三，字符串化的非整型数字转换为整型，结果也是不相等的。
注意，这个规范也强制数组索引不能是指数：
并且索引前面不能有多余的0：
18.4 长度
属性length的基本功能是追踪数组的最大索引：
因此，length不计算元素的个数，你必须自己编写函数来实现。例如：
为了计算元素（非空缺）个数，我们需要使用forEach跳过空缺的元素。下面是运行结果：
18.4.1 手动增加数组的长度
手动增加数组的长度对数组几乎没有明显的影响，只会创建一些空缺：
最后的结果末尾有两个逗号，因为后面的逗号是可选的，因此总会被忽略。
我们刚才的操作没有添加任何元素：
然而，属性length作为指针指向插入新元素的位置。例如：
因此，通过Array构造函数设置数组初始长度，创建的数组都是空的。
18.4.2 减少数组的长度
如果减少数组的长度，在新长度及之后的所有元素都会被删除：
清空数组
如果把数组的长度设置为0，则数组变为空的。这样可以清空数组的元素。例如：
下面是运行结果：
然而，注意，这个方法比较慢，因为每个数组元素是显式地删除。具有讽刺意味的是，创建新的空数组通常都很快。
清除共享数组
你需要注意这样一个事实，把数组长度设置为0会影响共享此数组的对象：
相比之下，赋值为空数组却不然：
18.4.3 最大长度
数组最大长度是232−1：
18.5 数组中的“空缺”
数组是由索引（indice）到值（value）的映射。这意味着数组可以有“空缺”（hole），索引个数小于数组长度说明数组缺少一些元素。在缺少元素的索引处读取该元素会返回undefined。
提示：
 你最好避免在数组中创建空缺。因为JavaScript对它的处理不一致（即一些方法会忽略空缺，而另一些则不会）。值得庆幸的是，你通常不需要知道JavaScript是如何处理空缺的，这些处理的用处不大，而且会影响性能。
18.5.1 创建空缺
你可以通过给数组索引赋值来创建空缺：
你也可以通过在数组字面量中省略值来创建空缺：
警告：
 你需要在数组字面量后面添加两个逗号来创建最后的空缺，因为最后的逗号常常可以忽略：
18.5.2 稀疏数组和密集数组
本节介绍了空缺和undefined元素之间的差异。考虑到读取空缺会返回undefined，两者也非常相似。
含有空缺的数组称为稀疏（sparse）。不含空缺的数组称为密集（dense）。密集数组是连续的，且在每个索引处（从0开始，到length-1结束）都存在元素。比较下面两个数组，稀疏数组和密集数组。它们非常相似：
在相同索引处，空缺和undefined元素很相似。两个数组都有相同的长度：
但稀疏数组在索引0处没有元素：
两个数组for遍历的结果相同：
forEach循环会跳过空缺，而不会跳过undefined元素：
18.5.3 哪些操作会忽略空缺，而哪些不会
涉及数组的一些操作会忽略空缺，而另一些不会。本节会详细解释这些细节。
数组遍历方法
forEach()遍历时跳过空缺：
every()也会跳过空缺（类似的有some()）：
map()虽然会跳过，但保留空缺：
filter()去除了空缺：
其他数组方法
join()把空缺、undefined和null转化为空字符串：
sort()在排序时保留空缺：
for-in循环
for-in循环可以正确地列出属性键（数组索引的超集）：
Function.prototype.apply()
apply()把每个空缺转化成值为undefined的参数。下面的执行结果展示了函数f()把它的参数作为数组返回。为了调用f()把有三个空缺的数组传给apply()时，f()接受了三个undefined参数：
这意味着我们可以使用apply()创建包含undefined元素的数组：
警告：
 apply()把空数组中的空缺转换为undefined，但它不能用来填补任意数组（包含或不包含空缺）的空缺。例如，任意数组[2]：
没有任何空缺的数组，使用apply()应该返回相同的数组。相反，则会返回长度为2的空数组（它包含两个空缺）。这是因为Array()把单独的数字解释为数组的长度，而不是数组元素。
18.5.4 移除数组中的空缺
正如上面提到过的，filter()可以移除空缺：
使用自定义函数把任意数组中的空缺转化为undefined：
执行这个函数：
18.6 数组构造函数
Array.isArray(obj)
如果obj是一个数组，则返回true。这个方法会正确地处理跨域（window或frame）的对象——与instanceof正好相反（参考17.10.4小节的“缺陷：跨域（window或frame）”）。