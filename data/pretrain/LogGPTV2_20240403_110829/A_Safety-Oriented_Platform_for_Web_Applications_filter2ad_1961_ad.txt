86% (25 of 29)
improper labeling
By subverting DNS, an attacker can trick a browser into sending cached credentials to an IP address of the attacker’s choosing.
33% (4 of 12)
interface spoofing
Web content can override Mozilla’s user interface, allowing attackers to spoof interface elements or remote sites.
100% (11 of 11)
other
Though instructed by the user not to do so, Mozilla stores a password on disk.
total:
0% (0 of 2)
87% (95 of 109)
Table 2. Vulnerabilities. We show the percentage of Mozilla vulnerabilities that Tahoma contains or eliminates.
trast, Tahoma uses virtual machines as a language-
independent sandbox for the entire browser instance.
• Vulnerable sharing interface: Browsers contain
many programmatic interfaces (e.g., DOM access) and
user interfaces (e.g., ﬁle upload dialog boxes) for shar-
ing data across security domains. These interfaces can
often be subverted. In Tahoma, we limit sharing across
Web applications to a small set of browser-calls and
holding bin manipulation interfaces.
• Improper labeling: Browsers assign Web objects to
security domains using a complicated set of heuristics.
Incorrectly labeling an object as belonging to a do-
main can enable attacks such as drive-by downloads.
In Tahoma, Web services explicitly declare the scope
of their Web application through manifests.
• Interface spooﬁng: Browsers are susceptible to
spooﬁng attacks, in which a malicious site attempts to
occlude or replicate browser UI elements or the “look
and feel” of victim sites. In Tahoma, the Tahoma win-
dow manager decorates browser instances with labeled
borders that cannot be accessed or occluded.
• Other: Some vulnerabilities could not easily be clas-
siﬁed; this category is a “catch-all” for these.
We examined each of the 109 Mozilla vulnerabilities to
determine whether Tahoma successfully contains or elim-
inates the threat within the affected browser instance, or
whether the attacker can use the vulnerability to harm ex-
ternal resources or Web applications.
Table 2 shows the results of our analysis, broken down
by our vulnerability categories. As examples, we list one
speciﬁc attack that was seen for each category. The table
shows that Tahoma successfully contains or eliminates 95
of the 109 listed Mozilla vulnerabilities (87%). Many of
these vulnerabilities are browser implementation ﬂaws that
allow a remote attacker to inject code, extract ﬁles from
the user’s machine, or otherwise subvert the browser’s se-
curity mechanisms. Although Tahoma does not directly ﬁx
these vulnerabilities, its isolated virtual machines contain
the damage to a single browser instance and its application,
preserving the integrity of the user’s resources, the host op-
erating system, and other browser instances.
A good example of a contained vulnerability is an attack
on Mozilla’s SSL certiﬁcate management functions. An at-
tacker could deliver a malicious email certiﬁcate to Mozilla
that masks a built-in certiﬁcate-authority certiﬁcate, per-
manently blocking SSL connections to valid sites. Under
Tahoma, this attack would succeed on a susceptible browser
instance, but it would be contained to that instance.
4.2 Performance
Our analysis of Mozilla vulnerabilities demonstrates that
Tahoma can increase safety and security for Web browsing.
However, there is typically a tradeoff between safety and
performance. Given Tahoma’s use of VMs for isolation,
what is the cost of virtualization to the user and to the Web
application?
To answer this question, we ran several benchmarks to
quantify the performance of common Web-browsing opera-
tions and the overhead of Tahoma’s browser virtualization.
Our measurements were made on an Intel Pentium 4 proces-
sor with a 3.0GHz clock, 800MHz front-side bus, 1 GB of
RAM, and an ATI Radeon 9600SE graphics card. Network-
ing tests used an on-board Intel Pro/1000 NIC connected to
an Asante FriendlyNet GX5-2400 Gigabit Ethernet switch.
We booted Linux version 2.6.10 either directly on the CPU
or in Xen virtual machines, as indicated for each experi-
ment. For the Xen-hosted tests, the kernels included the
necessary Xen modiﬁcations, built from the Xen 2.0 unsta-
ble branch with patches through March 7, 2005.
4.2.1 The cost of virtual machine creation
Although the optimization of virtual machine performance
is well studied [4], virtualization still has a cost.
In par-
ticular, the Tahoma implementation frequently creates (or
forks) a virtual machine to execute a new browser instance.
Forks occur whenever the user enters the URL of a new Web
application. Therefore, we wished to measure the impact of
VM fork overhead on Tahoma users.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:31 UTC from IEEE Xplore.  Restrictions apply. 
Tahoma
fork()
native
Konqueror
open URL
operation
average latency
specialize a pre-forked
browser instance
clone a new VM, boot guest OS, 
launch browser program
1.06 seconds
9.26 seconds
load URL in running Konqueror
0.84 seconds
warm-start Konqueror
1.32 seconds
cold-start Konqueror
5.74 seconds
Figure 7. Browser fork latency. This table com-
pares the time to fork a new browser instance for
the Konqueror browser running on the Tahoma pro-
totype, and for Konqueror running on native Linux.
Figure 7 shows the cost of forking a new Tahoma
browser instance in a virtual machine compared to the cost
of starting a new browser in native Linux. The top half
of the table shows two different Tahoma cases. The ﬁrst
line shows the time to “specialize” a pre-forked browser in-
stance. Because we expect forking of commodity browsers
to be the common case, Tahoma maintains a pool of pre-
forked guest operating systems with stock browsers (we use
Konqueror on Linux for this test). When the BOS receives a
fork browser-call, it checks whether a pre-forked version of
the speciﬁed browser and guest OS is available. If so, then
the BOS need only set up the appropriate network policy in
a tinyproxy process and “specialize” the browser instance
by mounting its data disk. The time to instantiate and spe-
cialize a pre-forked browser instance is 1.06 seconds.
If a compatible pre-forked instance cannot be found in
the pool, then to service the fork, Tahoma must clone a new
VM, boot its guest OS, and launch the browser. The cost
for this full operation is 9.26 seconds.
For comparison, the bottom half of Figure 7 shows the la-
tency of opening a Konqueror window on native Linux. We
measured three cases: (1) the latency of opening a new win-
dow in a running Konqueror process, (2) the “warm-start”
latency of launching Konqueror, assuming it has been previ-
ously launched, and (3) the “cold-start” latency of launching
Konqueror on a cold ﬁle system buffer cache. Interestingly,
the best case latency with Konqueror on native Linux, 0.84
seconds for an already executing browser, is only slightly
(and imperceptibly) better than the time to launch a pre-
forked Tahoma VM, while a warm-start of Konqueror is
slightly worse than the pre-fork operation. The latency for
a Konqueror cold start on native Linux is 5.7 seconds, 60%
of the latency of a full VM clone and OS boot on Tahoma.
Both the cold-start and full-clone latencies are relatively
long; both could be reduced through optimization.
1000
)
s
m
(
y
c
n
e
t
a
l
100
10
1
1
1MB object
128KB object
10KB object
1KB object
2
3
4
5
6
7
8
# concurrent browser instances
Figure 8. Web object download latency (LAN).
this graph shows the latency of downloading Web
objects of different size, with varying numbers of
concurrent browser instances actively fetching the
object, over a LAN.
4.2.2 Network performance
From the user’s perspective, there are two key network-
related performance metrics: the latency of fetching a Web
page, and the achieved throughput when fetching a large ob-
ject. On Tahoma, all browser network communications ﬂow
through the Xen Domain0 VM, where they are ﬁltered by
tinyproxy according to the network policy. We measured
the latency and bandwidth overhead of this additional indi-
rection and ﬁltering.
To measure the Web-object fetch latency, we started sev-
eral concurrent browser instances, each scripted to fetch a
Web object repeatedly. We measured the average latency to
fully retrieve the object from a dedicated server on the local
network as a function of the number of concurrent browser
instances for different object sizes. Figure 8 shows the re-
sults. For a single browser instance fetching a 10KB Web
object, the measured fetch latency was 3.6 ms. With eight
concurrent browser instances, the latency for the 10KB ob-
ject grew to 20.1 ms. These results are encouraging, as
this latency is well below the 625 ms response-time thresh-
old for users to operate in an optimal “automatic response”
mode [30]. For large Web pages (1MB), the single-instance
latency was 57 ms; at eight concurrent instances, the latency
grew to 444 ms.
As the Web page size grows, the user’s perceived re-
sponse time is dictated by the system’s bottleneck band-
width. We repeated our latency measurements on a wide-
area network.
In all cases, network round-trip time and
bandwidth dominated the download latency: Tahoma was
not a bottleneck and had no impact on perceived latency in
a WAN setting.
We compared the throughput of a long-lived TCP con-
nection under Tahoma and native Linux. For this experi-
ment, we initiated a TCP connection from the client to a
server running on the local LAN and measured the sus-
tained throughput from the server. Table 3 shows our re-
sults. Surprisingly, Tahoma’s raw throughput exceeds that
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:31 UTC from IEEE Xplore.  Restrictions apply. 
scenario
TCP throughput
direct from domain 0
Tahoma
domain 1, routed through domain 0
domain 1, proxied through domain 0
native Linux
direct
through a local proxy
911 Mb/s
638 Mb/s
637 Mb/s
840 Mb/s
556 Mb/s
Table 3. Long-lived TCP throughput. This table
compares the TCP bandwidth achieved in Tahoma
and on native Linux.
of native Linux: Domain0 achieves 911 Mb/s bandwidth
from the server, compared to 840 Mb/s on native Linux.
High-bandwidth TCP connections are notoriously sensitive
to small parameter changes (such as send and receive buffer
sizes) or timing discrepancies. Accordingly, it is difﬁcult
to fully account for the performance differences, though we
attribute some of them to Xen performance optimizations,
such as interrupt batching.
From Table 3, we can isolate the costs of indirection
and proxying in Tahoma. Routing communications through
Domain0 from another VM reduces throughput by 30%,
to 638 Mb/s. The additional cost of the tinyproxy ﬁlter-
ing is almost negligible at that point. From these numbers,
we conclude that Tahoma’s throughput, even when ﬁltered
through a proxy in the Domain0 VM, is high enough to
support the vast majority of Web browsing workloads.
4.2.3 User interface performance
To measure the performance of the Tahoma window man-
ager, we ran a variable number of virtual machines, each
containing an MPlayer browser instance, which we con-
sider a “worst case” test. Each MPlayer application ren-
dered a 512x304 pixel DIVX/AVI video at 25 frames per
second. We increased the number of browser instances until
MPlayer reported that it could no longer sustain this frame
rate. We ran this benchmark under two Tahoma conﬁgura-
tions: (1) each MPlayer running as a browser instance un-
der Tahoma using Tahoma’s window manager, and (2) each
MPlayer running as a browser instance under Tahoma, but
using X11 to render to a Domain0 Xserver. We also ran
an experiment on native Linux, where each MPlayer ran as
a Linux process using shared-memory X11 to render to the
local Xserver.
Table 4 shows our results. Tahoma’s window manager
can sustain 12 MPlayer instances simultaneously, achieving
an order of magnitude better performance than X11 across
VMs. Native Linux with shared-memory X11 improves
on Tahoma by 70% (20 sustained instances), but it lacks
Tahoma’s isolation beneﬁts. Tahoma’s ability to support 12
simultaneous video players indicates that multiplexing win-
dows from multiple VMs should not pose a visible perfor-
mance problem for Tahoma users.
display system
unit of execution
# sustained MPlayers
Tahoma graphics
(networked) X11
VM
VM
(shared-memory) X11
process
12
1
20
Table 4. Graphics throughput. This table com-
pares the maximum number of sustainable MPlayer
instances under different scenarios.
To measure Tahoma’s input performance, we recorded
the delay between the time a user presses a key and the
time the corresponding character is rendered by a Kon-
queror browser instance. To do this, we instrumented Xen
to timestamp physical keyboard interrupts and instrumented
Konqueror to timestamp character rendering events. In the
simple case of a single Konqueror browser instance, the in-
put echo time was under 1 ms. In an attempt to increase
window management interference, we measured the same
input event with 10 MPlayer browser instances running 10
video streams concurrently. When competing with the ten
MPlayer instances, the Konqueror echo time remained be-
low 12 ms, still imperceptibly small to the user.
4.3 Summary
This section examined the safety, effectiveness, and per-
formance of the Tahoma implementation. We used a list
of 109 security vulnerabilities in the Mozilla browser to
evaluate Tahoma’s effectiveness at containing threats. Our
analysis shows that Tahoma can contain or eliminate 87%
of the vulnerabilities discovered in Mozilla. Next, we ran
benchmarks to quantify the performance cost of Tahoma’s
VM-based isolation mechanism. Our benchmarks demon-
strate that despite virtualization, indirection, and proxying,
Tahoma can achieve the latency, throughput, and respon-
siveness characteristics demanded by the vast majority of
browsing applications.
5 Related Work
Tahoma is a composite of architectural elements that iso-
late Web applications and provide users with a safer expe-
rience. Several of Tahoma’s architectural components have
been explored in various forms in the past, as has the gen-
eral topic of improving Web security. We discuss this re-