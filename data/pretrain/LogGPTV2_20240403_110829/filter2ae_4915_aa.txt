如果我们选择`JavaScript`作为编程的首选语言，那么我们不必担心字符串连接问题。然而我们经常遇到的一个反复出现的问题是必须等待`JavaScript`的`npm`包管理器安装完成所有必需的依赖项。
在这篇文章中，我们研究了为什么字符串连接是一个复杂的问题，为什么不能在没有转换的情况且在低级编程语言中连接不同类型的两个值，以及字符串连接如何导致漏洞。
我们还将分析如果格式字符串包含某些类型数据的占位符，如果它们受到攻击者控制，则会导致严重问题。之后，我们将选择一种简单的方法来解决他们。
首先，让我们看一下JavaScript字符串连接，它在连接不同类型的数据时会遇到不同的情况。 这里有些例子：
    1 + 1 === 2                               // 很显然
    '1' + 1 === '11'                            // 很直观
    1 + true === 2                          // 对吗？
    1 + {} === '1[object Object]'    // 什么时候需要这种情况？
    true + undefined === NaN   // 这显然不是一个数字，但它是什么？
    typeof NaN === 'number'    // 好 那接下来呢？
毕竟，JavaScript并不是那么完美。 而且，虽然在JavaScript中连接两个不同类型的值很容易，但它不一定会产生预期且有用的结果。
一些混淆是因为：在JavaScript中，连接运算符与添加运算符相同，因此它必须决定是连接值还是添加它们。
让我们来看看另一种不是非常严谨的语言，比如PHP。 它如何处理串联？ 好吧，在PHP中你没有plus运算符。 而是使用如图所示的点：
    "The number one: " . 1          // 如其工作
    "10" . 1 === "101"                      // 这只是在字符串10中添加1
    "10" . 1.0 + "1.0"                       // 猜测下这个语句是用来做什么的？
显然，这是(`float)102`。我们将字符串`“10”`与`float 1.0`连接起来，这生成字符串`“101”`。
然后将字符串“1.0”添加到字符串“101”中，最后得到（浮点）102。 这非常容易理解。 我们可以将两个字符串一起添加，最后得到float类型的值。
### 字符串连接的基础知识
我们可以讨论PHP的输出系统存在的问题以及它如何导致现实生活中的漏洞（参见PHP类型漏洞的详细说明）。
但是我们不得不承认JavaScript和PHP中的字符串连接非常方便。
如果使用像C这样的低级语言这样做会发生什么吗？ 如果我们试图在字符串中添加一个浮点数，C语言并不会预期执行。
在此示例中，C不知道我们要实现的目标。 C甚至不允许你将两个字符串添加到一起来连接它们，更不用说不同数据类型的字符串了。
这里，字符串只是一个字符序列，末尾有一个`NULL`字节。 通常，有一个指向字符串第一个字节的指针。 错误消息中的`char *`引用该指针。
在`JavaScript`中，我们需要担心`NULL`字节或指针。 字符串在`JavaScript`中也是不可变的，因此我们不能只更改其中的数据。
相反，如果需要更改数据，则需要创建一个新字符串，并保持旧字符串不变。
在这个例子中，我们试图将“String”一词改为“Strong”，但它不起作用。 x变量不会改变。
虽然这个功能作用有限，但是它实际上是一个非常好的功能。它能够提示我们曾用过JavaScript中的对象。
### 连接不同的数据类型很难
`double`是指所谓的“双精度浮点数”。对于那些不知道的人，浮点数作为一个神秘的字节序列存储在内存中，但似乎这样没有意义。这样做的原因是它们通常以IEEE
754中定义的格式存储在科学记数法中（参见分步教程二进制分数和浮点数）。
C如何将一个字符串加入一个奇怪的字节组合，即浮点数，在内存中一起保留它们的初始含义？
答案是：不能。如果将浮点数附加到字符串的末尾并相应地移动NULL字节，则只会将这些字节视为文本，并尝试打印无法显示的垃圾或字符。这在JavaScript中是不可想象的;这是C编程中的常见问题。
因此，为了将浮点数添加到字符串，C需要首先将其IEEE 754格式转换为人类可读的字符串表示。为此，C库提供`* printf`系列函数。
### 安全的C语言
如果要将任何类型的数据放入字符串中，或将字符串连接在一起，则只需使用`printf`即可。 我们需要传递一个格式字符串，其中包含指定数据类型的占位符等。
我们来看一个例子。
如果我们编译此代码并运行它，它将只打印`'This is a string。'`。
可能已经猜到，`％s`是字符串的占位符，但也存在其他数据类型的占位符，例如整数，浮点数甚至单个字符。 您还可以以十六进制表示形式打印数据。
然而，有一个问题。 如果你错误地使用它，它是完全不安全的。
应该如何在C中连接两个字符串？
许多人都会咨询`Stackoverflow`，因为它是一个关于常见问题的直截了当的回答网站。
最高投票的答案使用`strcat`，一个根本不检查任何大小的函数，这在C中总是一件坏事，因为如果你不小心它会导致缓冲区溢出。
问题下方的评论建议使用`strlcat`，人们认为它是一个更安全的strcat版本。 但后来其他人建议使用`strcat_s`。
这似乎是另一个更安全的strcat版本。
`Stackoverflow`中的其他人喜欢使用`snprintf`，根据评论，这显然是“大不了”，因为显然`_snprintf`是不安全的。
但是，另一个帖子叫做停止使用`strncpy`了！ 提到它可以使用。 如果您还不熟悉`Stackoverflow`或C，那么这个线程完美地说明了两者的问题。
### 格式字符串漏洞
我已经提到 _如果使用不正确，`_ printf`函数会很危险。 但是，一个功能，其唯一目的是格式化输出，如何导致可能导致任意代码执行的漏洞？
详细答案超出了本博文的范围，但这里是一个概述。 局部变量和函数参数存储在内存中的特殊位置 - 堆栈上。 对于x86
Linux二进制文件，这通常意味着一旦调用函数，它将直接从堆栈中获取函数参数。 那么如果你有一个没有参数的printf调用会发生什么呢，如下所示？
    printf("%x%x%x%x%x");
它将简单地抓取堆栈中的数据并以十六进制格式打印。
这可能包括堆栈和返回地址，堆栈cookie（旨在防止缓冲区溢出利用的安全机制），变量和函数参数的内容，以及对攻击者非常有用的所有其他内容。
因此，如果`printf`中的格式字符串是用户可控制的，那就非常危险。
此外，如果使用足够的格式说明符，最终可能会得到一个指向用户可控输入的堆栈指针，就像格式字符串本身一样。
然后，我们可以向内存中的任何位置提供地址，并使用`％s`读取数据。 此外，如果启用了`％n`，则可以在内存中的任何位置写入任意数据，即已打印的字节数。
这听起来不是很多，但它可能允许攻击者覆盖返回地址，并将代码流重定向。
### Web应用程序是否包含格式字符串漏洞？
格式字符串不仅在C中可用。以下是其他语言，我们还可以在其中找到它们用于Web应用程序。
#### PHP
如果熟悉PHP，那么可能知道它还具有`printf`函数。 但是，PHP将检查是否有比函数参数更多的格式说明符（除了少数例外）。
如果在C中以不安全的方式使用printf，通常只会收到编译器警告.PHP会简单地中止脚本的执行。
#### Ruby
Ruby类似于PHP。 当尝试使用Ruby的printf函数时，它会将参数的数量与其对应的格式说明符进行比较。 如果说明符多于参数，则执行将停止。
#### Perl
Perl是不同的。 Perl很乐意接受传递给它的格式说明符，但结果不会很有用。 但是，我们可以使用％n说明符覆盖已经打印的字符数的变量。 这是一个代码示例：
    $str = "This is a string";
    printf("AAAAAAAAAAAAAAAAAAAAAAAA%n\n",$str);
    print($str); # this is 24 now, as there were 24 'A's printed
还有一个不那么明显的问题。 Perl中大量的比较结果是出乎意料的。
它与PHP类似，我们需要在比较时使用“eq”标识符而不是`==`符号，以便进行或多或少的严格比较。 因此，而不是`1 == 1`你会写`1 eq 0.
==`显然是大多数人的方式，比在每次比较中键入`“eq”`更方便。 如果我们查看Perl表，我们可以看到整数0与任何字符串相比，返回一个匹配项。
现在看下面的代码：
    $databasePassword = "secret pass"; #unknown to attacker
    $password = "A password"; #user supplied string
    # ... some more code ...
    printf("%n ", $password); #writes integer 0 into $password variable
    # ... some more code ...
    if($databasePassword == $password) { # this will match!
            print("Password matches");