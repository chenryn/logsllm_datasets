    } else {
            print("Password does not match");
    }
此代码将打印“密码匹配”。 这个问题是你甚至不需要一个整数来通过检查。 即使字符串“0”也会起作用。
（PHP有类似的问题，但它至少需要一个整数，你不能作为GET或POST参数传递。）
如果它允许更改可能不是用户可控制的输入值，则此方法仍然有用。 这可能会导致代码中的潜在可利用行为。
如果您想了解有关Perl中其他不安全行为的更多信息，请参阅Perl Jam 2。
#### Lua
是否知道人们在Lua中编写Web应用程序？ 甚至还有一个用于特定目的的Lua Apache模块。 例如，我在路由器中看到了基于Lua的Web应用程序。
这可能是由于Lua的体积非常小，因此适合在磁盘空间紧张的路由器中使用。 Lua也可用作“魔兽世界”界面自定义的脚本语言。
似乎下一个逻辑步骤是使用它来编写Web应用程序。
它还有一个类似于`printf`的`string.format`函数。 它仅支持一组有限的格式说明符，％n不是其中之一。
另外，它检查参数的数量是否与格式说明符的数量相匹配。 如果不匹配，则会发生错误。
#### Java
Java中有一个`System.out.printf`函数。 与大多数其他语言一样，它检查参数的数量是否与格式说明符的数量相匹配。
同样，有一个`％n`说明符，但它没有做到你所期望的。 出于某种原因，它将为正在运行的平台打印相应的行分隔符。
如果你是来自C，这会令人困惑，但你不能指望与Java的格式字符串兼容，即使两个函数具有相同的名称。
#### Python
`Python`是一个非常有趣的案例，因为它有两种不同的常用字符串格式化方法。
`PyFormat`网站致力于Python中的字符串格式化，认为Python自己的文档“过于理论化和技术化”。
首先，使用我们已经知道的格式说明符的旧方法。如下所示：
    print("This is %s." % "a string")
如我们所见，这使用格式字符串后跟百分号。 参数写在符号后面。 如果有多个参数，则需要使用元组。 这里`％n`不受支持。
此外，将参数的数量与格式说明符的数量进行比较，如果`python`不匹配则抛出错误。
但是还有一种新的字符串格式化方法。 我们可以通过在字符串上调用内置的`.format`方法来使用它。
    print("{} is {} years old".format("Alice", 42))
它甚至允许我们从格式字符串中访问传递的对象的属性。
    print("{person[name]} is {person[age]} years old".format(person={"name":"Alice","age":42}))
正如我们所看到的，他们两个都打印出“爱丽丝已经42岁了”。 它们并不真正需要格式说明符，因为Python会在大多数时间自动将它们转换为正确的字符串表示形式。
但是，第二种方法可能会导致信息泄露漏洞。
一篇名为`Be Careful with Python`的新式字符串格式的博客文章很好地描述了这种方法。
基本上，根据传递的数据，攻击者可以读取敏感信息，远远超出我们的意图。 我们来看一个例子吧。
    API_KEY = "1a2b3c4d5e6f"
    class Person:
       def __init__(self):
           """This is the Person class"""
               self.name = "Alice"
               self.age = "42"
    print("{person.name} is {person.age} years old".format(person=Person()))
虽然这一开始似乎没有漏洞，但如果攻击者可以在此处控制格式字符串，则可以轻松打印`API_KEY`变量。但它是如何工作的？
首先，知道person对象包含的不仅仅是我们设置的名称和年龄属性，这一点很重要。它还具有可直接访问的`__init__`功能。
Python实例化Person类时会自动调用它。它仍然是格式字符串中可用的用户定义函数。但是我们能在这做什么呢？我们无法从格式字符串中调用函数。但是，我们可以访问属性。
在Python中，函数具有一些通常不需要使用的特定属性。例如`__name__`表示函数的名称。但是，这里有另一个有用的属性，叫做`__globals__`。文档描述如下：
'对包含函数全局变量的字典的引用 - 定义函数的模块的全局命名空间。
这很有趣，因为根据定义，`API_KEY`变量位于`__init__`函数的全局命名空间中。这给我们留下了以下格式字符串。
    "API_KEY: {person.__init__.__globals__[API_KEY]}".format(person=Person())
之后输出的结果为：
    API_KEY: 1a2b3c4d5e6f
还有其他这样的键，例如`__doc__`，它打印函数的文档字符串（可能产生一些有用的信息）。 还有其他文件名。 完整列表在Python文档内容中提供。
我对Python不太熟悉，不知道博客文章中提供的修复是否合适，但它类似于我建议避免使用的黑名单方法。
如果需要向用户提供格式字符串，则可能需要使用旧格式。 但是，一般来说，我建议尝试避免格式字符串中的用户输入。
### JavaScript
通常，`JavaScript`不需要任何格式字符串。 你应该使用内置的替换功能自己实现它们，这完全不令人沮丧和过于复杂。
有外部库模仿它们，但由于`JavaScript`库的总数很大，因此检查每个库中的意外行为是一项不可能完成的任务。
尽管如此，`JavaScript`为我们提供了一种格式化输出的方法，无需替换和连接。 我们可以使用所谓的模板文字。
顾名思义，你不能在运行时动态创建这样的字符串，除非你使用像`eval`这样的函数，但我强烈建议不要这样做。
这是一个例子：
    const name = "Alice";
    const age = 42;
    console.log(`${name} is ${age} years old`)
我们使用反引号，在美元符号后面的花括号之间写入变量名：`$ {var}`。
由于没有简单的方法让用户能够定义他们自己的模板文字而不允许他们执行任意`JavaScript`代码，我想指出模板文字在绕过黑名单过滤器时是`JavaScript`中最好的东西。
为什么？ 这样的过滤器可以删除所有`"(" and ")"`字符，因此很难执行JavaScript代码。
例如，仍然可以使用`onerror`事件处理程序和`throw`关键字，但模板文字更方便，具体取决于要执行的函数。
我们只需在函数名称后面编写模板文字即可执行：
    alert`some popup message`
这就是为什么黑名单永远不是一个好主意。
### 格式化字符串和XSS
XSS漏洞和格式字符串还存在另一个威胁。如果使用格式字符串函数生成的输出容易受到XSS的攻击，则应尽快修复此问题。但是大多数用户都有一个安全网，除了那些在iOS之外使用Firefox的用户。大多数版本的谷歌浏览器，Safari，IE和Edge都有一个内置的XSS过滤器，定期更新。
问题在于这些过滤器的工作方式。它们比较用户输入和服务器发回的生成输出。如果它们足够相似并且包含危险的标签或参数，则不会呈现页面或删除危险输入。这些过滤器随着时间的推移变得更好，但它们仍然不是万无一失的。因此，如果在服务器端处理输入并进行更改，则筛选器将不会检测到该漏洞。在下面的示例中，Chrome目前不会检测到XSS漏洞，并会执行JavaScript代码。
    //server side code
    printf(user_input, "Alice", 42);
            URL:
    https://example.com/?user_input=
输出将是``，并将出现一个警告弹出窗口。
### 避免使用包含用户输入的格式字符串
格式字符串漏洞的影响在很大程度上取决于我们使用的语言。 一般的经验法则是避免使用包含用户输入的格式字符串。
相反，我们应该始终将该输入作为参数传递给格式化函数，这是避免与格式字符串相关的漏洞的通用方法。 当然，我们应该始终根据将要使用的上下文清理用户提供的输入。
我们现在应该对Web应用程序和其他地方的格式字符串利用有一个基本概述。 我建议测试`Netsparker Web`应用程序安全扫描程序。
它与最流行的持续集成解决方案和问题跟踪系统无缝集成，让我们有更多时间阅读Web应用程序漏洞，减少对它们的担忧。
    本文为翻译文章，原文为：https://www.netsparker.com/blog/web-security/string-concatenation-format-string-vulnerabilities/