i =0 2i xi.
end if
for i = 0 to ℓ − 1 do
if xi = 1 then
Sample a ← Bci
if a = 0 then return 0
1: function SampleBernExp(x ∈ [0, 2ℓ ) ∩ Z)
2:
3:
4:
5:
6:
7:
end for
return 1
8:
9: end function
1: function SampleBernCosh(x)
Sample a ← Bexp(−x /f )
2:
if a = 1 then return 1
3:
Sample b ← B1/2
4:
if b = 1 then restart
5:
Sample c ← Bexp(−x /f )
6:
if c = 1 then restart
7:
return 0
8:
9: end function
µ, one first generates commitment values y1, y2 ∈ R with normally
distributed coefficients, and then computes a hash c of the message
µ together with u = −aqy1 + y2 mod q. The signature is then the
triple (c, z1, z2), with zi = yi + si c, and there is rejection sampling
to ensure that the distribution of zi is independent of the secret key.
Verification is possible because u = −aqz1 + z2 mod q.
The real BLISS scheme, described in Figure 1, includes several
optimizations on top of the above description. In particular, to im-
prove the repetition rate, it targets a bimodal Gaussian distribution
for the zi’s, so there is a random sign flip in their definition. In
addition, to reduce key size, the signature element z2 is actually
transmitted in compressed form z†
2, and accordingly the hash input
includes only a compressed version of u. See also the full version of
this paper [21] for a description of key generation and verification.
Implementation of the BLISS rejection sampling. It is essential for
the security of the scheme that the distribution of signatures is
essentially statistically independent of the secret signing key. This
is achieved using the rejection sampling step 8 of algorithm Sign,
as described in Figure 1.
and B1/ cosh(x /f )
To implement this rejection sampling in practice, one needs to
be able to efficiently sample from Bernoulli distributions of the
form Bexp(−x /f )
for some fixed constant f and
variable integers x (where Bp denotes the Bernoulli distribution of
parameter p, which outputs 1 with probability p and 0 otherwise).
This can in principle be done by computing the rejection prob-
ability every time with sufficient precision and comparing it to
uniformly sampled randomness in a suitable interval, but such an
approach is quite costly, especially on constrained devices, as it
relies on the evaluation of transcendental functions to arbitrary
precision. Therefore, BLISS relies on an alternate approach, which
is described in [14, §6] and can be implemented based on sampling
Bernoulli distributions Bci
for a few precomputed constants ci.
, one can
consider the binary expansion(cid:80) xi ·2i of x, and let ci = exp(−2i /f ).
Then one has exp(−x/f ) =(cid:81)
xi =1 ci. As a result, sampling from
; if all the
Bexp(−x /f )
resulting samples are 1, return 1, and 0 otherwise. This can even be
done in a lazy manner, as described in algorithm SampleBernExp
in Figure 2.
The idea is as follows. To sample from Bexp(−x /f )
can be done by sampling from each of the Bci
In addition, one can show that sampling from B1/ cosh(x /f )
can
be done by repeated sampling from Bexp(−x /f )
and B1/2, as de-
scribed in algorithm SampleBernCosh in Figure 2 (the correctness
of that method is proved as [14, Lemma 6.3]). The algorithm has an
a priori unbounded number of iterations, but the expected number
of calls to Bexp(−x /f )
Concretely, the BLISS rejection sampling is thus implemented
as follows. The denominator f in SampleBernExp and Sample-
2, and the scaling factor M for the rejection
BernCosh is set to 2σ
sampling is taken of the form exp(K/f ) for some integer K. Then,
step 8 of Sign in Figure 1 actually consists of the instructions de-
scribed in Figure 3.
is less than 3.
3 ATTACKS ON THE REJECTION SAMPLING
As discussed in §2, the original BLISS paper describes an efficient
technique to carry out the rejection sampling during signature gen-
eration [14, §6], based on iterated Bernoulli trials. This technique
is used in particular in embedded implementations such as [46].
1: x ← K − ∥Sc∥2
2: Sample a ← SampleBernExp(x )
3: if a = 0 then restart the signing algorithm
4: x ← 2 · ⟨z, Sc⟩
5: if x < 0 then x ← −x
6: Sample a ← SampleBernCosh(x )
7: if a = 0 then restart the signing algorithm
From the description of algorithm SampleBernExp in Figure 2,
one can easily infer that its input x will be leaked in full on a power
or EMA trace whenever the entire for loop contained in it executes
in full (which is always the case when the algorithm returns 1).
This leakage is validated in the practical experiments of §3.3.
Now the signature generation algorithm Sign of BLISS only
passes the rejection sampling step if the calls to both SampleBern-
Exp and SampleBernCosh return 1. This means that a side-channel
attacker can recover the entire inputs to both of these functions,
which are K − ∥Sc∥2 and 2 ·(cid:12)(cid:12)(cid:12)⟨z, Sc⟩(cid:12)(cid:12)(cid:12) respectively. Thus, one can
obtain the squared norm ∥Sc∥2 on the one hand, and the scalar
product ⟨z, Sc⟩ up to sign on the other hand. However, since the
computation of the absolute value also leaks the sign of that value
on a power/EMA trace due to the conditional branch, one actually
obtains the full value ⟨z, Sc⟩ in practice. In this section, we describe
how these leaked values can be exploited for key recovery.
3.1 Exploiting the scalar product leakage
We first describe how to exploit the leakage of the scalar product
values:
⟨z, Sc⟩ = ⟨z1, s1c⟩ + ⟨z2, s2c⟩,
assuming that the adversary can somehow recover the whole un-
compressed signature (c, z1, z2). In that case, the attack is essentially
straightforward: indeed, each such leaked value is the evaluation
of a linear form with known coefficients on the vector S = (s1, s2)
seen as an element of Q2n. And it is clear that those linear forms
on Q2n generate the entire dual vector space of Q2n as (c, z1, z2)
vary.
This means that if we collect the leakage values associated with
sufficiently many signatures (slightly more than 2n is enough in
practice), we obtain a full-rank linear system in the coefficients of
S, and hence we can recover the entire secret key by simply solving
that linear system.
This attack does not apply to real implementations of BLISS,
however, due to signature compression: real BLISS signatures do
not contain the entire element z2 but only a compressed version
z†
2 that depends only on the higher-order bits of the former. As a
result, the previous approach fails to apply. We cannot even use it
to reduce the dimension of the underlying lattice problem, because
a leaked scalar product reveals less information about the secret
key than the number of unknown bits of z2 in view of the signature.
Thus, a more sophisticated approach is necessary, based on the
leaked Euclidean norms ∥Sc∥2.
3.2 Exploiting the norm leakage
Let’s suppose we can have access by SPA to the bits of ∥Sc∥2 in
the final computation of the rejection sampling. Recalling that
Sc = (s1c, s2c)T , we have ∥Sc∥2 = ⟨s1c, s1c⟩ + ⟨s2c, s2c⟩ and thus
this norm can be seen as CT · ΣT · Σ · C, where C = (c, c)T and
 ,
0
S2
 S1
0
Σ =
Figure 3: BLISS rejection sampling implemented in terms of
Bernoulli trials.
for c being the vector encoding of the polynomial c, and S1 (resp.
S2) being the skew-circulant matrix encoding the polynomial s1
(resp. s2). Let X be the matrix ΣT · Σ. Then, recovering the value
4
∥Sc∥2 yields an equation of the shape:
.
(1)
This equation can be viewed as a row of a linear system whose
unknowns are the coefficients of the secret-dependent matrix X.
cT · X · c = ∥Sc∥2
Since X is a block matrix of shape Diag(cid:16)
(cid:18)
circulant matrices of first line
m/2+1, 0,−x (i )
x (i )1 , x (i )2 , x (i )3 ,· · · , x (i )
X (1), X (2)(cid:17) where X (i ) are
(cid:19)
m/2+1,· · · ,−x (i )3 ,−x (i )2
as product of two conjugate skew-circulant matrices. Thus, only
2 × m/2 = m distinct unknowns are actually present in X. As a
consequence we only need m linearly independent equations to
fully recover the matrix X. Once recovered, we therefore get access
to the submatrices ST1 · S1 and ST2 · S2. By definition, this matrix
corresponds to the encoding of the polynomial s1 · ¯s1 and s2 · ¯s2,
that is the relative norm of the secrets s1 and s2 in the totally real
subfield. Using techniques from algebraic number theory we can
retrieve both parts of the secret up to multiplication by a root of
unity. Precisely, this is performed using our generalization of the
Howgrave-Graham–Szydlo algorithm [35], presented in Appen-
dix A. Actually once one value s1 · u1 or s2 · u2 (with u1, u2 roots
of unity), we can use our knowledge of the public key s2/s1 mod q
to recover candidates for the other part of the secret (once again
up to unity). Hence when candidate secrets are determined, we can
discriminate valid keys among them by checking their sparsity and
polynomial height, to satisfy the conditions imposes by the key
generation procedure. The whole attack is described in Figure 4.
The mostly costly part of the attack is the generalized Howgrave-
Graham–Szydlo algorithm from Appendix A, and in particular the
step of norm factorization over the integers. In order to estimate
the cost of this factorization step, one can bound the algebraic norm
of the secret element. A classical computation on resultants (see
Appendix A.5 for a detailed argument) entails that this norm is
bounded (somewhat crudely) as:
(cid:18)
(cid:113)
(cid:19)
.
log |N (s)| ≤ n
2
log(n
2
1 + 4δ
2
2 ) + 1
δ
Table 1 compiles the theoretical bound and the average practical
results for the various proposed security parameters.
We can see that these integers are typically too large to be fac-
tored in practice. Since the success of the attack depends on the
ability to factor the norm, we are only able to attack a fraction
of the whole space of private keys, for which the factorization is
easy. A particular class of them is the set of keys whose norm is
a B-semi-smooth integer, that is a composite number p · b, where
p is prime and b is B-smooth for an non-negative integer B. As
already remarked, the recovery of either s1 or s2 is sufficient to
recover the full secret. Hence the above-described attack becomes
tractable as soon as one of the norm N (s1),N (s2) is semi-smooth.
1: Collect traces (c(k ), ∥Sc(k ) ∥2
of the corresponding system is full-rank.
2: Solve the linear system C · X = (∥Sc(1) ∥2
3: Call Algorithm 12 on either s1 · ¯s1 or s2 · ¯s2 to recover s1 and s2 up
)k until the matrix C corresponding
, . . . , ∥Sc(k ) ∥2
)T .
to a root of unity.
Figure 4: Exploiting the norm leakage in BLISS.
5
Table 1: Estimation of the absolute norms of BLISS secret
keys for the security parameters of [14] (experimental aver-
ages over 2000 keys per set).
n
256
BLISS-0
512
BLISS-I
512
BLISS-II
BLISS-III
512
BLISS-IV 512
Bit size of N (f )
(δ1, δ2)
theoretical
exp. avg.
(0.55, 0.15)
(0.3, 0)
(0.3, 0)
(0.42, 0.03)
(0.45, 0.06)
1178
2115
2115
2332
2422
954
1647
1647
1866
1957
This means that the probability of getting a weak key is twice the
probability of one of the constituting part of the private key to have
a semi-smooth norm. Practical estimations of the fraction of keys
with semi-smooth norms are presented in Table 2.
Note that the entire attack is actually known to run on aver-
age in polynomial time, except, classically, the factorization of the
norm.Amusingly, this means that the attack becomes quantumly
fully polynomial: this is an interesting feature for an attack target-
ing a postquantum scheme!
The entire attack was implemented in PARI/GP, including the
generalized Howgrave-Graham–Szydlo algorithm and the Gentry–
Szydlo algorithm. To the best of our knowledge, this was the first
full implementation of this algorithm. It allows to tackle the problem
of solving norm equations in dimension up to 5121 Experiments
were conducted with this implementation to obtain the running
time the attack and presented in Table 3, on a single core of a Xeon
E5-2697 2.6 GHz CPU.
3.3 SEMA experiments against microcontroller
Experimental setup. Experiments were conducted on the same
target that the one used for development in [46] that is an XMEGA-
A1 Xplained board with a ATxmega128A1 micro controller, running
at a frequency of approximately 20 MHz. Traces were obtained by
measuring the electromagnetic radiations using a Langer EM H-
Field probe (30MHz-3GHz) and a MITEQ amplifier (up to 500MHz
with gain 63dB). Acquisition was performed using a Lecroy Wave-
Master 8300A oscilloscope. For the norm recovery we used a sam-
pling frequency of 5 MHz to obtain a good-looking picture but good
results may also be obtained with smaller sampling rates. The more
relevant position for the probe (i.e. the one providing the clearer
patterns) was over the ground capacitance and not over the chip
itself (which is not that surprising since the chip was packaged).
Experimental result. Section 3.2 shows that from a leaked set of
norms ∥Sc∥2 , we are able to fully recover the secret value S. We
show here how such norm can easily be recovered in the imple-
mentation proposed in [46] (we recall this implementation was not
supposed to be secure since optimized for performance).
(cid:17). The main point to notice here is the and
We can see in Figure 5 an extract of the code performing the
rejection sampling procedure. It corresponds to the probability
M exp(−∥Sc∥2
1/
1In their original paper, Howgrave-Graham and Szydlo were limited to smaller di-
mension (up to 100) and did not implement all the possible cases occurring in the
algorithm.
/(2σ
(cid:16)
2
)
Table 2: Estimation of the proportion weak BLISS secret keys, namely those for which at least one of s1 or s2 has B-semi-
smooth norm, for the security parameters of [14] and several choices of B. Estimates obtained by sampling 2000 secret keys
per parameter set and testing their norm for semi-smoothness by trial division.
n
256
BLISS-0
BLISS-I/II
512
BLISS-III/IV 512
B = 2
4%