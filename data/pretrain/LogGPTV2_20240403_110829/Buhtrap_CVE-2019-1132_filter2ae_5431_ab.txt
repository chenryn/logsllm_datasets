减一之后。
可以看到此时hunt tagWnd对象的bServerSideWindowProc字段已经被设置。
此时向hunt窗口发送指定消息，触发shellcode执行并替换进程令牌以实现越权。
这里有一个疑问，就是如果使用我之前的老版本的win7测试，发现漏洞并不能触发，看了下代码发现老版本的win32k.sys驱动中的xxxTrackPopupMenuEx函数中，并没有调用xxxUnlockMenuState导致。
可以看到对应的tagPOPUPMENU并没有设置为null。
但是这并不是意味着老版本的win32k中没有xxxUnlockMenuState，实际上只是在xxxTrackPopupMenuEx中没有调用而已.
### 补丁对比
微软的补丁修改中直接将xxxMNOpenHierarchy中HMAssignmentLock触发函数前设置了null监控，防止传入对应null地址。
## 恶意代码部分
Eset在其文章中给出两个该组织投递的恶意样本，具体的md5如下，虽然这两个攻击样本都不是0day事件中使用的样本，但是eset的文章中提到攻击中使用的手法是一致的，因此从这些样本中我们能看看这个团伙在攻击中使用样本的一些特点。
b54b618a9a6abd879e6703a9a4a53e94
f36fe1716c9e38fa39186b63339ebee6
### b54b618a9a6abd879e6703a9a4a53e94
该样本打开之后如下所示：
点击确认宏运行之后，真正的载荷如下所示
可以看到是企业合同相关的内容。
Vbs恶意代码会将对应的恶意exe及实际诱饵文档拷贝到office目录下，如下图所示诱饵文档为myfile.rtf。
对应的恶意exe伪装为putty程序。
实际的诱饵和恶意exe是写到控件中的。
如下所示，释放到office目录下的诱饵和恶意exe。
该putty实际上是通过nsis打包的安装文件，通过7zip打开如下所示：
$0：实际的恶意代码
$PLUGINSIDR:辅助nsis脚本的插件，实际就是一个写好的dll
[NSIS].nsi:具体的nsis脚本
可以看到nsis是windows下安装程序的制作程序，需要注意的是nsis中是通过脚本语言来描述安装程序的行为和逻辑的，这就给了攻击者很大的操作空间，我们可以在第二个样本中看到。
该样本的nsis脚本很简单，一开始通过HideWindow字段标记该次安装为隐藏安装，之后调用fun_3，fun_3将压缩包中$0目录下的文件释放到指定目录，通过插件CreateMutex创建互斥量38A81F7C-266A-4509-82E2-34C6E0956EF7，最后调用fun_0.
fun_0中将avz.exe设置开机启动，并运行。
释放的恶意代码目录如下：
Avz.exe:该文件是一个白文件，通过其加载对应update.dll及winspool.drv文件
Update.dll:该文件是一个密码窃取工具，主要用于窃取受害者机器上浏览器，邮箱等凭据
Winspool.drv:一个buhtrap常用的后门
**Winspool.drv**
Winspool.drv是一个dll，由avz.exe加载，对应的入口如下所示：
样本中使用的字符串都通过加密算法加密，一共使用了三种加密手段，且每个字符使用不同的密钥，调用时的堆栈也有所区别，以增加安全人员的分析成本。
主函数中的fun_HooksysApi用于hook系统api
showwindow/createwinodwex/shell_notifyicona，如下所示fun_Hookapi函数中依次传入hook目标api地址，用于保存hook
api头部内容的内存地址，hook回调函数。
fun_Hookapi中首先保存了目标api的前几个字节的内容。通过VirtualProtect修改目标api内存页属性，写入对应的jmp
hook指令，最后VirtualProtect再次调用，以恢复之前的内存页属性。
fun_StoretheOriginaddress中直接通过memcpy的方式保存hook 目标api前几个字节的内容。
如下所示CreateWindowEx的hook效果如下：
但是看过对应的hook回调函数，就会发现实际上这个样本中的hook没有作用，如下所示，hook回调的任务就是将执行流又传递给系统api，因此这里猜测这个hook
api的功能目前应该还只是测试阶段，而攻击者应该是希望通过hook api的方式来转移样本的执行流程，类似银行木马icedid的操作。
对应的主线程中的代码如下所示，一共再次启动了三个线程其中
线程一：主线程
线程二：键盘记录
线程三：类似守护线程。
fun_Connectcc中解密出对应的cc
主线程函数如下所示:
fun_ForsmartCard中用于读取和电脑设备连接的smart card信息
和cc连接，并下载对应的payload，payload猜测有包含后续smartcad dump相关的内容。
加载后续的payload，支持exe和dll。
线程二创建了一个窗口，被设定了对应的窗口回调。
窗口回调中通过GetRawInputData的方式实现键盘记录
需要注意的是该键盘记录只记录指定的进程，如下所示
线程三中监控系统中是否存在互斥量38A81F7C-266A-4509-82E2-34C6E0956EF7，该互斥量由一开始的nsis脚本创建。
加载模块update.dll。
**Update.dll**
Update.dll相关的窃取目标如下所示:
### f36fe1716c9e38fa39186b63339ebee6
该恶意文档打开如下所示，诱饵文档的内容是用户如何通过一系列操作看到文档的真实内容，但是这些操作实际是执行恶意宏的过程。
该样本同样通过恶意vbs执行释放文件，如下所示。
确认运行之后的真实内容。
主要是一份采购清单。
释放的恶意exe同样是一个nsis的安装程序，但是这个样本相较前一个就比较复杂了
$PLUGINSDIR:辅助nsis脚本运行的插件，这个样本中使用了多个插件
$TEMP:保存了对应的凭据窃取工具，和前一个样本一致
$0:一段用于load 的shellcode
$0_1: Meterpreter
[NSIS].nis:对应的nsis脚本
$PLUGINSDIR中的插件如下所示：
Createmutex.dll:用于设置互斥量相关的操作，这也是前一个样本中使用到的唯一一个插件
nsExec.dll:用于辅助nsis脚本执行cmd命令
System.dll:用于辅助nsis脚本调用系统api
Nsis脚本同样通过HideWindow设置隐藏安装，之后调用函数func_516.
该nsis脚本为了获取更为强大的功能，通过调用插件System.dll的方式来调用windows系统api，如下函数就直接调用了VirtualAllocEx函数。
func_516经过一系列处理之后调用函数fun_389.
fun_389设置开机启动，并修改了防火墙的过滤规则，以允许恶意代码和cc的通信，之后调用fun_224.
文档释放的最终nsis安装包。
通过nsis设置了具体的开机启动项
fun_224用于在内存中直接加在两段shellcode，具体步骤如第一个红框所示。
最终shellcode $0,$0_1通过一个线程启动。
Shellcode如下所示:
第一段load shellcode
第二段包含Meterpreter的shellcode
## 参考链接