DCOM Errors
This section discusses some of the problems you will encounter
when working across a network. I've tried to outline some of the
approaches I've found useful in diagnosing and fixing problems.
My company deploys a product that uses DCOM to connect
a GUI and server. We have installed it at several thousand sites.
Our customers have a tremendous variety of networks and con-
figurations, and we spend a lot of time debugging remote con-
nections. The software itself if very stable, but network
configurations are not. I have learned a lot about DCOM trying
to debug difficult installations.
Unfortunately, when you use DCOM over a network, you're
probably going to encounter a lot of problems. The more net-
work configurations you work with, the more problems you'll
have.
Debugging network issues falls somewhere between a sci-
ence and voodoo. Having access to a competent network admin-
istrator is a blessing. In the real world however, network
administrators are often not available, so the programmer has to
resolve problems himself or herself.
Following is a series of steps that I use when working on
DCOM issues.
Get It Working Locally
The first step in the debugging process is to get the client and
server working locally. Install both components on the server
machine, and keep at it until you can successfully communicate.
If a component won't work locally, it won't work across a net-
work. You probably developed and tested the application on a
single computer, but be sure to test it on the server system also.
By getting the system to work locally, you've eliminated
most of the common programming errors. There are still a few
things, like security and remote activation, that you can only test
across the net. Specify your local computer in the COSERVER-
INFO structure, which will exercise some of the network-related
code.
286    Appendix •
COM Error Handling 
Be Sure You Can Connect
Before you even try to install your program, debug the network
configuration using whatever tools you have available. Start by
checking the network neighborhood, and ensure that you can
browse the remote computer. This is not always possible, and a
failure to browse doesn't preclude DCOM working. In most
cases, however, browsing is good starting place for checking
connections. Check the connection in both directions.
Perhaps the most useful tool is PING. Ping sends a series of
network packets to the server and waits for a response. Most
installations support PING.
C:\>ping www.ustreas.gov
Pinging www.treas.gov [207.25.144.19] with 32 bytes of data:
Reply from 207.25.144.19: bytes=32 time=209ms TTL=247
Reply from 207.25.144.19: bytes=32 time=779ms TTL=247
Request timed out.
Reply from 207.25.144.19: bytes=32 time=852ms TTL=247
Ping statistics for 207.25.144.19:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 209ms, Maximum =  852ms, Average =  460ms
PING does a number of interesting things for you. First, it
resolves the name of the remote computer. If you're using TCP/
IP, the name of the remote computer will be turned into a TCP/
IP address. In the above example, PING converts the name
"Raoul" into the TCP/IP address [169.254.91.12]. 
You should also try PING from both directions. If you are
using callbacks or connection points, you must have COM work-
ing in both directions. Callbacks and connection points can be
very difficult to debug.
Figure A–1
The ping command
DCOM Errors
287
Additonal Information and Updates: http://www.iftech.com/dcom
Try Using a TCP/IP Address
Name resolution can be a vexing problem in remote connec-
tions. Most people want to work with names like "\\RAOUL"
and "\\SERVER", rather then TCP/IP addresses. The process of
turning that readable name into a network address is called
"Name Resolution", and it can be very complicated on some sys-
tem configurations. A common work-around is to refer to the
server by its TCP/IP address. This will eliminate many name res-
olution problems - which are outside the scope of this discus-
sion. You can easily put a TCP/IP address into the
COSERVERINFO structure, instead of a standard computer name. 
Use TRACERT
You can also glean interesting information from the TRACERT
utility. If you have any weird network configurations, they may
show up here. Here is typical output:
c:\>tracert www.ustreas.gov
Tracing route to www.treas.gov [207.25.144.19]
over a maximum of 30 hops:
  1   181 ms   180 ms   169 ms  ct1.intercenter.net [207.211.129.2]
  2   188 ms   188 ms   170 ms  ts-gw1.intercenter.net [207.211.129.1]
  3   176 ms   187 ms   190 ms  ilan-gw1.intercenter.net [207.211.128.1]
  4   547 ms   505 ms   756 ms  core01.rtr.INTERPATH.NET [199.72.1.101]
  5   516 ms   323 ms   338 ms  tysons-h2-0.rtr.INTERPATH.NET [199.72.250.26]
  6   184 ms   708 ms   216 ms  mae-east2.ANS.NET [192.41.177.141]
  7   576 ms   981 ms   423 ms  h12-1.t60-8.Reston.t3.ANS.NET [140.223.61.25]
  8   419 ms   804 ms   570 ms  f5-0.c60-14.Reston.t3.ANS.NET [140.223.60.210]
  9   314 ms   641 ms   621 ms  www.treas.gov [207.25.144.19]
Trace complete.
As you can see, the route your DCOM packets are taking to
their destination may be surprising! Beware of gateways, routers,
proxies, and firewalls - they can and will block your connection. 
Figure A–2
The tracert command
288    Appendix •
COM Error Handling 
Windows 95/98 Systems Will Not Launch Servers
Hopefully this will change in the future. If your server is on Win-
dows 95/98, you must manually start it before connecting from a
remote computer. There is actually a very good security reason
for this limitation. Because authentication on Windows 95/98 is
so limited, there is no way to ensure that unauthorized users
don't launch your server.
Windows NT systems have no such limitation. NT is fully
capable of validating remote users and launching servers safely.
Unfortunately, it is also capable of rejecting legitimate users
because of set-up problems.
See Chapter 14 for details.
Security is Tough
Assuming you've got the physical network connections working,
you're going to have to get through several layers of security.
This is especially an issue on Windows NT, which has an
extremely rich and complicated security layer.
A discussion of network security is well beyond the scope
of this book. We can, however, point out a few useful tools. See
also chapter 14 for a detailed discussion.
DCOMCNFG is your first line of defense when working with
COM security. DCOMCNFG allows easy access to most security
settings.
If you look at the "Common Error Messages" section above,
you'll see that many of the error messages are related to security.
This is not accidental. One of the tenets of good security is to
deny outsiders any information about your security set-up. This
makes error messages especially unhelpful. When the security
sub-system detects an error, it won't give you a useful error mes-
sage. By telling you what you did wrong, it is also giving you
information about its configuration - which is a security no-no. 
If you're working with NT, it logs some security messages in
the event viewer. Be sure to check this information if you're get-
ting un-helpful security messages.
Using the OLE/COM Object Viewer
289
Additonal Information and Updates: http://www.iftech.com/dcom
Using the OLE/COM Object Viewer 
This utility is also known as OLEVIEW. This utility is a useful tool
when diagnosing registration issues. This tool was originally
developed for viewing OLE interfaces, but it works for all COM
interfaces. This tool is essentially a view of the registry and type
libraries. The information seen in OLEVIEW all originates in the
registry. OLEVIEW does more than just view registry keys; it also
runs servers and interrogates type libraries for information. 
Under newer versions of the Developer Studio, OLEVIEW
shows up under the TOOLS|OLE/COM Object Viewer menu.
Note that there are a number of different versions of OLEVIEW
in circulation, and you'll get different results from each of them.
The older versions show much more limited information.
When you start the viewer, you'll be presented with a num-
ber of folders. COM classes and interfaces may show up under
several of these folders.  We're going to use OLEVIEW to find
our IDLTestServer server.
Select the "Object Classes" folder. Inside that folder select
the "Automation Objects" folder and expand it. Search down for
the "BasicTypes Class". This is the class we created in the chapter
on MIDL. If you haven't built or installed the example programs,
this class will not exist. If this is the case, just pick some other
class for viewing.
When you double click on the "BasicTypes Class" object,
several very interesting things happen. 
The left hand column will show the interfaces supported by
the class. In this case, we'll see our custom IBasicTypes class, as
well as a number of standard COM interfaces that are imple-
mented through ATL.
The right hand column displays detailed information about
the server and its interfaces. You can make changes to several
aspects of the server here. For example, you can designate that
the server runs on a remote machine by making changes in the
"Activation" tab.
One of the most fascinating aspects of OLEVIEW is that it
actually activates and connects to the server, if possible. When
you examine the running processes while using OLEVIEW, you'll
290    Appendix •
COM Error Handling 
actually see the highlighted server is running. Of course, if
there's a problem with the server, you'll get an error message. 
This means that you can use OLEVIEW to actually debug
your COM classes. If you can expand the server with OLEVIEW,
the registration was successful. 
There are several types of information visible through OLE-
VIEW. We've already seen where it lists automation classes. If
you want to see all the interfaces registered on your system,
open the "Interfaces" folder. This folder lists all the interfaces,
custom and dispatch that are registered.  There are a lot of them.
You can also open and view type libraries. Look under the
"Type Libraries" tab. Expanding the type libraries under this
folder shows you the stored IDL information in the library.
You should spend some time exploring this tool. It can be
very useful finding and fixing registration problems. It is also a
useful way to change security settings.
INDEX
Index
Index
#IMPORT 253
$(OutDir) 103
$(TargetPath) 103
__uuidof 256
__variant_t 135
_com_error 258
_com_issue_error 258
_COM_SMARTPTR_TYPEDEF 256
_ICpTestEvents 215
A
access permission 235
AccessPermission 235
Activation 71
Active Template Library 28
ActiveX 27, 125
adding properties 142
AddRef 82
Advise 184, 225
AfxBeginThread 205, 208
AfxGetApp 200
aggregation 23, 269
AllocSysString 118
angle brackets 253
apartment threads 153, 155, 158
using 163
API 178
AppID 170, 172
registration 174
application identifier 174
argument
named 130
array
conformant 119
fixed 120
fixed length 115
multi-dimensional 120
open 120
varying 119, 121
asynchronous event 181
ATL 28, 246
fundamental classes 252
generated code 55
server self registration 174
threading models 156
ATL wizard 30, 156
attribute 97, 109, 113
authentication 237
automation
OLE 125
B
base type 108
bi-directional 183, 213
binding 127
early 136
boolean 108, 113
Both threads 156
both threads 161
browsing 136
BSTR 113
byte 108
C
callback 183
chronology of events 201
connection points 213
custom interface 183
example 185
callback interfaces 181
calling methods 24
CBeepObj 60
292    Index
CCallBack 215
CComAggObject 252
CComCoClass 145, 148, 252
CComDynamicUnkArray 227
CComModule 177, 193
CComMultiThreadModel 160, 252
CComObject 198
CComObjectRoot 194, 252
CComObjectRootEx 158, 227, 252
CComPtr 252, 256
CComQIPtr 252, 256
CComSingleThreadModel 158, 252
CComVariant 135
CCpTest 215
char 108
class
definition 62
factory 77
store 168
class declaration 2
class wizard
adding properties 142
client 45
connectivity 20
running with server 40
simplest 19
CLSCTX 23, 88
CLSCTX_INPROC_SERVER 88
CLSCTX_LOCAL_SERVER 88
CLSCTX_REMOTE_SERVER 88
CLSID 22, 87, 170, 171
registration 171
CLSIDFromString 257
CO_E_BAD_SERVER_NAME 280
CO_E_CANT_REMOTE 280
CO_E_NOTINITIALIZED 280
CO_E_SERVER_EXEC_FAILURE 281
coclass 6, 100
CoComObject 79
CoCreateInstance 22
CoCreateInstanceEx 231, 233
CoGetClassObject 79
CoGetInterfaceAndReleaseStream 207
COINIT 157
COINIT_APARTMENTTHREADED 157
COINIT_MULTITHREADED 157
CoInitialize 21
CoInitializeEx 21
CoInitializeSecurity 239
COM
array attributes 120
class context 23
client 19
creating clients 43
creating servers 43
directional attributes 109
distributed 14, 229
error handling 277
identifiers 87
interfaces 68
language independent 68
map 139, 194
MFC 246
network 4
object viewer 289
pointer values 110
principles 67
process 3
registry structure 168
server threading models 153
string attributes 114
subsystem initializing 21
threading model 151
transparency 69
typical errors 280
vocabulary 5
COM interface
pure virtual 74
COM object
adding 33
interface 8
typical 11
unique 5
COM server 4, 14
DLL based 29
simple 27
CoMarshalInterThreadInterface-
InStream 206
Index
293
communication 6
compiler support 245
component class 100
components 10
conformant 119
connection point 213
classes 215
container 224
interfaces 215
containment 269
contract 69
cookie 187, 188
COSERVERINFO 231
CoTaskmemAlloc 117
CoTaskMemFree 117
CoUninitialize 22
coupling 89
CreateInstance 78, 79, 198
CreateObject 128
CString.AllocSysString 231
custom build 97, 103
custom callback 182
custom marshaling 95
CWinApp 195
D
data transfer 107
DCOM 14, 229
errors 285
DCOMCNFG 288
default pointer 99
DEFAULT_CLASSFACTORY 79
delta pinging 243
design of COM 3
destructors 257
disconnection 242
dispatch interface 140
DISPID 129
DISPPARAMS 129
distributed COM 14, 229
DLL 14, 29
DllRegisterServer 178
DllUnregisterServer 178
domain name 12
double 108, 112
dual interface 98, 99, 125, 137
VTABLE 138
Dynamic Link Library 14, 29
E
E_ACCESSDENIED 281
E_FAIL 282
E_NOINTERFACE 282
E_OUTOFMEMORY 282
E_POINTER 111, 283
early binding 127, 136
enumerations 121