# 【技术分享】胖客户端程序代理：HTTP(s)代理是如何工作的？
|
##### 译文声明
本文是翻译文章，文章来源：parsiya.net
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
翻译：[h4d35](http://bobao.360.cn/member/contribute?uid=1630860495)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**译者序**
**本文是Thick Client
Proxying系列文章中的第6篇，前几篇主要介绍了Burp的使用，而这一篇则详细介绍了代理的工作原理，因此单独挑出本文进行了翻译。**
为了编写我们自己的可定制的代理程序，首先我们需要知道代理是如何工作的。在[ **Proxying Hipchat Part 3: SSL Added and
Removed Here**](https://parsiya.net/blog/2015-10-19-proxying-hipchat-part-3-ssl-added-and-removed-here/)一文中，我想编写一个自定义代理工具（一个简单的Python脚本即可实现），因此我不得不回过头去学习它们的工作原理。我在网上没有找到从信息安全角度分析代理的文章。大多数文章只是在说如何配置缓存或转发代理，但是关于**中间人（Man-in-the-Middle，MitM）**代理的内容则寥寥无几。我在[
**那篇文章**](https://parsiya.net/blog/2015-10-19-proxying-hipchat-part-3-ssl-added-and-removed-here/)的第二节中简要介绍了这一点。在本文中，我将对此进行深入分析。实际上我还读了一些RFC，令人惊讶的是这些RFC写得相当好。
如果您想跳过简介，可以直接跳至第3节。
**0\. 为什么我需要知道代理是如何工作的？**
这个问题问得好。大多数情况下，我们只需要将浏览器的代理设置为Burp，就能开箱即用。但是，如果出现一点小意外，我们将进入恐慌模式。如果Web应用使用了Java或Silverlight组件，并且它有一些古怪的东西怎么办？另一个原因是，我还想使用Burp代理胖客户端程序（Thick
client application），因为Burp不仅仅能够代理Web应用程序。我的意见是：“
如果应用程序使用了HTTP协议，你就能够使用Burp进行代理
”。为胖客户端程序设置代理不是一件容易的事（通常情况下，仅仅将流量重定向到代理服务器就让人痛苦不堪了）。如果我们不知道代理的工作原理，我们就无法解决这些问题。
现在你确定你需要看下去了吗？确确确确确……定吗？
**1\. ”变成“一个代理**
在阅读本文时，尝试从代理的角度看问题有助于理解，至少对我来说是有用的。代理其实像一个观察者，它不知道系统内部发生的任何事情。作为观察者，我们只能决定代理自身的行为。”当用户在浏览器中输入google.com时，代理程序必须将请求发送到google.com”，那么代理是如何知道这一点的呢？毕竟代理程序还不能神通广大到能够“看到”浏览器的地址栏。
**1.1 这是什么意思？**
假设我们是代理程序。我们唯一能够看到的是客户端（例如浏览器）和目标端点（Endpoint）发送给我们的请求/数据包，除此之外其他信息我们一概不知。作为一个代理，我们必须依靠所知道的有限信息，决定如何处理收到的请求数据。
现在希望我们能够专注一点，开始吧！
**2\. 两种代理简介**
接下来我将讨论两种类型的代理。
**转发代理（Forwarding proxies）**
**TLS终止代理（TLS terminating proxies）**
这些描述不完全准确或详细，但对我们的目的来说足够了。当然这不是详尽的列表，还有其他类型的代理，但我们只对这两种代理感兴趣。讲真，其实我们只对TLS终止代理感兴趣。
**2.1 转发代理**
我们之前应该都遇到过，例如我们每天都能见到和使用的企业代理。如果您在企业环境中，请检查代理自动配置（proxy auto-config,
pac）脚本。本质上它是一个文本文件，它告诉应用程序应该向哪里发送流量，并根据目标端点重新路由流量。通常，如果目标端点在内网，则流量通过内部网络正常传输；反之，那些通过互联网发送的请求则被发送至转发代理服务器。你可以在[Microsoft
Technet](https://technet.microsoft.com/en-us/library/cc985335.aspx)中看到一些示例。从应用程序的角度来看，转发代理位于企业内网和互联网之间。
由**转发代理**的名称可知，这种代理只转发数据包，却看不到加密的有效内容（例如TLS）。从典型的转发代理的角度来看，一个建立的TLS连接只是一堆含有随机的TCP有效载荷的数据包。
**2.2 TLS终止代理**
Burp就是典型TLS终止代理。如果你知道Burp做了什么（可能是因为你正在阅读本文），你就会明白什么是TLS终止代理。这种代理通常是网络连接的**中间人**，代理程序会解开TLS数据包来查看有效载荷。
这种代理可以是像Burp或Fiddler等这类通常用于（安全）测试的应用程序，或者也可以是像Bluecoat这样的设备或Palo Alto
Networks的“thing”
（不管它它叫什么名字）的[SSL解密模块]( )。这些设备通常用于深度包检测。
您可以通过将所有目标端点添加到Burp的[SSL Pass
Through](https://parsiya.net/blog/2016-03-27-thick-client-proxying—part-1-burp-interception-and-proxy-listeners/#1-4-ssl-pass-through)配置项中来使Burp像转发代理一样工作，这对于排除连接错误非常有用。
**2.2.1 并不总是TLS**
是的。有时我们的代理会解密（或解码）非TLS加密（或编码）层。我将这一类别中的所有代理也划归为TLS终止代理，因为TLS已成为保护传输中数据的最常用方法。
**3\. HTTP(s)代理如何工作**
现在我们终于聊到正题了。在所有示例中，我们有一个使用代理（通过一些代理设置）的浏览器，浏览器知道它连接到一个代理（稍后我会谈到这一点）。
**3.1 HTTP代理**
在这种情况下，浏览器正在使用纯HTTP（意味着没有TLS）。在这种情况下，转发代理和TLS终止代理的工作方式类似。
假设我们在浏览器中输入了
。实际情况下，这里会产生一个302重定向，让我们暂时忽略这一点，并假设yahoo.com可以通过HTTP进行访问。或许我应该使用example.com举例，但是我比较懒，不想重新画图了。
浏览器和代理之间建立了一个TCP连接（著名的三次握手），然后浏览器发送GET请求。
Wireshark中看到的GET如下图所示（我们可以看到数据明文，因为这里没有TLS）。
现在，我们（代理）必须决定将这个GET请求发送到哪里。请注意，代理（Burp）和浏览器都位于同一台电脑上，所示上图中的源IP和目标IP均为127.0.0.1。因此，我们无法根据目标IP地址转发请求。
这个GET请求与不设置代理情况下的GET请求有何不同呢？我禁用浏览器的代理设置并重新捕获相同的GET请求，如下图所示。
注意上图中的高亮部分。发送到代理的请求具有`absoluteURI`。简单来说，发送到代理的GET请求的第二个参数是完整的URI（或URL），代理程序据此发现目标端点。`absoluteURI`最早在RFC2616（讨论HTTP/1.1）中被讨论。在[
**5.1.2节 请求URI**](https://tools.ietf.org/html/rfc2616#section-5.1.2)中，我们可以看到：
当请求目标是代理程序时，需要采用 **absoluteURI** 的形式。
…
例如以下GET请求：
GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
在较新的RFC中，您可以通过`absolute-URI`关键词查找到相关内容。此格式被称为`absolute-form`。在*[RFC7230 –
HTTP/1.1：消息语法和路由](RFC7230 – HTTP / 1.1：消息语法和路由)*中，*[第5.3.2节 absolute-form](https://tools.ietf.org/html/rfc7230#section-5.3.2)*中可以看到：
当向代理程序发出请求时，除了`CONNECT`或服务器范围的`OPTIONS`请求（如下所述）之外，客户端**必须**以`absolute-form`的形式发送目标URI。
absolute-form = absolute-URI
请注意，RFC要求客户端无论什么请求均发送`absolute-URI`（即使他们正在使用`CONNECT`请求）。
代理程序根据`absolute-URI`将请求转发到目标端点（在本例中为Yahoo!）。在这种情况下，转发代理和TLS终止代理的均以类似方式工作，因为它们都可以看到请求报文内部的HTTP有效载荷。
**HTTP代理流程如下：**
1、浏览器建立和代理之间的TCP连接。
2、浏览器将HTTP请求（使用`absolute-URI`）发送到代理。
3、代理建立与yahoo.com之间的TCP连接（使用`absolute-URI`）。
4、代理转发HTTP请求。
5、代理收到响应。
6、代理关闭与yahoo.com的连接。
7、代理将响应转发给浏览器。