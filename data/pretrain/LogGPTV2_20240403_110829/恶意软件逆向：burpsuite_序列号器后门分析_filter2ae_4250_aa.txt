# 恶意软件逆向：burpsuite 序列号器后门分析
##### 译文声明
本文是翻译文章，文章原作者 lkw，文章来源：0x00sec.org
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
> 免责声明：本文中包含病毒样本，处理该样本存在一定的安全风险，后果自负。如果条件允许，请使用虚拟机来运行该样本。
### **特别鸣谢：吾爱破解论坛提供无后门安全版本**
### **Burp Suite Pro Loader &Keygen By surferxyz（附带v1.7.31原版）**
### **https://www.52pojie.cn/thread-691448-1-1.html**
### **(出处: 吾爱破解论坛)**
## 一、前言
昵称为@the_heat_man的某些随机新“用户”多次在各种论坛上发布了一些文件（因为文件多次被删），并宣称这些文件为burpsuite的keygen（注册机）。论坛上好多用户怀疑该文件是恶意软件。我和@Leeky、@dtm、@Cry0l1t3以及@L0k1决定逆向分析这款软件，看一下我们的猜测是否正确。令人惊讶的是，虽然该工具包含一个远程访问木马（RAT，
remote access trojan），但的确也包含可用的keygen。因此，受法律条款约束，本文中我没有给出原始文件的具体链接。
## 二、木马分析
现在我们详细分析一下这款RAT。
keygen中包含一个`virus.txt`文件，文件内容为一个网页[链接](https://www.virustotal.com/#/file/6530b29367de2b0fa42c411f94ae734d745443256431aee0fe221acb7a75c103/detection)，链接指向virustotal对keygen
jar文件的扫描结果。
然而virus total上显示的哈希与实际文件并不匹配，表明该网站实际上扫描的是另一个文件，VT上的哈希为：
    VT: SHA-256    6530b29367de2b0fa42c411f94ae734d745443256431aee0fe221acb7a75c103
实际文件哈希值为：
    > shasum -a 256 burp-loader-keygen1.7.31.jar
    1bf764e77a543def4c623e6e207b1b72999f6550cf49651b88d53f80ae10e4d7  burp-loader-keygen1.7.31.jar
jar文件实际上就是zip文件，因此我们可以使用unzip命令解压jar文件。
    > cp burp-loader-keygen1.7.31.jar burp-loader-keygen1.7.31.zip
    > unzip burp-loader-keygen1.7.31.zip
    Archive:  burp-loader-keygen1.7.31.zip
       creating: META-INF/
     extracting: META-INF/MANIFEST.MF    
       creating: burploader/
     extracting: burploader/Burploader.class  
     extracting: burploader/Data.bin
解压结果中包含一个class文件，我们可以反编译这个类文件。我使用的是jad工具，kali上已经安装了这款工具。
    > jad burploader/Burploader.class
我摘抄了反编译后比较重要的java代码，如下所示：
在这部分代码之前是经过base64编码的另一个jar文件，文件中包含keygen。经过编码的文件存放在`m`中。解码函数会处理base64编码，将其写入`Data.jar`文件。
此外，代码中还包含一些powershell命令，用来下载并执行powershell脚本，脚本的地址为`http://imonty.cn/wp-includes/pomo/script/dcss/js.js`（虽然扩展名为`.js`，但实际上是powershell脚本），同时上面这段代码也会运行keygen。
我们可以下载这个脚本，观察脚本内容，如下所示：
这段代码会将两个新文件释放到新创建的`c:ProgramDataWindowsNT`目录中，释放出来的文件为：
1、，保存为`WindowsNT.ini`；
2、，保存为`WindowsNT.vbs`。
随后恶意代码会运行vb脚本（`co.vbs`），因此我们先来看看这个脚本，其内容如下所示：
我们看到了经过混淆处理的vb代码。想要解开混淆，最简单的一种方法就是将代码中的执行语句替换成打印语句（这种方法可能无法适用于所有情况，但仍然是非常有用的一种技术）。显然，这段代码中负责执行去混淆后代码的语句为`EVAL(ExEcUTE(www))`。
> 这个文件的真正功能是分割一个非常长的字符串（每次碰到`*`符号就进行切割），然后计算分割后的数学表达式，将其转换成字符，将这些字符拼接起来后再去运行。
为了打印出字符串，我们需要将`EVAL(ExEcUTE(www))`替换为`wscript.echo www`，然后再次运行脚本。
这段脚本的功能是使用powershell运行下载的另一个文件，即`co.js`（保存为`WindowsNT.ini`）。
因此让我们来看一下`co.js`。
这个文件比较大，因此我将该文件上传到了[GitHub](https://gist.githubusercontent.com/lkw657/f2dfae7f73267c8114de039a60efcb51/raw/e7b622c0385b48a3f727cb9b97fbf2b34966a5d5/co.ps1.gz.b64)上。
在上传之前，我使用gzip以及base64处理了一下这个文件，因此你可以运行`cat co.ps1.gzip.b64 | base64 -d |
gunzip > co.ps1`命令恢复原始代码。
此外，我将`co.js`重命名为`co.ps1`，方便大家在powershell中使用`./`方式运行。
`iex`（全称为`invoke-expression`）函数可以用来执行powershell代码，因此我们需要使用`write-output`来替换该函数，打印出结果，再次运行该文件。
修改后的代码如下所示：
由于我在新的虚拟机环境中运行这段代码，因此我需要允许执行不受信任的powershell脚本。以管理员身份运行powershell：
    PS E:burpburploader> ./co.ps1 > co.2.ps1
我也将生成的文件上传到了[GitHub](https://gist.githubusercontent.com/lkw657/aa4cb19b3b7b5ccd55c846a59b3c07bf/raw/572ae9cff6747c45c2880f655139c4aebe0ff266/co.2.ps1.gz.b64)上。
生成的文件同样经过混淆处理。
该文件的开头部分如下所示：
这一次代码没有使用`iex`，调用的是`Invoke-Expression`，我们同样可以使用`write-output`来替换该函数。
再次运行这个文件。
    PS E:burpburploader> ./co.2.ps1 > co.3.ps1
大家可以访问[此处](https://gist.githubusercontent.com/lkw657/bbbf4df3c2aa92f59cdd856643409d0f/raw/171f282ad627db264f279ca10644cda285acb284/co.3.ps1.gz.b64)获取生成的文件。
首先需要注意的是，新的文件包含三个部分，由空行分开。之前我犯了点错误，缺失了第一部分的文件，因此无法找到后面分析中所需的一些信息（感谢@leeky以及@dtm的细心提醒）。我没有尝试一次性解开整个文件（虽然之前我经常这么做），而是将其分成3个小文件，逐一处理这些文件。
###  第1部分
该部分的 **结尾** 处如下所示：
这一次我们并没有看到熟悉的`invoke-expression`，然而由于代码会在最后执行，因此调用操作很有可能出现在结尾处，要么在左侧，使用经过混淆的代码作为参数，要么在右侧，将代码重定向到标准输入中。
在这种情况下，由于左侧只包含一个括号，因此我们来分析一下管道右侧的语句，即`.(
$PsHOmE[21]+$PShOMe[30]+'X')`（上图中圈起来的部分）。
非常有趣，我们可以看一下`$PsHOmE[21]+$PShOMe[30]+'X'`的执行结果。
    PS E:burpburploader> $PsHOmE[21]+$PShOMe[30]+'X'
    ieX
因此，我们需要使用`write-output`来替换`.( $PsHOmE[21]+$PShOMe[30]+'X')`。
生成的结果也经过混淆处理，更加复杂。
重复类似操作。看一下上述代码中开头部分`.( $eNv:PuBliC[13]+$eNv:pUBLiC[5]+'x')`的具体含义：
    PS E:burpburploader> $eNv:PuBliC[13]+$eNv:pUBLiC[5]+'x'
    iex
还是使用`write-output`来替换这个语句：
运行后我们会得到更加复杂的结果，我们需要重复类似操作，在新生成的文件尾部使用`write-output`替换`&
($pShoME[21]+$pShoME[34]+'X')`，然后再替换开头处的`&( $pShoME[21]+$pSHOMe[30]+'X')`语句。
###  第2部分
第2部分的开头为`[String]::JoIN('',( [Char[]]( 127 ,105`。