This works by using kprobes to instrument the add_to_page_cache_lru() function, and filters
on the block type. Since the block type requires a struct cast and dereference, it is tested in an
if-statement rather than the probe filter. This is a frequent function, so running this tool can cost
noticeable overhead for busy workloads.
8.3.26readahead
readahead(8)?* traces file system automatic read-ahead (not the readahead(2) syscall) and shows
whether the read-ahead pages were used during tracing, and the time between reading the page
and its use. For example:
+ readahesd.bt
Attaching 5 pzobes...
^C
Readahead unused pages: 128
Readahead used page age (ns) :
:su"a60)
[1]
2455 18ee88e88e88e88e
[2, 4]
8424 1889889889886 8869889889869869889889886 886986986986980 
[4, B] 
4417 1 8898888 888888888e80
[8, 16}
7680 86889889886 889889869889889889889886 8889889869
[16, 32)
4352 18ee8e88e8e 88ee8ee8６e8ee8
[32, 64)
0 1
[64, 128]
[128, 256}
e818
This shows that during tracing there were 128 pages read ahead but unused (that's not many). The
histogram shows thousands of pages were read and used, mostly within 32 milliseconds. If that
time was in the many seconds, it could be a sign that read-ahead is loaxding too aggressively, and
should be tuned.
This tool was created to help analyze read-ahead behavior on Netflix production instances that
were using solid state drives, where read ahead is far less useful than it is for rotational disks, and
38 0rigin: I crested it for ths book on 3feb-2019 Ive talked abot writing this tool for years, and now ve finally
gotten around to it.
---
## Page 370
8.3 BPF Tools
333
a ut paquosap ose st ansst uogonpoad enored s aoureuogad pae Apasgeau ue
biosnoop(8) section in Chapter 9, as biosnoop(8) had previously been used for this analysis.
The source to readahead(8) is:
#1/usx/1ocal/bin/bpEtrace
kprobe :do_page_cache_zeadahead
(ft = [pta]peeqepeex"uta ]
kretprobe1__do_page_cache_readahead [ Bin_readiahead[tid] = 0; }
kretprobe:_page_cache_a1loc
/B1n_readahead[t.id]/
gbirth[retval] = nsecs;
Brapages++
kprobe :mark_page_accessed
/lbicth[arg0] /
Bage_ms = hist((nsecs - Bbicth [arg0|1 / 1000000) 
delete (@bilrth[azg0]1
Brspages---
EXD
printf (*\,nReadahead unused pages: Id’,n*, @rapages) ;
printf (*nReadahead used page sge (ns) :^n*)
print (Bage_na) clear (8age_ms) ;
clear (8birth) = clesr (Bin_readahead) : clesr (Brapages) 
This works by using kprobes to instrument various kernel functions. It sets a per-thread flag during
do_page_cache_readahead(), which is checked during page allocation to know whether the page
was for read-ahead. If so, a timestamp is saved for the page, keyed on the page struct address. This
is read later on page access, if set, for the time histogram. The count of unused pages is an entropy
count of read-ahead page allocations minus their use, for the duration of the program.
If the kernel implementation changes, this tool will need to be updated to match. Also, tracing
page functions and storing extra metadata per page wil likely add up to significant overhead, as
these page functions are frequent. The overhead of this tool may reach 30% or higher on very
busy systems. It is intended for short-term analysis.
At the end of Chapter 9, a bpftrace one-liner is shown that can count the ratio of read vs
read-ahead block I/O.
---
## Page 371
4 Chapter S File Systems
8.3.27 Other Tools
Other BPF tools worth mentioning:
• ext4slower(8), ext4dist(8): ext4 versions of xfsslower(8) and xfsdist(8), in BCC
 btrfsslower(8), btrfsdist(8): btrfs versions of xfsslower(8) anxd xfsdist(8), in BCC
·zfsslower(8), zfsdist(8): zfs versions of xfsslower(8) and xfsdist(8), in BCC
■ nfsslower(8), nfsdist(8): NFS versions of xfsslower(8) and xfsdist(8), in BCC, for NFSv3 and
NFSv4
8.4BPF One-Liners
These sections show BCC and bpftrace one-liners. Where posible, the same one-liner is imple
mented using both BCC and bpftrace.
8.4.1 BCC
Trace files opened via open(2) with process name:
doousuodo
Trace files created via creat(2) with process name:
trace *t:syscallsiays_enter_creat *%s*, args->pathnane′
Count newstat(2) calls by filename:
argdiat -C tiayscalls1sys_enter_newatat Il :char*:args=>filenane'
Count read syscalls by syscall type:
funccount 't:syscalls:sys_enter_*read*'
Count write syscalls by syscalltype:
Eunccount 't:syscallsrsys_enter_*vrite**
Show the distribution of read() syscall request sizes:
argdist -H 'tiayscallsisys_enter_read1) :int:args=>count *
Show the distribution of read() syscall read bytes (and errors):
argdist -H 'tisyscallsisys_exit_read(1 :int:args->ret*
Count read() syscall errors by error code:
argdist -C 't:ayscalls:sys_exit_read(1 :int:args=>ret:args=>retfLlenanel) : )*
Trace files created via creat(2) with process name:
bpftrace -e *tisyscallsisys_enter_creat ( printf(*es es\n", comm,
str (a.rgs=>pathnanel) : 1*
Count newstat(2) calls by filename:
bpftrace -e *tiayscallsiays_enter_newstat [ e[str largs->filenane]] = count I )
Count read syscalls by syscall type:
bpftrace -e *tracepointiayscallsiays_enter_*read*  8|probe] = countll: )
Count write syscalls by syscall type:
bpftrace -e *tracepointiayscallsiays_enter_*vrite* | e[probe] = count () : ]
Show the distribution of read() syscall request sizes:
Show the distribution of read() syscall read bytes (and errors):
bpftrace -e *tracepointiayscallsiays_exit_read  θ = hist(args=>ret) : 1*
---
## Page 373
336
6 Chapter 8 File Systems
Count read() syscall errors by error code:
gpftzace -e *t:syacalls:sya_exit_xead /arga=>xet zet] = count (); 1'
Count VFS calls:
1 (1tunoo =[eqoad]e1 4sgnregoxdy。 8-eoexadg
Count ext4 tracepoints:
Count xfs tracepoints:
1)unco -[eqoxd]e]1ex1sood6exs.8-8oexsdg
Count ext4 file reads by process name:
Count ext4 file reads by process name and user-level stack:
Trace ZFS spa_sync() times:
Bpftzace -e *kprobe:apa_sync I tine (*sH:sN:sS ZES spa_slnc (/ ,n*); 1*
Count dcache references by process name and PID:
1(0unco =[pduoo]e1 1sednxooqody。8-8oexdg
Count FS reads to storage devices via read_pages, with kernel stacks:
1(11unoo =[xoe1sx] 8 sebedpeex:eqoxdy。8-8oexadg
Count ext4 readls to storage devices via read_pages, with kernel stacks:
1(0unco =[xoesx]81se6edpeeaxs:qod。8-8oexdg
8.4.3 BPF One-Liners Examples
Includling some sample output, as I did previously for each tool, is also useful for illustrating one
liners. These are some selected one-liners with example output.
Counting Read Syscalls by Syscall Type
+funccount -d 10 *t:syscalls:sys_enter_*read**
Tracing 9 functions for *t:syscalls:sys_enter_*read**... Hit Ctzl-C to end.
FUNC
COUNT
9peardxaquae.siatteos.s
3
syscalls:sys_entex_readlinkat
34
syscalls:sys_enter_readlink
294
syscalls:sys_entex_read
9863782
De tach.ing- -
---
## Page 374
8.4 BPF One-Liners
337
This example uses d 10 to run for 10 seconds. This one-liner, and similar ones using **write**
and "*open**, are useful for determining which syscall variants are in use, so that they can then
with nearly 10 million calls in the 10 seconds of tracing.
be studied. This output is from a 36-CPU production server, which is almost always using read(2),
Showing the Distribution of read() Syscall Read Bytes (and Errors)
.（: (4a3<s6xe) astu = g ) peaa4gxasAe:etteass:quyodeoeaa, a- soeaagdq 
Attaching 1 pzobe..
9：
[..·, 0)
2791
[0]
2899 1869889
[1]
15609 leee88e8ee88e88ee8ee8ee8eeeee8ee8e
[2, 4)
731
[4, B]
1791
[8,16}
3741
[16, 32)
2184 18698
[32, 64)
14211869
[64, 128]
8808818512
[128, 256}
3899 188988988
[256, 512)
[512, 1K]
198  8 888888 88e8e888 888
[1K, 2x)
16170 188e8e88e88 888e8ee8６e8ee8６e8e88e8
[2K,
4K)
19885 869889889886 88698698698698988988988 88648
[4K, 8K)
23926 8888888888 88e8e88 1
[8K,16K)
0808808888886886886881 b166
[16x, 32K]
68888886886886881 6956
(89*x761
190918698
[64K, 128K)
55118
[128K, 256K)
1491
[256K, 512K)
 1 |
This output shows a large mode of reads between 512 bytes and 8 Kbytes. It also shows that 15,609
reads returned one byte only, which could be a target for performance optimizations. These can
be investigated further by fetching the stack for these one-byte reads like this:
= [xoe1sm]e 1 /T == ex<-s6xe/ peexTxesfs:stteosfs:aurodeoex。 8- eoexagdq
count (): )′
There were also 2,899 reads of zero bytes, which may be normal based on the target of the read,
and if there are no further bytes to read. The 279 events with a negative return value are error
codes, which can also be investigated separately.
---
## Page 375
338
 Chapter S File Systems
Counting XFS Tracepoints
funceount =d 10 *t:xfs :*1
Tracing 496 functions for *t:xfs**,.. Hit Ctrl-C to end
FUHC
COUNT
xfs:xfs_buf_delvri_queved
1
xfs:xfs_lrele
1
xfs:xfs_inactive_symlink
2
xfs:xfs_diz2_b1ock_addnane
xfs:xfs_buf_trylock_fai1
[..-]
xfs1xfs_t.rans_read_buf
9548
xfs:xfs_trans_log_buf
11800
xfsixfs_buf_read
13320
xfs:xfs_buf_find
13322
xfs:xfs_buf_get
13322
xfs:xfs_buf_tzylock
15740
xfs:xfs_buf_unlock
15836
xfs:xfs_buf_rele
20959
xfs:xfs_perag_get
21048
xfs:xfs_perag_put
26230
xfs:xfs_file_buffered_read
43283
xfsixfs_getattr
80541
xfs:xfs_vrite_extent
121930
xfs:xfs_update_tine
137315
xfs:xfs_log_reserve
140053
xfs:xfs_log_reserve_exit
140066
xfs:xfs_log_ungrant_sub
140094
xfs:xfs_log_ungrant_exit
140107
xfs:xfs_log_ungrant_enter
140195
xfs1xfs_log_done_nonperm
140264
xfs:xfs_lomap_found
188507
xfs:xfs_file_buffered_write
188759
xfs:xfs_writepage
476196
xfs1xfs_releasepoge
479235
xfs:xfs_1lock
581785
xfs:xfs_iunlock
589775
De tach.ing-..
XFS has so many tracepoints that this output example was truncated to save space. These provide
many ways to investigate XFS internals as needed, and get to the bottom of problems.
---
## Page 376
8.4 BPF One-Liners
339
Counting ext4 Reads to Storage Devices, with Stacks and Process Names
stackcount =P ext4_readpages
Tracing 1 functions for *ext4_readpages"... Hit Ctrl-C to end.
C
ext4_readpages
read_pages
peouepeax"aqoeo"abed"op
filenap_fault
ext4_filenap_fault
_do_fault
_handle_rn_fault
handle_nm_fau1t
[negabed"op
async_page_fault
_clesr_user
Load_elf_blnary
sesrch_binary_handler
_do_execve_flle.isra.36
aAaxase9x
do_sysca11_64
entry_SYsCALL_64_after_hxfrane
[unknoxn]
head [28475]
ext4_readpages
read_pages
peeuepeax"aqpeo"abed"op-
pesvepeex"pveuepuo
3e"oaua6
_vfs_read
vfs_read
kernel_read
prepare_binprn
_do_execve_flle.iara.36
aAaxase9x
do_aysca11_s4
entry_SYsCALL_64_after_hxfrane
[unknovn]
bash [28475]
De tach.ing.. *
---
## Page 377
340
Chapter S File Systems
This output has only two events, but it was the two I was hoping to capture for an example: the
first shows a page fault and how it leads to calling ext4_readpages0 and reading from disk (it's
actually from an execve(2) call loading its binary program); the second shows a normal read(2)
that reaches ext4_readpages() via readahead functions. They are examples of an address space
operations read, and a file operations read. The output also shows how the kernel stack trace can
provide more information about an event. These stacks are from Linux 4.18, and may change
between Linux kernel versions.
8.5
5OptionalExercises
If not specified, these can be completed using either bpftrace or BCC:
1. Rewrite filelife(8) to use the syscall tracepoints for creat(2) and unlink(2).
2. W'hat are the pros and cons of switching filelife(8) to these tracepoints?
3. Develop a version of vfsstat(8) that prints separate rows for your local file system and TCP
(See vfssize(8) and fsrwstat(8).) Mock output:
+ vfsstatx
7IME
FS
READ/s MRITE/s CREATE/s
s/ONXS38/N340
02:41:23:
ext4
1715013
38717
0
5379
1311
0
02 :41: 23 :
TCP
1431
0