HARVESTER to report both possible valuations for messageText,
along with the values for clazz and method.
public7static7boolean7EXECUTOR_1;
MainActivity()
Callee1()
EXECUTOR_17=7false;
Callee1();
EXECUTOR_17=7true;
Callee1();
if(EXECUTOR_1)
false
true
messageText7=7INTERN;
messageText7=7US;
clazz7=7dec("fri$ds\&S");
method7=7dec("dvdf4$DCS")7;
Harvester.report(clazz,method,messageText)
Class.forName(clazz).getMethod(method).invoke(
"+01234",null,messageText,null,null);
Fig. 3: Dynamic Execution of Reduced APK
As explained in Section V-A, slices are parametric and
HARVESTER must explore every possible combination of
branches to retrieve all values of interest at a given logging
point. For the executor, this means that it must re-run the code
slice for all possible combinations of these Boolean values. In
the worst case (all conditions in the slice have to be replaced),
this leads to 2n paths where n is the number of conditionals
between the introduction of the variable and the position of
the logging point. Only conditions inside the slice need to
be considered. Thus, in practice, our experiments show n to
be very limited (n = 0.21 per path on average over all our
sample data, see Section VI). In the few cases in which it is
not, our experiments show many of those paths to yield the
same or at least very similar values. HARVESTER can thus
be conﬁgured to sample only a predeﬁned number of slice
instances at random.
C. Runtime Value Injection
Part C in Figure 1 shows an optional step of HARVESTER,
runtime value injection. This step can be useful to combine
HARVESTER with existing off-the-shelf analysis tools, or to
handle reﬂection. Static-analysis approaches require a call graph
to determine potential targets for method invocations. For the
large fraction of malware applications that are obfuscated using
reﬂective method calls, such as the example in Listing 2, call
graph construction fails. Some tools do not support reﬂective
calls at all, while frameworks such as DOOP [27] implement a
static best-effort solution but can still be fooled through string
encoding. HARVESTER, however, can aid those off-the-shelf
tools by manifesting the runtime values of reﬂective call targets
6
resolved during the dynamic execution as ordinary method calls
in the application’s bytecode. This allows existing call-graph
construction algorithms to construct a sound call graph with
ease. To embed reﬂective calls into the program, HARVESTER
uses the same approach originally taken in the TamiFlex
tool [28]. Off-the-shelf analysis tools such as CHEX [29],
SCanDroid [30] or FlowDroid [4] can then analyze the enriched
APK ﬁle without requiring special handling for reﬂection or
string operations used to build the target method name. To the
best of our knowledge, HARVESTER is the ﬁrst fully-automated
approach that performs such a value injection for Android.
It is important to note that this very same mechanism is also
what allows HARVESTER itself to extract runtime values from
applications whose API calls have been obfuscated through
reﬂection. In such cases, in phase A HARVESTER would
ﬁrst construct a partial call graph that is incomplete in the
sense that it misses edges for reﬂective calls. It then extracts
information about the parameters to those calls and inlines the
calls as regular method calls. Finally, it reiterates the process,
constructing a new, more complete call graph, and extracting
further data values. This can be iterated up to a pre-deﬁned
number of times, or until a ﬁxed point has been reached. This
step is shown in Figure 1 by an edge from Enhanced APK to
Backward Slicer.
VI. EVALUATION
We evaluated HARVESTER extensively on different sets of
applications, one to address each of the following four research
questions. In total, all sets together, comprise 16,799 apps. To
the best of our knowledge, these sets faithfully model the state
of the art in malware applications.
•
•
•
•
RQ1: What is HARVESTER’s precision and recall?
RQ2: How does the recall of HARVESTER relate to that
of existing static and dynamic-analysis approaches?
RQ3: How efﬁcient is HARVESTER?
RQ4: Which interesting values does HARVESTER
reveal?
In all experiments, the cut-offs were 20 for caller-slicing and
50 for callee-slicing which proved to be a reasonable tradeoff
between recall and performance.
RQ1: What is HARVESTER’s recall and precision?: We
evaluated HARVESTER’s recall based on the coverage of logging
points. Ideally, HARVESTER should cover every logging point.
For the covered logging points we furthermore evaluated the
precision and recall of the extracted runtime values. From our
initial malware set of 16,799 samples, we took 12 different
malware samples from 6 different malware families for an
in-depth evaluation as shown in Table I. These samples were
selected since they are representatives of various challenges
for HARVESTER. Obad [1], for instance, is one of the most
sophisticated malware families today. Many (FakeInstaller,
GinMaster and Obad) are also highly obfuscated. These samples
rely heavily on reﬂection to mask the targets of method calls.
Another malware family, Pincer, is known to hinder dynamic
analysis through anti-emulation techniques [9], [10]. Ssucl and
Dougalek steal various private data items. We deliberately chose
12 complex samples only, since we sought to manually verify
the precision and recall of HARVESTER.
Table I shows the evaluation results for logging points from
the categories URI, Webview, SMS Number, SMS Text, File,
Reﬂection and Shell Commands. The results for each malware
sample in each category are represented as circles. Grey slices
indicate the fraction of logging points that use constant values,
which can be read off directly, and where consequently no
backward-slicing and dynamic execution is necessary. Though
the complexity of HARVESTER is not necessary to extract such
constant values, HARVESTER discovers constant values at once.
Green slices indicate the fraction of logging points with non-
constant values for which HARVESTER was able to successfully
retrieve at least one value. Red slices indicate the amount of
missing logging points for which HARVESTER could not ﬁnd a
runtime value. The fraction directly next to the circle indicate
the fraction of successfully extracted (non-constant) logging
points, where the fraction in brackets show the fraction of
successfully extracted logging points for constant values.
Table I shows two major facts: First, only 6.5% (bottom
right corner 56
860) of the extracted logging points contained a
constant value. This conﬁrms that a naive approach that only
extracts constant values is not sufﬁcient for our representative
set of current malware. Furthermore, the table also shows that
HARVESTER has a very high detection rate, since green slices
are bigger than the red slices (bottom right corner).
In summary,
the table shows that, averaged over all
categories, HARVESTER detects at least one value for 86,6%
860) of all logging points. The fraction of
(bottom right corner 745
missed logging points is due to HARVESTER’s limitations (see
Section IX) such as the lack of support for inter-component
communication. HARVESTER is even able to cope with the anti-
analysis techniques used by the Pincer malware family where
it successfully extracts the SMS number and message, URIs,
shell commands and various ﬁle accesses. The small fraction
of missed logging points is mainly caused by HARVESTER’s
limitations, which will be discussed in Section IX.
We then used those apps, for which at least one value of
interest was discovered, to assess HARVESTER’s precision and
recall. Through manual inspection we were able to conﬁrm
that all values discovered by HARVESTER are actual runtime
values, i.e., that HARVESTER has a precision of 100% on this
data set. We furthermore evaluated the recall of the extracted
SMS numbers, SMS messages and shell commands of our test
data since those values are among the most important ones in
a malware investigation. With the help of CodeInspect [31],
an interactive bytecode debugger for Android applications, an
independent ethical hacker manually reverse engineered and
conﬁrmed that HARVESTER extracted all runtime values for
these categories. In other words, in those experiments also
HARVESTER’s recall is 100%.
HARVESTER was conﬁgured with a timeout of 10 minutes.
This timeout caused the execution to abort in fewer than 1%
of all cases. Dummy values due to cut-offs during the slicing
(see Section V-A) only needed to be inserted in about 1% of
all cases as well.
RQ2: How does the recall of HARVESTER relate to existing
static- and dynamic-analysis approaches?: We next compare
HARVESTER with purely static and purely dynamic approaches
7
FakeInstaller (MD5)
b702b545d521f129e8efc1631a3abcee
dd40531493f53456c3b22ed0bf3e20ef
GinMaster (MD5)
0878b0bb41710324f7c0650daf6b0c93
ebe49b1b92a3b44eb159d15ca1f25c70
Obad (MD5)
e1064bfd836e4c895b569b2de4700284
dd1a3ff43330165298db703f7f0626ce
Pincer (MD5)
b2b7d5999dce0559d13ab06d30c2c6ec
9c9afd6b77d8d3a66a2db2d2cf0b94b3
Ssucl (MD5)
f0bf007b3d2580297b208868425e98c7
c5a2d14bc52f109a06641c1f15e90985
Dougalek (MD5)
95a04cfc5ed03c54d4749310ba29dda9
91d57eb7ee2582e0600f21b08dac9538
URI
Webview SMS No.
SMS
Text
File
Reﬂection
Shell
Cmd
Sum
3 ( 0
3
3 )
4 ( 0
4
4 )
7 ( 1
6
7 )
6 ( 0
6
6 )
248
280 ( 0
280 )
3 ( 1
0
3 )
185
185 ( 0
185 )
161 ( 2
157
161 )
3 ( 1
2
3 )
3 ( 1
2
3 )
1 ( 0
1
1 )
1 ( 0
1
1 )
2 ( 2
0
2 )
3 ( 2
1
3 )
4
12 ( 4
12 )
9 ( 2
7
9 )
2 ( 1
0
2 )
1 ( 0
1
1 )
10
14 ( 2
14 )
25
30 ( 3
30 )
2 ( 0
2
2 )
3 ( 0
3
3 )
9 ( 2
6
9 )
7
10 ( 2
10 )
2 ( 0
2
2 )
3 ( 0
3
3 )
2 ( 1
1
2 )
2 ( 1
1
2 )
1 ( 0
1
1 )
1 ( 0
1
1 )
2 ( 0
2
2 )
2 ( 0
2
2 )
1 ( 0
1
1 )
1 ( 0
1
1 )
6
13 ( 6
13 )
6
13 ( 6
13 )
22 ( 8
11
22 )
12
19 ( 4
19 )
2 ( 0
2
2 )
2 ( 0
2
2 )
10
18 ( 4
18 )
19
20 ( 1
20 )
248
280 ( 0
280 )
14
31 ( 8
31 )
33
40 ( 5
40 )
185
185 ( 0
185 )