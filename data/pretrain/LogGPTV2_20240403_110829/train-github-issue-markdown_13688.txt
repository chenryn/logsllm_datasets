 **I'm submitting a ...**
    [] bug report 
    [ x ] feature request
    [ ] support request
**Current behavior**  
Querying ngContent with a superclass doesn't work.
**Expected behavior**  
Querying ngContent with a superclass should work.
**Minimal reproduction of the problem with instructions**  
Currently, if you have a component that uses ng-content inside of its
template, it can render out whatever you pass to it. (ie. any other component
or html). However referencing this component is only possible if you know
exactly what component it will be.
    @ContentChildren(Component1) myComponent;
In the case where you don't know, you can't select it. My request would be
that you can select the components off a super class. Say, `Component1 extends
MySuperClass` and `Component2 extends MySuperClass` you can select their
instances like so:
    @ContentChildren(MySuperClass) myComponents;
**What is the motivation / use case for changing the behavior?**  
The motivation behind this is allowing dynamic components to be injected yet
allow their instance to be referenced by their parent component. In my
particular use-case I am allowing the developer to build pages of a wizard
containing whatever component they need -- I then assume that they have a
class or interface on them that they share so that I can call functions on
them like, say, `validate` so I can move forward in the wizard.
**Please tell us about your environment:**  
Windows 10, Angular 2.0.1, WebStorm, Webpack/Gulp
**Additional Notes**  
A workaround currently is instead to pass the components in as a config (say
an array of components) and then refer to them that way. However it would be
nice to be able to reference the instances of the components injected
dynamically via ng-content
I would also think that this may be related to #8580 in the sense that I would
expect these two scenarios to work the same. The linked issues mentions that
super class selectors should work (at least when the components aren't
dynamically defined).