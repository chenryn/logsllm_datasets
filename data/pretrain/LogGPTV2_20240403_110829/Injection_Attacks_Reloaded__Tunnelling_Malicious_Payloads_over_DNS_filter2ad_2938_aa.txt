title:Injection Attacks Reloaded: Tunnelling Malicious Payloads over DNS
author:Philipp Jeitner and
Haya Shulman
Injection Attacks Reloaded: 
Tunnelling Malicious Payloads over DNS
Philipp Jeitner, TU Darmstadt; Haya Shulman, Fraunhofer SIT
https://www.usenix.org/conference/usenixsecurity21/presentation/jeitner
This paper is included in the Proceedings of the 30th USENIX Security Symposium.August 11–13, 2021978-1-939133-24-3Open access to the Proceedings of the 30th USENIX Security Symposium is sponsored by USENIX.Injection Attacks Reloaded:
Tunnelling Malicious Payloads over DNS
Philipp Jeitner
TU Darmstadt
Haya Shulman
Fraunhofer SIT
Abstract
The traditional design principle for Internet protocols in-
dicates: “Be strict when sending and tolerant when receiv-
ing” [RFC1958], and DNS is no exception to this. The trans-
parency of DNS in handling the DNS records, also standard-
ised speciﬁcally for DNS [RFC3597], is one of the key fea-
tures that made it such a popular platform facilitating a con-
stantly increasing number of new applications. An application
simply creates a new DNS record and can instantly start dis-
tributing it over DNS without requiring any changes to the
DNS servers and platforms. Our Internet wide study conﬁrms
that more than 1.3M (96% of tested) open DNS resolvers are
standard compliant and treat DNS records transparently.
In this work we show that this ‘transparency’ introduces
a severe vulnerability in the Internet: we demonstrate a new
method to launch string injection attacks by encoding mali-
cious payloads into DNS records. We show how to weaponise
such DNS records to attack popular applications. For instance,
we apply string injection to launch a new type of DNS cache
poisoning attack, which we evaluated against a population
of open resolvers and found 105K to be vulnerable. Such
cache poisoning cannot be prevented with common setups
of DNSSEC. Our attacks apply to internal as well as to pub-
lic services, for instance, we reveal that all eduroam services
are vulnerable to our injection attacks, allowing us to launch
exploits ranging from unauthorised access to eduroam net-
works to resource starvation. Depending on the application,
our attacks cause system crashes, data corruption and leak-
age, degradation of security, and can introduce remote code
execution and arbitrary errors.
In our evaluation of the attacks in the Internet we ﬁnd that
all the standard compliant open DNS resolvers we tested allow
our injection attacks against applications and users on their
networks.
1 Introduction
Domain Name System (DNS) is a key component of the
Internet. Originally designed to translate domain names to
IP addresses, DNS has developed into a complex infrastruc-
ture providing platform to a constantly increasing number of
applications. The applications that are built over DNS range
from Internet speciﬁc services, such as location of hosts us-
ing GPOS record [RFC1712] [1] to security mechanisms,
such as authentication with certiﬁcates using TLSA record
[RFC6698] [2]. The core design feature that allows DNS to
support new applications without involving any changes to its
infrastructure is the requirement that the handling of the DNS
records is done transparently [RFC3597, RFC1035] [3, 4].
Namely, DNS should not attempt to interpret nor understand
the records that it is serving. Thanks to this feature new DNS
records can be easily added to the DNS infrastructure with-
out requiring any modiﬁcations, and novel applications can
instantly run over DNS using the newly added records.
In this work we show that the transparency-feature of DNS,
while critical for fast and smooth deployment of new tech-
nologies, introduces a gaping hole in Internet security.
Exploiting transparency to encode injections. We ex-
ploit the transparency of the DNS lookups to encode injection
strings into the payloads of DNS records. The attacker places
the malicious records in the zoneﬁle of its domain. When
provided by the attacker’s nameserver the records appear to
contain legitimate mappings under the domain controlled by
the attacker. However, when the record is processed by the
receiving victim application, a misinterpretation occurs - re-
sulting in the injection attack. Our attacks exploit two key
factors caused by the transparency of DNS: (1) the DNS re-
solvers do not alter the received records hence the malicious
encoding is preserved intact and (2) the receiving applica-
tions do not sanitise the received records. We devise injection
payloads to attack popular applications.
Applications do not sanitise DNS records. Classical in-
jection attacks are well known and have been extensively
studied: the attacker provides a malicious input through a
web application to alter the structure of a command, hence
subverting the logic of the application, e.g., [5, 6]. Such in-
jection attacks are easy to mitigate in practice: the input of
the user is validated and invalid characters are ﬁltered before
USENIX Association
30th USENIX Security Symposium    3165
reaching the application. Due to the long history of injection
vulnerabilities in web applications and the awareness to the
potential risks, most applications validate user input [7].
We show that in contrast to user input, the inputs provided
by the DNS resolvers are not validated. For instance, user
credentials provided to LDAP via a web interface to authenti-
cate the user and enable it to use services, are validated, while
DNS values that are provided to LDAP to route the authentica-
tion request to an authentication server are not validated. We
show how to construct malicious payloads to launch injection
attacks, such as XSS and cache poisoning, against a variety
of applications and services, including DNS caches, LDAP,
eduroam.
Attacker model. The attacker causes the victim resolvers
to issue queries for records that encode malicious payloads,
e.g., by deploying an ad-network or by sending an Email
from attacker’s domain to the victim. The resolvers cache
the records received in DNS responses and provide them to
applications and users. We illustrate the attacker model and
the setup with eduroam as example victim application, in
Figure 1. Using our “weak” attacker we demonstrate a range
of attacks against popular applications and services that use
DNS lookups, including DNS cache poisoning, applications’
crashes, downgrade of security mechanisms, remote code
execution vulnerabilities, XSS.
Contributions
The core issue that we explore in this work is the bal-
ance between security and the requirement to enable easy
deployment of new applications over DNS. Our contributions
include:
• Analysis of components in resolution chain. We anal-
yse the interaction between the applications and the compo-
nents in DNS resolution chain. We ﬁnd that the processing
applied by the DNS resolvers over DNS records is compliant
with the requirement in [RFC3597,RFC1035] and preserves
the structure of the malicious inputs encoded by the attackers
- this property is key to our attacks. We validate this also in
the Internet against 3M open DNS resolvers. Our measure-
ment study reveals that more than 96% of the open DNS
resolvers do not modify the records that they receive from the
nameservers, and serve them intact to the calling applications.
• Study of DNS input validation. We ﬁnd that although
DNS delivers untrusted data from potentially malicious Inter-
net servers the applications trust the data returned by the DNS
resolvers. Our study shows that the lack of input validation
is systematic and prevalent and is not a bug mistakenly intro-
duced by developers in some isolated cases – this includes
custom functions in applications as well as standardised func-
tion calls of IEEE POSIX, e.g., gethostbyname().
• Implementation of injection attacks over DNS. We
demonstrate that the attackers can systematically and efﬁ-
ciently construct attack vectors and show how to integrate
them into the zoneﬁle of a malicious domain operated by
Figure 1: Attack and setup overview, with eduroam rad-
secproxy as example application.
the attacker. We then demonstrate injection attacks over
DNS against popular applications using these malicious DNS
records.
• Injections into DNS caches. We show how to encode
payloads for injecting malicious records into DNS caches.
When cached by the victim DNS resolver, a misinterpreta-
tion occurs mapping a resource of some victim domain to
an attacker’s IP address. In contrast to classical cache poi-
soning, [8–10], which require a strong (on-path) attacker or
assume speciﬁc network properties, such as side channels or
fragmentation, our cache poisoning attacks do not make any
requirements on attacker capabilities. We also do not need to
spoof IP addresses in DNS responses - a requirement which
is essential in prior cache poisoning attacks. We automated
the evaluation of our poisoning attacks, which allowed us to
launch them against a large set of 3M target DNS resolvers,
performing successful poisoning against 105K resolvers. Im-
plementation of previous cache poisoning attacks had to be
manually tailored per each target - automating the attacks
would result in a negligible success probability. Hence the
previous attacks were carried out against at most a handful of
targets, and the rest of the resolvers’ population was merely
checked for properties that make them potential targets. Fur-
thermore, in contrast to previous poisoning attacks, ours can-
not be prevented with common setups of DNSSEC [11–13].
• Evaluation of injection attacks over DNS. We evaluate
our injection attacks against popular applications (listed in
Table 1). Our analysis of the vulnerabilities in applications,
where suitable, combines fuzzing, source code review and
dynamic (black box) execution. We evaluate our injection
attacks against a population of more than 3M open resolvers
in the Internet. We provide additional information on our
evaluations at https://xdi-attack.net.
Ethics and Disclosure
We have already taken preliminary steps to address these
vulnerabilities by contacting the DNS software vendors as
well the applications evaluated in this work. We experimen-
tally evaluated the attacks reported in this work against servers
that we set up as well as against open DNS resolvers in the
Internet using domains that we control. This allowed us to
3166    30th USENIX Security Symposium
USENIX Association
NameserverAttackerTrigger resolutionService asks fordomain resolutionResolver connects toattacker’s nameserverNameserver delivers maliciousinput to DNS resolverMalicious input is given to serviceService processes malicious input and crashes 23145DNS ResolverRadsec-proxyFirewallInternal NetworkInternet1253466gethostbyaddr() and getnameinfo() functions. When con-
sidering full ﬂedged resolution functionality, which also sup-
ports other query types, like MX, SRV or TXT, there is no
standardised API so applications need to rely on third party
libraries for constructing the DNS packets or for parsing the
DNS responses they receive from the network (e.g., recursive
resolvers). DNS software implementations in recursive re-
solvers and forwarders typically implement their own packet
decoding logic since they do not interface with the applica-
tions directly and do not need to decode parts of the DNS
records at all.
2.2 System Stub Resolvers
Stub resolvers provide the interface between the applica-
tions and the DNS resolvers. Applications typically do not
issue DNS requests to the recursive resolvers directly, but
instead use a POSIX standardised API [14, 15] to supply the
hostname they want to resolve, and the system’s standard C
library translates this into a DNS request and parses the re-
sponse from the recursive DNS resolver. The applications
can perform hostname-to-address (A, AAAA) and reverse
(PTR) lookups via the gethostbyname(), gethostbyaddr(),
getaddrinfo() and getnameinfo() calls. This API is deﬁned
to return CNAME aliases and results of reverse lookups
as null-terminated ‘host names’ [14, p. 320] in its returned
hostent structure, deﬁned [16, 17] to only contain Latin char-
acters, digits and hyphens ( "A-Z","a-z","0-9","-").
According to this deﬁnition the expected behaviour of a sys-
tem stub resolver is to check that any domain name returned
by a call to any of the POSIX-standardised resolver functions
must be checked before returning it to the application.
DNS Record Processing. We analyse the DNS record pro-
cessing done by stub-resolvers in Section 3.6.1 in detail. We
ﬁnd that while one implementation (glibc) is fully conforming
with our expectations, most stub-resolvers are not. Stub re-
solvers that do not validate the value of the hostname expose
the applications to attacks; we show these in Section 3.6.2.
2.3 Recursive Resolvers and Forwarders
Recursive resolvers provide lookup services to system DNS
resolvers: they locate nameservers and look up the requested
records.
DNS resolvers and forwarders process DNS records in their
line-format, i.e., they store and handle domain names in their
encoded form and do not try to parse the records that they do
not need to understand, like TXT or MX. This makes them
transparent for any binary values inside domains or other
record data as is required by the DNS standard [4, 18, 19].
For internal caching purposes, a DNS resolver may choose
to decode a domain name for further processing or to store it
inside a cache.
DNS Record Processing. DNS resolvers are expected to
transparently handle known and unknown DNS record types
[RFC3597] to ensure forward-compatibility and compatibility
Figure 2: Expected vs. actual behaviour in DNS lookup.
validate the presence of the vulnerabilities without exploiting
them against real victims and without causing damage to the
networks nor services in the Internet. Our attacks similarly
apply also to non-open DNS resolvers.
Prior to performing the validation of the vulnerabilities in
the wild we received an approval from our research institution.
In the next steps we will be coordinating countermeasures
with the DNS and applications vendors, as well as the IETF
community.
Organisation
In Section 2 we analyse the interaction between compo-
nents in DNS resolution chain. In Section 3, we demonstrate
injection attacks against popular applications. In Section 4 we
evaluate our attacks against open resolvers in the Internet. We
propose countermeasures in Section 5, review related work in
Section 6 and conclude in Section 7.
2 Analysis of DNS Resolution Chain
In this section we analyse the interaction between the com-
ponents relevant to processing DNS records in responses. In
our analysis we use popular DNS resolvers and stub resolver
implementations built into operating systems and program-
ming languages, and experimentally test how they handle
control characters in domain names and if they modify any
of the maliciously crafted payloads needed to conduct the
application-speciﬁc exploits that we evaluate in this work.
2.1 Components in DNS Lookup
We consider 3 different types of software components
which fulﬁl different roles during a DNS lookup: (recursive)
DNS resolvers, stub DNS resolvers and applications. In our
setup the DNS namerservers are controlled by the attacker
and provide maliciously-encoded DNS responses. The victim
resolvers serve these records to the stub resolvers in applica-
tions. We provide an illustration of these software components
together with the expectations on their behaviour and their
actual behaviour discovered in this work in Figure 2. DNS
lookups by system stub resolvers are implemented in various
ways in applications. For standard A, AAAA and PTR queries,
system C libraries include POSIX-standardised [14, 15] func-
tionality in form of the gethostbyname(), getaddrinfo(),
USENIX Association
30th USENIX Security Symposium    3167
Stub ResolverResolverNameserverApplicationExpectationTransparent forall typesofRecordsCheck ifDomain Namesrepresentvalid HostnamesPerform Input Validation ofInput overDNS responsesRealitySometimes: Naive decodingofDomain Namesleadstomisinterpretation.Often: Nochecks, naive decodingofDomain Namesleadstomisinterpretation.Mostly: NoInput validationwith mechanisms such as DNSSEC, as any change in the
encoded record would invalidate the DNSSEC signatures.
Moreover, [RFC1034] states that software like DNS resolvers
should not try to decode domain names into a string as stub-
resolvers would do. Most resolvers we tested are [RFC1034]
compliant: they handle any payload transparently or only
change the case of letters to lowercase, which is allowed since
domain names are deﬁned to be case insensitive [18]. One
tested resolver software, MaraDNS Deadwood 3.2.14, was
unable to handle inject\000.
We also identiﬁed an ‘[RFC1034] non-compliant’ be-
haviour, which we describe next. We take as an example
a systemd-resolved forwarding DNS resolver which when
receiving a DNS record decodes and escapes all included do-
main names into zero-terminated strings like a system stub
resolver would do. Then it caches the records as decoded
strings. The resolver unescapes and re-encodes the records
when sending them to a requesting client or application. This
behaviour ensures that any misinterpretation during decoding
(step 2 in Figure 7) will cause the domain name to be mod-
iﬁed. This modiﬁcation cannot be detected by downstream
resolvers or applications because the misinterpreted record is
re-encoded instead of just being passed as binary.
2.4 Applications
Applications are the source of DNS lookups and process
the records in the response after it has traversed all the other
components in the resolution chain. The records may contain
unexpected characters which the application cannot process
correctly. The impact of injection attacks on the applications
depends on the use case of the DNS lookup. For example,
applications which do service discovery or authentication
lookups typically need to parse DNS packets by themselves,
because system stub resolvers do not support queries for such
record types. This can also be abused to cause misinterpreta-
tion of domain names or other data in DNS records.
DNS Record Processing. When applications perform
DNS lookups of types other than A, AAAA or PTR, they
implement DNS lookup functionality by themselves as there
is no standardised API for this. While the standard libraries of
some programming languages like java, go or nodejs include
functions for query types like MX, SRV and TXT, there is no
recommended behaviour for such functions and they do not
perform any validation of the data which is passed to the ap-
plication. This also applies to DNS lookup implementations
done in applications directly. Domain names are typically not
validated nor escaped when decoded into a string.
Theoretically, when applications use the system resolver
to do DNS lookups, they could implement validation (step
3 in Figure 7) by themselves, to ensure no malicious input
is processed. However, applications would still not be able
to detect decoding errors in step 2 in Figure 7. For example,
since the application does not see the binary DNS data, it
cannot determine if the example domain in Figure 7 is "a\.b.
<>.com." or "a.b.<>.com.".
3
Injection Attacks Against Applications
In this section we demonstrate injection attacks using mali-
cious payloads tunnelled over DNS. We ﬁrst explain our study
methodology (Section 3.1) and then show attacks against se-
lected popular applications (Sections 3.2 – 3.6) taking DNS
software as the ﬁrst example application.
3.1 Study Methodology
3.1.1 Attack overview
The attack is illustrated in Figure 1. The target victim
application, e.g., radsecproxy of eduroam, is behind a ﬁrewall
on the victim network. The attack is initiated by causing the
target service to issue a request via its DNS resolver to the
attacker’s domain, e.g., by trying to authenticate at eduroam’s
wireless access point (steps 1 , 2 and 3 in Figure 1). In
the zoneﬁle of its domain, the attacker encodes malicious
payloads into the DNS records. The records are then provided
in responses to the queries of the DNS resolvers (step 4 ),
and are subsequently relayed to the requesting services, in
the example in Figure 1, to the radsecproxy server (step 5 )
which processes the attacker’s authentication request. The
payload then causes the application to divert from a standard
behaviour (step 6 ), e.g., causing it to allow unauthenticated
network access.
3.1.2 Selecting Target Applications
We evaluate injection attacks against popular services and
applications. In this work we present attacks against some
selected applications listed in Table 1. We select them based
on the following considerations:
DNS Use-Case. We identify 4 different use-cases of DNS
(address lookup, service discovery, reverse lookup and authen-
tication). We select a few popular applications and services
for each DNS use case.
Triggering query. The attacker must be able to trigger a
DNS lookup, e.g., via a script in a browser, via an Email to
a target Email Server. We summarise methods for triggering