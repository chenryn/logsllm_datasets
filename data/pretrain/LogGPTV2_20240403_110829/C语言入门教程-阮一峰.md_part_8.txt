(long int) 10 long int
算符会⾃动将右边的值，转为左边变量的类型。
可移植类型 #
C 语⾔的整数类型（short、int、long）在不同计算机上，占⽤的字节宽度可能是不⼀样的，⽆法提前知道
它们到底占⽤多少个字节。
程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，头⽂件 创造了⼀些新
stdint.h
的类型别名。
（1）精确宽度类型 (exact-width integer type)，保证某个整数类型的宽度是确定的。
：8 位有符号整数。
int8_t
：16 位有符号整数。
int16_t
：32 位有符号整数。
int32_t
：64 位有符号整数。
int64_t
：8 位⽆符号整数。
uint8_t
：16 位⽆符号整数。
uint16_t
：32 位⽆符号整数。
uint32_t
：64 位⽆符号整数。
uint64_t
上⾯这些都是类型别名，编译器会指定它们指向的底层类型。⽐如，某个系统中，如果 类型为 32
int
位， 就会指向 ；如果 类型为 32 位， 则会指向 。
int32_t int long int32_t long
下⾯是⼀个使⽤示例。
#include 
#include 
int main(void) {
int32_t x32 = 45933945;
printf("x32 = %d\n", x32);
return 0;
}
上⾯示例中，变量 声明为 类型，可以保证是 32 位的宽度。
x32 int32_t
（2）最⼩宽度类型（minimum width type），保证某个整数类型的最⼩⻓度。
int_least8_t
int_least16_t
int_least32_t
int_least64_t
uint_least8_t
uint_least16_t
uint_least32_t
uint_least64_t
上⾯这些类型，可以保证占据的字节不少于指定宽度。⽐如， 表示可以容纳 8 位有符号整数
int_least8_t
的最⼩宽度的类型。
（3）最快的最⼩宽度类型（fast minimum width type），可以使整数计算达到最快的类型。
int_fast8_t
int_fast16_t
int_fast32_t
int_fast64_t
uint_fast8_t
uint_fast16_t
uint_fast32_t
uint_fast64_t
上⾯这些类型是保证字节宽度的同时，追求最快的运算速度，⽐如 表示对于 8 位有符号整
int_fast8_t
数，运算速度最快的类型。这是因为某些机器对于特定宽度的数据，运算速度最快，举例来说，32 位计算
机对于 32 位数据的运算速度，会快于 16 位数据。
（4）可以保存指针的整数类型。
：可以存储指针（内存地址）的有符号整数类型。
intptr_t
：可以存储指针的⽆符号整数类型。
uintptr_t
（5）最⼤宽度整数类型，⽤于存放最⼤的整数。
：可以存储任何有效的有符号整数的类型。
intmax_t
：可以存放任何有效的⽆符号整数的类型。
uintmax_t
上⾯的这两个类型的宽度⽐ 和 更⼤。
long long unsigned long
全⽂完
本⽂由 简悦 SimpRead 转码，⽤以提升阅读体验，原⽂地址
指针 语⾔教程 ⽹道
- C -
⽹道（WangDoc.com），互联⽹⽂档计划
“
⽹道（WangDoc.com），互联⽹⽂档计划
指针是 C 语⾔最重要的概念之⼀，也是最难理解的概念之⼀。
简介 #
指针是什么？⾸先，它是⼀个值，这个值代表⼀个内存地址，因此指针相当于指向某个内存地址的路标。
字符 表示指针，通常跟在类型关键字的后⾯，表示指针指向的是什么类型的值。⽐如， 表示⼀个
* Char*
指向字符的指针， 表示⼀个指向 类型的值的指针。
float* float
int* intPtr;
上⾯示例声明了⼀个变量 ，它是⼀个指针，指向的内存地址存放的是⼀个整数。
intPtr
星号 可以放在变量名与类型关键字之间的任何地⽅，下⾯的写法都是有效的。
*
int *intPtr;
int * intPtr;
int* intPtr;
本书使⽤星号紧跟在类型关键字后⾯的写法（即 ），因为这样可以体现，指针变量就是⼀个
int* intPtr;
普通变量，只不过它的值是内存地址⽽已。
这种写法有⼀个地⽅需要注意，如果同⼀⾏声明两个指针变量，那么需要写成下⾯这样。
int * foo, * bar;
int* foo, bar;
上⾯示例中，第⼆⾏的执⾏结果是， 是整数指针变量，⽽ 是整数变量，即 只对第⼀个变量⽣
foo bar *
效。
⼀个指针指向的可能还是指针，这时就要⽤两个星号 表示。
**
int** foo;
上⾯示例表示变量 是⼀个指针，指向的还是⼀个指针，第⼆个指针指向的则是⼀个整数。
foo
* 运算符 #
这个符号除了表示指针以外，还可以作为运算符，⽤来取出指针变量所指向的内存地址⾥⾯的值。
*
void increment(int* p) {
*p = *p + 1;
}
上⾯示例中，函数 的参数是⼀个整数指针 。函数体⾥⾯， 就表示指针 所指向的那个
increment() p *p p
值。对 赋值，就表示改变指针所指向的那个地址⾥⾯的值。
*p
上⾯函数的作⽤是将参数值加 。该函数没有返回值，因为传⼊的是地址，函数体内部对该地址包含的值
1
的操作，会影响到函数外部，所以不需要返回值。事实上，函数内部通过指针，将值传到外部，是 C 语⾔
的常⽤⽅法。
变量地址⽽不是变量值传⼊函数，还有⼀个好处。对于需要⼤量存储空间的⼤型变量，复制变量值传⼊函
数，⾮常浪费时间和空间，不如传⼊指针来得⾼效。
& 运算符 #
运算符⽤来取出⼀个变量所在的内存地址。
&
int x = 1;
printf("x's address is %p\n", &x);
上⾯示例中， 是⼀个整数变量， 就是 的值所在的内存地址。 的 是内存地址的占位
x &x x printf() %p
符，可以打印出内存地址。
上⼀⼩节中，参数变量加 的函数，可以像下⾯这样使⽤。
1
void increment(int* p) {
*p = *p + 1;
}
int x = 1;
increment(&x);
printf("%d\n", x);
上⾯示例中，调⽤ 函数以后，变量 的值就增加了 1，原因就在于传⼊函数的是变量 的地
increment() x x
址 。
&x
运算符与 运算符互为逆运算，下⾯的表达式总是成⽴。
& *
int i = 5;
if (i == *(&i))
指针变量的初始化 #
声明指针变量之后，编译器会为指针变量本身分配⼀个内存空间，但是这个内存空间⾥⾯的值是随机的，
也就是说，指针变量指向的值是随机的。这时⼀定不能去读写指针变量指向的地址，因为那个地址是随机
地址，很可能会导致严重后果。
int* p;
*p = 1;
上⾯的代码是错的，因为 指向的那个地址是随机的，向这个随机地址⾥⾯写⼊ ，会导致意想不到的
p 1
结果。
正确做法是指针变量声明后，必须先让它指向⼀个分配好的地址，然后再进⾏读写，这叫做指针变量的初
始化。
int* p;
int i;
p = &i;
*p = 13;
上⾯示例中， 是指针变量，声明这个变量后， 会指向⼀个随机的内存地址。这时要将它指向⼀个已
p p
经分配好的内存地址，上例就是再声明⼀个整数变量 ，编译器会为 分配内存地址，然后让 指向
i i p
的内存地址（ ）。完成初始化之后，就可以对 指向的内存地址进⾏赋值了（ ）。
i p = &i; p *p = 13;
为了防⽌读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为 。
NULL
int* p = NULL;
在 C 语⾔中是⼀个常量，表示地址为 的内存空间，这个地址是⽆法使⽤的，读写该地址会报错。
NULL 0
指针的运算 #
指针本质上就是⼀个⽆符号整数，代表了内存地址。它可以进⾏运算，但是规则并不是整数运算的运算。
（1）指针与整数值的加减运算
指针与整数值的运算，表示指针的移动。
short* j;
j = (short*)0x1234;
j = j + 1;
上⾯示例中， 是⼀个指针，指向内存地址 。你可能以为 等于 ，但正确答案是
j 0x1234 j + 1 0x1235
。原因是 表示指针向⾼位移动⼀个单位，⽽⼀个单位的 类型占据两个字节的宽度，
0x1236 j + 1 short
所以相当于向⾼位移动两个字节。同样的， 得到的结果是 。
j - 1 0x1232
指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。
（2）指针与指针的加法运算
指针只能与整数值进⾏加减运算，两个指针进⾏加法是⾮法的。
unsigned short* j;
unsigned short* k;
x = j + k;
上⾯示例是两个指针相加，这是⾮法的。
（3）指针与指针的减法
相同类型的指针允许进⾏减法运算，返回它们之间的距离，即相隔多少个数据单位。
⾼位地址减去低位地址，返回的是正值；低位地址减去⾼位地址，返回的是负值。
这时，减法返回的值属于 类型，这是⼀个带符号的整数类型别名，具体类型根据系统不同⽽不
ptrdiff_t
同。这个类型的原型定义在头⽂件 ⾥⾯。
stddef.h
short* j1;
short* j2;
j1 = (short*)0x1234;
j2 = (short*)0x1236;
ptrdiff_t dist = j2 - j1;
printf("%d\n", dist);
上⾯示例中， 和 是两个指向 short 类型的指针，变量 是它们之间的距离，类型为
j1 j2 dist
，值为 ，因为相差 2 个字节正好存放⼀个 short 类型的值。
ptrdiff_t 1
（4）指针与指针的⽐较运算
指针之间的⽐较运算，⽐较的是各⾃的内存地址哪⼀个更⼤，返回值是整数 （true）或 （false）。
1 0
全⽂完
本⽂由 简悦 SimpRead 转码，⽤以提升阅读体验，原⽂地址
函数 语⾔教程 ⽹道
- C -
⽹道（WangDoc.com），互联⽹⽂档计划
“
⽹道（WangDoc.com），互联⽹⽂档计划
简介 #
函数是⼀段可以重复执⾏的代码。它可以接受不同的参数，完成对应的操作。下⾯的例⼦就是⼀个函数。
int plus_one(int n) {
return n + 1;
}
上⾯的代码声明了⼀个函数 。
plus_one()
函数声明的语法有以下⼏点，需要注意。
（1）返回值类型。函数声明时，⾸先需要给出返回值的类型，上例是 ，表示函数 返回⼀
int plus_one()
个整数。
（2）参数。函数名后⾯的圆括号⾥⾯，需要声明参数的类型和参数名， 表示这个函数有
plus_one(int n)
⼀个整数参数 。
n
（3）函数体。函数体要写在⼤括号⾥⾯，后⾯（即⼤括号外⾯）不需要加分号。⼤括号的起始位置，可以
跟函数名在同⼀⾏，也可以另起⼀⾏，本书采⽤同⼀⾏的写法。
（4） 语句。 语句给出函数的返回值，程序运⾏到这⼀⾏，就会跳出函数体，结束函数的
return return
调⽤。如果函数没有返回值，可以省略 语句，或者写成 。
return return;
调⽤函数时，只要在函数名后⾯加上圆括号就可以了，实际的参数放在圆括号⾥⾯，就像下⾯这样。
int a = plus_one(13);
函数调⽤时，参数个数必须与定义⾥⾯的参数个数⼀致，参数过多或过少都会报错。
int plus_one(int n) {
return n + 1;
}
plus_one(2, 2);
plus_one();
上⾯示例中，函数 只能接受⼀个参数，传⼊两个参数或不传参数，都会报错。