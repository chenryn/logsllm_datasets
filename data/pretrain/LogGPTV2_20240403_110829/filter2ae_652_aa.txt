**作者：罗权、于长奇@奇安信代码卫士**  
**公众号： **
### 漏洞概述
2019年6月18日，RedHat官网发布CVE编号为CVE-2019-11477的漏洞，此漏洞是一个底层协议栈的整数溢出漏洞，影响Linux
内核2.6.29及以上版本，理论上可以造成远程拒绝服务漏洞。
**经过奇安信代码卫士团队分析验证，在实际环境中很难触发此漏洞，所以在实际环境中此漏洞危害没那么大。**
### 漏洞原理
该漏洞是一个位于skb_buff结构体上tcp_gso_segs成员的整数溢出漏洞。linux
kernel数据包文以skb_buff结构体表示，内核为提升发包效率提供了NETIF_F_SG（默认开启）、NETIF_F_UFO等功能，当发送报文时，将会将小报文以类似分片形式累积，累积为大报文统一发送，由网卡硬件进行分片。此时报文累积最大长度为32k（x86）或者64k(powerpc)。代码中，小报文积累队列成员为skb_buff结构体的tcp_skb_cb对象，其中tcp_gso_segs成员是个short
unsight int 类型成员，代表小报文个数。
`\linux\net\ipv4\tcp.c`
    if (can_coalesce) {
             skb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);
          } else {
             get_page(page);
             skb_fill_page_desc(skb, i, page, offset, copy);
          }
`linux/include/linux/skbuff.h`
    struct
    tcp_skb_cb
    {__u32
    seq; / *Starting
    sequence
    number * /__u32
    end_seq; / *SEQ + FIN + SYN + datalen * /__u32
    tcp_tw_isn;struct
    {u16
    tcp_gso_segs;u16
    tcp_gso_size; };__u8
    tcp_flags; / 2 * TCP
    header
    flags.(tcp[13]) * /…}
通常，TCP协议为避免分片带来的性能损失，提供了mss协商机制，通过在握手过程中提供双方mtu值，协商双方报文的最大报文长度，发送提供各自的mss长度，双方选取最小的mss值为最大报文长度，此后，双方报文的最大长度将不会超过协商得出的mss值。如果要漏洞出发，发送方在握手时将mss值强制置为8（mss协商最小值为48-最大tcp报头长度=8）。即接收方在和握手方握手时，将mss值设置为8即可。
TCP-MSS，全称TCP maximum segment
size。翻译过来是TCP最大报文尺寸。它的值代表TCP传输层期望对端发送给自己单个TCP报文的最大尺寸。
TCP协议中，当TCP协议两端在初始协商进行TCP三次握手协议的时候，主机两端会把自己当前所在链路的MSS值告知对方。当一端主机收到另外一端的MSS值候，它会评估其MSS值并与自己的MSS值做对比，取最小的值来决定TCP发送的最大报文尺寸。
如何计算本地MSS值？本地MSS=MTU-20字节的标准IP头-20字节的标准TCP头（换个角度看其实就是TCP负载）
另外一个相关的是linux的sack机制。在RFC的描述中，当TCP报文乱序到达时，TCP接收端会要求发送端连未能按照顺序发送的报文也重新发送，为改进TCP协议的发包效率，TCP提供了sack机制（自linux
kernel
2.6.29以后提供了sack机制的实现），当接收方向发送方要求重传时，重传报文将会进入tcp_sendmsg函数的tcp_gso_segs机制中，以分片的形式积累报文碎片，在skb_buff结构体中最多接受17个分片队列，在恶意会话的接收过程中，接收方可以不断地要求发送方重传，即接受方不断向发送方发送sack报文，发送方接收到sack报文后，将重新发送报文。
`linux/include/linux/skbuff.h`
`define MAX_SKB_FRAGS (65536/PAGE_SIZE + 1) => 17`
此时一个skb_buff结构体最多可以由`17*32*1024/8=69632`个报文碎片积累而成，而69632超过了tcp_gso_segs成员（无符号短整型）的最大值65535，将导致整数溢出，最终在tcp_shifted_skb函数中触发崩溃.
`linux\net\ipv4\tcp_input.c`
    static bool tcp_shifted_skb (struct sock *sk, …, unsigned int pcount, ...)
    {
    ...
    tcp_skb_pcount_add(prev, pcount);
    BUG_ON(tcp_skb_pcount(skb)  0) {
          struct sk_buff *skb = tcp_write_queue_tail(sk);
          int copy, i;
          bool can_coalesce;
          if (!tcp_send_head(sk) || (copy = size_goal - skb->len) sk_allocation,
                        skb_queue_empty(&sk->sk_write_queue));
             if (!skb)
                goto wait_for_memory;
             skb_entail(sk, skb);
             copy = size_goal;
          }
          if (copy > size)
             copy = size;
          i = skb_shinfo(skb)->nr_frags;
          can_coalesce = skb_can_coalesce(skb, i, page, offset);
          if (!can_coalesce && i >= sysctl_max_skb_frags) {
             tcp_mark_push(tp, skb);
             goto new_segment;
          }
          if (!sk_wmem_schedule(sk, copy))
             goto wait_for_memory;
          if (can_coalesce) {
             skb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);
          } else {
             get_page(page);
             skb_fill_page_desc(skb, i, page, offset, copy);
          }
第二，将TCP报文的实际荷载设置8字节（mss设置为最小值48，TCP选项头设置为40字节，48-40=8）。此步实际情况是不默认，正常情况下是无法协商成功，客户端发起的mss协商，默认情况下服务端将不会认可，默认发行版linux系统都开启TSO（TCP