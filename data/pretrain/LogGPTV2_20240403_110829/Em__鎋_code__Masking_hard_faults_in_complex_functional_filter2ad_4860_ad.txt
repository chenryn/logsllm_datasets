### 优化后的文本

---

**授权使用限制：**
本内容仅限清华大学使用。下载时间：2021年3月20日09:58:33 UTC，来源：IEEE Xplore。请遵守相关使用限制。

---

**优化路径与预测路径的比较**

在优化路径中，当数值为0.0时，这是一个特殊情况，导致优化后的结果略逊于预期。虽然优化路径处理了0.0这个特殊值，但由于分支预测错误，实际执行周期数为51个周期，而非预测的33个周期。在整个操作过程中进行条件判断以检查0.0是不可行的。由于Emμ代码仅在程序实际使用其所覆盖的指令时才生效，并且不影响程序的控制流，因此可以使用一个简单的模型来预测启用Emμ代码时程序的性能下降情况。对于每个被Emμ编码的算术操作，只需将1个周期的时间替换为相应算术操作跟踪的平均执行时间即可。

公式1展示了该模型的计算方法：
\[ \text{GPD} = \frac{\text{Cyc}_{\text{orig}} - \sum_{i \in \text{Emu-coded}} N_i \times (\text{EmuCyc}_i - 1)}{\text{Cyc}_{\text{orig}}} \]

如图9所示，预测值与实际观测到的性能下降非常接近。预测值低估了mesa和mgrid的性能下降幅度，因为这些程序中有许多算术操作涉及将0加到另一个数上或与另一个数相乘，而这不是Emμ代码优化的目标路径。由于跟踪路径的平均周期数是在假设非零操作数的情况下预测的，因此对于mesa来说，单精度乘法操作的实际平均周期数为45个周期，而不是预测的33个周期。其他算术操作在mesa和mgrid中的性能下降也类似。

图9右侧显示了在5百万条指令窗口内动态执行浮点运算的比例。随着操作数的增加，性能下降也随之增加。在mcf中，在运行基准测试的5百万条指令窗口内没有动态浮点指令。许多SPECCPU2000基准测试都涵盖了这种情况，这表明它们不使用浮点运算。mcf没有性能下降，表明如果未使用Emμ代码，则不会引入额外开销。对于mesa和vpr，Emμ代码分别导致了1.36倍和2.58倍的性能下降。这些基准测试中只有少量的动态浮点操作被Emμ编码。由于浮点单元故障可能导致程序无法运行，这两种情况说明了Emμ代码是一种有价值的解决方案，它允许具有少量浮点操作的程序继续运行，尽管速度有所下降。

然而，在其他基准测试中，特别是SPECFP基准测试中，观察到了更大的性能下降。由于这些程序主要依赖浮点运算，Emμ代码对它们的影响较大。但如果没有浮点单元，这些程序可能根本无法运行，因此软件模拟通过操作系统陷阱实现是非常接近的。

---

**相关工作**

**硬故障校正**
在硬故障校正领域有大量的研究。优雅性能降级（GPD）可以通过利用现有微处理器中的冗余性来实现，从而利用并行性。例如，许多超标量处理器（如Intel Pentium 4或AMD Athlon）有多个算术逻辑单元（ALU）。如果其中一个单元失效，仍然可以使用其他单元执行代码，尽管这会导致性能下降。要实现GPD，需要功能单元具有一定的模块化特性，这意味着可以将单元从流水线中分离出来。现代微处理器中可以通过设置单元标志为忙状态来实现这一点，正如Srinivasan等人[20]所做的那样。他们表明GPD可以提高1.42倍的可靠性，性能成本低于5%。但在大型加速器结构中几乎没有冗余性，因此这种GPD方法在这种结构中不能提供可靠性，而Emμ代码可以。

**结构复制**
结构复制类似于双重模块冗余（DMR），通过使用两个微处理器运行同一程序并比较结果来实现可靠性。如果结果不同，则需要确定哪个是错误的。为了隔离失效单元，可以采用三重模块冗余（TMR），其中受保护的结构有三个副本。三个结果的一致性被认为是正确的结果。然而，也可以添加额外的功能单元并在需要时启用它们。与GPD类似，这种形式的结构复制要求架构支持在检测到单元失效时开启和关闭单元。结构复制的主要限制是芯片面积开销大。在极端情况下，TMR需要200%的开销来保证可靠性，这对大多数现代架构来说成本过高。Srinivasan等人[20]表明，结构复制可以将可靠性提高到基础值的3.17倍，但成本为2.25倍。然而，复制昂贵的加速器结构（如浮点单元）在面积上是昂贵的，通常更多是为了性能而不是可靠性。Emμ代码允许覆盖这些结构而无需复制。

**Bulletproof**
由Shyam等人[19]提出的Bulletproof是另一种GPD方法，通过在微处理器上运行测试套件并进行检查点恢复来应对故障，并禁用故障结构。虽然Bulletproof需要DMR才能从所有故障点恢复，这在面积上是昂贵的，但Emμ代码不需要。

**DIVA**
Austin[2]提出的DIVA使用额外的流水线阶段来实现更可靠的检查核心，重新执行指令并在发现问题时进行纠正，以检查核心的结果为准。为了使DIVA能够覆盖更大的加速器结构，需要有用于计算结果的单元实现。这样做需要一个额外的昂贵加速器结构副本，而Emμ代码则不需要。

**绕道技术**
Meixner等人[14]展示了如何通过重新编译代码来绕过具有硬故障的结构，称为“绕道”。Emμ代码不需要重新编译代码。

**Core Salvage**
Joseph[11]提出的Core Salvage利用多核系统中的冗余性，在某些指令上陷入虚拟机监控器（VMM）。Emμ代码可以在不进行昂贵的陷阱操作的情况下达到同样的效果。本文还考虑了微代码例程的优化，而绕道技术和Core Salvage则没有。

在现代微处理器中，有许多加速指令，如果使用SD复制会非常昂贵，或者需要扩展其他检查器的能力。例如，修改架构受保护状态的指令（如x86上的INT指令，需要上下文切换）或SSE指令（使用整个浮点流水线执行单个操作）。传统的GPD实现无法用于这些指令的标准实现。复制这些结构会非常昂贵，因为添加一个额外的浮点单元需要大量的芯片面积，更多是为了性能原因而不是可靠性。因此，需要其他方法来纠正这些类型的指令。本研究探讨了这样的技术。

**硬故障检测**
Emμ代码假设有一个底层的硬故障检测机制。硬错误检测已经以多种方式进行了探索。Schuchman和Vijaykumar[18]探讨了在SMT机器上使用冗余线程的方法。Yilmaz等人[15]探讨了附加自检机制的方法。Li等人[12]进行了软件传播硬故障的研究。Constantinides等人[5]探讨了使用固件定期通过扫描锁存器检测错误的方法。Emμ代码假设可以使用这些低开销的有效方法之一来确定何时必须屏蔽硬故障。

**其他相关工作**
Dally[7]表明，通过对程序的数据流图进行分析，可以优化多个浮点操作。他展示了通过组合相同的数字上的加法和乘法操作，可以减少执行时间40%。然而，他使用的跟踪路径是为浮点单元设计的，其各种子操作是开放优化的。由于Emμ代码旨在为浮点单元提供可靠性，这些信息对于创建Emμ代码跟踪路径并不适用。

Corliss等人[6]提出了一个框架，用于将微代码例程插入解码指令以提高性能。他们介绍了许多重要的结构，以便在不影响ISA状态的情况下插入Emμ代码例程。他们引入了基于指令位模式匹配的参数化替换、专用寄存器以及用于分支的应用定制函数（ACF）的DICEPC。有可能利用DISE类框架将Emμ代码跟踪作为ACF插入，如果在检测到硬故障后使用指令操作码作为DISE触发器。

**结论**
本文介绍了Emμ代码作为一种技术，用于掩盖硬件结构中的硬故障，这些结构要么很少使用，要么复制成本很高。我们评估了使用微代码跟踪代替原始指令的成本。研究表明，对浮点算术操作进行微代码编码时，可以实现6倍的性能下降。对于许多程序来说，特别是那些浮点指令较少的程序，6倍的性能下降是可以接受的。对于少于5%的浮点操作被Emμ代码覆盖的工作负载，性能下降仅为1.36倍至2.56倍；对于7%至40%的浮点操作被Emμ代码覆盖的工作负载，性能下降为3.16倍至19.33倍。如果没有使用Emμ代码覆盖的浮点指令，则不会引入性能开销。Emμ代码适用于昂贵的结构复制以及不常用的指令。支持Emμ代码只需要在传统处理器中添加最小的硬件。它需要额外的结构来存储指令信息，并且需要大量的间接分支和数据存储，这些数据在原始指令解码后不再可用。这些问题源于跟踪路径需要微代码分支，我们发现这些分支难以预测，从而增加了性能优化的复杂性。消除这些分支是此类微代码跟踪生成的主要关注点，因为它们对执行时间非常昂贵。我们展示了部分谓词、额外寄存器、微代码的源和目标寄存器的灵活性以及一些新的低成本微操作可以帮助优化跟踪路径，使其比朴素实现快6倍，平均情况下快3.79倍。

**参考文献**
[1] IEEE标准二进制浮点算术。ANSI/IEEE Std 754-1985，1985年8月。[在线]。可访问：http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=30711&isnumber=1316。
[2] T.M. Austin. DIVA: 深亚微米微架构设计的可靠基底。MICRO-32, 第196-208页, 1999年。
[3] D.T. Blaauw, C. Oh, V. Zolotov, 和 A. Dasgupta. 静电迁移分析片上信号互连。IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 27:39–48, 2003.
[4] S. Borkar. 从不可靠组件设计可靠的系统：晶体管变化和退化的挑战。IEEE Micro, 25:10–16, 2005年11-12月。
[5] K. Constantinides, O. Mutlu, T. Austin, 和 V. Bertacco. 基于软件的在线硬件缺陷检测机制、架构支持和评估。MICRO-40, 第97-108页, 2007年12月。
[6] M.L. Corliss, E.C. Lewis, 和 A. Roth. DISE: 可编程宏引擎用于应用程序定制。ISCA-30, 第362-373页, 2003年。
[7] W.J. Dally. 浮点操作的微观优化。ASPLOS, 第283-289页, 1989年。
[8] J.R. Hauser. SoftFloat 2b, 2002年5月。[在线]。可访问：http://www.jhauser.us/arithmetic/SoftFloat.html。
[9] G. Hinton, D. Sager, M. Upton, D. Boggs, D. Carmean, A. Kyker, 和 P. Roussel. Pentium 4处理器的微架构。Intel Technology Journal, Q1:1-13, 2001年。
[10] P.Y.T. Hsu 和 E.S. Davidson. 高度并发标量处理。ISCA-13, 第386-395页, 1986年。
[11] R. Joseph. 探索多核架构中的挽救技术。HPCR, 2005年。
[12] M.-L. Li, P. Ramachandran, S.K. Sahoo, S.V. Adve, V.S. Adve, 和 Y. Zhou. 理解硬错误向软件传播及其对弹性系统设计的影响。ASPLOS-13, 第265-276页, 2008年, 纽约, NY, USA, ACM。
[13] S.A. Mahlke, R.E. Hank, J.E. McCormick, D.I. August, 和 W.W. Hwu. ILP处理器全预判和部分预判执行支持的比较。ISCA, 第138-149页, 1995年。
[14] A. Meixner 和 D.J. Sorin. 绕道：翻译软件以绕过简单核心中的硬故障。DSN-38, 第80-89页, 2008年。
[15] S. Ozev, D. Sorin, 和 M. Yilmaz. 微处理器功能单元中硬延迟故障的低成本运行时诊断。Computer Design, 2007. ICCD 2007. 第25届国际会议, 第317-324页, 2007年10月。
[16] J.M. Rabaey. 数字集成电路：设计视角。Prentice-Hall, 上萨德尔河, NJ, 1996年。
[17] E. Rotenberg, S. Bennett, 和 J.E. Smith. 跟踪缓存：一种低延迟高带宽指令获取方法。MICRO-29, 第24-35页, 华盛顿特区, USA, 1996年, IEEE计算机学会。
[18] E. Schuchman 和 T.N. Vijaykumar. Blackjack: SMT上的冗余线程硬错误检测。DSN-37, 2007年。
[19] S. Shyam, K. Constantinides, S. Phadke, V. Bertacco, 和 T. Austin. 微处理器流水线超低成本缺陷保护。ASPLOS, 第113-119页, 2006年。
[20] J. Srinivasan, S. Adve, P. Bose, 和 J. Rivers. 利用结构复制提高生命周期可靠性。ISCA, 第520-531页, 2005年。
[21] AMD公司员工。AMD x86-64架构程序员手册, 第4卷: 128位媒体指令。Advanced Micro Devices, 2002年。
[22] J.H. Stathis 和 S. Zafar. MOS器件中的负偏置温度不稳定性综述。Microelectronics and Reliability, 46:270-286, 2006年2月。
[23] M.T. Yourst. PTLSim: 一个循环精确的全系统x86-64微架构模拟器。IPASS, 第23-34页, 2007年。

---

希望这些改进能帮助您更好地传达您的观点。如果有任何进一步的需求，请随时告诉我！