title:SLAKE: Facilitating Slab Manipulation for Exploiting Vulnerabilities
in the Linux Kernel
author:Yueqi Chen and
Xinyu Xing
SLAKE: Facilitating Slab Manipulation for Exploiting
Vulnerabilities in the Linux Kernel
Yueqi Chen
PI:EMAIL
Xinyu Xing
PI:EMAIL
The Pennsylvania State University
The Pennsylvania State University
ABSTRACT
To determine the exploitability for a kernel vulnerability, a secu-
rity analyst usually has to manipulate slab and thus demonstrate
the capability of obtaining the control over a program counter or
performing privilege escalation. However, this is a lengthy process
because (1) an analyst typically has no clue about what objects
and system calls are useful for kernel exploitation and (2) he lacks
the knowledge of manipulating a slab and obtaining the desired
layout. In the past, researchers have proposed various techniques
to facilitate exploit development. Unfortunately, none of them can
be easily applied to address these challenges. On the one hand, this
is because of the complexity of the Linux kernel. On the other hand,
this is due to the dynamics and non-deterministic of slab variations.
In this work, we tackle the challenges above from two perspec-
tives. First, we use static and dynamic analysis techniques to explore
the kernel objects, and the corresponding system calls useful for
exploitation. Second, we model commonly-adopted exploitation
methods and develop a technical approach to facilitate the slab
layout adjustment. By extending LLVM as well as Syzkaller, we
implement our techniques and name their combination after SLAKE.
We evaluate SLAKE by using 27 real-world kernel vulnerabilities,
demonstrating that it could not only diversify the ways to perform
kernel exploitation but also sometimes escalate the exploitability
of kernel vulnerabilities.
CCS CONCEPTS
· Security and privacy → Operating systems security; Software
security engineering;
KEYWORDS
OS Security; Vulnerability Exploitation;
ACM Reference Format:
Yueqi Chen and Xinyu Xing. 2019. SLAKE: Facilitating Slab Manipulation
for Exploiting Vulnerabilities in the Linux Kernel. In Proceedings of 2019
ACM SIGSAC Conference on Computer and Communications Security, London,
United Kingdom, November 11–15, 2019 (CCS’19), 16 pages.
https://doi.org/10.1145/3319535.3363212
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS’19, November 11–15, 2019, London, United Kingdom
© 2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-6747-9/19/11. . . $15.00
https://doi.org/10.1145/3319535.3363212
1 INTRODUCTION
Despite extensive code review, a Linux kernel, like all other soft-
ware, still inevitably contains a large number of bugs and vulnerabil-
ities [42]. Compared with vulnerabilities in user-level applications,
a vulnerability in kernel code is generally more disconcerting be-
cause kernel code runs with a higher privilege and the successful
exploitation of a kernel vulnerability could provide an attacker with
full root access.
One straightforward solution to minimize the damage of Linux
kernel defects is to have software developers and security analysts
patch all the bugs and vulnerabilities immediately. However, even
though allowing anyone to contribute to code development and
fix, the Linux community still lacks the workforce to sift through
each software bug timely. As such, the Linux community typi-
cally prioritizes kernel vulnerability remediation based on their
exploitability [30] (i.e., assessing a software bug based on ease of
its exploitation).
To determine the exploitability for kernel vulnerabilities, an
analyst typically needs to manipulate slab (i.e., heap in kernel),
manually craft working exploits and demonstrate the capability
in obtaining control over a program counter or escalating privi-
lege for a user process. In general, this is a time-consuming and
labor-intensive process. On the one hand, this is because given a
kernel vulnerability, a security analyst lacks the knowledge about
what kernel objects and system calls are useful for vulnerability
exploitation. On the other hand, this is because even if the analyst
figures out the kernel objects, as well as the corresponding system
calls, he may still have no clue about how to use them to obtain the
desired slab layout accordingly.
In the past, there are many techniques developed to facilitate the
exploit development (e.g., [3, 4, 6, 19, 20, 24, 35, 46, 48]), and a recent
research work indicates an analyst can use various test cases to ex-
plore the desired memory layout for vulnerability exploitation [15].
For the two following reasons, none of these techniques, however,
can be directly applied or tweaked to tackle the aforementioned
challenges. First, a Linux kernel is a complex system, in which many
kernel objects useful for exploitation cannot be allocated through
test cases regularly used. As we will show in Section 6, even merely
using Syzkaller (a kernel fuzzing tool) [13] to generate test cases,
we are still not able to pinpoint sufficient kernel objects suitable for
kernel exploitation. Second, a Linux kernel contains many routines,
making the slab very dynamic and non-deterministic. Even if an
analyst could observe the desired memory layout through one test
case, he is highly unlikely to use the same test case to obtain that
layout as he expects.
In this work, we propose a new approach, to facilitate the develop-
ment of working exploits for various kinds of kernel vulnerabilities
or, more precisely, a technique to facilitate slab manipulation with
the goal of obtaining the capability in hijacking control flow1. We
name our technique after SLAKE, standing for SLAb manipulation
for Kernel Exploitation. Technically speaking, it tackles the chal-
lenges above from the two angles. First, SLAKE performs static and
dynamic analysis to identify the objects useful for kernel exploita-
tion and track down corresponding system calls. Second, SLAKE
models kernel exploitation methods commonly adopted. Using the
model, it then designs a technical approach to facilitate the capabil-
ity of security analysts in adjusting slab layout and thus obtaining
the control over the program counter.
Given the pioneering research works (e.g., [24, 45, 46]), we do not
claim SLAKE is the first technique designed for kernel exploitation
facilitation. However, we argue that it is the first work that can
facilitate the manipulation of the slab and thus assist an analyst in
hijacking the control over kernel execution. Besides, SLAKE is the
first work that can facilitate kernel exploitation for various types
of kernel vulnerabilities (e.g., UAF, Double Free, and OOB). Using
27 real-world kernel vulnerabilities, we show that SLAKE could
not only identify the kernel objects and system calls commonly
adopted by professional analysts for kernel exploitation but more
importantly, pinpoint objects and system calls that have never
been used in the public exploits. We argue this is a very beneficial
characteristic for security analysts because, as we will show in
Section 6, this could significantly diversify the working exploits
and potentially escalate the exploitability for kernel vulnerabilities.
In summary, this paper makes the following contributions.
• We design a new technical approach that utilizes static/dy-
namic analysis to identify the kernel objects and system calls
useful for kernel exploitation.
• We model commonly-adopted kernel exploitation methods
and then design a manipulation method to adjust a slab and
thus obtain the layout desired for kernel exploitation.
• By extending LLVM and Syzkaller, we implement SLAKE
and demonstrate its utility in crafting working exploits by
using 27 real-world vulnerabilities in the Linux kernel.
The rest of this paper is organized as follows. Section 2 describes
the background and the key challenges of this work. Section 3 spec-
ifies how to utilize static and dynamic analysis to explore objects
and system calls useful for kernel exploitation. Section 4 introduces
how to adjust slab layout. Section 5 and 6 describe the implemen-
tation and evaluation of SLAKE. Section 7 discusses some related
issues and future work, followed by the discussion of related work
in Section 8. Finally, we conclude the work in Section 9.
2 BACKGROUND AND CHALLENGES
In this section, we first describe the problem scope, assumptions,
and objectives of this work. Then, we introduce the technical back-
ground, followed by the discussion of kernel exploitation chal-
lenges.
2.1 Problem Scope, Assumptions and Goals
Problem scope. This work focuses only on developing exploita-
tion techniques for those kernel vulnerabilities that result in the
corruption of the memory managed by SLAB/SLUB allocator. We
1As we will clarify in Section 2.1, this work focuses on the ability to hijack control
flow but not that to escalate privilege for a userland process.
claim the problem in this scope is meaningful and non-trivial. This
is because, after being triggered, most kernel vulnerabilities only
demonstrate the capability in corrupting memory regions tied to
the SLAB/SLUB and, more importantly, there has not yet been a
generic, systematic approach that could facilitate the manipulation
of kernel memory layout and thus benefit the exploitation of such
vulnerabilities.
Assumptions. By definition, the capability of a vulnerability is
a power, indicating at which memory addresses the vulnerability
gives an adversary the ability to overwrite data freely. In this work,
we consider the capability of a vulnerability through a PoC pro-
gram, which could panic kernel execution but not perform actual
exploitation. Under the assistance of address sanitizer KASAN [10]
and other debugging tools (e.g., GDB [40]), a security researcher
could manually learn the capability of a vulnerability. It should
be noted we do not assume researchers could go beyond the ca-
pability manifested by a PoC and find more powerful capability
for a target vulnerability. For example, if the PoC demonstrates
the ability to overwrite only one byte, but the vulnerability could
actually provide the capability of performing an arbitrary write, we
conservatively assume a researcher could obtain only the one-byte
overwriting capability.
In addition, we assume that a capability of controlling program
counter directly implies the exploitability of a vulnerability. On
the one hand, this is because many previous works have already
demonstrated an adversary can easily bypass kernel mitigation
and complete successful exploitation as long as he could hijack the
control of kernel execution [2, 7, 9, 14, 21ś23, 27, 28, 32, 45]. On
the other hand, this is because, with the ability to hijack kernel
execution, an adversary can always convert this capability into a
way to overwrite critical kernel object and thus carry out privilege
escalation or information leakage [17].
Goals. As is mentioned in the section above, the goals of this work
are in two folds. First, it aims to provide security researchers with
the ability to identify useful kernel objects and corresponding sys-
tem calls. Second, it aims to facilitate security researchers’ capability
in obtaining a desired memory layout for kernel exploitation. As
a result, different from the research in exploitation automation
(e.g., [3, 6]), we focus on ❶ building an automated approach to help
security analysts identify useful kernel objects and system calls, ❷
building a technical approach to facilitate researchers’ capability in
memory layout manipulation. In fact, the identification of object
and system calls, as well as memory manipulation are just one key
component of kernel exploitation. Therefore, we do not claim the
work is an end-to-end automated approach for kernel exploitation.
2.2 Technical Background
Here, we briefly introduce how SLAB/SLUB allocator works in
Linux kernel, followed by the kernel exploitation techniques com-
monly adopted in the real world.
2.2.1
SLAB/SLUB Allocator. SLAB/SLUB allocator organizes
physical memory in a unit of cache. Kernel objects in the same
cache share the same type or have similar sizes. Inside each cache
are a set of slabs which are contiguous pages. For each newly cre-
ated slab, SLAB/SLUB allocator partitions it into multiple individual
slots. For SLUB allocator, each unoccupied slot contains a meta-
data header which stores the address of the next slot unoccupied.
Through metadata, unoccupied slots are organized in the form of a
singly linked list with a dummy head freelist. Slightly different
from SLUB allocator, SLAB allocator does not utilize metadata head-
ers to organize the slots unoccupied. Rather, it employs an index
array also named freelist to implement the logic of the linked
list. When other kernel components request a memory region for a
new object, both SLUB and SLAB allocator retrieve and assign the
first slot of the list to hold the new object and update the freelist.
When an object is deallocated (freed), both SLUB and SLAB alloca-
tor reclaim the freed slot and add it back to the beginning of the
linked list. As such, SLAB/SLUB allocator work in a fashion of LIFO
(Last In, First Out).
2.2.2 Kernel Exploitation Approaches. The kernel exploitation
can be viewed as a three-step procedure. ❶ an adversary summa-
rizes the type of a target vulnerability as well as at which memory
addresses he could manipulate data freely (i.e., the capability of cor-
rupting memory regions). ❷ The adversary determines the specific
exploitation approaches to obtaining the ability to hijack control
flow. ❸ Using the primitive of control flow hijack, the adversary dis-
ables kernel mitigation and protection, and thus performs ultimate
exploitation.
Generally speaking, four exploitation approaches could lead to
a control over the program counter. In the following, we briefly
introduce these exploitation approaches. It should be noted that
this work does not discuss the techniques developed for vulnerabil-
ity capability summary nor those for bypassing mitigation. As is
described in Section 2.1, they are out of the scope of this research
work.
I. Manipulation through OOB write. Given a vulnerability with
the ability to perform an out-of-bounds (OOB) write, there are
two common approaches to hijacking control flow. The first is
to overwrite a function pointer in the adjacent object and then
dereference that pointer for exploitation. For another approach, the
exploitation overwrites a data pointer in the adjacent object and
then dereference a function pointer through that data pointer. To
illustrate this, Figure 1a depicts an example. In regular operations,
we assume Linux kernel dereferences the function pointer fptr
֒→ through the pointer ptr referencing the kernel object A. Using
the OOB write, an attacker could first overwrite the data object
pointer ptr, referencing it to a memory region under his control
(e.g., physmap [20, 37] or userland memory). In the memory area
under the attacker’s control, he could then carefully craft a fake
data object with the function pointer fptr referencing the target of
the attacker’s desire.
II. Manipulation through UAF. Different from the manipula-
tion approaches tied to OOB vulnerabilities, use-after-free (UAF)
vulnerabilities have unique exploitation approach. Given a UAF
vulnerability, an adversary first selects a kernel object (i.e., a spray
object), the content of which is completely under his control. Then,
he overlays that object on top of a vulnerable object. In this way,
the attacker could overwrite the critical data (e.g., function or data
object pointer) in that vulnerable object. Similar to the aforemen-
tioned approach, with the ability to manipulate a function or data
object pointer, an attacker could easily obtain control over the
kernel execution.
III. Manipulation through double free. With respect to the
double free vulnerability, when the vulnerability is triggered, the
metadata header of a vulnerable object refers to itself. As such, its
exploitation could be achieved through the process below. First,
an adversary carefully selects a victim object. Second, through
heap spray, he uses that selected object to take over the freed slot
pertaining to that self-referenced metadata. Third, he selects a spray
object and allocates that object. As is shown in Figure 1b, after the
allocation of the victim object, the freelist is updated with the
value of metadata header, and the freelist references the victim
object selected. As a result, the adversary can leverage the spray
object to overwrite the function or object pointer residing in the
victim object. Again, similar to the aforementioned exploitation
approach tied to OOB, this allows the adversary to obtain the control
over the program counter easily.
IV. Manipulation through metadata corruption. In addition
to the manipulation of function and data object pointers, all the
aforementioned vulnerabilities provide an attacker with the poten-
tial to tamper with the metadata header of free slots. As such, for
all the aforementioned vulnerability, an alternative manipulation
approach is to overwrite metadata header and trick SLUB alloca-
tor into allocating a victim object to a memory region under an
attacker’s control. To illustrate this, Figure 1c shows an example.
Through the capability of a vulnerability, an attacker first over-
writes the metadata header, referencing it to a region under the
attacker’s control. Since the metadata header indicates the next
unoccupied region, the attacker could allocate a series of objects
and force one victim object appearing at that desired memory re-
gion. He could easily manipulate the function pointer or data object
pointer in the victim object, trigger the function pointer dereference
and thus obtain the control over the program counter.
2.3 Key Challenges
Despite the commonly-adopted approaches mentioned above, it is
still challenging for an adversary and even a professional security
analyst to perform a successful exploitation. This is mainly because
an adversary lacks the following knowledge.
❶ Which kernel objects are suitable for exploitation? In ker-
nel exploitation, an adversary needs to select an exploitation ap-
proach and corresponding object(s). Take an OOB vulnerability for
example. To hijack control flow through this vulnerability, an ad-
versary typically overwrites the critical data in the adjacent object.
However, it is common that the adjacent object may not contain
critical data such as function or object pointers. Therefore, one
common operation for that adversary is to allocate an object (with
a function pointer enclosed) to the corresponding location prior
to the trigger of that vulnerability. However, a Linux kernel en-
closes many objects. In order to find that appropriate object for his
exploitation, the adversary generally has to seek through all the
objects. In this process, he also has to take the vulnerable object
into consideration. This is simply because SLUB/SLAB allocator
manages and groups data objects based on their types and sizes,
and only the data objects sharing the same type or similar sizes
could be placed in the same slab.
e trigger OOB write
e trigger OOB write
Before trigger OOB write
vul obj
vtm obj
ptr
fptr
benign target
obj A
After trigger OOB write
vul obj
vtm obj
overwritten ptr
fptr
malicious target
ee
After trigger double free


metadata 
header
Before corrupt metadata header

metadata header

self-referenced free slot
vul obj
free slot
free slot
After allocate vtm obj


ptr
benign target
After corrupt metadata header

vtm obj
After allocate spray obj


ptr
malicious target
vul obj
free slot
overwritten 
metadata header

free slot

fake obj in memory region 
under attacker’s control 
spray/vtm obj
free slot in memory region 
under attacker’s control
(a) Exploitation through OOB write
(b) Exploitation through double free
(c) Exploitation through corrupting metadata
Figure 1: The illustration of some kernel exploitation approaches.
❷ How to (de)allocate objects and dereference correspond-
ing pointers? An adversary typically utilizes a set of system calls
to (de)allocate selected objects or dereference pointers through
these objects. In a Linux kernel, there are hundreds of system calls
with various arguments. Given a target object, there has not yet
been a knowledge base indicating which group of system calls can
be used for its (de)allocation, nor prior knowledge specifying which
system calls could be applied to dereference a function pointer
through that target object. Under this situation, when performing
kernel exploitation, adversaries typically seek the kernel objects