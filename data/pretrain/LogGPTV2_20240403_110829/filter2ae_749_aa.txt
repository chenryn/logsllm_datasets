**作者： 知道创宇404区块链安全研究团队**  
**发布时间： 2018/08/01**
**更新于 2018/08/20 :** 修正了原文中的一处错误，感谢
[@None](https://www.seebug.org/accounts/profile/354f9596)在评论区的指正。
## 0x00 前言
2010年，`Laszlo` 使用 `10000` 个比特币购买了两张价值25美元的披萨被认为是比特币在现实世界中的第一笔交易。
2017年，区块链技术随着数字货币的价格暴涨而站在风口之上。谁也不会想到，2010年的那两块披萨，能够在2017年末价值 `1.9亿美元`。
以太坊，作为区块链2.0时代的代表，通过智能合约平台，解决比特币拓展性不足的问题，在金融行业有了巨大的应用。
通过智能合约进行交易，不用管交易时间，不用管交易是否合法，只要能够符合智能合约的规则，就可以进行无限制的交易。
在巨大的经济利益下，总会有人走上另一条道路。
古人的盗亦有道，在虚拟货币领域也有着它独特的定义。只有对区块链技术足够了解，才能在这场盛宴中 `偷`
到足够多的金钱。他们似那黑暗中独行的狼，无论是否得手都会在被发现前抽身而去。
`2018/03/20`,在
[《以太坊生态缺陷导致的一起亿级代币盗窃大案》[19]](https://mp.weixin.qq.com/s/Kk2lsoQ1679Gda56Ec-zJg) 和 [《揭秘以太坊中潜伏多年的“偷渡”漏洞，全球黑客正在疯狂偷币》[20]](https://paper.seebug.org/547/)
两文揭秘 `以太坊偷渡漏洞（又称为以太坊黑色情人节事件）` 相关攻击细节后，知道创宇404团队根据已有信息进一步完善了相关蜜罐。
`2018/05/16`,知道创宇404区块链安全研究团队对 `偷渡漏洞` 事件进行预警并指出该端口已存在密集的扫描行为。
`2018/06/29`, `慢雾社区` 里预警了 `以太坊黑色情人节事件（即偷渡漏洞）`
新型攻击手法，该攻击手法在本文中亦称之为：`离线攻击`。在结合蜜罐数据复现该攻击手法的过程中，知道创宇404区块链安全研究团队发现：在真实场景中，还存在
`另外两种` 新型的攻击方式： `重放攻击` 和 `爆破攻击`，由于此类攻击方式出现在 `偷渡漏洞` 曝光后，我们将这些攻击手法统一称为
`后偷渡时代的盗币方式`。
本文将会在介绍相关知识点后，针对 `偷渡漏洞` 及 `后偷渡时代的盗币方式`，模拟复现盗币的实际流程，对攻击成功的关键点进行分析。
## 0x01 关键知识点
所谓磨刀不误砍柴功，只有清楚地掌握了关键知识点，才能在理解漏洞原理时游刃有余。在本节，笔者将会介绍以太坊发起一笔交易的签名流程及相关知识点。
### 1.1 RLP 编码
> RLP (递归长度前缀)提供了一种适用于任意二进制数据数组的编码，RLP已经成为以太坊中对对象进行序列化的主要编码方式。
`RLP` 编码会对字符串和列表进行序列化操作，具体的编码流程如下图：
在此，也以 `3.4.1节` 中 `eth_signTransaction` 接口返回的签名数据为例，解释该签名数据是如何经过 `tx` 编码后得到的。
    result 字段中的 raw 和 tx 如下：
    "raw": "f86b01832dc6c083030d4094d4f0ad3896f78e133f7841c3a6de11be0427ed89881bc16d674ec80000801ba0e2e7162ae34fa7b2ca7c3434e120e8c07a7e94a38986776f06dcd865112a2663a004591ab78117f4e8b911d65ba6eb0ce34d117358a91119d8ddb058d003334ba4
    "
    "tx": {
            "nonce": "0x1",
            "gasPrice": "0x2dc6c0",
            "gas": "0x30d40",
            "to": "0xd4f0ad3896f78e133f7841c3a6de11be0427ed89",
            "value": "0x1bc16d674ec80000",
            "input": "0x",
            "v": "0x1b",
            "r": "0xe2e7162ae34fa7b2ca7c3434e120e8c07a7e94a38986776f06dcd865112a2663",
            "s": "0x4591ab78117f4e8b911d65ba6eb0ce34d117358a91119d8ddb058d003334ba4",
            "hash": "0x4c661b558a6a2325aa36c5ce42ece7e3cce0904807a5af8e233083c556fbdebc"
    }
根据 RLP 编码的规则，我们对 tx 字段当作一个列表按顺序进行编码(hash除外)。由于长度必定大于55字节，所以采用最后一种编码方式。
暂且先抛开前两位，对所有项进行RLP编码，结果如下：
合并起来就是：01832dc6c083030d4094d4f0ad3896f78e133f7841c3a6de11be0427ed89881bc16d674ec80000801ba0e2e7162ae34fa7b2ca7c3434e120e8c07a7e94a38986776f06dcd865112a2663a004591ab78117f4e8b911d65ba6eb0ce34d117358a91119d8ddb058d003334ba4
一共是 214 位，长度是 107 字节，也就意味着第二位是 `0x6b`，第一位是 `0xf7 + len(0x6b) = 0xf8`,这也是最终
`raw`
的内容：`0xf86b01832dc6c083030d4094d4f0ad3896f78e133f7841c3a6de11be0427ed89881bc16d674ec80000801ba0e2e7162ae34fa7b2ca7c3434e120e8c07a7e94a38986776f06dcd865112a2663a004591ab78117f4e8b911d65ba6eb0ce34d117358a91119d8ddb058d003334ba4`
### 1.2 keystore 文件及其解密
`keystore` 文件用于存储以太坊私钥。为了避免私钥明文存储导致泄漏的情况发生，`keystore` 文件应运而生。让我们结合下文中的
`keystore` 文件内容来看一下私钥是被如何加密的：
    keystore文件来源：https://github.com/ethereum/tests/blob/2bb0c3da3bbb15c528bcef2a7e5ac4bd73f81f87/KeyStoreTests/basic_tests.json，略有改动
    {
        "address": "0x008aeeda4d805471df9b2a5b0f38a0c3bcba786b",
        "crypto" : {
            "cipher" : "aes-128-ctr",
            "cipherparams" : {
                "iv" : "83dbcc02d8ccb40e466191a123791e0e"
            },
            "ciphertext" : "d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c",
            "kdf" : "scrypt",
            "kdfparams" : {
                "dklen" : 32,
                "n" : 262144,
                "r" : 1,
                "p" : 8,
                "salt" : "ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19"
            },
            "mac" : "2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097"
        },
        "id" : "3198bc9c-6672-5ab3-d995-4942343ae5b6",
        "version" : 3
    }
在此，我将结合私钥的加密过程说明各字段的意义：
**加密步骤一：使用aes-128-ctr对以太坊账户的私钥进行加密**
本节开头已经说到，`keystore` 文件是为了避免私钥明文存储导致泄漏的情况发生而出现的，所以加密的第一步就是对以太坊账户的私钥进行加密。这里使用了
`aes-128-ctr` 方式进行加密。设置 `解密密钥` 和 `初始化向量iv` 就可以对以太坊账户的私钥进行加密，得到加密后的密文。
`keystore` 文件中的`cipher`、`cipherparams`、`ciphertext`参数与该加密步骤有关：
  * `cipher`: 表示对以太坊账户私钥加密的方式，这里使用的是 `aes-128-ctr`
  * `cipherparams` 中的 `iv`: 表示使用 `aes` 加密使用的初始化向量 `iv`
  * `ciphertext`: 表示经过加密后得到的密文 
**加密步骤二：利用kdf算法计算解密密钥**
经过加密步骤一，以太坊账户的私钥已经被成功加密。我们只需要记住 `解密密钥` 就可以进行解密，但这里又出现了一个新的问题，`解密密钥`
长达32位且毫无规律可言。所以以太坊又使用了一个 `密钥导出函数(kdf)` 计算解密密钥。在这个 `keystore` 文件中，根据 `kdf`
参数可以知道使用的是 `scrypt` 算法。最终实现的效果就是：对我们设置的密码与 `kdfparams` 中的参数进行 `scrypt` 计算，就会得到
`加密步骤1` 中设置的 `解密密钥`.
`keystore` 文件中的 `kdf`、`kdfparams` 参数与该加密步骤有关：
  * `kdf`: 表示使用的 `密钥导出函数` 的具体算法 
  * `kdfparams`: 使用密钥导出函数需要的参数 
**加密步骤三：验证用户密码的正确性**
假设用户输入了正确的密码，只需要通过步骤一二进行解密就可以得到正确的私钥。但我们不能保证用户每次输入的密码都是正确的。所以引入了验算的操作。验算的操作十分简单，取步骤二解密出的密钥的第十七到三十二位和
`ciphertext` 进行拼接，计算出该字符串的 `sha3_256` 的值。如果和 `mac` 的内容相同，则说明密码正确。
`keystore` 文件中的 `mac` 参数与该步骤有关：
  * `mac`: 用于验证用户输入密码的正确性。 
综上所述，要从 `keystore` 文件中解密出私钥，所需的步骤是：
  1. 通过 `kdf` 算法生成解密私钥
  2. 对解密私钥进行验算，如果与 `mac` 值相同，则说明用户输入的密码正确。
  3. 利用解密私钥解密`ciphertext`，获得以太坊账户的私钥