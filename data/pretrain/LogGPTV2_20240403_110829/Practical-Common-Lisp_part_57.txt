## Page 286
先将其转化成可管理的Lisp对象，然后再写回到另一个正确格式化的二进制文件中。
存中Lisp对象之间的映射关系。使用这个库，编写一个可以读取二进制文件的程序将会很容易，
构来保存。
主要优点。为了同时满足这些要求，它们通常采用可以轻易映射到程序内存中数据结构的磁盘结
的话，将会得到不可打印的字符。
者的所有数字都可以被解释成表示人类可读文本的字符，而后者所含有的数据如果被解释成字符
二进制形式编码的数字罢了。不过，通常会把所谓“文本”文件和“二进制”文件区别看待，前
24.1
的宏也只有20行。
你将会编写很多代码。但是当一切都已完成时，整个库的规模将会少于150行代码，而其中最长
取和写入二进制数据。由于你将循序渐进地开发这个库，包括几个部分可用的版本，因此看起来
新的控制构造的示例，它将通用语言转化成了一种用于处理特定问题的专用语言，在本例中是读
件中诸如艺术家和专辑名这类元数据的机制。这个库同样也是一个关于如何使用宏来为语言扩展
即将编写的这个库将提供一种简单的方式，来定义那些在二进制文件所定义的磁盘结构和内
①在ASCII编码中，前32个字符是不可打印的控制字符，最初用来控制终端服务器的行为，让其做到诸如通过喇叭
二进制文件格式通常被设计成可以简洁高效地进行解析，这是它们相对于基于文本的格式的
在一个足够低的抽象层面上，所有文件都是“二进制”的，因为看起来它们只是含有一些以
②
范的数据表示，使其可以映射到特定类型的机器或编程语言的实际内存中的数据表示上。
中的表示方式也取决于程序所运行的硬件。这样，任何倾向于可移植的文件格式都必须为其所有数据类型定义规
在解除映射时会被写回到文件中。不过，这些格式都是平台相关的，因为即便像整数这样的简单数据类型在内存
如C语言这样的底层语言就可以将含有文件内容的内存区域当作任何其他的内存来处理。写入该内存区域的数据
某些二进制文件格式确实是内存数据结构。在许多操作系统中，将一个文件直接映射进内存是有可能的，然后
文件中看到：换行、回车以及水平制表(tab)。
发声、回退一个字符、换行以及将光标移到行首之类的操作。在这32个控制字符串里，通常只有三个可以在文本
二进制文件
实践：解析二进制文件
www.TopSage.com
---
## Page 287
你就可以解出一个整数的最不重要的八位元：
接受一个字节描述符和需要解出位数据的那个整数，然后返回由解出的位所代表的整数。这样，
需要解出（或设置）的位数量以及最右边那一位相对整数中最不重要位来说以零开始的位置。LDB
数中的位数量和它们的位置由BYTE函数所创建的一个位描述符所指定。BYTE接受两个参数，即
节（load byte）的意思，可用来从一个整数中解出和设置（通过sETF）任意数量的连续位。“整
big-endian?形式保存的，那么以最重要字节优先的顺序，你可以用下面的函数来读取这样一个数
个字节相加，从而将它们组合成单个整数。举个例子，假设指定这个16位量的二进制格式是以
式。为了读取这样一个整数，你需要读取两个字节，将一个字节乘以256，也就是2"，再跟另--
用来编写那些读写给定二进制格式中使用的基本数据类型的框架。
的数字、文本字符串以及位字段等，然后再复合成更复杂的结构。所以你的首要任务是定义一个
向wRITE-BYTE传递介于0到255之间的数字来向一个(unsigned-byte 8)输出流写入字节。
打开的输入流将在每次传给READ-BYTE时返回一个介于O到255之间的整数。同样地，你可以通过
元。当你在处理二进制文件时,需要把该参数设定为（unsigned-byte 8）。通过:element-type
24.2
270
②LDB跟与之相关的函数DPB均是来自DECPDP-10计算机的汇编函数，它们本质上做相同的事情。无论特定Common
①术语big-endian和它的反义词little-endian来自Jonathan Swift的Gulliver'sTravels（《格列佛游记》），用来表达-一个多
不过，Common Lisp提供了一种更便利的方式来进行这些按位处理。函数LDB，就是加载字
在单独字节的层面之上，多数二进制格式都使用了一小组基本数据类型—以多种方式编码
读写二进制文件的起始点是打开一个用于读写单个字节的文件。如同第14章里讨论的那样，
CL-USER>
CL-USER> (defvar *num* 0)
可以将LDB与SETF配合使用来设置一个保存在可SETF的位置上的整数的指定位。
为了得到下一个八位元，可以使用字节描述符(byte 88)，如下所示：
(ldb (byte 8 0) #xabcd) → 205 ; 205 is #xcd 
(defun read-u2 (in)
先举一个简单的例子，假设你正在处理一个将无符号16位整数作为基本数据类型的二进制格
*NUM*
(ldb (byte 8 8) #xabcd) → 171 ; 171 is #xab 
，
Lisp实现使用的是何种内部表示法，两个函数都运行在以二进制补码表示的整数上。
Holy Wars and a Plea for Peace”, 地h址是http://khavrinen.lcs.mit.edu/wollman/ien-137.txt。
事的更多隐情，以及术语big-endian和little-endian是最早以这种含义应用在哪里的，可以阅读DannyCohen的“On
紧要的。当然，尽管你可以在同样好的两种方式中任意选择，但可以保证的是并非人人都同意。要想了解关于此
位量时由ab和cd两个字节所组成。对于一台电脑来说，只要各方意见一致，以何种顺序保存这两个字节都是无关
字节的数字在诸如内存和文件中保存时所采用的字节顺序。例如，数字43981，其十六进制为abcd，当表示成16
(+(*(read-byte in) 256)(read-byte in)))
二进制格式基础
第24章
(setf (ldb (byte 8 0) *num*) 128)
实践：解析二进制文件
www.TopSage.com
---
## Page 288
point)。例如，ASC就是一种字符编码，它将0到127之间的数字映射到了拉丁字母表的一些特定
一个字符编码定义了从正整数到字符之间的映射。映射表中的每个数字被称为一个代码点（code
编码一个字符串。不过最起码来讲，二进制格式必须指定究竟需要编码多少个单独的字符。
码的数字所做的那样。并且正如你可以用多种方式来编码一个整数一样，你也可以用多种方式来
24.3
（endianness）以及有符号或无符号的格式。
字节，只需以同样的字节描述符来使用LDB就可以了。
为了将字节转化成字符，你既需要知道字符的编码（code)，也需要知道编码方式（encoding)。
① Common Lisp也提供了用来对整数进行移位和处理掩码的函数，这种方式可能对C和Java程序员来说更熟悉些。例
文本字符串是另一种可能在许多二进制格式中遇到的基本数据类型。当你逐字节地读取文件
当然，你也可以用许多其他的方式来编码整数-
为了把一个数字写成16位整数，需要解出单独的8位字节并逐个地写它们。为了解出单独的
(defun write-u2 (out value)
(defun read-u2 (in)
因此，也可以这样来编写read-u2：
65408
CL-USER> *num*
255
CL-USER> (setf (ldb (byte 8 8) *num*) 255)
128
章节里你将用到的各种按位操作，使用LDB和BYTE将是既便利又符合习惯的CommonLisp风格。
如，你还可以用第三种方式编写read-u2，像下面这样使用那些函数：
128
它们合并在一起。另一个函数LOGAND可以做按位与，这可用来掩盖特定的位。尽管如此，对于本章和接下来的
数对一个整数进行移位，当其第二个参数为正时左移，为负时右移。LOGIOR通过对整数的每个位做逻辑或来将
名字LOGIOR和ASH是LOGical Inclusive OR（逻辑同或）和Arithmetic SHift（算术移位）的简称。ASH以给定的位
public int readu2
该函数几乎跟下面的Java方法完全等价：
return (in.read() << 8)I(in.read());
(write-byte (ldb (byte 8 0) value) out))
(let
(logior (ash
二进制文件中的字符串
u2))
(setf
(setf
（(u20)
(ldb
(read-byte in) 8) (read-byte in)))
(InputStream in) throws IoException {
(byte 8 8) value) out)
(read-byte in))
www.TopSage.com
24.3
-使用不同的字节数、不同的尾部处理
二进制文件中的字符串
271
N
---
## Page 289
法控制究竟使用哪种编码方式了。不过，没有哪种编码方式比其他方式是特别难以读写的。举一
字符。
数量的字符。另一种方式是先写入字符数据后跟一个不可能出现在字符串中的定界符，例如空
都用在了ID3标签中，正如你将在下一章里看到的那样。
最后-一个元素，结构的总长度决定了有多少剩余字节可被用来作为字符串数据读取。这两种方式
件中的特定元素可能总是一个特定长度的字符串，或者一个字符串可能是一个变长数据类型中的
三种技术通常用在二进制文件格式中。
CHAR-CODE将可以直接用来转换这三种编码方式中的任何一种。?
ISO-8859-1则是ASCII的超集，如果你正在使用一个支持Unicode的Lisp平台，那么CODE-CHAR和
用ASCII、ISO-8859-1或Unicode作为其原生的字符编码。由于Unicode是ISO-8859-1的超集，而
符被编码进给定二进制文件格式中的每一个字符。不过，几乎所有的现代CommonLisp实现都使
准并未指定一个实现必须使用的字符编码方式，因此并不保证你可以表示有可能作为一个Lisp字
接受一个数值代码并返回一个字符，而CHAR-CODE则接受一个字符并返回其数值的代码。语言标
用四个字节来表示的字符构成的文本，如果用直接的双字节编码方式来编码的话，反而会更紧凑。
由ASCII字符构成的文本与ASCⅡI编码的结果是相同的。另一方面，对于几乎完全由UTF-8中需要
来编码0到127之间的值，同时使用至多四个八位元来编码最多1114111个不同的值。?
多时候更加紧凑。例如，UTF-8是一种设计用于Unicode字符代码的编码方式，它使用单个八位元
成big-endian还是litle-endian格式的。
编码方式比单字节编码方式更复杂的唯一原因就是你可能还需要知道那些16位的值究竟是编码
当直接的——每一个数值刚好编码成单个字节。
个字节序列的。对于那些使用八位或者更少位的编码，例如ASCII和ISO-8859-1，编码方式是相
字符上。另一方面，字符编码定义了代码点在诸如文件这种基于字节的媒体中是如何被表示成一
最简单的方式是不编码，而是让它成为字符串在更大的结构中某个位置上的隐含值：一个文
相对直接的是纯粹的双字节编码方式，例如UCS-2，它在16位值和字符之间做映射。双字节
272
① UTF-8最初被设计用来表示31位的字符代码，并在每个代码点上使用至多六个字节。不过，Unicode代码点的最大
不同的表示法各自具有不同的优点和缺点，但当你已经在处理指定的二进制格式时，你就无
另外两种技术可用来在无需依赖上下文的情况下编码变长的字符串。一种方式是先编码字
除了指定字符编码方式以外，一个字符串的编码工作还必须指定如何编码字符串的长度。有
由于在Unicode字符集中0到127的代码点映射到与ASCII相同的字符上，一段UTF-8编码的只
变长的编码方式对于不同的数值使用不同数量的八位元，这会使其更加复杂但却令它们在许
个含有任意Unicode字符串的文件，那么你总是可以在内存中将这些字符串表示成整数代码点的向量。它们不会
值是#x10ffff，因此一个UTF-8编码的Unicode字符在每个代码点上只需至多四个字节就够了。
成为Lisp字符串，因为你无法使用字符串函数来管理或比较它们，但你可以像对任意向量那样对它们做任何事情。
第24章实践：解析二进制文件
www.TopSage.com
---
## Page 290
ID3标签。
个帧都有其自己的内部结构。在帧之后是填满头部所指定的标签长度所需的数量相当的空字节。
四个以特定于ID3规范的编码方式编码整个标签长度的字节。紧接着头部的是一个帧的列表，每
“ID3"）的头部，两个用来指定规范的主版本和修订号的单字节无符号整数，八位的布尔旗标以及
类型，要么是另一个复合结构，或者可能是这些值的一个集合。
复合的磁盘结构通常是以一种接近于编程语言定义内存中数据结构的方式来定义的。通常，一个
24.4
小事一桩。
这将是一个相当直接的命题。事实上正如它们所说的，编写函数来读写一个特定的编码根本就是
出现在一个文件中的字节并将其映射到Lisp数据类型。如果一个二进制格式是良好定义的，那么
字符内容后面写入一个空终止符即可。
的值返回。
是S。所有写入流的字符都被收集到一个字符串中，并随后作为WITH-OUTPUT-TO-STRING形式
下构造字符串的简单方式。它创建了一个STRING-STREAM并将其绑定到特定的变量名上，这里
其中的WITH-OUTPUT-TO-STRING宏是我在第14章里提到过的，这是一种在你不知道长度的情况
个例子，下面是一个用来读取空字符结尾的ASCII字符串的函数，假设你的Lisp实现使用了ASCII，
如果你以面向对象的眼光来看的话，复合结构会和类很像。例如，你可以编写一个类来表示
例如，一个定义在2.2版本规范中的ID3标签包括：一个三字符的ISO-8859-1字符串（始终是
为了写回一个字符串，你只需将字符转换回可以用WRITE-BYTE来写的数值形式，然后再在
二进制格式通常用来表示那些可以轻易映射到内存数据结构上的数据。因此，不难理解那些
现在你可以转而考虑读写更复杂的磁盘结构，以及如何将它们映射到Lisp对象上的问题了。
(defclass id3-tag ()
如同这些示例所显示的，读写二进制文件中基本元素的主要智力挑战是理解究竟该如何解释
(defun write-null-terminated-ascii(string out)
(defconstant+null+(code-char0))
(defun read-null-terminated-ascii (in)
((identifier
(write-byte(char-code +null+)out))
(loop for char across string
复合结构
(with-output-to-string(s)
(major-version :initarg :major-version :accessor major-version)
(loopforchar
do（write-byte（char
until（char=char+null+)do（write-char char s))))
:initarg:identifier
-char（read-bytein))
code char)out))
www.TopSage.com
:accessor identifier)
24.4
---
## Page 291
用于保存旗标的槽有8个位，其中除了前两个以外都是0，其长度是4个字节，每个字节的最重要
范中的伪代码一样紧凑的东西，所以你可以从那里开始。指定一个ID3标签头部的方式如下所示;
就是要切换视角，转而思考这样一个宏的具体调用将会是怎样的。因为目标是可以书写像ID3规
的位上都是0。‘
版本部分由两个字节构成，对于当前版本的规范来说，其中第一个字节的值为2，第二个字节是0。
24.5
函数。听起来这正是宏的任务。