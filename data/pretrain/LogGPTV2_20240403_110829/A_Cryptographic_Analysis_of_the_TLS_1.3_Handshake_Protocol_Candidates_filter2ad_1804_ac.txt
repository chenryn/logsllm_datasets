AMS ← HKDF.Extract(0, SS)
FS ← HKDF.Expand(AMS, rskrc)
H3 ← H(CHk···kSP∗)
{ServerFinished}:
SF ← HKDF.Expand(FS, label2kH3)
Verify(pkS, SkH2, SP)
check SF = HKDF.Expand(FS, label2kH3)
{ClientCertificate∗}
{ClientCertificateVerify∗}
{ClientFinished}:
CF ← HKDF.Expand(FS, label3kH5)
H5 ← H(CHk . . .kCCV∗)
check CF = HKDF.Expand(FS, label3kH5)
MS ← HKDF.Extract(AMS, ES)
tkapp ← HKDF.Expand(MS, label1kH5)
RMS ← HKDF.Expand(MS, label4kH5)
EMS ← HKDF.Expand(MS, label5kH5)
stage 2
stage 3
stage 4
record layer (application data), using AEAD with key tkapp
ES
0
Ext
0
SS
Ext
H1
Exp
H5
Exp
H5
Exp
tkhs
tkapp
EMS
(
r
e
s
u
m
p
t
i
o
n
)
HMS
AMS
Ext
MS
rskrc
H5
Exp
Exp
FS
RMS
Figure 2: The handshake protocol in TLS 1.3 draft-dh (left) and its key schedule (right). Hash value and message com-
putations not stated explicitly are performed identically to TLS 1.3 draft-05 (Figure 1). For unauthenticated handshakes,
the ServerCertificate and ServerParameters messages are omitted and key derivation proceeds with SS set to ES. In the
key schedule, Ext and Exp are short for HKDF.Extract resp. HKDF.Expand. Dotted-line input to Ext is the (extractor) salt,
dotted-line input to Exp is the (context) information input; label inputs are omitted.
8. EMS ← HKDF.Expand(MS, label6kH)
3 Comments on the TLS 1.3 Design
Our analysis provides several insights into the TLS 1.3 drafts, for both the basic cryptographic choices, as
well as for the yet to be fully speciﬁed 0-RTT versions.
3.1 Basic Handshake Protocols
Soundness of key separation. Earlier versions of TLS used in the same session key to encrypt the
application data as well as the Finished messages at the end of the handshake. This made it impos-
sible to show that the TLS session key satisﬁed standard Bellare–Rogaway-style key indistinguishability
security [BR94]. We conﬁrm that the change in keys for encryption of handshake messages allows both
TLS 1.3 drafts to achieve standard key indistinguishability security.
9
Client
ClientHello: rc ←$ {0, 1}256, session_id ∈ {0, 1}256
Server
ServerHello: rs ←$ {0, 1}256
H ← H(CH||SH)
HMS ← PRF(RMS, label1kH)
tkhs ← PRF(HMS, label2krskrc)
stage 1
{ServerFinished}:
SF ← PRF(HMS, label3kH)
check SF = PRF(HMS, label3kH)
{ClientFinished}:
CF ← PRF(HMS, label4kH)
check CF = PRF(HMS, label4kH)
stage 2
record layer (application data), using AEAD with key tkapp
MS ← PRF(HMS, label5kH)
tkapp ← PRF(MS, label6krskrc)
RMS
H
PRF
HMS
H
PRF
MS
rskrc
PRF
rskrc
PRF
tkhs
tkapp
Figure 3: Session resumption in TLS 1.3 draft-05 using the resumption master secret RMS as a pre-shared key (left) and its
key schedule (right). In the key schedule, dotted-line input to PRF is the input value (omitting the label as additional input).
Key independence. Both TLS 1.3 drafts achieve key independence in the multi-stage security setting,
which heavily strengthens their overall security. (Recall key independence is the property that one can
reveal a session key without endangering the security of later-stage keys.) Beyond making it amenable to
generic composition, key independence safeguards the usage of derived keys against inter-protocol eﬀects
of security breakdowns.
draft-dh takes a slightly more composable approach to keying material exporting than draft-05. In
draft-dh, an exporter master secret EMS is derived from the master secret and then applications get
exported keying material as PRF(EMS, label).
In draft-05, applications get exported keying material
directly as PRF(MS, label). Key independence in the draft-dh approach allows us to treat derivation of
exported keying material as a separate symmetric protocol, whereas in draft-05 each exported key must
be considered in the main analysis, so we argue the draft-dh approach of a separate exporter master secret
is preferable.
Signing the session hash.
In both TLS 1.3 drafts, authenticating parties (the server, and sometimes
the client) sign (the hash of) all handshake messages up to when the signature is issued. This is diﬀerent
from TLS 1.2 and earlier, where the server’s signature is only over the client and server random nonces and
the server’s ephemeral public key. The server signing the transcript facilitates our proofs of the protocol’s
authentication properties.
Encryption of handshake messages. Both TLS 1.3 drafts encrypt the second part of the handshake
using the initial handshake traﬃc key tkhs, aiming to provide some form of privacy (against passive
adversaries) for these messages, in particular for the server and client certiﬁcates. Our analysis shows that
the handshake traﬃc key does indeed have security against passive adversaries and hence increases the
handshake’s privacy. The secrecy of the ﬁnal session keys however does not rely on the handshake being
encrypted and would remain secure even if was done in clear. Our analysis considers the encrypted case,
showing that this encryption does not negatively aﬀect the security goals.
Finished messages. The Finished messages in both drafts are computed by applying the PRF (or
HKDF in draft-dh) to the (hash of the) handshake transcript.
Interestingly, according to our proof
the Finished messages do not contribute to the session key secrecy in the full handshake or the session
10
resumption handshake in the sense that the key exchange would be secure without these messages. This is
mainly because the signatures already authenticate the transcripts. This contrasts with the case of RSA
key transport in the TLS 1.2 full handshake: the analyses of both Krawczyk et al. [KPW13] and Bhargavan
et al. [BFK+14] note potential weaknesses or require stronger security assumptions if Finished messages
are omitted. From an engineering perspective, the Finished messages can still be interpreted as providing
some form of (explicit) session key conﬁrmation, but is not cryptographically required to achieve key
indistinguishability. In session resumption, the Finished messages give the only explicit authentication.
Session hash in key derivation. Both TLS 1.3 drafts include a hash of all messages exchanged so far
in the derivation of all session keys and, in draft-05, also in deriving the master secrets. This session
hash was introduced in response to the triple handshake attack [BDF+14] on TLS 1.2 and earlier, with
the goal of ensuring that sessions with diﬀerent session identiﬁers have diﬀerent master secrets. In our
security analysis of both full handshakes, the online signatures computed over the handshake messages
already suﬃce to bind the exchanged messages to the authenticated parties and established keys, so
including the session hash in the key derivations does not contribute to the session keys’ secrecy. If keys
are meant to be used as a channel identiﬁer or for channel binding (with the purpose of leveraging the
sesssion protection and authentication properties established by TLS in an application-layer protocol),
including the session hash is appropriate. While the standardized tls-unique [AWZ10] and proposed
tls-unique-prf [Jos15] TLS channel binding methods do not use keys directly for binding, the low
cost of including the session hash seems worth it in case an application developer decides to use keying
material directly for binding. Interestingly, in the draft-dh version, computing the master secret requires
a semi-static secret and ephemerally-generated secret, but does not include the session hash. In draft-dh
session resumption, there is no ephemeral shared secret and the master secret is computed as a series of
HKDF.Extract computations over a 0-string using the resumption secret as the key. All sessions sharing
the same resumption master secret then compute the same master secret. However, since key derivation
still uses the session hash as context, keys are unique assuming uniqueness of protocol messages (assured,
e.g., via unique nonces).
Upstream hashing for signatures.
In signing the transcript for authentication, both draft-05 and
draft-dh have the signer input the hash of the current transcript to the signing algorithm; if the signature
algorithm is a hash-then-sign algorithm, it will then perform an additional hash. From a cryptographic
point of view, it would be preferable to insert the full (unhashed) transcript and let the signing algorithm
opaquely take care of processing this message. For engineering purposes, however, it may be amenable
to hash the transcript iteratively, only storing the intermediate values instead of entire transcript. Fur-
thermore, since the hashed transcript is likewise given to the key derivation function, storing the hash
value may be also advantageous in this regard. In our security proof, this upstream hashing leads to an
additional assumption about the collision resistance of the hash function (which would otherwise be taken
care of by the signature scheme).
3.2 0-RTT Handshake Mode
One of the main design goals for TLS 1.3 [Int] is to reduce handshake latency and in particular include
a zero round-trip time (0-RTT) mode for handshakes with a previously seen server. While the mainline
draft in version draft-05 [Res15a] does not contain a speciﬁcation for a 0-RTT handshake mode (yet), the
forked draft-dh draft [Res15c] provisions for a 0-RTT (“early application”) traﬃc key in its handshake
key schedule. However, also the draft-dh version (at the time of writing) lacks a detailed speciﬁcation
how 0-RTT data transfer will be implemented.
11
Most importantly, there is still an ongoing discussion on the IETF TLS working group mailing list6
about the handling (and potential prevention) of replay attacks, in which a man-in-the-middle attacker
replays a client’s ClientHello and ClientKeyShare messages in order to make the server derive the same
(0-RTT) key twice. Replay attacks on 0-RTT keys (to which only the client contributes) can, in principle,
only be prevented by requiring the server to keep a register of all client key shares (e.g., the nonces) seen
and reject any connections reusing a key share.
This approach is most prominently employed in Google’s QUIC protocol [Ros13, LC13], using time and
server-speciﬁc nonce preﬁxes to render the nonce register manageable in storage. The current discussion
on 0-RTT replay protection in TLS 1.3 however tends to refraining from the requirement of a globally
and temporally consistent server state in order to make replays always detectable. This would then, in
turn, require to give up the anti-replay protection for 0-RTT data sent over TLS, an option for which the
consequences with respect to implementation and application interface are still being discussed.
Missing suﬃcient details on design and implementation of the envisioned 0-RTT key exchange mode
and data transfer in TLS 1.3, we have to omit an analysis of this protocol aspect in this work. Nevertheless,
we remark that allowing replay in deriving 0-RTT keys inherently conﬂicts with the classical notions of
session partnering established in key exchange models. Exploring the security provided for 0-RTT keys
when replay is explicitly possible in a key exchange protocol as well as analyzing the yet to be deﬁned
approach in TLS 1.3 hence remains as a task for future work.
Another point of consideration for 0-RTT would be the possibility of small-subgroup-style attacks on
the semi-static Diﬃe–Hellman exponent s. By sending many diﬀerent small-subgroup generators X to be
used by the server to compute a shared 0-RTT, an attacker could observe handshake messages derived from
X s. After observing a large enough number of samples, the attacker could compute s mod |hXi| for many
diﬀerent |hXi|, and then use the Chinese Remainder Theorem to hopefully recover s. For non–0-RTT
draft-dh handshakes, the semi-static exponent s plays no role in our security analysis. However, this is
expected to change for 0-RTT handshakes, where the semi-static secret will become relevant for security.
4 Multi-Stage Key Exchange Model
In this section we recap and extend the model for multi-stage key exchange by Fischlin and Günther [FG14]
based on the Bellare–Rogaway-style model of Brzuska et al. [BFWW11, Brz13].
4.1 Outline of the Model for Multi-Stage Key Exchange
Our model for multi-stage key exchange protocols follows the Bellare–Rogaway paradigm [BR94]. We
assume that an adversary controls the network which connects multiple sessions of honest parties, enabling
the adversary to modify, inject, or drop transmissions of these honest parties. This is captured via a
NewSession (for starting a new session of an honest party) and a Send query (delivering some message to
it). Since the goal is to ultimately provide secrecy of the various session keys, the adversary may pose
Test queries for some stage to either receive the corresponding session key of that stage, or to get an
independent random key instead. Since a session key may be used to derive the next one, we need to be
careful when such a Test query is admissible.