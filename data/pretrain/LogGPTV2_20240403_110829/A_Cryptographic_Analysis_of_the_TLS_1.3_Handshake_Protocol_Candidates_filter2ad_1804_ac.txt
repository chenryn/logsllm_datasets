### 优化后的文本

#### 1. 密钥导出和验证
- **密钥导出：**
  - \( \text{AMS} \leftarrow \text{HKDF.Extract}(0, \text{SS}) \)
  - \( \text{FS} \leftarrow \text{HKDF.Expand}(\text{AMS}, \text{rskrc}) \)
  - \( \text{H3} \leftarrow H(\text{CHk} \cdots \text{kSP}^*) \)

- **服务器完成消息：**
  - \( \text{SF} \leftarrow \text{HKDF.Expand}(\text{FS}, \text{label2kH3}) \)
  - 验证 \( \text{pkS}, \text{SkH2}, \text{SP} \)
  - 检查 \( \text{SF} = \text{HKDF.Expand}(\text{FS}, \text{label2kH3}) \)

- **客户端证书和验证：**
  - \( \text{CF} \leftarrow \text{HKDF.Expand}(\text{FS}, \text{label3kH5}) \)
  - \( \text{H5} \leftarrow H(\text{CHk} \cdots \text{kCCV}^*) \)
  - 检查 \( \text{CF} = \text{HKDF.Expand}(\text{FS}, \text{label3kH5}) \)

- **其他密钥导出：**
  - \( \text{MS} \leftarrow \text{HKDF.Extract}(\text{AMS}, \text{ES}) \)
  - \( \text{tkapp} \leftarrow \text{HKDF.Expand}(\text{MS}, \text{label1kH5}) \)
  - \( \text{RMS} \leftarrow \text{HKDF.Expand}(\text{MS}, \text{label4kH5}) \)
  - \( \text{EMS} \leftarrow \text{HKDF.Expand}(\text{MS}, \text{label5kH5}) \)

- **阶段说明：**
  - **阶段 2**
  - **阶段 3**
  - **阶段 4**

- **记录层（应用数据）：**
  - 使用 AEAD 加密，密钥为 \( \text{tkapp} \)

- **图示：**
  - 图 2 展示了 TLS 1.3 草案中的握手协议及其密钥调度。哈希值和消息计算未明确说明的部分与 TLS 1.3 draft-05 相同（见图 1）。对于未经认证的握手，ServerCertificate 和 ServerParameters 消息被省略，并且密钥导出使用 SS 设置为 ES。

#### 2. TLS 1.3 设计分析
- **基本握手协议：**
  - **密钥分离性：** 
    - 早期版本的 TLS 在同一会话中使用相同的密钥来加密应用数据和握手结束时的 Finished 消息，这使得无法证明 TLS 会话密钥满足标准的 Bellare–Rogaway 式密钥不可区分性安全 [BR94]。我们确认，改变用于加密握手消息的密钥使两个 TLS 1.3 草案都能实现标准的密钥不可区分性安全。
  
  - **密钥独立性：**
    - 两个 TLS 1.3 草案在多阶段安全设置中实现了密钥独立性，从而大大增强了其整体安全性。密钥独立性的定义是，即使泄露了一个会话密钥，也不会危及后续阶段密钥的安全性。除了使其适用于通用组合外，密钥独立性还保护了派生密钥免受协议间安全故障的影响。

  - **导出主密钥：**
    - 在 draft-dh 中，从主密钥派生出一个导出主密钥 EMS，应用程序通过 PRF(EMS, label) 获取导出的密钥材料。而在 draft-05 中，应用程序直接通过 PRF(MS, label) 获取导出的密钥材料。draft-dh 的方法允许我们将导出密钥材料的派生视为一个独立的对称协议，而 draft-05 则需要在主要分析中考虑每个导出的密钥。因此，我们认为 draft-dh 方法更为可取。

  - **签名会话哈希：**
    - 在两个 TLS 1.3 草案中，认证方（服务器，有时也包括客户端）会对所有握手消息的哈希进行签名。这与 TLS 1.2 及之前的版本不同，后者服务器的签名仅包含客户端和服务器随机数以及服务器的临时公钥。服务器对整个握手消息的签名有助于我们证明协议的认证属性。

  - **握手消息加密：**
    - 两个 TLS 1.3 草案都使用初始握手流量密钥 tkhs 对握手的第二部分进行加密，以提供一定程度的隐私（针对被动攻击者），特别是对于服务器和客户端证书。我们的分析表明，握手流量密钥确实对被动攻击者具有安全性，从而提高了握手的隐私性。最终会话密钥的安全性并不依赖于握手消息的加密，即使明文传输也不会影响其安全性。我们的分析考虑了加密的情况，表明这种加密不会负面影响安全目标。

  - **Finished 消息：**
    - 两个草案中的 Finished 消息是通过对握手消息的哈希应用 PRF（或 HKDF 在 draft-dh 中）计算得出的。根据我们的证明，这些 Finished 消息在完整握手或会话恢复握手中不贡献于会话密钥的秘密性，因为签名已经认证了消息。这与 TLS 1.2 全握手中的 RSA 密钥传输情况形成对比：Krawczyk 等人 [KPW13] 和 Bhargavan 等人 [BFK+14] 的分析指出，如果没有 Finished 消息，可能会存在潜在弱点或需要更强的安全假设。从工程角度来看，Finished 消息可以被视为提供了某种形式的显式会话密钥确认，但并不是为了实现密钥不可区分性所必需的。在会话恢复中，Finished 消息提供了唯一的显式认证。

  - **会话哈希在密钥导出中的作用：**
    - 两个 TLS 1.3 草案在所有会话密钥的导出过程中都包含了迄今为止交换的所有消息的哈希，在 draft-05 中还包括主密钥的导出。这个会话哈希是在响应 TLS 1.2 及之前的三重握手攻击 [BDF+14] 时引入的，目的是确保具有不同会话标识符的会话具有不同的主密钥。在我们的全握手安全分析中，在线签名已经足以将交换的消息绑定到认证方和已建立的密钥，因此在密钥导出中包含会话哈希并不会增加会话密钥的秘密性。如果密钥打算用作通道标识符或通道绑定（目的是利用 TLS 建立的会话保护和认证属性在应用层协议中），则包括会话哈希是合适的。尽管标准化的 tls-unique [AWZ10] 和提议的 tls-unique-prf [Jos15] TLS 通道绑定方法不直接使用密钥进行绑定，但包含会话哈希的成本较低，值得在应用程序开发者决定直接使用密钥材料进行绑定时采用。有趣的是，在 draft-dh 版本中，计算主密钥需要一个半静态秘密和临时生成的秘密，但不包括会话哈希。在 draft-dh 会话恢复中，没有临时共享秘密，主密钥是通过一系列 HKDF.Extract 计算从 0 字符串导出的，使用恢复秘密作为密钥。所有共享相同恢复主密钥的会话将计算出相同的主密钥。然而，由于密钥导出仍然使用会话哈希作为上下文，因此假设协议消息唯一（例如，通过唯一随机数保证），密钥也是唯一的。

  - **上游哈希用于签名：**
    - 在认证签名时，draft-05 和 draft-dh 都要求签名者将当前会话消息的哈希输入到签名算法中；如果签名算法是先哈希后签名的算法，则会执行额外的哈希。从密码学角度来看，最好插入完整的（未哈希的）会话消息并让签名算法透明地处理该消息。然而，从工程角度来看，迭代哈希会话消息并只存储中间值可能更方便。此外，由于哈希后的会话消息同样传递给密钥导出函数，存储哈希值也可能在这方面有利。在我们的安全证明中，这种上游哈希导致了对哈希函数抗碰撞性的额外假设（否则由签名方案处理）。

- **0-RTT 握手模式：**
  - **设计目标：**
    - TLS 1.3 的主要设计目标之一是减少握手延迟，特别是在与之前见过的服务器进行握手时包括零往返时间（0-RTT）模式。虽然 version draft-05 [Res15a] 的主线草案尚未包含 0-RTT 握手模式的规范，但 forked draft-dh 草案 [Res15c] 在其握手密钥调度中规定了 0-RTT（“早期应用”）流量密钥。然而，截至撰写本文时，draft-dh 版本也缺乏关于如何实现 0-RTT 数据传输的详细规范。

  - **重放攻击：**
    - 最重要的是，IETF TLS 工作组邮件列表上仍在讨论如何处理（并可能预防）重放攻击。在这种攻击中，中间人攻击者重放客户端的 ClientHello 和 ClientKeyShare 消息，使服务器两次导出相同的 0-RTT 密钥。原则上，只有通过要求服务器维护所有客户端密钥共享（例如，随机数）的注册表并拒绝任何重复使用密钥共享的连接，才能防止对 0-RTT 密钥（仅由客户端贡献）的重放攻击。这种方法最著名的是 Google 的 QUIC 协议 [Ros13, LC13]，它使用时间和服务器特定的随机数前缀来使随机数注册表在存储方面可管理。然而，目前关于 TLS 1.3 中 0-RTT 重放保护的讨论倾向于避免要求全局和时间一致的服务器状态，以便始终检测到重放。这反过来又要求放弃对通过 TLS 发送的 0-RTT 数据的抗重放保护，这种选择对实现和应用程序接口的影响仍在讨论中。

  - **缺失的细节：**
    - 由于缺少关于设想的 0-RTT 密钥交换模式和数据传输的设计和实现的足够细节，我们在本工作中无法对其进行分析。尽管如此，我们注意到允许在导出 0-RTT 密钥时重放本质上与密钥交换模型中建立的经典会话伙伴关系概念相冲突。探索当重放在密钥交换协议中明确可能发生时 0-RTT 密钥提供的安全性，以及分析 TLS 1.3 中尚未定义的方法仍然是未来工作的任务。

  - **小子群攻击：**
    - 另一个需要考虑的问题是针对半静态 Diffie-Hellman 指数 s 的小子群攻击的可能性。通过发送许多不同的小子群生成器 X 供服务器计算共享 0-RTT，攻击者可以观察到从 X^s 导出的握手消息。在观察到足够多的样本后，攻击者可以计算 s mod |<X>| 对于许多不同的 |<X>|，然后使用中国剩余定理希望能恢复 s。对于非 0-RTT 的 draft-dh 握手，半静态指数 s 在我们的安全分析中不起作用。然而，对于 0-RTT 握手，半静态秘密将成为安全的关键因素。

#### 3. 多阶段密钥交换模型
- **概述：**
  - 我们的多阶段密钥交换协议模型遵循 Bellare–Rogaway 范式 [BR94]。我们假设对手控制连接多个诚实会话的网络，能够修改、注入或丢弃这些诚实会话的传输。这通过 NewSession（启动一个新的诚实会话）和 Send 查询（向其传递一些消息）来捕获。由于最终目标是提供各种会话密钥的秘密性，对手可以对某个阶段提出 Test 查询，以接收该阶段对应的会话密钥，或者获取一个独立的随机密钥。由于会话密钥可能用于派生下一个密钥，我们需要谨慎判断何时允许此类 Test 查询。

希望这些优化能帮助您更好地理解文本内容。如果有进一步的需求或需要更详细的解释，请告诉我！