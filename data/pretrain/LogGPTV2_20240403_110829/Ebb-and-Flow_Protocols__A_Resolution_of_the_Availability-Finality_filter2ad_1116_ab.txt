tolerate (n−f )/2 adversaries in a partially synchronous environment, for any
f between n/3 and n/2. Thus, there is a tradeoff between the two guarantees.
The snap-and-chat protocol achieves (n/2, n/3), simultaneously optimal. No
tradeoff is necessary.
2) (P2 - Dynamic Availability): If GST = 0, the available
ledger LOGda is guaranteed to be safe and live at all
times, provided that at all times fewer than 50% of the
awake nodes are adversarial.
Note that the assumptions on the adversary are different
for the security of the two ledgers, in line with the spirit of
a ﬂexible protocol [20]. Together, P1 and P2 say that the
ﬁnalized ledger LOGﬁn is safe under network partition, i.e.,
before max{GST, GAT}, and afterwards catches up with the
available ledger LOGda, which is always live and safe provided
that the majority of awake nodes is honest.
If GAT = 0, then the environment is the classical partially
synchronous network, and the ledger LOGﬁn has the opti-
mal resilience achievable in that environment. On the other
hand, if GST = 0 and GAT = ∞, then the environment
is a synchronous network with dynamic participation, and
the ledger LOGda has the optimal resilience achievable in
that environment. Thus, our construction achieves consistency
between the two ledgers without sacriﬁcing the best possible
security guarantees of the individual ledgers. In that sense, our
construction achieves the ebb-and-ﬂow property in an optimal
manner.
E. Flexible BFT Revisited
P1 and P2 together with preﬁx consistency provide ﬂexible
consensus. Our mathematical formulation of the ebb-and-ﬂow
property can be viewed as going beyond that of Flexible
BFT [20] in two ways. First, [20] focuses on synchronicity
assumptions and we bring dynamic participation as a new
client belief into the story. Second, the formulation in [20]
requires consistency between ledgers of two clients only when
their assumptions are both correct, but we require preﬁx
consistency between the ledgers in all circumstances. In that
sense, the ﬂexibility our formulation offers is closer in nature
to the ﬂexibility offered by Nakamoto’s longest chain protocol.
Preﬁx consistency under all circumstances is crucial, e.g., for
cryptocurrencies, where eventually all clients, no matter their
beliefs, should converge on a unique ledger, a single version
of history to settle disputes regarding ‘who owns what’.
But even for the formulation considered in [20], our con-
struction provides a different solution and offers stronger
security guarantees than the white-box construction in [20].
More speciﬁcally, the ﬂexible BFT protocol in [20] can si-
multaneously support clients who can tolerate n/2 adversaries
in a synchronous environment and clients who can tolerate a
fraction of n/4 adversaries in a partially synchronous environ-
ment. Since a synchronous environment is a special case of
the dynamic participation environment (by setting GAT = 0),
our construction improves the security guarantees to simulta-
neously support clients who can tolerate n/2 adversaries in
a synchronous environment and clients who can tolerate n/3
adversaries in a partially synchronous environment. Consistent
with the optimality of our construction,
these guarantees
cannot be improved further (see Figure 3).
It
is also insightful
to compare our results with those
of [27], which designed a randomized Byzantine agreement
protocol secure under both a synchronous and an asynchronous
environment. The dashed line in Figure 3 shows the tradeoff
between the resiliences the protocol can support in the two
environments, and this tradeoff is proved to be optimal. Note
that this protocol is not a ﬂexible protocol, since a single
value has to be agreed upon regardless of which of the two
environments one is in. Thus, the gap between the resilience
achieved by the snap-and-chat protocol and the protocol in
[27] can be interpreted as the value of ﬂexibility. Interestingly,
the protocol in [27] is also constructed by the composition of
two sub-protocols, but in contrast to the construction of snap-
and-chat protocols, the two sub-protocols are not off-the-shelf,
but are constructed tailored to the problem at hand.
F. Outline
The remainder of this manuscript is structured as follows.
First, we present a balancing attack on Gasper in Section II,
demonstrating that Gasper is not secure. Section III formulates
the ebb-and-ﬂow security property, describes the construction
of snap-and-chat protocols in detail and proves that they satisfy
the ebb-and-ﬂow security property with optimal resilience.
We show the results of simulation experiments providing an
insight into the behavior of snap-and-chat protocols in Sec-
tion IV. In Section V-A, we compare the design of snap-and-
chat protocols and ﬁnality gadgets. We conclude the paper with
how to transfer our results to the PoW setting in Section V-B
and an overview of features beyond security provided out-of-
the-box by snap-and-chat protocols in Section V-C.
II. A BALANCING ATTACK ON GASPER
Gasper [21] is the current proposal for Ethereum 2.0’s
beacon chain. In the following, we exhibit a liveness attack
against Gasper in the synchronous network model.3 What is
more, the attack leads to loss of safety for the underlying
dynamically available ledger. Thus, Gasper is not secure in the
3Source code of a simulation of the attack (discussed in Appendix A-C)
can be found at: https://github.com/tse-group/gasper-attack.
4
synchronous network model and does not provide a resolution
to the availability-ﬁnality dilemma.
Our attack uses that under synchrony, network delay is
adversarial (rather than merely stochastic, as was analyzed
in [21]). Considering, e.g., state-sponsored adversaries or ma-
licious network providers, at least some degree of adversarial
network delay cannot be ruled out. Furthermore, the synchrony
model with adversarial delay is a well-established baseline
model for which many secure protocols are known.
Gasper is a vote-based PoS protocol which combines Casper
FFG [22] with a committee-based blockchain block proposal
mechanism where the fork (i.e., the tip of the chain to propose
new blocks on or vote for) is chosen using the ‘greedy heaviest
observed sub-tree’ (GHOST) rule under the ‘latest message
driven’ (LMD) paradigm, i.e., taking into consideration only
the most recent vote per validator. A Gasper vote consists
of two parts, a GHOST vote and a Casper FFG vote. While
details of Gasper preclude the vanilla bouncing attack [28]–
[30] on the Casper FFG layer, Gasper is vulnerable to a similar
balancing attack on the GHOST layer.
Recall that Gasper proceeds in epochs which are further
subdivided into C slots each. For simplicity, let C divide n so
that every slot has a committee of size n/C. For each epoch,
a random permutation of all n validators assigns validators
to slots’ committees and designates a proposer per slot. Per
slot, the proposer produces a new block extending the tip
determined by the fork choice rule HLMD(G) executed in
local view G (see [21, Algorithm 4.2]). Then, each validator
of the slot’s committee decides what block to vote for using
HLMD(G) in local view G.
For the Casper FFG layer, a block can only become ﬁnalized
if two-thirds of validators vote for it. The attacker aims to keep
honest validators split between two options (‘left’ and ‘right’
chain, see Figure 4) indeﬁnitely, so that neither option ever
gets two-thirds votes and thus no block ever gets ﬁnalized.
Key technique to maintain this split is that some adversarial
validators (‘swayers’ in Figure 4) withhold their votes and
release them only at speciﬁc times and to speciﬁc subsets of
honest nodes in order to inﬂuence the fork choice of honest
nodes and thus steer which honest nodes vote ‘left’/‘right’.
The basic idea of the attack is as follows (for a detailed
description, see Appendix A and [31]). The adversary waits
for an opportune epoch to kick-start the attack. An epoch
is opportune if the proposer in the ﬁrst slot is adversarial,
and in every slot of the epoch there are enough (six sufﬁce;
explained in detail in Appendix A-B) adversarial validators to
fulﬁll certain tasks in the attack (see a(cid:13)– d(cid:13) in Figure 4). In
particular in the regime of many validators (n → ∞), the
probability that a particular epoch is opportune is roughly
f /n (see Appendix A-C). Note that for n large, any positive
fraction f /n of adversarial nodes sufﬁces to mount the attack,
with the ﬁrst opportune epoch occurring after n/f epochs on
average. For ease of exposition, let epoch 0 be opportune.
The adversarial proposer of slot 0 equivocates and produces
two conﬂicting blocks (‘left’ and ‘right’) which it reveals to
two suitably chosen equal-sized subsets of the committee. One
Slot
0
1
2
...
C − 2
C − 1
C
C + 1
C + 2
...
2C − 2
2C − 1
2C
2C + 1
2C + 2
...
3C − 2
3C − 1
0
h
c
o
p
E
1
h
c
o
p
E
2
h
c
o
p
E
Genesis
0(cid:48)
0
4
6
13
5
7
8
10
17
a(cid:13) b(cid:13) c(cid:13)
d(cid:13) vote
‘left’
vote
‘right’
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
Fig. 4. Two chains, ‘left’ ( ... ) and ‘right’ ( ... ), are built during the attack.
Honest and adversarial validators in a slot’s committee are depicted by and
, respectively. a(cid:13) In slot 0 the proposer needs to be adversarial ( ). b(cid:13) In
every slot i of epoch 0 the adversary recruits two ‘swayers’ whose votes (
votes ‘left’,
votes ‘right’) in epoch 0 are withheld and released during
slot C +i in epoch 1 to sway (
) honest validators. (For comprehensibility,
most votes and sway inﬂuences are omitted.) c(cid:13) Similarly, in every slot i of
epoch 0 the adversary recruits two ‘swayers’ whose votes in slot i are withheld
and released during slot i + 1 to sway honest validators. d(cid:13) If in some slot of
epoch 0 the number of honest validators is odd, then the adversary recruits a
‘ﬁller’ ( ) which behaves like an honest validator from thereon. Thus, during
epoch 0 every committee has an even number of honestly voting validators.
subset votes ‘left’, the other subset votes ‘right’ – a tie. The
adversary selectively releases withheld votes from slot 0 to
split validators of slot 1 into two equal-sized groups, one which
sees ‘left’ as leading and votes for it, and one which sees
‘right’ as leading and votes for it – still a tie. The adversary
continues this strategy to maintain the tie throughout epoch 0.
During epoch 1, the adversary selectively releases additional
withheld votes from epoch 0 to keep splitting validators into
two groups, one of which sees ‘left’ as leading and votes ‘left’,
the other sees ‘right’ as leading and votes ‘right’. Note that
these groups now do not have to be equal in size. It sufﬁces
for the adversary to release withheld votes selectively so as to
reafﬁrm honest validators in their illusion that whatever chain
they previously voted for happens to still be leading, so that
they renew their vote. Due to the LMD paradigm of Gasper’s
fork choice rule, only the most recent vote per validator counts
and thus the effective vote tally remains unchanged. At the end
of epoch 1 there are still two chains with equally many votes
and thus neither gets ﬁnalized.
5
For epoch 2 and beyond the adversary repeats its actions of
epoch 1. Note that the validators whose withheld epoch 0 votes
the adversary used to sway honest validators in epoch 1 have
themselves not voted in epoch 1 yet. Thus, during epoch 2 the
adversary selectively releases votes from epoch 1 to maintain
the tie between the two chains. This continues indeﬁnitely.
Thus, Gasper is not live in the synchronous model. Fur-
thermore, the block proposal mechanism is rendered unsafe
by the modiﬁed fork choice rule as the chosen fork ﬂip-ﬂops
between ‘left’ and ‘right’. Since Gasper does not satisfy the
desired ebb-and-ﬂow security property, we next introduce a
provably secure family of ebb-and-ﬂow protocols.
III. OPTIMAL EBB-AND-FLOW PROTOCOLS
In this section, we formulate precisely the ebb-and-ﬂow
security property, present the construction of snap-and-chat
protocols, and show that snap-and-chat protocols achieve
the ebb-and-ﬂow property with optimal resilience. For the
construction, we build state machine replication protocols
Πsac (snap-and-chat protocols) by composing a dynamically
available longest-chain protocol [3]–[5], [32] as Πlc with a
partially synchronous BFT protocol [8], [11], [12] as Πbft.
The focus of this paper is on the permissioned setting.
The resulting permissioned protocol can be viewed as a core
around which a full PoS protocol can be built, much like
Sleepy [3] is the permissioned core of the PoS protocol
SnowWhite [4]. To build a full PoS protocol, issues such as
stake grinding [4], [6] have to be considered. Snap-and-chat
protocols can also be used in a hybrid PoS-PoW setting, where
validators run the BFT sub-protocol and miners power the
dynamically available sub-protocol (see Section V-B). These
are topics for future work.
A. Model and Formulation
The execution model of Πsac inherits the cryptographic
assumptions and primitives used in [3], [11], [12]. The cor-
nerstones of the model are:
• There are in total n nodes numbered from 1 thru n.
• Time proceeds in slots. Nodes have synchronized clocks.4
• There is a public-key infrastructure and each node is
equipped with a unique cryptographic identity.
• There is a random oracle, which serves as the source of
randomness in our construction.
• The adversary is a probabilistic poly-time algorithm.
Corruption: Before the protocol execution starts, the adver-
sary gets to corrupt (up to) f nodes, then called adversarial.
Adversarial nodes surrender their internal state to the adversary
and can deviate from the protocol arbitrarily (Byzantine faults)
under the adversary’s control. The remaining (n − f ) nodes
are honest and follow the protocol as speciﬁed.
Networking: Nodes can send each other messages which
arrive with a certain delay controlled by the adversary, subject
to constraints elaborated below.
4Bounded clock offsets can be captured as part of the network delay.
Sleeping: The adversary chooses, for every time slot and
honest node, whether the node is awake or asleep in that slot,
subject to constraints elaborated below. An honest node that
is awake in a slot executes the protocol faithfully in that slot.
An honest node that is asleep in a slot does not execute the
protocol in that slot, and messages that would have arrived in
that slot are queued and delivered in the ﬁrst slot in which the
node is awake again. Adversarial nodes are always awake.
Using the features above, dynamic participation in the
permissioned setting can be modelled, where all nodes’ cryp-
tographic identities are common knowledge but honest nodes
do not know which nodes are awake or asleep at any given
time. Thus, the permissioned nature and dynamic participation
represent two orthogonal aspects of the environment.
As building blocks for the environment adopted for ebb-and-
ﬂow protocols, recall that in a traditional synchronous network,
messages sent by honest nodes arrive within a known ﬁnite
delay bound. In a partially synchronous network [33], initially,
messages can be delayed arbitrarily. After some time, the
network turns synchronous. Thus, partial synchrony models
a network with a period of partition followed by synchrony.
Although in reality, multiple such periods of (a-)synchrony
could alternate, we follow the long-standing practice in the
BFT literature and study only a single such transition.
Now, recall
the informal Theorem of Section I-D. The
theorem provides two sets of security guarantees, labelled
as P1 and P2, for the ﬁnalized and available ledgers. These
guarantees are stated under two sets of assumptions on the
environment Z and the adversary A. The assumptions model
a partially synchronous network and a synchronous network
with dynamic participation, respectively.
(A1(β),Z1) formalizes the model of P1, a partially syn-
chronous network under dynamic participation, with respect
to the fraction β of adversary nodes:
• A1 corrupts f = βn nodes.
• Before a global stabilization time GST, A1 can delay
network messages arbitrarily. After GST, A1 is required
to deliver all messages sent between honest nodes in
at most ∆ slots. GST is chosen by A1, unknown to