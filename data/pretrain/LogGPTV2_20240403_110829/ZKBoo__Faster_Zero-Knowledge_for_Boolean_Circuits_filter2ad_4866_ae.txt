### Optimized Text

#### Comparison with Other Systems

1. **Pinocchio**:
   - The SHA-1 circuit used by Pinocchio is approximately three times larger than the one used in our system.
   - Although it is conceivable that Pinocchio could be optimized using some of the techniques introduced here, we do not believe it could achieve proving times comparable to ZKBoo. This is due to the heavy use of public-key technology (exponentiations in a pairing-friendly group) for each gate in the circuit.

2. **ZKGC [21]**:
   - Direct comparison of implementations was not possible as the source code for [21] is not publicly available.
   - Since the publication of [21], several significant improvements have been proposed but not yet implemented.
   - In Table 2, we provide an accurate estimate of the proof size generated by ZKGC and a lower-bound for its runtime. These estimates are computed using the following methods:
     - **Garbled Circuits (GC)**: We estimate the proof size using the communication complexity of the most efficient garbled circuits, specifically privacy-free garbled circuits [13, 27], which can be instantiated with as little as one ciphertext (128 bits using AES) per AND gate in the circuit.
     - **Oblivious Transfer (OT)**: We use the size and runtime given by the most efficient OT available [6].
   - Given the large input size of SHA-1 (512 bits), OT extension might be beneficial. To make the comparison more favorable towards ZKGC, we only count the runtime of 190 base OTs necessary for active secure OT extensions [1] and do not account for the runtime of the OT extension protocol or the generation/verification of the GC.
   - The resulting estimates show that even when counting only the base OTs, the runtime of ZKGC is already larger than that of ZKBoo for the SHA-1 circuit. However, ZKGC produces shorter proofs.
   - A qualitative drawback of ZKGC is that it cannot be made non-interactive, which is likely to introduce significant slowdowns due to network latency.

#### Conclusions

In this paper, we described ZKBoo, the first attempt to make general-purpose zero-knowledge practical using the "MPC-in-the-head" approach of Ishai et al. [19]. We discussed how to generalize their protocol using (2,3)-function decompositions, provided simple linear decompositions for arithmetic circuits over any ring, and left finding compact decompositions for other interesting functions as future work.

Our experimental results show that for practically relevant circuits (such as SHA-1), our protocol is the fastest in terms of proving time, and the verification time is comparable even with SNARKs technology.

#### Acknowledgements

This project was supported by:
- The Danish National Research Foundation and The National Science Foundation of China (grant 61361136003) for the Sino-Danish Center for the Theory of Interactive Computation.
- The Center for Research in Foundations of Electronic Markets (CFEM).
- The European Union Seventh Framework Programme ([FP7/2007-2013]) under grant agreement number ICT-609611 (PRACTICE).

#### References

[1] ASHAROV, G., LINDELL, Y., SCHNEIDER, T., AND ZOHNER, M. More efficient oblivious transfer extensions with security for malicious adversaries. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Soﬁa, Bulgaria, April 26-30, 2015, Proceedings, Part I (2015), pp. 673–701.

[2] BEN-OR, M., GOLDWASSER, S., AND WIGDERSON, A. Completeness theorems for non-cryptographic fault-tolerant distributed computation (extended abstract). In STOC (1988), pp. 1–10.

[3] BEN-SASSON, E., CHIESA, A., GARMAN, C., GREEN, M., MIERS, I., TROMER, E., AND VIRZA, M. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, SP 2014, Berkeley, CA, USA, May 18-21, 2014 (2014), pp. 459–474.

[4] BEN-SASSON, E., CHIESA, A., TROMER, E., AND VIRZA, M. Succinct non-interactive zero knowledge for a von neumann architecture. In Proceedings of the 23rd USENIX Security Symposium, San Diego, CA, USA, August 20-22, 2014. (2014), pp. 781–796.

[5] BENDLIN, R., DAMGÅRD, I., ORLANDI, C., AND ZAKARIAS, S. Semi-homomorphic encryption and multiparty computation. In Advances in Cryptology - EUROCRYPT 2011 - 30th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Tallinn, Estonia, May 15-19, 2011. Proceedings (2011), K. G. Paterson, Ed., vol. 6632 of Lecture Notes in Computer Science, Springer, pp. 169–188.

[6] CHOU, T., AND ORLANDI, C. The simplest protocol for oblivious transfer. In Progress in Cryptology - LATINCRYPT 2015 - 4th International Conference on Cryptology and Information Security in Latin America, Guadalajara, Mexico, August 23-26, 2015, Proceedings (2015), pp. 40–58.

[7] DAMGAARD, I. On σ-protocols (2010). Lecture on Cryptologic Protocol Theory (Aarhus University, course notes).

[8] DAMGÅRD, I., AND ISHAI, Y. Scalable secure multiparty computation. In Advances in Cryptology-CRYPTO 2006. Springer, 2006, pp. 501–520.

[9] DAMGÅRD, I., ISHAI, Y., AND KRØIGAARD, M. Perfectly secure multiparty computation and the computational overhead of cryptography. In Proceedings of EuroCrypt (Springer Verlag 2010), pp. 445–465.

[10] DAMGÅRD, I., AND ZAKARIAS, S. Constant-overhead secure computation of boolean circuits using preprocessing. In TCC (2013), pp. 621–641.

[11] EVEN, S., GOLDREICH, O., AND LEMPEL, A. A randomized protocol for signing contracts. Commun. ACM 28, 6 (1985), 637–647.

[12] FIAT, A., AND SHAMIR, A. How to prove yourself: Practical solutions to identification and signature problems. In Advances in Cryptology—CRYPTO’86 (1986), Springer, pp. 186–194.

[13] FREDERIKSEN, T. K., NIELSEN, J. B., AND ORLANDI, C. Privacy-free garbled circuits with applications to efficient zero-knowledge. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Soﬁa, Bulgaria, April 26-30, 2015, Proceedings, Part II (2015), pp. 191–219.

[14] GIACOMELLI, I., MADSEN, J., AND ORLANDI, C. ZKboo: Faster zero-knowledge for boolean circuits. Cryptology ePrint Archive, Report 2016/163, 2016. http://eprint.iacr.org/.

[15] GOLDREICH, O., MICALI, S., AND WIGDERSON, A. How to play any mental game. In Proceedings of the nineteenth annual ACM symposium on Theory of computing (1987), ACM, pp. 218–229.

[16] GOLDWASSER, S., MICALI, S., AND RACKOFF, C. The knowledge complexity of interactive proof-systems (extended abstract). In Proceedings of the 17th Annual ACM Symposium on Theory of Computing, May 6-8, 1985, Providence, Rhode Island, USA (1985), pp. 291–304.

[17] HAZAY, C., AND LINDELL, Y. Efficient secure two-party protocols: Techniques and constructions. Springer Science & Business Media, 2010.

[18] HAZAY, C., AND VENKITASUBRAMANIAM, M. On the power of secure two-party computation. Cryptology ePrint Archive, Report 2016/074. To appear in Crypto 2016, 2016. http://eprint.iacr.org/.

[19] ISHAI, Y., KUSHILEVITZ, E., OSTROVSKY, R., AND SAHAI, A. Zero-knowledge from secure multiparty computation. In Proceedings of the Thirty-ninth Annual ACM Symposium on Theory of Computing (2007), STOC ’07, ACM, pp. 21–30.

[20] ISHAI, Y., KUSHILEVITZ, E., OSTROVSKY, R., AND SAHAI, A. Zero-knowledge proofs from secure multiparty computation. SIAM Journal on Computing 39, 3 (2009), 1121–1152.

[21] JAWUREK, M., KERSCHBAUM, F., AND ORLANDI, C. Zero-knowledge using garbled circuits: How to prove non-algebraic statements efficiently. In 2013 ACM SIGSAC Conference on Computer and Communications Security, CCS’13, Berlin, Germany, November 4-8, 2013 (2013), pp. 955–966.

[22] NIELSEN, J. B., NORDHOLT, P. S., ORLANDI, C., AND BURRA, S. S. A new approach to practical active-secure two-party computation. In Advances in Cryptology - CRYPTO 2012 - 32nd Annual Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2012. Proceedings (2012), pp. 681–700.

[23] PARNO, B., HOWELL, J., GENTRY, C., AND RAYKOVA, M. Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy, SP 2013, Berkeley, CA, USA, May 19-22, 2013 (2013), pp. 238–252.

[24] RABIN, M. O. How to exchange secrets with oblivious transfer. IACR Cryptology ePrint Archive 2005 (2005), 187.

[25] RANELLUCCI, S., TAPP, A., AND ZAKARIAS, R. W. Efficient generic zero-knowledge proofs from commitments. Cryptology ePrint Archive, Report 2014/934. To appear in ICITS 2016, 2014. http://eprint.iacr.org/.

[26] SCHNORR, C.-P. Efficient identification and signatures for smart cards. In CRYPTO (1989), pp. 239–252.

[27] ZAHUR, S., ROSULEK, M., AND EVANS, D. Two halves make a whole - reducing data transfer in garbled circuits using half gates. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Soﬁa, Bulgaria, April 26-30, 2015, Proceedings, Part II (2015), pp. 220–250.

### Appendix

#### Proof of Proposition 4.1

**Proof:**

To prove that the decomposition \( D_Z \) is correct, it is sufficient to show that for any \( c \in [N] \), the following holds:

1. If the \( c \)-th gate is an "add \( \alpha \)" gate, then:
   \[
   w_i[c] = \sum_{i=1}^3 w_i[a] + \alpha
   \]

2. If the \( c \)-th gate is a "mult. \( \alpha \)" gate, then:
   \[
   w_i[c] = \sum_{i=1}^3 w_i[a] \cdot \alpha
   \]

3. If the \( c \)-th gate is an addition gate, then:
   \[
   w_i[c] = \sum_{i=1}^3 w_i[a] + \sum_{i=1}^3 w_i[b]
   \]

4. If the \( c \)-th gate is a multiplication gate, then:
   \[
   w_i[c] = \sum_{i=1}^3 w_i[a] \cdot \sum_{i=1}^3 w_i[b]
   \]

Using (1), (2), (3), and (4) iteratively for all the gates in the circuit, we can prove that:
\[
\sum_{i=1}^3 w_i[N] = \phi \left( \sum_{i=1}^3 x_i \right)
\]
and from this, it follows that:
\[
\sum_{i=1}^3 w_i[N] = \phi \left( \sum_{i=1}^3 x_i \right)
\]

The first three follow trivially by the definition of the function \( \phi(c)_{A_i} \) when the \( c \)-th gate is an "add \( \alpha \)", "mult. \( \alpha \)", or addition gate, respectively. Now assume that the \( c \)-th gate is a multiplication gate. Then, using the definition for the function \( \phi(c)_{A_i} \) for this case and recalling that the index values are computed modulo 3, we have that:
\[
\sum_{i=1}^3 w_i[c] = \sum_{i=1}^3 \left( w_i[a] \cdot w_i[b] + w_{i+1}[a] \cdot w_i[b] + w_i[a] \cdot w_{i+1}[b] + R_i(c) - R_{i+1}(c) \right)
\]
\[
= \sum_{i=1}^3 w_i[a] \cdot (w_i[b] + w_{i+1}[b]) + \sum_{i=1}^3 w_i[a] \cdot w_{i+2}[b] + \sum_{i=1}^3 R_i(c) - \sum_{i=1}^3 R_{i+1}(c)
\]
\[
= \left( \sum_{i=1}^3 w_i[a] \right) \cdot \left( \sum_{i=1}^3 w_i[b] \right)
\]

We now proceed to prove the 2-privacy property. Given \( e \in [3] \), we define the simulator \( S_e \) on input \( y \) with the following instructions:

1. Sample random tapes \( k_e, k_{e+1} \).
2. Sample uniformly at random the values \( w_e[0] \) and \( w_{e+1}[0] \). For all \( c \in [N] \):
   - If the \( c \)-th gate is an "add \( \alpha \)", "mult. \( \alpha \)", or addition gate, then define \( w_e[c] \) and \( w_{e+1}[c] \) using the functions \( \phi(c)_e \) and \( \phi(c)_{e+1} \), respectively.
   - If the \( c \)-th gate is a multiplication gate, sample uniformly at random the value \( w_{e+1}[c] \) and compute the value \( w_e[c] \) using \( \phi(c)_e \). In this way, define the entire views \( w_e \) and \( w_{e+1} \).
3. Compute \( y_e = \text{Output}_e(w_e) \) and \( y_{e+1} = \text{Output}_{e+1}(w_{e+1}) \).
4. Compute \( y_{e+2} = y - (y_e + y_{e+1}) \).
5. Output \( \{ k_e, w_e \}, \{ k_{e+1}, w_{e+1} \}, y_{e+2} \).

It is easy to verify that the output of the simulator \( S_e \) has the same distribution as the string \( \{ k_i, w_i \}_{i \in \{e, e+1\}}, y_{e+2} \) produced by the protocol \( \Pi^*_{\phi} \). All elements in the output of \( S_e \) are computed using the same commands used in \( \Pi^*_{\phi} \), except for the element \( w_{e+1}[c] \) when the \( c \)-th gate is a multiplication gate. In this case, \( w_{e+1}[c] \) is sampled uniformly at random, while \( w_{e+1}[c] \) in the protocol is computed using the function \( \phi(c)_{e+1} \). Specifically, \( w_{e+1}[c] \) is computed by subtracting a determined value from the element \( R_{i+2}(c) \). Since \( R_{i+2} \) is a uniformly random function sampled using an independent tape \( k_{e+2} \), the distribution of \( w_{e+1}[c] \) in the protocol is uniform, matching the distribution of \( w_{e+1}[c] \) in the output of \( S_e \). Therefore, \( S_e \) is a correct simulator for the decomposition \( D_Z \).

Finally, by inspection, we have that \( |w_i| = (k + N + \lceil \log |Z| \rceil) \log |Z| + \kappa \) for all \( i \in [3] \).

---

This optimized text should be clearer, more coherent, and professionally formatted.