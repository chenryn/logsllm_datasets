cmp r0,#53
cmpls r1,#7
movhi pc,lr
```
> 
> 带后缀 `ls` 的命令只有在上一个比较命令的结果是第一个数字小于或与第二个数字相同的情况下才会被运行。它是无符号的。
> 
> 
> 带后缀 `hi` 的命令只有上一个比较命令的结果是第一个数字大于第二个数字的情况下才会被运行。它是无符号的。
> 
> 
> 
在写一个函数时，我们首先要考虑的事情就是输入，如果输入错了我们怎么办？在这个函数中，我们有一个输入是 GPIO 针脚号，而它必须是介于 0 到 53 之间的数字，因为只有 54 个针脚。每个针脚有 8 个函数，被编号为 0 到 7，因此函数编号也必须是 0 到 7 之间的数字。我们可以假设输入应该是正确的，但是当在硬件上使用时，这种做法是非常危险的，因为不正确的值将导致非常糟糕的副作用。所以，在这个案例中，我们希望确保输入值在正确的范围。
为了确保输入值在正确的范围，我们需要做一个检查，即 `r0`  7，`movhi` 会运行，函数结束，否则 `movhi` 不会运行，这样我们就确定 `r0`  
> `push {reg1,reg2,...}` 复制列出的寄存器 `reg1`、`reg2`、… 到栈顶。该命令仅能用于通用寄存器和 `lr` 寄存器。
> 
> 
> `bl lbl` 设置 `lr` 为下一个指令的地址并切换到标签 `lbl`。
> 
> 
> 
这三个命令用于调用我们第一个方法。`push {lr}` 命令复制 `lr` 中的值到栈顶，这样我们在后面可以获取到它。当我们调用 `GetGpioAddress` 时必须要这样做，我们将需要使用 `lr` 去保存我们函数要返回的地址。
如果我们对 `GetGpioAddress` 函数一无所知，我们必须假设它改变了 `r0`、`r1`、`r2` 和 `r3` 的值 ，并移动我们的值到 `r4` 和 `r5` 中，以在函数完成之后保持它们的值一样。幸运的是，我们知道 `GetGpioAddress` 做了什么，并且我们也知道它仅改变了 `r0` 为 GPIO 地址，它并没有影响 `r1`、`r2` 或 `r3` 的值。因此，我们仅去将 GPIO 针脚号从 `r0` 中移出，这样它就不会被覆盖掉，但我们知道，可以将它安全地移到 `r2` 中，因为 `GetGpioAddress` 并不去改变 `r2`。
最后我们使用 `bl` 指令去运行 `GetGpioAddress`。通常，运行一个函数，我们使用一个术语叫“调用”，从现在开始我们将一直使用这个术语。正如我们前面讨论过的，`bl` 调用一个函数是通过更新 `lr` 为下一个指令的地址并切换到该函数完成的。
当一个函数结束时，我们称为“返回”。当一个 `GetGpioAddress` 调用返回时，我们已经知道了 `r0` 中包含了 GPIO 的地址，`r1` 中包含了函数编号，而 `r2` 中包含了 GPIO 针脚号。
我前面说过，GPIO 函数每 10 个保存在一个块中，因此首先我们需要去判断我们的针脚在哪个块中。这似乎听起来像是要使用一个除法，但是除法做起来非常慢，因此对于这些比较小的数来说，不停地做减法要比除法更好。
将下面的代码复制到上面的代码中最下面的位置。
```
functionLoop$:
cmp r2,#9
subhi r2,#10
addhi r0,#4
bhi functionLoop$
```
> 
> `add reg,#val` 将数字 `val` 加到寄存器 `reg` 的内容上。
> 
> 
> 
这个简单的循环代码将针脚号（`r2`）与 9 进行比较。如果它大于 9，它将从针脚号上减去 10，并且将 GPIO 控制器地址加上 4，然后再次运行检查。
这样做的效果就是，现在，`r2` 中将包含一个 0 到 9 之间的数字，它是针脚号除以 10 的余数。`r0` 将包含这个针脚的函数所设置的 GPIO 控制器的地址。它就如同是 “GPIO 控制器地址 + 4 × (GPIO 针脚号 ÷ 10)”。
最后，将下面的代码复制到上面的代码中最下面的位置。
```
add r2, r2,lsl #1
lsl r1,r2
str r1,[r0]
pop {pc}
```
> 
> 移位参数 `reg,lsl #val` 表示将寄存器 `reg` 中二进制表示的数逻辑左移 `val` 位之后的结果作为与前面运算的操作数。
> 
> 
> `lsl reg,amt` 将寄存器 `reg` 中的二进制数逻辑左移 `amt` 中的位数。
> 
> 
> `str reg,[dst]` 与 `str reg,[dst,#0]` 相同。
> 
> 
> `pop {reg1,reg2,...}` 从栈顶复制值到寄存器列表 `reg1`、`reg2`、… 仅有通用寄存器与 `pc` 可以这样弹出值。
> 
> 
> 
这个代码完成了这个方法。第一行其实是乘以 3 的变体。乘法在汇编中是一个大而慢的指令，因为电路需要很长时间才能给出答案。有时使用一些能够很快给出答案的指令会让它变得更快。在本案例中，我们知道 `r2` × 3 与 `r2` × 2 + `r2` 是相同的。一个寄存器乘以 2 是非常容易的，因为它可以通过将二进制表示的数左移一位来很方便地实现。
ARMv6 汇编语言其中一个非常有用的特性就是，在使用它之前可以先移动参数所表示的位数。在本案例中，我将 `r2` 加上 `r2` 中二进制表示的数左移一位的结果。在汇编代码中，你可以经常使用这个技巧去更快更容易地计算出答案，但如果你觉得这个技巧使用起来不方便，你也可以写成类似 `mov r3,r2`； `add r2,r3`； `add r2,r3` 这样的代码。
现在，我们可以将一个函数的值左移 `r2` 中所表示的位数。大多数对数量的指令（比如 `add` 和 `sub`）都有一个可以使用寄存器而不是数字的变体。我们执行这个移位是因为我们想去设置表示针脚号的位，并且每个针脚有三个位。
然后，我们将函数计算后的值保存到 GPIO 控制器的地址上。我们在循环中已经算出了那个地址，因此我们不需要像 OK01 和 OK02 中那样在一个偏移量上保存它。
最后，我们从这个方法调用中返回。由于我们将 `lr` 推送到了栈上，因此我们 `pop pc`，它将复制 `lr` 中的值并将它推送到 `pc` 中。这个操作类似于 `mov pc,lr`，因此函数调用将返回到运行它的那一行上。
敏锐的人可能会注意到，这个函数其实并不能正确工作。虽然它将 GPIO 针脚函数设置为所要求的值，但它会导致在同一个块中的所有的 10 个针脚的函数都归 0！在一个大量使用 GPIO 针脚的系统中，这将是一个很恼人的问题。我将这个问题留给有兴趣去修复这个函数的人，以确保只设置相关的 3 个位而不去覆写其它位，其它的所有位都保持不变。关于这个问题的解决方案可以在本课程的下载页面上找到。你可能会发现非常有用的几个函数是 `and`，它是计算两个寄存器的布尔与函数，`mvns` 是计算布尔非函数，而 `orr` 是计算布尔或函数。
### 4、另一个函数
现在，我们已经有了能够管理 GPIO 针脚函数的函数。我们还需要写一个能够打开或关闭 GPIO 针脚的函数。我们不需要写一个打开的函数和一个关闭的函数，只需要一个函数就可以做这两件事情。
我们将写一个名为 `SetGpio` 的函数，它将 GPIO 针脚号作为第一个输入放入 `r0` 中，而将值作为第二个输入放入 `r1` 中。如果该值为 `0`，我们将关闭针脚，而如果为非零则打开针脚。
将下列的代码复制粘贴到 `gpio.s` 文件的结尾部分。
```
.globl SetGpio
SetGpio:
pinNum .req r0
pinVal .req r1
```
> 
> `alias .req reg` 设置寄存器 `reg` 的别名为 `alias`。
> 
> 
> 
我们再次需要 `.globl` 命令，标记它为其它文件可访问的全局函数。这次我们将使用寄存器别名。寄存器别名允许我们为寄存器使用名字而不仅是 `r0` 或 `r1`。到目前为止，寄存器别名还不是很重要，但随着我们后面写的方法越来越大，它将被证明非常有用，现在开始我们将尝试使用别名。当在指令中使用到 `pinNum .req r0` 时，它的意思是 `pinNum` 表示 `r0`。
将下面的代码复制粘贴到上述的代码下面位置。
```
cmp pinNum,#53
movhi pc,lr
push {lr}
mov r2,pinNum
.unreq pinNum
pinNum .req r2
bl GetGpioAddress
gpioAddr .req r0
```
> 
> `.unreq alias` 删除别名 `alias`。