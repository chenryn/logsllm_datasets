---
## Page 1052
### CTF特训营：技术详解、解题方法与
#### 27.7 专业调试工具
在AVR Studio的调试界面中，依次选择`View` -> `Memory Window`即可打开内存查看器，用于查看内存中的数据值。需要注意的是，AVR单片机采用哈弗结构，因此存储区分为程序存储区和数据存储区。在实际使用时，必须正确选择要查看的存储区域，否则会看到错误的数据值。如图27-39所示，左上角的选择框可以切换当前查看的存储区（程序或数据）。

![图27-39 内存查看器](图27-39)

总之，AVR Studio非常易于上手，更多功能请读者自行尝试和发现。随着使用次数的增加，读者会发现AVR Studio确实是一款强大的AVR全系列调试工具。

---

## Page 1054
### CTF特训营：技术详解、解题方法与
#### 27.7 专业调试工具

Helmi（Hapsim）是一个开源的AVR外设模拟器，作为AVR Studio的一个插件使用。它可以将串行设备（如USART、I2C、SPI等）虚拟成终端进行交互，这在调试按终端方式工作的串口程序时非常有用。本节将简单介绍该软件的使用方法。该插件是免费的，读者可从以下网址下载：[http://www.helmix.at/hapsim/](http://www.helmix.at/hapsim/)。

在使用Hapsim之前，首先需要启动AVR Studio，并创建好工程。然后启动Hapsim软件，如图27-40所示。

![图27-40 Hapsim启动界面](图27-40)

Hapsim可以模拟1602液晶屏、数字键盘、IO端口，并将TWI或USART转为COM口，方便与程序进行交互。例如，如果希望使用TWI与程序交互，可以通过依次选择`File` -> `New Control` -> `Terminal`来创建一个终端，如图27-41所示。

![图27-41 创建Terminal界面](图27-41)

创建终端后，还需要根据实际情况进行一些设置。例如，若想连接TWI和终端，则需在`Options` -> `Terminal Settings`中进行相应设置，如图27-42和图27-43所示。

![图27-42 打开Options选项卡](图27-42)

![图27-43 Terminal Setting窗体](图27-43)

在`Serial`模式中选择TWI，并勾选`Local Echo`前的方框以方便操作。点击`OK`按钮后，即可通过终端窗口与程序的TWI进行通信。如果是USART，在`Serial`选项中相应选择USART即可。此外，还有许多高级技巧供读者自行实践和发现。

---

## Page 1058
### CTF特训营：技术详解、解题方法与
#### 27.8 反编译工具

基于以上分析，我们已经找到了正确的反汇编分析方法。然而，目前泄露出来的IDA 6.8版本仅支持x86/x86_64和ARM32的反编译。即使是最新版本的IDA 6.9，也只增加了对aarch64和PPC的支持。对于IoT程序的分析，反编译工具提供了极大的便利。

如果没有最新的IDA也没关系，这里提供了一个替代方案：Retargetable Decompiler。这是一个在线免费反编译工具，支持x86、ARM、MIPS、PIC32和PPC平台的反编译。它在很大程度上可以替代IDA的功能，并且还支持IDA尚不支持的MIPS和PIC32。此外，该工具还提供了一个IDA插件，使用起来相当方便。在线反编译的结果也非常便于阅读。

在此推荐大家使用该工具：[https://retdec.com/decompilation/](https://retdec.com/decompilation/)。大多数情况下，只需上传bin文件即可下载到反编译后的源码。当然，读者也可以进一步使用该工具提供的API和IDA插件进行更高级的交互式反编译分析。

---

## Page 1059
### CTF特训营：技术详解、解题方法与
#### 第28章 固件结构分析

在前面的章节中，我们讨论了裸机系统（即整个固件就是一个程序）的固件逆向工程方法。但在实际环境中，我们遇到的固件通常是一系列文件或文件系统的组合，甚至包含压缩或加密的部分。在这种情况下，我们需要先对固件结构进行分析，从中分离出代码、文件和部分数据，再进行精确分析。本章将为大家介绍复杂固件的分析方法。

---

## Page 1060
### CTF特训营：技术详解、解题方法与
#### 28.1 常见固件类型

在前面的章节中，我们已经介绍了单片机程序的分析方法。接下来我们将分析嵌入式系统的固件。事实上，在介绍完单片机软件逆向工程后，我们已经分析了一种最基本的固件——裸机程序。裸机程序是最简单的固件，只包含代码和所需的数据。更复杂的固件则可能包含多个文件系统。

常见的固件类型包括：
- **裸机程序**：最简单的固件，容易分析，IDA可以正确识别并分析。
- **文件系统镜像**：包含完整的嵌入式文件系统，内部组织了多个文件结构，可能维护Linux的根目录，需要提取相应的bin文件进行分析。还可能包含配置文件（如xml或conf/ini文件）。
- **带压缩的镜像**：为了节省空间，固件内容被压缩，由引导代码进行解压。这种固件通常是只读的。
- **带压缩的文件系统**：采用支持压缩的文件系统（如Squashfs），使用lzma等算法进行压缩，实际运行时文件系统也是只读的。

由于裸机程序已在前文详细分析，本节将着重介绍文件系统的分析。在Linux中，可以使用常用的`binwalk`和`file`命令进行初步判定。

---

## Page 1062
### CTF特训营：技术详解、解题方法与
#### 28.2 Flash文件系统

与普通计算机系统不同，嵌入式系统通常使用低成本的存储器（如EEPROM或Nor/Nand Flash）。这些存储器在特性、写入和磨损性能上与机械硬盘或SSD有显著差异。因此，设计了专门针对Flash存储器的文件系统。常见的Flash文件系统包括：

- **JFFS/JFFS2**：RedHat公司开发的闪存文件系统，最初为NOR Flash设计，自2.6版本后开始支持NAND Flash，适合嵌入式系统，多见于32MB以下的Nor型Flash固件中。支持zlib、rubin和rtime三种压缩算法。
- **YAFFS/YAFFS2**：AlephOne公司开发的NAND flash嵌入式文件系统，最初专门为Nand型Flash设计，适用于大容量Flash读写。多见于128MB以上的Nand型Flash固件中。
- **Squashfs**：GPL开源只读压缩文件系统，支持文件、inode及目录结构的压缩，多用于存储资源紧张的场合。OpenWrt和DD-Wrt的固件使用的就是这种文件系统，常见于4～16MB的Nor型Flash中。

---

## Page 1064
### CTF特训营：技术详解、解题方法与
#### 28.3 固件基地址确定方法

在前面的讨论中，我们使用IDA加载并分析hex文件。但很多时候，我们拿到的是不包含加载基地址信息的固件，这时需要通过一些方法确定加载地址，并在IDA中使用正确的基地址加载程序，才能得到正确的分析结果。以下是几种常用的方法：

1. **查阅Datasheet**：对于裸机程序，其加载基地址是确定的，可以在Datasheet中找到，通常是程序存储区的起始地址。例如，ConfusedARM的加载地址0x08000000就是Memory Maps中Flash区域的起始地址。其他芯片的裸机程序同样可以通过查询Datasheet得出结论。

2. **在固件分区表中查找**：某些固件在头部有分区表，标明了每个分区的加载地址。如果某个分区没有加载地址，则表示该分区不会被映射到内存中。分区表的结构如图28-1所示。

![图28-1 分区表结构](图28-1)