# CVE-2019-0703根源分析
|
##### 译文声明
本文是翻译文章，文章原作者 checkpoint，文章来源：research.checkpoint.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
微软称CVE-2019-0703漏洞是Windows
SMB服务器处理特定请求时发生信息泄露漏洞。成功利用该漏洞是攻击者可以伪造包，从服务器窃取信息，导致信息泄露。
为了利用该漏洞，攻击者需要认证并发送SMB消息到受影响的Windows SBM服务器。安全更新通过修正Windows
SMB服务器处理经过认证的请求的方式来修复该漏洞。
但研究人员发现了一些不同的情况。研究人员该漏洞事实上是一个与从Windows Named
Pipes查询信息的机制相关的逻辑漏洞，并非SMB协议或其实现中的漏洞。虽然目前该漏洞是通过SMB触发的，但仍然有一些其他方式来利用该漏洞，比如使用NtQueryInformationFile
Windows API调用，而这与SMB是无关的。
该bug位于`npfs.sys`(Name Pipe File System
driver)中的函数`NpQueryInternalInfo`中。`npfs.sys`用于查询命名的pipe并返回一个文件引用数的值，而微软官方文档显示该值必须由文件系统分配，并且对文件或目录所在的卷是唯一的。
研究人员分析表明返回的值并非文件引用数（file reference number），而是一个指向kernel结构CCB（Client Control
Block）的指针。这在`npfs.sys`中并没有定义，但是在ReactOS
项目中有部分定义，即`NP_CCB`。很明显这并不是应该返回的值，泄露的struct可以被攻击者利用。
图8: 泄露的对象是CCB struct
为了触发该信息泄露漏洞，通过`ntdll.dll`的`NtQueryInformationFile stub`的以下参数进行调用：
    FileHandle – Handle to a named pipe (for example “\.pipebrowser”).
    FileInformationClass – FileInternalInformation (equals 0x6).
发生后，可以得到下面的调用栈：
图9: 与从用户模式调用`NtQueryInformationFile`相关的Kernel mode调用栈
前面已经讲到，该漏洞可以通过SMB来触发。用来确定被攻击的操作系统的位和覆写泄露的结构的域的方法，会导致远程代码执行。
为了利用该漏洞，必须首先建立到受害者及其的命名pipe的SMB连接，如下图所示：
图10: 证明建立了到pipebrowser 命名pipe (FID 0x4000)的SMB包网络抓包
然后可以用`0x32
SMB`命令(`SMB_COM_TRANSACTION2`)和`0x7`子命令(`TRANS2_QUERY_FILE_INFORMATION`)来查询关于打开的pipe的信息。后者有一个名为`InformationLevel`的域来描述从服务器提取的信息类型。
如果服务器在Negotiate Response域中声明了名为`Infolevel
Passthru`的功能作为早期协商信息，还可以提取更多的信息，，比如在服务器上提供原生文件信息。这样，前者的能力允许其提供名为`Pass-thru
Information Level`的代码数（客户端）来直接与服务器上另一个名为`Information
Class`的代码数映射。该值与`NtQueryInformationFile
API`的`FileInformationClass`参数是对应的，其中指定了从服务器查询什么类型的文件信息。
为了使用一个`pass-thru Information Levels`来查询服务器上的文件，添加值`0x3e8
(SMB_INFO_PASSTHROUGH)`到请求的`Information
Class`中就可以了。比如，如果获取`FileInternalInformation Information
Class`，想要获取相应的Information Level，只需要添加之前提到的值到information level中，最终会得到值`0x3ee`。
在本例中，使用相同的`Information
Level`将其作为`TRANS2_QUERY_FILE_INFORMATION`子命令的参数，通过从`srv.sys` driver (SMB
driver)中调用`NtQueryInformationFile`来触发该漏洞。后者会从npfs.sys来调用有漏洞的`NpQueryInternalInfo`，如下所示：
图11: Kernel mode调用栈
研究人员通过之前提到的info level发布一个到Trans2的请求来查询文件信息，并在响应中获取了CCB泄露的指针。
图12: Wireshark中获取的触发该漏洞的视图
为了确认该漏洞的根源，研究人员分析了`npfs.sys`文件补丁代码和未修复版本的差异：
图13: 补丁差异分析
可以看出，在有漏洞的代码中，`out_buffer`参数会返回调用者，然后客户端含有一个到`ClientControlBlock
(NP_CCB)`参数的指针，而非文件引用数。在补丁版本的代码中，`ClientControlBlock`的`0xa0`和`0xa4`被写入了`out_buffer`。
通过从信息泄露中得到的信息可以在受害者机器中执行代码。具体来说，需要了解CCB结构。其中一个成员指向了另一个结构`struct
x`。该结构中含有一个指向一个函数的指针，该函数会在连接到命名pipe终止时被调用，将其称之为pipe destructor function。
在APT3的漏洞实现中，HAL堆使用了struct x 的shellcode和实例。实例中止含有一个指向pipe destructor
function位置的shellcode的指针。因此，如果知道泄露的CCB结构，就可以覆写其到struct
x的指针，这样就可以指向虚假的实例。当连接关闭时，shellcode会被触发，攻击者就可以在受害者机器上执行任意代码。