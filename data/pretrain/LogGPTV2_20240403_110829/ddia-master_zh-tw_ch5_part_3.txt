透过使用这个日志，从库可以构建一个与主库一模一样的资料结构复制。
这种复制方法在 PostgreSQL 和 Oracle 等一些产品中被使用到【16】。其主要缺点是日志记录的资料非常底层：WAL 包含哪些磁碟块中的哪些位元组发生了更改。这使复制与储存引擎紧密耦合。如果资料库将其储存格式从一个版本更改为另一个版本，通常不可能在主库和从库上执行不同版本的资料库软体。
看上去这可能只是一个小的实现细节，但却可能对运维产生巨大的影响。如果复制协议允许从库使用比主库更新的软体版本，则可以先升级从库，然后执行故障切换，使升级后的节点之一成为新的主库，从而允许资料库软体的零停机升级。如果复制协议不允许版本不匹配（传输 WAL 经常出现这种情况），则此类升级需要停机。
#### 逻辑日志复制（基于行）
另一种方法是对复制和储存引擎使用不同的日志格式，这样可以将复制日志从储存引擎的内部实现中解耦出来。这种复制日志被称为逻辑日志（logical log），以将其与储存引擎的（物理）资料表示区分开来。
关系资料库的逻辑日志通常是以行的粒度来描述对资料库表的写入记录的序列：
* 对于插入的行，日志包含所有列的新值。
* 对于删除的行，日志包含足够的资讯来唯一标识被删除的行，这通常是主键，但如果表上没有主键，则需要记录所有列的旧值。
* 对于更新的行，日志包含足够的资讯来唯一标识被更新的行，以及所有列的新值（或至少所有已更改的列的新值）。
修改多行的事务会生成多条这样的日志记录，后面跟著一条指明事务已经提交的记录。MySQL 的二进位制日志（当配置为使用基于行的复制时）使用了这种方法【17】。
由于逻辑日志与储存引擎的内部实现是解耦的，系统可以更容易地做到向后相容，从而使主库和从库能够执行不同版本的资料库软体，或者甚至不同的储存引擎。
对于外部应用程式来说，逻辑日志格式也更容易解析。如果要将资料库的内容传送到外部系统，例如复制到资料仓库进行离线分析，或建立自定义索引和快取【18】，这一点会很有用。这种技术被称为 **资料变更捕获（change data capture）**，[第十一章](ch11.md) 将重新讲到它。
#### 基于触发器的复制
到目前为止描述的复制方法是由资料库系统实现的，不涉及任何应用程式程式码。在很多情况下，这就是你想要的。但在某些情况下需要更多的灵活性。例如，如果你只想复制资料的一个子集，或者想从一种资料库复制到另一种资料库，或者如果你需要冲突解决逻辑（请参阅 “[处理写入冲突](#处理写入冲突)”），则可能需要将复制操作上移到应用程式层。
一些工具，如 Oracle Golden Gate【19】，可以透过读取资料库日志，使得其他应用程式可以使用资料。另一种方法是使用许多关系资料库自带的功能：触发器和储存过程。
触发器允许你将资料更改（写入事务）发生时自动执行的自定义应用程式程式码注册在资料库系统中。触发器有机会将更改记录到一个单独的表中，使用外部程式读取这个表，再加上一些必要的业务逻辑，就可以将资料变更复制到另一个系统去。例如，Databus for Oracle【20】和 Bucardo for Postgres【21】就是这样工作的。
基于触发器的复制通常比其他复制方法具有更高的开销，并且比资料库内建的复制更容易出错，也有很多限制。然而由于其灵活性，它仍然是很有用的。
## 复制延迟问题
容忍节点故障只是需要复制的一个原因。正如在 [第二部分](part-ii.md) 的介绍中提到的，其它原因还包括可伸缩性（处理比单个机器更多的请求）和延迟（让副本在地理位置上更接近使用者）。
基于领导者的复制要求所有写入都由单个节点处理，但只读查询可以由任何一个副本来处理。所以对于读多写少的场景（Web 上的常见模式），一个有吸引力的选择是建立很多从库，并将读请求分散到所有的从库上去。这样能减小主库的负载，并允许由附近的副本来处理读请求。
在这种读伸缩（read-scaling）的体系结构中，只需新增更多的从库，就可以提高只读请求的服务容量。但是，这种方法实际上只适用于非同步复制 —— 如果尝试同步复制到所有从库，则单个节点故障或网路中断将导致整个系统都无法写入。而且节点越多越有可能出现个别节点宕机的情况，所以完全同步的配置将是非常不可靠的。
不幸的是，当应用程式从非同步从库读取时，如果从库落后，它可能会看到过时的资讯。这会导致资料库中出现明显的不一致：同时对主库和从库执行相同的查询，可能得到不同的结果，因为并非所有的写入都反映在从库中。这种不一致只是一个暂时的状态 —— 如果停止写入资料库并等待一段时间，从库最终会赶上并与主库保持一致。出于这个原因，这种效应被称为 **最终一致性（eventual consistency）**【22,23】。[^iii]
[^iii]: 道格拉斯・特里（Douglas Terry）等人【24】创造了最终一致性这个术语，并经由 Werner Vogels【22】的推广，成为了许多 NoSQL 专案的口号。然而，最终一致性并不只属于 NoSQL 资料库：关系型资料库中的非同步复制从库也有相同的特性。
最终一致性中的 “最终” 一词有意进行了模糊化：总的来说，副本落后的程度是没有限制的。在正常的操作中，**复制延迟（replication lag）**，即写入主库到反映至从库之间的延迟，可能仅仅是几分之一秒，在实践中并不显眼。但如果系统在接近极限的情况下执行，或网路中存在问题时，延迟可以轻而易举地超过几秒，甚至达到几分钟。
因为滞后时间太长引入的不一致性，不仅仅是一个理论问题，更是应用设计中会遇到的真实问题。本节将重点介绍三个在复制延迟时可能发生的问题例项，并简述解决这些问题的一些方法。
### 读己之写
许多应用让使用者提交一些资料，然后检视他们提交的内容。可能是使用者资料库中的记录，也可能是对讨论主题的评论，或其他类似的内容。提交新资料时，必须将其传送给主库，但是当用户检视资料时，可以透过从库进行读取。如果资料经常被检视，但只是偶尔写入，这是非常合适的。
但对于非同步复制，问题就来了。如 [图 5-3](fig5-3.png) 所示：如果使用者在写入后马上就检视资料，则新资料可能尚未到达副本。对使用者而言，看起来好像是刚提交的资料丢失了，所以他们不高兴是可以理解的。
![](../img/fig5-3.png)
**图 5-3 使用者写入后从旧副本中读取资料。需要写后读 (read-after-write) 的一致性来防止这种异常**
在这种情况下，我们需要 **写后读一致性（read-after-write consistency）**，也称为 **读己之写一致性（read-your-writes consistency）**【24】。这是一个保证，如果使用者重新载入页面，他们总会看到他们自己提交的任何更新。它不会对其他使用者的写入做出承诺：其他使用者的更新可能稍等才会看到。它保证使用者自己的输入已被正确储存。
如何在基于领导者的复制系统中实现写后读一致性？有各种可能的技术，这里说一些：
* 对于使用者 **可能修改过** 的内容，总是从主库读取；这就要求得有办法不透过实际的查询就可以知道使用者是否修改了某些东西。举个例子，社交网路上的使用者个人资料资讯通常只能由使用者本人编辑，而不能由其他人编辑。因此一个简单的规则就是：总是从主库读取使用者自己的档案，如果要读取其他使用者的档案就去从库。
* 如果应用中的大部分内容都可能被使用者编辑，那这种方法就没用了，因为大部分内容都必须从主库读取（读伸缩就没效果了）。在这种情况下可以使用其他标准来决定是否从主库读取。例如可以跟踪上次更新的时间，在上次更新后的一分钟内，从主库读。还可以监控从库的复制延迟，防止向任何滞后主库超过一分钟的从库发出查询。
* 客户端可以记住最近一次写入的时间戳，系统需要确保从库在处理该使用者的读取请求时，该时间戳前的变更都已经传播到了本从库中。如果当前从库不够新，则可以从另一个从库读取，或者等待从库追赶上来。这里的时间戳可以是逻辑时间戳（表示写入顺序的东西，例如日志序列号）或实际的系统时钟（在这种情况下，时钟同步变得至关重要，请参阅 “[不可靠的时钟](ch8.md#不可靠的时钟)”）。
* 如果你的副本分布在多个数据中心（为了在地理上接近使用者或者出于可用性目的），还会有额外的复杂性。任何需要由主库提供服务的请求都必须路由到包含该主库的资料中心。
另一种复杂的情况发生在同一位使用者从多个装置（例如桌面浏览器和移动 APP）请求服务的时候。这种情况下可能就需要提供跨装置的写后读一致性：如果使用者在一个装置上输入了一些资讯，然后在另一个装置上检视，则应该看到他们刚输入的资讯。
在这种情况下，还有一些需要考虑的问题：