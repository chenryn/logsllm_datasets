* 在 [第七章](ch7.md) 中讨论的 **可序列化**，是关于事务表现的像按 **某种先后顺序（some sequential order）** 执行的保证。它可以字面意义上地以 **序列顺序（serial order）** 执行事务来实现，或者允许并行执行，但同时防止序列化冲突来实现（透过锁或中止事务）。
* 在 [第八章](ch8.md) 讨论过的在分散式系统中使用时间戳和时钟（请参阅 “[依赖同步时钟](ch8.md#依赖同步时钟)”）是另一种将顺序引入无序世界的尝试，例如，确定两个写入操作哪一个更晚发生。
事实证明，顺序、线性一致性和共识之间有著深刻的联络。尽管这个概念比本书其他部分更加理论化和抽象，但对于明确系统的能力范围（可以做什么和不可以做什么）而言是非常有帮助的。我们将在接下来的几节中探讨这个话题。
### 顺序与因果关系
**顺序** 反复出现有几个原因，其中一个原因是，它有助于保持 **因果关系（causality）**。在本书中我们已经看到了几个例子，其中因果关系是很重要的：
* 在 “[一致字首读](ch5.md#一致字首读)”（[图 5-5](../img/fig5-5.png)）中，我们看到一个例子：一个对话的观察者首先看到问题的答案，然后才看到被回答的问题。这是令人困惑的，因为它违背了我们对 **因（cause）** 与 **果（effect）** 的直觉：如果一个问题被回答，显然问题本身得先在那里，因为给出答案的人必须先看到这个问题（假如他们并没有预见未来的超能力）。我们认为在问题和答案之间存在 **因果依赖（causal dependency）**。
* [图 5-9](../img/fig5-9.png) 中出现了类似的模式，我们看到三位领导者之间的复制，并注意到由于网路延迟，一些写入可能会 “压倒” 其他写入。从其中一个副本的角度来看，好像有一个对尚不存在的记录的更新操作。这里的因果意味著，一条记录必须先被建立，然后才能被更新。
* 在 “[检测并发写入](ch5.md#检测并发写入)” 中我们观察到，如果有两个操作 A 和 B，则存在三种可能性：A 发生在 B 之前，或 B 发生在 A 之前，或者 A 和 B**并发**。这种 **此前发生（happened before）** 关系是因果关系的另一种表述：如果 A 在 B 前发生，那么意味著 B 可能已经知道了 A，或者建立在 A 的基础上，或者依赖于 A。如果 A 和 B 是 **并发** 的，那么它们之间并没有因果联络；换句话说，我们确信 A 和 B 不知道彼此。
* 在事务快照隔离的上下文中（“[快照隔离和可重复读](ch7.md#快照隔离和可重复读)”），我们说事务是从一致性快照中读取的。但此语境中 “一致” 到底又是什么意思？这意味著 **与因果关系保持一致（consistent with causality）**：如果快照包含答案，它也必须包含被回答的问题【48】。在某个时间点观察整个资料库，与因果关系保持一致意味著：因果上在该时间点之前发生的所有操作，其影响都是可见的，但因果上在该时间点之后发生的操作，其影响对观察者不可见。**读偏差（read skew）** 意味著读取的资料处于违反因果关系的状态（不可重复读，如 [图 7-6](../img/fig7-6.png) 所示）。
* 事务之间 **写偏差（write skew）** 的例子（请参阅 “[写入偏差与幻读](ch7.md#写入偏差与幻读)”）也说明了因果依赖：在 [图 7-8](../img/fig7-8.png) 中，爱丽丝被允许离班，因为事务认为鲍勃仍在值班，反之亦然。在这种情况下，离班的动作因果依赖于对当前值班情况的观察。[可序列化快照隔离](ch7.md#可序列化快照隔离) 透过跟踪事务之间的因果依赖来检测写偏差。
* 在爱丽丝和鲍勃看球的例子中（[图 9-1](../img/fig9-1.png)），在听到爱丽丝惊呼比赛结果后，鲍勃从伺服器得到陈旧结果的事实违背了因果关系：爱丽丝的惊呼因果依赖于得分宣告，所以鲍勃应该也能在听到爱丽斯惊呼后查询到比分。相同的模式在 “[跨通道的时序依赖](#跨通道的时序依赖)” 一节中，以 “影象大小调整服务” 的伪装再次出现。
因果关系对事件施加了一种 **顺序**：因在果之前；讯息传送在讯息收取之前。而且就像现实生活中一样，一件事会导致另一件事：某个节点读取了一些资料然后写入一些结果，另一个节点读取其写入的内容，并依次写入一些其他内容，等等。这些因果依赖的操作链定义了系统中的因果顺序，即，什么在什么之前发生。
如果一个系统服从因果关系所规定的顺序，我们说它是 **因果一致（causally consistent）** 的。例如，快照隔离提供了因果一致性：当你从资料库中读取到一些资料时，你一定还能够看到其因果前驱（假设在此期间这些资料还没有被删除）。
#### 因果顺序不是全序的
**全序（total order）** 允许任意两个元素进行比较，所以如果有两个元素，你总是可以说出哪个更大，哪个更小。例如，自然数集是全序的：给定两个自然数，比如说 5 和 13，那么你可以告诉我，13 大于 5。
然而数学集合并不完全是全序的：`{a, b}` 比 `{b, c}` 更大吗？好吧，你没法真正比较它们，因为二者都不是对方的子集。我们说它们是 **无法比较（incomparable）** 的，因此数学集合是 **偏序的（partially ordered）** ：在某些情况下，可以说一个集合大于另一个（如果一个集合包含另一个集合的所有元素），但在其他情况下它们是无法比较的 [^译注i]。
[^译注i]: 设 R 为非空集合 A 上的关系，如果 R 是自反的、反对称的和可传递的，则称 R 为 A 上的偏序关系。简称偏序，通常记作≦。一个集合 A 与 A 上的偏序关系 R 一起叫作偏序集，记作 $(A,R)$ 或 $(A, ≦)$。全序、偏序、关系、集合，这些概念的精确定义可以参考任意一本离散数学教材。
全序和偏序之间的差异反映在不同的资料库一致性模型中：
* 线性一致性
  线性一致的系统中，操作是全序的：如果系统表现的就好像只有一个数据副本，并且所有操作都是原子性的，这意味著对任何两个操作，我们总是能判定哪个操作先发生。这个全序在 [图 9-4](../img/fig9-4.png) 中以时间线表示。
* 因果性
  我们说过，如果两个操作都没有在彼此 **之前发生**，那么这两个操作是并发的（请参阅 [“此前发生” 的关系和并发](ch5.md#“此前发生”的关系和并发)）。换句话说，如果两个事件是因果相关的（一个发生在另一个事件之前），则它们之间是有序的，但如果它们是并发的，则它们之间的顺序是无法比较的。这意味著因果关系定义了一个偏序，而不是一个全序：一些操作相互之间是有顺序的，但有些则是无法比较的。
因此，根据这个定义，线性一致的资料储存中是不存在并发操作的：必须有且仅有一条时间线，所有的操作都在这条时间线上，构成一个全序关系。可能有几个请求在等待处理，但是资料储存确保了每个请求都是在唯一时间线上的某个时间点自动处理的，不存在任何并发。
并发意味著时间线会分岔然后合并 —— 在这种情况下，不同分支上的操作是无法比较的（即并发操作）。在 [第五章](ch5.md) 中我们看到了这种现象：例如，[图 5-14](../img/fig5-14.png) 并不是一条直线的全序关系，而是一堆不同的操作并发进行。图中的箭头指明了因果依赖 —— 操作的偏序。
如果你熟悉像 Git 这样的分散式版本控制系统，那么其版本历史与因果关系图极其相似。通常，一个 **提交（Commit）** 发生在另一个提交之后，在一条直线上。但是有时你会遇到分支（当多个人同时在一个专案上工作时），**合并（Merge）** 会在这些并发建立的提交相融合时建立。
#### 线性一致性强于因果一致性
那么因果顺序和线性一致性之间的关系是什么？答案是线性一致性 **隐含著（implies）** 因果关系：任何线性一致的系统都能正确保持因果性【7】。特别是，如果系统中有多个通讯通道（如 [图 9-5](../img/fig9-5.png) 中的讯息伫列和档案储存服务），线性一致性可以自动保证因果性，系统无需任何特殊操作（如在不同元件间传递时间戳）。
线性一致性确保因果性的事实使线性一致系统变得简单易懂，更有吸引力。然而，正如 “[线性一致性的代价](#线性一致性的代价)” 中所讨论的，使系统线性一致可能会损害其效能和可用性，尤其是在系统具有严重的网路延迟的情况下（例如，如果系统在地理上散布）。出于这个原因，一些分散式资料系统已经放弃了线性一致性，从而获得更好的效能，但它们用起来也更为困难。
好讯息是存在折衷的可能性。线性一致性并不是保持因果性的唯一途径 —— 还有其他方法。一个系统可以是因果一致的，而无需承担线性一致带来的效能折损（尤其对于 CAP 定理不适用的情况）。实际上在所有的不会被网路延迟拖慢的一致性模型中，因果一致性是可行的最强的一致性模型。而且在网路故障时仍能保持可用【2,42】。
在许多情况下，看上去需要线性一致性的系统，实际上需要的只是因果一致性，因果一致性可以更高效地实现。基于这种观察结果，研究人员正在探索新型的资料库，既能保证因果一致性，且效能与可用性与最终一致的系统类似【49,50,51】。
这方面的研究相当新鲜，其中很多尚未应用到生产系统，仍然有不少挑战需要克服【52,53】。但对于未来的系统而言，这是一个有前景的方向。
#### 捕获因果关系
我们不会在这里讨论非线性一致的系统如何保证因果性的细节，而只是简要地探讨一些关键的思想。
为了维持因果性，你需要知道哪个操作发生在哪个其他操作之前（**happened before**）。这是一个偏序：并发操作可以以任意顺序进行，但如果一个操作发生在另一个操作之前，那它们必须在所有副本上以那个顺序被处理。因此，当一个副本处理一个操作时，它必须确保所有因果前驱的操作（之前发生的所有操作）已经被处理；如果前面的某个操作丢失了，后面的操作必须等待，直到前面的操作被处理完毕。