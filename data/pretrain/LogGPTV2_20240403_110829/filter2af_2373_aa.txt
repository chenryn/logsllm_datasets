本文章为翻译稿件，原内容为https://blog.talosintelligence.com/2018/10/old-dog-new-tricks-analysing-new-rtf_15.html
### 行动概述
思科Talos发现了一个新的恶意软件活动，该活动不再使用名为“Agent Tesla”或其他的木马例如“Loki信息窃取者”来窃取信息。
最初，Talos的遥测系统检测到一个十分可疑的文档，但这些文档并没有被常用病毒库所采集。然而，思科的恶意软件分析威胁情报平台Threat
Grid将未知文件识别为恶意软件。此恶意软件背后的利用者使用了著名的攻击链，并使用此方式对软件进行了修改以便防病毒解决方案无法检测到它。在这篇文章中，我们将概括更多的攻击手段，以及使用复杂软件来跟踪这类攻击的重要性。如果此类病毒未被发现，那么Agent
Tesla可以从许多重要的软件中窃取用户的登录信息，例如从Google Chrome，Mozilla Firefox，Microsoft
Outlook等。除此之外，它还可用于捕获屏幕截图，记录网络摄像头，并令被攻击主机的系统上安装其他恶意软件。
### 技术细节
在大多数情况下，攻击的第一阶段发生的方式与FormBook恶意软件活动所发生的情况类似，对此，我们在今年早些时候发过一篇博客文章，并对此进行过讨论。
之前FormBook活动背后的攻击者使用CVE-2017-0199（多个版本的Microsoft
Office中的远程执行代码漏洞）从恶意DOCX文件中下载并打开RTF文档。我们还发现了一些新的攻击被使用来分发Tesla和Loki代理以便于利用CVE-2017-11882。其中一个恶意软件分发URL的示例位于下面的屏幕截图中。
除了Tesla和Loki代理外，这个软件还分发了更多恶意代码，例如Gamarue。对于此恶意程序，  
它能够完全接管用户的机器并对用户信息进行窃取。
在Tesla代理工作的情况下，我们可以发现下载的RTF文件带有SHA256散列：`cf193637626e85b34a7ccaed9e4459b75605af46cedc95325583b879990e0e61`。
在分析文件时，防病毒扫描网站VirusTotal并没有对此文件内容进行检测。58个防病毒程序中只有两个发现其内含有可疑内容。并仅仅以“警告格式错误”来标记此RTF文件。例如：AhnLab-V3将其标记为“RTF
/ Malform-A.Gen”，而Zoner将它被标记为“RTFBadVersion”。
但是，思科的Threat Grid却显示出不同的检测内容，并将该文件标识为恶意软件。
上面的图2只显示了触发行为指标（BI）的一个子集，下面的流程树显示了高度可疑的恶意执行链。
在下图中，我们可以看到Winword.exe启动，稍后，svchost进程执行了Microsoft公式编辑器（EQNEDT32.exe）并启动一个名为“scvhost.exe”的进程。
公式编辑器是Microsoft Office用作辅助应用程序的工具，用于将数学方程式嵌入到文档中。 例如，Word使用OLE /
COM函数启动公式编辑器，它与我们在下图中看到的内容相匹配。公式编辑器启动其他可执行文件的情况非常罕见，如图所示的可执行文件。更不用说使用这样一个相似名称的可执行文件，如系统文件“svchost.exe”本身就是可疑的。
用户很容易忽略软件名称被修改的情况。
下面的Threat Grid进程时间表确认此文件的行为与典型的恶意软件相似。
您可以在上图中的第1点和第2点看到公式编辑器下载了一个名为“xyz [1]
.123”的文件，然后创建了scvhost.exe进程，该进程之后创建了自己的另一个实例[scvhost.exe(26)] （蓝色矩形框中）。
典型的命令和控制（C2）流量紧跟在第4点。至此，我们确信这是一个恶意软件。  
然而问题出现，我们系统中为何没有检测装置检测到它？它是如何绕过检测的？
### 恶意的RTF文件
作为跨平台文档交换，RTF标准是Microsoft面向开发的专有文档文件格式。
简化的标准RTF文件看起来就像在图中看到的那样。它由文本和控制字（字符串）构成。 上半部分是源代码，下半部分是此文件在Microsoft
Word中的显示方式。  
尽管RTF文件被严重混淆，我们依然能够使用rtfdump / rtfobj工具来验证结构并提取实际的对象数据有效负载。
图8显示的是该文件尝试启动Microsoft公式编辑器（类名：EQuATioN.3）
在图6中，您还可以看到攻击者正在使用\
objupdate技巧。这会强制嵌入对象在显示之前进行更新，换句话说，用户在加载之前不必单击该对象。这就是“普通”对象的情况。
但是如果强制打开文件，攻击将会立即开始。
让我们看看上面关于转换为十六进制二进制流的objdata内容。在此处可以找到更多标题详细信息。
我们可以找到FormBook帖子中描述的类似MTEF标题，但是为了避免检测，攻击者已经改变了标题的值。唯一的区别是，除了在MTEF版本字段中，actor也使用随机值填充了头字段。
MTEF版本字段需要为2或3才能使漏洞利用起作用。
在MTEF标题之后，我们有一两个字节的未知MTEF字节流标记（F1 01），其后跟一个字体标记（08 E0 7B ...）。字体标记后面的字节（B9 C3
...）看起来不像正常的字体名称，所以这是一个很好的指标，我们正在寻找一个漏洞利用。字节看起来与我们之前提到的研究中看到的非常不同，下面让我们解码它们。
这与我们之前看到的非常相似。 在图12中，您可以看到我们之前研究中的解码shellcode。
对手刚刚更改了寄存器和其他一些小部件。 在这一点上，我们已经非常确定这是CVE-2017-11882，下面让我们来证明这一点。
### PYREBOX ROCK 'N' ROLL
为了验证恶意RTF文件是否正在利用CVE-2017-11882，我们使用了由Talos开发的动态分析引擎PyREBox。该工具允许我们检测整个系统的执行并监控不同的事件，例如指令执行，内存读写，操作系统事件，还提供交互式分析功能，允许我们在任何时候检查任何模拟系统的状态。有关该工具的其他信息，请参阅有关其发布的博客文章以及Hack
in the Box 2018会议中提供的恶意软件监控脚本。
在此分析中，我们利用了影子堆栈插件，该插件与今年早些时候在EuskalHack Security Congress
III上的其他漏洞利用分析脚本（shellcode检测和堆栈旋转检测）一起发布（可用幻灯片）。此脚本监视在给定进程的上下文（在本例中为公式编辑器进程）下执行的所有调用和RET指令，并维护一个影子堆栈，用于跟踪所有有效的返回地址（每个执行的调用指令后面的地址）。
我们唯一需要做的是配置插件来监控公式编辑器进程（插件将等待它被创建），并在模拟的guest虚拟机中打开RTF文档。只要RET指令跳转到不在调用指令之前的地址，PyREBox就会停止执行系统。这种方法允许我们检测堆栈的溢出错误，这些错误会覆盖存储在堆栈中的返回地址。一旦执行停止，PyREBox就会产生一个交互式IPython
shell，它允许我们检查系统并调试和/或跟踪公式编辑器过程的执行。
PyREBox将停止在0x00411874的返回地址上执行，该地址属于CVE-2017-11882中报告的易受攻击的函数。在这种情况下，恶意软件作者决定利用此漏洞，用公式编辑器的主可执行模块中包含的地址覆盖返回地址：0x0044fd22。如果我们检查这个地址（参见图13），我们会看到它指向另一个RET指令，该指令将从堆栈中弹出另一个地址并跳转到它。影子堆栈插件将会再次检测到这种情况，并在下一步利用时停止执行。
图14显示了shellcode的第一个阶段，它在第二个RET之后执行。此shellcode将调用GlobalLock函数（0x18f36e），然后将跳转到包含shellcode第二阶段的第二个缓冲区。
shellcode的第二阶段由一系列jmp / call指令和一个解密循环组成。
此解密循环将解包shellcode的最终有效负载，最后跳转到此解码缓冲区。PyREBox允许我们在执行期间的任何时刻转储包含shellcode的内存缓冲区。有几种方法可以实现这一点，其中一种的是使用波动率框架（可通过PyREBox
shell获得）列出进程中的VAD区域并转储包含有趣代码的缓冲区。然后可以将此缓冲区导入IDA Pro以进行更深入的分析。
shellcode的最后阶段非常简单。
它利用标准技术在PEB中可用的已加载模块的链接列表中查找kernel32.dll模块，然后，解析其导出表以找到LoadLibrary和GetProcAddress函数。
通过使用这些函数，该脚本解析了几个API函数（ExpandEnvironmentStrings，URLDownloadToFileA和ShellExecute），从URL下载并执行xyz.123二进制文件，我们已经在Threat
Grid分析中看到过。shellcode以名称“scvhost.exe”启动此可执行文件，我们之前在Threat Grid报告中也看到过这个名称。
我们还看到了其他几个使用完全相同的感染链的活动，但是将Loki作为最终的有效载荷。我们在IOC部分列出了这些内容。
### Payload细节问题
如果您更喜欢上面的进程名称，让我们查看最终的有效负载文件“xyz.123”（a8ac66acd22d1e194a05c09a3dc3d98a78ebcc2914312cdd647bc209498564d8）或“scvhost.exe”。$
file xyz123.exe xyz123.exe：用于MS Windows的PE32可执行（GUI）Intel 80386 Mono /
.Net程序集将文件加载到dnSpy - 一个.NET程序集编辑器，反编译器和调试器 - 确认它是一个严重混淆的.NET可执行文件。
从类构造函数（cctor）开始执行的方法。
    .ҭъЩӂӬҀУ\u0486\u0489їҒреӱҤЫѝйҹП()
它将一个大型数组加载到内存中并对其进行解码。cctor的其余部分从数组中重构xs.dll和其他代码，并在入口点继续执行其他例程。
最后，它通过调用P.M（）方法跳转到xs.dll中。
这个很有意思，因为它向我们展示了一个众所周知的工件，它表明该程序集是用Agile.Net混淆器进行混淆的。
由于没有自定义混淆，我们可以只执行该文件，等待一段时间，然后通过Megadumper转储它，这是一个直接从内存转储.NET可执行文件的工具。这已经看起来好多了。
但是，混淆器使用H.G（）方法加密了所有字符串，我们无法看到这些字符串的内容。