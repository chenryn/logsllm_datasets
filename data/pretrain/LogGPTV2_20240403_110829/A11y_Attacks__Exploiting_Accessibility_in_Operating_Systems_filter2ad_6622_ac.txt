dialog through the accessibility library.
Some system applications in system directories are automatically
escalated to the administrative privilege at launch. On Windows,
when a process tries to load a DLL, the dynamic linker ﬁrst looks
for the DLL from the local directory where the executable resides.
Figure 7: Password Eye on the Gmail web application, accessed with
Internet Explorer 10. In Windows 8 and 8.1, this Eye is attached to
password ﬁelds not only for web applications, but also regular applica-
tions. By left-clicking the Eye, the box reveals its plaintext content.
Once malware injects malicious DLLs into the directory containing
these applications, it can obtain the administrative privilege when
the applications are run, thus bypassing UAC. An example of such
an application is sysprep, which will load Cryptbase.DLL from
the local directory. By sending synthetic clicks to Explorer.exe
and injecting a malicious Cryptbase.DLL, malware can achieve
privilege escalation.
Attack #3: stealing passwords using Password Eye and a screen-
shot. On Windows, passwords are protected in several ways. They
are not shown on the screen; and even with real user interactions,
the content in a password box cannot be copied to the clipboard.
Furthermore, as will be described in detail in Section §4.4, it is
also not possible to retrieve password content directly through the
accessibility library. However, the lack of input validation on the
password box UI component opens up a method of stealing the
plaintext of a password.
Starting with Windows 8, Microsoft introduced Password Eye as
a new UI feature to give visual feedback to users to correct a typo
in a password input box (Figure 7). This “Eye” appears when a
user provides input to a password box, and clicking it will reveal
the plaintext of the password. Unfortunately, since Password Eye
cannot distinguish hardware input from synthetic input, malware
can click it as long as UIPI permits. Again, since most applications
run at the same IL as malware, malware can send a left-click event
to reveal the content of the password dialog (Figure 7), and can
extract it from a screenshot.
4.3.2 Ubuntu Linux Desktop
Since Ubuntu does not have a built-in natural language user inter-
face, we only consider the attacks enabled by missing checks in the
OS or an application. The missing check at the OS level allows
malware to control any application and thus break the boundary
enforced by other security mechanisms (attack #4). The missing
check at the application level does not provide additional capabili-
ties beyond those already provided by the missing OS level check.
Attack #4: bypassing the security boundaries of Ubuntu. Since
neither the OS nor applications authenticate input, malware can
send synthetic input to any application in the GUI, i.e. the current
X Window display. The display here does not mean the physical
display (i.e., a monitor screen) of the device; rather, it refers to the
logical display space (e.g.,:0.0) of the X Window Server.
In this setting, the lack of security checks for input breaks two
security boundaries in Ubuntu. The ﬁrst violation is regarding user
ID (UID) boundaries. Regardless of the UID of the display service,
a launched process will run with the UID of the user who launched
it. For example, if a non-root user runs a GUI application with
sudo (e.g., sudo gparted or a GUI shell with root privileges), the
1. Invoke Speech Recognition Commander 2. Invoke msconfig.exe (run as HIGH IL) 3. Play artificial speech using text-to-speech library  Tools!	
  Page	
  Down!	
  Command	
  Prompt!	
  Launch!	
  4. Administrative Command Prompt has launched 5. Execute Stage-2 Malware by Speech (Run as HIGH IL) Type	
  D,	
  Type	
  I,	
  Type	
  R	
  Press	
  ENTER!	
  A) Before clicking Eye B) After clicking Eye 108application runs in the same display space of the non-root user
account, even though it runs as the root UID. Since AT-SPI allows
control of any application on the display, malware with a non-root
UID can send synthetic input to control other applications, even
those with root privileges.
Second, process boundaries can be bypassed by sending synthetic
input. Starting with Ubuntu 10.10, Ubuntu adopted the Yama secu-
rity module [8] to enhance security at the kernel level. In particular,
one feature in Yama prohibits a process from attaching to another
process using the ptrace system call, unless the target process is a
descendant of the caller. Thus, a process cannot attach or read/write
other processes’ memory if the target is not created by itself or
its descendants. However, malware can bypass this restriction: it
can write values or perform UI actions to change application status
through synthetic inputs or interfaces available by AT-SPI such as
settextvalue() and invokemenu().
4.3.3 iOS
iOS 6 lacks security checks at all levels. Missing input validation in
its natural language user interface, Siri, allows an attacker to abuse
its privileges to perform sensitive operations and access sensitive in-
formation (attack #5). Furthermore, missing OS-level checks allows
malware to 1) bypass sandbox restrictions to control other apps (at-
tack #6), 2) spoof the remote view mechanism to programmatically
authorize access permissions to sensitive resources (attack #7), and
3) bypass password protection (attack #8). Finally, since there are
no available checks at the application level, synthetic input from
a malicious app cannot be prevented or detected by the targeted
application.
Attack #5: bypassing passcode lock using Siri.6 iOS allows sev-
eral security-sensitive actions to be carried out through Siri even
when the device is locked with a passcode. Such actions include
making phone calls, sending SMS messages, sending emails, post-
ing messages on Twitter and Facebook, checking and modifying
the calendar, and checking contacts by name. Since there is no
input validation, any attacker who has physical access to the iOS
device can launch the attack without any knowledge of the passcode.
Attack #6: bypassing the iOS sandbox. App sandboxing [3] in
iOS enforces a strict security policy that strongly isolates an app
from others. The data and execution state of an app is protected
so that other apps cannot read or write its memory, or control its
execution (e.g., launching the app). However, the lack of OS-level
security checks on accessibility makes it possible for malware to
control other apps by sending synthesized input. With synthetic
touch, malware can perform any actions available to a user, such as
launching other apps, typing keystrokes, etc. That is, malware can
steal capabilities of other apps across the app sandbox.
Attack #7: privilege escalation with remote view. In addition
to app sandboxing, iOS protects its security sensitive operations
with the remote view mechanism [4]. Protected operations include
sending email, posting on Twitter or Facebook, and sending SMS.
Remote view works as follows: when an app tries to access any
protected operation, the underlying service (which is a diﬀerent
process) pops up a UI window to seek user consent. For example, if
an app wants to send an email, it invokes a remote function call to
the email service, which would then pop up a conﬁrmation window.
6 We note that this attack on Siri was not originally discovered by
us. The attack has been publicly known since September 2013 [11],
but we include this in the paper due to the importance of its security
implications on built-in AT.
Figure 8: Screenshot of passcode and password input in iOS. For pass-
code (left), typed numbers can be identiﬁed by color diﬀerences on the
keypad. For the password (right), iOS always shows the last character
to give visual feedback to the user.
The email message can only be sent after the user clicks the “Send”
button in the pop-up window.
Remote view is considered an eﬀective defense mechanism to
prevent misuse of sensitive operations. However, the lack of input
validation in iOS allows malware to send synthetic touches to spoof
user input to remote view and execute these privileged operations.
Attack #8: bypassing password protection on iOS. Another pro-
tection mechanism in iOS is passwords. This is utilized in two
system apps: the lock screen and the App Store.
The lock screen prevents any unauthorized access to the device
and is applied not only to UI events, but also to security data such
as KeyChain and encrypted ﬁles. Moreover, once the screen is
locked, all touch events are blocked; thus malware is no longer able
to manipulate apps other than the lock screen.
The App Store asks for an Apple ID and password for each
purchase. Although malware can generate “clicks” to initiate the
purchase, without knowing the password, it is not possible to ﬁnish
the transaction.
Unfortunately, since iOS always displays the last character of a
passcode/password in plaintext (Figure 8) and background screen-
shots can be taken through the private API call createScreenIOSur
face in UIWindow class, it is possible to steal the user’s passcode
and password. With a stolen password, since both the lock screen
and the App Store accept synthesized input, malware can program-
matically unlock the device and make malicious transactions.
4.3.4 Android
The Android platform has the most complete input validation among
the four evaluated platforms. First, Touchless Control [27], a natural
language user interface for the Moto X, utilizes voice authentication:
the user is required to register his/her voice with Touchless Control
at ﬁrst boot; the app then constantly monitors microphone input
for the ﬁxed authentication phrase “OK Google Now” from the
user. Once the command is captured, it checks whether the phrase
matches the voice signature extracted from the registered phrase;
if so, it then launches the Google Now application to execute a
voice command. Nonetheless, like other non-challenge-response-
based authentication, this voice authentication is vulnerable to replay
attacks (#9).
Second, as discussed in Section §4.2, Android requires explicit
user consent to acquire accessibility capabilities. However, its pro-
tection is incomplete. Speciﬁcally, Android has no runtime security
check for AT. Once an app is allowed to be an AT, it can leverage the
accessibility library to create a new inter-process communication
(IPC) channel that is not protected by the ordinary Android permis-
sion system (#10). As a result, a malicious AT can easily achieve the
same eﬀect as capability leakage attacks [7, 9, 13, 16, 34] and infor-
mation leakage attacks [18, 36]. Moreover, unlike UIPI, Android’s
109can programmatically enable developer mode (e.g., by sending 7
synthetic clicks) which can put a device at risk for further infection.
4.4 Vulnerabilities in Output Validation
Table 3 summarizes the evaluation results of each platform compared
against our output reference model in Figure 4. iOS does not support
alternative output, so its result is omitted in this section.
Platform Reading of
UI Structure
Windows
Ubuntu
UIPI
None
N/A
None
iOS
Android
Password Protection
Yes
Yes*
N/A
Settings*
Figure 9: Workﬂow of the attack on the Moto X’s Touchless Control.
Malware in the background can record a user’s voice, and replay it to
bypass voice authentication.
OS level access control on accessibility does not protect system
apps. In particular, we found that our malware can change system
settings through AT, which oﬀers us many powerful capabilities.
The only missing check in Android is at the application level.
Similar to the iOS case, we did not ﬁnd new capabilities beyond
what is enabled due to inconsistent OS-level checks.
Attack #9: bypass Touchless Control’s voice authentication. Frag-
ile authentication for AT leads to a vulnerability in Touchless Control
on the Moto X. In particular, voice authentication can be bypassed
by a replay attack shown in Figure 9. First, an attacker can build
malware as a background service that constantly monitors sound
from the microphone. As the phrase “OK Google Now” is the only
authentication phrase, the user is likely to repeat it frequently. The
malware can easily record the authentication phrase. Once recorded,
the malware can play the recorded phrase through the device speaker
to activate Touchless Control. Since Touchless Control accepts self-
played sound from the speaker to the microphone, it subsequently
launches Google Now. After this, the malware can play arbitrary
commands using the default TTS library for Google Now. Since
there is no further authentication for the command phrase, the mal-
ware can utilize a variety of commands to make phone calls, send
SMS, send email, set alarms, and launch applications.
Attack #10: bypassing Android sandboxing and more. Sand-
boxing in Android [1] provides isolation between apps to protect
memory and ﬁlesystem access, and prohibits an app from interfering
with the execution of other apps. Furthermore, its permission system
restricts an app’s access to sensitive resources.
However, once an app is activated as an AT, there are no further
restrictions. A malicious AT can then read UI structure (including
location, type, text, etc.) of the whole system and deliver user actions
to any UI element, such as the click of a button, a scroll up or down,
a cut/copy/paste of text, a change of focus, and expand/dismiss of
UI. Therefore, malware can control other apps as if it is the user.
Malware can abuse the permissions of other apps, e.g., even without
network permission, our malware can control the Gmail application
to exﬁltrate stolen data.
In addition, malware can change system settings such as user-
conﬁgurable settings, and install/uninstall apps. Moreover, malware
Table 3: Status of output validation on each platform. * means the
check enforces an inconsistent security policy.
Across all platforms, only Windows enforces an OS-level check
(UIPI) for output. However, since UIPI does not have any protection
among applications in the same IL, Windows suﬀers from the same
UI-level attacks described below.
Reading UI state of other applications. All platforms except iOS
allow an AT to access UI structures. The library provides not only
the metadata for the UI such as type of element, location, and size,
but also the content of the UI element. Hence, a malicious AT can
monitor other applications in a ﬁne-grained manner. For example,
malware can detect the current state of the target application using
1) available UI structures, 2) UI events such as change of focus,
movement of window, change of contents, and 3) user interaction
events. With these capabilities, malware can spy on every action a
user takes, as well as maintain an accurate status of an application.
All three platforms (Windows, Ubuntu, and Android) protect the
plaintext content of a password in a password dialog box by default.
However, in Ubuntu, AT-SPI fails to block all paths for retrieving
the plaintext of password (#11). Android can be conﬁgured to allow
reading keystrokes on password dialog boxes; this can be enabled
by malware implemented as an AT (as mentioned in #10).
Implementation of attacks. For extracting passwords in Ubuntu
(attack #11), we implemented proof-of-concept malware that looks
for authentication windows, obtains the plaintext, and prints out the
plaintext on the console using AT-SPI. For attack #12, we imple-
mented malware that enables the speaking of passwords via acces-
sibility services and registers itself as the TTS subsystem for the
accessibility service. In this twofold manner, malware can receive
and transmit the contents of a password to an attacker.
4.4.1 Windows
With UIPI, Windows is the only platform where the OS applies
access control on the reading of UI structures. Although UIPI
prohibits accessing the structures of an application that has higher
IL than the caller, access on the same or lower IL is still permitted.
The application level output check exists for password boxes by
default, which disallows 1) obtaining the password via WM_GETTEXT
or ValuePattern in UI Automation, and 2) copying the password
via "WM_COPY"or by generating a Ctrl-C input event. Therefore,
malware cannot steal passwords through the accessibility library.
4.4.2 Ubuntu Linux Desktop
In Ubuntu, the application level check for passwords exists, but its
implementation (in ATK) is inconsistent with the UI (in GTK).
Attack #11: stealing sudoer passwords from authentication di-
alogs. On Ubuntu, we found a password stealing vulnerability using
OK,	
  Google	
  Now!	
  1. Record authentication phrase in background OK,	
  Google	
  Now!	
  2. Play authentication phrase when the user is away. Call	
  Alice!	
  3. Command Touchless Control with Text-to-Speech API 110Figure 10: Administrator authentication dialog of GNOME on Ubuntu
13.10. It asks for the password of the current user to gain root permis-
sions.