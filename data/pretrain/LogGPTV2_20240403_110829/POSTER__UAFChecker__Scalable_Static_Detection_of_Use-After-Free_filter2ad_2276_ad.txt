high performance overhead and cannot analyze large-scale
programs. Clause et al. [14] presents a dynamic technique for
detecting invalid memory access. Their approach taints both
the objects and the corresponding pointer using the same taint
mark. The taint marks are propagated and checked every time
a pointer is referenced. If the taint marks of the object and the
pointer differ, then the illegal access is reported. The approach
is able to work on binary code but requires hardware support
to achieve an efﬁcient taint analysis.
Although dynamic analyses achieve a high detection accu-
racy and has few false alarms, the method requires inserting
dynamic runtime checks and has a high runtime overhead and
a high memory overhead. In addition, it is difﬁcult to generate
input that can execute vulnerable paths, which leads to low
code coverage in dynamic analyses.
Static analyses do not suffer from the above limitations.
However, there are very few studies on static analyses for
use-after-free vulnerability detection. UAFChecker [1] uses
classic static analysis techniques, including taint analysis and
symbolic execution, to detect use-after-free vulnerabilities in
C/C++ code. This paper does not discuss the performance
overhead of symbolic execution and taint analysis, and this
method is not suitable for binary code. Tac [31] is a machine
learning-guided static use-after-free vulnerability detection
framework. It learns the correlations between program fea-
tures and use-after-free vulnerability-related aliases by using
a support vector machine and exploits this knowledge to
improve the precision of the alias analysis. Nevertheless,
the approach is not yet sound and requires a large number
of marked training samples. The most important limitation
of the above methods is that they can only analyze the
open-source programs. However, the source code for a large
number of applications is unavailable.
The closest approach to ours is GUEB [16], which uses
static analysis to detect use-after-free vulnerabilities in binary
code. The solution uses a dedicated value set analysis to track
heap operations and address transfers. Then, it exploits these
results to statically identify use-after-free vulnerabilities and
extract the subgraph for each vulnerability. The main differ-
ence between this solution and ours is that GUEB uses a
naive in-lining technique for inter-procedural analysis. The
functions that are called many times need to be analyzed
repeatedly, which results in a high overhead for analyz-
ing large programs. UAFDetector uses function summaries
instead of an in-lining technique to improve the efﬁciency and
scalability of vulnerability detection.
B. USE-AFTER-FREE MITIGATION
Instead of detecting use-after-free vulnerabilities, some stud-
ies focus on how to prevent the exploitation of vulnerabilities.
Cling [32], Diehard [33] and Dieharder [34] are safe mem-
ory allocators that are designed to make the exploitation of
use-after-free vulnerabilities harder. These allocators restrict
memory reuse by using more address space or randomizing
VOLUME 8, 2020
78723
K. Zhu et al.: Scalable Static Detection of Use-After-Free Vulnerabilities in Binary Code
the memory allocation. These solutions can effectively pre-
vent exploitation of use-after-free vulnerabilities and have
acceptable overhead. However, attackers can bypass these
mitigations by using ‘‘heap spraying’’ or ‘‘heap fengshui’’-
like attacks.
DangNULL [4], FreeSentry [35] and DangSan [36] pre-
vent the exploitation of use-after-free vulnerabilities by using
pointer invalidation. These solutions insert runtime checks
during compilation to track per-object pointers and invalidate
the pointers once the object is freed. When the dangling
pointer is referenced, pointer invalidation crashes the pro-
gram to prevent the attacker from exploiting the vulnerability.
Despite a number of optimizations, the approach still has a
high performance and memory overhead and is not widely
applied in practice.
Overwriting virtual
table pointers is the most widely
used technique to exploit use-after-free vulnerabilities.
VTGuard [37], SafeDispatch [38] and VTV [39] protect
against this exploitation technique to mitigate use-after-free
vulnerabilities. These mitigations have low performance
overhead because they only focus on protecting the vir-
tual tables. However, these approaches are ineffective when
attackers target other pointers rather than virtual
table
pointers.
Many vulnerabilities are caused by incorrect memory man-
agement by programmers using C/C++. Therefore, some
efforts have been made on safe languages to avoid known
memory corruption vulnerabilities by modifying language
constructs. These languages use garbage collection instead
of explicitly freeing memory to reduce the harm of dangling
pointers. There are a number of safe languages [40], [41] that
are as close to the C/C++ language as possible. Although
they try to maintain compatibility with C/C++ programs,
it still requires a lot of effort to translate existing projects in
these languages.
VIII. CONCLUSION
Use-after-free vulnerabilities caused by dangling pointers are
an increasingly serious threat to computer systems. While a
number of mitigations are proposed to address this problem,
few of them are sufﬁciently practical for large-scale pro-
grams. In this paper, we propose a scalable static approach
that combines CFG construction, alias analysis, function
summaries and pointer tracking to detect use-after-free vul-
nerabilities in binary code. Our approach uses the function
summaries technique instead of the in-lining technique for the
inter-procedural analysis and avoids repeated analysis prob-
lem in existing approach. We have implemented a prototype
called UAFDetector to detect use-after-free vulnerabilities in
binary code and evaluated it using standard benchmarks (JTS)
and real-world programs.
The experimental results show that our approach can
effectively ﬁnd use-after-free vulnerabilities. UAFDetector
achieves a low false negative rate (2.39%) and a zero
false positive rate in the JTS. Moreover, despite some
false positives and false negatives, UAFDetector ﬁnds most
known vulnerabilities and one unknown vulnerability in the
real-world programs provided. Compared with the existing
static analysis solution GUEB for detecting use-after-free
vulnerabilities, our approach can reduce the redundant over-
head caused by repeated analysis. In our experiments,
the number of functions to be analyzed in UAFDetector
is approximately 70.8% less than that in GUEB. There-
fore, our approach has a lower overhead and better scalabil-
ity for detecting use-after-free vulnerabilities in large-scale
programs.
REFERENCES
[1] J. Ye, C. Zhang, and X. Han, ‘‘Poster: Uafchecker: Scalable static detection
of use-after-free vulnerabilities,’’ in Proc. ACM SIGSAC Conf. Comput.
Commun. Secur., Nov. 2014, pp. 1529–1531.
[2] National Vulnerability Database. Accessed: Apr. 10, 2019. [Online].
Available: https://nvd.nist.gov/
[3] M. Conti, S. Crane, and L. Davi, ‘‘Losing control: On the effectiveness of
control-ﬂow integrity under stack attacks,’’ in Proc. 22nd ACM SIGSAC
Conf. Comput. Commun. Secur., Oct. 2015, pp. 952–963.
[4] B. Lee, C. Song, Y. Jang, T. Wang, T. Kim, L. Lu, and W. Lee, ‘‘Preventing
Use-after-free with dangling pointers nulliﬁcation,’’ in Proc. Netw. Distrib.
Syst. Secur. Symp., San Diego, CA, USA, Feb. 2015, PP. 1–15.
[5] F.
J. Serna.
(2012). The Info Leak Era on Software Exploita-
tion. Black Hat, NY, USA. Accessed: Apr. 10, 2019.
[Online].
Available: https://docs.huihoo.com/blackhat/usa-2012/BH_US_12_Serna
_Leak_Era_Slides.pdf
[6] W. Xu, J. Li, and J. Shu, ‘‘From collision to exploitation: Unleashing use-
after-free vulnerabilities in linux kernel,’’ in Proc. 22nd ACM SIGSAC
Conf. Comput. Commun. Secur., Oct. 2015, pp. 425–441.
[7] J. Caballero, G. Grieco, M. Marron, and A. Nappa, ‘‘Undangle: Early
detection of dangling pointers in use-after-free and double-free vulnerabil-
ities,’’ in Proc. Int. Symp. Softw. Test. Anal. (ISSTA), 2012, pp. 133–143.
kvm Guest→Host
(2011).
Virtunoid:
A
[8] N.
Elhage.
Escalation
Privi-
lege
Exploit. Black Hat, NY, USA. Accessed:
Apr. 10, 2019. [Online]. Available: http://media.blackhat.com/bh-us-
11/Elhage/BH_US_11_Elhage_Virtunoid_WP.pdf
[9] X. Fan, Y. Sui, X. Liao, and J. Xue, ‘‘Boosting the precision of virtual call
integrity protection with partial pointer analysis for C++,’’ in Proc. 26th
ACM SIGSOFT Int. Symp. Softw. Test. Anal. (ISSTA), 2017, pp. 329–340.
(2010). Hack of Google, Adobe Conducted Through
[Online]. Available:
Zero-Day IE Flaw. Accessed: Apr. 10, 2019.
https://www.wired.com/2010/01/hack-of-adob/
[10] K. Zetter.
[11] R. Hastings and B. Joyce, ‘‘Purify: Fast detection of memory leaks and
access errors,’’ in Proc. Winter Usenix Conf., Jan. 1992, pp. 125–136.
[12] N. Nethercote and J. Seward, ‘‘Valgrind: A framework for heavyweight
dynamic binary instrumentation,’’ ACM SIGPLAN Notices, vol. 42, no. 6,
pp. 89–100, 2007.
[13] K. Serebryany, D. Bruening, and A. Potapenko, ‘‘AddressSanitizer: A fast
address sanity checker,’’ in Proc. USENIX Annu. Tech. Conf., Jun. 2012,
pp. 309–318.
[14] J. Clause, I. Doudalis, A. Orso, and M. Prvulovic, ‘‘Effective memory
protection using dynamic tainting,’’ in Proc. 22nd IEEE/ACM Int. Conf.
Automated Softw. Eng. (ASE), Nov. 2007, pp. 284–292.
[15] F. Kirchner, N. Kosmatov, V. Prevosto, J. Signoles, and B. Yakobowski,
‘‘Frama-C: A software analysis perspective,’’ Formal Aspects Comput.,
vol. 27, no. 3, pp. 573–609, May 2015.
[16] J. Feist, L. Mounier, and M.-L. Potet, ‘‘Statically detecting use after
free on binary code,’’ J. Comput. Virol. Hacking Techn., vol. 10, no. 3,
pp. 211–217, Aug. 2014.
[17] T. Boland and P. E. Black, ‘‘Juliet 1.1 C/C++ and Java test suite,’’
Computer, vol. 45, no. 10, pp. 88–90, 2012.
[18] Interactive DisAssembler. Accessed: Apr. 10, 2019. [Online]. Available:
https://www.hex-rays.com/
[19] BinNavi. Accessed: Apr. 10, 2019. [Online]. Available: https://github.com/
google/binnavi
[20] K. Zhu, Y. Lu, and H. Hang, ‘‘Construction approach for control ﬂow graph
from binaries using hybrid analysis,’’ J. ZheJiang Univ. (Eng. Sci.), vol. 53,
no. 5, pp. 829–836, 2019.
78724
VOLUME 8, 2020
K. Zhu et al.: Scalable Static Detection of Use-After-Free Vulnerabilities in Binary Code
[21] B. M. Padmanabhuni and H. B. K. Tan, ‘‘Auditing buffer overﬂow vulner-
abilities using hybrid static–dynamic analysis,’’ IET Softw., vol. 10, no. 2,
pp. 54–61, 2016.
[22] L. Xu, F. Sun, and Z. Su,
‘‘Constructing precise control ﬂow
graphs
from binaries,’’ Univ. California, Davis, CA, USA,
Tech. Rep., 2009. [Online]. Available: https://pdfs.semanticscollar.org/
8a80/f0d173ec7420478e4b96a8264e21e0dafac0.pdf
[23] A. V. Aho, M. S. Lam, and R. Sethi, ‘‘Machine-independent optimiza-
tions,’’ in Compilers: Principles, Techniques, and Tools, 2nd ed. Boston,
MA, USA: Addison-Wesley, 2006, pp. 601–607.
[24] J. Feist, ‘‘Finding the needle in the heap: Combining binary analysis
techniques to trigger use-after-free,’’ Ph.D. dissertation, Dept. Cryptogr.
Secur., Univ. Grenoble Alpes., Grenoble, France, 2017.
[25] S. Alrabaee, L. Wang, and M. Debbabi, ‘‘BinGold: Towards robust binary
analysis by extracting the semantics of binary code as semantic ﬂow graphs
(SFGs),’’ Digit. Invest., vol. 18, pp. S11–S22, Aug. 2016.
[26] S. Alrabaee, P. Shirani, L. Wang, and M. Debbabi, ‘‘SIGMA: A semantic
integrated graph matching approach for identifying reused functions in
binary code,’’ Digit. Invest., vol. 12, pp. S61–S71, Mar. 2015.
[27] W. Wang, Y. Li, X. Wang, J. Liu, and X. Zhang, ‘‘Detecting Android
malicious apps and categorizing benign apps with ensemble of classiﬁers,’’
Future Gener. Comput. Syst., vol. 78, pp. 987–994, Jan. 2018.
[28] S. Alrabaee, P. Shirani, and L. Wang, ‘‘FOSSIL: A resilient and efﬁcient
system for identifying FOSS functions in Malware binaries,’’ ACM Trans.
Privacy Secur., vol. 21, no. 2, pp. 1–34, 2018.
[29] W. Wang, M. Zhao, Z. Gao, G. Xu, H. Xian, Y. Li, and X. Zhang, ‘‘Con-
structing features for detecting Android malicious applications: Issues,
taxonomy and directions,’’ IEEE Access, vol. 7, pp. 67602–67631, 2019.
[30] S. Nagarakatte, M. M. K. Martin, and J. Zhao, ‘‘CETS: Compiler enforced
temporal safety for C,’’ ACM SIGPLAN Notices, vol. 45, no. 8, pp. 31–40,
2010.
[31] H. Yan, Y. Sui, S. Chen, and J. Xue, ‘‘Machine-Learning-Guided typestate
analysis for static Use-After-Free detection,’’ in Proc. 33rd Annu. Comput.
Secur. Appl. Conf., Dec. 2017, pp. 42–54.
[32] P. Akritidis, ‘‘Cling: A memory allocator to mitigate dangling pointers,’’
in Proc. USENIX Secur. Symp., Aug. 2010, pp. 177–192.
[33] E. D. Berger and B. G. Zorn, ‘‘DieHard: Probabilistic memory safety for
unsafe languages,’’ ACM SIGPLAN Notices, vol. 41, no. 6, pp. 158–168,
Jun. 2006.
[34] G. Novark and E. D. Berger, ‘‘DieHarder: Securing the heap,’’ in Proc.
17th ACM Conf. Comput. Commun. Secur. (CCS), 2010, pp. 177–192.
[35] Y. Younan, ‘‘FreeSentry: Protecting against Use-After-Free vulnerabilities
due to dangling pointers,’’ in Proc. Netw. Distrib. Syst. Secur. Symp.,
San Diego, CA, USA, Feb. 2015, pp. 1–15.
[36] E. van der Kouwe, V. Nigade, and C. Giuffrida, ‘‘DangSan: Scalable Use-
after-free detection,’’ in Proc. 12th Eur. Conf. Comput. Syst. - EuroSys,
2017, pp. 405–419.
8. Black Hat USA. Accessed: Apr.
10,
in Windows
[Online]. Available:
M_Miller/BH_US_12_Miller_Exploit_Mitigation_Slides.pdf
[37] K. Johnson and M. Miller. (2012). Exploit Mitigation Improvements
2019.
https://media.blackhat.com/bh-us-12/Brieﬁngs/
[38] D. Jang, Z. Tatlock, and S. Lerner, ‘‘SAFEDISPATCH: Securing C++
virtual calls from memory corruption attacks,’’ in Proc. Netw. Distrib. Syst.
Secur. Symp., San Diego, CA, USA, Feb. 2014, pp. 1–15.
[39] C. Tice, T. Roeder, and P. Collingbourne, ‘‘Enforcing forward-edge
control-ﬂow integrity in GCC & LLVM,’’ in Proc. 23rd USENIX Secur.
Symp. USENIX Secur., Aug. 2014, pp. 941–955.
C/C++ Users J., vol. 23, no. 1, pp. 112–139, 2005.
[40] D. Grossman, M. Hicks, and T. Jim, ‘‘Cyclone: A type-safe dialect of C,’’
[41] G. C. Necula, S. McPeak, and W. Weimer, ‘‘CCured: Type-safe retroﬁtting
of legacy code,’’ ACM SIGPLAN Notices, vol. 37, no. 1, pp. 128–139,
Jan. 2002.
KAILONG ZHU was born in China, in 1991.
He received the B.Sc. and M.Sc. degrees in
cyberspace security from the National University
of Defense Technology, Hefei, China, in 2014 and
2017, respectively, where he is currently pursuing
the Ph.D. degree. His areas of research interests are
in information security and program veriﬁcation.
YULIANG LU was born in China,
in 1964.
He received the B.Sc. (Hons.) and M.Sc. degrees
in computer application from Southeast Univer-
sity, China, in 1985 and 1988, respectively. He is
currently a Professor with the National University
of Defense Technology, Hefei, China. His areas of
research interests are in computer application and
information security.
HUI HUANG was born in China,
in 1987.
He received the M.Sc. and Ph.D. degrees in infor-
mation security from the National University of
Defense Technology, Hefei, China, in 2012 and
2015, respectively. His areas of research inter-
ests are in information security and program
veriﬁcation.
VOLUME 8, 2020
78725