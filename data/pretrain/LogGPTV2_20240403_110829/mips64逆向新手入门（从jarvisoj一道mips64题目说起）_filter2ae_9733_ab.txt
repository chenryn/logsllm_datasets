    b* 0x00000001200112f0
    b* 0x0000000120022504
我们从后开始看，看到函数0x0000000120022504执行时，其输入参数是（1，0x1200b97d0, 0xc），查看内存，是输出Wrong
Flag的函数。a1已经指向WrongFlag字符串了。
    Breakpoint 618, 0x0000000120022504 in ?? ()
    (gdb) i r
    ...
                        a0               a1               a2               a3
     R4   0000000000000001 00000001200b97d0 000000000000000c fffffffffbad2a84 
    (gdb) x/s $a1
    0x1200b97d0:    "Wrong Flag!nWB, Please input your flag: "
用同样的方法一路往前看在进入0x12000d6b0时，a0已经是WrongFlag字符串，而进入 0x12001f110 时，a0指向用户输入的字符串，说明
0x12001f110 是关键函数，用于判断用户输入是否正确的。
## 定位关键
在0x12001f110函数中逐行调试（ni指令），返回到了 0x120003ac0
(sub_120003AC0)，有这么一段指令，这是调用0x12001f110的地方，`beq $v0, $v1`是将输入长度和0x10进行比较
    .text:0000000120003B10                 bal     sub_12001F110  # a0为用户输入
    .text:0000000120003B14                 ld      $a0, -0x7F58($gp)
    .text:0000000120003B18                 li      $v1, 0x10  # sub_12001f110+110时返回到这里
    .text:0000000120003B1C                 beq     $v0, $v1, key  # v0=len(input),v1=0x10
    .text:0000000120003B20                 ld      $t9, -0x7F40($gp)
如果比较不相等，则一路调用sub_12000D6B0（根据上面的回溯分析，调用时a0已经是指向WrongFlag字符串了），所以
**输入长度是16个字符**
确定输入长度后，可以使用 `qemu-mips64 -strace -g 9999 ./mips64   83/16 = 5
    19%16 = 3   83%16 = 3
所以原来输入（1234…)，要对应修改为5234..(1改成5，3改成3）
修改输入后重新执行程序，原来不执行的0x12000415C也执行了，第二次进入函数 sub_120004EB0，函数返回后在0x12000416C进行了比较
    Breakpoint 622, 0x000000012000416c in ?? ()
    (gdb) i fl
    fpu type: double-precision
    reg size: 64 bits
    ...
    f0:  0x4010000042100000 flt: 36                dbl: 4.0000009844079614      
    f1:  0x404cc00042880000 flt: 68                dbl: 57.500007931143045      
    f2:  0x0000000000000000 flt: 0                 dbl: 0
同理
    36/16 = 2   68/16 = 4
    36%16 = 4   68%16 = 4
所以原来输入（5234…)，要对应修改为5434…(2改成4，4改成4）
在修改了前4字节后，在原来 0x120003BA8 设置断点，就是4个关键函数返回值之和与0.5比较的地方，此时我们可以看到f0已经变成1
    Breakpoint 623, 0x0000000120003ba8 in ?? ()
    (gdb) i fl
    fpu type: double-precision
    reg size: 64 bits
    cond    : 1 2 3 4 5 6 7
    cause   :
    mask    :
    flags   :
    rounding: nearest
    flush   : no
    nan2008 : no
    abs2008 : no
    f0:  0x401800003f800000 flt: 1                 dbl: 6.0000009462237358      
    f1:  0x404cc0003f000000 flt: 0.5               dbl: 57.500007510185242
这时候在IDA中查找函数 sub_120004EB0
的交叉引用，函数被调用了8次，上述提及的4个关键函数都各调用了2次，说明规律是类似的。只要在这8个地方附近设置断点，用同样的规律修改输入，即可让4个关键函数之和为4。
输入正确时，程序提示正确
## 总结
  1. mips64 目前缺乏分析工具（此题使用jeb和retdec都无法反编译），IDA对字符串的交叉引用也无法工作，让逆向难度加大。
  2. 此题根据较为原始的调试方法也可以定位出read和write等常见函数，也可以考虑使用Rizzo等工具恢复符号。
  3. 原本此程序的算法可以在整数域上进行，偏偏在浮点数域上编写，使得程序中使用了大量浮点数计算和转换，这些都增加了逆向难度。
  4. 注意mips64的分支延时等与x86不同的特性，才能更好的迁移x86逆向知识到mips逆向中。
## 附录
由于mips指令和x86指令差异较大，需要查阅网上mips指令的相关说明，结合动态调试理解。
  * 
  * 
  * 
  * 
  * 
  * 