void hammingdistance(void) {
int tmp = 0;
for (int i = 0; i < K; i++)
tmp += popcount32(a[i] ^ b[i]);
OUTPUT_hd = tmp;
}
Figure 3: CBMC-GC program for computing the
Hamming distance between two bit arrays.
in some scenarios it is desirable to consider an asymmet-
ric situation, where only one party holds the function to be
evaluated, while the second party holds the respective data
on which the function should be applied. For example, this
is relevant once algorithms must be evaluated which are con-
sidered the intellectual property of one of the parties. In this
case, the parties can jointly evaluate the algorithm without
revealing the algorithm as well as the private input.
Two diﬀerent approaches to this problem were reported in
the literature. The ﬁrst solution is based on the simple ob-
servation that code and data can be interchanged by the use
of universal programs (or interpreters). More precisely, in-
stead of evaluating the desired circuit directly, both parties
run a universal circuit that gets as input both a description
of the desired program (again in terms of a circuit), held
held by one party, and the input, held by the other. Given
that the size of the program to be executed is known to both
parties, the garbled circuit technique can be applied to the
universal circuit in a straightforward manner. The approach
using universal circuits has been described in detail in [25].
Given a secret program consisting of n Boolean gates, the
asymptotic complexity of the universal circuit construction
is O(n log2(n)). A second solution to this problem has been
proposed in [23]. Encrypting the circuit directly, while si-
multaneously hiding the circuit topology, they achieve an
asymptotic complexity of O(n). However, in order to garble
the entire circuit a large number of public key operations is
necessary. Since the size of the circuits can become rather
large, the required computational complexity is likely to ex-
ceed typical computing resources (unfortunately, no imple-
mentation is presented in [23] to experimentally verify this
assumption).
Solving the problem of STC with private functions is sur-
prisingly simple with CBMC-GC. In fact, one can write a
simple interpreter in C, which interprets a binary circuit of
a given size. In the sequel we describe two such interpreters
with diﬀerent properties.
The ﬁrst interpreter is depicted in Figure 4. The inter-
preter takes as input a list of gates, where each gate is
encoded as follows: Two bits are used to represent the bi-
nary operation (AND, OR, XOR and NOT) to be performed
#define CIRCUIT_SIZE 50
#define INPUT_SIZE 32
void interpreter_1() {
_Bool INPUT_A_a[INPUT_SIZE];
_Bool INPUT_B_b[INPUT_SIZE];
_Bool INPUT_A_circuit_ops[2 * CIRCUIT_SIZE];
short INPUT_A_circuit_left[CIRCUIT_SIZE];
short INPUT_A_circuit_right[CIRCUIT_SIZE];
_Bool results[CIRCUIT_SIZE + 2 * INPUT_SIZE];
int i;
for (i = 0; i < INPUT_SIZE, i++)
results[i] = INPUT_A_a[i];
for (i = INPUT_SIZE; i < 2 * INPUT_SIZE; i++)
results[i] = INPUT_B_b[i];
for (i = 2 * INPUT_SIZE; i < CIRCUIT_SIZE; i++)
results[i] = 0;
for (i = 0; i < CIRCUIT_SIZE; i++) {
short left_index = INPUT_A_circuit_left[i];
short right_index = INPUT_A_circuit_right[i];
_Bool left_value = results[left_index];
_Bool right_value = results[right_index];
_Bool tmp = 0;
if (INPUT_A_circuit_ops[2 * i] == 0) {
if (INPUT_A_circuit_ops[2 * i + 1] == 0)
tmp = left_value & right_value; // AND
else
tmp = left_value | right_value; // OR
} else {
if (INPUT_A_circuit_ops[2 * i + 1] == 1)
tmp = !left_value; // NOT
else
tmp = left_value ^ right_value; // XOR
}
results[2 * INPUT_SIZE - 1 + i] = tmp;
}
_Bool OUTPUT_result =
results[2 * INPUT_SIZE - 1 + CIRCUIT_SIZE];
}
Figure 4: CBMC-GC code for interpreting arbitrary
circuits.
while two additional integer values represent the indices of
the operands. The result of each gate evaluation is stored
in a separate array results. Now, evaluating a gate is done
in three steps: First the opcodes and operands are fetched
(observe that all operands originate from the parties inputs
or previous gate evaluations, and thus can be loaded from
the array results). Next, the operation is performed. In
a ﬁnal step the result is written to results. Once all gates
are evaluated, the interpreter outputs the result of the com-
putation. For simplicity of presentation we assume that the
circuit always outputs a single bit and that the result is com-
puted by the last gate in the list. However, more complex
scenarios with multiple output bits can be implemented with
ease as well. The design of the interpreter allows arbitrary
programs to be interpreted, at the cost of an asymptotic
complexity of O(n2).
Using C as programming language one can easily develop
customized versions of interpreters. For example, in case it
is known that interpreting the circuit needs only memory
signiﬁcantly smaller than n, a diﬀerent interpreter, depicted
in Figure 5, can be utilized. This interpreter makes use of
a small constant scratch memory, holding the intermediate
results (just like a standard RAM). This memory initially
780#define MEMORY_SIZE 3
#define INPUT_SIZE 32
#define CIRCUIT_SIZE 100
_Bool mem[INPUT_SIZE + MEMORY_SIZE];
typedef struct {
_Bool opcode1;
_Bool opcode2;
short leftOperand;
short rightOperand;
short target;
} operation;
operation INPUT_A_ops[CIRCUIT_SIZE];
_Bool INPUT_B_mem[INPUT_SIZE];
void interpreter_2() {
unsigned i = 0;
_Bool opcode1 = 0, opcode2 = 0, result = 0;
short lOp = 0, rOp = 0, target = 0;
_Bool lOpValue = 0, rOpValue = 0;
for (i = 0; i < INPUT_SIZE; i++)
mem[i] = INPUT_B_mem[i];
for (i = INPUT_SIZE; i < INPUT_SIZE + MEMORY_SIZE; i++)
mem[i] = 0;
for (i = 0; i < CIRCUIT_SIZE; i++) {
opcode1 = INPUT_A_ops[i].opcode1;
opcode2 = INPUT_A_ops[i].opcode2;
lOpValue = mem[INPUT_A_ops[i].leftOperand];
rOpValue = mem[INPUT_A_ops[i].rightOperand];
target = INPUT_A_ops[i].target;
if (opcode1) {
if (opcode2)
result = lOpValue & rOpValue;
else
result = lOpValue | rOpValue;
} else {
if (opcode2)
result = lOpValue ^ rOpValue;
else
result = !lOpValue;
}
mem[target] = result;
}
_Bool OUTPUTmem[MEMORY_SIZE];
for (i = 0; i < MEMORY_SIZE; i++)
OUTPUTmem[i] = mem[INPUT_SIZE + i];
}
Figure 5: CBMC-GC code for interpreting circuits with bounded memory.
holds the parties’ input values and is later updated to store
intermediate results occuring during the computation. To
implement the interpreter it now suﬃces to iterate over all
gates, evaluating one gate at a time: reading the required
inputs from scratch memory, performing the binary opera-
tion and writing the result back to a speciﬁc location in the
constant size memory.
For both approaches, the interpreter must be tailored to-
wards the size of the program (circuit) to be executed: once
the number of input bits and the number of gates of the
input program are known, the constants in Figures 4 and 5
can be set accordingly. Subsequently, CBMC-GC can com-
pile the interpreter into a circuit, which can be used in STC
to evaluate any circuit of the given size (with the constraint
that the size of the memory can be set to a small constant,
independent of the circuit size, for the second interpreter).
In fact, CBMC-GC distills a universal circuit out of the ﬁrst
interpreter. Note that the input to both interpreters is itself
a circuit, which can again be constructed out of a C program
using CBMC-GC.
Table 1 again depicts the experimental results; when inter-
preting 50 gates, the ﬁrst interpreter is compiled to a circuit
with approximately 1.2 million gates, among them 366, 600
gates other than XOR. Note that the size of the compiled
interpreter scales with O(n2), due to the way of handling
arrays and the representation of the circuit. The second in-
terpreter uses a small ﬁxed memory: e.g. to interpret circuits
with 50 gates which require a memory of 35 bits, CBMC-
GC produces a circuit with about 600, 000 gates, of which
196, 366 are non-XOR gates.
6. CONCLUSIONS & FUTURE WORK
This paper demonstrated that secure two-party computa-
tion can be realized for ANSI C programs. We believe that
this is an important step to put secure computation to wide
practical use. Our experiments show that the tool chain
has good practical performance. We expect that the sepa-
ration of concerns between garbled circuit evaluation and C
compilation will enable the programming language and the
compiler communities to further improve the performance of
practical secure computation. Our work therefore facilitates
and encourages a closer interaction between programming
languages and STC.
To realize the C compiler, our paper reused the CBMC
tool chain originally developed for software model checking.
This has the added advantage of a tight coupling between
the tools for STC and veriﬁcation of code correctness. In
future work, we plan to further investigate this relationship
as to achieve both functional correctness and security with
a single tool, and to directly verify the circuits. To support
diﬀerent programming languages one might also consider
LLVM5 bytecode as source language for circuit synthesis.
In future releases of CBMC-GC we will provide full sup-
port for pointer arithmetic and ﬂoating point arithmetic as
discussed in Section 3.2.6. Moreover, we will also provide
support for the integration of CBMC-GC with other STC
implementations such as [28] and will deﬁne interfaces that
enable secure computations in the context of larger pro-
grams.
7. ACKNOWLEDGMENTS
This work was supported in part by the Austrian National
Research Network S11403-N23 (RiSE) of the Austrian Sci-
ence Fund (FWF), by the Vienna Science and Technology
Fund (WWTF) grant PROSEED, and by CASED.
8. REFERENCES
[1] VIFF, the Virtual Ideal Functionality Framework.
http://viff.dk/.
[2] T. Ball, R. Majumdar, T. Millstein, and S. K.
Rajamani. Automatic Predicate Abstraction of C
Programs. In Proceedings of the ACM SIGPLAN 2001
Conference on Programming Language Design and
Implementation, PLDI ’01, pages 203–213. ACM
Press, 2001.
5http://llvm.org/
781[3] M. Barni, P. Failla, V. Kolesnikov, R. Lazzeretti,
[15] R. Cramer, I. Damg˚ard, and J. B. Nielsen. Multiparty
A.-R. Sadeghi, and T. Schneider. Secure Evaluation of
Private Linear Branching Programs with Medical
Applications. In Proceedings of the 14th European
Conference on Research in Computer Security,
ESORICS’09, pages 424–439. Springer, 2009.
Computation from Threshold Homomorphic
Encryption. In Proceedings of the International
Conference on the Theory and Application of
Cryptographic Techniques: Advances in Cryptology,
EUROCRYPT ’01, pages 280–299, 2001.
[4] A. Ben-David, N. Nisan, and B. Pinkas. FairplayMP:
A System for Secure Multi-Party Computation. In
Proceedings of the 15th ACM Conference on Computer
and Communications Security, CCS ’08, pages 17–21.
ACM, 2008.
[16] Z. Erkin, M. Franz, J. Guajardo, S. Katzenbeisser,
I. Lagendijk, and T. Toft. Privacy-Preserving Face
Recognition. In Proceedings of the 9th International
Symposium on Privacy Enhancing Technologies,
PETS ’09, pages 235–253. Springer, 2009.
[5] D. Beyer, T. A. Henzinger, R. Jhala, and
[17] M. K. Ganai, A. Gupta, and P. Ashar. DiVer:
R. Majumdar. The software model checker Blast:
Applications to software engineering. International
Journal on Software Tools for Technology Transfer,
9(5-6):505–525, October 2007.
[6] A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu.
Symbolic Model Checking without BDDs. In
Proceedings of the 5th International Conference on
Tools and Algorithms for Construction and Analysis of
Systems, TACAS ’99, pages 193–207. Springer, 1999.
[7] A. Biere, M. Heule, H. van Maaren, and T. Walsh,
editors. Handbook of Satisﬁability, volume 185 of
Frontiers in Artiﬁcial Intelligence and Applications.
IOS Press, 2009.
[8] D. Bogdanov, S. Laur, and J. Willemson. Sharemind:
A Framework for Fast Privacy-Preserving
Computations. In Proceedings of the 13th European
Symposium on Research in Computer Security:
Computer Security, ESORICS ’08, pages 192–206.
Springer, 2008.
[9] P. Bogetoft, I. Damg˚ard, T. Jakobsen, K. Nielsen,
J. Pagter, and T. Toft. A Practical Implementation of
Secure Auctions Based on Multiparty Integer
Computation. In Proceedings of the 10th International
Conference on Financial Cryptography and Data
Security, FC ’06, pages 142–147. Springer, 2006.
[10] E. Clarke, D. Kroening, and F. Lerda. A Tool for
Checking ANSI-C Programs. In Proceedings of the
10th International Conference on Tools and
Algorithms for the Construction and Analysis of
Systems, TACAS ’04, pages 168–176. Springer, 2004.
[11] E. Clarke, D. Kroening, and K. Yorav. Behavioral
Consistency of C and Verilog Programs using
Bounded Model Checking. In Proceedings of the 40th
annual Design Automation Conference, DAC ’03,
pages 368–371. ACM, 2003.
[12] E. Clarke, D. Kroening, and K. Yorav. Behavioral
Consistency of C and Verilog Programs using
Bounded Model Checking. Technical Report
CMU-CS-03-126, Carnegie Mellon University, School
of Computer Science, 2003.
[13] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and
H. Veith. Counterexample-Guided Abstraction
Reﬁnement. In Proceedings of the 12th International
Conference on Computer Aided Veriﬁcation, CAV ’00,
pages 154–169. Springer, 2000.
[14] P. Cousot, R. Cousot, J. Feret, L. Mauborgne,
A. Min´e, D. Monniaux, and X. Rival. The ASTR´EE
analyzer. In Proceedings of the 14th European
Conference on Programming Languages and Systems,
ESOP ’05, pages 21–30. Springer, 2005.
SAT-Based Model Checking Platform for Verifying
Large Scale Systems. In Proceedings of the 11th
International Conference on Tools and Algorithms for
the Construction and Analysis of Systems, TACAS’05,
pages 575–580. Springer, 2005.
[18] B. Goethals, S. Laur, H. Lipmaa, and T. Mielik¨ainen.
On Private Scalar Product Computation for
Privacy-Preserving Data Mining. In Proceedings of the
7th International Conference on Information Security
and Cryptology, ICISC’04, pages 104–120. Springer,
2004.
[19] W. Henecka, S. K¨ogl, A.-R. Sadeghi, T. Schneider, and
I. Wehrenberg. TASTY: Tool for Automating Secure
Two-partY computations. In Proceedings of the 17th
ACM conference on Computer and communications
security, CCS ’10, pages 451–462. ACM, 2010.
[20] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster
Secure Two-Party Computation Using Garbled
Circuits. In Proceedings of the 20th USENIX Security
Symposium, USENIX ’11, 2011.
[21] G. Jagannathan and R. N. Wright. Privacy-Preserving
Distributed k-Means Clustering over Arbitrarily
Partitioned Data. In Proceedings of the eleventh ACM
SIGKDD International Conference on Knowledge
Discovery in Data Mining, KDD ’05, pages 593–599.
ACM, 2005.
[22] A. Karatsuba and Y. Ofman. Multiplication of
Many-Digital Numbers by Automatic Computers. In
Doklady Akad. Nauk SSSR, Vol. 145, Translation in
Physics-Doklady, 7 (1963), pp. 595–596, 1962.
[23] J. Katz and L. Malka. Constant-Round Private
Function Evaluation with Linear Complexity. In
Proceedings of the 17th International Conference on
the Theory and Application of Cryptology and
Information Security, ASIACRYPT ’11, pages
556–571. Springer, 2011.
[24] V. Kolesnikov, A.-R. Sadeghi, and T. Schneider.
Improved Garbled Circuit Building Blocks and
Applications to Auctions and Computing Minima. In
Proceedings of the 8th International Conference on
Cryptology and Network Security, CANS ’09, pages
1–20. Springer, 2009.
[25] V. Kolesnikov and T. Schneider. A Practical Universal
Circuit Construction and Secure Evaluation of Private
Functions. In Proceedings of the 12th International
Conference on Financial Cryptography and Data
Security, FC ’08, pages 83–97. Springer, 2008.
[26] V. Kolesnikov and T. Schneider. Improved Garbled
Circuit: Free XOR Gates and Applications. In
Proceedings of the 35th International Colloquium on
782Automata, Languages and Programming, Part II,
ICALP ’08, pages 486–498. Springer, 2008.
[27] Y. Lindell and B. Pinkas. A Proof of Security of Yao’s
Protocol for Two-Party Computation. Journal of
Cryptology, 22:161–188, April 2009.
[28] L. Malka. VMCrypt: Modular Software Architecture
for Scalable Secure Computation. In Proceedings of the
18th ACM Conference on Computer and
Communications Security, CCS ’11, pages 715–724.
ACM, 2011.
[29] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay
— A Secure Two-Party Computation System. In
Proceedings of the 13th Conference on USENIX
Security Symposium, SSYM’04, pages 20–20. USENIX
Association, 2004.
[30] B. Pinkas, T. Schneider, N. P. Smart, and S. C.
Williams. Secure Two-Party Computation Is Practical.
In Proceedings of the 15th International Conference on
the Theory and Application of Cryptology and
Information Security: Advances in Cryptology,
ASIACRYPT ’09, pages 250–267. Springer, 2009.
[31] A. C.-C. Yao. Protocols for Secure Computations
(Extended Abstract). In Proceedings of the 23rd
Annual Symposium on Foundations of Computer
Science, FOCS ’82, pages 160–164. IEEE Computer
Society, 1982.
[32] A. C.-C. Yao. How to Generate and Exchange Secrets.
In Proceedings of the 27th Annual Symposium on
Foundations of Computer Science, FOCS ’86, pages
162–167. IEEE Computer Society, 1986.
783