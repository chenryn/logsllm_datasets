# 【技术分享】“Selfie”：利用DynamoRIO实现自修改代码自动脱壳的神器
|
##### 译文声明
本文是翻译文章，文章来源：breakingmalware
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
**翻译：**[ **shan66**](http://bobao.360.cn/member/contribute?uid=2522399780)
**稿费：160RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿**
在本文中，我们将隆重向大家介绍一款脱壳神器：“Selfie”。有了它，大家就不用为了在基于自修改代码技术加壳的恶意软件中寻找OEP发愁了，因为在大部分情况下，Selfie都能自动完成这项任务。该工具现在已经开源了，大家可以从下列地址下载：。
**引言**
对于恶意软件研究人员来说，我们经常会遇到经过加壳、加密或混淆处理的代码。恶意软件通常都会试图以这种方式来逃避安全检测。然而，为了研究这些恶意软件，我们需要摆脱加壳软件的干扰，找出恶意软件运行的起始点，即所谓的原始入口点（OEP）。不幸的是，脱壳工作通常是我们研究人员最耗时、最复杂的一项工作。
当我们遇到自修改代码的恶意软件时，脱壳工作就会格外的冗长乏味。自修改代码是加壳软件常用的技术，它通过增加额外的安全层来提高软件的复杂性。对于使用了自我修改代码来说，加壳后的恶意软件会对自身进行覆盖。在脱壳的时候，需要利用动态分配的内存脱壳，恢复其原始代码和映像，然后将脱壳后的代码拷回来。最令安全研究人员沮丧的事情，莫过于以手动方式来检索采用了自修改代码的恶意软件的OEP了。
由于这个缘故，我们开发了“Selfie”。对于Selfie来说，即使这些恶意软件利用自修改代码技术进行了加壳保护，它照样能够自动找出恶意软件的OEP。Selfie工具本身是基于DynamoRIO的，后者是一个动态代码插桩（Dynamic
Binary Instrumentation，DBI）框架。
要注意的是，对于那些使用不太常见的方法实现的自修改代码，Selfie目前尚无法处理，例如，使用返回指令到达OEP或不改变IAT大小的自修改代码等。
**手动方式为自修改代码脱壳**
下面，我们详细介绍如何通过手工方式为自修改代码脱壳的具体步骤，为此，我们以Trojan Shylock为例进行演示。
**第一步：观察PE文件**
下面是我们得到的原始信息，我们将从这里开始我们的脱壳之旅。
图1：shylock的特征数据
图2：注意高亮显示的部分
**第2步：分析第一次动态内存分配**
我们从第1步所示（即地址0x00404920）的入口点开始分析。
这将我们带到了地址0x4040F8处。在那里，我们可以看到一个对VirtualAlloc函数的调用，该调用动态分配了5E200字节的内存，其权限为PAGE_EXECUTE_READWRITE。
图3：分配虚拟内存
图4：virtualalloc的参数
一旦成功地分配了内存，代码就会把经过加壳的进程映像复制到动态分配的内存中。
图5：EAX指向分配的内存的基址，ECX是计数器。
**第3步：分析第二次动态内存分配**
一旦完成复制，加载器就会把执行权限转移给前面分配的内存中的代码。
我们可以看到，这里进行了另外一次内存分配 ，它只有PAGE_READWRITE权限。注意，这里的VirtualAlloc是从第2步中分配的动态内存中调用的。
图6：第二个VirtualAlloc
我们又看到一个复制循环（0x00574210），在这里，原始的那个加壳后的恶意软件（别忘了，现在它被映射到动态存储器中）含有一个嵌入式加密PE。下面的代码会把这个加密的嵌入式PE复制到第二次动态分配的内存中：
图7：拷贝嵌入的加密PE的复制循环代码
图8：原始映像基地址（左）含有加密的嵌入PE（右）。
图9：被复制到动态内存中的加密PE
图10：解密后从上面复制的PE
**第4步：分析第三次动态内存分配**
现在分析第三次内存分配。这次，加载程序将解密的PE复制到分配好的内存中：
图11：第三个VirtualAlloc
图12：第三个拷贝循环用于复制解密的PE
当复制例程成功结束后，将进入下面的代码。简而言之，它会重置原始映像的基地址。唉，我们知道这就是自修改代码。
图13：原始的进程映像空间（0x00400000）被0填充
图14：最后，得到一个充满0的进程映象空间
**第5步：分析倒数第二个感染步骤**
图15：加载器将解密的EXE复制到已归零的进程映像空间。
脱壳后的恶意软件（Shylock）：
图16：0x0040000就是该恶意软件元数据（图1）中的映像基地址
接下来，加载器将使用LoadLibrary/GetProcAddress重建导入地址表（IAT）。
图17：LoadLibrary
图18：GetProcAddress
**第6步：终极目的：调用OEP**
图19：间接调用OEP（0x00403780）
**Selfie：实现自修改代码的自动脱壳**
Selfie使用的是动态插桩技术，允许我们在应用程序运行时为其添加或修改代码。这真是研究人员的福音，因为它允许我们在恶意软件运行过程中对其进行监视和深入分析。我们可以认为，对恶意软件运用插桩技术后，我们的代码就能够完全控制恶意软件。