(cid:94)(cid:286)(cid:272)(cid:437)(cid:396)(cid:286)(cid:3)(cid:17)(cid:381)(cid:381)(cid:410)
(cid:60)(cid:286)(cid:455)(cid:3)(cid:349)(cid:400)(cid:3)(cid:286)(cid:454)(cid:410)(cid:396)(cid:258)(cid:272)(cid:410)(cid:286)(cid:282)(cid:3)(cid:271)(cid:455)
(cid:100)(cid:396)(cid:437)(cid:400)(cid:410)(cid:286)(cid:282)(cid:3)(cid:17)(cid:381)(cid:381)(cid:410)
(cid:24)(cid:17)
(cid:57)(cid:72)(cid:81)(cid:71)(cid:82)(cid:85)(cid:3)(cid:44)(cid:39)
(cid:51)(cid:85)(cid:82)(cid:71)(cid:88)(cid:70)(cid:87)(cid:3)(cid:44)(cid:39)
(cid:38)(cid:79)(cid:68)(cid:86)(cid:86)(cid:3)(cid:44)(cid:39)
(cid:54)(cid:88)(cid:69)(cid:38)(cid:79)(cid:68)(cid:86)(cid:86) (cid:44)(cid:39)
(cid:54)(cid:72)(cid:85)(cid:76)(cid:68)(cid:79)(cid:3)(cid:49)(cid:82)(cid:17)
(cid:38)(cid:75)(cid:68)(cid:79)(cid:79)(cid:72)(cid:81)(cid:74)(cid:72)
(cid:43)(cid:72)(cid:79)(cid:83)(cid:72)(cid:85)
(cid:38)(cid:76)(cid:83)(cid:75)(cid:72)(cid:85)(cid:87)(cid:72)(cid:91)(cid:87)
(cid:83)(cid:79)(cid:68)(cid:76)(cid:81)(cid:87)(cid:72)(cid:91)(cid:87)
(cid:367)(cid:349)(cid:271)(cid:38)(cid:100)(cid:24)(cid:47)
(cid:104)(cid:94)(cid:17) (cid:24)(cid:286)(cid:410)(cid:286)(cid:272)(cid:410)(cid:349)(cid:381)(cid:374)
(cid:367)(cid:349)(cid:271)(cid:104)(cid:94)(cid:17)
(cid:104)(cid:94)(cid:17)(cid:3)(cid:87)(cid:381)(cid:396)(cid:410)(cid:3)
(cid:894)(cid:90)(cid:381)(cid:381)(cid:410)(cid:3)(cid:44)(cid:437)(cid:271)(cid:895)
(cid:104)(cid:94)(cid:17)(cid:882)(cid:87)(cid:104)(cid:38)
(cid:24)(cid:286)(cid:448)(cid:349)(cid:272)(cid:286)
(cid:38)(cid:100)(cid:24)(cid:47)
(cid:87)(cid:62)(cid:882)(cid:87)(cid:104)(cid:38)(cid:3)(cid:4)(cid:437)(cid:410)(cid:346) (cid:18)(cid:349)(cid:396)(cid:272)(cid:437)(cid:349)(cid:410)
(cid:87)(cid:62)(cid:882)(cid:87)(cid:104)(cid:38)
Fig. 1. DeviceVeil design overview.
DeviceVeil authenticates a legitimate USB device with PUF,
and then exposes it to the OS, as pre-OS authentication. The
pre-OS authentication can be implemented in two options.
1) Hosting the cryptographic key: the key created by PUF
is stored in a veriﬁer on a host PC that is used to create
ciphertext from plaintext on demand. The drawback is
that the key is disclosed if the veriﬁer is compromised.
2) Database for plaintext and ciphertext: The veriﬁer does
not have the cryptographic key created by PUF, but it
has a database of plaintext and ciphertext pairs created
by the key. This prevents key disclosure but requires the
database to be created in advance.
We use option (2) to avoid storing a long term key, and
to restrict
the misuse of a challenge-repose pair exposed
via e.g., USB bus snifﬁng (each pair is used once). Also,
if the challenge-repose pairs are different on each PC, the
compromise of a PC with its database has limited impact on
the device’s authentication (e.g., the device can be safely used
in other PCs). If the hypervisor selects option (1) hosting
cryptographic/PUF key, it must select a different encryption
key, generated by PUF circuits of a device. The different
encryption key generates different ciphertext at each time on
each PC and can limit USB bus snifﬁng attacks. However, keys
generated by PUFs for all PCs need to be tested for correctness
because PUFs are sensitive to noise.
A. Pseudo-LFSR PUF (PL-PUF)
DeviceVeil customizes Pseudo-LFSR PUF (PL-PUF [24]) to
avoid shortcomings of current PUF technologies. PL-PUF is a
delay-based PUF but outputs multiple and variable responses.
The structure is based on the Linear Feedback Shift Register
(LFSR). PL-PUF composes larger combinational logic than
normal delay-based PUFs, and it efﬁciently outputs multiple
bits in parallel used for variable ID. However, the size of the
PL-PUF authentication circuit is reasonably small compared
to memory-based PUFs. Furthermore, the challenge-response
mapping of PL-PUF is variable, depending on the active
duration of the circuit, i.e., a single PL-PUF behaves as if
it has multiple PUF cores.
306
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:52:47 UTC from IEEE Xplore.  Restrictions apply. 
128 127

126

102

101 100


99

Dout
[128]
Dout
[127]
Dout
[126]
Dout
[102]
Dout
[101]
Dout
[99]
1

Dout
[1]
)HHGEDFNSRO\QRPLDO
128
x
+
126
x
+
101
x
+
99
x
+
1
Din
Dinit SEL
Dout
LFSR_core
Fig. 2. The structure of PL-PUF authentication circuit (128 bits). It consists
of 128 inverters and 3 XOR gates and creates a feedback polynomial.
Figure 2 shows the structure of our 128-bit PL-PUF with
the primitive feedback polynomial. The core logic is not a
register but an inverter, and thus our PL-PUF is composed of
a single combinational circuit. The output will oscillate since
the output of the last core (Dout(1)) is fed back to the top-most
core. The output value depends on the speed of the feedback
signal, which is signiﬁcantly affected by the device variation.
As a result, the output is device-dependent. PL-PUF realizes a
challenge-response pair as shown in Figure 2. The challenge
is a 128-bit initial value given to the core logic (Dinit), and
the response is a 128-bit output from the core logic (Dout)
after a certain time of feedback.
PL-PUF creates a multiple bit response that is prone to
burst errors. DeviceVeil uses the Reed-Solomon (RS) error
correction for the fuzzy extractor to deal with burst errors.
For authentication, DeviceVeil uses a temporal database of
plaintext and ciphertext pairs generated by using AES (the
AES key is created by PL-PUF to avoid the leakage of the
key). The plaintext and ciphertext pairs are created with the
AES key in advance by the administrator for each individual
device. Also, each challenge-response pair should be used only
once to prevent USB bus snifﬁng attacks.
B. Hypervisor with USB-PUF authentication
DeviceVeil is designed on top of BitVisor [56], a type-
1 thin hypervisor. BitVisor is based on a para-pass-through
architecture and does not prevent hardware interrupts from
the USB ports to the OS. Therefore, DeviceVeil disguises a
dummy device to the OS until the USB-PUF authentication
is completed in the isolated hypervisor environment. The
isolated environment also hosts a database with device records
used for USB device detection and challenge-response pairs
(i.e., ciphertext and plaintext pairs) used for PUF authen-
tication. The database is also encrypted by a TPM-sealed
key, and an inside attacker (e.g., the user of the machine)
cannot access this key; the key and the plaintext (decrypted)
database are available only to DeviceVeil’s hypervisor, and
inaccessible from the OS.
We enforce PUF authentication by default. To support non-
PUF USB devices as an exception, an administrator can con-
ﬁgure DeviceVeil to use only vendor ID, product ID, class ID,
and serial number. This weak authentication can co-exist dur-
ing the transition, but we strongly advise against relying on it.
C. Hypervisor with TPM and Secure Boot
To avoid bypassing DeviceVeil’s protection, we encrypt
the partition of the OS and seal
the encryption key in
TPM NVRAM, accessible only to DeviceVeil (loaded via
trusted boot). Thus,
loading
the unmodiﬁed DeviceVeil binary. Note that although the
encryption key stays in RAM, only the hypervisor has access
to it (i.e., making it unavailable to the OS, or OS-resident
memory extraction tools).
the OS cannot boot without
Even if trusted boot measures platform integrity and the disk
is encrypted by a TPM-protected key, a reinstallation attack
is still possible (i.e., kexec). DeviceVeil compensates this
problem with UEFI secure boot, by disallowing unauthorized
kernels. An administrator can customize a secure boot to spec-
ify legitimate kernels with no kexec support (allowing updates
for properly signed kernels). However, the hypervisor must
be updated with the active participation of the administrator
(to set up the trusted boot to extract/reseal the encryption
key in TPM). We assume our thin hypervisor will require
updates very infrequently (unlike an OS kernel). Note that,
the possibility of an I/O virtualization attack is restricted by
the fact that DeviceVeil is loaded ﬁrst, and it occupies CPU
virtualization, and thus other kernels cannot override it.
D. Deployability
DeviceVeil mostly uses security mechanisms included in
many commodity PCs (e.g., TPM, secure boot, and virtual-
ization) to help deployability. Although not all consumer PCs
come with these components, but enterprise IT admins can buy
PCs with appropriate support. In addition, DeviceVeil requires
new hardware “PUF” (similar to several other smart USB
solutions such as [7], [67]). For the novel PUF-authentication
mechanism, we limit the PUF cost to be reasonable (approx.
under 1 USD), to include a broad set of USB devices.
The cost of maintenance depends on the usage model. To
allow administrators to remotely manage the allowed list of
devices (i.e., DeviceVeil’s protected database) on a client PC,
DeviceVeil must mandate strong authentication of admin ma-
chines/accounts (e.g., via remote attestation). This extra effort
is necessary for scalability if devices are added/removed fre-
quently. If the authorized devices are changed infrequently, the
simple per-PC/device deployment may also be reasonable. Our
prototype implementation follows this usage scenario. Note
that current DeviceVeil allows users to update the kernel with
a proper signature, and thus makes updates easy to deploy.
VI. IMPLEMENTATION
DeviceVeil’s hypervisor is implemented on BitVisor [56]
with DeviceDisEnabler [62] (parts of TPM management),
and USB-PUF authentication is implemented on Zuiho [87]
which is a platform for PUF security evaluation. Newly added
and deleted code for DeviceVeil are about 6,000 and 500
LOC respectively. The main part of the added code is PL-
PUF authentication. Note that, DeviceVeil’s TCB also contain
libFTDI (unmodiﬁed: 55,000 LOC).
307
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:52:47 UTC from IEEE Xplore.  Restrictions apply. 
RESOURCES USED BY PL-PUF CIRCUITS. RESOURCES ARE SLICE OF
FPGA, LOOK UP TABLE (LUT), FLIP FLOP (FF), BLOCK RAM (BRAM)
AND OPERATION TIME (μSEC).
TABLE I
PL-PUF
RS Enc
RS Dec
AES
Total
Slice
130
181
7,990
2,774
12,774
LUT
260
333
15,086
5,405
21,459
FF
256
236
2,323
812
6,282
BRAM
0
2
1
0
7
μsec
0.33
1.37
23.17
0.58(Enc)/1.08(Dec)
25.44(Enc)/25.94(Dec)
A. Zuiho PL-PUF Authentication Circuits
The Zuiho board comes with an FPGA chip, Spartan-3A
DPS3400A, and our PL-PUF authentication circuits are im-
plemented on it. The circuits consist of PL-PUF, RS encoding,
RS decoding, AES encryption/decryption, etc. The circuits
for PL-PUF are based on [24], and the RS encoding and
decoding utilize MATLAB Communication Toolbox and HDL
Coder. For AES encryption/decryption, we utilize the open
source Verilog code offered by the Cryptographic Hardware