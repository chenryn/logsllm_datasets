and S. Qadeer, Eds., vol. 6806.
Springer, Jul. 2011, pp. 171–
177, snowbird, Utah. [Online]. Available: http://www.cs.stanford.edu/
∼barrett/pubs/BCD+11.pdf
[25] K. D. Cooper and K. Kennedy, “Interprocedural side-effect analysis in
linear time,” in Proceedings of the ACM SIGPLAN 1988 Conference
on Programming Language Design and Implementation, ser. PLDI ’88.
New York, NY, USA: ACM, 1988, pp. 57–66. [Online]. Available:
http://doi.acm.org/10.1145/53990.53996
[26] “Oyente: An analysis tool for smart contracts,” 2018, [Online; accessed
[Online]. Available: https://github.com/melonproject/
[27] “Etherscan,” [Online; accessed 31-May-2019].
[Online]. Available:
31-May-2019].
oyente
https://etherscan.io/
[28] “Zeus evaluation,” 2018, [Online; accessed 31-May-2019]. [Online].
[29] [Online; accessed 31-May-2019]. [Online]. Available: https://github.
Available: https://goo.gl/kFNHy3
com/ethereum/solidity/issues/6835
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 
1691
[30] [Online; accessed 31-May-2019].
[Online]. Available: https://blog.
peckshield.com/2018/05/21/ceoAnyone/
[31] T. Chen, X. Li, X. Luo, and X. Zhang, “Under-optimized smart contracts
devour your money,” in 2017 IEEE 24th International Conference on
Software Analysis, Evolution and Reengineering (SANER), Feb 2017,
pp. 442–446.
[32] E. Albert, P. Gordillo, A. Rubio, and I. Sergey, “GASTAP: A
gas analyzer for smart contracts,” CoRR, vol. abs/1811.10403, 2018.
[Online]. Available: http://arxiv.org/abs/1811.10403
[33] S. Grossman, I. Abraham, G. Golan-Gueta, Y. Michalevsky, N. Rinetzky,
M. Sagiv, and Y. Zohar, “Online detection of effectively callback free
objects with applications to smart contracts,” Proc. ACM Program.
Lang., vol. 2, no. POPL, pp. 48:1–48:28, Dec. 2017.
[Online].
Available: http://doi.acm.org/10.1145/3158136
[34] C. Liu, H. Liu, Z. Cao, Z. Chen, B. Chen, and B. Roscoe, “Reguard:
Finding reentrancy bugs in smart contracts,” in 2018 IEEE/ACM 40th
International Conference on Software Engineering: Companion (ICSE-
Companion), May 2018, pp. 65–68.
[35] C. Reitwiessner, “Formal veriﬁcation for solidity contracts.” 2015,
[Online; accessed 31-May-2019]. [Online]. Available: https://forum.
ethereum.org/discussion/3779/formal-veriﬁcation-for-solidity-contracts
[36] Y. Hirai, “Deﬁning the ethereum virtual machine for interactive theorem
provers,” in Financial Cryptography and Data Security, M. Brenner,
K. Rohloff, J. Bonneau, A. Miller, P. Y. Ryan, V. Teague, A. Bracciali,
M. Sala, F. Pintore, and M. Jakobsson, Eds. Cham: Springer Interna-
tional Publishing, 2017, pp. 520–535.
[37] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Gollamudi,
G. Gonthier, N. Kobeissi, N. Kulatova, A. Rastogi, T. Sibut-Pinote,
N. Swamy, and S. Zanella-B´eguelin, “Formal veriﬁcation of smart
contracts: Short paper,” in Proceedings of the 2016 ACM Workshop
on Programming Languages and Analysis for Security, ser. PLAS ’16.
New York, NY, USA: ACM, 2016, pp. 91–96. [Online]. Available:
http://doi.acm.org/10.1145/2993600.2993611
[38] I. Grishchenko, M. Maffei, and C. Schneidewind, “A semantic frame-
work for the security analysis of ethereum smart contracts,” in Principles
of Security and Trust, L. Bauer and R. K¨usters, Eds. Cham: Springer
International Publishing, 2018, pp. 243–269.
[39] S. Amani, M. B´egel, M. Bortin, and M. Staples, “Towards verifying
ethereum smart contract bytecode in isabelle/hol,” in Proceedings of the
7th ACM SIGPLAN International Conference on Certiﬁed Programs
and Proofs, ser. CPP 2018. New York, NY, USA: ACM, 2018, pp.
66–77. [Online]. Available: http://doi.acm.org/10.1145/3167084
[40] S. K. Lahiri, S. Chen, Y. Wang, and I. Dillig, “Formal speciﬁcation
and veriﬁcation of smart contracts for azure blockchain,” CoRR, vol.
abs/1812.08829, 2018. [Online]. Available: http://arxiv.org/abs/1812.
08829
[41] B. Jiang, Y. Liu, and W. K. Chan, “Contractfuzzer: fuzzing smart
contracts for vulnerability detection,” in ASE. ACM, 2018, pp. 259–
269.
[42] A. Gurﬁnkel, T. Kahsai, A. Komuravelli, and J. A. Navas, “The seahorn
veriﬁcation framework,” in Computer Aided Veriﬁcation, D. Kroening
and C. S. P˘as˘areanu, Eds. Cham: Springer International Publishing,
2015, pp. 343–361.
[43] M. Bravenboer and Y. Smaragdakis, “Strictly declarative speciﬁcation
of sophisticated points-to analyses,” in Proceedings of
the 24th
ACM SIGPLAN Conference on Object Oriented Programming Systems
Languages and Applications,
New York,
NY, USA: ACM, 2009, pp. 243–262.
[Online]. Available: http:
//doi.acm.org/10.1145/1640089.1640108
ser. OOPSLA ’09.
[44] T. Nipkow, M. Wenzel, and L. C. Paulson, Isabelle/HOL: A Proof
Assistant for Higher-order Logic. Berlin, Heidelberg: Springer-Verlag,
2002.
[45] N. Swamy, C. Hritcu, C. Keller, A. Rastogi, A. Delignat-Lavaud,
S. Forest, K. Bhargavan, C. Fournet, P.-Y. Strub, M. Kohlweiss, J.-K.
Zinzindohou´e, and S. Zanella-B´eguelin, “Dependent types and multi-
monadic effects in F*,” in 43rd ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages (POPL). ACM, Jan. 2016,
pp. 256–270. [Online]. Available: https://www.fstar-lang.org/papers/
mumon/
[46] E. Hildenbrandt, M. Saxena, N. Rodrigues, X. Zhu, P. Daian, D. Guth,
B. Moore, D. Park, Y. Zhang, A. Stefanescu, and G. Rosu, “Kevm: A
complete formal semantics of the ethereum virtual machine,” in 2018
IEEE 31st Computer Security Foundations Symposium (CSF), July 2018,
pp. 204–217.
[47] G. Ros¸u and T. F. S¸erb˘anut¸˘a, “An overview of the K semantic frame-
work,” Journal of Logic and Algebraic Programming, vol. 79, no. 6, pp.
397–434, 2010.
[48] “Openzeppelin: Safemath,” 2018,
[Online; accessed 31-May-2019].
[Online]. Available: https://github.com/OpenZeppelin/openzeppelin-
solidity/blob/master/contracts/math/SafeMath.sol
[49] B. Blanchet, P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min´e,
D. Monniaux, and X. Rival, “A static analyzer for large safety-critical
software,” in Proceedings of the ACM SIGPLAN 2003 Conference on
Programming Language Design and Implementation, ser. PLDI ’03.
New York, NY, USA: ACM, 2003, pp. 196–207. [Online]. Available:
http://doi.acm.org/10.1145/781131.781153
[50] P. Cousot, R. Cousot,
J. Feret, L. Mauborgne, A. Min´e, and
X. Rival, “Why does astr´ee scale up?” Formal Methods in System
Design, vol. 35, no. 3, pp. 229–264, 2009.
[Online]. Available:
https://doi.org/10.1007/s10703-009-0089-6
[51] “Sparrow,” [Online; accessed 31-May-2019].
https://github.com/ropas/sparrow
[Online]. Available:
[52] F. Kirchner, N. Kosmatov, V. Prevosto, J. Signoles, and B. Yakobowski,
“Frama-c: A software analysis perspective,” Formal Asp. Comput.,
vol. 27, no. 3, pp. 573–609, 2015.
[Online]. Available: https:
//doi.org/10.1007/s00165-014-0326-7
[53] “Frama-c: a source-code analyzer of c software.” [Online; accessed
31-May-2019]. [Online]. Available: https://frama-c.com/index.html
[54] X. Wang, H. Chen, Z. Jia, N. Zeldovich, and M. F. Kaashoek,
“Improving integer security for systems with kint,” in Proceedings
of
the 10th USENIX Conference on Operating Systems Design
and Implementation, ser. OSDI’12. Berkeley, CA, USA: USENIX
Association, 2012, pp. 163–177. [Online]. Available: http://dl.acm.org/
citation.cfm?id=2387880.2387897
[55] T. Wang, T. Wei, Z. Lin, and W. Zou, “Intscope: Automatically
detecting integer overﬂow vulnerability in X86 binary using symbolic
execution,” in Proceedings of
the Network and Distributed System
Security Symposium, NDSS 2009, San Diego, California, USA, 8th
February - 11th February 2009. The Internet Society, 2009. [On-
line]. Available: https://www.ndss-symposium.org/ndss2009/intscope-
automatically-detecting-integer-overﬂow-vulnerability-in-x86-binary-
using-symbolic-execution/
[56] D. Molnar, X. C. Li, and D. A. Wagner, “Dynamic test generation to
ﬁnd integer bugs in x86 binary linux programs,” in Proceedings of
the 18th Conference on USENIX Security Symposium, ser. SSYM’09.
Berkeley, CA, USA: USENIX Association, 2009, pp. 67–82. [Online].
Available: http://dl.acm.org/citation.cfm?id=1855768.1855773
[57] Y. Moy, N. Bjørner, and D. Sielaff, “Modular bug-ﬁnding for integer
overﬂows in the large: Sound, efﬁcient, bit-precise static analysis,” Tech.
Rep. MSR-TR-2009–57, 2009.
[58] S. Sidiroglou-Douskos, E. Lahtinen, N. Rittenhouse, P. Piselli, F. Long,
D. Kim, and M. Rinard, “Targeted automatic integer overﬂow discovery
using goal-directed conditional branch enforcement,” in Proceedings of
the Twentieth International Conference on Architectural Support for
Programming Languages and Operating Systems, ser. ASPLOS ’15.
New York, NY, USA: ACM, 2015, pp. 473–486. [Online]. Available:
http://doi.acm.org/10.1145/2694344.2694389
[59] P. Cousot and R. Cousot, “Abstract interpretation: A uniﬁed lattice
model for static analysis of programs by construction or approximation
of ﬁxpoints,” in Proceedings of
the 4th ACM SIGACT-SIGPLAN
Symposium on Principles of Programming Languages, ser. POPL ’77.
New York, NY, USA: ACM, 1977, pp. 238–252. [Online]. Available:
http://doi.acm.org/10.1145/512950.512973
[60] ——, “Systematic design of program analysis
Proceedings of
Principles of Programming Languages,
York, NY, USA: ACM, 1979, pp. 269–282.
http://doi.acm.org/10.1145/567752.567778
frameworks,” in
the 6th ACM SIGACT-SIGPLAN Symposium on
New
[Online]. Available:
ser. POPL ’79.
[61] A. Min´e, “The octagon abstract domain,” Higher-Order and Symbolic
Computation, vol. 19, no. 1, pp. 31–100, 2006. [Online]. Available:
https://doi.org/10.1007/s10990-006-8609-1
[62] E. Clarke, D. Kroening, and F. Lerda, “A tool for checking ansi-c
programs,” in Tools and Algorithms for the Construction and Analysis of
Systems, K. Jensen and A. Podelski, Eds. Berlin, Heidelberg: Springer
Berlin Heidelberg, 2004, pp. 168–176.
[63] M. Clochard, J.-C. Filliˆatre, and A. Paskevich, “How to avoid proving
the absence of integer overﬂows,” in Veriﬁed Software: Theories, Tools,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 
1692
and Experiments, A. Gurﬁnkel and S. A. Seshia, Eds. Cham: Springer
International Publishing, 2015, pp. 94–109.
[64] D. Sarkar, M. Jagannathan, J. Thiagarajan, and R. Venkatapathy,
“Flow-insensitive static analysis for detecting integer anomalies in
programs,” in Proceedings of
the 25th Conference on IASTED
International Multi-Conference: Software Engineering, ser. SE’07.
Anaheim, CA, USA: ACTA Press, 2007, pp. 334–340.
[Online].
Available: http://dl.acm.org/citation.cfm?id=1332044.1332098
[65] E. N. Ceesay, J. Zhou, M. Gertz, K. Levitt, and M. Bishop, “Using type
qualiﬁers to analyze untrusted integers and detecting security ﬂaws in
c programs,” in Detection of Intrusions and Malware & Vulnerability
Assessment, R. B¨uschkes and P. Laskov, Eds.
Berlin, Heidelberg:
Springer Berlin Heidelberg, 2006, pp. 1–16.
[66] F. Long, S. Sidiroglou-Douskos, D. Kim, and M. Rinard, “Sound input
ﬁlter generation for integer overﬂow errors,” in Proceedings of the 41st
ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, ser. POPL ’14. New York, NY, USA: ACM, 2014, pp. 439–
452. [Online]. Available: http://doi.acm.org/10.1145/2535838.2535888
[67] Z. Coker and M. Haﬁz, “Program transformations to ﬁx c integers,”
in Proceedings of
the 2013 International Conference on Software
Engineering, ser. ICSE ’13. Piscataway, NJ, USA: IEEE Press, 2013,
pp. 792–801. [Online]. Available: http://dl.acm.org/citation.cfm?id=
2486788.2486892
integer
[68] X. Cheng, M. Zhou, X. Song, M. Gu, and J. Sun, “Intpti:
in
the 32Nd IEEE/ACM International Conference on
Piscataway,
[Online]. Available:
Automatic
Proceedings of
Automated Software Engineering,
NJ, USA:
http://dl.acm.org/citation.cfm?id=3155562.3155693
IEEE Press, 2017, pp. 996–1001.
repair with proper-type
ser. ASE 2017.
inference,”
error
A. Preprocessing of Veriﬁcation Conditions
APPENDIX
Given a basic path p,
let F be a veriﬁcation condition
(either an inductiveness condition, i.e., F = GENVC(p).1,
or a safety condition, i.e., F ∈ GENVC(p).2) that contains
equalities of the form sum(x) = e for some mapping variable
x and expression e. For simplicity, we assume that F does not
contain primed instances (e.g., x(cid:3), x(cid:3)(cid:3)) of the mapping variable
x. Let I be the set of variables in F used as indices of x.
Then, we replace each equality sum(x) = e by G as follows.
If I = ∅, we deﬁne G to be G1 ∧ G2 where G1 = (Rx = e),
G2 = Bx (Rx and Bx are fresh variables, see Section III-D). If
I = {i} (i.e., I is a singletone set), we deﬁne G to be G1∧G2
where G1 = (x[i]+Rx = e) and G2 = (x[i]+Rx ≥ Rx∧Bx).
Otherwise (i.e., I = {i1, . . . , in}, n ≥ 2), we deﬁne G to be
G1 ∧ G2 where
G1 = (cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:3)
i = j) ∧
(
i (cid:8)= j)) →
(
(
Iu∈Pa
i,j∈Iu
a∈[1,m],
{{i1 ,...},··· ,{ik ,...}}
Pa=
and
G2 = (cid:2)
a∈[1,m],
{{i1 ,...},··· ,{ik ,...}}
Pa=
(cid:3)
(
(cid:2)
Iu∈Pa
(cid:2)
i,j∈Iu
(
i = j) ∧
(cid:2)
Iu,Iv∈Pa ,
Iu(cid:3)=Iv
(
(cid:2)
i∈Iu ,
j∈Iv
i (cid:8)= j)) →
(cid:4)
Hx,i,k ∧ x[i1] + · · · + x[ik] + Rx ≥ Rx)
(cid:4)k
Hx,i,k is deﬁned as true if k = 1, and deﬁned as
c=2 x[i1]+
··· + x[ic] ≥ x[ic] otherwise (i.e., k ≥ 2). P1, . . . , Pm are all
possible partitions of the index variable set I, where a partition
is a set of disjoint non-empty subsets of I such that the
∧ Bx.
union of the subsets equals I. For example, given I = {i, j},
we have two partitions: {{i, j}} and {{i},{j}}. Also, given
I = {i, j, k}, we have ﬁve partitions: {{i, j, k}}, {{i},{j, k}},
{{j},{i, k}}, {{k},{i, j}}, and {{i},{j},{k}}.
Intuitively, G1 asserts that the sum of distinct elements of x
equals e, and G2 asserts that overﬂows do not occur during
computing the sum of the distinct elements. More speciﬁcally,
using the partitions of I, we ﬁrst consider all possible cases of
(in)equalities among the variables in I; for each partition Pa =
{I1, . . . , Ik} (where (cid:25)1≤i≤kIi = I), the variables in the same
i = j)),
subsets have the same values (i.e.,
(cid:4)
and the variables in different subsets have different values (i.e.,
i (cid:3)= j)). Then, for each partition
case, we generate constraints on the distinct elements of x by
selecting an index variable from each subset.
Example 4: Given a basic path p, suppose F ∈ GENVC(p).2
is given as follows:
Iu,Iv∈Pa,Iu(cid:8)=Iv
i∈Iu,j∈Iv
Iu∈Pa
i,j∈Iu
(cid:4)
(cid:4)
(cid:4)
(
(
sum(y) = 100 ∧ y[i] ≥ v → y[j] + v ≥ y[j]
In this case, the index variable set for y is I = {i, j}, because
i and j are used as indices in y[i] and y[j], respectively. For
I, we have two partitions P1 = {{i, j}} and P2 = {{i},{j}},
and thus we consider two cases: i = j from P1 and i (cid:3)= j
from P2. Then, we replace sum(y) = 100 by G1 ∧ G2 where
G1 is
(i (cid:6)= j → y[i] + y[j] + Ry = 100) ∧ (i = j → y[i] + Ry = 100)
and G2 is
(i (cid:6)= j → y[i] + y[j] ≥ y[i] ∧ y[i] + y[j] + Ry ≥ Ry)∧
(i = j → y[i] + Ry ≥ Ry) ∧ By.
Finally, by replacing sum(y) = 100 in F by G1 ∧ G2, we
obtain the following F (cid:3)
(cid:9)
(i (cid:3)= j → y[i] + y[j] + Ry = 100)∧
(i = j → y[i] + Ry = 100)∧
(i (cid:3)= j → y[i] + y[j] ≥ y[i] ∧ y[i] + y[j] + Ry ≥ Ry)∧
(i = j → y[i] + Ry ≥ Ry) ∧ By∧
y[i] ≥ v
→ y[j] + v ≥ y[j]
(cid:10)
which is satisﬁable iff the original formula F is satisﬁable.
B. Proof of Proposition 1
Proof by contradiction. Assume p =⇒ q:
Ip |= q
(4)
where Ip is an interpretation that makes the evaluation of p
true (i.e., Ip |= p). From condition (ii), condition (iii), and
(4), we have a x-variant of Ip, denoted as I(cid:3)
p : Ip (cid:2) {x (cid:17)→ v} |= ¬q
I(cid:3)
where x ∈ FV(q) \ FV(p) and v ∈ DIp
Ip |= p and x (cid:3)∈ FV(p),
(5)
[x]}. Since
p, such that
\ {αIp
p |= p.
I(cid:3)
(3)
(6)
Iu,Iv∈Pa ,
Iu(cid:3)=Iv
i∈Iu ,
j∈Iv
x[i1] + · · · + x[ik] + Rx = e
(cid:4)
∀I.I |= ¬p ∨ q.
From condition (ii) and (3), we have
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 
1693
Combining (5) and (6), we have I(cid:3)
contradicts with the assumption (3). Thus p (cid:3)=⇒ q.
C. More Examples of Validity Templates
p |= ¬(¬p ∨ q), which
We provide three more examples that are important for
performance. We assume that formula F below is in CNF
(conjunctive normal form). We write c ∈ F for indicating that
F has clause c.
Example 5: Consider a template
sum(x) = n ∈ F, x[p] ≥ v ∈ F
F → x[q] + v ≥ x[q]
n + n ≥ n
where x is a mapping variable that maps address-typed index
variables to 256-bit unsigned integer-typed variables, n is an
integer constant (where n + n does not overﬂow in unsigned
256-bit), and p and q are address-typed variables. The template
above states that, when sum(x) = n and x[p] ≥ v hold in the
precondition F , x[q] + v ≥ x[q] also holds for any index
address-typed variable q. For example, we can use the rule to
check that the VC
··· ∧ sum(a) = 100 ∧ ··· ∧ a[i] ≥ k ∧ ··· → a[j] + k ≥ a[j]
is valid without preprocessing the formula and invoking an
SMT solver.
Example 6: Consider a template:
sum(x) = y ∈ F, y = n ∈ F, x[p] ≥ v ∈ F
F → x[q] + v ≥ x[q]
n + n ≥ n
where x is a mapping variable that maps address-typed index
variables to 256-bit unsigned integer-typed variables, y and v
are 256-bit unsigned integer-typed variables, n is an integer
constant (where n + n does not overﬂow in unsigned 256-bit),
and p and q are address-typed variables. Note that the template
above is similar to the one in Example 5, where sum(x) = n
is changed into a combination of sum(x) = y and y = n.
Using the template, we can prove the validity of the VC:
··· ∧ sum(a) = b ∧ ··· ∧ b = 100 ∧ ··· ∧ a[i] ≥ k ∧ . . .
→ a[j] + k ≥ a[j]
Example 7: Consider a template:
F → n1 + (x%n2) ≥ n1
n1 + n2 ≥ n1
where x is a 256-bit unsigned integer-typed variables, and n1
and n2 are integer constants (where n1 +n2 does not overﬂow
in unsigned 256-bit). Using the validity template above, we
can prove that ··· → 48 + (y%10) ≥ 48 is valid.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 
1694