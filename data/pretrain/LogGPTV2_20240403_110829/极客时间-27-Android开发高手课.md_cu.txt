# 练习Sample跑起来 \| 热点问题答疑第2期你好，我是孙鹏飞。今天我们基于[专栏第 5期](http://time.geekbang.org/column/article/71982)的练习 Sample以及热点问题，我来给你做答疑。有关上一期答疑，你可以点击[这里](http://time.geekbang.org/column/article/73068)查看。为了让同学们可以进行更多的实践，专栏第 5 期 Sample采用了让你自己实现部分功能的形式，希望可以让你把专栏里讲的原理可以真正用起来。前面几期已经有同学通过 Pull request提交了练习作业，这里要给每位参与练习、提交作业的同学点个赞。第 5 期的作业是根据系统源码来完成一个 CPU数据的采集工具，并且在结尾我们提供了一个案例让你进行分析。我已经将例子的实现提交到了[GitHub](http://github.com/AndroidAdvanceWithGeektime/Chapter05)上，你可以参考一下。在文中提到，"当发生 ANR 的时候，Android 系统会打印 CPU相关的信息到日志中，使用的是[ProcessCpuTracker.java](http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java)"。ProcessCpuTracker的实现主要依赖于 Linux 里的 /proc 伪文件系统（in-memory pseudo-filesystem），主要使用到了/proc/stat、/proc/loadavg、/proc/\[pid\]/stat、/proc/\[pid\]/task相关的文件来读取数据。在 Linux 中有很多程序都依赖 /proc 下的数据，比如top、netstat、ifconfig 等，Android 里常用的 procrank、librank、procmem等也都以此作为数据来源。关于 /proc 目录的结构在 Linux Man Pages里有很详细的说明，在《Linux/Unix系统编程手册》这本书里，也有相关的中文说明。``{=html}关于 proc 有一些需要说明的地方，在不同的 Linux内核中，该目录下的内容可能会有所不同，所以如果要使用该目录下的数据，可能需要做一些版本上的兼容处理。并且由于Linux内核更新速度较快，文档的更新可能还没有跟上，这就会导致一些数据和文档中说明的不一致，尤其是大量的以空格隔开的数字数据。这些文件其实并不是真正的文件，你用ls 查看会发现它们的大小都是0，这些文件都是系统虚拟出来的，读取这些文件并不会涉及文件系统的一系列操作，只有很小的性能开销，而现阶段并没有类似文件系统监听文件修改的回调，所以需要采用轮询的方式来进行数据采集。下面我们来看一下专栏文章结尾的案例分析。下面是这个示例的日志数据，我会通过分析数据来猜测一下是什么原因引起，并用代码还原这个情景。    usage: CPU usage 5000ms(from 23:23:33.000 to 23:23:38.000):System TOTAL: 2.1% user + 16% kernel + 9.2% iowait + 0.2% irq + 0.1% softirq + 72% idleCPU Core: 8Load Average: 8.74 / 7.74 / 7.36 Process:com.sample.app   50% 23468/com.sample.app(S): 11% user + 38% kernel faults:4965 Threads:  43% 23493/singleThread(R): 6.5% user + 36% kernel faults：3094  3.2% 23485/RenderThread(S): 2.1% user + 1% kernel faults：329  0.3% 23468/.sample.app(S): 0.3% user + 0% kernel faults：6  0.3% 23479/HeapTaskDaemon(S): 0.3% user + 0% kernel faults：982  \.\.\.上面的示例展示了一段在 5 秒时间内 CPU 的 usage的情况。初看这个日志，你可以收集到几个重要信息。1\. 在 System Total 部分 user 占用不多，CPU idle 很高，消耗多在 kernel和 iowait。2.CPU 是 8 核的，Load Average 大约也是 8，表示 CPU 并不处于高负载情况。3\. 在 Process 里展示了这段时间内 sample app 的 CPU 使用情况：user低，kernel 高，并且有 4965 次 page faults。4\. 在 Threads 里展示了每个线程的 usage 情况，当前只有 singleThread 处于R 状态，并且当前线程产生了 3096 次 pagefaults，其他的线程包括主线程（Sample 日志里可见的）都是处于 S 状态。根据内核中的线程状态的[宏的名字](http://elixir.bootlin.com/linux/v4.8/source/include/linux/sched.h#L207)和缩写的对应，R值代表线程处于 Running 或者 Runnable 状态。Running状态说明线程当前被某个 Core 执行，Runnable状态说明线程当前正在处于等待队列中等待某个 Core空闲下来去执行。从内核里看两个状态没有区别，线程都会持续执行。日志中的其他线程都处于S 状态，S状态代表[TASK_INTERRUPTIBLE](http://elixir.bootlin.com/linux/v4.8/ident/TASK_INTERRUPTIBLE)，发生这种状态是线程主动让出了CPU，如果线程调用了 sleep或者其他情况导致了自愿式的上下文切换（Voluntary ContextSwitches）就会处于 S 状态。常见的发生 S状态的原因，可能是要等待一个相对较长时间的 I/O 操作或者一个 IPC操作，如果一个 I/O 要获取的数据不在 Buffer Cache 或者 Page Cache里，就需要从更慢的存储设备上读取，此时系统会把线程挂起，并放入一个等待I/O 完成的队列里面，在 I/O操作完成后产生中断，线程重新回到调度序列中。但只根据文中这个日志，并不能判定是何原因所引起的。还有就是 SingleThread 的各项指标都相对处于一个很高的情况，而且产生了一些faults。page faluts 分为三种：minor page fault、major page fault 和invalid page fault，下面我们来具体分析。minor page fault 是内核在分配内存的时候采用一种 Lazy的方式，申请内存的时候并不进行物理内存的分配，直到内存页被使用或者写入数据的时候，内核会收到一个MMU 抛出的 page fault，此时内核才进行物理内存分配操作，MMU会将虚拟地址和物理地址进行映射，这种情况产生的 page fault 就是 minorpage fault。major page fault产生的原因是访问的内存不在虚拟地址空间，也不在物理内存中，需要从慢速设备载入，或者从Swap分区读取到物理内存中。需要注意的是，如果系统不支持[zRAM](http://source.android.com/devices/tech/perf/low-ram)来充当Swap 分区，可以默认 Android 是没有 Swap 分区的，因为在 Android里不会因为读取 Swap 而发生 major page fault 的情况。另一种情况是 mmap一个文件后，虚拟内存区域、文件磁盘地址和物理内存做一个映射，在通过地址访问文件数据的时候发现内存中并没有文件数据，进而产生了major page fault 的错误。根据 page fault 发生的场景，虚拟页面可能有四种状态：-   第一种，未分配；-   第二种，已经分配但是未映射到物理内存；-   第三种，已经分配并且已经映射到物理内存；-   第四种，已经分配并映射到 Swap 分区（在 Android    中此种情况基本不存在）。通过上面的讲解并结合 page fault 数据，你可以看到 SingleThread你一共发生了 3094 次 fault，根据每个页大小为 4KB，可以知道在这个过程中SingleThread 总共分配了大概 12MB 的空间。下面我们来分析 iowait 数据。既然有 iowait 的占比，就说明在 5秒内肯定进行了 I/O 操作，并且 iowait占比还是比较大的，说明当时可能进行了大量的 I/O操作，或者当时由于其他原因导致 I/O 操作缓慢。从上面的分析可以猜测一下具体实现，并且在读和写的时候都有可能发生。由于我的手机写的性能要低一些，比较容易复现，所以下面的代码基于写操作实现。    File f = new File(getFilesDir(), "aee.txt"); FileOutputStream fos = new FileOutputStream(f); byte[] data = new byte[1024 * 4 * 3000];// 此处分配一个 12mb 大小的 byte 数组 for (int i = 0; i `{=html}> Ftrace is an internal tracer designed to help out developers and> designers of systems to find what is going on inside the kernel.从文档中可以看出来，ftrace 工具主要是用来探查 outside of user-space的性能问题。不过在很多场景下，我们需要知道 user space 的事件调用和kernel 事件的一个先后关系，所以 ftrace也提供了一个解决方法，也就是提供了一个文件trace_marker，往该文件中写入内容可以产生一条 ftrace记录，这样我们的事件就可以和 kernel的日志拼在一起。但是这样的设计有一个不好的地方，在往文件写入内容的时候会发生system call调用，有系统调用就会产生用户态到内核态的切换。这种方式虽然没有内核直接写入那么高效，但在很多时候ftrace 工具还是很有用处的。由此可知，用户态的事件数据都是通过 trace_marker 写入的，更进一步说是通过write 接口写入的，那么我们只需要 hook 住 write 接口并过滤出写入这个 fd下的内容就可以了。这个方案通用性比较高，而且使用 PLT Hook 即可完成。下一步会遇到的问题是，想要获取 atrace 的日志，就需要设置好 atrace 的category tag 才能获取到。我们从源码中可以得知，判断 tag 是否开启，是通过atrace_enabled_tags & tag 来计算的，如果大于 0 则认为开启，等于 0则认为关闭。下面我贴出了部分 atrace_tag 的值，你可以看到，判定一个 tag是否是开启的，只需要 tag 值的左偏移数的位值和 atrace_enabled_tags在相同偏移数的位值是否同为 1。其实也就是说，我将 atrace_enabled_tags的所有位都设置为 1，那么在计算时候就能匹配到任何的 atrace tag。    #define ATRACE_TAG_NEVER            0      #define ATRACE_TAG_ALWAYS           (1`{=html}关于这期的 Sample 实现，有几个可能产生疑问的地方我们来探讨一下。这个 Sample 的 Gradle 插件是发布到本地 Maven库的，所以如果没有执行发布直接编译需要先发布插件库到本地 Maven中才能执行编译成功。另一个可能遇到问题的是，如果你想把 Sample 使用到其他项目，需要自己将SampleApp 中其 p 的e.systrace.TraceTag"类移植到自己的项目中，否则会产生编译错误。对于字节码处理，在 Sample 中主要使用了 ASM框架来处理。市面上关于字节码处理的框架有很多，常见的有[ASM 和 Javassist框架](https://www.infoq.cn/article/Living-Matrix-Bytecode-Manipulation)，其他的框架你可以使用"Javabytecode manipulation"关键字在 Google上搜索。使用字节码处理框架需要对字节码有比较深入的了解，要提醒你的是这里的字节码不是Dalvik bytecode 而是 Javabytecode。对于字节码的学习，你可以参考[官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html)和《Java虚拟机规范》，里面对字节码的执行规则和指令说明都有很详细的描述。并且还可以配合javap命令查看反编译的字节码对应的源码，这样学习下来会有很好的效果。字节码处理是一个很细微的操作，稍有失误就会产生编译错误、执行错误或者Crash 的情况，里面需要注意的地方也非常多，比如 Try Catch Block对操作数栈的影响、插入的代码对本地变量表和操作数栈的影响等。实现 AOP 的另一种方是可以接操作 Dex 文件进行 Dalvik bytecode字节码注入，关于这种实现方式可以使用[dexer](https://android.googlesource.com/platform/tools/dexter/)库来完成，在Facebook 的[Redex](https://github.com/facebook/redex)中也提供了针对 dex的 AOP 功能。下面我们来看[专栏第 8期](http://time.geekbang.org/column/article/74044)。我从文章留言里看到，有同学关于数据重排序对I/O性能的影响有些疑问，不太清楚优化的原理。其实这个优化原理理解起来是很容易的，在进行文件读取的操作过程中，系统会读取比预期更多的文件内容并缓存在Page Cache 中，这样下一次读请求到来时，部分页面直接从 Page Cache读取，而不用再从磁盘中获取数据，这样就加速了读取的操作。在[《支付宝 App构建优化解析》](https://mp.weixin.qq.com/s/79tAFx6zi3JRG-ewoapIVQ)里"原理"一节中已经有比较详细的描述，我就不多赘述了。如果你对"预读"感兴趣的话，我给你提供一些资料，可以深入了解一下。预读（readhead）机制的系统源码在[readhead.c](https://github.com/torvalds/linux/blob/master/mm/readahead.c)文件中。需要说明的是，预读机制可能在不同系统版本中有所变化，所以下面我提供的资料大多是基于Linux 2.6.x 的内核，在这以后的系统版本可能对 readhead机制有修改，你需要留意一下。关于预读机制详细的算法说明可以看[《Linux readahead: less tricks formore》](https://www.kernel.org/doc/ols/2007/ols2007v2-pages-273-284.pdf)和[《SequentialFile Prefetching InLinux》](http://www.ece.eng.wayne.edu/~sjiang/Tsinghua-2010/linux-readahead.pdf)、[《Linux内核的文件预读（readahead）》](http://blog.51cto.com/wangergui/1841294)这三篇文档。从专栏前几篇的正文看，很多优化的内容是从 Linux 的机制入手的，如果你对Linux的机制和优化不了解的话，是不太容易想到这些方案的。举个例子，专栏文章提到的小文件系统是运行在用户态的代码，底层依然依赖现存文件系统提供的功能，因此需要深入了解Linux VFS、ext4的实现，以及它们的优缺点和原理，这样我们才能发现为什么大量的小文件依赖现存的文件系统管理是存在性能缺陷的，以及下一步如何填补这些性能缺陷。作为 Android 开发工程师，我们该何学习 Linux呢？我其实不建议上来就直接阅读系统源码分析相关的书，我建议是从理解操作系统概念开始，推荐两本操作系统相关的书：《深入理解计算机系统》和《计算机系统系统架构与操作系统的高度集成》。Linux的系统实现其实和传统的操作系统概念在细节上会有不小的差别，再推荐一本解析Linux 操作系统的书《操作系统之编程观察》，这本书结合源码对 Linux的各方面机制都进行和很详细的分析。对于从事 Android 开发的同学来说，确实很有必要深入了解 Linux系统相关的知识，因为 Android里很多特性都是依赖底层基础系统的，就比如我刚刚提到的"预读"机制，不光可以用在Android 的资源加载上，也可以拓展到 Flutter的资源加载上。假如我们以后面对一个不是 Linux 内核的系统，比如 FuchsiaOS，也可以根据已经掌握的系统知识套用到现有的操作系统上，因为像内存管理、文件系统、信号机制、进程调度、系统调用、中断机制、驱动等内容都是共通的，在迁移到新的系统上的时候可以有一个全局的学习视角，帮助我们快速上手。对于操作系统内容，我的学习路线是先熟悉系统机制，然后熟悉系统提供的各个方向的接口，比如I/O操作、进程创建、信号中断处理、线程使用、epoll、通信机制等，按照《UNIX环境高级编程》这本书的内容一步步的走就可以完成这一步骤，熟悉之后可以按照自己的节奏，再去学习自己比较感兴趣的模块。此时可以找一本源码分析的书再去阅读，比如想了解fork 机制的实现、I/O 操作的 read 和 write在内核态的调度执行，像这些问题就需要有目的性的进行挖掘。上面这个学习路线是我在学习过程中不断踩坑总结出来的一些经验，对于操作系统我也只是个初学者，也欢迎你留言说说自己学习的经验和问题，一起切磋进步。最后送出 3本"极客周历"给用户故事"[专栏学得苦？可能是方法没找对](http://time.geekbang.org/column/article/77342)"留言点赞数前三的同学，分别是[\@坚持远方、@蜗牛、@JIA]{.orange}，感谢同学们的参与。![](Images/0e5461ae1393aa633b672fbee779c7e1.png){savepage-src="https://static001.geekbang.org/resource/image/bf/f1/bf8fdc35ddccb10b1161d8ca7eb8f8f1.jpg"}
# Android JVM TI机制详解（内含福利彩蛋）你好，我是孙鹏飞。在专栏[卡顿优化](http://time.geekbang.org/column/article/73277)的分析中，绍文提到可以利用JVM TI机制获得更加非常丰富的顿现场信息，包括内存申请、线程创建、类加载、GC信息等。JVM TI机制究竟是什么？它为什么如此的强大？怎么样将它应用到我们的工作中？今天我们一起来解开它神秘的面纱。