transform the ciphertext for user U into ciphertext for user
F. After that, the user F can decrypt the new ciphertext with
its own key and obtain the cleartext message.
Bidirectional signature proxy function. A bidirectional
signature function is deﬁned as a tuple S = (BiGen, BiSig,
BiVer, (cid:5)). As in the bidirectional encryption case, the key
generation algorithm BiGen creates keys for all users in
the system, including the user F. For each pair of keys
(kU; kF), the BiGen algorithm generates a bidirectional key
(cid:25). The general users U sign messages using BiSig and veri-
ﬁes the signatures using BiVer. Whenever the user F wants
to generate a valid signature for a message m on behalf of
a user U, it ﬁrst generates a signature with its own key and
then asks the proxy P for help. The proxy P uses the bidi-
rectional function (cid:5) and the bidirectional key (cid:25) to trans-
form the signature generated by the user F into a signature
generated with the user’s key.
Table 1 reﬂects the way the unidirectional and the bidi-
rectional techniques work for both encryption and signa-
tures.
Even though both bidirectional and unidirectional proxy
functions achieve the same goal, there are a few notable
differences between them. First, the unidirectional proxy
functions can be used only one way, from one user to an-
other user. The reverse sense requires a different unidirec-
tional function. The bidirectional proxy functions can be
used in both directions. Second, the bidirectional schemes
assume that the law enforcement agency (user F) has its
own key. The unidirectional schemes do not make this as-
sumption but pay an increased storage requirement price
because the user F needs to store one key for each user in
the system. In both cases, the proxy P has the increased
space problem because it needs to save one key for every
Bidirectional
Unidirectional
U(cid:13)(DK(cid:13)U(cid:13))(cid:13)
Encryption
U(cid:13)(sk(cid:13)U(cid:13))(cid:13)
e=Enc(cid:13)U(cid:13)(m)(cid:13)
P(  (cid:13))(cid:13)
e'=    (e)(cid:13)
F(sk(cid:13)F(cid:13))(cid:13)
e'=Enc(cid:13)F(cid:13)(m)(cid:13)
e=Enc(cid:13)U(cid:13)(m)(cid:13)
P(DK(cid:13)P(cid:13))(cid:13)
PDec(e)(cid:13)
F(DK(cid:13)F(cid:13))(cid:13)
FDec(PDec(e))=m(cid:13)
U(cid:13)(sk)(cid:13)
Signature
F(sk(cid:13)F(cid:13))(cid:13)
s'=Sig(cid:13)F(cid:13)(m)(cid:13)
P(  (cid:13))(cid:13)
s'=    (s)(cid:13)
U(cid:13)(sk(cid:13)U(cid:13))(cid:13)
s=Sig(cid:13)U(cid:13)(m)(cid:13)
F(sk(cid:13)F(cid:13))(cid:13)
m(cid:13)
FSig(m)(cid:13)
P(sk(cid:13)P(cid:13))(cid:13)
s=Psig(FSig(m))(cid:13)
Table 1. Unidirectional vs. Bidirectional techniques
user. This problem can be very important in systems where
the number of general users is extremely large. A solu-
tion is offered by the identity-based primitives [5], where
the proxy needs to save only a share of the master secret
key. Third, in both cases, revocation is easily achieved by
having the third party P refuse to help.
The unidirectional and bidirectional schemes described
in this paper require the proxy agent P to continuously as-
sist the law enforcement agency F when decrypting cipher-
text or generating valid signatures on behalf of a user. The
key-insulated model presented in [9, 10] can be easily ex-
tended such that the proxy agent P helps the law enforce-
ment agency only once, at the beginning of its warrant. The
key-insulated model has two actors, the proxy agent P and
the user U. The user U updates its secret key using the
index of the current time period and some information pro-
vided by a third party (P). Our model adds another player,
the law enforcement agency F, that receives from the proxy
P the user’s key for an unused period of time T0. Similar
to the original key-insulated model, the proxy P helps the
user to update its key. In addition, the proxy P helps the
law enforcement agency F to compute the user’s key for
time period Ti if presented with an warrant for the time Ti.
All primitives presented in [9, 10] can be easily extended
for our ofﬂine model.
With this model in mind, we introduce in the next sec-
tions the unidirectional and bidirectional encryption and
signature schemes. For each scheme, we give formal def-
initions, present one generic scheme and several speciﬁc
schemes, and prove their security guarantees. For simplic-
ity, all general deﬁnitions will be given in the context of
public-key cryptography.
4 Unidirectional Encryption Primitives
Deﬁnition 1 A unidirectional encryption scheme consists
of ﬁve algorithms, E = (UniGen, UniEnc, UniDec, PDec,
FDec).
The generation algorithm UniGen(1k) outputs a tuple of
keys (EK,DK) for each general user U. EK is the encryption
key and DK is the decryption key. For each secret key DK,
the key generation algorithm creates two secret keys DKP
and DKF for the proxy P, and respectively the user F. For
simplicity, the deﬁnitions given in table 2 show that the key
generation algorithm outputs only user keys, even though
it also builts the keys for the proxy P and the user F.
UniEncEK is the encryption algorithm and encrypts a
message m from the corresponding message space M (e.g.,
f0; 1gk) as e = UniEncEK(m). The decryption algo-
rithm UniDecDK is a deterministic decryption algorithm
that takes the ciphertext e, the secret key DK, and out-
puts m 2 M (or invalid in case e was an improper ci-
phertext). The correctness property of encryption states
that UniDec(UniEnc(m)) = m, for any message m and
pair of keys (EK; DK). The function PDec uses the se-
cret key of the proxy P, DKP, to transform a ciphertext
e into ciphertext e0. The FDec function takes this cipher-
text e0 and the secret key DKF of the user F and produces
the original message m 2 M or invalid if the ciphertext
e0 was not correct. The correctness property speciﬁes that
FDec(PDec(UniEnc(m))) = m, for any m and (EK; DK).
Informally, a unidirectional encryption scheme is con-
sidered to be secure if none of the participating entities
(user F, proxy P, user U) can break it even if they hold
extra secrets. For simplicity, the deﬁnitions presented in ta-
ble 2 will be speciﬁc to the CCA2 security for public key
encryption 2. In our deﬁnitions, the proxy agent P gets only
2CPA and ONE-WAY security deﬁnitions are given when necessary.
Deﬁnition 2 Let E = (UniGen, UniEnc, UniDec, PDec, FDec) be an unidirectional encryption scheme.
1. E is CCA2 secure against the proxy P if j SuccP;E (1k) (cid:0) 1=2 j is negligible, SuccP;E is deﬁned as below, PDec
is a deterministic algorithm, and the proxy P never submits PDec(UniEncEK(mb)) to the FDec oracle.
SuccP;E
def= Prh b = ~b (cid:12)(cid:12)(cid:12)
(EK; DK)   UniGen(1k); (m0; m1)   PFDec(EK; DKP);
b   f0; 1g; ~b   PFDec(EK; DKP; UniEncEK(mb))
i
2. E is CCA2 secure against the user F if j SuccF;E (1k) (cid:0) 1=2 j is negligible, SuccF;E is deﬁned as below, and the
user F cannot submit the challenge UniEncEK(mb) to the PDec oracle.
SuccF;E
def= Prh b = ~b (cid:12)(cid:12)(cid:12)
(EK; DK)   UniGen(1k); (m0; m1)   FPDec(EK; DKF);
b   f0; 1g; ~b   FPDec(EK; DKF; UniEncEK(mb))
i
3. E is CCA2 secure against any user U if j SuccU;E (1k) (cid:0) 1=2 j is negligible, SuccU;E is deﬁned as below, and
the user U cannot submit the challenge UniEncEK(mb) to the decryption oracle UniDec.
SuccU;E
def= Prh b = ~b (cid:12)(cid:12)(cid:12)
(EK; DK)   UniGen(1k); (m0; m1)   UUniDec(EK);
b   f0; 1g; ~b   UUniDec(EK; UniEncEK(mb))
i
Table 2. Online encryption deﬁnitions.
oracle access to the FDec. In fact, P does not need access to
UniDec because it can simulate it by itself. The only condi-
tions necessary are that PDec is a deterministic algorithm,
and the proxy P never submits PDec(UniEncEK(mb)) to
the FDec oracle.
to transform the ciphertext e into ciphertext e0 by decrypt-
ing once with its key DKP = DK1: e0 = Dec1(e). The
user F uses FDec to transform the ciphertext e0 into the ini-
tial message m (or invalid) by decrypting once with its key
DKF = DK2: m = Dec2(e0).
For each of the unidirectional schemes described next,
we will prove that they are secure according to all three
deﬁnitions.
4.1 Unidirectional Generic Encryption Scheme
We ﬁrst present a unidirectional generic technique
that
transforms a general encryption scheme E =
(Enc-Gen; Enc; Dec) into an unidirectional encryption
scheme E 0 = (UniGen, UniEnc, UniDec, PDec, FDec).
The key generation algorithm UniGen generates two pairs
of keys (EK1; DK1; EK2; DK2) by running the Enc-Gen
algorithm twice. The user U keeps both keys, while
proxy P and the user F get (EK1; EK2; DK1), respec-
tively (EK1; EK2; DK2). We deﬁne DKP = DK1 and
DKF = DK2. The encryption algorithm UniEnc is equiva-
lent to encrypting the message with the two keys EK1 and
EK2: UniEnc(m) = Enc1(Enc2(m)) = e. The unidirec-
tional decryption algorithm UniDec decrypts the ciphertext
e by applying the original decryption algorithm Dec twice:
m = Dec2(Dec1(e)). The proxy P uses the function PDec
The double encryption can be also deﬁned using two dif-
ferent encryption schemes E1 = (Enc-Gen1; Enc1; Dec1),
E2 = (Enc-Gen2Enc2; Dec2). In this case, the unidirec-
tional encryption scheme E 0 = (UniGen, UniEnc, UniDec,
PDec, FDec) is deﬁned as:
(cid:15) UniGen(1k) = (Enc-GenE1(1k); Enc-GenE2 (1k))
(cid:15) UniEnc(m) = EncE1(EncE2(m))
(cid:15) UniDec(e) = DecE2(DecE1 (e))
(cid:15) PDec(e) = DecE1 (e)
(cid:15) FDec(e0) = DecE2(e0)
For simplicity, we assume that both encryption schemes
are identical. Next, we prove that the generic unidirectional
encryption scheme is secure according to our deﬁnitions.
We make the assumption that the initial encryption scheme
we started from is CCA2 and show that the new unidirec-
tional encryption scheme is also CCA2 . The proofs are in
the Appendix A.1.
Theorem 1 Let’s consider a standard encryption scheme
E = (Enc-Gen; Enc; Dec). Based on E, we build an uni-
directional encryption scheme E 0 = (UniGen, UniEnc,
If E is CCA2 secure, than E 0 is
UniDec, PDec, FDec).
also CCA2 secure against (1) the proxy P, (2) the user F,
and (3) any user U.
The generic scheme is twice slower than the original
scheme it started from.
In order to eliminate this slow-
down, we developed a few speciﬁc unidirectional encryp-
tion functions based on El Gamal, RSA, and IBE.
4.2 Unidirectional El Gamal Encryption Scheme
Let’s assume that we have an El Gamal encryption
scheme E = (Enc-Gen; Enc; Dec). The key generation al-
gorithm outputs the public key EK = (g; p; q; y) and the
secret key DK = (x), where p is a prime number, g is a
generator for the Z(cid:3)
p, x is randomly chosen from Zq, and
y = gx mod p. The encryption algorithm is deﬁned as
e = EncEK(m) = (gr mod p; mgxr mod p), where r is
chosen at random from Zq. The decryption algorithm com-
putes the message m from e by dividing mgxr to (gr)x
mod p.
The unidirectional El Gamal encryption scheme is de-
ﬁned as E 0 = (UniGen, UniEnc, UniDec, PDec, FDec).
For each user U, the key generation algorithm UniGen(1k)
generates a public-key pair (EK; DK) and splits the secret
key DK = x into two parts x1 and = x2 such that x =
x1 +x2. The proxy P receives DKP = x1 and the user F re-
ceives DKF = x2. The encryption UniEnc and the decryp-
tion UniDec algorithms are identical to the standard algo-
rithms: Enc and Dec. The transformation algorithms PDec
and FDec are equivalent to Dec under x1, respectively x2.
The unidirectional encryption scheme is correct because
FDecx2(PDecx1 (Ency(m))) = FDecx2(mgxr=(gr)x1 ) =
mgx2r=(gr)x2 = m.
According to our deﬁnitions, the next theorem proves
that the unidirectional El Gamal is as secure as the original
El Gamal scheme. The proofs are presented in Appendix
A.2.
Theorem 2 Let E 0 = (UniGen, UniEnc, UniDec, PDec,