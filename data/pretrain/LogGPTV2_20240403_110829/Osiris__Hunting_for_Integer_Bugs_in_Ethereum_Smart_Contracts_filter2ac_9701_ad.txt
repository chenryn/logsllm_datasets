between Z and O, is that O aims at detecting solely
overows and underows that are exploitable by an attacker in
practice, thus limiting the number of reported bugs, while Z
aims to be complete. Z reports no result for 22 contracts, where
no result means either an error occurred or a timeout. Z en-
countered less timeouts than O, with 14 compared to 35. On
the other hand, O managed to always faithfully return a result.
Table 3 depicts the confusion matrix of the evaluation between
O and Z. O reports 5 contracts to be unsafe, whereas
Z reports them to be safe. We manually veried these 5 con-
tracts and indeed found them to potentially produce integer over-
ows. Listing 4 provides an example of a vulnerable function con-
tained in one of the 5 contracts. The multiplication in the function
convertToWei may overow if amount is large enough. This ques-
tions Z claim to be sound in terms of achieving zero false nega-
tives. In 471 cases, Z reports a contract to be unsafe while O
reports it to be safe. We manually analysed these cases and found
that in some cases overows were benign. These benign overows
670
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
C. Ferreira Torres et al.
]
8
1
[
Z
Safe
228
471
12
O
Unsafe
No Result
Safe
Unsafe
No Result
Table 3: Comparison between Z and O.
5
157
10
0
0
0
were induced by the developer or by the Solidity compiler as part
of handling data structures of dynamic size such as arrays, strings
or bytes. The remaining overows were indeed possible overows,
that were not caught by O. O could not catch them be-
cause they do not originate from the sources that we dened. So
technically O could detect them by adding more sources, such
as loading from storage (i.e. SLOAD). Apart from that, the authors of
Z state in their paper that for several cases their tool reported
unsafe, although the contract was safe. We encountered 32 of these
cases. O reports 28 of these cases to be safe, thus about 88%
less than Z. Unfortunately, Z does not check for division by
zero or modulo zero bugs, thus we cannot compare O to Z
in this regard. O did not nd any modulo bugs. However, it did
nd 26 contracts vulnerable to division by zero bugs. We conrm
the results via manual analysis of the source code and verifying
that the bytecode was compiled using a compiler version lower
than 0.4.0.
1 convertToWei ( uint amount , string unit ) external
constant returns ( uint ) {
return amount * etherUnits [ unit ];
2
3 }
Listing 4: Overow in EtherUnitConverter’s convertToWei
function, not detected by Z.
Truncation Bugs. O reports 39 contracts carrying truncation
bugs. We manually veried the ndings and conrm the 39 bugs to
be true positives. To conrm the ndings, we checked the source
code for type castings where integers are converted to smaller
ranges.
Signedness Bugs. Signedness bugs seem to be less common. O
only reports 6 contracts to be vulnerable. Also here, we manually
veried the ndings and conrm the 6 bugs to be true positives. In
order to conrm, we looked for conversions between signed and
unsigned integers in the source code.
5.1.2 antitative Analysis.
Dataset. We collected the bytecode of 1,207,335 smart contracts,
by downloading the rst 5,000,000 blocks from the public Ethereum
blockchain. The timestamps of the collected smart contracts range
from August 7, 2015 04:42:15 AM to January 30, 2018 1:41:33 PM.
Figure 3 depicts the number of smart contracts in our dataset with
respect to the month of their deployment on the blockchain. We
state a sudden increase of smart contracts, starting from April
2017. Ethereum does not store the source code of smart contracts.
To obtain the source code of a smart contract, users often refer
to services such as Etherscan. However, at the time of writing,
Etherscan solely lists the source code of 29,486 smart contracts [6].
671
s
t
c
a
r
t
n
o
c
t
r
a
m
s
f
o
r
e
b
m
u
N
1400000
1200000
1000000
800000
600000
400000
200000
0
October 2017
October 2016
October 2015
April 2017
April 2016
June 2017
June 2016
December 2016
December 2015
December 2017
August 2015
August 2016
August 2017
February 2016
February 2017
Date
Figure 3: Number of smart contracts in Ethereum has in-
creased abruptly.
Hence, only around 2% of the smart contracts on the Ethereum
blockchain have their source code publicly available. Again, this
emphasises the need for tools such as O, that are capable of
analysing smart contracts directly at the bytecode level. Out of
these 1,207,335 contracts, only 50,535 are unique in terms of their
bytecode. In other words, 96% of the smart contract on the Ethereum
blockchain are just copies.
Performance. On average, O takes 75 seconds to analyse a
contract, with a median of 13 seconds and a mode of 1 second. 524
contracts require more than 30 minutes to analyse. The number of
paths explored by O ranges from 1 to 1394 with an average
of 71 per contract and a median of 51. Similar to [20], we observe
that the running time depends almost linearly on the number of
explored paths. Finally, during our experiments, O achieved a
code coverage of about 88% on average.
Results. Figure 4 and Figure 5 report our results. O detects
42,108 contracts which contain at least one of the integer bugs
discussed in Section 2.3. Out of these, 14,697 are distinct (by direct
comparison of their bytecode). Figure 4 shows that most reported
bugs are arithmetic (e.g. overows, underows, etc.) with 41,379
contracts as compared to 2,738 and 405 contracts for truncation and
signedness, respectively. Out of these 41,379 contracts, 14,107 are
found to be distinct, which account for roughly 28% of the 50,535
distinct contracts in our dataset. Figure 5 depicts the distribution
between reported arithmetic bugs. We note that overows are the
most common type of bugs with 23,473 vulnerable contracts, where
10,520 are distinct which account for about 21% of the distinct con-
tracts in our dataset. Immediately after that, follow underows
with 11,479 vulnerable contracts, where 6,103 are distinct which
account for about 12% of the distinct contracts in our dataset. It
is interesting to note that even though we only detect 29 distinct
contracts vulnerable to modulo zero, the number of overall vul-
nerable contracts is 10,335. This implies that certain contracts are
copied excessively and that one bug in such a contract, can have a
huge impact on the security of thousands of other contracts on the
blockchain.
O: Hunting for Integer Bugs in Ethereum Smart Contracts
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
All contracts
Unique contracts
41379
14107
2738
1401
A RIT HM E T IC
T RUNCA T ION
405
235
S IGNE D NE S S
Figure 4: Number of vulnerable contracts reported by O
per integer bug.
All contracts
Unique contracts
23473
10520
11479
10335
6103
OV E RF LOW
UND E RF LOW
M OD ULO
29
1292
350
D IV IS ION
Figure 5: Number of vulnerable contracts per arithmetic er-
ror type.
5.2 Detection of Real-World Vulnerabilities
In this section, we examine the eectiveness and usefulness of
O in detecting and reporting real-world vulnerabilities. For
this purpose, we run O on ve divulged vulnerabilities and
analyse 495 top Ethereum token smart contracts.
5.2.1 Detecting Known Vulnerabilities.
Recently, a security company called Peckshield4 disclosed ve
dierent vulnerabilities targeted at ERC-20 token smart contracts,
each exploiting an integer overow (see Table 4). O successfully
detects all the vulnerabilities listed in Table 4. From this small-scale
4https://peckshield.com/
Bug Name
CVE Number
Token
batchOverow CVE-2018-10299
BEC [5]
proxyOverow CVE-2018-10376
SMT [9]
UET [11]
transferFlaw
CVE-2018-10468
SCA [10] multiOverow CVE-2018-10706
HXG [8]
burnOverow CVE-2018-11239
Table 4: CVEs examined by O.
Disclosed
22 April 2018
25 April 2018
28 April 2018
10 May 2018
18 May 2018
experiment, we gain condence that O is suitable as a detection
tool for vulnerabilities in real-world smart contracts.
5.2.2 Detecting Unknown Vulnerabilities.
In the previous experiment we analysed O’s capability of
eectively detecting known CVEs. In this experiment, we want
to check whether O is capable of detecting yet undiscovered
vulnerabilities in Ethereum token smart contracts.
Dataset. Etherscan provides a list of top tokens ranked by their
market capitalisation [7]. As of June 2018, the list holds a total of 509
dierent tokens. Out of these, 495 have their source code publicly
available. We downloaded the bytecode as well as the source code
for these 495 smart contracts and analysed them using O.
Results. O reported 164 contracts to be vulnerable, where
126 contracts were reported to contain overows and 54 to contain
underows. We veried the ndings via manual inspection of the
source code. We found two overows to be false positives and the