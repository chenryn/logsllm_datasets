参会者的集合，即表Meetings中存在的组合即可。
--求出缺席者的sQL语句(1)：存在量化的应用
SELBCT DISTINCT M1.meeting, M2-person
FROM Meetinge M1 CROSs JOIN Meetings M2
(SELECT *
FROM Meeting8 M3
KHERE M1.meeting = M3-meeting
AND M2.person = M3 .person) /
如上所示，我们的需求被直接翻译成了SQL语句，意思很好理解。
这道例题还可以用集合论的方法来解答，即像下面这样使用差集运算。
**-求出缺席者的sQL语句（2）：使用差集运算
SELECT M1.neeting, N2.person
FROM Keetings N1, Heetings M2
SELECT meeting. peraon
EXCEPT
FROM Meetings;
通过以上两条SQL语句的比较我们可以明白，NOT EXISTS直接具备
了差集运算的功能。
图灵社区会员非洲钢(PI:EMAIL）专享尊重版权
---
## Page 151
138—第1章神奇的SQL
全称量化（1)：习惯“肯定双重否定”之间的转换
接下来我们练习一下如何使用EXISTS谓词来表达全称量化，这是
EXISTS的用法中很具有代表性的一个用法。通过这一部分内容的学习，
的行一行都不存在”的转换。
这里使用下面这样一张存储了学生考试成绩的表为例进行讲解。
TestScores
sledent id（学生ID）subject |校科}
score[点数）
100
数学
100
100
语文
80
100
理化
80
200
数学
80
200
语文
95
300
数学
40
300
语文
90
300
社会
55
400
数学
80
我们先来看一个简单的问题：请查询出“所有科目分数都在50分
以上的学生”。答案是学号分别为100、200、400的3人。学号为300的
学生语文和社会两科目都在50分以上，但是数学考了40分，所以不符合
条件。
重否定“没有一个科目分数不满50分”，然后用NOTBXISTS来表示转换
后的命题
SELECT DISTINCT student_1d
FROM TestScores TS1
MHERE HOT EXISTS
不存在满足以下条件的行
(SELBCT +
FROM TeatScores TS2
NHERE TS2 atudent_id = TS1.student_1d
AND T82.a00re c 50}:
-分数不满50分的科目
---
## Page 152
18EXISTS请词的用法—139
■执行结果
student_id
100
200
400
怎么样，是不是很简单呢？
接下来我们把条件改得复杂一些再试试。请思考一下如何查询出满足
下列条件的学生。
1.数学的分数在80分以上。
2.语文的分数在50分以上。
结果应该是学号分别为100、200、400的学生。这里，学号为400的
学生没有语文分数的数据，但是也需要包含在结果里。像这样的需求，我
们在实际业务中应该会经常遇到，但是乍一看可能会觉得不太像是全称量
化的条件。
如果改成下面这样的说法，可能我们一下子就能明白它是全称量化的
命题了。
“某个学生的所有行数据中，如果科目是数学，则分数在80分以上；
如果科目是语文，则分数在50分以上。”
没错，这其实是针对同一个集合内的行数据进行了条件分支后的全称
量化。SQL语句本身是支持根据不同行表示条件分支的，例如可以通过下
面这个具有两个条件分支的CASE表达式来表示条件分支。
ELSE 0 END
这条SQL语句表达的正是1-4节介绍过的“特征函数”，对于满足条
件的行，该SQL语句会返回1，否则返回o.然后，我们只需要像下面这
样把语句里的条件反过来就可以了。
图灵社区会员非洲铜(PI:EMAIL)专享尊重版权
---
## Page 153
140—第1章神奇的SQL
SSLBCT DISTINCT student_id
MHERE BubjectIN（数学，语文
AND NOT EXISTS
ISBLBCT *
FROM TestScores TS2
WHERE TS2.student_id = TS1.student_id
ELSE 0 END)1
这里解释一下这段代码。首先，数学和语文之外的科目不在我们考虑
范围之内，所以通过IN条件进行一下过滤。然后，通过子查询来描述“数
学80分以上，语文50分以上”这个条件。
接下来，我们思考一下如何排除掉没有语文分数的学号为400的学生。
这里，学生必须两门科目都有分数才行，所以我们可以加上用于判断行数
的HAVING子句来实现。
SELSCT atudent_id
FBOM TestScores TS1
HHERE subjectIN数学，语文
AND NOT EXISTS
(SELBCT 
FROM TeatScores TS2
NHERE TS2.student_id = TS1.student_1d
AND 1 = CASE HHEN subject =*数学+ AND BCONe  CASE MEEN step_nbr <= 1
--使用双重否定来表达全称量化命题
完成
■执行结果
project_1d
step_nbr
status
...........
........
CS300
完成
CS300
完成
---
## Page 156
1-8EXISTS请词的用法—143
CS300
2
等待
3
等待
虽然两者都能表达全称量化，但是与HAVING相比，使用了双重否定
的NOTEXISTS代码看起来不是那么容易理解，这是它的缺点。但是这
种写法也有优点。第一个优点是性能好。只要有一行满足条件，查询就
会终止，不一定需要查询所有行的数据。而且还能通过连接条件使用
"project_id”列的索引，这样查询起来会更快。第二个优点是结果里能包
含的信息量更大。如果使用HAVING，结果会被聚合，我们只能获取到项
目ID，而如果使用EXISTS，则能把集合里的元素整体都获取到。
对列进行量化：查询全是1的行
不好的表在设计上一般都会存在一些典型的问题。例如没有主键且允
许重复的行存在，或者是完全忽略掉列应该作为“属性”来定义的这个习
惯，让某一列拥有了多个含义。还有一种是像下面这样只是单纯地存储了
数组的表，对于这样的表，数据库工程师看到就会忍不住叹一口气：“啊，
怎么又来了！
ArrayTbl
col1
ool2
0ol5
co6
Col7co8
ool9col10
D
/9
1
6
6
说这张表的设计不好的原因是，数组中的元素可以自由地增加或者减
少，而表中的列却不能这样。即便只是增加或减少1列，都非常麻烦。相反，
注0
行的增加或者减少却对系统几乎没有什么影响·。因此在设计表时有一条
当然性能方真会有一些影响。包
是在这里我们洗的只是还辑方演
原则：让列具有一定的扩展性。数组中的元素不应该对应表中的列，而是
的向题
应该对应行。
本来，如果理解表是对现实世界中实体（entity）的抽象这一关系模
型理论，很自然就会明白这种思考方式。如果只是生成上面这样的表，那
么使用SQL-99中引入的数组类型也不失为一个办法。
---