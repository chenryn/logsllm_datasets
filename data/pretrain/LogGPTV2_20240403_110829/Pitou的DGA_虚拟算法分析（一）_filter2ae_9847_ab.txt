  9. 研究如何从字节码解码指令，特别是哪些位是决定处理程序函数的操作码，像之前在VM 调度器部分所讲的，第一个字节的最低6个比特指定处理程序，该处理程序对指令的其余部分进行解码，并将指令指针前置。
  10. 了解VM的体系结构。这在虚拟机部分已经介绍了。
  11. 最后，必须分析处理程序。这是分析中最耗时的部分。在Pitou中，有29个必须进行逆向的不同函数。
下面的截图显示了第一个操作码0x00对应的处理程序。函数不是很长，更幸运的是没有进行混淆。
下图显示了操作码0x00(别名0x2F和0x35)的指令编码以及对堆栈的影响。
指令编码字段的含义：
范围 | 比特 | 描述  
---|---|---  
设置大小 | 1 | 0: 没有设置大小, 默认是双字, 1: 大小 (大小占1 字节)  
操作码 | 6 | 必须是 0x00, 0x2F 或 0x35  
大小 | 8 | (可选项) 操作大小, 0: 字节, 1: 字, 2: 双字, 3: 四字  
处理程序使用前缀的第一个比特确定是否设置可选的操作大小。如果该位没有设置，则假定操作为32位，并且指令只有一个字节长。另一方面，如果设置了，则必须跟随另一个字节，其中最低的两位决定操作的大小。0代表一个字节（8位），1代表一个字（16位），2代表一个双字（32位，默认选项），3代表一个四字（64位）。该指令从堆栈中弹出两个值，对它们进行异或并将结果压回到堆栈中，将值转换为指定的大小。反汇编器很容易重新实现这个处理程序：
  12. 检查是否设置了has size位，如果设置了，则读取下一个字节，并根据最后两个位(0表示字节等)确定数据大小。否则，默认是双字大小。
  13. 输出XOR 。
  14. 如果设置了has size位，则将指令指针加2，如果没有则加1。
在重新实现所有29个处理程序之后，可以对字节码进行反汇编。下面摘录自己反汇编的字节码，展示了 XOR dword edx,
edx，即将寄存器edx归零，虚拟指令及其对x64指令堆栈的影响：
    FFFFF8800585817C NOP
                                                        (empty stack)
    FFFFF8800585817D PUSH dword (rdx, addr(rdx))
                                                        | rdx          | addr(rdx)        |
    FFFFF8800585817F PUSH dword (addr(rdx), addr(rdx))
                                                        | addr(rdx)    | addr(rdx)        |
                                                        | rdx          | addr(rdx)        |
    FFFFF88005858181 DREFH dword 
                                                        | rdx          | addr(rdx)        |
                                                        | rdx          | addr(rdx)        |
    FFFFF88005858182 XOR dword 
                                                        | edx XOR edx  | addr(rdx)        |
    FFFFF88005858183 P2E dword 
                                                        (empty stack)
  1. 第一个指令NOP，是空指令，什么也不做。
  2. 寄存器rdx与处理程序0x12一起被推送到堆栈上，但是对于推送地址标志使用了两种不同的设置：第一个PUSH将寄存器rdx的值推入堆栈的值槽，第二个PUSH推入寄存器rdx的地址(在这两种情况下，地址都存储在堆栈实体的额外槽位中)。
  3. 栈顶寄存器rdx的地址由DREFH dword得到。堆栈上的两个实体的rdx现在是相同的。我不明白为什么编译器一开始没推入地址而不是寄存器。
  4. XOR dword指令从最上面的两个堆栈实体中获取值，进行异或并将结果推回到堆栈上。额外槽位保持不变，也就是，在异或操作之前，该额外槽位的值是栈顶的元素值。
  5. 最后，指令 P2E dword 从堆栈中弹出实体，并将值槽(edx异或edx)移动到额外槽提供的内存地址中-addr(rdx)。这意味着，虚拟寄存器rdx被设置为0。
下面是示例代码片段的字节码，如引言中所述，它对应于DGA中的一个简单数学语句：
反汇编器从上面的字节码生成以下代码：
第一个数字是每一行的地址。蓝色方块中的数字是处理程序编号。之后是组成指令的字节。大多数是1或2字节长，但也有更长的指令，如10字节长度的条件跳转指令。该指令的助记符位于字节码之后，并带有一些语法高亮显示。由于我放弃了反汇编方法，所以目前的助记符并不都是特别好的选择和有意义的，在附录中你可以找到它们。
如果耐心等待，我们或许可以从反汇编器的输出中提取DGA。然而，我放弃了这个方法，因为：
  1. 反汇编程序的输出非常长，共有3681行。
  2. 虚拟机使用特殊的指令，如上面所示的P2E或DREFH。这些都是新指令，需要练习才能快速掌握。
  3. 没有工具可以很好地显示输出，例如，可以帮助查看代码流的图形工具。
有多种方法可以使反汇编更具可读性，例如：
  1. 添加模式以减少行数。例如，上面组成XOR edx、edx的6行代码非常常见。巧妙的模式匹配可以大大减少行数。
  2. 将反汇编程序实现为一个IDA Pro处理模块。在IDA中提供很多可用的注释工具，将提供一个很好的图形视图，使代码更具可读性。
我没有去实现这些想法，因为我心里有一个更诱人的目标：将虚拟代码反编译为C。你可以使用[Github上的Python脚本](https://github.com/baderj/pitou)自己运行反汇编程序：
    python3 main.py disassembly -o pitou.dis
###  方法二：反编译器
接下来展示如何将虚拟代码反编译为C代码。我的计划是首先将字节码转换为x64程序集，然后将其组装为x64二进制文件。之后，使用IDA Pro中的Hex
Rays插件打开该文件并生成x64反汇编代码和C代码。采用这样的步骤，目的是能够使用已有的工具，特别是Hex
Rays反编译器。这一点值得特别注意，因为DGA中使用了许多整数乘除法实例，这些实例在汇编中很难读取，但是反编译器可以很好地处理它们。
**步骤1：动态二进制翻译器**
在这四个步骤中，唯一没有工具的步骤是将VM的字节码转换为x64程序集。二进制翻译的任务是将虚拟指令序列重新编译成x64汇编。
我决定通过模拟字节码并同时动态输出相应的x64指令来进行转换。为了模拟虚拟指令，我使用了方法1中的反汇编器。其提供了指令的解码以及代码的递归遍历。由于VM是基于堆栈的，因此必须模拟堆栈。每个堆栈槽跟踪两个方面:
  1. 立即数或寄存器名。我将其标记为堆栈的值槽和额外槽位两个槽位的值部分（值和额外值（value和extra），见下面表格的形式）。
  2. 仅当(1)是寄存器时，指向堆栈上的寄存器值的汇编指令列表（（1）见VM调度器部分）。这个指令列表可以是空的。我给指令列表加上了值指令和额外指令的标签。
下面将展示如何模拟大多数的虚拟指令。我希望可以讲清楚这个方法。不管怎样，如果想获得更多的细节，可以看我在[Github](https://github.com/baderj/pitou/tree/master/disassemblerdecompiler)上的二进制翻译程序的源代码都。
**一元操作**
一元操作的虚拟指令包括NEG；INC 和DEC；NOT；SHR, SHL, ROR, ROL, SAR, 和SAL。它们都使用以下方式反编译：
  1. 从堆栈中弹出一个值。如下面示例中的rcx。
  2. 如果值是寄存器，则根据指令的大小进行转换，例如，Dword将把rcx转换为ecx。转换后的寄存器成为新堆栈实体的值。
  3. 如果弹出堆栈元素中存在值指令（value instructions），则将其组合起来。然后添加  ，如NEG DWORD ecx。将指令序列设置为新堆栈元素的值指令。
  4. 将额外值和额外指令从弹出的堆栈元素复制到新元素的额外槽位的相应位置。
  5. 将新的堆栈元素压入堆栈。
反编译器只影响堆栈，没有任何输出。下表显示调用NEG处理程序之前的堆栈(未设置大小标志)：
值（value） | 值指令（value instructions） | 额外值（extra） | 额外指令（extra instructions）  
---|---|---|---  
rcx | ADD rcx, 10 SHR rcx, 2 | addr(rcx) |  
调用处理程序后：
值（value） | 值指令（value instructions） | 额外值（extra） | 额外指令（extra instructions）  
---|---|---|---  
ecx | ADD rcx, 10 SHR rcx, 2 NEG DWORD ecx | addr(rcx) |  
注：这里作者将之前虚拟栈中讲的槽位进行再次划分，每个槽位划分为值部分和指令部分。
**二元操作**
有7条虚拟指令执行二进制操作：XOR、SBB、SUB、OR、AND、CMP和ADD，二元算术指令的处理类似于一元运算：
  1. 从堆栈中弹出两个值。下面的例子中的[r10 + 1]和rax，第一个值是指令的源操作数，第二个是目的操作数。
  2. 如果目的操作数值是寄存器，则根据指令的大小进行转换。例如Word把rax转换为al。转换后的目标寄存器成为新堆栈元素的值。
  3. 如果弹出的两个元素中含有值指令则将其组合在一起。然后添加   , ，如XOR byte al, [r10 + 1]。将指令序列设置为新堆栈元素的值指令。
  4. 将第二个弹出堆栈元素的额外（extra）和额外指令（extra instructions）的值复制到新元素的额外槽位的对应位置。
  5. 将新的堆栈元素压入堆栈。
像=与一元操作类似，反编译器只更改堆栈，没有任何输出。下表显示调用XOR处理程序之前的堆栈，设置了大小（size）标志，设置为0(表示字节)：
值（value） | 值指令（value instructions） | 额外值（extra） | 额外指令（extra instructions）  
---|---|---|---  
[r10 + 1] | SHR r10d, 2 | r10 | ADD QWORD r10, 1  
rax | SHL rax, 2 | addr(rax) |  
xor操作后，堆栈更改为：
值（value） | 值指令（value instructions） | 额外值（extra） | 额外指令（extra instructions）  
---|---|---|---  
al | SHR r10d, 2 SHL rax, 2 XOR BYTE al, [r10 + 1] | addr(rax) |  
**移动操作**
写数据的虚拟指令有M2E、M2V、P2E和P2V。例如，M2E指令将堆栈顶部元素值槽中的数据移动到额外槽指定的内存位置。通常，额外槽位包含虚拟寄存器的地址，最终值槽中的数据被移动到虚拟寄存器。例如，如果应用到下面的栈中，rsp的内容将被写入rax：
值（value） | 值指令（value instructions） | 额外值（extra） | 额外指令（extra instructions）  
---|---|---|---  
rsp | SUB QWORD rsp, 8 | addr(rax) | SHL QWORD rax, 3 ADD QWORD rax, 1  
这个操作对应于汇编中的MOV rax,
rsp。但是，在值指令和额外指令列中可以看到，rsp和rax在堆栈上已经进行了修改：转换已影响了堆栈。所以这些操作需要反编译器在MOV语句之前进行简单地更改来实现：
    SHL QWORD rax, 3
    ADD QWORD rax, 1
    SUB QWORD rsp, 8
    MOV rax, rsp
在虚拟机的大多数字节码序列中，目的操作数和源操作数都是相同的。在这些情况下，MOV被移除，例如，MOV rsp,
rsp不会被写入。现在这些指令已经被实现了，如果处理程序还没有完全弹出堆栈，那么它们将从相应的堆栈槽中删除（像P2E,
P2V），值（value）和额外（extra）列保持不变。
值（value） | 值指令（value instructions） | 额外值（extra） | 额外指令（extra instructions）  
---|---|---|---  
rsp |  | addr(rax) |  
从堆栈中弹出也是同样的操作。在堆栈上POP dword rax ：
值（value） | 值指令（value instructions） | 额外值（extra） | 额外指令（extra instructions）  
---|---|---|---  
rdx | SHR rdx, 2 | addr(rdx) |  
结果返回一个空堆栈，可以翻译表示为：
    SHR rdx, 2
    MOV DWORD eax, edx
这种方法有一个小问题。考虑一下上述操作可能产生的这三行指令，前两行源于实现值指令字段，最后一行是实际移动。
    SHL QWORD rax, 2
    ADD QWORD rax, r11
    MOV QWORD rcx, rax
这里的问题是，第一行修改了rax，而第二条指令再次使用。然而，因为所有操作都发生在堆栈上，所以原始的虚拟寄存器不会被更改。在本例中，有一个简单的修复方法：操作的目标寄存器rcx在之前的汇编中没有使用。因此，它可以作为寄存器rax的替代品。这样就可以使用汇编指令MOV
rcx,rax来复制值。而这时，MOV rcx, rax可以省略，因为计算已经使用了rcx：
    MOV rcx, rax
    SHL QWORD rcx, 2
    ADD QWORD rcx, r11
不幸的是，这种方法并不能总是奏效，如下面的例子所示：
    SHL QWORD rax, 1
    ADD QWORD rax, rax
在这种情况下，对移动指令的目标寄存器rax进行计算操作，因此rax被消除。最终目标rax作用与污点寄存器类似。在这些情况下，二进制转换使用r15作为临时寄存器。显然，这个寄存器是可以被使用的，所以它首先存储在堆栈中，在结束时被恢复。我从[rsp-1000]中任意选择。由于除了RET之外虚拟机不使用本地堆栈，所以这应该不会造成任何问题。保存r15之后，它将接收执行MOV