1.入队
入队（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入
元素，新元素的下一个位置将会成为新的队尾。
---
## Page 90
双尾
2.出队
出队操作（dequeue）就是把元素移出队列，只允许在队头一侧移出元
素，出队元素的后一个元素将会成为新的队头。
K头
取尾
3
5
如果像这样不断出队，队头左边的空间
失去作用，那队列的容量岂不是越来越小了？例如像下面这样。
队头
队尾
35149
67
---
## Page 91
问得很好，这正是我后面要讲的。用
数组实现的队列可以采用循环队列
的方式来维持队列容量的恒
定。
循环队列是什么意思呢？让我们看看下面的例子。
假设一个队列经过反复的入队和出队操作，还剩下2个元素，在“物
理”上分布于数组的末尾位置。这时又有一个新元素将要入队。
队头
队尾
67
2
在数组不做扩容的前提下，如何让新元素入队并确定新的队尾位置呢？
我们可以利用已出队元素留下的空间，让队尾指针重新指回数组的首
位。
队尾
队头
6
7
这样一来，整个队列的元素就“循环"起来了。在物理存储上，队尾的位
置也可以在队头之前。当再有元素入队时，将其放入数组的首位，队尾
指针继续后移即可。
队尾
队头
8
6
72
2
一直到（队尾下标+1）%数组长度=队头下标时，代表此队列真的已
经满了。需要注意的是，队尾指针指向的位置永远空出1位，所以队列
---
## Page 92
最大容量比数组长度小1。
队尾
队头
6
7
2
这就是所谓的循环队列，下面让我们
来看一看它的代码实现。
1.private int[] array;
2.private int front;
3.private int rear;
4.
5.public MyQueue(int capacity){
6.
this.array = new int[capacity];
7.}
8.
9./**
10.
*入队
11.
@paramelement
入队的元素
12.
*/
13.
public void enQueue(int element) throws Exception {
14.
if((rear+1)%array.length == front){
---
## Page 93
15.
thrownewException（"队列已满！"）;
16.
17.
array[rear]= element;
18.
rear =(rear+1)%array.length;
19.}
20.
21./**
22.
*出队
23.
*/
24.
public int deQueue() throws Exception {
25.
if(rear == front){
26.
thrownewException（"队列已空！"）;
27.
28.
int deQueueElement = array[front];
29.
front =(front+1)%array.length;
30.
return deQueueElement;
31.}
32.
33./**
34.
*输出队列
35.
*/
36.
public void output(){
37.
for(int i=front; i!=rear; i=(i+1)%array.length){
38.
System.out .println(array[i]);
---
## Page 94
39.
{
40.}
41.
42. public static void main(String[] args) throws Exception {
43.
MyQueue myQueue = new MyQueue(6);
44.
myQueue.enQueue(3);
45.
myQueue.enQueue(5);
46.
myQueue.enQueue(6);
47.
myQueue.enQueue(8);
48.
myQueue.enQueue(1);
49.
myQueue.deQueue();
50.
myQueue.deQueue();
51.
myQueue.deQueue();
52.
myQueue.enQueue(2);
53.
myQueue.enQueue(4);
54.
myQueue.enQueue(9);
55.
myQueue.output();
56.}
循环队列不但充分利用了数组的空
---
## Page 95
间，还避免了数组元素整体移动的麻烦，还真是有点意思呢！至于
入队和出队的时间复杂度，也同样是0(1)吧？
说得完全正确！下面我们来看一看栈
和队列都可以应用在哪些地方。
2.3.6
栈和队列的应用
1.栈的应用
栈的输出顺序和输入顺序相反，所以栈通常用于对“历史"的回溯，也就
是逆流而上追溯“历史”。
例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用
链。
method
fun4
method
fun4
5
栈还有一个著名的应用场景是面包屑导航，使用户在浏览页面时可以轻
松地回溯到上一级或更上一级页面。
---
## Page 96
0Bro
②Compare
OrderConfimmationOCheckout
2.队列的应用
队列的输出顺序和输入顺序相同，所以队列通常用于对“历史"的回放，
也就是按照“历史"顺序，把“历史”重演一遍。
例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线
程在队列中的次序的。
再如网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，
再按照存入队列的顺序来依次抓取和解析的。
http://www.ccc.com
http://www.bbb.com
http://www.aaa.com
3.双端队列
那么，有没有办法把栈和队列的
特点结合起来，既可以先入先出，也可以先入后出呢？
---
## Page 97
还真有，这种数据结构叫作双端队列
(deque)
队头
队尾
35149
6
双端队列这种数据结构，可以说综合了栈和队列的优点，对双端队列来
说，从队头一端可以入队或出队，从队尾一端也可以入队或出队。
有关双端队列的细节，感兴趣的读者可以查阅资料做更多的了解。
4.优先队列
还有一种队列，它遵循的不是先入先出，而是谁的优先级最高，谁先出
队。
这种队列叫作优先队列。
35
1
4
6
2
优先队列已经不属于线性数据结构的范畴了，它是基于二叉堆来实现
---
## Page 98
的。关于优先队列的原理和使用情况，我们会在下一章进行详细介绍，
好了，关于栈和队列的知识我们就介
绍到这里，下一节再见！
22.4
神奇的散列表
2.4.1
为什么需要散列表
大黄，你觉得对程序员
来说英语能力重要吗？
---
## Page 99
当然重要喽：无论是在外企
工作，还是阅读国外的技术
资料，能够使用英语交流和
阅读都是必不可少的技能。
哎，我上学时那点可怜的
英语基础都还给老师啦：
哈哈。不要紧，学习英语
什么时候开始都不算晚！
说起学习英语，小灰上学时可没有那么丰富的学习资源和工具。当时有
一款很流行的电子词典，小伙伴们遇到不会的单词，只要输入到小小的
电子词典里，就可以查出它的中文含义。
输入框
Apple_
中文
苹果
---
## Page 100
当时的英语老师强烈反对使用这样的工具，因为电子词典查出来的中文
资料太有限，而传统的纸质词典可以查到单词的多种含义、词性、例句
等。
但是，同学们还是倾向于使用电子词典。因为电子词典实在太方便了，
只要输入要查的单词，一瞬间就可以得到结果，而不需要像纸质词典那
样烦琐地进行人工查找。
在我们的程序世界里，往往也需要在内存中存放这样一个“词典”，方便
我们进行高效的查询和统计。
例如开发一个学生管理系统，需要有通过输入学号快速查出对应学生的
姓名的功能。这里不必每次都去查询数据库，而可以在内存中建立一个
缓存表，这样做可以提高查询效率。
学号
姓名
001121
张三
002123
李四
002931
王五
003278
赵六
再如我们需要统计一本英文书里某些单词出现的频率，就需要遍历整本
书的内容，把这些单词出现的次数记录在内存中。
---
## Page 101
单词
出现次数
this
108
and
56
are
79
6q
46
因为这些需求，一个重要的数据结构诞生了，这个数据结构叫作散列表
散列表也叫作哈希表
（hashtable），这种数据结构提供了键（Key）
和值（Value）
的映射关系。只要给出
一个Key，就可以高效查找到它
所匹配的Value，时间复杂度接近于O(1)。
Key
Value
Key3
Key1
Value1
Key2
Value2
Key3
Value3
Value3
Key4
Value4
那么，散列表是如何根据Key来
快速找到它所匹配的Value呢？
---
## Page 102
这就是我下面要讲的散列表的基本原
理。
2.4.2
哈希函数
小灰，在咱们之前学过的几个数据结
构中，谁的查询效率最高？
当然是数组喽，数组可以根据下
标，进行元素的随机访问。
---
## Page 103
说得没错，散列表在本质上也是一个
数组。
可是数组只能根据下标，像a[0]、a[1]、
a[2]、a[3]、a[4]这样来访问，而散列表的Key则是以字符串类型为
主的。
例如以学生的学号作为Key，输入
002123，查询到李四：或者以单词为Key，输入by，查询到数字
46......
---
## Page 104
所以我们需要一个“中转站”，通过某
种方式，把Key和数组下标进行转换。这个中转站就叫作哈希函数
Key3
Value1
Value2
哈幕函数
Value3
2
Value3
Value3
Value4
数组
这个所谓的哈希函数是怎么实现的呢？
在不同的语言中，哈希函数的实现方式是不一样的。这里以Java的常用
集合HashMap为例，来看一看哈希函数在Java中的实现。
在Java及大多数面向对象的语言中，每一个对象都有属于自己的
hashcode，这个hashcode是区分不同对象的重要标识。无论对象自身的
类型是什么，它们的hashcode都是一个整型变量。
既然都是整型变量，想要转化成数组的下标也就不难实现了。最简单的
转化方式是什么呢？是按照数组长度进行取模运算。
index=HashCode(Key)%Array.length
实际上，JDK（JavaDevelopmentKit，Java语言的软件开发工具包）中
的哈希函数并没有直接采用取模运算，而是利用了位运算的方式来优化
性能。不过在这里可以姑且简单理解成取模操作。
通过哈希函数，我们可以把字符串或其他类型的Key，转化成数组的下
---
## Page 105
标index。
如给出一个长度为8的数组，则当
key=001121时，
index =HashCode ("001121") % Array.length =
1420036703%8=7
而当key=this时，
index=HashCode("this")%Array.length=3559070 % 8
=6
2.4.3散列表的读写操作
有了哈希函数，就可以在散列表中进行读写操作了。
1.写操作（put)
写操作就是在散列表中插入新的键值对（在JDK中叫作Entry）。
如调用hashMap.put("002931"，"王五")，意思是插入一组Key为002931、
Value为王五的键值对。
具体该怎么做呢？
第1步，通过哈希函数，把Key转化成数组下标5。
第2步，如果数组下标5对应的位置没有元素，就把这个Entry填充到数
组下标5的位置。
Null
Nul
Nul
Null
Nul
---
## Page 106
但是，由于数组的长度是有限的，当插入的Entrv越来越多时，不同的
Key通过哈希函数获得的下标有可能是相同的。例如002936这个Key对
应的数组下标是2；002947这个Key对应的数组下标也是2。
Q
2
3
5
7
cntru.
Null
Entryl
Entry5
Null
Null
index=2
这种情况，就叫作哈希冲突。
哎呀，哈希函数“撞衫”了，这该
怎么办呢？
哈希冲突是无法避免的，既然不能避
免，我们就要想办法来解决。解决哈希冲突的方法主要有两种，
种是开放寻址法，一种是链表法。
开放寻址法的原理很简单，当一个Key通过哈希函数获得对应的数组下
标已被占用时，我们可以“另谋高就”，寻找下一个空档位置。
以上面的情况为例，Entry6通过哈希函数得到下标2，该下标在数组中
---
## Page 107