perform taint analysis, one needs to identify sources and
sinks of possibly-tainted data. This amounts to identifying
methods that originate a tainted value and methods that use
a possibly-tainted value. Livshits and Lam’s analysis al-
gorithm [28] requires prior computation of a speciﬁc ﬂow-
insensitive points-to heap analysis and assumes the pres-
ence of programmer-supplied descriptors for sources and
sinks. Additionally, their algorithm requires the presence
of descriptors for library methods handling objects through
which taintedness may ﬂow. This approach does not han-
dle indirect ﬂows. By contrast, the algorithm described in
this paper takes into account indirect ﬂows and does not re-
quire any programmer-deﬁned descriptor. Pistoia et al.[33]
use program slicing to detect tainted variables in privilege-
asserting code. The work presented in this paper subsumes
that work, as observed in Section 4.1.
Stoughton [38] compares access control and informa-
tion ﬂow in a simple imperative language with semaphores.
No formal results are proven, nor is there a static analysis
for information ﬂow. Myers’ Jif tool [29] uses type-based
static analysis [41, 13] to track information ﬂow in Java,
but like in many other works the information-ﬂow policy
is expressed by a static labeling assumed given. Baner-
jee and Naumann [6] augment such a type system with
an effect analysis for SBAC, and allow that a procedure’s
labeling may depend on the permissions authorized for it
at runtime; noninterference is proved (and has even been
machine-checked [30]). However, their information lat-
tice is separate from permissions. They also adapt their
system to HBAC, where the dynamic permissions can be
exploited as a storage channel [5]. Barthe and Rezk [8]
prove noninterference for a security type system for Java
bytecode. Barthe et al. [7] prove that typable source code
compiles to typable bytecode. Zhao and Boyland [45] com-
bine type-based and dynamic checks to improve security of
stack inspection by tracking data ﬂows. However, they do
not consider implicit ﬂow. In contrast to static checking of
noninterference, Le Guernic, et al. [22] consider dynamic,
automaton-based, monitoring of information ﬂow for a sin-
gle execution of a sequential program. The mechanism is
based on a combination of dynamic and static analyses. The
dynamic analysis accepts or rejects a single execution of a
program without necessarily doing the same for all other ex-
ecutions. The automaton is used to guarantee conﬁdential-
ity of secret data and takes into account direct as well as im-
plicit ﬂows. The static analysis is used to overapproximate
implicit indirect ﬂows—that is, the branches not executed
during the execution of conditionals—and to generate cor-
responding branch-not-taken inputs to the automaton. This
is similar in spirit to the write oracle in our semantics. On
the other hand, that work does not consider the derivation of
an information-ﬂow policy from an access-control policy.
A number of works focus on stack inspection as an
access-control policy enforcement, with the purpose of
deﬁning alternative implementations and studying opti-
mization techniques. Wallach, et al. [44, 43] present an
approach called Security Architecture Formerly Known as
Stack Inspection (SAFKASI), which uses the calculus of
Security-Passing Style (SPS) to enforce a form of access
control equivalent to stack inspection. Pottier et al.[34] ex-
tend and formalize the SPS calculus via type theory using a
λ-calculus, called λsec. Jensen, et al. [25] focus on proving
that code is secure with respect to a global security policy.
Their model uses operational semantics to prove the prop-
erties, using a two-level temporal logic, and shows how to
detect redundant authorization tests. Bartoletti, et al. [9]
are interested in optimizing performance of run-time autho-
rization tests by eliminating redundant tests and relocating
others as needed. Rather than analyzing security policies as
embodied by existing code, Erlingsson and Schneider [40]
describe a system that inlines reference monitors into the
code to enforce speciﬁc security policies. This approach can
reduce or eliminate redundant authorization tests. Koved,
et al. [27] use static analysis for identiﬁcation of permission
requirements. Besson, et al. [10] present a static analysis
technique for verifying the security of libraries in SBAC
systems.
7 Discussion
In this paper, we have introduced IBAC, a new access-
control model that, for any security-sensitive operation,
veriﬁes that all the code responsible for that operation
is sufﬁciently authorized.
IBAC automatically infers the
information-ﬂow policy labels for a program from an exist-
ing access-control policy associated with the program, and
transforms existing access-control tests into information-
ﬂow tests. The idea behind IBAC comes from a process
that happens quite often in production-level code; precisely,
code that was written to run without SBAC enforcement,
is later required to run with SBAC enabled. System ad-
ministrators must ﬁgure out which permissions that code
requires, and developers must insert grant calls appropri-
ately to prevent unnecessary permission requirements from
percolating up the stack and affect client code. However, an
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:51 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007inherent ﬂaw in SBAC is that code inﬂuencing a security-
sensitive operation may no longer be on the stack of execu-
tion for that operation. Therefore, an SBAC test call may
fail to verify the permission assignments of all the code as-
sociated with a security-sensitive action, and a grant call
may allow untrusted code to inﬂuence, through tainted vari-
ables, the execution of trusted library code. Furthermore, in
this paper, we have compared IBAC to HBAC and demon-
strated that IBAC permits the execution of safe programs
that HBAC would instead reject.
SBAC is also vulnerable to conﬁdentiality attacks in sys-
tems that enforce capability-based security. Consider for
example the Java program in Figure 4. As observed in Sec-
tion 4.1, IBAC accepts that program. Suppose, however,
that the FileOutputStream object created in F.main
is inadvertently allowed to escape the security context in
which it was created. For example, it could be passed
as a parameter to a method m4 of an object h of type H,
or stored into the heap by F.main and subsequently ac-
cessed by h, where H is a class with no FilePermission
"passwords.txt", "write". Now, h.m4 could call
write on that FileOutputStream object, and its per-
missions are not checked since no object of type H was
on the stack when that FileOutputStream object was
created—a conﬁdentiality violation. This paper has dis-
cussed the integrity aspects of IBAC. In the future, we
would like to extend this work to conﬁdentiality as well.
Another interesting area of research is how to integrate
IBAC with a mechanism for declassiﬁcation.
So far, we have implemented a subsystem of IBAC,
which only enforces the rejection of integrity violations
caused by tainted variables in privilege-asserting code. We
plan to have a full implementation of IBAC enforcement
and to validate its usefulness on production-level code that
has adopted SBAC as its form of access control.
References
[1] M. Abadi and C. Fournet. Access Control Based on Ex-
ecution History.
In Proceedings of the 11th Network and
Distributed System Security Symposium (NDSS 2003), San
Diego, CA, USA, Feb. 2003.
[2] T. Amtoft, S. Bandhakavi, and A. Banerjee. A Logic for In-
formation Flow in Object-Oriented Programs. In Proceed-
ings of the 33rd ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (POPL 2006), pages
91–102, Charleston, SC, USA, Jan. 2006. Extended version
as KSU CIS-TR-2005-1.
[3] L. O. Andersen. Program Analysis and Specialization for
the C Programming Language. PhD thesis, University of
Copenhagen, Copenhagen, Denmark, May 1994.
[4] K. Ashcraft and D. Engler. Using Programmer-Written
Compiler Extensions to Catch Security Holes. In Proceed-
ings of the 2002 IEEE Symposium on Security and Privacy,
pages 143–159, Oakland, CA, USA, May 2002. IEEE Com-
puter Society.
[5] A. Banerjee and D. A. Naumann. History-based Ac-
cess Control and Secure Information Flow.
In G. Barthe,
L. Burdy, M. Huisman, J.-L. Lanet, and T. Muntean, editors,
Construction and Analysis of Safe, Secure, and Interopera-
ble Smart Devices, International Workshop (CASSIS 2004),
Revised Selected Papers, volume 3362 of Lecture Notes in
Computer Science, 2005.
[6] A. Banerjee and D. A. Naumann. Stack-based Access Con-
trol for Secure Information Flow. Journal of Functional
Programming, 15(2):131–177, Mar. 2005. Special Issue on
Language Based Security.
[7] G. Barthe, D. A. Naumann, and T. Rezk. Deriving an Infor-
mation Flow Checker and Certifying Compiler for Java. In
27th IEEE Symposium on Security and Privacy, pages 230–
242, Oakland, CA, USA, May 2006.
[8] G. Barthe and T. Rezk. Non-interference for a JVM-like
In M. F¨ahndrich, editor, Proceedings of 2005
Language.
ACM SIGPLAN International Workshop on Types in Lan-
guages Design and Implementatio (TLDI 2005), pages 103–
112, Long Beach, CA, USA, Jan. 2005. ACM Press.
[9] M. Bartoletti, P. Degano, and G. L. Ferrari. Static Analysis
for Stack Inspection. In Proceedings of International Work-
shop on Concurrency and Coordination, Electronic Notes in
Theoretical Computer Science, volume 54, Amsterdam, The
Netherlands, 2001. Elsevier.
[10] F. Besson, T. Blanc, C. Fournet, and A. D. Gordon. From
Stack Inspection to Access Control: A Security Analysis for
Libraries. In Proceedings of the 17th IEEE Computer Secu-
rity Foundations Workshop (CSFW-17 2004), pages 61–75,
Paciﬁc Grove, CA, USA, June 2004. IEEE Computer Soci-
ety.
[11] M. Bishop and M. Dilger. Checking for Race Conditions
in File Accesses. Computing Systems, 9(2):131–152, Spring
1996.
[12] D. E. Denning. A Lattice Model of Secure Information
Flow. Communications of the ACM, 19(5):236–243, May
1976.
[13] D. E. Denning and P. J. Denning. Certiﬁcation of Programs
for Secure Information Flow. Communications of the ACM,
20(7):504–513, July 1977.
[14] Eclipse Project, http://www.eclipse.org.
[15] Equinox
Security
Java
Project,
http://www.
eclipse.org/equinox/incubator/security/
java2security.html.
[16] J. S. Fenton. Memoryless Subsystems. The Computer Jour-
nal, 17(2):143–147, 1974.
[17] J. S. Foster, T. Terauchi, and A. Aiken. Flow-Sensitive
Type Qualiﬁers. In Proceedings of the 2002 ACM SIGPLAN
Conference on Programming Language Design and Imple-
mentation (PLDI 2002), pages 1–12, Berlin, Germany, June
2002.
[18] C. Fournet and A. D. Gordon. Stack Inspection: Theory
and Variants. In Proceedings of the 29th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Lan-
guages (POPL 2002), pages 307–318, Portland, OR, USA,
Jan. 2002. ACM Press.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:51 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007[19] J. A. Goguen and J. Meseguer. Security Policies and Secu-
rity Models. In Proceedings of the 1982 IEEE Symposium
on Security and Privacy, pages 11–20, Oakland, CA, USA,
May 1982. IEEE Computer Society Press.
[20] L. Gong, M. Mueller, H. Prafullchandra, and R. Schemers.
Going Beyond the Sandbox: An Overview of the New Se-
curity Architecture in the Java Development Kit 1.2.
In
USENIX Symposium on Internet Technologies and Systems,
Monterey, CA, USA, Dec. 1997.
[21] D. Grove and C. Chambers. A Framework for Call Graph
Construction Algorithms. ACM Trans. Program. Lang. Syst.,
23(6):685–746, November 2001.
[22] G. L. Guernic, A. Banerjee, T. Jensen, and D. A. Schmidt.
Automata-based Conﬁdentiality Monitoring.
In Proceed-
ings of 11th Annual Asian Computing Science Conference
(ASIAN 2006), Tokio, Japan, Dec. 2006.
[23] C. Hammer, J. Krinke, and G. Snelting. Information Flow
Control for Java Based on Path Conditions in Dependence
Graphs. In Proceedings of IEEE International Symposium
on Secure Software Engineering, Arlington, VA, USA, Mar.
2006.
[24] N. Hardy. The Confused Deputy. ACM SIGOPS Operating
Systems Review, 22(4):36–38, Oct. 1988.
[25] T. P. Jensen, D. L. M´etayer, and T. Thorn. Veriﬁcation of
Control Flow Based Security Properties. In Proceedings of
the 1999 IEEE Symposium on Security and Privacy, pages
89–103, Oakland, CA, USA, May 1999.
[26] G. A. Kildall. A Uniﬁed Approach to Global Program Op-
timization. In Proceedings of the 1st Annual ACM SIGACT-
SIGPLAN Symposium on Principles of Programming Lan-
guages, pages 194–206, Boston, MA, USA, 1973. ACM
Press.
[27] L. Koved, M. Pistoia, and A. Kershenbaum. Access Rights
Analysis for Java.
In Proceedings of the 17th ACM SIG-
PLAN Conference on Object-Oriented Programming, Sys-
tems, Languages, and Applications, pages 359–372, Seattle,
WA, USA, November 2002. ACM Press.
[28] V. B. Livshits and M. S. Lam. Finding Security Vulnerabil-
ities in Java Applications with Static Analysis. In Proceed-
ings of the 14th USENIX Security Symposium, Baltimore,
MD, USA, July 2005.
[29] A. C. Myers.
JFlow: Practical Mostly-static Information
Flow Control. In Proceedings of the 26th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Lan-
guages (POPL 1999), pages 228–241, San Antonio, TX,
USA, Jan. 1999.
[30] D. A. Naumann. Verifying a Secure Information Flow Ana-
lyzer. In J. Hurd and T. Melham, editors, 18th International
Conference on Theorem Proving in Higher Order Logics
TPHOLs 2005, volume 3603 of Lecture Notes in Computer
Science, pages 211–226, Oxford, UK, Aug. 2005. Springer.
[31] J. Newsome and D. X. Song. Dynamic Taint Analysis for
Automatic Detection, Analysis, and Signature Generation
of Exploits on Commodity Software. In Proceedings of the
12th Network and Distributed System Security Symposium
(NDSS 2005), San Diego, CA, USA, Feb. 2005. IEEE Com-
puter Society.
[32] N. Paul and D. Evans.
.NET Security: Lessons Learned
and Missed from Java. In Proceedings of the 20th Annual
Computer Security Applications Conference (ACSAC 2004),
pages 272–281, Washington, DC, USA, December 2004.
IEEE Computer Society.
[33] M. Pistoia, R. J. Flynn, L. Koved, and V. C. Sreedhar. In-
terprocedural Analysis for Privileged Code Placement and
Tainted Variable Detection. In Proceedings of the 19th Euro-
pean Conference on Object-Oriented Programming, pages
362–386, Glasgow, Scotland, UK, July 2005. Springer-
Verlag.
[34] F. Pottier, C. Skalka, and S. F. Smith. A Systematic Ap-
proach to Static Access Control. In Proceedings of the 10th
European Symposium on Programming Languages and Sys-
tems, pages 30–45. Springer-Verlag, 2001.
[35] J. H. Saltzer and M. D. Schroeder. The Protection of Infor-
mation in Computer Systems. In Proceedings of the IEEE,
volume 63, pages 1278–1308, Sept. 1975.
[36] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. De-
tecting Format String Vulnerabilities with Type Qualiﬁers.
In Proceedings of the 10th USENIX Security Symposium,
Washington, DC, USA, Aug. 2001.
[37] G. Snelting, T. Robschink, and J. Krinke. Efﬁcent Path Con-
ditions in Dependence Graphs for Software Safety Analysis.
ACM Transactions on Software Engineering and Methodol-
ogy (TOSEM), 15(4):410–457, October 2006.
[38] A. Stoughton. Access Flows: A Protection Model which In-
tegrates Access Control and Information Flow. In Proceed-
ings of the 1981 IEEE Symposium on Security and Privacy,
pages 9–18, Oakland, CA, USA, May 1981.
[40]
[39] IBM Security Workbench Development Environment for
Java (SWORD4J), http://www.alphaworks.ibm.
com/tech/sword4j.
´Ulfar Erlingsson and F. B. Schneider. IRM Enforcement of
Java Stack Inspection.
In Proceedings of the 2000 IEEE
Symposium on Security and Privacy, pages 246–255, Oak-
land, CA, USA, May 2000. IEEE Computer Society.
[41] D. Volpano, C. Irvine, and G. Smith. A Sound Type System
for Secure Flow Analysis. Journal of Computer Security,
4(2-3):167–187, Jan. 1996.
[42] L. Wall, T. Christiansen, and J. Orwant. Programming Perl.
O’Reilly & Associates, Inc., Sebastopol, CA, USA, third
edition, July 2000.
[43] D. S. Wallach, A. W. Appel, and E. W. Felten. SAFKASI:
A Security Mechanism for Language-based Systems. ACM
Transactions on Software Engineering and Methodology
(TOSEM), 9(4):341–378, 2000.
[44] D. S. Wallach and E. W. Felten. Understanding Java Stack
Inspection.
In Proceedings of the 1998 IEEE Symposium
on Security and Privacy, pages 52–63, Oakland, CA, USA,
May 1998.
[45] T. Zhao and J. T. Boyland. Type Annotations to Improve
Stack-Based Access Control.
In 18th IEEE Computer Se-
curity Foundations Workshop (CSFW-18 2005), pages 197–
210, Aix-en-Provence, France, June 2005. IEEE Computer
Society.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:51 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007