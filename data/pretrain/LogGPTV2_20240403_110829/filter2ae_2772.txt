# SaltStack远程执行代码多个高危漏洞透析（CVE-2021-25281/25282/25283）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
北京时间2月26日凌晨3点，SaltStack官方发布高危漏洞风险通告，包含CVE-2021-25281、25282、25283。此前，云鼎实验室安全研究员1mperio就曾发现该漏洞，并于2020年11月16日报送给SaltStack官方。
在对CVE-2020-17490和CVE-2020-16846进行分析后，发现CVE-2020-17490的补丁存在未修补完全的情况，导致wheel_async仍然存在未授权访问，可以调用wheel模块中的方法，基于此对SaltStack的wheel模块中的方法进行分析，最终发现加载配置模块存在模板注入，可以实现未授权远程代码执行。
## 引言
SaltStack是VMware子公司，其产品用于运维管理，能够支持数万台服务器，主要功能是配置文件管理和远程执行命令，十分易用且强大，在github有11.4k
star。
SaltStack只用python开发，采用C/S架构，其中Server被称为Master，Client被称为Minion，即一个Master能够向多个Minion下发配置文件，远程执行命令。SlatStack是系统总称，主要有salt、salt-master、salt-minion、salt-api等程序组成，其中salt-master和salt-minion的功能为从指定路径读取配置文件并启动。salt-master监听4505和4506端口，分别用于发布消息和接受监控数据。
salt程序可以调用大量函数，并可以指定minion或指定一组minion作为目标。salt-api可以使用cherrypy或tornado来对外提供REST接口，默认使用cherrypy。
本文主要对salt-master和salt-api展开讨论。
文中指定代码位置采用以下约定：FileLocation:Classname.method()或FileLocation:Method()
## CVE-2021-25281 未授权访问
通过分析CVE-2020-25592的
https://gitlab.com/saltstack/open/salt-patches/-/blob/master/patches/2020/09/25/3002.patch
可以发现
，补丁通过调用认证模块对SSH方法进行权限认证，而salt/salt/netapi/init.py:NetapiClient.run()方法通过getattr动态调用NetapiClient类中的方法，并将args和kwargs作为参数传入。
该类中可调用的方法有
    — local
    — local_async
    — local_batch
    — local_subset
    — runner
    — runner_async
    — ssh
    — wheel
    — wheel_async
经过分析，其中，wheel_async方法存在未授权调用，其他方法(除去SSH)均为生成一个job到zeromq，其后进行消费者再进行认证，而wheel_async异步调用wheel包中的方法。
调用链如下：
salt/salt/netapi/init.py:NetapiClient.run() ⇒
salt/salt/netapi/init.py:NetapiClient.wheel_async() ⇒
salt/salt/wheel/init.py:WheelClient.cmd_async() ⇒
salt/salt/client/mixins.py:AsyncClientMixin.asynchronous()
salt/salt/client/mixins.py:AsyncClientMixin.asynchronous()
这里的目标函数是self._proc_function，low参数为POST可控参数，fun参数的值在salt/salt/wheel/init.py:WheelClient.cmd_async()方法中通过low参数的fun键获取。
这里通过salt/salt/client/mixins.py:AsyncClientMixin._proc_function()函数调用salt/salt/client/mixins.py:SyncClientMixin.low()，并通过该函数使用args参数和kwargs参数动态调用wheel包中的方法。
salt/salt/client/mixins.py:SyncClientMixin.low()
可调用的方法如下：
    config.apply
    config.update_config
    config.values
    error.error
    file_roots.find
    file_roots.list_env
    file_roots.list_roots
    file_roots.read
    file_roots.write
    key.accept
    key.accept_dict
    key.delete
    key.delete_dict
    key.finger
    key.finger_master
    key.gen
    key.gen_accept
    key.gen_keys
    key.gen_signature
    key.get_key
    key.print
    key.list
    key.list_all
    key.master_key_str
    key.name_match
    key.reject
    key.reject_dict
    minions.connected
    pillar_roots.find
    pillar_roots.list_env
    pillar_roots.list_roots
    pillar_roots.read
    pillar_roots.write
## CVE-2021-25282 有限制任意文件写漏洞
其中salt/salt/wheel/pillar_roots.py:write()方法存在任意写入文件漏洞，不过需要__opts__[“pillar_roots”]中的路径存在。  
这里的读文件是没有办法利用的，由于是异步调用，所以返回的是jid和tag，通过jid和tag去查询任务执行的结果时是有认证的。
salt/salt/wheel/pillar_roots.py:write()
## CVE-2021-25283 模板注入漏洞
通过—log-level=debug参数开启debug模式，定位到了master自动加载的逻辑。  
salt/salt/master.py:Maintenance.run()
从代码中可以看出，每一个self.loop_interval将循环一次，loop_interval在配置文件中可以配置，默认为60s。通过debug发现在salt.daemons.masterapi.clean_old_jobs中读取minion配置文件。
调用栈如下：
salt/salt/daemons/masterapi.py:clean_old_jobs() ⇒
salt/salt/minion.py:MasterMinion.init() ⇒
salt/salt/config/init.py:minion_config()
在
salt/salt/minion.py:MasterMinion.init()中发现，自动加载值加载grains相关的参数，grains为saltstack收取各个minion中系统信息的功能。
salt/salt/minion.py:MasterMinion.init()
salt/salt/config/init.py:minion_config()
可以看到minio在加载配置文件的时候调用了一个很诱人的方法apply_sdb()，这个方法解析配置中以sdb://开头的字符串。
salt/salt/config/init.py:apply_sdb()
salt/salt/utils/sdb.py:sdb_get()
在这个函数中sdb://aaaa/bbbb字符串，saltstack将会在配置文件中找aaaa这个配置项，并读取其中driver字段，赋值给fun变量，经bbbb赋值给query参数。最后的salt.loader.sdb(opts,
fun,
utils=utils)是一个动态调用，通过LazyLoader加载fun变量值对应的方法，并调用，其中LazyLoader将加载salt.sdb包下的所有文件，并调用其中的get方法。
经过查找，最终定位到salt/salt/sdb/rest.py文件。
salt/salt/sdb/rest.py:query()
在这里，key为上述字符串中bbbb的值，可以看到这里还接收形如bbbb?ccc=ddd的参数，并且通过**key_vars传递到compile_template方法中。
这里的render使用的是jinja，众所周知，jinja是可以进行模板注入的，也就是说，在模板可控的情况下，如果不存在过滤，将可以执行任意代码，并且这里传入的参数是profile[key][‘url’]，也就是配置文件中aaaa配置项中bbbb字典url的值。compile_template函数详情如下：
salt/salt/template.py:compile_template()
这里的render调用的是salt/salt/renderers/jinja.py中的render方法，调用链如下：
salt/salt/template.py:compile_template() ⇒
salt/salt/utils/templates.py:JINJA() ⇒
salt/salt/utils/templates.py:wrap_tmpl_func() ⇒
salt/salt/utils/templates.py:render_jinja_tmpl()
最后调用到render_jinja_tmpl中的template.render()方法，在此处渲染模板，此中并未对传入的参数进行过滤，可以进行模板注入。
但自动加载的逻辑中未加载master的配置文件，但经过翻找，发现某个方法调用了master_config方法，master_config和minion_config一样，都调用了apply_sdb()方法，从而能够实现未授权RCE。
## 修复建议
尽快更新官方补丁。  
如果没有用到wheel_async模块，可以在salt/netapi/init.py中将其入口删除。