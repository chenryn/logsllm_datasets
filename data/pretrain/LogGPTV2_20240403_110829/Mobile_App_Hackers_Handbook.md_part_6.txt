dissecting-evasi0n.html), whereas a complete analysis of the userland portions are detailed by Accuvant
(http://blog.accuvant.com/bthomasaccuvant/evasi0n- jailbreaks-userland-component/) and Quarkslab
(http://blog.quarkslab.com/evasi0n-jailbreak-precisions-on-stage-3.html). The evad3rs team has
also previously documented its work in a HackInTheBox presentation
(http://conference.hitb.org/hitbsecconf2013ams/materials/ D2T1%20-
%20Pod2g,%20Planetbeing,%20Musclenerd%20and%20Pimskeks%20aka%20Evad3rs%20-
%20Swiping%20Through%20Modern%20Security%20Features.pdf).
evasi0n7 JAILBREAK
The evasi0n7 jailbreak was the second jailbreak to be released by the evad3rs team and affected iOS
versions 7.0 through 7.1 beta 3 with the exception of the Apple TV. In a similar style to the earlier evasi0n
jailbreak, evasi0n7 used a series of impressive tricks to bypass the userland mitigations on the device. The
jailbreak was able to coerce afcd into accessing the root filesystem, evading the service’s sandbox profile
by injecting a dynamic library, which used a code-signing bypass (CVE-2014-1273) to nullify the relevant
sandbox functions. A chain of other vulnerabilities were used, including a vulnerability in
CrashHouseKeeping (CVE-2014-1272), which was used to change the permissions on /dev/rdisk0s1s1 and
gain write-access to the root filesystem by writing directly to the block device. After userland code
execution was achieved, an out-of-bounds array access vulnerability in the ptmx_get_ioctl (CVE-2014-
1278) Input/Output Control (IOCTL) was used to elevate privileges. geohot published a detailed analysis
of the userland portion of this jailbreak (http://geohot.com/e7writeup.html), and further analysis of the
userland and kernel exploits have been detailed by Braden Thomas and p0sixninja, respectively
(http://theiphonewiki.com/wiki/Evasi0n7).
Building a Test Environment
After you have a jailbroken device, you are likely to want to set up your environment to build, test, and explore
iOS applications. This section details some of the tools you can use to build a basic test environment, gain access
to the device as well as to the various locations of interest on the device, and the types of files that you may
encounter.
Accessing the Device
You will need to log on to your jailbroken device to explore both the device and its applications and build your
testing environment. The fastest way to access your device is to install the OpenSSH package
(http://cydia.saurik.com/ package/openssh/) through Cydia (detailed in the following section). Predictably
this causes the OpenSSH service to be installed to the device, listening on all interfaces. To connect to the
service you can either join the device to your Wi-Fi network and SSH directly to it using the Wi-Fi interface, or
connect to the device over the USB using the USB multiplexing daemon. If your host operating system is not OS
X, the latter of these options requires the usbmuxd service to be installed, as detailed in the “Installing
Applications” section of this chapter. To forward a local TCP port over the USB connection, you can use the
tcprelay .py script in the usbmuxd python client or alternatively using iproxy if your host operating system is
Linux, as shown in the following examples.
To forward local port 2222 to port 22 on the iOS device using tcprelay.py:
$ ./tcprelay.py 22:2222
Forwarding local port 2222 to remote port 22
To forward local port 2222 to port 22 on the iOS device using iproxy:
$ iproxy 2222 22
When the port forwarding is enabled, you can connect to the device simply by using SSH to connect to the port
being forwarded on the localhost:
$ ssh -p 2222 root@localhost
Every iOS device comes with a default password of “alpine” for the root and mobile user accounts, which you
can use to access the device over SSH. To avoid someone inadvertently accessing your device, you should change
these passwords after your first logon.
Building a Basic Toolkit
Tools are an important part of any security professional’s arsenal and when assessing an iOS application,
installing some basic tools can make your life a little easier. Some of these are relatively unique to iOS, whereas
others you may be more familiar with if you have had exposure to other UNIX-like systems.
Cydia
Cydia (https://cydia.saurik.com/) is an alternative to Apple’s App Store for jailbroken devices and is installed
with many of the jailbreak applications. Cydia comes in the form of an iOS application that provides a graphic
user interface to the popular Advanced Packaging Tool (APT). You may be familiar with APT as it is widely used
for package management in other UNIX-like systems such as Linux’s Debian distribution. Cydia allows you to
install a variety of precompiled packages for your iOS device, including applications, extensions, and command-
line tools. Software packages are bundled in the deb file format; you can download them from any Cydia
repository. Repositories can be configured using the Sources option within the Cydia user interface. Cydia
provides a window to install many of the other tools that you can use in your test environment, as detailed in
the following sections.
BigBoss Recommended Tools
When you first log on to your iOS device you will discover that many of the command-line tools that you may be
used to finding on other UNIX-like systems are missing. This is because iOS is stripped back to the bare bones
and includes only necessary tools used by the operating system and associated services. To make iOS a little
more user friendly you can install the BigBoss recommended tools package from
http://apt.thebigboss.org/onepackage.php?bundleid=bigbosshackertools. This package does nothing itself
but has a number of useful dependencies registered against it, which means that these all get installed in one
fell swoop. The package contains essential command-line utilities such as those included in the coreutils,
system-cmds, and adv-cmds packages, all created as part of saurik’s Telesphoreo project
(http://www.saurik.com/id/1). The BigBoss package also forces the install of the apt package; for those familiar
with Debian’s package management system, this provides the command-line tools to install, update, and remove
other packages.
Apple’s CC Tools
During the course of an iOS application assessment, you likely will need to analyze or manipulate the
application binary. Apple’s CC Tools project (http://www.opensource.apple.com/source/cctools/) provides an
open source toolkit to do exactly that, containing a number of utilities to parse, assemble, and link Mach-O
binaries (the file format used by iOS/OS X applications). If you do any development on a Mac you are likely
familiar with many of these utilities because they come as part of the iOS and OS X development toolchain. CC
Tools can also be compiled under Linux when used as part of the iPhone-Dev project’s toolchain
(https://code.google.com/p/iphone-dev/). The following sections briefly describe some of the tools contained
in the toolchain, along with practical examples.
otool
otool, the object file-displaying tool, is the Swiss army knife of Mach-O binary analysis. It contains the
necessary functionality to parse the Mach-O file format and inspect the relevant properties of a binary or library.
The following examples describe how to use otool to extract assessment-relevant information from a decrypted
application binary (outputs truncated for brevity):
Inspect the Objective-C segment to reveal class and method names:
$ otool -oV MAHHApp
MAHHApp (architecture armv7):
Contents of (__DATA,__objc_classlist) section
0000c034 0xc5cc _OBJC_CLASS_$_ViewController
isa 0xc5e0 _OBJC_METACLASS_$_ViewController
superclass 0x0
cache 0x0
vtable 0x0
data 0xc098 (struct class_ro_t *)
flags 0x80
instanceStart 158
instanceSize 158
ivarLayout 0x0
name 0xbab9 ViewController
baseMethods 0xc078 (struct method_list_t *)
entsize 12
count 2
name 0xb3f8 viewDidLoad
types 0xbaff v8@0:4
imp 0xafd1
name 0xb404 didReceiveMemoryWarning
types 0xbaff v8@0:4
imp 0xb015
baseProtocols 0x0
ivars 0x0
weakIvarLayout 0x0
baseProperties 0x0
List the libraries used by the binary:
$ otool -L MAHHApp
MAHHApp (architecture armv7):
/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics
(compatibility version 64.0.0, current version 600.0.0)
/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version
1.0.0, current version 2935.137.0)
/System/Library/Frameworks/Foundation.framework/Foundation
(compatibility version 300.0.0, current version 1047.25.0)
/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version
228.0.0)
/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version
1198.0.0)
List the symbols exported by a binary:
$ otool -IV MAHHApp
MAHHApp (architecture armv7):
Indirect symbols for (__TEXT,__symbolstub1) 9 entries
address index name
0x0000bfdc 111 _UIApplicationMain
0x0000bfe0 103 _NSStringFromClass
0x0000bfe4 113 _objc_autoreleasePoolPop
0x0000bfe8 114 _objc_autoreleasePoolPush
0x0000bfec 116 _objc_msgSendSuper2
0x0000bff0 117 _objc_release
0x0000bff4 118 _objc_retain
0x0000bff8 119 _objc_retainAutoreleasedReturnValue
0x0000bffc 120 _objc_storeStrong
Display the short-form header information:
$ otool -hV MAHHApp
MAHHApp (architecture armv7):
Mach header
magic cputype cpusubtype caps filetype ncmds sizeofcmds
flags
MH_MAGIC ARM V7 0x00 EXECUTE 22 2212
NOUNDEFS DYLDLINK TWOLEVEL PIE
MAHHApp (architecture armv7s):
Mach header
magic cputype cpusubtype caps filetype ncmds sizeofcmds
flags
MH_MAGIC ARM V7S 0x00 EXECUTE 22 2212
NOUNDEFS DYLDLINK TWOLEVEL PIE
MAHHApp (architecture cputype (16777228) cpusubtype (0)):
Mach header
magic cputype cpusubtype caps filetype ncmds sizeofcmds
flags
MH_MAGIC_64 16777228 0 0x00 EXECUTE 22 2608
NOUNDEFS DYLDLINK TWOLEVEL PIE
Display the binary load commands:
$ otool -l MAHHApp
MAHHApp (architecture armv7):
Load command 0
cmd LC_SEGMENT
cmdsize 56
segname __PAGEZERO
vmaddr 0x00000000
vmsize 0x00004000
fileoff 0
filesize 0
maxprot 0x00000000
initprot 0x00000000
nsects 0
flags 0x0
nm
The nm utility can be used to display the symbol table of a binary or object file. When you use it against an
unencrypted iOS application, it reveals the class and method names of the application, preceded by a + for class
methods and – for instance methods:
$ nm MAHHApp
MAHHApp (for architecture armv7):
0000b368 s stub helpers
0000b1f0 t -[AppDelegate .cxx_destruct]
0000b058 t -[AppDelegate application:didFinishLaunchingWithOptions:]
0000b148 t -[AppDelegate applicationDidBecomeActive:]
0000b0e8 t -[AppDelegate applicationDidEnterBackground:]
0000b118 t -[AppDelegate applicationWillEnterForeground:]
0000b0b8 t -[AppDelegate applicationWillResignActive:]
0000b178 t -[AppDelegate applicationWillTerminate:]
0000b1c4 t -[AppDelegate setWindow:]
0000b1a8 t -[AppDelegate window]
0000b2c4 t -[MAHHClass dummyMethod]
0000b21c t -[MAHHClass initWithFrame:]
0000b014 t -[ViewController didReceiveMemoryWarning]
0000afd0 t -[ViewController viewDidLoad]
lipo
On occasion, you may be required to manipulate the architectures that are compiled into a binary. lipo allows
you to combine or remove architecture types from an application. This is discussed in greater detail within the
“Analyzing iOS Binaries” section of this chapter. Here are a couple brief examples of how to use lipo:
Print the architectures in a binary:
$ lipo -info MAHHApp
Architectures in the fat file: MAHHApp are: armv7 armv7s (cputype
(16777228) cpusubtype (0))
Remove all but the listed architecture types from a binary:
$ lipo -thin  -output MAHHApp-v7 MAHHApp
Debuggers
When you’re assessing an application, attaching a debugger can be a powerful technique for understanding the
application’s inner workings. A couple of debuggers work on iOS, and the one that works best for you will
depend upon what you are trying to debug and the resources available to you. If you have done any debugging
on UNIX-like platforms or debugged an iOS application under Xcode, you are likely familiar with the tools used
for debugging: gdb or lldb. We briefly discuss how to set up these debuggers under iOS as opposed to detailing
how to extensively use them.
The version of gdb in the default Cydia repositories does not work well with newer versions of iOS; indeed, it is
somewhat broken and not maintained. However, alternate repositories with custom compiled versions of gdb
are available. The one we have had the most success with is maintained by pancake of radare and can be
installed by adding radare’s Cydia repository as a source (http://cydia.radare.org).
If you do not have success with this version of gdb you can use Apple’s version that is distributed with Xcode, as
documented by pod2g (http://www.pod2g.org/2012/02/working-gnu-debugger-on-ios-43.html). However,
because Apple has transitioned to lldb, you must retrieve a copy from a previous version of Xcode, which you
can find in the iOS developer portal. The caveat is that these versions of gdb are limited to 32-bit devices. After
you have the required gdb binary, usually found under /Developer/Platforms/iPhoneOS
.platform/Developer/usr/libexec/gdb/gdb-arm-apple-darwin, you must thin the binary to the required
architecture, which you can do using lipo:
$ lipo -thin armv7 gdb-arm-apple-darwin -output gdb-arm7
Tools for Signing Binaries
All code running on an iOS device must be signed. Unless this requirement is explicitly disabled, it still applies
to jailbroken devices to some extent. However, in the case of jailbroken devices the code signing verification has
been relaxed to allow self-signed certificates. Therefore, when you modify a binary or build or upload tools to
the device, you must ensure that they are code signed to satisfy this requirement. To achieve this you can use a
couple of tools, namely codesign and ldid.
Apple provided the codesign tool and it is likely to be the one most OS X users are familiar with as it comes
bundled with OS X. You can use this multi-purpose tool for creating, checking, or displaying the status of a code-
signed binary.
To sign or replace an existing signature, use the following command:
$ codesign -v -fs "CodeSignIdentity" MAHHApp.app/
MAHHApp.app/: replacing existing signature
MAHHApp.app/: signed bundle with Mach-O universal (armv7 armv7s
(16777228:0)) [com.mdsec.MAHHApp]
To display the code signature of an application:
$ codesign -v -d MAHHApp.app
Executable=/MAHHApp.app/MAHHApp
Identifier=com.mdsec.MAHHApp
Format=bundle with Mach-O universal (armv7 armv7s (16777228:0))
CodeDirectory v=20100 size=406 flags=0x0(none) hashes=14+3
location=embedded
Signature size=1557
Signed Time=20 Jul 2014 22:29:52
Info.plist entries=30
TeamIdentifier=not set
Sealed Resources version=2 rules=5 files=8
Internal requirements count=2 size=296
If you do not have access to OS X fear not; saurik developed ldid as a pseudo-signing alternative
(http://www.saurik.com/id/8) to codesign. ldid generates and applies the SHA1 hashes that are verified by the
iOS kernel when checking a code-signed binary, and it can be compiled for a number of platforms. To sign a
binary with ldid use the following command:
$ ldid –S MAHHApp
Installipa
The normal process of installing an application to the device involves using the installd service, which
independently verifies the code signature of the application. During an application assessment, you may need to
install an IPA package that isn’t code signed or where the signature has been invalidated. You can, however,
circumvent this process on jailbroken devices using ipainstaller
(https://github.com/autopear/ipainstaller). Note that this requires the installation of AppSync, available
from the Cydia repository http://cydia.appaddict.org, a Cydia substrate tweak that disables code signing
within installd by hooking the MISValidateSignatureAndCopyInfo function where the signature verification is
performed. (Similar techniques will be detailed in Chapter 3, Attacking iOS Applications.) To install an
application, simply run ipainstaller against the IPA file from a root shell on the device:
# ipainstaller Lab1.1a.ipa
Analyzing Lab1.1a.ipa...