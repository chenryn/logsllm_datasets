analysis and query optimization.
As an example document, we use an auction document
of the XMark project. This document has 250,000 nodes,
and is generated by specifying factor =0.05 (see the XMark
project page).
When a query is evaluated against this document, some
nodes in this document are accessed by the XPath expres-
sions in this query. We classify these nodes into three groups,
which are deﬁned as follows:
no access These nodes are exempt from access. In other
words, the original query accesses these nodes but the
rewritten query does not.
access without runtime access check These nodes are
exempt from the runtime access control check, but
they must still be read.
access with runtime access check These nodes are not
exempt from runtime access check or access. In other
words, the rewritten query accesses these nodes and
this access requires runtime access check.
Role: ROLE10
+R,/
-R,/spec/body/div1/constraintnote/definitions
-R,/spec/header/latestloc/xtermref
-R,/spec/body/div1/definitions/exception
-R,//copyright
-R,/spec/header/prevlocs
-R,/spec/header/revisiondesc
-R,/spec/body/div1/vcnote/definitions/reference
-R,/spec/header/authlist/author
-R,/spec/back/div1/ulist/item/vcnote/glist
/gitem/def/table/tbody/tr/td/wfcnote
-R,//inform-div1/wfcnote
Figure 6: Random policy example
The bar chart (Figure 5) shows, for each role, the number
It shows the average for
of nodes in the three categories.
Queries #1 through #20.
We observe that the cost of query evaluation for roles M,
MM, IM and V is reduced signiﬁcantly, because the third
portion is very small. In particular, in the case of Maintainer
(M) we do not require runtime access checks at all, because a
maintainer has an access to all nodes. On the other hand, for
IM and V, we have a large number of skipped nodes that do
not even need to be examined during the query evaluation.
5.2 Scalability of Static Analysis
In the scalability test, we measure the running-time of our
analysis itself. We use real-world DTDs and random policies
with large sets of rules.
In this test, we distinguish two phases of the analysis, and
examine each phase independently. The ﬁrst phase is an ini-
tialization phase, where we ﬁrst compute a schema automa-
ton M G, then compute an access control automaton M Γ
for each role in the policy. The second phase is the anal-
ysis phase, where we statically analyze XPath expressions
in each query, i.e., we determine whether they are always-
denied or always-granted. When there are many queries,
we cache M G and M Γ which are computed in the initial-
ization phase, and later in the analysis phase we repeatedly
use them.
Settings. Three large DTDs are used, that is, the xmlspec-
v21.dtd from W3C XML Working Group [5], which has
157 element types, the HL7.dtd from Health Level Seven6,
which has 621 element types (as far as we know, this is the
biggest DTD publicly available), and the docbookx.dtd by
OASIS DocBook technical committee7, which has 393 ele-
ment types.
We use access control policies with diﬀerent sizes, i.e., 1
through 500 rules per role. For each of the given DTDs,
10 access control policies are randomly generated by using
element names or attribute names deﬁned in the DTD. As an
example, Figure 6 shows an access control policy generated
from the xmlspec-v21.dtd.
For each of the DTDs, we statically analyze a query with
12 XPath expressions. Each query is derived from the Query
#10 of XMark, in which each XPath expression has one //
and several /. We chose element names appearing in these
XPath expressions according to the corresponding DTDs.
6
7
http://www.hl7.org
http://www.oasis-open.org/committees/docbook
Results. Our test environment was a 2.4 GHz Pentium 4
machine with 512 Mbytes memory and the J2RE 1.4.0 IBM
build for Linux. The JIT-compiler is fully warmed up before
each run.
Figure 7(a) shows the running-time of the initialization
phase. Each point indicates the time required to compute
an access control automaton for each role in the randomly
generated policies. The running-time does not include the
time required to compute schema automata M G, which is
63.7ms, 57.5ms, and 249.3ms for xmlspec-v21.dtd, HL7.dtd,
and docbookx.dtd, respectively. The sizes of states of M G
are 214, 623, and 501 for xmlspec-v21.dtd, HL7.dtd, and
docbookx.dtd, respectively. The size of the access control
automaton M Γ is about 1,200 in the worst case.
Figure 7(b) shows the running-time for the analysis phase,
where each point indicates the average time required for
analyzing each XPath expression in the query.
In both phases, the performance is much better in the
case of HL7.dtd than in the case of xmlspec-v21.dtd or
docbookx.dtd. This is because xmlspec-v21.dtd and doc-
bookx.dtd contain many recursive deﬁnitions and thus are
more complicated than HL7.dtd.
The initialization phase (computing M Γ) takes more than
10 seconds for large policies and the running-time increases
non-linearly. On the other hand, in the analysis phase, the
running-time increases almost linearly with the number of
rules. In the real world, we perform the initialization phase
just once per policy, while we perform the analysis phase
once per XPath expression in queries. Therefore, we con-
clude that our static analysis scales with respect to the size
of schemas and access control policies.
6. CONCLUSIONS AND FUTURE WORK
In this paper, we have attempted to ease the burden of
checking access control policies for XML documents by dis-
tributing the burden to static analysis and run-time checks.
The key idea for our static analysis is to use automata
for representing and comparing queries, access control poli-
cies, and schemas. We have built a prototype of our static
analysis, demonstrated its eﬀectiveness, and experimented
with its performance. Our experiment (shown in Section 5)
reveals that (1) static analysis frequently makes run-time
checks unnecessary and further provides signiﬁcant opti-
mizations, and (2) our prototype scales nicely when schemas,
access control policies, and queries are large.
However, our static analysis has some limitations. We
summarize these limitations and sketch future extensions
for overcoming them.
Value-based access control: Value-based access con-
trol requires that the XPath expressions in the access con-
trol policies contain predicates. Query expressions may also
use XPath predicates. We have approximated such access
control policies and query expressions by creating under-
estimation automata and over-estimation automata. These
approximations make some queries statically indeterminate.
However, when an access control policy and query expres-
sion specify the same value, we can capture predicates by
incorporating them into the underlying alphabet (e.g., by
handling record[@patientId = $userid] as a “symbol”).
Such automata help to statically perform value-based access
control. For example, if a query expression and an access
control policy use record[@patientId = $userid], we can
statically grant this access.
]
s
m
[
e
m
i
t
]
s
m
[
e
m
i
t
 10000
 8000
 6000
 4000
 2000
 0
 0
 50  100  150  200  250  300  350  400  450  500
# of rules per role
xmlspec-v21.dtd
 1000
 800
 600
 400
 200
 0
 0
 50  100  150  200  250  300  350  400  450  500
# of rules per role
xmlspec-v21.dtd
]
s
m
[
e
m
i
t
]
s
m
[
e
m
i
t
 10000
 8000
 6000
 4000
 2000
 0
 0
 50  100  150  200  250  300  350  400  450  500
# of rules per role
HL7.dtd
(a) Initializing M Γ
 1000
 800
 600
 400
 200
 0
 0
 50  100  150  200  250  300  350  400  450  500
# of rules per role
HL7.dtd
]
s
m
[
e
m
i
t
]
s
m
[
e
m
i
t
 10000
 8000
 6000
 4000
 2000
 0
 0
 50
 100
 150
 200
 250
 300
# of rules per role
docbookx.dtd
 1000
 800
 600
 400
 200
 0
 0
 50
 100
 150
 200
 250
 300
# of rules per role
docbookx.dtd
(b) Analysis of each XPath expression
Figure 7: Results of Scalability Tests
Backward axes of XPath: Our static analysis does not
cover all axes (e.g., backward axes) of XPath. Although
we can use tree automata (rather than string automata)
to capture all the axes of XPath, tree automata are more
complicated and make implementations signiﬁcantly harder.
However, as a special case, we can easily handle some of the
backward axes by rewriting backward axes as forward ones
[26].
Advanced features of XQuery: We have signiﬁcantly
simpliﬁed XQuery here, but XPath allows arbitrary nesting
of FLWR expressions and even allows recursive queries. We
cannot handle recursive queries and are forced to rely on
run-time checking. However, we can handle nested FLWR
expressions by extracting XPath expressions.
Our next step is to incorporate static analysis as part of
an XML database system and seek a good balance between
run-time checking and static analysis.
7. ADDITIONAL AUTHORS
Additional author: Satoshi Hada (IBM Tokyo Research
Lab, 1623-14, Shimotsuruma, Yamato-shi, Kanagawa-ken
242-8502, Japan, email: PI:EMAIL)
8. REFERENCES
[1] E. Bertino. Data hiding and security in
object-oriented databases. In ICDE 92, 1992.
[2] E. Bertino, S. Castano, E. Ferrari, and M. Mesiti.
Controlled access and dissemination of XML
documents. In WIDM’99. ACM, Nov. 1999.
[3] E. Bertino, S. Castano, E. Ferrari, and M. Mesiti.
Author-X: a Java-based system for XML data
protection. In IFIP WG 11.3 Working Conference on
Database Security, 2000.
[4] S. Boag, D. Chamberlin, M. F. Fernandez,
D. Florescu, J. Robie, and J. Simeon. XQuery 1.0: An
XML query language. W3C working draft 16 august
2002. http://www.w3.org/TR/xquery/, August 2002.
[5] T. Bray, J. Paoli, and C. M. Sperberg-McQueen.
Extensible Markup Language (XML) 1.0. W3C
Recommendation. http://www.w3.org/TR/REC-xml,
February 1998.
[6] J. Clark and S. DeRose. XML Path Language
(XPath) version 1.0. W3C Recommendation.
http://www.w3.org/TR/xpath, Nov 1999.
[7] J. Clark and M. Murata (Eds). “RELAX NG
Speciﬁcation”. OASIS Committee Speciﬁcation, Dec.
2001.
[8] J. Clark (Eds). “XML Transformations (XSLT)
Version 1.0”. W3C Recommendation, Nov. 1999.
http://www.w3.org/TR/xslt.
[9] H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard,
D. Lugiez, S. Tison, and M. Tommasi. Tree automata
techniques and applications. Available at
http://www.grappa.univ-lille3.fr/tata, 1997.
[10] E. Damiani, S. D. C. di Vimercati, S. Paraboschi, and
P. Samarati. Securing XML documents. In EDBT
2000, LNCS 1777, Mar. 2000.
[11] A. Deutsch and V. Tannen. Containment of regular
path expressions under integrity constraints. In
KRDB, 2001.
[12] D. Draper, P. Fankhauser, M. Fernandez, A. Malhotra,
K. Rose, M. Rys, J. Simeon, and P. Wadler. XQuery
1.0 and XPath 2.0 formal semantics. W3C working
draft 16 august 2002, August 2002.
[13] W. Fan and L. Libkin. On XML integrity constraints
in the presence of DTDs. J. ACM, 49(3), 2002.
[14] M. F. Fernandez and D. Suciu. Optimizing regular
path expressions using graph schemas. In ICDE, 1998.
[15] A. Gabillon and E. Bruno. Regulating access to XML
documents. In IFIP WG 11.3 Working Conference on
APPENDIX
A.
IMPLEMENTATION
Here we present a few techniques for improving the per-
formance of our implementation.
Our automata library provides boolean operations (∩, ∪,
\) as well as the determinization and minimization opera-
tions. Our static analysis is built on top of these operations.
From our experience, the performance of our static anal-
ysis largely depends on the minimization operation. To im-
prove the performance of this operation, we use a very ef-
ﬁcient algorithm by Hopcroft [17]. Furthermore, we avoid
minimization when we can make automata small enough
by removing redundant states (i.e., unreachable states and
deadend states). We use this technique when we compute
intersection (∩) and diﬀerence (\) automata.
On the other hand, we heavily use the determinization
operation. While computing M Γ and M Γ in Step 2 (Sec-
tion 4.3), we always determinize intermediate automata as
well as M Γ and M Γ. By doing so, we can eﬃciently test ⊆
by applying \ in Step 4 (Section 4.5). If M Γ and M Γ were
large non-deterministic automata, \ (which requires the de-
terminization) would be prohibitively expensive.
In computing automata in Step 4 (Section 4.5), we ﬁrst
use M r, which is typically compact, and then use M G,
which can be very large and complex. More precisely, in
checking L(M Γ) ∩ L(M G) ∩ L(M r) = ∅, we ﬁrst compute
L(M Γ)∩L(M r) and then compute its intersection with M G;
in checking L(M r) ∩ L(M G) ⊆ L(M Γ), we ﬁrst compute
L(M r) \ L(M Γ) and then check whether or not (L(M r) \
L(M Γ)) ∩ L(M G) is empty.
In our experience, L(M Γ) ∩
L(M r) and L(M r) \ L(M Γ) are reasonably compact, but
L(M Γ)∩ L(M G) and L(M G)\ L(M Γ) can be very complex.
Database Security, Jul. 2001.
[16] S. Godik and T. Moses (Eds). “eXtensible Access
Control Markup Language (XACML) Version 1.0”.
OASIS Standard, Feb. 2003.
[17] J. E. Hopcroft. An n log n algorithm for minimizing
states in a ﬁnite automaton. Theory of Machines and
Computations, 1971.
[18] J. E. Hopcroft and J. D. Ullman. Introduction to
Automata Theory, Languages, and Computation.
Addison-Wesley, 1979.
[19] H. Hosoya and M. Murata. Validation and boolean
operations for attribute-element constraints. In
Programming Languages Technologies for XML
(PLAN-X), October 2002.
[20] H. Hosoya and B. C. Pierce. “XDuce: A Typed XML
Processing Language”. In WebDB, 2000.
[21] M. Kudo and S. Hada. XML document security based
on provisional authorization. In CCS-7. ACM, Nov
2000.
[22] J. Marsh (Eds). XML Base. W3C Recommendation,
June 2001.
http://www.w3.org/TR/2001/REC-xmlbase-20010627/.
[23] G. Miklau and D. Suciu. Containment and equivalence
for an XPath fragment. In PODS, 2002.
[24] M. Murata, D. Lee, and M. Mani. “Taxonomy of XML
Schema Languages using Formal Language Theory”.
In Extreme Markup Languages, Aug. 2001.
http://www.idealliance.org/papers/extreme02/
titles.html.
[25] F. Neven and T. Schwentick. XPath containment in
the presence of disjunction, DTDs, and variables. In
ICDT, 2003.
[26] D. Olteanu, H. Meuss, T. Furche, and F. Bry. XPath:
Looking forward. In Proceedings of Workshop on XML
Data Management (XMLDM), LNCS. Springer, 2002.
[27] Y. Papakonstantinou and V. Vassalos. Query rewriting
for semistructured data. In SIGMOD 1999, 1999.
[28] F. Rabitti, E. Bertino, W. Kim, and D. Woelk. A
model of authorization for next-generation database
systems. TODS, 16(1), 1991.
[29] W3C. “XML Schema”. W3C Recommendation, May
2001.
[30] P. T. Wood. Containment for XPath fragments under
DTD constraints. In ICDT, 2003.