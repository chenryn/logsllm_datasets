remove the potential carry from [ğ‘ + ğ‘Ÿ]ğ‘€ by computing
ğ‘š]ğ‘€ is then used to
[ğ‘’â€²]ğ‘€ â† [ğ‘ + ğ‘Ÿ]ğ‘€ âˆ’ 2ğ‘š Â· [ğ‘’â€²
ğ‘š]ğ‘€
in Step 6d of Î Conv. However, when ğ‘’â€²
ğ‘š âˆ‰ {0, 1} is multiplied with
2ğ‘š, we either subtract or add something much larger than what
may be represented by ğ‘š bits from [ğ‘ + ğ‘Ÿ]ğ‘€. Because this error is
so large, it is impossible for the adversary to cancel this out with
faulty multiplication triples or conversion tuples. Essentially, this
holds because faulty triples only introduce a 1-bit error, and the
result will always still be representable in ğ‘š bits.
A full security analysis, showing that faulty daBits do not im-
pact the security of Î Conv, can be found in the full version [3].
There, we define a functionality FFDabit that encompasses this idea
of two bits (ğ‘, ğ‘â€²) where ğ‘â€² â‰¡ ğ‘ mod 2.
Creating Faulty daBits. We now describe a revised daBit veri-
fication protocol Î FDabit realizing FFDabit, that, for a given daBit
([ğ‘]2, [ğ‘â€²]ğ‘€), only verifies that ğ‘ â‰¡ ğ‘â€² mod 2. For this check, it suf-
fices to compute random linear combinations in the two domains
and then open the values, giving consistency modulo 2. We define
the protocol Î FDabit in Figure 6, and show the following statement
in the full version [3]:
Lemma 3.6. Protocol Î FDabit (Figure 6) UC-realizes FFDabit except
with probability 2âˆ’ğ‘ +1.
Protocol Î FDabit
Inputs ğ‘ supposed faulty daBits ([ğ‘ğ‘–]2, [ğ‘ğ‘–]ğ‘)ğ‘–âˆˆ[ğ‘ ]. De-
fine ğ›¾ = ğ‘  + âŒˆlog2(ğ‘ + 1)âŒ‰ and require that (ğ‘ + 1) Â· 2ğ›¾+2 <
(ğ‘ âˆ’ 1)/2 for a statistical security parameter ğ‘ .
Protocol Perform the following check ğ‘  times:
(1) P samples ğ›¾ random bits {[ğ‘ğ‘–]ğ‘}ğ‘–âˆˆ[ğ›¾]. It additionally
creates [ğ‘1]2. It does not prove consistency among
[ğ‘1]ğ‘ and [ğ‘1]2.
(2) P shows that {[ğ‘ğ‘–]ğ‘}ğ‘–âˆˆ[ğ›¾] are bits by showing that
CheckZero([ğ‘ğ‘–]ğ‘ Â· (1 âˆ’ [ğ‘ğ‘–]ğ‘)) = (success) for ğ‘– âˆˆ [ğ›¾].
(3) V generates ğ‘ random bits ğ‘’ğ‘–.
(4) Let [ğ‘Ÿ]2 â† [ğ‘1]2 âŠ•ğ‘
(6) Let [ğ‘Ÿâ€²]ğ‘ â† [ğ‘
(7) Let ğœ = Open([ğ‘Ÿâ€²]ğ‘ +ğ›¾
(5) ğ‘Ÿ â† Open([ğ‘Ÿ]2)
ğ‘–=1 ğ‘’ğ‘– Â· ğ‘ğ‘–]ğ‘
ğ‘–=1 ğ‘’ğ‘– Â· [ğ‘ğ‘–]2
ğ‘—=1[ğ‘ğ‘–]ğ‘ Â· 2ğ‘–âˆ’1).
(8) Check if 0 â‰¤ ğœ < 2ğ›¾ and ğ‘Ÿ = ğœ mod 2. If not, abort.
Output (success).
Figure 6: Our optimized consistency check for daBits, that
no longer checks that [ğ‘]ğ‘ is a bit
We note that the main complexity of our faulty daBit check is
just that of creating the ğ›¾Â·ğ‘  auxiliary daBits. We assume the random
bits ğ‘’ğ‘– can be generated by letting the verifier pick a seed and then
using some expansion function on both sides. Since ğ›¾ = ğ‘ +log ğ‘ +1,
the dominant communication cost â€” namely committing to ğ›¾ Â· ğ‘ 
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea198daBits and multiplying to check that ğ‘ğ‘–(1âˆ’ ğ‘ğ‘–) is zero â€” amortizes
away when ğ‘ is large. This is in contrast to a secure daBit protocol,
which would need incur these costs for every faulty daBit.
4 TRUNCATION AND INTEGER COMPARISON
In this section, we provide protocols for verifying integer truncation
and comparison. With truncation, we mean that given integers ğ‘™, ğ‘š
and two authenticated values ğ‘¥, ğ‘¥â€² of ğ‘™ and ğ‘™ âˆ’ ğ‘š bits, we want to
verify that ğ‘¥â€² corresponds to the upper ğ‘™ âˆ’ğ‘š bits of ğ‘¥, i.e. ğ‘¥â€² = âŒŠ ğ‘¥
2ğ‘š âŒ‹
over the integers. Integer comparison is then the problem of taking
two authenticated integers and outputting 0 or 1 (authenticated)
depending on which input is the largest. Both protocols take as
input both the input and output of the function from the prover
and then verify the correctness of the provided data.
We also describe a novel way of checking the length of an au-
thenticated integer. We ask the prover to provide not only the
authenticated ring element, but also its bit decomposition. By prov-
ing consistency of these two representations, the prover shows that
the authenticated ring element can be represented by the provided
bit decomposition of which we can check the length. The naÃ¯ve
way of achieving this would be using a protocol for integer com-
parison or a less-than circuit. However, both of these ways would
require auxiliary consistent edaBits in addition to possibly other
operations. Instead, we only have to verify that the input forms a
consistent edaBit and therefore save anything beyond that.
We note that the integers in this section are signed in the in-
terval [âˆ’2ğ‘™âˆ’1, 2ğ‘™âˆ’1), but the protocols are all defined over a mod-
ulus ğ‘€ â‰¥ 2ğ‘™ where ğ‘€ is either a prime ğ‘ or 2ğ‘˜. Given an integer
ğ›¼ âˆˆ [âˆ’2ğ‘™âˆ’1, 2ğ‘™âˆ’1), this can be represented by a corresponding ring
element in Zğ‘€.
4.1 Truncation
0,ğ‘— , id
Functionality FVerifyTrunc
The functionality FVerifyTrunc extends F 2,ğ‘€
with
ComZK
VerifyTrunc that verifies truncations of committed
values from Zğ‘€. The function takes a set of
IDs
{(id
1,ğ‘—)} ğ‘— âˆˆ[ğ‘ ] of elements ğ‘id0,ğ‘— , ğ‘id1,ğ‘— âˆˆ Zğ‘€ and a
set of integers {ğ‘š ğ‘—} ğ‘— âˆˆ[ğ‘ ] such that ğ‘š ğ‘— âˆˆ [ğ‘€] represents
by how much ğ‘id0,ğ‘— is truncated to reach ğ‘id1,ğ‘— for ğ‘— âˆˆ [ğ‘].
It is assumed that the underlying values of the idâ€™s have
been Input prior to calling this method.
V
VerifyTrunc: Upon
(VerifyTrunc, ğ‘ , {ğ‘š ğ‘— , (id
1,ğ‘—)} ğ‘— âˆˆ[ğ‘ ]):
â€¢ Check that ğ‘id1,ğ‘—
P
0,ğ‘— , id
2ğ‘š ğ‘— âŒ‹, for each ğ‘— âˆˆ [ğ‘]. If all
checks pass, output (success), otherwise abort.
inputting
= âŒŠ ğ‘id
and
0,ğ‘—
Figure 7: Functionality FVerifyTrunc that verifies a truncation
In Figure 7 we present a functionality FVerifyTrunc that takes a
batch of commitments [ğ‘ ğ‘—]ğ‘€ and their supposed truncations (by
ğ‘š ğ‘— bits) [ğ‘â€²
ğ‘—]ğ‘€. The functionality ensures that the truncations are
correct, namely, ğ‘â€²
2ğ‘š ğ‘— âŒ‹. Note that this functionality we realise
ğ‘— = âŒŠ ğ‘ ğ‘—
ğ‘¡ğ‘Ÿ
ğ‘šâˆ’1]2)
ğ‘¡ğ‘Ÿ]2, . . . , [ğ‘ğ‘™âˆ’ğ‘šâˆ’1
]2)
([ğ‘0
0]2, . . . , [ğ‘â€²
bit decomposition ([ğ‘â€²
is flexible, in that it can support a large batch of truncations, each
of which may be of a different length.
We now construct a protocol for verifying truncations, which
can securely realise FVerifyTrunc using just a single call to our batch
conversion functionality, FConv, on a vector of tuples that is twice
the length of the number of truncations. For the protocol, we will
have that in addition to each input [ğ‘]ğ‘€, the prover also provides:
â€¢ the truncated value [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€ of [ğ‘]ğ‘€ and its bit decomposition
â€¢ the initial ğ‘š bits of [ğ‘]ğ‘€; [ğ‘â€²]ğ‘€ = [ğ‘ mod 2ğ‘š]ğ‘€ as well as its
Having access to [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€ and [ğ‘â€²]ğ‘€ allows the verifier then to check
that ğ‘ = 2ğ‘š Â· ğ‘ğ‘¡ğ‘Ÿ + ğ‘â€², which is sufficient to prove the claim.Observe
that running Î Conv on [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€ and ([ğ‘0
]2) not only
shows consistency between the binary and arithmetic representa-
tions, but also that [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€ can be represented by ğ‘™ âˆ’ ğ‘š or less bits
(same goes for [ğ‘â€²]ğ‘€ and its bit decomposition).
We first define an ideal functionality FCheckLength (Figure 8) that
encapsulates this concept of using FConv as a way of bounding the
size of an authenticated value.
The protocol Î CheckLength ensures that [ğ‘]ğ‘€ can be represented
by ğ‘š bits, as it proves consistency between the two representations
of ğ‘. The security of this protocol directly follows from using FConv.
The cost of the protocol also directly follows from the consistency
check described in Figure 3.
We prove that Î VerifyTrunc securely realises the functionality
FVerifyTrunc, in Appendix B. Note that Î CheckLength and Î VerifyTrunc
do not utilise anything specific about ğ‘€ except 2ğ‘™ â‰¤ ğ‘€ and both
work for Zğ‘ and Z2ğ‘˜ .
ğ‘¡ğ‘Ÿ]2, . . . , [ğ‘ğ‘™âˆ’ğ‘šâˆ’1
ğ‘¡ğ‘Ÿ
ComZK
Functionality FCheckLength
This functionality extends F 2,ğ‘€
with the extra func-
tion VerifyLength that takes a set of IDs {idğ‘—} ğ‘— âˆˆ[ğ‘ ] of
elements ğ‘¥idğ‘— âˆˆ Zğ‘€ and a set of integers {ğ‘š ğ‘—} ğ‘— âˆˆ[ğ‘ ] such
that ğ‘š ğ‘— âˆˆ [ğ‘€] represents the supposed lengths of the ele-
ments {ğ‘¥idğ‘— } ğ‘— âˆˆ[ğ‘ ]. FCheckLength communicates with two
parties P, V. It is assumed that the underlying values of
the idâ€™s have been Input prior to calling this method.
VerifyLength: Upon
(VerifyLength, ğ‘ , {ğ‘š ğ‘— , idğ‘—} ğ‘— âˆˆ[ğ‘ ]) :
â€¢ Check that ğ‘¥ğ‘–ğ‘‘ ğ‘— may be described by ğ‘š ğ‘— bits for all
ğ‘— âˆˆ [ğ‘]. Output (success) if so, otherwise abort.
and V
inputting
P
Figure 8: Functionality to verify length of commitments
4.2 Integer Comparison
We now discuss how to compare two signed, ğ‘™-bit integers ğ›¼ and ğ›½.
The way the protocol works is by having the prover (and verifier)
compute [ğ›¼]ğ‘€ âˆ’ [ğ›½]ğ‘€ and have the prover compute the truncation
of this which is only the most significant bit. Now we may run
Î VerifyTrunc on the truncation and use the truncation as the output
of the comparison. We remark that, similarly to previous works
in the MPC setting [11, 16], this gives the correct result as long as
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea199Protocol Î CheckLength
Input A set of tuples {[ğ‘¥ ğ‘—]ğ‘€, ğ‘š ğ‘— , } ğ‘— âˆˆ[ğ‘ ] where ğ‘¥ ğ‘— âˆˆ
[0, 2ğ‘™) and ğ‘š ğ‘— defines the claimed bitlength of ğ‘¥ ğ‘—.
Protocol
ğ‘š ğ‘—âˆ’1]2.
(1) For each ğ‘— âˆˆ [ğ‘], P commits to [ğ‘¥ ğ‘—
0]2, . . . , [ğ‘¥ ğ‘—
(2) Let ğ‘š = maxğ‘—{ğ‘š ğ‘—}, and for ğ‘– = ğ‘š ğ‘— , . . . , ğ‘šâˆ’ 1, let [ğ‘¥ ğ‘—
ğ‘– ]2
denote a dummy commitment to zero (which can be
easily obtained with CheckZero).
0]2, . . . , [ğ‘¥ ğ‘—
and output what FConv outputs.
(3) Run FConv on {([ğ‘¥ ğ‘—
ğ‘šâˆ’1]2, [ğ‘¥ ğ‘—]ğ‘€)} ğ‘— âˆˆ[ğ‘ ]
Figure 9: Protocol Î CheckLength that verifies that committed
elements are bounded.
Protocol Î VerifyTrunc
Input A set of tuples {[ğ‘ ğ‘—]ğ‘€, ğ‘š ğ‘— , [ğ‘ ğ‘—
ğ‘¡ğ‘Ÿ]ğ‘€} ğ‘— âˆˆ[ğ‘ ] where
ğ‘ ğ‘— âˆˆ [0, 2ğ‘™), ğ‘š ğ‘— defines the number of bits that has been
truncated and [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€ represents the supposed truncation.
Protocol
(1) For each ğ‘— âˆˆ [ğ‘], P commits to the least-significant
ğ‘š bits of [ğ‘ ğ‘—]ğ‘€, denoted as [ğ‘â€²]ğ‘€ = [ğ‘ ğ‘— mod 2ğ‘š]ğ‘€ .
input
(2) The
parties
call
{[ğ‘â€²]ğ‘€, ğ‘š ğ‘—} ğ‘— âˆˆ[ğ‘ ] âˆª {[ğ‘ ğ‘—
FCheckLength with
ğ‘¡ğ‘Ÿ]ğ‘€, ğ‘™ âˆ’ ğ‘š ğ‘—} ğ‘— âˆˆ[ğ‘ ].
ğ‘¡ğ‘Ÿ]ğ‘€ + [ğ‘â€²]ğ‘€)
(3) For each ğ‘—, let [ğ‘¦]ğ‘€ = [ğ‘ ğ‘—]ğ‘€ âˆ’ (2ğ‘š Â· [ğ‘ ğ‘—
Abort if any of the checks fail. Otherwise output (success).
and run CheckZero([ğ‘¦]ğ‘€).
Figure 10: Protocol to verify the truncation of an element
from Zğ‘€
ğ›¼, ğ›½ âˆˆ [âˆ’2ğ‘™âˆ’2, 2ğ‘™âˆ’2), so that ğ›¼ âˆ’ ğ›½ âˆˆ [âˆ’2ğ‘™âˆ’1, 2ğ‘™âˆ’1), so this introduces
a mild restriction on the range of values that can be supported.
5 INTERACTIVE PROOFS OVER Z2ğ‘˜
In this section, we provide the foundations for an interactive proof
system that natively operates over Z2ğ‘˜ . First, we show how linearly
homomorphic commitments for Z2ğ‘˜ can be constructed from VOLE
in Section 5.1. Then, in Section 5.2, we present two protocol variants
which instantiate F Z2ğ‘˜
, and prove their security in Section 5.3.
5.1 Linearly Homomorphic Commitments from
ComZK
Vector-OLE
To construct linearly homomorphic commitments over the ring
Z2ğ‘˜ , we use a variant of the information-theoretic MAC scheme
from SPDZ2ğ‘˜ [12]: Let ğ‘  be a statistical security parameter. To
authenticate a value ğ‘¥ âˆˆ Z2ğ‘˜ known to P towards V (denoted as
[ğ‘¥]), we choose the MAC keys Î” âˆˆğ‘… Z2ğ‘  and ğ¾[ğ‘¥] âˆˆğ‘… Z2ğ‘˜+ğ‘  , and
compute the MAC tag as
ğ‘€[ğ‘¥] := Î” Â· Ëœğ‘¥ + ğ¾[ğ‘¥] âˆˆ Z2ğ‘˜+ğ‘ 
(1)
where ğ‘¥ = Ëœğ‘¥ mod 2ğ‘˜, i.e. Ëœğ‘¥ is a representative of the corresponding
congruence class of integers modulo 2ğ‘˜. Then P gets Ëœğ‘¥ and ğ‘€[ğ‘¥],
whereas V receives Î” and ğ¾[ğ‘¥].
Initially Ëœğ‘¥ may be chosen as Ëœğ‘¥ = ğ‘¥ âˆˆ {0, . . . , 2ğ‘˜ âˆ’1}. Applying the
arithmetic operations described below can result in larger values
though, which do not get reduced modulo 2ğ‘˜ because all computa-
tion happens modulo 2ğ‘˜+ğ‘ . For a commitment [ğ‘¥] we always use Ëœğ‘¥
to denote the representative held by P.
This MAC schemes allows us to locally compute affine combi-
nations: E.g. for [ğ‘§] â† ğ‘ Â· [ğ‘¥] + [ğ‘¦] + ğ‘ with public ğ‘, ğ‘ âˆˆ Z2ğ‘˜ , the
parties compute Ëœğ‘§ â† ğ‘ Â· Ëœğ‘¥ + Ëœğ‘¦ + ğ‘ and ğ‘€[ğ‘§] â† ğ‘ Â· ğ‘€[ğ‘¥] + ğ‘€[ğ‘¦], as
well as ğ¾[ğ‘§] â† ğ‘ Â· ğ¾[ğ‘¥] + ğ¾[ğ‘¦] âˆ’ Î” Â· ğ‘. Then we have
ğ‘€[ğ‘§] â‰¡ğ‘˜+ğ‘  ğ‘ Â· ğ‘€[ğ‘¥] + ğ‘€[ğ‘¦]
â‰¡ğ‘˜+ğ‘  ğ‘ Â· (Î” Â· Ëœğ‘¥ + ğ¾[ğ‘¥]) + (Î” Â· Ëœğ‘¦ + ğ¾[ğ‘¦])
â‰¡ğ‘˜+ğ‘  Î” Â· (ğ‘ Â· Ëœğ‘¥ + Ëœğ‘¦) + (ğ‘ Â· ğ¾[ğ‘¥] + ğ¾[ğ‘¦])
â‰¡ğ‘˜+ğ‘  Î” Â· (ğ‘ Â· Ëœğ‘¥ + Ëœğ‘¦ + ğ‘) + (ğ‘ Â· ğ¾[ğ‘¥] + ğ¾[ğ‘¦] âˆ’ Î” Â· ğ‘)
â‰¡ğ‘˜+ğ‘  Î” Â· Ëœğ‘§ + ğ¾[ğ‘§].