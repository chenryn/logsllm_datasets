remove the potential carry from [𝑐 + 𝑟]𝑀 by computing
𝑚]𝑀 is then used to
[𝑒′]𝑀 ← [𝑐 + 𝑟]𝑀 − 2𝑚 · [𝑒′
𝑚]𝑀
in Step 6d of ΠConv. However, when 𝑒′
𝑚 ∉ {0, 1} is multiplied with
2𝑚, we either subtract or add something much larger than what
may be represented by 𝑚 bits from [𝑐 + 𝑟]𝑀. Because this error is
so large, it is impossible for the adversary to cancel this out with
faulty multiplication triples or conversion tuples. Essentially, this
holds because faulty triples only introduce a 1-bit error, and the
result will always still be representable in 𝑚 bits.
A full security analysis, showing that faulty daBits do not im-
pact the security of ΠConv, can be found in the full version [3].
There, we define a functionality FFDabit that encompasses this idea
of two bits (𝑏, 𝑏′) where 𝑏′ ≡ 𝑏 mod 2.
Creating Faulty daBits. We now describe a revised daBit veri-
fication protocol ΠFDabit realizing FFDabit, that, for a given daBit
([𝑏]2, [𝑏′]𝑀), only verifies that 𝑏 ≡ 𝑏′ mod 2. For this check, it suf-
fices to compute random linear combinations in the two domains
and then open the values, giving consistency modulo 2. We define
the protocol ΠFDabit in Figure 6, and show the following statement
in the full version [3]:
Lemma 3.6. Protocol ΠFDabit (Figure 6) UC-realizes FFDabit except
with probability 2−𝑠+1.
Protocol ΠFDabit
Inputs 𝑁 supposed faulty daBits ([𝑏𝑖]2, [𝑏𝑖]𝑝)𝑖∈[𝑁 ]. De-
fine 𝛾 = 𝑠 + ⌈log2(𝑁 + 1)⌉ and require that (𝑁 + 1) · 2𝛾+2 <
(𝑝 − 1)/2 for a statistical security parameter 𝑠.
Protocol Perform the following check 𝑠 times:
(1) P samples 𝛾 random bits {[𝑐𝑖]𝑝}𝑖∈[𝛾]. It additionally
creates [𝑐1]2. It does not prove consistency among
[𝑐1]𝑝 and [𝑐1]2.
(2) P shows that {[𝑐𝑖]𝑝}𝑖∈[𝛾] are bits by showing that
CheckZero([𝑐𝑖]𝑝 · (1 − [𝑐𝑖]𝑝)) = (success) for 𝑖 ∈ [𝛾].
(3) V generates 𝑁 random bits 𝑒𝑖.
(4) Let [𝑟]2 ← [𝑐1]2 ⊕𝑁
(6) Let [𝑟′]𝑝 ← [𝑁
(7) Let 𝜏 = Open([𝑟′]𝑝 +𝛾
(5) 𝑟 ← Open([𝑟]2)
𝑖=1 𝑒𝑖 · 𝑏𝑖]𝑝
𝑖=1 𝑒𝑖 · [𝑏𝑖]2
𝑗=1[𝑐𝑖]𝑝 · 2𝑖−1).
(8) Check if 0 ≤ 𝜏 < 2𝛾 and 𝑟 = 𝜏 mod 2. If not, abort.
Output (success).
Figure 6: Our optimized consistency check for daBits, that
no longer checks that [𝑏]𝑝 is a bit
We note that the main complexity of our faulty daBit check is
just that of creating the 𝛾·𝑠 auxiliary daBits. We assume the random
bits 𝑒𝑖 can be generated by letting the verifier pick a seed and then
using some expansion function on both sides. Since 𝛾 = 𝑠+log 𝑁 +1,
the dominant communication cost — namely committing to 𝛾 · 𝑠
Session 1C: Zero Knowledge I CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea198daBits and multiplying to check that 𝑐𝑖(1− 𝑐𝑖) is zero — amortizes
away when 𝑁 is large. This is in contrast to a secure daBit protocol,
which would need incur these costs for every faulty daBit.
4 TRUNCATION AND INTEGER COMPARISON
In this section, we provide protocols for verifying integer truncation
and comparison. With truncation, we mean that given integers 𝑙, 𝑚
and two authenticated values 𝑥, 𝑥′ of 𝑙 and 𝑙 − 𝑚 bits, we want to
verify that 𝑥′ corresponds to the upper 𝑙 −𝑚 bits of 𝑥, i.e. 𝑥′ = ⌊ 𝑥
2𝑚 ⌋
over the integers. Integer comparison is then the problem of taking
two authenticated integers and outputting 0 or 1 (authenticated)
depending on which input is the largest. Both protocols take as
input both the input and output of the function from the prover
and then verify the correctness of the provided data.
We also describe a novel way of checking the length of an au-
thenticated integer. We ask the prover to provide not only the
authenticated ring element, but also its bit decomposition. By prov-
ing consistency of these two representations, the prover shows that
the authenticated ring element can be represented by the provided
bit decomposition of which we can check the length. The naïve
way of achieving this would be using a protocol for integer com-
parison or a less-than circuit. However, both of these ways would
require auxiliary consistent edaBits in addition to possibly other
operations. Instead, we only have to verify that the input forms a
consistent edaBit and therefore save anything beyond that.
We note that the integers in this section are signed in the in-
terval [−2𝑙−1, 2𝑙−1), but the protocols are all defined over a mod-
ulus 𝑀 ≥ 2𝑙 where 𝑀 is either a prime 𝑝 or 2𝑘. Given an integer
𝛼 ∈ [−2𝑙−1, 2𝑙−1), this can be represented by a corresponding ring
element in Z𝑀.
4.1 Truncation
0,𝑗 , id
Functionality FVerifyTrunc
The functionality FVerifyTrunc extends F 2,𝑀
with
ComZK
VerifyTrunc that verifies truncations of committed
values from Z𝑀. The function takes a set of
IDs
{(id
1,𝑗)} 𝑗 ∈[𝑁 ] of elements 𝑎id0,𝑗 , 𝑎id1,𝑗 ∈ Z𝑀 and a
set of integers {𝑚 𝑗} 𝑗 ∈[𝑁 ] such that 𝑚 𝑗 ∈ [𝑀] represents
by how much 𝑎id0,𝑗 is truncated to reach 𝑎id1,𝑗 for 𝑗 ∈ [𝑁].
It is assumed that the underlying values of the id’s have
been Input prior to calling this method.
V
VerifyTrunc: Upon
(VerifyTrunc, 𝑁 , {𝑚 𝑗 , (id
1,𝑗)} 𝑗 ∈[𝑁 ]):
• Check that 𝑎id1,𝑗
P
0,𝑗 , id
2𝑚 𝑗 ⌋, for each 𝑗 ∈ [𝑁]. If all
checks pass, output (success), otherwise abort.
inputting
= ⌊ 𝑎id
and
0,𝑗
Figure 7: Functionality FVerifyTrunc that verifies a truncation
In Figure 7 we present a functionality FVerifyTrunc that takes a
batch of commitments [𝑎 𝑗]𝑀 and their supposed truncations (by
𝑚 𝑗 bits) [𝑎′
𝑗]𝑀. The functionality ensures that the truncations are
correct, namely, 𝑎′
2𝑚 𝑗 ⌋. Note that this functionality we realise
𝑗 = ⌊ 𝑎 𝑗
𝑡𝑟
𝑚−1]2)
𝑡𝑟]2, . . . , [𝑎𝑙−𝑚−1
]2)
([𝑎0
0]2, . . . , [𝑎′
bit decomposition ([𝑎′
is flexible, in that it can support a large batch of truncations, each
of which may be of a different length.
We now construct a protocol for verifying truncations, which
can securely realise FVerifyTrunc using just a single call to our batch
conversion functionality, FConv, on a vector of tuples that is twice
the length of the number of truncations. For the protocol, we will
have that in addition to each input [𝑎]𝑀, the prover also provides:
• the truncated value [𝑎𝑡𝑟]𝑀 of [𝑎]𝑀 and its bit decomposition
• the initial 𝑚 bits of [𝑎]𝑀; [𝑎′]𝑀 = [𝑎 mod 2𝑚]𝑀 as well as its
Having access to [𝑎𝑡𝑟]𝑀 and [𝑎′]𝑀 allows the verifier then to check
that 𝑎 = 2𝑚 · 𝑎𝑡𝑟 + 𝑎′, which is sufficient to prove the claim.Observe
that running ΠConv on [𝑎𝑡𝑟]𝑀 and ([𝑎0
]2) not only
shows consistency between the binary and arithmetic representa-
tions, but also that [𝑎𝑡𝑟]𝑀 can be represented by 𝑙 − 𝑚 or less bits
(same goes for [𝑎′]𝑀 and its bit decomposition).
We first define an ideal functionality FCheckLength (Figure 8) that
encapsulates this concept of using FConv as a way of bounding the
size of an authenticated value.
The protocol ΠCheckLength ensures that [𝑎]𝑀 can be represented
by 𝑚 bits, as it proves consistency between the two representations
of 𝑎. The security of this protocol directly follows from using FConv.
The cost of the protocol also directly follows from the consistency
check described in Figure 3.
We prove that ΠVerifyTrunc securely realises the functionality
FVerifyTrunc, in Appendix B. Note that ΠCheckLength and ΠVerifyTrunc
do not utilise anything specific about 𝑀 except 2𝑙 ≤ 𝑀 and both
work for Z𝑝 and Z2𝑘 .
𝑡𝑟]2, . . . , [𝑎𝑙−𝑚−1
𝑡𝑟
ComZK
Functionality FCheckLength
This functionality extends F 2,𝑀
with the extra func-
tion VerifyLength that takes a set of IDs {id𝑗} 𝑗 ∈[𝑁 ] of
elements 𝑥id𝑗 ∈ Z𝑀 and a set of integers {𝑚 𝑗} 𝑗 ∈[𝑁 ] such
that 𝑚 𝑗 ∈ [𝑀] represents the supposed lengths of the ele-
ments {𝑥id𝑗 } 𝑗 ∈[𝑁 ]. FCheckLength communicates with two
parties P, V. It is assumed that the underlying values of
the id’s have been Input prior to calling this method.
VerifyLength: Upon
(VerifyLength, 𝑁 , {𝑚 𝑗 , id𝑗} 𝑗 ∈[𝑁 ]) :
• Check that 𝑥𝑖𝑑 𝑗 may be described by 𝑚 𝑗 bits for all
𝑗 ∈ [𝑁]. Output (success) if so, otherwise abort.
and V
inputting
P
Figure 8: Functionality to verify length of commitments
4.2 Integer Comparison
We now discuss how to compare two signed, 𝑙-bit integers 𝛼 and 𝛽.
The way the protocol works is by having the prover (and verifier)
compute [𝛼]𝑀 − [𝛽]𝑀 and have the prover compute the truncation
of this which is only the most significant bit. Now we may run
ΠVerifyTrunc on the truncation and use the truncation as the output
of the comparison. We remark that, similarly to previous works
in the MPC setting [11, 16], this gives the correct result as long as
Session 1C: Zero Knowledge I CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea199Protocol ΠCheckLength
Input A set of tuples {[𝑥 𝑗]𝑀, 𝑚 𝑗 , } 𝑗 ∈[𝑁 ] where 𝑥 𝑗 ∈
[0, 2𝑙) and 𝑚 𝑗 defines the claimed bitlength of 𝑥 𝑗.
Protocol
𝑚 𝑗−1]2.
(1) For each 𝑗 ∈ [𝑁], P commits to [𝑥 𝑗
0]2, . . . , [𝑥 𝑗
(2) Let 𝑚 = max𝑗{𝑚 𝑗}, and for 𝑖 = 𝑚 𝑗 , . . . , 𝑚− 1, let [𝑥 𝑗
𝑖 ]2
denote a dummy commitment to zero (which can be
easily obtained with CheckZero).
0]2, . . . , [𝑥 𝑗
and output what FConv outputs.
(3) Run FConv on {([𝑥 𝑗
𝑚−1]2, [𝑥 𝑗]𝑀)} 𝑗 ∈[𝑁 ]
Figure 9: Protocol ΠCheckLength that verifies that committed
elements are bounded.
Protocol ΠVerifyTrunc
Input A set of tuples {[𝑎 𝑗]𝑀, 𝑚 𝑗 , [𝑎 𝑗
𝑡𝑟]𝑀} 𝑗 ∈[𝑁 ] where
𝑎 𝑗 ∈ [0, 2𝑙), 𝑚 𝑗 defines the number of bits that has been
truncated and [𝑎𝑡𝑟]𝑀 represents the supposed truncation.
Protocol
(1) For each 𝑗 ∈ [𝑁], P commits to the least-significant
𝑚 bits of [𝑎 𝑗]𝑀, denoted as [𝑎′]𝑀 = [𝑎 𝑗 mod 2𝑚]𝑀 .
input
(2) The
parties
call
{[𝑎′]𝑀, 𝑚 𝑗} 𝑗 ∈[𝑁 ] ∪ {[𝑎 𝑗
FCheckLength with
𝑡𝑟]𝑀, 𝑙 − 𝑚 𝑗} 𝑗 ∈[𝑁 ].
𝑡𝑟]𝑀 + [𝑎′]𝑀)
(3) For each 𝑗, let [𝑦]𝑀 = [𝑎 𝑗]𝑀 − (2𝑚 · [𝑎 𝑗
Abort if any of the checks fail. Otherwise output (success).
and run CheckZero([𝑦]𝑀).
Figure 10: Protocol to verify the truncation of an element
from Z𝑀
𝛼, 𝛽 ∈ [−2𝑙−2, 2𝑙−2), so that 𝛼 − 𝛽 ∈ [−2𝑙−1, 2𝑙−1), so this introduces
a mild restriction on the range of values that can be supported.
5 INTERACTIVE PROOFS OVER Z2𝑘
In this section, we provide the foundations for an interactive proof
system that natively operates over Z2𝑘 . First, we show how linearly
homomorphic commitments for Z2𝑘 can be constructed from VOLE
in Section 5.1. Then, in Section 5.2, we present two protocol variants
which instantiate F Z2𝑘
, and prove their security in Section 5.3.
5.1 Linearly Homomorphic Commitments from
ComZK
Vector-OLE
To construct linearly homomorphic commitments over the ring
Z2𝑘 , we use a variant of the information-theoretic MAC scheme
from SPDZ2𝑘 [12]: Let 𝑠 be a statistical security parameter. To
authenticate a value 𝑥 ∈ Z2𝑘 known to P towards V (denoted as
[𝑥]), we choose the MAC keys Δ ∈𝑅 Z2𝑠 and 𝐾[𝑥] ∈𝑅 Z2𝑘+𝑠 , and
compute the MAC tag as
𝑀[𝑥] := Δ · ˜𝑥 + 𝐾[𝑥] ∈ Z2𝑘+𝑠
(1)
where 𝑥 = ˜𝑥 mod 2𝑘, i.e. ˜𝑥 is a representative of the corresponding
congruence class of integers modulo 2𝑘. Then P gets ˜𝑥 and 𝑀[𝑥],
whereas V receives Δ and 𝐾[𝑥].
Initially ˜𝑥 may be chosen as ˜𝑥 = 𝑥 ∈ {0, . . . , 2𝑘 −1}. Applying the
arithmetic operations described below can result in larger values
though, which do not get reduced modulo 2𝑘 because all computa-
tion happens modulo 2𝑘+𝑠. For a commitment [𝑥] we always use ˜𝑥
to denote the representative held by P.
This MAC schemes allows us to locally compute affine combi-
nations: E.g. for [𝑧] ← 𝑎 · [𝑥] + [𝑦] + 𝑏 with public 𝑎, 𝑏 ∈ Z2𝑘 , the
parties compute ˜𝑧 ← 𝑎 · ˜𝑥 + ˜𝑦 + 𝑏 and 𝑀[𝑧] ← 𝑎 · 𝑀[𝑥] + 𝑀[𝑦], as
well as 𝐾[𝑧] ← 𝑎 · 𝐾[𝑥] + 𝐾[𝑦] − Δ · 𝑏. Then we have
𝑀[𝑧] ≡𝑘+𝑠 𝑎 · 𝑀[𝑥] + 𝑀[𝑦]
≡𝑘+𝑠 𝑎 · (Δ · ˜𝑥 + 𝐾[𝑥]) + (Δ · ˜𝑦 + 𝐾[𝑦])
≡𝑘+𝑠 Δ · (𝑎 · ˜𝑥 + ˜𝑦) + (𝑎 · 𝐾[𝑥] + 𝐾[𝑦])
≡𝑘+𝑠 Δ · (𝑎 · ˜𝑥 + ˜𝑦 + 𝑏) + (𝑎 · 𝐾[𝑥] + 𝐾[𝑦] − Δ · 𝑏)
≡𝑘+𝑠 Δ · ˜𝑧 + 𝐾[𝑧].