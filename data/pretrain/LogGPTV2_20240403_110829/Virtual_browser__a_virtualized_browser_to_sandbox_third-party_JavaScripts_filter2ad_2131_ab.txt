shown in Figure 2(b), the f or loop is not running directly
on the native JavaScript engine.
In order to compromise
the native browser with this vulnerability, virtual browser
source code needs to have the sentence with exactly the same
pattern: a f or-loop where a, b and c are all open inputs.
Then attackers need to manipulate other inputs to let the
sentence in virtual browser source code get the certain values
that can trigger the attack. Either of the two conditions is
not easy to satisfy, as evaluated in Section 6.3.
Third, some dynamic language features, such as eval and
with, are not supported in present JavaScript level approaches.
Developers however still use eval to parse JSON strings in
old browsers with no native JSON support. Gatekeeper [21]
reveals that about 9.4% of widgets use with.
As shown in Figure 1, the classical runtime approaches
(such as the runtime part in GateKeeper [21]) employ a pa-
rameter checking model, implying that they cannot check
the safety of eval and setTimeout, whose parameters contain
JavaScript code. and need to be passed to the JavaScript
parser. Web Sandbox [27] itself does not execute third party
scripts, and therefore it is hard to switch execution con-
texts for with statement. Meanwhile, although it is possible
to recursively transfer arguments of eval back to the server
for further transforming, large client-server delays will occur
and render the approach extremely slow. Therefore, in the
implementation of Web Sandbox, with is not supported and
the support of eval is incomplete.
Fourth, those approaches, which modify existing browsers
or utilize plugins like Native Client [38], are not supported
by all existing browsers. Mozilla publicly rejects adopting
NaCl [8], and meanwhile there is not clue that IE and Opera
will adopt NaCl either. Therefore, those approaches can
protect only a limited number of users who deploy their
approaches. Virtual browser uses only JavaScript features
that are supported by all present browsers.
3. DESIGN
In Section 3.1, we ﬁrst introduce the architecture of Vir-
tual Browser. Then we give several JavaScript examples to
show how exactly Virtual Browser works in Section 3.2.
3.1 Architecture
The architecture of Virtual Browser is shown in Figure
3. Virtual Browser is very similar to a native web browser
except that it is written in JavaScript. We will introduce the
interface, components and ﬂows of Virtual Browser below.
3.1.1 Interface
Similar to Microsoft Web Sandbox, Virtual Browser takes
a string, which contains the code of a third-party JavaScript
program, as input. For example, we are using the following
codes to include third-party JavaScripts.
str is a string that represents a third-party JavaScript
code, which can be embedded inside host web pages. Main-
tenance of str is vulnerable to string injection attacks. In
our approach, we leverage Base64 encoding, one of the many
existing ways [36, 29] to prevent string injection attacks.
Virtual Browser also provides a ﬁle loading interface.
An XM LHT T P Request will be made to the same ori-
gin web server (where all third-party and trusted codes and
Virtual Browser are fetched) ﬁrst by Virtual Browser. The
same origin web server will redirect the request to the real
web server (www.a.com). Therefore received contents will be
fed into the aforementioned evaluate interface.
3.1.2 Components and Data Objects
The functionality of these components and data objects
in Virtual Browser is similar to their corresponding parts in
native browser.
Components of Virtual Browser include a virtual Java-
Script parser, a virtual JavaScript execution engine, a vir-
tual HTML parser, a virtual CSS parser and so on.
• Virtual JavaScript Parser:
It parses third-party Java-
Script codes and outputs the parsed JavaScript AST tree.
• Virtual JavaScript Execution Engine: It executes the parsed
JavaScript AST tree from virtual JavaScript parser. The
interface of the JavaScript execution engine has three
parts: putValue, getValue and function call/return. put-
Value is loaded every time an object is changed. Every
modiﬁcation to a private (deﬁned by third-party) func-
tion/variable or a shared (from trusted scripts or third-
party) function/variables goes through putValue. Get-
Value provides an interface for every read operation. Func-
tion call/return are used for calling shared functions from
natively running code and private functions from third-
party codes. Our design of the interface of the virtual
JavaScript engine is similar to the one of the native Java-
Script engine. Several works[10, 15] have details about
the native JavaScript engine’s interface.
• Virtual CSS Parser: It parses CSS codes and attaches
the results to Virtual DOM.
• Virtual HTML Parser: It parses HTML codes provided
by other components and output DOM tree.
Data objects of Virtual Browser include virtual DOM and
other private objects.
• Virtual DOM: It is linked to the native DOM as an iframe.
The link is purely for virtual DOM to be shown on the
screen. JavaScript access to native DOM from third-
party codes is forbidden by our virtualization technique as
shown in Section 4.1. JavaScript access to virtual DOM
from trusted codes is also forbidden by iframe isolation3.
Meanwhile, the native DOM also transfers all the events
generated automatically by native browsers back to Vir-
tual Browser.
• Private Objects: Private data is used to store JavaScript
objects that is only accessible to third party JavaScript in
Virtual Browser. Section 4.1.2 gives the isolation details.
3.1.3 Flows
Flows inside Virtual Browser. When a third-party Java-
Script code runs into Virtual Browser, the virtual JavaScript
parser will ﬁrst parse it to an AST tree and give the tree to
the virtual JavaScript execution engine. The virtual Java-
Script execution engine will execute the AST tree similar to
a normal JavaScript interpreter does. When HTML content
is found, virtual JavaScript execution engine will send it to
the virtual HTML parser. Similarly, JavaScript codes and
CSS style sheets will be sent to the virtual JavaScript and
CSS parsers. Virtual HTML parser will parse HTML and
will send scripts/style sheets to the virtual JavaScript/CSS
parsers. All of these processes are shown in Figure 3. We
will give a detailed analysis on these ﬂows in Section 4.2.2.
Flows between Virtual Browser and Trusted Codes.
Virtual Browser is isolated from trusted codes as analyzed
in Section 4.1. The only ﬂow left is a shared object4 that
connects trusted codes running upon a native browser and
third-party codes running on a Virtual Browser.
3.2 Examples for Several JavaScript Opera-
tions
3Notice that the isolation provided by iframe is purely for
preventing access to virtual DOM from trusted code by mis-
take so that privilege escalation can be minimized (Please
refer to Section 4.1.2 for details). Virtual Browser is still
more robust to unknown native JavaScript engine vulnera-
bilities than native sandbox approaches, like AdJail [35].
4Object here is an abstracted concept, which can also be a
single value. According to some recent work done by Barth
et al.[13], in some cases, values might be less error-prone
than objects.
Third-Party 
JavaScript Code
Virtual Browser
Components
Data Objects
Virtual JavaScript 
Virtual HTML 
Virtual CSS 
Parser
Script
Parser
Parser
AST 
Virtual JavaScript 
Execution Engine
HTML
Style Sheet
Style Sheet
Access
Call
Attach
Virtual 
DOM
Private 
Objects
Trusted 
Code
Link to
Event
DOM
Native 
JavaScript
Parser
Shared 
Object
Native JavaScript Execution Engine
Figure 3: System Architecture
ZLWKH[S^
ERG\
`
9LUWXDO-63DUVHU
ZLWK
H[S
FKDQJHVFRSH
H[HFXWHERG\
ERG\
9LUWXDO-6
([HF(QJLQH
DZLWK
HYDOVWU
9LUWXDO-6
3DUVHU
HYDO
VWU
9LUWXDO-6
([HF(QJLQH
EHYDO
VWU
GRFXPHQWZULWHVWU
VUFIRUVFULSWWDJ
9LUWXDO-63DUVHU
9LUWXDO+70/3DUVHU
GRFXPHQW
ZULWH
VWU
9LUWXDO-6
([HF(QJLQH
UHVSRQVH
VWU
FDOO
9LUWXDO'20
FGRFXPHQWZULWHLQQHU+70/LVVLPLODU
6DPH2ULJLQ
:HE6HUYHU
IRUZDUG
UHT
5HDOVUF
:HE6HUYHU
Figure 4: Securing Several Dynamic JavaScript Op-
erations
In this section, we illustrate several JavaScript operations
in Virtual Browser to show how Virtual Browser works.
Some of them are not supported by previous approaches.
with. with is a notoriously hard problem in this area. None
of the existing works can solve this problem. In our system,
with becomes quite simple because Virtual Browser inter-
prets JavaScript. For example, as shown in Figure 4(a),
with exp in our system is just a switch of current context.
eval. eval is often disallowed by existing approaches to-
tally or partially because it will introduce additional un-
predictable JavaScript. As shown in Figure 4(b), Virtual
Browser just needs to redirect contents inside eval back to
our virtual JavaScript parser. No matter how many evals are
embedded, such as eval(eval(...(alert(’1’))...), JavaScript is
still executing inside our virtual JavaScript engine.
document.write/innerHTML. document.write and inner-
HTML are related to the HTML parser. As shown in Figure
4(c), when virtual JavaScript execution engine encounters
functions/variables like these, it will redirect them to the
virtual HTML parser by calling methods in virtual DOM.
If scripts like  are found in those
HTML codes, an XMLHTTPRequest like http://www.foo.
com/get.php?req=... will be sent to the same origin web
server (www.foo.com, where all third-party and trusted codes
and Virtual Browser are fetched) due to same-origin pol-
icy restriction and then redirected to the real web server.
JavaScript contents will be received and redirected back to
virtual JavaScript parser.
arguments. arguments are implemented inside a function.
Arguments of the current function are stored in the current
running context. When the third party codes use arguments,
Virtual Browser can fetch them directly.
4. SECURITY ANALYSIS
In this section, we analyze the security of Virtual Browser
by making sure third-party JavaScripts and their data ﬂows
only inside Virtual Browser, and create necessary commu-
nication channels to the data and resources outside Virtual
Browser. We adopt two methods to ensure security : avoid-
ance and redirection.
In Section 4.1, we sandbox all the
components inside Virtual Browser by cutting oﬀ the inﬂows
and outﬂows to and from the sandbox. We avoid using some
of JavaScript’s dangerous functions in the Virtual Browser
implementation to achieve isolation. In Section 4.2, we en-
able shared objects and communications with security access
control. Because we have already built an isolated sandbox,
in the second part of the design, we mainly redirect danger-
ous ﬂows within the third party code back to the sandbox
to facilitate communication.
4.1 Isolation through Avoidance
As we mentioned before, we design our sandbox as an-
other browser built on top of existing browsers, which we
call the Virtual Browser, similar to the concept of a vir-
tual machine. The right part of Figure 1 shows a Virtual
Browser upon a native browser. The Virtual Browser and
the trusted JavaScripts from the web site are all running on
the native browser. The third-party JavaScript is running
on the virtual browser. The method for building the Virtual
Browser is similar to building a native browser. We need
to build a JavaScript engine, HTML parser, CSS parser and
so on. Those components are fully written in JavaScript.
We will not focus on how to implement each of the com-
ponents here, which are not very diﬀerent from writing a
native browser. What we are interested in is how to isolate
the Virtual Browser from native browsers. Since we have
not introduced communication yet, we only need to enforce
isolation between the trusted JavaScripts from the web site
and the third-party JavaScripts.
4.1.1 Cutting off Outﬂows of Virtual Browser
Cutting oﬀ outﬂows of Virtual Browser means that we
want to prevent the third-party codes that run on Virtual
Browser from running directly on the native browser. We en-
sure the third-party codes are trapped inside Virtual Browser.
To achieve that, we have the following assumption.
Any JavaScript code has to be parsed in the native Java-
• evaluate. This function is used by JSC (a test module
in the JavaScript Core, not used in real browsers) and
the DOM to parse  tag, which is outside the
JavaScript Core.
• constructFunction. It is the function constructor. When
feeding a string into the function constructor, JavaScript
parsing is triggered. It is used by JSEventlistener which
binds a JavaScript function as an event handler for a spe-
ciﬁc event, and also is used by JSObjectMakeFunction,
an open API provided by the JavaScript Core.
Script parsers before it can be executed in native browser.
• functions in JavaScript Debugger. Virtual Browser is not
The Virtual Browser treats a third-party JavaScript as a
string, and the string is the input for a virtualized browser
instance. Virtual Browser calls the virtual JavaScript parser,
which is part of the virtual JavaScript engine, to parse the
string, and then executes the code on the virtual JavaScript
interpreter. We need to prevent any part of the string from
feeding into the native JavaScript, CSS, and HTML parsers.
On native browsers, the operations that can cause JavaScrip-
t/CSS/HTML parsing are limited. Therefore, we have to
avoid using all kinds of operations, such as eval, document.write
and so on when implementing our system, so that the na-
tive parsers have no chance to be triggered on the string that
contains the third-party JavaScript code.
The follow-up question is how we can ﬁnd these opera-
tions that cause native parsing. We use two approaches:
looking up references and looking at the source code of na-
tive browsers. Most browsers have their own references and
many browsers obey certain standards such as DOM, CSS,
and JavaScript. We look at those manuals to ﬁgure out
which functions trigger native parsing.
However, those manuals may be erroneous and may be
lacking details. Call graph analysis on the source code of
native browsers is another option. We examine parts of the
call graph in which only functions which call the parse func-
tion will be listed (the functions, which indirectly call the
parse function through other functions, are also included).
We avoid using all of the functions that are direct or in-
direct callers to native parsing when implementing Virtual
Browser.
Cutting off Outﬂows to the Native JavaScript Parser.
We need to make sure the third-party codes running in
the Virtual Browser cannot leak to the native JavaScript
parser. First, we looked up the JavaScript reference[6] and
veriﬁed that only eval and function construction from string,
such as new Function(string) can result in calling the Java-
Script parser. We also did a static call graph analysis of the
WebKit5 JavaScript Core using Doxygen[3].
In WebKit, we found that the following functions could
call the JavaScript parser directly or indirectly. We trace
functions only in the JavaScript Core.
• opcode op call eval. When eval is evaluated, op call eval
is called, and the JavaScript parser is invoked to parse
the parameter of eval.
5Some undocumented and non-standard functions that can
cause parsing may be used in close-source browsers,
like
IE, and new features may also be introduced in future ver-
sion of those browsers. However, because we do not even
know those new, undocumented, or non-standard functions,
they are deﬁnitely not used in the source codes of Virtual
Browser.
using debugging mode.
• functions in JavaScript Exception Handling. A JavaScript
string may be reparsed during exception handling in or-
der to get information such as line number, exception id,
etc. In the reparsing function, it will reparse exactly the
same string as before.
• numericCompareFunction. It uses the JavaScript parser
to parse a numeric constant string. Numeric constants
can be considered as safe, so this is not an issue.
Because the code of Virtual Browser uses only the basic
functions in the native JavaScript engine, to avoid using eval
and function construction through string is enough to pre-
vent third-party JavaScripts in Virtual Browser from leaking
out to the native JavaScript parser.
Cutting off Outﬂows to the Native HTML Parser and
the CSS Parser.
Similar to cutting oﬀ ﬂows to the native JavaScript parser
discussed above, we need to make sure that third-party HTML
or CSS do not leak to the native parsers. We found that the
native core JavaScript engine does not call the native HTML
or CSS parsers at all, so we can be sure that the third-party
HTML or CSS is not leaked to the native parsers from Vir-
tual Browser.6
In conclusion, outﬂows of Virtual Browser are cut oﬀ.
4.1.2 Cutting off Inﬂows of Virtual Browser
Cutting oﬀ inﬂows of Virtual Browser means preventing
the trusted JavaScripts of the web site from accessing the ob-
jects in Virtual Browser directly. Although the JavaScripts
from the web site may not have intentionally malicious be-
havior, it may inﬂuence the virtualized browser by mistake.
For virtual DOM, we link data in virtual DOM to an iframe
tag to prevent trusted codes from the web site to access it by
mistake. For other objects, we perform an encapsulation of
the virtualized browser based on the encapsulation of Object
in object-oriented languages. We provide only a limited API
as the interface and put all other variables and objects as
private objects inside Virtual Browser. We also use anony-
mous objects to prevent inheritance and misuse of Virtual