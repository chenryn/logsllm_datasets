title:Detecting Stack Layout Corruptions with Robust Stack Unwinding
author:Yangchun Fu and
Junghwan Rhee and
Zhiqiang Lin and
Zhichun Li and
Hui Zhang and
Guofei Jiang
Detecting Stack Layout Corruptions
with Robust Stack Unwinding
Yangchun Fu1,2, Junghwan Rhee1(B), Zhiqiang Lin2, Zhichun Li1,
Hui Zhang1, and Guofei Jiang1
1 NEC Laboratories America, Princeton, USA
{rhee,zhichun,huizhang,gfj}@nec-labs.com
2 University of Texas at Dallas, Richardson, USA
{yangchun.fu,zhiqiang.lin}@utdallas.edu
Abstract. The stack is a critical memory structure to ensure the correct
execution of programs because control ﬂow changes through the data
stored in it, such as return addresses and function pointers. Thus the
stack has been a popular target by many attacks and exploits like stack
smashing attacks and return-oriented programming (ROP). We present
a novel system to detect the corruption of the stack layout using a robust
stack unwinding technique and detailed stack layouts extracted from the
stack unwinding information for exception handling widely available in
oﬀ-the-shelf binaries. Our evaluation with real-world ROP exploits has
demonstrated successful detection of them with performance overhead of
only 3.93 % on average transparently without accessing any source code
or debugging symbols of a protected binary.
Keywords: Stack layout corruption · Stack layout invariants · Stack
unwinding information · Return oriented programming
1 Introduction
The stack is a critical memory structure to ensure the correct execution of pro-
grams since control ﬂow changes through the values stored in it (e.g., return
addresses and function pointers). Therefore, the stack has been a popular tar-
get of many attacks and exploits [9,33,36,46,48,51] in the security domain. For
instance, the stack smashing attack [33,36,48,51] is a traditional technique that
has been used to compromise programs. Recently return oriented programming
(ROP) [9,46] has gained signiﬁcant attention due to its strong capability of com-
promising vulnerable programs in spite of up-to-date defense mechanisms, such
as canaries [17], data execution prevention (DEP) [32], and address space layout
randomization (ASLR) [54] under certain conditions (e.g., memory disclosure
vulnerabilities, and the low entropy of ASLR).
Such attacks manipulate one aspect of the stack regarding return addresses
to hijack execution. However, the stack not only contains return addresses but
Y. Fu—Work done during an internship at NEC Laboratories America, Princeton.
c(cid:2) Springer International Publishing Switzerland 2016
F. Monrose et al. (Eds.): RAID 2016, LNCS 9854, pp. 71–94, 2016.
DOI: 10.1007/978-3-319-45719-2 4
72
Y. Fu et al.
also stores many other data, such as local variables and frame pointers, with
speciﬁc rules on its layout for a correct execution state. These rules are stati-
cally constructed by a compiler precisely for each function. Unfortunately such
constraints on the stack layout are not strictly checked by the CPU as evidenced
by the aforementioned attacks allowed, but a correct program execution strictly
follows such constraints and they are in fact parsed and checked when needed
(e.g., exception handling, backtrace in debug). Our intuition is that the current
ROP attacks are not aimed to follow these stack layout constraints. Thus the
inspection of the stack layout could be an eﬀective inspection method to detect
ROP attacks based on the manipulation and the side-eﬀects in the stack layout.
Our method is applicable to multiple stack-based attacks that tamper with the
stack layout (Sect. 3), but we focus on ROP attacks in this paper since it is one
of the most sophisticated and challenging attacks to date.
While many approaches have been proposed to detect and prevent ROP
attacks [16,19,38], they are not without limitations. In particular, many of them
heavily rely on the patterns of ROP gadgets, e.g., the length of a gadget, and
the number of consequent gadgets. As such, attacks violating these patterns keep
emerging, as witnessed by the recent attacks [12,25].
An early exploration toward this direction, ROPGuard [21], detects ROP
attacks by unwinding stack frames using a heuristic approach, based on the
stack frame pointer [3] (i.e., ebp-based stack unwinding in Windows). This is
one way to check the sanity of the stack with an assumption on the compiler’s
practice. Unfortunately, its detection policy is not general in many operating
systems causing a failure to protect the programs compiled without the stack
frame pointers. For instance, from the version 4.6 of GCC (the GNU Compiler
Collection), the frame pointer option (-fomit-frame-pointer) is omitted by
default for the 32-bit Linux making this approach unreliable.
In this paper we present a novel systematic approach called SLIck1 to verify
the stack layout structure at runtime with accurate and detailed information,
which is generated by a compiler for exception handling [1,2] and available inside
the binaries. From this information, we extract stack layout invariants that must
hold at all times. We show verifying these invariants is eﬀective for detecting
the stack manipulation caused by ROP attacks overcoming the limitations of
previous approaches based on stack unwinding. For our approach to be practical,
this information should not be optional during compilation, or require source
code since in many environments a program is deployed in the binary format.
A pleasant surprise is that the stack frame layout information is widely available
in Linux ELF binaries stored in the .eh frame section due to the support of
exception handling (even for C code). Moreover, this binary section is required
in the x86 64 application binary interface (ABI) [6].
The contribution of this paper is summarized as follows:
– We present two novel security invariants of the stack regarding legitimate
return address chains and legitimate code addresses based on the data stored
1 SLIck represents Stack Layout Invariants Checker similar to fsck.
Detecting Stack Layout Corruptions with Robust Stack Unwinding
73
in the .eh frame. While the .eh frame provides the information regarding
the stack layout, it is not directly applicable to ROP detection. The invariants
proposed in this paper ﬁll this gap.
– We present a novel ROP detection technique based on stack layout invariants
and a robust stack unwinding. This mechanism improves the robustness of
a prior heuristic-based stack unwinding (e.g., ebp-based [21]), which fails to
inspect the binaries that are not compiled with frame pointer support.
– We propose ﬂexible stack unwinding algorithm to overcome a general and
practical challenge in stack unwinding approaches which fail to unwind the
entire stack due to the incompleteness of stack frame information. Our evalu-
ation shows this instance is quite often, which leads to frequent false negative
cases of the stack inspections without addressing this issue.
2 Background
2.1 Return Oriented Programming
Return oriented programming (ROP) is an oﬀensive technique that reuses pieces
of existing code chained together to create malicious logic. An attacker identiﬁes
a set of instruction sequences called gadgets linked together using payloads, which
traditionally are placed in the stack [46] transferring control ﬂow via the return
instructions. Recently the attack pattern became diverse involving the call or jump
instructions, which can trigger an indirect control ﬂow [13] and the payloads can
be also placed in other places, such as the heap [49].
2.2 Stack Frame Information in Binaries for Exception Handling
When a program executes, many low level operations occur in the stack. When-
ever a function is called, its execution context (e.g., a return address) is pushed
to the stack. Also many operations, such as handling local variables, delivering
function call parameters, the ﬂush of registers, occur on the stack exactly as they
are determined during the compilation time. The speciﬁc rules on how to use
each byte of each stack frame are predetermined and embedded in the program.
Figure 1 illustrates an example of this stack layout information taken from a
function (ngx pcalloc) of nginx, a high-performance HTTP server and reverse
proxy. The top of the ﬁgure shows a part of its disassembled code. The middle
part of the ﬁgure shows an example of the stack layout information, which is orga-
nized with the reference to the head of each stack frame. The memory address of
a stack frame is referred to as the Canonical Frame Address (CFA) [1,2], which
is the stack pointer address at the function call site.
The decoded information at the bottom illustrates the detailed stack lay-
out at each instruction. For instance, [40530c: cfa=32(rsp), rbx=-24(cfa),
rbp=-16(cfa), ret=-8(cfa)] shows the exact locations of the top of the cur-
rent stack frame (cfa=), the pushed register values (rbx=, rbp=), and the return
address (ret=) described in terms of the stack pointer address and the oﬀsets at
74
Y. Fu et al.
Fig. 1. A detailed view of the stack layout information of the Nginx binary.
the instruction at 0x40530c. This information shows the detailed rules on the
stack usage which were not considered by the current ROP attacks to evade.
While we have found that the stack frame information is useful for the detec-
tion of ROP exploits, to be a practical solution, this information should be widely
available in binaries. Modern programming languages mostly support exception
handling. To do so, the runtime environment should be capable of interpret-
ing and unwinding stack frames such that the exception handler can correctly
respond to the exceptions. The ELF binary format, which is widely used in the
Linux and BSD operating systems, stores it in the .eh frame and .eh framehdr
sections [2]. Similar information is also available in other platforms to support
exception handling. For instance, the Windows OS has an exception handling
mechanism called Structured Exception Handling (SEH) [5,42]. The mach-O [4]
binary format used by Apple Macintosh programs has similar binary sections
(.eh frame, .cfi startproc, and .cfi def cfa offset).
Our investigation shows that the .eh frame section is included by default
in the compilation using the gcc and g++ compilers for C and C++ pro-
grams. According to the deﬁnition of the application binary interface (ABI) for
x86 64, it is a required section for a binary [6]. The strip utility with the most
strict option (e.g., strip --strip-all) does not aﬀect this section. In addi-
tion, most binaries deployed in modern Linux distributions include this section.
Detecting Stack Layout Corruptions with Robust Stack Unwinding
75
For instance, in Ubuntu 12.04 64 bit version all binaries in the /bin directory
have a valid .eh frame section. Among the entire set of the program binaries
examined, over 97 % of around 1700 binaries have this information except special
binaries: the Linux kernel image (e.g., kernel.img) and the binaries compiled
with klibc, which is a special minimalistic version of the C library used for
producing kernel drivers or the code executed in the early stage of a booting.
3 Overview of SLIck
We use the stack layout information available from the binary section for excep-
tion handling to detect ROP exploits. As a research prototype, we present
SLIck, a robust stack unwinding based approach that does not rely on any
gadget patterns, such as a gadget sequence, or behavior. Previous approaches
(e.g., [16,19,38]) are based on the characteristics of ROP gadgets, such as call-
precedence or the length of gadget sequences, which make them vulnerable to
new attacks [12,25]. The overview of SLIck is illustrated in Fig. 2.
SLIck uses two invariants regarding the stack layout information (to be
shortly described in Sect. 4 in details) to detect an ROP attack.
– Stack Frame Chain Invariant (Sect. 4.1). The stack frame information
inside the binary describes how stack frames must be chained, and the unwind-
ing of the runtime stack information should not be diﬀerent from it.
– Stack Frame Local Storage Invariant (Sect. 4.2). The accumulated stack
operations in a function are summarized as a constant because the memory
usage in each stack frame should be cleaned up when the function returns.
SLIck inspects the runtime status of the monitored program’s stack regard-
ing these two invariants transparently and eﬃciently so that ROP attacks can
be precisely detected. SLIck has two major system components.
– Derivation of stack layout invariants (Sect. 4). To achieve eﬃcient run-
time checks, the necessary information is derived in an oﬄine binary analysis.
Given a binary executable as an input, this component extracts the stack
frame information from the .eh frame section and constructs stack layout
invariants. Also, the table of valid instructions of this binary is derived to
verify the stack frame local storage invariant.
Fig. 2. System overview of SLIck.
76
Y. Fu et al.
– Runtime inspection of stack invariants (Sect. 5). This component veri-
ﬁes whether stack invariants hold at runtime and detects any violation caused.
SLIck inspects the stack status when an OS event is triggered to avoid high
overhead of ﬁne-grained techniques [14,19]. Diverse OS events with diﬀerent
characteristics can be used to trigger the inspection as policies. For instance,
the inspection on all system calls will catch the ROP behavior that uses any
system services, such as a ﬁle access, and network usage. Using the timer inter-
rupts, which trigger the context switches, enables non-deterministic inspection
points that make it hard to accurately determine our inspection time and also
enables frequent inspections in the CPU intensive workload.
Adversary Model and Assumptions. We consider an adversary who is able
to launch a user-level stack-based return oriented programming (ROP) attack,
which modiﬁes the stack to inject its payload using a native program in the
ELF format with the stack frame layout information widely available in the
Linux platform. There is no assumption on the characteristics of gadget content
(e.g., a sequence, a length, and the call-precedence of gadgets) which can be used
in the attack.
The techniques in this paper are in the context of Linux and the ELF binary
format because the mechanism and the implementation of the stack layout infor-
mation is speciﬁc to each OS platform due to the distinct underlying structures
of OSes. However, we believe a similar direction can be explored in other OS
platforms which are described in the discussion section.
We assume that the integrity of the operating system kernel is not compromised
and the ROP attack is not towards the vulnerability and the compromise of the
kernel. While such attack scenarios of ROP exploits are realistic, in this paper we do
not focus on the countermeasures for such attacks because of the existing detection
and prevention mechanisms on OS kernel integrity [22,23,27,39–41,45]. We rely on
such approaches to ensure the integrity of OS kernel and SLIck, which is designed
to be a module of it.
Finally, we mainly focus on native programs for the detection of ROP
exploits. The programs based on dynamically generated code running on virtual
machines, interpreters, and dynamic binary translators have their own unique
structures on their runtime and the stack layout. Currently, we do not focus on
ROP defense for these binaries.
4 Derivation of Stack Layout Invariants
Rich stack layout information of the .eh frame section can be used to derive
potentially many invariants regarding the layout of the stack. In this paper, we
focus on two invariants that are motivated by the following challenges.
First, ROP attacks can manipulate the valid chains of the function calls of
the original program, and determining such manipulation robustly and trans-
parently is a remaining challenge. Recent approaches on control-ﬂow integrity
have made substantial progress particularly when they can access or transform
Detecting Stack Layout Corruptions with Robust Stack Unwinding
77
source code [18,56]. Some approaches attempted to achieve a practical control-
ﬂow integrity by relaxing strict control-ﬂow [60,61]. However, they still introduce
new attacks [24]. Second, ROP gadgets popularly utilize unintended instructions
and it is non-trivial to detect such usage eﬃciently. We introduce two stack lay-
out invariants to solve these challenges.
4.1 Stack Frame Chain Invariant (FCI)
Observation. The description regarding the head of a stack frame (CFA), can
validate how far a previous stack frame should be apart from the current one.
For instance, the information [40530c: cfa=32(rsp), ..., ret=-8(cfa)] in
Fig. 1 shows that the CFA is at the address stored in the rsp register plus 32,
and the return address is at ret = −8(cf a) which is resolved as rsp + 32 − 8
using the location of the CFA. This information enables the validation of the
linkage of stack frames.
Invariant. For an instruction c in a function, let us deﬁne the accumulation
of stack operations between the function prologue and c in terms of a stack
distance as BL(c) (Backward stack frame Layout). This information generated
by a compiler for the instruction c is retrieved from the CFA of .eh frame. For
instance, the return address at B6 in Fig. 3, BL(B6) is −12(SP ) (i.e., stack
pointer + 12 bytes) due to three decrements of the stack pointer (each by 4
bytes) for local variables. A runtime version, BL(cid:3)(c), is subject to manipulation
under attacks requiring the veriﬁcation whether it conforms to BL(c) for all
stack frames in a chain. This invariant is presented as BL(c) = BL(cid:3)(c) called
the Stack F rame C hain I nvariant (FCI ).
Veriﬁcation. SLIck checks this invariant using a stack unwinding algorithm
(Sect. 5) iteratively over all stack frames validating the integrity of the BLs as a
chain. Any inconsistency in one of the BLs in the chain causes cascading eﬀects in
the following stack frames, therefore, breaking the BL sequence in the unwinding
Fig. 3. Illustration of stack layout invariants.
78
Y. Fu et al.
procedure. SLIck determines this invariant is satisﬁed if the unwinding proce-
dure over all stack frames is successful. To perform this runtime veriﬁcation
eﬃciently, we precompute the BLs using the CFAs from the .eh frame section.
4.2 Stack Frame Local Storage Invariant (FSI)
Observation. Programs use the stack to store data (e.g., for local variables
and register spills). To limit the impact across stack frames, the allocation and
deallocation of local stack memory in a frame should be paired up so that the
stack memory usage for a function could be cleaned up when the function returns.
Invariant. This observation regarding the gross sum of local stack operations is
summarized as follows. Let us deﬁne the accumulated stack operations between
the code c and the function epilogue in terms of a stack distance as F L(c)
(F orward stack frame Layout). The observation on the stack local storage is
represented as BL(c)+F L(c) = k, which we call the Stack F rame Local Storage
I nvariant (FSI ). In the right ﬁgure of Fig. 3, BL(B6) is −12(SP ), and F L(B6)
is 12(SP ) leading to k = 0. Typically k should be zero except the special corner
cases where functions do not properly return such as the exit. This invariant
allows to determine the usage of unintended code popularly used in ROP attacks
because such code may not follow the original code’s semantic.
Veriﬁcation. To eﬃciently check whether the executed code conforms to this
invariant, we precompute a table of instructions originally intended in the pro-
gram, named as a table of valid code addresses (TVC). Its rows show all possible
code addresses (i.e., every byte oﬀset of the code including unintended code in
the program) and the column indicates a boolean state whether the code is valid
(T ) or invalid (F ) depending on the BL(c) + F L(c).
We use the .eh frame and a binary analysis for the computation of this
table. The instructions derived from the stack frame information are marked
as valid. However, due to its compressed structure, which mainly describes the
instructions involving stack operations, not every instruction is covered. For such
cases, we use a binary analysis to simulate the instructions and determine the
validity. SLIck applies this check as part of a stack unwinding algorithm.
SLIck considers that a program is compromised if either or both of these
two invariants are violated. We present more speciﬁc details on how to check
them at runtime in Sect. 5.
5 Runtime Inspection of Stack Invariants
In this section, we present how SLIck inspects stack invariants and robustly
detects their violations.
Detecting Stack Layout Corruptions with Robust Stack Unwinding
79
5.1 Practical Challenges
After we use a traditional stack unwinding algorithm [3] to inspect the invariants,
we have identiﬁed the cases that frustrate the current algorithm and limit the
inspection of the full stack. There are two cases categorized.
Failure type Description
Attributes of virtual memory pages Binary exist Unwind info
Type A
Type B
Incomplete unwinding info Code
Executable
Invalid unwinding
Not found Not executable
Type
Page permission
exist
Yes
*
No
*
Type A: Incomplete Unwinding Information. We found that a rare por-