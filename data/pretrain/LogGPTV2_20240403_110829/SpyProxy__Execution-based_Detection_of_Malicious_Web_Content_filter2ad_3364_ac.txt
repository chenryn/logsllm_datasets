results in Section 4 conﬁrm this optimization is safe in
practice. Thus, a pipeline is established in which content
is transmitted and released incrementally to the client
browser.
In Figures 2(a) and 2(b), only part of the main Web
page has been downloaded and rendered by the VM
browser. In Figure 2(c), all of the ﬁrst embedded object
has been rendered by the VM, which causes that object
and some of the main Web page content (shown in black)
to be released and transmitted to the client browser. More
of the main Web page and the second embedded object
is downloaded and rendered in Figure 2(d), until ﬁnally,
in Figures 2(e) and 2(f), the full Web page is released.
Many Web pages contain dozens of embedded im-
ages. For example, CNN’s Web page contains over 32
embedded objects. Faced with such a Web page, our
staged release optimization quickly starts feeding the
client browser more and more of the root page and as-
sociated embedded objects. As a result, the user does not
observe expensive Web access delay.
Note that staged release is independent from prefetch-
ing. With prefetching, content is pushed to the client-side
agent before SpyProxy releases it to the client browser;
however, no content is released until the full page is
checked. With staged release, content is released incre-
mentally, but released content is not prefetched. Staged
release can be combined with prefetching, but since it
does not require a client-side agent to function, it may
be advantageous to implement staged release without
prefetching. We evaluate each of these optimizations in-
dependently and in combination in Section 4.
3.4 Additional optimizations
SpyProxy contains a few additional optimizations.
First, the VM worker is conﬁgured to have a browser
process already running inside, ready to accept a URL
to retrieve. This avoids any start-up time associated with
booting the guest OS or launching the browser. Sec-
ond, the virtual disk backing the VM worker is stored
in a RAM-disk ﬁle system in the host OS, eliminating
the disk trafﬁc associated with storing cookies or ﬁles
in the VM browser. Finally, instead of cloning a new
VM worker for every client request, we re-use VM work-
ers across requests, garbage collecting them only after a
trigger ﬁres or a conﬁgurable number of requests has oc-
curred. Currently, we garbage collect a worker after 50
requests.
4 Evaluation
This section evaluates the effectiveness and perfor-
mance of our SpyProxy architecture and prototype. The
Table 1: Effectiveness of SpyProxy. The effectiveness of
SpyProxy at detecting and blocking malicious Web content.
SpyProxy was successful at detecting and blocking 100% of
the malicious Web pages we visited, in spite of the fact that
most of them contained non-determinism. In comparison, the
SiteAdvisor service incorrectly classiﬁed 20% of the malicious
Web domains as benign.
prototype includes the performance optimizations we de-
scribed previously. Our results address three key ques-
tions: how effective is our system at detecting and block-
ing malicious Web content, how well do our performance
optimizations mask latency from the user, and how well
does our system perform given a realistic workload?
4.1 Effectiveness at Blocking Malicious Code
We ﬁrst consider the ability of SpyProxy to success-
fully block malicious content. To quantify this, we man-
ually gathered a list of 100 malicious Web pages on 45
distinct sites. Each of these pages performs an attack of
some kind. We found these pages using a combination of
techniques, including: (1) searching Google for popular
Web categories such as music or games, (2) mining pub-
lic blacklists of known attack sites, and (3) examining
public warning services such as SiteAdvisor.
Some of the Web pages we found exploit browser vul-
nerabilities to install spyware. Others try to “push” ma-
licious software at clients spontaneously, requiring user
consent to install it; we have conﬁgured SpyProxy to
automatically accept such prompts to evaluate its effec-
tiveness at blocking these threats. The pages include a
diversity of attack methods, such as the WMF exploit,
ActiveX controls, applet-based attacks, JavaScript, and
pop-up windows. A successful attack inundates the vic-
tim with adware, dialer, and Trojan downloader software.
Table 1 quantiﬁes the effectiveness of our system.
SpyProxy detected and blocked 100% of the attack
pages, despite the diversity of attack methods to which
it was exposed. Further, most of these attack pages con-
tained some form of non-deterministic content; in prac-
tice, none of the attacks we found attempted to evade
detection by “hiding” inside non-deterministic code.
The table also shows the advantage of our on-the-ﬂy
approach compared to a system like SiteAdvisor, which
provides static recommendations based on historical ev-
idence. SiteAdvisor misclassiﬁed 20% of the malicious
sites as benign. While we cannot explain why SiteAdvi-
 browser exploits 27 spontaneous downloads 73 malicious pages visited total 100 # sites containing the malicious pages 45 malicious pages blocked by SpyProxy 100% malicious domains identified by SiteAdvisor 80% malicious pages containing non-determinism 96%  sor failed on these sites, we suspect it is due to a combi-
nation of incomplete Web coverage (i.e., not having ex-
amined some pages) and stale information (i.e., a page
that was benign when examined has since become ma-
licious). SpyProxy’s on-the-ﬂy approach examines Web
page content as it ﬂows towards the user, resulting in a
more complete and effective defense.
For an interesting example of how SpyProxy works in
practice, consider www.crackz.ws, one of our 100 mali-
cious pages. This page contains a specially crafted im-
age that exploits a vulnerability in the Windows graph-
ics rendering engine. The exploit runs code that silently
downloads and installs a variety of malware, including
several Trojan downloaders. Many signature-based anti-
malware tools would not prevent this attack from suc-
ceeding; they would instead attempt to remove the mal-
ware after the exploit installs it.
In contrast, when SpyProxy renders a page from
www.crackz.ws in a VM, it detects the exploit when the
page starts performing unacceptable activity. In this case,
as the image is rendered in the browser, SpyProxy de-
tects an unauthorized creation of ten helper processes.
SpyProxy subsequently blocks the page before the client
renders it. Note that SpyProxy does not need to know
any details of the exploit to stop it. Equally important,
in spite of the fact that the exploit attacks a non-browser
ﬂaw that is buried deep in the software stack, SpyProxy’s
behavior-based detection allowed it to discover and pre-
vent the attack.
4.2 Performance of the Unoptimized System
This section measures the performance of the basic
unoptimized SpyProxy architecture we described in Sec-
tion 2.3. These measurements highlight the limitations
of the basic approach; namely, unoptimized SpyProxy
interferes with the normal browser rendering pipeline by
delaying transmission until an entire page is rendered and
checked. They also suggest opportunities for optimiza-
tion and provide a baseline for evaluating the effective-
ness of those optimizations.
We ran a series of controlled measurements, testing
SpyProxy under twelve conﬁgurations that varied across
the following three dimensions:
• Proxy conﬁguration. We compared a regular
browser conﬁgured to communicate directly with
Web servers with a browser that routes its requests
through the SpyProxy checker.
• Client-side network. We compared a browser
running behind an emulated broadband connection
with a browser running on the same gigabit Ethernet
LAN as SpyProxy. We used the client-side NetLim-
iter tool and capped the upload and download client
Table 2: Performance of the unoptimized SpyProxy. These
tables compare the latency of an unprotected browser that
downloads content directly from Web servers to that of a pro-
tected browser downloading through the SpyProxy service. We
show the latency until the page begins to render on the client
and the latency until the page ﬁnishes rendering. The data are
shown for three Web pages as well the client on (a) an emulated
broadband access link, and (b) the same LAN as SpyProxy.
bandwidth at 1.5 Mb/s to emulate the broadband
connection.
• Web page requested. We measured three different
Web pages: the Google home page, the front page
of the New York Times, and the “MSN shopping in-
sider” blog, which contains several large, embedded
images. The Google page is small: just 3,166 bytes
of HTML and a single 8,558 byte embedded GIF.
The New York Times front page is larger and more
complex: 92KB of HTML, 74 embedded images, 4
stylesheets, 3 XML objects, 1 ﬂash animation, and
10 embedded JavaScript objects. This represents
844KB of data. The MSN blog consists of a 79KB
root HTML page, 18 embedded images (the largest
of which is 176KB), 2 stylesheets, and 1 embedded
JavaScript object, for a total of 1.4MB of data.
For each of the twelve conﬁgurations, we created
a timeline showing the latency of each step from the
client’s Web page request to the ﬁnal page rendering in
the client. We broke the end-to-end latency into several
components, including WAN transfer delays, the over-
head of rendering content in the VM worker before re-
leasing it to the client, and internal communication over-
head in the SpyProxy system itself. We cleared all caches
in the system to ensure that content was retrieved from
the original Web servers in all cases.
For each conﬁguration, Table 2 shows the time until
content ﬁrst begins to render on the user’s screen and the
time until the Web page ﬁnishes rendering. In all cases,
 Google NY Times MSN blog  render begins render ends render begins render ends render begins render ends direct 0.21s 0.64s 0.41s 4.8s 0.40s 10.2s unoptimized SpyProxy 0.79s 1.2s 3.4s 7.3s 2.7s 12.4s        (a) broadband    Google NY Times MSN blog  render begins render ends render begins render ends render begins render ends direct 0.20s 0.63s 0.41s 3.3s 0.36s 2.3s unoptimized SpyProxy 0.79s 1.2s 3.4s 5.3s 2.7s 3.9s          (b) gigabit  Google NY Times MSN blog  render begins render ends render begins render ends render begins render ends direct 0.21s 0.64s 0.41s 4.8s 0.40s 10.2s unoptimized SpyProxy 0.79s 1.2s 3.4s 7.3s 2.7s 12.4s        (a) broadband    Google NY Times MSN blog  render begins render ends render begins render ends render begins render ends direct 0.20s 0.63s 0.41s 3.3s 0.36s 2.3s unoptimized SpyProxy 0.79s 1.2s 3.4s 5.3s 2.7s 3.9s          (b) gigabit Table 3: Detailed breakdown of the unoptimized SpyProxy.
Events occurring when fetching the New York Times page over
broadband through SpyProxy. Most SpyProxy overhead is due
to serializing the VM browser download and trigger checks be-
fore transferring or releasing content to the client browser.
the unoptimized SpyProxy implementation added less
than three seconds to the total page download time. How-
ever, the time until rendering began was much higher on
the unoptimized system, growing in some cases by a fac-
tor of ten. This conﬁrms that our system can perform
well, but, without optimizations, it interferes with the
browser’s ability to reduce perceived latency by pipelin-
ing the transfer and rendering of content.
Table 3 provides a more detailed timeline of events
when fetching the New York Times page from a broad-
band client using the unoptimized SpyProxy. Download-
ing and rendering the page in the VM browser introduced
2.8 seconds of overhead. Since no data ﬂows to the client
browser until SpyProxy ﬁnishes rendering and checking
content, this VM rendering latency is responsible for de-
lay experienced by the user.
4.3 Performance Optimizations
To reduce the overhead introduced by the unoptimized
SpyProxy system, we previously described three opti-
mization techniques: prefetching content to a client-side
agent, the staged release of content to the client browser,
and caching the results of security checks. We now
present the results of a set of microbenchmarks that eval-
uate the impact of each optimization.
Figure 3 summarizes the benchmark results. Both ﬁg-
ures show the latency to download three different pages
to a client on the emulated broadband connection. For
each page, we show latency for ﬁve cases: (1) the unop-
timized SpyProxy, (2) SpyProxy with only prefetching
enabled, (3) SpyProxy with only staged release enabled,
(4) SpyProxy with a hit in the enabled security cache, and
(5) the base case of a client fetching content directly from
Web servers. Figure 3(a) shows the latency before page
rendering begins in the client browser, while Figure 3(b)
Figure 3: Performance of optimizations (broadband). The
latency until the client browser (a) begins rendering the page,
and (b) ﬁnishes rendering the page. Each graph shows the la-
tency for three different pages for ﬁve conﬁgurations.
Table 4: Prefetching (broadband). Latency improvements
gained by the prefetching optimization in the broadband envi-
ronment. Prefetching alone did not yield signiﬁcant beneﬁts.
shows the latency until page rendering ends.
In combination, the optimizations serve to reduce the
latency before the start of rendering in the client. With
all of the the optimizations in place, the page load “feels”
nearly as responsive through SpyProxy as it does with-
out SpyProxy.
In either case, the page begins render-
ing about a second after the request is generated. The
optimizations did somewhat improve the total render-
ing latency relative to the unoptimized implementation
(Figure 3(b)), but this was not nearly as dramatic. Page
completion time is dominated by transfer time over the
broadband network, and our optimizations do nothing to
reduce this.
time (ms) event 0 user requests URL, browser generates HTTP request 169 SpyProxy FE receives request, requests root page from Squid 538 SpyProxy FE finishes static check, forwards URL to VM 560 VM browser generates HTTP request 561 first byte of root page arrives at VM browser 3055 last byte of last page component arrives at VM browser 3363 VM browser finishes rendering, checking triggers 3374 first byte of root page arrives at client browser 7334 last byte of last page component arrives at client browser 7347 client browser finishes rendering content    client browser transfer and render time: 4.5s   overhead introduced by VM browser: 2.8s   other SpyProxy system overhead: 0.05s 01000200030004000GoogleNew York TimesMSN Blog(a)latency to start rendering (ms)unoptimizedprefetching onlystaged release onlycache hit onlydirect02000400060008000100001200014000GoogleNew York TimesMSN Blog(b)latency to finish rendering (ms)unoptimizedprefetching onlystaged release onlycache hit onlydirect Google NY Times MSN blog  render begins render ends render begins render ends render begins render ends unoptimized SpyProxy 0.79s 1.21s 3.37s 7.3s 2.7s 12.4s prefetching only .78s (-0.01s) 1.15s (-0.06s) 3.43s (+0.06s) 5.2s (-2.1s) 2.2s (-0.5s) 11.3s (-1.1s)  Table 5: Staged release (broadband). Latency improvements
from staged release in the broadband environment. Staged re-
lease signiﬁcantly improved the latency until rendering starts.
It yielded improvements similar to prefetching in the latency
until full page rendering ends.
4.3.1 Prefetching
Prefetching by itself does not yield signiﬁcant ben-
eﬁts. As shown in Table 4, it did not reduce render-
ing start-time latency. With prefetching alone, the client
browser effectively stalls while the VM browser down-
loads and renders the page fully in the proxy. That is,
SpyProxy does not release content to the client’s browser
until the VM-based check ends.
However, we did observe some improvement
in
ﬁnish-time measurements. For example, the time to fully
render the New York Times page dropped by 2.1 seconds,
from 7.3 seconds in the unoptimized SpyProxy to 5.2
seconds with prefetching enabled. Prefetching success-
fully overlaps some transmission of content to the client-
side agent with SpyProxy’s security check, slightly low-
ering overall page load time.
4.3.2 Staged Release
Staged release very successfully reduced initial la-
tency before rendering started; this time period has the
largest impact on perceived responsiveness. As shown
in Table 5, staged release reduced this latency by sev-
eral seconds for both the New York Times and MSN blog
pages. In fact, from the perspective of a user, the New
York Times page began rendering nearly four times more
quickly with staged release enabled. For all three pages,
initial rendering latency was near the one-second mark,
implying good responsiveness.
The staged release optimization also reduced the la-
tency of rendering the full Web page to nearly the same
point as prefetching. Even though content does not start
ﬂowing to the client until it is released, this optimiza-
tion releases some content quickly, causing an overlap of
transmission with checking that is similar to prefetching.
Staged release outperforms prefetching in the case
that matters—initial time to rendering.
It also has the
advantage of not requiring a client-side agent. Once
SpyProxy decides to release content, it can simply begin