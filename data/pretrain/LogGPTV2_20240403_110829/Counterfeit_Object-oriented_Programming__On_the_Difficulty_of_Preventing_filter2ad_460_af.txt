—various— [14], [40], [56]
CPU debugging/performance monitoring features
CPU performance monitoring counters
HDROP [60]
WinAPI function hooking
Microsoft EMET 5 [34]
Binary
STIR [55]
Source code
G-Free [38]
XnR [7]
Binary / source code
—various— [4]–[6], [13], [36], [45] Mostly source code
CPI/CPS [31]
Source code
Effective against COOP ?
() - see §VII-E
/





?




?



?

TABLE II: Overview of the effectiveness of a selection of code reuse defenses and memory safety techniques (below double
line) against COOP;  indicates effective protection and  indicates vulnerability; ? indicates at least partial protection.
a simple form of CFI. We analyzed the proprietary implemen-
tation of Microsoft CFG. In summary, Microsoft CFG ensures
that protected indirect calls may only go to a certain set of
targets. This set is speciﬁed in a module’s PE header [42].
If multiple CFG-enabled modules reside in a process, their
sets are merged. For system libraries (written in C),
this
set is mostly comprised of exported functions. For the C++
mshtml.dll we discovered that all virtual functions are
contained in the set and can thus be invoked from any indirect
call site. Accordingly, Microsoft CFG in its current form does
not prevent COOP, but also likely not advanced ROP-based
attacks like the one by G¨oktas¸ et al.
Tice et al. recently described two variants of Forward-Edge
CFI for the GCC and LLVM compiler suites [52] that solely
aim at constraining indirect calls and jumps but not returns. As
such, taken for itself, forward-edge CFI does not prevent ROP
in any way. One of the proposed variants is the C++-aware
virtual table veriﬁcation (VTV) technique for GCC. It tightly
restricts the targets of each vcall site according to the C++
class hierarchy and thus prevents COOP. VTV is available
in mainline GCC since version 4.9.0. However, the variant
for LLVM called indirect function-call checks (IFCC) “[...]
does not depend on the details of C++ or other high-level
languages” [52]. Instead, each indirect call site is associated
with a set of valid target functions. A target is valid if (i) it is
address-taken and (ii) its signature is compatible with the call
site. Tice et al. discuss two deﬁnitions for the compatibility of
function signatures for IFCC: (i) all signatures are compatible
or (ii) signatures with the same number of arguments are
compatible. We observe that the former conﬁguration does not
prevent COOP, whereas the latter can still allow for powerful
COOP-based attacks in practice as discussed in §VI-A2b.
B. C++-aware CFI
As discussed in §VI, COOP’s control ﬂow can be reliably
prevented when precise C++ semantics are considered from
source code. Accordingly, various source code-based CFI so-
lutions exist that prevent COOP, e. g., GCC VTV as described
above, Safedispatch [29], or WIT [5].
Recently and concurrently, three C++-aware CFI approaches
for legacy binary code have been proposed: T-VIP [24],
vfGuard [41], and VTint [57]. They follow a similar basic
approach:
1) identiﬁcation of vcall sites and vtables (only vfGuard and
VTint) using heuristics and static data-ﬂow analysis
2) instrumentation of vcall sites to restrict the set of allowed
vtables.
T-VIP ensures at each instrumented vcall site that the vptr
points to read-only memory. Optionally, it also checks if a
random entry in the respective vtable points to read-only
memory. Similarly, VTint copies all identiﬁed vtables into
a new read-only section and instruments each vcall site to
check if the vptr points into that section. Both effectively
prevent attacks based on the injection of fake vtables, but as
in a COOP attack only actual vtables are referenced, they do
not prevent COOP. VfGuard instruments vcall sites to check
if the vptr points to the beginning of any known vtable. As
discussed §VI-A2a, such a policy restricts the set of available
vfgadgets signiﬁcantly, but still cannot reliably prevent COOP.
VfGuard also checks the compatibility of calling conventions
and consistency of the this-ptr at vcall sites, but this does
not affect COOP. Nonetheless, we consider vfGuard to be one
of the strongest available binary-only defenses against COOP.
VfGuard signiﬁcantly constraints attackers and we expect it to
be a reliable defense in at least some attack scenarios, e. g.,
for small to medium-sized x86 applications.
C. Heuristics-based Detection
Microsoft EMET [34] is probably the most widely deployed
exploit mitigation tool. Among others, it implements different
heuristics-based strategies for the detection of ROP [23].
Additionally, several related heuristics-based defenses have
been proposed that utilize certain debugging features avail-
able in modern x86-64 CPUs [14], [40], [56]. All of these
defenses have recently been shown to be unable to detect more
758
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:08:18 UTC from IEEE Xplore.  Restrictions apply. 
advanced ROP-based attacks [11], [16], [26], [43]. Similarly,
the HDROP [60] defense utilizes the performance monitoring
counters of modern x86-64 CPUs to detect ROP-based attacks.
The approach relies on the observation that a CPU’s internal
branch prediction typically fails in abnormal ways during the
execution of common code reuse attacks.
As discussed in §VI-A, such heuristics are unlikely to be
practically applicable to COOP and we can in fact conﬁrm
that our Internet Explorer exploits (§V-A and §V-B) are not
detected by EMET version 5.
D. Code Hiding, Shufﬂing, or Rewriting
STIR [55] is a binary-only defense approach that randomly
reorders basic blocks in an application on each start-up to
make the whereabouts of gadgets unknown to an attacker—
even if she has access to the exact same binary. As discussed
in §VI-A1c, approaches like this do conceptually not affect
our attack, as COOP only uses entire functions as vfgadgets
and only knowledge on the whereabouts of vtables is required.
This applies also to the recently proposed O-CFI approach [54]
that combines the STIR concept with coarse-grained CFI.
Execute-no-Read (XnR) [7] is a proposed defense against
so-called JIT-ROP [49] attacks that prevents code pages from
being read. We note that, depending on the concrete scenario,
a corresponding JIT-COOP attack could not always be thwarted
by such measures as it can sufﬁce to readout vtables and
possibly RTTI metadata (which contains the literal names of
classes) from data sections and apply pattern matching to
identify the addresses of the vtables of interest.
G-Free [38] is an extension to the GCC compiler. G-
Free produces x86 native code that (largely) does not contain
unaligned indirect branches. Additionally, it aims to prevent
attackers from misusing aligned indirect branches: return
addresses on the stack are encrypted/decrypted on a function’s
entry/exit and a “cookie” mechanism is used to ensure that
indirect jump/call instructions may only be reached through
their respective function’s entry. While effective even against
many advanced ROP-based attacks [11], [16], [25], [26], [43],
G-Free does not affect COOP.
E. Memory Safety
Systems that provide forms of memory safety for C/C++
applications [4]–[6], [13], [31], [36], [45] can constitute strong
defenses against control-ﬂow hijacking attacks in general. As
our adversary model explicitly foresees an initial memory
corruption and information leak (see §III-B), we do not explore
the defensive strengths of these systems in detail. Instead, we
exemplarily discuss two recent approaches in the following.
Kuznetsov et al. proposed Code-Pointer Integrity (CPI) [31]
as a low-overhead control-ﬂow hijacking protection for C/C++.
On the baseline, CPI guarantees the spatial and temporal
integrity of code pointers and, recursively, that of pointers to
code pointers. As in C++ applications typically many pointers
to code pointers exist (i. e., each object’s vptr), CPI can
still impose a signiﬁcant overhead there. As a consequence,
Kuznetsov et al. also proposed Code-Pointer Separation (CPS)
as a less expensive variant of CPI that speciﬁcally targets C++.
In CPS, sensitive pointers are not protected recursively, but it
is still enforced that “[...] (i) code pointers can only be stored
to or modiﬁed in memory by code pointer store instructions,
and (ii) code pointers can only be loaded by code pointer
load instructions from memory locations to which previously
a code pointer store instruction stored a value” [31] where
code pointer load/store instructions are ﬁxed at compile time.
Kuznetsov et al. argue that the protection offered by CPS
could be sufﬁcient in practice as it conceptually prevents recent
advanced ROP-based attacks [11], [16], [26]. We observe
that CPS does not prevent our attack, because COOP does
not require the injection or manipulation of code pointers.
In the presence of CPS, it is though likely hard to invoke
library functions not
imported by an application. But we
note that almost all applications import critical functions. The
invocation of library functions through an INV-G could also
be complicated or impossible in the presence of CPS. This
is however not a hurdle, because, as CPS does not consider
C++ semantics, imported library functions can always easily
be called without taking the detour through an INV-G as
described in §III-E in approach W-2.
VIII. RELATED WORK
Since we covered related work throughout the paper, we
only brieﬂy review contributions similar to ours in this section.
Closely related to our work, several advanced ROP-based
attacks were recently demonstrated [11], [16], [25], [26],
[43] that bypassed certain coarse-grained CFI systems [3],
[58], [59] or heuristics-based systems [14], [23], [40], [56].
However,
to the best of our knowledge, we are the ﬁrst
to demonstrate bypasses of the latest defenses CPS [31],
T-VIP [24], vfGuard [41], and VTint [57] and the coarse-
grained CFI + shadow call stack [3] concept. We also regard
COOP’s tolerance against the ﬁne-grained rewriting, shufﬂing,
and hiding of executable code as unique.
Bosman and Bos presented Sigreturn Oriented Program-
ming (SROP) [10], a distinct code reuse attack approach
that misuses UNIX signals. SROP is Turing complete and in
contrast to ROP does not chain short chunks of instructions
sequences. In SROP, the UNIX system call sigreturn is re-
peatedly invoked on an attacker supplied signal frames lying
on the stack. Accordingly, as prerequisites, the attacker needs
to control the stack and needs to be able to divert the control
ﬂow such that sigreturn is invoked. SROP was not speciﬁcally
designed to circumvent modern protection techniques, but
rather as an easy-to-use and portable alternative to ROP and
for implementing stealthy backdoors.
Tran et al. demonstrated that Turing complete return-to-libc
attacks are possible [53]. In their described attack, a thread’s
stack is prepared in such a way that certain functions from
libc such as longjmp() or wordexp() are subsequently
executed for varying arguments, where each function returns
to the entry point of its successor. At its core, their approach
shares similarities with ours. However, it can conceptually
not be used to bypass modern CFI systems. Skowyra et
al. demonstrated how the attack by Tran et al. can also be
implemented using other libraries than libc [47].
759
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:08:18 UTC from IEEE Xplore.  Restrictions apply. 
IX. CONCLUSION
In this paper, we introduced counterfeit object-oriented
programming (COOP), a novel code reuse attack technique to
bypass almost all CFI solutions and many other defenses that
do not consider object-oriented C++ semantics. We discussed
the speciﬁcs of object-oriented programming and explained
the technical details behind COOP. We believe that our results
contribute to the ongoing research on designing practical and
secure defenses against control-ﬂow hijacking attacks, a severe
threat that has been around for more than two decades. Our
basic insight that higher-level programming language-speciﬁc
semantics need to be taken into account is a valuable guide for
the design and implementation of future defenses. In particular,
our results demand for a rethinking in the assessment of
defenses that rely solely on binary code.
ACKNOWLEDGMENT
We thank the anonymous reviewers and Herbert Bos for
their constructive comments that guided the ﬁnal version of
this paper. This work has been supported by several organiza-
tion: the German Federal Ministry of Education and Research
(BMBF) under support code 16BP12302 (EUREKA project
SASER), the German Science Foundation as part of project
S2 within the CRC 1119 CROSSING, and the European
Unions Seventh Framework Programme under grant agreement
No. 609611, PRACTICE project.
[1] M. Abadi, M. Budiu,
REFERENCES
´U. Erlingsson, and J. Ligatti. A theory of
secure control-ﬂow. In International Conference on Formal Engineering
Methods (ICFEM), pages 111–124, 2005.
[2] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-ﬂow
integrity: Principles, implementations, and applications. ACM Trans-
actions on Information and System Security (TISSEC), 13(1), 2009.
[3] M. Abadi, M. Budiu, lfar Erlingsson, and J. Ligatti. Control-ﬂow
integrity. In Proceedings of ACM Conference on Computer and Com-
munications Security (CCS), 2005.
[4] P. Akritidis. Cling: A memory allocator to mitigate dangling pointers.
In USENIX Security Symposium, 2010.
[5] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and M. Castro. Preventing
memory error exploits with WIT. In IEEE Symposium on Security and
Privacy, 2008.
[6] P. Akritidis, M. Costa, M. Castro, and S. Hand. Baggy bounds checking:
An efﬁcient and backwards-compatible defense against out-of-bounds
errors. In USENIX Security Symposium, 2009.
[7] M. Backes, T. Holz, B. Kollenda, P. Koppe, S. N¨urnberger, and J. Pewny.
You can run but you cant read: Preventing disclosure exploits in
executable code. In Proceedings of ACM Conference on Computer and
Communications Security (CCS), 2014.
[8] A. Bittau, A. Belay, A. Mashtizadeh, D. Mazieres, and D. Boneh.
Hacking blind. In IEEE Symposium on Security and Privacy, 2014.
[9] T. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang.
Jump-oriented
programming: A new class of code-reuse attack. In ACM Symposium on
Information, Computer and Communications Security (ASIACCS), 2011.
[10] E. Bosman and H. Bos. Framing signals—a return to portable shellcode.
In IEEE Symposium on Security and Privacy, 2014.
[11] N. Carlini and D. Wagner. ROP is still dangerous: Breaking modern
defenses. In USENIX Security Symposium, 2014.
[12] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham,
and M. Winandy. Return-oriented programming without returns.
In
Proceedings of ACM Conference on Computer and Communications
Security (CCS), 2010.
[13] X. Chen, A. Slowinska, D. Andriesse, H. Bos, and C. Giuffrida.
StackArmor: Comprehensive protection from stack-based memory error
vulnerabilities for binaries. In Symposium on Network and Distributed
System Security (NDSS), 2015.
[14] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng. ROPecker: A
generic and practical approach for defending against ROP attacks. In
Symposium on Network and Distributed System Security (NDSS), 2014.
[15] L. Davi, P. Koeberl, and A.-R. Sadeghi. Hardware-assisted ﬁne-grained
control-ﬂow integrity: Towards efﬁcient protection of embedded systems
against software exploitation. In DAC, 2014.
[16] L. Davi, D. Lehmann, A.-R. Sadeghi, and F. Monrose. Stitching the
gadgets: On the ineffectiveness of coarse-grained control-ﬂow integrity
protection. In USENIX Security Symposium, 2014.
[17] L. Davi, A.-R. Sadeghi, and M. Winandy. ROPdefender: A detection
tool to defend against return-oriented programming attacks.
In ACM
Symposium on Information, Computer and Communications Security
(ASIACCS), 2011.
[18] L. De Moura and N. Bjørner. Z3: An efﬁcient SMT solver. In Conference
on Tools and Algorithms for the Construction and Analysis of Systems
(TACAS), 2008.
[19] L. De Moura and N. Bjørner. Generalized, efﬁcient array decision
procedures. In Formal Methods in Computer Aided Design (FMCAD),
2009.
[20] D. Dewey and J. T. Gifﬁn. Static detection of C++ vtable escape
vulnerabilities in binary code. In Symposium on Network and Distributed
System Security (NDSS), 2012.
[21] A. Fokin, E. Derevenetc, A. Chernov, and K. Troshina. SmartDec:
In Working Conference on Reverse
Approaching C++ decompilation.
Engineering (WCRE), 2011.
[22] M. Frantzen and M. Shuey. StackGhost: Hardware facilitated stack
protection. In USENIX Security Symposium, 2001.
[23] I. Fratric. Runtime Prevention of Return-Oriented Programming Attacks.
http://ropguard.googlecode.com/svn-history/r2/trunk/doc/ropguard.pdf.
[24] R. Gawlik and T. Holz. Towards automated integrity protection of C++
virtual function tables in binary programs. In Anual Computer Security
Applications Conference (ACSAC), 2014.
[25] E. G¨oktas¸, E. Athanasopoulos, H. Bos, and G. Portokalidis. Out of
In IEEE Symposium on