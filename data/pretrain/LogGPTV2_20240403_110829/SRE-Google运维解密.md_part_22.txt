注2Blaze的开源版本为Bazel，可参见网站上的“BazelFaq”，http://bazel.io/faq.html。
Blaze注2是Google的构建工具，它支持多种编程语言，如Google 内部标准的 C++、
构建
以及我们是如何利用Rapid和其他相关工具管理这种周期的。
可扩展的、密闭的，以及可靠的发布流程。下面几小节描述了Google内部的软件生命周期，
Google开发了一个自动化的发布系统：Rapid。该系统利用一系列Google内部技术执行
持续构建与部署
快地进行在线调试。
结果一起归档。SRE可以了解每个新发布中包含的具体改动，在发布出现问题时可以更
的。我们的自动化发布系统可以提供每个发布中包含的所有改动的报告，与其他的构建
们主要关注的操作有如下几项：
多层安全和访问控制机制可以确保在发布过程中只有指定的人才能执行指定的操作。我
强调策略和流程
版本，这样可以保证编译器功能的一致性。
个项目进行cherrypicking，仍然会用当时的编译器版本，而不会用到这个月新的编译器
也是放置在与被构建的程序同一个源代码仓库之中的。因此，如果要对上个月构建的某
建新的发布来解决这个问题，这种方式被称为摘樱桃（cherry picking）。构建工具自身
一般来说是比较复杂的。Google按照之前的源代码版本，加人一些后来提交的改动来构
当修复某个运行在生产环境中的软件的Bug，而需要重新构建之前的一个发布版本时，
编译过程是自包含的，不依赖于编译环境之外的其他服务。
构建过程使用指定版本的构建工具(编译器）,同时使用指定版本的依赖库(第三方类库)。
几乎所有对源代码的修改都需要进行代码评审，这与我们日常开发工作流程是完美结合
·批准初始的集成请求（也就是一个以某个源代码仓库版本为基础的构建请求），
·实际部署某个发布版本。
·创建新的发布版本。
·指定发布流程中需要执行的具体动作。
·批准源代码改动——通过源代码仓库中的配置文件决定。
修改某个项目的构建配置文件。
以及后续的cherrypicking请求。
第8章
发布工程
---
## Page 121
MPM同时支持给某个版本的包打标签。Rapid也会加入一个构建ID标签，这样某个包
shakespeare/frontend），记录构建结果的哈希值，并且会加入签名以确保真实完整性。
软件通过Midas Package Manager（MPM）系统分发到生产机器上。MPM基于Blaze
为实现持续测试系统，我们使用一套独立的测试环境来在打包好的构建结果上运行一些
记录。这一个步骤非常重要，因为如果一个发布过程需要cherry picking，发布分支可能
在发布过程中，我们会使用该发布分支重新运行全部单元测试，同时为测试结果创建审核
这些方法可以降低在真正发布时由于主分支上其他无关改动造成问题的几率。
否发布某个版本。同时建议使用最后一个测试全部通过的软件版本来进行最新的发布。
构建错误和测试错误。建议使用项目中定义的构建目标及测试目标的执行结果来决定是
cherry picking 的方法，可以明确每个发布版本中包含的全部改动。
方式可以避免在第一次构建之后，再引入主分支上的其他的无关改动。利用这种分支与
会再合并入主分支。Bug 修复先提交到主分支，再cherry picking到发布分支上。这种
支上进行直接发布。我们会基于主分支的某一个版本创建新分支，新分支的内容永远不
所有的代码都默认提交到主分支上（mainline）。然而，大部分的项目都不会直接从主分
分支
这样我们就可以很容易地将一个二进制文件与构建过程对应起来。
进制文件都支持用一个命令显示自身的构建时间、构建源代码版本，以及构建标识符，
目特有的功能开关，例如一些特有的构建标识符等，会由Rapid传递给Blaze。所有二
构建目标（二进制文件，以及对应的测试等）定义在Rapid的项目配置文件中。某个项
标的全部依赖。
例如Jar文件，
Java、Python、Go以及JavaScript。工程师利用 Blaze定义构建目标，即构建的输出结果，
可以用名字和这个标签来唯一识别。
规则中列出的构建结果和权限信息构建MPM包。每个包有固定名称（如search/
打包
系统级别测试。这些测试可以从Rapid网站上手工启动。
会包含主分支上不存在的一个代码版本。我们必须确保在发布分支上全部测试确实通过
一个持续测试系统会在每个主分支改动提交之后运行单元测试，这样我们可以快速检测
测试
同时给每个目标指定依赖关系。当进行具体构建时，Blaze 会自动构建目
持续构建与部署
79
91
---
## Page 122
92
8
典型的发布流程按如下顺序进行：
理几千个发布请求。
Borg系统上的生产服务器。因为Rapid使用Google的生产基础设施，我们可以同时处
者并发执行，某个工作流也可以启动另外一个工作流。Rapid将工作请求分发给运行在
每个Rapid项目都有一些工作流，定义了发布流程中的具体动作。工作流可以线性或
图8-1：简化版Rapid架构，展示了系统的主要组件。
执行哪些动作。
以及一些管理用信息（例如项目负责人信息）。基于角色的访问控制列表可以决定谁能
件是一种利用Google内部配置语言写成的，用来定义构建目标和测试目标、部署规则，
图8-1展示了Rapid系统中的主要组件。Rapid是用Blueprint文件配置的。Blueprint文
Rapid系统
了，后续安装canary版本的包的人会自动使用最新的包版本。
的包上移除。例如，如果一个包标记为canary，之前的canary包上的标签就被自动去掉
canary或production等）。如果将某个现有标签应用到新包上，这个标签会自动从原来
我们可以给某个MPM包加标签，标记该MPM包在整个发布过程中的位置（如dev、
2.Rapid利用Blaze编译所有的二进制文件，同时执行所有的单元测试，这两个过
1.Rapid使用集成版本号（通常自动从持续测试系统获取）创建新的发布分支。
运行的环境中。这种隔离使得并发更容易一些。
程通常是并发进行的。编译和测试各自在独立的环境中进行，而非Rapid工作流
第8章
Rapid Client
发布工程
External Services
UserArtifacts
Legend
Rapid Service
Blueprint
Rapid Worker
Rapid Build Job
Tasks
Source Repository
Deployment
Build&Package
Test Services
ExternalServices
Services
Services
LArifacs
---
## Page 123
Sisyphus，可以支持简单的发布流程，也可以支持复杂的发布流程。例如，我们可以立
我们使用 Sisyphus，SRE开发的一个通用的发布自动化框架，来执行更为复杂的部署任
利用具体的任务执行器（executor）来用新构建的MPM包更新Borg任务。
Rapid经常被用来直接驱动简单的部署流程。它可以根据Blueprint文件定义的部署规则，
部署
批准和拒绝。
Rapid 可以管理发布分支与cheery picking。每个具体的 cherry picking 请求可以被单独
评审。
所有这些模型都需要将配置文件存放于我们的主要代码仓库中，同时进行严格的代码
置管理流程都随着时间不停地发展。今天我们使用下面几段描述的模型来分发配置文件。
简单，但是这其实是不稳定性的一个重要来源。因此，我们的发布流程和系统运维与配
配置管理是发布工程师与SRE紧密合作的一个区域。虽然初看起来，配置管理可能很
配置管理
的地理位置交替进行。
对敏感的基础设施服务来说，我们可能会将发布扩展到几天内完成，根据这些实例所在
户的服务来说，我们可能会先更新一个集群，再以指数速度更新其他集群直到全部完成。
我们可能会每小时构建一次，同时在所有测试通过之后自动发布更新。对于大型面向用
我们的目标是让部署流程与服务的风险承受能力相结合。在开发环境或者预生产环境中
即更新所有的相关任务，也可以在几个小时的周期内，
个build标签来指定究竞使用哪个MPM版本进行部署。
已构建的MPM包的build标签，可以在创建发布时指定这个标签。Sisyphus 可以利用这
在典型的集成流程中，Rapid在某个Sisyphus系统中创建一个新的发布。Rapid知道自
来详细控制每个发布的执行，以及监控发布流程。
了一系列可扩展的Python类，以支持任意部署流程。同时，它还有一个监控台，可以用
务。
。一个发布（rollout）是由一个或多个任务组成的一个逻辑工作单元。Sisyphus提供
3.构建结果随后可以用来运行系统级集成测试，同时进行测试部署。
列表的报告。
每一步的结果都有日志记录。另外产生一份与上次发布对比包含的所有新的改动
过程是在系统测试完成之后，在生产环境中启动一系列Borg任务。
一个接一个地更新集群版本。
配置管理
。典型的测试部署
81
93
---
## Page 124
95
小结
区域，但其实这些实践适用于更广阔的范围。
虽然本章讨论的是Google的发布工程的特有方法，以及发布工程师与 SRE共同合作的
该服务。
总之，项目负责人在分发和管理配置文件时有多种选择，可以按需决定究竟哪种最适合
代码仓库的文件系统中（参见文献[Kem11]）。
二进制文件运行时）。这些文件可以存放在Chubby、Bigtable或者Google自己的基于源
从外部存储服务中读取配置文件。某些项目的配置文件需要经常改变，或者动态改变（在
这些标签在每个MPM命名空间内部都是唯一的，只有最后一个包才能被用到。
以应用到上面那段中的MPM包上，这样我们可以用一个标签同时获取两个版本。因为
我们可以利用MPM的标签功能选择哪些MPM包应该同时安装。much_ado这个标签可
置包，再实际部署。这种方式可以避免再构建一次二进制文件。
些是没有实际意义的名字），可以将这个变更cherry picking到发布分支上，重新构建配
能需要一个功能开关first_folio，但是我们后面发现这个开关值应该为bad_quarto（这
MPM包，
例如，某个实现了新功能的变更可以与配置该功能的配置文件一起发布。通过打包两个
布配置文件。就像二进制文件那样，可以利用构建ID来重新构建某一时刻的配置文件。
制配置文件一般与某个二进制版本紧密相关，我们也可以利用编译系统和打包系统来发
将配置文件打包成MPM配置文件包。我们也可以将密闭原则应用到配置管理上。二进
个包。
MPM包里。虽然这个策略在灵活性上有一定限制，但是简化了部署，仅仅需要安装
或者那些每次发布都会改变文件的项目来说，配置文件可以直接和二进制文件放在一个
将配置文件与二进制文件打包在同一个MPM包中。对没有多少配置文件的项目来说
些变更。
会造成提交的版本和实际运行的配置文件不一致，因为任务必须要经过更新才能应用这
配置文件的修改是异步进行的。虽然理解起来和执行起来都比较容易，但这种方式经常
经过代码评审之后会应用到正在运行的系统上。这样做的结果是，二进制文件的发布与
些系统）。使用这个模型，开发者和SRE可以同时修改主分支上的配置文件。这些修改
使用主分支版本配置文件。
第8章发布工程
一个二进制文件，
。这是配置Borg服务的第一个方法（以及配置Borg之前的那
一个配置文件，可以对两个包进行单独修改。如果某个功
---
## Page 125