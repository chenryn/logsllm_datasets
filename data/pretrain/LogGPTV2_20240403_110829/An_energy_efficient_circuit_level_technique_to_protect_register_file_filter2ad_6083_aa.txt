title:An energy efficient circuit level technique to protect register file
from MBUs and SETs in embedded processors
author:Mahdi Fazeli and
Alireza Namazi and
Seyed Ghassem Miremadi
978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
195
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:56:57 UTC from IEEE Xplore.  Restrictions apply. 
 An Energy Efficient Circuit Level Technique to protect Register File from MBUs and SETs in Embedded Processors  M. Fazeli, A. Namazi, S.G. Miremadi Department of Computer Engineering, Sharif University of Technology, Tehran, Iran {m_fazeli, namazi}@ce.sharif.edu, PI:EMAIL    Abstract  This paper presents a circuit level soft error-tolerant-technique, called RRC (Robust Register Caching), for the register file of embedded processors. The basic idea behind the RRC is to effectively cache the most vulnerable registers in a small highly robust register cache built by circuit level SEU and SET protected memory cells. To decide which cache entry should be replaced, the average number of read operations during a register ACE time is used as a criterion to judge. In fact, the victim cache entry is one which has the maximum read count. To minimize the power overhead of the RRC, the clock gating technique is efficiently exploited for the main register file resulting in significantly low power consumption. The RRC is able to protect the register file not only against Single Bit Upsets (SBUs) but also against Multiple Bit Upsets (MBUs) and Single Event Transients (SETs). The RRC is experimentally evaluated using the LEON processor. The experimental results show that, if the cache size is selected properly, the Architectural Vulnerability Factor (AVF) of the register file becomes about 1% while it imposes low power, area and performance overheads to the processor.   1. Introduction High energy particle strikes have severely challenged the reliability of today’s embedded processors [19][20]. Until recently, Single Bit Upsets (SEUs) in memory elements were considered as the main effect of the particle strikes. However, as technology shrinks to nanometer era, Single Event Transients (SETs) in combinational parts and Multiple Bit Upsets (MBUs) are becoming serious reliability concerns [1][2][3].  The register file is a critical part of an embedded processor from reliability point of view [6][7]. This is because, the register file mostly holds useful data and is frequently accessed by the processor. This implies that, an error occurring in a register most likely propagates to other parts of the processor. Several error handling techniques such as parity or error correction codes (ECC) are used to protect the entire register file against SEUs in different processors [8][9]. However, protecting all of the register by ECC or other techniques such as the TMR are not viable solutions in embedded applications due to high power consumption overhead. In addition, the use of parity bits can just leads to error detection but not error correction. To correct errors, a recovery mechanism such as checkpointing and rollback recovery is needed to recover the correct state of the processor. Using such recovery mechanisms might violate real-time requirements of embedded applications if the recovery happens after the tasks deadlines.  [6][7] have shown that only some registers are vulnerable to SEUs simultaneously. Thus, protecting only the most vulnerable registers of the register file with SECDED code can significantly reduce the power and area overheads of such techniques. Such classes of techniques as provided in [6][7][26] that utilize the architectural vulnerability characteristics of the register file for the protection are regarded as architecture level techniques in this paper. However, even though such techniques are power efficient to protect the register file against SEUs, they cannot be employed to cope with MBUs and SETs as they use SECDED code as the main protection technique.  One effective way to combat MBUs and SETs in the register file is to use circuit level protected SEU/SET-tolerant memory cells in the design of the register file [11][12][13]. However, such techniques impose rather high power and area overheads when they are used to protect the entire register file.  In short, architecture level SEU-tolerant techniques have low power and area overheads but are not able to protect the register file against MBUs and SETs. On the other hand, circuit level techniques are effective in combating such errors, but they suffer from high power and area overheads. To bridge the gap, this paper proposes a technique, called Robust Register Caching (RRC), which efficiently combines the advantages of both circuit and architecture level techniques to mask MBUs and SETs in the register file with low power, performance and area overheads.  The RRC technique is based on four ideas: 1) employing a small register cache along the register file as an architecture level technique to store the most vulnerable registers; 2) building the register cache by circuit level protected SEU and SET memory elements. As each memory cell of the register cache is built by such memory elements, it is highly robust against MBUs and SETs; 3) using an efficient replacement policy to increase the cache residency time of a register during its ACE time. The number of read operations from registers is used in the replacement policy as a criterion for replacement, such that a victim entry is the one that has the most read count; and 4) using the RRC 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
196
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:56:57 UTC from IEEE Xplore.  Restrictions apply. 
 with a proper register cache size significantly reduces the number of write operations to the register file. Based on this fact, the clock gating is efficiently used to prevent power consumed due to unnecessary transitions in the input lines of the register file during the write operations.    The rest of the paper is organized as follows: Section 2 presents motivations of the paper. In Section 3, some preliminaries are introduced. Section 4 describes the proposed soft error-tolerant technique. The experimental evaluations and comparisons are reported in Section 5. Finally, Section 6 concludes the paper. 2. Motivations In following, we will discuss about MBUs and SETs and their importance in challenging the reliability of today’s digital systems, as well as the shortcomings of the existing techniques when confronting such events. 2.1. Multiple Bit Upsets (MBUs) As mentioned earlier, while technology shrinks toward deep sub-micron, the probability of MBUs increases. This is because the distance between two memory cells in a word line decreases [14]. It has been reported in [14] that the probability of MBUs exceeds 10% for technology sizes below 50nm. In addition some studies have shown that 1–5% of the SEUs can cause MBUs [1]. MBUs can be classified into three types: 1) an energetic particle passes through multiple memory cells; 2) multiple particles strikes multiple memory elements at different times; and 3) a particle strike produces secondary particles that have enough energy to cause bit flips.  Using error correction codes (ECCs) is a well- known technique to protect memory against SEUs. However, the imposed area and power overheads to enhance the code to detect and correct MBUs increases quickly as the code is strengthened [10]. Moreover, reading and calculating ECC bits in each read operation imposes performance and power consumption overheads. The scenario gets even worse for register files with multiple read ports. One effective technique for MBU detection and correction is the joint use of bit interleaving and simple SEC-DED code. Bit interleaving is a memory layout in which physically adjacent memory cells are assigned to different logical words. For example in a k-way interleaving, k consecutive errors in a row or a column appear as k single errors in k different words. Therefore, using SEC-DED code can efficiently detect and correct these k bits errors. However, this technique imposes power overhead due to unnecessary reads from undesired words in a row. In addition, the use of long word lines and multiplexers for columns imposes additional area and performance overheads to the system. These overheads get worse as the degree of interleaving increases [10]. In some cases, the bit interleaving technique may negatively impact floor planning [15]. Moreover, all ECC based techniques correct the errors after the erroneous data is read. It means that it may take a long time between the occurrence of an error and the correction time. This may increase the occurrence of type 2 errors. 2.2. Single Event Transients (SETs) Soft errors have long been the major concern for memory elements. But due to smaller feature sizes, lower voltage levels, higher operating frequencies, and reduced logic depth of today’s digital systems, the soft error rate due to particle strikes in combinational parts i.e. SETs is dramatically increasing [2][13]. A study shows that the soft error rate per chip of logic circuits will increase nine orders of magnitude from 1992 to 2011 [3]. When a high energy particle strikes a sensitive node in combinational logics, it causes a voltage glitch, the so called SET. An SET may results in a soft error if it reaches input lines of system latches or flip flops at the edge of the clock pulse. The conventional error correcting codes cannot be used for masking SETs. This is because, when the ECC of a word is being computed, the SETs occurring in the combinational logic may also be incorporated in the computation. Therefore, the code is computed for the erroneous data and no error will be detected when decoding.  In addition, hardware redundancy based techniques, such as conventional duplication or TMR cannot tolerate SETs, since SETs reaching the input lines of the memory cells will also propagate to the redundant copies of the cells. Using time redundancy based methods are effective to mask SETs. For example, sampling the outputs of the combinational parts at three different times and voting will efficiently mask SETs. Although such techniques are efficient, they suffer from a high performance overhead due to time redundancy and also high area and power overheads due to use of additional hardware components to support multiple samplings. 3. Preliminaries In this section, the preliminary concepts that help in better understanding the proposed technique and the employed reliability evaluation method. In addition, the circuit level techniques for protecting latches and flip flop (FFs) against SEUs and SETs will be discussed. 3.1. Architectural Vulnerability Factor (AVF)  The errors are classified as either Silent Data Corruption (SDC) or Detected Unrecoverable Errors (DUE). The SDCs are those errors that cannot be detected and the DUEs are the ones that can be only detected and there is no mechanism to recover from them. In order to estimate the reliability of the proposed register file architecture, the AVF (Architectural Vulnerability Factor), a widely used metric [6][7][17], is employed in our experiments. The AVF of a part is the probability that a fault occurring in the part results in an error. The AVF can be measured for both SDCs and DUEs separately, and are called SDC AVF and DUE AVF [6]. To measure the AVF of a register, we should first extract the fraction of time in which the register is vulnerable to faults, dubbed ACE time (Architecturally Correct Execution) [17]. If a fault occurs in each bit of a register when it is in its ACE time, it will produce an error. In contrast, the un-ACE time of a register is the fraction of time in which a faulty bit in the register will not result in an error. 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE