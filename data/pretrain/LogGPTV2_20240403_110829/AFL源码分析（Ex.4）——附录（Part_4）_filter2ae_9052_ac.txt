DeMott`在`Defcon`上做了一个关于覆盖率驱动的模糊器的演讲，该模糊器依赖于覆盖率作为适应度函数。
`Jared`的方法与`afl-fuzz`所做的并不完全相同，但它在同一个范围内。他的模糊器试图用单个输入文件明确解决最大覆盖率；相比之下，`afl`只是选择做一些新事情的案例(这会产生更好的结果——请参阅`Technical_details.txt`)。
几年后，`Gabriel
Campana`发布了`fuzzgrind`，这是一个完全依赖`Valgrind`的工具和一个约束求解器，可以在没有任何蛮力位的情况下最大化覆盖率；和微软研究人员广泛讨论了他们仍然非公开的、基于求解器的`SAGE`框架。
在过去六年左右的时间里，我还看到了相当多的学术论文涉及智能模糊测试(主要关注符号执行)和几篇讨论具有相同目标的遗传算法的概念验证应用的论文心里。我不相信大多数这些实验的实用性。我怀疑他们中的许多人都受到了`bunny-the-fuzzer`的诅咒，即在纸上和精心设计的实验中很酷，但未能通过最终测试，即能够在其他经过充分模糊的真实世界中找到新的、有价值的安全漏洞软件。
在某些方面，好的解决方案必须与之竞争的基线比看起来要令人印象深刻得多，这使得竞争对手很难脱颖而出。对于一个单一的例子，请查看`Gynvael`和`Mateusz
Jurczyk`的工作，将“愚蠢”模糊测试应用于`ffmpeg`，现代浏览器和媒体播放器的一个突出且安全关键的组件：
在同样复杂的软件中使用最先进的符号执行轻松获得可比较的结果似乎仍然不太可能，并且到目前为止还没有在实践中得到证明。
但我离题了；归根结底，归因是困难的，夸耀`AFL`背后的基本概念可能是在浪费时间。魔鬼往往存在于经常被忽视的细节中，让我们继续往下看……
###  2.2 设计目标
简而言之，我相信`afl-fuzz`的当前实现可以解决一些其他工具似乎无法解决的问题：
  1. 速度。当您的自动化测试方法是资源密集型时，真的很难与蛮力竞争。如果您的检测使发现错误的可能性增加`10`倍，但运行速度却降低`100`倍，那么您的测试过程就会受到不利影响。为了避免您在使用时遇到困难，`afl-fuzz`旨在让您以大致相同的原始速度模糊大多数预期目标——因此即使它没有增加价值，您也不会损失太多。最重要的是，该工具利用以多种方式检测减少实际工作量。例如，仔细修剪语料库或跳过输入文件中的非功能性但不可修剪的内容。
  2. 坚如磐石的可靠性。如果您的方法脆弱且意外失败，则很难与蛮力竞争。自动化测试很有吸引力，因为它易于使用且可扩展；任何违反这些原则的行为都是一种不受欢迎的权衡，这意味着您的工具将被较少使用并且结果不一致。大多数基于符号执行、污点跟踪或复杂的语法感知工具的方法目前对于实际的待测目标相当不可靠。也许更重要的是，它们的故障模式会使它们比“愚蠢”工具更糟糕，而且这种退化对于经验不足的用户来说很难注意到和纠正。相比之下，`afl-fuzz`被设计得坚如磐石，主要是通过保持简单的逻辑。事实上，从本质上讲，它被设计为一个非常好的传统模糊器，具有广泛的有趣且经过充分研究的策略。额外的部分只是帮助它把精力集中在最重要的地方。
  3. 简单。测试框架的作者可能是唯一真正了解该工具提供的所有设置的影响的人——并且可以恰到好处地调整这些设置。然而，即使是最基本的模糊测试框架也经常带有无数的设置项和需要操作员提前猜测的模糊测试比率。这弊大于利。AFL 旨在尽可能避免这种情况。您可以使用的三个设置项是输出文件、内存限制以及覆盖默认自动校准超时的能力。其余的应该工作。如果没有，用户友好的错误消息会概述可能的原因和解决方法，并让您立即回到正轨。
  4. 可结合性。大多数通用`fuzzer`不能轻易用于资源匮乏或交互繁重的工具，需要创建自定义的进程内`fuzzer`或大量`CPU`能力的消耗(其中大部分浪费在与任务没有直接关系的任务上)`AFL`试图通过允许用户使用更轻量级的目标(例如，独立的图像解析库)来创建有趣的测试用例的小型语料库，这些测试用例可以输入到手动测试过程或稍后的`UI`工具中，从而解决这个问题。
正如`technical_details.txt`中提到的，`AFL`不是通过系统地应用单一的总体`CS`概念来实现这一切的，而是通过试验各种小的、互补的方法，这些方法被证明能可靠地产生比偶然更好的结果。这些工具的使用是该工具包的一部分，但远不是最重要的。  
归根结底，重要的是`afl-fuzz`旨在发现很酷的错误——并且在这方面有着非常强大的记录。
## 3\. INSTALL(安装说明)
本文档提供基本安装说明并讨论各种平台的已知问题。有关一般说明手册，请参阅自述文件。
###  3.1 Linux on x86
`AFL`在该平台预计会运行良好。使用以下命令编译程序：
    $ make
您可以在不安装的情况下开始使用 fuzzer，但也可以通过以下方式安装它：
    # make install
此软件包没有特殊的依赖关系需要安装，您将需要`GNU
make`和一个工作编译器(`gcc`或`clang`)。一些与程序捆绑在一起的可选脚本可能依赖于`bash`、`gdb`和类似的基本工具。
如果您正在使用`clang`，请查看`llvm_mode/README.llvm`；与传统方法相比，`LLVM`集成模式可以提供显着的性能提升。
您可能需要更改多个设置以获得最佳结果(最值得注意的选项是是否禁用崩溃报告实用程序并切换到不同的`CPU`调控器)，但`afl-fuzz`会在必要时指导您完成相关设置。
###  3.2 OpenBSD, FreeBSD, NetBSD on x86
与`Linux`类似，`AFL`在这些平台预计运行良好并将在这些平台进行定期测试。您可以用`GNU make`编译：
    $ gmake
请注意，`BSD
make`将不工作。如果您的系统上没有`gmake`，请先安装它。与在`Linux`上一样，您可以在不安装的情况下使用`fuzzer`本身，或者通过以下方式安装：
    # gmake install
请记住，如果您使用`csh`作为`shell`，自述文件和其他文档中给出的某些`shell`命令的语法会有所不同。
`llvm_mode`需要动态链接的、完全可操作的`clang`安装。至少在`FreeBSD`上，`clang`二进制文件是静态的并且不包含一些必要的工具，所以如果你想让它工作，你可能需要按照`llvm_mode/README.llvm`中的说明进行操作。
除此之外，一切都应该像文档所述的那样工作。
`QEMU`模式目前仅在`Linux`上受支持。但我认为这只是一个`QEMU`问题，因为我根本无法获得在`BSD`上正常工作的用户模式仿真支持的普通程序。
###  3.3 MacOS X on x86
`MacOS X`上`AFL`应该可以正常工作，但由于平台的特性，验证这一点存在一些问题。最重要的是，我的测试能力有限，框架的运行情况主要依赖于用户反馈。
要构建`AFL`，请安装`Xcode`并按照适用于`Linux`的一般说明进行操作。
`Xcode 'gcc'`工具只是`clang`的一个包装器，所以一定要使用`afl-clang`来编译任何检测过的二进制文件`afl-gcc`将失败，除非您从其他来源安装了`GCC`(在这种情况下，请指定`AFL_CC`和`AFL_CXX`以指向“真正的”`GCC`二进制文件)。
该平台只能进行`64`位编译；由于`OS X`处理重定位的方式，移植`32`位工具需要相当多的工作，而今天，几乎所有的`MacOS X`机器都是
`64`位的。
`MacOS X`默认附带的崩溃报告守护程序会导致模糊测试问题。您需要按照此处提供的说明将其关闭：
与其他`unix`系统相比，`OS X`上的`fork()`语义有点不寻常，而且绝对不符合`POSIX`标准。这意味着两件事：
  * `Fuzzing`可能比在`Linux`上慢。事实上，有些人报告说，通过在`MacOS X`上的`Linux VM`中运行作业，可显着提高性能。
  * 一些不可移植的、特定于平台的代码可能与`AFL forkserver`不兼容。如果遇到任何问题，请在启动`afl-fuzz`之前在环境中设置 `AFL_NO_FORKSRV=1`。
`MacOS X`似乎不支持`QEMU`的用户仿真模式，因此黑盒检测模式(`-Q`)将不起作用。
`llvm_mode`需要完整运行的`clang`安装。`Xcode`附带的那个缺少一些基本的头文件和辅助工具。有关如何从头构建编译器的建议，请参见`llvm_mode/README.llvm`。
###  3.4 Linux or *BSD on non-x86 systems
`AFL`的标准构建将在非`x86`系统上失败，但您应该能够利用其中的两个模式：
  * `LLVM`模式(参见`llvm_mode/README.llvm`)，它不依赖于`x86`特定的程序集做基础。它快速而强大，但需要完整安装`clang`。
  * `QEMU`模式(参见`qemu_mode/README.qemu`)，也可用于对跨平台二进制文件进行模糊测试。它更慢且更不稳定，但即使您没有测试应用程序的源代码，也可以使用它。
如果您不确定自己需要什么，则需要`LLVM`模式。要获得它，请尝试：
    $ AFL_NO_X86=1 gmake && gmake -C llvm_mode
…并使用`afl-clang-fast`或`afl-clang-fast++`编译您的目标程序，而不是传统的`afl-gcc`或`afl-clang`包装器。
###  3.5 Solaris on x86
据用户报告，`fuzzer`可以在`Solaris`上运行，但我没有亲自测试过，而且用户群相当小，所以我没有很多反馈报告以供参考。
为了让构建顺利进行，您需要使用`GNU
make`和`GCC`或`clang`。有人告诉我，平台附带的`GCC`的特定版本无法正常工作，因为它依赖于`as`的硬编码位置(其将完全忽略`-B`参数或`$PATH`)。
要解决此问题，您可能需要从源代码构建标准`GCC`，如下所示：
    $ ./configure --prefix=$HOME/gcc --with-gnu-as --with-gnu-ld \
      --with-gmp-include=/usr/include/gmp --with-mpfr-include=/usr/include/mpfr
    $ make
    $ sudo make install
注意不要指定`--with-as=/usr/gnu/bin/as`——这将产生一个忽略`-B`标志的`GCC`二进制文件，你将回到默认情况。
请注意，据报道`Solaris`启用了崩溃报告，这会导致崩溃被误解为挂起的问题，类似于`Linux`和`MacOS
X`的陷阱。`AFL`不会在此特定平台上自动检测崩溃报告，但您可能需要运行以下命令：
    $ coreadm -d global -d global-setid -d process -d proc-setid -d kzone -d log
`QEMU`的用户模拟模式在`Solaris`上不可用，因此黑盒检测模式(`-Q`)将不起作用。
###  3.6 其他的系统版本
在这些系统版本上构建就要靠你自己了。在符合`POSIX`的系统上，您可以编译和运行`AFL`；`LLVM`模式可能提供一种检测非`x86`代码的方法。
`AFL`不会在`Windows`上运行。它也不会在`Cygwin`下工作。它可以很容易地移植到后一个平台，但这是一个非常糟糕的主意，因为
`Cygwin`非常慢。使用`VirtualBox`左右运行硬件加速的`Linux
VM`更有意义；它的运行速度会快`20`倍左右。如果您有一个真正引人注目的`Cygwin`用例，请告诉我。
尽管`x86`上的`Android`理论上应该可以工作，但库存内核可能已编译出`SHM`支持，如果是这样，您可能必须首先解决该问题。您可能只需要以下解决方法：
`Joshua J.
Drake`指出，`Android`链接器添加了一个`shim`，可以自动拦截`SIGSEGV`和相关信号。为了解决这个问题并能够看到崩溃，你需要把它放在模糊程序的开头：
    signal(SIGILL, SIG_DFL);
    signal(SIGABRT, SIG_DFL);
    signal(SIGBUS, SIG_DFL);
    signal(SIGFPE, SIG_DFL);
    signal(SIGSEGV, SIG_DFL);
您可能需要先`#include `。