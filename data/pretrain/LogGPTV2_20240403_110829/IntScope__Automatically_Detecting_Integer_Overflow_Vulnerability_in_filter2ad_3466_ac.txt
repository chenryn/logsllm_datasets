102
103 return w;
104 }
abort ();
Figure 6. Function addvsi3 in libgcc2.c of
gcc-4.2.0
Note that IntScope does not immediately generate an
alarm when it ﬁnds the tainted expression in a predicate
could overﬂow, and instead it considers whether the predi-
cate is designed to catch integer overﬂow errors. We have
summarized several common patterns that make use of the
erroneous result to catch integer overﬂow errors, such as
if((x+1)0&&(x+y)nMaxCount) in
hdsa, DSA_SetItem calls ReAlloc to allocate a new
buffer. Although index is checked multiple times, a
large index (such as 0x7ffffffe) can trigger a multi-
plication overﬂow in nNewItems∗hdsa->nItemSize,
where hdsa->nItemSize is the size of an item, resulting
in a smaller-than-expected returned pointer size.
to a new item data which will
To better understand how our system works, we present
part of the disassembled code of DSA_SetItem in Figure
8(a), corresponding to the snippet of pseudo code in Figure 7.
The assembly code in Figure 8(a) is converted into PANDA,
shown in Figure 8(b).
For function DSA_SetItem, IntScope considers the sec-
ond parameter (arg2) as tainted because it comes from user
input, and all unknown variables will be assigned symbolic
values.
Result. At each if statement, IntScope will fork an ad-
ditional execution along the feasible branch. Let’s focus on
int DSA_SetItem(HDSA hdsa, int index, void *pItem) {
HLOCAL hMem;
int nNewItems;
L1 if (index =hdsa->nItemCount) {
if(index + 1>hdsa->nMaxCount)
L3
{ nNewItems=((index + hdsa->cItemGrow)/
return 0;
hMem = ReAlloc(hdsa->hMemArrayData,
hdsa->cItemGrow)* hdsa->cItemGrow;
nNewItems * hdsa->nItemSize);
//ignore some statements here
}
hdsa->nItemCount = index + 1;
memmove((void*)((index*hdsa->nItemSize)+
(DWORD)hdsa->hMemArrayData),pItem, hdsa->nItemSize);
Figure 7. Pseudo code for DSA SetItem.
L4
L5
}
the “process” which reaches line 58 along the path (B1, B2,
B3, B4) in Figure 8(b). Line 58 calls function realloc to
allocate (arg2 0+var 2 0)∗var 3 0 bytes of memory.
Because arg2_0 is the tainted symbolic value of arg2, the
whole expression is considered tainted. The Integer Over-
ﬂow Checker will check whether the whole expression could
overﬂow under current path constraints: arg2 0>=0 &&
arg2 0>=var arg1 0 && (1+arg2 0)>var 1 0. In
this case, a large arg2_0 (e.g., 0x7fffffffe) can pass
program constraints and trigger an integer overﬂow. As a
result, IntScope outputs this path as a detected one.
Besides the path we described above, IntScope reports
the other two paths, corresponding to the paths (L1, L2,
L5) and (L1, L2, L4, L5) in Figure 7, which terminate at
function memove because of the potential multiplication
overﬂow in index * hdsa->nItemSize. We do not
have any prior knowledge about the DSA structure, and we
assume all ﬁelds in hdsa have all possible values (e.g.,
hdsa can contain items of any size).
If either index or
hdsa->nItemSize is large enough, their product will
overﬂow. However, we are missing some preconditions be-
tween the number of items (nItemCount) and the size of
an item (nItemSize) in a normal DSA structure. Actually,
neither hdsa->nItemCount * hdsa->nItemSize
nor
hdsa->nItemSize
could overﬂow. Therefore,
the product of index and
hdsa->nItemSize cannot overﬂow under the constraint
indexnItemCount.
hdsa->nMaxCount *
GDI AttemptWrite Integer Overﬂow Vulnerability
(CVE-2007-3034). The integer overﬂow vulnerability in
function AttemptWrite of gdi32.dll is a classic
case. AttemptWrite tries to copy some data to a buffer
(named Buffer), whose capacity is Buffer_Capacity.
AttemptWrite performs memory management similar to
the code below:
if(NumberOfBytesWritten + NumberOfBytesToWrite
= 0 ) goto (26)
B2:
......
29. arg1_0 := arg1
30. var_1 :: dword [8+arg1_0]
31. var_2 :: dword [16+arg1_0]
32. var_3 :: dword [12+arg1_0]
34. var_arg1_0 :: dword [arg1_0]
35. esi = arg1_0
36. var_arg1_0_0 := var_arg1_0
39. if(arg2_0 u var_3_0)
Figure 9. (a) Vulnerable code in Function AttemptWrite. (b) PANDA IR for (a).
4.1.2 Zero-day Vulnerabilities
QEMU and Xen – We have detected 7 zero-day integer
overﬂow vulnerabilities in QEMU. Six of them have been
conﬁrmed by our dynamic testing tool [46]; the remaining
one is highly suspicious, but we cannot generate a test case
to show its real existence yet. French Security Incident Re-
sponse Team (FrSIRT) [19] has published a security advisory
for these vulnerabilities (FrSIRT/ADV-2008-2919).
QEMU supports various disk image formats, such as raw,
qcow, qcow2, vmdk, vpc and cloop. However, the block
drivers for some image formats are vulnerable as detected by
our system. Crafted disk images can trigger integer over-
ﬂows and cause out-of-bound accesses when QEMU tries
to open these images. We show the vulnerability in func-
tion qcow_open (in qemu-0.9.1/block-qcow2.c) to illus-
trate this.
194
if (bdrv_pread(s->hd, 0, &header, sizeof(header))
195
241
246
247
249
250