Momigari
最新的Windows操作系统内核在野漏洞概述
Boris Larin
@oct0xor
30-May-19
Anton Ivanov
@antonivanovm
讲师介绍
高级恶意软件分析师（启发式检测和漏洞研究团队）
Boris Larin
高级威胁研究和检测团队负责人
Anton Ivanov
Twitter: @oct0xor 
Twitter: @antonivanovm
3
内容梗概
Momigari: 日本人在秋天寻找最美
丽的树叶的传统
中国东北 吉林省 蛟河市. [新华社图片]
http://en.safea.gov.cn/2017-10/26/content_33734832_2.htm
4
内容梗概
5
内容梗概
1）我们将简要介绍我们找到零日漏洞的方法以及所面临的挑战
2）我们将介绍我们发现的三个在野特权提升（EOP）零日攻击
•
Windows系统内核漏洞利用变得更加困难
•
ITW样本分析帮助我们获得事情的现状和新技术的见解
•
我们将详细介绍Windows 10 RS4的两个漏洞利用
3）我们将揭示这些漏洞采用的开发框架
卡巴斯基实验室检测技术
6
我们通常会在报告中添加此详细信息：
这是我们去年发现的所有漏洞背后的两项技术
技术＃1  - 漏洞利用预防
7
交付
内存
操纵
运行
Shellcode
执行
预防漏洞利用
检测和阻止
Payload执行
开始
技术＃2  - 沙箱
用于分析的装配工
件
用于测试的 文件/ URL
- 执行日志
- 内存转储
- 系统/注册表更改
- 网络连接
- 截图
- 利用工件
关于判定活动性质的详细数据
测试虚拟机
文件/ URL将被发送到多个测试虚拟机
工件记录
检测漏洞
发现
开发
研究
如何:
卡巴斯基实验室捕获的在野漏洞利用
• 2018年5月 - CVE-2018-8174（Windows VBScript引擎远程执行代码漏洞）
• 2018年10月 - CVE-2018-8453（Win32k特权提升漏洞）
• 2018年11月 - CVE-2018-8589（Win32k特权提升漏洞）
• 2018年12月 - CVE-2018-8611（Windows内核特权提升漏洞）
• 2019年3月 - CVE-2019-0797（Win32k特权提升漏洞）
• 2019年4月 - CVE-2019-0859（Win32k特权提升漏洞）
近一年来: 
是什么让我们夜不能寐
一家公司在一年内发现了六个漏洞
其中一个漏洞是通过Microsoft Office中的远程代码执行
还有五个漏洞涉及到特权提升
虽然这个数字很大，但它只是冰山一角
单个漏洞获取计划的奖金示例
https://zerodium.com/program.html:
为什么我们没有看到很多针对浏览器的漏洞，其他软件的漏洞，
以及网络零点击远程代码执行的漏洞被捕获？
即使漏洞攻击已经被检测到了，大部分的案例分析所需要的数据远比实际检测中所能收集到的数据要多
零日发现的复杂度
我们的技术旨在漏洞的检测和预防开发
但要确定检测到的漏洞是否为零日漏洞，则需要进行额外的分析
一些漏洞很容易被发现
沙箱进程开始有异常的行为
一些漏洞很难被发现
由其他软件引起的虚假警报
示例：安装在同一台计算机上的两个或多个安全软件
需要改进的领域（浏览器）
需要进一步的分析漏洞利用脚本
扫描整个内存以查找所有脚本同样是不切实际的
可能的解决方法：
浏览器为安全应用程序提供接口以请求加载的脚本（类似于反恶意软件扫描接口（AMSI））
问题：
如果在同一进程中实现，漏洞利用程序可以对此进行修复
检测特权提升漏洞
特权提升漏洞通常用于攻击的后期阶段
当前操作系统提供的事件记录足以用于构建检测
由于它们通常以本机代码实现 - 因此可以轻松分析它们
特权提升漏洞可能是最适合用于分析的
15
案例 1
CVE-2018-8453
攻击模块以加密的形式分发
我们发现的样本仅针对x64平台
•
但分析表明对x86的攻击也是可以是实现的
编写的代码是为了支持下一个OS版本 :
•
Windows 10 build 17134
•
Windows 10 build 16299
•
Windows 10 build 15063
•
Windows 10 build 14393
•
Windows 10 build 10586
•
Windows 10 build 10240
•
Windows 8.1
•
Windows 8
•
Windows 7
16
Win32k
我们今天要讨论的四个漏洞中有三个存在于Win32k中
Win32k是一个处理图形，用户输入，UI元素的内核模式驱动程序
它自Windows诞生之时就存在了
起初它是在用户模式上实现的，但后来它的主要部分被转移到了内核
•
为了提升性能
这是一个非常大的攻击面
•
超过1000个系统调用
•
用户态回调
•
共享数据
超过一半的Windows内核安全漏洞是在win32k.sys中找到的
https://github.com/Microsoft/MSRC-Security-Research/blob/master/presentations/2018_10_DerbyCon/2018_10_DerbyCon_State_of%20_Win32k_Security.pptx
17
安全性的提升
在过去几年中，Microsoft进行了许多改进，这些改进使针对内核的攻击变得更为困难并提高了整体安全性
防止对于创建读写原语的特定内核结构的滥用
•
对tagWND的额外检查
•
GDI Bitmap对象的强化（SURFACE对象的类型隔离）
•
...
内核ASLR的改进
•
修复了通过共享数据公开内核指针的多种方法
CVE-2018-8453是第一个针对Windows 10 RS4 Win32k的漏洞
从我们发现的漏洞中可以看出这项工作的结果。 越新的操作系统=更少的漏洞利用。
18
CVE-2018-8453
从代码中可以看出这个漏洞最初似乎不并支持对Windows 10 build 17134的攻击，
是在后期添加的
也有一种可能是这个攻击在此版本发行之前就已经存在，但我们没有任何证据
可以证明这一猜测
19
CVE-2018-8453
win32k!tagWND (Windows 7 x86)
Microsoft从调试符号中删除了win32k!tagWND，
但在Windows 10 （17134） 中FNID还是处在相
同的位置
FNID（功能ID）定义了一类窗口
（它可以是ScrollBar，菜单，桌面等）
高位字节定义了窗口释放
FNID_FREED = 0x8000
漏洞位于syscall NtUserSetWindowFNID
20
CVE-2018-8453
在NtUserSetWindowFNID中，系统调用tagWND-> 
fnid，如果它等于0x8000（FNID_FREED），则不会
被检查
可以更改正在释放的窗口的FNID
21
CVE-2018-8453
Microsoft通过调用IsWindowBeingDestroyed()
函数修补了漏洞
22
CVE-2018-8453
在报告这个漏洞时，MSRC不确定这个攻击在最新版本的Windows 10中是否可以实现，因此要求我们提供了
完整的漏洞利用证据
以下幻灯片显示了对Windows 10 build 17134漏洞利用的的逆向分析
出于显而易见的原因，我们不会分享完整的漏洞利用
23
CVE-2018-8453
漏洞利用主要来自在用户态回调上设置的钩子
钩子回调：
设置钩子：
•
从PEB获取KernelCallbackTable的地址
•
用我们自己的处理程序替换回调指针
fnDWORD
fnNCDESTROY
fnINLPCREATESTRUCT
Patch Table
24
CVE-2018-8453
漏洞利用会创建窗口并使用ShowWindow()
回调将被触发
* 稍后将需要使用影子进行攻击
fnINLPCREATESTRUCT
SetWindowPos()将强制ShowWindow()调用AddShadow()并创建影子
25
CVE-2018-8453
漏洞利用会创建滚动条并执行Heap Groom
单击滚动条上的鼠标左键会启动滚动条轨道
•
它执行消息WM_LBUTTONDOWN发送到滚动条窗口
•
导致在内核中执行win32k！xxxSBTrackInit()
准备内存布局
将消息发送到滚动条窗口以进行启动
26
CVE-2018-8453
在漏洞利用中有五种（！）不同的Heap Groom策略
零日攻击与常规公共攻击的区别是什么？
通常，为实现最佳可靠性需要投入大量精力
27
CVE-2018-8453
fengshui_17134: Blind heap groom
fengshui_16299:
•
注册0x400类（lpszMenuName = 0x4141€|）
•
创建窗口
•
使用Tarjei Mandt描述的技术泄漏地址
NtCurrentTeb()->Win32ClientInfo.ulClientDelta
fengshui_15063与fengshui_16299相似
fengshui_14393:
•
创建0x200位图
•
创建加速器表
•
使用gSharedInfo泄漏地址
•
销毁加速器表
•
创建0x200位图
fengshui_simple: CreateBitmap & GdiSharedHandleTable
Windows 10 Mitigation Improvements
28
CVE-2018-8453
xxxSBTrackInit() 最终会执行 xxxSendMessage(, 0x114,…)
0x114 是 WM_HSCROLL 消息
将消息转换为回调
WM_HSCROLL              fnDWORD 回调
如何执行回调?
29
CVE-2018-8453
在漏洞利用程序中，在fnDWORD用户态回调挂钩中有状态机
•
状态机是必需的，因为fnDWORD 用户态回调经常被使用
•
我们在fnDWORD钩子中的漏洞利用有两个阶段
阶段1  - 在WM_HSCROLL消息中销毁fnDWORD用户模式回调内的窗口
第一个释放的就是影子（这就是影子需要初始化的原因）
它将导致执行fnNCDESTROY回调
30
CVE-2018-8453
在fnNCDESTROY用户态回调期间，查找释放的影子和并触发漏洞
影子窗口的FNID不再是FNID_FREED！
Call stack:
31
CVE-2018-8453
由于更改了FNID消息，WM_CANCELMODE将导致释放USERTAG_SCROLLTRACK！
第2阶段（在fnDWORD钩子内）
这最终将导致双重释放
Call stack:
32
CVE-2018-8453
使用WM_CANCELMODE释放USERTAG_SCROLLTRACK可以重新利用刚刚释放的内存
释放被分配到Fengshui()中的Bitmats，并分配更多
33
CVE-2018-8453
xxxSBTrackInit()将通过释放USERTAG_SCROLLTRACK完成执行，但最后的
结果是释放GDITAG_POOL_BITMAP_BITS
释放 USERTAG_SCROLLTRACK
释放 GDITAG_POOL_BITMAP_BITS
双重释放:
34
CVE-2018-8453
新的缓解措施：GDI对象隔离（在Windows 10 RS4中实施）
Francisco Falcon 的相关文章可以从下面地址访问:
https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html
新的缓解措施断绝了常见的使用Bitmaps的漏洞利用：
•
用于漏洞利用的的SURFACE对象现在不会被分配给像素数据缓冲区
使用Bitmap对象的内核漏洞利用已经完全被断绝
但是你也可以看到它不会完全灭绝
35
CVE-2018-8453
漏洞利用程序创建了64个线程
然后在使用win32k功能后每个线程都被转换为GUI线程
没有关于THREADINFO的记录，但结部分构可通过win32k!_w32thread获得
GetBitmapBits / SetBitmapBits用于覆盖THREADINFO数据
这将使得THREADINFO被分配到一个代替bitmap的位置
36
CVE-2018-8453
对THREADINFO的控制将允许SetMessageExtraInfo小工具的使用
Peek and poke *(u64*)((*(u64*) THREADINFO+0x1A8)+0x198)
0x1A8 - Message queue
0x198 - Extra Info
37
CVE-2018-8453
用任意地址替换消息队列指针
读取quadword，但使用零值覆盖
恢复消息队列指针
用任意地址替换消息队列指针
在地址处设置quadword
恢复消息队列指针
恢复原始值
38
CVE-2018-8453
THREADINFO还包含指向进程对象的指针
漏洞利用使用它来窃取系统令牌
39
案例 2
CVE-2018-8589
win32k中的竞争条件
发现的在野漏洞只针对Windows 7 SP1 32位
至少需要两个处理器内核
可能是今天提出的最无趣的漏洞，但它带来了更大的发现
40
CVE-2018-8589
CVE-2018-8589是win32k中一个复杂的竞争条件，这是由于线程之间同步发送的消息锁定不当引起的
找到了使用MoveWindow()和WM_NCCALCSIZE消息的漏洞利用样本
41
CVE-2018-8589
两个线程都具有相同的窗口过程
第二个线程启动递归
线程 1
线程 2
42
CVE-2018-8589
窗口程序
WM_NCCALCSIZE窗口消息回调中的递归
移动相反线程的窗口以增加递归
相反线程
本线程
在线程终止期间触发最大递归级别的竞争条件
43
CVE-2018-8589