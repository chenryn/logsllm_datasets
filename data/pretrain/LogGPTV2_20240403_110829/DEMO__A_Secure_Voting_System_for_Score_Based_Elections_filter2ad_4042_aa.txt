title:DEMO: A Secure Voting System for Score Based Elections
author:Lihi Dery and
Tamir Tassa and
Avishay Yanai and
Arthur Zamarin
DEMO: A Secure Voting System for Score Based Elections
Lihi Dery
PI:EMAIL
Ariel Cyber Innovation Center
Ariel University
Israel
Tamir Tassa
PI:EMAIL
The Open University
Israel
Avishay Yanai
PI:EMAIL
VMware Research
Israel
ABSTRACT
Dery et al. recently proposed [3] a secure voting protocol for score-
based elections, where independent talliers perform the tallying
procedure. The protocol offers perfect ballot secrecy: it outputs
the identity of the winner(s), but keeps all other information se-
cret, even from the talliers. This high level of privacy, which may
encourage voters to vote truthfully, and the protocol’s extremely
lightweight nature, make it a most adequate and powerful tool for
democracies of any size. We have implemented that system and in
this work we describe the system’s components – election adminis-
trators, voters and talliers – and its operation. Our implementation
is in Python and is open source. We view this demo as an essen-
tial step towards convincing decision makers in communities that
practice score-based elections to adopt it as their election platform.
CCS CONCEPTS
• Security and privacy → Social aspects of security and pri-
vacy; Privacy protections; • Applied computing → Voting /
election technologies.
KEYWORDS
Electronic Voting, Secure Multiparty Computation, Perfect Ballot
Secrecy, Voting Protocols, Computational Social Choice
ACM Reference Format:
Lihi Dery, Tamir Tassa, Avishay Yanai, and Arthur Zamarin. 2021. DEMO:
A Secure Voting System for Score Based Elections. In Proceedings of the 2021
ACM SIGSAC Conference on Computer and Communications Security (CCS
’21), November 15–19, 2021, Virtual Event, Republic of Korea. ACM, New York,
NY, USA, 3 pages. https://doi.org/10.1145/3460120.3485343
1 INTRODUCTION
Ballot secrecy is an essential goal in the design of voting systems,
since when voters are concerned for their privacy, they might de-
cide to vote differently from their real preferences, or even abstain
from voting altogether. Dery et al. [3] presented a secure protocol
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
CSS’21, November 15–19, 2021, Seoul, South Korea
© 2021 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-8454-4/21/11.
https://doi.org/10.1145/3460120.3485343
Arthur Zamarin
PI:EMAIL
The Open University
Israel
with perfect ballot secrecy to compute election results for score-
based voting rules. Perfect ballot secrecy [1] means that, given any
coalition of voters, the protocol does not reveal any information on
the ballots, beyond what can be inferred from the published results.
In score-based elections over M candidates, C = {C1, . . . , CM},
each voter, Vn ∈ V = {V1, . . . , VN }, submits a ballot vector, wn :=
(wn(1), . . . , wn(M)), that holds the scores that she gives to each
of the M candidates. The winner is the candidate that receives the
highest aggregated score from all voters (or the K highest, if the
elections need to determine K ≥ 1 candidates).
Each rule in this family defines the allowed ballot vectors. E.g., in
the Plurality rule, each ballot vector must contain a single 1-entry,
while the remaining M − 1 entries are 0; the 1-entry is placed in the
position corresponding to the voter’s favorite candidate. Other rules
in this family are: Approval (the ballot vector includes 1-entries for
candidates that the voter approves, and 0-entries otherwise); Veto
(the ballot vector includes a 1-entry for the voter’s least preferred
candidate, and 0-entries for all others); Range (the ballot vector
contains scores for the candidates, where the scores are in a preset
range [0, L]); and Borda (the ballot vector wn is a permutation of
{0, 1, . . . , M − 1} which describes Vn’s ranking of the candidates).
The protocol involves a set of talliers, T = {T1, . . . ,TD}, to whom
the voters send shares in their ballot vectors. The talliers validate the
legality of the cast ballots, aggregate them, and eventually compute
the final voting results, where all those computations are carried
out by invoking secure multiparty sub-protocols, so that the talliers
never obtain access to the actual ballots or other computational
results such as the final scores of candidates. The protocol is secure
under the assumption that the talliers have an honest majority.
Employing more talliers (higher values of D) will imply higher
costs, but at the same time it will provide enhanced security against
coalitions of corrupted talliers. Such perfect ballot privacy, by which
the ballots and aggregated scores are not disclosed even to the
talliers, may increase the voters’ confidence and, consequently,
encourage them to vote according to their true preferences.
2 THE PROTOCOL
Protocol 1 is a high level description of the protocol presented in
[3]. All computations are carried out in some finite field Zp. The
heart of the protocol is in Steps 4 and 6. In Step 4 the talliers run
an MPC (Multi-Party Computation) sub-protocol for validating the
legality of the ballot wn, in which they received shares in Step 3 (the
vectors wn,d, d ∈ [D] := {1, . . . , D}), without actually constructing
Session 8: Poster & Demo Session CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2399CSS’21, November 15–19, 2021, Seoul, South Korea
Dery, Tassa, Yanai and Zamarin
it. The process of validating a ballot consists of computing products
and sums of shared values. For example, for Plurality, each of
the ballot entries must be either 0 or 1, which can be validated by
computing the product wn(m) · (wn(m) − 1), for all m ∈ [M] :=
{1, . . . , M}. Those validations, for each of the five rules, are carried
out by invoking the MPC sub-protocol of Damgård and Nielsen [2]
for computing products of shared values.
 wn, where the sum goes over all legal ballots), in which they only
In Step 6, the talliers sort the vector of aggregated scores (w =
hold shares ( ˆwd), in order to find the K largest entries in it. This is
done by computing an arithmetic circuit, presented in [5], which
performs an MPC comparison of two secret values u, v ∈ Zp. Let
u and v be two entries in the aggregated vector of scores w. Each
tallier Td, d ∈ [D], holds shares ud and vd in u and v, respectively,
in a Shamir’s D′-out-of-D secret sharing scheme [6], where D′ :=
⌊(D +1)/2⌋. The circuit outputs the bit that indicates whether u < v.
That way, the talliers can find the winning candidates without
learning any other information on the ballots or on the aggregated
vector of scores.
Protocol 1 A protocol for secure score-based voting
Input: Ballot vectors, wn, n ∈ [N] := {1, . . . , N}.
Output: The K candidates with highest aggregated scores.
1: Each voter Vn, n ∈ [N], constructs a ballot vector wn according
to the voting rule.
2: Each voter Vn, n ∈ [N], generates a random polynomial дn,m
of degree D′ − 1, where D′ = ⌊(D + 1)/2⌋ and дn,m(0) =
wn(m), ∀m ∈ [M]. Then, she creates the share vector wn,d =
(дn,1(d), . . . , дn,M(d)), for each d ∈ [D].
3: Vn, ∀n ∈ [N], sends wn,d to Td, ∀d ∈ [D].
4: The talliers T jointly validate the legality of each of the cast
ballots wn, without revealing them.
all n ∈ [N] for which wn is legal.
w (the sum of all legal ballot vectors) and output them.
5: Td, ∀d ∈ [D], computes ˆwd = wn,d, where the sum is over
6: The talliers T jointly find the K indices with largest entries in
3 IMPLEMENTATION
We implemented a demo of a voting system that is based on Protocol
1. The demo illustrates the three modules of the system: election
administrator, voters and talliers, and it allows users to experi-
ence a simple interface for the administrator and voters, and to
witness the efficiency of the protocol. The system is implemented
in Python. We chose this programming language for best cross-
platform support. The demo’s code is fully open source: https:
//github.com/arthurzam/SecureVoting.
3.1 The election administrator
The first module of the system, the election administrator, initiates
a new election campaign. The administrator determines:
• The election title (e.g., "Electing a new faculty dean").
• The set of candidates C = {C1, . . . , CM} and their indexing.
• The set of eligible voters, V = {V1, . . . , VN }, together with
their email addresses and unique identifiers.
• The voting rule.
• The number K of candidates out of C that need to be elected.
• The number D of talliers, and their TCP/IP ports/addresses.
• The election termination condition (e.g., a specified time).
After establishing a new election campaign, the election adminis-
trator will receive a config.json file that will hold all configuration
details of the election. The administrator will send that file to all
talliers, and a shortened version of that file (without the details of
all voters) to each of the voters.
3.2 The voter module
The voter module can be executed on various devices (laptops,
tablets, smartphones), and is intended to be operated by non-expert
voters. Hence, the main design goal here was to keep the module
simple, so that it will be easy to migrate it between platforms, and
to keep the interface simple and clear.
The graphical interface presents the voter with the list of can-
didates, and instructs her on how to enter her ballot. For example,
in Plurality, the voter is asked to select exactly one candidate. In
Range, the voter needs to insert a score, out of a given range, for
each of the candidates. In Borda, the voter is instructed to rearrange
the order of the candidates from her most to least favorite.
Once the voter has finished entering her ballot, the voter’s mod-
ule will use the config.json file in order to create the proper ballot
vector (Step 1 in Protocol 1), create shares in them (Step 2), and
send those shares, signed and encrypted using SSL, to the talliers’
addresses as listed in the configuration file config.json (Step 3).
In order to support various types of voting devices, we developed
a specialized version of the voter module, implemented on fully
client-side web code. It receives the election information through
the URL parameters, presents them to the user, manages the vote
casting and the connection to the talliers. This module is imple-
mented using HTML and JavaScript, and can thus be run on any
browser in any device.
3.3 The tallier module
The tallier module is the most complex one: it establishes the syn-
chronized network with other peer talliers, collects the ballot shares
from all voters (Step 3 in Protocol 1), validates their legality, to-
gether with the other tallier modules (Step 4), aggregates shares
of all legal ballots (Step 5), and consequently takes part in an MPC
sub-protocol (with the other tallier modules) in order to determine
the winner(s) (Step 6).
As this module handles heavy network transport and a signifi-