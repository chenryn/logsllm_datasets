guess list generated by the original PCFG algorithm,
even if they are popular (e.g, “1q2w3e4r” appears in the
top-200 list of every dataset). The essential reason is
that
the PCFG algorithm simply assumes that each
segment in a structure is independent. Yet, in many
situations this is not true. For instance, the four D1
segments and L1 segments in the structure (D1L1)4 of
password “1q2w3e4r” are evidently interrelated with
each other (i.e., D4: 1234 and L4: qwer).
Our solution. To address this problem, we specially
tackle a few password structures that are long but simple
alternations of short segments by treating them as short
structures. For instance, (D1L1)4 is converted to D4L4,
and (D1L2)3 to D3L6.
In this way, the probability of
“1q2w3e4r” now is computed as P(“1q2w3e4r”)=
P((D1L1)4) · P((D1L1)4 → D4L4)·P(D4 →1234)·
P(L4 → qwer). Our approach is language-agnostic and
constitutes a general amendment to the state-of-the -art
PCFG-based algorithm in [36].
To further exploit the characteristics of Chinese pass-
words, we insert the “Pinyin name any” dictionary and
the six-digit date dictionary (see Sec. 3.3) into the o-
riginal PCFG L-segment and D-segment dictionaries,
respectively. Details about this insertion process and
our improved algorithm for password-guess generation
are shown in Algorithm 1. The resulting changes to the
original PCFG grammars are given in Table 6.
Fig. 4(c) illustrates that, when the guess number al-
lowed is small (e.g., 103), our improved attack exhibits
little improvement; As the guess number grows,
the
Algorithm 1: Our improved PCFG-based attack
Input: A training set S; A name list nameList; A date list
dateList; A parameter k indicating the desired size of
the PW guess list that will be generated (e.g., k = 107)
Output: A PW guess list L with the top-k items
segmentSet.insert(segment)
for password ∈ S do
1 Training (lastly tackle monotonically long PWs:)
2
3
4
5
6
7
8
for segment ∈ splitToSegments(password) do
baseStructure ← getBaseStructure(password)
if monotonicallyLong(baseStructure) then
trans f ormStructureSet.insert(baseStructure)
baseStructure ←
convertToshort(baseStructure)
baseStructureSet.insert(baseStructure)
trainingSet.insert(password)
9
10
11 Append name and date lists to the learned segment list:
12
13
for name ∈ nameList do
correctedCount =
totalOverlapNameInSegmentSet ∗
nameList.getCount(name)/totalOverlapNameInNameList
if name /∈ segmentSet and correctedCount ≥ 1 then
segmentSet.insert(name,correctedCount)
14
15
for date ∈ dateList do
if date /∈ segementSet then
16
17