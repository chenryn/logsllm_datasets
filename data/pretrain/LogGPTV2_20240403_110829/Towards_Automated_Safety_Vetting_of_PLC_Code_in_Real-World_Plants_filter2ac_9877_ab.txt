1Leading PLC supplier in North America w/ 60% of the market share [17]
2The most popular industrial robots worldwide [1]
Fig. 1: SMART Testbed for Manufacturing Model Vehicles
was developed by engineers from Rockwell Automation, fac-
ulty and graduate students: the hardware components and the
way they connect precisely resemble those on real-world fac-
tory Ô¨Çoors; a large body of controller code (e.g., robot motion,
CNC operation, RFID I/O, etc.) was directly borrowed from
industry practices [7]. The Ô¨Ådelity of this control system has
been veriÔ¨Åed through consistent collaboration with Rockwell
Automation.
Physical Compositions. The gantry system serves as the
entry and exit points of the testbed. It delivers empty pallets
to CNC machine #1 to start the manufacturing processes and,
eventually, it removes the produced parts from the conveyor.
The circular conveyor belt is always on and keeps moving
the pallets around the robots and CNCs. The robots and CNC
machines are organized into two cells to accomplish different
tasks (e.g., molding, Ô¨Çipping, etc.), where Cell 1 is comprised
of Robot #1 and CNC #1, and Cell 2 contains the rest.
Immediately in front of each cell are RFID transceivers that
can sense the presence of incoming pallets, empty or loaded,
because RFID tags are attached to both pallets and parts. The
RFID tag on a part maintains a numerical value indicating its
next manufacturing process. A pallet stopper is also installed
to every cell to block moving pallets. By default, the stopper
is always enabled to block any arriving pallets unless a signal
that indicates otherwise is received.
PLC and Robot Logics. Figure 2 and Figure 8 (in Ap-
pendix A) show in part the control logic of the PLC and
Robot #1 in Cell 1, respectively. The code snippets depict
how a processed part is passed from CNC to conveyor.
Since a raw part has been delivered by the gantry to the
CNC for processing, the PLC code (Figure 2) is now expecting
to receive the processed part and deliver it to the next cell
using an empty pallet. The coordination between PLC and
robot is realized through events. In order to receive and send
these signals, 6 input variables (Ln.3-7,52), 2 output variables
(Ln.8-9) and 4 internal variables (Ln.11-13,49) are declared.
In each scan cycle, the PLC Ô¨Årst clears the output variables
during initialization (Ln.16-19) and then checks all the input
variables sequentially to update the outputs (Ln.21-44).
More concretely, Ln.21-23 Ô¨Årst update the availability of
an empty pallet at Cell 1 (Pallet Arrival) by checking the
presence of a pallet (Pallet Sensor) and also the absence of
a part (NOT(Part Sensor)). If, however, an incoming pallet
is already loaded with a part (Ln.25-27), the PLC will send
a signal via Retract Stopper to retract the stopper and let
this pallet pass through. When an empty pallet has arrived at
(cid:22)(cid:19)(cid:21)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:42:08 UTC from IEEE Xplore.  Restrictions apply. 
Pallet_Sensor AT %IX0.1 : BOOL;
Part_Sensor AT %IX0.2 : BOOL;
CNC_Part_Ready AT %IX0.3 : BOOL;
Robot_Ready AT %IX0.4 : BOOL; //DO[6]
Part_AtConveyor AT %IX0.5 : BOOL; //DO[2]
Retract_Stopper AT %QX0.1: BOOL;
Deliver_Part AT %QX0.2 : BOOL; //DI[0]
Pallet_Arrival AT %MX0.1 : BOOL;
Update_Part_Process AT %MX0.2 : BOOL;
Update_Complete AT %MX0.3 : BOOL;
Pallet_Arrival := false;
Retract_Stopper := false;
Deliver_Part := false;
Update_Part_Process := false;
IF Pallet_Sensor AND NOT(Part_Sensor) THEN
Pallet_Arrival := true;
IF Pallet_Arrival AND CNC_Part_Ready AND Robot_Ready AND
IF Part_Sensor THEN
Retract_Stopper := true;
NOT(Part_AtConveyor) THEN
Deliver_Part := true;
Update_Part_Process := true;
CNC_Part_Ready := false;
Robot_Ready := false;
VAR
END_VAR
1 PROGRAM CELL1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45 END_PROGRAM
46
47 PROGRAM UPDATE_PART
48
49
50
51
52
53
54
55
56
57
58
59
60 END_PROGRAM
END_VAR
VAR
VAR_INPUT
END_IF
IF Update_Part_Process THEN
//Call subroutine to update process No.
UPDATE_PART(2);
IF Update_Complete AND Part_AtConveyor THEN
Retract_Stopper := true;
Update_Complete := false;
Part_Process AT %MD50 : DWORD;
RFID_IO_Complete AT %IX0.6 : BOOL;
Update_Complete AT %MX0.3 : BOOL;
END_VAR
//Perform 15-step I/O operations on RFID
...
IF RFID_IO_Complete THEN
Update_Complete := true;
Fig. 2: PLC ST Code for Picking Up Processed Parts
Cell 1, the PLC code (Ln.29-34) will further check the Boolean
inputs, CNC Part Ready, Robot Ready and NOT(Part -
AtConveyor), to conÔ¨Årm the existence of a processed part,
availability of robot and clearance of parts on the conveyor,
respectively. If all the conditions are satisÔ¨Åed, the PLC will
then perform two actions: 1) requesting the robot to pass the
processed part to pallet and 2) updating the manufacturing
process number on the part. Two signals Deliver Part and
Update Part Process are thus enabled.
1)Deliver Part. Based upon conÔ¨Åguration, the variable
Deliver Part is mapped to a digital input (DI[0]) on the
robot side. Being true, this signal triggers the robot program
in Figure 8 to execute. The robot code then operates the
robot arm, via a series of motion instructions such as linear
movement ‚Äò‚ÄòL‚Äô‚Äô or joint movement ‚Äò‚ÄòJ‚Äô‚Äô, in order to pick
up a part from the CNC machine (Figure 8 Ln.6-12) and pass
it to the conveyor (Figure 8 Ln.18-20). When the part has been
delivered to the conveyor, the robot turns on its output signal
DO[2] for 0.5 seconds to indicate the completion (Figure 8
Ln.22-24). This output is then mapped to Part AtConveyor
on the PLC. In the end, the robot returns to a safe zone.
2)Update Part Process. When this variable is true, a
subroutine UPDATE PART(int) is called to conduct a 15-
step I/O operation on the RFID attached to the part (Ln.36-
39). When this is done, the subroutine (Ln.47-60) will receive
a RFID IO Complete signal and then notify its caller by
setting the Boolean variable Update Complete.
To check whether the two actions are completed, PLC
constantly reads two response signals Part AtConveyor and
Update Complete. When both signals are true, PLC will
retract the stopper to transfer this loaded pallet (Ln.41-44).
Safety Violation and Root Cause. This code, in fact,
can lead to item overÔ¨Çow [9], which is a typical type of
safety issues on the factory Ô¨Çoor. Fundamentally, it is caused
by mismatched expectations between the sender (robot) and
receiver (PLC) of event Part AtConveyor‚Äôs duration.
The signal Part AtConveyor has dual purposes. When
it is true, it indicates the robot has delivered a part to the
pallet, which can now leave the cell. When it is off, that
means the conveyor has been cleared to accept a new part,
and the robot can then move away from conveyor for another
delivery. However, in practice, the robot does not need to
stop at conveyor waiting for the pallet to leave. Although the
robot cannot pass the second part to the conveyor prior to the
departure of Ô¨Årst one, the robot can, in fact, move towards the
CNC in advance to save time for the next delivery. For the
sake of saving time, the developers implemented a timeout in
the robot code and only allowed the event Part AtConveyor
(DO[2]) to last for 0.5 seconds (Figure 8 Ln.23-24), no matter
if the conveyor is cleared by then. As a result, the robot is
guaranteed to start handling another delivery 0.5 seconds after
the previous one.
Unfortunately, if the robot turns off Part AtConveyor
prematurely, the PLC may never see both Part AtConveyor
and Update Complete being set to true at the same time,
either due to an unexpectedly fast part delivery or slow RFID
update. This is also because PLC developers typically do not
buffer old signal values (in this case, Part AtConveyor
being ‚ÄúTRUE‚Äù) but rather always read data directly from their
origins, in order to avoid synchronization problem.
In fact, a real-world error has been reported from the
SMART testbed when the speed of robot
is increased to
a certain extent, and thus Part AtConveyor ends even
before the update of process number is complete. Then,
there exists no window when both Update Complete and
Part AtConveyor are true (Figure 3b). In that case, even if
the pallet has already been loaded, it can never leave the cell.
This error can cause a serious safety issue since the con-
veyor will overÔ¨Çow due to the constantly arriving pallets.
(cid:22)(cid:19)(cid:22)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:42:08 UTC from IEEE Xplore.  Restrictions apply. 


	










	










	
















	

 
 

(a) Sequence 1
 			
(b) Sequence 2

 	


 
	

(c) Sequence 3
Fig. 3: Event Sequences with Different Orders and Timings
Eventually, it will cause pallets to collide and fall, or even
cause the overloaded conveyor to break. Though seemingly
straightforward, this is in fact a typical safety violation that
can cause severe injuries on the factory Ô¨Çoor and thus has
attracted attention in both industrial practices [5], [6], [9] and
academic research [37].
It is worth noting that although we highlight this issue
using collaborative PLC and a robot, it is actually a common
problem that can be caused by coordination of any types of
controllers, such as multiple PLCs, PLCs and CNCs (con-
trolled by an integrated slave PLC) or CNCs and robots. Both
our experience and domain knowledge from Ô¨Åeld engineers
(from Rockwell) show that a large portion of PLC safety
problems originated from the coordination required between
multiple units because they are manufactured by different
vendors and programmed individually without considering
different contexts (e.g., timing). Nevertheless, we believe the
problem involving PLCs and robots is the most challenging
one to address because it requires the understanding of multi-
ple programming languages and their interactions. Hence, we