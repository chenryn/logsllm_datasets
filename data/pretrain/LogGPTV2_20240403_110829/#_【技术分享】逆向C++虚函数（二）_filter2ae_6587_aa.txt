# 【技术分享】逆向C++虚函数（二）
|
##### 译文声明
本文是翻译文章，文章来源：安全客
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
翻译：[维一零](http://bobao.360.cn/member/contribute?uid=32687245)
预估稿费：200RMB（不服你也来投稿啊！）
投稿方式：发送邮件至[linwei#360.cn](mailto:PI:EMAIL)，或登陆[网页版](http://bobao.360.cn/contribute/index)在线投稿
传送门：[【技术分享】逆向C++虚函数（一）](http://bobao.360.cn/learning/detail/3332.html)
**前言**
在[ **上一部分中，**](https://alschwalm.com/blog/static/2016/12/17/reversing-c-virtual-functions/) 我描述了一种在小型C
++程序中“反虚拟化”函数调用的方法。当然，这种方法有一些限制，即它非常的手工。如果目标二进制包含成千上万个虚表，手动去定位虚表并创建这些结构及关系是不实际的。
因此，在本部分中，我将详细介绍虚表的布局，以及如何用可编程的方式找到它们。我也将展示某些时候我们可以如何恢复这些虚表之间的关系（以及它们之间的关联类型）。
但首先我需要描述这套适用的二进制文件集。在第一部分中我提到，与虚表布局相关的大多数事情没有在标准规范中指定，因此往往会因编译器而异。这是因为C
++标准需要适配而无论底层架构如何。如果规范指定了一些特定的虚表布局，那在某些架构上可能是低效的，这就不好了。该架构的编译器开发人员将需要在性能与合规性之间进行选择（那就超越了原本规范）。
然而，因为由不同编译器生成的程序经常需要交互（最值得注意的是，对于动态链接来说），编译器开发人员要协商对虚表布局，异常实现等的一些补充规范。其中最常见的是[
**英特尔 C ++ ABI**](https://mentorembedded.github.io/cxx-abi/abi.html)
。此标准由GCC，clang，ICC和许多其他编译器（但值得注意的是，非Visual Studio）实现。我下面的描述将适用于这些编译器。
英特尔
ABI在某些方面仍然模糊不清的。例如，它没有声明应该使用哪些段来存储虚表。所以我将进一步说明，我描述的GCC是基于英特尔的特定品牌。因此，本质上，我描述的是以下突出显示的部分：
此外，做出以下假设：
1、RTTI被禁用（如果它打开，将会更容易些）；
2、该程序不会出现虚拟继承；
不幸的是，讨论这将大大增加这个话题的复杂性，并且因为虚拟继承有点不常见，所以我认为这里值得去探讨；
3、这些都是32位二进制文件。
**更多关于虚表布局**
在我们继续之前，回想一下，在第1部分中，我们将虚表描述为二进制数据段中连续的函数指针集合。我们还可以说该数组应该只由它的第一个元素来进行引用，因为其他元素将作为这个数组的偏移量被访问。
    .rodata:08048D48 off_8048D48     dd offset sub_8048B6E
    .rodata:08048D4C                 dd offset sub_8048BC2
    .rodata:08048D50                 dd offset sub_8048BE0
这是一个来自二进制的部分，看起来似乎符合上面的定义。它是在'.rodata'段中3个函数指针的数组，并且只有0x08048D48引用了该指针。原来，它是一个虚表，这个启发好吗？如果我们要编译以下代码：
    #include 
    #include 
    struct Mammal {
      Mammal() {   std::cout fly();
      m->walk();
    }
[view
raw](https://gist.github.com/ALSchwalm/5a8cd4928eb8e3c1d2993a7acc0099d1/raw/a3be3e673dda73e70269bcdf2107541fb2a14fe1/reversing-part-2-1.cpp)[reversing-part-2-1.cpp](https://gist.github.com/ALSchwalm/5a8cd4928eb8e3c1d2993a7acc0099d1#file-reversing-part-2-1-cpp) hosted with ❤ by [GitHub](https://github.com/)
我们希望那里将有5张虚函数表，分别为Mammal，Cat，Dog，Bird，和Bat。但你可能已经猜到，事情不是那么简单。实际上，在满足上述标准的二进制中有6个区域。当你考虑具有多重继承的对象布局时就会清楚为什么如此。
注意，Bat包含一个Bird和Mammal的完整实例（称为子对象）并且每个子对象都有一个vptr。这些指针指向不同的虚函数表。因此，具有多个父类型的对象类型在二进制中对应每个父类型都有一张虚表。英特尔
ABI将这些称为“虚表组”。
**  
**
**虚表组**
虚表组由第一个父类型的主表和任意数量的次表组成，次表对应在第一个父表后面的每个父类型。这些表在二进制中按照在源代码中声明父类型的顺序相邻。考虑到这一点，我们期望Bat的虚表组是这样的：
每个虚表需要12个字节。回顾第1部分内容，每个虚表将有两个析构函数，并且因为Bat没有重写walk，我们期望从
Mammal继承的walk出现在Bat表中。然而，如果我们检查二进制文件，并没有在.rodata段看到任何地方有连续的6个函数指针。
如果我们更仔细地看看英特尔的规范，可以找到原因。虚表不仅包括函数指针。实际上一个虚表看起来更像这样：
**  
**
**英特尔虚表布局（无虚拟继承）**
该RTTI pointer通常指向一个RTTI结构体（在英特尔规范中也有描述）。但是，由于我们假设了RTTI被禁用，所以它将总是0。而offset to
top的值等于必须添加的this指针的大小，通过这个指针可以获取从某个子对象到自身对象的起始位置。这点可能有些混乱，所以为了更清楚，观察下面的代码：
    Bat* bat = new Bat();
    Bird* b = bat;
    Mammal* m = bat;
[**view
raw**](https://gist.github.com/ALSchwalm/4d31be0344b8d1ff61ebbea1a94b0f3b/raw/47911166844814871c2758e8b727a7cd1b63388a/reversing-part-2-2.cpp)[ **reversing-part-2-2.cpp**](https://gist.github.com/ALSchwalm/4d31be0344b8d1ff61ebbea1a94b0f3b#file-reversing-part-2-2-cpp) **hosted with ❤ by**[ **GitHub**](https://github.com/)
这些分配的b和m都是有效的。第一个不需要任何指令。一个
Bat就是一个Bird，因为Bird是它的第一个父类型，在任何Bat对象的开始都是Bird子对象。因此，指向Bat的指针也是指向Bird的指针。这就像正常，单一继承。
但是，分配m确实需要额外一些工作。在Bat里面的子对象Mammal不是开头对象，所以编译器必须插入一些指令到bat，使其指向其Mammal子对象。添加的值将是Bird的大小（对齐）。此值的负值将存储在offset
to top字段中。
虚表的这个offset to top组件允许我们轻松地识别虚表组。一个虚表组将由在offset to top中具有缩减值的那些连续的虚表组成。考虑下图：
从上面的源代码构建的二进制文件中找到了6张虚表。注意到，第2张表有个-4的值（0xFFFFFFFC作为有符号整数）属于它的字段offset to