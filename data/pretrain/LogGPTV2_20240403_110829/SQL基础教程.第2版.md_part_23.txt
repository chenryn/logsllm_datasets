允许存在这样的书写方法可能并不奇怪，但是SQL的规则禁止这样的书
写方法。
KEYWORD 该书写方法究竟违反了什么规则呢？那就是关联名称的作用域。虽
●关联名称
然这一术语看起来有些晦涩难懂，但是一解释大家就明白了。关联名称
●作用域
就是像P1、P2这样作为表别名的名称，作用域（scope）就是生存范围
5-3 关联子查询 173 ●
（有效范围）。也就是说，关联名称存在一个有效范围的限制。
具体来讲，子查询内部设定的关联名称，只能在该子查询内部使用（图
5-9）。换句话说，就是“内部可以看到外部，而外部看不到内部”。
请大家一定不要忘记关联名称具有一定的有效范围。如前所述，SQL
是按照先内层子查询后外层查询的顺序来执行的。这样，子查询执行结束
注A 时只会留下执行结果，作为抽出源的P2表其实已经不存在了A。因此，
当然，消失的其实只是P2这个名
在执行外层查询时，由于P2表已经不存在了，因此就会返回“不存在使
称而已，Product表以及其中
的数据还是存在的。 用该名称的表”这样的错误。
图5-9 子查询内的关联名称的有效范围
P1
SELECT product_type, product_name, sale_price
FROM Product AS P1 P2
WHERE sale_price>(SELECT AVG(sale_price)
FROM Product AS P2
WHERE P1.product_type=P2.product_type
GROUP BY product_type);
（仅在子查询
中有效）
练习题
5.1 创建出满足下述三个条件的视图（视图名称为ViewPractice5_1）。使
用Product（商品）表作为参照表，假设表中包含初始状态的8行数据。
条件1： 销售单价大于等于1000日元。
条件2： 登记日期是2009年9月20日。
条件3： 包含商品名称、销售单价和登记日期三列。
对该视图执行SELECT语句的结果如下所示。
SELECT * FROM ViewPractice5_1;
执行结果
product_name | sale_price | regist_date
--------------+------------+-------------
T恤衫 | 1000 | 2009-09-20
菜刀 | 3000 | 2009-09-20
● 174 第5章 复杂查询
5.2 向习题5.1中创建的视图ViewPractice5_1中插入如下数据，会得到
什么样的结果呢？
INSERT INTO ViewPractice5_1 VALUES ('刀子', 300, '2009-11-02');
5.3 请根据如下结果编写SELECT语句，其中sale_price_all列为全部
商品的平均销售单价。
执行结果
product_id | product_name | product_type | sale_price | sale_price_all
------------+-------------+--------------+------------+----------------------
0001 | T恤衫 | 衣服 | 1000 | 2097.5000000000000000
0002 | 打孔器 | 办公用品 | 500 | 2097.5000000000000000
0003 | 运动T恤 | 衣服 | 4000 | 2097.5000000000000000
0004 | 菜刀 | 厨房用具 | 3000 | 2097.5000000000000000
0005 | 高压锅 | 厨房用具 | 6800 | 2097.5000000000000000
0006 | 叉子 | 厨房用具 | 500 | 2097.5000000000000000
0007 | 擦菜板 | 厨房用具 | 880 | 2097.5000000000000000
0008 | 圆珠笔 | 办公用品 | 100 | 2097.5000000000000000
5.4 请根据习题5.1中的条件编写一条SQL语句，创建一幅包含如下数据的视
图（名称为AvgPriceByType）。
执行结果
product_id | product_name | product_type | sale_price | avg_sale_price
------------+-------------+--------------+------------+----------------------
0001 | T恤衫 | 衣服 | 1000 | 2500.0000000000000000
0002 | 打孔器 | 办公用品 | 500 | 300.0000000000000000
0003 | 运动T恤 | 衣服 | 4000 | 2500.0000000000000000
0004 | 菜刀 | 厨房用具 | 3000 | 2795.0000000000000000
0005 | 高压锅 | 厨房用具 | 6800 | 2795.0000000000000000
0006 | 叉子 | 厨房用具 | 500 | 2795.0000000000000000
0007 | 擦菜板 | 厨房用具 | 880 | 2795.0000000000000000
0008 | 圆珠笔 | 办公用品 | 100 | 300.0000000000000000
提示：其中的关键是avg_sale_price列。与习题5.3不同，这里需要计算出的
是各商品种类的平均销售单价。这与5-3节中使用关联子查询所得到的结果相同。
也就是说，该列可以使用关联子查询进行创建。问题就是应该在什么地方使用这个
关联子查询。
5-3 关联子查询 175 ●
CASE
第6章 函数、谓词、 表达式
各种各样的函数
谓词
CASE表达式
本章重点
不仅SQL，对所有的编程语言来说，函数都起着至关重要的作用。函数就
像是编程语言的“道具箱”，每种编程语言都准备了非常多的函数。使用函数，
我们可以实现计算、字符串操作、日期计算等各种各样的运算。
本章将会和大家一起学习具有代表性的函数以及特殊版本的函数（谓词和
CASE表达式）的使用方法。
6-1 各种各样的函数
■函数的种类
■算术函数
■字符串函数
■日期函数
■转换函数
6-2 谓词
■什么是谓词
■LIKE谓词——字符串的部分一致查询
■BETWEEN谓词——范围查询
■IS NULL、IS NOT NULL——判断是否为NULL
■IN谓词——OR的简便用法
■使用子查询作为IN谓词的参数
■EXIST谓词
6-3 CASE表达式
■什么是CASE表达式
■CASE表达式的语法
■CASE表达式的使用方法
6-1 各种各样的函数 177 ●
第6章 函数、谓词、CASE表达式
6-1
各种各样的函数
● 根据用途，函数可以大致分为算术函数、字符串函数、日期函数、转换函
学习重点
数和聚合函数。
● 函数的种类很多，无需全都记住，只需要记住具有代表性的函数就可以了，
其他的可以在使用时再进行查询。
函数的种类
前几章和大家一起学习了SQL的语法结构等必须要遵守的规则。本
KEYWORD 章将会进行一点改变，来学习一些SQL自带的便利工具——函数。
●函数
我们在3-1节中已经学习了函数的概念，这里再回顾一下。所谓函数，
●参数（parameter）
●返回值 就是输入某一值得到相应输出结果的功能，输入值称为参数（parameter），
输出值称为返回值。
函数大致可以分为以下几种。
KEYWORD ● 算术函数（用来进行数值计算的函数）
●算术函数
● 字符串函数（用来进行字符串操作的函数）
●字符串函数
●日期函数 ● 日期函数（用来进行日期操作的函数）
●转换函数
● 转换函数（用来转换数据类型和值的函数）
●聚合函数
● 聚合函数（用来进行数据聚合的函数）
我们已经在第3章中学习了聚合函数的相关内容，大家应该对函数有初
步的了解了吧。聚合函数基本上只包含COUNT、SUM、AVG、MAX、MIN
这5种，而其他种类的函数总数则超过200种。可能大家会觉得怎么会有那
么多函数啊，但其实并不需要担心，虽然数量众多，但常用函数只有30 ~ 50个。
不熟悉的函数大家可以查阅参考文档（词典）来了解A。
注A
参考文档是DBMS手册的一部分。 本节我们将学习一些具有代表性的函数。大家并不需要一次全部记住，
大家也可以从介绍各种函数的书
籍以及Web网站上获取相关信息。 只需要知道有这样的函数就可以了，实际应用时可以查阅参考文档。
● 178 第6章 函数、谓词、CASE表达式
接下来，让我们来详细地看一看这些函数。
算术函数
KEYWORD 算术函数是最基本的函数，其实之前我们已经学习过了，可能有些读
●算术函数
者已经想起来了。没错，就是2-2节介绍的加减乘除四则运算。
KEYWORD ● +（加法）
●+运算符
● -（减法）
●-运算符
●*运算符 ● *（ 乘法）
●/运算符
● /（ 除法）
由于这些算术运算符具有“根据输入值返回相应输出结果”的功能，
因此它们是出色的算术函数。在此我们将会给大家介绍除此之外的具有代
表性的函数。
为了学习算术函数，我们首先根据代码清单6-1创建一张示例用表
（SampleMath）。
NUMERIC是大多数DBMS都支持的一种数据类型，通过NUMBERIC
(全体位数,小数位数)的形式来指定数值的大小。接下来，将会给大家
介绍常用的算术函数——ROUND函数，由于PostgreSQL中的ROUND
函数只能使用NUMERIC类型的数据，因此我们在示例中也使用了该数
据类型。
代码清单6-1 创建SampleMath表
-- DDL：创建表
CREATE TABLE SampleMath
(m NUMERIC (10,3),
n INTEGER,
p INTEGER);
SQL Server PostgreSQL
-- DML：插入数据
BEGIN TRANSACTION; ①
INSERT INTO SampleMath(m, n, p) VALUES (500, 0, NULL);
INSERT INTO SampleMath(m, n, p) VALUES (-180, 0, NULL);
INSERT INTO SampleMath(m, n, p) VALUES (NULL, NULL, NULL);
INSERT INTO SampleMath(m, n, p) VALUES (NULL, 7, 3);
6-1 各种各样的函数 179 ●
INSERT INTO SampleMath(m, n, p) VALUES (NULL, 5, 2);
INSERT INTO SampleMath(m, n, p) VALUES (NULL, 4, NULL);
INSERT INTO SampleMath(m, n, p) VALUES (8, NULL, 3);
INSERT INTO SampleMath(m, n, p) VALUES (2.27, 1, NULL);
INSERT INTO SampleMath(m, n, p) VALUES (5.555,2, NULL);
INSERT INTO SampleMath(m, n, p) VALUES (NULL, 1, NULL);
INSERT INTO SampleMath(m, n, p) VALUES (8.76, NULL, NULL);
COMMIT;
特定的SQL
不同的DBMS事务处理的语法也不尽相同。代码清单6-1中的DML语句在
MySQL中执行时，需要将①部分更改为“START TRANSACTION;”，在Oracle和DB2
中执行时，无需用到①的部分（请删除）。
详细内容请大家参考4-4节中的“创建事务”。
下面让我们来确认一下创建好的表中的内容，其中应该包含了m、n、
p三列。
SELECT * FROM SampleMath;
执行结果
m | n | p
---------+---+--
500.000 | 0 |
-180.000 | 0 |
| |
| 7 | 3
| 5 | 2
| 4 |
8.000 | | 3
2.270 | 1 |
5.555 | 2 |
| 1 |
8.760 | |
■ABS——绝对值
语法6-1 ABS函数
ABS(数值)
KEYWORD
●ABS函数
ABS是计算绝对值的函数。绝对值（absolute value）不考虑数值的
●绝对值
符号，表示一个数到原点的距离。简单来讲，绝对值的计算方法就是：0
和正数的绝对值就是其本身，负数的绝对值就是去掉符号后的结果。
● 180 第6章 函数、谓词、CASE表达式
代码清单6-2 计算数值的绝对值
SELECT m,
ABS(m) AS abs_col
FROM SampleMath;
执行结果
m | abs_col
---------+--------
500.000 | 500.000
-180.000 | 180.000
|
|
4行NULL
|
|
8.000 | 8.000
2.270 | 2.270
5.555 | 5.555
| NULL 凡 例
8.760 | 8.760 abs_col:ABS(m)的返回值（绝对值）
右侧的abs_col列就是通过ABS函数计算出的m列的绝对值。请
大家注意，-180的绝对值就是去掉符号后的结果180。
通过上述结果我们可以发现，ABS函数的参数为NULL时，结果也
是NULL。并非只有ABS函数如此，其实绝大多数函数对于NULL都返
回NULLA。
注A
■MOD——求余
但是转换函数中的COALESCE
函数除外。
语法6-2 MOD函数
MOD(被除数，除数)
KEYWORD MOD是计算除法余数（求余）的函数，是modulo的缩写。例如，
●MOD函数
7 / 3的余数是1，因此MOD（7, 3）的结果也是1（代码清单6 -3）。因为
小数计算中并没有余数的概念，所以只能对整数类型的列使用MOD函数。
代码清单6-3 计算除法（n ÷ p）的余数
Oracle DB2 PostgreSQL MySQL
SELECT n, p,
MOD(n, p) AS mod_col
FROM SampleMath;