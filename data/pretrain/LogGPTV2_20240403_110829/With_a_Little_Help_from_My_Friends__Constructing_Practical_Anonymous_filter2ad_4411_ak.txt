ğ‘§,ğ‘— ğ‘§(1)
ğœŒ(1)
1
ğ‘¦ ğ‘—
ğœ“ğ‘šâˆ—,ğ‘–,ğ‘—
ğ‘— âˆˆ[ğ‘]
ğ‘— âˆˆ[ğ‘]
ğ‘— âˆˆ[ğ‘]
1
ğ‘¦ ğ‘—
ğœ“ğ‘¦,ğ‘—
ğœ“ğ‘§,ğ‘—
ğ‘—
ğ‘—
ğ‘— âˆˆ[ğ‘]
ğ‘— âˆˆ[ğ‘]
ğ‘— âˆˆ[ğ‘]
(4)
)
Now, by expanding the RHS and comparing coefficients it follows
that ğœ‹ğ‘§ğœ‹ğ‘¦ = 0, ğœ‹ğ‘§ğœ“ğ‘¦,ğ‘— = 0, ğœ‹ğ‘¦ğœ“ğ‘§,ğ‘— = 0, ğœ‹ğ‘¦ğœŒ(ğ‘)
ğ‘§,ğ‘— = 0 for all ğ‘— âˆˆ [ğ‘],
ğ‘ âˆˆ [2] and ğœ“ğ‘§,ğ‘—ğœ“ğ‘¦,ğ‘˜ = 0 for all ğ‘—, ğ‘˜ âˆˆ [ğ‘]. This simplifies the RHS
ğœŒ(1)
ğ‘§,ğ‘— ğœ“ğ‘¦,ğ‘˜ğ‘§(1)
ğ‘—
1
ğ‘¦ğ‘˜
ğœŒ(2)
ğ‘§,ğ‘— ğœ“ğ‘¦,ğ‘˜ğ‘§(2)
ğ‘—
1
ğ‘¦ğ‘˜
(5)
ğ‘—
ğ‘§,ğ‘— ğœ“ğ‘¦,ğ‘˜ = 0 and ğœŒ(2)
Now, we take a closer look at Equation (5) and Claim 1 tells us that
every ğ‘§(ğ‘)
, ğ‘ âˆˆ [2], has an equal number of ğ‘¦â€™s and ğ‘¥â€™s (respec-
tively ğ‘¢â€™s) in the numerator and consequently for all monomials
on the LHS there is one ğ‘¦ less than ğ‘¥â€™s (or ğ‘¢â€™s respectively). Con-
sequently, following the same argumentation as in [45] we obtain
that ğœŒ(1)
ğ‘§,ğ‘— ğœ“ğ‘¦,ğ‘˜ = 0 for all ğ‘— â‰  ğ‘˜ (note that it may
be the case that either of ğ‘§(1) or ğ‘§(2) may not be present at all,
but one needs to be non-zero to represent a valid forgery. We will
consider the case where both are present subsequently, the other
cases are analogous). Furthermore, following the FHS15 argumen-
tation it follows that there is exactly one ğ‘› âˆˆ [ğ‘] s.t. ğœŒ(ğ‘)
ğ‘§,ğ‘› ğœ“ğ‘¦,ğ‘› â‰  0.
Consequently, we obtain a simplified version of Equation (5) as
ğ‘›
ğœŒ(1)
ğ‘§,ğ‘›ğœ“ğ‘¦,ğ‘›ğ‘§(1)
and substituting ğ‘§(ğ‘)
ğœŒ(1)
ğ‘§,ğ‘›ğœ“ğ‘¦,ğ‘›
ğœ“ğ‘¦,ğ‘›(ğœŒ(1)
âˆ‘ï¸
ğ‘›
1
ğ‘¦ğ‘›
+ ğœŒ(2)
ğ‘§,ğ‘›ğœ“ğ‘¦,ğ‘›ğ‘§(2)
ğ‘›
1
ğ‘¦ğ‘›
âˆ‘ï¸
ğ‘–âˆˆ[â„“]
ğ‘šğ‘›,ğ‘–(ğ‘¥ğ‘– + ğ‘¢ğ‘–)
by its definition and simplification we obtain
ğ‘šğ‘›,ğ‘–ğ‘¥ğ‘– + ğœŒ(2)
ğ‘§,ğ‘›ğœ“ğ‘¦,ğ‘›
ğ‘šğ‘›,ğ‘–ğ‘¢ğ‘– =
Now, plugging in ğ‘šğ‘›,ğ‘– and setting ğ›¼ = ğœ“ğ‘¦,ğ‘›(ğœŒ(1)
ğ‘§,ğ‘› + ğœŒ(2)
ğ‘§,ğ‘›) we obtain:
ğ‘–âˆˆ[â„“]
ğ‘§,ğ‘› + ğœŒ(2)
ğ‘§,ğ‘›) âˆ‘ï¸
ğœ‹ğ‘š,ğ‘›,ğ‘–+ âˆ‘ï¸
ğ‘–âˆˆ[â„“]
ğœŒ(2)
ğ‘š,ğ‘›,ğ‘–,ğ‘˜
ğ‘š,ğ‘›,ğ‘–,ğ‘˜
ğœŒ(1)
ğ‘˜ + âˆ‘ï¸
ğ‘˜âˆˆ[ ğ‘—âˆ’1]
ğ‘§(2)
ğ‘˜âˆˆ[ ğ‘—âˆ’1]
ğ‘šâˆ—,ğ‘–,ğ‘— = ğ›¼ğœŒ(1)
ğ›¼(cid:0) âˆ‘ï¸
âˆ‘ï¸
ğ‘–âˆˆ[â„“]
ğ‘˜âˆˆ[ ğ‘—âˆ’1]
ğ‘§(1)
ğ‘˜ +
ğœ“ğ‘š,ğ‘›,ğ‘–,ğ‘˜
(cid:1)(ğ‘¥ğ‘– + ğ‘¢ğ‘–)
1
ğ‘¦ğ‘˜
and by equating coefficients with the LHS of Equation (4) we obtain
that ğœ‹ğ‘šâˆ—,ğ‘– = ğ›¼ğœ‹ğ‘š,ğ‘›,ğ‘–, ğœŒ(1)
and
ğœ“ğ‘šâˆ—,ğ‘–,ğ‘— = ğ›¼ğœ“ğ‘š,ğ‘›,ğ‘–,ğ‘˜, whereas the forgery just represents a previously
queried message. Finally, the simulation error of the generic group
is identical to FHS15.
, ğœŒ(2)
ğ‘šâˆ—,ğ‘–,ğ‘— = ğ›¼ğœŒ(2)
ğ‘š,ğ‘›,ğ‘–,ğ‘˜
ğ‘š,ğ‘›,ğ‘–,ğ‘˜
C PROOFS FOR SECTION 4
C.1 Proof of Theorem 4.2
We will prove this theorem using a series of hybrid arguments. Let
asigâˆ— = (pkâˆ—
, ğœâˆ—
Attr) and Attrâˆ— be the values returned
by the adversary and nonceâˆ— be the value given to the adversary.
, Sigâˆ—
SFPK
SFPK
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2022, Sigâ€²
C.2 Proof of Theorem 4.3
We will prove this theorem using a series of hybrid arguments.
Let ğ‘HD denote the maximum number of queries made to the HD
oracle by the adversary. Let asig = (pkâ€²
, ğœâ€²
Attr) be the
SFPK
challenge signature given to the adversary.
H0 : This is the anonymity experiment.
H1 : We change the way the value ğœâ€²
Attr
is computed inside oracle
OHShow, i.e. instead of randomizing the AAEQ signature
using ChgRep, we use the secret key iskâˆ— to generate a fresh
signature on pkâ€²
H2 : We choose two distinct indexes ğ‘˜0, ğ‘˜1 âˆˆ [ğ‘HD] and abort
the experiment if ğ‘–0 â‰  ğ‘˜0 and ğ‘–1 â‰  ğ‘˜1 where ğ‘–0 â†$ I2D[ ğ‘—0],
ğ‘–1 â†$ I2D[ ğ‘—1] and ğ‘—0, ğ‘—1 were returned by the adversary.
SFPK
Lemma C.6. Hybrids H0 and H1 are indistinguishable assuming
.
SFPK
the AAEQ scheme perfectly adapts signatures.
Lemma C.7. The experiment is not aborted in H2 with probability
(1/ğ‘HD)2.
Lemma C.8. An adversary that has non-negligible advantage against
the anonymity experiment in H2 can be used to break the class-hiding
property of SFPK signatures.
Proof. We will show this by constructing a reduction R which
is given ((sk0, pk0), (sk1, pk1), pkâ€²) by the challenger and access to
an oracle that output valid SFPK signatures for public key pkâ€². The
reduction uses (sk0, pk0) and (sk1, pk1) to respectively simulate
the devices ğ‘˜0 and ğ‘˜1.
Finally, it receives ( ğ‘—0, ğ‘—1, Attrâˆ—, nonceâˆ—, iskâˆ—, ipkâˆ—, st) from the
adversary. Because we are in H2 we know that ğ‘—0, ğ‘—1 correspond
SFPK = pkâ€², uses
to devices ğ‘˜0, ğ‘˜1. The reduction now sets pkâ€²
on message aidâˆ— =
itâ€™s oracle to generate the signature Sigâ€²
AIDGen(Attrâˆ—, nonceâˆ—) and creates ğœâ€²
as per H2. The adversary
SFPK
ends the experiment by outputting ğ‘âˆ— which is also returned by
reduction. It is easy to see that in this case pkâ€² = pkğ‘ and the adver-
sary can be used this way to break the class-hiding property.
â–¡
Attr
C.3 Proof of Theorem 4.4
The proof follows using a simple reduction. The key point to no-
tice is that there is only one honest device created in this ex-
periment and the reduction can use itâ€™s own signing oracle to
get a SFPK signature and answer queries to the OCShow oracle.
What is more, since we require that aidâˆ— âˆ‰ SN it follows that
for asigâˆ— = (pkâˆ—
SFPK)
can be used by the reduction as a valid forgery. Note that in case
there exists a tuple (Attr, nonce) â‰  (Attrâˆ—, nonceâˆ—) for which aidâˆ— =
AIDGen(Attr, nonce) the reduction can return both pairs as a colli-
sion for AIDGen.
Attr) the tuple (aidâˆ—, pkâˆ—
, ğœâˆ—
, Sigâˆ—
, pkâˆ—
SFPK
SFPK
SFPK
Moreover, let ğ‘HD denote the maximum number of queries made to
the HD oracle by the adversary and aidâˆ— = AIDGen(Attrâˆ—, nonceâˆ—).
H0 : This is the anonymity experiment.
H1 : We change the way we generate the keys inside the OHD(ğ‘–)
oracle. Instead of SFPK.KeyGen we use trapdoor generation
SFPK.TKGen and retain the trapdoor ğ›¿ğ‘–.
H2 : We abort the experiment if there is a collision for aidâˆ—, i.e. if
there was a query for a tuple (Attr, nonce) â‰  (Attrâˆ—, nonceâˆ—)
for which aidâˆ— = AIDGen(Attr, nonce).
SFPK) = 0 for
all ğ‘— âˆˆ [ğ‘HD] and ğ‘— âˆˆ HD, i.e. we do not abort if the SFPK
public key is in a relation with an honest device public key.
H4 : We choose an index ğ‘— âˆˆ [ğ‘HD] and we abort the experiment
if SFPK.ChkRep(ğ›¿ ğ‘— , pkâˆ—
SFPK) = 0, i.e. we chose a specific
honest device.
H3 : We abort the experiment if SFPK.ChkRep(ğ›¿ ğ‘— , pkâˆ—
SFPK.TKGen produce key pairs with identical distribution.
Lemma C.1. Hybrids H0 and H1 are indistinguishable.
Proof. For the SFPK scheme we have that SFPK.KeyGen and
â–¡
Lemma C.2. The changes made in hybridH2 lowers the adversaries
advantage in the unforgeability experiment only by a negligible frac-
tion which is at most the advantage of breaking collision-resistance
of AIDGen.
Lemma C.3. The changes made in hybrid H3 lowers the adver-
saries advantage in the unforgeability experiment only by a negligible
fraction which is at most the advantage of an adversary breaking the
unforgeability of the AAEQ scheme.
Proof. We will show this proof via a simple reduction. The
idea for the reduction is to instead of using the AKGen and Sign
algorithm inside Issue to generate credentials cred for devices the
reduction will use its AAEQ signing query. In the end, the adversary
returns (Attrâˆ—, asigâˆ— = (pkâˆ—
, ğœâˆ—
Attr)) which contains a
AAEQ forgery for message (pkâˆ—
, Attrâˆ—).
Note that because we only abort if the SFPK public key pkSFPK
is not in a relation with any of the honest device and by definition
this excludes the usage of all corrupted attribute. Thus, we know
that Attrâˆ— was never queried together with an element from the
class [pkâˆ—
â–¡
SFPK]R to the AAEQ signing oracle.
, Sigâˆ—
SFPK
SFPK
SFPK
Lemma C.4. Hybrid H4 does not abort with prob. 1/ğ‘HD.
Lemma C.5. An adversary that has non-negligible advantage against
the unforgeability experiment in H4 can be used to break the unforge-
ability of the SFPK scheme.
Proof. We will show this proof via a simple reduction. The
idea is for the reduction to simulate the ğ‘—-the device using the
SFPK signing oracle. In other words, instead of running algorithm
CObtain, CShow for the secret device key DSK[ ğ‘—], the reduction
asks the oracle for the corresponding signature.
Finally the adversary output asigâˆ— for which we know that
SFPK.ChkRep(ğ›¿ ğ‘— , pkâˆ—
cor-
responds to the device that the reduction simulated using the SFPK
challenges. Thus by returning (pkâˆ—
SFPK) the reduction
outputs a valid forgery against the SFPK unforgeability experi-
ment.
â–¡
SFPK) = 1, i.e. that the signature Sigâˆ—
, aidâˆ—, Sigâˆ—
SFPK
SFPK
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2023