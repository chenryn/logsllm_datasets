：标准的进入序列
mov ebp, esp
其中nop指令占1字节，本身不做任何操作，也是以占位符的形式存在，FUNCTION为一
个标号，表明函数的入口，本身不占据任何空阅，
被设计成这样的函数在运行的时候可以很容易被其他函数“替换”掉，在上面的指令序列
申调用的函数是FUNCTION，但是我们可以做一些改动，就可以在运行时刻修改成调用函
数REPLACEMENT_FUNCTION，首先我们需要在进程的内存空间里的任意某处写入
REPLACEMENT_FUNCTION 的定义:
REPLACEMENT_FUNCTION:
dsa*dqa Aou
push ebp
nov esp, ebp
dqe dod
ret
然后将原函数的内容稍作修改即可：
LABEL:
jmp REPLACEMENT_FUNCTION
:NOILON
：函数的实际入口
np LABEL
push ebp
：标准的进入序列
mov ebp, esp
程序员的自我修养一链接、装载与库
---
## Page 316
10.2栈与调用惯例
293
在这里，我们首先将占用5个字节的5个nop指令覆盖为一个jmp指令（恰好5字节）
然后将占用两个字节的movedi,edi指令替换为另一个jmp指令，为什么第二个jmp指令尺
占用2个字节呢？因为这个jmp 的目标距离这个jmp指令本身非常近，因此这个jmp指令
就被汇编器翻译成了一个“近跳”指令，这种指令只占用2个字节，但只能疏跃至当前地址
前后127字节范围的目标位置，在经过这样的替换之后，原函数的调用就被转换为新函数的
调用，
这里替换的机制往往可以用来实现一种叫做钩子（Hook）的技术，允许用户在某些时
刻截获特定函数的调用，如图10-7所示。
10.2.2调用惯例
经过前面的分析和讨论，我们大致知道了函数调用时实际发生的事件。从这样的信息里
能够发现一个现象，那就是函数的调用方和被调用方对函数如何调用有着统一的理解，例如
它们双方都一致地认同函数的参数是按照某个固定的方式压入栈内。如果不这样的话，函数
将无法正确运行，这就好比我们说话时需要双方对同一个声音（语音）有若一致的理解一样，
否则就会产生误解，如图10-7所示。
黑龙江？
C
图10-7函数调用惯例胧如语言
假设有一个foo函数：
int foo(int n, float m)
int a = 0, b = 0;
如果函数的调用方在传递参数时先压入参数n，再压入参数m，而foo函数却认为其调
用方应该先压入参数m，后压入参数n，那么不难想象foo内部的m和n的值将会被交换。
如图10-8所示。
程序员的自我修养一链接、装载与库
---
## Page 317
294
第10章内存
实际的栈状态
foo认为
m
返图地址
图10-8错误的调用惯例
再者如果函数的调用方决定利用寄存器传递参数，而函数本身却仍然以为参数通过栈传递，
那么显然函数无法获取正确的参数。因此，毫无疑问函数的调用方和被调用方对于函数如何调
用须要有一个明确的约定，只有双方都遵守同样的约定，函数才能被正确地调用，这样的约定
就称为调用惯例（CallingConvention）。一个调用惯例一般会规定如下儿个方面的内容。
·
函数参数的传递顾序和方式
函数参数的传递有很多种方式，最常见的一种是通过栈传递，函数的调用方将参数压入
栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方
将参数压栈的顺序：是从左至石，还是从右至左。有些调用食例还允许使用寄存器传递参数，
以提高性能。
栈的维护方式
在函数将参数压栈之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以
使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函
数本身来完成。
·名字修饰（Name-mangling）的策略
为了链接的时候对调用惯例进行区分，调用管理要对函数本身的名字进行修饰，不同的
调用惯例有不同的名字修饰策略。
事实上，在C语言里，存在着多个调用惯例，而默认的调用惯例是cdecl。任何一个没
有显式指定调用惯例的函数都默认是cdecl惯例。对于函数foo的声明，它的完整形式是：
int _cdecl foo(int n, float m)
注
_cdecl是非标准关键字，在不同的编译器里可能有不同的写法，例如在gcc里就不存在
_cdecl这样的关键字，而是使用_attribute_(lcdecll)。
cdecl这个调用惯例是C语言默认的调用惯例，它的内容如表10-1所示。
表10-1
数传递出栈方名字修饰
从右至左的顺序压参数入栈函数调用方
直接在函数名称前加1个下划线
程序员的自我修养一链接、装载与库
---
## Page 318
10.2栈与调用惯例
295
因此foo被修饰之后就变为_foo。在调用 foo的时候，按照cdecl 的参数传递方式，具
体的堆栈操作如下。
将m压入栈。
将n压入栈。
·
调用_foo，此步又分为两个步骤：
a）将返回地址（即调用_foo之后的下一条指令的地址）压入栈：
b）跳转到_foo执行。
当函数返回之后：sp=sp+8（参数出栈，由于不需要得到出栈的数据，所以直接调整
栈项位置就可以了）。因此进入foo函数之后，栈上大致是如图10-9所示。
m
返回地址
图10-9fo0函数栈布局
然后在foo里面要保存一系列的寄存器，包括函数调用方的ebp寄存器，以及要为a和
b两个局部变量分配空间（参见本节开头）。最终的栈的构成会如图10-10所示。
ebp+12
m
ebp+8
n
ebp+4
返图地址
4etp
old ebp
保存寄存器和局部
变量等
图10-10foo函数栈布局（2）
对于不同的编译器，由于分配局部变量和保存寄存器的策略不同，这个结果可能有出入。
在以上布局中，如果想访问变量n，实际的地址是使用ebp+8。当foo返回的时候，程序首
先会使用pop恢复保存在栈里的寄存器，然后从栈里取得返回地址，返回到调用方，调用方
程序员的自我修养—键接、装载与库
---
## Page 319
296
第10章内存
再调整ESP将堆栈恢复。因此有如下代码：
void f(int ×, int y)
return:
int main()
f (1, 3) ;
return 0;
实际执行的操作如图10-11所示。
nain的核
通居地址
Od etp
3
finakiac
空量
main的牲
main的线
3
1
返国地址
返目地址
main的栈
3
图10-11main函数的执行流程
其中虚线指向该指令执行后的栈状态，实线表示程序的跳转状况。同样，对于多级调用，
如果我们有如下代码：
void f(int y)
printf(*y=$d*, y) 1
int
main ()
int x = 1
程序员的自我修养一链接、装载与库
---
## Page 320
10.2栈与调用惯例
297
f (x) :
return 0;
这些代码形成的堆栈格局如图10-12所示。
t(int y)
lnt_y?
(*P4-A)ver.ad
r{,,wd
eriett(y=d",_x11
mmia()
tain()
f (x) :
Int x • 1;
returh 0;
od ete
d etep
f etp
保有套存器和显社
保存费存国和用邮
返国地址
适居地址
od atp
old ete
保存图存和
Y
dd etp
printf(*y-kd*, y):
printf(*y-$d*, y11
return_0L
maint)
mxin()
reters 0,
old etp
old ebp
存客存
通目地址
od etp
图10-12多级调用栈布局
程序员的自我修养一
一链接、装载与库
---
## Page 321
298
第10章内存
图10-12的箭头表示地址的指向关系，而带下划线的代码表示当前执行的代码。除了
cdecl调用惯例之外，还存在很多别的调用惯例，例如 stdcall、fastcall等，表10-2介绍了儿
项主要的调用惯例的内容。
表10-2
名字修饰
西数调用方
从右至左的顺序压参数入栈
下划线+函数名
下划线+函数名+@+参数的字节
stdcall
函数本身
从右至左的顺序压参数入栈
数，如函数 int func(int a, double b)
的修饰名是_func@12
头两个DWORD（4字节）类
fastcall
函数本身
型或者占更少字节的参数被
放入寄存器，其他剩下的参
+函数名+@+参数的字节数
数按从右到左的顺序压入栈
_pascal
函数本身
从左至右的顺序压参数入栈较为复杂，参见pascal文档
此外，不少编译器还提供一种称为nakedcall的调用惯例，这种调用惯例用在特殊的场
合，其特点是编译器不产生任何保护寄存器的代码，故称为nakedcall。对于C++语言，以
上几种调用惯例的名字修饰策略都有所改变，因为C++支持函数重载以及命名空间和成员函
数等等，因此实际上一个函数名可以对应多个函数定义，那么上面提到的名字修饰策略显然
是无法区分各个不同同名函数定义的，所以C++自己有更加复杂的名字修饰策略，我们在前
面的章节也已经遇到过了。最后，C++自己还有一种特殊的调用惯例，称为thiscall，专用于
类成员函数的调用。其特点随编译器不同面不同，在VC里是this指针存放于ecx寄存器，
参数从右到左压栈，而对于gcc、thiscall和cdecl完全一样，只是将this看作是函数的第一
个参数。
【小实验】
我们可以让函数的调用方使用错误的调用惯例，看看能发生什么事情：