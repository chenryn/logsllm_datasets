warning代码
if response["auto_delete"] != auto_delete:
print "WARN: Queue '%s' - auto_delete flag is NOT %s." %\
(queue_name,auto_delete)
exit(EXIT_WARNING)
标记不正确，返
if response["durable"]!=durable:
回warning代码
print"WARN:Queue‘%s'-durable flag is NOT %s."%\
(queue_name,durable)
6队列存在，并且各
exit(EXIT_WARNING)
个标记都正确，返
 299:
exit(EXIT_UNKNOWN)
如同之前基于API的健康检测程序一样，你通过HTTP连接到API服务器·，
并通过Base64编码的头来发送凭证3。唯一不同的地方在于该健康检测程序将发送
请求到/api/nodes②。在发送请求之后，你准备开始处理API服务器的响应，如
下列代码清单所示。由于你需要检测节点成员看看是否有缺失，同时也要检测每个
节点的内存使用情况，因此你将对包含数据和配置的节点字典数字进行两次遍历。
清单10.7cluster health_check.py：处理节点列表
response = json.loads(response.read())
mem_critical:
print"CRITICAL:Node&s memoryusageis &d."%\
(node["name"],node["mem_used"])
exit(EXIT_CRITICAL)
4所有节点
print "WARNING:Node &s memory usage is &d."\
都存在，
(node["name"],node["mem_used"])
并且使用
exit(EXIT_WARNING)
的内存未
超过限制
print "oK:%d nodes.All memory usage below %d."%(len(response),
mem_warning)
exit(EXIT_OK)
---
## Page 227
10.1监控RabbitMQ：密切关注你的warren
205
在用JSON解码节点字典数组为对应的Python变量之后O，你尝试将字典中的
每个节点name元素2与从命令行传人的期望成员的节点相匹配。随着选代节点字
典数组，如果字典中的name元素和期望的节点名称相匹配的话（并且该节点处于
running），那么就从期望节点列表中移除该名称。结果是如果所有期望的节点都存
在的话，那么在结束遍历节点字典时，期望节点列表就会为空。另一方面，如果期
望节点列表中仍然有条目的话，那么根据/api/nodes，你就知道这些节点不存在了，
或者没有运行。如果检测程序确定集群中缺失了节点，那么你将退出代码设置为
EXIT_WARNING并退出，不再进行其他分析了。将状态设置为warning的原因在于
缺失的节点虽然会使得集群在性能上有所损失，但是却不会使得集群无法正常工作。
如果你觉得缺失节点非常严重的话，那么就将退出代码设置为EXIT_CRITICAL。
一旦你确认了所有期望节点都存在于集群之中的话，然后你就再一次迭代每
个节点字典，求出每个节点使用的内存大小3。如果任何节点字典中的mem_used
元素大于通过命令行设置的critical内存使用国值的话，那么就将状态代码设置为
EXITCRITICAL并退出，同时输出一段可读信息表示受影响的节点当前的内存使
用数据（以字节表示）。如果节点的mem_used元素没有超过critical国值，但是超
过了内存使用的warming国值的话，你将以EXIT_WARNING状态代码退出，并输出
受影响节点的当前内存使用情况。最后，如果所有期望的集群成员都存在，并且没
有一个超过了warming或者critical内存使用国值的话，就以EXIT_OK状态代码退
出4，并输出所有节点内存使用均低于warning国值数值。让我们这就来运行健康
检测程序，看看会发生什么吧：
$python cluster_health_check.py localhost:55672 guest guest\
rabbit@Phantome,rabbit2@Phantome34000000 33000000
OK: 2 nodes. All memory usage below 33000000.
$echo$?
0
棒极了，你的健康检测程序确认了rabbit@Phantome和rabbit2@Phantome
节点是集群中的成员，并且两者的内存使用情况均低于critical（34MB）和warming
（33MB）国值。不过，让我们来看看你的检测程序如何处理其中一个集群节点消失
的情况：
$ rabbitmqctl -n rabbit2@Phantome stop_app
Stopping node rabbit2@Phantome ...
...done.
---
## Page 228
206
第10章监控
$ python cluster_health_check.py localhost:55672 guest guest
rabbit@Phantome,rabbit2@Phantome34000000 33000000
WARNING:Cluster missing nodes:['rabbit2@Phantome']
$echo $?
1
到目前为止一切顺利；你的健康检测程序不仅检测到了集群中有节点缺失，同
时能告诉你是哪个节点缺失了。最后，你需要确定检测程序能够正确地对节点进行
warning和critical内存阈值检测：
$ python cluster_health_check.py localhost:55672 guest guest
rabbit@Phantome,rabbit2@Phantome 32000000 31000000
WARNING: Node rabbit2@Phantome memory usage is 31785552.
$ echo $?
1
rabbit@Phantome,rabbit2@Phantome3100000030000000
CRITICAL: Node rabbit2@Phantome memory usage is 31834792.
$echo$?
通过将critical/warning内存国值在32MB/31MB和31MB/30MB两者之间进
行切换，你可以看到当RabbitMQ使用了超出限定的内存时，你的新检测程序能够
正确检测并报告。现在你拥有一套完整的面向Rabbit的健康检测。它不仅能在单
台RabbitMQ服务器不可用的时候告知你，同时也能在Rabbit集群缺失节点或者任
何成员节点快要耗尽内存的时候及时通知你。但是如果问题不在于Rabbit是否正常
运作，而是在于你的应用程序是否能像原本那样正确地消费消息呢？集群健康检测
可以让你知道内存是否耗尽，但是如果问题在于你的遛狗应用未能正确消费订单队
列中的订单的话，在内存耗尽成为问题之前就能够知道，这不是很好吗？如果你的
消息容量（或者大小）很低，则监控特定队列中有多少条消息显得更为重要，因为