# 计算机组成
> 注 : 笔记中拓扑图 drawio 源文件在其图片目录下
---
# 计算机工作流程
![](../../../assets/img/Develop/计算机基础/计算机组成/1.png)
- 存储器：用于存储数据并在需要时提供数据
    - 外部存储器：硬盘、光盘等等
    - 内部存取器：
        - RAM：内存条
        - ROM：BIOS 芯片
- CPU
    - 运算器 ：对数据进行各种算术运算和逻辑运算，即对数据进行加工处理
    - 控制器 ：完成协调和指挥整个计算机系统的操作
---
## CPU
CPU 的核心是从程序或应用程序获取指令并执行计算。此过程可以分为三个关键阶段：提取，解码和执行。
CPU 从系统的 RAM 中提取指令，然后解码该指令的实际内容，然后再由 CPU 的相关部分执行该指令。
在 CPU 的结构中，需要尽量了解寄存器，因为程序是把寄存器作为对象来描述的。
**程序计数器**
程序计数器(Program Counter)是用来存储下一条指令所在单元的地址。
程序执行时 PC 的初值为程序第一条指令的地址，在顺序执行程序时，控制器首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将PC的值加1指向下一条要执行的指令。
![](../../../assets/img/Develop/计算机基础/计算机组成/4.png)
这是一段进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，示例中是将 123 和 456 进行相加并将结果输出到显示器上。
实际上每个指令和数据都可能分布在不同的地址上，地址 0100 是程序运行的起始位置。windows 等操作系统把程序从硬盘复制到内存后，会将程序计数器作为设定为起始位置 0100，然后执行程序，每执行一条指令后，程序计数器的数据会增加 1(或者直接指向下一条指令的地址)，然后，CPU 根据程序计数器的数值，从内存中读取命令并执行，程序计数器控制着程序的流程。
**条件分支和循环机制**
高级语言中的条件控制流程主要分为三种：顺序执行、条件分支、循环判断三种，
- 顺序执行时按照地址的内容顺序的执行指令。
- 条件分支是根据条件执行任意地址的指令。
- 循环是重复执行同一地址的指令。
![](../../../assets/img/Develop/计算机基础/计算机组成/5.png)
程序的开始过程和顺序流程是一样的，CPU 从 0100 处开始执行命令，在 0100 和 0101 都是顺序执行，PC 的值顺序 + 1，执行到 0102 地址的指令时，判断 0106 的寄存器的数值大于 0，跳转 (jump) 到 0104 地址的指令，将数值输出到显示器中，然后结束程序，0103 的指令被跳过了，这就和我们程序中的 if() 判断是一样的，在不满足条件的情况下，指令会直接跳过。所以 PC 的执行过程也就没有直接 + 1, 而是下一条指令的地址。
**标志寄存器**
条件和循环分支会使用到 jump(跳转指令)，会根据当前的指令来判断是否跳转，上面我们提到了标志寄存器，无论当前累加寄存器的运算结果是正数、负数还是零，标志寄存器都会将其保存 (也负责溢出和奇偶校验)
- 溢出 (overflow): 指运算的结果超过了寄存器的长度范围
- 奇偶校验 (parity check): 指检查运算结果的值是偶数还是奇数
CPU 在进行运算时，标志寄存器的数值会根据当前运算的结果自动设定，运算结果的正、负和零三种状态由标志寄存器的三个位表示。标志寄存器的第一个字节位、第二个字节位、第三个字节位各自的结果都为 1 时，分别代表正数、零和负数。
![](../../../assets/img/Develop/计算机基础/计算机组成/6.png)
假设累加寄存器中存储的值 X 和通用寄存器中存储的值 Y 做比较，CPU 会通过减法来进行比较。而无论减法的结果是正数、零还是负数，都会保存到标志寄存器中。结果为正表示 X 比 Y 大，结果为 0 表示 X 和 Y 相等，结果为负表示 X 小于 Y，所以程序的比较指令，在 CPU 内部是做减法运算。
**函数调用机制**
函数调用处理通过把程序计数器的值设定成函数的存储地址来实现的。函数执行跳转指令后，必须进行返回处理，单纯的指令跳转没有意义。
![](../../../assets/img/Develop/计算机基础/计算机组成/7.png)
上图中将变量 a、b 分别赋值为 123 和 456，然后调用 MyFun(a,b) 方法，进行指令跳转。图中的地址是将 C 语言编译成机器语言后运行时的地址，由于 1 行 C 程序在编译后通常会变为多行机器语言，所以图中的地址是分散的。在执行完 MyFun(a,b) 指令后，程序会返回到 MyFun(a,b) 的下一条指令，CPU 继续执行下面的指令。
函数的调用和返回很重要的两个指令是 call 和 return 指令，再将函数的入口地址设定到程序计数器之前，call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行 return 指令。return 指令的功能是把保存在栈中的地址设定到程序计数器。MyFun 函数在被调用之前，0154 地址保存在栈中，MyFun 函数处理完成后，会把 0154 的地址保存在程序计数器中。
![](../../../assets/img/Develop/计算机基础/计算机组成/8.png)
在一些高级语言的条件或循环语句中，函数调用的处理会转换成 Call 指令，函数结束后的处理会转换成 return 指令
**通过地址或索引实现数组**
通过基址寄存器和变址寄存器，我们可以对主存上的特定区域进行划分，来实现类似数组的操作。
例如，用十六进制将内存中的 00000000-FFFFFFFF 的地址划分出来，那么，凡是该范围的内存地址，只要有一个 32 位的寄存器，便可查看全部地址。但如果要像数组那样分割特定的内存区域以达到连续查看的目的，使用两个寄存器会更加方便。
例如，通过两个寄存器来表示内存的值
![](../../../assets/img/Develop/计算机基础/计算机组成/9.png)
数组是指同样长度的数据在内存中进行连续排列的数据构造。用数组名表示数组全部的值，通过索引来区分数组的各个数据元素，例如: a\[0]-a\[4],\[ ] 内的 0-4 就是数组的下标。
### CPU指令执行过程
- 取指令 : 将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址。
- 指令译码 : 在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分不同的指令类别以及各种获取操作数的方法。
- 执行指令 : 译码完成后，需要执行这一指令，此阶段是完成指令所规定的各种操作，具体实现指令的功能。
- 访问取数 : 根据指令的需要，有可能需要从内存中提取数据，此阶段根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。
- 结果写回 : 最后一阶段，把执行指令阶段的运行结果数据 "写回" 到某种存储形式: 结果数据经常被写到 CPU 的内部寄存器中，以便被后续的指令快速的存取。
---
## 内存
- 内容见 [内存](./内存.md)
---
## 存储器
磁盘和内存都具有存储功能，但内存通过电流来实现存储，磁盘通过磁记录技术实现。
内存断电后数据消失，而磁盘中的数据可以长存，内存属于内部存储设备，硬盘属于外部存储设备，两者结合使用。
### 存储单位
8bits=1Bytes 简称 8B 1 比特
- Byte = 8 bit
- Word = 2 Byte = 16 bit
- Dword = 4 Byte = 32 bit
- KB = 1048B(Byte)
- MB = 1024KB
- GB = 1024MB
- TB = 1024GB
买硬盘时,看到标 500G,但实际只有 466G,正常,原因是制作商使用 10 进制单位,500G 代表 500\*1000\*1000\*1000Byte=466GB.
因为硬盘的最小物理量为 512Bytes,最小的组成单位为扇区( sector ),通常计算硬盘容量是看有多少个 sector,所以才用十进制处理,
**位 (bit)**
来自英文 bit, 音译为 "比特", 表示二进制位.