        catch(C e) 
// 捕捉 C 类型的异常 
20 
        { 
21 
            printf("Class C %d captured\n",e.no); 
22 
        } 
23 
        o.age=o0.age;     
//此语句前 EHRec 被设置为 2 
24 
    }             
// EHRec = 1 
25 
    catch(...)     
// 捕捉所有类型的异常 
26 
    {             
27 
        printf("Async exception captured\n");     
28 
    }             
29 
    return o.age;      
// EHRec = 0 
30 
} 
31 
int main(int argc, char* argv[]) 
32 
{ 
33 
    printf("Exception Handling in C++ [%d]!\n", CppEH(argc-1)); 
34 
    return 0; 
35 
} 
36 
随便跟一个参数执行调试版本的 CppEh.EXE 程序，此时 argc = 2，所以第 16 行的
除法操作可以顺利进行，于是执行第 17 行的 throw 语句，即抛出一个 C++类类型的异常，
这个异常会被第一个 catch 块捕捉到，其执行结果如清单 24-22 所示。 
清单 24-22  带一个参数执行 CppEH 程序 
c:\dig\dbg\author\code\bin\Debug>cppeh 888 //带一个参数执行调试版本的 CppEH 程序 
《软件调试》补编 
- 31 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
Object 1 is destroyed [100]   
//执行 Catch 块前栈展开时析构对象 o1 
Class C 1 is captured   
//执行第 19～22 行的 catch 块 
Object 1 is destroyed [100]   
//Catch 块中的用户代码执行后析构对象 e 
Object 1 is destroyed [100]   
//析构抛出的异常对象，参见第 24.9 节 
Object 0 is destroyed [100]   
//对象 o0 被析构 
Object -1 is destroyed [100]   
//-1 号对象被析构 
Exception Handling in C++ [100]!   
//main 函数打印的消息 
如果不带任何参数执行调试版本的 CppEh.EXE，因为 argc = 1，所以第 16 行会导致
一个除零异常，对于 C++程序来说，这是个非语言级的异常，相对于使用 throw 语句抛
出的 C++异常，又被称为异步异常（Asynchronous Exception）或结构化异常（Structured 
Exception）。普通 catch 块的异常声明只匹配 C++异常，对于除零这样的异步异常，只有
第二个 catch 块有可能捕捉到。之所以说有可能，是因为这与编译器的设置有关，直接执
行使用默认选项编译出的调试版本 CppEH 程序（不带参数），程序的执行结果为： 
c:\dig\dbg\author\code\bin\Debug>cppeh   
//不带参数执行调试版本的 CppEH 程序 
Object 0 is destroyed [0]   
//对象 o0 被析构 
Async exception captured   
//执行第 25～28 行的 catch 块 
Object -1 is destroyed [100]   
//对象 o-1 被析构 
Exception Handling in C++ [100]!   
// main 函数打印的消息 
也就是说，使用默认选项编译的调试版本中的 catch(…)块捕捉到了除零异常。对于
发布版本的 CppEH.EXE，带参数执行的结果是一样的，如果不带参数执行，那么会导致
应用程序错误，启动 JIT 调试，这说明默认发布版本的 CppEH.EXE 的 catch(…)块没有捕
捉到除零异常。 
事实上，VC 编译器（VC6 和 VC2005 都有）有一个 C++异常有关的重要选项： 
/EH{s|a}[c][-] 
其中 s 代表只捕捉同步异常而且外部（extern）C 函数会抛出异常；a 代表捕捉同步和
异步异常，c 代表外部（extern）C 函数不抛出异常。编译器对发布版本的默认设置为 EHsc，
即只捕捉非 C 函数的同步异常，这样编译器就可以假定只有 throw 语句和函数调用语句
才会发生异常，如果某些对象的生命期没有跨越 throw 语句和函数调用，那么在构建对象
展开记录时就可以不考虑这些对象，从而减小编译出的目标代码大小，因此 EHsc 是最经
济的设置。 
如果在发布版本的项目属性中加入/EHa 开关（Settings → C++选 Customize，然后在
编辑框中输入），重新编译，然后再执行，则 catch(…)块便也可以捕捉除零异常了。 
24.8.2  C++异常处理的编译 
了解了 C++异常处理的基本用法后，我们来看一下 VC 编译器是如何编译包含
try{}catch 结构的，仍以 CppEH 函数为例。在讨论之前要说明的一点是，C++标准定义
了 C++异常处理的基本行为，但是并没有规定编译器应该如何编译有关的代码。因此不同
编译器的实现机制会有所不同，我们以 VC 编译器为例。清单 24-23 给出了 CppEH 函数
（发布版本）开头处的汇编代码。 
清单 24-23  CppEH 函数的序言（发布版本） 
1 
CppEH!CppEH: 
2 
00401000 55               push    ebp 
3 
00401001 8bec             mov     ebp,esp 
4 
00401003 6aff             push    0FFFFFFFFh 
5 
00401005 68d8784000      push    offset CppEH!CloseHandle+0x22 (004078d8) 
6 
0040100a 64a100000000    mov     eax,dword ptr fs:[00000000h] 
7 
00401010 50                push    eax 
8 
00401011 64892500000000  mov     dword ptr fs:[0],esp 
9 
00401018 83ec24           sub     esp,24h 
《软件调试》补编 
- 32 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
容易看出，以上代码与前面几节介绍使用__try{}__except()结构的情况很类似，但
有以下两点不同。 
第一，在压入处理函数的地址之前，压入的是 EHRec 变量的初始值−1，没有压入范
围表指针（scopetable）。这是因为 try{}catch 结构不使用我们前面介绍的范围表结构，
而是使用我们下面要介绍的 cxx_function_descr 和 tryblock_info 等结构。EHRec 变
量的作用与__try{}__except 结构中使用的 trylevel 类似，但是其变化规则有所不同。这
样一来，try{}catch 结构登记在 FS:[0]链条上的数据结构便与__try{}__except()所使
用的_EXCEPTION_REGISTRATION 结构有所不同，MSVCR80 的调试符号中将这个结构
称为 EHRegistrationNode，详情如下： 
0:000> dt EHRegistrationNode   
//CppEH 使用的登记结构 
   +0x000 pNext            : Ptr32 EHRegistrationNode   
//指向下一个节点 
   +0x004 frameHandler     : Ptr32 Void   
//处理函数 
   +0x008 state            : Int4B   
//即 EHRec 
第二，对于__try{}__except()结构，第 5 行压入的是_except_handler3 这样的函
数，而现在压入的显然不再是_except_handler3 函数。也就是说，使用 C++异常处理的
函数所注册的异常处理函数与使用__try{}__except()结构时的处理函数是不同的。那么
这个函数是什么？不妨反汇编其地址（004078d8）来看一下。 
清单 24-24  编译器（VC6）动态产生的异常处理函数 
0:000> u 004078d8 
CppEH!CloseHandle+0x22: 
004078d8 b820864000      mov     eax,offset CppEH!_TI1H+0x10 (00408620) 
004078dd e9a299ffff      jmp     CppEH!__CxxFrameHandler (00401284) 
可 见 这 个 函 数 只 是 一 个 过 度 ， 它 将 某 个 地 址 赋 给 EAX 寄 存 器 后 便 跳 转 到
__CxxFrameHandler 函数。所以可以说这段代码只是__CxxFrameHandler 函数的一个特
别入口，我们将这一小段代码称为C++异常处理函数的入口片段，简称CppEH入口。CppEH
入口是编译器动态产生的，因为没有为其输出专门的符号，所以上面清单中（第 5 行）使
用了邻近的符号（CppEH!CloseHandle）来做参照物。 
事实上，CppEH 入口就是为了传递赋给 EAX 寄存器的那个地址值（00408620），或
者说以这种特别的方式来传递参数。这个地址指向的是一个名为__cxx_function_ descr
的数据结构，称为 C++函数描述符，其定义如下： 
typdedef struct __cxx_function_descr{     
       UINT  magic    
//结构签名，固定为 0x19930520 
       UINT  unwind_count    
//unwind_table 数组所包含的元素个数 
       unwind_info *  unwind_table    //用于描述展开信息的展开表 
       UINT  tryblock_count    
// tryblock 数组所包含的元素个数 
       tryblock_info *  tryblock    
//用于描述 try{}catch 结构的 Try 块表 
       UINT  unknown [3]   
// 
} cxx_function_descr;     
其中，magic 为一个固定的整数，始终为 0x19930520，当使用 throw 关键字抛出 C++
异常时，异常参数信息 ExceptionInformation[0]中设置的也是这个值（见后文）。
unwind_count 字段描述的是下面的 unwind_table 数组所包含的元素个数，unwind_table
的每个元素是一个 unwind_info，用于描述栈展开时所需的信息。tryblock_count 是下
面的 tryblock 数组的元素个数，也就是函数内所包含的 Try 块的个数。使用 dd 命令加上
CppEH 入口代码中的地址便可以观察 CppEH 函数的描述结构： 
0:000> dd 00408620 
00408620  19930520 00000007 00408640 00000002 
00408630  00408678 00000000 00000000 00000000 
其中，19930520 是 magic 字段，00000007 代表 00408640 处有 7 个 unwind_info 结
《软件调试》补编 
- 33 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
构，后面的 2 代表这个函数中共有两个 Try 块，它们的描述位于 00408678。unwind_info
结构的定义如下： 
typedef struct __unwind_info 
{ 
     int    prev;          
//这个展开任务执行后要执行的下一个展开处理器的 EHRec 
     void (*handler)();      //执行这个展开任务的函数，即展开处理器（unwind handler） 
} unwind_info; 
对于 CppEH 函数，unwind_count = 7，unwind_table 数组的地址是 00408640，使
用 dd 命令可以观察原始的数据： 
0:000> dd 00408640 le 
00408640  ffffffff 004078c0 00000000 00000000 
00408650  00000001 004078c8 00000002 00000000 
00408660  00000003 004078d0 00000002 00000000 
00408670  00000000 00000000 
其中第 2、4 列是 prev 字段，第 3、5 列是 handler 字段。可以看到某些 handler
字段为空，这是预留在这，没有真正使用。非零的 handler 字段值代表栈展开时要调用
的函数地址。对其其中的 004078c0 进行反汇编： 
0:000> u 004078c0  
004078c0 8d4de0          lea     ecx,[ebp-20h]     
004078c3 e91898ffff     jmp     CppEH!C::~C (004010e0)     
可见这也是很短的一个转发性代码，共有两行汇编，第 1 行是将一个局部变量的地址
赋给 ECX 寄存器，然后便跳转到类 C 的析构函数中，因为 this 调用协议是使用 ECX 寄存
器来传递 this 指针的，所以这显然是将对象指针赋给 ECX，然后便调用这个对象的析构函
数。对 004078c8 和 004078d0 进行反汇编，看到的结果非常类似，因此可以想象到这 3 个
代码片段是与 CppEH 函数中的 3 个对象一一对应。 
描述 try{}catch 布局的 tryblock_info 结构的定义如下： 
typedef struct __tryblock_info 
{ 
     int   start_level;          
//这个 Try 块起点的 EHRec 级别 
     int   end_level;            
//这个 Try 块的终点的 EHRec 级别 
     int   catch_level;          
//Catch 块的初始 EHRec 级别 
     int   catchblock_count;   
//catchblock 数组的元素个数 
     const catchblock_info *catchblock;   //描述 Catch 块的数组 
} tryblock_info; 
在 CppEH 函数中有两个 Try 块，因此 tryblock 所指向的地址处有两个 tryblock_ 
info，使用 dd 命令可以观察这两个结构： 
0:000> dd 00408678 la 
00408678  00000003 00000004 00000005 00000001 
00408688  004086a0 00000001 00000005 00000006 
00408698  00000001 004086b0 
每个 tryblock_info 结构的长度是 20 个字节，即 5 个 DWORD 长，因此我们一共
显示了 10 个 DWORD，前 5 个描述的是内层的 Try 块（第 14～18 行，我们将其称为 Try1），
后 5 个描述的是外层的 Try 块（第 11～24 行，即 Try0）。 
为了支持对象展开，编译器在描述 C++异常结构时，使用一个名为 EHRec 的内部变
量来标记不同的区域。编译器产生的代码是使用 EBP-4 来索引 EHRec 变量，因此观察汇
编代码中对局部变量 EBP-4 的赋值指令就可以看到编译器是如何设置 EHRec 的。对于
CppEH 函数，我们将 EHRec 的设置情况标记在清单 24-22 的注释中。 
catchblock_count 字段用来记录 Try 块所拥有的 Catch 块数量，catchblock 数组用
来描述每个 Catch 块的信息，每个元素是一个 catchblock_info 结构： 
typedef struct __catchblock_info 