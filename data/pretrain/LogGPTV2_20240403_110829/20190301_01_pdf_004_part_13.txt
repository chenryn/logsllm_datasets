 Hash Join – A table is scanned and its join attributes are loaded into a hash table
using its join attributes as hash keys. The other joined table is then scanned and its
join attributes are used as hash keys to locate the matching rows from the first
table.
The following table lists the optimizer hints that can be used to influence the planner to
use one type of join plan over another.
Table 2-3 Join Hints
Hint Description
USE_HASH(table [...]) Use a hash join for table.
NO_USE_HASH(table [...]) Do not use a hash join for table.
USE_MERGE(table [...]) Use a merge sort join for table.
NO_USE_MERGE(table [...]) Do not use a merge sort join for table.
USE_NL(table [...]) Use a nested loop join for table.
NO_USE_NL(table [...]) Do not use a nested loop join for table.
Examples
In the following example, the USE_HASH hint is used for a join on the
pgbench_branches and pgbench_accounts tables. The query plan shows that a hash
join is used by creating a hash table from the join attribute of the pgbench_branches
table.
EXPLAIN SELECT /*+ USE_HASH(b) */ b.bid, a.aid, abalance FROM
pgbench_branches b, pgbench_accounts a WHERE b.bid = a.bid;
QUERY PLAN
-----------------------------------------------------------------------------
------
Hash Join (cost=21.45..81463.06 rows=2014215 width=12)
Hash Cond: (a.bid = b.bid)
-> Seq Scan on pgbench_accounts a (cost=0.00..53746.15 rows=2014215
width=12)
-> Hash (cost=21.20..21.20 rows=20 width=4)
-> Seq Scan on pgbench_branches b (cost=0.00..21.20 rows=20
width=4)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 109
Database Compatibility for Oracle® Developers Guide
(5 rows)
Next, the NO_USE_HASH(a b) hint forces the planner to use an approach other than
hash tables. The result is a merge join.
EXPLAIN SELECT /*+ NO_USE_HASH(a b) */ b.bid, a.aid, abalance FROM
pgbench_branches b, pgbench_accounts a WHERE b.bid = a.bid;
QUERY PLAN
-----------------------------------------------------------------------------
------------------
Merge Join (cost=333526.08..368774.94 rows=2014215 width=12)
Merge Cond: (b.bid = a.bid)
-> Sort (cost=21.63..21.68 rows=20 width=4)
Sort Key: b.bid
-> Seq Scan on pgbench_branches b (cost=0.00..21.20 rows=20
width=4)
-> Materialize (cost=333504.45..343575.53 rows=2014215 width=12)
-> Sort (cost=333504.45..338539.99 rows=2014215 width=12)
Sort Key: a.bid
-> Seq Scan on pgbench_accounts a (cost=0.00..53746.15
rows=2014215 width=12)
(9 rows)
Finally, the USE_MERGE hint forces the planner to use a merge join.
EXPLAIN SELECT /*+ USE_MERGE(a) */ b.bid, a.aid, abalance FROM
pgbench_branches b, pgbench_accounts a WHERE b.bid = a.bid;
QUERY PLAN
-----------------------------------------------------------------------------
------------------
Merge Join (cost=333526.08..368774.94 rows=2014215 width=12)
Merge Cond: (b.bid = a.bid)
-> Sort (cost=21.63..21.68 rows=20 width=4)
Sort Key: b.bid
-> Seq Scan on pgbench_branches b (cost=0.00..21.20 rows=20
width=4)
-> Materialize (cost=333504.45..343575.53 rows=2014215 width=12)
-> Sort (cost=333504.45..338539.99 rows=2014215 width=12)
Sort Key: a.bid
-> Seq Scan on pgbench_accounts a (cost=0.00..53746.15
rows=2014215 width=12)
(9 rows)
In this three-table join example, the planner first performs a hash join on the
pgbench_branches and pgbench_history tables, then finally performs a hash join
of the result with the pgbench_accounts table.
EXPLAIN SELECT h.mtime, h.delta, b.bid, a.aid FROM pgbench_history h, pgbench_branches
b, pgbench_accounts a WHERE h.bid = b.bid AND h.aid = a.aid;
QUERY PLAN
---------------------------------------------------------------------------------------
-
Hash Join (cost=86814.29..123103.29 rows=500000 width=20)
Hash Cond: (h.aid = a.aid)
-> Hash Join (cost=21.45..15081.45 rows=500000 width=20)
Hash Cond: (h.bid = b.bid)
-> Seq Scan on pgbench_history h (cost=0.00..8185.00 rows=500000 width=20)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 110
Database Compatibility for Oracle® Developers Guide
-> Hash (cost=21.20..21.20 rows=20 width=4)
-> Seq Scan on pgbench_branches b (cost=0.00..21.20 rows=20 width=4)
-> Hash (cost=53746.15..53746.15 rows=2014215 width=4)
-> Seq Scan on pgbench_accounts a (cost=0.00..53746.15 rows=2014215 width=4)
(9 rows)
This plan is altered by using hints to force a combination of a merge sort join and a hash
join.
EXPLAIN SELECT /*+ USE_MERGE(h b) USE_HASH(a) */ h.mtime, h.delta, b.bid, a.aid FROM
pgbench_history h, pgbench_branches b, pgbench_accounts a WHERE h.bid = b.bid AND h.aid
= a.aid;
QUERY PLAN
---------------------------------------------------------------------------------------
-----------
Hash Join (cost=152583.39..182562.49 rows=500000 width=20)
Hash Cond: (h.aid = a.aid)
-> Merge Join (cost=65790.55..74540.65 rows=500000 width=20)
Merge Cond: (b.bid = h.bid)
-> Sort (cost=21.63..21.68 rows=20 width=4)
Sort Key: b.bid
-> Seq Scan on pgbench_branches b (cost=0.00..21.20 rows=20 width=4)
-> Materialize (cost=65768.92..68268.92 rows=500000 width=20)
-> Sort (cost=65768.92..67018.92 rows=500000 width=20)
Sort Key: h.bid
-> Seq Scan on pgbench_history h (cost=0.00..8185.00 rows=500000
width=20)
-> Hash (cost=53746.15..53746.15 rows=2014215 width=4)
-> Seq Scan on pgbench_accounts a (cost=0.00..53746.15 rows=2014215 width=4)
(13 rows)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 111
Database Compatibility for Oracle® Developers Guide
2.4.5 Global Hints
Thus far, hints have been applied directly to tables that are referenced in the SQL
command. It is also possible to apply hints to tables that appear in a view when the view
is referenced in the SQL command. The hint does not appear in the view, itself, but rather
in the SQL command that references the view.
When specifying a hint that is to apply to a table within a view, the view and table names
are given in dot notation within the hint argument list.
Synopsis
hint(view.table)
Parameters
hint
Any of the hints in Table 2-2 or Table 2-3.
view
The name of the view containing table.
table
The table on which the hint is to be applied.
Examples
A view named, tx, is created from the three-table join of pgbench_history,
pgbench_branches, and pgbench_accounts shown in the final example of Section
2.4.4.
CREATE VIEW tx AS SELECT h.mtime, h.delta, b.bid, a.aid FROM pgbench_history
h, pgbench_branches b, pgbench_accounts a WHERE h.bid = b.bid AND h.aid =
a.aid;
The query plan produced by selecting from this view is show below:
EXPLAIN SELECT * FROM tx;
QUERY PLAN
---------------------------------------------------------------------------------------
-
Hash Join (cost=86814.29..123103.29 rows=500000 width=20)
Hash Cond: (h.aid = a.aid)
-> Hash Join (cost=21.45..15081.45 rows=500000 width=20)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 112
Database Compatibility for Oracle® Developers Guide
Hash Cond: (h.bid = b.bid)
-> Seq Scan on pgbench_history h (cost=0.00..8185.00 rows=500000 width=20)
-> Hash (cost=21.20..21.20 rows=20 width=4)
-> Seq Scan on pgbench_branches b (cost=0.00..21.20 rows=20 width=4)
-> Hash (cost=53746.15..53746.15 rows=2014215 width=4)
-> Seq Scan on pgbench_accounts a (cost=0.00..53746.15 rows=2014215 width=4)
(9 rows)
The same hints that were applied to this join at the end of Section 2.4.4 can be applied to
the view as follows:
EXPLAIN SELECT /*+ USE_MERGE(tx.h tx.b) USE_HASH(tx.a) */ * FROM tx;
QUERY PLAN
---------------------------------------------------------------------------------------
-----------
Hash Join (cost=152583.39..182562.49 rows=500000 width=20)
Hash Cond: (h.aid = a.aid)
-> Merge Join (cost=65790.55..74540.65 rows=500000 width=20)
Merge Cond: (b.bid = h.bid)
-> Sort (cost=21.63..21.68 rows=20 width=4)
Sort Key: b.bid
-> Seq Scan on pgbench_branches b (cost=0.00..21.20 rows=20 width=4)
-> Materialize (cost=65768.92..68268.92 rows=500000 width=20)
-> Sort (cost=65768.92..67018.92 rows=500000 width=20)
Sort Key: h.bid
-> Seq Scan on pgbench_history h (cost=0.00..8185.00 rows=500000
width=20)
-> Hash (cost=53746.15..53746.15 rows=2014215 width=4)
-> Seq Scan on pgbench_accounts a (cost=0.00..53746.15 rows=2014215 width=4)
(13 rows)
In addition to applying hints to tables within stored views, hints can be applied to tables
within subqueries as illustrated by the following example. In this query on the sample
application emp table, employees and their managers are listed by joining the emp table
with a subquery of the emp table identified by the alias, b.
SELECT a.empno, a.ename, b.empno "mgr empno", b.ename "mgr ename" FROM emp a,
(SELECT * FROM emp) b WHERE a.mgr = b.empno;
empno | ename | mgr empno | mgr ename
-------+--------+-----------+-----------
7369 | SMITH | 7902 | FORD
7499 | ALLEN | 7698 | BLAKE
7521 | WARD | 7698 | BLAKE
7566 | JONES | 7839 | KING
7654 | MARTIN | 7698 | BLAKE
7698 | BLAKE | 7839 | KING
7782 | CLARK | 7839 | KING
7788 | SCOTT | 7566 | JONES
7844 | TURNER | 7698 | BLAKE
7876 | ADAMS | 7788 | SCOTT
7900 | JAMES | 7698 | BLAKE
7902 | FORD | 7566 | JONES
7934 | MILLER | 7782 | CLARK
(13 rows)
The plan chosen by the query planner is shown below:
EXPLAIN SELECT a.empno, a.ename, b.empno "mgr empno", b.ename "mgr ename"
FROM emp a, (SELECT * FROM emp) b WHERE a.mgr = b.empno;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 113
Database Compatibility for Oracle® Developers Guide
QUERY PLAN
-----------------------------------------------------------------
Hash Join (cost=1.32..2.64 rows=13 width=22)
Hash Cond: (a.mgr = emp.empno)
-> Seq Scan on emp a (cost=0.00..1.14 rows=14 width=16)
-> Hash (cost=1.14..1.14 rows=14 width=11)
-> Seq Scan on emp (cost=0.00..1.14 rows=14 width=11)
(5 rows)
A hint can be applied to the emp table within the subquery to perform an index scan on
index, emp_pk, instead of a table scan. Note the difference in the query plans.
EXPLAIN SELECT /*+ INDEX(b.emp emp_pk) */ a.empno, a.ename, b.empno "mgr
empno", b.ename "mgr ename" FROM emp a, (SELECT * FROM emp) b WHERE a.mgr =
b.empno;
QUERY PLAN
---------------------------------------------------------------------------
Merge Join (cost=4.17..13.11 rows=13 width=22)
Merge Cond: (a.mgr = emp.empno)
-> Sort (cost=1.41..1.44 rows=14 width=16)
Sort Key: a.mgr
-> Seq Scan on emp a (cost=0.00..1.14 rows=14 width=16)
-> Index Scan using emp_pk on emp (cost=0.14..12.35 rows=14 width=11)
(6 rows)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 114
Database Compatibility for Oracle® Developers Guide
2.4.6 Using the APPEND Optimizer Hint
By default, Advanced Server will add new data into the first available free-space in a
table (vacated by vacuumed records). Include the APPEND directive after an INSERT or
SELECT command to instruct the server to bypass mid-table free space, and affix new
rows to the end of the table. This optimizer hint can be particularly useful when bulk
loading data.
The syntax is:
/*+APPEND*/
For example, the following command, compatible with Oracle databases, instructs the
server to append the data in the INSERT statement to the end of the sales table:
INSERT /*+APPEND*/ INTO sales VALUES
(10, 10, '01-Mar-2011', 10, 'OR');
Note that Advanced Server supports the APPEND hint when adding multiple rows in a
single INSERT statement:
INSERT /*+APPEND*/ INTO sales VALUES
(20, 20, '01-Aug-2011', 20, 'NY'),
(30, 30, '01-Feb-2011', 30, 'FL'),
(40, 40, '01-Nov-2011', 40, 'TX');
The APPEND hint can also be included in the SELECT clause of an INSERT INTO
statement:
INSERT INTO sales_history SELECT /*+APPEND*/ FROM sales;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 115
Database Compatibility for Oracle® Developers Guide
2.4.7 Parallelism Hints
The PARALLEL optimizer hint is used to force parallel scanning.
The NO_PARALLEL optimizer hint prevents usage of a parallel scan.
Synopsis
PARALLEL (table [ parallel_degree | DEFAULT ])
NO_PARALLEL (table)
Description
Parallel scanning is the usage of multiple background workers to simultaneously perform
a scan of a table (that is, in parallel) for a given query. This process provides performance
improvement over other methods such as the sequential scan.
Parameters
table
The table to which the parallel hint is to be applied.
parallel_degree | DEFAULT
parallel_degree is a positive integer that specifies the desired number of
workers to use for a parallel scan. If specified, the lesser of parallel_degree
and configuration parameter max_parallel_workers_per_gather is used as
the planned number of workers. For information on the
max_parallel_workers_per_gather parameter, please see Section 19.4.6
Asynchronous Behavior located in Section 19.4 Resource Consumption in
the PostgreSQL core documentation available at:
https://www.postgresql.org/docs/11/static/runtime-config-resource.html
If DEFAULT is specified, then the maximum possible parallel degree is used.
If both parallel_degree and DEFAULT are omitted, then the query optimizer
determines the parallel degree. In this case, if table has been set with the
parallel_workers storage parameter, then this value is used as the parallel
degree, otherwise the optimizer uses the maximum possible parallel degree as if
DEFAULT was specified. For information on the parallel_workers storage
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 116
Database Compatibility for Oracle® Developers Guide
parameter, please see the Storage Parameters subsection located under
CREATE TABLE in the PostgreSQL core documentation available at:
https://www.postgresql.org/docs/11/static/sql-createtable.html
Regardless of the circumstance, the parallel degree never exceeds the setting of
configuration parameter max_parallel_workers_per_gather.
Examples
The following configuration parameter settings are in effect:
SHOW max_worker_processes;
max_worker_processes
----------------------
8
(1 row)
SHOW max_parallel_workers_per_gather;
max_parallel_workers_per_gather
---------------------------------
2
(1 row)
The following example shows the default scan on table pgbench_accounts. Note that a
sequential scan is shown in the query plan.
SET trace_hints TO on;
EXPLAIN SELECT * FROM pgbench_accounts;
QUERY PLAN
---------------------------------------------------------------------------
Seq Scan on pgbench_accounts (cost=0.00..53746.15 rows=2014215 width=97)
(1 row)
The following example uses the PARALLEL hint. In the query plan, the Gather node,
which launches the background workers, indicates that two workers are planned to be
used.
Note: If trace_hints is set to on, the INFO: [HINTS] lines appear stating that
PARALLEL has been accepted for pgbench_accounts as well as other hint information.
For the remaining examples, these lines will not be displayed as they generally show the
same output (that is, trace_hints has been reset to off).
EXPLAIN SELECT /*+ PARALLEL(pgbench_accounts) */ * FROM pgbench_accounts;
INFO: [HINTS] SeqScan of [pgbench_accounts] rejected due to PARALLEL hint.
INFO: [HINTS] PARALLEL on [pgbench_accounts] accepted.
INFO: [HINTS] Index Scan of [pgbench_accounts].[pgbench_accounts_pkey]
rejected due to PARALLEL hint.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 117
Database Compatibility for Oracle® Developers Guide
QUERY PLAN
-----------------------------------------------------------------------------
------------
Gather (cost=1000.00..244418.06 rows=2014215 width=97)
Workers Planned: 2
-> Parallel Seq Scan on pgbench_accounts (cost=0.00..41996.56
rows=839256 width=97)
(3 rows)
Now, the max_parallel_workers_per_gather setting is increased:
SET max_parallel_workers_per_gather TO 6;
SHOW max_parallel_workers_per_gather;
max_parallel_workers_per_gather
---------------------------------
6
(1 row)
The same query on pgbench_accounts is issued again with no parallel degree
specification in the PARALLEL hint. Note that the number of planned workers has
increased to 4 as determined by the optimizer.
EXPLAIN SELECT /*+ PARALLEL(pgbench_accounts) */ * FROM pgbench_accounts;
QUERY PLAN
-----------------------------------------------------------------------------
------------
Gather (cost=1000.00..241061.04 rows=2014215 width=97)
Workers Planned: 4
-> Parallel Seq Scan on pgbench_accounts (cost=0.00..38639.54
rows=503554 width=97)
(3 rows)