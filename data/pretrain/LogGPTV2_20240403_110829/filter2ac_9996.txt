title:Exploiting Software
author:Gary McGraw
Exploiting Software:
How to Break Code
Gary McGraw, Ph.D.
CTO, Cigital
http://www.cigital.com
© 2004 Cigital
Pop quiz
(cid:132) What do wireless devices, cell phones, PDAs, 
browsers, operating systems, servers, personal 
computers, public key infrastructure systems, and 
firewalls have in common?
Software
© 2004 Cigital 
So what’s the problem?
© 2004 Cigital
Commercial security is reactive
(cid:132) Defend the perimeter with a 
firewall
(cid:132) To keep stuff out
(cid:132) Over-rely on crypto
(cid:132) “We use SSL”
(cid:132) “Review” products when 
they’re done
(cid:132) Why your code is bad
(cid:132) Promulgate “penetrate and 
patch”
(cid:132) Disallow advanced 
technologies
(cid:132) Extensible systems (Java 
and .NET) are dangerous
The “ops guy with keys” does 
not really understand software 
development.
© 2004 Cigital 
(cid:132) Most security people are 
operations people
(cid:132) Network administrators
(cid:132) Firewall rules 
manipulators
(cid:132) COTS products 
glommers
(cid:132) These people need 
training
Security means different 
things to different people
Builders versus operators
(cid:132) Most builders are not 
security people
(cid:132) Software development 
remains a black art
(cid:132) How well are we doing 
teaching students to 
engineer code?
(cid:132) Emergent properties like 
security are hard for 
builders to grok
(cid:132) These people need 
academic education
© 2004 Cigital 
Making software behave is hard
(cid:132) Can you test in quality?
(cid:132) How do you find (adaptive) bugs in code?
(cid:132) What about bad guys doing evil on purpose?
(cid:132) What’s the difference between security testing and 
functional testing?
(cid:132) How can you teach security design?
(cid:132) How can you codify non-functional, emergent 
requirements like security?
(cid:132) Can you measure security?
© 2004 Cigital 
Attaining software security is even harder
The Trinity of Trouble
(cid:132) Connectivity
(cid:132) The Internet is everywhere 
and most software is on it
(cid:132) Complexity
(cid:132) Networked, distributed, 
mobile code is hard
(cid:132) Extensibility
(cid:132) Systems evolve in 
unexpected ways and are 
changed on the fly
The network is 
the computer.
This simple interface…
…is this complex program
.NET
© 2004 Cigital 
Software complexity growth
Windows Complexity
45
40
35
30
25
20
15
10
5
0
Win
3.1
(1990)
Win
NT
(1995)
Win 95
(1997)
NT 4.0
(1998)
Win 98
(1999)
NT 5.0
(2000)
XP
(2002)
Win
2K
(2001)
© 2004 Cigital 
i
s
e
n
L
f
o
s
n
o
i
l
l
i
M
Software vulnerability growth
© 2004 Cigital 
Normalized (and slightly shifted) data from Geer
© 2004 Cigital 
Science please
(cid:132) Basic understanding of complexity and its impact on 
security problems is sorely needed
(cid:132) Do the LOC and vulnerability graphs really 
correlate?
(cid:132) What are software security problems really like?
(cid:132) How common are basic categories?
(cid:132) How can we teach students something that now 
takes years of fieldwork to merely intuitively 
grasp? 
© 2004 Cigital 
Who is the bad guy?
(cid:132) Hackers
(cid:132) “Full disclosure” zealots
(cid:132) “Script kiddies”
(cid:132) Criminals
(cid:132) Lone guns or organized
(cid:132) Malicious insiders
(cid:132) Compiler wielders
(cid:132) Business competition
(cid:132) Police, press, terrorists, intelligence agencies
© 2004 Cigital 
History is quirky
1995
(cid:132) Dan Geer fired from Silicon 
Graphics for releasing 
SATAN with Wietse
Venema
(cid:132) FUD: possible attack tool!
Fall 2004
(cid:132) John Aycock at University of 
Calgary publicly criticized 
for malware course
(cid:132) FUD: possible bad guy 
factory
2004
(cid:132) Any system administrator 
not using a port scanner to 
check security posture runs 
the risk of being fired
Should we talk about 
attacking systems?
© 2004 Cigital 
The good news and the bad news
Good news
Bad news
(cid:132) The world loves to talk 
about how stuff breaks
(cid:132) This kind of work 
sparks lots of interest in 
computer security
(cid:132) The world would rather 
not focus on how to 
build stuff that does not 
break
(cid:132) It’s harder to build good 
stuff than to break 
junky stuff
© 2004 Cigital 
Know your enemy: How stuff 
breaks
© 2004 Cigital
Security problems are complicated
IMPLEMENTATION BUGS
ARCHITECTURAL FLAWS
(cid:132) Buffer overflow
(cid:132) String format
(cid:132) One-stage attacks
(cid:132) Race conditions
(cid:132) TOCTOU (time of check to 
time of use)
(cid:132) Unsafe environment variables
(cid:132) Unsafe system calls 
(cid:132) System()
(cid:132) Untrusted input problems
(cid:132) Misuse of cryptography
(cid:132) Compartmentalization 
problems in design
(cid:132) Privileged block protection 
failure (DoPrivilege())
(cid:132) Catastrophic security failure 
(fragility)
(cid:132) Type safety confusion error
(cid:132) Insecure auditing
(cid:132) Broken or illogical access 
control (RBAC over tiers)
(cid:132) Method over-riding problems 
(subclass issues)
(cid:132) Signing too much code
© 2004 Cigital 
Attackers do not distinguish bugs and flaws
(cid:132) Both bugs and flaws 
lead to vulnerabilities 
that can be exploited
(cid:132) Attackers write code to 
break code
(cid:132) Defenders are network 
operations people
(cid:132) Code?!  What code?
© 2004 Cigital 
The attacker’s toolkit
(cid:132) The standard attacker’s toolkit has lots of (software 
analysis) stuff
(cid:132) Disassemblers and decompilers
(cid:132) Control flow and coverage tools
(cid:132) APISPY32
(cid:132) Breakpoint setters and monitors
(cid:132) Buffer overflow
(cid:132) Shell code
(cid:132) Rootkits
© 2004 Cigital 
Attacker’s toolkit: dissasemblers and decompilers
(cid:132) Source code is not a necessity for software exploit
(cid:132) Binary is just as easy to understand as source code
(cid:132) Disassemblers and decompilers are essential tools
(cid:132) Reverse engineering is common and must be 
understood (not outlawed)
(cid:132) IDA allows plugins to be created
(cid:132) Use bulk auditing
© 2004 Cigital 
Attacker’s toolkit: control flow and coverage
(cid:132) Tracing input as it flows through 
software is an excellent method
(cid:132) Exploiting differences between 
versions is also common
(cid:132) Code coverage tools help you 
know where you have gotten in a 
program
(cid:132) dyninstAPI (Maryland)
(cid:132) Figure out how to get to 
particular system calls
(cid:132) Look for data in shared buffers
© 2004 Cigital 
Attacker’s toolkit: buffer overflow foo
(cid:132) Find targets with static analysis
(cid:132) Change program control flow
(cid:132) Trampolining past a canary
(cid:132) Heap attacks
(cid:132) Stack smashing
(cid:132) Trampolining
(cid:132) Arc injection
(cid:132) Particular examples
(cid:132) Overflow binary resource files 
(used against Netscape)
(cid:132) Overflow variables and tags 
(Yamaha MidiPlug)
(cid:132) MIME conversion fun 
(Sendmail)
(cid:132) HTTP cookies (apache)
Function arguments
Return Address
Canary Value
Frame Pointer
Local Variable: Buffer A
Local Variable: Pointer A
Local Variable: Buffer B
© 2004 Cigital 
Attacker’s toolkit: shell code and other payloads
(cid:132) Common payloads in buffer overflow 
attacks
(cid:132) Size matters (small is critical)
(cid:132) Avoid zeros
(cid:132) XOR protection (also simple crypto)
(cid:132) Payloads exist for
(cid:132) X86 (win32)
(cid:132) RISC (MIPS and sparc)
(cid:132) Multiplatform payloads
© 2004 Cigital 
(cid:132) The apex of software exploit…complete control of 
Attacker’s toolkit: rootkits
the machine
(cid:132) Live in the kernel
(cid:132) XP kernel rootkit in the book
(cid:132) See http://www.rootkit.com
(cid:132) Hide files and directories by controlling access to 
process tables
(cid:132) Provide control and access over the network
(cid:132) Get into the EEPROM (hardware viruses)
© 2004 Cigital 
Attacker’s toolkit: other miscellaneous tools
(cid:132) Debuggers (user-mode)
(cid:132) Kernel debuggers
(cid:132) SoftIce
(cid:132) Fault injection tools
(cid:132) FUZZ
(cid:132) Failure simulation tool
(cid:132) Hailstorm
(cid:132) Holodeck
(cid:132) Boron tagging
(cid:132) The “depends” tool
(cid:132) Grammar rewriters
© 2004 Cigital 
(cid:132) The standard process
(cid:132) Scan network
(cid:132) Build a network map
(cid:132) Pick target system
(cid:132) Identify OS stack
(cid:132) Port scan
(cid:132) Determine target 
components
(cid:132) Choose attack patterns
(cid:132) Break software
(cid:132) Plant backdoor
How attacks unfold
(cid:132) Attacking a software system is 
a process of discovery and 
exploration
(cid:132) Qualify target (focus on 
input points)
(cid:132) Determine what 
transactions the input 
points allow
(cid:132) Apply relevant attack 
(cid:132) Cycle through observation 
patterns
loop
(cid:132) Find vulnerability
(cid:132) Build an exploit
© 2004 Cigital 
Knowledge: 48 Attack Patterns
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
Make the Client Invisible
Target Programs That Write to Privileged OS Resources 
Use a User-Supplied Configuration File to Run 
Commands That Elevate Privilege 
Make Use of Configuration File Search Paths 
Direct Access to Executable Files 
Embedding Scripts within Scripts 
Leverage Executable Code in Nonexecutable Files 
Argument Injection 
Command Delimiters 
Multiple Parsers and Double Escapes 
User-Supplied Variable Passed to File System Calls 
Postfix NULL Terminator 
Postfix, Null Terminate, and Backslash 
Relative Path Traversal 
Client-Controlled Environment Variables 
User-Supplied Global Variables (DEBUG=1, PHP 
Globals, and So Forth) 
Session ID, Resource ID, and Blind Trust
Analog In-Band Switching Signals (aka “Blue Boxing”) 
Attack Pattern Fragment: Manipulating Terminal Devices 
Simple Script Injection 
Embedding Script in Nonscript Elements 
XSS in HTTP Headers 
HTTP Query Strings 
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
(cid:132)
User-Controlled Filename 
Passing Local Filenames to Functions That Expect a 
URL 
Meta-characters in E-mail Header
File System Function Injection, Content Based
Client-side Injection, Buffer Overflow
Cause Web Server Misclassification
Alternate Encoding the Leading Ghost Characters
Using Slashes in Alternate Encoding
Using Escaped Slashes in Alternate Encoding 
Unicode Encoding 
UTF-8 Encoding 
URL Encoding 
Alternative IP Addresses 
Slashes and URL Encoding Combined 
Web Logs 
Overflow Binary Resource File 
Overflow Variables and Tags 
Overflow Symbolic Links 
MIME Conversion 
HTTP Cookies 
Filter Failure through Buffer Overflow 
Buffer Overflow with Environment Variables 
Buffer Overflow in an API Call 
Buffer Overflow in Local Command-Line Utilities 
Parameter Expansion 
String Format Overflow in syslog() 
© 2004 Cigital 
(cid:132) Remove the client from the 
communications loop and 
talk directly to the server
(cid:132) Leverage incorrect trust 
model (never trust the 
client)
(cid:132) Example: hacking browsers 
that lie (opera cookie foo)
Attack pattern 1: 
Make the client invisible
© 2004 Cigital 
Breaking stuff is important
(cid:132) Learning how to think like 
an attacker is essential
(cid:132) Do not shy away from 
teaching attacks
(cid:132) Engineers learn from 
stories of failure
(cid:132) Attacking group projects can 
be the most fun part of a 
course
(cid:132) Fun is good!  Software 
engineering is too boring!
© 2004 Cigital 
Great, now what do we 
do about this?
© 2004 Cigital
Software security critical lessons
(cid:132) Software security is more than a set of security 
functions
(cid:132) Not magic crypto fairy dust
(cid:132) Not silver-bullet security mechanisms
(cid:132) Not application of very simple tools
(cid:132) Non-functional aspects of design are essential
(cid:132) Security is an emergent property of the entire 
system (just like quality)
(cid:132) To end up with secure software, deep integration 
with the SDLC is necessary
© 2004 Cigital 
Ten guiding principles for secure design
1. Secure the weakest link
2. Practice defense in depth
3. Fail securely
4. Follow the principle of least 
privilege
5. Compartmentalize
Keep it simple
Promote privacy
–
–
– Remember that hiding 
resources
secrets is hard
Be reluctant to trust
–
– Use your community 
© 2004 Cigital 
The antidote: Software security in the SDLC 
Security
requirements
External
review
Abuse
cases
Risk
analysis
Risk-based
security tests
Static
analysis
(tools)
Penetration
testing
Risk
analysis
Security
breaks
Requirements
and use cases
Design
Test plans
Code
Test
results
Field
feedback
© 2004 Cigital 
Software security best practices
(cid:132) Security best practices 
should be applied 
throughout the dev lifecycle
(cid:132) Tendency is to “start right” 
(penetration testing) and 
declare victory
(cid:132) Not cost effective
(cid:132) Hard to fix problems
(cid:132) Start as early as possible
(cid:132) Abuse cases
(cid:132) Security requirements 
analysis
(cid:132) Architectural risk analysis
(cid:132) Risk analysis at design
(cid:132) External review
(cid:132) Test planning based on 
risks
(cid:132) Security testing (malicious 
tests)
(cid:132) Code review with static 
analysis tools
© 2004 Cigital 
Where to learn more
© 2004 Cigital
IEEE Security & Privacy Magazine
(cid:132) See the department on Software 
Security best practices called 
“Building Security In”
(cid:132) Also see this month’s special 
issue on breaking stuff
http://www.computer.org
http://
www.computer.org/security
/security
© 2004 Cigital 
(cid:132) Cigital’s Software Security Group 
invents and practices Software 
Quality Management 
(cid:132) WE NEED PEOPLE
(cid:132) http://www.cigital.com/presentations/
exploit04
(cid:132) Use Exploiting Software and Building 
Secure Software
(cid:132) Send e-mail: 
PI:EMAIL
Pointers
© 2004 Cigital