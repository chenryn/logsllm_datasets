noted as OBU 1, 2, and 3 respectively, OBU 1 and 2 are used
as victim CV devices, and OBU 3 is used as the attack device.
To control the experiments, we connect a laptop with three
OBUs via Ethernet connections.
Figure 8: Testbed setup for attack validation.
The Cohda OBU that we use in our experiments is an
ARM embedded device running Ubuntu 16.04. It implements
the latest version of the CV network stack, which conforms
with IEEE 802.11p [37, 38], IEEE 1609-2016 [32–34], and
SAE J2735-2016 [20]. Notably, the implementation of IEEE
1609.2, called Aerolink, is developed by OnBoard Secu-
rity [52] and closed source.
Victim OBU setup. To implement the CV communication
model, both victim OBUs run a simple program that period-
ically broadcasts a correctly-signed SPDU. This broadcast-
based communication also allows the attacker to observe all
network trafﬁc. For P2PCD, we place random data in the
SPDU. For PMP, the SPDU stands for the beacon message,
which contains the platoon ID and depth. Besides, both OBUs
run PMP programs that are extracted from the source codes
of VENTOS [69] and PLEXE [56].
For two different protocols (i.e., P2PCD, PMP), we assign
different roles to OBU 1 and 2. In P2PCD attacks (i.e., N1-4),
following the same assumption in §5.1, OBU 2 cannot verify
packets sent by OBU 1 due to a missing certiﬁcate, so OBU
2 wants to initialize P2PCD to learn the unknown certiﬁcate
from OBU 1. In PMP attacks (i.e., A1-15), by default, OBU
1 and 2 belong to the same platoon. OBU 1 and 2 are the
platoon leader and the platoon follower respectively.
Tool preparation. To launch the attacks, we need to pre-
pare tools that allow us to (1) parse and construct arbitrary
packets and certiﬁcates, and (2) sign and verify CV network
packets correctly. For (1), we use asn1c [71] to extract C data
structures used by CV network services from ASN.1 modules
in protocol speciﬁcations, and port platoon message types
from the source codes of VENTOS and PLEXE. For (2), we
follow IEEE 1609.2 to implement the signing and veriﬁca-
tion functionalities. We start from ECDSA APIs provided by
OpenSSL 1.1.0j [53]. The elliptic curve and the hash func-
tion that we use with ECDSA is NIST P-256 and SHA-256,
respectively. We cross-validate the correctness of our tools
using APIs of Cohda CV network stack. The Cohda CV net-
work stack can process packets and certiﬁcates generated by
our tool without throwing any errors.
Certiﬁcate conﬁgurations. As N1-4 require triggering
P2PCD, we need to conﬁgure the pre-installed certiﬁcates
in both victim OBUs to ensure that OBU 2 cannot construct
a certiﬁcate chain while verifying packets sent by OBU 1.
Both OBU 1 and 2 can correctly verify packets from OBU 3
USENIX Association
30th USENIX Security Symposium    3229
OBU 3AttackerOBU 1OBU 2Ethernet connectionsVictim CV devicesControllerOBUAntenna(attacker). First, we use our certiﬁcate generator to construct
a Root CV certiﬁcate, referred as root, which is trusted by
all three OBUs. Then, we use root to issue two interme-
diate Certiﬁcate Authority (CA) certiﬁcates: ca1 and ca2.
We add both ca1 and ca2 to the local certiﬁcate database
of OBU 1, but only add ca2 to the database of OBU 2. To
generate end-entity certiﬁcates for signing packets, we utilize
ieeeAcfGenerator in Cohda SDK to issue two batches of
certiﬁcates: batch1 for OBU 1 and batch2 for OBU 2. Each
batch is an Aerolink-speciﬁc ﬁle and contains 20 end-entities
certiﬁcates. Besides, we use ca2 to issue another end-entity
certiﬁcate ee3 for the attacker so that OBU 1&2 can construct
a valid certiﬁcate chain for packets sent by the attacker.
Apart from generating these normal certiﬁcates, we also
need to construct certiﬁcates that can cause hash collisions.
In N1 and N2, the ﬁrst certiﬁcate in the malicious learning
response should match with the low-order 3-byte and 8-byte
hash value of the unknown certiﬁcate respectively. We there-
fore use our certiﬁcate generator to construct two CA cer-
tiﬁcates: ca1-h3 and ca1-h8, which can lead to 3-byte and
8-byte hash collision with ca1.
Attack programs. Following the attack processes in §5,
we implement different attack programs. For each attack pro-
gram, we set the start condition and the fail condition. The
attack programs will stop only if the fail conditions are satis-
ﬁed; otherwise, they will keep running. For P2PCD attacks,
the attack fails if she observes any learning response from
OBU 1. For example, the attack program for N1 will send ma-
licious learning responses after observing a learning request
sent by OBU 2 (i.e., Vehicle 2 in Figure 5). If it observes
a learning response sent by OBU 1, the program will stop,
which means that the attack fails. For PMP attacks, the attack
fails if the victim platoon member can still ﬁnish the merge,
split, leave, or dissolve maneuver.
6.1.2 Validation Results
In the real-world experiments, we ﬁnd that all attacks from
P2PCD and PMP are successfully validated. Interestingly, we
further ﬁnd that some implementation details in Aerolink
can actually make P2PCD attacks, N1 and N2, even easier
and even block the CV communication indeﬁnitely.
First, we observe that N1 and N2 can indeﬁnitely block the
P2PCD learning process. Based on our model-checking ﬁnd-
ings in §5.1, once the adversary stops sending malicious learn-
ing responses, the victim devices should eventually be able to
recover from DoS. However, in our real-world experiments,
we ﬁnd that even after the attack program terminates, OBU 2
still cannot learn the correct unknown certiﬁcate from OBU 1.
After analyzing the execution log, we ﬁnd that OBU 1 keeps
sending the fake certiﬁcate (i.e., ca1-h3), while OBU 2 sends
learning requests for the unknown certiﬁcate ca1 to OBU 1.
By design, a CV device responds to an incoming learning
request only if the learning request ﬁeld matches with a sign-
ing certiﬁcate which is recently used by that device. With the
help of a binary disassembler called Hopper [11], we ﬁnd that
Aerolink actually does not check whether the certiﬁcate used
for a learning response is indeed a recently used certiﬁcate.
For example, in N1, OBU 1 stores the fake certiﬁcate (i.e.,
ca1-h3) carried by the malicious learning response from the
attacker. Thus, during the preparation of the future learning
response, OBU 1 has two candidates, ca1 and ca1-h3, as
they have the same low-order three-byte hash. When receiv-
ing learning requests, OBU 1 always picks ca1-h3 and sends
it to OBU 2, which thus permanently prevents OBU 2 to learn
the correct certiﬁcate.
Second, to launch N1, we ﬁnd that the attacker only needs
to send 3 malicious learning responses instead of 4. Be-
fore running real-world experiments, we ﬁrst measure the
response threshold in Aerolink, and ﬁnd that the threshold
set in Aerolink is actually 2 instead of 3 in the protocol speci-
ﬁcations. This ﬁnding is also conﬁrmed using Hopper. In this
case, the attacker only needs to send 3 malicious responses
to succeed. Although this may not be a big improvement for
the attacker, it still uncovers an implementation choice in
Aerolink that is unexpectedly favorable to the attacker.
Third, we ﬁnd that N2 only requires 3-byte hash collision
rather 8-byte hash collision, which largely lowers the bar of
launching N2. In P2PCD, by design, a CV device records an
unknown certiﬁcate by adding the identity of that certiﬁcate
(i.e., an 8-byte hash value) into a queue. If the 8-byte hash
of a certiﬁcate in an incoming learning response matches
with any entries in the queue, that entry will be removed. To
launch N2, the attacker has to intentionally cause the 8-byte
hash collision to let the victim CV device wrongly remove an
entry in the queue. However, according to our binary analysis
through Hopper, we ﬁnd that Aerolink actually uses a 3-byte
hash of the unknown certiﬁcate to record its status. Therefore,
in our real-world experiments, we use ca1-h3 in N2, and the
results further validates this ﬁnding. Later in §7, we will show
why this small truncated hash (e.g., 3-byte hash) is not secure
enough. Although the protocol speciﬁcation does not clearly
state how to record unknown certiﬁcates, Annex D in IEEE
1609.2 [32] gives an example of P2PCD implementation that
uses the 8-byte hash as the identity to record the unknown
certiﬁcate. Also, while recording the unknown certiﬁcate, the
most complete identity about the unknown certiﬁcate is the 8-
byte hash value. A CV network implementation should always
use complete information rather than truncated information.
6.2 RQ2: Attack Impact
The following two case studies demonstrate the impact of
identiﬁed attacks: (1) P2PCD attacks can lead to trafﬁc ac-
cidents, which eliminates the beneﬁts of V2V safety appli-
cations (e.g., Forward Collision Warning (FCW)); (2) PMP
attacks can affect the speed stability of the victim vehicle.
Simulator setup. To evaluate the impact of identiﬁed at-
tacks, we use a simulator, VENTOS (VEhicular NeTwork
Open Simulator) [69], so that we can demonstrate the driv-
3230    30th USENIX Security Symposium
USENIX Association
(a) No collision, FCW
(b) Collision
Figure 9: Relative distance between the leading vehicle (V1)
and the following vehicle (V2).
ing behavior under attacks. VENTOS is built upon SUMO
road trafﬁc simulator [62] and OMNeT++ [51]/Veins [61, 68]
network simulator. These simulators [51, 62, 68] have been
widely used in academia, industry, and the government. We
conﬁgure it to use the models for the IEEE 802.11p [37] proto-
col for CV communication. Based on our reverse engineering
and study on Aerolink (§ 6.1), we port the digital signature
and P2PCD in IEEE 1609.2 to the simulator to secure BSMs
and PMP commands. All secured packets are then transmit-
ted through Wave Short Message Protocol (WSMP) and are
directly sent to the data-link layer which uses continuous
channel access based on IEEE 1609.4 [33].
Table 5: Vehicle parameters in the rear-end collision scenario.
Vehicles
Initial Speed Max. Speed Max. Decel.
Leader (V1)
Follower (V2)
30 m/s
20 m/s
30 m/s
30 m/s
5 m/s2
2 m/s2
Length
10 m
5 m
6.2.1 Safety Impact
By design, the CV safety application promises to increase
personal safety [63]. However, our experiment results show
that P2PCD attacks can fully eliminate the beneﬁts of CV ap-
plications (e.g., Forward Collision Warning (FCW)), violating
the original goal of CV applications.
Rear-end collision scenario w/ FCW. We ﬁrst set up a
rear-end collision scenario and demonstrate that vehicles with
Forward Collision Warning (FCW), a V2V safety application,
can avoid the accident (Figure 9a). The rear-end collision sce-
nario includes a leading vehicle (V1) and a following vehicle
(V2) with the initial parameters in Table 5. FCW alerts the
driver in order to help avoid the severity of crashes into the
rear end of other vehicles on the road [63]. We follow the
FCW’s design in Cohda SDK to actively monitor the distance
between two vehicles. Once the distance is smaller than the
safe distance, FCW will warn the driver. As FCW does not
directly control the vehicle, after receiving FCW warnings,
we ask the simulated vehicle to maintain a safe speed. No-
tably, we leverage Krauss car-following model [40], which is
collision-free, to calculate the safe distance and safe speed.
During the simulation, both vehicles drive in the same lane.
By exchanging BSMs, they can monitor each other’s speed,
position, and acceleration. The initial distance between two
vehicles is 30 m, which is smaller than the safe distance at
that time, thus triggering FCW. After starting the simulation
(a) Before attack
(b) After attack
Figure 10: Speed proﬁles in A3 (split trigger attack).
for 10 s, V1 suddenly stops at the maximum deceleration
(i.e., 5 m/s2). Figure 9a shows that, before 10 s, V2 keeps
increasing the distance to the leading vehicle due to the FCW.
Therefore, after the leading vehicle suddenly decelerates, V2
has enough space to slow down safely.
Vehicles w/ FCW under attacks. Then, we place an at-
tacker on the roadside who follows § 5.1 to launch P2PCD
attacks and aims at causing trafﬁc accidents, leading to a rear-
end collision shown in Figure 9b. At the beginning of the
simulation, both vehicles launch P2PCD to exchange certiﬁ-
cates so that they can verify and process following BSMs.
However, P2PCD attacks prevent them from learning certiﬁ-
cates, meaning that they cannot process any BSMs from the
peer vehicle. During the simulation, we observe that FCW
is never triggered, so V2 accelerates to the maximum speed
and follow V1. At 10 s, V1 starts decelerating at the maximum
deceleration (i.e., 5 m/s2). Since two vehicles are too close to
each other (i.e., 54 m), and the maximum deceleration of the
V2 is 2 m/s2, V2 eventually collides into the rear end of V1.
6.2.2 Trafﬁc Efﬁciency Impact
By design, CACC aims at increase trafﬁc throughput and im-
prove trafﬁc ﬂow stability [46, 57, 72]. However, A3 and A4
can interfere with the trafﬁc ﬂow stability, even without sacri-
ﬁcing her own speed stability, which violates the design goals
of CACC. We place V1, the attacker, and V2 sequentially in
the same lane and follow the attack steps of A3 to run the sim-
ulation for 100 seconds. Figure 10 presents the speed proﬁles
of V2, the victim platoon. In the normal case (Figure 10a),
all vehicles will eventually reach a stable speed of 20 m/s;
after launching the attack starting around time 27 seconds, we
increase the standard deviation of V2’s speed by 43%, further
disturbing the following trafﬁc.
6.3 RQ3: Performance of CVAnalyzer
Table 6 presents the runtime performance of CVAnalyzer. We
run CVAnalyzer on a server with four 2.60GHz (8-core) CPUs
and 128G memory. CVAnalyzer ﬁrst explores all reachable
states and then veriﬁes given properties. Notably, without
applying the state reduction, these two model checking tasks
will take too long to explore reachable states. The results
highlight the importance and effectiveness of state reduction.
USENIX Association
30th USENIX Security Symposium    3231
Table 6: Runtime statistics of CVAnalyzer.
Attacks
Distinct States Model Checking Duration
P2PCD
PMP
2209351
142133161
1h 35min
16s
7 Defense Proposals
Based on the discussions from previous sections, we propose
defense solutions at the protocol design level:
1. Mandate veriﬁcation for all learning responses;
2. Increase the truncated hash size for the issuer ﬁeld in the
certiﬁcate and the learning request ﬁeld in SPDU;
3. Disallow unicast learning requests;
4. Bind the sender identity with the CV certiﬁcate;
5. Track platoon conﬁguration data locally or remotely;
6. Design and integrate an error recovery mechanism.
Defense against N1 and N2. Solution 1 and 2 are proposed