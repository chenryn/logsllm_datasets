*priv-safe
if (*AM-sec(Sâ€², ğ‘–â€²)) âˆ¨ AM[Sâ€², ğ‘–â€², R] = received
if âˆ€(S, ğ‘–) : (S, ğ‘–) âˆˆ Chall =â‡’ *FS-sec(S, ğ‘–)
return false
return true
Figure 15: The main oracles of the FS-GAEAD security game.
Oracle inj-AM can be used by A to inject any non-honestly gen-
erated AD/ciphertext pair. Algorithm Rcv must reject all such pairs
unless they are compromised, which is the case if A has learned the
corresponding key material via state compromise. Whether or not
this is the case is determined by the safety helper function *FS-sec,
which is discussed below. Irrespective of whether a compromise
has occurred, Rcv is required to detect and prevent replays.
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1481Corruption. By calling oracle corr(ID) the attacker can learn the cur-
rent state of party ID. The game adds the triple (ID, AM-Rcvd, AM-Tr[ID])
to the set AM-Lk to indicate that IDâ€™s state is now compromised,
but the messages recorded in AM-Rcvd are supposed to remain
secure (because the corresponding key material must have been
deleted); the game also adds potential trash, AM-Tr[ID], stored by
ID to the same set.
B.2.2 Privacy-related safety. At the end of the execution of the FS-
GAEAD security game, the procedure *priv-safe ensures that the
attacker has only challenged messages that are considered secure
by the (generic) safety predicate *FS-sec. If the condition is not
satisfied, the attacker loses the game.
B.2.3 Advantage. Let Î  = *FS-sec be the generic safety predicate
used in the FS-GAEAD definition. The attacker A is parameter-
ized by itâ€™s running time ğ‘¡ and the number of challenge queries
ğ‘, referred to as (ğ‘¡, ğ‘)-attacker. The advantage of A against an FS-
GAEAD scheme F w.r.t. to predicate Î  is denoted by AdvFSfs,Î (A).
Definition B.1. An FS-GAEAD scheme F is (ğ‘¡, ğ‘, ğœ€)-secure w.r.t.
predicate Î , if for all (ğ‘¡, ğ‘)-attackers,
AdvF
FS-GAEAD,Î (A) â‰¤ ğœ€ .
C PRF-PRNGS
C.1 Syntax
A PRF-PNRG PP is an algorithm (ğœâ€², ğ‘…) â† PP(ğœ, ğ¼, ğ¶): it takes the
current state ğœ, absorbs input ğ¼ along with context information ğ¶,
and produces a new state ğœâ€² as well as an output string ğ‘….
C.2 Security
A PRF-PRNG must satisfy PCFS (cf. Section 3.2) and be resilient to
splitting-attacks. Therefore, the security game for PRF-PRNGs (cf.
Figure 16) follows the same history-graph approach as the defini-
tions of SGM and CKGA. However, since the game only consists of
the state of the PRF-PRNG and there are no parties, it suffices to
keep track of a much smaller amount information:
â€¢ Nodes of the history graph only consist of the vid.
â€¢ For every node vid,
â€“ the value ğœ[vid] stores the corresponding state of the PRF-
PRNG,
â€“ the value ğ‘…[vid] stores the corresponding output of the
PRF-PRNG, and
â€“ the value BI[vid] is a flag indicating whether the input ğ¼
absorbed to reach the state ğœ[vid] is known to the attacker.
â€¢ The set V-Lk records the vids for which the PRF-PRNG state
is leaked to the attacker.
The root node vidroot of the history graph corresponds to the initial
state of the PRF-PRNG, which is assumed to be the all-zero string.
The attacker A has the following capabilities:
â€¢ He may create a new child state of any node vid by calling
oracle process and specifying an input/context pair (ğ¼, ğ¶); of
course, only one such call per triple (vid, ğ¼, ğ¶) is allowed. If
init
corr (vid)
ğ‘ â†R {0, 1}
vidroot â† HG.init
ğœ[vidroot] â† 0
V-Lk â† âˆ…
ğ‘…[Â·] â† âˆ…
Reveal[Â·] â† âˆ…
Chall[Â·] â† âˆ…
BI[Â·] â† âˆ…
V-Lk +â† vid
return ğœ[vid]
process(vid, ğ¼, ğ¶)
req Ì¸âˆƒ child of vid for (ğ¼, ğ¶)
vidâ€² â† HG.create(vid, ğ¼)
BI[vidâ€²] â† (ğ¼ Ì¸= âŠ¥)
(ğœ[vidâ€²], ğ‘…[vidâ€²]) â† PP(ğœ[vid], ğ¼, ğ¶)
return vidâ€²
req ğ‘…[vid] Ì¸= ğœ€
req Â¬(Reveal[vid] âˆ¨ Chall[vid])
Reveal[vid] â† true
return ğ‘…[vid]
req ğ‘…[vid] Ì¸= ğœ€
req Â¬(Reveal[vid] âˆ¨ Chall[vid])
ğ‘…0 â† ğ‘…[vid]
ğ‘…1 â† R
Chall[vid] â† true
return ğ‘…ğ‘
return âˆ€vid : Chall[vid] =â‡’ *PP-secure(vid)
Figure 16: PRF-PRNG security game.
reveal(vid)
chall(vid)
safe
the call is made with ğ¼ Ì¸= âŠ¥, the game samples ğ¼ it randomly.
The value BI[vid] is set accordingly.
â€¢ He may reveal or challenge outputs ğ‘…[vid] corresponding to
arbitrary nodes vid Ì¸= vidroot by calling the corresponding
oracles reveal and chall, respectively. The flags Reveal[vid]
resp. store Chall[vid] whether a reveal resp. a challenge has
been requested for vid.
â€¢ Finally, A can also leak the state ğœ[vid] for any epoch vid Ì¸=
vidroot using oracle corr.
As per usual, at the end of the game, the oracle safe ensures that A
does not win the game trivially; safe uses a generic safety predicate
*PP-secure.
C.2.1 Advantage. Let Î  = *PP-secure be the generic safety predi-
cate used in the PRF-PRNG definition. The attacker A is parameter-
ized by itâ€™s running time ğ‘¡, referred to as ğ‘¡-attacker. The advantage
of A against a PP scheme PRF-PRNG w.r.t. to predicate Î  is denoted
by AdvPP
PRF-PRNG,Î (A).
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1482Definition C.1. A PRF-PRNG scheme PP is (ğ‘¡, ğœ€)-secure w.r.t. pred-
icate Î , if for all ğ‘¡-attackers,
AdvPP
PRF-PRNG,Î (A) â‰¤ ğœ€ .
D SECURE GROUP MESSAGING
In this section we define compatibility helpers for SGM.
*compat-create(ID, skid, wkid)
*compat-dlv-CM(ID, vid)
*compat-inj-CM(ID,ğ‘‡â€²)
chk HG.isChild(V-Pt[ID], vid)
chk HG[vid].pid âŠ† P-St[ID]
return true
vid â† V-Pt[ID]
chk vid Ì¸= vidroot
chk âˆ€vidâ€² âˆˆ HG.children(vid) :
ğ‘‡â€² Ì¸= CM[vidâ€², ID]
*compat-dlv-CM(ID, vid)
return true
chk HG.isChild(V-Pt[ID], vid)
chk HG[vid].pid âŠ† P-St[ID]
return true
vid â† V-Pt[ID]
chk vid Ì¸= vidroot
chk âˆ€vidâ€² âˆˆ HG.children(vid) :
ğ‘‡â€² Ì¸= CM[vidâ€², ID]
*compat-inj-CM(ID,ğ‘‡â€²)
return true
*compat-dlv-WM(ID, vid)
chk V-Pt[ID] = vidroot
wkid â† HG.addedWK(ID, vid)
chk wkid Ì¸= âŠ¥
âˆ§ wkid âˆˆ WK-St[ID]
*compat-inj-WM(ID,ğ‘Š â€²)
return true
vid â† V-Pt[ID]
chk vid = vidroot
chk âˆ€vidâ€² :
ğ‘Š â€² Ì¸= CM[vidâ€², ID]
return true
*compat-send(S)
chk V-Pt[ID] Ì¸= vidroot
return true
*compat-chall(S, ğ‘š0, ğ‘š1)
chk V-Pt[ID] Ì¸= vidroot
chk |ğ‘š0|= |ğ‘š1|
return true
*compat-dlv-AM(vid, S, ğ‘–, R)
chk vid âˆˆ V-St[R]
chk AM[vid, S, ğ‘–, R] /âˆˆ
{ğœ–, received}
return true
chk âˆ€S, vid, ğ‘–, ğ‘š :
AM[vid, S, ğ‘–, R] Ì¸= (ğ‘, ğ‘š, ğ‘’)
return true
*compat-inj-AM(ğ‘, ğ‘’, R)
chk V-Pt[ID] = vidroot
chk SK-ID[skid] = ID
chk WK-SK[wkid] = skid
chk skid âˆˆ SK-St[ID]
chk wkid âˆˆ WK-St[ID]
return true
vid â† V-Pt[ID]
chk vid Ì¸= vidroot
ğº â† HG.roster(vid)
select op
case add do
*compat-prop(op, ID, IDâ€², skid)
chk
CL-KB[ID, IDâ€²] Ì¸= âˆ…
chk IDâ€² /âˆˆ ğº
chk IDâ€² âˆˆ ğº
chk skid âˆˆ SK-St[ID]
case rem do
case upd do
*compat-dlv-PM(ID, pid)
return true
chk Props[pid].vid = V-Pt[ID]
return true
vid â† V-Pt[ID]
chk vid Ì¸= vidroot
chk Ì¸âˆƒ pid :
*compat-inj-PM(ID, ğ‘ƒâ€²)
Props[pid].vid = vid
âˆ§ ğ‘ƒâ€² = PM[pid]
*compat-commit(ID, pid)
return true
vid â† V-Pt[ID]
chk vid Ì¸= vidroot
chk pid âŠ† P-St[ID]
G â† HG.roster(vid)
for pid âˆˆ pid
G â† *app-prop(G, pid)
chk G Ì¸= âŠ¥
return true
*app-prop(G, pid)
ğ‘ â† Props[pid]
req ğ‘.orig âˆˆ G
select op
case add do
(IDâ€², Â·, Â·) â† ğ‘.data
req IDâ€² /âˆˆ G
G +â† IDâ€²
IDâ€² â† ğ‘.data
req IDâ€² âˆˆ ğº
G âˆ’â† IDâ€²
case rem do
return G
Figure 17: Compatibility oracles of the security game for secure
group-messaging schemes.
E SGM CONSTRUCTION
In this section we formally define the helper functions of our SGM
construction.
// Returns ids, wpks, of new parties
*added(P)
if ğ‘ƒ = ("add", Â·, Â·, (IDğ‘, kbâ€²), Â·)
ID[Â·] â† ğœ€
wpk[Â·] â† ğœ€
ğ‘– â† 1 for ğ‘ƒ âˆˆ P
(wpk, Â·) â† kbâ€²
ID[ğ‘–] â† IDğ‘
wpk[ğ‘–] â† wpk
ğ‘–++
return (ID, wpk)
// Returns spks after applying props
*new-spks(epid, P)
spk â† s.Ep-SPK[epid]
for ğ‘ƒ âˆˆ P
if ğ‘ƒ = ("add", Â·, Â·, (IDğ‘, kbâ€²), Â·)
(Â·, spk) â† kbâ€²
spk[IDğ‘] â† spk
spk[IDğ‘Ÿ ] â† ğœ€
spk[IDğ‘¢] â† spk
if ğ‘ƒ = ("rem", Â·, Â·, IDğ‘Ÿ , Â·)
if ğ‘ƒ = ("upd", Â·, IDğ‘¢, spk, Â·)
return spk
// Returns position of ID in roster
*roster-pos(ID, G)
[ID1, . . . , IDğ‘›] â† G
for ğ‘– âˆˆ [1, ğ‘›]
if IDğ‘– = ID
return ğ‘–
if Pâ€² = ("rem", Â·, IDğ‘ , IDğ‘Ÿ , Â¯P)
if Pâ€² = ("add", Â·, IDğ‘ , (IDğ‘, kbâ€²), Â¯P)
// Returns Proposal Info
*get-propInfo(Pâ€²)
op = add
orig = IDğ‘ 
(wpk, spk) â† kbâ€²; data = (IDğ‘, wpk, spk)
op = rem
orig = IDğ‘ 
data = IDğ‘Ÿ
op = upd
orig = IDğ‘ 
data = spk
if Pâ€² = ("upd", Â·, IDğ‘ , spk, Â¯P)
return (op, orig, data)
Figure 18: The SGM Construction : Helper Algorithm.
Helpers. *added receives a vector of proposals P and returns the
ids and welcome public keys of newly added members. *new-spks
receives an epoch id and vector of proposals, (epid, P), and returns
the public verification keys for the ids affected by the proposals in P.
*roster-pos returns the position of ID in G, and *get-propInfo
receives a proposal Pâ€² and returns the proposal information, namely
the operation, op, the proposal origin, orig, and the data, data,
where if op = add, data holds the id, IDğ‘, welcome key material,
wpk, and the signature verification key spk, of the newly added
member. If op = rem, data holds the id of the removed party IDğ‘Ÿ ,
and if op = upd, data holds the updated verification key spk.
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1483