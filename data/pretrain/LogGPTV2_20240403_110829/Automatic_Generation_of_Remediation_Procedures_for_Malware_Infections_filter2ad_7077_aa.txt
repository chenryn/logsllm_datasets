title:Automatic Generation of Remediation Procedures for Malware Infections
author:Roberto Paleari and
Lorenzo Martignoni and
Emanuele Passerini and
Drew Davidson and
Matt Fredrikson and
Jonathon T. Giffin and
Somesh Jha
Automatic Generation of Remediation Procedures for Malware Infections
Roberto Paleari1, Lorenzo Martignoni2, Emanuele Passerini1,
Drew Davidson3, Matt Fredrikson3, Jon Gifﬁn4, Somesh Jha3
1Universit`a degli Studi di Milano
{roberto, ema}@security.dico.unimi.it
2Universit`a degli Studi di Udine
PI:EMAIL
3University of Wisconsin
{davidson, mfredrik, jha}@cs.wisc.edu
4Georgia Institute of Technology
PI:EMAIL
Abstract
Despite
the widespread deployment of malware-
detection software, in many situations it is difﬁcult to
preemptively block a malicious program from infecting
a system. Rather, signatures for detection are usually
available only after malware have started to infect a large
group of systems.
Ideally, infected systems should be
reinstalled from scratch. However, due to the high cost
of reinstallation, users may prefer to rely on the remedi-
ation capabilities of malware detectors to revert the ef-
fects of an infection. Unfortunately, current malware de-
tectors perform this task poorly, leaving users’ systems
in an unsafe or unstable state. This paper presents an
architecture to automatically generate remediation pro-
cedures from malicious programs—procedures that can
be used to remediate all and only the effects of the mal-
ware’s execution in any infected system. We have imple-
mented a prototype of this architecture and used it to gen-
erate remediation procedures for a corpus of more than
200 malware binaries. Our evaluation demonstrates that
the algorithm outperforms the remediation capabilities of
top-rated commercial malware detectors.
1
Introduction
One of the most pressing problems faced by the In-
ternet community today is the widespread diffusion of
malware. To defend against malware, users rely on
signature- or behavior-based anti-malware software that
attempts to detect and prevent malware from damaging
an end-host. Unfortunately, in many cases detection and
prevention are not possible. Malware authors have per-
fected the practice of automatically creating a large num-
ber of variants, or malware that appears new to detectors
but exhibits the same behavior when executed. For new
malware and variants, signatures for detection are rarely
available by the time malware reaches a network, leaving
a time window in which systems are susceptible to infec-
tion. In these situations, the ability to detect and remove
the malware after infection is not enough—it is also im-
perative that any harmful changes to the system made by
the malware are remediated (or reverted).
The safest way to remediate a system is to format
the permanent storage and re-install the operating sys-
tem from scratch. While effective, this approach is also
costly and usually results in a loss of valuable personal
data, particularly when data backups are incomplete or
non-existent. Rather, end-users and administrators may
prefer to remove only those resources left behind by the
malware, leaving the rest of the system intact. Unfor-
tunately, current anti-malware products perform poorly
at this task. A recent study demonstrated that even top-
rated commercial anti-malware software fails to revert
the effects of all the actions performed by malware dur-
ing infections [15]. Needless to say, partially-remediated
systems are unstable and prone to error.
In this paper, we present a system that automatically
generates remediation procedures from malware bina-
ries. These remediation procedures can be executed on
infected systems to restore the state to a clean conﬁg-
uration, and are capable of remediating the effects of a
malware sample a posteriori, without observing the in-
fection take place. The fact that our remediation proce-
dures are generated to cover a particular malware binary,
rather than a speciﬁc sequence of system events resulting
in an infected state [7, 19], amounts to a substantial break
from previous technologies. Using our system, one can
generate a single general-purpose executable that is ca-
pable of reversing the effects of a malware sample on an
arbitrary number of hosts after the fact. In other words,
one does not need to be aware of our system, or make
use of it, until after the infection takes place. To achieve
this goal, we rely on a combination of dynamic program
analysis and semantic generalization to produce models
of infection behavior that are resilient to common mal-
ware anti-analysis techniques, such as the use of nonde-
terminstic ﬁle names or the omission of malicious behav-
ior on some runs of the program. Then, we translate these
1
behavior models directly into executable procedures that
remediate the effects of a malware infection.
We have implemented our ideas in a prototype tool.
Using the prototype, we automatically generated reme-
diation procedures on a corpus of more than 200 binary
malware samples belonging to approximately 50 distinct
families. We evaluated the practical effectiveness of each
procedure by testing its ability to recognize all of the
harmful effects of a malware execution (true positives)
while leaving benign aspects of the system intact (true
negatives). The results of our evaluation attest to the ef-
fectiveness of our technique: in total, we reversed 98%
of the harmful effects while generating only a single false
positive, although we were not able to remediate user-
speciﬁc resource changes such as deleted documents and
personal ﬁle mutations. In contrast, the best commercial
anti-malware product remediated only 82% of the effects
of our corpus.
In summary, we make the following contributions:
• We present an architecture to automatically gener-
ate remediation procedures given binary malware
samples. To the best of our knowledge, our architec-
ture is the ﬁrst to work under the assumption that in-
formation relating to a speciﬁc infection is not avail-
able; rather, characteristic infection patterns are ob-
served and generalized to produce effective proce-
dures in this setting.
• We evaluated an implementation of our framework
on on more than 200 real malware samples and
found that it was able to remediate the resulting in-
fections more effectively than existing commercial
antivirus products. We have made this implementa-
tion available as an open-source package 1.
The rest of this paper is organized as follows: In Sec-
tion 2 we discuss related work. In Section 3.1, we de-
scribe the problem that our architecture solves by pre-
senting a realistic example, and in Section 3.2 we outline
our approach, relating it to the example. In Section 4,
we formalize the problem of malware remediation and
present the technical details of our approach.
In Sec-
tion 5, we evaluate the effectiveness of our approach by
testing a prototype implementation against real malware.
In Section 6 we discuss the limitations of our approach,
the security implications, and potential avenues for fu-
ture work. We present concluding remarks in Section 7.
2 Related Work
Our contributions relate to ongoing research on behavior-
based malware analysis, on the execution of untrusted
1The URL for
∼mfredrik/remediate
this tool
is http://www.cs.wisc.edu/
2
applications in trusted systems, and on the automatic
generation of signatures to detect malicious network traf-
ﬁc.
Behavior-Based Malware Analysis: The prevalence
of packed, polymorphic, and metamorphic malware
highlights the deﬁciencies of traditional detection ap-
proaches based on syntactic signatures. This has urged
researchers and security practitioners to focus on solu-
tions that base policy on the behavior exhibited by un-
trusted software. Behavior-based techniques attempt to
infer security-relevant information about an untrusted
program either by analyzing it statically [16] or by ob-
serving its operation dynamically [1, 11, 21]. The major
drawback of current behavior-based techniques is their
high computational overhead. Recently, Kolbitsch et al.
developed an efﬁcient analysis solution intended to re-
place traditional anti-malware on the desktop [8]. Closer
in spirit to the work presented here is that of Christodor-
escu et al. [4]. They described an automatic approach
that derives formal speciﬁcations of malicious behavior
by comparing the observed dynamic behavior of mali-
cious and benign applications. Their technique uses de-
pendence graphs, which express the relationships among
various low-level behavior events, and is similar in many
ways to our high-level behavior abstraction component
(see Section 4.2.1). Another area of much recent activity
is that of automatic classiﬁcation of malware into fami-
lies [2, 18]. For that type of work, malware is grouped
into clusters, which correspond to families, by some no-
tion of behavioral similarity. Our technique uses a form
of behavioral grouping as a means to remediate a system,
but we go further than malware classiﬁcation by attempt-
ing to remove the harmful effects of the malware on the
system.
Execution of Untrusted Applications:
In addition to
work that attempts to detect or prevent the execution of
malicious software, some work has been done to miti-
gate the harmful effects of software a posteriori. Hsu
et al. presented a framework for automatically repairing
an infected system after monitoring the execution of the
malware [7]. The actual work of remediating a system
given a detailed description of the malicious execution
is similar to the way that we construct remediation pro-
cedures from generalized behavior models. Liang et al.
described an alternative approach called Alcatraz [10].
In Alcatraz, an untrusted application is executed inside
of a sandbox, and any change it makes is not commit-
ted until the program is conﬁrmed to be innocuous. The
manner in which a program is deemed innocuous is con-
sidered orthogonal to the main issue of sandboxing. The
idea was later tweaked [19] so that all state changes made
by an application are cached, and upon program termina-
tion the user decides whether or not to keep any changes.
The primary differences between these techniques and
the one presented in this paper is that they rely on in-
formation regarding speciﬁc execution traces, whereas
our remediation procedures use generalized notions of
the behavior of a malware instance. As such, our sys-
tem can remediate harmful effects of malware, including
some effects that were not observed in a trace.
Automatic Signature Generation: The generalized
behavior models that we use to construct executable re-
mediation procedures can be viewed as generic signa-
tures relating the effects of a malicious program on sys-
tem resources. Different approaches have been proposed
for automatically generating attack signatures. Poly-
graph [14] is one of the ﬁrst systems proposed by re-
searchers to address the problem of generating network
signatures to detect polymorphic worms. Polygraph
identiﬁes invariant fragments of packets that are found in
all the network ﬂows generated by the same worm, since
they are necessary for the worm to successfully exploit a
given vulnerability. These fragments are then combined
into signatures using different techniques. Hamsa [9]
addresses the same problem using a different algorithm
that identiﬁes and combines invariants. Hamsa’s signa-
tures have better accuracy and are more resilient against
attacks than Polygraph. Finally, Nemean [20] gener-
ates semantics-aware signatures to detect network intru-
sions. Nemean’s methodology, consisting of high-level
network trafﬁc abstraction, clustering, and generalization
using automata learning, is similar to ours. However,
we operate on a fundamentally different domain than
Nemean, which generates signatures of network packet
traces.
3 Overview
In this section, we motivate our work using a realistic
example of a malware infection and present our architec-
ture by walking through the steps that it takes to remedi-
ate the example.
3.1 Motivation
Consider the malware whose pseudo-code is shown
in Figure 1. This program generates a random ﬁle-
name located in the system directory, drops a mali-
cious payload into the ﬁle, creates a new registry value
that causes the payload to be executed at system boot
time, tampers with the system’s network name resolver
(c:\...\etc\hosts), and infects a benign system li-
brary (c:\windows\user32.dll). Our goal is to gen-
erate a procedure that remediates infections caused by
In this case, re-
any possible execution of this code.
covery includes: (1) deleting the ﬁle containing a copy
of the malicious payload, (2) deleting the registry key
created to start the malware at boot, (3) disinfecting
c:\windows\user32.dll, and (4) restoring the original
conﬁguration of the name resolver c:\...\etc\hosts. It
is important that the effects of all malicious actions taken
by the malware are removed. For example, consider what
happens when (1), (2), and (3) are remediated, but not
(4). In this case, all internet trafﬁc on the host remains
subject to hijacking by the malware, so the system is still
in a dangerous conﬁguration. Many commercial prod-
ucts would leave the system in this conﬁguration [15].
Completely remediating the effects of the malware in
Figure 1 is not as straightforward as the example might
suggest. First, high-level source code is usually not avail-
able when dealing with real malware. Given the well-
known difﬁculty of statically analysing adversarial bi-
nary code [13], this means we must partially rely on
dynamic information. Although this example does not
illustrate it, there is a possibility that the malware con-
tains paths that are rarely executed under normal circum-
stances. Any harmful effects produced on such a path
would be difﬁcult to account for in a remediation pro-
cedure, because the problem of discovering such an ef-
fect dynamically is extremely difﬁcult. Secondly, mal-
ware can appear to be nondetermistic by relying on sub-
tle details in its environment, such as the system clock
or pseudorandom number generator. This behavior is of-
ten present even on common paths, and is apparent in
our example, despite its simplicity: Both the ﬁlename of
the malicious payload and the name of the registry value
used to activate the payload depend on randomness.
Given the limited nature of dynamic program informa-
tion, it may be hard to generate a remediation procedure
that precisely accounts for all of the nondeterminism in
a program. Procedures that do so may mistakenly iden-
tify benign system resources as malicious and attempt to
remediate them. Consider a remediation procedure that
attempts to account for the nondeterminism in our exam-
ple by looking for all ﬁles in the system directory with
the sufﬁx .exe. While this policy would effectively cap-
ture the nondeterminism in the payload ﬁlename, any at-
tempt to remediate resources based on it would result in
the unacceptable removal of benign executables. Con-
versely, procedures that do not attempt to generalize ex-
ecution behavior are likely to miss some malicious ef-
fects that must be remediated. For example, after run-
ning the sample malware once, we might ﬁnd that the
payload is delivered in c:\windows\poqwz.exe. If a re-
mediation procedure does not generalize this information
and only ever looks for this ﬁle when remediating infec-
tions caused by other executions of this malware, then it
will miss the payload ﬁle most of the time, as it is not
3
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
/ / g e n e r a t e random f i l e and v a l u e names
filename = "po" + random_alpha ( ) + random_alpha ( ) + random_alpha ( ) + ".exe" ;
valuename = ( random_int ( ) % 2 ) ? "qv" : "vq" ;
. . .
/ / drop m a l i c i o u s code
f = CreateFile ( ”c:\windows\” + filename , GENERIC_WRITE ,
WriteFile ( f , malicious_buf ,
. . . ) ;
WriteFile ( f , other_malicious_buf ,
. . .
/ /
RegOpenKey ( HKEY_LOCAL_MACHINE , "...\Windows\CurrentVersion\Run" , &r ) ;
if ( RegQueryValueEx ( r , valuename , NULL , REG_SZ ,
t h e n e w l y c r e a t e d e x e c u t a b l e a t b o o t
. . . ) == ERROR_FILE_NOT_FOUND )