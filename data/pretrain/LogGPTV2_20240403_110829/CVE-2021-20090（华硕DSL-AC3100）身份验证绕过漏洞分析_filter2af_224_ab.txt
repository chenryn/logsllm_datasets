      iVar3 = FUN_00018c70(iParm1);
      if (iVar3  && ： 逻辑与，前后条件同时满足表达式为真；
>
> || ： 逻辑与，前后条件只要有一个满足表达式为真。
如下面的代码，因为逻辑运算符&& 的优先级大于 || ，因此会先计算 && 的值。所以要先判断 iParm1 + 0x76a8 的值。如果值不为0
，则接着执行 逻辑运算符的|| 的表达式。
    ((((code )(PTR_PTR_DAT_00054fac + 0x14) == (code )0x0) ||
    (iVar3 = ((code )(PTR_PTR_DAT_00054fac + 0x14))(iParm1), iVar3 != 2)) &&
    (((int )(iParm1 + 0x76a8) != 0 || (iVar3 = FUN_0001d578(__dest,0,iParm1), iVar3 == 0))))
根据 FUN_00015058() 函数的代码，可以看到 iParm1 + 0x76a8 的值是从 FUN_0000deb0(__dest) 获取到的，而
“_dest” 的值在前面可以看出来是用户请求的 URL。
如果 iParm1 + 0x76a8 不为0 ，那么就能跳过身份验证的函数 **evaluate_access()**
，来直接执行处理POST请求的FUN_00014c30函数。
接下来进入 FUN_0000deb0() 函数，来查看是怎么处理 URL
    undefined4 FUN_0000deb0(char *pcParm1)
    {
      size_t __n;
      int iVar1;
      char *__s;
      undefined **ppuVar2;
      ppuVar2 = &PTR_s_/images/_00054f70;
      __s = PTR_s_/images/_00054f70;
      if (PTR_s_/images/_00054f70 == (undefined *)0x0) {
        return 0;
      }
      do {
        __n = strlen(__s);
        iVar1 = strncasecmp(pcParm1,__s,__n);
        if (iVar1 == 0) {
          return 1;
        }
        ppuVar2 = ppuVar2 + 1;
        __s = *ppuVar2;
      } while (*ppuVar2 != (char *)0x0);
      return 0;
    }
函数会将 url 和 &PTR _s_ /images/00054f70 字符串进行比较，直到符合为止，而 &PTR_s/images/_00054f70
的值是 “/images/” ，所以只需要请求的URL中带有 “/images/” 字符串，就可以绕过身份认证函数访问其他页面。
前面已经分析出来了身份验证绕过的漏洞点，但是并不能绕过验证访问任意界面，因为在访问的时候，需要正确的httoken值。接下来我们来分析设备的httoken
是怎么获取和生成的，在这个设备里，httoken 是设备的token值，并且访问设备的页面需要带有给定的httoken 值。根据漏洞披露来看，httoken
是在服务端进行生成，然后前端js 中进行解密，最终向服务器请求的时候，将httoken加入到请求数据中，但是漏洞披露并没有说明httoken
是那一段字符串生成的。。
我在httpd 的逆向工程中找到了生成httoken 的函数，
    undefined4 FUN_00022520(int iParm1)
    {
      int iVar1;
      undefined4 uVar2;
      undefined *puVar3;
      size_t sVar4;
      char cStack120;
      undefined auStack119 [107];
      memset(&cStack120,0,0x65);
      iVar1 = FUN_00017df0();
      if (iVar1 == -1) {
        uVar2 = 0;
      }
      else {
        puVar3 = (undefined *)(iParm1 + 0x7994);
        if (puVar3 == (undefined *)0x0) {
          puVar3 = &DAT_0003d274;
        }
        uVar2 = FUN_000393e0(puVar3);
        sprintf(&cStack120,"%lu",uVar2);
        sVar4 = strlen(&cStack120);
        FUN_00017e78(&cStack120,sVar4,auStack119 + sVar4,100 - sVar4);
        uVar2 = so_printf(iParm1,
                          ""
                          ,auStack119 + sVar4);
      }
      return uVar2;
接下来我们来分析FUN_00022520函数。在函数中我们可以看到最终生成了一个img 标签，并且src
的值是一段“data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7
+ auStack119 + sVar4 ”字符串，而其中 auStack119 + sVar4 的值是从FUN_00017e78 函数中进行base64
以及其他的方式进行处理后的字符串，并且这段字符串就是httoken的值。
生成的img 标签会在设备的login.html 中html 代码中出现，如下图所示，
根据生成httoken函数拼接这段字符串的方式，使用脚本对把token 解密出来，可以确定如下图的“372646849” 为设备的 token。
ArcBase.decode(“image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7MTU2OTQzNDE0OA==”）  
根据解密出来的信息，“;” 后面的字符串 “ 372646849” 就是设备解密后的httoken 值。
## 0x04 ping 命令注入+配置选项
这一部分，漏洞披露的相对来说比较详细，很多的网络设备中在ping网络诊断
这个功能中，出现过大量的历史漏洞，比如NetGear，D-Link等都出现过此类漏洞，因此关于ping
这一步部分命令拼接就不展开来讲述，但是本漏洞的不同点在于使用设备内部的配置选项ARC_TELNETD_ENABLE
来开启设备的telentd，这一点可以在以后的漏洞挖掘中遇到无法执行命令的时候，提供了不同的执行命令的方式。  
我们来重点的关注一下ARC_TELNETD_ENABLE 这个配置。在文件 /sbin/arc_telnetd
文件中可以看到文件内容。文件可以获取ARC_TELNETD_ENABLE的值，当ARC_TELNETD_ENABLE的值为1的时候，设备会开启telnetd。
###  漏洞复现
## 0x05 总结
这个身份验证绕过漏洞产生的根本原因在于对请求的URL
验证不严格，本来”/image”是用来用户请求前端静态资源时，默认不需要通过验证，最终导致通过“/image/” 绕过登录。
另外在前一阵子的披露的NetGear DGN2200v1
设备中同样存在通过前端静态资源的路径，来绕过身份验证。并且我在其他的一款网络设备的固件中发现类似的问题。