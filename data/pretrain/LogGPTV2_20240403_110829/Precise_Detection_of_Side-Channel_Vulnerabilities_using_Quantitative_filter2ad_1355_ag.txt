Privacy Under Fire. In 20th USENIX Security Symposium, San Francisco, CA, USA,
August 8-12, 2011, Proceedings.
[39] Jan Hoffmann, Klaus Aehlig, and Martin Hofmann. 2012. Multivariate Amortized
Resource Analysis. ACM Trans. Program. Lang. Syst. 34, 3, Article 14 (Nov. 2012),
62 pages.
[40] Jan Hoffmann, Ankush Das, and Shu-Chun Weng. 2017. Towards Automatic
Resource Bound Analysis for OCaml. In Proceedings of the 44th ACM SIGPLAN
Symposium on Principles of Programming Languages (POPL 2017). ACM, 359–373.
[41] Jan Hoffmann and Martin Hofmann. 2010. Amortized Resource Analysis with
Polynomial Potential: A Static Inference of Polynomial Bounds for Functional Pro-
grams. In Proceedings of the 19th European Conference on Programming Languages
and Systems (ESOP’10). Springer-Verlag, 287–306.
[42] Jan Hoffmann and Zhong Shao. 2014. Type-Based Amortized Resource Analysis
with Integers and Arrays. Springer International Publishing, 152–168.
[43] Martin Hofmann and Steffen Jost. 2003. Static Prediction of Heap Space Usage
for First-order Functional Programs. In Proceedings of the 30th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages (POPL ’03). ACM,
185–197.
[44] Bertrand Jeannet and Antoine Miné. 2009. Apron: A Library of Numerical
Abstract Domains for Static Analysis. In Proceedings of the 21st International
Conference on Computer Aided Verification (CAV ’09). Springer-Verlag, 661–667.
[45] Paul Kocher. 1996. Timing attacks on implementations of Diffie-Hellman, RSA,
DSS, and other systems. In Advances in CryptologyâĂŤCRYPTOâĂŹ96. Springer,
104–113.
[46] Paul C. Kocher. 1996. Timing Attacks on Implementations of Diffie-Hellman, RSA,
DSS, and Other Systems. In CRYPTO ’96, 16th Annual International Cryptology
Conference, Santa Barbara, California, USA, August 18-22, 1996, Proceedings. 104–
113.
[47] Shuvendu K. Lahiri and Shaz Qadeer. 2009. Complexity and Algorithms for Mono-
mial and Clausal Predicate Abstraction. In Proceedings of the 22Nd International
Conference on Automated Deduction (CADE-22). Springer-Verlag, 214–229.
[48] Chang Liu, Austin Harris, Martin Maas, Michael Hicks, Mohit Tiwari, and Elaine
Shi. 2015. GhostRider: A Hardware-Software System for Memory Trace Obliv-
ious Computation. In Proceedings of the Twentieth International Conference on
Architectural Support for Programming Languages and Operating Systems (ASPLOS
’15). ACM, 87–101.
[49] Robert Martin, John Demme, and Simha Sethumadhavan. 2012. TimeWarp:
Rethinking Timekeeping and Performance Monitoring Mechanisms to Mitigate
Side-channel Attacks. In Proceedings of the 39th Annual International Symposium
on Computer Architecture (ISCA ’12). IEEE Computer Society, 118–129.
[50] David Molnar, Matt Piotrowski, David Schultz, and David Wagner. 2006. The
Program Counter Security Model: Automatic Detection and Removal of Control-
flow Side Channel Attacks. In Proceedings of the 8th International Conference on
Information Security and Cryptology (ICISC’05). Springer-Verlag, 156–168.
[51] Andrew C Myers, Lantian Zheng, Steve Zdancewic, Stephen Chong, and
Nathaniel Nystrom. 2001. Jif: Java information flow. Software release. Located at
http://www. cs. cornell. edu/jif 2005 (2001).
[52] David A. Naumann. 2006. From Coupling Relations to Mated Invariants for Check-
ing Information Flow. Springer Berlin Heidelberg, 279–296.
[53] Van Chan Ngo, Mario Dehesa-Azuara, Matthew Fredrikson, and Jan Hoffmann.
2017. Verifying and Synthesizing Constant-Resource Implementations with
Types. In 38st IEEE Symposium on Security and Privacy, S&P.
[54] Corina Pasareanu, Quoc-Sang Phan, and Pasquale Malacaria. 2016. Multi-Run
Side-Channel Analysis Using Symbolic Execution and Max-SMT. In Computer
Security Foundations Symposium. IEEE.
[55] Corina S. Pasareanu, Quoc-Sang Phan, and Pasquale Malacaria. 2016. Multi-run
Side-Channel Analysis Using Symbolic Execution and Max-SMT. In IEEE 29th
Computer Security Foundations Symposium, CSF 2016, Lisbon, Portugal, June 27 -
July 1, 2016. 387–400.
[56] François Pottier and Vincent Simonet. 2003. Information Flow Inference for ML.
ACM Trans. Program. Lang. Syst. 25, 1 (Jan. 2003), 117–158.
[57] Ashay Rane, Calvin Lin, and Mohit Tiwari. 2015. Raccoon: Closing Digital Side-
Channels through Obfuscated Execution. In 24th USENIX Security Symposium
(USENIX Security 15). USENIX Association, Washington, D.C., 431–446.
[58] Ashay Rane, Calvin Lin, and Mohit Tiwari. 2016. Secure, Precise, and Fast Floating-
Point Operations on x86 Processors. In 25th USENIX Security Symposium (USENIX
Security 16). USENIX Association, Austin, TX, 71–86.
[59] Bruno Rodrigues, Fernando Magno Quintão Pereira, and Diego F. Aranha. 2016.
Sparse Representation of Implicit Flows with Applications to Side-channel Detec-
tion. In Proceedings of the 25th International Conference on Compiler Construction
(CC 2016). ACM, 110–120.
[60] Andrei Sabelfeld and Andrew C Myers. 2003. Language-based information-flow
security. IEEE Journal on selected areas in communications 21, 1 (2003), 5–19.
[61] Rahul Sharma, Saurabh Gupta, Bharath Hariharan, Alex Aiken, Percy Liang, and
Aditya V. Nori. 2013. A Data Driven Approach for Algebraic Loop Invariants.
In Proceedings of the 22Nd European Conference on Programming Languages and
Systems (ESOP’13). Springer-Verlag, 574–592.
[62] Reza Shokri and Vitaly Shmatikov. 2015. Privacy-Preserving Deep Learning. In
Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications
Security, Denver, CO, USA, October 12-6, 2015. 1310–1321.
[63] Moritz Sinn, Florian Zuleger, and Helmut Veith. 2014. A Simple and Scalable
Static Analysis for Bound Analysis and Amortized Complexity Analysis. Springer
Session D3:  Logical Side ChannelsCCS’17, October 30-November 3, 2017, Dallas, TX, USA888International Publishing, 745–761.
[64] Moritz Sinn, Florian Zuleger, and Helmut Veith. 2017. Complexity and Resource
Bound Analysis of Imperative Programs Using Difference Constraints. Journal
of Automated Reasoning (2017), 1–43.
[65] Marcelo Sousa and Isil Dillig. 2016. Cartesian Hoare Logic for Verifying K-safety
Properties. In Proceedings of the 37th ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI ’16). ACM, New York, NY, USA,
57–69.
[66] Tachio Terauchi and Alexander Aiken. 2005. Secure Information Flow as a Safety
Problem. In Static Analysis, 12th International Symposium, SAS 2005, London, UK,
September 7-9, 2005, Proceedings. 352–367.
[67] Raja Vallée-Rai, Phong Co, Etienne Gagnon, Laurie Hendren, Patrick Lam, and
Vijay Sundaresan. 1999. Soot - a Java Bytecode Optimization Framework. In Pro-
ceedings of the 1999 Conference of the Centre for Advanced Studies on Collaborative
Research (CASCON ’99). IBM Press, 13–.
[68] Serge Vaudenay. 2002. Security Flaws Induced by CBC Padding - Applications
to SSL, IPSEC, WTLS .... In Advances in Cryptology - EUROCRYPT 2002, Inter-
national Conference on the Theory and Applications of Cryptographic Techniques,
Amsterdam, The Netherlands, April 28 - May 2, 2002, Proceedings. 534–546.
[69] Jean Yang, Kuat Yessenov, and Armando Solar-Lezama. 2012. A language for
automatically enforcing privacy policies. In ACM SIGPLAN Notices, Vol. 47. ACM,
85–96.
[70] Yuval Yarom, Daniel Genkin, and Nadia Heninger. 2016. CacheBleed: A Timing
Attack on OpenSSL Constant Time RSA. Springer Berlin Heidelberg, 346–367.
[71] Anna Zaks and Amir Pnueli. 2008. CoVaC: Compiler Validation by Program
Analysis of the Cross-Product. In Proceedings of the 15th International Symposium
on Formal Methods (FM ’08). Springer-Verlag, Berlin, Heidelberg, 35–51.
[72] Danfeng Zhang, Aslan Askarov, and Andrew C. Myers. 2012. Language-based
Control and Mitigation of Timing Channels. In Proceedings of the 33rd ACM
SIGPLAN Conference on Programming Language Design and Implementation (PLDI
’12). ACM, 99–110.
[73] Kehuan Zhang, Zhou Li, Rui Wang, XiaoFeng Wang, and Shuo Chen. 2010. Side-
buster: Automated Detection and Quantification of Side-channel Leaks in Web
Application Development. In Computer and Communications Security. ACM, 595–
606.
[74] Florian Zuleger, Sumit Gulwani, Moritz Sinn, and Helmut Veith. 2011. Bound
Analysis of Imperative Programs with the Size-change Abstraction. In Proceedings
of the 18th International Conference on Static Analysis (SAS’11). Springer-Verlag,
280–297.
APPENDIX A: PROOF OF SOUNDNESS
Lemma .1. Let program P = λ(cid:174)p.S. If the following premises hold:
• (cid:174)p1 = α((cid:174)p), (cid:174)p2 = α((cid:174)p)
• |= I → (cid:174)p1
l ∧ (cid:174)p1
• Σ is sound
• Σ ⊢ CanSynchronize(e1, e2, S1, S2, I)
h (cid:44) (cid:174)p2
l = (cid:174)p2
h
Then |= I → (e1 ↔ e2).
then at least one of the two conditions must be true:
Proof. According to figure 6, if Σ ⊢ CanSynchronize(e1, e2, S1, S2, I),
• |= I → (e1 ↔ e2)
• e1 ≡α e2 ∧ S1 ≡α S2 ∧ Σ ⊢ e1 : low ∧ Σ ⊢ e2 : low
l and (cid:174)p2
l = (cid:174)p2
If the first condition is true, then the conclusion trivially holds.
Otherwise, since Σ is sound, we know that e1 and e2 depend solely
on (cid:174)p1
l , respectively. According to the first two premises,
I → (cid:174)p1
l . It follows that I → e1 = e2 and therefore |= I →
(e1 ↔ e2).
□
Lemma .2. Let vars(S) be the set of all free variables in S. If
vars(S1) ∩ vars(S2) = ∅, then S1; S2 is semantically equivalent to
S2; S1.
Proof. Suppose Γ ⊢ S1; S2 : Γ′, r. Since vars(S1) and vars(S2)
are mutually disjoint, we could break Γ into three partitions Γ =
Γ1 ⊔ Γ2 ⊔ Γ3, where dom(Γ1) = vars(S1), dom(Γ2) = vars(S2) and
dom(Γ3) = dom(Γ)\ vars(S1)\ vars(S2). Since Si does not touch Γj
where i (cid:44) j, we have
Γ1 ⊢ S1 : Γ
′
1 , r1
Γ2 ⊢ S2 : Γ
′
2 , r2
It follows that
′
Γ ⊢ S1 : Γ
1 ⊔ Γ2 ⊔ Γ3, r1
′
1 ⊔ Γ2 ⊔ Γ3 ⊢ S2 : Γ
Γ
′
Γ1 ⊔ Γ
2 ⊔ Γ3 ⊢ S1 : Γ
′
Γ ⊢ S2 : Γ1 ⊔ Γ
2 ⊔ Γ3, r2
′
′
1 ⊔ Γ
2 ⊔ Γ3, r1 + r2
′
′
1 ⊔ Γ
2 ⊔ Γ3, r2 + r1
Using the operational semantics rule for sequential composition
shown in figure 4, this means
Γ ⊢ S1; S2 : Γ
Γ ⊢ S2; S1 : Γ
′
2 ⊔ Γ3, r1 + r2
′
2 ⊔ Γ3, r2 + r1
′
1 ⊔ Γ
′
1 ⊔ Γ
As S1; S2 and S2; S1 both have the same effect on Γ and consume
the same amount of resource, they are semantically equivalent. □
Lemma .3. Let program P = λ(cid:174)p.S. Under the assumption that the
• (cid:174)p1 = α((cid:174)p), (cid:174)p2 = α((cid:174)p)
l ∧ (cid:174)p1
• |= Φ → (cid:174)p1
• Σ is sound
following premises hold:
l = (cid:174)p2
h (cid:44) (cid:174)p2
h
If Σ ⊢ ⟨Φ⟩ S1 ⊛ S2⟨Ψ⟩, then ⊢ {Φ} S1; S2 {Ψ}.
Proof. By structural induction on proof rules shown in figure 5.
• Rule (1).
By inductive hypothesis, ⊢ {Φ}S2; S1{Ψ}. Since S1 and S2 be-
longs to two different alpha-renamed copies of the program,
we have vars(S1) ∩ vars(S2) = ∅. Using lemma .2, we get
⊢ {Φ}S1; S2{Ψ}
Session D3:  Logical Side ChannelsCCS’17, October 30-November 3, 2017, Dallas, TX, USA889e2)}while e1 do S1; while e2 do S2{I ∧ ¬(e1 ∧ e2)}. Apply-
ing the consequence rule here we end up with
⊢ {I}while e1 do S1; while e2 do S2{I∧¬(e1∧e2)}. Combin-
ing this with |= Φ → I and the second inductive hypothesis
we finally get
⊢ {Φ}while e1 do S1; S; while e2 do S2; S′{Ψ}.
□
Theorem .4 (Soundness). Assuming soundness of taint environ-
ment Σ, if Σ ⊢ SideChannelFree(λ(cid:174)p.S, ϵ), then the program λ(cid:174)p.S
does not have an ϵ-bounded resource side-channel.
h. Therefore, lemma .3 applies, and we get ⊢ {Φ}Sτ
Proof. We know that Σ is sound and |= Φ → (cid:174)p1
l ∧
h (cid:44) (cid:174)p2
(cid:174)p1
2 {Ψ}.
Additionally, |= Ψ → |τ1 − τ2| ≤ ϵ|. Using the consequence rule in
standard Hoare logic, we obtain ⊢ {Φ}Sτ
2 {|τ1 − τ2| ≤ ϵ|}. By the
soundness of Hoare logic, it follows that |= {Φ}Sτ
2 {|τ1−τ2| ≤ ϵ|}.
By the soundness of self-composition, this means that
l = (cid:174)p2
1 ; Sτ
∀ (cid:174)a1, (cid:174)a2. (cid:174)a1l = (cid:174)a2l ∧ (cid:174)a1h (cid:44) (cid:174)a2h =⇒ |τ1 − τ2| ≤ ϵ
By lemma 4.1, τ1 = RP( (cid:174)a1) and τ2 = RP( (cid:174)a2). Substitute τ with RP
we arrive at our conclusion
∀ (cid:174)a1, (cid:174)a2. ( (cid:174)a1l = (cid:174)a2l ∧ (cid:174)a1h (cid:44) (cid:174)a2h) =⇒ |RP( (cid:174)a1) − RP( (cid:174)a2)| ≤ ϵ
1 ; Sτ
1 ; Sτ
□
• Rule (2).
By inductive hypothesis, ⊢ {Φ}S1; skip; S2{Ψ}. As S1; skip
is semantically equivalent to S1, we have ⊢ {Φ}S1; S2{Ψ}.
• Rule (3).
By inductive hypothesis, ⊢ {Φ′}S2; S3{Ψ}. Also, we know
{Φ}S1{Φ′}. Using the sequence rule in standard Hoare logic,
we derive ⊢ {Φ}S1; S2; S3{Ψ}.
• Rule (4).
By inductive hypothesis, ⊢ {Φ}S{Ψ}. As S is semantically
equivalent to S; skip, we get {Φ}S; skip{Ψ}.
• Rule (5).
By inductive hypothesis, ⊢ {Φ ∧ e}S1; S; S3{Ψ1} and ⊢ {Φ ∧
¬e}S2; S; S3{Ψ2}. Since |= Ψ1 → Ψ1 ∨ Ψ2 and |= Ψ2 →
Ψ1 ∨ Ψ2, according to the consequence rule in standard
Hoare logic we have {Φ ∧ e}S1; S; S3{Ψ1 ∨ Ψ2} and {Φ ∧
¬e}S2; S; S3{Ψ1 ∨ Ψ2}. With the sequence rule in standard
Hoare logic, assume
(1) ⊢ {Φ ∧ e}S1{Φ1}
(2) ⊢ {Φ1}S; S3{Ψ1 ∨ Ψ2}
(3) ⊢ {Φ ∧ ¬e}S2{Φ2}
(4) ⊢ {Φ2}S; S3{Ψ1 ∨ Ψ2}.
Let Φ′ = wp(Ψ1∨ Ψ2). It follows immediately from (2) and (4)
that Φ1 → Φ′ and Φ2 → Φ′. We could apply the consequence
rule again to (1) and (3) and derive ⊢ {Φ ∧ e}S1{Φ′} and
⊢ {Φ∧¬e}S2{Φ′}. Using the condition rule in standard Hoare
logic, we have {Φ}if e then S1 else S2{Φ′}. Combining (2),
(4), sequence rule and the definition of wp, we could finally
derive ⊢ {Φ}if e then S1 else S2; S; S3{Ψ1 ∨ Ψ2}.
• Rule (6).
By inductive hypothesis, ⊢ {Ψ′}S; S′{Ψ}. We also know that
⊢ {Φ}while e1 do S1{Φ′} and ⊢ {Φ′}while e2 do S2{Ψ′}.
Applying the sequence rule in standard Hoare logic twice,
we get ⊢ {Φ}while e1 do S1; while e2 do S2; S; S′{Ψ}. Ad-
ditionally, S and while e2 do S2 comes from two different
alpha-renamed copies so vars(S) ∩ vars(while e2 do S2) =
∅. We could apply lemma .2 and get
⊢ {Φ}while e1 do S1; S; while e2 do S2; S′{Ψ}
• Rule (7).
By inductive hypothesis, ⊢ {I ∧ e1 ∧ e2}S1; S2{I′} and ⊢
{I ∧ ¬e1 ∧ e2}S; S′{Ψ}. As |= I′ → I, we have ⊢ {I ∧ e1 ∧
e2}S1; S2{I} due to consequence rule. Now we may apply the
while rule in standard Hoare logic to obtain ⊢ {I}while e1 ∧
e2 do (S1; S2){I ∧ ¬(e1 ∧ e2)}.
Now, as following two statements are semantically equiva-
lent:
- while e1 ∧ e2 do (S1; S2)
- while e1 ∧ e2 do (S1; S2); while e1 do S1; while e2 do S2
we could replace the former with the latter:
⊢ {I}while e1 ∧ e2 do (S1; S2); while e1 do S1;
while e2 do S2{I ∧ ¬(e1 ∧ e2)}
According to lemma .1, |= I → (e1 ↔ e2). But we also
know that the precondition I ∧ ¬(e1 ∧ e2) holds before
the second loop while e1 do S1. This implies I¬e1 ∧ ¬e2
and therefore both of the two loops while e1 do S1 and
while e2 do S2 would not execute, which means ⊢ {I∧¬(e1∧
Session D3:  Logical Side ChannelsCCS’17, October 30-November 3, 2017, Dallas, TX, USA890