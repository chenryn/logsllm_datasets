### References

1. **Privacy Under Fire.** In *20th USENIX Security Symposium*, San Francisco, CA, USA, August 8-12, 2011, Proceedings.

2. **Jan Hoffmann, Klaus Aehlig, and Martin Hofmann.** 2012. *Multivariate Amortized Resource Analysis*. *ACM Trans. Program. Lang. Syst.* 34, 3, Article 14 (Nov. 2012), 62 pages.

3. **Jan Hoffmann, Ankush Das, and Shu-Chun Weng.** 2017. *Towards Automatic Resource Bound Analysis for OCaml*. In *Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL 2017)*. ACM, 359–373.

4. **Jan Hoffmann and Martin Hofmann.** 2010. *Amortized Resource Analysis with Polynomial Potential: A Static Inference of Polynomial Bounds for Functional Programs*. In *Proceedings of the 19th European Conference on Programming Languages and Systems (ESOP’10)*. Springer-Verlag, 287–306.

5. **Jan Hoffmann and Zhong Shao.** 2014. *Type-Based Amortized Resource Analysis with Integers and Arrays*. Springer International Publishing, 152–168.

6. **Martin Hofmann and Steffen Jost.** 2003. *Static Prediction of Heap Space Usage for First-order Functional Programs*. In *Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL ’03)*. ACM, 185–197.

7. **Bertrand Jeannet and Antoine Miné.** 2009. *Apron: A Library of Numerical Abstract Domains for Static Analysis*. In *Proceedings of the 21st International Conference on Computer Aided Verification (CAV ’09)*. Springer-Verlag, 661–667.

8. **Paul Kocher.** 1996. *Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems*. In *Advances in Cryptology—CRYPTO’96*. Springer, 104–113.

9. **Shuvendu K. Lahiri and Shaz Qadeer.** 2009. *Complexity and Algorithms for Monomial and Clausal Predicate Abstraction*. In *Proceedings of the 22nd International Conference on Automated Deduction (CADE-22)*. Springer-Verlag, 214–229.

10. **Chang Liu, Austin Harris, Martin Maas, Michael Hicks, Mohit Tiwari, and Elaine Shi.** 2015. *GhostRider: A Hardware-Software System for Memory Trace Oblivious Computation*. In *Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS ’15)*. ACM, 87–101.

11. **Robert Martin, John Demme, and Simha Sethumadhavan.** 2012. *TimeWarp: Rethinking Timekeeping and Performance Monitoring Mechanisms to Mitigate Side-channel Attacks*. In *Proceedings of the 39th Annual International Symposium on Computer Architecture (ISCA ’12)*. IEEE Computer Society, 118–129.

12. **David Molnar, Matt Piotrowski, David Schultz, and David Wagner.** 2006. *The Program Counter Security Model: Automatic Detection and Removal of Control-flow Side Channel Attacks*. In *Proceedings of the 8th International Conference on Information Security and Cryptology (ICISC’05)*. Springer-Verlag, 156–168.

13. **Andrew C. Myers, Lantian Zheng, Steve Zdancewic, Stephen Chong, and Nathaniel Nystrom.** 2001. *Jif: Java Information Flow*. Software release. Located at <http://www.cs.cornell.edu/jif>.

14. **David A. Naumann.** 2006. *From Coupling Relations to Mated Invariants for Checking Information Flow*. Springer Berlin Heidelberg, 279–296.

15. **Van Chan Ngo, Mario Dehesa-Azuara, Matthew Fredrikson, and Jan Hoffmann.** 2017. *Verifying and Synthesizing Constant-Resource Implementations with Types*. In *38th IEEE Symposium on Security and Privacy, S&P*.

16. **Corina Pasareanu, Quoc-Sang Phan, and Pasquale Malacaria.** 2016. *Multi-Run Side-Channel Analysis Using Symbolic Execution and Max-SMT*. In *IEEE 29th Computer Security Foundations Symposium, CSF 2016, Lisbon, Portugal, June 27 - July 1, 2016*. 387–400.

17. **François Pottier and Vincent Simonet.** 2003. *Information Flow Inference for ML*. *ACM Trans. Program. Lang. Syst.* 25, 1 (Jan. 2003), 117–158.

18. **Ashay Rane, Calvin Lin, and Mohit Tiwari.** 2015. *Raccoon: Closing Digital Side-Channels through Obfuscated Execution*. In *24th USENIX Security Symposium (USENIX Security 15)*. USENIX Association, Washington, D.C., 431–446.

19. **Ashay Rane, Calvin Lin, and Mohit Tiwari.** 2016. *Secure, Precise, and Fast Floating-Point Operations on x86 Processors*. In *25th USENIX Security Symposium (USENIX Security 16)*. USENIX Association, Austin, TX, 71–86.

20. **Bruno Rodrigues, Fernando Magno Quintão Pereira, and Diego F. Aranha.** 2016. *Sparse Representation of Implicit Flows with Applications to Side-channel Detection*. In *Proceedings of the 25th International Conference on Compiler Construction (CC 2016)*. ACM, 110–120.

21. **Andrei Sabelfeld and Andrew C. Myers.** 2003. *Language-based Information-Flow Security*. *IEEE Journal on Selected Areas in Communications* 21, 1 (2003), 5–19.

22. **Rahul Sharma, Saurabh Gupta, Bharath Hariharan, Alex Aiken, Percy Liang, and Aditya V. Nori.** 2013. *A Data Driven Approach for Algebraic Loop Invariants*. In *Proceedings of the 22nd European Conference on Programming Languages and Systems (ESOP’13)*. Springer-Verlag, 574–592.

23. **Reza Shokri and Vitaly Shmatikov.** 2015. *Privacy-Preserving Deep Learning*. In *Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, Denver, CO, USA, October 12-6, 2015*. 1310–1321.

24. **Moritz Sinn, Florian Zuleger, and Helmut Veith.** 2014. *A Simple and Scalable Static Analysis for Bound Analysis and Amortized Complexity Analysis*. Springer Session D3: Logical Side Channels, *CCS’17, October 30-November 3, 2017, Dallas, TX, USA*. 745–761.

25. **Moritz Sinn, Florian Zuleger, and Helmut Veith.** 2017. *Complexity and Resource Bound Analysis of Imperative Programs Using Difference Constraints*. *Journal of Automated Reasoning* (2017), 1–43.

26. **Marcelo Sousa and Isil Dillig.** 2016. *Cartesian Hoare Logic for Verifying K-safety Properties*. In *Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI ’16)*. ACM, New York, NY, USA, 57–69.

27. **Tachio Terauchi and Alexander Aiken.** 2005. *Secure Information Flow as a Safety Problem*. In *Static Analysis, 12th International Symposium, SAS 2005, London, UK, September 7-9, 2005, Proceedings*. 352–367.

28. **Raja Vallée-Rai, Phong Co, Etienne Gagnon, Laurie Hendren, Patrick Lam, and Vijay Sundaresan.** 1999. *Soot - a Java Bytecode Optimization Framework*. In *Proceedings of the 1999 Conference of the Centre for Advanced Studies on Collaborative Research (CASCON ’99)*. IBM Press, 13–.

29. **Serge Vaudenay.** 2002. *Security Flaws Induced by CBC Padding - Applications to SSL, IPSEC, WTLS...*. In *Advances in Cryptology - EUROCRYPT 2002, International Conference on the Theory and Applications of Cryptographic Techniques, Amsterdam, The Netherlands, April 28 - May 2, 2002, Proceedings*. 534–546.

30. **Jean Yang, Kuat Yessenov, and Armando Solar-Lezama.** 2012. *A Language for Automatically Enforcing Privacy Policies*. In *ACM SIGPLAN Notices, Vol. 47*. ACM, 85–96.

31. **Yuval Yarom, Daniel Genkin, and Nadia Heninger.** 2016. *CacheBleed: A Timing Attack on OpenSSL Constant Time RSA*. Springer Berlin Heidelberg, 346–367.

32. **Anna Zaks and Amir Pnueli.** 2008. *CoVaC: Compiler Validation by Program Analysis of the Cross-Product*. In *Proceedings of the 15th International Symposium on Formal Methods (FM ’08)*. Springer-Verlag, Berlin, Heidelberg, 35–51.

33. **Danfeng Zhang, Aslan Askarov, and Andrew C. Myers.** 2012. *Language-based Control and Mitigation of Timing Channels*. In *Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI ’12)*. ACM, 99–110.

34. **Kehuan Zhang, Zhou Li, Rui Wang, XiaoFeng Wang, and Shuo Chen.** 2010. *Side-buster: Automated Detection and Quantification of Side-channel Leaks in Web Application Development*. In *Computer and Communications Security*. ACM, 595–606.

35. **Florian Zuleger, Sumit Gulwani, Moritz Sinn, and Helmut Veith.** 2011. *Bound Analysis of Imperative Programs with the Size-change Abstraction*. In *Proceedings of the 18th International Conference on Static Analysis (SAS’11)*. Springer-Verlag, 280–297.

### Appendix A: Proof of Soundness

#### Lemma 1
Let program \( P = \lambda \vec{p}.S \). If the following premises hold:
- \(\vec{p}_1 = \alpha(\vec{p}), \vec{p}_2 = \alpha(\vec{p})\)
- \(\models I \rightarrow \vec{p}_1^l \land \vec{p}_1\)
- \(\Sigma\) is sound
- \(\Sigma \vdash \text{CanSynchronize}(e_1, e_2, S_1, S_2, I)\)
- \(\vec{p}_2^l = \vec{p}_2^h \land \vec{p}_2^h\)

Then \(\models I \rightarrow (e_1 \leftrightarrow e_2)\).

**Proof:**
According to Figure 6, if \(\Sigma \vdash \text{CanSynchronize}(e_1, e_2, S_1, S_2, I)\), then at least one of the two conditions must be true:
- \(\models I \rightarrow (e_1 \leftrightarrow e_2)\)
- \(e_1 \equiv_\alpha e_2 \land S_1 \equiv_\alpha S_2 \land \Sigma \vdash e_1 : \text{low} \land \Sigma \vdash e_2 : \text{low}\)

If the first condition is true, then the conclusion trivially holds. Otherwise, since \(\Sigma\) is sound, we know that \(e_1\) and \(e_2\) depend solely on \(\vec{p}_1^l\) and \(\vec{p}_2^l\), respectively. According to the first two premises, \(\models I \rightarrow \vec{p}_1^l\). It follows that \(\models I \rightarrow e_1 = e_2\) and therefore \(\models I \rightarrow (e_1 \leftrightarrow e_2)\). \(\blacksquare\)

#### Lemma 2
Let \(\text{vars}(S)\) be the set of all free variables in \(S\). If \(\text{vars}(S_1) \cap \text{vars}(S_2) = \emptyset\), then \(S_1; S_2\) is semantically equivalent to \(S_2; S_1\).

**Proof:**
Suppose \(\Gamma \vdash S_1; S_2 : \Gamma', r\). Since \(\text{vars}(S_1)\) and \(\text{vars}(S_2)\) are mutually disjoint, we could break \(\Gamma\) into three partitions \(\Gamma = \Gamma_1 \sqcup \Gamma_2 \sqcup \Gamma_3\), where \(\text{dom}(\Gamma_1) = \text{vars}(S_1)\), \(\text{dom}(\Gamma_2) = \text{vars}(S_2)\), and \(\text{dom}(\Gamma_3) = \text{dom}(\Gamma) \setminus \text{vars}(S_1) \setminus \text{vars}(S_2)\). Since \(S_i\) does not touch \(\Gamma_j\) where \(i \neq j\), we have:
\[
\Gamma_1 \vdash S_1 : \Gamma_1', r_1
\]
\[
\Gamma_2 \vdash S_2 : \Gamma_2', r_2
\]

It follows that:
\[
\Gamma \vdash S_1 : \Gamma_1' \sqcup \Gamma_2 \sqcup \Gamma_3, r_1
\]
\[
\Gamma_1' \sqcup \Gamma_2 \sqcup \Gamma_3 \vdash S_2 : \Gamma_1' \sqcup \Gamma_2' \sqcup \Gamma_3, r_2
\]

Using the operational semantics rule for sequential composition shown in Figure 4, this means:
\[
\Gamma \vdash S_1; S_2 : \Gamma_1' \sqcup \Gamma_2' \sqcup \Gamma_3, r_1 + r_2
\]
\[
\Gamma \vdash S_2; S_1 : \Gamma_1' \sqcup \Gamma_2' \sqcup \Gamma_3, r_2 + r_1
\]

As \(S_1; S_2\) and \(S_2; S_1\) both have the same effect on \(\Gamma\) and consume the same amount of resource, they are semantically equivalent. \(\blacksquare\)

#### Lemma 3
Let program \( P = \lambda \vec{p}.S \). Under the assumption that the following premises hold:
- \(\vec{p}_1 = \alpha(\vec{p}), \vec{p}_2 = \alpha(\vec{p})\)
- \(\models \Phi \rightarrow \vec{p}_1^l \land \vec{p}_1\)
- \(\Sigma\) is sound
- \(\vec{p}_2^l = \vec{p}_2^h \land \vec{p}_2^h\)

If \(\Sigma \vdash \langle \Phi \rangle S_1 \star S_2 \langle \Psi \rangle\), then \(\vdash \{\Phi\} S_1; S_2 \{\Psi\}\).

**Proof:**
By structural induction on proof rules shown in Figure 5.

- **Rule (1):**
  By inductive hypothesis, \(\vdash \{\Phi\} S_2; S_1 \{\Psi\}\). Since \(S_1\) and \(S_2\) belong to two different alpha-renamed copies of the program, we have \(\text{vars}(S_1) \cap \text{vars}(S_2) = \emptyset\). Using Lemma 2, we get \(\vdash \{\Phi\} S_1; S_2 \{\Psi\}\).

- **Rule (2):**
  By inductive hypothesis, \(\vdash \{\Phi\} S_1; \text{skip}; S_2 \{\Psi\}\). As \(S_1; \text{skip}\) is semantically equivalent to \(S_1\), we have \(\vdash \{\Phi\} S_1; S_2 \{\Psi\}\).

- **Rule (3):**
  By inductive hypothesis, \(\vdash \{\Phi'\} S_2; S_3 \{\Psi\}\). Also, we know \(\{\Phi\} S_1 \{\Phi'\}\). Using the sequence rule in standard Hoare logic, we derive \(\vdash \{\Phi\} S_1; S_2; S_3 \{\Psi\}\).

- **Rule (4):**
  By inductive hypothesis, \(\vdash \{\Phi\} S \{\Psi\}\). As \(S\) is semantically equivalent to \(S; \text{skip}\), we get \(\{\Phi\} S; \text{skip} \{\Psi\}\).

- **Rule (5):**
  By inductive hypothesis, \(\vdash \{\Phi \land e\} S_1; S; S_3 \{\Psi_1\}\) and \(\vdash \{\Phi \land \neg e\} S_2; S; S_3 \{\Psi_2\}\). Since \(\models \Psi_1 \rightarrow \Psi_1 \lor \Psi_2\) and \(\models \Psi_2 \rightarrow \Psi_1 \lor \Psi_2\), according to the consequence rule in standard Hoare logic, we have \(\{\Phi \land e\} S_1; S; S_3 \{\Psi_1 \lor \Psi_2\}\) and \(\{\Phi \land \neg e\} S_2; S; S_3 \{\Psi_1 \lor \Psi_2\}\). With the sequence rule in standard Hoare logic, assume:
  1. \(\vdash \{\Phi \land e\} S_1 \{\Phi_1\}\)
  2. \(\vdash \{\Phi_1\} S; S_3 \{\Psi_1 \lor \Psi_2\}\)
  3. \(\vdash \{\Phi \land \neg e\} S_2 \{\Phi_2\}\)
  4. \(\vdash \{\Phi_2\} S; S_3 \{\Psi_1 \lor \Psi_2\}\).

  Let \(\Phi' = \text{wp}(\Psi_1 \lor \Psi_2)\). It follows immediately from (2) and (4) that \(\Phi_1 \rightarrow \Phi'\) and \(\Phi_2 \rightarrow \Phi'\). We could apply the consequence rule again to (1) and (3) and derive \(\vdash \{\Phi \land e\} S_1 \{\Phi'\}\) and \(\vdash \{\Phi \land \neg e\} S_2 \{\Phi'\}\). Using the condition rule in standard Hoare logic, we have \(\{\Phi\} \text{if } e \text{ then } S_1 \text{ else } S_2 \{\Phi'\}\). Combining (2), (4), sequence rule, and the definition of wp, we could finally derive \(\vdash \{\Phi\} \text{if } e \text{ then } S_1 \text{ else } S_2; S; S_3 \{\Psi_1 \lor \Psi_2\}\).

- **Rule (6):**
  By inductive hypothesis, \(\vdash \{\Psi'\} S; S' \{\Psi\}\). We also know that \(\vdash \{\Phi\} \text{while } e_1 \text{ do } S_1 \{\Phi'\}\) and \(\vdash \{\Phi'\} \text{while } e_2 \text{ do } S_2 \{\Psi'\}\). Applying the sequence rule in standard Hoare logic twice, we get \(\vdash \{\Phi\} \text{while } e_1 \text{ do } S_1; \text{while } e_2 \text{ do } S_2; S; S' \{\Psi\}\). Additionally, \(S\) and \(\text{while } e_2 \text{ do } S_2\) come from two different alpha-renamed copies, so \(\text{vars}(S) \cap \text{vars}(\text{while } e_2 \text{ do } S_2) = \emptyset\). We could apply Lemma 2 and get:
  \[
  \vdash \{\Phi\} \text{while } e_1 \text{ do } S_1; S; \text{while } e_2 \text{ do } S_2; S' \{\Psi\}
  \]

- **Rule (7):**
  By inductive hypothesis, \(\vdash \{I \land e_1 \land e_2\} S_1; S_2 \{I'\}\) and \(\vdash \{I \land \neg e_1 \land e_2\} S; S' \{\Psi\}\). As \(\models I' \rightarrow I\), we have \(\vdash \{I \land e_1 \land e_2\} S_1; S_2 \{I\}\) due to the consequence rule. Now we may apply the while rule in standard Hoare logic to obtain \(\vdash \{I\} \text{while } e_1 \land e_2 \text{ do } (S_1; S_2) \{I \land \neg(e_1 \land e_2)\}\).

  Now, as the following two statements are semantically equivalent:
  - \(\text{while } e_1 \land e_2 \text{ do } (S_1; S_2)\)
  - \(\text{while } e_1 \land e_2 \text{ do } (S_1; S_2); \text{while } e_1 \text{ do } S_1; \text{while } e_2 \text{ do } S_2\)

  We could replace the former with the latter:
  \[
  \vdash \{I\} \text{while } e_1 \land e_2 \text{ do } (S_1; S_2); \text{while } e_1 \text{ do } S_1; \text{while } e_2 \text{ do } S_2 \{I \land \neg(e_1 \land e_2)\}
  \]

  According to Lemma 1, \(\models I \rightarrow (e_1 \leftrightarrow e_2)\). But we also know that the precondition \(I \land \neg(e_1 \land e_2)\) holds before the second loop \(\text{while } e_1 \text{ do } S_1\). This implies \(I \land \neg e_1 \land \neg e_2\), and therefore both of the two loops \(\text{while } e_1 \text{ do } S_1\) and \(\text{while } e_2 \text{ do } S_2\) would not execute, which means \(\vdash \{I \land \neg(e_1 \land e_2)\} \text{while } e_1 \text{ do } S_1; \text{while } e_2 \text{ do } S_2 \{\Psi\}\). \(\blacksquare\)

#### Theorem 4 (Soundness)
Assuming soundness of taint environment \(\Sigma\), if \(\Sigma \vdash \text{SideChannelFree}(\lambda \vec{p}.S, \epsilon)\), then the program \(\lambda \vec{p}.S\) does not have an \(\epsilon\)-bounded resource side-channel.

**Proof:**
We know that \(\Sigma\) is sound and \(\models \Phi \rightarrow \vec{p}_1^l \land \vec{p}_1^h \land \vec{p}_2^h\). Therefore, Lemma 3 applies, and we get \(\vdash \{\Phi\} S_{\tau_1} \{\Psi\}\). Additionally, \(\models \Psi \rightarrow |\tau_1 - \tau_2| \leq \epsilon\). Using the consequence rule in standard Hoare logic, we obtain \(\vdash \{\Phi\} S_{\tau_1} \{|\tau_1 - \tau_2| \leq \epsilon\}\). By the soundness of Hoare logic, it follows that \(\models \{\Phi\} S_{\tau_1} \{|\tau_1 - \tau_2| \leq \epsilon\}\).

By the soundness of self-composition, this means that:
\[
\forall \vec{a}_1, \vec{a}_2. (\vec{a}_1^l = \vec{a}_2^l \land \vec{a}_1^h \neq \vec{a}_2^h) \Rightarrow |\tau_1 - \tau_2| \leq \epsilon
\]

By Lemma 4.1, \(\tau_1 = \text{RP}(\vec{a}_1)\) and \(\tau_2 = \text{RP}(\vec{a}_2)\). Substitute \(\tau\) with RP, we arrive at our conclusion:
\[
\forall \vec{a}_1, \vec{a}_2. (\vec{a}_1^l = \vec{a}_2^l \land \vec{a}_1^h \neq \vec{a}_2^h) \Rightarrow |\text{RP}(\vec{a}_1) - \text{RP}(\vec{a}_2)| \leq \epsilon
\]

\(\blacksquare\)