Security Symposium (Security), Washington, DC, Aug. 2015.
[52] M. Rash, “A Collection Of Vulnerabilities Discovered By The AFL
Fuzzer,” 2017, https://github.com/mrash/afl-cve.
[53] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida, and H. Bos,
“VUzzer: Application-aware Evolutionary Fuzzing,” in Proceedings of
the 2017 Annual Network and Distributed System Security Symposium
(NDSS), San Diego, CA, Feb.–Mar. 2017.
[54] M. Russinovich and D. A. Solomon, Windows internals: including
Windows server 2008 and Windows Vista. Microsoft press, 2009.
[55] R. Schaefer,
“Fuzzing Adobe Reader For Exploitable Vulns,”
https://kciredor.com/fuzzing-adobe-reader-for-exploitable-vulns-fun-
not-profit.html, 2018.
[56] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, “Address-
Sanitizer: A Fast Address Sanity Checker,” in Proceedings of the 2012
USENIX Annual Technical Conference (ATC), Boston, MA, Jun. 2012.
[57] A. Souchet, I. Fratric, J. Vazquez, and S. Denbow, “AFL For Fuzzing
Windows Binaries,” 2016, https://github.com/ivanfratric/winafl.
[58] A. Souchet, I. Fratric, J. Vazquez, and S. Denbow, “How to Select
A Target Function,” https://github.com/googleprojectzero/winafl#how-to-
select-a-target-function, 2016.
[59] A. Souchet, I. Fratric, J. Vazquez, and S. Denbow, “WinAFL Intel PT
mode ,” 2019, https://github.com/googleprojectzero/winafl/blob/master/
readme_pt.md.
[60] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting
Fuzzing Through Selective Symbolic Execution,” in Proceedings of
the 2016 Annual Network and Distributed System Security Symposium
(NDSS), San Diego, CA, Feb. 2016.
[61] symeon, “Fuzzing The MSXML6 Library With WinAFL,” https://
symeonp.github.io/2017/09/17/fuzzing-winafl.html, 2017.
[62] Syzkaller, “Syzkaller Found Bugs - Linux Kernel,” 2018, https://github.
15
A. Fork Internals
APPENDIX
To implement our fork functionality, we reverse-engineered
various internal Windows APIs and systems, namely ntdll.dll,
NtCreateUserProcess, and the CSRSS (Client/Server Runtime
Subsystem). Doing so, we identified several magic values
required by them. After overcoming these challenges, we were
able to implement a practical, robust fork-server for fuzzing.
Role of CSRSS. The CSRSS is the user-mode process
that controls the underlying layer of the Windows environ-
ment [54]. This daemon is responsible for allocating console
windows and shutting down processes. New processes must
connect to it to function properly.
We use Windows native system APIs to communicate with
the kernel directly. Figure 6 and Figure 10 display our fork
implementation. The steps are as follows:
1 The parent process calls NtCreateUserProcess with
the proper flags, creating a suspended child process with
a CoW copy of the parent’s address space (line 1). We
keep the child process suspended until the parent 2 calls
CsrClientCallServer to inform the CSRSS that a new process
was created (line 12). 3 The parent now resumes the child,
which proceeds to self-initialize (line 17). Then, the parent
returns from fork (line 14). 4 In the child process, because
the address space matches the parent’s, several global variables
(e.g., CsrServerApiRoutine in ntdll.dll) that would be zero
for new processes are already set. The child must de-initialize
these manually by zeroing them out (line 18) to avoid crashing
in the next step. 5 The child now connects to the CSRSS
by calling CsrClientConnectToServer (line 20). This step is
critical for the child process to function properly. 6 The
CSRSS finally acknowledges the newly created process and
thread, and the child process returns from fork (line 21).
&hProcess, &hThread, MAXIMUM_ALLOWED, MAXIMUM_ALLOWED,
NULL, NULL, PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT
| PROCESS_CREATE_FLAGS_INHERIT_HANDLES,
THREAD_CREATE_FLAGS_CREATE_SUSPENDED,
NULL, &procInfo, NULL
1 NTSTATUS result = NtCreateUserProcess(
2
3
4
5
6
7 );
8
9 if (!result) { // Parent process
10
11
12
13
14
15
16 } else { // Child process
17
18
19
20
21
22 }
// Inform the CSRSS that a new process was created
// via CsrClientCallServer(CreateProcessRequest)
NotifyCsrssParent(hProcess, hThread);
// Allow the child to connect to CSR and resume.
ResumeThread(hThread);
return GetProcessId(hProcess);
// De-initialize ntdll variables before re-initialization
memset(pCsrData, 0, csrDataSize);
// Connect to the CSRSS via CsrClientConnectToServer
ConnectCsrChild();
return 0;
Fig. 10: Fork implementation, We displayed the core fork() function
only. Low level details and helper functions are omitted for brevity.
For more detailed code, refer to our project’s source code.
B. Tested Harnesses
100
90
80
70
60
s
s
e
n
r
a
h
d
i
l
a
v
f
o
%
50
0
25
50
75
100
125
150
175
200
modified LoC
Fig. 11: Cumulative distribution plot for our harnesses. The graph
plots how many of our harnesses fixed N LoC or fewer. As shown,
nearly 70% of the harnesses worked without any modifications at all.
95% of our harnesses could be fuzzed with ≤ 10 LoC modifications.
16
#
Program
7zip
File
Size
WinAFL-PT
WinAFL-DR #
File
Size
WinAFL-PT
WinAFL-DR
Program
IrfanView
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
timeout
crash
crash
crash
timeout
timeout
timeout
timeout
timeout
timeout
timeout
timeout
timeout
crash
timeout
7z.dll
rar.exe
makecab.exe
avformat-gp-57
expand.exe
libfaad.dll
uriparser.exe
jp2klib.dll
storm.dll
impic9.flt
imcdr9.flt
hncbmp10.flt
hncgif10.flt
hncwmf10.flt
imdrw9.flt
hncjpeg10.flt
hnctiff10.flt
mac.exe
core_rl_magic_
undname.exe
pdf2office(doc)
pdf2office(ppt)
egg.dll
tar.dll
alz.dll
lib.exe
hncpng10.flt
imgdrw9.flt
magic1.dll
dxcap.exe
1
2 WinRAR
makecab
3
GomPlayer
4
expand
5
VLCPlayer
6
uriparser
7
AdobeRdr
8
Starcraft
9
10 HWP
11
12
13
14
15
16
17
18 monkey2
19 GraphMagic
20
21 EzPDF
22
23 Alzip
24
25
26 Lib
27 HWP
28
29 Libmagic
30
TABLE XI: Results of testing the generated harnesses with WinAFL. We generated 59 harnesses and tested on WINNIE, WinAFL-IPT,
and WinAFL-DR. WINNIE was able to run all 59 harnesses. WinAFL-IPT and WinAFL-DR failed to run 33 and 30 harnesses respectively.
"No inst." denotes no instrumentation.
31
32 EzPDF
33
34
35 RetroArch
36
37
38
39
40
41
42
43
44 ml
45 mspdbcmf
pdbcopy
46
47 XnView
48
49 UltraISO
50 ACDSee
51 KGB
52
53 MuseScore3 musescore3.exe
54 MSSDK
55
56
57
58
59
jpg_transform
pdf2html.dll
ezpdf2hwp.dll
pdf2office(xls)
bnes.dll
handy.dll
quicknes.dll
bsnes.dll
fmsx.dll
sfc.dll
vbam.dll
fcemm.dll
desmume.dll
ml.exe
mspdbcmf.exe
pdbcopy.exe
cadimage.dll
ldf_jpm.dll
ultraiso.exe
IDE_ACDStd
paq6.dll
inkscape.exe
1115KB
557KB
68KB
4092KB
53KB
273KB
157KB
847KB
453KB
86KB
70KB
85KB
131KB
79KB
147KB
220KB
629KB
408KB
973KB
23KB
3221KB
3221KB
131KB
114KB
123KB
20KB
479KB
146KB
147KB
904KB
404KB
5596KB
1227KB
3221KB
2407KB
736K
1022KB
31MB
523KB
2724KB
1683KB
683KB
5408KB
476KB
1150KB
726KB
4205KB
692KB
5250KB
3007KB
52KB
386KB
30.5MB
257KB
43KB
1358KB
341KB
466KB
109KB
crash
crash
no inst.
timeout
no inst.
crash
timeout
timeout
timeout
timeout
hang
timeout
timeout
timeout
crash
crash
crash
timeout
timeout
timeout
timeout
timeout
timeout
timeout
timeout
timeout
crash
timeout
crash
crash
crash
timeout
crash
timeout
timeout
timeout
timeout
timeout
timeout
timeout
peverify.exe
tar.exe
link.exe
esentutl.exe
macdll.dll
tmxviewer.exe
input creation failed
input creation failed
no inst.
CreateProc fail
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔