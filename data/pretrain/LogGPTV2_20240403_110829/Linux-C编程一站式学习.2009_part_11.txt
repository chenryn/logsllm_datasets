return;
return;
，表达式的值必然是事先计算好了存在一个临时变量里的，
........
，要么就是像上例这样的笔误，语义错误。还有一
C语言的传参规则是Callby Value，按值传递，
变
空间释放；
函数已经退出，
量用完就释放＊/
读完值就释放它，
说明跟你预想的不一样，
 在程序中通常充当控制表达式，
，你不可能故意写出一行永远不会被执行的代码，
局部变量x已经释放,
而不能往它里面存新的值，换句话说，
。is_even这个函数写得有点啰嗦，
，虽然函数的返回值可以看作是一
要么是你对所有可能的情况分析
 所以不可能在这时候才
函数名通常带
一些时候，对程序中所
现在我们知道返回
，然后函数退
B
---
## Page 85
[ 有的代码路径没有返回值的问题编译器是可以检查出来的，如果编译时加-wal1选项会报警告。
2、编写一个函数double myround(double x)，
被4整除，
1、编写一
习题 请点评
第5章深入理解函数
求绝对值的，我们通常不必自己写绝对值函数。
的现象都不一样,
中x==0时返回的不确定值就是
但很快你就会认识到，
辑[]。虽然到现在为止你见到了各种各样的编译器错误提示，也许你已经十分讨厌编译器报错了，
以上两段代码都不会产生编译错误，编译器只做语法检查和最简单的语义检查，而不检查程序的逻
用
等学到第1节“函数调用"你就知道为什么了。另外注意这个例子中把-号当负号用而不是当减号
出函数，
这个函数被定义为返回int,
出来了。然后你花了
序交给用户，
函数，在你测试的时候运行得很好，
辑非运算符相同，
，事实上+号也可以这么用。正负号是单目运算符，而加减号是双目运算符，正负号的优先级和
，什么也不返回，C语言对于这种情况会返回什么结果是未定义的，
int absolute_value(int x)
，但不能被100整除，那么这一年就是闰年，
，起初的几天里
而且这个错误很难复现,
if(×
 return x;
它帮你节省了大量的调试时间。另外，
里相安无事，
是0，
就应该在任何情况下都返回int,
(x
如果当初编译器能报个错多好啊！所以，如果编译器报错了，
 然后你放心地把它集成到一个数万行的程序之中。然后你把这
，也许是你没有测到x==0的情况，
全国嵌入式人才培训基地
之后每过几个星期就有用户报告说程序出错，
你想让它出现时它就不出现,
，输入一个小数，将它四舍五入。
起始页
上一级
此外，能被400整除的年份也是闰年。
判断参数year是不是闰年。如果某年份能
 但是上面这个程序在x==0时安静地退
，在math.h中有一
几天之后终于幸运地找到了
也许刚好在你的环境
在你毫无防备时它又突
，通常返回不确定的值，
。例如myround(-
一个fabs函数就是
2.增量式开发
但每次出
下一页
8
不
错
个
这
X
---
## Page 86
初学者写到这里就已经不太自信了：这个函数定义写得对吗？虽然我是按我理解的语法规则写的，
先写一个简单的函数定义：
首先编写aistance这个函数，我们已经明确了它的参数是两点的坐标，返回值是两点间距离，可以
2.增量式开发 请点评
但书上没有和这个一模一
出。首先分析和分解问题，把大问题分解成小问题，再对小问题分别求解。这个问题可分为两步：
现在问题来了：我们要编一个程序求圆的面积，
（Incremental）开发的思路，很适合初学者。
识。但是如果从头开始编写一
目前为止你看到了很多示例代码，
上一页
2．上一步算出的距离是圆的半径，
，然后立刻测试这个函数定义得有没有错：
返回值是area。
也可以用我们学过的C语言表达式来解决，这个公式也可以实现成一个函数，参数是radius,
 area = T·radius2
数是两点的坐标，返回值是distance。
括号里的部分都可以用我们学过的C语言表达式来表示，
double distance(double xl, double yl, double x2, double y2) 
int main(void)
因此这个小问题全部都可以用我们学过的知识解决。这个公式可以实现成一个函数，参
return 0;
printf("distance is %f\n", distance(1.0, 2.0, 4.0, 6.0));
return 0.0;
一样的例子,
一个程序解决某个问题，应该按什么步骤来写呢？本节提出一种增量式
也在它们的基础上做了很多改动并在这个过程中巩固所学的知
万-
，已知圆的半径之后求面积的公式是：
第5章深入理解函数
全国嵌入式人才培训基地
一不小心遗漏了什么呢？既然不自信就不要再往下写了，
2.增量式开发
，圆的半径以两个端点的坐标(x1,y1)和(x2, V2)给
-................
下一
8
没
贝
---
## Page 87
这个办法找出来。以后我们会介绍程序调试工具gdb，它提供了更强大的调试功能帮你分析更隐蔽
离和y坐标距离都没问题了，
这样如果以后出了新的Bug又需要跟踪调试时，
再加上脚手架，
是房子的一部分，
我们用来测试的main函数,
够验证程序算得对不对。
出来看看。把它和上面的main函数一起编译运行，
当然，现在函数还没实现，计算结果肯定是不对的。现在我们再往函数里添一点代码：
两点间距离应该是5.0，你必须事先知道正确答案是5.0，这样你才能测试程序计算的结果对不对。
测试时给这个函数的参数是(1.0,2.0)和(4.0,6.0),
有
编译,
可
题
然
这个函数：
没，
先前的正确版本做参照,
行，确保没问题
后再编译、运行，
果你不确定dx和dy这样初始化行不行，
，这样就避免了必须从很多行代码中查找分析到底是哪一行出的问题。在这个过程中printr功
一个更高明的解决办法：
你怀疑哪一
运行，
例 5.1. distance函数
double distance(double xl, double yl, double x2, double y2)
double distance(double xl, double yl, double x2, double y2)
double distance(double xl, double yl, double x2, double y2)
-..-..-..-..-.....-
一切正常。
这很麻烦，
一行代码有问题，
return 0.0;
double
double dy = y2 - yl;
double dx = x2 - 
return 0.0;
double
房子盖好之
return 0.0;
了再写一
double
￥
看看是不是得25.0。这样的增量式开发非常适合初学者，
.-...........
一旦验证无误，
这时你就会建立起信心了：既然没问题，
dsquared
：把Scaffolding的代码注释掉。
dy
，改动之后如果出了问题，
要是当初不用拆就好了
都起到了类似脚手架（Scaffold）的作用：在盖房子时很有用，
下面求它们的平方和：
后就可以拆掉了。房子盖好之后可能还需要维修、加盖、翻新，又要
2
........
一方面在写代码时更有信心，
xl;
xl;
x1;
函数里的这句打印就可以撤掉了
，那么就此打住，
， dsquared);
还可以把这句重新加进代码中使用。两点的x坐标距
，由于我们事先知道结果应该是3.0和4.0，
 两点的x坐标距离是3.0,
，几乎可以肯定就是刚才改的那行代码出的问
可是不拆不行，
，在函数里插一条打印语句把dx和dy的值打
，另一方面也方便了调试：总是有
就不用管它了，
，不拆多难看啊。写代码却可以
像这种打印语句，
y坐标距离是4.0，因此
，任何错误都可以通过
 每写一行代码都编译
继续往下写。
，但它不
因此
8
在
能
---
## Page 88
也可以这样:
的长度，再把这个长度传给area函数：
整个问题呢？给出半径的两端点坐标(1.0,2.0)和(4.0,6.0)求圆的面积，
给出两点的坐标求距离，给出半径求圆的面积，这两个子问题都解决了，
接下来编写area这个函数：
完(x2-x1)把结果存在一个临时变量dx里,
便，而且有时候可以避免不必要的计算，
个函数就一个语句,
这样写简洁得多了。
以帮你节省大量的调试时间,
试，
然后编译运行,
定会有Bug的，到那时候再找Bug就难了。
而不是像现在这样每写-
double result = 
double area(double radius)
double distance(double xl, double yl, double x2, double y2)
看看是不是得5.0。
4.0, 6.0));
int main(void)
y2)
double distance(double xl, double yl, double x2, double
 return 3.1416 * radius * radius;
return sqrt((x2-xl）*(x2-xl）+(y2-yl）*(y2-yl));
插printr都没地方插。所以用临时变量有它的好处，使程序更清晰，调试更方
。但如果写错了呢？只知道是这一长串表达式有错，
printf("distance is %f\n", distance(1.0, 2.0,
return 0;
return result;
double result = sqrt(dsquared);
double
double
area(radius);
一行就测试一次,
不管你有多强，
dsquared
。随着编程经验越来越丰富，
y2
，例如上面这一行表达式要把(x2-x1)计算两遍，如果算
就不需要再算第二遍了。
，2.0, 4.0, 6.0);
1
=
 xl;
，但不管怎么样，
yl;
dx
p ￥ p + xp ￥
增量式开发的思路是很有用的，
你可能每次写若干行代码再一起测
，先用distance函数求出半径
，根本不知道错在哪，
 如何把它们组合起来解决
，而且整
88
它可
---
## Page 89
可以被更上一层
现就是函数的分层设计（Stratify）。
解决问题的过程是把大的问题分成小的问题，
的代码是非常容易出错的，
这样组合是不理想的。这样组合了之后，
句组合到一起：
还有另一种组合的思路，不是把distance和area两个函数调用组合起来，而是把那两个函数中的语
的程序当中的子问题呢？我们可以把先前的两个函数组合起来做成一个新的函数以便日后使用：
我们一直把“给出半径的两端点坐标求圆的面积"这个问题当作整个问题来看，
要
问题时可以用这些函数，在解决第二个大问题时可以复用这些函数。
了删掉，那么如果有些情况只需要求两点间的距离，
避免写重复的代码。封装就是为了复用,
图 5.1.函数的分层设计
double area_point(double xl, double yl, double x2, double y2)
double area_point(double xl, double yl, double x2, double y2)
double result = area(distance(1.0, 2.0, 4.0, 6.0));
area_point
distance
层的函数调用，
main
一个上层函数，
return 3.1416 * radius * radius;
double dx = x2 - xl;
 return area(distance(xl, yl, x2, y2));
double
area
func2
，在任何时候都要尽量避免。因此，
，最终所有的函数都直接或间接地被main函数调用。
上层函数通过调用底层函数来解决更大的问题，
y2
Level 1
Level 2
distance和area是两个底层函数,
yl
，原来写的distance和area两个函数还要不要了呢？如果不
同理，
，小的问题再分成更小的问题，
，把解决各种小问题的代码封装成函数，
上一级
满足不了这样的需要。如果保
 或者只需要给定半径长度求圆的面积
尽可能复用（Reuse）
，解决一些很小的问题，
，这个过程在代码中的体
，如果它也是一个更大
，如下图所示：
，底层和上层函数都
）以前写的代
在解决第一
维护重
28
页
复
---
## Page 90
1. return语句
全国嵌入式人才培训基地
起始页
3.递归
---
## Page 91
用另一个函数－－另一个有着相同函数名和相同代码的函数，调用它就是跳到它的代码里执行，然
方便，我们引入几个临时变量把这个语句拆分
如果参数n不是0应该return什么呢？根据定义
因此，3!=3*2!,
n!=n·(n-1)!
Case）：0的阶乘等于1。
frabjuous
如果定义一个概念需要用到这个概念本身，我们称它的定义是递归的（Recursive）。例如:
3.递归 请点评
数A间接调用自己，这也是递归函数。如果你觉得迷惑，可以把factorial(n-1)这一步看成是在调
数。这里的factorial是直接调用自己，
factorial这个函数居然可以自己调用自己？是的。
0!=1
乘。那n-2的阶乘又是什么？这样下去永远也没完。因此需要定义一个最关键的基础条件（Base
样就算定义完了，
这只是一个玩笑，
道
它
，我们要写一个计算阶乘的函数factorial，先把Base Case这种最简单的情况写进去：
道了1!=1我们再反过来算回去，
自己来定义的，
L二
页
int factorial(int n)
int factorial(int n)
，2!=2*1!,
else {
if (n == 0)
if (n == 0)
比如n的阶乘（Factorial）是这样定义的：n的阶乘等于n乘以n-1的阶乘。如果
如果你在字典上看到这么一个词条肯定要怒了。然而数学上确实有很多概念是月
 return 1;
、1!=1*0!=1*1=1,
return result;
int result = n 
int recurse = factorial(n-l);
return 1;
，2!=2*1!=2*1=2， 3!=3*2!=3*2=6。
，有些时候函数A调用函数B，函数B又调用函数A，也就是函
第5章深入理解函数
全国嵌入式人才培训基地
，正因为有了Base Case，
义
 3.递归
 recurse;
，自己直接或间接调用自己的函数称为递归函
下面用程序来完成这一计算过
，才不会永远没完地数下去，
为了下面的分析
91
知
这
用
---
## Page 92
程
后再返回factorial(n-1)这个调用的下一步继续执行。我们以factorial(3)为例分析整个调用过
，如下图所示：
图 5.2. factorial(3)的调用过程
..........
... retum result;
..... retum result;
int factorial(int n)
 int factorial(int n) 
 int factorial(int n) 
int factorial(int n)
int main(void)
else{
if (n == 0)
else{
if (n == 0)
if (n == 0)
....retum result;
if (n == 0)
return 0;