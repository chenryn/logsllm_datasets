i}i∈[n]), to A.
:= x1,1
i ), to get Enc′(gpk′, ek′
i − x1,b
, and queries its own encryption oracle
), which it forwards to A, where β ∈ {0, 1},
Adversary B2 proceeds as follows.
-Simulation of pk:
Adversary B2 receives (gpk′,{ek′
i}i∈[n] from its experiment. Then, it samples (pkot, mskot,
), and sends pk := (pkot, gpk′,{ek′
i }i∈[n]) ← Setupot(1λ, F m,X,Y
{ekot
, xj,1
-Simulation of OEnc(i, (xj,0
i )):
For all b ∈ {0, 1}, B1 computes wj,b
on input (i, wj,0
depending on the experiment B2 is interacting with.
-Simulation of OKeygen(y1k···kyn):
for all i ∈ [n], B1 uses its own decryption key generation oracle on input yi to get dk′
KeyGen′(gpk′, msk′
since it knows mskot. It sends dky1k···kyn := ({dk′
-Simulation of OCorrupt(i):
B1 returns ekot
β ∈ {0, 1}, when B2 interacts with many-AD-INDFE
to A. Therefore,
Advmany-AD-IND
i :=
i, yi). It computes z := KeyGenot(pkot, mskot, y1k···kyn), which it can do
It is clear that for all
β (1λ, 1n,B2), it simulates the game G1+β
Finally, B2 forwards the outputs α of A to its own experiment.
i}i∈[n], z) to A.
to A.
(λ) =
i
i
FE,B2,n
(cid:12)(cid:12)(cid:12)Prhmany-AD-INDFE
|AdvG1(A) − AdvG2(A)|.
0 (1λ, 1n,B2) = 1i − Prhmany-AD-INDFE
1 (1λ, 1n,B2) = 1i(cid:12)(cid:12)(cid:12) =
112
Chapter 5. Multi-Input Inner-Product Functional Encryption without Pairings
Concrete instances of FE for Inner Product
In this section we discuss three instantiations of our generic construction from Section 5.1.3.
In particular, we show that the existing (single-input) public-key FE schemes proposed by
[ALS16] (that are proven many-AD-IND-secure) satisfy Property 1 (two-step decryption) and
Property 2 (linear encryption). These schemes are presented Section 2.6, recalled here for
completeness.
Inner Product FE from MDDH
Here we present the FE for bounded norm inner product from [ALS16, Section 3], generalized
to the Dk(p)-MDDH setting, as in [AGRW17, Figure 15]. It handles the following functionality
F m,X,Y
: K × X → Z, with X := [0, X]m, K := [0, Y ]m, Z := Z, and for all x ∈ X , y ∈ Y, we
have:
ip
F m
ip (y, x) = hx, yi.
In [ALS16], it was proven many-AD-IND secure under the DDH assumption.
In Sec-
tion 2.6.1, we extend the many-AD-IND security proof from [AGRW17] to the multi-instance
setting. We also show in this section that it satisﬁes Property 1 (two-step decryption) and
Property 2 (linear encryption).
GSetup(1λ, F m,X,Y
G := (G, p, P ) ← GGen(1λ), A ←R Dk(p), gpk := (G, [A])
Return gpk
):
IP
Setup(1λ, gpk, F m,X,Y
W ←R Zm×(k+1)
Return (ek, msk)
IP
p
):
, ek := [WA], msk := W
Enc(gpk, ek, x):
r ←R Zk
p
Return(cid:20) −Ar
Return(cid:18)W⊤y
x + WAr(cid:21) ∈ Gk+m+1
y (cid:19) ∈ Zk+m+1
KeyGen(gpk, msk, y):
p
Dec(gpk, [c], d):
C := [c⊤d]
Return log(C)
Figure 5.7: FE, a functional encryption scheme for the functionality F m,X,Y
security is based on the Dk(p)-MDDH assumption.
IP
, whose many-AD-IND
Proof of Property 1 (two-step decryption).
1. The algorithm GSetup⋆(1λ, F m,X,Y
, 1n) works the same as GSetup except that it addi-
tionally uses n to ensure that n · m · X · Y = poly(λ) (which implies n · m · X · Y  2l(λ) for an l(λ) = poly(λ) such
N 2,
that factoring is λ-hard, and set N := pq ensuring that m · X · Y  √λ · N 5/2, and for all j ∈ [m], hj := gsj mod N 2.
ek := {hj}j∈[m], msk := {sj}j∈[m]
Return (ek, msk)
N 2
Enc(gpk, ek, x ∈ Zm):
r ←R {0, . . . ,⌊N/4⌋}, C0 := gr ∈ ZN 2, for all j ∈ [m], Cj := (1 + xjN) · hr
Return ctx := (C0, . . . , Cm) ∈ Zm+1
KeyGen(gpk, msk, y ∈ Zm):
d :=Pj∈[m] yjsj ∈ Z.
Return sky := (d, y)
Dec(cid:0)gpk, sky := (d, y), ctx):
j (cid:17) · C −d
C :=(cid:16)Qj∈[m] C yj
0 mod N 2.
Return log(1+N )(C) := C−1 mod N 2
.
N
j ∈ ZN 2
Figure 5.9: Functional encryption scheme for the class F m,X,Y
IP
, based on the DCR assumption.
G as the subgroup of Z∗
E : ZN × Z → G deﬁned for all γ ∈ ZN , noise ∈ Z as
N 2 of order N generated by (1 + N), and the encoding function
We let Dec1 and Dec2 be the ﬁrst and second line of Dec in Figure 5.9.
E(γ, noise) := 1 + γ · N mod N 2.
2. We have for all x, y ∈ Zm,
Dec1(dky := (d, y), ctx) := Yj∈[m]
Cyj
j  · C−d
0 mod N 2 = E(hx, yi mod N, 0).
3. It is straightforward to see that see that E(γ, 0) can be eﬃciently computed from public
information.
4. It is also easy to see that E is linear.
5. Finally, for all γ ∈ Z such that γ ≤ n · m · X · Y < N, it holds
Dec2(E(γ, 0)) := E(γ, 0) − 1 mod N 2
N
= γ.
Property 2 (linear encryption). For all x′ ∈ Zm and (C0, C′
Add((C0, C1, . . . , Cm), x′) computes C′
puts (C0, C′
1, . . . , C′
hr
1, . . . , (1 + xmN) · hr
let
jN) mod N 2 for all j ∈ [m] and out-
m). Then, for all x, x′ ∈ Zm, and (C0, C1, . . . , Cm) := (gr, (1 + x1N) ·
m) ∈ Zm
j := Cj · (1 + x′
m) ∈ Zm+1
N 2, we have:
1, . . . , C′
N 2
,
Add((C0, C1, . . . , Cm), x′) = (gr, (1 + (x1 + x′
1 mod N 2, . . .
, (1 + (xm + x′
1)N) · hr
= Enc(cid:0)mpk, (x + x′ mod N)(cid:1).
m)N) · hr
m mod N 2)
116
Chapter 5. Multi-Input Inner-Product Functional Encryption without Pairings