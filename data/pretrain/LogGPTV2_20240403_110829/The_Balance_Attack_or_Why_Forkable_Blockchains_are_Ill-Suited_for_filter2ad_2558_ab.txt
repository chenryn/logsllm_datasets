(c) view (cid:2)3
(d) global state (cid:2)0 =
(cid:2)1 ∪ (cid:2)2 ∪ (cid:2)3
Figure 1: The global state (cid:2)0 of a blockchain results from
the union of the distributed local views (cid:2)1, (cid:2)2 and (cid:2)3 of the
blockchain
the presentation, the graph G is static meaning that no nodes
can join and leave the system, however, nodes may fail as
described in Section II-A2. As we consider a network poten-
tially shared by other applications and subject to contention,
we assume that the system is partially synchronous in that
there is a bound on the delay of messages but that this bound
can be large and is not known by the algorithm [12].
1) Miners try to create new blocks: Miners have the
role of creating blocks, by sometimes provably solving a
hashcash crypto-puzzle [3]. Given a global threshold and
the block of largest index the miner knows, trying to solve
a crypto-puzzle consists of repeatedly selecting a nonce
and applying a pseudo-random function to this block and
the selected nonce until a result lower than the threshold
is obtained. Upon success the miner creates a block that
contains the successful nonce as a proof-of-work as well as
the hash of the previous block, hence ﬁxing the index of
the block, and broadcasts the block. As there is no known
strategy to solve the crypto-puzzle, the miners simply keep
testing whether randomly chosen numbers solve the crypto-
puzzle. The mining power is thus expressed in the number
of hashes the miner can test per second, or H/s for short.
The difﬁculty of this crypto-puzzle, deﬁned by the threshold,
limits the rate at which new blocks can be generated by the
network.
2) The failure model: We assume the presence of an
adversary that can control attacker or malicious nodes that
together own a relatively small fraction 0 < ρ < 1
2 of
the total mining power of the system. The nodes controlled
by the adversary may not follow the protocol speciﬁcation,
however, they cannot impersonate other nodes while issuing
transactions.3 A node that is not malicious is correct.
abstraction: Let
the
blockchain be a directed acyclic graph (DAG) (cid:2) = (cid:2)B, P(cid:3)
such that blocks of B point to each other with pointers P
(pointers are recorded in a block as a hash of the previous
block) and a special block g ∈ B, called the genesis block,
does not point to any block but serves as the common ﬁrst
blockchain
forkable
3) The
3This is typically ensured through public key crypto-systems.
581
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:34 UTC from IEEE Xplore.  Restrictions apply. 
selections: Nakamoto’s consensus protocol (Alg. 2) present
in Bitcoin [33] and the GHOST consensus protocol (Alg. 3)
present in Ethereum [41].
Nakamoto’s consensus algorithm: The difﬁculty of the
crypto-puzzles used in Bitcoin produces a block every 10
minutes in expectation. The advantage of this long period,
is that it is relatively rare for the blockchain to fork because
blocks are rarely mined during the time others are propa-
gated to the rest of the nodes.
Algorithm 2 Nakamoto’s consensus protocol at node pi
6: m = 5, the number of blocks to be appended after the one containing
7:
tx , for tx to be committed in Bitcoin
8: get-main-branch()i:
9:
10:
11:
12:
13:
14:
15:
b ← genesis-block(Bi)
while b.next (cid:6)= ⊥ do
block ← argmaxc∈children(b)
B ← B ∪ {block}
P ← P ∪ {(cid:3)block , b(cid:4)}
b ← block
return (cid:3)B, P(cid:4)
{depth(c)}
 select the longest branch
 start from the blockchain root
 prune shortest branches
 deepest subtree
 update vertices of main branch
 update edges of main branch
 move to next block
 returning the Bitcoin main branch
Figure 2: Nakamoto’s consensus protocol at the heart of
Bitcoin selects the main branch as the longest branch (in
black) whereas the GHOST consensus protocol at the heart
of Ethereum follows the heaviest subtree (in grey)
Algorithm 3 The GHOST consensus protocol at node pi
6: m = 11, the number of blocks to be appended after the one containing
tx , for tx to be committed in Ethereum (since Homestead v1.3.5)
7:
16: depth(b)i:
17:
18:
if children(b) = ∅ then return 1
else return 1 + maxc∈children(b) depth(c)
 depth of tree rooted in b
 stop at leaves
 recurse at children
Algorithm 2 depicts the Bitcoin-speciﬁc pseudocode that
includes Nakamoto’s consensus protocol
to decide on a
particular block at index i (lines 8–18) and the choice of
parameter m (line 6) explained later in Section II-B. When a
fork occurs, Nakamoto’s protocol resolves it by selecting the
longest branch as the main branch (lines 8–15) by iteratively
selecting the root of the deepest subtree (line 11). When
process pi is done with this pruning, the resulting branch
becomes the main branch (cid:2)Bi, Pi(cid:3) as observed by the local
process pi. Note that the pseudocode for checking whether a
block is decided and a transaction committed based on this
parameter m is common to Bitcoin and Ethereum, it is thus
deferred to Alg. 4.
6) The GHOST consensus algorithm: As opposed to the
Bitcoin protocol, Ethereum generates one block every 12–
15 seconds. While it improves the throughput (transactions
per second) it also favors transient forks as miners are more
likely to propose new blocks without having heard about
the latest mined blocks yet. To avoid wasting large mining
efforts while resolving forks, Ethereum uses the GHOST
(Greedy Heaviest Observed Subtree) consensus algorithm
that accounts for the, so called uncles, blocks of discarded
branches. In contrast with Nakamoto’s protocol, the GHOST
protocol iteratively selects, as the successor block, the root
of the subtree that contains the largest number of nodes (cf.
Algorithm 3).
The main difference between Nakamoto’s consensus pro-
tocol and GHOST is depicted in Figure 2, where the black
blocks represent the main branch selected by Nakamoto’s
consensus protocol and the grey blocks represent the main
8: get-main-branch()i:
9:
10:
11:
12:
13:
14:
15:
b ← genesis-block(Bi)
while b.next (cid:6)= ⊥ do
block ← argmaxc∈children(b)
B ← B ∪ {block}
P ← P ∪ {(cid:3)block , b(cid:4)}
b ← block
return (cid:3)B, P(cid:4).
{num-desc(c)}
 select the branch with the most nodes
 start from the blockchain root
 prune lightest branches
 heaviest tree
 update vertices of main branch
 update edges of main branch
 move to next block
 returning the Ethereum main branch
16: num-desc(b)i:
17:
18:
if children(b) = ∅ then return 1
else return 1 +
 number of nodes in tree rooted in b
 stop at leaves
c∈children(b) num-desc(c)  recurse at children
(cid:2)
branch selected by GHOST. Note that Ethereum adapted
GHOST to account for the difﬁculties of blocks in the choice
of the heaviest subtree [39].
B. Decided blocks and committed transactions
A blockchain system S must deﬁne when the block at an
index is agreed upon. To this end, it has to deﬁne a point
in its execution where a preﬁx of the main branch can be
“reasonably” considered as persistent.4 More precisely, there
must exist a parameter m provided by S for an application
to consider a block as decided and its transactions as
committed. This parameter is typically mbitcoin = 5 in
Bitcoin (Alg. 2, line 6) and methereum = 11 in Ethereum
(Alg. 3, line 6). Note that these two choices do not lead to
the same probability of success [18] and different numbers
are used by different applications [35].
Deﬁnition 1 (Transaction commit). Let (cid:2)i = (cid:2)Bi, Pi(cid:3) be the
blockchain view at node pi in system S. For a transaction
4In theory, there cannot be consensus on a block at a partiular index [16],
hence preventing persistence, however, applications have successfully used
Ethereum to transfer digital assets based on parameter methereum =
11 [35].
582
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:34 UTC from IEEE Xplore.  Restrictions apply. 
tx to be locally committed at pi, the conjunction of the
following properties must hold in pi’s view (cid:2)i:
1) Transaction tx has to be in a block b0 ∈ Bi of the
main branch of system S. Formally, tx ∈ b0 ∧ b0 ∈
i : (cid:2)B
(cid:3)
B
2) There should be a subsequence of m blocks b1, ..., bm
appended after block b. Formally, ∃b1, ..., bm ∈ Bi :
(cid:2)b1, b0(cid:3),(cid:2)b2, b1(cid:3), ...,(cid:2)bm, bm−1(cid:3) ∈ Pi. (In short, we
say that b0 is decided.)
i(cid:3) = get-main-branch()i.
(cid:3)
(cid:3)
i, P
A transaction tx is committed if there exists a node pi such
that tx is locally committed.
Property (1) is needed because nodes eventually agree on
the main branch that deﬁnes the current state of accounts in
the system—blocks that are not part of the main branch
are ignored. Property (2) is necessary to guarantee that
the blocks and transactions currently in the main branch
will persist and remain in the main branch. Before these
additional blocks are created, nodes may not have reached
consensus regarding the unique blocks b at index j in the
chain. This is illustrated by the fork of Figure 1 where nodes
consider, respectively, the pointer (cid:2)b1, g(cid:3) and the pointer
(cid:2)b2, g(cid:3) in their local blockchain view. By waiting for m
blocks were m is given by the blockchain system, the system
guarantees with a reasonably high probability that nodes will
agree on the same block b. Note that the property is not
preﬁx-closed in the sense that get-main-branch may return
a chain that is not necessarily a preﬁx of another branch
returned later.
Algorithm 4 Checking transaction commit at node pi
19:
20:
21:
22:
23:
24:
is-committed(tx )i:
 check whether transaction is committed
(cid:3)B(cid:3)
i(cid:4) ← get-main-branch()  pick main branch with Alg. 2 or 3
i, P (cid:3)
if ∃b0 ∈ B(cid:3)
 tx in main branch
(cid:3)b1, b0(cid:4), (cid:3)b2, b1(cid:4)..., (cid:3)bm, bm−1(cid:4) ∈ Pi then  enough blocks
return true
i : tx ∈ b0 ∧ ∃b1, ..., bm ∈ Bi :
else return false
For example, consider a ﬁctive blockchain system with
mﬁctive = 2 that selects the heaviest branch (Alg. 3, lines 8–
15) as its main branch. If the blockchain state was the
one depicted in Figure 2, then blocks b2 and b5 would be
decided and all their transactions would be committed. This
is because they are both part of the main branch and they
are followed by at least 2 blocks, b8 and b13. (Note that we
omit the genesis block as it is always considered decided
but does not include any transaction.)
III. THE BALANCE ATTACK
The Balance attack demonstrates a fundamental limita-
tion of main proof-of-work systems in that they are not
immutable.
Deﬁnition 2 (Corruptibility). A blockchain system is cor-
ruptible if an adversary can:
1) make the recipient of a transaction tx observe that tx
is committed and
with probability 1 − ε.
2) later remove the transaction tx from the main branch,
The Balance attack is simple: while the attacker disrupts
communications between correct subgroups of equivalent
mining power, it simply issues transactions in one subgroup.
The attacker then mines sufﬁciently many blocks in another
subgroup to ensure with high probability that the subtree
of another subgroup outweighs the transaction subgroup’s.
Even though the transactions are committed, the attacker
can rewrite with high probability the blocks that contain
these transactions by outweighing the subtree containing this
transaction.
Note that one could beneﬁt from delaying messages
only between the merchant and the rest of the network by