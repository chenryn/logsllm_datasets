  面向对象编程的优点在于，如果你需要修改程序，计算另一种图形的面积，比如三角形，你只需要再另外增加一块相应的代码就可以了，甚至可以不修改程序的其他部分。但是，批评者会反驳说，这种方法的缺点是，由于增加代码不用考虑其他部分，结果往往导致写出性能不佳甚至有副作用的代码，就好比造房子不考虑已经完成的部分一样。
  关于面向对象编程优劣的争论并不像静态类型与动态类型之争那样壁垒分明，因为编程的时候你只能在静态类型和动态类型之中选一种。但是，面向对象编程只是程度不同的问题。事实上有两种程度的面向对象编程：某些语言允许你以这种风格编程，另一些语言则强迫你一定要这样编程。
  我觉得后一类语言不可取。允许你做某事的语言肯定不差于强迫你做某事的语言。所以，至少在这方面我们可以得到明确的结论：你应该使用允许你面向对象编程的语言。至于你最后到底用不用则是另外一个问题了。
文艺复兴
  有一件事，我想所有软件业的人都会同意，那就是最近出现了很多新的编程语言。直到20世纪80年代，只有大机构才买得起开发编程语言所需的硬件，所以大多数编程语言都是大公司的教授或者研究员开发的。而现在，一个高中生就能搞到所有必需的硬件。
  Perl语言的设计者拉里·瓦尔^的例子启发了很多黑客：为什么不动手设计一种自己的语言呢？只要你懂得驾驭开源软件社区，就会有很多人在短期内为你提供大量的代码。
^“Larry Wall（1954-）在大学里主修语言学。1987年为了使管理机房的工作变得方便，他在业余时间创造了Perl语言。——译者注”
  结果就是产生了一些也许可以称为“头重脚轻”的语言：它们的内核设计得并非很好，但是却有着无数强大的函数库，可以用来解决特定的问题。（你可以想象一辆本身性能很差的小汽车，车顶却绑着一个飞机发动机。）有一些很琐碎、很普遍的问题，程序员本来要花大量时间来解决，但是有了这些函数库以后，解决起来就变得很容易，所以这些库本身可能比核心的语言还要重要。所以，这些奇特组合的语言还是蛮有用的，一时间变得相当流行。车顶上绑着飞机发动机的小车也许真能开，只要你不尝试拐弯，可能就不会出问题^。
^“提醒各位亲爱的黑客，我只是打一个比方，请不要尝试在车顶绑上飞机发动机。另外，可以认为这类“头重脚轻”的语言存在已久，Fortran语言的流行主要就是因为它的函数库。”
  另一个结果就是语言的多样化。编程语言之间总是存在很大区别。Fortran、Lisp、APL都是1970年以前开发出来的，它们之间的区别大得就像海星、熊、蜻蜓之间的区别。新兴的开源编程语言肯定将继承这种传统。
  现在好像每隔一段日子就能听到一种新出现的语言。乔纳森·埃里克森把这种现象称为“编程语言的文艺复兴”。人们有时还会用另一个说法，即“编程语言的战争”。这并不矛盾，文艺复兴时期就是存在很多战争的。
  实际上，很多历史学家相信战争是文艺复兴的一个副产品^。当时，欧洲活力旺盛可能就是因为它分成许多互相竞争的小国。它们互相毗邻，所以新思想能够从一个国家传播到另一个国家，但是它们又互相独立，使得单个的统治者无法遏制创新的发展。相比之下，中国古代的封建皇朝禁止民间建造大型的远洋船只，阻止了经济的正常发展。
^“参见Carlo Cipolla所著的《枪，帆船，帝国：技术革新在1400～1700年欧洲扩张早期阶段的作用》（Guns，Sails，and Empires: Technological Innovation and the Early Phases of European Expansion 1400-1700），Pantheon，1965年出版。”
  所以，程序员活在这个文艺复兴时代可能是一件好事。如果我们所有人都使用同一种编程语言，反而有可能是坏事。
11.百年后的编程语言
  很难预测一百年后的人类生活，只有少数几件事是可以确定的。那时，汽车将具备低空飞行能力，城市规划的法规将放宽，大楼可以造到几百层，大街上一天到晚看不见太阳，女性个个都学过防身术。本文只想讨论其中的一个细节：一百年后，人们使用什么语言开发软件？
  为什么这个问题值得思考？原因不是我们最终会用上这些语言，而是幸运的话，我们从现在开始就能用上这些语言。
  我认为，编程语言就像生物物种一样，存在一个进化的脉络，许许多多分支最终都会成为进化的死胡同。这种现象已经发生了。Cobol语言曾经流行一时，但是现在看来没有任何后续语言继承它的思想。它就像尼安德特人^一样，进化之路已经走到了尽头。
^“尼安德特人（Neanderthal），一种生活在欧洲的古人类，三万多年前已经全部灭绝。——译者注”
  我预言Java也会如此。有人写信说：“你怎么能说Java不会成功呢？它已经成功了。”我觉得这要看你的成功标准是什么。如果标准是相关书籍的出版量，或者是相信学会Java就能找到工作的大学生数量，那么Java确实已经成功了。当我说Java不会成功时，我的意思是它和Cobol—样，进化之路已经走到了尽头。
  这只是我的猜测，未必正确。这里的重点不是看衰Java，而是提出编程语言存在一个进化的脉络，从而引导读者思考，在整个进化过程中，某一种语言的位置到底在哪里？之所以要问这个问题，不是为了一百年后让后人感叹我们曾经如此英明，而是为了找到进化的主干。它会启发我们去选择那些靠近主干的语言，这样对当前的编程最有利。
  无论何时，选择进化的主干可能都是最佳方案。要是你不幸选错了，变成了一个尼安德特人，那就太糟了。你的对手克鲁马努人时不时就会来攻打你，把你的食物全部偷走。
  这就是我想找出一百年后的编程语言的原因。我不愿意押错赌注。
  编程语言的进化与生物学进化还是有区别的，因为不同分支的语言会发生聚合。比如，Fortran分支看来正在与Algol^的继承者聚合。理论上，不同的生物物种也可能发生聚合，但是可能性很低，所以大概从来没有真正出现过。
^“Algol语言诞生于20世纪50年代，是最早的计算机语言之一，对后来的许多语言产生了极大的影响。——译者注”
  编程语言之所以可能出现聚合，一个原因是它的概率空间^较小，另一个原因是它的突变不是随机的。语言的设计者们总是有意识地借鉴其他语言的设计思想。
^“概率空间是一个数学术语，大致指概率的可能取值范围。这里的意思是，不管编程语言怎么变，它的形式总是很有限的。——译者注”
  对于语言设计者来说，认清编程语言的进化路径特别有用，因为这样就可以照着样子设计语言了。这时，认清进化的主干就不仅有助于识别现存的优秀语言，还可以把它当作设计语言的指南。
  任何一种编程语言都可以分成两大组成部分：基本运算符的集合（扮演公理的角色）以及除运算符以外的其他部分（原则上，这个部分可以用基本运算符表达出来）。
  我认为，基本运算符是一种语言能否长期存在的最重要因素。其他因素都不是决定性的。这有点像买房子的时候你应该先考虑地理位置。别的地方将来出问题都有办法弥补，但是地理位置是没法变的。
  慎重选择公理还不够，还必须控制它的规模。数学家总是觉得公理越少越好，我觉得他们说到了点子上。