i
a
t
n
o
c
d
e
t
a
m
i
t
s
E
1 0 0
8 0
6 0
4 0
2 0
1 0 0
0
0
2 0
4 0
8 0
T ru e  c o n ta in m e n t (% )
6 0
1 0 0
(a) Low cardinality = 10, 000
(b) High cardinality = 10, 000, 000
Fig. 7: Estimation of containment with ﬁxed cardinalities. The bars indicate the 95th and 5th percentiles of the
estimates.
)
%
(
t
n
e
m
n
i
a
t
n
o
c
d
e
t
a
m
i
t
s
E
1 0 0
8 0
6 0
4 0
2 0
0
0 .0
2 .5
5 .0
7 .5
1 0 .0
C a rd in a lity  ra tio
1 2 .5
1 5 .0
1 7 .5
2 0 .0
Fig. 8: Estimation of containment with varying cardinal-
ity ratio. The true containment is 50%. The bars indicate
the 95th and 5th percentiles of the estimates.
to estimate the uniqueness distribution and pairwise
containment of very large databases at scale.
The efﬁciency and scalability of risk analysis using
KHLL represent a practical and useful tool for large
organizations in protecting user privacy. It provides an
objective, quantiﬁable and replicable measure of reiden-
tifability of data sets. The KHLL algorithm also presents
a novel and practical approach for tackling the joinability
risks of data sets and ID spaces. The efﬁciency of KHLL
further enables periodic analyses of complex production
systems that evolve over time. We described the practical
use of KHLL for protecting user privacy.
Future work: While KHyperLogLog is memory ef-
ﬁcient,
it still requires a linear pass over the data.
Techniques to produce sketches suitable for joinability
analysis without scanning the entire data set would be
helpful. It would also be interesting to see more innova-
tive use of approximate counting in privacy enhancing
techniques (including data anonymization) rather than
just for risk analysis purposes.
ACKNOWLEDGMENT
We thank Lea Kissner, Jessica Staddon, Rebecca Bale-
bako, Lorenzo Martignoni, Nina Taft and the anonymous
reviewers for the valuable feedback on the earlier version
of the paper. We also thank all colleagues who have
contributed directly or indirectly to the work.
REFERENCES
[1] L. Sweeney, “K-anonymity: A model for protecting privacy,”
Int. J. Uncertain. Fuzziness Knowl.-Based Syst., vol. 10,
no. 5, pp. 557–570, Oct. 2002. [Online]. Available: http:
//dx.doi.org/10.1142/S0218488502001648
[2] A. Machanavajjhala, D. Kifer, J. Gehrke, and M. Venkitasub-
ramaniam, “L-diversity: Privacy beyond k-anonymity,” ACM
Trans. Knowl. Discov. Data, vol. 1, no. 1, Mar. 2007. [Online].
Available: http://doi.acm.org/10.1145/1217299.1217302
[3] P. Jaccard, “Lois de distribution ﬂorale dans la zone alpine,”
vol. 38, pp. 69–130, 01 1902.
[4] A. Broder,
“On the
resemblance
and containment of
documents,” in Proceedings of the Compression and Complexity
of Sequences 1997, ser. SEQUENCES ’97. Washington, DC,
USA:
[Online].
Available: http://dl.acm.org/citation.cfm?id=829502.830043
IEEE Computer Society, 1997, pp. 21–.
(cid:20)(cid:23)(cid:19)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:49:06 UTC from IEEE Xplore.  Restrictions apply. 
[5] P. Eckersley, “How unique is your web browser?” in
Proceedings of the 10th International Conference on Privacy
Enhancing Technologies, ser. PETS’10. Berlin, Heidelberg:
Springer-Verlag, 2010, pp. 1–18. [Online]. Available: http:
//dl.acm.org/citation.cfm?id=1881151.1881152
[6] X. Xiao and Y. Tao, “Anatomy: Simple and effective privacy
preservation,” in Proceedings of
the 32Nd International
Conference on Very Large Data Bases, ser. VLDB ’06.
VLDB Endowment, 2006, pp. 139–150. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1182635.1164141
[7] C. Dwork, “Differential privacy,” in Proceedings of
the
33rd International Conference on Automata, Languages and
ICALP’06. Berlin,
Programming - Volume Part
Heidelberg: Springer-Verlag,
[Online].
Available: http://dx.doi.org/10.1007/11787006 1
II, ser.
2006,
pp.
1–12.
[8] A. Narayanan and V. Shmatikov, “Robust de-anonymization
of large sparse data sets,” in Proceedings of the 2008 IEEE
Symposium on Security and Privacy, ser. SP ’08. Washington,
DC, USA:
IEEE Computer Society, 2008, pp. 111–125.
[Online]. Available: https://doi.org/10.1109/SP.2008.33
[9] K. Beyer, P.
J. Haas, B. Reinwald, Y. Sismanis, and
R. Gemulla, “On synopses for distinct-value estimation under
multiset operations,” in Proceedings of
the 2007 ACM
SIGMOD International Conference on Management of Data,
ser. SIGMOD ’07. New York, NY, USA: ACM, 2007,
pp. 199–210. [Online]. Available: http://doi.acm.org/10.1145/
1247480.1247504
[10] P. Flajolet, ´Eric Fusy, O. Gandouet, and et al., “Hyperloglog:
The analysis of a near-optimal cardinality estimation algorithm,”
in IN AOFA ’07: Proceedings Of The 2007 International Con-
ference On Analysis Of Algorithms, 2007.
[11] S. Heule, M. Nunkesser, and A. Hall, “Hyperloglog in practice:
the art cardinality
Algorithmic engineering of a state of
estimation algorithm,” in Proceedings of the 16th International
Conference on Extending Database Technology, ser. EDBT ’13.
New York, NY, USA: ACM, 2013, pp. 683–692. [Online].
Available: http://doi.acm.org/10.1145/2452376.2452456
[12] G. S. Manku, S. Rajagopalan, and B. G. Lindsay, “Approximate
medians and other quantiles in one pass and with limited
memory,” in Proceedings of
the 1998 ACM SIGMOD
International Conference on Management of Data,
ser.
SIGMOD ’98. New York, NY, USA: ACM, 1998, pp. 426–435.
[Online]. Available: http://doi.acm.org/10.1145/276304.276342
[13] Z. Karnin, K. Lang, and E. Liberty, “Optimal quantile approx-
imation in streams,” in 2016 IEEE 57th Annual Symposium on
Foundations of Computer Science (FOCS), Oct 2016, pp. 71–
78.
[14] A. Metwally, D. Agrawal, and A. El Abbadi, “Efﬁcient
computation of frequent and top-k elements in data streams,”
in Proceedings of
the 10th International Conference on
Database Theory, ser. ICDT’05. Berlin, Heidelberg: Springer-
Verlag, 2005, pp. 398–412. [Online]. Available: http://dx.doi.
org/10.1007/978-3-540-30570-5 27
[15] G. Cormode and M. Hadjieleftheriou, “Finding frequent
streams,” Proc. VLDB Endow., vol. 1,
[Online]. Available:
items
no. 2, pp. 1530–1541, Aug. 2008.
http://dx.doi.org/10.14778/1454159.1454225
in data
[16] “Protocol
buffers,”
https://developers.google.com/
protocol-buffers/, [Online, last accessed Oct 28, 2018].
[17] “Semantic types of protocol buffer ﬁelds can be anno-
tated using custom options.” https://developers.google.com/
protocol-buffers/docs/proto#options, [Online, last accessed Oct
28, 2018].
[18] X. Zhu and Z. Ghahramani, “Learning from labeled and unla-
beled data with label propagation,” Tech. Rep., 2002.
[19] J. Dean and S. Ghemawat, “Mapreduce: Simpliﬁed data
processing on large clusters,” Commun. ACM, vol. 51,
no. 1, pp. 107–113, Jan. 2008.
[Online]. Available: http:
//doi.acm.org/10.1145/1327452.1327492
[20] “Evaluating khll accuracy with bigquery,” https://github.com/
google/khll-paper-experiments.
[21] “Decennial census of population and housing,” https://factﬁnder.
census.gov, 2010.
[22] N. Li, T. Li, and S. Venkatasubramanian, “t-closeness: Privacy
beyond k-anonymity and l-diversity,” in 2007 IEEE 23rd In-
ternational Conference on Data Engineering, April 2007, pp.
106–115.
[23] A. Halevy, F. Korn, N. F. Noy, C. Olston, N. Polyzotis,
S. Roy, and S. E. Whang, “Goods: Organizing google’s data
sets,” in Proceedings of
the 2016 International Conference
on Management of Data, ser. SIGMOD ’16. New York,
NY, USA: ACM, 2016, pp. 795–806. [Online]. Available:
http://doi.acm.org/10.1145/2882903.2903730
[24] S. Sen, S. Guha, A. Datta, S. K. Rajamani, J. Tsai, and J. M.
Wing, “Bootstrapping privacy compliance in big data systems,”
in Proceedings of
the 2014 IEEE Symposium on Security
and Privacy, ser. SP ’14. Washington, DC, USA: IEEE
Computer Society, 2014, pp. 327–342. [Online]. Available:
http://dx.doi.org/10.1109/SP.2014.28
[25] Q. Xiao, Y. Zhou, and S. Chen, “Better with fewer bits:
Improving the performance of cardinality estimation of large
data streams,” in IEEE INFOCOM 2017 - IEEE Conference on
Computer Communications, May 2017, pp. 1–9.
[26] G. Cormode and S. Muthukrishnan, “Space efﬁcient mining
of multigraph streams,” in Proceedings of the Twenty-fourth
ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems, ser. PODS ’05. New York, NY,
USA: ACM, 2005, pp. 271–282. [Online]. Available: http:
//doi.acm.org/10.1145/1065167.1065201
[27] ——, “An improved data stream summary: The count-
min sketch and its applications,” J. Algorithms, vol. 55,
no. 1, pp. 58–75, Apr. 2005.
[Online]. Available: http:
//dx.doi.org/10.1016/j.jalgor.2003.12.001
[28] P. Flajolet and G. N. Martin, “Probabilistic counting,” in
Proceedings of the 24th Annual Symposium on Foundations of
Computer Science, ser. SFCS ’83. Washington, DC, USA:
IEEE Computer Society, 1983, pp. 76–82. [Online]. Available:
https://doi.org/10.1109/SFCS.1983.46
[29] M. S. Charikar, “Similarity estimation techniques
from
rounding algorithms,” in Proceedings of
the Thiry-fourth
Annual ACM Symposium on Theory of Computing, ser. STOC
’02. New York, NY, USA: ACM, 2002, pp. 380–388.
[Online]. Available: http://doi.acm.org/10.1145/509907.509965
[30] Y. W. Yu and G. Weber, “Hyperminhash: Jaccard index
sketching in loglog space,” CoRR, vol. abs/1710.08436, 2017.
[Online]. Available: http://arxiv.org/abs/1710.08436
XII. APPENDIX: HLL++ HALF BYTE
Standard HLL++ uses a 64-bit hash. Typically the
counters of trailing zeros in hashes are stored in byte size
values for simplicity and efﬁciency of implementation.
This arrangement is convenient but memory inefﬁcient
because the counts are only in the range [0, 64]. We
(cid:20)(cid:23)(cid:20)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:49:06 UTC from IEEE Xplore.  Restrictions apply. 
storing all hash values instead of in multiple KMV stores.
The size of the table is governed by parameters K1, K2,
corresponding to the number of hashes stored at each
level. We use an amortized strategy where hash values
are stored in sorted order. New hash values are written
to a buffer which is periodically merged into the sorted
list.
Fig. 9: Histogram of the counters of trailing zeros in
hashes computed on our proprietary data sets.
improve the memory signature slightly with the follow-
ing observation. Since hashes are distributed uniformly
between all buckets, the counters tend to be clustered
together. Rather than storing the actual count, we store
count offsets instead. Speciﬁcally, we store a single value
ρ and a table with offset values in the range [0, 16). Real
count values correspond to ρ + offset.
As we see more unique values, all the offsets in the
table increase. When there are no more counters with
offset 0 left, ρ is incremented and each offset in the
table is decremented by 1. It is always possible there
are outlier counters exceeding ρ + 15. We store all such
additional values in an outlier list, merging them back
into the table as ρ increases. As shown in Figure 9, we
validated that the number of outliers is small in practice.
By storing offsets, we reduce the number of bits per
HLL bucket from 8 to 4, allowing us to store 2 buckets in
each byte. The additional elements (ρ and the outlier list)
are small so this effectively allows us to have twice as
many counters for roughly the same memory signature.
Since we use the memory savings to increase the number
of HLL buckets this improves the error rate by a factor
1√
2. This is comparable to the recent HLL-TailCut+
of
algorithm [25] which improves the memory efﬁciency of
HLL by 45%.
XIII. APPENDIX: K2MV
At a high level KHLL stores a K Minimum Values
(KMV) sketch with an HLL sketch for each distinct hash
value (bucket). An alternative we considered and experi-
mented was using KMV sketches instead of HLL for the
individual buckets. We name this K2MV given the two-
level data structure of minimum hash values. To improve
the performance, we implemented this as a single table
(cid:20)(cid:23)(cid:21)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:49:06 UTC from IEEE Xplore.  Restrictions apply.