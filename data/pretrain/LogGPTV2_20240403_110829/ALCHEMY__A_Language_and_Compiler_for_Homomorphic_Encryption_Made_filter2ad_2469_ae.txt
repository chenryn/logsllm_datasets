DSL addition of ciphertexts. This leads to a trivial Add_ instance:
instance (Add_ ctex (Cyc2CT m'map zqs a), Applicative mon)
=> Add_ (PT2CT m'map zqs gad ctex mon) a where
add_ = PC $ pure add_
neg_ = PC $ pure neg_
Here add_ just embeds the ciphertext-DSL function add_ into the
host-language (applicative) monad mon, and similarly for neg_.
Multiplication. By contrast, translating plaintext multiplication
to a full homomorphic ciphertext multiplication is much more
involved, but still has relatively concise code for the amount of
work it does:
instance (Lambda_ ctex, SHE_ ctex, Mul_ ctex (PreMul_ ...),
MonadAccumulator Hints mon,
MonadAccumulator Keys mon,
MonadRandom
mon, ...)
=> Mul_ (PT2CT m'map zqs gad ctex mon) (PNoiseCyc p m zp) where
mul_ = PC $
lamM $ \x -> lamM $ \y -> do
modSwitch_ $:
var x *: var y
keySwitchQuad_ hint .:
hint  LinearCyc_ (PT2CT m'map zqs gad ctex mon) (PNoiseCyc p) where
linearCyc_ f = PC $
lamM $ \x -> do
tunnel_ hint .:
modSwitch_ $: var x
hint  expr env (_ -> PNoiseCyc 0 H5 (Zq 2))
ringRound = (rescaleTree_ @K) .: coeffsToSlots
Note that we have monomorphized the output type as required for
plaintext-to-ciphertext compilation, setting the pNoise parameter
to zero to indicate that no further homomorphic operations are
needed on the output.
-- modulus p = 25 = 32
= 5
8Optionally, we could switch back to the original cyclotomic ring to move the rounded
slot entries back to coefficients, but this is not needed for our application so we omit
it. Switching back would be required for bootstrapping, but fortunately, switching is a
small fraction of the overall running time in the bootstrapping scenario.
5.2 Rounding Homomorphically
Next, we want to use PT2CT to compile the plaintext-DSL function
ringRound to a ciphertext-DSL function that homomorphically
rounds the coefficients of an encrypted input. Recall that to use its
interface pt2ct, we need to specify types for the cyclotomic indices
of ciphertext rings and available ciphertext moduli (see Figure 2):
type H0'
type H1'
type M'Map = [(H0,H0'), (H1,H1'), ...]
-- corpus of ciphertext moduli
type Zqs = [ Zq $(mkModulus 1543651201), ... ]
The type M'Map associates each plaintext ring index with its cipher-
text ring index. The type Zqs is a collection of Zq-types that PT2CT
combines to assign large enough moduli to each ciphertext.
Having defined the necessary types, it is now trivial to compile
= H0 * 7 * 13
= ...
the plaintext computation to its homomorphic counterpart:
homomRingRound = pt2ct @M'Map @Zqs @TrivGad ringRound
Recall that pt2ct yields a monadic value, where the monad needs
to support generation and accumulation of keys and hints, so we
need to use homomRingRound in an appropriate monadic context.
5.3 Homomorphic PRF Evaluation
Now that we have homomRingRound, we can easily implement ho-
momorphic evaluation of RLWR-based PRFs. The simplest such
PRF is defined as Fs (x ) = ⌊H (x ) · s⌉2, where H : X → Rp is a
hash function modeled as a random oracle mapping the PRF input
space to Rp, and ⌊·⌉2 denotes the ring-rounding function. (There
are also variants where H is replaced with a publicly evaluable
function [5, 10], which has no effect on homomorphic evaluation.)
an FHE encryption(cid:72)s of the secret key s ∈ Rp and an input x, we
To homomorphically compute an FHE encryption of Fs (x ) given
multiply-by-a-public-value operation to get an encryption (cid:103)a · s.
first compute the hash value a = H (x ) ∈ Rp, then we use the FHE’s
of the PRF output:⌊a · s⌉2 = 
Finally, we apply homomorphic ring rounding to get an encryption
The following code chooses a uniformly random PRF key s ∈ Rp
to⌊a · s⌉2, and the corpus of generated FHE keys that allows for
and returns s, a host-language function f that maps any a ∈ Rp
decrypting the result:
homomRLWR = do
Fs (x ).
s  homomRingRound) $
flip mulPublic  encrypt s
return (s, f, keys)
Here homomRLWR is a monadic value, where the monad just needs
to provide a source of randomness. The call to runKeysHints
sets up the additional “accumulator monad” context required by
homomRingRound, and outputs the desired host-language function f
along with all the generated FHE keys and hints (the latter of which
we ignore as unneeded).
5.4 Parameters, Security and Performance
The concrete cyclotomic ring indices and ring dimensions we use
are given in Figure 2. Our PRF uses a modulus of p = 25 = 32.
Our entire corpus of ciphertext moduli is altogether less than 2180.
According to the “core-SVP” methodology [2] for estimating the
security of LWE/LWR parameters, our FHE and PRF parameters
have at least 100 bits of security (and this is likely a significant
underestimate).
On an iMac (Retina 5k) late-2015 model with 4 GHz Core i7
and 16 GB RAM, homomorphic evaluation of the PRF itself (after
generating all keys and hints) takes only 10–11 seconds for each
of several runs. Generating the keys and hints takes about 150
seconds, due primarily to a very naive implementation of finite-field
arithmetic in Λ◦λ, which is used for computing decToCRT. These
performance figures were achieved with no compiler optimization
flags turned on (ghc-8.0.2), so even better performance may be
possible; however, certain flags cause compilation to take a great
deal of time and memory.
CT ring index m′
PT ring index m
H′
0 = H0 · 7 · 13
H0 = 27
H′
1 = H1 · 5 · 13
H1 = 26 · 7
H′
H2 = 25 · 7 · 13
2 = H2 · 3 · 5
H′
H3 = 23 · 5 · 7 · 13
3 = H3 · 3 · 5
H′
4 = H4 · 5
H4 = 22 · 3 · 5 · 7 · 13
H5 = 20 · 32 · 5 · 7 · 13 H′
5 = H5 · 5
dimension φ(m′)
4,608
9,216
9,216
11,520
5,760
8,640
Figure 2: Cyclotomic ring indices used for the homomorphic
evaluation of the Ring-LWR PRF.
REFERENCES
[1] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and
[9] Dan Bogdanov, Sven Laur, and Jan Willemson. 2008. Sharemind: A Framework
[12] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. 2014.
[4] Jacob Alperin-Sheriff and Chris Peikert. 2014. Faster Bootstrapping with Polyno-
[5] Abhishek Banerjee and Chris Peikert. 2014.
New and Improved Key-
[2] Erdem Alkim, Léo Ducas, Thomas Pöppelmann, and Peter Schwabe. 2016. Post-
[3] Jacob Alperin-Sheriff and Chris Peikert. 2013. Practical Bootstrapping in Quasi-
[6] Abhishek Banerjee, Chris Peikert, and Alon Rosen. 2012. Pseudorandom Func-
Michael Zohner. 2015. Ciphers for MPC and FHE. In EUROCRYPT. 430–454.
quantum Key Exchange - A New Hope. In USENIX Security Symposium.
linear Time. In CRYPTO. 1–20.
mial Error. In CRYPTO. 297–314.
Homomorphic Pseudorandom Functions. In CRYPTO. 353–370.
tions and Lattices. In EUROCRYPT. 719–737.