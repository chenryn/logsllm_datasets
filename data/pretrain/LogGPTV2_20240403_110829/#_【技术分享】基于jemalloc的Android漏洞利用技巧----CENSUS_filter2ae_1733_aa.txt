# 【技术分享】基于jemalloc的Android漏洞利用技巧----CENSUS
|
##### 译文声明
本文是翻译文章，文章来源：census-labs.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
翻译：[ **arnow117**](http://bobao.360.cn/member/contribute?uid=941579989)
预估稿费：300RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**背景介绍**
**jemalloc的相关研究**
argp与huku在2012年在Phrack上发表的：对jemalloc内存分配器的单独利用(做出了基于FreeBSD上libc的POC)。
argp与huku在2012年BlackHat上发表的：在Firefo中玩坏jemalloc的元数据。
argp在2015年INFILTRATE上的jemalloc漏洞利用方法论。
**Android堆漏洞利用的相关研究**
Hanan Be'er对CVE-2015-3864这个stagefright中整形溢出导致堆破坏的漏洞利用
Aaron Adams的对这个漏洞的又一次利用
Joshua Drake对于stagefright漏洞利用相关工作 向之前的研究者们致谢！（这也是为什么要翻译这一段之必要）
**配合jemalloc使用的插件：Shadow**
**注，因为本文核心是jemalloc与堆漏洞利用，此章节关于对关于插件shadow的历史部分没有翻译。**
shadow是CENSUS开发的的一个基于jemalloc的堆漏洞利用框架，开源在Github([传送门](https://github.com/CENSUS/shadow))上。用来搭配调试器提供jemalloc分配器的内部结构信息。可以作为插件在GDB，WINDBG，以及lldb中使用。
这个框架有几个优点：
没有多余的要附加的源文件。
对于Android与Firefox两个平台，使用相同的指令。
简化的调试引擎。
提供堆快照支持。
    (gdb) jeparse -f
    (gdb) jestore /tmp/snapshot1
提供单独的脚本，允许进行非运行时的堆排布分析。单独使用时样例：
    $ python shadow.py /tmp/snapshot1 jeruns -c
    listing current runs only
    [arena 00 (0x0000007f85680180)] [bins 36]
    [run 0x7f6ef81468] [region size 08] [total regions 512] [free regions 250]
    [run 0x7f6e480928] [region size 16] [total regions 256] [free regions 051]
    [run 0x7f6db81888] [region size 32] [total regions 128] [free regions 114]
    ...
提供对于堆中内存排布的解析脚本。作为Python插件包时的使用样例：
    //code
    import jemalloc
    heap = jemalloc.jemalloc("/tmp/snapshot1")
    for chunk in heap.chunks:
    print "chunk @ 0x%x" % chunk.addr
    //run
    $ python print_chunks.py
    chunk @ 0x7f6d240000
    chunk @ 0x7f6db00000
    chunk @ 0x7f6db40000
    chunk @ 0x7f6db80000
    chunk @ 0x7f6dbc0000
    ...
**jemalloc**
**jemalloc的一些特性**
jemalloc使用bitmap管理堆分配，而不是通过内存的利用率，这也可能是jemalloc被广泛使用的主要原因。当下FreeBSD
libc，Firefox，Android libc，MySQL，Redis以及Facebook内部都在用。
设计原则
最小化的元数据开销
基于每个线程进行缓存，避免了同步问题。
避免了连续分配内存的碎片化问题。
简洁高效（所以就可以预判了哦呵呵）
**Android中的jemalloc**
在Android 6使用的版本实际上是4.0.0，在Android 7
上使用的版本是4.1.0-4-g33184bf69813087bf1885b0993685f9d03320c69
jemalloc在Android源码中的修改通过宏定义开关控制的代码块来实现，同时辅以/* Android change */的注释
    #if defined(__ANDROID__)/* ANDROID change */
    /* … */                 /* … */
    #endif                  /* End ANDROID change */
在jemalloc的Android.mk中限制了仅使用两个arenas，并且开启了线程缓存(PS：本文的讨论基于64位的架构)
    //part of Android.mk
    jemalloc_common_cflags += 
    -DANDROID_MAX_ARENAS=2 
    -DJEMALLOC_TCACHE 
    -DANDROID_TCACHE_NSLOTS_SMALL_MAX=8 
    -DANDROID_TCACHE_NSLOTS_LARGE=16 
**jemalloc内部结构**
**概念：region**
调用malloc返回给用户的实际内存
在内存中连续分布
不包含元数据
根据大小不同，划分为三种类型：
Small，最大0x14336字节
Large，最大0x38000字节(Android 6上)
Huge，大于0x38000
可以使用shadow中的jebininfo列出当前线程所有的region，或者jesize列出满足给定size的region相关信息
    //jebinfo
    (gdb) jebininfo
    [bin 00] [region size 008] [run size 04096] [nregs 0512]
    [bin 01] [region size 016] [run size 04096] [nregs 0256]
    [bin 02] [region size 032] [run size 04096] [nregs 0128]
    [bin 03] [region size 048] [run size 12288] [nregs 0256]
    [bin 04] [region size 064] [run size 04096] [nregs 0064]
    [bin 05] [region size 080] [run size 20480] [nregs 0256]
    [bin 06] [region size 096] [run size 12288] [nregs 0128]
    [bin 07] [region size 112] [run size 28672] [nregs 0256]
    //jesize
    (gdb) jesize 24
    [bin 02] [region size 032] [run size 04096] [nregs 0128]
线程申请memory时，与region的对应关系。
**概念：run**
存放连续的大小相同的region的容器
一系列连续的页集合
内部存放small/large类型的region
没有元数据
查看给定的地址所属的run中的region信息
    (gdb) jerun 0x7f931c0628
    [region 000] [used] [0x0000007f931cc000] [0x0000000070957cf8]
    [region 001] [used] [0x0000007f931cc008] [0x0000000070ea78b0]
    [region 002] [used] [0x0000007f931cc010] [0x0000000070ec2868]
    [region 003] [used] [0x0000007f931cc018] [0x0000000070f0322c]
    ...
    (gdb) x/4gx 0x7f931cc000
    0x7f931cc000: 0x0000000070957cf8 0x0000000070ea78b0
    0x7f931cc010: 0x0000000070ec2868 0x0000000070f0322c
    ...
线程申请memory时，与run的对应关系。
**概念：chunk**
存放run的容器
大小固定相同
操作系统返回的内存被划分到chunk中管理
存储着关于自身以及它管理的run的元数据
chunks的结构，与run以及元数据的关系。
chunks中的元数据结构，mapbit[0]与mapmisc[0]指向chunk中的第一个run。
chunks元数据中mapmisc中的bitmap结构管理着run中的region的分配使用。
**变化: 不同Android版本下的jemalloc**
Chunk的大小
元数据的变化
增加了mapbias与mapbits flags
**堆中的jemalloc**
    root@bullhead/: cat /proc/self/maps | grep libc_malloc
    7f81d00000-7f81d80000 rw-p 00000000 00:00 0 [anon:libc_malloc]
    7f82600000-7f826c0000 rw-p 00000000 00:00 0 [anon:libc_malloc]
    7f827c0000-7f82a80000 rw-p 00000000 00:00 0 [anon:libc_malloc]
    7f82dc0000-7f830c0000 rw-p 00000000 00:00 0 [anon:libc_malloc]
    (gdb) jechunks
    [shadow] [chunk 0x0000007f81d00000] [arena 0x0000007f996800c0]
    [shadow] [chunk 0x0000007f81d40000] [arena 0x0000007f996800c0]
    [shadow] [chunk 0x0000007f82600000] [arena 0x0000007f996800c0]
    [shadow] [chunk 0x0000007f82640000] [arena 0x0000007f996800c0]
    [shadow] [chunk 0x0000007f82680000] [arena 0x0000007f996800c0]
    [shadow] [chunk 0x0000007f827c0000] [arena 0x0000007f996800c0]
    ...
可以看到maps中0x7f81d00000对应的memory，属于两个chunk，分别位于0x7f81d00000以及0x7f81d40000。
**jemalloc的内存排布**
jemalloc管理下的内存排布
溢出了region的示意图
如果溢出了run的示意图
如果溢出了chunk的示意图，注意到，chunk头部有元数据。
**基于jemalloc的堆喷**
Hanan Be'er, Aaron Adams, Mark Brand, Joshua Drake都讨论过
region与run都没有元数据
堆喷的时候，chunk的第一个与最后一个页是不可喷的
chunk的地址是可以预测的
chunk中可堆喷的区域大小示意图
chunk地址可预测？
Google ProjectZero的Mark Brand曾经有说过
32位上：大chunk，而地址空间较小
mmap()产生多个chunk，而chunk大小固定。
Andorid进程通常加载很多模块
Android 7的chunk更大
同样适用于申请巨大的内存
可预测的chunk地址意味着
可预测的run地址
可预测的region地址
这些可以让我们做更有目的性的，更加精确的堆喷
**jemalloc的内存管理**