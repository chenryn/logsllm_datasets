1.8.5共享库
静态阵的缺点是如果我们在同一时间运行多个程序面它们又都使用着来自同-个函数库里
的两数时，内存里就会有许多份同一函数的拷员，在程序文件本身里面也有许多份同样的拷。
这会消耗大录宝贵的内存和硬盘空间。
许多UNIX系统支持共享库，它同时克服了在这两方面的无谓消耗。对共享库和它们在不间
系统上实现方法的详细讨论超出了本书的范围，所以我们把自已的注意力集中在眼前Linux环境
下的实现方法上.
共学库的存放位置和静态库是一样的，但有着不同的文件后缓。在一个典型的Linux系统上，
C语言标准库的共享版本是/usr/lib/libc.so.N，其中的“N”是主版本号，目前是6
在我们编写本书的时候，许多Linux发行版本都在对它们的C/C++编译器和C函数库的版本进
行升级。下面示例中给出的输出来自使用GNUlib2.1的RedHat6.0发行版本。如果读者使用的不
是这个发行版本，那么你的输出情况可能会稍有不同
如果一个程序使用了共享库，它的链接方式是这样的：它本身不再包含函数的代码，而只
保存共享代码的调用线索，共享代码是在该程序运行的时候才加人到其中的。当编译好的程序
被加载到内存中准备执行的时候，函数的调用线索被解析，程序向共享库发出调用，共学库只
在必要的时候才被加载到内存。
通过这种办法，在内存里系统就可以只保留一份共享库拷贝供许多程序使用，在硬盘上也
只需要保存一份拷贝就行、另外-个好处是共享库的升级不再会影响到依赖于它的那些程序
我们只需修改从文件/usr/lib/libc.so.6到实际库文件的升级版本（本书写作期间是/lib/libc-2.1.1.so）
加入jaVa编程群：524621833
---
## Page 32
第1章入门如识13
的符号链接就可以了
对Linux系统来说、负责加载共享库并解析客户程序中函数调用线索的程序（也就是共享库
的动态加载器）是ld.so或ld-linux.so.2，查找共享库的其他地点是在/etc/ld.so.conf文件里配置
的；如果这个文件进行了修改（如系统里增加了X11共享库）、就需要用ldconfig命令进行处理。
如果读者想了解某个程序要求使用的是哪一个共享库，可以用工具程序1dd来查看，如下
所示：
S 1dd progrem
/lib/1d-11nux.so.2 =>1ib.1d1fnux.so.2 (0x40000000
80.6 =>/1ib/1ibc.so.6 (0x4001aG00)
在上面的例子里，我们看到标准的C语言函数库（libc）是共享的（.so）我们I的程序要求使
用的主版本号是6，上例中是由2.1.1版的GNUlibc的数库担当的。其他UNIX系统在访问共享库
的时候也会有类似的安排。详细情况请参考你自已的系统文档。
共享库在许多方面与微软Windows环境下的动态链接库很相似。so库相当于.DLL文件，是
在程序运行时加入的：面.sa库类似于.LIB文件，是加入到可执行程序文件里去的。
1.9UNIX系统中程序设计的特点和原则
我们希望在以后的章节里倡导--种良好的UNIX程序设计风格。虽然不管在哪一种计算机平
台.上使用C语言进行程序设计都大同小异，但应该说UNIX开发入员在程序和系统开发方面更有
独到的见解。
UNIX操作系统鼓励人们采用一种独到的程序设计风格。下面就是一些典型UNIX程序和系
统所共有的一些特点。
1.9.1简单性
许多最有用的UNIX软件工具都是非常简单的，作为其结果，程序小而易于理解。KISS
（英文“KeepISmall and Simple”的字头缩写，意思是小面简单）是一种值得学习的技巧。大
型而又复杂的系统肯定会包含更大更复杂的程序漏洞，它的调试工作是一种我们大家都愿意回
避的“痛”。
1.9.2重点性
让一个程序把一项工作做到最好是很好的做法。一个所谓功能齐全的程序可能既不容易使
用，也不容易维护。如果程序只用于一个目的，那么当更好的算法或更好的操作界面被开发出
来的时候，它就更容易得到改进。在UNIX世界里，通常会在需求出现的时候把小的工具程序组
合到一起去完成一项更大的任务，而不是用一个巨大的程序预测一个用户的需求。
1.9.3可反复使用的程序组件
把应用程序的核心部分搞成一个库。带有简单面又灵活的程序设计接口并且文档齐备的函
数库能够帮助其他人开发同类的项目，或者能够把这里的技巧用在新的应用领域。就拿dbm数据
加入iaVa编程群：524621833
---
## Page 33
14Linux程序设计
库函数库来说吧，它就是一整套许多可再使用的函数的集合而不是一个单一的数据库管理系统。
1.9.4过滤器
许多UNIX应用程序可以被用做过滤器。这句话的意思是它们可以把自己的输入转换为另外
一种形式的输出。我们在后面的内容里就会看到，UNIX提供的工具程序能够从组合其他UNIX
程序开始开发出相当复杂的应用软件，其组合方法既新颖文匪夷所思。当然，这类程序组合正
是由我们刚才介绍的开发方法支撑着的。
1.9.5开放的文件格式
比较成功和流行的UNIX程序所使用的配置文件和数据文件都是普通的ASCII文本。如果读
者在程序开发工作中有这样的选择，这将是一个很好的做法。它使用户能够利用标准的软件工
具对配置数据进行改动和搜索，从而开发出新的工具，通过新的函数对数据文件进行处理。源
代码交叉引用检查软件ctags就是一个这样的好例子，它把程序中的符号位置信息以规则表达式
的形式记录下来供检索程序使用。
1.9.6灵活适应性
你根本无法预测一个不太聪明的用户会怎样使用你的程序，因此在你的程序设计里要尽可
能地增加灵活适应性。尽量避免给数据域长度或者记录条数加上人为的限制。如果你能够做到，
就要编写能够响应网络访问的程序，使它既能够跨网络运行又能够在本地单机上运行。永远不
要认为你自己了解用户心里想的一切。
1.10本章总结
在这个介绍性的章节里，我们讨论了Linux及其先驱UNIX系统之间的一些共同之处，还讨
论了能够为我们（UNIX开发人员）所用的各种各样的程序设计系统。
的参照物进行了对比。最后，我们对UNIX中的程序设计进行了简单的介绍。
加入java编程群：524621833
---
## Page 34
第2章shell程序设计
我们刚刚在这本书的开始介绍了使用C语言进行的UNIX程序设计，现在立刻就要掉转方向
进人shell程序设计。为什么？
这么说吧，shell扮演着双重角色。它与DOS中的命令处理器Command.com有不少相似之处，
但本身的功能又比它强大很多，我们完全可以把它看做是一种独立的型序设计语言。你不仅能
够执行命令和调用UNIX工具程序，还可以编写新的命令和程序。它是一种解释型的语言，这使
调试工作比较容易进行、因为你可以逐行地执行每一条指令，面且节省了反复编详所需要花费
的时间。但这也使shell不适合用来完成对执行时间比较挑剔或者处理器负荷比较大的工作
为什么要用它来进行程序设计呢？因为shell的程序设计既迅速又简单，面月即使是最基本
的UNIX安装也会有一个shell。因此，作为一个简单的框架，你可以检查自己的想法是否可行。
在与容易配置、维护和可移植性相比效率不是很重要的情况下，它非常适合用来编写一些完成
简单任务的小工具。你可以通过shell对进程控制进行组织，使命令按照预定计划在前一步骤顺
利完成的条件下顺序执行。
在你的UNIX帐户上可能已经有不少这样的例子了，比如软件包安装程序、白由软件基金会
（Free Software Foundation，简称FSF）的autoconf、.xinitrc和startx，以及/etc/rc.d子目录里用来
在开机引导时对系统进行配置的各种脚本程序等。
我们再来说点儿UNIX程序设计的特色。UNIX建立在并高度依赖于代码再使用的基础上。
你编写了一个小巧而又简单的工具，其他人把它作为另外一根链条上的某个环节来构成一条命
令。请看下面这个简单的例子：
S 1e •a1 1 mora
它使用ls和more命令把文件清单输出经管道分次分批地传输到显示器屏幕上。每个工具都只
是一个建筑构件。今后你肯定会经常性地把许多小脚本程序组织起来构成-个大型而又复杂的
组合程序。
举例来说，如果你想打印出一份由man命令给出的bash使用手册，就可以使用这样的命令：
“man bash 1 col -b 1lpr”
更进一步的是，由于UNIX操作系统本身在文件处理方面的强大功能，你不必知道工具程序
是用哪种语言编写的。如果需要执行得更快一些，常见的办法是这样的：把用shell搭成的UNIX
工具程序框架用C或C++重新写一遍一一当然先要确定这样做是值得的。反过来说，如果它们工
作的够好，就别再折聘了！
人们喜欢使用的可以与C或C++语言交替使用的其他解释型语言有Perl、Tcl/Tk和Python。
是否需要重写脚本程序取决于是否需要对它进行优化、是否需要对它进行移植、是否需要
让它更容易修改，以及它是否偏离了最初的设计目的（经常发生这样的情况）。
加入jaVa编程群：524621833
---
## Page 35
16
Linux程序设计
因此，如果在你的系统管理工作中必须面对某个整梦般的shell脚本程序、如果你想把自己
最新的大的（但有一种简单的美）设想勾勒出来或者你只是想加快一些重复性的工作，那这一
章就是为你写的。
我们将在本章学习利用shell进行程序设计时需要掌握的语法、程序结构和命令，我们主要
通过交互（基于屏幕）形式的例子进行讲解。应该把这些例子当作学习shell特性及其作用的手
段。在本章结笔部分，我们将编写一个有实际用途的脚本程序，在本书的其他后续章节里，我
们将用C语言对它进行重写和扩充。
在本章里，我们将学习以下内容：
·什么是shell。
·基本思路。
·精巧的语法：变量、条件判断和程序控制。
·命令表。
·函数。
·命令和命令的执行。
·即时文档（bere文档）。
·调试。
2.1什么是shell
我们先来看看shell的作用和UNIX里各种各样的shell。
shell是一个做为用户与UNIX系统之间的操作接口的程序，它允许用户向操作系统输入需要
执行的命令。从这方面看它与DOS很相似，但它向用户掩盖了内核操作的细节。因此，文件的
重定向只要使用“”就行，管道用一个“1”就能代表，子进程的输出是“S（.)”，所
有这些的具体细节都早已为用户准备好了。从这方面看，它本身就算得上是一种高级UNIX程序
设计语言。
csh
其他程序
X窗口系统
图2-1
加入jaVa编程群：524621833
---
## Page 36
第2章shell程序设计
因为UNIX是一个模块化程度如此之高的操作系统，所以你可以从众多不同的shell里选-一种
来使用：它们中的大多数都是从最初的Bourneshell演变而来的（见表2-1）。
裘2-1
shell名称
掌故
sb(Boume)
最韧的shell
csli, tcsh and zsn
Bi在Berkeley UNIX 1:编的C shel，可能是bash之后最黄行的sbel了
ksh, pdksh
Kom shell和它的公共域兄弟.电DavidKom编写
4uea
Linmx中的主角，来白GNU项目。bash是英文“Bourme Again Shell”的字头缩、它
的优势在于其滁代码是公开的，即使你的UNIX系统上现在没有运行它，世很可能已经
移植过来了
比csh带有更多的C语内色彩。也来白GNU项目
除了Cshell和少数变体以外，所有这些shell都很相似.并且都与X/Open4.2和POSIX1003.2
技术规范中的规定比较吻合。POSiX1003.2技术规范中对shell的规定是很少的，但X/Opcn中的
扩展规定却提供了一个更加友好和强大的shell。一般说来，X/Open是一个要求比较多的技术规
范，但由它面产生出来的又是一个比较友好的系统。在这里我们只列出了一些比较知名的shell
变体，还存在许多其他种类的shell。
在本章里，我们使用的主要是那些与POSIX兼容的shell中常见的功能，同时我们假设默认情
况下的shell被安装为/bin/sh
在许多Linux系统里，/bin/sh命令通常只是一个到实际使用中的shell的链接。它在大部分
Linux系统上是一个指向/bin/bash——即bash shell的链接。请在你自己的系统上用“ls-1/bin/sh”
命令检查一下看是否如此。如果你还想知道自己使用的bash是什么版本的，请在bash的命令
提示符处输入“/bin/bash-version”命今或“echo SBASH_VERSION”会令，它会告诉你的》
在本书后面，当我们讲到Tcl和Tk时（第14章和第15章）要分别用到rclsh和wish这两种shel。
GNU项目还提供了一组基本的shell工具，即Shellutils。与系统本身提供的shell相比，在某
些安装情况下它的执行性能更好。如果你只想用shell脚本程序对文本文件进行归档的话，可以
使用shar软件包。
2.2管道和重定向
在深人shel程序设计之前，我们需要先介绍一下如何才能对UNIX程序（不仅仅是shell程序）
的输入输出进行重定向。
2.2.1对输出数据进行重定向
读者可能已经对某些类型的重定向比较熟悉了，请看：
S1e-1>lsoutput.txt
这条命令将把ls命令的输出保存到一个名为lsoutput.txt的文件里去。
重定向可比这个简单的例子深奥多了。我们将在第3章里学习更多关于标准文件描述符的内
加入jaVa编程群：524621833
---
## Page 37
18Linux程序设计
容，在这里我们只需知道文件描述符0代表着·个程序标准输人，文件描述符1代表着一个程序
标准输出，而文件描述符2代表着一个程序标准错误输出就行了。这些标准输人输出的重定向彼
此之间不会互相于扰。事实上，你还可以对其他文件描述符进行重定向，但对标准输人输出0、
1和2等以外的东西进行重定向的情况是很少见的。
如果该文件已经存在，它的内容将被覆盖。如果你想改变重定向这个默认的行为，可以使用
“set-C”命令，该命令对noclobber选项进行了设置，从面防止了重定向操作对一个文件的覆盖。
我们将在本章后面的内容里看到set命令更多的选项。
如果想对文件进行追加，需要使用“>>”操作符，如下所示：
S p8 >> lsoutput.txt
这条命令将把ps命令的输出追加到文件尾部。
如果想对标准错误输出进行重定向，需要把准备重定向的文件描述符编号加在“>”操作符
的前面。因为标准错误输出的文件描述符是2，所以我们要使用“2>”操作符。在需要丢弃错误
信息的情况下这个办法很有用，这可以防止它们堆积在屏幕上：
假设我们想从一个脚本程序里使用k训命令来终止一个进程。这样做可能会遇到的一个小麻
烦是我们准备终止的进程在执行kill命令之前就已经结束了。如果出现这种情况，kill会向标准错
误输出写上一条出错信息，在默认的情况下它就会出现在屏幕上。通过对标准输出和标准错误
都施行重定向的办法我们就可以不让k训命令往显示器屏幕上写任何东西了。
请看下面的命令：
Ski11-HUP1234>ki1lout.txt 2>ki1lerr.txt
该命令将把输出和错误信息分别重定向到不同的文件里去。
如果我们想把两组输出都捕获到同一个文件里去、可以使用“&”操作符把两组输出弄到一
起，请看：
Ski11-11234>ki11outerr.txt 2>&1
这条命令将把输出和错误输出放到同个文件里去。请注意操作符出现的顺序。这个命令
的意思是“把标准输出重定向到文件killouterr.txt，再把标准错误重定向到与标准输出同样的地
方去”。如果你把顺序弄错了，重定向就不会按照你预想的那样工作了。
因为我们可以通过返回码（以后会讲到）了解kil命令的执行结果，所以可能根本就用不若
保留标准输出或标准错误。我们可以利用UNIX的万能“垃圾桶”/dev/null让这些输出信息无声
无息地消失掉，就像下面这样：
Ski11-11234>/dev/nu112>&1
2.2.2对输入数据进行重定向
我们不仅能重定向输出信息，还可以重定向输人数据，请看下面的小例子：
S more <killout.txt
很明显，在UNIX环境里这样做有点傻平乎的，因为UNIX中的more命令可以接受文件名作
加入jaVa编程群：524621833
---
## Page 38
第2章shell程序设计
61
为自已的参数、这--点与DOS中的对应命令不一样。
2.2.3管道
我们可以用管道操作符“”把进程连接在一起。UNIX不同于DOS，用管道连接在一起的进
程可以同时运行，并会随着数据流在它们之间的流动而自动协调。
下面是一个简单的例子，我们用sort命令对ps命令的输出进行排序。
如果我们没有使用管道，就必须把这个操作分为几个步骤，如下所示：