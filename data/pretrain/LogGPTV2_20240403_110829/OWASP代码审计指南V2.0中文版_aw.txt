识被呈现为一个隐藏的字段，或者在网址中，并且一旦选择了链接/按钮，它就会被附加到
HTTP 请求中。攻击者不知道这个唯一的标识，因为它是随机的，并且是按链接、按页面动
态呈现的。 
3.8.2.1 防止 CSRF 的应用逻辑 
⚫ 
在将页面交付给用户之前，会编译一个唯一标识列表。该列表包含为给定页面上的
所有链接生成的所有有效唯一标识。唯一标识可以从安全的随机生成器(如 J2EE 的
安全随机存储器)中获得，并可以存储在会话或另一个集中式缓存中。 
⚫ 
在向用户显示之前，唯一的标识被附加到所请求页面上的每个链接/表单。 
212 
⚫ 
应用程序审计与 HTTP 请求一起传递的唯一标识对于给定的请求是否有效。如果与
HTTP 请求一起传递的唯一标识对给定的请求有效则允许操作。 
⚫ 
如果唯一标识不存在，则终止用户会话并向用户显示错误。 
3.8.2.2 一般建议:同步器令牌模式 
为了促进“透明但可见”的 CSRF 解决方案，鼓励开发人员采用同步令牌模式
http://www.corej2eepatterns.com/Design/PresoDesign.htm. 同步器令牌模式要求生
成与用户当前会话相关联的随机“挑战”令牌。然后，这些挑战令牌被插入到与敏感的服务
器端操作相关联的 HTML 表单和链接中。当用户希望调用这些敏感操作时，HTTP 请求应
该包括这个质询令牌。然后，服务器应用程序负责验证该令牌的存在和正确性。通过在每个
请求中包含一个挑战令牌，开发人员可以很好地控制验证用户是否真的打算提交所需的请求。
在与敏感业务功能相关联的 HTTP 请求中包含所需的安全令牌有助于减轻 CSRF 攻击，因为
成功的攻击需要攻击者知道目标受害者的会话随机生成的令牌。下面的概要描述了将质询令
牌合并到请求中的一般方法。 
当一个网络应用程序制定一个请求时(通过生成一个链接或表单，在提交时引发一个请
求，或者由用户点击)，应用程序应该包括一个隐藏的输入参数。参数具有一个共同的名字，
如“CSRFToken”。该令牌的值必须随机生成，以便攻击者无法猜到。java 应用程序利用
java.security.SecureRandom 类来生成足够长的随机令牌。也可以使用替代生成算法，包
括使用 256 位 BASE64 编码哈希。选择这种生成算法的开发人员必须确保在被散列以生成
随机令牌的数据要具有随机性和唯一性。 
213 
示例： 
… 
根据产品的风险级别，它可能只为当前会话生成一次此令牌。在最初生成该令牌后，该
值存储在会话中，并在会话到期前用于每个后续请求。当最终用户发出请求时，服务器端组
件必须验证请求中令牌的存在且有效，并与会话中找到的令牌进行比较。如果在请求中找不
到令牌，或者提供的值与会话中的值不匹配，则应中止请求，重置令牌，并将事件记录为正
在进行的潜在 CSRF 攻击。 
为了进一步增强此建议设计的安全性，请考虑为每个请求随机化 CSRF 令牌参数名称和
值。实现这种方法会生成每个请求的令牌，而不是每个会话的令牌。但是，请注意，这可能
会导致可用性问题。例如，“后退”按钮的浏览器功能通常会受到阻碍，因为上一页可能包
含不再有效的令牌。与上一页的交互将导致服务器发生 CSRF 假阳性安全事件。无论采用何
种方法，都鼓励开发人员像保护经过身份验证的会话标识符一样保护 CSRF 令牌，例如，使
用 SSLv3/TLS。 
3.8.2.3 在网址中公开令牌 
这种方法的许多实现包括获取请求和发布请求中的挑战令牌。这通常是由于敏感的服务
214 
器端操作被页面中的嵌入式链接或其他通用设计模式调用而实现的。这些模式的实施往往不
了解 CSRF，也不了解 CSRF 预防设计策略。虽然这种控制确实有助于降低 CSRF 攻击的风
险，但是对于 GET 请求，每个会话唯一的令牌是公开的。GET 请求中的 CSRF 令牌可能会
在几个位置泄漏:浏览器历史、HTTP 日志文件、记录 HTTP 请求第一行的网络设备，以及
受保护站点链接到外部站点时的参考头。 
在后一种情况下(由于被链接站点解析了参考者头，导致 CSRF 令牌泄漏)，链接站点很
容易对受保护站点发起 CSRF 攻击，并且他们能够非常有效地攻击目标，因为参考者头告诉
他们站点以及 CSRF 令牌。攻击可以完全通过 javascript 运行，在网站的 HTML 中添加一
个简单的脚本标签就可以发起攻击(无论是在最初的恶意网站上还是在被黑客攻击的网站
上)。这种攻击很容易防止，如果请求的来源是 HTTPS，则将忽略参考。 因此，此攻击不
会影响仅使用 HTTPS 的 Web 应用程序。 
理想的解决方案是仅在 POST 请求中包含 CSRF 令牌，并修改状态更改会影响服务器端
的操作以仅响应 POST 请求。 实际上，这就是 RFC 2616 对 GET 请求的要求。 如果保证
敏感的服务器端操作仅响应 POST 请求，则无需在 GET 请求中包含令牌。 
3.8.2.4 ViewState (ASP.NET) 
ASP.NET 有一个选项来维护您的 ViewState。ViewState 指示页面提交到服务器时的状
态。状态是通过一个隐藏字段来定义的，该字段放置在带有控件
的每个页面上。ViewState 可以用作 CSRF 防御，因为攻击者很难伪造有效的 ViewState。
伪造一个有效的 ViewState 不是不可能的，因为参数值可能被攻击者获得或猜到。但是，
如果当前会话标识被添加到 ViewState，那么它会使每个 ViewState 都是唯一的，因此不
受 CSRF 的影响。 
215 
要在 ViewState 中使用 ViewState 用户键属性来防止欺骗的回发，请在页面派生类的
OnInit 虚拟方法中添加以下内容(此属性必须在页面中 Page.Init 设置) 
示例： 
protected override OnInit(EventArgs e) { 
base.OnInit(e); 
if (User.Identity.IsAuthenticated) 
ViewStateUserKey = Session.SessionID;  
} 
要使用您选择的唯一值向个人键入 ViewState，请使用“(Page.ViewStateUserKey)"。
这必须在 Page_Init 中应用，因为在加载视图状态之前，必须将密钥提供给 ASP.NET。自
ASP.NET 1.1 版以来，此选项一直可用。然而，这种机制有其局限性。例如，ViewState MACs
只在回发时审计，因此任何其他不使用回发的应用程序请求都将很容易产生 CSRF 攻击。 
3.8.2.5 双重提交 Cookies 
双重提交 cookie 被定义为在 cookie 和请求参数中发送随机值，服务器验证 cookie 值
和请求值是否相等。 
当用户向一个站点进行身份验证时，该站点应该生成一个(加密的强)伪随机值，并将其
设置为用户机器上与会话 id 分开的 cookie。网站不必以任何方式保存该值。然后，网站应
该要求每个敏感的提交都包括这个随机值，作为隐藏的表单值(或其他请求参数)，也作为
cookie 值。根据同源策略，攻击者无法读取从服务器发送的任何数据或修改 cookie 值。这
意味着，尽管攻击者可以通过恶意的 CSRF 请求发送他想要的任何值，但攻击者将无法修改
或读取存储在 cookie 中的值。由于 cookie 值和请求参数或表单值必须相同，攻击者将无
216 
法成功提交表单，除非他能够猜测随机的 CSRF 值。 
直接网络远程处理(DWR) Java 库 2.0 版本内置了 CSRF 保护，因为它透明地实现了双
cookie 提交。 
上述 CSRF 通过维护一个秘密令牌来验证请求，从而防止依赖使用唯一令牌和同源策略
来阻止 CSRF。下列方法可以通过依靠 CSRF 攻击永远不会破坏的相似规则来防止 CSRF。 
3.8.2.6 审计头部 Referer 
虽然在你自己的浏览器上进行请求 referer 欺骗是非常容易的，但是在 CSRF 攻击中是
不可能做到的。审计 referer 是在嵌入式网络设备上防止 CSRF 的常用方法，因为它不需要
每个用户的状态。这使得 referer 成为不记忆任何属性的情况下，预防 CSRF 病的有效方法。
这种 CSRF 缓解方法也通常用于未经身份验证的请求，例如在建立跟踪同步令牌所需的会话
状态之前发出的请求。 
然而，审计 referer 被认为是 CSRF 保护的较弱形式。例如，开放重定向漏洞可用于利
用基于 GET 的 CSRF 攻击，如果这些请求通过 referer 审计进行 CSRF 保护，因为一些组织
或浏览器工具删除 header 中的 referer 作为一种数据保护形式。referer 审计也有常见的实
现错误。例如，如果 CSRF 攻击源自 HTTPS 域，则 referer 将被忽略。在这种情况下，当
请求执行状态更改时，缺少 referer 应被视为攻击。还要注意，攻击者对 referer 可以有一
定的影响。例如，如果受害者的域是“ site.com”。然后，攻击者可以利用来自
“site.com.attacker.com”的 CSRF 漏洞，这可能会绕过 referer 审计实现。另外，XSS 可
用于绕过 referer 审计。 
简而言之，referer 审计是 CSRF 入侵检测和防御的一种合理形式，尽管它不是一种完
217 
全的保护。referer 审计可以检测到一些攻击，但不能阻止所有攻击。例如，如果 HTTP referer
来自不同的域，并且您只期望来自您的域的请求，您可以阻止该请求。 
3.8.2.7 审计 Origin Header 
HTTP 请求头中的 Origin 字段是作为防御 CSRF 和其他跨域攻击的一种方法引入的。
不同于 referer，Origin 将存在于源自 HTTPS URL 的 HTTP 请求中。如果 Origin 报头存在，
则应审计其一致性。 
3.8.2.8 挑战-回应 
挑战-回应是 CSRF 的另一种防御选择。如前所述，它通常在被调用的函数具有高风险
时使用。虽然挑战-响应是对 CSRF 的一个非常强有力的防御(假设实施得当)，但它确实会影
响用户体验。对于需要高安全性的应用程序，应在高风险功能上使用令牌(透明)和挑战-回
应。 
以下是挑战-回应选项的一些示例: 
⚫ 
验证码 
⚫ 
重新认证(密码) 
⚫ 
一次性令牌 
3.8.3 没有跨站点脚本(XSS)漏洞 
CSRF 不需要跨站点脚本来工作。但是，任何跨站点脚本漏洞都可以用来击败基于令牌、
双重提交 cookie、推荐者和来源的 CSRF 防御。这是因为 XSS 有效负载可以使用
XMLHttpRequest 简单地读取站点上的任何页面，并从响应中获取生成的令牌，将该令牌
218 
与伪造的请求包括在内。这项技术正是 MySpace (Samy)蠕虫在 2005 年击败 MySpace 反
CSRF 防御的方法，正是这种方法使蠕虫得以传播。XSS 无法击败诸如验证码、重新认证或
一次性密码等挑战-响应防御措施。因此，防御 CSRF 的前提是不存在 XSS 漏洞，以确保
CSRF 防御无法规避。 
3.9 A9 使用已知漏洞的组件 
具有已知漏洞的组件，如库、框架和其他软件模块，几乎总是以完全特权运行。如果利
用了易受攻击的组件，这种攻击可能会导致严重的数据丢失或服务器接管。使用具有已知漏
洞的组件的应用程序可能会削弱应用程序的防御能力，并导致一系列可能的攻击和影响。 
3.9.1 描述 
如今，一个应用程序或软件组件的开发很少不重复使用一些开源或付费的库或框架。这
很有意义，因为这些框架和库已经被开发和运行，并且已经非常成熟稳定。然而，当攻击者
在组件代码中发现缺陷时，这些第三方组件也可能是安全漏洞的来源。事实上，该缺陷比其
它漏洞对攻击者更具吸引力，因为他们知道该漏洞将对使用该组件的每个人起作用。 
这个问题已经发展到这样一种状态:流行框架、库和操作系统的缺陷/漏洞在地下市场上
以高价出售。 
3.9.2 审计什么 
对于这个主题来说，确实没有代码需要审计，除非您的组织已经自己审计了组件的代码
(假设它是开源的，而不是封闭的第三方库)，在这种情况下，代码审计将类似于任何其他的
审计审计。然而，代码审计可以在更大的公司范围的跟踪或审计机制中使用，以让组织清楚
219 
地知道它正在使用什么第三方代码。 
无论公司的规模如何，都应该跟踪第三方组件的使用及其版本，以确保当任何安全漏洞
被发现时，组织可以收到警报。对于规模较小（拥有 1-2 个产品）的公司，这种跟踪可能
像电子表格或 wiki 页面一样简单，但是对于拥有 100 多个应用程序或产品的大型公司来说，
跟踪开发人员使用第三方框架和库的任务与这些库带来的风险一样大。 
如果一个公司有 20 个产品，并且每个产品使用 5 或 6 个第三方组件(例如，Apache web
服务器，OpenSSL 加密库，用于 regex 和 DB 交互的 Java 库等)这使得该公司有超过 100
个外部来源，安全漏洞可能来自这些组件。如果公司突然收到了一个严重漏洞，它必须能够
做出反应并升级那些受影响的应用程序，或者采取其他对策来保护自己和客户。 
3.9.2.1 控制组件库 
大公司用来限制暴露于第三方漏洞的一种方法是控制开发者可以使用哪些库。例如，他
们可以指定开发人员应该使用 OpenSSL 的某个版本作为加密库，而不是其他选项。 
这使得管理层和风险控制人员能够了解他们对市场漏洞的风险状况，如果发现漏洞，他
们知道这些漏洞没有暴露(即，一些开发人员没有在其中一个产品上使用 bouncycastle，因
为它不在要使用的加密库列表中)。另一方面，如果 OpenSSL 有 bug，他们所有的鸡蛋都
在那个篮子里，需要马上升级。 
限制第三方组件的选择显然会有技术上的挑战，这种政策可能不受希望使用最新最棒框
架的开发人员的欢迎，但确保产品安全的第一步是知道你用什么组件制作的产品。 
如何跟踪或实施这样的政策？通常情况下，库或框架以.dll/.so 或源代码形式，集成到
代码行中。此类集成应接受代码审计，作为此代码审计的一项任务，审计者可以审计: 
220 
⚫ 
这个库是一个可以在产品套件中使用的库(或者可能已经被使用过了，但是开发人
员并不知道，在这种情况下，审计应该被拒绝)。 
⚫ 
任何跟踪或审计软件(甚至是基本的数据表)都会更新，以反映产品正在使用第三方
库。这允许在出现漏洞时进行快速补救，这意味着产品将被修补。 
3.9.2.2 敲碎坚果的大锤 
审计人员的最后一项职责是确保正确的第三方库用于所需的功能。许多库都有大量可能
不被使用的功能。例如，开发人员是否包括一个库来执行他们的正则表达式，但也包括应用
程序不使用/不需要的其他功能？这增加了应用程序的攻击面，当额外的代码打开端口并与
互联网通信时，会导致意外的行为。 
如果审计者认为引入了太多的功能/代码，他们可以建议关闭未使用的功能，或者更好
的方法是不将该功能包括在产品中(例如，通过剥离代码，或者硬编码分支，以便从不使用
未使用的函数)。 
OWASP 项目“OWASP 依赖性审计”可以为图书馆审计提供一种自动化措施
(https://www.owasp.org/index.php/OWASP_Dependency_Check) 
3.10  A10 未验证的重定向和转发 
Web 应用程序经常将用户重定向和转发到其他页面和网站，并使用不受信任的数据来
确定目标页面。如果没有适当的验证，攻击者可以将受害者重定向到网络钓鱼或恶意软件网
站，或使用转发来访问未经授权的页面。 
221 
3.10.1 描述 
当 web 应用程序接受不可信输入时，可能会发生未经验证的重定向和转发，这可能会
导致 web 应用程序将请求重定向到不可信输入中包含的网址。通过修改网站的不可信网址
输入，攻击者可以成功发起网络钓鱼诈骗并窃取用户凭据。 
由于修改后的链接中的服务器名称与原始站点相同，用于钓鱼的网站与真实网站很难区
分。无效的重定向和转发攻击也可用于创建一个 URL，该 URL 将通过应用程序的访问控制