9019426137074931948836881412856529444940507252018234253636995370272
6532830052579978881891592694167046933479761478884334265896721145936
7897335358473
p1=primefac.gcd（n1,n2）
p2=p1
q1=n1/p1
q2=n2/p2
e1=65537
e2=65537
d1=modinv(e1,（p1-1)*（q1-1)
d2=modinv（e2.（p2-1)*（q2-1)
m1=pow（c1,d1,n1)
m2=pow(c2,d2,n2)
print long_to_bytes(m1)
print long_to_bytes(m2)
结果输出如下：
flag(first_part)
flag(second_part)
---
## Page 725
CTF特训营：技术详解、解题方法与
21.2.5其他模数分解方式
725/1144
21.2.5其他模数分解方式
当上面的几种方法都无法分解模数时，可以尝试使用一些网站来
进行分解，如http://factordb.com/index.php
有的时候，题目中也会提供一些其他信息来辅助选手分解n。下
面来看一道真题，来自于MMACTF2016：
n=
1940264376802796729448069536103722764963751456128046135270842019219
7328993512710852087871986349184383442031544945263966477446685587168
0251547750601787828970979939498008459032188909752757254166992584629
2009798642493608854111279095887521133618824910728075366146761951107
9649070248659536282267267928669265252935184448638997877593781930103
8664169495856865415096424940485542420041008633152204300749971455319
2912820088575827403787534953901866933626346980327728104865719811484
4413236754680549874472753528866434686048799833381542018876362229842
6052135008697093616570000441825733088255502379991394420404221079318
57506897810951
npp=
1940264376802796729448069536103722764963751456128046135270842019219
7328993512710852087871986349184383442031544945263966477446685587168
0251547750601787828970979939498008459032188909752757254166992584629
2009798642493608854111279095887521133618824910728075366146761951107
9649070248659536282267267928669265252935757418867172314593546678104
1001290273392560689409874128167797443399949716651095556804014673244
8739754185248680577030089506331508396544509846796673890539232096329
3379345531703349669197397492241574949069875012089172754014231783160
9604255311602462673896570345433429909406806031537904865304774706557
57947009682859
e=65537
C=
7991219189591014572196623817385737879027208108469800802629706564258
5086260106745138754960291772905758196503668027308032837611370362553
---
## Page 726
CTF特训营：技术详解、解题方法与
21.2.5其他模数分解方式
726/1144
8076776653886608646389553997359461588232197473814093168933387310612
4459849322556754579010062541988138211176574621668101228531769828358
2899731503933431099486115836092194202135308343648374387304113793050
4615667001502454726301993228898980822809160120694874130422219777980
8592738075111024678982273856922586615415238555211148847427589678238
7451862536497836656079283820028681112780770548712948379231895367142
3504404199354115840294337218877979799671179261043996910599391737365
1847337638929
题目中在提供了（n，e.c）的同时，还提供了npp的值，npp的值为（p
+2)*（q+2）。构造一个方程：x²-（p+q）x+p*q=0。此方程中（p+q）的值和
pq的值都可以通过npp和n转化得到，而此方程的两个根即为p和q的
值。
此题的c经过了n和npp两次加密，攻击代码如下：
n=
1940264376802796729448069536103722764963751456128046135270842019219
0251547750601787828970979939498008459032188909752757254166992584629
2009798642493608854111279095887521133618824910728075366146761951107
9649070248659536282267267928669265252935184448638997877593781930103
8664169495856865415096424940485542420041008633152204300749971455319
2912820088575827403787534953901866933626346980327728104865719811484
4413236754680549874472753528866434686048799833381542018876362229842
6052135008697093616570000441825733088255502379991394420404221079318
57506897810951
npp=
1940264376802796729448069536103722764963751456128046135270842019219
7328993512710852087871986349184383442031544945263966477446685587168
0251547750601787828970979939498008459032188909752757254166992584629
2009798642493608854111279095887521133618824910728075366146761951107
1001290273392560689409874128167797443399949716651095556804014673244
---
## Page 727
CTF特训营：技术详解、解题方法与
21.2.5其他模数分解方式
727/1144
8739754185248680577030089506331508396544509846796673890539232096329
3379345531703349669197397492241574949069875012089172754014231783160
9604255311602462673896570345433429909406806031537904865304774706557
57947009682859
e=65537
pq=n
z/(t-u-ddu)=bed
import gmpy2
(）zdudub=u
(ddu）zdudub=ub
a=gmpy2.mpz（1)
（bed-)zduz
那么此时：
c=m3
直接对c开三次根号即可得到m。当然这是一种极端的情况。如
果m3>n但是并没有超过n太多，即：
k*n= PolynomialRing(ZmodN)#, implementation='NTL)
base=
0x9876543210fedcba00000000000000000000000000000000000000000000000000
000000000000
00000000000000000000000000000000000000000000000000
pol=（2^length_N-2^Kbits+x)^e-C
print2lengthN
print2^Kbits
printx
pol=（base-2^Kbits+x)e-C
dd =pol.degree()
#Tweak those
beta=1
#b=N
epsilon=beta/7
#<=beta/7
mm=ceil(beta**2/（dd*epsilon)
#optimizedvalue
tt=floor（dd*mm*（（1/beta)-1）)#optimizedvalue
XX=ceil(N*(（beta**2/dd)-epsilon))#optimizedvalue
#Coppersmith
start_time = time.time()
roots=coppersmith_howgrave_univariate(pol,N,beta,mm,tt,XX)
#output
print“n#Solutions"
#print“we want to find:”,str(K)
print“we found:", str(roots)
print(in:%s seconds "% (time.time()- start_time))
如图21-13所示，可以得到m的值，接下来使用num2str进行数字
的转化，代码如下：
m=1861040492750592458109753184254913405
print long_to_bytes(m)
结果输出如下：
---
## Page 736
CTF特训营：技术详解、解题方法与
21.2.8 LLL-attack
736/1144
flag(llattack)
至此LLL-attack攻击完毕。
以上方法同样适用于p泄露三分之二的情况。给出的代码在泄露