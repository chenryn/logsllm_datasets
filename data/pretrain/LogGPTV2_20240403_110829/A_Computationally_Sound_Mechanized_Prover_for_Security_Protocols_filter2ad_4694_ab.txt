channel restriction
P ::=
input
output process
c[M1, . . . , Ml](cid:5)N1, . . . , Nk(cid:6); Q output
new x[i1, . . . , im] : T ; P
let x[i1, . . . , im] : T = M in P assignment
if M then P else P (cid:2)
conditional
[(cid:2)i] ≤ njmj
ﬁnd (
) ∧ Mj then Pj)
(cid:3)m
j=1 uj1[(cid:2)i] ≤ nj1, . . . , ujmj
suchthat deﬁned (Mj1, . . . , Mjlj
random number
else P
array lookup
Figure 1. Syntax of the process calculus
Our calculus also assumes a set of parameters, denoted
by n, which correspond to integer values polynomial in the
security parameter, so we deﬁne Iη(n) = q(η) where q is a
polynomial, and Iη(n) denotes the interpretation of n for a
given value of the security parameter η.
Our calculus also assumes a set of types, denoted by
T . For each value of the security parameter η, each type
corresponds to a subset Iη(T ) of Bitstring ∪ {⊥} where
Bitstring is the set of all bitstrings and ⊥ is a special
symbol. The set Iη(T ) must be recognizable in polyno-
mial time, that is, there exists an algorithm that decides
whether x ∈ Iη(T ) in time polynomial in the length of x
and the value of η. Let ﬁxed-length types be types T such
that Iη(T ) is the set of all bitstrings of a certain length,
this length being a function of η bounded by a polynomial.
Let large types be types T such that
|Iη(T )| is negligible.
(f (η) is negligible when for all polynomials q, there ex-
ists ηo ∈ N such that for all η > η0, f (η) ≤ 1
q(η) .) Par-
ticular types are predeﬁned: bool, such that Iη(bool ) =
{0, 1}, where 0 means false and 1 means true; bitstring,
such that Iη(bitstring) = Bitstring; bitstring ⊥ such that
Iη(bitstring ⊥) = Bitstring ∪ {⊥}; [1, n] where n is a pa-
rameter, such that Iη([1, n]) = [1, Iη(n)].
(We consider
integers as bitstrings without leading zeroes.)
1
The calculus also assumes a ﬁnite set of function sym-
bols f. Each function symbol comes with a type declaration
f : T1 × . . . × Tm → T . For each value of η, each function
symbol f corresponds to a function Iη(f ) from Iη(T1) ×
. . .×Iη(Tm) to Iη(T ), such that Iη(f )(x1, . . . , xm) is com-
putable in polynomial time in the lengths of x1, . . . , xm and
the value of η. Particular functions are predeﬁned, and some
of them use the inﬁx notation: M = N for the equality test,
M (cid:12)= N for the inequality test (both taking two values of
the same type T and returning a value of type bool), M ∨ N
for the boolean or, M ∧ N for the boolean and, ¬M for the
boolean negation (taking and returning values of type bool).
In this calculus, terms represent computations on bit-
strings. The replication index i is an integer which serves in
distinguishing different copies of a replicated process !i≤n.
(Replication indexes are typically used as array indexes.)
The variable access x[M1, . . . , Mm] returns the content of
the cell of indexes M1, . . . , Mm of the array variable x. We
use x, y, z, u as variable names. The function application
f (M1, . . . , Mm) returns the result of applying function f
to M1, . . . , Mm.
The calculus distinguishes two kinds of processes: input
processes Q are ready to receive a message on a channel;
output processes P output a message on a channel after ex-
ecuting some internal computations. The input process 0
does nothing; Q | Q(cid:2) is the parallel composition of Q and
Q(cid:2); !i≤nQ represents n copies of Q in parallel, each with
a different value of i ∈ [1, n]; newChannel c; Q creates a
new private channel c and executes Q; the semantics of the
input c[M1, . . . , Ml](x1[(cid:2)i] : T1, . . . , xk[(cid:2)i] : Tk); P will be
explained below together with the semantics of the output.
The output process new x[i1, . . . , im] : T ; P chooses
a new random number uniformly in Iη(T ), stores it in
x[i1, . . . , im], and executes P .
(T must be a ﬁxed-
length type, because probabilistic polynomial-time Tur-
ing machines can choose random numbers uniformly only
in such types.) Function symbols represent determinis-
tic functions, so all random numbers must be chosen by
new x[i1, . . . , im]
: T . Deterministic functions make
automatic syntactic manipulations easier: we can dupli-
cate a term without changing its value.
The process
let x[i1, . . . , im] : T = M in P stores the bitstring value
of M (which must be in Iη(T )) in x[i1, . . . , im], and exe-
cutes P . The process if M then P else P (cid:2) executes P if M
evaluates to 1 and P (cid:2) if M evaluates to 0. Next, we explain
[(cid:2)i] ≤ njmj
the process ﬁnd (
) ∧ Mj then Pj) else P ,
suchthat deﬁned (Mj1, . . . , Mjlj
where (cid:2)i denotes a tuple i1, . . . , im(cid:2). The order and ar-
ray indexes on tuples are taken component-wise, so for
instance, uj1[(cid:2)i] ≤ nj1, . . . , ujmj
[(cid:2)i] ≤ njmj can be
further abbreviated (cid:2)uj[(cid:2)i] ≤ (cid:4)nj. A simple example
is the following: ﬁnd u ≤ n suchthat deﬁned (x[u]) ∧
x[u] = a then P (cid:2) else P tries to ﬁnd an index u such that
x[u] is deﬁned and x[u] = a, and when such a u is found,
it executes P (cid:2) with that value of u; otherwise, it executes
P . In other words, this ﬁnd construct looks for the value a
in the array x, and when a is found, it stores in u an index
(cid:3)m
j=1 uj1[(cid:2)i] ≤ nj1, . . . , ujmj
In case of success, it executes P (cid:2).
(cid:3)m
j=1 uj1[(cid:2)i] ≤ nj1, . . . , ujmj
such that x[u] = a. Therefore, the ﬁnd construct allows
us to access arrays, which is key for our purpose. More
generally, ﬁnd u1[(cid:2)i] ≤ n1, . . . , um[(cid:2)i] ≤ nm suchthat
deﬁned (M1, . . . , Ml) ∧ M then P (cid:2) else P tries to ﬁnd val-
ues of u1, . . . , um for which M1, . . . , Ml are deﬁned and
M is true.
In case
of failure, it executes P . This is further generalized to m
[(cid:2)i] ≤ njmj
branches: ﬁnd (
) ∧ Mj then Pj) else P
suchthat deﬁned (Mj1, . . . , Mjlj
tries to ﬁnd a branch j in [1, m] such that there are values of
uj1, . . . , ujmj for which Mj1, . . . , Mjlj are deﬁned and Mj
is true. In case of success, it executes Pj. In case of failure
for all branches, it executes P . More formally, it evaluates
the conditions deﬁned (Mj1, . . . , Mjlj
)∧Mj for each j and
[(cid:2)i] in [1, nj1]×. . .×[1, njmj
each value of uj1[(cid:2)i], . . . , ujmj
].
If none of these conditions is 1, it executes P . Otherwise,
it chooses randomly with uniform1 probability one j and
one value of uj1[(cid:2)i], . . . , ujmj
[(cid:2)i] such that the correspond-
ing condition is 1, and executes Pj.
Finally, let us explain the output c[M1, . . . , Ml](cid:5)N1, . . . ,
Nk(cid:6); Q. A channel c[M1, . . . , Ml] consists of both a chan-
nel name c and a tuple of terms M1, . . . , Ml. Channel
names c allow us to deﬁne private channels to which the
adversary can never have access, by newChannel c. (This
is useful in the proofs, although all channels of protocols
are often public.) Terms M1, . . . , Ml are intuitively anal-
ogous to IP addresses and ports which are numbers that
the adversary may guess. Two channels are equal when
they have the same channel name and terms that evaluate to
the same bitstrings. A semantic conﬁguration always con-
sists of a single output process (the process currently be-
ing executed) and several input processes. When the out-
put process executes c[M1, . . . , Ml](cid:5)N1, . . . , Nk(cid:6); Q, one
looks for an input on the same channel and with the same ar-
ity in the available input processes. If no such input process
is found, the process blocks. Otherwise, one such input pro-
l ](x1[(cid:2)i] : T1, . . . , xk[(cid:2)i] : Tk); P is chosen
cess c[M (cid:2)
randomly with uniform probability. The communication is
then executed: for each j ≤ k, the output message Nj is
evaluated, its result is truncated to length maxlenη(c), the
obtained bitstring is stored in xj[(cid:2)i] if it is in Iη(Tj) (oth-
erwise the process blocks). Finally, the output process P
that follows the input is executed. The input process Q that
follows the output is stored in the available input processes
for future execution. Note that the syntax requires an output
to be followed by an input process, as in [30]. If one needs
to output several messages consecutively, one can simply
1A probabilistic polynomial-time Turing machine can choose a random
number uniformly in a set of cardinal m only when m is a power of 2.
When m is not a power of 2, there exist approximate algorithms: for ex-
ample, in order to obtain a random integer in [0, m − 1], we can choose a
− 1] for a certain k large enough
random integer r uniformly among [0, 2k
and return r mod m. The distribution can be made as close as we wish
to the uniform distribution by choosing k large enough.
1, . . . , M (cid:2)
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
insert ﬁctitious inputs between the outputs. The adversary
can then schedule the outputs by sending messages to these
inputs.
Using different channels for each input and output al-
lows the adversary to control the network. For instance,
we may write !i≤nc[i](x[i] : T ) . . . c(cid:2)[i](cid:5)M (cid:6) . . . The adver-
sary can then decide which copy of the replicated process
receives its message, simply by sending it on c[i] for the
appropriate value of i.
We write if M then P as an abbreviation for
if M then P else yield(cid:5)(cid:6); 0, and similarly for a ﬁnd with-
out else clause. (“else 0” would not be syntactically cor-
rect.) A trailing 0 after an output may be omitted.
Variables can be deﬁned by assignments, inputs, restric-
tions, and array lookups. The current replication indexes at
a certain program point in a process are i1, . . . , im where
the replications above the considered program point are
!i1≤n1 . . .!im≤nm. We often abbreviate x[i1, . . . , im] by x
when i1, . . . , im are the current replication indexes, but it
should be kept in mind that this is only an abbreviation.
Variables deﬁned under a replication must be arrays: for
example !i1≤n1 . . .!im≤nm let x[i1, . . . , im] : T = M in . . .
More formally, we require the following invariant:
Invariant 1 (Single deﬁnition) The process Q0 satisﬁes
Invariant 1 if and only if
1. in a deﬁnition of x[i1, . . . , im] in Q0,
the indexes
i1, . . . , im of x are the current replication indexes at
that deﬁnition, and
2. two different deﬁnitions of the same variable x in Q0
are in different branches of a if or a ﬁnd.
Invariant 1 guarantees that each variable is assigned at most
once for each value of its indexes. (Indeed, item 2 shows
that only one deﬁnition of each variable can be executed for
given indexes in each trace.)
Invariant 2 (Deﬁned variables) The process Q0 satisﬁes
Invariant 2 if and only if every occurrence of a variable ac-
cess x[M1, . . . , Mm] in Q0 is either
• syntactically under the deﬁnition of x[M1, . . . , Mm]
(in which case M1, . . . , Mm are in fact the current
replication indexes at the deﬁnition of x);
• or in a deﬁned condition in a ﬁnd process;
• or
in a process of
in M (cid:2)
j or Pj
the form
(cid:3)m(cid:2)(cid:2)
j=1 (cid:2)uj[(cid:2)i] ≤ (cid:4)nj suchthat deﬁned (M (cid:2)
j1, . . . ,
) ∧ M (cid:2)
j then Pj) else P where for some k ≤ lj,
ﬁnd (
M (cid:2)
x[M1, . . . , Mm] is a subterm of M (cid:2)
jlj
jk.
Invariant 2 guarantees that variables can be accessed only
when they have been initialized. It checks that the deﬁni-
tion of the variable access is either in scope (ﬁrst item) or
checked by a ﬁnd (last item). Both invariants are checked
by the prover for the initial game, and preserved by all game
transformations.
j
: T → Tj
(f (x1, . . . , xm)) = xj and f −1
We say that a function f : T1 × . . . × Tm → T is
poly-injective when it is injective and its inverses can be
computed in polynomial time, that is, there exist func-
tions f −1
(1 ≤ j ≤ m) such that
f −1
can be computed in
j
polynomial time in the length of f (x1, . . . , xm) and in
the security parameter. When f is poly-injective, we de-
ﬁne a pattern matching construct let f (x1, . . . , xm) =
M in P else Q as an abbreviation for let y : T = M in
let x1 : T1 = f −1
m (y) in