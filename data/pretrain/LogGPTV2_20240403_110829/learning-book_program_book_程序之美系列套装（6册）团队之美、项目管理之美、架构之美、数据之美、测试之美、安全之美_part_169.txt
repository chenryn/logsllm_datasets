从列表、表格和双击激活等功能。我们从未破坏属性-绑定架构。
应用程序外观
947
---
## Page 949
创建强大的领域模型容易犯一个典型的错误。表示层（在这个例子
中就是U模型层）常常与领域模型太过亲密。如果表示层遍历了领
域模型中的关系，那么就很难改变领域模型了。像大多数敏捷团队
一样，我们需要保持灵活，我们不能允许自已的设计决定导致灵活
性随时间的推移而降低。
MartinFowler的"应用程序外观"模式正适合解决这个问题（参见这
一章末尾的第4.6节）。应用程序外观只将领域模型的一部分暴露给
表示层。表示层不会跟踪领域对象的关系图，而是让应用程序外观
来帮助实现遍历、生命周期管理和激活等操作。
每个表格定义了一个对应的外观接口。实际上，按照应该由客户
（而不是提供者）来确定接口的格言，我们将这个外观接口放到了
表格的包中。表格要求外观来查询领域对象、建立领域对象之间的
关系并将它们持久。实际上，这些外观管理着所有的数据库事务，
所以表格从不知道事务边界。
在表格对象和外观对象之间的这些接口，也成为隔离对象、进行单
元测试的理想场所。要测试某个表格对象，单元测试会创建一个模
拟对象（mockobject）来实现外观的接口。测试让模拟对象向表格
对象提供一组预期的结果，包括很难通过真正的外观对象再现的错
误情况。我想我们都把模拟对象看成是一种双面承诺：尽管我们让
单元测试变得可行，但有时候仍然觉得让测试和表格的实现绑得这
么紧是不对的。例如，模拟对象必须事先录制预期的方法调用顺序
和准确的参数。（新的模拟对象框架更灵活一些。）结果，即使外
部可见的行为没有改变，表格内部结构的变化常常也会导致测试失
败。在某种程度上来说，这只是你使用模拟对象的代价。
所有的CreationCenter应用程序，包括在照相馆和打印工厂中使用
的，都使用相同的层。将GUI从驾驶室中挪并让团队不必与Swing进
行无休止的搏斗。反向控制也提供了一种统一的结构，每个应用程
序，每一对程序员都遵守它。虽然我们创造的架构超出了通常的
“三层蛋糕”，但它在分离关注点方面相当有效：Swing限制在UI部
分，领域交互在表格中完成，持久在应用外观中实现。
4.3.4可以互换的工作站
当摄影师完成一段拍摄之后，她可以使用任意一台工作站。她通常
会当时就完成这个客户的工作，这取决于照相馆当时的忙闲状况。
948
---
## Page 950
但是，客户常常也会稍后再回来，甚至可能改天再来。让某个用户
只能使用某台工作站是很奇怪的，这不仅在安排上行不通，而且也
有风险。工作站可能失效。
所以照相馆中的所有工作站必须能够互换，但是“可互换"带来了一
些问题。每次拍摄的图像可能占用将近1GB的空间。
我们简单考虑了一下将工作站连成一个P2P网络，进行分布式复
制。最后，我们采用了更为传统的客户端-服务器模式，如图4-5所
示。
照相馆客户端
照相馆服务器
照相馆客户端
图像存储MySQL
图4-5：照相馆部署
与客户端相比，服务器装有多个大容量硬盘，它们构成RAID，保证
安全。服务器上运行着MySQL数据库，存放结构化的数据，记录客
户、各次拍摄、订单等。但大部分空间用于存放客户的照片。
因为照相馆的距离很远，而且其中的合伙人不精通技术，所以我们
知道把基础设施隐藏起来是很重要的。工作人员应该永远不必查看
文件系统、分析失效原因或重启任务。他们当然应该从不登录数据
库服务器。最坏的情况下，如果网线被碰松了，当它插回去时，所
有工作都应该恢复正常，并且应该从临时的问题中自动恢复。
考虑这一点，我们设计了系统和应用的架构。
图像库
949
---
## Page 951
要让工作站可以互换，最基本的功能就是自动传输图像，包括从摄
影师加载图像的工作站到服务器，以及从服务器到另一台工作站。
照相馆客户端和照相馆服务器都使用了一个核心组件，名为图像
库。它负责处理所有的存储、加载和记录图像的工作，包括图像的
元数据。在客户端，我们建立了一个本地的、带缓存的、后写入的
代理。当调用者请求一张图片时，客户端图像库要么直接从本地缓
存中取出它，要么将文件下载到本地缓存中，再取出它。不管用哪
种方式，调用者都不必了解具体的细节。
类似地，当在客户端添加图像时，客户端图像库会将它上传到服务
器。我们使用一个后台运行的线程池来进行传输，这样用户就不必
等待上传。
客户端和服务器都大量运用了多线程。我们创建了一个锁系统，名
为“预订”。预订是协作锁的软件形式。当客户想在图像库中添加一
幅图像时，它必须先请求并持有“写预订”。通过这种方式，我们可
以保证在我们发出该预订时，没有别的线程在读取图片。自然地，
读取程序必须获得“读预订”。
虽然我们没有实现分布式事务或两阶段提交，但在实践中，在客户
端图像库确认一次写预订和服务器端确认对应的写预定之间，只有
很短的时间。当第二次预订确认时，我们就确信能够避免文件冲突
了。
在实践中，甚至锁竞争也是很少见的。只有两个摄影师在两个不同
工作站访问同一个客户的照片时才会出现。但是，每个照相馆有几
台工作站，每个工作站上有许多线程，所以小心一点是值得的。
NIO图像传输
显然，剩下的问题是将图像从客户端传输到服务器。早期我们曾考
虑并否决的一种可选方案是CIFS，即Windows共享驱动器。这里我
们主要考虑的是容错，但我们也担心传输速度。这些机器需要来回
转输许多数据，摄影师和客户要坐在那里等看。
在我们列出的所有现成的可选方案中，没有哪种方案可以同时确保
速度、并行、容错和信息隐藏。虽不情愿，我们也只有决定创建自
已的文件传输协议，这将我们带入了CreationCenter最复杂的部分。
950
---
## Page 952
图像转输变成了严峻的考验，但我们最后得到了整个系统最健壮的
一项功能。
我以前对JavaNfO曾有过一些经验，所以我知道我们可以利用它来
实现一种非常快速的图像转输机制。实现NIO数据传输本身并不是
太困滩。我们使用常见的领导者-追随者（leader-follower）模式来
提供并发，同时保证NIO选择器在一个线程中执行。
虽然该协议的实现并不困滩，却有一些细小的地方需要处理：
套接字的两端都可以关闭它，特别是在客户端进行缓存的情况下。
示例代码没有对这种情况提供合适的处理。
在处理IO事件时，SelectionKey仍将发出信号，表明它已准备好。
如果你不清楚来自这个SelectionKey的兴趣集的操作，就可能导致多
个线程调用同一段处理程序。
领导者必须处理所有对SelectionKey的兴趣集的变更，否则就会在
Selector上产生竞态条件，所以我们必须创建一个队列来存放待执行
的SelectionKey变更，领导者线程将在调用select之前执行这些变
更。
处理这些小细节导致了不同对象之间的耦合比我预期的要多。如果
我们当时是要设计一个框架，这个部分就需要更多地关注松耦合。
但对于一个应用程序，我们觉得这是可以接受的，可以将服务器上
这些操作的对象看成是一个内聚的单元。
当我们运行一个包嘎探器，想看看是否真地获得了最大可能的吞吐
量时，出现了特别有趣的一幕。我们没有做到。最初，当接收方从
有数据的套接字中读取数据时，它会读满一个缓冲区，然后返回。
我们猜想，如果数据多于8192字节，不用等多少时间就会继续读取
后面的数据。事实表明照相馆的网络相当快，在下一个线程再次调
用处理程序之前就会填满服务器的TCP窗口，所以实际上每次传输
都会停顿几乎一半的时间。我们在响应代码中添加了一个循环，它
会不断读取，直到缓冲区读空为止。这使得传输时间几乎缩短了一
半，而且减少了线程切换和调度的并销。我觉得这很有趣，因为它
只在快速、低延迟的网络中有效，而且要在客户端总数较少的时
候。对于网络延迟较高或客户端较多的情况，这种处理方式可能会
951
---
## Page 953
导致某些客户端饥饿。同样，这是在我们的环境中有效的一种折
中。
单元测试和代码复审
这个NIO文件服务器让我发现进行大组复审是很有帮助的，即使是
在一个完全进行结对编程的敏捷项目中也是如此。
我的结对伙伴和我在大多数选代中都一起处理多线程、锁和NIO机
制。我们尽自己所能进行了单元测试，但在多线程和低级套接字IO
之间，我们发现很滩对代码产生自信。所以我们执行了另一件最佳
实践：我们让更多的眼睛来关注它。但是我们称之为特例。我们对
不能够编写足够的单元测试进行了补偿。
一般来说，在所有时间里让两双眼睛盯着代码，可以提供代码复审
的所有好处。将结对编程与自动格式化和代码检查结合，就会使代
处，那为什么还要进行代码复审？
我们在工作室里放了一个投影仪，通过A/B开关连接到两台电脑。
当我们有一项技术要展示，或有一个设计模式要分享时，我们就会
在午餐后打并投影仪，走查一些代码。这在项目的早期非常方便，
尤其是让架构和设计变得更流畅，以及我们在学习如何使用Spring
和Hibernate时。这也有助于共享Eclipse的实践和技巧。
投影仪对于选代展示也很方便。我们可以让所有利益相关人坐在房
间里，不必挤在一个屏幕前面。
（更别说在墙上投影有趣的YouTube视频了。）
我知道，快速构建易碎的东西并不难。真正的挑战是让它变得健
壮，特别是整个网络都在几百英里以外的照相馆中。这个网络不能
让我们远程登录来调试问题，或在失效后清理现场。这个网络要面
对小孩、分心的父母，服务器放在学步几童视线的高度。想想这个
不发好的坏境！通过电缆传输数据是不够的，我们需要自动的文件
传输并保证成功。第一层保障是协议本身。对于"put"操作（将文件
从客户端上传到服务器），请求的第一个数据包中包含了文件的
MD5校验和。当客户端发出最后一个数据包后，它等待来自服务器
的响应。服务器的响应代码包括：OK、TIMEOUT、
FAILED_CHECKSUM或UNKNOWN_ERROR。如果收到的响应代码
952
---
## Page 954
不是OK，客户端就会重发整个文件，我们称之为"快重试”。客户端
在传输失败之间要经过3次快重试。
文件传输的问题分成两类。一类是“快速短暂的”，这种问题会自己
消失，如网络错误。另一类要求人的干预。这意味着问题不会在几
毫秒内消失，或者需要几分钟到几小时来修正。反复重试快速文件
传输是没有意义的。如果几次尝试都无效，就不太可能在很短的时
间内恢复正常。
因此，如果客户端经过3次快重试仍然失败，就会将文件放到一个
文件传输任务队列中。一个后台任务会每20分钟执行一次，检查受
阻的文件传输任务。它会再次尝试每个任务，如果还是失败，它会
将任务放回到队列中。利用Spring的任务调度支持，这种“慢重试”
是很容易实现的。
这种混合快重试和慢重试的策略让我们能够分离服务器和客户端的
维护和支持。在升级或替换时，不需要“冷启动"整个照相馆的机
器。
快速和健壮