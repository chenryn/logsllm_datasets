A Veriﬁed Protocol Core. In RefTLS-CORE, we develop,
implement and verify (for the ﬁrst time) a composite state
machine for TLS 1.2 and 1.3 (shown in Appendix B). Each
state transition is implemented by a ProScript function that
processes a ﬂight of incoming messages, changes the session
state, and produces a ﬂight of outgoing messages. For
497
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
TLS 1.3 clients, these functions are get client hello,
put server hello, and put server finished;
servers use the functions put client hello, get -
server finished, and put client finished.
that
We then use the ProScript compiler to translate this
module into a ProVerif script
looks much like the
protocol models described in earlier sections of this paper.
(See [48] for details of the translation.) Each pure function
in ProScript translates to a ProVerif function; functions that
modify mutable state are translated to ProVerif processes
that read and write from tables. The interface of the module
is compiled to a top-level process that exposes a subset of
the protocol functions to the adversary over a public channel.
The adversary can call these functions in any order and
any number of times, to initiate connections in parallel, to
provide incoming ﬂights of messages, and to obtain outgoing
ﬂights of messages. The ProVerif model uses internal tables,
not accessible to the attacker,
to manage state updates
between ﬂights and preserve state invariants through the
protocol execution.
Our approach allows us to quickly obtain veriﬁable
ProVerif models from running RefTLS code. For example,
we were able to rapidly prototype changes to the TLS 1.3
speciﬁcation between Draft-13 and Draft-18, while testing
for interoperability and analyzing the core protocol at the
same time. In particular, we extracted a model from our
Draft-18 implementation, and veriﬁed our security goals
from §III and §V with ProVerif.
We engineered the ProScript compiler to generate read-
able ProVerif models that can be modiﬁed by a protocol
analyst to experiment with different threat models. We are
working towards applying the same automated translation
approach towards CryptoVerif models. CryptoVerif syntax
differs slightly from the ProVerif syntax, yet there is ongoing
work in the CryptoVerif team to have it accept the same
source syntax as ProVerif. However, the kind of models that
are easy to verify using CryptoVerif differ from the models
that ProVerif can automatically verify, and the assumptions
on cryptographic primitives will always remain different.
Therefore, even if the source syntax is the same, we may
need to adapt our compiler to generate different models for
ProVerif and CryptoVerif.
Evaluation: Veriﬁcation, Interoperability, Performance.
The full RefTLS codebase consists of about 6500 lines of
Flow code, including 3000 lines of trusted libraries (mostly
message parsing), 2500 lines of untrusted application code,
and 1000 lines of veriﬁed protocol core. From the core,
we extracted an 800 line protocol model in ProVerif and
composed it with our generic library from §II. Verifying this
model took several hours on a powerful workstation.
RefTLS implements TLS 1.0-1.3, and interoperates with
all major TLS libraries for TLS 1.0-1.2. Fewer libraries
currently implement TLS 1.3, but RefTLS participated in
the IETF Hackathon and achieved interoperability with other
implementations of Draft-14. It now interoperates with NSS
(Firefox) and BoringSSL (Chrome) for Draft-18.
application. We demonstrate the utility of this approach by
integrating RefTLS into the Brave web browser, which is
written in Electron. We are able to intercept all of Brave’s
HTTPS requests and reliably fulﬁll them through RefTLS.
We benchmarked RefTLS against Node.js’s default
OpenSSL-based HTTPS stack when run against an OpenSSL
peer over TLS 1.2. In terms of computational overhead,
RefTLS is two times slower than Node’s native library,
which is not surprising since RefTLS is written in JavaScript,
whereas OpenSSL is written in C. In exchange for speed,
RefTLS offers an early implementation of TLS 1.3 and
a veriﬁed protocol core. Furthermore, in many application
scenarios, network latency dominates over crypto, so the
performance penalty of RefTLS may not be that noticeable.
VIII. DISCUSSION AND RELATED WORK
Symbolic Analysis of TLS 1.3. We symbolically analyzed
a composite model of TLS 1.3 Draft-18 with optional client
authentication, PSK-based resumption, and PSK-based 0-
RTT, running alongside TLS 1.2 against a rich threat model,
and we established a series of security goals. In summary,
1-RTT provides forward secrecy, authentication and unique
channel identiﬁers, 0.5-RTT offers weaker authentication,
and 0-RTT lacks forward secrecy and replay protection.
We discovered potential vulnerabilities in 0-RTT client
authentication in earlier draft versions. These attacks were
presented at the TLS Ready-Or-Not (TRON) workshop and
contributed to the removal of certiﬁcate-based 0-RTT client
authentication from TLS 1.3. The current design of PSK
binders in Draft-18 is also partly inspired by these kinds of
authentication attacks.
TLS 1.3 has been symbolically analyzed before, using the
Tamarin prover [35]. ProVerif and Tamarin are both state-of-
the-art protocol analyzers with different strengths. Tamarin
can verify arbitrary compositions of protocols by relying on
user-provided lemmas, whereas ProVerif is less expressive
but offers more automation. In terms of protocol features,
the Tamarin analysis covered PSK and ECDHE handshakes
for 0-RTT and 1-RTT in Draft-10, but did not consider 0-
RTT client certiﬁcate authentication or 0.5-RTT data. On
the other hand, they do consider delayed (post-handshake)
authentication, which we did not consider here.
The main qualitative improvement
in our veriﬁcation
results over theirs is that we consider a richer threat model
that allows for downgrade attacks, and that we analyze
TLS 1.3 in composition with previous versions of the
protocol, whereas they verify TLS 1.3 in isolation.
Our full ProVerif development consists of 1030 lines of
ProVerif; including a generic library incorporating our threat
model (400 lines), processes for TLS 1.2 (200 lines) and
TLS 1.3 (250 lines), and security queries for TLS 1.2 (50
lines) and TLS 1.3 (180 lines). All proofs complete in
about 70 minutes on a powerful workstation. In terms of
manual effort, these models took about 3 person-weeks for
a ProVerif expert.
Computational Proofs for TLS 1.3. We presented the
ﬁrst mechanically-checked cryptographic proof for TLS 1.3,
developed using the CryptoVerif prover. We prove secrecy,
By implementing Node’s https interface, we are able
to naturally integrate RefTLS within any Node or Electron
498
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
forward secrecy with respect to the compromise of long-
term keys, authentication, replay prevention (except for 0-
RTT data), and existence of a unique channel identiﬁer for
TLS 1.3 draft-18. Our analysis considers PSK modes with
and without DHE key exchange, with and without client
authentication. It includes 0-RTT and 0.5-RTT data, as well
as key updates, but not post-handshake authentication.
Unlike the ProVerif analysis, our CryptoVerif model does
not consider compositions of client certiﬁcates and pre-
shared keys in the same handshake. It also does not account
for version or ciphersuite negotiation; instead, we assume
that the client and server only support TLS 1.3 with strong
cryptographic algorithms. The reason we limit the model
in this way is to make the proofs more tractable, since
CryptoVerif is not fully automated and requires signiﬁcant
input from the user. With future improvements in the tool,
we may be able to remove some of these restrictions.
CryptoVerif is better suited to proofs than ﬁnding attacks.
Sometimes, proof failures in CryptoVerif might
lead us
towards computational attacks that do not appear at the sym-
bolic level, but we did not ﬁnd such attacks in our model of
TLS 1.3. We failed to prove forward secrecy for handshakes
that use both pre-shared keys and Difﬁe-Hellman, but this
failure is due to limitations in our tool, not due to an attack.
Our proofs required some unusual assumptions on public
values in Difﬁe-Hellman groups to avoid confusions between
different key exchange modes; these ambiguities are inherent
in Draft-18 but have been ﬁxed in Draft-19, making some
of our assumptions unnecessary.
In comparison with previous cryptographic proofs of draft
versions of TLS 1.3 [40], [52], [55], our cryptographic as-
sumptions and proof structure is similar. The main difference
in this work is that our proof is mechanized, so we can easily
adapt and recheck our proofs as the protocol evolves.
Our full CryptoVerif development consists of 1895 lines,
including new deﬁnitions and lemmas for the key schedule
(570 lines), a model of the initial handshake (550 lines), a
model of PSK-based handshakes (625 lines), and a model
of the record protocol (150 lines). For different proofs, we
sometimes wrote small variations of these ﬁles, and we do
not count all those variations here. All proofs completed in
about 6 minutes. The total veriﬁcation effort took about 5
person-weeks for a CryptoVerif expert.
Verifying TLS Implementations. Speciﬁcations for pro-
tocols like TLS are primarily focused on interoperability;
the RFC standard precisely deﬁnes message formats, cryp-
tographic computations, and expected message sequences.
However, it says little about what state machine these pro-
tocol implementations should use, or what APIs they should
offer to their applications. This speciﬁcation ambiguity is
arguably the culprit for many implementation bugs [12] and
protocol ﬂaws [15] in TLS.
In the absence of a more explicit speciﬁcation, we ad-
vocate the need for veriﬁed reference implementations of
TLS that can provide exemplary code and design patterns on
how to deploy the protocol securely. We proposed one such
implementation, RefTLS, for use in JavaScript applications.
The core protocol code in RefTLS implements both TLS
1.2 and 1.3 and has been veriﬁed using ProVerif. However,
RefTLS is a work-in-progress and many of its trusted
components remain to veriﬁed. For example, we did not
verify our message parsing code or cryptographic libraries,
and our veriﬁcation results rely on the correctness of the
unveriﬁed ProScript-to-ProVerif compiler [48].
The symbolic security guarantees of RefTLS are weaker
than those of computationally-veriﬁed implementations like
miTLS [21]. However, unlike miTLS, our analysis is fully
automated and it can quickly ﬁnd attacks. The type-based
technique of miTLS requires signiﬁcant user intervention
and is better suited to building proofs than ﬁnding attacks.
Other Veriﬁcation Approaches. In addition to ProVerif and
CryptoVerif, there are many symbolic and computational
analysis tools that have been used to verify cryptographic
protocols like TLS. As discussed above, Tamarin [68] was
used to symbolically analyze TLS 1.3 Draft-10 [35]. Easy-
Crypt [8] has been used to develop cryptographic proofs
for various components used in TLS, including the MAC-
Encode-Encrypt construction used in the record layer [5].
Our ProScript-to-ProVerif compiler is inspired by pre-
vious works on deriving ProVerif models from F# [20],
Java [6], and JavaScript [16]. Such translations have been
used to symbolically and computationally analyze TLS
implementations [18]. An alternative to model extraction
is to synthesize a veriﬁed implementation from a veriﬁed
model; [30] shows how to compile CryptoVerif models to
OCaml and uses it to derive a veriﬁed SSH implementation.
The most advanced case studies for veriﬁed protocol
implementations use dependent type systems, because they
scale well to large codebases. Reﬁnement types for F# have
been used to prove both symbolic [19] and cryptographic
security properties, with applications to TLS [21]. The F*
programming language [70] has been used to verify small
protocols and cryptographic libraries [73]. Similar tech-
niques have been applied to the cryptographic veriﬁcation
of Java programs [53].
IX. CONCLUSION AND FUTURE WORK
TLS 1.3 is a social and technical experiment
in the
collaborative design of a practical protocol with regular input
and review from the academic research community. It seeks
to reverse the traditional pattern where security analyses are
performed several years after standardization, when it may
be too late to change how implementations work. This paper
describes our contribution to this standardization effort.
We present veriﬁcation results for symbolic models in
ProVerif, computational models in CryptoVerif, and a ref-
erence implementation in JavaScript of TLS 1.3 Draft-18.
There are still many features and aspects of the emerging
protocol standard that remain to be analyzed. Furthermore,
the formal connections between our ProVerif models, Cryp-
toVerif proofs, and JavaScript code are not as strong as
could be desired. We have focused on proof automation
and readable models as a pragmatic ﬁrst step, but we are
working on formal proofs of correctness for our translations
from Flow to ProVerif and CryptoVerif, so that we can obtain
strong guarantees for our protocol source code.
499
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] D. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry, M. Green, J. A.
Halderman, N. Heninger, D. Springall, E. Thom´e, L. Valenta et al.,
“Imperfect forward secrecy: How Difﬁe-Hellman fails in practice,” in
ACM SIGSAC Conference on Computer and Communications Security
(CCS), 2015, pp. 5–17.
[2] M. R. Albrecht and K. G. Paterson, “Lucky microseconds: A timing
attack on Amazon’s S2N implementation of TLS,” in EUROCRYPT,
2016, pp. 622–643.
[3] N. AlFardan, D. J. Bernstein, K. G. Paterson, B. Poettering, and
J. C. Schuldt, “On the security of RC4 in TLS,” in USENIX Security
Symposium, 2013, pp. 305–320.
[4] N. J. AlFardan and K. G. Paterson, “Lucky thirteen: Breaking the TLS
and DTLS record protocols,” in 2013 IEEE Symposium on Security
and Privacy (SP 2013), 2013, pp. 526–540.
[5] J. B. Almeida, M. Barbosa, G. Barthe, and F. Dupressoir, “Veriﬁable
Side-Channel Security of Cryptographic Implementations: Constant-
Time MEE-CBC,” in Fast Software Encryption (FSE), 2016, pp. 163–
184.
[6] M. Avalle, A. Pironti, R. Sisto, and D. Pozza, “The Java SPI frame-
work for security protocol implementation,” in Availability, Reliability
and Security (ARES), 2011 Sixth International Conference on, Aug
2011, pp. 746–751.
[7] N. Aviram, S. Schinzel, J. Somorovsky, N. Heninger, M. Dankel,
J. Steube, L. Valenta, D. Adrian, J. A. Halderman, V. Dukhovni,
E. K¨asper, S. Cohney, S. Engels, C. Paar, and Y. Shavitt, “DROWN:
breaking TLS using SSLv2,” in USENIX Security Symposium, 2016,
pp. 689–706.
[8] G. Barthe, F. Dupressoir, B. Gr´egoire, C. Kunz, B. Schmidt, and P.-
Y. Strub, “EasyCrypt: A tutorial,” in Foundations of Security Analysis
and Design VII (FOSAD), ser. Lecture Notes in Computer Science.
Springer, 2014, vol. 8604, pp. 146–166.
[9] M. Bellare, “New proofs for NMAC and HMAC: Security without
collision-resistance,” in Advances in Cryptology (CRYPTO), 2006, pp.
602–619.
[10] M. Bellare, J. Kilian, and P. Rogaway, “The security of the cipher
block chaining message authentication code,” Journal of Computer
and System Sciences, vol. 61, no. 3, pp. 362–399, Dec. 2000.
[11] M. Bellare and C. Namprempre, “Authenticated encryption: Relations
among notions and analysis of the generic composition paradigm,” in
Advances in Cryptology – ASIACRYPT’00, 2000, pp. 531–545.
[12] B. Beurdouche, K. Bhargavan, A. Delignat-Lavaud, C. Fournet,
M. Kohlweiss, A. Pironti, P.-Y. Strub, and J. K. Zinzindohoue, “A
messy state of the union: taming the composite state machines of
TLS,” in IEEE Symposium on Security & Privacy (Oakland), 2015.
[13] K. Bhargavan, B. Blanchet, and N. Kobeissi, “Veriﬁed models and
reference implementations for the TLS 1.3 standard candidate,” Inria,
Research report RR-9040, 2017.
[14] K. Bhargavan, C. Brzuska, C. Fournet, M. Green, M. Kohlweiss, and
S. Z. B´eguelin, “Downgrade resilience in key-exchange protocols,”
in IEEE Symposium on Security and Privacy (Oakland), 2016, pp.
506–525.
[15] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Pironti, and P.-
Y. Strub, “Triple handshakes and cookie cutters: Breaking and ﬁxing
authentication over TLS,” in IEEE Symposium on Security & Privacy
(Oakland), 2014, pp. 98–113.
[16] K. Bhargavan, A. Delignat-Lavaud, and S. Maffeis, “Language-based
defenses against untrusted browser origins,” in USENIX Security
Symposium, 2013, pp. 653–670.
[17] K. Bhargavan, A. Delignat-Lavaud, and A. Pironti, “Veriﬁed contribu-
tive channel bindings for compound authentication,” in Network and
Distributed System Security Symposium (NDSS ’15), 2015.
[18] K. Bhargavan, C. Fournet, R. Corin, and E. Z˘alinescu, “Veriﬁed
cryptographic implementations for TLS,” ACM TOPLAS, vol. 15,
no. 1, pp. 3:1–3:32, 2012.
[19] K. Bhargavan, C. Fournet, and A. D. Gordon, “Modular veriﬁcation of
security protocol code by typing,” in ACM Symposium on Principles
of Programming Languages (POPL), 2010, pp. 445–456.
[20] K. Bhargavan, C. Fournet, A. D. Gordon, and S. Tse, “Veriﬁed inter-
operable implementations of security protocols,” ACM Transactions
on Programming Languages and Systems, vol. 31, no. 1, 2008.
in
TLS
P.-Y.
[21] K. Bhargavan, C.
Strub,
security,”
Fournet, M. Kohlweiss, A.
“Implementing