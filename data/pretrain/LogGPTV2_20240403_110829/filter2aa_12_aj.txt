每一个HTTP客户端发送给服务器请求都会要求服务器发回响应信息。在特定情况下，服务器会发回两条响应，一条初步响应和一条实际上的响应。一般，一个请求产生一个响应，表明服务器对于该请求的处理结果，并且响应往往消息主体还携带一个实体（文件或资源）。（微信号：EMC_Support）
响应消息格式如下：
如下图所示。
状态行
状态行是响应信息的起始行，作用有两个：告知客户端服务器使用的协议版本以及沟通客户端请求的处理结果。状态行语法格式如下：
HTTP版本
状态行中的HTTP-VERSION标签与请求信息中的目的一样。服务器要求返回的版本号不得高于客户端发送的版本号。
响应码和文本描述
状态码和文本描述提供客户端请求处理结果的信息。服务器通过3位数字状态码告知客户端处理结果。目的是为了方便客户端HTTP软件采取合适的行动。文本描述将服务器响应显示给客户端用户。
状态代码由 3 位数字组成， 表示请求是否被理解或被满足，状态描述给出了关于状态码的简短的文字描述。状态码的第一个数字定义了响应类别，后面两位数字没有具体分类。第一个数字有5 种取值，如下所示。
1xx：指示信息——表示请求已经接受，继续处理
2xx：成功——表示请求已经被成功接收、理解、接受。
3xx：重定向——要完成请求必须进行更进一步的操作
4xx：客户端错误——请求有语法错误或请求无法实现
5xx：服务器端错误——服务器未能实现合法的请求。
常见状态代码、状态描述、说明：
200 OK      //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
响应首部
响应首部可能包括：
Location（重定向）
Location响应报头域用于重定向接受者到一个新的位置。例如：客户端所请求的页面已不存在原先的位置，为了让客户端重定向到这个页面新的位置，服务器端可以发回Location响应报头后使用重定向语句，让客户端去访问新的域名所对应的服务器上的资源。当我们在JSP中使用重定向语句的时候，服务器端向客户端发回的响应报头中，就会有Location响应报头域。  
Server响应头
  Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。它和User-Agent请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户端软件(浏览器)和操作系统的信息。下面是Server响应报头域的一个例子：Server: Apache-Coyote/1.1
实体头
  请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法未接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。
Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型，如："application/octet-stream"。
Last-modified：实体头指定服务器上保存内容的最后修订时间。
Accept-Ranges：这个字段说明Web服务器是否支持Range（是否支持断点续传功能），如果支持，则返回Accept-Ranges： bytes，如果不支持，则返回Accept-Ranges： none。
Content-Encoding：文档的编码（Encode）方法。它的值指示了已经被应用到实体正文的附加内容编码，因而要获得Content- Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding主要用语记录文档的压缩方法，下面是它的一个例子： Content-Encoding: gzip。如果一个实体正文采用了编码方式存储，在使用之前就必须进行解码。
Expires： 给出响应过期的日期和时间。通常，代理服务器或浏览器会缓存一些页面。当用户再次访问这些页面时，直接从缓存中加载并显示给用户，这样缩短了响应的时间，减少服务器的负载。为了让代理服务器或浏览器在一段时间后更新页面，我们可以使用Expires实体报头域指定页面过期的时间。当用户又一次访问页面时，如果Expires报头域给出的日期和时间比Date普通报头域给出的日期和时间要早(或相同)，那么代理服务器或浏览器就不会再使用缓存的页面而是从服务器上请求更新的页面。不过要注意，即使页面过期了，也并不意味着服务器上的原始资源在此时间之前或之后发生了改变。
Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5; URL=http://host/path")让浏览器读取指定的页面。 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV="Refresh" CONTENT="5;URL=http://host/path"＞实现。
Allow：服务器支持哪些请求方法（如GET、POST等）。
Content-Disposition：打开一个网页时，浏览器会首先看是否有Content-Disposition: attachment这一项，当是“Content-Disposition: attachment”时是下载，“Content-Disposition:inline”是在线打开文件
下面是一个响应消息
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain
HTTP方法:
GET
GET方法请求服务器检索由该HTTP请求中的URL指定的资源并在回复中发给客户端。这是最基本的请求类型，也是占大多数的HTTP数据流。当你输入一个常规URL或点击一个文档中的链接，通常就是提示Web浏览器发送GET请求。
对于GET的处理取决于若干因素。如果URL正确并且服务器能够找到资源，会发送合适的响应给客户端。返回资源需取决于请求对象的特性。如果无法妥当处理请求，则会产生一个错误信息。在使用缓存的情况下，代理服务器甚至客户端自己就可以满足请求。对于某种特定报头如 If-Modified-Since 或 If-Match， GET请求的含义可能随之而改变，要求服务器仅在满足特定条件时发送资源。这类请求称为条件GET。类似的，客户端可以使用Range头来要求服务器仅发送部分资源。这类请求称为部分GET。
HEAD
HEAD方法同GET，但告知服务器不要发送消息实体。客户端通常使用这种方法来检查资源是否存在，状态，或文件大小，再决定是否需要服务器发送整个文件。HEAD请求的处理与GET相同，除了只返回头部而不返回实际的资源之外。
POST
POST方法允许客户端发送任意数据的实体到服务器以进行处理。它通常同于客户端提交例如交互式HTML信息给服务器程序，之后服务器作出行动并发回响应。这种方法用于各种在线进程。请求中的URL指定服务器上接受数据的程序名。
PUT
这种方法请求服务器将请求中的实体保存在请求中的URL里。PUT中，URI指明请求中的实体，因而PUT能够让文件复制到服务器，在GET请求中文件能够被复制到客户端。与之相反，POST中URI标识的程序处理请求中的实体，因此通常应用于交互式程序。PUT用法很多，如上传内容到网站，这种情况下必须加以认证。但是，在站点上存储文件通常使用其他方式，如FTP。
TRACE
客户端通过这种方法接收发至服务器的请求，用于诊断目的。
参考
TCP/IP Guide
部分内容来源于网络
网络基本功（二十三）：Wireshark抓包实例诊断TCP连接问题
网络基本功（二十三）：Wireshark抓包实例诊断TCP连接问题
转载请在文首保留原文出处：EMC中文支持论坛https://community.emc.com/go/chinese 
介绍
前文论述了TCP基础知识，从本节开始，通过TCP抓包实例来诊断TCP常见问题。
TCP进程通讯时，双方打开连接，发送数据，最后关闭连接。当TCP打开连接时，从源端口到目的端口发送一个请求。在应用建立或关闭时可能发生一些问题。本文讨论用Wireshark网络抓包的方法来定位及解决这一问题。
更多信息
问题的表现形式:
问题可能有多种表现类型：
尝试运行应用程序但发现应用程序无法工作。尝试浏览网络但无法获得响应。
尝试发送邮件但无法连接到邮件服务器。
问题可能由简单原因引起，如服务器宕机，服务器上没有运行应用程序，或在客户端到服务器的某一处网络断开。
问题也可能由复杂原因引起，如DNS问题，服务器内存不足无法连接（例如某一应用占用高内存空间），重复IP，以及其他原因。
处理方法:
下文会介绍解决问题的线索以及如何通过抓包来诊断TCP连接问题。通常，这些问题会导致运行应用程序时无法得到任何结果。
当你在运行一个应用程序时，例如数据库客户端，邮件客户端，观看视频等等，而又无法获得输出，按照以下步骤诊断：
确认服务器和应用程序正在运行。
确认客户端正在运行，IP地址已配置（手动或通过DHCP），并连接至网络。
Ping服务器并确认连接正常。
在某些情况下，ping不通服务器但连接正常。这是由于防火墙拦截了ICMP信息，所以如果无法ping通并不一定表示连接有问题。防火墙可能是网络中的专用设备或Windows/Linux/UNIX终端设备上安装的防火墙。
5. 抓包文件中，查找以下模式：
三重SYN信息而没有响应（见以下截屏）
SYN信息带一个reset(RST)响应
这两种情况下都有可能是防火墙拦截了特定应用程序或应用程序没有在运行。
以下截屏是一个简单的case：客户端无法连接到web服务器81.218.31.171（报文61,62和63）。可能是由于不被防火墙允许，或服务器发生故障。可以看到另一个站点108.160.163.43（报文65,66和67）的连接正常，因此连接问题仅限于81.218.31.171。
下例是一个这种情况相对复杂的case。该case中，客户想要登录到camera服务器来访问远程站点的camera。camera服务器的IP地址为135.82.12.1，问题在于客户能够看到服务器主页上的登录窗口，但无法登进系统。在下面的截图中可以看到，打开了一个到IP地址135.82.12.1的连接。到HTTP服务器的TCP连接是打开的，一开始看上去没有连接问题：
当我们过滤出目的IP地址为135.82.12.1的数据流，也就是camera服务器。这里可以看到，当尝试连接TCP端口6036时，得到了一个RST/ACK响应，有以下可能性：
防火墙拦截了端口6036
如果配置了端口地址转换（PAT），那么仅转换端口80而非6036
用户名和密码验证是在TCP端口6036上完成的，防火墙仅允许端口80，验证被拦截，应用无法工作
总之，当无法正常连接服务器时，检查服务器和客户端是否所有TCP/UDP端口都能通过网络转发，以及是否有未知的端口。
工作过程：
TCP连接开始时，发生了以下三步：
1. 客户端TCP进程发送了一个SYN报文。该报文中SYN标志位设置为1。这一报文中客户端：
指定自己的初始序列号。这是客户端发送给服务器的第一个字节。
指明自己的窗口大小。这是客户端分配给进程的缓存大小（位于客户端的RAM）。
设置自己将要使用的选项：MSS，Selective ACK，等等。
2. 当服务器收到建立连接请求，服务器：
发送SYN/ACK给客户端，确认接收到SYN请求。
指明服务器端的初始序列号。这是服务器发送给客户端的第一个字节。
指明服务器的窗口大小。这是服务器分配给进程的缓存大小（位于服务器RAM）。
回复请求选项并设置服务器端选项。