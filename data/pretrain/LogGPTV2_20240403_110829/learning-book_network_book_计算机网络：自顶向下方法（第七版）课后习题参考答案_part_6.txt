醒过期后，ACK（或Nack）可能仍在发送方的途中，然而，要检测丢失，对于每个包，一个持续时间不变的定时器仍然需要在发送者。
R12,
a]丢包造成一段时间后，所有五个包都被重传。
b)由于Go-8ack-N使用累积数据，ACK的去失没有触发任何重传承认
c发送方无法发送第六个分组，因为发送窗口大小固定为5
R13.
a当分组丢失时，接收的4个分细被缓冲接收器。完成后超时，发送方重新发送丢失的数据包，接收方传送缓冲的数据包数据包以正确的顺序应用。
b)接收露为丢失的ACK发送了重复ACK。
c发送窗口大小固定为5时，发送方无法发送第六数据包当分组丢失时，返回-N重传所有的分组，而选择性地重传所有的分组，仅重发丢失的数据包，在丢失确认的情况
下，选择性重复发送重复ACK, 并有GO-BACK-N使用的累积确认, 不需要重复ACK
R14、假假真留真假假
R15,
a) 20 bytes
b) ack number = 90
R16, 3段, 第一段: SEQ=43, ack=80;第二段:SEQ=80, ack=44; 第三段; seq=44, ack=81
R17, R/2
R18，false，它没置为拥塞窗口的当前值的一半。
R19, 让X  RTTy±,Y  RTTz 和ST=搜素时间, 考虑以下时序图
25 / 79
---
## Page 26
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
Client
Front End Server
BackEndServer
TCP
Handshake
Y+ST
3 Windows
httpsf//featet.top
套户端和服务醒 (后端)之间使用代理(前端)之间的TCP数据包交换图
从这个图中段门可以看到, 总时间是4.X + Y + ST  4 + RTTyg + RZTBe + 搜素时间 +
Back to Indea
26 / 79
---
## Page 27
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
问题3
R1,
source port numbers
destination port numbers
a) A→S467
23
b) B5513
23
c) S+A23
467
EZ 8=S (p
513
e) Yes.
f No.
P2.假没主机A.B和C的IP地址分别为a，b，c.（请注意，a，b，c各不相可)。
主机A:源端口=80, 源P姚址=b, 目标端口=26145, 目标IP地址=a
到生机C,左进程：源端口=80,源P地址=b,目标端口=7532, 目标IP地址=c
到生机C，右进程：源端口=80，源P地址=b，目标端口=26145,目标IP姚址=c
P3、注章，如果溢出，请绕一圈。
+ 8 1 1 e 8 1 1 8
1 0 1 1 1 e e 1
8 1 0 1 0 e 1 1
8 1 1 1 8 1 e 8
+ 1 e 1 1 1 ee 1
 e 1  1 1 1 θ
补码为: 1 1 8 1 8 8 @ 1
为了检测错误，接效方添加四个单词(三个源始单词和校验和），如果和包含一个零，接收器知道有一个错误，所有的一位错误都会被检测到，但是两位错误可以不被检
测到”（例如，如果第—个单词的最后一个数字披转换为0，第二个单试的最后一个数字被转狭为1）。
P4,
a]将这两个字节相加得到11000001。取一个人的补始量就等于0011110,
b)把这两个字节相加，等于01000000;补码等于1011111。
第—个字节=01010100; 第二个字节=01101101,
P5、不，接收方不能完全确定没有发生任何位蜡误。这是因为计算数据包的校验和的方式。如果包中两个16位字的对应位（相加在一起）是0和1，那么即使这些位分别醒
转到1和0，和仍然保持不变。因此，接收方计算的1s补罚也将是相同的，这意求着，即使存在传输错误，校验和也将进行验证。
P6、假没发送方处于“从上面等待呼叫1状态，而接收方（作业问题中显示的接收方）处于“从下面等待1状态。发送方发送一个序列号为1的数据包，并转换为“等待ACK
或NAK 1°，等待ACK或NAK。现在照没接收方正确继接收序列号为1的数据包。发送一个ACK，然后转换为状态“从下面等特O"，等待序列号为0的数据包。但是，ACK已报
坏，当rdt2.1发送方获得损坏的ACK时，它用序列号1重新发送数据包。然而，接收方正在等得序列号为的数据包，并且（如家务问题所示）总是在没有得到序列号为0的
数据包时发送NAK。因此，发送方将始终发送一个序列号为1的数据包。而接收方将始终键定该数据包。也不会从那个州前进。
ACK的情况下，发送方不需要这个信息（即ACK上的序列号）亲判断是否检测到重复的ACK，对于rdt3.接收器来说，一个重复的ACK是显而悬见的，因为当它接收到原始
ACK时，它会转换到下一个状态。重复的ACK不是发送方需要的ACK，因此接rdt3.发送方忽略。
P8、协议rd13.0的发送方与协议22的发送方不同，因为已经添加了超时。我们已经看剩，超时的引1入增加了在发送方到膜收方数据流中重复数据包的可能性。然而，协议
rdt2.2中的接收方已经可以处理重复的数据包。如果接敏方发送丢失的ACK，然后发送方重新传输旧数据，则RDT2.2中的接收方重复出现)。因此。协议rdt22中的接收器
也将作为协议rdt3.0中的接收器工作,
P9、履没协议已经运行了一段时间。发送方处于“从上等待呼叫状态(左上角)，接敏方处于“从下等待0的状态。下图显示了损坏的数据和损坏的ACK的场景。
27 / 79
---
## Page 28
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
Sender sends M0
M0 cormupted
A1
Packet garbled, receiver
Sender ignores A1
resends last ACK (A1)
Corrupted
Timeout: sender
M0
data
resends M0
A0
M1
A1
sender sends M0
M0
sender sends M1
A0
M1
Corrupted
A1 comupted
ACK
Ignore ACK
Timeout: sender
M1
resends M1
A1
M0
P10、在这里，我们添加一个计时器，它的值大于已知的往返传播延退。我们将超时事件添加到等特ACK或NAK0°和等待ACK或NAK1状态。如果发生超时事件。则重
新发送最近发送的数据包。让我们看看为什么这个协议仍将与rdt2.1接收器一起工作。
·假设超时是由丢失的数据包引起的，即发送方到接收方通道上的数据包。在这种情况下，接收机从未接收到先前的传输，并且从接收机的角度来看，如果接收到超
假设现在一个ACK丢失了。接收器最终会在超时时重新发送数据包。但是，重传与ACK被混淆时的动作完全相同。因此，发送者的反应与损失是一样的，就像混乱
时重传，它看起来与接收到的原始传输完全相司。
的ACK一样。RDT2.1接收器已经可以处理混消的ACK的情况。
P11、如果删除了该消息的发送，发送和接收侧将死期，等得永远不会发生的事件，以下是一种场景：
·接收然处于“从下面等待0状态，接收到损坏的数据包来自发送方。假设它不发送任何信息，只需重新输入“等待0"处于"下“状态。
sender发送pkto，输入等待ACKo状态”，等待数据包返回来自接收机
现在，ender正在等待来自接收机的集种类型的ACK，并目接收机等待数据包形成发送方-死机！
P12、该协议仍在工作。因为如果重新传输将是如果接收到情误的分相实际上已经丢失（并目从接收机的观点来看，它从不知道这些事件中的哪一个发生，如果有的
适)。
分组的另一个额外拷贝，发送分组N的次数将随着N接近无穷大而不受限制地增加。
P13,
28 / 79
---
## Page 29
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
M0
AQ
M1
A1
M0
A0
old version of M0
accepted!
M1
https:
feater.top
P14、在仅NAK协议中，只有当接收到分细x+1时，接改方才检测丢包x，也就是说，接收露接收x-1，然后x+1，只有当接收到x+1时，接收器才会意识到x被忽略了。如果
的传输和x+1的传输之间存在很长的疑迟，那么在只使用NAK协议下，需要很长时间才能疾复x
另一方面，如果数据经常被发送，那么以NAK为唯一方案的疾复可能会银快发生。此外，如果错误很少发生，那么Naks只是偶尔核发送（当需要时），并且ACK永远不会
被发送-NAK中的反馈大大减少-仅在ACK的情况下才发送，
P15.发送数据包需要12微秒(或0.012毫秒),作为1500 8/10..... .9 12 微钞。为了使发送者在98的时间里忙绿,现们必额使用ut0.98 (0.012n)/30.012或
n大的2451个数据包。
P16、是。这实际上会导致发送方向通道发送大量流水线数据。
是。这里有一个潜在的问题。如果数据没丢失在通道中，那么RDT3.0的发送方将不会重新发送这些段，除非应用程序中有一些从丢失中恢复的额外机制。
P17.
rdt_send(data)
packet=make_pkt(data)
udt_send(packet)
Wait: send
A
Wait:receive
to B
from B
rdt_send(data)
rdt_send(data)
Rdt_unable_to_send(data)
rdt_receive(packet)
rdt_unable_to_send(data)
extract(packet,data)
deliver_data(data)
rdt_send(data)
packet=make_pkt(data)
udt_send(packet)
Wait: send
B
Wait:receiv
toA
from A
rdt_send(data)
rdt_send(data)
(evep)puasoaiqeunpa
rdt_receive(packet)
rdt_unable_to_send(data)
extract(packet,data)
P18、在我们的解决方案中，发送方将等待接收到一对消息(seqmum和sequm+1的ACK，然后再转到下一对消息。数据包有一个数据字段，并携带两位序列号：也就是
说，有效序列号为0、1、2和3。（注章：您应该考虑为什么1位序列号空间0，1在下面的解决方案中不能工作。）ACK消息携带他们正在确认的数据包的序列号。
发送方和接收方的FSM如图2所示，请注意，发送方状态记录：0当前对末收到ACK，i接收到用于seqmum仅)的ACK，或接收到用于seqrum1的ACK(仅)。在这个图中，
我们假设seqnum最初为0，并目发送者已经发送了第一个两个数据消息（获取要进行的事情），发送方和接收方的时间线跟踪从丢失的数据包中恢复如下所示
29 / 79
---
## Page 30
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
aurhar
sender
+1
apt(rcvpkt)
rupt(rovpkt)
https://featr
+1
receiver
ptrcvpkt
m+2
n+1)
trc（rowpkt
has
ait for
ud_snd(ACK
airof
pkt)
+1)
https:
//featerp
图2：问题的发送方和接收方(3.18)
Sender
Receiver
make pair (0,1)
send packet 0
Packet 0 drops
send packet 1
receive packet 1
buffer packet 1
send ACK 1
rective ACK 1
(timeout)
resend packet 0
receive packet 0
deliver pair (0,1)
send ACK 0
receive ACK 0
P19、这个问题是简单停止和等待协议[Irdt3.0）上的一个变化。由于信道可能丢失消息，并且由于发送方可能重新发送其中一个接收方已经接收到的消息（要么由于过早超
时，要么由于另一个接取方尚末正确接收数据），因此需要序列号，在rdt3.0中，0位序列号在这里就足够了。
30 / 79
---