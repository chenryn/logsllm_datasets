序二进制接口（ABI）规定参数主要通过寄存器来传递。本章后面讨论到栈的利用的时
候，我们将会介绍这个话题。
需要提醒的是，除了先前我们提到的不同之外，我们之前讨论过的所有关于x86的架构的
观点在x86-64架构中都适用。
执行阶段
现在我们已经讨论了架构。是时候开始我们的执行阶段了。正如前面指出的，在很多内核
利用场景中这个阶段还可以细分为两个子阶段：
·获取权限这意味着一旦执行代码就会提升权限（或是获得更多的权限），正如我们接
下来要讨论的，在内核态最通常的操作是定位那些能够保持进程权限跟踪的结构，并将
它们提升至超级用户权限。因为这种代码在内核中拥有超级执行权限，所有用户态的保
护措施都会变得无效。
·稳固系统这意味着要使系统处于稳定状态，以便攻击者可以享用他刚刚获取的系统权
限。正如我们将要讨论的，获取权限代码的执行通常是执行流程重定向的结果。换句话
说，您可能会在完成内核利用之前结束内核执行的流程。如果是这样的话，无论内核执
行流程当前获取的是什么资源（尤其是锁），都需要进行合适保存。内核利用扰乱内核的
状态越厉害，为了系统正确运行而编写的稳固系统的代码就越多。而且，当发生内存破
坏的bug时，从发生溢出到成功劫持工作流可能会花费一些时间。如果任何重写的内存
在此间被访问和检测，必须保证这些检测能够通过。
正如第1章中指出的那样，shellcode是想重定向到的一段汇编指令。很明显，需要将这些
指令放入内存中并且了解它们的地址，这样才能安全地将执行流程定位到该地址。如果在获取
目标地址的时候出现错误，就会失去目标机器的控制权。
放置shellcode
因为失去目标机器不是我们的主要目标，所以让我们看一下安全可靠的shellcode位置的可
选范围。这依赖于漏洞类型（属于控制程度）和使用的内存模型（独立的或者混合的内核态/用
户态地址空间），可以将shellcode放在内核态地址空间或用户态地址空间，或者二者的混合空间。
通常，内核态强加了一些不得不考虑的限制：
·被劫持的内核路径必须能够确定shellcode在内存中的位置。换句话说，shellcode必
shellcode置于实现了用户态/内核态分离地址空间模型的系统的唯一内核上下文中，并
---
## Page 56
第3章成功内核利用进阶47
且置于实现了用户态/内核态混合地址空间模型的系统的内核上下文和返回进程上下文中
（大多数情况下）。
·保存shellcode的内存必须标记为可执行的。换言之，存有shellcode的页需要将执行标志
位打开。如果可以将shellcode放到用户态（这意味着正在瞄准混合的地址空间环境中的
本地漏洞），这就不是一个问题，因为您可以自己设置映射保护。如果将shellcode保存
到内核态，这可能会变得复杂些。
·在一些情况下，存储shellcode的区域必须在内存中。换言之，内核可能会隐含地将要
执行的内存作为分页，所以不能承受再从硬盘中取shellcode页。幸运的是，页将被载
入内存。
现在让我们来讨论放置shellcode的不同方法和如何克服上面讲到的这些限制。
用户态中的shellcode
无论什么时候都能够尝试把shellcode放入用户态。这样会带来很多益处。
首先，这会非常容易地满足前面所罗列的需求，因此能够让您写出优良的内核利用代
码（内核利用可以自动地侦测到一些错误并且能够避免岩机），包括利用本地的或是远程的
漏洞。
对于本地漏洞，我们可以自已触发，因为控制了调用内核的用户态进程。使用操作系统提
即使系统阻止同时可写和可执行的内存映射（在进程的生命周期中阻止一个先前的可写段变成
可执行段），但是仍可以这样操作：
·在编译/链接阶段把shellcode包含到本身的执行文件中。这意味着您可以用C语言编写
shellcode，这是一个非常好的优势。
·把shellcode放到一个文件中并且映射这个文件，并赋予其执行的权限（无写权限）。
您也获得了另外一个优势：将不会受shellcode的空间限制所羁绊。换言之，可以把
shellcode写得足够长，因此可以在它的开始部分添加大量的NOP区域。NOP区域大大增加了
内核利用成功的机会，尤其当没有完全控制将要重定向到劫持控制流的地址。
比方说，您能够控制虚拟地址的前面部分，这就是说内核路径跳转到32位地址的前16
位。留下后16位可以存储其他的数据。通过映射2字节的内存空间，把它填充为NOP指令，
在这之后放置您的shellcode，您能确定无论这些16位的值是什么，都可以正确地执行您想要
执行的代码。如图3.3所示。
如前面指出的那样，使用C语言来编写shellcode代码的能力是一种优势。事实上，尤其
是当有很多的任务要做的时候，使用C语言编写代码而让编译器工作要比编写大量的汇编指令
容易得多。然而，需要指出的是，编译运行在用户态的代码时所选用的编译规约必须与内核所
选用的一样。需要特别关注调用规约（在前面介绍过，这可能与编译的选择有关），否则可能
在函数结束时得不到正确的返回并且导致死机。您还需要尽可能地保证代码独立，并且避免在
运行时使用外部类库中的函数（或者最终静态地编译您的代码，但是不提倡这样做）。作为一
个例子，x86-64架构中的段寄存器的使用方式在用户态和内核态不同，这意味着您将停止使用
---
## Page 57
48第一部分内核态
一个在用户态中非常有意义的段寄存器。
32位进程布局
用户态
用户态
--0x40000000---
NOP区
64字节
NOP区
shellcode
←---0×40010000---
shellcode
内核指
针指向
用户态
内核态
内核态
部分2字节覆盖
功能指针
用0x400
功能指针
内核代码
内核代码
指针覆盖前
部分指针覆盖后
图3.3shellcode顶部的NOP放置区
克服前面指出的第三种限制通常不需要花费太多的额外努力。如果shellcode是可执行利用
的一部分，在一个页当中它们可能会用来运行可执行代码，而且在达到目的之前不会从内存中
清除。无论如何，您都可以从保存有shellcode的虚拟地址空间中读取一个字节以驱动内核把具
体的页加载到内存。
当确定shellcode跟内核路径所依赖的内核内存模型和漏洞具有一样的周边环境时，您不能
在内核态和用户态在适当位置分开的系统中使用用户态的方法。在这种情景下，用户态的虚拟
地址空间在内核态中会有完全不同的意义。
为了能够成功地获取shellcode代码，还需要工作在与劫持内核路径相同的执行环境中，以
保证您所运行的进程所在的页表是内核态中正在使用的活动页表。这也就是说，在进入内核态
之前的用户态指令和容易受攻击的内核路径必须运行在同一个CPU中。即使当代码发生系统调
用或同步中断时，也是这种情况。然而，如果易受攻击的内核路径存在于一个异步中断处理程
序中或延迟的程序中（将安排中断例程稍后执行或是在对称多处理器环境中运行在另一个CPU
上），这一切将会发生改变。在这种情况下（在内核态和用户态地址空间独立的情况下），您需
要考虑一种清理内核态中的shellcode或者至少一种混合/多阶段的方法。
内核态中的shellcode
如果不能将您的shellcode置于用户态中，您就需要将其放于内核态中。然而，内核态中的
---
## Page 58
第3章成功内核利用进阶49
生命周期不像在用户态中那样简单，您需要克服很多的障碍和问题。
·不能够控制内核态的页保护。您需要寻找一段已经映射为可执行且可读的内存区域。而
这可能不是始终可行的。
·在内核态，拥有非常有限的虚拟地址空间。换句话说，在缺少信息泄露的状况下，我们
将会依赖内核输出和从用户态搜集到的信息，正如我们将在第4章中讨论的部分一“信
息收集阶段”。
·由于我们通常没有直接向内核态的缓冲池中写入的途径，所以可能需要我们想出更为巧
妙和原始的方法来把shellcode放人内核态的地址空间中。
·假设您找到并控制了一段内存空间，但由于受限只能使用这块空间的一部分。换言之，
必须非常关注shellcode的长度。而且，shellcode大多数需要用汇编（最优）来写。
另外，内核页表明显对任何可执行的内核路径都是可见的（它们在同样的环境当中）。通
常它们都在当前页中（比如，内核代码在内存中锁定并且操作系统明确指出内核区域是不可调
页的）。我们将在第4章和第5章中更为具体地讨论只存放到内核态地址空间的shellcode。
混合或多阶段的shellcode
由于内核缓存区大小的限制以及用户态所展现出来的优势，完全放置于内核态地址空间的
shellcode还不是非常普遍。一个非常典型的方法就是在内核态中保留一个与用户态通信信道的
顺序设置相关的复本，或者为进入用户态做简单的准备。我们把这种方法称为混合或多阶段的
shellcode，用这种方法来描述执行流从内核态到用户态的多个阶段跳转。
当开发在中断环境中触发漏洞的程序时，混合或多阶段的shellcode是很常用的，尤其远程
内核漏洞可能会触发由网卡（我们将在第7章和第8章详细讨论）所引起的中断例程中的bug。
关键问题是：中断环境多种多样，但它不是一个良好的执行环境。毫无疑问的是，内核级别的
中断例程通常应该尽可能小。
注意虽然跳转到用户态结束位置的shellcode是一种经典的方法，但是将多级
shellcode置于完全的内核运行环境中也是可行的。在这种情况下，我们仍旧比较倾向
于多级shellcode而不是只在内核空间的shellcode。
让我们更为详细地看一个混合或多阶段的shellcode的例子。为了简单起见，我们考虑一个
两阶段shellcode（但是要记住有时候可能会需要更多个阶段的shellcode）：
1）第一个阶段的第一件事情就是要在内核态中找个存储shellcode的地方。我们可以通过
分配一块新的空间或把一个已知的地址空间的静态数据替换掉来达到这一目的。需要指出的
是，现在已经可以开始执行了，因为您的“兵工厂”中已经有了一件巨大的“武器”：您能够
用内核子系统和内部结构去寻找您感兴趣的内存空间。比如，一个高级的shellcode可以遍历活
动进程表并且找到正在监听套接字的进程，或是遍历内核的符号列表并且解析诸如系统调用表
等重要的系统结构的地址。
2）在第二阶段的相应代码放置在内核相应的位置后，第一阶段需要将控制权交给它。如
果需要，可以从中断环境中跳出来实现。比如，在前一阶段找到系统调用表后，可以将经常使
---
## Page 59
50第一部分内核态
用的系统调用的地址替换，然后等待一个进程触发它。到那时，代码就会在比较合适的进程环
境中执行。
混合的shellcode也需要满足我们在这部分一开始介绍的那些限制，与在用户态和内核态
中相应的限制一样，这依赖于这个阶段要在哪儿执行。正如您将在本书第三部分看到的那样，
当我们讨论远程内核利用的时候，一个三阶段的方法也是这种方式。第一阶段设置进程环境转
换，第二阶段修改一些用户程序地址空间，然后跳转到用户态去执行第三阶段的shellcode（在
用户态套接字的操作要比代码的操作容易得多）。
回到内核主题
我们将以一种特殊的内核态shellcode来结束分析。高级的内核保护阻正您利用shellcode
发现一个可执行且可写空间，用这种方式我们可以绕过这个障碍。这里展示的技术通过创建一
可执行区域。如果您对用户态的漏洞利用比较熟悉，这种方法类似于使用返回库技术和代码借
用技术来绕过不能执行的内存保护。
这种技术的第一道关卡是至少有一个空间映射为可执行的：内存映射组成可执行体本身。
加载模块的代码段（如果在使用一个模块化的内核）。第二道关卡是在可执行的映射中能够发
现很多的指令，如果串联到一起并且使用正确的话，这些指令的执行可能会提升用户权限。
这种技术跟底层基础架构（并且依赖于）关系非常紧密，如应用程序二进制接口（ABI），
甚至编译器。我们感兴趣的是正在使用的调用规约（比如，返回值地址在哪里？参数是如何传
递的？）。
提示在x86/x86-64的架构中，指令的大小是可变的，允许从任何地址（甚至是某
个指令的中间）开始执行，并从此处开始解释二进制位。这经常用于发现段序列。
例如：
abb5bc3ffff
mov$0xffffc35b.eox
b）5b
popebx
C3
ret
跳转到mov操作码的第一个字节后，接下来会顺序进入pop%ebx；ret，即使这两条
指令没有在内核中连续使用。需要指出的是，我们不必为ret指令后是否为有效的指
令而烦恼，因为在执行ret指令后到达有效指令前控制流将会转移。在RISC架构中，
指令的大小是固定的。跳转到没有跟指令大小对应的地址将会产生错误。从根本上
说，不能够跳转到一个指令的中间并将其解析成不同的指令。
各种过程函数的返回地址通常都保存在栈中，在大多数情况下，这种技术对栈的控制是一
项强制性的要求。最经典的方案是栈的溢出允许我们重写返回地址，而且如果应用程序二进制
接口（ABI）规定参数通过栈来传递（以x86-32位系统为例），那么可以为目标函数伪造一个
参数集。这样将会有很多的选择，这依赖于以下几点：
---
## Page 60
第3章成功内核利用进阶51
·漏洞允许您做什么。换言之，有多少栈空间可以用来重写，对重写的值能控制到什么
程度。
器。如果函数的参数通过栈来传递，就需要更多的栈空间，但是对函数将来的用途会有
更多的选择。如果通过寄存器来传递参数，需要以某种方式将适当的值保存到寄存器中，
但是最终可能只需要用到少量的栈空间。
占位符空间组成的shellcode。这个shellcode将做以下几件事：
·使用内核函数分配一些内存空间并且标记为可读。
·利用一个内核函数从用户态（或是从可知的内核态）复制一些字节单元到返回前的地址。
·抛弃最后的返回地址，以便代码跳转到选定的内存地址执行。
复制来的代码开始执行，并且从那一刻开始您将处于传统的内核shellcode环境当中。
可以想象，当栈被很多函数使用时，这种方法会变得越来越复杂。对那些熟悉用户态内核
漏洞利用的人来讲，这种方法可以看做是内核级别的（return-into-lib）。
幸运的是，由于您没有必要返回一个函数的入口点，所以还有另外一个方法。假设我们拥
有内核代码地址空间的所有知识（当在详细看了“信息收集阶段”部分后，这并不是一个不可
能达到的状况），就可以找到很多有用的指令。例如，考虑一下我们使用的操作系统的权限系
统：最可能的情况是，一个内核函数（甚至是内核系统调用）允许一个授权的进程去降低或是
提升该进程的权限。这个函数将接受新的进程权限值作为参数，然后对这个进程做很多的检测
（很明显，一个没有权限的进程不能提升它本身的权限），最后执行一些代码来复制进程存储的
权限值。不论选择什么样的架构和编译器，这个新的权限值最终将会保存到一个寄存器中，因
为多个使用者可能会访问它（核对当前的进程，检查这是不是一个授权的请求，并且最终将权
限值保存到相应的进程凭证结构中）。
这时，可以做下面几件事：
·可以在寄存器中设置最高权限值，控制栈并没有听起来那么复杂。您需要做的就
是编写一段代码，将当前栈中的内容出栈并保存到寄存器中，然后指定一个返回
调用（通常仅仅将一个值出栈并将它作为返回值）。即使执行序列在内核中从来没
有用过，也可以在一个非RISC架构的内存中的某处发现它，正如前面内容中提到
的那样。
提示0是一个表明高权限的经典数值（当用整数值表示时）。当用位掩码来表示权限
集时，OxFFFFFFFF是个经典数值。这两个值在函数中都非常普遍（正如一1经常表
示一个错误而0表示成功）。可以将返回值设置到寄存器（绕过我们描述的第一阶段）
中并不始终是件坏事·
·将返回地址放置到栈中，使它正好处于权限设置函数的检测语句之后。