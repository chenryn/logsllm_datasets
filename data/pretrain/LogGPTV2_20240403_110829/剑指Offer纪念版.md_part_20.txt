图3.12
质量的代码，如图3.12所示。
本章小结
本章从规范性、
本题考点：
规范性
测试用例：
从规范性、安
书写清晰
慎程序就会崩溃。应聘者需要采用防御性编程的方式，每次访问
考查代码的鲁棒性。本题的代码中含有大量的指针操作，稍有不
考查对二叉树遍历算法的理解及递归编程能力。
指针地址之前都要考虑这个指针有没有可能是NULL。
二叉树的所有结点都没有左子树或者右子树)。
特殊输入测试（两棵二叉树的一个或者两个根结点为NULL指针、
的子结构)。
功能测试（树A和树B都是普通的二叉树，树B是或者不是树A
完整性和鲁棒性3个方面提高代码的质量
做好错误处理
、完整性和鲁棒性3个方面介绍了如何在面试时写出高
考虑边界条件
完成基本功能
完整性
处理无效的输入
采取防御式编程
鲁棒性
高质量的代码121
---
## Page 136
122剑指Offer一
种无效输入做好相应的处理。
应聘者最好养成防御式编程的习惯，在函数入口判断输入是否有效并对各
这3方面的代码才是完整的代码。
基本功能之外，还考虑了边界条件，并做好了错误处理。只有全面考虑到
代码布局合理，同时合理命名代码中的变量和函数。
的时候要注意规范性，尽量清晰地书写每个字母，通过缩进和对齐括号让
另外，要确保自己写出的程序不会轻易崩溃。平时在写代码的时候，
最好在编码之前全面考虑所有可能的输入，确保写出的代码在完成了
大多数面试都是要求应聘者在白纸或者白板上写代码。应聘者在编码
一名企面试官精讲典型编程题（纪念版）
---
## Page 137
面试官谈面试思路
的人员，除非后面表现非常优秀，否则很容易通不过。”
做事之前明白自己要做的事情究竟是什么，以及该怎么做。
“让应聘者给我讲具体的问题分析过程，经常会要求他证明。”
“编码前讲自己的思路是一个考查指标。一个合格的应聘者应该在他
解决面试题的思路
-殷焰（支付宝，高级安全测试工程师）
-张晓禹（百度，技术经理）
一开始就编码
第4章
---
## Page 138
124
剑指Offer
并加以改正。”
他证明是否正确，主要是希望他能在分析的过程中发现这些错误和漏洞
楚思路和设计。”
方式，解释清楚问题本身和问题解决方案是关键。”
没有想清楚就动手本身就不是太好。应聘者可以采用举例子、画图等多种
“喜欢应聘者在写代码之前先讲思路，举例子和画图都是很好的方法。”
“喜欢应聘者先讲清思路。如果觉察到方案的错误和漏洞，我会让
“对于比较复杂的算法和设计，
“个人比较倾向于让应聘者在写代码之前解释他的思路。
一名企面试官精讲典型编程题（纪念版）
一般来讲最好是在开始写代码前讲清
-何幸杰（SAP，高级工程师）
-陈黎明（微软，SDEII)
-尧敏（淘宝，资深经理）
-田超（微软，SDEII)
1
应聘者如果
---
## Page 139
structBinaryTreeNode
面试题19：二叉树的镜像
是有益的，因为面试官会觉得他有很好的沟通交流能力。
着图形一边讲解，面试官就能更加轻松地理解应聘者的思路。这对应聘者
应聘者光用语言未必能够说得清楚。这个时候可以画出几个图形，一边看
果能够画出每一步操作时的指针操作，那接下来写代码就会容易得多。
够很容易找到最后一圈退化的规律。对于面试题26“复杂链表的复制”，如
（因为最后一圈可能退化而不是一个完整的圈），如果画几张示意图，就能
然后从外向内打印每个圆圈。面试的时候很多人都会在边界条件上犯错误
印矩阵”中，我们画图之后很容易就发现可以把矩阵分解成若干个圆圈，
就是在遍历树的同时交换非叶结点的左右子结点。在面试题20“顺时针打
叉树的镜像”中我们画几张二叉树的图就能发现，求树的镜像的过程其实
规律和特点，随手画几张图却能让我们轻易找到窍门。比如在面试题19“二
都可以采用画图的方法来分析。很多时候空想未必能想明白题目中隐含的
化，应聘者说不定通过几个图形就能找到规律，从而找到问题的解决方案
关的图形，借以辅助自己观察和思考。图形能使抽象的问题具体化、形象
多面试题很抽象，不是很容易找到解决办法。这时不妨画出一些与题目相
画图让抽象问题形象化
在面试的时候应聘者需要向面试官解释自己的思路。对于复杂的问题
树的镜像对很多人来说是一个新的概念，我们未必能够一下子想出求
BinaryTreeNode*
int
二叉树结点的定义如下：
题目：请完成一个函数，输入
有不少与数据结构相关的问题，比如二叉树、二维数组、链表等问题
画图是在面试过程中应聘者用来帮助自己分析、推理的常用手段。很
m_nValue;
m_pRight;
一个二叉树，该函数输出它的镜像。
第4章解决面试题的思路
125
---
## Page 140
126
剑指Offer
void MirrorRecursively (BinaryTreeNode *pNode)
当交换完所有非叶子结点的左右子结点之后，就得到了树的镜像。
这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子结点。
点；（c）交换值为6的结点的左右子结点。
图4.2求二叉树镜像的过程
白白白回 白四白白
始树的镜像。
之后，我们已经遍历完所有的非叶子结点。此时变换之后的树刚好就是原
换之后的结果分别是图4.2中的第三棵树和第四棵树。做完这两次交换
结点仍然保持不变，因此我们还需要交换这两个结点的左右子结点。交
在树中交换根结点的两个子结点，就得到图4.2中的第二棵树。
树的根结点相同，但它们的左右两个子结点交换了位置。因此我们不妨先
图4.1两棵互为镜像的二叉树
树的镜像。
然后根据照镜子的经验画出它的镜像。如图4.1中右边的二叉树就是左边的
树的镜像的方法。为了能够形成直观的印象，我们可以自己画一棵二叉树，
想清楚了这个思路，我们就可以动手写代码了。参考代码如下：
交换根结点的两个子结点之后，我们注意到值为10、6的结点的子
仔细分析这两棵树的特点，看看能不能总结出求镜像的步骤。这两棵
总结上面的过程，我们得出求一棵树的镜像的过程：我们先前序遍历
注：（a）交换根结点的左右子树；（b）交换值为10的结点的左右子结
。
回命回
一名企面试官精讲典型编程题（纪念版）
日
白白白口白白白
15
---
## Page 141
个数字。例如：如果输入如下矩阵：
面试题20：顺时针打印矩阵
题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每
if (pNode->m_pRight)
if（pNode-
if（pNode == NULL)
上面的代码是用递归实现的。如果要求用循环，该如何实现？
本题完整的源代码详见19_MirrorOfBinaryTree 项目。
本题扩展
本题考点
测试用例
源代码
MirrorRecursively(pNode->m_pRight);
考查应聘者的思维能力。树的镜像是一个抽象的概念，应聘者需
考查对二叉树的理解。本题实质上是利用树的遍历算法解决问题
特殊输入测试（二叉树的根结点为NULL指针)。
功能测试（普通的二叉树，
return;
图把抽象的问题形象化，这有助于其快速找到解题思路。
要在短时间内想清楚求镜像的步骤并转化为代码。应聘者可以画
右子树，只有一个结点的二叉树)。
>m_pLeft== NULL && pNode->m_pRight==NULL)
二叉树的所有结点都没有左子树或者
第4章解决面试题的思路127
---
## Page 142
128
剑指Offer-
void PrintMatrixClockwisely(int**numbers,
用如下的循环来打印矩阵：
循环继续的条件是columns>startX×2 并且rows>startY×2。所以我们可以
角的坐标仍然为(2,2)。我们发现6>2×2依然成立。于是我们可以得出，让
我们发现5>2×2。对一个6×6的矩阵而言，最后一圈有4个数字，其左上
可以在矩阵中选取左上角为(start,start)的一圈作为我们分析的目标。
1)，依此类推。我们注意到，左上角的坐标中行标和列标总是相同的，于是
columns。打印第一圈的左上角的坐标是(0,0)，第二圈的左上角的坐标是(1.
图4.3把矩阵看成由若干个顺时针方向的圈组成
图4.3所示。我们可以用一个循环来打印矩阵，每一次打印矩阵中的一个圈。
是以从外圈到内圈的顺序依次打印，我们可以把矩阵想象成若干个圈，如
路，并把复杂的问题分解成若干个简单的问题。
不可避免会越写越混乱。因此解决这个问题的关键在于先要形成清晰的思
还需要判断多个边界条件。如果在把问题考虑得很清楚之前就开始写代码，
很简单的问题。但实际上解决这个问题，会在代码中包含多个循环，并且
对一个5×5的矩阵而言，最后一圈只有一个数字，对应的坐标为(2,2)。
接下来分析循环结束的条件。假设这个矩阵的行数是rows，列数是
当我们遇到一个复杂问题的时候，可以用图形来帮助我们思考。由于
这道题完全没有涉及复杂的数据结构或者高级的算法，看起来是一个
则依次打印出数字1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、10。
3
6
5
14
10
9
2
名企面试官精讲典型编程题（纪念版）
11
3
16
12
8
4
int columns,introws）
---
## Page 143
start)
void PrintMatrixInCircle(int** numbers, int columns, int rows, int
两列，因此要求终止行号比起始行号至少大2，同时终止列号大于起始列号。
求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少有三行
圈内至少有两行两列，也就是说除了要求终止行号大于起始行号之外，还要
第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条件是
为打印一圈至少有一步。如果只有一行，那么就不用第二步了。也就是需要
图4.4打印矩阵最里面一圈可能只需要三步、两步甚至一步
的例子，打印一圈分别只需要三步、两步甚至只有一步。
至只有一个数字，因此打印这样的一圈就不再需要四步。图4.4是几个退化
或者一列。
印一列。每一步我们根据起始坐标和终止坐标用一个循环就能打印出一行
第二步从上到下打印一列，第三步从右到左打印一行，第四步从下到上打
如图4.3所示，我们可以把打印一圈分为四步：第一步从左到右打印一行，
通过上述的分析，我们就可以写出如下代码：
因此我们要仔细分析打印时每一步的前提条件。第一步总是需要的，因
不过值得注意的是，最后一圈有可能退化成只有一行、只有一列，甚
接着我们考虑如何打印一圈的功能，即如何实现PrintMatrixInCircle。
while(columns >start×2 && rows >start ×2)
int start = O;
if(numbers==NULL1lcolumns <=011rows<=0)
++start;
PrintMatrixInCircle(numbers, columns,rows,start);
return;
第4章解决面试题的思路
129