### Identity Hiding in PQ-WireGuard

Identity hiding is a property that was proven in the symbolic proof for WireGuard. When adapting this proof to the KEM setting of PQ-WireGuard, Tamarin successfully proves the property. However, it turns out that the model in this case makes an idealizing assumption that may not hold in the KEM setting: the Tamarin model assumes a key hiding property, meaning that a key encapsulation (in the case of DH, a key exchange message) does not allow an adversary to learn under which public key it was produced. For DH key exchange, this can be derived from the Decisional Diffie-Hellman (DDH) assumption (against passive adversaries) or the PRFODH assumption (against active adversaries).

For KEMs, this assumption is not implied by the standard security assumptions of IND-CPA and IND-CCA security. A counterexample is a KEM that includes the public key as part of the key encapsulation, which does not invalidate IND-CPA or IND-CCA security. What is formally required to justify the applicability of the model is a KEM version of the notion of indistinguishability of keys (IK). For active adversaries, IK-CCA is required, and for passive adversaries, IK-CPA is sufficient. It has been shown that the public key encryption scheme underlying Classic McEliece achieves IK-CPA security. Based on this, we conjecture that the Classic McEliece KEM achieves IK-CCA security, although we do not formally prove it.

### Instantiation with McEliece and Saber

The generic approach for a purely KEM-based variant of WireGuard allows us to instantiate the protocol with any post-quantum KEMs that meet the required security properties. In this section, we describe the specific instantiation we chose: the Classic McEliece [22] IND-CCA KEM and an IND-CPA secure variant of Saber [24], [23]. This choice, like the choices of primitives in WireGuard, is "cryptographically opinionated." The criteria for our selection are:

1. **Standardization Potential**: Stick to primitives that are in the second round of the NIST PQC project and have the potential to become future standards.
2. **Security Level**: Choose parameters that reach NIST security level 3.
3. **Packet Efficiency**: Do not increase the number of required unfragmented IPv6 packets for the handshake compared to WireGuard (one sent by the initiator and one by the responder, plus the key-confirmation by the initiator).
4. **Performance**: Pick primitives that have high-performance, timing-attack protected implementations.
5. **Conservatism**: Select "conservative" primitives, i.e., those with a history of cryptanalytic results.
6. **Patent-Free**: Stay away from primitives encumbered by patents.
7. **No Modifications**: Do not modify or tweak primitives in any way that would invalidate security reductions.

The most limiting criterion is fitting the initiator's and responder's handshake messages into one IPv6 packet each. IPv6 mandates every link in the internet to support an MTU of at least 1280 bytes. After accounting for the IPv6 and UDP headers, 1232 bytes remain for the WireGuard handshake payloads. In the initiator's message, the fields type, 03, sidi, ltk, time, m1, and m2 together occupy 116 bytes, leaving 1116 bytes for a CPAKEM public key and a CCAKEM ciphertext. In the responder's message, the fields type, 03, sidi, sidr, zero, m1, and m2 together occupy 60 bytes, leaving 1172 bytes for a CPAKEM ciphertext and a CCAKEM ciphertext.

#### Classic McEliece as CCAKEM

In Algorithm 2, the handshake never sends public keys of CCAKEM, and the computation does not involve any CCAKEM.Gen operations. Therefore, for the instantiation of CCAKEM, we are primarily concerned with ciphertext size, with secondary criteria being encapsulation and decapsulation speed. Among all round-2 NIST PQC candidate KEMs, Classic McEliece has the smallest ciphertext, weighing in at only 188 bytes for the level-3 parameter set mceliece460896. Additionally, Classic McEliece comes with very fast, timing-attack-protected software for encapsulation and decapsulation, making it the ideal choice for our use case. Note that while McEliece is often regarded as a conservative but inefficient choice due to its slow key generation and large public keys, these disadvantages do not matter for our use case.

#### Tweaked Saber as CPAKEM

With the straightforward choice of Classic McEliece as the CCAKEM, we need to find an IND-CPA KEM among the NIST candidates with public keys of at most 928 bytes and ciphertexts of at most 984 bytes for parameters that reach NIST security level 3. The only KEMs meeting these criteria are Round5 [65], SIKE [66], and ROLLO-I [67]. Unfortunately, none of these meet our other criteria. Round-5 is covered by patents, SIKE is rather slow, and ROLLO-I is not considered particularly conservative.

Among the remaining candidates, there are multiple lattice-based KEMs with public keys and ciphertexts that are only slightly larger than what we need. Saber already includes public-key and ciphertext compression and carefully chooses parameters to minimize sizes while keeping the failure probability δ cryptographically negligible. We decided to propose an IND-CPA version of Saber, which further compresses public keys and ciphertexts. This comes at the additional advantage of making the underlying hard lattice problem harder, but at the expense of significantly increased failure probability. Specifically, the Saber specification states that a higher choice for parameters p and T will result in lower security but higher correctness [24, Sec. 2.2].

The original parameters for the level-3 parameters of Saber use p = 210 and T = 24; we propose to use p = 29 and T = 23 for an IND-CPA variant of Saber, which we refer to as "Dagger." Compared to Saber, Dagger reduces the public-key size from 992 bytes to 896 bytes and the ciphertext size from 1088 bytes to 960 bytes, well within our limits. To analyze the failure rate and bit security of Dagger, we adapted the Python script that comes with the Saber submission package to run on the new parameters. This adapted Python script is included with the software package at https://cryptojedi.org/crypto/#pqwireguard. Compared to Saber, the post-quantum bit security of Dagger increases from 180 to 198 bits, and the failure probability increases from 2−136.14 to 2−25.25. On the protocol level, such a failure has a similar effect to a failed UDP packet transmission, meaning about one out of every 40 million handshakes will need to be repeated. In addition to the modified values of p and T, Dagger does not use the Fujisaki-Okamoto transform, which Saber uses to build an IND-CCA KEM from an IND-CPA public-key encryption scheme. For a pseudocode description of Dagger, see Appendix A.

### Performance Analysis

We compare the handshake efficiency using the following metrics: the amount of traffic, the number of packets exchanged, and the time span of the handshake. The client time span is the elapsed time between when the client starts any computation for a handshake and when session keys are derived on the client side. Similarly, the server time span is the elapsed time between the server receiving an initiation packet from the client and the server being ready to send application data to the client.

The handshake protocol of each VPN software was invoked 1000 times to compute the average and standard deviation (enclosed by parentheses) of these metrics. The results for IPv4 and IPv6 are presented in Table III and Table IV, respectively. In both tables, the amount of traffic includes the 14-byte Ethernet frame headers.

### Resource Requirements for VPN Handshake Protocols over IPv4

| **VPN Software** | **WireGuard** | **PQ-WireGuard (this paper)** | **IPsec (RSA-2048)** | **IPsec (Curve25519)** | **OpenVPN (RSA-2048)** | **OpenVPN (NIST P-256)** | **OpenVPN-NL (RSA-2048)** | **OpenVPN-NL (NIST P-256)** | **PQ-OpenVPN (Frodo-752)** | **PQ-OpenVPN (SIDHp503)** |
|------------------|---------------|-------------------------------|-----------------------|------------------------|-------------------------|---------------------------|-----------------------------|------------------------------|------------------------------|------------------------------|
| **Packet Number** | 3 (0)         | 3 (0)                         | 6 (0)                 | 4 (0)                  | 21.005 (0.071)          | 19.005 (0.007)            | 19.005 (0.007)              | 19.006 (0.078)               | 63.001 (0.032)               | 23.003 (0.055)               |
| **Traffic (bytes)** | 398 (0)       | 2594 (0)                      | 4123 (0)              | 2145 (0)               | 7535.507 (7.940)        | 5408.572 (7.997)          | 5685.585 (8.155)            | 5681.711 (8.979)             | 34348.114 (3.569)            | 5681.711 (8.979)             |

The experiments were carried out between two virtual machines managed by VMware’s “vSphere” in version 6.7, connected through a virtual Ethernet link (VMware “vSwitch”) with a bandwidth limit of 10 Gbit/s. Both virtual machines are running Linux kernel 4.15.0, and the underlying physical machine is powered by Intel Xeon Gold 6130 (Skylake) CPUs running at 2.1 GHz.