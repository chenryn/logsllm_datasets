// and no honest peer has ever sent an init msg with kb
& not(Ex pki1 pkr1 peki1 psk1 #j.
ISend() @ #j & #j  // then PSK between R and I was compromised (or not in use)
Ex #j. Reveal_PSK(psk) @ j & #j ) @ i
// and the init msg was generated by honest peer I
// for another peer R’ and is replayed or intercepted
// by the attacker (fields tampered)
& (Ex pki pkr1 peki1 psk1 #j.
ISend() @ j
& #j  // then PSK between R and I was compromised (or not in use)
(Ex #j. Reveal_PSK(psk) @ #j & #j < #i)
)"
i.e.,
Identity Hiding. Indentity hiding is a property that was proven
in the symbolic proof for WireGuard. When adapting the proof
to the KEM setting of PQ-WireGuard Tamarin successfully
proves the property. However, it turns out the model in this
case makes an idealizing assumption that is not necessarily
true in the KEM setting: The Tamarin model assumes a key
hiding property,
that a key encapsulation (in case of
DH a key exchange message) does not allow to learn under
which public key it was produced. For DH key exchange this
can be derived from the DDH assumption (against passive
adversaries) or the PRFODH assumption (against active ad-
versaries).
For KEMs this assumption is not implied by the standard
security assumptions of IND-CPA and IND-CCA security. For
a counter example consider a KEM that makes the public
key part of a key encapsulation. This does not
invalidate
IND-CPA or IND-CCA security. What is formally required
to justify the applicability of the model is a KEM version
of the notion of indistinguishability of keys (IK) [62]. For
active adversaries IK-CCA is requried, for passive adversaries
IK-CPA is sufﬁcient. In [63] it
the public
key encryption scheme underlying Classic McEliece achieves
is shown that
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:30 UTC from IEEE Xplore.  Restrictions apply. 
314
IK-CPA security. Based on this we conjecture that the Classic
McEliece KEM achieves IK-CCA security but we do not
formally prove it.
V. INSTANTIATION WITH MCELIECE AND SABER
The generic approach for a purely KEM-based variant of
WireGuard allows us in principle to instantiate the protocol
with any post-quantum KEM(s) with the required security
properties. In this section we describe the concrete instanti-
ation we chose. We selected the Classic McEliece [22] IND-
CCA KEM and an IND-CPA secure variant of Saber [24],
[23]. One could say that this choice—just like the choices of
primitives in WireGuard—is “cryptographically opinionated”.
The criteria by which we made this choice are the following:
• stick to primitives that are in the second round of the
NIST PQC project and thus have potential to become a
future standard;
• choose parameters that reach NIST security level 3
(see [64, Sec. 4.A.5]);
• do not increase the number of required unfragmented
IPv6 packets for the handshake compared to WireGuard
(one sent by the initiator and one by the responder,
plus the key-conﬁrmation by the initiator that is implicit
through application-data transmission in WireGuard and
explicit in PQ-WireGuard).
• pick primitives that have high-performance timing-attack
protected implementations;
• pick “conservative” primitives, i.e, primitives building on
a history of cryptanalytic results;
• stay away from primitives that the submitters declare to
be encumbered by patents; and
• do not modify or tweak primitives in any way that would
invalidate security reductions.
The most limiting of these criteria is to ﬁt the initiator’s
and the responder’s handshake messages into one IPv6 packet
each. IPv6 mandates every link in the internet to support an
MTU of at least 1280 bytes [20, Sec. 5]. Out of those 1280
bytes, 40 are required for the IPv6 header and another 8 are
required for the UDP header. This leaves 1232 bytes for the
WireGuard handshake payloads. In the initiator’s message, the
ﬁelds type, 03, sidi, ltk, time, m1, and m2 together occupy
116 bytes, which leaves 1116 bytes for a CPAKEM public
key and a CCAKEM ciphertext. In the responder’s message,
the ﬁelds type, 03, sidi, sidr, zero, m1, and m2 together
occupy 60 bytes, which leaves 1172 bytes for a CPAKEM
ciphertext and a CCAKEM ciphertext.
Classic McEliece as CCAKEM. Note in Alg. 2 that
the
handshake never sends public keys of CCAKEM; also the
computation does not involve any CCAKEM.Gen operations.
This means that for the instantiation of CCAKEM we are
mainly concerned about ciphertext size with secondary criteria
being encapsulation and decapsulation speed. Out of all round-
2 NIST PQC candidate KEMs4, Classic McEliece has the
4For an overview, see https://pqc-wiki.fau.edu/
smallest ciphertext by far, weighing in at only 188 bytes
for the level-3 parameter set mceliece460896. Also, Classic
McEliece comes with very fast timing-attack-protected soft-
ware for encapsulation and decapsulation, which makes it the
ideal choice of primitive for our use case. Note that McEliece
is often regarded as a conservative, but rather inefﬁcient
choice, because of its slow key generation and large public
keys – however, these disadvantages are precisely the aspects
that do not matter for us here.
Tweaked Saber as CPAKEM. With the rather straightforward
choice of Classic McEliece as instantiation of CCAKEM
ﬁxed, we need to ﬁnd an IND-CPA KEM among the NIST
candidates that has public keys of at most 928 bytes and
ciphertexts of at most 984 bytes for parameters that reach
the NIST security level 3. The only KEMs that meet these
criteria are Round5 [65], SIKE [66], and ROLLO-I [67].
Unfortunately, none of these three meets our other criteria.
Round-5 is covered by patents held by the submitters; SIKE
is rather slow, for example more than an order of magnitude
slower than most lattice-based KEMs, and ROLLO-I cannot be
seen as a particularly conservative choice. Speciﬁcally, in the
document explaining the choice of round-2 candidates [68],
NIST writes about the rank-based candidate ROLLO-I:
“Nonetheless rank-based cryptography is quite new
and not as well studied as lattice-based cryptogra-
phy or code-based cryptography using the Hamming
metric. More cryptanalysis on rank-based primitives
would be valuable.”
However, among the remaining candidates, there are mul-
tiple lattice-based KEMs with public keys and ciphertext that
are only slightly larger than what we need. Also, most of
them aim for IND-CCA security (which we do not need to
instantiate CPAKEM) and some of them allow to reduce the
size of public keys and ciphertexts at the expense of achieving
only IND-CPA security and increasing failure probability.
Concretely, Saber already includes public-key and ciphertext
compression, and, in order to achieve IND-CCA security, care-
fully chooses parameters to minimize sizes while keeping the
failure probability δ cryptographically negligible. We decided
to propose an IND-CPA version of Saber, which compresses
public keys and ciphertexts even further. This comes at the
additional advantage that the underlying hard lattice problem
becomes harder, but at the expense of signiﬁcantly increased
failure probability. Speciﬁcally, the Saber speciﬁcation states
that “a higher choice for parameters p and T , will result
in lower security, but higher correctness” [24, Sec. 2.2]; the
parameters p and T are precisely what controls public-key and
ciphertext sizes.
The original parameters for the level-3 parameters of Saber
use p = 210 and T = 24; we propose to use p = 29 and
T = 23 for an IND-CPA variant of Saber. In the following
we will refer to this variant of Saber as “Dagger”. Compared
to Saber, the modiﬁcations in Dagger reduce the public-key
size from 992 bytes to 896 bytes and the ciphertext size from
1088 bytes to 960 bytes, which is well within our limits. To
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:30 UTC from IEEE Xplore.  Restrictions apply. 
315
analyze the failure rate and bit security of Dagger, we adapt the
Python script that comes with the Saber submission package
to run on the new parameters. This adapted Python script is
included with the software package at https://cryptojedi.org/
crypto/#pqwireguard. Compared to Saber, the post-quantum
bit security of Dagger increases from 180 to 198 bits; the
failure probability increases from 2−136.14 to 2−25.25. Note
that on the protocol level such a failure has a similar effect
to a failed UDP packet transmission. Essentially it means that
about one out of every 40 million handshakes will need to be
repeated. In addition to the modiﬁed values of p and T , Dagger
does not use the Fujisaki-Okamoto transform [30], i.e., the
construction that Saber uses to build an IND-CCA KEM from
an IND-CPA public-key encryption scheme. For a pseudocode
description of Dagger see Appendix A.
We compare the handshake efﬁciency by the following met-
rics: the amount of trafﬁc, the number of packets exchanged,
and the time span of the handshake. The client time span is the
elapsed time between when the client starts any computation
for a handshake and when session keys are derived from the
handshake on the client side. Similarly, the server time span
is the elapsed time between the server receiving an initiation
packet from the client and the server being ready to send
application data to the client.
The handshake protocol of each VPN software was invoked
for 1000 times to compute the average and standard deviation
(enclosed by parentheses) of those metrics. The results with
IPv4 and IPv6 are presented in Table III and Table IV,
respectively. In both tables, the amount of trafﬁc includes the
14-byte Ethernet frame headers.
VI. PERFORMANCE ANALYSIS
In this Section, we present performance benchmarks
of our proposal of PQ-WireGuard and compare to origi-
nal WireGuard (version 0.0.20191206), IPsec (strongSwan
in version U5.6.2/K4.15.0-72-generic), OpenVPN (version
2.4.4, linked against OpenSSL 1.1.1), OpenVPN-NL (version
2.4.7, linked against mbed TLS 2.16.2), and PQCrypto-VPN
(OpenVPN 2.4.4, linked against OQS-OpenSSL 1.0.2 [69]).
OpenVPN-NL is a branch of OpenVPN, which is mandated for
critical infrastructure in the Netherlands by the Dutch govern-
ment, while PQCrypto-VPN is the aforementioned VPN soft-
ware from Microsoft [46] based on OpenVPN and the Open
Quantum Safe (OQS) framework [69]. Note that PQCrypto-
VPN has optional post-quantum authentication using the Pic-
nic signature scheme [70], [71]; in our experiments we do
not use this option, but benchmark PQCrypto-VPN only with
post-quantum conﬁdentiality. To achieve this post-quantum
conﬁdentiality, PQCrypto-VPN has two options, both provided
through OQS: either SIDH-503 as described in [72] or Frodo-
752 as described in [73]. For WireGuard we report resources
including the ﬁrst application-data packet, which also serves as
key conﬁrmation. In this packet we use zero-length application
data. In other words, we consider the handshake ﬁnished on
the responder (server) side only at the point when the server
is ready to send application data.
the PQ-WireGuard software is
based on the original WireGuard implementation. For Classic
McEliece we use the “avx2” software targeting recent 64-
bit Intel processors, which has been submitted to SUPER-
COP [74] by the Classic McEliece team. For the implementa-
tion of Dagger we start from the Saber reference implementa-
tion and adapt the ﬁles kem.c (to remove the CCA transform)
and SABER_params.h (to change the values of p and T ).
implementation of
Our
We carried out the experiments between two virtual ma-
chines managed by VMware’s “vSphere” in version 6.7 and
connected through a virtual Ethernet link (VMware “vSwitch”)
with a bandwidth limit of 10 Gbit/s. Both virtual machines are
running Linux kernel 4.15.0. The underlying physical machine
is powered by Intel Xeon Gold 6130 (Skylake) CPUs running
at 2.1 GHz.
316
RESOURCE REQUIREMENTS FOR VPN HANDSHAKE PROTOCOLS OVER
IPV4, NUMBERS IN PARENTHESES ARE STANDARD DEVIATION
TABLE III
VPN Software
WireGuard
PQ-WireGuard
(this paper)
IPsec
(RSA-2048)
IPsec
(Curve25519)
OpenVPN
(RSA-2048)
OpenVPN
(NIST P-256)
OpenVPN-NL
(RSA-2048)
OpenVPN-NL
(NIST P-256)
PQ-OpenVPN
(Frodo-752)
PQ-OpenVPN
(SIDHp503)
Packet
Number
3
(0)
3
(0)
6
(0)
4
(0)
21.005
(0.071)
19.005
(0.007)
19.005
(0.007)
19.006
(0.078)
63.001
(0.032)
23.003
(0.055)
Trafﬁc
(bytes)
398
(0)
2594
(0)
4123
(0)
2145
(0)
7535.507
(7.940)
5408.572
(7.997)
5685.585
(8.155)
5681.711
(8.979)
34348.114
(3.569)