196860
3.10%
81195517
2.65%
9698634
0.65%
832435
9.01% 223143562
402918
0.02%
0.01%
2826786
Timing Trojan
AES Fault Trojan
Cycles
Overhead
1396490
15.66%
23533786
0.00%
23249383
0.00%
660001
1.37%
660001
1.37%
30118
0.00%
28344001
0.47%
0.34%
306914
0.58% 110816657
0.00%
12959764
0.11%
1518872
0.40% 233888566
527593
32.99%
23.67%
4258054
Overhead
26.44%
10.17%
42.49%
15.95%
15.95%
9.50%
5.58%
36.08%
27.15%
25.17%
45.26%
4.98%
48.82%
49.33%
Table 3: Cycle overhead comparison of our Trojan case-studies using the Embench benchmark suite [27]
independent hardware path for reading microcode must be
implemented to ensure that the readout process has not been
subjected to tampering, e.g. by a malicious microcode update.
Towards Resilient Microcode Architectures Currently,
microcode updates have Turing-complete computation model
capabilities limited only by hardware storage size. Even
though microcode updates provide hardware designers with
powerful capabilities, we have demonstrated that this power
can be leveraged by adversaries as well. To build a resilient
architecture under the assumption of malicious microcode up-
dates, future interdisciplinary (security) research may focus
on whether microcode updates may be restricted in a way that
is powerful enough for hardware designers to patch erroneous
CPU behavior, but simultaneously limit the capabilities of
various microcode Trojan classes.
8.4 Comparison to Classical Malicious Hard-
ware and Malicious Software
Malicious microcode is a distinct class of attack vectors since
it possesses traits from both software and hardware worlds,
in particular with respect to ﬂexibility and stealth.
Malicious Hardware Unlike hardware Trojans, microcode
Trojans do not lack post-manufacturing versatility, since mi-
crocode Trojans can be inserted as easily as they can be re-
moved from a target system. As both hardware Trojans and
malicious microcode are custom-tailored to target a system
and its applications, the ﬂexibility of microcode enables scal-
ability, while providing similar stealthiness capabilities. With
respect to current defenses, detection methods for hardware
Trojans exist (cf.
[35]), however, such analyses typically
require specialized equipment to investigate hardware im-
plementation chip details. Here, the analysis of malicious
microcode has traits that are similar to the analysis and subse-
quent removal of malicious software (e.g., low-level root-kits),
however, as long as implementation details and the microcode
structure are not fully reverse-engineered or published by ven-
dors, malicious microcode provides similar stealth capabilities
as malicious hardware.
Malicious Software Malicious microcode is inﬂexible
when compared to traditional malicious software due to re-
quired low-level hardware access and the limited availability
of information from running applications. Malicious software
is typically seamlessly portable to new architectures and soft-
ware versions, while microcode requires custom-tailoring to
the CPU architecture and targeted application. As noted in
the previous paragraph, microcode Trojans generally possess
traits that are similar to sophisticated low-level malicious soft-
ware. However, considering the limited information available
for COTS CPUs and the current state of defenses, malicious
microcode enables signiﬁcantly improved stealth capabilities.
Modern Trusted Execution Environments (TEEs), such as
Intel SGX, are partially, if not completely, implemented with
microcode [8]. Since microcode provides the Trusted Comput-
ing Base (TCB) foundation, any malicious microcode update
invalidates the security properties of the TCB. Hence, adver-
saries with the ability to issue malicious microcode updates
could unleash devastating attacks on a spectrum of modern
computing systems.
Thus, microcode Trojans provide a balance between ﬂexi-
bility and stealthiness. Since no mechanisms to analyze mi-
crocode semantics are available yet for commercially avail-
able CPUs, microcode Trojans constitute a dangerous affair
that has been sparsely discussed in the scientiﬁc community.
280    30th USENIX Security Symposium
USENIX Association
9 Conclusion
In this paper we explored the threat posed by malicious mi-
crocode, with a focus on embedded CPUs. We showed that
by using stateful trigger conditions, the adversary can design
targeted Trojans that will rarely — if ever — be triggered
by mistake. Similarly, we showed that there is a large design
space for the Trojan payload, i.e., the actual malicious action
executed. Through three case studies, we demonstrated that
Trojans that lead to major security violations can be realized.
We also showed that there is a trade-off between stealthiness
and trigger complexity — complex triggers come with consid-
erable run time costs. This observation gives rise to detection
and mitigation strategies. Even though our experiments were
done on a RISC-V platform, they carry over in principle to
other CPUs, both for embedded and desktop applications.
Acknowledgements
We would like to thank Iryna Schwindt for her initial research
into commercial microcode, Felix Wegener for supporting us
with the timing side-channel attack and Jérémie Crenne for
his input regarding microcoded RISC-V architectures. We
would also like to thank our shepherd, Ramya Jayaram Masti,
for her great input, as well as the anonymous reviewers for
their helpful comments. This work was supported in part
by DFG Excellence Strategy grant 39078197 (EXC 2092,
CASA), ERC grant 695022 and NSF grant CNS-1563829.
References
[1] OpenSSL - Cryptography and SSL/TLS Toolkit. https://github.
com/openssl/openssl. Accessed: 2020-10-10.
[2] OpenSSL AES x86 implementation. https://github.com/openssl/
openssl/blob/master/crypto/aes/asm/aes-586.pl. Accessed:
2020-10-10.
[3] Simple C module for constant-time AES encryption and decryption.
https://github.com/bitcoin-core/ctaes. Accessed: 2020-10-
10.
[4] The GnuTLS Transport Layer Security Library. https://gitlab.
com/gnutls/gnutls/. Accessed: 2020-10-10.
[5] BERKLEY, U. The sodor processor collection (on github). [Online].
Available: https://github.com/ucb-bar/riscv-sodor.
[6] BHUNIA, S., HSIAO, M. S., BANGA, M., AND NARASIMHAN, S.
Hardware trojan attacks: Threat analysis and countermeasures. Proc.
IEEE 102, 8 (2014), 1229–1247.
[7] CHEN, D. D., AND AHN, G.-J. Security analysis of x86 processor
microcode, 2014.
[8] COSTAN, V., AND DEVADAS, S. Intel SGX explained. IACR Cryptol.
ePrint Arch. 2016 (2016), 86.
[9] DAEMEN, J., DOBRAUNIG, C., EICHLSEDER, M., GROSS, H.,
MENDEL, F., AND PRIMAS, R. Protecting against statistical inef-
fective fault attacks. IACR Trans. Cryptogr. Hardw. Embed. Syst. 2020,
3 (2020), 508–543.
[10] DAN GOODIN OCT 28, . . P. U. In a ﬁrst, researchers extract secret
key used to encrypt intel cpu code, Oct 2020.
[11] DC, D. S. B. W. Report of the Defense Science Board Task Force on
High Performance Microchip Supply, 2005.
[12] FYRBIAK, M., STRAUSS, S., KISON, C., WALLAT, S., ELSON, M.,
RUMMEL, N., AND PAAR, C. Hardware reverse engineering: Overview
and open challenges. In IEEE 2nd International Veriﬁcation and Secu-
rity Workshop, IVSW 2017, Thessaloniki, Greece, July 3-5, 2017 (2017),
IEEE, pp. 88–94.
[13] FYRBIAK, M., WALLAT, S., SWIERCZYNSKI, P., HOFFMANN, M.,
HOPPACH, S., WILHELM, M., WEIDLICH, T., TESSIER, R., AND
PAAR, C. HAL-The Missing Piece of the Puzzle for Hardware Reverse
Engineering, Trojan Detection and Insertion. IEEE Transactions on
Dependable and Secure Computing (2018).
[14] GOOGLE.
Veriﬁed boot -
[On-
line]. Available: https://sites.google.com/a/chromium.org/
dev/chromium-os/chromiumos-design-docs/verified-boot.
the chromium projects.
[15] HELLER, L. C., AND FARRELL, M. S. Millicode in an ibm zseries
processor. IBM Journal of Research and Development 48, 3.4 (2004),
425–434.
[16] HICKS, M., FINNICUM, M., KING, S. T., MARTIN, M. M. K., AND
SMITH, J. M. Overcoming an untrusted computing base: Detecting
and removing malicious hardware automatically. login Usenix Mag.
35, 6 (2010).
[17] INTEL CORPORATION. Intel issues updates to protect systems from se-
curity exploits. [Online]. Available: https://newsroom.intel.com/news-
releases/ intel-issues-updates-protect-systems-security-exploits/., 2017.
[18] JALLENNK. Signature veriﬁcation for embedded systems (on github).
[Online]. Available: https://github.com/jhallen/rsa-verify.
[19] KÄSPER, E., AND SCHWABE, P. Faster and timing-attack resistant
In Cryptographic Hardware and Embedded Systems
AES-GCM.
- CHES 2009, 11th International Workshop, Lausanne, Switzerland,
September 6-9, 2009, Proceedings (2009), C. Clavier and K. Gaj, Eds.,
vol. 5747 of Lecture Notes in Computer Science, Springer, pp. 1–17.
[20] KOCHER, P., GENKIN, D., GRUSS, D., HAAS, W., HAMBURG,
M., LIPP, M., MANGARD, S., PRESCHER, T., SCHWARZ, M., AND
YAROM, Y. Spectre attacks: Exploiting speculative execution. CoRR
abs/1801.01203 (2018).
[21] KOLLENDA, B., KOPPE, P., FYRBIAK, M., KISON, C., PAAR, C.,
AND HOLZ, T. An exploratory analysis of microcode as a building
block for system defenses. In Proceedings of the 2018 ACM SIGSAC
Conference on Computer and Communications Security, CCS 2018,
Toronto, ON, Canada, October 15-19, 2018 (2018), D. Lie, M. Mannan,
M. Backes, and X. Wang, Eds., ACM, pp. 1649–1666.
[22] KOPPE, P., KOLLENDA, B., FYRBIAK, M., KISON, C., GAWLIK,
R., PAAR, C., AND HOLZ, T. Reverse engineering x86 processor
microcode. In 26th USENIX Security Symposium, USENIX Security
2017, Vancouver, BC, Canada, August 16-18, 2017 (2017), E. Kirda
and T. Ristenpart, Eds., USENIX Association, pp. 1163–1180.
[23] MARK SMOTHERMAN.
programming.
MicroprogrammingABriefHistoryOf.pdf. Accessed: 2020-10-10.
[24] MATROSOV, A. Modern secure boot attacks: Bypassing hardware root
A Brief History
of Micro-
http://ed-thelen.org/comp-hist/
of trust from software. Blackhat Asia (2019).
[25] NARAYANASAMY, S., CARNEAL, B., AND CALDER, B. Patching
processor design errors. In 24th International Conference on Computer
Design (ICCD 2006), 1-4 October 2006, San Jose, CA, USA (2006),
IEEE, pp. 491–498.
[26] PAAR, C., AND PELZL, J. Understanding Cryptography - A Textbook
for Students and Practitioners. Springer, 2010.
[27] PATTERSON, D., BENNETT, J., DABBELT, P., GARLATI, C., MAD-
HUSUDAN, G. S., AND MUDGE, T. Embenchtm: An evolving bench-
mark suite for embedded iot computers from an academic-industrial
cooperative recruiting for the long overdue and deserved demise of
dhrystone. RISC-V Workshop 2019 (jun 2019).
USENIX Association
30th USENIX Security Symposium    281
[28] ROBERTSON, J., AND RILEY, M. The big hack: How china used a tiny
chip to inﬁltrate u.s. companies, Oct 2018.
[29] SARANGI, S. R., NARAYANASAMY, S., CARNEAL, B., TIWARI, A.,
CALDER, B., AND TORRELLAS, J. Patching processor design errors
with programmable hardware. IEEE Micro 27, 1 (2007), 12–25.
[30] SHIRRIFF, K. Reverse engineering the ARM1 processor’s microin-
structions . [Online]. Available: http://www.righto.com/2016/02/
reverse-engineering-arm1-processors.html, 2016.
[31] SNYDER, W. verilator. [Online]. Available: https://github.com/
verilator/verilator.
[32] STEIL, M. 17 mistakes microsoft made in the xbox security system.
In 22nd Chaos Communication Congress (2005).
[33] STOFFELEN, K. Efﬁcient cryptography on the RISC-V architecture.
In Progress in Cryptology - LATINCRYPT 2019 - 6th International
Conference on Cryptology and Information Security in Latin Amer-
ica, Santiago de Chile, Chile, October 2-4, 2019, Proceedings (2019),
P. Schwabe and N. Thériault, Eds., vol. 11774 of Lecture Notes in
Computer Science, Springer, pp. 323–340.
[34] SWIERCZYNSKI, P., FYRBIAK, M., KOPPE, P., AND PAAR, C. FPGA
trojans through detecting and weakening of cryptographic primitives.
IEEE Trans. on CAD of Integrated Circuits and Systems 34, 8 (2015),
1236–1249.
[35] TEHRANIPOOR, M., AND KOUSHANFAR, F. A survey of hardware
trojan taxonomy and detection. IEEE Design & Test of Computers 27,
1 (2010), 10–25.
[36] WARD, S. A., AND JR., R. H. H. Computation structures. MIT
electrical engineering and computer science series. MIT Press, 1990.
[37] WELCH, B. L. The generalization of student’s’ problem when several
different population variances are involved. Biometrika 34, 1/2 (1947),
28–35.
[38] WERNER, M., SCHILLING, R., UNTERLUGGAUER, T., AND MAN-
GARD, S. Protecting RISC-V processors against physical attacks. In
Design, Automation & Test in Europe Conference & Exhibition, DATE
2019, Florence, Italy, March 25-29, 2019 (2019), J. Teich and F. Fummi,
Eds., IEEE, pp. 1136–1141.
[39] WOLFE, A.
For Intel, it’s a case of FPU all over again. EE-
Times [Online]. Available: http://www.fool.com/EETimes/1997/
EETimes970516d.htm, 1997.
[40] WOLFF, F. G., PAPACHRISTOU, C. A., BHUNIA, S., AND
CHAKRABORTY, R. S. Towards trojan-free trusted ics: Problem
In Design, Automation and Test in
analysis and detection scheme.
Europe, DATE 2008, Munich, Germany, March 10-14, 2008 (2008),
D. Sciuto, Ed., ACM, pp. 1362–1365.
A Implementation of AES Timing Trojan in
Microcode
A.1 Trojanized XOR instruction
Listing 1 shows the Trojanized XOR instruction for the case-
study in Section 6. The Trojan adds an overhead of 28 mi-
croinstructions (excluding the additional payload NOPs) to
each XOR execution. To check if the operands were equal at
a speciﬁc byte, we check whether the result of a byte compar-
ison is zero. For this, we combine left and right shifts to mask
the targeted byte locations. The masked result is checked
against the RISC-V zero register that always contains zeros.
The comparison in, e.g., line 25, determines whether a jump
is taken. Note that microcode generally has limited function-
ality and basic comparisons need to be implemented with a
signiﬁcant overhead.
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37