title:Keep the Dirt: Tainted TreeKEM, Adaptively and Actively Secure Continuous
Group Key Agreement
author:Karen Klein and
Guillermo Pascual-Perez and
Michael Walter and
Chethan Kamath and
Margarita Capretto and
Miguel Cueto and
Ilia Markov and
Michelle Yeo and
Jo&quot;el Alwen and
Krzysztof Pietrzak
5
3
0
0
0
.
1
2
0
2
.
1
0
0
0
4
P
S
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
1
2
0
2
©
0
0
.
1
3
$
/
1
2
/
5
-
4
3
9
8
-
1
8
2
7
-
1
-
8
7
9
|
)
P
S
(
y
c
a
v
i
r
P
d
n
a
y
t
i
r
u
c
e
S
n
o
m
u
i
s
o
p
m
y
S
E
E
E
I
1
2
0
2
2021 IEEE Symposium on Security and Privacy (SP)
Keep the Dirt: Tainted TreeKEM, Adaptively and
Actively Secure Continuous Group Key Agreement
Karen Klein∗(cid:93)§, Guillermo Pascual-Perez∗(cid:93)(cid:91), Michael Walter∗(cid:93)§, Chethan Kamath, Margarita Capretto‡,
Miguel Cueto∗, Ilia Markov∗, Michelle Yeo∗(cid:91), Jo¨el Alwen‡, Krzysztof Pietrzak∗§
{kklein, gpascual, mwalter}@ist.ac.at
∗IST Austria, †Universidad Nacional del Rosario, ‡Wickr Inc.
Abstract—While messaging systems with strong security guar-
antees are widely used in practice, designing a protocol that scales
efﬁciently to large groups and enjoys similar security guarantees
remains largely open. The two existing proposals to date are ART
(Cohn-Gordon et al., CCS18) and TreeKEM (IETF, The Messag-
ing Layer Security Protocol, draft). TreeKEM is the currently
considered candidate by the IETF MLS working group, but
dynamic group operations (i.e. adding and removing users) can
cause efﬁciency issues. In this paper we formalize and analyze a
variant of TreeKEM which we term Tainted TreeKEM (TTKEM
for short). The basic idea underlying TTKEM was suggested by
Millican (MLS mailing list, February 2018). This version is more
efﬁcient than TreeKEM for some natural distributions of group
operations, we quantify this through simulations.
Our second contribution is two security proofs for TTKEM
which establish post compromise and forward secrecy even
against adaptive attackers. The security loss (to the underlying
PKE) in the Random Oracle Model is a polynomial factor, and
a quasipolynomial one in the Standard Model. Our proofs can
be adapted to TreeKEM as well. Before our work no security
proof for any TreeKEM-like protocol establishing tight security
against an adversary who can adaptively choose the sequence of
operations was known. We also are the ﬁrst to prove (or even
formalize) active security where the server can arbitrarily deviate
from the protocol speciﬁcation. Proving fully active security –
where also the users can arbitrarily deviate – remains open.
I. INTRODUCTION
Messaging systems allow for asynchronous communication,
where parties need not be online at the same time. Messages
are buffered by an untrusted delivery server, and then relayed
to the receiving party when it comes online. Secure messaging
protocols (like Open Whisper Systems’ Signal Protocol) pro-
vide end-to-end privacy and authenticity but, by having parties
perform regular key updates, also stronger security guaran-
tees like forward secrecy (FS) and post-compromise security
(PCS). Here, FS means that even if a party gets compromised,
previously delivered messages (usually all messages prior to
the last key update) remain private. In turn, PCS guarantees
that even if a party was compromised and its state leaks,
normal protocol execution after the compromise ensures that
eventually (usually after the next key update) future messages
will again be private and authenticated.
(cid:93)The ﬁrst three authors contributed equally to this work.
§Funded by the European Research Council (ERC) under the European
Union’s Horizon2020 research and innovation programme (682815-TOCNeT).
(cid:91)Funded by the European Union’s Horizon 2020 research and innovation
programme under the Marie Skłodowska-Curie Grant Agreement No.665385.
Most existing protocols were originally designed for the
two party case and do not scale beyond that. Thus, group
messaging protocols are usually built on top of a complete
network of two party channels. Unfortunately, this means that
message sizes (at least for the crucial key update operations)
grow linearly in the group size. In view of this, constructing
messaging schemes that provide strong security – in particular
FS and PCS – while efﬁciently1 scaling to larger groups is
an important but challenging open problem. Designing such
a protocol is the ongoing focus of the IETF working group
Message Layer Security (MLS) [1].
Instead of constructing a messaging scheme directly, a
modular approach seems more natural. This was done for the
two party case by Alwen et al. [2]. We consider in this paper
the concept of Continuous Group Key Agreement (CGKA), a
generalisation for groups of their Continuous Key Agreement
(CKA). Such a primitive can then be used to build a group
messaging protocol as in [2].
A. Continuous Group Key Agreement
Informally, in a CGKA protocol any party ID1 can initialise
a group G = (ID1, . . . , IDn) by sending a message to all
group members, from which each group member can compute
a shared group key I. ID1 must know a public key pki of each
invitee IDi, which in practice could be realized by having a
key-server where parties can deposit their keys. As this key-
management problem is largely orthogonal to the construction
of a CGKA, we will assume that such an infrastructure exists.
Apart from initialising a group, CGKA allows any group
member IDi to update its key. Informally, after an Update2
operation the state of IDi
is secure even if its previous
state completely leaked to an adversary. Moreover any group
member can add a new party, or remove an existing one.
These operations (Update, Add, Remove) require sending a
message to all members of the group. As we do not assume
that the parties are online at the same time, IDi cannot simply
send a message to IDj. Instead, all protocol messages are
exchanged via an untrusted delivery server. Although the
server can always prevent any communication taking place,
we require that the shared group key in the CGKA protocol
1The meaning of efﬁcient here will be determined by what can be
implemented and receive adoption by the general public, but we think of
it as having message sizes (poly)logarithmic in the size of the group.
2We use capital letters to refer to the operations (as opposed to verbs).
© 2021, Karen Klein. Under license to IEEE.
DOI 10.1109/SP40001.2021.00035
268
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:16:47 UTC from IEEE Xplore.  Restrictions apply. 
– and thus the messages encrypted in the messaging system
built upon it – remains private.
Another issue we must take into account is the fact that (at
least for the protocols discussed below) operations must be
performed in the same order by all parties in order to maintain
a consistent state. Even if the delivery server is honest, it can
happen that two parties try to execute an operation at the
same time. In this case, an ordering must be enforced, and
it is natural to let the delivery server do it. Whenever a party
wants to initiate an Update/Remove/Add operation, it sends
the message to the delivery server and waits for an answer. If
it gets a conﬁrmation, it updates its state and deletes the old
one. If it gets a reject, it deletes the new state and keeps the
old one. Note that when a party gets corrupted while waiting
for the conﬁrmation, both, the old and new state are leaked.
The formalization of CGKA is fairly recent, having ﬁrst
been introduced in [3]. In particular, the MLS working group
predates it, which only complicates any account of its develop-
ment. We try to give a brief overview below. Up to the writing
of this paper, the MLS protocol has seen 9 versions, through
which we can ﬁnd two different CGKA protocols: ART and
TreeKEM, both of which were incorporated as candidates in
the initial MLS protocol draft. ART was later removed in the
second version of the protocol, with TreeKEM (which has
seen several modiﬁcations throughout the different versions)
being the current candidate. Accordingly, we will refer to
the CGKA construction underlying version X of the MLS
draft as TreeKEMvX. We will also loosely use the term
TreeKEM when referring to aspects that are not unique to
speciﬁc versions or when there is no ambiguity.
1) Asynchronous Ratcheting Tree (ART): The ﬁrst proposal
of (a simpliﬁed variant of) a CGKA is the Asynchronous
Ratcheting Tree (ART) by Cohn-Gordon et al. [4]. This
protocol (as well as TreeKEM and the protocol formalized in
this paper) identiﬁes the group with a binary tree where edges
are directed and point from the leaves to the root.3 Each party
IDi in the group is assigned their own leaf, which is labelled
with an ElGamal secret key xi (known only to IDi) and a
corresponding public value gxi. The values of internal nodes
are deﬁned recursively: an internal node whose two parents
have secret values a and b has the secret value gab and public
value gι(gab), where ι is a map to the integers. The secret value
of the root is the group key. As illustrated in Figure 1, a party
can update its secret key x to a new key x(cid:48) by computing a
new path from x(cid:48) to the (new) root, and then send the public
values on this new path to everyone in the group so they can
switch to the new tree. Note that the number of values that
must be shared equals the depth of the tree, and thus (as the
tree is balanced) is only logarithmic in the size of the group.
The authors prove the ART protocol secure even against
adaptive adversaries. However, in this case, their reduction
loses a factor that is super-exponential in the group size. To
get meaningful security guarantees based on this reduction
requires a security parameter for the ElGamal scheme that is
3The non standard direction of the edges here captures that knowledge of
(the secret key of) the source node implies knowledge of the (secret key of
the) sink node. Note that nodes therefore have one child and two parents.
super-linear in the group size, resulting in large messages and
defeating the whole purpose of using a tree structure.
2) TreeKEM: The TreeKEM proposal [5], [6] is similar to
ART, as a group is still mapped to a balanced binary tree
where each node is assigned a public and secret value. In
TreeKEM those values are the public/secret key pair for an
arbitrary public-key encryption scheme. As in ART, each leaf
is assigned to a party, and only this party should know the
secret key of its leaf, while the secret key of the root is the
group key. Unlike in ART, TreeKEM does not require any
relation between the secret key of a node and the secret key