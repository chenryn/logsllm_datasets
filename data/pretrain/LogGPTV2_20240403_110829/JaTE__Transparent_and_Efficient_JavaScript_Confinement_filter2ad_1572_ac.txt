use the keyword eval. Our implementation transforms
. Obfuscated, or un-
eval(x) into eval(processEval(x))
usual instances of direct eval may not be recognized by this
approach. This is not a security threat since an unrecognized
direct eval will to be treated as an indirect eval.
4.4 Supporting DOM Access
7
Normally, when a principal creates a JavaScript object, it
receives a direct reference. However, this wouldn’t be safe for
DOM nodes, since they contain read-only built-in properties
that can get to the global object and the whole DOM tree
(e.g., aNode.ownerDocument.defaultView is window where
aNode is a DOM node).
For the above reason, we ensure that only the host has
direct access to DOM-nodes. Third-party code can access
DOM-node creation operations only through proxies. As a
result, all DOM nodes will have the host as the owner, and
be accessed using proxies by third-party. Since object own-
ership information is no longer enough to tell who created a
DOM-node, we record this information explicitly in a ﬁeld,
and call it DOM-ownership.
JavaScript code generated from HTML. Certain DOM-
operations, such as the setting of innerHTML property and
calling document.write, can generate new JavaScript code
from HTML. It is necessary to parse HTML, identify script
7Due to space constraints, we have shown a simpliﬁed transfor-
mation here. The full version, with additional security checks,
can be found in the extended version of this paper on our web
site [37].
code, and rewrite it so that it executes in the same compart-
ment as the principal invoking the HTML operation.
Malicious third parties can attempt to confuse our HTML
parser with malformed HTML so that our parser does not
recognize all the scripts that would be recognized and ex-
ecuted by the browser. We can rely on the solution used
in Blueprint [35] for this purpose, namely, parsing HTML,
ﬁltering the parse tree, and then converting the parse tree
directly into actual DOM nodes using safe DOM API calls.
5.
IMPLEMENTATION
We implemented JaTE in Firefox 33. The implementa-
tion consists of (a) a Firefox extension that implements the
JaTE network module, and (b) the JaTE script, written in
JavaScript. When miniﬁed, this script is about 30KB in
size. JaTE source has been released under GPL [36].
5.1 Use of Proxy
Use of shadow objects. To provide consistent semantics,
ES6 proxies enforce several invariants within each trap han-
dler. For example, a non-conﬁgurability invariant is enforced
in the get trap to ensure that the return value is consistent
for a frozen property. This prevents JaTE from creating a
proxy to such a property. To work around this, instead of
creating a proxy to an object O, JaTE creates a proxy to
a shadow object [39] S that contains a reference to O. The
traps on the proxy are set so as to access O. Since S does
not undergo any modiﬁcation, all invariants enforced by ES6
proxies will always be satisﬁed.
Fixing built-in functions. Proxy is still a new concept
and Firefox 33 does not yet completely conform to the ES6
speciﬁcation. For example, some String prototype functions
such as replace and match that take a regular expression
argument don’t work if a proxy is supplied instead. To work
around this problem, JaTE wraps such problematic func-
tions to replace proxies with direct versions before calling
the original function, and also creates proxies as needed for
return values.
5.2
JavaScript rewriting
JaTE’s rewriting requires static recognition of certain key-
words. We can perform this safely because all dynamic code
is analyzed and rewritten just before execution. By consid-
ering all formats of JavaScript comments, our rewriting is
resilient to lexer confusing attacks [5].
8
Code undergoes three transformations: direct eval rewrit-
ing, this rewriting, and global function declaration rewrit-
. These rewriting steps are eﬃcient because they only
ing
require lexical analysis, plus maintaining the current paren-
thesis nesting level, as opposed to more extensive transfor-
mations that require full parsing.
While rewriting, we introduce some identiﬁers, such as
processThis, processEvalSrc, etc., to the source code. In
the actual implementation, these identiﬁers are randomly
generated with a safe length to avoid the possibility of col-
liding with the names used by third-party code.
5.3 Supporting EcmaScript 6
Even though JaTE was developed to conﬁne ES 5 code, it
can support new ES 6 features. Some require minor changes:
for example, let statements need a new rewriting rule to
8To support strict mode, we perform simple global variable dec-
laration rewritings. More details can be found in our tech re-
port [37].
156
convert them to var declarations if they are in the global
scope. Other new constructs such as Arrow Functions, Prox-
ies, and WeakMaps do not require changes to JaTE and are
already supported.
6. EVALUATION
6.1 Performance Evaluation
6.1.1 Page Load Overhead
To calculate page load overhead, we developed a test ex-
tension for Firefox. The extension loads URLs sequentially
from an input list, measuring the time it takes for the browser
to emit the load event. The measurement is ﬁrst performed
10 times without any JaTE components, and then repeated
another 10 times with JaTE enabled. To avoid problems
with network and caching, the extension disables caching
and discards the load time for the ﬁrst request of each site.
Social Media Widgets. Since JaTE mediates all security-
relevant operations, it can support any policy. Although
we leave the design of a ﬂexible policy framework as future
work, we have developed a suitable policy for our evalua-
tion. The starting point for this policy is one-way isolation
[16], which allows untrusted code to read or modify any data,
but the modiﬁcations are visible only to untrusted code. We
then tighten this policy to enforce conﬁdentiality: all reads
of primitive types return a “null” value. Speciﬁcally, the
following rules are enforced:
• traversable objects: cross-compartment objects can be ob-
tained but not modiﬁed or called. (Built-in functions can
be called). This allows navigating the whole object graph.
• primitive zeroing: reading cross-compartment primitives
always returns a default value, e.g., empty string.
• global object shadowing: property writes on the global
object do not aﬀect other principals. The updated value
is only visible to the current principal.
We then relaxed this policy to support the functionality of
Facebook’s “Like”-button script. This script ﬁrst creates a
new global variable FB. Since this variable is not shared
with other principals, the default global object shadowing
policy is already permissive enough. The script then looks
for two DIVs, one with id fb-root and one with class name
fb-like, by looping through all DOM nodes using docu-
ment.getElementsByTagName(’*’). The default policy al-
lows calling the built-in DOM functions and looping through
the DOM nodes (traversable objects), but zeroes out their
properties (primitive zeroing). Our policy relaxation is to
avoid such zeroing and providing access to the two DIVs.
Then, the script writes into them. Finally, the script in-
serts a new script tag and a new iframe, both of which
are allowed by the default policy since they pose no security
threats with JaTE. In summary, the default policy needs
only a small change to allow write access to the two DIVs.
We used a process similar to that described above for Face-
book “Like”-button to create policies for Google+, Twitter,
etc. Much like the Facebook button, they also required write
access to a small set of DOM nodes.
Figure 5 shows the overhead for the conﬁnement of each
button. The interception overhead dominates because it in-
cludes rewriting these rather large scripts, while the policy
checks only need to approve the creation of a handful of
DOM nodes. We used a blank enclosing (i.e., ﬁrst-party)
page for each button, so the overhead ﬁgures represent the
Widget
Size
Intercept. Over. Policy Over.
Facebook
Google Plus
Twitter
StumbleUpon
LinkedIn
Average
177kB
222kB
361kB
15kB
187kB
12.06%
18.79%
11.77%
8.02%
9.24%
11.97%
0.44%
2.50%
2.99%
6%
1.17%
2.62%
Figure 5: Performance for Social Media Widgets
Interaction
Scroll Page
Next news item
Scroll Page
Start a video
Instant search
Website
Yahoo
Yahoo
YouTube
YouTube
Google
Google map Panning
Google map
Amazon
Amazon
Average
Zooming in/out
Item details
Search suggestions
89.6ms
32.6ms
73.6ms
50ms
50ms
88ms
202.3ms
15.1ms
20.3ms
Delay Overhead
6.9%
8.3%
7.4%
2.5%
1.3%
6.2%
15.0%
3.0%
5.3%
6.21%
Figure 6: User interaction overhead
worst-case. (A non-empty enclosing page would reduce the
overall overheads because ﬁrst-party scripts are not conﬁned
— and hence not slowed down — by JaTE.)
Advertisements.
In this experiment, we measured the
overhead for conﬁning advertisement scripts on Alexa’s Top
500 websites. Since interception overheads dominate, we did
not develop a speciﬁc policy for advertisements, but used an
“allow-all” policy. To identify which scripts on a page are re-
lated to advertisement, we relied on a popular advertisement
host list [1]. These scripts were conﬁned by JaTE, while the
remaining scripts were not conﬁned. The average page load
overhead was 19.5%.
6.1.2 User Interaction Overhead
We also measured the perceived overhead of JaTE on com-
mon user interactions, such as scrolling the page and mov-
ing to the next image in a gallery. These actions trigger
one or more callbacks, which might schedule asynchronous
callbacks of their own (e.g. making an HTTP request and
evaluating the data when it has arrived).
To estimate the interaction delay, we leveraged the single-
threaded nature of JavaScript, instrumenting all mechanisms
used to register callbacks (e.g., addEventListener and Xml-
HttpRequest) to wrap the callback in a special function
which stores its running time. Since only one callback is
executing at a time, the sum of the running times of all
callbacks is the total time spent executing code for the in-
teraction. Adding this number to the time spent loading
new network resources yields a reasonable estimate of the
perceived user delay for the action. Figure 6 shows the de-
lay in JavaScript execution and the total overhead perceived
by the user. Since the network delay is unaﬀected by con-
ﬁnement and usually dominates, the overhead is quite small.
6.1.3 Rewriting Overhead
We assessed the performance of the rewriter by rewrit-
ing 6 common scripts. Figure 7 shows the time required to
rewrite the scripts. Our rewriter is much faster than JSand’s
rewriter — JaTE’s 58ms Vs JSand’s 753ms for rewriting
JQuery in 753ms. This is because their rewriting is signif-
icantly more complex than ours. But even JaTE’s smaller
157
Script
Google AdSense
Google Analytics
Google Maps
JQuery 2.1
Twitter “Share” Button
Facebook “Like” Button
Total
Size
Time
22kB
40kB
50kB
83kB
96kB
37ms
25ms
47ms
58ms
60ms
160kB 101ms
451kB 328ms
Figure 7: Rewriting overhead
Test
Blank Page
JQuery
Google Maps
Google Maps (Pan)
Type
Page Load
Page Load
Page Load
Interaction
JaTE
JSand
208%
169%
219% 1230%
364%
31%
98%
6.2%
Figure 8: JaTE vs JSand Overhead Comparison
overhead may be deemed signiﬁcant, e.g., 100ms on Face-
book “Like” button, and hence in our future work, we plan
to implement it in C.
6.1.4 Comparison With Related Work
Comparison with JSand. We compared the performance
of JaTE with that of JSand, a JavaScript conﬁnement solu-
tion based on SES. To compare JaTE’s and JSand’s perfo-
mance, we replicated JSand’s benchmarks. Figure 8 shows
the overhead for opening a blank page, loading the jQuery
library, Google Maps and ﬁnally interacting with Google
Maps. Two reasons for the diﬀerence in performance are the
full parsing required by JSand during rewrite, which aﬀects
page load times, and its compatibility layer: their conﬁne-
ment setup makes all global variables local, which requires
expensive global object synchronization.
Comparison with Caja. We also compared JaTE against
Caja using a subset of the demos provided by the Caja au-
thors. The chosen subset consisted of programs that could
easily be benchmarked: a canvas clock, a markdown con-
verter and a Game of Life. We modiﬁed the code for each
demo to stop after a ﬁxed amount of computations (e.g.
200 generations in Game of Life) and measured the aver-
age time required to complete the computation with Caja,
JaTE and without any conﬁnement to assess the overhead.
For Caja, we tested both ES5/3 mode (compatible with
ES3, uses rewriting to isolate code and a virtual DOM im-
plementation) and ES5 mode (compatible with ES5, uses
SES for isolation and the same virtual DOM implementa-
tion as ES5/3). Figure 9 shows the results; ES5/3 mode is
slower than ES5 mode and JaTE because of its heavy run-
time checks; Caja ES5 mode is faster than ES3/5 mode due
to their use of SES (which realizes object capability without
runtime checks), but still substantially slower than JaTE
because of its virtual DOM implementation.
6.2 Transparency Evaluation
6.2.1
There are three corner cases where JaTE can change the
semantics of a script: (a) use of a cross-compartment caller,
(b) special forms of direct eval, and (c) modiﬁcation of
white-listed built-in functions.
JaTE Transparency
To assess the prevalence of these corner cases, we un-