e
c
t
i
o
n
instruction informatin
TB information
instruction
instrumenting
API parameters
and return vaules
TranslateBlock
instrumenting
code region
information
Dynamic
Information
 Extractor
indirect branches
information
Exploit Exception Detector
Code Injection Detector
Code Reuse Detector
Process 
Lifttime
U
s
e
r
S
p
a
c
e
K
e
r
n
e
l
S
p
a
c
e
Fig. 4. Xede prototype based on QEMU
during Process Creation
before process exec
before reaching OEP
dynamic Loaded Modules
injected by others
ntdll.dll
target.exe
Kernel
loaded
ws2_32.dll
kernel32.exe
user32.dll
third_party.dll
input_mothod.dll
Kernel
loaded
Process
preloaded
Dynamic
loaded
3rd party
injected
Ring3 API:
LoadLibraryEx,
etc.
SetWindowsHookEx,
etc.
Ring0 API:
ZwMapViewOfSetcion
NtMapViewOfSection
MmMapViewOfSection
MiMapViewOfPhysicalSection
MiMapViewOfImageSection
MiMapViewOfDataSection
map a physical section
map a PE module
map a data section
Fig. 5. Xede introspects Windows libraries
inserts a call back to the entry point of each interested API function (e.g.,
NtFlushInstructionCache) to catch its parameters and return values. The API
call data is used by the second module, exploit exception detector, to detect failed
exploits. To reduce the overhead of address validation, code injection detector
only validates the branch targets to ensure that they jump to legitimate code
regions. As such, it inserts a callback at the end of each basic block (this is
where branch instructions are located.) The last module, code reuse detector,
instruments indirect branch instructions (i.e., indirect calls, indirect jumps, and
returns).
210
M. Nie et al.
Figure 5 shows how our prototype for Windows intercepts the executable
loading events. A process may include executables loaded by the kernel (e.g.,
ntdll.dll and kernel32.exe), the dynamic loader (e.g., user 32.dll and
ws2 32.dll), the process itself, and libraries injected by third-party pro-
grams such as input method editors. These modules are loaded into the
process using diﬀerent API functions. For example, the kernel uses function
ZwMapViewOfSection to load an executable section, and a user process can load
dynamic libraries using a series of related functions such as LoadLibraryEx. A
third-party library can be injected into the process with SetWindowsHookEx.
However, these functions eventually converge at the MiMapViewofImageSection
function. As such, Xede hooks this function to intercept the executable module
loading events.
Xede leverages the guest kernel states to improve the preciseness of the detec-
tion. For example, it retrieves the valid stack area from the kernel to detect
stack pivoting. This technology is commonly known as virtual machine intro-
spection [20,24], which reconstructs the high-level semantics from the low-level
raw data such as the memory and disk images. Our semantic analyzer is devel-
oped to perform this task.
5 Evaluation
In this section, we evaluate eﬀectiveness of exploit detection with Xede and
the incurred overheads. In particular, we systematically analyze two real exploit
cases detected by Xede. We demonstrate the eﬀectiveness of Xede by detecting
real exploits collected from contagiodump [10], securityfocus [38], and exploit-
db [18]. We deploy our Xede prototype as a service to detect exploits on the
Internet and collect data from two systems. We integrate Xede into the mail
server of a university in China which aims to detect exploits in emails, and
deploy Xede on the Internet as a pubic service [42] that provides exploit detection
services for Internet users. In particular, similar to VirusTotal [43], the public
service is deployed as a web service so that any Internet users can scan their ﬁles
by submitting the ﬁles to the website. Currently, the service allows anonymous
sample submissions from the Internet for exploit detection.
5.1 Eﬀectiveness Evaluation
Detection with Exploit Samples. We use exploits downloaded from some
websites, e.g., contagiodump [10], securityfocus [38], and exploit-db [18], to eval-
uate the eﬀectiveness of exploit detection. Overall we collect 12501 exploits that
are included in doc/docx/rtf ﬁles, xls/xlsx ﬁles, ppt/pptx ﬁles, and pdf ﬁles.
Table 1 shows the results of exploit detection. Xede accurately detects all of these
exploits. Xede detects that more than 75 % exploits are generated by using the
code injection techniques. In particular, among these exploits, 51.47 % exploits
adopt the ROP techniques, which validates that most of exploits combine ROP
and code injection techniques, and around 19.85 % exploits leverage JMP-based
Xede: Practical Exploit Early Detection
211
Table 1. Exploit sample proportion with diﬀerent exploitation techniques.
Exploit techniques Sample proportion
code injection
75 %
ret-based gadgets
51.47 %
jmp-based gadgets 19.85 %
exploit exception
25 %
gadgets. 25 % exploits are captured because they raise abnormal execution excep-
tions. Furthermore, we do not observe any pure ROP attacks.
Real Deployment Detection. We collected 1,241 samples submitted by the
anonymous Internet users during three months, and collected 10,144 attachments
from our university email system for one month. Speciﬁcally, we selected 5,000
active users and randomly sampled their incoming emails with a rate of 3 %, and
analyzed 20 popular types of the samples attached in the emails. This results in
62,500 emails and 10,144 attachments. Note that, we collected the emails before
the email ﬁlters. Table 2 shows the breakdown of ﬁle types collected in real world
deployment. Xede detects 136 exploits, among which 4 and 132 exploits are from
the emails and the public service, respectively. Most of the exploits are pdf ﬁles
and the ﬁles generated by MS oﬃce suites. They account for 30.9 % and 58.1 %,
respectively. The rest are some swf ﬁles, html/htm ﬁles, and wps ﬁles. We conﬁrm
these exploits by manual analysis. Although we observe the attacks constructed
by these exploits, only 44.12 % of exploits successfully succeed, which means
that these exploits heavily rely on special system environments. Therefore, it is
necessary to capture and detect the exploits that do not succeed to compromise
the systems. Table 3 shows the success rate of diﬀerent exploits. Xede can detect
all these exploits no matter if they are successfully executed, which shows that
the exploit detection in Xede is independent of the target system conﬁgurations.
Note that, in the experiments, we do not diﬀerentiate legitimate and malicious
application “crashes” because we do not observe any legitimate “crashes”.
Many exploits detected by Xede cannot be captured by the existing anti-
virus software. We conﬁrm it by using some commercial virus software, i.e.,
Kaspersky 2015, Mcfee AntiVirus Plus, Avira Free Antivirus 2015, and Norton
2015. Overall, all these software cannot correctly detect the exploits. As shown
in Table 4, Kaspersky achieves the lowest false negative that is around 15.44 %.
It only detects 115 exploits out of 136 exploits, and the rest 21 exploits cannot
be detected by any anti-virus software. The results reveal that many exploits can
evade detection with signature matching. It demonstrates that a generic detec-
tion system is essential to detect exploits by identifying malicious operations of
software.
For the 11,249 samples that Xede did not raise an alert, we used the
previously-mentioned anti-virus products to cross-validate whether Xede intro-
duced any false negatives. None of those samples were identiﬁed by them as
212
M. Nie et al.
Table 2. Breakdown of sample ﬁle types collected in real world deployment.
The number of The number of
email samples
submitted samples number
Total
Sample
type
doc/docx/dot
pdf
swf
xls/xlsx
html/htm
rtf
ppt/pptx/pps
wps
txt/ini
jpg/png/gif
chm
5840
153
2
778
80
110
82
58
2611
411
19
Total Number 10144
154
241
49
112
102
120
144
20
115
180
4
1241
5994
394
51
890
182
230
226
78
2726
591
23
11385
Table 3. Success rate of diﬀerent exploits.
The number of
detected exploits exploit
Succeed Failed Success
Sample
type
doc/docx
pdf
swf
xls/xlsx
htm/html
rtf
ppt/pptx/pps
wps
58
42
8
11
6
6
4
1
43
4
0
8
3
1
1
0
exploit rate
15
38
8
3
3
5
3
1
74.14 %
9.52 %
0 %
72.73 %
50 %
16.67 %
25 %
0 %
Table 4. False negatives of commercial anti-virus software.
AV software Version
Date of DB update False negative
Kaspersky
15.0.2.361
24/05/2015
McAfee
Avira
Norton
18.0.204
24/05/2015
15.0.10.434 24/05/2015
22.2.0.31
24/05/2015
21
49
22
32
Xede: Practical Exploit Early Detection
213
malicious. Note that false negatives are still possible if both Xede and those
anti-virus products miss the attacks. Moreover, to roughly estimate how many
of these 11,249 samples may be detected by existing approaches [16,30,34] as
malicious (possible false positives), we recorded the suspicious patterns detected
(but eventually dismissed) by Xede in these samples. Particularly, we found that
879 xls samples cause Excel to generate more than 90KB dynamic code each,
and most doc samples each lead to over 4,500 mismatched call and ret instruc-
tions in Microsoft Word. All these cases may be mis-identiﬁed as malicious by
existing approaches. Xede did not raise alerts for these cases.
5.2 Case Study
We analyze two diﬀerent exploit samples that detected by our Xede. One sample
can successfully compromise a system by leveraging the vulnerability reported
by CVE-2012-0158, and the other sample leveraging the vulnerability reported
by CVE-2014-1761 fails to launch the attack due to wrong system conﬁgurations.
Case 1: CVE-2012-0158. We analyze an exploit that leverages the vulnera-
bility named with CVE-2012-0158 [14] that is a buﬀer overﬂow vulnerability in
the ListView and TreeView ActiveX controls in the MSCOMCTL.OCX library.
The vulnerability is leveraged against a Doc ﬁle that combines ROP and code
injection technique. In order to evade Data Execution Prevention (DEP), the
Doc ﬁle invokes the system call VirtualAlloc to allocate a block of executable
memory by constructing a ROP chain, and injects the shellcode into the space.
We run the exploit in Windows 7 as guest OS with Oﬃce 2003 SP1. In order
to systematically analyze the exploit techniques leveraged by the exploit, we do
not terminate the exploit after it is detected. Instead, we allow Xede to detect
all attacks in the exploit.
ROP Detection. Xede detects 12 anomalous return operations. We ﬁnd that
the returned address by executing the ﬁrst return instruction is 0X7c809a81
that is exactly the address of the system call VirtualAlloc. By analyz-
ing the stack information, we obtain the parameters of the system call as
follows. VirtualAlloc(0x001210b0, 0x0001000, 0x00001000, 0x0000040).
After the system call is executed, a block of executable memory is allocated.
We conﬁrm that the memory later will be injected with the shellcode. Moreover,
we detect 45,039 gadget-like sequences of instructions. But, we do not ﬁnd any
jmp-based gadgets.
Code Injection Detection. During execution of the exploit, Xede records
53 legal code regions and 47 regions that are executable sections generated by
the modules (e.g., DLL and EXE modules). As we discussed in Sect. 3, once
instructions are not executed in a legal region, Xede will treat it as an attack.
Overall, Xede detect 133,643 attacks. In particular, by analyzing the ﬁrst ﬁve
attacks, we ﬁnd that the instructions are within the memory block allocated
by the VirtualAlloc function. It means that these instructions are the code
214
M. Nie et al.
injected by the attackers. We conﬁrm that the code is shellcode by manual
analysis. We identify several instructions that should not be invoked by Doc
ﬁles, e.g., to release PE ﬁles or invoke CMD scripts.
Case 2: CVE-2014-1761. Now we analyze another Doc sample that leverages
the vulnerability of CVE-2014-1761 [15] that is executed in Windows XP OS with
Oﬃce 2003 SP3. When we open the sample ﬁle, the Word application crashes.
We do not ﬁnd anomalies by monitoring invoked APIs.
Exploit Exception Detection. Xede identiﬁes anomaly address access at
0x909092e4. We conﬁrm the sample is an exploit by running in Windows 7
OS with Oﬃce 2010 SP1. The possible reason why the exploit fails is that the
part of shellcode, i.e., 0x9090, is treated as the address and the shellcode cannot
be correctly located. Therefore, the exploit was not correctly executed due to
the mismatched software versions.
Summary. As we observed, most exploits combine diﬀerent exploitation tech-
niques, i.e., ROP and code injection, which similar to the exploit sample above.
ROP is used to evade the DEP mechanism, and the attacks ﬁnally are mounted
by executing injected shellcode. According to the two exploit sample above, we
show that how Xede detects exploits no matter if they can be successfully exe-
cuted.
5.3 Performance Evaluation
In this experiment we evaluate the overheads incurred by Xede and the overheads
during Xede bootstrapping. The experiment is performed in an Ubuntu 12.04
server with 3.07 GHz Intel Xeon X5675 CPU and 32 GB memory. We measure
the overheads incurred by Xede compared with pure QEMU. As shown in Fig. 6,
Xede consumes around 60 % of CPU cycles that consumed by QEMU during the
bootstrapping within the 60 seconds. The possible reason is that exploit exe-
cution incurs many virtual machine introspections during Xede bootstrapping.
Note that, Xede can eﬀectively detect most exploits during this period. After
the bootstrapping, Xede does not introduce extra signiﬁcant CPU consumption.
We compare the CPU utilization rate and memory overhead by measur-
ing the resource assumption in a Guest OS with 256 MB assigned memory (see
Figs. 7 and 8). We can observe that Xede does not incur many CPU cycles
after bootstrapping. The CPU utilization rate in QEMU with Xede and QEMU
without Xede are around 0.12 % and 0.08 %, respectively. Similarly, Xede does
not introduce signiﬁcant memory overheads. Therefore, Xede is very lightweight.
Furthermore, we measure the overheads with parallel exploit detection. Figure 9
illustrates the resource consumption with 80 Xede instances. Memory consump-