bound values may be sufﬁcient to detect opaque predicates
with long dependency chains (up to 230 in the study, including
contextual opaque predicates), since we do not always need to
recover all the information to conclude to infeasibility.
B. Call Stack Tampering
Call stack tampering consists in altering the standard
compilation scheme switching from function to function by
associating a call and a ret and making the ret return to
the call next instruction (return site). The ret is tampered
(a.k.a violated) if it does not return to the expected return site.
New taxonomy. In this work we reﬁne the deﬁnition of a stack
tampering in order to characterize it better.
• integrity: does ret return to the same address as pushed
by the call? It characterizes if the tampering takes place
or not. A ret is then either [genuine] (always returns
to the caller) or [violated].
• alignment: is the stack pointer (esp) identical at call
and ret? If so, the stack pointer is denoted [aligned],
otherwise [disaligned].
• multiplicity: in case of violation, is there only one possible
ret target? This case is noted [single], otherwise
[multiple].
Approach with BB-DSE. The goal is to check several properties
of the tampering using BB-DSE. We consider the following
predicates on a ret instruction:
• @[esp{call}] = @[esp{ret}]: Compare the content of the
value pushed at call @[esp{call}] with the one used
to return @[esp{ret}]. If it evaluates to VALID,
the
ret cannot be tampered [genuine]. If it evaluates
to UNSAT, a violation necessarily occurs [violated].
Otherwise, cannot characterize integrity.
• esp{call} = esp{ret}: Compare the logical ESP value at
the call and at ret. If it evaluates to VALID, the ret
necessarily returns at the same stack offset [aligned],
if it evaluates to UNSAT the ret is [disaligned].
Otherwise cannot characterize alignment.
• T (cid:2)= @[esp{ret}]: Check if the logical ret jump target
@[esp{ret}] can be different from the concrete value from
the trace (T ). If it evaluates to UNSAT the ret cannot
jump elsewhere and is ﬂagged [single]. Otherwise
cannot characterize multiplicity.
The above cases can be checked by BB-DSE (for checking
VALID with some predicate ψ, we just need to query BB-DSE
with predicate ¬ψ). Then, our detection algorithm works as
follow, taking advantage of BB-DSE and dynamic analysis:
• the dynamic analysis can tag a ret as: [violated],
[disaligned], [multiple];
• BB-DSE can tag a ret as: [genuine], [aligned],
[single] ([violated] and [disaligned] are
already handled by dynamic analysis).
As for opaque predicates, dynamic results can be trusted,
while BB-DSE results may be incorrect. Table II summarizes
all the possible situations.
TABLE II: Call stack tampering detection
RT Status
RT Genuine
RT Tampered
[violated]
integrity
alignment
multiplicity
VALID: [genuine]
RT: KO[disaligned]
- VALID: [aligned]
RT: KO[disaligned]
- VALID: [aligned]
RT: (2+)[multiple]
- UNSAT: [single]
This call stack tampering analysis uses BB-DSE, but with a
slightly non-standard setting. Indeed, in this case the bound
k will be different for every call/ret pair. The trace is
analysed in a forward manner, keeping a formal stack of call
instructions. Each call encountered is pushed to the formal
stack. Upon ret, the ﬁrst call on the formal stack is poped
and BB-DSE is performed, where k is the distance between the
call and the ret.
From an implementation point of view, we must take care
of possible corruptions of the formal stack, which may happen
for example in the following situations:
• Call to a non-traced function: because the function is not
traced, its ret is not visible. In our implementation these
calls are not pushed in the formal stack;
• Tail call [2] to non-traced function: tail calls consists in
calling functions through a jump instruction instead of
call to avoid stack tear-down. This is similar to the
previous case, except that care must be taken in order to
detect the tail call.
C. Other deobfuscation-related infeasibility issues
Opaque constant. Similar to opaque predicates, opaque
constants are expressions always evaluating to a single value.
Let us consider the expression e and a value v observed
at runtime for e. Then, the opaqueness of e reduces to the
infeasibility of e (cid:2)= v.
Dynamic jump closure. When dealing with dynamic jumps,
switch, etc., we might be interested in knowing if all the
639
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
targets have been found. Let us consider a dynamic jump
jump eax for which 3 values v1, v2, v3 have been observed
so far. Checking the jump closure can be done through checking
the infeasibility of eax (cid:2)= v1 ∧ eax (cid:2)= v2 ∧ eax (cid:2)= v3.
Virtual Machine & CFG ﬂattening. Both VM obfuscation
and CFG ﬂattening usually use a custom instruction pointer
aiming at preserving the ﬂow of the program after obfuscation.
In the case of CFG ﬂattening, after execution of a basic block
the virtual instruction pointer will be updated so that the
dispatcher will know where to jump next. As such, we can
check that all observed values for the virtual instruction pointer
have been found for each ﬂattened basic block. Thus, if for
each basic block we know the possible value for the virtual
instruction pointer and have proved it cannot take other values,
we can ultimately get rid of the dispatcher.
A glimpse of conditional self-modiﬁcation. Self-modiﬁcation
is a killer technique for blurring static analysis, since the
real code is only revealed at execution time. The method is
commonly found in malware and packers, either in simple
forms (unpack the whole payload at once) or more advanced
ones (unpack on-demand, shifting-decode schemes [34]). The
example in Figure 8 (page 10) taken from ASPack combines
an opaque predicate together with a self-modiﬁcation trick
turning the predicate to true in order to fool the reverser. Other
examples from existing malwares have been detailed in previous
studies (NetSky.aa [10]).
Dynamic analysis allows to overcome the self-modiﬁcation
as the new modiﬁed code will be executed as such. Yet, BB-
DSE can be used as well, to prove interesting facts about self-
modiﬁcation schemes. For example, given an instruction known
to perform a self-modiﬁcation, we can take advantage of BB-
DSE to know whether another kind of modiﬁcation by the same
instruction is possible or not (conditional self-modiﬁcation).
Let us consider an instruction mov [addr], eax identiﬁed
by dynamic analysis to generate some new code with value
eax = v. Checking whether the self modiﬁcation is conditional
reduces to the infeasibility of predicate eax (cid:2)= v.
As a matter of example, this technique has been used on the
example of Figure 8 to show that no other value than 1 can
be written. This self-modiﬁcation is thus unconditional.
VI. EVALUATION: CONTROLLED EXPERIMENTS
We present a set of controlled experiments with ground truth
values aiming at evaluating the precision of BB-DSE as well
as giving hints on its efﬁciency and comparing it with DSE.
A. Preliminary: Comparison with Standard DSE
As already stated, forward DSE is not ﬁt to infeasibility
detection, both in terms of scalability and error rate (false
positive, FP), since DSE essentially proves the infeasibility
of paths, not of reachability conditions. The goal of this
preliminary experiment is to illustrate this fact clearly, since
DSE is sometimes used for detecting opaque predicates [12].
We consider a trace of 115000 instructions without any opaque
predicate, and we check at each conditional jump if the branch
not taken is proved infeasible (if so, this is a FP). We take the
BB-DSE algorithm for opaque predicate from Section V, with
bound k = 20, which is a reasonable value (cf. Section VI-B).
We take the forward DSE of BINSEC/SE. Results are presented
in Table III. As expected, BB-DSE is much more efﬁcient than
DSE and yields far less FP and timeouts (TO).
These results were expected, as they are direct consequences
of the design choices behind DSE and BB-DSE. On the opposite,
BB-DSE is not suitable for feasibility questions.
TABLE III: Benchmark DSE versus BB-DSE
bound
k
-
20
Cond. branch
#TO
# FP
7749
2460
54
0
Total
time
17h43m
4m14s
forward DSE
BB-DSE
total number of queries: 10784 – TO: timeout (60 seconds)
#FP: #false positive – no false negative on this example
B. Opaque Predicates evaluation
We consider here the BB-DSE-based algorithm for opaque
predicate detection. We want to evaluate its precision, as well
as to get insights on the choice of the bound k.
Protocol and benchmark. We consider two sets of programs:
(1) all 100 coreutils without any obfuscation, as a genuine
reference data set, and (2) 5 simple programs taken from the
State-of-the-Art in DSE deobfuscation [10] and obfuscated with
O-LLVM [23]. Each of the 5 simple programs was obfuscated
20 times (with different random seeds) in order to balance
the numbers of obfuscated samples and genuine coreutils.
We have added new opaque predicates, listed in Table IV, in
O-LLVM (which is open-source) in order to maximize diversity.
TABLE IV: OP implemented in O-LLVM
Formulas
∀x, y ∈ Z
∀x, y ∈ Z
∀x ∈ Z
∀x ∈ Z
∀x ∈ Z
∀x ∈ Z
y < 10||2|(x × (x − 1))
7y2 − 1 (cid:3)= x2
2|(x + x2)
2|(cid:6) x2
4|(x2 + (x + 1)2)
2|(x × (x + 1))
(cid:7)
2
Comment
(initially present in O-LLVM)
(2nd bit of square always 0)
In total, 200 binary programs were used. For each of them a
dynamic execution trace was generated with a maximum length
of 20.000 instructions. By tracking where opaque predicates
were added in the obfuscated ﬁles, we are able a priori
to know if a given predicate is opaque or not, ensuring a
ground truth evaluation. Note that we consider all predicates
in coreutils to be genuine. The 200 samples sums up a total
of 1,091,986 instructions trace length and 11,725 conditional
jumps with 6,170 genuine and 5,556 opaque predicates. Finally,
experiments were carried using different values for the bound
k, and with a 5 second timeout per query.
Results. Among the 11,725 predicates, 987 were fully covered
by the trace and were excluded from these results, keeping
640
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
10,739 predicates (and 5,183 genuine predicates). Table V (and
Figure 14 in Appendix) shows the relation between the number
of predicates detected as opaque (OP) or genuine, false positive
(FP, here: classify a genuine predicate as opaque) and false
negatives (FN, here: classify an opaque predicate as genuine)
depending of the bound value k. The experiment shows a
tremendous peak of opaque detection with k = 12. Alongside,
the number of false negative steadily decreases as the number
of false positive grows. An optimum is reached for k = 16,
with no false negative, no timeout and a small number of false
positive (372), representing an error rate of 3.46%, while the
smallest error rate (2.83%) is achieved with k = 12. Results
are still very precise up to k = 30, and very acceptable for k
= 50.
TABLE V: Opaque predicate detection results
k
2
4
8
12
16
20
24
32
40
50
OP (5556)
miss
ok
(FN)
5556
4653
995
11
0
0
0
4
8
12
0
903
4561
5545
5556
5556
5556
5552
5548
5544
Genuine (5183)
miss
ok
(FP)
5182
5153
4987
4890
4811
4715
4658
4579
4523
4458
1
30
196
293
372
468
525
604
660
725
TO
Error rate
(FP+FN)/Tot
Time
(s)
avg/query
(s)
(%)
51.75
43.61
11.09
2.83
3.46
4.36
4.89
5.66
6.22
6.86
0
0
0
0
0
2
7
25
39
79
89
96
120
152
197
272
384
699
1145
2025
0.008
0.009
0.011
0.014
0.018
0.025
0.036
0.065
0.107
0.189
. 10,739 predicates, 5,556 opaque predicates, 5,183 genuine predicates
. ok: well-classiﬁed predicate – miss: badly-classiﬁed predicate
. Timeout (TO): 5 sec, counts UNKNOWN (classiﬁes the predicate as genuine)
A glimpse at efﬁciency. Taking the same detection algorithm
and queries, we want to evaluate predicate solving time. Each
predicate formula is solved using Z34 with a 5 seconds timeout.
Table V gives for each value of k the total time taken for
solving and the average time per query. For k = 16 the average
time per query is 0.018s which proves that the technique
scales. Previous works based on forward DSE aiming at solving
invariant opaque predicates [12] reports an average of 0.49s per
queries (min:0.09, max:0.79). As expected, BB-DSE provides
a very signiﬁcant speed up.
Conclusion. BB-DSE is very precise at detecting opaque
predicates, and while the choice of bound is important, the
technique still performs very well if the bound is not too far
from the optimal one (k between 10 and 30). Query solving
time is also very low.
C. Call Stack Tampering evaluation
We want to assess the precision BB-DSE for stack tampering
detection (Section VI-C). Especially, we would like the
technique to identify as genuine or single-target tampered