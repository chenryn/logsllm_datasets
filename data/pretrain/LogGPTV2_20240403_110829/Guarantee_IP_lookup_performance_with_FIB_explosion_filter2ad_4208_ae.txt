hours period starting from October 22nd 08:00 AM 2013.
For each FIB instance at a particular hour, the real traﬃc
that we experimented is the 10 minutes of real traﬃc that
we captured during that hour. Figure 9 shows the lookup
speed of these 4 algorithms with preﬁx-based synthetic traf-
ﬁc on the 12 FIBs downloaded from www.ripe.net. Figure 10
shows the lookup speed of these 4 algorithms with random
traﬃc on F IB2013. From these ﬁgures, we further observe
that for each of these 4 algorithms, its lookup speed on re-
al traﬃc is faster than that on preﬁx-based traﬃc, which is
further faster than that on random traﬃc. This is because
real traﬃc has the best IP locality, which results in the best
CPU caching behavior, and random traﬃc has the worst IP
locality, which results in the worst CPU caching behavior.
We now evaluate the FIB update performance of SAIL L
on the data plane. Figure 11 shows the variation of the num-
ber of memory accesses per update for 3 FIBs (rrc00, rrc01,
47800
700
600
500
400
300
200
100
0
)
s
p
p
M
(
d
e
e
p
s
p
u
k
o
o
L
 LC-trie  
 TreeBitmap  
 Lulea  
 SAIL_L
1
2
3
4
5
6
7
FIB
8
9
10
11
12
e
t
a
d
p
u
r
e
p
s
e
s
s
e
c
c
a
y
r
o
m
e
m
f
o
#
14
12
10
8
6
4
2
0
rrc00
average of rrc00
rrc01
average of rrc01
rrc03
average of rrc03
9
9
1
9
2
9
3
9
4
9
5
9
6
9
7
9
8
9
9
9
0
1
9
1
1
9
2
1
9
3
1
9
4
1
9
5
1
9
6
1
9
7
1
9
8
1
9
9
1
9
0
2
9
1
2
9
2
2
9
3
2
9
4
2
9
5
2
9
6
2
9
7
2
9
8
2
9
9
2
9
0
3
9
1
3
# of updates (*500)
Figure 8: Lookup speed with real traﬃc and FIBs.
Figure 11: # memory accesses per update.
800
700
600
500
400
300
200
100
0
)
s
p
p
M
(
d
e
e
p
s
p
u
k
o
o
L
 LC-trie  
 TreeBitmap  
 Lulea  
 SAIL_L
rrc00rrc01rrc03rrc04rrc05rrc06rrc07rrc10rrc11rrc12rrc13rrc14rrc15
FIB
500
400
300
200
100
0
)
s
p
p
M
(
d
e
e
p
s
p
u
k
o
o
L
Prefix-based traffic
Random Trace
2
3
4
5
8
7
6
# of FIBs
9
10
11
12
Figure 9: Lookup speed with preﬁx-based traﬃc on
12 FIBs.
and rrc03) during a period with 319∗500 updates. The aver-
age numbers of memory accesses per update for these three
FIBs are 1.854, 2.253 and 1.807, respectively. The observed
worst case is 7.88 memory accesses per update.
We now evaluate the lookup speed of SAIL M for virtual
routers. Figure 12 shows the lookup speed of SAIL M al-
gorithm as the number of FIBs grows, where x FIBs means
the ﬁrst x FIBs in the 12 FIBs rrc00, rrc01, rrc03,··· rrc07,
rrc10,··· , rrc15, for both preﬁx-based traﬃc and random
traﬃc. This ﬁgure shows that on average SAIL M achieves
132 Mpps for random traﬃc and 366 Mpps for preﬁx-based
traﬃc.
6.4 Evaluation on GPU
We evaluate SAIL L on GPU platform with CUDA 5.0.
We carry out these experiments on a DELL T620 server
with an Intel CPU (Xeon E5-2630, 2.30 GHz, 6 Cores) and
)
s
p
p
M
(
d
e
e
p
s
p
u
k
o
o
L
250.0
200.0
150.0
100.0
50.0
0.0
 LC-trie  
 TreeBitmap  
 Lulea  
 SAIL_L
2
4
6
8
10
12
14
Traffic file
16
18
20
22
24
Figure 10: Lookup speed with random traﬃc on
F IB2013.
Figure 12: Lookup speed of SAIL M for 12 FIBs us-
ing preﬁx-based and random traﬃc.
an NVIDIA GPU (Tesla C2075, 1147 MHz, 5376 MB de-
vice memory, 448 CUDA cores). These experiments use the
12 FIBs rrc00, rrc01, rrc03,··· rrc07, rrc10,··· , rrc15. We
measure the lookup speed and latency with a range of CU-
DA conﬁgurations: the number of streams (1, 2,··· , 24), the
number of blocks per stream (64, 96,··· , 512), and the num-
ber of threads per block (128, 256,··· , 1024). The lookup