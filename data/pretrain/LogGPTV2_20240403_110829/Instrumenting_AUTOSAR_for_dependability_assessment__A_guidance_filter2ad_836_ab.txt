open issues.
III. RELATED WORK
In order to implement fault-tolerance extensions or to
conduct fault injection experiments, several publications have
dealt with the instrumentation of AUTOSAR software systems.
In [16], Lu et al. propose a fault-tolerance extension for au-
tomotive modular embedded software, which is implemented
as an error monitor in an external customizable component.
The external monitor instruments and interfaces the monitored
system via software hooks provided by the AUTOSAR OS
on certain events (e.g. task start/stop, OS errors), based on
the user’s OS conﬁguration. The approach is capable of
monitoring the control- and data-ﬂow at the OS level, with
granularity restricted to task invocations. Apart from the low
granularity, the approach is limited by the instrumentation at
the OS level (therefore requiring OS access) and the use of
software hooks, which necessitates white-box access to those
parts of the OS that implement the hooks.
In [17], the authors suggest a wrapping-based approach that
partly addresses above limitations. The approach is based on
the same architecture, but targets the RTE as the instrumenta-
tion location, leveraging software hooks provided by the RTE.
The granularity of monitoring is substantially improved to
tracking interactions between SW-Cs and RTE at the interface
level, and is comparable to our approach. Furthermore, the
approach only requires RTE access and no longer OS access.
On the other hand, white-box restrictions still apply, while
implicitly necessitating the time-consuming recompilation of
code, when the conﬁguration of instrumentation changes.
Lanigan et al. [15] published a feasibility study of fault
tool
injection in AUTOSAR using CANoe, a commercial
that provides a simulation and evaluation environment for
automotive applications. As with the previous approaches,
the instrumentation method of choice is software hooks.
The authors restrict themselves to the basic software (BSW)
layer and do not
is mostly
auto-generated by the AUTOSAR conﬁguration tools”.
While the instrumentation at BSW service level provides a
better granularity than at the OS level, the same access and
white-box limitations as for [16] apply, due to the similarities
in instrumentation method and location. As the approach
targets a speciﬁc tool, the generic applicability is restricted.
the RTE, as “it
instrument
In summary, the review of related work shows that all
current approaches rely on hooks provided by either the
BSW, the OS or the RTE, requiring at least partial source
code access, and in turn, the recompilation of parts of the
system for different conﬁgurations. Currently, none of the
existing approaches addresses the different access levels of
white-box, grey-box or black-box, which are explicitly pro-
moted by AUTOSAR. Furthermore, the question of how to
IV. INSTRUMENTING AUTOSAR SOFTWARE
COMPONENTS
AUTOSAR’s high-level view of inter-component commu-
nication facilitates the identiﬁcation of candidate locations for
instrumentation. In order to analyze or intercept the commu-
nication on the component level, i.e. among the core building
blocks of AUTOSAR systems, communication end-points of
interest can be chosen from the set of ports that are used for
component interconnection. Unfortunately, this simplicity of
the communication model is not reﬂected in the tool-generated
source code structure, for which the actual instrumentation
has to be implemented. In the following we discuss how
AUTOSAR’s high-level communication model translates to
source code constructs, along with the resulting opportunities
for instrumentation.
A. Inter-Component Communication: Model vs Code
AUTOSAR models are stored as machine-readable speciﬁ-
cation in a XML-based data format called ARXML. A code
generator translates these models into an implementation code
skeleton. To illustrate the code generation process, we have
modeled the system presented in Figure 1, which, despite its
simplicity, resulted in almost 140 lines of ARXML code. From
this code, an extract of the component speciﬁcation of SW-C A
is shown in Listing 1, with the intent to provide an illustrative
example and give the reader a glimpse at the overall process.
A
SendPort 
/ r o o t P a c k a g e / S e n d P o r t / D a t a P r o t o t y p e 
/ r o o t P a c k a g e / SendPort 
Listing 1. Component prototype speciﬁcation (extract from the ARXML of
the model in Figure 1).
The speciﬁcation’s key elements are the component name
(line 2) and the provide port deﬁnition (lines 3-11), which
contains references to the data prototype (lines 6-7) and the
interface (lines 9-10). In [3], the AUTOSAR standard deﬁnes
various interface types, which are translated to more than 20
API types during the code generation, each of which is gen-
erated with a strict naming scheme to ensure interoperability.
In our example, the interface is of type SENDER-RECEIVER-
INTERFACE (lines 9-10), and the speciﬁcation results in the
generation of an Rte Write API. For this API, the naming
scheme is deﬁned as Rte_Write__, where 
denotes the port name and  the DataElementPrototype.
Line 4 of Listing 1 speciﬁes the port name (SendPort) while
the DataElementPrototype can be obtained by de-referencing
1
2
3
4
5
6
7
8
9
10
11
12
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:19:13 UTC from IEEE Xplore.  Restrictions apply. 
the interface reference in lines 9-10. Listing 2 shows the
interface speciﬁcation. The name of the DataElementPrototype
(DataPrototype) is located in line 4.
1 
2 SendPort 
3 
4 D a t a P r o t o t y p e 
5 
6
7 
8 
/ r o o t P a c k a g e / DataType 
Listing 2.
Figure 1).
Interface speciﬁcation (extract from the ARXML of the model in
By applying the port name and the DataElementPrototype
to the API naming scheme, we obtain the function call sig-
nature Rte_Write_SendPort_DataPrototype which
matches that of the actual generated code, as in Listing 3.
1 Std ReturnType Rte Write SendPort DataPrototype(DataType data);
Listing 3. Communication primitive generated from the ARXML speciﬁca-
tion in Listings 1 and 2.
This simple example illustrates some of the key concepts of
ARXML parsing. By de-referencing basic building blocks of a
component, the function call signature can be derived and lo-
cated in the implementation code base for instrumentation. The
AUTOSAR standard deﬁnes more than 20 interface types with
a multitude of options, signiﬁcantly adding to the complexity
of the translation process. An exhaustive implementation of all
interface types is essential, if maximum compatibility needs to
be achieved. Else, a limited subset that resembles the interfaces
that are used throughout the concrete model sufﬁces.
B. Opportunities for Instrumentation
The AUTOSAR standard document “Requirements on RTE
Software” [2] deﬁnes that the “RTE shall be generated in C
and that the RTE is required to support components written
using the C and C++ programming languages”. Thus, C and
C++ are the prevalent programming languages in AUTOSAR
systems, and we focus on these for instrumentation. Examining
the characteristics of the C/C++ programming languages, both
languages allow either source code, header ﬁle, or binary ob-
ject, as possible options for instrumentation, which correspond
to the software access levels white-box, grey-box and black-
box. SW-Cs and the RTE are instrumented in a technically
similar manner, hence we will refer to them collectively. A
clear distinction has to be drawn during the evaluation and
discussion of each approach though, as the instrumentation
of SW-Cs and RTE differs in semantics and requirements, as
discussed in Section VI. Thus each instrumentation location
(RTE and SW-C) has three instrumentation options at the code
access level, as:
Option 1: Instrumentation of Source Code (.c-ﬁles):
The source code of a component contains its implementa-
tion, which is located in a .c-ﬁle or .cpp-ﬁle. Source code
instrumentation demands white-box access to the instrumented
component and therefore has the highest requirements in terms
of accessibility.
In order to instrument a component’s implementation, i.e.,
its .c-ﬁle, all invocations of the interface function that is to be
instrumented, must be replaced with calls to a wrapper. This
is done by renaming all calls to Interface Name to a unique
and unused function name, e.g. Wrapper Interface Name. An
implementation of Wrapper Interface Name then has to be
provided in a separate .c-ﬁle that replicates all #include
statements of the original .c-ﬁle (e.g. for type deﬁnitions and
macros) and transparently invokes the original API function
Interface Name, by passing all parameters and the return
value.
Option 2: Instrumentation of Header File (.h-ﬁles): The
header ﬁle of a component contains its interface declaration,
which is located in a .h-ﬁle. Header ﬁle instrumentation
requires grey-box access to the instrumented component, as
the interface declaration must be accessible, but knowledge of
implementation speciﬁc details is not necessary.
The interface declaration of a component, i.e., its .h-ﬁle,
is instrumented by redeclaring the interface name of the
is to be instrumented (e.g. Interface Name)
function that
to a new, unique and unused function name (e.g. Origi-
nal Interface Name), effectively hiding the original interface
from the implementation. Similar to the instrumentation of
source code, an implementation of Interface Name has to be
provided in a separate .c-ﬁle, that #includes the original
header ﬁle, and invokes the original API function Origi-
nal Interface Name transparently.
Option 3: Instrumentation of Binary Object (.o-ﬁles):
The binary object of a component contains its compiled object
code, which is located in an .o-ﬁle. The instrumentation of
binary objects only requires black-box access to the instru-
mented component and therefore has the lowest requirements
in terms of accessibility.
Binary objects contain tables with information on imported
and exported symbols that are used by the linker during the
link phase of a program. Symbol tables can be accessed and
manipulated by tools such as objdump and objcopy, both
part of GNU Binutils [8]. By modifying the import/export
table of the binary object, the linker can be instructed to
link all calls of the original interface function (e.g. Inter-
face Name) to a wrapped version of the function (e.g. Wrap-
per Interface Name). An entry in the symbol table can be
redeﬁned, by calling objcopy with the --redefine-sym
parameter, passing the original and new symbol name as addi-
tional parameters. An implementation of the wrapped interface
function Wrapper Interface Name has to be provided in a
similar way as for above approaches in a separate .c-ﬁle.
C. Automating AUTOSAR Wrapper Generation
We have implemented aforementioned instrumentation
methods into a prototype AUTOSAR instrumentation frame-
work, which was developed in C#. The development of this
framework was motivated by our need for a ﬂexible, conﬁg-
urable and programmatic process to drive the instrumentation
of AUTOSAR systems for our own fault injection experiments.
At the same time, we also wanted to verify that we can
indeed achieve a usable, customizable and efﬁcient approach
to instrumentation.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:19:13 UTC from IEEE Xplore.  Restrictions apply. 
generated, to provide feedback and report errors.
By integrating a presentation of the various instrumentation
options on the model’s abstraction layer, while preserving the
ﬂexibility and customizability of working directly on the im-
plementation level, we were able to satisfy the requirements of
usability and customizability. The evaluation of the efﬁciency
of our approach is provided in the following section.
V. PROOF OF CONCEPT AND EXPERIMENTAL EVALUATION
This section provides a proof of concept for our suggested
instrumentation approach in a typical dependability assess-
ment scenario. We apply the source code and binary object
instrumentation options to the SW-C and RTE layers, in order
to conduct a series of fault injection (FI) experiments on a
simpliﬁed anti-lock braking system (ABS). The purpose and
intent of these experiments is not so much the evaluation
of a single, speciﬁc system, but rather to apply all of the
instrumentation methods in a common application scenario to
show their generic applicability. We determine the overhead of
each instrumentation technique, in order to establish a relative
comparison and raise the reader’s awareness for the different
evaluation criteria. This is a best effort approach, as, given
the multitude of platforms, systems and tool-chains in the
automotive domain, a generic analysis is infeasible.
For development,
implementation and evaluation of the
system, we used the commercial AUTOSAR tools ETAS
INTECRIO V3.2.0 Hotﬁx 5 [7] and OptXware Embedded
Architect (EA) V1.0.0.201103031241 [19], which enabled us
to cross-validate our results. Although we have conducted all
of our experiments on both tools, it is neither our intention nor
feasible to provide a comparison of tools, due to the diverse
functionality and application area of each tool. Instead, we
intend to provide a relative comparison of instrumentation
approaches per tool, and we aim at showing that our approach
is a generic one, therefore not limited to a certain tool or
implementation. For the automated instrumentation of the
system, we employ the instrumentation framework prototype
that we have developed according to the technical details given
in Section IV.
A. The Experimentation Setup
The system on which we implement the proof of concept
is a simpliﬁed anti-lock braking system, as shown in Figure
5. It
is simpliﬁed in the sense that only two wheels are
present in the model and that the internal behavior is not
used in a production system (i.e., a real car). The system is
nevertheless a complete and fully-ﬂedged AUTOSAR system,
aligning well with the intent of our experiments. A detailed
description of the function of the system and the operating
conditions is given in Section V-B. In our setup we aimed to
cover the instrumentation locations SW-C and RTE and the
wrapper implementation options .c-ﬁle, .h-ﬁle and .o-ﬁle. By
applying each of the 3 implementation options to each of the 2
instrumentation locations, we have 6 distinct experimentation
setups possible, of which we were able to evaluate 5. We were
unable to apply, and therefore experimentally validate, the RTE
Fig. 4. Automating instrumentation: Basic workﬂow of the model parsing
and instrumentation phases.
The overall workﬂow is divided into three phases: parsing,
conﬁguration and instrumentation, as depicted in Figure 4.
Model parsing is key in providing usability to the user, as it
enables a presentation of the system on the model abstraction
level. During model parsing (shown on the left side of Figure
4), the parser analyzes the AUTOSAR XML (ARXML) ﬁle(s)
for elements that are relevant to create this presentation and to
drive instrumentation. Beginning at the top-level composition
(TLC), which contains the component instances (CIs) of the
system,
the parser de-references the component prototype
speciﬁcation (CPS) of all CIs. Next, the parser extracts all
references to interface type(s) and data element type(s) that are
part of the component prototype. The information contained