样），该文件就是文本文件，其中包含文本内容。如果文件中的二进制值代
表机器语言代码或数值数据（使用相同的内部表示，假设，用于long或
double类型的值）或图片或音乐编码，该文件就是二进制文件，其中包含二
进制内容。
UNIX用同一种文件格式处理文本文件和二进制文件的内容。不奇怪，
鉴于C是作为开发UNIX的工具而创建的，C和UNIX在文本中都使用\n（换行
符）表示换行。UNIX目录中有一个统计文件大小的计数，程序可使用该计
数确定是否读到文件结尾。然而，其他系统在此之前已经有其他方法处理文
件，专门用于保存文本。也就是说，其他系统已经有一种与UNIX模型不同
的格式处理文本文件。例如，以前的OS X Macintosh文件用\r （回车符）表
示新的一行。早期的MS-DOS文件用\r\n组合表示新的一行，用嵌入的Ctrl+Z
字符表示文件结尾，即使实际文件用添加空字符的方法使其总大小是256的
倍数（在Windows中，Notepad仍然生成MS-DOS格式的文本文件，但是新的
编辑器可能使用类UNIX格式居多）。其他系统可能保持文本文件中的每一
行长度相同，如有必要，用空字符填充每一行，使其长度保持一致。或者，
系统可能在每行的开始标出每行的长度。
为了规范文本文件的处理，C 提供两种访问文件的途径：二进制模式和
文本模式。在二进制模式中，程序可以访问文件的每个字节。而在文本模式
中，程序所见的内容和文件的实际内容不同。程序以文本模式读取文件时，
把本地环境表示的行末尾或文件结尾映射为C模式。例如，C程序在旧式
Macintosh中以文本模式读取文件时，把文件中的\r转换成\n；以文本模式写
入文件时，把\n转换成\r。或者，C文本模式程序在MS-DOS平台读取文件
时，把\r\n转换成\n；写入文件时，把\n转换成\r\n。在其他环境中编写的文本
模式程序也会做类似的转换。
除了以文本模式读写文本文件，还能以二进制模式读写文本文件。如果
读写一个旧式MS-DOS文本文件，程序会看到文件中的\r 和\n 字符，不会发
生映射（图 13.1 演示了一些文本）。如果要编写旧式 Mac格式、MS-DOS格
949
式或UNIX/Linux格式的文件模式程序，应该使用二进制模式，这样程序才能
确定实际的文件内容并执行相应的动作。
图13.1 二进制模式和文本模式
虽然C提供了二进制模式和文本模式，但是这两种模式的实现可以相
同。前面提到过，因为UNIX使用一种文件格式，这两种模式对于UNIX实现
而言完全相同。Linux也是如此。
13.1.3 I/O的级别
除了选择文件的模式，大多数情况下，还可以选择I/O的两个级别（即
处理文件访问的两个级别）。底层I/O（low-level I/O）使用操作系统提供的
基本I/O服务。标准高级I/O（standard 
high-level 
I/O）使用C库的标准包和
stdio.h头文件定义。因为无法保证所有的操作系统都使用相同的底层I/O模
950
型，C标准只支持标准I/O包。有些实现会提供底层库，但是C标准建立了可
移植的I/O模型，我们主要讨论这些I/O。
13.1.4 标准文件
C程序会自动打开3个文件，它们被称为标准输入（standard input）、标
准输出（standard output）和标准错误输出（standard error output）。在默认
情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错
误输出是系统的普通输出设备，通常为显示屏。
通常，标准输入为程序提供输入，它是 getchar()和 scanf()使用的文件。
程序通常输出到标准输出，它是putchar()、puts()和printf()使用的文件。第8
章提到的重定向把其他文件视为标准输入或标准输出。标准错误输出提供了
一个逻辑上不同的地方来发送错误消息。例如，如果使用重定向把输出发送
给文件而不是屏幕，那么发送至标准错误输出的内容仍然会被发送到屏幕
上。这样很好，因为如果把错误消息发送至文件，就只能打开文件才能看
到。
951
13.2 标准I/O
与底层I/O相比，标准I/O包除了可移植以外还有两个好处。第一，标准
I/O有许多专门的函数简化了处理不同I/O的问题。例如，printf()把不同形式
的数据转换成与终端相适应的字符串输出。第二，输入和输出都是缓冲的。
也就是说，一次转移一大块信息而不是一字节信息（通常至少512字节）。
例如，当程序读取文件时，一块数据被拷贝到缓冲区（一块中介存储区
域）。这种缓冲极大地提高了数据传输速率。程序可以检查缓冲区中的字
节。缓冲在后台处理，所以让人有逐字符访问的错觉（如果使用底层I/O，
要自己完成大部分工作）。程序清单13.1演示了如何用标准I/O读取文件和
统计文件中的字符数。我们将在后面几节讨论程序清单 
13.1 
中的一些特
性。该程序使用命令行参数，如果你是Windows用户，在编译后必须在命令
提示窗口运行该程序；如果你是Macintosh用户，最简单的方法是使用
Terminal在命令行形式中编译并运行该程序。或者，如第11章所述，如果在
IDE中运行该程序，可以使用Xcode的Product菜单提供命令行参数。或者也
可以用puts()和fgets()函数替换命令行参数来获得文件名。
程序清单13.1 count.c程序
/* count.c -- 使用标准 I/O */
#include 
#include   // 提供 exit()的原型
int main(int argc, char *argv [])
{
int ch;      // 读取文件时，储存每个字符的地方
FILE *fp;   // “文件指针”
unsigned long count = 0;
952
if (argc != 2)
{
printf("Usage: %s filename\n", argv[0]);
exit(EXIT_FAILURE);
}
if ((fp = fopen(argv[1], "r")) == NULL)
{
printf("Can't open %s\n", argv[1]);
exit(EXIT_FAILURE);
}
while ((ch = getc(fp)) != EOF)
{
putc(ch, stdout); // 与 putchar(ch); 相同
count++;
}
fclose(fp);
printf("File %s has %lu characters\n", argv[1], count);
return 0;
}
953
13.2.1 检查命令行参数
首先，程序清单13.1中的程序检查argc的值，查看是否有命令行参数。
如果没有，程序将打印一条消息并退出程序。字符串 
argv[0]是该程序的名
称。显式使用 
argv[0]而不是程序名，错误消息的描述会随可执行文件名的
改变而自动改变。这一特性在像 UNIX 这种允许单个文件具有多个文件名的
环境中也很方便。但是，一些操作系统可能不识别argv[0]，所以这种用法并
非完全可移植。
exit()函数关闭所有打开的文件并结束程序。exit()的参数被传递给一些
操作系统，包括 UNIX、Linux、Windows和MS-DOS，以供其他程序使用。
通常的惯例是：正常结束的程序传递0，异常结束的程序传递非零值。不同
的退出值可用于区分程序失败的不同原因，这也是UNIX和DOS编程的通常
做法。但是，并不是所有的操作系统都能识别相同范围内的返回值。因此，
C 
标准规定了一个最小的限制范围。尤其是，标准要求0或宏
EXIT_SUCCESS用于表明成功结束程序，宏EXIT_FAILURE用于表明结束程
序失败。这些宏和exit()原型都位于stdlib.h头文件中。
根据ANSI 
C的规定，在最初调用的main()中使用return与调用exit()的效
果相同。因此，在main()，下面的语句：
return 0;
和下面这条语句的作用相同：
exit(0);
但是要注意，我们说的是“最初的调用”。如果main()在一个递归程序
中，exit()仍然会终止程序，但是return只会把控制权交给上一级递归，直至
最初的一级。然后return结束程序。return和exit()的另一个区别是，即使在其
他函数中（除main()以外）调用exit()也能结束整个程序。
13.2.2 fopen()函数
954
继续分析程序清单13.1，该程序使用fopen()函数打开文件。该函数声明
在stdio.h中。它的第1个参数是待打开文件的名称，更确切地说是一个包含
改文件名的字符串地址。第 2 个参数是一个字符串，指定待打开文件的模
式。表13.1列出了C库提供的一些模式。
表13.1 fopen()的模式字符串
像UNIX和Linux这样只有一种文件类型的系统，带b字母的模式和不带b
字母的模式相同。
新的C11新增了带x字母的写模式，与以前的写模式相比具有更多特
性。第一，如果以传统的一种写模式打开一个现有文件，fopen()会把该文件
的长度截为 0，这样就丢失了该文件的内容。但是使用带 x字母的写模式，
即使fopen()操作失败，原文件的内容也不会被删除。第二，如果环境允许，
x模式的独占特性使得其他程序或线程无法访问正在被打开的文件。
警告
如果使用任何一种"w"模式（不带x字母）打开一个现有文件，该文件的
内容会被删除，以便程序在一个空白文件中开始操作。然而，如果使用带x
字母的任何一种模式，将无法打开一个现有文件。
程序成功打开文件后，fopen()将返回文件指针（file pointer），其他I/O
955
函数可以使用这个指针指定该文件。文件指针（该例中是fp）的类型是指向
FILE的指针，FILE是一个定义在stdio.h中的派生类型。文件指针fp并不指向
实际的文件，它指向一个包含文件信息的数据对象，其中包含操作文件的
I/O函数所用的缓冲区信息。因为标准库中的I/O函数使用缓冲区，所以它们
不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及操作哪一个文
件。标准I/O函数根据这些信息在必要时决定再次填充或清空缓冲区。fp指
向的数据对象包含了这些信息（该数据对象是一个 C结构，将在第 14章中
介绍）。
13.2.3 getc()和putc()函数
getc()和putc()函数与getchar()和putchar()函数类似。所不同的是，要告诉
getc()和putc()函数使用哪一个文件。下面这条语句的意思是“从标准输入中
获取一个字符”：
ch = getchar();
然而，下面这条语句的意思是“从fp指定的文件中获取一个字符”：
ch = getc(fp);
与此类似，下面语句的意思是“把字符ch放入FILE指针fpout指定的文件
中”：
putc(ch, fpout);
在putc()函数的参数列表中，第1个参数是待写入的字符，第2个参数是
文件指针。
程序清单13.1把stdout作为putc()的第2个参数。stdout作为与标准输出相
关联的文件指针，定义在stdio.h中，所以putc(ch, stdout)与putchar(ch)的作用
相同。实际上，putchar()函数一般通过putc()来定义。与此类似，getchar()也
通过使用标准输入的getc()来定义。
956
为何该示例不用 putchar()而要用 putc()？原因之一是为了介绍 putc()函
数；原因之二是，把stdout替换成别的参数，很容易将这段程序改写成文件
输出。
13.2.4 文件结尾
从文件中读取数据的程序在读到文件结尾时要停止。如何告诉程序已经
读到文件结尾？如果 getc()函数在读取一个字符时发现是文件结尾，它将返
回一个特殊值EOF。所以C程序只有在读到超过文件末尾时才会发现文件的
结尾（一些其他语言用一个特殊的函数在读取之前测试文件结尾，C语言不
同）。
为了避免读到空文件，应该使用入口条件循环（不是do while循环）进
行文件输入。鉴于getc() 
（和其他C输入函数）的设计，程序应该在进入循
环体之前先尝试读取。如下面设计所示：
// 设计范例 #1
int ch;      // 用int类型的变量储存EOF
FILE * fp;
fp = fopen("wacky.txt", "r");
ch = getc(fp);     // 获取初始输入
while (ch != EOF)
{
putchar(ch); // 处理输入
ch = getc(fp);  // 获取下一个输入
}
957
以上代码可简化为：
// 设计范例 #2
int ch;
FILE * fp;
fp = fopen("wacky.txt", "r");
while (( ch = getc(fp)) != EOF)
{
putchar(ch); //处理输入
}
由于ch = getc(fp)是while测试条件的一部分，所以程序在进入循环体之
前就读取了文件。不要设计成下面这样：
// 糟糕的设计（存在两个问题）
int ch;
FILE * fp;
fp = fopen("wacky.txt", "r");
while (ch != EOF) // 首次使用ch时，它的值尚未确定
{
ch = getc(fp);  // 获取输入
putchar(ch);    // 处理输入
958
}
第1个问题是，ch首次与EOF比较时，其值尚未确定。第2个问题是，如
果getc()返回EOF，该循环会把EOF作为一个有效字符处理。这些问题都可以
解决。例如，把ch初始化为一个哑值（dummy value），再把一个if语句加入
到循环中。但是，何必多此一举，直接使用上面的设计范例即可。
其他输入函数也会用到这种处理方案，它们在读到文件结尾时也会返回
一个错误信号（EOF 或 NULL指针）。
13.2.5 fclose()函数
fclose(fp)函数关闭fp指定的文件，必要时刷新缓冲区。对于较正式的程
序，应该检查是否成功关闭文件。如果成功关闭，fclose()函数返回0，否则
返回EOF：
if (fclose(fp) != 0)
printf("Error in closing file %s\n", argv[1]);
如果磁盘已满、移动硬盘被移除或出现I/O错误，都会导致调用fclose()
函数失败。
13.2.6 指向标准文件的指针
stdio.h头文件把3个文件指针与3个标准文件相关联，C程序会自动打开
这3个标准文件。如表13.2所示：
表13.2 标准文件和相关联的文件指针
这些文件指针都是指向FILE的指针，所以它们可用作标准I/O函数的参
959
数，如fclose(fp)中的fp。接下来，我们用一个程序示例创建一个新文件，并
写入内容。
960
13.3 一个简单的文件压缩程序
下面的程序示例把一个文件中选定的数据拷贝到另一个文件中。该程序
同时打开了两个文件，以"r"模式打开一个，以"w"模式打开另一个。该程序
（程序清单13.2）以保留每3个字符中的第1个字符的方式压缩第1个文件的
内容。最后，把压缩后的文本存入第2个文件。第2个文件的名称是第1个文
件名加上.red后缀（此处的red代表reduced）。使用命令行参数，同时打开多
个文件，以及在原文件名后面加上后缀，都是相当有用的技巧。这种压缩方
式有限，但是也有它的用途（很容易把该程序改成用标准 I/O 而不是命令行
参数提供文件名）。
程序清单13.2 reducto.c程序