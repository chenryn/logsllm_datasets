regions containing the new code.
The test set was composed by a toy application that
we packed with 20 different packers we found on the
web. The signature we used for the detection was man-
ually generated and described the body of the main
function of our toy application, before packing. The
same signature was used for both ClamAV and Omni-
Unpack-enhanced ClamAV.
The results of the comparison are reported in Ta-
ble 3. ClamAV unpacked 5 of the packed instances
and only 3 of these matched the signature. We believe
that the unpacking algorithms contained a bug that pre-
vented the correct recovery of the original payload. On
the other hand, OmniUnpack successfully unpacked and
matched the original payload of 16 of the 20 packed
instances. The instances packed with Armadillo and
CExe were not correctly identiﬁed because both pack-
438438
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply. 
Packer
ClamAV
OmniUnpack
Unpacked
Detected
Detected
ACprotect
Armadillo
ASpack
ASprotect
CExe
ExeStealth
FSG
MEW
MoleBox
Morphine
nPack
nSPack
PKLite
RLPpack
teLock
Themida
UPX
WinUpackE
Xcompw
Xpackw
Rate
-
-
-
-
-
-
X
X
-
-
-
X
-
-
-
-
X
X
-
-
-
-
-
-
-
-
X
X
-
-
-
-
-
-
-
-
-
X
-
-
X
IMPL
X
X
IMPL
X
X
X
X
X
N/A
X
X
X
IMPL
X
X
X
X
X
25%
15%
80%
Table 3: Comparison of the detection rate of ClamAV
and OmniUnpack-enhanced ClamAV. IMPL denotes a
limitation of the current OmniUnpack implementation
and N/A denotes programs that did not execute cor-
rectly after packing, with or without OmniUnpack.
ers unpack the original payload, or an intermediate ex-
ecutable, on disk and then execute this executable. Our
prototype did not follow process creation. nPack gener-
ated an invalid executable which crashed with or with-
out OmniUnpack and was thus not detected. The in-
stance packed with teLock was not identiﬁed because
we ran the experiment within a Qemu virtual machine
and probably the packer used an instruction not cor-
rectly implemented in the virtual machine and the pro-
gram failed to unpack. We believe this problem would
not manifest itself with real hardware.
5.3. Overhead for Benign Programs
Another performance concern is related to the over-
head OmniUnpack introduces during the execution of
benign programs. Because OmniUnpack changes the
malware-detection approach from one-time to contin-
uous scanning, it is possible that benign programs incur
overheads when monitored by OmniUnpack. We com-
pared the execution times of benign programs with Om-
niUnpack disabled and enabled.
The test set was composed of several common
command-line applications (agrep, bison, bzip2,
cksum, compress, egrep, tar, uniq, wc, and
wget) and by their packed copy (packed with UPX).
The test set also included an application (tester), as
well as its packed copy, that performs different types
of memory accesses repeatedly (e.g., page read, page
write, and then page execution).
1.2
1.1
1
0.9
n
w
o
d
w
o
s
l
o
N
Relative slowdown
p
e
r
g
a
n
o
s
b
i
2
p
z
b
i
m
u
s
k
c
s
s
e
r
p
m
o
c
p
e
r
g
e
r
a
t
r
e
t
s
e
t
i
q
n
u
c
w
t
e
g
w
Program
No packing
UPX packing
Figure 5: Relative slowdown introduced by OmniUn-
pack.
The average overhead of OmniUnpack (computed
on three runs with different arguments) is reported in
Figure 5. For the ease of presentation we show only
the total overhead introduced by our system. The total
overhead is the sum of the user time, the system time,
the time to scan the program when ﬁrst loaded in mem-
ory, and the time requested to scan the written memory
pages at the end of an unpacking stage. For non-packed
applications the average overhead introduced by Omni-
Unpack was about 6%, while for packed applications it
was about 11%. In two cases, wc and wget, the ex-
ecution time with OmniUnpack was smaller then that
measured with OmniUnpack disabled. During the initial
setup of OmniUnpack all memory pages of the programs
are accessed to load them in memory. That avoided
most of the page faults due to non-present pages dur-
ing the execution and resulted in faster execution with
OmniUnpack.
6. Related Work
Packed malware has been a known problem for a
long time. The ﬁrst polymorphic virus that encrypted its
payload appeared in 1989 and tools to handle such mal-
ware followed quickly. Sz¨or presents a comprehensive
survey of unpacking techniques [18]. He covers most
algorithmic unpacking approaches, including heuristics
such as static decryptor detection and x-raying. Stepan
discussed specialized unpackers and their limitations, in
particular the fact these specialized routines need to be
updated “ ‘after the fact’ to accomodate new packer ver-
sions” [16].
Generic unpacking is the solution to the threat of
diverse packing techniques. Emulation and sandboxing
technologies, which integrated emulation into the mal-
ware detector, have been proposed for the detection of
polymorphic malware [7, 8]. This approach is open to
resource-consumption attacks and is prone to false neg-
atives, since the execution time in the sandbox has to be
restricted for performance reasons [9, 10]. In contrast,
OmniUnpack imposes little overhead and as a result can
monitor the whole program execution without affecting
the user experience. A faster approach to generic un-
439439
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply. 
packing uses dynamic code generation to speed up em-
ulation [16], but it is still too slow for interactive use.
A further improvement is introduced by PolyUnpack,
which executes the program inside a debugger until it
reaches an instruction sequence that does not appear in
the static disassembly of the program [15]. PolyUnpack
suffers from limitations inherent in static disassembly,
limitations that we avoid by using a purely dynamic
technique. Additionally, the use of a debugger leads to
signiﬁcant overhead that relegates this tool to the foren-
sic ﬁeld.
OmniUnpack avoids both the pitfalls of algorith-
mic unpacking (too speciﬁc) and of emulation- and
debugging-based unpacking (too time intensive). Our
unpacking technique builds on common hardware fea-
tures that allow us to monitor the status of memory
pages (e.g., written vs.
executed), making it fast,
generic, and widely applicable. Similar uses of hard-
ware features for security purposes have been proposed
by PaX PAGEEXEC [13] (to prevent some classes of
memory error exploits) and Ray et al. [14] (to integrate
virus scanning with the virtual memory manager). We
enhanced these mechanisms to create OmniUnpack as a
fast malware defense that is resilient to packing, self-
protection, and self-modiﬁcation.
7. Conclusion
The current approaches to packed malicious pro-
grams have several limitations that make analysis and
accurate detection both complex and time consuming.
Dynamic approaches based on debugging and emula-
tion are slow and can be easily detected. Static ap-
proaches are fast but require a priori knowledge of the
packing algorithm. In this paper we have presented a
new unpacking technique, called OmniUnpack, that ad-
dresses the aforementioned shortcomings. Our tech-
nique is implemented directly in the operating system
and constantly monitors the execution of a suspicious
program to detect the end of the unpacking process and
to notify a malware detector about the presence of new
unpacked code in memory. Our experimental evalua-
tion has shown that our technique is able to deal with
known and unknown unpacking algorithms and that it is
drastically faster than the dynamic approaches currently
available and at most an order of magnitude slower than
static approaches. Moreover, our technique introduces
little overhead, making OmniUnpack amenable to con-
tinuous monitoring of any program on production sys-
tems.
Future work includes the improvement of our pro-
totype implementation (e.g., support for monitoring
multiple processes) and the automatic generation of sig-
natures that satisfy the requirements imposed by our
system.
References
[1] Offensive
Computing.
offensivecomputing.net/.
http://www.
[2] F. Bellard. QEMU, a Fast and Portable Dynamic Trans-
lator. http://fabrice.bellard.free.fr/qemu/.
[3] M. Christodorescu, J. Kinder, S. Jha, S. Katzenbeisser,
and H. Veith. Malware normalization. Technical Re-
port 1539, University of Wisconsin, Madison, WI, USA,
Nov. 2005.
[4] T. Kojm. Clam AntiVirus. http://www.clamav.net.
[5] Y. Mashevsky. Watershed in malicious code evolu-
tion. Published online at http://www.viruslist.com/en/
analysis?pubid=167798878 (last accessed on May
15, 2007), July 29, 2005.
[6] McAfee Avert Labs. McAfee Avert Labs unveils
predictions for top ten security threats in 2007 as
hacking comes of age.
Press release published
online at http://www.mcafee.com/us/about/press/
corporate/2006/20061129 080000 f.html
(last ac-
cessed on May 15, 2007), Nov. 29, 2006.
[7] C. Nachenberg. Polymorphic virus detection module.
United States Patent # 5,696,822, Dec. 1997.
[8] C. Nachenberg. Polymorphic virus detection module.
United States Patent # 5,826,013, Oct. 1998.
[9] K. Natvig. Sandbox technology inside AV scanners.
In Proceedings of the 2001 Virus Bulletin Conference,
pages 475–487. Virus Bulletin, Sept. 2001.
[10] K. Natvig. Sandbox II: Internet. In Proceedings of the
2002 Virus Bulletin Conference, pages 1–18. Virus Bul-
letin, 2002.
[11] M. F. Oberhumer and L. Moln´ar. The Ultimate Packer
for eXecutables (UPX). Published online at http://upx.
sourceforge.net/. Last accessed on 14 Jan. 2007.
online
[12] Panda Research. Mal(ware)formation statistics. Pub-
at http://research.pandasoftware.
lished
com/blogs/research/archive/2007/05/28/
Mal 2800 ware 2900 formation-statistics.aspx
(last accessed on May 29, 2007).
[13] PaX Team.
executable pages.
pageexec.txt.
PaX PAGEEXEC: paging based non-
http://pax.grsecurity.net/docs/
[14] K. D. Ray, M. Kramer, P. England, and S. A. Field.
On-access Scan of Memory for Malware. United States
Patent # 2006/0200863 A1, Sept. 2006.
[15] P. Royal, M. Halpin, D. Dagon, R. Edmonds, and
W. Lee. PolyUnpack: Automating the Hidden-Code Ex-
traction of Unpack-Executing Malware. In Proceedings
of 2006 Annual Computer Security Applications Confer-
ence (ACSAC), pages 289–300, Washington, DC, USA,
2006. IEEE Computer Society.
[16] A. Stepan. Improving proactive detection of packed mal-
ware. Virus Bulletin, pages 11–13, Mar. 2006.
[17] J. Stewart. OllyBonE. http://www.joestewart.org/
ollybone/.
[18] P. Szor. The Art of Computer Virus Research and De-
fense, chapter 11, pages 425–494. Addison-Wesley,
2005.
440440
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply.