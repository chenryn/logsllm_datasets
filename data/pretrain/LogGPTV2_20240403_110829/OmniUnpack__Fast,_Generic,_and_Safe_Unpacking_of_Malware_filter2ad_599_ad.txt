### Regions Containing the New Code

The test set comprised a toy application that we packed using 20 different packers found on the web. The detection signature was manually generated and described the body of the main function of our toy application before packing. The same signature was used for both ClamAV and OmniUnpack-enhanced ClamAV.

### Comparison Results

The results of the comparison are summarized in Table 3. ClamAV successfully unpacked 5 of the 20 packed instances, but only 3 of these matched the signature. We believe that the unpacking algorithms contained a bug that prevented the correct recovery of the original payload. In contrast, OmniUnpack successfully unpacked and matched the original payload of 16 out of the 20 packed instances. The instances packed with Armadillo and CExe were not correctly identified because both packers unpack the original payload or an intermediate executable on disk and then execute this executable. Our prototype did not follow process creation. nPack generated an invalid executable, which crashed with or without OmniUnpack and was thus not detected. The instance packed with teLock was not identified because the experiment was run within a Qemu virtual machine, and the packer likely used an instruction not correctly implemented in the virtual machine, causing the program to fail to unpack. We believe this issue would not occur on real hardware.

| Packer          | ClamAV Unpacked | ClamAV Detected | OmniUnpack Detected |
|-----------------|-----------------|-----------------|---------------------|
| ACprotect       | -               | -               | IMPL                |
| Armadillo       | -               | -               | N/A                 |
| ASpack          | X               | -               | X                   |
| ASprotect       | X               | -               | X                   |
| CExe            | -               | -               | N/A                 |
| ExeStealth      | X               | -               | X                   |
| FSG             | X               | -               | X                   |
| MEW             | X               | -               | X                   |
| MoleBox         | -               | -               | IMPL                |
| Morphine        | X               | -               | X                   |
| nPack           | X               | -               | N/A                 |
| nSPack          | X               | -               | X                   |
| PKLite          | X               | -               | X                   |
| RLPpack         | X               | -               | X                   |
| teLock          | -               | -               | N/A                 |
| Themida         | X               | -               | X                   |
| UPX             | X               | -               | X                   |
| WinUpackE       | X               | -               | X                   |
| Xcompw          | X               | -               | X                   |
| Xpackw          | X               | -               | X                   |

**Table 3: Comparison of the detection rate of ClamAV and OmniUnpack-enhanced ClamAV. IMPL denotes a limitation of the current OmniUnpack implementation, and N/A denotes programs that did not execute correctly after packing, with or without OmniUnpack.**

### Overhead for Benign Programs

Another performance concern is the overhead introduced by OmniUnpack during the execution of benign programs. Since OmniUnpack changes the malware-detection approach from one-time to continuous scanning, it is possible that benign programs incur additional overhead when monitored by OmniUnpack. We compared the execution times of benign programs with OmniUnpack disabled and enabled.

The test set included several common command-line applications (agrep, bison, bzip2, cksum, compress, egrep, tar, uniq, wc, and wget) and their packed copies (packed with UPX). The test set also included a custom application (tester), as well as its packed copy, that performs various types of memory accesses repeatedly (e.g., page read, page write, and page execution).

![Relative slowdown introduced by OmniUnpack](figure5.png)

**Figure 5: Relative slowdown introduced by OmniUnpack.**

The average overhead of OmniUnpack, computed over three runs with different arguments, is shown in Figure 5. For clarity, we present only the total overhead introduced by our system. The total overhead includes user time, system time, the time to scan the program when first loaded into memory, and the time required to scan written memory pages at the end of an unpacking stage. For non-packed applications, the average overhead introduced by OmniUnpack was about 6%, while for packed applications, it was about 11%. In two cases, wc and wget, the execution time with OmniUnpack was actually shorter than that measured with OmniUnpack disabled. During the initial setup of OmniUnpack, all memory pages of the programs are accessed to load them into memory, which avoids most page faults due to non-present pages and results in faster execution with OmniUnpack.

### Related Work

Packed malware has been a known problem for a long time. The first polymorphic virus that encrypted its payload appeared in 1989, and tools to handle such malware followed quickly. Ször provides a comprehensive survey of unpacking techniques [18], covering most algorithmic unpacking approaches, including heuristics such as static decryptor detection and x-raying. Stepan discussed specialized unpackers and their limitations, particularly the need to update these specialized routines "after the fact" to accommodate new packer versions [16].

Generic unpacking is the solution to the threat of diverse packing techniques. Emulation and sandboxing technologies, which integrate emulation into the malware detector, have been proposed for the detection of polymorphic malware [7, 8]. However, this approach is vulnerable to resource-consumption attacks and is prone to false negatives, as the execution time in the sandbox must be restricted for performance reasons [9, 10]. In contrast, OmniUnpack imposes little overhead and can monitor the entire program execution without affecting the user experience. A faster approach to generic unpacking uses dynamic code generation to speed up emulation [16], but it is still too slow for interactive use.

PolyUnpack, another improvement, executes the program inside a debugger until it reaches an instruction sequence that does not appear in the static disassembly of the program [15]. PolyUnpack suffers from limitations inherent in static disassembly, which we avoid by using a purely dynamic technique. Additionally, the use of a debugger leads to significant overhead, limiting its use to forensic analysis.

OmniUnpack avoids the pitfalls of algorithmic unpacking (too specific) and emulation- and debugging-based unpacking (too time-intensive). Our unpacking technique builds on common hardware features that allow us to monitor the status of memory pages (e.g., written vs. executed), making it fast, generic, and widely applicable. Similar uses of hardware features for security purposes have been proposed by PaX PAGEEXEC [13] (to prevent some classes of memory error exploits) and Ray et al. [14] (to integrate virus scanning with the virtual memory manager). We enhanced these mechanisms to create OmniUnpack, a fast malware defense that is resilient to packing, self-protection, and self-modification.

### Conclusion

Current approaches to packed malicious programs have several limitations that make analysis and accurate detection both complex and time-consuming. Dynamic approaches based on debugging and emulation are slow and can be easily detected. Static approaches are fast but require a priori knowledge of the packing algorithm. In this paper, we presented a new unpacking technique called OmniUnpack, which addresses these shortcomings. Our technique is implemented directly in the operating system and constantly monitors the execution of a suspicious program to detect the end of the unpacking process and notify a malware detector about the presence of new unpacked code in memory. Our experimental evaluation has shown that our technique can handle known and unknown unpacking algorithms and is drastically faster than current dynamic approaches and at most an order of magnitude slower than static approaches. Moreover, our technique introduces little overhead, making OmniUnpack suitable for continuous monitoring of any program on production systems.

Future work includes improving our prototype implementation (e.g., support for monitoring multiple processes) and the automatic generation of signatures that meet the requirements imposed by our system.

### References

[1] Offensive Computing. http://www.offensivecomputing.net/.

[2] F. Bellard. QEMU, a Fast and Portable Dynamic Translator. http://fabrice.bellard.free.fr/qemu/.

[3] M. Christodorescu, J. Kinder, S. Jha, S. Katzenbeisser, and H. Veith. Malware normalization. Technical Report 1539, University of Wisconsin, Madison, WI, USA, Nov. 2005.

[4] T. Kojm. Clam AntiVirus. http://www.clamav.net.

[5] Y. Mashevsky. Watershed in malicious code evolution. Published online at http://www.viruslist.com/en/analysis?pubid=167798878 (last accessed on May 15, 2007), July 29, 2005.

[6] McAfee Avert Labs. McAfee Avert Labs unveils predictions for top ten security threats in 2007 as hacking comes of age. Press release published online at http://www.mcafee.com/us/about/press/corporate/2006/20061129_080000_f.html (last accessed on May 15, 2007), Nov. 29, 2006.

[7] C. Nachenberg. Polymorphic virus detection module. United States Patent # 5,696,822, Dec. 1997.

[8] C. Nachenberg. Polymorphic virus detection module. United States Patent # 5,826,013, Oct. 1998.

[9] K. Natvig. Sandbox technology inside AV scanners. In Proceedings of the 2001 Virus Bulletin Conference, pages 475–487. Virus Bulletin, Sept. 2001.

[10] K. Natvig. Sandbox II: Internet. In Proceedings of the 2002 Virus Bulletin Conference, pages 1–18. Virus Bulletin, 2002.

[11] M. F. Oberhumer and L. Molnár. The Ultimate Packer for eXecutables (UPX). Published online at http://upx.sourceforge.net/. Last accessed on 14 Jan. 2007.

[12] Panda Research. Mal(ware)formation statistics. Published online at http://research.pandasoftware.com/blogs/research/archive/2007/05/28/Mal-formation-statistics.aspx (last accessed on May 29, 2007).

[13] PaX Team. PaX PAGEEXEC: paging based non-executable pages. http://pax.grsecurity.net/docs/pageexec.txt.

[14] K. D. Ray, M. Kramer, P. England, and S. A. Field. On-access Scan of Memory for Malware. United States Patent # 2006/0200863 A1, Sept. 2006.

[15] P. Royal, M. Halpin, D. Dagon, R. Edmonds, and W. Lee. PolyUnpack: Automating the Hidden-Code Extraction of Unpack-Executing Malware. In Proceedings of 2006 Annual Computer Security Applications Conference (ACSAC), pages 289–300, Washington, DC, USA, 2006. IEEE Computer Society.

[16] A. Stepan. Improving proactive detection of packed malware. Virus Bulletin, pages 11–13, Mar. 2006.

[17] J. Stewart. OllyBonE. http://www.joestewart.org/ollybone/.

[18] P. Ször. The Art of Computer Virus Research and Defense, chapter 11, pages 425–494. Addison-Wesley, 2005.