structured objects. arXiv preprint arXiv:1904.12787, 2019.
[76] Zhibo Liu and Shuai Wang. How far we have come: Testing decom-
pilation correctness of c decompilers. In ISSTA, 2020.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
1115
[102] Yulei Sui and Jingling Xue. SVF: interprocedural static value-ﬂow
analysis in LLVM. In Proceedings of the 25th International Conference
on Compiler Construction, pages 265–266. ACM, 2016.
[103] Yulei Sui, Ding Ye, and Jingling Xue. Detecting memory leaks
statically with full-sparse value-ﬂow analysis. IEEE Transactions on
Software Engineering, 40(2):107–122, 2014.
[104] Chengnian Sun, Vu Le, and Zhendong Su. Finding compiler bugs via
live code mutation. In OOPSLA, 2016.
[105] sunlv. Fail to build klee maze example. https://github.com/lifting-bits/
mcsema/issues/569, 2019.
[106] testhound. Mctoll crashes when running raising arm binary. https:
//github.com/microsoft/llvm-mctoll/issues/67, 2020.
[107] Pei Wang, Qinkun Bao, Li Wang, Shuai Wang, Zhaofeng Chen, Tao
Wei, and Dinghao Wu. Software protection on the go: A large-scale
empirical study on mobile app obfuscation. In ICSE, 2018.
[108] Ruoyu Wang, Yan Shoshitaishvili, Antonio Bianchi, Aravind Machiry,
John Grosen, Paul Grosen, Christopher Kruegel, and Giovanni Vigna.
Ramblr: Making reassembly great again. In NDSS, 2017.
[109] Shen Wang, Zhengzhang Chen, Xiao Yu, Ding Li, Jingchao Ni, Lu-
An Tang, Jiaping Gui, Zhichun Li, Haifeng Chen, and Philip S
Yu. Heterogeneous graph matching networks for unknown malware
detection. In Proceedings of the 28th International Joint Conference
on Artiﬁcial Intelligence, pages 3762–3770. AAAI Press, 2019.
[110] Shuai Wang, Pei Wang, and Dinghao Wu. Reassembleable disassem-
bling. In USENIX Sec., 2015.
[111] Shuai Wang, Pei Wang, and Dinghao Wu. Uroboros: Instrumenting
stripped binaries with static reassembling. In 2016 IEEE 23rd Interna-
tional Conference on Software Analysis, Evolution, and Reengineering
(SANER), volume 1, pages 236–247. IEEE, 2016.
[112] Wenhan Wang, Ge Li, Bo Ma, Xin Xia, and Zhi Jin. Detecting code
clones with graph neural networkand ﬂow-augmented abstract syntax
tree. arXiv preprint arXiv:2002.08653, 2020.
[113] Wenwen Wang, Stephen McCamant, Antonia Zhai, and Pen-Chung
Yew. Enhancing cross-isa dbt through automatically learned translation
rules. ACM SIGPLAN Notices, 53(2):84–97, 2018.
[114] Brian Wickman, Hong Hu,
JungWon
Lim Sanidhya Kashyap, and Taesoo Kim. Preventing use-after-free
attacks with fast forward allocation. 2021.
Insu Yun Daehee Jang,
[115] David Williams-King, Hidenori Kobayashi, Kent Williams-King, Gra-
ham Patterson, Frank Spano, Yu Jian Wu, Junfeng Yang, and
Vasileios P Kemerlis. Egalito: Layout-agnostic binary recompilation.
In Proceedings of the Twenty-Fifth International Conference on Archi-
tectural Support for Programming Languages and Operating Systems,
pages 133–147, 2020.
[116] Xiaojun Xu, Chang Liu, Qian Feng, Heng Yin, Le Song, and Dawn
Song. Neural network-based graph embedding for cross-platform
In Proceedings of the 2017 ACM
binary code similarity detection.
SIGSAC Conference on Computer and Communications Security, pages
363–376, 2017.
[117] Khaled Yakdan, Sebastian Eschweiler, Elmar Gerhards-Padilla, and
Matthew Smith.
No more gotos: Decompilation using pattern-
independent control-ﬂow structuring and semantic-preserving transfor-
mations. In NDSS, 2015.
[118] Zeping Yu, Rui Cao, Qiyi Tang, Sen Nie, Junzhou Huang, and Shi
Wu. Order matters: Semantic-aware neural networks for binary code
the AAAI Conference on
similarity detection.
Artiﬁcial Intelligence, volume 34, pages 1145–1152, 2020.
In Proceedings of
[119] Zeping Yu, Wenxin Zheng, Jiaqi Wang, Qiyi Tang, Sen Nie, and Shi
Wu. CodeCMR: Cross-modal retrieval for function-level binary source
code matching. Advances in Neural Information Processing Systems,
33, 2020.
[120] Hang Zhang and Zhiyun Qian. Precise and accurate patch presence
test for binaries. In USENIX Security, 2018.
[121] Zheng Zhang, Hang Zhang, Zhiyun Qian, and Billy Lau. An inves-
In Usenix Security,
tigation of the android kernel patch ecosystem.
2021.
[122] Zhuo Zhang, Wei You, Guanhong Tao, Yousra Aafer, Xuwei Liu, and
Xiangyu Zhang. STOCHFUZZ: Sound and cost-effective fuzzing of
stripped binaries by incremental and stochastic rewriting. 2021.
[123] Jianzhou Zhao, Santosh Nagarakatte, Milo M.K. Martin, and Steve
Zdancewic. Formal veriﬁcation of SSA-based optimizations for LLVM.
pages 175–186, 2013.
[124] Lei Zhao, Yuncong Zhu, Jiang Ming, Yichen Zhang, Haotian Zhang,
and Heng Yin. PatchScope: Memory object centric patch difﬁng. In
Proceedings of the 2020 ACM SIGSAC Conference on Computer and
Communications Security, pages 149–165, 2020.
[125] Jie Zhou, Ganqu Cui, Zhengyan Zhang, Cheng Yang, Zhiyuan Liu,
Lifeng Wang, Changcheng Li, and Maosong Sun. Graph neural
arXiv preprint
networks: A review of methods and applications.
arXiv:1812.08434, 2018.
A. Binary Code Sanitization
APPENDIX
Address sanitizer (ASan) [98] inserts sanitizer checks to
detect software defects such as buffer overﬂow [101]. It
instruments each memory access to validate memory addresses
with sanitizer checks. ASan also uses a runtime library to hook
memory allocation/free and to create poisoned “redzones” for
each allocated memory region to detect memory errors.
Taxonomy of Memory Protection Capability. The LLVM
framework has provided ASan as a standard utility. We en-
able ASan by compiling lifted IR using clang and with
the -fsanitize=address option. In addition, we reuse
RetroWrite [43], a binary-only rewriting framework to insert
sanitizer checks into binary code. RetroWrite leverages Cap-
stone [85] for disassembling. It facilitates relocation symbol
recovery and ASan check insertion. We compare RetroWrite
with McSema and RetDec given their distinct and repre-
sentative code lifting schemes, i.e., emulation-style lifting vs.
high-level lifting (Sec. III). We follow the notation used in the
RetroWrite paper, and report to what extent different memory
regions are protected by ASan in Table XIII. As a binary-only
solution, RetroWrite can redzone heap but does not strive to
recover global or local variables. RetroWrite thus instruments
stack objects at the stack frame granularity, which may miss
bugs when the overﬂow is contained within the frame [43].
Recall McSema uses emulation-style lifting, which means that
the recovered function local stack no longer corresponds to the
original stack. Hence, we deem its lifted IR does not facilitate
redzoning stack, but protects heap and globals. Our previous
study has shown that RetDec (partially) recovers variables
and program stacks which are seen to be similar with the
clang-generated LLVM IR code. In principle, RetDec-lifted
IR code can enable the securing of stacks and global memory
regions, thereby overcoming the limits of binary-only tools.
Nevertheless, its variable recovery is inaccurate, which means
that its memory protections are not ﬂawless; we use “partial”
in Table XIII to denote this aspect.
Experiments. We use the Juliet test suite that was bench-
marked in the RetroWrite paper, which is a collection of test
programs containing stack and heap memory vulnerabilities.
Each test program has a “good” variant without a vulnerability
and a “bad” variant with a vulnerability (generated by slightly
modifying the “good” variant). Hence, tools can be evaluated
regarding errors reported on the bad variants while not ﬂagging
errors on the good variants.
We report the bug detection rates of ASan-enabled programs
in Table XII, and compare these with the rates reported for
RetroWrite (reusing results in its paper). For each Juliet test
case, we ﬁrst compare the outputs of the ASan-enabled good
variant with its original good variant using its shipped test
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
1116
VULNERABILITY DETECTION RATES. “FALSE POSITIVES” ARE OMITTED AS THEY ARE ALL ZERO FOR ALL SETTINGS.
TABLE XII
clang & ASan
RetroWrite
McSema & ASan
#Functionality Correct Cases
True Positive
True Negative
False Negative
Recall
5,914
4,489
5,914
1,382
76.5%
5,912
3,257
5,912
2,614
55.5%
6,350
2,097
6,350
4,253
33.0%
McSema & ASan
(heap vulnerability)
2,187
1,862
2,187
325
85.1%
RetroWrite & ASan
(heap vulnerability)
3,497
3,124
3,497
355
89.3%
RetDec & ASan
692
0
692
692
0%
TABLE XIII
OVERVIEW OF REDZONE POLICY AS ENABLED BY STANDARD ASAN,
RETROWRITE, AND LIFTED LLVM IR. “PARTIAL” CONSERVATIVELY
DENOTES THAT VARIABLE RECOVERY IS NOT ACCURATE, AND
FUNCTIONALITY MAY BE BROKEN IN THE FIRST PLACE.
Memory Object
Heap
Stack
Global
ASan
Full
Full
Full
RetroWrite
Full
NA
Lower granularity
McSema
Partial
NA
Partial
RetDec
Partial
Partial
Partial
inputs; if the outputs of two good variants are equal (see the
second row of Table XII), we then test if ASan checks in the
corresponding bad variant can capture the memory vulnera-
bility. A false positive means that ASan reports to capture the
vulnerability in a good variant whereas false negative means
that ASan misses to capture the vulnerability in a bad variant.
Given that McSema uses emulation-style stacks, we exclude
Juliet test programs containing stack vulnerabilities and report
results derived from the remaining ASan in the 5th column
of Table XII (heap vulnerabilities). Similarly, we also run the
released RetroWrite tool [15] on these heap vulnerability cases
and report the results in the sixth column.
clang-inserted ASan (the second column in Table XII) has
the highest recall rate, and the remaining false negative cases
(1,382) arise because some vulnerabilities in the Juliet dataset
are not designed to benchmark ASan. RetroWrite (the third
column) shows a good recall rate, which is comparable to
that of clang-inserted ASan. More importantly, RetroWrite
and McSema on heap vulnerability cases yield promising and
comparable recall rates (85.1% vs. 89.3%); however, McSema
generates 1,310 lifted IR programs which are mal-functional
(see the second row of Table XII). It thus becomes meaningless
to benchmark ASan over those 1,310 programs. In addition,
our manual study shows that some remaining false negatives
are due to bugs are not triggerable in 64-bit PIC code. Note
that RetroWrite can only process 64-bit PIC code whereas
McSema is a versatile cross-platform binary lifter that can
process binary code on 32-bit/64-bit x86, ARM, and SPARC
architectures. In sum, given that many heap-related vulnerabil-
ities, such as use-after-free bugs, remain unsolved [12], [71],
[114], McSema has appealing utility, as on the correctly-lifted
IR programs, it shows heap-sanitization performance that is
comparable to that of RetroWrite, the state-of-the-art binary-
only solution.
In addition, McSema’s emulation-style lifting can gener-
ate slower code than binary-only solutions. In all, McSema
carries large runtime performance overhead as computations
are emulated in its lifted IR code. Nonetheless, for Juliet
test cases, we report the extra runtime cost is negligible. Our
experiments show that McSema +ASan introduces about 40%
extra slowdown whereas RetroWrite +ASan is about 37%.
This is reasonable: while Juliet test cases contain compre-
hensive sets of vulnerabilities, these test programs are not so
complex. Nevertheless, we note that complex executable may
impose major challenge for both McSema and RetroWrite:
the emulation-style lifting of McSema can likely introduce
notable performance penalty, whereas the “re-assemable dis-
assembling” heuristics [110] employed by RetroWrite might
be broken (i.e., generating mal-functional code).
Our manual study conﬁrms that
in RetDec-lifted IR,
ASan checks are inserted in a generally comprehensive way,
similar to those in clang-generated IR. However, almost
all LLVM IR lifted by RetDec fails to retain functional
correctness. After excluding Juliet test programs that have
erroneous outputs, we have 692 remaining programs. We
report that vulnerabilities in all the “bad” variants of these
692 programs are missed, resulting in 692 false negatives in
Table XII. This evaluation reveals the lack of binary lifters
capable of delivering full-ﬂedged sanitization support. Heap
memory regions can be protected based on McSema-lifted IR,
which exhibits accuracy comparable to that of RetroWrite.
In contrast, the sanitization of stacks is dependent on the
functionality correctness of RetDec-lifted IR code, which
requires major improvements.
DE E PBI NDI F F BINARY DIFFING COMPARISON RESULTS ON POJ-104
RESULTS OVER DIFFERENT SETTINGS.
TABLE XV
gcc -O0
gcc -O3
clang -O0
clang -O3
BinDiff
70.2%
54.8%
57.7%
59.6%
DeepBinDiff
66.3%
68.3%
73.1%
66.3%
RetDec
77.7%
80.1%
81.0%
78.2%
B. Binary Difﬁng Comparison
We also compare our binary similarity analysis results
with those generated by the state-of-the-art binary difﬁng
tool, DeepBinDiff [46], and by the industrial standard
binary difﬁng tool, BinDiff [2]. The released DeepBinDiff
implementation [45] is highly convenient to use, as it does
not require a pre-trained model. Given two executable ﬁles,
it launches an on-the-ﬂy training process and conducts basic
block level matching.
Recall our discriminability model used in Sec. VI-C is
on the whole program-level, whereas the DeepBinDiff
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
1117
AVERAGE STRUCTUREDNESS AND LOC PER USER-DEFINED FUNCTION OF SPEC PROGRAMS.
TABLE XIV
Tools
gcc -O0