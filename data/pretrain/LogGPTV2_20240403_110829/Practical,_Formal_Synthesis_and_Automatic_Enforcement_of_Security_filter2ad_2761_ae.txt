next two columns represent the time spent on transforming
the Alloy models into 3-SAT clauses, and in SAT solving to
ﬁnd the space of solutions for each bundle. The timing results
show that on average SEPAR is able to analyze bundles of
apps containing hundreds of components in the order of a few
minutes (on an ordinary laptop), conﬁrming that the proposed
technology based on a lightweight formal analyzer is feasible.
D. Results for RQ4 (Policy Enforcement)
The last evaluation criterion is the performance benchmark
of SEPAR’s policy enforcement. To measure the runtime
overhead required for APE (i.e., policy enforcement), we have
tested a set of benchmark applications. Our benchmark appli-
cations repeatedly perform several ICC operations, such as the
startService method. We have handled uncontrollable factors
in our experiments by repeating the experiments 33 times, the
minimum number of repetitions needed to accurately measure
the average execution time overhead at 95% conﬁdence level.
Overall, the execution time overhead incurred by APE for
policy enforcement is 11.80% ± 1.76%, making the effect
on user experience negligible. Note that using the run-time
process instrumentation (cf. section VI), our infrastructure
only introduces overhead with the ICC calls, and does not have
any overhead in terms of the non-ICC calls. Thus, in practice,
the overhead introduced by our approach is signiﬁcantly less
than 11.80%.
VIII. RELATED WORK
Mobile security issues have received a lot of attention
recently. Here, we provide a discussion of the related efforts
in light of our research.
Android security analysis. A large body of work [16],
[22], [24], [27], [33], [35], [46], [59] focuses on performing
security analysis in the context of Android. Chin et al. [24]
studied security challenges of Android communication, and
developed ComDroid to detect those vulnerabilities through
static analysis of each app. Octeau et al. [46] developed
Epicc for analysis of Intent properties—except data scheme—
through inter-procedural data ﬂow analysis. FlowDroid [13]
introduces a precise approach for static taint ﬂow analysis
in the context of each application component. CHEX [42]
also takes a static method to detect component hijacking
vulnerabilities within an app. These research efforts, like many
others we studied, are mainly focused on Intent and component
analysis of one application. SEPAR’s analysis, however, goes
far beyond single application analysis, and enables synthesis
of policies targeting the overall security posture of a system,
greatly increasing the scope of vulnerability analysis.
The other, and perhaps more closely related, line of re-
search focuses on ICC analysis [17], [40], [41], [57], [59].
DidFail [40] introduces an approach for tracking data ﬂows
between Android components. It leverages Epicc for Intent
analysis, but consequently shares Epicc’s limitation of not
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:14 UTC from IEEE Xplore.  Restrictions apply. 
covering data scheme, which negatively affects the precision
of this approach in inter-component path matching. Moreover,
it does not generate nor enforce system-speciﬁc policies, as
performed by SEPAR. IccTA, similarly, leverages an intent res-
olution analysis to identify inter-component privacy leaks [41].
IccTA’s approach for inter-component taint analysis is based
on a pre-processing step connecting Android components
through code instrumentation, which improves accuracy of
the results but may also cause scalability issues. Amandroid
also tackles Android ICC-based privacy leaks [57]. It does
not support one of the four types of Android components,
i.e., Content Provider, nor complicated ICC methods,
like
startActivityForResult. Along the same line, COVERT [17]
presents an approach for compositional analysis of Android
inter-app vulnerabilities. While this work is concerned with
the analysis of permission leakage between Android apps, it
does not really address the problem that we are addressing,
namely the automated synthesis and dynamic enforcement of
system-speciﬁc policies.
Policy enforcement. The other relevant thrust of research
has focused on policy enforcement [15], [23], [37], [39], [48],
[50], [56], [58]. Kirin [28] extends the application installer
component of Android’s middleware to check the permissions
requested by applications against a set of security rules. These
predeﬁned rules are aimed to prevent unsafe combination of
permissions that may lead to insecure data ﬂows. Our work
differs in that it generates system-speciﬁc, ﬁne-grain policies
for a given system, rather than relying on general-purpose
policies deﬁned based only on coarse-grain permissions. More-
over, SEPAR is more precise as it dynamically analyzes policy
violations against ﬂows that actually occur at run-time.
Along the same line, some other techniques enforce policies
at runtime. Among others, Kynoid [50] performs a dynamic
taint analysis over a modiﬁed version of Dalvik VM. This
approach, similar to many of the previously proposed solu-
tions [26]–[29], requires changes to the Android. ASM [37]
presents an extensible security modules framework that en-
ables apps to deﬁne hooks in order to enforce app-speciﬁc
security requirements. While this work is concerned with
the design and implementation of a programmable interface
for deﬁning new reference monitors,
it does not consider
the problem that we address, the automation of synthesizing
ICC policies. The two approaches are thus complementary in
that SEPAR’s APE module can be realized as ASM hooks.
More recently, DeepDroid [56] presents a policy enforcement
scheme based on dynamic memory instrumentation of system
processes. However,
it depends on undocumented internal
architecture of Android framework and its system resources
which may change in future versions without notice.
Overall, all the enforcement techniques we studied rely
on policies developed by users, whereas SEPAR is geared
towards the application of formal techniques to synthesize
such policies through compositional analysis of Android apps.
Our work can complement prior enforcement techniques by
providing highly-precise synthesized policies to relieve the
users of responsibility of manual policy development.
Synthesis. Finally, constraint solving for synthesis and anal-
ysis has increasingly been used in a variety of domains [12],
[18], [19], [36]. These research efforts share with ours the
common insight of using the state-of-the-art constraint solving
for synthesis. Different from all
these techniques, SEPAR
tackles the automated detection and mitigation of inter-app
security vulnerabilities in Android, by synthesizing Android-
speciﬁc security policies. It thus relieves the tedium and errors
associated with their manual development. To the best of our
knowledge, SEPAR is the ﬁrst formally-precise technique for
automated synthesis and dynamic enforcement of Android
security policies.
IX. CONCLUDING REMARKS
This paper presents a novel approach for automatic synthesis
and enforcement of security policies, allowing the end-users
to safeguard the apps installed on their device from inter-app
vulnerabilities. The approach, realized in a tool, called SEPAR,
combines static program analysis with lightweight formal
methods to automatically infer security-relevant properties
from a bundle of apps. It then uses a constraint solver to
synthesize possible security exploits, from which ﬁne-grain
security policies are derived and automatically enforced to
protect a given device. The results from experiments in the
context of thousands of real-world apps corroborates SEPAR’s
ability in ﬁnding previously unknown vulnerable apps as well
as preventing their exploitation.
The great majority of Android devices run KitKat or older
versions [1], which provide a static permission model. How-
ever, a recently released version of Android (Marshmallow)
provides a Permission Manager that allows users to revoke
granted permissions after installation time. We believe a solu-
tion such as SEPAR becomes even more relevant in this new
version of Android, where the policies have to be ﬁne-tuned to
the user-speciﬁc, continuously-evolving conﬁguration of apps.
SEPAR has more potential in such a dynamic setting, as it can
be applied to continuously verify the security properties of
an evolving system as the status of app permissions changes.
SEPAR’s incremental analysis for policy synthesis can then
be performed on permission-modiﬁed apps at runtime. In
cases where vulnerabilities are detected and new policies are
synthesized, mitigation strategies could be carried through
the policy enforcer deployed on mobile devices, restricting
communications between certain apps to secure the system.
Our approach has a few limitations. Current implementation
of SEPAR mainly monitors API calls at the bytecode level. It
thus might miss methods executed in native libraries accessed
via Java Native Interface (JNI), or from external sources that
are dynamically loaded. It has been shown that only about
4.52% of the apps on the market contain native code [60].
Supporting these additional sources of vulnerability entails
extensions to our static program analysis and instrumentation
approach to support native libraries. Reasoning about dynam-
ically loaded code is not possible through static analysis,
and thus, an additional avenue of future work is leveraging
dynamic analysis techniques, such as TaintDroid [27] and
EvoDroid [43],
that would allow us to extract additional
behaviors that might be latent in apps.
524
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:14 UTC from IEEE Xplore.  Restrictions apply. 
X. ACKNOWLEDGMENT
This work was supported in part by awards CCF-1252644
from the National Science Foundation, D11AP00282 from
the Defense Advanced Research Projects Agency, W911NF-
09-1-0273 from the Army Research Ofﬁce, HSHQDC-14-
C-B0040 from the Department of Homeland Security, and
FA95501610030 from the Air Force Ofﬁce of Scientiﬁc Re-
search.
REFERENCES
[1] “Android
platform versions,”
http://developer.android.com/about/
dashboards/index.html#2015.
[2] “Bazaar,” http://cafebazaar.ir/.
[3] D. Jackson, Software Abstractions, 2nd ed. MIT Press, 2012.
[4] “Droidbench2.0,”
http://github.com/secure-software-engineering/
DroidBench/tree/iccta/apk.
[5] “F-droid,” https://f-droid.org/.
[6] “Freemarker java template engine,” http://freemarker.org/.
[7] “Google play market,” http://play.google.com/store/apps/.
[8] “Iccbench,” https://github.com/fgwei/ICC-Bench/tree/master/apks.
[9] “Iccta tool on github, reported issues,” https://github.com/lilicoding/
soot-infoﬂow-android-iccta/issues/7.
[10] “Separ,” https://seal.ics.uci.edu/projects/separ.
[11] “Xposed framework,” http://repo.xposed.info/.
[12] D. Akhawe, A. Barth, P. Lam, J. Mitchell, and D. Song, “Towards a
formal foundation of web security,” in Proc. of CSF, 2010.
[13] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y. Le Traon, D. Octeau, and P. McDaniel, “Flowdroid: Precise context,
ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for android
apps,” in Proc. of PLDI, 2014.
[14] K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie, “Pscout: Analyzing the
android permission speciﬁcation,” in Proc. of CCS, 2012.
[15] M. Backes, S. Gerling, C. Hammer, M. Maffei, and P. von Styp-
Rekowsky, “Appguard–enforcing user requirements on android apps,”
in Proc. of TACAS, 2013.
[16] H. Bagheri, E. Kang, S. Malek, and D. Jackson, “Detection of design
ﬂaws in android permission protocol through bounded veriﬁcation,” in
Proc. of FM, 2015, pp. 73–89.
[17] H. Bagheri, A. Sadeghi, J. Garcia, and S. Malek, “Covert: Compositional
analysis of android inter-app permission leakage,” IEEE Transactions on
Software Engineering, vol. 41, no. 9, pp. 866–886, 2015.
[18] H. Bagheri and K. Sullivan, “Model-driven synthesis of formally precise
stylized software architectures,” Formal Aspects of Computing, 2016.
[19] H. Bagheri, C. Tang, and K. Sullivan, “Trademaker: Automated dynamic
analysis of synthesized tradespaces,” in Proc. of ICSE, 2014.
[20] E. Bodden, “Inter-procedural data-ﬂow analysis with ifds/ide and soot,”
in Proc. of SOAP, 2012.
[21] S. Bugiel, L. David, Dmitrienko, T. A. Fischer, A. Sadeghi, and
B. Shastry, “Towards taming privilege-escalation attacks on android,”
in Proc. of NDSS, 2012.
[22] Y. Cao, Y. Fratantonio, A. Bianchi, M. Egele, C. Kruegel, G. Vigna,
and Y. Chen, “Edgeminer: Automatically detecting implicit control ﬂow
transitions through the android framework,” in Proc. of NDSS, 2015.
[23] K. Z. Chen, N. M. Johnson, V. D’Silva, S. Dai, K. MacNamara, T. R.
Magrino, E. X. Wu, M. Rinard, and D. X. Song, “Contextual policy
enforcement in android applications with permission event graphs.” in
NDSS, 2013.
[24] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, “Analyzing inter-
application communication in android,” in Proc. of MobiSys, 2011.
[25] A. S. Christensen, A. Møller, and M. I. Schwartzbach, “Precise analysis
of string expressions,” in Proc. of SAS, 2003.
[26] M. Dietz, S. Shekhar, Y. Pisetsky, A. Shu, and D. S. Wallach, “Quire:
Lightweight provenance for smart phone operating systems,” in Proc. of
USENIX, 2011.
[27] W. Enck, P. Gilbert, B. g. Chun, L. P. Cox, J. Jung, P. McDaniel,
and A. N. Sheth, “Taintdroid: An information-ﬂow tracking system for
realtime privacy monitoring on smartphones,” in USENIX OSDI, 2011.
[28] W. Enck, M. Ongtang, and P. McDaniel, “On lightweight mobile phone
application certiﬁcation,” in Proc. of CCS, 2009.
[29] A. P. Felt, H. Wang, A. Moshchuk, S. Hanna, and E. Chin, “Permission
re-delegation: Attacks and defenses,” in Proc. of USENIX Security, 2011.
[30] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner, “Android
permissions demystiﬁed,” in Proc. of CCS, 2011, pp. 627–638.
[31] E. Fragkaki, L. Bauer, L. Jia, and D. Swasey, “Modeling and enhancing
android’s permission system,” in Proc. of ESORICS, 2012.
[32] Gartner Inc., “Gartner reveals top predictions for IT organizations
and users for 2012 and beyond,” http://www.gartner.com/newsroom/id/
1862714, 2011.
[33] C. Gibler, J. Crussell, J. Erickson, and H. Chen, “Androidleaks: Auto-
matically detecting potential privacy leaks in android applications on a
large scale,” in Trust and Trustworthy Computing, 2012.
[34] Google, “Android api reference document,” http://developer.android.
[35] M. Grace, Y. Zhou, Z. Wang, and X. Jiang, “Systematic detection of
capability leaks in stock android smartphones,” in Proc. of NDSS, 2012.
[36] S. Gulwani, “Dimensions in program synthesis,” in Proc. of PPDP,
com/reference.
2010.
[37] S. Heuser, A. Nadkarni, W. Enck, and A.-R. Sadeghi, “Asm: A
programmable interface for extending android security,” in Proc. of
USENIX, 2014.
[38] S. Holavanalli, D. Manuel, V. Nanjundaswamy, B. Rosenberg, F. Shen,
S. Y. Ko, and L. Ziarek, “Flow permissions for android,” in Proc. of
ASE, 2013.
[39] P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall, “These
aren’t the droids you’re looking for: Retroﬁtting android to protect data
from imperious applications,” in Proc. of CCS, 2011, pp. 639–652.
[40] W. Klieber, L. Flynn, A. Bhosale, L. Jia, and L. Bauer, “Android taint
ﬂow analysis for app sets,” in Proc. of SOAP, 2014.
[41] L. Li, A. Bartel, J. Klein, Y. L. Traon, S. Arzt, S. Rasthofer, E. Bodden,
D. Octeau, and P. McDaniel, “Iccta: Detecting inter-component privacy
leaks in android apps,” in Proc. of ICSE, 2015.
[42] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang, “Chex: statically vetting
android apps for component hijacking vulnerabilities,” in CCS, 2012.
[43] R. Mahmood, N. Mirzaei, and S. Malek, “Evodroid: Segmented evolu-
tionary testing of android apps,” in Proc. of FSE, 2014.
[44] C. Mann and A. Starostin, “A framework for static detection of privacy
leaks in android applications,” in Proc. of SAC, 2012.
[45] T. Nelson, S. Saghaﬁ, D. J. Dougherty, K. Fisler, and S. Krishnamurthi,
“Aluminum: Principled scenario exploration through minimality,” in
Proc. of ICSE, 2013, pp. 232–241.
[46] D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, and Y. L.
Traon, “Effective Inter-Component Communication Mapping in Android
with Epicc: An Essential Step Towards Holistic Security Analysis,” in
Proc. of USENIX Security, 2013.
[47] S. Rasthofer, S. Arzt, and E. Bodden, “A machine-learning approach
for classifying and categorizing android sources and sinks,” in Proc. of
NDSS, 2014.
[48] S. Rasthofer, S. Arzt, E. Lovat, and E. Bodden, “Droidforce: Enforcing
complex, data-centric, system-wide policies in android,” in Proc. of
ARES, 2014, pp. 40–49.
[49] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E. Youman, “Role-
based access control models,” Computer, vol. 29, no. 2, pp. 38–47, 1996.
[50] D. Schreckling, J. Posegga, J. K¨ostler, and M. Schaff, “Kynoid: Real-
time enforcement of ﬁne-grained, user-deﬁned, and data-centric security
policies for android,” in Proc. of WISTP, 2012, pp. 208–223.
[51] A. Shabtai, Y. Fledel, U. Kanonov, Y. Elovici, S. Dolev, and C. Glezer,
“Google android: A comprehensive security assessment,” Security &
Privacy, IEEE, vol. 8, no. 2, pp. 35–44, 2010.
[52] Symantec, “2015 internet security threat report,” Tech. Rep. Vol. 20,
Apr. 2015.
[53] Symantec Corp., “2012 norton study.” http://www.symantec.com/about/
news/release/article.jsp?prid=20120905 02, Sep. 2012.
[54] O. Tripp, M. Pistoia, P. Cousot, R. Cousot, and S. Guarnieri, “An-
dromeda: Accurate and scalable security analysis of web applications,”
in Proc. of FASE, 2013.
[55] R. Valle ´e-Rai, P. Co, E. Gagnon, L. Hendren, and V. Lam, P.and Sun-
daresan, “Soot - a java bytecode optimization framework,” in Proc. of
CASCON’99, 1999.
[56] X. Wang, K. Sun, Y. Wang, and J. Jing, “Deepdroid: Dynamically
enforcing enterprise policy on android devices,” in Proc. of NDSS, 2015.
[57] F. Wei, S. Roy, X. Ou, and Robby, “Amandroid: A precise and general
inter-component data ﬂow analysis framework for security vetting of
android apps,” in Proc. of CCS, 2014.
[58] R. Xu, H. Sa¨ıdi, and R. Anderson, “Aurasium: Practical policy enforce-
ment for android applications.” in Proc. of USENIX Security, 2012.
[59] Y. Zhou and X. Jiang, “Detecting passive content leaks and pollution in
android applications,” in Proc. of NDSS, 2013.
[60] Y. Zhou, Z. Y. Wang, W. Zhou, and X. Jiang, “Hey, you, get off of
my market: Detecting malicious apps in ofﬁcial and alternative android
markets,” in Proc. of NDSS, 2012.
[61] Y. Zhou and X. Jiang, “Dissecting android malware: Characterization
and evolution,” in Proc. of IEEE Security and Privacy, 2012.
525
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:14 UTC from IEEE Xplore.  Restrictions apply.