adopting this conﬁguration, among which 1,038 of them allow
their SSL/TLS traﬃc to be potentially intercepted.
Domain example.com and Invalid Digests Another peculiar
conﬁguration comes from apps using the domain example.com
within their policy. We identiﬁed this interesting conﬁguration
from a cluster of 41 apps. However, there is, of course, no
need for an app to protect this domain since this example.com
domain is clearly not relevant. Thus, we looked for similar apps
and we found out that in total, other 58 apps use this domain,
48 of which come from 7 diﬀerent clusters. We then found that
these policies are copied verbatim from the Android Developer
website and from StackOverﬂow. We tracked down the original
policiescombiningboththedomainnameandtheuniquedigests
deﬁned in some of the policies. These policies deﬁne certiﬁcate
pinning on example.com or with invalid digests formed by “B”
repeated 44 times (see the Appendix for the complete policies).
We believe that there are two possible explanations to justify
the adoption of these (useless) policies. In the ﬁrst one, the
developer wants to deﬁne one speciﬁc feature of the policy: she
then copies an existing policy that contains both the requested
featureandtheuniqueconﬁgurationofcertiﬁcatepinning.Inthe
secondone,thispolicymighthavebeenusedbyadeveloperwho
was looking for a certiﬁcate pinning implementation and she
copiedtheﬁrstavailablepolicy. Whilecopyingsecuritypolicies
that contain “dummy” domain names such as example.com is
not a security problem per se, we believe that these policies
may create a false sense of security in the developer’s mind:
the developer may wrongly believe that certiﬁcate pinning is
correctly implemented in her application, while, in fact, it is not.
Certiﬁcate Pinning. Certiﬁcate pinning increases the security
of the communication ensuring integrity, conﬁdentiality, and
authenticity. Thankfully, implementing certiﬁcate pinning via
Figure 1: The ﬁgure shows the CDF of the number of domains
deﬁned within policies. Note how 62.5% of the apps do not
deﬁne a custom policy for any domain. The 21% of the apps
deﬁne exactly one domain, while the 8.5% speciﬁes up to 2
domains within the policy. Note that the CDF has a long tail,
with several apps deﬁning more than 30 domains within the
same policy, and two apps specifying 368 and 426 policies.
Domains. We then proceed by looking at apps using the
cleartext attribute on an explicit list of domains (using the
domain node). We identiﬁed only 2,891 apps allow cleartext
for a subset of domain while only 219 force the domain in the
list to be reached only securely. Figure 1 shows the cumulative
distribution function (CDF) of the number of domains deﬁned
within policies. In general, most apps (∼ 95%) specify custom
policies for at most three domain names.
Policy for 127.0.0.1. We then looked at clusters of more com-
plex policies, in terms of nodes and attributes, and we noticed
someinterestingpatterns. Weidentifyhow492appsconﬁgurea
veryspeciﬁcdomain-confignodefortheIPaddress127.0.0.1,
localhost. Even if this policy does not introduce any security
vulnerability and should be considered as a safe policy, we
founditinteresting: whileitmaybecommon practicetospawn a
local server,it is very uncommon that all the 492 apps deﬁne the
same policy for localhost. This conﬁguration, however, is very
common among other apps: in total, we identify other 512 apps
belonging to 43 diﬀerent clusters having the same domain-
config setup, and 109 apps not belonging to any cluster. Thus,
this speciﬁc domain conﬁguration is used by 1,113 apps. We
then set out to pinpoint the underlying source of this policy, and
we eventually determined that this policy is deﬁned by the Audi-
ence NetworkAndroidSDK,the Facebookadvertisementframe-
work. Inparticular,wenoticedhowadeveloperwhowantstouse
thislibrarymustmodifythepolicytoincludethisspeciﬁcconﬁg-
uration to avoid unintended behavior. The oﬃcial library’s doc-
umentation makes clearthatthis modiﬁcation is mandatory due
totheinternalsofthelibraryitself. Thisﬁndingopensascenario
that is diﬀerent than the simple “developers copy policies”: in
USENIX Association
29th USENIX Security Symposium    349
NSP is now much simpler than it was in the past. However,
we found that only 102 applications enforce it through the
policy. Out of these 102 apps enforcing certiﬁcate pinning,
an interesting cluster is constituted by apps that implement
pinning but then mistakenly override it. We identiﬁed 9 apps
that specify one or more pin-set, but set the overridePins
attribute to true, making the various pin-set useless. We
argue that it is very likely that the developer is not aware of
it, otherwise she would not have speciﬁed any pin-set entry.
We believe Android Studio (or other IDEs) should ﬂag this
kind of policy as potentially misconﬁgured.
Invalid Attributes. We identiﬁed a group of apps deﬁning
attributes that are not speciﬁed within the oﬃcial documen-
tation [24]. For example, we identiﬁed two apps deﬁning the
usesCleartextTraffic attribute in the policy (even if this
is only valid in the old version of the NSP), or two apps deﬁning
the cleartextTrafficPermitted attribute within a wrong
node. We also found one app declaring the hstsEnforced
attribute, which is not mentioned in the oﬃcial documentation.
However, by looking at the source code of the policy parser, we
notice how this attribute is actually recognized as valid. This
attribute allows a developer to deﬁne HSTS for the WebView
component of her application (which would “force” the Web-
View to always contact via HTTPS websites sending the HSTS
header [18]). We note how the concept of HSTS signiﬁcantly
overlaps with the cleartext aspect of the NSP. We investigated
the reason whythis attribute is stillavailable within the NSP and
we found out that it may exist because older versions of the Web-
View were not enforcing the cleartextTrafficPermitted
attribute [24] (but were enforcing HSTS instead).
TrustKit. The cluster of policies deﬁned using TrustKit
is formed by 53 apps. Among these apps, 10 deﬁne a
reporting-endpoint to use when a pinning failure is
identiﬁed, while 16 apps explicitly disabled this feature. To
conclude, 46 apps deﬁne certiﬁcate pinning within the policy.
Remaining Apps. Our methodology based on clustering and
targeted queries allowed us to systematically group a vast
portion of our dataset. However, as we mentioned, 311 apps
did not ﬁt any cluster. We then manually inspected them all,
to look for additional interesting patterns. Among these, we
identiﬁed 98 apps that deﬁne a very unique policy in terms
of domain nodes used with the policy. The other 46 apps
shared a speciﬁc policy that did not take advantage of the
“wrapper nodes” like pin-set or domain-config: for each
of the domains, these apps opened a new domain-config
node each time instead of deﬁning all the domains within
one node. We also found 44 apps that specify more than one
custom certiﬁcate. Another interesting conﬁguration comes
from apps whose policy appears very verbose and that could
have been reduced. We noticed how 32 applications specify
a default “allow cleartext” for the entire app and, on top of
that, conﬁgured a very detailed list of domains and subdomains
with the same exact policy. 21 applications deﬁned additional
text (like comments or left-over in between nodes) that is then
removed by the system during the parsing process. To conclude,
the remaining apps deﬁned very unique and complex policies
that do not belong to any of the aforementioned groups, but that,
from the security perspective,do not represent anything special.
Dataset Evolution. Starting from November 1st, 2019, all
apps must target at least API level 28 [28]. This means, from
a NSP perspective, that all the new apps, by default, will forbid
cleartext. Since our dataset was crawled before November (see
Section 5.1), we decided to repeat some of the measurements,
this time on a dataset downloaded after this new mandatory
requirement. Our goal is to investigate how the apps evolved
after the introduction of the new default value that forbids
the usage of any cleartext protocol. We started a re-crawl of
the same initial dataset, starting from the 125,419 package
names. These apps were re-crawled from April to June 2020.
We were able to download 86.5% of the initial dataset, for a
total of 108,542 apps. Of the remaining apps that we could not
re-download, 15,749 apps were removed from the Google Play
Store and 1,128 apps moved from a free to "paid" download or
introduced in-app purchases not available in our geographical
region. The apps that we were able to re-crawl are distributed
as follows: the 14.3% of the apps (15,531) target an API level
29, the 46.2% (50,191) instead target a level 28, 9.5% (10,351)
the level 27, 12.7% (13,795) level 26 and the remaining 17.2%
(18,674) target an API level 25 or lower.
Unsurprisingly, the number of apps deﬁning a NSP
increased: 33.3% of the apps (36,165) now specify one
of the two types of NSP. Among these apps, the 65.5%
(23,718) still adopts the ﬁrst version of the NSP through the
AndroidManifest, while the remaining apps (15,492) opted
for the new and more recent version. Interestingly, 8.4% of
the apps (3,045) use both versions of the policies.
We then looked for how many apps eﬀectively adopted the
new defaultofforbidding cleartextprotocols forthe entire appli-
cation: surprisingly,approximatelythe33%oftheentiredataset
(35,789 out of 108,542) enforced a default conﬁguration that
does not permit cleartext protocols. Out of these apps, 419 used
theﬁrstversionofthepolicy. Theremaining67%oftheappsstill
conﬁgureaNSPthatpermitscleartexttraﬃc. Fromthis67%,the
32% (23,229) still adopt the ﬁrst version of the policy. However,
what it is interesting to notice is that 58% (42,353) of apps allow
cleartext due to default conﬁguration, dictated by the API level.
To conclude,we note how only a small portion of apps,the 0.4%
(349), allow cleartext as base conﬁguration and also deﬁne a set
of domains for which they allow only encrypted connections.
These results somehow highlight an ecosystem-wide prob-
lem that aﬀects Android apps: even if Google provides a simple
and easy way to conﬁgure the SSL/TLS for an app (the NSP),
and even though it explicitly changed the defaults to force the
usageofcleartextprotocols,asigniﬁcantportionofappsstillopt
to stick, for one reason or another, to plain and unencrypted net-
workingprotocols:whilethecommunityismakingprogress,we
are not there yet for a full adoption of HTTPS by Android apps.
350    29th USENIX Security Symposium
USENIX Association
5.3 Android Networking Libraries Adoption
So far, this section has focused on the exploration of how apps
adopt NSPs. However, we did not tackle the aspect of enforcing
these policies. The NSP is simply an XML conﬁguration ﬁle,
and it is then up to the various network libraries to properly
honor (and enforce) what is speciﬁed by such conﬁguration ﬁle.
To this end, we set out to explore how Android apps and
network libraries do enforce these policies. First, we checked
the oﬃcial Android documentation, which states that “third-
party libraries are strongly encouraged to honor the cleartext
setting” [24]. We found the documentation concerning, for two
reasons. First, the wording of the documentation only mentions
that honoring the policy is “strongly encouraged.” However,
we believe that since the policy relates to security-relevant
aspects, network libraries should be forced to honor the
policy—and in case they do not, that should be considered
as a vulnerability. In fact, a network library not honoring the
policy would have the negative side-eﬀect of silently making
the policy useless. Second, the documentation only mentions
the “cleartext settings.” However, as we discussed in Section 3,
the new version of the policy touches on many more aspects:
Unfortunately, the documentation does not even mention the
other features (e.g., which KeyStore to trust, pinning).
Next, we checked the oﬃcial API, implemented by the
NetworkSecurityPolicy class. This is the API that, in
theory, network libraries should rely on to obtain the content
of the policy (and honor it). However, this API appears very
limited: the only available API is isCleartextTrafficPer-
mitted(), which returns whether cleartext traﬃc should be
allowed. There is no other API to query the remaining ﬁelds
of the policy, and it is thus not clear how network libraries are
supposed to enforce them.
Forthesereasons,wesetouttoexplorehowandwhetherpopu-
larnetwork libraries honorthe policy. The remainderof this sec-
tion discusses how we built a dataset of network libraries, an au-
tomatic analysis framework to test whether a given library hon-
ors thevarious aspectsofa policy,andtheresults ofthis analysis.
Libraries Dataset. To perform this investigation, we ﬁrst
built a comprehensive dataset of the most used networking
libraries. We identiﬁed these libraries from AppBrain [11],
a service that provides multiple statistics on the Android
application’s ecosystem such as “Android libraries adoption”
by diﬀerent apps. Our dataset consists of all the network
libraries mentioned by AppBrain: URLConnection, Robospice,
HttpClientAndroid, AndroidAsync, Retroﬁt, BasicHttpClient,
OkHttp, AndroidAsyncHTTP, Volley, and FastAndroidNetwork-
ing. Except for URLConnection, which is the default HTTP
library on Android, all the libraries are “external,” which
means that app developers need to manually specify them as
external dependencies. Note that these external libraries, even
though they are not the default, are used by almost 30% of all
the apps published on the Google Play Store (∼250K unique
apps). Table 3, in Appendix, provides more detailed statistics.
Analysis Framework. Determining whether a given library is
implementing the NSP is not a straightforward process. In fact,
the source code of these libraries is often not available, and
manualreverseengineeringmaybechallenginganderror-prone.
Thus, we opted for an automatic approach based on dynamic
analysis. We built an automatic framework to check whether
a given networking library honors the policy deﬁned in an app.
Note that while for this paper we tested the ten popular network
libraries in our dataset, our framework is completely generic
and can be easily used to vet an arbitrary network library.
Our framework analyzes each network library individually.
For each of them, it performs the following steps. First, we
generate all the possible combinations of a policy, by combin-
ing all possible nodes, attributes, and representative values. In
particular, the framework considers the following nodes: base-
config, domain-config, pin-set, and trust-anchors.
For each node, it considers all the relevant child nodes, such as
domain, pin,and certificate. Eachnode is then conﬁgured
with all the possible attributes that might be used within a given
node,like overridePins forwhatconcerns trust-anchors,
or src for the certificate node (see Section 3 for the entire
list). For what concerns the values, we generate “representative
values.” For the value ﬁeld representing a certiﬁcate hash,
we generate various policies with the following values: a
valid hash matching the hash of the certiﬁcate actually used
during the tests, a valid hash that is diﬀerent than the expected
one, and a non-valid hash (e.g., the character “A” repeated
several times). The combinations of all nodes, attributes, and
representative values, generates 72 unique policies.
Then, the framework creates an app that attempts to connect
to an endpoint via HTTP and via HTTPS by using the library
under test. The app is then built multiple times, each time with
a diﬀerent policy. Each of these apps is then tested in three
diﬀerent “testing environments,” each of which simulates the
diﬀerent threat models discussed in Section 2: 1) the app is
tested without attempting to perform MITM; 2) we simulate
an attacker performing MITM (by using a proxy); 3) we
simulate an attacker performing MITM with the attacker’s
custom CA added to the User KeyStore. At each execution, the
framework logs whether a given connection with a given policy
in a given testing environment was successful or not. These
logs are compared with a ground truth, which is generated
by a Python-based implementation that takes into account
the various aspects of the policy and the various testing
environments. We ﬂag a library as compliant if and only if the
runtime logs match with the expectations of the ground truth.
Compliance Results. First, we identiﬁed that HttpClien-
tAndroid, AndroidAsync, and AndroidAsyncHTTP are not
enforcing the cleartext attribute: these libraries allow HTTP
even though the policy would prohibit it. We note how these
libraries are used by more than tens of thousands of popular
apps with hundreds of millions of unique installations.
Instead, for what concerns certiﬁcate pinning and trusted
anchors, we noticed that nine of the ten libraries do correctly
USENIX Association
29th USENIX Security Symposium    351
Figure 2: Ad Ecosystem of individual ad network
honor the policy. Given the diﬃculty and missing documen-
tation, we were positively surprised by this high adoption rate.
We thus decided to investigate why libraries are enforcing
such a diﬃcult part of the policy and not the easier-to-enforce
cleartext settings. For these libraries, we performed manual
analysis (including source code analysis, when available)
to determine how the policy is actually enforced. We found
that none of these libraries is implementing SSL/TLS-related
operations from scratch nor deﬁning a custom handler for
CAs. Instead, they are all relying on core Android framework
methods to perform SSL operations, which includes handshake
and management of the KeyStores. All these operations are
handled by the Conscrypt [23] package, which provides Java
Secure Socket Extension (JSSE). While this is clearly a positive
news, we ﬁnd it surprising that these popular network libraries
do not adhere to arguably more critical cleartext settings.
We also found that AndroidAsync, used by thousands of
apps, does not support NSP at all. In fact, we found that the
mere presence of a domain-config node is enough to break
the network library, leading to an exception, and thus making
it essentially incompatible with the NSP. Table 3, in Appendix,
summarizes our ﬁndings.
5.4 Disclosure
We disclosed our ﬁndings to Google, with an emphasis on the
misconﬁguration of the SSL Pinning (which may give a false
sense of security to inexperienced app developers). We also
proposed to extend the AndroidStudio IDE with a linter for the
NSP that checks for these misconﬁgurations and informs the
developer about the potential risks. Google acknowledged that
this is, in fact, a rather odd conﬁguration. For what concerns
the networking libraries not compliant with the actual NSP