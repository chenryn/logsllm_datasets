reducing the required user interaction to opening a web-browser have been described by McCann et
al. [41].
Salgarelli et al. [53] suggested a general roaming authentication framework based on the shared keys
which can be implemented as an EAP method. Their protocol extends the classical Needham-Schroeder
technique [46] to accommodate the authentication servers of the foreign and the home network while
minimizing the communication rounds between them. Previously, Molva et al. [45] described another
roaming protocol based on shared keys, which was designed for the integration into the IBM’s Kryp-
toKnight authentication and key distribution framework. Merino et al. [42] proposed a Single Sign-On
authentication architecture based on 802.1X and EAP-TLS [57] relying on the Public Key Infrastructure
(PKI). Their method can be combined with any web-based authentication method, e.g., UAM. The draw-
back of this approach is that the mobile device is assumed to be able to check the validity of the foreign
network’s certiﬁcate while being oﬀ-line. Furthermore, the use of public-key operations might be costly
for performance-constraint mobile devices. Similar drawbacks appear in the authentication protocols
from [9, 33]. Long et al. [40] suggested a roaming protocol based on the modiﬁed SSL handshake assum-
ing that mobile device are equipped with public-key certiﬁcates, so that the protocol can be executed
without active involvement of the home network. Ribeiro et al. [49] described a roaming authentication
approach based on IPsec VPNs and a hierarchy of certiﬁcation authorities. The aforementioned problems
with validation of public-key certiﬁcates by the mobile device were solved by Meyer et al. [44] via secret
sharing technique [55]. In their protocol described as an extension of EAP-TLS [57] each foreign network
is assumed to hold a share of the home network’s secret key and the respective public-key certiﬁcate of
the home network is pre-installed at the mobile device. During the execution of the protocol (which is a
modiﬁed TLS handshake) the foreign and the home network need to cooperate in order to perform the
required signature and decryption operations.
Additionally, we mention the commercial system Fon [30], which sells own Wi-Fi routers that mediate
the authentication of mobile devices to a Fon server using MAC/IP address ﬁlter technique. As noted
in [54] the deployed address ﬁlter technique allows address spooﬁng attacks. Another commercial system
Wisher [60] requires that foreign networks distribute WPA keys to authorized guests. Obviously, this
approach does not protect from the redistribution of the obtained keys by possibly malicious guests.
The aforementioned solutions proposed for wireless non-tunnel-based roaming (in mobile phone and
wireless IP networks) have been designed with the main goal to authenticate (and provide a session key
to) the mobile and the foreign network, whereby some approaches require the interaction with the home
network. The only currently available solution for the tunnel-based roaming by Sastry et al. [54] has
already been discussed in Section 2.1.
4 Authentication and Key Establishment Model for WRT
Here we model authentication and key establishment goals of a WRT protocol (denoted as Π within the
model). Our deﬁnitions extends the classical two-party model from [13].
4.1 Communication Model
Protocol Participants and Long-Lived Keys We consider a home network H, a mobile device M
registered with H, and a foreign network F as participants of Π. In practice H and F can be seen as
corresponding authentication servers. We do not distinguish between the participants and their identities,
6
M. Manulis, D. Leroy, F. Koeune, O. Bonaventure, and J.-J. Quisquater
which are assumed to be unique; the identity of a mobile device M is assumed to be unique within its own
home network H. All protocol participants are modeled as probabilistic polynomial time (PPT) machines.
We assume that participating H, F, and M are in possession of their corresponding long-lived keys LLP ,
P ∈ {M,F,H}, which are used in diﬀerent executions of Π. We assume that all long-lived keys as well
as further secrets used in Π are polynomially bounded with respect to some security parameter κ.
Instances and Protocol Sessions In order to model participation of M, F, and H in distinct sessions of
Π we consider an unlimited number of instances: By [P, s] we denote the s-th instance of P ∈ {M,F,H}
where s ∈ N.
its unique publicly known session id sids
sidsM = sidsF = sidsH are partnered, i.e. participate in the same session.
An instance [P, s] may be invoked for one session. Throughout the protocol execution [P, s] may learn
P . Instances of M, F and H that hold identical session ids
Upon the protocol invocation the instance [P, s] is initialized with the long-lived key LLP and turns
into a processing state where it proceeds according to the protocol speciﬁcation, until it collects enough
information to decide whether the protocol execution was successful (we say an instance accepts) or not
(we say an instance aborts). Finally, the instance terminates meaning that it stops processing any further
protocol messages. In a WRT protocol diﬀerent participants have diﬀerent acceptance criteria, i.e., an
instance of F accepts when it is ready to create the tunnel, in particular after the computation of the
session tunnel key Kt ∈ {0, 1}κ, whereas the instances of M and H accept when they are ready to
communicate with each over the tunnel, in particular after the computation of the session end-to-end key
KM,H ∈ {0, 1}κ (in addition to Kt).
4.2 Security Model
Security Associations and Commitments The mobile device M and its home network H are assumed
to maintain some security association (as a result of the initialization), and to accept the provided tunnel
connection if they can successfully authenticate each other upon the tunnel establishment.
To the contrary, there is no security association between M and F prior to the execution of Π, i.e.
M and F need not to be aware of each other, which is fairly natural in the case of roaming. Therefore,
in questions related to the authorized WRT participation both, M and F, rely on H.
On the other hand, as part of their contract we assume that F creates a tunnel to H if it successfully
authenticates H, whereas H accepts the provided tunnel after the successful authentication of F (in
addition to the authentication of M). Nevertheless, this does not rule out attacks by malicious F trying
to impersonate M towards H.
Adversarial Model The adversary A modeled as a PPT machine is assumed to have complete control
over the protocol invocation and the communication channels. Additionally, we allow A to corrupt parties.
However, we will restrict this latter ability of A in a meaningful way upon deﬁning the actual security
goals. We model possible actions of A through the following set of queries:
- Invoke(P, m): This is the protocol invocation query that can be asked for some entity P ∈ {M,F,H}.
In response, a new instance [P, s] is created and A is given its ﬁrst outgoing message. The optional
input m indicates the message expected by the instance to start the execution; for the initiator of the
protocol m is supposed to be empty.
- Send(P, s, m): This query models communication control by A and contains a message m which
should be delivered to the s-th instance of P ∈ {M,F,H}. The adversary can decide honestly to
forward protocol messages between the instances in order to eavesdrop the protocol execution (that
is A remains passive) or to manipulate or inject messages (that is A becomes active). In response, A
receives the outgoing message of [P, s], or an an empty message if [P, s] terminates having processed
m.
- Corrupt(P ): This query models corruptions of P ∈ {M,F,H}. In response, A receives LLP . As soon
as A corrupts P , all instances of P are also treated as corrupted.
Authenticated Wireless Roaming via Tunnels: Making Mobile Feel at Home
7
- RevealKey(P, s): This query models independence of end-to-end keys computed by the instances of
P ∈ {M,H} in diﬀerent sessions. In response, A is given KM,H held by the instance; the query is
answered only if [P, s] has accepted.
- RevealTunnelKey(P, s): This query models independence of tunnel keys computed by the instances of
P ∈ {M,F,H} in diﬀerent sessions. In response, A is given Kt held by the instance; the query is
answered only if [P, s] has accepted.
Correctness The following deﬁnition of correctness, given from the perspective of one particular session,
speciﬁes the purpose of Π with respect to the tunnel creation and key establishment.
Deﬁnition 1 (Correctness). An authentication and key establishment protocol for WRT Π is correct
if in the presence of a passive adversary A the invoked instances of M, F, and H terminated having
accepted and all of the following holds: M and H hold the same end-to-end key KM,H; M, F, and H
hold the same tunnel key Kt.
Security Goals We start by deﬁning the requirement of mutual authentication (MA) between the
instances of M and H. In order to reduce the complexity of the model (and proofs) Deﬁnition 2 captures
additional sub-goals related to the agreement on the session end-to-end and tunnel keys computed by
the instances of M and H, i.e., that at the end of the successful protocol execution both instances hold
identical keys (these sub-goals are expressed through conditions 3 and 4). The signiﬁcant diﬀerence is
that for the agreement on the tunnel key Kt, the foreign network F should remain uncorrupted, whereas
no such restriction is made for the mutual authentication between M and H and the agreement on the
end-to-end key KM,H. This models possible attacks of a malicious F trying to impersonate either M or
H or to inﬂuence a disagreement on the established session end-to-end key KM,H. Since the tunnel key
Kt will be used to protect control messages for the maintenance of the tunnel (and not to protect the
actual service requests of M and responses of H) we refrain from consideration of malicious M, H, or F
aiming to compromise the agreement on Kt.
(A, κ) we denote
Deﬁnition 2 (MA between M and H). Given a correct protocol Π by Gamema-m-h
the interaction between the instances of M, F and H with a PPT adversary A that is allowed to query
Invoke, Send, Corrupt, RevealKey, and RevealTunnelKey. A wins if at some point during the interaction:
(1) an uncorrupted instance of M accepts but there is no uncorrupted partnered instance of H, or
(2) an uncorrupted instance of H accepts but there is no uncorrupted partnered instance of M, or
(3) uncorrupted partnered instances of M and H accept without holding the same session end-to-end key
(4) F is uncorrupted and uncorrupted partnered instances of M and H accept without holding the same
KM,H, or
Π
session tunnel key Kt.
The maximum probability of this event over all adversaries (running in time κ) is denoted
Succma-m-h
Π
(A, κ) = maxA | Pr[A wins in Gamema-m-h
Π
(A, κ)]|.
Π provides mutual authentication between M and H if this probability is negligible in κ.
Our next Deﬁnition 3 aims to deﬁne similar goals with respect to the instances of F and H: in
particular the mutual authentication requirement (conditions 1 and 2), and the requirement related to
the agreement on the tunnel key Kt (condition 3). Note that the mutual authentication between F and
H does not depend on the honesty of M that can be corrupted by A. Similar to the previous deﬁnition
M, F, and H are treated as honest with respect to the agreement on Kt.
Deﬁnition 3 (MA between F and H). Given a correct protocol Π by Gamema-f-h
(A, κ) we denote
the interaction between the instances of M, F and H with a PPT adversary A that is allowed to query
Invoke, Send, Corrupt, RevealKey, and RevealTunnelKey. A wins if at some point during the interaction:
Π
8
M. Manulis, D. Leroy, F. Koeune, O. Bonaventure, and J.-J. Quisquater
(1) an uncorrupted instance of F accepts but there is no uncorrupted partnered instance of H, or
(2) an uncorrupted instance of H accepts but there is no uncorrupted partnered instance of F, or
(3) M is uncorrupted and uncorrupted partnered instances of F and H accept without holding the same
session tunnel key Kt.
The maximum probability of this event over all adversaries (running in time κ) is denoted
Succma-f-h
Π
(A, κ) = maxA | Pr[A wins in Gamema-f-h
Π
(A, κ)]|.
Π provides mutual authentication between F and H if this probability is negligible in κ.
Here, we provide some observations concerning Deﬁnitions 2 and 3 with respect to the authorization
issues. Recall, that according to our model instances of protocol participants are seen as partnered if they
hold the same session ids. This implies that any protocol Π which satisﬁes both of the above deﬁned
mutual authentication requirements ensures that if an uncorrupted instance of H accepts then there are
uncorrupted instances of M and F that are also partnered. That is the decision of H to accept in some
session of Π implies that H treats M and F as authorized participants of a WRT session. Since our model
does not consider malicious M, F, or H aiming to disrupt the agreement on Kt the above mentioned
“transitive” partnering between the instances of M and F ensures that all partnered instances that accept
in some protocol session hold the same session tunnel key Kt.
In the following we focus on the secrecy of KM,H and Kt. For this, we make use of the classical notion
of authenticated key exchange (AKE) security (cf. [13, 21, 22]), adopted to the setting of our model. The
basic idea of AKE-security in WRT is to model the indistinguishability of KM,H and Kt computed in
some test session from some randomly chosen values by any outsider adversary. The signiﬁcant diﬀerence
is that for KM,H a possibly malicious foreign network F should be also treated as such adversary.
In order to model the AKE-security of the end-to-end key KM,H we ﬁrst specify the auxiliary notion
of e2e-freshness for the instances of M and H, which deﬁnes the conditions under which A can be treated
as an outsider with respect to the test session for which it has to distinguish KM,H. In particular, these
conditions prevent active participation of A on behalf of either M or H by restricting A from respective
corruptions, and capture known-key attacks allowing A to reveal end-to-end keys computed in sessions
that are diﬀerent from the test session. Moreover, A is not restricted from revealing Kt. That is the
knowledge of Kt (e.g., by F) should not compromise the end-to-end communication security between M
and H.
Deﬁnition 4 (e2e-Freshness). In the execution of Π an instance [P, s] with P ∈ {M,H} is e2e-fresh
if none of the following holds:
– A asks Corrupt(P );
– Case P = M: A asks RevealKey(M, s) after [M, s] has accepted or RevealKey(H, t) after [H, t] has
– Case P = H: A asks RevealKey(H, s) after [H, s] has accepted or RevealKey(M, t) after [M, t] has
accepted and [M, s] and [H, t] are partnered;
accepted and [H, s] and [M, t] are partnered.
In order to model the AKE-security of the tunnel key Kt we specify the auxiliary notion of t-freshness,
this time for the instances of M, F, and H, which deﬁnes the conditions under which A can be treated
as an outsider with respect to the test session for which it has to distinguish Kt. These conditions are
widely similar to those deﬁned for the e2e-freshness except that A is now allowed to reveal tunnel keys
computed in sessions that are diﬀerent from the test session, and is not restricted from revealing KM,H.
Deﬁnition 5 (t-Freshness). In the execution of Π an instance [P, s] with P ∈ {M,F,H} is t-fresh if
none of the following holds:
– A asks Corrupt(P );
– Case P = M: A asks RevealTunnelKey(M, s) after [M, s] has accepted or RevealTunnelKey(P (cid:48), t) for
P (cid:48) ∈ {H,F} after [P (cid:48), t] has accepted and [M, s] and [P (cid:48), t] are partnered;
Authenticated Wireless Roaming via Tunnels: Making Mobile Feel at Home
9
– Case P = F: A asks RevealTunnelKey(F, s) after [F, s] has accepted or RevealTunnelKey(P (cid:48), t) for
– Case P = H: A asks RevealTunnelKey(H, s) after [H, s] has accepted or RevealTunnelKey(P (cid:48), t) for
P (cid:48) ∈ {M,H} after [P (cid:48), t] has accepted and [F, s] and [P (cid:48), t] are partnered;
P (cid:48) ∈ {M,F} after [P (cid:48), t] has accepted and [H, s] and [P (cid:48), t] are partnered.
Further, we introduce two additional queries TestKey(P, s) and TestTunnelKey(P, s). The query TestKey(P, s)
can be asked to an instance of P ∈ {M,H} and is answered only if the instance [P, s] has already ac-
cepted. The answer of this query is based on some secret bit b ∈ {0, 1} chosen in advance. In response to
TestKey(P, s) A is given either KM,H (if b = 1) or a randomly chosen value from {0, 1}κ (if b = 0). The only
diﬀerence between TestKey(P, s) and TestTunnelKey(P, s) is that for the latter we assume P ∈ {M,F,H}
and the key which is returned in the case that bit b = 1 is the tunnel key Kt.
Now we are ready to formally deﬁne AKE-security for the end-to-end and tunnel keys computed in
Π. Using the auxiliary deﬁnitions of e2e- and t-freshness we can provide one deﬁnition for both goals.