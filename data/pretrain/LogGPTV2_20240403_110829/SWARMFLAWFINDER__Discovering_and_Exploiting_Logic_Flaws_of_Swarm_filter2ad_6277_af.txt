//www.darpa.mil/work-with-us/offensive-swarm-enabled-tactics.
Are
[84] D.
[83] DARPAtv, “Teams Test Swarm Autonomy in Second Major OFF-
SET Field Experiment,” 2019, https://www.youtube.com/watch?v=
ruWC10AW87E.
Hambling,
Every
Does
https://www.forbes.com/sites/davidhambling/2021/03/01/
what-are-drone-swarms-and-why-does-everyone-suddenly-want-one/
?sh=2a5f085d2f5c.
And Why
2021,
Suddenly Want
“What
Military
Swarms
One?”
Drone
[85] K. N. McGuire, C. De Wagter, K. Tuyls, H. J. Kappen, and G. C. H. E.
de Croon, “Minimal navigation solution for a swarm of tiny ﬂying robots
to explore an unknown environment,” 2019.
[86] T. Delft, “SGBA-code,” 2020, https://github.com/tudelft/SGBA code
SR 2019.
A. Algorithm Selection
IX. APPENDIX
1) Selection Criteria: As shown in Fig. 13- 1 , we exhaus-
tively search all publicly accessible swarm algorithms (i.e., 46
algorithms in the second row, 2 ) and select the reproducible
ones (i.e., 26 algorithms in the third row, 3 ).
Fig. 13. Algorithm Selection Process
Not Executable Algorithms. During the process, we en-
counter 20 swarm algorithms that are not executable due
to various reasons, including compilation errors (e.g., miss-
ing libraries/packages), runtime errors, and missing modules.
Summary of errors for each algorithm can be found in [8].
Algorithms lacking Swarm Behaviors. We further inspect the
26 executable algorithms and prune out 22 algorithms lacking
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:38:51 UTC from IEEE Xplore.  Restrictions apply. 
151822
1727292026224from 44Academic Papersfrom 29 GitHub RepositoriesWithout Source CodeNot executable (NE)Lacking swarm behaviorsSelected46 Algo. with Source Code26 Executable Algo.73Academic Papers and Public GitHub Repos146 Swarm Algorithms226 Executable Algorithms3swarm behaviors. Speciﬁcally, 21 algorithms do not exhibit
communications between drones in the swarm, meaning that
a drone will consider other drones as merely an external
object to avoid. 16 algorithms do not allow us to introduce
external attack drones; hence we prune out them. 2 algorithms
are immature, meaning that they fail on provided example
missions without any interventions. We focus on algorithms
that at least can ﬁnish simple missions without errors. We
further elaborate on the details of our analysis on [8].
Sizes of the Algorithms. Fig. 14 shows the SLOC of all
the considered swarm algorithms’ source code size in lines
of code. We count the SLOC of swarm algorithms, excluding
ﬁles for installations and conﬁgurations. It shows the selected
algorithms’ sizes are comparable to others and representative.
Commercial Swarm Algorithms. The reason that we do not
have commercial swarm algorithms in our evaluation is that
they are not publicly available for us to run. We comment that
one of our selected swarm algorithms’ authors mention that
their recent version of the swarm algorithm is not publicly
accessible due to legal issues. We could not investigate the
details of those legal issues, but we believe that their codebase
might be used in a proprietary product.
Fig. 14. SLOC of Considered and Selected Algorithms. Avg. of A1-4: 3,919
lines, Executable: 1,968 lines, and Not Executable: 2,305 lines.
2) Representativeness with respect to Real-world Examples:
We believe our selection of the algorithms is comparable to
the commercial algorithms because the four selected algo-
rithms can conduct complex swarm scenarios that commercial
swarms target. Speciﬁcally, we compare our selected algo-
rithms with other publicly known swarm projects to understand
the representativeness of our selection. In particular, DARPA’s
OFFSET program [82] conducted swarm missions aligned
with our selected swarm algorithms: searching missions in ur-
ban/rural areas [83]. While the source code of their algorithms
is not available, from the materials provided by DARPA, our
algorithms A2 and A3 are comparable. Also, the column from
Forbes [84] introduces the Reynolds’ Boids model as the
theoretical base for the modern military’s swarm operation.
A3 is comparable as it uses the same ﬂocking model. Another
popular swarm searching project by TU Delft [85] releases its
source code [86]. We compare it with our algorithms, and it
is smaller than A1, A2, and A3. Moreover, we believe that
an up-to-date version of A4 [7] might be used in proprietary
products, while the authors choose not to reveal the details.
B. Observed Unique DCC Values
Fig. 15 shows the number of newly observed DCC values
over 12 hours of testing. Observe that most new DCC values
are discovered in the ﬁrst 8-9 hours, showing the effectiveness
of DCC guided testing and justifying our 24 hours of timeout.
Fig. 15. Observed unique DCC values during testing over time
C. Random Testing Approach vs SWARMFLAWFINDER
In § V-C, we created a random testing approach by remov-
ing the DCC guidance from SWARMFLAWFINDER. We use
the random testing approach to understand which components
of SWARMFLAWFINDER make our approach more effective.
1) Effectiveness in Finding Mission Failures: Finding
mission failures during testing is critical since they can
lead to logic ﬂaws of the algorithms. Fig. 16 shows the
number of tests leading to mission failures executed by
SWARMFLAWFINDER and a random testing approach (i.e.,
SWARMFLAWFINDER without the DCC guidance). Observe
that SWARMFLAWFINDER covers more test cases leading
to mission failures. Note that
the total number of tested
missions is similar between the random testing and SWARM-
FLAWFINDER, because it depends on the execution time of
each test case.
Fig. 16. Effective test cases (i.e., failures) from the random testing approach
and SWARMFLAWFINDER
2) Impact of Searching Space on Random Testing Ap-
proach: SWARMFLAWFINDER’s DCC based guided fuzz test-
ing prioritizes test cases generated in an area that can lead
to more unique DCC values (or exercise diverse swarm be-
haviors). In this experiment, we aim to understand the impor-
tance of ﬁnding the searching space in SWARMFLAWFINDER.
Speciﬁcally, we run the random testing approach (which is
essentially SWARMFLAWFINDER without DCC guided test-
ing) with different searching space restrictions, obtained by
SWARMFLAWFINDER. Note that except for the searching
spaces, we keep the original conﬁgurations described in
§ V-A2. We deﬁne three different searching spaces for each
algorithm. First, we run SWARMFLAWFINDER and obtain
the explored space by SWARMFLAWFINDER as shown in
Fig. 17-(a), considering it the baseline space. Second, from
the baseline space, we deﬁne 2x and 3x Base (Fig. 17-(b) and
(c)) by extending the radius of the baseline by 2 and 3 times.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:38:51 UTC from IEEE Xplore.  Restrictions apply. 
161823
025005000750010000A1~4Exec.N. Exec.025005000750010000A1~4Exec.N. Exec.1234123456789101112131415161718192021221234567891011121314151617181920SelectedExecutableNot executable10,0007,5005,0002,500001020304050123456789101112New Unique Dcc ValuesElapsed Time (Hours)A1A2A3A478661430023976461569655418332069275322836427741102004006008001000SwarmFlawFinderRandomSwarmFlawFinderRandomSwarmFlawFinderRandomSwarmFlawFinderRandomA4A3A2A1FailSuccessSWARMFLAWFINDER VS RANDOM TESTING, WITH RESPECT TO
DIFFERENT SEARCHING SUBSPACE RESTRICTIONS.
TABLE IV
ID Root
Cause
SWARMFLAWFINDER
No Restrict.
# Exe.
Uq.
Random Testing Approach
No Restrict.
# Exe. Uq.
Base
2x Base
3x Base
# Exe. Uq.
# Exe. Uq.
# Exe. Uq.
Crash btw.
Drones
C1-1
C1-2
C1-3
Crash into
ext. objects
C1-1
C1-2
C1-3
C1-4
Suspended
progress
C1-5
C1-6
Slow
progress
C1-6
Total:
Crash btw.
Drones
C2-1
Suspended
progress
C2-2
Slow
progress
C2-3
C2-4
Total:
Crash into
ext. objects
C3-1
C3-2
Slow
progress
C3-1
C3-2
Total:
Crash btw.
Drones
C4-1
C4-2
Crash into
ext. objects
C4-1
C4-2
Slow
progress
C4-3
Total:
A1
A2
A3
A4
273
86
176
11
435
88
326
3
18
671
242
429
175
175
1,554
28
28
119
119
608
586
22
755
47
10
37
240
23
217
287
230
216
14
630
599
31
1,228
1,228
2,088
9
4
4
1
8
3
3
1
1
2
1
1
1
1
20
3
3
1
1
4
3
1
8
2
1
1
4
2
2
6
3
1
2
3
1
2
2
2
8
166
49
117
0
359
89
270
0
0
594
183
411
163
163
1,282
20
20
99
99
415
415
0
534
50
0
50
182
16
166
232
210
210
0
411
411
0
887
887
1,508
4
3
1
0
5
3
2
0
0
2
1
1
1
1
12
1
1
1
1
2
2
0
4
1
0
1
2
1
1
3
1
1
0
1
1
0
2
2
4
251