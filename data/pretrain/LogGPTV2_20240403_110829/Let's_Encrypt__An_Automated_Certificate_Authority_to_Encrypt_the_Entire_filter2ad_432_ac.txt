Certificate revocation. ACME provides a mechanism for revoca-
tion of a certificate to be requested by any of the following parties:
(1) The account that caused the certificate to be issued;
(2) Any other account that can prove control of the identifiers
in the certificate; or
(3) Anyone who can prove control of the private key correspond-
ing to the public key in the certificate.
Figure 2: ACME protocol. This diagram illustrates how an ACME client
can obtain a certificate without human interaction. In the dashed region,
the client proves ownership of the domain using an HTTP-based challenge.
The last case is an especially important innovation over prior pro-
tocols, since it allows a good Samaritan who encounters a leaked
key to request automated revocation of corresponding certificates.
4.2 Validation Methods
The ACME challenge mechanism for identifier validation is exten-
sible so that new validation mechanisms can be added over time
and so that CAs can implement their own mechanisms. (Acceptable
methods for the Web PKI are defined in the CA/Browser Forum’s
Baseline Requirements [28].) There are currently three specified
challenge types, all of which are supported by Let’s Encrypt:
(1) The HTTP challenge requires the applicant to serve an ob-
ject containing a CA-provided random value at a specific
HTTP URL at the domain. The CA makes GET requests for
the URL and verifies that the correct object is returned.
(2) The DNS challenge requires the applicant to provision a
DNS record at _acme-challenge. containing a
CA-provided random value. The CA fetches this record and
verifies that its content is correct.
(3) The TLS-ALPN challenge requires the applicant to config-
ure a TLS server to respond to a TLS ClientHello message
containing a specific ALPN value and an ACME-specific TLS
extension [42, 87]. The TLS server must then present a self-
signed certificate containing a CA-provided random value
and correctly complete the TLS handshake.
These three mechanisms allow ACME to be integrated into a
variety of operational environments. For example, the HTTP chal-
lenge is easy to deploy on domains that have single Web servers,
but it requires the response to be provisioned across all servers in
load-balanced configurations. The TLS-ALPN challenge allows for
certificate management to be done by a TLS entity with no HTTP
logic of its own, e.g., by a TLS-terminating load balancer.
The various challenge types offer slightly different levels of as-
surance, and it is up to CAs to decide which are appropriate in a
given situation. Let’s Encrypt, for example, only allows a wildcard
certificate to be issued if the applicant has proven control with
the DNS challenge, since this challenge type proves direct control
Requesting ClientCA1. Client registers, provides public keyFor each identifier in the order:2. Client sends certificate order, provides list of identifiers (e.g. domains) to include in certificate5. Client selects the HTTP challenge, creates file containing token and hosts it at ./well-known/acme-challenge/When all identifiers verified:4. CA sends token and list of challenges client can complete to prove ownership of identifier6. Client informs CA that challenge complete8. Client sends PKCS 10 Certificate Signing Request9. CA issues certificate7. CA verifies that file is reachable3. CA generates random tokenSession 10E: CertificatesCCS ’19, November 11–15, 2019, London, United Kingdom2477over the DNS zone in question (and such control could be used to
provision arbitrary subdomains and obtain certificates for them).
In the 90 days preceding September 22, 2019, Let’s Encrypt com-
pleted 266M successful challenges with ACME clients. Of these,
86% used HTTP, 13% used DNS, and 0.3% used TLS-ALPN.
4.3 Security Improvements
While ACMEv1 and ACMEv2 share many attributes, several sig-
nificant changes were made in ACMEv2 in response to security
analyses performed during the IETF standardization process.
Bhargavan et al. formally verified the security of ACME [24].
They modeled the protocol in the applied pi calculus and demon-
strated its security in an even more robust threat model than the
one addressed by traditional CAs’ issuance processes. However,
their work also uncovered weaknesses involving some subtle au-
thentication properties. ACMEv2 incorporates improvements based
on their recommendations.
IETF security review also highlighted some areas for privacy
improvements Most notably, all GET requests (which lacked any
authentication) were replaced with authenticated POST requests,
so that CAs can apply appropriate authorization policies.
ACME validation methods have also evolved in response to se-
curity findings. In general, all validation methods that rely on em-
pirical validation of control (as all of the above do) are vulnerable
to network-layer attacks on the validation process, such as BGP
hijacking to reroute validation requests [25, 26, 84]. The ACME RFC
discusses these risks in detail, and suggests some mitigations [20].
However, validation methods face a range of other, often subtle
threats due to the diversity of server and hosting-provider behavior.
During ACME’s development, two additional challenges types were
proposed (one of which was deployed by Let’s Encrypt), but they
were found to be insecure in common shared-hosting environments:
HTTPS-based HTTP challenge. Initially, HTTP challenges were
allowed to be completed on port 80 (over HTTP) or port 443 (over
HTTPS). In 2015, Kasten and Eckersley noted that Apache would
serve the first HTTPS site defined in its configuration file if the
requested domain did not have HTTPS enabled. In other words, if
the same Apache instance served both site1.com and site2.com
but only site2.com supported HTTPS, all HTTPS requests to the
server—regardless of whether the client requested site1.com or
site2.com—would be served with content from site2.com. In
shared-hosting environments, this behavior could allow an attacker
to acquire certificates for domains they did not control. In response,
the HTTP challenge type was changed to prohibit HTTPS requests.
TLS-SNI challenge. In early 2018, Franz Rosén found that the
TLS-SNI challenge supported by Let’s Encrypt did not provide suffi-
cient authentication in many shared-hosting environments [5, 81].
This challenge validated domain control by requiring the applicant
to configure a TLS server at the domain to host a specific chal-
lenge certificate. This certificate had to contain a subject alternative
name (SAN) with a CA-specified random value as a subdomain
of .acme.invalid. The server was required to respond with the
certificate if the subdomain was queried using the Server Name
Indication (SNI) extension [38] in the TLS handshake.
The challenge design incorrectly assumed that hosting providers
prevent clients from uploading certificates for domains they do not
own (including .invalid domains). After Rosén demonstrated that
this was often not the case, Let’s Encrypt immediately disabled
the challenge, then re-enabled it for a small set of whitelisted non-
vulnerable providers. Let’s Encrypt eventually phased it out and
replaced it with the TLS-ALPN challenge described above, which
represents the result of security lessons learned from this process.
5 CA SOFTWARE AND OPERATIONS
When we started to develop Let’s Encrypt, available CA software
was designed around the manual processes that CAs typically fol-
lowed. ACME, with its focus on automation, differs substantially
from these human-oriented workflows, and we needed to build
entirely different software to operate an automated CA. We created
Boulder, a new, open-source CA software stack that forms the core
of Let’s Encrypt’s operations.
5.1 Security Principles
Let’s Encrypt must achieve high security and availability in order
to remain trustworthy and fulfill its role as Internet infrastruc-
ture. Both Boulder and the CA’s operations reflect a set of design
principles that support these goals:
Minimal logic. Boulder implements the minimal logic necessary
to instantiate an ACME-based CA, in order to make it easier for
developers and auditors to verify the correctness of the code. Boul-
der is implemented in a relatively high-level language, with struc-
tured intercomponent communications (Go and gRPC, respectively),
which further increase the comprehensibility of the code.
Minimal data. To reduce the potential harm from data breaches,
Let’s Encrypt collects only the minimum subscriber data necessary
to deliver the service in compliance with ACME and WebTrust [103]
requirements: a public key, an optional contact email address, and
various access logs [64].
Full automation. The system has a single issuance path, based
on ACME, with no facility for human operators to manually create
certificates or make one-off policy exceptions. Locking out humans
prevents errors that have led to misissuance by other CAs [80].
Functional isolation. Boulder is composed of limited-purpose
components that communicate only through well-defined APIs.
Components with different risk levels are physically isolated from
one another. This reduces the risk that compromise of more ex-
posed components (e.g., the Internet-facing front end) will lead to
compromise of more critical components (e.g., CA signing keys).
Operational isolation. To limit risk of physical compromise, ac-
cess to Let’s Encrypt data centers is strictly limited, even for our
staff. Most administration is performed remotely, with engineers
only entering the data centers to complete tasks that require physi-
cal access to hardware. Remote administration tasks are protected
by multifactor authentication and strong monitoring. Staff with
administrative access can only access administration functions
via dedicated, restricted virtual machine environments within a
security-focused operating system running on specific laptops.
Continuous availability. Boulder’s componentized architecture
allows multiple redundant instances of each function to be run
in parallel. Let’s Encrypt operates Boulder instances in physically
Session 10E: CertificatesCCS ’19, November 11–15, 2019, London, United Kingdom2478Figure 3: Boulder architecture. Let’s Encrypt developed and operates a Go-based open-source CA software platform named Boulder, which is composed of
single-purpose components that communicate over gRPC, as illustrated here. The certificate lifecycle unfolds roughly from left to right in the diagram.
secure, geographically distributed facilities, and divides production
traffic between datacenters, with load balancing handled by a CDN.
In addition, security audits by outside firms are regularly com-
missioned. Physical access to core CA equipment, all HSM adminis-
trative operations, and certain other functions require multiple staff
members to present authentication. For most other administrative
operations, including software deployments, logging and monitor-
ing systems provide strong accountability. These protections help
ensure that a rogue engineer would have difficulty stealing a sign-
ing key, and although they might be able to cause misissuance, they
would likely be caught after the fact.
To reduce the chances that bugs in Boulder could lead to misis-
suance or other problems, new versions are tested in a public stag-
ing environment prior to entering production. Boulder also applies
ZLint [58] to perform automated conformance tests on every cer-
tificate, and any ZLint notices, warnings, or errors block issuance.
5.2 System Architecture
Boulder implements the three main functions required of a CA in
the modern Web PKI:
(1) Issuance of certificates (via ACME);
(2) Submission of precertificates and certificates to Certificate
Transparency (CT) logs [62]; and
(3) Publication of certificate revocation status via OCSP.
Figure 3 illustrates Boulder’s components and their interactions.
All instances of a given Boulder component run independently.
For example, Let’s Encrypt runs four instances of the Certificate
Authority component, each of which can sign certificates and OCSP
responses without communication with the other three instances.
ACME clients communicate with Let’s Encrypt exclusively via
the ACME API component, which validates client requests and re-
lays them to the Registration Authority (RA). The RA orchestrates
the authorization and issuance process. For example, when a client
responds to an ACME challenge, the RA instructs the Validation Au-
thority to validate that the client has completed the challenge. Once
the RA has verified that the client has sufficient authorization to
issue a requested certificate, it instructs the Certificate Authority to
issue a precertificate, which is submitted to CT logs by the Publisher.
When a CT log provides a Signed Certificate Timestamp (SCT), the
RA instructs the Certificate Authority to issue the certificate and
makes it available to the client.
Each Certificate Authority has access to a hardware security
module (HSM) that stores the private key corresponding to one of
the Let’s Encrypt intermediate certificates. The private key corre-
sponding to the ISRG root certificate is held in a separate, offline
HSM. The online HSMs also hold a private key corresponding to
an OCSP signer certificate, used to sign OCSP responses. As of
September 2019, Let’s Encrypt HSMs perform approximately 450
signatures per second, with the bulk of this work going towards
OCSP responses and the remainder towards signing certificates.
OCSP responses are computed proactively, asynchronously from
OCSP requests. The OCSP Updater monitors for new certificates or
newly revoked certificates, and instructs the Certificate Authority
to sign appropriate OCSP responses. As these responses expire,
the OCSP Updater issues fresh ones, until the certificate expires.
All of these OCSP responses are stored in a database, from which
the OCSP Responder answers OCSP requests. OCSP responses are
served and cached via Akamai, allowing Let’s Encrypt to keep up
with OCSP traffic even for very popular sites.
The architecture described here has allowed Let’s Encrypt to
scale up to issuing more than a million certificates per day at peak,
running on modest infrastructure. The biggest scalability challenge
has not been compute power or signing capacity, but rather the
growth of the primary CA database and of log data. As of September
2019, Let’s Encrypt produces about 150 GB of CA log data per day.
All of this log data is kept online and searchable for 90 days (the life-
time of certificates), and, in compliance with WebTrust audit require-
ments, a subset is archived offline for a minimum of seven years.
6 CLIENT ECOSYSTEM
There is no official client for Let’s Encrypt. Instead, by standardizing
ACME, the project has fostered an ecosystem of third-party clients
that support a wide range of platforms and use cases [65]. ACME
client libraries are available in a variety of languages, including
C, Go, and Java. There are a range of command-line clients, such
as acme.sh and Certbot, as well as server software with built-in
CustomersRegister account; request, renew, and revoke certiﬁcates; prove control over identiﬁersCT LogsMaintain public, append-only log of certiﬁcates; issue SCTs that promise that a certiﬁcate will be included in the logRelying PartiesAsk for revocation status of certiﬁcatesACME APIReceive and validate all customer requestsValidation AuthorityVeriﬁes challenges for client identiﬁersPublisherUploads certiﬁcates and precertiﬁcates to logs; receives SCTs for submitted precertiﬁcatesOCSP ResponderReplies to OCSP requestsOCSP UpdaterReplies to OCSP requestsRegistration AuthorityHandles account registration; manages identiﬁer validation, certiﬁcate requests, SCTs for precertiﬁcates, revocation requests Certiﬁcate AuthoritySigns certiﬁcates and OCSP responsesHSMStorage AuthorityManages database of certiﬁcates, logs, and other records(All components connected; lines omitted)Internet-FacingInternalCA EnclaveSession 10E: CertificatesCCS ’19, November 11–15, 2019, London, United Kingdom2479provisioning, such as Caddy, Apache, and cPanel. Shared hosting
providers, including Squarespace, Google, and OVH, also use Let’s
Encrypt to transparently provision HTTPS. In this section, we
survey some of the noteworthy clients and gauge their popularity.
6.1 Certbot
In conjunction with Let’s Encrypt’s launch, the Electronic Frontier
Foundation (EFF) created an ACME client, now named Certbot [40].
Unlike most other clients, Certbot aims to fully automate secure
HTTPS deployment, rather than simply procuring a certificate.
Certbot currently is the most popular client in terms of unique IP
addresses. During the time period we studied, 50% of clients (by
unique IP address) used Certbot, and about 16% of certificates were
requested using it, as shown in Table 2. This suggests that Certbot
is particularly popular with operators of individual servers.
Certbot automatically parses and modifies configuration files
for popular Web servers, including Apache and Nginx. This lets
Certbot automate complicated HTTPS configuration steps that have
historically confused administrators [36, 107] and contributed to
TLS vulnerabilities (e.g., [11, 17, 23]). Furthermore, Certbot updates
can automatically patch server configurations to apply new security
configuration recommendations or mitigate newfound attacks.
Certbot’s extensible Python-based framework supports a va-
riety of Web servers and validation types. Authenticator plugins