different payload sent by an epoch leader are considered an equiv-
ocation. In this protocol, the leader of an epoch ğ‘’ sends propose
5
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3506and vote-cert messages (explained later) to all other nodes. In or-
der to facilitate efficient equivocation checks, the leader sends the
payload along with the signed hash of the payload. When an equiv-
ocation is detected, broadcasting the signed hash suffices to prove
equivocation by ğ¿ğ‘’.
3.1 Protocol Details
We first describe a simple function that is used by an honest node
to forward a long message received from the epoch leader.
Deliver function. The Deliver() function (refer Figure 2) imple-
ments efficient broadcast of long messages using erasure coding
techniques and cryptographic accumulators. The input parameters
to the function are message type mtype, long message ğ‘, accumu-
lation value ğ‘§ğ‘’ corresponding to object ğ‘ and epoch ğ‘’ in which
the Deliver function is invoked. The input message type mtype
corresponds to message type containing large message ğ‘ sent by
leader ğ¿ğ‘’ of epoch ğ‘’. In order to facilitate efficient leader equiv-
ocation checks, the input message type mtype, hash of object ğ‘,
accumulation value ğ‘§ğ‘’ and epoch ğ‘’ are signed by leader ğ¿ğ‘’.
When the function is invoked using the above input parameters,
the message ğ‘ is partitioned into ğ‘¡ + 1 data symbols. The ğ‘¡ + 1 data
symbols are then encoded into ğ‘› code words (ğ‘ 1, . . . , ğ‘ ğ‘›) using ENC
function (defined in Section 2). Then, the cryptographic witness
ğ‘¤ğ‘– is computed for each code words (ğ‘ 1, . . . , ğ‘ ğ‘›) using CreateWit
(defined in Section 2). Then, the code word and witness pair (ğ‘  ğ‘— , ğ‘¤ ğ‘—)
is sent to the node ğ‘ ğ‘— âˆˆ P along with the accumulation value ğ‘§ğ‘’,
message type mtype, and ğ¿ğ‘’â€™s signature on the message.
When a node ğ‘ ğ‘— receives the first valid code word ğ‘  ğ‘— for an
accumulation value ğ‘§ğ‘’ such that the witness ğ‘¤ ğ‘— verifies the code
word ğ‘  ğ‘— (using Verify function defined in Section 2), it forwards the
code word and witness pair (ğ‘  ğ‘— , ğ‘¤ ğ‘—) to all nodes. Note that node ğ‘ ğ‘—
forwards only the first code word and witness pair (ğ‘  ğ‘— , ğ‘¤ ğ‘—). Thus, it
is required that all honest nodes forward the code word and witness
pair (ğ‘  ğ‘— , ğ‘¤ ğ‘—) for long message ğ‘; otherwise all honest nodes may
not receive ğ‘¡ + 1 code words for ğ‘. When a node ğ‘ğ‘– receives ğ‘¡ + 1
valid code words corresponding to the first accumulation value ğ‘§ğ‘’ it
receives, it reconstructs the object ğ‘. Note that node ğ‘ğ‘– reconstructs
object ğ‘ for the first valid share even though it detects equivocation
in an epoch.
The Deliver function contains two communication steps and
hence requires 2Î” time to ensure all honest nodes can receive at
least ğ‘¡ + 1 code words sufficient to reconstruct the original input ğ‘.
Invoking Deliver on a long message of size â„“ incurs ğ‘‚(ğ‘›â„“+(ğœ…+ğ‘¤)ğ‘›2)
bits where ğœ… is the size of accumulator and ğ‘¤ is the size of the
accumulator witness. The witness size is ğ‘‚(ğœ…) and ğ‘‚(ğœ… log ğ‘›) when
bilinear accumulators and Merkle trees are respectively used as
witnesses. Thus, the total communication complexity to broadcast
a single message of size â„“ is ğ‘‚(ğ‘›â„“ + ğœ…ğ‘›2) bits, or ğ‘‚(ğ‘›â„“ + ğœ…ğ‘›2 log ğ‘›)
bits without the ğ‘-SDH assumption.
BFT SMR Protocol. Our BFT SMR protocol is described in Figure 1.
Consider an epoch ğ‘’ and its epoch leader ğ¿ğ‘’. To ensure an honest
leader can always make progress, leader ğ¿ğ‘’ first collects the highest
ranked certificate Cğ‘’â€²(ğµâ„) from all honest nodes. In each epoch, at
a high level, there are two â€œroundsâ€ of communication from the
epoch leader. The first round involves leader making a proposal and
6
the second round involves sending certificates to aid in committing
the proposal.
Efficient propagation of proposal. In the first round, the leader
proposes a block ğµâ„ to every node (step 2) by extending the high-
est ranked certificate Cğ‘’â€²(ğµâ„). The proposal for ğµâ„, conceptually,
has the form âŸ¨propose, ğµâ„, Cğ‘’â€²(ğµğ‘™), ğ‘§ğ‘ğ‘’, ğ‘’âŸ©ğ¿ğ‘’ where ğ‘§ğ‘ğ‘’ is the ac-
cumulation value for the pair (ğµâ„, Cğ‘’â€²(ğµğ‘™)). In order to facilitate
efficient equivocation checks, the leader signs the following tu-
ple âŸ¨propose, ğ»(ğµâ„, Cğ‘’â€²(ğµğ‘™)), ğ‘§ğ‘ğ‘’, ğ‘’âŸ© and sends ğµâ„ and Cğ‘’â€²(ğµğ‘™) sep-
arately. The size of this signed message is ğ‘‚(ğœ…) bits. In case of
equivocation, all-to-all broadcast of this signed message incur only
ğ‘‚(ğœ…ğ‘›2) in communication.
If the received proposal is valid and it extends the highest ranked
certificate known to a node ğ‘ğ‘–, node ğ‘ğ‘– forwards the proposal.
Forwarding the received proposal is required to ensure all honest
nodes receive a common proposal; otherwise only a subset of the
nodes may receive the proposal if the leader is Byzantine. Observe
that the size of the proposal is linear as it contains certificate Cğ‘’â€²(ğµğ‘™)
(which is linear in the absence of threshold signatures). A naÃ¯ve
approach of forwarding the entire proposal incurs ğ‘‚(ğœ…ğ‘›3) when
all nodes broadcast their proposal. In order to save communication,
nodes forward the proposal by invoking Deliver function. For linear
sized proposal, invoking Deliver incurs ğ‘‚(ğœ…ğ‘›2) bits (or ğ‘‚(ğœ…ğ‘›2 log ğ‘›)
bits under ğ‘-SDH assumption) in communication.
Observe that the Deliver primitive requires 2Î” time. In particular,
we need to ensure all honest nodes forward their code word and
witness pair for the proposal. Thus, our protocol waits for 2Î” time
(i.e., vote-timerğ‘’) before voting to check for equivocation. Hence, if
no equivocation is detected at the end of 2Î” wait, all honest nodes
forwarded their code word and witness pair for the proposal and all
honest nodes can reconstruct the proposal. At the end of 2Î” wait,
if there no equivocation is detected, nodes vote for the proposed
block ğµâ„ (step 3).
Ensuring the receipt of a certificate efficiently. Observe that
a vote message is ğ‘‚(ğœ…) sized and hence, it can be broadcast us-
ing all-to-all communication with communication complexity of
ğ‘‚(ğœ…ğ‘›2). However, if every node that commits needs to ensure that
all honest nodes receive a certificate for the block being committed,
this can result in ğ‘‚(ğœ…ğ‘›3) complexity again. This is because, all-to-
all broadcast of linear sized certificate incurs ğ‘‚(ğœ…ğ‘›3). One might
try to invoke Deliver to propagate the certificate. However, this
does not save communication. This is because, in general, there can
be exponentially many combinations of ğ‘¡ + 1 signatures forming
a certificate depending on the set of signers, and each node may
invoke Deliver on a different combination.
This issue can be addressed if we ensure that there is a single
certificate for a block. Hence, we use the leader to collect signatures
and form a single certificate (step 3). The leader forwards this cer-
tificate via âŸ¨vote-cert, Cğ‘’(ğµâ„), ğ‘§ğ‘£ğ‘’, ğ‘’âŸ©ğ¿ğ‘’ to all nodes (step 4) where
ğ‘§ğ‘£ğ‘’ is the accumulation value of Cğ‘’(ğµâ„). Similar to the proposal, the
hash of the certificate is signed to allow for efficient equivocation
checks. It is important to note that two different certificates for the
same value is still considered an equivocation in this step.
To ensure that every honest node receives this certificate, we
again resort to the Deliver primitive which yields a communication
complexity of ğ‘‚(ğœ…ğ‘›2) when all honest nodes are invoking it using
the same certificate. Again, to tolerate malicious behaviors such
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3507Let ğ‘’ be the current epoch and ğ¿ğ‘’ be the leader of epoch ğ‘’. For each epoch ğ‘’, node ğ‘ğ‘– performs the following operations:
(1) Epoch advancement. When epoch-timerğ‘’âˆ’1 reaches 0, enter epoch ğ‘’. Upon entering epoch ğ‘’, send the highest ranked certificate Cğ‘’â€² (ğµğ‘™) to ğ¿ğ‘’. Set
epoch-timerğ‘’ to 11Î” and start counting down.
(2) Propose. ğ¿ğ‘’ waits for 2Î” time after entering epoch ğ‘’ and broadcasts âŸ¨propose, ğµâ„, Cğ‘’â€² (ğµğ‘™), ğ‘§ğ‘ğ‘’, ğ‘’âŸ©ğ¿ğ‘’ where ğµâ„ extends ğµğ‘™ . Cğ‘’â€² (ğµğ‘™) is the highest
ranked certificate known to ğ¿ğ‘’.
(3) Vote. If epoch-timerğ‘’ â‰¥ 7Î” and node ğ‘ğ‘– receives the first proposal ğ‘ğ‘’ = âŸ¨propose, ğµâ„, Cğ‘’â€² (ğµğ‘™), ğ‘§ğ‘ğ‘’, ğ‘’âŸ©ğ¿ğ‘’ where ğµâ„ extends a highest ranked certificate,
invoke Deliver(propose, ğ‘ğ‘’, ğ‘§ğ‘ğ‘’, ğ‘’). Set vote-timerğ‘’ to 2Î” and start counting down. When vote-timerğ‘’ reaches 0, send âŸ¨vote, ğ» (ğµâ„), ğ‘’âŸ©ğ‘– to ğ¿ğ‘’.
(4) Vote cert. Upon receiving ğ‘¡ + 1 votes for ğµâ„, ğ¿ğ‘’ broadcasts âŸ¨vote-cert, Cğ‘’ (ğµâ„), ğ‘§ğ‘£ğ‘’, ğ‘’âŸ©ğ¿ğ‘’ .
(5) Commit. If epoch-timerğ‘’ â‰¥ 3Î” and node ğ‘ğ‘– receives the first ğ‘£ğ‘’ = âŸ¨vote-cert, Cğ‘’ (ğµâ„), ğ‘§ğ‘£ğ‘’, ğ‘’âŸ©ğ¿ğ‘’ , invoke Deliver(vote-cert, ğ‘£ğ‘’, ğ‘§ğ‘£ğ‘’, ğ‘’). Set
commit-timerğ‘’ to 2Î” and start counting down. When commit-timerğ‘’ reaches 0, if no equivocation for epoch-ğ‘’ has been detected, commit ğµâ„ and
all its ancestors.
(6) (Non-blocking) Equivocation. Broadcast equivocating hashes signed by ğ¿ğ‘’ and stop performing epoch ğ‘’ operations.
Figure 1: BFT SMR Protocol with ğ‘‚(ğœ…ğ‘›2) bits communication per epoch and optimal resilience
Deliver(mtype, ğ‘, ğ‘§ğ‘’, ğ‘’):
(1) Partition input ğ‘ into ğ‘¡ + 1 data symbols. Encode the ğ‘¡ + 1 data
symbols into ğ‘› code words (ğ‘ 1, . . . , ğ‘ ğ‘›) using ENC function. Com-
pute witness ğ‘¤ğ‘— âˆ€ğ‘  ğ‘— âˆˆ (ğ‘ 1, . . . , ğ‘ ğ‘›) using CreateWit function. Send
âŸ¨codeword, mtype, ğ‘  ğ‘— , ğ‘¤ğ‘— , ğ‘§ğ‘Ÿ , ğ‘ŸâŸ©ğ‘Ÿ to node ğ‘— âˆ€ğ‘— âˆˆ [ğ‘›].
(2) If
receives
valid
âŸ¨codeword, mtype, ğ‘  ğ‘— , ğ‘¤ğ‘— , ğ‘§ğ‘’, ğ‘’âŸ©âˆ—
the code word to all the nodes.
(3) Upon receiving ğ‘¡ + 1 valid code words for the accumulator ğ‘§ğ‘’, decode
ğ‘ using DEC function.
the
for the accumulator ğ‘§ğ‘’,
code word
forward
first
node
ğ‘ ğ‘—
Figure 2: Deliver function
as sending multiple different certificates for the same block (due
to which none of them may be delivered), we treat the vote-cert
message similar to the proposal and perform equivocation checks.
Thus, nodes commit only if they observe no equivocation 2Î” time
after they invoke Deliver (step 5).
Epoch timers. Observe that we set the epoch timer epoch-timerğ‘’
for each epoch ğ‘’ to be 11Î”. This is the maximum time required
for an epoch when the leader is honest and all messages take Î”
time. Similarly, in different steps, we make appropriate checks
w.r.t. epoch-timerğ‘’ to ensure that the protocol is making sufficient
progress within the epoch.
Latency. We note that all honest nodes commit in the same epoch
when the epoch leader is honest. However, when the epoch leader is
Byzantine, only some honest nodes may commit in that epoch. Due
to the round-robin leader selection, there will be at least one honest
leader every ğ‘¡ + 1 epochs and all honest nodes commit common
blocks up to the honest epoch. Thus, our protocol has a worst-case
commit latency of ğ‘¡ + 1 epochs.
Due to space constraints, we present complete proofs in Appen-
dix B.1.
4 RANDOM BEACON PROTOCOLS
In this section, we present two random beacon protocols while tol-
erating ğ‘“ â‰¤ ğ‘¡ < ğ‘›/2 Byzantine faults. The first protocol GRandPiper
outputs a random beacon with ğ‘‚(ğœ…ğ‘›2) communication complexity
always, per beacon output, where ğœ… is the security parameter, guar-
antees bias-resistance, and ğ‘‚(min(ğœ…, ğ‘¡))-absolute unpredictability
against a static adversary, but ğ‘¡ +1-absolute unpredictability against
7
an adaptive adversary. The second protocol BRandPiper outputs
a random beacon with ğ‘‚(ğœ… ğ‘“ ğ‘›2) communication complexity per
output after amortization where ğœ… is the security parameter, and
guarantees bias-resistance and 1-absolute unpredictability. When
the actual number of faults ğ‘“ = ğ‘‚(1), the communication complex-
ity is quadratic.
A key aspect of both of our protocols is their reconfiguration-
friendliness. A protocol is said to be reconfiguration-friendly if it
allows changing protocol parameters such as the scheme and nodes,
without stopping the old instance, and starting a new one. Such
reconfiguration is possible if the setup used for the protocol does
not bind to the system, as such a binding will force a new setup
to change any parameter in the system. This is true, for instance,
when using threshold signatures in a protocol which is used by
many existing permissioned systems [7, 14, 15, 27]. Neither of our
protocols use setups for threshold signatures, but a setup based on
the ğ‘-SDH assumption. This allows for easy reconfiguration.4
4.1 RandPiper â€“ GRandPiper Protocol
Enqueue(Q(ğ¿ğ‘’), ğ‘…ğ‘’)
Share Queue Q(Â·)
Epoch ğ‘’
SMR
ğ‘…ğ‘’
Recon.
Epoch ğ‘’ + 1
SMR
ğ‘…ğ‘’+1
Recon.
Leader ğ¿ğ‘’
Leader ğ¿ğ‘’+1
ğ¿ğ‘’ â‰  ğ¿ğ‘–
âˆ€ğ‘– âˆˆ {ğ‘’ + 1, . . . , ğ‘’ + ğ‘¡}
Dequeue(Q(ğ¿ğ‘’â€²))
Â· Â· Â·
Â· Â· Â·
Epoch ğ‘’â€²
SMR
ğ‘…ğ‘’â€²
Recon.