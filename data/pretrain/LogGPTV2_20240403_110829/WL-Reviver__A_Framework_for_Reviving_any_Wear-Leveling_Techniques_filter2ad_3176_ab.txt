work, named as WL-Reviver, to revive any wear-leveling
schemes on PCM-based memory in the face of failures.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:25:52 UTC from IEEE Xplore.  Restrictions apply. 
II. RELATED WORK
To address PCM’s issue of limited endurance, many
efforts have been made to achieve two objectives. One is
to use additional resources to correct errors, and the second
is to prevent early failures.
Regarding the ﬁrst objective, PCM is more likely to
have permanent stuck-at faults, rather than transient errors,
that can be gradually accumulated over time within the
lifetime of a data block. To postpone the occurrence of ﬁrst
uncorrectable fault on PCM, many fault tolerance schemes
have been proposed, including ECP [20], SAFER [21], and
RDIS [15]. In particular, ECP corrects errors by perma-
nently encoding the locations of failed cells into a vector
and assigning other cells to replace them. With additional
metadata the schemes can correct a certain number of errors
in a bit group before the group is declared as failed. A bit
group usually consists of 64bits to 512bits. WL-Reviver is
designed to help manage failures that cannot be tolerated by
the schemes.
The second objective is at least as important as the ﬁrst
one, because a PCM chip or an entire PCM-based memory
can become unavailable with only a small percentage of
blocks failed and most of them still alive. There are two
sources leading to early failures. One is the process variation,
which causes high lifetime variability across PCM cells.
The other is non-uniformly distributed writes. The proposed
solutions can be categorized into three groups.
The ﬁrst group of solutions is to dynamically allocate
hardware resources for error correction so that early-failed
blocks can stay alive longer for storing data. As an example,
Pay-As-You-Go (PAYG) reserves a certain amount of meta-
data space for a set of bit groups and uses the space for any
of the groups only when their faults cannot be corrected by
their local metadata [18].
The second group is to prevent pages from early loss
due to failure of its blocks. One such scheme is FREE-
p, which acquires some reserved data space and uses the
space to hide any failed blocks via pointers embedded in
the failed blocks [23]. Zombie [8] pairs a failed block in
a working memory page with a spare block in a disabled
page. Zombie also uses a pointer (or a link) to record the
pairing relationship. This pairing may enable various error
correction codes between the failed and spare blocks. As we
have discussed, migration of data in the spare blocks in the
wear leveling operations can foil the efforts of these page-
recovery schemes and WL-Reviver provides a solution to
this issue.
The third group is to level wear on the PCM. Though
the technique can be applied at the bit level by shifting
data placement offset in a bit group [20], [24] and at the
byte level [25], wear leveling techniques are most commonly
used at the cacheline level for migrating data across memory
blocks. Start-Gap [21] and Security Refresh [22] are two rep-
resentative schemes, which also consider malicious attacks
that keep writing at the same set of addresses. Though they
are effective and play an irreplaceable role for extending
PCM’s lifetime,
they cease to function with occurrence
of the ﬁrst block failure in their working address spaces
as a contiguous address space is required. WL-Reviver
effectively addresses the issue with an efﬁcient address re-
mapping technique.
LLS [12] is a scheme sharing a similar goal with WL-
Reviver. It dynamically reduces software-useable address
space to acquire reserved space for re-mapping failed blocks.
Compared with WL-Reviver, LLS is inadequate in four
aspects. First, LLS has to rely on OS’s support to obtain
reserved space. To maintain contiguous address space for
wear leveling, LLS has to constantly acquire space from
either higher or lower device addresses. Consequently, to
reserve space for LLS, an OS may have to conduct expen-
sive data relocation operations among pages. Second, LLS
represents the mapping relationship between failed blocks
and their backup blocks, which are equivalent to shadow
blocks in WL-Reviver, by maintaining the same relative
order in their respective block lists. This may constantly
incur block insertion operations, and consequently expensive
data shifting operations. This also requires LLS to maintain
a bitmap that has to be read upon each access of data on
a backup block, which can substantially increase PCM’s
access time. Third, it is less ﬂexible for LLS to manage
address space. LLS uses chunk, which is 64MB by default
in the paper, as the unit for expanding the reserved space.
To maintain contiguous wear-leveling space, LLS partitions
blocks into salvaging groups and dictates that a failed block
can only use block in the same group as its backup one.
Because a group consists of blocks from different chunks,
LLS may have to move a new chunk into the reserved space
while many idle blocks are in the reserved space without
being mapped to failed blocks. Therefore, software-usable
space can be unnecessarily reduced. Furthermore, because
these idle blocks do not participate in wear leveling, the wear
leveling effect is compromised. Fourth, to integrate existent
wear-leveling schemes into LLS, one may have to conduct
substantial adaptation of the schemes. In contrast, WL-
Reviver requires almost no OS support, no data migration
other than that demanded by the wear-leveling scheme itself,
and minimal data access overhead. It conducts implicit,
incremental, and ﬂexible space reservation without requiring
any modiﬁcations of the wear-leveling schemes for them to
be in the framework.
III. THE DESIGN OF WL-Reviver
WL-Reviver is a framework to revive any wear-leveling
scheme that becomes incapable to perform its leveling opera-
tions due to block failures in its working space. Its strategy is
to hide the failures from the scheme by redirecting accesses
that are originally to the failed blocks to the reserved
231231231
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:25:52 UTC from IEEE Xplore.  Restrictions apply. 
healthy blocks without any new OS supports. To serve as a
framework accommodating any wear-leveling scheme, WL-
Reviver assumes only one fundamental operation common to
any of such schemes, which is to migrate data into a memory
block. Below we will describe when and how reserved space
is acquired and how a failed block is linked to a reserved
block.
A. Acquiring Spare Space to Hide Failed Blocks
There are two issues to address in the acquisition of spare
space for hiding currently failed blocks and for being used
as reserved space to cover future failures. The ﬁrst issue
is about condition and timing of this acquisition, and the
second one is about acquisition method.
As we have discussed, for the sake of widespread and
quick adoption of PCM as main memory, minimal involve-
ment of OS is preferred. To this end, WL-Reviver does
not modify existent
interface between the software and
the memory hardware. In addition to supporting read and
write commands, the interface also includes mechanism of
generating exception to OS when an access error is detected.
A standard procedure for OS to handle the exception is to
exclude the page associated with the error from its allocation
pool and to prevent future access of data in the page. Some
system architectures, such as HP Memory Quarantine [3],
use ﬁrmware to mark memory locations with errors as bad
and unavailable before passing the errors to the OS. To avoid
computer downtime, especially for servers running mission-
critical applications, the OS would make every effort to
recover from the errors without shutting down the system or
even without closing down the affected threads or processes.
To facilitate this effort, WL-Reviver does not require any
changes of the interface. The only assumption it makes to
acquire spare space is that the page associated with the
error reported in the exception will not be accessed by
the software. As the assumption had been supported, WL-
Reviver is not intrusive to existent systems at all.
Note that wear-leveling is conducted at the unit of mem-
ory block to match the memory access unit, which is the
cacheline size of the last-level cache, and OS uses memory
at the unit of page. As an example, for a 64B memory
block, acquisition of a 4KB page is equivalent to receipt
of 64 physical addresses (PAs), each mapped to a different
memory block at a device address (DA). If one of the
PAs is mapped to a healthy memory block, the healthy
block can be served as the shadow block of a recently
failed block that is demanding for a spare block to hide
the failure, or to transparently redirect accesses to the failed
block to the shadow block. A salient feature of WL-Reviver
distinguishing it from other schemes is that a failed block
is not directly linked to its shadow block. Instead, the failed
block is only linked to a PA that is excluded out of the
scope accessible to the software. This PA is named as virtual
shadow block, as it has to be mapped to a shadow block
addressed by a DA to serve the purpose of hiding failures.
For the ﬁrst block failure, WL-Reviver allows PCM to
report it to the OS so that it can acquire a number of PAs
included in the page associated with the failure to serve as
virtual shadow blocks. For this particular failure, only one
virtual shadow block is needed to be linked to the failed
block. For a number of following block failures, WL-Reviver
does not report them to the OS. Instead, it uses the unlinked
PAs as virtual shadow blocks to hide the failures. Only after
the acquired PAs are used up, a new block failure will trigger
another exception to the OS for another page acquisition.
Apparently WL-Reviver incrementally acquires a small set
of PAs at a time for two beneﬁts. First, it avoids reservation
of a large chunk of memory at once to minimize reduction of
software-usable memory space. Second, it can handle most
of failures without any interaction with the OS . To facilitate
the acquisition method, WL-Reviver sets up two registers.
One records the PA currently available to serve as a virtual
shadow block, and the other records the last PA available
for the purpose. PAs in the range between the current PA
and the last PA represent the reserved virtual spare space.
When a failed block is detected, the PA recorded in the ﬁrst
register is employed as a virtual shadow block, and then the
register increments its recorded PA value by one. If the PA
in the ﬁrst register exceeds that in the second one and an
access error occurs, the error is reported to the OS, which
discontinues its use of the page that is associated with the
error, and the two registers are accordingly set.
In addition to failures detected in the service of accesses
from the software, there are failures detected in the execution
of data migration due to wear leveling within the PCM.
If there are unlinked virtual shadow blocks, the failures
can be hidden transparently without interruption to the OS.
However, if there are not any unlinked PAs ready for use,
there are two options about the timing to acquire the PAs.
One is to immediately interrupt the OS to acquire the PAs.
The drawback of this option is the need to change the OS. It
requires PCM to send the OS an interruption to proactively
report errors and explicitly acquire spare space. Apparently
the OS needs to be accordingly modiﬁed to handle this new
type of interruption. The other option is to leave the space
acquisition as a reactive operation, or reporting errors only
in response to access requests from the software, to keep
the OS unchanged. This option requires a delayed space
acquisition.
A challenge with the second option, which is taken
by WL-Reviver, is its risk of losing data that has been
successfully stored in the PCM. The sequence of data
migration operations, including source and destination of
each migration, has been pre-determined in a wear leveling
scheme. Without an immediately available shadow block,
data would have to be unsuccessfully written into the failed
block and get lost. To address the challenge, WL-Reviver
232232232
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:25:52 UTC from IEEE Xplore.  Restrictions apply. 
Current
VV
Last
…
( )
S
S
OS Page A
Memory Blocks
OS Page A
Memory Blocks
F
F
F
F
(a)
Last
Current
V V
V
…
FF
F
S
S
Memory Blocks
OS Page A
Last
Current
V …V
Memory Blocks
OS Page A
F
F
F
F
S
S
(b)
Current
Last
V V
V V
…
FF
F
S
S
F Failed Block
S Shadow Block
V Virtual Shadow Block
Inverse Pointer Block
DA to PA pointer
PA to DA mapping
Inverse pointer
(c)
(d)
Illustrating how failed blocks, virtual shadow blocks, and shadow blocks are linked. (a) Failed block D0 points to virtual shadow block P1,
Figure 2.
which is mapped to shadow block D1 via mapping function F1(). (b) After the data in D1 is migrated to D2, the mapping function is updated to F2()
so that the shadow block becomes D2. (c) The software issues write to PA P0 mapped to the failed block D0, which has its shadow block D2. When
D2 fails upon serving the write, D3 becomes D0’s new shadow block via a new virtual shadow block P2. (d) Blocks D0 and D2 switch their virtual
shadow blocks to reduce the chain size from two to one. Now D2 is on a PA-DA loop and does not have its shadow block. P0 is a PA accessible from
the software. OS page A represents reserved PA spaces unaccessible from the software.
OS Page A
Last
Current
V …
V
…
Last
Current
V
V
…
…
OS Page B
Memory Blocks
F
F
F
F
( )
(a)
F
F
F
F
( )
S
S
S
S
OS Page A
Last
Current
V …
V …
Current
V
V
V
VV
OS Page B
OS Page Bg
OS Page B
Memory Blocks
F
F
F
F
F
F
F
F