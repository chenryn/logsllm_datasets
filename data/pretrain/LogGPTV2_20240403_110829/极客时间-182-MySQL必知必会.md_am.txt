# 16 \| 游标：对于数据集中的记录，该怎么逐条处理？你好，我是朱晓峰。今天，我来和你聊一聊游标。咱们前面学习的 MySQL数据操作语句，都是针对结果集合的。也就是说，每次处理的对象都是一个数据集合。如果需要逐一处理结果集中的记录，就会非常困难。虽然我们也可以通过筛选条件 WHERE 和HAVING，或者是限定返回记录的关键字 LIMIT返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是随意定位到某一条记录，并对记录的数据进行处理。这个时候，就可以用到游标。所谓的游标，也就是能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。这么说可能有点抽象，我举一个生活中的例子，你一看就明白了。比如，你想去某个城市旅游，现在需要订酒店。你打开预订酒店的App，设置好价格区间后进行搜索，得到了一个酒店列表。接下来，你可能要逐条查看列表中每个酒店的客户评价，最后选择一个口碑不错的酒店。这个逐条搜索并对选中的数据进行操作的过程，就相当于游标对数据记录进行操作的过程。今天我就来给你讲一讲游标的使用方法，同时还会通过一个案例串讲，帮助你更好地使用游标，让你能够轻松地处理数据集中的记录。游标的使用步骤游标只能在存储程序内使用，存储程序包括存储过程和存储函数。关于存储过程，我们上节课刚刚学过，这里我简单介绍一下存储函数。创建存储函数的语法是：    CREATE FUNCTION 函数名称 （参数）RETURNS 数据类型 程序体存储函数与存储过程很像，但有几个不同点：1.       存储函数必须返回一个值或者数据表，存储过程可以不返回。        2.       存储过程可以通过 CALL    语句调用，存储函数不可以。        3.       存储函数可以放在查询语句中使用，存储过程不行。        4.       存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。        这节课，我们主要学习下游标在存储过程中的使用方法，因为游标在存储过程中更常用。游标在存储函数中的使用方法和在存储过程中的使用方法是一样的。在使用游标的时候，主要有 4个步骤。 第一步，定义游标。语法结构如下：    DECLARE 游标名 CURSOR FOR 查询语句这里就是声明一个游标，它可以操作的数据集是"查询语句"返回的结果集。第二步，打开游标。语法结构如下：    OPEN 游标名称；打开游标之后，系统会为游标准备好查询的结果集，为后面游标的逐条读取结果集中的记录做准备。第三步，从游标的数据结果集中读取数据。语法结构是这样的：    FETCH 游标名 INTO 变量列表；这里的意思是通过游标，把当前游标指向的结果集中那一条记录的数据，赋值给列表中的变量。需要注意的是，**游标的查询结果集中的字段数，必须跟 INTO后面的变量数一致**，否则，在存储过程执行的时候，MySQL会提示错误。第四步，关闭游标。语法结构如下：    CLOSE 游标名；**用完游标之后，你一定要记住及时关闭游标**。因为游标会占用系统资源，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。知道了基本步骤，下面我就结合超市项目的实际案例，带你实战一下。案例串讲在超市项目的进货模块中，有一项功能是对进货单数据进行验收。其实就是在对进货单的数据确认无误后，对进货单的数据进行处理，包括增加进货商品的库存，并修改商品的平均进价。下面我用实际数据来演示一下这个操作流程。这里我们要用到进货单头表（demo.importheadl）、进货单明细表（demo.importdetails）、库存表（demo.inventory）和商品信息表（demo.goodsmaster）。进货单头表：![](Images/6810a1df71138d352b006cbc3e58282b.png)savepage-src="https://static001.geekbang.org/resource/image/aa/97/aa133989325a1125ff118bce9993ec97.jpeg"}进货单明细表：![](Images/afc427e8fcd1edfd7c1e4cb53752aa05.png)savepage-src="https://static001.geekbang.org/resource/image/a5/b3/a5b6af4f27a24e003bced20e044336b3.jpeg"}库存表： ![](Images/2c3985e2a8d831d6f5dc46bb9c404c82.png)savepage-src="https://static001.geekbang.org/resource/image/1e/d3/1e1c6d83d75094376bf21e6f4c0572d3.jpeg"}商品信息表：![](Images/78791a21a5183767c049e2872e0ef1dc.png)savepage-src="https://static001.geekbang.org/resource/image/cd/8e/cd9832d7cac00446b937462518bf018e.jpeg"}要验收进货单，我们就需要对每一个进货商品进行两个操作：1.       在现有库存数量的基础上，加上本次进货的数量；        2.       根据本次进货的价格、数量，现有商品的平均进价和库存，计算新的平均进价：（本次进货价格    \* 本次进货数量 + 现有商品平均进价 \*    现有商品库存）/（本次进货数量 +    现有库存数量）。        针对这个操作，如果只用我们在第 4 讲里学习的 SQL语句，完成起来就比较困难。因为我们需要通过应用程序来控制操作流程，做成一个循环操作，每次只查询一种商品的数据记录并进行处理，一直到把进货单中的数据全部处理完。这样一来，应用必须发送很多的SQL指令到服务器，跟服务器的交互多，不仅代码复杂，而且也不够安全。这个时候，如果使用游标，就很容易了。因为所有的操作都可以在服务器端完成，应用程序只需要发送一个命令调用存储过程就可以了。现在，我们就来看看如何用游标来解决这个问题。我用代码创建了一个存储过程 demo.mytest（）。当然，你也完全可以在Workbench中创建存储过程，非常简单，我就不多说了。创建存储过程的代码如下：    mysql> DELIMITER //    mysql> CREATE PROCEDURE demo.mytest(mylistnumber INT)    -> BEGIN    -> DECLARE mystockid INT;    -> DECLARE myitemnumber INT;    -> DECLARE myquantity DECIMAL(10,3);    -> DECLARE myprice DECIMAL(10,2);    -> DECLARE done INT DEFAULT FALSE; -- 用来控制循环结束    -> DECLARE cursor_importdata CURSOR FOR -- 定义游标    -> SELECT b.stockid,a.itemnumber,a.quantity,a.importprice    -> FROM demo.importdetails AS a    -> JOIN demo.importhead AS b    -> ON (a.listnumber=b.listnumber)    -> WHERE a.listnumber = mylistnumber;    -> DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; -- 条件处理语句    ->    -> OPEN cursor_importdata; -- 打开游标    -> FETCH cursor_importdata INTO mystockid,myitemnumber,myquantity,myprice; -- 读入第一条记录    -> REPEAT    -> -- 更新进价    -> UPDATE demo.goodsmaster AS a,demo.inventory AS b    -> SET a.avgimportprice = (a.avgimportprice*b.invquantity+myprice*myquantity)/(b.invquantity+myquantity)    -> WHERE a.itemnumber=b.itemnumber AND b.stockid=mystockid AND a.itemnumber=myitemnumber;    -> -- 更新库存    -> UPDATE demo.inventory    -> SET invquantity = invquantity + myquantity    -> WHERE stockid = mystockid AND itemnumber=myitemnumber;    -> -- 获取下一条记录    -> FETCH cursor_importdata INTO mystockid,myitemnumber,myquantity,myprice;    -> UNTIL done END REPEAT;    -> CLOSE cursor_importdata;    -> END    -> //    Query OK, 0 rows affected (0.02 sec)    -> DELIMITER ;这段代码比较长，核心操作有 6步，我来给你详细解释下。1.       把 MySQL    的分隔符改成"//"。        2.       开始程序体之后，我定义了 4 个变量，分别是    mystockid、myitemnumber、myquantity 和    myprice，这几个变量的作用是，存储游标中读取的仓库编号、商品编号、进货数量和进货价格数据。        3.       定义游标。这里我指定了游标的名称，以及游标可以处理的数据集（mylistnumber    指定的进货单的全部进货商品明细数据）。        4.       定义条件处理语句"DECLARE CONTINUE HANDLER FOR NOT FOUND SET done    = TRUE;"。        5.       打开游标，读入第一条记录，然后开始执行数据操作。        6.       关闭游标，结束程序。        可以看到，在这个存储过程中，我用到了条件处理语句，它的作用是告诉系统，在存储程序遇到问题的时候，应该如何处理。条件处理语句条件处理语句的语法结构：    DECLARE 处理方式 HANDLER FOR 问题 操作；下面我结合刚刚的"DECLARE CONTINUE HANDLER FOR NOT FOUND SET done =TRUE;"，来解释一下条件处理语句是如何工作的。1.       **语法结构中的"问题"是指 SQL    操作中遇到了什么问题**        。比如这里的问题是"NOT    FOUND"，意思就是游标走到结果集的最后，没有记录了。也就是说，数据集中的所有记录都已经处理完了。        2.       执行的操作是"SET done=TRUE"，done    是我定义的用来标识数据集中的数据是否已经处理完成的一个标记。done=TRUE，意思是数据处理完成了。        3.       **处理方式有 2    种选择，分别是"CONTINUE"和"EXIT"**        ，表示遇到问题，执行了语法结构中的"操作"之后，是选择继续运行程序，还是选择退出，结束程序。        所以，这个条件处理语句的意思就是：当游标读到结果集的最后，没有记录了，设置操作完成标识为真，然后继续运行程序。在存储过程的第 5步，为了逐一处理每一条记录，我还使用了流程控制语句。解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL操作。流程控制语句的作用就是控制存储过程中 SQL语句的执行顺序，是我们完成复杂操作必不可少的一部分。下面我就给你具体讲解一下。流程控制语句MySQL 的流程控制语句也只能用于存储程序。主要有 3类。 1.       跳转语句：ITERATE 和 LEAVE    语句。    2.       循环语句：LOOP、WHILE 和 REPEAT    语句。    3.       条件判断语句：IF 语句和 CASE    语句。    接下来我依次讲解一下跳转语句、循环语句和条件判断语句。跳转语句1.       ITERATE    语句：只能用在循环语句内，表示重新开始循环。        2.       LEAVE 语句：可以用在循环语句内，或者以 BEGIN 和 END    包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。        循环语句LOOP 语句的语法结构是：    标签：LOOP    操作    END LOOP 标签;关于这个语句，需要注意的是，LOOP 循环不能自己结束，需要用跳转语句ITERATE 或者 LEAVE 来进行控制。WHILE 语句的语法结构：    WHILE 条件 DO    操作    END WHILE;WHILE循环通过判断条件是否为真来决定是否继续执行循环中的操作，你要注意一点，**WHILE循环是先判断条件，再执行循环体中的操作**。REPEAT 语句的语法结构：    REPEAT    操作    UNTIL 条件 END REPEAT；REPEAT循环也是通过判断条件是否为真来决定是否继续执行循环内的操作的，与 WHILE不同的是， **REPEAT循环是先执行操作，后判断条件**。最后我来讲讲条件判断语句：IF 语句和 CASE语句。 条件判断语句IF 语句的语法结构是：    IF 表达式1 THEN 操作1    [ELSEIF 表达式2 THEN 操作2]……    [ELSE 操作N    END IF这里"\[\]"中的内容是可选的。**IF语句的特点是，不同的表达式对应不同的操作**。CASE 语句的语法结构是：    CASE 表达式    WHEN 值1 THEN 操作1    [WHEN 值2 THEN 操作2]……    [ELSE 操作N    END CASE;这里"\[\]"中的内容是可选的。CASE语句的特点是，表达式不同的值对应不同的操作。到这里，我们处理进货单验收的存储过程就创建好了。现在，让我们来运行一下这个存储过程，看看能不能得到我们想要的结果：    mysql> CALL demo.mytest(1234);          -- 调用存储过程，验收单号是1234的进货单    Query OK, 0 rows affected (11.68 sec)   -- 执行成功了         mysql> select * from demo.inventory;    -- 查看库存，已经改过来了    +---------+------------+-------------+    | stockid | itemnumber | invquantity |    +---------+------------+-------------+    | 1 | 1 | 15.000 |    | 1 | 2 | 23.000 |    +---------+------------+-------------+    2 rows in set (0.00 sec)         mysql> select * from demo.goodsmaster;     -- 查看商品信息表，平均进价也改过来了    +------------+---------+-----------+---------------+------+------------+----------------+    | itemnumber | barcode | goodsname | specification | unit | salesprice | avgimportprice |    +------------+---------+-----------+---------------+------+------------+----------------+    | 1 | 0001 | 书 | 16开 | 本 | 89.00 | 31.00 |    | 2 | 0002 | 笔 | NULL | 包 | 5.00 | 2.87 |    +------------+---------+-----------+---------------+------+------------+----------------+    2 rows in set (0.00 sec)很显然，库存和平均价格都被正确地计算出来了。最后，有个小问题要提醒你注意：**如果一个操作要用到另外一个操作的结果，那我们一定不能搞错操作的顺序**。比如，在刚刚的例子中，我是先计算平均价格，后消减库存数量，这就是因为，计算平均价格的时候会用到库存数量，如果先消减库存数量，平均价格的计算就会不准。总结这节课，我们学习了游标的使用方法，包括在存储过程中使用游标的 4个步骤，分别是定义游标、打开游标、读取游标数据和关闭游标。除此之外，我还介绍了经常与游标结合使用的流程控制语句，包括循环语句LOOP、WHILE 和 REPEAT；条件判断语句 IF 和 CASE；还有跳转语句 LEAVE 和ITERATE。 游标是 MySQL的一个重要的功能，为逐条读取结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。但是游标会消耗系统资源，所以我建议你养成用完之后就关闭的习惯，这样才能提高系统的整体效率。思考题假设我有一个数据表demo.test，具体信息如下所示：![](Images/ab573dff9841b1b4b31c2b35b47ccf79.png)savepage-src="https://static001.geekbang.org/resource/image/a6/44/a62ccd9ea5e88cfa793dc837a1168f44.jpeg"}你能自己写一个简单的存储过程，用游标来逐一处理一个数据表中的数据吗？要求：编号为偶数的记录，myquant=myquant+1；编号是奇数的记录，myquant=myquant+2。欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，欢迎你把它分享给你的朋友或同事，我们下节课见。
# 17 \| 触发器：如何让数据修改自动触发关联操作，确保数据一致性？你好，我是朱晓峰。今天，我来和你聊一聊触发器。在实际开发中，我们经常会遇到这样的情况：有 2个或者多个相互关联的表，如商品信息和库存信息分别存放在 2个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用事务包裹起来，确保这两个操作成为一个原子操作，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很容易忘记其中的一步，导致数据缺失。这个时候，其实咱们可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。听上去好像很不错，那触发器到底怎么使用呢？接下来，我就重点给你聊聊。我会先给你讲解创建、查看和删除触发器的具体操作，然后借助一个案例带你实战一下。如何操作触发器？首先，咱们来学习下触发器的基本操作。创建触发器创建触发器的语法结构是：    CREATE TRIGGER 触发器名称 {BEFORE|AFTER} {INSERT|UPDATE|DELETE}    ON 表名 FOR EACH ROW 表达式；在创建时，你一定要注意触发器的三个要素。1.  表名：表示触发器监控的对象。        2.  INSERT\|UPDATE\|DELETE：表示触发的事件。INSERT    表示插入记录时触发；UPDATE 表示更新记录时触发；DELETE    表示删除记录时触发。        3.  BEFORE\|AFTER：表示触发的时间。BEFORE 表示在事件之前触发；AFTER    表示在事件之后触发。        只有把这三个要素定义好，才能正确使用触发器。创建好触发器之后，咱们还要知道触发器是不是创建成功了。怎么查看呢？我来介绍下。查看触发器查看触发器的语句是：    SHOW TRIGGERS\G;删除触发器删除触发器很简单，你只要知道语法结构就可以了：    DROP TRIGGER 触发器名称;知道了触发器的操作方法，接下来咱们就借助超市项目的实际案例，在真实的场景中实战一下，毕竟，实战是掌握操作的最好方法。案例讲解超市项目实际实施过程中，客户经常要查询储值余额变动的明细，但是，查询会员消费流水时，存在数据汇总不及时、查询速度比较慢的问题。这时，我们就想到用触发器，及时把会员储值金额的变化信息记录到一个专门的表中。我先用咱们熟悉的 SQL语句来实现记录储值金额变动的操作，后面再带你使用触发器来操作。通过两种操作的对比，你就能更好地理解，在什么情况下，触发器能够比普通的SQL语句更加简洁高效，从而帮助你用好触发器这个工具，提高开发的能力。下面我就借助具体数据，来详细说明一下。这里我们需要用到会员信息表（demo.membermaster）和会员储值历史表（demo.deposithist）。会员信息表：![](Images/9b1d5b29ef18c31807fcbc81bf5e3019.png)savepage-src="https://static001.geekbang.org/resource/image/26/34/26166082e21c2cbd38e4c21d03e76734.jpeg"}会员储值历史表：![](Images/ca48f0d362c324eb5c2254bd578ca401.png)savepage-src="https://static001.geekbang.org/resource/image/f0/c5/f0b59f65801543af6c52b208c71925c5.jpeg"}假如在 2020 年 12 月 20 日这一天，会员编号是 2的会员李四，到超市的某家连锁店购买了一条烟，消费了 150元。现在，我们用之前学过的 SQL语句，把这个会员储值余额的变动情况记录到会员储值历史表中。第一步，查询出编号是 2的会员卡的储值金额是多少。我们可以用下面的代码来实现：    mysql> SELECT memberdeposit    -> FROM demo.membermaster    -> WHERE memberid = 2;    +---------------+    | memberdeposit |    +---------------+    | 200.00 |    +---------------+    1 row in set (0.00 sec)第二步，我们把会员编号是 2 的会员的储值金额减去150。     mysql> UPDATE demo.membermaster    -> SET memberdeposit = memberdeposit - 150    -> WHERE memberid = 2;    Query OK, 1 row affected (0.01 sec)    Rows matched: 1 Changed: 1 Warnings: 0第三步，读出会员编号是 2的会员当前的储值金额。    mysql> SELECT memberdeposit    -> FROM demo.membermaster    -> WHERE memberid = 2;    +---------------+    | memberdeposit |    +---------------+    | 50.00 |    +---------------+    1 row in set (0.00 sec)第四步，把会员编号和前面查询中获得的储值起始金额、储值余额和储值金额变化值，写入会员储值历史表。    mysql> INSERT INTO demo.deposithist    -> (    -> memberid,    -> transdate,    -> oldvalue,    -> newvalue,    -> changedvalue    -> )    -> SELECT 2,NOW(),200,50,-150;    Query OK, 1 row affected (0.02 sec)    Records: 1 Duplicates: 0 Warnings: 0这样，我们就完成了记录会员储值金额变动的操作。现在，我们来查询一下记录的结果：    mysql> SELECT *    -> FROM demo.deposithist;    +----+----------+---------------------+----------+----------+--------------+    | id | memberid | transdate | oldvalue | newvalue | changedvalue |    +----+----------+---------------------+----------+----------+--------------+    | 1 | 2 | 2020-12-20 10:37:51 | 200.00 | 50.00 | -150.00 |    +----+----------+---------------------+----------+----------+--------------+    1 row in set (0.00 sec)结果显示，会员编号是 2 的会员卡储值金额在 2020-12-20 10:37:51时有变动，变动前是 200 元，变动后是 50 元，减少了 150元。 你看这个记录会员储值金额变动的操作非常复杂，我们用了 4步才完成。而且为了确保数据的一致性，我们还要用事务把这几个关联的操作包裹起来，这样一来，消耗的资源就比较多。那如果用触发器来实现，效果会怎样呢？我们来实操一下。首先，我们创建一个数据表 demo.membermaster的触发器。每当更新表中的数据时，先触发触发器，如果发现会员储值金额有变化，就把会员编号信息、更新的时间、更新前的储值金额、更新后的储值金额和变动金额，写入会员储值历史表。然后，再执行会员信息表的更新操作。创建触发器的代码如下所示：    DELIMITER //    CREATE TRIGGER demo.upd_membermaster BEFORE UPDATE  -- 在更新前触发    ON demo.membermaster    FOR EACH ROW                              -- 表示每更新一条记录，触发一次    BEGIN                                     -- 开始程序体    IF (new.memberdeposit <> old.memberdeposit)  -- 如果储值金额有变化    THEN    INSERT INTO demo.deposithist    (    memberid,    transdate,    oldvalue,    newvalue,    changedvalue    )    SELECT    NEW.memberid,    NOW(),    OLD.memberdeposit,                  -- 更新前的储值金额    NEW.memberdeposit,                  -- 更新后的储值金额    NEW.memberdeposit-OLD.memberdeposit; -- 储值金额变化值    END IF;    END    //    DELIMITER ;创建完成之后，我们查看一下触发器，看看是不是真的创建成功了：    mysql> SHOW TRIGGERS \G;    *************************** 1. row ***************************    Trigger: upd_membermaster -- 触发器名称    Event: UPDATE -- 触发的事件    Table: membermaster -- 表名称    Statement: BEGIN -- 被触发时要执行的程序体    IF (new.memberdeposit <> old.memberdeposit) -- 储值金额变动时插入历史储值表    THEN    INSERT INTO demo.deposithist    (    memberid,    transdate,    oldvalue,    newvalue,    changedvalue    )    SELECT    NEW.memberid,    NOW(),    OLD.memberdeposit,    NEW.memberdeposit,    NEW.memberdeposit-OLD.memberdeposit;    END IF;    END    Timing: BEFORE    Created: 2021-04-03 15:02:48.18    sql_mode: STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION    Definer: root@localhost    character_set_client: utf8mb4    collation_connection: utf8mb4_0900_ai_ci    Database Collation: utf8mb4_0900_ai_ci    1 row in set (0.00 sec)从代码中，我们可以知道触发器的具体信息：1.  Trigger 表示触发器名称，这里是    upd_membermaster；        2.  Event 表示触发事件，这里是    UPDATE，表示更新触发；        3.  Table 表示定义触发器的数据表，这里是    membermaster；        4.  Statement    表示触发时要执行的程序体。        看到这些信息，我们就可以确认，触发器创建成功了。创建成功以后，我们尝试更新一下会员编号是 1的会员的储值金额，这里假设把会员 1 的储值金额增加 10元。简单说明一下，会员也可以把钱存到会员卡里，需要的时候进行消费，对应的就是储值金额的增加。我们用下面的代码来完成这个操作：    mysql> UPDATE demo.membermaster    -> SET memberdeposit = memberdeposit + 10    -> WHERE memberid = 1;    Query OK, 1 row affected (0.03 sec)    Rows matched: 1 Changed: 1 Warnings: 0现在，我们来查看一下会员信息表和会员储值历史表：    mysql> SELECT *    -> FROM demo.membermaster;    +----------+----------+------------+---------+-------------+---------------+    | memberid | cardno | membername | address | phone | memberdeposit |    +----------+----------+------------+---------+-------------+---------------+    | 1 | 10000001 | 张三 | 北京 | 13812345678 | 110.00 |    | 2 | 10000002 | 李四 | 天津 | 18512345678 | 50.00 |    +----------+----------+------------+---------+-------------+---------------+    2 rows in set (0.00 sec)         mysql> SELECT *    -> FROM demo.deposithist;    +----+----------+---------------------+----------+----------+--------------+    | id | memberid | transdate | oldvalue | newvalue | changedvalue |    +----+----------+---------------------+----------+----------+--------------+    | 1 | 2 | 2020-12-20 10:37:51 | 200.00 | 50.00 | -150.00 |    | 2 | 1 | 2020-12-20 11:32:09 | 100.00 | 110.00 | 10.00 |    +----+----------+---------------------+----------+----------+--------------+    2 rows in set (0.01 sec)结果显示，触发器正确地记录了修改会员储值金额的操作。如果你一直跟着我进行操作，到这里，你可能会有疑问，在会员历史储值表中记录修改会员储值金额的操作，和实际修改会员信息表是2个操作，有没有可能一个成功，一个失败？比如说，记录修改会员储值金额的操作失败了，但是会员的储值金额被修改了。其实，在 MySQL中，如果触发器中的操作失败了，那么触发这个触发器的数据操作也会失败，不会出现一个成功、一个失败的情况。我还是借助一个例子来解释下。假设我们创建了一个触发器，这个触发器的程序体中的SQL语句有误，比如多了一个字段。在这种情况下，触发器执行会失败，因此，数据更新的操作也不会执行。我们用下面的代码来验证一下：    DELIMITER //    CREATE TRIGGER demo.upd_membermaster BEFORE UPDATE    ON demo.membermaster    FOR EACH ROW    BEGIN    IF (new.memberdeposit <> old.memberdeposit)    THEN    INSERT INTO demo.deposithist    (    aa, -- 不存在的字段    memberid,    transdate,    oldvalue,    newvalue,    changedvalue    )    SELECT    1, -- 给不存在的字段赋值    NEW.memberid,    NOW(),    OLD.memberdeposit,    NEW.memberdeposit,    NEW.memberdeposit-OLD.memberdeposit;    END IF;    END    //    DELIMITER ;现在，假设我们要把会员编号是 2 的会员卡的储值金额更新为20：     mysql> update demo.membermaster set memberdeposit=20 where memberid = 2;    ERROR 1054 (42S22): Unknown column 'aa' in 'field list'系统提示：因为字段"aa"不存在，导致触发器执行失败。现在我们来看看会员储值金额有没有被修改：    mysql> select * from demo.membermaster;    +----------+----------+------------+---------+-------------+---------------+    | memberid | cardno | membername | address | phone | memberdeposit |    +----------+----------+------------+---------+-------------+---------------+    | 1 | 10000001 | 张三 | 北京 | 13812345678 | 110.00 |    | 2 | 10000002 | 李四 | 天津 | 18512345678 | 50.00 |    +----------+----------+------------+---------+-------------+---------------+    2 rows in set (0.00 sec)结果显示，会员储值金额不变。这个时候，为了让应用程序知道触发器是否执行成功，我们可以通过ROW_COUNT() 函数来发现错误：    mysql> select row_count();    +-------------+    | row_count() |    +-------------+    | -1 |    +-------------+    1 row in set (0.00 sec)结果是 -1，说明我们可以通过 ROW_COUNT()函数捕获到错误。我们回顾一下：对于记录会员储值金额变化的操作，可以通过应用层发出 SQL语句指令，或者用一个存储过程来实现。无论哪种方式，都要通过好几步相互关联的操作，而且要做成一个事务，处理过程复杂，消耗的资源也较多。如果用触发器，效率就会提高很多，消耗的资源也少。同时，还可以起到事务的类似功能，保证关联操作全部完成或全部失败。触发器的优缺点通过刚刚的案例，你应该感受到触发器的高效了。现在，咱们把视角拔高一下，来看看触发器具体都有什么优缺点。毕竟，知己知彼，才能百战不殆。只有非常清楚它的优缺点，你才能充分发挥它的作用。我先来说说触发器的优点。**首先，触发器可以确保数据的完整性**。这是怎么体现的呢？我来举个小例子。假设我们用进货单头表（demo.importhead）来保存进货单的总体信息，包括进货单编号、供货商编号、仓库编号、总计进货数量、总计进货金额和验收日期。![](Images/2bab5947618cfd2dfa3ab6bf5bdaf89f.png)savepage-src="https://static001.geekbang.org/resource/image/5b/e8/5b36cf11405b0159a1388ee23639aee8.jpeg"}用进货单明细表（demo.importdetails）来保存进货商品的明细，包括进货单编号、商品编号、进货数量、进货价格和进货金额。![](Images/328c02ab693427ddde91ba9c46e03ff7.png)savepage-src="https://static001.geekbang.org/resource/image/b8/0e/b8e3fc8e001da9af2c85c22be5e6780e.jpeg"}每当我们录入、删除和修改一条进货单明细数据的时候，进货单明细表里的数据就会发生变动。这个时候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。为了解决这个问题，我们就可以使用触发器，规定每当进货单明细表有数据插入、修改和删除的操作时，自动触发2 步操作： 1.       重新计算进货单明细表中的数量合计和金额合计；        2.       用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。        这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与合计金额的值相同，数据就是一致的，不会互相矛盾。**其次，触发器可以帮助我们记录操作日志。**利用触发器，可以具体记录什么时间发生了什么。我们前面的记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。**另外，触发器还可以用在操作数据前，对数据进行合法性检查。**举个小例子。超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏......这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止错误数据进入系统。说了这么多触发器的优点，那是不是所有事件可以驱动的操作，都应该用触发器呢？要是你这么想，就掉坑里了。下面我来说说触发器的缺点。**触发器最大的一个问题就是可读性差。**因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能不受应用层的控制。这对系统维护是非常有挑战的。这是啥意思呢？我举个例子，你一看就明白了。还是拿我们创建触发器时讲到的修改会员储值操作的那个触发器为例。如果触发器中的操作出了问题，会导致会员储值金额更新失败。我用下面的代码演示一下：    mysql> update demo.membermaster set memberdeposit=20 where memberid = 2;    ERROR 1054 (42S22): Unknown column 'aa' in 'field list'结果显示，系统提示错误，字段"aa"不存在。这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表添加一个叫"aa"的字段，试图解决这个问题，结果只能是白费力。另外，相关数据的变更，特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。总结今天这节课，我给你介绍了如何操作触发器。为了方便你学习，我汇总了相关的语法结构：    创建触发器的语法结构是    CREATE TRIGGER 触发器名称 {BEFORE|AFTER} {INSERT|UPDATE|DELETE}    ON 表名 FOR EACH ROW 表达式；    查看触发器的语句是：    SHOW TRIGGERS\G;    删除触发器的语法结构是：    DROP TRIGGER 触发器名称;除此之外，我们还学习了触发器的优缺点。它的优点是可以确保数据一致性、记录操作日志和检查数据合法性。不过，它也存在可读性差，会增加系统维护的成本的缺点。在使用触发器的时候，你一定要综合考量。最后，我还想再给你提一个小建议：**维护一个完整的数据库设计文档**。因为运维人员可能会经常变动，如果有一个完整的数据库设计文档，就可以帮助新人快速了解触发器的设计思路，从而减少错误，降低系统维护的成本。思考题我在课程中提到，每当在进货单明细表中插入或修改数据的时候，都要更新进货单头表中的总计数量和总计金额，这个问题可以用触发器来解决。你能不能创建一个触发器，要求是当操作人员更新进货单明细表中相关数据的时候，自动触发对进货单头表中相关数据的更改，确保数据的一致性？欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，欢迎你把它分享给你的朋友或同事，我们下节课见。