ğ‘š, ğ‘š, ğ‘Ÿâ€²) :
if Â¬Vf(pk, ğœâ€², (ğ‘â€²
return (ğ‘š, fdâ€²)
ğ‘š, ğ‘ ğ‘Ÿğ‘â€²)) :
return âŠ¥ //verify platform signature
//ğ‘šğ‘ ğ‘” = (ğ‘š, ğ‘“ ğ‘‘â€²) will be used to forward the message
Figure 3: Tree-linkable construction.
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1491S = (KGenğ‘ ğ‘–ğ‘” â†’ (vkğ‘ , skğ‘ ), Sig(skğ‘ , ğ‘š) â†’ ğœ,
Vf(vkğ‘ , ğœ, ğ‘š) â†’ {0, 1}.
â€¢ A commitment scheme
â€¢ A signature scheme
C = (Commit(ğ‘š) â†’ (ğ‘ğ‘š, ğ‘Ÿ), Open(ğ‘ğ‘š, ğ‘š, ğ‘Ÿ) â†’ {0, 1}).
One of the merits of the scheme in Figure 3 is that it is non-
interactive. The communication for each protocol only consists of
a single message sent from the user to the platform in the case of
a send, or from the platform to the user in the case of a receipt,
though optional status messages could be added to let a platform
or user know if an operation succeeds.
We prove the following security theorems in Appendix B. Defi-
nitions of CPA- and AE-security can be found in [2].
Theorem 4.1. Assuming that the platform encryption scheme P
is CPA-secure, the commitment scheme C is hiding, and that the
messaging encryption scheme E is AE-secure, then Scheme 1 is tree-
linkably confidential (Definition 3.4).
Theorem 4.2. Assuming that the platformâ€™s signature scheme S
is secure against any efficient adversary A, then Scheme 1 satisfies
accountability (Definition 3.5).
Theorem 4.3. Assuming that the signature scheme S is unforge-
able and the commitment scheme C is binding against any efficient
adversary A, then Scheme 1 is unforgeable (Definition 3.6).
Theorem 4.4.
If for any efficient adversary, the messaging sys-
temâ€™s encryption scheme E satisfies deniability1 and the platformâ€™s
encryption scheme P is CPA-secure, then the scheme is deniable (Def-
inition 3.8).
5 TREE-UNLINKABLE SOURCE-TRACKING
Intuitively, we could achieve tree-unlinkability in the scheme de-
scribed in Section 4 if there was a way to re-randomize the for-
warding data fd each time a message is forwarded. However, such
a re-randomization is not easily achieved because re-randomizing
the platformâ€™s signature is not sufficient to make forwarding data
unlinkable. Both the signature and the signed contents need to be
re-randomized without revealing the contents to the platform.
Our tree-unlinkable construction preserves the basic framework
of the tree-linkable scheme in that forwarding data consists of a
â€œsignatureâ€ (in this case a MAC) on a commitment to the message
and an encryption of the source user and optional metadata. Users
re-randomize this forwarding data by re-randomizing the contents
of the signature and proving the validity of the re-randomized
values in zero-knowledge to the platform, which then issues the
user a fresh signature on those values.
Our scheme can be thought of as similar to a keyed-verification
anonymous credential scheme [4â€“6] that we modify to allow for
anonymous and unlinkable credential delegation via forwarding.
The attributes included in each credential are an encryption of
the source identity and metadata as well as a hash of the mes-
sage content. Since our attributes are a mix of group elements and
scalars and we need users to efficiently prove properties about these
1See Appendix A.2 for a formal definition of deniability for encrypted messaging
schemes.
attributes to the platform in zero-knowledge, we use the keyed-
verification anonymous credential scheme presented in [5]. This
construction relies on an algebraic MAC rather than a signature
for the credential. This is fine for us because only the platform will
need to distribute and verify forwarding credentials.
5.1 Tools
Zero Knowledge Proofs. We use zero knowledge proofs, denoted
with the standard Camenisch-Stadler notation ( [3]), i.e.,
ğœ‹ â† ğ‘ƒğ¾{(secrets) : expressions with secret and public vals}
When verifying a proof ğœ‹, we use the notation Vf(ğœ‹, [optional: ğ‘ƒ1,
ğ‘ƒ2, ...]), where ğ‘ƒ1, ğ‘ƒ2, ... are any public values used in the proof.
Algebraic MAC. The main building block of our scheme is an
algebraic MAC construction from Chase et al. [5]. Our particular
instantiation requires a MAC on three attributes, two of which are
group elements encoding the source information about a message
(ğ¸1 and ğ¸2), and the other a scalar corresponding to a hash of the
message plaintext ğ‘š, which we refer to by ğ‘‘ â† ğ»(ğ‘š).
This MAC requires a group G of prime order ğ‘ where the discrete
log problem is hard and 10 (public) fixed group elements. Because
we use most of the MAC functionality as a black-box in our scheme,
we will only deal with five of these parameters explicitly, and refer
to them as ğº, ğºğ‘‘, ğºğ‘¦1, ğºğ‘¦2, ğºğ‘¦3. These parameters correspond to
the parameters of the same name described in Section 3.1 of [5].
In an effort to reduce redundancy and keep our scheme simple,
we use this MAC as a black-box via the following functions:
â€¢ KGenğ‘€ğ´ğ¶(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ ) â†’ skğ‘€ğ´ğ¶ : Generates a MAC key.
â€¢ issue(ğ‘‘, ğ¸1, ğ¸2, skğ‘€ğ´ğ¶) â†’ ğœ, ğœ‹ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ : This function issues a MAC,
ğœ, on the attributes ğ‘‘, ğ¸1, and ğ¸2, which are provided in the clear,
as well as a proof that the MAC has been computed correctly,
ğœ‹ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ (See [5], Section 3.2). When verifying the unblinded MAC
on attributes ğ‘–ğ‘›ğ‘“ ğ‘œ = (ğ‘‘, ğ¸1, ğ¸2), we use the verification function
Vf(ğœ, ğœ‹ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’, ğ‘–ğ‘›ğ‘“ ğ‘œ).
â€¢ blindIssue(ğ‘ğ‘¡ğ‘‘, ğ‘ğ‘¡ğ¸1, ğ‘ğ‘¡ğ¸2, pk, skğ‘€ğ´ğ¶) â†’ ğ‘ğ‘¡ğœ, ğœ‹ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ : Given ElGa-
mal ciphertexts of each attribute encrypted under pk, this func-
tion blindly issues an encrypted MAC ğ‘ğ‘¡ğœ encrypted under the
same key. ğœ‹ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’ is a proof that the MAC is well-formed. (See [5],
Section 5.10).
â€¢ Vfğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’(ğœ‹ğ‘–ğ‘ ğ‘ ğ‘¢ğ‘’, ğ‘ğ‘¡ğœ, ğ‘ğ‘¡ğ‘‘, ğ‘ğ‘¡ğ¸1, ğ‘ğ‘¡ğ¸2, sk) â†’ ğœ or âŠ¥ : This is called by
a user to verify that a blindly issued MAC is well-formed. If the
proof is correct, the function returns the decrypted MAC. (See [5],
Section 5.10).
â€¢ prepPresent(ğœ, ğ‘‘, ğ¸1, ğ¸2) â†’ ğ¶ğ‘‘, ğ¶ğ¸1, ğ¶ğ¸2, ğ‘§, ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡ : When a
user wants to prove to a platform that it has a valid MAC, it uses
this function to commit to its attributes and MAC with opening
ğ‘§, and a proof ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡ that it has a valid MAC for these com-
mitments. The commitments have the form ğ¶ğ¸1 = ğºğ‘§
ğ‘¦1ğ¸1, ğ¶ğ¸2 =
. We include these commitments separately
ğ‘¦2ğ¸2, ğ¶ğ‘‘ = ğºğ‘§
ğºğ‘§
because they are later used for a second proof of the MAC con-
tents, but assume all necessary commitments are included in
ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡. (See [5], Section 3.2).
â€¢ blindVf(ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡ , ğ¶ğ¹ , skğ‘€ğ´ğ¶) â†’ valid or âŠ¥ : Verifies that ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡
is a valid proof that the user holds a MAC on the committed at-
tributes ğ¶ğ¹ . (See [5], Section 3.2).
ğ‘¦3ğºğ‘‘
ğ‘‘
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1492present(ğ‘‘, ğ¸1, ğ¸2, ğœ, pk = ğ‘Œ)
(ğ¶ğ‘‘, ğ¶ğ¸1, ğ¶ğ¸2, ğ‘§, ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡) â† prepPresent(ğœ, ğ‘‘, ğ¸1, ğ¸2)
//Additional commitments for proving re-randomization
(ğ‘§â€², ğ‘Ÿğ‘›ğ‘‘) â†R Z2
ğ‘‘ â† ğ¶ğ‘‘ğºğ‘§â€²
ğ¶â€²
ğ¸1 â† ğºğ‘§â€²
ğ¶â€²
ğœ‹ğ‘Ÿğ‘’ğ‘Ÿğ‘ğ‘›ğ‘‘ = ğ‘ƒğ¾ {(ğ‘§â€², ğ‘Ÿğ‘›ğ‘‘) : ğ¶â€²
ğ‘¦1ğºğ‘Ÿğ‘›ğ‘‘ğ¶ğ¸1, ğ¶â€²
ğ¸2 â† ğºğ‘§â€²
ğ‘¦2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘ğ¶ğ¸2
ğ‘‘/ğ¶ğ‘‘ = ğºğ‘§â€²
ğ‘¦3
ğ‘
ğ‘¦3
ğ¸2/ğ¶ğ¸2 = ğºğ‘§â€²
ğ‘¦2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘ }
âˆ§ ğ¶â€²
ğ‘¦1ğºğ‘Ÿğ‘›ğ‘‘ âˆ§ ğ¶â€²
ğ¸1/ğ¶ğ¸1 = ğºğ‘§â€²
ğ¶ğ¹ â† (ğ¶ğ‘‘, ğ¶ğ¸1, ğ¶ğ¸2)
ğ¶â€²
ğ‘‘, ğ¶â€²
ğ¹ â† (ğ¶â€²
ğ¸1, ğ¶â€²
ğ¸2)
ğ‘œ ğ‘“ â† (ğ‘§ + ğ‘§â€², ğ‘‘, (ğ¸1ğºğ‘Ÿğ‘›ğ‘‘, ğ¸2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘))
return (ğ¶ğ‘“ , ğ¶â€²
ğ‘“ , ğ‘œ ğ‘“ , ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡ , ğœ‹ğ‘Ÿğ‘’ğ‘Ÿğ‘ğ‘›ğ‘‘)
Figure 4: Construction of a senderâ€™s proof in our tree-
unlinkable scheme. This function constructs a proof that a user
has a valid forwarding credential, and additionally that ğ¶â€²
ğ¹ is a
commitment to the same message and a re-randomization of the
source of the forwarding credential in question.
Protocols using El-Gamal Encryption. Chase et al.â€™s algebraic
MAC (Section 5.1) relies on a number of protocols based on manip-
ulating El-Gamal ciphertexts, variants of which will also be used
in our scheme. These protocols all rely on the homomorphic prop-
erties of El-Gamal encryption, which allow users to re-randomize
ciphertexts without knowledge of the platformâ€™s secret key.
Similarly to the Chase et al. scheme, re-randomizing El-Gamal
ciphertexts will enable blind issuance and unlinkable presentation
of a MAC on hidden attributes in our scheme. We will use their
techniques to prove that a user possesses valid credentials to for-
ward a message. Whereas the original Chase et al. paper shows how
to prove that a commitment commits to the same value as a given
ciphertext, our protocol will augment theirs and show that a com-
mitment commits to a re-randomization of a given ciphertext. We
need the re-randomization to render the encryption of a message
authorâ€™s identity unlinkable to past forwards of the same message.
5.2 Our Construction
Our scheme requires a group G of prime order ğ‘ in which the dis-
crete log problem is hard and the 10 fixed group elements required
by the MAC described in Section 5.1.
We assume that each message ğ‘š can be hashed to a representa-
tion in Zğ‘, which we denote as ğ‘‘ â† ğ»(ğ‘š). We also assume that
each (ğ‘ ğ‘Ÿğ‘, md) pair corresponding to a source user and metadata
value have a reversible representation in G. Our scheme can easily
be extended if more than one element is needed to represent these
values.
Keys. Our scheme assumes that a platform has an El-Gamal key
pair (ğ‘¦, ğ‘Œ = ğº ğ‘¦) for ğ‘¦ âˆˆ Zğ‘. This is used for encrypting source
ciphertexts. The platform also has a MAC key skğ‘€ğ´ğ¶.
Authoring and forwarding data structure. Forwarding data fd
held by a user consists of a tuple (ğ‘š, (ğ¸1, ğ¸2), ğœ), where ğ‘š corre-
sponds to the message plaintext, (ğ¸1, ğ¸2) is an ElGamal encryp-
tion of some (ğ‘ ğ‘Ÿğ‘, md) pair ğ‘† âˆˆ G, and ğœ is a MAC on attributes
ğ‘‘ â† ğ»(ğ‘š), ğ¸1, ğ¸2.
2
, ğ¸(ğ´)
, ğ¸(ğ¹)
2
redeem(ğ¶ğ´, ğ‘ ğ‘Ÿğ‘, ğ‘œğ´, ğ¶ğ¹ , ğ‘œğ¹ , ğ‘¡ğ‘¦ğ‘ğ‘’, pk = ğ‘Œ)
(ğ¶ğ‘‘, ğ¶ğ¸1, ğ¶ğ¸2) â† ğ¶ğ¹ , (ğ¸(ğ´)
) â† ğ‘ ğ‘Ÿğ‘
1
(ğ‘§ğ¹ , ğ‘‘ğ¹ , ğ¸(ğ¹)
) â† ğ‘œğ¹ , (ğ‘§ğ´, ğ‘‘ğ´) â† ğ‘œğ´
1
â„, ğ‘Ÿ1, ğ‘Ÿ2, ğ‘Ÿ3, ğ‘Ÿğ‘›ğ‘‘ â†R Zğ‘, ğ» â† ğºâ„
)
(ğ´1, ğ´2) â† (ğºğ‘Ÿ1, ğ» ğ‘Ÿ1ğº
(ğµ1, ğµ2) â† (ğºğ‘Ÿ2, ğ» ğ‘Ÿ2 ğ¸(ğ‘¡ ğ‘¦ğ‘ğ‘’)
ğºğ‘Ÿğ‘›ğ‘‘)
(ğ¶1, ğ¶2) â† (ğºğ‘Ÿ3, ğ» ğ‘Ÿ3 ğ¸(ğ‘¡ ğ‘¦ğ‘ğ‘’)
ğ‘Œ ğ‘Ÿğ‘›ğ‘‘)
ğ‘ƒ1 â† ğ» = ğºâ„ âˆ§ ğ´1 = ğºğ‘Ÿ1 âˆ§ ğµ1 = ğºğ‘Ÿ2 âˆ§ ğ¶1 = ğºğ‘Ÿ3
ğ‘‘ğ‘¡ ğ‘¦ğ‘ğ‘’
ğ‘‘
1
2
âˆ§ ğ¶ğ´ = ğºğ‘‘ğ´
ğ‘¦3 âˆ§ ğ¶ğ‘‘ = ğºğ‘‘ğ¹
ğºğ‘§ğ´
ğ‘‘ âˆ§ ğµ2/ğ¸(ğ´)
ğ‘ƒğ´ â† ğ´2 = ğ» ğ‘Ÿ1ğºğ‘‘ğ´
1
ğ‘‘
ğ‘‘
ğºğ‘§ğ¹
ğ‘¦3
= ğ» ğ‘Ÿ2ğºğ‘Ÿğ‘›ğ‘‘
âˆ§ ğ¶2/ğ¸(ğ´)
2
= ğ» ğ‘Ÿ3ğ‘Œ ğ‘Ÿğ‘›ğ‘‘
ğ‘ƒğ¹ â† ğ´2 = ğ» ğ‘Ÿ1ğºğ‘‘ğ¹
ğ‘‘ âˆ§ ğµ2/ğ¶ğ¸1 = ğ» ğ‘Ÿ2ğºğ‘Ÿğ‘›ğ‘‘/ğºğ‘§ğ¹
ğ‘¦1
âˆ§ ğ¶2/ğ¶ğ¸2 = ğ» ğ‘Ÿ3ğ‘Œ ğ‘Ÿğ‘›ğ‘‘/ğºğ‘§ğ¹
ğ‘¦2
ğœ‹ â† ğ‘ƒğ¾ {(â„, ğ‘Ÿ1, ğ‘Ÿ2, ğ‘Ÿ3, ğ‘Ÿğ‘›ğ‘‘, ğ‘‘ğ´, ğ‘§ğ´, ğ‘‘ğ¹ , ğ‘§ğ¹) :
ğ‘ƒ1 âˆ§ (ğ‘ƒğ´ âˆ¨ ğ‘ƒğ¹)}
ğ‘–ğ‘›ğ‘“ ğ‘œ â† (ğ», (ğ´1, ğ´2), (ğµ1, ğµ2), (ğ¶1, ğ¶2))
return (ğœ‹, ğ‘–ğ‘›ğ‘“ ğ‘œ, â„, ğ¸(ğ‘¡ ğ‘¦ğ‘ğ‘’)