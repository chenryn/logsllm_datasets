PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
Prev_size
size
fd
Bk  
. . . . . .
P
FD
BK
Prev_size
size
fd
Bk 
. . . . . .
Prev_size
size
fd
Bk 
. . . . . .
free_addr
free_addr - 12
Shellcode_addr
(free_addr – 12) ->bk = 
shellcode_addr
shellcode_addr -> fd =  free_addr – 
12
free_addr = shellcode_addr
P->fd->bk = P->bk.
P->bk->fd = P->fd.
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
这样,当程序在代码[5]处再次执行free的时候，就会转而执行shellcode了:
在较低的glibc版本下,没有校验机制,利用程序能
够正常获得shell执行命令,但在新版本下的
glibc增加了对应的安全检查机制，执行exp将会
报错:
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
新版本的glibc malloc针对unlink利用主要增加了如下安全检测机制:
l Double Free检测
该机制不允许释放一个已经处于free状态的chunk。因此，当攻击者将second chunk的
size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前
的first chunk(我们需要free的chunk)已经处于free状态，那么这时候再free(first)
的话，就会报出double free错误。相关代码如下：
l next size非法检测
该机制检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next 
size为-4的时候，就会报出invalid next size错误。相关代码如下：
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
l 双链表冲突检测
该机制会在执行unlink操作的时候检测链表中前一个chunk的fd与后一个chunk的bk是否都
指向当前需要unlink的chunk。这样攻击者就无法替换second chunk的fd与fd了。相关代
码如下:
即便如此,依然有办法可以绕过unlink安全检测机制(比如伪造chunk等)
PWN基础入门
UAF
Ø 堆漏洞利用
HITCON-training 
从add_note菜单项，
我们可以看出程序最
多可以添加 5 个 note。
每个 note 有两个字
段 put 与 content，
其中 put 会被设置为
一个函数，其函数会
输出 content 具体的
内容。
PWN基础入门
UAF
Ø 堆漏洞利用
HITCON-training 
print_note 就是简单的根
据给定的 note 的索引来输
出对应索引的 note 的内容。
delete_note 会根据给定的索引来释
放对应的 note。但是值得注意的是，
在 删除的时候，只是单纯进行了 
free，而没有设置为 NULL，那么显
然，这里是存在 Use After Free 
漏洞的。
PWN基础入门
UAF
Ø 堆漏洞利用
HITCON-training 
如何利用UAF?
从add_note函数我们可以看出,一个note是8个字节,分
别存放put和content两个指针,然后程序根据输入的 
size来申请指定大小的内存,然后用来存储content,其
中put会被赋值为print_note_content函数地址,由于
程序里自带magic函数(读取flag),这里思路是修改
note的 put字段为magic函数的地址,这样当调用print 
note的时候就会直接执行magic函数,打印出flag!
put_ptr
content_ptr
content
PWN基础入门
UAF
Ø 堆漏洞利用
利用步骤如下:
1.Malloc note0,size =16,content = ‘aaaa’.
2.Malloc note1,size =16,content = ‘bbbb’.
3.Free note0.
4.Free note1.
5.Malloc note2,size = 8,conten = addr(magic)
6.Print note0,got the flag
Note0
fastbin[0] fastbin[1] fastbin[2] fastbin[3] …..
Note0_content:
aaaa
3
Note1
Note1_content:
bbbb
4
Size=16
Size=24
Size=32
Size=40
Note2
5
Note2_content:
Addr(magic)
3
4
6
PWN基础入门
Double free
Ø 堆漏洞利用
double free的原理其实和堆溢出的原理差不多，都是通过unlink这个双向链表删除的宏来利用
的，只是double free需要由自己来伪造整个chunk并且欺骗操作系统。
在堆漏洞利用里，很多都是基于触发unlink来实现任意代码执行的，double free也是基于此。不同于unlink的
是，unlink是利用溢出来伪造chunk，实现unlink的。而double free则一般是需要至少获得三个连续的chunk，
再全部free。之后再重新分配两个大chunk（能够覆盖前面free的三个chunk），通过伪造p（利用绕过unlink
的检查的技术伪造）chunk和一个引导触发unlink的chunk即可。
PWN基础入门
Double free
Ø 堆漏洞利用
待完善优化
PWN基础入门
Off-By-One
Ø 堆漏洞利用
off-by-one 利用思路:
溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，
或是覆盖其他块数据，也可使用 NULL 字节溢出的方法
溢出字节为 NULL 字节:在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_in_use 
位被清，这样前一堆块会被认为是 free 块。
(1)这时可以选择使用前面提到的 unlink 方法进行处理。
(2)另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。
此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的后一块（理论上是当
前正在 unlink 的块）与当前正在 unlink 的块大小是否相等。
Chunk Extend and Overlapping
chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk 
overlapping 的效果。这种利用方法需要以下的时机和条件：
•
程序中存在基于堆的漏洞
•
漏洞可以控制 chunk header 中的数据
PWN基础入门
Chunk Extend and Overlapping
Ø 堆漏洞利用
chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk 
overlapping 的效果。这种利用方法需要以下的时机和条件：
•
程序中存在基于堆的漏洞
•
漏洞可以控制 chunk header 中的数据
待完善优化
Gdb-  插件  gef!!
PWN基础入门
堆溢出利用--Malloc Maleficarum
Ø 堆漏洞利用
从 2004 年末开始，glibc malloc 变得更可靠了。之后，类似 unlink 的技巧已经废
弃，攻击者没有线索。但是在 2005 年末，Phantasmal Phatasmagoria 带来了下面
这些技巧，用于成功利用堆溢出:
House of Prime
House of Mind
House of Force
House of Lore
House of Spirit
…
待完善优化
PWN基础入门
Fast-Bin-Attack
Ø 堆漏洞利用
fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。
这类利用的前提是：
•
存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞
•
漏洞发生于 fastbin 类型的 chunk 中
如果细分的话，可以做如下的分类：
•
Fastbin Double Free
•
House of Spirit
•
Alloc to Stack
•
Arbitrary Alloc
其中，前两种主要漏洞侧重于利用 free 函数释放真的 chunk 或伪造的 chunk，然后
再次申请 chunk 进行攻击，后两种侧重于故意修改 fd 指针，直接利用 malloc 申请
指定位置 chunk 进行攻击。
PWN实例讲解与演示
第四部分
PWN解题总结
第五部分
根据比赛经验，CTF中PWN题目类型主要为如下几类:
PWN题目类型总结
PWN题目类型总结
PWN
Level 1:Basic Secuity Vulnerabilities
Level 2:Bypassing Exploit Mitigation Techniques 
Level 3:Heap Vulnerabilities
Stack
Heap
Bypass 
Canary,NX,PIE/ASLR
Stack Based Buffer Overflow
Integer Overflow
Off-By-One (Stack Based)
Heap overflow using unlink
Heap overflow using Malloc Maleficarum
Off-By-One (Heap Based)
Use After Free
Thank You!
谢谢！
北京朝阳区酒仙桥路6号院2号楼 100015
Building 2, 6 Haoyuan, Jiuxianqiao Road, Chaoyang 
District,Beijing,P.R.C. 100015
Tel +86 10 5682 2690   Fax +86 10 5682 2000