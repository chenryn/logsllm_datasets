~c = (M + eQ mod p1, M + eQ mod p2)
and output ~c.
• Dec(sk, ~c): Parse ~c into (c1, c2). Output M = (c1 ¯p1 +
c2 ¯p2 mod N ) mod Q.
• Add(~c1,··· , ~cℓ): OutputPℓ
wise integer additions.
i=1 ~ci through component-
Correctness We can easily verify the correctness of our
scheme. For a given fresh ciphertext ~c = (c1, c2) = (M +
eQ mod p1, M + eQ mod p2), it holds that
M + eQ ≡ c1 ¯p1 + c2 ¯p2 mod N
1, c′
c′
1 ¯p1 + c′
by the CRT and hence M ≡ (c1 ¯p1 + c2 ¯p2 mod N ) mod Q.
Assume that ~ci = (ci1, ci2) = (Mi+eiQ mod p1, Mi+eiQ mod
p2) are given for 1 ≤ i ≤ A. Let ~c′ = (c′
2) be the sum
of A ciphertexts ~ci’s deﬁned by ~c′ = (c′
1, c′
i=1 ~ci =
(cid:16)PA
i=1 ci1,PA
2) = PA
i=1 ci2(cid:17). Then the following relation holds:
AXi=1
and gives the correct valuePA
i=1 Mi mod Q if |PA
QPA
most 2γ−(ρ+⌈log Q⌉+2) fresh ciphertexts since |PA
QPA
i=1 Mi +
i=1 ei|  η + 1.
Using the union bound, we have
Pr[E] = Pr[[i,j
pi ≤ 1
for any si ∈ (− pi
Xj,i] ≤Xi,j
Pr[Xj,i] ≤Xi,j
Pr[Yj,i] ≤
2 ]] = 1
pi
(τ + 1)Q
2 , pi
2 , pi
2η−3
.
1
2 + ǫ
Now, we are ready to compute the advantage of B. Let
S be the event that B solves the given problem.
If b =
0, then A will correctly guess, so Pr[A succeeds|b = 0] =
1
2 + ǫ. If b = 1, the challenging ciphertext does not reveals
no information of b, so Pr[A succeeds|b = 1] = 1
2 . Hence,
Pr[S|¬E] = 1
2 . Therefore,
AdvB = (cid:12)(cid:12)(cid:12)(cid:12)Pr[S] −
2(cid:12)(cid:12)(cid:12)(cid:12) =(cid:12)(cid:12)(cid:12)(cid:12)Pr[S ∧ E] + Pr[S ∧ ¬E] −
= (cid:12)(cid:12)(cid:12)(cid:12)Pr[S|E] Pr[E] + Pr[S|¬E] Pr[¬E] −
2(cid:12)(cid:12)(cid:12)(cid:12)
= (cid:12)(cid:12)(cid:12)(cid:12)
2(cid:12)(cid:12)(cid:12)(cid:12)
= (cid:12)(cid:12)(cid:12)(cid:12)(cid:18)Pr[S|¬E] −
2(cid:18)1 − (τ + 1)
2η−3(cid:19) .
Since we assume Q < 2η−3−2λ and τ is polynomial in λ and
so τ < 2λ, (τ +1)Q
2η−3 < 2−λ. Therefore, the advantage of B is
2 (1−2−λ) and it is non-negligible in the security
larger than ǫ
parameter.
Pr[E] + Pr[S|¬E] Pr[¬E] −
ǫ
2(cid:19) Pr[¬E](cid:12)(cid:12)(cid:12)(cid:12) ≥
2(cid:12)(cid:12)(cid:12)(cid:12)
1
2
Q
1
1
1
1
3. OUR PUBLIC-KEY ADDITIVE HOMO-
MORPHIC ENCRYPTION
To convert our symmetric encryption to public key en-
cryption, basically we use the well-known technique, subset-
sum of zero encryptions, as in [47, 14, 15, 9]. However,
it is not enough for our construction since we cannot di-
rectly apply the classical leftover hash lemma due to our
ciphertext format, which is considered as not an element of
ﬁnite set but an element of inﬁnite set Z. Instead, we adopt
the technique used for similar purpose to ours in the recent
multilinear maps construction due to Coron, Lepoint, and
Tibouchi [13].
3.1 Construction
We present our public key construction for additive ho-
momorphic encryption. We begin with deﬁning some algo-
rithms along with their properties that will be used in both
our construction and security proof.
We consider an algorithm InstGen outputting two vectors
~b1 and ~b2 such that the half-open parallelepiped generated
by (~b1,~b2) satisﬁes the followings:
(1) It is contained in R = (−2η−2, 2η−2] × (−2η−2, 2η−2].
(2) It is suﬃciently large in the sense that | det B| ≥ 15 ·
22η−8 = 15
64 · volume(R), where B is the 2-by-2 matrix with
column vector ~bi.
It is not hard to design an eﬃciently computable InstGen;
290e.g., we can repeatedly generate ~bi’s at random until they
satisfy the above conditions.
In fact, we are interested in
InstGenAlg such that it uses an algorithm Alg as a subroutine
(in a black-box manner), which generates vectors with some
distribution, until the output vectors ~b1 and ~b2 satisfy the
above conditions.
More precisely, let Alg be a probabilistic algorithm taking
two η-bit primes p1, p2 and an integer Q as inputs and out-
putting an element ~c in Zp1 × Zp2 . If the input of Alg is clear
from the context, we often omit it. InstGenAlg takes p1, p2,
and Q as inputs and uses Alg as a subroutine by feeding p1,
InstGenAlg repeatedly runs Alg (each with fresh
p2 and Q.
randomness) to obtain ~a0, ~a1, ~a2 ∈ Z × Z until
~a0 ∈ (−2η−2,−(2η−3 + 2η−4)) × (−2η−2, −(2η−3 + 2η−4)),
~a1 ∈ (−2η−3,−(2η−3 + 2η−4)) × (2η−4, 2η−3),
~a2 ∈ (2η−4, 2η−3) × (−2η−3,−(2η−3 + 2η−4)),
and outputs ~b1 = ~a1 − ~a0 and ~b2 = ~a2 − ~a0. Then, it is
clear that InstGenAlg satisﬁes the above two conditions. Al-
gorithms Alg1 and Alg2 deﬁned in Section 2 are suitable
candidates for Alg which can be utilized in InstGenAlg. We
will construct our public key scheme with Alg1.
Now, we are ready to describe our public key construction
for additive homomorphic encryption.
SetupAlg1(1λ): Choose two η-bit primes p1 and p2 at ran-
dom and an integer Q for the message space. Run
InstGenAlg1(p1, p2, Q) to obtain ~b1 and ~b2. Run Alg1
to obtain a sequence of vectors (~x1, . . . , ~xm) such that
each ~xj is an output of Alg1 with taking independent
randomness and is contained in the half-open paral-
lelepiped generated by ~b1 and ~b2. Finally, set pk =
{N = p1p2, Q,~b1,~b2, ~x1, . . . , ~xm} and sk = {¯p1, ¯p2},
where ¯p1 = p2(p−1
1 mod
p2) mod N , and ZQ is the message space.
2 mod p1) mod N , ¯p2 = p1(p−1
Enc(pk, M ): Choose sj ← {0, 1}, ti ← [0, 2µ) ∩ Z for j ∈
{1, . . . , m} and i ∈ {0, 1}. Compute and output