title:teEther: Gnawing at Ethereum to Automatically Exploit Smart Contracts
author:Johannes Krupp and
Christian Rossow
teether: Gnawing at Ethereum to Automatically 
Exploit Smart Contracts
Johannes Krupp and Christian Rossow, CISPA, Saarland University, 
Saarland Informatics Campus
https://www.usenix.org/conference/usenixsecurity18/presentation/krupp
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.TEETHER: Gnawing at Ethereum to Automatically Exploit Smart Contracts
Johannes Krupp
CISPA, Saarland University,
Saarland Informatics Campus
Christian Rossow
CISPA, Saarland University,
Saarland Informatics Campus
Abstract
Cryptocurrencies like Bitcoin not only provide a decen-
tralized currency, but also provide a programmatic way
to process transactions. Ethereum, the second largest
cryptocurrency next to Bitcoin, is the ﬁrst to provide
a Turing-complete language to specify transaction pro-
cessing, thereby enabling so-called smart contracts. This
provides an opportune setting for attackers, as security
vulnerabilities are tightly intertwined with ﬁnancial gain.
In this paper, we consider the problem of automatic vul-
nerability identiﬁcation and exploit generation for smart
contracts. We develop a generic deﬁnition of vulnera-
ble contracts and use this to build TEETHER, a tool that
allows creating an exploit for a contract given only its bi-
nary bytecode. We perform a large-scale analysis of all
38,757 unique Ethereum contracts, 815 out of which our
tool ﬁnds working exploits for—completely automated.
1
Introduction
Cryptocurrencies are widely regarded as one of the
most disruptive technologies of the last years. Their
central value proposition is providing a decentralized
currency—not backed by banks, but built on concepts
of cryptography and distributed computing. This is
achieved by using a blockchain, a publicly veriﬁable
append-only data structure in which all transactions are
recorded. This data structure is maintained by a peer-
to-peer network. All nodes of this network follow a
consensus protocol that governs the processing of trans-
actions and keeps the blockchain in a consistent state.
Furthermore, the consensus protocol guarantees that the
blockchain cannot be modiﬁed by an attacker, unless
they control a signiﬁcant fraction of computation power
in the entire network.
In 2009, the ﬁrst cryptocurrency, Bitcoin [22], was
launched. Since then, it has seen an unprecedented hype
and has grown to a market capitalization of over 150 bil-
lion USD [1]. Although Bitcoin remains the predominant
cryptocurrency, it also inspired many derivative systems.
One of the most popular of these is Ethereum, the second
largest cryptocurrency by overall market value as of mid
2018 [1].
Ethereum heavily extends the way consensus proto-
cols handle transactions: While Bitcoin allows to specify
simple checks that are to be performed when processing
a transaction, Ethereum allows these rules to be speciﬁed
in a Turing-complete language. This makes Ethereum
the number one platform for so-called smart contracts.
A smart contract can be seen quite literally as a con-
tract that has been formalized in code. As such, smart
contracts can for example be used to implement fundrais-
ing schemes that automatically refund contributions un-
less a certain amount is raised in a given time, or shared
wallets that require transactions to be approved of by
multiple owners before execution. In Ethereum, smart
contracts are deﬁned in a high-level, JavaScript-like lan-
guage called Solidity [2] and is then compiled into a
bytecode representation suitable for consumption by the
Ethereum Virtual Machine (EVM). Parties can interact
with this contract through transactions in Ethereum. The
consensus protocol guarantees correct contract execution
in the EVM.
Of course, increased complexity comes at the cost of
increased risk—Ethereum’s Turing-complete Solidity is
more error-prone than the simple checks that can be spec-
iﬁed in Bitcoin. To make matters worse, once deployed,
smart contracts are immutable and cannot be patched or
updated. This causes an unparalleled coupling of soft-
ware vulnerabilities and ﬁnancial loss. In fact, since the
inception of Ethereum in 2015, several cases of smart
contract vulnerabilities have been observed [3, 4], caus-
ing a loss of tens of millions USD. As Ethereum is be-
coming more and more popular and valuable, the impact
of smart contract vulnerabilities will only increase.
In this work, we tackle the problem of automatic vul-
nerability discovery and, more precisely, automatic ex-
USENIX Association
27th USENIX Security Symposium    1317
ploit generation. Our attacker model assumes a regular
Ethereum user without special capabilities whose goal
it is to steal Ether from a given contract. Towards this,
we ﬁrst give a generic deﬁnition of contract vulnerabili-
ties. Our deﬁnition is based on the observation that value
transfer from one account (a contract) to another can only
occur under few and well-deﬁned conditions. In particu-
lar, we identify four critical, low-level EVM instructions
that are necessarily involved in a value transfer: One used
to create regular transactions (CALL), one for contract ter-
mination (SELFDESTRUCT), and two that can allow for
code injection (CALLCODE, DELEGATECALL).
We propose a methodology to ﬁnd vulnerable execu-
tion traces in a contract and employ symbolic execution
to automatically create an exploit. Our approach is as fol-
lows: We search for certain critical paths in a contract’s
control ﬂow graph. Speciﬁcally, we identify paths that
lead to a critical instruction, where the instruction’s ar-
guments can be controlled by an attacker. Once a path is
found, we leverage symbolic execution to turn this path
into a set of constraints. Using constraint solving we
can then infer the transactions an attacker has to perform
to trigger the vulnerability. The special execution envi-
ronment of smart contracts make this a non-trivial task.
Most notably we show how to handle hash values sym-
bolically, which are used extensively in smart contracts.
To demonstrate the utility of our methodology, we ﬁ-
nally perform a large-scale analysis of 38,757 unique
contracts extracted from the blockchain. TEETHER ﬁnds
exploits for 815 (2.10%) of those—completely auto-
mated, without the need for human intervention or man-
ual validation, and not requiring source code of contracts.
Due to code sharing this puts the funds of at least 1,731
accounts at risk. Furthermore, a case-study indicates,
that many of the underlying vulnerabilities are caused
by the design choices of Solidity and misunderstandings
about the EVM’s execution model.
We summarize our core contributions as follows:
1. We provide a generic deﬁnition of vulnerable con-
tracts, based on low-level EVM instructions (Sec-
tion 3).
2. We develop a tool TEETHER that provides end-to-
end exploit generation from a contract’s bytecode
only. To this end, we tackle several EVM-speciﬁc
challenges, such as novel methodologies to handle
hash values symbolically (Section 4).
3. We provide a large-scale vulnerability analysis
of 38,757 unique contracts extracted from the
Ethereum blockchain (Section 5).
2 Background
Ethereum is the second largest consensus-based transac-
tion system next to Bitcoin, with a current market capi-
talization of over 110 billion USD [1]. Ethereum is of-
ten described as a second-generation blockchain, due to
its support of so-called smart contracts—accounts con-
trolled only by code which can handle transactions fully
autonomously. In this section, we give a description of
smart contracts, the Ethereum virtual machine, as well as
the Ethereum execution model.
2.1 Transaction System
At the very core, Ethereum provides a public ledger for a
new cryptocurrency called Ether. It provides a mapping
between accounts—identiﬁed by a 160-bit address—and
their balance. This ledger is backed by a network of mu-
tually distrusting nodes, so-called miners. Users can sub-
mit transactions to the network in order to transfer Ether
to other users or to invoke smart contracts. Miners will
then process these transactions and, using a consensus
protocol, agree on the outcome thereof. A processing fee
is paid to the miner for each transaction to prevent re-
source exhaustion attacks on the network as well as to in-
centivize miners to process as many transactions as pos-
sible. All processed transactions are kept in a blockchain,
a public hash-based append-only log, which allows any-
one to verify the current state of the system.
2.2 Smart Contracts
A smart contract is a special type of Ethereum account
that is associated with a piece of code. Like regular ac-
counts, smart contracts can hold a balance of Ether. Ad-
ditionally, smart contracts also have a (private) storage—
a key-value store with 256-bit keys and 256-bit values.
This storage is only “private” in the sense that it cannot
be read or modiﬁed by other contracts, only by the con-
tract itself. Furthermore, the storage is not secret. In fact
is only cryptographically secured against external mod-
iﬁcations. As all transactions are recorded in the public
blockchain, the contents of a contract’s private storage
can be easily reconstructed by analyzing all transactions.
2.2.1 The Ethereum Virtual Machine (EVM)
The code of a smart contract is executed in a spe-
cial purpose virtual machine, the Ethereum Virtual Ma-
chine (EVM). The EVM is a stack-based virtual ma-
chine with a wordsize of 256 bit. Besides arithmetic and
control-ﬂow instructions, the EVM also offers special
instructions to access ﬁelds of the current transaction,
1318    27th USENIX Security Symposium
USENIX Association
modify the contract’s private storage, query the current
blockchain state, and even create further transactions1.
The EVM only provides integer arithmetic and cannot
handle ﬂoating point values. To be able to denote val-
ues smaller than 1 Ether, balance is expressed in Wei, the
smallest subdenomination of Ether. 1 Ether = 1018 Wei.
In addition to the 256 bit word stack and the persistent
storage the EVM also provides a byte-addressable mem-
ory, which serves as an input and output buffer to various
instructions. For example, the SHA3 instruction, which
computes a Keccak-256 hash over a variable length data,
reads its input from memory, where both the memory lo-
cation and length of the input are provided via two stack
arguments. Content of this memory is not persisted be-
tween contract executions, and the memory will always
be set to all zero at the beginning of contract execution.
2.2.2 Solidity
Smart contracts are usually written in Solidity [2], a high-
level language similar to JavaScript, and then compiled
to EVM bytecode. For ease of readability, we will use
Solidity in examples, however, our analysis is based on
EVM bytecode only and completely Solidity-agnostic.
Smart contracts can be created by anyone by sending a
special transaction to the zero address. After creation, the
code of a contract is immutable, which means that smart
contracts cannot be updated or patched. While some at-
tempts have been made to create “updatable” contracts
that only act as a front-end and delegate actual execution
to another, updatable contract address, in most cases cre-
ating a new contract with updated code and transferring
funds is the only option—given that funds can still be
reclaimed from the old contract2.
An example smart contract is given in Figure 1. This
smart contract models a wallet, which allows to deposit
and withdraw money (deposit, withdraw) as well as
to transfer ownership of the wallet (changeOwner). In
Solidity, a function with the same name as the contract is
considered a constructor (Wallet). The constructor code
is only executed once during contract creation and is not
part of the contract code afterwards.
Furthermore, Solidity has the concept of modiﬁers.
Modiﬁers are special functions with a placeholder ( ) that
allow to “wrap” other functions. Modiﬁers are often used
to implement sanity or security checks. For instance, the
example contract deﬁnes a modiﬁer onlyOwner, which
checks if the sender of the current transaction is equal to
the stored owner of the wallet. Only if the check suc-
1The original Ethereum paper [25] distinguishes between transac-
tions, which are signed by regular accounts, and messages, which are
not. For simplicity we will refer to both as transactions in this paper.
2https://np.reddit.com/r/ethereum/comments/3l6b6b/
fuck i just send all my ether to a new contract/
owner = msg.sender;
// constructor
function Wallet(){
}
modifier onlyOwner{
require(msg.sender == owner);
;
function changeOwner(address newOwner)
onlyOwner {
}
owner = newOwner;
}
1 contract Wallet{
address owner;
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
}
function deposit()
payable {
}
function withdraw(uint amount)
onlyOwner {
}
owner.transfer(amount);
Figure 1: A contract that models a wallet.
ceeds the actual function is executed. This is used to en-
sure that only the owner of the wallet can perform with-
draw money or transfer ownership.
2.2.3 Transactions
In Ethereum, all interactions between accounts happens
through transactions. The most important ﬁelds of a
transaction are to, sender, value, data, and gas.
sender and to are the sender and receiver of a trans-
action respectively. In a normal transaction between two
regular accounts, value denotes the amount to be trans-
ferred while data can be used as a payment reference. A
simple function call on a smart contract on the other hand
is a transaction with a value of 0 and data the input
data to the contract. By convention, Solidity uses the ﬁrst
four bytes of data as a function identiﬁer, followed by
the function arguments. The function identiﬁer is com-
puted as the ﬁrst four bytes of the Keccak-256 hash of the
function’s signature. E.g., to call the withdraw function,
data would consist of the bytes 2e1a7d4d, followed by
the amount to be withdrawn in Wei as a 256-bit word.
Functions marked as payable, as for example deposit
in Figure 1 can also be invoked through transactions with
a non-zero value. In this case, the transferred value is
USENIX Association
27th USENIX Security Symposium    1319
added to the contract’s balance.
The concept of “functions” and “modiﬁers” only ex-
ists at the level of Solidity, not at the bytecode-level of
the EVM. At EVM level, a smart contract is just a single
string of bytecode, and execution always starts at the ﬁrst
instruction. This is why compiled contracts usually start
with a sequence of branches, each comparing the ﬁrst
four bytes of data to the contract’s function signatures.
A transaction also speciﬁes the transaction fee a
miner gets for processing the transaction. To this end,
Ethereum uses the concept of “gas”: Every instruction
that is executed by a miner in order to process the trans-
action consumes a certain amount of gas. Gas consump-
tion depends on the instruction type to model the actual
work performed by the miner. For example, a simple
addition consumes 3 units of gas, whereas access to the
contract’s storage consumes 20000. The transaction ﬁeld
gas therefore speciﬁes the maximum amount of gas that
may be consumed in processing the transaction. When
this limit is exceeded, processing of the transaction is
aborted. However, the processing fee is still deducted.
2.3 Notation
Keeping our terminology close to the formal speciﬁca-
tion of Ethereum [25], we use the following notation: We
use µ to denote an EVM machine state with memory µm
and stack µs. Furthermore, we use I to refer to a trans-
action’s execution environment, in particular, we use Id
as the data ﬁeld of the transaction and Iv as its value.
Finally, S refers to a contract’s storage.
2.4 Attacker Model
For the attacks considered in this paper we do not require
special capabilities from the attacker. An attacker needs
only be able to (i) obtain a contract’s bytecode (in order
to generate an exploit) and (ii) to submit transactions to
the Ethereum network (to execute the exploit). The fact
that both of these are trivial to accomplish serves to stress