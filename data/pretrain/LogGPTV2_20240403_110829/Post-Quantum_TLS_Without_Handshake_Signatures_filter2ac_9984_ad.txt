message. As a result, the adversary facilitates all interactions, even
between honest parties.
The adversary interacts with honest parties via several queries.
The first two queries model the typical protocol functionality, which
is now under the control of the adversary:
Post-Quantum TLS Without Handshake Signatures
CCS ’20, November 9–13, 2020, Virtual Event, USA
intended partner and role.
• NewSession: Creates a new session at a party with a specified
• Send: Delivers a message to a session at a party, which ex-
ecutes the protocol based on its current state, updates its
state, and returns any outgoing protocol message.
The next two queries model the adversary’s ability to compromise
parties’ secret information:
• Reveal: Gives the adversary the key established in a particu-
lar stage. This key, and the key at the partner session (if it
exists), is marked as revealed.
• Corrupt: Gives the adversary a party’s long-term secret key.
This party is marked as corrupted.
The Reveal and Corrupt queries may make a stage unfresh, meaning
the adversary has learned sufficiently much information that no
security can be expected of this key.
The final query models the challenge to the adversary of breaking
a key established in a stage:
• Test: For a session and stage chosen by the adversary, returns
either the real key for that stage, or a uniformly random key,
depending on a hidden bit 𝑏 fixed throughout the experiment.
Some additional conditions apply to the handling of queries. For
keys marked as intended for internal use, the execution of the Send
query pauses at the moment the key is accepted, giving the adver-
sary the option to either Test that key or continue without testing.
This is required since internal keys may be used immediately for,
e.g., handshake encryption, and giving the adversary to Test the key
after it has already started being used to encrypt data would allow
the adversary to trivially win. For keys that are not considered
authenticated at the time of the Test query, the query is only per-
mitted if the session has an honest contributive partner, otherwise
the adversary could trivially win by active impersonation.
4.2 Security properties
A sequence of works [25, 26, 41] split AKE security into two distinct
properties: the traditional session-key indistinguishability property
dating back to Bellare and Rogaway [6], and a property called
Match-security, which models the soundness of the session identi-
fier, ensuring that the session identifier 𝜋 .sid properly matches the
partnered 𝜋′.sid and the correctness property that partnered ses-
sions compute the same session key. For well-chosen session iden-
tifiers, proving the technical properties of Match-security typically
does not depend on any cryptographic assumptions, and instead
follows syntactically. This is indeed the case for both TLS 1.3 and
KEMTLS, although for KEMTLS we account for correctness-error
in KEMs: the small chance that some PQ KEMs have of both parties
not computing the same shared secret. Details are in Appendix B.4.
4.2.1 Multi-Stage security. The Multi-Stage model captures both
key indistinguishability and authentication properties, which we
describe below. Details of the experiment appear in Appendix B.5.
Key indistinguishability. Secrecy of the key established in each
stage is through indistinguishability from random following Bellare–
Rogaway [6]. This property is defined via an experiment with the
syntax and adversary interaction as specified above. The goal of the
adversary is to guess the hidden, uniformly random bit 𝑏 which was
used to answer Test queries: was the adversary given real or ran-
dom keys? As noted above, the experiment imposes constraints on
Reveal queries to prevent the adversary from revealing and testing
the same key of some stage in a session or its partner. Depending on
the intended forward secrecy goals of the stage key, some Corrupt
queries may also be prohibited as described below to prevent the
adversary from actively impersonating a party in an unauthenti-
cated session then testing that key. We measure the adversary’s
advantage in guessing 𝑏 better than just flipping a coin.
Forward secrecy and implicit authentication. Our multi-stage
security definition incorporates three notions of forward secrecy
[68, 69] for stage keys:
• Weak forward secrecy level 1 (wfs1): The stage key is indis-
tinguishable against adversaries who were passive in the
test stage (even if the adversary obtains the peer’s long-term
secret key at any point in time—before or after the stage key
was accepted). These keys have no authentication.
• Weak forward secrecy level 2 (wfs2): The stage key is indistin-
guishable against adversaries who were passive in the test
stage (wfs1) or if the adversary never corrupted the peer’s
long-term key. These keys are implicitly authenticated if the
adversary did not corrupt the peer’s long-term key before
the stage key was accepted.
• Forward secrecy (fs): The stage key is indistinguishable against
adversaries who were passive in the test stage (wfs1) or if the
adversary did not corrupt the peer’s long-term key before
the stage accepted. These keys are implicitly authenticated.
These correspond to forward-secrecy levels 1, 3, and 5 in the Noise
protocol framework [89].
Explicit authentication. We add an explicit authentication notion
to the multi-stage model, where the adversary also wins if it causes
a supposedly explicitly authenticated stage to accept without a
partner stage (called malicious acceptance).
Properties of KEMTLS. For KEMTLS, the properties of each stage
key in a client instance are as follows:
• Stages 1 and 2: wfs1 from when they are accepted, retroactive
fs once stage 6 has accepted. No authentication at the time
of acceptance, retroactive explicit authentication once stage
6 has accepted. For internal use.
• Stages 3, 4, and 5: wfs2 from when they are accepted, retroac-
tive fs once stage 6 has accepted. Implicit authentication at
the time of acceptance, retroactive explicit authentication
once stage 6 has accepted. Stages 3 and 4 are for internal use;
stage 5 for external use.
• Stage 6: fs and explicit authentication from the time of ac-
ceptance; for external use.
All stage keys in a server instance of KEMTLS have wfs1 security
and are unauthenticated; they have the same internal/external key
use as the client.
The following theorem says that KEMTLS is Multi-Stage-secure
with respect to the forward secrecy, authentication, and inter-
nal/external key-use properties as specified above, assuming that
the hash function H is collision-resistant, HKDF is a pseudorandom
function in either its “salt” or “input keying material” arguments,
HMAC is a secure MAC, KEMs is an IND-CCA-secure KEM, and
CCS ’20, November 9–13, 2020, Virtual Event, USA
Schwabe, Stebila, Wiggers
(cid:32) 𝜖IND-1CCA
(cid:32) 𝜖IND-CCA
KEMe
+2 𝜖dual-PRF-sec
HKDF.Ext
KEMs
+3 𝜖PRF-sec
HKDF.Exp
+ 𝜖PRF-sec
HKDF.Ext
+ 4 𝜖PRF-sec
HKDF.Exp
+ 2 𝜖dual-PRF-sec
HKDF.Ext
+ 𝜖EUF-CMA
HMAC
𝑛𝑠
+2𝑛𝑢
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
(cid:33)
(cid:33)(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172) .
KEMe is an IND-1CCA-secure KEM (i.e., KEMe is secure if a single
decapsulation query is allowed).
Theorem 4.1. Let A be an algorithm, and let 𝑛𝑠 be the number of
sessions and 𝑛𝑢 be the number of parties. Then the advantage of A
in breaking the multi-stage security of KEMTLS is upper-bounded by
𝑛2
2|nonce| + 𝜖COLL
𝑠
H
+ 6𝑛𝑠 ·
𝑌 ,B𝑖
Above we use the shorthand notation 𝜖𝑋
for reduc-
tions B𝑖 that are described in the proof. The proof of Theorem 4.1
appears in Appendix B.5; here we provide a sketch. The proof pro-
ceeds by a sequence of games, and splits into several cases.
𝑌 = Adv𝑋
We start off with game hops that assume that there are no reused
nonces among the honest session and that there are no collisions
in any hash function calls, which will be useful in later parts of the
proof. The Multi-Stage security experiment is formulated to allow
the adversary to make multiple Test queries. In the next game hop,
we restrict the adversary to make a single Test query by guessing
a to-be-tested session using a hybrid argument [50]; this incurs a
tightness loss 6𝑛𝑠 related to the number of sessions and stages.
The proof then splits into three cases: case A where the (now
single) tested session has an honest contributive partner in the first
stage; case B where the tested does not have an honest contributive
partner in the first stage and the adversary never corrupts the peer’s
long-term key; and case C where the tested session does not have
an honest contributive partner in the first stage and the adversary
does not corrupt the peer’s long-term key before the tested stage
has accepted. These three cases effectively correspond to the three
forward-secrecy levels wfs1, wfs2, and fs.
Case A. Here we assume that there does exist an honest contribu-
tive partner to at least the first stage of the tested session. When the
tested session is a client session, this means that the adversary did
not interfere with the ephemeral key exchange in the ClientHello
and ServerHello messages, so the ephemeral shared secret is un-
known to the adversary assuming a secure KEMe.
However, when the tested session is a server session, we only
have the guarantee that the adversary faithfully delivered the
ClientHello to the server; the adversary could have sent its own
ServerHello message to the client. This is valid adversary be-
haviour, and such an adversary would be able to compute the hand-
shake encryption keys. In this case we need to correctly respond
to the adversary, but in our simulation we do not have the KEMe
secret key, thus we need to make a single query to a decapsula-
tion oracle. This is why we rely on IND-1CCA security, the single-
decapsulation-query version of IND-CCA, rather than IND-CPA as
might be expected for passive security.5
All keys derived from this are thus also indistinguishable from
random, and the remainder of case A is a sequence of game hops
which, one-by-one, replace derived secrets and stage keys with
random values, under the PRF-security or dual-PRF-security [4]
5This is analogous to the proofs of signed-Diffie–Hellman in TLS 1.2 [59, 71] and TLS
1.3 [38, 39] that use a single query to a PRF-ODH oracle.
of HKDF (dual-PRF-security arises since the TLS 1.3 and KEM-
TLS key schedules sometime use secrets in the “salt” argument of
HKDF.Extract, rather than the “input keying material argument”).
This yields the required wfs1 property for all stage keys.
Case B. Lacking an honest contributive partner in the first stage
means the adversary was actively impersonating the peer to the
tested session, and there is no partner at any stage of that session. As
KEMTLS only provides server-to-client authentication, the tested
session in case B is a client session. In case B we assume the server’s
long-term key is never compromised. This allows us to rely on the
security of encapsulations under the server’s long-term key.
Case B’s sequence of game hops is as follows. First, we guess
the identity of the server 𝑆 that the adversary will attempt to im-
personate to the client in the tested session. Then we replace with
a random value the shared secret ss𝑆 that the client encapsulated
against the intended server’s long-term static key pk𝑆. If KEMs is
IND-CCA-secure, only the intended server should be able to de-
capsulate and recover ss𝑆, and thus ss𝑆, and any key derived from
it (following a sequence of game hops involving the security of
HKDF), is an implicitly authenticated key unknown to the adver-
sary. This yields the indistinguishability of the stage 3-6 keys under
the conditions of case B, and hence their required wfs2 properties.
Case C. Case C and case B differ only if the adversary does cor-
rupt the intended peer’s long-term key after the tested session
accepts in stage 6. Our reduction from IND-CCA security of KEMs
in case B runs into a problem: how to correctly answer the ad-
versary’s Corrupt query. Up until this bad query occurs, however,
our IND-CCA reduction (and indeed, every reduction in case B) is
fine, and all keys in the tested client session can be shown indistin-
guishable from random. This includes key fk𝑠 that the server uses
for the MAC authenticating the transcript in the ServerFinished
message. If the client accepts SF in case C — without a partner to
stage 6 — then the adversary has forged an HMAC tag.
Contrapositively, assuming all the cryptographic primitives are
secure, no stage accepts under the conditions of case C. This yields
explicit server-to-client authentication of stage 6 (and retroactive
authentication of all previous stages once stage 6 accepts, since
their session identifiers are substrings of the stage-6 sid). This also
yields forward secrecy (fs) of the stage-6 key at the client, and
retroactive fs of all stage keys at the client.
4.3 Discussion of security properties
Strength of the ephemeral KEM. The proof requires that the
ephemeral KEM be slightly stronger than passive IND-CPA security:
that it be secure against a single decapsulation query (IND-1CCA).
This is subtle and counterintuitive: one might expect that IND-CPA
would be enough for ephemeral key exchange (indeed, we missed
this in an earlier draft of this paper). However, in an AKE security
model that replaces the public key of the client and the ciphertext
of the server, but allows the adversary to send a different ciphertext
back to the client without invalidating the target session at the
server, this is unavoidable [59, 71]. An IND-CCA KEM certainly
suffices for the ephemeral KEM, but for most known PQ candidates
this incurs the cost of re-encryption using the Fujisaki–Okamoto
(FO) transform [45]. There are concrete attacks against several non-
FO-protected lattice- and isogeny-based KEMs using a few thousand
Post-Quantum TLS Without Handshake Signatures
CCS ’20, November 9–13, 2020, Virtual Event, USA
decapsulation queries [42, 46], but none with just a single query.
We leave as an open question to what extent non-FO-protected
post-quantum KEMs may be secure against a single decapsulation
query, but at this point IND-CCA is the safe choice.
Tightness. Theorem 4.1 is non-tight, due to hybrid and guessing
arguments. While it is certainly desirable to have tight results,
only a few authenticated-key-exchange protocols have tight proofs,
most of which with specialized designs. Most previous results on
TLS 1.3 [38, 39] are similarly non-tight, except for very recent work
[34] which reduces from multi-user security of the symmetric en-
cryption scheme, MAC, KDF, and signature scheme, and the strong
Diffie–Hellman assumption. As of this writing, none of the IND-
CCA NIST round-3 KEMs have tight proofs in a multi-user model,
although there is some work in that direction for Regev’s original
scheme and a variant of Frodo [111]. One can view a non-tight re-
sult such as Theorem 4.1 as providing heuristic justification of the
soundness of the protocol design, and one can in principle choose
parameters for the cryptographic primitives that yield meaningful
advantage bounds based on the non-tight reductions.
Quantum adversaries. The proof of Theorem 4.1 proceeds in the
standard model (without random oracles), and does not rely on
techniques such as the forking lemma or rewinding, so techniques
like Song’s “lifting lemma” [104] could be applied to show that
KEMTLS is secure against quantum adversaries, provided that each
of the primitives used is also secure against quantum adversaries.
Negotiation and downgrade resilience. We do not explicitly
model algorithm negotiation in KEMTLS, but it merits consideration
given the likelihood that any deployment of KEMTLS would support
multiple algorithms within KEMTLS, and might also be running in
parallel with a TLS 1.3 implementation. We consider adversarial
downgrades among each of the following negotiated choices:
• Protocol: KEMTLS versus TLS 1.3.
• Ephemeral key exchange: which KEM within KEMTLS, or
which group if downgraded to DH/ECDH in TLS 1.3.
• Authenticated encryption and hash function.
• Public key authentication: which KEM within KEMTLS, or
which signature scheme if downgraded to TLS 1.3.
We consider three levels of downgrade resilience:
1) Full downgrade resilience: the adversary cannot cause a party
to use any algorithm other than the one that would be used between