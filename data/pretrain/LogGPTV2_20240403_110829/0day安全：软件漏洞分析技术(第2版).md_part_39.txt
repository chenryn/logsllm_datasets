寄存器，如表7-2-1所示。接下来我们来看看各寄存器的主要作用。
表7-2-1不同处理器模式下ARM物理寄存器
用户横式系统横式特权横式中止横式未定义指令横式外部中断横式
快速中断横式
RO
RO
RO
RO
RO
RO
RO
212
---
## Page 238
第
续表
7
用户模式
系统横式
特权模式
中止模式
未定义指令模式
外部中断横式
快速中断模式
章
R1
R1
R1
A
R1
R1
R1
手
R2
R2
R2
R2
R2
R2
R2
机
R3
R3
R3
R3
R3
R3
R3
里
R4
R4
R4
R4
R4
R4
R4
的
R5
R5
R5
R5
R5
R5
R5
缓
R6
R6
R6
R6
R6
冲
R6
R6
区
R7
R7
R7
R7
R7
R7
R7
期
R8
R8
R8
R8
R8
R8
R8_fiq
出
R9
R9
R9
R9
R9
R9
R9_fiq
R10
R10
R10
R10
R10
R10
R10_fiq
R11
R11
R11
R11
R11
R11
R11_fiq
R12
R12
R12
R12
R12
R12
R12_fiq
R13
R13
R13_svc
R13_abt
R13_und
R13_irq
R13_fiq
R14
R14
R14_svc
R14_abt
R14_und
R14_irq
R14_fiq
PC
PC
PC
PC
PC
PC
PC
CPSR
CPSR
CPSR
CPSR
CPSR
CPSR
CPSR
SPSR_svc
SPSR_abt
SPSR_und
SPSR_irq
SPSR_fiq
1.未分组寄存器R0~R7
场合都可以使用未分组寄存器。但有一点需要注意，未分组寄存器不会因为处理器模式的改变
而更改指向的寄存器，因此在所有的处理器模式下未分组寄存器都指向同一个寄存器，当中断
或异常处理造成处理器模式转换的时候，由于不同的处理器模式使用了相同的物理寄存器，这
就有可能造成寄存器中的数据被破坏。
2.分组寄存器R8~R14
对于分组寄存器，他们每一次所访问的物理寄存器与处理器当前的运行模式有关。例如在
快速中断模式下R8~R12访问寄存器R8_fiq~R12_fiq：而在其他模式下R8~R12又访问寄存
器R8_usr~R12_usr。因此它们每个对应着两个不同的物理寄存器。
对于R13、R14来说，每个寄存器对应6个不同的物理寄存器，其中的一个是用户模式与
系统模式共用，另外5个物理寄存器对应于其他5种不同的运行模式。采用以下的记号来区分
不同的物理寄存器：
R13_
R14_
其中，mode为以下几种模式之一：usr、fiq、irq、svc、abt、und。
寄存器R13在ARM指令还有着一个非常重要的作用，通常它被用做堆栈指针，当然这只
213
---
## Page 239
0
day
是一种习惯用法，用户也可使用其他的寄存器作为堆栈指针，但在Thumb指令集中，某些指
安
令强制性地要求使用R13作为堆栈指针。由于处理器的每种运行模式均有自己独立的物理寄存
全：
器R13，在用户应用程序的初始化部分，一般都要初始化每种模式下的R13，使其指向该运行
模式的栈空间，这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指
软
向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以保证异常
件
漏
发生后程序的正常执行。
洞
R14也称做子程序连接寄存器（SubroutineLinkRegister）或连接寄存器LR。当执行BL
分
子程序调用指令时，R14中得到R15（程序计数器PC）的备份。其他情况下，R14用做通用寄
析
存器。与之类似，当发生中断或异常时，对应的分组寄存器R14_svc、R14_irq、R14_fiq、R14_abt
技
术
和R14_und用来保存R15的返回值。
（第
每一种处理器模式在自己的物理R14中存放当前子程序的返回地址。当通过BL或者BLX
2
序计数器PC中时，就实现了子程序返回。该功能可以靠以下指令来完成：
版
1.执行以下任意一条指令：
MOVPC,LR
BXLR
2.在子程序入口处使用以下指令将R14存入堆栈：
STMFDSP！，（,R）
对应地，使用以下指令可以完成子程序返回：
LDMFDSP!,（,PC)
当发生异常中断的时候，该模式下的特定物理R14被设置成该异常模式将要返回的地址。
3.程序计数器（PC指针）R15
由于ARM处理器采用的是流水线机制，当正确地读取了PC值时，该值为当前指令地址
值加8字节。也就是说对于ARM指令来说，PC指向当前指令的下两条指令的地址，由于ARM
指令是字对齐的，PC值的第0位和第1位总是为0。当成功地向PC写入一个地址数值时，程
序将跳转到该地址执行。在ARM系统进行代码级调试时对于R13、R14及R15的跟踪很重要，
可以用来分析系统堆栈及PC指针值的变化等。
R15虽然也可用做通用寄存器，但一般不这么使用，因为对R15的使用有一些特殊的限制，
当违反了这些限制时，程序的执行结果是未知的。
4.寄存器R16
寄存器R16用做当前程序状态寄存器（CurrentProgramStatusRegister），可在任何运行模
式下被访问，它包括条件标志位、中断禁正位、当前处理器模式标志位，以及其他一些相关的
控制和状态位。
每一种运行模式下又都有一个专用的物理状态寄存器，称为备份的程序状态寄存器（Saved
214
---
## Page 240
第
ProgramStatusRegister），当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时则可
7
由SPSR来恢复CPSR。
章
由于用户模式和系统模式不属于异常模式，他们没有SPSR，当在这两种模式下访问SPSR，
手
结果是未知的。
机
里
7.2.3ARM汇编指令结构
的
ARM微处理器的在较新的体系结构中支持两种指令集：ARM指令集和Thumb指令集。
缓
冲
其中，ARM指令为32位的长度，Thumb指令为16位长度。Thumb指令集为ARM指令集的
区
功能子集，但与等价的ARM代码相比较，可节省30%～40%以上的存储空间，同时具备32位
期
代码的所有优点。
出
ARM指令由操作码字段和操作数字段两部分组成。操作码字段指示处理器所要执行的操
作，而操作数字段则指出在指令执行操作的过程中所需要的操作数。
ARM指令的基本格式如下：
其中：
opcode
指令助记符，如LDR.STR等。
cond
执行条件，如EQ、NE等。
S
是否影响CPSR寄存器的值，书写时影响CPSR
Rd
目标寄存器。
Rn
第一个操作数的寄存器。
operand2
第二个操作数。
符号内的项是必须的，（）符号内的项是可选的。例如：
LDR
RO,[R1]
：读取R1地址上的存储器单元内容，即R0一[R1]
BEQ
Lable
：跳转指令B，执行条件EQ，即相等则程序跳转到Lable处
ADD
R1，R1，R2：加法指令，R1+R2→R1，即R1+R2的结果送给R1
ADDS
R1，R1，#1：加法指令，R1+1一R1，并影响状态寄存器（S）
ARM的指令集可以分为存储器访问指令、数据处理指令、跳转指令、协处理器指令、杂
项指令和伪指令六大类。接下来我们简单介绍一下这六大类指令。
1.存储器访问指令
存储器访问指令用于在寄存器和存储器之间传送数据，它可以分为加载和存储两类指令，
其中加载指令用于将存储器中的数据传送到寄存器，存储指令则完成相反的操作。这些指令如
表7-2-2所示。
表7-2-2存储器访问指令
助记符
指令功能描述
格式
示例
LDM
批量加载
LDM1AR0!(R3-R9}：将存储器地址为
LDM{cond){mode}Rn{!}，Reg列表
RO的数据加载到R3~R9中
215
---
## Page 241
0
day
续表
安
助记符
指令功能描述
格
式
示
例
全
LDR
加载字数据
LDR|cond}Rd,地址
LDRR0.[R1]：将存储器地址为R1的字
：
数据读入寄存器RO
软
LDRBR0[RI]：将存储器地址为R1的
件
LDRB
加载字节数据
漏
LDR{cond} B Rd,地址
字节数据读入寄存器RO，并将RO的高
洞
24位清零
分
LDRHRO.[R1]：将存储器地址为R1
析
LDRH
加载半字数据
LDR(cond} H Rd,地址:
的半字数据读入寄存器R0.并将R0的高
技
16位清零
术
STR
存储字数据
STR(cond}
Rd,地址
STRRO,[R1]：将R0中的字数据写入以
第
R1为地址的存储器中
STRBRO.[RI]：将寄存器RO中的字节
2
STRB
存储字节数据
STR{cond} B Rd, 地址
版
数据写入以R1为地址的存储器中
STRH
STR(cond) HRd, 地址:
STRHRO,[R1]：将寄存器R0中的半字
数据写入以R1为地址的存储器中
STM
批量存储