Exploitations of XNU Port Type Confusions
Tielei Wang
The background
Background of the talk
iOS 14.2, released on Nov 5, 
2020, ﬁxed an in-the-wild exploit 
reported by Google Project 0.
First in-the-wild exploit since iOS 14 (?)
Safari RCE (CVE-2020-27930)
kernel info leak (CVE-2020-27950)
kernel type confusion (CVE-2020-27932)
Background of the talk
• While analyzing CVE-2020-27932, we discovered a new variant issue in the 
XNU kernel - a port type confusion vulnerability
• We analyzed the root cause of the vulnerability at Zer0Con 2021, and 
presented a way to gain the root privilege on macOS Big Sur on Apple 
Silicon M1
• Today: share more attempts to exploit the port type confusion issue
A brief introduction of Mach ports
• XNU - X is Not Unix
• Mach
• BSD
• IOKits
A brief introduction of Mach ports
• XNU - X is Not Unix                Hybrid kernel
• Mach                                
• BSD
• IOKits
☜
A brief introduction of Mach ports
• XNU - X is Not Unix                Hybrid kernel
• Mach                                     Microkernel  
• BSD
• IOKits
☜
☜
A brief introduction of Mach ports
• XNU - X is Not Unix                Hybrid kernel
• Mach                                     Microkernel  
• BSD
• IOKits
☜
☜
A fundamental design: Inter-process communication (IPC)   
A brief introduction of Mach ports
• XNU - X is Not Unix                Hybrid kernel
• Mach                                     Microkernel  
• BSD
• IOKits
☜
☜
A fundamental design: Inter-process communication (IPC)   
Mach Port
Mach port vs UNIX ﬁle
Userspace
integer
integer 
Usage
mach_msg_send
mach_msg_receive
write
read
Permissions
send right
receive right
send-once right
O_RDONLY
O_WRONLY
O_RDWR
NameSpace
per-task
per-proc
Kernel
struct ipc_port 
struct ﬁleproc
Opaque objects
task, thread, voucher…  
vnode, socket, device… 
Mach ports are far more complicated and powerful! 
• A mach port is a kernel-maintained message queue
• multiple sender, single receiver
• Mach messages can carry both port rights, memory, and inline raw data 
Body
optional
mach_msg_*_descriptor
Header
Destination
Port Rights
Memory
Inline data
☜ Transfer port send/recv rights to destination
Mach ports are far more complicated and powerful! 
• While sending a message to a port, the kernel either appends the message 
to the queue, or directly handles the message sent to the kernel objects
ipc_port 
mach_msg_send
mach_msg_receive
ipc_mqueue 
Kernel
Userspace
mach_msg_send
Kernel 
Objects
ipc_mqueue_send
ipc_port at ﬁrst glance
kobject
io_lock_data
ipc_port 
io_references
io_bits
…
…
☜ The type info of the port
☜ The nullable kernel object behind the port
Review port’s io_bits 
Review port’s io_bits 
0x80000000
e.g., a regular port’s io_bits
IO_BITS_ACTIVE
Review port’s io_bits 
0x8000081d
e.g., a userclient port’s io_bits
IO_BITS_ACTIVE
IO_BITS_KOBJECT
IKOT_IOKIT_CONNECT
Review port’s io_bits 
0x80000825
e.g., a voucher port’s io_bits
IO_BITS_ACTIVE
IO_BITS_KOBJECT
IKOT_VOUCHER
Task
task_suspend, task_resume, task_set_exception_ports
task_get_exception_ports, thread_create
Thread
thread_set_state, thread_suspend
thread_resume
Memory
mach_vm_read, mach_vm_write
mach_vm_allocate, mach_vm_protect
IOKit
IOConnectCallMethod
Host
host_info, host_get_io_master, host_processors
Processor
processor_info, processor_control, processor_assign
Misc
Clock/voucher/semaphore
Powerful interfaces
Getting a send right to the (fake) kernel_task has been 
used for a long time in jailbreak developments 
Powerful interfaces
Other outdated tricks: based on ROP-based code execution 
in a system service, sending the service’s task/thread ports, 
or creating an IOKit userclient,  and sending them back to 
the attacker process
Task
task_suspend, task_resume, task_set_exception_ports
task_get_exception_ports, thread_create
Thread
thread_set_state, thread_suspend
thread_resume
Memory
mach_vm_read, mach_vm_write
mach_vm_allocate, mach_vm_protect
IOKit
IOConnectCallMethod
Host
host_info, host_get_io_master, host_processors
Processor
processor_info, processor_control, processor_assign
Misc
Clock/voucher/semaphore
The IPC, send rights, and more
☞
Task inherits the send 
rights to a few special 
ports from its parent. 
Task
Host
I/O master
1. host_get_io_master
2. send right to I/O master
3. IOServiceGetMatchingService
IOService
4. send right to IOService object
5. IOServiceOpen
IOUserClient
6. send right to IOUserClient
7. IOConnectCallMethod
☜ Newly 
created 
kernel 
object
Get the send rights via task_get_special_port()
The IPC, send rights, and more
☞
launch is in charge of 
the bootstrap port 
Task
Launchd
1. bootstrap_lookup
Service
2.send right to the service
3. IPC channel to the service
Where is the sandbox?
Task
Launchd
1. bootstrap_lookup
Service
2.send right to the service
3. IPC channel to the service
☜
Launchd should check whether 
the task is allowed to talk with 
the services. So how?
IPC Sandbox in Launchd
☜
The kernel adds a trailer 
to indicate the auditing 
information of the sender
Body
optional
mach_msg_*_descriptor
Header
Trailer
IPC Sandbox in Launchd
Inside the audit_token, launchd 
can get the information including 
pid/p_idversion, and then perform 
a sandbox check according to pid 
and p_idversion.
☜
The mach message carries a trailer
Task
Launchd
1. bootstrap_lookup
Service
2.send right to the service
3. IPC channel to the service
Kernel
(Sandbox extension)
☜
Query the kernel with 
pid/p_idversion
No-more-senders (NMS) notiﬁcation
Task
Host
I/O master
1. host_get_io_master
2. send right to I/O master
3. IOServiceGetMatchingService
IOService
4. send right to IOService object
5. IOServiceOpen
IOUserClient
6. send right to IOUserClient
7. IOConnectCallMethod
☜
Per-task kernel object
☜
Permanent kernel object
No-more-senders (NMS) notiﬁcation
Task
Host
I/O master
1. host_get_io_master
2. send right to I/O master
3. IOServiceGetMatchingService
IOService
4. send right to IOService object
5. IOServiceOpen
IOUserClient
6. send right to IOUserClient
7. IOConnectCallMethod
☜
Per-task kernel object
☜
Permanent kernel object
Consider such a scenario: when a 
task is terminated accidentally,  
how to clean up the kernel objects?
No-more-senders (NMS) notiﬁcation
• The kernel object can register for no-
more-senders notiﬁcation 
(IPC_KOBJECT_ALLOC_NSREQUEST)
• When there are no longer any tasks 
which hold a send right to this kernel 
object, the kernel would send the no-
more-senders notiﬁcation message to the 
port. As a result, the kernel can 
deallocate/destroy the corresponding 
kernel object. 
Only the kernel can send NMS
• In the past, Ian beer found a lot of bugs due to spoofed NMS
• Now the ipc_kobject_notify only handles mach message with the kernel 
tokens
The bug
https://github.com/wangtielei/Slides/blob/main/zer0con21.pdf
XNU has many optimizations to boost IPC 
CVE-2020-27932 
is caused by special reply ports 
Special reply port
• Normally, when a thread traps into the kernel to receive mach messages, 
its priority will be decreased
• Assume a higher priority thread sends a mach message to a service, and 
would receive a reply latter. When receiving the reply, the thread doesn’t 
want to lose its priority, because highly likely the reply is already on the 
queue.
• This is how the “special reply port” comes. Receiving messages from a 
special reply port should not decrease the thread priority. 
How to use special reply ports?
Sample Code from XNU source code
A customized send
• Send a mach port msg_port via a complex 
mach message to send_port with reply port 
reply_port
• A few things to note
• msg_port is sent with 
MACH_MSG_TYPE_MOVE_RECEIVE
• mach_msg uses the option  
MACH_SEND_SYNC_OVERRIDE
We found a new panic while analyzing CVE-2020-27932
dst_port became inactive!
☜
send special_reply_port 
to itself, use itself as 
reply port
send a null port to ☞
dst_port, use 
special_reply_port 
as reply port
☞
receive from 
dst_port
Root cause analysis
ipc_port_link_special_reply_port
ipc_kmsg_copyin_header
ipc_kmsg_copyin
mach_msg_overwrite_trap
ipc_kmsg_set_qos
ipc_port_link_special_reply_port
Root cause analysis
ipc_port_link_special_reply_port
kdata.sync_inheritor_port
…
special_reply_port 
io_references
dst_port 
io_bits
io_references
io_bits
Root cause analysis
The second send is very complicated, but there are 
three key steps
Root cause analysis
1.
msg_port is sent with MACH_MSG_TYPE_MOVE_RECEIVE
ipc_kmsg_copyin_body
ipc_kmsg_copyin
mach_msg_overwrite_trap
ipc_kmsg_copyin_port_descriptor
ipc_object_copyin
ipc_right_copyin
special_reply_port’s ip_tempowner is set 1
Root cause analysis
2.
sending a port to itself will trigger a circularity check 
the kmsg is set with MACH_MSGH_BITS_CIRCULAR 
ipc_kmsg_copyin_body
ipc_kmsg_copyin
mach_msg_overwrite_trap
ipc_kmsg_copyin_port_descriptor
ipc_port_check_circularity
Root cause analysis
2.
sending a port to itself will trigger a circularity check 
ipc_kmsg_destroy
ipc_kmsg_send
mach_msg_overwrite_trap
the kmsg gets destroyed due to the circularity check
Root cause analysis