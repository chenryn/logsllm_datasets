than the versions produced by Cheerp. However, reimplemented
versions of CHStone consume slightly less memory.
We make two observations. First, careful implementation of
JavaScript can outperform certain types of computations (e.g., AES
and SHA), echoing the findings in the previous sections. Second,
it is challenging to build optimal JavaScript programs in practice,
which means that compiler-generated versions may be beneficial
for developers to design efficient JavaScript programs (in terms of
both runtime and memory space overhead).
4.6.2 Real-World Applications. We selected three real-world appli-
cations from open-source GitHub projects, Long.js, Hyphenopoly.js,
and FFmpeg, and conducted six experiments: three experiments
for Long.js, two for Hyphenopoly.js, and one for FFmpeg. Table 10
shows the experiment input, the sum of LOCs of HTML, JavaScript,
and WAT (human-readable WebAssembly Text) files, the exeuction
time of WebAssembly and JavaScript, and execution time ratio of
WebAssembly to JavaScript.
Long.js. We test three operations using Long.js, multiplication, di-
vision, and remainder, in both WebAssembly and JavaScript. Rows
1-3 in Table 10 show the execution time result. In all three experi-
ments, WebAssembly executes faster than JavaScript. We manually
inspect the three programs to identify the number of arithmetic op-
erations executed by them. Our inspection shows that the JavaScript
versions run many more instructions than the WebAssembly ver-
sions because of the different mechanisms of implementing 64-bit
operations in JavaScript and WebAssembly. The count of arithmetic
operations executed is presented in Appendix D.
Hyphenopoly.js. We test Hyphenopoly.js in WebAssembly and
JavaScript using two input languages, English (en-us) and French
(fr). As shown in Table 10 rows 4-5, WebAssembly and JavaScript
have similar execution time while WebAssembly is marginally faster
than JavaScript. Our manual investigation shows that a significant
amount of time is spent on input and output operations in which
WebAssembly is not specialized.
544
Understanding the Performance of WebAssembly Applications
IMC ’21, November 2–4, 2021, Virtual Event, USA
FFmpeg. We measure the performance of this library in WebAssem-
bly and JavaScript by converting a 296 MB video file in MP4 to AVI.
Table 10 row 6 shows that WebAssembly executes much faster
than JavaScript. This is because the WebAssembly implementation
uses multiple WebWorkers to parallelize the conversion, while the
JavaScript implementation has no parallelization.
5 LIMITATIONS AND FUTURE WORK
Threats to Validity. Our study is potentially subject to several
threats, namely the representativeness of the chosen benchmarks
and the generalization of the results. According to [16, 70], We-
bAssembly was designed to be used in a variety of applications,
including compression, cryptographic libraries, games, image pro-
cessing, numeric computation, and others. In our experiment, we
choose 41 widely used C benchmark programs that perform nu-
meric computation, image processing, data compression, and cryp-
tographic algorithms. While we believe the programs we tested
can well represent some common WebAssembly use scenarios, we
do not include large standalone programs such as games in the
comparison. This is because of the complexity of their source code
and unsupported features that are incompatible with the compiler,
Cheerp is not able to compile these programs. In the future, we
plan to overcome the incompatible issues to support the evaluation
of complex real-world applications by modifying the compiler or
refactoring the source programs. Another threat concerns the gen-
eralization of the performance results. The benchmarks used in the
study were tested on three mainstream browsers, Google Chrome,
Mozilla Firefox, and Microsoft Edge. These browsers are evolving
quickly, releasing updates frequently. Thus, the results of this study
may not reflect the up-to-date performance of the browsers. To
reduce the bias introduced by different browsers, we ensure three
browsers were stable release versions and were released around
the same time (Dec. 2019).
Future Work. We discuss several future directions that are worthy
of pursuing based on our empirical findings: First, we observed
that JavaScript performance was significantly affected by JIT opti-
mization. However, no substantial performance increase was seen
for WebAssembly with JIT. This is because the current browser
engine can identify hot code in JavaScript to substantially improve
its speed, but not so much in WebAssembly, suggesting that more
effort should be spent on optimizing WebAssembly code execu-
tion. Second, our experiments show that compiler optimizations
do not work as intended for WebAssembly. For example, -Ofast,
which is supposed to create the fastest target code, is slower than
-Oz and -O1 for WebAssembly. As described in Section 2.1.2, such
compiler inefficiencies are pervasive. These findings call for more
research effort on designing new compiler optimization techniques
for WebAssembly.
6 RELATED WORK
WebAssembly Performance Measurement and Studies. Our
work is closely related to WebAssembly performance measurement
and studies [43, 46, 48, 70, 77, 81]. [43] measured the performance of
WebAssembly, asm.js, and native C implementations. [48] focused
on performance comparison of WebAssembly and C programs. [81]
studied WebAssembly performance for applications performing
sparse matrix-vector multiplication. [70] studied the prevalence of
WebAssembly in Alexa Top 1 Million Websites. Hilbig et al. [46]
presented an empirical study of 8,461 real-world WebAssembly
binaries and analyzed their security properties, source languages,
and use cases. To the best of our knowledge, our work conducts
a first comprehensive study on the performance of both generic
JavaScript and WebAssembly with diverse settings.
WebAssembly Analysis Tools, Protections, and Extensions.
Prior works on WebAssembly analysis tools, protections, and exten-
sions [28, 49, 53, 54, 71, 72, 78–80, 91] are also related. Wasabi [54]
is the first general-purpose framework for dynamically analyzing
WebAssembly. Lehmann et al. [53] analyzed how vulnerabilities in
memory-unsafe source languages are exploitable in WebAssembly
binaries. Swivel [71] presented a new compiler framework for hard-
ening WebAssembly against Spectre attacks. CT-wasm [91] intro-
duced a type-driven, strict extension to WebAssembly to facilitate
the verifiable secure implementation of cryptographic algorithms.
MS-Wasm [28] extended WebAssembly to enable developers to
capture low-level C/C++ memory semantics in WebAssembly at
compile time.
Web Performance Measurement. There have been several prior
works on testing web page performance and analyzing JavaScript,
PHP, and other web technologies [42, 55, 76, 82]. Besides, our work
is also relevant to studies [3, 18, 19, 26, 45, 52, 56, 57, 60, 83, 92],
researching the performance of operating systems, mobile applica-
tions, and virtual machines. The closest previous work is [45] which
also compares WebAssembly and JavaScript on desktop and mobile
devices. However, our work covers more diverse applications and
inputs, and tests on new versions of the browsers (i.e., our target
browsers are released two years later than those used in [45]). Our
results also differ from it where WebAssembly only performs better
on desktop Firefox, mobile Chrome, and mobile Edge.
Compiler Optimization Studies. [6] conducted a case study us-
ing the Intel Core 2 Duo processor to analyze the compiler optimiza-
tions required to obtain high performance on modern processors.
[51] leveraged machine learning techniques to predict the best op-
timization flags for creating efficient programs. [13] researched
the impact of compiler optimizations on high-level synthesis. By
contrast, we investigate the impact of compiler optimizations on
the performance of compiled WebAssembly programs.
7 CONCLUSION
This paper conducts the first systematic empirical study to un-
derstand the performance of WebAssembly applications along with
JavaScript. We perform measurements on different types of sub-
ject programs, including compiler-generated programs, manually-
written programs, and real-world applications, with diverse settings.
Our findings provide insights for WebAssembly tooling develop-
ers to optimize for performance improvement. We make our data
publicly available [2].
8 ACKNOWLEDGMENTS
We thank the anonymous reviewers and our shepherd, Balakr-
ishnan Chandrasekaran, for their constructive feedback. We greatly
appreciate the time and effort spent by our shepherd and other
reviewers in helping us improve our paper.
545
IMC ’21, November 2–4, 2021, Virtual Event, USA
Y. Yan et al.
REFERENCES
[1] 2019. IEEE Standard for Floating-Point Arithmetic.
[2] 2020.
Project Website.
BenchmarkingWebAssembly/
https://benchmarkingwasm.github.io/
[3] Aldeida Aleti, Catia Trubiani, André van Hoorn, and Pooyan Jamshidi. 2018. An
efficient method for uncertainty propagation in robust software performance
estimation. Journal of Systems and Software 138 (2018), 222–235.
studio/command-line/adb
[4] Android. 2020. Android Debug Bridge (adb). https://developer.android.com/
[5] asm.js. 2020. asm.js - an extraordinarily optimizable, low-level subset of JavaScript.
http://asmjs.org/
[6] Aart JC Bik, David L Kreitzer, and Xinmin Tian. 2008. A case study on compiler
optimizations for the Intel® Core TM 2 Duo Processor. International Journal of
Parallel Programming 36, 6 (2008), 571–591.
Why is webAssem-
bly function almost 300 time slower than same JS function.
https:
//stackoverflow.com/questions/48173979/why-is-webassembly-function-
almost-300-time-slower-than-same-js-function
[7] Stack Overflow Contributor Blindman67. 2018.
[8] Caligatio. 2021. Caligatio/jsSHA. https://github.com/Caligatio/jsSHA
[9] Winston Chen. 2018.
Performance Testing Web Assembly vs JavaScript.
https://medium.com/samsung-internet-dev/performance-testing-web-
assembly-vs-javascript-e07506fd5875
[10] Clang. 2020. LLVM’s Analysis and Transform Passes. https://llvm.org/docs/
Passes.html#argpromotion-promote-by-reference-arguments-to-scalars
[11] Lin Clark. 2018.
Calls between JavaScript and WebAssembly are fi-
https://hacks.mozilla.org/2018/10/calls-between-javascript-and-
nally fast.
webassembly-are-finally-fast-%F0%9F%8E%89/
[12] Stack Overflow Contributor ColinE. 2017. Why is my WebAssembly function
slower than the JavaScript equivalent? https://stackoverflow.com/questions/
46331830/why-is-my-webassembly-function-slower-than-the-javascript-
equivalent/46500236#46500236
[13] Jason Cong, Bin Liu, Raghu Prabhakar, and Peng Zhang. 2012. A study on
the impact of compiler optimizations on high-level synthesis. In International
Workshop on Languages and Compilers for Parallel Computing. Springer, 143–157.
File System Overview — Emscripten
https://emscripten.org/docs/porting/files/
1.39.17 documentation.
file_systems_overview.html#file-system-overview
[14] Emscripten Contributors. 2015.
[15] Emscripten Contributors. 2020. Emscripten 1.39.4 documentation.
https://
emscripten.org/
[16] WebAssembly Contributors. 2020. Webassembly Use Cases.
https://
webassembly.org/docs/use-cases/
[17] Netscape Communications Corporation and Inc. Sun Microsystems. 1995.
Netscape and Sun Announce JavaScript, the Open, Cross-Platform Object Script-
ing Language for Enterprise Networks and the Internet. https://web.archive.org/
web/20070916144913/http://wp.netscape.com/newsref/pr/newsrelease67.html
[18] Luis Cruz and Rui Abreu. 2017. Performance-based guidelines for energy efficient
mobile applications. In 2017 IEEE/ACM 4th International Conference on Mobile
Software Engineering and Systems (MOBILESoft). IEEE, 46–57.
[19] Mariana Cunha and Nuno Laranjeiro. 2018. Assessing Containerized REST
Services Performance in the Presence of Operator Faults. In 2018 14th European
Dependable Computing Conference (EDCC). IEEE, 95–100.
https://github.com/
damianociarla/node-ffmpeg
[20] Damianociarla. 2021. Damianociarla/node-ffmpeg.
[21] Damianociarla. 2021. Damianociarla/node-ffmpeg/lib/ffmpeg.js.
github.com/damianociarla/node-ffmpeg/blob/master/lib/ffmpeg.js
[22] DcodeIO. 2021. DcodeIO/Long.js. https://github.com/dcodeIO/Long.js/
[23] DcodeIO. 2021. Long.js Avoiding Overflow. https://github.com/dcodeIO/long.js/
https://
[24] DcodeIO. 2021. Long.js JavaScript Source Code. https://github.com/dcodeIO/
[25] DcodeIO. 2021. Long.js WebAssembly Source Code. https://github.com/dcodeIO/
blob/master/src/long.js#L56-L59
long.js/blob/master/src/long.js
long.js/blob/master/src/wasm.wat
[26] Giovanni Denaro, Andrea Polini, and Wolfgang Emmerich. 2004. Early per-
formance testing of distributed software applications. In Proceedings of the 4th
international workshop on Software and performance. 94–103.
[27] Mozilla developers. 2021. Bugzilla – Bug 37449 – llvm performs less inlining in
-O3 than in -O2. https://bugs.llvm.org/show_bug.cgi?id=37449
[28] Craig Disselkoen, John Renner, Conrad Watt, Tal Garfinkel, Amit Levy, and
Deian Stefan. 2019. Position Paper: Progressive Memory Safety for WebAssembly.
In Proceedings of the 8th International Workshop on Hardware and Architectural
Support for Security and Privacy (Phoenix, AZ, USA) (HASP ’19). Association for
Computing Machinery, New York, NY, USA, Article 4, 8 pages. https://doi.org/
10.1145/3337167.3337171
[29] MDN Web Docs. 2020. Compiling an Existing C Module to WebAssembly. https:
//developer.mozilla.org/en-US/docs/WebAssembly/existing_C_to_wasm
[30] Haas et al. 2017. Bringing the web up to speed with WebAssembly. In Proceedings
of the 38th ACM SIGPLAN Conference on Programming Language Design and
546
[31] Martín Abadi et al. 2015. TensorFlow: Large-Scale Machine Learning on Hetero-
Implementation. 185–200.
geneous Systems. https://www.tensorflow.org/
[32] FFmpeg. 2021. FFmpeg. https://www.ffmpeg.org/
[33] ffmpegwasm. 2021.
ffmpegwasm/ffmpeg.wasm.
ffmpegwasm/ffmpeg.wasm
https://github.com/
[34] ffmpegwasm. 2021. ffmpegwasm/ffmpeg.wasm/dist/ffmpeg.min.js.
unpkg.com/@ffmpeg/ffmpeg@0.10.0/dist/ffmpeg.min.js
The collaborative interface design tool.
https://
https://
[35] Inc. Figma. 2021.
www.figma.com/
https://gcc.gnu.org/
[36] Free Software Foundation (FSF). 2020. GCC, the GNU Compiler Collection.
[37] Google. 2020. Google Chrome - Download the Fast, Secure Browser from Google.
https://www.google.com/chrome/
[38] Google. 2020. V8 JavaScript Engine. https://v8.dev/
[39] WebAssembly Group. 2020. WebAssembly/design.
WebAssembly/design/blob/master/FutureFeatures.md
https://github.com/
[40] WebAssembly Community Group. 2020. Use Cases - WebAssembly.
https:
//webassembly.org/docs/use-cases/
[41] Jakob Gruber. 2021. JIT-less V8. https://v8.dev/blog/jitless
[42] Antonio Guerriero, Raffaela Mirandola, Roberto Pietrantuono, and Stefano Russo.
2019. A Hybrid Framework for Web Services Reliability and Performance Assess-
ment. In 2019 IEEE International Symposium on Software Reliability Engineering
Workshops (ISSREW). IEEE, 185–192.
[43] Andreas Haas, Andreas Rossberg, Derek L. Schuff, Ben L. Titzer, Michael Holman,
Dan Gohman, Luke Wagner, Alon Zakai, and JF Bastien. 2017. Bringing the Web
up to Speed with WebAssembly. SIGPLAN Not. 52, 6 (June 2017), 185–200.
[44] Yuko Hara, Hiroyuki Tomiyama, Shinya Honda, and Hiroaki Takada. 2009. Pro-
posal and quantitative analysis of the CHStone benchmark program suite for
practical C-based high-level synthesis. Journal of Information Processing 17 (2009),
242–254.
[45] David Herrera, Hangfen Chen, Erick Lavoie, and Laurie Hendren. 2018. We-
bAssembly and JavaScript Challenge: Numerical program performance using
modern browser technologies and devices. University of McGill, Montreal: QC,
Technical report SABLE-TR-2018-2 (2018).
[46] Aaron Hilbig, Daniel Lehmann, and Michael Pradel. 2021. An Empirical Study of
Real-World WebAssembly Binaries: Security, Languages, Use Cases. In Proceedings
of the Web Conference 2021 (Ljubljana, Slovenia) (WWW ’21). Association for
Computing Machinery, New York, NY, USA, 2696–2708. https://doi.org/10.1145/
3442381.3450138
[47] Raymond Hill. 2019. gorhill/ublock. https://github.com/gorhill/uBlock
[48] Abhinav Jangda, Bobby Powers, Emery D Berger, and Arjun Guha. 2019. Not
so fast: analyzing the performance of webassembly vs. native code. In 2019
{USENIX} Annual Technical Conference ({USENIX}{ATC} 19). 107–120.
[49] Evan Johnson, David Thien, Yousef Alhessi, Shravan Narayan, Fraser Brown,
Sorin Lerner, Tyler McMullen, Stefan Savage, and Deian Stefan. 2021. Trust, but
verify: SFI safety for native-compiled Wasm. In NDSS. Internet Society.
[50] Josdejong. 2021. Josdejong/mathjs. https://github.com/josdejong/mathjs
[51] Yuriy Kashnikov, Jean Christophe Beyler, and William Jalby. 2012. Compiler op-
timizations: Machine learning versus o3. In International Workshop on Languages
and Compilers for Parallel Computing. Springer, 32–45.
[52] Heejin Kim, Byoungju Choi, and W Eric Wong. 2009. Performance testing
of mobile applications at the unit test level. In 2009 Third IEEE International
Conference on Secure Software Integration and Reliability Improvement. IEEE,
171–180.
[53] Daniel Lehmann, Johannes Kinder, and Michael Pradel. 2020. Everything Old is
New Again: Binary Security of WebAssembly. In 29th USENIX Security Symposium
(USENIX Security 20). USENIX Association, 217–234. https://www.usenix.org/
conference/usenixsecurity20/presentation/lehmann
[54] Daniel Lehmann and Michael Pradel. 2018. Wasabi: A Framework for Dynamically
Analyzing WebAssembly. CoRR abs/1808.10652 (2018). arXiv:1808.10652 http:
//arxiv.org/abs/1808.10652