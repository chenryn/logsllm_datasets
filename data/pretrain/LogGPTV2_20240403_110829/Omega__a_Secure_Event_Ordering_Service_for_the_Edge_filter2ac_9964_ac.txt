We do not make assumptions about the security and time-
liness of the communication, except that messages are even-
tually received by their recipient.
We also assume that each fog node has a processor with
Intel SGX, which allows running a TEE designated enclave,
as depicted in Figure 2. Both clients and fog nodes have
asymmetric key pairs (Ku, Kr). The private key of the fog
node K F
r never leaves the enclave. For public key distribution,
we consider the existence of a Public Key Infrastructure (PKI).
We do the usual assumptions about the security of TEEs/en-
claves (data executed/stored inside the enclave has integrity
and conﬁdentiality ensured) and cryptographic schemes (e.g.,
private keys are not disclosed, signatures cannot be created
without the private key, and the hash function is collision-
resistant). For obtaining digital signatures efﬁciently we use
Elliptic Curve Cryptography (ECC), speciﬁcally the ECDSA
algorithm [69] with 256-bit keys, which is recommended by
NIST [70]. We assume the existence of a collision-resistant
hash function. In practice we use SHA-256 [71], also recom-
mended by NIST [70]. We use the implementations provided
by the SGX SDK (inside the enclave) and Java (outside).
Interestingly, this involves converting public keys from little
endian (enclave) to big endian (Java).
D. Client Binding
Before a client invokes any method of the Omega API
must execute a client binding procedure. The purpose of this
procedure is to ensure that the client has the following guar-
antees: i) it has a secure connection to a software component;
ii) this software component is running on an enclave in an
Intel processor with SGX; iii) the software version is the
same version as the one registered in Intel’s attestation servers
(which is assumed to be the correct version of the software
component). This is also known as the attestation procedure
[30]. One limitation of the procedure deﬁned by Intel is that it
involves multiple communication steps, including a connection
to Intel servers (to ensure that the enclave is created on an
Intel CPU). This is a cumbersome process which conﬂicts
with our goal of improving the overall event-ordering service
latency. Therefore, we have resorted to a different scheme to
perform client binding. Our solution is inspired in Excalibur
[72], a service designed for the Trusted Platform Module [73]
that also aims at preventing clients from attesting directly
all servers. However, Omega uses substantially different tech-
niques, in particular, Excalibur requires the transmission of
keys in the network, which is signiﬁcantly less robust than
Omega’s protocol. The Omega client binding protocol relies
on the Attestation Server (AS) that runs in the cloud. The
AS runs Intel’s attestation protocol with each fog node. It
performs this attestation periodically, with a period that can
be conﬁgured. If the fog node passes the attestation, the AS
obtains from the CA a certiﬁcate with an expiration date lower
than the period, digitally signed with its private key K CA
. The
attestation performed by the AS allows to establish a secure
connection with the enclave. The AS uses this connection to
acquire the public key of the fog node, which is added to
the previously mentioned certiﬁcate. This certiﬁcate is sent to
the Omega instance running on the enclave of the fog node
and stored in the untrusted part. Instead of running the Intel’s
attestation procedure Clients of the Omega service just ask the
Omega implementation to return the certiﬁcate that has been
issued by the AS.
r
E. The Omega Vault and the Event Log
Omega is required to safely store different pieces of infor-
mation, such as the private key associated with the certiﬁcate
signed by the AS, the last event generated by Omega, and also
the last event associated with each tag. However, the enclave
memory is limited to a few tens of megabytes and Omega
must keep an arbitrary number of tags. Therefore, Omega
requires a way to securely store the above information (in
particular the last event for an arbitrary number of tags). Also,
Omega must have access to events it has generated in the past,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:36:47 UTC from IEEE Xplore.  Restrictions apply. 
494
(see Figure 3); in the implementation this table is splited
into N parts, and for each part, the enclave computes a hash
to ensure integrity. Since the enclave may not have enough
memory to store all these hashes, we use a Merkle tree such
that the enclave only needs to store the top hash. All the hashes
are calculated inside the enclave. In particular, SGX exhibits
an attribute user check that allows passing a pointer of the
untrusted zone memory space as an argument in an ECALL,
so that the enclave can access data that is in the untrusted part.
This way, the enclave can verify and generate the Merkle tree
hashes when needed while storing only the top hash.
When the enclave requires to modify one part of the table
it needs to: compute the Merkle tree to verify the data,
then change the data and, ﬁnally, recalculate a few of the
Merkle tree hashes (as many as the depth of the tree). These
operations must be performed in an atomic manner, otherwise
an attacker could change the table between the two Merkle
tree calculations and the enclave would not be able to detect
it. To ensure the atomicity of the combined operations, the
enclave calculates the hashes in parallel, i.e., it calculates the
old hash and the new hash of the table simultaneously so that
in the end it can simply replace the old one.
Our implementation of the Omega vault is optimized to
support multi-threaded operation. The tag address space is
sharded, and each shard is maintained in an independent
Merkle tree. This allows the concurrent execution of multiple
threads inside the enclave, as long as they are updating
different shards. This substantially improves the throughput
sustained by the Omega service. Note that, even when multiple
threads are used, Omega still ensures the serialization of
all events: the existence of a sequential history makes the
task of crawling the event log easier. This means that the
assignment of the last event
identiﬁer is still executed in
mutual exclusion inside the enclave. However, the fraction
of the Omega code that needs to be executed serially is so
small, when compared with the remaining code, that it does
not represent an impairment to performance. In fact, with the
number of cores we have tested (up to 16), we could not
observe any signiﬁcant degradation resulting from the need to
serialize events.
F. Implementation of the Omega API
Clients invoke the Omega API via a client library. In this
way, clients do not need to be aware of the speciﬁcs for
communication with the Omega server. In fact, as we discuss
here, different methods use different communication primitives
to interact with the enclave. Also, some of the methods can be
executed directly by the client library and do not require any
message exchange with the enclave. In the next paragraphs,
we describe the implementation of each primitive in detail.
The methods registerTag and createEvent are the only
methods that modify the state of the Omega server in the
fog node. The method registerTag registers tags, so it has
to adjust the space allocated to the vault when the space
available is exhausted (recall that Omega keeps track of the
last event associated with each tag it observed); The method
Fig. 3. Merkle tree stored in the Omega vault in the untrusted zone of the
fog node (with N = 4).
given that clients can use the predecessorEvent method to
crawl the event history. To satisfy these requirements, Omega
uses two storage services with different properties, the vault
and the event log. In both cases, Omega stores events in the
untrusted zone. These events can be in plain text but we still
need integrity, i.e., to ensure that the untrusted zone cannot
modify these values in case the fog node is compromised.
Given that events are signed by Omega, the untrusted zone
cannot modify individual events; however it can delete events
or replace new events by older events. We now describe the
implementation of these two services.
The event log is just a record of all events generated, so we
opted to implement this component as a key-value store where
events are stored using their unique identiﬁer (assigned by the
application) as key. Everytime Omega makes a look-up for
a speciﬁc event (for instance, when a client crawls the event
history) it simply checks the integrity of the event before the
value is returned to the client. If an event cannot be found in
the key-value store, this is a sign that the untrusted components
of the fog node have been compromised.
The vault
is harder to implement, because it needs to
maintain the last event generated for each tag and its im-
plementation needs to ensure that the untrusted components
cannot replace the last event by an older event. Therefore,
checking the integrity of the event returned is not enough: the
Omega vault implementation must ensure that the values have
not been changed. At the logical level, this is achieved by
requiring the enclave to hash the vault every time it updates
its content; the hash is stored at the enclave itself. However, a
naive implementation that would actually keep a single hash
for the entire vault would not perform well because, as we
have noted, the application may use a large number of tags
and computing a hash of all these tags may take a long time.
Also, it is not straightforward to ensure that the hash function
yields the intended value if the values being hashed are to
many to ﬁt inside the enclave and may be changed by the
adversary while the hash is being computed.
To address the problems above, the implementation of the
Omega vault uses the following techniques. First, the content
of the vault is stored as a Merkle tree [74]. While conceptually
the vault is just a table, maintained in the untrusted zone,
where each line is a tag (index) and a column for the event
495
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:36:47 UTC from IEEE Xplore.  Restrictions apply. 
createEvent is used to create a new event in the server. The
state of an event is a tuple that contains the following ﬁelds: i)
a unique timestamp, that is associated to the event by the server
(in the current implementation, this timestamp is a sequence
number); ii) the EventId; iii) the associated EventTag (that
must be a tag previously registered via the registerTag event);
iv) the EventId of the last event generated by Omega; v) the
EventId of the last event generated by Omega with the same
tag. The identiﬁers of the predecessor events are maintained in
the Omega vault. The new tuple is signed with the private key
of the Omega server. Subsequently, the Omega server replaces
the identiﬁer of the last event generated by the identiﬁer of
the new event and replaces the identiﬁer of the last event
generated with the given tag, by the new event. As noted, these
variables are maintained in the secured Omega vault. Then, the
tuple is also stored in the event log that is maintained in the
non-secured portion of the fog node. Finally, the tuple that
represents the event is returned to the client.
it uses the vault
The methods lastEvent,
lastEventWithTag, predeces-
sorEvent, and predecessorWithTag do not change the state
of the Omega. When the server receives a lastEvent request it
extracts the last event it has processed from the vault (i.e, a tu-
ple with the ﬁelds enumerated in the previous paragraph) to the
client. Similarly, when the server receives a lastEventWithTag
request,
the previous request
and sends it to the client. The requests predecessorEvent
and predecessorWithTag are executed collaboratively by the
client library and the server. The client library, that is aware of
the internal structure of the Event tuple, extracts the timestamp
of the event. This event identiﬁer is sent to the server that
fetches the complete event tuple associated to that identiﬁer
from the event log. Finally, the full tuple associated with the
desired event is returned to the client.
to extract
Lastly, the methods orderEvents, getId, and getTag re-
quire no communication with the enclave, and are imple-
mented directly on the library. The ﬁrst method extracts the
timestamp ﬁeld from each tuple, compares their values, and
returns the tuple with lower timestamp. The other two simply
return the corresponding ﬁelds from the input tuple.
Note that several of the methods described above require
the Omega server to extract information from the vault and/or
from the event log. The integrity of the information maintained
in the vault
is ensured by construction. Also the server
can always check the validity of records extracted from the
event log (since each tuple is signed with the private key of
the server, which is safely stored in the enclave). However,
the Omega server cannot prevent the non-secured portion of
the fog node from deleting information from stable storage,
making the vault, the log, or both unavailable. In this case,
the part of Omega that runs inside the enclave detects the
corruption, stops operating, and reports an error.
VI. OMEGA KEY-VALUE STORE
OmegaKV is an extension to key-value stores that have
been designed for the cloud. It makes it possible to maintain
a cache of some key-value pairs in the untrusted space of
(cid:3)(cid:6)(cid:8)(cid:7)(cid:1)(cid:2)(cid:10)(cid:9)(cid:7)(cid:11)(cid:13)
(cid:4)(cid:13)(cid:9)(cid:10)(cid:7)(cid:3)(cid:6)
(cid:8)(cid:12)(cid:11)(cid:9)(cid:14)(cid:17)
(cid:4)(cid:13)(cid:9)(cid:10)(cid:7)(cid:1)
(cid:8)(cid:12)(cid:11)(cid:9)(cid:14)(cid:17)
(cid:4)(cid:12)(cid:8)(cid:1)(cid:5)(cid:12)(cid:6)(cid:7)
(cid:4)(cid:13)(cid:9)(cid:10)(cid:7)(cid:3)(cid:6)
(cid:4)(cid:13)(cid:9)(cid:10)(cid:7)
(cid:2)(cid:14)(cid:8)(cid:12)(cid:7)(cid:19)(cid:9)
(cid:3)(cid:9)(cid:20)(cid:21)(cid:6)(cid:7)(cid:12)(cid:18)(cid:9)
(cid:5)(cid:17)(cid:15)(cid:16)(cid:9)
Fig. 4. OmegaKV service components.
a fog node while still ensuring that clients observe up-to-
date values of the cached objects, in an order that respects
causality. This is achieved by resorting to the services of
Omega. OmegaKV also ensures that all updates performed
by edge clients on the fog node, if they are propagated to the
cloud, are propagated in an order that respects causality. As
discussed in Section IV, Omega cannot ensure availability in
case the adversary compromises the fog node. For availability,
clients of OmegaKV should write on multiple fog nodes
eagerly or cache the updates they have made and replay them
later, if and only if they discover that the fog node has failed
to propagate those updates to the cloud. We omit those details
in this paper, given that here we use OmegaKV mainly to
illustrate the use of Omega and as a means to assess the
overhead introduced by this service.
OmegaKV is implemented by combining an untrusted local
key-value store and Omega. The key-value store resides in
the untrusted region of the fog node, and it is used to store
the values persistently. Omega is used to keep track of the
relative order of update operations that have been performed
locally. Figure 4 illustrates the architecture of OmegaKV, the
implementation of OmegaKV has components that run on a
client library and components that run of the fog node.
OmegaKV uses Omega as follows. Every update performed
on the local replica is associated with an event generated by
Omega. The keys used in the OmegaKV are associated to
EventTags in Omega; thus Omega will store securely each
update performed on each key. Also, for each update operation,
an EventId is generated as a function of the content of the
update; more precisely, if a client writes value v on some key
k, that update will be identiﬁed by hash(k⊕ v). The operation
local kv.put (k, (v, e))
event id ← hash(k ⊕ v).
e ← omega.createEvent (event id, k)
BEGIN ATOMIC
(old v, old e) ← local kv.get (k)
if old e = omega.orderEvents (old e, e) then
Algorithm 1 OmegaKV Implementation
1: function PUT(k, v)
2:
3:
4:
5: