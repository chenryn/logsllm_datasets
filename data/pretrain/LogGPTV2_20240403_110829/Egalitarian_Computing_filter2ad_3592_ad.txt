the memory is allocated separately for each chunk. The
reader may also refer to Figure 2.
The underlying idea is to use both the header and the
body blocks to produce the ciphertext. In tun, to recom-
pute the body blocks both the ciphertext and the header
must be available during trial decryption.
3The similar argument is made for the online authenticated ciphers
9
USENIX Association  
25th USENIX Security Symposium  323
pwd
H
header
body
Argon2
H
K1
K0
E
CBC
Cq+1
H
K0
random
K1
E
ECB
K1
E
ECB
m1
m2
C(cid:31)(cid:31)1
E
CBC
C1
K0
C(cid:31)(cid:31)2
E
CBC
C2
Figure 2: MHE: Disk encryption using memory-hard function Argon2.
The version of the MHE scheme which allocates the
same memory for multiple chunks is very similar. The
S input is ignored at the beginning, so that the header
memory blocks do not depend on the data. Instead, we
set K0 = H(X0,S), so that the body blocks are affected
by S and M, and thus are different for every chunk. In
this case the body blocks have to be stored separately
and should not overwrite the header blocks for t > 1.
Let us verify that the scheme in Algorithm 3 satisﬁes
the properties we listed earlier:
• The allocated memory size M can be chosen inde-
pendently of the chunk length q (as long as M > q).
• The body memory blocks are allocated and pro-
cessed for each chunk independently. In addition,
the header blocks are also processed independently
for each chunk in the single-chunk version.
• In order to decrypt a single byte of the ciphertext,
an adversary would have to obtain K1, which can be
done only by running F up to the ﬁnal block, which
requires all C(cid:30)(cid:30)i , which are in turn must be derived
from the ciphertext blocks.
• Encryption needs one pass over data, and decryp-
tion needs two passes over data.
• The total time needed to allocate and ﬁll the header
is tunable.
• The computation of the body memory blocks dur-
ing decryption can not be delegated, as it requires
knowledge both of the header and the ciphertext. It
in [18].
might be possible to generate the header on an ex-
ternal machine, but then random access to its blocks
to decrypt the ciphertext is required.
We note that properties 1, 5, and 6 are not present in [35].
Security First, we address traditional CPA security.
We do not outline the full proof here, just the basic steps.
We assume that the adversary does not have access to the
internals of Argon2, and that blockcipher E is a secure
PRF. Next, we assume collision-resistance of the com-
pression function F used in F . Given that, we prove
that all the memory blocks are distinct, which yields the
CPA security for C(cid:30). From the latter we deduce the CPA
security for the ﬁnal ciphertext. We note that in the case
when the collision-resistance of F can not be guaranteed,
we may additionally require that Xi undergo hashing by
a cryptographic hash function H(cid:30) before encryption, so
that the plaintext blocks are still distinct. All these prop-
erties hold up to the birthday bound of the blockcipher.
Next, we ﬁgure out the tradeoff security. The genuine
decrypting user is supposed to spend M memory blocks
for F and q memory blocks to store the plaintext and
intermediate variables (if the ciphertext can be overwrit-
ten, then these q blocks are not needed). Suppose that
an adversary wants to use αM memory for header and
body. Then each missing block, if asked during decryp-
tion, must be recomputed making C(α) calls to F. The
best such strategy for Argon2, described in [9], yields
C(α) that grows exponentially in 1/α. For example, us-
ing 1/5 of memory, an adversary would have to make
344 times as many calls to F, which makes a memory-
reducing encryption cracking inefﬁcient even on special
hardware.
324  25th USENIX Security Symposium 
USENIX Association
10
Algorithm 3 Memory-hard encryption with independent
memory allocation (for each chunk).
Input: Password P, memory size M, associated data S,
chunk Q, number of iterations t, memory-hard function
F (preferably Argon2), blockcipher E, cryptographic
hash function H (e.g. SHA-3).
1. Run F on (P,S) with input parameters M and t but
ﬁll only M − q blocks (the header) in the last itera-
tion. Let X0 be the last memory block produced by
F .
2. Produce K0 = H(X0) — the ﬁrst session key.
3. Generate a random session key K1.
4. Generate the remaining blocks X1, X2, . . ., Xq (body)
for F as follows. We assume that each chunk M
consists of smaller blocks m1, m2, . . ., mq of length
equal to the block size of F . For each i ≥ 1:
• Encrypt Xi−1 by E in the ECB mode under K1
and get the intermediate ciphertext block C(cid:28)i.
• Add the chunk data: C(cid:28)(cid:28)i = C(cid:28)i ⊕ mi.
• Encrypt C(cid:28)(cid:28)i under K0 in the CBC mode and
produce the ﬁnal ciphertext block Ci.
• Modify the memory: Xi−1 ← Xi−1 ⊕C(cid:28)(cid:28)i .
• Generate the block Xi according to the speci-
ﬁcation of F . In Argon2, the modiﬁed Xi−1
and some another block X[φ (Xi−1)] would be
used.
5. After the entire chunk is encrypted, encrypt also the
key K1 :
Ct+1 = EK0(H(Xt )⊕ K1).
Output: C1, . . . ,Ct+1.
Performance We suggest taking l = 4 in Argon2 in or-
der to ﬁll the header faster using multiple cores, which
reportedly takes 0.7 cpb (about the speed of AES-GCM
and AES-XTS). The body has to be ﬁlled sequentially
as the encryption process is sequential. As AES-CBC
is about 1.3 cpb, and we use two of it, the body phase
should run at about 4 cpb.
In a concrete setting, sup-
pose that we tolerate 0.1 second decryption time (about
300 Mcycles) for the 1-MB chunk. Then we can take the
header as large as 256 MB, as it would be processed in
170 Mcycles + 4 Mcycles for the body phase.
6 Conclusion
We have introduced the new paradigm of egalitarian
computing, which suggests amalgamating arbitrary com-
putation with a memory-hard function to enhance the
security against off-line adversaries equipped with pow-
erful tools (in particular with optimized hardware). We
have reviewed password hashing and proofs of work as
applications where such schemes are already in use or
are planned to be used. We then introduce two more
schemes in this framework. The ﬁrst one is MTP, the
progress-free proof-of-work scheme with fast veriﬁca-
tion based on the memory-hard function Argon2, the
winner of the Password Hashing Competition. The sec-
ond scheme pioneers the memory-hard encryption — the
security enhancement for password-based disk encryp-
tion, also based on Argon2.
References
[1] Avalon asic’s 40nm chip to bring hashing boost for less power,
2014. http://www.coindesk.com/avalon-asics-40nm-/
/chip-bring-hashing-boost-less-power/.
[2] Bitcoin: Mining hardware comparison,
avail-
able at https://en.bitcoin.it/wiki/Mining_hardware_
comparison. We compare 232 hashes per joule on the best
ASICs with 217 hashes per joule on the most efﬁcient x86-
laptops.
2014.
[3] Password Hashing
Competition,
//password-hashing.net/.
2015.
https:
[4] 2016. Andrew Miller, Bram Cohen, private communication.
[5] ABADI, M., BURROWS, M., AND WOBBER, T. Moderately
hard, memory-bound functions. In NDSS’03 (2003), The Internet
Society.
[6] ANDERSEN, D. A public review of cuckoo cycle. http://www.
cs.cmu.edu/~dga/crypto/cuckoo/analysis.pdf, 2014.
[7] BACK, A. Hashcash – a denial of service counter-measure, 2002.
available at http://www.hashcash.org/papers/hashcash.
pdf.
[8] BERNSTEIN, D. J., AND LANGE, T. Non-uniform cracks
in the concrete: The power of free precomputation.
In ASI-
ACRYPT’13 (2013), vol. 8270 of Lecture Notes in Computer Sci-
ence, Springer, pp. 321–340.
USENIX Association  
25th USENIX Security Symposium  325
11
[9] BIRYUKOV, A., AND KHOVRATOVICH, D. Tradeoff cryptanaly-
sis of memory-hard functions. In Asiacrypt’15 (2015). available
at http://eprint.iacr.org/2015/227.
[27] PERCIVAL, C. Stronger key derivation via sequential memory-
hard functions. http://www.tarsnap.com/scrypt/scrypt.
pdf.
[10] BIRYUKOV, A., AND KHOVRATOVICH, D. Argon2: new gener-
ation of memory-hard functions for password hashing and other
applications.
available at https:
//www.cryptolux.org/images/0/0d/Argon2.pdf.
In Euro S&P’16 (2016).
[11] BIRYUKOV, A., AND KHOVRATOVICH, D. Equihash: Asym-
metric proof-of-work based on the generalized birthday problem.
In NDSS’16 (2016). available at https://eprint.iacr.org/
2015/946.pdf.
[12] CAI, J., LIPTON, R. J., SEDGEWICK, R., AND YAO, A. C. To-
wards uncheatable benchmarks. In Structure in Complexity The-
ory Conference (1993), IEEE Computer Society, pp. 2–11.
[13] DWORK, C., GOLDBERG, A., AND NAOR, M. On memory-
bound functions for ﬁghting spam.
In CRYPTO’03 (2003),
vol. 2729 of Lecture Notes in Computer Science, Springer,
pp. 426–444.
[14] DWORK, C., AND NAOR, M. Pricing via processing or combat-
ting junk mail. In CRYPTO’92 (1992), vol. 740 of Lecture Notes
in Computer Science, Springer, pp. 139–147.
[15] DWORK, C., NAOR, M., AND WEE, H. Pebbling and proofs
of work. In CRYPTO’05 (2005), vol. 3621 of Lecture Notes in
Computer Science, Springer, pp. 37–54.
[16] DZIEMBOWSKI, S., FAUST, S., KOLMOGOROV, V., AND
PIETRZAK, K. Proofs of space. In CRYPTO’15 (2015), R. Gen-
naro and M. Robshaw, Eds., vol. 9216 of Lecture Notes in Com-
puter Science, Springer, pp. 585–605.
[17] GIRIDHAR, B., CIESLAK, M., DUGGAL, D., DRESLINSKI,
R. G., CHEN, H., PATTI, R., HOLD, B., CHAKRABARTI, C.,
MUDGE, T. N., AND BLAAUW, D. Exploring DRAM organi-
zations for energy-efﬁcient and resilient exascale memories. In
International Conference for High Performance Computing, Net-
working, Storage and Analysis 2013 (2013), ACM, pp. 23–35.
[18] HOANG, V. T., REYHANITABAR, R., ROGAWAY, P., AND
VIZ ´AR, D. Online authenticated-encryption and its nonce-
reuse misuse-resistance. In CRYPTO’15 (2015), R. Gennaro and
M. Robshaw, Eds., vol. 9215 of Lecture Notes in Computer Sci-
ence, Springer, pp. 493–517.
[19] HOPCROFT, J. E., PAUL, W. J., AND VALIANT, L. G. On time
versus space. J. ACM 24, 2 (1977), 332–337.
[20] JERSCHOW, Y. I., AND MAUVE, M. Ofﬂine submission with
RSA time-lock puzzles. In CIT (2010), IEEE Computer Society,
pp. 1058–1064.
[21] LORIMER, D. Momentum – a memory-hard proof-of-work via
available at http://www.
ﬁnding birthday collisions, 2014.
hashcash.org/papers/momentum.pdf.
[22] MAHMOODY, M., MORAN, T., AND VADHAN, S. P. Publicly
In ITCS (2013), ACM,
veriﬁable proofs of sequential work.
pp. 373–388.
[23] MALVONI,
K.
2014.
crack-
available
http://www.openwall.com/presentations/
ing,
at
Passwords14-Energy-Efficient-Cracking/.
Energy-efﬁcient
Passwords’14
conference,
bcrypt
[28] PIPPENGER, N. Superconcentrators. SIAM J. Comput. 6, 2
(1977), 298–304.
[29] RIVEST, R. L., SHAMIR, A., AND WAGNER, D. A. Time-lock
puzzles and timed-release crypto. https://people.csail.
mit.edu/rivest/pubs/RSW96.pdf.
[30] SPRENGERS, M., AND BATINA, L. Speeding up GPU-based
password cracking. In SHARCS’12 (2012). available at http:
//2012.sharcs.org/record.pdf.
[31] THOMPSON, C. D. Area-time complexity for VLSI. In STOC’79
(1979), ACM, pp. 81–88.
[32] TROMP, J. Cuckoo cycle: a memory bound graph-theoretic
proof-of-work. Cryptology ePrint Archive, Report 2014/059,
2014.
available at http://eprint.iacr.org/2014/059,
project webpage https://github.com/tromp/cuckoo.
[33] VAN OORSCHOT, P. C., AND WIENER, M. J. Parallel colli-
sion search with cryptanalytic applications. J. Cryptology 12, 1
(1999), 1–28.
[34] WAGNER, D. A generalized birthday problem. In CRYPTO’02
(2002), vol. 2442 of Lecture Notes in Computer Science,
Springer, pp. 288–303.
[35] ZAVERUCHA, G. Stronger password-based encryption using
available at http://research.
all-or-nothing transforms.
microsoft.com/pubs/252097/pbe.pdf.
A Merkle hash trees
We use Merkle hash trees in the following form. A
prover P commits to T blocks X[1],X[2], . . . ,X [T ] by
computing the hash tree where the blocks X[i] are at
leaves at depth logT and nodes compute hashes of their
branches. For instance, for T = 4 and hash function G
prover P computes and publishes
Φ = G(G(X[1],X[2]),G(X[3],X[4])).
Prover stores all blocks and all intermediate hashes. In
order to prove that he knows, say, X[5] for T = 8, (or to
open it) he discloses the hashes needed to reconstruct the
path from X[5] to Φ:
open(X[5]) = (X[5],X[6],g78 = G(X[7],X[8]),
g1234 = G(G(X[1],X[2]),G(X[3],X[4])),Φ),
so that the veriﬁer can make all the computations. If G
is collision-resistant, it is hard to open any block in more
than one possible way.
[24] MARTIN, L. Xts: A mode of aes for encrypting hard disks. IEEE
Security & Privacy, 3 (2010), 68–69.
[25] NAKAMOTO, S. Bitcoin: A peer-to-peer electronic cash system.
http://www.bitcoin.org/bitcoin.pdf.
[26] PARK, S., PIETRZAK, K., ALWEN, J., FUCHSBAUER, G., AND
GAZI, P. Spacecoin: A cryptocurrency based on proofs of space.
IACR Cryptology ePrint Archive 2015 (2015), 528.
326  25th USENIX Security Symposium 
USENIX Association
12