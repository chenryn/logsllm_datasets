### Acknowledgements
We extend our gratitude to our colleagues from other IARPA SPAR teams for their exceptional collaboration and the valuable exchange of ideas.

### References
1. **IARPA Security and Privacy Assurance Research (SPAR) Program**. [Online]. Available: <http://www.iarpa.gov/Programs/sso/SPAR/spar.html>
2. **Porter Stemming Algorithm**. [Online]. Available: <http://tartarus.org/martin/PorterStemmer/>
3. **Privacy Groups File Lawsuit Over License Plate Scanners**. [Online]. Available: <http://www.therepublic.com/view/story/210d27e7585543a3941f5e577cf7f627/CA--License-Plate-Suit>
4. **M. Abdalla, M. Bellare, D. Catalano, E. Kiltz, T. Kohno, T. Lange, J. Malone-Lee, G. Neven, P. Paillier, and H. Shi**. Searchable encryption revisited: Consistency properties, relation to anonymous IBE, and extensions. *J. Cryptol.*, 21(3):350–391, 2008.
5. **D. Beaver**. Precomputing oblivious transfer. In *CRYPTO'95*, volume 963 of LNCS, pages 97–109. Springer, Aug. 1995.
6. **M. Bellare, A. Boldyreva, and A. O’Neill**. Deterministic and efficiently searchable encryption. In *Proceedings of CRYPTO'07*, 2007.
7. **M. Bellare, V. T. Hoang, and P. Rogaway**. Foundations of garbled circuits. In *ACM CCS 12*, pages 784–796. ACM Press, Oct. 2012.
8. **B. H. Bloom**. Space/time trade-offs in hash coding with allowable errors. *Commun. ACM*, 13(7):422–426, 1970.
9. **D. Boneh, G. D. Crescenzo, R. Ostrovsky, and G. Persiano**. Public key encryption with keyword search. In *Proceedings of EUROCRYPT'04*, pages 506–522, 2004.
10. **D. Boneh and B. Waters**. Conjunctive, subset, and range queries on encrypted data. In *TCC 2007*, volume 4392 of LNCS, pages 535–554. Springer, Feb. 2007.
11. **D. Cash, S. Jarecki, C. S. Jutla, H. Krawczyk, M.-C. Rosu, and M. Steiner**. Highly-scalable searchable symmetric encryption with support for boolean queries. In *CRYPTO 2013, Part I*, volume 8042 of LNCS, pages 353–373. Springer, Aug. 2013.
12. **Y.-C. Chang and M. Mitzenmacher**. Privacy preserving keyword searches on remote encrypted data. In *ACNS*, volume 3531, 2005.
13. **M. Chase and S. Kamara**. Structured encryption and controlled disclosure. In *ASIACRYPT 2010*, volume 6477 of LNCS, pages 577–594. Springer, Dec. 2010.
14. **S. G. Choi, J. Katz, R. Kumaresan, and H.-S. Zhou**. On the security of the “free-XOR” technique. In *TCC 2012*, volume 7194 of LNCS, pages 39–53. Springer, Mar. 2012.
15. **B. Chor, N. Gilboa, and M. Naor**. Private information retrieval by keywords. *Technical Report TR-CS0917*, Dept. of Computer Science, Technion, 1997.
16. **B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan**. Private information retrieval. *J. ACM*, 45(6):965–981, 1998.
17. **R. Curtmola, J. A. Garay, S. Kamara, and R. Ostrovsky**. Searchable symmetric encryption: Improved definitions and efficient constructions. In *ACM CCS 06*, pages 79–88, 2006.
18. **E. De Cristofaro, Y. Lu, and G. Tsudik**. Efficient techniques for privacy-preserving sharing of sensitive information. In *TRUST'11*, pages 239–253, 2011.
19. **T. ElGamal**. A public key cryptosystem and a signature scheme based on discrete logarithms. *IEEE Transactions on Information Theory*, 31:469–472, 1985.
20. **S. Even, O. Goldreich, and A. Lempel**. A randomized protocol for signing contracts. In *CRYPTO'82*, pages 205–210. Plenum Press, New York, USA, 1982.
21. **C. Gentry**. Fully homomorphic encryption using ideal lattices. In *41st ACM STOC*, pages 169–178. ACM Press, May / June 2009.
22. **C. Gentry, K. A. Goldman, S. Halevi, C. Julta, M. Raykova, and D. Wichs**. Optimizing ORAM and using it efficiently for secure computation. In *Privacy Enhancing Technologies*, pages 1–18. Springer, 2013.
23. **C. Gentry, S. Halevi, and N. P. Smart**. Homomorphic evaluation of the AES circuit. In *CRYPTO 2012*, volume 7417 of LNCS, pages 850–867. Springer, Aug. 2012.
24. **Y. Gertner, Y. Ishai, E. Kushilevitz, and T. Malkin**. Protecting data privacy in private information retrieval schemes. *Journal of Computer and System Sciences*, 60(3):592–629, 2000.
25. **E.-J. Goh**. Secure indexes. *IACR Cryptology ePrint Archive*, 2003:216, 2003.
26. **O. Goldreich, S. Micali, and A. Wigderson**. How to play any mental game or A completeness theorem for protocols with honest majority. In *19th ACM STOC*, pages 218–229. ACM Press, May 1987.
27. **O. Goldreich and R. Ostrovsky**. Software protection and simulation on oblivious RAMs. *J. ACM*, 43:431–473, 1996.
28. **S. Goldwasser and S. Micali**. Probabilistic encryption. *Journal of Computer and System Sciences*, 28(2):270–299, 1984.
29. **S. D. Gordon, J. Katz, V. Kolesnikov, F. Krell, T. Malkin, M. Raykova, and Y. Vahlis**. Secure two-party computation in sublinear (amortized) time. In *ACM CCS 12*, pages 513–524, 2012.
30. **Y. Ishai, J. Kilian, K. Nissim, and E. Petrank**. Extending oblivious transfers efficiently. In *CRYPTO 2003*, volume 2729 of LNCS, pages 145–161. Springer, Aug. 2003.
31. **S. Jarecki, C. S. Jutla, H. Krawczyk, M.-C. Rosu, and M. Steiner**. Outsourced symmetric private information retrieval. In *ACM CCS 13*, pages 875–888. ACM Press, Nov. 2013.
32. **S. Kamara and C. Papamanthou**. Searching Dynamic Encrypted Data in Parallel. In *FC 2013*, 2013.
33. **D. M. Kays**. Reasons to “friend” electronic discovery law. *Franchise Law Journal*, 32(1), 2012.
34. **V. Kolesnikov**. Gate evaluation secret sharing and secure one-round two-party computation. In *ASIACRYPT 2005*, volume 3788 of LNCS, pages 136–155. Springer, Dec. 2005.
35. **V. Kolesnikov and R. Kumaresan**. Improved secure two-party computation via information-theoretic garbled circuits. In *SCN 12*, volume 7485 of LNCS, pages 205–221. Springer, Sept. 2012.
36. **V. Kolesnikov and T. Schneider**. Improved garbled circuit: Free XOR gates and applications. In *ICALP 2008, Part II*, volume 5126 of LNCS, pages 486–498. Springer, July 2008.
37. **V. Kolesnikov and T. Schneider**. A practical universal circuit construction and secure evaluation of private functions. In *FC 2008*, volume 5143 of LNCS, pages 83–97. Springer, Jan. 2008.
38. **Y. Lindell and B. Pinkas**. A proof of security of Yao’s protocol for two-party computation. *Journal of Cryptology*, 22(2):161–188, Apr. 2009.
39. **S. Lu and R. Ostrovsky**. Distributed oblivious RAM for secure two-party computation. In *TCC*, pages 377–396, 2013.
40. **D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella**. Fairplay - secure two-party computation system. In *USENIX Security Symposium*, pages 287–302, 2004.
41. **T. Moataz and A. Shikfa**. Boolean symmetric searchable encryption. In *ASIACCS 2013: 8th ACM Symposium on Information, Computer and Communications Security*, 2013.
42. **M. Naor and B. Pinkas**. Computationally secure oblivious transfer. *Journal of Cryptology*, 18(1):1–35, Jan. 2005.
43. **J. E. Pace III**. Testing the security blanket: An analysis of recent challenges to stipulated blanket protective orders. *Antitrust Magazine*, 19(3), 2005.

### Appendix A: Representing Query & Policy

#### Encoding a Query
In our system, a query is represented as a Bloom filter. This filter contains all the relevant columns, operations, and search terms and conditions. For example, consider the following query:
```sql
SELECT id WHERE fname = 'ALICE' AND dob <= '1975-01-01' AND CONTAINED_IN(notes1, 'engineer')
```
The Bloom filter will contain the following:
- `fname`, `fname:=`, `fname:ALICE`, `fname:=:ALICE`
- `dob`, `dob:1975-01-01`, `dob:<=:1975-01-01`
- `notes1`, `notes1:contained_in`, `notes1:engineer`, `notes1:contained_in:engineer`

#### Policy Circuit
The current implementation provides a parser for any policy that can be represented as a monotone DNF, where each variable indicates whether some policy condition (Bloom filter keyword) belongs to the input Bloom filter representing a query. If the formula output is true, then the client's query is disallowed. For example, a policy may disallow a query if it contains an equality check on `fname` with value `ALICE` and a range in `dob`. In this case, the policy circuit is a simple formula `V1 AND V2`, where the variable `V1` is true if the input Bloom filter contains `fname:=:ALICE`, and `V2` is true if the filter contains `dob:<=`.

We believe this provides a wide coverage of policies. For example, our parser also supports a policy that allows only range operations on `fname`, indirectly. One technical issue is that we do not want to allow any false approval of a query that fails the policy (though a tunable small probability of false rejection of a good query is acceptable), but the Bloom filters allow no false negatives. We can fix this issue by adding keywords representing the absence of certain columns or column operators to the Bloom filter. In the example above, the system adds the following keywords:
- `NOT:fname:range`, `NOT:dob:=`, `NOT:notes1:stem`, `NOT:lname`, `NOT:zip`, `NOT:marital_status`, etc.

Now, the aforementioned policy is equivalent to one that disallows queries if the corresponding Bloom filter contains `fname` and `NOT:fname:range`. If the check succeeds, then the query is disallowed. Similarly, a policy allowing only equality operations on `dob` will check if the filter has `dob` and `NOT:dob:=`. The policy can now disallow queries that do not contain an equality on the `dob` column or that do not contain `lname`. More importantly, the policy can now enforce that the query must have a `lname` value if `fname` was present.

### Appendix B: One-Case Indistinguishability

Here, we provide a formal definition of one-case indistinguishability. Since our system realizes the ideal functionality \(F_{db}\), the definitions concern only input/output behavior and the leakage profile \(L\).

The distribution \(E\) discussed in Section V-B with \(\delta\) is defined as follows:
- Let \((D_0, q, r)\) be a database, a query, and a record as specified in Section V-B.
- Choose a record in \(D_0\) uniformly at random and replace it with \(r\). Let \(D_1\) be the modified database.
- Choose a bit \(b \in \{0, 1\}\) according to the following distribution:
  - \(Pr[b = 1] = \delta\)
  - \(Pr[b = 0] = 1 - \delta\)
- Run \(F_{db}\), calling `Init` with \((D_0, P)\), and `Query` with \(q\).
- Let \(v\) be the leakage to the index server. Output \((b, v)\).

We show that our system satisfies one-case indistinguishability. Note that the initial leakage is none, and therefore, we only need to consider the query leakage, which is the query pattern and the tree search pattern. This implies that we only need to consider the tree search pattern since the same query is considered in the experiment. Observe that the newly introduced record \(r\) is equivalent to adding random paths in terms of the tree search pattern. Therefore, it suffices to focus on the number of added random paths. In particular, let \(D^+\) be defined as follows:
- \(x \leftarrow D\); output \((x + 1)\).

Now, consider the following game \(X\):
- Choose a bit \(b \in \{0, 1\}\) such that \(Pr[b = 1] = \delta\) and \(Pr[b = 0] = 1 - \delta\).
- If \(b = 0\), let \(x \leftarrow D\); otherwise, let \(x \leftarrow D^+\).
- Output \((b, x)\).

We show that for any \(x\), it holds that:
- When \(2 \leq x \leq \alpha - 1\), it holds that:
  \[
  Pr[b = 1 | x] = \frac{\delta / \alpha}{\delta / \alpha + (1 - \delta) / \alpha} = \delta
  \]
- When \(x \geq \alpha\), it holds that:
  \[
  Pr[b = 1 | x] = \frac{\delta \cdot (1 / \alpha) \cdot 1 / 2^{x - \alpha}}{\delta \cdot (1 / \alpha) \cdot 1 / 2^{x - \alpha} + (1 - \delta) \cdot (1 / \alpha) \cdot 1 / 2^{x - \alpha + 1}} = \frac{\delta}{\delta + (1 - \delta) / 2} \leq 2\delta
  \]

We show this by using case analysis:
- When \(x \leq 1\), it never comes from \(D^+\), so the inequality trivially holds.