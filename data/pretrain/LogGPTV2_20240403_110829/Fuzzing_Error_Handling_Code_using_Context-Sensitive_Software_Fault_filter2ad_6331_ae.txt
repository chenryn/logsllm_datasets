Memory
corruption
Arbitrary
read
Memory
overread
36
0
0
0
2
1
39
0
5
1
0
0
0
6
0
0
2
0
0
0
2
0
0
2
1
0
0
3
Table 7: Security impact classiﬁed by bug type.
Program
vim
bison
ffmpeg
nasm
catdoc
clamav
cﬂow
gif2png+libpng
openssl
Total
689
108
5
7
29
29
105
4
18
994
FIFUZZ_insensitive
FIFUZZ
Useful error
sequence
Useful error
sequence
Alert
1
3
0
2
2
1
1
0
0
10
Bug
1
3
0
1
2
1
1
0
0
9
1,664
289
516
78
38
325
217
6
671
3,804
Alert
58
11
35
8
2
103
1
0
80
298
Bug
12
6
12
1
3
6
1
1
8
50
Table 8: Results of sensitivity analysis.
without considering their calling contexts. We evaluate the
resulting tool on the 9 tested applications in Table 3, without
using any sanitizer. Each application is also tested for three
times, and the time limit of each testing is 24 hours. Table 8
shows the results of the resulting tool (FIFUZZ_insensitive)
and FIFUZZ.
Compared to FIFUZZ, the resulting tool generates less
useful error sequences that increase code coverage. Indeed,
some error handling code is only triggered when related error
sites fail in speciﬁc calling contexts and succeed in other
calling contexts, but the resulting tool always makes these
error sites fail and cannot cover such code. The results indicate
that our context-sensitive SFI method is effective in covering
hard-to-trigger error handling code.
Besides, the resulting tool ﬁnds 9 bugs (including 8 null-
pointer dereferences and 1 memory error). All these bugs
are also reported by FIFUZZ, but 41 bugs found by FIFUZZ
are missed by this tool, because it does not consider calling
contexts of error sites. The results indicate that our context-
sensitive SFI method is effective in ﬁnding deep bugs in
different calling contexts.
5.6 Comparison to Existing Fuzzing Tools
Many fuzzing approaches have proposed to test infrequently
executed code and shown promising results in bug detection.
Among them, we select four state-of-the-art and open-source
fuzzing tools to make detailed comparison, including AFL [1],
AFLFast [13], AFLSmart [50] and FairFuzz [38]. Meanwhile,
to validate the generality of FIFUZZ, we select 5 common
programs (including nm, objdump, size, ar and readelf) in the
Binutils toolset [12] of an old version 2.26 (release in Jan-
uary 2016) as tested programs, instead of the 8 applications of
the lasted versions in the above experiments. We use FIFUZZ
and the four fuzzing tools to fuzz each program without us-
ing any sanitizer for three times, and the time limit of each
fuzzing is 24 hours. For the alerts or crashes reported by these
tools, we also check their root causes to count unique bugs.
Figure 13 plots the covered code branches of each tested
program during fuzzing. Compared to AFL and AFLFast,
FIFUZZ covers more code branches in all the tested programs,
by covering much more error handling code. Compared to
Figure 12: Two use-after-free bugs found in clamav.
5.4 Security Impact of Found Bugs
We manually review the 50 found bugs to estimate their secu-
rity impact. The results are shown in Table 7, classiﬁed by bug
type, including double-free, use-after-free, buffer-overﬂow
and free-invalid-pointer bugs. The results show that many
found bugs can cause serious security problems, such as mem-
ory corruption and arbitrary read.
Figure 12 shows two use-after-free bugs reported in clamav.
When the program starts, the function cli_ac_addsig is ex-
ecuted, and it calls cli_ac_addpatt that can fail and trig-
ger error handling code. In this code, mpool_free is called
to free the pointer new. When the program exits, the func-
tion cli_ac_free is called, and it executes a loop to handle
each element patt in the pointer array root->ac_pattable.
When i is a speciﬁc value, patt is an alias of new which
has been freed in cli_ac_addsig, and then patt is used to
access patt->virname (a pointer) and patt->special (a
condition variable), causing two use-after-free bugs. Once
these bugs are triggered, the attacker can exploit them to con-
trol the values of patt->virname and patt->special, and
thus to corrupt memory and switch the control ﬂow between
the branches of the if statement in line 581.
5.5 Comparison to Context-Insensitive SFI
In FIFUZZ, our context-sensitive SFI method is an impor-
tant technique of covering error handling code in different
calling contexts. To show the value of this technique, we
modify FIFUZZ by replacing it with a context-insensitive
SFI method, which builds error sequences using error sites,
2604    29th USENIX Security Symposium
USENIX Association
FILE: clamav/libclamav/matcher-ac.c572.void cli_ac_free(struct cli_matcher *root) {  ......577.for (i = 0; i ac_patterns; i++) {// ''patt'' can be ''new'' given specific ''i''578.patt = root->ac_pattable[i];   ......580.mpool_free(root->mempool, patt->virname)  // use after free581.if (patt->special) // use after free  ......620.}2413. int cli_ac_addsig(struct cli_matcher *root, ...) {  ......2835.     if ((ret = cli_ac_addpatt(root, new))) {  ......2839.    mpool_free(root->mempool, new);  // free ''new''2840.    return ret;2841.     }  ......2857. }Figure 13: Code coverage of FIFUZZ and the four fuzzing tools.
Program
nm
objdump
size
ar
readelf
Total
Null
AFL
MemErr
0
0
0
0
0
0
1
1
0
0
0
2
AFLFast
MemErr
Null
0
0
0
0
0
0
1
1
0
0
0
2
All
1
1
0
0
0
2
All
1
1
0
0
0
2
AFLSmart
MemErr
Null
0
1
0
0
0
1
1
1
0
0
0
2
All
1
2
0
0
0
3
FairFuzz
MemErr
Null
0
0
0
0
0
0
1
1
1
0
0
3
FIFUZZ
MemErr
Null
4
2
2
4
0
12
1
1
0