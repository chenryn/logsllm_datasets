### 优化后的文本

#### 表7：按漏洞类型分类的安全影响
| 漏洞类型 | 内存损坏 | 任意读取 | 内存越界读取 |
| --- | --- | --- | --- |
| 数量 | 36 | 2 | 5 |

#### 表8：敏感性分析结果
| 程序 | vim | bison | ffmpeg | nasm | catdoc | clamav | cflow | gif2png+libpng | openssl | 总计 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 测试用例数 | 689 | 108 | 5 | 7 | 29 | 29 | 105 | 4 | 18 | 994 |
| FIFUZZ_insensitive | 有用错误序列 | 警告 | 1 | 3 | 0 | 2 | 2 | 1 | 1 | 0 | 0 | 10 |
| FIFUZZ_insensitive | Bug | 1 | 3 | 0 | 1 | 2 | 1 | 1 | 0 | 0 | 9 |
| FIFUZZ | 有用错误序列 | 1,664 | 289 | 516 | 78 | 38 | 325 | 217 | 6 | 671 | 3,804 |
| FIFUZZ | 警告 | 58 | 11 | 35 | 8 | 2 | 103 | 1 | 0 | 80 | 298 |
| FIFUZZ | Bug | 12 | 6 | 12 | 1 | 3 | 6 | 1 | 1 | 8 | 50 |

### 5.5 与上下文不敏感的SFI方法的比较
在FIFUZZ中，我们的上下文敏感SFI方法是覆盖不同调用上下文中的错误处理代码的重要技术。为了展示该技术的价值，我们将FIFUZZ修改为使用上下文不敏感的SFI方法，并对表3中的9个应用程序进行测试，未使用任何消毒器。每个应用程序进行了三次测试，每次测试的时间限制为24小时。表8显示了修改后的工具（FIFUZZ_insensitive）和FIFUZZ的结果。

与FIFUZZ相比，修改后的工具生成的有用错误序列较少，这减少了代码覆盖率。事实上，某些错误处理代码仅在特定的调用上下文中触发，而在其他上下文中不会触发，但修改后的工具总是使这些错误点失败，无法覆盖此类代码。结果表明，我们的上下文敏感SFI方法在覆盖难以触发的错误处理代码方面是有效的。

此外，修改后的工具发现了9个漏洞（包括8个空指针解引用和1个内存错误）。所有这些漏洞也被FIFUZZ报告，但FIFUZZ发现的41个漏洞被该工具遗漏，因为它没有考虑错误点的调用上下文。结果表明，我们的上下文敏感SFI方法在不同调用上下文中发现深层漏洞方面是有效的。

### 5.6 与现有模糊测试工具的比较
许多模糊测试方法已经提出用于测试不常执行的代码，并在漏洞检测方面显示出良好的效果。其中，我们选择了四个最先进的开源模糊测试工具进行详细比较，包括AFL [1]、AFLFast [13]、AFLSmart [50] 和 FairFuzz [38]。同时，为了验证FIFUZZ的通用性，我们选择了Binutils工具集 [12] 中的一个旧版本2.26（发布于2016年1月）中的5个常用程序（包括nm、objdump、size、ar和readelf），而不是上述实验中的最新版本的8个应用程序。我们使用FIFUZZ和这四个模糊测试工具对每个程序进行三次模糊测试，每次测试的时间限制为24小时。对于这些工具报告的警告或崩溃，我们也检查其根本原因以统计唯一漏洞。

图13绘制了每个测试程序在模糊测试过程中覆盖的代码分支。与AFL和AFLFast相比，FIFUZZ在所有测试程序中覆盖了更多的代码分支，尤其是覆盖了更多的错误处理代码。

### 5.4 找到的漏洞的安全影响
我们手动审查了找到的50个漏洞，以估计它们的安全影响。结果如表7所示，按漏洞类型分类，包括双重释放、使用后释放、缓冲区溢出和释放无效指针漏洞。结果显示，许多找到的漏洞可能导致严重的安全问题，如内存损坏和任意读取。

图12展示了在clamav中报告的两个使用后释放漏洞。当程序启动时，执行函数cli_ac_addsig，并调用可能失败并触发错误处理代码的cli_ac_addpatt。在此代码中，调用mpool_free释放指针new。当程序退出时，调用函数cli_ac_free，并执行一个循环来处理指针数组root->ac_pattable中的每个元素patt。当i为特定值时，patt是new的别名，而new已在cli_ac_addsig中被释放，然后使用patt访问patt->virname（一个指针）和patt->special（一个条件变量），导致两个使用后释放漏洞。一旦这些漏洞被触发，攻击者可以利用它们控制patt->virname和patt->special的值，从而在第581行if语句的分支之间切换控制流。

```c
// 文件: clamav/libclamav/matcher-ac.c
572. void cli_ac_free(struct cli_matcher *root) {
    ...
577. for (i = 0; i < root->ac_patterns; i++) { // 当i为特定值时，patt可以是new
578.     patt = root->ac_pattable[i];
    ...
580.     mpool_free(root->mempool, patt->virname); // 使用后释放
581.     if (patt->special) // 使用后释放
    ...
620. }

2413. int cli_ac_addsig(struct cli_matcher *root, ...) {
    ...
2835.     if ((ret = cli_ac_addpatt(root, new))) {
        ...
2839.         mpool_free(root->mempool, new); // 释放new
2840.         return ret;
2841.     }
    ...
2857. }
```

图13：FIFUZZ和四个模糊测试工具的代码覆盖率。

| 程序 | nm | objdump | size | ar | readelf | 总计 |
| --- | --- | --- | --- | --- | --- | --- |
| AFL | 内存错误 | 空指针 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 2 |
| AFLFast | 内存错误 | 空指针 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 2 |
| AFLSmart | 内存错误 | 空指针 | 0 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 2 | 3 |
| FairFuzz | 内存错误 | 空指针 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 3 |
| FIFUZZ | 内存错误 | 空指针 | 4 | 2 | 2 | 4 | 0 | 12 | 1 | 1 | 0 | 14 |

通过以上优化，文本变得更加清晰、连贯和专业。希望这对你有帮助！