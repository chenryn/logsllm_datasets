        unsigned char ip_addr;
        void *child;   //这里弄成一个void指针，其可能是last_node类型，也可能是tree_node类型
        struct tree_node *next;
    };
其中，last_node结构体用于具体描述IP的访问分布，tree_node结构体更多的是用作索引，用来快速的检索真正需要的last_node元素。
在我们自己的实现中，最终tree_node / last_node都采用了链表的方式实现。但实际上，
_对于独立IP数很高的大厂，tree_node可以用数组的方式进行更加快速的查找_ ，也会更加的优美。（链表查找需要遍历，数组查找仅需计算地址）
一番调整后，整个思路终于得以被完整实现。这下可以美滋滋了？显然不是。
# 四、拒绝逐个比特遍历：亿级IP访问密度高速计算优化
数据已经是收集起来了，但很快我们又遇到一个问题。
因为方案采取的是T+1输出慢速爬虫可疑IP列表，所以我们会发现，系统负载每到整小时的时候（起了另一个线程去计算）就出现大量的增加，甚至于影响了整体的性能。
**就很气，就不太优美。**
仔细检查了下原先的逻辑：
_遍历整棵树 - > 遍历每个last_node中的timeline数组 -> 根据遍历结果计算可疑IP_
很显然在这个过程中我们几乎遍历了整个内存空间，这个空间有多大呢——109GB：
但是我们真的需要这么做么？其实我只关心的是，这个IP地址在这个小时内“有没有”发生过访问，实质上是一个布尔值。为了一个布尔值去遍历整个字节，是不是有些不太值得，更重要的是不太优美？
好的，那再来优化性能，这回用的是位图。
咳咳咳，解释一下这里的位图。这货不是“苍老师.BMP”这个玩意儿，而是一个特殊的数据结构，
**它是一大堆连续布尔值的集合，对于其中一个布尔值用特定位置的一个比特表示。**
即，如果一个1字节的位图，它可以表示成连续8个布尔值。比如，0xBF = 10111111
我们将上面提到的timeline用位图表示，就可以变成char bitmap[91]，遍历的内存范围缩小为原来的约6%。
紧接而来的是另一个问题： **如何快速的对给定的一串字节，从中获取为1的位的个数？**
马上能想到的方案有两种：  
_遍历每个位，计算1的个数，或者，创建一个固定长度的位图表，查表得出1的个数。_
显然第二种做法是用空间换时间，位图表越长，检索的次数就越少，相应的占用的空间会越多。比如一个32位的位图表，它就将占用 (2^32) * (16+8) =
12GB的空间。这丝毫不能缓解我们的担忧嘛……不行，不优美，不要这个方案。
有没有一种方案就像编译器优化乘法一样，用一些类似魔数+移位的方式来获得1的个数呢？
嘿嘿嘿，当然有。
MIT曾经在一份备忘录中提到过类似的算法，它将一个定长整数经过移位和一些简单的逻辑运算后得到这个整数中1的个数。具体算法如下：
    uint8_t count1(uint32_t x) { 
        x = (x & 0x55555555UL) +((x >> 1) & 0x55555555UL);
        x = (x & 0x33333333UL) +((x >> 2) & 0x33333333UL);
        x = (x & 0x0f0f0f0fUL) +((x >> 4) & 0x0f0f0f0fUL);
        x = (x & 0x00ff00ffUL) +((x >> 8) & 0x00ff00ffUL);
        x = (x & 0x0000ffffUL) +((x >> 16) & 0x0000ffffUL);
        return x;
    }
那这样一来，其实有两种方案可选，一种是将位图表缩小到16位进行查表操作，一种是使用这个移位算法。
我们需要对比一下两种方案的优劣。
对于查表操作，表面上看效果很好，只需要进行一次寻址过程即可大功告成。而移位算法需要进行10 次 &， 5 次移位， 5 次加法，看起来会慢一些。
虽然查表过程只需要1次寻址，但这个寻址是在内存中进行的，即CPU至少需要一个访问内存的指令。在现在的CPU结构中，内存的速度比起CPU来说是很慢的，大约需要250个时钟周期。移位算法如果能全部在寄存器中操作，则只需要
10 + 5 + 5 = 20 个时钟周期。
250 >> 20。
是是是，你没说错，CPU的L1确实比内存要快很多。但L1不由我们控制，而且你要把192KB的一张大表（对于L1可怜巴巴的那点大小而言）放到L1中。指令不要缓冲了（数据也放不进指令缓存）？流水线不用预测了？都给你放完L1我挖矿怎么办？寄希望于把表缓到L1里加速不现实，也不优美。
回过头我们使用-O3来编译移位算法，看看是不是符合我们的设想：
果然，它全部变成了寄存器和立即数的操作。
到这个份儿上了还能优化吗？当然可以！call和retn指令需要整理堆栈信息，而且还容易有一个大大的jmp到处乱飞。我们把这段内联汇编（或者就直接拿源代码）写成一个宏，抛弃耗时的函数调用过程。
现在这样，就很优美了。
# 五、最终结果：一台128GB内存的机器撑起了一片天空
经过调整后的服务很快就上线了，正如上面截图所示，我们花了100多GB的内存撑起了这个服务。而且经过一段时间的验证，我们通过这个小功能（虽然优化过程很坎坷），发现了潜藏很久的慢速爬虫。
我也深知，反爬虫的挑战其实是丰富多样的，仅凭IP一个维度的数据很难观察到事件的核心。事实上，我们除了对访问分布进行监控外，依然安排了很多其他措施共同对抗爬虫的“入侵”。仅凭一把武器是拿不下一场战争的，只有对事件进行多维度的描述，才能够更接近本质。与君共勉
最后致个歉，大家看我唠唠叨叨BB了这么多个字，源码呢？很抱歉，受制于保密协议，我不能提供这个工具的源代码，还请大家谅解。