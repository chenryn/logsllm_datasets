.text:004037AE var_420         = dword ptr -420h  
.text:004037AE var_41C         = dword ptr -41Ch  
.text:004037AE var_4           = dword ptr -4  
.text:004037AE hinstDLL        = dword ptr  8  
.text:004037AE fdwReason       = dword ptr  0Ch  
.text:004037AE lpReserved      = dword ptr  10h  
.text:004037AE  
.text:004037AE ; FUNCTION CHUNK AT  ➊.text:004040D7 SIZE 00000011 BYTES  
.text:004037AE ; FUNCTION CHUNK AT .text:004129ED SIZE 0000000A BYTES  
.text:004037AE ; FUNCTION CHUNK AT .text:00413DBC SIZE 00000019 BYTES  
.text:004037AE  
.text:004037AE                 push    ebp  
.text:004037AF                 mov     ebp, esp  
通过双击与函数块关联的地址（如➊处），可迅速到达该函数块。在反汇编代码清单中，IDA通过界定其指令范围的注释和涉及其所属函数的注释来说明函数块，如下所示：
.text:004040D7 ; START OF FUNCTION CHUNK FOR ChunkedFunc  
.text:004040D7  
.text:004040D7 loc_0040C0D7: ; CODE XREF: ChunkedFunc+72↑j  
.text:004040D7                 dec     eax  
.text:004040D8                 jnz     loc_403836  
.text:004040DE                 call    sub_4040ED  
.text:004040E3                 jmp     loc_403836  
.text:004040E3 ; END OF FUNCTION CHUNK FOR ChunkedFunc 
有时候，IDA 可能无法确定与函数关联的每一个块，或者函数可能被错误地识别成函数块，而非函数本身。在这种情况下，你需要创建自己的函数块，或删除现有的函数块。
要创建新的函数块，首先要选择属于该块的地址范围（不得属于现有的任何函数），并选择Edit▶Functions ▶Append Function Tail命令。这时，IDA 会要求你从所有已定义的函数列表中选择该函数的父函数。
说明
  在反汇编代码清单中，函数块就叫做函数块；在IDA 的菜单系统中，函数块叫做函数尾 （function tail ）。
要删除现有的函数块，将光标放在要删除的块中的任何一行上，然后选择Edit▶Functions ▶ Remove Function Tail即可。这时，IDA 会要求你在删除选中的块之前确认该项操作。
如果函数块只会造成更多麻烦，你可以在初次将文件加载到IDA 时，取消选择Create function tails加载器选项，要求IDA 不要创建函数块。这个选项是一个加载器选项，可通过最初的文件加载对话框中的Kernel Options （核心选项，参见第4章）访问。如果禁用了函数尾，你看到的主要不同是，已经包含函数尾的函数将包含指向函数边界以外区域的跳转。IDA 会在反汇编代码清单左侧的箭头窗口中用红线和箭头突出显示这些跳转。在对应函数的图形视图中，这些跳转的目标并不显示。
4. 函数特性
IDA 为它识别的每一个函数提供许多特性。如图7-7所示的函数属性对话框可用于编辑其中的某些特性。下面说明每一个可修改的属性。
图7-7
  函数编辑对话框
函数名称
 。提供另外一种更改函数名称的方法。
起始地址
 。函数中第一条指令的地址。通常，IDA 会在分析过程中，或根据创建函数时所使用的地址，自动识别这个地址。
结束地址
 。函数中最后一条指令之后的地址。通常，它是函数的返回语句之后的指令的地址。多数情况下，IDA 会在分析阶段或在创建函数的过程中自动识别这个地址。如果 IDA无法正确定位一个函数的结束部分，你就需要手动编辑这个值。记住，这个地址并不是函数的一部分，而是函数的最后一条指令之后的地址。
局部变量区
 。函数的局部变量（见图6-4）专用的栈字节数。多数情况下，IDA 会通过分析函数的栈指针的行为，自动计算出这个值。
保存的寄存器
 。为调用方保存寄存器（见图6-4）所使用的字节数。IDA 认为保存的寄存器区域放在保存的返回地址顶部、与函数有关的所有局部变量的下方。一些编译器选择将寄存器保存在函数局部变量的顶部。IDA 认为保存这些寄存器所使用的空间属于局部变量区域，而非保存的寄存器区域。
已删除字节
 。已删除字节表示当函数返回调用方时，IDA从栈中删除的参数的字节数。对cdecl
 函数而言，这个值始终为0 。对stdcall
 函数来说，这个值表示传递到栈上的所有参数（见图6-4）占用的空间。在x86 程序中，如果IDA 观察到程序使用了返回指令的RET N
 变体，它将自动确定这个值。
帧指针增量
 。有时候，编译器可能会对函数的帧指针进行调整，使其指向局部变量区域的中间，而不是指向保存在局部变量区域底部的帧指针。调整后的帧指针到保存的帧指针之间的这段距离叫做帧指针增量（frame pointer delta ）。多数情况下，IDA 会在分析函数的过程中自动计算出帧指针增量。编译器利用栈帧增量进行速度优化。使用增量的目的，是在离帧指针1字节（带符号）的偏移量（128～+127）内保存尽可能多的栈帧变量。
还有另外一些特性复选框可用于设置函数的特性。与对话框中的其他选项一样，这些复选框通常反映的是IDA 自动分析得到的结果。以下是这些可启用也可禁用的属性。
不返回
 。函数不返回到它的调用方。如果调用这样的函数，在相关的调用指令之后，IDA认为函数不会继续执行。
远函数
 。这个属性用于在分段体系结构上将一个函数标记为远函数。在调用该函数时，函数的调用方需要指定一个段和一个偏移值。通常，是否使用远调用，应由程序中使用的内存模式决定，而不是由体系结构支持分段［例如，在x86体系结构上使用了大
 内存模式（相对于平
 内存模式）］决定。
库函数
 。这个属性将一个函数标记为库代码。库代码可能包括静态链接库中的编译器或函数所包含的支持例程。将一个函数标记为库函数后，该函数将以分配给库函数的颜色显示，从而与非库代码区分开来。
静态函
 数。除在函数的特性列表中显示静态修饰符外，其他什么也不做。
基于BP的帧
 。这个特性表示函数利用了一个帧指针。多数情况下，你可以通过分析函数的“序言”来自动确定这一点。但是，如果通过分析无法确定给定的函数是否使用了帧指针，就可以手动选择这个特性。如果你手动选择了这个特性，一定要相应地调整保存的寄存器的大小（通常指根据保存的帧指针的大小增大）和局部变量的大小（通常指根据保存的帧指针的大小减少）。对基于帧指针的帧而言，使用帧指针的内存引用被格式化，以利用符号栈变量名称，而非数字偏移量。如果没有设置这个特性，则认为栈帧引用与栈指针寄存器有关。
BP等于SP
 。一些函数将帧指针配置为在进入一个函数时指向栈帧（以及栈指针）的顶端。 在这种情况下，就应设置该属性。基本上，它的作用等同于将帧指针增量的大小设置为 等于局部变量区域。
5. 栈指针调整
如前所述，IDA 会尽其所能跟踪函数内每一条指令上的栈指针的变化。IDA 跟踪这种变化的准确程度，在很大程度上影响着函数的栈帧布局的准确程度。如果IDA 无法确定一条指令是否更改了栈指针，你就需要手动调整栈指针。
如果一个函数调用了另一个使用stdcall
 调用约定的函数，就会出现上述情况，这是最简单的一种情况。如果被调用的函数位于IDA 无法识别的共享库中（IDA 拥有与许多常用库函数的签名和调用约定有关的信息），那么，IDA 并不知道该函数使用了stdcall
 调用约定，也就无法认识到：被调用的函数会将栈指针修改后返回。因此，IDA 会为函数的剩余部分提供一个错误的栈指针值。在下面的函数调用中，some_imported_func
 即位于共享库中，这正好说明了上述问题（注意，“栈指针行部分”选项已被选中）：
     .text:004010EB     01C      push     eax  
     .text:004010F3     020      push     2  
     .text:004010FB     024      push     1  
➋   .text:00401102      028      call    some_imported_func  
     .text:00401107  ➊  028      mov     ebx, eax
由于some_imported_func
 使用的是stdcall
 调用约定，在返回时，它清除了栈中的3 个参数，➊处的正确栈指针值应为01C
 。修正这个问题的一种方法，是对➋处的指令进行手动栈调整。要进行栈调整，首先应选中进行调整的地址，并选择Edit▶Functions▶Change Stack Pointer （热键为ALT+K），然后指定栈指针更改的字节数，在本例中为12 。
虽然前面的例子能够解决这个问题，但这个特殊问题还有一个更好的解决办法。假如some_imported_func
 被调用了许多次，那该怎么办呢？这时，我们需要在some_imported_ func
 被调用的每一个位置进行上述栈调整。很明显，这是一个非常繁琐的任务，很容易出错。那么，我们最好是让IDA 了解some_imported_func
 的行为。因为我们处理的是一个导入的函数，如果我们尝试导航到该函数，我们将最终导航到该函数的导入表条目，如下所示:
.idata:00418078   ; Segment type: Externs
.idata:00418078   ; _idata
.idata:00418078         extrn some_imported_func:dword ; DATA XREF: sub_401034 ↑r  
尽管这是一个导入的函数，你也可以编辑有关其行为的一条信息：与该函数有关的已删除字节的数量。通过编辑这个函数，你可以指定它在返回时从栈中删除的字节数，IDA 将会“扩散”这一信息，将其应用于调用该函数的每一个位置，立即纠正每个位置的栈指针计算错误。
为了改进自动分析，IDA 融入了一些高级技术，通过一个与栈指针行为有关的线性方程系统来解决栈指针错误问题。因此，我们可能根本不会意识到，IDA 之前并不了解诸如some_imported_func
 之类的函数的详细信息。欲了解有关这些技术的更多信息，请参阅Ilfak 的博客标题为“Simplex method in IDA Pro”的文章，地址为http://hexblog.com/2006/06/
 。
7.3.4 数据与代码互相转换
在自动分析阶段，字节有时可能被错误地归类。数据字节可能被错误地归类为代码字节，并被反汇编成指令；而代码字节可能被错误地归类为数据字节，并被格式化成数据值。有许多原因会导致这类情况，如一些编译器将数据嵌入在程序的代码部分，或者一些代码字节从未被作为代码直接引用，因而IDA 选择不对它们反汇编。模糊程序则特别容易模糊代码部分与数据部分之间的区别。
无论你出于什么原因希望对反汇编代码重新格式化，这个过程都相当简单。在重新格式化之前，首先必须删除其当前的格式（代码或数据）。右击你希望取消定义的项目，在结果上下文菜单中选择Undefine（也可使用Edit▶Undefine命令或热键U），即可取消函数、代码或数据的定义。取消某个项目的定义后，其基础字节将作为原始字节值重新格式化。在执行取消定义操作之前，使用“单击并拖动”操作选择一个地址范围，可以取消大范围内的定义。下面以一个简单的函数为例：
.text:004013E0 sub_4013E0      proc near  
.text:004013E0                 push    ebp  
.text:004013E1                 mov     ebp, esp  
.text:004013E3                 pop     ebp  
.text:004013E4                 retn  
.text:004013E4 sub_4013E0      endp  
取消这个函数的定义将得到下面这些未分类的字节，我们几乎可以以任何方式重新对它们进 行格式化：
.text:004013E0 unk_4013E0      db  55h ; U  
.text:004013E1                 db  89h ; ë  
.text:004013E2                 db 0E5h ; s  
.text:004013E3                 db  5Dh ; ]  
.text:004013E4                 db 0C3h ; +    
要反汇编一组未定义的字节，右击其中的第一个字节，在上下文菜单中选择Code（也可使用Edit▶Code或热键C）。这样，IDA 将开始反汇编所有字节，直到它遇到一个已定义的项目或非法指令。在执行代码转换操作之前，使用“单击并拖动”操作选择一个地址范围，可以进行大范围代码转换操作。
将代码转换为数据的逆向操作要复杂一些。首先，使用上下文菜单不可能将代码转换为数据。你可以通过EditData 和热键D来完成。要想将指令批量转换为数据，最简单的方法是取消你希望转换为数据的所有指令的定义，然后对数据进行相应的格式化。基本的数据格式化将在下一节讨论。
7.4 基本数据转换
在了解程序行为的过程中，格式正确的数据可能和格式正确的代码一样重要。IDA 会收集不同来源的信息，并使用许多算法来决定对反汇编代码清单中的数据进行格式化的最佳方法。下面的一些例子说明了IDA 如何选择数据格式。
通过了解寄存器的使用方式，可以推断出数据类型和大小。如果一条指令从内存加载了一个32 位寄存器，我们可以据此推断，相关内存位置保存有一个4 字节的数据类型（虽然我们无法判断其到底是一个4字节整数，还是一个4字节指针）。
函数原型可用于为函数参数分配数据类型。为此，IDA 维护着一个庞大的函数原型库。我们可以对传递给函数的参数进行分析，尝试将一个参数与某个内存位置关联起来。如果可以确定这种关系，就可以对相关内存位置应用一种数据类型。以一个函数为例，该函数仅有的参数是一个指向CRITICAL_SECTION
 （一种Windows API数据类型）的指针。如果IDA 能够确定调用这个函数时传递的地址，它就可以将这个地址标记为CRITICAL_SECTION
 对象。
分析字节序列可以知道可能的数据类型。扫描二进制文件以从中查找字符串内容即是如此。如果发现较长的ASCII字符序列，即可认为它们属于字符数组。
在下面的几节中，我们将讨论可以对反汇编代码清单中的数据执行的一些基本转换。
7.4.1 指定数据大小
调整数据的大小是修改该数据的最简单方法。IDA 提供了许多数据大小/类型说明符。最常见的说明符包括db
 、dw
 和dd
 ，分别代表1 字节、2 字节和4 字节数据。第一种更改数据大小的方法是使用如图7-8所示的Options▶Setup Data Types（选项▶设置数据类型）对话框。
图7-8
  数据类型设置对话框
这个对话框分为两个部分。对话框的左侧是一组按钮，用于立即更改当前选中的项目的数据大小。对话框的右侧是一组复选框，用于配置IDA 中所谓的数据转盘
 （data carousel）。值得注意的是，左侧的每一个按钮，在右侧都有一个对应的复选框。数据转盘是一个不断循环的数据类型列表，其中仅包含选中的复选框所代表的数据类型。修改数据转盘的内容并不会立即影响IDA 的显示。而当我们右击一个数据项时，数据转盘中列出的每一种数据类型都会在上下文菜单中出现。因此，将数据重新格式化为数据转盘中的类型比格式化为数据转盘以外的类型要简单。根据图7-8中选择的数据类型，右击一个数据项，你可将这个数据项重新格式化为字节、字或双字数据。
数据转盘这一名称源自于相关的数据格式化热键D 的行为。按下D 键后，当前选中地址所在的数据项被重新格式化为数据转盘列表中的下一种数据类型。以前面包含3个数据项的列表为例，当前格式为db
 的项被切换为dw
 ，格式为dw
 的项被切换为dd
 ，格式为dd
 的项被切换为db
 ，从而完成了转盘的循环过程。对一个非数据项（如代码）使用格式化热键，该项将被格式化为转盘列表中的第一种数据类型（本例中为db
 ）。
切换数据类型会使数据项目变大、缩小或保持不变。如果一个项目的大小保持不变，那么，你能够观察到的唯一变化是格式化数据的方式的变化。如果你缩小某个项，例如，由dd
 （4字节）转换成db
 （1 字节），则额外的字节（这里为3 字节）将变成未定义字节。如果你增大某个项，且该项之后的字节为已定义字节，这时，IDA 会委婉地提醒你：是否希望取消下一个项的定义，以扩大当前的项。这时，IDA 显示的消息为：“直接转换成数据吗？”通常，这条消息表示IDA 会取消随后足够多的项目的定义，以满足你的要求。例如，将字节数据（db
 ）转换为双字数据（dd
 ）时，还需要另外3字节才能构成新的数据项。
你可以对任何描述数据（包括栈变量）的位置指定数据类型和大小。要更改栈分配的变量的大小，首先双击你希望修改的变量，打开详细栈帧视图，然后修改变量的大小。
7.4.2 处理字符串