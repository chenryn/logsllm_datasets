type typename represented by the value v into
the address represented by op (e.g., store i8
%frombool1, %y.addr).
5. GetElementPtr (GEP) is the instruction used by the
IR to represent structure and array-based accesses
and has fairly complex semantics [53]. A simpli-
ﬁed way to represent this is v = getelementptr
typename ob, off, which will get
the ad-
dress of the ﬁeld at
index off from the ob-
ject ob of type typename, and store the refer-
enced value in v (e.g., %val =
getelementptr
%struct.point %my point, 0).
Both our points-to and taint analysis implement trans-
fer functions based on these ﬁve instructions.
1012    26th USENIX Security Symposium
USENIX Association
Algorithm 2: Points-to analysis transfer functions
function updatePtoAlloca (φc,τc,δ ,I,v,locx)
function updatePtoBinOp (φc,τc,δ ,I,v,op1,op2)
function updatePtoLoad (φc,τc,δ ,I,v,op)
mappt ← φc(δ )
locx ← (x, /0, /0)
mappt (v) ← (0,locx)
mappt ← φc(δ )
pto1 ← mappt (op1)
pto2 ← mappt (op2)
set1 ← {(0,ob) | ∀( ,ob) ∈ pto1}
set2 ← {(0,ob) | ∀( ,ob) ∈ pto2}
mappt (v) ← mappt (v)∪ set1 ∪ set2
mappt ← φc(δ )
ptoop ← mappt (op)
set1 ← {ob(n) | ∀(n,ob) ∈ ptoop}
set2 ← {(0,ob) | ∀ob ∈ set1}
mappt (v) ← mappt (v)∪ set2
mappt ← φc(δ )
ptoop ← mappt (op)
ptov ← mappt (v)
setv ← {ob | ∀( ,ob) ∈ ptov}
∀(n,ob) ∈ ptoop do ob(n) ← ob(n)∪ setv
mappt ← φc(δ )
ptoop ← mappt (op)
setop ← {ob(n) | ∀(n,ob) ∈ ptoop}
setv ← {(o f f ,ob) | ∀ob ∈ setop}
mappt (v) ← mappt (v)∪ setv
function updatePtoStore (φc,τc,δ ,I,v,op)
function updatePtoGEP (φc,τc,δ ,I,v,op,o f f )
3.3 Points-to Analysis
The result of our points-to analysis is a list of values and
the set of all of the possible objects, and offsets, that
they can point to. Because of the way in which we con-
structed our alias location objects and transfer functions,
we are able to ensure that our points-to results are ﬁeld-
sensitive. That is, we can distinguish between objects
that are pointed to by different ﬁelds of the same object
(e.g., different elements in a struct). Thus, as imple-
mented in SDT, we are able to obtain points-to results
that are ﬂow-, context-, and ﬁeld-sensitive.
Dynamic allocation. To handle dynamic allocation in
our points-to analysis, we maintain a list of kernel func-
tions that are used to allocate memory on the heap (e.g.,
kmalloc, kmem cache alloc, get free page). For
each call-site to these functions, we create a unique alias
object. Thus, for a given context of a function, each allo-
cation instruction has a single alias location, regard-
less of the number of times that it is visited. For example,
if there is a call to kmalloc in the basic block of a loop,
we will only create one alias location for it.
Algorithm 3: Taint analysis transfer functions
function updateTaintAlloca (φc,τc,δ ,I,v,locx)
Nothing to do
function updateTaintBinOp (φc,τc,δ ,I,v,op1,op2)
function updateTaintLoad (φc,τc,δ ,I,v,op)
mapt ← τc(δ )
setv ← mapt (op1)∪ mapt (op2)
mapt (v) ← setv||I
mappt ← φc(δ )
ptoop ← mappt (op)
setop ← {obt (n)||I | ∀(n,ob) ∈ ptoop}
mapt ← τc(δ )
mapt (v) ← mapt (v)∪ setop
mappt ← φc(δ )
ptoop ← mappt (op)
mapt ← τc(δ )
trv ← mapt (v)
∀(n,ob) ∈ ptoop do obt (n) ← obt (n)∪ (trv||I)
function updateTaintGEP (φc,τc,δ ,I,v,op,o f f )
function updateTaintStore (φc,τc,δ ,I,v,op)
UPDATETAINTBINOP(φc,τc,δ ,I,v,op,o f f )
Internal kernel functions. Except for few kernel API
functions, whose effects can be easily handled (e.g.,
memcpy, strcpy, memset), we ignore all of the other
kernel APIs and core kernel functions.
For exam-
ple, if the target of a call instruction is the function
i2c master send, which is part of the core kernel, we
do not follow the call. Contrary to the other works, which
check for valid usage of kernel API functions [12,64], we
assume that all usages of these functions are valid, as we
are only concerned with analyzing the more error-prone
driver code. Thus, we do no follow any function calls
into the core kernel code. While, we may miss some
points-to information because of this, again sacriﬁcing
soundness, this assumption allows us to be more precise
within the driver and scale our analysis.
The update points-to transfer functions (updatePto*)
for the various instructions are as shown in Algorithm 2.
3.4 Taint Analysis
Taint analysis is a critical component of our system, as
almost all of our bug detectors use its results. Similar to
our points-to analysis, the results of our taint analysis are
ﬂow-, context-, and ﬁeld-sensitive.
The taint sources in our analysis are the arguments of
the entry functions. Section 5.3 explains the different
types of entry functions and their correspondingly tainted
arguments. We also consider special kernel functions
that copy data from user space (e.g., copy from user,
simple write to buffer) as taint sources and taint all
of the ﬁelds in the alias locations of the points-to map for
USENIX Association
26th USENIX Security Symposium    1013
c a l l
c h a r
Listing 2: A buffer overﬂow bug detected in Mediatek’s
Accdet driver by ITDUD where buf is assumed to be a
single character but the use of “%s” will continue read-
ing the buffer until a null-byte is found.
1 s t a t i c
2 . . .
3 s t a t i c
4
5
6
a c c d e t s t o r e c a l l s t a t e
( s t r u c t d e v i c e d r i v e r ∗ d d r i ,
c o n s t c h a r ∗ buf ,
t a i n t e d d a t a ∗∗
/ / ∗∗ Improper use o f
/ / b u f can c o n t a i n more t h a n one char !
i n t
r e t = s s c a n f ( buf , ”%s ” , & c a l l
s t a t u s ) ;
s t a t u s ;
s s i z e t
c o u n t )
s i z e t
7 {
i s checked , b u t
i t ’ s
t o o l a t e
I n v a l i d v a l u e s\n ” ) ;
/ / The r e t u r n v a l u e
i f
!= 1 ) {
( r e t
ACCDET DEBUG( ” a c c d e t :
r e t u r n -EINVAL ;
}
s t a t u s ) {
s w i t c h ( c a l l
c a s e CALL IDLE :
. . .
8
9
10
11
12
13
14
15
16
17
18
19
20
21 }
the destination operands of these functions. Our taint
propagators are implemented as various transformation
functions (updateTaint* in Algorithm 3). Similar to
our points-to analysis, we do not propagate taint for any
core kernel function calls, aside from a few exceptions
(e.g., memcpy). The taint sinks in our analysis are depen-
dent on the vulnerability detectors, as every detector has
its own taint policy. These detectors will raise warnings
if any tainted data violates a speciﬁed policy (e.g., if a
tainted value is used as the length in a memcpy).
4 Vulnerability Detectors
This section describes the various vulnerability detectors
that were used in our analysis. These detectors are highly
conﬁgurable and are able to act on the results from both
our points-to and taint analysis. They are implemented
as plugins that are run continuously as the code is being
analyzed, and operate on the results from our analysis
clients (i.e., taint and points-to analysis). Our architec-
ture enables us to very quickly implement new analyses
to explore new classes of vulnerabilities. In fact, in the
process of analyzing our results for this paper, we were
able to create the Global Variable Race Detector (GVRD)
detector and deploy it in less than 30 minutes.
Almost all of the detectors use taint analysis results to
verify a vulnerable condition and produce a taint trace
with all of their emitted warnings. The warnings also
provide the line numbers associated with the trace for
ease of triaging. The various bug detectors used by
DR. CHECKER in our analysis are explained below:
Improper Tainted-Data Use Detector (ITDUD) checks
for tainted data that is used in risky functions (i.e.,
strc*, strt*, sscanf, kstrto, and simple strto
e r r o r = -EINVAL ;
u n s i g n e d i ;
i n t
c h a r m l o g s t r [MLOG STR LEN ] ;
. . .
/ /
i f
l e n i s u n s i g n e d
( ! buf
l e n < 0 )
| |
g o t o o u t ;
e r r o r = 0 ;
/ /
i f
g o t o o u t ;
/ / b u f o f
i f
l e n n o t c h e c k e d a g a i n s t MLOG STR LEN
( ! l e n )
l e n c o n f i r m e d t o be i n u s e r
s p a c e
l e n ) ) {
( ! a c c e s s o k ( VERIFY WRITE , buf ,
e r r o r = -EFAULT ;
g o t o o u t ;
}
. . .
i = 0 ;
. . .
/ / ∗∗ I n t e g e r u n d e r f l o w bug ∗∗
/ /
/ / and i s compared w i t h u n s i g n e d i
w h i l e
( ! e r r o r && ( m l o g s t a r t
&& i < l e n - MLOG STR LEN) {
s i z e ;
l e n - MLOG STR LEN ( 1 6 ) can be n e g a t i v e
i n t
. . .
s i z e = s n p r i n t f ( m l o g s t r , MLOG STR LEN ,
s t r f m t
l i s t [ s t r f m t
i d x ++] , v ) ;
. . .
/ /
/ /
/ /
i f
e l s e {
t h i s
t h i s
p o t e n t i a l l y
(
e r r o r = -EFAULT ;
f u n c t i o n i s an u n s a f e copy
r e s u l t s
i n w r i t i n g p a s t b u f
i n t o k e r n e l a d d r e s s
c o p y t o u s e r ( buf , m l o g s t r ,
s p a c e
s i z e ) )
!= mlog end )
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44 }
Listing 3: A zero-day vulnerability discovered by
DR. CHECKER in Mediatek’s mlog driver using our
TAD and TLBD analysis. First TAD identiﬁed an integer
overﬂow bug (len - MLOG STR LEN). TLBD then iden-
tiﬁed that this tainted length was being used as a bound
condition for the while loop where data is being copied