Tag-side attacks against NFC
What is NFC?
Contactless communication between two 
devices in close proximity
Many uses, primarily door controls and 
payment systems
Why attack NFC?
Interesting technology
Low-level analysis tools can be prohibitively expensive
Known to be insecure, but still widely used
ISO-14443
Focuses on 13.56MHz NFC communication
Defines the characteristics of the communication performed between tags and readers
Two tag types based on it, A and B
ISO-14443A is the most commonly used of the standards
Low-level communication – ISO14443A
Tags are powered by electromagnetic induction
Communication is sent by the reader by disabling the field at specific intervals
The reader uses the Modified Miller coding scheme for transmitting data to the tag
Responses are sent by the tag by modifying the power being drawn from the reader
Tags use the Manchester coding scheme to modulate the load
Each communicated byte has an additional parity bit
Modified Miller
Disables field a defined intervals
Minimises power loss
Defined as follows:
•
0 bit after 0 bit: low for the first quarter of the transmission, followed by high for the remainder 
of the transmission
•
0 bit after 1 bit: high for the entire transmission
•
1 bit: high for the first half of the transmission, followed by low for one quarter of the 
transmission, and high for the remainder of the transmission
0
0
1
1
0
0
1
0
0
Manchester
Performed by modifying the phase of the signal
In NFC is communicated by modifying the load being drawn by the tag, using a subcarrier
1
0
0
1
0
Basic Enumeration
Anticollision
Performed when two tags are communicating with a 
reader
Involves requesting responses based on partial UIDs
Increases the number of bits requested until a single 
UID is identified
Once communication is complete, the next tag can be 
identified and communicated with
Encryption and Authentication – Mifare Ultralight
An authentication key is sent to the tag
If the key is accurate, the reader has authenticated with the tag and communication can 
perform
Failed attempts are logged, and in some cases can lock the chip
Can work with no authentication
Support for a wider number of authentication methods in newer versions
Encryption and Authentication – Mifare Classic
Utilises Crypto-1 algorithm
Reader requests authentication for a sector of the tag (0x60/0x61) 
Tag responds with a unique four byte nonce
Reader responds with a random value, followed by an encrypted number generated 
from the original nonce
Tag responds with an encrypted number generated from the nonce
All further communication is encrypted as authentication has been performed
Each sector of the tag can be authenticated using its own unique keys
Encryption and Authentication – Mifare DESFire
Based on different application IDs
Authentication based on DES, 3-DES or AES depending on version and configuration
Multiple keys can be used for authentication
Authenticated similarly to Mifare Classic
Not yet been broken in any meaningful manner 
Creating analysis tools
Existing tools and projects
Proxmark3 - https://proxmark.com/ 
Chameleon Mini - https://github.com/emsec/ChameleonMini
HydraNFC - https://hydrabus.com/hydranfc-1-0-specifications/
SimpleNFC - http://www.nonan.net/nkruse/simplenfc
Emutag - http://www.emutag.com/
NFC field detection
LED and a coil of wire
Useful for detecting when a field is active
Creating a passive sniffer – RTL-SDR
Powerful SDR, able to tune between 25MHz and 1700MHz
Configurable sample rate
Libraries available for simple communication
Problems:
Cannot tune down to 13.56MHz without hardware modifications
Cannot run at a low sample rate
Bundled with weak antenna
Not built for purpose
Creating a passive sniffer – RTL-SDR
Possible to tune to harmonic frequency, providing adequate signal (27.12MHz)
Can synchronise with the reader by setting sample rate to 1.695MHz
Antenna modifications not required, introducing a coil to the NFC field provides 
adequate power for analysis
Possible to detect communication from the reader to the tag
Constant signal means automatic gain control is possible
Accurate responses, providing real-time analysis of communication
Building a tag
Mifare Classic was used as the initial tag type
Wanted to build it with no standard NFC chipsets, as these would limit access to raw 
communication
Wanted to build it with minimal components
Full implementation of Crypto-1 authentication would be required, adding complexity to 
the project
By fully implementing the protocol weaknesses could be identified in it
Hardware requirements
Inductive coupling would be required in order to receive signal from reader
This signal would need to demodulated by amplitude
An appropriate Microcontroller which could synchronise to 13.56MHz would be 
required
The Microcontroller would need to be fast enough for encryption calculations
Sufficient memory would be required for storage of data
Inductive coupling - LC circuit
A circuit used to resonate with the field
Made of an inductor and a capacitor
For this purpose, a large coil of wire acts as inductor/antenna
Coil of wire was tuned to 10pF capacitor
Resonance can be checked with logic analyser, assessing whether wave frequency is 
13.56MHz 
Demodulation – envelope detector
Used in circuits to demodulate signal based on amplitude
Made from a diode, resistor and capacitor
Works by rectifying the signal, and then smoothing it
Values can be guessed by trial and error
Testing concluded that a 1K resistor and a 220pF capacitor were appropriate for this circuit
Appropriate values show Modified Miller communication in logic analyser
Receiving circuit
Final circuit built with very simple layout
Accurately receives communication from a reader with sufficient voltage to trigger GPIO
No need for additional smoothing or regulation 
Microcontroller selection
ATTiny84 was selected for the initial device
Utilises 8KB of program space, and 512B of RAM
Can be programmed using a standard Arduino, or dedicated programmer
Able to use external crystals to run at a specific frequency
DIP package makes it easy to build into prototypes
Receiving circuit could be attached to GPIO pins
Good support for interrupts and timers
Bad support for debugging
8-bit architecture may cause problems with fast calculation
Implementation
A 13.56MHz crystal and matching capacitors were connected to the ATTiny
Receiving circuit was connect to an input pin and output pin
Due to UART not being feasible with non-standard clock, debug strings were communicated 
via software-based SPI
An LED was attached to confirm when the device was active
The responses and state machine used by Mifare Classic were implemented, allowing the 
device to behave as a tag
Timing issues
Using a 13.56MHz crystal, ATTiny was synchronised with reader
At predefined intervals at 847.5KHz, value of GPIO was read
Attempting to match signal against exact timings provided inconsistent results, commands 
were only read accurately 50% of the time
This was found to be due to clock drift on the MCU
Instead, interrupts were configure to run whenever the signal went low, and times between 
interrupts were assessed
This yielded a 99% accuracy
Implementing Crypto-1
Crapto-1 library and Crypto-1 papers used as a reference for implementation
Found to be based on 48-bit keys utilised as two 24-bit keys
8-bit architecture of MCU meant that all multi-byte calculations would take much longer
Additionally, AVR machine code only allows for one bit-shift at a time, making it 
unsuitable for cryptography
Slow responses to authentication requests would cause compatibility issues
The filter function used for all calculations was identified to be the slowest function in 
use
Implementing Crypto-1
All Crypto-1 code was converted from C to AVR assembly
SimAVR was used to compare optimised assembly version against C version in 
environment with more effective debugging
All calculations which would be treated as 32-bit were performed as 24-bit operations
All bit-shifts were converted into more efficient operations:
•
16-bit shifts - move the two upper bytes to the lower two bytes
•
8-bit shifts - move the second lowest byte to the lowest byte
•
4-bit shifts – use the AVR SWAP operation to swap the upper and lower nibbles
•
2-bit shifts – two traditional shift operations
•
1-bit shifts – one traditional shift operation
These optimisations increased the speed of the calculations by ~10 times
Hardware limitations
Microcontroller is too slow to perform complex operations in time, 13.56MHz clock 
speed is not enough to perform additional functions
~400 bytes of RAM and ~7000 bytes of Flash were used for the implementation, 
leaving little room for further functionality
512 bytes of EEPROM memory were not enough to store an entire tag
Debugging complex functionality on AVR Microcontrollers is a difficult process
Limited number of pins means limited number of additional peripherals could be 
added
Some readers were still not compatible, as they require fast response times
Building a better device
A more powerful Microcontroller was selected – STM32L496ZG
1MB of Flash available, 320KB of RAM (640x more than the 
ATTiny)
Much faster clock speed, capable of performing at 72MHz
32-bit architecture could improve encryption calculations
Large number of useful peripherals, including USB and UART
Easy to program and debug using development software
Can be built using the same circuitry and logic as previous device
Building a better device
Pin configurations and clock speeds can be set in STM32Cube
Very little modification to core codebase was required – only timers and 
interrupts needed to be modified
Synchronisation issues could occur due to lack of standard clock rate
Building a better device – Synchronisation
Internal clock of the chip was not able to tune to 13.56MHz
This would not be a problem for receiving data, but would be a problem for transmitting 
responses
Use of an external crystal was not ideal, as it would increase complexity of the board
Without an accurate clock, the device would fall out of sync with the reader
The STM32 can run at a large number of frequencies, it could be possible to find a clock 
at a close enough frequency, without being perfectly in sync
Each possible frequency was assessed in order to find the most suitable candidate
Additional features – Multi-tag support
Can be implemented by having several instances of the same state machine
Handling of multiple requests can be performed by forcing anticollision, or more easily 
by cascading requests so that only one selection is performed at a time for each 
emulated tag
This can be used to exploit weaknesses related to selecting multiple tags
Not hugely useful, as readers rarely implement this functionality
Additional features – Dynamic Crypto-1 Key Generation
Some readers generate unique keys depending on the UID of the tag
If the algorithm for these can be reverse engineered, keys can be calculated as 
authentication is requested
This can allow for dynamic modification of UID values without adversely affecting 
authentication
Additional features – Implementing DESFire
Can present as DESFire by modifying SAK and ATQA 
response values
Implemented by replaying legitimate requests from readers
Protocols are robust, when a valid response can’t be provided, 
the reader will try again
Authentication functionality is well documented
The Mifare DESFire Tool Android Application can be used to 
develop and test this functionality
Security Weaknesses
Crypto-1 Weaknesses
Weaknesses in this algorithm have been known for a long time, most importantly in the 
paper “Dismantling Mifare Classic”, which outlines the most key weaknesses. 
Crypto-1 utilises 48-bit keys, split into 24-bit keys, this can be brute forced
Authentication is vulnerable to replay attacks
Nonces used to authenticate can be used to recover 32-bits of keystream from 
authentication
Rollbacks from the authentication can be performed to fully recover the initial key
Attacking Crypto-1 from the tag
Key recovery for a sector can be achieved from two authentication requests when 
emulating a tag:
Authentication is allowed to progress until the reader sends a response to the tag’s 
initial nonce
This response contains a random value followed by an encrypted value generated by 
the tag’s nonce, the generated value can be calculated and XORed with this, 
providing 32-bits of keystream
The two 24-bit keys generated from the 48-bit initial key are used to calculate each 
alternating bit of the keystream, reducing these values from ~16 million possible 
24-bit keys to ~200,000
Matching key pairs can be checked in order to find combinations which generate 
the 32-bit keystream
These keys can be rolled back through the random value and the initial nonce in 
order to recover the initial key
Attacking Crypto-1 from the tag
Attacking Crypto-1 from the tag
This approach can be used to perform offline cracking on Mifare Classic keys
Keys can be recovered in under ten minutes
This is more efficient than reader-based attacks on tags, but is impractical in a real-
world setting
This functionality is available on the Proxmark and Chameleon Mini, and is part of the 
core functionality of Crapto-1, but is not widely used to due to practicality in most 
contexts
Attacking Crypto-1 from the tag - Demonstration
A Mifare Classic reader with no known research was selected – the NFC reader used by a 
Japanese Video Game
Reader was identified to use USB for communication, which was reverse-engineered using 
the USBProxy tool and a Beaglebone Black, the protocol was found to be simplistic and 
allowed for access to tag UIDs and block data
The reader was  found to not be compatible with the Proxmark or Chameleon Mini due to 
the speed with which it required responses from tags
A tool was written which identified tags on the reader and tried to read data from it
Attacking Crypto-1 from the tag – Demonstration
UIDs, sector numbers and authentication values were generated from the STM32 device
A custom tool was written which processed these in order to recover keys
Keys were verified against the reader after being generated, showing that they could be 
recovered
A large number of different keys were generated by emulating a large number of unique 
UIDs, this allowed for identification of differences between keys, and could help with 
reverse engineering key generation algorithms
Crypto-1 - Improvements
An increased key size would significantly increase the complexity of the attack
Usage of a single, large key would prevent brute forcing of key stream values
An improved PRNG on the tag would limit replay attacks
Removing known plaintext from authentication would remove opportunity for exploitation
Raw protocol weaknesses
Most NFC chipsets don’t support control of the initial enumeration procedures, leaving 
it only accessible for testing by dedicated devices
Initial enumeration is performed by all tag types, meaning that weaknesses can be tested 
on a large number of readers  
No limits on response sizes leave readers potentially open to memory corruption 
weaknesses
The greatest weaknesses lie in the anticollision procedures
Exploiting anticollision
By constantly responding to requests with corrupted communications, the reader will 
ask for an increasing number of bits of the UID, eventually overflowing and requesting a 
size too large for the buffer
This can often cause crashes 
This feature is rarely implemented, most readers only support one card at a time
This weakness is known, but is still found in some readers
High level protocol weaknesses
Each tag type has its own weaknesses
Entire stack lends itself to fuzzing beyond enumeration, as this data can be manipulated 
by most NFC chipsets
NDEF data has the greatest potential for weaknesses, as it has a large number of data 
types and features
Authentication mechanisms often have known plaintext weaknesses
Capabilities of tag hardware mean that complex authentication and encryption is not 
possible 
Compiling research
Future work
Source will be released – RTL-SDR, AVR and STM32 tools
Boards will be designed
DESFire will be fully implemented, and each element of it will be assessed
More tag types will be researched for weaknesses
Questions
Christopher Wade
@Iskuri1
https://github.com/Iskuri
https://www.pentestpartners.com