window . l o c a t i o n=" http :// e . com / "+document . c o o k i e
There are ongoing discussions by the community on this
channel [1] with proposals for a new CSP directive allowing
to whitelist navigation destinations or, alternatively, devel-
opment of a dedicated mechanism.
window.name Closely related to page navigation is the DOM
property window.name, designed to assign names to browser
windows to ease targeting within the browser. Since the
name of a window is independent of the loaded web page, its
value persists when navigating to a new page inside the same
window. Attackers can abuse this feature as shared memory
throughout diﬀerent page contexts to exﬁltrate data [2]. For
an attack to succeed, an attacker needs to ensure that the
same window instance is navigated to an attacker-controlled
page to retrieve the exﬁltrated data.
For successfully exploiting window.name, page navigation
is required. We therefore believe that the security problem
caused by window.name can be solved through a control for
page navigation as discussed above.
Timing channels An alternative known way of leaking
data is through timing channels, i.e., via information about
when and for how long data is processed. An attacker can,
for example, infer the browser history by trying to inject
certain page content. In case of a relatively short response
time, the content was most likely recovered from cache and
was therefore fetched from the server in a diﬀerent context
before. Timing channels are subject to ongoing work by the
research community [9, 24, 14].
7.2 Mitigation of prefetching-based exﬁltration
Improving existing controls Automatic DNS prefetch-
ing can be disabled through the X-DNS-Prefetch-Control
HTTP header, but it cannot be used to disable forced DNS
prefetching in all supporting browsers. Our experiment shows
that only one browser vendor allows forced DNS prefetch-
ing to be disabled through the same HTTP header, giv-
ing web developers the option to disable this functionality
and hereby preventing that attackers abuse DNS prefetching
to exﬁltrate information. Since automatic and forced DNS
prefetching is likely related in the codebase of every support-
ing web browser, we recommend that all browser vendors
implementing DNS prefetching also adopt this functionality
and give full control over DNS prefetching to web developers.
But even if this is applied in every browser, it will not
solve the problem entirely. If all DNS prefetching could be
controlled using a single X-DNS-Prefetch-Control HTTP
header, a web developer may enable DNS prefetching, then
use  elements with the “dns-prefetch” relationship to
pre-resolve some hostnames and ﬁnally disable DNS prefetch-
ing again. The list of hostnames to be pre-resolved would
be under strict control of the web developer, not giving an
attacker the chance to exﬁltrate information.
However, this solution works only if all hostnames to be
pre-resolved, are known beforehand and if their number is
manageable. A web page with thousands of URLs, all point-
ing to diﬀerent hostnames, would require thousands of 
elements to pre-resolve them before DNS prefetching is dis-
abled by the web developer.
Luckily, the hierarchical nature of DNS allows for a more
eﬃcient solution by using a wildcard to encompass all sub-
domains of a given domain name. Using a wildcard would
allow a web developer to conﬁgure the DNS prefetching sys-
tem to only perform DNS prefetching for those trusted host-
names that match the wildcard. An attacker trying to ex-
ﬁltrate information would ﬁnd the attacker’s own domain
name disallowed by this wildcard.
Unfortunately, this mechanism cannot be implemented
with the machinery that is currently in place to restrict DNS
prefetching. A possible solution is to modify the semantics
of the X-DNS-Prefetch-Control HTTP header to accept a
list of wildcard domain names instead of “on” or “oﬀ”, e.g.
X−DNS−P r e f e t c h−C o n t r o l : ∗ . example . com
CSP oriented solutions
If CSP is understood to pre-
vent data exﬁltration, at least to the extent that it restricts
the web sources to which network requests can be made, it
stands reason that CSP should also cover resource prefetch-
ing. CSP has directives for several kinds of resources, but
the nature of the prefetched resource does not necessarily ﬁt
in any of the predeﬁned categories. Exactly in which cate-
gory prefetched resources can be placed is subject to a design
choice. In any case, it is natural for prefetched resources to
at least be under control of the “default-src” directive.
Another solution is to absorb DNS prefetching control into
CSP, just like the X-Frame-Options HTTP header which
was absorbed into the CSP speciﬁcation under the “frame-
ancestors” directive. A “dns-prefetch” CSP directive could
replace the X-DNS-Prefetch-Control HTTP header, e.g.
Content−S e c u r i t y−P o l i c y :
dns−p r e f e t c h ∗ . example . com
The advantage of this solution is that CSP is standard-
ized by W3C and supported by most browser vendors, while
the X-DNS-Prefetch-Control HTTP header is not. Stan-
dardizing DNS prefetching through CSP would beneﬁt the
42.3% of most popular web domains that already use DNS
prefetching through the “dns-prefetch”  relationship.
8. RELATED WORK
We discuss related work on CSP in general, CSP and data
exﬁltration, and on DNS prefetching in the context of CSP.
Content Security Policy The CSP standard has evolved
over the last years with CSP 3.0 [17] currently under devel-
862opment. Since recently, the document lists such goals as the
mitigation of risks of content-injection attacks and provi-
sion of a reporting mechanism. Interestingly, other features
of CSP, e.g. restricting target servers for form data submis-
sions, are not reﬂected in the goals, thereby reinforcing the
importance of being explicit about whether CSP is intended
for controlling data exﬁltration. DNS prefetching is not cov-
ered by any CSP speciﬁcation document. Our ﬁndings and
improvement suggestions aim at supporting the future de-
velopment of the CSP standard.
Johns [28] identiﬁes a cross-site scripting attack through
scripts dynamically assembled on the server-side but based
on client information. An attacker can spoof the client infor-
mation and cause the injection of a malicious script. Because
the resulting script comes from a whitelisted source, CSP al-
lows its execution. Johns proposes PreparedJS to prevent
undesired code assembling.
Heiderich et al. [25] demonstrate scriptless attacks by com-
bining seemingly harmless web browser technologies such
as CSS and SVG. Prefetching of any kind is not analyzed.
Though Heiderich et al. state that CSP is a useful tool to
limit chances for a successful attack, they assess that CSP
only provides partial protection. Some of the attacks we
cover, i.e. URL and HTML injections, fall under the cate-
gory of scriptless attacks. However, we see scriptless attacks
only as one of the several possible ways of exﬁltrating data.
Weissbacher et al. [50] empirically study the usage of CSP
and analyze the challenges for a wider CSP adoption. They
mention DNS prefetch control headers in HTTP and remark
that these allow websites to override the default behavior.
While they include the DNS prefetch control headers in the
general statistics of websites that use security-related HTTP
headers, they do not discuss the impact of these headers on
CSP and the handling of prefetching by clients. Addition-
ally to HTTP CSP headers, our empirical study also reports
on occurrences of CSP inside web pages statically or dy-
namically included through e.g. HTML  elements or
content inside iframe elements.
CSP and data exﬁltration Orthogonal to the attack
vectors discussed so far are the so called self-exﬁltration at-
tacks [13], where an attacker leaks data to origins whitelisted
in a CSP policy. A representative example is analytics scripts,
used pervasively on the Web [35], and hence often whitelisted
in CSP. The attacker can simply leak sensitive data to ana-
lytics servers, e.g. via URL encoding, and legitimately collect
it from their accounts on these servers.
Observing the proliferation of HTML elements and at-
tributes that can request external resources, Cure53 created
a webpage [19] that exhaustively tests for HTTP leaks, not-
ing its potential to test a browser for CSP leaks.
DNS prefetching Attacking DNS resolution is often paired
with a network attacker model. Johns [26] leverages DNS
rebinding attacks to request resources from unwanted ori-
gins. Although the attacks are against the same-origin pol-
icy, CSP can be bypassed in the same way. Not being a
network attacker, our attacker avoids the need to tamper
with DNS entries.
Monrose and Krishnan [33, 29] observe that DNS prefetch-
ing by web search engines populates DNS servers with en-
tries in a way that allows to infer search terms used by users.
Inspecting records on a DNS server can thus be used for a
side-channel attack. Our attacker model, however, has only
the capability to observe queries to the attacker’s own DNS
server. In addition, our attackers can directly exﬁltrate data
without the need to interpret DNS cache entries.
Born [8] shows that the bandwidth of the DNS-prefetching
channel is suﬃcient to exﬁltrate documents from the local
ﬁle system by a combination of encoding and timeout fea-
tures in JavaScript. While he demonstrates the severeness
of prefetching attacks, we widen the perspective by system-
atically analyzing a full family of attacks introduced through
prefetching in combination with CSP.
CSP vs. prefetching To date, prefetching in the context
of CSP has only received scarce attention. There are re-
ported observations on prefetching not handled by CSP [40,
11], providing examples of leaks to bypass CSP. We go be-
yond these observations by systematically studying the en-
tire class of the prefetching attacks, analyzing a variety of
browser implementations for desktop and mobile devices,
and proposing countermeasures based on the lessons learned.
9. CONCLUSION
We have put a spotlight on an unsettling vagueness about
data exﬁltration in the CSP speciﬁcation, which appears to
have led to fundamental discrepancies in interpreting its se-
curity goals. As an in-depth case study, we have investigated
DNS and resource prefetching in mainstream browsers in the
context of CSP. For most browsers, we ﬁnd that attackers
can bypass the strictest CSP by abusing DNS and resource
prefetching to exﬁltrate information. Our large-scale evalua-
tion of the Web indicates that DNS prefetching is commonly
used on the Web, on 42.3% of the 10,000 most popular web
domains according to Alexa.
We discuss general countermeasures on data exﬁltration
and consequences in the context of CSP, as well as concrete
countermeasures for the case study on DNS and resource
prefetching. The concrete countermeasures for web browsers
consist of resolving the inconsistency in DNS prefetching
handling and subjugating resource prefetching to the CSP.
Our intention is that our ﬁndings will inﬂuence the ongo-
ing discussion on the goals of CSP [17].
Responsible disclosure and related resources We are
in the process of responsibly disclosing all discovered vul-
nerabilities to the involved web browser vendors. Extra re-
sources related to this work can be found online [12].
Acknowledgments Thanks are due to Artur Janc and
Mario Heiderich for the helpful feedback. This work was
partly funded by Andrei Sabelfeld’s Google Faculty Research
Award, the European Community under the ProSecuToR
project, and the Swedish research agency VR.
10. REFERENCES
[1] Preventing page navigation to untrusted sources.
https://lists.w3.org/Archives/Public/
public-webappsec/2015Apr/0259.html.
[2] window.name can be used as an XSS attack vector .
https://bugzilla.mozilla.org/show bug.cgi?id=444222.
[3] Adam barth. CSP and inline styles.
https://lists.w3.org/Archives/Public/
public-webappsec/2012Oct/0055.html.
[4] D. Akhawe, A. Barth, P. E. Lam, J. C. Mitchell, and
D. Song. Towards a formal foundation of web security.
In CSF, 2010.
863[5] D. Akhawe, F. Li, W. He, P. Saxena, and D. Song.
Data-conﬁned HTML5 applications. In ESORICS,
2013.
[6] Ariya Hidayat. PhantomJS. http://phantomjs.org.
[7] A. Barth, C. Jackson, and J. C. Mitchell. Securing
frame communication in browsers. In USENIX
Security, 2008.
[8] K. Born. Browser-based covert data exﬁltration.
CoRR, 2010.
[9] A. Bortz and D. Boneh. Exposing private information
by timing web applications. In WWW, 2007.
[10] Brian Smith. Should CSP aﬀect a Notiﬁcation icon?
https://lists.w3.org/Archives/Public/
public-webappsec/2014Nov/0137.html.
[11] CSP does not block favicon request. https:
//bugzilla.mozilla.org/show bug.cgi?id=1167259#c3.
[12] Chalmers CSE. Related materials.
http://www.cse.chalmers.se/research/group/security/
data-exﬁltration-in-the-face-of-csp.
[13] E. Y. Chen, S. Gorbaty, A. Singhal, and C. Jackson.
Self-Exﬁltration: The Dangers of Browser-Enforced
Information Flow Control. In W2SP, 2012.
[14] S. Chen, R. Wang, X. Wang, and K. Zhang.
Side-Channel Leaks in Web Applications: A Reality
Today, a Challenge Tomorrow. In S&P, 2010.
[15] Content Security Policy 1.1.
[30] L. Meyerovich and B. Livshits. ConScript: Specifying
and enforcing ﬁne-grained security policies for
Javascript in the browser. In Proc. of SP’10, 2010.
[31] Mike West. Remove paths from CSP?
https://lists.w3.org/Archives/Public/
public-webappsec/2014Jun/0007.html.
[32] M. S. Miller, M. Samuel, B. Laurie, I. Awad, and
M. Stay. Caja - safe active content in sanitized
JavaScript. Technical report, Google Inc., June 2008.
[33] F. Monrose and S. Krishnan. DNS prefetching and its
privacy implications: When good things go bad. In
LEET, 2010.
[34] Re: dns-prefetch. http://permalink.gmane.org/gmane.
comp.mozilla.security/4109.
[35] N. Nikiforakis, L. Invernizzi, A. Kapravelos, S. Van
Acker, W. Joosen, C. Kruegel, F. Piessens, and
G. Vigna. You are what you include: large-scale
evaluation of remote JavaScript inclusions. In ACM
CCS, 2012.
[36] OWASP. OWASP Top 10.
https://www.owasp.org/index.php/Category:
OWASP Top Ten Project.
[37] Resource hints. https://w3c.github.io/resource-hints/.
[38] RFC1034: Domain names - concepts and facilities.
[39] RFC1035: Domain names - implementation and
speciﬁcation.
http://www.w3.org/TR/2014/WD-CSP11-20140211.
[40] SEC Consult: Content Security Policy (CSP) -
[16] Content Security Policy 2.0.
http://www.w3.org/TR/CSP/.
[17] Content Security Policy 3.0. http://w3c.github.io/
webappsec/specs/content-security-policy/.
[18] Controlling DNS prefetching.
https://developer.mozilla.org/en-US/docs/Web/
HTTP/Controlling DNS prefetching.
[19] Cure53. HTTPLeaks.
https://github.com/cure53/HTTPLeaks.
[20] David Veditz. [CSP2] Preventing page navigation to
untrusted sources. https://lists.w3.org/Archives/
Public/public-webappsec/2015Apr/0270.html.
[21] Deian Stefan. WebAppSec re-charter status.
https://lists.w3.org/Archives/Public/
public-webappsec/2015Feb/0130.html.
[22] DNS Prefetching - The Chromium Projects.
http://dev.chromium.org/developers/
design-documents/dns-prefetching.
[23] StatCounter Global Stats. http://gs.statcounter.com/.
[24] E. W. Felten and M. A. Schneider. Timing attacks on
Web privacy. In CCS, 2000.
[25] M. Heiderich, M. Niemietz, F. Schuster, T. Holz, and
J. Schwenk. Scriptless attacks: Stealing the pie
without touching the sill. In CCS, 2012.
[26] M. Johns. On JavaScript Malware and related threats.
Journal in Computer Virology, 2008.
[27] M. Johns. PreparedJS: Secure Script-Templates for
JavaScript. In DIMVA, 2013.
[28] M. Johns. Script-templates for the content security
policy. Journal of Information Security and
Applications, 2014.
[29] S. Krishnan and F. Monrose. An empirical study of
the performance, security and privacy implications of
domain name prefetching. In DSN, 2011.
Another example on application security and
”assumptions vs. reality”. http://blog.sec-consult.com/
2013/07/content-security-policy-csp-another.html.
[41] P. Soni, E. Budianto, and P. Saxena. The SICILIAN
defense: Signature-based whitelisting of web
JavaScript. In CCS, 2015.
[42] S. Souders. Velocity and the Bottom Line.
http://radar.oreilly.com/2009/07/
velocity-making-your-site-fast.html.
[43] S. Stamm, B. Sterne, and G. Markham. Reining in the
web with content security policy. In WWW, 2010.
[44] D. Stefan, E. Z. Yang, P. Marchenko, A. Russo,
D. Herman, B. Karp, and D. Mazi`eres. Protecting
users by conﬁning JavaScript with COWL. In
USENIX OSDI, 2014.
[45] M. Ter Louw, K. T. Ganesh, and V. Venkatakrishnan.
AdJail: Practical Enforcement of Conﬁdentiality and
Integrity Policies on Web Advertisements. In
Proceedings of the 19th USENIX Security, 2010.
[46] S. Van Acker. Isolating and Restricting Client-Side
JavaScript. PhD thesis, KU Leuven, 2015.
[47] S. Van Acker, D. Hausknecht, W. Joosen, and
A. Sabelfeld. Password meters and generators on the
web: From large-scale empirical study to getting it
right. In CODASPY, 2015.
[48] W3C. PI:EMAIL Mail Archives. https:
//lists.w3.org/Archives/Public/public-webappsec.
[49] W3C. World Wide Web Consortium.
http://www.w3.org/.
[50] M. Weissbacher, T. Lauinger, and W. K. Robertson.
Why Is CSP Failing? Trends and Challenges in CSP
Adoption. In RAID, 2014.
[51] M. Zalewski. Postcards from the post-XSS world.
http://lcamtuf.coredump.cx/postxss/.
864