.
B
A.6 Supplementary material for Section 8
Hereafter, we assume that at least one of the participants in {G}C
has a secret a in G. Since rule [C-Advertise] requires that secret names
are fresh, this ensures that the same contract can not be advertised
twice. Expressiveness is not affected by this assumption, since a
needs not be used in C. In all our examples, we implicitly assume
this condition to be respected.
(cid:16) ∥ i∈I Ai :? vi @ xi
C =(cid:80)m
G =
i =1 Di
ei = Bout (Di )
Ti = BD (Di, Di, Tinit, 0, v, PartG, 0)
(∀i ∈ 1..m)
(cid:17) | (cid:16) ∥ i∈J Bi :! v′
v =(cid:80)
⃗x =(cid:85)m
(cid:17) | (cid:16) ∥ i∈K Ci :secret ai
(cid:17)
i
i @ yi
i∈J v′
i =1 fv(ei )
(∀i ∈ 1..m)
Badv ({G }C ) = Tinit T1 · · · Tm
Tinit
in: i (cid:55)→ txout(yi )
wit: ⊥
λ⃗x .(cid:87)m
out:(cid:16)
i =1 ei, v
(∀i ∈ J )
(cid:17)
C =(cid:80)m
⃗x =(cid:85)m
i =1 Di
ei = Bout (Di )
i =1 fv(ei )
I = {z1, . . . , zk }
(∀i ∈ 1..m)
Ti = BD (Di, Di, TC , 0, v, PartG, 0)
TC
in: 0 (cid:55)→ (T, o), i (cid:55)→ txout(zi )
out:(cid:16)
wit: 0 (cid:55)→ sigK(Dp ,P ), i (cid:55)→ sigK(part(zi ))
(cid:17)
i =1 ei, v
(∀i ∈ 1..k )
(∀i ∈ 1..k )
λ⃗x .(cid:87)m
BC (C , Dp, T, o, v, I, P, t ) = TC T1 · · · Tm
(∀i ∈ 1..m)
absLock: t
D (cid:46) A1 : · · · : An : after t1 : · · · : after tk : put ⃗z & reveal ⃗a if p . C ⃗ς fresh
Bout (D ) = versigK(D ,PartG) (⃗ς )
D ≡ A1 : · · · : An : after t1 : · · · : after tk : put ⃗z & reveal ⃗a if p . C ⃗a = a1 · · · am ⃗ς, b1 · · · bm fresh
Bout (D ) = versigK(D ,PartG) (⃗ς ) ∧ B(p{b1/a1} · · · {bm/am }) ∧ (cid:86)m
, out :(cid:16)
D = withdraw A
BD (D, Dp, T, o, v, P, t ) = {in : (T, o), wit : sigK(Dp ,P )
D = put ⃗z & reveal ⃗a if p . C v′ = v +(cid:80)
x∈⃗z val(x )
BD (D, Dp, T, o, v, P, t ) = BC (C , Dp, T, o, v′, ⃗z, P, t )
i =1 H(bi ) = sechash(ai ) ∧ |bi | ≥ η
(cid:17)
⃗v = v1 · · · vk
λς . versigK(A ) (ς ), v
, absLock : t }
(cid:80)k
i =1 vi ≤ v
D = split ⃗v → ⃗C
BD (D, Dp, T, o, v, P, t ) = Bpar (⃗C , Dp, T, o, ⃗v, P, t )
BD (D, Dp, T, o, v, P, t ) = BD (D′, Dp, T, o, v, P \ {A}, t )
D = A : D′
Ci =(cid:80)ki
BD (D, Dp, T, o, v, P, t ) = BD (D′, Dp, T, o, v, P, max{t, t′})
D = after t′ : D′
TC
λ⃗xi .(cid:87)ki
j =1 ei, j, vi
(cid:17)
(∀i ∈ 1..n)
⃗C = C1 · · · Cn
⃗v = v1 · · · vn
⃗xi =(cid:85)ki
j =1 fv(ei, j )
j =1 Di, j
(∀i ∈ 1..n)
ei, j = Bout (Di, j )
(∀i ∈ 1..n)
in: (T, o)
wit: sigK(Dp ,P )
(∀i ∈ 1..n, j ∈ 1..ki )
out: i − 1 (cid:55)→(cid:16)
absLock: t
Bpar (⃗C , Dp, T, o, ⃗v, P, t ) = TC (Ti, j )i∈1. .n, j∈1. .ki
(∀i ∈ 1..n, j ∈ 1..ki )
Ti, j = BD (Di, j, Di, j, TC , i − 1, vi, PartG, 0)
B(true) = true
B(p1 ∧ p2) = B(p1) ∧ B(p2)
B(N ) = N
B(|a|) = |a| − η
B(¬p ) = ¬B(p )
B(e1 ◦ e2) = B(e1) ◦ B(e2)
B(e1 • e2) = B(e1) • B(e2)
Figure 7: Compiling contracts to Bitcoin transactions.
Tinit
in: 0 (cid:55)→ (TA , 0), 1 (cid:55)→ (TB , 0)
wit: ⊥
out: (λςAςBb.e1 ∨ e2, v )
T′
(Tinit, 0)
in:
wit: sigK(D1,{A,B})
out: (λςAςB .e′, v )
T′
A
in: (T′, 0)
wit: sigK(withdraw A,{A,B})
out: (λς . versigK(A) (ς ), v )
T′
B
in: (Tinit, 0)
wit: sigK(D2,{A,B})
out: (λς . versigK(B) (ς ), v )
absLock: t
Figure 8: Transactions obtained by compiling the timed commitment contract.
21
(2) α = A : {G}C , ∆, where: (i) for some B, ˙Rc contains B → ∗ : C,
Definition 20 (Coherence). We inductively define the relation
coher (Rs , Rc , r , txout, sechash, κ), where (i) Rs is a symbolic run,
(ii) Rc is a computational run, (iii) r is a randomness source, (iv) txout
is an injective function from names x (occurring in Rs) to trans-
action ouputs (T, o) (where T occurs in Rc), respecting values;
(v) sechash is a mapping from secret names a (occurring in Rs)
to bitstrings; (vi) κ maps triples ({G}C , D , A), where D is a subterm
of C, to public keys.
Base case: coher (Rs , Rc , r , txout, sechash, κ) holds if all the follow-
ing conditions hold: (i) Rs = Γ0 | 0, with Γ0 initial; (ii) Rc = T0 · · ·
initial; (iii) all the public keys in Rc are generated from r, accord-
ing to Definition 13; (iv) txout maps exactly the x of ⟨A, v⟩x in
Γ0 to an output in T0 of value vB, and spendable with ˆKA (rA );
(v) dom sechash = ∅; (vi) dom κ = ∅.
Inductive case: coher ( ˙Rs α−→ Γ | t, ˙Rc λc , r , txout, sechash, κ) holds
if coher ( ˙Rs , ˙Rc , r , txout′, sechash′, κ′) and one of the following cases
applies.
(1) α = advertise({G}C ), λc = A → ∗ : C, where C is obtained
by encoding {G}C as a bitstring, representing each x in it
as the transaction output txout′(x ). Further, txout′ = txout,
sechash′ = sechash, and κ′ = κ.
where C is obtained from {G}C and txout′ as in Item 1.
Note that ˙Rc might contain several such messages; below,
we let C represent the first occurrence. (ii) for some B,
λc = B → ∗ : (C, ⃗h, ⃗k ) (signed by A), where ⃗h is a sequence
with |hi| = η for each secret ai in
comprising a bitstring hi
∆, and ⃗k is a sequence of keys, as the one produced by the
stipulation protocol. We require that λc is the first occur-
rence, in the run ˙Rc, of such a message after C. (iii) Let Ni
be the length of ai fixed in ∆. If Ni (cid:44) ⊥, we require that
˙Rc contains, for some B, a query to the oracle B → O : mi,
such that |mi| = η + Ni.
and a subsequent reply O → B : hi
Otherwise, if Ni = ⊥, we require that hi
does not occur as
a reply from O to any query of length ≥ η. (iv) No hash is
reused: the hi
are pairwise distinct, and also distinct from
sechash′(b ) for any b ∈ dom (sechash′). (v) txout = txout′.
(vi) sechash extends sechash′ so that for each secret ai we
. (vii) If A ∈ Hon, we define κ by
have sechash(ai ) = hi
extending κ′ according to ⃗k, so to record the public keys
of all participants occurring in G for each subterm D of C.
If κ′ already defines such keys, or A (cid:60) Hon, we let κ = κ′.
(3) α = A : {G}C , x, where: (i) λc = B → ∗ : m for some
B, where m is the signature of the transaction Tinit of
Badv ({G}C ) relatively to the input x with ˆKA (rA ). The pa-
rameters of the compiler are set as follows: part, PartG and
val are inferred from G, we let txout = txout′, sechash = sechash′,
B (rB ), K(D , B) = κ′({G}C , D , B) for each B,
and K(B) = ˆK
and D subterm of C. (ii) For some B, we have B → ∗ : Tinit
occurring in ˙Rc. (iii) λc is the first occurrence in ˙Rc of a
broadcast of m after Tinit. (iv) txout = txout′, sechash = sechash′,
and κ = κ′.
(4) α = init (G , C ), where: (i) α consumes from ˙Rs the ad-
vertisement {G}C and its persistent deposits to produce
⟨C , v⟩z . (ii) λc = Tinit where Tinit is the first transaction
p
22
i Di,
(5) α = A : x, D, where: (i) ˙Rs contains⟨C ′, v⟩x with C ′ = D +(cid:80)
in Badv ({G}C ). The needed compiler parameters are ob-
tained as in Item 3. (iii) sechash = sechash′, κ = κ′, and
txout extends txout′, mapping z to Tinit.
for some D = A : D′. (ii) In ˙Rs, we find that ⟨C ′, v⟩x has
{G}C as its ancestor advertisement. (iii) λc = B → ∗ : m,
where m is a signature with key κ′({G}C , D , A) of the
first transaction T in BD (D , D , T′, o, v, PartG, 0), where
(T′, o) = txout′(x ). The compiler parameters are obtained
as in Item 3. (iv) txout = txout′, sechash = sechash′, and
κ = κ′. (v) ˙Rc contains B → ∗ : T for some B, and m is the
first signature of T in ˙Rc λc after the first broadcast of T.
(6) α = put (⃗x, ⃗a, y), where: (i) ⃗x = x1 · · · xk. (ii) In Γ˙Rs , the ac-
tion α consumes ⟨D + C , v⟩y and the deposits ⟨Ai , vi⟩xi
to
produce⟨C ′, v′⟩y′, where D = · · · : put· · · reveal· · ·. C ′.
Let t be maximum deadline in an after in front of D. (iii) In
˙Rs, we find that ⟨D + C , v⟩y has {G}C ′′ as its ancestor ad-
vertisement, for some G and C ′′. (iv) λc = T where T is the
first transaction of BC (C ′, D , T′, o, v′, ⃗x, PartG, t ), where
(T′, o) = txout′(y ). The compiler parameters are obtained
as in Item 3. (v) txout extends txout′ so that y′ is mapped
to (T, 0), sechash = sechash′, and κ = κ′.
(7) α = A : a, where: (i) λc = B → ∗ : m from some B with
|m| ≥ η. (ii) ˙Rc =· · · (B → O : m)(O → B : sechash′(a )) · · · ,
for some B. (iii) txout = txout′, sechash = sechash′ and
κ = κ′. (iv) In ˙Rs we find an A : {G}C , ∆ action, with a in
G, with a corresponding broadcast in ˙Rc of m′ = (C, ⃗h, ⃗k ).
(v) λc is the first broadcast of m in ˙Rc after the first broad-
cast of m′.
to obtain⟨C0, v0⟩x0 | · · · | ⟨Ck , vk⟩xk
and ⃗C = C0 . . . Ck. Let t be the maximum deadline in an
after in front of D. (ii) In ˙Rs, we find that ⟨D + C , v⟩y has
{G}C ′ as its ancestor advertisement. (iii) λc = T where T
is the first transaction of Bpar (⃗C , D , T′, o, PartG, t ) where
(T′, o) = txout′(y). The compiler parameters are obtained
as for Item 3. (iv) txout extends txout′ mapping each xi to
(T, i), sechash = sechash′, and κ = κ′.
(9) α = withdraw(A, v, y ), where: (i) In ˙Rs, the action α con-
sumes⟨D + C , v⟩y to obtain⟨A, v⟩x , where D = · · · : withdraw A.
(ii) In ˙Rs, we find that ⟨D + C , v⟩y has {G}C ′ as its ancestor
advertisement. (iii) λc = T where T is the first transaction of
BD (D , D , T′, o, v, PartG, 0) where (T′, o) = txout′(y). The
compiler parameters are obtained as for Item 3. (iv) txout
extends txout′ mapping x to (T, 0), sechash = sechash′,
and κ = κ′.
(10) α = A : x, x′, where: (i) In ˙Rs we find ⟨A, v⟩x and ⟨A, v′⟩x′.
(ii) In ˙Rc we find B → ∗ : T for some B, T, where T has as its
two inputs txout′(x ) and txout′(x′), and a single output of
value v +v′ redeemable with ˆKA (rA ). (iii) λc = B → ∗ : m′
for some B, m′, where m′ is the signature of T with ˆKA (rA ).
(iv) λc is the first broadcast of m′ in ˙Rc after the first broad-
cast of T. (v) txout = txout′, sechash = sechash′, and
κ = κ′.
(8) α = split (y), where: (i) In ˙Rs, the action α consumes⟨D + C , v⟩y
where D = · · · : split ⃗v → ⃗C
(11) α = join(x, y), where: (i) In ˙Rs the action α spends ⟨A, v⟩x
and ⟨A, v′⟩x′ to obtain ⟨A, v + v′⟩y. (ii) λc = T is a trans-
action having as inputs txout′(x ) and txout′(x′), and hav-
ing one output of value v + v′ redeemable with ˆKA (rA ).
(iii) txout extends txout′ mapping y to (T, 0), sechash = sechash′,
and κ = κ′.
(12) α = A : x, v, v′. Similar to Item 10.
(13) α = divide(x, v, v′). Similar to Item 11.
(14) α = A : x, B. Similar to Item 10.
(15) α = donate(x, B). Similar to Item 11.
(16) α = A : ⃗y, j, where: (i) ⃗y = y1 · · · yk. (ii) In ˙Rs we find
⟨Bi , vi⟩yi
for i ∈ 1..k, with Bj = A. (iii) In ˙Rc we find
B → ∗ : T for some B, T, where T has as its inputs
txout′(yi ) for i ∈ 1..k, and possibly others not in ran txout′.
(iv) λc = B → ∗ : m from some B, m where m is a signa-
ture of T with ˆKA (rA ), corresponding to the j-th input.
(v) λc is the first broadcast of m in ˙Rc after the first broad-
cast of T. (vi) λc does not correspond to any of the other
cases, i.e. there is no other symbolic action α for which
˙Rs α would be coherent with ˙Rc λc. (vii) txout = txout′,
sechash = sechash′, and κ = κ′.
(17) α = destroy(⃗x ), where: (i) ⃗x = x1 · · · xk. (ii) In ˙Rs, α con-
sumes ⟨Ai , vi⟩xi
to obtain 0. (iii) λc = T from some T hav-
ing as inputs txout′(x1), . . . , txout′(xk ), and possibly oth-
ers not in ran txout′. (iv) λc does not correspond to any of
the other cases, i.e. there is no other symbolic action α for
which ˙Rs α would be coherent with ˙Rc λc. (v) txout = txout′,
sechash = sechash′, and κ = κ′.
(18) α = δ = λc, and txout = txout′, sechash = sechash′, and
κ = κ′.
Inductive case 2: the predicate coher (Rs , Rc λc , r , txout, sechash, κ)
holds if coher (Rs , Rc , r , txout, sechash, κ), and one of the following
cases applies:
(1) λc = T where no input of T belongs to ran txout.
(2) λc = A → O : m or λc = O → A : m, for some A, m.