III. THREAT MODEL & ASSUMPTIONS
In this work, we consider malicious API-level attacks and
accidental app misconﬁgurations in appiﬁed IoT platforms
such as smart home platforms. An API-level attacker is able
to access or manipulate the state of the smart home through
creation and transition of well-formed API control messages.
There are several plausible scenarios through which this capa-
bility could be obtained:
(cid:15) Malicious Apps: An attacker can trick victims into in-
stalling a malicious 3rd party app by offering to provide
some useful automation functionality [44], [54].
(cid:15) Device Vulnerability: An attacker may gain remote
access to a device through accessing an inadequately
protected management interface [1], [61].
2Available at https://developer.apple.com/reference/homekit/hmservice
SmartThings AppGroovy SandboxSmartAppGroovy SandboxDeviceHandlerSmartThings APIDevice 1Device 2EventsCommandsSmartThings Cloud BackendHub Motion Detected EventFunctionName:senseWasGeneratedByMotion SensorWasAssociatedWithApple Home AppFunctionName:onKitchen LightWasAssociatedWithFunctionName:eventHandlerWasInformedByUsedWasAssociatedWithTABLE II: We introduce the following model for representing the provenance of IoT. Each common concept in IoT platforms is mapped to
the PROV model and has a subtype property for ﬁner categorization.
Description
An application in a IoT platform. For example, an IoT app or a mobile app.
A smart device in a platform.
The security-critical APIs provided a platform, such as making a HTTP request.
A action supported by a device. For example, a switch has on and off commands.
The states of a device. For example, a lock is locked or unlocked.
An object that represents a state change on a device.
Messages received at or sent from a device.
A non-device event. For example, a location event or a timer event.
Data that goes into a platform, such as user inputs, HTTP requests or responses.
Concept
App
Device
Action
Device Command
Device State
Device Event
Device Message
External Event
Input
(cid:15) Proximity: An unmonitored adversary within the home
can covertly make use of device interfaces that implicitly
trust
issuing an unauthorized voice
command [49].
local users, e.g.,
PROV Model
Agent
Agent
Activity
Activity
Entity
Entity
Entity
Entity
Entity
Subtype
APP IOT, APP MOBILE, ..
DEVICE
ACTION
DEVICE CMD
DEVICE STATE
EVENT DEVICE
DEVICE MSG
EVENT LOC, EVENT TIMER,..
INPUT USER, INPUT HTTP, ..
What our work does not consider is an attacker that can
obtain root access to devices (e.g., Mirai attack [10]), but
instead assumes device integrity. The assumption of device
integrity has been used consistently in closely-related prior
work [44], [45], [54]. Our goal is to provide a holistic expla-
nation of system behaviors by generating data provenance of
API control messages (e.g., unlocking the door). Thus, attacks
that bypass platform APIs, such as through compromising
communication protocols [6], are out of scope. We adopt this
assumption in order to ensure that we arrive at a practical and
immediately deployable solution; reliably tracking information
ﬂow on compromised devices would necessitate a complete
redesign of device architectures (e.g., trusted hardware).
Similarly, in this work, we assume the entity responsible
for executing the IoT’s central management logic is not com-
promised. In the case of Samsung SmartThings, this means that
our approach trusts the Samsung cloud. In alternate hub-centric
platforms, our solution would trust the local hub. Securing the
platform by reducing its attack surface is orthogonal to our
research (e.g., [34]). Particularly in the case of cloud-centric
platforms, and in light of the adversary’s capabilities, we argue
that this integrity assumption is reasonable due an array of
security precautions (e.g., best practices, app analysis) that can
be taken by the cloud administrator.
IV. PROVTHINGS
To serve as a general framework for the development of
provenance-aware IoT platforms, a system needs to satisfy a
key collection of requirements:
(cid:15) Completeness. It must produce complete explanations as
to all causal event chains and data state changes that occur
within the IoT deployment.
(cid:15) Applicability. The framework must be general enough to
(cid:15) Minimality. The framework must be minimally invasive
be applicable to many IoT platforms.
in order to facilitate deployment on existing systems.
To satisfy completeness, a system should be able to answer
questions such as “How was the data generated by my sleep
sensor used?” and “What triggered my front door to unlock?”,
while also making it possible to reconstruct and detect attacks
and diagnose misconﬁgurations. To satisfy applicability, the
framework should be adaptable with modest changes to the
4
Fig. 4: The architecture of the ProvThings provenance management
framework.
broad variety of IoT platforms listed in Table I. To achieve
minimality, it should require few or no changes to the se-
mantics of the IoT platform, or to the platform itself, and thus
continue to behave typically except when interacting with other
provenance-aware components. We thus rule out approaches
involving device instrumentation due to the great heterogeneity
of developers or manufacturers involved in the provisioning of
even a modest smart home deployment.
IoT Provenance Model. Our approach to addressing these
requirements in ProvThings is to identify the common concepts
present in different IoT platforms from xII and deﬁne a uniﬁed
IoT provenance model based on the W3C PROV-DM [2]. With
this model, we are able to utilize provenance metadata in a
platform-independent way; a uniﬁed model enables the same
terminology for provenance to be used on different platforms,
uniﬁcation of causal relations across multiple platforms, and
the speciﬁcation of platform-agnostic general policies. Our
general model is shown in Table II. We map each concept
to the PROV model and use a subtype property to further
categorize concepts. For example, a smart device generates
device messages (entities) and executes device commands
(activities). We map it to an Agent and use the DEVICE
subtype to distinguish it from other types of agents. For
convenience, we add an agentid property to each entity and
activity that points to the identities of their agents.
A key insight enabled by IoT platform designs is that we
can deﬁne provenance in terms of sources and sinks. A
source is a security sensitive data object like the state of
a door lock. A sink is a security sensitive method like the
command to unlock a door. Sources and sinks can be easily
identiﬁed from platform developer API documentations such
as [24]. By default, we consider device state, device event,
ProvenanceRecorderDatabaseProvenance FlowInstrumentedQueryPolicyPolicy MonitorProv.CollectorProv.CollectorProvThingsFrontendsConﬁgPolicy EngineQuery APIdevice message and input as sources. And we consider device
command and action as sinks. In xVI, we argue that by tracking
provenance in terms of sources and sinks is enough to satisfy
the completeness requirement.
Provenance Management Framework. We show an overview
of the ProvThings framework in Figure 4. We use a modular
design to decouple the capture, management and analysis of
provenance metadata on IoT platforms. ProvThings uses a
set of provenance collectors to collect provenance records
from different components in an IoT platform. A provenance
recorder merges records collected from different sources, and
converts them into our IoT provenance model. It then builds
provenance graphs and stores them into database. The pol-
icy monitor uses user-deﬁned policies to analyze provenance
graphs and take actions. The frontends provide interfaces to
interact with other components in the framework. By con-
verting provenance records into our IoT provenance model,
we aim to make most of the framework agnostic to different
IoT platforms to address applicability. In the architecture,
only the provenance collectors are platform-speciﬁc. To apply
ProvThings on a different IoT platform, we only need to
implement provenance collectors for the target IoT platform.
We next describe each of these components in more detail.
Provenance Collectors are monitoring mechanisms resid-
ing within different IoT components that are responsible for
generating provenance records in response to low-level system
events (e.g., API calls). For example, a provenance collector
for an IoT app could track the data used by the app and
the commands the app issued to devices. However, a single
collector is inadequate to observe interactions between dif-
ferent components. To satisfy the completeness requirement,
we therefore distribute provenance collectors across different
components in order to gain a complete picture of system
events. In this work, we consider IoT apps and device APIs
(proxies for devices), which are two key components in IoT
platforms. In support of minimality, our implementation makes
use of program instrumentation mechanisms to implement
provenance collectors. These collectors track data ﬂow and
method invocations in order to generate provenance meta-
data. Provenance collectors are platform speciﬁc as different
platforms use different programming languages and have dif-
ferent signatures of APIs. We show our implementation of
provenance collectors for SmartThings in xV and discuss the
implementations for two other platforms in xVIII. We envision
community-built and vetted provenance collectors for different
platforms to integrate into our framework.
The Provenance Recorder aggregates and merges prove-
nance records from different collectors, ﬁlters them, and con-
verts them into the IoT provenance model. The recorder then
builds and stores the resulting provenance graphs, offering
modular support for different storage backends such as SQL
and Neo4j [21]. The provenance recorder provides a server
interface to access provenance graphs, and notiﬁes the policy
monitor every time a target entity or activity is updated.
The Policy Monitor is responsible for performing active
enforcement based on the provenance of system events. The
monitor takes as input policies describing sequences of causal
interactions between system components,
then performs a
speciﬁed action (e.g., whitelist/blacklist) when an artifact’s
provenance is matched to the policy. ProvThings provides an
expressive policy language allowing for the description of such
sequences of events and further deﬁne what action should be
taken when the sequence is detected. At runtime, ProvThings
checks the provenance graph against the set of active policies.
We discuss the policy language in greater depth below.
ProvThings Frontends provide an interface for users to
interact with the above components of the ProvThings frame-
work. They allow users to create conﬁgurations, deﬁne poli-
cies, and make queries with the query API. Our implemen-
tation provides multiple frontends for users of different skill
levels, which are explained in greater detail in xVII. These
frontends make use of the following components, presenting
various levels of abstraction depending on the use case. A
conﬁguration interface allows users to decide what provenance
records they want to collect, how to process the collected
records and where to store them. For example, users could
deﬁne sources and sinks based on their needs instead of using
the default ones. A query API provides a low-level interface
through which to conduct causal and impact analysis. Finally, a
policy engine is responsible for developing and storing policies
for use with the backend Policy Monitor.
The main functions of ProvThings query API are:
FindNodes ﬁnds all
the provenance nodes that match an
expression; FindAncestors and FindSuccesssors return
the ancestors or successors of a speciﬁc type for a given
node; BackwardQuery and ForwardQuery return a partial
provenance graph describing either a target node’s ancestry
or propagation within the system. The backward dependency
query, which traces back in time to ﬁnd causal dependencies
among system activities, could be used to investigate why a
sensitive command of a device was executed. The forward
dependency query, which traces forward in time, is useful to
investigate information leak. For example, how the pincode of
a smart lock set by the user was leaked.
Instrumentation-based Provenance Collection. To satisfy
minimality, we design ProvThings to be backward compatible
using instrumentation-based provenance collection, which can
be directly adopted by existing IoT platforms. At a high level,
we instrument code to a program to track data assignments
and method invocations to capture data provenance such as
data creations and derivations. We now describe our method
for instrumenting IoT component source code to embed Prove-
nance Collectors using static analysis. As a starting point,
our approach is to generate an Abstract Syntax Tree (AST)
and a call graph from the source code, then perform control
ﬂow analysis and data ﬂow analysis over the AST in order
to identify all relationships between all data objects. The
data ﬂow analysis considers aliasing and object properties
to precisely track data dependencies. We then instrument the
code with new instructions that emit provenance records as
instructions are executed. While this simple approach would be
adequate to assure completeness, tracking all control and data
ﬂow transition would require a provenance event for almost
every instruction in the program, violating minimality, and
moreover would produce provenance records that would be
far too dense to interpret.
In order to overcome this obstacle, what
is needed is
a means of logging provenance only for those instructions
which are necessary for attack reconstruction and detection.
Our solution is to use the API of the IoT platform as a guide
5
Algorithm 1: The Selective Code Instrumentation Algo-
rithm.
Inputs : ast   Abstract Syntax Tree of a Program;
entries   Program Entry Points;
sources   Source Set;
sinks   Sink Set;
Output: instAst   Instrumented ast
1 foreach method 2 ast:methodNodes do
2
if not ISREACHABLEFROMENTRY (method, entries) then
continue
if not method.name 2 sinks then continue
if method.name 2 entries then
ADDINSTRUMENT(method)
/* Insert code to create an
Activity and create Used relations with arguments.
*/
foreach branch 2 method.branches do
foreach stm 2 branch.statements do
if stm is MethodCall and stm.name 2 sinks then
/* Insert code to
ADDINSTRUMENT(method)
3
4
5
6
7
8
9
10
11
12
13
14
15
create Activity, Used relation, and
WasInformedBy relation with the top method in
call stack
*/
varsU sed   all variables in stm.arguments
sourceV ars   varsU sed \ sources
if sourceV ars 6= ; then
slice   BACKWARDSLICE(stm,
sourceV ars)
foreach stm2 2 slice do
ADDINSTRUMENT(stm2)
/* Insert
code to create Entities and
WasDerivedFrom relations
*/
to identify sources and sinks which are security sensitive. We
perform intra-procedural control-ﬂow and data-ﬂow analysis
in order to identify sinks invocations, data dependencies and
return values of each method. A method that invokes a sink
will also be labeled as sink and a data object that derives from
a source will also be labeled as source. Then, we conduct
iterative inter-procedural analysis to compute a ﬁx point of
sources and sinks. After that, we perform selective code
instrumentation with the identiﬁed sources, sinks and program
entry points to insert provenance collection instructions as
shown in Algorithm 1. For each method in the program, we
ﬁrst check if this method is a sink and if it can be reached from
any entry point. If not, we can ignore this method as it will not
affect the sensitive behavior of the program. If this method is a
program entry point, we instrument code to track this method
invocation (Line 5). Then for each branch of this method, we
iterate over each statement to look for sink invocations. If a
sink invocation is encountered, we instrument code to track this
sink execution (Line 9). If this sink uses variables whose value
is derived from sources (Line 10-12), we compute a backward
slice [78] from the sink invocation statement with the variables
as slicing criteria (Line 13). The backward slice is a subset of
code in the branch that affects the source variables used by
the sink. We instrument code for each statement in the slice
to track the provenance of source data.
The statically instrumented code supports runtime logic
that creates entities, activities and agents, tracks the relation
between them, and sends them to ProvThings’s provenance
recorder. There are four key aspects of this runtime function:
(1) Each method execution is represented as an activity. A
WasInformedBy relation is created from the callee function
to the calling function. (2) Each method invocation has a Used
relation with its argument whose value is derived from some
6
source. The return value of a method has a WasGeneratedBy
relation to the method. (3) Each data dependency is represented
as a WasDerivedFrom relation between entities. We assign
each source entity a taint label and maintains a taint map
that propagates dependencies between entities. These taint
labels make it possible to quickly query relations between
entities and make it easier to deﬁne information ﬂow policies
(e.g., Figure 13). (4) To help capture data dependencies that
are not directly propagated by assignments, we track implicit
ﬂows (e.g., conditional statements) using an Implicit-Used
relation.
pattern:{
check:
action: notify | allow | deny
exist | not exist
}
Fig. 5: Format description for IoT Provenance Policy.
IoT Provenance Policy Speciﬁcation. We now describe the
policy language of ProvThings. As the provenance of a system
behavior is a graph, it is natural to use graph patterns to
describe the behavior. The format of a policy is shown in
Figure 5. In a policy, the pattern ﬁeld deﬁnes the graph
pattern of a target behavior;
the check condition deﬁnes