Handling dropped packets. When capturing network trafﬁc,
packet drops cannot always be avoided. They can be caused by
a high trafﬁc volume, kernel scheduling issues, or artifacts of
the monitoring environment. Such drops lead to content gaps in
application-level data processed by protocol parsers. Facing con-
tent gaps, parsers not only are unable to extract data for the cur-
rent message, but also may not even know where the next message
starts.
A particular, very common case of a content gap is one located
inside a byte sequence of known length. For example, within an
HTTP entity body, a content gap can be handled without creating
uncertainty for subsequent protocol elements. If a byte sequence is
deﬁned as &chunked in a binpac speciﬁcation—and thus only
passed to a potential &processchunk function, but not further
referenced by other expressions—then the generated parser can
simply skip over such a gap. (If &processchunk is deﬁned for
the sequence, the function is called with a specially marked “gap
chunk” so it can take note of the fact.) This mechanism allows us
to handle most content gaps for protocols in which the majority of
data is contained in long byte sequences. Hand-written protocol
parsers in Bro handle content gaps in a similar way, but on an indi-
vidual basis; the chunked byte string abstraction in binpac allows
them to be handled universally for all protocols.
In general, it is trickier to handle content gaps which do not fully
fall into a byte sequence of known size. We discuss these below in
Section 5.2.2.
Run-time type safety. The only access to parsing results provided
to binpac parsers is via typed interfaces. These leaves two as-
pects of type safety to enforce at run-time: (1) among multiple
case ﬁelds in a case type, the generated code ensures that only the
case that is selected during parsing can be accessed, otherwise it
throws a run-time exception; (2) access to array elements is always
boundary-checked. On the other hand, note that binpac cannot
guarantee complete safety, as it allows arbitrary embedded C++
code which it cannot control.
User-deﬁned error detection A user may also deﬁne protocol-
speciﬁcation error checking, using the &check attribute. For
example, one may check the data against some protocol signa-
ture (e.g., the ﬁrst 4 bytes of a CIFS/SMB message should be
“\xffSMB”) to make sure the trafﬁc data indeed reﬂects the pro-
tocol.
5.2.2 Error Recovery
Currently errors are handled in a simple model: when the ﬂow
processing function catches an exception, it logs the error, discards
the unﬁnished message as well as the unprocessed data, and initial-
izes to resume on the next chunk of data.
One potential problem with this approach is that, for stream-
based protocols, the next message might not be aligned with the
next payload chunk.
In the future we plan to add support for
re-discovering message boundaries in such cases. Having such a
mechanism will also help to further improve parsing performance,
as we can then skip large, semantically uninteresting messages, and
re-align with the input stream afterwards.
6. EXPERIENCES
We have used binpac to add protocol parsers for CIFS/SMB,
DCE/RPC (including its end-point mapping protocol) and NCP to
Bro’s trafﬁc analysis engine.5 To compare binpac with hand-
5Given the complexity of CIFS, the parser does not yet cover the entire
protocol, but only the commonly seen message types.
Protocol
HTTP
DNS
Hand-written
binpac
LOC CPU Time (seconds)
1,896
1,425
538–541
37.3–37.5
Throughput
244 Mbps / 36.7 Kpps
18.6 Mbps / 13.3 Kpps
LOC CPU Time (seconds)
676
698
442–444
44.7–44.8
Throughput
298 Mbps / 44.7 Kpps
15.6 Mbps / 11.1 Kpps
Table 2: Performance.
written protocol parsers, we also rewrote the parsers for HTTP
and DNS (and SUN/RPC, which we have not yet evaluated) in
binpac. We use these latter to provide a comparison in terms
of code size and performance between binpac-based and hand-
written parsers.
As Table 2 shows, the binpac-based parsers for HTTP and
DNS have code sizes of roughly 35–50% that of the hand-written
parsers, measured in lines of code (and the same holds in source ﬁle
sizes), respectively. We also note that for both protocols, the Bro-
speciﬁc semantic analysis comprises well over half of the binpac
speciﬁcation, so for purposes of reuse, the speciﬁcations are signif-
icantly smaller than shown.
To test the performance of the parsers, we collected a one-hour
trace of HTTP and DNS trafﬁc at Lawrence Berkeley National Lab-
oratory’s network gateway. The HTTP subset of the trace spans
19.8M packets and 16.5 GB of data. The DNS subset spans 498K
packets and 87 MB. The drop rate reported by tcpdump when
recording the trace was below 4/106.
Table 2 shows the CPU time required for each type of analysis,
giving the minimum and maximum times measured across 5 runs,
using a 3.4 GHz Xeon system running FreeBSD 4.10 with 2 GB of
system RAM. We also show the throughput in bits/sec and pack-
ets/sec, observing that on a per-packet basis, DNS analysis is much
more expensive than HTTP analysis, since many HTTP packets are
simply entity data transfers requiring little work.
For these numbers, we disabled Bro’s script-level analysis of
the protocols, so the timings reﬂect the computation necessary for
the parser to generate the Bro events corresponding to the applica-
tion activity (including TCP/IP processing and TCP ﬂow reassem-
bly), but no further processing of those events. Speciﬁcally, the
HTTP parser generates an event for (1) every request line (with
the method, the URL, and the HTTP version as event parameters),
(2) every response line (with the response number and the reason
phrase), (3) every HTTP header (with the name and the value, in
either request or response), and (4) the end of every request/reply
message (with the length of the body). The DNS parser generates
an event for every request and reply and for every answer in the re-
ply. Thus, the generated events allow almost all essential analysis
on HTTP and DNS, except that HTTP data bodies are not exported
through events.
We see that the binpac HTTP parser performs signiﬁcantly
This gain came after tun-
better than the hand-written one.
ing the speciﬁcation by adding a &transient attribute to
HTTP header ﬁelds, which instructs binpac to not create a
copy of the corresponding bytestring. (Transient strings are visi-
ble only within the parsing function of the type, while non-transient
ones, which are copied, can be accessed after parsing.) We have not
yet applied the same tuning to the DNS speciﬁcation; as a result, it
allocates many more dynamic objects, and copies more strings than
the hand-written one does. We do, however, believe that tuning it
will prove straightforward.
Both the hand-written and the binpac HTTP parsers handle
content gaps by skipping over gaps within data bodies, which are
common in large traces. However, it is worth noting that in the
hand-written case, content-gap skipping must be crafted in each
case and thus is applied in very limited scope beyond HTTP bod-
ies (such as SMTP mail bodies). For binpac-based parsers, gap
skipping is automatically handled for every string type with a
&chunked attribute.
We also note that in developing our DNS parser we found two
signiﬁcant bugs in the hand-written parser’s processing. These re-
lated to using incorrect ﬁeld widths and non-portable byte-ordering
manipulations, and provide direct examples of the beneﬁt in terms
of correctness for specifying analyzers in a high-level, declarative
fashion.
7. SUMMARY AND FUTURE
DIRECTIONS
This paper presents binpac, a declarative language for generat-
ing parsers of application-layer network protocols from high-level
speciﬁcations. Such parsers are a crucial component of many net-
work analysis tools, yet coding them manually is a tedious, time-
consuming, and error-prone task, as demonstrated by the numerous
severe vulnerabilities found in such programs in the past.
binpac reﬂects a different paradigm for building protocol
parsers: abstracting their syntax into a high-level meta-grammar,
along with associated semantics. A parser generator then translates
the speciﬁcation into low-level code automatically. By providing
such an abstraction, a programmer can concentrate on high-level
protocol aspects, while at the same time achieve correctness, ro-
bustness, efﬁciency and reusability of the code.
In spirit, this approach is similar to that embodied in the use of
yacc for writing parsers for programming languages, but many
elements of the network analysis problem domain require signif-
icantly different underlying mechanisms. First, there are critical
differences between the syntax and grammar of network protocols
and context-free languages. In addition, processing network trafﬁc
requires a fundamentally different approach in terms of handling
input, namely the ability to incrementally parse many concurrent
input streams.
Our domain-speciﬁc binpac language addresses these issues
with a set of network-speciﬁc features: parameterized types, vari-
able byte ordering, automatic generation of boundary checking, and
a hybrid approach of buffering and incremental parsing for han-
dling concurrent input. binpac supports both binary and ASCII
protocols, and we have already used it to build parsers for HTTP,
DNS, SUN/RPC, RPC portmapper, CIFS, DCE/RPC (including the
endpoint mapper), and NCP. We integrated all of these into the
Bro NIDS, replacing some of its already existing, manually writ-
ten ones. Our evaluation shows that binpac speciﬁcations are
35–50% the size of handcoded ones, with the protocol descrip-
tion (independent of the user’s analysis semantics) comprising less
than half of the speciﬁcation. Our HTTP parser runs faster than the
handcrafted one it replaces (and with equal memory consumption),
and we are conﬁdent that the DNS will likewise soon exhibit per-
formance equal to the one it replaces. binpac is open-source and
now ships as part of the Bro distribution.
In the future, along with specifying further protocols in binpac,
we envision exploiting its power in two areas. First, we wish to
explore the reusability of binpac-generated parsers by integrating
them into additional network tools. Second, we intend to add back-
ends other than C++ to binpac to generate parsers for different
execution models. As proposed in [32], we speciﬁcally aim to build
highly parallel parsers in custom hardware.
[16] K. Fisher, Y. Mandelbaum, and D. Walker. The next 700 data
description languages. In Proceedings of the 24th ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages (POPL), pages 2–15, New York,
NY, USA, 2006. ACM Press.
8. ACKNOWLEDGMENTS
This work was supported in part by NSF Awards CNS-0520053,
STI-0334088, ITR/ANI-0205519, and NSF-0433702, as well as
a fellowship within the Postdoc-Programme of the German Aca-
demic Exchange Service (DAAD). Our thanks to John Dunagan
and the anonymous reviewers for numerous valuable comments.
9. REFERENCES
[1] M. B. Abbott and L. L. Peterson. A language-based approach
to protocol implementation. IEEE/ACM Transactions on
Networking, 1(1):4–19, 1993.
[2] M. Arlitt, B. Krishnamurthy, and J. C. Mogul. Predicting
short-transfer latency from TCP arcana: A trace-based
validation. In Proceedings of the Internet Measurement
Conference (IMC), October 2005.
[3] Abstract Syntax Notation One (ASN.1). ISO/IEC
8824-1:2002.
[4] G. Back. Datascript—a speciﬁcation and scripting language
for binary data. In GPCE ’02: The ACM
SIGPLAN/SIGSOFT Conference on Generative
Programming and Component Engineering, pages 66–77,
London, UK, 2002. Springer-Verlag.
[5] E. Biagioni, R. Harper, and P. Lee. A network protocol stack
in Standard ML. Higher-Order and Symbolic Computation,
14(4):309–356, 2001.
[6] T. P. Blumer and J. C. Burruss. Generating a service
speciﬁcation of a connection management protocol. In PSTV,
pages 161–170, 1982.
[7] N. Borisov, D. J. Brumley, H. J. Wang, J. Dunagan, P. Joshi,
and C. Guo. Generic application-level protocol analyzer and
its language. Under submission.
[8] Common Internet File System. http://www.snia.org/
tech activities/CIFS/CIFS-TR-1p00 FINAL.pdf.
[9] D. Crocker. RFC 2234: Augmented BNF for Syntax
Speciﬁcations: ABNF.
[10] DCE 1.1: Remote procedure call.
http://www.opengroup.org/onlinepubs/9629399/toc.htm.
[11] DSniff. www.monkey.org/ dugsong/dsniff.
[12] The Ethereal Network Analyzer. http://www.ethereal.com/.
[13] A. Feldmann, N. Kammenhuber, O. Maennel, B. Maggs,
R. D. Prisco, and R. Sundaram. A Methodology for
Estimating Interdomain Web Trafﬁc Demand. In
Proceedings of the Internet Measurement Conference (IMC),
October 2004.
[14] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter,
P. Leach, and T. Berners-Lee. RFC 2616: Hypertext Transfer
Protocol – HTTP/1.1, June 1999.
[15] K. Fisher and R. Gruber. PADS: A domain-speciﬁc language
for processing ad hoc data. In Proceedings of the ACM
SIGPLAN Conference on Programming Language Design
and Implementation (PLDI), pages 295–304, New York, NY,
USA, 2005. ACM Press.
[17] M. Handley, C. Kreibich, and V. Paxson. Network Intrusion
Detection: Evasion, Trafﬁc Normalization, and End-to-End
Protocol Semantics. In Proceedings of USENIX Security
Symposium, 2001.
[18] G. J. Holzmann. The model checker SPIN. IEEE Trans.
Softw. Eng., 23(5):279–295, 1997.
[19] V. Jacobson, C. Leres, and S. McCanne. TCPDUMP.
ftp://ftp.ee.lbl.gov/libpcap.tar.Z.
[20] S. C. Johnson. YACC - Yet Another Compiler-Compiler.
Computer Science Technical Report No. 32, Bell
Laboratories, Murray Hill, New Jersey, July 1975.
[21] J. Jung and E. Sit. An Empirical Study of Spam Trafﬁc and
the Use of DNS Black Lists. In Proceedings of the Internet
Measurement Conference (IMC), Taormina, Italy, October
2004.
[22] E. Kohler, M. F. Kaashoek, and D. R. Montgomery. A
readable TCP in the Prolac protocol language. In
Proceedings of the ACM SIGCOMM Conference, pages
3–13, Cambridge, MA, August 1999.
[23] C. Kreibich. NetDude (NETwork DUmp data Displayer and
Editor). http://netdude.sourceforge.net/.
[24] C. Kreibich. Design and implementation of netdude, a
framework for packet trace manipulation. June 2004.
[25] A. Kumar, V. Paxson, and N. Weaver. Exploiting Underlying
Structure for Detailed Reconstruction of an Internet-scale
Event. In Proceedings of the Internet Measurement
Conference (IMC), October 2005.
[26] P. J. McCann and S. Chandra. Packet Types: Abstract
speciﬁcations of network protocol messages. In Proceedings
of the ACM SIGCOMM Conference, pages 321–333, 2000.
[27] P. Mockapetris. DOMAIN NAMES - IMPLEMENTATION
AND SPECIFICATION, Section 4.1.4, November 1987.
RFC 1035.
[28] NFR Security. http://www.nfr.com.
[29] R. Pang, V. Yegneswaran, P. Barford, V. Paxson, and
L. Peterson. Characteristics of Internet Background
Radiation. In Proceedings of the Internet Measurement
Conference (IMC), October 2004.
[30] T. Parr and R. Quong. ANTLR: A predicated-ll (k) parser
generator. Software, Practice and Experience, 25, July 1995.
[31] V. Paxson. BRO: A system for detecting network intruders in
real time. In Proceedings of USENIX Security Symposium,
San Antonio, TX, January 1998.
[32] V. Paxson, K. Asanovic, S. Dharmapurikar, J. Lockwood,
R. Pang, R. Sommer, and N. Weaver. Rethinking hardware
support for network analysis and intrusion prevention. In
Proceedings of Workshop on Hot Topics in Security
(HotSec), Vancouver, B.C., Canada, July 2006.
[33] NetWare Core Protocol.
http://forge.novell.com/modules/xfmod/project/?ncp.
[34] T. H. Ptacek and T. N. Newsham. Insertion, Evasion, and
Denial of Service: Eluding Network Intrusion Detection.
Technical report, Secure Networks, Inc., January 1998.
[35] M. Roesch. SNORT: Lightweight intrusion detection for
networks. In Proceedings of USENIX LISA, 1999.
[36] The SNORT network intrusion detection system.
http://www.snort.org.
[37] S. Saroiu, K. P. Gummadi, R. J. Dunn, S. D. Gribble, and
H. M. Levy. An analysis of internet content delivery systems.
In Proceedings of the Fifth Symposium on Operating Systems
Design and Implementation (OSDI), December 2002.
[38] C. Shannon and D. Moore. The Spread of the Witty Worm.
http://www.caida.org/analysis/security/witty, 2004.
[39] R. Srinivasan. RFC 1831: RPC: Remote Procedure Call
Protocol Speciﬁcation.
[40] R. Srinivasan. RFC 1832: XDR: External Data
Representation Standard.
[41] Ethereal OSPF Protocol Dissector Buffer Overﬂow
Vulnerability. http://www.idefense.com/intelligence/
vulnerabilities/display.php?id=349.
[42] Snort TCP Stream Reassembly Integer Overﬂow Exploit.
http://www.securiteam.com/exploits/5BP0O209PS.html.
[43] Symantec Multiple Firewall NBNS Response Processing
Stack Overﬂow. http://www.eeye.com/html/research/
advisories/AD20040512A.html.
[44] tcpdump ISAKMP packet delete payload buffer overﬂow.
http://xforce.iss.net/xforce/xfdb/15680.
[45] Separation of concerns. http://en.wikipedia.org/wiki/
Separation of concerns.
[46] C. Wong, S. Bielski, J. M. McCune, and C. Wang. A study of
mass-mailing worms. In Proceedings of the 2005 ACM
Workshop on Rapid Malcode (WORM), pages 1–10, New
York, NY, USA, 2004. ACM Press.