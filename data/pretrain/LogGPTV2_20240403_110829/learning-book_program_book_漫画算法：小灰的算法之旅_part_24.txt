Name
1
小灰
2
大黄
3
小白
第2步，让每一个标签存储包含此标签的所有用户ID，每一个标签都是
一个独立的Bitmap。
ID
Sex
Age
Occupation
Phone
1
男
90后
程序员
苹果
2
男
90后
程序员
三星
3
女
00后
学生
小米
Sex
Bitmap
Age
Bitmap
男
1,2
90后
1,2
女
3
00后
3
Occupation
Bitmap
Phone
Bitmap
程序员
1,2
苹果
1
学生
3
三星
2
小米
3
---
## Page 447
这样一来，每一个用户特征都变得一目了然。
例如程序员和"00后"这两个群体，各自的Bitmap分别如下。
程序员：
“00后”
Bingo！这就是Bitmap算法的运用。
我还有一点不太明白，使用哈希
表也同样能实现用户的去重和统计操作，为什么一定要使用Bitmap
呢？
---
## Page 448
傻孩子，如果使用哈希表的话，每一
个用户ID都要存成int或long类型，少则占用4字节（32bit），多则
占用8字节（64bit）。而一个用户ID在Bitmap中只占1bit，内存是使
用哈希表所占用内存的1/32，甚至更少！
不仅如此，Bitmap在对用户群做交集
和并集运算时也有极大的便利。我们来看看下面的例子。
1.如何查找使用苹果手机的程序员用户
程序员用户（0000000110B）：
用苹集手机的用户（0000000010B）：
2.如何查找所有男性用户或“00后"用户
---
## Page 449
只性用户（0000000110B）：
00后”用户（0000001000B）：
：（00111000000=8000100000000110000000）00
这就是Bitmap算法的另一个优势一
高性能的位运算。
原来如此。我还有一个问题，如
何利用Bitmap实现反向匹配呢？例如我想查找非“90后”的用户
如果简单地做取反运算操作，会出现问题吧？
会出现什么问题呢？我们来看一看。
---
## Page 450
"90后"用户的Bitmap如下。
“90后”用户：
6
如果想得到非“90后”的用户，能够直接进行非运算吗？
非“90后”用户：
显然，非“90后"用户实际上只有1个，而不是图中所得到的8个结果，所
以不能直接进行非运算。
这个问题提得很好，但是也不难解
决，我们可以借助一个全量的Bitmap。
同样是刚才的例子，我们给出“90后"用户的Bitmap，再给出一个全量用
户的Bitmap。最终要求出的是存在于全量用户，但又不存在于"90后"用
户的部分。
“90后”用户：
全量用户：
---
## Page 451
如何求出这部分用户呢？我们可以使用异或
运算进行操作，即相同位
为0，不同位为1。
：（80110000000）06。
全量用户（0000001110B)：
非*90后”用户（0000000110BXOR0000001110B=0000001000B）：
我明白了，这真是个好方法！那么
Bitmap的代码该怎么来实现呢？
Bitmap的实现方法稍微有些难理解，
让我们来看看代码。
1.//每一个word是一个1ong类型元素，对应一个64位二进制数据
---
## Page 452
2. private long[] words;
3.//Bitmap的位数大小
4. private int size;
5.
6. public MyBitmap(int size){
7.
this.size = size;
8.
this.words = new long[(getwordIndex(size-1) + 1)];
'6
10.
11./**
12.
判断Bitmap某一位的状态
13.
*
@param
bitIndex位图的第bitIndex位
14.
*/
15.
public boolean getBit(int bitIndex) {
16.
if(bitIndexsize-1){
17.
throw new IndexOutofBoundsException("超过Bitmap
有效范围")；
18.
19.
int wordIndex = getwordIndex(bitIndex);
20.
return （words[wordIndex]&（1L size-1){
29.
throw new IndexOutofBoundsException("超过Bitmap
有效范围"）；
30.
31.
int wordIndex = getwordIndex(bitIndex);
32.
words[wordIndex] |=(1L > 6;
42.}
43.
44. public static void main(String[] args) {
45.
MyBitmap bitMap = new MyBitmap(128);
46.
bitMap.setBit(126) ;
47.
bitMap. setBit(75);
48.
System.out.println(bitMap.getBit(126)) ;
---
## Page 454
49.
System.out.println (bitMap.getBit(78));
50.}
在上述代码中，使用一个命名为words的long类型数组来存储所有的二
进制位。每一个long元素占用其中的64位。
如果要把Bitmap的某一位设为1，需要经过两步。
1.定位到words中的对应的long元素。
2.通过与运算修改long元素的值。
如果要查看Bitmap的某一位是否为1，也需要经过两步。
1.定位到words中的对应的long元素。
2.判断long元素的对应的二进制位是否为1。
有了Bitmap的基本读写操作，该如何实现两个Bitmap的与、或、异或运
算呢？感兴趣的读者可以思考一下。
想要深入研究Bitmap算法的读者，可
以看一下JDK中BitSet类的源码。同时，缓存数据库Redis中也有对
Bitmap算法的支持。
虽然有现成的工具类和数据库，但我们仍然应该了解Bitmap算法的底层
原理和实现方式。
---
## Page 455
今天就介绍到这里，咱们下一节再
见！
---
## Page 456
6.3
LRU算法的应用
6.3.1
一个关于用户信息的需求
小灰，我又有一个
需求要和你说谈。
好呀，好呀，来100
个需求也不怕！
现在公司的业务越来越复杂，我们需要抽出
一个用户系统，向各个业务系统提供用户的基本信息。
---
## Page 457
业务1
业务2
业务3
用户信息
用户ID
用户名
手机号
用户等级
......
用户系统
业务方对用户信息的查询频率很高，一定要
注意性能问题哦。
放心吧，交给我，妥妥的！
用户信息当然是存放在数据库里。但是由于我们对用户系统的性能要求
比较高，显然不能在每一次请求时都去查询数据库。
所以，小灰在内存中创建了一个哈希表作为缓存，每当查找一个用户时
会先在哈希表中进行查询，以此来提高访问的性能。
---
## Page 458
业务1
业务2
业务3
用户ID
用户信息
001
用户1信息
哈希表
002
用户2信息
003
用户3信息
用户数据库
b00
用户4信息
用户系统
很快，用户系统上线了，小灰美美地休息了几天。
一个多月之后....
小灰，小灰，大事不好了！
哦，出了什么事？
---
## Page 459
线上服务器岩机了！
让我看看......糟了，是内存溢出了，用
户数量越来越多，当初设计的哈希表把内存给撑爆了，赶紧重启
吧！
可是以后该怎么办呢？我们能不能给服
务器的硬件升级，或者加几台服务器呀？
---
## Page 460
可是咱们公司没钱呀？！
那我能不能在内存快耗尽的时候，随机
删掉一半用户缓存呢？
喉，这样也不妥，如果删掉的用户信
息，正好是被高频查询的用户，会影响系统性能的。
天响这可怎么办？
---
## Page 461
6.3.2
用算法解决问题
小灰，你怎么日渐消瘦了啊？
喉，还不是被一个需求折腾的！
事情是这样子的....（小灰把工
作中的难题告诉了大黄）
---
## Page 462
小灰，你听说过LRU算法吗？
只听说过URL，没听说过LRU，那是什
么鬼？
LRU全称LeastRecentlyUsed，也就是
最近最少使用的意思，是一种内存管理算法，该算法最早应用于
Linux操作系统。
---
## Page 463
这个算法基于一种假设：长期不被使
用的数据，在未来被用到的几率也不大。因此，当数据所占内存达
到一定阅值时，我们要移除掉最近最少被使用的数据。
原来如此，这个算法正好对我的
用户系统有帮助！可以在内存不够时，从哈希表中移除一部分很少
被访问的用户。
可是，我怎么知道哈希表中哪些Key-
Value最近被访问过，哪些没被访问过？总不能给每一个Value加上
时间戳，然后遍历整个哈希表吧？
---
## Page 464
这就涉及LRU算法的精妙所在了。在
LRU算法中，使用了一种有趣的数据结构，这种数据结构叫作哈希
链表。
什么是哈希链表呢？
我们都知道，哈希表是由若干个Key-Value组成的。在“逻辑”上，这些
Key-Value是无所谓排列顺序的，谁先谁后都一样。
Keyl
Key2
Key3
Key4
Key5
Value1
Value2
Value3
Value4
Value5
在哈希链表中，这些Key-Value不再是彼此无关的存在，而是被一个链
条串了起来。每一个Key-Value都具有它的前驱Key-Value、后继Key-
Value，就像双向链表中的节点一样。
Keyl
Key2
Key3
Key4
Key5
Value1
Volue2
Value?
alu
Value5
这样一来，原本无序的哈希表就拥有了固定的排列顺序。
可是，这哈希链表和LRU算法有什么关
---
## Page 465
系呢？
依靠哈希链表的有序性，我们可以把
Key-Value按照最后的使用时间进行排序。
让我们以用户信息的需求为例，来演示一下LRU算法的基本思路。
1.假设使用哈希链表来缓存用户信息，目前缓存了4个用户，这4个用户
是按照被访问的时间顺序依次从链表右端插入的。
001
002
003
t00
==
用户1
用户2
用户3
用户4
信息
信息
信息
信息
2.如果这时业务方访问用户5，由于哈希链表中没有用户5的数据，需要
从数据库中读取出来，插入到缓存中。此时，链表最右端是最新被访问
的用户5，最左端是最近最少被访问的用户1。
001
002
003
b00
005
用户1
用户3
用户4
用户5
信息
信息
信息
信息
3.接下来，如果业务方访问用户2，哈希链表中已经存在用户2的数据，
这时我们把用户2从它的前驱节点和后继节点之间移除，重新插入链表
的最右端。此时，链表的最右端变成了最新被访问的用户2，最左端仍
然是最近最少被访问的用户1。
---
## Page 466
001
003