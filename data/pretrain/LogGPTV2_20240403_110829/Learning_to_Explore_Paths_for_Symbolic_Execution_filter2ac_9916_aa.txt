title:Learning to Explore Paths for Symbolic Execution
author:Jingxuan He and
Gishor Sivanrupan and
Petar Tsankov and
Martin T. Vechev
Learning to Explore Paths for Symbolic Execution
Jingxuan He
ETH Zurich
Switzerland
PI:EMAIL
Gishor Sivanrupan
ETH Zurich
Switzerland
Petar Tsankov
ETH Zurich
Switzerland
Martin Vechev
ETH Zurich
Switzerland
PI:EMAIL
PI:EMAIL
PI:EMAIL
ABSTRACT
Symbolic execution is a powerful technique that can generate tests
steering program execution into desired paths. However, the scal-
ability of symbolic execution is often limited by path explosion,
i.e., the number of symbolic states representing the paths under
exploration quickly explodes as execution goes on. Therefore, the
effectiveness of symbolic execution engines hinges on the ability
to select and explore the right symbolic states.
In this work, we propose a novel learning-based strategy, called
Learch, able to effectively select promising states for symbolic
execution to tackle the path explosion problem. Learch directly
estimates the contribution of each state towards the goal of max-
imizing coverage within a time budget, as opposed to relying on
manually crafted heuristics based on simple statistics as a crude
proxy for the objective. Moreover, Learch leverages existing heuris-
tics in training data generation and feature extraction, and can thus
benefit from any new expert-designed heuristics.
We instantiated Learch in KLEE, a widely adopted symbolic ex-
ecution engine. We evaluated Learch on a diverse set of programs,
showing that Learch is practically effective: it covers more code
and detects more security violations than existing manual heuris-
tics, as well as combinations of those heuristics. We also show that
using tests generated by Learch as initial fuzzing seeds enables
the popular fuzzer AFL to find more paths and security violations.
CCS CONCEPTS
• Software and its engineering → Software testing and de-
bugging; • Security and privacy → Software security engi-
neering.
KEYWORDS
Symbolic execution; Fuzzing; Program testing; Machine learning
ACM Reference Format:
Jingxuan He, Gishor Sivanrupan, Petar Tsankov, and Martin Vechev. 2021.
Learning to Explore Paths for Symbolic Execution. In Proceedings of the 2021
ACM SIGSAC Conference on Computer and Communications Security (CCS
’21), November 15–19, 2021, Virtual Event, Republic of Korea. ACM, New York,
NY, USA, 15 pages. https://doi.org/10.1145/3460120.3484813
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
© 2021 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3484813
Symbolic
execution
Heuristics
(iteration 1)
Training
programs
Learning
Inference
Input
programs
Tests
iter 1
iter 2
...
Reward
calculation
iteration 2, 3, ...
Regression
training
1.3
2.0
0.5
0.4
Supervised
dataset
Learned
strategy
Coverage
Security
violations
Tests
Figure 1: Our recipe for learning a state selection strategy.
1 INTRODUCTION
Symbolic execution [18, 44] is a promising program analysis tech-
nique widely used in many security-related tasks, such as analyzing
protocol implementations [23, 24, 53], validating hardware design
[76], securing smart contracts [49, 55], and detecting cache timing
leaks [36]. Most prominently, symbolic execution has been exten-
sively used for automatic test generation to exercise program paths
and identify security violations [8, 16, 17, 22, 68], and is by now
an established industrial practice for software testing at Microsoft
[34], IBM [6], NASA [52], and other organizations.
At a high level, symbolic execution works by representing pro-
gram inputs as symbolic variables, exploring program paths sym-
bolically, and collecting path constraints that capture conditions
over the input variables that must hold to steer the program along a
given path. These constraints can be fed into an external constraint
solver to construct a concrete test case. The common goal for sym-
bolic execution tools is to generate a test suite that achieves high
code coverage over the program’s statements within an allocated
time budget [16, 52, 74].
Key challenge: path explosion. While powerful, symbolic exe-
cution is expensive and difficult to scale to large, real-world pro-
grams due to the so-called path explosion problem [18]. That is, at
each program branch, the (symbolic) state for a given path is forked
into two separate states. As a consequence, the number of states
is exponential in the number of branches and quickly explodes as
the execution reaches deep branches. To cope with this challenge,
symbolic execution tools need an effective mechanism to select and
execute promising states that achieve the highest coverage and cost
the least execution time, while avoiding expensive states that do
not improve coverage.
Unfortunately, constructing an ideal state selection is not pos-
sible because at the time of picking a state to explore we do not
know whether it will indeed improve coverage at a reasonable cost.
Ultimately, this decision depends on how the selected state would
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2526unfold as we continue executing it as well as on state selection
decisions we make in the future. Due to this fundamental limita-
tion, symbolic execution tools rely on manually designed heuristics,
used as a proxy for the ideal selection, that select states based on
properties such as instruction count [16], subpath count [48], con-
straint search depth [52], and hand-crafted fitness [74]. As a result,
even though designed by experts, those heuristics can easily get
stuck in program parts favoring the measured property and fail
to reach other relevant parts that, if covered, would improve code
coverage and may identify critical security violations.
Learch: a learning-based state selection strategy.
In this
work, we propose a new data-driven approach, called Learch (short
for Learning-based sEARCH), for learning a state selection strategy
that enables symbolic execution tools to efficiently explore the
input program. The key idea is to leverage a machine learning re-
gression model that, for each state, estimates a reward that directly
captures the core objective of the tool – improving more coverage
while spending less time producing concrete tests. Based on this
model, Learch selects the state with the highest estimated reward,
as opposed to relying on manual heuristics used as a proxy to max-
imize the tool’s objective. Importantly, the construction of Learch
utilizes the knowledge of existing heuristics and can benefit from
any advances in the invention of new heuristics.
Learch is constructed using an iterative learning procedure, as
illustrated at the top of Figure 1. At each iteration, we first run
symbolic execution on a set of training programs. Notably, instead
of exploring states uniformly at random, we leverage different
state selection strategies (e.g., manual heuristics at iteration 1) to
generate a diverse set of tests. Then, for each explored state in the
generated tests, we extract a set of high-level features (including
the properties used by the heuristics) and calculate a reward based
on the overall coverage improvement and time spent exploring the
state. This results in a supervised dataset that captures the behaviors
of the strategies used in the previous step. Finally, we construct a
learned strategy by training a regression model to achieve a small
loss on the supervised dataset so that the model can make accurate
estimations for the reward. The strategy learned at the current
iteration is used to add new supervised data in the next iterations
to create additional learned strategies. At inference time (bottom
of Figure 1), given an unseen program, we run multiple symbolic
execution instances with the learned strategies to generate effective
tests used to exercise the program and report security violations.
Instantiation and evaluation. We instantiated Learch1 on the
most popular symbolic execution engine KLEE [16]. We evaluated
Learch on a diverse set of programs, including 52 coreutils pro-
grams and 10 real-world programs. Our results demonstrate that
Learch is practically effective: it consistently produced more code
coverage (e.g., >20%) and detected more security violations (e.g.,
>10%) than existing manual heuristics [16, 48], as well as the combi-
nations of individual heuristics. Moreover, we used tests generated
by KLEE as initial seeds to run a popular fuzzer, AFL [1, 29]. The
initial seeds from Learch helped AFL to trigger more paths and
security violations than the manual heuristics.
1Learch is publicly available at https://github.com/eth-sri/learch.
s
m
a
r
g
o
r
p
f
o
#
30
20
10
0
# of symbolic states:
28
9
8
7
0–1k
1k–10k
10k–100k 100k–140k
Figure 2: Number of coreutils programs grouped by the aver-
age number of candidate states available at selection steps.
bolic execution. (Section 3)
strategies. (Section 4)
Main contributions. Our main contributions are:
• Learch, a new learning-based state selection strategy for sym-
• A novel learning framework for constructing multiple learned
• A complete instantiation of Learch on the popular symbolic test
• An extensive evaluation on a diverse set of programs and various
tasks, demonstrating that Learch is practically effective and
outperforms existing manually designed heuristics. (Section 6)
generator KLEE. (Section 5)
2 MOTIVATION FOR LEARNING
In this section, we motivate the use of learning for selecting sym-
bolic states by analyzing the results of running KLEE [16] on the
52 coreutils programs used as one of the test set in our evaluation.
The time limit of KLEE was 1h, and the memory budget was 4GB.
Large number of candidate states. When symbolically execut-
ing an input program, KLEE usually forks a large number of states
due to branching behaviors such as if-else statements, resolving
function pointers, and resolving memory allocation sizes. To mea-
sure the number of states produced by KLEE, we ran the tool using
the random path search heuristic (rps) on the 52 coreutils programs
and calculated the average number of candidate states at the se-
lection steps, and show the results in Figure 2. For most programs,
the number of states produced by KLEE is huge: 28 programs have
on average 10k–100k candidate states for selection. For programs
larger than coreutils, the number of candidate states could be even
larger. The enormous search space motivates the need for construct-
ing an effective, fine-grained strategy able to pick promising states
instead of relying on simple and crude heuristics.
Limitations of existing manually designed heuristics. Ex-
isting heuristics are random or manually designed by experts and
typically depend on certain property of the states [16, 48]. They
often get stuck in program parts favoring the property but fail to
explore other parts. We ran KLEE with a set of existing heuristics
and present the average line coverage of the top three heuristics
(rps, nurs:depth, and sgs) in the Venn diagram in Figure 3(a). All
three heuristics achieved ∼540 line coverage. However, no single
heuristic significantly outperformed the others. Importantly, the
heuristics have non-comparable performance and covered different
parts of the program: 499 lines were covered by all heuristics, but
the rest 86 lines were covered by different heuristics. Similarly, the
capability of detecting security violations (UBSan violations [4] in
our work) differs across the heuristics, as shown in Figure 3(b).
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2527rps
nurs:depth
sgs
portfolio
Learch
17
499
10
17
11
12
19
3
62
3
7
1
3
3
10
535
79
14
523
91
21
519
95
21
551
62
9
7
66
22
6
67
21
64
24
10
67
21
(a) Average line cover-
age by heuristics.
(b) UBSan violations
found by heuristics.
(c) Average
Learch v.s. heuristics.
line
coverage:
(d) UBSan violations: Learch v.s.
heuristics.
Figure 3: Limitations of existing manually designed heuristics and how Learch outperforms them for our coreutils test set.
Opportunities for learning. Based on the results in Figure 3(a)
and Figure 3(b), we can compute the union of covered lines and de-
tected UBSan violations for the three heuristics. The union achieved
585 line coverage and detected 82 UBSan violations, significantly
higher than any individual heuristic. This indicates a promise of
constructing an adaptive strategy that subsumes individual heuris-
tics. In fact, the heuristics provide a precious knowledge base that
facilitates learning such an adaptive strategy. Namely, the heuris-
tics can be used to generate a diverse training dataset, capturing
different selection behaviors, and the properties they rely on can
be used as valuable features for a machine learning model. Another
key advantage of learning is that while the reward calculation is
impossible at inference time, it can be computed for the states ex-
plored at training time, from which we can obtain a direct estimator
for the final coverage-guided objective. The above insights facilitate
and motivate our learning scheme proposed in Figure 1.
To show evidence on the benefits of learning, we constructed an-
other heuristic called portfolio by running the three heuristics, each
for a third of the total time limit, and combined all produced test
cases. We compare Learch with the four heuristics in Figure 3(c)
and Figure 3(d). In terms of total coverage, Learch outperformed all
four heuristics. Learch was able to cover most code covered by the
heuristics, and exclusively covered more code than the heuristics.
The same holds for the detection of UBSan violations.
Scope and applicability. Our work focuses on purely symbolic
execution (i.e., no concrete execution happens during the test gener-
ation process), even though our idea may give hints for improving
other approaches where it is tricky to select program branches for
test generation, such as concolic testing [33, 57, 58, 62] and hybrid
testing [27, 69, 75]. We aim to solve the state selection problem, while
there are many orthogonal approaches for easing path explosion
such as state merging [46] and state pruning [13, 14, 21, 70].
3 SYMBOLIC EXECUTION FRAMEWORK
In this section, we first present a general symbolic execution frame-
work parameterized by a state selection strategy and then introduce
the Learch state selection strategy.
3.1 Symbolic Execution
In Algorithm 1, we show a symbolic execution algorithm called
symExec, a general version of the one in [48]. symExec takes a program
proд (compiled to low-level instructions such as LLVM IR) and a
state selection strategy (strateдy) as input, and generates a set of
test cases (tests). symExec symbolically explores the branches of proд
(different from [16] which explores one instruction each time) and
stores the progress in a list of symbolic states (states). strateдy is
used to select a state from states for execution at each step. When
the execution of one program path is finished, a test is generated
and added to tests. Next, we describe symExec step by step.
At Line 2, we initialize tests and states to be empty. Then, we
append proд’s initial state which represents the proд’s entry block
to states (Line 3) and calls update to update strateдy (Line 4). update
is an auxiliary function that is called whenever a new state is added
or a pending state is updated. We will discuss update later in this
section. Next, at Line 5, the main loop for symbolic exploration
starts. The loop terminates when states becomes empty, i.e., no
available state can be explored, or the time limit has been reached.
Inside the main loop, we first call selectState, another auxiliary
function described later, for selecting a state (state) from states
where each state represents a branch under exploration. We contin-
uously execute the instructions of state symbolically (Line 8) and
meanwhile check if the current execution violates any of the prede-
fined security properties. The execution stops when we encounter
an EXIT instruction, a security violation, or a FORK instruction
(Line 7). When reaching an EXIT instruction that indicates the
end of a program path or detecting a security violation, we call an
external constraint solver to construct a new concrete test (Line 10)
and remove state from states so that we stop further execution
on state (Line 11). FORK instructions indicate a branching point,
for which we need to copy state to create a forked state f orked
(Line 13). state and f orked then represent the two new branches,
respectively. We append f orked to states, and update both state
and f orked (Line 14 to Line 16). After the main loop finally finishes,
tests is returned.
Objective of symExec. Given an input program, the objective of
running symExec with strateдy is to find a set of concrete tests
achieving the maximal coverage within a fixed amount of time:
|
t ∈tests coverage(t)|
symExecTime
arg maxtests =symExec(proд,str ateдy)
(1)
where coverage(t) measures the coverage of test t (we use line cov-
erage in this work) and symExecTime is the time spent on running
symExec. Achieving Equation 1 is challenging as the number of pend-
ing states is exponential to the number of forks and it is hard to
predict what tests and the coverage of the tests a selected state will
result in. The key is to construct a state selection strategy that can
select the most promising states leading to high-quality tests.
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2528Input
Algorithm 1: Branch-based symbolic execution
1 Procedure symExec(proд, strateдy)
:proд, an input program.