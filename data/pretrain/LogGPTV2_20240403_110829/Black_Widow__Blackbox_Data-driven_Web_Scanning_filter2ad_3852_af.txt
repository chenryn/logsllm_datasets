1
1
ZAP
S
R
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
D. Code Injection Results
This section presents the results from the vulnerabilities
the different scanners ﬁnd. To be consistent with the ter-
minology used in previous works [13], [8], we deﬁne an
XSS vulnerability to be any injected JavaScript code that
results in execution. While accepting JavaScript from users
is risky in general, some applications, like Wordpress, have
features which require executing user supplied JavaScript.
In Section V-G we discuss the impact and exploitability of
the vulnerabilities our scanner ﬁnds.
In Table IV we list all the XSS vulnerabilities found by
the scanners on all the applications. The table contains the
number of self-reported vulnerabilities. After removing the
false positives and clustering similar injections, as explained
in Section IV-B, we get the new results in Table V. The
results from Table V show that Black Widow outperforms
the other scanners on both the reference applications and the
modern applications. In total, Black Widow ﬁnds 25 unique
vulnerabilities, which is more than 3 times as many as the
second-best scanner. Of these 25, 6 are previously unknown
vulnerabilities in modern applications. We consider the
remaining 19 vulnerabilities to be known for the following
reasons. First, all WackoPicko vulnerabilities are implanted
by the authors and they are all known by design. Second,
SCARF has been researched thoroughly and vulnerabilities
may be already known. We conservatively assumed the eight
vulnerabilities to be known. Third, the vulnerabilities on
phpBB and Vanilla were ﬁxed in their newest versions.
It is important to note we did not miss any vulnerability
that the others found. However, there were cases where both
Black Widow and other scanners found the same vulnerabil-
ity but by injecting different parameters. We explore these
cases more in Section V-F. Furthermore, Black Widow is
the only scanner that ﬁnds vulnerabilities in the modern web
applications.
E. Takeaways
We have shown that our scanner can outperform the other
scanners in terms of both code coverage and vulnerability
detection. Figure 2 and Table I show that we outperform the
other scanners in 69 out of 70 cases. Additionally, Table II
and Table III show we improve code coverage by between
63% and 280% compared to the other scanners and by
between 6% and 62%, compared to the sum of all other
scanners. We also improve vulnerability detection, as can
be seen in Table IV and Table V. Not only do we match
the other scanners but we also ﬁnd new vulnerabilities in
production applications.
In the next section, we will analyze these results closer
and conclude which features allowed us to improve coverage
and vulnerability detection. We also discuss what other
scanners did better than us.
V. ANALYSIS OF RESULTS
The results from the previous section show that
the
code coverage of our scanner outperforms the other ones.
Furthermore, we ﬁnd more code injections and in particular
more stored XSS. In this section, we analyze the factors
which led to our advantage. We also analyze where and
why the other scanners performed worse.
Since we have access to the executed lines of code we
can closely analyze the path of the scanner through the
application. We utilize this to analyze when the scanners
miss injectable parameters, what values they submit, when
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:17 UTC from IEEE Xplore.  Restrictions apply. 
1134
requests. This could be due to an implementation error or
because the state inference becomes too complicated in these
applications.
Although Black Widow performs well against Wget, Wget
still ﬁnds some unique lines, which can seem surprising as it
has previously been used as a reference tool [13], [8]. Based
on the traces and source code, we see that most of the unique
lines of code Wget ﬁnds are due to state differences, e.g.
visiting the same page Black Widow ﬁnds but while being
unauthenticated.
B. False positives and Clustering
To better understand the reason behind the false positives,
and be transparent about our clustering, we analyze the
vulnerabilities reported in Table IV. For each scanner with
false positives, we reﬂect on the reasons behind the incorrect
classiﬁcation and what improvements are required. We do
not include w3af in the list as it did not produce any false
positives or required any clustering.
the State
a) Arachni reports two reﬂected XSS vulnerabilities in
Vanilla. The injection point was a Cloudﬂare cookie used
on the online support forum for the Vanilla web application.
The cookie is never used in the application and we were
unable to reproduce the injection. In addition, Arachni ﬁnds
31 XSS injections on SCARF. Many of these are incorrect
because Arachni reuses payloads. For example, by injecting
into the title of the page, all successive injection will be
label as vulnerable.
b) Enemy of
claims the discovery of 8
reﬂected XSS vulnerabilities on Joomla. However, after
manual analysis, none of these result in code execution. The
problem is that Enemy of the State interprets the reﬂected
payload as an executed payload. It injects, eval(print
"[random]"), into a search ﬁeld and then detects that
"[random]" is reﬂected. It incorrectly assumes this is
because eval and print were executed. For this reason,
we consider Enemy of the State to ﬁnd 0 vulnerabilities on
Joomla.
c) j ¨Ak reports 13 vulnerabilities on WackoPicko. These
13 reports were different payloads used to attack the search
parameter. After applying our clustering method, we con-
sider j ¨Ak to ﬁnd one unique vulnerability.
they fail to access parts of the application and how they
handle sessions.
We start by presenting interesting cases from the code
coverage evaluation in Section V-A, followed by an analysis
of the reported vulnerabilities from all scanners in Sec-
tion V-B. In Section V-C, we discuss the injections our
scanner ﬁnds and compare it with what the others ﬁnd. In
Section V-D, we perform two case studies of vulnerabilities
that only our scanner ﬁnds and which requires both workﬂow
traversal and dependency analysis. Finally, in Section V-E,
we extract the crucial features for ﬁnding injections based
on all vulnerabilities that were found.
A. Coverage Analysis
As presented in Section IV-C, Black Widow improved
code coverage, compared to the aggregated result of all the
other scanners, ranged from 5.5% on Drupal to 62% on
PrestaShop. Comparing the code coverage to each scanner,
Black Widow’s improvement ranged from 63.3% against
Arachni to 280% against Wget. In this section, we analyze
the factors pertaining to code coverage by inspecting the per-
formance of the different scanners. To better understand our
performance we divide the analysis into two categories. We
look at both cases where we have low coverage compared
to the other scanners and cases where we have high relative
coverage.
Low coverage: As shown in Figure 2, Enemy of the
State is the only scanner that outperforms Black Widow
and this is speciﬁcally on Drupal. Enemy of the State high
coverage on Drupal is because it keeps the authenticated
session state by avoiding logging out. The reason Black
Widow lost the state too early was two-fold. First, we use
a heuristic algorithm, as explained in Section III-B to select
the next edge and unfortunately the logout edge was picked
early. Second, due to the structure of Drupal, our scanner did
not manage to re-authenticate. In particular, this is because,
in contrast to many other applications, Drupal does not
present the user with a login form when they try to perform
an unauthorized operation. To isolate the reason for the
lower code coverage, we temporarily blacklist the Drupal
logout function in our scanner. This resulted in our scanner
producing similar coverage to Enemy of the State, ensuring
the factor behind the discrepancy is session handling.
Skipﬁsh performs very well on WordPress, which seems
surprising since it is a modern application that makes heavy
use of JavaScript. However, WordPress degrades gracefully
without JavaScript, allowing scanners to ﬁnd multiple pages
without using JavaScript. Focusing on static pages can
generate a large coverage but, as is evident from the detected
vulnerabilities, does not imply high vulnerability detection.
High coverage: Enemy of the State also performs
worse against Black Widow on osCommerce and HotCRP.
This is because Enemy of the State is seemingly entering
an inﬁnite loop, using 100% CPU without generating any
d) Black Widow ﬁnds 32 stored vulnerabilities on
phpBB. Most of these parameters are from the conﬁguration
panel and are all used in the same database query. There-
fore, only 3 can be considered unique. Two parameters on
PrestaShop are used in the same request, thus only one is
considered unique. Black Widow did not produce any false
positives thanks to our dynamic detection method explained
in section III-D
e) Skipﬁsh claims the detection of a stored XSS in
WackoPicko in the image data parameter when uploading
an image. However, the injected JavaScript could not be
executed. Interesting to note is that Skipﬁsh was able to
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:17 UTC from IEEE Xplore.  Restrictions apply. 
1135
inject JavaScript into the guestbook but was not able to
detect it.
f) ZAP
claims to ﬁnd 9 reﬂected XSS injection
on osCommerce. They are all variations of
injecting
javascript:alert(1) into the parameter of a link.
Since it was just part of a parameter and not a full URL,
the JavaScript code will never execute. Thus, all 9 injections
were false positives.
C. What We Find
In this section, we present the XSS injections our scanner
the
ﬁnds in the different applications. We also extract
important features which made it possible to ﬁnd them.
HotCRP: Reﬂected XSS in bulk user upload: The admin
can upload a ﬁle with users to add them in bulk. The name
of the ﬁle is then reﬂected on the upload page. To ﬁnd this,
the scanner must be able to follow a complex workﬂow
that makes heavy use of JavaScript, as well as handle ﬁle
parameters. It is worth noting that the ﬁlename is escaped
on other pages in HotCRP but missed in this case.
osCommerce; Stored and reﬂected XSS: Admins can
change the tax classes in osCommerce and two parameters
are not correctly ﬁltered, resulting in stored XSS vulnera-
bilities. The main challenge to ﬁnd this vulnerability was to
ﬁnd the injection point as this required us to interact with a
navigation bar that made heavy use of JavaScript.
We also found three vulnerable parameters on the review
page. These parameters were part of a form and their types
were radio and hidden. This highlights that we still inject
all parameters, even if they are not intended to be changed.
phpBB; Multiple Stored XSS in admin backend: Ad-
mins can change multiple different application settings on
the conﬁguration page, such as ﬂooding interval for posts
and max avatar ﬁle size. On a separate page, they can also
change the rank of the admin to a custom title. In total, this
results in 32 vulnerable parameters that can be clustered to
3 unique ones. These require inter-state dependency analysis
to solve. Once a setting is changed, the admin is met with
a “Successful update” message, which does not reﬂect the
injection. Thus, the dependency must be found to allow for
successful fuzzing.
PrestaShop; Reﬂected XSS in admin dashboard: The
admin dashboard allows the admin to specify a date range
for showing statistics. Two parameters in this form are not
correctly ﬁltered and result in a reﬂected XSS. Finding these
requires a combination of modeling JavaScript events and
handling workﬂows. To ﬁnd this form the scanner must ﬁrst
click on a button on the dashboard.
SCARF; Stored XSS in comments: There are many
vulnerabilities in SCARF, most are quite easy to ﬁnd. Instead
of mentioning all, we focus on one that requires complex
workﬂows, inter-state dependencies and was only found by
us. The message ﬁeld in the comment section of conference
papers is vulnerable. What makes it hard to ﬁnd is the
traversing and needed before posting the comment and the
inter-state dependency analysis needed to ﬁnd the reﬂection.
The scanner must ﬁrst create a user, then create a conference,
after which it can upload a paper that can be commented on.
Vanilla; Stored and reﬂected XSS: The language tag
for the RSS feed is vulnerable and only reﬂected in the
feed. Note that
the feed is served as HTML, allowing
JavaScript to execute. There is also a stored vulnerability
in the comment section which can be executed by saving
a comment as a draft and then viewing it. Both of these
require inter-state dependency analysis to ﬁnd the connecting
between language settings and RSS feeds, as well as posting
comments and viewing drafts.
Black Widow also found a reﬂected XSS title parameter
in the conﬁguration panel that was vulnerable. Finding this
mainly required and modeling JavaScript and forms.
WackoPicko; Multi-step stored XSS: We found all the
known XSS vulnerabilities [25], except the one requiring
ﬂash as we consider it out-of-scope. We also found a
non-listed XSS vulnerability in the reﬂection of a SQL
error. Most notably we were able to detect the multi-step
XSS vulnerability that no other scanner could. This was
thanks to both inter-state dependency tracking and handling
workﬂows. We discuss this in more detail in the case study
in Section V-D1.
WordPress; Stored and reﬂected XSS: The admin can
search for nearby events using the admin dashboard. The
problem is that the search query is reﬂected, through AJAX,
for the text-to-speech functionality. Finding this requires
modeling of both JavaScript events, network requests and
forms.
Our scanner also found that by posting comments from the
admin panel JavaScript is allowed to run on posts. For this,
the scanner must handle the workﬂows needed to post the
comments and the inter-state dependency analysis needed to
later ﬁnd the comment on a post.
D. Case Studies
In this section, we present two in-depth case studies of
vulnerabilities that highlights how and why our approach
ﬁnds vulnerabilities the other scanners do not. We base
our analysis on server-side traces, containing the executed
lines of code, generated from the scanner sessions. By
manually analyzing the source code of an application we can
determine the exact lines of code that need to be executed
for an injection to be successful.
The cases we use are the comment section in WackoPicko
and the conﬁguration panel in phpBB. As we have shown,
Black Widow can ﬁnd vulnerabilities in more complex
modern web applications. Nevertheless, these cases allow us
to limit the number of factors when comparing our approach
with the other scanners. Since WackoPicko and phpBB have
been used in previous studies [8], [13] they also serve as a
level playing ﬁeld for all scanners.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:17 UTC from IEEE Xplore.  Restrictions apply. 
1136
1) Comments on WackoPicko: WackoPicko has a previ-
ously unsolved multistep XSS vulnerability that no other
scanner has been able to ﬁnd. The difﬁcultly of ﬁnding and
exploiting is the need for correctly reproducing a speciﬁc
workﬂow. After submitting a comment via a form the user
needs to review the comment. While reviewing, the user can
choose to either delete the comment or add it. If, however,
the user decided to visit another page, before adding or
deleting, then the review form will be removed and the user
will have to resubmit the comment before reviewing it again.
Thus, the steps that must be taken are: Find an image to
comment on (view.php#50, i.e. line 50 in view.php),
Post a comment (preview_comment.php#54), Accept
the comment while reviewing (view.php#53) In Table VI
we note that two scanners are able to ﬁnd the input but not
exploit it.
Both Enemy of the State and Arachni managed to post a
comment but neither could exploit the vulnerability. Enemy
of the State was able to post a comment containing an
empty string but the fuzzing was unsuccessful. Arguably,
Arachni made it a bit further since it was able to inject an
XSS payload. However, the payload was not detected and
reported. Enemy of the State’s shortcoming is that it fuzzes
the forms independently while Arachni’s shortcoming is that
it forgets it’s own injection.
j ¨Ak and ZAP had problems ﬁnding the ﬁrst step, i.e.
viewing the pictures, because the login form breaks the
HTML standard by putting a form inside a table [26]. We
avoid this by using a modern browser to parse the web
page. This allows Black Widow to view the web page as
the developer intended, assuming they tested it in a modern
browser
Both w3af and Skipﬁsh were able to ﬁnd the pictures but
not able to post the comment. w3af because it could not
model the textarea in the form. Skipﬁsh, on the other
hand, does not have this problem. We believe that Skipﬁsh
logged out after seeing the picture but before posting the
comment. The data shows that Skipﬁsh does not try to log
in multiple times. In comparison, we correctly handle the
textarea allowing us to post comments. At the same time,
we also try to log in multiple times if presented with a login
form. This mitigates losing the session forever at an early
stage.
To solve this challenge Black Widow needs to combine
the modeling of form elements, handle workﬂows and use
inter-state dependency analysis to correctly inject and detect
the vulnerability.
2) Conﬁguration on phpBB: The conﬁguration panel on
phpBB has multiple code injection possibilities. To ﬁnd
these the crawler must overcome two challenges. First,
to reach the admin panel requires two logins,
the ﬁrst
to authenticate as a user and then again, with the same
credentials,
to authenticate as an administrator. Second,
the injected parameter is not reﬂected on the same page.
STEPS TO RECREATE THE VULNERABILITY IN WACKOPICKO. THE
COLUMNS CONTAIN THE FILE NAME AND LINE OF CODE FOR EACH STEP.
Table VI
Crawler
Arachni
Enemy
j ¨Ak
Skipﬁsh
w3af
Widow
ZAP
view.php#50
preview comment.php#54
view.php#53
Exploit
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
To detect this injection inter-state dependency analysis is
required. The steps needed to ﬁnd the vulnerability is, log
in as admin (admin/index.php#28), ﬁnd the vulner-
able form (admin_board.php#34), successfully update
the database (admin_board.php#74) ﬁnd the reﬂection
(admin_board.php#34).
As shown in Table VII, none of the other scanners
managed to access the conﬁguration panel. This is because
j ¨Ak, Skipﬁsh,
phpBB requires a double login. Arachni,
w3afand ZAP all require user-supplied credentials together
with parameters before running. Based on the traces they
do not try these credentials on the admin login form, only
the ﬁrst login form. Enemy of the State, on the other hand,
tries the standard username and password scanner1. This
was enough to log in but it did not manage to log in as an
admin.
Our scanner solves the double login by being consistent
with the values we submit. This allows us to both authenti-
cate as a user and then also as an admin when presented with
the login prompt. After submitting the form in conﬁguration
panel with our taint tokens and later revisiting it, we detect
the inter-state dependency and can fuzz the source and sink.
STEPS TO RECREATE THE VULNERABILITY IN PHPBB. THE COLUMNS
CONTAIN THE FILE NAME AND LINE OF CODE FOR EACH STEP.
Table VII
admin/
index.php#28
admin
board.php#34
admin
board.php#74
admin
board.php#34
Exploit
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Crawler
Arachni
Enemy
j ¨Ak
Skipﬁsh
w3af
Widow
ZAP
E. Features Attribution
In this section, we identify and attribute the key features
that contributed to ﬁnding the vulnerabilities in the web
applications.
In particular, we try to determine the impact of our
modeling,
traversing and inter-state dependency analysis
techniques. Below are the deﬁnitions we use in Table VIII.
1137
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:17 UTC from IEEE Xplore.  Restrictions apply. 
Modeling: Modeling is considered to contribute if a
combination of HTML forms and JavaScript events were
used to ﬁnd the code injection.
Traversal: Workﬂow traversal contributes if the point
of injection depends on a previous state. This could, for
example, be a form submission, a click of a button or some
other DOM interaction.
Inter-state dependency: A code injection is deﬁned to
need inter-state dependency analysis if the point of reﬂection
is different from the point of injection.
Table VIII shows the 25 unique code injections from the
evaluation. Of these, modeling contributed to 4, workﬂow
traversal contributed to 9, and inter-state dependency anal-
ysis contributed to 13. In total, at least one of them was a
contributor in 16 unique injections. The remaining 9 were
usually simpler. Four of them were from WackoPicko where
the results of injection were directly reﬂected. SCARF had
3 directly reﬂected injections and osCommerce had 2. It
is clear, especially for unique vulnerabilities, that modeling,
workﬂow traversal and inter-state dependency analysis plays
an important role in detecting stored XSS vulnerabilities.
FOR EACH OF THE VULNERABILITIES WE NOTE CONTRIBUTING
FEATURES, I.E. MODELING, WORKFLOW REPRODUCTION OR
Table VIII
INTER-STATE DEPENDENCY (ISD) ANALYSIS. WE ALSO PRESENT IF
THEY WERE UNIQUELY DETECTED BY BLACK WIDOW.
Application
HotCRP
osCommerce
osCommerce
phpBB
phpBB
phpBB
PrestaShop
SCARF
SCARF
SCARF
SCARF
SCARF
SCARF
SCARF
SCARF
Vanilla
Vanilla
Vanilla
Id
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16