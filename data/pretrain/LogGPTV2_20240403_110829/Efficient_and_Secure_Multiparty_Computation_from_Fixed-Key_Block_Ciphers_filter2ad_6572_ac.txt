This work
[28]
[1]
[1]
Standard OT
Correlated OT
Random OT
cr
random oracle
random oracle
Malicious security
cr∗
[29, 2]
[2]
[2]
Standard OT
Correlated OT
Random OT
random oracle
random oracle
cr
cr
cr
tcr
tcr
tcr
TABLE II: Assumptions about H in protocols for OT extension.
∗ refers to correlation robustness with compression, for which no
cr
instantiation from a ﬁxed-key cipher was known.
its other oracle. Thus, e.g., we say that a construction H in the
random-permutation model is (p, q, ρ, ε)-correlation robust if
for all D making at most p queries to π/π−1 and q queries
R, and all R with min-entropy at least ρ, it holds that
to Ocr
H,R(D) ≤ ε. We remark that for applications to secure
Advcr
computation, q is typically ﬁxed by the protocol but p can be
as large as the adversary’s running time.
Relations between the deﬁnitions. It is easy to see that any
H that is ccr (resp., tccr) is also cr (resp., tcr). It is also
easy to see that any H that is tcr (resp., tccr) can be used to
construct a hash function H(cid:3) that is cr (resp., ccr).
The construction we give in Section VII-B is cr but not ccr.
We are not aware of a generic transformation from cr (resp.,
ccr) to tcr (resp., tccr), however in Section V we show
(implicitly) that any H that is ccr can be used to construct
a hash function H(cid:3) that satisﬁes tccr for random inputs and
non-repeating tweaks. We show there that this weaker notion
sufﬁces for analyzing the half-gates garbling scheme.
IV. OBLIVIOUS-TRANSFER EXTENSION
As discussed in Section II-A, many existing implementa-
tions of OT extension based on a ﬁxed-key cipher are insecure
or, at best, cannot be proven secure. Part of the problem is
that some OT-extension protocols are proven secure in the
random-oracle model, but (efﬁcient) instantiations of a random
oracle from a ﬁxed-key cipher are not known. To address this
gap, we present here various ﬂavors of OT-extension protocols
based on hash functions satisfying the deﬁnitions from the
previous section. In doing so, we improve on the assumptions
used in several prior works, as summarized in Table II.
Speciﬁcally, for semi-honest security we show that it sufﬁces
for the hash function to be correlation robust. For malicious
security, however, we need tweakable correlation robustness.
The addition of a tweak is necessary in the malicious setting,
intuitively, to prevent the attacks shown in Section II. Without
a tweak, the hash function behaves “the same” across different
executions of the OT, and this can be exploited by a malicious
adversary. The attack can be prevented by incorporating an
independent tweak for each execution. (We formally prove
this intuition in the next section.)
Here we consider standard-OT extension and correlated-
OT extension; we defer the case of random-OT extension
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:34 UTC from IEEE Xplore.  Restrictions apply. 
829
Functionality FΔ-ROT
Initialize: Upon receiving (Init, Δ) from PA with Δ ∈ {0, 1}k, and (Init) from PB, store Δ and ignore subsequent Init commands.
Set up correlations: Upon receiving (x1, . . . , xm) from PB with xi ∈ {0, 1} do:
1) For each i ∈ [m], sample uniform ai, bi ∈ {0, 1}k such that ai ⊕ bi = xi · Δ.
2) If PA is corrupted, wait for A to send {ai} and recompute {bi} accordingly.
If PB is corrupted, wait for A to send {bi} and recompute {ai} accordingly.
3) Send {ai} to PA and {bi} to PB.
Global key query: If PB is corrupted then A can send a predicate P : {0, 1}k → {0, 1} to the functionality after initialization but
before sending its input. If P (Δ) = 1, the functionality sends 1 to A; otherwise, the functionality aborts and notiﬁes PA.
Fig. 1. Functionality FΔ-ROT.
Functionality FS-OT
m, m1
1, m1
1), . . . , (m0
Upon receiving ((m0
(x1, . . . , xm) from PB with xi ∈ {0, 1}, send {mxi
Fig. 2. Functionality FS-OT for standard OT.
m)) from PA and
i } to PB.
(m0
m, m1
Protocol ΠS-OT
1, m1
1), . . . , (m0
Inputs: PA has
x1, . . . , xm with xi ∈ {0, 1}.
Protocol:
1) PA chooses uniform Δ and sends (Init, Δ) to FΔ-ROT; PB
to FΔ-ROT, which returns
2) PB
sends (Init) to FΔ-ROT.
a1, . . . , am to PA and b1, . . . , bm to PB.
m) and PB has
(x1, . . . , xm)
sends
i := H(ai) ⊕ m0
i and
i to PB, who can then compute
3) Semi-honest security: PA sends c0
:= H(ai ⊕ Δ) ⊕ m1
:= cxi
i ⊕ H(bi).
c1
i
mxi
i
i := H(ai, i) ⊕ m0
Malicious security: PA sends c0
i := H(ai ⊕ Δ, i) ⊕ m1
c1
i ⊕ H(bi, i).
mxi
i
Fig. 3. Protocol ΠS-OT in the FΔ-ROT-hybrid model.
i and
i to PB, who can then compute
:= cxi
to Appendix A. Since our focus is on instantiating the hash
function H used in the second phase of OT extension (cf. the
beginning of Section II-A), we present all our protocols in the
FΔ-ROT-hybrid model (see Figure 1). This ideal functionality
provides an abstraction of the ﬁrst phase of OT extension, and
efﬁcient protocols realizing it are known in both the semi-
honest [1] and malicious [29] settings.
A. Standard-OT Extension
Figure 2 describes the standard OT functionality FS-OT. In
Figure 3 we show a protocol realizing standard OT in the
FΔ-ROT-hybrid model, in both the semi-honest and malicious
settings. We remark that the result for the case of semi-honest
security already follows from the work of Ishai et al. [28].
Theorem 1 (Informal). If H is cr (resp., tcr) then protocol
ΠS-OT securely realizes FS-OT for semi-honest (resp., mali-
cious) adversaries in the FΔ-ROT-hybrid model.
The theorem is somewhat informal since, e.g., we have not
deﬁned what it means for H to be cr but only what it means
for it to be (t, q, ρ, ε)-cr. A formal statement incorporating
concrete security bounds can be obtained from the proof.
Proof. Security in the FΔ-ROT-hybrid model for a corrupted
PA, whether semi-honest or malicious, holds perfectly and is
trivial to show. We therefore focus on the case of an adversary
A corrupting PB.
The case of a semi-honest PB is straightforward. (As noted
earlier, this is also implicit in [28].) The simulator in this case
extracts PB’s inputs from its input to the FΔ-ROT functionality,
sends these to the FS-OT functionality to obtain {mxi
i }, and
then for all i sets cxi
and chooses uniform
c1−xi
i
. It is immediate that correlation robustness of H implies
i
that this results in a view for PB that is indistinguishable from
its view in a real execution.
:= H(bi) ⊕ mxi
i
i
0 , . . . , mxm
(x1, . . . , xm)
m ).
In the malicious case the simulator is almost the same as
before, but the proof is more involved. For completeness, we
describe the simulator S in full:
1–2. S obtains the inputs (x1, . . . , xm), along with the values
. It sends the {cb
:= H(bi, i) ⊕ mxi
to FS-OT, which
{bi}i∈[m], that A sends to FΔ-ROT.
S sends
returns
(mx0
S chooses a uniform Δ and answers A’s global key query
(if any) using Δ.
uniform c1−xi
3. For all i, S sets cxi
and chooses
If A makes no global key query then it is immediate that if
H is (t, m, k, ε)-tweakable correlation robust then for any A
running in time at most t the advantage of A in distinguishing
−k (with
the simulated view from the real view is at most ε+2
the second term accounting for the probability that Δ = 0k).
Assume that for all 0 ≤ ρ ≤ k it holds that H is
(t, m, ρ, ε(ρ))-tweakable correlation robust. Say the global key
query P of A is such that |{Δ : P (Δ) = 1}| = 2ρ. Then
with probability 2ρ−k the attacker reduces the min-entropy of
Δ to ρ, but with the remaining probability the functionality
aborts. The maximum distinguishing advantage of A is thus
maxρ{2ρ−k · ε(ρ)} + 2
i} to PB.
−k.
i
i
B. Correlated OT
Correlated OT, proposed by Asharov et al. [1], is a weaker
form of OT in which the sender can only specify the XOR
of its “messages” (which are otherwise chosen uniformly by
the functionality); the relevant ideal functionality FC-OT is
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:34 UTC from IEEE Xplore.  Restrictions apply. 
830
Functionality FC-OT
Upon receiving (Δ1, . . . , Δm) from PA and (x1, . . . , xm) from
PB with xi ∈ {0, 1} do:
i ∈ {0, 1}k and set
1) For each i ∈ [m], sample uniform m0
i ⊕ Δi.
m1
i := m0
i} and recompute
2) If PA is corrupted, wait for A to send {m0
i} accordingly.
{m1
i } and
If PB is corrupted, wait for A to send {mxi
recompute {m1−xi
} accordingly.
3) Send {m0
i} to PA and {mxi
i } to PB.
i
Fig. 4. Functionality FC-OT for correlated OT.
Protocol ΠC-OT
sends
(x1, . . . , xm)
Inputs: PA has Δ1, . . . , Δm ∈ {0, 1}k and PB has x1, . . . , xm
with xi ∈ {0, 1}.
Protocol:
1) PA chooses uniform Δ and sends (Init, Δ) to FΔ-ROT; PB
to FΔ-ROT, which returns
2) PB
sends (Init) to FΔ-ROT.
a1, . . . , am to PA and b1, . . . , bm to PB.
3) Semi-honest security: PA computes m0
:= H(ai) and
sends ci := H(ai) ⊕ H(ai ⊕ Δ) ⊕ Δi to PB, who can
i
:= H(bi) ⊕ xici.
then compute mxi
Malicious security: PA computes m0
:= H(ai, i) and
sends ci := H(ai, i) ⊕ H(ai ⊕ Δ, i) ⊕ Δi to PB, who
i
can then compute mxi
Fig. 5. Protocol ΠC-OT in the FΔ-ROT-hybrid model.
:= H(bi, i) ⊕ xici.
i
i
given in Figure 4. Prior work showing correlated-OT extension
protocols [1, 2] requires a programmable random oracle,
even for semi-honest security, because the simulator needs
to program the output of H to ensure consistency with the
output from the ideal functionality. In fact, it appears difﬁcult
to efﬁciently realize the ideal functionality as deﬁned by
Asharov et al. without a programmable random oracle, and
for this reason we weaken the ideal functionality to allow the
adversary to choose its output. (Interestingly, we observe that
prior work [2] does not actually realize the ideal functionality
of Asharov et al. [1] but instead also realizes the weaker
version we deﬁne here. See Appendix B for more details.)
This ideal functionality still sufﬁces for applications to secure
computation. In Figure 5 we show a protocol that realizes this
functionality in both the semi-honest and malicious settings.
Theorem 2 (Informal). If H is cr (resp., tcr) then protocol
ΠC-OT securely realizes FC-OT for semi-honest (resp., mali-
cious) adversaries in the FΔ-ROT-hybrid model.
The comment following Theorem 1 applies here as well.
Proof. As in the case of Theorem 1, security for an adversary
A corrupting PA is perfect and easy to show. We thus focus on
the case of a corrupted PB. We consider the malicious setting;
the semi-honest setting follows similarly.
The simulator S for a malicious PB is as follows:
1–2. S obtains the inputs (x1, . . . , xm), as well as the values
{bi}i∈[m], that A sends to FΔ-ROT.
S also chooses a uniform Δ and answers A’s global key
query (if any) using Δ.
3. S chooses uniform {ci} and sends them to PB. It sets
:= H(bi, i) ⊕ xici and sends (x1, . . . , xm) and
i } to FC-OT.
mxi
{mxi
i
A proof of indistinguishability follows as in the proof of
Theorem 1.
V. REVISITING THE HALF-GATES GARBLING SCHEME
Zahur et al. [53] introduced the half-gates garbling scheme
based on an abstract hash function H. To analyze the scheme,
Zahur et al. introduce a deﬁnition called “circular correlation
robustness for naturally derived keys,” and prove security for
their garbling scheme when H satisﬁes that deﬁnition. They
then claim, without proof, that the hash function H(x, i) =
π(2x ⊕ i) ⊕ 2x ⊕ i satisﬁes their deﬁnition. It is not clear to
us that this is the case (but see footnote 5).
In this section, we revisit the assumption needed to prove