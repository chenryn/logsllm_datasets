 2020-01-07 00:00:00+01 |    2 | {1,2,2,2,2} | {1,2}
 2020-01-08 00:00:00+01 |    2 | {2,2,2,2,2} | {2}
 2020-01-09 00:00:00+01 |    2 | {2,2,2,2,2} | {2}
 2020-01-10 00:00:00+01 |    2 | {2,2,2,2,2} | {2}
 2020-01-11 00:00:00+01 |    2 | {2,2,2,2,3} | {2,3}
 2020-01-12 00:00:00+01 |    2 | {2,2,2,3,3} | {2,3,3}
 2020-01-13 00:00:00+01 |    3 | {2,2,3,3,3} | {2,2,3}
 2020-01-14 00:00:00+01 |    3 | {2,3,3,3}   | {2,3}
 2020-01-15 00:00:00+01 |    3 | {3,3,3}     | {3}
(14 rows)
test=# SELECT   day, week, 
        array_agg(week) OVER (ORDER BY week, day ROWS
                BETWEEN 2 PRECEDING AND 2 FOLLOWING EXCLUDE TIES) AS ties
FROM    t_demo;
          day           | week |    ties     
------------------------+------+-------------
 2020-01-02 00:00:00+01 |    1 | {1,1,1}
 2020-01-03 00:00:00+01 |    1 | {1,1,1,1}
 2020-01-04 00:00:00+01 |    1 | {1,1,1,1,2}
 2020-01-05 00:00:00+01 |    1 | {1,1,1,2,2}
 2020-01-06 00:00:00+01 |    2 | {1,1,2,2,2}
 2020-01-07 00:00:00+01 |    2 | {1,2,2,2,2}
 2020-01-08 00:00:00+01 |    2 | {2,2,2,2,2}
 2020-01-09 00:00:00+01 |    2 | {2,2,2,2,2}
 2020-01-10 00:00:00+01 |    2 | {2,2,2,2,2}
 2020-01-11 00:00:00+01 |    2 | {2,2,2,2,3}
 2020-01-12 00:00:00+01 |    2 | {2,2,2,3,3}
 2020-01-13 00:00:00+01 |    3 | {2,2,3,3,3}
 2020-01-14 00:00:00+01 |    3 | {2,3,3,3}
 2020-01-15 00:00:00+01 |    3 | {3,3,3}
(14 rows)
test=# SELECT   *, 
        array_agg(week) OVER (ORDER BY week ROWS
                                BETWEEN 2 PRECEDING 
            AND 2 FOLLOWING EXCLUDE GROUP) AS week,
        array_agg(week) OVER (ORDER BY day ROWS
                                BETWEEN 2 PRECEDING 
            AND 2 FOLLOWING EXCLUDE GROUP) AS all
FROM    t_demo;
 ordinality |          day           | week | week  |    all   
------------+------------------------+------+-------+-----------
          1 | 2020-01-02 00:00:00+01 |    1 |       | {1,1}
          2 | 2020-01-03 00:00:00+01 |    1 |       | {1,1,1}
          3 | 2020-01-04 00:00:00+01 |    1 | {2}   | {1,1,1,2}
          4 | 2020-01-05 00:00:00+01 |    1 | {2,2} | {1,1,2,2}
          5 | 2020-01-06 00:00:00+01 |    2 | {1,1} | {1,1,2,2}
          6 | 2020-01-07 00:00:00+01 |    2 | {1}   | {1,2,2,2}
          7 | 2020-01-08 00:00:00+01 |    2 |       | {2,2,2,2}
          8 | 2020-01-09 00:00:00+01 |    2 |       | {2,2,2,2}
          9 | 2020-01-10 00:00:00+01 |    2 |       | {2,2,2,2}
         10 | 2020-01-11 00:00:00+01 |    2 | {3}   | {2,2,2,3}
         11 | 2020-01-12 00:00:00+01 |    2 | {3,3} | {2,2,3,3}
         12 | 2020-01-13 00:00:00+01 |    3 | {2,2} | {2,2,3,3}
         13 | 2020-01-14 00:00:00+01 |    3 | {2}   | {2,3,3}
         14 | 2020-01-15 00:00:00+01 |    3 |       | {3,3}
(14 rows)
test=# SELECT   *, 
        array_agg(DISTINCT week) OVER (ORDER BY day ROWS
                                BETWEEN 2 PRECEDING AND 2 FOLLOWING)
FROM    t_demo;
ERROR:  DISTINCT is not implemented for window functions
LINE 2:  array_agg(DISTINCT week) OVER (ORDER BY day ROWS
test=# SELECT  *, (SELECT array_agg(DISTINCT unnest) FROM unnest(x)) AS b
FROM
(
        SELECT  *, 
                array_agg(week) OVER (ORDER BY day ROWS
                        BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS x
        FROM    t_demo
) AS a;
 ordinality |          day           | week |      x      |   b   
------------+------------------------+------+-------------+-------
          1 | 2020-01-02 00:00:00+01 |    1 | {1,1,1}     | {1}
          2 | 2020-01-03 00:00:00+01 |    1 | {1,1,1,1}   | {1}
          3 | 2020-01-04 00:00:00+01 |    1 | {1,1,1,1,2} | {1,2}
          4 | 2020-01-05 00:00:00+01 |    1 | {1,1,1,2,2} | {1,2}
          5 | 2020-01-06 00:00:00+01 |    2 | {1,1,2,2,2} | {1,2}
          6 | 2020-01-07 00:00:00+01 |    2 | {1,2,2,2,2} | {1,2}
          7 | 2020-01-08 00:00:00+01 |    2 | {2,2,2,2,2} | {2}
          8 | 2020-01-09 00:00:00+01 |    2 | {2,2,2,2,2} | {2}
          9 | 2020-01-10 00:00:00+01 |    2 | {2,2,2,2,2} | {2}
         10 | 2020-01-11 00:00:00+01 |    2 | {2,2,2,2,3} | {2,3}
         11 | 2020-01-12 00:00:00+01 |    2 | {2,2,2,3,3} | {2,3}
         12 | 2020-01-13 00:00:00+01 |    3 | {2,2,3,3,3} | {2,3}
         13 | 2020-01-14 00:00:00+01 |    3 | {2,3,3,3}   | {2,3}
         14 | 2020-01-15 00:00:00+01 |    3 | {3,3,3}     | {3}
(14 rows)
```
## 窗口查询用法和业务场景举例    
### 窗口查询SQL用法    
1、查询与每门成绩第一名相差几分    
```    
select     
  *,     
  first_value(score) over w1 - score    
from t     
  window w1 as (partition by sub order by score desc)     
order by sub,score desc;    
 sid | sub | des  | score | ?column?     
-----+-----+------+-------+----------    
   4 |   1 | 语文 |   100 |        0    
   3 |   1 | 语文 |    99 |        1    
   7 |   1 | 语文 |    90 |       10    
   6 |   1 | 语文 |    89 |       11    
   1 |   1 | 语文 |    81 |       19    
   2 |   1 | 语文 |    71 |       29    
   5 |   1 | 语文 |    32 |       68    
   7 |   2 | 数学 |   100 |        0    
   6 |   2 | 数学 |    97 |        3    
   2 |   2 | 数学 |    96 |        4    
   4 |   2 | 数学 |    90 |       10    
   1 |   2 | 数学 |    81 |       19    
   3 |   2 | 数学 |    78 |       22    
   5 |   2 | 数学 |    12 |       88    
   1 |   3 | 英语 |   100 |        0    
   2 |   3 | 英语 |    95 |        5    
   3 |   3 | 英语 |    95 |        5    
   4 |   3 | 英语 |    95 |        5    
   7 |   3 | 英语 |    93 |        7    
   6 |   3 | 英语 |    87 |       13    
   5 |   3 | 英语 |    56 |       44    
   7 |   4 | 物理 |    71 |        0    
   6 |   4 | 物理 |    71 |        0    
   3 |   4 | 物理 |    65 |        6    
   4 |   4 | 物理 |    65 |        6    
   5 |   4 | 物理 |    65 |        6    
   1 |   4 | 物理 |    60 |       11    
   2 |   4 | 物理 |    60 |       11    
(28 rows)    
```    
2、查询每门成绩排行，并列时，消耗计数    
```    
select     
  *,     
  rank() over w1     
from t     
  window w1 as (partition by sub order by score desc)     
order by sub,score desc;    
 sid | sub | des  | score | rank     
-----+-----+------+-------+------    
   4 |   1 | 语文 |   100 |    1    
   3 |   1 | 语文 |    99 |    2    
   7 |   1 | 语文 |    90 |    3    
   6 |   1 | 语文 |    89 |    4    
   1 |   1 | 语文 |    81 |    5    
   2 |   1 | 语文 |    71 |    6    
   5 |   1 | 语文 |    32 |    7    
   7 |   2 | 数学 |   100 |    1    
   6 |   2 | 数学 |    97 |    2    
   2 |   2 | 数学 |    96 |    3    
   4 |   2 | 数学 |    90 |    4    
   1 |   2 | 数学 |    81 |    5    
   3 |   2 | 数学 |    78 |    6    
   5 |   2 | 数学 |    12 |    7    
   1 |   3 | 英语 |   100 |    1    
   2 |   3 | 英语 |    95 |    2    
   3 |   3 | 英语 |    95 |    2    
   4 |   3 | 英语 |    95 |    2    
   7 |   3 | 英语 |    93 |    5    
   6 |   3 | 英语 |    87 |    6    
   5 |   3 | 英语 |    56 |    7    
   7 |   4 | 物理 |    71 |    1    
   6 |   4 | 物理 |    71 |    1    
   3 |   4 | 物理 |    65 |    3    
   4 |   4 | 物理 |    65 |    3    
   5 |   4 | 物理 |    65 |    3    
   1 |   4 | 物理 |    60 |    6    
   2 |   4 | 物理 |    60 |    6    
(28 rows)    
```    
3、查询与总分前一名的同学的单门分差    
```    
select     
  *,     
  coalesce(lag(score) over w1, score) - score    
from     
(    
select t.*,t1.rn from t join    
(    
  select sid, row_number() over(order by sum desc) as rn from (select sid,sum(score) from t group by sid) t    
) t1     
using (sid)    
) t     
  window w1 as (partition by sub order by rn)     
order by sub,rn;    
 sid | sub | des  | score | rn | ?column?     
-----+-----+------+-------+----+----------    
   7 |   1 | 语文 |    90 |  1 |        0    
   4 |   1 | 语文 |   100 |  2 |      -10    
   6 |   1 | 语文 |    89 |  3 |       11    
   3 |   1 | 语文 |    99 |  4 |      -10    
   2 |   1 | 语文 |    71 |  5 |       28    
   1 |   1 | 语文 |    81 |  6 |      -10    
   5 |   1 | 语文 |    32 |  7 |       49    
   7 |   2 | 数学 |   100 |  1 |        0    
   4 |   2 | 数学 |    90 |  2 |       10    
   6 |   2 | 数学 |    97 |  3 |       -7    
   3 |   2 | 数学 |    78 |  4 |       19    
   2 |   2 | 数学 |    96 |  5 |      -18    
   1 |   2 | 数学 |    81 |  6 |       15    
   5 |   2 | 数学 |    12 |  7 |       69    
   7 |   3 | 英语 |    93 |  1 |        0    
   4 |   3 | 英语 |    95 |  2 |       -2    
   6 |   3 | 英语 |    87 |  3 |        8    
   3 |   3 | 英语 |    95 |  4 |       -8    
   2 |   3 | 英语 |    95 |  5 |        0    
   1 |   3 | 英语 |   100 |  6 |       -5    
   5 |   3 | 英语 |    56 |  7 |       44    
   7 |   4 | 物理 |    71 |  1 |        0    
   4 |   4 | 物理 |    65 |  2 |        6    
   6 |   4 | 物理 |    71 |  3 |       -6    
   3 |   4 | 物理 |    65 |  4 |        6    
   2 |   4 | 物理 |    60 |  5 |        5    
   1 |   4 | 物理 |    60 |  6 |        0    
   5 |   4 | 物理 |    65 |  7 |       -5    
(28 rows)    
```    
4、查询每3个相邻分组的分数平均值，SUM值，COUNT值。    
需要使用group的帧语法，order by中每簇相同表达式的值，或者列的值，表示一个peer group。    
```    
select     