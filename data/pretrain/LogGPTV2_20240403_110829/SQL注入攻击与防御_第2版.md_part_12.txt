WHERE name=*dickens
从上面的SQL代码可以看到，该应用程序并没有对从变量name中接收到的值进行任何检
验。因此，下面的请求将使PostgreSQL数据库产生一个错误：
http://www.victim. com/1ist_author-php?name=*
对于上面这个请求，PostgreSQL数据库将返回如下所示的一个错误：
Query failed: ERROR: unterminated quoted string at or near "'"
对于其他情况，当SQL代码由于其他原因执行失败时—比如由于开始或结束的圆括号、
子查询等原因，PostgreSQL数据库将返回一个常规错误：
Query failed: ERROR: syntax error at or near "=
对于PostgreSQL开发，另外一种常见的配置是充分利用PostgreSQLJDBCDriver，当在Java
项目中编写代码时就是采用这种方式。在这种方式下，从PostgreSQL数据库返回的错误与上
面介绍的错误信息非常类似，此外还包含了一些Java的函数信息：
org.postgresql.util.PSQLException: ERRoR: unterminated quoted string at
or near =*\* "
at org-postgresql core.v3.QueryExecutorImp1.receiveErrorResponse (Query
ExecutorImpl - java:1512)
org.postgresq] ,core,v3.QueryExecutorImpl processResults (Query
ExecutorImp1 - java:1297)
at org-postgresql.core.v3.QueryExecutorImpl.execute (QueryExecutorImpl
(88T:eAe [
at org-postgresql . jdbc2.AbstractJdbc2Statement.
execute (AbstractJdbc2Statement . java: 430)
at org-postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags
(AbstractJdbc2Statement , java :332)
at org-postgresq] - jdbc2.AbstractJdbc2Statement.executeQuery
(AbstractJdbc2Statement . java :231)
at org-postgresq] .jdbc2.AbstractJdbc2DatabaseMetaData.getTables
[AbstractJdbc2DatabaseMetaData. java: 2190)
上面的代码就是当PostgreSQLJDBCDriver处理缺少结束引号的字符串时返回的错误信息。
注意：
并不存在真正完美的规则可以确定某个输入是否会融发SQL注入漏润，因为存在无数种
可能的情况
38
---
## Page 53
第2章SQL注入测试
侦查潜在的SQL注入时，必须坚持不解并留心细节信息，这一点非常重要，建议使用Web
代理，因为Web浏览器会隐藏诸如HTML源代码、HTTP重定向等细节信息。此外，在底层
工作和查看HTML源代码时，可能会发现SQL注入外的其他漏洞。
2.2.3应用程序的响应
上一节介绍了当后台数据库执行查询失败时应用通常会返回的错误类型。如果您看到了这
样的错误，那么您就能非常肯定该应用易受到某种SQL注入攻击。不过，由于应用收到数据
库错误时会做不同的处理，因此有时识别SQL注入漏润并不像前面介绍的那么容易。本节将
介绍一些不直接在测览器中显示错误的示例，它们代表不同的复杂度。
寻找SQL注入漏润的过程包括识别用户数据输入、操纵发送给应用的数据以及识别服务
器返回结果中的变化。请记住，操纵参数产生的错误可能与SQL注入无关。
常见错误
刚才介绍了从数据库返回的典型错误。根据当时的情况，我们很容易判断出参数是否易受到
SQL注入攻击。但对于其他情况，不管遇到何种错误，应用程序均返回一个通用的错误页面。
如图 2-6 所示。
全
Server Error in 7 Application
图2-6默认的ASPNET 错误页面
这是个常见页面。当应用未对错误进行处理且服务器又没有配置自定义的错误页面时，便
会出现该页面。前面讲过，该行为取决于web.config文件的设置。
39
---
## Page 54
SQL注入攻击与防御（第2版）
如果测试Web站点时发现应用始终返回默认或自定义的错误页面，就需要弄清该错误是不
是由SQL注入引发的。可以通过向参数中插入不会触发应用错误的SQL代码来进行测试。
在上述例子中，可以假设SQL查询与下面的内容相似：
SELECT *
FROM products
WHERE category=′[attacker′s control] '
注入attacker很明显会产生错误，因为末尾增加了多余的单引号，这导致该SQL语句出错：
SELECT *
FROM products
WHERE category='attacker''
可以尝试注入不会产生错误的内容。通常这是个反复训练且不断摸索的过程。在本例中要
记住，我们正在尝试将数据注入一个用单引号引起来的字符串中。
如果注入像bikes”orT'=T这样的内容，会产生什么结果呢？最终的SQL语句如下所示：
SELECT *
FROM products
/. sx1 Te suzex  returns no rows */
上述语句不会返回任何结果，因为WHERE子句中的最后一个条件永远不会成立。但是请
记住，事情不总是像这些例子介绍的这么简单。如果注入了一个永假条件，但是应用却返回了
40
---
## Page 55
第2章SQL注入测试
结果，那么也不要惊讶，因为很多原因会引发这种情况。例如：
/* Select all */
FROM products
/*products */
WHERE category='bikes′ AND '1'-′2'
/* false condition */
UNION SELECT *
/* append al1 new_products */
FROM new_products
/* to the previous result set */
本例将两个查询结果合并到一起并作为结果返回。如果注入参数只影响了查询的一部分，
那么即便攻击者注入一个永假条件，也还是会收到结果。后面的2.3.3节“终止式SQL注入”
会介绍注释其他查询时用到的技术。
HTTP代码错误
HTTP包含很多返回给Web浏览器的代码，它们被用来指定请求的结果或客户端需要执行
的操作。
最常见的HTTP返回代码是HTTP200，它表示请求已成功接收。检测SQL注入漏洞时需
要熟悉两个错误代码。第一个是HTTP500代码：
HTTP/1.1 500 Internal Server Error
Date: Mon, 05 Jan 2009 13:08:25 GMT
Server: Microsoft-IIs/6.0
XPowered-By: ASP.NET
XAspNet-Version: 1.1.4322
Cache-Control: private
Content-Type: text/html; charset=utf-8
Content-Length: 3026
[HTML content]
Web服务器在呈现请求的Web源时，如果发现错误，便会返回HTTP500。很多情况下SQL
错误都是以HTTP500错误代码形式返回给用户的。除非使用代理捕获Web服务器的响应，否
则返回的HTTP代码将是透明的。
当发现错误时，有些应用会采取另一种比较常见的处理方式：重定向到首页或自定义错误
页面。可通过HTTP302重定向代码来实现该操作：
HTTP/1.1 302 Found
Connection: Keep-A1ive
Content-Length: 159
Date: Mon, 05 Jan 2009 13:42:04 GMT
Location: /index.aspx
Content-Type: text/html; charset=utf-8
Server:*Microsoft-IIs/6.0
XPowered-By: ASP.NET
X-AspNet-Version: 2.0.50727
Cache-Control: private
0bject moved
'xu ou qo(qo<>
41
---
## Page 56
SQL注入攻击与防御（第2版）
上述例子将用户重定向到首页。302响应始终包含Location字段，该字段指明Web浏览器
应该重定向到的目的地。前面讲过，Web浏览器负责处理该操作，除非使用Web代理拦截Web
服务器的响应，否则该操作对用户将是透明的。
在操纵发送给服务器的参数时收到HTTP500或HTTP302响应会是个好现象，因为这意
味着我们已经以某种方式干预了应用的正常行为。接下来的步骤是构思有意义的注入，稍后的
2.3节“确认SQL注入”会作具体讲解。
不同大小的响应
每个应用都会对用户发送的输入进行不同的处理，有时很容易识别应用中的异常，面有时
则很难识别。尝试寻找SQL注入漏洞时，哪怕是最轻微、最细小的变化也需要考虑。
在显示SELECT语句结果的脚本中，通常很容易区分合法请求与SQL注入行为间的差异。
但现在我们考虑的是那些不显示任何结果或差异不明显、不容易引起注意的脚本。这就是接下
来的例子所要说明的情况，如图2-7所示。
1910(20.54M/1) -FA
ng to 
图2-7响应不一致
在图2-7中，示例包含了两个不同的请求。测试是根据tracking.asp页面中的idvisitor参数
来进行的，该页面用于跟踪访问Web站点http://www.victim.com的访客。示例中的脚本只是为
idvisitor变量指定的访客更新数据库，如果发生SQL错误，就会捕获异常并将响应返回给用户。
由于编程方式存在差异，最终的响应会稍有不同。
类似的例子还包括根据用户参数加载的较小的Web界面元素（如商品标签）。当发生SQL错
误时，通常很容易忽视较小的界面元素。虽然看起来是个很小的错误，但借助SQL盲注(blindSQL
injection）技术，我们可以有很多方法来利用这种错误，2.2.4节及第5章会详细介绍SQL盲注技术。
2.2.4SQL盲注
Web应用访问数据库有很多目的。常见的目的是访间信息并将其呈现给用户。在这种情况
42
---
## Page 57
第2章SQL注入测试
下，攻击者可能会修改SQL语句并显示数据库中的任意信息，将这些信息写入Web服务器对
HTTP请求的响应之中。
有时不可能显示数据库的所有信息，但并不代表代码不会受到SQL注入攻击。这意味着
寻找及利用漏洞会稍有不同。请思考下面的例子。
Victim公司允许用户通过http://www.victim.com/authenticate.aspx页面上的身份验证表单登
录到Web站点。身份验证表单要求用户输入用户名和口令。如果任意地输入用户名和口令，
那么结果页面会显示“Invalid usermame orpassword”消息。这是可以预料到的结果。但如果输
入user'or7=7作为用户名，就会显示图2-8所示的错误。
图2-8展示了Victim公司身份验证系统的一个缺陷。应用程序收到有效的用户名后会显示
不同的错误消息，进一步讲，usemame字段看起来易受SQL注入攻击。
BeEan yneHgory
Invalid password
Fser er ?'2
Send_
Fo
图2-8SQL盲注示例-永真
发现这种情况后，可注入一个永假条件并检查返回值的差异，这对进一步核实usemame
字段是否易受SQL注入攻击来说非常有用，如图2-9所示。
Invalid username or password
uer' and T2
PAS
图2-9SQL盲注示例-永假
43
---
## Page 58
SQL注入攻击与防御（第2版）
做完永假测试后，可以确认usermame字段易受到SQL注入攻击。但password字段不易受
到攻击，面且无法绕过身份验证表单。
该表单没有显示数据库的任何数据。我们只知道两件事
·usemame条件为真时，表单显示“Invalid password”。
·usermame 条件为假时，表单显示“Invalid usermame or password”。
这种情况被称为SQL盲注。第5章将专门讲解SQL盲注攻击技术。
SQL盲注是一种SQL注入漏洞，攻击者可以操纵SQL语句，应用会针对真假条件返回不
同的值。但是攻击者无法检索查询结果。