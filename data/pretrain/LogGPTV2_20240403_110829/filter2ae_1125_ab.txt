在发送请求前代码会对url进行解析。如果传入url的值匹配了10.0.0.*，服务器将返回403禁止响应。下面是一些绕过办法：
    - 使用十进制的IP地址_http://167772162_替代_http://10.0.0.2_
    - 创建指向10.0.0.2的A记录，使用子域名
    - 使用上述的重定向方式。
使用重定向访问 __ ，你的第一个请求将发往到你所控制的服务器。从服务器上，你被重定向至
__
。这个方式将绕过代码层面的风险管控防护，因为参数已经抵达open函数。如果在上述代码启用了黑名单策略，绕过难度将成陡坡增加，因为你不得不站在开发的角度去思考所有的绕过方式，有时候这又是必要的。如果像下面的代码那样使用了白名单策略，那就需要尝试从白名单主机中找到存在的重定向漏洞。这些有助于你可以进入站点的内部网络。重定向在突破端口、主机、路径和协议方面的限制非常有用。
        require 'sinatra'
        require 'open-uri'
        get '/' do
          url = URI.parse params[:url]
          halt 403 unless url.host == 'web-server.com'
          format 'RESPONSE: %s', open(params[:url]).read
        end
以下五个功能点不分排名先后比较容易出现SSRF漏洞：
    1. web钩子：寻找触发特定事件时发出http请求的服务。在大多数web钩子的功能中，终端用户可以选择他们的终端点和主机名。尝试向内部服务发送http请求。
    2. PDF生成器：试着注入指向内部服务的`,,`或者``元素或者CSS的`url()`函数。
    3. 文档解析器：尝试了解文档是如何被解析的。如果是XML文档，那就是用了PDF生成器方法。对于其他文档，检查是否存在引用外部资源的方法然后通过服务器向内部服务发送请求。
    4. 链接扩展: 最近Mark Litchfield在推特扩展链接上发现了漏洞，名声大涨。[链接在这][3]
    5. 文件上传：与常规上传文件相反，尝试发送url请求然后检查是否下载了url的内容。[例子在这][4]
# 影响
因为web服务器能够访问admin-panel，且处于同一个网络，也不存在防火墙规则限制。攻击者便能收集更多的网络信息和访问服务器和服务。这就是一个常规性的SSRF漏洞。不是所有的SSRF漏洞都将返回响应给攻击者，这种情况就是blind
SSRF了。下面是示例：
        require 'sinatra'
        require 'open-uri'
        get '/' do
          open params[:url]
          'done'
        end
这段代码与文中的第一个代码示例的不同之处在于服务器对传给url的任意值处理方式，服务器总是将url值作为新请求的目的地址并只返回字符串done给攻击者。如果遇到这种情况，利用SSRF进行端口扫描和服务探测的效果将大打折扣（具体情况如下）。
## 暴露内网/防火墙后的系统
SSRF漏洞的诠释就是发现了公网无法访问的系统。无论什么时候你想这么做，牢记程序策略，不要越界。如果你想找到内网服务，下面是一份IPv4的私网地址，能够为你提供服务：
    - 10.0.0.0/8
    - 127.0.0.1/32
    - 172.16.0.0/12
    - 192.168.0.0/16
**技巧**
：尝试寻找不同响应的时间差，这样才有可能发现网络是否在内部路由。无路由的网络流量通常会被路由器立即丢弃（可以通过响应时间上一点点的增加来观察）。内部防火墙策略会引起路由网络流量的RTT时间的增加。另外请记住交换机和路由器通常会启用http和ssh服务，所以首先在.1和.254地址上的22、80、443、8080和8443端口上进行尝试更易于取得成效的。
## 服务探测和端口扫描
某些时候SSRF漏洞可以用作局域网内的端口扫描。这有助于理清内网的基础设施轮廓和并为下一步其他漏洞的利用做铺垫。上述这种情况通常是最简单的blind
SSRF了。如果之前的脚本无法建立连接或收不到服务器响应，异常将被抛出。利用这个特征可以识别端口是否开放（连接建立）或关闭（连接失败或超时）。
 URL参数 状态码 RTT 结论 [http://127.0.0.1:22
&nbsp](http://127.0.0.1:22 &nbsp); 200 10ms 端口开放 [http://127.0.0.1:22
&nbsp](http://127.0.0.1:22 &nbsp); 500 10ms 端口关闭 [http://10.0.0.1/
&nbsp](http://10.0.0.1/     &nbsp); 500 30010ms 防火墙或流量不可达
 500 10ms 端口关闭流量可达 
对于开放和关闭的端口，每个SSRF响应都不同。试着以不同的响应为基础建立一个开放、闭合端口和标志符之间的映射。上面的表格就是一个例子。
## 提取EC2配置文件
这是我最喜欢的技巧之一。越来越多的公司将部分基础设施放到亚马逊的EC2服务器上。亚马逊公开内部服务，每台EC实例都能查询主机元数据。[这是AWS文档](&nbsp;&nbsp;&nbsp;&nbsp;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)。如果你在EC2上发现了SSRF漏洞，试着请求 __ 。响应会提供许多有用的信息便于对基础设施有一定的了解，甚至可能会泄漏亚马逊S3的访问token，API token等等。你也可以下载_
# 核心
正如你所猜想的那样，不是所有SSRF漏洞都是用HTTP协议。有些时候，可以通过重定向指向一个不同的协议或者交换机协议。在Redis队列推送异步作业的场景下，如果能由应用使用_gopher://protocol_去执行代码，这将是SSRF升级成远程代码执行的关键。Redis大多数实例不使用任何形式的授权认证，这种方式非常方便。
在此期间，关键点总是来自于发现了的内部服务，这将扩大漏洞的影响范围。比如当你发现了未授权的admin面板。如果程序允许，想想你将如何使用内部服务将多个漏洞综合利用提高发现漏洞的影响范围。
愉快的黑客吧！
Jobert
此外-本文描述的许多技术都可以使用我的github上的[仓库](&nbsp;&nbsp;&nbsp;&nbsp;https://github.com/jobertabma/ground-control)进行调试。去看看吧；欢迎公关。
[原文在这][1]
[1]: 
"How To: Server-Side Request Forgery (SSRF)"