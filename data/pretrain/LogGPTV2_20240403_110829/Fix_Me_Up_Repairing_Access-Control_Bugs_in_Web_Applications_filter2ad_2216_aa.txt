title:Fix Me Up: Repairing Access-Control Bugs in Web Applications
author:Sooel Son and
Kathryn S. McKinley and
Vitaly Shmatikov
Fix Me Up: Repairing Access-Control Bugs in Web Applications
Sooel Son†
Kathryn S. McKinley†∗
Vitaly Shmatikov†
†The University of Texas at Austin
∗Microsoft Research
{samuel,mckinley,shmat}@cs.utexas.edu
Abstract
Access-control policies in Web applications ensure that
only authorized users can perform security-sensitive oper-
ations. These policies usually check user credentials be-
fore executing actions such as writing to the database or
navigating to privileged pages. Typically, every Web ap-
plication uses its own, hand-crafted program logic to en-
force access control. Within a single application, this logic
can vary between different user roles, e.g., administrator
or regular user. Unfortunately, developers forget to include
proper access-control checks, a lot.
This paper presents the design and implementation of
FIXMEUP, a static analysis and transformation tool that
ﬁnds access-control errors of omission and produces can-
didate repairs. FIXMEUP starts with a high-level speciﬁ-
cation that indicates the conditional statement of a correct
access-control check and automatically computes an inter-
procedural access-control template (ACT), which includes
all program statements involved in this instance of access-
control logic. The ACT serves as both a low-level policy
speciﬁcation and a program transformation template. FIX-
MEUP uses the ACT to ﬁnd faulty access-control logic that
misses some or all of these statements, inserts only the miss-
ing statements, and ensures that unintended dependences
did not change the meaning of the access-control policy.
FIXMEUP then presents the transformed program to the de-
veloper, who decides whether to accept the proposed repair.
Our evaluation on ten real-world PHP applications
shows that FIXMEUP is capable of ﬁnding subtle access-
control bugs and performing semantically correct repairs.
Introduction
1
Modern Web-based software, such as e-commerce appli-
cations, blogs, and wikis, typically consists of client-side
scripts running in a Web browser and a server-side program
that (1) converts clients’ requests into queries to a back-
end database and (2) returns HTML content. Because any
Internet user can invoke the server, application developers
must ensure that unauthorized users cannot reach database
queries, administrator functionality, pages with conﬁdential
or paid content, and other privileged operations.
Developers usually program access-control logic from
scratch because there is no standard framework for imple-
menting access control in Web applications. Access-control
logic is often fairly sophisticated, spread over multiple func-
tions, with different checks performed for different user
roles [32, 36]. The scripting language of choice for server-
side applications is PHP [27, 28]. In PHP, a network user
can directly invoke any program ﬁle by providing its name
as part of a URL. This feature introduces unintended entry
points into programs and permits “forced browsing,” where
a user navigates to pages without following the intended
pattern and therefore bypasses access-control checks. As a
consequence, incorrectly implemented access-control vul-
nerabilities occur prominently in the OWASP Top 10 Ap-
plication Security Risks [24]. For example, all but one of
the ten real-world PHP applications analyzed in this paper
contain access-control vulnerabilities.
Whereas ﬁnding bugs is now a mature area, repairing
them is a much harder problem and only recently has some
progress been made on semi-automated methods for soft-
ware repair. Static repair techniques can now ﬁx viola-
tions of simple local patterns that need only one- or two-
line edits [14, 25], or ﬁnd one- or two-line changes that
pass unit tests [41], or perform user-speciﬁed transforma-
tions within a single method [1, 19]. None of these tech-
niques address interprocedural bugs. Several recent meth-
ods ﬁnd access-control bugs using interprocedural analy-
sis [32, 36] but how to repair them has been an open prob-
lem. A key issue for repairing these bugs is that many, but
not all of the statements implementing the access-control
logic are often already present in the vulnerable code. None
of the prior patch, transformation, refactoring, or repair al-
gorithms check if the statements are already present in the
target of transformation.
We design and implement a static analysis and program
transformation tool called FIXMEUP. FIXMEUP ﬁnds vi-
olations of access-control policies, produces candidate re-
pairs, eliminates repairs that incorrectly implement the pol-
icy, and suggests the remaining repairs to developers.
As input, FIXMEUP takes an access-control check, i.e.,
a conditional statement that determines whether or not
some security-sensitive operation executes. These checks,
marked by the developer or inferred by static analysis [32],
serve as the high-level speciﬁcation of the access-control
policy. Our analysis computes interprocedural control and
data dependences of the check, extracting an interproce-
dural slice containing all program statements that imple-
ment the access-control logic. FIXMEUP creates an access-
control template (ACT) from these statements. The ACT
serves both as a low-level policy speciﬁcation and a pro-
gram transformation template. FIXMEUP then uses the
ACT to (1) ﬁnd security-sensitive operations not protected
by appropriate access-control logic; (2) transform the pro-
gram by inserting only the missing logic into the vulner-
able calling contexts, while preserving the statements and
dependences already present; and (3) verify the transforma-
tion did not accidentally introduce unwanted dependences,
changing the semantics of the inserted policy.
We evaluate FIXMEUP on ten real-world Web appli-
cations varying in size from 1,500 to 100,000+ lines of
PHP code. We chose these benchmarks because (i) prior
work used them to specify and/or infer access-control poli-
cies [32, 36]; (ii) they contain known access-control bugs
that FIXMEUP ﬁnds and repairs; and (iii) they demonstrate
the scalability of FIXMEUP.
FIXMEUP found 38 access-control bugs and correctly
repaired 30 of them. We conﬁrmed all bugs and repairs by
hand and with experimental testing on attack inputs. In par-
ticular, FIXMEUP found and repaired 5 bugs in two bench-
marks that prior analysis of the same code missed [36]. In
7 cases, the inserted access-control check was added to an
existing, alternative check.
In one case, our repair vali-
dation procedure automatically detected an unwanted con-
trol dependence and issued a warning. In 28 cases, FIX-
MEUP detected that vulnerable code already contained one
or more, but not all, of the statements prescribed by the
access-control template and adjusted the repair accordingly.
This result shows that detecting which parts of the access-
control logic are already present and correct is critical to re-
pairing access-control vulnerabilities. No prior program re-
pair or transformation approach detects whether the desired
logic is already present in the program [1, 14, 19, 25, 41].
FIXMEUP guarantees that the repaired code implements
the same access-control policy as the template, but it cannot
guarantee that the resulting program is “correct.” For ex-
ample, FIXMEUP may apply the policy to a context where
the developer did not intend to use it, or the repair may in-
troduce an unwanted dependence into the program (adding
an access-control check always changes the program’s con-
trol ﬂow). Static analysis in FIXMEUP is neither sound,
nor complete because it does not consider language features
such as dynamic class loading, some external side effects,
or eval. The developer should examine the errors found by
FIXMEUP and the suggested repairs.
Using automated program analysis tools for veriﬁcation
and bug ﬁnding is now a well-established approach that
helps programmers discover errors and improve code qual-
ity in large software systems. No prior tool, however, can
repair access-control errors of omission. These errors may
appear relatively simple, but our analysis shows that they
are common in Web applications. FIXMEUP is a new tool
that can help Web developers repair common access-control
vulnerabilities in their applications.
2 Overview of our approach
FIXMEUP starts with a high-level speciﬁcation of the
access-control policy. A policy prescribes one or more
access-control checks on execution paths leading to sensi-
tive operations, such as database queries, links to privileged
pages, operations that rewrite cookies and delete ﬁles. Sen-
sitive operations must be speciﬁed in advance. If the checks
fail, the program does not execute the sensitive operations.
Because access-control logic varies between different user
roles and entry points within the same application [32, 36],
different paths may require different checks or no checks at
all. Access-control logic in Web applications is often inter-
procedural and context-sensitive.
FIXMEUP is agnostic about the source of the policy and
works equally well with user-speciﬁed policies and with
policies inferred by program analysis. Our focus in this pa-
per is on program repair and not on the orthogonal problem
of policy speciﬁcation or inference.
For simplicity, assume that the high-level policy is speci-
ﬁed explicitly by the developer who adds annotations to the
PHP source code marking (1) access-control checks, (2) the
protected sensitive operation, and (3) a tag indicating the
user role to which the policy applies (e.g., root, admin, or
blog poster). Section 3 presents examples of speciﬁcations
and policies. FIXMEUP assumes that each high-level pol-
icy applies throughout the indicated user role.
FIXMEUP uses this speciﬁcation to compute an access-
control template (ACT). FIXMEUP starts with the con-
ditional statement performing the correct access-control
check and computes all methods and statements in its back-
ward, interprocedural slice. Given this slice, FIXMEUP
builds an interprocedural, hierarchical representation of all
statements in the check’s calling context on which the check
depends. The ACT is both a low-level policy speciﬁcation
and a program transformation template.
To ﬁnd missing access-control checks, FIXMEUP looks
at every calling context in which a sensitive operation may
be executed and veriﬁes whether the access-control logic
present in this context matches the ACT for the correspond-
ing role. Of course, FIXMEUP cannot decide general se-
mantic equivalence of arbitrary code fragments. In practice,
the access-control logic of Web applications is usually very
stylized and located close to the program entry points. The
resulting templates are loop-free, consist of relatively few
statements, and have simple control and data dependences
(see Table 2). A few statements may have side effects on the
global variables, such as opening database connections and
initializing session state. For example, a typical Web appli-
cation may open the database once and then permit only the
authorized users to store into the database; these stores may
be sprinkled throughout the application.
FIXMEUP generates candidate repairs by replicating the
access-control logic in program contexts where some or all
of it is missing.
If FIXMEUP ﬁnds a vulnerable context
that permits execution of some sensitive operation with-
out an access-control check, it transforms the context using
the access-control template. This transformation ﬁnds and
reuses statements already present in the vulnerable code and
only inserts the statements from the template that are miss-
ing. The repair procedure uses and respects all control and
data dependences between statements.
To ensure that the reused statements do not change the
meaning of the inserted policy, FIXMEUP computes a fresh
template starting from the access-control check and matches
If the templates do not
it against the original template.
match, FIXMEUP issues a warning.
If they match, FIX-
MEUP provides the transformed code to the developer as
the suggested repair.
3 Access-Control Policies
Access control is the cornerstone of Web-application secu-
rity. Several of the OWASP Top 10 Application Security
Risks [24] are access-control bugs: broken authentication
and session management, insecure direct object references,
and failure to restrict URL accesses. Access-control bugs
can expose other types of vulnerabilities, too.
3.1 Examples of correct policies and bugs
In general, an access-control policy requires some checks
prior to executing security-sensitive operations. Web appli-
cations frequently implement multiple user roles. For ex-
ample, an online store may have customers and administra-
tors, while a blogging site may have blog owners, publish-
ers, and commenters. Access-control policies are thus role-
sensitive. Different calling contexts associated with differ-
ent user roles often require different checks.
Figures 1 and 2 show examples of access-control checks
in real-world PHP applications. Figure 1 shows a correct
check (line 4) in Add.php from minibloggie. Add.php in-
vokes a dedicated verifyuser function that queries the user
database with the username and password. If veriﬁcation
fails, the application returns the user to the login page.
Figure 2 shows a correct check (line 3) performed by Ac-
ceptBid.php in the DNscript application. It reads the hash
table containing the session state and checks the member
Add.php
s e s s i o n s t a r t ( ) ;
1 
Figure 1: minibloggie: Access-control check
ﬂag. Both access-control policies protect the same oper-
ation—a mysql query call site that updates the back-end
database—but with very different logic.
The access-control checks are role-speciﬁc. For exam-
ple, the DNscript application has two roles. Figure 2 shows
the check for the “regular user” role and Figure 3 shows the
check for the “administrator” role.
DelCb.php in Figure 2 shows an access-control bug in
the DNscript application: the check on $ SESSION for
the “regular user” role is present in AcceptBid.php, but
missing in DelCb.php. The developer either forgot the
check or did not realize that any network user can directly
invoke DelCb.php. The bottom of Figure 2 shows how FIX-
MEUP repairs DelCb.php by replicating the correct access-
control logic from AcceptBid.php (associated with the “reg-
ular user” role). Similarly, Figure 3 shows how FIXMEUP
repairs an access-control bug in AddCat2.php (associated
with the “administrator” role) by replicating the access-
control check from Del.php.
Invalid control ﬂow distinguishes access-control vulner-
abilities from data-ﬂow vulnerabilities, such as cross-site
scripting and SQL injection studied in prior work [13, 15,
17, 39, 42]. The access-control policy determines if the user
is authorized to perform a particular operation, regardless
of whether or not there are tainted data ﬂows into the argu-
ments of the operation.
3.2 Design patterns for access control
There is no standard access-control library or framework for
Web applications, thus each application implements access-
AcceptBid.php
Del.php
s e s s i o n s t a r t ( ) ;
i f
( ! $ SESSION [ ’ member ’ ] ) { / / a c c e s s−c o n t r o l c h e c k
header ( ’ L o c a t i o n :
e x i t ;
l o g i n . php ’ ) ;
i n c l u d e
i n c l u d e
. . .
’ i n c / c o n f i g . php ’ ;
’ i n c / conn . php ’ ;
7
8
9
10 $q5 = mysql query ( ”INSERT INTO c l o s e b i d ( item name ,
s e c u r i t y −s e n s i t i v e o p e r a t i o n
/ /
s e l l e r n a m e , bidder name ,
c l o s e p r i c e ) ” . $ s q l 5 ) ;
DelCb.php
1 
6
7
8
9 }
10 ?>