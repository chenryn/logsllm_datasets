by CreateProcessAsUserW
AipVerifyConsent: 
Verify consent not patched by 
ReadProcessMemory
PI:EMAIL
AiLaunchProcess:  
Create Suspended Consent Process  
by CreateProcessAsUserW
AipVerifyConsent: 
Verify consent not patched by 
ReadProcessMemory
PI:EMAIL
Consent process gets awake, checks the 
"trustFlag", and decides to display 
alert UI or not.
PI:EMAIL
AiLaunchProcess:  
Create Suspended Consent Process  
by CreateProcessAsUserW
AipVerifyConsent: 
Verify consent not patched by 
ReadProcessMemory
PI:EMAIL
PI:EMAIL
PI:EMAIL
High Priv
Low Priv
Priv Low to High
Timeline 
PI:EMAIL
NtOpenProcess
RpcImpersonateClient
High Priv
Low Priv
NtDuplicateToken(-2)
RpcRevertToSelf
RpcImpersonateClient
ExeFileHandle = 
CreateFileW
$p = ToDosName(GetLongPathNameW(pathInput))
TrustAuth_A($p)
TrustAuth_B($p)
RpcRevertToSelf
AiLaunchConsentUI
AiLaunchProcess(pathInput)
PI:EMAIL
NtOpenProcess
RpcImpersonateClient
High Priv
Low Priv
NtDuplicateToken(-2)
RpcRevertToSelf
RpcImpersonateClient
ExeFileHandle = 
CreateFileW
$p = ToDosName(GetLongPathNameW(pathInput))
TrustAuth_A($p)
TrustAuth_B($p)
RpcRevertToSelf
AiLaunchConsentUI
AiLaunchProcess(pathInput)
PI:EMAIL
NtOpenProcess
RpcImpersonateClient
High Priv
Low Priv
NtDuplicateToken(-2)
RpcRevertToSelf
RpcImpersonateClient
ExeFileHandle = 
CreateFileW
$p = ToDosName(GetLongPathNameW(pathInput))
TrustAuth_A($p)
TrustAuth_B($p)
RpcRevertToSelf
AiLaunchConsentUI
AiLaunchProcess(pathInput)
PI:EMAIL
NtOpenProcess
RpcImpersonateClient
High Priv
Low Priv
NtDuplicateToken(-2)
RpcRevertToSelf
RpcImpersonateClient
ExeFileHandle = 
CreateFileW
$p = ToDosName(GetLongPathNameW(pathInput))
TrustAuth_A($p)
TrustAuth_B($p)
RpcRevertToSelf
AiLaunchConsentUI
AiLaunchProcess(pathInput)
PI:EMAIL
〉〉〉Issue
PI:EMAIL
NtOpenProcess
RpcImpersonateClient
High Priv
Low Priv
NtDuplicateToken(-2)
RpcRevertToSelf
RpcImpersonateClient
ExeFileHandle = 
CreateFileW
$p = ToDosName(GetLongPathNameW(pathInput))
TrustAuth_A($p)
TrustAuth_B($p)
RpcRevertToSelf
AiLaunchConsentUI
AiLaunchProcess(pathInput)
PI:EMAIL
> TenableSecurity: UAC Bypass by Mocking Trusted 
Directories by David Wells  
> Google Project Zero: The Definitive Guide on Win32 to 
NT Path Conversion by James Forshaw 
> MSDN Developer Blog:  
Path Normalization by Jeremy Kuhne 
Path Format Overview by Jeremy Kuhne
/?path_Normaliz
PI:EMAIL
/?path_Format
DOS Paths (2.0)
C:\Test\Foo.txt
A full volume name. If it doesn't start with all 3 
characters it is considered to be partially 
qualified or relative to the current directory.
PI:EMAIL
/?
UNC Paths
\\Server\Share\Test\Foo.txt
start with two separators. The first component is 
the host name (server), which is followed by the 
share name.
path_Format
PI:EMAIL
/?
DOS Device Paths
\\.\C:\Test\Foo.txt
path_Format
\\?\C:\Test\Foo.txt
\\.\UNC\Server\Share\Test\Foo.txt
\\?\UNC\Server\Share\Test\Foo.txt
PI:EMAIL
• Identifying the Path and Legacy Devices 
• Applying the Current Directory 
• Canonicalizing Separators 
• Evaluating Relative Components 
• Trimming Characters 
• Skipping Normalization
/?path_Normaliz
Path Normalization by Jeremy Kuhne 
PI:EMAIL
• Identifying the Path and Legacy Devices 
• Applying the Current Directory 
• Canonicalizing Separators 
• Evaluating Relative Components 
• Trimming Characters 
• Skipping Normalization
/?path_Normaliz
Path Normalization by Jeremy Kuhne 
If the path doesn't end in a separator, all trailing 
periods and \x20 will be removed. If the last segment 
is simply a single or double period it falls under 
the relative components rule above.
This rule leads to the possibly surprising ability 
to create a directory with a trailing space. You 
simply need to add a trailing separator to do so.
PI:EMAIL
• Identifying the Path and Legacy Devices 
• Applying the Current Directory 
• Canonicalizing Separators 
• Evaluating Relative Components 
• Trimming Characters 
• Skipping Normalization
/?path_Normaliz
Path Normalization by Jeremy Kuhne 
An important exception- if you have a device 
path that begins with a question mark instead of 
a period.  It must use the canonical backslash- 
if the path does not start with exactly  
\\?\ it will be normalized.
PI:EMAIL
NtOpenProcess
RpcImpersonateClient
High Priv
Low Priv
NtDuplicateToken(-2)
RpcRevertToSelf
RpcImpersonateClient
ExeFileHandle = 
CreateFileW
$p = ToDosName(GetLongPathNameW(pathInput))
TrustAuth_A($p)
TrustAuth_B($p)
RpcRevertToSelf
AiLaunchConsentUI
AiLaunchProcess(pathInput)
/?Issue
PI:EMAIL
$p =  
RtlDosPathNameToRelativeNtPathName_U_WithStatus( 
    GetLongPathNameW(pathInput) 
)
/?trustAuth_A
PI:EMAIL
RtlDosPathNameToRelativeNtPathName_U_WithStatus( 
    GetLongPathNameW(L"C:\sea\food \seafood.exe") 
)
RtlDosPathNameToRelativeNtPathName_U_WithStatus( 
    L"C:\sea\food\seafood.exe" 
)
$p = L"\??\C:\sea\food\seafood.exe"
/?trustAuth_A
AiLaunchProcess(L"C:\sea\food \seafood.exe")
PI:EMAIL
RtlDosPathNameToRelativeNtPathName_U_WithStatus( 
  GetLongPathNameW(L"C:\Windows \System32\a.exe") 
)
RtlDosPathNameToRelativeNtPathName_U_WithStatus( 
    L"C:\Windows\System32\a.exe" 
)
$p = L"\??\C:\Windows\System32\a.exe"
/?trustAuth_A
AiLaunchProcess(L"C:\Windows \System32\a.exe")
PI:EMAIL
RtlDosPathNameToRelativeNtPathName_U_WithStatus( 
  GetLongPathNameW(L"C:\Windows \System32\a.exe") 
)
RtlDosPathNameToRelativeNtPathName_U_WithStatus( 
    L"C:\Windows\System32\a.exe" 
)
$p = L"\??\C:\Windows\System32\a.exe"
/?trustAuth_A
AiLaunchProcess(L"C:\Windows \System32\a.exe")
We have no privilege to write files inside 
C:\Windows\System32 due to Windows DACL
But it's okay for us to create a 
dictionary "Windows\x20" via the \\?\ 
prefix to avid Path Normalization 
PI:EMAIL
〉〉〉Combo
PI:EMAIL
• TrustAuth_A  
- Path Normalization Issues  
→ \\?\ prefix to bypass 
• TrustAuth_B 
- Whitelisted EXE Files with Trusted Signature 
- AutoElevated Marked EXE Files 
→  DLL Side-Loading Tricks to hijack AutoElevated Marked 
EXE Files
/?attack Vectors
PI:EMAIL
$_payload?
PI:EMAIL
$_Siofra
github.com/Cybereason/siofra
PI:EMAIL
$_Siofra
PI:EMAIL
$_Siofra
$_ DEMO
PI:EMAIL
• TrustAuth_A used for verifying child process launched 
from a trustable dircctory 
• if trusted, TrustAuth_B check child process signed with  
legal signature or marked as AutoElevate 
• Consent.exe launched, and the UAC prompt pops up if 
child process isn't full trusted 
• TrustAuth_A/B is an extra design. The different paths 
between verification and Forking Process lead to EoP
$_./Recap
万⽤劫持
本地提权
情报渗透
越级注入
PS C:\> 
[System.Convert]::ToBase64String([System
ext.Encoding]::UTF8.GetBytes("PS
cmd.exe /c "dir"
141414141414141414141
AAAAAAAAAAAAAAAAAAAAAAA
PI:EMAIL
远程后⾨
网军⾏动
Thanks!
Slide
Github
@aaaddress1
Facebook