审计什么 
当回顾执行带外功能的代码模块时，需要注意一些常见问题 
包括: 
⚫ 
认识到系统被滥用的风险。攻击者想从你的站点向某人发送大量的短信，或者向随机的
人发送电子邮件。确保: 
⚫ 
如果可能，只有经过身份验证的用户才能访问导致带外功能被调用的链接(忘记密码是
个例外)。 
⚫ 
对界面进行速率限制，因此拥有“肉机”或者僵尸账号的攻击者不能使用它向用户发送
99 
带外消息。 
⚫ 
不允许该功能接受用户输入的地址，只使用注册的电话号码、电子邮件、地址。 
⚫ 
对于高风险站点(例如，银行)用户的电话号码可以线下注册，而不是通过网站注册。 
⚫ 
不要在带外通信中发送任何个人或身份验证信息。 
⚫ 
确保通过带外信道发送的任何 PIN 或密码都具有较短的寿命，并且是随机的。 
⚫ 
需要考虑的一点是防止短信发送到当前正在进行浏览会话的设备上(即,用户在他们的
手机上浏览，短信被发送到该手机)。然而，这可能很难执行。如果可能的话，让用户
选择他们想要使用的波段。对于银行网站，移动设备上的 Zitmo 恶意软件（请参阅参
考资料）可以拦截 SMS 消息，但是 iOS 设备尚未受到此恶意软件的影响，因此用户可
以选择将 SMS PIN 发送到其 Apple 设备，而在 Android 上，他们可以使用录制的语
音留言接收 PIN。 
⚫ 
在典型的部署中，与 Web 应用程序分离的专用硬件/软件将处理带外通信，包括创建
临时 PIN 和可能的密码。 在这种情况下，无需将 PIN /密码暴露给您的 Web 应用程
序（增加暴露的风险），而是 Web 应用程序应使用最终用户提供的 PIN /密码来查询
专用的硬件/软件，并获得是与否的判断结果。 
⚫ 
包括银行业在内的许多部门都制定了法规，要求对某些类型的交易使用双因素身份验证。 
在其他情况下，双因素身份验证可以提高欺诈的成本，并增强客户对网站的信任。 
参考 
⚫ 
https://www.owasp.org/index.php/Forgot_Password_Cheat_Sheet 
⚫ 
http://secure ist . com/blog/virus-watch/57860/new-zitmo-for-Andr 
100 
oid-and-blackberry/ 
3.2.7 会话管理 
概述 
网络会话是与同一用户相关联的一系列网络 HTTP 请求和响应事务。web 应用程序需
要对会话状态进行管理，因为这些应用程序需要在多个请求期间保留每个用户的信息或状态。
因此，会话提供了建立变量(如，访问权限和本地化设置)的能力，这些变量将应用于会话期
间用户与网络应用程序的每次交互。 
描述 
代码审计者需要了解开发人员使用了什么会话技术，以及如何发现可能造成潜在安全风
险的漏洞。Web 应用程序可以在第一次用户请求后创建会话来跟踪匿名用户。一个典型的
功能例子是维护用户的语言偏好。此外，一旦用户通过身份验证，web 应用程序将建立会
话。这确保了在任何后续请求中识别用户的能力，以及能够应用安全访问控制、对用户私有
数据的授权访问，并提高应用程序的可用性。因此，当前的网络应用程序可以提供认证前和
认证后的会话能力。 
会话标识或令牌将用户身份验证凭据(以用户会话的形式)绑定到用户的 HTTP 流量和网
络应用程序实施的适当访问控制上。现代 web 应用程序中这三个组件(身份验证、会话管理
和访问控制)的复杂性，加上其实现和绑定掌握在 web 开发人员手中(因为 web 开发框架不
提供这些模块之间的严格关系)，使得安全会话管理模块的实现非常具有挑战性。 
101 
会话标识的泄露、捕获、预测、暴力或固定将导致会话劫持(或侧劫持)攻击，攻击者能
够在网络应用程序中完全模拟受害用户。攻击者可以执行两种类型的会话劫持攻击，目标攻
击和一般攻击。在有针对性的攻击中，攻击者的目标是冒充特定(或特权)的 web 应用程序
受害用户。对于一般的攻击，攻击者的目标是在 web 应用程序中模拟(或获得访问权限)任
何有效或合法的用户。 
为了实现安全会话标识，标识符(标识或令牌)的生成必须满足 
以下属性: 
⚫ 
会话标识使用的名称不应过于描述性，也不应提供不必要的关于标识目的和含义的细节。 
⚫ 
建议将 web 开发框架的默认会话 id 名称更改为通用名称，如“ID”。 
⚫ 
会话标识长度必须至少为 128 位(16 字节)(会话标识值必须提供至少 64 位的熵)。 
⚫ 
会话标识内容(或值)必须是无意义的，以防止信息泄露攻击，攻击者能够解码标识内容
并提取用户、会话或网络应用程序内部工作的详细信息。 
⚫ 
建议通过使用加密哈希函数(如 SHA2 (256 位))来创建加密性强的会话标识。 
审计什么 
当您的应用程序包含身份验证时，需要 cookie。代码审计者需要了解应用程序 cookies
中存储了什么信息。如果敏感信息存储在需要 SSL 的 cookie 中，则需要进行风险评估。 
. NET ASPX 配置 
102 
Java web.xml 
PHP.初始化设置文件的后缀名 
样本: 
PHP php.ini 
会话到期 
在审计会话处理代码时，审计者需要了解 web 应用程序需要什么样的到期设置，或者
1  
2  
2  
3 true 
4  
5  
103 
是否使用了默认会话超时。网络会话过期时间设置不当的话，应用程序就会增加其他基于会
话的攻击的风险，因为攻击者能够重用有效的会话标识并劫持关联的会话的前提是，它必须
仍然是有效的。 
请记住，为了安全编码，我们的目标之一是减少应用程序的攻击面。 
.NET ASPX 
开发人员 ASPX 可以更改会话的默认超时。web.config 文件中的这段代码设置了 
超时会话为 15 分钟。aspx 会话的默认超时是 30 分钟。 
JAVA 
PHP 
没有会话超时机制。PHP 开发人员将需要创建他们自己的自定义会话超时。 
会话注销/结束 
Web 应用程序应该提供一种机制，允许具有安全意识的用户在使用完 web 应用程序后
1  
2   
1  
2 1 
3  
104 
主动关闭他们的会话。 
.NET ASPX Session.Abandon()销毁存储在会话对象中的所有对象，并释放它们的资
源。如果不显式调用放弃方法，服务器会在会话超时时销毁这些对象。当用户注销时，您应
该使用它。Session.Clear()从进程中删除所有键和值。不更改会话标识。如果不希望用户重
新登录并重置所有会话特定数据，请使用此命令。 
会话攻击 
通常有三种类型的会话攻击: 
⚫ 
会话劫持:窃取某人的会话标识，并使用它来冒充该用户。 
⚫ 
会话固定:将某人的会话标识设置为预定义值，并使用该已知值模拟他们 
⚫ 
会话提升:当会话的权限改变，但其标识没有改变时。 
会话劫持 
⚫ 
大部分是通过 XSS 攻击完成的，可以通过设置会话属性为 http-only 字段来防止(在
Javascript 代码不需要访问它们的时候)。 
⚫ 
对于 Javascript 来说，不需要访问会话 cookies 通常是一个好做法，因为防止所有类
型的 XSS 通常是强化系统最困难的部分。 
⚫ 
会话标识应该放在 cookies 中，而不是网址中。网址信息会在浏览器的历史记录和超
文本传输协议中被参考，攻击者可以访问。 
⚫ 
因为防止各种类型的 XSS 通常是强化系统最困难的部分，所以，有“HTTPOnly”的
105 
属性禁止 XSS 获取 cookie，会话 cookie 应该设置了此属性。无论如何，如果代码需
要从客户端访问会话 cookie，您应该对这种代码产生怀疑。 
⚫ 
地理位置审计有助于检测简单的劫持场景。高级劫机者使用受害者的相同 IP(或范围)。 
⚫ 
当从另一个位置访问活动会话时，应发出警告。 
⚫ 
当活动用户在其他地方有活动会话时，应发出警告(如果策略允许单个用户有多个会话)。 
会话固定 
⚫ 
如果应用程序发现池中不存该用户的会话标识，则应拒绝它，并应重置新的会话标识。
这是防止固定的唯一方法。 
⚫ 
所有会话标识都应该由应用程序生成，然后存储在一个池中，供以后审计。应用程序是
生成会话的唯一权威。 
会话提升 
⚫ 
无论何时提升会话(登录、注销、特定授权)，都应该进行更新。 
⚫ 
许多应用程序也为访问者(而不仅仅是经过身份验证的用户)创建会话。他们肯定应该在
提升时更新会话，因为用户希望应用程序在他们登录后安全地对待保证他们会话安全。 
⚫ 
发生降级时，应刷新有关更高级别的会话信息。 
⚫ 
会话在提升时应该更新。更新意味着会话 id 应该被改变，并且会话信息应该被转移到
新的 id。 
106 
会话管理的服务器端防御 
.NET ASPX 
生成新的会话标识有助于防止会话滚动、固定和劫持。 
JAVA 
PHP php.ini  
1 public class GuidSessionIDManager : SessionIDManager { 
2 public override string CreateSessionID(HttpContext context){ 
3 return Guid.NewGuid().ToString(); 
4 } 
5 public override bool Validate(string id) { 
6 try{ 
7 Guid testGuid = new Guid(id); 
8 if (id == testGuid.ToString()) 
9 return true; 
10 }catch(Exception e) { throw e } 
11 return false; 
12 } 
13 } 
1 request.getSession(false).invalidate(); 
2 //and then create a new session with 
3 getSession(true) (getSession()) 
107 
参考 
⚫ 
https://wwww.owasp.org/index.php/SecureFlag 
3.3 A3 跨站点脚本注入（XSS） 
3.3.1 概述 
什么是跨站点脚本(XSS)？ 
跨站点脚本(XSS)是一种编码注入漏洞。它通常出现在 web 应用程序中。XSS 使攻击者
能够向其他用户浏览的网页中注入恶意内容。XSS 允许攻击者绕过访问控制，例如，同源策
略。它是 OWASP Top10 最常见的漏洞之一。赛门铁克在其年度威胁报告中发现，XSS 是
网络服务器上的第二大漏洞。根据易受攻击站点处理的数据的敏感性和站点组织实施的任何
安全缓解措施的性质，此漏洞的严重性/风险可能从有害到主要安全风险不同等级。 
描述 
有三种类型的 XSS，反射 XSS(非持久)，存储 XSS(持久)，和基于 DOM 的 XSS。每种
类型都有不同的方式向服务器传递恶意负载。攻击的效果是一样的。 
审计什么 
1 session.use_trans_sid = 0 