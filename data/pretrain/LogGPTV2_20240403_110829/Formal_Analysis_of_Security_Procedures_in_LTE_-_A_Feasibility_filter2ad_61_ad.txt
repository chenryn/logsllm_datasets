20
21
22
23
24
25
26
27
28
l e t UE( u e c a p s : c a p s , kasme : k e y ) =
(NSR , n a s u l c o u n t ) ) ; (∗ i n i t i a l
new n a s u l c o u n t : b i t s t r i n g ; out ( pubch , n a s u l c o u n t ) ;
out ( s e c c h ,
i n ( pubch , (=RSM, a : a l g ,
l e t kenb : k e y = k d f ( n a s u l c o u n t , kasme )
l e t k r r c i n t : k e y = k d f ( RRCINT , kenb )
i f mem( a , u e c a p s ) && r r c m a c = pmac ( a ,
r r c m a c : b i t s t r i n g ) ) ;
s e r v i c e
i n
i n
r e q u e s t ∗)
(RSM, a ) , k r r c i n t )
then
l e t k r r c e n c : k e y = k d f (RRCENC, kenb )
out ( pubch ,
( RSC , p s e n c ( a ,
( s e c r e t , pmac ( a ,
i n
( RSC ,
s e c r e t ) , k r r c i n t ) ) ,
l e t MME( u e c a p s : c a p s , kasme : k e y ) =
k r r c e n c ) ) ) .
i n ( s e c c h , (=NSR , n a s u l c o u n t ) ) ;
l e t kenb : k e y = k d f ( n a s u l c o u n t , kasme )
out ( s e c c h ,
i n ( s e c c h , =CSC ) .
i n
( ISC , u e c a p s , kenb ) ) ; (∗ i n i t i a l
l e t eNodeB ( ) =
c o n t e x t
s e t u p ∗)
r r c m a c : b i t s t r i n g = pmac ( a ,
i n ( s e c c h , (=ISC , u e c a p s : c a p s , kenb : k e y ) ) ;
l e t k r r c i n t : k e y = k d f ( RRCINT , kenb )
l e t a : a l g s u c h t h a t mem( a , u e c a p s )
l e t
out ( pubch ,
l e t k r r c e n c : k e y = k d f (RRCENC, kenb )
i n ( pubch , (=RSC , p a y l o a d : b i t s t r i n g ) ) ; (∗ s e c u r i t y mode c o m p l e t e ∗)
l e t
i f
r r c m a c r : b i t s t r i n g ) = p s d e c ( a , p a y l o a d , k r r c e n c )
r r c m a c ) ) ; (∗ s e c u r i t y mode command ∗)
i n (∗ i n t e g r i t y p r o t e c t i o n ∗)
i n (∗ c o n f i d e n t i a l i t y ∗)
(RSM, a ) , k r r c i n t )
s e c r e t ) , k r r c i n t )
(= s e c r e t ,
(RSM, a ,
then
i n
i n
i n
r r c m a c r = pmac ( a ,
out ( s e c c h , CSC ) . (∗ i n i t i a l
( RSC ,
c o n t e x t
s e t u p r e s p o n s e ∗)
p r o c e s s
. . .
( ( ! UE( u e c a p s , kasme ) )
|
( ! eNodeB ( ) )
|
( !MME( u e c a p s , kasme ) ) )
Fig. 5. RRC security establishment model
The main process (line 26) executes some initialization steps then forks in
parallel an unbounded number of sessions of three processes representing an UE
(1), an MME (10) and an eNB (15) node. The initialization steps (omitted in
the ﬁgure) are required to set up the parameters established earlier which are
the user capabilities and the KASME key in a similar manner to how it is done
in the model of Fig. 4. The additional in the model parameter denoted by
nasulcount represents the NAS protocol message counter. This counter is used
for deriving the KeNB key (lines 5 and 12) that is to be provisioned to the eNB
(13 and 16). It is incremented for each message exchange between the UE and
MME. For example, this would be the eﬀect of the send and matching receive
operations of lines 3 and 11.
We model the counter by a fresh variable that we disclose (line 2) and make
sure that it is synchronized by including it in the ﬁrst NAS message (line 11). Ac-
cording to the speciﬁcation [1](TS 33.401), when the counter, which is bounded,
is about to wrap around then a new AKA run can be triggered in order to
generate a new KASME key and thus preventing a KeNB key reuse.
Formal Analysis of Security Procedures in LTE - A Feasibility Study
355
For the security properties, we consider the secrecy and sanity queries in a
similar manner to the previous models. For the correspondence assertions, we
focus on the agreement on the established KeNB key and the chosen algorithm
between the UE and the eNB. ProVerif solves all the queries as expected except
one of the injective correspondence assertions (see Table 1).
5 Mobility Management
An eNB may detect that another eNB is better suited to serve an active ter-
minal, for example because of better radio conditions. The source or serving
eNB (denoted by S-eNB) hands over the terminal to the target eNB (denoted
by T-eNB). There are two compound procedures to perform a handover. The
ﬁrst is a core network assisted handover that is called S1 handover (HO S1).
The second is a handover without core network assistance called X2 handover
(HO X2). The names come from the primary network interfaces used during the
execution of the handovers.
5.1 X2 Handover
Handovers can be performed after the terminal has completed all necessary pro-
cedures so that RRC and NAS security has been activated. The X2 handover
∗
eNB key from the currently
(Fig. 6) is initiated by the S-eNB calculating a K
active KeNB and sending it together with the terminal security capabilities to
the T-eNB in a handover request message (REQ). The T-eNB replies with the
required conﬁguration information for the terminal connection. This information
includes the chosen algorithms that the T-eNB and the terminal shall use (CMD).
The S-eNB then forwards the reply to the terminal, which conﬁrms the handover
with a completion message (CPL). In the last step, the T-eNB retrieves a new
key called the Next Hop key (NH) from the MME. The NH which is derived
∗
from the KASME is to be used as a basis for the K
eNB calculation in the next
handover event [1] (TS 33.401).
5.2 S1 Handover
In an S1 handover (Fig. 7), the S-eNB and target T-eNB are not directly con-
nected. Instead, the S-eNB sends a handover required message (RQD) to the MME
containing the security capabilities of the terminal. The MME then derives the
NH key and sends it to the target node, together with the UE capabilities. The
T-eNB uses the NH key to derive the KeNB for communication with the termi-
nal, and sends a handover command (CMD) containing the chosen algorithms to
the source node. Finally, the S-eNB forwards the message to the terminal which
replies to the T-eNB by a handover completed message (CPL).
356
N.B. Henda and K. Norrman
UE
S-eNB
T-eNB
MME
REQ: K
∗
eNB
, UEalgs
CMD: RRCalgs
CMD: RRCalgs
{[CPL]}
PSR
ACK: NH2
REQ: Handover Request
ACK: Path Switch Acknowledge
CMD: Handover Command
CPL: Handover Complete
PSR: Path Switch Request
[ ] Integrity protected
{} Encrypted
Fig. 6. X2 handover
UE
S-eNB
T-eNB
MME
RQD: K
∗
eNB
, UEalgs
REQ: NH2, UEalgs
ACK: RRCalgs
CMD: RRCalgs
CMD: RRCalgs
{[CPL]}
RQD: Handover Required
REQ: Handover Request
CMD: Handover Command
CPL: Handover Complete
PSR: Path Switch Request
ACK: Path Switch Acknowledge
[ ] Integrity protected
{} Encrypted
Fig. 7. S1 handover
5.3 Formal Models and Analysis
Both handover procedures involve four agents: a UE, a source S-eNB, a target
T-eNB and an MME. The procedures are very similar but provide slightly dif-
ferent security guarantees. The ProVerif models of the protocols are provided
in Fig. 8 and Fig. 9. The declaration parts have been omitted as they are very
similar to previous models except for some types and constants.
In the model of X2 handover (Fig. 8), the main process performs the required
initialization steps and forks unbounded sessions of the processes deﬁned in
lines 1, 6, 9 and 12 representing respectively a UE, an MME, a S-eNB and a
T-eNB. The initialization steps include deﬁning the UE capabilities (lines 22-
24), the KASME key shared between the UE and the MME (25), and the KeNB
Formal Analysis of Security Procedures in LTE - A Feasibility Study
357
l e t UE( u e c a p s : c a p s , kenb : key ,
c e l l i d : b i t s t r i n g ) =
i n ( s e c c h , (=CMD, a : a l g ) ) ;
i f mem( a , u e c a p s )
then
l e t k e n b s t a r : k e y = k d f ( c e l l i d , kenb )
out ( pubch ,
( CPL ,
i n
s e n c ( ( a , mac ( ( CPL , a ) , k e n b s t a r ) ) , k e n b s t a r ) ) ) .
l e t MME( n h 2 : k e y ) =
i n ( s e c c h , =PSR ) ;
out ( s e c c h ,
(ACK, n h 2 ) ) .
l e t SeNodeB ( u e c a p s : c a p s , kenb : key ,
c e l l i d : b i t s t r i n g ) =
l e t k e n b s t a r : k e y = k d f ( c e l l i d , kenb )
out ( s e c c h ,
(REQ, k e n b s t a r , u e c a p s ) ) .
i n
l e t TeNodeB ( ) =
i n ( s e c c h , (=REQ, k e n b s t a r : key , u e c a p s : c a p s ) ) ;
l e t a : a l g s u c h t h a t mem( a , u e c a p s )
out ( s e c c h ,
i n ( pubch , (=CPL , msg : b i t s t r i n g ) ) ;
l e t
i f
r r c m a c : b i t s t r i n g ) = s d e c ( msg , k e n b s t a r )
(CMD, a ) ) ;
then
(=a ,
i n
r r c m a c = mac ( ( CPL , a ) , k e n b s t a r )
out ( s e c c h , PSR ) ;
i n ( s e c c h , (=ACK, n h 2 : k e y ) ) .
i n
p r o c e s s
c o n s s e t ( a2 , e m p t y s e t ) )
new a1 : a l g ; new a2 : a l g ;
l e t u e c a p s = c o n s s e t ( a1 ,
out ( pubch , u e c a p s ) ;
new kasme : k e y ; new n a s u l c o u n t : b i t s t r i n g ; out ( pubch , n a s u l c o u n t ) ;
l e t kenb : k e y = k d f ( n a s u l c o u n t , kasme )
l e t n h 1 : k e y = k d f ( t o b i t s t r i n g ( kenb ) , kasme )
l e t n h 2 : k e y = k d f ( t o b i t s t r i n g ( n h 1 ) , kasme )
new c e l l i d : b i t s t r i n g ; out ( pubch ,
(
( ! SeNodeB ( u e c a p s , kenb ,
c e l l i d ) )
c e l l i d ) ;
i n
i n
i n
i n
|
( ! UE( u e c a p s , kenb ,
( ! TeNodeB ( ) )
c e l l i d ) )
( !MME( n h 2 ) )
|
|
)
1
2
3
4
5
6
7
8
9
10
11
12