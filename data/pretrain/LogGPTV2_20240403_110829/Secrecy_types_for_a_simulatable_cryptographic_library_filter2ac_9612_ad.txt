EK(T ) (cid:20) Public
(cid:0)8i : Ti (cid:20) Public(cid:1) ) List(T1; : : : ; Tn) (cid:20) Public
Ti (cid:20) T1 + T2
(T1 (cid:20) T ^ T2 (cid:20) T ) ) T1 + T2 (cid:20) T
(cid:0)8i : Ti (cid:20) T 0
i (cid:1) ) List(T1; : : : ; Tn) (cid:20) List(T 0
1; : : : ; T 0
n)
T1+(T2+T3) (cid:17) (T1+T2)+T3 T1+T2 (cid:17) T2+T1 T +T (cid:17) T
List(T1; : : : ; Ti + T 0
i ; : : : ; Tn) (cid:17) List(T1; : : : ; Ti; : : : ; Tn)+
List(T1; : : : ; T 0
i ; : : : ; Tn)
Figure 6: Subtyping
kept separate because the library THn restricts the use of these keys
purely to the decryption of ciphertexts. Finally, a variable of type
T1 + T2 contains a handle to a term with either type T1 or T2;
subsequent parsing may make the typing more precise. We say
that a type is public if it is a subtype of Public. The type Public
has another special meaning — a variable of type Public (and not
some subtype of it) may point to a tainted term — a term that is
constructed by the adversary.
Not all types SKi(T ) are valid types — the orders of keys have
to be respected. Let us deﬁne the order for all types T (A). The
order of all public types, as well as SecData and SNonce is 0. The
order of SKi(T ) is i. The order of lists and sums is the maximum
order of their components. A type SKi(T ) is valid if the order of
T is strictly less than i.
Note that our type system does not allow making a symmetric
encryption key available to the adversary. The property NoComm
[9] does not exclude revealing a symmetric key, but this must be
done before the key is used for encryption. We do not believe that
real protocols generate symmetric keys only to make them imme-
diately available to the attacker, so we simplify the type system by
excluding this case. This immediately takes care of the property
(V).
As we said before, (cid:0) maps the free variables of a process to
types, i.e. if we say that a process P types according to (cid:0) (denoted
(cid:0) ‘ P ) then dom((cid:0)) must at least include all free variables of
P . The typing (cid:0) also has to map channels between principals to
types (of the messages passed on these channels). The abstract
channels have been introduced for this purpose. There are even
two types for each abstract channel — one for sent and one for
received messages. These two types can by safely taken as equal if
both ends of a channel connect to protocol participants, but this is
not the case for channels between the participant and the user. The
typing (cid:0) must deﬁne two types, (cid:0)(c; s) and (cid:0)(c; r) for each abstract
channel c occurring in the protocol. These may not be completely
arbitrary — if c 2 Chana then (cid:0)(c; s) and (cid:0)(c; r) must be public
types. Also, if c 2 Chani then both (cid:0)(c; s) and (cid:0)(c; r) must be
equal to Public. For abstract channels c in Chans, Chana and
Chani the inequality (cid:0)(c; s) (cid:20) (cid:0)(c; r) must hold. If c 2 Chanu
then (cid:0)(c; r) = SecRD and (cid:0)(c; s) = AllRD — the inputs from
the user have to be treated as secret, whereas anything can be sent
back to him.
Compared to the type system of Abadi and Blanchet [2] a cate-
gory of types is absent — the public encryption keys that the ad-
versary is not allowed to know. The reason for this omission is the
operation of the cryptographic library THn — it tags each asym-
metric encryption with the public encryption key used to produce
it.
Let T ? T 0 denote that T and T 0 have no common subtypes.
Let TA (resp. TH) be the set of all types T (A) (resp. T (H)) in
Fig. 5. The typing judgments (cid:0) ‘ e : T for expressions e are given
in Fig. 7. Here (cid:0) must give types to all variables occurring in e.
Beside e : T we may be able to derive NF(e) or AF(e), meaning
that the computation of the value of the expression e either never
fails (i.e. results in ?) or always fails. This knowledge is useful
when typing the processes of form let x := e in P else Q where
it allows to leave either P or Q untyped (see rules (LetP, LetF)
in Fig. 9). The rules for inferring the failure of expressions are
given in Fig. 8. Note that never failing only makes sense if the
expression has a type. Most of the typing rules for expressions
should be obvious. The computation that is done with public inputs
may always produce public outputs (PNce, PEU, SEU, List, StoP,
SDU, PrT, Const, RetP). The meaning of the types EK(T ) and
SKi(T ) is reﬂected in the rules (PET, SET) — the encryption with
these keys is enough to turn data of type T to public data. Also, if
the decryption of public data succeeds with the symmetric key of
type SKi(T ) then the plaintext must have been of type T (SDT).
If the decryption succeeds with the asymmetric decryption key of
type DK(T ), then the plaintext may also be of type T , but it may
also have been generated by the adversary (who may have learned
the encryption key). Hence the type of decryption is either T or
Public (PD).
The typing rules for the processes are given in Fig. 9. We see
that a message received from a channel gets the type of this channel
(Recv) while the sender of that message is known to the adversary.
The handles may be compared only if it is certain that the corre-
sponding terms are not created by store-commands storing mes-
sages received from the user (IfH). Sometimes we can deduce that
the compared terms cannot be equal (if their types are necessar-
ily different), then we do not have to worry about (i.e.
type) the
then-branch (IfH).
Example
There exists a typing (cid:0) with dom((cid:0)) = fc1; c2; ci; cug (cid:2) fs; rg,
such that both processes A and B in Fig. 4 type with respect to
it. Let us denote T1 = List(SNonce; SK1(SecData); EK(T2))
and T2 = List(SNonce; Public) + SK1(SecData). If we take
(cid:0)(ci; s) = (cid:0)(ci; r) = Public, (cid:0)(cu; r) = SecRD, (cid:0)(cu; s) =
AllRD, (cid:0)(c1; s) = (cid:0)(c1; r) = EK(T1) and (cid:0)(c2; s) = (cid:0)(c2; r) =
EK(T2), then this satisﬁes the constraints put on the values of (cid:0)(c)
for channels c in Chana, Chani or Chanu. To show that (cid:0) ‘
A and (cid:0) ‘ B, let us mention the types that some variables get
when typing A and B; the rest of the types should be easy to ﬁgure
out. We mostly mention the type when the variable points to newly
generated data.
In process A, variable k(cid:0)1
A gets the type DK(T1). The process
A0 is included in A twice (ﬁrst time for kX = kB and second
time for possibly tainted kX-s), the types of variables are somewhat
different there. The variable sA gets the type SNonce in the ﬁrst
case and Public in the second. We need to give the type Public to
pubenc(kX ; list(sA; kA)), this is done with help of the rule (PET)
in the ﬁrst case and (PEU) in the second. The value l2 gets a sum
type, at this point we use the rule (Sum), giving us two subcases
for both cases. The comparison if sA2 = sA effectively rules out
l1 : Public in the ﬁrst case and l1 : T1 in the second case because
of incompatible types (we ﬁnd that the else-part is deﬁnitely taken).
In the remaining subcases pubenc(kX2; k0
AX ) has the type Public
(cid:0) ‘ e : T T (cid:20) T 0
(cid:0) ‘ e : T 0
(Sub)
(cid:0) ‘ n : PubRD
(Const)
(cid:0) ‘ x : (cid:0)(x)
(Var)
8i : (cid:0) ‘ ei : Ti 8i : Ti 2 TA
(cid:0) ‘ list(e1; : : : ; ek) : List(T1; : : : ; Tk)
(List)
(cid:0) ‘ e : PubRD
(cid:0) ‘ store(e) : PubData
(StoP)
(cid:0) ‘ e : SecRD
(cid:0) ‘ store(e) : SecData
(StoS)
(cid:0) ‘ gen symenc key(i) : SKi(T )
(SK)
(cid:0) ‘ keypair : DK(T )
(KP)
(cid:0) ‘ gen nonce : SNonce
(SNce)
(cid:0) ‘ gen nonce : Public
(PNce)
(cid:0) ‘ ek : Public (cid:0) ‘ et : Public
(cid:0) ‘ pubenc(ek; et) : Public
(PEU)
(cid:0) ‘ ek : EK(T ) (cid:0) ‘ et : T
(cid:0) ‘ pubenc(ek; et) : Public
(PET)
(cid:0) ‘ ek : Public (cid:0) ‘ et : Public
(cid:0) ‘ privenc(ek; et) : Public
(SEU)
(cid:0) ‘ ek : SKi(T ) (cid:0) ‘ et : T
(cid:0) ‘ privenc(ek; et) : Public
(SET)
(cid:0) ‘ e : Public
(cid:0) ‘ list proj(e; i) : Public
(PrT)
(cid:0) ‘ e : List(T1; : : : ; Tk)
(cid:0) ‘ list proj(e; i) : Ti
(PrL)
(cid:0) ‘ ek : Public (cid:0) ‘ et : Public
(cid:0) ‘ privdec(ek; et) : Public
(SDU)
(cid:0) ‘ ek : SKi(T ) (cid:0) ‘ et : Public
(cid:0) ‘ privdec(ek; et) : T
(SDT)
(cid:0) ‘ ek : DK(T ) (cid:0) ‘ et : T
(cid:0) ‘ pubdec(ek; et) : T + Public
(PD)
(cid:0) ‘ e : DK(T )
(cid:0) ‘ pubkey(e) : EK(T )
(PK)
(cid:0) ‘ e : Public
(cid:0) ‘ retrieve(e) : PubRD
(RetP)
(cid:0) ‘ e : T T 6? SecData
(cid:0) ‘ retrieve(e) : SecRD
(RetS)
Figure 7: Typing expressions
e0 is a subexpression of e (cid:0) ‘ AF(e0)
(cid:0) ‘ AF(e)
(fSub)
e 2 fn; x; gen symenc key(i); keypair; gen nonceg
(cid:0) ‘ NF(e)
(fNoSub)
(cid:0) ‘ e : T 8k (cid:21) i 8T1; : : : ; Tk : T ? List(T1; : : : ; Tk)
(cid:0) ‘ AF(list proj(e; i))
(fPr)
8i : (cid:0) ‘ NF(ei)
(cid:0) ‘ NF(list(e1; : : : ; ek))
(fList)
9i : (cid:0) ‘ ei : T T 62 TA
(cid:0) ‘ AF(list(e1; : : : ; ek))
(fList’)
(cid:0) ‘ NF(e)
(cid:0) ‘ NF(store(e))
(fSto)
(cid:0) ‘ ek : T 8i; T 0 : T ? SKi(T 0) T ? Public
(cid:0) ‘ AF(privenc(ek; et))
(fSE)
(cid:0) ‘ ek : T 8T 0 : T ? DK(T 0)
(cid:0) ‘ AF(pubdec(ek; et))
(fPD)
(cid:0) ‘ e : T 8T 0 : T ? DK(T 0)
(cid:0) ‘ AF(pubkey(e))
(fPK)
(cid:0) ‘ ek : T 8T 0 : T ? EK(T 0)
(cid:0) ‘ AF(pubenc(ek; et))
(fPE)
(cid:0) ‘ e : T T 2 TA T ? SecData + PubData
(cid:0) ‘ AF(retrieve(e))
(fRet)
Figure 8: Failing of expressions
(cid:0) ‘ 0
(Zero)
(II)
(cid:0) ‘ II
x 2 F V (P ) (cid:0)[x 7! T1] ‘ P (cid:0)[x 7! T2] ‘ P
(cid:0)[x 7! T1 + T2] ‘ P
(Sum)
8i : (cid:0) ‘ Ii
(cid:0) ‘ I1 j (cid:1) (cid:1) (cid:1) j In j 0
(Par)
(cid:0) ‘ I (cid:3) (cid:0) ‘ ep : PubRD (cid:0) ‘ e : (cid:0)(c; s)
(cid:0) ‘ sendc(ep; e):I (cid:3)
(Send)
(cid:0)[x 7! (cid:0)(c; r); xp 7! PubRD] ‘ P
(cid:0) ‘ (!)receivec(xp; x):P
(Recv)
(cid:0) ‘ e : T (cid:0)[x 7! T ] ‘ P (cid:0) ‘ Q
(cid:0) ‘ let x := e in P else Q
(Let)
(cid:0) ‘ e : T (cid:0)[x 7! T ] ‘ P (cid:0) ‘ NF(e)
(cid:0) ‘ let x := e in P else Q
(LetP)
(cid:0) ‘ Q (cid:0) ‘ AF(e)
(cid:0) ‘ let x := e in P else Q
(LetF)
(cid:0) ‘ e : T (cid:0) ‘ e0 : T 0 T; T 0 2 TA SecData ? T + T 0
if T 6? T 0 then (cid:0) ‘ P (cid:0) ‘ Q
(cid:0) ‘ if e = e0 then P else Q
(IfH)
(cid:0) ‘ e : PubRD (cid:0) ‘ e0 : PubRD (cid:0) ‘ P (cid:0) ‘ Q
(cid:0) ‘ if e = e0 then P else Q
(IfR)
Figure 9: Typing processes and input processes
either by (PET) or (PEU). The types of the rest of the variables are
obvious.
In process B the variable k(cid:0)1
B gets the type DK(T2). The value
l1 gets a sum type T2. At this point we use the (Sum) rule. The
case where l1 : SK1(SecData) is immediately ruled out by the
following list proj-operation. The variable kAB obviously gets the
type SK1(SecData). The variable kAB2 also gets the sum type T2.
We use the (Sum) rule and the case kAB2 : List(: : :) is ruled out
by the following comparison if kAB = kAB2. It is straightforward
to verify that all send- and if - statements type in both A and B.