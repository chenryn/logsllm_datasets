Here ρ is obtained from φ by replacing every instance of
scopeS(x) with scopeS(x) ∨ ψ(x)
8.{ρ}[rmUsr(xsi) ← ψ]{φ} :
Here ρ is obtained from φ by replacing every instance of
scopeS(x) with scopeS(x) ∧ ¬ψ(x) and every instance of
playsRole(x, y) with playsRole(x, y) ∧ ¬ψ(x)
9.{ρ}[addRole(xri) ← ψ]{φ} :
Here ρ is obtained from φ by replacing every instance of
scopeR(x) with scopeR(x) ∨ ψ(x)
10.{ρ}[rmRole(xr) ← ψ]{φ} :
Here ρ is obtained from φ by replacing every instance of
scopeR(x) with scopeR(x) ∧ ¬ψ(x) and every instance of
playsRole(x, y) with playsRole(x, y) ∧ ¬ψ(y)
11.{ρ}[addObj(xoi) ← ψ]{φ} :
Here ρ is obtained from φ by replace every instance of scopeO(x)
with scopeO(x) ∨ ψ(x)
12.{ρ}[rmObj(xoi) ← ψ]{φ} :
Here ρ is obtained from φ by replacing every instance of
scopeO(x), (x, y) ∈ subPerm(z) and (x, y) ∈ rolePerm(z)
with respectively with scopeO(x)∧¬ψ(x), (x, y) ∈ subPerm(z)∧
¬ψ(x) and (x, y) ∈ rolePerm(z) ∧ ¬ψ(x)
17813.{ρ}[addAct(xai) ← ψ]{φ} :
Here ρ is obtained from φ by replacing every instance of
scopeA(x) with scopeA(x) ∨ ψ(x)
14.{ρ}[rmAct(xai) ← ψ]{φ} :
Here ρ is obtained from φ by replacing every instance of
scopeA(x), (x, y) ∈ subPerm(z) and (x, y) ∈ rolePerm(z)
with respectively with scopeO(x)∧¬ψ(x), (x, y) ∈ subPerm(z)∧
¬ψ(y) and (x, y) ∈ rolePerm(z) ∧ ¬ψ(y)
Proof Rules:
1.
{ψ}p1{ρ},{ρ}p2{φ}
{ψ}(p1; p2){φ}
σ → ψ,{ψ}p{φ}, φ → ρ
{σ}p{ρ}
2.
3.
4.
5.
6.
7.
8.
{ψ}p1{φ}
{ψ}(p1 (cid:16) p2){φ} ,
{ψ}p2{φ}
{ψ}(p1 (cid:16) p2){φ}
{ψ}p1{φ}, {ψ}p2{φ}
{ψ}(p1 (cid:15) p2){φ}
{ψ}p1{φ}
{ψ}(p1 (cid:1) p2){φ}
{ψ}p{φ}
{ψ}(θ :: p){φ}
{ψ}p{φ}
{ψ}(p (cid:2) θ){φ}
{ψ}p{φ}, If {ψ}p
n{φ} then {ψ}p
{ψ}p(cid:16){φ}
n+1{φ}
Lemma 1
(HPC is Sound). The axiom schema and the
proof rules given for HPL are sound.
Proof: See the Appendix.
In order to understand the proposed axiom schema for
HPL compare it with the corresponding axiom schema used
for the assignment statement (x:=t) in verifying imperative
programs. Namely, {φ(t/x)}(x := t){φ}. Notice that φ(t/x)
evaluates the postcondition φ in the pre state with the only
change that aﬀect its truth value, if evaluated in the post
state: namely the variable x taking the value t. In compar-
ison, executing {ρ}[assignP(xsi, xoj, xak) ←
ψ(xsi, xoj, xak)]{φ} changes all those permission sets of sub-
ject si that satisfy ψ(si, xoj, xak) by adding all permissions
that satisfy ψ. The only eﬀect that change could have on
evaluating φ in the pre state is if a truth value had to be
evaluated for an instance of the formula (y, z) ∈ subPerm(x).
Therefore, if every such formula is augmented with the sug-
gested scopeO(y)∧scopeA(z)∧ψ(x, y, z), then it should eval-
uate to the same truth value if φ was to be evaluated in the
post state. We submit that it preserves the intent and the
spirit of the axiom schema from imperative program veriﬁ-
cation literature, but adapts it to the context of our appli-
cation where assignments are sets of individuals satisfying a
formula.
For the usage of these HPL deduction schema, consider
the process of deducing necessary consistency of
assignP(xsi, xoj , xak) ← (cid:29))(cid:16) p for any policy p. According
to Axiom Schema 1, assignP(xsi, xoj, +xak) ← (cid:29)) (cid:16) p is
consistency for any application dependent deﬁnition of con-
sistency provided it does not involve the conUsr, conPerm
predicates. Hence according to the third rule,
assignP(xsi, xoj , xak) ← (cid:29)) (cid:16) p is necessarily consistent.
8. CONCLUSIONS
In this paper, we extended the access policy composition
algebra of [21, 22] to the predicate case. We did so by intro-
ducing a many-sorted ﬁrst-order logic as the based language
and some atomic policies.
Introduced atomic policies model assignments and removal
of permissions from subjects and roles, assignments of roles
to subjects, and addition/removal of subjects, objects, ac-
tions and roles. These represent common operations in-
volved in providing access control.
These atomic policies together with previously introduced
external and internal operators in [22] form our policy alge-
bra. External operators represent automata-theoretic oper-
ators on policies, such as ∪, ∩, −, ;, and (cid:22). Internal operators
are used to merge access permissions either subject-wise or
role-wise. As for expressibility, we have shown that our al-
gebra is capable of deﬁning many known meta policies used
in access control and RBAC.
We have also shown that many notions of consistency and
completeness used in access control policies are deﬁnable as
many-sorted ﬁrst order sentences. In this respect we have
shown that it is not necessary to use the full expressive power
of second-order logic to reason about or specify RBAC poli-
cies. The advantage here is that it is now possible to specify
and verify same properties with far less complicated logical
machinery.
Given that many notions of consistency and completeness
used in access control policies are deﬁnable as many-sorted
ﬁrst order sentences, we have developed a Hoare Logic and
a corresponding Hoare calculus for our policy algebra. The
current version is limited to properties necessary of all pos-
sible end states due to application of a policy. Ongoing
work address extending this logic for other operators, rela-
tive completeness of the Hoare Policy Logic, and extending
our formalism to a more general reasoning system along the
lines of dynamic logic [11].
9. REFERENCES
[1] G.-J. Ahn and R. Sandhu. Role-based authorization
constraints speciﬁcation. ACM Transactions on
Information and Systems Security, 3(4), November
2000.
[2] B. Alpern and F. B. Schneider. Deﬁning liveness.
Information Processing Letters, 21(4):181–185,
October 1985.
[3] B. Alpern and F. B. Schneider. Recognizing safety and
liveness. Distributed Computing, 2:117–126, 1987.
179[4] Y. Bai and V. Varadarajan. A logic for state
Information and System Security, To appear.
APPENDIX
Proof of Lemma 1
We show some sample cases, one axiom corresponding to an
assignment statement and a proof rule.
1. Sample Assignment: {ρ}[assignP(xsi, xoj, xak) ← ψ]{φ} :
Suppose M, s |= ρ and (s, s(cid:7)
) is any state transition corre-
sponding to assignP(xsi, xoj , xak) ← ψ. We need to prove
that M, s(cid:7) |= φ. We do so by using induction on the struc-
ture of φ.
(cid:4)
Base Case: φ is an instance of an atomic predicate:
1. Suppose φ does is not contain any ∈ symbol. Then,
according to Deﬁnitions 6 and 9, M, s |= φ.
2. Suppose φ is of the form (oj, ak) ∈ subPerm(si). Then,
ρ is (oj , ak) ∈ subPerm(si)
scopeO(oj ) ∧ scopeA(ak) ∧
ψ(si, oj , ak). Suppose M, s(cid:7) |= ρ and (s, s(cid:7)
) is a state transi-
tion corresponding to assignP(xsi, xoj, xak) ← ψ. From def-
inition 9, Ms(cid:1),f un(subPerm)(si) = Ms,f un(subPerm)(si) ∪
{(xoj, xa) : M, s |= scopeO(xoj ) scopeA(xak) ∧ ψ(si, xoj, xak)}.
|=
Hence,
(oj , ak) ∈ subPerm(si). Conversely if M, s |= scopeO(oj) ∧
scopeA(ak) ∧ ψ(si, oj , ak), then (oj, ak) ∈ Ms(cid:1),f un(subPerm)(si).
Therefore, M, s |= (oj , ak) ∈ subPerm(si).
Inductive Case: φ is constructed using: ∧,∨,→ ¬,∀
or ∃.
if M, s |= (oj, ak) ∈ subPerm(si), then M, s(cid:7)
Suppose that the constituents of φ satisfy the property to
be proved. Then, this is a standard inductive argument we
omit.
2. Sample Proof Rule:
{ρ}p1{φ}
{ρ}p2{φ}
{ρ}(p1 (cid:16) p2){φ} ,
{ρ}(p1 (cid:16) p2){φ}
Suppose the antecedent of the left hand rule is admissible,
) corresponds to a transition of (p1 (cid:16) p2).
) corresponds to a
M, s |= ρ and (s, s(cid:7)
Then, according to Deﬁnition 10, (s, s(cid:7)
transition of p1. Therefore M, s(cid:7) |= φ
transformations in authorization policies. In Proc.
10th IEEE Computer Security Foundations Workshop,
pages 173–182, 1997.
[5] J. Barwise and S. Feﬀermann. Model Theoretic Logics.
Springer-Verlag, 1985.
[6] P. Bonatti, S. De Capitani di Vimercati, and
P. Samarati. A modular approach to composing access
control policies. In Proc. 7th ACM Conf. on
Communications and Security, pages 164–173, August
2000.
[7] S. A. Cook. Soundness and completeness of an axiom
system for program verﬁcation. SIAM Journal on
Computing, pages 79–90, 1978.
[8] J. Dobson and J. McDermid. A framework for
expressing models of security policy. In Proceedings of
IEEE Symposium on Security and Privacy, pages
229–239, May 1989.
[9] H. B. Enderton. Mathematical Introduction to Logic.
Harcourt Academic Press, 2001.
[10] D. Gries. The Science of Programming.
Springer-Verlag, 1981.
[11] D. Harel, D. Kozen, and J. Tiuryn. Dynamic Logic.
MTI Press, 2000.
[12] S. Jajodia, E. Bertino, and P. Samarati. A ﬂexible
authorization mechanism for relational data
management. ACM Transactions on Information
Systems, 17(9):01–140, 1999.
[13] S. Jajodia, P. Samarati, M. L. Sapino, and V. S.
Subrahmanian. Flexible support for multiple access
control policies. ACM Transactions on Database
Systems, 26(2):214–260, June 2001.
[14] J. Loeckx, K. Sieber, and R. Stansifer. The
Foundations of Program Veriﬁcation. John Wiley and
Sons, 1987.
[15] J. McLean. A general theory of composition for trace
sets closed under selective interleaving functions. In
Proc. IEEE Symp. on Security and Privacy, pages
79–93, Oakland, CA, May 1994.
[16] J. McLean. A general theory of composition for a class
of ”possibilistic” properties. IEEE Transactions on
Software Enginerring, 22(1):53–67, January 1996.
[17] J. McLean. Algebra of security. In Proc. IEEE Symp.
on Security and Privacy, pages 2–7, Oakland, CA,
May 1998.
[18] R. Sandhu and P. Samarati. Access control: Principles
and practices. IEEE Communications, 29(2):38–47,
1996.
[19] R. S. Sandhu, V. Bhamidipati, and Q. Munawer. The
ARBAC97 model for role based administration of
roles. ACM Transactions on Information and System
Security, 1(2):106–135, Febraury 1999.
[20] F. B. Schneider. Enforceable security policies.
Technical Report TR 98-1664, Department of
Computer Science, Cornell University, 1998.
[21] D. Wijesekera and S. Jajodia. Policy algebras for
access control - the propositional case. In Proceedings
of the Eighth ACM Conference on Computer and
Communications Security, November 2001.
[22] D. Wijesekera and S. Jajodia. Propositional policy
algebras for access control. ACM Transactions on
180