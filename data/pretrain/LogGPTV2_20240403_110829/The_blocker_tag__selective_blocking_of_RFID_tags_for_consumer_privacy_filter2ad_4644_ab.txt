Weis et al. show how to encrypt the reader’s transmissions,
so that a passive eavesdropper cannot infer the IDs being
read. Apart from the fact that this does not defend against
active attacks, the authors note that their proposal relies on
the somewhat unrealistic assumption of a common, secret
string shared among tags; this assumption can be removed,
however, if the tags can generate their own random pseudo-
ID’s before singulation.
We note that our selective blocking approach is compati-
ble with this method of protecting reader transmissions from
eavesdroppers.
We note that the “silent tree-walking” and “hash-lock”
approaches for constructing “smart” RFID tags (and indeed
almost any conceivable approach based on smart RFID tags)
involve cryptographic operations on tags. Such approaches
are thus unlikely to be economically practical for the near
future—the RFID chips will be smart but too expensive!
1.6 The Regulation Approach
Garﬁnkel [5] proposes a diﬀerent approach based on an
“RFID Bill of Rights,” which consists of ﬁve articles pro-
posed as a voluntary framework for commercial deployment
of RFID tags. Included are: (1) the right of the consumer
to know what items possess RFID tags, (2) the right to have
tags removed or deactivated upon purchase of these items,
(3) the right of the consumer to access of the data associated
with an RFID tag, (4) the right to access of services with-
out mandatory use of RFID tags, and ﬁnally (5) the right
to know to when, where, and why the data in RFID tags is
accessed.
1.7 Organization
In section 2 we describe how tree-walking singulation al-
gorithms work. Section 3.1 then describes how blocker tags
work for systems that use tree-walking. We focus on use of
the blocker tag as a privacy protection device in section 4.
We consider blocker tags as a denial-of-service threat in sec-
tion 5, and also explore detection measures. We conclude in
section 6 with summary recommendations and a discussion
of future research topics.
2. TREE-WALKING SINGULATION PRO-
TOCOLS
As noted earlier, our approach is based on selectively
blocking the singulation protocol used by the RFID read-
ers. In this section, we present and discuss the tree-walking
singulation protocol, so that we may then in the following
section describe how our blocker tags work.
An RFID reader is really only able to communicate with
a single RFID tag at a time. If more than one tag responds
to a query by the reader (as will often happen naturally, for
example, in a supermarket automated checkout), the reader
detects a “collision.” In this case, it doesn’t read accurately
any of the information transmitted by the tags. The reader
and RFID tags then need to engage in some sort of proto-
col so that the reader can communicate with the conﬂicting
tags one at a time. Such a protocol is called a “singulation
protocol”—it enables the reader to talk to each tag singly.
While there are a number of available singulation proto-
cols, our focus in this paper is on RFID-tag systems that
employ a singulation technique known as tree-walking, as
this singulation technique is (a) likely to be the most com-
mon one deployed in practice and (b) supportive of the more
ﬂexible modes of blocking proposed here.
RFID-tag systems typically operate at a frequency of ei-
ther 13.56 Mhz or 915 Mhz. Those operating at 915 Mhz
usually rely on tree-walking as a singulation technique [13],
and are expected to be the most common type used in the
United States [10]. These are the main focus of our work
here. Tags operating at 13.56 Mhz usually use what is
known as the ALOHA protocol [13] for singulation. (Our
techniques are adaptable to the ALOHA protocol, but we
do not discuss this issue here. Other frequencies, such as
125 kHz and 2.45 GHz, are also used, and employ similar
singulation protocols.
2.1 The Tree-Walking Singulation Algorithm
The tree-walking singulation algorithm enables an RFID-
tag reader to identify the serial numbers of nearby tags indi-
vidually by means of a bit-by-bit query process resembling
a depth-ﬁrst search of a binary tree.
of some ﬁxed bit-length k (such as k = 64, 96, or 128).
Suppose the tags in a given system bear unique identiﬁers
Let (cid:1) denote the concatenation operator for bit strings.
The set of all possible k-bit identiﬁers can be viewed as
the leaves of a standard binary tree of depth k. The root of
this tree has depth 0 and is labeled with the empty string.
A node of depth d is labeled with a binary string x of length
d; if d < k, then the node has a two children at depth d + 1:
a “left child” with label x0, and a “right child” with label
x1. (Here x0 means x (cid:1) 0 and x1 means x (cid:1) 1.)
We regard the branches of a given node in this tree as
bearing labels ‘0’ and ‘1’, respectively associated with the
left and right branches. Thus a node at depth d in this tree
may be uniquely identiﬁed by a binary preﬁx B = b1b2 . . . bd,
representing the sequence of branch labels of branches tra-
versed in a path from the root to the node. It follows that
each of the 2k leaves in the tree has a unique associated k-
bit string. We view each such leaf as representing a distinct
possible tag serial number.
The tree-walking algorithm is a recursive depth-ﬁrst
search performed by a reader in the following way. Let the
subtree of a node denote all its descendents in the tree. The
reader initiates the tree-walking algorithm at the root of the
tree.
Starting at a given node B = b1b2 . . . bd, the reader queries
all tags bearing serial numbers in the leaves of the corre-
sponding subtree, i.e., all tags whose serial numbers bear
the preﬁx B; all other tags are instructed to remain silent.
The queried tags reply to the reader with the d+1-st bit in
their serial numbers; i.e., each tag broadcasts a ‘0’ if it lies in
the left subtree of the node B, and a ‘1’ if it lies in the right
subtree. Consequently, if there are tags in both the left and
right subtrees of B, then the tags together simultaneously
broadcast both a ‘0’ and a ‘1’, creating a collision in the
broadcast bit.
In this case, when a collision is detected, the reader re-
curses (sequentially in turn) beginning at its child nodes
B (cid:1) 0 and B (cid:1) 1.
If, on the other hand, the tags all reply with only a single
bit b, i.e., they all lie in the same subtree, then the reader
recurses on the node B (cid:1) b, and ignores the other (empty)
subtree.
When the algorithm reaches a leaf (at depth k), it outputs
the associated k-bit sequence, which is the serial number of
the tag just read. The full output of the algorithm is a list
of the ID numbers of all tags within range.
The running time of this algorithm is bounded by the
product of k and the number of tags being read. In practice,
a shopping cart full of goods should be scannable in a few
seconds.
Tree-walking example: We provide a toy example in Fig-
ure 1 of how the tree-walking algorithm works. This tree,
which is of depth 3, has 23 = 8 tag serial numbers repre-
sented at its leaves. The preﬁxes associated with subtrees
are denoted in italics.
In this example, we consider three tags as being present,
the ‘001’,‘011’, and ‘110’ tag. These are indicated by large
black circles at their respective leaves.
When carried by a consumer, a blocker tag induces a phys-
ical region of privacy protection in which a reader is inca-
pable of singulating tags.
In this paper, we explore two guises of the blocker tag: as
a privacy-protection tool, and as a malicious tool.
First, the chip can serve as a privacy-protection tool. As
we show, a blocker tag may be naturally designed to prevent
singulation across certain restricted ranges of serial num-
bers. Thus, it is possible to designate a particular zone, i.e.,
range of serial numbers – say, all those with a leading ‘1’
bit – as subject to the privacy-protection of the blocker tag.
As we show, this selective-blocking feature may be used to
protect items in the hands of consumers, while at the same
time permitting unimpeded reading of tags in commercial
environments.
Second, we examine the blocker tag in its malicious guise,
namely as a tool for mounting denial-of-service attacks. Such
a blocker tag might shield either the full spectrum of serial
numbers from reading, or might target a particular range
– for example, the set of serial numbers assigned to a par-
ticular manufacturer. A blocker tag of this form might be
used to disrupt business operations or to help perpetrate
petty theft by shielding merchandise from inventory-control
mechanisms. We are unaware of any protocol-level tech-
nique for circumventing the eﬀects of a malicious blocker
tag, but explore simple ways of detecting the presence of
such a device.
3.1 How a blocker tag works
The operation of a basic blocker tag is quite simple: It
simulates the full set of 2k possible RFID-tag serial num-
bers. We may call such a tag a “full blocker” or a “universal
blocker.”
Thanks to the structure of the tree-walking algorithm,
such blocking may be accomplished quite easily. Whenever
the reader queries tags in the subtree of a given node B for
their next bit value, the blocker tag simultaneously broad-
casts both a ‘0’ bit and a ‘1’ bit. (The blocker tag may re-
quire two antennae to do this.) This forced collision drives
the reader to recurse on all nodes, causing the reader to
explore the entire tree.
If the reader had enough time, memory, and processing
power to complete the tree-walking algorithm in these cir-
cumstances, it would output the entire set of all 2k possible
tag serial numbers.
This set is very large, however – of size at least 264 in even
the most basic system – and the reading process is designed
to execute very rapidly.
In practice, therefore, the reader
may be expected to stall after reaching only a few hundred
leaves in the tree.
The net eﬀect is that the full blocker tag “blocks” the
reading of all tags.
The idea of a special device simulating a number of tags
ﬁrst appears, to the best of our knowledge, in the master’s
thesis of Steve Weis [19]. Weis imagines the use of such a
device in an attack against inventory-control systems – in
particular, as a way of spooﬁng such systems into believing
that stolen items are still present in a retail environment.
Our application – namely privacy protection – is diﬀerent,
and the implementation details are also diﬀerent.
The blocker tag can be reﬁned so as to simulate and there-
fore eﬀectively block just a subset of tags; we call such a
blocker a “partial blocker” tag or a “selective blocker” tag.
Figure 1: Tree-walking example. Each tag has a
three-bit serial number, corresponding to a leaf in
this depth-three binary tree. The tree-walking sin-
gulation protocol corresponds to a depth-ﬁrst search
of this tree, restricted to the leaves/ID’s in use and
their ancestors.
The tree-walking algorithm here ﬁrst singulates the ‘001’
tag. It does this by following the path denoted by the dark-
ened edges. At two nodes, namely the root of the tree and
the root for all tags with a ‘0’ preﬁx, there are collisions in
the bits broadcast by tags, because there are tags present in
both the left and right subtrees. We denote these collision-
points with hollow circles.
Singulation of the ‘011’ and ‘110’ tags would follow by
recursion on the collision points.
2.2 Zones
The tree-walking method has the following nice property,
which is exploited in our blocker-tag approach: all tags
whose IDs share a common preﬁx lie in a common subtree.
Thus, for example, since all products produced by a par-
ticular manufacturer share a common preﬁx, all IDs on tags
for products of that manufacturer lie in a common subtree.
These IDs are all scanned sequentially by the tree-walking
algorithm.
More generally, diﬀerent ID preﬁxes may correspond to
diﬀerent zones (or subtrees) of the space of possible IDs. For
example, all IDs beginning with a ‘1’ may be in a “privacy
zone,” or all IDs beginning with ‘010’ may be in a “recy-
cling zone.” The careful allocation of ID preﬁxes allows the
establish of multiple “zones” of IDs that may be useful in
conjunction with our blocker RFID approach to consumer
privacy. We expand on this idea below.
3. BLOCKER TAGS
We now describe our simple blocker-tag scheme for
privacy-protection. We show how blocker tags selectively
exploit (i.e., interfere with) the tree-walking singulation pro-
tocol. The blocker tag does not engage in an active form
of jamming. Rather, by participating in the tag-reading
process in a non-compliant (or more accurately, a super-
compliant) way, it performs what may be thought of as a
kind of passive jamming.
As brieﬂy explained above, a blocker tag simulates the
full spectrum of possible serial numbers for tags, thereby
obscuring the serial numbers of other tags. The blocker tag
eﬀectively overwhelms this process by forcing it to sweep the
full space of all possible tag identiﬁers, which is extremely
large.
For example, a selective blocker might reply to the reader
only during execution of the tree-walking in the left subtree
of the root. This selective-blocking feature would have the
eﬀect of obstructing only the reading of tags that bear a
‘0’ preﬁx in their serial numbers; tags that begin with a
‘1’ bit could be read without interference. In this manner,
the selective blocker tag can target a particular zone for
protection.
Indeed, a selective blocker tag may be easily and inex-
pensively created so as to block reading of all tags with an
arbitrary preﬁx or small set of preﬁxes – a useful feature, as
we explain below. (More generally, a selective blocker tag
may be designed to simulate – and thus block the reading of
– serial numbers satisfying any of a number of simple con-
ditions, such as those matching a given regular expression.)
3.2 Reader-friendly blocking protocol
If we continue along the above line of exploration, where
the blocker tags are blocking certain zones (subtrees) and
leaving others alone, we see that a problem arises.
For example, if IDs beginning with ‘0’ are blocked, then
the reader may never get around to reading IDs beginning
with ‘1’.
Some method is needed for the reader to know not to
attempt to read within certain subtrees. That is, the reader
needs to know when a subtree is being blocked, so that it
can proceed to other parts of the tree without stalling on
the blocked subtree.
There are many ways one could imagine revising the tree-
walking singulation protocol to make it work eﬃciently even
in the presence of blocker tags, by having the tree-walk ig-
nore subtrees that are being blocked.
For example, when at a given node, the basic tree-walking
protocol asks all leaves in the node’s subtree to broadcast
their “next bit” (the label on the next branch from the node
towards the leaf in question). We could augment the pro-
tocol by allowing the reader ﬁrst to pose the special query:
“Is the subtree rooted at this node being blocked?” If it is
not being blocked, then the reader would proceed to ask the
standard next-bit question.
We might also call this “polite blocking,” since the blocker
tag is being polite by “declaring” which subtrees it is block-
ing.
Another form of polite blocking would be for a blocker tag
to “announce” to readers the policy it is implementing. To
do this, we might use of a small, designated range of “vir-
tual” tag serial numbers t, t+1, . . . , t+k, each corresponding
to one of a range of standard, pre-speciﬁed policies labeled
0, 1, . . . , k. In order to indicate that it is implementing pri-
vacy policy i, a blocker tag can simulate the presence of a
tag with serial number t + i.
(Such unary representation
of policy numbers is important so as to allow a reader that
encounters multiple blocker tags to decipher the full policy
set.) We discuss the idea of privacy policies in greater detail
below.
This approach of “policy announcement” is only viable for
signaling one of a small set of pre-established privacy poli-
cies. It would work especially well with a small number of
privacy-designated zones. In general, policy announcement
is less ﬂexible than the approach of permitting any node to
declare that its subtree is protected. On the other hand, it
may be important not to allow blocker tags to implement an
indiscriminately rich set of privacy policies, as a policy can
then become a unique identiﬁer – or at least distinct enough
to undermine the policy of its bearer.
3.3 Cost considerations
Our blocker-tag approach is particularly attractive be-
cause of its very low cost of implementation.
First, the ordinary consumer-product RFID tags may not
need to be modiﬁed at all. (Or, if the privacy zone recommen-
dations below are followed, they only need to be modiﬁed
slightly to allow ﬂipping of a few initial bits of their IDs.)
The RFID tags don’t need any expensive cryptography. In
terms of overall systems cost, this is the most important
consideration, since there are many more consumer-product
RFID tags than other types.
Second, the blocker tags themselves can be very cheap;
they would consist essentially of just one or two standard
RFID tags, with very slight circuit modiﬁcations made. If
a standard RFID tag can be made for ﬁve cents, a blocker
tag can probably be manufactured for at most ten cents.
Third, the background implementation is small – a pass-
word needs to be managed for each standard RFID tag,
to authorize it to change privacy zones (see the description
later). This is identical then to what is already proposed for
the “kill” command.
Thus, the blocker tag approach is probably as cheap as the
“kill” command approach, but is, as we’ll see, much more
ﬂexible and useful for protecting privacy.
4. BLOCKER TAGS AS PRIVACY TOOLS