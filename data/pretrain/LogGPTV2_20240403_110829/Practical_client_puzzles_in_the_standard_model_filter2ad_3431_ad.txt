Find a solution soln such that VerSoln(puz, soln)
= true. Return (puz, soln) to A.
• Test(str∗): This query may be asked once, at any
point during the game. The challenger gener-
ates a puzzle puz∗ ← GenPuz(s, Q, str) and re-
turns puz∗ to A. Then A may continue to ask
CreatePuzSoln queries.
3. A outputs a potential solution soln∗.
4. Output 1 if VerSoln(puz∗, soln∗) = true and 0 other-
wise.
We say that A wins the game if ExpDiﬀA,Puz,Q(k) = 1 and loses
otherwise. The advantage of A is deﬁned as:
AdvDiﬀA,Puz,Q(k) = Pr
ExpDiﬀA,Puz,Q(k) = 1
(cid:16)
(cid:17)
.
Let k,Q(t) be a family of functions monotonically increas-
ing in t. A puzzle Puz is k,Q(t)−diﬃcult if, for all proba-
bilistic algorithms A running in time at most t,
AdvDiﬀA,Puz,Q(k) ≤ k,Q(t) .
Theorem 3
(Difficulty of DLPuz). Let k be a secu-
rity parameter and let Q be a diﬃculty parameter. Let
GenRSA be a modulus generation algorithm and let Hρ be
a pseudo-random function. Suppose IDL∗ with GenRSA is
δk,Q(t)-diﬃcult. Let k,Q(t) = δk,Q(t + O(poly log k)) +
negl(k). Then DLPuz is k,Q(t)-diﬃcult for all probabilis-
tic algorithms A running in time at most t.
Proof. We prove the theorem using a sequence of games.
Let A be a probabilistic algorithm with running time t. Let
Si be the event that A wins in game Gi. We will use an
adversary A that wins the puzzle diﬃculty experiment to
construct an algorithm B that solves the IDL∗ problem.
Game G0.
Let G0 be the original diﬃculty game ExpDiﬀA,DLPuz,Q(k). For
clarity, we write the full deﬁnition of this game:
1. The challenger ﬁrst runs the Setup algorithm and
obtains s ← (b, ρ, φ(n), (xi, Xi)) and params ←
(n, g, gb). s is kept secret by the challenger and the
parameters params are supplied to A.
2. Whenever A issues a CreatePuzSoln(NC ) query, the
challenger ﬁrst runs the BPV pair generator BPVGen
to obtain a pair (a, ga) and then computes z, v, and
an interval I of length Q in which v lies as in the
puzzle description (Figure 1). The challenger returns
(puz, soln) ← ((z, ga, gb,I), v) to A.
3. At any point during the game, A is allowed to issue a
Test(N∗
C ) query for which the challenger, generates a
puzzle puz∗ = (z∗, ga∗
NC∗ ) and returns puz∗ to A. Then A may continue to
ask CreatePuzSoln(NC ) queries.
, gb,I∗) using GenPuz(s, Q,
4. Eventually, A outputs a potential solution soln∗ =
v∗. If VerSoln(puz∗, soln∗) = true, then the challenger
outputs 1, otherwise it outputs 0.
(cid:17)
ExpDiﬀA,DLPuz,Q(k) = 1
= Pr(S0) .
(8)
(cid:16)
Hence,
Pr
Game G1.
In game G1, we replace the pseudo-random function Hρ
with a truly random function H. This change is indistin-
guishable due to the pseudo-randomness of Hρ, so
| Pr(S0) − Pr(S1)| ≤ negl(k) .
(9)
Game G2.
In game G2, we insert an IDL∗ challenge into the response
to the Test query. In particular, the experiment proceeds as
follows:
1. Obtain an IDL∗ challenge (g, y, n, ¯I). Choose a long-
term secret b ←R Zn and compute all other values in
Setup as speciﬁed in game G1. Set params ← (g, n).
2. Run A(params) with oracle access to CreatePuzSoln(·)
and Test(·), which are answered as follows:
• CreatePuzSoln(str): As in game G1.
• Test(str∗): Use the IDL∗ challenge y as ga. Com-
pute z∗ speciﬁed, and set I ← ¯I + b · z∗. Return
puz ← (NS, z∗, y, gb,I).
3. A outputs a potential solution soln∗.
4. Output 1 if gsoln∗ ≡ y· (gb)z∗
mod n and 0 otherwise.
If A wins game G2, then soln∗ can be converted into a so-
lution soln∗ − b · z∗ for the IDL∗ challenger. Hence,
Pr(S2) ≤ AdvIDL∗
(10)
where B is our challenger which runs in time t(B) = t(A) +
(N + 1)texp + c where c is a constant.
B,GenRSA,Q(k)
The messages generated by the challenger in G2 are iden-
tical to those in G1 except for the following modiﬁcations:
• In game G2, the challenger selects a random b ∈ Zn,
instead of a random b ∈ Zφ(n). This change is in-
distinguishable due to the fact that (n − φ(n))/n ≈
√
O (1/
n).
• The value ga which is returned during the Test query:
in G1 it is an output from the BPV generator BPVGen
whereas in G2 it is uniformly random. By Theorem 1,
one can choose N and (cid:96) so that the distribution of
the BPV generator is statistically close to the uniform
distribution.
Hence
| Pr(S1) − Pr(S2)| ≤
(cid:118)(cid:117)(cid:117)(cid:116)M/
(cid:32)
(cid:33)
N
(cid:96)
+ O(cid:0)1/
n(cid:1) ≤ negl(k)
√
(11)
for a ﬁxed M , where the second inequality follows from ap-
propriate choices of M, N and (cid:96).
Final result.
6. PERFORMANCE COMPARISON
The experimental results of the number theoretic puzzles
for 512-bit RSA modulus with the security parameter k = 56
and the hash based puzzle appear in Table 3. The results
are shown for diﬃculty levels ranging from low, to high. The
experiment is run on a single core of a 3.06 GHz Intel Core i3
with 4GB RAM, compiled using gcc -O2 with architecture
x86 64. The big integer arithmetic from OpenSSL 0.9.8r is
used to implement the software.
It is evident from our experimental results that our puz-
zle is much faster to verify than the existing number theo-
retic puzzles. More precisely, for the 512-bit RSA modulus,
the solution veriﬁcation time of DLPuz is approximately 89
times faster when compared with Rivest et al. puzzle and by
approximately 50 times faster when compared with Karame-
Capkun puzzle. In addition, the solution veriﬁcation time
of DLPuz is approximately 3 times faster when compared
with Rangasamy et al. puzzle. On the other hand, the so-
lution veriﬁcation time of DLPuz is only 1.4 times slower
when compared with Chen et al.’s hash based puzzle (which
is proven secure in the random oracle model).
Note that the running time of generating DLPuz includes
the time to compute HMAC-SHA1 operation. Even though
the puzzle generation algorithm GenPuz of our puzzle is 4 to
7 times slower than the GenPuz in Rivest et al., Karame-
Capkun and Chen et al. puzzles, the cumulative puzzle
generation and veriﬁcation time of our puzzle is still less
than the corresponding times in Rivest et al. and Karame-
Capkun. Moreover, the cost of GenPuz in DLPuz can be
further reduced by setting a lower value for (cid:96) and by in-
creasing the number of precomputed pairs N in the puzzle
setup phase.
7. CONCLUSION
Client puzzles are a promising countermeasure for defense
against denial of service attacks. Hash-based puzzles are
very eﬃcient but are generally secure only in the random
oracle model. On the other hand, number-theoretic puz-
zles can be shown secure in the standard model but exist-
ing puzzles have had expensive puzzle generation or veri-
ﬁcation operations. We have presented a number-theoretic
client puzzle that is not only eﬃcient but also has a standard
model proof of security in the Chen et al. model. To prove
diﬃculty of our puzzle, we introduced a new variant of the
interval discrete logarithm problem and showed the hardness
of this new problem under the factorisation and composite
interval discrete logarithm assumptions. Our experimental
results show that, for 512-bit modulus, the solution veriﬁca-
tion time of our proposed puzzle are much faster than the
Karame- ˇCapkun and the Rivest et al.’s time-lock puzzle.
Combining equations (8) through (11) yields the desired
result.
Future Work.
Remark 2. Though our puzzle is proven secure in the
Chen et al. model, it does not seem straightforward to prove
the security of our puzzle in the multiple puzzle diﬃculty
deﬁnition of Stebila et al. [19]. To prove the security of our
puzzle in the Stebila et al. model we need to either extend
the proposed hardness assumption (to a new variant of the
interval discrete logarithm problem for example) or ﬁnd a
suitable computationally hard problem.
Though we show that our puzzle satisﬁes Chen et al.’s
security notions, the proof for achieving diﬃculty in the
stronger model of Stebila et al. does not follows directly.
Hence, constructing an eﬃcient number theoretic standard
model puzzle which satisﬁes the stronger diﬃculty notion
of Stebila et al. appears to be an interesting open problem.
Additionally, constructing a provably secure hash based puz-
zle that satisﬁes the strong deﬁnition of Stebila et al. in the
standard model remains an open problem.
Puzzle
Diﬃculty
Setup (ms) GenPuz (µs)
FindSoln (s) VerAuth + VerSoln (µs)
512-bit modulus, k = 56.
Rivest et al. [17]
Karame-Capkun [12]
Chen et al. [6] — hash-based
Rangasamy et al. [16]
DLPuz (this paper)
1 million
1 million
222
1 million
10 million
Rivest et al. [17]
Karame-Capkun [12]
Chen et al. [6] — hash based
Rangasamy et al. [16]
DLPuz (this paper)
10 million
10 million
226
10 million
150 million
Rivest et al. [17]
Karame-Capkun [12]
Chen et al. [6] — hash based
Rangasamy et al. [16]
DLPuz (this paper)
100 million
100 million
229
100 million
1500 million
Low Diﬃculty
13.919
11.520
0.002
1401.14
31863
4.80
8.37
5.92
16.66
31.437
Medium Diﬃculty
49.989
28.951
0.002
1419.78
31832
High Diﬃculty
416.292
218.757
0.002
1609.83
31885
4.80
8.37
5.92
16.66
32.01
4.81
8.35
5.87
16.76
32.01
Additional parameter sizes:
For Rangasamy et al. puzzle, (cid:96) = 4 and N = 2500.
For DLPuz, N = 65536 and (cid:96) = 8.
1.54
1.59
1.07
1.54
1.05
15.17
15.18
16.84
15.34
18.10
157.10
160.97
134.38
158.22
175.41
474.68
263.35
3.77
14.75
5.31
474.83
265.28
3.77
14.53
5.29
470.61
259.39