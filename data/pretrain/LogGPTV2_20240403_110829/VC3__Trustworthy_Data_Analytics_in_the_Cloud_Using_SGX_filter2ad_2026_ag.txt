In USENIX Symposium on Operating
an untrusted cloud with haven.
Systems Design and Implementation (OSDI), 2014.
[10] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among
notions of security for public-key encryption schemes. In Advances in
Cryptology—CRYPTO, 1998.
[11] M. Bellare and C. Namprempre. Authenticated encryption: Relations
In
among notions and analysis of the generic composition paradigm.
Advances in Cryptology—ASIACRYPT, 2000.
[12] E.-O. Blass, R. Di Pietro, R. Molva, and M. ¨Onen. Prism—privacy-
preserving search in MapReduce. In S. Fischer-H¨ubner and M. Wright,
editors, Privacy Enhancing Technologies, volume 7384 of Lecture Notes
in Computer Science. Springer Berlin Heidelberg, 2012.
[13] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and
In ACM Symposium
M. Walﬁsh. Verifying computations with state.
on Operating Systems Principles (SOSP), 2013.
[14] S. Brenner, C. Wulf, and R. Kapitza. Running ZooKeeper coordination
In USENIX Workshop on Hot Topics in
services in untrusted clouds.
Systems Dependability (HotDep), 2014.
[15] E. Brickell and J. Li. Enhanced privacy ID from bilinear pairing
In IEEE International
for hardware authentication and attestation.
Conference on Social Computing (SocialCom), 2010.
[16] S. Chen, R. Wang, X. Wang, and K. Zhang. Side-channel leaks in web
applications: A reality today, a challenge tomorrow. In IEEE Symposium
on Security and Privacy, 2010.
[17] X. Chen, T. Garﬁnkel, E. C. Lewis, P. Subrahmanyam, C. A. Wald-
spurger, D. Boneh, J. Dwoskin, and D. R. Ports. Overshadow: A
virtualization-based approach to retroﬁtting protection in commodity
operating systems. In International Conference on Architectural Support
for Programming Languages and Operating Systems (ASPLOS), 2008.
[18] J. Criswell, N. Dautenhahn, and V. Adve. Virtual Ghost: Protecting
applications from hostile operating systems. In International Conference
on Architectural Support for Programming Languages and Operating
Systems (ASPLOS), 2014.
[19] I. Damg˚ard, V. Pastro, N. Smart, and S. Zakarias. Multiparty com-
In Advances in
putation from somewhat homomorphic encryption.
Cryptology—CRYPTO, 2012.
[20] J. Dean and S. Ghemawat. MapReduce: simpliﬁed data processing on
large clusters. Commun. ACM, 51(1), 2008.
[21] C. Fournet, M. Kohlweiss, G. Danezis, and Z. Luo. ZQL: A compiler
for privacy-preserving data processing. In USENIX Security Symposium,
2013.
[22] C. Gentry. Fully homomorphic encryption using ideal lattices. In ACM
Symposium on Theory of Computing (STOC), 2009.
[23] C. Gentry and S. Halevi.
Implementing Gentry’s fully-homomorphic
encryption scheme. In Advances in Cryptology—EUROCRYPT, 2011.
[24] E. G¨oktas¸, E. Athanasopoulos, H. Bos, and G. Portokalidis. Out of
In IEEE Symposium on
control: Overcoming control-ﬂow integrity.
Security and Privacy, 2014.
[25] S. Gueron and M. E. Kounavis. Intel carry-less multiplication instruction
and its usage for computing the GCM mode, 2010. No. 323640-001.
[26] C. Hawblitzel, J. Howell, J. R. Lorch, A. Narayan, B. Parno, D. Zhang,
Ironclad Apps: End-to-end security via automated full-
In USENIX Symposium on Operating Systems
and B. Zill.
system veriﬁcation.
Design and Implementation (OSDI), 2014.
[27] M. Hoekstra, R. Lal, P. Pappachan, C. Rozas, V. Phegade, and J. del
Cuvillo. Using innovative instructions to create trustworthy software
solutions.
In Workshop on Hardware and Architectural Support for
Security and Privacy (HASP), 2013.
[28] O. S. Hofmann, S. Kim, A. M. Dunn, M. Z. Lee, and E. Witchel. Inktag:
Secure applications on an untrusted operating system. In International
Conference on Architectural Support for Programming Languages and
Operating Systems (ASPLOS), 2013.
[29] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster secure two-party
In USENIX Security Symposium,
computation using garbled circuits.
2011.
[30] Intel Corp.
Intel 64 and IA-32 architectures software developer’s
manual—combined volumes: 1, 2a, 2b, 2c, 3a, 3b and 3c, 2013. No.
325462-048.
[31] Intel Corp.
Intel trusted execution technology. software development
[32] Intel Corp. Software guard extensions programming reference, 2013.
guide, 2013. No. 315168-009.
No. 329298-001.
[33] S. Y. Ko, K. Jeon, and R. Morales. The Hybrex model for conﬁdentiality
and privacy in cloud computing. In USENIX Workshop on Hot Topics
in Cloud Computing (HotCloud), 2011.
[34] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and D. Song.
In USENIX Symposium on Operating Systems
Code-pointer integrity.
Design and Implementation (OSDI), 2014.
[35] J. Li, M. Krohn, D. Mazieres, and D. Shasha. Secure untrusted data
In USENIX Symposium on Operating Systems
repository (SUNDR).
Design and Implementation (OSDI), 2004.
[36] Y. Li, J. McCune, J. Newsome, A. Perrig, B. Baker, and W. Drewry.
In Usenix ATC,
MiniBox: A two-way sandbox for x86 native code.
2014.
[37] D. Lie, M. Thekkath, M. Mitchell, P. Lincoln, D. Boneh, J. Mitchell,
and M. Horowitz. Architectural support for copy and tamper resistant
software.
In International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS), 2000.
[38] J. M. McCune, Y. Li, N. Qu, Z. Zhou, A. Datta, V. D. Gligor, and
A. Perrig. Trustvisor: Efﬁcient TCB reduction and attestation. In IEEE
Symposium on Security and Privacy, 2010.
[39] J. M. McCune, B. J. Parno, A. Perrig, M. K. Reiter, and H. Isozaki.
Flicker: an execution infrastructure for TCB minimization. In European
Conference on Computer Systems (EuroSys), 2008.
[40] D. McGrew and J. Viega. The Galois/counter mode of operation (GCM).
Submission to NIST Modes of Operation Process, 2004.
[41] F. Mckeen,
I. Alexandrovich, A. Berenzon, C. Rozas, H. Shaﬁ,
V. Shanbhogue, and U. Savagaonkar.
Innovative instructions and
software model for isolated execution. In Workshop on Hardware and
Architectural Support for Security and Privacy (HASP), 2013.
[42] G. Morris and M. Aubury. Design space exploration of the European
option benchmark using hyperstreams. In IEEE Symposium on Field-
Programmable Custom Computing Machines (FCCM), 2007.
[43] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. SoftBound:
Highly compatible and complete spatial memory safety for C.
In
ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI), 2009.
[44] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. CETS:
compiler enforced temporal safety for C. In International Symposium
on Memory Management, 2010.
[45] O. Ohrimenko, M. T. Goodrich, R. Tamassia, and E. Upfal. The
Melbourne shufﬂe: Improving oblivious storage in the cloud.
In
International Colloquium on Automata, Languages and Programming
(ICALP), 2014.
[46] E. Owusu, J. Guajardo, J. McCune, J. Newsome, A. Perrig, and
A. Vasudevan. Oasis: On achieving a sanctuary for integrity and
secrecy on untrusted platforms. In ACM Conference on Computer and
Communications Security (CCS), 2013.
[47] B. Parno. Bootsrapping trust in a ”trusted” platform.
In USENIX
Workshop on Hot Topics in Security (HotSec), 2008.
[48] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly
practical veriﬁable computation. In IEEE Symposium on Security and
Privacy, 2013.
[49] A. Pavlo, E. Paulson, A. Rasin, D. J. Abadi, D. J. DeWitt, S. Madden,
and M. Stonebraker. A comparison of approaches to large-scale data
analysis. In ACM SIGMOD International Conference on Management
of Data, 2009.
[50] R. A. Popa, C. M. S. Redﬁeld, N. Zeldovich, and H. Balakrishnan.
CryptDB: Protecting conﬁdentiality with encrypted query processing.
In ACM Symposium on Operating Systems Principles (SOSP), 2011.
[51] R. A. Popa, E. Stark, J. Helfer, S. Valdez, N. Zeldovich, M. F. Kaashoek,
and H. Balakrishnan. Building web applications on top of encrypted data
using Mylar. In USENIX Symposium on Networked Systems Design and
Implementation (NSDI), 2014.
[52] I. Roy, S. T. Setty, A. Kilzer, V. Shmatikov, and E. Witchel. Airavat:
In USENIX Symposium on
Security and privacy for MapReduce.
Networked Systems Design and Implementation (NSDI), 2010.
[53] M. Russinovich and D. Solomon. Windows Internals, Part 1. Microsoft
Press Corp., 6th edition, 2012.
[54] N. Santos, R. Rodrigues, K. P. Gummadi, and S. Saroiu. Policy-sealed
data: A new abstraction for building trusted cloud services. In USENIX
Security Symposium, 2012.
5353
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:08:24 UTC from IEEE Xplore.  Restrictions apply. 
[55] F. Schuster, M. Costa, C. Fournet, C. Gkantsidis, M. Peinado, G. Mainar-
Ruiz, and M. Russinovich. V C3: Trustworthy data analytics in the
cloud. Technical Report MSR-TR-2014-39, Microsoft Research, 2014.
[56] D. Song, D. Wagner, and X. Tian. Timing analysis of keystrokes and
SSH timing attacks. In USENIX Security Symposium, 2001.
[57] R. Strackx, B. Jacobs, and F. Piessens. ICE: A passive, high-speed, state-
continuity scheme. In Anual Computer Security Applications Conference
(ACSAC), 2014.
[58] R. Strackx and F. Piessens.
Fides: Selectively hardening software
application components against kernel-level or process-level malware.
In ACM Conference on Computer and Communications Security (CCS),
2012.
[59] G. Suh, D. Clarke, B. Gassend, M. van Dijk, and S. Devadas. AEGIS:
In
Architecture for tamper-evident and tamper-resistant processing.
International Conference on Supercomputing (ICS), 2003.
[60] L. Szekeres, M. Payer, T. Weiz, and D. Song. Sok: Eternal war in
memory. In IEEE Symposium on Security and Privacy, 2013.
[61] S. D. Tetali, M. Lesani, R. Majumdar, and T. Millstein. MrCrypt:
In Conference on
Static analysis for secure cloud computations.
Object-Oriented Programming, Systems, Languages, and Applications
(OOPSLA), 2013.
[62] Trusted Computing Group. Trusted platform module main speciﬁcation.
version 1.2, revision 103, 2007.
[63] K. H. Tsoi, K.-H. Lee, and P. H. W. Leong. A massively parallel RC4
key search engine. In IEEE Symposium on Field-Programmable Custom
Computing Machines (FCCM), 2002.
[64] S. Tu, M. F. Kaashoek, S. Madden, and N. Zeldovich. Processing
analytical queries over encrypted data. In VLDB, 2013.
[65] M. Van Dijk and A. Juels. On the impossibility of cryptography alone
for privacy-preserving cloud computing. In USENIX Workshop on Hot
Topics in Security (HotSec), 2010.
[66] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. Efﬁcient
software-based fault isolation. In ACM Symposium on Operating Systems
Principles (SOSP), 1993.
[67] W. Wei, J. Du, T. Yu, and X. Gu. Securemr: A service integrity assurance
In Anual Computer Security Applications
framework for mapreduce.
Conference (ACSAC), 2009.
[68] C. Wright, L. Ballard, S. Coull, F. Monrose, and G. Masson. Spot me if
you can: Uncovering spoken phrases in encrypted VoIP conversations.
In IEEE Symposium on Security and Privacy, 2008.
[69] F. Zhang, J. Chen, H. Chen, and B. Zang. CloudVisor: Retroﬁtting
protection of virtual machines in multi-tenant cloud with nested virtual-
ization. In ACM Symposium on Operating Systems Principles (SOSP),
2011.
APPENDIX
A. Multi-User Key Exchange
We describe a variant of our basic key exchange protocol in
case there are several users u ∈ U, each contributing their
own set of input splits (using separate keys), and all getting
access to the output. For simplicity, it is assumed that online
communication channels between the involved parties exist.
It is though possible to implement the multi-user protocol as
regular MapReduce job without such channels the same way
it is described in §V-C for the single-user protocol.
1) Each user is still identiﬁed by its public encryption key
pku.
2) The users agree on the code to run; they exchange fresh
random shares ju, kcode,u, kjob,u, kout,u and compute
j = ⊕u∈U ju, kcode = ⊕u∈U kcode,u, kjob = ⊕u∈U kjob,u,
kout = ⊕u∈U kout,u. They then prepare the enclave
code Cj,u as above (using the same randomness for the
encryption), except that all their public keys (pku)u∈U
are included in the Cj,u package.
3) Each enclave prepares and sends the message of the base
protocol pw to every user, each encapsulating a distinct,
fresh, symmetric key kw,u. (The collection of messages
may be jointly quoted once by each effective QE.)
4) Each user independently receives, veriﬁes, and decrypts
then sends the encrypted job credentials
its message,
Encki,u []{kcode | kjob | kin,u | kinter ,u | kout | kprf ,u},
where kin,u, kout are the authenticated-encryption keys
for their input and the output ﬁle, and where kinter ,u and
kprf ,u are their fresh shares of the keys for the intermedi-
ate key-value pairs and the pseudo-random function PRF
respectively.
5) Each enclave decrypts all job credentials, checks that they
all provide the same keys kcode, kjob, kout, and computes
kinter = ⊕u∈U kinter ,u and kprf = ⊕u∈U kprf ,u.
At this stage, kcode, kjob, and kout are known to every user
and every enclave in the job; kin,u is known to every enclave
and to user u; kinter and kprf are known to every enclave
in the job, but not to any strict subset of users. VC3 does
currently not implement a multi-user key exchange but we
plan to support it in the future.
B. Lightweight Key Exchange
The in-band key exchange protocol (§V-C) implemented in our
VC3 prototype works well with existing Hadoop installations,
but requires executing a full (though lightweight) MapReduce
job just for exchanging keys.
In case the user is willing to put extended trust into a
special Support Enclave (SE), the necessity for a separate key
exchange job can be avoided while maintaining compatibility
with existing Hadoop installations. We brieﬂy describe a
corresponding protocol in the following.
As described in §V-A, we generally foresee the cloud
provider to deploy a Cloud QE to each of its SGX-enabled
nodes that is functionally equivalent to the standard SGX
QE. Here, a special Support Enclave (SE) with extended
functionality is deployed instead of such a Cloud QE. Instead
of an EPID private key, each SE creates and manages a node-
speciﬁc long-term RSA key pair that is permanently sealed to
local storage. Each SE acquires a quote from the regular local
SGX QE for its RSA public key. The cloud provider makes
the quoted public keys for all SEs available to the user. For
each SE, the user veriﬁes the quotes and sends
[Cj,u]{kcode | k} | PKEncpkSE
{ke}
Encke
where ke is a fresh job-speciﬁc ephemeral symmetric key.
Each SE decrypts ke and then veriﬁes Cj,u and decrypts
kcode | k. Subsequently, on each node, a new enclave con-
taining Cj,u is started. A mutually authenticated secure local
channel between E+ (running in the newly created enclave)
and SE is created using local attestation (see §II-B). The SE
passes kcode | k over this channel to E+. Finally, E+ decrypts
E− and the enclave is able to process job data afterwards.
In this protocol variant, the user needs to trust the SE
deployed by the cloud provider as it handles kcode and k in
the clear. In order to facilitate the establishment of this trust,
the cloud provider should make the source code of the SE
publicly available.
5454
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:08:24 UTC from IEEE Xplore.  Restrictions apply.