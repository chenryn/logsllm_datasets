GET /cgi-bin/phf?/etc/passwd may cause three alerts: one concerning
the presence of /etc/passwd in the URL, one concerning the presence of
/cgi-bin/phf and one concerning the success/failure of the request.
In other existing alert formats, source and target concepts are attributes of
the alerts [12,13]. Source and target implicitly refer to the source and target
of an attack. As events reﬂect the steps of an attack, we claim that the source
and the target concepts are hold by the events themselves. For IP events, the
source and the target are respectively the source IP address and the destination
IP address. Port numbers play that role for TCP events. The target information
may also be deduced from the location where an event was detected. This is the
case for all the events raised by HIDS, since IDS only monitor the host they are
running on.
Scans. Scan is a shorthand for “vulnerability scan”. A scan is a vulnerability
assessment provided by a vulnerability scanner (Nessus5 for instance) against a
speciﬁc host.
Like alerts, scans have a tool-speciﬁc report name (reportname). Scans are
generated by scanners (scan generator).
There are two major diﬀerences between scans and alerts. Firstly, scans are
not caused by events, since scans do not detect active vulnerabilities exploits.
However, it should be noted that to perform security tests, scanners generate
intrusive traﬃc which can cause IDS alerts. Alert correlation should take this
information into account.
The second diﬀerence is that while alert target information is carried by low
level events, the target is explicitly carried by the scan. Vulnerability assessments
are made against a host (scan host target) on a given port (scan port target).
IPEvents, TCPEvents, UDPEvents, HTTPEvents. These event types are
modeled in ﬁgure 9.
In Vigna’s model, a message is a triple (is, id, p), where is, id ∈ I are re-
spectively the source interface and the destination interface which belong to the
same link. p is the payload of the message.
5
http://www.nessus.org
M2D2: A Formal Data Model for IDS Alert Correlation
127
Deﬁnitions
U is the set of URL which have been raised by security tools.
Functions & Relations
→ NA
ip src, ip dst, idt ∈
EIP
EIP
ipayload ∈
(cid:9)→ ETCP ∪ EUDP
sp, dp ∈ ETCP ∪ EUDP → N
ETCP → N
seq, ack ∈
tpayload ∈ ETCP ∪ EUDP (cid:1) EHTTP
EHTTP → {GET,POST,HEAD}
httpmeth ∈
EHTTP → N
status ∈
EHTTP → U
url ∈
Comments
ip src, ip dst, idt Resp. source address, destination address and identiﬁcation
number of an IPv4 event,
sp, dp Resp. source port and destination port numbers of a TCP or
UDP event,
seq, ack Resp. sequence number and acknowledgement number of a TCP
event,
httpmeth Method of an HTTP request,
status Status of an HTTP request,
url URL of an HTTP request.
ipayload is a partial function because IP Event payload may not be avail-
able and thus is not provided by the security tool.
Fig. 9. M2D2 IP Events, TCP Events, UDP Events and HTTP Events
An IP datagram is a sequence of messages whose payload is a triple
(as, ad, p(cid:2)), where as, ad ∈ N are respectively the source and destination ad-
dresses of the IP datagram. The messages in the sequence represent the route of
the datagram.
An IP session is a sequence of IP datagrams and represents a conversation
between two hosts.
An UDP datagram is an IP datagram whose payload is a couple (ps, pd),
where ps,pd ∈ N are respectively the source port and the destination port of the
UDP datagram. An UDP session is a couple of UDP datagrams (request and
response).
Basically, a TCP segment is an IP datagram whose payload is a tuple
(ps,pd,s,a,F ,p(cid:2)(cid:2)), where ps,pd,s,a ∈ N are respectively the source port, the des-
tination port, the sequence number and the acknowledgement number, F is a
set of ﬂags and p(cid:2)(cid:2) is the payload of the TCP segment. A TCP session is an
IP session with constraints over the datagram attributes which are described in
Vigna’s model.
In the same way, a M2D2 TCP event (resp. an UDP event) is a TCP segment
(resp. an UDP datagram) in Vigna’s model.
128
B. Morin et al.
We do not model sessions in M2D2 yet because most current NIDS do not
work at the session level. However, extending M2D2 with sessions is straightfor-
ward since the M2D2 events are conceptually identical to the concepts found in
Vigna’s model.
An IP event is linked to its content with the ipayload function. In the same
way, TCP or UDP event are linked to their content (an application protocol like
HTTP for instance) with the tpayload function.
HTTP Events. An HTTP event models an HTTP interaction between a client
and a server. HTTP event attributes potentially reﬂect a complete HTTP inter-
action. Thus, we use the httpmeth, url, and status functions. Note that if only
a part of the interaction may be analyzed (that is the case for NIDS, which may
only have access to a part of the interaction), then a special value is assigned to
the event attribute.
HTTP Log events. Log events correspond to entries in HTTP server logs. An
HTTP server log entry contains an HTTP event, and an identiﬁer of the requester
(either its IP address or its host name). That mix of information coming from
two diﬀerent protocol layers raises a modeling problem. We thus had to introduce
a speciﬁc kind of events, the HTTP Log events. That kind of events reﬂect the
contents of a HTTP server log.
3 Alert Correlation Using M2D2
A ﬁrst step towards alert correlation is alert aggregation. It consists in grouping
alerts following various criteria. In this section, we propose three relevant exam-
ples of aggregation methods which use many M2D2 concepts. As these concepts
are deﬁned in an unambiguous way, the aggregation methods are rigorously ex-
pressed. M2D2 contribution to alert correlation resides in the use of relations
between vulnerabilities and topology, between topology and security tools, as
well as between security tools and vulnerabilities to model alert aggregation
methods.
3.1 Aggregation of Alerts Referring a Single Host
The goal of the common target aggregation function (cf ﬁgure 10) is to group
alerts referring to a given target host. This set is made of two subsets: one con-
tains the alerts generated by HIDS running on the host, and the other contains
alerts generated by NIDS having detected malicious IP events destined to the
host.
As HIDS monitor a single host (cf ﬁgure 7, monitored host), the set of alerts
referring to a host is equal to the set of alerts generated by the HIDS monitoring
the host. We call this aggregation function hids target (cf ﬁgure 10).
M2D2: A Formal Data Model for IDS Alert Correlation
129
Functions & Relations
hids target ∈ H ↔ EA
nids target ∈ H ↔ EA
common target ∈ H ↔ EA
belongs to host ∈ I → H
Properties
hids target = monitored host
nids target = addr; ip dst
i belongs to host h ⇐⇒ i ∈ h
−1; alert generator
−1
−1; causes
common target = hids target ∪ nids target
Fig. 10. The common target aggregation function referring the same target host
sub conﬁg ∈ ran(aﬀects) ↔ ran(conﬁguration)
Functions & Relations
EA
relative vulns ∈
EA
harmful ∈
↔ VN
↔ H
Properties
v sub conﬁg c ⇐⇒ v ⊂ c
relative vulns = reportname; refersto; equiv
harmful = relative vulns; vulname
−1; aﬀects; sub conﬁg; conﬁguration
−1
Fig. 11. The successful attacks identiﬁcation function
An intermediate relation is required to uniquely identify a host from a net-
work interface (this is a function because hosts partition the interface set, cf
ﬁgure 10). We call this function belongs to host (cf 16).
NIDS monitor an interface which has access to a stream of network events,
some of which being destined to the host under consideration. The aggregation
function, nids target (cf ﬁgure 10) consists in aggregating all the alerts caused
by IP events whose IP destination address maps to one of the host interfaces.
3.2
Identiﬁcation of the Hosts Vulnerable to an Attack Occurrence
The successful attack identiﬁcation function, called harmful (cf ﬁgure 11), applies
to a single alert and gives the set of hosts on which the attack may work. In
other words, it gives information about the success of the attack.
An attack may be successful if one of the conﬁgurations aﬀected by the
vulnerability which is exploited by the attack really exists on some hosts in the
information system. For example, an attack exploiting a ProFTP vulnerability
against a WU-ftp server may not work. Thus the attack severity is low. That does
130
B. Morin et al.
not mean that the attack should not be reported (it is still an attack attempt),
but its severity may be lowered.
A vulnerability v ∈ V exists on a host if the host conﬁguration is a superset
of at least one of v vulnerable conﬁgurations. Thus, we introduce the sub conﬁg
(cf ﬁgure 11) relation, which maps all the vulnerability conﬁgurations with all
the host conﬁgurations. sub conﬁg provides all the vulnerabilities exhibited by
a given host, and sub conﬁg−1 provides all the hosts which exhibit a given
vulnerability. Building and updating the sub conﬁg relation in batch mode is
required for eﬃciency because evaluating existing vulnerabilities in real time
would be prohibited.
We introduce the relative vulns relation which applies to an alert and maps
the vulnerability names the alert report name refers to. From an alert relative
vulnerability set, we get the corresponding CVE vulnerability subset, and then
the vulnerable conﬁgurations set is extracted. Thanks to the sub conﬁg relation,
we get the set of vulnerable host conﬁgurations. Lastly, applying conﬁguration−1
to the host conﬁguration set provides the set of hosts which are vulnerable.
3.3 Detecting False Positives
In this section we present a correlation function which is a way to detect false
positives. When an IDS generates an alert, it is relevant to check if all the IDS
which were able to detect the events causing the alarm did generate an alert too.
When an IDS generates an alert, a simple sanity check is to verify that others
able to both process the events and create the alert did so. If this constraint is
veriﬁed, then the alert likelihood is reinforced. If not, the proper behavior of all
IDSes should be checked to decide whether the one sending the alert is providing
the wrong diagnosis or whether the others are misbehaving.
Let us consider an alert a ∈ EA. We ﬁrst need to identify the alerts which
are similar to a. That is, we need to know which alerts are caused by the same
set of events. Once we have the set of similar alerts, we can know which set
of IDS raised them. Finally, we have to compare this set with the set of IDS
which were able to detect the events (the ability of an IDS to detect events and
generate alerts depends on its topological visibility and its operational visibility
(cf section 2.4)).
In the following, we ﬁrst describe two methods to identify similar alerts.
We then show how to get the set of IDS which did react. Lastly, we propose a
function to get the potentially reactive IDS set (i.e the set of IDS which could
react to an attack).
Alerts similarity. In Howard’s classiﬁcation [14], an attack is a series of actions
taken by an attacker to achieve an unauthorized result. Events result from these
actions. As it has been described in section 2, one or more alerts may result
from every each event. Determining the likelyhood of an alert can be achieved
by enumerating the IDS which also generated an alert for a single action (be it
from an attack or from a legitimate action which is believed malicious). We call
M2D2: A Formal Data Model for IDS Alert Correlation
131
Deﬁnitions
ip= ∈ EIP ↔ EIP
∀i1, i2 ∈ EIP, i1
ip=i2 ⇐⇒
ip src(i1) = ip src(i2) ∧ ip dst(i1) = ip dst(i2)
∧ idt(i1) = idt(i2)
∧ |tstamp(i1) − tstamp(i2)| < ε
∃i3 ∈ EIP, such that i1 = i3 ∧ i2 = i3
OR
sim alert ip ∈ EA ↔ EA
Properties
ip= is an equivalence relation.
sim alert ip = (causes
sim alert ip[{a}] is the set of alerts which are caused by the same IP event as a.
−1; ip=; causes)
Fig. 12. Alerts caused by the same IP event
alerts caused by a single action similar alerts. Several ways to aggregate alerts
are possible, for example:
– aggregating alerts caused by the same event
– aggregating alerts referring to the same vulnerability
– aggregating alerts caused by events belonging to the same TCP/IP session
– aggregating alerts on a temporal relation basis
In the remainder of this section, we illustrate the ﬁrst two examples of similar
alerts aggregation methods.
Aggregating alerts through events. Several alerts can be generated from a single
event either because more than one triggers within the same IDS matches the
event (a trigger is a condition fulﬁllment leading an IDS to generate an alert), or
because more than one IDS have access to the event itself. Thus, alerts caused
by the same events should be aggregated. We call events causing an alert causal
events. It should be noted that two alerts do not need to have the same set of
causal events to be aggregated: alerts can be aggregated if they have at least
one causal event in common. For example, a suspicious HTTP request can be
detected by a NIDS (A) and by an application-based IDS (B). A alert is caused
by an HTTP event and the underlying network layers event. B alert is caused
by an HTTP event, which is part of a web server log occurrence. Thus, A and
B do not have the same set of causal events; the HTTP event is the only one
they have in common. However, A alert and B alert are aggregated because they
have one causal event in common.