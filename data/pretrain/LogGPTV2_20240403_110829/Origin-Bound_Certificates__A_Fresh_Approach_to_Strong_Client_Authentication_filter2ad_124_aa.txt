title:Origin-Bound Certificates: A Fresh Approach to Strong Client Authentication
for the Web
author:Michael Dietz and
Alexei Czeskis and
Dirk Balfanz and
Dan S. Wallach
Origin-Bound Certiﬁcates: A Fresh Approach to Strong Client
Authentication for the Web
Michael Dietz
Rice University
PI:EMAIL
Alexei Czeskis
University of Washington
PI:EMAIL
Dirk Balfanz∗
Google Inc.
PI:EMAIL
Dan S. Wallach
Rice University
PI:EMAIL
Abstract
Client authentication on the web has remained in the
internet-equivalent of the stone ages for the last two
decades. Instead of adopting modern public-key-based
authentication mechanisms, we seem to be stuck with
passwords and cookies.
In this paper, we propose to break this stalemate by
presenting a fresh approach to public-key-based client
authentication on the web. We describe a simple TLS
extension that allows clients to establish strong authenti-
cated channels with servers and to bind existing authen-
tication tokens like HTTP cookies to such channels. This
allows much of the existing infrastructure of the web to
remain unchanged, while at the same time strengthening
client authentication considerably against a wide range
of attacks.
We implemented our system in Google Chrome and
Google’s web serving infrastructure, and provide a per-
formance evaluation of this implementation.
1
Introduction
In the summer of 2011, several reports surfaced of at-
tempted man-in-the-middle attacks against Google users
who were primarily located in Iran. The Dutch certiﬁ-
cation authority DigiNotar had apparently issued certiﬁ-
cates for google.com and other websites to entities not
aﬃliated with the rightful owners of the domains in ques-
tion1. Those entities were then able to pose as Google
and other web entities and to eavesdrop on the commu-
nication between users’ web browsers and the websites
they were visiting. One of the pieces of data such eaves-
droppers could have conceivably recorded were authen-
tication cookies, meaning that the man-in-the-middle
∗The opinions expressed here are those of the authors and do not
necessarily reﬂect the position of Google.
1It later turned out that the certiﬁcates had, in fact, been created
fraudulently by attackers that had compromised DigiNotar.
could have had full control over user accounts, even after
the man-in-the-middle attack itself was over.
This attack should have never been possible: authen-
ticating a client to a server while defeating man-in-the-
middle attacks is theoretically a solved problem. Simply
put, client and server can use an authenticated key agree-
ment protocol to establish a secure permanent “channel.”
Once this channel is set up, a man-in-the-middle cannot
“pry it open”, even with stolen server certiﬁcates.
Unfortunately, this is not how authentication works on
the web. We neither use sophisticated key agreement
protocols, nor do we establish authenticated “channels.”
Instead, we send secrets directly from clients to servers
with practically every request. We do this across all lay-
ers of the network stack. For example, to authenticate
users, passwords are sent from clients to servers; SAML
or OpenID assertions are sent from clients to servers in
order to extend such user authentication from one web-
site to another; and HTTP cookies are sent with every
HTTP request after the initial user authentication in or-
der to authenticate that HTTP request.
We call this pattern bearer tokens:
the bearer of a
token is granted access, regardless of the channel over
which the token is presented, or who presented it2.
Unfortunately, bearer tokens are susceptible to cer-
tain classes of attacks. Speciﬁcally, an adversary that
manages to steal a bearer token from a legitimate user
can impersonate that user to web services that require
it. For diﬀerent kinds of bearer tokens these attacks
come in diﬀerent ﬂavors: passwords are usually ob-
tained through phishing or keylogging, while cookie
theft happens through man-in-the-browser malware (e.g.,
Zeus [16]), cross site scripting attacks, or adversaries that
manage to sniﬀ the network or insert themselves into the
network between the client and server [1, 7]).
The academic community, of course, has known of
authentication mechanisms that avoid the weaknesses of
2Bearer tokens, originally called “sparse capabilities” [25], were
widely used in distributed systems, well before the web.
bearer tokens since before the dawn of the web. These
mechanisms usually employ some form of public-key
cryptography rather than a shared secret between client
and server. Authentication protocols based on public-
key cryptography have the beneﬁt of not exposing secrets
to the eavesdropper which could be used to impersonate
the client to the server. Furthermore, when public/private
key pairs are involved, the private key can be moved out
of reach of thieving malware on the client, perhaps us-
ing a hardware Trusted Platform Module (TPM). While
in theory this problem seems solved, in practice we have
seen attempts to rid the web of bearer tokens gain near-
zero traction [10] or fail outright [13].
In this paper, we present a fresh approach to using
public-key mechanisms for strong authentication on the
web. Faced with an immense global infrastructure of
existing software, practices and network equipment, as
well as users’ expectations of how to interact with the
web, we acknowledge that we cannot simply “reboot”
the web with better (or simply diﬀerent) authentication
mechanisms. Instead, after engaging with various stake-
holders in standards bodies, browser vendors, operators
of large website, and the security, privacy and usability
communities, we have developed a layered solution to
the problem, each layer consisting of minor adjustments
to existing mechanisms across the network stack.
The key contributions of this work are:
• We present a slight modiﬁcation to TLS client au-
thentication, which we call TLS-OBC. This new
primitive is simple and powerful, allowing us to cre-
ate strong TLS channels.
• We demonstrate how higher-layer protocols like
HTTP, federation protocols, or even application-level
user login can be hardened by “binding” tokens at
those layers to the authenticated TLS channel.
• We describe our eﬀorts in gaining community sup-
port for an IETF draft [2], as well as support from
major browser vendors; both Google’s Chrome and
Mozilla’s Firefox have begun to incorporate and test
support for TLS-OBC.
• We present a detailed report on our client-side im-
plementation in the open-source Chromium browser,
and our server-side implementation inside the serv-
ing infrastructure of a large website.
• We give some insight into the process that led to
the proposal as presented here, contrasting it with
existing work and explaining real-world constraints,
ranging from privacy expectations that need to be
weighed against security requirements, to deploy-
ment issues in large datacenters.
Summary.
The main idea of this work is easily
explained: browsers use self-signed client certiﬁcates
within TLS client authentication. These certiﬁcates are
generated by the browser on-the-ﬂy, as needed, and con-
tain no user-identifying information. They merely serve
as a foundation upon which to establish an authenticated
channel that can be re-established later.
The browser generates a diﬀerent certiﬁcate for every
website to which it connects, thus defeating any cross-
site user tracking. We therefore call these certiﬁcates
origin-bound certiﬁcates (OBCs). This design choice
also allows us to completely decouple certiﬁcate gener-
ation and use from the user interface; TLS-OBC client
authentication allows the existing web user experience
to remain the same, despite the changes under the hood.
Since the browser will consistently use the same client
certiﬁcate when establishing a TLS connection with an
origin, the website can “bind” authentication tokens (e.g.,
HTTP cookies) to the OBC, thereby creating an authen-
ticated channel. This is done by simply recording which
client certiﬁcate should be used at the TLS layer when
submitting the token (i.e., cookie) back to the server. It
is at this layer (in the cookie, not in the TLS certiﬁcate)
that we establish user identity, just as it is usually done
on the web today.
TLS-OBC’s channel-binding mechanism prevents
stolen tokens (e.g., cookies) from being used over other
TLS channels, thereby making them useless to token
thieves, solving a large problem in today’s web.
2 Threat Model
We consider a fairly broadly-scoped (and what we be-
lieve to be a real-world) threat model. Speciﬁcally, we
assume that attackers are occasionally able to “pry open”
TLS sessions and extract the enclosed sensitive data by
exploiting a bug in the TLS system [22], mounting a man
in the middle (MITM) attack through stolen server TLS
certiﬁcates [1], or utilizing man-in-the-browser mal-
ware [16]. These attacks not only reveal potentially pri-
vate data, but in today’s web will actually allow attack-
ers to impersonate and completely compromise user ac-
counts by capturing and replaying users’ authentication
credentials (which, as we noted earlier, are usually in the
form of bearer tokens). These attacks are neither theo-
retical nor purely academic; they are being employed by
adversaries in the wild [24].
In this paper we focus on the TLS and HTTP lay-
ers of the protocol stack, and on protecting the authen-
tication tokens at those layers—mostly HTTP cookies
(but also identity assertions in federation protocols)—by
binding them to the underlying authenticated TLS-OBC
channel. We have a parallel eﬀort under way to pro-
tect the application-layer user logins, but that is mostly
outside the scope of this paper. To model this distinc-
tion, we consider two classes of attacker. The ﬁrst class
is an attacker that has managed to insert themselves as
a MITM during the initial authentication step (when
the user trades his username/password credentials for a
cookie), or an attacker that steals user passwords through
a database compromise or phishing attack. The second
class of attacker is one that has inserted themself as a
MITM after the initial user authentication step where
credentials are traded for an authentication token. The
ﬁrst class of attacker is strictly stronger than the second
class of attacker as a MITM that can directly access a
user’s credentials can trade them in for an authentication
token at his leisure. While the second class of attacker,
a MITM that can only steal the authentication token, has
a smaller window of opportunity (the duration for which
the cookie is valid) for access to the user’s private infor-
mation.
For the purposes of this paper, we choose to focus on
the second class of attacker. In short, we assume that the
user has already traded their username/password creden-
tials to acquire an authentication token that will persist
across subsequent connections. Our threat model allows
for attackers to exploit MITM or eavesdropping attacks
during any TLS handshake or session subsequent to the
initial TLS connection to a given endpoint—including at-
tacks that cause a user to re-authenticate as discussed in
Section 4.3. Attacks that target user credentials during
the initial TLS connection, rather than authentication to-
kens during subsequent TLS connections, are dealt with
in a forthcoming report.
3 TLS-OBC
We propose a slightly modiﬁed version of traditional
TLS client certiﬁcates, called Origin-Bound Certiﬁcates
(OBCs), that will enable a number of useful applications
(as discussed in Section 4).
3.1 Overview
Fundamentally, an Origin-Bound Certiﬁcate is a self-
signed certiﬁcate that browsers use to perform TLS
Client Authentication. Unlike normal certiﬁcates, and
their use in TLS Client Authentication (see Section 8.1),
OBCs do not require any interaction with the user.
This property stems from the observation that since the
browser generates and stores only one certiﬁcate per ori-
gin, it’s always clear to the browser which certiﬁcate it
must use; no user input is necessary to make the deci-
sion.
On-Demand Certiﬁcate Creation If the browser does
not have an existing OBC for the origin it’s connecting
to, a new OBC will be created on-the-ﬂy. This newly
generated origin-bound certiﬁcate contains no user iden-
tifying information (e.g., name or email).
Instead, the
OBC is used only to prove, cryptographically, that sub-
sequent TLS sessions to a given server originate from the
same client, thus building a continuous TLS channel3,
even across diﬀerent TLS sessions.
User Experience As noted earlier, there is no user in-
terface for creating or using Origin-Bound Certiﬁcates.
This is similar to the UI for HTTP cookies; there is typi-
cally no UI when a cookie is set nor when it is sent back
to the server. Origin-Bound Certiﬁcates are similar to
cookies in other ways as well:
• Clients uses a diﬀerent certiﬁcate for each origin.
Unless the origins collaborate, one origin cannot dis-
cover which certiﬁcate is used for another.
• Diﬀerent browser proﬁles use diﬀerent Origin-Bound
• In incognito or private browsing mode, the Origin-
Bound Certiﬁcates used during the browsing session
get destroyed when the user closes the incognito or
private browsing session.
• In the same way that browsers provide a UI to in-
spect and clean out cookies, there should be a UI that
allows users to reset their Origin-Bound Certiﬁcates.
Certiﬁcates for the same origin.
3.2 The Origin-Bound Certiﬁcates TLS
Extension
OBCs do not alter the semantics of the TLS handshake
and are sent in exactly the same manner as traditional
client certiﬁcates. However, because they are generated
on-the-ﬂy and have no associated UI component, we
must diﬀerentiate TLS-OBC from TLS client-auth and
treat it as a distinct TLS extension. Figure 1 shows, at
a high level, how this extension ﬁts in with the normal
TLS handshake protocol; the speciﬁcs of the extension
are explained below.
The ﬁrst step in the client-server decision to use OBCs
occurs when the client advertises acceptance of the TLS-
OBC extension in its initial ClientHello message. If
the server chooses to accept the use of OBCs, it echoes
the TLS-OBC extension identiﬁer in its ServerHello
message. At this point, the client and server are consid-
ered to have negotiated to use origin-bound client certiﬁ-
cates for the remainder of the TLS session.
After OBCs have been negotiated, the server sends a
CertificateRequest message to the client that spec-
iﬁes the origin-bound certiﬁcate types that it will ac-
cept (ECDSA, RSA, or both). Upon a client’s receipt
of the CertificateRequest, if the client has already
generated an OBC associated with the server endpoint,
3We use the same notion as TAOS [27] does, of a cryptographically
strong link between two nodes.
Figure 1: TLS-OBC extension handshake ﬂow.
Figure 2: Process of setting an OBC bound cookie
the existing OBC is returned to the server in the client’s
ClientCertificate message. If this is the ﬁrst con-
nection to the server endpoint or if no acceptable existing
OBC can be found, an origin-bound certiﬁcate must be
generated by the client then delivered to the server in the
client’s ClientCertificate message.
During the OBC generation process, the client cre-
ates a self-signed client certiﬁcate with common and dis-
tinguished names set to “anonymous.invalid” and an
X509 extension that speciﬁes the origin for which the
OBC was generated.
4 Securing Web Authentication Mecha-
nisms with TLS-OBC
We now show how origin-bound certiﬁcates can be used
to strengthen other parts of the network stack: In Sec-
tion 4.1 we explain how HTTP cookies can be bound to
TLS channels using TLS-OBC. In Section 4.2 we show
how federation protocols (such as OpenID or OpenID
Connect) can be hardened against attackers, and in Sec-
tion 4.3 we turn brieﬂy to application-level user authen-
tication protocols.
4.1 Channel-binding cookies