# Title: Origin-Bound Certificates: A Fresh Approach to Strong Client Authentication for the Web

## Authors
- Michael Dietz, Rice University, [Email]
- Alexei Czeskis, University of Washington, [Email]
- Dirk Balfanz, Google Inc., [Email]
- Dan S. Wallach, Rice University, [Email]

## Abstract
Client authentication on the web has remained largely unchanged over the past two decades, with most systems still relying on passwords and cookies. This paper introduces a new approach to public-key-based client authentication on the web. We propose a simple TLS extension that allows clients to establish strong authenticated channels with servers and bind existing authentication tokens, such as HTTP cookies, to these channels. This approach enhances security while maintaining compatibility with existing web infrastructure. We implemented our system in Google Chrome and Googleâ€™s web serving infrastructure, and we provide a performance evaluation.

## 1. Introduction
In the summer of 2011, reports emerged of man-in-the-middle (MITM) attacks targeting Google users, primarily in Iran. The Dutch certification authority DigiNotar had issued fraudulent certificates for google.com and other websites, allowing attackers to impersonate these sites and eavesdrop on user communications. This incident highlighted the vulnerability of current web authentication mechanisms, particularly the use of bearer tokens like HTTP cookies, which can be stolen and reused by attackers.

### Bearer Tokens and Their Vulnerabilities
Bearer tokens, such as passwords and HTTP cookies, are widely used for authentication on the web. These tokens are sent directly from clients to servers with each request, making them susceptible to various attacks. For example, passwords can be obtained through phishing or keylogging, while cookies can be stolen via man-in-the-browser malware, cross-site scripting (XSS) attacks, or network interception.

### Public-Key Cryptography and Authentication
Public-key-based authentication mechanisms, which have been known in the academic community for decades, offer a more secure alternative. These mechanisms do not expose secrets to eavesdroppers and can use hardware security modules, such as Trusted Platform Modules (TPMs), to protect private keys. However, attempts to implement these mechanisms on the web have seen limited success.

### Our Approach
In this paper, we present a new approach to using public-key mechanisms for strong client authentication on the web. We acknowledge the need to work within the existing web infrastructure and user expectations. Our solution involves minor adjustments to existing protocols across the network stack, including a slight modification to TLS client authentication, which we call TLS-OBC (Origin-Bound Certificates).

#### Key Contributions
- **TLS-OBC**: A simple and powerful modification to TLS client authentication that enables the creation of strong TLS channels.
- **Token Binding**: We demonstrate how higher-layer protocols, such as HTTP and federation protocols, can be hardened by binding tokens to the authenticated TLS channel.
- **Community Support**: We describe our efforts to gain support for an IETF draft and the implementation of TLS-OBC in major browsers, including Google Chrome and Mozilla Firefox.
- **Implementation Details**: We provide a detailed report on our client-side implementation in the open-source Chromium browser and our server-side implementation in a large website's serving infrastructure.
- **Real-World Constraints**: We discuss the process that led to our proposal, including real-world constraints such as privacy expectations and deployment issues in large data centers.

### Summary
The core idea is to use self-signed client certificates within TLS client authentication. These certificates, called Origin-Bound Certificates (OBCs), are generated by the browser on-the-fly and contain no user-identifying information. OBCs allow the establishment of authenticated channels that can be re-established later. By binding authentication tokens (e.g., HTTP cookies) to these OBCs, we prevent stolen tokens from being used over other TLS channels, significantly enhancing security.

## 2. Threat Model
We consider a broad threat model that includes MITM attacks, exploitation of TLS bugs, and man-in-the-browser malware. These attacks can compromise user accounts by capturing and replaying authentication credentials, typically in the form of bearer tokens. We focus on protecting authentication tokens at the TLS and HTTP layers by binding them to the underlying authenticated TLS-OBC channel.

### Classes of Attackers
- **First Class**: Attackers who can insert themselves as a MITM during the initial authentication step or steal user passwords.
- **Second Class**: Attackers who can only steal authentication tokens after the initial authentication step.

For this paper, we focus on the second class of attackers, assuming that the user has already traded their username/password credentials for an authentication token.

## 3. TLS-OBC
We propose a modified version of traditional TLS client certificates, called Origin-Bound Certificates (OBCs), to enable several useful applications.

### 3.1 Overview
An OBC is a self-signed certificate used by browsers for TLS client authentication. Unlike normal certificates, OBCs do not require any user interaction. The browser generates and stores one certificate per origin, ensuring that it always knows which certificate to use.

#### On-Demand Certificate Creation
If the browser does not have an existing OBC for the origin, a new OBC is created on-the-fly. This certificate contains no user-identifying information and is used solely to prove that subsequent TLS sessions originate from the same client.

#### User Experience
There is no user interface for creating or using OBCs, similar to HTTP cookies. Different browser profiles use different OBCs, and OBCs are destroyed in incognito or private browsing modes. Users should have a UI to inspect and reset their OBCs.

### 3.2 The Origin-Bound Certificates TLS Extension
OBCs do not alter the semantics of the TLS handshake but are sent in the same manner as traditional client certificates. To differentiate TLS-OBC from standard TLS client-auth, we treat it as a distinct TLS extension.

#### Handshake Flow
1. The client advertises acceptance of the TLS-OBC extension in its initial ClientHello message.
2. If the server accepts, it echoes the TLS-OBC extension identifier in its ServerHello message.
3. The server sends a CertificateRequest message specifying the accepted OBC types (ECDSA, RSA, or both).
4. The client returns the existing OBC or generates a new one and sends it in the ClientCertificate message.

During OBC generation, the client creates a self-signed certificate with common and distinguished names set to "anonymous.invalid" and an X509 extension specifying the origin.

## 4. Securing Web Authentication Mechanisms with TLS-OBC
We show how OBCs can be used to strengthen other parts of the network stack:

### 4.1 Channel-binding Cookies
HTTP cookies can be bound to TLS channels using TLS-OBC. When a cookie is set, the browser records the corresponding OBC. Subsequent requests must include the correct OBC to validate the cookie, preventing stolen cookies from being used over other TLS channels.

### 4.2 Hardening Federation Protocols
Federation protocols, such as OpenID and OpenID Connect, can be hardened by binding identity assertions to the authenticated TLS channel. This prevents stolen assertions from being misused.

### 4.3 Application-Level User Authentication
We briefly discuss how application-level user authentication protocols can be enhanced by integrating OBCs, ensuring that user credentials are protected against MITM and other attacks.

This paper provides a comprehensive approach to enhancing web security through the use of Origin-Bound Certificates, addressing both theoretical and practical challenges.