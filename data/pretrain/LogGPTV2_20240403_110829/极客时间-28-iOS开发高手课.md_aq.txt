## 通过内存警告获取内存限制值通过 XNU 的宏获取内存限制，需要有 root 权限，而 App内的权限是不够的，所以正常情况下，作为 App开发者你是看不到这个信息的。那么，如果你不想越狱去获取这个权限的话，还可以利用didReceiveMemoryWarning 这个内存压力代理事件来动态地获取内存限制值。iOS 系统在强杀掉 App 之前还有 6秒钟的时间，足够你去获取记录内存信息了。那么，**如何获取当前内存使用情况呢？**iOS 系统提供了一个函数 task_info，可以帮助我们获取到当前任务的信息。关键代码如下：    struct mach_task_basic_info info;mach_msg_type_number_t size = sizeof(info);kern_return_t kl = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &size);代码中，task_info_t 结构里包含了一个 resident_size字段，用于表示使用了多少内存。这样，我们就可以获取到发生内存警告时，当前App 占用了多少内存。代码如下：    float used_mem = info.resident_size;NSLog(@" 使用了 %f MB 内存 ", used_mem / 1024.0f / 1024.0f)
## 定位内存问题信息收集现在，我们已经可以通过三种方法来获取内存上限值了，而且通过内存警告的方式还能够动态地获取到这个值。有了这个内存上限值以后，你就可以进行内存问题的信息收集工作了。要想精确地定位问题，我们就需要 dump出完整的内存信息，包括所有对象及其内存占用值，在内存接近上限值的时候，收集并记录下所需信息，并在合适的时机上报到服务器里，方便分析问题。获取到了每个对象的内存占用量还不够，你还需要知道是谁分配的内存，这样才可以精确定位到问题的关键所在。一个对象可能会在不同的函数里被分配了内存并被创建了出来，当这个对象内存占用过大时，如果不知道是在哪个函数里创建的话，问题依然很难精确定位出来。那么，**怎样才能知道是谁分配的内存呢？**这个问题，我觉得应该从根儿上去找答案。内存分配函数 malloc 和 calloc等默认使用的是 nano_zone。nano_zone 是 256B 以下小内存的分配，大于 256B的时候会使用 scalable_zone 来分配。在这里，我主要是针对大内存的分配监控，所以只针对 scalable_zone进行分析，同时也可以过滤掉很多小内存分配监控。比如，malloc 函数用的是malloc_zone_malloc，calloc 用的是 malloc_zone_calloc。使用 scalable_zone 分配内存的函数都会调用 malloc_logger函数，因为系统总是需要有一个地方来统计并管理内存的分配情况。具体实现的话，你可以查看 malloc_zone_malloc 函数的实现，代码如下：    void *malloc_zone_malloc(malloc_zone_t *zone, size_t size){MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0);void *ptr;if (malloc_check_start && (malloc_check_counter++ >= malloc_check_start)) {internal_check();}if (size > MALLOC_ABSOLUTE_MAX_SIZE) {return NULL;}ptr = zone->malloc(zone, size);// 在 zone 分配完内存后就开始使用 malloc_logger 进行进行记录if (malloc_logger) {malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0);}MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0);return ptr;}其他使用 scalable_zone分配内存的函数的方法也类似，所有大内存的分配，不管外部函数是怎么包装的，最终都会调用malloc_logger 函数。这样的话，问题就好解决了，你可以使用 fishhook 去Hook这个函数，加上自己的统计记录就能够通盘掌握内存的分配情况。出现问题时，将内存分配记录的日志捞上来，你就能够跟踪到导致内存不合理增大的原因了。
## 小结为了达到监控内存的目的，我们需要做两件事情：一是，能够根据不同机器和系统获取到内存有问题的那个时间点；二是，到了出现内存问题的那个时间点时，还能要取到足够多的可以分析内存问题的信息。针对这两件事，我在今天这篇文章里和你分享了在 JetsamEvent 日志里、在 XNU代码里、在 task_info函数中怎么去找内存的上限值。然后，我和你一起分析了在内存到达上限值时，怎么通过内存分配时都会经过的malloc_logger 函数来掌握内存分配的详细信息，从而精确定位内存问题。说到这里你可能会回过头来想，为什么用于占用内存过大时会被系统强杀呢？macOS打开一堆应用也会远超物理内存，怎么没见系统去强杀 macOS 的应用呢？其实，这里涉及到的是设备资源的问题。苹果公司考虑到手持设备存储空间小的问题，在iOS系统里去掉了交换空间，这样虚拟内存就没有办法记录到外部的存储上。于是，苹果公司引入了MemoryStatus 机制。这个机制的主要思路就是，在 iOS系统上弹出尽可能多的内存供当前应用使用。把这个机制落到优先级上，就是先强杀后台应用；如果内存还不够多就强杀掉当前应用。而在macOS 系统里，MemoryStatus 只会强杀掉标记为空闲退出的进程。在实现上，MemoryStatus 机制会开启一个 memorystatus_jetsam_thread的线程。这个线程，和内存压力监测线程 vm_pressure_monitor没有联系，只负责强杀应用和记录日志，不会发送消息，所以内存压力检测线程无法获取到强杀应用的消息。除内存过大被系统强杀这种内存问题以外，还有以下三种内存问题：-   访问未分配的内存： XNU 会报 EXC_BAD_ACCESS 错误，信号为 SIGSEGV    Signal #11 。-   访问已分配但未提交的内存：XNU    会拦截分配物理内存，出现问题的线程分配内存页时会被冻结。-   没有遵守权限访问内存：内存页面的权限标准类似 UNIX    文件权限。如果去写只读权限的内存页面就会出现错误，XNU 会发出 SIGBUS    Signal #7 信号。第一种和第三种问题都可以通过崩溃信息获取到，在收集崩溃信息时如果发现是这两类，我们就可以把内存分配的记录同时传过来进行分析，对于不合理的内存分配进行优化和修改。
## 课后小作业我今天提到了定位内存问题需要获取更多的信息，比如内存分配。那么，请你来根据我们今天所讲的hook malloc_logger 的方法，来实现一个记录内存分配的小工具吧。感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。![](Images/0e2ff493da248888e66ed0aa4e0251a2.png){savepage-src="https://static001.geekbang.org/resource/image/f5/27/f5ee90aa0183a4bcc688980bd625eb27.jpg"}
# 15 \| 日志监控：怎样获取 App 中的全量日志？你好，我是戴铭。我在前面的第 12、13 和 14三篇文章中，和你分享了崩溃、卡顿、内存问题的监控。一旦监控到问题，我们还需要记录下问题的详细信息，形成日志告知开发者，这样开发者才能够从这些日志中定位问题。但是，很多问题的定位仅靠问题发生的那一刹那记录的信息是不够的，我们还需要依赖更多的日志信息。在以前公司还没有全量日志的时候，我发现线上有一个上报到服务器的由数据解析出错而引起崩溃的问题。由于数据解析是在生成数据后在另一个线程延迟执行的，所以很难定位到是谁生成的数据造成了崩溃。如果这个时候，我能够查看到崩溃前的所有日志，包括手动打的日志和无侵入自动埋点的日志，就能够快速定位到是由谁生成的数据造成了崩溃。这些在App里记录的所有日志，比如用于记录用户行为和关键操作的日志，就是全量日志了。有了更多的信息，才更利于开发者去快速、精准地定位各种复杂问题，并提高解决问题的效率。那么，**怎样才能够获取到App 里更多的日志呢**？你可能会觉得获取到全量的日志很容易啊，只要所有数据都通过相同的打日志库，不就可以收集到所有日志了吗？但，现实情况并没有这么简单。一个 App很有可能是由多个团队共同开发维护的，不同团队使用的日志库由于历史原因可能都不一样，要么是自己开发的，要么就是使用了不同第三方日志库。如果我们只是为了统一获取日志，而去推动其他团队将以前的日志库代码全部替换掉，明显是不现实的。因为，我们谁也无法确定，这种替换日志库的工作，以后是不是还会再来一次。``{=html}那么，我们还有什么好办法来解决这个问题吗？在我看来，要解决这个问题，我们就需要先逐个地分析各团队使用的日志库，使用不侵入的方式去获取所有日志。接下来，我就先和你说说怎样获取系统自带 NSLog 的日志。
## 获取 NSLog 的日志我们都知道，NSLog 其实就是一个 C 函数，函数声明是：    void NSLog(NSString *format, ...);它的作用是，输出信息到标准的 Error控制台和系统日志（syslog）中。在内部实现上，它其实使用的是 ASL（AppleSystem Logger，是苹果公司自己实现的一套输出日志的接口）的API，将日志消息直接存储在磁盘上。那么，**我们如何才能获取到通过 ASL 存放在系统日志中的日志呢？**ASL 会提供接口去查找所有的日志，通过CocoaLumberjack](https://github.com/CocoaLumberjack/CocoaLumberjack)这个第三方日志库里的 DDASLLogCapture 这个类，我们可以找到实时捕获 NSLog的方法。DDASLLogCapture 会在 start 方法里开启一个异步全局队列去捕获 ASL存储的日志。start 方法的代码如下：    + (void)start {    ...    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void) {        [self captureAslLogs];    });}可以看出，捕获 ASL 存储日志的主要处理都在 captureAslLogs方法里。在日志被保存到 ASL的数据库时，syslogd（系统里用于接收分发日志消息的日志守护进程）会发出一条通知。因为发过来的这一条通知可能会有多条日志，所以还需要先做些合并的工作，将多条日志进行合并。具体的实现，你可以查看captureAslLogs 方法的实现，关键代码如下：    + (void)captureAslLogs {    @autoreleasepool {        ...        notify_register_dispatch(kNotifyASLDBUpdate, &notifyToken, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0),^(int token) {            @autoreleasepool {                ...                // 利用进程标识兼容在模拟器情况时其他进程日志无效通知                [self configureAslQuery:query];                 // 迭代处理所有新日志                aslmsg msg;                aslresponse response = asl_search(NULL, query);                 while ((msg = asl_next(response))) {                    // 记录日志                    [self aslMessageReceived:msg];                     lastSeenID = (unsigned long long)atoll(asl_get(msg, ASL_KEY_MSG_ID));                }                asl_release(response);                asl_free(query);                 if (_cancel) {                    notify_cancel(token);                    return;                }            }        });在上面这段代码中，notify_register_dispatch的作用是用来注册进程间的系统通知。其中，kNotifyASLDBUpdate宏表示的就是，日志被保存到 ASL 数据库时发出的跨进程通知，其键值是com.apple.system.logger.message。既然是跨进程通知，那么多个 App 之间也是可以进行通知的。不过对于 iPhone来说，多个 App 同时保活的机会太少，所以一般都是接收系统功能发出的通知。在 iOS 系统中，类似地把日志保存到 ASL数据库时发出的通知还有很多种，比如键值是 com.apple.system.lowdiskspace的 kNotifyVFSLowDiskSpace宏，该通知是在系统磁盘空间不足时发出的。当捕获到这个通知时，你可以去清理缓存空间，避免发生缓存写入磁盘失败的情况。更多的跨进程通知宏，你可以在 notify_keys.h 里看到，终端查看命令如下：    cat /usr/include/notify_keys.h接下来，**我继续和你说说 captureAslLogs 方法，看看 captureAslLogs是怎么处理 ASL 日志的。**在 captureAslLogs 方法里，处理日志的方法是 aslMessageReceived，入参是aslmsg 类型，由于 aslmsg 类型不是字符串类型，无法直接查看。所以在aslMessageReceived 方法的开始阶段，会使用 asl_get 方法将其转换为 char字符串类型。类型转换代码如下：    const char* messageCString = asl_get( msg, ASL_KEY_MSG );接下来，char 字符串会被转换成 NSString 类型，NSString 是 Objective-C里字符串类型，转成 NSString 更容易在 Objective-C 里使用。    NSString *message = @(messageCString);因为 CocoaLumberjack 的日志最后都是通过 DDLog:log:message:方法进行记录的，其中 message 参数的类型是 DDLogMessage，所以 NSString类型还需要转换成 DDLogMessage 类型。因为 DDLogMessage类型包含了日志级别，所以转换类型后还需要设置日志的级别。CocoaLumberjack这个第三方日志库，将捕获到的 NSLog 日志的级别设置为了Verbose。那为什么要这么设置呢？CocoaLumberjack 的日志级别，包括两类：-   第一类是 Verbose 和 Debug ，属于调试级；-   第二类是 Info、Warn、Error    ，属于正式级，适用于记录更重要的信息，是需要持久化存储的。特别是，Error    可以理解为严重级别最高。将日志级别定义为 Verbose，也只是基于 CocoaLumberjack 对 NSLog日志的理解。其实，NSLog 是被苹果公司专门定义为记录错误信息的：> Logs an error message to the Apple System Log facility.据我观察，现在有很多开发者都用 NSLog来调试。**但是我觉得，一般的程序调试，用断点就好了，我不推荐你把 NSLog作为一种调试手段。**因为，使用 NSLog 调试，会发生 IO磁盘操作，当频繁使用 NSLog 时，性能就会变得不好。另外，各团队都使用NSLog来调试的话很容易就会刷屏，这样你也没有办法在控制台上快速、准确地找到你自己的调试信息。而如果你需要汇总一段时间的调试日志的话，自己把这些日志写到一个文件里就好了。这样的话，你随便想要怎么看都行，也不会参杂其他人打的日志。所以说 ，CocoaLumberjack 将 NSLog 设置为 Verbose ，在我看来CocoaLumberjack 对 NSLog 的理解也不够准确。说完如何创建一个DDLogMessage，接下来我们再看看**如何通过 DDLog 使用 DDLogMessage作为参数添加一条 ASL 日志**。下面是 DDLog 记录 ASL 日志相关的代码：    DDLogMessage *logMessage = [[DDLogMessage alloc] initWithMessage:message level:_captureLevel flag:flag context:0 file:@"DDASLLogCapture" function:nil line:0 tag:nil option:0 timestamp:timeStamp]; [DDLog log:async message:logMessage到这里，通过 ASL 获取 NSLog 日志的过程你就应该很清楚了。你可以直接使用CocoaLumberjack 这个库通过 \[DDASLLogCapture start\] 捕获所有 NSLog的日志。你现在已经清楚了 CocoaLumberjack的捕获原理和方法，如果不想引入这个第三方库的话，也可以按照它的思路写个简化版的工具出来，只要这个工具能够把日志记录下来，并且能够在出现问题的时候，把日志上传到服务器，方便我们进行问题的追踪和定位即可。为了使日志更高效，更有组织，在 iOS 10之后，使用了新的统一日志系统（Unified LoggingSystem）来记录日志，全面取代 ASL 的方式。以下是官方原话：> Unified logging is available in iOS 10.0 and later, macOS 10.12 and> later, tvOS 10.0 and later, and watchOS 3.0 and later, and supersedes> ASL (Apple System Logger) and the Syslog APIs. Historically, log> messages were written to specific locations on disk, such as> /etc/system.log. The unified logging system stores messages in memory> and in a data store, rather than writing to text-based log files.接下来，我们就看看 iOS 10 之后，如何来获取 NSLog 日志。统一日志系统的方式，是把日志集中存放在内存和数据库里，并提供单一、高效和高性能的接口去获取系统所有级别的消息传递。macOS 10.12开始使用了统一日志系统，我们通过控制台应用程序或日志命令行工具，就可以查看到日志消息。但是，新的统一日志系统没有 ASL那样的接口可以让我们取出全部日志，所以**为了兼容新的统一日志系统，你就需要对NSLog 日志的输出进行重定向。**对 NSLog 进行重定向，我们首先想到的就是采用 Hook 的方式。因为 NSLog本身就是一个 C 函数，而不是 Objective-C 方法，所以我们就可以使用fishhook 来完成重定向的工作。具体的实现代码如下所示：    static void (&orig_nslog)(NSString *format, ...); void redirect_nslog(NSString *format, ...) {    // 可以在这里先进行自己的处理        // 继续执行原 NSLog    va_list va;    va_start(va, format);    NSLogv(format, va);    va_end(va);} int main(int argc, const char * argv[]) {    @autoreleasepool {        struct rebinding nslog_rebinding = {"NSLog",redirect_nslog,(void*)&orig_nslog};         NSLog(@"try redirect nslog %@,%d",@"is that ok?");    }    return可以看到，我在上面这段代码中，利用了 fishhook对方法的符号地址进行了重新绑定，从而只要是 NSLog 的调用就都会转向redirect_nslog 方法调用。在 redirect_nslog方法中，你可以先进行自己的处理，比如将日志的输出重新输出到自己的持久化存储系统里，接着调用NSLog 也会调用的 NSLogv 方法进行原 NSLog方法的调用。当然了，你也可以使用 fishhook 提供的原方法调用方式orig_nslog，进行原 NSLog 方法的调用。上面代码里也已经声明了类orig_nslog，直接调用即可。NSLog 最后写文件时的句柄是 STDERR，我先前跟你说了苹果对于 NSLog的定义是记录错误的信息，STDERR 的全称是 standarderror，系统错误日志都会通过 STDERR 句柄来记录，所以 NSLog最终将错误日志进行写操作的时候也会使用 STDERR 句柄，而 dup2函数是专门进行文件重定向的，那么也就有了另一个不使用 fishhook 还可以捕获NSLog 日志的方法。你可以使用 dup2 重定向 STDERR句柄，使得重定向的位置可以由你来控制，关键代码如下：    int fd = open(path, (O_RDWR | O_CREAT), 0644);dup2(fd, STDERR_FILENO);其中，path 就是你自定义的重定向输出的文件地址。这样，我们就能够获取到各个系统版本的 NSLog了。那么，通过其他方式打的日志，我们怎么才能获取到呢？现在与日志相关的第三方库里面，使用最多的就是CocoaLumberjack。而且，其他的很多第三库的思路也和 CocoaLumberjack类似，都是直接在 CocoaLumberjack的基础上包装了一层，增加了统一管控力和易用性而已。接下来，我们就先看看 CocoaLumberjack 的整体架构是怎样的，进而找到获取CocoaLumberjack 所有日志的方法。