⌉
33
34
2
35 Upon deliver ⟨PERSIST, bNum, ⟨r , lbHash⟩σr ⟩ do
Cert[bNum] ← Cert[bNum] ∪ {⟨r , lbHash⟩σr}
36
if valid(recTx , recProof , nKeysx [])
37 Upon totalOrderDeliver ⟨VIEW, cid, recTx , recProof , nKeys[]⟩ do
38
39
40
41
42
43
44
45
46
47
48
Txs[bNum] ← ⟨recTx , recProof , nKeys[]⟩
asyncWriteBC(⟨cid, Txs[bNum], nKeys[]⟩)
updates cv according to recTx
Res[bNum] ← ⟨recTx .senderId, cv ⟩
asyncWriteBC(Res[bNum])
closeBlock (hash(Txs[bNum]), hash(Res[bNum]))
send ⟨REPLY, cv ⟩ to recTx .senderId
lRec ← bNum
checkpoint()
bNum + +
if (bNum % CHECKPOINT PERIOD) =0
49 Procedure checkpoint()
50
51
52
53
54
lCkp ← bNum
resetCached()
lSnapshot ← takeSnapshot()
asyncWriteSN(lSnapshot)
55 Upon deliver ⟨ST REQ, cid, stateReq⟩ do
56
57
lastTxs ← get transactions from lCkp + 1 to cid from the cache
send ⟨ST REP, cid, lastTxs, lSnapshot⟩ to stateReq.senderId
system, respectively. The processing to exclude a member
from the system is similar, but in this case, it is necessary
to wait for transactions from a quorum of nodes advocating
for the removal.
Finally, snapshots are written outside the blockchain in a
different ﬁle (line 54) and state transfer requests are replied
with the last snapshot together with the blockchain data cached
since the last checkpoint (lines 55-57).
VI. EVALUATION
We implemented SMARTCHAIN over BFT-SMART and
conducted several experiments (1) to compare the performance
of different strategies for blockchain data persistence, (2) to
compare the SMARTCHAIN performance with similar sys-
tems (Tendermint and Hyperledger Fabric), and (3) to under-
stand the system behavior under events like reconﬁgurations,
crashes, and recoveries.
A. Experimental Setup and Methodology
The experimental environment was conﬁgured with 14 ma-
chines connected to a 1Gbps switched network. The machines
were conﬁgured with Ubuntu Linux 16.04.5 LTS operating
system and JRE 1.8.0, hosted in Dell PowerEdge R410 servers.
Each machine has 32 GB of memory and two quadcore 2.27
GHz Intel Xeon E5520 processor with hyperthreading, i.e.,
supporting 16 hardware threads. The machines have also a
146 GB SCSI HDD (Seagate Cheetah ST3146356SS). The
experiments were conducted in up to ten replicas hosted in
separate physical machines. Moreover, 2400 client processes
were distributed uniformly across the other four machines.
SMARTCHAIN was conﬁgured to use a maximum batch
size (block size) of 512 transactions. The experiments were
conducted in two phases: the ﬁrst one is composed of MINT
operations to generate new coins, and then a second phase
considers SPEND operations to transfer the generated coins to
new addresses. Following the UTXO model, this corresponds
to single-input, single-output SPEND transactions. Each client
issued up to 1000 requests of each type (MINT and SPEND).
In this section we report only the values for SPEND since both
types of transactions yield equivalent results.
For each experiment, the throughput was measured at the
replicas at regular intervals (at each 10k operations). From
the collected data, 20% of the values with greater variance
were discarded and the average values are presented. Standard
deviations were always under 500 txs/sec.
B. Results
This section presents the experimental results, which were
divided in three subsets according to the evaluation goals.
a) Comparing different blockchain strategies: We com-
pared the system performance considering different blockchain
persistence guarantees: SMARTCHAIN conﬁgured with syn-
chronous storage writes (0- and 1-Persistence in the strong
and weak variants, respectively), asynchronous storage writes
(λ-Persistence for both variants), and memory only (∞-
Persistence for both variants). As a baseline, we also present
results for the efﬁcient durability layer of BFT-SMART [37],
which does not implement a blockchain (Section IV-A). Fig-
ure 6 presents the throughput results for all these conﬁgura-
tions considering different consortium sizes and the use or not
of signatures.
The results show that signature veriﬁcation represents the
major factor that impacts performance, followed by the storage
strategy. For n = 4 and when using signatures, SMARTCHAIN
throughput reaches around 12k and 14k txs/sec for the strong
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:27:46 UTC from IEEE Xplore.  Restrictions apply. 
432
 35
 30
 25
 20
 15
 10
 5
 0
)
c
e
s
/
s
x
t
k
(
t
u
p
h
g
u
o
r
h
T
n=4
Si+Sy Si Sy N
Strong blockchain
Si+Sy Si Sy N
Weak blockchain
Si+Sy Si Sy N
Durable-SMaRt
 35
 30
 25
 20
 15
 10
 5
 0
)
c
e
s
/
s
x
t
k
(
t
u
p
h
g
u
o
r
h
T
n=7
Si+Sy Si Sy N
Strong blockchain
Si+Sy Si Sy N
Weak blockchain
Si+Sy Si Sy N
Durable-SMaRt
 35
 30
 25
 20
 15
 10
 5
 0
)
c
e
s
/
s
x
t
k
(
t
u
p
h
g
u
o
r
h
T
n=10
Si+Sy Si Sy N
Strong blockchain
Si+Sy Si Sy N
Weak blockchain
Si+Sy Si Sy N
Durable-SMaRt
Fig. 6: SMARTCHAIN throughput for different consortium sizes and blockchain persistence guarantees. Legend: Si+Sy =
Signatures and synchronous writes; Si = Signatures only; Sy = Synchronous writes only; N = None.
TABLE II: Throughput and latency for different blockchains.
Blockchain
Throughput (txs/sec)
Latency (sec)
SMARTCHAIN Strong
SMARTCHAIN Weak
Tendermint
Hyperledger Fabric
12560 ± 480
14547 ± 465
1602 ± 395
381 ± 102
0.210 ± 0.033
0.200 ± 0.023
1.378 ± 0.421
1.602 ± 0.504
and weak variants, respectively. When signatures are disabled,
these values increase to around 18k and 26k txs/sec in the
strong and weak variants, respectively. Notice that the size
of transactions makes the throughput of plain BFT-SMART
(N setup) reach 33k txs/sec, which is much less than the 80k
txs/sec the system achieve with transactions of few bytes [25].
In our experiments, the size of the consortium has a minor
impact on the performance of the conﬁgurations with stronger
guarantees (signatures and synchronous writes), in all dura-
bility strategies. This shows that the consensus protocol was
not the bottleneck in these scenarios. Instead, the bottleneck is
the time demanded to write the ledger to disk and to perform
signature veriﬁcation. However, it is expected that the lack of
scalability of BFT-SMART consensus protocol will make it a
bottleneck in larger groups [24].
Likewise, the results show that the additional PERSIST
phase in the strong blockchain variant does not signiﬁcantly
impact system performance, as the obtained results for this
setup are only 13% lower than the ones obtained for the weak
variant.
b) Comparison with other systems: Table II compares
the SMARTCHAIN performance with two other well-known
BFT blockchain systems: Tendermint [3], [49], [50] and
Hyperledger Fabric [1] conﬁgured with a BFT ordering ser-
vice [40]. For both variants, SMARTCHAIN was conﬁgured
to use signatures and synchronous writes. Both Tendermint
and Hyperledger Fabric were also conﬁgured for maximum
durability. Finally, all systems were conﬁgured with four
replicas to tolerate a single Byzantine failure.
Table II shows that SMARTCHAIN performs signiﬁcantly
better than the competing systems. Tendermint uses an ar-
chitecture that decouples application and ordering layers,
similar to SMaRtCoin, and the performance results were also
similar (Section IV-A). Although other works reported higher
throughput for Hyperledger Fabric (e.g., approximately 1k
txs/sec [51]), we could reach at most 381 txs/sec in our testbed.
c) Reconﬁgurations, crashes, and recoveries: Figure 7
shows the behavior of the strong variant of SMARTCHAIN,
using signatures and synchronous writes, in a run with dif-
ferent events and 600 clients accessing the system. For this
experiment, the system was conﬁgured with 8 million UTXOs
representing 10% of the current number of UTXOs in the
Bitcoin network [52], leading to a state of 1GB.
We can observe that the throughput increases until all clients
become operational, around second 7. At second 120, replica 4
joins the system and the throughput decreases since large quo-
rums are used in the protocol. At second 240, replica 3 crashes,
which does not impact throughput, and later recovers at second
360. In second 442, replicas perform a checkpoint that takes
23 seconds to ﬁnish. During this period, the throughput drops
to almost zero. It is possible to conﬁgure replicas to take
checkpoints at different instants in the execution to decrease
its impact in the overall system performance [37]. Finally, at
second 480, replica 4 leaves the system and throughput goes
back to what was observed in the beginning of the experiment.
Notice that after a join or a recovery, replicas demand
approximately 60 seconds to obtain and install the 1GB state
from the other replicas (green spots in Figure 7). Throughput
is slightly smaller during this period since replicas must send
their state to the joining/recovering replica. By using check-
points and state transfer, a replica can join the system faster
than in other systems that do not employ this technique. For
example, currently a node must process a blockchain of 223GB
(9080186 blocks) to join the Ethereum network [53], even
pruning old states. Based on this observation, Figure 8 shows
the processing time demanded to update a replica considering
different checkpoint periods and blockchain sizes. Checkpoints
boost
the reconﬁguration performance since joining nodes
need to process only the transactions logged after the last
checkpoint.
VII. RELATED WORK
Since Bitcoin’s inception and widespread adoption there
have been an impressive amount of work on both permission-
less and permissioned blockchain platforms. Most of these
works focus on the multiple types of blockchain consensus,
but very few provide an in-depth discussion about blockchain
durability and the issues with decentralized consortium recon-
ﬁguration.
a) Durability: The scale, latency, and probabilistic ﬁ-
nality of the most popular blockchains lead to an ad-hoc
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:27:46 UTC from IEEE Xplore.  Restrictions apply. 
433
)
c
e
s
/
s
x
t
k
(
t
u
p
h
g
u
o
r
h
T
 4
 3
 2
 1
 0
 0
 0
 120
 240
 360
 480