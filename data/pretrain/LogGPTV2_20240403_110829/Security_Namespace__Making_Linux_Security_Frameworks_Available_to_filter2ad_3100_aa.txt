title:Security Namespace: Making Linux Security Frameworks Available to
Containers
author:Yuqiong Sun and
David Safford and
Mimi Zohar and
Dimitrios Pendarakis and
Zhongshu Gu and
Trent Jaeger
Security Namespace: Making Linux Security 
Frameworks Available to Containers
Yuqiong Sun, Symantec Research Labs; David Safford, GE Global Research;  
Mimi Zohar, Dimitrios Pendarakis, and Zhongshu Gu, IBM Research;  
Trent Jaeger, Pennsylvania State University
https://www.usenix.org/conference/usenixsecurity18/presentation/sun
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.Security Namespace : Making Linux Security
Frameworks Available to Containers
Yuqiong Sun
Symantec Research Labs
David Safford
GE Global Research
Mimi Zohar
IBM Research
Dimitrios Pendarakis
IBM Research
Zhongshu Gu
IBM Research
Trent Jaeger
Pennsylvania State University
Abstract
1
Introduction
Lightweight virtualization (i.e., containers) offers a vir-
tual host environment for applications without the need
for a separate kernel, enabling better resource utiliza-
tion and improved efﬁciency. However, the shared ker-
nel also prevents containers from taking advantage of se-
curity features that are available to traditional VMs and
hosts. Containers cannot apply local policies to gov-
ern integrity measurement, code execution, mandatory
access control, etc.
to prevent application-speciﬁc se-
curity problems. Changes have been proposed to make
kernel security mechanisms available to containers, but
such changes are often adhoc and expose the challenges
of trusting containers to make security decisions without
compromising host system or other containers. In this
paper, we propose security namespaces, a kernel abstrac-
tion that enables containers to have an autonomous con-
trol over their security. The security namespace relaxes
the global and mandatory assumption of kernel security
frameworks, thus enabling containers to independently
deﬁne security policies and apply them to a limited scope
of processes. To preserve security, we propose a routing
mechanism that can dynamically dispatch an operation
to a set of containers whose security might be affected
by the operation, therefore ensuring the security decision
made by one container cannot compromise the host or
other containers. We demonstrate security namespace by
developing namespaces for integrity measurement and
mandatory access control in the Linux kernel for use by
Docker containers. Results show that security names-
paces can effectively mitigate security problems within
containers (e.g., malicious code execution) with less than
0.7% additional latency to system call and almost identi-
cal application throughput. As a result, security names-
paces enable containers to obtain autonomous control
over their security without compromising the security of
other containers or the host system.
Lightweight virtualization (i.e., containers) offers a vir-
tual host environment for applications without the need
for a separate kernel, enabling better resource utiliza-
tion and improved efﬁciency. It is broadly used in com-
putation scenarios where a dense deployment and fast
spin-up speed is required, such as microservice archi-
tecture [39] and serverless computation (e.g., Amazon
Lambda [26]). Many commercial cloud vendors [23, 20,
1] have adopted the technology.
The key difference between containers and traditional
VMs is that containers share the same kernel. While this
enables better resource utilization, it also prevents con-
tainers from taking advantage of security features in ker-
nel that are available to traditional VMs or hosts. Con-
tainers cannot apply local security policies to govern in-
tegrity measurement, code execution, mandatory access
control, etc. to prevent application speciﬁc security prob-
lems. Instead, they have to rely on a global policy spec-
iﬁed by the host system admin, who often has different
security interests (i.e., protect the host system) and does
not have enough insight about the security needs of indi-
vidual containers. As a result, containers often run with-
out any protection [34, 40].
Previous efforts of making kernel security frameworks
available to containers are often adhoc and expose the
challenges of trusting containers to make security deci-
sions without compromising host system or other con-
tainers. For example, a kernel patch [24] to Integrity
Measurement Architecture (IMA) [53] suggested that the
IMA measurement list can be extended with a container
ID, such that during integrity attestation the measure-
ments will become separable based on containers. As
another example, AppArmor and Tomoyo introduced the
concept of proﬁle and policy namespace [49, 44] to allow
certain processes to run under a policy different from the
rest of the system. These changes, however, only made
limited kernel security features available to containers,
USENIX Association
27th USENIX Security Symposium    1423
and they all rely on the system owner to specify a global
policy, leaving containers no real freedom in enforcing
an autonomous security.
In this paper, we explore approaches to make kernel
security frameworks available to containers. Due to the
diversity of kernel security frameworks and their differ-
ent design perspectives and details, it is extremely dif-
ﬁcult to reach a generic design that can cover all ker-
nel security frameworks in a single step.
Instead, this
paper explores an initial step, by making two concrete
kernel security frameworks available to containers, to in-
vestigate the common challenges and approaches behind.
Hopefully, the results have enough generality to guide
other kernel security frameworks and eventually lead to a
generic design. In studying the two popular kernel secu-
rity frameworks, namely IMA [53] for integrity and Ap-
pArmor [41] for mandatory access control, we make the
following observations: ﬁrst, we ﬁnd that the common
challenge for containers to obtain autonomous security
control is the implicit global and mandatory assumptions
that kernel security frameworks often make. Kernel se-
curity frameworks are designed to be global—they con-
trol all processes running on the system. They are also
designed to be mandatory—only the owner of the system
may apply a security policy. However, autonomous se-
curity control requires relaxation of both assumptions. A
container need to apply local security policies to control
a subset of processes running on the system (i.e., pro-
cesses in the container). Relaxing these assumptions in-
volves security risks. Our second insight is that we can
relax the global and mandatory assumptions in a secure
way by checking if the autonomous security control of
a container may compromise the security of other con-
tainers or the host system. We do this by inferring from
containers’ security expectation towards an operation.
Leveraging these insights, we propose the design of
security namespaces, kernel abstractions that enable con-
tainers to utilize kernel security frameworks to apply au-
tonomous security control. Security namespace virtual-
izes kernel security frameworks into virtual instances,
one per container. Each virtual instance applies inde-
pendent security policies to control containerized pro-
cesses and maintains their independent security states.
To ensure that the relaxation does not compromise any
principal’s security (i.e., other containers or the host sys-
tem), an Operation Router is inserted before the virtual
instances mediating an operation. The Operation Router
decides the set of virtual instances whose security might
be affected by an operation and routes the operation to
those virtual instance for mediation. After each virtual
instance makes an independent security decision, the de-
cisions are intersected. A speciﬁc challenge is that vir-
tual instances may make conﬂicting security decisions.
A Policy Engine is added to detect such conﬂicts and in-
form the container owners of potential conﬂicts before
they load their security policies.
We evaluate our design by developing two concrete in-
stances of security namespace, one for IMA and one for
AppArmor. Results show that leveraging the namespace
abstractions, containers (e.g., Docker and LXC) can ex-
ercise the full functionality of IMA and AppArmor and
apply autonomous security control, much like a VM or
host system. Speciﬁcally, we show that the IMA names-
pace enables containers to independently measure and
appraise ﬁles that are loaded into the container, with-
out violating any of the host system’s integrity policy.
For AppArmor namespace, we show that it enables con-
tainers to enforce two policy proﬁles simultaneously, one
protects the host system and another protects the con-
tainerized application, which was not possible as dis-
cussed in Ubuntu LXC documentation [34]. We evaluate
the performance of both namespace abstractions. Results
show that security namespaces introduce less than 0.7%
latency overhead to system calls in a typical container
cloud use case (i.e., no nested namespaces) and an al-
most identical throughput for containerized applications.
In summary, we make the following contributions.
• Through studying IMA and AppArmor, we inves-
tigate the common challenges and approaches be-
hind making kernel security frameworks available
to containers.
• We develop two concrete security namespace ab-
stractions, one for IMA and another for AppArmor,
which enables autonomous security control for con-
tainers while preserving security.
• We show that widely used container systems (e.g.,
Docker and LXC) can easily adopt the IMA and
AppArmor security namespace abstractions to exer-
cise full functionality of kernel security frameworks
with modest overhead.
2 Background
In this section, we ﬁrst describe the namespace concept
in the Linux kernel and how it is adopted by container.
We then discuss security frameworks in Linux kernel.
2.1 Namespace and Container
The Linux namespace abstraction provides isolation for
various system resources. According to Linux man
page [31]:
A namespace wraps a global system resource
in an abstraction that makes it appear to the
processes within the namespace that they have
their own isolated instance of the global re-
source. Changes to the global resource are
visible to other processes that are members of
1424    27th USENIX Security Symposium
USENIX Association
Table 1: Namespaces in Linux kernel.
Namespace
Constant
Isolates
IPC
Network
Mount
PID
User
UTS
CLONE NEWIPC
CLONE NEWNET
CLONE NEWNS
CLONE NEWPID
CLONE NEWUSER
CLONE NEWUTS
System V IPC, POSIX message queues
Network devices, stacks, ports, etc.
Hostname and NIS domain name
Mount points
Process IDs
User and group IDs
Figure 1: Creating a Docker container.
the namespace, but are invisible to other pro-
cesses.
We use mount namespace as an example. Without
mount namespace enabled, processes running within a
Linux OS share the same ﬁlesystems. Any change to
the ﬁlesystems made by one process is visible to the oth-
ers. To provide ﬁlesystem isolation across processes, ch-
root [6] was ﬁrst introduced but then found to be vulner-
able to a number of attacks [7, 8]. As a more principled
approach, Linux kernel introduced the mount namespace
abstraction to isolate mount points that can be seen by
the processes. A mount namespace restricts the ﬁlesys-
tem view to a process by creating separate copies of
vfs mount points. Thus, processes running in different
mount namespaces could only operate over their own
mount points. To date, six namespace abstractions (Ta-
ble 1) have been introduced into the Linux kernel.
Container [56] is an OS-level virtualization technol-
ogy. By leveraging the namespace abstractions (together
with other kernel mechanisms, e.g., Cgroups, SecComp),
a container can create an isolated runtime environment
for a set of processes. Well-known container implemen-
tations include Docker [13], LXC [33], and LXD [35].
Figure 1 illustrates the procedure of creating a Docker
container.
It starts from launching a daemon process
(e.g., dockerd) on the native host system. The daemon
process forks itself (i.e., via clone), specifying that the
newly forked process will run in different namespaces
from the native for isolation. The forked process then
properly sets up the namespaces that it runs in (e.g.,
mounting a different root, setting up its IP address, ﬁre-
walls, etc.) and executes a target program (i.e., via ex-
ecve). The target program then starts running in an en-
vironment isolated from other containers and the native
system. The isolation is achieved by using the names-
pace abstractions. When forking a new process, the clone
system call accepts different ﬂags to indicate that the
child process should run in none, one or several types of
new namespaces. Containers often leverage all six types
of namespaces at the same time, in order to create a fully
isolated environment.
2.2 Kernel Security Frameworks
To protect the system and applications running atop,
Linux kernel features many security frameworks. Some
of
these frameworks are upstreamed to the Linux
kernel, such as Linux integrity subsystem [53, 30],
SELinux [42], and AppArmor [41]. Some remain as re-
search proposals [43, 63, 2, 28]. Although differing in
security goals, these frameworks share a similar design.
In general, these security frameworks rely on ”hooks”
added into the kernel to intercept security critical oper-
ations (e.g., accessing inodes) from a process. Such se-
curity critical operations are passed to a security module
where decisions (i.e., allow or deny) are made based on
security policies.
2.2.1 Linux Integrity Subsystem
The Linux integrity subsystem, also known as the In-
tegrity Measurement Architecture (IMA) [53],
is de-
signed to thwart attacks against the unexpected changes
to ﬁles, particularly executable, on a Linux system.
IMA achieves this by measuring ﬁles that may affect
the integrity of the system. Working with a secure co-
processor such as TPM, IMA could securely store the
measurements and then report them to a remote party
as a trustworthy proof of the overall integrity status of