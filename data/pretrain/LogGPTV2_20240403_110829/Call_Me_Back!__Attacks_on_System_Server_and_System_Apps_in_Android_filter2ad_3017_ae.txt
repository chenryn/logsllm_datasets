to any GUI operation. It gives the impression that the virus
scanning consumes too many computing resources. The s-
canning also will be blocked until the system soft-reboots.
5.2.3 Hindering Critical Application Patching
Scenario. Due to the evolving nature of mobile systems,
apps have to update for vulnerability patching. Malicious
apps need to hinder the patching of critical apps, which will
render the vulnerable apps unpatched.
Design. The app updating is conducted by PMS. It can
be divided into three sequential subtasks: removing the o-
riginal app, adding a new app and conﬁguring the new app.
When each subtask ﬁnishes, a broadcast will be send with
corresponding action tags. The malicious app can check
the existence of the target apps by calling PackageManag-
er.getApplicationInfo() frequently. This helps to moni-
tor the removal of the old version. Once the target app no
longer exists, the malicious app can hinder the installation
of the new version or soft-reboot the system immediately.
When the system ﬁnishes the soft-reboot, PMS will roll back
the unﬁnished update task to ensure its atomicity.
Result. The PoC app was deployed on Android 5.1.0 of
Nexus 6 to prevent the update of 360 Mobile Safe. It checks
the existence of the target app every 5 milliseconds. The
V ul#1 was leveraged to conduct the attack. It led to the
freeze of AMS. Hence, PMS could not utilize AMS to send
the broadcast after the old version app was removed. After
about 62 seconds of blocking, the whole system crashed. The
update rolled back after reboot.
5.2.4 Hindering System Updating
Scenario. Android is evolving rapidly. The newly found
vulnerabilities are patched quickly in the new versions. If an
attacker can ﬁnd a way to hinder the update of the system,
it will ensure the system remains vulnerable forever.
Design and Implementation. For ordinary users, the
most frequently used measure to update the system is through
an OTA (Over-The-Air) update. The OTA update needs to
download the update ﬁles from the network server and store
them in local devices. To monitor the OTA update, the ma-
licious app can scan the ﬁle system to detect the downloaded
update ﬁles. It also could monitor the process in charge of
the OTA update by checking the amount of received bytes
from the internet. When the malicious app ﬁnds the system
is updating, it will have many options. It can exploit V ul#1
or V ul#4 to freeze and soft-reboot the system. It also can
exploit V ul#6 to crash the Phone app in order to hinder
the download through the mobile network.
Result. We deployed the PoC app on Nexus 6, which
needed to update from 5.1.0 to 5.1.1. The size of the up-
date package was about 110MB. The Google Mobile Service
(GMS) app was in charge of the OTA update. The PoC
app monitored the number of bytes received by the GMS
100app by invoking the TrafficStats.getUidRxBytes() API.
When the number surpassed 10 MB, V ul#4 was triggered.
It soft-rebooted the system immediately. The test result
shows that the PoC app can successfully prevent the OTA
update.
6. DEFENSE APPROACHES
Attacks on the new vulnerabilities are diﬃcult to prevent
due to the reasons:
1). in the aspect of the Binder driver, a malicious service
request is indistinguishable from benign requests;
2). in the aspect of the SS, a received callback handle is
unveriﬁable to prevent attack;
3). in the aspect of dynamic monitoring, when the call-
back is invoked, the malicious service component could
choose to attack under certain timing to avoid expos-
ing its aggressive behavior;
4). in the aspect of static audit, the attack code can be
developed with both Java and C/C++ languages.
Therefore, the best way to defend against the attacks is
to identify and patch the vulnerabilities as quickly as possi-
ble. To patch these vulnerabilities, we propose the following
suggestions for the developers of system services.
For some callbacks, the callers have no need to wait for
the reply. These callbacks must be declared as asynchronous.
AMS receives a callback handle whose interfaces are deﬁned
in the IInstrumentationWatcher class. MS receives a call-
back handle whose interfaces are deﬁned in the IMountSer-
viceListener class. These two system services are vulner-
able to the “call me back” vulnerability. After an in-depth
study on them, we ﬁnd that all the return types of their
interfaces are void. There is no need to wait for the re-
turn of these callback methods at all. Therefore, there is a
very convenient way to patch these vulnerabilities, which is
to change the type of these callbacks from synchronous to
asynchronous.
For some callbacks, the callers have to wait for the reply.
Their invocation statements must not be in a synchronized
block. And a caller should invoke a callback in a try-catch
block which can handle all possible exceptions. Four of the
new vulnerabilities are caused by receiving a parameter that
contains a callback handler as a member variable. Actual-
ly the class of the callback handles is the same, which is
the IIntentSender class. This class only declares one call-
back method named send(). This callback method returns
a value which indicates whether or not an intent is sent suc-
cessfully. Hence, it has to be a synchronous callback. Under
this circumstance, the developers should not invoke the call-
back in a synchronized block. He/she should try to catch
and handle all the possible exceptions using try-catch blocks.
From another perspective, although the developers can
anticipate the worst-case situations before implementing a
new service interface which accepts a callback handle as a
parameter, a more fundamental security design question is
whether a system service developer should ever use a syn-
chronous callback to “communicate” with untrusted apps.
There are some other ways to “communicate” with an un-
trusted app, such as socket, pipe and shared memory. No
matter which way is chosen, the key point is whether the
communication should be synchronous. We insist that one
design principle of system services is that it should never
communication with untrusted apps in a synchronous way.
7. RELATED WORK
Vulnerabilities in system services have been explored by
several previous studies. A general design trait in the con-
currency control mechanism of the system services has been
discovered by [17]. This new kind of vulnerability is named
as ASV, which makes the Android system vulnerable to
Denial-of-Service attacks. The hazard situation of ASV is
similar to the situation A1 in this paper (see Section 2.2).
The limitation of [17] is that: 1) they believe that the at-
tack surfaces are the APIs which wrap the invocation code of
vulnerable service interfaces instead of the interfaces them-
selves; 2) the exploitation code needs to repeatedly invoke
the attack surfaces or register unusually large numbers of
resources, which is easy to detect and prevent; 3) only AMS
and PMS are found to be vulnerable and the attacks only
can freeze parts of their functionalities immediately. Our
work have found four hazard situations, which makes the
attacks more various. Our attacks only need to invoke the
vulnerable service interfaces once. They can freeze critical
target functionalities or soft-reboot the system immediately.
Therefore, our attacks are more ﬂexible to be leveraged in
diﬀerent attack scenarios (see in Section 5.2).
Some other works designed fuzzing tools targeted on the
system services in Android [13, 16, 19]. They leveraged the
idea that Binder provides a very convenient way to inject
test cases into system services. Fuzzing tests are easy to im-
plement and eﬀective on vulnerability detection. However,
there are two main challenges to designing a perfect fuzzing
tool for the system services in Android. Firstly, the strate-
gy of test data generation can seriously aﬀect the eﬀect and
eﬃciency of a fuzzing test. The designer cannot guarantee
that the test cases cover all the execution paths of the target
system service. Secondly, it is hard to deﬁne the abnormal
behavior for every system service interface. Therefore, the
false negative rate is highly dependent on the deﬁnitions of
abnormal behaviors.
If a designer wants to cover all the
possible failure situations, he/she has to manually inspect
the source code of every system service. This is heavy and
clumsy work. Our static taint analysis tool can easily cover
all the execution paths. Since we have clearly characterized
the feature of the “call me back” vulnerabilities, we do not
have to blindly generate test cases and struggle to monitor
all the possible failure situations of the system services.
Taint analysis has been widely applied to diﬀerent plat-
forms for diﬀerent purposes [11, 12, 21, 25, 26, 27]. For
Android, the main usage of taint analysis is to detect priva-
cy leakages of the apps. They can be divided into dynamic
taint analysis [15, 23] and static taint analysis [10, 18, 20, 29,
30]. TaintDroid is a dynamic taint analysis tool for real-time
privacy monitoring on Android apps [15]. It uses variable-
level tracking within the VM interpreter while the target
app is running.
It is very eﬀective on real-time monitor-
ing but cannot guarantee that all the execution paths have
been covered. Other researchers focus on the design of stat-
ic taint analysis tools. FlowDroid is an excellent framework
for static taint analysis. It can provide precise context, ﬂow,
ﬁeld, and object-sensitive and lifecycle-aware taint analysis
for Android apps [10]. However, it is not entirely applicable
for vulnerability detection on the SS, as we have described
in Section 3. Our work is the ﬁrst to introduce static taint
analysis on the code audit and vulnerability detection tar-
geted on the SS in Android.
1018. CONCLUSIONS
Based on a new understanding of the security risks in-
troduced by the callback mechanism in system services, we
have discovered a general type of design ﬂaw. It reveals a
new kind of vulnerability in system services and system app-
s. We have designed and implemented a vulnerability detec-
tion tool based on static taint analysis.Our tool has success-
fully analyzed all the 80 system services in Android 5.1.0.
With its help, we discovered six previously unknown vul-
nerabilities, which are further conﬁrmed on Android 2.3.7-
6.0.1. These vulnerabilities aﬀect about 97.3% of the entire
1.4 billion real-world Android devices. We crafted several
PoC apps and illustrated the serious attack hazards from the
freeze of critical functionalities to the soft-reboot of the sys-
tem. We also designed several attack scenarios and proved
that the vulnerabilities can enable malicious apps to attack
the system at mission critical moments, such as system up-
dating and virus scanning. The newly found vulnerabilities
have been reported to Google and Google conﬁrmed them
promptly. Some suggestions are also proposed for the devel-
opers of system services and apps to patch and prevent this
new kind of vulnerability.
9. ACKNOWLEDGMENTS
Kai Wang and Yuqing Zhang were supported by the Na-
tional Natural Science Foundation of China (61272481, 61572460),
the National Key Research and Development Project (2016YF-
B0800703), the National Information Security Special Projects
of National Development and the Reform Commission of
China [(2012)1424]. Peng Liu was supported by ARO W911NF-
13-1-0421 (MURI), NSF CNS-1422594, and NSF CNS-1505664.
10. REFERENCES
[1] 27 million doctors’ mobile devices at high risk of malware |
ITProPortal.com. http://goo.gl/BJs5Mu.
[2] Android and RTOS together: The dynamic duo for today‘s
medical devices - embedded computing design.
http://goo.gl/StURzu.
medical devices | hughes systique. http://goo.gl/aO0NFk.
[3] Android auto. https://www.android.com/auto/.
[4] Android OS for smart medical equipment, developing embedded
[5] Android point of sale | android POS restaurants, cafes, bars |
[6] The best android POS of 2016 | top ten reviews.
tablet POS. http://www.posandro.com/.
goo.gl/9xykVH.
[7] Gartner says worldwide smartphone sales grew 9.7 percent in
fourth quarter of 2015. http://goo.gl/M0ZwSk.
[8] Google says there are now 1.4 billion active android devices
worldwide. http://goo.gl/utHxO8.
[9] Lollipop is now the most-used version of android, marshmallow
up to 2.3 percent. http://goo.gl/Q598DH.
[10] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y. Le Traon, D. Octeau, and P. McDaniel. FlowDroid: Precise
context, ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint
analysis for android apps. In Proceedings of the 35th ACM
SIGPLAN Conference on Programming Language Design and
Implementation, PLDI ’14, pages 259–269. ACM.
[11] J. Bell and G. Kaiser. Dynamic taint tracking for java with
phosphor (demo). In Proceedings of the 2015 International
Symposium on Software Testing and Analysis, ISSTA 2015,
pages 409–413. ACM.
[12] E. Bodden. Inter-procedural data-ﬂow analysis with IFDS/IDE
and soot. In Proceedings of the ACM SIGPLAN International
Workshop on State of the Art in Java Program Analysis,
SOAP ’12, pages 3–8. ACM.
[13] C. Cao, N. Gao, P. Liu, and J. Xiang. Towards analyzing the
input validation vulnerabilities associated with android system
services. In Proceedings of the 31st Annual Computer Security
Applications Conference, ACSAC 2015, pages 361–370. ACM.
[14] Q. A. Chen, Z. Qian, and Z. M. Mao. Peeking into your app
without actually seeing it: Ui state inference and novel android
attacks. In 23rd USENIX Security Symposium (USENIX
Security 14), pages 1037–1052, San Diego, CA, Aug. 2014.
USENIX Association.
[15] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. N. Sheth. TaintDroid: An information-ﬂow
tracking system for realtime privacy monitoring on
smartphones. In Proceedings of the 9th USENIX Conference
on Operating Systems Design and Implementation, OSDI’10,