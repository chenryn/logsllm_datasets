01. mov ebp, [edi+04h]
02. mov eax, [ebp]
03. mov [edi+18h], eax
04. mov eax, [ebp+4]
05. mov [edi+1Ch], eax
    ...
06. mov eax, [ebp-24h]
07. mov ebx, eax
08. shr ebx, 5
09. shl eax, 4
10. xor eax, ebx
11. add eax, [ebp-24h]
12. mov edx, [edi+1Ch]
13. and edx, 03h
14. mov ebx, [edi+18h]
15. add ebx, edx
16. mov edx, [ebx]]
17. add edx, [edi+1Ch]
    ...
instructions
following
single-step
exception
form the 
decryption key
variation of 
the TEA cipher
employed for 
second layer 
decryptinon
    ...
01. mov esi, [edx]
02. lea esi, [esi+22h]
03. mov esi, [esi+40h] 
04. mov edx, [esi+44h]
05. xor ebx, ebx
06. rdtsc
07. push eax
08. call d [edi+32h] 
09. jne 2150D010h 
10. call d [edi+44h]
    ...
    jne 03
    call d [edi+12h]
    ...
    ...
11. pop [edi+4ch]
12. rdtsc
13. sub [edi+4ch], eax
14. lea ebx, [edi+4dh]
15. mov ebx, [ebx+24h]
16. sub [edi+4ch], ebx
17. jc 19
18. call d [edi+2dh]
19. mov eax, [esi]
    ...
...
01. mov eax, [ebp-20h] 
02. mov ebx, eax
03. push cs
04. pop ecx
05. and ecx, 0Fh
06. add ecx, 5
07. shr ebx, ecx
08. dec ecx
09. shl eax, ecx
10. xor eax, ebx
...
(a)                                                                                                  (b)
                                                         (c)
Figure 9. (a)-(c) W32/Ratos Decryption Mechanism and Anti-analysis Tricks
single-step handler.
Consider line 12 of the code fragment shown in Figure 8a.
This is responsible for the decryption of the code for the partic-
ular metamorphic code fragment. Now consider the code frag-
ment shown in Figure 8c which is obtained when the call is ex-
ecuted by Cobra. As seen from lines 1–3, Figure 8c, the trojan
uses the PUSHF instuction and sets the trap-ﬂag thereby invok-
ing the single-step handler from that point on, during execu-
tion. The single-step handler, present in the kernel-mode com-
ponent and concealed within a polymorphic code envelope, is
responsible for the actual second level decryption.
We proceed to analyze the single-step handler using Cobra,
by setting an overlay point on the IDT entry for the single-
step exception upon encountering block execution events con-
taining the instructions shown in Figure 8c. We also setup Co-
bra for generating memory read and write events on the in-
structions shown in lines 4–7, Figure 8c and the encrypted
data section (line 13 onwards, Figure 8a) of the metamorphic
code fragment, since we suspected that that single-step han-
dler might overwrite those with new instructions on the ﬂy.
Figure 9a shows a part of the single-step handler that was
reconstructed from the blocks by handling memory read and
write events on the metamorphic code fragment in Figure 8a
and the range of insructions shown in lines 4–7 of Figure 8c.
As seen from lines 1–5, Figure 9a (documented via a mem-
ory read event on the instructions shown in lines 4–7, Figure
8c), the single-step handler makes use of a 64-bit value fol-
lowing the single-step exception from the instruction sequence
shown in Figure 8c. A memory write event on the encrypted
data section of the metamorphic code fragment in Figure 8a,
later reveals code fragments of the single-step handler (lines
6–17, Figure 9a) which resembles a variant of the TEA en-
cryption algorithm using a 64-bit key which is borrowed from
the two instructions following the single-step exception (lines
5–6, Figure 8c). Thus, the encryption key is stored within the
metamorphic code fragment itself, albeit camouﬂaged in in-
structions, which is used to decrypt the obfuscated section for
that particular metamorphic code fragment. Similar investiga-
tions reveal the IDEA encryption algorithm being employed as
a ﬁrst layer of encryption.
W32/Ratos employs a couple of other techniques apart from
its metamorphic code envelopes, to prevent its analysis. These
techniques are scattered in various areas of its internal code
both in user- and kernel-mode. Consider the code fragment
shown in Figure 9b. The malware employs a technique which
we call code execution timing. The trojan makes use of the
RDTSC instruction to obtain the value of the processor time
stamp counter at various intervals within a group of instruc-
tions comprising its code (lines 6 and 12, Figure 9b). If the dif-
ference in the execution time of the instructions for a block is
greater than a particular pre-calibrated threshold for that block
of instructions (lines 13–17, Figure 9b), W32/Ratos sets cer-
tain speciﬁc ﬂags which cause the decryption engine to cease
working in a normal fashion (line 18, Figure 9b). Thus, when
the trojan is executed in a virtual or supervised environment
(resulting in an increase in the execution time beyond the the
normal range) the metamorphic code generated by the trojan is
erroneous and thus results in spurious faults.
Another technique employed by W32/Ratos is what we call
privilege-level checks. The trojan obtains the privilege level of
its currently executing code, data and/or stack segment dur-
ing execution of instructions in kernel-mode. This is done us-
ing various instructions that access segment selectors (PUSH,
MOV etc.). Figure 9c shows a fragment of code employing the
PUSH instruction to obtain the code segment privilege level
within its decryption engine. The W32/Ratos employs a very
intelligent mechanism in that it uses the privilege level indi-
cator in the segment selectors as a part of its internal compu-
tations (lines 3–9, Figure 9c). Thus, if the code is run under
a different privilege level to capture the behavior of the tro-
jan in kernel-mode (this might be the case when running under
a VM such as VMWare [52], Bochs [30] etc.), the decryption
algorithm in this particular case would be erroneous as the val-
ues for the instructions would be completely different. How-
ever, Cobra handles such anti-analysis techniques with ease.
The framework employs stealth-implants on blocks contain-
ing such instructions thereby fooling the malware into think-
ing its being executed without any form of supervision.
As
seen,
features provided by current ﬁne-grained
code analysis frameworks do not sufﬁce in the analy-
sis of W32/Ratos and similar malware. However, with Co-
bra this task is greatly simpliﬁed. The framework cannot
be detected or countered and allows ﬁne-grained analy-
sis to be dynamically and selectively deployed on desired
code-streams. With Cobra it is relatively easy to glean mal-
ware details such as the malware code envelopes, its en-
cryption/decryption engine, memory layout etc. — important
pieces of information that facilitate the development of an an-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
tidote to combat the malware and it variants.
6. Performance Measurements
The performance of a ﬁne-grained malware analysis frame-
work such as Cobra depends on a number of factors, chief
among them being: (a) the nature of the code being analyzed
such as SM-SC code, obfuscated code, etc. and (b) the style
of analysis employed by an individual such as selecting the
code-streams to be analyzed, the analysis ranges, the blocks to
be coalesced, the code-streams to be skipped etc. These fac-
tors are not easy to characterize and hence it is difﬁcult to
come up with a representative analysis session for performance
measurements. This is further complicated by the fact that the
same individual can adopt different styles of analysis at differ-
ent times for a given code-stream. Therefore, we will concen-
trate on presenting the performance of Cobra based on anal-
ysis sessions with W32/Ratos, a malware based on the Win-
dows OSs (see Section 5). The performance of the framework
for other analysis sessions can be estimated in a similar fash-
ion. To validate Cobra, we make use of our prototype malware
analysis environment, WiLDCAT, (see Section 5) running un-
der the Windows XP OS, on a 32-bit Intel 1.7 GHz processor
with 512 MB of memory.
Latency due to 
Block Creations
Latency due to 
Xfer-Stubs
Latency due to 
Stealth Implants
Latency due to 
Block Purging
AR-1
AR-2
AR-3
AR-4
AR = Analysis Range
(112% , 2.47s)
(165% , 1.59s)
(403% , 4.04s)
(35% , 0.67s)
0
50
100
150
200
250
Latency in Clock Cycles ( x 107)
(a) Normal
AR-1
AR-2
AR-3
AR-4
(105% , 2.33s)
(111% , 1.1s)
(38% , 0.75s)
0
50
100
150
Latency in Clock Cycles ( x 107)
(b) With Block-Coalescing
(332% , 3.39s)
200
250
AR-1
AR-2
AR-3
AR-4
0
AR-1
AR-2
AR-3
AR-4
(79% , 1.63s)
(287% , 3.01s)
(112% , 0.99s)
(36% , 0.77s)
50
100
150
200
250
Latency in Clock Cycles ( x 107)
(c) With Block-Coalescing and Skipping (standard)
(58% , 1.39s)
(209%, 2.14s)
(85% , 0.93s)
(21% , 0.44s)
0
50
100
150
200
250
Latency in Clock Cycles ( x 107)
(d) With Block-Coalescing and Skipping (non-standard)
Figure 10. (a)-(d) Performance of Cobra
We divide the total runtime latency of Cobra into: (a) la-
tency due to block creations, (b) latency due to xfer-stubs, (c)
latency due to block purging, and (d) latency due to stealth-
implants. Readings were taken at various points within WiLD-
CAT and Cobra to measure these overheads. We use proces-
sor clock cycles as the performance metric for runtime latency.
This metric is chosen, as it does not vary across processor
speeds and also since it is a standard in literature related to mi-
cro benchmarks. The processor performance counter registers
are employed to measure the clock cycles, using the RDMSR
instruction.
Figure 10 shows the performance of Cobra employing dif-
ferent analysis methods for various analysis ranges. The analy-
sis ranges were chosen from our analysis sessions involving the
encryption and decryption engine of W32/Ratos. The choice
of the analysis ranges (single-step handler and parts of ﬁrst
and second decryption layers) were such that their semantics
are relatively constant and they occur for every instance of the
malware deployment. This allows us to obtain a determinis-
tic performance measure of various aspects of the framework.
For the graphs in Figure 10, the y-axis represents the analy-
sis ranges and the x-axis is the amount of extra clock cycles
that are incurred as opposed to the native runtime of that par-
ticular range. The data labels next to every stacked bar, in all
the graphs, represent the percentage of normalized latency and
its actual time in seconds for a 1.7GHz Intel processor.
Figure 10a shows the performance of Cobra when run nor-
mally (without applying performance enhancement techniques
such as block-coalescing and/or skipping). As seen from the
graph of Figure 10a, latency due to block-creations and xfer-
stubs are present in every analysis range (analysis ranges 1–4
in this case) and form a major portion of Cobra’s overall la-
tency since these elements form the backbone of the frame-
work. Latency due to block-purging only comes into effect
when an analysis range involves self-modifying code (analy-
sis ranges 1–3 in this case) and is due to the fact that the
framework invalidates the blocks corresponding to the modi-
ﬁed code regions. Latency due to stealth-implants occur when
Cobra needs to patch a block in order to prevent its detec-
tion. This is shown in analysis ranges 1, 2 and 4 which con-
tain W32/Ratos anti-analysis code fragments. In general, Co-
bra incurs lower overall latency when the ratio of straight line
instructions to branches and loops is greater over a localized
code region as exempliﬁed by analysis range 4. In other cases,
the overall latency of the framework depends upon the number
and nature of the branches encountered in the code stream. As
an example, analysis range 2 incurs a latency as high as 5 times
its normal execution time. This is due to the presence of a high