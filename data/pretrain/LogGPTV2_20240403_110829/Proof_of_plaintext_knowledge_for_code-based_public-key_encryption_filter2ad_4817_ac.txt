private-index predicate encryption, whereas attribute-based encryption (which do not hide the
policy or attributes underlying each ciphertext) are referred to as public-index predicate en-
cryption. It is important to note that the construction from [GVW15b] only hides the attributes
underlying each ciphertext (they build a key-policy predicate encryption, where attributes are
associated with ciphertexts) when the adversary can only obtain functional decryption keys
for access policies which are not satisﬁed by the attribute of the challenge ciphertext. This
is referred to as weakly-hiding the attributes. Prior works [BW07, KSW08, KSW13] fully
hide the attributes associated with each ciphertext, the only information that leaks being the
value of the predicate evaluation, namely, whether or not the decryption succeeds. In fact,
fully-hiding predicate encryption for all circuits essentially implies functional encryption for
all circuits, for which we have no construction based on standard assumptions. We defer the
interested reader to [GVW15b, 1.3 Discussion] for further details on the connections between
predicate encryption and functional encryption for all circuits.
Functional encryption beyond predicates. So far, we have only discussed special kinds
of functional encryption where decryption successfully recovers the entire message if the at-
tributes associated with the ciphertext (resp. the functional decryption key) satisfy the access
policy embedded in the key (resp. the ciphertext). While this is a fruitful generalization of
traditional public-key encryption, since it permits embedding complex access policy into the
encrypted data, this is still an all-or-nothing encryption: either the message is entirely recov-
ered by the decryption, or no information whatsoever is revealed about the message. Not much
is known about functional encryption with ﬁne-grained access to the encrypted data, that is,
where decryption recovers partial information about the encrypted data. In [ABDP15], the
authors build the ﬁrst construction of functional encryption from standard assumptions be-
yond predicates. In [ABDP15], messages to be encrypted are vectors of integers, in Zd, for
some dimension d ∈ N that is ﬁxed during the setup of the scheme. Functional decryption keys
8
Chapter 1. Introduction
are associated with vectors y ∈ Zd. Decryption of an encryption of x ∈ Zd with a functional
decryption key associated with y ∈ Zd recovers hx, yi ∈ Z, which denotes the inner product
between x and y. Otherwise stated, this encryption scheme lets owners of functional decryp-
tion keys compute weighted sum on the encrypted data. Moreover, it is possible to encode
any constant-depth formula as a polynomial of constant degree, which can be evaluated via
functional encryption for inner products. That is, this scheme handles computation of NC0
circuits on encrypted data. Later, [ALS16] gave fully-secure functional encryption schemes
(the original schemes from [ABDP15] being only selectively-secure). In this thesis, we present
extensions of these functional encryption for inner products, and new functional encryption
schemes with succinct ciphertexts that supports the evaluation of degree-2 polynomials on
encrypted data. More details on the contributions of this thesis are given below.
Related works: functional encryption for bounded collusion. The case where security
is guaranteed only when a constant number of functional decryption keys are corrupted has
been considered in prior works. [SS10] built the ﬁrst functional encryption for all circuits, where
security handles the corruption of one functional decryption key, using garbled circuits and
public-key encryption. In this functional encryption, the ciphertext size depends on the size
of the circuit associated with the functional decryption keys (which thus needs to be bounded
[GKP+13] improves upon [SS10] since the ciphertext size
during the setup of the scheme).
depends only on the size of the output of the function for which functional decryption keys
are generated. They use attributed-based encryption for all circuits, and fully homomorphic
encryption, both of which admits construction from standard assumptions. Note that the
security of both of these constructions breaks down as soon as two functional decryption keys
are corrupted. [GVW12, Agr17] show how to generically turn any functional encryption secure
only when one functional decryption key is corrupted, into a functional encryption scheme
where security handles an a priori bounded polynomial number of collusions. We now consider
the case of general functional encryption with unbounded collusions.
Theoretical motivation: the power of general purpose functional encryption. As
mentioned before, the existing functional encryption schemes from standard assumptions only
permit the evaluation of degree-1 (inner products) or degree-2 polynomials on the encrypted
data. However, there are feasibility results for functional encryption schemes where functions
associated to functional decryption keys can be any arbitrary circuits (such schemes are called
general purpose functional encryption schemes). The ﬁrst candidate construction for general
purpose functional encryption appeared in [GGH+13b, GGH+16]. It relies on Indistinguisha-
bility Obfuscation, a powerful object, originally deﬁned in [BGI+01, BGI+12], that has been
remarkably successful at providing an all-purpose tool for solving cryptographic problems, as
shown in [SW14]. [GGH+13b, GGH+16] gave a construction for Indistinguishability Obfusca-
tion that relies on cryptographic multilinear maps, for which there is currently no construction
from standard assumptions. Other works [BLR+15, GGHZ16] gave direct candidate construc-
tions of functional encryption from multilinear maps.
Follow-ups [Lin16, LV16, Lin17, AS17, LT17] focused on reducing the degree of the required
multilinear map, all the way down to 3 in [LT17] (the degree of the multilinear map required in
prior works depends on the complexity of the circuits for which functional decryption keys are
generated). Namely, in [LT17], general purpose functional encryption is built from succinct
functional encryption which handles evaluation of degree-3 polynomials on encrypted data
(which can be built from degree 3 multilinear maps), together with some assumptions on the
existence of special kind of pseudo-random generators1. Here, succinctness refers to the fact
that the ciphertext size only depends on the underlying message, and not the functions for
which functional decryption keys are generated. Unfortunately, there is no construction of even
1Namely, the existence of pseudo-random generators of block-wise locality 3.
1.2 Functional Encryption
9
degree-3 multilinear from standard assumptions. To sum up, all existing general purpose func-
tional encryption schemes either rely on multilinear maps, or Indistinguishability Obfuscation,
both of which rely on non-standard assumptions. In fact, general purpose functional encryption
has been shown to imply Indistinguishability Obfuscation in [AJ15, BV15, BNPW16].
Contribution 2: Functional Encryption with New Features, and Richer
Functionalities
Motivated by the quest for succinct functional encryption for richer classes of functions, we
follow the bottom-up approach initiated by [ABDP15], which consists of building functional
encryption as expressive as possible from standard assumptions. The beneﬁt of this approach is
two-fold: ﬁrst, it aims at bridging the gap between the powerful Indistinguishability Obfusction,
and the current constructions from standard assumptions; second, it gives practically relevant
schemes based from concrete assumptions, which are interesting in their own right. We present
extensions of the original functional encryption for inner products from [ABDP15, ALS16] with
additional features:
in contribution 2.1, we extend functional encryption for inner products
to the multi-input setting, and to the multi-client setting in contribution 2.2, both of which
generalize the standard single-input setting. Then, we expand functional encryption for richer
classes of functions in contribution 2.3. These contributions are presented in more details
below.
Contribution 2.1: multi-input encryption for inner products.
We present here an extension of the original functional encryption from [ABDP15, ALS16] to
the more general multi-input setting.
Deﬁnition of multi-input functional encryption. As explained above, in a functional
encryption (FE) scheme [SW05, BSW11], an authority can generate restricted decryption keys
that allow users to learn speciﬁc functions of the encrypted messages and nothing else. That is,
each FE decryption key dkf is associated with a function f and decrypting a ciphertext Enc(x)
with dkf results in f(x). Multi-input functional encryption (MIFE) introduced by [GGG+14]
is a generalization of functional encryption to the setting of multi-input functions. A MIFE,
the scheme has several encryption slots and each decryption key dkf for a multi-input function
f decrypts jointly ciphertexts Enc(x1), . . ., Enc(xn) for all slots to obtain f(x1, . . . , xn) without
revealing anything more about the encrypted messages. The MIFE functionality provides the
capability to encrypt independently messages for diﬀerent slots. This facilitates scenarios where
information, which will be processed jointly during decryption, becomes available at diﬀerent
points of time or is provided by diﬀerent parties. MIFE has many applications related to
computation and data mining over encrypted data coming from multiple sources, which include
examples such as executing search queries over encrypted data, processing encrypted streaming
data, non-interactive diﬀerentially private data releases, multi-client delegation of computation,
order-revealing encryption [GGG+14, BLR+15].
Application of multi-input functional encryption for inner products. For instance,
consider a database that contains proﬁles of the employees in company, where each proﬁle
describes the qualiﬁcations that the person has and the position that she can hold. Each such
proﬁle can be represented as an integer vector that contains the scores that person has received
for her qualiﬁcations in her last evaluation. The employee proﬁles are sensitive information
and only direct managers can access the proﬁle information of the people in their teams.
Therefore, the information of proﬁles needs to be protected from everyone else in the company.
At the same time when the company starts a new project, the manager assigned to lead the
project needs to select people for the new team. According to the needs of the project, the team
10
Chapter 1. Introduction
should have people serving diﬀerent roles; the qualiﬁcations of each team member have diﬀerent
importance for every project. The selection criterion for the team members can be described
as an integer vector that assigns weights to the diﬀerent qualiﬁcations for the members in all
team positions. In order to evaluate and compare potential teams, the manager needs to obtain
the team score for each of them, which is the weighted sum of the individual qualiﬁcations.
A MIFE for inner products provides a perfect solution for the above scenario that protects
the privacy of the proﬁles while enabling managers to evaluate possible team conﬁgurations.
MIFE encryption slots will correspond to diﬀerent team positions. Each person’s proﬁle will
be a vector of her scores, which will be encrypted for the slot corresponding to the position
she is qualiﬁed to hold. When a new project is established, the leading manager is granted a
decryption key that is associated with an integer vector that assigns appropriate weight to each
qualiﬁcation of diﬀerent team members. The manager can use this key to evaluate diﬀerent
combinations of people for the team while learning nothing more about the people’s proﬁles
than the team score. A similar example is the construction of a complex machine that requires
parts from diﬀerent manufacturers. Each part is rated based on diﬀerent quality characteristics
and prices, which are all manufacturer’s proprietary information until a contract has been
signed. The ultimate goal is to assemble a construction of parts that achieve a reasonable
trade-oﬀ between quality and price. In order to evaluate diﬀerent construction conﬁgurations,
the company wants to compute cumulative score for each conﬁguration that is a weighted sum
over the quality rates and price of each of the parts.
State of the art for multi-input functional encryption. There are several construc-
tions of MIFE schemes, which can be broadly classiﬁed as follows: (i) feasibility results for
general circuits [GGG+14, BGJS15, AJ15, BKS16], and (ii) constructions for speciﬁc func-
tionalities, notably comparison, which corresponds to order-revealing encryption [BLR+15].
Unfortunately, all of these constructions rely on indistinguishability obfuscation, single-input
FE for circuits, or multilinear maps [GGH+13b, GGH13a], which we do not know how to
instantiate under standard and well-understood cryptographic assumptions.2
In [AGRW17], we present a multi-
A new construction of MIFE for inner products.
input functional encryption scheme (MIFE) for inner products based on standard assumptions
in prime-order bilinear groups. Our construction works for any polynomial number of encryp-
tion slots and achieves adaptive security against unbounded collusion, while relying on standard
polynomial hardness assumptions. Prior to this work, we did not even have a candidate for
3-slot MIFE for inner products in the generic bilinear group model. Our work is also the ﬁrst
MIFE scheme for a non-trivial functionality based on standard cryptographic assumptions,
as well as the ﬁrst to achieve polynomial security loss for a super-constant number of slots
under falsiﬁable assumptions. Prior works required stronger non-standard assumptions such
as indistinguishability obfuscation or multilinear maps. Later, in [ACF+18], we put forward a
novel methodology to convert single-input functional encryption for inner products into multi-
input schemes for the same functionality. Our transformation is surprisingly simple, general
and eﬃcient. In particular, it does not require pairings and it can be instantiated with all
known single-input schemes. This leads to two main advances. First, we enlarge the set of
assumptions this primitive can be based on, notably, obtaining new MIFEs for inner products
from plain DDH, LWE, and Decisional Composite Residuosity. Second, we obtain the ﬁrst
MIFE schemes from standard assumptions where decryption works eﬃciently even for mes-
sages of super-polynomial size. In this thesis, we strengthen the security of these constructions
to handle corruption of the input slots. That is, to encrypt, each input slot i ∈ [n] requires an
encryption key eki. We consider the private-key setting, where encryption keys remain secret.
2Here, we refer only to unbounded collusions (i.e. the adversary can request for any number of secret keys).
See the paragraph about related works for results on bounded collusions.
1.2 Functional Encryption
11
This is actually more relevant than the public-key setting, where the encryption keys eki are
revealed to everyone. Indeed, in such a case, anyone can encrypt arbitrary message for any
input slot. That weakens security drastically, since a challenge ciphertext Enc(eki, mb) for mes-
sage mb
i, where b ←R {0, 1} is chosen by the security game, can be combined with encryption
of arbitrary messages for the other input slots during decryption. That means that given even
a single functional decryption key for a function f, one can learn f(∗,··· ,∗, mb
i ,∗, x··· ,∗),
where each ∗ can be any arbitrary message. This is simply too much information in most rel-
evant use cases. Thus, we consider the setting where encryption keys eki aren’t public, which
avoids precisely this kind of leakage of information. In the schemes presented in Chapter 4
and Chapter 5, the security holds even when some eki are corrupted. That means that even
given eki for some slots i ∈ [n], the security remains for other slots j 6= i. This is an important
security feature, since that means even colluding users cannot learn any information about
the encrypted messages by other users. This is relevant to assume such collusions, since in a
multi-input encryption scheme, users do not communicate with each other, and do not trust
each other. This is a novelty compared to [AGRW17, ACF+18]. A summary of our results and
prior works on functional encryption for inner products is shown in Figure 1.3.
Reference
[ABDP15]
[ALS16, ABDP16]
[BSW11]
[LL18]
[KLM+18]
Chapter 4
Chapter 5
# inputs
setting
security
assumption
pairing
1
1
1
2
2
public-key many-SEL-IND
public-key many-AD-IND
DDH
DDH
no
no
any
many-SEL-SIM
impossible
private-key many-SEL-IND
SXDH + T3DH
yes
private-key
single-key
many-AD-IND3
function-private FE
yes
multi
private-key many-AD-IND
SXDH
multi
private-key many-AD-IND DDH, DCR, LWE
yes
no
Figure 1.3: Summary of constructions from cyclic or bilinear groups. We have 8 security
notions xx-yy-zzz where xx ∈ {one, many} refers to the number of challenge ciphertexts; yy
∈ {SEL, AD} refers to the fact that encryption queries are selectively or adaptively chosen;
zzz ∈ {IND, SIM} refers to indistinguishability vs simulation-based security. SXDH stands
for Symmetric eXternal Diﬃe Hellman assumption, DDH stands for Decisional Diﬃe Hellman
assumption, DCR stands for Decisional Composite Residuosity assumption, and LWE stands
for Learning With Errors assumption.
Contribution 2.2: multi-client functional encryption for inner products.
We now present another contribution of this thesis, which is an extension of multi-input func-
tional encryption, where the encryption can additionally handle labels, which prevents mixing
and matching diﬀerent ciphertexts with diﬀerent labels, thereby giving a stronger security
notion. The labels are typically set to be time stamps, for the application we have in mind.
In multi-client functional encryption,
Deﬁnition of multi-client functional encryption.
as deﬁned in [GGG+14, GKL+13], the single input x to the encryption procedure is bro-
ken down into an input vector (x1, . . . , xn) where the components are independent. An
index i for each client and a (typically time-based) label ℓ are used for every encryption:
(c1 = Enc(1, x1, ℓ), . . . , cn = Enc(n, xn, ℓ)). Anyone owning a functional decryption key dkf ,
for an n-ary function f and multiple ciphertexts for the same label ℓ, c1 = Enc(1, x1, ℓ), . . . , cn =
12
Chapter 1. Introduction
Enc(n, xn, ℓ), can compute f(x1, . . . , xn) but nothing else about the individual xi’s. The com-
bination of ciphertexts generated for diﬀerent labels does not give a valid global ciphertext and
the adversary learns nothing from it. This is diﬀerent from multi-input functional encryption,
where every ciphertext for every slot can be combined with any other ciphertext for any other
slot, and used with functional decryption keys to decrypt an exponential number of values, as
soon as there is more than one ciphertext per slot. This “mix-and-match” feature is crucial for
some of the applications of MIFE, such as building Indistinguishability Obfuscation [GGG+14].
However, it also means the information leaked about the underlying plaintext is too much for
some applications. In the multi-client setting, however, since only ciphertexts with the same
label can be combined for decryption, the information leaked about the encrypted messages is
drastically reduced.
Decentralized multi-client functional encryption. While it allows independent genera-
tion of the ciphertexts, multi-client functional encryption (like multi-input functional encryp-
tion) still assumes the existence of a trusted third party who runs the Setup algorithm and
distributes the functional decryption keys. This third party, if malicious or corrupted, can
easily undermine any client’s privacy. We are thus interested in building a scheme in which
such a third party is entirely taken out of the equation. In [CDG+18a], we introduce the no-
tion of decentralized multi-client functional encryption, in which the authority is removed and
the clients work together to generate appropriate functional decryption keys. We stress that
the authority is not simply distributed to a larger number of parties, but that the resulting
protocol is indeed decentralized: each client has complete control over their individual data
and the functional keys they authorize the generation of.
In
A new decentralized multi-client functional encryption for inner products.
[CDG+18a], we give the ﬁrst decentralized multi-client functional encryption from standard
assumptions, for inner products. Security is proven using bilinear pairing groups, and handles
corruption of input slots. We ﬁrst give an eﬃcient centralized scheme whose security does