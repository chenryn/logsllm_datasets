### Private-Index and Public-Index Predicate Encryption

Private-index predicate encryption (PIPE) is a cryptographic scheme where the policy or attributes underlying each ciphertext are hidden. In contrast, attribute-based encryption (ABE), which does not hide the policy or attributes, is referred to as public-index predicate encryption (PIPE).

It is important to note that the construction from [GVW15b] only hides the attributes underlying each ciphertext when the adversary can only obtain functional decryption keys for access policies that are not satisfied by the attribute of the challenge ciphertext. This is referred to as weakly-hiding the attributes. Prior works [BW07, KSW08, KSW13] fully hide the attributes associated with each ciphertext, with the only information leaked being the value of the predicate evaluation, i.e., whether or not the decryption succeeds.

In fact, fully-hiding predicate encryption for all circuits essentially implies functional encryption for all circuits, for which we currently have no construction based on standard assumptions. For further details on the connections between predicate encryption and functional encryption for all circuits, we refer the interested reader to [GVW15b, 1.3 Discussion].

### Functional Encryption Beyond Predicates

So far, we have discussed special kinds of functional encryption where decryption successfully recovers the entire message if the attributes associated with the ciphertext (or the functional decryption key) satisfy the access policy embedded in the key (or the ciphertext). While this generalizes traditional public-key encryption by allowing complex access policies, it remains an all-or-nothing encryption: either the message is entirely recovered by the decryption, or no information is revealed about the message.

Little is known about functional encryption with fine-grained access to encrypted data, where decryption recovers partial information about the encrypted data. In [ABDP15], the authors present the first construction of functional encryption beyond predicates from standard assumptions. In this scheme, messages to be encrypted are vectors of integers in \(\mathbb{Z}^d\) for some fixed dimension \(d \in \mathbb{N}\). Functional decryption keys are associated with vectors \(y \in \mathbb{Z}^d\). Decryption of an encryption of \(x \in \mathbb{Z}^d\) with a functional decryption key associated with \(y \in \mathbb{Z}^d\) recovers \(\langle x, y \rangle \in \mathbb{Z}\), which denotes the inner product between \(x\) and \(y\). This scheme allows owners of functional decryption keys to compute weighted sums on the encrypted data. Moreover, any constant-depth formula can be encoded as a polynomial of constant degree, which can be evaluated via functional encryption for inner products, handling the computation of NC0 circuits on encrypted data.

Later, [ALS16] provided fully-secure functional encryption schemes, whereas the original schemes from [ABDP15] were only selectively secure. In this thesis, we present extensions of these functional encryption schemes for inner products and new functional encryption schemes with succinct ciphertexts that support the evaluation of degree-2 polynomials on encrypted data. More details on the contributions of this thesis are given below.

### Related Works: Functional Encryption for Bounded Collusion

Prior works have considered the case where security is guaranteed only when a constant number of functional decryption keys are corrupted. [SS10] built the first functional encryption for all circuits, where security handles the corruption of one functional decryption key, using garbled circuits and public-key encryption. The ciphertext size in this scheme depends on the size of the circuit associated with the functional decryption keys, which must be bounded during the setup. [GKP+13] improved upon [SS10] by making the ciphertext size dependent only on the size of the output of the function for which functional decryption keys are generated. They used attribute-based encryption for all circuits and fully homomorphic encryption, both of which can be constructed from standard assumptions. However, the security of these constructions breaks down as soon as two functional decryption keys are corrupted.

[GVW12, Agr17] showed how to generically transform any functional encryption scheme secure only when one functional decryption key is corrupted into a scheme where security handles an a priori bounded polynomial number of collusions. We now consider the case of general functional encryption with unbounded collusions.

### Theoretical Motivation: The Power of General-Purpose Functional Encryption

Existing functional encryption schemes from standard assumptions only permit the evaluation of degree-1 (inner products) or degree-2 polynomials on the encrypted data. However, there are feasibility results for functional encryption schemes where functions associated with functional decryption keys can be any arbitrary circuits, known as general-purpose functional encryption schemes. The first candidate construction for such schemes appeared in [GGH+13b, GGH+16], relying on Indistinguishability Obfuscation (IO), a powerful object originally defined in [BGI+01, BGI+12]. IO has been remarkably successful at providing an all-purpose tool for solving cryptographic problems, as shown in [SW14]. [GGH+13b, GGH+16] provided a construction for IO that relies on cryptographic multilinear maps, for which there is currently no construction from standard assumptions.

Other works [BLR+15, GGHZ16] gave direct candidate constructions of functional encryption from multilinear maps. Follow-ups [Lin16, LV16, Lin17, AS17, LT17] focused on reducing the degree of the required multilinear map, with [LT17] achieving a degree of 3. In [LT17], general-purpose functional encryption is built from succinct functional encryption, which handles the evaluation of degree-3 polynomials on encrypted data, together with some assumptions on the existence of special kinds of pseudo-random generators. Here, succinctness refers to the fact that the ciphertext size only depends on the underlying message, not the functions for which functional decryption keys are generated. Unfortunately, there is no construction of even degree-3 multilinear maps from standard assumptions. To summarize, all existing general-purpose functional encryption schemes either rely on multilinear maps or IO, both of which rely on non-standard assumptions. In fact, general-purpose functional encryption has been shown to imply IO in [AJ15, BV15, BNPW16].

### Contribution 2: Functional Encryption with New Features and Richer Functionalities

Motivated by the quest for succinct functional encryption for richer classes of functions, we follow the bottom-up approach initiated by [ABDP15], building functional encryption as expressive as possible from standard assumptions. This approach aims to bridge the gap between powerful IO and current constructions from standard assumptions and provides practically relevant schemes based on concrete assumptions. We present extensions of the original functional encryption for inner products from [ABDP15, ALS16] with additional features:

1. **Multi-Input Encryption for Inner Products**: We extend the original functional encryption for inner products to the more general multi-input setting.
2. **Multi-Client Functional Encryption for Inner Products**: We introduce multi-client functional encryption, which handles labels to prevent mixing and matching different ciphertexts, thereby providing a stronger security notion.
3. **Decentralized Multi-Client Functional Encryption for Inner Products**: We introduce the notion of decentralized multi-client functional encryption, where the authority is removed, and clients work together to generate appropriate functional decryption keys.

These contributions are presented in more detail below.

#### Contribution 2.1: Multi-Input Encryption for Inner Products

We extend the original functional encryption from [ABDP15, ALS16] to the more general multi-input setting.

**Definition of Multi-Input Functional Encryption (MIFE)**: In a functional encryption (FE) scheme [SW05, BSW11], an authority can generate restricted decryption keys that allow users to learn specific functions of the encrypted messages and nothing else. That is, each FE decryption key \(dk_f\) is associated with a function \(f\), and decrypting a ciphertext \(Enc(x)\) with \(dk_f\) results in \(f(x)\). MIFE, introduced by [GGG+14], generalizes functional encryption to the setting of multi-input functions. A MIFE scheme has several encryption slots, and each decryption key \(dk_f\) for a multi-input function \(f\) decrypts jointly ciphertexts \(Enc(x_1), \ldots, Enc(x_n)\) for all slots to obtain \(f(x_1, \ldots, x_n)\) without revealing anything more about the encrypted messages. MIFE facilitates scenarios where information, which will be processed jointly during decryption, becomes available at different points in time or is provided by different parties. MIFE has many applications related to computation and data mining over encrypted data from multiple sources, including executing search queries over encrypted data, processing encrypted streaming data, non-interactive differentially private data releases, multi-client delegation of computation, and order-revealing encryption [GGG+14, BLR+15].

**Application of Multi-Input Functional Encryption for Inner Products**: Consider a database containing profiles of employees in a company, where each profile describes the qualifications and positions they can hold. Each profile can be represented as an integer vector containing scores received for qualifications in their last evaluation. These profiles are sensitive information, and only direct managers can access the profile information of people in their teams. When the company starts a new project, the manager needs to select team members based on the project's needs. The selection criterion can be described as an integer vector assigning weights to different qualifications for team members. A MIFE for inner products provides a solution that protects the privacy of the profiles while enabling managers to evaluate potential team configurations. MIFE encryption slots correspond to different team positions, and each person’s profile is a vector of scores encrypted for the slot corresponding to the position they are qualified to hold. The leading manager is granted a decryption key associated with an integer vector that assigns appropriate weights to each qualification. The manager can use this key to evaluate different combinations of people for the team while learning nothing more about the people’s profiles than the team score.

**State of the Art for Multi-Input Functional Encryption**: There are several constructions of MIFE schemes, broadly classified as follows: (i) feasibility results for general circuits [GGG+14, BGJS15, AJ15, BKS16], and (ii) constructions for specific functionalities, notably comparison, which corresponds to order-revealing encryption [BLR+15]. Unfortunately, all these constructions rely on indistinguishability obfuscation, single-input FE for circuits, or multilinear maps [GGH+13b, GGH13a], which we do not know how to instantiate under standard and well-understood cryptographic assumptions.

In [AGRW17], we present a multi-input functional encryption scheme (MIFE) for inner products based on standard assumptions in prime-order bilinear groups. Our construction works for any polynomial number of encryption slots and achieves adaptive security against unbounded collusion, relying on standard polynomial hardness assumptions. Prior to this work, we did not have a candidate for 3-slot MIFE for inner products in the generic bilinear group model. Our work is the first MIFE scheme for a non-trivial functionality based on standard cryptographic assumptions and the first to achieve polynomial security loss for a super-constant number of slots under falsifiable assumptions. Later, in [ACF+18], we introduced a novel methodology to convert single-input functional encryption for inner products into multi-input schemes for the same functionality. Our transformation is simple, general, and efficient, and it does not require pairings. This leads to two main advances: (i) enlarging the set of assumptions this primitive can be based on, obtaining new MIFEs for inner products from plain DDH, LWE, and Decisional Composite Residuosity, and (ii) obtaining the first MIFE schemes from standard assumptions where decryption works efficiently even for messages of super-polynomial size. In this thesis, we strengthen the security of these constructions to handle corruption of the input slots.

#### Contribution 2.2: Multi-Client Functional Encryption for Inner Products

We extend multi-input functional encryption to handle labels, which prevents mixing and matching different ciphertexts with different labels, thereby providing a stronger security notion. The labels are typically set to be time stamps.

**Definition of Multi-Client Functional Encryption**: As defined in [GGG+14, GKL+13], the single input \(x\) to the encryption procedure is broken down into an input vector \((x_1, \ldots, x_n)\) where the components are independent. An index \(i\) for each client and a (typically time-based) label \(\ell\) are used for every encryption: \((c_1 = Enc(1, x_1, \ell), \ldots, c_n = Enc(n, x_n, \ell))\). Anyone owning a functional decryption key \(dk_f\) for an \(n\)-ary function \(f\) and multiple ciphertexts for the same label \(\ell\), \(c_1 = Enc(1, x_1, \ell), \ldots, c_n = Enc(n, x_n, \ell)\), can compute \(f(x_1, \ldots, x_n)\) but nothing else about the individual \(x_i\)'s. The combination of ciphertexts generated for different labels does not give a valid global ciphertext, and the adversary learns nothing from it. This is different from multi-input functional encryption, where every ciphertext for every slot can be combined with any other ciphertext for any other slot, and used with functional decryption keys to decrypt an exponential number of values, as soon as there is more than one ciphertext per slot. This "mix-and-match" feature is crucial for some applications of MIFE, such as building Indistinguishability Obfuscation [GGG+14]. However, it also means the information leaked about the underlying plaintext is too much for some applications. In the multi-client setting, since only ciphertexts with the same label can be combined for decryption, the information leaked about the encrypted messages is drastically reduced.

**Decentralized Multi-Client Functional Encryption**: While it allows independent generation of the ciphertexts, multi-client functional encryption still assumes the existence of a trusted third party who runs the Setup algorithm and distributes the functional decryption keys. This third party, if malicious or corrupted, can easily undermine any client’s privacy. In [CDG+18a], we introduce the notion of decentralized multi-client functional encryption, where the authority is removed, and the clients work together to generate appropriate functional decryption keys. We stress that the authority is not simply distributed to a larger number of parties, but the resulting protocol is indeed decentralized: each client has complete control over their individual data and the functional keys they authorize the generation of.

In [CDG+18a], we present the first decentralized multi-client functional encryption from standard assumptions, for inner products. Security is proven using bilinear pairing groups and handles corruption of input slots. We first give an efficient centralized scheme whose security does not rely on a trusted third party.