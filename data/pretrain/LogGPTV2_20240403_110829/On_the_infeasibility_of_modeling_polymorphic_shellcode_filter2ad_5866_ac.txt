sequences that it generates are sparsely spread out and each de-
coder looks very different from the next, then it will be dif(cid:2)cult to
than the dimensionality of the data sample.
train any generalized statistical models or extract useful signatures
until a suf(cid:2)ciently large number of samples from this engine are
seen. Our propagation metric is proportional to how long an en-
gine’s generated shellcode can propagate before a detector can be
properly trained.
OVERALL STRENGTH
We de(cid:2)ne the overall strength of a polymorphic engine (cid:5)((cid:1)) to
be the product of the variation strength and propagation strength
since they are positively correlated.
(cid:5)(engine) = (cid:9)(engine) (cid:1) (cid:8)(engine)
(5)
To normalize the metric, we (cid:2)nd the (cid:147)strengths(cid:148) of completely ran-
dom distributions of data we generated, then divide the strengths
of each engine by these strengths to generate a scaled score, which
we call the (cid:147)relative polymorphism score(cid:148), or (p-score) for short.
Non(cid:150)linear combinations (such as adding exponents to weight the
two strengths differently) of the (cid:8)((cid:1)) and (cid:9)((cid:1)) metrics are possible.
Althougth we could attempt to (cid:2)nd tighter bounds, our main goal
was to introduce this particular dual approach to quantifying the
capacity of polymorphic engines, allowing them to be ranked rela-
tive to one another. We therefore keep the metric in its basic setting
and leave open problems such as what is the most appropriate (cid:14)
function.
Engine
Shikata
Jcadd
C4d
Fnstenv
Clet
Admmutate
rand128
rand256
Prop. St. Var. St. Overall St.
0.14
0.11
0.06
0.07
0.14
0.15
0.16
0.16
53.24
44.62
14.62
15.70
53.00
68.76
36.90
73.74
7.24
4.87
0.83
1.05
7.37
10.59
5.83
11.61
p-score
0.62
0.42
0.07
0.09
0.63
0.91
0.50
1.00
Table 1: Decoder polymorphism strengths of various engines
under our metric (the (cid:2)rst four engines are from Metasploit).
Also shown are the scores for random distributions of strings
within range 128 and range 256. Compare with Figure 2.
Table 1 shows the strengths of these engines based on our met-
rics. The latter two rows in the table, rand128 and rand256, refer to
a set of randomly generated strings with each byte values between
[0..128] and [0..256], respectively. This overall p-score, used in
conjunction with the spectral images, can be used to gauge the ef-
fectiveness of polymorphic engines relative to each other as well
as to noise. This comparison provides some utility for predicting
detection success rates of various IDS systems for newly released
engines. For example, IDS solutions that cannot detect CLET sam-
ples have no hope against ADMmutate. The p-score is also useful
in determining identi(cid:2)ability. Engines with scores higher than a
certain threshold would generate decoders which cannot be traced
back to the same engine, as we can see from the spectral image
for ADMmutate. The value of this threshold is the subject of our
ongoing work.
Some of the engines we examined can be adjusted to obtain bet-
ter scores. For example, CLET allows the user to specify an ar-
bitrary number of decoding operations i.e., xor then sub then add,
and so on. Our experiments used the default setting of (cid:2)ve instruc-
tion operations. CLET’s main weakness derives from the (cid:2)xed way
in which it clears registers before decoding. Therefore, testing dif-
ferent levels of ciphering would not yield signi(cid:2)cantly different re-
sults. Note that three of the engines from Metasploit are not entirely
polymorphic (according to the Metasploit documentation) and it is
easy to see which ones these are.
While CLET’s cleverness and ef(cid:2)ciency was on par with that of
ADMmutate in terms of disguising its payload, we found that all
decoders generated by CLET contained a unique 9-byte signature
string that represents a set of instructions used to clear the work-
ing registers and the appropriate jump/call instructions used to load
the needed loop counter variable into memory. While CLET is
one of the more creative engines that we have seen, this particular
feature makes the decoders easier to detect and identify than the
other engines, thus explaining the lowered score. The CLET team
acknowledged as one of their weaknesses this static structural lay-
out [13]. This weakness is not dif(cid:2)cult to address, and we expect
future versions of CLET will eliminate these artifacts.
3. A HYBRID ENGINE: FULL SPECTRUM
POLYMORPHISM AND BLENDING
Previous sections illustrated how polymorphism works in vari-
ous engines and how ef(cid:2)cient certain engines are at hiding their
payloads.
In this section, we show how one can extend existing
polymorphic methods by combining two powerful engines: CLET
and ADMmutate. While CLET’s decoder leaves some noticeable
artifacts, it has very useful spectral ciphering techniques that al-
low the shellcode to blend to a target byte distribution. ADMmu-
tate cannot perform blending attacks, but it generates very random
looking decoders as well as a recursive NOP sled. We simply use
CLET to cipher the shellcode, then hide CLET’s decoder with AD-
Mmutate. We also take advantage of ADMmutate’s advanced NOP
sled generator. Section 1.2 outlines some of the techniques used to
make the other sections polymorphic, and we employ these tactics
in our engine design.
The combination of these engines makes the shellcode not only
impossible to model but also allows the exploit instance to blend
in with normal network traf(cid:2)c. Every section of the shellcode can
be made polymorphic, leaving only the blending section exposed,
as demonstrated in Figure 3. Here, we have added bytes into each
of padding sections of the shellcode samples, so that when stacked
together, the shellcode shows the ACM SIGSAC logo. Each row of
the three spectral images shown in Figure 3 represents a 512-byte
fully working shellcode sample that was tested and con(cid:2)rmed to
execute successfully.
The polymorphic capabilities employed by ADMmutate, which
uses two layers of ciphering on the payload using 16-bit random
keys, allows the payload to be scattered across n-space and thus
avoids being detected by signature detectors. The padding section
(a)
(b)
(c)
Figure 3: Spectral images. (a) A single CLET mutated exploit
is stacked row-wise 100 times (note the vertical bands). Next
to it, CLET’s polymorphic blending ability leaves a padding
area open for arbitrary (cid:2)ller bytes which are never reached in
the execution. We (cid:2)ll it with the ACM logo. (b) CLET’s de-
coder and exploit is hidden by ADMMutate, leaving only the
blending bytes exposed. The repeating columns represent the
[RETADDR] section, which is shown morphed in (c) using the
random offset method.
can carry an arbitrary byte combination since the exploit exists to
the left of the section and triggers immediately before the execu-
tion (cid:3)ow ever passes into the padding section. (cid:147)Normal-looking(cid:148)
n-grams, placed within this padding section, can thus allow the
shellcode to blend into normal traf(cid:2)c (cid:151) slipping by statistical IDS
methods as well. It is also non(cid:150)trivial to model the blending bytes
section; one simply takes as input a distribution model and for
every byte feature i, multiply it with the length of the section to
(cid:2)nd how many of these bytes to use. The section is then (cid:2)lled
up with accordingly with the appropriate number of bytes for each
0x00: : :0xFF value, then this section is randomly permuted (for
example, rearranging the order of the bytes). This alteration pre-
vents the derivation of signatures. Statistically speaking, the sec-
tion has not changed since all of the bytes are still present in their
corresponding frequencies. We implemented this technique in our
engine and report results later in the section.
For this particular demonstration, we have chosen a padding sec-
tion of size 100 bytes, out of a total shellcode size of 512 bytes. Of
course, this section and the entire shellcode sample can be enlarged.
The only change that needs to be made is to increment the values
in the [RETADDR] section to (cid:147)aim a little higher(cid:148) into memory to
compensate for the larger shellcode.
The [RETADDR] section is the series of repeated columns seen
to the right of the padding section in Figure 3(a) and (b) (cid:151) notice
the periodicity. As mentioned above, the [RETADDR] is not easily
modeled. This portion normally has variable length, is mutable,
and is both platform and vulnerability dependent. This mutability
feature is demonstrated in Figure 3(c) where we have mutated the
[RETADDR] section by aiming the instruction pointer at the center
of the NOP sled and adding a random byte offset of approximately
50 bytes in each of the repeated return addresses. This gives us
about 100m possible unique sequences for the [RETADDR] section,
where m is the number of times the target address is repeated. The
base of the exponent (100) can be larger or smaller, depending on
3.5
3
2.5
2
1.5
1
0.5
0
0
50
100
150
200
250
300
(a)
(b)
Figure 4: adm+clet engine. (a) 1-gram distribution (b) 3-gram
scatter. Comparing this to Figure (7), we can see that this en-
gine is equally dif(cid:2)cult to model.
how large the NOP sled section is. The only real weakness we see
from ADMMutate is a white column, representing a 4-byte salient
artifact generated by the engine, which is too small to use as a sig-
nature or statistical model.
In terms of statistical features, Figure 4(a) shows the 1-gram dis-
tribution of the ADMmutate decoder section of the above engine,
which was calculated by (cid:2)nding the average 1-byte histogram of
these decoders, then normalizing it by dividing by the variance
along each dimension.
Dividing by the variance normalizes the values so that we obtain
their discriminative scores. For example, if a feature is consistently
present, it has low variance. Therefore, dividing by its variance will
increase the prominence of that feature. Conversely, if a feature ex-
hibits very high variance, then its reliability in statistical modeling
is correspondingly low. From Figure 4(a), we see that there is lit-
tle to no signal from the 1-byte distribution. Figure 4(b) shows the
3-gram scatter of these 100 decoders, showing us the range of 3-
grams present. As we can see, for 3-grams, it is a full spectrum
spread. If 3-space is saturated, then so is 2-space since it is a sub-
space within 3-space. Having the decoder bytes spread across n-
0.1
0.09
0.08
0.07
0.06
0.05
0.04
0.03
0.02
0.01
0
0
0.22
0.2
0.18
0.16
0.14
0.12
0.1
0.08
0
50
100
150
200
250
(a)
50
100
150
200
250
300
350
400
(b)
Figure 5: Our combined adm+clet engine executing a blending
attack. Image (a) shows target distribution, while image (b)
shows distance to target given padding section size.
space means we have some freedom to perform blending attacks,
since it means the engine can generate decoders which do not ap-
pear (cid:147)too binary.(cid:148) We implemented a blending attack function into
our adm+clet engine.
Figure 5 displays a simulation of a blending attack using our
engine. We (cid:2)rst arti(cid:2)cially generate a target distribution, shown
in Figure 5(a). We created a distribution from a mixture of three
Gaussians with centroids at 55 (ASCII character (cid:147)7(cid:148)), 77 (ASCII
character (cid:147)M(cid:148)) and 109 (ASCII character (cid:147)m(cid:148)) in order to simulate
the network traf(cid:2)c distribution of a server hosting many clear text
transfers. We also added some binary noise to account for binary
transfers (e.g., images and video). We set the variance of each of
the three Gaussians to 15. Next, we implemented the Mahalanobis