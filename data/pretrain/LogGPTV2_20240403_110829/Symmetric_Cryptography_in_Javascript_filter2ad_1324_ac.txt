Google Chrome, Microsoft Internet Explorer 8 beta, Apple
Safari 4, and Mozilla Firefox 3.0 and 3.5 beta 5. We enabled
the Javascript JIT compiler in Firefox 3.5. Safari 4 and
Google Chrome also use JIT compilers. Measurements were
taken on a Lenovo Thinkpad T61 with an Intel Core 2 Duo
processor (2.1 GHz) running 32-bit Windows Vista.
Table III shows code size and running times, in addition to
the speed improvement over the fastest previously existing
implementation for each browser. The improvement in speed
is due to our construction of large lookup tables in browser
memory that allow us to compute mixing functions quickly.
378
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:09:39 UTC from IEEE Xplore.  Restrictions apply. 
CRUNCHED SIZES AND SPEEDS FOR VARIOUS JAVASCRIPT AES IMPLEMENTATIONS.
Table III
Implementation
Size (B)
Speed (kB/s)
Chrome
IE 8b
Safari 4
Firefox 3.0
Firefox 3.5b5
Our code
Clipperz
EKU
BrowserSync
Javascrypt
Movable Type
Improvement
5687
9395
14667
15916
6455
6460
12%
585.2
58.6
99.0
125.9
16.2
111.4
60.4
2.1
2.7
5.2
1.3
5.2
264.8
12.3
136.9
231.5
33.6
110.7
97.4
4.8
5.1
21.8
13.3
13.1
451.6
5.4
42.8
62.3
13.9
45.8
365%
1062%
14%
347%
625%
The improvement in code size is due to precomputation: the
code to precompute our lookup tables is about 60% smaller
than a hard-coded S-box used in previous implementations.
B. Effects of precomputation
Precomputing both the S-box and the round transforma-
tions tables T results in a worst-case precomputation time of
fewer than 10 milliseconds each time the library is loaded.
Hard-coded tables speed up precomputation at the cost of
increased code size. In some browsers, precomputing the
tables may be even faster than loading them from disk.
Table IV shows that hardcoding nothing and instead
precomputing all
tables introduces minimal performance
degradation, but greatly reduces code size. Hardcoding both
the S-box and the T-tables can remove at most eight mil-
liseconds from the time taken to load the library, but that
hardly seems worth the code bloat.
Table IV shows that our approach to precomputation
provides the speed beneﬁts of hardcoding AES tables in the
code, but without the code bloat.
C. Effects of loop unrolling
Table V shows performance gains from unrolling loops
in the core encrypt function. The ﬁrst implementation is our
standard implementation with no unrolling. The second im-
plementation unrolls short loops with 4 or fewer iterations.
The third implementation unrolls the round transformation
loop as well, which iterates 10 times per block for 128-
bit keys. This is the technique used by OpenSSL [14]. As
Table V shows, unrolling short loops achieves no signiﬁcant
performance improvement. Unrolling the round function,
however, shows signiﬁcant improvements in some browsers
at the cost of increased code size. In some of the newer
Javascript interpreters, loop unrolling shows less of a perfor-
mance increase, suggesting that loop unrolling in Javascript
is currently effective but will become less relevant as users
adopt more modern interpreters.
We also experimented with loop unrolling in the CCM
and OCB implementations. These modes of operation wrap
the core AES code. There was no signiﬁcant improvement
in CCM and OCB performance in Chrome. Firefox 3.5
was improved by approximately 5% and 12%, respectively,
by unrolling short loops (mostly four or fewer iterations).
This same optimization had little effect on the AES core;
however, there are more short loops in the OCB imple-
mentation than AES, which accounts for the performance
improvement in OCB. Still, this small performance increase
came at the cost of a 12% increase in code size, motivating
our decision to use an implementation of OCB with no
unrolled loops in our library. Results for the standard and
unrolled implementations of OCB are shown in Table VI.
D. Comparison to other algorithms
To ensure that AES is a good choice for a Javascript
crypto library, we compared our optimized implementation
to our own implementations of other algorithms. Table VII
shows the results of these comparisons. We found that
SHA-256 is slower across all browsers, which motivated
our decision to abandon HMAC-SHA-256 for integrity and
instead use AES-CMAC.
We compared Javascript AES with a Javascript imple-
mentation of Salsa20/12 [20], one of the fastest eSTREAM
ciphers. A native x86 implementation of Salsa20/12 is about
5 times faster than a native implementation of 128-bit AES.
Surprisingly, Table VII shows that when both algorithms
are implemented in Javascript, Salsa 20/12 is comparable in
speed to AES. We believe that this discrepancy is primarily
due to Javascript’s lack of 128-bit SIMD instructions or of
64-bit registers, and secondarily due to Salsa20/12’s larger
state spilling to memory.
VI. CONCLUSION
We described an optimized Javascript implementation of
symmetric cryptography. Our primary contribution is an
approach which differs from typical AES implementations
and allows us to reduce code size and increase speed. Instead
of doing all the cipher computations at run-time or including
large lookup tables in code, our implementation precomputes
tables as soon as the ﬁrst cipher object is created. This
precomputation is fast enough to be a win when encrypting
or decrypting messages of any length, and it is much smaller
than hardcoding the tables themselves.
We studied various optimization tradeoffs for AES and
modes of operation (OCB and CCM), and we showed that
379
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:09:39 UTC from IEEE Xplore.  Restrictions apply. 
CRUNCHED SIZES AND SPEEDS FOR OUR AES IMPLEMENTATIONS WITH VARIOUS AMOUNTS OF PRECOMPUTATION.
Table IV
Hardcode
Size (B)
Chrome
IE 8b
Precomputation time (ms)
Firefox 3.0
Safari 4
Firefox 3.5b5
Nothing
S-box only
Everything
5687
8788
32799
0.89
0.78
7.85
7.33
1.59
1.59
2.93
2.77
3.03
3.04
CRUNCHED SIZES AND SPEEDS FOR OUR AES IMPLEMENTATIONS WITH VARIOUS AMOUNTS OF LOOP UNROLLING.
Table V
Unroll
Size (B)
Chrome
IE 8b
None
Short
Round
5687
6485 (+14%)
8814 (+55%)
1524
1596 (+5%)
1836 (+20%)
153
136 (−11%)
233 (+52%)
Speed (kB/s)
Safari 4
256
248 (−3%)
223 (−13%)
Firefox 3.0
260
253 (−3%)
453 (+74%)
Firefox 3.5b5
326
313 (−4%)
270 (−17%)
CRUNCHED SIZES AND SPEEDS FOR OUR OCB IMPLEMENTATION WITH AND WITHOUT LOOP UNROLLING.
Table VI
Unroll
Size (B)
Chrome
IE 8b
None
Short
3772
4221 (+12%)
183
193 (+5%)
34.9
34.7 (−0%)
Speed (kB/s)
Safari 4
54.2
53.9 (−1%)
Firefox 3.0
60.0
59.8 (−0%)
Firefox 3.5b5
42
47 (+12%)
PERFORMANCE OF AES, SHA-256, AND SALSA 20/12 (OUR IMPLEMENTATIONS).
Table VII
Algorithm
AES
AES unrolled
SHA-256
Salsa20/12
Chrome
679.4
753.6
131.9
452.2
IE 8b
63.2
92.0
38.6
148.8
Speed (kB/s)
Safari 4
Firefox 3.0
Firefox 3.5b5
248.0
214.0
71.3
266.0
124.5
173.5
50.9
161.8
347.2
289.4
153.2
283.1
certain standard optimizations are ineffective in the browser.
Our data suggests that SHA-256 performs far worse than
AES and consequently Javascript integrity schemes based
on AES are a better choice than integrity schemes based
on HMAC-SHA-256. Similarly, certain ciphers, like Salsa
20/12, consistently outperform AES in native code but do
not in Javascript. Our library, which is publicly available on
the Internet [21], is four times faster and 12% smaller than
previous Javascript AES implementations.
We also discussed the issue of generating cryptographic
randomness in the browser. We hope that future browsers
will provide a clean solution to this issue, for example by
implementing Netscape’s window.crypto.random.
REFERENCES
[1] Marco and G. Cesare, “Clipperz online password manager,”
2007, http://www.clipperz.com.
[2] “Google
http://www.google.com/tools/ﬁrefox/browsersync/.
Browser
Sync,”
2008,
[3] E. Styere, “Javascript AES Example,” October 2006,
http://people.eku.edu/styere/Encrypt/JS-AES.html.
[4] J. Walker, “JavaScrypt: Browser-Based Cryptography Tools,”
December 2005, http://www.fourmilab.ch/javascrypt.
[5] “Javascript
implementation of AES in counter mode,”
http://www.movable-type.co.uk/scripts/aes.html.
ACKNOWLEDGMENTS
This works was supported by NSF and the Packard
foundation. We thank Elie Bursztein for his help with the
user study.
[6] M. labs, “The weave project,” 2007, https://wiki.mozilla.org/
Labs/Weave/0.2.
[7] C. Jackson, A. Barth, and J. Mitchell, “Securing frame
communication in browsers,” in Proc. of USENIX Security
2008, 2008.
380
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:09:39 UTC from IEEE Xplore.  Restrictions apply. 
[8] D. S. Chester Rebeiro and A. Devi, “Bitslice Implementation
Springer
of AES,” in Lecture Notes in Computer Science.
Berlin, 2006, pp. 203–212.
[9] B. Yee, D. Sehr, G. Dardyk, B. Chen, R. Muth, T. Ormandy,
S. Okasaka, N. Narula, and N. Fullagar, “Native client: a sand-
box for portable, untrusted, x86 native code,” in Proceedings
of IEEE Security and Privacy, 2009.
[10] NIST, “Special publication 800-38b, recommendation for
block cipher modes of operation: The cmac mode for au-
thentication,” 2005.
[11] T. Korvetz and P. Rogaway, “The ocb authenticated-
encryption algorithm,” Internet Draft draft-krovetz-ocb-00.txt,
2005.
[12] NIST, “Special publication 800-38c, recommendation for
block cipher modes of operation: The ccm mode for authen-
tication and conﬁdentiality,” 2004.
[13] J.
Daemen
and
Cipher,”
Block
http://csrc.nist.gov/archive/aes/rijndael/Rijndael-
ammended.pdf.
V.
AES
Rijmen,
Proposal, March
“The
Rijndael
1999,
[14] “OpenSSL: The Open Source
http://www.openssl.org.
toolkit
for SSL/TLS,”
[15] M. Matsui and J. Nakajima, “On the power of bitslice
implementation on intel core2 processor,” in Cryptographic
Hardware and Embedded Systems, 2007.
[16] E. Kasper and P. Schwabe, “Faster and timing-attack resistant
aes-gcm,” Cryptology ePrint Archive: Report 2009/129, 2009.
[17] R. Halprin and M. Naor, “Games for extracting randomness,”
in Proceedings of SOUPS ’09, 2009.
[18] N. Ferguson and B. Schneier, Practical Cryptography. Wiley
Publishing, Inc., 2003.
[19] D. Edwards, “A javascript compressor,” 2007, http://dean.
edwards.name/packer.
[20] D. Bernstein, “Salsa20 speciﬁcation,” eSTREAM Project
http://www.ecrypt.eu.org/stream/
algorithm description,
salsa20pf.html.
[21] Emily Stark, Mike Hamburg, and Dan Boneh, “jsCrypto,”
2009, http://crypto.stanford.edu/sjcl.
381
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:09:39 UTC from IEEE Xplore.  Restrictions apply.