Ourexamplebeginsbystoringthevaluesreturnedfrom
Exchange,checkingwhethertherewasanerror,andifso,calling
panic()tostoptheprogram❶.Thepanic()functionletsyou
quicklyseethestacktraceandidentifywheretheerror
occurred.Next,validatethatthelengthoftheAnswersliceisat
least1❷,andifitisn’t,indicatethattherearenorecordsand
immediatelyreturn—afterall,therewillbelegitimate
instanceswhenthedomainnamecannotberesolved.
ThetypeRRisaninterfacewithonlytwodefinedmethods,
andneitherallowsaccesstotheIPaddressstoredinthe
answer.ToaccessthoseIPaddresses,you’llneedtoperforma
typeassertiontocreateaninstanceofthedataasyourdesired
type.
First,loopoveralltheanswers.Next,performthetype
assertionontheanswertoensurethatyou’redealingwitha
*dns.Atype❸.Whenperformingthisaction,youcanreceive
twovalues:thedataastheassertedtypeandaboolrepresenting
whethertheassertionwassuccessful❹.Afterchecking
whethertheassertionwassuccessful,printtheIPaddress
storedina.A❺.Althoughthetypeisnet.IP,itdoesimplementa
String()method,soyoucaneasilyprintit.
Spendtimewiththiscode,modifyingtheDNSqueryand
exchangetosearchforadditionalrecords.Thetypeassertion
maybeunfamiliar,butit’sasimilarconcepttotypecastingin
otherlanguages.
EnumeratingSubdomains
NowthatyouknowhowtouseGoasaDNSclient,youcan
createusefultools.Inthissection,you’llcreateasubdomain-
guessingutility.Guessingatarget’ssubdomainsandother
DNSrecordsisafoundationalstepinreconnaissance,because
themoresubdomainsyouknow,themoreyoucanattemptto
attack.You’llsupplyourutilityacandidatewordlist(a
dictionaryfile)touseforguessingsubdomains.
WithDNS,youcansendrequestsasfastasyouroperating
systemcanhandletheprocessingofpacketdata.Whilethe
languageandruntimearen’tgoingtobecomeabottleneck,the
destinationserverwill.Controllingtheconcurrencyofyour
programwillbeimportanthere,justasithasbeeninprevious
chapters.
First,createanewdirectoryinyourGOPATHcalled
subdomain_guesser,andcreateanewfilemain.go.Next,
whenyoufirststartwritinganewtool,youmustdecidewhich
argumentstheprogramwilltake.Thissubdomain-guessing
programwilltakeseveralarguments,includingthetarget
domain,thefilenamecontainingsubdomainstoguess,the
destinationDNSservertouse,andthenumberofworkersto
launch.Goprovidesausefulpackageforparsingcommand
lineoptionscalledflagthatyou’llusetohandleyourcommand
linearguments.Althoughwedon’tusetheflagpackageacross
allofourcodeexamples,we’veoptedtouseitinthiscaseto
demonstratemorerobust,elegantargumentparsing.Listing5-
3showsourargument-parsingcode.
packagemain
import(
"flag"
)
funcmain(){
var(
flDomain=flag.String("domain","","Thedomaintoperformguessing
against.")❶
flWordlist=flag.String("wordlist","","Thewordlisttouseforguessing.")
flWorkerCount=flag.Int("c",100,"Theamountofworkerstouse.")❷
flServerAddr=flag.String("server","8.8.8.8:53","TheDNSservertouse.")
)
flag.Parse()❸
}
Listing5-3:Buildingasubdomainguesser(/ch-5/subdomain_guesser/main.go)
First,thecodelinedeclaringtheflDomainvariable❶takesa
Stringargumentanddeclaresanemptystringdefaultvaluefor
whatwillbeparsedasthedomainoption.Thenextpertinentline
ofcodeistheflWorkerCountvariabledeclaration❷.Youneedto
provideanIntegervalueastheccommandlineoption.Inthis
case,setthisto100defaultworkers.Butthisvalueisprobably
tooconservative,sofeelfreetoincreasethenumberwhen
testing.Finally,acalltoflag.Parse()❸populatesyourvariables
byusingtheprovidedinputfromtheuser.
NOTE
YoumayhavenoticedthattheexampleisgoingagainstUnixlawinthatit
hasdefinedoptionalargumentsthataren’toptional.Pleasefeelfreetouse
os.Argshere.Wejustfinditeasierandfastertolettheflagpackagedoallthe
work.
Ifyoutrytobuildthisprogram,youshouldreceiveanerror
aboutunusedvariables.Addthefollowingcodeimmediately
afteryourcalltoflag.Parse().Thisadditionprintsthevariablesto
stdoutalongwithcode,ensuringthattheuserprovided-domain
and-wordlist:
if*flDomain==""||*flWordlist==""{
fmt.Println("-domainand-wordlistarerequired")
os.Exit(1)
}
fmt.Println(*flWorkerCount,*flServerAddr)
Toallowyourtooltoreportwhichnameswereresolvable
alongwiththeirrespectiveIPaddresses,you’llcreateastruct
typetostorethisinformation.Defineitabovethemain()
function:
typeresultstruct{
typeresultstruct{
IPAddressstring
Hostnamestring
}
You’llquerytwomainrecordtypes—AandCNAME—for
thistool.You’llperformeachqueryinaseparatefunction.It’s
agoodideatokeepyourfunctionsassmallaspossibleandto
haveeachperformonethingwell.Thisstyleofdevelopment
allowsyoutowritesmallertestsinthefuture.
QueryingAandCNAMERecords
You’llcreatetwofunctionstoperformqueries:oneforA
recordsandtheotherforCNAMErecords.Bothfunctions
acceptaFQDNasthefirstargumentandtheDNSserver
addressasthesecond.Eachshouldreturnasliceofstringsand
anerror.Addthesefunctionstothecodeyoubegandefining
inListing5-3.Thesefunctionsshouldbedefinedoutside
main().
funclookupA(fqdn,serverAddrstring)([]string,error){
varmdns.Msg
varips[]string
m.SetQuestion(dns.Fqdn(fqdn),dns.TypeA)
in,err:=dns.Exchange(&m,serverAddr)
iferr!=nil{
returnips,err
}
iflen(in.Answer)0{
❺cfqdn=cnames[0]
❻continue//WehavetoprocessthenextCNAME.
}
❼ips,err:=lookupA(cfqdn,serverAddr)
iferr!=nil{
break//TherearenoArecordsforthishostname.
}
❽for_,ip:=rangeips{
results=append(results,result{IPAddress:ip,Hostname:fqdn})
}
❾break//Wehaveprocessedalltheresults.
}
returnresults
}
First,defineaslicetostoreresults❶.Next,createacopy
oftheFQDNpassedinasthefirstargument❷,notonlyso
youdon’tlosetheoriginalFQDNthatwasguessed,butalso
soyoucanuseitonthefirstqueryattempt.Afterstartingan
infiniteloop,trytoresolvetheCNAMEsfortheFQDN❸.If
noerrorsoccurandatleastoneCNAMEisreturned❹,set
cfqdntotheCNAMEreturned❺,usingcontinuetoreturntothe
beginningoftheloop❻.Thisprocessallowsyoutofollow
thetrailofCNAMESuntilafailureoccurs.Ifthere’safailure,
whichindicatesthatyou’vereachedtheendofthechain,you
canthenlookforArecords❼;butifthere’sanerror,which
indicatessomethingwentwrongwiththerecordlookup,then
youleavetheloopearly.IftherearevalidArecords,append
eachoftheIPaddressesreturnedtoyourresultsslice❽and
breakoutoftheloop❾.Finally,returntheresultstothecaller.
Ourlogicassociatedwiththenameresolutionseemssound.
However,youhaven’taccountedforperformance.Let’smake
ourexamplegoroutine-friendlysoyoucanaddconcurrency.
PassingtoaWorkerFunction
You’llcreateapoolofgoroutinesthatpassworktoaworker
function,whichperformsaunitofwork.You’lldothisby
usingchannelstocoordinateworkdistributionandthe
gatheringofresults.Recallthatyoudidsomethingsimilarin
Chapter2,whenyoubuiltaconcurrentportscanner.
ContinuetoexpandthecodefromListing5-3.First,create
theworker()functionandplaceitoutsidemain().Thisfunction
takesthreechannelarguments:achannelfortheworkerto
signalwhetherithasclosed,achannelofdomainsonwhichto
receivework,andachannelonwhichtosendresults.The
functionwillneedafinalstringargumenttospecifytheDNS
servertouse.Thefollowingcodeshowsanexampleofour
worker()function:
typeemptystruct{}❶
funcworker(trackerchanempty,fqdnschanstring,gatherchan[]result,
serverAddrstring){
forfqdn:=rangefqdns{❷
results:=lookup(fqdn,serverAddr)
iflen(results)>0{
gather<-results❸
}
}
vareempty
tracker<-e❹
}
Beforeintroducingtheworker()function,firstdefinethetype
emptytotrackwhentheworkerfinishes❶.Thisisastructwith
nofields;youuseanemptystructbecauseit’s0bytesinsize
andwillhavelittleimpactoroverheadwhenused.Then,inthe
worker()function,loopoverthedomainschannel❷,whichis
usedtopassinFQDNs.Aftergettingresultsfromyourlookup()
functionandcheckingtoensurethereisatleastoneresult,
sendtheresultsonthegatherchannel❸,whichaccumulatesthe
resultsbackinmain().Aftertheworkloopexitsbecausethe
channelhasbeenclosed,anemptystructissentonthetracker
channel❹tosignalthecallerthatallworkhasbeen
completed.Sendingtheemptystructonthetrackerchannelis
animportantlaststep.Ifyoudon’tdothis,you’llhavearace
condition,becausethecallermayexitbeforethegatherchannel
receivesresults.
Sincealloftheprerequisitestructureissetupatthispoint,
let’srefocusourattentionbacktomain()tocompletethe
programwebeganinListing5-3.Definesomevariablesthat
willholdtheresultsandthechannelsthatwillbepassedto
worker().Thenappendthefollowingcodeintomain():
varresults[]result
varresults[]result
fqdns:=make(chanstring,*flWorkerCount)
gather:=make(chan[]result)
tracker:=make(chanempty)
Createthefqdnschannelasabufferedchannelbyusingthe
numberofworkersprovidedbytheuser.Thisallowsthe
workerstostartslightlyfaster,asthechannelcanholdmore
thanasinglemessagebeforeblockingthesender.
CreatingaScannerwithbufio
Next,openthefileprovidedbytheusertoconsumeasaword
list.Withthefileopen,createanewscannerbyusingthebufio
package.Thescannerallowsyoutoreadthefileonelineata
time.Appendthefollowingcodeintomain():
fh,err:=os.Open(*flWordlist)
iferr!=nil{
panic(err)
}
deferfh.Close()
scanner:=bufio.NewScanner(fh)
Thebuilt-infunctionpanic()isusedhereiftheerrorreturned
isnotnil.Whenyou’rewritingapackageorprogramthat
otherswilluse,youshouldconsiderpresentingthis
informationinacleanerformat.
You’llusethenewscannertograbalineoftextfromthe
suppliedwordlistandcreateaFQDNbycombiningthetext
withthedomaintheuserprovides.You’llsendtheresulton
thefqdnschannel.Butyoumuststarttheworkersfirst.The
orderofthisisimportant.Ifyouweretosendyourworkdown
thefqdnschannelwithoutstartingtheworkers,thebuffered
channelwouldeventuallybecomefull,andyourproducers
wouldblock.You’lladdthefollowingcodetoyourmain()
function.Itspurposeistostarttheworkergoroutines,read
yourinputfile,andsendworkonyourfqdnschannel.
❶fori:=0;i<*flWorkerCount;i++{
goworker(tracker,fqdns,gather,*flServerAddr)
}
❷forscanner.Scan(){
fqdns<-fmt.Sprintf("%s.%s",scanner.Text()❸,*flDomain)
}
Creatingtheworkers❶byusingthispatternshouldlook
similartowhatyoudidwhenbuildingyourconcurrentport
scanner:youusedaforloopuntilyoureachedthenumber
providedbytheuser.Tograbeachlineinthefile,scanner.Scan()
isusedinaloop❷.Thisloopendswhentherearenomore
linestoreadinthefile.Togetastringrepresentationofthe
textfromthescannedline,usescanner.Text()❸.
Theworkhasbeenlaunched!Takeasecondtobaskin
greatness.Beforereadingthenextcode,thinkaboutwhereyou
areintheprogramandwhatyou’vealreadydoneinthisbook.
Trytocompletethisprogramandthencontinuetothenext
section,wherewe’llwalkyouthroughtherest.
GatheringandDisplayingtheResults
Tofinishup,firststartananonymousgoroutinethatwill
gathertheresultsfromtheworkers.Appendthefollowing
codeintomain():
gofunc(){
forr:=rangegather{
❶results=append(results,r...❷)
}
vareempty
❸tracker<-e
}()
Byloopingoverthegatherchannel,youappendthereceived
resultsontotheresultsslice❶.Sinceyou’reappendingaslice
toanotherslice,youmustusethe...syntax❷.Afteryouclose
thegatherchannelandtheloopends,sendanemptystructtothe
trackerchannelasyoudidearlier❸.Thisisdonetopreventa
raceconditionincaseappend()doesn’tfinishbythetimeyou
eventuallypresenttheresultstotheuser.
Allthat’sleftisclosingthechannelsandpresentingthe
results.Includethefollowingcodeatthebottomofmain()in
ordertoclosethechannelsandpresenttheresultstotheuser:
❶close(fqdns)
❷fori:=0;i<*flWorkerCount;i++{
<-tracker
}
❸close(gather)
❹<-tracker
Thefirstchannelthatcanbeclosedisfqdns❶because
you’vealreadysentalltheworkonthischannel.Next,you
needtoreceiveonthetrackerchannelonetimeforeachofthe
workers❷,allowingtheworkerstosignalthattheyexited
completely.Withalloftheworkersaccountedfor,youcan
closethegatherchannel❸becausetherearenomoreresultsto
receive.Finally,receiveonemoretimeonthetrackerchannelto
allowthegatheringgoroutinetofinishcompletely❹.
Theresultsaren’tyetpresentedtotheuser.Let’sfixthat.If
youwantedto,youcouldeasilyloopovertheresultssliceand
printtheHostnameandIPAddressfieldsbyusingfmt.Printf().We
prefer,instead,touseoneofGo’sseveralgreatbuilt-in
packagesforpresentingdata;tabwriterisoneofourfavorites.It
allowsyoutopresentdatainnice,evencolumnsbrokenupby
tabs.Addthefollowingcodetotheendofmain()tousetabwriter
toprintyourresults:
w:=tabwriter.NewWriter(os.Stdout,0,8,4,'',0)
for_,r:=rangeresults{
fmt.Fprintf(w,"%s\t%s\n",r.Hostname,r.IPAddress)
}
w.Flush()
Listing5-4showstheprograminitsentirety.
Packagemain
import(
"bufio"
"errors"
"flag"
"fmt"
"os"
"text/tabwriter"
"github.com/miekg/dns"
)
funclookupA(fqdn,serverAddrstring)([]string,error){
varmdns.Msg
varips[]string
m.SetQuestion(dns.Fqdn(fqdn),dns.TypeA)
in,err:=dns.Exchange(&m,serverAddr)
iferr!=nil{