Views are part of a view hierarchy, with child Views inside
of parent Views. The developer can change this hierarchy
programmatically.
ACGs. We implement each ACG as a Fragment. A Frag-
ment is an isolated part of an Activity (for example, a single
button and an action for that button). A Fragment con-
tains a View that it inserts at runtime. Because of this, each
ACG only needs to implement resource-accessing behavior
and not any secure UI logic. The application cannot access
any of the validation or resource-accessing logic to remove
or modify it.
We expose two ACG interfaces: one for temporary permis-
sions and one for permanent permissions. Temporary ACGs
provide resource access only immediately after user interac-
tion, while permanent ACGs provide resource access from
the time of initial interaction until the user disables them.
In true Android fashion, these are event-driven: The appli-
cation implements a listener. The listener is notiﬁed when
the resource availability state changes. When the resource
is available, the application may use it as desired.
ACG UIs. We implement a ViewWrapper to prevent appli-
cations from modifying the ACG UIs after creation. Each
ACG UI has an associated View. The ViewWrapper contains
this View and does not expose it to the application. It de-
fers all rendering logic and delegates all events to the internal
View. After the internal View handles events, the ViewWrap-
per requests layout. When the internal View changes its
layout, the ViewWrapper notiﬁes Android to draw the View
again.
Using the Library. ACGLib is designed to be easy to use.
An application developer can include an ACG in one of two
ways: He can deﬁne it in a layout and then bind to it from
within an Activity, or he can add it programmatically at
runtime. Next, the developer must implement ACGListener
and override buildACGListeners(), which attaches listeners
to the ACGs. The listeners react to changes in resource
availability. Developers can also pass input to ACGs and
chain ACGs. For example, the ACG for playing audio can
take input from the ACG for recording audio (Figure 4).
4.3 Event Flow: User → UIseen
Both direct and indirect event forgery attacks can be in-
stantiated two ways in Android: by constructing or modi-
fying events, or by calling the methods that events trigger
(such as performClick()). In the ﬁrst case, application in-
terference is application code that runs after setup code be-
fore the event itself reaches the ACG; in the second case,
it is application code that runs after setup code before the
result of the event reaches the ACG.
We stop applications from constructing or modifying events
and from programmatically clicking elements statically. We
build our analysis using Soot.3 Our analysis does not al-
low application code to call click methods on any subclass
of View, and it does not let applications call construction,
modiﬁcation, or copying methods on any event subclass. It
operates on the bytecode rather than on the source code,
since there is enough information present in the bytecode.
We do not stop applications from dispatching events. Event
ﬂow through the view hierarchy in Android is complex, so
banning all methods which propagate events through the
hierarchy is dangerous and does not scale. This does not
impact the soundness of AUDACIOUS: Since applications
cannot modify, create, or copy events, the only events that
applications can dispatch are authentic. This means that
at runtime, both the location and the time of the event are
authentic, so we can defer reasoning about these to our UI
context check (Section 4.4).
Our implementation is conservative: It guarantees that
applications do not interfere with the ﬂow of events from
the user to the UI by preventing applications from interfering
with events in any way. Some applications modify events for
the sake of upscaling or UI customization. We acknowledge
3https://sable.github.io/soot/
this as a limitation of our implementation. Our evaluation of
event usage in practice (Section 6.4) shows that this behavior
occurs rarely enough that it is human-veriﬁable.
4.4 UI Context: UIseen (cid:39) UIACG
Android provides a method that a security-sensitive View
can override to implement ﬁne-grained security checks for
events. We implement our UI context check in this method.
Internal UI: UIapp (cid:39) UIACG. An application may mis-
lead the user by modifying a View or by covering it with a
new View. To prevent this, each ACG contains a Bitmap
validator. The validator takes a View and decides whether
the Bitmap rendering of that View is acceptable. It is ﬂexi-
ble enough to support diﬀerent notions of acceptable trans-
formations as well as application-supplied proofs. Diﬀerent
ACGs can use diﬀerent implementations of the validator.
We implement two example validators. The non-stateful
validator checks for equality between a Bitmap rendering of
the ACG View in isolation and a Bitmap rendering of the
supplied View. This is the default validator, as it is the
most conservative. The stateful validator takes both a View
and a state, and expects diﬀerent UIs for diﬀerent states.
We use this validator for the LocationACG, which expects
one UI for its “on” state and a diﬀerent UI for its “oﬀ” state.
External UI: UIapp = UIapp + UIother. Tapjacking in
Android occurs through Toasts. A Toast is a system-level
pop-up notiﬁcation. A voice recording application, for ex-
ample, may use a Toast to alert the user that it has saved
the audio to the device. Android delegates events which pass
through a Toast to the UI element underneath it. Malicious
applications abuse this feature to trick users into clicking
on elements [18, 20]. This is a concern not only within an
application, but also between applications, since a Toast is
outside of the application’s view hierarchy.
To prevent these attacks, Android provides the native ﬂag
FLAG_WINDOW_IS_OBSCURED. This is set on an event whenever
the View on which the event occurs is either partially or
wholly obscured by a window outside of the view hierarchy,
regardless of whether the event passes through the obscured
part of the window [3]. We reject an event whenever this ﬂag
is set and invalidate the UI for a suitable period of time.
Due to a bug in Android, the ﬂag does not handle partially
obscured views correctly. A malicious application can, for
example, expose a Toast which obfuscates the intent of the
ACG, but leave room around the edges. Clicks which pass
through those edges ought to be invalidated, but they are
not. We have reported this to Android. It is scheduled to
be investigated for a future release.
UI Consistency: UIapp = UIseen. To ensure that the
event occurs in the correct location, we verify that it occurs
within the boundaries of the ACG View element. To ensure
that the event occurs at the correct time, we verify that no
amount of time longer than some buﬀer has passed (that is,
the current time is within the boundaries of the time of the
event and the time of the event plus the buﬀer).
We implement random checks to handle bait-and-switch
attacks. We expose two intervals at the library level: the
maximum frequency of random checks and the invalidation
interval for failed checks.
Individual ACGs can conﬁgure
these intervals independently. We set the default time buﬀer
for events to the rate at which random checks occur. This
public final class LocationACG {
@Source(value = "ACG(location)")
public Location getResource();
}
public final class PlayAudioACG {
public Void getResource();
@Sink(value = "ACG(play_audio)")
public void passInput(File file);
}
Figure 5: Stubs for two ACGs. The source of any
Location from the LocationACG is ACG(location), and
the sink of any File passed into the PlayAudioACG is
ACG(play_audio).
ACG("audio_recording") -> FILESYSTEM("/ACG")
FILESYSTEM("/ACG") -> ACG("play_audio")
ACG("audio_recording") -> ACG("play_audio")
Figure 6: Flow policy ﬁle for a voice recorder ap-
plication that uses ACGs. The application can save
and play its recordings.
way, a random check is guaranteed to happen in the time an
event is valid.
We are once again limited by our lack of OS support in
that we are unable to randomly check the UI outside of the
view hierarchy. In order to check FLAG_WINDOW_IS_OBSCURED
without an authentic event, we must construct an event in
the location of the ACG. However, if we construct an event
programmatically, the ﬂag is never set.
4.5 Resource Flow: UIACG → ACG
∗→ . . .
We use SPARTA [5] to verify ﬂow from the ACG UI to the
resource itself and onward. SPARTA is an information ﬂow
tool which uses static type-checking to infer illegal ﬂows.
SPARTA operates on the source code. Application develop-
ers annotate code with sources and sinks. The annotation
burden for developers is typically low [5]. SPARTA includes
trusted annotations in the form of stub ﬁles to minimize
annotation burden; this includes most Android core code.
SPARTA compares the ﬂows it ﬁnds with allowable ﬂows
deﬁned in a ﬂow policy ﬁle (Figure 6). A human veriﬁer
inspects the source code and the output of SPARTA in the
context of this policy.
SPARTA alone ensures that the application uses resources
correctly. However, it does not ensure that the application
accesses the correct resources at the correct times. For ex-
ample, SPARTA will catch an application that sends videos
over the internet if the application should never send videos
over the internet. However, it will not catch an application
that ought to send videos over the internet with the user’s
consent, yet actually sends videos over the internet without
the user’s consent. AUDACIOUS provides more powerful
guarantees than SPARTA alone.
We extend SPARTA with the notion of an ACG. We
implement an ACG type, which we parameterize by the
name of the ACG. This way, SPARTA can distinguish ACGs
from other sources and sinks, and it can distinguish diﬀer-
ent ACGs from each other. We add stub ﬁles that inform
SPARTA when resources ﬂow to or from an ACG. Adding a
new ACG only involves a few lines of stubbing in SPARTA
(Figure 5) and decreases annotation burden for the applica-
tion developer.
The underlying analysis for SPARTA is sound and cor-
rectly handles implicit ﬂow [5]. SPARTA also handles reﬂec-
tion and Intents (two major challenges for static analysis of
Android applications) soundly [2]. Intents are objects that
Android applications use to communicate between parts of
an application or between applications. Reﬂection and In-
tents complicate control ﬂow. Applications that use these
features must annotate their applications accordingly [2].
In AUDACIOUS, applications may use alternative per-
mission models for any functionality for which user-driven
access control is not ideal by including non-ACG ﬂows in
their ﬂow policies. These applications must have their ﬂow
policies approved. Applications that use ACGs without ad-
vanced functionality only require manual approval in the
case of false positives.
5. DISCUSSION: OS SUPPORT
The previous sections show that supporting user-driven
access control without explicit OS support is possible, mov-
ing beyond prior work on ACGs (e.g., [23]), and enabling
ACGs to be used and enforced without requiring major
changes to already-deployed OSes. We take a step back
and reﬂect on the beneﬁts of ACGs that don’t require OS
support, as well as the lessons we learned about the possible
role of OS support. We identify areas where limited (not
ACG-speciﬁc) OS support is necessary or beneﬁcial, and we
identify fundamental limitations of not having OS support.
5.1 Beneﬁts of a User Space Approach
An approach that provides and ensures the security of
ACGs without OS support has clear beneﬁts.
Deployability. Changes to the OS are costly and may not
be backward-compatible. As a result, despite the poten-
tial for ACGs to solve many issues with permission models
in modern OSes, they are unlikely to be deployed in the
near future, if ever. Furthermore, even if ACGs were incor-
porated into an OS, old devices may never update to the
latest OS, and so these changes may never reach customers
(a situation notorious for the Android ecosystem [1]).
In contrast, a library paired with program analyses can be
deployed within any application and veriﬁed by any entity
with the ability to run the analysis tools. While we assume
that the app store takes on the role of analyst, this role
can also be ﬁlled by trusted third-party organizations (for
example, to produce a list of “ACG-certiﬁed” apps).
Flexibility of Permission Models. The application per-
mission model (manifest, prompts, user-driven access con-
trol, or some combination) is ﬁxed within an OS. However,
permission models are not one-size-ﬁts-all: Diﬀerent models
may be better suited for diﬀerent applications and diﬀerent
resources [7]. A key beneﬁt of a user space approach like
ours is that the permission model can be changed or com-
bined with other permission models. For example, in our
implementation, we extend Android with a user-driven ac-
cess control model, but still allow applications to use the
manifest model (subject to information ﬂow guarantees).
5.2 Opportunities for Limited OS Support
Through our design and implementation experience, we
identify simple, broadly useful features that OSes can (and
may already) provide to enable user-driven access control to
be implemented easily and securely in user space. Note that
the features we describe here are generic, not ACG-speciﬁc.
We believe that these features are also useful beyond ACGs
(for example, to prevent a broader class of UI-level attacks
like clickjacking).
Event Analysis.
If the OS prevented events from being
created or modiﬁed, we would not need to run an analysis
to detect illegal event ﬂow. Alternatively, if the OS ﬂagged
programmatic events as synthetic, we would be able to verify
event ﬂow with minimal eﬀort and performance overhead
at runtime. Unfortunately, Android does not distinguish
between forged events and real events that come from user
input, which forces us to make this distinction.4
Tapjacking. Detecting tapjacking attacks which occur out-
side of the application’s UI — for example, by another ap-
plication overlaying content on top of the target applica-
tion — requires some OS support. The reason for this is that
OSes typically do not allow applications to take system-level
screenshots, which is necessary for our bitmap inspection ap-
proach. (Allowing applications to take system-level screen-
shots poses a security risk, since it allows applications to
read content from other applications.)
Instead, our implementation relies on Android’s FLAG_
WINDOW_IS_OBSCURED ﬂag (modulo its incorrect handling of
partially obscured UIs, discussed in Section 4.4). Without
this limited support, it would have been diﬃcult or impos-
sible to detect application-external UI attacks.
Bait-and-Switch. With full OS support, we could deter
bait-and-switch attacks without relying on random checks.
We could instead depend on a secure layer at the OS level
which alerts us when the UI changes, but is not susceptible
to modiﬁcation or interception by applications.
5.3 Limitations of a User Space Approach
Finally, we identify several fundamental limitations of sup-
porting user-driven access control without OS support.
Increased Trusted Code Base. We must now trust not
only the OS and the device, but also our library, the analysis
tools, and the veriﬁcation model those tools depend on.
Software Updates. If the ACG library is updated, each
application developer must individually update their ap-
plication to include the latest version of the library. By
contrast, OS updates (though they may be slow to propa-
gate [1]) are applied centrally.
Inconsistent Permission Models. In some cases, ﬂexi-
ble permission models may lead to inconsistent permission
models. For example, as of Android 6.0, sensitive permis-
sion requests generate permission prompts on ﬁrst use. If
an application accesses that permission through an ACG,
this prompt will seem redundant to users (and will be re-
dundant, from a security perspective). Without modifying
the OS, however, these prompts cannot be removed even in
cases where permission is already granted through an ACG.
4Android events do contain a ﬂag called FLAG_TAINTED for