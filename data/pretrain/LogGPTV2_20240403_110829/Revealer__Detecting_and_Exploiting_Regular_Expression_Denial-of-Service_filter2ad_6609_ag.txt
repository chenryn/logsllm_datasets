International
study of practical regular expressions.
Journal of Foundations of Computer Science, 14(06):1007–
1018, 2003. doi: 10.1142/S012905410300214X.
[10] J. C. Davis.
Rethinking regex engines to address
redos. In Proceedings of the 27th ACM Joint European
Software Engineering Conference and Symposium on the
Foundations of Software Engineering (ESEC/FSE), Tallinn,
Estonia, Aug. 2019.
[11] J. C. Davis, C. A. Coghlan, F. Servant, and D. Lee. The
impact of regular expression denial of service (redos) in
practice: an empirical study at the ecosystem scale. In
Proceedings of the 26th ACM Joint European Software
Engineering Conference and Symposium on the Founda-
tions of Software Engineering (ESEC/FSE), Lake Buena
Vista, FL, Nov. 2018.
[12] J. C. Davis, E. R. Williamson, and D. Lee. A sense of
time for javascript and node.js: First-class timeouts as a
cure for event handler poisoning. In Proceedings of the
27th USENIX Security Symposium (Security), Baltimore,
MD, Aug. 2018.
[13] J. C. Davis, L. G. M. IV, C. A. Coghlan, F. Servant,
and D. Lee. Why aren’t regular expressions a lingua
franca? an empirical study on the re-use and portability
of regular expressions. In Proceedings of the 27th ACM
Joint European Software Engineering Conference and
Symposium on the Foundations of Software Engineering
(ESEC/FSE), Tallinn, Estonia, Aug. 2019.
[14] H. M. Demoulin, T. Vaidya, I. Pedisich, B. DiMaiolo,
J. Qian, C. Shah, Y. Zhang, A. Chen, A. Haeberlen, B. T.
Loo, L. T. X. Phan, M. Sherr, C. Shields, and W. Zhou.
DeDoS:defusing dos with dispersion oriented software.
In Proceedings of the 34th Annual Computer Security
Applications Conference (ACSAC), San Juan, PR, Dec.
2018.
[15] M. Docs. Backtracking in .net regular expressions.
"https://docs.microsoft.com/en-us/dotnet/standard/base-
types/backtracking-in-regular-expressions", 2020.
[16] M. J. Dominus. Perl regular expression matching is np-
hard, 2020. URL https://perl.plover.com/NPC/.
[17] J. Friedl. Mastering Regular Expressions: Understand
Your Data and Be More Productive. O’Reilly Media,
2006. ISBN 9781449332532. URL https://books.google.
com.hk/books?id=sshKXlr32-AC.
[18] J. Kirrage, A. Rathnayake, and H. Thielecke. Static
analysis for regular expression denial-of-service attacks.
In J. Lopez, X. Huang, and R. Sandhu, editors, Network
and System Security, pages 135–148, Berlin, Heidelberg,
2013. Springer Berlin Heidelberg.
[19] E. Larson and A. Kirk. Generating evil test strings for
In 2016 IEEE International Con-
regular expressions.
ference on Software Testing, Verification and Validation
(ICST). IEEE, apr 2016. doi: 10.1109/icst.2016.29. URL
https://doi.org/10.1109%2Ficst.2016.29.
[20] N. Li, T. Xie, N. Tillmann, J. de Halleux, and W. Schulte.
Reggae: Automated test generation for programs using
In Proceedings of the
complex regular expressions.
24th IEEE/ACM International Conference on Automated
Software Engineering (ASE), Auckland, New Zealand,
Nov. 2009.
[21] C. Lin, C. Liu, and S. Chang. Accelerating regular
expression matching using hierarchical parallel machines
In 2011 IEEE Global Telecommunications
on gpu.
Conference - GLOBECOM 2011, pages 1–5, 2011.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1481
[22] B. Loring, D. Mitchell, and J. Kinder. Sound regular
expression semantics for dynamic symbolic execution of
javascript. In Proceedings of the 40th ACM SIGPLAN
Conference on Programming Language Design and Im-
plementation (PLDI), New York, NY, June 2019.
[23] L. G. Michael, J. Donohue, J. C. Davis, D. Lee, and
F. Servant. Regexes are hard: Decision-making, difficulties,
and risks in programming regular expressions. In Pro-
ceedings of the 34th IEEE/ACM International Conference
on Automated Software Engineering (ASE), San Diego,
CA, Nov. 2019.
[24] R. Mitkov. The Oxford Handbook of Computational
Linguistics. Oxford University Press, 2003.
ISBN
9780199276349. URL https://books.google.com/books?
id=yl6AnaKtVAkC&pg=PA754.
[25] Y. Noller, R. Kersten, and C. S. P˘as˘areanu. Badger:
complexity analysis with fuzzing and symbolic execution.
In Proceedings of the 27th International Symposium
on Software Testing and Analysis (ISSTA), Amsterdam,
Netherlands, July 2018.
[26] A. Ojamaa and K. Düüna.
Security assessment of
node.js platform. In Information Systems Security: 8th
International Conference, ICISS 2012, Guwahati, India,
December 15-19, 2012, Proceedings, page 40. Springer
Science & Business Media, 2012. URL https://books.
google.com.hk/books?id=xOrfxw3OcTUC.
[27] OWASP.
Regex
"http://www.owasp.org/index.php/Regular_expres-
sion_Denial_of_Service_-_ReDoS", 2010.
denial
of
service.
[28] T. Petsios, J. Zhao, A. D. Keromytis, and S. Jana.
Slowfuzz: Automated domain-independent detection of
algorithmic complexity vulnerabilities. In Proceedings of
the 24th ACM Conference on Computer and Communica-
tions Security (CCS), Dallas, TX, Oct.–Nov. 2017.
[29] A. Rathnayake and H. Thielecke. Static analysis for
regular expression exponential runtime via substructural
logics (extended). arXiv preprint arXiv:1405.7058, 2014.
[30] Y. Shen, Y. Jiang, C. Xu, P. Yu, X. Ma, and J. Lu. ReScue:
crafting regular expression DoS attacks. In Proceedings
of the 33rd IEEE/ACM International Conference on Auto-
mated Software Engineering (ASE), Montpellier, France,
Sept. 2018.
[31] R. Smith, C. Estan, and S. Jha. Backtracking algorithmic
complexity attacks against a nids. In Proceedings of the
22nd Annual Computer Security Applications Conference
(ACSAC), 2006.
[32] C.-A. Staicu and M. Pradel. Freezing the web: A study
of redos vulnerabilities in javascript-based web servers.
In Proceedings of the 27th USENIX Security Symposium
(Security), Baltimore, MD, Aug. 2018.
[33] S. Sugiyama and Y. Minamide. Checking time linearity of
regular expression matching based on backtracking. IPSJ
Online Transactions, 7(0):82–92, 2014. doi: 10.2197/
ipsjtrans.7.82. URL https://doi.org/10.2197%2Fipsjtrans.
7.82.
[34] B. van der Merwe, N. Weideman, and M. Berglund.
Turning evil regexes harmless. In Proceedings of the South
African Institute of Computer Scientists and Information
Technologists on - SAICSIT '17. ACM Press, 2017. doi:
10.1145/3129416.3129440. URL https://doi.org/10.1145%
2F3129416.3129440.
[35] M. Veanes, P. de Halleux, and N. Tillmann. Rex:
In 2010 Third
Symbolic regular expression explorer.
International Conference on Software Testing, Verification
and Validation. IEEE, 2010. doi: 10.1109/icst.2010.15.
URL https://doi.org/10.1109%2Ficst.2010.15.
[36] P. Wang and K. T. Stolee. How well are regular expres-
sions tested in the wild? In Proceedings of the 26th ACM
Joint European Software Engineering Conference and
Symposium on the Foundations of Software Engineering
(ESEC/FSE), Lake Buena Vista, FL, Nov. 2018.
[37] N. Weideman, B. van der Merwe, M. Berglund, and
B. Watson. Analyzing matching time behavior of back-
tracking regular expression matchers by using ambiguity
of NFA. In Implementation and Application of Automata,
pages 322–334. Springer International Publishing, 2016.
doi: 10.1007/978-3-319-40946-7_27. URL https://doi.org/
10.1007%2F978-3-319-40946-7_27.
[38] V. Wüstholz, O. Olivo, M. J. Heule, and I. Dillig.
Static detection of dos vulnerabilities in programs that
In Proceedings of the 23rd
use regular expressions.
International Conference on Tools and Algorithms for the
Construction and Analysis of Systems (TACAS), Uppsala,
Sweden, Apr. 2017.
[39] S. Yu. Regular Languages. Springer Berlin Heidelberg,
1997. doi: 10.1007/978-3-642-59136-5_2. URL https:
//doi.org/10.1007%2F978-3-642-59136-5_2.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1482
Fig. 10: NFA-like structure transformed from the “Loop in Loop”
vulnerable e-NFA structure. r0 to r4 are the same subexpressions as
those in the vulnerable e-NFA structure.
Fig. 11: NFA-like structure transformed from the “Branch in Loop”
vulnerable structure.
Fig. 8: The structure of hyper-vulnerable NFA pattern.
Fig. 9: The structure of vulnerable NFA pattern.
APPENDIX
A. Additional Proofs for Modeling ReDoS Vulnerability
We provide the proofs for the four theorems we defined in
§IV. We first introduce the existing theorems about vulnerable
NFA patterns (§A1) that inspired our modeling. We then prove
the theorem about the crucial states in an e-NFA that may lead
to super-linear matching behavior (§A2). Finally we provide
proofs for our proposed vulnerable e-NFA patterns (§A3).
1) Vulnerable NFA Patterns: Before we introduce our theory
in vulnerable e-NFA patterns, we review necessary background
of vulnerable NFA patterns and corresponding attack string
patterns in [38].
Definition 5 (NFA). An NFA A is a 5-tuple (Q, Σ, ∆, q0, F )
where Q is a finite set of states, Σ is a finite alphabet of symbols,
and ∆ : Q × Σ → 2Q is the transition function. Here, q0 ∈ Q
is the initial state, and F ⊆ Q is the set of accepting states.
We say that (q, l, q′) is a transition via label l if q′ ∈ ∆(q, l).
The notation π denotes an NFA path, which includes a
sequence of NFA transitions (q1, l1, q2), . . . , (qm−1, lm−1, qm)
that starts at q1 and ends at qm. labels(π) denotes the sequence
of labels (l1, . . . , lm−1) for following the transitions in path π.
Theorem 5 (Hyper-vulnerable NFA pattern). An NFA is hyper-
vulnerable (has exponential complexity) iff there exists a pivot
state q ∈ Q and two distinct paths π1, π2 such that (i) both
π1, π2 start and end at q, (ii) labels(π1) = labels(π2), (iii)
there is a path πp from initial state q0 to q, and (iv) there is a
path πs from q to a state qr /∈ F , as shown in Figure 8.
Theorem 6 (Vulnerable NFA pattern). An NFA is vulnerable
(has super-linear complexity) iff there exists two states q ∈ Q,
q′ ∈ Q, and three paths π1, π2, and π3 (where π1 ̸= π2) such
that (i) π1 starts and ends at q, (ii) π2 starts at q and ends at q′,
(iii) π3 starts and ends at q′, (iv) labels(π1) = labels(π2) =
labels(π3), (v) there is a path πp from initial state q0 to q, and
(vi) there is a path πs from q′ to a state qr /∈ F , as shown in
Figure 9.
The ReDoS attack string pattern against the vulnerable
NFA patterns is proposed as s0.sk.s1, where s0 is the attack
prefix given by labels(πp), s1 is the attack suffix given by
labels(πs), and s is the attack core given by labels(π1). For
example, regex (ab|a|b)* has a hyper-vulnerable NFA pattern,
whose attack core is ‘ab’. The attack core has two distinct
matching paths—(ab){1} for π1, and (a|b){2} for π2 which
is a repetition of the subexpression (a|b). Both labels(π1) and
labels(π2) are equal to the attack core ‘ab’.
2) Crucial States in e-NFA: We provide the proof for
Theorem 1 that the e-NFA match process runs in linear time if
an e-NFA has neither loop states nor branch states.
Proof of Theorem 1: For a state v that is neither a loop
state nor a branch state, it has at most one outgoing inclusion
v ≤ 1, which means it can match a symbol
transition, and cmax
at most once and the e-NFA has to take a connection transition
after the match. Since a state can have at most one outgoing
connection transition as described in §III-A4, the e-NFA can
transit from v to only one state v′ through the only connection
transition t. Let Pv(s) denote the number of possible matching
paths from the start state v0 to v before matching the next
substring s, and s′ denote the remaining unmatched substring
after following the transition t from v to v′. We have Pv′(s′) =
Pv(s). If the e-NFA contains only such states, then all states
would be visited at most once, and the possible matching paths
count keeps the same from the start state to the accepting state,
i.e., Pvf (ϵ) = Pv0(s0) = 1, where s0 is the entire input string.
Since the maximum length for each matching path Lmax is
less than M × N, where M is the number of states in e-NFA,
and N is the length of s0, the overall matching time would be
less than Pvf (ϵ) × Lmax, and is linear with N.
3) The Sufficiency of Vulnerable e-NFA Patterns: In this
section, we prove the sufficiency of vulnerable e-NFA patterns.
We first discuss two vulnerable e-NFA patterns with
exponential complexity: “Loop in Loop” and “Branch in Loop”.
Loop in Loop. The “Loop in Loop” vulnerable structure and
the corresponding NFA-like structure are shown in Figure 2 and
Figure 10, respectively. We can see similar structures between
Figure 8 and Figure 10 by mapping πp to r0, π1 to r1r3, π2
to r1r2r3, and πs to r1r3r4. We propose the following proof
for the “Loop in loop” vulnerable e-NFA structure.
Proof of Theorem 2: Let s denote the common match
string of r1r2r3 and r1r3, and there are k repetitions of s in
the attack string. When the regex engine fails to match r4 after
accepting sk at vi, for each s, it can backtrack to vi by either
r1r2r3 or r1r3. Each backtracking of string s takes constant
time O(1). Let Tv(k) denote the running time of backtracking
from state v on string sk. For each repetition of s, the total
number of backtracking paths doubles, and the total running
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1483
qr0q’q’’qrεr1r2r3r4q0qr0 q’q’’qrεr1r2r3r4q0q’’’r5qπpqrq0π2πsπ1qπpq’q0π3π2π1qrπsFig. 12: NFA-like structure transformed from the “Loop after Loop”
vulnerable structure.
time becomes: Tvi(k) = (O(1)+Tvi(k−1))+(O(1)+Tvi (k−
1)). Iteratively, we have Tvi(k) = O(1) · (2k+1 − 2) = O(2k).
In summary, there are 2k possible backtracking paths, and the
regex engine would end up traversing all possibilities in the
worst case, which is of exponential time with k.
Branch in Loop. The “Branch in Loop” vulnerable structure
and the corresponding NFA-like structure are shown in Figure 3
and Figure 11, respectively. Similarly, paths in Figure 8 can be
mapped to subexpressions in Figure 11 as follows: πp to r0,
π1 to r1r2r4, π2 to r1r3r4, and πs to r1r3r4r5. We propose
the following proof.
Proof of Theorem 3: Let s denote the common match
string of r1r2r4 and r1r3r4, and there are k repetitions of
s in the attack string. Similar to Theorem 2, the number of
backtracking possibilities doubles on each repetition of s, which
leads to exponential time complexity.
We then discuss the vulnerable e-NFA pattern “Loop after
Loop”, which is of polynomial complexity.
Loop after Loop. The “Loop after Loop” vulnerable struc-
ture and the corresponding NFA-like structure are shown in
Figure 4 and Figure 12, respectively. Paths in Figure 9 and
subexpressions in Figure 12 can be mapped as follows: πp to
r0, π1 to r1, π2 to r2, π3 to r3 , and πs to r4. We propose the
following proof.
Proof of Theorem 4: Let s denote the common match
string of r1, r3 (and r2), and there are k repetitions of s in
the attack string. When the regex engine fails to match r4
after accepting sk at vi, for each s, it can backtrack to vi
by either r1r2r3 or r1r3. Each backtracking step of string s
takes constant time O(1). Let Tv(k) denote the running time
of backtracking from state v on string sk. The backtracking
algorithm starts from vi+1 with sk. When the engine backtracks
the first s, it either goes to vi or stays at vi+1, which gives:
Tvi+1(k) = (O(1) + Tvi(k − 1)) + (O(1) + Tvi+1(k − 1)). If
the engine goes to vi, it cannot come back to vi+1, so it can
only perform backtracking on vi afterwards. Thus, we have
Tvi(k − 1) = (k − 1) · O(1) = O(k), and then Tvi+1(k) =
Tvi+1(k−1)+O(k). Iteratively we have Tvi+1 (k) = k·O(k) =
O(k2). In summary, the regex engine would end up running
in polynomial time with k in the worst case.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1484
qr0q’q0r3r2r1qrr4