Table 1. Overall detection results in our
dataset
fall back to manual efforts for conﬁrmation. Fortunately,
these generated execution paths greatly facilitate this pro-
cess. Our experience shows that it took a single co-author
less than three days to classify all 1, 456 vulnerable apps.
We stress that our manual efforts are only needed to clas-
sify the types of private information that might be leaked or
polluted. The selection and conﬁrmation of vulnerable apps
are still mostly an automated process. Moreover, the inter-
mediate results (such as function call graph and CFG) can
be leveraged to greatly reduce the classiﬁcation overhead.
5 Evaluation
To assess the level of threats from these two vulnera-
bilities, we have collected 62, 519 (free) apps from vari-
ous Android markets in February 2012. Among these apps,
35, 047 were downloaded from Google Play and the rest
were fetched from ten other popular third-party ones. From
these apps, as described in Section 3, our system ﬁrst iden-
tiﬁes apps with exported content provider interfaces as can-
didates. In our dataset, our system reports 3, 018 (or 4.8%)
candidate apps (Table 1). The reduction from the initial
62, 519 apps to these 3, 018 candidate apps is helpful to
exclude unrelated ones for processing. Also we ﬁnd that
among 62, 519 apps, 4994 of them have content providers
and only 1976 (39.6%) of them explicitly protect them ei-
ther by not exporting them or by declaring dangerous per-
missions. This fact indicates that if one interface is open by
default, many developers will do so even without realizing
this. After that, for each candidate app, our system analyzes
it to conﬁrm whether it is indeed vulnerable. In total, our
system detects 1, 279 and 871 apps that suffer from passive
content leak and content pollution vulnerabilities, re-
spectively. Among these vulnerable apps, 435 and 398 apps
were downloaded from Google Play. As mentioned earlier,
some of them are popular, with more than 10, 000, 000 in-
stalls from the ofﬁcial Google Play market.
Some apps were not automatically conﬁrmed by our sys-
tem. Upon manual analysis, we discovered this was due to
the following reasons: (1) In some of these apps, the re-
turn value of start functions such as ContentProvider.
query() depends on the internal logic of the app. If cer-
tain internal logic is not satisﬁed, the start function will
simply return an unexpected value, based on which our
system will mark it as not vulnerable. For instance, the
ContentProvider.query() function of MiTalk Messenger
(version: 2.1.365/365)3 will check whether there is a regis-
tered user account. If not, it will directly return null to our
test app. Accordingly, we manually add these apps back to
the list of vulnerable apps. (2) Certain apps may enforce
an access policy in the start functions and deny the re-
quest from our test app. However, due to improper enforce-
ment, the access policy may be bypassed. One concrete
example is the QQ Browser (version: 3.0/35), which checks
the package name of calling app in its ContentProvider.
query() function. If the package name of the calling app
is in a predeﬁned list, it will honor the request and re-
turn a valid Cursor object. Note that this access policy
blocked our test app’s ﬁrst try. However, after analyzing
the app and accordingly changing the package name of our
test app, we can still successfully retrieve data from this
app. (3) Other apps may also check the signatures of call-
ing apps. In this case, they are not vulnerable as the signa-
ture used to sign the app is supposed to be unique and not
leaked to others. (4) Some apps may not be properly devel-
oped and will essentially throw an exception when running.
For example, we ﬁnd cases where the authority attribute
speciﬁed in manifest ﬁle is different from the one used in
URIMatcher. In this case, the Android runtime fails to ﬁnd
the corresponding content provider. (5) Finally, some apps
may use speciﬁc Android classes which cannot be returned
to another process (or app). For example, some apps re-
turn a CursorWrapper to ContentProvider.query() func-
tion. However this object may not be passed to another app
(i.e., our test app) and an UnsupportedOperationException
will be thrown at runtime.
After identifying these vulnerable apps, starting from
February 2012, we spent a considerable amount of time on
reporting them to the corresponding developers. Some of
them ﬁxed the vulnerabilities and released the patched ver-
sion quickly.4 Some developers did not respond but ﬁxed
the bugs silently. Yet others did not response and chose to
completely ignore our report.
5.1 Passive Content Leaks
In our dataset, we detected 1, 279 apps that are vulnera-
ble to passive content leaks. In the following, we organize
them into several main categories. The overall results are
summarized in Table 2. In the table, we show the number
of vulnerable apps in each category and the detailed infor-
3In this paper, we use versionName and versionCode in its manifest ﬁle
to uniquely specify an app. For example the versionName and versionCode
of MiTalk Messenger app is 2.1.365 and 365, respectively.
4For example, the developers of Maxthon Mobile Web Browser re-
sponded within less than one day and released a patched version in two
weeks. And the developers of Match.com - #1 Dating Site acknowledged
our reports and kept us updated about their process of this vulnerability.
Category
# of
Apps
App Name
Package Name
Version
# of Installs
Representative Apps (Available on Google Play)
SMS messages
268
Message GOWidget
Pansi SMS
Youni SMS
Blovestorm
com.gau.go.launcherex.
gowidget.smswidget
com.pansi.msg
com.snda.youni
com.blovestorm
mOfﬁce - Outlook sync
com.innov8tion.isharesync
WaliSMS
cn.com.wali.walisms
Contacts
128
Shady SMS 3.0 PAYG
Private information
in IM apps
121
360 Kouxin
GO SMS Pro
Messenger WithYou
Nimbuzz Messenger
MiTalk Messenger
com.project.
memoryerrorthreepayg
com.qihoo360.kouxin
com.jb.gosms
miyowa.android.
microsoft.wlm
com.nimbuzz
com.xiaomi.channel
Youdao Dictionary
com.youdao.dict
User credentials
80
GO FBWidget
Netease Weibo
com.gau.go.launcherex.
gowidget.fbwidget
com.netease.wb
2.3/17
1
,
000
000 - 5
,
,
000
,
000
2.06/226
2.1.0c/67
3.2.1/28
3.0/21
3.2.2/39
1.78/228
1.51/96
4.32/69
2.0.76/
2000076
2.0.10/2091
2.1.365/365
2.0.1(2)/
2000102
500
000 - 1
,
,
000
,
000
100
100
100
100
,
,
,
,
000 - 500
000 - 500
000 - 500
000 - 500
,
,
,
,
000
000
000
000
50
000 - 100
,
,
000
1
,
10
,
000
,
000 - 5
000 - 50
,
000
000
,
,
000
10
000
000 - 50
,
,
,
000
,
000
1
,
000
100
,
,
000 - 5
000 - 500
,
000
,
000
000
,
1
,
000
000 - 5
,
,
000
,
000
2.2/15
1
,
000
000 - 5
,
,
000
,
000
1.2.2/12
10
,
5
,
000 - 50
000 - 1
,
000
,
000
Netease Cloudalbum
com.netease.cloudalbum
Ver 2.2.0/7
Browser history
or bookmarks
Dolphin Browser HD
Maxthon Android
70
Web Browser
mobi.mgeek.
TunnyBrowser
7.3.0/116
10
000
000 - 50
,
,
,
000
,
000
com.mx.browser
2.4.6/2811
500
000 - 1
,
,
000
,
000
Boat Browser Mini
com.boatgo.browser
3.0.2/1611
500
000 - 1
,
,
000
,
000
Call logs
Private information
in social
network apps
61
27
Mobile Security
Personal Ed.
Droid Call Filter
Tc Assistant
Anguanjia
GO TwiWidget
Sina Weibo
Tencent WBlog
com.trendmicro.
tmmspersonal
com.droiddev.blocker
cn.com.tc.assistant
com.anguanjia.safe
com.gau.go.launcherex.
gowidget.twitterwidget
2.1/31
50
000 - 100
,
,
000
1.0.23/24
4.3.0/19
2.58/57
100
10
10
,
,
,
000 - 500
000 - 50
000 - 50
,
,
000
,
000
000
2.1/14
1
,
000
000 - 5
,
,
000
,
000