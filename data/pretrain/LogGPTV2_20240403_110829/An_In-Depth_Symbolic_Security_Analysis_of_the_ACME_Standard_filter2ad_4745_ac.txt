satisfies the predicate. In fact, the auth_send function can only be
called by an honest sender if the message it wants to put on the
global trace satisfies this predicate (see the requires clause of that
function). Conversely, when a party receives such a message, it can
be sure that the predicate is satisfied or the sender is corrupted (see
the ensures clause of the receive function). Finally, we extend the
valid_trace predicate such that for every authenticated message,
either the (ostensible) sender is corrupted or auth_send_pred holds.
We point out that the concept introduced here greatly general-
izes the basic notion of an authenticated channel. We cannot only
express that a message has been sent by a certain sender, we can
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2605even express that this message has certain properties and, for ex-
ample, that the (honest) sender, when sending this message, was in
a certain state. The authenticated send predicate can be customized
per application, and hence, can precisely reflect relevant aspects of
the behavior of honest parties in that application.
3.2 Modeling Key Substitution Attacks
Key substitution attacks [46] (also called duplicate signature key
selection [19] or (no) exclusive ownership attacks [48]) are subtle
properties of signature schemes that are not excluded by standard
cryptographic security definitions for signatures, and that can lead
to attacks on protocols, with an early draft of ACME being one
example [2] (see also Section 5). However, the default model of
signatures in DY★ does not account for such attacks.
We extend the algebraic model of signatures in DY★ to allow key
substitution attacks. More specifically, following [36] we formulate
(no) destructive exclusive ownership (DEO) and (no) conservative
exclusive ownership (CEO), with CEO being a special case of DEO.
Roughly speaking, if a signature scheme fails to provide DEO,
given a signature 𝑠 on a message 𝑚, an attacker can forge a new
verification key for a message 𝑚′ (possibly ≠ 𝑚) such that 𝑠 verifies
under the new key for 𝑚′. Similarly to [36], we specify a function
that enables the adversary to generate such a verification key:
val deo_gen: m':bytes → sig:bytes → bytes
This function is used to generate a new type of DY★ bytes:
type bytes = ... | DEOgen: m':bytes → sig:bytes → bytes | ...
We extend the verify function for signatures such that if the verifi-
cation key provided to the function is of this type, the verification
succeeds if the (forged) key was generated for the signature and
message.1 We verify that the modified function indeed reflects
no-DEO using the following lemma, which expresses this property:
val deo_gen_verify_lemma: m:bytes → m':bytes → sk:bytes →
Lemma (ensures (verify (pk (deo_gen m' (sign sk m))) m' (sign sk m) == true))
This lemma is automatically proven by F★’s type checker. DY★
contains similar lemmas to ensure that signatures work as intended.
These are unaffected by our change but illustrate that our exten-
sion does not break the existing semantics of signatures. There is,
however, one lemma that (obviously) fails under this modification.
val sign_verify_lemma: vk:bytes → msg:bytes → tag:bytes →
Lemma (verify vk msg tag =⇒
(∃ sk msg' . tag == sign sk msg' ∧ vk = pk sk ∧ msg = msg'))
This lemma states that any signature must have been created with
the correct key, which, however, is not the case anymore. We there-
fore remove this lemma from the (extended) DY★ framework.
No-CEO is a special case of no-DEO where 𝑚′ = 𝑚 (see, e.g., [48]).
We, hence, can formalize no-CEO similarly to no-DEO.
3.3 Our Approach for Interoperability
As mentioned in Section 2, DY★ allows for symbolic debugging
of model code and enables us to execute and test our model as a
sanity check. Still, there might be subtle mismatches between the
model and the real-world specification. Therefore, we want to test
a DY★ model against a real-world implementation, i.e., we take
Figure 1: Overview of the interoperable implementation ar-
chitecture. The core of the application (on the right) consists
of the verified F★ code.
the symbolic implementation of one party, connect it to a real net-
work, and run it with real-world counterparts. This way, we check
for interoperability to strengthen confidence in the model and to
illustrate that the model is as precise as a reference implementation.
To this end, we leverage the symbolic debugging feature of DY★
to compile our verified model (including the DY★ framework) to
OCaml code. We further implement a wrapper in OCaml that con-
nects the (now) executable model with the real world (see Figure 1).
This wrapper mainly translates messages from real bytes to sym-
bolic bytes and vice-versa. For this purpose, the wrapper maintains
a mapping between symbolic nonces and keys to concrete counter-
parts. Based on the message it receives from the real network, the
wrapper also selects the protocol endpoint to call.2 Hence, some
parts of the wrapper are application-specific. But it does not per-
form deeper application logic or state management. In particular,
we do not change the code generated from the DY★ model. It is this
code, with all its layers, that is called by the wrapper to actually
carry out the protocol. The code, for instance, still maintains the
trace as a (now local) data structure to keep state. We illustrate our
approach in Section 8, with ACME as an example.
We note that our approach for interoperability does not aim to
yield a fully verified real-world executable but rather allows us to
perform in-depth functional tests of the entire (verified) model with
real-world counterparts.
4 THE ACME PROTOCOL
The ACME standard defines a protocol between a client and a server.
In practice, a web server that wants to get a new certificate acts as
an ACME client, and a CA acts as an ACME server. To request a
certificate, the ACME client creates an order for one or more of its
own domains and sends the order to the ACME server. The ACME
server then responds with an authorization message containing one
or more challenges (usually a nonce) for each of the domains. The
client publishes each challenge on (the HTTP web server or the
DNS server of) its corresponding domain (along with some other
data, see below) to prove that the client indeed controls the domains.
The ACME server verifies that the challenges have indeed been
published accordingly for all requested domains. Finally, the client
creates a key pair for the domains and provides the ACME server
with the public key (contained in an X.509 certificate signing request
(CSR)). The ACME server then issues a certificate containing the
public key and all domains previously requested by the client.
1Note that our symbolic model allows privileged functions such as verify to “unwrap”
signatures to inspect the message they have been created for.
2Note that this way, we leave scheduling of our application to the network, which is a
standard assumption for protocol analyses.
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2606creates an asymmetric key pair (pk𝑎𝑐𝑐, sk𝑎𝑐𝑐) in Step 1 that will be
used to sign (and verify) protocol messages sent by the client to the
ACME server. The client registers pk𝑎𝑐𝑐 at the server 2 , which in
turn creates an account identified by some URL3 𝑖𝑎𝑐𝑐 for this key 3
and sends it to the client 4 . The client stores the identifier along
with the corresponding key pair 5 , and henceforth, each request
to the server includes 𝑖𝑎𝑐𝑐 and is signed with the signing key sk𝑎𝑐𝑐.
To request a new certificate, the client creates an order for a set
of domains (belonging to the client) 6 . For each of these domains,
the server generates a so-called authorization object that tracks
the ownership verification of the domain 7 . Each authorization is
identified by a URL 𝑎 𝑗 and includes one or more challenges, one for
each verification method that the server supports. Each challenge
is identified by some URL 𝑐𝑘
𝑗 , which is later used to state which
challenge the client decided to solve. For each challenge, the server
also generates a nonce 𝑡𝑘
𝑗 (see below). The server further generates
a finalize URL 𝑓𝑜 for the order which the client uses at the end
of the flow to request the actual certificate. After the order has
been created at the server, the server provides the client with meta-
information about the order 8 , including the authorization URLs
at which the client can retrieve the challenges for each domain as
well as the finalize URL, all of which the client needs to know to
perform later steps of the protocol 9 .
To prove ownership of each domain, the client first retrieves
the respective authorization object (including the challenges) from
the server (Steps 10 and 11 ). To make an authorization valid, i.e.,
convince the server that the client indeed owns a domain, the
client can choose one of the challenges 12 (say challenge 𝑙) as it is
sufficient for ACME to solve only one challenge (recall that the set
of challenges represents different verification methods). Typically,
a challenge is to publish the nonce 𝑡𝑙
𝑗 (concatenated with pk𝑎𝑐𝑐) in
some way that only someone with a high level of control over that
domain is able to do 13 .4 To trigger verification of the challenge
𝑙 that the client has chosen, the client sends a request to the URL
14 . The ACME server now checks whether the client was able to
𝑐𝑙
𝑗
publish the nonce correctly. To this end, the server sends an HTTP
request to some well-known path of the respective domain 15 . The
server verifies that the HTTP response 16 sent by the (web server
of) the client contains (𝑡𝑙
𝑗 , pk𝑎𝑐𝑐) and records that the authorization
has successfully been verified 17 . Note that the ACME standard
assumes that an attacker cannot spoof or manipulate the verification
response 16 .5 Otherwise, an attacker can trivially attack ACME and
verify ownership of arbitrary domains. In our model (see below),
we use an authenticated channel to transfer the message of Step 16
(all other messages are sent over an insecure channel). After the
ACME server successfully verified each authorization, the server
considers the order of the certificate to be valid and allows the
client to request a certificate. To this end, the client creates a fresh
3The account URL not only identifies this account but also allows the client to send re-
quests to the server to change account metadata, replace the account key, or deactivate
the account.
4Currently, there exist three challenge types, http-01, dns-01, and tls-alpn-01 (the
latter is specified in a separate standard [50]). All challenge types work very similar,
and for presentation, we here assume that challenge 𝑙 is an HTTP-01 challenge.
5In practice, CAs verify the publication of the challenge data several times using
different network routes to minimize the probability of an attacker being man-in-the-
middle for all verification messages, see, e.g., [23]. See also Section 10.2 of [5].
Figure 2: ACME protocol flow. We note that this figure sim-
plifies several aspects of ACME for brevity, e.g., the presen-
tation of JWS messages, which use a well-structured data
format and include the URL they are sent to. JWS messages
have to be signed by the sender, and this signature is verified
by the receiver. Also, the last step has been simplified. In re-
ality, the server does not return the certificate in Step 21, but
a URL instead, at which the client then retrieves the certifi-
cate. In our model, however, we include all such details.
The actual ACME protocol is designed to work asynchronously
and breaks the sketched flow into several (smaller) steps. Each of
these steps is linked to the flow using unique identifiers (provided in
URLs) that are issued by the ACME server step-by-step during the
flow. The protocol requires the client to authenticate each message
(based on the JSON Web Signature (JWS) standard [37]).
4.1 Main Protocol Flow
Figure 2 depicts a typical ACME protocol flow (simplified for pre-
sentation). Before the client actually orders a certificate, it first
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2607key pair along with a corresponding X.509 CSR 18 , and transfers
the CSR to the server 19 . The ACME server checks whether the
CSR lists the same set of domains as the order and (if the check
succeeds) issues the certificate for this CSR 20 and provides the
certificate to the client 21 which in turn stores the certificate for
usage 22 . We note that for brevity of presentation, the protocol
description above focuses on the main functionality of ACME, and
in particular, does not present mechanisms for replay protection,
account management, pre-authorization, and certificate revocation
(see Sections 6.5, 7.3, 7.4.1 and 7.6 of [5]).
4.2 Informal Security Goals
Informally, the ACME protocol intends to ensure that clients can
obtain certificates only for domains under their control. The security
considerations section of the ACME specification (see Section 10
of [5]) divides this goal into two concrete statements, intending
to restrict the authorizations to the rightful parties: (1) A client
should only be able to get authorizations for domains it controls,
and (2) authorizations for a domain associated with an account
(via the account public key) should not be used by other accounts.
Without either of these properties holding true, an attacker could
get certificates for someone else’s domains.
5 ATTACKS AND VULNERABILITIES
The previous section illustrates that the 100 page ACME stan-
dard [5] forms a quite complex, asynchronous protocol, which
consists of unbounded recursive control flows, complex state man-
agement, and messages with unbounded data structures, such as
lists or trees, which themselves again need to be processed in loops.
There can be potential flaws and problems on various levels,
including logical and implementation flaws as well as ambiguities
in the RFC that programmers might interpret incorrectly.
𝑗 , 𝑠𝑘𝑎𝑐𝑐) instead of (𝑡𝑙
For example, in an early draft of the standard, the value published
for domain ownership verification (see Steps 13 and 16 of Figure 2)
used to be 𝜎 = sign(𝑡𝑙
𝑗 , 𝑝𝑘𝑎𝑐𝑐), i.e., the client
published only the value of a signature on the respective domain
𝑗.6 As ACME allows clients to use signature schemes,
challenge 𝑡𝑙
which do not provide DEO, such as RSA-PSS and certain instanti-
ations of ECDSA, an adversary can easily carry out an attack to
obtain a certificate for a domain of some honest client [2]: After
the honest client has published 𝜎 for her domain 𝑑, the adversary
uses its own account to start another ACME flow for 𝑑. After the
ACME server has issued a new challenge 𝑡′ (to the attacker) to
verify ownership of 𝑑, the adversary forges a new key pair for its
account such that 𝜎 is a valid signature for the challenge 𝑡′ under
the attacker’s new public account key.
One of the most important implementations of an ACME server,
Boulder, contained an implementation error in the ownership veri-
fication loop for domains which resulted in Boulder checking only
the first domain in the list of an order, allowing an adversary to
obtain certificates for domains it does not own [35]. As already men-
tioned in the introduction, as a result of this error, Let’s Encrypt
had to revoke more than 3 million certificates.
6Note that at this time, ACME used different challenge concepts for the several domain
verification sub-protocols. This verification mechanism was part of the DNS-based
authorization mechanism.
DY★
ACME model
Σ
# modules
13
37
50
fLoC pLoC Σ LoC
5,986
2,180
10,722
5,531
7,711
16,708
3,806
5,191
8,997
Time
6 min
61 min
67 min
Table 1: Overview on lines of code and verification time, in-
cluding number of modules, functional lines of code (fLoC),
lines of code for proofs and security property (pLoC), and
the verification time using the F★ type checker on an off-
the-shelf machine (single-core on Intel Xeon E5-2620 v4 @
2.1 GHz). Note that verification in DY★ is modular; each mod-