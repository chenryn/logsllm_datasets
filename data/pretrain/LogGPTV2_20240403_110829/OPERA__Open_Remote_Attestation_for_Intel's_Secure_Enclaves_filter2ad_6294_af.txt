Mona Vij. 2018. Integrating Remote Attestation with Transport Layer Security.
CoRR abs/1801.05863 (2018). arXiv:1801.05863 http://arxiv.org/abs/1801.05863
[25] Arseny Kurnikov, Klaudia Krawiecka, Andrew Paverd, Mohammad Mannan, and
N. Asokan. 2018. Using SafeKeeper to Protect Web Passwords. In Companion
Proceedings of the The Web Conference 2018 (WWW ’18). International World
Wide Web Conferences Steering Committee, Republic and Canton of Geneva,
Switzerland.
[26] Dmitrii Kuvaiskii, Oleksii Oleksenko, Sergei Arnautov, Bohdan Trach, Pramod
Bhatotia, Pascal Felber, and Christof Fetzer. 2017. SGXBOUNDS: Memory Safety
for Shielded Execution. In 12th European Conference on Computer Systems. ACM.
[27] Sinisa Matetic, Mansoor Ahmed, Kari Kostiainen, Aritra Dhar, David Sommer,
Arthur Gervais, Ari Juels, and Srdjan Capkun. 2017. ROTE: Rollback Protection
for Trusted Execution. In 26th USENIX Security Symposium (USENIX Security 17).
Vancouver, BC.
[28] Frank McKeen, Ilya Alexandrovich, Alex Berenzon, Carlos Rozas, Hisham Shafi,
Vedvyas Shanbhogue, and Uday Savagaonkar. 2013.
Innovative Instructions
and Software Model for Isolated Execution. In 2nd International Workshop on
Hardware and Architectural Support for Security and Privacy. ACM.
[29] Olga Ohrimenko, Felix Schuster, Cedric Fournet, Aastha Mehta, Sebastian
Nowozin, Kapil Vaswani, and Manuel Costa. 2016. Oblivious Multi-Party Machine
Learning on Trusted Processors. In 25th USENIX Security Symposium. USENIX
Association.
[30] Thomas Ristenpart, Eran Tromer, Hovav Shacham, and Stefan Savage. 2009.
Hey, you, get off of my cloud: Exploring information leakage in third-party
compute clouds. In Proceedings of the 16th ACM conference on Computer and
communications security. ACM.
[31] Mark Russinovich. 2017. Introducing Azure confidential computing.
https:
//azure.microsoft.com/en-us/blog/introducing-azure-confidential-computing/.
[32] Vinnie Scarlata, Simon Johnson, James Beaney, and Piotr Zmijewski. 2018. Sup-
porting Third Party Attestation for Intel SGX with Intel Data Center Attestation
Primitives. (2018). https://software.intel.com/sites/default/files/managed/f1/b8/
intel-sgx-support-for-third-party-attestation.pdf
[33] F. Schuster, M. Costa, C. Fournet, C. Gkantsidis, M. Peinado, G. Mainar-Ruiz, and
M. Russinovich. 2015. VC3: Trustworthy Data Analytics in the Cloud Using SGX.
Session 10B: TEE IICCS ’19, November 11–15, 2019, London, United Kingdom2329In 36th IEEE Symposium on Security and Privacy.
[34] Jaebaek Seo, Byoungyoung Lee, Seongmin Kim, Ming-Wei Shih, Insik Shin,
Dongsu Han, and Taesoo Kim. 2017. SGX-Shield: Enabling Address Space Layout
Randomization for SGX Programs. In The Network and Distributed System Security
Symposium.
[35] Shweta Shinde, Dat Le Tien, Shruti Tople, and Prateek Saxena. 2017. Panoply:
Low-TCB Linux Applications With SGX Enclaves. In The Network and Distributed
System Security Symposium.
[36] Rohit Sinha, Sriram Rajamani, Sanjit Seshia, and Kapil Vaswani. 2015. Moat: Veri-
fying Confidentiality of Enclave Programs. In 22nd ACM Conference on Computer
and Communications Security. ACM.
[37] Claudio Soriente, Ghassan Karame, Wenting Li, and Sergey Fedorov. 2019. Replica-
TEE: Enabling Seamless Replication of SGX Enclaves in the Cloud. In Proceedings
of the 2019 IEEE European Symposium on Security and Privacy.
[38] Raoul Strackx and Frank Piessens. 2016. Ariadne: A Minimal Approach to State
Continuity. In 25th USENIX Security Symposium. USENIX Association.
[39] Yogesh Swami. 2017. SGX Remote Attestation is not Sufficient. Cryptology ePrint
Archive, Report 2017/736. https://eprint.iacr.org/2017/736.
[40] Sandeep Tamrakar, Jian Liu, Andrew Paverd, Jan-Erik Ekberg, Benny Pinkas,
and N. Asokan. 2017. The Circle Game: Scalable Private Membership Test Using
Trusted Hardware. In ACM on Asia Conference on Computer and Communications
Security. ACM.
[41] Florian Tramer, Fan Zhang, Huang Lin, Jean-Pierre Hubaux, Ari Juels, and Elaine
Shi. 2017. Sealed-Glass Proofs: Using Transparent Enclaves to Prove and Sell
Knowledge. In Proceedings of the 2017 IEEE European Symposium on Security and
Privacy.
[42] D. Tychalas, N. G. Tsoutsos, and M. Maniatakos. 2017. SGXCrypter: IP protection
for portable executables using Intel’s SGX technology. In 22nd Asia and South
Pacific Design Automation Conference.
[43] Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci, Frank
Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx.
2018. Foreshadow: Extracting the Keys to the Intel SGX Kingdom with Transient
Out-of-Order Execution. In 27th USENIX Security Symposium (USENIX Security
18). USENIX Association, Baltimore, MD.
[44] Stephan van Schaik, Alyssa Milburn, Sebastian ÃŰsterlund, Pietro Frigo, Giorgi
Maisuradze, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2019. RIDL:
Rogue In-flight Data Load. In 40th IEEE Symposium on Security and Privacy.
[45] Venkatanathan Varadarajan, Yinqian Zhang, Thomas Ristenpart, and Michael
Swift. 2015. A Placement Vulnerability Study in Multi-Tenant Public Clouds. In
USENIX Security Symposium.
[46] Samuel Weiser and Mario Werner. 2017. SGXIO: Generic Trusted I/O Path for Intel
SGX. In Proceedings of the Seventh ACM on Conference on Data and Application
Security and Privacy (CODASPY ’17). ACM, New York, NY, USA.
[47] Fan Zhang, Ethan Cecchetti, Kyle Croman, Ari Juels, and Elaine Shi. 2016. Town
Crier: An Authenticated Data Feed for Smart Contracts. In Proceedings of the
2016 ACM SIGSAC Conference on Computer and Communications Security (CCS
’16). ACM, New York, NY, USA.
[48] Fan Zhang, Ittay Eyal, Robert Escriva, Ari Juels, and Robbert Van Renesse. 2017.
REM: Resource-Efficient Mining for Blockchains. In 26th USENIX Security Sym-
posium. USENIX Association.
[49] Wenting Zheng, Ankur Dave, Jethro G. Beekman, Raluca Ada Popa, Joseph E.
Gonzalez, and Ion Stoica. 2017. Opaque: An Oblivious and Encrypted Distributed
Analytics Platform. In 14th USENIX Symposium on Networked Systems Design and
Implementation. USENIX Association.
[50] Guy Zyskind, Oz Nathan, and Alex Pentland. 2015. Enigma: Decentralized
Computation Platform with Guaranteed Privacy. CoRR abs/1506.03471 (2015).
arXiv:1506.03471 http://arxiv.org/abs/1506.03471
A PROVERIF CODE
The ProVerif code for the security proof is listed below.
(* EPID scheme *)
type epidikey.
type epidvkey.
fun epidvk(epidikey): epidvkey.
type epidmkey.
type epidpkow.
type epidcert.
fun epidpk(epidmkey, bitstring): epidpkow.
fun epidct(epidpkow, epidikey, bitstring): epidcert.
fun epidsign(bitstring, epidmkey, epidcert): bitstring.
reduc forall m: bitstring, k: epidmkey, c: epidcert;
getepidmsg(epidsign(m, k, c)) = m.
reduc forall m: bitstring, mk: epidmkey, ik: epidikey, nonce: bitstring;
checkepidsign(
epidsign(m, mk, epidct(epidpk(mk, nonce), ik, nonce)),
epidvk(ik)
) = m.
fun vk2bs(epidvkey): bitstring.
reduc forall vk: epidvkey; bs2vk(vk2bs(vk)) = vk.
fun pk2bs(epidpkow): bitstring.
reduc forall pk: epidpkow; bs2pk(pk2bs(pk)) = pk.
fun ct2bs(epidcert): bitstring.
reduc forall ct: epidcert; bs2ct(ct2bs(ct)) = ct .
(* Symmetric encryption *)
type sekey.
fun senc(bitstring, sekey): bitstring.
reduc forall m: bitstring, k: sekey;
sdec(senc(m, k), k) = m.
(* Diffie-Hellman *)
type G.
type exponent.
const g: G [data].
fun exp(G, exponent): G.
equation forall x: exponent, y: exponent;
exp(exp(g, x), y) = exp(exp(g, y), x).
fun G2sek(G): sekey.
fun G2bs(G): bitstring.
reduc forall gxy: G; bs2G(G2bs(gxy)) = gxy.
(* SGX related *)
type sgxsp.
type mrenc.
type rpkey.
fun mr(sgxsp): mrenc.
fun egetrpkey(sgxsp): rpkey.
fun ereport(sgxsp, mrenc, bitstring): bitstring.
reduc forall sFrom: sgxsp, rTo: mrenc, m: bitstring;
egetreport(ereport(sFrom, rTo, m)) = m.
reduc forall sFrom: sgxsp, rTo: mrenc, m: bitstring;
egetmrfrom(ereport(sFrom, rTo, m)) = mr(sFrom).
reduc forall sFrom: sgxsp, sTo: sgxsp, m: bitstring;
everif(ereport(sFrom, mr(sTo), m), egetrpkey(sTo)) = m.
(* free names *)
free ae_ie: channel.
free ie_qe: channel.
free ae_qe: channel.
free la: channel.
free ra: channel.
free c: channel.
free epidikIntel: epidikey [private].
free sgxIntelQE: sgxsp [private].
free sgxIssueE: sgxsp [private].
free sgxAttestE: sgxsp [private].
free sgxIsvE: sgxsp [private].
free s: bitstring [private].
(* query *)
query attacker(s).
(* protocol *)
let IntelQE(sp: sgxsp, mk: epidmkey, ct: epidcert, la: channel) =
in(la, erpt: bitstring);
let rpt = everif(erpt, egetrpkey(sp)) in
let mrf = egetmrfrom(erpt) in
out(la, epidsign((mrf , rpt), mk, ct)).
let IssueE(sp: sgxsp, epidik: epidikey, aem: mrenc,
Session 10B: TEE IICCS ’19, November 11–15, 2019, London, United Kingdom2330qem: mrenc, qec: channel, ae: channel) =
(* msg 1 *)
in(ae, req: bitstring);
(* get IAS quote of cert *)
let vk = epidvk(epidik) in
out(qec, ereport(sp, qem, vk2bs(vk)));
in(qec, cert: bitstring);
new nonce: bitstring;
(* msg 2 *)
out(ae, (nonce, cert));
(* msg 3 *)
in(ae, quotepk: bitstring);
let (mrf : mrenc, pk: bitstring)
= checkepidsign(quotepk, epidvk(epidikIntel)) in
(* security check: verify the identity of AttestE *)
if mrf = aem then
(* msg 4 *)
out(ae, epidct(bs2pk(pk), epidik, nonce)).
let AttestE(sp: sgxsp, qem: mrenc, qec: channel,
ie: channel, la: channel) =
(* msg 1 *)
new req: bitstring;
out(ie, req);
(* msg 2 *)
in(ie, (nonce: bitstring, cert: bitstring));
new mk: epidmkey;
let pk = epidpk(mk, nonce) in
(* get IAS quote *)
out(qec, ereport(sp, qem, pk2bs(pk)));
in(qec, quotepk: bitstring);
(* msg 3 *)
out(ie, quotepk);
(* msg 4 *)
in(ie, ct: bitstring);
(* remote attesation *)
in(la, erpt: bitstring);
let rpt = everif(erpt, egetrpkey(sp)) in
let mrf = egetmrfrom(erpt) in
out(la, (epidsign((mrf , rpt), mk, bs2ct(ct)), cert)).
let IsvE(sp: sgxsp, aem: mrenc, la: channel, ra: channel) =
(* rcv isv challenge *)
in(ra, (gx: G, nonce: bitstring));
new y: exponent;
let dhsk = G2sek(exp(gx, y)) in
let enonce = senc(nonce, dhsk) in
(* get OPERA quote *)
out(la, ereport(sp, aem, (exp(g, y), enonce)));
in(la, (quote: bitstring, cert: bitstring));
(* send response *)
out(ra, (quote, cert));
(* rcv isv secret *)
in(ra, emsg: bitstring).
let IsvClient(isvm: mrenc, iem: mrenc, ra: channel) =
(* send challenge *)
new x: exponent;
new nonce: bitstring;
out(ra, (exp(g, x), nonce));
(* rcv response *)
in(ra, (quote: bitstring, cert: bitstring));
let (mrfie: mrenc, asvk: bitstring)
= checkepidsign(cert, epidvk(epidikIntel)) in
(* security check: verify the identity of IssueE *)
if mrfie = iem then
let (mrf : mrenc, (gy: G, enonce: bitstring))
= checkepidsign(quote, bs2vk(asvk)) in
(* security check: verify the identity of the attested enclave *)
if mrf = isvm then
let dhsk = G2sek(exp(gy, x)) in
if sdec(enonce, dhsk) = nonce then
(* send secret *)
out(ra, senc(s, dhsk)).
process
let epidvkIntel = epidvk(epidikIntel) in out(c, epidvkIntel);
new epidmkQE1: epidmkey;
new epidmkQE2: epidmkey;
new nonceQE1: bitstring;
new nonceQE2: bitstring;
let mrQE = mr(sgxIntelQE) in out(c, mrQE);
let mrIE = mr(sgxIssueE) in out(c, mrIE);
let mrAE = mr(sgxAttestE) in out(c, mrAE);
let mrISVE = mr(sgxIsvE) in out(c, mrISVE);
new epidikAS: epidikey;
(
IntelQE(sgxIntelQE, epidmkQE1,
epidct(epidpk(epidmkQE1, nonceQE1),
epidikIntel, nonceQE1), ie_qe) |
IssueE(sgxIssueE, epidikAS, mrAE, mrQE, ie_qe, ae_ie) |
IntelQE(sgxIntelQE, epidmkQE2,
epidct(epidpk(epidmkQE2, nonceQE2),
epidikIntel, nonceQE2), ae_qe) |
AttestE(sgxAttestE, mrQE, ae_qe, ae_ie, la) |
IsvE(sgxIsvE, mrAE, la, ra) |
IsvClient(mrISVE, mrIE, ra)
)
Session 10B: TEE IICCS ’19, November 11–15, 2019, London, United Kingdom2331