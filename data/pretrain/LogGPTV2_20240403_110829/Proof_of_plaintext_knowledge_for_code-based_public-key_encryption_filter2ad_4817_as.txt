(λ) +
1
p − 1
.
Recall, from Lemma 3, that for any matrix distribution Dk(p), we have Dk(p)-MDDH
⇒ Uk(p)-MDDH.
86
Chapter 4. Multi-Input Inner-Product Functional Encryption from Pairings
p, ezi ←R Zp, and r ←R Zk
Proof of Lemma 29. Here, we switch {[r]2, [hzi, ri]2}i∈HS used by the oracle OKeygen to {[r]2,
[ezi]2}i∈HS, where zi ←R Zk
p. Recall that HS denotes the set of honest
slots, that is HS := [n] \ CS.
This is justiﬁed by the fact that {[r]2, [hzi, ri]2}i∈HS ∈ G(k+h)
, where h is the size of HS,
is identically distributed to [Ur]2 where U ←R Uk+h,k(p) (wlog. we assume that the upper k
rows of U are full rank), which is indistinguishable from a uniformly random vector over Gk+h
,
that is, of the form: {[r]2, [ezi]2}i∈HS, according to the Uk+h,k(p)-MDDH assumption. To do the
switch simultaneously for all calls to OKeygen, that is, to switch {[rj]2, [hzi, rji]2}i∈HS,j∈[Q0]
to {[rj]2, [ezj
p for all j ∈ [Q0], where Q0 denotes
the number of calls to OKeygen, we use the Q0-fold Uk+h,k(p)-MDDH assumption. Namely, we
build a PPT adversary B′
i ]2}i∈HS,j∈[Q0], where ezj
i ← Zp and rj ←R Zk
2,β such that
2
2
AdvG1,β (A) − AdvG2,β (A) ≤ Adv
Q0-Uk+h,k(p)-mddh
G2,B′
2,β
(λ).
IP
2
2
p, and sets eki
2,β proceeds as follows.
This, together with Corollary 1 (Uk(p)-MDDH ⇒ Q0-fold Uk+h,k(p)-MDDH), implies the
lemma. The adversary B′
-Simulation of (pk,{cti}i∈I ,{eki}i∈CS):
Upon receiving an Q0-fold Uk+h,k-MDDH challenge
(cid:17) ,
,hh1k···khQ0i2 ∈ G(k+h)×Q0
(cid:16)PG, [U]2 ∈ G(k+h)×k
2,β samples (ggpk, td) ←
i}i∈I,b∈{0,1} and the set CS ⊆ [n] from A, B′
). For all i ∈ [n], it samples (feki, gmski) ← ^Setup(1λ,ggpk, F m+k,X,Y
:= gEnc(td,feki, gmski).
:= (feki, zi). For all i ∈ HS, it samples cti
It sets pk := ggpk, and returns
together with the challenge {xb
^GSetup(1λ, F m+k,X,Y
zi ←R Zk
For all i ∈ CS ∩ I, it samples cti := Enc′(ggpk,feki, xβ
(pk,{cti}i∈I ,{eki}i∈CS) to A.
-Simulation of OKeygen(y1k···kyn):
On the j’th query y1k···kyn of A, B′
k-upper components of hj ∈ Zk+n
. For all i ∈ CS, it computes di := KeyGen′(ggpk, gmski,
k+i]2(cid:17),
yikrj). For all i ∈ HS, it computes [di] := ^KeyGen(cid:16)td, gmski, [yikrj]2, [hxβ
k+i denotes the k + i’th coordinate of the vector hj ∈ Zk+h
the fact that ^KeyGen(td, gmsk,·,·) is linear in its inputs (y, a), so that B′
^KeyGen(gmsk, [y]2, [a]2) = [ ^KeyGen(gmsk, y, a)]2. Note that whenhh1k···khQ0i2
challenge, B′
formly random over G(k+n)×Q0
2,β simulate game G1,β, whereas it simulates game G2,β whenhh1k···khQ0i2
. Here we rely on
2,β can compute
is a real MDDH
2,β sets [rj]2 := [hj]2, where hj ∈ Zk
i , yii + hj
p denotes the
IP
),
where hj
i kzi).
p
2
.
p
is uni-
Lemma 30: Game G2,0 to G2,1
AdvG2,0(A) = AdvG2,1(A).
Proof of Lemma 30. We show that G2,β does not depend on β, using the fact that for all
y1k···kyn ∈ (Zm
p }i∈[n],b∈{0,1}, the following are identically distributed:
p )n, for all {xb
i ∈ Zm
{ezi}i∈HS and {ezi − hxβ
i , yii }i∈HS ,
4.1 Selectively-Secure, Private-Key MIFE for Inner Products
87
i ∈ Zm
does not depend on β, and
where ezi ←R Zp for all i ∈ HS.
For each query y1k···kyn, OKeygen(y1k···kyn) picks values ezi ←R Zp for i ∈ HS that are
independent of y1k···kyn and the challenge {xb
p }i∈[n],b∈{0,1} (note that here we crucially
rely on the fact the games G2,0 and G2,1 are selective), therefore, using the previous fact, we can
switch ezi to ezi − hxβ
i , yii for all i ∈ HS, without changing the distribution of the game. This
way, for all i ∈ HS, OKeygen(y1k···kyn) computes di ← ^KeyGen(td, gmski, yikr,ezi), which
z := Xi∈CShzi, ri + Xi∈HSezi − Pi∈HShxβ
z := Xi∈CShzi, ri + Xi∈HSezi − Pi∈Ihxβ
i , yii .
i , yii = Pi∈Ihx1
Finally, by deﬁnition of the security game, we have: Pi∈Ihx0
i , yii. This is
implied by Condition 1 in Deﬁnition 23, and the fact that HS ⊆ I. That means the value
[z]T computed by OKeygen does not depend on β. Finally, for all i ∈ CS, OKeygen(y1k···kyn)
computes di := KeyGen′(ggpk, gmski, yikr), which does not depend on β. Putting everything
together, we get that G2,β is independent of β.
i for all i ∈ CS ∩ I. Thus, we have:
By deﬁnition of the security game, we have x0
i , yii .
i = x1
Remark 10: decryption capabilities
As a sanity check, we note that the simulated secret keys will correctly decrypt a sim-
ulated ciphertext. However, unlike schemes proven secure via the standard dual system
encryption methodology [Wat09], a simulated secret key will incorrectly decrypt a nor-
mal ciphertext. This is not a problem because we are in the private-key setting, so a
distinguisher will not be able to generate normal ciphertexts by itself.
Remark 11: why a naive argument is inadequate
1, x1
1, x0
We cannot aﬀord to do a naive hybrid argument across the n slots for the challenge
ciphertext as it would introduce extraneous restrictions on the adversary’s queries. Con-
cretely, suppose we want to use a hybrid argument to switch from encryptions of x0
1, x0
2
in game 0 to those of x1
2 in game 2 with an intermediate hybrid that uses encryp-
tions of x1
2 in Game1. To move from game 0 to game 1, the adversary’s query y1ky2
must satisfy hx0
1kx0
2, y1ky2i, which implies the extraneous restriction
hx0
1, y1i = hx1
1, y1i.
As described in the proof above, we overcome the limitation by using simulation-based
security. Note that what essentially happens in the ﬁrst slot in our proof is as follows (for
k = 1, that is, DDH): we switch from Enc′(pk′
1kz1) while giving
out a secret key which contains KeyGen′(msk′
1kz1) to Enc′(pk′
2, y1ky2i = hx1
1kx0
1, x0
1, x1
1, y1kr1) and [r1]2. Observe that
hx1
1, y1i + z1r1
1kz1, y1kr1i = hx1
hx0
1kz1, y1kr1i = hx0
1, y1i + z1r1,
may not be equal, since we want to avoid the extraneous restriction hx0
1, y1i.
This means that one-SEL-IND security does not provide any guarantee that the cipher-
texts are indistinguishable. However, one-SEL-SIM security does provide such a guaran-
tee, because
1, y1i = hx1
([hx0
1, y1i + z1r1]2, [r1]2) ≈c ([hx1
1, y1i + z1r1]2, [r1]2)
via the DDH assumption in G2. Since the outcomes of the decryption are computationally
88
Chapter 4. Multi-Input Inner-Product Functional Encryption from Pairings
indistinguishable, the output of the simulated ciphertext would also be computationally
indistinguishable.
Theorem 10: many-yy-IND-static security of MIFE
Let yy ∈ {AD,SEL}. Suppose FE is many-yy-IND secure and MIFE is one-yy-IND-
static secure. Then, MIFE is many-yy-IND-static secure.
Since the construction MIFE from Figure 4.1 is proven one-SEL-IND-static secure in
Theorem 9, we obtain the following corollary.
Corollary 2: many-SEL-IND-static security of MIFE
The scheme MIFE from Figure 4.1 is many-SEL-IND secure, assuming the underlying
FE is many-SEL-IND secure.
That is, we show that our multi-input FE is selectively secure in the setting with multi-
ple challenge ciphertexts (and since our multi-input FE is a private key scheme, this is not
immediately implied by the one-SEL-IND security).
Proof overview.
1 , . . . , x1,0
n
• We ﬁrst switch encryptions of x1,0
to those of x1,1
n , and for the re-
maining ciphertexts, we switch from an encryption of xj,0
i − x1,0
to
that of (xj,0
. This uses the one-yy-IND security of MIFE, and the fact
that its encryption algorithm is linearly homomorphic, thanks to which encryption of
i − x1,0
(xj,0
can be publicly computed from an encryption of x1,β
i − x1,0
) + x1,β
1 , . . . , x1,1
i = (xj,0
) + x1,0
) + x1,1
.
i
i
i
i
i
i
i
• Then, we switch from encryptions of
(x2,0
i − x1,0
i
) + x1,1
i
, . . . , (xQi,0
i − x1,0
i
) + x1,1
i
to those of
(x2,1
i − x1,1
i
) + x1,1
i
, . . . , (xQi,1
i − x1,1
i
) + x1,1
i
.
This uses the many-yy-IND security of FE.
As described earlier, to carry out the latter argument, the queries must satisfy the constraint
i − x1,0
h(xj,0
where the latter is already imposed by the ideal functionality.
, yii ⇐⇒ hxj,0
, yii = h(xj,1
, yii = hxj,1
i − x1,0
i − x1,1
i − x1,1
) + x1,1
) + x1,1
, yii
i
i
i
i
i
i
Proof of Theorem 10. We proceed via a series of games, described in Figure 4.5. The transi-
tions are summarized in Figure 4.4. Let A be a PPT adversary. For any game G, we denote
by AdvG(A) the probability that the game G outputs 1 when interacting with A.
Game G0:
tion 21.
is such that Advmany-SEL-IND
MIFE,A
(λ) = |AdvG0(A) − AdvG2(A)|, according to Deﬁni-
is as game G0, except we replace the challenge ciphertexts to ctj
Game G1:
xj,0
i − x1,0
we prove in Lemma 31 that there exists a PPT adversary B1 such that
i = Enc(pk, eki,
) for all i ∈ [n] and j ∈ [Qi], using the one-yy-IND security of MIFE. Namely,
i + x1,1
i
AdvG0(A) − AdvG1(A) ≤ Advone-yy-IND
MIFE,B1
(λ).
4.1 Selectively-Secure, Private-Key MIFE for Inner Products
89
game
ctj
i :
0
1
2
Enc(eki, xj,0
i − x1,0
Enc(eki, xj,1