r,exp), ((cid:100)SK
, enew, sk , pinfoenew )
r,new, sk(cid:48)
tl := TL.lock
(cid:48)
exp),
(cid:17)
(cid:48)
(cid:48)
(cid:48)
(cid:48)
sk(cid:48) := (pk , (sk(cid:48)
enew, sk , pinfoenew )
return pinfoenew , sk(cid:48)
10
11
12
13
14
15
16s
16c
17
Algorithm 4: Σ.sign
1 fun Σ.sign (sk , m):
2
3
4
5
σ := Σ.sign(cid:0)sk , pinfoe||m(cid:1)
σ := (σ, pinfoe)
return σ
, sk , pinfoe := sk
,
,
,
reason for why we prepend(cid:99)pk||t to the arguments of all calls
to H is simply to prevent multi-target attacks. While our proof
does not make use of this and as such there is no effect on our
ﬁnal security-statement, we consider it good practice to do so
anyways.
Theorem 5. Σ is complete in the sense of Deﬁnition 22.
For a proof we refer to the full version.
Theorem 6. Σ is unforgeable in the sense of Deﬁnition 16
with:
AdvEEUF-CMA
Σ,E ,V , F (cid:0)1λ, ∆t(cid:1)
(cid:0)1λ(cid:1)
 E · AdvPRF
(cid:0)1λ, V · ∆t(cid:1)
(cid:0)1λ(cid:1)
H, APRF
+ V · AdvIND-NMA
(cid:0)1λ(cid:1)
(cid:98)Σ,E , A4
+ AdvFS-EUF-CMA
+ AdvEUF-CMA
T L, AIND-NMA
Σ, A5
≤E ·
Proof. (Sketch, for the full proof see Appendix C1.)
We use game-hopping, with the regular EEUF-CMA-game
as starting-point.
Algorithm 5: Σ.verify
1 fun Σ.verify (pk , e, σ, m):
2
3
4
5
6
(cid:99)pk , t0, ∆t, E , V := pk
pk e(cid:48) , e(cid:48), re(cid:48)−V , (cid:98)sk e(cid:48)−V , tle(cid:48) ,(cid:98)σ := pinfoe(cid:48)
b0 :=(cid:98)Σ.verify
b1 := Σ.verify(cid:0)pk , σ, pinfoe(cid:48)||m(cid:1)
σ, pinfoe(cid:48) := σ
if e ≤ 0 ∨ e(cid:48) ≤ 0 ∨ e(cid:48) + V ≤ e ∨ e(cid:48) > e ∨ e > E:
(cid:16)(cid:99)pk ,(cid:98)σ, pk e(cid:48)||e(cid:48)||re(cid:48)−V ||(cid:98)sk e(cid:48)−V ||tle(cid:48)
return 0
(cid:17)
return b0 ∧ b1
7
8
9
In the ﬁrst hop we guess the epoch e for which F will
present a forgery and abort the execution after e + V − 1
epochs (loss-factor of 1
In the next hop we replace the random seeds re as well
as the pseudorandom random-tapes used for TL.lock and
Σ.gen of all epochs including and after e with random
values, which works because of the PRF-security of H (loss
≤ E · AdvPRF
E ).
In the next hop we encapsulate random values in all
timelock-puzzles that are generated in and after epoch e. This
works because of their hiding-property and because the game
enforces that F doesn’t have enough time to unlock them (loss
≤ V · AdvIND-NMA
ture contains a fresh signature under (cid:99)pk, present it to an
In the next hop we check whether the forged signa-
FS-EUF-CMA-challenger and abort the game if it is (loss
≤ AdvFS-EUF-CMA
(cid:0)1λ(cid:1)).
H, A(cid:0)1λ(cid:1)).
T L, A (cid:0)1λ, V · ∆t(cid:1)).
Σ, A
In the last hop we note that the forged signature must
contain a fresh signature under pk and we present it to an
EUF-CMA-challenger (loss ≤ AdvEUF-CMA
Theorem 7. Σ is deniable in the sense of Deﬁnition 17.
Proof. Our simulator S uses the information in pinfoe to
create a secret key that is equivalent to the real one for all
expired epochs and then simply executes the signing algorithm
as an honest party would. We ﬁrst introduce Algorithm 6
which extracts a suitable secret key from the public epoch
information pinfoe.
(cid:0)1λ(cid:1)).
(cid:98)Σ,E , A
,
for i ∈ {e − 1, . . . , 0}:
Algorithm 6: The key-extractor
1 fun extract sk(pk , pinfoe):
2
3
4
(cid:99)pk := pk
, e, re−V , (cid:98)sk e−V ,
(cid:17)
(cid:16)(cid:98)sk i+1
(cid:98)sk i :=(cid:98)Σ.update
ri := H(ri+1,(cid:99)pk||i + 1||0)
:= [(cid:98)sk 0, . . . , (cid:98)sk e]
r,(cid:99)pk , (cid:98)sk
∗
sk∗
return (sk∗
r := [r0, . . . , re]
, 0,⊥,⊥)
(cid:98)sk
5
6
7
8
9
∗
:= pinfoe
With this the actual simulation (Algorithm 7) essentially just
executes Σ.sign. If the sk that is computed by the simulator is
indeed equivalent to the real secret key, the deniability of our
scheme follows immediately from the remaining deﬁnition of
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:37 UTC from IEEE Xplore.  Restrictions apply. 
1689
Algorithm 7: Our simulator S
1 fun S(pk , pinfoe, ts):
sk∗ := extract sk(pk , pinfoe)
ts(cid:48) := [ ]
e(cid:48) := 0
for (e, m) ∈ ts:
e − e(cid:48) times :
ts(cid:48)|| = Σ.sign (sk∗, m)
, sk∗ := Σ.evolve (sk∗)
return ts(cid:48)
2
3
4
5
6
7
8
the simulator and the fact that Σ.evolve is deterministic. To see
that sk is in fact equivalent it is enough to see that the only
difference between it and the real key is that the pebbling data
structure doesn’t go back as many key/randomness evolutions,
preventing the use in future epochs. By the structure of the
game, this information is however not needed at the point at
which S runs. Therefore the only difference is one that does
not make a difference for the generated signatures because
sign does not use that information. Therefore the keys are
equivalent for all past epochs and the simulated signatures are
distributed exactly as they would be if they were honestly
generated. Since pinfoe and the relevant parts of sk e are
identical to the ones an honest party would have used and
since Σ is assumed to be stateless, this means that the resulting
signature is clearly information-theoretically indistinguishable
from a real one. Because this perfect indistinguishability holds
even if S is called more than once there is no way for J to
learn b, limiting her to guessing a random bit, which has a
success-probability of 1
2.
Therefore Σ is perfectly ofﬂine deniable.
We would like to add the following strengthening to The-
orem 7: Even if the simulator only receives pinfoe when it
should also create a signature for epoch e, it is still possible to
create a perfectly indistinguishable signature. To do so, S starts
by opening the time-lock puzzle tle (part of pinfoe) and will
after performing computations for roughly V ·∆t time receive
re and (cid:98)sk e. With those he can execute Algorithm 7 as before
and the resulting signatures will be perfectly indistinguishable
for the same reason presented above as well.
VII. ACKNOWLEDGEMENTS
We thank Sof´ıa Celi for her helpful comments. We also
thank the S&P reviewers and our shepherd Cas Cremers for
their helpful comments and suggestions. We especially thank
reviewer C for pointing out the time-stamping-attack.
REFERENCES
[1] E. Omara, B. Beurdouche, E. Rescorla, S. Inguva, A. Kwon, and
A. Duric, “The Messaging Layer Security (MLS) Architecture,” Internet
Engineering Task Force, Internet-Draft draft-ietf-mls-architecture-05,
Jul. 2020, work in Progress. [Online]. Available: https://datatracker.ietf.
org/doc/html/draft-ietf-mls-architecture-05 1, 2, 9
[2] the MLS-project, “Issue 50: Provide details about deniability.” [Online].
Available: https://github.com/mlswg/mls-architecture/issues/50 1
[3] D. Chaum and H. van Antwerpen, “Undeniable signatures,” in CRYPTO’
89, G. Brassard, Ed. New York, NY: Springer New York, 1990, pp.
212–216. 1
[4] H. Krawczyk and T. Rabin, “Chameleon hashing and signatures,” 1998,
https://eprint.iacr.org/1998/010. 1
[5] R. Canetti, C. Dwork, M. Naor, and R. Ostrovsky, “Deniable encryp-
tion,” in CRYPTO ’97, B. S. Kaliski, Ed. Berlin, Heidelberg: Springer
Berlin Heidelberg, 1997, pp. 90–104. 1
[6] N. Borisov, I. Goldberg, and E. Brewer, “Off-the-record communication,
or, why not to use pgp,” in 2004 ACM Workshop on Privacy in the
Electronic Society, ser. WPES ’04. New York, NY, USA: Association
for Computing Machinery, 2004, p. 77–84. 1
[7] N. Unger, S. Dechand, J. Bonneau, S. Fahl, H. Perl, I. Goldberg,
and M. Smith, “Sok: Secure messaging,” in 2015 IEEE Symposium on
Security and Privacy, 2015, pp. 232–249. 1, 5
[8] the OTRv4 team, “Off-the-record messaging protocol version 4 (draft),”
available at https://bugs.otr.im/otrv4/otrv4, commit 127793d9 from
28. 10. 2019. 1
[9] M. Marlinspike, “Advanced cryptographic ratcheting,” 2013, https://
signal.org/blog/advanced-ratcheting/. 1
[10] Y. Dodis, J. Katz, A. Smith, and S. Walﬁsh, “Composability and on-line
deniability of authentication,” in Theory of Cryptography, O. Reingold,
Ed. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009, pp. 146–162.
1, 2
[11] H. Liu, E. Y. Vasserman, and N. Hopper, “Improved group off-the-record
messaging,” in 12th ACM Workshop on Workshop on Privacy in the
Electronic Society, ser. WPES ’13. New York, NY, USA: Association
for Computing Machinery, 2013, p. 249–254. 1
[12] M. Schliep, E. Vasserman, and N. Hopper, “Consistent synchronous
group off-the-record messaging with sym-gotr,” PoPETs, vol. 2018,
no. 3, pp. 181 – 202, 01 Jun. 2018.
[Online]. Available: https:
//content.sciendo.com/view/journals/popets/2018/3/article-p181.xml 1
[13] M. Schliep and N. Hopper, “End-to-end secure mobile group messaging
with conversation integrity and deniability,” in 18th ACM Workshop on
Privacy in the Electronic Society, ser. WPES’19. New York, NY, USA:
Association for Computing Machinery, 2019, p. 55–73. 1
[14] M. Marlinspike, “Private group messaging,” 2014, https://signal.org/
blog/private-groups/. 1
for
[15] J. Bian, R. Seker, and U. Topaloglu, “Off-the-record instant messaging
for group conversation,” in 2007 IEEE International Conference on
Information Reuse and Integration, 2007, pp. 79–84. 1
[16] I. Goldberg, B. Ustao˘glu, M. D. Van Gundy, and H. Chen, “Multi-
party off-the-record messaging,” in 16th ACM Conference on Computer
and Communications Security, ser. CCS ’09. New York, NY, USA:
Association for Computing Machinery, 2009, p. 358–368. 1
[17] N. Unger and I. Goldberg, “Improved strongly deniable authenticated
secure messaging,” Proceedings on Privacy
key exchanges
Enhancing Technologies, vol. 2018, no. 1, pp. 21 – 66, 01 Jan.
2018.
[Online]. Available: https://content.sciendo.com/view/journals/
popets/2018/1/article-p21.xml 2
[18] P. R¨osler, C. Mainka, and J. Schwenk, “More is less: On the end-to-
end security of group chats in signal, whatsapp, and threema,” in 2018
IEEE European Symposium on Security and Privacy (EuroS P), 2018,
pp. 415–429, https://eprint.iacr.org/2017/713. 2, 3, 4
[19] R. Robert, “Re: [mls] deniability without pairwise channels.” on the
MLS mailing-list. [Online]. Available: https://mailarchive.ietf.org/arch/
msg/mls/JpqtnUj9uxbX9vgsuLCFcjpLDNU/ 2
[20] M. Specter, S. Park, and M. Green, “Keyforge: Mitigating email breaches
with forward-forgeable signatures,” Cryptology ePrint Archive, Report
2019/390, 2019, https://eprint.iacr.org/2019/390. 2
[21] M. Bellare and S. K. Miner, “A forward-secure digital signature scheme,”
in CRYPTO’ 99, M. Wiener, Ed. Berlin, Heidelberg: Springer Berlin
Heidelberg, 1999, pp. 431–448. 11
[22] J. Buchmann, E. Dahmen, and A. H¨ulsing, “Xmss - a practical forward
secure signature scheme based on minimal security assumptions,” in
Post-Quantum Cryptography, B.-Y. Yang, Ed.
Berlin, Heidelberg:
Springer Berlin Heidelberg, 2011, pp. 117–129. 11
[23] B. Schoenmakers, “Explicit optimal binary pebbling for one-way
hash chain reversal,” in Financial Cryptography and Data Security,
J. Grossklags and B. Preneel, Eds. Berlin, Heidelberg: Springer Berlin
Heidelberg, 2017, pp. 299–320. 11
[24] R. L. Rivest, A. Shamir, and D. A. Wagner, “Time-lock puzzles and
timed-release crypto,” 1996. 11, 15
[25] A. H¨ulsing, M. Kannwischer, and P. Schwabe, “Forward-secure XMSS
based on RFC 8391,” https://github.com/mkannwischer/xmssfs. 15
[26] N. Bitansky, S. Goldwasser, A. Jain, O. Paneth, V. Vaikuntanathan, and
B. Waters, “Time-lock puzzles from randomized encodings,” in 2016
ACM Conference on Innovations in Theoretical Computer Science, ser.
ITCS ’16. New York, NY, USA: Association for Computing Machinery,
2016, p. 345–356. 15
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:37 UTC from IEEE Xplore.  Restrictions apply. 
1690
APPENDIX
A. Performance Estimates
The runtime of Σ.gen essentially consists of the time to run
of four pebbling operations (two for key-evolution and two
for evolving the pseudorandom r values), one generation of
a timelock-puzzle, two calls to H, and one call to Σ.gen and
(cid:98)Σ.gen and preparing the pebbling-structures. Σ.evolve consists
(cid:98)Σ.sign, each. The computation of the later two is not necessary
Σ.sign, and Σ.verify of one call to(cid:98)Σ.verify and Σ.verify, each.
for fast-forwarding. Σ.sign roughly consists of one call to
To give a performance estimate we instantiate these primi-
tives as follows: We use 220 epochs, consisting of 5 minutes
each, resulting in a key-validity of 9.97 years. We use a
forward-secure implementation [25] of XMSS as described
in RFC 8391, speciﬁcally the XMSS-SHA2 20 256 variant,
as static signature scheme. We use the classical RSA-based
timelock-puzzle [24] with 2048 bit modulus and (to simplify
measurements) RSA-2048 bit signatures as dynamic signature
scheme. We assume the use of an optimal speed-1 pebbling
algorithm as well as the use of SHA256 as H. All of the
following measurements were performed on a Ryzen 3600 and