This corresponds to an increase of approximately 201%. Although
this overhead is significant, it is experienced only when the app is
compiled on the developer’s computer (it does not affect the user).
6 RELATED WORK
In this section we discuss relevant related work.
Android Permission System: Android system prior M uses ask-
on-install model to request permissions. Many research has shown
the ineffectiveness of this design and the need for better permission
management. First, few people would review the requests and even
fewer can correctly understand how permissions are mapped to
sensitive resources [15, 22, 26, 44]. The problem of apps routinely
abusing sensors has been highlighted in [36, 42].
Different techniques to help users manage permissions have been
proposed. Stowaway [14] can determine the set of API calls that an
app uses, and map those API calls to permissions towards detecting
privilege escalation. Ismail et al. [23] proposed using crowdsourcing
to find minimal sets of permissions for apps. Liu et al. [10] proposed
a personal assistant to help manage permissions. TaintDroid [12]
performs dynamic taint analysis to help user uncover cases of po-
tential permission misuse. Livshits et al. provides an automated
way of inserting prompts before sensitive API calls [28]. A field
study conducted by Wijesekera et al. [47] found that apps routinely
abuse permissions once they are granted and that users would like
greater control over sensitive information. Dynamic permissions
Session 18: AndroidASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea774At most one At least one
5 or less
5 or greater
49%
40%
Table 2: Permissions per functionality
51%
60%
(such as those in Android M and iOS) address some of the concerns
but permissions once granted, are rarely revoked in practice. The
study makes a case for finer grained, more intelligent permission
management than that with Android M.
Android M: Andriotis et al. [2] conducted a study on users’ adapta-
tion of Android M and found that in general, users greatly prefer the
new model to the old one. The results of the study further highlights
the need for developers to migrate their apps to the new permission
model. revDroid [13] empirically analyzes how often app crashes
can occur due to permission revocation, in off-the-shelf Android
applications targeting Android M. Their study highlighted the dan-
gers of not handling permission revocation correctly and as such,
Droid M+ builds on their results by making it easier for developers
to correctly manage dynamic permissions.
Annotations: Google [11] has developed a set of annotations for
permissions in Android but it is used only in code inspection tools
such as lint. APE [29] uses an annotation language and middleware
service that eases the development of energy-efficient Android apps.
In Java, AOP is used by frameworks like Spring [6] to provide
declarative enterprise services and to allow users to implement their
own custom aspects. In our work, we automatically annotate Android
code, to help developers adopt Android’s new permission model.
7 DISCUSSION
Automated Annotation Extraction: Currently, Droid M+ cannot
automatically generate the functionality, reason, and feedback
within the annotations as it requires automated reasoning about the
context. However, researchers have demonstrated that it is possible
to use natural language processing (NLP) over apps’ descriptions to
infer their functionalities [33]. Using NLP, we may also be able to
extract the context information directly from the target app. We plan
to explore this direction in the future.
Per-Functionality Permission: Although the new Android permis-
sion model is a big step forward from its old model, it is still not
ideal. Specifically, once a user grants a permission, the permission
will be shared across all the functionalities that will require this per-
mission. For example, when a user grants the Location permission
to a “map” app to find her current location, this permission can also
be used by third party libraries [48] and violate the user’s privacy.
A recent study [47] shows that for the “ask-on-first-use” strategy
Android M and iOS employ, the participants subsequent decisions on
whether to grant a permission would match their first decision, only
about half of the time (51.3 %). This observation is also intuitive; for
example, in the above example, while the user is willing to grant the
Location permission to the core functionality of the map app, she
may not want the advertisement library to know her current location.
To quantify the extent to which permissions are carried over
across functionalities, we analyzed the same 1638 apps that contain
revocable permissions (recall Section 3). Table 2 shows the results.
In particular, 51% of the apps share at least one permission across
multiple functionalities. For these apps, in 60% of the cases, the
permission is shared by up to 5 functionalities; in the remaining
cases, the permission is shared between 5 and 20 functionalities.
We discuss two further improvements that can address this prob-
lem. Under the constraint of the current Android M permission
model, one solution is to provide more education to the user with
aggregated explanation messages from multiple functionalities. This
solution will offer the best transparency about all possible uses of
any permissions. With Droid M+, we have in fact implemented this
solution and provided an example screenshot shown in Fig. 10. If a
user chooses to approve the permission use, he or she will be fully
aware that the permission is enabled in all functionalities. Of course,
the downside of such an approach is that it burdens the user with too
much information and puts the onus on her to revoke a permission
later to protect her privacy.
A better solution is to extend the ask-on-first-use strategy to work
on a triplet  instead of the pair
. This means that a permission is approved per
functionality. If the same permission is used in several functionalities,
a user can independently approve and deny a subset of the same. With
the help of Droid M+, an existing app can be easily ported to this new
per-functionality permission model as Droid M+ can already help
developers to identify and annotate the different functionalities of
their apps, identify the required permission(s) for each functionality,
and automatically generate the permission request code. To enforce
this fine-grained permission model though, we can either insert
additional code to maintain the per-functionality permission status,
or require proper support from the Android OS.
Unpredictable App Behaviors: Since Droid M+ introduces non-
trivial changes in the source code, a valid question is whether the
changes break the app in some way or induce unpredictable behav-
iors. Although we only present case studies of two apps, we tested
most apps in our data set to make sure that they worked as expected.
If requested permissions are always granted by the user, it is easy
to see why Droid M+ will not cause any change in app behavior.
It simply adds permission checks that if granted, will result in the
app executing as before. However, the denied execution branch is
more problematic as discussed in §4. Towards understanding the
logic relating to a denied permission, consider first how Android M
deals with apps that have not updated to the newest SDK. If an API
requires a permission that is withdrawn, the app will simply throw
an exception and most likely crash. Droid M+ helps resolve this by
inserting a check for needed permissions before their use and indi-
cating, using code comments, where the permission denied call-back
should be implemented (as can be seen in listing 2). Of course, the
developer still needs to fill the handler code for denied permissions.
We are not making this job any easier or difficult. By default, Droid
M+ displays an error message and exits if a permission is denied.
This is to prevent the app from entering any inconsistent or bad
state (e.g., as simply aborting the original execution flow will likely
cause). Alternatively, depending on the nature of the denied permis-
sions, we can generate more graceful handlers. Android APIs that
require permissions generally fall under two categories: (1) those
that return immediately with results (e.g., get the last location); (2)
those that register a callback (e.g., receiving location updates). For
(1), we can return randomized values so as to keep the program
running (a strategy that has been used in prior work [16]); for (2),
we can simply skip the registration of the callbacks because app de-
velopers cannot assume callbacks will always occur (e.g., at a given
Session 18: AndroidASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea775Figure 10: Any.do current version vs with Droid M+.
rate). This strategy is not likely to cause the program to malfunction.
However, there is no guarantee that the two strategies will not lead
to unexpected/unsafe program states.
Other issues: As discussed in § 3, the manual process of checking
whether permissions are legitimately asked upfront is subjective.
There are techniques that can be used to alleviate the subjectivity
(e.g.the crowdsourcing technique [27]). Further, there is almost no
work on understanding the privacy implications of normal permis-
sions as defined by google. We defer the study of these issues, which
we believe can supplement the utility of Droid M+, to future work.
8 CONCLUSIONS
Given criticisms on Android’s permission models, Google revamped
the model in Android 6.0. In this paper, we find via an in depth
measurement study that many apps from the Google Play store have
either not migrated to the new model, or do not follow Google’s
guidelines for adoption, effectively. We find some evidence that this
unsatisfying status quo could be due to the lack of tools that allow
developers to easily adopt the new model. Towards addressing this
shortfall, we design and implement Droid M+, a tool that helps
developers refactor their code to adopt the model. We show that
Droid M+ can help developers in evolving their legacy code to
adhere to Google’s guidelines, via case studies and general app
evaluations.
9 ACKNOWLEDGMENTS
This research was partially sponsored by the Army Research Labora-
tory and was accomplished under Cooperative Agreement Number
W911NF-13-2-0045 (ARL Cyber Security CRA). The views and
conclusions contained in this document are those of the authors and
should not be interpreted as representing the official policies, either
expressed or implied, of the Army Research Laboratory or the U.S.
Government. The U.S. Government is authorized to reproduce and
distribute reprints for Government purposes notwithstanding any
copyright notation here on. The work was also partially supported by
NSF Award 1617481. The authors would like to thank our shepherd
and the anonymous reviewers for their constructive feedback.
REFERENCES
[1] Y. Acar, M. Backes, S. Fahl, S. Garfinkel, D. Kim, M. Mazurek, and C. Stransky.
2017. Comparing the usability of cryptographic APIs. In IEEE S&P.
[2] P. Andriotis, M. Sasse, and G. Stringhini. 2016. Permissions snapshots: Assessing
users’ adaptation to the Android runtime permission model. In IEEE Workshop on
Information Forensics and Security (WIFS).
[3] Androguard. 2016. Tool to play with apk files. (2016). https://goo.gl/edcClw.
[4] Android. 2017. Android Share. (2017). https://goo.gl/9kiCgg.
[5] Any.do. 2016. To-do list, Task List. (2016). https://goo.gl/rPpZq8.
[6] AOP. [n. d.]. Aspect Oriented Programming. ([n. d.]). http://goo.gl/1UnkGS.
[7] Apktool. 2016. Reverse engineering apk files. (2016). https://goo.gl/JCh7U7.
[8] AskMD 2016. AskMD. (2016). https://goo.gl/3D5Vvw.
[9] K. Au, Y. Zhou, Z. Huang, and D. Lie. 2012. Pscout: analyzing the android
permission specification. In ACM CCS.
[10] B.Liu, M.S. Andersen, F.Schaub, H.Almuhimedi, S.Zhang, N.Sadeh, Y.Agarwal,
and A.Acquisti. 2016. Follow My Recommendations: A Personalized Privacy
Assistant for Mobile App Permissions. In ACM SOUPS.
http://goo.gl/qSE9dh.
[12] W. Enck, P. Gilbert, S. Han, V. Tendulkar, B. Chun, L. Cox, J. Jung, P. McDaniel,
and A Sheth. 2014. TaintDroid: an information-flow tracking system for realtime
privacy monitoring on smartphones. ACM Transactions on Computer Systems
(2014).
[13] Z. Fang, W. Han, D. Li, Z. Guo, D. Guo, X. Wang, Z. Qian, and H. Chen. 2016.
revDroid: Code Analysis of the Side Effects after Dynamic Permission Revocation
of Android Apps. In ACM ASIACCS.
[14] A. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner. 2011. Android permissions
demystified. In ACM CCS.
[11] Google Developers. 2016. Improving Code Inspection with Annotations. (2016).
[15] A. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, and D. Wagner. 2012. Android
permissions: User attention, comprehension, and behavior. In ACM SOUPS.
[16] Patrice Godefroid, Michael Y Levin, and David Molnar. 2012. SAGE: whitebox
fuzzing for security testing. Queue 10, 1 (2012), 20.
[17] Google. 2016. Material Design Patterns. (2016). https://goo.gl/QQcfEv.
[18] Google. 2016. Requesting Runtime Permissions. (2016). https://goo.gl/0enMi9.
[19] Google. 2016. Runtime Permissions Basic Sample. (2016). https://goo.gl/t59Dw9.
[20] Google. 2017. Google Play Store. (2017). https://goo.gl/kN0Nhz.
[21] Google. 2018. Play Store Top Charts. (2018). https://goo.gl/uPr4nj.
[22] A. Gorla, I. Tavecchia, F. Gross, and A. Zeller. 2014. Checking app behavior
against app descriptions. In ICSE.
[23] Q. Ismail, T. Ahmed, A. Kapadia, and M. Reiter. 2015. Crowdsourced exploration
of security configurations. In ACM CHI.
[24] Java 1.8 2016. Parser and Abstract Syntax Tree. (2016). https://goo.gl/qI1f34.
[25] J. Jung, S. Han, and D. Wetherall. 2012. Short paper: Enhancing mobile application
permissions with runtime feedback and constraints. In ACM workshop on Security
and privacy in smartphones and mobile devices.
[26] P. Kelley, S. Consolvo, L. Cranor, J. Jung, N. Sadeh, and D. Wetherall. 2012. A
conundrum of permissions: installing applications on an android smartphone. In
International Conference on Financial Cryptography and Data Security (FC).
[27] J. Lin, S. Amini, J. Hong, N. Sadeh, J. Lindqvist, and J. Zhang. 2012. Expectation
and purpose: understanding users’ mental models of mobile app privacy through
crowdsourcing. In ACM UBICOMP.
[28] B. Livshits and J. Jung. 2013. Automatic mediation of privacy-sensitive resource
access in smartphone applications. In USENIX Security.
[29] N. Nikzad, O. Chipara, and W. Griswold. 2014. APE: an annotation language and
middleware for energy-efficient mobile application development. In ICSE.
[30] H. Nissenbaum. 2004. Privacy as contextual integrity. Wash. L. Rev. (2004).
[31] K. Olmstead and M. Atkinson. 2015. Apps Permissions in the Google Play Store.
(2015). http://goo.gl/ph7KGk.
[32] Oracle. 2016. Java SE Annotations. (2016). http://goo.gl/g9b0Dh.
[33] R. Pandita, X. Xiao, W. Yang, W. Enck, and T. Xie. 2013. Whyper: Towards
automating risk assessment of mobile applications. In USENIX Security.
[34] Zhengyang Qu, Vaibhav Rastogi, Xinyi Zhang, Yan Chen, Tiantian Zhu, and
Zhong Chen. 2014. Autocog: Measuring the description-to-permission fidelity in
android applications. In Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security. ACM, 1354–1365.
[35] Ringdroid. 2016. Ringdroid. (2016). https://goo.gl/MhLqGW.
[36] R. Schlegel, K. Zhang, X. Zhou, M. Intwala, A. Kapadia, and X. Wang. 2011.
Soundcomber: A Stealthy and Context-Aware Sound Trojan for Smartphones.. In
NDSS.
[37] Y. Shao, J. Ott, Q.Chen, Z. Qian, and Z. M. Mao. 2016. Kratos: Discovering
Inconsistent Security Policy Enforcement in the Android Framework. In NDSS.
[38] Y. Smaragdakis, G. Balatsouras, G. Kastrinis, and M. Bravenboer. 2015. More
sound static handling of Java reflection. In Asian Symposium on Programming
Languages and Systems. Springer.
[39] Songily 2016. SONGily. (2016). https://goo.gl/fFWI1m.
[40] Soot 2016. Soot - A Java optimization framework. (2016). https://goo.gl/UsmKcC.
[41] J. Tan, K. Nguyen, M. Theodorides, H. Negr´on-Arroyo, C. Thompson, S. Egel-
man, and D. Wagner. 2014. The effect of developer-specified explanations for
permission requests on smartphone user behavior. In ACM CHI.
[42] Z. Templeman, R and. Rahman, D. Crandall, and A. Kapadia. 2012. PlaceRaider:
Virtual theft in physical spaces with smartphones. arXiv:1209.5982 (2012).
[43] TheScore 2016. theScore: Sports Scores. (2016). https://goo.gl/iefw9C.
[44] Christopher Thompson, Maritza Johnson, Serge Egelman, David Wagner, and
Jennifer King. 2013. When it’s better to ask forgiveness than get permission:
attribution mechanisms for smartphone resources. In ACM SOUPS.
[45] X. Wei, L. Gomez, I. Neamtiu, and M. Faloutsos. 2012. Permission evolution in
the android ecosystem. In ACSAC.
[46] WhatsApp 2016. WhatsApp Messenger. (2016). https://goo.gl/W1QcPv.
[47] P. Wijesekera, A. Baokar, A. Hosseini, S. Egelman, D. Wagner, and K. Beznosov.
2015. Android permissions remystified: A field study on contextual integrity. In
USENIX Security.
[48] W. Xu, F. Zhang, and S. Zhu. 2013. Permlyzer: Analyzing permission usage in
android applications. In IEEE Symposium on Software Reliability Engineering
(ISSRE).
Session 18: AndroidASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea776