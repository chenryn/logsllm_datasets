information ﬂow analysis of low level code”, in CCS,
2014.
[41] Q. H. Do, R. Bubel, and R. Hähnle, “Exploit generation
for information ﬂow leaks in object-oriented programs”,
in SEC, 2015.
[42] D. Milushev, W. Beck, and D. Clarke, “Noninterference
in Formal Techniques for
via symbolic execution”,
Distributed Systems, 2012.
[43] P. Subramanyan, S. Malik, H. Khattri, A. Maiti, and
J. M. Fung, “Verifying information ﬂow properties of
ﬁrmware using symbolic execution”, in DATE, 2016.
[44] N. Benton, “Simple relational correctness proofs for
static analyses and program transformations”, in POPL,
2004.
[45] G. Barthe, J. M. Crespo, and C. Kunz, “Relational
veriﬁcation using product programs”, in FM, 2011.
[46] T. H. Austin and C. Flanagan, “Multiple facets for
dynamic information ﬂow”, in POPL, 2012.
[47] M. Ngo, N. Bielova, C. Flanagan, T. Rezk, A. Russo,
and T. Schmitz, “A better facet of dynamic information
ﬂow control”, in WWW (Companion Volume), 2018.
[48] H. Palikareva, T. Kuchta, and C. Cadar, “Shadow of a
doubt: Testing for divergences between software ver-
sions”, in ICSE, 2016.
[49] G. P. Farina, S. Chong, and M. Gaboardi, “Relational
symbolic execution”, in PPDP, 2019.
[50] N. J. AlFardan and K. G. Paterson, “Lucky thirteen:
Breaking the TLS and DTLS record protocols”, in S&P,
2013.
[51] C. Cadar, D. Dunbar, and D. R. Engler, “KLEE: Unas-
sisted and Automatic Generation of High-Coverage
Tests for Complex Systems Programs.”, in OSDI, 2008.
[52] T. Avgerinos, D. Brumley, J. Davis, R. Goulden, T.
Nighswander, A. Rebert, and N. Williamson, “The
mayhem cyber reasoning system”, IEEE Security &
Privacy, vol. 16, no. 2, 2018.
[53] V. Chipounov, V. Kuznetsov, and G. Candea, “The S2E
implementation, and applications”,
platform: Design,
ACM Trans. Comput. Syst., vol. 30, no. 1, 2012.
[54] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens,
M. Polino, A. Dutcher, J. Grosen, S. Feng, C. Hauser,
C. Kruegel, and G. Vigna, “SOK: (State of) The Art
of War: Offensive Techniques in Binary Analysis”, in
S&P, 2016.
[55] R. David, S. Bardin, T. D. Ta, L. Mounier, J. Feist,
M. Potet, and J. Marion, “BINSEC/SE: A dynamic
symbolic execution toolkit for binary-level analysis”, in
SANER, 2016.
[56]
[57]
J. C. King, “Symbolic execution and program testing”,
Commun. ACM, vol. 19, no. 7, 1976.
J. Vanegue and S. Heelan, “SMT solvers in software
security”, in WOOT, 2012.
[58] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley,
“AEG: automatic exploit generation”, in NDSS, 2011.
[59] E. J. Schwartz, T. Avgerinos, and D. Brumley, “Q:
exploit hardening made easy”, in USENIX, 2011.
[60] B. Yadegari, B. Johannesmeyer, B. Whitely, and S. De-
bray, “A generic approach to automatic deobfuscation
of executable code”, in S&P, 2015.
[61] S. Bardin, R. David, and J. Marion, “Backward-bounded
targeting infeasibility questions on obfuscated
DSE:
codes”, in S&P, 2017.
J. Salwan, S. Bardin, and M. Potet, “Symbolic deobfus-
cation: From virtualized code back to the original”, in
DIMVA, 2018.
[62]
[63] C. Barrett, P. Fontaine, and C. Tinelli, “The SMT-
LIB Standard: Version 2.6”, Department of Computer
Science, The University of Iowa, Tech. Rep., 2017.
[64] FixedSizeBitVectors Theory, SMT-LIB. [Online]. Avail-
able: http : / / smtlib . cs . uiowa . edu / theories -
FixedSizeBitVectors.shtml (visited on 04/02/2019).
[65] ArraysEx Theory, SMT-LIB. [Online]. Available: http:
//smtlib.cs.uiowa.edu/theories-ArraysEx.shtml (visited
on 04/02/2019).
[66] B. Farinier, R. David, S. Bardin, and M. Lemerre, “Ar-
rays made simpler: An efﬁcient, scalable and thorough
preprocessing”, in LPAR, 2018.
[67] D. J. Bernstein, “Curve25519: New difﬁe-hellman speed
records”, in Public Key Cryptography, 2006.
[68] S. Bardin, P. Herrmann, J. Leroux, O. Ly, R. Tabary,
and A. Vincent, “The BINCOA framework for binary
code analysis”, in CAV, 2011.
[69] G. Barthe, B. Grégoire, and V. Laporte, “Secure com-
pilation of side-channel countermeasures: The case of
cryptographic "constant-time"”, in CSF, 2018.
[70] A. Niemetz, M. Preiner, and A. Biere, “Boolector 2.0
system description”, Journal on Satisﬁability, Boolean
Modeling and Computation, vol. 9, 2014.
[71] SMT-COMP. [Online]. Available: https : / / smt - comp .
[72]
github.io/2019/results.html (visited on 10/11/2019).
Imdea-software/verifying-constant-time.
[Online].
Available: https://github.com/imdea-software/verifying-
constant-time (visited on 10/13/2019).
[73] D. J. Wheeler and R. M. Needham, “Tea, a tiny
encryption algorithm”, in FSE, 1994.
[74] F. Recoules, S. Bardin, R. B. Bonichon, L. Mounier,
and M.-L. Potet, “Get rid of inline assembly through
veriﬁcation-oriented lifting”, in ASE, 2019.
[75] B. Farinier, S. Bardin, R. Bonichon, and M. Potet,
“Model generation for quantiﬁed formulas: A taint-
based approach”, in CAV (2), 2018.
[76] R. David, S. Bardin, J. Feist, L. Mounier, M. Potet,
T. D. Ta, and J. Marion, “Speciﬁcation of concretization
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:43 UTC from IEEE Xplore.  Restrictions apply. 
1035
and symbolization policies in symbolic execution”, in
ISSTA, 2016.
[77] M. Jung, S. Kim, H. Han, J. Choi, and S. K. Cha, “B2r2:
Building an efﬁcient front-end for binary analysis”, in
The BAR Workshop, Internet Society, 2019.
[78] C. Cadar and H. Palikareva, “Shadow symbolic execu-
tion for better testing of evolving software”, in ICSE,
2014.
J. Agat, “Transforming out timing leaks”, in POPL,
2000.
[79]
[80] D. Molnar, M. Piotrowski, D. Schultz, and D. A. Wag-
ner, “The program counter security model: Automatic
detection and removal of control-ﬂow side channel
attacks”, in ICISC, 2005.
[81] B. Rodrigues, F. M. Q. Pereira, and D. F. Aranha,
“Sparse representation of implicit ﬂows with applica-
tions to side-channel detection”, in CC, 2016.
[82] S. Chattopadhyay and A. Roychoudhury, “Symbolic
IEEE
veriﬁcation of cache side-channel
Trans. on CAD of Integrated Circuits and Systems,
vol. 37, no. 11, 2018.
freedom”,
[83] M. Wu, S. Guo, P. Schaumont, and C. Wang, “Elimi-
nating timing side-channel leaks using program repair”,
in ISSTA, 2018.
[84] O. Reparaz, J. Balasch, and I. Verbauwhede, “Dude, is
my code constant time?”, in DATE, 2017.
APPENDIX
A. Symbolic Evaluation - Full Set of Rules
The full set of rules for the symbolic evaluation is reported
in Figure 7.
B. Proofs
Let ck and c(cid:48)
1) Sketch of Proof of Relative Completeness of RelSE
(Theorem 1): The proof is similar to proofs of completeness
in standard symbolic execution, but have to be adapted to
the framework of relational symbolic execution, considering
pairs of concrete executions. We can prove inductively that
the semantics is preserved from a pair of concrete executions
to the symbolic execution.
k be concrete conﬁgurations and sk a symbolic
conﬁguration for which the inductive hypothesis holds, i.e
s0 (cid:32)k sk ∧ ck
∼∼∼l sk ∧ c(cid:48)
k
∼∼∼r sk
t
k+1
∼∼∼l sk+1 ∧ c(cid:48)
∼∼∼r sk+1 holds.
ck+1 and ck −→
t(cid:48)
For each concrete steps ck −→
ck+1
such that t = t(cid:48), we need to show that we can perform
a step in the symbolic execution sk → sk+1 and that
ck+1
The symbolic execution do not get stuck unless an insecurity
is satisﬁable. Hence, follows from t = t(cid:48) that there exists a
symbolic conﬁguration sk+1 such that sk (cid:32) sk+1. Now, we
need to show that ck+1
∼∼∼r sk, we
can prove for each symbolic rule that the relation is preserved
at the next step.
∼∼∼l sk+1 ∧ c(cid:48)
Given the induction hypothesis ck
∼∼∼r sk+1 holds.
∼∼∼l sk ∧ c(cid:48)
k+1
k
Expr
BINOP
LOAD
Instr
D_JUMP
(cid:94) (cid:44) (cid:104)select(µ
ϕ
(cid:94)
(cid:94)
(cid:94)
secLeak (φ
)
P.l = goto e
(cid:94)
|l = ϕ
|r)
(cid:94) (cid:44) φ
ϕ
(cid:94) (cid:5)b ψ
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
|l, φ
|r, φ
UNOP
|r)(cid:105)
S_JUMP
ue (cid:96) ϕ
CST (cid:0)ρ, µ
, π(cid:1)
∃ M (cid:15) π(cid:48)
l(cid:48) (cid:44) M (ϕ
(cid:94) (cid:44) (cid:5)u φ
ϕ
|l)| select(µ
P.l = goto l(cid:48)
VAR (cid:0)ρ, µ
π(cid:48) (cid:44) π ∧ (ϕ
(cid:94)
secLeak (ϕ
)
(cid:94)(cid:1) v (cid:96) ρ v
(cid:94)(cid:1) bv (cid:96) (cid:104)bv(cid:105)
(cid:94)(cid:1) e (cid:96) φ
(cid:0)ρ, µ
(cid:0)ρ, µ
(cid:94)(cid:1)
(cid:0)ρ, µ
(cid:94)(cid:1) e1 (cid:96) φ
(cid:0)ρ, µ
(cid:94)(cid:1) e2 (cid:96) ψ
(cid:0)ρ, µ
(cid:94)(cid:1) e1 be2 (cid:96) ϕ
(cid:0)ρ, µ
(cid:94)(cid:1) e (cid:96) φ
(cid:0)ρ, µ
(cid:94)(cid:1) @e (cid:96) ϕ
, π(cid:1) (cid:32)(cid:0)l(cid:48), ρ, µ
(cid:0)l, ρ, µ
(cid:0)ρ, µ
(cid:94)(cid:1) e (cid:96) ϕ
, π(cid:48)(cid:1)
, π(cid:1) (cid:32)(cid:0)l(cid:48), ρ, µ
(cid:0)l, ρ, µ
(cid:0)ρ, µ
(cid:94)(cid:1) e (cid:96) ϕ
, π(cid:48)(cid:1)
, π(cid:1) (cid:32)(cid:0)l(cid:48), ρ, µ
(cid:0)ρ, µ
(cid:94)(cid:1) e (cid:96) ϕ
, π(cid:1) (cid:32)(cid:0)l(cid:48), ρ, µ
, π(cid:48)(cid:1)
(cid:0)ρ, µ
(cid:94)(cid:1) e (cid:96) ϕ
, π(cid:48)(cid:1)
, π(cid:1) (cid:32)(cid:0)l + 1, ρ(cid:48), µ
(cid:0)l, ρ, µ
(cid:0)ρ, µ
(cid:94)(cid:1) e (cid:96) ϕ
, π(cid:48)(cid:1)
l(cid:48) = l + 1
|l, φ
|l, ϕ
(cid:94)(cid:48)
|l) ∧ µ
(cid:94)
secLeak (ϕ
)
(cid:94)(cid:48)
(cid:0)l, ρ, µ
(cid:0)l, ρ, µ
, π(cid:1) (cid:32)(cid:0)l(cid:48), ρ, µ
(cid:94)(cid:48) (cid:44) (cid:104)store(µ
µ
|l, φ
|l)| store(µ
|r = store(µ
(cid:0)l, ρ, µ
(cid:94)(cid:48)
π(cid:48) (cid:44) π ∧ (ϕ
l(cid:48) (cid:44) lf alse
(cid:94)
secLeak (ϕ
)
(cid:94)
secLeak (ϕ
)
l(cid:48) (cid:44) ltrue
|l = store(µ
|l = ϕ
(cid:15) π(cid:48)
(cid:15) π(cid:48)
|l, ϕ
|r)
|r)
|l)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)
(cid:94)(cid:48) (cid:44) canonical (ϕ
(cid:94)
)
ϕ
|r)
|r = ϕ
(cid:94)(cid:48)
|l) ∧ (ϕ
(cid:94)
(cid:94)
(cid:94)
|r, ϕ
|r, ϕ
|r, φ
|r, φ
(cid:94)
(cid:94)
(cid:94)
|r)(cid:105)
|r)
ITE-TRUE
P.l = ite e ? ltrue: lf alse
|l = ϕ