mation and Networks. 263–269.
[35] Bruce Ndibanje, Ki Hwan Kim, Young Jin Kang, Hyun Ho Kim, Tae Yong Kim,
and Hoon Jae Lee. 2019. Cross-Method-Based Analysis and Classification of
Malicious Behavior by API Calls Extraction. Applied Sciences 9, 2 (2019), 239.
[36] Razvan Pascanu, Jack W Stokes, Hermineh Sanossian, Mady Marinescu, and Anil
Thomas. 2015. Malware classification with recurrent networks. In 2015 IEEE
International Conference on Acoustics, Speech and Signal Processing (ICASSP). IEEE,
1916–1920.
[37] Abdurrahman Pektaş and Tankut Acarman. 2017. Classification of malware fam-
ilies based on runtime behaviors. Journal of information security and applications
37 (2017), 91–100.
[38] Abdurrahman Pektaş and Tankut Acarman. 2017. Malware classification based on
API calls and behaviour analysis. IET Information Security 12, 2 (2017), 107–117.
[39] Radu S Pirscoveanu, Steven S Hansen, Thor MT Larsen, Matija Stevanovic,
Jens Myrup Pedersen, and Alexandre Czech. 2015. Analysis of malware behavior:
Type classification using machine learning. In 2015 International conference on
cyber situational awareness, data analytics and assessment (CyberSA). IEEE, 1–7.
[40] Yong Qiao, Yuexiang Yang, Lin Ji, and Jie He. 2013. Analyzing malware by abstract-
ing the frequent itemsets in API call sequences. In 2013 12th IEEE International
Conference on Trust, Security and Privacy in Computing and Communications.
IEEE, 265–270.
[41] Chandrasekar Ravi and R Manoharan. 2012. Malware detection using windows api
sequence and machine learning. International Journal of Computer Applications
43, 17 (2012), 12–16.
[42] Konrad Rieck, Philipp Trinius, Carsten Willems, and Thorsten Holz. 2011. Auto-
matic analysis of malware behavior using machine learning. Journal of Computer
Security 19, 4 (2011), 639–668.
[43] Zahra Salehi, Mahboobeh Ghiasi, and Ashkan Sami. 2012. A miner for malware
detection based on API function calls and their arguments. In The 16th CSI
international symposium on artificial intelligence and signal processing (AISP 2012).
IEEE, 563–568.
[44] Zahra Salehi, Ashkan Sami, and Mahboobe Ghiasi. 2017. MAAR: Robust features
to detect malicious activity based on API calls, their arguments and return values.
Engineering Applications of Artificial Intelligence 59 (2017), 93–102.
[45] Ashkan Sami, Babak Yadegari, Hossein Rahimi, Naser Peiravian, Sattar Hashemi,
and Ali Hamze. 2010. Malware detection based on mining API calls. In Proceedings
of the 2010 ACM symposium on applied computing. ACM, 1020–1025.
[46] Cuckoo Sandbox. [n.d.]. Hooked APIs and Categories in Cuckoo. ([n. d.]). https:
//github.com/cuckoosandbox/cuckoo/wiki/Hooked-APIs-and-Categories/.
[47] Igor Santos, Felix Brezo, Javier Nieves, Yoseba K Penya, Borja Sanz, Carlos Laor-
den, and Pablo G Bringas. 2010. Idea: Opcode-sequence-based malware detection.
In International Symposium on Engineering Secure Software and Systems. Springer,
35–43.
[48] Marcos Sebastián, Richard Rivera, Platon Kotzias, and Juan Caballero. 2016. Av-
class: A tool for massive malware labeling. In International Symposium on Research
in Attacks, Intrusions, and Defenses. Springer, 230–253.
[49] SensorsTechForum. [n.d.]. Most Popular Windows File Types Used by Malware
(2018). ([n. d.]). https://sensorstechforum.com/popular-windows-file-types-
used-malware-2018/.
[50] FileHippo s.r.o. [n.d.]. File Hippo.
([n. d.]). https://filehippo.com/software/
[51] Ronghua Tian, Rafiqul Islam, Lynn Batten, and Steve Versteeg. 2010. Differentiat-
ing malware from cleanware using behavioural analysis. In 2010 5th international
conference on malicious and unwanted software. IEEE, 23–30.
[52] Dolly Uppal, Rakhi Sinha, Vishakha Mehra, and Vinesh Jain. 2014. Malware
detection and classification based on extraction of API sequences. In 2014 Inter-
national Conference on Advances in Computing, Communications and Informatics
(ICACCI). IEEE, 2337–2342.
[53] Hashing Vectorizer. [n.d.].
Scikit-learn Machine Learning in Python.
([n. d.]).
https://scikit-learn.org/stable/modules/generated/sklearn.feature_
extraction.text.HashingVectorizer.html.
[54] R Veeramani and Nitin Rai. 2012. Windows api based malware detection and
framework analysis. In International conference on networks and cyber security,
Vol. 25.
[55] Eunjin Kim Youngjoon Ki and Huy Kang Kim. [n.d.]. APIMDS-dataset. ([n. d.]).
http://ocslab.hksecurity.net/apimds-dataset.
[56] Zhaoqi Zhang, Panpan Qi, and Wei Wang. 2019. Dynamic Malware Analysis
with Feature Engineering and Feature Learning. arXiv preprint arXiv:1907.07352
(2019).
desktop.
65Advanced Windows Methods on Malware Detection and Classification
ACSAC 2020, December 7–11, 2020, Austin, USA
A PSEUDOCODE OF DYNAMIC FEATURE
EXTRACTION
Algorithm 1 Feature vector generation
1: ∆: Dataset of malware and benign behavior analysis reports [fi ]
2: processed_api_arg: List of the generalized API calls and arguments
Given: common_malware_types, common_registry_keywords and ∆
Results:
(1) Feature vector of Method 1 [Feature_VectorM1], and
Method 2 [Feature_VectorM2]
3: processed_api_arg = {}
4: foreach fi ∈ ∆ do
Process the log file and extract its list of API calls (AP Ii j ) and argu-
5:
ments (ARGi jk )
Remove the suffix from the API name [’ExW’, ’ExA’, ’W’, ’A’, ’Ex’]
in AP Ii j ∈ fi
foreach ARGi jk ∈ AP Ii j do
6:
common malware file
types
exists
in
switch (ARGi jk )
Check if
the
command_line
case command_line:
Call Algorithm 4
Call Algorithm 3
case ’path’ or ’directory’:
Call Algorithm 5
Check if the regkey value is one of the common regkey for mal-
ware
case ’regkey’:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
Remaining arguments with integer values, convert them into
bin-based tags
case IsNumber(ARGi jk ):
Remaining arguments with concrete values will not be changed
else:
Call Algorithm 2
processed_api_arg[ARGi jk ] = value(ARGi jk )
end switch
end foreach
Features are constructed using Method 1 and Method 2 formulas
M1processed_api_arg = Method1(processed_api_arg)
M2processed_api_arg = Method2(processed_api_arg)
Generate Method 1 and Method 2 feature vectors from the pro-
cessed_api_arg using HashingVectorizer function
Feature_VectorM1 = HashingVectorizer(M1processed_api_arg)
Feature_VectorM2 = HashingVectorizer(M2processed_api_arg)
29:
30:
31: end foreach
32: return Feature_VectorM1, Feature_VectorM2
Algorithm 2 Logarithmic bin converter
Given: ARGi jk is an argument with integer type
1: X = value(ARGi jk )
2: prefix = ’ ’
3: if value(X < 0 then
prefix = ’neg_’
4:
5: else if X = 0 then
6:
7: else
8:
9: end if
10: return processed_api_arg[X] = prefix + tag
tag = ’numB’+ X
tag = ’num0’
if common_key = value(ARGijk) then
Algorithm 3 Registry key (common_key) extraction
Given: ARGijk is an argument
1: registry_tag = {}
2: foreach common_key in common_registry_keywords do
3:
4:
5:
6:
7:
8: end foreach
9: return processed_api_arg[ARGijk] = registry_tag
registry_tag = common_key
registry_tag = other_reg
end if
else
if file_type = value(ARGijk) then
Algorithm 4 Command line (CMD) extraction
1: CMD commonly appears in CreateProcessInternal
Given: ARGijk is an argument
2: c_l_tag = {}
3: foreach file_type in common_malware_types do
4:
5:
6:
7:
8:
9:
10: end foreach
11: return processed_api_arg[ARGijk] = c_l_tag
if not exists, return other_CL
c_l_tag = other_CL
c_l_tag = file_type
end if
else
loc = ’sys_dir’
Algorithm 5 Directory and path extraction
Given: ARGijk is an argument
1: if value(ARGijk) = ’System32’ then
2:
3: else
4:
5: end if
6: return processed_api_arg[ARGijk] = loc
loc = ’other_dir’
B DESCRIPTION OF USED MACHINE
LEARNING ALGORITHMS
A description of each machine learning classifier is shown below:
• Support Vector Machine (SVM): uses a technique called the
kernel trick to transform the data (N-dimensional space
where N is the number of features ). Based on these trans-
formations, it finds an optimal boundary (hyperplance) be-
tween the possible outputs that distinctly classifies the data
points [31].
• Decision Tree (DT): uses a tree-like diagram in which each
internal node represents a test on a feature. It classifies the
features by sorting them down the tree from the root to
some leaf node where each leaf node represents a class label,
and branches represent conjunctions of features that lead
to those class labels. The paths from the root to the leaf
represent classification rules [31].
• Random Forest (RF): consists of a large number of sepa-
rate decision trees (DTs) that serve as an ensemble. Each
66ACSAC 2020, December 7–11, 2020, Austin, USA
Dima Rabadi and Sin G. Teo
Table 6: A description of the malware types (forms) [28] used
in this paper.
Malware Type
Trojan
Adware
Spyware
Ransomware
Virus
Worm
PUP
Backdoor
Riskware
Others
Figure 5: Comparison of our proposed methods with the
baseline work [44], and [51] which uses only API names
without arguments, in terms of recall scores over different
threshold values.
tree in the random forest represents a class prediction. The
class with the most votes in general becomes the concluding
model’s prediction [31].
• eXtreme Gradient Boosting (XGBoost): employs a decision-
tree-based ensemble machine learning algorithm that uses
a gradient boosting framework by combining a set of weak
learners and making conclusions about the various feature
importance and parameters [9]. Then it uses those conclu-
sions to create new, more reliable models for regression and
classification problems.
• Passive-Aggressive (PA): from its name, Passive means keep
the model if the prediction is correct, and Aggressive means
update the model to adjust to the misclassified instances if the
prediction is incorrect. Consequently, it changes its classifier
weight vector (update the classifier) for each misclassified
case it receives, trying to correct it. Usually, it is used for
classifying massive streams of data [12].
C MALWARE TYPES DESCRIPTION
A description of each malware type used in this paper is shown in
Table 6.
D EVALUATION IN TERMS OF RECALL
Table 5 shows the performance comparison between our proposed
methods against the six works from the state-of-the-art in terms
of the F1 scores. This section presents the comparison based on
another performance metric, recall, to evaluate the performance
of our proposed methods against the state-of-the-art in terms of
correctly classifying the malicious samples as malware. As shown
in Table 5, [44] gives the highest F1 score among the six works.
Thus, we use it as a baseline in our recall comparison experiments.
Description
It hides as legitimate software and rep-
resents itself as something useful to
deceive users into installing and down-
loading malware on their systems
It displays advertisements on the
user’s interface or screen automati-
cally and usually within a web browser
It secretly spies and gathers sensitive
information without the user’s permis-
sion and reports it to the spyware’s
author
It limits the access to the user’s system
by locking down the whole system or
encrypting the files and then demand-
ing to pay a ransom to get the files or
system back and for its release
It replicates itself from device to device
by modifying other device programs
and poisoning them with its code
It spreads to other devices and usu-
ally causes harm by destroying files
and data. However, unlike a virus, it
has the ability of self-replicating and
spreading itself independently with-
out any need for human help
Potentially Unwanted Program: from
the name, it is an unwanted program
(e.g., advertising, toolbars, and pop-
ups) that usually comes bundled with
other irrelevant and legitimate soft-
ware that has been downloaded by the
user
It bypasses the user’s system security
measurements and tries to gain a high-
level privilege such as root access to
install itself on a computer and thus
allows the attacker to access it. Back-
door is generally classified as a Trojan
A program that is not designed to be
strictly malicious but puts the user at
risk in some way when it is used with
bad intentions, as it has functions that
can be used for malicious purposes
(i.e., stealing data, causing disruptions
or hijacking)
Hack Tool A special kind of Riskware program
that is designed to hack into comput-
ers and networks
0.10.20.30.40.50.60.70.80.9Threshold0.900.920.940.960.981.00Recallbaseline using Method 1 featuresbaseline using Method 2 featuresonly API names without argumentsMethod 1Method 267Advanced Windows Methods on Malware Detection and Classification
ACSAC 2020, December 7–11, 2020, Austin, USA
Moreover, to compare our work with other works that use different
feature selection methods such as neglecting the API arguments and
relying only on the API calls, we compare our methods with [51].
Figure 5 shows the comparison results of our proposed methods
with the baseline work [44], and [51] which uses only API names
without arguments, in terms of recall scores over different threshold
values. As shown in the figure, for malware detection, our methods
outperform the methods of the previous work [44, 51], where using
our methods, fewer malware samples are misclassified as benign
compared to their works.
68