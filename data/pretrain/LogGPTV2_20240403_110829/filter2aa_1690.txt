Fuzzing AOSP 
for non-crash bugs
Elphet & Guang Gong
@360 Alpha Team
About us
●Elphet
○Security Researcher (Intern) of 360 Alpha Team 
○Focus on Android system and application security
●Guang Gong 
○Senior Security Researcher and Team Leader of 360 Alpha Team 
○Focus on Android/Chrome 
Introduction
• Fuzzers catch memory corruption bugs via crashes.
○When a bug doesn’t result in a crash, then it will be ignored. 
• Memory debugging tool also known as a runtime debugger is a 
tool for finding software memory problem during runtime.
○They increase the crash rate of a program by reporting errors positively. 
(e.g. ASAN, MSAN, TSAN)
• Some kinds of bugs cannot be uncovered even with the help of
sanitizers.
○ e.g. Intra-object-overflow
○ We built a tool based on LLVM to help our fuzzers find ~30 
vulnerabilities in AOSP
Agenda
●Fuzzers and Sanitizers
●Intra-object-overflow Bugs
●LLVM and IOODetector
●Case study
●Related Work and Discussion
Fuzzers and Sanitizers
●Fuzzing is proved to be an effective way to find memory 
corruption bugs. 
●A general workflow of a fuzzer
Seed 
selector
Mutator/
Generator
Target 
Program
Monitor/
Filter
Init
seed corpus
Report 
crash
Discarded boring 
test cases 
Interesting 
testcases
Real 
Vulnerabilities
Fuzzers
●Crash is a necessary signal for identifying a vulnerability in general 
purpose fuzzers
Seed 
selector
Mutator/
Generator
Target 
Program
Monitor
/
Filter
Init
seed corpus
Report 
crash
Discarded 
boring test cases 
Interesting 
testcases
Real 
Vulnerabilities
Crash handlers in popular fuzzers
Crash handler in AFL
Crash handler in 
honggFuzz
Crash handler in 
libFuzzer
Memory debugging tools (Sanitizers）
●Address Sanitizer 
●Use after free
●Heap Buffer overflow
●Stack Buffer overflow
●Global buffer overflow
●Use after return 
●Use after scope
●Initialization order bugs
• Leak Sanitizer
●Memory leaks
• Memory Sanitizer
• use of uninitialized memory
• Thread Sanitizer
• Data races and dead locks
• Undefined Behavior Sanitizer
• ……
Address Sanitizer Founded Bugs
●Sanitizers help fuzzers find more bugs by raise interesting signals 
in the program
●It founds many bugs in open source projects
Algorithm of ASAN
●Core part: Shadow memory and poisoned red zone
Red 
zone1
mem1
Red 
zone2
Mem2
Red 
zone3
●Heap buffer overflow check
●Stack buffer overflow check
After
Instrumenta
tion
Before
Instrumenta
tion
Bugs that ASAN cannot detect
●Overflow an inner field in an object 
Red zone1
mem1
Red 
zone2
Mem2
Red zone3
int size
byte 
data[4]
int size2
……
struct s1{
int size;
uint8_t data[4];
int size2;
}obj;
obj.data[5] = input();
●Overflow a buffer with a large array index 
Red 
zone1
byte 
data[4]
Red 
zone2
Mem2
Red 
zone3
index = 4 + sizeof(redzone2);
data[index] = input();
Intra Object Overflow
intra-object-overflow
other_field overwriten
large index integer overflow
Access red zone
Report an error
Intra Object Overflow Detector
Manually?
Manually sanitize the index to 
avoid buffer overflow after 
reviewing the project
A lot of boring work. Some 
bugs would be missed.
Intra Object Overflow Detector
Automatically?
• Static Analysis
• LLVM Passes
• Data Flow Analysis
• Dynamic Analysis
• LLVM Instrumentation
• Data Flow tracing
• Fuzzing
IOODetector
LLVM
• Clang Frontend translate source 
code into IR
• LLVM optimizer performs a 
sequence of optimization on IR
• Backend then translate the 
optimized IR into machine code
• We can customize our own 
LLVM passes on the IR
LLVM IR
LLVM IR
LLVM IR GEP
The ‘getelementptr’ instruction is used to get the address of a subelement of an 
aggregate data structure. It performs address calculation only and does not access 
memory.
arg1: a type used as the basis for the calculations
arg2: a pointer or a vector of pointers, and is the base address to start from
arg3..n : indices that indicate which of the elements of the aggregate object are 
indexed
LLVM IR GEP Instruction API
• getSourceElementType()
• getResultElementType()
• getNumIndices()
• hasIndices()
• Indices()
• getPointerOperand()
• getPointerOperandType()
• getOperand()
• ……
With all these 
convenient APIs, we 
can do whatever we 
want
IOODetector simplest solution
• A check function call will 
be inserted before every 
GEP instruction whose 
source Type is an array
• Detector sanitize two 
things
• index  0
GetSourceElementType
srcType
isArrayTy
GEP
hasIndicies
size=src->getNumElements
insertCheckBeforeGEP
END
visitGetElementPtrInst
IOODetector’s simplest solution
• Checking Results:
IOODetector’s simplest solution
• Checking Results:
However, it’s not enough
GEP without numOfElements
1. SourceType is not 
ArrayType. 
2. Array NumElement
is missing
Store and Load Instructions(Memory Access)
The real memory access 
behavior happens in 
load&store instruction.
Checking on GEP 
instruction will result in 
false positive
Store and Load Instructions(Pointer Ref && Deref)
Load and Store instructions
are also used to propagate
tainted nodes.
If the src of
StoreInst/loadInst is tainted
callInst and retInst
Tainted Value
propagating to/from
function call
IOODetector’s Solution
• Step1: Find all explicit GEP instructions. Allocate a tag for them.
• new_node( int unique_tag, int current_index, int number_element);
• Step2: Traverse its user list
• propagate( int src_tag, int uniq_dest_tag, int offset )
• check(int tag)
• Step3: Recursively traverse the user list of its user
• propagate( int src_tag, int uniq_dest_tag, int offset )
• check(int tag)
IOODetector’s Solution
• Taint Source
• GEP Instruction
• %arrayidx14.i = getelementptr inbounds [16 x i32], [16 x i32]* %16, i32 0, i32 0
• Taint Propagation
• GEP Instruction
• %arrayidx23.i = getelementptr inbounds i32, i32* %279, i32 8
• Load && Restore Instruction
• store i32* %2, i32** %1, align 8
• %3 = load i32*, i32** %1, align 8
• Call && Return Instruction
• %33 = call i32 @func(i8* %31, i32 %32)
• ret i32* %25
• Check Point
• Load & Store Instruction
• %37 = load i32, i32* %3, align 4
• store i32 %24, i32* %4, align 4
Detection Result
Detection Result
All the three examples 
are
Successfully Detected
Other Challenges and Solutions
• Recursion -> Tags in the the same function are constants
• fun_a->fun_b->fun_a
• Solution: we introduce node->call_layer field to simulate the call stack.
• For efficiency: only instrumented functions will be record.
• Multiple modules in a big project
• Global Tag Generator:
• Unique tags are required in every module
• Consistent tags for the same function are required
Find real target project in AOSP
●Code pattern of Intra object buffer in C
●Search [ in .h files for a coarse result
●Or 
●Search with regular expression in the whole AOSP
libxaac, the treasure
• libxaac is a new OMX component introduced in Android P
• XAAC stands for xHE-AAC (Extended High Efficiency Advanced 
Audio Coding)
• Bit rate as low as 6kbps for mono and 12kbps for stereo when 
network is congested. Request a higher bit rate version and 
seamlessly switch over once more bandwidth available
• “Adding xHE-AAC to our patent pool ensures that broadcasters 
and service providers can deliver the next generation of audio to 
consumers efficiently and affordably.”
• libxaac in Android is the first implementation of xHE-AAC
libxaac, the treasure
• Memory Management in libxaac
●libxaac itself doesn’t allocate or 
deallocate any buffers. It provides a 
GET_SIZE_API. API caller is responsible 
for memory management
●Big chunks are allocated for efficiency. 
~64MB
●Sort of anti-fuzzing or anti-crash. 
Unfriendly to Fuzzer+ASAN
• Lots of intra-object arrays in the allocated 
big chunks
libxaac – configuration and decoding
Two attack Surfaces
configuration
decoding
Both the functions receive a  
buffer as input
Both the two attack surfaces 
uses two different big data 
structures with lots of intra 
object buffers
Fuzzing libxaac
●Two fuzzers for libxaac – lots of crashes raised by IOODetector
● configfuzzer
●Testing the configuration process of libxaac
●We also use this fuzzer to generate `good config bufs` for decoding stage. (After a 
config-buf is processed, if the err_code is OK, then the buf is considered as a `good 
config-buf`)
●1000+ good config bufs were generated in 1 week
● decodefuzzer
●The second stage of decoding an audio stream. a) choose a random gcb  b) feed 
gcb to configxaacdecoder. c) generate test cases for decodexaacstream interface 
Vulnerabilities found in AOSP
Confirmed bugs
• CVE-2018-9569, CVE-2018-9570, CVE-2018-9571, CVE-2018-9572, CVE-2018-9573, 
CVE-2018-9574, CVE-2018-9575, CVE-2018-9576, CVE-2018-9577, CVE-2019-2063, 
CVE-2019-2064, CVE-2019-2065, CVE-2019-2066, CVE-2019-2067, CVE-2019-2068, 
CVE-2019-2069, CVE-2019-2070, CVE-2019-2071, CVE-2019-2072, CVE-2019-2073, 
CVE-2019-2074, CVE-2019-2075, CVE-2019-2076, CVE-2019-2077, CVE-2019-2078, 
CVE-2019-2079, CVE-2019-2086.
Duplicated issues
• AndroidID-119054381, AndroidID-119054381, AndroidID-117992588 , AndroidID-
117789761, AndroidID-117789797, AndroidID-116772652, AndroidID-116746433, 
AndroidID-117079549, AndroidID-117064603, AndroidID-117105233, AndroidID-
117204086, AndroidID-115919654 ……
And some other issues…
Case1 CVE-2019-2065
str_node is a pointer that 
points to a field of 
ia_spline_nodes_struct
impd_read_bits_buf is 
controllable, k could be 
larger than 256 when 
end_marker never meet
out-of-bounds write 
here
str_node lies in the 
deep layer of multiple 
nested structures
Case2 CVE-2018-9575
Impd_read_bits_buf is 
controllable. 
temp:[0..0xff]
DOWNMIX_INSTRUCTI
ON_COUNT_MAX is 16
dwnmix_instructions_co
unt’s range is [0..0x7f]
dwnmix_instructions[] out-
out-of-bounds access
Case2 CVE-2018-9575
Write controllable values 
out-of-bounds
Case3 CVE-2019-2064
Number of elements in array 
str_filter_element is 
FILTER_ELEMENT_COUNT_MAX(16)
Filter_element_count is controllable, its range 
is [0..63]
str_filter_elements is a temp pointer pointed 
to the start address of member array 
str_filter_element
The for-loop goes through at most 64 cycles, 
which is larger than 
FILTER_ELEMENT_COUNT_MAX(16)
Pointer str_filter_elements will point to the 
next element in this array
Many possible oobw issues
False positive and performance
●Strange accessing approaches will result in false positive
mem1
byte predata[5]
byte data[4]
int size2
……
ptr
*(int*)(ptr+NUM_DATA)
IOODetector will be 
sensitive and report an 
error
*(int*)(ptr-NUM_PREDATA)
●The overhead of IOODetector is about ~2.6x after we optimize our code 
to instrument as less code as possible
Further stories
The library has been marked as experimental and is no longer 
included in any production Android builds since Nov. 2018
Google introduced a Sanitizer named BoundSan to automatically 
instrument arrays to prevent overflows and fail safely.
BoundSan is enabled in 11 media codecs and throughout the 
Bluetooth stack for Android Q. By optimizing away a number of 
unnecessary checks the performance overhead was reduced to 
less than 1%.
https://security.googleblog.com/2019/05/queue-
hardening-enhancements.html
THANKS
Q&A