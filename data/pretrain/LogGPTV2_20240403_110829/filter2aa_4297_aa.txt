.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "SELECT" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
SELECT \- 从表或视图中取出若干行
.SH SYNOPSIS
.sp
.nf
SELECT [ ALL | DISTINCT [ ON ( \fIexpression\fR [, ...] ) ] ]
    * | \fIexpression\fR [ AS \fIoutput_name\fR ] [, ...]
    [ FROM \fIfrom_item\fR [, ...] ]
    [ WHERE \fIcondition\fR ]
    [ GROUP BY \fIexpression\fR [, ...] ]
    [ HAVING \fIcondition\fR [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] \fIselect\fR ]
    [ ORDER BY \fIexpression\fR [ ASC | DESC | USING \fIoperator\fR ] [, ...] ]
    [ LIMIT { \fIcount\fR | ALL } ]
    [ OFFSET \fIstart\fR ]
    [ FOR UPDATE [ OF \fItable_name\fR [, ...] ] ]
where \fIfrom_item\fR can be one of:
    [ ONLY ] \fItable_name\fR [ * ] [ [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, ...] ) ] ]
    ( \fIselect\fR ) [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, ...] ) ]
    \fIfunction_name\fR ( [ \fIargument\fR [, ...] ] ) [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, ...] | \fIcolumn_definition\fR [, ...] ) ]
    \fIfunction_name\fR ( [ \fIargument\fR [, ...] ] ) AS ( \fIcolumn_definition\fR [, ...] )
    \fIfrom_item\fR [ NATURAL ] \fIjoin_type\fR \fIfrom_item\fR [ ON \fIjoin_condition\fR | USING ( \fIjoin_column\fR [, ...] ) ]
.sp
.fi
[Comment: FIXME: This last syntax is incorrect if the join type is an
INNER or OUTER join (in which case one of NATURAL, ON ..., or USING
\&... is mandatory, not optional). What's the best way to fix
this?]
.SH "DESCRIPTION 描述"
.PP
\fBSELECT\fR 将从一个或更多表中返回记录行。 SELECT 通常的处理如下：
.IP 1. 
 计算列出在 FROM 中的所有元素。（FROM 中的每个元素都是一个真正的或者虚拟的表。）如果在 FROM 列表里声明了多过一个元素，那么他们就交叉连接在一起。（参阅下面的 FROM Clause [\fBselect\fR(7)] ）。
.IP 2. 
 如果声明了 WHERE 子句，那么在输出中消除所有 不满足条件的行。（参阅下面的 WHERE Clause [\fBselect\fR(7)] ）。
.IP 3. 
 如果声明了 GROUP BY 子句，输出就分成匹配一个或多个数值的不同组里。 如果出现了 HAVING 子句，那么它消除那些不满足给出条件的组。（参阅下面的
GROUP BY Clause [\fBselect\fR(7)] 和
HAVING Clause [\fBselect\fR(7)] ）。
.IP 4. 
 使用 UNION，INTERSECT， 和 EXCEPT，我们可以把多个 SELECT  语句的输出合并成一个结果集。UNION 操作符返回在两个结果集或者其中一个中的行， INTERSECT 操作符返回严格地在两个结果集中都有的行。 EXCEPT 操作符返回在第一个结果集中，但是不在第二个结果集中的行。不管哪种情况， 重复的行都被删除，除非声明了 ALL。（参阅下面的
UNION Clause [\fBselect\fR(7)], INTERSECT Clause [\fBselect\fR(l)], 和
EXCEPT Clause [\fBselect\fR(7)] ）。
.IP 5. 
 实际输出行的时候，SELECT 先为每个选出的行计算输出表达式 （参阅下面的
SELECT List [\fBselect\fR(7)] ）。
.IP 6. 
 如果声明了 ORDER BY 子句，那么返回的行是按照指定的顺序排序的。 如果没有给出 ORDER BY，那么数据行是按照系统认为可以最快生成的方法给出的。 （参阅下面的 
ORDER BY Clause [\fBselect\fR(7)] ）。
.IP 7. 
 如果给出了 LIMIT 或者 OFFSET  子句，那么 SELECT 语句只返回结果行的一个子集。（参阅下面的 LIMIT Clause [\fBselect\fR(7)] ）。
.IP 8. 
DISTINCT 从结果中删除那些重复的行。 DISTINCT ON 删除那些匹配所有指定表达式的行。 ALL （缺省）将返回所有候选行，包括重复的。 （参阅下面的 DISTINCT Clause [\fBselect\fR(7)] ）。
.IP 9. 
FOR UPDATE 子句导致 SELECT  语句对并发的更新锁住选定的行。（参阅下面的 FOR UPDATE Clause [\fBselect\fR(7)] ）。
.PP
.PP
 你必须有 SELECT 权限用来从表中读取数值。 使用 FOR UPDATE 还要求 UPDATE 权限。
.SH "PARAMETERS 参数"
.SS "FROM 子句"
.PP
FROM 子句为 SELECT 声明一个或者多个源表。 如果声明了多个源表，那么结果就是所有源表的笛卡儿积（交叉连接）。 但是通常我们会添加一些条件，把返回行限制成笛卡儿积的一个小的结果集。
.PP
FROM-子句可以包括：
.TP
\fB\fItable_name\fB\fR
 一个现存的表或视图的名字（可以有模式修饰）。 如果声明了ONLY，则只扫描该表。 如果没有声明ONLY，该表和所有其派生表（如果有的话）都被扫描。 可以在表名后面跟一个*来表示扫所有其后代表， 但在目前的版本里，这是缺省特性。 （在 PostgreSQL 7.1 以前的版本里，ONLY是缺省特性。） 缺省的特性可以通过修改配置选项 sql_interitance 来改变。
.TP
\fB\fIalias\fB\fR
 为那些包含别名的 FROM 项目取的别名。别名用于缩写或者在自连接中消除歧义（自连接里，同一个表扫描了多次）。 如果提供了别名，那么它就会完全隐藏表或者函数的实际名字； 比如，如果给出 FROM foo AS f，那么 SELECT  剩下的东西必须吧这个 FROM 项以 f 而不是 foo 引用。如果写了别名， 我们也可以提供一个字段别名列表，这样可以替换表中一个或者多个字段的名字。
.TP
\fB\fIselect\fB\fR
 一个子 SELECT 在 FROM 子句里出现的。 它的输出作用好象是为这条 SELECT 命令在其生存期里创建一个临时表。 请注意这个子 SELECT 必须用园括弧包围。 并且必须给它加别名。
.TP
\fB\fIfunction_name\fB\fR
 函数调用可以出现在 FROM 子句里。 （对于那些返回结果集的函数特别有用，但是任何函数都能用。） 这么做就好像在这个 SELECT 命令的生命期中， 把函数的输出创建为一个临时表一样。我们也可以使用别名。如果写了别名， 我们还可以写一个字段别名列表，为函数返回的复合类型的一个或多个属性提供名字替换。 如果函数定义为了 record 数据类型， 那么必须出现一个 AS 关键字或者别名，后面跟着一个字段定义列表， 形如：( column_name data_type [, ... ])。 这个字段定义列表必须匹配函数返回的字段的实际数目和类型。
.TP
\fB\fIjoin_type\fB\fR
.RS
.TP 0.2i
\(bu
[ INNER ] JOIN
.TP 0.2i
\(bu
LEFT [ OUTER ] JOIN
.TP 0.2i
\(bu
RIGHT [ OUTER ] JOIN
.TP 0.2i
\(bu
FULL [ OUTER ] JOIN
.TP 0.2i
\(bu
CROSS JOIN
.RE
.PP
 之一。 就 INNER 和 OUTER 连接类型， 我们必须声明一个连接条件，也就是说一个 NATURAL， ON join_condition， 或者 USING (join_column [, ...])。 见下文获取它们的含义，对于 CROSS JOIN，这些子句都不能出现。
 一个 JOIN 子句，组合了两个 FROM 项。 必要时使用圆括弧以决定嵌套的顺序。 如果没有圆括弧，JOIN 的嵌套从左向右。 在任何情况下，JOIN 都比逗号分隔的 FROM 项绑定得更紧。
CROSS JOIN 和 INNER JOIN
生成一个简单的笛卡儿积，和你在 FROM 的顶层列出两个项的结果相同。 CROSS JOIN 等效于 INNER JOIN ON (true)， 也就是说，没有被条件删除的行。这种连接类型只是符号上的方便， 因为它们和你用简单的 FROM 和 WHERE 干的事情是一样的。
LEFT OUTER JOIN 返回有条件的笛卡儿积（也就是说， 所有组合出来的行都通过了连接条件）中的行，加上左手边的表中没有对应的右手边表的行可以一起匹配通过连接条件的那些行。 这样的左手边的行扩展成连接生成表的全长，方法是在那些右手边表对应的字段位置填上空。请注意，只有在决定那些行是匹配的时候， 之计算 JOIN 子句自己的条件。外层的条件是在这之后施加的。
 对应的是，RIGHT OUTER JOIN 返回所有连接出来的行， 加上每个不匹配的右手边行（左边用空值扩展）。这只是一个符号上的便利，因为我们总是可以把它转换成一个 LEFT OUTER JOIN， 只要把左边和右边的输入对掉一下即可。
FULL OUTER JOIN 返回所有连接出来的行，加上每个不匹配的左手边的行（右边用空值扩展）， 加上每个不匹配的右手边的行（左边用空值扩展）。
.TP
\fBON \fIjoin_condition\fB\fR
\fIjoin_condition\fR 是一个表达式， 生成类型为 boolean 的结果（类似WHERE 子句）， 表示连接中那些行被认为是匹配的。
.TP
\fBUSING (\fIjoin_column\fB [, ...])\fR
 一个形如 USING ( a, b, ... ) 的子句， 是ON left_table.a = right_table.a AND left_table.b = right_table.b ...  的缩写。同样，USING 蕴涵着：每对等效字段中只有一个包含在连接输出中，而不是两个都输出的意思。
.TP
\fBNATURAL\fR
NATURAL 是一个 USING 列表的缩写，这个列表说的是两个表中同名的的字段。
.PP
.SS "WHERE 子句"
.PP
 可选的 WHERE 条件有如下常见的形式：
.sp
.nf
WHERE \fIcondition\fR
.sp
.fi
 这里 condition  可以是任意生成类型为 boolean 的表达式。 任何不满足这个条件的行都会从输出中删除。如果一个行的数值替换到条件的引用中计算出来的条件为真，那么该行就算满足条件。
.SS "GROUP BY 子句"
.PP
 可选的 GROUP BY 子句的一般形式
.sp
.nf
GROUP BY \fIexpression\fR [, ...]
.sp
.fi
.PP
GROUP BY 将把所有在组合了的表达式上共享同样的值的行压缩成一行。 expression 可以是一个输入字段名字， 或者是一个输入字段（SELECT 列表）的序号，或者也可以是任意从输入字段值形成的任意表达式。 在有歧义的情况下，一个 GROUP BY 的名字将被解释成输入字段的名字，而不是输出字段的名字。
.PP
 如果使用了聚集函数，那么就会对组成一组的所有行进行计算，为每个组生成一个独立的值（而如果没有 GROUP BY， 那么聚集对选出来的所有行计算出一个值）。如果出现了 GROUP BY， 那么 SELECT 列表表达式中再引用那些没有分组的字段就是非法的， 除非放在聚集函数里，因为对于未分组的字段，可能会返回多个数值。
.SS "HAVING 子句"
.PP
 可选的 HAVING 子句有如下形式：
.sp
.nf
HAVING \fIcondition\fR
.sp
.fi
 这里 condition  和为 WHERE 子句里声明的相同。
.PP
HAVING 去除了一些不满足条件的组行。 HAVING 与 WHERE 不同： WHERE 在使用 GROUP BY  之前过滤出单独的行，而 HAVING 过滤由 GROUP BY 创建的行。 在 condition 里引用的每个字段都必须无歧义地引用一个分组的行，除非引用出现在一个聚集函数里。
.SS "UNION 子句"
.PP
UNION 子句的一般形式是：
.sp
.nf
\fIselect_statement\fR UNION [ ALL ] \fIselect_statement\fR
.sp