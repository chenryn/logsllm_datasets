# 密码学基本原理（上）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
连载系列——It works,why?  
在做密码学相关项目的时候，经常可以看到很多程序员，对密码学有哪些技术，每个技术怎么用一无所知。在选择合适的密码学技能来达成目标的时候，总是选择自己最熟悉的方案，这不一定是最好的方案，甚至不一定是合格的方案。后果往往有两个：一个是很多代码潜伏着安全隐患；另一个则是，很多算法并不如想象中那样工作。我们时时可以见到程序员对着电脑沉思，这个算法不能工作，Why？又时时可以见到，这个算法能工作，Why？因此我将在“It
works,why?”系列文章中，论述常见的算法和常见应用，其中的“Why”。
* * *
本文简述了传统密码学的常见算法和相关特征。
## Digest
摘要为一个函数H，对任意数据d，有h=H(s)。同时至少满足下面特性1，其余特性为额外要求。
  1. 对相同的数据d1=d2，计算得到h1=H(d1)和h2=H(d2)，必然有h1=h2，但不要求h1=h2的情况下，必然有d1=d2；
  2. 根据h计算任意一个可能的d极其困难（安全性）；
  3. d服从随机分布的情况下，h的分布足够随机（均匀性）。
## hash系列函数
hash系列中最著名的即MD5，其后继者为SHA1，SHA2，SHA3等，但实际上这几个都是密码学hash函数，非密码hash常用于快速计算均匀散列值（例如hashtable），代表有CRC
（实际上CRC主要的目地是校验，而不是散列）, FNV，Murmur。
以上几个非密码hash函数的对比可以看这里： 。
hash函数需要注意长度。一般来说，长度越长越安全（越难被找到一个碰撞值），但是过于长的值会在保存和使用上产生困难。
## Rainbow table
Rainbow table是一种通过预先计算来碰撞的手段。
从粗略的角度来说，你可以认为这就是一个巨大的反向hash表，保存了所有计算过的hash和对应的碰撞数据，但通过计算可知，这样的反向表会占用巨大的存储空间。
而彩虹表采用巧妙的算法缩减了空间消耗。其基础思想是，对某个碰撞数据，计算其hash，随后通过某个算法R，将这个目标hash再映射到另一个碰撞数据上去。通过这种方式，一个碰撞数据可以持续的计算出一串不同的hash，假设这个长度为n，我们最后保留最终一个hash和最初一个碰撞数据。
在检索某个hash的原始碰撞数据时，我们可以利用R将其映射为碰撞数据(但不是我们需要的那个碰撞数据)，进而计算hash串并检测是否在反向表里。如果表里存在这个hash的碰撞数据，那么在生成n步的hash串的过程中，必然能在反向表里发现命中，而当发现命中后，就可以通过原始碰撞数据算出整个碰撞链，从而找到该hash的对应碰撞数据。
从算法分析的角度来说，这是一个空间换时间和时间换空间同时存在的巧妙算法，利用反向表计算原始碰撞是用空间换时间，用hash串来压缩空间消耗是用时间换空间。
另一个细节是hash链的碰撞。当hash链在某个节点相同，后续链条必然完全相同。这大大降低了hash串的效率，因此彩虹表采取了一个变形，算法R在n步中每一步都各不相同(实际一般是将n当作参数)，这样使得hash碰撞只发生在一个点上，由于算法在每个步骤上各自不一，因而得名彩虹表。
## KDF
密钥生成算法( KDF
)是一类算法的统称，用于将一个密码/密钥变换成另一个(或多个)密码/密钥。在这个过程中，会提供很多额外特性，例如：符合特定格式、防御暴力穷举攻击、保存后难于破解原始密码等。
KDF的最知名场景，就是密码保存问题。用户的密码不应直接保存，这样在万一数据库泄漏时就会泄漏原始密码，而单纯hash会导致用户密码遭受彩虹表攻击，一般解决这个问题的方法是对密码加盐。
但是盐是加在前面还是后面呢？以我个人的分析来看，似乎是没有区别的。即s+salt和salt+s都能保证安全，当然，更好的方法是用scrypt或bcrypt，他本身就有专门的函数保证密码安全保存，这可比加盐好使多了。
## 最佳实践
相信大部分读者都可能知道MD5和SHA1不安全的事了，这两者虽然还能完成摘要的用途，但是并没有安全保证了。如果你需要一个安全的hash算法，我推荐sha2，sha3目前并没有进入主流系统，而且执行速度还是略慢。
另外，如果可以选择的话，在sha2算法族里我推荐SHA-512/256或SHA-512/224，这两个算法有助于避免长度扩展攻击。
## Encryption and Decryption
对称加密解密为一对函数，加密为E，解密为D。对任意数据d和密钥p，满足下面要求1和2。
  1. 加密为e=E(d, p)，解密为d=D(e, p)；
  2. 攻击者得知E，D，e的情况下，无法反推d和p；
  3. 在条件2的基础上，攻击者能得知d和对应e的情况下，无法反推p（已知明文攻击）；
  4. 在条件2的基础上，攻击者能构造d并得知对应e的情况下，无法反推p（选择明文攻击）。
对称加密有几种可能的变形情况，例如E和D为同样的函数，一次加密第二次解密，或者由生成算法构造出密钥p和解密密钥p’，在其中密钥p可以推算变换为解密密钥p’，但这其实仍然符合上面的描述。因为解密时可以使用d=D(e,
p’)，而p’=G(p)，因此d=D(e, G(p))，即可认为d=D’(e, p)。对于密钥p无法推算出解密密钥p’的情况，请参考下面的“非对称加密”。
## DES/AES加密解密算法
加密算法中最有名的是DES和AES。关于这两个，我们不赘述。
## 密码模式
加解密算法一般都是以块模式运作的。即每个加密算法都有一个特定的长度，他只能处理这个长度的数据。块密码模式算法将基于某个特定的块算法，将其应用于流上。
最简单的用法是重复进行加密。取明文的前N字节加密，得到N字节密文，重复直到得到最后一块数据，数据的长度必然大于0小于N，对尾部的数据补足0，最后将所有密文联合起来，得到最终密文，这种模式叫做ECB模式。
ECB模式的好处是简单，但ECB并不能防御内容替换攻击。攻击者可以通过某种方式获得一个数据的加密形式（选择明文）B’，然后将某个加密后的块B’替换原始块B。以此，虽然攻击者并不知道原始内容，但是可以替换其中的部分内容。
人们对ECB做了一点改进，使用上一个块的加密结果，对下一个块做干扰（具体使用XOR），如此一来，对任意一个块的变更会导致后续块全部都无法解密。第一个块没有上一个块，也就没有加密结果，所以CBC需要一个初始向量IV来初始化干扰，而先加密上一个块的结果，再和当前数据XOR的算法，被称为CFB。CFB和CBC仅仅顺序上有区别，但是CFB可以用于流式加密，而CBC不行，因为CBC必须得到一个完整块，才能计算加密，而CFB是预先算出mask，用XOR获得结果。
CFB再略变化一点，就可以构成OFB。OFB取的是XOR前的结果，因此加密序列并不受明文的影响，只受IV和key的影响。你可以想像，OFB是一个由IV和key已经决定好的，无限长的mask，逐步XOR到明文上。
但是CFB和OFB都有一些缺陷，例如明文和密文的异或对应性。在确定模式为CFB或OFB的前提下，对某些特定位置遍历所有可能空间，就能在不了解解密结果的前提下遍历所有明文可能性。这个问题被用于ss的主动探测上。
## Salsa20
Salsa20原来叫Chacha20，是一种经过特别设计的密码系统，在未经优化的CPU上拥有非常快的执行速度。
## 最佳实践
可能和大家想像的相反，一般没事不会推荐直接使用加密函数本身，而是推荐使用AEAD算法。这里有一份2015年密码学最佳实践，按照推荐，是使用AES-GCM或Chacha20-Poly1305最好，这两种都是AEAD。
如果一定要用加密算法，而非AEAD的话，推荐使用NaCl（