1,465
K1+K2
1,613
2,218
2,010
1,875
2,066
2,285
(S1+S2)/T(%)
(K1+K2)/T(10−4)
24.6
20.2
11.3
13.1
7.4
6.5
15.0
15.6
8.1
8.1
5.6
4.8
Table 2: Comparison of the formulas generated by bit-level,
byte-level and multiple granularity symbolic execution. The
formula size is measured by number of lines. The second
metric is the number of variables. The third metric is the
solving time measured by seconds. - means timeout after
1800 seconds.
SE Metrics
byte
bit
MG
size
var #
time
size
var #
time
size
var #
time
grep
671
1289
90
7992
25110
383
71
408
12
bzip2
459
2071
105
5205
41947
486
128
558
16
aes
674
3215
150
5310
69827
532
218
544
13
md5sum thttp
792
4730
144
6840
80592
793
291
804
20
801
4318
152
9134
87638
517
239
673
14
sqlite
997
6103
183
10289
13609
-
348
930
23
plus a color, such as łlion blackž, łtiger red.ž One animal name refers
to a custom VM architecture and the colors means different vari-
ants of that that architecture. Deeper color means the variant has
more virtualization methods applied in that VM architect. In this
experiment, we apply two significantly different VMs, łtiger whitež
and łfish blackž to virtualize the two sensitive areas as shown in
Figure 9. After that we repeat the experiment in the last section.
The result shows that all virtualized snippets in different VMs are
correctly detected and simplified. The size of different sections is
shown in Table 3. Particularly, by comparison of the S2 column in
Table 3 with the S2 column in Table 1, we can see that the łfish
blackž VM is more complicated than łtiger white.ž However, the
size of the kernel is still similar. It proves that VMHunt can extract
the core semantics of the virtualized snippet.
Another way of applying multiple-VM virtualization is nested
VM [83], which means, apply another virtualization to an already
virtualized code. We also evaluate VMHunt in the nested VM sce-
nario. We use grep as the testbed and apply the tiger-white VM
twice. In practice, we observe that virtualized snippet after the
first round of virtualization is significantly larger than the original
snippet as shown in Table 3. Therefore, if the second round of virtu-
alization is applied directly to the virtualized snippet, it will cause
performance problem. Besides, the virtualized snippet also contains
program structures which are not suitable for being virtualized
again as mentioned in Section 1. In our evaluation, we select one
block of instructions after in the first-round virtualization. That
block does not include any program structures that could lead to
wrong virtualization. Then we apply another round of virtualization
to the block to produce the nested-virtualized grep program.
In our evaluation, we run VMHunt on the nested-virtualized grep.
First, VMHunt correctly identify two virtualized snippets. Different
from the previous experiment, those two virtualized snippets are
nested. We first apply VMHunt to extract the kernel of the inner
virtualized snippet and replace it with the kernel. After that, we run
VMHunt again to process the outer virtualized snippet. The final
result shows that VMHunt is able to correctly handle nested-VMs.
8.3 Malware Samples
In order to evaluate VMHunt in a malicious scenario in practice,
we collect malware samples from Virustotal3 and some other fo-
rums. These samples cover different malware categories, such as
botnet, virus, and ransomware. All samples are already known as
being virtualized. We run VMHunt on these malware to detect
and simplify the virtualized snippet. Table 4 shows the evaluation
result. VMHunt successfully detects all virtualized snippets in all
the 10 samples. We also manually verify the extracted snippets are
real virtualized snippet. A detailed case study of the ransomware
sample, tears, is presented in the next section. Our observation is
that malware developers only apply virtualization obfuscation to a
small piece of code, which is typically a sensitive area that can be
detected by the anti-virus software.
8.4 A Ransomware Case Study
In this section, we present a case study about applying VMHunt
in a real-world ransomware called łtearsž. We download the ran-
somware sample from VirusTotal. The ransomware encrypts vic-
tims’ files by AES encryption and then ask the victims to pay a
ransom for decryption of their files. Based on the description on
VirusTotal, the core part of the sample is protected by virtualization
techniques. We set up a Cuckoo sandbox4 to run the ransomware
and record an execution trace. Then we use VMHunt to analyze the
virtualized snippets inside the trace. The size of the whole trace,
virtualized snippets and the kernels is shown as the last row in
Table 4.
VMHunt identifies one virtualized snippet inside the execution
of the ransomware. After extraction and multiple granularity sym-
bolic execution of the kernel, we discover that the virtualized part
is actually the procedure of key generation. In fact, the AES en-
cryption key is generated based on the time when the ransomware
3https://www.virustotal.com
4https://cuckoosandbox.org/
Table 3: The number of instructions of the whole trace, virtualized snippets, and kernels in the Multi-VM experiment. S1 is
the virtualized snippet by tiger-white and S2 is the virtualized snippet by fish-black. K1 and K2 are the kernels of S1 and S2
respectively.
Programs
T
grep
bzip2
aes
1,217,671
1,594,486
2,566,455
md5sum 2,310,301
3,691,011
thttpd
sqlite
4,764,819
S1
122,615
120,103
110,801
138,508
123,080
143,995
S2
231,807
206,049
240,743
249,138
277,226
294,373
S1+S2
354,422
326,152
351,544
387,646
400,306
438,368
K1
537
713
792
649
711
802
K2
1,458
1,540
1,675
1,549
1,563
1,898
K1+K2
1,995
2,253
2,467
2,198
2,274
2,700
(S1+S2)/T(%)
(K1+K2)/T(10−4)
29.1
20.8
13.7
16.8
10.8
9.2
16.4
14.1
9.6
9.5
6.2
5.7
Table 4: VMHunt evaluation result on malware samples. S/T
is calculated in percentage. K/T is calculated in (10−4)
Name
chodebot
nzm
phatbot
zswarm
tsgh
dllinject
locker_builder
locker_locker
temp_java
tears
T
Type
Botnet
Botnet
Botnet
Botnet
Botnet
Virus
Virus
Virus
Virus
1,967,000
6,141,556
2,224,405
5,587,140
5,199,837
8,634,893
10,435,886
4,594,868
8,661,836
Ransom 2,658,615
S
150,129
181,457
152,723
168,529
145,372
174,232
198,695
146,960
185,380
143,308
K
930
1432
1008
1395
1362
1568
1293
893
1504
1074
S/W K/W
4.7
5.9
3.0
2.3
4.5
6.9
2.5
3.0
2.6
3.0
1.8
2.0
1.9
1.2
1.9
3.2
1.7
2.1
5.4
4.0
is invoked. If the key generation procedure is cracked, people can
easily calculate the key by themselves. So the key generation proce-
dure is the sensitive area in the ransomware. The developer adopts
virtualization to hide this procedure.
According to the final result of VMHunt’s analysis, the key gen-