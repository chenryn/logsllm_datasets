poor performance is that events on the OSX laptop of-
ten take 2x-5x more time than on the Linux desktop ma-
chine. This difference is reﬂected in the height of the
peaks (rather than in their position), which is penalized
by DTW. Normalizing the measurements could improve
cross-machine recognition.
The code and datasets used for tuning and cross-
validation are available as an R library at https://
github.com/cgvwzq/rlang-loophole.
4.1.7 Threats to Validity
We perform our experiments in a closed-world scenario
with only 2 tabs (the spy and the victim) sharing an event
loop. In real world scenarios there can be more pages
concurrently running the browser, which will make de-
tection harder. The worst case for monitoring the host
process occurs when a tab performs streaming, since the
loop gets completely ﬂooded. The renderer’s loop, how-
ever, is in general more robust to noise caused by other
tabs in the browser.
On the other hand, our attacks do not make any use of
the pages’ source code or of details of Chrome’s schedul-
ing system with priority queues, the GC with periodic
scavenges, or the frame rendering tasks. We believe that
taking into account this information can signiﬁcantly im-
prove an adversary’s eavesdropping capabilities and en-
able attacks even in noisy, open-world scenarios.
4.2 Detecting User Behavior
In this section we show that it is possible to detect user
actions performed in a cross-origin tab or iframe, when
the renderer process is shared. We ﬁrst describe an attack
recovering the inter-keystroke timing information against
Google’s OAuth login forms, which provides higher pre-
cision than existing network-based attacks [32].
4.2.1
Inter-keystroke Timing Attack on Google’s
OAuth login form
Many web applications use the OAuth protocol for user
authentication. OAuth allows users to login using their
identity with trusted providers, such as Google, Face-
book, Twitter, or Github. On the browser, this process
is commonly implemented as follows:
1. A web application A pops up the login form of a
trusted provider T;
mits the form to T;
2. User V types their (name and) password and sub-
3. T generates an authorization token.
Because the window of the login form shares the event
loop with the opener’s renderer, a malicious A can eaves-
drop on the keystroke events issued by the login form.
Figure 8: Delay pattern generated by a keystroke in the
Google OAuth login form, measured across origins on
Chrome Canary v61 on OSX. The two consecutive de-
lays of approx. 2ms each, correspond to keydown and
keypress event listeners.
Figure 8 depicts the event-delay trace of a keystroke
as seen by an eavesdropper on the renderer’s event loop.
The trace contains two characteristic consecutive delays,
caused by the keydown and keypress event listeners. We
use this observation to identify keystrokes, by scanning
the event-delay trace for pairs of consecutive delays that
are within a pre-deﬁned range, forgoing any training or
ofﬂine work. Listing 4 contains the script that performs
this operation. We deﬁne 0.4 ms as a lower bound, and
3.0 ms as an upper bound for the range. We chose this
threshold before gathering the data, by manual inspection
of a few keystroke events. Note that this calibration could
be done automatically, based on the victim’s interactions
with a page controlled by an attacker.
858    26th USENIX Security Symposium
USENIX Association
19780.00019785.00019790.00019795.00019800.00019805.0000.020.040.060.100.200.401.002.004.0010.001
2
3
4
5
6
7
8
9
10
const L = 0.4 , U = 3.0 , keys = []
for ( let i =1; i < trace . length -1; i ++) {
let d1 = trace [ i ] - trace [i -1] ,
d2 = trace [ i +1] - trace [ i ]
if (L < d1 < U && L < d1 < U ) {
keys . push ( trace [ i ])
}
}
Listing 4:
Pseudo-Javascript code to detect
keystrokes in a trace of timestamps gathered by
the code in Listing 1. We classify a timestamp as
a keystroke if the differences to the previous and
subsequent timestamps (d1 and d2) are both in a
predeﬁned range.
4.2.2 Experimental Evaluation
To evaluate the effectiveness of this attack, we have
implemented a malicious application A that extracts
the inter-keystroke timing information from a user V
logging-in via Google’s OAuth. The focus of our evalu-
ation is to determine the accuracy with which keystroke
timings can be measured through the event loop. A full
keystroke recovery attack is out of scope of this paper;
for this refer to [32].
Figure 9: Experimental setup for evaluating effectiveness
of automatic, cross-renderer keystroke detection.
We simulate an inter-keystroke timing attack in 4
steps, which are described below and illustrated in Fig-
ure 9.
1. A Selenium3 script acting as V navigates to A, clicks
on the login button (which pops up Google’s OAuth
login form),
types a password, and submits the
form.
2. Meanwhile,
the attacker A monitors the main
thread’s event loop using the attack described in
Section 4.2.1.
3Selenium (http://www.seleniumhq.org/) is a cross-platform
testing framework for web applications that provides capabilities for
programmatically navigating to web pages and producing user input.
3. V and A send to the server the timestamps of the
real and the detected keystrokes, respectively.
4. We
the
compute
accuracy of
the detected
keystrokes, where we take the timestamps of
the real keystrokes as ground truth. Matching the
timestamps requires taking into account the delay
(6 − 12 ms on our machine) between Selenium
triggering an event, and Chrome receiving it.
We use as inter-keystroke timings random delays uni-
formly drawn from 100−300 ms. This choice is inspired
by [20], who report on an average inter-keystroke delay
of 208 ms. Using random delays is sufﬁcient for evalu-
ating the accuracy of eavesdropping on keystrokes, but
it obviously does not reveal any information about the
password besides its length.
4.2.3 Experimental Results
We perform experiments with 10.000 passwords ex-
tracted from the RockYou dataset, where we obtain the
following results:
• In 91.5% of the cases, our attack correctly identiﬁes
the length of a password. 4 In 2.2% of the cases, the
attack misses one or more characters, and in 6.3%
of the cases it reports spurious characters.
• For the passwords whose length was correctly iden-
tiﬁed, the average time difference between a true
keystroke and a detected keystroke event is 6.3ms,
which we attribute mostly to the inﬂuence of Se-
lenium. This inﬂuence cancels out when we com-
pute the average difference between a true inter-
keystroke delay and a detected inter-keystroke de-
lay, which amounts to 1.4 ms. The noise of these
measurements is low: We observe a standard devia-
tion of 6.1 ms, whereas the authors of [20] report on
48.1 ms for their network based measurements.
Overall, our results demonstrate that shared event
loops in Chrome enable much more precise recovery of
keystroke timings than network-based attacks. More-
over, this scenario facilitates to identify the time when
keystroke events enter the loop (from popping-up to form
submission), which is considered to be a major obstacle
for inter-keystroke timing attacks on network trafﬁc [20].
Keystroke timing attacks based on monitoring
procfs [38] or CPU caches [18] can extract more ﬁne-
grained information about keystrokes, such as contain-
ment in a speciﬁc subsets of keys. However, they require
ﬁlesystem access or are more susceptible to noise, due
to the resource being shared among all processes in the
system. In contrast, our attack enables targeted eaves-
dropping without speciﬁc privileges.
4We conﬁgured Selenium to atomically inject characters that would
require multiple keys to be pressed.
USENIX Association
26th USENIX Security Symposium    859
4.2.4 Open Challenges for Recognizing User Events
We conclude by discussing two open challenges for
recognizing user events, namely the detection of user
events beyond keystrokes and the detection of events in
the browser’s host process.
Detecting User Events beyond Keystrokes A contin-
uous mouse movement results in a sequence of events,
each of which carrying information about the coordinates
of the cursor’s trajectory. These events are issued with an
inter-event delay of 8 ms, and the (empty) event listener
operation blocks the loop for approx 0.1 ms. The partic-
ular frequency and duration of these events makes mouse
movements (or similar actions, like scrolling) easy to
spot with LoopScan, as seen in Figure 10.
Figure 10: Mouse movement captured by LoopScan tool.
The graph shows 3 delays of 0.1 ms duration (at t equals
3350, 3358 and 3366), with an inter-event delay of 8 ms.
Likewise, mouse click events, corresponding to “up”
or “down”, can be identiﬁed using LoopScan. Their
shape depends on the speciﬁc event listener of the spied
web page and the HTML element being clicked. We ex-
pect that events with speciﬁc listeners are more easily
detectable than events without registered event listeners,
that is, user actions that do not trigger Javascript exe-
cution. However, we can use the context in which the
event occurs to reduce the search space. For instance,
most mouse clicks only appear between two sequences
of mouse movement events.
We are currently investigating techniques that enable
the automatic identiﬁcation of such patterns in event-
delay streams. A promising starting point for this are
existing on-line variants of dynamic time-warping [31].
Detecting User Events in the Host Process Our dis-
cussion so far has centered on detecting user events in
the event loop of the renderer process. However, all user
events originate in the main thread of the host process
and are sent towards a speciﬁc renderer through the event
loop of the host’s I/O thread. Hence, any user action can
in principle be detected by spying on the host.
Unfortunately, our current methods are not precise
enough for this task, since the host’s I/O thread is more
noisy than the renderer’s main thread and the effect of a
user action on the host process is limited to a short sig-
naling message, whereas the renderer’s main thread is
affected by the execution of the corresponding Javascript
event listener.
4.3 Covert Channel
In this section we show how shared event loops in
Chrome can be abused for implementing covert chan-
nels, i.e. channels for illicit communication across ori-
gins. We ﬁrst consider the case of cross-origin pages
sharing the event loop of a renderer’s main thread be-
fore we turn to the case of cross-origin pages sharing the
event loop of the host processes’ I/O thread.
4.3.1 Renderer Process
We implement a communication channel to transmit
messages from a sender page S to a cross-origin receiver
page R running in the same renderer process.
For this, we use a simple, unidirectional transmission
scheme without error correction. Speciﬁcally, we encode
each bit using a time interval of ﬁxed duration tb. The op-
timal conﬁguration of tb depends on the system. In our
experiments we tried different values, with tb = 5 ms giv-
ing good results on different platforms: Chromium 52.0
on Debian 64-bit and Chrome 53 on OSX.
In each of those intervals we do the following:
• the sender S idles for transmitting a 0; it executes a
blocking task of duration ˆt < tb for transmitting a 1.
• the receiver R monitors the event loop of the ren-
derer’s main thread using the techniques described
in Section 3.1; it decodes a 0 if the length of the ob-
served tasks is below a threshold (related to ˆt), and
a 1 otherwise.
Transmission starts with S sending a 1, which is used by
the agents to synchronize their clocks and start count-
ing time intervals. Transmission ends with S sending a
null byte. With this basic scheme we achieve rates of
200 bit/s. These numbers can likely be signiﬁcantly
improved by using more sophisticated coding schemes
with error correction mechanisms; here, we are only in-
terested in the proof-of-concept.
We note that
there are a number of alternative
covert channels for transmitting information between
pages running in the same renderer [1], e.g., us-
ing window.name, location.hash, history.length,
scrollbar’s position or window.frames.length. What
distinguishes the event-loop based channel is that it does
not require the sender and receiver to be connected, i.e.
they do not need to hold references to each other in order
to communicate.
4.3.2 Host Process
We also implement a communication channel to transmit
messages between two cooperative renderer processes
860    26th USENIX Security Symposium
USENIX Association
sharing the host process. Transmission is unidirectional
from sender S to receiver R. Figure 11 visualizes how this
channel can be used, even if one of the parties browses
in Incognito mode.
Figure 11: Covert channel through the I/O event loop
of the Chrome’s host process. Tabs in different renderer
processes (one of them navigating in Incognito mode)
communicate.
As before, we encode each bit using a time intervals
of ﬁxed duration tb. During each intervals we do the fol-
lowing:
• the sender S idles for transmitting a 0; it posts N
fetch requests into the I/O thread’s queue for send-
ing a 1.
• the receiver R monitors the event loop of the I/O
thread of the host process using the techniques de-
scribed in Section 3.2. It decodes a 0 if the number
of observed events during time interval tb is below
a threshold, and 1 otherwise.
The optimal values of N and tb highly depend on the ma-
chine. In our experiments we achieve good results, work-
ing on different systems, with a tb = 200 ms and N = 350,
which give us a 5 bit/s transmission rate. This rate is sig-
niﬁcantly lower than for communication using the ren-
derer event loop, which is explained by the difference in
noise and monitoring resolution of both channels, as dis-
cussed in Section 3.2.3.
The threat scenario of this covert channel is more
relevant than the previous one for the renderer loop.