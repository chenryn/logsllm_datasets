byteBlock[j] = ~(byteBlock[j]);
count = buffer->writeBytes(i * 512, (UInt8 *)byteBlock, 512);
}
buffer->complete();
return;
}
static void
fixBufferUserWrite(IOMemoryDescriptor *bufferR, IOMemoryDescriptor *bufferW)
{
IOByteCount i, j;
IOByteCount length, count;
UInt64 byteBlock[64];
assert(bufferR);
assert(bufferW);
length = bufferR->getLength();
assert(!(length % 512));
length /= 512;
bufferR->prepare(kIODirectionOut);
bufferW->prepare(kIODirectionIn);
for (i = 0; i readBytes(i * 512, (UInt8 *)byteBlock, 512);
for (j = 0; j writeBytes(i * 512, (UInt8 *)byteBlock, 512);
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 61 of 79
}
bufferW->complete();
bufferR->complete();
return;
}
static void
SCDReadWriteCompletion(void *target,
void *parameter,
IOReturn status,
UInt64 actualByteCount)
{
SimpleCryptoDiskContext *context = (SimpleCryptoDiskContext *)parameter;
if (context->bufferWO == NULL) { // this was a read
// Fix buffer contents (apply simple "decryption").
fixBufferUserRead(context->buffer);
} else { // This was a write.
// Release temporary memory descriptors and free memory that we had
// allocated in the write call.
(context->bufferRO)->release();
(context->bufferWO)->release();
IOFree(context->memory, context->size);
}
// Retrieve the original completion routine.
IOStorageCompletion completion = context->completion;
IOFree(context, sizeof(SimpleCryptoDiskContext));
// Run the original completion routine, if any.
if (completion.action)
(*completion.action)(completion.target, completion.parameter, status,
actualByteCount);
}
To test the SimpleCryptoDisk driver, we will create a disk image with a partition type of osxbook_HFS. We
will also create a regular disk image so we can highlight the difference between encrypted and cleartext
storage. Let us create a regular disk image first (Figure 1037).
Figure 1037. Reading the contents of cleartext storage directly from the storage medium
$ hdiutil create -size 32m -fs HFS+ -volname Clear /tmp/clear.dmg
...
created: /private/tmp/clear.dmg
$ open /tmp/clear.dmg # mount the volume contained in clear.dmg
$ echo "Secret Message" > /Volumes/Clear/file.txt
$ hdiutil detach /Volumes/Clear # unmount the volume
...
$ strings /tmp/clear.dmg
...
Secret Message
...
The use of the hdiutil command-line program to create and manipulate disk images is discussed in Chapter
11.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 62 of 79
As Figure 1037 shows, we can see the contents of the text file we created on a cleartext volume by accessing
the raw storage medium. Let us attempt to do the same in the case of an encrypted disk (Figure 1038).
Figure 1038. Using encrypted storage with the SimpleCryptoDisk filter scheme driver
$ hdiutil create -size 32m -partitionType osxbook_HFS /tmp/crypto.dmg
...
created: /private/tmp/crypto.dmg
$ sudo kextload -v SimpleCryptoDisk.kext
kextload: extension SimpleCryptoDisk.kext appears to be valid
kextload: loading extension SimpleCryptoDisk.kext
kextload: SimpleCryptoDisk.kext loaded successfully
kextload: loading personalities named:
kextload: SimpleCryptoDisk
kextload: sending 1 personality to the kernel
kextload: matching started for SimpleCryptoDisk.kext
$ hdiutil attach -nomount /tmp/crypto.dmg
/dev/disk10 Apple_partition_scheme
/dev/disk10s1 Apple_partition_map
/dev/disk10s2 osxbook_HFS
/dev/disk10s2s1 Apple_HFS
$ newfs_hfs -v Crypto /dev/rdisk10s2s1
Initialized /dev/rdisk10s2s1 as a 32 MB HFS Plus Volume
$ hdiutil detach disk10
...
"disk10" ejected.
$ open /tmp/crypto.dmg
$ echo "Secret Message" > /Volumes/Crypto/file.txt
$ cat /Volumes/Crypto/file.txt
Secret Message
$ hdiutil detach /Volumes/Crypto
$ strings /tmp/crypto.dmg
# the cleartext message is not seen
An experimental use of a filter scheme driver could be to analyze patterns of block reads and writes.
10.8. Debugging
Casually speaking, debugging can be defined as the process of finding and fixing defects, or bugs,[15] in an
object of interest, which could be a piece of software, firmware, or hardware. In this section, we will look at
several areas related to kernel debugging.
[15] A real-life buga mothcaused program malfunction in the Harvard Mark I computer and
gained the distinction of being the first computer bug.
10.8.1. Kernel Panics
When there is a kernel panic, the kernel takes different actions depending on whether kernel debugging is
enabled or not. By default, kernel debugging is disabled, in which case the kernel displays a panic user
interface that instructs the user to restart the computer. We saw in Section 5.6 how to customize and test this
user interface. Various kernel-debugging options can be enabled by setting the appropriate bits in the
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 63 of 79
kernel's debug boot-time argument. Table 413 lists details of this argument. A typical setting of debug is
0x144, which is the bitwise OR of DB_LOG_PI_SCRN (disables the panic user interface), DB_ARP (allows the
kernel debugger nub to use ARP), and DB_NMI (enables support for NMI generation). With this setting, the
kernel dumps kernel panic information on the screen and waits for a debugger connection. Figure 1039
shows an example of a kernel panic dump, along with the functions involved in generating the dump. The
panic corresponds to a NULL pointer being dereferenced in the kernel.
Figure 1039. Dissection of a kernel panic dump
[View full size image]
The file osfmk/kern/debug.c contains definitions of several panic-related data structures and variables,
such as panicstr, panic_lock, paniccpu, panicDebugging, debug_mode, logPanicDataToScreen, and
debug_buf. It also implements the platform-independent panic() routine, which calls the platform-
dependent routine Debugger() [osfmk/ppc/model_dep.c].
As we saw in Section 4.11.1.1, if kernel debugging is disabled, information about the last kernel panicif
there was oneis saved in a special NVRAM partition, provided there is sufficient space in the NVRAM. The
panic information represents the contents of the debug_buf global buffer. Even though a page of memory is
allocated for the latter, only up to 2040 bytes of its contents are saved to NVRAM,[16] or transmitted to
another computer, by Debugger(). On rebooting, the contents of the panic log are available as an NVRAM
property called aapl,panic-info, which is read-only from the user's standpoint. The property is created
when Open Firmware variables are initialized in the IONVRAM module [iokit/Kernel/IONVRAM.cpp].
Additionally, the NVRAM panic partition is marked for clearing.
[16] The kernel attempts to apply rudimentary compression on the panic log. Therefore, the
saved panic information may contain more information than the same number of bytes in the
debug buffer.
Once the kernel panics, a driver cannot automatically reboot the system because the kernel does not run
driver threads after a panic. However, the Xserve hardware watchdog timer can be used to trigger a reboot.
During bootstrapping, the crash reporter daemon (/usr/libexec/crashreporterd) is launched by the
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 64 of 79
CrashReporter startup item. crashreporterd calls a helper tool (/usr/libexec/crashdump) to read the
contents of aapl,panic-info and dump them to the panic log file (/Library/Logs/panic.log). The raw
contents can also be viewed using the nvram command-line program:
$ nvram -p aapl,panic-info
aapl,panic-info %e1%87v%9cj1%f0%ea%81%82%0cxvl%cb%c9%03%0f...
Note that the contents of aapl,panic-info are the same as what would have been displayed on-screen if
kernel-debugging were enabled.
On Old World Macintosh computers, the NVRAM may not have enough space to store the panic
information. On such computers, no panic log will be dumped on rebooting after a panic.
10.8.2. Remote Core Dumps
The Mac OS X kernel supports remote core dumping wherein one Mac OS X system can send core dumps
to another system, with the latter running the remote kernel core dump server (/usr/libexec/kdumpd)also
called the panic server. kdumpd is derived from the BSD tftp program.[17] It listens on UDP port number
1069, which is hardcoded in the implementation of the Kernel Debugging Protocol (KDP). It should be
executed as a low-privilege user such as "nobody." The directory for storing received core files is specified
to kdumpd as an argument.
[17] It is possible to run kdumpd on a system other than Mac OS X.
A single panic server can receive core dump files and panic logs from multiple systems.
The core dump filename sent by a target kernel uses the string "core---
" as the template, where  is the IP address of the sender in dotted-decimal format and
 is the hexadecimal representation of the lower 32 bits of the absolute time value (as reported by
mach_absolute_time()). Note that the kernel can send both core dump files and panic logs to kdumpd. The
following is an example of the message printed by a target machine while sending a core dump file to
kdumpd:
Entering system dump routine
Attempting connection to panic server configured at IP 10.0.0.1
Routing via router MAC address xx:xx:xx:xx:xx:xx
Kernel map size is 725536768
Sending write request for core-xnu-792-10.0.0.2-4104e078
To enable sending core dumps to a panic server, the latter's IP address is specified through the _panicd_ip
boot-time argument to the target kernel. Moreover, the appropriate bits of the debug argument must be setin
particular, the DB_KERN_DUMP_ON_PANIC (0x400) bit must be set to trigger a core dump on panic.
Additionally, DB_KERN_DUMP_ON_NMI (0x800) can be set to trigger a core dump on an NMI without inducing
a kernel panic.
$ sudo nvram boot-args="-v debug=0xd44 panicd_ip=10.0.0.1"
There are certain caveats in transmitting core dumps to the panic server, such as the following.
 The system running kdumpd must have a static IP address.
In its current implementation, remote core dumping is inherently insecure in that kernel memory is
transmitted over the network.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 65 of 79
 There must be sufficient free disk space on the system running kdumpd to accommodate the incoming
core dump.
10.8.3. Logging
Logging is an integral part of software debugging, whether it is kernel-level or user-level software. The Mac
OS X kernel provides several mechanisms that kernel extensions can use to log messages. The Mac OS X
system log facility, Apple System Logger (ASL), supports several methods of dispatching log messages.
Figure 1040 shows an overview of logging in Mac OS X.
Figure 1040. Logging in Mac OS X
[View full size image]
The following are the primary logging functions available in the kernel.
 IOLog() is the preferred logging function in the I/O Kit. It generates a message that is destined for the
system log file and possibly for the console. It is a wrapper around _doprnt()
[osfmk/kern/printf.c]. IOLog() is not synchronous normally, which means it is possible to miss
log messages in the case of a kernel panic. However, setting the kIOLogSynchronous bit
(0x00200000) in the io boot-time argument makes the console output synchronous. The file
iokit/IOKit/IOKitDebug.h enumerates several other bits that can be set in the io argument to
enable specific types of I/O Kit log messages.
 printf() is similar to IOLog() but can be used from outside the I/O Kit. It is another wrapper around
_doprnt(), but it also surrounds the call to _doprnt() by disable_preemption() and
enable_preemption().
 OSReportWithBacktrace() calls OSBacktrace() [libkern/gen/OSDebug.cpp] to generate a stack
backtrace and prints it using printf(). It also calls kmod_dump_log() [osfmk/kern/kmod.c] to print
loadable kernel modulesalong with their dependenciesassociated with the backtrace.
 kprintf() is a synchronous logging function whose output must be enabled by setting the DB_KPRT
(0x8) bit in the debug boot-time argument. Its output can be sent across a serial connection (provided
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 66 of 79
a native serial port is available) or a FireWire connection. The latter requires the
AppleFireWireKPrintf kernel extension on the system generating the messages and the
FireWireLogger program on the system used for viewing the messages.[18]
[18] AppleFireWireKPrintf.kext and FireWireLogger are available as parts of Apple's
FireWire SDK.
conslog_putc() [osfmk/kern/printf.c] calls log_putc() [bsd/kern/subr_log.c] to append messages
to a global message buffera msgbuf structure that we came across in Section 5.3.3.
// bsd/sys/msgbuf.h
#define MSG_BSIZE (4096 - 3 * sizeof(long))
struct msgbuf {
#define MSG_MAGIC 0x063061
long msg_magic;
long msg_bufx; // write pointer
long msg_bufr; // read pointer
char msg_bufc[MSG_BSIZE]; // circular buffer
};
The user-space system log daemon (/usr/sbin/syslogd) retrieves log messages from the kernel by reading
from the kernel log device /dev/klog. During file system initialization, the device file system layer (devfs)
is initialized. As part of devfs initialization, several built-in BSD-style devices, including /dev/klog, are
initialized. The device-switch structure (struct cdevsw) of /dev/klog contains logopen(), logread(),
and logselect() [bsd/kern/subr_log.c] as the open, read, and select functions, respectively. syslogd
uses the select() system call to see if the log device is ready for reading. As shown in Figure 1041, the
kernel periodically wakes up the thread waiting on the log device by calling klogwakeup().
Figure 1041. Periodic delivery of log messages to readers of the log device
// bsd/kern/bsd_init.c
void
bsd_init()
{
...
// hz is 100 by default
timeout((void (*)(void *))lightning_bolt, 0, hz);
...
}
void
lightning_bolt()
{
...
timeout(lightning_bolt, 0, hz);
klogwakeup();
...
}
// bsd/kern/subr_log.c
void
logwakeup()
{
...
// wake up threads in select()
selwakeup(...);
...
}
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 67 of 79
void
klogwakeup()
{
if (_logentrypend) {
_logentrypend = 0;
logwakeup();
}
}
The logopen() function ensures that only one thread can open the log device at a time.
10.8.4. Debugging by Using GDB
As we discussed in Section 6.8.1, Mac OS X supports two-machine kernel debugging using GDB over an
Ethernet or FireWire connection. Consider the case of Ethernet-based debugging. We saw earlier that a
network driver that supports such debugging provides polled-mode implementations of functions to transmit
and receive packetssendPacket() and receivePacket(), respectively. The IONetworkController class
provides the attachDebuggerClient() method to allocate an IOKernelDebugger object and attach it as a
client, leading to the creation of a debugger client nub. The IOKernelDebugger instance calls a KDP-layer
functionkdp_register_send_receive() [osfmk/kdp/kdp_udp.c]to register internal transmit and receive
dispatcher functions, which in turn call the polled-mode methods when the debugger is active. Thereafter,
the KDP module can send and receive protocol packets. Figure 1042 shows a portion of the I/O Kit stack
relevant to Ethernet- and FireWire-based debugging.
Figure 1042. Objects that implement target-side KDP
[View full size image]
A network controller can have at most one debugger client.
Apple provides a package called Kernel Debug Kit that contains debug versions of the Mac OS X kernel and
several I/O Kit family kernel extensions. The executables in this kit are meant for remote debugging using
GDBthey contain full symbolic information. Note, however, that the kernel contained in the kit is a release
kernelthat is, it is compiled in the RELEASE_xxx configuration, rather than the DEBUG_xxx configuration.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 68 of 79
There are several ways to cause a kernel to stop normal execution and wait for a remote GDB connection. A
kernel panic is one, but it is possible to invoke the debugger by generating an NMI and even by calling a