end latencies for a null RPC that immediately returns, and a
recursive null RPC that calls itself n times before returning
null. These tests isolate the raw cost of RPC invocation,
ignoring any computation that an RPC library might do.
Jigsaw’s function invocation overheads are 3–5 microsec-
onds across all tests. Pivot’s overheads are slower by two
272
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:00:50 UTC from IEEE Xplore.  Restrictions apply. 
Jigsaw (rw-sat)
Pivot (no-rw satellite)
Pivot (rw-satellite)
1000
100
10
1
C
P
R
r
e
p
s
d
n
o
c
e
s
o
r
c
i
M
l
)
e
a
c
s
g
o
l
(
Figure 18: End-to-end RPC latencies for a null RPC and
recursive null RPCs: Jigsaw, Pivot with an unrewritten
satellite, and Pivot with a rewritten satellite.
)
B
K
(
e
z
i
s
e
d
o
c
n
e
t
t
i
r
w
e
R
80
60
40
20
0
Jigsaw
Pivot
SHA1
DomSQL
JsonRPC
Bubblemark
Figure 19: Relative expansion of rewritten code: Jigsaw
versus Pivot.
orders of magnitude, ranging from 369–491 microseconds.
There are several sources for this overhead. First, each Pivot
RPC requires two postMessage() roundtrips (one between
the calling satellite and the master, and another between
the master and the responding satellite). These RTTs add
roughly 230 microseconds to each Pivot RPC. Second, as
explained in Section V-C, generator overhead grows as the
depth of the call chain increases. This explains why, in
Figure 18, the white bar slowly grows compared to the
striped bar.
An asynchronous postMessage() framework like Post-
Mash [4] incurs the postMessage() RTT costs described
above; however, such a framework avoids the additional gen-
erator latencies that Pivot introduces. If a particular mashup
application only requires asynchronous cross-domain com-
munication, then Pivot’s generators add unnecessary over-
head, and a framework like PostMash is more appropriate.
However, for applications that do require synchronous RPCs,
Pivot can provide order-of-magnitude performance improve-
ments over other synchronous frameworks (§V-D).
F. Size of Rewritten Code
Figure 19 depicts the size of fully rewritten libraries in
Jigsaw and Pivot. Pivot’s rewritten libraries are similar in
size to those of Jigsaw, so Pivot does not fundamentally
change the amount of code that a secure web application
must download. However, Pivot has the ability to safely
integrate unrewritten libraries as well, and such libraries are
typically 2–4 times smaller than the rewritten versions.
VI. RELATED WORK
Leveraging browser-provided isolation: TreeHouse [14]
and Privilege-separated JavaScript (PSJ) [3] use browser-
enforced protection domains. PSJ employs frames, and
TreeHouse uses web workers. Web workers are similar
to frames; each worker has a separate JavaScript runtime,
and communicates with other workers and frames using
postMessage(). The primary difference between a frame
and a web worker is that the latter does not have a DOM
tree.
Pivot, TreeHouse, and PSJ all use a trusted coordinator
frame to route messages and determine which sensitive
operations can be invoked by untrusted code. All
three
systems also place a control stub in each untrusted frame.
However, Pivot and PSJ do not trust those control stubs,
whereas TreeHouse does. Since TreeHouse does not rewrite
untrusted code, malicious libraries can use attacks like
prototype poisoning (§II-A) to tamper with TreeHouse’s
control stubs.
Neither TreeHouse nor PSJ provide synchronous RPC
interfaces. Thus, porting legacy applications to TreeHouse
and PSJ will often require non-trivial refactoring to convert
synchronous code paths to asynchronous ones. Furthermore,
the standard DOM interface exposes many synchronous
methods, e.g., to access persistent storage, register event han-
dlers, and mutate the DOM tree. TreeHouse and PSJ expose
virtualized DOM interfaces, but these interfaces can only
export asynchronous methods. Thus, porting DOM-intensive
legacy applications to TreeHouse and PSJ is challenging,
and writing new applications for these frameworks requires
programmers to learn a new set of DOM semantics. In
contrast, Pivot’s synchronous interfaces make it easy to port
old applications and write new ones that use familiar browser
APIs. For example, the Pivot application from Section V-B
accesses DOM storage using the standard synchronous in-
terface.
PostMash [4] is another framework which uses frames
as isolation containers and postMessage() as the cross-
domain communication primitive. To include an untrusted
library, an integrator page includes a JavaScript stub written
by the library’s developer; this stub exports the library’s
API, and implements RPC requests and responses via
postMessage(). Since the stub runs in the integrator’s
frame, it must be trusted. In contrast, Pivot places all code
from untrusted libraries in external frames, meaning that
the integrating master frame does not need to trust any
code from the satellites. Pivot also provides synchronous
interfaces, unlike PostMash. However, PostMash does not
rewrite any code, so it avoids the overhead of the dynamic
checks that Pivot inserts at function call sites.
SMash [15] uses frames as isolation containers, but it
leverages fragment identiﬁers in URLs as the cross-frame
communication primitive. This communication channel
273
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:00:50 UTC from IEEE Xplore.  Restrictions apply. 
leverages the fact that, in older browsers, parent frames and
child frames could modify each other’s URLs, even if they
were from different origins. This technique was popular in
older browsers, before postMessage() was standardized.
However, fragment communication no longer works on
many popular browsers, and postMessage() is now the
standard mechanism for cross-frame communication.
Rewriting-based isolation: Caja [24] and Jigsaw [22] use
code rewriting to safely place mutually untrusting code
within the same frame. Like Pivot, both systems provide
synchronous RPCs. However, Section V shows that Pivot
can provide superior performance by selectively rewriting
code—only the synchronous application core needs to be
rewritten, and untrusted libraries that do not make syn-
chronous RPCs can be left unrewritten (and thus free of
slow, dynamic security checks).
Pivot only supports pass-by-value cross-domain sharing.
In contrast, Caja and Jigsaw provide a brokered form
of pass-by-reference in which a wrapper object mediates
untrusted accesses to a sensitive underlying object.
Converting asynchronous JavaScript
to synchronous
JavaScript: Narrative JS [25] uses rewriting to transform
asynchronous JavaScript code into a pseudo-synchronous
form. However, Narrative JS requires programmers to use
a special syntax for asynchronous calls; more generally,
it requires developers to explicitly reason about how to
safely execute interleaved threads within the same frame.
This breaks the standard JavaScript programming model in
which each frame has only one thread. In contrast, Pivot’s
true synchronous interfaces avoid the race conditions that
are endemic to pseudo-synchronous frameworks [18], [22].
The Narrative JS compiler does not leverage the yield
statement
into the JavaScript engine, so it
has to manually generate JavaScript-level code to manage
generator state, and only top-level functions in call chains
can yield. Narrative JS is not a security framework, so it
does not provide features like cross-domain isolation or RPC
registration interfaces. Similar rewriting solutions include
jwacs [36] and StratiﬁedJS [27].
is built
that
The task.js library uses the built-in yield statement to
provide a cooperatively multithreaded environment within
a single frame [26]. However, only the top-most function
in a call chain is allowed to yield; in contrast, Pivot uses
rewriting to allow any function in a call chain to be an
RPC. task.js requires programmers to explicitly insert yields
and use a special syntax to manage execution threads.
Pivot introduces no new keywords or concurrency semantics.
task.js provides no security mechanisms to isolate untrusted
code, nor does it provide performance isolation—since all
tasks run in the same frame, a buggy or malicious task can
launch a denial-of-service attack on other tasks by spin-
looping.
Other systems: Pivot runs on today’s commodity browsers,
leveraging frames, yield, and postMessage() to provide
synchronous, pass-by-value sharing between domains. The
resulting security model is simple, and a natural ﬁt for
many applications. Other mashup systems provide more
complicated (but more expressive) policy languages. For
example, several frameworks modify the JavaScript engine
to support transactional JavaScript, such that, if untrusted
code violates a security policy, the effects of that code can
be rolled back [8], [29]. Mash-IF [17] uses an IFC approach,
associating each domain’s JavaScript objects with security
labels, and using a modiﬁed browser to track taint and
enforce disclosure policies. OMash [7], object views [18],
Embassies [13], and MashupOS [34] provide additional
models for expressing cross-domain security policies.
VII. CONCLUSIONS
Pivot is a new isolation framework for web applications.
leverages
Pivot uses iframes as isolation containers, but
rewriting to provide synchronous cross-domain RPCs. To
provide synchronicity, Pivot translates a frame’s JavaScript
code into a generator function. These generators are explic-
itly invoked by Pivot’s distributed cross-frame scheduler; this
scheduler layers an RPC mechanism atop postMessage()
calls. Each satellite frame exposes a public interface by reg-
istering local function references with Pivot. When a satellite
issues an RPC, its generator yields to the Pivot scheduler,
which then sends a postMessage() to the satellite that
implements the RPC. When Pivot receives a response, it
restarts the caller’s generator function.
Using the built-in isolation mechanisms provided by
iframes, Pivot can avoid rewriting libraries that respond
to, but do not make, synchronous RPC calls. By only
rewriting an application’s small, trusted core, Pivot avoids
the performance penalties incurred by rewrite-everything
frameworks which have to modify all code to ensure safety.
Experiments show that Pivot RPCs are up to two orders
of magnitude faster than those of Jigsaw, a state-of-the-art
rewrite-everything framework. Compared to other rewriting
solutions that implement pseudo-synchronous RPCs, Pivot
provides true synchrony without forcing developers to use
special function call syntax, a restricted version of the
JavaScript language, or new concurrency semantics.
REFERENCES
[1] B. Adida, A. Barth, and C. Jackson. Rootkits for JavaScript
Environments. In Proceedings of the USENIX Workshop on
Offensive Technologies, Montreal, Canada, August 2009.
[2] A. Adya, J. Howell, M. Theimer, W. Bolosky, and J. Douceur.
Cooperative Task Management without Manual Stack Man-
agement.
In Proceedings of USENIX ATC, Monterey, CA,
June 2002.
[3] D. Akhawe, P. Saxena, and D. Song. Privilege Separation in
HTML5 Applications. In Proceedings of USENIX Security,
Bellevue, WA, August 2012.
274
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:00:50 UTC from IEEE Xplore.  Restrictions apply. 
[4] A. Barth, C. Jackson, and W. Li. Attacks on JavaScript
Mashup Communication. In Proceedings of Web 2.0 Security
and Privacy, Oakland, CA, May 2009.
[20] J. Mickens. Silo: Exploiting JavaScript and DOM Storage
for Faster Page Loads. In Proceedings of USENIX WebApps,
Boston, MA, June 2010.
[5] P. Boere. DOM-Storage-Query-Language: A SQL-inspired
http://code.google.com/p/
interface for DOM Storage.
dom-storage-query-language/, 2011.
[21] J. Mickens. Rivet: Browser-agnostic Remote Debugging for
Web Applications. In Proceedings of USENIX ATC, Boston,
MA, June 2012.
[6] Compuware. Compuware AJAX Edition: Free Web Perfor-
mance Analysis and Debugging Tool. http://www.compuware.
com/en_us/application-performance-management/products/
ajax-free-edition/overview.html, 2014.
[7] S. Crites, F. Hsu, and H. Chen. OMash: Enabling Secure
In Proceedings of
Web Mashups via Object Abstractions.
CCS, Alexandria, VA, October 2008.
[8] M. Dhawan, C.-C. Shan, and V. Ganapathy. Enhancing
JavaScript with Transactions. In Proceedings of the European
Conference on Object-Oriented Programming (ECOOP), Bei-
jing, China, June 2012.
[9] Ecma International. Draft ECMAScript 6 Speciﬁcation:
Generators. http://wiki.ecmascript.org/doku.php?id=harmony:
generators, February 20, 2014.
[10] A. Gavrilov.
Bubblemark animation test: Silverlight
(JavaScript and CLR) vs DHTML vs Flash (Flex) vs WPF
vs Apollo vs Java (Swing). http://bubblemark.com/, 2009.
[11] G. Gherardi. JsonRPCjs. https://github.com/gimmi/jsonrpcjs,
2012.
[12] Google. Google-Caja: Performance of cajoled code. http://
code.google.com/p/google-caja/wiki/Performance, October 4,
2011.
[13] J. Howell, B. Parno, and J. Douceur. Embassies: Radically
Refactoring the Web. In Proceedings of NSDI, Lombard, IL,
April 2013.
[14] L. Ingram and M. Walﬁsh. TreeHouse: JavaScript Sandboxes
to Help Web Developers Help Themselves. In Proceedings
of USENIX ATC, Boston, MA, June 2012.
[15] F. D. Keukelaere, S. Bhola, M. Steiner, S. Chari, and S. Yoshi-
hama. SMash: Secure Component Model for Cross-Domain
Mashups on Unmodiﬁed Browsers. In Proceedings of WWW,
Beijing, China, April 2008.
[16] O. Kiselyov, S. Peyton-Jones, and A. Sabry. Lazy v. Yield: In-
cremental, Linear Pretty-printing. In Proceedings of APLAS,
Kyoto, Japan, December 2012.
[17] Z. Li, K. Zhang, and X. Wang. Mash-IF: Practical
In
Information-Flow Control within Client-side Mashups.
Proceedings of DSN, Chicago, IL, June 2010.
[18] L. Meyerovich, A. Felt, and M. Miller. Object Views: Fine-
In Proceedings of WWW,
grained Sharing in Browsers.
Raleigh, NC, April 2010. ACM.
[19] L. Meyerovich and B. Livshits. ConScript: Specifying and
Enforcing Fine-grained Security Policies for JavaScript in the
Browser. In Proceedings of the IEEE Symposium on Security
and Privacy, Oakland, CA, May 2010.
[22] J. Mickens and M. Finifter.
Mashup Isolation.
Boston, MA, June 2012.
Jigsaw: Efﬁcient, Low-effort
In Proceedings of USENIX WebApps,
[23] J. Mickens, J. Howell, and J. Elson. Mugshot: Deterministic
Capture and Replay for JavaScript Applications. In Proceed-
ings of NSDI, San Jose, CA, April 2010.
[24] M. Miller, M. Samuel, B. Laurie, I. Awad, and M. Stay.
Caja: Safe active content in sanitized JavaScript. Google
white
http://google-caja.googlecode.com/ﬁles/
caja-spec-2008-06-07.pdf, June 7, 2008.
paper.
[25] N. Mix. Narrative JavaScript.
narrativejs, 2014.
http://www.neilmix.com/
[26] Mozilla. task.js: Beautiful Concurrency for JavaScript. https:
//github.com/mozilla/task.js, March 21, 2013.
[27] Oni Labs. StratiﬁedJS: JavaScript plus Structured Concur-
rency. http://onilabs.com/stratiﬁedjs, 2011.
[28] T. Parr. The Deﬁnitive ANTLR Reference. Pragmatic Book-
shelf, Raleigh, North Carolina, 2007.
[29] G. Richards, C. Hammer, F. Nardelli, S. Jagannathan, and
J. Vitek. Flexible Access Control for JavaScript. In Proceed-
ings of OOPSLA, Indianapolis, IN, October 2013.
[30] E. Stark, M. Hamburg, and D. Boneh. Symmetric Cryptog-
raphy in JavaScript. In Proceedings of the Annual Computer
Security Applications Conference (ACSAC), Honolulu, HI,
December 2009.
[31] D. Synodinos. ECMAScript 5, Caja and Retroﬁtting Security:
An Interview with Mark S. Miller. http://www.infoq.com/
interviews/ecmascript-5-caja-retroﬁtting-security,
February
25, 2011.
[32] R. von Behren, J. Condit, F. Zhou, G. Necula, and E. Brewer.
Capriccio: Scalable Threads for Internet Services. In Proceed-
ings of SOSP, Lake George, NY, October 2003.
[33] W3C Web Apps Working Group. Web Storage: W3C Work-
ing Draft. http://www.w3.org/TR/webstorage/, July 30 2013.
[34] H. Wang, X. Fan, J. Howell, and C. Jackson. Protection and
Communication Abstractions for Web Browsers in Mashu-
pOS. In Proceedings of SOSP, Stevenson, WA, October 2007.
[35] Web Hypertext Application Technology Working Group
(WHATWG). HTML Living Standard, Section 4.8.2: The
iframe element.
http://www.whatwg.org/specs/web-apps/
current-work/#attr-iframe-sandbox, March 13, 2014.
[36] J. Wright.
jwacs: Javascript With Advanced Continuation
Support. http://chumsley.org/jwacs/, 2006.
275
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:00:50 UTC from IEEE Xplore.  Restrictions apply.