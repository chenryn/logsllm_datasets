title:SGXJail: Defeating Enclave Malware via Confinement
author:Samuel Weiser and
Luca Mayr and
Michael Schwarz and
Daniel Gruss
SGXJail: Defeating Enclave Malware via Conﬁnement
Samuel Weiser, Luca Mayr, Michael Schwarz, Daniel Gruss
Graz University of Technology
Abstract
Trusted execution environments, such as Intel SGX, allow
executing enclaves shielded from the rest of the system. This
fosters new application scenarios not only in cloud settings
but also for securing various types of end-user applications.
However, with these technologies new threats emerged. Due
to the strong isolation guarantees of SGX, enclaves can effec-
tively hide malicious payload from antivirus software. Were
these scenarios already outlined years ago, we are evidencing
functional attacks in the recent past. Unfortunately, no reason-
able defense against enclave malware has been proposed.
In this work, we present the ﬁrst practical defense mecha-
nism protecting against various types of enclave misbehavior.
By studying known and future attack vectors we identiﬁed
the root cause for the enclave malware threat as a too permis-
sive host interface for SGX enclaves, leading to a dangerous
asymmetry between enclaves and applications. To overcome
this asymmetry, we design SGXJail, an enclave compartmen-
talization mechanism making use of ﬂexible memory access
policies. SGXJail effectively defeats a wide range of enclave
malware threats while at the same time being compatible with
existing enclave infrastructure. Our proof-of-concept software
implementation conﬁrms the efﬁciency of SGXJail on com-
modity systems. We furthermore present slight extensions to
the SGX speciﬁcation, which allow for even more efﬁcient
enclave compartmentalization by leveraging Intel memory
protection keys. Apart from defeating enclave malware, SGX-
Jail enables new use cases beyond the original SGX threat
model. We envision SGXJail not only for site isolation in
modern browsers, i.e., conﬁning different browser tabs but
also for third-party plugin or library management.
1
Introduction
Isolation is an essential element of modern computer systems.
Traditionally, the operating system was responsible for iso-
lating processes. With the emergence of various novel use
cases, further isolation became necessary. For instance, exe-
cuting untrusted JavaScript code demands isolation from the
browser via sandboxing. Also, mutually untrusted services in
the cloud, e.g., from different tenants, run in different contain-
ers or virtual machines. In any case, it is still necessary to trust
system administrators, operating systems, and hypervisors.
Intel addressed this problem with SGX. Intel SGX can
be used to isolate software modules via hardware protected
enclaves from a compromised or malicious administrator, op-
erating system, or hypervisor. The trust anchor in SGX is
only the processor. Even if any other system part is manipu-
lated or compromised, SGX maintains its security guarantees.
This enables new use cases, such as trusted cloud computing,
where tenants do not only distrust the other tenants, but also
the cloud provider and its hardware and software infrastruc-
ture [3, 17, 50]. A similar distrust also exists when protecting
copyrighted material [2] or cryptographic or security-critical
secrets [30, 35, 42] on a compromised user PC or server.
While isolation techniques such as SGX can be an excellent
tool for security, they can also be misused for hiding mali-
cious activity inside an enclave. In the recent past, we have
seen not only enclave malware exploiting side channels [54]
but also enclave ransomware and shellcode [38], however,
with the help of a colluding host application. Recent research
showed that enclaves can effectively hijack and impersonate
any benign host application [53], opening up enclaves for
various types of userspace malware. This conﬁrms what re-
searchers already suspected years ago [13, 16, 48]. Having
witnessed ﬁrst proof-of-concept attacks [38, 53], we can ex-
pect that more sophisticated and real-world attacks will appear
in the future. Hence, it is necessary to providently explore the
defense space, before real-world attacks are discovered.
Unfortunately, little is known about how to address this
emerging threat properly. While conventional programs can
be scanned for misbehavior by anti-virus technology, SGX
is a complete game changer when it comes to enclave anal-
ysis. On the one hand, SGX prevents runtime inspection of
enclaves. On the other hand, SGX allows lazy loading of ma-
licious enclave content at runtime. Thus, malware infection
can be completely decoupled from enclave distribution and
installation, which renders all static analysis techniques on
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 353the enclave void. In other words, SGX is a viable alternative
to malware obfuscation and analysis evasion techniques. If
Intel chose to allow certiﬁed anti-virus software to inspect
enclaves, this would undermine essential security guarantees
and is in fundamental conﬂict with the very goal SGX has [48].
Others proposed to detect enclave malware via their I/O be-
havior [13, 16], which is prone to both false positives and
false negatives. Moreover, tracing and analyzing all enclave
I/O behavior is believed infeasible in practice [38]. Others
proposed to embed malware analysis code within the enclave
itself, which raises several questions regarding its practical-
ity [13]. Consequently,
“[...] the release and adoption of SGX-protected en-
claves is likely to require a completely new approach
to protecting our machines from the very malware
SGX was designed to prevent.” [16]
So far, no practical defense against enclave malware exists.
In this work, we propose the ﬁrst practical defense mecha-
nism against enclave malware. To do so, we analyze enclave
primitives and their resulting attack vectors and identify the
root cause for the enclave malware threat as a too permissive
feature set available to enclaves, forcing applications to trust
any enclaves they host blindly. Consequently, a proper de-
fense mechanism should give applications means to conﬁne
enclave operation to a clearly speciﬁed interface. To that end,
we propose SGXJail, a lightweight yet effective measure to
establish mutual distrust between enclaves and its host ap-
plication. SGXJail does so by conﬁning enclave operation
to a clearly deﬁned set of memory pages. This mitigates en-
tire classes of runtime attacks (ROP, JOP, DOP, etc.) from
the enclave to the host and enables reasoning about enclave
misbehavior purely based on the legitimate communication in-
terface. We instantiate SGXJail using process sandboxing and
syscall ﬁlters and demonstrate its efﬁciency. Furthermore, we
propose HSGXJail, a minimal hardware extension to the SGX
speciﬁcation making use of Intel memory protection keys
to conﬁne enclave execution, which is even more efﬁcient.
(H)SGXJail is opt-in, works on unmodiﬁed enclaves and can
be easily integrated with the SGX software development kit1.
With SGXJail, we expand possible SGX use cases beyond
isolated execution. We envision modern software which is
additionally hardened using SGXJail against potentially mali-
cious or misbehaving third-party code. This is, for example,
vital for all software enabling third-party plugins and add-ons,
such as browsers, mail clients, or password managers.
Contributions. We summarize our contributions as follows.
1. We systematically break down the enclave malware threat
and identify a number of enclave malware primitives.
2. We devise SGXJail, the ﬁrst practical defense against en-
3. We implement and evaluate SGXJail in software.
4. We propose highly efﬁcient HSGXJail via minimal hard-
clave malware.
ware changes.
1The code is available at https://github.com/IAIK/sgxjail
Host application
ECALL FuncE
FuncA()
FuncA()
// do syscall
Return
Return
...
EENTER
EEXIT
EENTER
EEXIT
G
C
FuncE()
OCALL FuncA
G
C
Return
e
v
a
l
c
n
E
Figure 1: SGX enclaves are tightly integrated in a host
application. The application can invoke the enclave via
ECALLs while the enclave can perform OCALLs. En-
claves can only be entered via the EENTER instruction at
certain call gates (CG) and can only be left via EEXIT.
The rest of the paper is organized as follows. Section 2 pro-
vides background information. Section 3 describes the threat
model. Section 4 analyzes various enclave primitives and
attack vectors. Section 5 presents (H)SGXJail. Section 6 dis-
cusses related work. We summarize our discussion of enclave
malware in Section 7 and conclude in Section 8.
2 Background
In this section, we provide background on Intel SGX as well
as runtime attacks.
2.1 Intel SGX
Intel Software Guard Extensions (SGX) are an instruction-set
extension introduced with the Skylake microarchitecture [26].
SGX allows creating so-called enclaves running trusted code
isolated from the remaining system.
Enclaves are hosted by an ordinary application process.
Although the enclave and the host application reside in the
same virtual address space, the address range of the enclave
is inaccessible to the host application. Only the enclave itself
can access its memory while the hardware prevents any other
access to enclave memory. However, the enclave can access
the entire virtual address space of the host application, allow-
ing to share data between the enclave and the host application.
This asymmetry in access permissions ﬁts the original threat
model of SGX but gives rise to enclave malware.
The host application is responsible for loading the enclave
into the current address space and providing an interface
through which the enclave communicates with the outer world.
The CPU measures the loading process to ensure the integrity
of the loaded enclave. The enclave is only executed if the
resulting measurement matches a developer-speciﬁed value.
Figure 1 shows the process of invoking an enclave. The
enclave deﬁnes secure functions denoted as ECALLs, which
the application can call with the EENTER instruction. Call
gates (CG) restrict enclave invocation to valid entry points.
354          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationEnclaves can request OS services such as syscalls via so-
called OCALLs. To leave the enclave, an enclave can issue
the EEXIT instruction. Enclave developers need to specify the
ECALL/OCALL interface via a so-called Enclave Deﬁnition
Language (EDL). Each enclave is shipped with its own EDL
ﬁle. An EDL ﬁle roughly contains function signatures of the
enclave’s ECALLs and OCALLs, augmented with additional
security attributes (e.g., in, out). Intel provides developers
with an SDK [25] that automatically generates glue code from
the EDL ﬁle with appropriate parameter validation and buffer
copying inside the enclave.
SGX assumes that all non-enclave code (i.e., operating
system and host application) is untrusted. SGX provides no
means to protect applications from misbehaving enclaves.
Instead, an enclave can access all application memory and
divert control ﬂow to arbitrary application code via EEXIT.
2.2 Runtime Attacks
While it is typically not possible to directly inject or modify
code at runtime, e.g., via a buffer overﬂow, an attacker can
often manipulate control data and thus change the control ﬂow
of an application. By overwriting a code pointer, an attacker
can divert the control ﬂow to existing code snippets, resulting
in so-called control-ﬂow hijacking attacks. One of the most
generic and powerful attacks is return-oriented programming
(ROP) [55] which overwrites return addresses to create ar-
bitrary attack payloads. Similar attacks exist for overwriting
function pointers [5, 9, 10, 18, 32, 51] or signal handlers [6].
Some widely deployed techniques against code-reuse at-
tacks are address-space layout randomization (ASLR) [45],
stack canaries [14, 46] and shadow stacks [12]. While stronger
control-ﬂow integrity (CFI) [1, 31] can eradicate control-ﬂow
attacks, they leave data-only attacks [8, 28] unaddressed.
3 Threat Model
In this section, we ﬁrst outline various application scenarios
of SGX and argue why the original SGX threat model does
not properly address enclave misbehavior. We then present
our extended SGX threat model addressing enclave malware.
Scenario A. In the near future, SGX technology will likely
permeate consumer systems and create diverse and many-
faceted trust relations. Multiple independent software ven-
dors (ISV) can use SGX for mutually protecting their pro-
prietary library code (e.g., multimedia codecs, classiﬁcation
algorithms) or sensitive customer data (e.g., user passwords,
encryption keys or bitcoin wallets) inside third-party enclaves.
Applications can embed such third-party enclaves to leverage
their functionality.
In this scenario, an attacker develops innocent-looking en-
clave malware (e.g., disguised as browser plugins) and dis-
tributes it as a third-party enclave via existing software stores
or repositories. A user installs those third-party enclaves
alongside other applications. The attacker defers installation
of malicious payload to runtime via a generic loader [48].
Hence, neither the maintainers of software repositories nor
the user can detect this malware before it is actually triggered.
This might not only be invasive malware like ransomware,
bots, or rootkits. A malicious enclave can also stealthily col-
lect data about the user and host system without the user
knowing, and with plausible deniability for the developer. An
enclave developer can then monetize this data, e.g., by selling
it to advertising agencies.
Scenario B. As more software is moved into enclaves,
chances increase for exploitable vulnerabilities within en-
clave code. Enclaves are equipped with increasingly complex
software, such as fully-ﬂedged TLS stacks [24]. Thus, it is
just a matter of time for bugs in the trusted code of enclaves,
enabling well-known memory corruption attacks [56] inside
enclaves. In fact, it has already been shown that enclaves
are prone to such attacks [33, 52, 60]. This can be used to
inﬁltrate trusted enclaves with a malicious payload.
A Holistic Threat Model. The original threat model of Intel
SGX considers all non-enclave code as untrusted, including
application code hosting enclaves (cf. Section 2). This model
might be well-suited from an enclave’s perspective. However,
it does not ﬁt more advanced application scenarios outlined
before, leaving applications completely unprotected against
misbehaving third-party enclaves. This creates a dangerous
asymmetry, as also outlined by Schwarz et al. [53].
In this work, we introduce a more holistic threat model
which does not violate the original threat model of SGX but
augments it to explicitly address misbehaving enclaves. We
consider a commodity system running software from various
independent software vendors. On the one hand, third-party
library vendors protect their secret data (e.g., cryptographic
keys or intellectual property) inside enclaves. On the other
hand, application developers include third-party enclaves in
their applications for implementing various tasks. However,
they want some form of assurance that third-party enclaves are
well-behaving, for the reasons outlined before. While from
an enclave vendor’s perspective SGX provides strong protec-
tion against other enclaves as well as compromised systems,
application developers have no means to assure themselves
of proper behavior of (third-party) enclaves they use.
From a user’s perspective, the computer (including the op-
erating system and certain applications) are trusted. A mecha-
nism is needed to protect applications (and, subsequently the
computer) from potential enclave misbehavior, even if such
enclaves are fully controlled by a dedicated attacker (e.g.,
enclave malware). In particular, an application needs protec-
tion against any inspection or alteration of its state (memory,
CPU registers) by enclaves, apart from what it is exposing to
the enclave via the ECALL/OCALL interface. SGXJail does
not prevent API attacks, exploiting too permissive OCALLs
or badly designed interfaces (e.g., avoiding Iago attacks and
confused deputy attacks), which is a separate, yet important
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 355Table 1: Enclave primitives leading to various attack vec-
tors on the host application.
overview of attacks violating memory safety was presented