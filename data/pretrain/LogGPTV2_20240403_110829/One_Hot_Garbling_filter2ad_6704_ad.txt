ğ‘–
Figure 3: Our central primitive computes the outer product of two values: (1) a one-hot encoded value H(ğ‘) where ğ¸ knows ğ‘
and (2) a value ğ‘. For inputs ğ‘ âˆˆ {0, 1}ğ‘› and ğ‘ âˆˆ {0, 1}ğ‘š, ğº sends to ğ¸ 2(ğ‘› âˆ’ 1) + ğ‘š ciphertexts. Recall from Section 3.3 that ğ» is a
circular correlation robust hash function.
In Section 7, we enumerate a number of useful modules, but we
are confident that we have not found them all. Thus, we provide
a framework for building and using modules: we specify the mod-
ule requirements, and prove that, if met, the module can be used
as a regular gate in GC. Thus GCs can be arbitrarily constructed
from secure modules, without the need for additional proofs. New
modules require proofs; the circuits that use them do not.
5.1 Reveal gates
Our framework introduces a Reveal meta-gate (see Figure 2). Reveal
gates are our frameworkâ€™s method for revealing cleartext values to
ğ¸. The GC may reveal a value to ğ¸ so long as that value is indistin-
guishable from a value drawn from a fixed distribution (more for-
mally, the input and output are together indistinguishable from the
input and the sampled value). To achieve this indistinguishability,
we allow the module designer to specify an arbitrary function that
can apply a mask to the Reveal gate input value. The Reveal gate
samples the mask (which is revealed to ğº) from a designer-specified
distribution. In practice, this is achieved by ğº locally sampling the
mask and programming it into the gate.
The Reveal gate produces as (garbled) output both the mask
and the masked value; crucially, it also reveals in cleartext the
masked value to ğ¸ and the mask to ğº.4 Because the masked value
is indistinguishable from one drawn from a fixed distribution, our
security proofs can simulate ğ¸â€™s view5.
4Values are revealed to ğ¸ via color bits; as noted above, ğº selects the mask himself.
5In this work, we only use Reveal gates that each produce a distribution that is identical
to a fixed distribution, not merely indistinguishable. We allow indistinguishability
because it is more flexible and because it is easily proved secure.
Session 2D: Secure Multiparty ComputationCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea5802
1
, ğ‘¤(cid:1)ğº
OneHot.ev(C, x) takes as input a circuit C and a string ğ‘¥. It outputs a string ğ‘¦. Each gate in a module is handled as follows:
â€¢ For each XOR gate ğ‘¤2 := ğ‘¤0 âŠ• ğ‘¤1 and each one-hot gate ğ‘¤2 := H(ğ‘¤0) âŠ— ğ‘¤1, ev applies the appropriate function and stores the
result in ğ‘¤2. For each constant gate ğ‘¤0 := Constant(ğ‘), ev stores ğ‘ in ğ‘¤0.
â€¢ For each Module ğ‘¤1 := Module[M](ğ‘¤0), OneHot.ev recursively evaluates M on input ğ‘¤0 and stores the result in ğ‘¤1.
â€¢ For each Reveal gate ğ‘¤(cid:1)ğ¸
:= Reveal[C, Dmask](ğ‘¤0), OneHot.ev (1) samples a mask ğ›¼ â† Dmask, (2) recursively evaluates
C with input (ğ‘¤0, ğ›¼), (3) stores the result on wire ğ‘¤1, and (4) stores ğ›¼ on wire ğ‘¤2. Each Color gate ğ‘¤1, ğ‘¤2 := Color(ğ‘¤0) is handled
in the same manner as each Reveal gate except that ğ›¼ is drawn uniformly.
OneHot.Gb(1ğœ…, C) takes as input a circuit C. It outputs an input encoding string ğ‘’, an output decoding string ğ‘‘, and circuit material ğ‘€.
OneHot is a projective garbling scheme [BHR12], so ğ‘’ and ğ‘‘ are standard. When OneHot.Gb is first called, it uniformly draws the global
XOR offset Î” â† {0, 1}ğœ… and sets Î”â€™s least significant bit to one. To generate ğ‘€, OneHot.Gb maintains a garbled share on each circuit
wire. Each gate in a module is handled as follows:
â€¢ For each XOR gate ğ‘¤2 := ğ‘¤0 âŠ• ğ‘¤1, OneHot.Gb generates the output sharing by XORing the two input sharings (see Lemma 3.5).
â€¢ For each one-hot gate ğ‘¤2 := H(ğ‘¤0) âŠ— ğ‘¤1, OneHot.Gb runs ğºâ€™s steps as described in Figure 3. When Figure 3 indicates ğº should
â€¢ For each constant gate ğ‘¤0 := Constant(ğ‘), OneHot.Gb sets ğ‘¤0 to ğ‘Î”.
â€¢ For each Module, OneHot.Gb recursively garbles.
â€¢ For each Reveal gate ğ‘¤(cid:1)ğ¸
:= Reveal[C, Dmask](ğ‘¤0), Gb samples a mask ğ›¼ â† Dmask and sets the share ğ‘¤2 to ğ›¼Î”. The
procedure recursively garbles the subcircuit C with appropriate input shares and stores the output shares in ğ‘¤1. Finally, the
procedure evaluates Color(ğ‘¤1) and attaches the result to ğ‘€: informally, this reveals the masked output to ğ¸.
send a message to ğ¸, OneHot.Gb appends the message to ğ‘€.
, ğ‘¤(cid:1)ğº
â€¢ For each Color gate ğ‘¤1, ğ‘¤2 := Color(ğ‘¤0), Gb computes Color(ğ‘¤0) and stores Color(ğ‘¤0)Î” in ğ‘¤2. It then stores ğ‘¤2 âŠ• ğ‘¤0 in ğ‘¤1.
OneHot.Ev(C, ğ‘€, ğ‘‹) takes as input a circuit C, material ğ‘€, and encoded input ğ‘‹. It outputs encoded output ğ‘Œ. OneHot.Ev maintains
ğ¸â€™s garbled share on circuit wires, propagating them through each gate in a module as follows:
for this call to be legal. When Figure 3 indicates ğº should send a message to ğ¸, OneHot.Ev parses the message from ğ‘€.
â€¢ For each XOR gate ğ‘¤2 := ğ‘¤0 âŠ• ğ‘¤1, OneHot.Ev generates the output share by XORing the two input shares (see Lemma 3.5).
â€¢ For each one-hot gate ğ‘¤2 := H(ğ‘¤0) âŠ— ğ‘¤1, OneHot.Ev runs ğ¸â€™s steps as described in Figure 3. Note, ğ‘¤0 must have been revealed
â€¢ For each Constant gate ğ‘¤0 := Constant(ğ‘), OneHot.Ev sets ğ‘¤0 to zero. Note, ğ¸ need not know ğ‘.
â€¢ For each Module, OneHot.Ev recursively evaluates.
â€¢ For each Reveal gate ğ‘¤(cid:1)ğ¸
:= Reveal[C, Dmask](ğ‘¤0), Ev sets ğ‘¤2 to zero. The procedure recursively evaluates the subcircuit
C with appropriate input shares and stores the output shares in ğ‘¤1. Finally, the procedure parses ğºâ€™s color bits col from ğ‘€ (see
Gb above), computes Color(ğ‘¤1) âŠ• col, and as a side-effect outputs this value: i.e, the value ğ‘¤1 is revealed.
â€¢ For each Color gate ğ‘¤1, ğ‘¤2 := Color(ğ‘¤0), Ev computes Color(ğ‘¤0) and outputs this value to ğ¸. Color sets ğ‘¤1 to ğ‘¤0 and ğ‘¤2 to zero.
OneHot.En(ğ‘’, ğ‘¥) takes as input an encoding string ğ‘’ and cleartext input ğ‘¥; it outputs encoded input ğ‘‹. En maps each bit ğ‘¥ğ‘– to ğ‘‹ğ‘– âŠ• ğ‘¥ğ‘– Î”
for uniform ğ‘‹ğ‘–.
OneHot.De(ğ‘‘, ğ‘Œ) takes as arguments a decoding string ğ‘‘ and an encoded output ğ‘Œ; it outputs a cleartext output ğ‘¦. We ensure that for
each output bit ğ‘¦ğ‘–, ğ‘‘ holds the following two strings:
, ğ‘¤(cid:1)ğº
1
2
1
2
ğ»(ğ‘Œğ‘–, nonce)
ğ»(ğ‘Œğ‘– âŠ• Î”, nonce)
where nonce is a fresh nonce. De hashes ğ‘Œ and outputs 0 or 1 depending on which above string matches. If neither matches, De aborts.
Figure 4: Our garbling scheme algorithms. We describe the handling of gates G (Equation (2)) inside of modules. Circuit/module
handling is achieved by the repeated handling of gates. Note that our scheme does not directly provide XOR/AND gates to
top-level circuits. However, these standard gates can be formalized as modules in our framework (see Section 5.4). Recall, in our
notation wires hold matrices of bits.
We do not wish to restrict masking methods (in this work we
mask via XORing, adding, and multiplying). Reveal gates can im-
plement arbitrary masking by way of the circuit C (see Figure 2).
5.1.1 Color Gates and Connection to [ZRE15]. The half-gates tech-
nique views the color (see Section 3.2.2) of a GC label as a masked
cleartext value, where the mask is known to ğº. They use this ob-
servation to help implement efficient AND gates.
Reveal gates can be viewed as a generalization of this simple
masking: we allow arbitrary masks, and the chosen mask can be
tailored to the application.
Reveal gates require ğº to send bits to ğ¸ to reveal the output.
Color bits do not require extra sending from ğº to ğ¸: the revealed
value is implicit. We view color-based masking as a special case;
for completeness, we include a special Color gate. At the interface,
Color gates are the same as Reveal gates, except that they do not
need a designer-specified distribution Dmask or circuit C. Color
gates can be viewed as a specific instantiation of a Reveal gate.
Formally, a Color gate takes as input a matrix(cid:74)ğ‘(cid:75). Let ğ›¼ be the
color of ğºâ€™s share: ğ›¼ = Color(ğ´). The gate outputs (1)(cid:74)ğ‘ âŠ• ğ›¼(cid:75)
and (2)(cid:74)ğ›¼(cid:75). The gate â€œrevealsâ€ ğ›¼ to ğº and ğ‘ âŠ• ğ›¼ to ğ¸. Of course,
the parties already knew these values, so no communication is
Session 2D: Secure Multiparty ComputationCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea581required â€“ the Color gate is merely a formalism that allows modules
to syntactically manipulate colors.
5.2 Modules
Reveal gates and Color gates do not encapsulate sensitive data that
might be misused.
As an example, suppose the module designer specifies a Reveal
gate that applies a uniform XOR mask ğ›¼ to a bit ğ‘: thus ğ¸ learns
ğ‘ âŠ• ğ›¼. Now suppose the designer inadvertently specifies that ğ›¼ is
an output of the overall circuit. Because ğ‘ âŠ• ğ›¼ was revealed to ğ¸,
this leaks ğ‘ to ğ¸!
To achieve a clean modular GC framework, we must prevent
sensitive values (i.e. values that depend on random masks) from
escaping the context where they are used. Thus, we introduce the
concept of Modules. A Module is a subroutine that computes a
specific function of its input and that encapsulates internal data.
A Module is parameterized over a module-designer-provided
circuit. It simply passes its input to this circuit and then propagates
the output. So far, this is trivial. However, we require that the mod-
ule designer provide a proof of correctness demonstrating that the
internal circuit implements a deterministic function of its argument.
This will, in particular, guarantee that the output is independent of
internal random masks; thus, masks cannot escape the module.
Top level circuits are only allowed to manipulate modules. I.e.,
our one-hot outer product primitive, Reveal gates, and Color gates
are syntactically prohibited outside of modules. This restriction
means (we prove this) that top level circuits may use modules
without any extra proofs, and so are suitable for end users.
5.3 Formal Syntax
We now formalize our syntax. Specifically, we formalize the space of
circuits C, the space of modules M, and the space of gates allowed
in modules G. Because we wish to allow modules to use other,
simpler modules (i.e., one module designer should be allowed to
use the work of another) our syntax is inductively defined.
As stated above, top level circuits are only allowed to manipulate
modules. Formally, a circuit C is an ordered list of modules with
specified input and output wires. Modules can manipulate lower
level gates. A module M is a list of gates with accompanying input
and output wires. Modules do not directly manipulate garbled shares,
etc (Section 4.4).
We provide a grammar for the gates allowed inside of modules.
Let each ğ‘¤ğ‘– denote a wire that holds a matrix of bits of arbitrary
dimension. When a wire ğ‘¤ğ‘–â€™s cleartext value is revealed to ğº (resp.
ğ¸), we write ğ‘¤(cid:1)ğº
). When a wire is revealed, it remains
a valid garbled sharing and can be used inside a module. Let Dmask
refer to an arbitrary distribution over a finite set of values. Let ğ‘
refer to a constant chosen by ğº:
G â‰œ ğ‘¤2 := ğ‘¤0 âŠ• ğ‘¤1
(resp. ğ‘¤(cid:1)ğ¸
ğ‘–
ğ‘–
| ğ‘¤2 := H(ğ‘¤0) âŠ— ğ‘¤1
| ğ‘¤0 := Constant(ğ‘)
| ğ‘¤(cid:1)ğ¸
:= Reveal[C, Dmask](ğ‘¤0)
| ğ‘¤(cid:1)ğ¸
:= Color(ğ‘¤0)
| ğ‘¤1 := Module[M](ğ‘¤0)
, ğ‘¤(cid:1)ğº
, ğ‘¤(cid:1)ğº
1
2
1
2
(2)
That is, modules can use gates that (1) compute the XOR of two
matrices (of equal dimension), (2) compute the one-hot outer prod-
uct of two vectors, (3) output a constant chosen by ğº, (4) reveal a
masked value to ğ¸ (see Figure 2), (5) incorporate a shareâ€™s color in
the GC (see Section 5.1.1), and (6) recursively call another module.
We refer to one-hot outer product gates simply as â€˜one-hotâ€™ gates.
We specify two requirements each module must satisfy.
Reqirement 1 (Module correctness). For module M com-
puting function ğ‘“ , it must hold that for all inputs ğ‘¥:
ğ‘“ (ğ‘¥) = M(ğ‘¥)
, ğ‘¤(cid:1)ğº
Reqirement 2 (Reveal indistinguishability). For a Reveal
gate ğ‘¤(cid:1)ğ¸
:= Reveal[C, Dmask](ğ‘¤0), there must exist a distri-
bution Dout such that for all inputs ğ‘¥ on wire ğ‘¤0 and for ğ‘Ÿ â† Dout
and ğ›¼ â† Dmask the following indistinguishability holds:
1
2
{ğ‘¥, C(ğ‘¥, ğ›¼)} ğ‘
= {ğ‘¥, ğ‘Ÿ}
Note, each module may have more than one Reveal gate, so it
may not be a priori clear that arbitrary Reveal gate interactions are
secure. For instance, is it safe to feed the output of one Reveal gate
as input to another? From Requirement 2, we can prove that every-
thing revealed in a module can be simulated by a fixed distribution.
We then (Theorem 5.5) prove that this is sufficient for security.
Lemma 5.1. Let M be a module and let ğ‘¦ be the tuple of all values
revealed to ğ¸ in M due to Reveal gates and Color gates (as formally
specified by OneHot.Ev). There exists a distribution Drev such that:
{ğ‘¦} ğ‘
= {ğ‘Ÿ}
where ğ‘Ÿ â† Drev
Specifically, Drev is the distribution that samples from each
Reveal gate distribution Dout (and samples a uniform distribution
in the case of Color gates) and concatenates the samples. Due to
lack of space, we prove Lemma 5.1 in Appendix A.
gate that XORs the two bits of its input and outputs the result.
5.4 Standard Boolean Gates in Our Framework
Neither XOR nor AND are by default available to top level circuits.
However, these functions can be expressed as modules, and thus
traditional Boolean circuits are compatible with our framework:
XOR is easily handled by building a module with a single XOR
AND is conspicuously missing from G. We do not need a separate
AND gate primitive, because we can express AND as a module.
Moreover, the resulting module is functionally identical to the state-
of-the-art half-gates technique [ZRE15]. Namely, our approach uses
the same number of calls to ğ» for each party and transfers the same
number of ciphertexts (i.e., two) from ğº to ğ¸.
Let ğ‘, ğ‘ be bits, and view them as one element vectors. Let ğ›¼, ğ›½
denote the color of ğ‘, ğ‘ respectively. Note the following equality:
(T (id) Â· H(ğ‘ âŠ• ğ›¼) âŠ— ğ‘) âŠ• (T (id) Â· H(ğ‘ âŠ• ğ›½) âŠ— ğ›¼) âŠ• ğ›¼ğ›½
= ((ğ‘ âŠ• ğ›¼) âŠ— ğ‘) âŠ• ((ğ‘ âŠ• ğ›½) âŠ— ğ›¼) âŠ• ğ›¼ğ›½
= ((ğ‘ âŠ• ğ›¼)ğ‘) âŠ• ((ğ‘ âŠ• ğ›½)ğ›¼) âŠ• ğ›¼ğ›½
= ğ‘ğ‘
Thus, we can compute ğ‘ğ‘ via two Color gates (to compute and
reveal ğ‘âŠ•ğ›¼ and ğ‘âŠ•ğ›½), two one-hot gates, one Constant gate (for ğ›¼ğ›½),
and XOR gates (to compute T (ğ‘–ğ‘‘)Â·). Each of these sub-components
Session 2D: Secure Multiparty ComputationCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea582is communication free except for the one-hot gates. A one-hot gate
uses 2(ğ‘› âˆ’ 1) + ğ‘š ciphertexts; here, in both cases ğ‘› = ğ‘š = 1, so the
module costs a total of two ciphertexts.
Thus, [ZRE15] half-gates can be hosted in our framework.
5.5 The OneHot Garbling Scheme
Now that we have established syntax, we prove the framework
secure. We formalize our framework as a garbling scheme [BHR12].