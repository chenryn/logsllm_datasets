缓存负责对这些首部进行改造，以便与客户端的要求相匹配。比如，服务器返回
的可能是一条HTTP/1.0响应（甚至是HTTP/0.9响应），而客户端期待的是一条
HTTP/1.1响应，在这种情况下，缓存必须对首部进行相应的转换。缓存还会向其中
插入新鲜度信息（Cache-Control、Age以及Expires首部），而且通常会包含一
个Via首部来说明请求是由一个代理缓存提供的。
注意，缓存不应该调整Date首部。Date首部表示的是原始服务器最初产生这个对
象的日期。
7.7.6 第六步——发送
一旦响应首部准备好了，缓存就将响应回送给客户端。和所有代理服务器一样，代
理缓存要管理与客户端之间的连接。高性能的缓存会尽力高效地发送数据，通常可
以避免在本地缓存和网络I/O缓冲区之间进行文档内容的复制。
7.7.7 第七步——日志
大多数缓存都会保存日志文件以及与缓存的使用有关的一些统计数据。每个缓存事
务结束之后，缓存都会更新缓存命中和未命中数目的统计数据（以及其他相关的度
量值），并将条目插入一个用来显示请求类型、URL和所发生事件的日志文件。
最常见的缓存日志格式为Squid日志格式和网景的可扩展通用日志格式，但很多缓
存产品都允许用户创建自定义的日志文件。第21章探讨了日志文件格式。 174
7.7.8 缓存处理流程图
图7-12以简化形式显示了缓存是如何处理请求，以GET一个URL的。12
7.8 保持副本的新鲜
可能不是所有的已缓存副本都与服务器上的文档一致。毕竟，这些文档会随着时间
发生变化。报告可能每个月都会变化。在线报纸每天都会发生变化。财经数据可能
每过几秒钟就会发生变化。如果缓存提供的总是老的数据，就会变得毫无用处。已
缓存数据要与服务器数据保持一致。
HTTP有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情
注12： 可以通过条件请求在一步里完成图7-12列出的资源再验证及获取（参见7.8.4节）。
缓 存 ｜ 183
况下，保持已缓存数据与服务器数据之间充分一致。HTTP将这些简单的机制称为
文档过期（document expiration）和服务器再验证（server revalidation）。
请求到达
否
是否已缓存？
是
否 否
是否足够新鲜？ 与服务器进行再验证 再验证过了？ 从服务器获取
是 是
对已缓存文档的
存入缓存
新鲜度进行更新
提供给客户端
图7-12 缓存GET请求的流程图
7.8.1 文档过期
通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向
每个文档附加了一个“过期日期”（参见图7-13）。就像一夸脱牛奶上的过期日期一
175 样，这些首部说明了在多长时间内可以将这些内容视为新鲜的。
HTTP/1.0 200 OK HTTP/1.0 200 OK
Date: Sat, 29 Jun 2002, 14:30:00 GMT Date: Sat, 29 Jun 2002, 14:30:00 GMT
Content-type: text/plain Content-type: text/plain
Content-length: 67 Content-length: 67
Expires: Fri, 05 Jul 2002, 05:00:00 GMT Cache-Control: max-age=484200
Independence Day sale at Joe's Hardware Independence Day sale at Joe's Hardware
Come shop with us today! Come shop with us today!
（a）Expires首部 （b）Cache-Control：max-age首部
图7-13 Expires首部和Cache-Control首部
在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联
系——当然，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。但一
旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果
被修改过，就要获取一份新鲜（带有新的过期日期）的副本。
184 ｜ 第7章
7.8.2 过期日期和使用期
服务器用HTTP/1.0+的Expires首部或HTTP/1.1的Cache-Control: max-age响应首
部来指定过期日期，同时还会带有响应主体。Expires首部和Cache-Control:
max-age首部所做的事情本质上是一样的，但由于Cache-Control首部使用的是
相对时间而不是绝对日期，所以我们更倾向于使用比较新的Cache-Control首部。
绝对日期依赖于计算机时钟的正确设置。表7-2列出了各种过期响应首部。
表7-2 过期响应首部
首 部 描 述
Cache-Control:max-age max-age值定义了文档的最大使用期——从第一次生成文档到文档不再新
鲜、无法使用为止，最大的合法生存时间（以秒为单位）
Cache-Control: max-age=484200
Expires 指定一个绝对的过期日期。如果过期日期已经过了，就说明文档不再新鲜了
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
假设今天是美国东部标准时间（EST，Eastern Standard Time）2002年6月29日上
午9∶30，Joe的五金商店正在准备进行7月4日（美国国庆日）特卖（只剩5天
了）。Joe想在他的Web服务器上放置一个特殊的Web页面，并将其设置为2002年
7月5日晚上的EST午夜时间过期。如果Joe的服务器使用的是老式的Expires首
部，服务器响应报文（参见图7-13a）中可能就会包含这个首部：13
Expires: Fri, 05 Jul 2002, 05:00:00 GMT 176
如果Joe的服务器使用了较新的Cache-Control: max-age首部，服务器响应报文
（参见图7-13b）中可能就会包含这个首部：
Cache-Control: max-age=484200
如果这还不够明确的话，可以这样来看，当前时间，EST时间2002年6月29日早上
9∶30，到售卖结束时间2002年7月5日午夜之间有484 200秒。到售卖结束之前还
有134.5小时（大约5天）。每小时有3600秒，这样到售卖结束之前还有484 200秒。
7.8.3 服务器再验证
仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有
注13： 所有HTTP日期和时间都会在格林尼治标准时间（GMT）过期。GMT是穿过英国格林尼治的本
初子午线（经度为零）上的时间。GMT比美国东部标准时间早五个小时，因此EST的午夜就是
05∶00GMT。
缓 存 ｜ 185
实际的区别；这只是意味着到了要进行核对的时间了。这种情况被称为“服务器再
验证”，说明缓存需要询问原始服务器文档是否发生了变化。
• 如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在
旧文档的位置上，然后将文档发送给客户端。
• 如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过
期日期，并对缓存中的首部进行更新就行了。
这是个很棒的系统。缓存并不一定要为每条请求验证文档的有效性——只有在文档
过期时它才需要与服务器进行再验证。这样不会提供陈旧的内容，还可以节省服务
器的流量，并拥有更好的用户响应时间。
HTTP协议要求行为正确的缓存返回下列内容之一：
• “足够新鲜”的已缓存副本；
• 与服务器进行过再验证，确认其仍然新鲜的已缓存副本；
• 如果需要与之进行再验证的原始服务器出故障了，就返回一条错误报文14；
• 附有警告信息说明内容可能不正确的已缓存副本。
7.8.4 用条件方法进行再验证
HTTP的条件方法可以高效地实现再验证。HTTP允许缓存向原始服务器发送一个
“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主
体。通过这种方式，将新鲜度检测和对象获取结合成了单个条件GET。向GET请
求报文中添加一些特殊的条件首部，就可以发起条件GET。只有条件为真时，Web
177 服务器才会返回对象。
HTTP 定义了 5 个条件请求首部。对缓存再验证来说最有用的 2 个首部是 If-
Modified-Since和If-None-Match。15所有的条件首部都以前缀“If-”开头。表
7-3列出了在缓存再验证中使用的条件请求首部。
注14： 如果原始服务器不可访问，但缓存需要进行再验证，那么缓存就必须返回一条错误或一条用来描述
通信故障的警告报文。否则，来自已移除服务器上的页面未来可能会在网络的缓存中存留任意长的
时间。
注15： 其他条件首部包括If-Unmodified-Since（在进行部分文件的传输时，获取文件的其余部分之前
要确保文件未发生变化，此时这个首部是非常有用的）、If-Range（支持对不完整文档的缓存）和
If-Match（用于与Web服务器打交道时的并发控制）。
186 ｜ 第7章
表7-3 缓存再验证中使用的两个条件首部
首 部 描 述
If-Modified-Since: 如果从指定日期之后文档被修改过了，就执行请求的方法。可以与
Last-Modified服务器响应首部配合使用，只有在内容被修改后与已
缓存版本有所不同的时候才去获取内容
If-None-Match: 服务器可以为文档提供特殊的标签（参见ETag），而不是将其与最近修
改日期相匹配，这些标签就像序列号一样。如果已缓存标签与服务器文
档中的标签有所不同，If-None-Match首部就会执行所请求的方法
7.8.5 If-Modified-Since:Date再验证
最常见的缓存再验证首部是If-Modified-Since。If-Modified-Since再验证请
求通常被称为IMS请求。只有自某个日期之后资源发生了变化的时候，IMS请求才
会指示服务器执行请求：
• 如果自指定日期后，文档被修改了，If-Modified-Since条件就为真，通常
GET就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信
息之外，还包含了一个新的过期日期。
• 如果自指定日期后，文档没被修改过，条件就为假，会向客户端返回一个小
的304 Not Modified响应报文，为了提高有效性，不会返回文档的主体。16这
些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如，
Content-Type首部通常不会被修改，所以通常不需要发送。一般会发送一个
新的过期日期。
If-Modified-Since首部可以与Last-Modified服务器响应首部配合工作。原始
服务器会将最后的修改日期附加到所提供的文档上去。当缓存要对已缓存文档进行
再验证时，就会包含一个If-Modified-Since首部，其中携带有最后修改已缓存副
本的日期： 178
If-Modified-Since: 
如果在此期间内容被修改了，最后的修改日期就会有所不同，原始服务器就会回送
新的文档。否则，服务器会注意到缓存的最后修改日期与服务器文档当前的最后修
改日期相符，会返回一个304 Not Modified响应。
注16： 如果有一个不认识If-Modified-Since首部的老服务器收到了条件请求，它会将其作为一个普通
的GET解释。在这种情况下，系统仍然能够工作，但由于要对未修改的文档数据进行不必要的传输，
所以效率会比较低。
缓 存 ｜ 187
例如，如图7-14所示，如果你的缓存在7月3日对Joe的五金商店的7月4日特卖
声明进行再验证，就会收到一条Not Modified响应（参见图7-14a）。但如果你的缓
存在7月5日午夜售卖结束后对文档进行再验证，缓存就会收到一个新文档，因为
服务器内容已经发生了变化（参见图7-14b）。
条件请求
GET /announce.html HTTP/1.0
If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT
HTTP/1.0 304 Not Modified
客户端 服务器
Date: Wed, 03 Jul 2002, 19:18:23 GMT
Expires: Fri, 05 Jul 2002, 14:30:00 GMT
响应
（a）If-Modified-Since成功的再验证
条件请求
GET /announce.html HTTP/1.0
If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT
HTTP/1.0 200 OK
客户端 服务器
Date: Fri, 05 Jul 2002, 17:54:40 GMT
Content-type: text/plain
Content-length: 124
Expires: Mon, 09 Sep 2002, 05:00:00 GMT
All exterior house paint on sale through
Labor Day. Just another reason for you
to shop this summer at Joe's Hardware!
响应
（b）If-Modified-Since失败的再验证
图7-14 如果未发生变化，If-Modified-Since再验证会返回304响应，如果发生了变化，
就返回带有新主体的200响应
注意，有些Web服务器并没有将If-Modified-Since作为真正的日期来进行比
对。相反，它们在IMS日期和最后修改日期之间进行了字符串匹配。这样得到的语
义就是“如果最后的修改不是在这个确定的日期进行的”，而不是“如果在这个日期
179 之后没有被修改过”。将最后修改日期作为某种序列号使用时，这种替代语义能够很
好地识别出缓存是否过期，但这会妨碍客户端将If-Modified-Since首部用于真
正基于时间的一些目的。
188 ｜ 第7章
7.8.6 If-None-Match：实体标签再验证
有些情况下仅使用最后修改日期进行再验证是不够的。
• 有些文档可能会被周期性地重写（比如，从一个后台进程中写入），但实际包含
的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。
• 有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重
装数据（比如对拼写或注释的修改）。
• 有些服务器无法准确地判定其页面的最后修改日期。
• 有些服务器提供的文档会在亚秒间隙发生变化（比如，实时监视器），对这些服
务器来说，以一秒为粒度的修改日期可能就不够用了。
为了解决这些问题，HTTP允许用户对被称为实体标签（ETag）的“版本标识符”
进行比较。实体标签是附加到文档上的任意标签（引用字符串）。它们可能包含了文
档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。
当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，
如果实体标签被修改了，缓存就可以用If-None-Match条件首部来GET文档的新
副本了。
在图7-15中，缓存中有一个实体标签为v2.6的文档。它会与原始服务器进行再验
证，如果标签v2.6不再匹配，就会请求一个新对象。在图7-15中，标签仍然与之