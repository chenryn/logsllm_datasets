### 缓存对响应首部的处理

缓存负责调整这些首部，以满足客户端的要求。例如，如果服务器返回的是HTTP/1.0响应（甚至是HTTP/0.9响应），而客户端期望的是HTTP/1.1响应，缓存必须对首部进行相应的转换。此外，缓存会插入新鲜度信息（如Cache-Control、Age和Expires首部），并通常会在响应中添加一个Via首部，以表明请求是由代理缓存提供的。

需要注意的是，缓存不应修改Date首部，因为该首部表示原始服务器最初生成对象的日期。

### 第六步：发送响应

一旦响应首部准备就绪，缓存将把响应回传给客户端。像所有代理服务器一样，代理缓存需要管理与客户端之间的连接。高性能的缓存会尽量高效地发送数据，通常可以避免在本地缓存和网络I/O缓冲区之间复制文档内容。

### 第七步：日志记录

大多数缓存都会保存日志文件，并记录与缓存使用相关的统计数据。每个缓存事务结束后，缓存会更新命中和未命中的统计数字（以及其他相关指标），并将条目插入一个显示请求类型、URL和事件的日志文件中。最常见的缓存日志格式包括Squid日志格式和网景的可扩展通用日志格式，但许多缓存产品允许用户自定义日志文件格式。关于日志文件格式的详细讨论，请参见第21章。

### 缓存处理流程图

图7-12展示了缓存如何处理GET请求的简化流程。

### 保持副本的新鲜度

并非所有的已缓存副本都与服务器上的文档一致，因为这些文档会随时间发生变化。例如，报告可能每月更新一次，在线报纸每天更新，财经数据可能每几秒钟更新一次。如果缓存总是提供旧的数据，它将变得毫无用处。因此，已缓存数据必须与服务器数据保持一致。

HTTP提供了简单的机制，可以在不要求服务器记住哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据的一致性。这些机制被称为文档过期和服务器再验证。

#### 文档过期

通过特殊的HTTP Cache-Control首部和Expires首部，HTTP允许原始服务器为每个文档附加一个“过期日期”。类似于牛奶上的过期日期，这些首部指定了内容被视为新鲜的时间段。

#### 过期日期和使用期

服务器可以使用HTTP/1.0+的Expires首部或HTTP/1.1的Cache-Control: max-age响应首部来指定过期日期。这两个首部本质上是相同的，但由于Cache-Control首部使用相对时间而不是绝对日期，我们更倾向于使用较新的Cache-Control首部。表7-2列出了各种过期响应首部及其描述。

#### 服务器再验证

仅仅是因为已缓存文档过期，并不意味着它与原始服务器上的当前文档有实际差异；这只是意味着到了需要核对的时间。这种情况称为“服务器再验证”，缓存需要询问原始服务器文档是否发生了变化。

- 如果再验证显示内容发生了变化，缓存会获取新的文档副本，并替换旧文档。
- 如果再验证显示内容没有变化，缓存只需获取新的首部（包括新的过期日期）并更新缓存中的首部。

#### 用条件方法进行再验证

HTTP的条件方法可以高效地实现再验证。缓存可以通过向原始服务器发送“条件GET”请求来检查文档是否被修改。只有当文档被修改时，服务器才会回送对象主体。常用的条件请求首部包括If-Modified-Since和If-None-Match。表7-3列出了在缓存再验证中使用的条件请求首部及其描述。

#### If-Modified-Since: Date 再验证

最常见的缓存再验证首部是If-Modified-Since。只有自某个日期之后资源发生了变化时，IMS请求才会指示服务器执行请求。如果自指定日期后文档被修改了，条件为真，通常GET会成功执行，新文档会被返回给缓存。如果自指定日期后文档没有被修改，条件为假，服务器会返回一个小的304 Not Modified响应报文。

#### If-None-Match: 实体标签再验证

在某些情况下，仅使用最后修改日期进行再验证是不够的。为了解决这些问题，HTTP允许比较称为实体标签（ETag）的“版本标识符”。实体标签是附加到文档上的任意标签，可能包含文档的序列号、版本名或内容的校验和。当发布者修改文档时，可以修改实体标签来表示新版本。如果实体标签被修改，缓存可以用If-None-Match条件首部来获取文档的新副本。