2012.
[5] J. B. Almeida, M. Barbosa, G. Barthe, and F. Dupres-
soir. Certiﬁed computer-aided cryptography: eﬃcient
provably secure machine code from high-level imple-
mentations. In CCS 2013, 2013.
[6] T. Amtoft, J. Dodds, Z. Zhang, A. W. Appel,
L. Beringer, J. Hatcliﬀ, X. Ou, and A. Cousino. A
certiﬁcate infrastructure for machine-checked proofs of
conditional information ﬂow.
In POST 2012, volume
7215 of LNCS, pages 369–389. Springer, 2012.
[7] L. O. Andersen. Program analysis and specialization for
the C programming language. PhD thesis, 1994.
[8] A. Azevedo de Amorim, N. Collins, A. DeHon, D. De-
mange, C. Hri¸tcu, D. Pichardie, B. C. Pierce, R. Pol-
lack, and A. Tolmach. A veriﬁed information-ﬂow ar-
chitecture. In POPL 2014. ACM, 2014.
[9] A. Banerjee and D. Naumann. Stack-based access con-
trol for secure information ﬂow. Journal of Functional
Programming, 15:131–177, Mar. 2005. Special Issue on
Language-Based Security.
[10] G. Barthe, G. Betarte, J. Campo, and C. Luna. For-
mally verifying isolation and availability in an idealized
model of virtualization.
In FM 2011, pages 231–245.
Springer-Verlag, 2011.
[11] G. Barthe, G. Betarte, J. Campo, and C. Luna. Cache-
Leakage Resilient OS Isolation in an Idealized Model of
Virtualization. In CSF 2012, pages 186–197, 2012.
[12] G. Barthe, G. Betarte, J. D. Campo, C. Luna,
and D. Pichardie. System-level non-interference for
constant-time cryptography (full version), 2014.
[13] G. Barthe, B. Gr´egoire, S. Heraud, and S. Zanella-
B´eguelin. Computer-aided security proofs for the work-
ing cryptographer. In CRYPTO 2011, volume 6841 of
LNCS, Heidelberg, 2011.
[14] G. Barthe, B. K¨opf, L. Mauborgne, and M. Ochoa.
Leakage resilience against concurrent cache attacks. In
POST, 2014.
[15] G. Barthe, D. Pichardie, and T. Rezk. A certiﬁed
lightweight non-interference java bytecode veriﬁer. In
ESOP 2007, pages 125–140, 2007.
[16] G. Barthe, T. Rezk, and D. A. Naumann. Deriving
an information ﬂow checker and certifying compiler for
java.
In S&P 2006, pages 230–242. IEEE Computer
Society, 2006.
[17] D. J. Bernstein. Cache-timing attacks on AES, 2005.
Available from author’s webpage.
[18] K. Bhargavan, C. Fournet, and A. D. Gordon. Modu-
lar veriﬁcation of security protocol code by typing. In
POPL 2010. ACM, 2010.
[19] J. Bonneau and I. Mironov. Cache Collision Timing
Attacks Against AES. In CHES ’06, 2006.
[20] D. Cad´e and B. Blanchet. From computationally-
proved protocol speciﬁcations to implementations. In
ARES 2012, pages 65–74. IEEE Computer Society,
2012.
[21] A. Canteaut, C. Lauradoux, and A. Seznec. Under-
standing cache attacks. Rapport de recherche RR-5881,
INRIA, 2006.
[22] T. Chardin, P.-A. Fouque, and D. Leresteux. Cache
timing analysis of RC4. In ACNS 2011, volume 6715 of
LNCS, pages 110–129, 2011.
[23] J. Chen, R. Chugh, and N. Swamy. Type-preserving
compilation of end-to-end veriﬁcation of security en-
forcement. In PLDI 2010, pages 412–423. ACM, 2010.
[24] B. Coppens, I. Verbauwhede, K. D. Bosschere, and
B. D. Sutter. Practical mitigations for timing-based
side-channel attacks on modern x86 processors. In S&P
2009, pages 45–60, 2009.
[25] M. Dam, R. Guanciale, N. Khakpour, H. Nemati, and
O. Schwarz. Formal veriﬁcation of information ﬂow se-
curity for a simple ARM-based separation kernel.
In
CCS 2013, pages 223–234, 2013.
[26] G. Doychev, D. Feld, B. K¨opf, L. Mauborgne, and
J. Reineke. Cacheaudit: A tool for the static analysis
of cache side channels. In Usenix Security 2013, 2013.
[27] F. Dupressoir, A. D. Gordon, J. J¨urjens, and D. A.
Naumann. Guiding a General-Purpose C Veriﬁer to
Prove Cryptographic Protocols.
In CSF 2011, pages
3–17. IEEE Computer Society, 2011.
[28] S. Dziembowski and K. Pietrzak. Leakage-resilient
In FOCS, pages 293–302. IEEE Com-
cryptography.
puter Society, 2008.
[29] U. Erlingsson and M. Abadi. Operating system pro-
tection against side-channel attacks that exploit mem-
ory latency. Technical Report MSR-TR-2007-117, Mi-
crosoft Research, 2007.
[30] D. Gullasch, E. Bangerter, and S. Krenn. Cache games -
bringing access-based cache attacks on AES to practice.
In S&P 2011, pages 490–505, 2011.
[31] E. K¨asper and P. Schwabe. Faster and timing-attack
resistant aes-gcm. In C. Clavier and K. Gaj, editors,
CHES, volume 5747 of Lecture Notes in Computer Sci-
ence, pages 1–17. Springer, 2009.
[32] J. Kelsey, B. Schneier, D. Wagner, and C. Hall. Side
Channel Cryptanalysis of Product Ciphers. Journal of
Computer Security, 8(2–3):141–158, 2000.
[33] G. A. Kildall. A uniﬁed approach to global program
optimization.
In Proceedings of the 1st annual ACM
SIGACT-SIGPLAN symposium on Principles of pro-
gramming languages, POPL ’73, pages 194–206, New
York, NY, USA, 1973. ACM.
[34] T. Kim, M. Peinado, and G. Mainar-Ruiz. Stealthmem:
system-level protection against cache-based side chan-
nel attacks in the cloud.
In USENIX Security 2012,
pages 11–11, Berkeley, CA, USA, 2012. USENIX Asso-
ciation.
[35] G. Klein, K. Elphinstone, G. Heiser, J. Andronick,
D. Cock, P. Derrin, D. Elkaduwe, K. Engelhardt,
R. Kolanski, M. Norrish, T. Sewell, H. Tuch, and
S. Winwood. seL4:
formal veriﬁcation of an OS ker-
nel. In SOSP 2009, pages 207–220. ACM, 2009.
[36] P. Kocher. Timing Attacks on Implementations of
Diﬃe-Hellman, RSA, DSS, and Other Systems.
In
CRYPTO’96, volume 1109 of LNCS, pages 104–113.
Springer, 1996.
[37] G. Leander, E. Zenner, and P. Hawkes. Cache Timing
Analysis of LFSR-Based Stream Ciphers.
In IMACC
2009, volume 5921 of LNCS, pages 433–445. Springer,
2009.
[38] X. Leroy. Formal certiﬁcation of a compiler back-end,
or: programming a compiler with a proof assistant. In
POPL 2006, pages 42–54. ACM, 2006.
[39] C. Liu, M. Hicks, and E. Shi. Memory trace oblivious
program execution. In CSF 2013, pages 51–65, 2013.
[40] D. Molnar, M. Piotrowski, D. Schultz, and D. Wagner.
The program counter security model: Automatic detec-
tion and removal of control-ﬂow side channel attacks. In
ICISC 2005, pages 156–168, 2005.
[41] T. Murray, D. Matichuk, M. Brassil, P. Gammie,
T. Bourke, S. Seefried, C. Lewis, X. G., and G. Klein.
sel4:
from general purpose to a proof of information
ﬂow enforcement. In S&P 2013, pages 415–429, 2013.
[42] T. Ristenpart, E. Tromer, H. Shacham, and S. Savage.
Hey, you, get oﬀ of my cloud! Exploring information
leakage in third-party compute clouds. In CCS 2009,
pages 199–212. ACM Press, 2009.
[43] V. Robert and X. Leroy. A formally-veriﬁed alias anal-
ysis. In CPP, pages 11–26, 2012.
[44] J. M. Rushby. Noninterference, Transitivity, and
Channel-Control Security Policies. Technical Report
CSL-92-02, SRI International, 1992.
[45] T. Sewell, S. Winwood, P. Gammie, T. Murray, J. An-
dronick, and G. Klein. seL4 enforces integrity. In ITP
2011, Nijmegen, The Netherlands, 2011.
[46] Z. Shao. Certiﬁed software. Commun. ACM, 53(12):56–
66, 2010.
[47] D. Stefan, P. Buiras, E. Z. Yang, A. Levy, D. Terei,
A. Russo, and D. Mazi`eres. Eliminating cache-based
timing attacks with instruction-based scheduling.
In
J. Crampton, S. Jajodia, and K. Mayes, editors, ES-
ORICS, volume 8134 of Lecture Notes in Computer Sci-
ence, pages 718–735. Springer, 2013.
[48] E. Tromer, D. A. Osvik, and A. Shamir. Eﬃcient cache
attacks on AES, and countermeasures. J. Cryptology,
23(1):37–71, 2010.
[49] Y. Tsunoo, T. Saito, T. Suzaki, M. Shigeri, and
H. Miyauchi. Cryptanalysis of DES implemented on
computers with cache. In CHES 2003, volume 2779 of
LNCS, pages 62–76. Springer, 2003.
[50] Z. Wang and R. B. Lee. New cache designs for thwart-
ing software cache-based side channel attacks. In ISCA
2007, pages 494–505. ACM, 2007.
[51] D. Zhang, A. Askarov, and A. C. Myers. Predictive
mitigation of timing channels in interactive systems. In
CCS 2011, pages 563–574. ACM, 2011.
Action
read va
Informal description
Guest OS reads virtual address va
write va val
Guest OS writes value val in va
Hypervisor extends non-stealth memory of active OS with va 7→ ma
new va pa
new_sm stealth va pa Hypervisor extends stealth memory of active OS with stealth va 7→ ma
switch o
lswitch pa
hcall c
chmod
page_pin pa t
page_unpin pa
Hypervisor sets o to be active OS
Hypervisor changes the current memory mapping of active OS to be pa
An OS requires privileged service c to be executed by the hypervisor
Hypervisor gives the execution control to active OS
Memory page corresponding to pa is registered and classiﬁed with type t
Memory page of active OS that corresponds to pa is un-registered
Effect
∅ if va is Stealth
read va otherwise
∅ if va is Stealth
write va otherwise
new va pa
∅
switch o
lswitch pa
hcall c
chmod
page_pin pa t
page_unpin pa
Figure 9: Selected actions and their eﬀects
Action write va val
Action new_sm stealth va pa
Guest OS writes value val in va
Add stealth va 7→ ma to stealth memory of active OS
Rule
Rule
aos act = (aos, running)
get page mem(t, va) = (ma, pg)
aos act = (aos, waiting)
oss[aos] = (pa′, N ew stealth va pa)
get page hyp(t, aos, pa) = (ma, pg)
pg = (RW , OS aos, true)
¬memory alias(mem, stealth va, ma)
get page hyp(t, aos, pa′) = (ma′, cpt)
cpt[stealth va] = ∅
oss[aos := (pa′, N one)] = oss′
cpt[stealth va := ma] = cpt′
mem[ma′ := cpt′] = mem′
cache add(cache, stealth va, ma, pg) = (cache′, )
tlb[stealth va := ma] = tlb′
t = (oss, aos act, hyp, mem, cache, tlb)
t′ = (oss′, aos act, hyp, mem′, cache′, tlb′)
new_sm stealth va pa
−−−−−−−−−−−−−−−→ t′
t ֒
Precondition The action new_sm stealth va pa requires
that the active OS aos is waiting for the hypervisor to ex-
tend its current page table cpt with stealth va. The physical
address pa maps to the machine address ma and page pg in
the hypervisor mapping of aos (get page hyp). This page
pg must be readable/writable and cacheable. Also, no page
table can map a virtual address to ma (no memory alias),
and stealth va is not mapped in cpt. This is needed in order
to guarantee that the stealth page pg in ma is always cached
and that no aliased pages are cached.
Postcondition In the resulting state, the pending hypercall
of aos is removed. The current page table cpt and tlb are up-
dated with the mapping of stealth va to ma. Furthermore,
the new stealth page is immediately stored in cache.
pg = (RW , OS aos, b)
pg = (RW val, OS aos, b)
cache add(cache, va, ma, pg) = (cache′, (ma′, pg′))
mem[ma′ := pg′][ma := pg]pol = mem′
tlb[va := ma] = tlb′
t = (oss, aos act, hyp, mem, cache, tlb)
t′ = (oss, aos act, hyp, mem′, cache′, tlb′)
write va val
−−−−−−−−−→ t′
t ֒
aos act = (aos, running)
get page mem(t, va) = (ma, pg)
pg = (RW , OS aos, b)
pg = (RW val, OS aos, b)
cache add(cache, va, ma, pg) = (cache′, ⊥)
mem[ma := pg]pol = mem′
tlb[va := ma] = tlb′
t = (oss, aos act, hyp, mem, cache, tlb)
t′ = (oss, aos act, hyp, mem′, cache′, tlb′)
write va val
−−−−−−−−−→ t′
t ֒
Precondition The action write va val requires that the
active OS aos is running. Furthermore, the virtual ad-
dress va is mapped to a machine address ma and a read-
able/writable page pg in the current page table of the active
OS (get page mem).
Postcondition There are two rules for the write action,
one in which an entry is evicted from the cache when the writ-
ten page is added, and the other in which no entry is evicted.
In both cases the resulting state diﬀers in the value val of the
page associated to the pair (va, ma) in the cache cache, and
in the TLB tlb. If cache add returns an entry (ma′, pg′) that
was evicted from the cache, the memory in ma′ is updated
with pg′. The ﬁnal value in memory of the page in ma is
dependent on the write policy in use (mem[ma := page]pol
updates the page in ma with page in write-through policies,
and it leaves it unchanged in write-back ones).
Figure 10: Semantics of write and new sm actions