user, and (2) they do not compromise the integrity of the
browser, including other miners. The majority of our technical
discussion regarding miners addresses these concerns.
Security Policies: To support a diverse set of extensions while
maintaining control over the sensitive information contained in
the personal store, REPRIV allows extension authors to express
the capabilities of their code in a simple policy language. At
the time of installation, users are presented with the extension’s
list of needed capabilities, and have the option of allowing or
disallowing the installation. Several of the policy predicates
deal with information ﬂow and to provenance labels, which
are (cid:2)host, extensionid(cid:3) pairs. All sensitive information used
by miners is tagged with a set of these labels, which allow
policies to reason about information ﬂows involving arbitrary
(cid:2)host, extensionid(cid:3) pairs. A sampling of the predicates avail-
able in REPRIV’s policy language is presented in Figure 4.
Given a list of policy predicates regarding a particular miner,
the policy for that extension is interpreted as the conjunction
of each predicate in the list. This is equivalent to behavioral
whitelisting: unless a behavior is implied by the predicate
conjunction, the miner does not have permission to exhibit
it. Each miner is associated with one static security policy
that is active throughout the lifespan of the miner; revocation
is not needed by any of our current applications, and is not
supported by the extension framework.
Tracking Sensitive Information: When a miner makes a call
to REPRIV requesting information from the personal store,
special precautions must be taken to ensure that the returned
information is not misused. Likewise, when a miner writes
information to the store that is derived from content on pages
viewed by the user, REPRIV must ensure that the user’s wishes
about the privacy of web content are not violated. All REPRIV
functionality that returns sensitive information to miners ﬁrst
encapsulates it in a private data type tracked, which contains
metadata indicating the provenance of that information.
it encapsulates without
This allows REPRIV to take the provenance of data into
account when it is used by miners. The tracked type is
opaque – it does not allow miner code to directly reference
the data that
invoking a REPRIV
mechanism that prevents misuse. This means that REPRIV can
ensure complete noninterference, to the degree mandated by
the miner’s policy. Whenever the miner would like to perform
a computation over the encapsulated information, it must call
a special bind function that takes a function-valued argument
and returns a newly-encapsulated result of applying it to the
tracked value. This scheme prevents leakage of sensitive
information, as long as the function passed to bind does not
cause any side effects. We discuss veriﬁcation of this property
below.
136
The domain “example.com” would like to learn 
your top-n interests. We will tell them your 
interests are: c1, c2, … 
Is this acceptable? 
The domain “example.com” would like to learn 
how interested you are in the topic “catN”. We 
will tell them interest-level. 
Is this acceptable? 
(a) top-n interests
(b) Interest level by category
Fig. 3: Communication protocols for personal information.
each element in the provenance label p. Because the REPRIV
API is very limited, we are assured that this is the only
function that impacts the CanCommunicateXHR predicate.
Notice as well that the third argument, as well as the return
value of MakeRequest, are of the dependent type tracked.
tracked types are indexed both by the type of the data that
they encapsulate, as well as the provenance of that data. The
third argument is the request string that will be sent to the
host speciﬁed in the second argument; its provenance plays
a part in the reﬁnement on the host string discussed above.
The return value has a provenance label that is reﬁned in the
ﬁfth argument. The reﬁnement speciﬁes that the provenance
of the return value of MakeRequest has all elements of the
provenance associated with the request string, as well as a
new provenance tag corresponding to (cid:2)host, eprin(cid:3), where
eprin is the extension principal that invokes the API. This
reﬂects all of the principals that could affect the value returned
by MakeRequest. The reﬁnement on the fourth argument
ensures that the extension passes its actual ExtensionId to
MakeRequest. These considerations ensure that the prove-
nance of information passed to and from MakeRequest is
available for all necessary policy considertations.
As discussed above, verifying correct enforcement of infor-
mation ﬂow properties in REPRIV requires checking that func-
tional arguments passed to bind are side effect-free. Fine’s
language-level sandbox guarantees that side effects are only
created via API calls; our veriﬁcation task reduces to ensuring
that API’s which create side effects are not called from code
that is invoked by bind, as bind provides direct access to data
encapsulated by tracked types. We use capability tokens that
are given afﬁne types [31] to gain this assurance. Roughly,
an afﬁne typed-variable can only be used once, so an afﬁne
token that is copied in the program text results in a type error.
Each API function that may create a side effect takes an afﬁne
token mut_capability as an argument (short for “mutation
capability”), which indicates that the caller of the function
has the right to create side effects. REPRIV passes the main
function of each miner a value of type mut_capability,
which the miner must in turn pass to each location that calls a
side-effecting function. Because mut_capability is an afﬁne
Fig. 5: Example API deﬁnitions.
Verifying Miners: REPRIV veriﬁes miners against their stated
properties statically using security types. This eliminates the
need for costly run-time checks, and ensures that a security
exception will never interrupt a browsing session. To meet
this goal, we require that all untrusted miners be written
in Fine [31], a security-typed programming language. Fine
allows programmers to express dependent
types on func-
tion parameters and return values, which forms the basis of
REPRIV’s veriﬁcation mechanism. Fine provides a language-
level sandbox, so all useful functionality is available to miners
only through a set of API functions. The interface for these
API’s speciﬁes type reﬁnements on key parameters that reﬂect
the consequence of each API function on the relevant policy
predicates. Veriﬁcation occurs at each code point where an
API function is invoked: the miner’s policy is checked against
the dependent type signature of the API function.
Two example interface deﬁnitions are given in Figure 5. The
ﬁrst example, MakeRequest, is the API used by miners to
make HTTP requests; several policy interests are operative in
its deﬁnition. The second argument of MakeRequest is a string
that denotes the remote host with which to communicate, and
is reﬁned with the formula AllCanCommunicateXHR host p,
where p is the provenance label of the buffer to be transmitted.
This reﬁnement ensures that a miner cannot call MakeRequest
unless its policy includes a CanCommunicateXHR predicate for
137
CanCaptureEvents(t,(cid:2)h, e(cid:3))
CanReadDOMElType(t, h)
CanReadDOMId(i, h)
CanUpdateStore(d,(cid:2)h, e(cid:3))
CanReadStore((cid:2)h, e(cid:3))
CanCommunicateXHR(h1,(cid:2)h2, e(cid:3)) Extension can communicate information tagged (cid:2)h2, e(cid:3) to host h1 via XHR-style
Extension can capture events of type t on elements tagged (cid:2)h, e(cid:3).
Extension can read DOM elements of type t from pages hosted by h.
Extension e can read DOM elements with ID i from pages hosted by h.
Extension can update the personal store with information tagged (cid:2)h, e(cid:3).
Extension can read items in the personal store tagged (cid:2)h, e(cid:3).
CanServeInformation(h1,(cid:2)h2, e(cid:3))
CanHandleSites(h)
requests.
Extension can serve programmatic requests to sites hosted by h1, containing
information tagged (cid:2)h2, e(cid:3). An example of a programmatic request is an invocation
of an extension function from the JavaScript on a site in d.
Extension can set load handlers on sites hosted by h.
Fig. 4: Selected security policy predicates. A full listing is available in our technical report [9].
type, and the functional argument of bind does not specify
an afﬁne type, the Fine type system will not allow any code
passed to bind to reference a mut_capability value Be-
cause the constructor for mut_capability is private and the
original token cannot be copied, the functional passed to bind
has no way of generating a value of type mut_capability
required to invoke a side-effecting function. As an example
of this construct in the REPRIV API, observe that both API
examples in Figure 5 create side effects, so their interface
deﬁnitions specify arguments of type mut_capability.
Veriﬁcation Philosophy: The policy associated with a miner
is expressed at the top of its source ﬁle, using a series of
Fine assume statements: one assume for each conjunct in
the overall policy. An example of this is shown in Figure 8,
where the policy assumptions of the miner are 3–5 lines of
the source code. Given the type reﬁnements on all REPRIV
API’s, verifying that the miner correctly implements its stated
policy is reduced to an instance of Fine type checking. The
soundness of this technique rests on three assumptions:
• The soundness of the Fine type system, and the correct-
ness of its implementation. The soundness of the type
system was established via a mechanical proof [31].
• The correctness of the dependent type reﬁnements placed
on the API functions. This amounts to less than 100 lines
of code, which reasons about a relatively simple logic
of policy predicates. Furthermore, because the REPRIV
API is very limited, it is easy to argue that reﬁnements
are placed on all necessary arguments to ensure sound
enforcement. In other words, the API usually only pro-
vides one function for producing a particular type of side
effect, so it is not difﬁcult to check that the appropriate
reﬁnements are placed at all necessary points.
• The correctness of the underlying browser’s implemen-
tation of functions provided by the REPRIV API. For
REPRIV, we used C3, an experimental managed-code
HTML5 platform. C3 is written in a memory-managed
language (C#), providing assurance that
it does not
contain memory corruption vulnerabilities. The logical
correctness of C3 code needed by REPRIV has not been
formally veriﬁed, but doing so is a goal of future work.
We stress that these are modest requirements for the trusted
computing base, and point towards the overall soundness of
REPRIV’s security properties.
IV. REPRIV MINERS
In this section, we discuss several miner templates and their
corresponding policies, as well as two concrete examples:
TwitterMiner and GlueMiner. Two additional miners, Bing-
Miner and NetﬂixMiner, are discussed in various capacities,
but their complete description is available only in the technical
report [9].
A. Miner Patterns
In general, miners can provide a wide range of functionality
when it comes to updating the personal store with infor-
mation that reﬂects the user’s browser-related behaviors. In
this section, we present three patterns of functionality that
we envision many potential miners following. The policies
for each category can be templatized, easing the burden on
miner developers who wish to create variations on these basic
patterns. The three patterns are summarized in Figure 6.
The ﬁrst miner pattern, “site-speciﬁc parsing”,
includes
extensions that are aware of the layout and semantics of
speciﬁc web sites, and are able to update the user’s inter-
est proﬁle accordingly. For example, TwitterMiner invokes
REPRIV’s document classiﬁer over the text contained in the
user’s latest tweets, and BingMiner classiﬁes the user’s search
terms. Miners that follow this pattern either need to send HTTP
requests to relevant web API’s, as in the case of TwitterMiner,
or read the relevant DOM elements from particular sites, as
with BingMiner. They invariably require permission to update
the personal store with information derived from these sources.
The second pattern, “category-speciﬁc information”, returns
detailed information about the user’s interactions with speciﬁc
types of sites to services that request
it via a JavaScript
138
Pattern
Site-speciﬁc parsing
Category-speciﬁc information
Web service relay
)
Policy Template
For the domain d of interest, either CanCommunicateXHR(d) or CanReadDOM*(d,
CanUpdateStore( , d)
CanHandleSites(d) (optional, depending on the semantics of the miner)
CanCaptureEvents( , d) (optional, depending on the semantics of the miner)
For the domain d of interest, either CanCommunicateXHR(d) or CanReadDOM*(d,
CanUpdateStore(Tag( , d))
CanHandleSites(d) (optional, depending on the semantics of the miner)
CanCaptureEvents( , d) (optional, depending on the semantics of the miner)
CanReadStore(Tag( , d))
For each domain p that can request category-speciﬁc information, CanServeInformation(p, Tag( , d))
For the API provider a and each provenance tag t sent to a CanCommunicateXHR(a, t) and
)
CanReadStore(t)
For each domain p that can make requests, CanServeInformation(p, t) and CanServeInformation(p, a)
Fig. 6: Miner patterns and their policy templates.
Name
TwitterMiner
BingMiner
NetﬂixMiner
GlueMiner
Lines of code
C#
Fine
36
89
35
78
110
112
213
101
Fig. 7: Miner characteristics.
Veriﬁcation
time (seconds)
6.4
6.8
7.7
9.5
interface. NetﬂixMiner is an example of this pattern;
the
user’s interactions with pages hosted by netflix.com are
monitored, and information is added to the personal store to
reﬂect this. When a third-party site, such as fandango.com,
would like to personalize based on the user’s recent movie
interests, NetﬂixMiner queries the store to retrieve the list of
most recently-viewed entries by genre, and returns the relevant
titles to the third-party site. In addition to the capabilities
required by site-speciﬁc parsing miners, miners that follow
this pattern also need the ability to read from the store, and
return tagged information to speciﬁc sites via a programmatic
interface.
The ﬁnal pattern, “web service relay”, acts as a privacy-
conscious intermediary between the user’s personal informa-
tion, and web sites that provide useful services using this
information. Miners in this category expose functionality via
a JavaScript interface, and query a third-party web service
with data from the personal store to implement this func-
tionality. For example, GlueMiner returns movies similar to
those recently viewed by the user by reading store entries
created by NetﬂixMiner, sending them to the API provided
by getglue.com, and returning the results to the JavaScript
that requested this information.
B. Miner Examples
In this section we discuss examples of miners that we wrote
for REPRIV.
TwitterMiner: TwitterMiner utilizes the RESTful API ex-
posed by twitter.com to periodically check the user’s twit-
ter proﬁle for updates. When the user posts a new tweet,
TwitterMiner analyzes its content using REPRIV’s classiﬁer
to determine how to update the personal store accordingly.
TwitterMiner needs only two capabilities from REPRIV, as
the twitter.com API simpliﬁes its task:
1) It must be able to make XHR-style requests to twitter.
com. The second argument of the CanCommunicateXHR
capability must indicate that TwitterMiner cannot send
any sensitive information derived from the store in such
a request.
2) It must be able to update the store to reﬂect data derived
from twitter.com
The source code for TwitterMiner is shown in Figure 8
There are only two places in the Fine code in which the
programmer must justify to the compiler that the stated policy
is in fact being enforced. The ﬁrst is in the type signature of
CollectLatestFeed, where a reﬁned type is used to tell the
compiler that the identiﬁer extid refers to the extension ID
stated in the policy manifest. The second location is the ﬁrst
statement in CollectLatestFeed, where a provenance label
is constructed to reﬂect the source of information that will be
collected by TwitterMiner, e.g. twitter.com. This allows the
compiler to verify that the tracked information being sent to
the store at the end of CollectLatestFeed is in accordance
with the policy. Reﬁnements on the type of API function