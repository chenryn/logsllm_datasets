    }
    ok = (sym != 0);
    }
    }
**0x03 小结**
这是今年在这个模块第二次出现UAF的漏洞了，在反序列化的流程中，将中间产生的元素存放在objArrays当中，在处理reference的时候进行使用，但是没有考虑到reference的流程中，会使用到已经被free的元素。  
在过去的日常开发中，反思字节开发的序列化库，也确实经常会做类似的处理，默认了函数的输入都是合理的数据，并对序列化产生的数据进行了详细的测试，确保反序列化不会出问题，但是并没有考虑到恶意构造的二进制数据和序列化函数产生的二进制数据，在执行时可能会造成不同的流程。
reference
1.PEGASUS iOS Kernel Vulnerability Explaine
https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html
2.PEGASUS iOS Kernel Vulnerability Explained – Part 2
https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html
附
源码
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    #define setAtIndex(v, idx, o)
    if (idx >= v##Capacity)
    {
    uint32_t ncap = v##Capacity + 64;
    typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));
    if (!nbuf) ok = false;
    if (v##Array)
    {
    bcopy(v##Array, nbuf, v##Capacity * sizeof(o));
    kfree(v##Array, v##Capacity * sizeof(o));
    }
    v##Array    = nbuf;
    v##Capacity = ncap;
    }
    if (ok) v##Array[idx] = o;
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    OSObject *
    OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString)
    {
    OSObject ** objsArray;
    uint32_t    objsCapacity;
    uint32_t    objsIdx;
    OSObject ** stackArray;
    uint32_t    stackCapacity;
    uint32_t    stackIdx;
        OSObject     * result;
        OSObject     * parent;
        OSDictionary * dict;
        OSArray      * array;
        OSSet        * set;
        OSDictionary * newDict;
        OSArray      * newArray;
        OSSet        * newSet;
        OSObject     * o;
        OSSymbol     * sym;
        OSString     * str;
        size_t           bufferPos;
        const uint32_t * next;
        uint32_t         key, len, wordLen;
        bool             end, newCollect, isRef;
        unsigned long long value;
        bool ok;
    if (errorString) *errorString = 0;
    /*
    #define kOSSerializeBinarySignature "323"
    */
    // 检测是否是是具有签名的内存数据
    if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);
    // 0000 0011 && buffer指针 ==》buffer的地址末尾不能是11
    if (3 & ((uintptr_t) buffer)) return (NULL);
    // 检测buffersize的大小要小于kOSSerializeBinarySignature的大小
    if (bufferSize > 2; //计算要用几个word
    end = (0 != (kOSSerializeEndCollecton & key));
            DEBG("key 0x%08x: 0x%04x, %dn", key, len, end);
            newCollect = isRef = false;
    o = 0; newDict = 0; newArray = 0; newSet = 0;
    //根据key的不同对不同的数据结构做操作
    switch (kOSSerializeTypeMask & key)
    {
        case kOSSerializeDictionary:
    o = newDict = OSDictionary::withCapacity(len);
    newCollect = (len != 0);
            break;
        case kOSSerializeArray:
    o = newArray = OSArray::withCapacity(len);
    newCollect = (len != 0);
            break;
        case kOSSerializeSet:
    o = newSet = OSSet::withCapacity(len);
    newCollect = (len != 0);
            break;
        case kOSSerializeObject:
    if (len >= objsIdx) break;
    o = objsArray[len];
    o->retain();
    isRef = true;
    break;
        case kOSSerializeNumber:
    bufferPos += sizeof(long long);
    if (bufferPos > bufferSize) break;
        value = next[1];
        value  bufferSize)           break;
    if (0 != ((const char *)next)[len-1]) break;
            o = (OSObject *) OSSymbol::withCString((const char *) next);
            next += wordLen;
            break;
        case kOSSerializeString:
    bufferPos += (wordLen * sizeof(uint32_t));
    if (bufferPos > bufferSize) break;
            o = OSString::withStringOfLength((const char *) next, len);
            next += wordLen;
            break;
            case kOSSerializeData:
    bufferPos += (wordLen * sizeof(uint32_t));
    if (bufferPos > bufferSize) break;
            o = OSData::withBytes(next, len);
            next += wordLen;
            break;
            case kOSSerializeBoolean:
    o = (len ? kOSBooleanTrue : kOSBooleanFalse);
            break;
        default:
            break;
    }
    //退出循环
    if (!(ok = (o != 0))) break;
    //如果反序列化的结果不是一个reference
    //就将结果存放到objsCapacity之中
    //如果反序列化自后内存申请失败,则退出反序列化
    if (!isRef)
    {
    setAtIndex(objs, objsIdx, o);
    //如果ok的值为false，则退出反序列化循环
    //#define kalloc_container(size)
    kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN)
    /*
    typeof(objsArray) nbuf = (typeof(objsArray)) kalloc_container(ncap * sizeof(o));
    if (!nbuf) ok = false;
    */
    //在内核中申请ncap*sizeof（o）大小的内存，如果申请失败的了则ok设为false
    if (!ok) {
    break;
    }
    objsIdx++;
    }
    //如果存在一个解析出来的dict
    if (dict)
    {
    if (sym)
    {
    DEBG("%s = %sn", sym->getCStringNoCopy(), o->getMetaClass()->getClassName());
    if (o != dict) 
    {
    ok = dict->setObject(sym, o);
    }
    o->release();
    sym->release();
    sym = 0;
    }
    else 
    {
    sym = OSDynamicCast(OSSymbol, o);
    if (!sym && (str = OSDynamicCast(OSString, o)))
    {
        sym = (OSSymbol *) OSSymbol::withString(str);
        o->release();
        o = 0;
    }
    ok = (sym != 0);
    }
    }
    else if (array) 
    {
    ok = array->setObject(o);
        o->release();
    }
    else if (set)
    {
       ok = set->setObject(o);
       o->release();
    }
    else
    {
        assert(!parent);
        result = o;
    }
    if (!ok) break;
    if (newCollect)
    {
    if (!end)
    {
    stackIdx++;
    setAtIndex(stack, stackIdx, parent);
    if (!ok) break;
    }
    DEBG("++stack[%d] %pn", stackIdx, parent);
    parent = o;
    dict   = newDict;
    array  = newArray;
    set    = newSet;
    end    = false;
    }
    if (end)
    {
    if (!stackIdx) break;
    parent = stackArray[stackIdx];
    DEBG("--stack[%d] %pn", stackIdx, parent);
    stackIdx--;
    set   = 0; 
    dict  = 0; 
    array = 0;
    if (!(dict = OSDynamicCast(OSDictionary, parent)))
    {
    if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));
    }
    }
    }
    DEBG("ret %pn", result);
    if (objsCapacity)  kfree(objsArray,  objsCapacity  * sizeof(*objsArray));
    if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray));
    if (!ok && result)
    {
    result->release();
    result = 0;
    }
    return (result);
    }