59.1% 
46.5% 
67.2% 
100% 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:30 UTC from IEEE Xplore.  Restrictions apply. 
4.1 Fault emulation using G-SWFIT 
G-SWFIT  is  based  on  a)  the  existence  of  a  set  of 
simple  high-level  programming  errors 
that  occur 
frequently,  and  b)  the  knowledge  on  how  high-level 
languages are translated to low-level code. This allows us 
to  identify  patterns  of  low-level  code  that  relate  to 
locations  suitable  for  fault  injection  and  to  know  what 
specific  mutations  are  needed  to  emulate  the  intended 
faults. The executable code mutation process is guided by 
a library of mutation operators previously defined for the 
target  platform:  the  target  code  is  scanned  for  specific 
low-level 
instruction  patterns  and  mutations  are 
performed  on  those  patterns  to  emulate  high-level  faults. 
For  each  mutation  applied  a  different  version  of  the 
original target is generated. To cover more faults one has 
only to enlarge the library with more operators. 
As  seen  in  section  3,  many  of  the  defects  that  remain 
in the software after deployment are simple programming 
errors.  Therefore,  techniques  such  as  G-SWFIT,  which 
recreate programmer errors, provide an adequate tool  for 
fault emulation. 
When defining mutation operators the following issues 
are relevant: 
•  Faults addressed in the library must me representative 
of the faults that really appear in defective software. 
•  Locations  eligible  for  fault  injection  must  reflect  the 
high-level constructs where faults are prone to appear. 
•  The  mutations  to  apply  must  recreate  the  code  that 
would  have  been  generated  by  the  compiler  if  the 
intended fault were present in the source code. 
We addressed these issues in the following manner: 
•  The operators proposed in this paper are based on the 
data on real software faults discussed in section 3. 
•  The locations for fault injection are selected (through 
appropriate search patterns) based on the locations in 
the high-level code where we observed that faults are 
more frequent. 
•  The mutations proposed were based on the analysis of 
the  effects  of  each  fault  and  the  observation  of  how 
the source code is translated into low-level code. 
The  resulting  set  of  low-level  mutation  operators  is 
presented  in  section  4.2.  Currently  G-SWFIT  doest  not 
yet  address  all  of  the  faults  of  Section  3.  Because  this 
technique 
localized  code 
mutations,  faults  that  relate  to  large  portions  of  code  are 
still outside its scope. 
to  small  and 
is  oriented 
4.2. Low-level mutation operators 
In  the  work  presented  in  [9]  we  have  shown  that  the 
construction of the low level mutation library was mainly 
dependent on the target processor architecture. In fact the 
programming  language,  the  compiler,  and  the  compiler 
in 
the 
optimization  switches  also  have  some  influence  on  the 
library.  However,  this  accounts  for  some  more  fault 
operators 
library  while  different  processor 
architectures  require  completely  different  libraries.    The 
operators  presented  here  are  intended  for  the  IA32 
architecture and the target applications are assumed to be 
of  32-bit  code.  The  search  patterns  and  its  related 
mutations were derived from the observation of compiler 
code  generation  using  different  optimization  settings. 
Both patterns and  mutations are presented in the  form of 
assembly mnemonics according to the Intel notation [16]. 
The  G-SWFIT  mutation  operators  are  defined  around 
the two following concepts: 
• 
Search  pattern.  This  is  a  sequence  of  machine 
code  instructions  that  relate  to  the  high-level  constructs 
where faults can be emulated. Search patterns are defined 
in  such  a  way  that  it  is  possible  to  identify  locations 
where it is pertinent to emulate a given fault and exclude 
other locations where such fault would not be meaningful.  
•  Low-level  mutation.  This  is  the  mutation  to 
apply to a location to emulate of the intended fault. 
 It  is  worth  noting  that  most  of  the  operators  actually 
cover  more  than  one  fault  type  described  in  section  3.4, 
which  greatly  simplifies 
the 
operators.  Due  to  space  restrictions,  we  cannot  present  a 
thorough  list  of  mutation  operators  here  (see  [11]  for  a 
more  complete  list). The  operators  listed  here  are  shown 
in Table 12 and cover the following types: 
task  of  building 
the 
Missing  function  call:  This  operator  (OFC)  locates 
function  calls  in  a  context  where  its  return  value  is  not 
being used (removing a function where its value is needed 
would not represent real software faults). This restriction 
is  implemented  by  assuring  that  the  CALL  instruction  is 
not  followed  by  instructions  that  represent  the  usage  of 
the return value.  
variable 
Missing/wrong 
initialization:  These 
operators  address  different  ways  in  which  a  variable  can 
be initialized: through the assignment of a value (OIV) or 
another  variable  or  an  expression  (OIE).  Search  patterns 
for  these  operators  locate  the  first  occurrence  of  an 
assignment to a stack-resident variable. 
Missing/wrong variable assignment: These operators 
address  the  several  ways  in  which  a  variable  can  be 
assigned:  through  assignment  of  a  value  (OAV),  another 
variable,  or  an  expression  (OAE)  (operator  OAA  covers 
both  cases).  To  avoid  the  emulation  of  missing  variable 
initialization  faults  (which  fall  in  a  different  fault  type), 
the first occurrence of assignment to each offset inside the 
function stack space is excluded from mutation. Operator 
OAVW addresses the emulation of a wrong value used in 
a variable assignment. 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:30 UTC from IEEE Xplore.  Restrictions apply. 
Wrong  variable  in  parameter  of  function  call:
operator OWPV emulates the use of a wrong variable as a 
parameter in a function call. This operator locates CALL 
instructions that are preceded by the fetching and pushing 
of a stack-resident variable. 
Missing  "if  (cond)".  Operator  OIA  recreates  a 
missing if condition, having the effect of some instruction 
being always executed instead of only when the condition 
is  met;  operator  OIS  emulates  a  missing  if  construct  as 
well as the statements it affects.  
Missing  "AND  expr"  in  logical  expression  used  in 
branch  condition"  Operator  OLAC  emulates 
the 
omission of part of a logical expression used in a branch 
condition.  The  logical  expression  is  composed  of  a 
sequence  of  at  least  two  sub-expressions  linked  together 
with the logical operator AND. Such expressions usually 
originate  a  series  of  conditional  jumps  instructions;  the 
effect  of  the  omission  of  one  of  the  sub-expressions  can 
be obtained by removing its related jump instruction.  
5. Conclusions 
Table 12 - Fault emulation operators 
Opers  F.type covered  Search pattern 
Mutation 
Operator for "missing function call"
OFC
MFC 
(  func(....);  )
CALL target-address
Not followed by a 
instruction using EAX 
(=return value)
CALL instruction 
removed
Operators for Missing variable initializations 
OIV
MVI, WVIV, WIDI 
( var = value; )
MVI
OIE
(var = SomeVar ) 
(var = xpression )
First occurrence of  
MOV offset[EBP], val 
for each given offset
inside a given function 
First occurrence of 
MOV offset[EBP], reg
for each given offset
inside a given function 
MOV instruction 
removed 
Each offset is a 
different fault
MOV instruction 
removed 
Each offset is a 
different fault
Operators for "missing variable assignment"
OAE
OAV
OAV
OAA
MVAE, WAEA 
( var = expr ) 
MVAV
( var = value ) 
WVAV
( var = value ) 
MVAE, WAEA, 
MVAV, WVAV 
( var  = ... ) 
Any
MOV offset[EBP], reg
Any
MOV offset[EBP], val
Any
MOV offset[EBP], val
MOV instruction 
removed 
MOV instruction 
removed 
value id modified 
Any
MOV offset[EBP], … 
MOV instruction 
removed 
Operators for wrong variable in parameter 
WPFV 
( wrong variable 
used )
MOV EAX, offset [EBP] 
PUSH EAX 
CALL address
offset changed by 
4 (32 bits 
assumed) 
OWPV
Operators for "missing if (cond)" 
Jump removed 
References
trend 
The  analysis  of  field  data  on  more  than  five  hundred 
in  fault 
real  software  faults  shows  a  clear 
distribution  across  ODC  classes.  Other  research  works 
using  field  data  also  obtained  similar  fault  distributions, 
in spite of using different sources. This suggests that this 
fault  distribution  is  a  characteristic  of  software  faults  in 
general and should be reflected in faultload definition for 
representative  emulation  of  software  faults.  One  very 
important  conclusion  is  that  a  smaller  subset  of  specific 
fault 
fault 
occurrence.  These  specific  fault  types  are  the  obvious 
candidates for the emulation of software faults. 
types  was  clearly  dominant 
regarding 
The  emulation  of  software  faults  can  be  performed 
using  a  technique  that  mutates  the  low-level  code  in  a 
way  that  recreates  the  code  that  would  have  been 
produced by the compiler if the fault had occurred at the 
high-level  source  code.  This  method  is  very  simple  and 
can  be  used  even  when  the  original  source  code  is  not 
available.  The  conclusions  of  our  field  data  analysis 
(concerning  the  most  frequent  fault  types)  led  us  to  the 
definition of a  set of  mutation operators that emulate the 
majority  of  fault  types  that  are  expected  to  be  found  in 
real software. 
To assist in the definition of mutation operators, faults 
were  classified  as  missing,  wrong  or  extraneous 
constructs.    This  classification  proved  to  be  useful:  it  is 
well adapted to common mistakes made by programmers, 
and leads to a considerable simplification in the definition 
of  the  mutation  operators.  In  fact,  the  same  operator  can 
emulate in general more than one fault type. 
[1]  J. Aidemark, J. Vinter, P. Folkesson, J. Karlsson, “GOOFI: 
Generic  Object-Oriented 
Tool”, 
Proceedings  of  International  Conference  on  Dependable 
Systems  and  Networks,  DSN-2001,  Göteborg,  Sweden, 
2001, pp. 71-76. 
Injection 
Fault 
[2]  J. Arlat et al, “Fault Injection and Dependability Evaluation 
of  Fault  Tolerant  Systems”,  IEEE  Transactions  on 
Computers, vol. 42, no. 8, pp. 919-923, August 1993. 
[3]  A. Brown, D. Patterson, "Towards availability benchmark: 
a  case  study  of  software  RAID  systems",  Proceedings  of 
OIA  MIA 
OIS  MIFS 
CMP reg, ... 
jcond after: 
...instructions...
after:
CMP reg, ... 
jcond after: 
...instructions...
after:
Jump and 
instructions
removed 
Operators for "missing AND expr in logical condition" 
OLAC  MLAC 
jcond1 after 
...
jcondn after 
instructions
after:
instructions
one of the 
conditional 
jumps is 
removed
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:30 UTC from IEEE Xplore.  Restrictions apply. 
2000  USENIX  Annual  Technical  Conference,  San  Diego, 
California, USA, June 18-23, 2000, pp 263-276. 
[4]  J.  Carreira,  H.  Madeira,  J.  G.  Silva,  “Xception:  Software 
Fault  Injection  and  Monitoring  in  Processor  Functional 
Units",  IEEE  Transactions  on  Software  Engineering,  vol. 
24, no. 2, Feb. 1998 
[5]  R. Chillarege,  “Orthogonal Defect Classification”, Ch. 9 of 
“Handbook  of  Software  Reliability  Engineering”,  M.  Lyu 
Ed., IEEE Computer Society Press, McGraw-Hill, 1995 
[6]  J.  Christmansson  and  R.  Chillarege,  “Generation  of  an 
Error  Set  that  Emulates  Software  Faults”,  Proceedings  of 
the  26th  IEEE  Fault  Tolerant  Computing  Symposium, 
FTCS-26, Sendai, Japan, pp. 304-313, June 1996. 
[7]  D.  Costa,  T.  Rilho,  M.  Vieira,  H.  Madeira,  "ESFFI–  A 
novel  technique  for  the  emulation  of  software  faults  in 
COTS  components",  Conference  on  the  Engineering  of 
Computer-Based  Systems,  ECBS  2001,  Washington,  DC, 
USA, April, 2001. 
[8]  M. Daran, P. Thévenod-Fosse, “Software Error Analysis: A 
Real  Case  Study  Involving  Real  Faults  and  Mutations”, 
Proc. of 3rd Symposium on Software Testing and Analysis, 
ISSTA-3, San Diego, USA, pp. 158-171, January 1996. 
[9]  J.  Durães,  H.  Madeira,  "Emulation  of  Software  Faults  by 
Educated Mutations at Machine-Code Level", Proceedings 
of  the  Thirteenth  IEEE  International  Symposium  on 
Software  Reliability  Engineering,  ISSRE’02,  November 
2002, Annapolis MD, USA. 
[10] J.  Durães,  H.  Madeira,  "Characterization  of  Operating 
Systems  Behavior  in  the  Presence  of  Faulty  Drivers 
through  Software  Fault  Emulation  ",  Proceedings  of  the 
Ninth  IEEE  Pacific  Rim  International  Symposium  on 
Dependable  Computing,  PRDC’02,  December 
  2002, 
Tsukuba, Japan. 
[11] J.  Durães,  H.  Madeira,  “Definition  of  complete  set  of 
software  fault  emulation  operators  based  on  a  field  data 
Study”, Technical Report DEI-005-2002, ISSN 0873-9293, 
Departamento de Engenharia Informática – FCTUC, 2002, 
http://www.dei.uc.pt/~henrique/G-SWFIT.htm. 
[12] R. DeMillo, D. Guindi, W. McCracken, A. Offut, K. King, 
“An  Extended  Overview  of  the  Mothra  Software  Testing 
Environment”,  Proc.  of  ACM  SIGSOFT/IEEE  2nd 
Workshop on Software Testing, Verification, and Analysis, 
pp. 142-151, July 1988. 
[13]  J.-C. Fabre, F. Salles, M. R. Moreno, J. Arlat, “Assessment 
of COTS Microkernels by Fault Injection”, in Dependable 
Computing  for  Critical  Applications  (Proceedings  of  the 
7th  IFIP  Working  Conference  on  Dependable  Computing 
for  Critical  Applications:  DCCA-7,  San  Jose,  CA,  USA, 
Jan. 1999). 
[14] J.  Gray,  “A  Census  of  Tandem  Systems  Availability 
IEEE  Transactions  on 
Between  1985  and  1990”, 
Reliability, vol. 39, no. 4, pp. 409-418, October 1990. 
[15] J.  P.  Hudepohl  et.  al.,  “EMERALD:  A  Case  Study  in 
Enhancing  Software  Reliability”  Proceedings  of  8th 
International  Symposyum 
on  Software  Reliability 
Engineering, ISSRE’98, Nov. 1998. 
[16] Intel  Architecture  Software  Developer’s  manual,  Volume 
2: Instruction Set Reference, Intel Corporation, 1997. 
[17] R.  K.  Iyer,  “Experimental  Evaluation”,  Special  Issue 
FTCS-25  Silver  Jubilee,  25th  IEEE  Symposium  on  Fault 
Tolerant Computing, FTCS-25, pp. 115-132, June 1995. 
[18] G.  Kanawati,  N.  Kanawati,  J.  Abraham,  “FERRARI:  A 
Tool 
the  Validation  of  System  Dependability 
Properties”,  Proceedings  of  the  22th  IEEE  Fault  Tolerant 
Computing Symp., FTCS-22, pp. 336-344, June 1992. 
for 
[19] K.  Kanoun,  J.  Arlat,  D.  Costa,  M.  Dal  Cin,  P.  Gil,  J-C. 
Laprie,  H.  Madeira,  N.  Suri,  “DBench:  Dependability 
Benchmarking”,  Supplement  of  International  Conference 
on  Dependable  Systems  and  Networks,  DSN-2001, 
Göteborg, Sweden, 2001 
[20] T.  Khoshgoftaar  et.  al.,  “Process  Measures  for  Predicting 
Software  Quality”,  High  Assurance  Systems  Engineering 
Workshop, HASE’97, Washington D.C., USA, 1997. 
[21] P. Koopman, J. Sung, C. Dingman, D. Siewiorek, T. Marz, 
“Comparing  Operating  Systems  using  Robustness 
Benchmarks”,  in  Proceedings  of  the  16th  International 
Symposium  on  Reliable  Distributed  Systems,  SRDS-16, 
Durham, NC, USA, 1997. 
[22] I. Lee, R. K. Iyer, “Software Dependability in the Tandem 
GUARDIAN  System”,  IEEE  Transactions  on  Software 
Engineering, vol. 21, no. 5, pp. 455-467, May 1995. 
[23] M.  Lyu,  “Handbook  of  Software  Reliability  Engineering”, 
IEEE Computer Society Press, McGraw-Hill, 1996. 
[24] H.  Madeira,  M.  Vieira,  D.  Costa,  “On  the  Emulation  of 
Software Faults by Software Fault Injection,” International 
Conference  on  Dependable  Systems  and  Networks,  NY, 
USA, June, 2000. 
[25] J. Musa, “Software Reliability Engineering”, McGraw-Hill, 
1996. 
[26] W.  T.  Ng,  C.  M.  Aycock,  P.  M.  Chen,  “Comparing  Disk 
and  Memory’s  Resistance  to  Operating  System  Crashes”, 
Proc.  of  the  7th  IEEE  Int.  Symp.  on  Software  Reliability 
Engineering, ISSRE’96, Oct, 1996, New York, USA. 
[27] Wee. T. Ng and Peter M. Chen, “Systematic improvement 
of  fault  tolerance  in  the  RIO  file  cache”,  Proc.  of  the  30th
IEEE  Fault  Tolerant  Computing  Symposium,  FTCS-29, 
Madison, WI, USA, June 1999. 
[28] M.  Sullivan,  R.  Chillarege,  “Software  defects  and  their 
impact  on  systems  availability  –  A  study  of  field  failures 
on  operating  systems”,  Proc.  of  the  21st  IEEE  Fault 
Tolerant Computing Symp., FTCS-21, pp. 2-9, June 1991. 
[29] T. Tsai and R, K. Iyer, “An Approach to Benchmarking of 
Fault-Tolerant  Commercial  Systems”,  Proceedings  of  the 
26th 
IEEE  Fault  Tolerant  Computing  Symposium, 
FTCS-26, Sendai, Japan, pp. 314-323, June 1996. 
[30] J. Voas, G. McGraw, L. Kassab, L. Voas, “A ‘Crystal Ball’ 
for Software Liability”, 1996. 
[31] J.  Voas,  F.  Charron,  G.  McGraw,  K.  Miller,  and  M. 
Friedman,  “Predicting  how  Badly  ‘Good’  Software  can 
Behave”, IEEE Software, 1997. 
Acknowledgements 
Funding for this paper was provided, in part, by the Portuguese 
Government/European  Union 
through  R&D  Unit  326/94 
(CISUC) and by DBench project, IST 2000 - 25425 DBENCH, 
funded by the European Union.  
We also would like to thanks to Kerstin Buchacker and Roland 
Karch  for  showing  us  the  bugs  database  of  open  source 
programs. 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:30 UTC from IEEE Xplore.  Restrictions apply.