RE:Trace – Applied Reverse 
Engineering on OS X
Tiller Beauchamp
SAIC
David Weston
Microsoft
DTRACE BACKGROUND
What Is DTrace™?
*Dtrace was created by Sun Microsystems, Inc. and released under the Common Development and Distribution 
License (CDDL), a free software license based on the Mozilla Public License (MPL).
DTrace Background
• Kernel-based dynamic tracing framework
• Created by Sun Microsystems
• First released with Solaris™ 10 operating System
• Now included with Apple OS X Leopard, QNX
• June 10th, 2008, committed to CURRENT branch 
of FreeBSD 7, Will be in 8 STABLE (John Birrell)
• OpenBSD, NetBSD, Linux?
*Solaris™ is a trademark of Sun Microsystems, Inc. in the United States and/or other countries.
DTrace Overview 
• DTrace is a framework for performance 
observability and debugging in real time
• Tracing is made possible by thousands of 
“probes” placed “on the fly” throughout the system
• Probes are points of instrumentation in the kernel
• When a program execution passes one of these 
points, the probe that enabled it is said to have 
fired
• DTrace can bind a set of actions to each probe
DTrace Architecture
Source: Solaris Dynamic Tracing Guide
The D Language
• D is an interpreted, block-structured language
• D syntax is a subset of C
• D programs are compiled into intermediate form
• Intermediate form is validated for safety when 
your program is first examined by the DTrace 
kernel software
• The DTrace execution environment handles any 
runtime errors
The D Language
• D does not use control-flow constructs such as if 
statements and loops
• D program clauses are written as single, straight-
line statement lists that trace an optional, fixed 
amount of data
• D can conditionally trace data and modify control 
flow using logical expressions called predicates
• A predicate is tested at probe firing before 
executing any statements
DTrace Performance
• DTrace is dynamic: probes are enabled only 
when you need them
• No code is present for inactive probes
• There is no performance degradation when you 
are not using DTrace
• When the dtrace command exits, all probes are 
disabled and instrumentation removed 
• The system is returned to its original state
DTrace Uses
• DTrace takes the power of multiple tools and 
unifies them with one programmatically 
accessible interface 
• DTrace has features similar to the following:
– truss: tracing system calls, user functions
– ptrace: tracing library calls 
– prex/tnf*: tracing kernel functions 
– lockstat: profiling the kernel 
– gdb: access to kernel/user memory
DTrace Uses
• DTrace combines system performance statistics, 
debugging information, and execution analysis 
into one tight package
• A real “Swiss army knife” for reverse engineers
• DTrace probes can monitor every part of the 
system, giving “the big picture” or zooming in for a 
closer look
• Can debug “transient” processes that other 
debuggers cannot
Creating DTrace Scripts
• Dozens of ready-to-use scripts are included with 
Sun’s DTraceToolkit; they can be used as 
templates
• These scripts provide functions such as syscalls 
by process, reads and writes by process, file 
access, stack size, CPU time, memory r/w and 
statistics
• Complex problems can often be diagnosed by a 
single “one-liner” DTrace script
Example: Syscall Count
1
2
3
3
4
4309
6899
• System calls count by application:
dtrace -n 'syscall:::entry{@[execname] = count();}'.
Matched 427 probes
Syslogd
DirectoryService
Finder
TextMate
Cupsd
Ruby
vmware-vmx
Example: File Open Snoop
#!/usr/sbin/dtrace -s
syscall::open*:entry { 
  printf("%s %s\n",
          execname,
          copyinstr(arg0));
}
Example: File Snoop Output
vmware-vmx
/dev/urandom
Finder
/Library/Preferences/SystemConfiguration/com.apple.smb.server.plist
iChat 
/Library/Preferences/SystemConfiguration/com.apple.smb.server.plist
Microsoft Power
/Library/Preferences/SystemConfiguration/com.apple.smb.server.plist
nmblookup 
/System/Library/PrivateFrameworks/ByteRange ... ByteRangeLocking
nmblookup 
/dev/dtracehelper
nmblookup 
/dev/urandom
nmblookup 
/dev/autofs_nowait
Nmblookup
/System/Library/PrivateFrameworks/ByteRange... ByteRangeLocking
 DTrace Lingo
• Probes are points of instrumentation
• Providers are logically grouped sets of probes
• Examples of providers include syscall, lockstat, 
fbt, io, mib
• Predicates allow actions to be taken only when 
certain conditions are met
•  Actions are taken when a probe fires 
DTrace Syntax
Generic D Script
Probe:      provider:module:function:name
Predicate:    /some condition that needs to happen/
{
Action:
action1;
action2; (ex: printf(); )
}
DTRACE AND REVERSE 
ENGINEERING (RE)
How Can We Use DTrace?
DTrace for RE
• DTrace is extremely versatile and has many 
applications for RE
• It is very useful for understanding the way a 
process works and interacts with the rest of the 
system
• DTrace probes work in a manner very similar to 
debugger “hooks”
• DTrace probes are useful because they can be 
described generically and focused later
DTrace for RE
• Think of DTrace as a rapid development 
framework for RE tasks and tools
• One of DTrace’s greatest assets is speed
• DTrace can instrument any process on the 
system without starting or stopping it
• Complex operations can be understood with a 
succinct one-line script
• You can refine your script as the process 
continues to run
Helpful Features
DTrace gives us some valuable features for free:
• Control flow indicators
• Symbol resolution
• Call stack trace
• Function parameter values
• CPU register values
• Both in kernel space and user space!
Control Flow
  1        -> -[AIContentController finishSendContentObject:] 
  1          -> -[AIAdium notificationCenter] 
  1           -[AIContentController processAndSendContentObject:] 
  1            -> -[AIContentController handleFileSendsForContentMessage:] 
  1             -[AdiumOTREncryption willSendContentMessage:] 
  1              -> policy_cb                 
  1                -> contactFromInfo         
  1                  -> -[AIAdium contactController] 
  1                   accountFromAccountID  
Symbol and Stack Trace
dyld`strcmp
  dyld`ImageLoaderMachO::findExportedSymbol(char
  dyld`ImageLoaderMachO::resolveUndefined(...  
  dyld`ImageLoaderMachO::doBindLazySymbol(unsigned
  dyld`dyld::bindLazySymbol(mach_header const*, ...
  dyld`stub_binding_helper_interface2+0x15
  Ftpd`yylex+0x48
  Ftpd`yyparse+0x1d5
  ftpd`ftp_loop+0x7c
  ftpd`main+0xe46
Function Parameters
DTrace’s copyin* functions allow you to copy data 
from the process space:
printf("arg0=%s", copyinstr( arg0 ))
Output:
 1  -> strcmp    arg0=_isspecial_l
CPU Register Values
Uregs array allows access to reading CPU registers
printf(“EIP:%x”, uregs[R_EIP]);
Example:
EIP: 0xdeadbeef
EAX: 0xffffeae6
EBP: 0xdefacedd
ESP: 0x183f6000
Destructive Examples
#!/usr/sbin/dtrace -w -s
syscall::uname:entry { self->a = arg0; }
syscall::uname:return{
        copyoutstr(“Windows”, self->a, 257);
        copyoutstr(“PowerPC”, self->a+257, 257);
        copyoutstr(“2010.b17”, self->a+(257*2), 257);
        copyoutstr(“fud:2010-10-31”, self->a+(257*3), 257);
        copyoutstr(“PPC”, self->addr+(257*4), 257);
}
Adapted from: Jon Haslam, http://blogs.sun.com/jonh/date/20050321
Snooping
syscall::write: entry { 
   self->a = arg0; 
}
syscall::write: return { 
   printf(“write: %s”,
   copyinstr(self->a); 
}
Got Ideas?
Using DTrace:
• Monitor stack overflows
• Code coverage
• Fuzzer feedback
• Monitor heap overflows
DTrace vs. Debuggers
• Don’t think of DTrace as a debugger
• User mode and kernel mode debuggers allow you 
to control execution and inspect process 
information 
• DTrace can instrument both the kernel and user 
land applications at the same time
• To trace execution, debuggers use instructions to 
pause and resume execution
• DTrace carries out parallel actions in the kernel 
when a probe is hit 
DTrace vs. Debuggers
• Traditional debuggers also affect the target 
process’s memory layout.  DTrace doesn’t
• DTrace does not directly perform exception 
handling
• DTrace can halt process and transfer control to 
external debugger
• Currently DTrace is not susceptible to traditional 
anti-debugging techniques (isdebuggerpresent())
• However, Apple has implemented probe blocking 
with use of the PT_ATTACH_DENY
DTrace vs. Tracers
• Truss, ltrace, and strace operate one process at a 
time, with no system-wide capability
• Truss reduces application performance
• Truss stops threads through procfs, records the 
arguments for the system call, and then restarts 
the thread
• Valgrind™ is limited to a single process and only 
runs on Linux
• Ptrace is much more efficient at instruction level 
tracing but it is crippled on OS X 
*Valgrind is Open Source/Free Software and is freely available under the GNU General Public License.
DTrace Limitations
• The D language does not have conditionals or 
loops
• The output of many functions is to stdout (i.e., 
stack(), unstack())
• Lack of loops and use of stdout means DTrace is 
not ideal for processing data
• We can fix this
• Cannot modify registers :’(  epic sad time
DTrace Cautionaries
A few issues to be aware of:
• DTrace drops probes by design
• Tune options, narrow trace scope to improve 
performance
• Some libraries and functions behave badly
• overflows can cause violations before function 
return
RE with Ruby, DTrace and the 
Mach API
RE:Trace & RE:dbg
RE:Trace
• RE:Trace combines Ruby with DTrace
• Ruby gives us the power of OOP, text processing, 
iteration
• RE:Trace utilizes Ruby libdtrace bindings, written 
by Chris Andrews
• Can be the glue which combines the power of 
several existing Ruby RE frameworks (idarub, 
librub, metasm, MSF3) 
• RE:Trace is similar to programmatic frameworks 
(pyDBG, noxDBG, immDBG)
• Includes script to dump and search memory
IdaRub
• Wraps IDA interface
• Ruby code is the client
• Server is IDA plugin
• Ruby glues it all together
• IdaRub was released by Spoonm at REcon 2006
ida.set_item_color(eip, 3000)
More info: 
http://www.metasploit.com/users/spoonm/idarub/
RE:Trace and Exploit Dev
• Vulnerability analysis times can be dramatically 
reduced with RE:Trace
• DTrace probes allow you to track data input flow 
throughout a process to understand where and 
why memory corruption took place
• Methods that cause stack and heap corruption 
can be pinpointed using IDARub to integrate 
IDA’s static analysis features
RE:Trace and Code Coverage
• DTrace can “hook” every function in a process
• This makes it perfect for implementing a “code 
coverage aware” fuzzer
• Code coverage is useful for understanding what 
areas are being fuzzed
• Current RE code coverage monitors are mostly 
block based (PaiMei)
• We can use IDA to obtain block information or 
check code coverage at the function or instruction 
level
RE:dbg
• RE:dbg picks up where RE:Trace left off
• Programmatic debugger for mach debug API
• Partially exists on OS X in Python (see vtrace and 
Charlie Miller’s pydbg port)
Integrated Ruby based RE Toolset:
• Tracing : RE:Trace
• Disassembly:  IDArub
• Debugger reDBG
RE:dbg
• C code around Mach debugging API with Ruby 
bindings
• Higher level Ruby class to make everything easy
• Symbol resolution
• Read and write memory
• Walk memory segments
• Modify memory permissions
• Set breakpoints
• Exception handling
• Interface with IDA ( ... metasm?)
iPhoto Format String Exploit
• iPhoto format string vuln is a good test for 
automation
• URL handler bug: iphoto://%dd%n
• What we want to do is trace with RE:Trace until 
we hit printf with arg1=%25 (URL encoded %n)
• Use idarub to get disassembly info from IDA
• Set a break on RET of the function with reDBG 
• When breakpoint is hit, print out stack return 
address (or whatever you overwrote) to make 
sure the overflow was correct
RE:Trace/reDBG/IDArub
Progtext = “pid$target::__vfprintf:entry 
/copyinstr(arg2) == "%25n"/ {stop();}”
t = Dtrace.new
p = t.createprocess([ARGV[0]])
prog = t.compile progtext
prog.execute
t.go
p.Continue
ida,sess = IdaRub.auto_client
Func = ida.Get_func(eip)
function[0..4].each  do |line| 
  if line == “ret”
Dbg = reDBG.new
dbg.attach(pid)
       dbg.setBreak(line)
RE:dbg ASLR
• ASLR analysis
• Start the application, lookup addresses for 
application and library symbols
• Search through all memory for references to 
those addresses
• Rinse and repeat
Can you find an address that is always relative to 
an address of a useful function?
RE:dbg Soon!
If it’s not up in a week, bug us
MONITORING THE STACK
Writing a Stack Overflow Monitor with RE:Trace
Stack Overflow Monitoring
Programmatic control at EIP overflow time allows 
you to:
• Pinpoint the vulnerable function
• Reconstruct the function call trace