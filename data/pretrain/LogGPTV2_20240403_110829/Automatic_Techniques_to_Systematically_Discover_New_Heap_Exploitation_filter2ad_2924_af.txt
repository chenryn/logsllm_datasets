related techniques [37] and house-of-force, which HeapHop-
per fails to find because of an arbitrary size allocation.
ARCHEAP can find these techniques within a few minutes, as
they require fewer than five transactions.
8.2 Security Check Coverage
To show how exhaustively ARCHEAP explores the security-
sensitive part of the state space, we counted the number of
security checks in ptmalloc2 executed by ARCHEAP.
In
24 hours of exploration, ARCHEAP executed 18 out of 21
security checks of ptmalloc2: it failed to cover C2, C4, and
C21 in Table 11. We note that C21 is related to a concurrency
Name
Error message
free(): invalid next size (fast)
free(): invalid next size (normal)
free(): invalid size
corrupted double-linked list
corrupted double-linked list (not small)
free(): corrupted unsorted chunks
C1
C2
C3
C4 malloc(): corrupted unsorted chunks 1
C5 malloc(): corrupted unsorted chunks 2
C6 malloc(): smallbin double linked list corrupted
C7
C8
C9
C10 malloc(): memory corruption
C11
C12
C13
C14
C15 malloc(): memory corruption (fast)
C16 malloc_consolidate(): invalid chunk size
C17
C18
C19
C20 munmap_chunk(): invalid pointer
C21
double free or corruption (!prev)
double free or corruption (fasttop)
double free or corruption (top)
double free or corruption (out)
break adjusted to free malloc space
corrupted size vs. prev_size
free(): invalid pointer
invalid fastbin entry (free)
Version Xenial Bionic
2.3.4
2.21
2.11
2.11
2.11
2.11
2.3.4
2.3.4
2.4
2.3.4
2.3.4
2.3.4
2.3.4
2.3.4
2.3.4
2.27
2.10.1
2.26
2.0.1
2.4
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
—
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
2.12.1
Table 11: Security checks in ptmalloc2 covered by ARCHEAP;
an unique identifier for a check, an error message for its failure,
and version that the check is first introduced, and covered ones by
ARCHEAP in Ubuntu versions.
bug, which is outside of the scope of this work. C2 and C4
require a strict relationship between large chunks (e.g., the
sizes of two chunks are not equal but less than the minimum
size), which is probably too stringent for any randomization-
based strategies.
8.3 Delta-Debugging-Based Minimization
The minimization technique based on delta-debugging is ef-
fective in simplifying the generated PoCs for further analysis.
It effectively reduces 84.3% of redundant actions from orig-
inal PoCs (refer to §7.3) and emits small PoCs that contain
26.1 lines on average (see Table 12). Although our minimiza-
tion is preliminary (i.e., eliminating one independent action
per testing), the final PoC is sufficiently small for manual
analysis to understand impacts of the found technique.
9 Discussion and Limitations
Completeness. ARCHEAP is fundamentally incomplete
due to its random nature, so it would not be surprising at
all if someone discover other heap exploitation techniques.
HeapHopper, on the other hand, is complete in terms of given
models, i.e., exploring all combinations of transactions given
the length of transactions. Since their models are incomplete
USENIX Association
29th USENIX Security Symposium    1123
Version
2.15
2.19
2.23
2.27
Average
Raw
Mean
112.6
110.8
98.3
344.2
166.5
Std. dev
161
145
120
177
150.8
Minimized
Mean
25.9 (-77.0 %)
23.3 (-79.0 %)
22.5 (-77.1 %)
33 (-90.4 %)
26.2 (-84.3 %)
Std. dev
25.3
4.6
6.2
8.8
11.2
Table 12: Average and standard derivation of lines of raw and
minimized PoCs using delta debugging. It shows that the delta
debugging successfully removes 84.3% of redundant actions.
(or often error-prone), proper use of each approach is depen-
dent on the target use cases. For example, if one is looking
for a practical solution to find new exploitation techniques,
ARCHEAP would be a more preferable platform to start with.
Overfitting to fuzzing strategies. ARCHEAP’s approach
is quite generic in practice even with its specific fuzzing
strategies to the common design decisions in §2.1. First,
ARCHEAP can explore security issues related to APIs (e.g.,
double free) without loss of generality because of their stan-
dardization (see, §7.2). Second, ARCHEAP’s approach to
make random metadata is practically useful thanks to the
bipartite design of a real-world allocator. In particular, a
performance-focused allocator that places metadata in a
chunk (e.g., ptmalloc2) has little motivation to avoid the use
of in-place metadata or to violate the cardinal design for its
performance. If an allocator is not performance-oriented, it
will move its metadata to a dedicated place for better security
(e.g., jemalloc). Such a design will make all methods to gener-
ate metadata useless in finding heap exploitation techniques.
However, ARCHEAP still has a chance to cause overfitting:
our fuzzing strategies could be insufficient to examine cer-
tain allocators. In this case, one might have to devise own
models for proper space reduction to apply ARCHEAP to
non-conventional implementation. requiring in-depth under-
standing of a target allocator. For example, if an allocator
uses big-endian encoding for its size, a user should encode
this in ARCHEAP’s fuzzing strategies.
Scope. Unlike other automatic exploit generation work,
ARCHEAP focuses only on finding heap exploit techniques.
To make end-to-end exploits, we need to properly combine
application contexts, which is currently out-of-scope for this
project. Despite many open challenges in realizing fully au-
tomated exploit generation, we believe that ARCHEAP can
contribute by supplying useful primitives [58]. Moreover,
ARCHEAP focuses only on a user-mode allocator. To extend
ARCHEAP to kernel, we need to handle kernel-specific chal-
lenges, e.g., non-deterministism and zone-based allocation.
10 Related work
Automatic exploit generation (AEG). Automatic discovery
of heap exploit techniques is a small step toward AEG’s ambi-
tious vision [4, 10], but it is worth emphasizing its importance
and difficulty. Despite several attempts to accomplish fully
automated exploit generation [4, 10, 11, 33, 46, 58, 60, 70],
AEG, particularly for heap vulnerabilities, is too sophisti-
cated and difficult even for state-of-the-art cyber systems
[21, 30, 62, 67]. Recently, Repel et al. [58] propose symbolic-
execution-based AEG for heap vulnerabilities, but it only
works for much older allocators without security checks (pt-
malloc2 version 2.3.3) unlike ARCHEAP (2.23 and 2.27).
Heelan et al. [33, 34] demonstrate AEG for heap overflows
in interpreters, but specific to scriptable programs. Unlike
the prior work, ARCHEAP focuses on finding heap exploita-
tion techniques, which are re-usable across applications, in
modern allocators with full security checks.
Fuzzing beyond crashes.
There has been a large body
of attempts to extend fuzzing to find bugs beyond memory
safety [29, 75]. They often use differential testing, which
we used for minimization, to find semantic bugs, e.g., com-
pilers [73], cryptographic libraries [9, 53], JVM implemen-
tations [14] and learning systems [51]. Recently, Slow-
Fuzz [54] uses fuzzing to find algorithmic complexity bugs,
and IMF [69] to spot similar code in binary.
Application-aware fuzzing. Application-aware fuzzing is
one of the attempts to reduce the search space of fuzzing.
In this regard, there have been attempts to use static and dy-
namic analysis [13, 44, 52, 57], bug descriptions [74], and
real-world applications [12, 32, 39] to extract target-specific
information for fuzzing. Moreover, to reduce the search space
for applications that require well-formed inputs, researchers
have embedded domain-specific knowledge such as gram-
mar [35, 68, 73] or structure [9, 53] in their fuzzing. Similar
to these works, ARCHEAP reduces its search space by consid-
ering its targets and memory allocators, particularly exploiting
their common designs.
11 Conclusion
In this paper, we present ARCHEAP, a new approach using
fuzzing to automatically discover new heap exploitation tech-
niques. ARCHEAP’s two key ideas are to reduce the search
space of fuzzing by abstracting the common design of modern
heap allocators, and to devise a method to quickly estimate
the possibility of heap exploitation. Our evaluation with
ptmalloc2 and 10 other allocators shows that ARCHEAP’s ap-
proach can effectively formulate new exploitation primitives
regardless of their underlying implementations.
12 Acknowledgment
We thank the anonymous reviewers for their helpful feed-
back. This research was supported, in part, by the NSF
award CNS-1563848, CNS-1704701, CRI-1629851 and CNS-
1749711 ONR under grant N00014-18-1-2662, N00014-15-
1-2162, N00014-17-1-2895, DARPA AIMEE, and ETRI
IITP/KEIT[2014-3-00035], and gifts from Facebook, Mozilla,
Intel, VMware and Google.
1124    29th USENIX Security Symposium
USENIX Association
References
[1] anonymous. Once upon a free()... http://phrack.org/issues/
57/9.html, 2001.
[2] anonymous. Chrome os exploit: one byte overflow and sym-
links. https://googleprojectzero.blogspot.com/2016/12/
chrome-os-exploit-one-byte-overflow-and.html, 2016.
[3] argp and huku. Pseudomonarchia jemallocum. http://www.phrack.
org/issues/68/10.html, 2012.
[4] T. Avgerinos, S. K. Cha, A. Rebert, E. J. Schwartz, M. Woo, and
D. Brumley. AEG: Automatic exploit generation. In Proceedings of
the 18th Annual Network and Distributed System Security Symposium
(NDSS), San Diego, CA, Feb. 2011.
[5] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley. Enhancing
symbolic execution with veritesting. In Proceedings of the 36th In-
ternational Conference on Software Engineering, pages 1083–1094.
ACM, 2014.
[6] Awakened.
How a double-free bug in WhatsApp turns to
https://awakened1712.github.io/hacking/hacking-
RCE.
whatsapp-gif-rce/, 2019.
[7] blackngel. Malloc des-maleficarum. http://phrack.org/issues/
66/10.html, 2009.
[8] blackngel. The house of lore: Reloaded. http://phrack.org/
issues/67/8.html, 2010.
[9] C. Brubaker, S. Jana, B. Ray, S. Khurshid, and V. Shmatikov. Using
frankencerts for automated adversarial testing of certificate validation
in ssl/tls implementations. In Proceedings of the 35th IEEE Symposium
on Security and Privacy (Oakland), San Jose, CA, May 2014.
[10] D. Brumley, P. Poosankam, D. Song, and J. Zheng. Automatic patch-
based exploit generation is possible: Techniques and implications. In
Proceedings of the 29th IEEE Symposium on Security and Privacy
(Oakland), Oakland, CA, May 2008.
[11] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing
mayhem on binary code. In Proceedings of the 33rd IEEE Symposium
on Security and Privacy (Oakland), San Francisco, CA, May 2012.
[12] J. Chen, W. Diao, Q. Zhao, C. Zuo, Z. Lin, X. Wang, W. C. Lau,
M. Sun, R. Yang, and K. Zhang. IoTFuzzer: Discovering memory
corruptions in IoT through app-based fuzzing. In Proceedings of the
2018 Annual Network and Distributed System Security Symposium
(NDSS), San Diego, CA, Feb. 2018.
[13] P. Chen and H. Chen. Angora: Efficient fuzzing by principled search.
In Proceedings of the 39th IEEE Symposium on Security and Privacy
(Oakland), San Francisco, CA, May 2018.
[14] Y. Chen, T. Su, C. Sun, Z. Su, and J. Zhao. Coverage-directed dif-
ferential testing of jvm implementations. In Proceedings of the 2016
ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI), Santa Barbara, CA, June 2016.
[15] D. Delorie. malloc per-thread cache:
https:
//sourceware.org/ml/libc-alpha/2017-01/msg00452.html,
2017.
benchmarks.
[16] C. Eagle. Re: DARPA CGC recap.
dailydave/2017/q2/2, 2017.
http://seclists.org/
[17] M. Eckert, A. Bianchi, R. Wang, Y. Shoshitaishvili, C. Kruegel, and
G. Vigna. HeapHopper: Bringing bounded model checking to heap
implementation security. In Proceedings of the 27th USENIX Security
Symposium (Security), Baltimore, MD, Aug. 2018.
[18] C. Evans and T. Ormandy. The poisoned NUL byte, 2014 edi-
https://googleprojectzero.blogspot.com/2014/08/
tion.
the-poisoned-nul-byte-2014-edition.html, 2014.
[19] J. Evans.
Scalable memory allocation using jemalloc.
https://code.fb.com/core-data/scalable-memory-
allocation-using-jemalloc/, 2011.
[20] J. N. Ferguson. Understanding the heap by breaking it. In Black Hat
USA Briefings (Black Hat USA), Las Vegas, NV, Aug. 2007.
[21] ForAllSecure.
Unleashing the Mayhem CRS.
https://
forallsecure.com/blog/2016/02/09/unleashing-mayhem/,
2016.
[22] Free Software Foundation. The GNU C library. https://www.gnu.
org/software/libc/, 1998.
[23] Free Software Foundation. MallocInternals - glibc wiki. https:
//sourceware.org/glibc/wiki/MallocInternals, 2017.
[24] Free Software Foundation. malloc(3) - Linux manual page. http:
//man7.org/linux/man-pages/man3/malloc.3.html, 2017.
[25] g463. The use of set_head to defeat the wilderness. http://phrack.
org/issues/64/9.html, 2007.
[26] S. Ghemawat and P. Menage. Tcmalloc: Thread-caching malloc. http:
//goog-perftools.sourceforge.net/doc/tcmalloc.html,
2009.
[27] W. Gloger. Wolfram Gloger’s malloc homepage. http://www.
malloc.de/en/, 2006.
[28] F. Goichon. Glibc adventures: The forgotten chunk.
https:
//www.contextis.com/resources/white-papers/glibc-
adventures-the-forgotten-chunks, 2015.
[29] Google. syzkaller – linux syscall fuzzer. https://github.com/
google/syzkaller, 2017.
[30] GrammaTech.
http://blogs.grammatech.com/the-cyber-
grand-challenge, 2016.
[31] Gzob Qq. ares_create_query single byte out of buffer write. https: