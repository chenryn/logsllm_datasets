### 8.2 Security Check Coverage

To demonstrate the extent to which ARCHEAP explores security-sensitive parts of the state space, we counted the number of security checks in ptmalloc2 that ARCHEAP executed. Over a 24-hour period, ARCHEAP executed 18 out of 21 security checks in ptmalloc2. The three checks that were not covered are C2, C4, and C21, as shown in Table 11. It is worth noting that C21 is related to a concurrency bug, which is outside the scope of this work. C2 and C4 require a strict relationship between large chunks (e.g., the sizes of two chunks must be unequal but less than the minimum size), which is likely too stringent for any randomization-based strategies.

**Table 11: Security Checks in ptmalloc2 Covered by ARCHEAP**

| Name | Error Message | Version Introduced | Covered by ARCHEAP |
| --- | --- | --- | --- |
| C1 | free(): invalid next size (fast) | 2.3.4 | ✓ |
| C2 | free(): invalid next size (normal) | 2.3.4 | — |
| C3 | free(): invalid size | 2.21 | ✓ |
| C4 | corrupted double-linked list | 2.11 | — |
| C5 | corrupted double-linked list (not small) | 2.11 | ✓ |
| C6 | free(): corrupted unsorted chunks | 2.11 | ✓ |
| C7 | malloc(): corrupted unsorted chunks 1 | 2.3.4 | ✓ |
| C8 | malloc(): corrupted unsorted chunks 2 | 2.3.4 | ✓ |
| C9 | malloc(): smallbin double linked list corrupted | 2.3.4 | ✓ |
| C10 | malloc(): memory corruption | 2.3.4 | ✓ |
| C11 | — | — | — |
| C12 | — | — | — |
| C13 | — | — | — |
| C14 | — | — | — |
| C15 | malloc(): memory corruption (fast) | 2.27 | ✓ |
| C16 | malloc_consolidate(): invalid chunk size | 2.10.1 | ✓ |
| C17 | — | — | — |
| C18 | — | — | — |
| C19 | — | — | — |
| C20 | munmap_chunk(): invalid pointer | 2.26 | ✓ |
| C21 | double free or corruption (!prev) | 2.0.1 | — |

### 8.3 Delta-Debugging-Based Minimization

The minimization technique based on delta-debugging effectively simplifies the generated proofs of concept (PoCs) for further analysis. This method reduces 84.3% of redundant actions from the original PoCs (refer to §7.3) and produces smaller PoCs containing an average of 26.1 lines (see Table 12). Although our minimization is preliminary (i.e., eliminating one independent action per test), the final PoC is sufficiently small for manual analysis to understand the impact of the discovered techniques.

**Table 12: Average and Standard Deviation of Lines in Raw and Minimized PoCs Using Delta Debugging**

| Version | Raw Mean | Raw Std. Dev | Minimized Mean | Minimized Std. Dev |
| --- | --- | --- | --- | --- |
| 2.15 | 112.6 | 161 | 25.9 (-77.0%) | 25.3 |
| 2.19 | 110.8 | 145 | 23.3 (-79.0%) | 4.6 |
| 2.23 | 98.3 | 120 | 22.5 (-77.1%) | 6.2 |
| 2.27 | 344.2 | 177 | 33 (-90.4%) | 8.8 |
| Average | 166.5 | 150.8 | 26.2 (-84.3%) | 11.2 |

### 9. Discussion and Limitations

#### Completeness
ARCHEAP is fundamentally incomplete due to its random nature, so it would not be surprising if other heap exploitation techniques are discovered. HeapHopper, on the other hand, is complete in terms of given models, exploring all combinations of transactions up to a certain length. However, their models may be incomplete or error-prone, making the choice of approach dependent on the target use case. For example, if one is looking for a practical solution to find new exploitation techniques, ARCHEAP would be a more suitable starting point.

#### Overfitting to Fuzzing Strategies
ARCHEAP’s approach is quite generic in practice, even with its specific fuzzing strategies tailored to common design decisions. First, ARCHEAP can explore security issues related to APIs (e.g., double free) without loss of generality due to standardization (see §7.2). Second, ARCHEAP’s approach to generating random metadata is practically useful thanks to the bipartite design of real-world allocators. Performance-focused allocators that place metadata in a chunk (e.g., ptmalloc2) have little motivation to avoid in-place metadata or violate their cardinal design for performance. If an allocator is not performance-oriented, it will move metadata to a dedicated place for better security (e.g., jemalloc), rendering methods to generate metadata useless for finding heap exploitation techniques. However, ARCHEAP still has the potential to overfit: our fuzzing strategies might be insufficient for examining certain allocators. In such cases, users may need to devise their own models for proper space reduction, requiring in-depth understanding of the target allocator. For example, if an allocator uses big-endian encoding for its size, a user should encode this in ARCHEAP’s fuzzing strategies.

#### Scope
Unlike other automatic exploit generation (AEG) work, ARCHEAP focuses solely on finding heap exploitation techniques. To create end-to-end exploits, application contexts must be properly combined, which is currently out of scope for this project. Despite the many open challenges in fully automated exploit generation, ARCHEAP can contribute by supplying useful primitives [58]. Additionally, ARCHEAP focuses only on user-mode allocators. Extending ARCHEAP to the kernel would require handling kernel-specific challenges, such as non-determinism and zone-based allocation.

### 10. Related Work

#### Automatic Exploit Generation (AEG)
Automatic discovery of heap exploitation techniques is a step toward AEG's ambitious vision [4, 10], but it is important to highlight its significance and difficulty. Despite several attempts to achieve fully automated exploit generation [4, 10, 11, 33, 46, 58, 60, 70], AEG, particularly for heap vulnerabilities, remains sophisticated and challenging even for state-of-the-art cyber systems [21, 30, 62, 67]. Recently, Repel et al. [58] proposed symbolic-execution-based AEG for heap vulnerabilities, but it only works for older allocators without security checks (ptmalloc2 version 2.3.3) unlike ARCHEAP (versions 2.23 and 2.27). Heelan et al. [33, 34] demonstrated AEG for heap overflows in interpreters, but it is specific to scriptable programs. Unlike prior work, ARCHEAP focuses on finding heap exploitation techniques that are reusable across applications in modern allocators with full security checks.

#### Fuzzing Beyond Crashes
There have been numerous attempts to extend fuzzing to find bugs beyond memory safety [29, 75]. These often use differential testing, which we used for minimization, to find semantic bugs in compilers [73], cryptographic libraries [9, 53], JVM implementations [14], and learning systems [51]. Recently, SlowFuzz [54] uses fuzzing to find algorithmic complexity bugs, and IMF [69] to spot similar code in binaries.

#### Application-Aware Fuzzing
Application-aware fuzzing aims to reduce the search space of fuzzing. In this regard, there have been efforts to use static and dynamic analysis [13, 44, 52, 57], bug descriptions [74], and real-world applications [12, 32, 39] to extract target-specific information for fuzzing. Moreover, to reduce the search space for applications that require well-formed inputs, researchers have embedded domain-specific knowledge such as grammar [35, 68, 73] or structure [9, 53] in their fuzzing. Similar to these works, ARCHEAP reduces its search space by considering its targets and memory allocators, particularly exploiting their common designs.

### 11. Conclusion

In this paper, we present ARCHEAP, a new approach using fuzzing to automatically discover new heap exploitation techniques. ARCHEAP’s key ideas are to reduce the search space of fuzzing by abstracting the common design of modern heap allocators and to develop a method to quickly estimate the possibility of heap exploitation. Our evaluation with ptmalloc2 and 10 other allocators shows that ARCHEAP’s approach can effectively formulate new exploitation primitives regardless of their underlying implementations.

### 12. Acknowledgment

We thank the anonymous reviewers for their helpful feedback. This research was supported, in part, by the NSF awards CNS-1563848, CNS-1704701, CRI-1629851, and CNS-1749711, ONR grants N00014-18-1-2662, N00014-15-1-2162, and N00014-17-1-2895, DARPA AIMEE, and ETRI IITP/KEIT [2014-3-00035], as well as gifts from Facebook, Mozilla, Intel, VMware, and Google.

### References

[1] Anonymous. Once upon a free()... http://phrack.org/issues/57/9.html, 2001.
[2] Anonymous. Chrome OS exploit: One byte overflow and symlinks. https://googleprojectzero.blogspot.com/2016/12/chrome-os-exploit-one-byte-overflow-and.html, 2016.
[3] Argp and Huku. Pseudomonarchia jemallocum. http://www.phrack.org/issues/68/10.html, 2012.
[4] T. Avgerinos, S. K. Cha, A. Rebert, E. J. Schwartz, M. Woo, and D. Brumley. AEG: Automatic exploit generation. In Proceedings of the 18th Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA, Feb. 2011.
[5] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley. Enhancing symbolic execution with veritesting. In Proceedings of the 36th International Conference on Software Engineering, pages 1083–1094. ACM, 2014.
[6] Awakened. How a double-free bug in WhatsApp turns to RCE. https://awakened1712.github.io/hacking/hacking-whatsapp-gif-rce/, 2019.
[7] Blackngel. Malloc des-maleficarum. http://phrack.org/issues/66/10.html, 2009.
[8] Blackngel. The house of lore: Reloaded. http://phrack.org/issues/67/8.html, 2010.
[9] C. Brubaker, S. Jana, B. Ray, S. Khurshid, and V. Shmatikov. Using frankencerts for automated adversarial testing of certificate validation in SSL/TLS implementations. In Proceedings of the 35th IEEE Symposium on Security and Privacy (Oakland), San Jose, CA, May 2014.
[10] D. Brumley, P. Poosankam, D. Song, and J. Zheng. Automatic patch-based exploit generation is possible: Techniques and implications. In Proceedings of the 29th IEEE Symposium on Security and Privacy (Oakland), Oakland, CA, May 2008.
[11] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing mayhem on binary code. In Proceedings of the 33rd IEEE Symposium on Security and Privacy (Oakland), San Francisco, CA, May 2012.
[12] J. Chen, W. Diao, Q. Zhao, C. Zuo, Z. Lin, X. Wang, W. C. Lau, M. Sun, R. Yang, and K. Zhang. IoTFuzzer: Discovering memory corruptions in IoT through app-based fuzzing. In Proceedings of the 2018 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA, Feb. 2018.
[13] P. Chen and H. Chen. Angora: Efficient fuzzing by principled search. In Proceedings of the 39th IEEE Symposium on Security and Privacy (Oakland), San Francisco, CA, May 2018.
[14] Y. Chen, T. Su, C. Sun, Z. Su, and J. Zhao. Coverage-directed differential testing of JVM implementations. In Proceedings of the 2016 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), Santa Barbara, CA, June 2016.
[15] D. Delorie. Malloc per-thread cache: https://sourceware.org/ml/libc-alpha/2017-01/msg00452.html, 2017.
[16] C. Eagle. Re: DARPA CGC recap. http://seclists.org/dailydave/2017/q2/2, 2017.
[17] M. Eckert, A. Bianchi, R. Wang, Y. Shoshitaishvili, C. Kruegel, and G. Vigna. HeapHopper: Bringing bounded model checking to heap implementation security. In Proceedings of the 27th USENIX Security Symposium (Security), Baltimore, MD, Aug. 2018.
[18] C. Evans and T. Ormandy. The poisoned NUL byte, 2014 edition. https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html, 2014.
[19] J. Evans. Scalable memory allocation using jemalloc. https://code.fb.com/core-data/scalable-memory-allocation-using-jemalloc/, 2011.
[20] J. N. Ferguson. Understanding the heap by breaking it. In Black Hat USA Briefings (Black Hat USA), Las Vegas, NV, Aug. 2007.
[21] ForAllSecure. Unleashing the Mayhem CRS. https://forallsecure.com/blog/2016/02/09/unleashing-mayhem/, 2016.
[22] Free Software Foundation. The GNU C library. https://www.gnu.org/software/libc/, 1998.
[23] Free Software Foundation. MallocInternals - glibc wiki. https://sourceware.org/glibc/wiki/MallocInternals, 2017.
[24] Free Software Foundation. malloc(3) - Linux manual page. http://man7.org/linux/man-pages/man3/malloc.3.html, 2017.
[25] G463. The use of set_head to defeat the wilderness. http://phrack.org/issues/64/9.html, 2007.
[26] S. Ghemawat and P. Menage. Tcmalloc: Thread-caching malloc. http://goog-perftools.sourceforge.net/doc/tcmalloc.html, 2009.
[27] W. Gloger. Wolfram Gloger’s malloc homepage. http://www.malloc.de/en/, 2006.
[28] F. Goichon. Glibc adventures: The forgotten chunk. https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks, 2015.
[29] Google. syzkaller – Linux syscall fuzzer. https://github.com/google/syzkaller, 2017.
[30] GrammaTech. http://blogs.grammatech.com/the-cyber-grand-challenge, 2016.
[31] Gzob Qq. ares_create_query single byte out of buffer write. https://