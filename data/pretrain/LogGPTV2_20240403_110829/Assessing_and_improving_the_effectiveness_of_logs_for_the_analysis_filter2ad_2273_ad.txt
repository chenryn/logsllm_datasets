This is an essential 
events may inadvertently 
poor maintainability. 
following, 
the logging 
limitations, 
findings have been experienced 
by providing 
mechanism 
the focus is on the Apache Web Server. 
lead to performance 
results 
how 
use of log 
loss and 
in the 
Similar 
for the other case studies. 
has been improved. 
We describe 
Due to space 
achieved 
specific examples  showing 
Figure 9: apcpalloc 
(apcpools.c, 
lines 637-638) 
Example 
#2: ap_directory_walk. NULL pointers 
(ranked 4th according 
We found that the 
to 
are not the only cause of halt failures. 
ap_directory_walk function 
Table 5), is sensitive 
Figure 10 reports 
detected 
before its use, as shown by lines of code 2-5. As in the 
previous 
a specific example. This error can be 
the suitability 
and logged by verifying 
case, additional 
could be issued. 
operations 
to faults 
leading 
of an index 
to bad array indexes. 
I  / / ... omissis ... 
2 if(baindex(filename_len))) 
3  log('ap_directory_walk: 
4  gracefu:Lstop(); 
5  } 
6 r->filename[filename_len]=O; 
7 temp_slash= I; 
{ 
using bad array index'); 
We analyze 
memory dumps generated 
by the operating 
Figure 10: ap_directory-
walk (request.c, 
lines 739-740) 
system in case of halt failures. 
most frequent functions executed during 
descending 
a halt failure, 
Table 5 reports 
the 10 
in 
order. 
Table 5: Functions 
occurrences) 
. 
most prone to halt failures 
(by # of 
#occ. Function 
Function 
apr_palloc  435  apr_pollsecadd 221 
386  add_any _filter_handle 
216 
ap_escape_Iogitem 
353  apjead_request 213 
apr_sockecaddret 
ap_directory 
_walk  304  core_create_req 198 
175 
ap_core_output_filter 
258  ap_core_inpuCfilter 
# occ. 
due to the 
in an unlogged 
guide­
should check before their use the value 
we define the following 
Analysis 
that bad memory accesses 
reveals 
of a software fault may result 
array indexes, 
propagation 
system halt. Accordingly, 
line: "developers 
of pointers, 
containing 
this type of variables  requires 
and it may result in too high an overhead 
However, our approach 
most likely 
number of check-instructions 
a memory address". 
Inserting 
identifies 
a failure. 
to exhibit 
a high development 
effort, 
at runtime. 
This significantly 
limits 
the 
as well as other variables 
source code locations 
a check before 
We perform the same analysis 
6 reports 
the campaign, 
the 10 most frequent 
in descending 
order. 
to be inserted. 
for silent 
failures. 
Table 
during 
experienced 
functions 
978-1-4244-7501-8/10/$26.00 
©2010 IEEE 
464 
DSN 2010:  Cinque 
et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:05 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEE/IFIP 
International 
Conference 
on Dependable 
Systems & Networks (DSN) 
Table 6: Functions 
occurrences). 
most prone to silent 
failures 
(by # of 
Function  # occ. Function 
apr_sockecaccept 
apr_sockecsendfile 
ap_escape_logitem 
apr_sockecsendv 
ap_directory 
364  add_any _filter_handle 9 
59  ap_allow 
56  ap_byterange_filter 9 
25  ap_invoke_filter_init 
9 
_walk I7  ap_seclistner  9 
_standard_methods 
# occ. 
9 
most of the Web Server internal 
for incoming 
connections, 
processes 
while only 
when we force a memory dump to 
We exclude the apr_socket_accept function 
from 
failure 
for 
We found that in case of a silent 
waiting 
the analysis. 
apr_socket_accept, 
be generated, 
are correctly 
a single process 
fault. The analysis 
Table 6 reveals 
to software faults triggering 
specific 
that unlogged 
is actually 
of the remaining 
functions 
reported 
in 
are mainly due 
failures 
silent 
infinite 
loops. We report a 
in the following. 
example showing this scenario 
hanged because of the injected 
*d++ =  ' \\ ' ; 
switch(*s) { 
case '\b'; 
*d++ =  'b'; 
break; 
II ... omissis 
I int current_iterations 
=  0; 
2 for (; *s; ++s){ 
3  if (TEST_CHAR(*s, T_ESCAPE_LOGITEM» 
4 
5 
6 
7 
8 
9 
10  defaul t ; 
\I 
12  )) 
13  else { 
14  *d++ =  *s;) 
15  if(current_iterations++ 
16  log(' ap_invoke_filter_init: 
17 
18  log('Potential 
19  } 
20 
c2x(*s, 'x', d); 
\ 
==  MAX_ITERATIONS) 
{ 
ITERATIONS exceeded'); 
cause: linked list corruption'); 
of cycles when they are controlled 
by 
number of iterations 
complex variable 
number of iterations 
nI, n2, ... , 
during fault-free 
factor (e.g., 
manipulations". 
A suitable  maximum 
is K x max{nI,n2, 
... ,nT}, where 
nT and K are the observed 
runs of the application, 
number of iterations 
and a mUltiplying 
3), respectively. 
In particular 
by modifying 
the 
by the previous 
in order 
leads to the 
code into the source of the Web 
campaign 
actually 
the logging 
functions, 
mechanisms 
as described 
of the logging 
guidelines. 
to the proposed 
that an additional 
We repeat the fault injection 
are logged by the Web Server, 
We integrate 
Server according 
we focus on the described 
source code of the Web Server, 
examples. 
to figure out if the code modification 
improvement 
We experience 
failures 
the original 
the achieved 
instances 
6). In fact, a failure 
(e.g., 
instances 
silent 
when compared to the former fault injection 
covering 
of the target functions 
may generate 
processes); 
multi-threaded 
of the same failure 
version 
improvement 
56.3% and 81.2% of the failures, 
(as depicted 
location. 
increases 
Coverage 
failures 
with respect 
of the code. It should be noted that 
to 
is not equal to the number of 
in Tables 5, 
for halt and 
of the program. 
114 halt and 52 silent 
campaign, 
respectively. 
several memory dumps 
this may lead to multiple 
by 10.1 % and  20.8%, respectively, 
6 Lessons learned 
in the context 
In this paper we evaluated 
mechanisms 
By means of fault injection 
logging 
campaigns 
studies. 
that, in most cases, logs are not able to provide 
information 
faults. 
the effectiveness 
of three real-world 
case 
we showed 
any useful 
In particular 
about failures 
from injected 
we found that: 
resulting 
of current 
software 
case studies, 
of logged failures 
• The coverage of current logging mechanisms, 
in the 
is no more than 40%. The 
ranges between 
proposed 
percentage 
a minimum 
of 35.6%, i.e., the MySQL DBMS, and a maximum 
of 42.1 %, i.e., the TAO OpenDDS (Subscriber 
This result 
failures 
logs during system operations. 
side). 
that about 6 out of every 10 actual 
due to software faults 
do not leave any trace in 
suggests 
• Software 
systems 
are most prone to log errors that occur 
Figure 11: ap_escape_logitem 
(util.c, 
lines 1795-1826) 
injected 
lines of code. It is a switch construct 
Figure 11 
Example 
#3: ap_escape_logitem. Several 
for loop in this function. 
make an infinite 
seven case clauses. 
input re­
from a software fault makes the cycle never end. A 
to deal with this error is to pro­
ex­
faults 
shows the involved 
encapsulating 
sulting 
simple but effective 
duce a message when the number of current 
ceeds a maximum, estabilished 
value (lines 
Figure 11). This message eases the failure 
example, 
Leading from the described 
A malformed 
solution 
of code 1, 15-19, 
analysis 
process. 
following 
logging 
guideline: 
"developers 
we define the 
should check the 
rather than algorithmic 
system resources 
with operating 
ones. Both Apache Web Server and MySQL DBMS 
are able to log software 
files, memory or IPCs management. 
leading,  for 
management 
example, 
or concurrency 
Algorithmic 
loops, wrong buffer 
resulting 
to infinite 
faults 
errors 
in bad sockets, 
issues are mainly unlogged. 
influence the effectiveness 
of 
the logging mechanism. 
architecture 
log failures. 
effective 
of the DDS increases 
The use of the mysqld_safe 
to 
process 
is an 
to log almost all halt failures. 
solution 
the probability 
We find that the distributed 
iterations 
• Architectural 
features 
978-1-4244-7501-8/101$26.00 
©2010 IEEE 
465 
DSN 2010: Cinque et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:05 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP 
International 
Conference 
on Dependable 
Systems & Networks (DSN) 
coverage. 
infrastruc­
[5]  J.  Duraes 
software faults 
IntI. Con! on Dependable 
and H. Madeira. Generic faultloads based on 
ng. In Proc. of 
2004. 
for dependability 
Systems and Networks, 
benchmarki
[6] J. Duraes and H. Madeira. Emulation 
of software faults:  A 
• Designing 
specific logging 
support 
increases 
results 
show that a distributed 
logs at the publisher 
the number of logged 
sides may increase 
The addition 
Experimental 
ture for collecting/correlating 
subscriber 
failures. 
event collection, 
approaches 
developers 
transfer 
could provide additional 
at the cost of the overhead 
for 
log coverage. 
data to 
can also increase 
node or process. 
to a dedicated 
of a process, 
of log event 
failure 
These 
and 
responsible 
The approach 
for improving 
logs, based on the analysis 
during the 
us to draw a few general 
enabled 
locations 
campaign, 
identified 
as well as to significantly 
of the most frequent failure 
experimental 
guidelines 
a minimal impact on the source code. Although 
full coverage, 
need to introduce 
cation, 
instrumentation 
efforts 
100%, is not feasible, 
code in every possible 
trade-off 
i.e., ideally 
logging 
and improved 
our approach 
a balanced 
provides 
increase 
between 
effectiveness. 
achieving 
due to the 
failure 
lo­
coverage 
with 
Future work will encompass 
the definition 
of a wider set 
of guidelines 
improve the suitability 
faults. 
as well as the investigation 
of logs for the analysis 
of techniques 
of software 
to 
Acknowledgment 
field  data 
on Software Engineering, 
study and a practical 
32( 11 ) : 849-867, 2006. 
approach. 
IEEE Transactions 
[7] Gartner and Affiliates. Hype cycle for application 
development. 
id number g00
1 47982. 29 June 2007. 
[8] J. Gray. Why do computers 
stop and what can  be done 
about it. In Proc. of Symp. on Reliability in Distributed 
Software and Database 
Systems, 1 986. 
[9] J. P. Hansen and D. P. Siewiorek. Models for time coales­
cence in event logs. In Proc. of IntI. Symp. on Fault-Tolerant 
Computing, pages 221 -227, 1 992. 
[ 1 0] M. Hsueh, R. Iyer, and K. Trivedi. 
Modeling 
Based on Real Data: a Case Study. IEEE Transactions 
Computers, 37(4):478-484, April 1 98 8 .  
Performability 
on 
[ 1 1] M. Kalyanakri
shnam, Z. Kalbarczyk, 
and R. K. Iyer. Failure 
data analysis of a LAN of windows NT  based 
In Proc. of Symp. on Reliable 
Distributed 
Systems, 1 999. 
computers. 
[ 1 2] L. Keller, 
P. Upadhyaya, and G. Candea. ContErr: A Tool 
for Assessing 
IntI. Con! on Dependable 
Resilience 
to Human Configuration 
Systems and Networks, 
Errors.  In 
2008. 
[ 1 3] R. L. O. Moraes, J. Duraes, R. Barbosa, E. Martins, and 
H. Madeira. Experimental 
son Using Software Fault Injection. In Proc. of IntI. Con! 
on Dependable 
Systems and Networks, 
Risk Assessment and Compari­
2007. 
[ 1 4] A. J. Oliner and J. Stearley. 
say: 
A  study of five system logs. In Proc. of IntI. Con! on 
pages 575-584. 
Dependable 
Computer Society, 2007. 
Systems and Networks, 
What supercomputers 
IEEE 
We would like to thank our shepherd 
Kimberly 
Keeton 
[ 1 5]  D.  L. 
Oppenheimer, 
A. Ganapathi, and D.  A. Patterson. 
fail, and what can be done  about  it?  In 
Why 
do internet 
USENIX Symp. on Internet Technologies 
services 
2003. 
and  M. Malek. Using Hidden Semi-Markov 
and Systems, 
reviewers 
(CRITICAL-ST
"CRITICAL Software 
[ 1 6] F. Salfner 
for their help in improving 
supported 
by the 
for an Evolution­
EP, http://www
Marie Curie Industry-Academia 
and the anonymous 
this paper. This work has been partially 
project 
Technology 
ary  Partnership" 
step.eu), 
Pathways (lAPP) number 230672, within the context 
the Seventh Framework 
Programme (FP7), and by the 
Italian 
(MIUR) within the framework of the project 
Off-The-Shelf 
scale Complex Critical 
http://dots-lcci.prin.dis.unina.it),DM1407. 
and Research 
"Dependable 
Infrastructures" 
based middleware 
Partnerships 
systems for Large­
for Education, 
(DOTS-LCCI, 
University, 
[ 1 7] B. Schroeder 
.critical­
and 
of 
Ministry 
Models for Effective 
the 26th IEEE Symp. on Reliable 
Online Failure 
Prediction. In Proc. of 
Systems, 
Distributed 
2007. 
and G.  A. Gibson. A large-scale study of 
systems. In Proc. 
in high-performance 
failures 
of Inti. Con! on Dependable 
computing 
Systems and Networks, 
and Z. Kalbarczyk. 
[ 1 8] D. Siewiorek, R. Chillarege, 
Trends and Experimental 
on Industry 
ability. 
Computing, 1 (2): 109- 1 27, April-June 
IEEE Transactions 
on  Dependable 
Research 
[ 1 9] L. Silva. Comparing Error Detection 
2004. 
Techniques for Web 
2006. 
Reflections 
in Depend­
and Secure 
References 
[ 1 ]  A. Avizienis, J. Laprie, B. Randell, 
and C. Landwehr. 
Basic  Concepts and Taxonomy of Dependable 
Computing. IEEE Trans.  on  Dependable 
Computing, 2004. 
and Secure 
and Secure 
[2]  M. F. Buckley and D. P. Siewiorek. VAXN MS event 
and analysis. In Symposium on Fault-Tolerant 
monitoring 
Computing, 1 995. 
[3] J. Christman
sson and P. Santhanam. Error Injection 
Aimed 
at Fault Removal in Fault Tolerance 
for Error Selection 
Proc. Symp. on Software Reliability 
using Field Data on Software Faults. In 
[4] D. Cotroneo, S .  Orlando, and S .  Russo. Failure 
Machine. 
tion and Analysis of the Java 
26th IntI. Con! on Distributed 
Virtual 
Computing Systems, 
2006. 
1 996. 
Engineering, 
Classifica­
In Proc. of 
Mechanisms-Criteria 
assessment of 
and wtmpx 
Applicati
on Network Computing and Applications, 
ons: An Experimental 
2008. 
Study. 7th IEEE IntI. Symp. 
[20] C. Simache  and 
M. Kaaniche. 
Availability 
sunOSlsol
log  files
Dependable 
aris unix systems based on syslogd 
:  A case study. In Pacific Rim IntI. Symp. on 
Computing, 2005. 
[21 ]  E. Voas, F. Charron, 
man. Predicting 
IEEE Software, 1 4(4):73-8 3 ,  1 997. 
G.  McGraw, 
and M. Fried­
How Badly "Good" Software Can Behave. 
K. Miller, 
[22] J. Xu, Z. Kalbarczyk, 
and R. Iyer. Networked 
Windows NT 
Data Analysis. In Proc. Pacific Rim 
Computing, 1 999. 
[23] w. Xu, L. Huang, A. Fox, D. Patterson, and M. Jordan. 
System Field Failure 
International 
Symposium on Dependable 
Large-Scale System Problems 
Detecting 
Logs. In Proceedings 
2009. 
on Operating Systems Principles, 
of the ACM SIGOPS 22nd symposium 
by Mining Console 
[24] Z. Zheng, Z. Lan, B .  Park, and A. Geist. System log pre­
processing 
Conference on Dependable 
to improve failure 
predicti
Systems and Networks, 
2009. 
on. In International 
978-1-4244-7501-8/101$26.00 
©201O IEEE 
466 
DSN 2010: Cinque et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:05:05 UTC from IEEE Xplore.  Restrictions apply.