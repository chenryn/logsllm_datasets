病毒"基因"的提取
病毒 基因 的提取
•
把完整功能的病毒看作可拆分为一个个单独的函数，我们将这些函数分为“基因函数” + “工具
函数”。 本文使用的一种分类情况：
•
基因函数包括6个：
•
m
delta
（重定位函数）
•
my_delta                     （重定位函数）
•
my_get_k32_base_addr         （获得kernel32基址）
•
my_get_apis_addr             （获得病毒需要的API）
•
my_find_director             （查找要感染的文件）
•
my_payload                   （执行病毒攻击载荷）
•
my_exit                      （退出）
•
工具函数包括不限：
•
my crc32
（计算一段buff的crc32值）
•
my_crc32                     （计算一段buff的crc32值）
•
my_infect_file               （感染一个指定文件）
•
my_lde_opsize                （计算一个指定位置的指令长度）
•
my_alloc_virus_body          （分配一段内存空间给病毒体）
•
my_find_jump_or_call         （搜索宿主的call/jump指令）
•
my_safe_api_address          （获得safe-api的地址）
•
my_gen_and_proc_code         （产生一段遗传感染的代码）
•
my mig
（产生一个指定的随机寄存器指令）
•
my_mig                       （产生一个指定的随机寄存器指令）...
病毒"基因"的提取
病毒 基因 的提取
• 如何确定“基因函数”的数量？
• 通过程序测试，统计正常程序代码段中的call的数量。
•
0xff10  ~ 0xff13   -
call   [Rx]       eax ～
edx
•
0xff16
~ 0xff17
-
call
[Rx]
esi
～
edi
0xff16   0xff17   
call   [Rx]       esi  
edi
•
0xffd0  ~ 0xffd7   -
call   Rx         eax ～
edi
•
0xff15  
-
call   [addr]     间接寻址
•
0
8
ll
dd
直接寻址
•
0xe8               -
call   addr       直接寻址
• 为什么选择call指令来作为基因函数的数量测试依据？
为什么选择
指令来作为基因函数的数量测试依据
• 我们希望病毒能与宿主程序处于同一生存周期，尽量”延
长“病毒的执行过程
长“病毒的执行过程。
病毒"基因"的提取
病毒 基因 的提取
•
一些常用程序的代码段call的统计：
•
migpwd.exe        (7)  \%system32%\ 目录下的文件
•
mmc exe
(7)
•
mmc.exe           (7)
•
mqtgsvc.exe       (15) 
•
•
avpcc exe
(9)
\avp\ 目录下
avpcc.exe         (9)  ...\avp\ 目录下
•
AVPExec.exe       (10)
•
AVPInst.exe       (10)
•
klav.exe
(8)
klav.exe          (8)
•
360Diagnose.exe  （11）...\360safe\ 目录下
•
360FunPro.exe    （9）
•
360leakfixer.exe （8）
•
...
•
结论 ： ”基因函数“的选取上4～6较为合适。
宿主交叉/变异点的选择
宿主交叉/变异点的选择
•
宿主的哪些位置可作为交叉点？
•
1 能体现出宿主程序"处于运行中某阶段“的指令 ，显然call 指令是最好的
一个选择.
个选择.
•
2 选择的位置要有随机化。
•
利用z0mbie 统计的一般程序的指令使用频率：
•
8B  6588971    15%      mov modr/m
•
FF  2736426     6%      push modr/m
•
E8  2509099     6%      call
•
83  2240885     5%      cmp/add modr/m (including add esp, xx after call)
•
89
2045133
4%
mov modr/m
•
89  2045133     4%      mov modr/m
•
8D  1573296     3%      lea modr/m
•
50  1423289     3%      push eax
•
74  1269798     3%      jz
•
6A  1064820     2%      push xx
•
......
3 可以把宿主程序看作是由这些高频指令分割组合而成，而这些位置
就是交叉点
就是交叉点。
宿主交叉/变异点的选择
宿主交叉/变异点的选择
•
获得宿主交叉点的随机位置算法:
•
1 随机选择若干个高频指令中某一个指令作为本次搜索的定位点指令fre ins
1 随机选择若干个高频指令中某
个指令作为本次搜索的定位点指令fre_ins。
•
2 在搜索到宿主代码段call 指令后,匹配call 后面指令是否出现fre_ins指
令，若有则记录该位置偏移cross_ins_off并转向步骤3。
_
_
•
3 分析cross_ins_off值距离下一个call之间是否有5字节，不足则
•
cross_ins_off += calc_ins_len,跳向步骤1，继续进行寻找,大于等于5字节
则记录下该位置及长度
i
l
作为
个可选的交叉点 进入步骤4
则记录下该位置及长度cross_ins_len，作为一个可选的交叉点,进入步骤4。
•
4  产生一个新的fre_ins,重复步骤2
•
5  记录下本次搜寻到的交叉点个数，除以病毒基因函数个数，得到一个平均
值cp_average。
•
注意：要查找到交叉点处指令不能包含操作ebp，esp的指令 跳转指令。
注意：要查找到交叉点处指令不能包含操作ebp，esp的指令,跳转指令。
宿主交叉/变异点的选择
宿主交叉/变异点的选择
•
当用上面算法的得到的cp_average =5字节的空间的指令位置，记录该值
若该方式得到的
仍然小于
那么不进行感染
ins_off,若该方式得到的cp_average仍然小于1，那么不进行感染。
•
因为得到这些ins_off值本身可能处于jz，jnz 等条件分支中，所以为了增大
_
j
j
感染几率，假设cp_average = N,那么每N个连续的cross_ins_off的位置，需
要用同一个病毒的DAN(i)函数去hook掉。
•
下图是winxp-sp2下记事本notepad.exe的入口点。
下图是
p
p 下记事本
p
的入
点
Stub区域的组成元素
Stub区域的组成元素
•
构造stub区域：
•
1将宿主ins_off位置抽出若干条大于5字节指令，copy到stub区域，
记为元素1
记为元素1。
•
2病毒的“基因函数”，以后将记为DNA函数记为元素2。
•
3将Safe-API记为元素3。
S f
API 例子
•
Safe-API 例子：
•
user32.dll  
•
ActivateKeyboardLayout(2),
( )
•
GetCaretPos(5) ...
•
kernel32.dll
•
UTUnRegister(1) ,              
•
IsDBCSLeadByteEx(2) ...
•
Gdi32.dll  
•
AbortDoc(1) , Chord(9) , CreateBitmap(5)...
bo t oc( ) , C o d(9) , C eate
t ap(5)...
Safe-API的参数问题
Safe API的参数问题
•
需要产生一个看似合法空间的safe api 参数 ，否则都是随机产生数字，可
能会导致因启发式报警。
•
;@1 产生一个合法的地址参数，0 ~
1000h 随机数字+ 0x401000 基址
;@1 产生
个合法的地址参数，0 
1000h 随机数字  0x401000 基址
•
;@2 产生一个1000h 的整数,仿真句柄
•
;@3 产生一个7c000000h为基址的参数，仿真kernel32基址
•
;@4 产生一个80000000h的数字
•
;@5 产生一个数字0 ～ 10
•
;@6 产生一个0
•
;@7   push eax
•
;@8   push ebx
•
;@9   push [ecx+eax];
•
;@10  push edi
[
]
•
;@11  push [esi];
•
...
•
其中这些操作寄存器的参数要慎重，因为可能产生”非法“，内存寻址的地
址。
Stub 区域的构造
Stub 区域的构造
•
针对宿主程序交叉点的修改可以有几种常见的方式：
1 直接修改为
ll
本文使用的方式
•
1 直接修改为call xxxxxxxx ，本文使用的方式。
•
2 直接修改为jmp xxxxxxxx ，因和壳的某些方式相似，容易引起一
些过度敏感的启发式扫描报警
些过度敏感的启发式扫描报警。
•
3 push xxxxxxxx  ；该方式同上，也可能会引起启发式报警。
•
ret 
•
•
4 如果宿主的交叉点可用空间足够大，可使用一些技巧，混淆直接获
取控制的方式
比如
这样对抗静态启发式分析
取控制的方式，比如jmp Rx，这样对抗静态启发式分析。
•
最好的方式是每次寻找宿主交叉点时，随机的选择其中一种。
Stub 区域的构造
Stub 区域的构造
•
stub区域的构造规则：
1 随机产生0
N个
f
API
用于本次 t b的构建
•
1 随机产生0～N个safe-API，用于本次stub的构建。
•
2 随机的组合元素1，2，3也就是宿主代码，safe-API,病毒DNA的执
行顺序
行顺序。
•
3 在产生这一区域的开头和结尾随机插入垃圾数据。
•
4 需要计算两种情况：
•
1） 如果cross_ins_len == 5 ,那么因为修改了宿主的为
call xxxxxxxx，刚好此时堆栈空间为宿主的下一条指令，那
么在stub 控制区返回宿主时，直接写入ret.
•
2） 如果cross_ins_len > 5,则在stub控制区恢复堆栈，然后用
返回宿主
jmp 返回宿主。
同一程序的不同感染效果
同一程序的不同感染效果
同一程序的不同感染效果
同一程序的不同感染效果
构造宿主/病毒的双执行环境
构造宿主/病毒的双执行环境
为何要构造
执行环境
•
为何要构造双执行环境？
•
1 遗传感染与以往病毒技术的最大不同点是，遗传感染将病毒转化为宿主程
序指令流的若干个部分。
•
2 以往的病毒技术，无论使用何种复杂的方式，入口模糊,嵌入式解密方式，
多态,变形等等，但对宿主程序的控制权都是一旦获得就不再释放，直到病毒