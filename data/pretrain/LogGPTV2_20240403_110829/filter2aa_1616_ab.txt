### 病毒“基因”的提取

#### 病毒基因的分类
将病毒的功能拆分为一个个单独的函数，这些函数可以分为“基因函数”和“工具函数”。本文采用的一种分类如下：

**基因函数**（共6个）：
- `m_delta`：重定位函数
- `my_delta`：重定位函数
- `my_get_k32_base_addr`：获取Kernel32基址
- `my_get_apis_addr`：获取病毒所需的API地址
- `my_find_director`：查找要感染的文件
- `my_payload`：执行病毒攻击载荷
- `my_exit`：退出

**工具函数**（不限于以下）：
- `my_crc32`：计算一段缓冲区的CRC32值
- `my_infect_file`：感染指定文件
- `my_lde_opsize`：计算指定位置指令的长度
- `my_alloc_virus_body`：为病毒体分配内存空间
- `my_find_jump_or_call`：搜索宿主程序中的call/jump指令
- `my_safe_api_address`：获取安全API的地址
- `my_gen_and_proc_code`：生成一段遗传感染代码
- `my_mig`：生成指定的随机寄存器指令

#### 如何确定“基因函数”的数量？
通过统计正常程序代码段中的call指令数量来确定。以下是常见的call指令形式：
- `0xff10` ~ `0xff13`：`call [Rx]` (eax ~ edx)
- `0xff16` ~ `0xff17`：`call [Rx]` (esi ~ edi)
- `0xffd0` ~ `0xffd7`：`call Rx` (eax ~ edi)
- `0xff15`：`call [addr]` 间接寻址
- `0xe8`：`call addr` 直接寻址

**为什么选择call指令作为基因函数的数量测试依据？**
我们希望病毒能与宿主程序处于同一生命周期，尽量延长病毒的执行过程。因此，call指令是一个合适的测试依据。

#### 常用程序代码段call指令的统计
- `migpwd.exe`：7次 (`%system32%\`目录下)
- `mmc.exe`：7次
- `mqtgsvc.exe`：15次
- `avpcc.exe`：9次 (`...\avp\`目录下)
- `AVPExec.exe`：10次
- `AVPInst.exe`：10次
- `klav.exe`：8次
- `360Diagnose.exe`：11次 (`...\360safe\`目录下)
- `360FunPro.exe`：9次
- `360leakfixer.exe`：8次

**结论**：选取4到6个“基因函数”较为合适。

### 宿主交叉/变异点的选择

#### 交叉点的选择标准
1. **体现宿主程序运行阶段的指令**：call指令是最佳选择。
2. **随机化**：利用z0mbie统计的一般程序指令使用频率，例如：
   - `mov modr/m` (8B)：15%
   - `push modr/m` (FF)：6%
   - `call` (E8)：6%
   - `cmp/add modr/m` (83)：5%
   - `mov modr/m` (89)：4%
   - `lea modr/m` (8D)：3%
   - `push eax` (50)：3%
   - `jz` (74)：3%
   - `push xx` (6A)：2%

3. **高频指令分割组合**：宿主程序由这些高频指令分割组合而成，这些位置就是交叉点。

#### 获取宿主交叉点的随机位置算法
1. **随机选择高频指令**：从高频指令中随机选择一个作为定位点指令`fre_ins`。
2. **匹配call指令后的指令**：在搜索到宿主代码段的call指令后，检查其后的指令是否出现`fre_ins`。如果出现，则记录该位置偏移`cross_ins_off`并进入下一步。
3. **分析偏移值**：检查`cross_ins_off`值距离下一个call之间是否有5字节。不足则更新`cross_ins_off`并继续寻找；大于等于5字节则记录该位置及长度`cross_ins_len`，作为一个可选的交叉点。
4. **产生新的`fre_ins`**：重复步骤2。
5. **计算平均值**：记录本次搜寻到的交叉点个数，除以病毒基因函数个数，得到平均值`cp_average`。

**注意**：交叉点处的指令不能包含操作ebp、esp的指令或跳转指令。

#### 交叉点处理
- 如果`cp_average < 1`，则不进行感染。
- 为了增加感染几率，假设`cp_average = N`，那么每N个连续的`cross_ins_off`位置，需要使用同一个病毒的DNA(i)函数去hook掉。

### Stub区域的构造

#### 构造规则
1. **随机选择safe-API**：随机产生0到N个safe-API，用于本次stub的构建。
2. **随机组合元素**：随机组合宿主代码、safe-API和病毒DNA的执行顺序。
3. **插入垃圾数据**：在该区域的开头和结尾随机插入垃圾数据。
4. **计算两种情况**：
   - 如果`cross_ins_len == 5`，修改宿主为`call xxxxxxxx`，并在stub控制区返回宿主时写入`ret`。
   - 如果`cross_ins_len > 5`，在stub控制区恢复堆栈，然后用`jmp`返回宿主。

### 同一程序的不同感染效果

#### 构造宿主/病毒的双执行环境

**为何要构造双执行环境？**
1. **遗传感染的特点**：遗传感染将病毒转化为宿主程序指令流的若干部分。
2. **传统病毒技术**：无论使用何种复杂方式，如入口模糊、嵌入式解密、多态等，一旦获得宿主程序的控制权就不会释放，直到病毒完成执行。

通过以上方法，可以有效地实现病毒的遗传感染，并确保其与宿主程序的生命周期紧密结合。