39, 54], none has taken the form of a principled analysis of
heap security directly applicable to arbitrary heap implemen-
tations. The closet work, by Repel et al. [39], explored heap
vulnerabilities in the context of automatic exploit generation,
but did not achieve the significant results of HEAPHOPPER’s
principled bounded model checking approach.
Bounded model checking. Model checking is a power-
ful technique to model a design as a finite state machine,
and verify a pre-defined set of temporal logic properties.
Bounded Model Checking (BMC) bounds the depth of paths
that are checked during model checking, and leverages SAT
solvers, instead of binary decision diagrams, in the verifica-
tion process to ease the memory pressure and improve the
scalability [6].
Symbolic execution is widely used in program testing
and verification, especially for detecting memory-related
defects [9]. We integrate symbolic execution into BMC to
allow for an easy and precise construction of finite state
automata and a straightforward modeling and verification
of security properties. Essentially, HEAPHOPPER creates
a symbolic finite automaton during the symbolic execution
of each generated program in a white-box manner. The
use of a state-of-the-art SMT solver like Z3 and a modern
symbolic execution engine like angr [46] helps improving
the complexity of the problems that can be successfully
examined by our system.
10 Conclusions
In this paper, we presented HEAPHOPPER, a novel, fully
automated tool, based on model checking and symbolic exe-
cution, to analyze, in a principled way, the exploitability of
heap implementations, in the presence of memory corruption.
Using HEAPHOPPER, we were able to identify both known
and previously unknown weaknesses in the security of dif-
ferent heap allocators. HEAPHOPPER showed that many
security checks can be easily bypassed by attackers (and
especially the negative impact that recent optimizations to
the standard glibc allocation implementation have had on
its security) and, at the same time, it helped in implementing
and evaluating more secure checks.
We envision that HEAPHOPPER will be used in the future
both by security researchers and allocators’ developers to
test and improve the security of existing and future heap
implementations. To this end, we have presented an in-depth
evaluation of HEAPHOPPER and we are releasing it as an
open-source tool.
11 Acknowledgments
We would like to thank our shepherd, Brendan Dolan-Gavitt,
for his help and comments.
This material
is based on research sponsored by
DARPA under agreement numbers FA8750-15-2-0084 and
HR001118C0060, and by the NSF under agreement CNS-
1704253. The U.S. Government is authorized to reproduce
and distribute reprints for Governmental purposes notwith-
standing any copyright notation thereon. The views and
112    27th USENIX Security Symposium
USENIX Association
conclusions contained herein are those of the authors and
should not be interpreted as necessarily representing the offi-
cial policies or endorsements, either expressed or implied, of
DARPA or the U.S. Government.
References
[1] glibc libc. https://www.gnu.org/software/libc/libc.html,
2017.
[2] musl libc. https://www.musl-libc.org/, 2017.
[3] ALEXANDER III, W. P., LEVINE, F. E., REYNOLDS, W. R., AND
URQUHART, R. J. Method and system for shadow heap memory leak
detection and other heap analysis in an object-oriented environment
during real-time trace processing, 2003. US Patent 6,658,652.
[4] AVGERINOS, T., CHA, S. K., REBERT, A., SCHWARTZ, E. J., WOO,
M., AND BRUMLEY, D. Automatic exploit generation. Communica-
tions of the ACM 57, 2 (2014), 74–84.
[5] BAO, T., WANG, R., SHOSHITAISHVILI, Y., AND BRUMLEY, D.
Your exploit is mine: Automatic shellcode transplant for remote ex-
ploits. In Proceedings of the IEEE Symposium on Security and Privacy
(S&P) (2017).
[6] BIERE, A., CIMATTI, A., CLARKE, E. M., STRICHMAN, O., ZHU,
Y., ET AL. Bounded model checking. Advances in computers 58, 11
(2003), 117–148.
[7] BITTAU, A., BELAY, A., MASHTIZADEH, A., MAZI`ERES, D., AND
BONEH, D. Hacking blind. In Proceedings of the IEEE Symposium
on Security and Privacy (S&P) (2014).
[8] BRUMLEY, D., POOSANKAM, P., SONG, D., AND ZHENG, J. Au-
tomatic patch-based exploit generation is possible: Techniques and
implications. In Proceedings of the IEEE Symposium on Security and
Privacy (S&P) (2008).
[9] CADAR, C., DUNBAR, D., ENGLER, D. R., ET AL. KLEE: Unas-
sisted and automatic generation of high-coverage tests for complex
systems programs. In Proceedings of the USENIX Symposium on
Operating Systems Design and Implementation (OSDI) (2008).
[10] CHA, S. K., AVGERINOS, T., REBERT, A., AND BRUMLEY, D.
Unleashing mayhem on binary code. In Proceedings of the IEEE
Symposium on Security and Privacy (S&P) (2012).
[11] CONTI, M., CRANE, S., DAVI, L., FRANZ, M., LARSEN, P., NE-
GRO, M., LIEBCHEN, C., QUNAIBIT, M., AND SADEGHI, A.-R.
Losing control: On the effectiveness of control-flow integrity under
stack attacks. In Proceedings of the ACM Conference on Computer
and Communications Security (CCS) (2015).
[12] COWAN, C., PU, C., MAIER, D., WALPOLE, J., BAKKE, P., BEAT-
TIE, S., GRIER, A., WAGLE, P., ZHANG, Q., AND HINTON, H.
Stackguard: Automatic adaptive detection and prevention of buffer-
overflow attacks. In Proceedings of the USENIX Security Symposium
(USENIX Security) (1998).
[13] COWAN, C., PU, C., MAIER, D., WALPOLE, J., BAKKE, P., BEAT-
TIE, S., GRIER, A., WAGLE, P., ZHANG, Q., AND HINTON, H.
Stackguard: Automatic adaptive detection and prevention of buffer-
overflow attacks. In Proceedings of the USENIX Security Symposium
(USENIX Security) (1998).
[14] DI FEDERICO, A., CAMA, A., SHOSHITAISHVILI, Y., KRUEGEL,
C., AND VIGNA, G. How the ELF ruined Christmas. In Proceedings
of the USENIX Security Symposium (USENIX Security) (2015).
[15] ECKERT, M. [PATCH] malloc/malloc.c: Mitigate null-byte overflow
attacks. https://sourceware.org/ml/libc-alpha/2017-10/
msg00773.html, 2017.
[16] ECKERT, M.
angr/heaphopper. https://github.com/angr/
heaphopper, 2018.
[17] ECKERT, M. malloc: Security implications of tcache. https://
sourceware.org/ml/libc-alpha/2018-02/msg00298.html,
2018.
[18] EVANS, C. Commit: 17f487b7afa7cd6c316040f3e6c86dc96b2eec30.
https://sourceware.org/git/?p=glibc.git;a=commit;h=
17f487b7afa7cd6c316040f3e6c86dc96b2eec30, 2017.
[19] EVANS, C. Further hardening glibc malloc() against single byte over-
flows. https://scarybeastsecurity.blogspot.com/2017/
05/further-hardening-glibc-malloc-against.html, 2017.
[20] EVANS, C., AND ORMANDY, T. The poisoned NUL byte, 2014 edi-
tion. https://googleprojectzero.blogspot.com/2014/08/
the-poisoned-nul-byte-2014-edition.html, 2014.
[21] EVANS, J. Scalable memory allocation using jemalloc. https:
//www.facebook.com/notes/facebook-engineering/
scalable-memory-allocation-using-jemalloc/
480222803919/, 2011.
[22] GLOGER, W. Ptmalloc. http://www.malloc.de, 2006.
[23] GOICHON, F.
Glibc adventures:
The forgotten chunks.
https://www.contextis.com/resources/white-papers/
glibc-adventures-the-forgotten-chunks, 2015.
[24] HEELAN, S. Automatic generation of control flow hijacking exploits
for software vulnerabilities. PhD thesis, University of Oxford, 2009.
[25] HEELAN, S., MELHAM, T., AND KROENING, D. Automatic heap
layout manipulation for exploitation. In Proceedings of the USENIX
Security Symposium (USENIX Security) (2018).
[26] HU, H., CHUA, Z. L., ADRIAN, S., SAXENA, P., AND LIANG, Z.
Automatic generation of data-oriented exploits. In Proceedings of the
USENIX Security Symposium (USENIX Security) (2015).
[27] HUANG, S.-K., HUANG, M.-H., HUANG, P.-Y., LAI, C.-W., LU,
H.-L., AND LEONG, W.-M. CRAX: Software crash analysis for
automatic exploit generation by modeling attacks as symbolic con-
tinuations. In Proceedings of the IEEE International Conference on
Software Security and Reliability (SERE) (2012).
[28] KAPIL, D. Unlink exploit.
https://heap-exploitation.
dhavalkapil.com/attacks/unlink_exploit.html, 2017.
[29] KIM, Y., DALY, R., KIM, J., FALLIN, C., LEE, J. H., LEE, D.,
WILKERSON, C., LAI, K., AND MUTLU, O. Flipping bits in memory
without accessing them: An experimental study of dram disturbance
errors. In Proceeding of the Annual International Symposium on
Computer Architecuture (ISCA) (2014).
[30] KLEIN, T. RELRO - a (not so well known) memory corruption mit-
igation technique. http://tk-blog.blogspot.com/2009/02/
relro-not-so-well-known-memory.html.
[31] LEA, D. A memory allocator (called Doug Lea’s Malloc, or dlmal-
loc for short). http://gee.cs.oswego.edu/dl/html/malloc,
1996.
[32] MCLACHLAN, J. G., LEROUGE, J., AND REYNAUD, D. F. Dynamic
obfuscation of heap memory allocations, 2016. US Patent 9,268,677.
[33] MOERBEEK, O. A new malloc for OpenBSD. In Proceedings of the
European BSD Conference (EuroBSDCon) (2009).
[34] NIKIFORAKIS, N., PIESSENS, F., AND JOOSEN, W. HeapSentry:
Kernel-assisted protection against heap overflows. In Proceedings of
the International Conference on Detection of Intrusions and Malware,
and Vulnerability Assessment (DIMVA) (2013).
[35] NOVARK, G., AND BERGER, E. D. DieHarder: Securing the heap.
In Proceedings of the ACM Conference on Computer and Communi-
cations Security (CCS) (2010).
[36] PAPPAS, V., POLYCHRONAKIS, M., AND KEROMYTIS, A. D.
Smashing the gadgets: Hindering return-oriented programming using
in-place code randomization. In Proceedings of the IEEE Symposium
on Security and Privacy (S&P) (2012).
USENIX Association
27th USENIX Security Symposium    113
[37] PAPPAS, V., POLYCHRONAKIS, M., AND KEROMYTIS, A. D. Trans-
parent ROP exploit mitigation using indirect branch tracing. In Pro-
ceedings of the USENIX Security Symposium (USENIX Security)
(2013).
[38] PRAKASH, A., HU, X., AND YIN, H. vfGuard: Strict protection for
virtual function calls in COTS C++ binaries. In Proceedings of the
Annual Network & Distributed System Security Symposium (NDSS)
(2015).
[39] REPEL, D., KINDER, J., AND CAVALLARO, L. Modular synthesis
of heap exploits. In Proceedings of the Workshop on Programming
Languages and Analysis for Security (PLAS) (2017).
[40] RICHARTE, G. Heap massaging. Proceedings of the Symposium sur
la scurit des technologies de l’information et des communications
(SSTIC) Rump sessions, http://actes.sstic.org/SSTIC07/
Rump_sessions/SSTIC07-rump-Richarte-Heap_Massaging.
pdf, 2007.
[41] ROBERTSON, W. K., KRUEGEL, C., MUTZ, D., AND VALEUR, F.
Run-time detection of heap-based overflows. In Proceedings of the
Large Installation System Administration Conference (LISA) (2003).
[42] SCHWARTZ, E. J., AVGERINOS, T., AND BRUMLEY, D. Q: Ex-
ploit hardening made easy. In Proceedings of the USENIX Security
Symposium (USENIX Security) (2011).
[43] SHACHAM, H. The geometry of innocent flesh on the bone: Return-
into-libc without function calls (on the x86). In Proceedings of the
ACM Conference on Computer and Communications Security (CCS)
(2007).
[44] SHELLPHISH. how2heap. https://github.com/shellphish/
how2heap, 2017.
[45] SHELLPHISH. how2heap – fix for the new check. https://github.
com/shellphish/how2heap/compare/58ae...d1ce, 2017.
[46] SHOSHITAISHVILI, Y., WANG, R., SALLS, C., STEPHENS, N.,
POLINO, M., DUTCHER, A., GROSEN, J., FENG, S., HAUSER, C.,
KRUEGEL, C., AND VIGNA, G. SoK: (State of) The Art of War:
Offensive Techniques in Binary Analysis. In Proceedings of the IEEE
Symposium on Security and Privacy (S&P) (2016).
[47] SILVESTRO, S., LIU, H., CROSSER, C., LIN, Z., AND LIU, T.
FreeGuard: A faster secure heap allocator. In Proceedings of the
ACM Conference on Computer and Communications Security (CCS)
(2017).
[48] SILVESTRO, S., LIU, H., LIU, T., LIN, Z., AND LIU, T. Guarder:
An efficient heap allocator with strongest and tunable security. In
Proceedings of the USENIX Security Symposium (USENIX Security)
(2018).
[49] SOTIROV, A. Heap Feng Shui in JavaScript.
in BlackHat Europe 2007,
presentations/bh-europe-07/Sotirov/Presentation/
bh-eu-07-sotirov-apr19.pdf, 2007.
Presentation
https://www.blackhat.com/
[50] SZEKERES, L., PAYER, M., WEI, T., AND SONG, D. SoK: Eternal
war in memory. In Proceedings of the IEEE Symposium on Security
and Privacy (S&P) (2013).
[51] VANEGUE, J. Heap models for exploit systems. In Proceedings of the
IEEE Security and Privacy Workshop on Language-Theoretic Security
(LangSec) (2015).
[52] WAISMAN, N. Understanding and bypassing Windows heap protec-
tion. Immunity Security Research (2007).
[53] WANG, M., SU, P., LI, Q., YING, L., YANG, Y., AND FENG, D.
Automatic polymorphic exploit generation for software vulnerabili-
ties. In Proceedings of the International Conference on Security and
Privacy in Communication Systems (SecureComm) (2013).
[54] ZENG, Q., WU, D., AND LIU, P. Cruiser: Concurrent heap buffer
overflow monitoring using lock-free data structures. In Proceedings of
the ACM SIGPLAN Conference on Programming Language Design
and Implementation (PLDI) (2011).
A Appendix: Source Code Samples
In the following we list two examples of source code of
exploitation attempts and the corresponding generated PoCs.
A.1 1-byte NULL Overflow
The sequence of transactions for the 1-byte NULL technique
in C source code, as it is passed to the symbolic execution
engine.
/*
* List of t r a n s a c t i o n s : M -M -M -F -O -M -M -F -F - M
*/
# include 
# include 
# include 
# include 
# include 
# include 
typedef struct _ _ a t t r i b u t e _ _ (( _ _ p a c k e d _ _ ) ) {
uint64_t * g l o b a l _ v a r ;
} c o n t r o l l e d _ d a t a ;
typedef struct _ _ a t t r i b u t e _ _ (( _ _ p a c k e d _ _ ) ) {
uint64_t data [0 x20 ];
} s y m b o l i c _ d a t a ;
void winning ( void ) {
puts ( " You win ! " ) ;
c t r l _ d a t a _ 0 ;
}
c o n t r o l l e d _ d a t a _ _ a t t r i b u t e _ _ (( aligned (16) ) ) ←(cid:45)
c o n t r o l l e d _ d a t a _ _ a t t r i b u t e _ _ (( aligned (16) ) ) ←(cid:45)
c o n t r o l l e d _ d a t a _ _ a t t r i b u t e _ _ (( aligned (16) ) ) ←(cid:45)
c o n t r o l l e d _ d a t a _ _ a t t r i b u t e _ _ (( aligned (16) ) ) ←(cid:45)
c o n t r o l l e d _ d a t a _ _ a t t r i b u t e _ _ (( aligned (16) ) ) ←(cid:45)
c o n t r o l l e d _ d a t a _ _ a t t r i b u t e _ _ (( aligned (16) ) ) ←(cid:45)
c t r l _ d a t a _ 4 ;
c t r l _ d a t a _ 3 ;
c t r l _ d a t a _ 1 ;
c t r l _ d a t a _ 2 ;
c t r l _ d a t a _ 5 ;
// All the symbolic values :
size_t w r i t e _ t a r g e t [4];
size_t offset ;
size_t h e a d e r _ s i z e ;
size_t m e m 2 c h u n k _ o f f s e t ;
size_t m a l l o c _ s i z e s [6];
size_t f i l l _ s i z e s [6];
size_t o v e r f l o w _ s i z e s [1];
int main ( void ) {