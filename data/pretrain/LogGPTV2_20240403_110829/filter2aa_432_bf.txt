很多函数都可以阻塞。像 accept()函数是阻塞的，所有以 recv 开头的函数也都是阻塞
的。它们这样做的原因是他们需要这样做。
当你一开始建立一个套接字描述符的时候，系统内核就被设置为阻塞状态。如果你不
想你的套接字描述符是处于阻塞状态的，那么你可以使用函数 fcntl()。
fcntl()函数声明如下：
#include 
#include 
int fcntl (int fd, int cmd, long arg）;
下面我们看一段程序片段：
#include
#include
sockfd = socket（AF_INET, SOCK_STREAM, 0）;
fcntl（sockfd, F_SETFL, O_NONBLOCK）;
⋯ ⋯
⋯ ⋯
这样将一个套接字设置为无阻塞模式后，你可以对套接字描述符进行有效的“ 检测” ．如
果你尝试从一个没有接收到任何数据的无阻塞模式的套接字描述符那里读取数据，那么读
取函数会马上返回–1 代表发生错误，全局变量 errno 中的值为 EWOULDBLOCK。
一般来说，这种无阻塞模式在某些情况下不是一个好的选择。假如你的程序一直没有
接收到传过来的数据，那么你的程序就会进行不停的循环来检查是否有数据到来，浪费了
大量的 CPU 时间，而这些 CPU 时间本来可以做其他事情的。
另外一个比较好的检测套接字描述符的方法是调用 select()函数。
6.10.8  套接字选择项 sel ect ( ) 函数
这个技术有一点点奇怪但是它对我们的程序确是非常有用的。
假想一下下面的情况：
你写的服务器程序想监听客户端的连接，但是你同时又想从你以前已经建立过的连接
中来读取数据。你可能会说：“ 没有问题，我不就是需要使用一个 accept()函数和一对儿recv()
函数吗？” 。不要这么着急，你要想想，当你调用 accept()函数阻塞的时候，你还能调用 recv()
函数吗？“ 使用非阻塞套接字！” 你可能会这么说。是的，你可以。但是如果你又不想浪
费宝贵的 CPU 时间，该怎么办呢？
Select()函数可以帮助你同时监视许多套接字。它会告诉你哪一个套接字已经可以读取
数据，哪个套接字已经可以写入数据，甚至你可以知道哪个套接字出现了错误，如果你想
知道的话。
下面是 select()函数的声明：
- 188 -
Linux网络编程
#include 
#include 
#include 
int select(int numfds, fd_set *readfds, fd_set *writefds,
fd_set *exceptfds, struct timeval *timeout);
下面是 select()函数的参数说明：
numfds 是 readfds，writefds，exceptfds 中 fd 集合中文件描述符中最大的数字加上
1。
readfds 中的 fd 集合将由 select 来监视是否可以读取。
writefds 中的 fds 集合将由 select 来监视是否可以写入。
exceptfds 中的 fds 集合将由 select 来监视是否有例外发生。
如果你想知道是是否可以从标准输入和一些套接字（sockfd）中读取数据，你就可以
把文件描述符和 sockfd 加入 readfds 中。numfds 的数值设成 readfds 中文件描述符中最大的
那个加上一，也就是 sockfd+1（因为标准输入的文件描述符的值为 0 ，所以其他任何的文
件描述符都会比标准输入的文件描述符大）。
当 select()函数返回的时候，readfds 将会被修改用来告诉你哪一个文件描述符你可以用
来读取数据。使用 FD_ISSET() 宏，你可以选出 select()函数执行的结果。
在进行更深的操作前，我们来看一看怎样处理这些 fd_sets。下面这些宏可以是专门进
行这类操作的：
FD_ZERO（fd_set *set）将一个文件描述符集合清零
FD_SET（int fd, fd_set *set）将文件描述符 fd 加入集合 set 中。
FD_CLR（int fd, fd_set *set）将文件描述符 fd 从集合 set 中删除．
FD_ISSET（int fd, fd_set *set）测试文件描述符 fd 是否存在于文件描述符 set 中．
那么，struct timeval 是什么呢？是这样的，一般来说，如果没有任何文件描述符满足
你的要求，你的程序是不想永远等下去的．也许每隔 1 分钟你就想在屏幕上输出信息：
“ hello！”。这个代表时间的结构将允许你定义一个超时。在调用 select()函数中，如果时间
超过 timeval 参数所代表的时间长度，而还没有文件描述符满足你的要求，那么 select()函
数将回返回，允许你进行下面的操作。
这个 timeval 结构定义如下：
struct timeval
{
int tv_sec ; 
/* 秒数 */
int tv_usec ; 
/* 微秒 */
} ;
只需要将 tv_sec 设置为你想等待的秒数，然后设置 tv_usec 为想等待的微秒数（真正
的时间就是 tv_sec 所表示的秒数加上 tv_usec 所表示的微秒数）．注意，是微秒（百万分之
一）而不是毫秒．一秒有 1,000 毫秒，一毫秒有 1,000 微秒。所以，一秒有 1,000,000 微秒．
当 select()函数返回的时候，timeval 中的时间将会被设置为执行为 select()后还剩下的
时间。
第 6 章  berkeley 套接字
- 189 -
现在，我们拥有了一个以微秒为单位的记时器！但是因为 Linux 和 UNIX 一样，最小
的时间片是 100 微秒，所以不管你将 tv_usec 设置的多小，实质上记时器的最小单位是 100
微秒．
另外需要注意的是：
如果你将 struct timeval 设置为 0，则 select()函数将会立即返回，同时返回在你的
集合中的文件描述符的状态。
如果你将 timeout 这个参数设置为 NULL，则 select()函数进入阻塞状态，除了等
待到文件描述符的状态变化，否则 select()函数不会返回。
下面这段代码演示了从标准输入等待输入等待 2.5 秒．
#include 
#include 
#include 
/* 标准输入的文件描述符数值 */
#define STDIN 0
main()
{
struct timeval tv;
fd_set readfds;
/* 设置等待时间为 2 秒零 500,000 微秒 */
tv.tv_sec = 2;
tv.tv_usec = 500000;
FD_ZERO(&readfds);
FD_SET(STDIN, &readfds);
/* 因为我们只想等待输入，所以将 writefds 和 execeptfds 设为 NULL */
/* 程序将会在这里等待 2 秒零 500,000 微秒，除非在这段时间中标准输入有操作 */
select(STDIN+1, &readfds, NULL, NULL, &tv);
/* 测试 STDIN 是否在 readfds 集合中 */
if (FD_ISSET(STDIN, &readfds))
{
/* 在，则在标准输入有输入 */
printf(“ A key was pressed!\n”);
}
else
{
/* 不在，则在标准输入没有任何输入 */
- 190 -
Linux网络编程
printf(“Timed out.\n”);
}
}
在标准输入上，你需要输入回车后终端才会将输入的信息传给你的程序。所以如果你
没有输入回车的话，程序会一直等待到超时。
对 select()函数需要注意的最后一点：如果你的套接字描述符正在通过 listen()函数侦听
等待一个外来的网络连接，则你可以使用 select()函数（将套接字描述符加入 readfds 集合
中）来测试是否存在一个未经处理的新连接。
上面是对 select()函数的一些简单介绍。
6.11  带外数据
许多传输层都支持带外数据（Out-Of-Band data），有时候也称为快速数据（Expedited
Data）．之所以有带外数据的概念，是因为有时候在一个网络连接的终端想“ 快速” 的告诉
网络另一边的终端一些信息．这个“ 快速” 的意思是我们的“ 提示” 信息会在正常的网络
数据（有时候称为带内数据 In-Band data）之前到达网络另一边的终端．这说明，带外数
据拥有比一般数据高的优先级．但是不要以为带外数据是通过两条套接字连接来实现的．事
实上，带外数据也是通过以有的连接来传输。
不幸的是，几乎每个传输层都有不同的带外数据的处理方法。我们下面研究的是 TCP
模型的带外数据，提供一个小小的例子来看看它是怎样处理套接字的带外数据，及调用套
接字 API 的方法。
流套接字的抽象中包括了带外数据这一概念，带外数据是相连的每一对流套接字间一
个逻辑上独立的传输通道。带外数据是独立于普通数据传送给用户的，这一抽象要求带外
数据设备必须支持每一时刻至少一个带外数据消息被可靠地传送。这一消息可能包含至少
一个字节；并且在任何时刻仅有一个带外数据信息等候发送。对于仅支持带内数据的通讯
协议来说（例如紧急数据是与普通数据在同一序列中发送的），系统通常把紧急数据从普
通数据中分离出来单独存放。这就允许用户可以在顺序接收紧急数据和非顺序接收紧急数
据之间作出选择（非顺序接收时可以省去缓存重叠数据的麻烦）。在这种情况下，用户也
可以“ 偷看一眼” 紧急数据。
某一个应用程序也可能喜欢线内处理紧急数据，即把其作为普通数据流的一部分。这
可以靠设置套接字选项中的 SO_OOBINLINE 来实现。在这种情况下，应用程序可能希望
确定未读数据中的哪一些是“ 紧急” 的（“ 紧急” 这一术语通常应用于线内带外数据）。为
了达到这个目的，在 Sockets 的实现中就要在数据流保留一个逻辑记号来指出带外数据从
哪一点开始发送．
select()函数可以用于处理对带外数据到来的通知。
6.11.1  TCP 的带外数据
TCP 上没有真正意义上的“ 带外数据”。TCP 是由一种叫做“ 紧急模式” 的方法来传
输带外数据的。假设一个进程向一个 TCP 套接字写入了 N 个字节的数据，数据被 TCP 套
接字的发送缓冲区缓存，等待被发送到网络上面．我们在图 6-10 可以看见数据的排列。
第 6 章  berkeley 套接字
- 191 -
图 6-10  TCP 数据的排列
现在进程使用以 MSG_OOB 为参数的 send()函数写入一个单字节的＂带外数据＂，包
含一个 ASCII 字符＂a＂：
send（fd, “a”, 1, MSG_OOB）;
TCP 将数据放在下一个可用的发送缓冲区中，并设置这个连接的＂紧急指针＂（urgent
pointer）指向下一个可用的缓冲区空间．图 6-11 表示了我们描述的这个状态，并将带外数
据（Out-Of-Band）表示为＂OOB＂。
图 6-11  ODB 数据
    TCP 的紧急指针的指向的位置是在程序发送的 OOB 数据的后面。
由图 6-11 所表示的 TCP 套接字的状态，得知下一个将要发送的数据是 TCP 的 URG
（Urgent pointer）标志，发送完 URG 标志，TCP 才会发送下面的带外数据的那个字节。
但是 TCP 所一次发送的数据中，可能只包含了 TCP 的 URG 标志，却没有包含我们所发送
的 OOB 数据．是否会发生这种情况而取决于 TCP 将要发送的数据队列中，在 OOB 数据
之前的数据的多少。如果在一次发送中，OOB 前的数据已经占满了名额，则 TCP 只会发
送 URG 标志，不会发送 OOB 数据
这是一个 TCP 紧急数据状态的重要特性：TCP 的信息头指出发送者进入了紧急模式（比
方说，在紧急偏移处设置了 URG 标志），但是紧急偏移处的数据并没有必要一定要发送出
去．事实上，如果一个 TCP 套接字的流传送停止后（可能是接收方的套接字的接收缓冲区
没有空余空间），为了发送带外数据，系统会发送不包含数据的 TCP 数据包，里面标明这
是一个带外数据．这也是我们使用带外数据的一个有利点：TCP 连接就算是在不能向对方
- 192 -
Linux网络编程
发送数据的时候，也可以发送出一个带外数据的信号。
如果我们像下面这样发送一个多字节的带外数据：
send(fd, “abc”, 3, MSG_OOB);
在这个例子中， TCP 的紧急指针指向了数据最后一位的后面， 所以只有最后一位数
据（“ c”）才被系统认为是“ 带外数据”。
我们上面大致了解了发送方是怎样发送“ 带外数据” 的了，下面我们来看一看接收方
是怎样接收“ 带外数据” 的。
1．当 TCP 收到一个包含 URG 标志的数据段时，TCP 会检查“ 紧急指针” 来验证是
否紧急指针所指的数据已经到达本地。也就是说，无论这次是否是 TCP 紧急模式从发送方
到接收方的第一次传输带外数据。一般来说，TCP 传输数据会分成许多小的数据包来传输
（每个包的到达时间也不同）。可能有好几个数据包中都包含紧急指针，但是这几个包中
的紧急指针都是指向同一个位置的，也就是说多个紧急指针指向一个数据。需要注意的是，
对于这一个带外数据，虽然有多个指针指向它，但是只有第一个紧急指针会通知程序注意。
2．接收进程收到另外一个带外数据的通知的条件是：有另外一个带外数据的指针到
达．注意这里是“ 另外一个带外数据” 的指针，不是上面的“ 一个带外数据” 的另外一个
指针。首先， SIGURG 信号回发送给套接字的属主，这个取决于是否已经使用 fcntl()函数
或 ioctl()函数设定套接字的属主和这个程序对 SIGURG 信号的具体操作函数。其次，如果
一个程序正阻塞与对这个套接字描述符的 select()函数的调用中，则 select()函数会产生一个
例外，然后返回。
注意：进程收到带外数据的通知的时候，并不会在乎带外数据的真正数据是否到达。
3．当紧急指针所指的真正的带外数据通过 TCP 网络到达接收端的时候，数据或者被
放入带外数据缓冲区或是只是简单的和普通的网络数据混合在一起。在缺省的条件下，
SO_OOBINLINE 套接字选项是不会被设置的，所以这个单字节的带外数据并没有被防在
套接字的接收缓存区中，而是被放入属于这个套接字的一个单独的带外数据缓存区中。如
果这个进程想读取这个带外数据的具体内容的话，唯一的办法就是调用 recv，recvfrom，
或是 recvmsg 函数，并且一定要指定 MSG_OOB 标志。
4．如果一个进程将套接字设置为 SO_OOBINLINE 属性，则由紧急指针所指的，代表
带外数据的那个字节将回被放在正常套接字缓冲区中的最左边．在这种情况下，进程不能
指定 MSG_OOB 来读取这个一个字节的带外数据，但是它可以知道带外数据的到达时间：
通过检查套接字的带外数据标记．
有可能发生的一些错误：
5．如果当连接没有发送带外数据的时候进程来读取带外数据（比如说，通过 MSG_OOB
参数来接收函数），则 EINVAL 将会被返回。
6．当真正的带外数据到达之前的时候，进程被通知（SIGURG 或是 select 函数）有带
外数据到达（也就是说带外数据的通知信号已经到达），如果进程尝试读取带外数据，则
返回 EWOULDFBLOCK ．进程所能做的只是去读取套接字的接收缓存区．（也许，由于
缓存区的数据以满，带外数据的那个字节信息无法传输过来，这样的话也许你需要清理一
下接收缓存区来给带外数据空出一些空间）
7．如果进程尝试多次读取同一个带外数据，则 EINVAL 将会被返回。
8．如果进程将套接字属性设置为 SO_OOBINLINE ，然后尝试通过指定 MSG_OOB
第 6 章  berkeley 套接字
- 193 -
标志来读取带外数据，则 EINVAL 将会被返回。
下面我们将前面的套接字例程做一些变动来测试带外数据的发送与接收．
6.11.2  OOB传输套接字例程（服务器代码 Server. c）
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
/* 服务器要监听的本地端口 */
#define MYPORT 4000 
/* 能够同时接受多少没有 accept 的连接 */
#define BACKLOG 10 
void
sig_urg（int signo）;
main()
{
/* 在 sock_fd 上进行监听，new_fd 接受新的连接 */
int sock_fd, new_fd ;
/* 用于存储以前系统缺省的 SIGURL 处理器的变量 */ void * old_sig_urg_handle ;
/* 自己的地址信息 */
struct sockaddr_in my_addr;
/* 连接者的地址信息*/
struct sockaddr_in their_addr;
int sin_size;
int n ;