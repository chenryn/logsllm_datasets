page-resident JavaScript and extension code. This design of
our semantics and its corresponding safety property results in
a ﬁne-grained security model for extensions that is robust with
respect to the effects of JavaScript on the web page.
To appreciate the design of our semantics, we ﬁrst dis-
cuss (a straw-man) security property that depends on the
instantaneous dynamic state of a web page. In this model,
consider a well-behaved implementation of an extension like
FacePalm. Such an extension could query a metadata attribute
on a DOM node (e.g., check that the ?=II attribute of a
node is label); decide according to the policy that it has read
privilege over the node; and, could then proceed to read the
contents of the node. If the node’s metadata changes just
prior to the read (due the effect of page-resident JavaScript),
under an instantaneous view of the policy, the read must
be rejected as insecure. Effectively, due to the behavior of
unforeseen JavaScript, unpredictable time-of-check to time-
of-use (TOCTOU) discrepancies can arise. Worse, under this
model, an adversarial web page can cause extensions to throw
runtime security exceptions, making the browser platform
unstable.
To counter such difﬁculties, the key insight behind our
semantics is to make the security behavior of extensions de-
pendent only on a dynamic log, a monotonically increasing set
ࡀ of ground facts about page metadata. While page-resident
JavaScript can cause additional facts to be introduced into the
log, it can never remove facts from the log. In conjunction with
our use of (strictly positive) Datalog as a policy language,
this design ensures that page-resident JavaScript, and any
TOCTOU discrepancies that it may introduce, can never cause
security failures in extension code.
Figure 7 deﬁnes a reduction relation   ࡀ   ࡀ߰ ߰,
according to which a runtime conﬁguration ࡀ , consisting
of a dynamic log ࡀ of ground facts and a BX term , reduces
to ࡀ߰ ߰, while under the purview of an unchanging policy
. This is a small-step reduction relation for a call-by-value
language, with a left-to-right evaluation order, extended with
reductions for the primitive operators of BX. The deﬁnition
of the relation makes use of an auxiliary judgment ࡀ ࢯ
, a standard entailment relation for Datalog, stating that the
fact  is derivable from the database of ground facts ࡀ and
intensional rules . We omit the deﬁnition of the standard
entailment relation for Datalog.
The rules (E-Ctx), (E-), (E-If) and (E-) are standard.
The rule (E-Eq) is unsurprising—it represents an equality test
on string values. (E-SetAttr) is more interesting. It represents
an attempt by the extension program to alter the DOM by
altering the attribute  on the node  to the value .
Our model views attribute mutation as a security-sensitive
event, so the premise of (E-SetAttr) contains a security check.
Speciﬁcally, we require the +=9HEJA)JJH    privilege
to be derivable from the facts in the log ࡀ and the policy .
As discussed in Section IV-A we view the tree structure of
a page as security metadata not subject to access restrictions
itself. This design is reﬂected in the rule (E-GetCh), which
contains no security check in the premise—an extension is
always free to traverse the structure of the page. However, in
the conclusion of the rule, we record facts in the log ࡀ߰ to
indicate that the parent/child relationships between ,  and
 . These facts can be used in subsequent security checks to
grant privileges to extensions. Note that for the purposes of
this model, we consider DOM trees as having inﬁnite depth,
i.e., it is always possible to access the children of a node. In
practice (cf. Section VI-B), CAJ+DE@HA returns an option.
Finally, we have (E-GetAttr), which combines elements
from (E-SetAttr) and (E-GetCh). Depending on the policy,
some attributes of a node (say, its EAH6ANJ ﬁeld) are con-
sidered security sensitive and are subject to access controls;
other attributes (say, a CSS class) can be treated as security
metadata. For this reason, the premise of (E-GetAttr) contains
a check to ensure that an extension has read privilege on the
requested attribute. Additionally, we record facts in the log ࡀ߰.
The ﬁrst fact indicates that the node  indeed has the attribute
 ; the second records the fact that the value  was
derived from . The latter fact is useful for enforcing data ﬂow
properties—we discuss this in Section VII-B.
Modeling the effects of JavaScript via non-determinism:
Extensions and page-resident JavaScript interact via shared
DOM state. In most browsers, extensions and JavaScript
share a single thread of control. An event handler, whether
JavaScript or extension, runs to completion on receiving an
event, and then yields control back to the browser, which
can then schedule another event handler. In general, when
extension code regains control, the page may have evolved
arbitrarily since the last time the extension had control.
We model this characteristic feature of the extension exe-
cution model by making the rules (E-GetCh) and (E-GetAttr)
non-deterministic. The non-determinism in our formal model
is at an arbitrarily ﬁne level of granularity, e.g., successive calls
to (E-GetAttr) with the same arguments are allowed to return
122
log ࡀ  
ࢯ  ࢯ ࡀ ࡀ 
eval. contexts ࢫ
 ࢫ ࢯ   ࢯ   ࢯ   ࢯ   ࢯ  ࢯ if  then  else  
  ࡀ   ࡀ߰ ߰
  ࡀ   ࡀ߰ ߰
E-Ctx
  ࡀ    ࡀ 
E-
  ࡀ     ࡀ 
E-
  true when    
  false otherwise
  ࡀ IJH-G     ࡀ 
ࡀ߰  ࡀ 2=HAJ   2=HAJ   
  ࡀ CAJ+DE@HA   ࡀ߰   
E-GetCh
ࡀ  ࢯ +=4A=@)JJH  
߰   when   true
߰    when   false
  ࡀ if  then  else    ࡀ ߰
ࡀ  ࢯ +=9HEJA)JJH   
E-Eq
  ࡀ IAJ)JJH     ࡀ߰ 
ࡀ߰  ࡀ -J)JJH    .MI.H  
  ࡀ CAJ)JJH    ࡀ߰ 
E-If
E-SetAttr
E-GetAttr
Fig. 7: Dynamic semantics of BX:   ࡀ   ࡀ߰ ߰
different results, modeling the fact that JavaScript code can be
interleaved between the two calls. In practice, interleavings are
not arbitrarily ﬁne—extension code in a single event handler
runs to completion without preemption. However, closures and
shared state across event handler invocations allow extensions
to observe the effects of JavaScript, essentially, between any
pair of syntactically adjacent instructions.
C. ࡀ-safety: A security property for BX
The main security deﬁnition of this paper is a notion of
safety of BX programs, deﬁned above as a traditional type
soundness property on the reduction relation.
Deﬁnition 1 (Safety): An extension  is ࡀ-safe if either
 is a value, or there exists an expression ߰ and a log ࡀ߰ such
that   ࡀ   ࡀ߰ ߰ and ߰ is ࡀ߰-safe.
ࡀ-safety has the pleasing property that the security of
an extension does not depend on the actions of page-resident
JavaScript. However, it also limits the kinds of security policies
that can be deﬁned. In particular, policies that involve dynamic
revocations cannot be modeled using ࡀ-safety. We leave
to future work the investigation of a security property for
extensions that is suitable for use with revocation, while still
being robust to the effects of untrusted JavaScript on the page.
VI. STATIC ENFORCEMENT OF EXTENSION SAFETY
This section describes a methodology based on reﬁnement
type checking that we use to statically verify that extensions
comply with their policies. Section VI-A brieﬂy reviews
reﬁnement types and Fine. We then discuss the high-level
architecture of our veriﬁcation methodology and present frag-
ments of the reﬁned APIs that we expose to extensions. We
then present several small examples of extension code and
show how these are veriﬁed against the APIs. The section
concludes with a discussion of the main theorem of the paper,
namely that well-typed Fine programs are ࡀ-safe.
Our approach has a number of beneﬁts, some of which
were discussed in Section III-D. In light of the presentation
of our safety property, we begin this section by highlighting
two further beneﬁts of our approach.
Robustness and modular veriﬁcation: While ࡀ-safety
is weak in the sense that it cannot model revocation, we ﬁnd it
particularly useful since it lends itself to a modular veriﬁcation
strategy. We can verify extensions for compliance with this
property independently of page-resident JavaScript, and reason
that this property is still preserved under composition with
JavaScript. As such, this notion of safety is similar to the
notion of robust safety, as formulated for use with model
checking concurrent programs [16], or for verifying authen-
ticity properties of cryptographic protocols [14].
Efﬁcient policy enforcement: Static veriﬁcation of extension
safety removes the performance cost of runtime monitoring. In
the context of ࡀ-safety, runtime monitoring is particularly
expensive, since it requires a dynamic log to be maintained
at runtime as well as a Datalog interpreter to be invoked
(potentially) on each access to the DOM. Static enforcement
allows the dynamic log to be virtualized, so no log need be
maintained at runtime, and, of course, no runtime Datalog
interpretation is necessary either. Additionally, ࡀ-safety
also allows us to enforce data-ﬂow like taint-based properties
with no runtime overhead.
A. A review of reﬁnement types in Fine
Fine is a veriﬁcation system for a core, functional subset of
F#. The principal novelty of Fine is in its type system, which
is designed to support static veriﬁcation of safety properties
via a mixture of reﬁnement and substructural types—for the
purposes of this paper, substructural typing is unimportant.
This section describes the syntax and intuitions behind re-
ﬁnement types in Fine. For details, we refer the reader to a
recent comprehensive presentation of Fine and other related
languages [31].
Value-indexed types: Types in Fine can be indexed both by
types (e.g., list int) as well as by values. For example, array int 17
could represent the type of an array of 17 integers, where the
index 17:nat is a natural number value. Value indexes on types
can be used to specify a variety of security constraints, e.g.,
example, labeled int x could represent the type of an integer
whose security label is described by the program variable x.
Note that for uniformity, unlike ML, type applications are
written in preﬁx notation (e.g., list int instead of int list).
Dependent function types: Functions in Fine are, in general,
given dependent function types, i.e., their range type depends
on their argument. These are written x:t ࢐ t’, where the formal
name x of the parameter of type t is in scope in t’. For example,
the type of a function that allocates an array of  integers can
be given the type n:nat ࢐ array int n. When a function is non-
dependent, we drop the formal name.
Reﬁnement types: A reﬁnement type in Fine (technically, a
ghost reﬁnement) is written x:t, where  is a formula in
123
which the variable x is bound. Fine is parametric in the logic
used for formulas, , however, in practice, the logic is often a
ﬁrst-order logic with equality. In this paper, rather than use the
full power of ﬁrst-order logic, we limit the formula language to
strictly positive Datalog, which, as explained earlier, is suitable
for ࡀ-safety. Formulas are drawn from the same syntactic
category as types, although, for readability, we use italicized
fonts for formulas.
Reﬁnements as pre- and post-conditions: We can use
reﬁnement types to place pre- and post-conditions on func-
tions. For example, we may give the following (partial)
speciﬁcation to a list permutation, where the reﬁnement for-
mula on the return value m corresponds to a post-condition
of the function, relating the return value to the argument.
࢘ .l:list  ࢐ m:list  ࢘x. In x l  In x m. Reﬁnement types can also
be used to state pre-conditions of functions. For example, to
rule out divide-by-zero errors, we could give the following
type to integer division: x:int ࢐ y:inty != 0 ࢐ int.
Kind language: Types in Fine are categorized according to
a language of kinds. Types are divided into four basic kinds,
although we only consider two of these kinds in this paper.
The kind ਭ is the kind of normal types; and,  , the kind of
propositions. Type constructors are given arrow kinds, which
come in two ﬂavors. The ﬁrst,   ߰ is the kind of type
functions that construct a ߰-kinded type from a -kinded type
 . Just as at the type level, kind-level arrows are dependent—
the type variable  can appear free in ߰. Type functions that
construct value-indexed types are given a kind   , where
 names the formal of type  and  can appear free in . In
both cases, when the kind is non-dependent, we simply drop
the formal name. For example, the kind of list is ਭ  ਭ ; the
kind of the value-indexed array constructor is ਭ  nat  ਭ ; the
kind of the propositional connective And is      ; the
kind of the user-deﬁned predicate In is ::ਭ    list    .
Top-level assumptions: The predicates that appear in a reﬁne-
ment formula can be axiomatized using a collection of user-
provided assumptions. For example, in order to axiomatize
the list membership predicate In, the standard library of Fine
contains assumptions of the form assume ࢘hd, tl. In hd (Cons hd tl).
In the context of this paper,
in addition to axiomatizing
standard predicates, top-level assumptions are used to specify
the security policy that applies to an extension.
Reﬁnement type checking: A reﬁnement type x:t is in-
habited by values v:t, for which [v/x] is derivable. Formally,
derivability is deﬁned with respect to assumptions induced by
the program context (e.g., equalities due to pattern matching),
the top-level assumptions, and any formulas in a purely
virtual dynamic log ࡀ, where the contents of the log is itself
soundly approximated using reﬁnement types. The derivability
of reﬁnement formulas is decided by Fine’s type checker by
relying on Z3 [7], an SMT solver. We show an example
program and its typing derivation in Section VI-C.
B. Reﬁned APIs for extensions
Our veriﬁcation methodology involves giving reﬁnement-
typed interfaces to browser functionality that is exposed to
extensions. This section presents a fragment of this interface
in detail and discusses how the types of these interfaces map to
the semantics of Section V. We focus here on the API for the
DOM; our implementation uses a similar approach to provide
reﬁned APIs for local storage, network, and browsing history.
The listing below shows a fragment of the reﬁned DOM API
we expose to extensions. It begins by deﬁning two abstract
types, doc and elt, the types of web documents and document
nodes, respectively. Well-typed extensions can only manipulate
values of these types using our exposed APIs.
Next, we deﬁne a number of type constructors correspond-
ing to the predicates of our policy language (Figure 5)—Fine’s
type and kind language makes it straightforward to deﬁne these
predicates. We start at lines 4-8 by showing the deﬁnitions of
several metadata predicates that can be used to speak about
the structure of a web page. Lines 10-14 show predicates
corresponding to authorization privileges. For example, at line
4, DocDomain is deﬁned to construct a proposition (a  -kinded
type) from a doc and a string value. Fine’s kind language