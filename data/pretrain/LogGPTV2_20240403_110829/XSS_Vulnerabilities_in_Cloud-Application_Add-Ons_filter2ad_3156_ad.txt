Doc Variables
Order Printer Pro
ShipHero Fulﬁllment
Simple Admin
ShipRelay Fulﬁllment
Ship Systems 3D Box Packing
Outside input
Fixing
Fixing
Fixing
Fixing
Fixing
Fixing
Shared workspace No response
Shared workspace
Shared workspace No response
Shared workspace No response
Shared workspace No response
Shared workspace No response
Shared workspace No response
Shared workspace
Shared workspace No response
Shared workspace
Shared workspace
Shared workspace
Shared workspace No response
Shared workspace
Shared workspace No response
Shared workspace No response
Shared workspace
Shared workspace No response
Shared workspace No response
Shared workspace No response
Shared workspace No response
Shared workspace
Shared workspace No response
Shared workspace
Shared workspace No response
Shared workspace No response
Shared workspace No response
Fixing
Fixing
Fixed
Fixing
After creating the test item, we tried all functions of each
add-on on the test item and looked for workﬂows that involve
rendering the content of the item. We also added more custom
JavaScript code in a number of cases because some add-ons
only considered data in speciﬁc formats. For example, with
Doc Variables [34] — an add-on that allows deﬁning and
using variables in Google Docs documents — we had to
insert our script into a variable’s deﬁnition, which was in
the format: ${variable_name}. If any of the injected script
snippets were executed, we concluded that the add-on was
vulnerable to XSS.
While our analysis was manual, we believe that it is sufﬁ-
cient to ﬁnd most, if not all, XSS vulnerabilities in the selected
add-ons. The main reason is that, compared to standalone web
services, add-ons are usually quite simple with a relatively
small number of features. The number of places where the
user can inject scripts is also limited. Thus, it is not difﬁcult
to understand and manually test all the workﬂows of an add-
on with the black-box testing method. However, while our
methodology is sufﬁcient to produce results that, in our opin-
ion, need wider attention, it is clearly not practical for those
who want to perform large scale analyses of cloud-application
add-ons. A more complete and efﬁcient approach is needed
in the future for such purpose.
5.3 Results and responsible disclosure
We found 28 vulnerable add-ons among the 300 analyzed
ones, which is around 9%. The result indicates that XSS vul-
nerabilities are common in cloud-application add-ons today.
Table 4 shows the names of the add-ons, the attack vectors,
and whether the add-ons have been ﬁxed. Among the three
marketplaces, only the G Suite shows the number of users of
each add-on, and the vulnerable add-on with the greatest num-
ber of users in the marketplace, Form Ranger, had roughly
7,8 million users as of August 2019. The most popular vul-
nerable add-ons in the Microsoft Ofﬁce Online and Shopify
marketplaces are Translator for Outlook and Order Printer
Pro, respectively. The former had 1772 reviews, and the latter
had 371 reviews.
10
We can see that the vulnerability rate in the set of popular
add-ons appears lower in all the three marketplaces. This
could be because popular add-ons are more likely to be written
by more experienced developers. Also, it seems that add-
ons that are vulnerable to outside input are rare. Speciﬁcally,
only one add-on in our study is vulnerable. We hypothesize
that add-on developers are more familiar with threats from
outside input (i.e. emails in this case) than those from shared
workspace.
We have disclosed the vulnerabilities to all of the add-on
developers that we were able to contact. We also provided
guidance on how the security bugs could be ﬁxed (see the
solutions for add-on developers in Section 6). At the moment
of writing, of the 28 add-on teams/developers that we have
contacted, 1 has acknowledged and ﬁxed their add-on, 9 has
acknowledged the vulnerabilities but are still working on
the ﬁxes, and the others have not responded to us. We also
discussed the problem of the Picker API with Google. They
conﬁrmed the problem and said that they would take it into
account in the next version of their add-on system.
6 Defenses
In this section, we discuss what the add-on developers and
cloud application vendors can do to defend against the XSS
attacks caused by vulnerable add-ons.
6.1 Solutions for add-on developers
To prevent XSS, add-on developers should not add untrusted
data to the add-on UI as HTML because it can contain mali-
cious JavaScript code. We discuss some practices that they
can follow below.
Coding practices. Secure coding practices to prevent XSS
are a common topic in web security literature [24, 40, 47]. A
straightforward way to prevent XSS in cloud-application add-
ons is to always render user input as text instead of HTML.
Instead of the innerHTML property, the developer should use
the innerText and textContent properties to insert text.
With jQuery, the .text() method should be used instead of
the .html() method.
In general, user data should not be interpreted as web appli-
cation code. However, in the rare cases where it is necessary
to render untrusted HTML as part of the add-on UI, the de-
veloper needs to properly validate and escape on the input
ﬁrst. On the server side, most web frameworks have built-in
functions for such tasks. On the client side, JavaScript meth-
ods like .toStaticHTML() can be used to remove dynamic
HTML elements and attributes in the user data before ren-
dering it. We refer to [47] for a detailed guidance on how to
escape characters to prevent XSS.
Security enforcement. Since add-ons are basically web ser-
vices, add-on developers could implement a Content Security
Policy (CSP) [52] to enforce some defenses on their add-ons.
An extreme policy is to ban execution of all inline scripts
(e.g.  tags, inline event handlers). With such policy,
even if the attacker managed to insert malicious scripts to the
add-on UI, the scripts would not be executed. Only JavaScript
code that are in separate .js ﬁles and loaded from trusted
servers that the developers have whitelisted are allowed to
run.
However, completely prohibiting inline scripts is not al-
ways ideal because legitimate inline scripts are preferred for
various tasks. For example, event handlers are usually im-
plemented in inline scripts. Moving inline event handlers to
separate .js ﬁles cannot be done by simply copying and past-
ing the code; instead, they need to be rewritten with DOM
APIs. Fortunately, CSP can be used in a less extreme way
to avoid the hassle. Speciﬁcally, hash-based or nonce-based
policies can be implemented so that inline scripts with pre-
registered hash or nonce values are allowed to execute.
Add-on developers should also minimize the permissions
that their add-ons request. As we can see from the case of
the Form Ranger add-on (Section 4.2.2), the unnecessary
permissions that the add-on has enable the XSS attacker to
steal all of the victim’s Google Drive ﬁles as well as sending
emails on the victim’s behalf.
There are also other generic practices that help to defend
against XSS [47]. For example, the HTTPOnly ﬂag of session
cookie and any custom cookies that are not accessed by any
JavaScript code should always be set. Also, many web frame-
works provide automatic escaping functionality [5,16], which
should be used whenever possible.
XSS detection. Add-on developers can also utilize the
method that we used for our empirical analysis (Section 5.2)
to check whether their add-ons are vulnerable. Speciﬁcally,
they can create similar test items as we did and write unit
tests to continuosly check for XSS vulnerabilities during their
development cycle. While our method does not scale well, it
should be sufﬁcient for testing individual add-ons.
6.2 Lessons for cloud-application vendors
In Section 4, we analyzed the designs of three popular add-
on systems and what an XSS attack can achieve in them.
This section presents the lessons that we learned from the
analysis about design choices and their impact on the security
of add-ons. We hope that the lessons would be useful for any
cloud-application vendors which are developing or improving
their add-on systems.
Harden the add-on iframe. The add-on UI is contained
in an iframe, and by default, the code in the iframe can
call browser APIs to request access to features on the local
device, such as geolocation, microphone, and camera. The
host application should restrict the browser features which
the add-on iframe can access, which can be done by setting
11
the allow and sandbox properties of the iframe [42].
At the moment, there is an experimental feature in the
Chrome and Opera browsers that allows the host application
to enforce a CSP policy on add-ons. Speciﬁcally, the browsers
add a new property to the iframe elements, namely csp,
which can be used to specify a policy which the embedded
page must enforce upon itself [59]. If this property becomes
a standard feature of browsers, it gives cloud-application ven-
dors control over the CSP policy in their add-ons. However,
we observe that most of the add-ons in our analysis did not
use CSP. Thus, deploying such restriction would not be an
easy task for the vendors because a meaningful CSP, such
as allowing only inline scripts whose hash or nonce match
a speciﬁed value to run, would break many add-ons in their
marketplaces.
Implement add-on logic in the add-on server, not in client-
side JavaScript. Cross-origin messaging within the browser,
as used in MS Ofﬁce Online, enables low-latency access from
the add-on to user data that is available in the main applica-
tion UI. However, this access is only controlled by relatively
coarse-grained generic permissions, such as those in Table 1.
We can see that such access control is not useful when defend-
ing against XSS attackers because their malicious scripts are
executed in the context of the add-on. Therefore, the add-on
logic should be implemented on the server side, as G Suite
and Shopify have done. The add-on server would act a a layer
of isolation between the client-side script and user data in the
cloud application in two ways. First, the add-on server deﬁnes
a limited, purpose-speciﬁc interface through which all access
to user data has to go. Second, the add-on server implements
business logic that further ﬁlters the kinds of read and write
operations that are passed on to the cloud application. Both
mechanisms act as ﬁlters between the potential XSS code
that has taken over the add-on iframe in the browser and the
user’s data.
Filter scripts in user input. The host application vendors
should think thoroughly about the types of user input that their
applications need to receive in a shared workspace and ﬁlter
for unwanted types. For example, Shopify deals with shop
resources such as products and orders, which are relatively
structured data. Thus, the developers know where HTML or
scripts should not appear. The G Suite and MS Ofﬁce Online
applications are more problematic in this respect because the
input to them is mostly documents, where legitimate HTML
and scripts can appear in unexpected places.
Do not share access tokens to delegate all your permis-
sions. OAuth 2.0 tokens are bearer tokens, and anyone in
possession of the token can use it for resource access. This
can lead to unsafe coding practices where too powerful tokens
are delegated to unsafe places — as we saw in the case of the
Picker API in G Suite. Instead of sharing its access token with
the client side, the add-on server should mediate the access.
Where tokens need to be shared, they should only convey the
absolute minimum permissions needed by the client side. In
the case of the Picker API, for example, the add-on server
should delegate to the UI a restricted token that can only be
used to list speciﬁc ﬁles in the user’s Google Drive.
Avoid asking user consent at runtime. Relying on user judg-
ment when authorizing add-ons to access user data may not
be as good an idea as it ﬁrst seems. In particular, prompting
the user for consent at runtime conditions the user to answer-
ing yes to every such prompt, including ones from injected
malicious code. Thus, it may be better to ask for user con-
sent only in a separate UI where the user installs or upgrades
add-ons. On the negative side, that prevents document-level
access control.
7 Discussion and future work
Since cross-site scripting is a well-known vulnerability, pru-
dent engineering practices have been developed to prevent
such mistakes [48]. On one hand, developers are aware of the
need to ﬁlter untrusted input, and on the other, cloud appli-
cation vendors have developed platforms and toolchains that
make their products immune to most types of code injection.
Nevertheless, the problem has not been completely solved. On
one hand, attackers ﬁnd new ways of bypassing the defenses
and, on the other, the speed of software development makes
it difﬁcult for threat analysis and defenses to stay up to date.
This paper is doing its part to catch up with the development
in one key area of modern software.
We have conﬁrmed by experiments that the vulnerabili-
ties described in this paper are real and exploitable. There
are, however, some additional practical considerations that a
real-world attacker would face. The attacker needs to know
which vulnerable add-on the victim is using, and the victim
has to enable the add-on on the shared document. Thus, a
successful attack probably requires a vulnerable add-on that
users regularly invoke on large classes of documents which
they are reading or editing. Translator and writing-assistant
add-ons could meet these criteria. Add-ons that ﬁx problems
in data, such as duplicate removers, could even be installed by
the victim when they receive a document with the matching
problem.
In addition to the XSS vulnerabilities in the add-ons, an-
other serious issue discovered in this paper is the way OAuth
2.0 tokens are used in the Picker API, and the powerful ex-
ploits that it enables for the XSS attacker. The Picker API doc-
umentation has educated developers to use a design pattern
where an add-on server shares its OAuth 2.0 with a client-side
script. Even if the Picker API itself is replaced with a safer
solution, this unsafe software pattern might persist among
developers.
For these reasons, some further measures may be needed to
prevent unsafe use of the access tokens. G Suite has the advan-
tage that the add-on server runs in the Google cloud, and the
12
access token is handled by the third-party code only in special
cases, which could be monitored and blocked. Also, host ap-
plications could relatively easily reject tokens that come from
somewhere other than the authorized add-on server. Such re-
strictions on the token usage would, however, take away the
convenience and ﬂexibility of bearer tokens that has made
them popular with developers. Indeed, the designers of OAuth