已经有了其他元素，那么就向后移动1位，看看数组下标3的位置是否有
空。
Entru
Nul
Null
Null
Entry6
很不巧，下标3也已经被占用，那么就再向后移动1位，看看数组下标4
的位置是否有空。
Null
Nul
Entrye
幸运的是，数组下标4的位置还没有被占用，因此把Entry6存入数组下
标4的位置。
0
Nul
Nul
这就是开放寻址法的基本思路。当然，在遇到哈希冲突时，寻址方式有
很多种，并不一定只是简单地寻找当前元素的后一个元素，这里只是举
一个简单的示例而已。
在Java中，ThreadLocal所使用的就是开放寻址法。
接下来，重点讲一下解决哈希冲突的另一种方法一—链表法。这种方法
被应用在了Java的集合类HashMap当中。
HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节
点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的
Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即
可。
---
## Page 108
Entru
Null
Nul
Nul
next
2.读操作（get)
讲完了写操作，我们再来讲一讲读操作。读操作就是通过给定的Key，
在散列表中查找对应的Value。
例如调用hashMap.get("002936")，意思是查找Key为002936的Entry在散
列表中所对应的值。
具体该怎么做呢？下面以链表法为例来讲一下。
第1步，通过哈希函数，把Key转化成数组下标2。
第2步，找到数组下标2所对应的元素，如果这个元素的Key是002936，
那么就找到了；如果这个Key不是002936也没关系，由于数组的每个元
素都与一个链表对应，我们可以顺着链表慢慢往下找，看看能否找到与
Key相匹配的节点。
时查找Key
002936
Key: 002947
0
5
Null
Null
next
Key:002936
在上图中，首先查到的节点Entry6的Key是002947，和待查找的Key
002936不符。接着定位到链表下一个节点Entry1，发现Entry1的Key
002936正是我们要寻找的，所以返回Entry1的Value即可。
3.扩容（resize）
---
## Page 109
在讲解数组时，曾经介绍过数组的扩容。既然散列表是基于数组实现
的，那么散列表也要涉及扩容的问题。
首先，什么时候需要进行扩容呢？
当经过多次元素插入，散列表达到一定饱和度时，Key映射位置发生冲
突的概率会逐渐提高。这样一来，大量元素拥挤在相同的数组下标位
置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影
响。
这时，散列表就需要扩展它的长度，也就是进行扩容。
对于JDK中的散列表实现类HashMap来说，影响其扩容的因素有两个。
·Capacity，即HashMap的当前长度
·LoadFactor，即HashMap的负载因子，默认值为0.75f
衡量HashMap需要进行扩容的条件如下。
HashMap.Size>=CapacityxLoadFactor
---
## Page 110
散列表的扩容操作，具体做了什
么事情呢？
扩容不是简单地把散列表的长度扩
大，而是经历了下面两个步骤。
1.扩容，创建一个新的Entry空数组，长度是原数组的2倍。
2.重新Hash
，遍历原Entry数组，把所有的Entry重新Hash到新数组
中。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改
变。
经过扩容，原本拥挤的散列表重新变得稀疏，原有的Entry也重新得到
了尽可能均匀的分配。
扩容前的HashMap。
4
5
Null
Entruz
Null
next
Entryl
---
## Page 111
扩容后的HashMap。
Q
Null
Null
10
11
12
13
14
15
Null
Nul
Nul
Entry
以上就是散列表各种基本操作的原理。由于HashMap的实现代码相对比
较复杂，这里就不直接列出源码了，有兴趣的读者可以在JDK中直接阅
读HashMap类的源码。
需要注意的是，关于HashMap的实现，JDK8和以前的版本有着很大的
不同。当多个Entry被Hash到同一个数组下标位置时，为了提升插入和
查找的效率，HashMap会把Entry的链表转化为红黑树这种数据结构。建
议读者把两个版本的实现都认真地看一看，这会让你受益匪浅。
基本明白了，散列表还真是个神奇的
数据结构！
散列表可以说是数组和链表的结合，
它在算法中的应用很普遍，是一种非常重要的数据结构，大家一定
---
## Page 112
要认真掌握哦。
这一次就讲到这里，咱们下一章再
见。
2.5小结
·什么是数组
数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式
是顺序存储，访问方式是随机访问。利用下标查找数组元素的时间复杂
度是0(1)，中间插入、删除数组元素的时间复杂度是0(n)。
·什么是链表
链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节
点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。查
找链表节点的时间复杂度是O(n)，中间插入、删除节点的时间复杂度是
O(1)。
·什么是栈
栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含
入栈和出栈操作，遵循先入后出的原则（FILO）。
·什么是队列
队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队
列包含入队和出队操作，遵循先入先出的原则（FIFO）。
---
## Page 113
·什么是散列表
散列表也叫哈希表，是存储Key-Value映射的集合。对于某一个Key，散
列表可以在接近0(1)的时间内进行读写操作。散列表通过哈希函数实现
Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突。
第3章树
3.1
树和二叉树
3.1.1
什么是树
大黄，我们已经学习了
序表、链表、队列等线性
数据结构，已经能够满足
任何需求了吧？
还远远不够，小灰，你家
有口人？
---
## Page 114
除了爷爷、奶奶和父母，我
有两个哥哥，还有一个报
叔。为什么忽然问这个呢？
小灰的“家谱”是这样子的。
小灰的
爷爷、奶奶
小灰的
小灰的
爸爸、妈妈
叔叔
大灰
二灰
小灰
所以说，有许多逻辑关系并不是简单
的线性关系，在实际场景中，常常存在着一对多，甚至是多对多的
情况。
---
## Page 115
其中树和图就是典型的非线性数据
结构，我们首先讲一讲树的知识。
什么是树呢？在现实生活中有很多体现树的逻辑的例子。
例如前面提到的小灰的“家谱”，就是一个“树”
再如企业里的职级关系，也是一个“树”。
技术总监
项目经理A
项目经理口
员工A
员工B
员工C
员工口
员工F
除人与人之间的关系之外，许多抽象的东西也可以成为一个“树”，如一
本书的目录。
---
## Page 116
XXX从入门到放弃
第1章
第2章
第3章
第4章
第一节
第2节
第3节
以上这些例子有什么共同点呢？为什么可以称它们为“树"呢？
因为它们都像自然界中的树一样，从同一个“根"衍生出许多“枝干”，再
从每一个“枝干"衍生出许多更小的"枝干”，最后衍生出更多的"叶子”。
在数据结构中，树的定义如下。
树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一
个非空树中，有如下特点。
1.有且仅有一个特定的称为根的节点。
2.当n>1时，其余节点可分为m（m>0）个互不相交的有限集，每一个集
合本身又是一个树，并称为根的子树。
下面这张图，就是一个标准的树结构。
---
## Page 117
根节点
(root)
3
4
子树
叶子节点
在上图中，节点1是根节点（root）
：节点5、6、7、8是树的末端，没
有“孩子”，被称为叶子节点（leaf）
。图中的虚线部分，是根节点1的
其中一个子树。
同时，树的结构从根节点到叶子节点，分为不同的层级。从一个节点的
角度来看，它的上下级和同级节点关系如下。
节点4的
父节点
3
6
8
节点4的
兑弟节点
节点4的
树的高度=4
孩子节点
---
## Page 118
在上图中，节点4的上一级节点，是节点4的父节点（parent）；从节点
4衍生出来的节点，是节点4的孩子节点（child）；和节点4同级，由同
一个父节点衍生出来的节点，是节点4的兄弟节点（sibling）。
树的最大层级数，被称为树的高度或深度。显然，上图这个树的高度是
4。
哎呀，这么多的概念还真是不好记。
这些都是树的基本术语，多看几次就
记住啦。下面我们来介绍一种典型的树一—二叉树。
3.1.2什么是二叉树
二叉树（binarytree）是树的一种特殊形式。二叉，顾名思义，这种树
的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只
有1个，或者没有孩子节点。
二叉树的结构如图所示。
---
## Page 119
2
5
G
8
节点4的
节点4的
左孩子节点
右孩子节点
二叉树节点的两个孩子节点，一个被称为左孩子（leftchild），一个被
称为右孩子（rightchild）。这两个孩子节点的顺序是固定的，就像人
的左手就是左手，右手就是右手，不能够颠倒或混淆。
此外，二叉树还有两种特殊形式，一个叫作满二叉树，另一个叫作完
全二叉树。
什么是满二叉树呢？
一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在
同一层级上，那么这个树就是满二叉树。
---
## Page 120
2
1011
简单点说，满二叉树的每一个分支都是满的。
什么又是完全二叉树呢？完全二叉树的定义很有意思。
对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1
到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节
点位置相同，则这个二叉树为完全二叉树。
这个定义还真绕，看看下图就很容易理解了。
3
10
1
在上图中，二叉树编号从1到12的12个节点，和前面满二叉树编号从1到
---
## Page 121
12的节点位置完全对应。因此这个树是完全二叉树。
完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是
满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。
那么，二叉树在内存中是怎样存
储的呢？
上一章咱们讲过，数据结构可以划分
为物理结构和逻辑结构。二叉树属于逻辑结构，它可以通过多种物
理结构来表达。
二叉树可以用哪些物理存储结构来表达呢？
1.链式存储结构。
2.数组。
让我们分别看看二叉树如何使用这两种结构进行存储吧。
首先来看一看链式存储结构。
---
## Page 122
NodeA
Data
Left
Right
Data
Data
Left
Right
Left
Right
NodeB
NodeC
链式存储是二叉树最直观的存储方式，
上一章讲过链表，链表是一对一的存储方式，每一个链表节点拥有data
变量和一个指向下一节点的next指针。
而二叉树稍微复杂一些，一个节点最多可以指向左右两个孩子节点，所
以二叉树的每一个节点包含3部分。
·存储数据的data变量
·指向左孩子的left指针
·指向右孩子的right指针
再来看看用数组是如何存储的。
---
## Page 123
234
45
0
12
345678
使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位
置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空
出来。
为什么这样设计呢？因为这样可以更方便地在数组中定位二叉树的孩子
节点和父节点。
假设一个父节点的下标是parent，那么它的左孩子节点下标就
是2xparent+1；右孩子节点下标就是2xparent+2。
反过来，假设一个左孩子节点的下标是leftChild，那么它的父节点下标
就是（leftChild-1）/2。
假如节点4在数组中的下标是3，节点4是节点2的左孩子，节点2的下标
可以直接通过计算得出。
节点2的下标=(3-1)/2=1
显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的，
什么样的二叉树最适合用数组表示呢？
我们后面即将学到的二叉堆，一种特殊的完全二叉树，就是用数组来存
储的。
---
## Page 124
3.1.3二叉树的应用
咱们讲了这么多理论，二叉树究
竞有什么用处呢？
二叉树的用处有很多，让我们来具体
看一看。
二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主
要的应用还在于进行查找操作和维持相对顺序这两个方面。
1.查找
二叉树的树形结构使它很适合扮演索引的角色。
这里我们介绍一种特殊的二叉树：二叉查找树（binary searchtree）
光看名字就可以知道，这种二叉树的主要作用就是进行查找操作。
二叉查找树在二叉树的基础上增加了以下几个条件。
·如果左子树不为空，则左子树上所有节点的值均小于根节点的值
·如果右子树不为空，则右子树上所有节点的值均大于根节点的值
·左、右子树也都是二叉查找树
---
## Page 125
下图就是一个标准的二叉查找树。
3
8
二叉查找树的这些条件有什么用呢？当然是为了查找方便。
例如查找值为4的节点，步骤如下。
1.访问根节点6，发现43。
---
## Page 126
6
3
8
4
6
3.访问节点3的右孩子节点4，发现4=4，这正是要查找的节点。
3
8
9
对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那
么搜索节点的时间复杂度就是O(logn)，和树的深度是一样的。
这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。
2.维持相对顺序
这一点仍然要从二叉查找树说起。二叉查找树要求左子树小于父节点，
右子树大于父节点，正是这样保证了二叉树的有序性。
---