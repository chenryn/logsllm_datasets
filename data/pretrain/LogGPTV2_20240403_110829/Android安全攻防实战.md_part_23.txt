## Page 182
Android安全攻防实战
Properties.java
• The PackageManager class in the Android Developers Reference guide at https://
developer.android.com/reference/android/content/pm/PackageManagcr.html.
● The Applicationlnfo class in the Android Developers Reference guide at https:/
developer.android.com/reference/android/content/pm/ApplicationInfo.html.
5.8用ProGuad删除所有日志消息
ProGuard是个开源的Java代码混淆器，Android SDK里自带了这个工具。对于
不熟悉混淆器的读者，我简单解释一下。混淆器会把代码中所有程序执行时用不着
的信息都删除掉。比如，不使用的代码和调试信息，同时也会把你写的、易于阅读
的、带描述性的，便于维护的代码识别出来，并把它们重新改成经过优化的”、更短
的、非常难以阅读的代码。在优化之前，这个样子的代码：
SecurityManager.encrypt(String text），在优化之后就变成了 a.b(String c)这个样子了。
正如你所见到的这例子，没留下任何表示它是干什么的线索。
通过移除不使用的方法、域（field）和属性，ProGuard也能减少代码的总大小，
同时由于对代码做了机器级优化（machine-optimized），也会使程序执行起来更快些。
对于移动执行环境来说，这是个很理想的结果，因为优化极大地减少了导出的.apk
文件的大小，特别是在仅仅使用了第三方库中的一部分代码时，尤为如此。
当然，还可以使用其他一些Java 混淆器。但是由于ProGuard 本来就是Android
SDK的一部分，所以许多第三方开发库中就带有自定义的ProGuard配置，以确保它
们功能正常。
准备工作
首先，我们要在一个Android app 中打开ProGuard。
1.如果你是使用 Eclipse 的 Android ADT 插件开发 app 的，你应该去你的
workspace，切换到含有你的app的代码的那个目录，然后会在这个目录下看
①优化也会使代码变得难读。—译者注
164
---
## Page 183
第5章保护app
 slesaly g  
end.ceftg-5(se.eir)/tae1s/prep
tepebcttarge1.
图 5.2
要打开ProGuard，你需要确保下面这一行代码没有被注释掉。
proguard, config= (sdk,dix) /too1s/proguard/proguard-androld.txt 1progua
rd-pro)ect.txt
这里，假设你Android SDK的目录结构是默认的，因为上面的配置中含有一
个静态路径——/tools/proguard/proguard-android.txt。如果你的目录结构不是
如此，或者使用的不是Eclipse 的“Android Developer's Toolkit”插件，你应
该复制proguardandroid.txt 文件，把它复制到你的 app 的工作目录中，在这种
情况下，你应该像下面这样配置这个目录。
proguard, config=proguardandroid. txt :proguard=project , txt
2.Android Studio下进行配置，需要你在 Gradle Build 系统中 buildType 的release
部分中加入下面这些代码。
android(
bui1dTypes{
release{
runProguard true
proguardFile file (*  -/proguard-project, txt)
proguardFile getDefaultProguardFLle (*proguard-android.
txt)
3.保证proGuard-android.txt 文件始终待在配置中的规定位置是很重要的，因为
这个文件中含有为 Android 定制的例外，没有它们，app 可能根本就运行不
起来。下面就是从proGuard-android.txt文件中复制出来的一段代码，它要求
ProGuard 不要混淆这些在AndrodiManifest.xml文件中处理onClick事件时要
使用的方法的方法名。
-keepclassmenbers class * extends android.app.Activity (
f(nTTAPToxpue) 。 PToA oTTqnd
165
---
## Page 184
Android安全攻防实战
怎么做
在你的项目中打开了proGuard之后，只要简单的两个步骤就能保证把所有的日
志消息全部删除掉。
1.为了使ProGuard能够成功地找出所有日志语句，我们要使用一个擦除（wrap）
类来擦除Android日志。
pub1ic class Logkrap {
public static final String TAG = *MyAppTag*;
public static void e(final Object obj。 final Throwable cause) (
Log,e (TAG, String.valueOf (obj)) /
Log .e (TAG, convertThrovableStackToString (cause)) :
public static void e(final Object obj) (
Log.e (TAG, String.valueOf (obj1)
public static void w(final Object obj。 final Throwable cause)f
Log,v(TAG, String.valueOf(obj)) ;
Log.v(TAG, convertThrowableStackToString (cause) ) /
public static void ￥(final Object obj) (
Log.v(TAG, String,valueOf (ob)) 
public static void i(final Object obj) (
Log.1 (TAG, String,valueOf (ob)) 
public static void d(final Object obj) (
Log,d(TAG, String,valueOf (ob)) :
public static void v(final Object obj) (
Log.v(TAG, String.valueOf (obj)) /
public statie String convertThrowableStackToString(final
Throvable thr)(
Stringkriter b = nev StringWriter ():
thr-printStackTrace (nev PrintHriter (b)) :
166
---
## Page 185
第5章保护app
return b.toString():
1
2.在你app 的代码中，使用类LogWrap来代替标准的 android.util.Log。例如
try[
111
}catch(I0&xoeption e)(
LogWrap.e("Ezror opening file.*, e) 
3.在项目的 proguard-project.txt 文件中插入下面这些定制的 ProGuard 配置。
-assumenosideeffects class android.util.Log [
public static boolean isloggable (java.lang.String, 1nt):
public static int v(...)
public static Lnt i(...)
 ***)x q es an
public static int d(..-)/
public static int e(..)
4.把优化配置文件添加到项目中，启用ProGuard优化。
proguard. config=$ (sdk . dir) /tools/proguard/proguard-androidoptimi.ze. txt
:proguard-project. txt
5.在release 模式下 build 你的 app，以使用 ProGuard。
 使用 Eclipse 的 Android Tools cxport 向导。
口在终端窗口中，切换至你的项目的根目录，输入下列命令。
对于Ant：ant release
对 Gradle: gradle assembleRelease
工作原理
当你在 release 模式下 build一个 app 时，build 系统将会检查 proguard.config 的
值（如果它没有被注释掉的话），并在把app 的字节码打包进app（.apk）之前，使用
ProGuard对它进行（混淆）处理。
在ProGuard处理字节码时，assumeNoefects 属性让它完全删除掉相关的代码
行—在这个例子中，就是android.util.Log类中所有方法，使用优化配置和日志擦除
器，我们让ProGuard安全地识别出了所有对android.util.Log类中各个方法的调用，
①原文如此，疑为 assumenosideefects 之误。—译者注
167
---
## Page 186
Android安全攻防实战
启用优化的一个额外的好处是：优化代码使混淆系数变得更大，甚至会使它更难读。
更多信息
我们来更进一步讨论ProGuard的一些输出及其局限性。
ProGuard 输出
下面这些是把 ProGuard 应用到 Android.apk文件时产生的输出。
·mapping.txt：顾名思义，这个文件中是混淆后的类、域（field）的名字与原来
的名字之间的映射关系。当你想使用 ProGuard 的李生工具ReTrace，分析由
被混淆过的app生成的stack trace/bug report时，必须要有这个文件。
·Seeds.txt：这个文件中列出了没混淆之前的类和成员。
·Usage.txt：这个文件中列出了从.apk文件中去掉的代码。
·Dump.txt：这个文件中描述了.apk文件中所有.class文件的内部结构。
局限性
使用ProGuard混淆一个app，增加了逆向、理解以及利用该app中的漏润所需
的时间和技术水平。但不管怎样，逆向还是有可能完成的。所以自然不能把它当作
软件安全的唯一屏障，而是应该把它作为整体安全解决方案的一个有机的组成部分。
拓展阅读
• The Advanced code obfuscation with DexGuard recipe, which talks about
ProGuard's sibling DexGuard for deeper Android-specific obfuscation.
● The ProGuard tool's web page on Android Developers site at http:/developer.
android.com/tools/help/proguard.html.
 The ProGuard official site at http://proguard.sourceforge.net/index.htm.
● The ProGuard example configurations at http:/proguard.sourceforge.net/index.
html/manual/examples.html.
5.9用GexGuard进行高级代码混淆
DexGuard是EricLafortune（他也开发了ProGuard）编写的个商用优化和混淆
工具。它的功用类似ProGuard，但是除了能混淆Java代码之外，DexGuard也可以用
在Android资源和Dalvik字节码上。和 ProGuard一样，开发者的关键优势之一就是，
源码保留了（软件的）可维护性和可测试性，而编译输出则是经过优化和加固的。
168
---
## Page 187
第5章保护app
一般面言，使用DexGuard可以获得更多的安全性，因为它是专门为Android而
优化的，同时还提供了额外的安全特性。在这个实验里，我们将要把其中的两个特
性：API隐藏和字符串加密，运用在上个实验里编写的app签名的验证代码上。
·API隐藏：就是使用API反射机制隐藏对敏感API和代码的调用。如果你要
隐藏会被黑客攻击的关键代码段，这是个完美的解决方案。例如，注册码验
证代码肯定会是软件破解者的主攻目标，所以它是个应该予以专门加固的代
码段。在反编译时，基于反射机制的调用会极大地加大破解的难度。
·字符串加密：就是把你源代码中的字符串加密起来，不让逆向工程分析人员
找到它们。对于APIkey或者其他写死在你的代码中的常量来说，这是个特别
有用的功能。
我们使用API隐藏功能，把指定的调用转换成基于反射机制的调用，这对于我
们隐藏那些不想让攻击者发现的敏感方法是很有用的。反射调用实现时是把类名和
方法签名存储为字符串的。有鉴于此，我们将用字符串加密特性作为补充，再把这
些反射字符串加密起来，以达到进一步加固的目的。这提供了一种保护app中敏感代
码段（比如募改检测代码、注册码验证代码和加密/解密代码）的健壮的方法。
厂
DexGuard 需要开发者许可，请至http://www.saikoa.com/dexguard
购买。
准备工作
假设你已经下载了Android SDK工具（22或更高版本）和DexGuard，并把它们
解压至一个你有权访问的目录中了。这个例子中，我们使用的DexGuard位于
/Users/userl/dev/lib/DexGuard/目录中，它是基于DexGuard 5.3的。本节中，我们将介
绍如何把DexGuard装入Eclipse，如何把它整合进Ant build系统和Gradle build系统。
安装完毕之后，你的app将获得比ProGuard更高安全级别的保护。此外，我们还将
启用一些定制的配置，以保护app中的敏感部分。
安装DexGuard的Eclipse插件
1.把插件JAR文件（com.saikoa.dexguard.eclipse.adt_22.0.0.v5_3_14.jar）从
DexGuard 的/eclipse 目录复制到你的 Eclipse 的安装目录下的/dropins 目录中去。
2.在你启动/重启Eclipse的时候，DexGuard 插件会自动安装。
3.如果安装顺利完成，在一个Android 项目上单击右键，你会发现在Android
169
---
## Page 188
Android安全攻防实战
tools菜单上多了一个新的选项：
Export Optimize and Obfuscate Application package (DexGuard)
4.你的项目现在可以像往常一样编译和生成一个.apk文件，但这时，在后台，
DexGuard已经被用来对这个app进行优化和混淆了。
在Antbuild系统中启用DexGuard
在Ant 中启用 DexGuard 是很方便的，只要在你的Android 项目中的配置文件
local.properties 里指定 DexGuard所在的目录就可以了。
1.如果你还没有local.properties，就创建一个，在里面加上下面这一行：
dexguard. dlr=/Users/user1/dev/1ib/DexGuard/
2.把Custom_rules.xml 文件从 DexGuard 所在目录中的 ant 文件夹中复制到你的
Android 项目的根目录中。
在Gradlebuild系统中启用DexGuard
在Gradle build 系统中启用 DexGuard，需要修改你的项目中的build.gradle 文件：
bulldscript(
repositories (
[,qTT/pxrngxea/αTT/Aep/[xesn/sxesn/=/ ,。 sxTp ) xT(vTg
dependencies [
classpath *com,android.tools.bui.1digradle:0.5.1*
classpath ' :dexguard: *
apply plug.n1*dexguard*
android (
bu11dTypes (
 + + - 
release {
proguardFile plugin getDefaultDexGuardF11e
(,o2d eeeeToxp.xenbxop,)
,3xq*4oa[oxdpxen5xep, eTTapzenfoxd
170
---
## Page 189
第5章保护app
怎么做
在安装完毕之后，我们就能启用和配置API隐藏和字符串加密特性了。
1.在你的Android 项目的根目录下，创建一个名为“dexguard-project.txt”的新
文件。
2.在DexGuard 中配置要加密的敏感字符串。在这个例子中，我们使用的是
个普通的模式：它由固定不变的一个接口以及之前实验中使用的证书hash
构成。因为这些固定不变的值在编译后甚至是用ProGuard混消之后仍是易于
阅读的。
3.在Constants接口中加密指定的字符串：
-encryptstrings interface com.packt,android.security Constants (
public static final Java.lang.String CERTIFICATE_SHA1/
或者你也可以加密某个接口或者类中的所有字符串。下面是加密
MainActivityjava 中定义的所有字符串的例子：
-encryptstrings class com.packt.android.security-MainActivity
4.作为对“验证app签名（防算改）”这个实验中“局限性”一节的回应，我们
将演示一种相应的（反制）方法，给它再加上一层保护：隐藏调用
verifyAppSignature方法的代码，使攻击者很难分析出到底是哪里的代码在做
防募改验证：
-accessthroughreflection class com,packt.android.,security Tanper (
boolean verifyAppSignature (Context) 
-accessthroughreflection class android.content .pm.PackageManager (