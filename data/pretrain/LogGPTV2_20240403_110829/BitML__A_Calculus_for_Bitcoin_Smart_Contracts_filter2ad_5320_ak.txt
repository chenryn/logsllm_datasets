(3) λc = A → ∗ : m, where λc does not correspond to any
symbolic move, according to the first inductive case.
We write Rs ∼r Rc iff coher (Rs , Rc , r , txout, sechash, κ) for some
⋄
txout, sechash, and κ.
The following lemma is the active contracts analogous of Lemma 1.
Both results are proved by induction on the definition of coherence.
Lemma 6. Let coher (Rs , Rc , r , txout, sechash, κ). For each active
contract ⟨C , v⟩x occurring in ΓRs , there exists a corresponding unspent
transaction output (T, o) in BRc with value v. Further, T is generated
by the invoking the compiler as BC (C , Dp , T′, o′, v, I , P , t ) for some
values of Dp , T′, o′, I , P , t, or as Bpar (⃗C , Dp , T′o′, ⃗v, P , t ) for some
values of ⃗C , Dp , T′, o′, ⃗v, P , t such that C = ⃗C o+1 and v = ⃗vo+1,
using parameters txout, sechash, κ.
Proof. By induction on the definition of coherence. The corre-
□
spondence is witnessed by the txout mapping.
A.7 From symbolic to computational strategies
Our computational soundness result is based on a mapping from
symbolic to computational strategies.
23
Given a symbolic strategy Σs of an honest participant A, we
translate it to a computational strategy Σc which emulates its be-
haviour. We first describe how to translate the stipulation of a
contract advertisement {G}C, i.e. by providing a computational
counterpart to the rules in Figure 4. In the computational model,
this is performed by following a stipulation protocol (Definition 21),
which will be exploited to construct Σc.
Note that, while in the symbolic setting we model contract ad-
vertisements as terms {G}C, containing names x for the deposits,
in the computational setting we encode such advertisements as bit-
strings, using transaction outputs (T, o) instead of deposit names x.
In the stipulation protocol, we assume as given this representation
C, which we call computational contract advertisement, and the
parameters of Σc
, i.e. the computational run Rc and the random
A
sequence rA. After decoding C as a symbolic advertisement {G}C,
A interacts with the other participants to obtain all the parame-
ters required to compile {G}C. Then, A computes Badv({G}C ), and
finally she puts the generated Tinit transaction on the ledger.
Definition 21 (Stipulation protocol). Let A ∈ Hon, let Rc∗ be a
(A-stripped) computational run, and let rA be a random sequence.
The stipulation protocol for a computational contract advertisement
C is the following.
p
p
p
(1) A decodes C, constructing a symbolic contract advertise-
ment {G}C; in doing this, A chooses distinct symbolic
names for all the transaction outputs in C. The mapping
txout is defined according to the used correspondence be-
tween names and transaction outputs.
(2) A infers from G the parameters part, PartG, and val.
(3) A uses rA to obtain the key pairs KA (rA ) and ˆKA (rA ). The
key KA (rA ) is used by A to sign all the protocol messages.
Further, A reads, from the initial prefix of the run Rc∗, the
B (rB ) of the all B ∈ PartG \
B (rB ) and ˆK
public keys K
p
{A}. The keys K
B (rB ) are then used by A to filter out the
incoming messages with incorrect signatures.
(4) A defines compiler keys: K(A) is ˆKA (rA ), while the public
part of K(B) is ˆK
B (rB ) for B (cid:44) A. The keys K(D , A) are
generated by A consuming ∼ η fresh bits from rA, and their
public parts are shared with the others. Dually, A defines
the public parts of keys K(D , B) using the first broadcasts
by the other participants. Let ⃗k be the sequence of public
keys known by A after this step.
(5) A generates from rA a secret nonce of the desired length
(to be defined by Σc
) for every A:secret a in G. Then,
A
A computes the hashes ⃗h = h1 · · · hk
of secret nonces (by
querying O), and broadcasts all these hashes as a single
message m(C, ⃗h, ⃗k ). Dually, A receives the hashes ⃗h′ from
the other participants. When doing this, A defines sechash
using the first (correctly signed) m(C, ⃗h′, ⃗k ) in Rc∗ which
has no duplicate hashes, and has no hashes already occur-
ring (signed) in Rc∗.
(6) A computes Badv({G}C ), generating a list of transactions.
The signatures by A occurring in the witnesses are com-
puted and shared with others, while the signatures of other
participants are received and verified. Note that the Tinit
transaction, (whose wit field is left to ⊥ by the compiler),
is not signed, yet.
(7) Only at this point, after having verified all the other signa-
tures, A signs the first transaction, adding the signatures
for her persistent deposits using ˆKA (rA ). Dually, she re-
ceives the signatures from the other participants for their
own persistent deposits.
(8) Finally, A broadcasts the signed Tinit, and its witnesses,
and puts it on the ledger.
Remark on replay attacks Item 5 of Definition 21 makes any
honest participant reject any hash which has been already used in a
previous commitment. This is crucial to avoid replay attacks during
the commitment of the hashes: otherwise, it would be easy for an
adversary to win the OddsEvens game in in Section 2. The attack
would proceed as follows. The adversary plays the role of A. After
(by broadcasting H (sb )), A commits to
B has committed to secret sb
the same hash. Later on, after B has revealed sb
, A reveals sa = sb
.
In this way, A would ensure that the two secrets are identical, hence
have the same length, which causes A to win the game.
Under the assumption that hashes are modelled according to the
random oracle model, checking against duplicates in the stipulation
protocol avoids replay attacks like the one above. Instead, under
some weaker assumptions on the hash function, e.g. collision re-
sistance, a replay attack5 would not be prevented by Item 5. For
instance, let H′ be a collision resistant hash function, and let:
(X1 · · · Xn )
H (X ) = X0 ∥ H
(where X = X0 · · · Xn)
In this way, also the hash function H is collision resistant. Let
flip(X ) be the function which toggles the first bit of a bit string X.
Our hash function H, by definition, satisfies:
′
H (flip(X )) = H (flip(X0) ∥ X1 · · · Xn )
′
(X1 · · · Xn )
(X1 · · · Xn ))
= flip(X0) ∥ H
′
= flip(X0 ∥ H
= flip(H (X ))
In this way, after receiving H (sb ), the adversary can compute and
broadcast flip(H (sb )). Since flip(H (sb )) is different from H (sb ) (in
the first bit), it is accepted as a commitment of A by our stipulation
is revealed, A can compute flip(sb ), and
protocol. Further, after sb
reveal it as a preimage of flip(H (sb )) = H (flip(sb )). Since sb
and
flip(sb ) have the same length, the adversary A wins the game.
Parsing computational runs In order to define the mapping
from symbolic to computational strategies, we first sketch how to
parse a (stripped) computational run Rc∗ so to obtain a (stripped)
symbolic run Rs∗. This requires to find, when possible, a symbolic
counterpart to computational actions, mapping, e.g., computational
advertisements to symbolic ones, signatures to authorizations, trans-
actions to symbolic actions (involving deposits or contracts), and
secrets to reveal actions. This correspondence closely follows Def-
inition 20. Indeed, to perform the parsing, we can exploit maps
similar to txout, sechash and κ to keep track of the correspondence
at each step of Rs∗.
5We would like to thank Andrew Miller for pointing out this attack, which would be
possible when weakening the assumptions about the hash function.
24
Using such maps, we can detect when a transaction T in Rc∗ has
some input with a symbolic counterpart (i.e. in ran txout). When
that happens, we can map T into its corresponding action in Rs∗.
According to Definitions 16 and 17, T has to be preceded by the
broadcasts of its witnesses w, which, in turn, must be preceded by
the broadcast of T. This allows to parse the signatures in w, so to
generate authorizations in Rs∗.
A few cases must be handled with more care. For instance, Adv
could broadcast a signature before the signed transaction. When this
happens, we simply ignore the message; duplicate signatures are
ignored as well. Further, a computational contract advertisement
could involve only dishonest participants: we ignore that as well.
Adv can consume her own deposits (among those tracked by txout),
to create an arbitrary transaction without a symbolic counterpart.
In this case, in the semantics we use the [Dep-Destroy] move in Rs∗,
preceded by its authorizations, making those deposits disappear
from the symbolic world. When the hash of a secret is committed, it
can not be parsed precisely as a [C-AuthCommit] move, since the latter
involves the length of the secrets, which can not be inferred from
the hash. However, this is not needed, since the stripped run Rs∗
does not involve such lengths.
Definition 22 (From symbolic to computational strategies).
Let Σs
A ) =
A
below. Given the parameters Rc∗, rA of Σc
Σc
A
A
(1) parse the (stripped) run Rc∗, so to obtain a corresponding
(2) halve the random sequence rA as (π1 (rA ), π2 (rA ));
(3) evaluate Λs = Σs
(4) convert the symbolic actions Λs into computational ac-
tions Λc, and define Σc
A (Rc∗ , rA ) = Λc. When Λs contains
A : {G}C , ∆ or A : {G}C , x, their conversion follows the
stipulation protocol (Definition 21), using π2 (rA ). There,
at item 5, we choose the length of each secret by adding η
⋄
to the corresponding value N in ∆.
be a symbolic strategy, with A ∈ Hon. We define ℵ(Σs
symbolic (stripped) run Rs∗, as sketched above;
A (Rs∗ , π1 (rA ));
, we:
A.8 Supplementary material for Section 9
Proof of Theorem 2 Assume that Rc satisfies the hypotheses, but
has no corresponding Rs which is coherent (to Rc) and conforming
(to the symbolic strategies). Consider the longest prefix ˙Rc of Rc
having a corresponding ˙Rs which is coherent (to ˙Rc) and conform-
ing (to the computational strategies). We have that Rc = ˙Rc λc · · · .
We now show that either ˙Rc λc has a corresponding symbolic run
˙Rs ¨Rs which is coherent and conforming to the symbolic strategies
(contradicting the maximality of ˙Rc), or the adversary succeeded
in a signature forgery, or in a preimage attack (which can happen
only with negligible probability). Note that, by obtain coherence,
¨Rs must be either empty, or contain a single symbolic action.
We proceed by cases on λc:
(1) λc = B → ∗ : m. Then, coherence must hold for some ¨Rs.
Indeed, the definition of coherence maps m to an authoriza-
tion (if it is the first broadcast of a signature), a revealed
secret (if it is the first broadcast of a preimage), or in all
other cases it simply ignores m. So, we can choose ¨Rs as the
corresponding move, or to be empty, and obtain coherence.
In these cases, we also obtain conformance. Indeed, in the
= ℵ(Σs
last case (¨Rs empty) the run ˙Rs ¨Rs = ˙Rs is trivially conform-
ing. For the authorization or reveal cases, we note that if
the computational Adv was able to generate m, it is either
forged (with negligible probability), or it originated from
A ), it follows that, at some
some honest A. Since Σc
A
time in the past, Σs
enabled the authorization or reveal.
A
By persistency, it is also enabled at the end of ˙Rs, hence
can choose such action, and achieve conformance.
Σs
Adv
(2) If λc = T, we consider the following subcases according to
the inputs of T:
(a) If no input of T belongs to ran txout, then coherence
and conformance are achieved taking ¨Rs to be empty.
(b) Otherwise, if at least one of the inputs of T belongs
to ran txout, then we look in ˙Rs for all the deposits
and active contracts corresponding to such inputs. By
definition of computational strategy, we must find in
˙Rc a (first) broadcast B → ∗ : T followed by a (first)
broadcast B → ∗ : m for all witnesses m of T. By the
coherence of ˙Rc, in ˙Rs the messages B → ∗ : m corre-
spond to suitable authorization/reveal moves for each
of the (counterparts of the) inputs of T. We consider
the following subcases:
(i) If all the inputs are deposits, then we let ¨Rs
perform the symbolic move corresponding to T
(e.g., init or join). Note that if T can not be rep-
resented symbolically, we can choose ¨Rs to per-
form a destroy. Such moves are feasible symboli-
cally since we already have their authorizations.
Such ¨Rs leads to a coherent run, which is also
conforming, since even if no honest strategy
wants to perform the move, Adv can perform it
on its own, having all the authorizations.
(ii) Otherwise, some input T′ of T must correspond
to an active contract. This must be originated
from an advertisement, which has to involve at
least one honest participant A, by definition of
the symbolic semantics (rule [C-Advertise]). How-
ever, by construction, our compiler makes T′
require the signatures of all the participants,
hence including A. Since such signature must
occur as a witness in T, the adversary Adv must
have forged it (with negligible probability), or
must have obtained it from A. In the latter case,
˙Rs contains an authorization for the symbolic
move corresponding to λc. By choosing ¨Rs ac-
cordingly, we obtain a coherent and conforming
run.
(3) Finally, if λc = δ, we simply choose ¨Rs to perform δ. Co-
herence trivially holds. For conformance, we note that by
definition of computational strategy, all the honest partici-
pants must output a Λc which either contains some δ′ ≥ δ,
or is empty. By definition of ℵ, this must also be the case
in Λs, resulting in conformance.
□
25