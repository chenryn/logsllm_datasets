Phase 5
P hase 1
P hase 3
P hase 5
Phase 4
cloud
(outsourcing agent)
Figure 1: The complete outsourced SFE protocol.
3.3 Malleable claw-free collections
To prevent the generating party from providing differ-
ent inputs for each evaluation circuit, we implement the
malleable claw-free collections technique developed by
shelat and Shen [41]. Their construction essentially al-
lows the generating party to prove that all of the garbled
input values were generated by exactly one function in
a function pair, while the ability to ﬁnd an element that
is generated by both functions implies that the genera-
tor can ﬁnd a claw.
It is composed of a four-tuple of
algorithms (G,D,F,R), where G is the index selection
algorithm for selecting a speciﬁc function pair, D is an
algorithm for sampling from the domain of the function
pair, F is the algorithm for evaluating the functions in the
pair (in which it should be difﬁcult to ﬁnd a claw), and R
is the “malleability” function. The function R maps ele-
ments from the domain of F to the range of F such that
for b ∈ {0,1}, any I in the range of G, and any m1,m2 in
the domain of F, we have for the function indexed by I
and b f b
I (m1)(cid:28)RI(m2), where (cid:30) and (cid:28) rep-
resent the group operations over the domain and range of
F. We provide full deﬁnitions of their construction in our
technical report [6].
I (m1 (cid:30)m2) = f b
3.4 Model and Deﬁnitions
The work of Kamara et al. [21] presents a deﬁnition
of security based on the ideal-model/real-model secu-
rity deﬁnitions common in secure multiparty computa-
tion. Because their deﬁnition formalizes the idea of a
non-colluding cloud, we apply their deﬁnitions to our
protocol for the two-party case in particular. We sum-
marize their deﬁnitions below.
Real-model execution. The protocol takes place be-
tween two parties (P1,P2) executing the protocol and a
server P3, where each of the executing parties provides
input xi, auxiliary input zi, and random coins ri and the
server provides only auxiliary input z3 and random coins
r3. In the execution, there exists some subset of indepen-
dent parties (A1, ..,Am),m ≤ 3 that are malicious adver-
saries. Each adversary corrupts one executing party and
292  22nd USENIX Security Symposium 
USENIX Association
4
does not share information with other adversaries. For all
honest parties, let OUTi be its output, and for corrupted
parties let OUTi be its view of the protocol execution.
The ith partial output of a real execution is deﬁned as:
REAL(i)(k,x;r) ={OUT j : j ∈ H}∪OUTi
where H is the set of honest parties and r is all random
coins of all players.
Ideal-model execution. In the ideal model, the setup of
participants is the same except that all parties are inter-
acting with a trusted party that evaluates the function. All
parties provide inputs xi, auxiliary input zi, and random
coins ri. If a party is semi-honest, it provides its actual
inputs to the trusted party, while if the party is malicious
(and non-colluding), it provides arbitrary input values.
In the case of the server P3, this means simply providing
its auxiliary input and random coins, as no input is pro-
vided to the function being evaluated. Once the function
is evaluated by the trusted third party, it returns the result
to the parties P1 and P2, while the server P3 does not re-
ceive the output. If a party aborts early or sends no input,
the trusted party immediately aborts. For all honest par-
ties, let OUTi be its output to the trusted party, and for
corrupted parties let OUTi be some value output by Pi.
The ith partial output of an ideal execution in the pres-
ence of some set of independent simulators is deﬁned as:
IDEAL(i)(k,x;r) ={OUT j : j ∈ H}∪OUTi
where H is the set of honest parties and r is all random
coins of all players. In this model, the formal deﬁnition
of security is as follows:
Deﬁnition 1. A protocol securely computes a function
f if there exists a set of probabilistic polynomial-time
(PPT) simulators {Simi}i∈[3] such that for all PPT ad-
versaries (A1, ...,A3), x, z, and for all i ∈ [3]:
{REAL(i)(k,x;r)}k∈N
c
≈ {IDEAL(i)(k,x;r)}k∈N
Where S = (S1, ...,S3), Si = Simi(Ai), and r is random
and uniform.
4 Protocol
Our protocol can be divided into ﬁve phases, illustrated
in Figure 1. Given a circuit generator Bob, and an eval-
uating mobile device Alice, the protocol can be summa-
rized as follows:
• Phase 1: Bob generates a number of garbled cir-
cuits, some of which will be checked, others will be
evaluated. After Bob commits to the circuits, Alice
and Bob use a fair coin toss protocol to select which
circuits will be checked or evaluated. For the check
Inputs: Alice has a string of encoded input bits ea of
length (cid:29)·n and Bob has pairs of input values (x0, j,x1, j)
for j = 1...(cid:29)· n.
1. Setup: Alice generates random matrix T of size
(cid:29)· n× t, Bob generates random string s of length
t.
2. Primitive OT: Alice and Bob execute t 1-
out-of-2 oblivious transfers with Alice inputting
(T i,T i⊕ea) and Bob inputting selection bits s (T i
denotes the ith column of the T matrix). Bob sets
the resulting columns as matrix Q.
3. Permuting the output: Alice generates random
string p of length (cid:29)· n and sends it to Bob.
4. Encrypting the output: Bob sets the en-
crypted output pairs y0, j,y1, j where yb, j = xb, j ⊕
H1( j,Q j ⊕ (b· s)) (Q j denotes the jth row of the
Q matrix).
5. Permuting the outputs: Bob permutes the en-
crypted output pairs as y0⊕p j, j,y1⊕p j, j and sends
the resulting set of pairs Y to the cloud.
6. Decrypting the output: Alice sends h = ea ⊕
p and T to the cloud. The cloud recovers z j =
yh j, j ⊕ H1( j,Tj) for j = 1...(cid:29) · n (Tj denotes the
jth row of the T matrix).
Figure 2: The Outsourced Oblivious Transfer protocol
circuits, Bob sends the random seeds used to gener-
ate the circuits to the cloud and the hashes of each
circuit to Alice. These are checked to ensure that
Bob has not constructed a circuit that is corrupted
or deviates from the agreed-upon function.
• Phase 2: Alice sends her inputs to Bob via an out-
sourced oblivious transfer. Bob then sends the cor-
responding garbled inputs to the cloud. This allows
the cloud to receive Alice’s garbled inputs without
Bob or the cloud ever learning her true inputs.
• Phase 3: Bob sends his garbled inputs to the cloud,
which veriﬁes that they are consistent for each eval-
uation circuit. This prevents Bob from providing
different inputs to different evaluation circuits.
• Phase 4: The cloud evaluates the circuit given Alice
and Bob’s garbled inputs. Since the cloud only sees
garbled values during the evaluation of the circuit,
it never learns anything about either party’s input or
output. Since both output values are blinded with
one-time pads, they remain private even when the
cloud takes a majority vote.
• Phase 5: The cloud sends the encrypted output val-
ues to Alice and Bob, who are guaranteed its au-
thenticity through the use of commitments and zero-
knowledge proofs.
USENIX Association  
22nd USENIX Security Symposium  293
5
4.1 Participants
Our protocols reference three different entities:
Evaluator: The evaluating party, called Alice, is as-
sumed to be a mobile device that is participating in a
secure two-party computation.
Generator: The party generating the garbled circuit,
called Bob, is an application- or web- server that is the
second party participating with Alice in the secure com-
putation.
Proxy: The proxy, called cloud, is a third party that is
performing heavy computation on behalf of Alice, but is
not trusted to know her input or the function output.
a
two
that
is
securely
a function f (x,y)
claw-free
hash
4.2 Outsourced Protocol
Common inputs:
to
computed,
be
collection
(GCLW ,DCLW ,FCLW ,RCLW ),
functions
H1 : {0,1}∗ → {0,1}n and H2 : {0,1}∗ → {0,1}w,
a primitive 1-out-of-2 oblivious transfer protocol, a per-
fectly hiding commitment scheme comH (key,message),
and security parameters for the number of circuits built
k, the number of primitive oblivious transfers t, and the
number of encoding bits for each of Alice’s input wires
(cid:30).
Private inputs: The generating party Bob inputs a bit
string b and a random string of bits br that is the length
of the output string. The evaluating party Alice inputs a
bit string a and a random string of bits ar that is the length
of the output string. Assume without loss of generality
that all input and output strings are of length |a| = n.
Output: The protocol outputs separate private values f a
for Alice and f b for Bob.
Phase 1: Circuit generation and checking
1. Circuit preparation: Before beginning the protocol,
both parties agree upon a circuit representation of
the function f (a,b), where the outputs of the func-
tion may be deﬁned separately for Alice and Bob as
fA(a,b) and fB(a,b). The circuit must also meet the
following requirements:
(a) Additional XOR gates must be added such that
Bob’s output is set to f b = fB(a,b)⊕ br and
Alice’s output is set to f a = fA(a,b)⊕ ar.
(b) For each of Alice’s input bits, the input wire
wi is split into (cid:30) different input wires w j,i
such that wi = w1,i ⊕ w2,i ⊕ ... ⊕ wl,i follow-
ing the input encoding scheme by Lindell and
Pinkas [29]. This prevents Bob from correlat-
ing a selective failure attack with any of Al-
ice’s input bit values.
2. Circuit garbling: the generating party, Bob, con-
structs k garbled circuits using a circuit garbling
technique Garble(·,·). When given a circuit rep-
resentation C of a function and random coins
rc, Garble(C,rc) outputs a garbled circuit GC
that evaluates C. Given the circuit C and ran-
dom coins rc1...rck, Bob generates garbled circuits
Garble(C,rci) =GC i for i = 1...k. For Bob’s jth in-
put wire on the ith circuit, Bob associates the value
H2(βb, j,i) with the input value b, where βb, j,i =
FCLW (b,I,αb, j,i). For Alice’s jth input wire, Bob as-
sociates the value H2(δb, j,i) with the input value b,
where δb, j,i = FCLW (b,I,γb, j,i). All the values αb, j,i
and γb, j,i for b = {0,1}, j = 1...n,i = 1...k are se-
lected randomly from the domain of the claw-free
pair using D.
3. Circuit commitment: Bob generates commitments
for all circuits by hashing H1(GCi) = HCi for i =
1...k. Bob sends these hashes to Alice. In addition,
for every output wire wb, j,i for b = {0,1}, j = 1...n
and i = 1...k, Bob generates commitments CO j,i =
comH (ck j,i, (H2(w0, j,i),H2(w1, j,i))) using commit-
ment keys ck j,i for j = 1...n and i = 1...k and sends
them to both Alice and the cloud.
4. Input label commitment: Bob commits to Alice’s
garbled input values as follows:
for each gener-
ated circuit i = 1...k and each of Alice’s input wires
j = 1...(cid:30)· n, Bob creates a pair of commitment keys
ik0, j,i,ik1, j,i and commits to the input wire label
seeds δ0, j,i and δ1, j,i as CIb, j,i = comH (ikb, j,i,δb, j,i).
For each of Alice’s input wires j = 1...(cid:30)·n, Bob ran-
domly permutes the commitments within the pair
CI0, j,i,CI1, j,i across every i = 1...k. This prevents
the cloud from correlating the location of the com-
mitment with Alice’s input value during the OOT
phase.
5. Cut and choose: Alice and Bob then run a fair coin
toss protocol to agree on a set of circuits that will
be evaluated, while the remaining circuits will be
checked. The coin toss generates a set of indices
Chk ⊂ {1, ...,k} such that |Chk| = 3
5 k, as in shelat
and Shen’s cut-and-choose protocol [41]. The re-
maining indices are placed in the set Evl for eval-
uation, where |Evl| = e = 2
5 k. For every i ∈ Chk,
Bob sends rci and the values [αb,1,i, ...,αb,n,i] and
[γb,1,i, ...,γb,(cid:30)·n,i] for b = {0,1} to the cloud. Bob
also sends all commitment keys ck j,i for j = 1...n
and i ∈ Chk to the cloud. Finally, Bob sends the
commitment keys ikb, j,i for b = {0,1}, i ∈ Chk, and
j = 1...(cid:30) · n to the cloud. The cloud then gener-
ates Garble(C,rci) =GC (cid:22)i for i ∈ Chk. For each
i ∈ Chk, the cloud then hashes each check circuit
H1(GC(cid:22)i) =HC (cid:22)i and checks that:
294  22nd USENIX Security Symposium 
USENIX Association
6
formed
value b for Bob’s jth input wire
value b for Alice’s jth input wire
• each commitment CO j,i for j = 1...n is well
• the value H2(βb, j,i) is associated with the input
• the value H2(δb, j,i) is associated with the input
• for every bit value b and input wire j, the val-
If any of these checks fail, the cloud immediately
aborts. Otherwise, it sends the hash values HC(cid:30)i for
i ∈ Chk to Alice. For every i ∈ Chk, Alice checks
if HCi = HC(cid:30)i. If any of the hash comparisons fail,
Alice aborts.
ues committed in CIb, j,i are correct
Phase 2: Outsourced Oblivious Transfer (OOT)
1. Input encoding: For every bit j = 1...n in her input
a, Alice sets encoded input ea j as a random string
of length (cid:29) such that ea1, j ⊕ ea2, j ⊕ ...⊕ eal, j = a j
for each bit in ea j. This new encoded input string
ea is of length (cid:29)· n.
2. OT setup: Alice initializes an (cid:29)· n×t matrix T with
uniformly random bit values, while Bob initializes
a random bit vector s of length t. See Figure 2 for a
more concise view.
3. Primitive OT operations: With Alice as the sender
and Bob as the chooser, the parties initiate t 1-out-
of-2 oblivious transfers. Alice’s input to the ith in-
stance of the OT is the pair (T i,T i ⊕ ea) where T i
is the ith column of T , while Bob’s input is the ith
selection bit from the vector s. Bob organizes the t
selected columns as a new matrix Q.
follows:
for Alice’s
5. Encrypting the commitment keys:
4. Permuting the selections: Alice generates a random
bit string p of length (cid:29)· n, which she sends to Bob.
Bob gen-
erates a matrix of keys
that will open the
committed garbled input values and proofs of
in-
consistency as
put bit, Bob creates a pair (x0, j,x1, j), where
xb, j = [ikb, j,Evl1,ikb, j,Evl2, ...,ikb, j,Evle]||[γb j, j,Evl2 (cid:28)
(γb j, j,Evl1)−1,γb j, j,Evl3 (cid:28) (γb j, j,Evl1)−1, ...,γb j, j,Evle (cid:28)
(γb j, j,Evl1)−1] and Evli denotes the ith index in the
set of evaluation circuits. For j = 1...(cid:29)· n, Bob pre-
pares (y0, j,y1, j) where yb, j = xb, j ⊕ H1( j,Q j ⊕ (b·
s)). Here, Q j denotes the jth row in the Q matrix.
Bob permutes the entries using Alice’s permutation
vector as (y0⊕p j, j,y1⊕p j, j). Bob sends this permuted
set of ciphertexts Y to the cloud.
jth
6. Receiving Alice’s garbled inputs: Alice blinds her
input as h = ea ⊕ p and sends h and T to the
cloud. The cloud recovers the commitment keys
7
and consistency proofs xb, j = yh j, j ⊕ H1( j,Tj) for
j = 1...(cid:29) · n. Here, h j denotes the jth bit of the
string h and Tj denotes the jth row in the T ma-
trix. Since for every j ∈ Evl, the cloud only has
the commitment key for the b garbled value (not the
b⊕1 garbled value), the cloud can correctly decom-
mit only the garbled labels corresponding to Alice’s
input bits.
7. Verifying
pre
and
Alice’s
[γb j, j,Evl2
the modiﬁed
across
decommitted
(cid:28) (γb j, j,Evl1)−1,γb j, j,Evl3
in-
values
im-
(cid:28)
the
consistency
puts:
Given
the
[δb,1,i, ...,δb,(cid:29)·n,i]
ages
(γb j, j,Evl1)−1, ...,γb j, j,Evle (cid:28) (γb j, j,Evl1)−1],
cloud checks that:
δb j, j,i = δb j, j,Evl1 (cid:23) RCLW (I,γb j, j,i (cid:28) (γb j, j,Evl1)−1)
for i = 2...e. If any of these checks fails, the cloud
aborts the protocol.
Phase 3: Generator input consistency check
1. Delivering inputs:
for
every
Bob delivers
the hash
seeds
for each of his garbled input values
[βb1,1,i,βb2,2,i, ...,βbn,n,i]
evaluation
circuit i ∈ Evl to the cloud, which forwards a copy
of these values to Alice. Bob then proves the
consistency of his inputs by sending the modiﬁed
[αb j, j,Evl2 (cid:28) (αb j, j,Evl1)−1,αb j, j,Evl3 (cid:28)
preimages
(αb j, j,Evl1)−1, ...,αb j, j,Evle (cid:28) (αb j, j,Evl1)−1] such that
FCLW (bi,I,αbi, j,i) = βbi, j,i for j = 1...n and i ∈ Evl
such that GCi was generated with the claw-free