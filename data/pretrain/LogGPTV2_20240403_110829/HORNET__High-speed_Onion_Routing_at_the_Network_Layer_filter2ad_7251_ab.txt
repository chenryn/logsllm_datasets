information to any node on the path. We note that using Sphinx
also for data forwarding would result in low throughput due to pro-
hibitively expensive per-hop asymmetric cryptographic operations.
Therefore, we use Sphinx only for session setup packets, which
are amortized over the subsequent data transmission packets. We
explain the details of the setup phase in Section 4.3.
Data transmission phase. Having collected the FSes, the source
is now able to construct a forward AHDR and a backward AHDR
for the forward and backward paths, respectively. AHDRs carry the
FSes which contain all state necessary for nodes to process and
forward packets to the next hop. When sending a data packet, the
source onion-encrypts the data payload using the session’s shared
symmetric keys, and prepends the AHDR. Each node then retrieves
its FS from the AHDR, onion-decrypts the packet and forwards it to
the next hop, until it reaches the destination. The destination uses
the backward AHDR (received in the ﬁrst data packet2) to send data
back to S, with the only difference being that the payload is en-
crypted (rather than decrypted) at each hop. We present the details
of the data transmission phase in Section 4.4.
3.2 Sender-Receiver Anonymity
Sender-receiver anonymity, where neither S nor D knows the
other’s location (e.g., a hidden service), presents a new challenge:
since S does not know D’s location (and vice versa), S cannot
retrieve a path to D, precluding the establishment of state between
S and nodes on the path to D as described in Section 3.1.
A common approach to this problem (as adopted by Tor3, LAP,
and Dovetail) is to use a public rendezvous point (RP) to forward
trafﬁc between S and D without knowing either S or D. This
solution would also work for HORNET, but would require RPs to
maintain per-session state between sources and destinations. For
instance, when receiving a packet from S, an RP needs the state to
determine how to send the packet to D. Maintaining per-session
state on RPs increases complexity, bounds the number of receivers,
and introduces a state exhaustion denial-of-service attack vector.
Nested AHDRs. Our proposal for sender-receiver anonymity re-
quires no state to be kept at the RP by nesting the necessary state
for RPs to forward a packet within the packet’s header: a forward
AHDR from S to a RP will include the AHDR from the RP to D; a
backward AHDR from D to a RP will include the AHDR from the
RP back to S.
Brieﬂy, to establish a HORNET session between S and D keep-
ing both parties hidden from each other, D selects a public ren-
dezvous point R and completes a HORNET session setup between
D and R. D publishes AHDRR→D to a public directory. Note that
this AHDR leaks no information about D’s location and can only be
used to send data to D through R within a speciﬁc time window.
When S wants to send trafﬁc to D, S retrieves (from a public
directory) AHDRR→D. S then establishes a HORNET session be-
tween S and R and constructs a nested AHDR with AHDRR→D
inside AHDRS→R. Thus, when R receives a packet from S, R can
retrieve AHDRR→D from AHDRS→R and forward the packet to
D. S also includes AHDRR→S in the data payload of the ﬁrst data
packet to D, allowing D to create a return path to S.
One of the advantages of our scheme is that any node on the net-
work can serve as a rendezvous point. In fact, multiple points can
2If the ﬁrst packet is lost the source can simply resend the backward
AHDR using a new data packet (see Section 4.4).
3Tor additionally uses an introduction point, which enables S to
negotiate a rendezvous point with D. This design provides addi-
tional scalability and attack resistance [25], but increases the delay
of setting up a session. HORNET’s design favors simplicity and
performance, but nothing fundamentally prevents HORNET from
using Tor’s approach.
1443be selected and advertised, allowing the source to pick the RP clos-
est to it. Moreover, once a HORNET session has been established,
S and D can negotiate a better (closer) RP (e.g., using private set
intersection [27]). A disadvantage of the nested AHDR technique is
that it doubles the size of the header.
For space reasons, the formal protocol details and evaluation sec-
tions focus on sender anonymity only. Details of sender-receiver
anonymity can be found in the full paper [19].
3.3 Packet Structure
HORNET uses two types of packets: setup packets and data
packets (see Figure 1). Both types of packets begin with a com-
mon header (CHDR) which describes the packet type, the length of
the longest path that the session supports, and a type-speciﬁc ﬁeld.
For session setup packets, the type-speciﬁc ﬁeld contains a value
EXP which indicates the intended expiration time of the session.
For data packets, the speciﬁc value is a random nonce generated by
the sender used by intermediate nodes to process the data packet.
Session setup packets include a nested Sphinx packet and an FS
payload. Data packets carry an AHDR and an onion-encrypted data
payload. We explain each ﬁeld in detail in Section 4.
Figure 1: HORNET packet formats. For both setup packet and
data packet, the shaded ﬁelds represent the common header
(CHDR).
4. FORMAL PROTOCOL DESCRIPTION
We now describe the details of our protocol, focusing on sender
anonymity. We begin with notation (Section 4.1) and initialization
requirements (Section 4.2). We then describe the establishment of
anonymous communication sessions (Section 4.3) and data trans-
mission (Section 4.4).
4.1 Notation
Let k be the security parameter used in the protocol. For evalua-
tion purposes we consider k = 128. G is a prime order cyclic group
of order q (q ∼ 22k), which satisﬁes the Decisional Difﬁe-Hellman
Assumption. G∗ is the set of non-identity elements in G and g is a
generator of G. Throughout this section we use the multiplicative
notation for G.
Let r be the maximum length of a path, i.e., the maximum num-
ber of nodes on a path, including the destination. We denote the
length of an FS as |F S| and the size of an AHDR block, containing
an FS and a MAC of size k, as c = |F S| + k.
• MAC : {0, 1}k × {0, 1}∗ → {0, 1}k: Message Authentication
• PRG0,PRG1,PRG2 : {0, 1}k → {0, 1}rc: Three cryptographic
HORNET uses the following cryptographic primitives:
Code (MAC) function.
pseudo-random generators.
• PRP : {0, 1}k ×{0, 1}a → {0, 1}a: A pseudo-random permu-
tation, implementable as a block cipher. The value of a will be
clear from the context.
Term
k
|F S|
c
r
S, D
pf , pb
lf , lb
nf
i , nb
j
gxn , xn
sf
i
R
CHDR
SHDR, SP
P
AHDR
O
EXP
Deﬁnition
Security parameter (length of keys and MACs). k = 128 bits (16
B).
Length of a forwarding segment (FS). |F S| = 256 bits (32 B).
Length of a typical block made of an FS and a MAC. c = |F S| +
k = 384 bits (48 B) .
Maximum path length, including the destination. From our evalu-
ation, r = 7.
Source and destination.
The forward path (from S to D) and the backward path (from D to
S).
Lengths of the forward and backward path (l, when it is clear from
the context to which path it refers). From our evaluation, 1 ≤ l ≤
7.
The i-th node on the forward path and the j-th node on the back-
ward path, with 0 ≤ i < lf and 0 ≤ j < lb.
Public/private key pair of node n.
Secret key established between S and node nf
i .
Routing information, which allows a node to forward a packet to
the next hop.
Common header. First three ﬁelds of both setup packets and data
packets (see Figure 1).
Sphinx header and payload.
FS payload, used to collect the FSes during the setup phase.
Anonymous header, used for every data packet.
node on the path to retrieve its FS.
Onion payload, containing the data payload of data packets.
Expiration time, included in each FS.
It allows each
Table 1: Protocol notation and typical values (where applica-
ble).
• ENC : {0, 1}k × {0, 1}k × {0, 1}mk → {0, 1}mk: Encryption
function, with the second parameter being the Initialization Vec-
tor (IV) (e.g., stream cipher in CBC mode). m is a positive inte-
ger denoting the number of encrypted blocks.
• DEC : {0, 1}k × {0, 1}k × {0, 1}mk → {0, 1}mk: Decryption
• hop : G∗ → {0, 1}k: a family of hash functions used to key op,
function, inverse of ENC.
with op ∈ {MAC,PRG0,PRG1,PRP,ENC,DEC}.
We denote by RAND(a) a function that generates a new uniformly
random string of length a.
Furthermore, we deﬁne the notation for bit strings. 0a stands for
a string of zeros of length a. |σ| is the length of the bit string σ.
σ[a...b] represents a substring of σ from bit a to bit b, with sub-
index a starting from 0; σ[a...end] indicates the substring of σ from
bit a till the end. ε is the empty string. σ(cid:107) σ(cid:48) is the concatenation of
string σ and string σ(cid:48). We summarize protocol notation and typical
values for speciﬁc parameters in Table 1.
0 , nf
1 , . . . , nf
lb−1, with lf , lb ≤ r, where nf
In the following protocol description, we consider a source S
communicating with a destination D using forward path pf travers-
ing nodes nf
lf−1 and backward path pb traversing nodes
1, . . . , nb
0, nb
nb
lb−1 are the
nodes closest to the source. Without loss of generality, we let the
last node on the forward path nf
= D and refer to the desti-
nation by these two notations interchangeably. In general we use
dir ∈ {f, b} as superscripts to distinguish between notation refer-
ring to the forward and backward path, respectively. Finally, to
avoid redundancy, we use {symdir
|0 ≤ i ≤
ldir − 1}, where sym can be any symbol.
i } to denote {symdir
0 and nb
lf−1
i
HORNET Setup PackethopstypeHORNET Data PackethopstypeSphinx HeaderSphinx PayloadFS PayloadAHDRData PayloadEXPnonce14444.2 Initialization
0 , Rf
1,··· , Rf
1 ,··· , Rf
lb−1
lf−1
} from D to S. Rdir
Suppose that a source S wishes to establish an anonymous ses-
sion with a public destination D. First, S anonymously obtains
(from the underlying network) paths in both directions: a forward
} from S to D and a backward path
path pf = {Rf
pb = {Rb
0, Rb
denotes the rout-
ing information needed by the node ndir
to forward a packet. S
xndir
also anonymously retrieves and veriﬁes a set of public keys g
on path pdir (see Section 2.1). Note that gxD
for the node ndir
is also included in the above set (as nf
= D). Finally, S gen-
erates a random DH public/private key pair for the session: xS
and gxS . The per-session public key gxS is used by the source to
create shared symmetric keys with nodes on the paths later in the
setup phase. S locally stores
, and
uses these values for the setup phase.
, pdir(cid:111)
(xS, gxS ) ,
lf−1
(cid:110)
(cid:110)
(cid:111)
xndir
g
i
i
i
i
i
4.3 Setup Phase
As discussed in Section 3, in the setup phase, HORNET uses
two Sphinx packets, which we denote by P and P, to traverse
all nodes on both forward and backward paths and establish per-
session state with every intermediate node, without revealing S’s
network location. For S to collect the generated per-session state
from each node, both Sphinx packets contain an empty FS payload
into which each intermediate node can insert its FS, but is not able
to learn anything about, or modify, previously inserted FSes.
i
Sphinx Overview
dir that is re-randomized at each hop. Each yi
4.3.1
Sphinx [22] is a provably-secure mix protocol. Each Sphinx
packet allows a source node to establish a set of symmetric keys,
one for each node on the path through which packets are routed.
These keys enable each node to check the header’s integrity, onion-
decrypt the data payload, and retrieve the information to route the
packet. Processing Sphinx packets involves expensive asymmet-
ric cryptographic operations, thus Sphinx alone is not suitable to
support high-speed anonymous communication.
Sphinx packets. A Sphinx packet is composed of a Sphinx header
SHDR and a Sphinx payload SP. The SHDR contains a group ele-
dir is used
ment yi
as S’s ephemeral public key in a DH key exchange with node ndir
.
From this DH exchangeïij ˇN node ndir
derives a shared symmetric
key sdir
, which it uses to process the rest of the SHDR and mutate
yi
i
dir.
The rest of the SHDR is an onion-encrypted data structure, with
each layer containing routing information and a MAC. The rout-
ing information indicates to which node the packet should be for-
warded to next, and the MAC allows to check the header’s integrity
at the current node. The Sphinx payload SP allows end hosts to
send conﬁdential content to each other. Each intermediate node
processes SP by using a pseudo-random permutation.
Sphinx core functions. We abstract the Sphinx protocol into the
following six functions:
• GEN_SPHX_HDR. The source uses this function to generate two
Sphinx headers, SHDRf and SHDRb, for the forward and back-
ward path, respectively. It also outputs the symmetric keys {sdir
i },
xndir
.
each established with the corresponding node’s public key g
• GEN_SPHX_PL_SEND. The function allows the source to gener-