Oxymoron [7] applies fine grained code randomization that is
compatible with code sharing. However, page-level code random-
ization has been proven ineffective by Isomeron [24], which shows
that even leaking one page of memory may still allow a successful
ROP attack. Isomeron [24] thwarts JIT-ROP attacks by creating
execution path diversity with multiple code versions. Although
attackers can still read code, they do not know which version will
be actually executed. Therefore, the possibility of successful gadget
chain execution drops exponentially.
Another line of recent research efforts has focused on enforcing
an execute-only memory policy to prevent JIT-ROP attacks from
reading gadgets from memory [6, 13, 17, 20, 32, 51, 66, 74] This
can be achieved using page table manipulation [6], split TLBs [32],
hardware virtualization extensions [20, 21, 66, 74], or a form of
software-fault isolation [13, 51]. For instance, Readactor [20] and
Readactor++ [21] rely on the extended page table (EPT) feature
of Intel processors. In addition, they protect all code pointers by
forcing them to point to “proxy” pages that contain trampoline
code stubs. By doing so, JIT-ROP attacks that harvest code pointers
are defeated because leaked code pointers all point to non-readable
“proxy” pages that leak no further information to attackers. SECRET
provides a similar capability by using code pointer remapping with-
out relying on recompilation or special hardware features.
LR2 [14] prevents code and code pointer disclosure similarly to
our work. LR2 focuses on low-end ARM devices and confines mem-
ory reads on a certain memory range by masking load instructions.
All control flows to a function are intercepted by trampolines which
use direct jumps to relay control. LR2 operates at the source code
level, while SECRET operates directly on stripped binaries.
5.4 Dynamic Binary Instrumentation
Dynamic binary instrumentation (DBI) systems [15, 41, 59] use a
code cache to execute translated application code. Similar to shadow
code, the code cache is isolated, and indirect control transfer targets
are translated using an address mapping table. For performance
reasons, the code cache is isolated. For performance reasons, code
cache usually remains both writable and executable, which subjects
it to code corruption attacks. In contrast, shadow code is never
writable, so attackers cannot corrupt it. Recent research [65] has
shown how to secure code cache using two processes, one for code
generation and another for execution, but the technique has not
yet been incorporated into the above DBI platforms.
An important difference between a code cache, as used in DBI
systems, and shadow code is that the latter is self-contained and
executes independently, while the former requires constant orches-
tration by the DBI runtime. This orchestration requires many data
pointers in the code cache that point to critical data structures of
the binary translator, leaking the locations of both.
6 LIMITATIONS
Use of RTTI. Given our focus on COTS binaries, our ability to
identify code pointers is limited due to the lack of certain types of
information. For instance, with the help of RTTI in C++ programs,
we can reliably discover all virtual function information. When
such information is not available, however, we can only use con-
servative static analysis, relying on the direct data flow between
constructors and the new function. However, when an object is
created on the stack, the new function is not called, since memory
can be easily allocated on the stack. In such cases, SECRET cannot
detect these virtual tables. Fortunately, the majority of binaries do
contain RTTI, and most objects are allocated on the heap instead of
the stack. For code pointers involving non-virtual functions, we are
still working on further conservative techniques to improve upon
their identification.
Applicability to x86-64 platforms. Our current prototype cur-
rently supports only 32-bit x86 platforms, given the fact that it is
built on top of PSI, which only supports 32-bit systems. A few as-
pects of SECRET have been implemented and evaluated on x86_64,
as described in Sections 3.1.2 and 4.1.3. A more complete imple-
mentation requires significant implementation effort, but is not
conceptually more challenging.
DWARF information. One could argue that using DWARF in-
formation contradicts the claim of handling COTS binaries. The
DWARF information used by SECRET is not the same as the option-
ally generated debugging information, which is also emitted in the
DWARF format. The information we rely on is solely the exception
handling information located in the .eh_frame and .eh_frame_hdr
sections. This information is present even in stripped binaries, as it
is critical for exception handling in C++ programs, and even in C
programs, when stack unwinding involves stack frames of both C
and C++ code.
7 CONCLUSION
Defending against advanced code reuse attacks that take advan-
tage of memory disclosure vulnerabilities is becoming increasingly
important. To that end, breaking the ability of attackers to read
the executable memory segments of a process, or even to infer the
location of potential gadgets, can be a significant roadblock. In this
paper, we have achieved the above goal by designing and imple-
menting SECRET, which introduces two novel code transformation
techniques, code space isolation and code pointer remapping. The
former prevents read accesses to the executable memory of the
instrumented code (a protected version of an application’s original
code), while the latter decouples its required code pointers from
that of the original code. Our experimental results demonstrate that
SECRET can protect real-world COTS applications, while incurring
only a modest performance overhead.
REFERENCES
[1] 2013.
ploit.
mwr-labs-pwn2own-2013-write-up---webkit-exploit/.
MWR Labs Pwn2Own 2013 Write-up
- Webkit Ex-
http://labs.mwrinfosecurity.com/blog/2013/04/19/
[2] 2014. PSI Version 1.1. http://www.seclab.cs.sunysb.edu/seclab/psi/. (2014).
[3] Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti. 2005. Control-flow
(2013).
integrity. In CCS.
[4] Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti. 2009. Control-flow
integrity principles, implementations, and applications. ACM TISSEC (2009).
[5] Brad Antoniewicz. 2013. Analysis of a Malware ROP Chain. (Oct. 2013). http://
blog.opensecurityresearch.com/2013/10/analysis-of-malware-rop-chain.html.
[6] Michael Backes, Thorsten Holz, Benjamin Kollenda, Philipp Koppe, Stefan Nürn-
berger, and Jannik Pewny. 2014. You Can Run but You Can’T Read: Preventing
Disclosure Exploits in Executable Code. In CCS.
[7] Michael Backes and Stefan Nürnberger. 2014. Oxymoron: Making Fine-grained
Memory Randomization Practical by Allowing Code Sharing. In USENIX Security.
[8] Muli Ben-Yehuda, Michael D. Day, Zvi Dubitzky, Michael Factor, Nadav Har’El,
Abel Gordon, Anthony Liguori, Orit Wasserman, and Ben-Ami Yassour. 2010.
The Turtles Project: Design and Implementation of Nested Virtualization. In Proc.
of OSDI. 423–436.
[9] Sandeep Bhatkar, Daniel C. DuVarney, and R. Sekar. 2003. Address obfuscation:
an efficient approach to combat a board range of memory error exploits. In
USENIX Security.
[10] Sandeep Bhatkar, R. Sekar, and Daniel DuVarney. 2005. Efficient techniques for
comprehensive protection from memory error exploits. In USENIX Security.
[11] David Bigelow, Thomas Hobson, Robert Rudd, William Streilein, and Hamed
Okhravi. 2015. Timely Rerandomization for Mitigating Memory Disclosures. In
CCS.
[12] Andrea Bittau, Adam Belay, Ali Mashtizadeh, David Mazières, and Dan Boneh.
2014. Hacking Blind. In Security and Privacy.
[13] Kjell Braden, Stephen Crane, Lucas Davi, Michael Franz, Per Larsen, Christopher
Liebchen, and Ahmad-Reza Sadeghi. 2016. Leakage-Resilient Layout Randomiza-
tion for Mobile Devices. In NDSS.
[14] Kjell Bradeny, Stephen Crane, Lucas Davi, Michael Franz, and Per Larson. 2016.
Leakage-Resilient Layout Randomization for Mobile Devices. In NDSS.
[15] Derek L. Bruening. 2004. Efficient, transparent, and comprehensive runtime code
manipulation. Ph.D. Dissertation. MIT.
[16] Nicholas Carlini, Antonio Barresi, Mathias Payer, David Wagner, and Thomas R.
Gross. 2015. Control-Flow Bending: On the Effectiveness of Control-Flow In-
tegrity. In USENIX Security 15.
[17] Yaohui Chen, Dongli Zhang, Ruowen Wang, Rui Qiao, Ahmed M Azab, Long Lu,
Hayawardh Vijayakumar, and Wenbo Shen. 2017. NORAX: Enabling Execute-
Only Memory for COTS Binaries on AArch64. In Security and Privacy (SP), 2017
IEEE Symposium on. IEEE.
[18] Tzi-cker Chiueh and Fu-hau Hsu. 2001. RAD: a Compile-Time Solution to Buffer
Overflow Attacks. In ICDCS.
[19] Mauro Conti and et. al. 2015. Losing Control: On the Effectiveness of Control-
FlowIntegrity under Stack Attacks. In CCS.
[20] Stephen Crane, Christopher Liebchen, Andrei Homescu, Lucas Davi, Per Larsen,
Ahmad-Reza Sadeghi, Stefan Brunthaler, and Michael Franz. 2015. Readactor:
Practical Code Randomization Resilient to Memory Disclosure. In Security and
Privacy.
[21] Stephen Crane, Stijn Volckaert, Felix Schuster, Christopher Liebchen, Per Larsen,
Lucas Davi, Ahmad-Reza Sadeghi, Thorsten Holz, Bjorn De Sutter, and Michael
Franz. 2015. It’s a TRAP: Table Randomization and Protection against Function
Reuse Attacks. In CCS.
[22] Thurston H.Y. Dang, Petros Maniatis, and David Wagner. 2015. The Performance
Cost of Shadow Stacks and Canaries. In ASIACCS.
[23] Thurston H.Y. Dang, Petros Maniatis, and David Wagner. 2015. The Performance
Cost of Shadow Stacks and Stack Canaries. In Proceedings of the 10th ACM
Symposium on Information, Computer and Communications Security (ASIACCS).
555–566.
[24] Lucas Davi, Christopher Liebchen, Ahmad-Reza Sadeghi, Kevin Z. Snow, and
Fabian Monrose. 2015. Isomeron: Code Randomization Resilient to (Just-In-Time)
Return-Oriented Programming. In NDSS.
[25] Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehmann, and Fabian Monrose. 2014.
Stitching the Gadgets: On the Ineffectiveness of Coarse-Grained Control-Flow
Integrity Protection. In USENIX Security.
[26] Lucas Davi, Ahmad-Reza Sadeghi, and Marcel Winandy. 2011. ROPdefender: a
detection tool to defend against return-oriented programming attacks. In ASI-
ACCS.
[27] Lucas Vincenzo Davi, Alexandra Dmitrienko, Stefan Nürnberger, and Ahmad-
Reza Sadeghi. 2013. Gadge Me if You Can: Secure and Efficient Ad-hoc Instruction-
level Randomization for x86 and ARM. In ASIACCS.
[28] Solar Designer. 1997. Getting around non-executable stack (and fix). http:
//seclists.org/bugtraq/1997/Aug/63. (1997).
[29] T. Durden. 2002. Bypassing PaX ASLR protection. Technical Report. Phrack
Magazine, vol. 0x0b, no. 0x3b.
[30] Isaac Evans, Sam Fingeret, Julian Gonzalez, Ulziibayar Otgonbaatar, Tiffany Tang,
Howard Shrobe, Stelios Sidiroglou-Douskos, Martin Rinard, and Hamed Okhravi.
2015. Missing the Point(er): On the Effectiveness of Code Pointer Integrity. In
Security and Privacy.
[31] Bryan Ford and Russ Cox. 2008. Vx32: lightweight user-level sandboxing on the
x86. In USENIX ATC.
[32] Jason Gionta, William Enck, and Peng Ning. 2015. HideM: Protecting the Contents
of Userspace Memory in the Face of Disclosure Vulnerabilities. In Proceedings of
the 5th ACM Conference on Data and Application Security and Privacy (CODASPY).
325–336.
[33] Enes Göktas, Elias Athanasopoulos, Herbert Bos, and Georgios Portokalidis. 2014.
Out of Control: Overcoming Control-Flow Integrity. In Security and Privacy.
[34] Enes Göktaş, Elias Athanasopoulos, Michalis Polychronakis, Herbert Bos, and
Georgios Portokalidis. 2014. Size Does Matter: Why Using Gadget-Chain Length
to Prevent Code-Reuse Attacks is Hard. In USENIX Security.
[35] Jason Hiser, Anh Nguyen-Tuong, Michele Co, Matthew Hall, and Jack Davidson.
2012. ILR: where’d My Gadgets Go?. In Security and Privacy.
[36] Chongkyung Kil, Jinsuk Jun, Christopher Bookholt, Jun Xu, and Peng Ning. 2006.
Address Space Layout Permutation (ASLP): Towards Fine-Grained Randomization
of Commodity Software. In ACSAC.
[37] Vadim Kotov. 2014.
2014-0322).
dissecting-the-newest-ie10-0-day-exploit-cve-2014-0322/.
(Feb. 2014).
Dissecting the newest IE10 0-day exploit (CVE-
http://labs.bromium.com/2014/02/25/
[38] Sebastian Krahmer. 2005. x86-64 buffer overflow exploits and the borrowed code
chunks exploitation technique. http://www.suse.de/~krahmer/no-nx.pdf. (2005).
[39] Volodymyr Kuznetsov, Laszlo Szekeres, Mathias Payer, George Candea, R. Sekar,
and Dawn Song. 2014. Code-Pointer Integrity. In OSDI.
[40] Lixin Li, James Just, and R. Sekar. 2006. Address-Space Randomization for Win-
dows Systems.
[57] Felix Schuster, Thomas Tendyck, Liebcheny Christopher, Lucas Davi, Ahmad-
Reza Sadeghiy, and Thorsten Holz. 2015. Counterfeit Object-oriented Program-
ming: On the Difficulty of Preventing Code Reuse Attacks in C++ Applications.
In Security and Privacy.
[58] Edward J. Schwartz, Thanassis Avgerinos, and David Brumley. 2011. Q: exploit
hardening made easy. In the 20th conference on USENIX Security Symposium.
[59] K. Scott, N. Kumar, S. Velusamy, B. Childers, J. Davidson, and M. Soffa. 2003.
Retargetable and reconfigurable software dynamic translation. In CGO.
[60] Jeff Seibert, Hamed Okhravi, and Eric Söderström. 2014.
Information Leaks
Without Memory Disclosures: Remote Side Channel Attacks on Diversified Code.
In CCS.
[41] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff
Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin:
building customized program analysis tools with dynamic instrumentation. In
PLDI.
[42] the PaX team.
2001.
Address
Space
Layout
Randomization.
http://pax.grsecurity.net/docs/aslr.txt. (2001).
[43] Matt Miller, Ken Johnson, Nitin Goel, and Vanegue Julien. 2011. Intra-modular
Displacement Randomization. (2011).
[44] Ben Niu and Tan Gang. 2015. Per-Input Control-Flow Integrity. In CCS.
[45] Ben Niu and Gang Tan. 2014. Modular Control-Flow Integrity. In PLDI.
[46] Ben Niu and Gang Tan. 2014. RockJIT: Securing Just-In-Time Compilation Using
Modular Control-Flow Integrity. In CCS.
[47] Angelos Oikonomopoulos, Elias Athanasopoulos, Herbert Bos, and Cristiano
Giuffrida. 2016. Poking Holes in Information Hiding. In USENIX Security.
[48] Kaan Onarlioglu, Leyla Bilge, Andrea Lanzi, Davide Balzarotti, and Engin Kirda.
2010. G-Free: defeating return-oriented programming through gadget-less bina-
ries. In ACSAC.
[49] Vasilis Pappas, Michalis Polychronakis, and Angelos Keromytis. 2012. Smashing
the Gadgets: Hindering Return-Oriented Programming Using In-place Code
Randomization. In Security and Privacy.
[50] Mathias Payer, Antonio Barresi, and Thomas R. Gross. 2015. Fine-Grained Control-
Flow Integrity through Binary Hardening. In DIMVA.
[51] Marios Pomonis, Theofilos Petsios, Angelos D. Keromytis, Michalis Polychron-
akis, and Vasileios P. Kemerlis. 2017. kR^X: Comprehensive Kernel Protection
against Just-In-Time Code Reuse. In Proc. of EuroSys. 420–436.
[52] Aravind Prakashm, Xunchao Hu, and Heng Ying. 2015. vfGuard: Strict Protection
for Virtual Function Calls in COTS C++ Binaries. In NDSS.
[53] Manish Prasad and Tzi-cker Chiueh. 2003. A Binary Rewriting Defense against
Stack Based Overflow attacks. In USENIX ATC.
[54] Rui Qiao, , and R. Sekar. 2017. Function Interface Analysis: A Principled Approach
for Function Recognition in COTS Binaries. In Dependable Systems and Networks.
[55] Rui Qiao, Mingwei Zhang, and R Sekar. 2015. A Principled Approach for ROP
[56] Jonathan Salwan. 2012. ROPGadget. http://shell-storm.org/project/ROPgadget.
Defense. In ACSAC.
(2012).
[61] Hovav Shacham. 2007. The geometry of innocent flesh on the bone: return-into-
libc without function calls (on the x86). In CCS.
[62] Hovav Shacham, Matthew Page, Ben Pfaff, Eu-Jin Goh, Nagendra Modadugu,
and Dan Boneh. 2004. On the Effectiveness of Address-space Randomization. In
CCS.
[63] Igor Skochinsky. 2012. Compiler Internals: Exceptions and RTTI. In Recon.
[64] Kevin Z. Snow, Fabian Monrose, Lucas Davi, Alexandra Dmitrienko, Christopher
Liebchen, and Ahmad-Reza Sadeghi. 2013. Just-In-Time Code Reuse: On the
Effectiveness of Fine-Grained Address Space Layout Randomization. In Security
and Privacy.
[65] Chengyu Song, Chao Zhang, Tielei Wang, Wenke Lee, and David Melski. 2015.
Exploiting and Protecting Dynamic Code Generation. In NDSS.
[66] Adrian Tang, Simha Sethumadhavan, and Salvatore Stolfo. 2015. Heisenbyte:
Thwarting Memory Disclosure Attacks using Destructive Code Reads. In CCS.
[67] PaX Team. 2002. PaX SEGMEXEC. Technical Report.
[68] Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway, Úlfar
Erlingsson, Luis Lozano, and Geoff Pike. 2014. Enforcing Forward-Edge Control-
Flow Integrity in GCC & LLVM. In USENIX Security.
[69] Victor van der Veen, Dennis Andriesse, Enes Goktas, Ben Gras, Lionel Sambuc,
Asia Slowinska, Herbert Bos, and Cristiano Giuffrida. 2015. Practical Context-
Sensitive CFI. In CCS.
[70] Victor van der Veen, Enes Goktas, Moritz Contag, Andre Pawlowski, Xi Chen,
Sanjay Rawat, Herbert Bos, Thorsten Holz, Elias Athanasopoulos, and Cristiano
Giuffrida. 2016. A Tough Call: Mitigating Advanced Code-Reuse Attacks At The
Binary Level. In Security and Privacy.
[71] Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. 1993.
Efficient software-based fault isolation. In SOSP.
[72] Richard Wartell, Vishwath Mohan, Kevin Hamlen, and Zhiqiang Lin. 2012. Binary
stirring: self-randomizing instruction addresses of legacy x86 binary code. In
CCS.
[73] Richard Wartell, Vishwath Mohan, Kevin W. Hamlen, and Zhiqiang Lin. 2012.
Securing untrusted code via compiler-agnostic binary rewriting. In ACSAC.
[74] Jan Werner, George Baltas, Rob Dallara, Nathan Otternes, Kevin Snow, Fabian
Monrose, and Michalis Polychronakis. 2016. No-Execute-After-Read: Preventing
Code Disclosure in Commodity Software. In Proceedings of the 11th ACM Asia
Conference on Computer and Communications Security (ASIACCS).
[75] David Williams-King, Graham Gobieski, Kent Williams-King, James P. Blake,
Xinhao Yuan, Patrick Colp, Michelle Zheng, Vasileios P. Kemerlis, Junfeng Yang,
and William Aiello. 2016. Shuffler: Fast and Deployable Continuous Code Re-
Randomization. In 12th USENIX Symposium on Operating Systems Design and
Implementation (OSDI 16).
[76] Jun Xu, Zbigniew Kalbarczyk, and Ravishankar K. Iyer. 2003. Transparent Run-
time Randomization for Security. Florence, Italy.
[77] Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, Laszlo Szekeres, Stephen Mc-
Camant, Dawn Song, and Wei Zou. 2013. Practical Control Flow Integrity &
Randomization for Binary Executables. In Security and Privacy.
[78] Mingwei Zhang, Rui Qiao, Niranjan Hasabnis, and R. Sekar. 2014. A Platform for
Secure Static Binary Instrumentation. In ACM Virtual Execution Environments.
[79] Mingwei Zhang and R. Sekar. 2013. Control flow integrity for COTS binaries. In
USENIX Security.
[80] Mingwei Zhang and R. Sekar. 2015. Control Flow and Code Integrity for COTS
binaries: An Effective Defense Against Real-World ROP Attacks. In ACSAC.