Although the non-interactive protocol is simpler, using a larger value of k2 is more suitable for
IoT devices with suﬃcient memory and processing power, such as web cameras. Low-performance
or low-power devices should use the interactive protocol.
Communication complexity We calculate the number of bits that are sent in the protocol. As
we assume S generates a ﬁxed rp per D, we will only consider the size of D’s proof (and neglect
the k2 bits sent by S ).
The size of the representation of each permutation is 2(cid:96) · |2(cid:96)| = 2(cid:96) · (log (cid:96) + 1). The size of
each vector is |(s∗, e, V∗, pad)| = k1 · (2(cid:96) + 1 + (cid:96)) + 2(cid:96) ≈ 3(cid:96)k1, |(sj, πj∗, blindj)| = |(sj, πj, dj)| =
4k1(cid:96) + 2(cid:96) · (log (cid:96) + 1) ≈ 4(cid:96)k1.
The total communication complexity is approximately 4(cid:96)k1k2. For speciﬁc parameters of the
non interactive protocol, (cid:96) = 16, k1 = 2048, K2 = 128, it is about 2 MB, and for the interactive
protocol with k2 = 20 about 312 KB.
7 Proof of Concept Implementation
7.1 QR Protocol PoC
We implemented a proof-of-concept (PoC) of our maliciously secure QR protocol in python, showing
that even an unoptimized implementation is suﬃciently eﬃcient for many IoT devices. To simulate
an IoT device, we ran the device-side code on a Raspberry Pi 3 Model B [ras], and the server code
on an Intel i7-7500U 2.7GHz CPU.
We use a modulus N of size 2048 bits and (cid:96) = 16. We measure processing time of the protocol
with k2 = 20 (interactive version) and k2 = 128 (non-interactive version).
The device required 2.8 seconds of run time and 13.5 seconds of preprocessing for k2 = 128, and
0.4 seconds of run time and 2.1 seconds of preprocessing for k2 = 20. The server required about 0.5
sec to verify the k2 = 128 non-interactive proof, and about 3msec to update the counters.
22
Fig. 3. A Comparison of the numbers of users blacklisted by our scheme and by an ideal blacklisting process.
7.2 Popular Hash List Simulation
We simulated our password blacklisting scheme using three lists of frequencies of passwords that
were leaked, of users of Linkedin, Yahoo! and RockYou [BH19,Bon12,Wik19], which were of sizes
of 174M, 70M, and 33M passwords respectively.
We ran the simulation 150 times for each database. In each run of the simulation, the passwords
were hashed to random 16-bit values, and the protocol was simulated between each “user” and the
server. For supporting local diﬀerential privacy, each user’s answer was randomized with probability
v = 0.25.
We compare the success of blacklisting passwords using our scheme to the success of an ”ideal”
blacklisting of passwords which has the entire list of passwords of all users. We assume that the
server decides on a threshold t and blacklists the top t popular passwords. We measure the percent-
age of users whose password is blacklisted by the server. For our simulation, we take the median
result among the 150 runs of the simulation.
Figure 3 shows the percentage of users whose password is blacklisted, as a function of the
number t of top popular passwords that are blacklisted. The results of our simulation are compared
to those of an “ideal blacklister” which blacklists the actual t most popular passwords. Note that
due to the Zipf distribution of passwords, the utility of blacklisting each additional password is
sharply decreasing. Therefore it is only needed to examine the eﬀect of blacklisting a relatively
small number of passwords.
When blacklisting up to the t = 8 most popular passwords, the results of the simulation are
identical to the ideal blacklisting. When blacklisting more passwords, the results of the simulation
are very close to the ideal run. For example, when blacklisting the top t = 25 passwords, applying the
simulation to the Linkedin database blocked the passwords of 92% of the users whose passwords were
blacklisted by the ideal blacklister. The simulation for the smaller RockYou database blacklisted
the passwords of 86% of the users that were blocked by the ideal simulation.
8 Discussion and Open Questions
Tradeoﬀ between the QR and garbled circuit solutions: The garbled circuit solution is more
eﬃcient both in run time and in bandwidth. On the other hand, it requires an interactive protocol
and generating a new r value for each password change. The QR based protocol demands more
23
resources but has a non-interactive version that only requires the device to prepare and send a
single message to the server reusing the same r.
Implementation for the Tor Network: We believe our protocol can be useful for private statis-
tics gathering in the Tor network. This requires working with the Tor project for choosing the best
use case and adjusting and implementing the protocol in that setting.
Open question – is cryptography needed? We described a protocol for the semi-honest setting
which does not require any (complexity based) cryptographic primitives. (Namely, the server sends
r to the device, which sends back the result of the inner-product.) This protocol is secure even if
the server is malicious. However, to guarantee security against a coalition of malicious devices, our
protocol instantiations use Oblivious Transfer (OT) or public-key cryptography. The interesting
question is whether protecting against an undercount attack implies the existence of OT or other
cryptographic primitives. It is an open problem to either prove this claim or show an alternative
protocol.
Open question – how eﬀective is the data leakage? In the “Malicious Campaign” setting, we
treated the data leakage as allowing the adversary to mount an attack with a success probability
that is linear in the number of bits leaked. It is unclear if this approach can indeed be exploited.
Hence the parameters of the system may be improved. Is it possible to argue that the system
behaves better than our analysis?
References
32718.
AJL.
BDB16.
Bon12.
BS15.
California Senate Bill No. 327. Bill no. 327 information privacy: connected devices, 2018.
Andris Ambainis, Markus Jakobsson, and Helger Lipmaa. Cryptographic randomized response techniques.
In Public Key Cryptography - PKC 2004.
Jeremiah Blocki, Anupam Datta, and Joseph Bonneau. Diﬀerentially private password frequency lists.
In NDSS, 2016.
Jeremiah Blocki and Ben Harsha. LinkedIn Password Frequency Corpus. 2019.
BH19.
BNST17. Raef Bassily, Kobbi Nissim, Uri Stemmer, and Abhradeep Guha Thakurta. Practical locally private
heavy hitters. In Advances in Neural Information Processing Systems 30: Annual Conference on Neural
Information Processing Systems 2017, 4-9 December 2017, Long Beach, CA, USA, pages 2285–2293, 2017.
Joseph Bonneau. The science of guessing: Analyzing an anonymized corpus of 70 million passwords. In
IEEE SP. IEEE Computer Society, 2012.
Raef Bassily and Adam Smith. Local, private, eﬃcient protocols for succinct histograms. In Proc. of
47th STOC, pages 127–135. ACM, 2015.
National Cyber and Security Centre. Passwords, passwords everywhere, 2019.
CC19.
CLSX12. T.-H. Hubert Chan, Mingfei Li, Elaine Shi, and Wenchang Xu. Diﬀerentially private continual monitoring
CO15.
CSS.
CSS11.
of heavy hitters from distributed streams. In PETS, 2012.
Tung Chou and Claudio Orlandi. The simplest protocol for oblivious transfer. In LATINCRYPT, 2015.
T.-H. Hubert Chan, Elaine Shi, and Dawn Song. Optimal lower bound for diﬀerentially private multi-
party aggregation. In Algorithms - ESA 2012.
T.-H. Hubert Chan, Elaine Shi, and Dawn Song. Private and continual release of statistics. ACM Trans.
Inf. Syst. Secur., 14(3), 2011.
DNP+10. Cynthia Dwork, Moni Naor, Toniann Pitassi, Guy N. Rothblum, and Sergey Yekhanin. Pan-private
streaming algorithms. In Innovations in Computer Science - ICS., 2010.
DNPR10. Cynthia Dwork, Moni Naor, Toniann Pitassi, and Guy N. Rothblum. Diﬀerential privacy under continual
observation. In STOC, 2010.
DNRR15. Cynthia Dwork, Moni Naor, Omer Reingold, and Guy N. Rothblum. Pure diﬀerential privacy for rectangle
DR14.
DRV10.
queries via private partitions. In ASIACRYPT, 2015.
Cynthia Dwork and Aaron Roth. The algorithmic foundations of diﬀerential privacy. Foundations and
Trends in Theoretical Computer Science, 9(3-4):211–407, 2014.
C. Dwork, G. N. Rothblum, and S. Vadhan. Boosting and diﬀerential privacy. In FOCS, 2010.
24
EPK14.
FS86.
GGF17.
GM84.
´Ulfar Erlingsson, Vasyl Pihur, and Aleksandra Korolova. RAPPOR: randomized aggregatable privacy-
preserving ordinal response. In ACM CCS (2014), 2014.
Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identiﬁcation and signature
problems. In CRYPTO, 1986.
Paul A Grassi, M Garcia, and J Fenton. DRAFT NIST special publication 800-63-3 digital identity
guidelines. 2017.
Shaﬁ Goldwasser and Silvio Micali. Probabilistic encryption. Journal of computer and system sciences,
28(2):270–299, 1984.
HKK+14. Yan Huang, Jonathan Katz, Vladimir Kolesnikov, Ranjit Kumaresan, and Alex J. Malozemoﬀ. Amortizing
HKR12.
Hoe63.
garbled circuits. In CRYPTO, 2014.
Justin Hsu, Sanjeev Khanna, and Aaron Roth. Distributed private heavy hitters. In ICALP, 2012.
Wassily Hoeﬀding. Probability inequalities for sums of bounded random variables. Journal of the Amer-
ican statistical association, 1963.
LMD.
LP07.
LP09.
LR15.
KMRR15. Vladimir Kolesnikov, Payman Mohassel, Ben Riva, and Mike Rosulek. Richer eﬃciency/security trade-
oﬀs in 2pc. In Yevgeniy Dodis and Jesper Buus Nielsen, editors, TCC, volume 9014 of Lecture Notes in
Computer Science. Springer, 2015.
Karsten Loesing, Steven J. Murdoch, and Roger Dingledine. A case study on measuring statistical data
in the Tor anonymity network. In WECSR (2010).
Yehuda Lindell and Benny Pinkas. An eﬃcient protocol for secure two-party computation in the presence
of malicious adversaries. In EUROCRYPT, 2007.
Yehuda Lindell and Benny Pinkas. A proof of security of yao’s protocol for two-party computation. J.
Cryptology, 22(2), 2009.
Yehuda Lindell and Ben Riva. Blazing fast 2pc in the oﬄine/online setting with security for malicious
adversaries. In Indrajit Ray, Ninghui Li, and Christopher Kruegel, editors, ACM CCS, 2015.
Payman Mohassel and Matthew K. Franklin. Eﬃciency tradeoﬀs for malicious two-party computation. In
Moti Yung, Yevgeniy Dodis, Aggelos Kiayias, and Tal Malkin, editors, Public Key Cryptography - PKC
2006, volume 3958 of Lecture Notes in Computer Science. Springer, 2006.
Tal Moran and Moni Naor. Polling with physical envelopes: A rigorous analysis of a human-centric
protocol. In EUROCRYPT, 2006.
Akshaya Mani and Micah Sherr. Histor: Diﬀerentially Private and Robust Statistics Collection for Tor.
In (NDSS), 2017.
Chris Peikert, Vinod Vaikuntanathan, and Brent Waters. A framework for eﬃcient and composable
oblivious transfer. In CRYPTO, 2008.
Raspberry pi 3 model b. [Online; accessed 17-May-2017].
Peter Rindal and Mike Rosulek. Faster malicious 2-party secure computation with online/oﬄine dual
execution. In USENIX Security 16, pages 297–314, Austin, TX, 2016.
Bruce Schneier. Your WiFi-connected thermostat can take down the whole internet. we need new regu-
lations - the washington post. 2016.
Stuart Schechter, Cormac Herley, and Michael Mitzenmacher. Popularity is everything: A new approach
to protecting passwords from statistical-guessing attacks. In USENIX conference on Hot topics in security,
2010.
Madhu Sudan. List decoding: Algorithms and applications. In IFIP International Conference on Theo-
retical Computer Science, 2000.
Iain Thomson. Who’s using 2fa? sweet fa. less than 10two-factor authentication, 2018.
Salil Vadhan. The Complexity of Diﬀerential Privacy, pages 347–450. Springer International Publishing,
Cham, 2017.
Tho18.
Vad17.
ras.
RR16.
PVW08.
SHM10.
Sud00.
MF06.
MN06.
MS17.
Sch16.
WCW+17. Ding Wang, Haibo Cheng, Ping Wang, Xinyi Huang, and Gaopeng Jian. Zipf’s law in passwords. IEEE
Wika.
Wikb.
Wik19.
Yun17.
Trans. Information Forensics and Security, 12(11):2776–2791, 2017.
Wikipedia. Mirai (malware). [Online; accessed 12-May-2019].
Wikipedia. Shodan. [Online; accessed 19-May-2017].
Wikipedia contributors. Rockyou — Wikipedia, the free encyclopedia, 2019. [Online; accessed 15-August-
2019].
Moti Yung. Snapchat’s “my eyes only” secure cloud storage protocol, 2017.
25
A Frequently Asked Questions
Isn’t the password distribution already known?
As we explain in Section 1.1, the password distribution can change over time, or between
diﬀerent populations.
Can publishing the blacklist put users at risk?
As we explain in Section 1.1, this is similar to publishing new code vulnerabilities, as the only
way to help most of the users and to protect the ecosystem. Moreover, as we prevent any single
password from becoming too popular, this will actually limit the attackers’ ability to exploit
this information.
Can we use some PIR, PSI or other mechanisms to protect the blacklist of passwords?
Unfortunately no. In our analysis we assume there is a large colluding coalition, and each device
is allowed to test if its password is blacklisted or not. If this coalition is large then it might be
able to test the entire hash domain and ﬁnd all blacklisted values regardless of the protection
mechanism.
What about the users that are already using a blacklisted password?
As we note in Section 1.1, the device can alert the user if its current password is added to
the blacklist. However, this results in a security trade-oﬀ, as the change may reveal a lot of
information about the user’s previous password.
Leakage: why leaking one bit of information is ﬁne?
The password game deﬁned in Section 2.1 shows what is the eﬀect of releasing one bit of
information. Moreover, this section shows how diﬀerential privacy can be used to reduce this
eﬀect.
Is it practical to implement this protocol?
Yes! In section 7 we describe the PoC we implemented both for the device and the server sides
and for participial parameters of the scheme. A relatively weak server requires ≈ 0.5 seconds
to run the whole non-interactive proof veriﬁcation and to update the counters. A low resources
Raspberry Pi 3 Model B can prepare the proof in less than 15 seconds.
What size of the domain can be used in the real world?
The domain size does not aﬀect the security of the protocol in any way. It is just a trade-
oﬀ between communication complexity and performance on one hand, and password rejection
false positive rate on the other hand. Our PoC was done with (cid:96) = 16, which allows for good