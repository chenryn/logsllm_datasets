乍看起来，这像是一个经典的空指针引用bug，这样的话到此就可以放弃了：因为它通常是无法利用的，因为现代操作系统阻止零虚拟地址被映射。我们可以考察一下周围的代码，以便更好地了解可能发生的情况：
我们可以从这段代码中提取一些有用的信息。首先，我们注意到，崩溃发生在一个函数调用之前，它看起来像一个JavaScript函数调度器存根，这次崩溃主要是由于
**v8::internal::Builtin_FunctionPrototypeToString**
的地址被加载到该调用之前的一个寄存器中引起的。通过查看位于0x000002d167e84500处的函数的代码，我们发现地址0x000002d167e8455f确实包含一个call
rbx指令，这似乎证实了我们的怀疑。它调用Builtin_FunctionPrototypeToString这一事实的却很有趣，因为这是
**Object.toString**
方法的实现，而我们最小化的测试用例会调用它。这似乎表明，崩溃发生在Javascript函数func0的JIT编译版本中。
从上面的反汇编代码中，我们可以收集到的第二条信息是，发生崩溃时寄存器rax中包含的零值是从内存加载的。这个被加载的值好像应该作为参数传递给toString函数调用的。我们不难看出，它是从[rdi
+ 0x18]处加载的。基于此，我们可以仔细看一下相关的内存区：
这里没有发现非常有用的信息，只能看出大部分值都是指针。但是，知道这个值（它是一个指针）是从哪里加载的是非常有用的信息，因为它可以帮助我们弄清楚为什么这个值此前为零。利用WinDbg最新的Time
Travel Debugging（TTD）功能，我们可以在该位置放置一个内存写入断点（baw 8
0000025e`a6845dd0），然后在该函数的起始处放置一个执行断点，最后重新运行反跟踪（g-）。
有趣的是，我们的内存写断点并没有触发，这意味着这个内存片段在这个函数中没有被初始化，或者至少没有用到。这可能是正常的，但是如果我们借助于测试用例，例如使用o.b.bc.bca.bcab
= 0xbadc0de;行替换o.b.bc.bca.bcab = 0;行的话，我们就发发现，导致崩溃的值原来所在的内存区发生了变化：
我们看到，常数值0xbadc0de出现在该内存区域的末端。虽然这并不能证明任何事情，但是至少说明，这个内存区域可能是JIT编译的函数用来存储局部变量的。还记得前面代码崩溃的原因吗？导致崩溃的原因是加载了一个本来要作为参数传递给Object.toString的值引发的。这进一步印证了我们的这个看法。
结合TTD，我们可以进一步确认这段内存的确未被该函数初始化的事实，可能的原因是JIT编译器没有给出初始化指向用于访问o.b.ba.bab字段的对象成员的指针的代码。
为了证实这一点，我们可以使用-trace-turbo和-trace-turbo-graph参数在D8中运行测试用例。这样的话，D8就会输出TurboFan（V8的JIT编译器）任何构建和优化相关代码方面的信息。我们可以将它与turbolizer结合起来使用，可以显示TurboFan用于表示和优化代码的相关图。
TurboFan会依次对这些图实施各种优化。当优化过程经过一半，也就是在卸载优化阶段之后，将得到如下所示的代码的流程图：
显然，优化器将func0放入了无限循环中，然后从第一次循环迭代中把它拽了出来。这些信息对于了解各个代码块之间的相互关系非常帮助。然而，这种展示方式的缺点是，漏掉了对应于加载函数调用的参数的节点，以及局部变量的初始化对应的节点，但是这些信息正好都是我们比较感兴趣的。
幸运的是，我们可以使用turbolizer的界面来显示这些内容。下面我们考察第二个Object.toString调用，我们可以看到参数来自哪里，以及它被分配到哪里以及在哪里进行初始化：
（注意：需要手动修改节点标签以提高可读性）
在优化阶段，代码看起来非常合理：
分配内存块以存储本地对象o.b.ba（节点235），并初始化baa和bab字段
分配内存块以存储本地对象o.b（节点259），并且初始化所有字段，其中需要特别指出的是，ba初始化为指向前面的o.b.ba的引用
分配内存块以存储本地对象o（节点303），并且初始化所有字段
本地对象o的字段b被对对象o.b（节点185）的引用覆盖，
本地对象字段o.b.ba.bab被加载（节点199、209和212）
调用Object.toString方法，将o.b.ba.bab传递为第一个参数
在这个优化阶段中，编译的代码看起来没有表现出未初始化的局部变量行为（我们猜测这种行为是该bug的根本原因）。话虽如此，该图的某些方面可以证明我们的猜测。请看一下节点209和212，分别加载o.b.ba和o.b.ba.bab，用于函数调用参数，我们可以看到，偏移量+24和+32与崩溃代码的反汇编结果是相对应的：
0x17和0x1f的十进制值分别为23和31。考虑到V8标签的值是如何区分实际对象与内联整数（SMI）的，这一切就顺理成章了：如果一个JavaScript变量的值的最低有效位为1，则被视为指向对象的指针，否则被视为SMI。因此，V8代码在解引用的时候，作为一种优化措施，会从JavaScript对象偏移中减1。
由于我们仍然无法解释这个bug，所以还需继续考察这个优化过程。在经过Escape分析之后，图形变成下面的样子：
这里有两个显着的差异：
代码不再是加载o和o.b了——它被优化为直接引用o.b，可能是因为该字段的值从未发生变化的缘故
代码不再初始化o.b.ba；从图中可以看出，turbolizer将节点264显示未灰色，这意味着它不再活动，因此不会被内置到最终的代码中
查看这个阶段所有的活动节点，可以发现这个字段确实没有被初始化。同时，我们在这个测试用例上运行d8，并且使用–no-turbo-escape选项，以省略这个优化阶段：d8不再崩溃，从而确认这就是问题所在。这个结果表明，谷歌对这个bug的修补方法为：完全禁用v8
6.1中的escape分析，直到v8 6.2版本中的新escape分析模块就绪为止。
现在，我们已经清楚了这个bug的根本原因，下面我们要做的就是寻找相应的利用方法。虽然这个bug看上去非常强大，但实际上它完全取决于我们对未初始化的内存片段的控制能力，以及最终的利用方式。