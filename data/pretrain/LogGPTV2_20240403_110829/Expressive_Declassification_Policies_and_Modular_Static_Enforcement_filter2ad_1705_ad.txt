may be used. For our main result, we simply assume
that valid pre-assertion and relational correctness are
checked soundly.
What we need about typing is the following.
Lemma 6.3 (typing): (a) If h C , s i → h C 0, s 0 i
and C is typable then C 0 is typable, indeed, the assign-
ment of types to constituent commands is maintained.
(b) If the active command in C is low and is not a
declassiﬁcation, and h C , s i → h C 0, s 0 i, and t ∼ s,
then there exists t 0 with h C , t i → h C 0, t 0 i and
t 0 ∼ s 0. (c) If the active command of C is high and
h C , s i → h C 0, s 0 i then s ∼ s 0. (d) If Γ ` C : H then
C always terminates and every constituent command
of C is also typed high.
Type checking and assertion checking potentially
involve the whole program, but in both cases each
subprogram can be checked separately, using types or
speciﬁcations for other program units. The relational
correctness checks are modular in a stronger sense:
they apply only to declass commands.
7. Soundness
This section is devoted to proving the following.
Theorem 7.1: Suppose M is
statically secure
(Def. 6.2). Then it has the conditioned gradual release
property (Def. 5.5).
To connect the static analysis with CGR we need a
simulation-style characterization of the situation where
an additional observed state does not increase knowl-
edge. The main deﬁnitions (Section 5) work at the level
of traces and low-observable distinctions on traces. But
to show soundness of the enforcement r´egime we need
a ﬁner analysis in terms of pre-runs.
For traces σ, τ with generating pre-runs S and T ,
indistinguishability can be characterized using a notion
which resembles the instantiation of a simulation,
matching up the low parts of S and T .
First, a supporting deﬁnition. If the active command
of C is typed high then the L-continuation of C , writ-
ten Lcont (C ), is the command D such that C = B ; D
where B : H and D : L. (The active command may be
all or part of B .) Here we allow that D may be empty.
Deﬁnition 7.2 (correspondence): Suppose S and T
are pre-runs and let dom(S ) be the set of indices,
{0, . . . , last (S )}, of S . A correspondence from S to T
is a relation Q ⊆ dom(S ) × dom(T ) such that 0 Q 0
and for all i, j with i Q j the following hold:
1) (state agreement) state(Si ) ∼ state(Tj )
2) (level agreement) actc(Si ) : L iff actc(Tj ) : L
3) (code agreement L) code(Si ) = code(Tj ) if
actc(Si ) : L
4) (code
agreement H) Lcont (code(Si )) =
Lcont (code(Tj )) if actc(Si ) : H
5) (monotonicity) if i Q j , i  {
int id; boolean committed; int vsn;
String{alpha} diag;
String{beta} notes;
PatientRecord{L} next; }
Note that now the levels of diag and notes are type
parameters (level polymorphism like this is available in
Jif and similar security type systems [31], [33]). Patient
12
records are linked by the next ﬁeld, which itself is low
—for clarity we have made that label explicit. (Recall
from Sect. 2 that the unmarked default is L.) We are
assuming that diag and notes contain secret values, so
a sensible declaration and (noninterferent) assignment
to obtain the list of records is
root := db.lookupAll();
where root: PatientRecord{L}. To ob-
tain a list of records in which the diagnoses have
been declassiﬁed, it would be possible to clone the
list, iteratively performing a declassiﬁcation like that
in Sect. 2. In fact, such cloning is done extensively in
Jif case studies [3], in order to avoid laundering attacks
whereby ﬁelds are updated with high info subsequent
to their declassiﬁcation, via high aliases into the data
structure.
If in fact there are no exploitable aliases, cloning is
costly and unnecessary. We would like to release the
entire list of patient records by a single assignment:
newRoot := root;
where newRoot: PatientRecord{L}.
This will be rejected by the typechecker owing to the
types of root versus newRoot . But it can be made a
declassiﬁcation, subject to a ﬂowspec like this:
ﬂow pre ISOL(root ) &
A(root ) ∧ A(root .next ∗.diag)
mod newRoot , newRoot .next ∗.diag
The agreement precondition says that what is released
is the diag ﬁeld of all the records. The state predicate
ISOL(root ) is intended to say that the records are
reachable only via root . This property is well studied in
the literature on ownership for heap encapsulation [12].
For present purposes, we need transferrable ownership,
which can be expressed and enforced by certain type
systems and program veriﬁers [7], [23].
The modiﬁes clause reﬂects
that giving type
PatientRecord{L} to newRoot effec-
tively changes the type of all the records (owing to the
declared type of next ). Thus the relational correctness
condition for static security, Def. 6.2(3), will specify
agreement on all the reachable diag ﬁelds —and this
will follow from the agreement precondition.
In summary,
the extension of our enforcement
r´egime to declassiﬁcation of data structures adds a
requirement on ﬂowspecs, namely the isolation pre-
condition which must then be proved as a valid pre-
assertion.
9. Related work
Sabelfeld and Sands [29] systematically analyze