source, we opt for a black-box approach, developing a testbed
of various EPUBs which, upon loading, instruct the EPUB
Fig. 2. Overview of our experimental design. The various EPUB ﬁles that
make up our testbed are manually loaded in the tested reading system. If
remote communication is available, the results are automatically submitted
to a web server, which will store it in the database. Alternatively, these are
manually copied from the e-book.
reading system to run embedded experiments. Because of the
high variety of reading systems, both in terms of the platform
they are run on as well as the functionality they provide
and their user-interface, we deemed it infeasible to perform
a fully automated evaluation while maintaining completeness.
Instead, we opted for a semi-automated approach, where we
use JavaScript code to render the results of our experiments in
the reader, or, if possible, send these to a remote web server.
As such, the manual effort is limited to copying this output
from the EPUB reader into a ﬁle that can be further evaluated
by our analysis framework. An overview of our experimental
design can be found in Figure 2.
Supported by this setup, we aim to evaluate the presence
of certain “primitives” that are required to launch attacks. For
instance, in order to leak the contents of a ﬁle on the local ﬁle
system, an attacker requires the ability to render content from
local ﬁles, execute JavaScript code, and ﬁnally send remote
requests. For every primitive functionality, our testbed uses a
separate EPUB ﬁle that tests its presence. The reason for this
is that EPUB reading systems label certain EPUBs as corrupt
when these try to execute unsupported functionality. Several
experiments rely on speciﬁc functionality such as JavaScript
execution; when this functionality is not present, the associated
experiments can be omitted. The decision on which experiment
to perform next is each time imposed by our testbed protocol.
We used the ofﬁcial EPUB Validation Tool [59] provided
by W3C to validate conformance with the standard. To accom-
modate all EPUB reading systems, the embedded JavaScript
uses ECMAScript 5 functionality because the more recent
ECMAScript 6 is not widely supported among reading systems.
We have publicly released all code required to construct this
testbed of EPUBs.2
In the rest of this section we discuss all features that were
evaluated, an overview is depicted in Figure 3.
1) JavaScript execution: Because most reading systems do
not disclose whether JavaScript is supported, which is indeed
an optional feature in the EPUB speciﬁcation, this information
2https://github.com/DistriNet/evil-epubs
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:25 UTC from IEEE Xplore.  Restrictions apply. 
1733
textual ﬁles (.html, .txt, .log, .bogus), images (.png, .jpg), audio
(.mp3), video (.mp4) and fonts (.ttf). In an attempt to bypass
the potentially restrictive direct access to the local ﬁle system,
we do not only refer to the resource through its absolute
path (file:// protocol), but also leverage relative symbolic
links. For UNIX systems, we were able to enclose correctly
functioning symbolic links pointing to a ﬁle and folder in
the ZIP ﬁle, which is essential for embedding them in an
EPUB. We did not ﬁnd a way to reproduce this on Windows.
These experiments were considered successful only when the
obtained information could be leaked to a remote server (see
Experiment IV-A3).
In the ﬁrst set of experiments, the EPUB attempts to render
the local user ﬁles by simply including them by means of an
iframe, img, audio or video element, or by assigning a
CSS font-family to include a font. When such a resource
is rendered, it is trivial to conﬁrm its existence on the local ﬁle
system. For iframes and images, an observable load event is
ﬁred when the subresource was successfully loaded. Similarly,
on audio and video elements the canplaythrough event
is ﬁred. Although no such event exists for fonts, existence of
font ﬁles can be inferred by leveraging canvas elements to
check whether the referred font has been applied to a text box.
The second set of experiments aims to determine whether
the content of local resources can be accessed through the
XMLHttpRequest and Fetch API [43], [47] or by leveraging
content-speciﬁc methods. For textual resources, the EPUB tries
to access the rendered content within an iframe through its
contentWindow attribute. Images, on the other hand, can
be encoded in the base64 format through the toDataURL
functionality of the canvas element. However, when reading
systems use a unique domain to host the EPUB’s content, as
is recommended by the speciﬁcation [2], the SOP disallows
access to the content of the referred resource. Again, here
we can leverage symbolic linking to make it appear as if the
referred content is hosted on the same domain.
Well-secured EPUB reading systems will prevent the EPUB
from rendering local ﬁles and leaking their content, however,
we might still be able to leak the existence of a particular
ﬁle by leveraging timing attacks. This was evaluated in an
additional experiment, by measuring the time between setting
the src attribute of an image element and the ﬁring of the
onerror event, for both a URL of an existing ﬁle and a
non-existing ﬁle. In every experiment, this measurement was
performed 20,000 times, alternating the sequence order of the
existing and non-existing ﬁle to reduce potential noise. When
in a signiﬁcant portion of these cases the measured time was
larger for the existing ﬁle than for the non-existing ﬁle, or vice-
versa, we consider a timing attack to be viable. For all such
labeled reading systems, this calculated accuracy was at least
95%, except for two reading systems where we measured an
accuracy of about 75%. However, in all cases the accuracy can
be increased by performing multiple measurements. On MacOS
and Linux, we used a ﬁlesystem in user space (FUSE) [50] in
advance to determine whether the local ﬁlesystem is accessed
in an attempt to read out the ﬁle.
Fig. 3. Overview of the different EPUB experiments. In order to assess certain
features (red) of the reading system, we used several experiments (rectangular),
both with (yellow) and without (white) JavaScript; these experiments are
grouped by category (blue).
needs to be obtained empirically. JavaScript support might
be an important trait to the user, e.g. to support interactive
EPUBs, but even more so to a potential attacker, considering
the substantially increased threat surface. That is, through
JavaScript a multitude of different APIs become available,
which could be used to request local or remote resources, or
even access user media devices (MediaDevices API [45]).
We test three different ways of how JavaScript can be
included in an EPUB: (i) directly embedding code with a
 tag in an XHTML ﬁle (inline), (ii) reference a
separate JavaScript ﬁle within the EPUB by setting the src
attribute of  tags (external), and (iii) reference a
JavaScript ﬁle hosted on an external web server (remote). All
three approaches were evaluated by dynamically changing the
content of a visible HTML element through inline, external or
remote JavaScript code. When the content of such an element
assumed the dynamically assigned value over the original value,
we could safely assume that JavaScript was executed.
2) Local ﬁle system access: The EPUB speciﬁcation allows
reading systems to support references to certain types of
resources on the local ﬁle system, explicitly mentioning audio,
video and fonts, but also any resource retrievable by a script [1].
JavaScript-supporting reading systems that implement this
optional feature may implicitly grant every EPUB the ability to
retrieve ﬁles from the user’s operating system. Even when the
SOP is enforced to prevent content leaking, as is recommended
by the speciﬁcation [2], a malicious EPUB might still be able
to gather sensitive information such as the presence of certain
ﬁles, or even the user’s account name.
For this evaluation, we performed three sets of experiments
in which the EPUB attempts to access ﬁve types of resources:
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:25 UTC from IEEE Xplore.  Restrictions apply. 
1734
Inline JSExternal JSRemote JSJavaScriptsupportyesyesJSsupport?yesRenderlocal ﬁle?XHRFetchJS requestAPIsiframe ﬁle://img ﬁle://font-familiyﬁle://DOM localﬁle accessContentextractioniframecontentWindowcanvastoDataURLLeaklocal ﬁles?Remotecomm.?DOM elementscookieslocalStorageStorage mechanismsPersistentstorage?FeatureaccessMediaDevicesAPIBackgroundactivity?URI schemesCan accessmedia dev?Protocolhandlers?click()...Browserengine?3) Remote communication: Similar to the local resource
access discussed in the previous section, the EPUB speciﬁca-
tion allows reading systems to support references to online
resources for certain resource types [1], implying that remote
communication with a server is possible. However, the standard
also acknowledges the security implications produced by this
trait and advises reading system developers to explicitly notify
users of network trafﬁc, and ideally, even request user consent
in advance [2]. Indeed, this capability is essential for relaying
sensitive information to a tracker, or for receiving instructions
from an attacker.
In this experiment, we investigate whether an EPUB is
able to communicate with remote servers while it is opened
by the reading system, and whether the user is notiﬁed of
the occurring network trafﬁc. Various HTML tags can be
used to initiate HTTP requests, and in an attempt to be
exhaustive we leveraged the comprehensive collection on the
HTTPLeaks GitHub repository [25], in combination with the
XMLHttpRequest and Fetch API [43], [47]. When any of these
requests reaches the remote server, we label the EPUB reading
system as supporting remote communication. As we manually
load the crafted EPUBs in the readers, we also take note of
any request for consent that was presented to the user.
4) Persistent storage: In modern browsers, websites have
access to various mechanisms to store data locally, such as
cookies and the LocalStorage API [33]. Again, EPUB reading
systems might inherit this functionality to provide storage
capabilities to EPUBs. The EPUB speciﬁcation rightfully
recommends reading system developers to treat all stored data
as sensitive, preventing other documents from accessing.
In these experiments, we ﬁrst determine whether the EPUB
reading system supports persistent storage through one of the
two mechanisms. Since reading systems might merely provide
the API, neglecting the persistence trait, we evaluate whether
the stored information persists after closing the EPUB reading
system. To adequately validate inter-session persistence, we
start an initial session by opening the crafted EPUB. After
rendering is complete, we close the reading system, thereby
ending the ﬁrst session. Finally, by reopening the same EPUB
ﬁle and starting a second session, we inquire whether any
cookies or LocalStorage entries have remained.
In an additional experiment, we check compliance with the
recommendation to isolate this data from other documents. For
this, we use different EPUBs in subsequent sessions, validating
whether a modiﬁcation by the ﬁrst EPUB is detectable by the
second.
5) Feature access: Modern browsers allow websites to
request access to features, such as the user’s geolocation,
microphone and webcam [20], [51]. When such access is
requested, the browser will ask the user for consent to allow
the website to access the indicated resource. We did not ﬁnd
any occurrence of these mechanisms in the EPUB speciﬁcation,
however, since most EPUB reading systems rely on browser
engines,
this functionality is inherited.
Because access to these media devices could allow an EPUB to
record the user’s surroundings or determine the user’s location,
is possible that
it
it proves a tempting target for a potential attacker.
In this experiment, we evaluate whether the GeoLocation
and MediaDevices API are made available in EPUB reading
systems, and if so, whether user consent is required.
6) URI schemes: On the Internet, resources are referenced
through Uniform Resource Identiﬁers (URI), of which most
rely on the http: or https: protocol. However, by using
custom URI schemes, websites can also instruct the browser to
open applications upon activation of the URI (e.g. by clicking a
hyperlink), even passing on arguments in the URI. For instance,
the mailto: scheme is often employed to refer to an e-mail
address, and when activated, will open the operating system’s
default mail application [29]. Whereas the mailto: scheme
is one of the ofﬁcial URI schemes issued by the Internet
Assigned Numbers Authority (IANA) [16], there are also many
non-registered schemes used in practice.
To prevent misuse, modern browsers generally request
conﬁrmation from the user to initiate another application. This
precaution is considered critical as URI links can be activated
without any user interaction, e.g.
through the click()
function in JavaScript. Depending on the security considerations
of a referred application, leveraging the arguments of such an
activation could initiate a phone call, send a mail or download
a ﬁle, facilitating various attacks by respectively exposing a
user’s phone number or e-mail address, or downloading a
malicious payload.
In this experiment, we investigate whether EPUB reading
systems support initiation of applications through URI schemes,
and if so, whether the reader requested permission from the
user for this action.
7) Browser engine evaluation: Considering that browser
engines require regular patching to ﬁx security bugs, disclosed
vulnerabilities could be abused to target reading systems with
an outdated browser engine.
In this experiment, we explore browser engine use in
EPUB reading systems by evaluating whether the embedded
browser engine is outdated and insecure. While at ﬁrst sight
consulting the user-agent string poses a straightforward solution,
this information might not correctly represent the underlying
browser engine. For instance, reading systems could have
modiﬁed it, and WebKit has stopped updating the user-agent
string altogether [61]. Therefore, we identify the embedded
browser engine version by ﬁngerprinting browser engines based
on supported features, leveraging MDN’s browser compatibility
dataset [44]. Such a ﬁngerprint is constructed by evaluating
support for each HTML element, attribute and JavaScript API
present in the MDN dataset. This way, we collected almost 100
distinct ﬁngerprints from applications whose embedded browser
engine is known, and subsequently used those to determine the
embedded browser engine of the reading systems. A browser
engine is marked insecure if its age has surpassed at least three
years, and if any vulnerabilities are publicly disclosed.
8) Background activity: To facilitate multi-tasking, mobile
applications retain operation for a short time after focus is lost
(e.g. when the user switches to another app), depending on the
application’s conﬁguration. However, to improve battery life
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:25 UTC from IEEE Xplore.  Restrictions apply. 
1735
EVALUATION RESULTS FOR EPUB READING SYSTEMS ON WINDOWS.
TABLE I
Application
JavaScript
Local
Remote
Existence
Local Resources
Render
Leak
Remote
communication
Persistent storage
Cookies
LocalStorage
Features
URI handles
Insecure
engine
Ʃ
Ʃ
‡
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
Ƭ: .mp4 ﬁle
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)§
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)†
(cid:35)
(cid:35)
(cid:35)
Ƨ: .ttf
(cid:35)
-
-
-
-
-
-
(cid:32)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
-
-
-
-
ƭ Ʃ o
ƫ Ƭ
ƭ Ʃ o q n ƫ Ƭ Ƨ
ƭ Ʃ o q ƫ Ƨ
Adobe Digital Editions (4.5.10)
Bibliovore (2.0.2.0)
BookReader (1.6.0.0)
Bookviser Reader (6.8.1.0)
Calibre (3.40.1)
(4.3.0)∗
CoolReader (n/a)
EPUB File Reader (1.5)
FBReader (0.12.10)
Freda (4.21)
Icecream Ebook Reader (5.19)∗
Liberty (1.0.0.13)
MS Edge (44.17763.1.0)
Nook (1.10.1.15)
Overdrive (3.8.0)
SumatraPDF (3.1.2)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
Ʃ: .png/.jpg ﬁle
ƭ: .html ﬁle
∗ Only executes inline JavaScript.
† Requires user consent.
‡ Additionally renders textual ﬁles (.html, .txt), images (.png, .jpg), audio and video residing on a connected network share.
§ Allows EPUB to open URL in default browser.
-
-
-
-
-
n: .bogus ﬁle
-
-
-
q: .log ﬁle
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:32)
(cid:35)
(cid:32)
(cid:35)
o: .txt ﬁle
ƭ Ʃ o q
ƭ Ʃ o q
ƭ Ʃ o q
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
ƭ Ʃ o
ƭ Ʃ o
ƫ Ƭ
Ƨ
ƫ Ƭ
Ƨ
ƫ Ƭ
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
ƫ: .mp3 ﬁle
and memory consumption, mobile platforms impose restrictions