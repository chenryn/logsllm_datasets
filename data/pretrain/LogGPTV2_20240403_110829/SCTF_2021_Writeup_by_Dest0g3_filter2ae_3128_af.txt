            return tmp^a;
        else if(b == 4)
            return gfmultby(tmp, 2);
        else if(b == 8)
            return gfmultby(gfmultby(tmp, 2), 2);
        else if(b == 9)
            return gfmultby(gfmultby(tmp, 2), 2)^a;
        else if(b == 10)
            return gfmultby(gfmultby(tmp, 2), 2)^tmp;
        else if(b == 11)
            return gfmultby(gfmultby(tmp, 2), 2)^tmp^a;
        else if(b == 12)
            return gfmultby(gfmultby(tmp, 2), 2)^gfmultby(tmp, 2);
        else if(b == 13)
            return gfmultby(gfmultby(tmp, 2), 2)^gfmultby(tmp, 2)^a;
        else
            return gfmultby(gfmultby(tmp, 2), 2)^gfmultby(tmp, 2)^tmp;
    }
    void aes::InvMixColumns(unsigned char (*state)[4])
    {
        int i, j, k;
        unsigned char output[4][4] = {{0}};
        for(i = 0; i decryption_cbc(enc+i, plain+i);
            if(i == 0)
                cry->xor_iv(plain+i, iv);
            else
                cry->xor_iv(plain+i, enc+(i-16));
        }
        for(int i = 0; i 
    #include 
    unsigned int k[] = {0x21667463, 0x735F6F74, 0x5F656D6F, 0x636C6557}; 
    //unsigned char s[] = {0x7F, 0xF4, 0xB3, 0xD0, 0x25, 0x45, 0x0E, 0x60, 0x00, 0xFD, 0xB8, 0xC7, 0x80, 0x6F, 0x3F, 0xD0};
    //unsigned char s[] = {0xa5, 0x5b, 0x93, 0xfb, 0x44, 0x98, 0x88, 0x2c, 0x22, 0x53, 0x22, 0x7e, 0xa, 0xf3, 0xcc, 0xbb};
    unsigned char s[] = {0xdb, 0x7c, 0x93, 0x4f, 0x6a, 0x56, 0xc5, 0x16, 0x4d, 0xe0, 0x55, 0xf7, 0x99, 0x27, 0xa, 0xf6};
    char x[] = "sctf";
    int main(void)
    {
    /*    srand(0x53435446);
        for(int i = 0; i > 5)+k[0])^(b+sum)^((b > 5)+k[2])^(a+sum)^((a > 5)+k[0])^(d+sum)^((d > 5)+k[2])^(c+sum)^((c > 5)+k[2])^(a+sum)^((a > 5)+k[0])^(b+sum)^((b > 5)+k[2])^(c+sum)^((c > 5)+k[0])^(d+sum)^((d << 4)+k[1]))^tmp;
            sum -= 0x73637466;
        }
        printf("%#x, ", a);
        printf("%#x, ", b);
        printf("%#x, ", c);
        printf("%#x, ", d);
    }
## Crypto
###  cubic
扩展维纳攻击分解n得到p q，根据一般群阶p-1，复数群阶$p^{2}-1$，推导该群阶为$p^{3}-1$，直接求逆得d进行解密
    from Crypto.Util.number import *
    from gmpy2 import invert
    from z3 import *
    #c =(166431982461794383404765894353564652417286281286845040815812696140245010936597690881728163044999563295606777822589599719988749943986277241768406486432942976971806090294723679213709276119783333317719736480695779056909005344748713312922208943911234004090154620267867923985496066206993388826848408016113230559895319140692117846347161636934408901418900660630848238252785792937558161125236263657446105045318374541989968623804546523311550966511721989817712979188863096534909514606855128351038197938270797429538803633123512162732858973784140131107258309968348721003718514188938837464306149466871073659419970807525573186177295974780597677202177278450017235952741828648411332753623971689087414338005032425283018127420482524353019039589883070439499816602536780385008119304807415943660538320547325663679105882323899559945539040614335041356182742492246188685166079997529059728431638477119368978924088838246744082322934215253952260604000, 583811541976786499144377377934025235584387131534635007022251365145942422227051060939985851484706210836767096516219672713844985063110538384884200155176672559391335026702801538941879468724743394010709887016418730105669706000795612301487140087279830678314909581314560039721638176230206155638477025095967507768951649990761591795801514872889641096293748540210199152367695575307597602483917419532171797268649128704295643514700599003974515092476985280147122085743107678260804403848731411523152508976557299100005180707794868709825610527244045712157278351329970986028569553983677992653806577740248777743401724460474149400544970284499843498104577389527968551869656641095498167438798405641085540418812727789234175230571563718616654865504708574325812468631975439864831103170397966449939536937839005435391565163846769907939906973391750780003117155026788680288079657919663977842795793378060965920997621456965471449613549935486637988132751)
    #pad =117974859274346072583739577879237661359633939326177996925545772649078598610987301667759912933925662285927802009264196767594856451275711699740105534472053429854738915648249617679338619108159296653886787677835343872851980353011790571950727888130983528711607533379553800325336063577707548506215714783818842480239
    #e1 = 2816364923215542703181103700546313680109699436794123566226755921623782970809742716991858902522746028156003630828900076158585411663702115647361928930336417992964232866389633747914430575706682691181456229019202935906062908587609722493361057620793975135051750614902337992567625486243873224234033256269675850528518211544253411469959902538438091955199793022342556708413965433779350671626129791137318004869160747756926534289668211426638719794731091512998036558584096298208598924494265349419704363061401758956080768587013310392993665629098212668360357545504145264857268152702858316846654320106999264941629532500605382044391
    #e2 = 7688844608122166688554531210042890906331317367269721882913839185271394937163082744925864177779002472233203611799817777199710838582026800408107353934895515601449211254844714968565944446477081395969750472765835932266965229128856452781816269289992832230947973758915003020471524086758777628035741239238359503130190607998292797906572873297770527569698066692949759789487870533498458377873270494530630801359434977962847044065574759512179511120769361043269784870586239376868814910804487324802261815900392837165247623551114275644333697133133053782070322628235841247238848243632844856346687843129893451542644093889516093928419
    #N  = 10601906187740216931595985813561018154094349391814625467866276039997784519775353384474319150269738230372047308386421763681496742534415560601792743087606061049915679247822012183530512682920721493867744110943536891780424477404764918611971479616608837196312314759612406032833626939153217353695263399529371219150113614077103843371902911156062855363330555112519824288646026162760935051435028546568477902038113029695080397072016581518542586165205453807211236256185776189563790278426435009592437384840461159406810098763820921285305532960357029603792366631504440047476973500179551679652666963735985418083518134488043693919959
    #a  = 0.356#731./2049
    #M1=N**0.5
    #M2= N **(a+1)
    #D = diagonal_matrix(ZZ,[N,M1,M2,1])
    #M=matrix(ZZ,[[1,-N,0,N**2],[0,e1,-e1,-e1*N],[0,0,e2,-e2*N],[0,0,0,e1*e2]])*D
    #L=M.LLL()
    #t=vector(ZZ,L[0])
    #x=t*M**(-1)
    #phi = int(x[1]/x[0]*e1)
    #print(phi)
    #s = Solver()
    #p=Int('p')
    #q=Int('q')
    #s.add(p*q == 10601906187740216931595985813561018154094349391814625467866276039997784519775353384474319150269738230372047308386421763681496742534415560601792743087606061049915679247822012183530512682920721493867744110943536891780424477404764918611971479616608837196312314759612406032833626939153217353695263399529371219150113614077103843371902911156062855363330555112519824288646026162760935051435028546568477902038113029695080397072016581518542586165205453807211236256185776189563790278426435009592437384840461159406810098763820921285305532960357029603792366631504440047476973500179551679652666963735985418083518134488043693919959)
    #s.add((p-1)*(q-1) == 10601906187740216931595985813561018154094349391814625467866276039997784519775353384474319150269738230372047308386421763681496742534415560601792743087606061049915679247822012183530512682920721493867744110943536891780424477404764918611971479616608837196312314759612406032833626939153217353695263399529371219149907244546504287005803482157028158074361894837406690284282849804962647074137779175591115328533588303073897939953060596832041619446744193574226011368389348902367198191084032689790313003404759414296565690419913481077396162900768249534438395618483441070907431902912073411573833342021889020103616571648206308514880)
    #if s.check() == sat:
    #    print(s.model())
    def add(P, Q, mod):
        x1, y1 = P
        x2, y2 = Q
        if x2 is None:
            return P
        if x1 is None:
            return Q
        if y1 is None and y2 is None:
            x = x1 * x2 % mod
            y = (x1 + x2) % mod
            return (x, y)
        if y1 is None and y2 is not None:
            x1, y1, x2, y2 = x2, y2, x1, y1
        if y2 is None:
            if (y1 + x2) % mod != 0:
                x = (x1 * x2 + 2) * inverse(y1 + x2, mod) % mod