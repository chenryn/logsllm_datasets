title:SoK: SSL and HTTPS: Revisiting Past Challenges and Evaluating
Certificate Trust Model Enhancements
author:Jeremy Clark and
Paul C. van Oorschot
2013 IEEE Symposium on Security and Privacy
Revisiting past challenges and evaluating certiﬁcate trust model enhancements
SoK: SSL and HTTPS:
Jeremy Clark and Paul C. van Oorschot
School of Computer Science
Carleton University, Canada
{clark,paulv}@scs.carleton.ca
Abstract—Internet users today depend daily on HTTPS for
secure communication with sites they intend to visit. Over
the years, many attacks on HTTPS and the certiﬁcate trust
model it uses have been hypothesized, executed, and/or evolved.
Meanwhile the number of browser-trusted (and thus, de facto,
user-trusted) certiﬁcate authorities has proliferated, while the
due diligence in baseline certiﬁcate issuance has declined. We
survey and categorize prominent security issues with HTTPS
and provide a systematic treatment of the history and on-going
challenges, intending to provide context for future directions.
We also provide a comparative evaluation of current proposals
for enhancing the certiﬁcate infrastructure used in practice.
Keywords-SSL; certiﬁcates; browser trust model; usability.
I. INTRODUCTORY REMARKS
Enabling end users to easily communicate sensitive data
online was a signiﬁcant milestone in the development of
today’s web, and, arguably, a necessary condition for its
explosive growth. Little-changed since its early days (1994–
2000), the core SSL/TLS technology persists as the basis
for securing many aspects of today’s Internet
including
software download, data transfer, user passwords, and for
site authentication. While centred on the HTTPS protocol
(HTTP over SSL/TLS), its security services—conﬁdentiality,
message integrity, and site authentication—fundamentally
rely on the correct interplay of out-of-band infrastructures,
procedures, and trust decisions.
While the web has moved from serving static information
pages to one which is relied on for billions of dollars of
commerce and for supporting critical infrastructures, there
has been an erosion of conﬁdence in the HTTPS certiﬁcate
infrastructure for multiple reasons, e.g., increasing issuance
of server certiﬁcates through fully-automated (domain val-
idated) procedures, a proliferation of certiﬁcate authorities
(CAs) which may either directly issue site certiﬁcates or
certiﬁcates for other CAs, and the compromise of real-world
CAs leading to increased concern amongst security experts
of real-world man-in-the-middle (MITM) attacks on HTTPS.
SSL/TLS has evolved in response to the discovery of
cryptographic weaknesses and protocol design ﬂaws. Prob-
lems with the certiﬁcate model appear to be more chal-
lenging, including among others: design and implementation
Extended version available [32].
issues in the CA/Browser (CA/B) trust model leading to
fragility (compromise of a single CA can, at least tem-
porarily, undermine system-wide security) and lack of trust
agility, poor support for certiﬁcate revocation, a reduction
in CA diligence in certiﬁcate issuance, and user interface
challenges related to reliably signalling to end-users,
in
ways not ignored or spoofed, security indicators and site
authentication information.
In this paper, we provide a broad perspective of the
SSL/TLS (henceforth TLS) mechanism, as employed with
web browsers for securing HTTP trafﬁc. We consider
HTTPS,
the underlying CA infrastructure, CA/B trust
model, and proposed enhancements. Among many important
HTTPS-related topics beyond our main focus are: phishing,
performance enhancements, use of certiﬁcates for client-
authentication, and the use of TLS beyond securing HTTP.
Our main contributions are the following: (1) We classify
and put into a broader context disparate contributions on
HTTPS security, spanning elements of cryptographic de-
sign and implementation, systems software, operations, and
human factors. (2) We provide a comparative evaluation
of existing proposals to enhance security aspects of the
CA/B model, deconstructing and evaluating their core ideas.
(3) Building on this contextual review, classiﬁcation, and
analysis, we summarize open problems and future research
directions. In addition, by systematic discussion of security
issues in a single place, we hope to provide perspective based
on the hindsight of a multitude of historical problems. Our
work highlights the overall complexity, including algorithms,
protocols, infrastructure, conﬁguration, and interfaces, and
contributes an overall understanding of which issues are
addressed by which enhancements and protocol revisions.
II. BACKGROUND
Historical Objectives: SSL was developed to address
Netscape’s needs for securing web trafﬁc, and speciﬁcally
designed to work well with HTTP [84]. Network protection
of data like credit card details sent from client to server
motivated two major design goals: conﬁdentiality, and server
authentication—sensitive data should be released only to
a party one would ‘intend to do business with,’ i.e., the
© 2012, Jeremy Clark. Under license to IEEE.
DOI 10.1109/SP.2013.41
511
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:35 UTC from IEEE Xplore.  Restrictions apply. 
correct web server.1 Client authentication was an optional
third goal, however the credit card number largely replaced
user identity. Even today, while TLS supports client-side au-
thentication, this feature is little-used on the public internet;
we do not consider it at length herein.
As Netscape intended SSL to be a core technology beyond
use with HTTP alone, and since most high-runner internet
protocols ran over TCP, SSL was designed to provide a gen-
eral channel that can be adopted with minimal modiﬁcation
by almost any TCP-based protocol seeking some security.
An important property was termed transparency: “the data
that one end writes is exactly what the other end reads [84].”
Protocol Speciﬁcation: HTTPS combines the network
protocol HTTP with the cryptographic protocol TLS. The
TLS protocol (v1.0, 1.1, 1.2) updates the older public
SSL protocol (v3.0). TLS provides a secure tunnel to a
server, which is most commonly authenticated by an X.509
certiﬁcate. Speciﬁcation of the cryptographic primitives used
by X.509 is largely delegated to PKCS standards. We do
not focus on protocols (e.g., IMAP or SMTP) other than
HTTP run over TLS, nor the use of TLS with transport
layer protocols other than TCP (e.g., DTLS).
III. CRYPTO PROTOCOL ISSUES IN HTTPS
In this section, we consider attacks on the TLS protocol
which relate to HTTPS security. Section IV expands focus
to the broader CA/B infrastructure and human decisions
involved. As TLS is well-documented, we assume familiarity
with the basic protocol. Many attacks reﬁne known tech-
niques; examining both historical and recent attacks provides
a fuller perspective.
A. Weaknesses in Cryptographic Primitives
1) Weak Encryption & Signature Key Lengths: Several
encryption functions offered in the ciphersuites of early
versions of TLS are no longer considered secure. Any
symmetric key encryption scheme with 40, 56, or 64 bit
keys is subject to a brute-force attack. TLS supported DES,
RC2, and RC4 with some of these key lengths. Asymmetric
encryption schemes like RSA are subject to factoring attacks
when used with a 512 bit modulus. A 2007 analysis of TLS
servers found that while only 4% of sites still offered RSA-
512, 93% supported (single) DES [68]. Note that support-
ing an insecure primitive does not imply it is ever used,
as security parameters are negotiated (but see Downgrade
Attacks below). NIST strongly recommends that primitives
hold the equivalent of 112 bits (symmetric) security strength
and will require this by 2014 [22] (e.g., phasing out 1024-bit
RSA/DSA and 193-bit ECDSA).
Key length is also an issue for certiﬁcates. Sufﬁcient key
lengths should be used by the certiﬁcate authority to sign a
1The meaning of ‘correct’ remains challenging today (see Section VI).
certiﬁcate, and CAs should only sign certiﬁcates containing
public keys that are of sufﬁcient length.2
2) Weak Hash Functions: To issue a site certiﬁcate, CAs
sign its hash. Collision-resistance of the hash is paramount:
an adversary that could construct two meaningful certiﬁcates
with the same digest could transfer a CA signature from
a benign site certiﬁcate to a malicious CA certiﬁcate. The
MD5 hash function, published in 1992, has been eligible
for providing certiﬁcate digests. However the collision re-
sistance of MD5 has deteriorated over time, from generic
attacks [102] to the ﬁrst published collision [37] to the gen-
eration of “meaningful” collisions [98], and ﬁnally ﬁnding
collisions that are structured enough to be both an acceptable
benign site certiﬁcate and a malicious root certiﬁcate [99].
Use of MD5 is discouraged (RFC 3279) and certiﬁcates
digested with MD5 are in decline [54]. MD5 remains
recommended in other places in the TLS protocol where
collision-resistance of the hash function is not critical, i.e.,
HMAC and key derivation [65], [25], [66].
B. Implementation Flaws and Related Attacks
1) PRNG Seeding: Many values in the TLS protocol
are generated randomly, including secret keys. This requires
a strong pseudorandom number generator (PRNG), seeded
with a high entropy seed. The Netscape browser (prior
to 1.22) relied on a PRNG implementation with weak
keys [51] allowing the TLS session key (master secret) to be
predictable. A 2008 change to the Debian operating system
reduced the randomness served to OpenSSL, which was
used to generate TLS certiﬁcates with predictable private
keys [24], [15], [110]. Recently, 0.5% of TLS certiﬁcates
were found to have recoverable RSA private keys due to
shared prime factors [53], [70]; most originated from poor
PRG seeding in embedded devices.
2) Remote Timing Attacks: Remote timing attacks have
been used against TLS servers that use an optimized variant
of RSA decryption, the default in OpenSSL versions prior to
0.9.7b [30], [13]. The decryption algorithm makes branching
decisions that are functionally dependent on the long-term
certiﬁed secret key. This results in measurable differences
in execution time, leaking information about the key during
TLS handshakes. Previous OpenSSL implementations of
ECDSA enabled similar remote timing attacks [29].
C. Oracle Attacks
The following attacks interactively and adaptively query
the victim’s protocol implementation, treating it as an oracle.
1) RSA Encoding: SSL 3.0 with the RSA ciphersuite uses
“textbook” RSA (which enables ciphertext malleability) for
transporting a PKCS#1 v1.5 encoded premaster secret to
the server during the handshake. If upon decryption and
decoding, the plaintext is not properly encoded, an error
2An intermediate CA in Nov 2011 was revoked for issuing certiﬁcates
for 512-bit RSA keys. http://www.entrust.net/advisories/malaysia.htm.
512
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:35 UTC from IEEE Xplore.  Restrictions apply. 
is returned to the client. An adversary could capture an
encrypted premaster secret, and,
in separate handshakes
with the same server, submit adaptively modiﬁed versions
of it, learning if they are conformant [27]. With just this
information, the adversary can eventually (∼1M queries)
recover the premaster secret. TLS 1.0 consequently recom-
mends that encoding errors are handled indistinguishably
from successful decryptions.3
2) CBC Initialization: In TLS 1.0 and earlier, all block
ciphers are used in cipher block chaining (CBC) mode.
Records are encrypted individually, however the initializa-
tion vector for each (except the ﬁrst) is set equal to the last
block of ciphertext sent (i.e., in a predictable way). CBC
with predictable IVs is not secure against chosen plaintext
attacks [23], and thus an adversary capable of injecting
partial plaintext into a TLS connection and of observing the
transmitted ciphertext can determine semantic information
about the rest of the plaintext [20], [21]. In one instantiation
of this attack, BEAST, an adversary submits adaptively
chosen cross-site requests for a domain with a secure cookie
to learn the value of the cookie (and by adjusting the amount
of the value included in a single block, due to partitioning,
the value can be guessed byte-by-byte) [38]. This issue is
resolved in TLS 1.1, not applicable to any stream cipher
(e.g., RC4), and is purportedly mitigated by ﬁrst sending
the ﬁrst byte as a separate record (‘1/n-1 record splitting’).4
3) Compression: The use of data compression is a ne-
gotiable option in TLS, although one never broadly sup-
ported by browsers. TLS does not obfuscate the length of a
compressed TLS record, thus again an adversary capable
of injecting partial plaintext into a TLS connection and
observing the post-compression record length can determine
semantic information about the rest of the plaintext [64].
An instantiation of this attack, CRIME, used a similar
setup to BEAST for recovering secret values from secure
cookies [89]. As a result, all major browsers have disabled
TLS compression.
4) CBC Padding: An extended version of this paper [32]
discusses oracle attacks on CBC padding [103], [31], which
until very recently [16] applied only to non-HTTPS proto-
cols run over TLS.
D. Protocol-level Attacks
1) Ciphersuite Downgrade Attack: The ciphersuite used
by the client and server is negotiated during the TLS hand-
shake. In SSL 2.0, a man-in-the-middle could inﬂuence the
negotiation and downgrade the strength of the ciphersuite to
the weakest acceptable by both parties. This is ﬁxed in SSL
3.0 and all versions of TLS by having the client send, once
the MAC keys have been established, an authenticated digest
3Also note that while RSA key transport support is ubiquitous, 60–70%
of servers also support Diffe-Hellmen key exchange [86], [104] which has
the added beneﬁt of perfect forward secrecy.
4A. Langley, “BEAST Followup,” ImperialViolet (blog), 15 Jan 2012.
of the previous handshake messages and waiting for an
authenticated conﬁrmation from the server. Thus, downgrade
prevention is contingent on the unavailability of weak MAC
functions for negotiation.
2) Version Downgrade Attack: The TLS version is also
negotiated and while version downgrade attacks are not
possible against a strict implementation of the TLS spec-
iﬁcation, many client implementations respond to certain
server errors by reconnecting with an older TLS version.
These server errors can be spoofed by an attacker. To prevent
an adversary from ﬁrst downgrading to SSL 2.0 and then
downgrading the ciphersuite, TLS prohibits downgrading
to SSL 2.0. TLS implementations may still be vulnerable
to downgrades from later version to earlier versions (e.g.,
from TLS 1.1+ to TLS 1.0 to exploit CBC initialization
vulnerabilities). One mitigation is to include the highest
supported version number in the list of ciphersuites during
negotiation, extending ciphersuite-downgrade protection to
versions [5].
3) Renegotiation Attack: Once a TLS connection has
been established, either party can at any point request a
new handshake, within the existing tunnel, to renegotiate
the cipher suite, session key, or other relevant connection
parameters. The renegotiation protocol was discovered to be
ﬂawed in 20095 and was subsequently updated [1]. The erro-
neous version allowed an adversary to establish a connection
to a server, send data, renegotiate, and pass the renegotiated
connection onto a client
is forming an
initial connection. This effectively allowed the adversary
to prepend chosen records to new HTTPS connections. An
extension [50] to the standardized countermeasures [1] can
provide a strong notion of renegotiation security.
that believes it
4) Cross-Protocol Attacks: An extended version of this
paper [32] addresses cross-protocol attacks [105], [74] where
parameters intended to be used in one setting (e.g., Difﬁe-
Hellmen) are replayed in a different setting (e.g., RSA).
IV. TRUST MODEL ISSUES IN HTTPS
Section III narrowly considered attacks on the TLS proto-
col and the cryptographic algorithms it involves. This section
assumes a perfectly functioning TLS protocol and considers
attacks on the broader CA/B infrastructure. Our analysis
covers the certiﬁcation process itself, who is allowed to be
a certiﬁcate authority (anchoring trust), how this authority
can be delegated (transitivity of trust), how certiﬁcates
are revoked (maintenance of trust), and how users interact
with certiﬁcate information (indication and interpretation of
trust). In what follows, we speciﬁcally note which issues
remain unresolved.