下的实现方法。
ZSCORE
ZREM
ZREVRANK
ZRANK
ZREVRANGE
ZRANGE
ZCOUNT
ZCARD
ZADD
举个例子，以下代码就展示了使用DEL命令来删除三种不同类型的键：
列表键
OK
redis> SET msg "hello"
  字符串键
其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE 命令、RENAME
Redis 中用于操作键的命令基本上可以分为两种类型。
命令
类型检查与命令多态
元素分值
点，然后取出成员节点旁边的分值节点保存的
点，以及被删除成员节点旁边的分值节点
员
员，沿途记录经过节点的数量，当找到给定成
员
员，沿途记录经过节点的数量，当找到给定成
范围内的所有元素
范围内的所有元素
点的数量
素的数量
含节点的数量，将这个数量除以2得出集合元
值作为两个节点分别插人到压缩列表
遍历压缩列表，查找包含了给定成员的节
遍历压缩列表，删除所有包含给定成员的节
的排名
员之后，途经节点的数量就是该成员所对应元
从表尾向表头遍历压缩列表，
的排名
之后，途经节点的数量就是该成员所对应元
从表头向表尾遍历压缩列表，查找给定的成
从表尾向表头遍历压缩列表，返回给定索引
从表头向表尾遍历压缩列表，返回给定索引
遍历压缩列表，统计分值在给定范围内的节
调用zipiistLen 函数，获得压缩列表包
调用ziplistInsert 函数，将成员和分
ziplist 编码的实现方法
表 8-11
有序集合命令的实现方法
，查找给定的成
成员和分值的关联
跳跃表节点。并在字典中解除被删除元素的
应元素的排名
成员之后，途经节点的数量就是该成员所对
员，沿途记录经过节点的数量，当找到给定
应元素的排名
成员之后，途经节点的数量就是该成员所对
员，沿途记录经过节点的数量，当找到给定
范围内的所有元素
范围内的所有元素
点的数量
接返回集合元素的数量
素关联到字典
到跳跃表，然后调用 dictAdd 函数，将新元
追历跳联表，删除所有包含了给定成员的
从表尾向表头遍历跳跃表，查找给定的成
从表头向表尾遍历跳跃表，查找给定的成
从表尾向表头遍历跳跃表，返回给定索引
从表头向表尾遍历跳跃表，返回给定索引
遍历跳跃表，统计分值在给定范围内的节
访问跳既表数据结构的 length 属性，直
直接从字典中取出给定成员的分值
先调用 zslInsert 函数，将新元素添加
zset 编码的实现方法
第 8章 
·81
---
## Page 86
82·第一部分数据结构与对象
再决定是否执行给定的命令。
定的命令，在执行一个类型特定的命令之前，Redis 会先检查输人键的类型是否正确，然后
8.7.1
Redis将向我们返回一个类型错误：
操作这个键，但如果我们试图对这个字符串键执行只有列表键才能执行的 LLEN 命令，那么
类型特定命令所进行的类型检查是通过 redisObject 结构的type 属性来实现的：
从上面发生类型错误的代码示例可以看出，为了确保只有指定类型的键可以执行某些特
口在执行一个类型特定命令之前，服务器会先检查输人数据库键的值对象是否为执行
(error)
redis> LLEN msg
"hello world again!"
redis> GET msg
(integer) 18
redis> APPEND msg " again!"
redis> sET msg "hello world"
举个例子，我们可以用SET命令创建一个字符串键，然后用GET命令和APPEND命令
口 ZADD、ZCARD、ZRANK、ZSCORE 等命令只能对有序集合键执行;
口
口
口HDEL、HSET、HGET、HLEN 等命令只能对哈希键执行；
口SET、GET、APPEND、STRLEN 等命令只能对字符串键执行：
而另一种命令只能对特定类型的键执行，比如说：
(integer) 1 
redis> DEL fruits
(integer) 1
redis> DEL numbers
(integer) 1
redis> DEL msg
(integer) 3
redis> SADD fruits apple banana cherry
#集合键
(integer) 3
redis> RPUSH numbers 1 2 3
SADD、SPOP、SINTER、SCARD 等命令只能对集合键执行；
RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行
类型检查的实现
 WRONGTYPE Operation against a key holding the wrong kind of value
---
## Page 87
于处理多种不同编码。
令可以同时用于处理多种不同类型的键，而后者是基于编码的多态-
键是什么类型，这些命令都可以正确地执行。
类型特定命令的执行过程也是类似的。
linkedlist 编码，命令都可以正常执行。
的，只要执行LLEN命令的是列表键，那么无论值对象使用的是 ziplist 编码还是
实现：
执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的LLEN命令
来实现列表命令。
两种编码可用，其中前者使用压缩列表API来实现列表命令，而后者则使用双端链表API
的编码方式，选择正确的命令实现代码来执行命令。
8.7.2
图8-19展示了LLEN命令从类型检查到根据编码选择实现函数的整个执行过程，其他
DEL、EXPIRE等命令和LLEN等命令的区别在于，
实际上，我们可以将DEL、EXPIRE、TYPE 等命令也称为多态命令，因为无论输人的
举个例子，在前面介绍列表对象的编码时我们说过，列表对象有ziplist和linkedlist
口 如果列表对象的编码为 ziplist，那么说明列表对象的实现为压缩列表，程序将使
现在，考虑这样一个情况，如果我们对一个键执行LLEN命令，那么服务器除了要确保
借用面向对象方面的术语来说，我们可以认为 LLEN命令是多态（polymorphism）
Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象
口 如果列表对象的编码为 linkedlist，那么说明列表对象的实现为双端链表，程序
其他类型特定命令的类型检查过程也和这里展示的LLEN命令的类型检查过程类似。
口否则的话，服务器就拒绝执行命令并向客
口在执行LLEN命令之前，服务器会先检查
举个例子，对于LLEN命令来说：
口否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。
将使用 listLength 函数来返回双端链表的长度；
用 ziplistLen 函数来返回列表的长度；
多态命令的实现
一类型检查过程。
户端返回一个类型错误；图8-18展示了这
果是的话，服务器就对键执行LLEN命令；
type 属性的值是否为 REDIS_LIST，如
也即是，检查值对象redisObject 结构
输人数据库键的值对象是否为列表类型
命令所需的类型，如果是的话，服务器就对键执行指定的命令；
图8-18LLEN命令执行时的类型检查过程
对键key执行LLEN命令
，前者是基于类型的多态一
客户端发送LLEN命令
是
是否列表对象
键key的值对象
服务器检查
一个命令可以同时用
”返回一个类型错误
第8章  对 
一个命
+83
---
## Page 88
84·第一部分数据结构与对象
引用计数。
对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。
用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪
8.8
resetRefCount
decrRefCount
incrRefCount
表 8-12 列出了修改对象引用计数的API，这些 API分别用于增加、减少、重置对象的
每个对象的引用计数信息由 redisObject 结构的refcount 属性记录：
因为C 语言并不具备自动内存回收功能，所以 Redis 在自己的对象系统中构建了一个引
口当对象的引用计数值变为0时，对象所占用的内存会被释放。
口
口当对象被一个新程序使用时，它的引用计数值会被增一；
在创建一个新对象时，引用计数的值会被初始化为1；
对象的引用计数信息会随着对象的使用状态而不断变化：
robj;
typedef struct redisobject {
函数
当对象不再被一个程序使用时，它的引用计数值会被减一；
内存回收
！！
int refcount;
//引用计数
！！.··
返回压缩列表的长度
的引用计数值时使用
将对象的引用计数值设置为0，但并不释放对象，这个函数通常在需要重新设置对象
将对象的引用计数值减一
将对象的引用计数值增
ziplist还是linkedlist?
表 8-12 修改对象引用计数的 API
ziplist
对象的编码是
图 8-19LLEN 命令的执行过程
返回双端链表的长度
linkedlist
当对象的引用计数值等于0时，释放对象
编码
客户端发送LLEN命令
是
是否列表对象
key的值对象
作用
返回一个类型错误
---
## Page 89
能节约越多的内存。
共享对象机制对于节约内存非常有帮助，数据库中保存的相同值对象越多，对象共享机制就
的样子，可以看到，除了对象的引用计数从之前的1变成了2之外，其他属性都没有变化。
务器有以下两种做法：
举个例子，假设键A 创建了一个包含整数值100的字符串对象作为值对象，如图 8-20所示。
8.9
以下代码展示了一个字符串对象从创建到释放的整个过程：
如果这时键B 也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服
除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。
2）让键A 和键B 共享同一个字符串对象；
对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。作为例子，
举个例子，图 8-21 就展示了包含整数值100 的字符串对象同时被键A 和键B共享之后
2）将被共享的值对象的引用计数增一。
1）将数据库键的值指针指向一个现有的值对象；
在 Redis中，让多个键共享同一个值对象需要执行以下两个步骤：
以上两种方法很明显是第二种方法更节约内存。
1）为键B新创建一个包含整数值100的字符串对象；
其他不同类型的对象也会经历类似的过程。
decrRefCount(s)
// 对象s 执行各种操作．.．
robj *s = createStringobject(...)
/1创建一个字符串对象 s，对象的引用计数为 1 
对象共享
图8-20未被共享的字符串对象
REDIS_ENCODING_INT
REDIS_STRING
redisobject
encoding
refcount
ptr
type
1
100
图8-21被共享的字符串对象
REDIS_ENCODING_INT
REDIS_STRING
redisobject
refcount
encoding
ptr
type
2
第8章
→100
对
象
·85
---
## Page 90
86·第一部分数据结构与对象
对象，使得共享对象的引用计数值变为3：
的键 A，如图 8-22 所示。
键A的值对象的引用计数，我们会发现值对象的引用计数为2：
来修改。
用这些共享对象，而不是新创建对象。
到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使
存才能保存的数据。
那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内
如果这时我们再创建一个值为100的键B，那么键B也会指向包含整数值100 的共享
举个例子，
创建共享字符串对象的数量可以通过修改 redis.h/REDIS_SHARED_INTEGERS 常量
目前来说，Redis 会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0
图 8-23展示了共享值对象的三个程序。
引用这个值对象的两个程序分别是持有这个值对象的服务器程序；以及共享这个值对象
redis> SET A 100
例如，假设数据库中保存了整数值100的键不只有键A 和键B 两个，而是有一百个，
(integer) 3
redis> OBJECT REFCOUNT B
(integer) 3
redis> OBJECT REFCOUNT A
redis> SET B 100
(integer)2
redis> OBJECT REFCOUNT A
服务器程序
OK
图8-22
，如果我们创建一个值为100的键A，并使用OBJECTREFCOUNT命令查看
引用数为2的共享对象
 REDIS_ENCODING_INT
 REDIS_STRING
redisobject
refcount
 encoding
 ptr 
type
2
100
服务器程序
键A
图8-23引用数为3的共享对象
REDIS_ENCODING_INT
REDIS_STRING
encoding
redisobject
refcount
xzd
type