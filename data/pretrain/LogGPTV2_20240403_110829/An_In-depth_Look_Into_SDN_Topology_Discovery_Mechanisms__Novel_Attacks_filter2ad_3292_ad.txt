the authentication server. To force the victim’s host to move to
another network location, adversaries could follow an approach
similar to the one used in the port amnesia attack [40]. Crucial to
the proposed attack is that during the authentication procedure the
host does not establish any cryptographic session key with either
the controller or the switch. As a result, the packets transmitted
by hosts after completing the authentication protocol are neither
encrypted nor authenticated.
According to SecureBinder, it should be impossible to disconnect
and connect a host without triggering a port-down and a port-up
event even when the adversary has specialised equipment and physi-
cal access to the devices. We envision a scenario where the physical
hosts can contain several Virtual Machines (VMs) and a virtual
switch for routing the packets to/from each VM. In such a case, the
virtual switch (inside the physical host) should always inform the
corresponding physical switch when a VM is (dis)connected so that
the VM can authenticate to the controller using SecureBinder. The
way this is done depends on how the virtual switch is designed and
programmed. However, it is important to note that all the events
generated by the VMs should be treated as if they were originating
from a physical host connected to a physical switch.
Attack. We conducted several experiments to investigate if it
is possible to disconnect a (victim) host from its switch/port and
connect a (malicious) host fast enough such that the switch does
not notice about this disconnection. According to the IEEE 802.3
standard, if twisted pairs Ethernet connections are used between
switches and hosts, a signalling protocol is used where a link in-
tegrity pulse is sent by these devices every 16 ± 8 ms [16]. In other
words, a switch infers that a host is no longer connected if it does
not receive such a pulse in 24 ms. If adversaries can remotely detect
or trigger a (victim) host disconnection and immediately connect
a (malicious) host to the switch, they could benefit from the valid
ongoing communication session initiated by the victim’s host.
We started our experiments by running the command ifconfig
eth0 down && ifconfig eth0 up on a Mininet host to measure
the average time between disconnecting and re-connecting a net-
work interface. This test resulted in a delay of only 8 ms, which
indicates that it could be possible to circumvent SecureBinder in
order to add a malicious host in the network. (Recall that switches
can only detect that a host is no longer connected after 24 ms).
However, we observed that Mininet switches always detect the port
disconnection and send a port-down to the controller. In contrast
to real OpenFlow switches, Mininet switches do not implement any
signalling protocol with the host and thus they do not check the
port liveness before notifying the controller about the port-down.
In other words, Mininet emulates the disconnection of a host from a
switch without considering the delays introduced by the signalling
communication protocol between the host and the switch.
Subsequently, we used Wireshark to measure the average time
between a port-down and a port-up on the control plane. Similarly
to the previous test, this experiment also resulted in a delay of
8 ms. Motivated by the results obtained in Mininet, we tested our
hypothesis using our hardware SDN network with two Raspberry Pi
3 acting as a switch and host, respectively. However, in this case the
previous commands took 68 ms, whereas the average time between
the port-down and port-up was around 1630 ms on average.
While our preliminary results indicate that SecureBinder is ca-
pable of detecting our attack, we suggest that topology defences
should not base their security solely on the fact that port-down
and port-up events are all genuine (i.e., they are generated if and
only if a host really (dis)connects from/to a switch). As a future
work, we plan to further investigate how to accelerate the process
of disconnecting and reconnecting a network interface.
Insecure low level bindings. SecureBinder provides a weak
5.3.2
binding between the hosts’ MAC address and their network loca-
tion. More specifically, the main limitation of SecureBinder is that
it does not bind the authentication traffic to the switch/port where
the host is connected.
Attack. Adversaries can intercept the authentication traffic
from/to a victim host and replay it in a different network location.
If adversaries replay the victim’s authentication traffic to a switch
whose path to the controller is faster, they can convince the con-
troller that the victim’s host is at their location. This attack can be
possible (i) if the adversary manages to insert an Ethernet hub in
the network or (ii) when the victim host and the adversary have
two VMs running on the same physical host.
Figure 7 shows a realistic network scenario where this attack
could be mounted. This network configuration is known as in-band
SDN and is widely used in practice [8, 36]. Unlike out-of-band SDN
configurations, where all switches can directly communicate to the
controller, only a few switches interact with the controller in an
in-band SDN configuration.
In an in-band SDN configuration, adversaries can intercept the
(plain) authentication traffic from/to H1 (e.g., using an Ethernet hub)
and replay it to S2 using H2. If the link between S1 and S2 is slower
than the path between S2 and the controller, the authentication
traffic sent by the adversary using H2 is received first. This causes
the controller to believe that H1 is connected to S2. To improve
the effectiveness of this attack, the adversary could overload S1 to
deliberately increase the latency of the link between S1 and S2. The
main advantage of our attack is that, if H2 succeeds in convincing
the controller that H1 is connected to S2, H2 not only receives
all the traffic to H1 but also prevents H1 from receiving its traffic.
Even if the genuine authentication traffic sent by H1 is eventually
received and validated by the controller, the previously installed
flow rules can lead to inconsistencies in the data plane.
Figure 7: Possible attack scenario against SecureBinder
using an in-band SDN network.
6 IMPLEMENTATION ATTACKS
In 2018, Nehra et al. showed that most SDN controllers lack security
mechanisms to protect the network topology information [29].
Motivated by their study, we manually inspected the source code of
the Floodlight controller to find potential ways of tampering with
the network topology view at the controller4. Our analysis resulted
in the identification of two new attacks called Reverse Loop and
Topology Freezing. These attacks do not require the controller or the
switches to be compromised, and assume that the control channel
between switches and the controller is protected using TLS/SSL.
Although these attacks are specific to the Floodlight controller,
these (or similar) attacks are also likely to exist in other major SDN
controllers. Most controllers rely on the standard OFDP protocol,
each with minor message field variations [29]. In addition, the
OFDP protocol is not well defined and lacks security mechanisms
to protect packet integrity and confidentiality. This results in ad
hoc insecure implementations.
4We downloaded the Floodlight controller version 1.2 from the official Git repository
on Sept 5, 2018 [31].
6.1 Reverse Loop
We unveil a new attack – which we call Reverse Loop – that exploits
a weakness in the way the LDS handles the LINK-TYPE field inside
the LLDP packets. Before describing our attack, let us first briefly
explain what the purpose of the LINK-TYPE field is. Suppose that
S1 and S2 are connected to each other and the controller does not
know yet about the existence of a link between them. Initially, the
controller sends an LLDP packet with the LINK-TYPE field set to
‘0x01’ to S1 which in turn sends it to S2. Once the controller infers
a unidirectional link from S1 to S2, it immediately checks if the
reverse link (i.e., from S2 to S1) exists by sending an LLDP packet
to S2. However, in this case the LINK-TYPE field is set to ‘0x02’
(instead of ‘0x01’). Note that the controller regularly repeats this
procedure with all switches to collect information about existing
or new inter-switch links.
We highlight that the Reverse Loop attack can facilitate the cre-
ation of fake links using an out-of-band channel when TopoGuard+
is deployed. As the controller always sends an LLDP packet to check
for the reverse link whenever it receives a valid LLDP packet, our
attack can indicate whether the LLI module accepted the delayed
LLDP packet. Recall that the controller checks for the reverse link
only if the latency of the LLDP packet is within the valid range.
The core idea behind the Reverse Loop attack is to extend the
duration of an LLDP round as much as possible to exhaust the
controller resources, potentially leading to crashes. To illustrate
how the Reverse Loop attack works, let us give an example using the
network topology shown in Figure 2b. Essentially, the adversary
proceeds in the same way as when a fake link is created from
S3 to S1. Specifically, the adversary (i.e., H1) starts by sending a
maliciously crafted LLDP packet containing the headers associated
with S3. The controller then proceeds as expected and sends an
LLDP packet with the LINK-TYPE field set to ‘0x02’ to S1 to validate
if a reverse link exists from S1 to S3. Subsequently, the adversary
transmits the LLDP packet with the LINK TYPE field set to ‘0x01’.
Crucially, we found that re-sending the initial LLDP packet (with the
LINK TYPE field set to ‘0x01’) triggers the controller into checking
if the reverse link exists indefinitely. We then discovered an even
more powerful variant of our attack that induces the controller
into continuously computing the topology instance. This variant
leverages the fact that the LDS re-computes the topology instance
every time the latency of a link changes. (Note that from Floodlight
version 1.2 onwards, LLDP packets contain a time-stamp that is
used to determine the link latency).
To test the practicality and severity of the Reverse Loop attack,
we conducted a series of experiments where we instructed H1 to
send LLDP packets with a slightly modified time-stamp to force the
controller into recomputing the topology instance. We tested our
attack in Mininet using a tree topology with depth 4 and fanout
3, comprising 81 hosts and 40 switches. Figure 8 illustrates the
resource consumption of the Floodlight process inside the controller
before and during the attack. To measure the CPU performance, we
used the top command on the Linux shell. This test demonstrates
that computing the topology instance is a very demanding task that
can cause the controller to crash. While we did not evaluate it, the
Reverse Loop also results in more LLDP packets being sent by the
controller, which can negatively impact the network bandwidth.
SDNControllerSwitchS2SwitchS1SwitchS3p2p2 p3 p1 Host1Host2AA’A’AAA’1223p1p1OpenFlowTMlinkData linkHost packetHost packet inside a PACKET_INSlow linkFigure 8: CPU usage of the Floodlight controller during the
Reverse Loop Attack. In this example, the attack starts after
approximately 60 s.
The fundamental reason this attack is possible is because LLDP
packets lack integrity protection that guarantees that they have not
been tampered with, and originate from the sender switch. Protect-
ing the integrity of LLDP packets would mitigate such attacks to
a large extent, but this would require major changes in the Flood-
light controller. Additionally, we argue that the use of an anomaly
detection system could also help to keep track of the number of
times a certain LLDP packet is sent.
6.2 Topology Freezing
Our second attack – which we call Topology Freezing – affects the
module responsible for computing the topology instance. It can be
launched to “freeze” the current topology instance, preventing the
controller from updating part of the network topology view.
Essentially, our attack is based on the following observation:
When two links are created that originate from the same “origin”
switch/port (e.g., S1 port 1) but end in two different network loca-
tions (e.g., S4 port 1 and S5 port 1), the LDS accepts both links and
treats the “multi-link” port as a broadcast domain port (see Figure 9).
As a result, the LDS removes the “origin” port and its links from the
topology graph construction. Yet, we made the crucial observation
that these links are still being used by the controller to compute
the shortest path (using an outdated topology instance), causing
systematic runtime exceptions.
To show the consequences of performing our attack, we imple-
mented it in Mininet using the network topology shown in Figure 9.
As we configured the network so that the shortest path between
two hosts is determined based on the number of hops, H3 and H6
initially communicate through Link A. (Note that our attack can
be executed regardless of the metric used to compute the shortest
path between a pair of hosts). To execute our attack, we used H4
and H5 to create two fake links between (i) S1-Port1 and S4-Port1
and (ii) S1-Port1 and S5-Port1. From this moment onwards and for
as long as S1-Port1 contained two links, the controller was unable
to fully update the topology instance and the forwarding module,
as shown in Figure 10.
Figure 9: Topology Freezing Attack. H4 and H5 can success-
fully create two fake links originating from S1 Port1.
ERROR [n.f.t.TopologyManager] Error in topology instance task thread
java.lang.NullPointerException: null
at net.fl[..].topology.TopologyInstance.dijkstra(TopologyInstance.java:624)
at net.fl[..].topology.TopologyInstance.yens(TopologyInstance.java:1068)
at net.fl[..].topology.TopologyInstance.computeOrderedPaths(TopologyInstance.java:790)
at net.fl[..].topology.TopologyInstance.compute(TopologyInstance.java:168)
at net.fl[..].topology.TopologyManager.createNewInstance(TopologyManager.java:1015)
at net.fl[..].topology.TopologyManager.updateTopology(TopologyManager.java:208)
at net.fl[..].topology.TopologyManagerUpdateTopologyWorker.run(TopologyManager.java:179)
at net.fl[..].core.util.SingletonTaskSingletonTaskWorker.run(SingletonTask.java:69)
at java.util.concurrent.ExecutorsRunnableAdapter.call(Executors.java:511)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
Figure 10: Log file in the Floodlight controller when freezing
the network topology.
Subsequently, we removed Link A from the network topology
and observed that H6 can no longer receive packets from H3. This
is because the controller keeps using an old topology instance and
hence uses Link A (which no longer exists) to carry the packets
between H3 and H6. It is interesting to see that even if the controller
learns about the existence of a new legitimate link between two
switches, it cannot update the topology instance and thus cannot
use the link. Therefore, adversaries can execute this attack to freeze
the network topology and act maliciously without being noticed by
the controller. We want to stress that this attack can complement
and increase the impact of existing SDN attacks. To maximise its
outcome, adversaries need to carefully choose the switch/port from
where they launch the attack. Updating the topology instance is
done sequentially based on the switches’ DPID, starting from the
switch with the lowest DPID. If the multi-link port is created on
the switch with the lowest DPID, the rest of the network is no
longer updated. The best strategy is therefore to perform the attack
from the switch with the lowest DPID. As the Floodlight controller
assigns the DPID to each switch based on its MAC address, finding
the switch with the lowest DPID is straightforward.
050100150200250300Time [s]020406080100CPU Usage [%]Attack startsSwitchS1SwitchS2p1p4p2Host 1SwitchS3p3SwitchS4p1Host 4SwitchS5p1p2p2p3p4p2p3p2p1Host 3Host 6p5Link AHost 5Data linkFake data linkFixing this vulnerability is not easy. The most intuitive solution
to defend against it would be to check if the link exists (e.g., by
pinging the other host) before using the link to send real traffic.
hardware to relay packets over an out-of-band channel. As a future
work, we plan to investigate how to apply the ideas behind distance
bounding protocols in SDN networks.
7 PRACTICAL COUNTERMEASURES
To defend against topology attacks, SDN networks could simply
use a static network configuration similar to traditional networks
(e.g., limiting the number of MAC addresses in a switch port) [2].
However, this is a tedious and error-prone approach that does not
account for the dynamics of SDN networks. Re-designing the exist-