Max Min
5
1
1
1
1
1
1
1
5
7
5
2
1
4
1
1
Avg
5.0
3.1
2.0
1.0
1.0
2.0
1.0
1.0
σ
0
2.2
1.3
0.3
0
1.3
0
0
SDK Version
21
22
23
24
25
26
27
28
5.0
5.1
6.0
7.0
7.1
8.0
8.1
9.0
# ROM CDD
Violations
1/58 (1.7%)
20/251 (7.9%)
58/359 (16.1%)
8/226 (3.5%)
3/163 (1.8%)
121/141 (85.8%)
110/139 (79.1%)
122/196 (62.2%)
443/1533 (28.9%)
Neverallow Rules Violations
Max Min
σ
0
8
1
10.4
15.7
1
3.9
1
88.1
1
7.7
1
2
7.5
8.8
1
Avg
8.0
4.6
3.6
7.2
56.3
7.2
7.2
4.0
8
39
121
10
158
27
25
37
ROMs. For 351 ROMs, we identified that they correctly support
SELinux at kernel level, but no policy has been found: we suppose
these might be incremental updates, not containing the policy.
We now focus our discussion on the remaining 1,817 ROMs that
define a SELinux policy. Out of them, 7% (108 ROMs) violate the
CDD specification for their corresponding Android version as they
still define one or more permissive domains. We found this
violation spread across 16 different vendors. We also analyzed the
distribution of these violations with respect to their SDK level to de-
termine whether this problem only affects older versions of Android.
Surprisingly, we noticed that even if Google forbids permissive
domains starting from Android 5.0 (and thus from SDK 20), several
ROMs are still not complaint even after four major releases, and
after an almost complete redesign of SELinux on Android 8 [25].
Table III summarizes the results of this analysis. We divided the
results before and after the introduction of Project Treble to show
once more how the problem persisted even after the introduction
of the new system design.
We then performed the second analysis to identify whether a
vendor tampered with any of the predefined neverallow rules,
which is a strict violation of the CDD, starting from Android 5.0.
However, detecting this type of violation is not straightforward.
Each Android version contains a preset of SELinux rules: the
neverallow rules are part of this base policy. At compilation
time, the SELinux policy compiler verifies if any rules defined in
the policy are in contrast with what is defined by the neverallow
rules: if a violation is identified, the compiler throws a compilation
error. However, these checks are performed only at compilation
time and are not enforced at runtime. Therefore, potentially, a
third-party vendor facing a violation of a neverallow rule
introduced by one of its customizations may be tempted to “solve”
the issue by just changing or removing the neverallow rule
that prevents the compilation of the final policy. Thus, by analyzing
only the vendor policy of the final ROM is not possible to conclude
whether it violates the CDD requirement.
To detect these violations, we proceed as follows: for each ROM,
we first retrieved the tag used by the vendor as a base system (see
Section III-B), and we save both the textual and the compiled version
of the policy. Then, we identify all the differences between the
compiled policies, and we collect the customizations introduced by
the vendor. For each of the additional vendor-only rules, we then try
to recompile the original AOSP policy with the addition of the new
rule, and we check for compilation errors. In case of compilation
errors, we finally check whether it is due to a neverallow rule
violation, and if so, we mark the vendor policy as not compliant.
Out of 1,533 ROMs with a SELinux policy (and that target
Android ≥ 5), we identified that 29% of them (443) violated the
CDD by defining one or more rules violating one of them default
neverallow rules. For all these images, from 21 unique vendors, it
was possible to identify SELinux policies allowing operations that
were not supposed to be available. Table IV summarizes the results
of this second analysis. Also in this case, the introduction of Project
Treble failed to mitigate the vendors’ problems related to SELinux
customizations. As can be seen from Table IV, if we consider the
results for SDK level 26, 27, and 28, we see how this problem has
increased dramatically, reaching peaks of 85% of the ROMs having
at least one violation.
Although the Vendor Test Suites contain tests to check for
SELinux violations, and specifically to identify this type of
violations [26], the results we have collected show that not only
these are easily bypassable by vendors, but that vendors actually
do violate them very often, making them not compliant with the
CDD, and potentially introducing security issues. We would like
to note that these results do not imply maliciousness: we believe
most of the vendors use this practice to fix compatibility issues
introduced by their customizations quickly. Indeed, modifying
or commenting out a neverallow rule is much easier than
potentially re-architecting a customization to fit the requirements.
C. Binary Compliance
The last category of system hardening defined by Google
is related to user-space binaries. As previously discussed, the
requirements for binaries were introduced only in Android 9, and so
far, they only cover two aspects: Control Flow Integrity (CFI) and
Integer Overflow Sanitization (IntSan). CFI is a security mechanism
that tries to prevent changes to the control flow of a compiled binary,
making exploitations that require hijacking the “expected” control
flow much harder. IntSan provides instead compile-time instrumenta-
tion to detect signed and unsigned arithmetic integer overflow. When
an overflow is detected, the process safely aborts. Both protection
systems have been gradually introduced by Google to harden the
Android Media Stack component [27], [28], which has been subject
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:28:06 UTC from IEEE Xplore.  Restrictions apply. 
94
to numerous attacks over the years, including Stagefright [29], which
could have been prevented with these two hardening techniques.
To take advantage of these new protections, the developer must
use a compiler that supports them. Officially, Google uses and
supports Clang, but both features are also available on the GCC
compiler.
As presented in Table I, the only requirement for the user-space
binaries is defined as strongly recommended, and it asks vendors
to not remove CFI or IntSan compiler mitigations from components
that have them enabled. Thus, to identify if vendors adhere to this
recommendation, we proceed as follows: for each ROM, we first
identify its AOSP base image (see Section III-B). Then, we extract
all binaries shared between the vendor ROM and the corresponding
AOSP base image. Finally, for each of these binaries, we tested their
security features: if the original binary (present in the AOSP base
image) has CFI or IntSan enabled and the corresponding binary in
the third-party ROM does not, we mark the ROM as not respecting
the recommendation suggested in the CDD.
Since both defense mechanisms were introduced in the CDD
from Android 9, we only considered the 196 ROMs with SDK
≥ 28. Among them, 85 (43.37 %) contained at least one binary
that disabled CFI and 104 (53.06 %) contained at least one that
disabled IntSan. In these cases, six unique vendors lowered the
security of a binary, with respect to AOSP, thus violating the CDD
recommendation.
However, these vendors did not entirely disable CFI or IntSan for
all the binaries: on average, among the ROMs that have violated the
recommendations, the vendors disabled CFI for 38.7% (σ =36.5)
of the binaries, while they disabled IntSan for 35.8% (σ =34.9) of
them.
VI. ADDITIONAL CUSTOMIZATIONS
This section discusses our analysis of OEM customizations that,
even though may not constitute a strict violation of the requirements,
do negatively impact the security posture of the overall ROM.
A. New Functions in System Libraries
The vast majority of Android’s core system components are still
written in unsafe memory languages like C and C++ and shipped
as ELF libraries. Vendors can add functionalities to such libraries,
which can result in an increased attack surface. A recent (fixed
in May 2020) impactful example is a bug found in Samsung’s
customizations of Google’s Skia library [2]. The library is used to
process pictures for many applications, and Samsung customized
it to add support for new proprietary formats. Unfortunately, one of
these functions was vulnerable to memory corruption bugs, and the
exploitation of this vulnerability allowed an unauthenticated remote
attacker (i.e., 0-click) to execute arbitrary code on the device.
To assess the prevalence of vendor customizations that add
functionalities, given a ROM as input, we first inspect all binaries
that are also found in the original AOSP (we refer to this subset
of binaries with the term Shared Libraries), and we extract the
list of exported functions that were not present in the original
version. Since a vendor can use different library versions that might
have been taken from another AOSP branch, we opted for the
following conservative approach: we consider a ROM to have
Fig. 2. Analysis of new exported functions introduced in AOSP libraries
added functionality to a given binary if it contains symbols that do
not appear in any (i.e., older or newer) AOSP releases.
Figure 2 summarizes our findings. The two bar plots share the
same x-axis (the SDK level) and report respectively the mean of
the percentages of Shared Libraries in a ROM in which a vendor
has introduced new functions and the numbers of new functions
(when a vendor introduced at least one). The dark bar highlights
the actual vendors’ customizations, while the soft bar displays a
modification found in a previous version of AOSP. There is no soft
bar in the correspondence of SDK 10 because there are no ROMs
older than that in our dataset.
The results show an almost constant trend of roughly 80 new func-
tions added to 20% of the system libraries, thus vanishing Project
Treble’s efforts. Nevertheless, we also note that vendors are still
using old AOSP functions, maybe because their code still depends
on them. However, using a function that is no longer maintained in
AOSP can be dangerous because it does not receive security patches.
B. Compile-time Hardening
In addition to the CDD, Google also maintains a Security
Enhancements (SE) webpage [30], in which it presents the security
and privacy enhancements for each Android version. While the
CDD only started to discuss binary hardening in Android 9 (2018),
the SE discusses this topic since Android 3 (2009). This webpage
is not directly linked from the CDD, so it is not mandatory for the
OEMs to implement such enhancements. However, since these
aspects are security-relevant, we analyzed customizations related
to these aspects as well.
We first went over all the security features reported in the SE
and collected all mitigation techniques related to binary hardening:
I) Stack Canaries, II) No eXecute (NX), III) Position Independent
Executables (PIE), IV) Full Relocation Read-Only (Full RELRO),
V) Fortify Source, and VI) the use of setuid/setgid binaries.
(We do not mention CFI here because it was already discussed in
the previous section.) We then compiled a list of artifacts whose
95
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:28:06 UTC from IEEE Xplore.  Restrictions apply. 
0%10%20%30%(I) Mean of percentages of Shared Libraries with new functions1015161718192122232425262728SDK Level0255075100125(II) Mean of numbers of new functions introduced in a Shared LibraryNever found in AOSP, i.e., actual vendors' customizationOnly found in previous AOSP releasesFig. 4. Evolution of new services defined through Android Init Scripts
around 40% of vendors binary lack this basic feature), probably
because it slightly penalizes the performance [31]. NX adoption
and Full RELRO have instead always been very common in AOSP
binaries, while the gap with the vendors’ binaries is still substantial.
Moreover, we found an inconsistency concerning NX adoption:
the CDD never mentions NX, while the CTS contains a test to verify
at run-time if NX is enabled [32]. SE webpage presents NX in
Android 2.3, released in December 2010, and the test was committed
in March 2011. This fact is odd because the test is checking (and
thus enforcing) for a feature that is not explicitly requested.
Finally, we measured the prevalence of setuid/setgid files.
Since Android 4.3 (SDK 18), the AOSP removed all setuid exe-
cutables. Among the vendor binaries, we found that 319/447 (71%)
of the ROMs with SDK < 18 and 371/2453 (15%) of the ROMs
with SDK ≥18 contain at least one setuid executable. In partic-
ular, ROMs with SDK ≥18 should never contain any setuid ex-
ecutables (and in fact AOSP contains none). At a closer analysis, the
binaries that appear more frequently in those ROMs are su (18%),
procmem (17%), netcfg (16%), procrank (12%), and
tcpdump (11%). Developers often use these executables for
debugging purposes, but they should be removed from the final
released ROM since the presence of setuid executables can
severely affect the overall security posture of the device.
C. Android Init Script Customizations
Android OS relies on a custom init script system to start binaries
at boot time. Unfortunately, this component has been subject to
numerous security problems in the past, in many cases, due to
changes introduced by vendors [16].
To study this aspect, our system extracts from each ROM how
many new services it defines with respect to its corresponding
AOSP base image. However, not all services are started every time.
Therefore, among them, we mainly focus on those that start at
system boot and that run with root user privileges.
Figure 4 summarizes our findings. For each SDK level, the figure
displays the distribution of the number of new services: the left
Fig. 3. Mean of percentages of binaries using a certain security feature
presence or absence can be used to infer whether an ELF binary
implements or not each mitigation technique. The list is available
in Table V in the Appendix, annotated with a full description of
the features.
This information allowed us to compare the security-related
compiler options used by vendors for their binaries with respect