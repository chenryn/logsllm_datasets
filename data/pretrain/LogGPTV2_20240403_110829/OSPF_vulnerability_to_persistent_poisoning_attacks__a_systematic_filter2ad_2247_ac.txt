patches.
In Table 2 we compare the attack techniques of [11] and
of [16] with the new attack technique we uncovered. All
three attacks persistently falsify an LSA of a victim router
not controlled by the attacker. However, it seems that our
attack is more powerful that the others. It does not trigger
the victim router to originate a ﬁght-back LSA during the
attack. It requires only a single malicious packet to carry
out the attack. Finally, it can be used to poison the entire
2Note that for Router-LSAs, the Advertising Router ﬁeld
must be equal to the Link State ID ﬁeld and hence must
also be known.
topology described above in the GNS3 software. The attack
was successful. Here are our main ﬁndings:
1. The false LSA replaces the valid LSA. The false LSA
is not only installed in the LSA databases of all the
routers but also replaces the valid LSA. This hap-
pens in all routers, including the victim router. Con-
sequently, all routers always consider the false LSA
during their routing table calculation.
2. Routing tables of all routers except the victim router
are poisoned. All routers except the victim build their
routing tables according to the false LSA advertised
by the attacker. In particular, the route to R2 in R1’s
routing table is gone.
3. The routing table of the victim is erased. Probably
due to the bogus value of the Advertising Router ﬁeld
in the false LSA, the victim does not install routes
in its routing table. Consequently, all the entries in
the victim’s routing table which are sourced from the
OSPF process are deleted. This essentially empties
the routing table, eﬀectively making the victim unable
to perform its routing function. This erasure of the
victim’s routing table is permanent. The victim is not
able to spontaneously recover from this. To recover,
the OSPF process must be reinitialized.
4. The attack can be undone. The attacker can easily
undo the eﬀects of the attack by sending another false
LSA on behalf of the victim but this time with an
Advertising Router that equals the victim’s ID. This
LSA must have a higher sequence number than that of
the previous attack LSA. The new false LSA triggers
a ﬁght-back by the victim, which originates a newer
instance of the valid LSA that replaces the false LSA
in the LSA databases of all routers. In particular, the
route to R2 is reinstated in R1’s routing table and the
victim’s routing table reverts to normal.
RouterOS.
RouterOS is a software router that can be run on an x86
PC. We tested the newest version of RouterOS – version
6.2. We set up on a single PC four virtual machines running
Ubuntu version 10.4 Desktop. Each virtual machine ran
a single instance of RouterOS. The virtual machines were
conﬁgured in the topology described above. The attack was
successful. Here are our main ﬁndings:
1. The false LSA is installed in the LSA databases of all
routers. Note that unlike the Cisco case, here the valid
LSA still remains in the LSA databases.
2. All routers always consider the false LSA during their
routing table calculation. Routing tables of all routers
except the victim router are poisoned, as in the Cisco
case. We assume that the false LSA is always fetched
rather than the valid one since it was installed in the
database on a later time, however we can not verify
this.
3. The routing table of the victim is erased, as in the
Cisco case.
4. Triggering a ﬁght-back using a second false LSA does
not undo the attack’s eﬀects.
Figure 3: The topology used for the experiments
AS: all the routers within the attacked AS will install the
false LSA in their LSA databases. This includes the victim
router on whose behalf the false LSA has been advertised.
This last property is unique to our attack.
5.2 Attack’s Effects on Commercial Routers
We demonstrate the attack’s eﬀects on two commercial
routers: a hardware router and a software router. We chose
a Cisco 7200-series router as a hardware router. For the
software router we chose MikroTik’s RouterOS [4]. On both
routers the attack was successful and reliable. Figure 3 de-
picts the sample network topology we used for both experi-
ments. We labeled the routers as follows:
• Victim – The router on whose behalf a false LSA is
advertised
• Attacker – The router that was compromised by the
attacker, and which originates the false LSA
• R1 – The router co-located on the same local network
as the attacker and victim
• R2 – A router connected to the victim router
The victim, attacker and R1 reside on the same local net-
work – Net1. The victim and R2 reside on a diﬀerent local
network. The attacker sends out a false LSA onto Net1 on
behalf of the victim . The false LSA has the following ﬁelds
in its header:
• Link State ID = victim’s ID
• Advertising Router 6= victim’s ID (some arbitrary value)
• LS sequence number > valid LSA’s sequence number
The attacker advertises an LSA on behalf of the victim say-
ing that the victim has only a single link which is connected
to Net1. In particular, no link is advertised which connects
the victim to R2. The purpose of this false LSA is to poison
the LSA database of R1 so that no route to R2 will exist
in its routing table. The attacker ﬂoods the false LSA on
Net1. Note that we put R1 and the attacker on the same lo-
cal network to simplify the presentation. R1’s LSA database
would have been poisoned even if R1 had not resided on the
local network of the attacker.
Cisco.
We used network simulation software called GNS3 [3] that
builds on top of a Cisco IOS emulator called Dynamips [1].
We emulated a Cisco 7200 router with a commercial image
of a stable release of IOS – 15.0(1)M3. We conﬁgured the
3IOS 15.0(1)M was released on November 2009. Cisco ac-
knowledged that IOS’s latest release – 15.3 – is also vulner-
able as well as most other versions of IOS (around 600!).
Periodic injection [11] Disguised LSA [16] Our attack
Attack property
Persistence
Triggers ﬁght-back
Number of packets to send Many (1 packet per 5 sec.)
Entire AS is poisoned
Victim router is poisoned
Yes
No
No
No
Yes
Yes
2
No
No
Yes
No
1
Yes
Yes
Table 2: A comparison of our attack to previously published persistent attacks. The green cells in each row
contain the best value for the corresponding attack property
5.3 Mitigation Measures
The attack we presented relies on the following three vul-
nerabilities in the standard:
1. There is no sanity check on Router-LSA reception to
verify that the Link State ID ﬁeld equals the Adver-
tising Router ﬁeld.
2. A ﬁght-back is triggered only when a false LSA is re-
ceived having an Advertising Router ﬁeld that equals
the ID of current router (Section 13.4).
3. During the routing table calculation phase, Router-
LSAs are looked up in the LSA database using only on
the Link State ID ﬁeld (Section 16.1).
Elimination of any one of the three vulnerabilities shall
successfully mitigate the attack. Here are possible mitiga-
tion measures for each vulnerability:
1. Specify a check on Router-LSA reception to verify that
the Link State ID ﬁeld equals the Advertising Router
ﬁeld; otherwise, the LSA should be discarded.
2. A ﬁght-back shall be triggered if a false LSA is received
having either an Advertising Router or a Link State ID
that equals the ID of current router.
3. During the routing table calculation phase, Router-
LSAs are looked up using their full identiﬁer.
Probably the easiest mitigation measure for a vendor to
implement is the ﬁrst one. It is least likely to have unex-
pected aﬀects on other parts of the OSPF implementation.
Indeed, this measure was implemented by many vendors
found to be vulnerable to the attack. We note, however,
that the third measure should ideally be implemented as
well, since the third vulnerability is due to an oversight of
the protocol’s designers rather than an intended functional-
ity.
6. FORMAL VERIFICATION
Model checking is a widely used formal veriﬁcation method.
Its goal is to automatically determine whether a system
satisﬁes a desired speciﬁcation. A model of the system
is systematically searched for a violation of the speciﬁca-
tion. If such a violation is found, the system behavior that
caused this violation is returned to the user. Model check-
ing has shown notable success in verifying software systems,
hardware designs, communication protocols, controllers, and
more [6, 17].
Some past works [14, 10, 13, 5] have analyzed the security
of OSPF and other routing protocols using model checking.
Their goal was to check OSPF functionality in general. Since
OSPF is a complex protocol, none of these works actually
modeled the protocol in its entirety but rather abstracted
away many of the details. In this work, we extend a pre-
vious formal model of OSPF that was described in [5]. In
this extension, the ﬁght-back mechanism and routing table
calculation are modeled in more detail. Such extended mod-
eling allows us to better search for attacks that may exploit
intricate details of the ﬁght-back mechanism.
6.1 Modeling OSPF
The model is composed of a ﬁxed network topology that
contains legitimate OSPF routers and a single malicious
router. The modeled functionality includes the LSA mes-
sage structure, the LSA ﬂooding procedure, the ﬁght-back
mechanism, and the routing table calculation. In the follow-
ing we include a pseudo-code that gives a general overview
of the model we used. For the sake of brevity and clarity, the
pseudo-code does not encompass all of the model’s details.
The code of our full model can be found here [2]. The next
sections explain the pseudo-code.
6.1.1 The main function
The main function of the model is a loop, where in each
loop iteration any of the routers (including the attacker) can
run their procedure once. Each loop iteration is considered
a cycle. The ﬂooding timers of each router are decremented
in every cycle (see Section 6.1.3 for an explanation of the
ﬂooding timers).
We mark LSAs which are deemed to aﬀect the routing
table. We count the number of cycles each LSA resides in
an LSA database. The last portion of the main loop is the
assertion of the model’s speciﬁcation (Section 6.1.5).
6.1.2 The attacker model
The attacker generates an LSA with arbitrary content.
This models an attacker with complete control over the false
LSAs it sends out. Note that the identity of the victim router
on whose behalf the false LSA is sent is not predeﬁned. It
can be any one of the legitimate routers. The model checker
will cover every possible false LSA during its search for an
attack. Note that the attack may be composed of a sequence
of false LSAs sent by the attacker.
6.1.3 The router model
In the initial state, each router R has in its LSA database
LSAs originated by R, and for each link described in these
LSAs, there is also an LSA in the database with a link back
to R. Namely, there is a link from one of R’s neighbors back
to R. We need these links in our model because, as per the
OSPF standard, a link can be considered in the routing table
calculation only if there are links in the reverse direction.
Listing 1: The model’s main loop
Listing 3: A valid router procedure
main ( )
{
l o o p {
f o r e v e r y r o u t e r R
{
Router (R) ; // e x e c u t e R ’ s p r o c e d u r e
i f
(R. f l o o d i n g t i m e r > 0 )
R. f l o o d i n g t i m e r −−;
f o r e v e r y LSA i n R. LSA DB
{
LSA . c o u n t e r ++;
// v i o l a t i o n o f
// i n d i c a t e s a s u c c e s s f u l a t t a c k
a s s e r t (
t h i s a s s e r t i o n
LSA . mark == f a l s e
LSA . o r i g i n a t e d b y a t t a c k e r ==
| |
f a l s e
| |
LSA . c o u n t e r < MIN COUNTER
) ;
}
}
A t t a c k e r ( ) ; // e x e c u t e a t t a c k e r ’ s
p r o c e d u r e
n u m c y c l e s++;
}
}
Listing 2: The attacker’s procedure
A t t a c k e r ( )
{
LSA = g e n e r a t e a r b i t r a r y L S A ( ) ;
f l o o d (LSA) ;
}
Each router has a ﬂooding timer that determines how
many cycles it should wait before originating an LSA. When
the timer is set to 0 the router can originate its own LSA
without any delay. After the router ﬂoods its own LSA, its
timer is set to MinLSInterval, a predeﬁned constant that
determines by how many cycles to delay the next LSA orig-
ination. The timer is decreased by 1 in each cycle for which
its value is greater than 0.
When the router R receives an LSA, it ﬁrst checks that it
is valid (i.e., properly formatted and received from a valid
neighbor). If so, it checks whether such an LSA exists in its
LSA database. If it exists and is considered newer than the
database copy or if it does not exist in the database, then R
ﬂoods this LSA. Afterward it checks whether the LSA is self-
originated. A self-originated LSA is a one whose Advertising
Router ﬁeld equals R’s ID. If this conditions holds, a ﬁght-
back is triggered, in which case the LSA will not be installed
in the database. The ﬁght-back itself is delayed due to the
ﬂooding of the false LSA prior to discovering that it was
self-originated.