tion about their callers, both direct and indirect. Table 12-2 shows some of 
these mappings.
Table 12-2: EtwTi Sensor-to-Syscall Mappings
Sensor
Call tree from syscall (depth = 4)
EtwTiLogAllocExecVm
MiAllocateVirtualMemory← 
NtAllocateVirtualMemory
EtwTiLogDriverObjectLoad
IopLoadDriver← IopLoadUnload 
Driver ← IopLoadDriverImage← 
NtLoadDriverIopLoadDriver← 
IopLoadUnloadDriver← IopUnload 
Driver← NtUnloadDriver
EtwTiLogInsertQueueUserApc 
There are other branches of the call 
tree that lead to system calls, such as 
nt!IopCompleteRequest(), nt!PspGetConte
xtThreadInternal(), and nt!PspSetContex
tThreadInternal(), but these aren’t particu-
larly useful, as many internal functions rely 
on these functions regardless of whether the 
APC is being created explicitly.
KeInsertQueueApc← NtQueueApcThread 
KeInsertQueueApc← NtQueueApcThreadEx
EtwTiLogMapExecView
NtMapViewOfSectionMiMapView Of 
SectionExCommon← NtMap ViewOfSectionEx
EtwTiLogProtectExecVm
NtProtectVirtualMemory
Evading EDR (Early Access) © 2023 by Matt Hand
Microsoft-Windows-Threat-Intelligence   225
Sensor
Call tree from syscall (depth = 4)
EtwTiLogReadWriteVm
MiReadWriteVirtualMemory← 
NtReadVirtualMemoryMiReadWrite 
Virtual Memory← NtRead 
VirtualMemoryExMiReadWriteVirtual 
Memory← NtWrite VirtualMemory
EtwTiLogSetContextThread
PspSetContextThreadInternal← 
NtSetContextThread
EtwTiLogSuspendResumeThread 
This sensor has additional paths that are not 
listed and are tied to debugging APIs, including  
ntdll!NtDebugActiveProcess(), 
ntdll!NtDebugContinue(), and ntdll!NtRe
moveProcessDebug().
PsSuspendThread← 
NtSuspendThreadPsSuspendThread← 
NtChangeThreadStatePsSuspend 
Thread← PsSuspendProcess← 
NtSuspendProcessPsMultiResume 
Thread← NtResumeThread
An important fact to consider when reviewing this dataset is that 
Ghidra does not factor conditional calls in its call trees but rather looks for 
call instructions inside functions. This means that while the graphs gener-
ated from the Cypher queries are technically correct, they may not be fol-
lowed in all instances. To demonstrate this, an exercise for the reader is to 
reverse ntdll!NtAllocateVirtualMemory() to find where the determination to 
call the nt!EtwTiLogAllocExecVm() sensor is made.
Consuming EtwTi Events
In Chapter 8, you learned how EDRs consume events from other ETW pro-
viders. To try consuming ETW events from EtwTi, run the commands in 
Listing 12-13 from an elevated command prompt.
PS > logman.exe create trace EtwTi -p Microsoft-Windows-Threat-Intelligence -o C:\EtwTi.etl
PS > logman.exe start EtwTi
Listing 12-13: Logman commands to collect events from the EtwTi provider
You’ll probably receive an access denied error, despite having run the 
commands in high integrity. This is due to a security feature implemented 
by Microsoft in Windows 10 and later versions called Secure ETW, which 
prevents malware processes from reading or tampering with antimal-
ware traces. To accomplish this, Windows allows only processes with the 
PS_PROTECTED_ANTIMALWARE_LIGHT protection level and services started with the 
SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT service protection type to con-
sume events from the channel.
Let’s explore process protection so that you can better understand how 
consuming events from EtwTi works.
Understanding Protected Processes
Process protections allow sensitive processes, such as those that interact 
with DRM-protected content, to evade interaction by outside processes. 
Table 12-2: EtwTi Sensor-to-Syscall Mappings (continued)
Evading EDR (Early Access) © 2023 by Matt Hand
226   Chapter 12
While originally created for software such as media players, the introduc-
tion of Protected Process Light (PPL) eventually extended this protection 
to other types of applications. In modern versions of Windows, you’ll find 
PPL used heavily by not only Windows components but also third-party 
applications, as seen in the Process Explorer window in Figure 12-6.
Figure 12-6: Protection levels across various processes
You can view a process’s protection state in the protection field of the 
EPROCESS structure that backs every process on Windows. This field is of the 
type PS_PROTECTION, which is defined in Listing 12-14.
typedef struct _PS_PROTECTION {
union {
UCHAR Level;
struct {
UCHAR Type  : 3;
UCHAR Audit  : 1;
UCHAR Signer : 4;
};
};
} PS_PROTECTION, *PPS_PROTECTION;
Listing 12-14: The PS_PROTECTION structure definition
The Type member of PS_PROTECTION correlates to a value in the  
PS_PROTECTED_TYPE enumeration, defined in Listing 12-15.
kd> dt nt!_PS_PROTECTED_TYPE
 PsProtectedTypeNone = 0n0
 PsProtectedTypeProtectedLight = 0n1
 PsProtectedTypeProtected = 0n2
 PsProtectedTypeMax = 0n3
Listing 12-15: The PS_PROTECTED_TYPE enumeration
Lastly, the Signer member is a value from the PS_PROTECTED_SIGNER enu-
meration, defined in Listing 12-16.
kd> dt nt!_PS_PROTECTED_SIGNER
 PsProtectedSignerNone = 0n0
 PsProtectedSignerAuthenticode = 0n1
 PsProtectedSignerCodeGen = 0n2
 PsProtectedSignerAntimalware = 0n3
Evading EDR (Early Access) © 2023 by Matt Hand
Microsoft-Windows-Threat-Intelligence   227
 PsProtectedSignerLsa = 0n4
 PsProtectedSignerWindows = 0n5
 PsProtectedSignerWinTcb = 0n6
 PsProtectedSignerWinSystem = 0n7
 PsProtectedSignerApp = 0n8
 PsProtectedSignerMax = 0n9
Listing 12-16: The PS_PROTECTED_SIGNER enumeration
As an example, let’s take a look at the process protection state of 
msmpeng.exe, Microsoft Defender’s primary process, using WinDbg, as dem-
onstrated in Listing 12-17.
kd> dt nt!_EPROCESS Protection
 +0x87a Protection : _PS_PROTECTION
kd> !process 0 0 MsMpEng.exe
PROCESS ffffa608af571300
SessionId: 0  Cid: 1134 Peb: 253d4dc000  ParentCid: 0298
DirBase: 0fc7d002 ObjectTable: ffffd60840b0c6c0 HandleCount: 636.
Image: MsMpEng.exe
kd> dt nt!_PS_PROTECTION ffffa608af571300 + 0x87a
 +0x000 Level 
 : 0x31 ‘1’
 +0x000 Type 
1 : 0y001
 +0x000 Audit 
 : 0y0
 +0x000 Signer 
 2 : 0y0011
Listing 12-17: Evaluating msmpeng.exe’s process protection level
The process’s protection type is PsProtectedTypeProtectedLight 1 and its 
signer is PsProtectedSignerAntimalware (a value equivalent to 3 in decimal) 2. 
With this protection level, also referred to as PsProtectedSignerAntimalware 
-Light, outside processes have limited ability to request access to the pro-
cess, and the memory manager will prevent improperly signed modules 
(such as DLLs and application compatibility databases) from being loaded 
into the process.
Creating a Protected Process
Creating a process to run with this protection level is not as simple as 
passing flags into kernel32!CreateProcess(), however. Windows validates the 
image file’s digital signature against a Microsoft-owned root certificate 
authority used to sign many pieces of software, from drivers to third-party 
applications.
It also validates the file by checking for one of several Enhanced Key 
Usage (EKU) extensions to determine the process’s granted signing level. 
If this granted signing level doesn’t dominate the requested signing level, 
meaning that the signer belongs to the DominateMask member of the  
RTL_PROTECTED_ACCESS structure, Windows checks whether the signing 
level is runtime customizable. If so, it checks whether the signing level 
matches any of the registered runtime signers on the system, and if a 
Evading EDR (Early Access) © 2023 by Matt Hand
228   Chapter 12
match is found, it authenticates the certificate chain with the runtime 
signer’s registration data, such as the hash of the signer and EKUs. If all 
checks pass, Windows grants the requested signature level.
Registering an ELAM Driver
To create a process or service with the required protection level, a devel-
oper needs a signed ELAM driver. This driver must have an embedded 
resource, MICROSOFTELAMCERTIFICATEINFO, that contains the certificate hash 
and hashing algorithm used for the executables associated with the user-
mode process or service to be protected, along with up to three EKU 
extensions. The operating system will parse or register this informa-
tion at boot via an internal call to nt!SeRegisterElamCertResources() (or an 
administrator can do so manually at runtime). If registration happens 
during the boot process, it occurs during pre-boot, before control is 
handed to the Windows Boot Manager, as shown in the WinDbg output 
in Listing 12-18.
1: kd> k
 # Child-SP  
RetAddr  
Call Site
00 ffff8308`ea406828 fffff804`1724c9af nt!SeRegisterElamCertResources
01 ffff8308`ea406830 fffff804`1724f1ac nt!PipInitializeEarlyLaunchDrivers+0x63
02 ffff8308`ea4068c0 fffff804`1723ca40 nt!IopInitializeBootDrivers+0x153
03 ffff8308`ea406a70 fffff804`172436e1 nt!IoInitSystemPreDrivers+0xb24
04 ffff8308`ea406bb0 fffff804`16f8596b nt!IoInitSystem+0x15
05 ffff8308`ea406be0 fffff804`16b55855 nt!Phase1Initialization+0x3b
06 ffff8308`ea406c10 fffff804`16bfe818 nt!PspSystemThreadStartup+0x55
07 ffff8308`ea406c60 00000000`00000000 nt!KiStartSystemThread+0x28
Listing 12-18: ELAM resources registered during the boot process
You’ll rarely see the manual registration option implemented in enter-
prise products, as resources parsed at boot require no further interac-
tion at runtime. Still, both options net the same result and can be used 
interchangeably.
Creating a Signature
After registration, the driver becomes available for comparison when 
a signing-level match is found. The rest of this section covers the imple-
mentation of the consumer application in the context of an endpoint 
agent.
To create the resource and register it with the system, the devel-
oper first obtains a certificate that includes the Early Launch and Code 
Signing EKUs, either from the certificate authority or generated as a 
self-signed certificate for test environments. We can create a self-signed 
certificate using the New-SelfSignedCertificate PowerShell cmdlet, as shown 
in Listing 12-19.
PS > $password = ConvertTo-SecureString -String "ThisIsMyPassword" -Force -AsPlainText
PS > $cert = New-SelfSignedCertificate -certstorelocation "Cert:\CurrentUser\My"
Evading EDR (Early Access) © 2023 by Matt Hand
Microsoft-Windows-Threat-Intelligence   229
>>  -HashAlgorithm SHA256 -Subject "CN=MyElamCert" -TextExtension
>>  @("2.5.29.37={text}1.3.6.1.4.1.311.61.4.1,1.3.6.1.5.5.7.3.3")
PS > Export-PfxCertificate -cert $cert -FilePath "MyElamCert.pfx" -Password $password
Listing 12-19: Generating and exporting a code-signing certificate
This command generates a new self-signed certificate, adds  
both the Early Launch and Code Signing EKUs, then exports it in  
.pfx format.
Next, the developer signs their executable and any dependent DLLs 
using this certificate. You can do this using the signtool.exe syntax included 
in Listing 12-20.
PS > signtool.exe sign /fd SHA256 /a /v /ph /f .\MyElamCert.pfx
>>  /p "ThisIsMyPassword" .\path \to\my\service.exe
Listing 12-20: Signing an executable using the generated certificate
At this point, the service executable meets the signing requirements to 
be launched as protected. But before it can be started, the driver’s resource 
must be created and registered.
Creating the Resource
The first piece of information needed to create the resource is the To-Be-
Signed (TBS) hash for the certificate. The second piece of information is 
the certificate’s file-digest algorithm. As of this writing, this field can be one 
of the following four values: 0x8004 (SHA10), x800C (SHA256), 0x800D 
(SHA384), or 0x800E (SHA512). We specified this algorithm in the  
/fd parameter when we created the certificate with signtool.exe.
We can collect both of these values by using certmgr.exe with the -v argu-
ment, as shown in Listing 12-21.
PS > .\certmgr.exe -v .\path\to\my\service.exe
--snip--
Content Hash (To-Be-Signed Hash)::
04 36 A7 99 81 81 81 07 2E DF B6 6A 52 56 78 24  ‘.6. . . . . . . . .jRVx$’
E7 CC 5E AA A2 7C 0E A3 4E 00 8D 9B 14 98 97 02  ‘..^..|..N. . . . . . .’
--snip--
Content SignatureAlgorithm:: 1.2.840.113549.1.1.11 (sha256RSA)
--snip--
Listing 12-21: Retrieving the To Be Signed hash and signature algorithm using cert-
mgr.exe
The hash is located under Content Hash and the signature algorithm 
under Content SignatureAlgorithm.
Adding a New Resource File
Now we can add a new resource file to the driver project with the contents 
shown in Listing 12-22 and compile the driver.
Evading EDR (Early Access) © 2023 by Matt Hand
230   Chapter 12
MicrosoftElamCertificateInfo MSElamCertInfoID
{
1,
L"0436A799818181072EDFB66A52567824E7CC5EAAA27C0EA34E008D9B14989702\0",
0x800C,
L"\0"
}
Listing 12-22: The MicrosoftElamCertificateInfo resource contents
The first value of this resource is the number of entries; in our case, 
there is only one entry, but there may be up to three. Next is the TBS hash 
that we collected earlier, followed by the hexadecimal value corresponding 
to the hashing algorithm used (SHA256 in our case).
Finally, there is a field in which we can specify additional EKUs. 
Developers use these to uniquely identify antimalware components signed 
by the same certificate authority. For example, if there are two services 
with the same signer on the host, but only one needs to be launched with 
the SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT flag, the developer could add 
a unique EKU when signing that service and add it to the ELAM driver’s 
resource. The system will then evaluate this additional EKU when starting 
the service with the Anti-Malware protection level. Since we’re not provid-
ing any additional EKUs in our resource, we pass what equates to an empty 
string.
Signing the Resource
We then sign the driver using the same syntax we used to sign the service 
executable (Listing 12-23).
PS > signtool.exe sign /fd SHA256 /a /v /ph /f "MyElamCert.pfx" /p "ThisIsMyPassword"
>>  .\path\to\my\driver.sys
Listing 12-23: Signing the driver with our certificate
Now the resource will be included in the driver and is ready to be 
installed.
Installing the Driver
If the developer wants the operating system to handle loading the cer-
tificate information, they simply create the kernel service as described in 
“Registering an ELAM Driver” on page XX. If they would like to install the 
ELAM certificate at runtime, they can use a registration function in their 
agent, such as the one shown in Listing 12-24.
BOOL RegisterElamCertInfo(wchar_t* szPath)
{
HANDLE hELAMFile = NULL;
hELAMFile = CreateFileW(
Evading EDR (Early Access) © 2023 by Matt Hand
Microsoft-Windows-Threat-Intelligence   231
szPath, FILE_READ_DATA, FILE_SHARE_READ, NULL, OPEN_EXISTING,
FILE_ATTRIBUTE_NORMAL, NULL);
if (hELAMFile == INVALID_HANDLE_VALUE)
{
wprintf(L"[-] Failed to open the ELAM driver. Error: 0x%x\n",
GetLastError());
return FALSE;
}
if (!InstallELAMCertificateInfo(hELAMFile))
{
wprintf(L"[-] Failed to install the certificate info. Error: 0x%x\n",
GetLastError());
CloseHandle(hELAMFile);
return FALSE;
}
wprintf(L"[+] Installed the certificate info");
return TRUE;
}
Listing 12-24: Installing the certificate on the system
This code first opens a handle to the ELAM driver containing the 
MicrosoftElamCertificateInfo resource. The handle is then passed to kernel32!I
nstallELAMCertificateInfo() to install the certificate on the system.
Starting the Service
All that is left at this point is to create and start the service with the 
required protection level. This can be done in any number of ways, but it is 
most frequently done programmatically using the Win32 API. Listing 12-25 
shows an example function for doing so.
BOOL CreateProtectedService() {
SC_HANDLE hSCM = NULL;
SC_HANDLE hService = NULL;
SERVICE_LAUNCH_PROTECTED_INFO info;
 1 hSCM = OpenSCManagerW(NULL, NULL, SC_MANAGER_ALL_ACCESS);
if (!hSCM) {
return FALSE;
}
 2 hService = CreateServiceW(
hSCM,
L"MyEtWTiConsumer",
L"Consumer service",
SC_MANAGER_ALL_ACCESS,
SERVICE_WIN32_OWN_PROCESS,
SERVICE_DEMAND_START,
SERVICE_ERROR_NORMAL,
L"\\path\\to\\my\\service.exe",
Evading EDR (Early Access) © 2023 by Matt Hand
232   Chapter 12