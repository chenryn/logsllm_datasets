tions. While monitoring 403.gcc, π-CFI allows, for some
return instructions, over 1,400 return targets (Figure 3b).
While monitoring 444.namd, π-CFI allows, for some re-
turn instructions, more than 46 transfer targets (Figure 3d).
Because PITTYPAT maintains a stack of points-to infor-
mation during its analysis, it will always allow only a
single transfer target for each return instruction, over all
programs and workloads. PITTYPAT thus significantly
improves defense against ROP attacks, which are still one
of the most popular attacks software.
6.3.2 Mitigating malicious applications
To determine if PITTYPAT can detect common attacks
on control, we used it to monitor selected RIPE bench-
marks [39]. For each of the 264 benchmarks that ran in
our experimental setup, PITTYPAT was able to success-
fully detect attacks on the benchmark’s control security.
We constructed a proof-of-concept program vulnera-
ble to a COOP [32] attack that corrupts virtual-function
pointers to perform a sequence of method calls not pos-
sible by a well-defined run of the program. In Figure 4,
the program defines two derived classes of SchoolMember
(line L1–L4), Student (line L5–L10) and Teacher (line
L11–L16). Both Student and Teacher define their own
implementation of the virtual function registration()
(lines L7–9 and L13–15, respectively). set_buf() (line
L17–L21) allocates a buffer buf on the stack of size 4 (line
L18), but does not bound the amount of data that it reads
into buf (line L20). The main function (line L22–L37)
constructs instances of Student and Teacher (lines L23
and L24, respectively), and stores them in SchoolMember
pointers (lines L26 and 27 respectively). main then calls
the registration() method of each instance (lines L29–
L31), reads input from a user by calling set_buf() (line
L33), and calls Student::registration() a second time
(line L35). A malicious user can subvert control flow of
the program by exploiting the buffer overflow vulnerabil-
ity in set_buf to overwrite the vptr of Student to that of
Teacher and run Teacher::registration() at line L35.
Previous work introducing COOP attacks [32] estab-
lished such an attack cannot be detected by CFI. π-CFI
was not able to detect an attack on the above program be-
cause it allows a dynamic method as a call target once its
address is taken. However, PITTYPAT detected the attack
because its analyzer module accurately models the effect
of each load of a function pointer used to implement the
dynamic calls over the program’s well-defined runs.
public:
public:
}
}
public:
void registration(void){
void registration(void){
cout registration();
//Student calling its virtual functions
member_2->registration();
//buffer overflow to overwrite the vptr
set_buf();
//Student calling its virtual functions again
member_2->registration();
return 0;
char buf[4];
//change vptr to that of Teacher’s sensitive func
gets(buf);
Figure 4: A program vulnerable to a COOP attack.
6.3.3 Enforcing path-sensitive CFI efficiently
Table 2 contains measurements of our experiments that
evaluate performance of PITTYPAT when monitoring
benchmarks from SPEC CPU2006 and NGINX server,
along with the performance results replicated from the
paper that presented π-CFI [26]. A key feature observable
from Table 2 is that PITTYPAT induces overhead that is
consistently larger than, but often comparable to, the over-
head induced by π-CFI. The results show that PITTYPAT
incurs a geometric mean of 12.73% overhead across the
16 SPEC CPU2006 benchmarks, along with a 11.9% in-
creased response time for NGINX server over one million
requests with concurrency level of 50. Overhead of shar-
ing branch targets taken is consistently less than 5%. The
remaining overhead, incurred by the analysis module, is
proportional to the number of memory operations (e.g.,
loads, stores, and copies) performed on memory cells that
transitively point to a target of an indirect call, as well
as the number of child processes/threads spawned during
execution of multi-process/-threading benchmarks.
Another key observation from Table 2 is that PITTYPAT
induces much smaller overhead than CETS [23] and Soft-
Bound [22], which can only be applied to a small selec-
tion of the SPEC CPU2006 benchmarks. CETS provides
USENIX Association
26th USENIX Security Symposium    141
Program Features
Name
400.perlbench
401.bzip2
403.gcc
429.mcf
433.milc
444.namd
445.gobmk
450.soplex
453.povray
456.hmmer
458.sjeng
462.libquantum
464.h264ref
470.lbm
473.astar
482.sphinx3
Geo. Mean
nginx-1.10.2
KLoC
128
6
383
2
10
4
158
28
79
21
11
3
36
1
4
13
15
122
Payload Features
Exp
Tm (sec)
332
No
317
No
179
No
211
No
No
514
556
No
328
No
167
No
100
No
No
258
359
No
234
No
339
No
429
No
No
289
338
No
285
–
No
25.41
π-CFI Features
Alarm Overhd (%)
8.7%
No
1.3%
No
6.2%
No
4.3%
No
No
1.9%
-0.3%
No
11.4%
No
-1.1%
No
11.9%
No
No
0.2%
8.5%
No
-1.5%
No
8.0%
No
1.4%
No
No
2.2%
1.7%
No
3.30%
–
No
2.7%
PITTYPAT Features
Alarm Overhd (%)
47.3%
No
17.7%
No
34.1%
No
32.2%
No
No
1.8%
28.8%
No
4.0%
No
27.5%
No
16.0%
No
No
20.2%
6.7%
No
14.1%
No
11.8%
No
0.7%
No
No
22.5%
16.0%
No
12.73%
–
No
11.9%
CETS+SB Features
Alarm Overhd (%)
–
Yes
91.4%
No
–
Yes
–
Yes
Yes
–
–
Yes
–
Yes
–
Yes
–
Yes
Yes
–
80.1%
No
Yes
–
251.7%
No
–
Yes
Yes
–
Yes
–
122.60%
–
Yes
–
Table 2: “Name” contains the name of the benchmark. “KLoC” contains the number of lines of code in the benchmark.
Under “Payload Features,” “Exp” shows if the benchmark contains an exploit and “Tm (sec)” contains the amount of
time used by the program, when given the payload. Under “π-CFI Featues”, “PITTYPAT Features,” and “CETS+SB
Features,” “Alarm” contains a flag denoting if a given framework determined that the payload was an attack and aborted;
“Overhd (%)” contains the time taken by the framework, expressed as the ratio over the baseline time.
temporal memory safety and SoftBound provides spa-
tial memory safety; both enforce full data integrity for
C benchmarks, which entails control security. However,
both approaches induce significant overhead, and cannot
be applied to programs that perform particular combi-
nations of memory-unsafe operation [17]. Our results