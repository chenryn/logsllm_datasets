level origin information is collected. The origin of the main
web frame “frameOrigin” is obtained by identifying the
mainframe object in the frame tree and retrieving the last-
loaded URL from the mainframe object. It can be done by
calling “frame_tree()->GetMainFrame()->last_committed_-
url().GetOrigin().spec()”. The origin of the nested script
“ScriptOrigin” can be retrieved from the last node of the
frame stack (i.e., v8::StackTrace::CurrentStackTrace()). The
ﬂag “isProxyInvolved” is conﬁgured by checking if a
message handler is called, which is done by analyzing
the above frame stack. Currently, only the global message
handler “onmessage” is supported. We leave supporting other
message handlers as our future work.
Later, the render module packs all above origin information
together with the message content and sends them to
the content module. Finally, developers’ callback function
“Callback.onMessage()” is called with multiple level origin
information and the message content.
D. Evaluation
In this section, we present our evaluation result of OSV-Free
on its performance, effectiveness, and compatibility. In the end,
we also demonstrate that OSV-Free is easy to use.
1) Performance: To evaluate OSV-Free’s performance, we
develop a simple app to call the OSV-Free APIs. We found
that OSV-Free was fast, and only used ~2 milliseconds. The
details are shown in Table IV.
More speciﬁcally, we record the starting and ending time
of the API execution, and then compute the time difference
as the cost. However, we found it was challenging to record
the time in two different platforms. To mitigate the problem,
we select the method “Date.getTime()”, which is available in
both web and native platforms, and also record the time using
Target Item
APIs
Average
Cost Time
(milliseconds)
The ofﬁcial API
(N→W )
OSV-Free N→W
OSV-Free W→N
postWebMessage()
postMessageToMainFrame()
postMessageToNativeFrame →
receiveMessageFromMainFrame()
2.63
2.23
2.08
Table IV: The Performance of OSV-Free APIs
the same standard. The method returns the milliseconds since
midnight 01 January 1970 UTC.
2) Effectiveness: To check OSV-Free’s effectiveness, we use
OSV-Free to patch two vulnerable frameworks: the Facebook
React Native framework and the Google Print lib. We found
that the vulnerabilities could be eliminated. In N→W , only
the speciﬁed target origin can receive the message. When a
message is received, its source origin is the native frame’s
origin. In W→N, the target origin is implied in the function
postMessageToNativeFrame(), while the source origin of the
received message provides rich and correct origins.
3) Compatibility: To conﬁrm OSV-Free’s compatibility,
we installed and successfully veriﬁed OSV-Free APIs in
several popular Android versions (5.0+). These tested versions
collectively occupy ~80% distribution of the Android market
[17].
4) Case Study : Patching The Facebook React Native
Framework: To demonstrate OSV-Free is easy to use, we
apply OSV-Free to patch the Facebook React Native framework
(version 46). We found only a few minutes were used in the
process. Our patching code is mainly located in the class
ReactWebViewManager. More details are shown as follows.
First, we import the OSV-Free WebView class into the
React Native framework. To make it effective, we make the
framework’s own customized WebView (i.e., ReactWebView)
inherit OSV-Free WebView.
Then, the communication “W→N” is enhanced. Initially,
it is implemented based on a JavaScript Bridge, which is
enabled by calling two Java methods setMessagingEnabled()
and linkBridge(). Instead, in its enhanced implementation,
our API postMessageToNativeFrame() is used. To enable
postMessageToNativeFrame(), in the above two Java methods,
the Java method receiveMessageFromMainFrame() is called
instead. Please note that a callback function is pre-deﬁned as
the parameter of receiveMessageFromMainFrame() to receive
messages from web code. Once a message is received, the
received message content and multiple-level source origin
information are sent to the JavaScript engine JavaScriptCore
(by calling onMessage()), and ﬁnally forwarded to developers’
JavaScript code.
Lastly, the communication “N→W ” is also improved. It is
done by instrumenting the native method receiveCommand().
When a command “COMMAND_POST_MESSAGE” is re-
ceived for sending a message from the native frame to the
main web frame, postMessageToMainFrame() is used instead.
753
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:50 UTC from IEEE Xplore.  Restrictions apply. 
VI. RELATED WORK
A. Regular postMessage Security
In past years, several detection and defense solutions for
regular postMessage were proposed. However, all of them
are incompetent to detect or defend against OSV. Barth et al.
[22] conducted a systematic study of the frame isolation and
communication, and enhanced postMessage. However, it could
not prevent postMessage from being misused, and also did not
support hybrid postMessage. Saxena et al. [7] highlighted the
client-side validation vulnerability (CSV) in postMessage and
proposed the detection tool “FLAX”. Weissbacher et al. [8]
applied the dynamic invariant detection technique in defending
against CSV. Son et al. [6] conducted a systematic study
of CSV on a large number of popular websites, and also
proposed novel defense solutions to defend against CSV. Guan
et al. discovered DangerNeighbor attacks on postMessage, and
designed a deployable defense solution. However, they were
only available to vet or protect the message receivers of N→W ,
and could not eliminate OSV by making up the lost origins.
Furthermore, since the source origin is not always provided
due to V2, their effectiveness may be impacted.
B. Android WebView Security
Recently, WebView security has attracted signiﬁcant attention
from researchers. Luo et al. [23] explored the potential attack
vectors in WebView. Mutchler et al. [3] conducted a systematic
study on a large number of hybrid apps. Wang et al. [24]
studied the Intent abuse problem in hybrid apps. Georgiev et
al. [4] conducted a systematic study on web-mobile bridges.
Tuncay et al. [9] demonstrated the potential attacks on web-
mobile bridges. Jin et al. [25] disclosed new attack channels
for code injection attacks in WebView. Wu et al. [26] studied
ﬁle:// based attacks. Rastogi et al. [27] discovered web-mobile
bridges might be exploited by malicious content. Li et al. [28]
disclosed a novel cross-app infection attack on WebView. Yang
et al. [29] discovered a novel event oriented attack.
Several static analysis based approaches were proposed to
vet hybrid apps. However, they were not suitable to detect OSV,
since they failed to ﬁll the semantic gap between the web and
native layers. Furthermore, they all could not track origins, since
the real data was missing. Chin et al. [30] statically analyzed
WebView vulnerabilities that result in illegal authorization and
ﬁle-based attacks. Yang et al. [10] and Hassanshahi et al. [14]
proposed static analysis tools to vet hybrid apps armed with
web-mobile bridges.
Other generic detection tools were also circumscribed to
detect OSV. For example, Flowdroid [31] and Taintdroid [32]
statically and dynamically applied taint analysis in the native
layer. However, both could not ﬁll the web-mobile gap.
Several defense solutions, such as NoFrak [4], Draco [9],
MobileIFC [11], WIREframe [12], and HybridGuard [13], were
designed to provide protection for WebView and web-mobile
bridges. NoFrak and MobileIFC extended SOP into the native
layer. Draco and HybridGuard enforced security policies for
N→W by instrumenting either the chromium provide library, or
JavaScript code. WIREframe provided bidirectional protections
by directly instrumenting apps. However, as discussed in
Section I, all of them were not suitable to protect hybrid
postMessage.
VII. DISCUSSION
OSV-Hunter’s goal. Although some hybrid postMessage APIs
are implemented based on JavaScript Bridge, OSV-Hunter is
not designed to analyze JavaScript Bridge. Instead, it is used
to vet hybrid postMessage against OSV.
OSV-Hunter’s weakness. As a dynamic test tool, OSV-Hunter
may have false negatives. For example, OSV-Hunter uses the
random test tool “Monkey” to trigger WebView. However,
some apps’ WebView can only be shown when preconditions
are satisﬁed. For example, users must ﬁnish login, or a pdf ﬁle
must exist in local storage in advance. To mitigate the problem,
we assume all the preconditions are satisﬁed before our test.
Other ways to defend against V4. Developers may retrieve
the origin of the main frame through other ways, such as the
native API WebView.getUrl(), which provide the URL for the
current page. However, the API may fail and return NULL
[33]. Developers may also maintain the status of current URL
using event handlers [33]. However, this approach may also
fail, since event handlers may not be successfully triggered
[34].
VIII. CONCLUSION
In this paper, we conduct the ﬁrst systematic study on hybrid
postMessage in Android apps and identify a new type of
vulnerabilities called Origin Stripping Vulnerability (OSV). To
measure the prevalence and presence of OSV, we design a
lightweight vulnerability detection tool, called OSV-Hunter.
Our evaluation on a set of popular apps demonstrates that OSV
is widespread in existing hybrid postMessage implementations.
Guided by the evaluation results, we design three safe hybrid
postMessage APIs, called OSV-Free, to eliminate potential
OSVs in hybrid apps. We show that OSV-Free meets the
development requirements: it is secure, fast, and generic.
ACKNOWLEDGMENT
We thank all framework/library/app developers, especially
the Facebook security team, for helping us conﬁrm the OSV
issues. This material is based upon work supported in part
by the National Science Foundation (NSF) under Grant no.
1314823 and 1700544. Any opinions, ﬁndings, and conclusions
or recommendations expressed in this material are those of the
authors and do not necessarily reﬂect the views of NSF.
REFERENCES
[1] “Web messaging standard,” https://html.spec.whatwg.org/multipage/web-
messaging.html.
[2] “Same origin policy,” https://en.wikipedia.org/wiki/Same-origin_policy.
[3] P. Mutchler, A. DoupÃ, J. Mitchell, C. Kruegel, G. Vigna, A. Doup,
J. Mitchell, C. Kruegel, and G. Vigna, “A Large-Scale Study of Mobile
Web App Security,” in MoST, 2015.
[4] M. Georgiev, S. Jana, and V. Shmatikov, “Breaking and ﬁxing origin-
based access control in hybrid web/mobile application frameworks,” in
NDSS, 2014.
754
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:50 UTC from IEEE Xplore.  Restrictions apply. 
[5] S. Farhang, A. Laszka, and J. Grossklags, “An economic study of
the effect of android platform fragmentation on security updates,” in
ariv:1712.08222, 2017.
[6] S. Son and V. Shmatikov, “The postman always rings twice: Attacking
and defending postmessage in html5 websites,” in NDSS, 2013.
[7] P. Saxena, S. Hanna, P. Poosankam, and D. Song, “Flax: Systematic
discovery of client-side validation vulnerabilities in rich web applications,”
in NDSS, 2010.
[8] M. Weissbacher, W. Robertson, E. Kirda, C. Kruegel, and G. Vigna,
“Zigzag: Automatically hardening web applications against client-side
validation vulnerabilities,” in USENIX Security, 2015.
[9] G. S. Tuncay, S. Demetriou, and C. A. Gunter, “Draco: A system for
uniform and ﬁne-grained access control for web code on android,” in
CCS, 2016.
[10] G. Yang, A. Mendoza, J. Zhang, and G. Gu, “Precisely and scalably
vetting javascript bridge in android hybrid apps,” in RAID, 2017.
[11] K. Singh, “Practical context-aware permission control for hybrid mobile
applications,” in RAID, 2013.
[12] D. Davidson, Y. Chen, F. George, L. Lu, and S. Jha, “Secure integration
of web content and applications on commodity mobile operating systems,”
in ASIA CCS, 2017.
[13] P. H. Phung, A. Mohanty, R. Rachapalli, and M. Sridhar, “Hybridguard:
A principal-based permission and ﬁne-grained policy enforcement
framework for web-based mobile applications,” in MoST, 2017.
[14] B. Hassanshahi, Y. Jia, R. H. C. Yap, P. Saxena, and Z. Liang, “Web-to-
application injection attacks on android: Characterization and detection.”
in ESORICS, 2015.
[15] “Adding a security warning about osv in the facebook react native
framework,” https://github.com/facebook/react-native-website/pull/113.
[16] “Android webview message ports implementation,” https://developer.
android.com/reference/android/webkit/WebMessagePort.html.
[17] “Android version distribution: Nougat and oreo up, everything else
down,” https://www.androidauthority.com/android-version-distribution-
748439/.
[18] “Ui/application exerciser monkey,” https://developer.android.com/studio/
test/monkey.html.
[19] “An interactive tls-capable intercepting http proxy for penetration testers
and software developers,” https://github.com/mitmproxy/mitmproxy.
[20] J. Schwenk, M. Niemietz, and C. Mainka, “Same-origin policy: Evalua-
tion in modern browsers,” in USENIX Security, 2017.
[21] “The chromium projects,” https://www.chromium.org/.
[22] A. Barth, C. Jackson, and J. C. Mitchell, “Securing frame communication
in browsers,” in USENIX Security, 2009.
[23] T. Luo, H. Hao, W. Du, Y. Wang, and H. Yin, “Attacks on webview in
the android system,” in ACSAC, 2011.
[24] R. Wang, L. Xing, X. Wang, and S. Chen, “Unauthorized origin crossing
on mobile platforms: Threats and mitigation,” in CCS, 2013.
[25] X. Jin, X. Hu, K. Ying, W. Du, H. Yin, and G. N. Peri, “Code injection
attacks on html5-based mobile apps: Characterization, detection and
mitigation,” in CCS, 2014.
[26] D. Wu and R. K. C. Chang, “Indirect File Leaks in Mobile Applications,”
in MoST, 2015.
[27] V. Rastogi, R. Shao, Y. Chen, X. Pan, S. Zou, and R. Riley, “Are
these Ads Safe: Detecting Hidden Attacks through the Mobile App-Web
Interfaces,” NDSS, 2016.
[28] T. Li, X. Wang, M. Zha, K. Chen, X. Wang, L. Xing, X. Bai, N. Zhang,
and X. Han, “Unleashing the walking dead: Understanding cross-app
remote infections on mobile webviews,” in CCS, 2017.
[29] G. Yang, J. Huang, and G. Gu, “Automated generation of event-oriented
exploits in android hybrid apps,” in NDSS, 2018.
[30] E. Chin and D. Wagner, “Bifocals: Analyzing webview vulnerabilities
in android applications,” in WISA, 2013.
[31] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. Le Traon,
D. Octeau, and P. McDaniel, “Flowdroid: Precise context, ﬂow, ﬁeld,
object-sensitive and lifecycle-aware taint analysis for android apps,” in
PLDI, 2014.
[32] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. McDaniel,
and A. N. Sheth, “Taintdroid: An information-ﬂow tracking system for
realtime privacy monitoring on smartphones,” in OSDI, 2010.
[33] “Webview.geturl() returns null,” https://stackoverﬂow.com/questions/
13773037/webview-geturl-returns-null-because-page-not-done-loading.
redi-
rects,” https://stackoverﬂow.com/questions/10592998/android-webview-
not-calling-onpageﬁnished-when-url-redirects.
calling onpageﬁnished when url
[34] “Android webview not
755
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:50 UTC from IEEE Xplore.  Restrictions apply.