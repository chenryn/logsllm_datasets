title:Verified Security for Browser Extensions
author:Arjun Guha and
Matthew Fredrikson and
Benjamin Livshits and
Nikhil Swamy
2011 IEEE Symposium on Security and Privacy
Veriﬁed Security for Browser Extensions
Arjun Guha
Brown University
Matthew Fredrikson
University of Wisconsin, Madison
Benjamin Livshits
Nikhil Swamy
Microsoft Research
Abstract—Popup blocking, form ﬁlling, and many other fea-
tures of modern web browsers were ﬁrst introduced as third-
party extensions. New extensions continue to enrich browsers
in unanticipated ways. However, powerful extensions require
capabilities, such as cross-domain network access and local
storage, which, if used improperly, pose a security risk. Several
browsers try to limit extension capabilities, but an empirical
survey we conducted shows that many extensions are over-
privileged under existing mechanisms.
This paper presents IBEX, a new framework for authoring,
analyzing, verifying, and deploying secure browser extensions.
Our approach is based on using type-safe, high-level languages
to program extensions against an API providing access to
a variety of browser features. We propose using Datalog to
specify ﬁne-grained access control and data ﬂow policies to
limit the ways in which an extension can use this API, thus
restricting its privilege over security-sensitive web content and
browser resources. We formalize the semantics of policies in
terms of a safety property on the execution of extensions and
develop a veriﬁcation methodology that allows us to statically
check extensions for policy compliance. Additionally, we provide
visualization tools to assist with policy analysis, and compilers
to translate extension source code to either .NET bytecode or
JavaScript, facilitating cross-browser deployment of extensions.
We evaluate our work by implementing and verifying 17
extensions with a diverse set of features and security policies.
We deploy our extensions in Internet Explorer, Chrome, Firefox,
and a new experimental HTML5 platform called C3. In so doing,
we demonstrate the versatility and effectiveness of our approach.
I. INTRODUCTION
Like operating systems, IDEs, and other complex software
systems, web browsers may be extended by third-party code.
Extensions provide unforeseen new functionality and are sup-
ported by all major browsers. Although a precise count for
each browser is hard to obtain, various sources estimate that
a third of all users of Firefox (some 34 million) use exten-
sions [27], while the 50 most popular Chrome extensions have
each been downloaded several hundred thousand times [13].
Notwithstanding their popularity, extensions can pose a
signiﬁcant risk to the security and reliability of the browser
platform. Unlike JavaScript served on web pages, extensions
can access cross-domain content, make arbitrary network
requests, and can make use of local storage. A malicious or
buggy extension can easily void many security guarantees that
a browser tries to provide; e.g., with extensions installed, the
same-origin restriction enforced by browser to prevent cross-
domain ﬂows is easily circumvented. Additionally, extensions
affect page load times and browser responsiveness.
In light of these concerns, browser vendors have put in place
various processes to control how extensions are distributed, in-
stalled, and executed. Mozilla, for example, manages a hosting
service for Firefox extensions. Newly submitted extensions are
subject to an ad hoc community review process to identify
extensions that violate best practices, e.g., polluting the global
JavaScript namespace. In contrast, Google Chrome extensions
request privileges they need in an explicit manifest [3], and,
when installing an extension, the user is prompted to grant it
these privileges.
We view the Chrome model as a step in the right direction—
privileges in the manifest can be inspected independently of
extension code; and the browser assumes the responsibility of
enforcing access controls. However, from an empirical study
of over 1,000 Chrome extensions (Section II), we ﬁnd that
this model is often not very effective in limiting the privileges
of extensions. For example, nearly a third of the extensions
we surveyed request full privileges over data on arbitrarily
many web sites; and as many as 60% have access to a user’s
entire browsing history. In many of these cases, the language of
Chrome’s security manifests makes it impossible to state ﬁner-
grained policies to more precisely capture extension behavior.
In an effort to alleviate some of these shortcomings, we
propose IBEX, a new framework for authoring, analyzing, ver-
ifying, and deploying secure browser extensions. Our model
speaks to three main groups of principals: extension develop-
ers, curators of extension hosting services, and end-users.
While this paper focuses primarily on the subject of browser
extensions, our work is motivated by, and speaks to, several
important trends in software distribution. As evidenced by
app stores for iOS, Windows, and Android devices and web
apps in Chrome OS [32], software distribution is increasingly
mediated by a centralized, curated service. In this context,
automated software checking for both security and reliability
becomes a plausible alternative to manual vetting, since cura-
tors have the ability to reject distributing applications that risk
compromising the integrity of the ecosystem. Our work also
explores the space of policies that apply to a growing number
of HTML5 applications, running on the web, on the desktop,
a mobile device, or within a browser. (Trends in Chrome OS
suggest a convergence between these forms of applications.) A
key component of IBEX is a lightweight, logic-based approach
to policies that aims to ﬁnd a balance between resources and
rights speciﬁed at a ﬂexible level of granularity, while still
allowing for efﬁcient and reliable enforcement.
A. Overview of IBEX and contributions
We discuss the key elements of IBEX (illustrated in Fig-
ure 1) in conjunction with our technical contributions, below.
1081-6011/11 $26.00 © 2011 IEEE
DOI 10.1109/SP.2011.36
115
Browser-agnostic API for extensions. We provide developers
with an API that exposes core browser functionality to ex-
tensions. We expect programmers to write extensions in high-
level, type-safe languages that are amenable to formal analysis,
including, for example,
the .NET family of languages, or
JavaScript subsets like those explored in Gatekeeper [17]. Our
API is designed for the static veriﬁcation of extension security
and thus mediates access to features that can be abused by
buggy or malicious extensions.
A policy language for stating extension privileges. To de-
scribe an extensions privilege over speciﬁc browser resources,
we propose using a logic-based policy language. Our language,
based on Datalog, allows the speciﬁcation of ﬁne-grained
authorization and data ﬂow policies on web content and
browser state accessible by extensions. We expect policies to
be developed in conjunction with the extension code, either
authored manually by extension developers, or, in the future,
extracted automatically via analysis of extension code.
Tools for curators of an extension hosting service. We
envisage the distribution of extensions to end-users via a
curated extension hosting service, as adopted by Chrome,
or Firefox. Extension developers submit extension code and
policy to the hosting service and curators can avail of policy
analysis tools we provide to determine whether or not an
extension is ﬁt for public distribution. Speciﬁcally, we discuss
a policy visualization tool that helps a curator to estimate an
extensions access rights on speciﬁc web pages.
A formal semantics of policies and extension safety. We give
a formal notion of extension safety to deﬁne precisely when
an extension can be said to be in compliance with a policy.
A distinctive feature of our semantics is that it accounts for
an execution model that involves arbitrary interleavings of
extension code with other untrusted scripts on a web page.
Our safety property is designed to be robust with regard to
the composition of safe extension code with untrusted scripts.
Static checking of extension safety. We develop a method-
ology based on reﬁnement typing (proven sound) to verify
that extensions written in Fine [30], a dependently typed
ML dialect, satisﬁes our safety condition. Static veriﬁcation
eliminates the overhead of runtime security monitoring, and
promotes robustness of the browser platform since extensions
can never raise unexpected security exceptions. We expect
our veriﬁcation tools to be used both by extension developers
and, importantly, by curators prior to accepting extensions for
distribution.
Cross-browser deployment. We utilize multiple code gener-
ators implemented by the Fine compiler (including a new
JavaScript backend) to allow the same extension source to be
deployable in multiple browsers. A key enabler of this feature
is the use of a browser-agnostic core extension API, combined
with the use of a standard ML-like source language. To date,
we have deployed extensions in Internet Explorer 8, Chrome,
and Firefox. Additionally, we show how to deploy extensions
in C3 [23], a new platform for HTML5 experimentation
developed entirely in a type-safe, managed language.
Fig. 1: Users, developers, and curators: an overview of IBEX.
Empirical evaluation. Our evaluation includes program-
ming 17 extensions in Fine, specifying a range of ﬁne-
grained authorization and data ﬂow properties for each, and
automatically verifying them for policy compliance. Among
these 17 extensions are several ported versions of widely-used
Chrome extensions, which shows that our model also brings
beneﬁts to existing legacy extension architectures.
B. Outline of the paper
We begin in Section II by discussing existing extension
security models. Section III presents an overview of the design
of IBEX. Section IV discusses our policy language and its visu-
alization tool. Section V formalizes the semantics of policies
and our safety property. Section VI shows how to statically
verify extensions using reﬁnement type checking. Section VII
presents our experimental evaluation and discusses the code of
two extensions in detail. Section VIII discusses our support for
cross-browser deployment of extensions. Section IX discusses
limitations and future work. Section X discusses related work,
and Section XI concludes.
II. A SURVEY OF EXISTING EXTENSION MODELS
Extensions have access to browser resources not usually
available to scripts running on web pages. Unlike scripts on
web pages, which can can only affect the page on which
they are hosted, extensions can read and modify arbitrary
web pages, and can even customize browsers’ interfaces.
Extensions are also not subject
to the same-origin policy
that applies to scripts on web pages—this allows them to
communicate with arbitrary web hosts. With access to these
and other capabilities, extensions, if malicious, pose a security
risk. Moreover, since extensions interact with web pages, a
malicious page could exploit a vulnerable extension to access
capabilities that web pages do not ordinarily possess.
Below, we discuss the security mechanisms employed by
Internet Explorer, Firefox, and Chrome to motivate the design
of IBEX. Of these browsers, Chrome has the most security-
aware extension system to date. We perform a detailed study
of over 1,000 Chrome extensions to study the effectiveness
116
FineVerifierCompilerExtension codeFirefoxIEC3.NETJavaScript.NETVisualization toolsPolicyChromeextractJavaScript· Authors code and policy· Uses Fine to check code· Inspects policy using visualizer· Uses Fine to check for compliance· Hosts extension gallery· Trusts curator’s gallery· Downloads extension· Installs and uses extensionDeveloperCuratorUserof its security model and conclude that many, if not most,
extensions are unnecessarily over-privileged.
A. Internet Explorer’s extension model
Internet Explorer supports several extension mechanisms of
which browser helper objects or BHOs are probably the most
commonly used. BHOs (usually native binaries) have virtually
unrestricted access to IE’s event model and, as such, have
been used by malware writers in the past to create password
capturing programs and key loggers. This is especially true
because some BHOs run without changes to the user interface.
For instance, the ClSpring Trojan [4] uses BHOs to install
scripts to provide a number of instructions to be performed
such as adding and deleting registry values and downloading
additional executable ﬁles, all completely transparent to the
user. Even if the BHO is completely benign, but buggy, its
presence might be enough to open up exploits in an otherwise
fully patched browser.
B. Firefox’s extension model
Firefox extensions are typically written in JavaScript and
can modify Firefox in fairly unrestricted ways. This ﬂexibility
comes with few security guarantees. Extensions run with the
same privilege as the browser process, so a malicious extension
can cause arbitrary damage. Firefox extensions often employ
highly dynamic programming techniques that make it difﬁcult
to reason about their behavior [22].
To protect end-users, Firefox relies on a community review
process to determine which extensions are safe. Only exten-
sions deemed safe are added to Mozilla’s curated extension
gallery. Firefox ordinarily refuses to install extensions that do
not originate from this gallery. Users are thus protected from
unreviewed extensions, but reviews themselves are error-prone
and malicious extensions are sometimes accidentally added to
the gallery. An example of this is Mozilla Sniffer [28], an
extension which was downloaded close to 2,000 times, before
being removed from the gallery after it was deemed malicious.
C. Chrome’s extension model
Google Chrome extensions are written in JavaScript and
hosted on extension pages, but they have access to APIs that
are not available to web pages. Extension pages run in the
context of the extension process, different from the browser
processes and has the ability to both access and augment the
browser UI. Extension pages can register to listen to special
browser events such as tab switching, window closing, etc.
Extension manifests: Extensions specify their resources and
the capabilities they require in an extension manifest ﬁle.
When a user tries to install an extension, Chrome reads the
extension manifest and displays a warning. Figure 2 shows
the manifest of an extension called Twitter Extender and the
warning raised by Chrome before the extension is installed.
In this example, the manifest requests (roughly) read and
write privileges over all content on DJJF=FE>EJO and
DJJFJMEJJAH?. Additionally, this extension requires
access to events related to browser tab manipulations. In
117
KF@=JAKHDJJF?EAJI CCA?IAHLE?A
=A 6MEJJAH -NJA@AH LAHIE  !
@AI?HEFJE )@@I AM .A=JKHAI  6MEJJAH? 
F=CA=?JE    E?I    
?JAJI?HEFJI  
=J?DAI 
DJJFJMEJJAH? DJJFIJMEJJAH?
I GKAHO" EI?@AI
 
>=?CHK@F=CA >=?CHK@DJ
FAHEIIEI  J=>I DJJF=FE>EJO 
Fig. 2: A fragment of Twitter Extender’s manifest and the dialog that
prompts a user for access privileges when the extension is installed
Name
Behavior
Google Reader client
Gmail Checker Plus
Bookmarking
Dictionary lookup
JavaScript toolbox