touchwin函数。
动手试试：子窗口
1）首先是初始化代码部分。我们先用一些文字初始化基本窗口的显示情况。
linclude cunistd.h>
#include 
include 
define NUM_NAMES 14
int nain()
HINDOw *sub_window_ptt:
int x_locp:
int y_loop:
Ant counter;
加入jaVa编程群：524621833
---
## Page 194
176
Linx程序设计
char *names[NUM_NANES] = {*David Hudson,*.*ArArev Cr]la,*, “′ame: Jones,^,
*Ciara Loughran.*.
Peter Bradley,*."llancy Innocenzi.*.
“Abdul Hussain.*
‘Anre Pawson.*,*Alex Hopper.*
“Russell Thomas.·.Nazir Makandra,*1:
initscr():
for (y_loop = 0;y_1oop 'z'} a_letter ='A':
a_letter++;
2）现在来创建一个新的卷屏子窗口。根据前面的介绍，在剧新屏幕之前必须对父窗口调用
touchwin函数
sub_window_ptr = subwin(stdscr. 10, 20, 10,1C:
touchwin(stdscr):
scrollok(sub_window_ptr. 1) :
refresh(l;
sleep(1) ;
3）接下来，我们删掉子窗口里的内容，重新输出些文字，刷新它。文字的卷屏动作是由
一个循环来完成的。
werase(sub_window_ptr);
mwwprintw(sub_window_ptr,2,0.*$s*.
wrefresh(sub_window_ptr);
*This window wil1 now scroll as namcs are added *);
sleep(1) :
for（counter =O;counter
int keypad( WINbow *window_ptr, bool keypad_on 1;
把keypad_on设置为true再调用keypad函数将激活Keypad模式，curses由此开始接管按键转义
序列的处理工作。这样，读键盘操作不仅能返回被按下的键，还能返回与逻辑按键一一对应的
“KEY_”定义。
使用Keypad模式有三条小小的限制。
第一个问题是识别escape转义序列需要一定时间，而许多网络协议要么把字符打成数据包
（这会导致escape转义序列的识别不准确），要么会从某个地方开始分断它们（这将导致功能键的
转义序列被识别为Escape字符和其他彼此没有联系的字符）。在WAN网络或其他繁忙的链路上这
一情况将更为加剧。惟一的解决之道是设法对终端进行编程，让它针对用户使用的每一个功能
键发送出单个的、独一无二的字符来一—虽然这样做会限制住控制字符的数量。
第二个间题，为了让curses能够区分“单独按下Escape按键”和一个以Escape字符打头的键
盘转义序列，它就必须等待很短的一小段时间。在Keypad模式被激活之后，处理Escape按键所
造成的非常微小的延时也能被注意到。
第三条限制是curses不能处理二义性的escape转义序列。如果键盘上两个不同的按键会产生
同一个转义序列，就会让curses不知所措，不知道该返回哪个逻辑按键。curses对这种情况的处
理措施也很简单，它会放弃对这个转义序列的处理。
我们的看法是：从产品设计的角度看，既让某些按键发送escape转义序列又在键盘
上布置一个Escape键（用这个键实现“取消操作”的软件不胜枚举）的做法是一个最不
理智的决策，但我们不得不接受这个现实，而且还必须尽力搞好它。
下面这小程序keypad.c演示了Keypad模式的使用方法、在运行这个程序的时候，按下Escape
键并注意观察那个微小的延时，程序将在这段延时里判断这个Escape是一-个转义序列的开始还
是一次单独的击键动作。
加入jaVa编程群：524621833
---
## Page 196
178
Linux程序设计
动手试试：使用Keypad模式
1）程序和curses函数库的初始化工作完成之后，我们把Keypad模式设置为“TRUE”。
inelude 
include 
#include 
#define LOCAL_ESCAPE_KEY
2 7
int nain(}
in: key;
inatscr () :
keypad(stdscr, TRUE) ;
crmode () :
2）接下来，我们必须关闭回显功能以防止光标在我们按下光标键时发生移动。清屏并显示
一些文字。程序等待击键动作，如果既不是“q”也没有产生错误，就把按键对应的字符显示到
屏幕上。如果击键动作匹配上终端的某个转义序列，就把这个转义序列显示到屏幕上。
moecho () :
mvprintw(5, 5,*Key pad denonstration.Press‘q′ to quit*1:
cleaz() :
move(7, 5) ;
refresh() ;
key = getch();
while(key != &RR && key 1=*q'}(
nove (7, _5) :
clrtoeol(}:
11(.z. => ax  .V. =ax ,,=
int start_color(void):
如果终端支持彩色显示功能，has_colors例程将返回“true”。接下来需要调用start_color函
数，如果彩色显示功能的初始化操作成功了，它将返回“OK”。调用start_color对彩色显示功能
的初始化操作成功之后，变量COLOR_PAIRS将被设置为该终端所能支持的颜色组合的最大值。
最多64个颜色组合是比较常见的。变量COLORS定义了可用色彩的种类，只有八种色彩的情况
比较多见。
在把颜色用做属性之前，我们必须对准备使用的颜色组合进行初始化。这项工作可以用
init_pair函数完成。对颜色组合的存取要通过COLOR_PAIR函数来进行。
includie 
int init_pair(short pair_number, short foreground. short background) ;
int pair_content short pair_nunber. short *fotegzound, short *background):
int COLOR_PAIR(int pair_nmber} ;
curses.h通常会定义一些基本的颜色，其名称都以“COLOR_”打头。另外还有一个函数
pair_content，它的作用是对定义好的颜色组合信息进行检索。
用下面的语句可以把绿背景红前景定义为第一号颜色组合：
in1t_Dair(1, COLOR_RED, COLOR_GREEN ):
这个颜色组合就可以被用做属性了，注意下面语句中COLOR_PAIR的用法：
wattron(window_ptr, COLOR_PAIR(1) 1;
这个语句的作用是把屏幕的后续内容设置为绿色背景上的红色内容。
因为一个COLOR_PAIR就是一个属性，所以我们可以把它和其他属性结合在一起使用。在
PC个人电脑上，我们通常可以通过组合COLOR_PAIR属性和附加属性A_BOLD在屏幕上得到加
浓的额色，两个属性要按位OR在一起，如下所示：
wattron{window_ptr, CoLoR_PAIR(1) 1 A_Boup :
我们来看看这些函数在下面的color.c程序里的使用情况。
动手试试：彩色
1）首先，检查这个程序的显示终端是否支持彩色显示功能。如果它支持，就开始彩色显示。
加入jaVa编程群：524621833
---
## Page 198
180
Linux程序设计
#include 
#includo 
#include
int main(1
int i;
initser();
if (1has_colors(){
endwin() :
fprintf(stderr,*Error - no color support on this terminal\n*):
exit (1) :
(start_color(1 I= ok) {
endwin(}:
fprintf(stderr,*Error - could not initialize colors\n*);
exit (2) :
2）现在，我们可以把允许使用的颜色种类和颜色组合种类打印出来。我们将创建几个颜色
组合并把它们同时显示在屏幕上。
mvprintw(5. S. *There are ed COLORS, and d COLOR_PAIRS available*.
clear() :
COLORS,COLOR_PAIRS):
refresh():
init_pairi1,
COLOR_RED,COLOR_BLACK):
init_pair (2,
init_pair(3.
COLOR_RED, COLOR_GREEN) :
init_pair（4.COLOR_YELLOW.COLOR_BLUE);
COLOR_GREEN, COLOR_PED) ;
init_pair(5,
COLOR_BLACK,COLOR_WHITE);
init_pair(7, COLOR_CYAN, COLOR_WHITE) :
init_paiz(6,
COLOR_MAGENTA,COLOR_BLUE) :
for （i = 1; i 