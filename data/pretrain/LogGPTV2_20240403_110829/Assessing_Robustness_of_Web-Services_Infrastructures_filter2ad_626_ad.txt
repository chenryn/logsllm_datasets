Bristlecone applications have two components: high-level organization description that is used
for recovery from an error to a consistent state and speciﬁes how the applications conceptual
operations interact, and a low-level operational description that speciﬁes the sequence of instruc-
tions that comprise an individual conceptual operation.
In another study, Hui and Lui [73] argue that to ensure the function of critical services their
operation can use but should not be dependent on less critical components. Otherwise, a minor
fault can propagate “along complex and implicit dependency chains and bring down the sys-
tem” [73].
In a theoretical attempt to address this issue, they present dependency algebra, a
framework for dependency management in real-time systems. The framework allows compari-
son of diﬀerent designs from the perspective of robustness.
Adding error-handling code and design is another popular way to increase the robustness
of software. Keane and Ellman have “implemented a high-level language and runtime environ-
ment that allow failure-handling strategies to be incorporated into legacy Fortran and C analysis
programs while preserving their computational integrity” [87]. Moreover, in a series of stud-
ies, Issarny and Benatre [160, 74, 75] investigate the design and implementation of exception
handling support for architecture-based development environments.
On the other hand, Gabriel and Goldman [58] argue that achieving robustness by adding
explicit exception handlers and error detection code to the program decreases the maintainability
and increases the complexity of the system. Instead Gabriel proposes developing context-aware
programs to solve the robustness problem. The main robustness issues in context-aware systems
are [98]:
1. Failures in context-driven reconﬁgurations due to inaccessibility of services or services not
being in the correct state for performing the reconﬁguration actions.
2. Object-binding failures
13
3. Service-level operational failures
4. Context invalidations due to lack of privilege or unmet condition
Kulkarni and Tripathi [98] present a recovery model for context-aware applications which “con-
sists of mechanisms for asynchronous event handling and synchronous exception handling. Events
represent occurrence of a particular state (normal or failure) related to a context-aware applica-
tion. Exceptions represent a subclass of events that arise synchronously during the execution of
an action within a role operation or a reaction.” [98].
Another study conducted by Hameed et al. [64] proposes an aspect-oriented approach to
separate error discovery and handling from the core functionality. This can limit the cost and
time for introducing changes in the system and make the robustness and quality testing of a
system cheaper in the long run.
In a theoretical study, Ambriola and Gervasi [10] identify several diﬀerent quality attributes
such as robustness and investigate the eﬀect of factors such as separation, abstraction, composi-
tion, replication and resource sharing in architecture on these quality attributes. The result is that
replication has a positive eﬀect on robustness and resource sharing has a negative eﬀect.
Another aspect of software robustness is stability against unexpected events in the execution
environment. Choi [32] introduces a kernel resource protector which shields the kernel from
faults generated by modules. Observing the relationship between modules and resource objects,
the protector can detect and resolve misuses of kernel resources by modules.
Wrapper
Wrapping or encapsulating external modules or services is a common design method used to
improve robustness. The method aims at ﬁltering the inputs and avoid the propagation of errors
in the system.
Schmidt [144] presents the Wrapper Facade pattern to encapsulate low-level functions and
data structures with object-oriented class interfaces. “Common examples of the Wrapper Facade
pattern are class libraries like MFC, ACE, and AWT that encapsulate native OS C APIs, such as
sockets, pthreads, or GUI functions” [144]. Schmidt proposes a cohesive approach for wrapping
classes in the same pattern. He proposes the following activities for creating cohesive classes:
• Coalesce multiple individual functions into class methods
• Select the level of indirection
• Determine where to handle platform-speciﬁc variation
The aim for this encapsulation is partly to avoid robustness problems to happen or propagate.
Multilayer systems are another focus area for using encapsulation to achieve higher robust-
ness. Lu et al. [108] investigate robustness in multi-layered software architectures such as AU-
TOSAR (AUTomotive Open System ARchitecture) which is the new architecture standard in
the automotive industry. Lu et al. maintain that in such systems to minimize the error prop-
agation from one layer to the next can increase the severity of the error. They argue that the
quality of these systems relies not only on the correctness of underlying services but also on
multilevel properties. To evaluate this argument they develop a “software as a set of wrappers
checking multilevel properties at runtime. The wrappers check the correctness of the application
that depends on the behavior of the middleware (communication channels between application
components) and OS functions (task management and scheduling) despite accidental and design
14
faults that could impair both the control ﬂow and the data ﬂow of the application. They also
trigger recovery actions.” [108]
Another area of focus for robustness design is programming libraries. Most common libraries
are designed for reuse and focus on ﬂexibility, neglecting robustness requirements [55]. Frick et
al. [55, 54] investigate the trade-oﬀ between ﬂexibility and robustness. They present an object-
oriented library of algorithms and data structures with focus on robustness and ﬂexibility called
KARLA. In a similar study, De Vale and Koopman [43] present a safe/fast I/O library with
higher safety and robustness than standard I/O libraries which has the same performance. The
robustness of this library is evaluated using Ballista robustness testing tool.
In another attempt to increase the robustness of C libraries, Fetzer and Zhen [52] present the
HEALERS system. Using header ﬁles and manual pages, HEALERS automatically generates
a wrapper for each global function that performs argument checking before invoking C library
functions. HEALERS has also been used for robustness and security hardening of COTS in [154]
Other interesting results using wrappers to increase robustness can be found in [78, 24, 40,
141, 149, 7, 46].
4.1.4. Veriﬁcation and Validation
With 68 studies, robustness veriﬁcation and validation (V&V) is the largest focus group in
software robustness phases. The main technique used in this category is testing. This section is
divided into three subsections robustness benchmarks, fault injection and automated robustness
testing. Automated robustness testing tools almost exclusively use fault injection methods. How-
ever, the studies in that category have their main focus on the automated tool, unlike others that
use less sophisticated automation mechanics for fault injections and focus more on presenting
the technique they use.
Robustness benchmarks
As mentioned above, an important discussion in robustness testing is the diﬀerent methods to
benchmark the level of robustness in a system.
CRASH is the most commonly used metrics for robustness failures as presented in [95]. For
grading the severity of robustness vulnerabilities, CRASH uses 5 levels:
C Catastrophic (OS crashes/multiple tasks aﬀected)
R Restart (task/process hangs, requiring restart)
A Abort (task/process aborts, e.g. segmentation violation)
S Silent (no error code returned when one should be)
H Hindering (incorrect error code returned)
In another study, Dingman [44] uses the returned messages from an aerospace system under
robustness test to create measurements and benchmarks for robustness failures. The results are
very similar to CRASH.
Siewiorek et al. [152] present another benchmark which classiﬁes robustness failure reasons
into four categories: omissions, timing, value or state of Response, and crash. Another study
providing robustness benchmarks is [26], which presents an experience report of developing a
benchmark to measure system robustness. These metrics are used to evaluate robustness of C
15
libraries. Robustness failures were mostly found in the following parts of the libraries: task han-
dling, numeric manipulations, I0 and System protection mechanisms. A CRASH-like benchmark
was also presented for failure classiﬁcation in this study.
On a diﬀerent level, Mukherjee and Siewiorek [122] divide existing robustness benchmarks
into the following categories:
• Crashme: random data against system interfaces.
• Modular: Regard the system as isolated modules and check the robustness of each module.
• Hierarchical: decompose the software based on features and test robustness of each fea-
ture.
They also propose a hierarchical benchmark based on features and test it on C++ applica-
tions [122].
Some other robustness benchmarks included in this review can be found in [85, 117].
Fault injection
Software fault injection is the primary method used for robustness testing. Fault injection tech-
niques are classiﬁed into the following categories by [169]:
• Software implemented fault injection where faults are injected by means of software.
• Scan-chain (ﬂip-ﬂopping ICs) implemented fault injection where faults are injected to
physical system using scan-chains.
• Pin level fault injection where faults are injected to the pins of an IC.
• Fault injection by external disturbance where heavy ion radiation and power disturbance
are used for injecting faults by external disturbances.
• Fault injection in emulated systems where faults are injected to an emulated model of the
system.
Software robustness testing using fault injection uses exclusively the ﬁrst and in some cases the
last technique.
Voas et al. [164] present an automated software analysis environment called Pisces Safety Net
(PSN) which is a part of Whitebox Software Analysis Toolkit that injects faults against hardware
and software. Instead of analyzing correctness, this approach examines output behavior and aims
to analyze and avoid dangerous and life-threatening outcomes. The goal of PSN is to identify
weaknesses in software with catastrophic consequences and locate weaknesses in code. Input to
PSN is a program, an operational proﬁle, and a description of unacceptable outcomes. Based on
that, PSN returns locations in code with potential weaknesses. PSN requires some manual set-
ups for what part of the code to perform fault injection on and what is an unacceptable output.
Java applications have also been the subject of robustness fault injection tests. Zamli et
al. [169] presents SFIT, a fault injection tool to assess the dependability of Java COTS, while
Olah and Majzik [126] have developed an Eclipse-based fault injection framework that provides
a model-based approach and a graphical user interface to specify both the fault injection experi-
ments and the run-time monitoring of the results for Java applications.
16
Robustness testing of network protocols is another area of focus. Tsanchi et al. [158] test
telecommunication systems’ fault tolerance by injecting software faults into the service manager
and observing the behavior in the fault manager.
In another study, Chuanming [33] uses a formal test speciﬁcation language, TTCN, to de-
scribe test cases for robustness testing of network protocols. TTCN is also used in [140] to
create a robustness test framework consisting of two phases: (1) Creating increased speciﬁcation
by considering hazards in the speciﬁcation model (2) A method to generate robustness test cases
in TTCN-3 from the increased speciﬁcation provided in (1).
Fault injection has also been used to test and evaluate robustness of web applications. In [100]
an online tool called Wsrbench is presented for evaluation of web services. Another study that
focuses on this issue is [145], which provides a framework for testing robustness of web services.
For white-box coverage testing of error recovery code in Java web services, Fu et al. [57, 56] use
compiler-directed fault injection.
Several studies concerning robustness testing of Commercial-Oﬀ-the Shelf (COTS) were
found in the review. The interest in using COTS is rapidly increasing due to development of
more complex systems and the amount of money and time that can be saved using third-party
software. However, there is a need to evaluate the robustness and reliability of these systems
before they can be integrated into the solution. Barbosa et al. [15] present a methodology for
evaluating robustness and dependability of COTS using fault injection techniques, while Sarbu
et al. [142] provides a robustness testing method for testing operating system drivers (COTS OS
extensions) using their operational state model.
Finally, Johansson et al. [81] study the impact that varying the time for error injection has on
evaluation of software robustness. Using “call blocks (i.e. a distinct sequence of calls made to
the driver), the trigger for injection can be used to guide injections into diﬀerent system states,
corresponding to the operations carried out.”
Some other studies using fault injection techniques for robustness testing are available in [25,
137, 138, 120, 124]
Automated robustness testing
Automated robustness testing tools are common contributions in the area of software robustness.
The main idea of these tools is to use stress testing or fuzz testing to try to crash a system and
assess its robustness. Several fault injection studies mentioned earlier use this principle as well,
but since their main focus has been on the use of fault injection and not on the resulting tool, they
were discussed in the previous part.
The most well-known contribution in robustness testing is the Ballista project. In [93] Koop-
man describes the Ballista robustness testing tool. Ballista uses random and extreme values of
diﬀerent parameter types against system interfaces to test their robustness and stability against
random and extreme values. The results of Ballista testing on operating systems identify sig-