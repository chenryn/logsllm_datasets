# 2016 Worm 逆向题解题报告
|
##### 译文声明
本文是翻译文章，文章来源：360安全播报
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
题目:一款恶意软件被发现可以感染”NUS GOVT”驱动器类型U盘。恶意软件使用加密算法加密向外发送的数据。请使用以下格式提交答案: XCTF{SHA1
of(key1 + key2 + key3)}
文件:add4f352cbcb62fffe01eccf78a912b8
SHA1 Hash: 16e9245a14e223b83fde700aa6904e2f487ef07b
首先我们使用IDA看看能得到什么信息。
浏览IAT窗口,我们发现有很多SetupDI前缀的函数被调用,查询MSDN可以发现这些函数都是用来枚举即插即用设备的。
图 1、导入表
SetupDiGetDeviceRegistryProperty函数获得一个特殊的即插即用设备驱动属性。
在IDA中查看其交叉引用(IDA快捷键X),可以发现更多有用的东西,看起来这个恶意软件试图寻找一个USBSTOR类的设备。这是很正常的,因为题目中已经说到该恶意软件会感染“NUS
GOVT”类型USB驱动设备。我们之后可以在OllyDgb中下断点,看看恶意软件到底做了些什么。在调用该函数的反汇编代码中可以发现,其试图匹配字符串“NUS
GOVT”。现在我们先记下这个操作。
图 2、查看SetupDiGetDeviceRegistryProperty交叉引用
在IDA的字符串窗口,也可以发现一些有趣的东西,看起来这个恶意软件想通过autorun.inf来感染。好的,我们暂时先记下这个发现。在字符串窗口我们同样可以看到wsock32.dll,Ws2_32.dll等,但是在导入表中,我们没有发现任何调用这些库中的函数。
或许,GetProcAddress函数被使用了。
图 3、autorun.inf在strings表中
现在,我们打开Ollydbg。遇到访问违例(Access Violation),向上回溯我们会发现,恶意软件使用了反调试机制。
图 4、访问违例
代码中,如果发现有调试器存在,就会jmp
到0x4141FD+1,否则跳转到0x4041F4,我们可以简单的设置新的origin为0x4041F4来绕过这个反调试机制。
图 5、fs[18h]
我们在地址0x4026D1处下断点,根据图2这里是比较字符串“NUS GOVT”的位置。如下图所示:
图 6、匹配驱动器名称 NUS GOVT
下面我们手工将当前的驱动器名称修改为“NUS GOVT”,如下图所示:
图 7、修改驱动器名称为 NUS GOVT
继续运行该二进制代码。。。
程序再一次崩溃,但是这一次,有一些文件被拷贝进了我们的usb驱动器中。
图 8、autorun.inf
似乎有一些二进制文件拷贝到了RECYCLER文件夹中,而且是隐藏文件,我们使用“attrib –h -s”来显示这些隐藏的文件。
图 9、拷贝的二进制文件
将二进制文件在IDA中加载分析,似乎这个二进制文件和该恶意软件是仙童的,但是它们的文件哈希不一样。在Ollydbg中打开文件,同样发现了反调试代码。我们依然在0x4026D1处下断点,然后修改驱动器名称为“NUS
GOVT”。为了方便我直接点击run运行然后监控所有的动态信息。WireShark捕捉到了一些http通信流。
图 10、捕获的http 通信数据
记得之前我们怀疑程序中使用了GetProcAddress,我们在字符串表中发现了与socket相关的动态链接库,但是我们在导入表中没有发现任何与网络通信相关的函数被调用。所以,我们在函数GetProcAddress出下断点,查看是否能发现有用的东西。
图 11、通过GetProcAddress获得WSAStartup函数
返回到用户空间代码,我们在Ollydbg中看到如下图所示的混淆代码:
图 12、混淆代码
我们使用OllyDbg重新分析上述代码,得到如下图所示的汇编代码:
图 13、OllyDbg重新分析出来的汇编代码
分析上述代码,我们发现,与nus.edu.sg/ctf.php的外部通信连接,通过参数传递了一些数据,附加到user
agent字符串中。我们返回寻找调用该函数的代码。
图 14、加密数据?
看起来调用代码函数@0x403210被保护了,因此即使在这里设置一个软中断,也不会起作用,因为这里的代码是运行时重建的。在这种情况下,我们需要使用硬件中断。在调用0x403210之前,函数@0x401FD0被调用了两次来解混淆0x403210处的混淆代码。在调用了0x403210处函数之后,再次调用@0x401FD0来重新混淆代码。
图 15、向外发送数据
从图15中,我们发现了一个模式,似乎在上述发送数据函数0x403210调用之前,函数@0x401090解混淆&重新混淆了3次。
图 16、0x401090 处加密函数
在0x401090处下断点,我们可以发现一些十分有趣的现象。这个函数在传递我的计算机名称和一个字符串(可能是加密密钥)。
图 17、发现key1
继续两次进入断点,我们可以获得所有的3个key(前面已经发现有三次加密混淆操作)。
图 18 key2找到
图 19、key3找到
因此这一题的falg应该是
sha1(“MED DNI PTS oRTO RUO VAN MOC iASP VED MDA IONDEADBEEFNU5_MA5T3R”)
XCTF{1f5020e4c091d1464c16c157bc0e56f3d81a3b3a}
提交之后,错误!
这个flag不正确,回忆一下autorun.inf,这里有几个传递的参数,参见图8.
我们试试使用这几个传递的参数重新进行上述步骤…
图 20、得到了不同的key2
结果,我们得到了一个不同的key2
sha1(“MED DNI PTS oRTO RUO VAN MOC iASP VED MDA IONMEDiCINENU5_MA5T3R”)
所以真正的Flag是: XCTF{db8496580ff636bc51ade827d1999d32d5dabb1c}
提交,结果正确