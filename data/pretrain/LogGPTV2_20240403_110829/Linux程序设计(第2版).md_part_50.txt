关系（main.c和a.h）、2.o的下级依赖关系（2.c、ah和b.h）和3.o的下级依赖关系（3.c、b.h和c.h）。
也就是说，main.o受main.c和a.h文件中修改的影响.如果这两个文件发生了变化，就需要通过重
新编译main.c文件来重建它。
这些规则在制作文件里的写法是：先写出目标的名字，然后紧跟着一个冒号，任意个空格
或制表符，最后是用一个空格或制表符隔开的文件清单，清单里的文件将用来生成该目标文件。
与我们的例子相对应的依赖关系如下所示：
myapp: main.o 2.o 3.o
maiu.o: noxn,c a.h
uq y'e o' :0
q' u*q * 0*
它长示myapp依赖于main.o、2.0和3.o，而main.o又依赖于main.c和a.h，等等。
这组依赖关系构成一个树状结构，源文件之间的联系一目了然。我们可以非常清楚地看到：
如果b.h发生了变化，就需要改动2.o和3.o，而既然2.o和3.o变化了，整个myapp也将重建。
如果我们想一次制作多个文件，就可以利用名义上的目标all。假设我们的应用软件是由一
个二进制文件myapp和一个使用手册页myapp.1组成的，我们可以用下面这行进行定义：
α11: myapp myapp.1
如果我们没有使用一个all目标，make命令就将只创建它在制作文件里找到的第一个目标。
2.规则
规则是制作文件里的第二部分内容，它们定义了目标的创建方式。那么，在我们上面的例
子里，如果make确定需要重建2.o，它将使用哪条命令呢？很简单，使用“gcc·c2.c”命令就足
够了（我们将在后面的内容看到，make命令其实知道不少的缺省规则）。那如果我们想定义一个
头文件子目录，或者如果我们想为今后的调试工作设置一些符号链接信息又该怎么办呢？这就
需要我们在制作文件里对某些规则做明确的定义。
讲到这，我们遇到了制作文件奇怪面又槽糕的语法现象：一个空格和一个制表符是有区别的。
规则所在的行必须以一个制表符开始，用空格是不行的。因为几个连续的空格和一
个制表符看起来很相似，又因为空格和制表符在UNIX程序设计几乎所有的其他方面都
没有太大的区别，所以这经常会引起一些问题。此外，如果制作文件中的某一行是以一
个空格结尾的，它就会引起make命令执行的失败。
这是一个历史遗留问题，面且因为已经有太多制作文件存在着了，所以即使想改正它也有
些力不从心，自己多注意吧！如果缺少了制表符，make命令就不会工作，这多少可以让我们
“死的明占”。
动手试试：一个简单的制作文件
加入jaVva编程群：524621833
---
## Page 263
第8章开发工具245
大多数规则都带有一个也能在命令行上敲人执行的简单命令。就我们的例子来说，我们使
用Makefile1做为制作文件的文件名：它的内容如下所示：
myapp: main.o 2.o 3.o
gcc -o myapp main.o 2.o 3.o
main.o: main.c a.h
gcc -C nain.c
2.o: 2.c a.h b.h
gcc -c 2.c
3.o: 3.c b,h c.h
gcc =c 3.c
因为我们的制作文件没有使用常见的缺省文件名makefile或Makefile，所以我们将在调用
make命令时给它加上一个“-r”选项。如果我们在一个没有任何源文件的子目录使用这个命令，
就会出现下面这样的情况：
Smake -E Makefile1
 No rule to make target main.c'. reeded by *maan.o'.Stup.
$
make命令假定制作文件里的第一个目标myapp是我们想要创建文件。它会对其他依赖关系
做进一步检查，最终确定需要有一个main.c文件。因为我们还没有创建这个文件，制作文件里也
没有说怎样才能把它创建出来，所以make会报告出现一个错误。创建这个文件之后我们再米试
试。因为我们只对结果感兴题，所以不妨把这些文件弄得简单点儿。头文件可以是空的，所以
我们可以用touch命令来创建它们。如下所示：
S touch .h
S toech b.h
S touch c.b
main.c文件里包含着main函数，它调用了function_two和function_thrce两个函数；而
function_two和function_three这两个函数是在另外两个文件里定义的。这个源文件通过“#
include”语句包括上相应的头文件，使它们看起来就好象是依赖于这两个头文件的内容似的。
它其实算不上是个应用程序，下面是它的程序清单：
#include 'a.h*
/*main.c */
extern void functicn_two():
extern void function_three(}:
int main()
function_two () :
function_three():
exit (EXIT_SUCCESS);
#inciude *a.h*
/*2.c*/
#include *b.h*
yoid funetion_two(){
加入jaVa编程群：524621833
---
## Page 264
246
Linux程序设计
/* 3.c */
include *b.h"
#include *c.h"
void function_three()(
我们再次执行make命令，如下所示：
nake -f Makefilel
gccc2.c
gcc ·c main.c
gccc3.c
这是一次成功的制作。
操作注释：
make命令对制作文件中定义依赖关系的部分进行了处理，确定好需要创建的文件和创建它
们的序。虽然我们把创建myapp的规则列在最前面，make还是能够找出创建文件的正确顺序。
接下来，它调用我们在规则部分给出的命令创建出相应的文件。make命令会在执行过程中把命
令显示出来。现在来看看我们的制作文件能否正确地处理好对文件b.h进行了改动的情况。
q gonoa S
S make -f Hakefilel
gccc2.e
gcc
-c 3.c
gcc -o myapp main.o 2.o 3.o
make命令读了我们的制作文件，确定了重建myapp所需要的最少命令，并以正确的顺序执
行了它们。我们来看看如果删掉个日标代码文件会发生什么样的事情。
Smake -f Makefilel
m2.0
gee -c 2.e
gcc -0 myapp main.o 2.o 3.o
$
make再次正确地确定出需要采取的动作。
8.2.3制作文件中的注释
制作文件中以井字号（#）开始的文本行就是注释行，它一直延续到这一行的结束。制作文
件中的注释与C语言程序中的作用相同，可以帮助程序的编写者和其他人弄明白这个文件到底是
用来干什么的。
8.2.4制作文件中的宏
即使这是make命令和制作文件中仅有的东西，它们仍会是对多文件项目进行管理的有力武
器。对由非常大量的文件构成的项月来说、其制作文件也相应的会比较庞大，比较不灵活。制
加入jaVa编程群：524621833
---
## Page 265
第8章开发工具
作文件允许使用宏定义，这使我们能够按普通化的格式把它们写出来。
制作文件中的宏定义语句的写法是“MACRONAME=value”，引用宏的办法是在需要使用
“$MACRONAME”这样的写法。如果想把一个宏定义名设置为空白，可以在等号（=）后面什
么都不写。
在制作文件里，宏定义通常被用做编译器的命令选项。在软件的开发过程中，般做法是
把调试信息包括在它的编译结果里，先不对它进行优化。面到了发行它的时候，往往又需要反
过来做：不包含调试信息的二进制代码一般比较短小，运行得也更快。
Makefilel的另外一个问题是它假设编译器的名字是gcc。在其他UNIX系统上，我们使用的
可能是cc或c89。如果我们想为另一个UNIX版本编写一个制作文件，或者只是想在现有系统比
使用另外个编译器，就需要对制作文件中的几行语句进行修改，让它能够完成我们要求的工
作。而宏定义正是收集这些与系统有关的各种信息的好办法，这使得对它们的修改更容易进行。
宏通常都是在制作文件里面定义的，但也可以在调用make命令的时候在命令行上给出宏定
义，比如“makeCC=c89”这样。命令行上的宏定义将替换制作文件中的定义。
动手试试：带宏定义的制作文件
下面是我们制作文件的一个改进版本，它使用了宏定义，我们给它起名为Makefile2。
al1: myapp
which compiler
CC - gec
#where are include files kept
INCLUDE =
Options for developaent
Options for release
$ CFLAGS s-0 -Wa11-ansi
myapp: main.o 2.o 3.0
00u d o-）
main.o: main,c a.h
2.o: 2.c a.h b.h
S(CC)-IS(INCLUDE)$(CFLAGS)-C2.C
3.0: 3.c b.h e.h
删掉刚才的旧安装，再用这个新制作文件建立-个新安装。我们将看如下所示的输出内容：
$rm.oayapp
Smake -f Makefile2
[eM-6-I-3b
336
-su-e--
-ansi -c 2.c
gcc -0 myapp ma1n.o 2.o 3.0
加入jaVa编程群：524621833
---
## Page 266
248
Linux程序设计
操作注释：
make命令会把“S（CC)”、“S（CFLAGS)”、和“S（INCLUDE)”替换为相应的定义，这一点
与C语言中的“#define”语句很相似。现在，如果我们想改变编译器命令，只需在制作文件里
修改一条语句就可以了。
事实上，make内部本身就带有一些特殊的宏定义，它们可以使制作文件更简洁。我们把几
个常用的列在下面的表里，读者很快就可以在操作示例中看见它们。这些宏定义是在使用前才
展开的，所以宏定义的含义会随着制作文件的进展而发生变化。事实上，如果宏定义的用法不
是这样，它们就没有太大的用处见表8-1。
表8-1
2$
当前目标最近一次被修改时的改动清单
9$
当前目标的名字
S<
现在正被处理看的文件的名字
$*
现在正被处理着的文件的名字，不带任何后缓
在制作文件里我们还经常会看到另外两个特殊字符，它们出现在命令的前面。
“”告诉make不要理会任何错误。比如说，如果你想创建一个子目录，但不想看到任何出
错信息（如果子目录已经存在就会给出一条错误信息），就可以在mkdir命令的前面加上一个减
号“”。我们很快就可以在例子里看到“”了。
“@”告诉make在执行一条命令之前不要把命令本身输出到标准输出去。当你想用echo语句
给出一些提示信息的时候，这个字符正好派上用场。
8.2.5多个制作目标
经常会出现有不止一个目标文件的情况，人们也经常把几组命令放在同一个软件里。通过
扩展我们的制作文件就能达到这一目的。我们将在下面增加一个“clean”选项和一个“install”
选项，前者的作用是删除不再需要的目标代码文件，而后者的作用是把应用程序移动到另一个
子自录里去。
动手试试：多个制作目标
这里是制作文件下一个版本Makefile3文件的内容：
@deu :19
which compiler
CC * gcc
where to install
INSTDIR = /usr/loca1/bin
where are include files kept
#Options for development
--6-=0
加入jaVa编程群：524621833
---
## Page 267
第8章开发工具
249
-1990-= #
 Cptions for release
myapp: main.o 2.o 3.0
$(CC) -o myapp main.o 2.o 3.0
main.o: main.c a.h
(CC)-IS(INCLODE）$(CFLAG6)2.C
clean:
rn main.o 7.o 3.0
install: myapp
if[-d S（INSTDIR ]:\
then \
cp myapp $(INSTDIR）;\
churod a+x S(INSTDIR)/eyapp:\
else \
这个制作文件有几个需要大家注意的地方。首先，特殊目标all还是只定义了myapp这-个目
标。因此，如果我们在执行make的时候没有指定目标，其缺省行为还将是创建目标myapp。如
果后续命令必须在它前面的所有命令都执行成功的前提下才会执行，我们在写出这些命令的时
候就必须把它们用“&&”连接起来，如下所示：
if [ -d sINSTDIR1 1:
then
y dIS） x+eo
chmod og-w S1INSTDIR/nyapp&k\
else\
echo*Sorry.S(INsrDIR) dces not exist′:false :\
fi
大家应该还记得我们曾经在shell程序设计那一章里见过“&&”，它的作用是把shell命令
“与”在一起，每一个后续命令只有在前面的命令都执行成功的前提下才会被执行。在这一章里，
我们并不需要过分关心前面命令的执行是否成功，所以今后将坚持使用简单的写法。
还需要注意的地方是那两个新增加的目标clean和install。目标clean使用rm命令射除了目标
代码文件。这个命令的前面加上了一个减号（-），告诉make不理会这条命令的执行结果，也就
是说，即使rm命令因为目标代码文件不存在而返回了一个错误，“makeclean”也会成功。制作
make总会认为这个目标已经过了期，只要把clean指定为一个目标，就会执行它的规则。
目标install依赖于myapp，所以make会知道在执行制作install的其他命令之前必须先创建出
myapp来。install的制作规则是由几个shell脚本程序命令组成的。make会启动一个shell来执行规
则，并且每一条规则都会启动-个新的shell，所以我们必须在上面每一行代码的尾部都加上一
个反斜线字符，让所有这些shell脚本程序命令在逻辑上成为一个完整的命令行，传递到一个被
加入jaVa编程群：524621833
---