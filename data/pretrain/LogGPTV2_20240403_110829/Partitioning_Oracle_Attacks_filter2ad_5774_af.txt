216
218
BW
q
1.0
1.4
0.9
1.0
1.5
4.0
12.0
60,255
30,085
69
27
18
18
19
Figure 6: (Left) Success rate achieved for different numbers q of
partitioning oracle queries. (Right) The maximum total bandwidth
(BW) in megabytes and number of queries required to guarantee a
20% success rate.
problem, which is known to be NP-hard but relatively easy to
solve (q.v., [44]). Pragmatically for the k, q, and ˆp we found
that the following simple heuristic works well. First check if
the top k passwords by probability have aggregate mass less
than 50%. If so, set P to those top k passwords. Otherwise,
perform the classic greedy heuristic that starts with two empty
sets P,P(cid:48). Then in order of decreasing probability, add each
password to whichever of the two sets has smaller aggregate
mass, initially starting with P and stopping when |P| = k.
The attacker can then use the partitioning oracle with P as
described above to learn if pw ∈ P. If so it recurses by setting
D = P and otherwise D = D \ P.
Attack performance. We use simulations using the datasets
described in Section 4 to evaluate the efﬁcacy of the attack,
compared to brute force. We compute up to q = 100 the set
of passwords that will be successfully recovered by the attack
for k ∈ {1,2,210,212,214,216,218}. We then calculate their
aggregate probability according to their distribution in Ptest,
yielding the success rate (the percentage of times the attack
will succeed). Again note that the maximum success rate
is 70% for these simulations.
Figure 6 summarizes the simulation results. The graph
(left) shows that in a bruteforce search (k = 1), only 3% of
passwords can be found with 100 queries. The partitioning
oracle attack does signiﬁcantly better. The curves for k > 2
exhibit an initial exponential growth in success rate, which
then tapers off to a logarithmic growth. This shift occurs at
around log2(k) for each value of k because: (1) the ﬁrst set
P almost always contains the most probable k passwords,
and (2) the attack needs around log2(k) queries to recover
passwords from this set. Growth then tapers off because the
popularity of passwords found with further queries decreases.
What this means is that for, e.g., k = 210 which corresponds
to a ciphertext length of 16.4 kB, an attacker can achieve 20%
success with just 100 queries. For k = 218 the attack obtains
20% with only 19 queries, and 57% with 100 queries.
The right table in Figure 6 shows the total bandwidth and
number of queries used by each attack to guarantee a 20%
success rate. Despite the linear dependence of k on ciphertext
length, partitioning oracles can use about the same bandwidth
(k = 212) compared to brute-force search, while decreasing
the query cost by 2,228×.
Attack viability with TLS integration. We must imperson-
ate the server to build a partitioning oracle. Here we study if
the attack still works if OPAQUE is integrated with TLS, as
suggested by the paper and a later internet-draft [76].
One suggested integration is to run OPAQUE login within
an outer TLS session. The server is authenticated to the client
(via TLS’s cert auth) before the client begins the OPAQUE
login protocol, preventing server impersonation. If the PKI is
compromised or circumvented the attack can still work. The
draft [76] also suggests using the server’s OPAQUE private
key for its TLS signature. The server public key is sent to the
client in C. (The document notes “there is no need to send a
regular TLS certiﬁcate”.) Because the client must decrypt C
before it can check the signature, our attack is possible.
6 Countermeasures
The partitioning oracle attacks against Shadowsocks and non-
compliant OPAQUE implementations represent just two ex-
amples of a broader problem. We discuss more vulnerable
or possibly vulnerable cryptographic tools and protocols in
Appendix A, including the Age tool [79], the draft HPKE
RFC [10], IKEv1 with passwords as pre-shared secrets [32],
password-based encryption in the Java Web Encryption stan-
dard [40], and proposed Kerberos extensions [35, 36]. We
responsibly disclosed our results to relevant parties, and in
several cases worked with developers to explore remediations.
Here we discuss these efforts as well as longer-term ﬁxes.
Immediate mitigations.
In many cases partitioning oracle
vulnerabilities can be mitigated by: (1) length limitations on
ciphertexts and/or (2) entropy requirements on shared secrets.
For example, in response to our disclosure, the developer of
the age tool enforced ciphertext length limits to ensure that
splitting ciphertexts generated by our attack can have degree
at most k = 2 [3]. This limits a partitioning oracle attack to a
factor-2 speedup over brute force. The HPKE draft RFC [10],
after we disclosed to the authors, was updated to require use
of high-entropy secrets, effectively barring human-chosen
passwords. This makes the attack infeasible.
When we disclosed our attack to several prominent mem-
bers of the Shadowsocks community and Outline’s tech lead,
the Shadowsocks developers took immediate action to disable
UDP proxying where it was enabled by default. We discussed
possible mitigations at length; because all require a breaking
protocol change, the developers elected not to deploy them.
The most recent OPAQUE draft standard speciﬁes an
ad hoc committing AEAD scheme, obviating the concern
USENIX Association
30th USENIX Security Symposium    207
that future (compliant) implementations will choose a non-
committing AEAD scheme. With the current parameter rec-
ommendations, the OPAQUE protocol only needs a six-block
AE ciphertext; thus, implementions could also limit the ci-
phertext size as a defense-in-depth measure.
Modifying schemes to be committing. The mitigations
above are application-speciﬁc, and in some cases they do not
completely prevent partitioning oracle attacks. This leaves
open the question of how to ﬁx the root cause of vulnerability,
the use of non-committing encryption.
One approach would be to attempt to retroﬁt existing pop-
ular AEAD schemes to render them committing. A trans-
form suggested by NIST [78] and an early OPAQUE draft
appends an all-zeros block to a message before encrypting
with AES-GCM, and, during decryption, checks that resulting
plaintext includes the zeros block. This technique can be for-
mally shown to be committing when used with AES-GCM as
well as XSalsa20/Poly1305 and ChaCha20/Poly1305. How-
ever, security relies on implementations avoiding timing side-
channels that allow distinguishing between decryption failure
(the authentication tag is wrong) and a zeros-check failure.
Avoiding such timing channels will be difﬁcult given cur-
rent cryptographic library interfaces. The natural implemen-
tation approach is to call a decryption API and only perform
the zeros check should that API call succeed. But this may
give rise to an observable timing difference, re-enabling the
attack: a splitting ciphertext ˆC would pass the decryption API
and trigger a (failed) zeros check if fpw( ˆC) = 1 while the zero
check would be skipped should fpw( ˆC) = 0. We performed
an experiment to test such a side-channel in the context of a
modiﬁed OPAQUE implementation. While there was some
timing difference, the experiment was ultimately inconclusive.
We give more detail in the full version.
Side channels can be avoided if the zeros check happens
in decryption before checking the authentication tag. Current
APIs for AES-GCM and other schemes cannot partially de-
crypt a ciphertext (in other contexts this would be dangerous),
so libraries will need to be rewritten.
Moving to commiting AEAD. Unfortunately no current
standards specify a committing AEAD scheme, such as single-
key4 Encrypt-then-HMAC [29]. We therefore suggest stan-
dardizing suitable committing AEAD schemes, including
zeros-check variants of AES-GCM and XSalsa20/Poly1305.
For general purpose AEAD where the danger of partitioning
oracles or other non-committing vulnerabilities (e.g., [21])
cannot be a priori ruled out, we believe committing AEAD
should be the default. In particular, all password-based en-
cryption should use committing AEAD.
4Using a single key is important: a draft standard [57] for AES-CBC-then-
HMAC uses distinct AES and HMAC keys, making it non-committing [29].
7 Related Work
A PAKE protocol by Gentry, MacKenzie, and Ramzan [27]
introduced the use of password-based encryption to protect
protocol secrets in asymmetric PAKEs. Unlike OPAQUE,
which begins with an OPRF, their protocol begins with a
symmetric PAKE. The security of the symmetric PAKE rules
out a partitioning oracle attack.
Mackenzie [55] gave a PAKE relaxation where a bounded
number of guesses can be checked in each impersonation
and proved a SPEKE variant [37] allows testing only two
passwords per impersonation. This can be viewed as a formal
approach for allowing (limited) partitioning oracle attacks.
Two prior attacks on PAKE protocols are relevant to our
work. The ﬁrst is the two-for-one attack [85] on an early ver-
sion of SRP, mentioned in Section 2. The attack allowed an
adversary to check two passwords with one server imperson-
ation. This can be viewed as a partitioning oracle attack, and
falls into the more general framework we introduce.
Dragonblood [80] is an attack on the Dragonﬂy PAKE
used in WPA3 [31]. Their attack uses side channels to recover
passwords against a WPA3 server, due to a non-constant-time
hash-to-curve algorithm that is applied to passwords. They
take (remote) measurements and then use that to reﬁne an
ofﬂine brute force attack against the password, and do not use
an adaptive attacks with specially crafted protocol messages
to elicit certain behaviors. One could potentially turn the
Dragonﬂy side-channel into a partitioning oracle, which we
leave to future work.
Our attacks fall into a broader class of decryption error
oracles attacks, which also includes padding oracles attacks [6,
7, 17, 69, 81] and format oracle attacks [8, 26]. All these types
of attacks involve adaptive CCAs that enable speeding up
recovery of some secret data. Our attacks recover information
about decryption keys, rather than plaintexts.
Also related to our work are a series of password-recovery
attacks against APOP, an authentication protocol for email,
that showed that with server impersonation MD5 collisions
can be used to recover a user’s APOP password [50,70]. Their
techniques are speciﬁc to MD5.
Finally, our multicollision attacks against AES-GCM can
be seen as a generalization of the two-key multi-collision used
in the invisible salamander attack [21] against Facebook’s
message franking protocol (q.v., [29]). Our results show how
to collide more keys, and identify new places where non-
committing encryption leads to subtle vulnerabilities.
8 Conclusion
We introduced partitioning oracle attacks, which exploit a
new type of decryption error oracle to learn information
about secret keys. We showed how to build AES-GCM ci-
phertexts that decrypt under a large number of keys, what we
208    30th USENIX Security Symposium
USENIX Association
call a key multi-collision attack. We gave more limited at-
tacks against XSalsa20/Poly1305, ChaCha20/Poly1305, and
AES-GCM-SIV. In case studies of ShadowSocks and early,
non-compliant implementations of the OPAQUE protocol, we
demonstrate partitioning oracle attacks that can efﬁciently re-
cover passwords. We responsibly disclosed the vulnerabilities,
and helped practitioners with mitigations.
The non-committing AEAD schemes exploited by our at-
tacks are in wide use, and more tools and protocols are likely
to have vulnerabilities. Looking ahead, our results suggest
that future work should design, standardize, and add to li-
braries schemes designed to be committing. A starting point
would be to improve the performance of, and work towards
standardizing, existing committing AEAD designs [21, 29].
Acknowledgements
The authors thank Hugo Krawczyk for helping us design an
early version of the partitioning oracle attack in Section 5 and
giving extensive feedback on early drafts of the paper. We also
thank Mihir Bellare, Scott Fluhrer, David McGrew, Kenny
Paterson, and Chris Wood for helpful feedback on early drafts.
References
[1] opaque.
2019.
https://github.com/gustin/opaque,
[2] opaque.
opaque, 2019.
https://github.com/noisat-labs/
[3] age: mitigate multi-key attacks on ChaCha20Poly1305.
https://github.com/FiloSottile/age/commit/
2194f6962c8bb3bca8a55f313d5b9302596b593b,
2020.
[4] opaque-rs.
https://github.com/Lldenaurois/
opaque-rs, 2020.
[5] Michel Abdalla, Mihir Bellare, and Gregory Neven. Ro-
bust encryption. In TCC, 2010.
[6] Nadhem J Al Fardan and Kenneth G Paterson. Lucky
thirteen: Breaking the TLS and DTLS record protocols.
In IEEE S&P, 2013.
[7] Martin R Albrecht and Kenneth G Paterson. Lucky
microseconds: a timing attack on amazon’s s2n imple-
mentation of tls. In EUROCRYPT, 2016.
[8] Martin R Albrecht, Kenneth G Paterson, and Gaven J
In
Watson. Plaintext recovery attacks against SSH.
IEEE S&P, 2009.
[9] Nadhem J. AlFardan, Daniel J. Bernstein, Kenneth G.
Paterson, Bertram Poettering, and Jacob C. N. Schuldt.
On the security of RC4 in TLS. In USENIX Security,
2013.
[10] R.L. Barnes, K. Bhargavan, and C. Wood. Hybrid pub-
lic key encryption, 2020. https://tools.ietf.org/
html/draft-irtf-cfrg-hpke-04.
[11] Here come the ⊕ ninjas.
https://tlseminar.
github.io/docs/beast.pdf, 2011. ekoparty.
[12] Gabrielle Beck, Maximilian Zinkus, and Matthew Green.
Automating the development of chosen ciphertext at-
tacks. In USENIX Security, 2020.
[13] Daniel J. Bernstein. The Poly1305-AES Message-
Authentication Code. In IACR FSE, 2005.
[14] Daniel J Bernstein. ChaCha, a variant of Salsa20. In
Workshop Record of SASC, volume 8, pages 3–5, 2008.
[15] Daniel J. Bernstein. The Salsa20 Family of Stream
Ciphers. In New Stream Cipher Designs - The eSTREAM
Finalists. 2008.
[16] Daniel J Bernstein, Tanja Lange, and Peter Schwabe.
The security impact of a new cryptographic library. In
LATINCRYPT, 2012.
[17] Daniel Bleichenbacher. Chosen ciphertext attacks
against protocols based on the RSA encryption standard
PKCS# 1. In CRYPTO, 1998.
[18] Wieb Bosma, John Cannon, and Catherine Playoust. The
Magma algebra system. I. The user language. J. Sym-
bolic Comput., 1997.
[19] Tatiana Bradley, Jan Camenisch, Stanislaw Jarecki, Anja
Lehmann, Gregory Neven, and Jiayu Xu. Password-
authenticated public-key encryption. In ACNS, 2019.
[20] Julio Casal. 1.4 Billion Clear Text Credentials Discov-
ered in a Single Database. 2017.
[21] Yevgeniy Dodis, Paul Grubbs, Thomas Ristenpart, and
Joanne Woodage. Fast message franking: From invisible
salamanders to encryptment. In CRYPTO, 2018.
[22] Pooya Farshim, Benoît Libert, Kenneth G Paterson, and
Elizabeth A Quaglia. Robust encryption, revisited. In
PKC, 2013.
[23] Pooya Farshim, Claudio Orlandi, and R˘azvan Ro¸sie. Se-
curity of symmetric primitives under incorrect usage of
keys. In IACR FSE, 2017.
[24] Dennis Felsch, Martin Grothe, Jörg Schwenk, Adam
Czubak, and Marcin Szymanek. The dangers of key
reuse: practical attacks on IPsec IKE. In USENIX Secu-