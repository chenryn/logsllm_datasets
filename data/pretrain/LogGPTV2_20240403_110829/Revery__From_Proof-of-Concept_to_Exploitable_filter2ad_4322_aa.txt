title:Revery: From Proof-of-Concept to Exploitable
author:Yan Wang and
Chao Zhang and
Xiaobo Xiang and
Zixuan Zhao and
Wenjie Li and
Xiaorui Gong and
Bingchang Liu and
Kaixiang Chen and
Wei Zou
Revery: From Proof-of-Concept to Exploitable
(One Step towards Automatic Exploit Generation)
Yan Wang
Chao Zhang∗
PI:EMAIL
CAS-KLONAT§, IIE, CAS†
School of Cyber Security, UCAS¶
PI:EMAIL
Institute for Network Sciences and
Cyberspace, Tsinghua University
Xiaobo Xiang
PI:EMAIL
CAS-KLONAT§, IIE, CAS†
School of Cyber Security, UCAS¶
Beijing, China
Xiaorui Gong∗
Beijing, China
Wei Zou
PI:EMAIL
CAS-KLONAT§, IIE, CAS†
School of Cyber Security, UCAS¶
Beijing, China
PI:EMAIL
CAS-KLONAT§, IIE, CAS†
School of Cyber Security, UCAS¶
PI:EMAIL
CAS-KLONAT§, IIE, CAS†
School of Cyber Security, UCAS¶
PI:EMAIL
CAS-KLONAT§, IIE, CAS†
School of Cyber Security, UCAS¶
Beijing, China
Zixuan Zhao
Beijing, China
Bingchang Liu
Beijing, China
Wenjie Li
Beijing, China
Kaixiang Chen
PI:EMAIL
CAS-KLONAT§, IIE, CAS†
School of Cyber Security, UCAS¶
Beijing, China
PI:EMAIL
Institute for Network Sciences and
Cyberspace, Tsinghua University
Beijing, China
ABSTRACT
Automatic exploit generation is an open challenge. Existing so-
lutions usually explore in depth the crashing paths, i.e., paths taken
by proof-of-concept (PoC) inputs triggering vulnerabilities, and
generate exploits when exploitable states are found along the paths.
However, exploitable states do not always exist in crashing paths.
Moreover, existing solutions heavily rely on symbolic execution
and are not scalable in path exploration and exploit generation. In
addition, few solutions could exploit heap-based vulnerabilities.
In this paper, we propose a new solution Revery to search for
exploitable states in paths diverging from crashing paths, and gen-
erate control-flow hijacking exploits for heap-based vulnerabilities.
It adopts three novel techniques: (1) a layout-contributor digraph to
characterize a vulnerability’s memory layout and its contributor
instructions; (2) a layout-oriented fuzzing solution to explore diverg-
ing paths, which have similar memory layouts as the crashing paths,
in order to search more exploitable states and generate correspond-
ing diverging inputs; (3) a control-flow stitching solution to stitch
crashing paths and diverging paths together, and synthesize EXP
inputs able to trigger both vulnerabilities and exploitable states.
∗ Corresponding Authors.
§ Key Laboratory of Network Assessment Technology, CAS.
† Institute of Information Engineering, Chinese Academy of Sciences.
¶ University of Chinese Academy of Sciences.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5693-0/18/10...$15.00
https://doi.org/10.1145/3243734.3243847
We have developed a prototype of Revery based on the binary
analysis engine angr, and evaluated it on a set of 19 CTF (capture
the flag) programs. Experiment results showed that it could generate
exploits for 9 (47%) of them, and generate EXP inputs able to trigger
exploitable states for another 5 (26%) of them.
CCS CONCEPTS
verse engineering;
• Security and privacy → Penetration testing; Software re-
KEYWORDS
exploit; vulnerability; taint analysis; fuzzing; symbolic execution
ACM Reference Format:
Yan Wang, Chao Zhang, Xiaobo Xiang, Zixuan Zhao, Wenjie Li, Xiaorui
Gong, Bingchang Liu, Kaixiang Chen, and Wei Zou. 2018. Revery: From
Proof-of-Concept to Exploitable: (One Step towards Automatic Exploit Gen-
eration). In 2018 ACM SIGSAC Conference on Computer and Communica-
tions Security (CCS ’18), October 15–19, 2018, Toronto, ON, Canada. ACM,
NY, NY, USA, 14 pages. https://doi.org/10.1145/3243734.3243847
1 INTRODUCTION
Due to the success of automated vulnerability discovery solu-
tions (e.g., fuzzing), more and more vulnerabilities are found in real
world applications, together with proof-of-concept (PoC) inputs.
For example, Google’s OSS-Fuzz platform [31] adopts several state-
of-the-art fuzzers to continuously test open source applications,
and has found over 1000 bugs in 5 months [4]. As a result, more and
more human resources are spent on assessing vulnerabilities, e.g.,
identifying root causes and fixing them. It thus calls for solutions
to automatically assess the severity and priority of vulnerabilities.
Vulnerability assessment, especially exploitability assessment, is
important for both defenders and attackers. Attackers could isolate
Session 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1914exploitable vulnerabilities and write exploits to launch attacks. On
the other hand, defenders could prioritize exploitable vulnerabilities
to fix first, and allocate resources accordingly. Moreover, defenders
could learn from the exploits to generate IDS (Intrusion Detection
System) signatures, to block future attacks.
A straightforward way to assess a vulnerability is analyzing the
program state at the crashing point, i.e., the instruction leading to
program crashes or security violations, which could be caught by
a sanitizer (e.g., AddressSanitizer [32]). For example, Microsoft’s
!exploitable tool [3] inspects all instructions in the crashing
point’s basic block, and searches for known exploitable patterns, e.g.,
control transfer instructions with tainted targets. HCSIFTER [19]
takes an extra step to recover the data corrupted by heap over-
flow, enabling the program to execute more code after the crashing
point, and thus provides more reliable assessments. However, these
solutions rely on heuristics to determine the exploitability of vul-
nerabilities, and thus are inaccurate sometimes. Moreover, they
could not provide exploit inputs to prove the exploitability.
The ultimate way to assess the exploitability of a vulnerability is
generating a working exploit, either by human or by machine, e.g., as
demonstrated in Cyber Grand Challenge (CGC [16]). Sean Heelan
proposed a prototype [20] in his thesis, using dynamic analysis and
symbolic execution to generate exploits for classic buffer overflow
vulnerabilities. AEG [10] and Mayhem [15] provide end-to-end sys-
tems to discover vulnerabilities and automatically generate exploits
when possible, for source code and binary respectively. Q [29] and
CRAX [22] could generate exploits for binaries given PoC inputs.
These automatic exploit generation (AEG) solutions share a sim-
ilar workflow. In general, they will first analyze vulnerabilities in
detail in the crashing paths using dynamic analysis, then search for
exploitable states in crashing paths, then utilize symbolic execution
to collect the path reachability constraints, vulnerability trigger-
ing constraints and exploit construction constraints respectively,
and finally solve these constraints using SMT (satisfiability modulo
theories) solvers and generate exploit inputs. However, these solu-
tions could only solve a small number of problems. For example,
machines developed in CGC could only solve in total 26 out of 82
challenge programs in the Final Event.
There are several challenges need to be addressed:
Challenge 1: Exploit derivability issue. As pointed in [17, 39], once
memory corruption vulnerabilities are triggered, the victim pro-
gram’s state machine turns into a weird (state) machine. Exploitation
is actually a process of programming the weird machine to perform
unintended behavior. It is extremely important to set up the initial
state of this weird machine in order to exploit it.
However, PoC inputs (e.g., provided by fuzzers) could corrupt
some data and lead weird machines to non-exploitable initial states.
For example, the program may exit soon after the crashing point
due to some sanity checks. So, AEG solutions have to search for
exploitable states not only in crashing paths taken by PoC inputs,
but also in alternative diverging paths. This is known as exploit
derivability, one of the core challenges of exploitation [39]. Few
AEG solutions have paid attentions to this issue.
Challenge 2: Symbolic execution bottleneck. Existing solutions
heavily rely on symbolic execution to explore program paths (e.g.,
for vulnerability discovery), or perform reasoning (e.g., for test case
and exploit generation). AEG [10] and Mayhem [15] utilize sym-
bolic execution to explore paths reachable from the vulnerability
point and search for exploitable states, able to mitigate the afore-
mentioned exploit derivability issue. However, symbolic execution
has scalability issues and performs poorly in exploit generation.
First, it faces the path explosion issue when exploring paths, and
consumes too many resources even when analyzing only one path.
Second, it gets blind to certain exploitable states after concretizing
some values. For example, it has to concretize symbolic arguments
of memory allocations and symbolic indexes of memory access
operations in a path, in order to model the memory states and
enable exploring following sub-paths. But the concretized values
could lead to non-exploitable memory states.
Challenge 3: Exploiting Heap-based Vulnerability. Few existing so-
lutions could generate exploits for heap-based vulnerabilities. First,
heap management functions are too complicated for program anal-
ysis techniques to analyze. For example, the single file malloc.c in
the library glibc has more than 5000 lines of code. Second, heap
management functions have deployed several sanity checks, which
could detect the heap corruption at certain checkpoints.
Our solution. In this paper, we focus on the exploitability assess-
ment of heap-based vulnerabilities, given PoC inputs. We present
a framework Revery, able to search for exploitable states in not
only crashing paths but also diverging paths and generate working
control-flow hijacking exploits when possible.
First, it analyzes the vulnerabilities using dynamic analysis. Sim-
ilar to existing AEG solutions, Revery also collects some runtime
information in the crashing path, including taint attributes of vari-
ables. In addition, it inspects corrupted memory objects (denoted
as exceptional objects), and objects that can be used to locate the
exceptional objects. Moreover, it retrieves layout-contributor in-
structions from the path, which create these objects and set up the
point-to relationship among them. Based on these instructions and
objects, Revery creates a layout-contributor digraph to characterize
the vulnerability’s memory state and contributors.
Then it searches alternative diverging paths for exploitable states.
Revery utilizes a novel layout-oriented fuzzing solution rather than
symbolic execution to explore diverging paths. Similar to directed
fuzzing [12], Revery also drives a fuzzer to explore paths close to
specific targets, i.e., the crashing paths.
However, Revery does not aim at matching the exact crashing
path or triggering the vulnerability during fuzzing. Instead, it ig-
nores most of the instructions in the crashing path, but aims at
hitting the aforementioned layout-contributor instructions, which
could yield a similar memory layout as the vulnerability. There-
fore, the fuzzer could explore many diverging paths, and has a
better chance to find exploitable states, while sticking around the
vulnerable memory states.
Finally, Revery tries to synthesize new EXP inputs to trigger
both the exploitable states in diverging paths and vulnerabilities in
crashing paths. It employs a novel control-flow stitching solution
to stitch the diverging paths and crashing paths together, and then
utilizes a lightweight symbolic execution to generate EXP inputs.
In certain cases, Revery is able to directly generate working
exploits. But it is not guaranteed, due to the presence of compli-
cated defense mechanisms, or the requirement of making dynamic
Session 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1915Figure 1: An example heap overflow. The vulnerability at line 10 could overwrite the following object, i.e., obj2. PoC inputs
would crash at line 12 and enter a non-exploitable state. Successful exploits will trigger the exploitable state at line 14.
decisions during exploitation, or other challenges which are out of
the scope of this paper. It is worth noting that, even in cases where
Revery fails to generate working exploits, Revery could provide
EXP inputs to experts and help them write exploits.
Results. We have built a prototype of Revery based on the binary
analysis engine angr [34], and evaluated it on 19 CTF (Capture
The Flag) programs. It demonstrated that Revery is effective in
triggering exploitable states, and could generate working exploits
for a big portion of them. More specifically, Revery could generate
exploits for 9 (47%) out of 19 programs, while existing open source
AEG solutions could not solve any of them. Furthermore, it could
trigger exploitable states for another 5 (26%) of them.
In summary, we have made the following contributions:
• We proposed an automated solution Revery able to transfer PoC
inputs into EXP inputs, which could trigger vulnerabilities and
enter exploitable states. It could also directly generate working
exploits in certain cases.
• We proposed a layout-contributor digraph data structure, to char-
acterize vulnerabilities’ memory layouts and their contributor
instructions, enabling many exploit-related analysis.
• We proposed a novel layout-oriented fuzzing solution, to search
for exploitable states in diverging paths, without symbolic exe-
cution.
• We proposed a novel control-flow stitching solution, to stitch
crashing paths and diverging paths together and synthesize EXP
inputs with a lightweight symbolic execution.
• We have implemented a prototype of Revery, and demonstrated
its effectiveness in CTF programs.
2 MOTIVATION EXAMPLE
In this section, we will illustrate the exploit derivability issue
facing by automated exploit generation solutions, and present the
overview of our solution Revery, with a running example demon-
strated in Figure 1.
2.1 The Vulnerability
As shown in Figure 1, there is a heap overflow vulnerability at
line 10. The two objects obj1 and obj2 have the same size, and
are likely to be allocated next to each other in the heap. If the
vulnerability condition vul at line 9 is met, lengthy inputs could
cause an overflow in the buffer obj1->data. As a result, objects
(e.g., obj2) following this buffer will be corrupted.
Therefore, the statement at line 12 and 14 will read from and
write to corrupted memory address respectively. If the corrupted
pointer obj2->ptr points to invalid (e.g., nonexistent) memory,
these two statements will cause crashes. If it points to valid memory,
the statement at line 12 will execute normally (but result in wrong
return value), while the statement at line 14 will further corrupt
the target memory and cause Arbitrary Address Write (AAW).
From the perspective of exploitation, the statement at line 12 is
non-exploitable, unless the returned value res affects control-flow in
caller functions. But the statement at line 14 triggers an exploitable
state. It causes an AAW primitive able to overwrite arbitrary targets,
including the global function pointer handler which is invoked at
line 15, and thus could cause control-flow hijacking at line 15.
2.2 Exploit Derivability
As discussed in [39], exploit derivability is one of the core chal-
lenges of exploitation. More specifically, given a PoC input for a
vulnerability, the program could be turned into a weird machine,
but with a non-exploitable initial state. To successfully exploit the
vulnerability, we have to search for exploitable states in alternative
diverging paths, and lead the weird machine to exploitable.
As shown in the running example, assuming a PoC input prov-
ing the vulnerability at line 10 is provided (e.g., by fuzzers), it
could overwrite the field obj2->status to non-zero, and overwrite
obj2->ptr to invalid memory address, and cause a crash at line
12. So this PoC leads the weird machine to a non-exploitable initial
state. A successful exploitation has to trigger the vulnerability (at
line 10) and enter an exploitable state (e.g., at line 14).
For simplicity, we introduce several terminologies:
• Crashing path: the path taken by the PoC input, e.g., the path
• Crashing point: the instruction where the program crashes or
9->10->11->12 in the example.
a security violation is caught by sanitizers, e.g., line 12.
1112131410stitching pointcrashing pointvulnerability pointexploitable pointEXP inputPOC input9stitching pointdiverging input15hijacking point1.  struct Type1 { char[8] data;                              };2.  struct Type2 { int status;    int* ptr;  void init(){…};  };3.  int (*handler)(const int*) = …;4.  struct{Type1* obj1; Type* obj2;} gvar = {};5.  int foo(){6.    gvar.obj1 = new Type1;7.    gvar.obj2 = new Type2;8.    gvar.obj2->init();  // resulting different statuses9.    if(vul) 10.     scanf(“%s”, &gvar.obj1->data);    // vulnerability point11.   if(gvar.obj2->status)               // stitching point12.     res = *gvar.obj2->ptr;            // crashing point13.   else                                // stitching point14.     *gvar.obj2->ptr = read_int();     // exploitable point15.   handler(gvar.obj2->ptr);            // hijacking point16.   return res;17. }Session 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1916Figure 2: Overview of Revery. It first analyzes the vulnerability in the crashing path and gets the layout-contributor digraph
to characterize the vulnerability, then guides a fuzzer with this digraph to explore diverging paths and search for exploitable
states, and finally stitches the diverging path with the crashing path to synthesize exploits.
found, e.g., 9->11->13->14 in the example.
• Vulnerability point: the instruction where the vulnerability
(i.e., security violation) happens, e.g., line 10 in the example. A
crashing path may have multiple security violations. The first
violation point is denoted as the vulnerability point.
• Exploitable point: the instruction which could lead to a suc-
cessful exploit, e.g., line 14 in the example. Exploitable points
lead to exploitable states where the weird machine could work
properly. In practice, arbitrary address read/write/execute in-
structions (AAR/AAW/AAX) are classical exploitable points.
• Diverging path: the path where exploitable states could be
• Hijacking point: the instruction where the control-flow could