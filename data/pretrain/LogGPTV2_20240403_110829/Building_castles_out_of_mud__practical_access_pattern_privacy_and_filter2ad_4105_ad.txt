is out of scope here) that it is computationally infeasible to
ﬁnd two sets that have the same checksum; the hash function
(1) thus forms an easy and eﬃcient way to authenticate the
set of items in a level:
Theorem 4. If the discrete logarithm problem in Z∗p is
hard it is computationally infeasible to ﬁnd two sets A 6= B
with H(A) = H(B).
Theorem 5. A client interface correctly implementing the
above integrity constructs will detect all incorrect server re-
sponses before they reveal any part of the access pattern, or
return an incorrect answer to the user of the interface.
6. PERFORMANCE
We implemented a prototype of the mechanisms discussed
above. This allowed us a unique insight in the boundary
between theoretical complexity and runtimes. We faced nu-
merous challenges to allow TB(Terabyte) - level, multi-disk
data handling, including implementing eﬃcient TB - sized
hashtables, multi-threading, fast packet queueing and data
request handling, tweaking TCP/IP sockets to handle ef-
ﬁciently without delays, as well as generally caring about
every spent microsecond.
We chose Java as an initial platform and compiled using
the Sun JDK 1.6.0 05. The testing environment included
a mix of 4 of the following drive types: Seagate Barracuda
7200.11 SATA 3Gb/s 1TB, 7200 RPM, 105 MB/s sustained
data rate, 4.16ms average seek latency and 32 MB cache, and
Western Digital Caviar SE16 3 Gb/s, 320GB, 7200 RPM,
122 MB/s sustained data rate, 4.2ms average latency and
16MB cache. The machines involved were running Intel(R)
Pentium(R) 4 CPUs at 3.00GHz, with 2MB of L2 cache,
2GB RAM, and Linux Redhat Fedora Core 8, kernel 2.6.23.1
with Ext4 ﬁle system support enabled. To evaluate the suit-
ability of the mechanisms for diﬀerent network types we
modulated diﬀerent network delays and also ran the suite
in a general purpose 100MBps CDMA ethernet network.
Growing Database. Figure 3 shows observed query re-
sponse times over a database growing in size (by write queries)
from 10 to 650 MBytes. A majority of queries require a few
hundred milliseconds to run. Points above the average repre-
sent reshuﬄes of large levels. Large levels require more time
to reshuﬄe, but are reshuﬄed less frequently. The triples of
points show that each successive reshuﬄe of a level requires
more time as the level grows; after the fourth reshuﬄe, the
level is empty. The bands below the average query time re-
ﬂect that after a large reshuﬄe, most of the levels are empty,
decreasing the number of levels that must be examined in
the following queries.
Impact of Network Latency.
Figure 4 explores the
impact of network latency on response time (simulated using
sleep; the granularity of that primitive aﬀects the accuracy
of the points at 0ms and 5ms). A strong dependence on
Query response time vs. Database size
Individual query response time
Running average query response time
)
s
d
n
o
c
e
s
i
l
l
i
m
(
e
m
i
t
e
s
n
o
p
s
e
r
y
r
e
u
Q
 1e+07
 1e+06
 100000
 10000
 1000
 100
 10
 100
 200
 300
 400
 500
 600
Database size (MBytes)
Figure 3: A database is built from 64KB items using
a Bloom ﬁlter collision rate of 2−35 with network
RTTs of 25ms (logscale on y axis).
Query response time vs. Network latency, 640MByte DB
)
s
d
n
o
c
e
s
i
l
l
i
m
(
e
m
i
t
e
s
n
o
p
s
e
r
y
r
e
u
Q
 1100
 1000
 900
 800
 700
 600
 500
 0
 5
 10
 15
 20
 25
 30
 35
 40
 45
Round trip time (milliseconds)
Figure 4: We issue 1000 read queries for items from
the previously constructed 640MB database, aver-
aging query response time .
network round trip time can be observed, due to the fact
that round trip costs are paid several times during the online
phase of each query.
Impact of Database Size.
Figure 5 explores the im-
pact of database size on response time in a controlled low-
latency network setting (localhost network < .1ms latency).
Here the databases are not grown as in ﬁgure 3, but rather
queries are issued on a pre-constructed database of the in-
dicated size. Multiple hard disks are used to incur disk seek
cost in parallel. The behavior validates the O(log n log log n)
complexity and looks almost logarithmic for the considered
database sizes. For a 1 TByte database, over 2 1
4 queries per
second can be performed.
Improvements. Our implementation suﬀers from two bot-
tlenecks that are not inherent to the protocol. First, the
Java implementation of the cryptographic primitives is sig-
niﬁcantly slower than what can be achieved on the hardware
used. This slow-down is most prevalent during the reshuf-
ﬂe process, in which we encountered an unexpected CPU
bottleneck instead of the expected I/O bottleneck. Second,
Query response time vs. Database Size
)
s
d
n
o
c
e
s
i
l
l
i
m
(
e
m
i
t
e
s
n
o
p
s
e
r
y
r
e
u
Q
 450
 400
 350
 300
 250
 200
 150
 1
 10
 100
 1000
Database size (GB)
Figure 5: The impact of database size on query re-
sponse time in a controlled, low-latency network set-
ting on a pre-constructed database (logscale on x
axis).
our implementation runs queries synchronously. The highly
interactive nature of our query process, in which the output
from one level is needed before the query to the next level can
be composed, requires that we pay the network round-trip
delay multiple times per query, as illustrated in Figure 4.A
higher query throughput can be achieved by running mul-
tiple queries simultaneously, since the network delay does
not represent a resource bottleneck. The current implemen-
tation does not yet support simultaneous queries, however
this can be achieved (at least for those queries that don’t
trigger reshuﬄes) without aﬀecting the rest of the protocol.
Additionally, disk seek times will be mitigated in a parallel
implementation, for the same reason, if there are multiple
hard disks on the provider, since the disk seek penalty can
be paid simultaneously across diﬀerent disks.
7. CONCLUSIONS
In this paper we introduce a ﬁrst practical oblivious data
access protocol with correctness. The key insights lie in new
constructions and sophisticated reshuﬄing protocols that
yield practical computational complexity (to O(log n log log n))
and storage overheads (to O(n)). We also introduce a ﬁrst
practical implementation that allows a throughput of several
queries per second on 1Tbyte+ databases, with full compu-
tational privacy and correctness, orders of magnitude faster
than existing approaches.
8. ACKNOWLEDGEMENTS
We would like to thank our anonymous reviewers, who
oﬀered helpful insights. The authors are supported in part
by the NSF through awards CT CNS-0627554, CT CNS-
0716608 and CRI CNS-0708025. The authors also wish
to thank Motorola Labs, IBM Research, the IBM Software
Cryptography Group, CEWIT, and the Stony Brook Oﬃce
of the Vice President for Research.
9. REFERENCES
[1] GMail. Online at http://gmail.google.com/.
[2] Xdrive. Online at http://www.xdrive.com/.
[3] IBM 4764 PCI-X Cryptographic Coprocessor
(PCIXCC). Online at http://www-03.ibm.com/
security/cryptocards/pcixcc/overview.shtml,
2006.
[4] D. Asonov. Querying Databases Privately: A New
Approach to Private Information Retrieval. Springer
Verlag, 2004.
[5] M. Bellare and D. Micciancio. A new paradigm for
collision-free hashing: Incrementality at reduced cost.
In Proceedings of EuroCrypt, 1997.
[6] Steven M. Bellovin and William R. Cheswick.
Privacy-enhanced searches using encrypted bloom
ﬁlters. Technical report, Columbia University, 2004.
[7] B. H. Bloom. Space/time trade-oﬀs in hash coding
with allowable errors. Commun. ACM, 13(7):422–426,
1970.
[8] B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan.
Private information retrieval. In IEEE Symposium on
Foundations of Computer Science, pages 41–50, 1995.
[9] CNN. Feds seek Google records in porn probe. Online
at http://www.cnn.com, January 2006.
[10] Gartner, Inc. Server Storage and RAID Worldwide.
Technical report, Gartner Group/Dataquest, 1999.
www.gartner.com.
[11] W. Gasarch. A WebPage on Private Information
Retrieval. Online at
http://www.cs.umd.edu/~gasarch/pir/pir.html.
[12] W. Gasarch. A survey on private information retrieval,
2004.
[13] O. Goldreich. Foundations of Cryptography.
Cambridge University Press, 2001.
[14] Oded Goldreich and Rafail Ostrovsky. Software
protection and simulation on oblivious ram. Journal of
the ACM, 45:431–473, May 1996.
[15] A. Iliev and S.W. Smith. Private information storage
with logarithmic-space secure hardware. In
Proceedings of i-NetSec 04: 3rd Working Conference
on Privacy and Anonymity in Networked and
Distributed Systems, pages 201–216, 2004.
[16] Rajeev Motwani and Prabhakar Raghavan.
Randomized Algorithms. Cambridge University Press,
1995.
[17] Radu Sion and Bogdan Carbunar. On the Practicality
of Private Information Retrieval. In Proceedings of the
Network and Distributed Systems Security Symposium,
2007. Stony Brook Network Security and Applied
Cryptography Lab Tech Report 2006-06.
[18] Shuhong Wang, Xuhua Ding, Robert H. Deng, and
Feng Bao. Private information retrieval using trusted
hardware. In Proceedings of the European Symposium
on Research in Computer Security ESORICS, pages
49–64, 2006.
[19] Peter Williams and Radu Sion. Usable Private
Information Retrieval. In Proceedings of the 2008
Network and Distributed System Security (NDSS)
Symposium, 2008.