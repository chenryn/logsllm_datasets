# tracer: function_graph    
#    
# CPU  DURATION                  FUNCTION CALLS    
# |     |   |                     |   |   |   |      0)               |  kfree_skb() {      0)               |    skb_release_all() {      0)               |      skb_release_head_state() {      0)               |        nf_conntrack_destroy() {      0)               |          destroy_conntrack [nf_conntrack]() {      0)   0.205 us    |            nf_ct_remove_expectations [nf_conntrack]();      0)               |            nf_ct_del_from_dying_or_unconfirmed_list [nf_conntrack]() {      0)   0.282 us    |              _raw_spin_lock();      0)   0.679 us    |            }      0)   0.193 us    |            __local_bh_enable_ip();      0)               |            nf_conntrack_free [nf_conntrack]() {      0)               |              nf_ct_ext_destroy [nf_conntrack]() {      0)   0.177 us    |                nf_nat_cleanup_conntrack [nf_nat]();      0)   1.377 us    |              }      0)               |              kfree_call_rcu() {      0)               |                __call_rcu() {      0)   0.383 us    |                  rcu_segcblist_enqueue();      0)   1.111 us    |                }      0)   1.535 us    |              }      0)   0.446 us    |              kmem_cache_free();      0)   4.294 us    |            }      0)   6.922 us    |          }      0)   7.665 us    |        }      0)   8.105 us    |      }      0)               |      skb_release_data() {      0)               |        skb_free_head() {      0)   0.470 us    |          page_frag_free();      0)   0.922 us    |        }      0)   1.355 us    |      }      0) + 10.192 us   |    }      0)               |    kfree_skbmem() {      0)   0.669 us    |      kmem_cache_free();      0)   1.046 us    |    }      0) + 13.707 us   |  }好了，对于 ftrace 的最基本的、也是最重要的内核函数相关的tracer，我们已经知道怎样操作了。那你有没有好奇过，这个 ftrace又是怎么实现的呢？下面我们就来看一下。ftrace 的实现机制下面这张图描述了 ftrace 实现的 high level 的架构，用户通过 tracefs向内核中的 function tracer 发送命令，然后 function tracer把收集到的数据写入一个 ring buffer，再通过 tracefs输出给用户。![](Images/5379aa20a9a534429927f2e32023dd50.png)savepage-src="https://static001.geekbang.org/resource/image/22/52/2220b9346955d55361a2fe5ce1e62552.jpeg"}这里的整个过程看上去比较好理解。不过还是有一个问题，不知道你有没有思考过，frace可以收集到内核中任意一个函数被调用的情况，这点是怎么做到的？你可能想到，这是因为在内核的每个函数中都加上了 hook点了吗？这时我们来看一下内核的源代码，显然并没有这样的 hook 点。那 Linux到底是怎么实现的呢？其实这里 ftrace 是利用了 gcc编译器的特性，再加上几步非常高明的代码段替换操作，就很完美地实现了对内核中所有函数追踪的接口（这里的"所有函数"不包括"inline函数"）。下面我们一起看一下这个实现。Linux 内核在编译的时候，缺省会使用三个 gcc 的参数\"-pg -mfentry-mrecord-mcount\"。其中，\"-pg-mfentry\"这两个参数的作用是，给编译出来的每个函数开头都插入一条指令\"callq\\"。你如果编译过内核，那么你可以用\"objdump -Dvmlinux\"来查看一下内核函数的汇编，比如 do_mount()函数的开头几条汇编就是这样的：    ffffffff81309550 :    ffffffff81309550:       e8 fb 83 8f 00          callq  ffffffff81c01950     ffffffff81309555:       55                      push   %rbp    ffffffff81309556:       48 89 e5                mov    %rsp,%rbp    ffffffff81309559:       41 57                   push   %r15    ffffffff8130955b:       49 89 d7                mov    %rdx,%r15    ffffffff8130955e:       ba 00 00 ed c0          mov    $0xc0ed0000,%edx    ffffffff81309563:       41 56                   push   %r14    ffffffff81309565:       49 89 fe                mov    %rdi,%r14    ffffffff81309568:       41 55                   push   %r13    ffffffff8130956a:       4d 89 c5                mov    %r8,%r13    ffffffff8130956d:       41 54                   push   %r12    ffffffff8130956f:       53                      push   %rbx    ffffffff81309570:       48 89 cb                mov    %rcx,%rbx    ffffffff81309573:       81 e1 00 00 ff ff       and    $0xffff0000,%ecx    ffffffff81309579:       48 83 ec 30             sub    $0x30,%rsp    ...而\"-mrecord-mcount\"参数在最后的内核二进制文件 vmlinux 中附加了一个mcount_loc 的段，这个段里记录了所有\"callq\\"指令的地址。这样我们很容易就能找到每个函数的这个入口点。为了方便你理解，我画了一张示意图，我们编译出来的 vmlinux就像图里展示的这样：![](Images/d964720e49cc7247bf14e3d90f51ceaa.png)savepage-src="https://static001.geekbang.org/resource/image/9f/49/9f62b0951b764fa61b7e5fe9b2d05449.jpeg"}不过你需要注意的是，**尽管通过编译的方式，我们可以给每个函数都加上一个额外的hook 点，但是这个额外\"****fentry****\"函数调用的开销是很大的。**即使\"**fentry**\"函数中只是一个 retq 指令，也会使内核性能下降 13%，这对于Linux内核来说显然是不可以被接受的。那我们应该怎么办呢？ftrace在内核启动的时候做了一件事，就是把内核每个函数里的第一条指令\"callq\\"（5 个字节），替换成了\"nop\"指令（0F 1F 44 0000），也就是一条空指令，表示什么都不做。虽然是空指令，不过在内核的代码段里，这相当于给每个函数预留了 5个字节。这样在需要的时候，内核可以再把这 5 个字节替换成 callq 指令，call的函数就可以指定成我们需要的函数了。同时，内核的 mcount_loc 段里，虽然已经记录了每个函数\"callq\\"的地址，不过对于 ftrace来说，除了地址之外，它还需要一些额外的信息。因此，在内核启动初始化的时候，ftrace 又申请了新的内存来存放mcount_loc段中原来的地址信息，外加对每个地址的控制信息，最后释放了原来的mcount_loc 段。所以 Linux内核在机器上启动之后，在内存中的代码段和数据结构就会发生变化。你可以参考后面这张图，它描述了变化后的情况：![](Images/d03f50adeaa893872ad091679a666c25.png)savepage-src="https://static001.geekbang.org/resource/image/02/6c/020548718a7a1819fac0c61d73f52e6c.jpeg"}当我们需要用 function tracer 来 trace 某一个函数的时候，比如\"echodo_mount \> set_ftrace_filter\"命令执行之后，do_mount()函数的第一条指令就会被替换成调用 ftrace_caller的指令。 你可以查看后面的示意图，结合这张图来理解刚才的内容。![](Images/723b32228be3f0cc4231f5f062181a01.png)savepage-src="https://static001.geekbang.org/resource/image/a2/5c/a2b469b754ab63c686318d2c427fb55c.jpeg"}这样，每调用一次 do_mount() 函数，它都会调用 function_trace_call()函数，把 ftrace function trace 信息放入 ring buffer 里，再通过 tracefs输出给用户。重点小结这一讲我们主要讲解了 Linux ftrace这个工具。 首先我们学习了 ftrace 最基本的操作，对内核函数做trace。在这里最重要的有两个 tracers，分别是 function 和function_graph。function tracer可以用来记录内核中被调用到的函数的情况。在实际使用的时候，我们可以设置一些ftrace 的 filter来查看某些我们关心的函数，或者我们关心的进程调用到的函数。我们还可以设置 func_stack_trace 选项，来查看被 trace函数的完整调用栈。而 function_graph trracer可以用来查看内核函数和它的子函数调用关系以及调用时间，这对我们理解内核的行为非常有帮助。讲完了 ftrace 的基本操作之后，我们又深入研究了 ftrace 在 Linux中的实现机制。在 ftrace 实现过程里，**最重要的一个环节是利用 gcc编译器的特性，为每个内核函数二进制码中预留了 5个字节，这样内核函数就可以调用调试需要的函数，从而实现了 ftrace的功能。** 思考题我们讲 ftrace 实现机制时，说过内核中的"inline 函数"不能被 ftrace到，你知道这是为什么吗？那么内核中的\"static 函数\"可以被 ftrace追踪到吗？ 欢迎你在留言区跟我分享你的思考与疑问，如果这一讲对你有启发，也欢迎转发给你的同事、朋友，跟他一起交流学习。
# 加餐04 \| 理解ftrace（2）：怎么理解ftrace背后的技术tracepoint和kprobe？你好，我是程远。前面两讲，我们分别学习了 perf 和 ftrace 这两个最重要 Linux tracing工具。在学习过程中，我们把重点放在了这两个工具最基本的功能点上。不过你学习完这些之后，我们内核调试版图的知识点还没有全部点亮。如果你再去查看一些 perf、ftrace 或者其他 Linux tracing相关资料，你可能会常常看到两个单词，"tracepoint"和"kprobe"。你有没有好奇过，这两个名词到底是什么意思，它们和perf、ftrace这些工具又是什么关系呢？这一讲，我们就来学习这两个在 Linux tracing系统中非常重要的概念，它们就是 **tracepoint** 和 **kprobe**。tracepoint 和 kprobe 的应用举例如果你深入地去看一些 perf 或者 ftrace的功能，这时候你会发现它们都有跟 tracepoint、kprobe相关的命令。我们先来看几个例子，通过这几个例子，你可以大概先了解一下tracepoint 和 kprobe的应用，这样我们后面做详细的原理介绍时，你也会更容易理解。首先看看 tracepoint，tracepoint 其实就是在 Linux内核的一些关键函数中埋下的 hook 点，这样在 tracing的时候，我们就可以在这些固定的点上挂载调试的函数，然后查看内核的信息。我们通过下面的这个 `perf list` 命令，就可以看到所有的tracepoints：    
# perf list | grep Tracepoint      alarmtimer:alarmtimer_cancel                       [Tracepoint event      alarmtimer:alarmtimer_fired                        [Tracepoint event      alarmtimer:alarmtimer_start                        [Tracepoint event      alarmtimer:alarmtimer_suspend                      [Tracepoint event      block:block_bio_backmerge                          [Tracepoint event      block:block_bio_bounce                             [Tracepoint event      block:block_bio_complete                           [Tracepoint event      block:block_bio_frontmerge                         [Tracepoint event      block:block_bio_queue                              [Tracepoint event    …至于 ftrace，你在 tracefs 文件系统中，也会看到一样的tracepoints：    
# find /sys/kernel/debug/tracing/events -type d | sort    /sys/kernel/debug/tracing/events    /sys/kernel/debug/tracing/events/alarmtimer    /sys/kernel/debug/tracing/events/alarmtimer/alarmtimer_cancel    /sys/kernel/debug/tracing/events/alarmtimer/alarmtimer_fired    /sys/kernel/debug/tracing/events/alarmtimer/alarmtimer_start    /sys/kernel/debug/tracing/events/alarmtimer/alarmtimer_suspend    /sys/kernel/debug/tracing/events/block    /sys/kernel/debug/tracing/events/block/block_bio_backmerge    /sys/kernel/debug/tracing/events/block/block_bio_bounce    /sys/kernel/debug/tracing/events/block/block_bio_complete    /sys/kernel/debug/tracing/events/block/block_bio_frontmerge         …为了让你更好理解，我们就拿"do_sys_open"这个 tracepoint做例子。在内核函数 do_sys_open() 中，有一个 trace_do_sys_open()调用，其实它这就是一个tracepoint：    long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)    {            struct open_flags op;            int fd = build_open_flags(flags, mode, &op);            struct filename *tmp;                 if (fd)                    return fd;                 tmp = getname(filename);            if (IS_ERR(tmp))                    return PTR_ERR(tmp);                 fd = get_unused_fd_flags(flags);            if (fd >= 0) {                    struct file *f = do_filp_open(dfd, tmp, &op);                    if (IS_ERR(f)) {                            put_unused_fd(fd);                            fd = PTR_ERR(f);                    } else {                            fsnotify_open(f);                            fd_install(fd, f);                            trace_do_sys_open(tmp->name, flags, mode);                    }            }            putname(tmp);            return fd;    }接下来，我们可以通过 perf 命令，利用 tracepoint来查看一些内核函数发生的频率，比如在节点上，统计 10 秒钟内调用do_sys_open成功的次数，也就是打开文件的次数。    
# 
# perf stat -a -e fs:do_sys_open -- sleep 10          Performance counter stats for 'system wide':                          7      fs:do_sys_open               10.001954100 seconds time elapsed同时，如果我们把 tracefs 中 do_sys_open 的 tracepoint 打开，那么在ftrace 的 trace 输出里，就可以看到具体 do_sys_open每次调用成功时，打开的文件名、文件属性、对应的进程等信息。    
# pwd    /sys/kernel/debug/tracing    
# echo 1 > events/fs/do_sys_open/enable         
# cat trace    