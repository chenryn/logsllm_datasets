从服务创建拦截看端上主防软件的工作原理和
绕过方法
前言
书接上文，在上一篇中我们详细讲解了服务的工作原理和隐藏方法，但是如果我们的服务根本就无法直
接注册到系统中，那上一节的内容就是白扯。所以怎么能够绕过端上类似于360主动防御类型的软件，
将我们的服务注册进系统，是一个棘手的问题，我们本节就着重研究这个问题，看怎么绕过。
从端上主防软件的工作原理讲起
本文把在客户端上利用行为进行拦截的软件成为端上主防软件，简称为hips，360的主动防御模块就是
典型的端上主防软件。这类软件复杂的会有用户态监控和内态监控，例如crowdstrike的Falcon，简单的
只有内核态监控，例如火绒hips，360的主动防御。
1. 用户态监控一般是inline hook，在第三方程序启动的时候，注入自己的DLL到目标进程中，修改目
标程序中关键函数的前几个字节为jmp指令，跳转到自己的处理函数，记录函数调用的相关的参
数，进行分析后再决定是否要返回到原函数完成工作任务。
2. 内核态监控：windows的64系统内核有patchguard机制之后，不允许驱动程序对内核的关键数据
和代码进行patch了，所以无法实现内核态的inline hook，此时做行为监控，只能用windows提供
的几个回调来实现，主要的监控点如下：
PsSetCreateProcessNotifyRoutineEx ： 此API允许你注册一个回调函数，当系统中有新的进
程创建或线程创建，就会将相关的数据传给你的回调函数，你可以再自己的回调函数记录这个
行为，以及是否允许这个操作。
CmRegisterCallback：此API注册的回调函数会在注册表发生改动的时候被调用，再回调函数
中可以记录相关的信息，并决定是否允许这个动作发生。
ObRegisterCallbacks：此API可以为系统关键的object操作注册回调，比如打开进程，创建线
程等。
PsSetLoadImageNotifyRoutine： 此API可以为系统的模块加载提供回调，模块包括DLL和
sys。虽然也可以在这个函数中通过patch被加载模块的代码，实现拒绝模块的加载，但是但
是这个行为有死锁风险，在商业软件中并不敢这么用。另外驱动的加载和模块加载有更好的监
控位置，本文不再展开。（吴国感兴趣，以后可以专门写文章介绍）。
Minifilter: windows提供的内核态文件监控和框架,能够拒绝文件操作。
WFP ： windows提供的包过滤框架，可以实现网路监控，能够拒绝网络操作。
有了如上的这些内核态的监控点，恶意程序对系统资源的敏感操作就无处遁形，在发生恶意操作时就会
被行为防护模块kill掉。
使用360测试服务创建的拦截
首先要明确端上安全软件的工作逻辑，在运行一个可执行文件时，安全软件的杀毒引擎会先工作，使用
病毒库对文件进行扫描，如果发现是白程序(已知的非恶意程序)，就立马放行，如果发现时黑程序(恶
意)，就直接禁止执行，如果发现是灰程序(无法判别)，那么就会将可执行程序的信息发送给主防模块，
主防对此程序后续的行为进行监控，如果发现恶意就立马终止执行。
我们接下里的测试和讨论都是建立在你的软件是静态免杀的前提下进行的。
首先说明，我并没有对360的驱动和规则引擎进行逆向分析，我下面的结论全部来自我对行为防护软件
上的工作相关经验和个人猜测，可能和真实的拦截规则有偏差，如果有不正确，我们再详细交流。
独立进程的服务
上一节讲了三种注册服务的方法，我们依次进行测试，看360是怎么拦截的，根据拦截的效果我们来分
析360拦截的原因，然后想办法来绕过拦截。
使用sc安装服务
使用命令安装服务是最简单的方式，当然也是行为防护软件最容易拦截的方式：
因为内核中的 PsSetCreateProcessNotifyRoutineEx 回调监控可以直接拿到sc.exe 执行时的命令行，
所以拦截这个操作也仅仅只需要一个正则表达式就可以了。
直接写注册表项
保存为1.reg,然后运行 regedit /s 1.reg :
执行完之后，360并没有什么反应。
sc create FirstService 
BinPath="C:\ConsoleApplication1\Release\ConsoleApplication1.exe" 
DisplayName="FirstService"
Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SecondService]
"DisplayNmae"="SecondService"
"ErrorControl"=dword:01
"ImagePath"=hex(2):43,00,3a,00,5c,00,55,00,73,00,65,00,72,00,73,00,5c,00,41,00,\
  64,00,6d,00,69,00,6e,00,69,00,73,00,74,00,72,00,61,00,74,00,6f,00,72,00,5c,\
  00,44,00,65,00,73,00,6b,00,74,00,6f,00,70,00,5c,00,43,00,6f,00,6e,00,73,00,\
  6f,00,6c,00,65,00,41,00,70,00,70,00,6c,00,69,00,63,00,61,00,74,00,69,00,6f,\
  00,6e,00,31,00,5c,00,52,00,65,00,6c,00,65,00,61,00,73,00,65,00,5c,00,43,00,\
  6f,00,6e,00,73,00,6f,00,6c,00,65,00,41,00,70,00,70,00,6c,00,69,00,63,00,61,\
  00,74,00,69,00,6f,00,6e,00,31,00,2e,00,65,00,78,00,65,00,00,00
"ObjectName"="LocalSystem"
"Sstart"=dword:03
"Type"=dword:0x10
我们以为服务创建成功了，但是其实不然，我们看注册表项，并没有完全写成功。
其实这个行为被360默认给拦截了，我们看一下拦截记录，就能发现写 ImagePath这个键值的时候被
360拦截了：
那我们测试一下，直接打开regedit.exe，通过界面编辑注册表项，手工创建 ImagePath键值，会不会被
拦截呢？
时间  操作  说明  次数
2021-10-29 09:59:16 [自动阻止]    修改 驱动/服务  防护 1 次
详细描述：
注册表位置：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\SERVICES\SECONDSERVICE\
[ImagePath]
注册表内容：
C:\Users\Administrator\Desktop\ConsoleApplication1\Release\ConsoleApplication1.e
xe
进程：C:\Windows\regedit.exe
父进程：C:\Windows\System32\cmd.exe , (0)
防护信息: RD|10, 10, -1||
测试发现，我们手工填写进去并不会被拦截：
同样都是regedit.exe的写注册表行为，为什么一个拦截，一个不拦截呢？这个问题看起来好像有点智
障，如果手工界面操作都被拦截的话，这个行为防护软件还能用吗？ 但是问题来了，360怎么知道你是
通过GUI创建的还是通过自动化的方式写进去的呢？
这个问题这里先不解答，我们看完最后一个测试之后统一做解释。
使用API创建服务
代码在上一节有详细的展示，我们直接编译测试吧。
查不到服务是因为我代码直接写了服务隐藏，看到注册表内容就表明了我的服务已经注册进入了系统。
我们发现360并没有进行拦截。
我们通过API创建服务，肯定也是需要写注册表的，但是360为什么不拦截呢？
通过现象看本质
我们在上面的测试中提出了两个问题：
1. 360是怎么区分我是通过界面操作改写的注册表还是通过自动化的调用regedit.exe程序写的注册
表？ 
2. 通过API创建服务也会改写注册表，为什么不拦截?
第一个问题：（进程链）
第一个问题其实需要去了解hips类型的产品一种常见的跟踪进程行为的方式，叫做进程链规则，本质就
是跟踪整个进程的生命周期的父子进程，然后对父子进程的行为进行评分，最后在关键行为的位置计算
分值，如果超过阈值就拦截 。
我们列一下我们两种情况下的进程链：
1. 使用 regedit.exe /s 1.reg 的进程链如下
2. 使用regedit,exe界面操作的进程链
这两个进程链的关键区别就是 regedit.exe  是否带有 /s 1.reg 参数，为了验证这个猜想，我们需要
做一个实验。就是让进程链跟第一个相同的情况下去写注册表服务的 ImagePath  键值，看是否会被拦
截。
那怎么让 regedit.exe 听我们话，自动帮我们写键值呢？那当然是向此进程中注入一个写注册表的
shellcode了，代码如下：
这段shellcode的作用就是写
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\SERVICES\FirstService\[ImagePath]  为 
c:\1.exe ,生成shellcode的代码就贴了，太长了。
+ wininit.exe
    + cmd.exe
        + regedit.exe /s 1.reg
            - RegSetValueExA(....) // 关键行为位置，在此处计算分值
+ wininit.exe
    + cmd.exe // 为了控制变量，我们的regedit.exe用cmd.exe启动，跟上面保持一致
        + regedit.exe
            + RegSetValueExA(....) // 关键行为位置，在此处计算分值
//#include "stdafx.h"
#include 