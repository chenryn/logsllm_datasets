## 扩展方法虽然 HTTP/1.1里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了HTTP协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。例如著名的愚人节玩笑 RFC2324，它定义了协议HTCPCP，即"超文本咖啡壶控制协议"，为 HTTP 协议增加了用来煮咖啡的 BREW方法，要求添牛奶的 WHEN 方法。此外，还有一些得到了实际应用的请求方法（WebDAV），例如MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH等。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK方法锁定资源暂时不允许修改，或者使用 PATCH方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。当然了，你也完全可以根据实际需求，自己发明新的方法，比如"PULL"拉取某些资源到本地，"PURGE"清理某个目录下的所有缓存数据。
## 安全与幂等关于请求方法还有两个面试时有可能会问到、比较重要的概念：**安全**与**幂等**。在 HTTP协议里，所谓的"**安全**"是指请求方法不会"破坏"服务器上的资源，即不会对服务器上的资源造成实质的修改。按照这个定义，只有 GET 和 HEAD方法是"安全"的，因为它们是"只读"操作，只要服务器不故意曲解请求方法的处理方式，无论GET 和 HEAD 操作多少次，服务器上的数据都是"安全的"。而 POST/PUT/DELETE操作会修改服务器上的资源，增加或删除数据，所以是"不安全"的。所谓的"**幂等**"实际上是一个数学用语，被借用到了 HTTP协议里，意思是多次执行相同的操作，结果也都是相同的，即多次"幂"后结果"相等"。很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE可以多次删除同一个资源，效果都是"资源不存在"，所以也是幂等的。POST 和 PUT 的幂等性质就略费解一点。按照 RFC 里的语义，POST是"新增或提交数据"，多次提交数据会创建多个资源，所以不是幂等的；而 PUT是"替换或更新数据"，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。我对你的建议是，你可以对比一下 SQL 来加深理解：把 POST 理解成 INSERT，把PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次UPDATE 只操作一条记录，而且效果相同。
## 小结今天我们学习了 HTTP 报文里请求方法相关的知识，简单小结一下。1.  [请求方法是客户端发出的、要求服务器执行的、对资源的一种操作；]{.orange}2.  [请求方法是对服务器的"指示"，真正应如何处理由服务器来决定；]{.orange}3.  [最常用的请求方法是 GET 和    POST，分别是获取数据和发送数据；]{.orange}4.  [HEAD 方法是轻量级的 GET，用来获取资源的元信息；]{.orange}5.  [PUT 基本上是 POST 的同义词，多用于更新数据；]{.orange}6.  ["安全"与"幂等"是描述请求方法的两个重要属性，具有理论指导意义，可以帮助我们设计系统。]{.orange}
## 课下作业1.  你能把 GET/POST    等请求方法对应到数据库的"增删改查"操作吗？请求头应该如何设计呢？2.  你觉得 TRACE/OPTIONS/CONNECT 方法能够用 GET 或 POST 间接实现吗？欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。![unpreview](Images/50d10ccf087f63242be9d4a24b3c976b.png){savepage-src="https://static001.geekbang.org/resource/image/60/81/60ee384d93d46cd6632be0606ae21681.png"}![unpreview](Images/4913a489805db29b38aefa585223c013.png){savepage-src="https://static001.geekbang.org/resource/image/56/63/56d766fc04654a31536f554b8bde7b63.jpg"}
# 11 \| 你能写出正确的网址吗？上一讲里我们一起学习了 HTTP 协议里的请求方法，其中最常用的一个是GET，它用来从服务器上某个资源获取数据，另一个是POST，向某个资源提交数据。那么，应该用什么来标记服务器上的资源呢？怎么区分"这个"资源和"那个"资源呢？经过前几讲的学习，你一定已经知道了，用的是URI，也就是**统一资源标识符**（**U**niform **R**esource**I**dentifier）。因为它经常出现在浏览器的地址栏里，所以俗称为"网络地址"，简称"网址"。严格地说，URI 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP世界里用的网址实际上是 URL------**统一资源定位符**（**U**niform**R**esource **L**ocator）。但因为 URL实在是太普及了，所以常常把这两者简单地视为相等。不仅我们生活中的上网要用到URI，平常的开发、测试、运维的工作中也少不了它。如果你在客户端做 iOS、 Android或者某某小程序开发，免不了要连接远程服务，就会调用底层 API 用 URI访问服务。如果你使用 Java、PHP 做后台 Web 开发，也会调用 getPath()、parse_url()等函数来处理 URI，解析里面的各个要素。在测试、运维配置 Apache、Nginx 等 Web 服务器的时候也必须正确理解URI，分离静态资源与动态资源，或者设置规则实现网页的重定向跳转。``{=html}总之一句话，URI 非常重要，要搞懂 HTTP 甚至网络应用，就必须搞懂 URI。
## URI 的格式不知道你平常上网的时候有没有关注过地址栏里的那一长串字符，有的比较简短，有的则一行都显示不下，有的意思大概能看明白，而有的则带着各种怪字符，有如"天书"。其实只要你弄清楚了 URI 的格式，就能够轻易地"破解"这些难懂的"天书"了。URI本质上是一个字符串，这个字符串的作用是**唯一地标记资源的位置或者名字**。这里我要提醒你注意，它不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。而"资源"既可以是存在磁盘上的静态文本、页面数据，也可以是由Java、PHP 提供的动态服务。下面的这张图显示了 URI 最常用的形式，由 scheme、host:port、path 和 query四个部分组成，但有的部分可以视情况省略。![](Images/1b8492edae86c2197be5e85ab360fe10.png){savepage-src="https://static001.geekbang.org/resource/image/46/2a/46581d7e1058558d8e12c1bf37d30d2a.png"}
## URI 的基本组成URI第一个组成部分叫**scheme**，翻译成中文叫"**方案名**"或者"**协议名**"，表示**资源应该使用哪种协议**来访问。最常见的当然就是"http"了，表示使用 HTTP协议。另外还有"https"，表示使用经过加密、安全的 HTTPS协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。浏览器或者你的应用程序看到 URI 里的scheme，就知道下一步该怎么走了，会调用相应的 HTTP 或者 HTTPS 下层API。显然，如果一个 URI 没有提供scheme，即使后面的地址再完善，也是无法处理的。在 scheme 之后，必须是**三个特定的字符**"**://**"，它把 scheme和后面的部分分离开。实话实说，这个设计非常的怪异，我最早上网的时候看见地址栏里的"://"就觉得很别扭，直到现在也还是没有太适应。URI的创造者蒂姆·伯纳斯 -李也曾经私下承认"://"并非必要，当初有些"过于草率"了。不过这个设计已经有了三十年的历史，不管我们愿意不愿意，只能接受。在"://"之后，是被称为"**authority**"的部分，表示**资源所在的主机名**，通常的形式是"host:port"，即主机名加端口号。主机名可以是 IP地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。但端口号有时可以省略，浏览器等客户端会依据scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS的默认端口号是 443。有了协议名和主机地址、端口号，再加上后面**标记资源所在位置**的**path**，浏览器就可以连接服务器访问资源了。URI 里 path采用了类似文件系统"目录""路径"的表示方式，因为早期互联网上的计算机多是UNIX 系统，所以采用了 UNIX 的"/"风格。其实也比较好理解，它与 scheme后面的"://"是一致的。这里我也要再次提醒你注意，URI 的 path部分必须以"/"开始，也就是必须包含"/"，不要把"/"误认为属于前面authority。说了这么多"理论"，来看几个实例。    http://nginx.orghttp://www.chrono.com:8080/11-1https://tools.ietf.org/html/rfc7230file:///D:/http_study/www/第一个 URI算是最简单的了，协议名是"http"，主机名是"nginx.org"，端口号省略，所以是默认的80，而路径部分也被省略了，默认就是一个"/"，表示根目录。第二个 URI 是在实验环境里这次课程的专用URI，主机名是"www.chrono.com"，端口号是 8080，后面的路径是"/11-1"。第三个是 HTTP 协议标准文档 RFC7230 的URI，主机名是"tools.ietf.org"，路径是"/html/rfc7230"。最后一个 URI要注意了，它的协议名不是"http"，而是"file"，表示这是本地文件，而后面居然有三个斜杠，这是怎么回事？如果你刚才仔细听了 scheme 的介绍就能明白，这三个斜杠里的前两个属于 URI特殊分隔符"://"，然后后面的"/D:/http_study/www/"是路径，而中间的主机名被"省略"了。这实际上是file 类型 URI 的"特例"，它允许省略主机名，默认是本机 localhost。但对于 HTTP 或 HTTPS这样的网络通信协议，主机名是绝对不能省略的。原因之前也说了，会导致浏览器无法找到服务器。我们可以在实验环境里用 Chrome 浏览器再仔细观察一下 HTTP 报文里的 URI。运行 Chrome，用 F12打开开发者工具，然后在地址栏里输入""，得到的结果如下图。![](Images/c00f0ccecb7867cefef3fb4c43179fa2.png){savepage-src="https://static001.geekbang.org/resource/image/20/9f/20ac5ee55b8ee30527492c8abb60ff9f.png"}在开发者工具里依次选"Network""Doc"，就可以找到请求的 URI。然后在 Headers页里看 Request Headers，用"viewsource"就可以看到浏览器发的原始请求头了。发现了什么特别的没有？在 HTTP 报文里的URI"/11-1"与浏览器里输入的""有很大的不同，协议名和主机名都不见了，只剩下了后面的部分。这是因为协议名和主机名已经分别出现在了请求行的版本号和请求头的 Host字段里，没有必要再重复。当然，在请求行里使用完整的 URI也是可以的，你可以在课后自己试一下。通过这个小实验，我们还得到了一个结论：[客户端和服务器看到的 URI是不一样的]{.orange}。客户端看到的必须是完整的URI，使用特定的协议去连接特定的主机，而服务器看到的只是报文请求行里被删除了协议名和主机名的URI。如果你配置过 Nginx，你就应该明白了，Nginx 作为一个 Web 服务器，它的location、rewrite 等指令操作的 URI 其实指的是真正 URI 里的 path和后续的部分。
## URI 的查询参数使用"协议名 + 主机名 +路径"的方式，已经可以精确定位网络上的任何资源了。但这还不够，很多时候我们还想在操作资源的时候附加一些额外的修饰参数。举几个例子：获取商品图片，但想要一个 32×32的缩略图版本；获取商品列表，但要按某种规则做分页和排序；跳转页面，但想要标记跳转前的原始页面。仅用"协议名 + 主机名 + 路径"的方式是无法适应这些场景的，所以 URI后面还有一个"**query**"部分，它在 path之后，用一个"?"开始，但不包含"?"，表示对资源附加的额外要求。这是个很形象的符号，比"://"要好的多，很明显地表示了"查询"的含义。查询参数 query 有一套自己的格式，是多个"**key=value**"的字符串，这些 KV值用字符"**&**"连接，浏览器和客户端都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。你可以在实验环境里用 Chrome 试试下面这个加了 query 参数的 URI：    http://www.chrono.com:8080/11-1?uid=1234&name=mario&referer=xxxChrome 的开发者工具也能解码出 query 里的 KV 对，省得我们"人肉"分解。![](Images/5348972d66b27012a3993ad45040ab03.png){savepage-src="https://static001.geekbang.org/resource/image/e4/f3/e42073080968e8e0c58d9a9126ab82f3.png"}还可以再拿一个实际的 URI 来看一下，这个 URI 是某电商网站的一个商品查询URI，比较复杂，但相信现在的你能够毫不费力地区分出里面的协议名、主机名、路径和查询参数。    https://search.jd.com/Search?keyword=openresty&enc=utf-8&qrst=1&rt=1&stop=1&vt=2&wq=openresty&psort=3&click=0你也可以把这个 URI 输入到 Chrome的地址栏里，再用开发者工具仔细检查它的组成部分。