* 防止双重开支
  允许使用者花钱或使用积分的服务，需要检查使用者的支付数额不超过其余额。可以透过在使用者的帐户中插入一个试探性的消费专案来实现这一点，列出帐户中的所有专案，并检查总和是否为正值【44】。在写入偏差场景下，可能会发生两个支出专案同时插入，一起导致余额变为负值，但这两个事务都不会注意到另一个。
#### 导致写入偏差的幻读
所有这些例子都遵循类似的模式：
1. 一个 `SELECT` 查询找出符合条件的行，并检查是否符合一些要求。（例如：至少有两名医生在值班；不存在对该会议室同一时段的预定；棋盘上的位置没有被其他棋子占据；使用者名称还没有被抢注；账户里还有足够余额）
2. 按照第一个查询的结果，应用程式码决定是否继续。（可能会继续操作，也可能中止并报错）
3. 如果应用决定继续操作，就执行写入（插入、更新或删除），并提交事务。
   这个写入的效果改变了步骤 2 中的先决条件。换句话说，如果在提交写入后，重复执行一次步骤 1 的 SELECT 查询，将会得到不同的结果。因为写入改变了符合搜寻条件的行集（现在少了一个医生值班，那时候的会议室现在已经被预订了，棋盘上的这个位置已经被占据了，使用者名称已经被抢注，账户余额不够了）。
这些步骤可能以不同的顺序发生。例如可以首先进行写入，然后进行 SELECT 查询，最后根据查询结果决定是放弃还是提交。
在医生值班的例子中，在步骤 3 中修改的行，是步骤 1 中返回的行之一，所以我们可以透过锁定步骤 1 中的行（`SELECT FOR UPDATE`）来使事务安全并避免写入偏差。但是其他四个例子是不同的：它们检查是否 **不存在** 某些满足条件的行，写入会 **新增** 一个匹配相同条件的行。如果步骤 1 中的查询没有返回任何行，则 `SELECT FOR UPDATE` 锁不了任何东西。
这种效应：一个事务中的写入改变另一个事务的搜寻查询的结果，被称为 **幻读**【3】。快照隔离避免了只读查询中幻读，但是在像我们讨论的例子那样的读写事务中，幻读会导致特别棘手的写入偏差情况。
#### 物化冲突
如果幻读的问题是没有物件可以加锁，也许可以人为地在资料库中引入一个锁物件？
例如，在会议室预订的场景中，可以想象建立一个关于时间槽和房间的表。此表中的每一行对应于特定时间段（例如 15 分钟）的特定房间。可以提前插入房间和时间的所有可能组合行（例如接下来的六个月）。
现在，要建立预订的事务可以锁定（`SELECT FOR UPDATE`）表中与所需房间和时间段对应的行。在获得锁定之后，它可以检查重叠的预订并像以前一样插入新的预订。请注意，这个表并不是用来储存预订相关的资讯 —— 它完全就是一组锁，用于防止同时修改同一房间和时间范围内的预订。
这种方法被称为 **物化冲突（materializing conflicts）**，因为它将幻读变为资料库中一组具体行上的锁冲突【11】。不幸的是，弄清楚如何物化冲突可能很难，也很容易出错，并且让并发控制机制泄漏到应用资料模型是很丑陋的做法。出于这些原因，如果没有其他办法可以实现，物化冲突应被视为最后的手段。在大多数情况下。**可序列化（Serializable）** 的隔离级别是更可取的。
## 可序列化
在本章中，已经看到了几个易于出现竞争条件的事务例子。**读已提交** 和 **快照隔离** 级别会阻止某些竞争条件，但不会阻止另一些。我们遇到了一些特别棘手的例子，**写入偏差** 和 **幻读**。这是一个可悲的情况：
- 隔离级别难以理解，并且在不同的资料库中实现的不一致（例如，“可重复读” 的含义天差地别）。
- 光检查应用程式码很难判断在特定的隔离级别执行是否安全。特别是在大型应用程式中，你可能并不知道并发发生的所有事情。
- 没有检测竞争条件的好工具。原则上来说，静态分析可能会有帮助【26】，但研究中的技术还没法实际应用。并发问题的测试是很难的，因为它们通常是非确定性的 —— 只有在倒楣的时序下才会出现问题。
这不是一个新问题，从 20 世纪 70 年代以来就一直是这样了，当时首先引入了较弱的隔离级别【2】。一直以来，研究人员的答案都很简单：使用 **可序列化（serializable）** 的隔离级别！
**可序列化（Serializability）** 隔离通常被认为是最强的隔离级别。它保证即使事务可以并行执行，最终的结果也是一样的，就好像它们没有任何并发性，连续挨个执行一样。因此资料库保证，如果事务在单独执行时正常执行，则它们在并发执行时继续保持正确 —— 换句话说，资料库可以防止 **所有** 可能的竞争条件。
但如果可序列化隔离级别比弱隔离级别的烂摊子要好得多，那为什么没有人见人爱？为了回答这个问题，我们需要看看实现可序列化的选项，以及它们如何执行。目前大多数提供可序列化的资料库都使用了三种技术之一，本章的剩余部分将会介绍这些技术：
- 字面意义上地序列顺序执行事务（请参阅 “[真的序列执行](#真的序列执行)”）
- **两阶段锁定（2PL, two-phase locking）**，几十年来唯一可行的选择（请参阅 “[两阶段锁定](#两阶段锁定)”）
- 乐观并发控制技术，例如 **可序列化快照隔离**（serializable snapshot isolation，请参阅 “[可序列化快照隔离](#可序列化快照隔离)”）
现在将主要在单节点资料库的背景下讨论这些技术；在 [第九章](ch9.md) 中，我们将研究如何将它们推广到涉及分散式系统中多个节点的事务。
### 真的序列执行
避免并发问题的最简单方法就是完全不要并发：在单个执行绪上按顺序一次只执行一个事务。这样做就完全绕开了检测 / 防止事务间冲突的问题，由此产生的隔离，正是可序列化的定义。
尽管这似乎是一个明显的主意，但资料库设计人员只是在 2007 年左右才决定，单执行绪回圈执行事务是可行的【45】。如果多执行绪并发在过去的 30 年中被认为是获得良好效能的关键所在，那么究竟是什么改变致使单执行绪执行变为可能呢？
两个进展引发了这个反思：
- RAM 足够便宜了，许多场景现在都可以将完整的活跃资料集储存在记忆体中（请参阅 “[在记忆体中储存一切](ch3.md#在记忆体中储存一切)”）。当事务需要访问的所有资料都在记忆体中时，事务处理的执行速度要比等待资料从磁碟载入时快得多。
- 资料库设计人员意识到 OLTP 事务通常很短，而且只进行少量的读写操作（请参阅 “[事务处理还是分析？](ch3.md#事务处理还是分析？)”）。相比之下，长时间执行的分析查询通常是只读的，因此它们可以在序列执行回圈之外的一致快照（使用快照隔离）上执行。
序列执行事务的方法在 VoltDB/H-Store、Redis 和 Datomic 中实现【46,47,48】。设计用于单执行绪执行的系统有时可以比支援并发的系统性能更好，因为它可以避免锁的协调开销。但是其吞吐量仅限于单个 CPU 核的吞吐量。为了充分利用单一执行绪，需要有与传统形式的事务不同的结构。
#### 在储存过程中封装事务
在资料库的早期阶段，意图是资料库事务可以包含整个使用者活动流程。例如，预订机票是一个多阶段的过程（搜寻路线，票价和可用座位，决定行程，在每段行程的航班上订座，输入乘客资讯，付款）。资料库设计者认为，如果整个过程是一个事务，那么它就可以被原子化地执行。
不幸的是，人类做出决定和回应的速度非常缓慢。如果资料库事务需要等待来自使用者的输入，则资料库需要支援潜在的大量并发事务，其中大部分是空闲的。大多数资料库不能高效完成这项工作，因此几乎所有的 OLTP 应用程式都避免在事务中等待互动式的使用者输入，以此来保持事务的简短。在 Web 上，这意味著事务在同一个 HTTP 请求中被提交 —— 一个事务不会跨越多个请求。一个新的 HTTP 请求开始一个新的事务。
即使已经将人类从关键路径中排除，事务仍然以互动式的客户端 / 伺服器风格执行，一次一个语句。应用程式进行查询，读取结果，可能根据第一个查询的结果进行另一个查询，依此类推。查询和结果在应用程式程式码（在一台机器上执行）和资料库伺服器（在另一台机器上）之间来回传送。
在这种互动式的事务方式中，应用程式和资料库之间的网路通讯耗费了大量的时间。如果不允许在资料库中进行并发处理，且一次只处理一个事务，则吞吐量将会非常糟糕，因为资料库大部分的时间都花费在等待应用程式发出当前事务的下一个查询。在这种资料库中，为了获得合理的效能，需要同时处理多个事务。
出于这个原因，具有单执行绪序列事务处理的系统不允许互动式的多语句事务。取而代之，应用程式必须提前将整个事务程式码作为储存过程提交给资料库。这些方法之间的差异如 [图 7-9](../img/fig7-9.png) 所示。如果事务所需的所有资料都在记忆体中，则储存过程可以非常快地执行，而不用等待任何网路或磁碟 I/O。