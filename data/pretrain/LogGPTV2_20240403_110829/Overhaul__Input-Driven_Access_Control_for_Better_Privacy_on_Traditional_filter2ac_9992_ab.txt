within the kernel, any time a permission decision is to be
made. This decision process involves comparing a timestamp
issued together with the query with the stored interaction
timestamp corresponding to the target application, and in this
way correlating privileged operations with input events based
on their temporal proximity.
Finally, the kernel also uses the secure communication
channel to request from the display manager that it display
a visual alert when a resource access is granted.
C. Sensitive Resource Protection
An important class of system resources that OVERHAUL
aims to protect is sensitive hardware devices. These devices
could include arbitrary sensors attached to the system; typical
examples on desktop operating systems include the camera
and microphone. In order to implement dynamic access control
over hardware resources, the kernel is responsible for mediat-
ing accesses to these sensitive hardware devices.
However, note that the kernel does not interpose on all
security-sensitive resources. Representative examples include
the system clipboard and program display contents, both
controlled by the display manager. Applying dynamic access
control over these resources requires the display manager to
query the kernel permission monitor, and grant or deny the
action based on the response.
To illustrate the enhancements required to the kernel and
the display manager, and how sensitive resources are protected,
we present
two scenarios that build upon the components
described above. For the following, we let:
opt be a privileged operation at time t,
where op ∈ {copy, paste, scr, mic, cam},
EA,t be an input event sent to application A at time t,
NA,t be an interaction notiﬁcation corresponding to EA,t
QA,t be a permission query for application A at time t,
RA,t be a response ∈ {grant, deny} for QA,t,
VA,op be a visual alert request, indicating A performs op.
Hardware resources. Figure 1 presents an example
interaction involving an application’s request to access the
system microphone. In an unmodiﬁed system,
the request
would succeed so long as application A holds the permission
to access the microphone device at t + n.
OVERHAUL introduces the following changes. First, the
system ensures that for all applications the permission to access
the microphone is denied by default. (1) When the user clicks
on a button in application A to turn on the microphone at
time t, the display manager receives the input event EA,t and
veriﬁes that it is generated by a hardware input device through
user interaction. (2) If EA,t is authentic, then the display man-
ager ﬁrst sends the kernel permission monitor an interaction
445
3
EA,t
1
EA,t
Display
Manager
NA,t
A
mict+n
Userspace
Kernel
2
6
4
VA,mic
Permission Monitor
Hardware
Cam
5
Mic
Figure 1. Dynamic access control over privacy-sensitive hardware devices.
notiﬁcation NA,t through the secure communication channel.
The permission monitor records this notiﬁcation, indicating
that A received authentic user input at t. (3) The display
manager then forwards EA,t to its destination A. (4) Upon
receiving the event, A attempts to turn on the microphone. The
permission monitor intercepts A’s request mict+n to access
the device. It compares A’s latest interaction time t with the
device access request time t+n to correlate the input event with
the privileged operation, based on a preconﬁgured threshold δ.
(5) Access to the device is granted to A only if the privileged
operation could successfully be correlated with a preceding
input event (i.e., if (t + n) − t = n < δ holds). (6) Finally,
the kernel sends VA,mic to the display manager to request that
the user be alerted. This step is necessary because the display
manager may not have adequate information to identify the
process that actually accessed the resource (e.g., due to IPC
mechanisms, as explained in Section III-D).
The veriﬁcation of user input authenticity provides the
property that sensitive device access operations can only be
performed in response to legitimate user input. Note that, in
this scenario, no permission query from the display manager to
the permission monitor is necessary. Since the kernel has full
mediation over hardware resources, the permission monitor can
implicitly adjust the permissions of A when necessary. This
entire process is transparent to the application.
Display resources. Figure 2 shows an example interaction
for a clipboard paste operation between the display manager
and an application A. The baseline protocol consists of A
requesting the clipboard contents from the display manager,
and receiving back the copied data. OVERHAUL revokes all
clipboard access permissions by default, and modiﬁes the
protocol in the following way.
(1) First
the user inputs the keystrokes to paste some
text, (2) the display manager veriﬁes that the input EA,t is
authentic and notiﬁes the kernel permission monitor with NA,t,
(3) and forwards the key event to A. (4) After receiving the
command from the user, A issues a clipboard paste request
pastet+n to the display manager. (5) Instead of immediately
serving the request, the display manager sends a permission
446
3
4
data
pastet+n
A
7
EA,t
1
EA,t
Display
Manager
NA,t QA,t+n
2
5
6
RA,t+n
Permission Monitor
Userspace
Kernel
Figure 2. Protecting copy & paste operations against clipboard snifﬁng.
query QA,t+n to the kernel permission monitor through the
secure communication channel. (6) As before, the permission
monitor compares the interaction time t in its records for
A with the privileged operation request time t + n issued
together with the query. If the correlation of the input event
with the operation request is successful based on the temporal
proximity threshold δ, (i.e. n < δ), the permission monitor
replies with a grant response RA,t+n; otherwise RA,t+n is
a deny response. (7) If and only if RA,t+n is a permission
grant does the display manager return to A the data; or else
A is blocked from accessing the clipboard. In this scenario an
explicit visual alert request from the kernel is not necessary,
because the display manager can successfully identify the
requesting process without kernel assistance.
Here,
the secure communication channel between the
kernel and the display manager is used both for sending
interaction notiﬁcations to the permission monitor, and for
querying it whether to allow the privileged operation.
As before, the veriﬁcation of user input authenticity pro-
vides the property that copy & paste operations can only
be performed in response to actual
inputs. This provides
protection against malicious programs that attempt to capture
sensitive data from the system clipboard, such as passwords
pasted from a password manager. We note that because per-
mission queries are implicitly generated along with the copy &
paste requests, this protection is transparent to the application.
Note that, in this scenario, ﬁrst sending input notiﬁcations
to the permission monitor and later querying it for the same
information could seem unnecessary. Instead, one could store
input notiﬁcations inside the display manager to avoid kernel
communication. However, in the next section, we show that our
design is necessary for the kernel to track interactions across
process boundaries, through process spawns and IPC channels.
D. Interaction Across Process Boundaries
Real-life applications often consist of multiple processes or
threads, and communicate with each other using application-
speciﬁc protocols via inter-process communication (IPC) fa-
cilities provided by the OS. This signiﬁcantly complicates
the task of associating user input with privileged operations
requested by an application, because the process receiving
the input event could be different from the actual process
ERun,t
1
ERun,t
Display
Manager
NRun,t
QShot,t+n
3
5
scrt+n
img
8
Shot
Run
Userspace
Kernel
2
6
7
4
RShot,t+n
Permission Monitor
create 
process
Figure 3. A program launcher executing a screen capture program, illustrating
the need for interposing on process spawn mechanisms to propagate interaction
information.
that accesses a sensitive resource. We illustrate this challenge
OVERHAUL needs to address with the examples below.
Figure 3 presents a scenario where an application Shot
attempts to capture a screen image. Since the screen content is
also a resource controlled by the display manager, this example
is similar to the previous copy & paste example. However,
here, the user ﬁrst executes a program launcher Run, types in
the name of the program Shot, and the application launcher
executes Shot on the user’s behalf. In other words, (1–3) the
user actually interacts with Run, which the kernel permission
monitor records; (4) but Run creates a new process Shot, (5)
and the screen capture request scrt+n is made by this different
process for which there exists no interaction record.
In another scenario, Figure 4 depicts how a multi-process
Internet browser that uses separate processes for each browser
tab (i.e., similar to Chromium) would run a web-based video
conferencing application. (1–3) When the user commands the
browser to launch a video conference session, she actually
interacts with the main browser window Browser, and the
permission monitor is notiﬁed of this. However, Browser
opens the web application in a separate process Tab and (4)
commands it to turn on the camera via shared memory IPC.
As a result, (5) Tab requests camt+n without a corresponding
interaction record in the permission monitor.
The ubiquity of multi-process application architectures, ap-
plications that launch third-party programs, and IPC use make
it necessary for OVERHAUL to correctly handle cases similar
to those exempliﬁed above. Therefore, our design requires
OVERHAUL to interpose on all process and thread spawns, as
well as the entire range of IPC mechanisms provided by the OS
(e.g., (4) in Figure 3 and Figure 4). Speciﬁcally, OVERHAUL
needs to propagate interaction notiﬁcations between processes
according to the following policy:
(P1) Interaction notiﬁcations of a parent process must be prop-
agated to a newly spawned child process; i.e., whenever
a process X creates a new process Y , all interaction
notiﬁcations NX,t recorded in the permission monitor
must be duplicated as NY,t.
(P2) In an IPC channel established between two (or more)
processes, interaction notiﬁcations of a message sender
process must be propagated to the receiver process; i.e.,
EBrowser,t
1
EBrowser,t
Display
Manager
NBrowser,t
3
Tab
camt+n
Browser
open cam
Userspace
2
Kernel
5
4
Permission Monitor
Shared
Memory
Hardware
6
Cam
Mic
Figure 4. A multi-process browser, components of which communicate via
shared memory IPC. This example illustrates the need for interposing on IPC
endpoints to propagate interaction information.
OVERHAUL must monitor all established IPC endpoints,
and whenever process X sends a message to process Y ,
interaction notiﬁcations NX,t recorded in the permission
monitor must be duplicated as NY,t.
In this way, OVERHAUL can support process spawns and
IPC chains of arbitrary length and complexity, and remain
transparent to the applications and oblivious to the application-
level communication protocols.
E. Limitations
OVERHAUL inherently shares the limitations of other user-
driven security approaches. In particular, because the user’s
perception of malice and their interaction with applications
are central to this security model, OVERHAUL cannot provide
protection against malware that can trick users into voluntarily
installing and using it, for example, by mimicking the appear-
ance and functionality of well-known legitimate applications.
Additionally, OVERHAUL does not support running scheduled
tasks, or persistent non-interactive programs that need access
to the protected sensitive devices (e.g., a cron job or daemon
that periodically takes screen captures). We stress that these
issues are fundamental to any user-driven access control model,
and despite its limitations OVERHAUL provides important
security beneﬁts complementing the standard access control
models employed in commodity operating systems, without
any signiﬁcant detriments to performance or user experience.
The trade-offs OVERHAUL makes between backwards com-
patibility with legacy programs and defending against on-
system malware results in a system that provides strictly
weaker security guarantees than prior work on user-driven