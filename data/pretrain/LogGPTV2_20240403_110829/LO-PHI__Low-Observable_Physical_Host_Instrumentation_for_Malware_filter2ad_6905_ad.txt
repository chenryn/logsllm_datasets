### Table
| Entry Index | Address         | Name                       | Module        | Created Filename                                            |
|-------------|-----------------|----------------------------|---------------|--------------------------------------------------------------|
| 0x0000f7    | 0xf7c5b406      | NtSetValueKey              | hookssdt.sys  | /.../lophi/$$ rk sketchy server.exe                          |
| 0x0000ad    | 0xf7c5b44c      | NtQuerySystemInformation   | hookssdt.sys  | /.../lophi/hookssdt.sys                                      |
| 0x000091    | 0xf7c5b554      | NtQueryDirectoryFile       | hookssdt.sys  | /.../lophi/sample 0742475e94904c41de1397af5c53dff8e.exe     |

**Figure 6: Post-filtered semantic output from the rootkit experiment (Section VII-C1).**

### B. Filtering Background Noise

While a complete log of system modifications is valuable, it is more relevant to extract only those events attributed to the binary under analysis. To filter out unrelated activity, we first establish a controlled baseline for both our physical and virtual Systems Under Test (SUTs) by creating a dataset using a benign binary (rundll32.exe with no arguments) over 10 independent executions. We then use our analysis framework to extract all system events from these trials and create a filter based on frequently occurring events in the benign dataset.

Two of our memory analysis modules, `filesan` and `timers`, generated a high number of false positives and were less useful for automated analysis. To reduce false positives in disk analysis, we decouple filenames from their respective Master File Table (MFT) record numbers.

### C. Experiment 1: High-fidelity Output

To verify that LO-PHI can extract malware behaviors, we evaluated our system with known malware samples, for which we have ground truth. In our first case study, we evaluated a rootkit developed using techniques from The Rootkit Arsenal [15] (Section VII-C1). Additionally, we obtained 213 malware samples constructed in a cleanroom environment, accompanied by their source code and detailed annotations. All binaries were executed on both physical and virtual machines running Windows XP (32-bit, Service Pack 3).

#### 1. Homemade Rootkit

Our rootkit stealths itself by adding hooks to the Windows Global Descriptor Table (GDT) and System Service Dispatch Table (SSDT) to hide any directory or running executable with the prefix `$$ rk` and opens a malicious FTP server. The rootkit module is embedded in a malicious PDF file that drops and loads a malicious driver (`hookssdt.sys`) and the FTP server executable (`$$ rk sketchy server.exe`). Figure 6 shows the post-filtered results when running this rootkit through our framework. We received identical results for both virtual and physical machines, matching our ground truth. The rootkit drops files to disk, loads the kernel module, hooks the kernel, and executes the FTP server. We omitted numerous temporary files created by Adobe Acrobat Reader and Windows, as well as accesses to existing files (81 total events), to save space, but all disk activity was successfully reconstructed. We can trivially detect the new process by examining physical memory, bypassing execution-level hooks.

We also ran our rootkit on the Anubis and Cuckoo analysis frameworks. Anubis failed to execute the binary, likely due to missing dependencies like Acrobat Reader. Cuckoo produced similar file-system-level output, reporting 156 file events compared to our 81 post-filtered events. However, we could not find the listening socket or GDT and SSDT hooks in their output. Our FTP server was executed, creating a listening socket on port 21, but the kernel module may not have executed properly on their framework. Our ability to introspect memory and find obvious malware indicators is a notable distinction. The lack of execution for such a simple rootkit highlights the importance of a realistic software and hardware environment, which we address in Section VII-E.

#### 2. Labeled Malware

For the 213 well-annotated malware samples, we performed a blind analysis and later verified our findings with the labels. Only the most interesting findings are shown.

- **VM-detection**: 66 samples employed anti-VM or anti-debugging capabilities, focusing on VMWare, VirtualPC, and other virtualization suites. All samples executed their full payload in both environments.
- **New Processes**: 79 samples created new long-running processes, with `svchost.exe` being the most common (15 samples). Variations like `dddsvchost.exe` and `cbasvchost.exe` were also detected. These 17 samples dropped their own `svchost.exe` binary, which opened a TCP listening socket on port 1053. The second most common process was `bot.exe` (12 samples), and 4 of these also had `dwwin.exe`. These 4 samples each created 2 UDP listening sockets on ports 1045 and 1046, suggesting they were derived from the same two malware families and contained remote administration tools (RATs).
- **Data Exfiltration**: 46 samples attempted to collect and exfiltrate data. Two samples exfiltrated data over port 25 (SMTP), reading Firefox's `cert8.db` and `key3.db` files. Disk analysis of the rest of the set yielded 44 additional samples with similar behavior.
- **Worms and Network Scanning**: 30 samples exhibited worm propagation and network scanning behavior, contacting a significant number of IP addresses and opening many network sockets. For example, 8 samples contacted over 140 IP addresses, and 13 samples opened more than 2000 sockets, targeting external IPs over port 135 (Microsoft RPC).
- **Command and Control (C2) and DNS**: 14 samples attempted to contact external servers over TCP port 6667 (IRC). The most common DNS queries were for hostnames like `579.info` (55 samples), `windowsupdate.net` (16 samples), and others.
- **Kernel Modules**: 3 samples unloaded the `ipnat.sys` driver and replaced it with a malicious version.

### D. Experiment 2: Unlabeled Malware

In this experiment, we demonstrate our framework's ability to scale and extract useful results from completely unknown malicious binaries, also targeting Windows XP. The physical SUT was the same (Dell T7500 with 1GB of RAM), but the virtual machines were instantiated on a server with six quad-core Xeon X5670s (24 logical cores) and 68GB of RAM, enabling us to run 20 virtual machines with instrumentation. Due to resource constraints, we ran 1091 samples in both environments before running out of storage.

**Table I: Overall statistics for unlabeled malware (Section VII-D).**

| Observed Behavior          | Number of Samples |
|----------------------------|-------------------|
| Created new process(es)     | 765               |
| Opened socket(s)            | 210               |
| Started service(s)          | 300               |
| Loaded kernel modules       | 20                |
| Modified GDT                | 58                |
| Modified IDT                | 10                |

- **New Processes**: 70% of the wild samples created new processes, with common names like `IEXPLORE.exe`, `dwwin.exe`, and `svchost.exe`.
- **Sockets**: 19% of the wild samples opened at least one network socket, with the most common ports being 1038 (UDP), 1039 (TCP), and 1042 (TCP).
- **Services**: 27.5% of the wild samples started and installed at least one new system service, often claiming to be hardware drivers like `hidusb.sys`.

### E. Experiment 3: Evasive Malware

In this section, we demonstrate LO-PHI's ability to analyze evasive malware, which thwarts existing analysis frameworks. We ran these analyses on the same hardware but with Windows 7 (64-bit) as the operating system, and installed several potentially vulnerable applications. The Volatility modules used were limited to those supporting Windows 7: `psscan`, `envars`, `ssdt`, `netscan`, `ldrmodules`, `driverirp`, and `psxview`.

#### 1. Paranoid Fish

We highlight our ability to analyze evasive binaries with a ground truth sample, Paranoid Fish (paﬁsh v054), an open-source tool demonstrating various VM detection and anti-debugging techniques. When executed, paﬁsh writes a file for each artifact it observes. It detected artifacts in popular analysis frameworks like Anubis and Cuckoo Sandbox, writing files such as `hi qemu`, `hi sandbox drive size`, and `hi CPU VM rdtsc`.

This demonstrates LO-PHI's capability to handle and analyze evasive malware effectively.