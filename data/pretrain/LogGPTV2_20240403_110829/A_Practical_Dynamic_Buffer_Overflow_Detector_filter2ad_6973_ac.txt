tium III, 1GB Linux machine.
The results of the experiment are presented in Fig-
ure 5. Full bounds checking, like the original JK system,
imposes signiﬁcant performance overhead on most pro-
grams. The enscript application experiences a 11-times
slowdown, while ssh experiences a 12-times slowdown
when instrumented with full bounds checking. Limiting
the bounds-checking to strings greatly improves the per-
formance for most programs. The instrumentation im-
poses an overhead of less than 26% for 14 of the pro-
grams. The slowdown is still signiﬁcant for Apache
(1.6X), enscript (1.9X), gnupg (1.8X), hypermail (2.3X),
monkey (1.8X) and pgp4pine (1.6X). These programs in-
volve signiﬁcant string processing, thereby limiting the
effectiveness of our optimization. Fortunately, known
compiler optimizations can be applied to eliminate redun-
What was evaluated
Response time to 15K tcp connections at the rate of 90 per second.
Response time to 3K tcp connections at the rate of 50 per second.
Latency of 126MB ﬁle transfer using scp via the network loop back interface.
Program
Apache-1.3.24
monkey-0.7.1
openssh-3.2.2p1
OpenSSL-0.9.7b Time to sign and verify 2048 bit keys using rsa.
pgp4pine-1.76
polymorph-0.40
WsMp3-0.0.10
wu-ftpd-2.6.1
Time to decrypt 1MB ﬁle
Time to convert names of 100 ﬁles to unix style (lower case) names.
Latency of downloading a 1.5MB ﬁle.
Latency of 126MB ﬁle transfer via the network loop back interface
Figure 4. Description of performance tests.
dant bounds checks in loops and thereby reduce the per-
formance penalty[15]. Static analysis techniques can also
be incorporated to reduce the portion of code that requires
instrumentation[9].
5. Related Work
A considerable amount of work has been performed
on mitigating the buffer overﬂow problem using either
static analysis or dynamic analysis.
In addition com-
parative studies of these techniques have been carried
out[14, 28, 33, 34].
In this section we review different
works in each category.
5.1. Static Analysis Approaches
Wagner et al. developed a system for detecting buffer
overﬂows in C programs statically[31]. Their approach
treats C strings as an abstract data type accessed through
the library routines and models buffers as pairs of inte-
ger ranges (size and current length), while the detection
problem is formulated as an integer constraint problem.
The library functions are modeled in terms of how they
modify the size and length of strings. By trading preci-
sion for scalability their implemented tool gives both false
positives and false negatives. The tool found known and
unknown security vulnerabilities in Sendmail 8.7.5.
Larochelle and Evans[22] presented a lightweight
annotation-assisted static analysis based on LCLint[13].
This technique exploits information provided in program-
mers’ semantic comments to detect likely buffer overﬂow
vulnerabilities. Their tool is neither sound nor complete.
Sagiv et al. presented C String Static Verifyer (CSSV),
a tool that statically detects string manipulation errors
with the aid of procedure summaries[11]. CSSV is sound
and handles all C language constructs such as structures
and multilevel pointers. Its disadvantages are that it gen-
erates false alarms and imposes on the programmer the
extra burden of writing procedure summaries.
5.2. Dynamic Analysis Approaches
StackGuard by Cowan et al. is an extension to the GNU
C compiler that tackles the stack smashing attacks by in-
serting a canary word just before the return address on the
stack[10]. Attempts to overwrite the return address would
result in the canary value being modiﬁed. The canary is
veriﬁed when the function is about to return, and the pro-
gram is halted if the canary was altered. Bulba and Kil3r
present techniques for bypassing StackGuard[6]. Our tool
is not susceptible to these techniques.
ProPolice by Etoh and Yoda is another extension to
the GNU C compiler that protects against stack smash-
ing attacks [12]. Similar to StackGuard, ProPolice pro-
tects the return address with a guard value. In addition
stack allocated variables are rearranged such that local
char buffers are at a higher address(below the guard value)
than other local variables and pointers. Therefore local
char buffers cannot be overﬂowed to affect other local
variables. ProPolice offers no protection against other
forms of buffer overﬂow attacks, which our tool does.
StackShield is also an extension to the GNU C com-
piler that protects the return address against stack smash-
ing attacks[30]. It does so by storing a copy of the return
address in a safe place on entering a function and restor-
ing it before returning. So if the return address on the
stack is overwritten, the saved copy will be restored any-
way and used when the function returns. Techniques to
bypass StackShield are presented by Bulba and Kil3r[6].
Our tool is impervious to these techniques and thus offers
better protection to programs.
Baratloo et al. presented two complementary tech-
niques for foiling stack smashing attacks that attempt to
corrupt the return address[2]. The techniques are imple-
mented as dynamically loaded libraries Libsafe and Lib-
verify. Libsafe replaces vulnerable C library functions
with safe implementations. Libverify implements a re-
turn address veriﬁcation scheme similar to StackGuard;
Figure 5. Performance overhead of instrumentation with and without strings only checking
optimization. Non instrumented code is normalized to 1.
however it works on executables and, as such, does not
require recompilation of source code, making it applica-
ble to legacy code. A combination of both tools is inef-
fective against overﬂows that is caused by dereferencing
out-of-bounds addresses, which our tool correctly detects.
Lhee and Chapin presented a buffer overﬂow detec-
tion technique using array bounds checking[23]. In their
scheme object ﬁles are augmented with type information
about static and automatic buffers that is used to carry
out this range checking. Their technique does not guard
against overﬂows caused by erroneous pointer arithmetic,
making it an impractical solution. Our tool offers this pro-
tection.
Haugh and Bishop presented STOBO, an instrumenta-
tion tool that aids detection of buffer overﬂow vulnerabil-
ities due to use of C library functions during testing[16].
STOBO keeps track of lengths of memory buffers, checks
if they satisfy certain conditions when used as arguments
to library functions and issues warnings when buffer over-
ﬂows may occur from such uses. STOBO ﬁnds vulnera-
bilities in programs even when the test data does not trig-
ger and overﬂow. However it detects only vulnerabilities
due to use of library functions.
It also generates false
alarms.
5.3. Combination of Static and Dynamic Analysis
Necula et al. presented a program transformation tool
(CCured) that adds memory safety guarantees to C
programs[24, 9]. CCured ﬁrst attempts to statically verify
the absence of memory errors in a program by enforcing
a strong type system. It then inserts run-time checks to
handle portions of the code for which static veriﬁcation
is insufﬁcient. CCured is incompatible with complex C
code, therefore manual intervention in the form of anno-
tations and source code changes is required for the system
02468101214apachebinutilsbisonccryptcoreutilsenscriptgawkgnupggrepgziphypermailmonkeypgp4pinepolymorphssh(scp)rsa2048 signrsa2048 verifytarWsMp3wu-ftpdzlibBenchmarkNormalized execution timeFull checkingStrings onlyto work with real-life programs. Our tool is fully auto-
matic and compatible with complex C code.
Cyclone by Jim et al. is a safe dialect of C which pre-
vents memory errors by using static analysis and runtime
checks in a similar manner to CCured [17]. Cyclone
changes pointer representation and is therefore incompat-
ible with legacy code. Also source code changes are re-
quired to make Cyclone work with real-life programs.
Kiriansky et al. presented program shepherding, a tech-
nique that monitors control ﬂow transfers during program
execution in order to enforce a security policy[21, 20].
Program shepherding builds a custom security policy for
the target program using automatic static and dynamic
analyses. Buffer overﬂows attack are therefore prevented
because a successful attack would require a control ﬂow
transfer that would violate the security policy. This tech-
nique was implemented in the DynamoRIO dynamic code
modiﬁcation system[3, 4]. The system works on unmod-
iﬁed native binaries and requires no special hardware or
operating system support. However, it does not support
self-modifying code.
6. Conclusions
We presented CRED, a practical dynamic buffer over-
ﬂow detector for C programs. Our solution is built upon
Jones and Kelly’s technique of tracking the referent object
of each pointer. Compared to the previous system, our so-
lution does not break existing codes that compute with
out-of-bound addresses and is signiﬁcantly more efﬁcient
by limiting the buffer overrun checks to strings.
Our experimental results demonstrate the compatibil-
ity of our technique with commonly used programs and
its effectiveness in detecting buffer overrun attacks in vul-
nerable programs. The overheads experienced range from
1% to 130%, depending on the use of strings in the appli-
cation. These numbers are signiﬁcantly better than pre-
viously published results on dynamic bounds checking.
Further improvement in performance is possible using
known techniques for optimizing bounds checking[15],
and using static veriﬁcation to reduce the portion of code
that requires instrumentation[9].
7. Acknowledgements
References
[1] AlephOne. Smashing stack for fun and proﬁt. Phrack,
7(49), November 1996.
[2] A. Baratloo, N. Singh, and T. Tsai. Transparent runtime
defense against stack smashing attacks.
In Proceedings
of the USENIX Annual Technical Conference, pages 251–
262, June 2000.
[3] D. Bruening, E. Duesterwald, and S. Amarasinghe.
Design and implementation of a dynamic optimiza-
tion framework for Windows.
4th ACM Workshop on
Feedback-Directed and Dynamic Optimization (FDDO-
4), December 2001.
[4] D. Bruening, T. Garnett, and S. Amarasinghe. An infras-
tructure for adaptive dynamic optimization. International
Symposium on Code Generation and Optimization (CGO-
03), March 2003.
[5] H. Brugge.
Bounds
checking C compiler
http://web.inter.nl.net/hcc/haj.ten.brugge/.
[6] Bulba and Kil3r. Bypassing StackGuard and StackShield.
Phrack, 10(56), May 2000.
[7] CERT/CC.
Advisories
2002.
http://www.cert.org/advisories.
[8] CERT/CC.
Vulnerability
notes
by metric
http://www.kb.cert.org/vuls/bymetric.
[9] J. Condit, M. Harren, S. McPeak, G. C. Necula, and
In Proceedings
W. Weimer. CCured in the real world.
of the ACM SIGPLAN 2003 Conference on Programming
Language Design and Implementation, June 2003.
[10] C. Cowan, P. Wagle, C. Pu, S. Beattie, and J. Walpole.
Buffer overﬂows: Attacks and defenses for vulnerabil-
ity of the decade. In Proceedings of DARPA Information
Survivability Conference and Exposition, pages 119–129,
January 2000.
[11] N. Dor, M. Rodeh, and M. Sagiv. Cssv: Towards a re-
alistic tool for statically detecting all buffer overﬂows in
c. In Proceedings of the ACM SIGPLAN 2003 Conference
on Programming Language Design and Implementation,
pages 155–167, June 2003.
[12] H. Etoh and K. Yoda.
Protecting from stack-
smashing attacks http://www.trl.ibm.com/projects/ secu-
rity/ssp/main.html.
[13] D. Evans, J. Guttag, J. Horning, and Y. Tan. Lclint: A
tool for using speciﬁcations to check code. In Proceedings
of the SIGSOFT Symposium on Foundations of Software
Engineering, pages 87 – 96, December 1994.
[14] P. A. Fayolle and V. Glaume.
ﬂow study,
loads.securityfocus.com/library/report.pdf.
defenses
attacks
and
A buffer over-
down-
http://
We thank Herman ten Brugge, John Wilander and
members of the open source development community for
their assistance throughout this project. We also thank
David Heine, David Brumley, Constantine Sapuntzakis,
Andrew Myers, and the anonymous reviewers for their
helpful comments on this paper.
[15] R. Gupta. Optimizing array bounds checks using ﬂow
analysis. ACM Letters on Programming Languages and
Systems, 2(1-4):135–150, March–December 1993.
[16] E. Haugh and M. Bishop. Testing C programs for buffer
overﬂow vulnerabilities.
In Proceedings of the Network
and Distributed System Security Symposium, February
2003.
[17] T. Jim, G. Morriset, D. Grossman, M. Hicks, J. Cheney,
and Y. Wang. Cyclone: A safe dialect of C. In Proceedings
of the USENIX Annual Technical Conference, pages 275 –
288, June 2002.
[18] R. Jones and P. Kelly. Backwards-compatible bounds
checking for arrays and pointers in C programs. In Pro-
ceedings of the International Workshop on Automatic De-
bugging, pages 13–26, May 1997.
[19] S. C. Kendall. Bcc: Run-time checking for C programs.
In Proceedings of the USENIX Summer Conference, pages
5–16, 1983.
[20] V. Kiriansky, D. Bruening, and S. Amarasinghe. Secure
execution via program shepherding.
In Proceedings of
the USENIX Security Symposium, pages 191–206, August
2002.
[21] V. Kiriansky, D. Bruening,
S. Amaras-
inghe.
Execution model via program shepherding,
www.cag.lcs.mit.edu/commit/papers/ 03/rio-security-tm-
638.pdf, May 2003.
and
[22] D. Larochelle and D. Evans. Statically detecting likely
buffer overﬂow vulnerabilities.
In Proceedings of the
USENIX Security Symposium, pages 177–190, August
2001.
[23] K. S. Lhee and S. J. Chapin. Type-assisted dynamic buffer
overﬂow detection. In Proceedings of the USENIX Secu-
rity Symposium, pages 81–89, August 2002.
[24] S. McPeak, G. C. Necula, and W. Weimer. CCured: Type-
safe retroﬁtting of legacy code. In Symposium on Princi-
ples of Programming Languages, pages 128 – 139, Jan-
uary 2002.
[25] D. Mosberger
and T.
Jin.
for measuring web
tool
http://www.hpl.hp.com/personal/david mosberger/httperf.html.
server
httperf
a
performance
-
[26] Securiteam. http://www.securiteam.com.
[27] SecurityFocus. http://online.securityfocus.com/bid.
[28] I. Simon.
A comparative
of
ods
http://www.mcs.csuhayward.edu/˜simon/security/boﬂo.html.
defense
against
buffer
analysis of meth-
overﬂow attacks
[29] D. D. Sleator and R. E. Tarjan. Self-adjusting binary
search trees. Journal of the ACM, 32(3):652–686, 1985.
[30] StackShield. http://www.angelﬁre.com/sk/stackshield.
[31] D. Wagner, J. Foster, E. Brewer, and A. Aiken. A ﬁrst step
towards automated detection of buffer overrun vulnerabil-
ities. In Proceedings of the Network and Distributed Sys-
tems Security Symposium, pages 3–7, February 2000.
[32] D.
A.
Wheeler.
http://www.dwheeler.com/sloccount/.
Sloccount
[33] J. Wilander and M. Kamkar. A comparison of publicly
available tools for static intrusion detection. In Proceed-
ings of the Nordic Workshop on Secure IT Systems, pages
68–84, November 2002.
[34] J. Wilander and M. Kamkar. A comparison of publicly
available tools for dynamic buffer overﬂow prevention. In
Proceedings of the Network and Distributed System Secu-
rity Symposium, pages 149 – 162, February 2003.