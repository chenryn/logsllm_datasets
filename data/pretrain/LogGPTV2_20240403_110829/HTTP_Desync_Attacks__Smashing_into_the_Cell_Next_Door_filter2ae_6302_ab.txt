如果目标请求看起来像：  
那么，一次CL.TE毒害攻击尝试看起来像是：  
如果攻击成功，受害者请求（绿色）将得到404响应。
te.cl攻击看起来很相似，但是需要一个封闭块，这意味着我们需要自己指定所有的头，并将受害者请求放在正文中。确保前缀中的内容长度略大于正文：
如果一个站点是运行的，另一个用户的请求可能会击中您之前投毒的套接字，这将使您的攻击失败，并可能使用户不安。因此，此过程通常需要进行几次尝试，在高流量站点上可能需要数千次尝试。所以请谨慎和克制行为
## Explore
我将使用一系列真实的网站演示其余的方法。像往常一样，我专门针对那些明确表示愿意通过运行bug奖励计划与安全研究人员合作的公司。多亏了大量涌现的私人程序和不打补丁的习惯，我不得不编写很多案例。在明确声明网站的地方，请记住，它们是少数能够抵御这种攻击的安全网站之一。
现在我们已经确定套接字投毒是可能的，下一步是收集信息，这样我们就可以发动一次全面的攻击。
前端通常会附加和重写HTTP请求头，如x-forwarded-host和x-forwarded-for，以及许多经常难以猜测名称的自定义头。我们的走私请求可能缺少这些头，这可能导致意外的应用程序行为和失败的攻击。
幸运的是，有一个简单的策略另辟蹊径，并且可以看到这些隐藏的header头。这使得我们可以通过手动添加头来恢复功能，甚至可以启用进一步的攻击。
只需在目标应用程序上查找一个反射post参数的页面，对参数进行无序排列，使反射的参数排列最后，稍微增加内容长度，然后将生成的请求进行走私：  
绿色请求将在其到达login[email]参数之前由前端重写，因此当它被反射回来时，将泄漏所有内部头：
通过增加Content-Length头，您可以逐步检索更多信息，直到您试图读取超过受害者请求末尾的内容，并且受害者的请求会超时。
有些系统完全依赖于前端系统的安全性，一旦您bypass，您就可以直接为所欲为。在login.new
relic.com上，“后端”系统是反代的，因此更改走私的主机头授予我访问不同的新relic系统的权限。最初，我访问的每个内部系统都认为我的请求是通过HTTP发送的，并以重定向方式响应的：
使用前面观察到的x-forwarded-proto头很容易修复：  
通过一些目录，我在目标上找到了一个有用的端点：  
错误消息清楚地告诉我需要某种类型的授权头，但却没有告诉我字段名。我决定尝试前面看到的“x-nr-external-service”头段：  
不幸的是，这不起作用——我们还是得到直接访问该URL时的禁止响应(403 forbidden)。这表明前端正在使用x-nr-external-service头来指示请求来自Internet，因为我们是通过走私进行的请求，因此丢失了部分请求头，但是我们已经诱使系统认为我们的请求来自内部。这是非常有意义的，但没有直接的用处——我们仍然需要缺少的授权头的名称。
此时，我可以将已处理的请求反射技术应用到一系列端点，直到找到一个具有正确请求头的端点。相反，我决定从上一次我的New
Relic6中查询一些笔记，这显示了两个非常宝贵的报头-Server-Gateway-Account-Id and Service- Gateway-Is-Newrelic-Admin。使用这些工具，我可以获得对其内部API的完全管理级访问：  
New Relic部署了一个修补程序，并将根本原因诊断为F5 gateway中的一个弱点。据我所知，没有可用的补丁，这意味着在写作的时候这仍然是0day。
## Exploit
直接进入内部API确实不错，但它很少是我们唯一的选择。我们还可以针对浏览目标网站的每个人发起大量不同的攻击。
要确定哪些攻击可以应用到其他用户，我们需要了解哪些类型的请求可以被破坏。从“confirm”阶段重复套接字中毒测试，但不断调整“受害者”请求，直到它类似于典型的GET请求。您可能会发现，您只能使用某些方法、路径或头毒害请求。另外，尝试从不同的IP地址发出受害者请求-在极少数情况下，您可能会发现您只能对来自同一IP的请求进行毒害。
最后，检查网站是否使用Web缓存-这些可以帮助绕过许多限制，增加我们对哪些资源中毒的控制，并最终增加请求走私漏洞的严重性。
### Store
如果应用程序支持编辑或存储任何类型的文本数据，那么利用就非常容易。通过在受害者的请求前加上一个精心设计的存储请求，我们可以让应用程序保存他们的请求并将其显示给我们，然后窃取任何身份验证cookie/headers。下面是一个以Trello为目标的示例，使用其配置文件编辑端点：
一旦受害者的请求到达，它就会保存在我的个人资料中，暴露他们所有的头和cookie：
使用这种技术的唯一主要目的是丢失“&”之后发生的任何数据，这使得从表单编码的post请求中窃取主体很困难。我花了一段时间试图通过使用可选的请求编码来解决这个限制，最终放弃了，但我仍然怀疑这是可能的。
数据存储的机会并不总是如此明显——在另一个网站上，我可以使用“联系我们”表单，最终触发一封包含受害者请求的电子邮件，并获得2500美元的额外收入。
### Attack
能够将一个任意prefix放置到其他人的响应报文中，也打开了另一种攻击途径——触发一个有害的响应。
使用有害反应有两种主要方法。最简单的方法是发出“攻击”请求，然后等待其他人的请求击中后端套接字并触发有害响应。一种更为棘手但更强大的方法是亲自发出“攻击”和“受害者”请求，并希望对受害者请求的有害响应通过Web缓存保存，并提供给访问同一URL的任何其他人-Web缓存中毒。
在以下每个请求/响应片段中，黑色文本是对第二个（绿色）请求的响应。第一个（蓝色）请求的响应被忽略，因为它不相关。
## Upgrading XSS
在审计一个SaaS应用程序时，Param Miner7发现了一个名为saml的参数，Burp
scaner证实它易受反射XSS的攻击。反射式XSS本身不错，但在规模上很难利用，因为它需要用户交互。
通过请求走私，我们可以对主动浏览网站的随机用户提供包含XSS的响应，从而实现直接的大规模利用。我们还可以访问authentication headers
和仅HTTP cookie，这可能会让我们转到其他域。
## Grasping the DOM
在www.redhat.com上查找请求走私链的漏洞时，我发现了一个基于DOM的开放重定向，这带来了一个有趣的挑战：  
页面上的一些javascript正在从受害者浏览器的查询字符串中读取“redir”参数，但我如何控制它？请求走私使我们能够控制服务器认为查询字符串是什么，但是受害者的浏览器对查询字符串的认知只是了解用户试图访问哪个页面。
我可以通过服务器端的某个重定向来解决这个问题：
受害者浏览器将收到一个301重定向到
## CDN Chaining
有些网站使用多层反向代理和cdn。这给了我们额外的机会来desynchronization，这是一直被赞赏的，但它也经常增加了问题带来的严重性
一个目标不知何故地使用两层Akamai，尽管服务器由同一供应商提供，但仍有可能将它们不同步，因此，在受害者网站的Akamai
network中提供不同的内容：  
同样的概念也适用于SaaS提供商——我能够攻破一个建立在知名SaaS平台上的关键网站，将请求定向到建立在同一平台上的不同系统。
## 'Harmless' responses
因为请求走私让我们影响对任意请求的响应，一些通常无害的行为成为可利用的。例如，即使是不起眼的重定向，也可以通过将javascript导入，从而重定向到恶意域来危害帐户。
使用307代码的重定向特别有用，因为在发出post请求后接收307的浏览器将把post重新发送到新的目的地。这可能意味着你可以让不知情的受害者直接将他们的明文密码发送到你的网站。