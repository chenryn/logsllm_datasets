MurmurHash3哈希函数来设置Bloom过滤器。这些nHashFuncs MurmurHash3哈希函数通过nHashNum×0xFBA4C795 +
nTweak初始化，其中nHashNum是哈希函数的索引（例如1st，2nd，3rd），nTweak是SPV客户端为过滤器选择的随机数。要将数据项（例如比特币地址）添加到过滤器，该数据项必须通过nHashFuncs不同的哈希函数进行哈希处理，并通过按位或运算设置过滤器中的相应位。例如，数据项将使用2个不同的哈希函数添加到干净的6位过滤器（值为000000），并且假设第一个和第二个哈希函数的结果分别为7（000111）和9（001001），可以接受的是，将过滤器设置为001111（000111或001001）。
研究表明，为了阻止攻击者通过拦截和分析纯文本filterload消息来准确发现比特币钱包用户曾经使用过的所有比特币地址， _BitcoinJ_
中实现了两种安全机制。首先，由于Bloom过滤器的误报率，一些不属于用户的错误地址将被过滤器过滤掉。其次，仅创建一次filterload消息并将其传输到比特币FNC（成功建立与FNC的TCP连接时），这意味着，如果攻击者从一开始就无法监视SPV客户端的所有活动，则它们将无法拦截filterload消息。
通过进一步的分析，发现这两个安全机制并不是安全的，原因如下。首先，将 _BitcoinJ_
中使用的Bloom过滤器的误报率（假地址数占添加到过滤器的所有地址数之和）设置为0.001％。第二，在SPV客户端和FNC之间建立TCP连接之后，将包含计算得出的Bloom过滤器的filterload消息发送到FNC。但是研究表明，如果SPV客户端与FNC的现有TCP连接被断开，
_BitcoinJ_ 将自动发现并与新FNC连接（参见上面的BitcoinJ
code1中的HandlePeerDeath函数）。因此，SPV客户端可能会遭受TCP重置攻击（即，有意断开受害者与旧FNC的TCP连接）并将filterload消息重新传输到新FNC。最后一点是，发现在SPV客户端使用的网络接口变得无法使用超过5秒后，
_BitcoinJ_ 将使用全新的随机数（即nTweak）生成filterload消息。根本原因是 _BitcoinJ_
维护一个Reset计时器（即5秒）以监视是否仍然存在可用的网络接口。收到比特币消息后，计时器将更新。一旦过期，将清除并重新初始化存储在内存中的多个变量，包括用于生成过滤器的nTweak。请注意，由于nTweak用于初始化filterload消息中使用的nHashFuncs
MurmurHash3哈希函数，因此，由两个不同的nTweaks生成的两条filterload消息可以帮助攻击者显着降低推断比特币用户地址的误报率。
例如，假设有两个由两个不同的nTweaks生成的filterload消息，且误报率设置为0.001％。由于该地址需要通过两个不同的过滤器，因此每个人仅允许0.001％的错误地址通过，因此将错误的地址识别为真实地址的可能性为0.001％×0.001％。
**验证：** 进行了如下实验来验证这种漏洞的能力，首先通过家庭Wi-Fi网络将经过测试的智能手机（例如，Samsung Galaxy S6
Edge）与互联网连接，下载并安装了经过测试的比特币钱包应用程序（例如，使用BitcoinJ的SPV客户，Bitcoin
Wallet）。其次，分别将0.0001
BTC存入了SPV客户端创建的两个比特币地址中。第三，为了使SPV客户端重新传输filterload消息，针对SPV客户端发起了两种攻击：（1）使用Netwox78工具进行TCP重置攻击，该工具旨在代表SPV客户端向FNC发送TCP重置数据包，并且（
2）使用Aircrack-ng进行Wi-Fi取消身份验证攻击，其目的是使SPV客户端的Wi-Fi断开时间超过5秒，如上图所示。第四，利用拦截的filterload中携带的过滤器消息和公共比特币交易数据库（即Blockchain.info）来推断SPV客户端使用的比特币地址。
实验结果如上图所示。通过发起TCP重置攻击，攻击者可以迫使经过测试的SPV客户端重新传输带有0.001％误报率的带有过滤器的filterload消息，而Wi-Fi取消身份验证攻击则允许攻击者获取由两个不同的nTweaks生成的两个filterload消息，这可以将误报率降低到10-8％们进一步检查了公共比特币交易数据库中记录的多少比特币地址可以通过拦截的过滤器。对于被TCP重置攻击拦截的过滤器，有3288个比特币地址通过了该过滤器。但是，比特币钱包应用程序仅使用了两个地址，而其余的3286个地址则未被使用。对于通过Wi-Fi取消身份验证攻击拦截的两个过滤器，只有两个比特币地址同时通过了两个过滤器；这两个比特币地址都属于经过测试的比特币钱包应用程序。验证实验证实，
_BitcoinJ_ 确实泄漏了比特币钱包应用程序使用的比特币地址。
###  V2：没有针对下载比特币交易的反垃圾信息防御
第二个安全漏洞是，使用 _BitcoinJ_
的比特币钱包App将继续在后台从连接的比特币FNC中下载SPV客户端感兴趣的比特币交易，而不会向SPV客户端用户发出任何警报或通知。具体来说，如先前所述，SPV客户端将发送filterload消息，以指定其对特定比特币地址和交易的兴趣到比特币FNC。为了防止FNC或攻击者（中间人）准确地推断比特币用户/钱包的隐私，SPV客户端将通过配置filterload的筛选器字段来添加一些虚假数据项（即，这些内容不符合SPV客户端的兴趣）消息（将误报率设置为0.001％）。如果FNC发现任何符合SPV客户兴趣的比特币交易，则FNC将准备库存消息（即inv），其中包含匹配交易的身份，并将该消息发送给SPV客户。然后，SPV客户端使用
_BitcoinJ_ 处理inv消息。
研究表明， _BitcoinJ_ 将在下载inv消息之前对所有交易进行检查。但是，检查是有缺陷的，如BitcoinJ
code2所示。具体地说，进行了两次检查：（1）是否在（第11行）之前未下载交易，以及（2）交易是否不是自发的（第14行）。如果无论哪种情况都不进行交易，
_BitcoinJ_ 将下载比特币交易（第19行）。这证实了 _BitcoinJ_
在下载交易之前不检查正在下载的比特币交易是否可以通过发送给FNC的先前过滤器。如果在 _BitcoinJ_
上没有部署其他安全机制（例如，与恶意FNC断开连接），则SPV客户端将下载接收到的inv消息中指定的比特币交易操作，无论这些交易是否出于其目的。因此，SPV客户端用户会遭受各种攻击，并且没有意识到这些攻击。
**验证：** 本文进行了一项实验来验证此漏洞。首先在Samsung Galaxy S6
Edge上使用BitcoinJ安装了经过测试的比特币钱包应用程序（即Bitcoin Wallet），并通过家庭Wi-Fi网络将其连接到互联网。其次，使用ARP欺骗攻击拦截了filterload消息。由于比特币并未对所有消息字段都采用消息级加密和完整性保护，因此修改了filterload消息的消息字段Data和nFlag分别设置为0xFF
…
FF和0，并将修改后的filterload消息发送到SPV客户端连接到的FNC。以上修改表示用户对所有全球比特币用户产生的所有新比特币交易感兴趣。实验持续了10分钟。
上图说明了在10分钟的实验运行中，SPV客户端从连接的FNC接收了130条清单消息并下载了2535比特币交易。有三个观察结果。首先，所有下载的比特币交易均不涉及经过测试的SPV客户端曾经使用过的任何比特币地址。其次，SPV客户并未与FNC断开连接，因为FNC出于SPV客户的利益而传输了大量比特币交易。第三，SPV客户端没有向用户显示任何警报或通知（例如，遭受垃圾信息攻击）。这些证实了SPV客户端和BitcoinJ在下载它们之前均未验证是否关注比特币交易，并且未采用任何其他安全机制来阻止由连接的FNC发送的垃圾信息。
###  V3：违反比特币钱包服务去中心化