    0019ee2c 0138a72f EqnEdt32!MFEnumFunc+0xc0a3
    0019ee44 013875da EqnEdt32!MFEnumFunc+0xbf32
    0019eea8 0137f926 EqnEdt32!MFEnumFunc+0x8ddd
    0019eed8 01356a98 EqnEdt32!MFEnumFunc+0x1129
    0019ef3c 755a04e8 EqnEdt32!AboutMathType+0x5a98
    0019ef58 75605311 RPCRT4!Invoke+0x2a
    0019f360 75ddd7e6 RPCRT4!NdrStubCall2+0x2d6
    0019f3a8 75ddd876 ole32!CStdStubBuffer_Invoke+0xb6 [d:\w7rtm\com\rpc\ndrole\stub.cxx @ 1590]
    0019f3f0 75ddddd0 ole32!SyncStubInvoke+0x3c [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1187]
    0019f43c 75cf8a43 ole32!StubInvoke+0xb9 [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1396]
    0019f518 75cf8938 ole32!CCtxComChnl::ContextInvoke+0xfa [d:\w7rtm\com\ole32\com\dcomrem\ctxchnl.cxx @ 1262]
    0019f534 75cf950a ole32!MTAInvoke+0x1a [d:\w7rtm\com\ole32\com\dcomrem\callctrl.cxx @ 2105]
    0019f560 75dddccd ole32!STAInvoke+0x46 [d:\w7rtm\com\ole32\com\dcomrem\callctrl.cxx @ 1924]
    0019f594 75dddb41 ole32!AppInvoke+0xab [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1086]
    0019f674 75dde1fd ole32!ComInvokeWithLockAndIPID+0x372 [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1724]
    0019f69c 75cf9367 ole32!ComInvoke+0xc5 [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1469]
    -------------------------------------------------------------------------------    
    0019ec58  cb ce cc e5 00                                   .....
    ChildEBP RetAddr 
    WARNING: Stack unwind information not available. Following frames may be wrong.
    0019eacc 013717c8 EqnEdt32!FMDFontListEnum+0xbc7
    0019ebc4 01371980 EqnEdt32!FMDFontListEnum+0x534
    0019ecec 0138b463 EqnEdt32!FMDFontListEnum+0x6ec
    0019eda8 7545a24c EqnEdt32!MFEnumFunc+0xcc66
    0019ee08 0136775e kernel32!GlobalUnlock+0xba
    0019ee14 0138a8a0 EqnEdt32!EqnFrameWinProc+0x8c7e
    0019ee2c 0138a72f EqnEdt32!MFEnumFunc+0xc0a3
    0019ee44 013875da EqnEdt32!MFEnumFunc+0xbf32
    0019eea8 0137f926 EqnEdt32!MFEnumFunc+0x8ddd
    0019eed8 01356a98 EqnEdt32!MFEnumFunc+0x1129
    0019ef3c 755a04e8 EqnEdt32!AboutMathType+0x5a98
    0019ef58 75605311 RPCRT4!Invoke+0x2a
    0019f360 75ddd7e6 RPCRT4!NdrStubCall2+0x2d6
    0019f3a8 75ddd876 ole32!CStdStubBuffer_Invoke+0xb6 [d:\w7rtm\com\rpc\ndrole\stub.cxx @ 1590]
    0019f3f0 75ddddd0 ole32!SyncStubInvoke+0x3c [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1187]
    0019f43c 75cf8a43 ole32!StubInvoke+0xb9 [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1396]
    0019f518 75cf8938 ole32!CCtxComChnl::ContextInvoke+0xfa [d:\w7rtm\com\ole32\com\dcomrem\ctxchnl.cxx @ 1262]
    0019f534 75cf950a ole32!MTAInvoke+0x1a [d:\w7rtm\com\ole32\com\dcomrem\callctrl.cxx @ 2105]
    0019f560 75dddccd ole32!STAInvoke+0x46 [d:\w7rtm\com\ole32\com\dcomrem\callctrl.cxx @ 1924]
    0019f594 75dddb41 ole32!AppInvoke+0xab [d:\w7rtm\com\ole32\com\dcomrem\channelb.cxx @ 1086]
    Tue Dec 26 15:56:36.506 2017 (GMT+8): ModLoad: 74f90000 74fdc000   C:\Windows\system32\apphelp.dll
    Tue Dec 26 15:56:36.584 2017 (GMT+8): (304.784): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=00000021 ebx=0019ece8 ecx=0019ec24 edx=771470f4 esi=00000001 edi=00190001
    eip=01380c46 esp=0019ecd8 ebp=d32b8ac7 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202
    EqnEdt32!MFEnumFunc+0x2449:
    01380c46 c9              leave
从日志中可以看到存在两次拷贝，通过栈回溯我们可以知道这两次拷贝正是静态分析中对sub_21174的两次调用。第一次是sub_214c6对sub_21174的调用，第二次是sub_21174对自身的调用。可以看到第一次拷贝时明显发生了栈溢出。这里稍微提一下，cb
ce cc e5代表的是宋体。
我们来详细计算一下需要溢出多少长度才能控制父函数(sub_21174)的返回地址(这个问题的结论在“补丁绕过分析”一节已被提及)，由图11可知，从lfFaceName(-0x90)溢出到ret_addr(+0x4)，一共需要0x94字节，超出0x94部分的字节会逐个从低地址开始覆盖返回地址。
图11
我们对照poc里面的数据来看一下，如图12所示，蓝色部分为溢出的前0x94字节，25 00
为溢出的最后两个字节，00为终止符，拷贝时遇到00就停止。按照小端地址布局，poc运行时，EIP只会被覆盖低位的2个字节。为什么这样做？答案是为了绕过ASLR。
图12
#### Bypass ASLR
我们来看一下为什么区区两个字节就可以绕过 ASLR。
首先我们要清楚，补丁文件是开启了ASLR的，如图13所示。这样一来每次加载EQNEDT32.EXE时的基址都是随机的，所以溢出时需要考虑的第一个问题就是如何绕过ASLR。(至于DEP，由图14可以看到，补丁文件的EQNEDT32.EXE未开启DEP，所以正常情况下无需考虑DEP)
不幸的是，攻击者显然对Windows系统机制和防御措施非常了解。因为在Windows平台上，32位进程的ASLR每次只随机化地址的高2个字节，而低2个字节保持不变。假如能在被覆盖的地址的同一片低0xFFFF空间内找到一个ret指令，并且满足形如0xABCD00XY的这种地址(其中ABCD及XY为6个任意16进制数，地址中倒数第二个字节必须为0x00，因为复制完后需要精确截断)，就可以直接利用这个ret跳转到栈上。由于无需绕过DEP，所以可以在栈上直接执行shellcode。
图13：EQNEDT32.EXE的ASLR状态为启用，DEP为非永久DEP
图14: EQNEDT32.EXE的DEP状态为停用
更加不幸的是，在EQNEDT32.EXE模块内，微软还真给且仅给了这样一个地址(图15)，满足条件的地址有且仅有一个，即20025，eip中被覆盖的两个字节25
00是唯一的，没有第二个满足条件的ret。
图15
我们来思考一下sub_21174原来的返回地址是什么？当然是sub_214C6调用sub_21174的下一条指令的地址，由图16可以看到这个地址的偏移为214E2，按照图12的覆盖方式，覆盖后的偏移变成了20025，由上面的分析及图17中可以看到，这个地址是一条ret指令。这条指令会弹出sub_214C6给sub_21174的第1个参数，并且将控制流切换到这个值去执行。雪上加霜的是，这第1个参数恰好为lpLogFont，正是用户所提供的FontName。所以ret执行后，控制流会被转移到栈上，并且恰好开始执行用户提供的FontName的第一个字节。
图16
图17
#### 样本A的Shellcode分析
在针对样本A改造的poc中，控制流劫持及shellcode部分的执行如图18所示：
图18：由于递归的存在，从sub_21774函数中需要返回两次，这解释了前两个ret
jmp eax指令后会马上调用WinExec，而命令行参数恰好为calc.exe，如图19所示：
图19
#### 样本B的Shellcode分析
样本B绕过ASLR的方式和样本A一致，但shellcode部分与样本A不一样。样本B的shellcode会通过PEB找到kernel32.dll的导出表(图20和图21)，然后通过特定的hash算法(图21)在导出表中搜索比较所需函数的哈希值，所需函数的哈希值在shellcode中所给出。随后，shellcode会将查找到的函数地址保存到之前存放hash值的地方(图22)。
图20：样本B的shellcode中所给出的hash值及拷贝的路径名称
图21：通过hash值在kernel32.dll的导出表中查找所需函数
图22：查找函数地址前后栈上数据的对比
在成功查找到函数并且将地址保存到栈上后，先调用ExpandEnvironmentStringsA函数展开短路径(短路径保存在shellcode中)，再调用CopyFileA将payload拷贝到word插件目录下，从而让payload随着word下次启动自动加载到内存。最后调用ExitProcess退出公式编辑器进程(图23)。整个过程并不影响文档的正常打开。
图23：展开短路径，拷贝文件，退出进程
## 总结
“噩梦公式二代”（CVE-2018-0802）所使用的0day漏洞堪称CVE-2017-11882的双胞胎漏洞，攻击样本中的一个漏洞针对未打补丁前的系统，另外一个漏洞针对打补丁后的系统，利用两个OLE同时进行攻击，黑客精心构造的攻击完美兼容了系统漏洞补丁环境的不同情况。这个漏洞的利用技巧和Bypass
ASLR的方式都带有一定的巧合性，假如EQNEDT32.EXE模块内没有一条满足条件的ret指令可以用来绕过ASLR，假如lpLogFont不是sub_21774的第一个参数，假如CVE-2017-11882的补丁修复方式强制开启了DEP保护，“噩梦公式二代”将没有可乘之机。
最新的360安全产品已可以检测并防止此0day漏洞的攻击，同时我们建议用户及时更新2018年1月的微软安全补丁。
## 参考