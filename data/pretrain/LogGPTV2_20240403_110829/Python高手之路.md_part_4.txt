---
## Page 25
熊猫爱中国www.xiongmaoi.com
不同模式和准则。
这些设计笔记直接写进了 stevedore 官方文档的简介里，用来解释在应用程序中使用插件的
使用。我意识到，如果我在类的构造函数中放最复杂的参数，方法map（）几乎是可互换的。
了些时间思考我见过的使用插件的通用模式，并且写了几页粗略的文档描述这些类应该如何
理解如何使用这个库，还可以了解在创建它时我的期望是什么。这就是我用在 stevedore 上
需要提交任何实现的细节。它还让我可以记录对于设计我所做出的选择，以便读者不仅可以
方式去构建这个库。
应用程序变得更容易一点儿。我通常会以测试的方式创建一系列示例程序，然后依照其工作
人员如何使用其API。通过先写测试代码而不是库代码，可以让思考如何通过这个新库开发
成器创建了基类。通过让这些类遵循同样的API使我可以很容易地创建数据收集应用的一个
的方法。
版本，它可以直接将数据写入数据库而无需通过网络发送数据。
存。在添加几个不同的报告功能的过程中，我意识到重放已收集的数据的过程和在一开始收
从另一个运行的应用程序收集数据，另一部分用来接收通过网络发送过来的数据并将其保
先尝试用 Python的 trace API写一些临时脚本。对于 smily 我最初的设想包括一个仪表盘并
建测试用例也可以让代码重构更容易。
它们，在这个功能可以基本调通后，再编写测试用例确保我已经覆盖了所有的边界情况。创
次提交代码前添加可能的自动化测试。
数据运行应用程序，以便我理解它是如何工作的。我经常会做一些修改并测试它们，并在每
何工作的，我需要改进哪些代码。我可能会添加日志或是输出语句，或是用pdb，利用测试
我个人在对应用程序和库开发的处理方式上有更多的不同。
18
我知道我想让 stevedore 能够提供一组类用来管理应用程序的插件。在设计阶段，我花
当设计一个应用程序时，我会考虑用户界面是如何工作的，但对于库，我会专注于开发
创建一个新应用时，我会采取相同的逐步探索方法。我先创建一些代码，然后手动运行
·从抽象角度看步骤都差不多，但是细节上有所不同。相对于对比开发新项目和已有项目，
我还发现，在写任何库的代码之前先写文档让我可以全面考虑功能和流程的使用，而不
这正是smiley（https://pypi.python.org/pypi/smiley）的情况。在开发正式应用程序前，我
当我要修改已有代码时，特别是这些代码是其他人创建的时，起初我需要研究代码是如
第2章模块和库
本电子书仅限学习交流使用，请勿用于商业用途
---
## Page 26
熊猫爱中国www.xiongmaoi.com
熊猫爱中国
还是应该写他们自己的函数，切换到其他外部库或是开始给Python提交补丁？
我特别想了解对于日期/时间的处理。对此你有什么建议吗？程序员应该坚持使用标准库，
能够用来为模板解析创建上下文或者通过清晰的流程定义来管理不同来源的配置。
访问属性。另一个有意思的数据结构是ChainMap，它可以生成良好的层级命名空间。ChainMap
加逻辑的话，可以很容易将 namedtuple 转换成一个普通的类，因为 namedtuple 支持通过名字
来创建一些小的像类一样的数据结构来保存数据但并不需要任何关联逻辑。如果之后需要添
此它非常适合放到标准库中。我特别喜欢它可以搜索稀疏列表，且搜索的值可能并不在其中。
Python也有。
可选的。抽象基类已经在其他一些语言中内置了，但我发现很多Python 程序员并不知道
抽象基类进行的扩展定义API，以帮助扩展的作者们了解API的哪些方法是必需的，哪些是
（bugfix）的更新可以更频繁，对于处理新技术或 API 的库来说这尤其重要。
因此在标准库之外维护一个新的库可能更实用。单独的发布使得对于新功能和 bug 修复
Proposal，PEP)，它包括添加这个模块的动因，以及如何过渡的一些实现细节。
的感兴趣程度。如果回应很积极，下一步就是创建一个Python 增强提案（PythonEnhancement
不同的变种。API应该非常清晰并且它的实现不能依赖任何标准库之外的库。
供的功能要么是很难正确实现的，要么是非常有用以至于许多开发人员已经创建了他们自己
stdlibchanges.html）中找到。
许多项目（包括OpenStack）或者外部库，会在标准库之上封装一层自己的抽象。例如，
collections模块中有许多有用的数据结构并没有得到广泛使用。我喜欢用namedtuple
bisect模块中的二分查找算法是个很好的例子，一个广泛使用但不容易正确实现的功能，因
最近我做了许多关于应用程序中动态加载扩展方面的工作。我使用 abc 模块为那些作为
所有这些都可以。我倾向于避免重复造轮子，所以我强烈主张贡献补丁和改进那些能够
标准库中的哪三个模块是你最想人们深入了解并开始使用的？
因为包的管理和发现工作已经非常稳定了，尤其是 pip 和 Python Package Index（PyPI)，
提议一个新模块的第一步是在社区通过 python-ideas 邮件列表非正式地了解一下大家对此
一个模块在被加入 Python 标准库之前，需要被证明是稳定且广泛使用的。模块需要提
将一个模块加入Python标准库的流程是什么？
本电子书仅限学习交流使用，请勿用于商业用途
2.5Doug Hellmann 访谈
9
---
## Page 27
熊猫爱中国www.xiongmaoi.com
熊猫爱中虑将其拆到一个包中。与上层模块或者应用程序模块相比，对底层模块的这种拆分可能会发
绑定过于紧密，导致很难修改和重用。
重新组合以构建其他应用程序。未能采用这种方法的话意味着应用程序的功能和用户界面的
中，这会让测试变得更简单。这还意味着应用程序的功能可以通过库进行访问，并且能够被
将这些功能实现为一个库，然后在构建应用程序时确保库的代码能够很好地组织到逻辑单元
成一个库。关于设计、规划、迁移等，做这些最好的方式是什么？
Python3上的库基本会被视为“不再维护”。
新项目都应该认真考虑对 Python3的支持，除非有尚未移植的依赖。目前来说，不能运行在
也很容易。主要的Linux发行版正在致力于将Python 3默认安装。任何人要用Python 创建
程序从未如此简单过，而且幸亏有3.3中加入的兼容性功能使同时维护对Python 2.7的支持
生得更快，因为对于上层模块我期望将更多片段组织在一起。
重用的修改贡献对于维护一个“私有的”框架似乎更可取。
我们可能需要增强其中一个以便其可以完全适应OpenStackAPI服务器的需要时，将这些可
框架转成采用一个第三方Web 开发框架。在Python中开发WSGI应用有很多选择，并且当
它们不太适合作为 Python 标准库的补丁或者作为一个通用库发布以及被其他项目采用。
可以保证它们在OpenStack项目中以一致的方式进行处理。因为许多函数都是应用相关的，
很薄的封装。大部分功能都简短且简单，但通过将这些最常见的操作封装为一个模块，我们
程序内还是作为一个新的库。
用来作为依赖的项目。但是，有时创建另外的抽象并单独维护代码也是合理的，不管在应用
20第2章模块和库
你提到的例子中，OpenStack里的 timeutils 模块就是对 Python的 datetime 模块的一层
应用程序就是“胶水代码”的集合用来将库组织在一起完成特定目的。起初设计时可以
支持 Python3 的第三方库的数量已经到了决定性的时刻。针对 Python3开发新库或应用
关于Python3，有什么模块是值得一提而且能令开发人员有兴趣深入了解的？
我没有什么硬性限制，但是如果我有过多的导入时，我会重新考虑这个模块的设计并考
当从标准库或其他地方导入并使用大量模块时，关于该做什么你有什么特别的建议吗？
与之相反，我目前正致力于将OpenStack的API 服务项目从早期创建时使用的WSGI
本电子书仅限学习交流使用，请勿用于商业用途
---
## Page 28
熊猫爱中国www.xiongmaoi.com
熊猫生成器表达式，因为生成器表达式，更有效也更容易理解。列表的组合也很常见，以便它们
版本边界。这种情况突显了理解依赖管理和确保持续集成测试中适当的测试配置的重要性。
的用户造成了问题。解决方案就是在cliff 的依赖列表中对Python 2和Python 3提供不同的
(https://pypi.python.org/pypi/cliff)的设置中限制依赖版本号，所以 pyparsing 的新发布给cliff
消了对 Python 2的支持，
通过使用元组和新类将相关的值合并到一个对象中从而减少函数的参数，以及在公共API
的内容可以以某种方式一起被处理，但却没有使用itertools.chain（）。
新是个重大的修改，而且是明确标识成这样的，但是因为我没有在对cliff
中定义要使用的类而不是依赖于字典。
if:then:else块作为查找表，确保函数总是返回相同的类型（如一个空列表而不是None)，
个循环中处理这个结果（可能将列表作为参数传给一个函数）。我通常建议将过滤循环改成
见的反模式是使用for 循环过滤一个列表并将元素加入到一个新的列表中，然后再在第二
是被库的设计强加的约束去使用这个库。
是单独的。开发人员可以自行决定对于API访问的正确的抽象程度，并基于他们的需求而不
的组织应该不同于公共 API。
例中被方法使用，以及每个方法每次都要传入哪些值。最后，考虑实现以及是否底层的代码
考虑调用者如何使用这个库，并创建一个API去支持这些功能。考虑什么值可以存在一个实
Principle，SRP）（http://en.wikipedia.org/wiki/Single_responsibility_principle）这样的设计准则。
框架像任何工具类型一样。它们确实有帮助，但在选择框架时要特别谨慎，应确保它能
你怎么看待框架？
最近，我有个例子，pyparsing（https://pypi.python.org/pypi/pyparsing）的一个新发布取
有没有关于选择了一个“错误”的依赖的具体的例子是你亲身经历或目睹过的？
还有一些我在代码评审时给出的更细小的建议，例如，使用 dict（)而不是长的
Python的习惯用法和其他语言的一个较大的不同在于循环和迭代。例如，我见过的最常
当你随机看Python程序员的代码时遇到的最常见的编程错误是什么？
SQLAlchemy是应用这些原则的绝好例子。声明式 ORM、数据映射和表达式生成层都
我通常建议自顶向下设计库和API，对每一层应用单一职责原则（Single Responsibility
对于计划开始构建自己的Python库的人们有什么样的建议呢？
：这给我正在维护的一个库带来了一点儿小麻烦。对 pyparsing 的更
本电子书仅限学习交流使用，请勿用于商业用途
2.5Doug Hellmann 访谈
---
## Page 29
熊猫爱中国www.xiongmaoi.com
熊猫爱中国
可以采用增加小版本号的方式。
分开发人员通过主版本号的增加来表示此类变化，但这取决于你对版本号管理的方法，你也
然可以将Unix系统作为你的灵感来源。通常，版本号应该反映出 API 对用户的影响，大部
护者如何选择正确的版本号和策略。但是，关于如何定义自己的库或应用程序的版本，你依
和细粒度的版本标识符。Python 中没有这样的系统，也没有对应的转换。因此完全取决于维
智的。
核公共API 破坏的零容忍而闻名。考虑到如此多的人依赖Linux，可以说他的选择是非常明
共 API，而_bar 是私有的。
不需要直接操作这些API)，因而可以任意处理它们：分解、调整或者根据需要任意使用。
库暴露给终端用户的API。内部 API则有另外的考虑，并且由于它们在内部（也就是说用户
2.6管理API变化
终将不得不同框架做斗争。
的框架会令应用的实现变得更难。如果你试着使用与框架建议不同的模式或惯用方式，你最
映应用程序本身的设计。如果设计的限制不能从根本上符合应用程序的需求，那么选择错误
程中保持一致，这意味着最终你的代码将更易于理解且更可重用。
个应用程序迅速达到一个可用的状态而不是从头开发。它们还可以激励你在应用程序开发过
过提供许多类似运行在开发模式或者写一个测试套件这样的引导代码，它们还可以帮你让一
够很好地完成当前的工作。
22
Unix平台的库管理系统很复杂，它依赖于soname（http://en.wikipedia.org/wiki/Soname）
在构建 API 时，最糟糕的事情莫过于 API 被突然破坏。Linus Torvalds 就因对 Linux 内
这两种 API 很容易区分。Python 的传统是用下划线作为私有 API 的前缀，如 foo 是公
通过抽取公共部分到一个框架中，你可以将你的开发精力专注于应用中独特的方面。通
不管如何决定，最重要的一步就是在修改API时要通过文档对修改进行详细地记录，包括：
在后面的段落中 women 将讨论如何管理公共 API 的变化。公共 API 是指将应用程序或
在构造 API时很难一而就。API需要不断演化、添加、删除或者修改所提供的功能。
虽然使用框架时还有其他一些潜在的缺点需要注意。决定使用某个特定框架通常能够反
第2章模块和库
本电子书仅限学习交流使用，请勿用于商业用途
---
## Page 30
熊猫爱中国www.xiongmaoi.com
熊猫爱
这些警告能够用来通知开发人员某个正在调用的函数已经废弃或即将废弃。这样，开发人员
码发出不同类型的警告信息，如 PendingDeprecationWarning 和DeprecationWarning。
文档。
缺点就是，你不能指望开发人员在升级你的 Python 包到新版本时会去读你的修改日志或者
能不应该再被使用，并且可以直接访问到新功能，并随之解释如何升级旧代码。这个方法的
示例2.2API变化的记录
录见示例2.2.
为作废，所以新用户不会去使用它。在维护实在太麻烦时再移除旧接口。API变化的记
Python 提供了一个很有意思的名为 warnings 的模块用来解决这一问题。这一模块允许代
使用 Sphinx标记强调修改是个好主意。在构建文档时，用户应该能清楚地知道某个功
class Car(object):
旧接口不要立刻删除。实际上，
●记录废除的旧的接口；
●记录新的接口；
）记录如何升级到新的接口。
def turn left(self):
def turn(self,
pass
#Write actual code here instead
"""Turn the car left.
1111
:type direction:str
:param direction: The direction to turn to.
self.turn(direction='left')
.deprecated:: 1.1
direction):
本电子书仅限学习交流使用，请勿用于商业用途
：应该尽量长时间地保留旧接口。因为已经明确标识
2.6管理API变化
23
---
## Page 31
熊猫爱中国www.xiongmaoi.com
熊猫爱中国
注意
示例2.3带警告的API变化的记录
就能够看到他们正在使用旧接口并且应该相应地进行处理?。
手册。
时指定-W all 选项来禁用这一过滤器。关于-W的可用值的更多信息可以参考 python
从Python 2.7开始，DeprecationWarning默认将不显示。可以通过在调用python
24
对应物。
>>> Car().turn_left()
任何调用了废弃的turn_left 函数的代码，都将引发一个警告：
回到之前的例子，我们可以利用它向用户发出警告，如示例2.3所示。
class Car(object):
import warnings
第2章模块和库
def turn(self, direction):
def turn_left(self):
pass
# Write actual code here instead
self.turn(direction='left')
warnings.warn("turn_left is deprecated, use turn instead",
"""'Turn the car left.
:type direction: str
:param direction: The direction to turn to.
 Use :func: 'turn` instead with the direction argument set to "left",
 deprecated:: 1.1
DeprecationWarning)
本电子书仅限学习交流使用，请勿用于商业用途
---
## Page 32
熊猫爱中国www.xiongmaoi.com
熊猫爱许作为插件被集成到其他 Web 框架中。
开发人员可以使用这个框架定义Python 风格的Web服务，并且支持多种丰富的 API，且允
2.7Christophe de Vienne 访谈
示例2.4 运行 python -W error
个错误被抛出，这样使用你的库的开发人员就可以很容易知道如何具体修改他们的代码。
-W error 选项，它会将警告转换为异常。这意味着一个废弃的函数每次被调用时都会有-
因为这其实也可以自动化。当运行他们的测试集合时，开发人员可以在执行 python 时使用
Christophe是一名Python程序员，并且是WSME（Web Services Made Easy）的作者。
·过于复杂。常言道：“Keep It Simple”（也有人说“Keep It Simple Stupid"，但我认为
有许多我在设计Python API 时试图避免的错误。
>>> import warnings
在设计Python的API时开发人员常犯的错误是什么？
Traceback (most recent call last):
>>> warnings.warn("This is deprecated", DeprecationWarning)
让你的代码告诉开发人员他们的程序正在使用某些最终将要停止工作的东西是明智的，
File"",line 1,in 
API几乎与它做的事一样复杂。
的 API是非常简单且自然的，但是在背后它做了很多复杂的工作。相比而言，urllib
就是Request 库（http:/www.python-requests.org/）)，与其他标准 urllib库相比，Requests
要让实际的库函数也太简单，但让库函数简单也是一个明智的想法。一个好的例子
“simple”和“stupid”并不兼容)。复杂的API会很难理解也难以文档化。不过没必