user and reasons about the exposure of data represented by the output. It then
attempts to uniquely concretize the user input. If the user input can be uniquely
concretized, then it represents that the input required to reach the privileged
program point can be uniquely determined by the attacker, and the associated
path is labeled as an authentication bypass . At this point, Firmalice
terminates its analysis. In cases where the user input depends on data exposed
by the device’s output, a function that can generate valid inputs for a provided
output is produced.
Choosing I/O
What should be considered as user input to the firmware is not always obvious.
Firmalice uses several heuristics to identify input and output. Alternatively,
Firmalice can accept a specification of the Application Binary Interface of the
firmware and use that to choose between input and output.
Data Exposure
1776
8.27 Firmalice - Automatic Detection of Authentication Bypass Vulnerabilities in
Binary Firmware
The core intuition of our approach is that data seen by the user, via an output
routine, is exposed to the attacker. Specifically, this exposure does not just
reveal information about the output data: information is also revealed about any
data that depends on or is related to the output. The attackers can deduce
information about authentication credentials by observing program outputs.
Constraint Solving
For each privileged state, Firmalice attempts to concretize the user input to
determine the possible values that a user can input to successfully reach the
privileged program point. A properly-authenticated path contains inputs that
concretize to a large set of values. Conversely, the existence of a path for which
the input concretizes into a limited set of values signifies that an attacker can
determine, using a combination of information within the firmware image and
information that is revealed to them via device output, an input that allows them to
authenticate.
1777
8.28 Cross-Architecture Bug Search in Binary Executables
8.28 Cross-Architecture Bug Search in
Binary Executables
paper video
简介
这篇文章提出了一个系统来导出已知漏洞的漏洞签名（bug signatures），然后可
以利用这些签名来查找不同 CPU 架构（x86、ARM和MIPS）上的其他二进制文件
中的漏洞。
方法
实现
1778
8.29 Dynamic Hooks: Hiding Control Flow Changes within Non-Control Data
8.29 Dynamic Hooks: Hiding Control Flow
Changes within Non-Control Data
paper
简介
1779
8.30 Preventing brute force attacks against stack canary protection on networking
servers
8.30 Preventing brute force attacks against
stack canary protection on networking
servers
paper
简介
1780
8.31 WYSINWYX What You See Is Not What You eXecute
8.31 WYSINWYX What You See Is Not What
You eXecute
paper
简介
1781
8.32 Unleashing MAYHEM on Binary Code
8.32 Unleashing MAYHEM on Binary Code
paper
简介
1782
8.33 Under-Constrained Symbolic Execution: Correctness Checking for Real
Code
8.33 Under-Constrained Symbolic
Execution: Correctness Checking for Real
Code
paper
简介
1783
8.34 Enhancing Symbolic Execution with Veritesting
8.34 Enhancing Symbolic Execution with
Veritesting
paper
简介
1784
8.35 Q: Exploit Hardening Made Easy
8.35 Q: Exploit Hardening Made Easy
paper
简介
1785
8.36 A Survey of Symbolic Execution Techniques
8.36 A Survey of Symbolic Execution
Techniques
paper
简介
1786
8.37 CUTE: A Concolic Unit Testing Engine for C
8.37 CUTE: A Concolic Unit Testing Engine
for C
paper
简介
1787
8.38 TaintEraser: Protecting Sensitive Data Leaks Using Application-Level Taint
Tracking
8.38 TaintEraser: Protecting Sensitive Data
Leaks Using Application-Level Taint
Tracking
paper
简介
1788
8.39 DART: Directed Automated Random Testing
8.39 DART: Directed Automated Random
Testing
paper
简介
1789
8.40 EXE: Automatically Generating Inputs of Death
8.40 EXE: Automatically Generating Inputs
of Death
paper
简介
1790
8.41 IntPatch: Automatically Fix Integer-Overflow-to-Buffer-Overflow Vulnerability
at Compile-Time
8.41 IntPatch: Automatically Fix Integer-
Overflow-to-Buffer-Overflow Vulnerability
at Compile-Time
paper
简介
1791
8.42 Dynamic Taint Analysis for Automatic Detection, Analysis, and Signature
Generation of Exploits on Commodity Software
8.42 Dynamic Taint Analysis for Automatic
Detection, Analysis, and Signature
Generation of Exploits on Commodity
Software
paper
简介
1792
8.43 DTA++: Dynamic Taint Analysis with Targeted Control-Flow Propagation
8.43 DTA++: Dynamic Taint Analysis with
Targeted Control-Flow Propagation
paper
简介
1793
8.44 Superset Disassembly: Statically Rewriting x86 Binaries Without Heuristics
8.44 Superset Disassembly: Statically
Rewriting x86 Binaries Without Heuristics
paper
简介
1794
8.45 Ramblr: Making Reassembly Great Again
8.45 Ramblr: Making Reassembly Great
Again
paper slides video
简介
静态二进制重写在逆向工程中有许多重要的应用，例如补丁、代码重用和插桩。
Reassembly 就是静态二进制重写的一种有效方法（Reassembly is the process of
assembling a set of instructions obtained through disassembly and which were
certainly patched or modified）。
本文提出了一种新的 binary reassembling 的方法，并实现了工具 Ramblr。该方法
首先将原始的二进制文件反汇编，正确识别符号和预期的跳转目标，插入必要的补
丁，然后将程序集重新组装到修补后的二进制文件中。
1795
8.46 FreeGuard: A Faster Secure Heap Allocator
8.46 FreeGuard: A Faster Secure Heap
Allocator
paper slides video source
简介
1796
8.47 Jump-Oriented Programming: A New Class of Code-Reuse Attack
8.47 Jump-Oriented Programming: A New
Class of Code-Reuse Attack
paper
简介
1797
8.48 Reassembleable Disassembling
8.48 Reassembleable Disassembling
paper slides video source
简介
1798
8.49 Understanding Integer Overflow in C/C++
8.49 Understanding Integer Overflow in
C/C++
简介
1799
九、附录
第九章 附录
9.1 更多 Linux 工具
9.2 更多 Windows 工具
9.3 更多资源
9.4 Linux 系统调用表
9.5 幻灯片
1800
9.1 更多 Linux 工具
9.1 更多 Linux 工具
dd
dmesg
file
edb
foremost
ldd
ltrace
md5sum
nm
objcopy
objdump
od
readelf
socat
ssdeep
strace
strip
strings
valgrind
xxd
dd
dd 命令用于复制文件并对原文件的内容进行转换和格式化处理。
重要参数
if=FILE read from FILE instead of stdin
of=FILE write to FILE instead of stdout
skip=N skip N ibs-sized blocks at start of input
bs=BYTES read and write up to BYTES bytes at a time
1801
9.1 更多 Linux 工具
patch 偏移 12345 处的一个字节：
echo 'X' | dd of=binary.file bs=1 seek=12345 count=1
常见用法
$ dd if=[file1] of=[file2] skip=[size] bs=[bytes]
dump 运行时的内存镜像：
cat /proc//maps
找到内存中 text 段和 data 段
dd if=/proc//mem of=/path/a.out skip=xxxx bs= 1
count=xxxx
dmesg
dmesg 命令用于显示 Linux 内核环形缓冲区（ring buffer）的信息。开机信息和各
种错误信息都会放到里面。在调试和故障诊断中非常有用。
-c, --read-clear
Clear the ring buffer after first printing its contents.
-s, --buffer-size size
Use a buffer of size to query the kernel ring buffer. Thi
s is 16392 by default.
-n, --console-level level
Set the level at which printing of messages is done to the
console.
file
file 命令用来探测给定文件的类型。
技巧
1802
9.1 更多 Linux 工具
$ file -L [file]
当文件是链接文件时，直接显示符号链接所指向的文件类别。
edb
edb 是一个同时支持x86、x86-64的调试器。它主要向 OllyDbg 工具看齐，并可通
过插件体系进行功能的扩充。
安装
$ yaourt -S edb
foremost
foremost 是一个基于文件文件头和尾部信息以及文件的内建数据结构恢复文件的
命令行工具。
$ yaourt -S foremost
ldd
ldd 命令用于打印程序或者库文件所依赖的共享库列表。
ldd 实际上仅是 shell 脚本，重点是环境变量 LD_TRACE_LOADED_OBJECTS ，在执
行文件时把它设为 1 ，则与执行 ldd 效果一样。
$ ldd [executable]
$ LD_TRACE_LOADED_OBJECTS=1 [executable]
ltrace
1803
9.1 更多 Linux 工具
ltrace 命令用于跟踪进程调用库函数的情况。
-f trace children (fork() and clone()).
-p PID attach to the process with the process ID pi
d.
-S trace system calls as well as library calls.
md5sum