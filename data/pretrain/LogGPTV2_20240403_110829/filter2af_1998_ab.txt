    sudo chmod o+w /data
    su - postgres
    mkdir /data/postgresql
    mkdir /data/postgresql/data
    # postgres用户初始化数据库
    /usr/lib/postgresql/13/bin/initdb -D /data/postgresql/data
    # 启动数据库
    /usr/lib/postgresql/13/bin/pg_ctl -D /data/postgresql/data -l logfile start
    #查看是否监听了端口(结果应类似下图)
    netstat -nlp |grep 5432
    参考：https://www.cnblogs.com/0x200/p/14026460.html
接下来应该就能按照官方的Usage来使用了（没试）：[firmadyne: Platform for emulation and dynamic
analysis of Linux-based firmware
](https://github.com/firmadyne/firmadyne#usage)
**【方案2】安装[firmware-analysis-plus](https://github.com/liyansong2018/firmware-analysis-plus)**
因为用Firmadyne直接进行调试比较麻烦，所以用了FAP这个项目。
这是个国人写的中文项目，没啥好说的：[liyansong2018/firmware-analysis-plus: 开源固件仿真平台，使用 firmadyne
一键模拟固件 (github.com)](https://github.com/liyansong2018/firmware-analysis-plus)
安装作者提供的binwalk的时候一直报错(kali2021 & ubuntu18
both)，导致一直卡在提取固件的步骤（emmmm哪位大哥部署成功后教我一下)
对此提了个issue
**【方案3】AttifyOS**
这个方法比较稳，自己部署也太折磨人了（外加考试周给娃弄傻了）
_注：密码是attify_
###  模拟执行固件
模拟固件运行：
通过192.168.0.50即可访问固件
###  调试固件
这个部分用到了Damn Vulnerable Router Firmware这个项目，大小400M+，建议上gitee clone
安装以下工具：
    sudo apt install gdb-multiarch
    wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh
    sudo pip3 install capstone unicorn keystone-engine
进入DVRF/Firmware/，用binwalk提取DVRF_v03.bin
提取出来的目录里有个文件夹pwnable，里面存放着漏洞程序示例，选取stack_bof_01程序进行实验，程序的源代码可以在DVRF/Pwnable
Source/Intro/里查看
首先用reasdelf查看程序架构
!
（顺手试了一下checksec，这里居然有装😀）
拷贝qwmu-mipsel-static到固件根目录：
    cp (which qemu-mipsel-static) .
用qemu虚拟运行stack_bof_01：
以调试的方式启动程序，并在1234端口进行监听：
    sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01
打开一个新的shell，运行以下命令：
    gdb-multiarch pwnable/Intro/stack_bof_01
    # 设置架构
    set architecture mips
    #设置调试端口
    target remote 127.0.0.1:1234
创建trash触发溢出：
    pattern create 300
带上它重新进行调试
gdb attach后继续让程序运行，触发vul
接下来就直接ret2system，但经过尝试后发现，如果直接把跳转地址设置为后门函数dat_shell的起始地址0x400950会触发异常
查看函数汇编代码（MIPS…看不懂的话可以边看边学一波，[MIPS 通用寄存器_flyingqr的专栏-CSDN博客_mips寄存器](https://blog.csdn.net/flyingqr/article/details/7073088)；[MIPS汇编指令集
– 深海之炎 – 博客园 ](https://www.cnblogs.com/glodears/p/9762615.html)；[MIPS的汇编指令 ·
语雀 ](https://www.yuque.com/liyanfu/mq65pb/bv7xb5)）
调试中发现，当执行到0x400970时，gp寄存器指向了不可访问的地址
而gp的值是由上一条指令得到的
本来执行后v0要指向 指向__DT_MIPS_BASE_ADDRESS的指针
简单来说就是强行跳转到backdoor之后，因为t9（默认在运行中指向当前函数的起始地址）没有发生改变，导致在执行0x400970时产生异常访问
但可以发现（其实是按照exp来推…）main函数中的gp在-0x7fe4后刚好指向PTR__DT_MIPS_BASE_ADDRESS*（猜测原因是源代码中后门函数在main函数后面且没有被调用，导致编译时认为main函数和后门函数的
gp和表的偏移 相等）
于是得到
* * *
update：
main函数中
所以gp在函数执行完毕后依旧指向的是基地址表
* * *
_感觉对于mips程序的分析，Ghidra比IDA好用些_
从这题也能看出mips和x86、x64的不同之处， **除了这种特殊情况外，大多数情况下还是应该寻找gadget来进行跳转改变t9寄存器**
**这一节就到这，DVRF这个项目还设计了一些别的漏洞程序可以再进行分析**
## 0x4 解密固件
访问dlink的ftp服务器获得几个DIR-882的固件（图中选中的文件），时间跨度为2017~2020年
    ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/
解压得到固件和对应的版本说明
###  加密固件发布方案
一般来说，有三种发布固件的方案
  * 出厂时未加密，解密例程在高版本固件v1.1中给出，为后续的加密固件做准备  
对于这个方案，我们可以通过解密v1.1来获得解密例程
  * 出厂时的固件已经加密，供应商决定更改高版本固件的加密方式，并发布了包含解密例程的未加密中间版本v1.2  
这一方案与上面那个类似
  * 出厂时的固件已经加密，供应商决定更改高版本固件的加密方式，并发布了包含解密例程的使用原加密方式加密的过渡版本v1.3  
这种方案对获取解密例程的难度较大，可从硬件中直接提取固件或对发布的v1.3进行分析
DIR-882的固件发布方案为第一种，示意图如下
_虽然个人认为第三种方案才是较为常见的，但教程中并没有讲到。猜测除了从硬件中提取外，还可以通过模拟器模拟然后进行patch或拿头还原_
###  解密过程
用binwalk分析最新和最早的两个固件
经过binwalk分析，FW104B02正是存在解密程序的中间版本（从文件名也能看出）
> 对于判断固件是否被加密/混淆还可以使用之前提到的binwalk -E 来查看文件各个区域的熵值
提取该固件
    binwalk -eM DIR882A1_FW104B02_Middle_FW_Unencrypt.bin
在最终目录下搜索找到imgdecrypt，从名字看出是下个版本固件的解密例程
可以静态分析程序的解密算法，也可以直接运行程序来对加密固件进行解密。
在本地运行时依旧需要借助qemu-mipsel-static模拟器，使用方法和上一节的模拟过程类似，不表。
利用imgdecrypt还可以还原出ftp服务器上提供的最新的固件，所以可能后续版本和Dlink其它型号的路由器也能用这个程序还原固件？Orz
## 0x5 修复固件运行环境
有一些固件因为硬件依赖等原因导致qemu和firmadyne之类的软件无法正确模拟
比如下面这个
>
>     ftp://ftp2.dlink.com/PRODUCTS/DIR-605L/REVA/DIR-605L_FIRMWARE_1.13.ZIP
>  
> 模拟固件运行的实质其实就是把固件的Web程序跑起来，而模拟失败则说明Web程序运行出错了，我们接下来就要看看Web程序报错的原因以及如何修复运行环境。
###  尝试运行固件
首先binwalk提取固件，进入文件系统目录squashfs-root-0
找到web服务程序Boa
>
> Boa程序是一个轻量级的web服务器程序，常见于嵌入式系统中。dlink就是在boa开源代码的基础上新增了很多功能接口以实现路由器上的不同功能。boa程序的路径为/bin/boa，同时我们发现在/etc/boa路径下还有个boa的密码配置文件，我们可以直接获取到boa加密后的密码。
用qemu-mips-static运行，结果产生了段错误
> mips 是32位大端字节序
>
> mipsel 是32位小端字节序
###  分析错误并修复
> 注：APMIB 是个Realtek的玩意（原来realtek还有做路由器相关的东西…）
>
>   * apmib_init(), 从 flash 读出 mib 值写入 RAM —[Realtek apmib library @ 邱小新の工作笔记
> ](https://jyhshin.pixnet.net/blog/post/47162002)
>
>
> 有些CVE（如CVE-2019-19823）就跟APMIB有关 —[TOTOLINK and other Realtek SDK based
> routers – full takeover
> (sploit.tech)](https://sploit.tech/2019/12/16/Realtek-TOTOLINK.html)
>
> MIB：management information base，与SNMP有关，可在维基里进一步了解：[Management information
> base – Wikipedia](https://en.wikipedia.org/wiki/Management_information_base)
由于没有flash，导致读mib失败
拖到反编译工具中分析。先定位到字符串“Initialize AP MIB
failed!”的位置。注意到在输出这个字符串前有个调用APMIB初始化的跳转，在此下断点，IDA远程调试
QEMU的远程调试不需要gdbserver，-g 指定端口，ida 远程调试选项指定相应端口就行
简单调试后发现，程序进入APMIB初始化函数后将返回值赋给v0，返回后对返回值进行判断。（跟着教程做完后，发现其实用静态分析看的就很明显，但多调试总是没有坏处的嘛）
跳转回去的位置在这：
我们先试试看把原来的跳转patch一下能不能运行正常固件boa。
有以下两个可行方案：
  1. hxd（或其他二进制编辑器），把benz（0x14，不为0跳转）改为beqz（0x10，为0跳转）  
这个方法比较直接，定位到指令后把0x14改为0x10即可
  2. Ghidra，把bne改为beq（Ghidra中反编译出的原指令为bne）
  * **如何用Ghidra进行patch并保存：**
  1. 下载python脚本[ghidra_SavePatch](https://github.com/schlafwandler/ghidra_SavePatch) 并放到Ghidra存放python脚本的目录（找不到目录的话，如图）。
  2. 按照下图导入脚本。
  3. patch
  4. 光标放在更改的指令，在script manager里运行脚本。
参考：[Patching Binaries With Ghidra –
RangeForce](https://materials.rangeforce.com/tutorial/2020/04/12/Patching-Binaries/)
  * **不用ida的原因：**
把patch保存到文件中时，发现报错，稍微搜了一下，依然不知道是啥原因orz
> 418228: has no file mapping (original: 14 patched: 10)…skipping…
再次运行试试，发现又报错了：
再放到Ghidra里分析，依旧通过字符串定位错误触发点。
两个函数（调用的地方位于websAspInit）里的报错由open函数造成（图为create_chklist_file()，但两个报错类似，均为一开始打开某个文件出错）
用IDA调试发现报错后仍然继续运行，异常发生在执行apmib_get()时：
具体在0x4084c9b0时，把[0+v0]里的值赋给v1，而0x1001明显是一个访问不了的地址
查一下apmib_get是干啥的。似乎是用来获取硬件配置信息，但我们要想让固件跑起来可以不需要这个。那么直接把获得apmib_get入口后的跳转语句nop掉
重新尝试运行
固件会一直尝试朝
ioctl（设备驱动的控制接口）发送0x89f0（应该是一个SIOCDEVPRIVATE），我们模拟的固件并不支持，但没啥大影响。（用Google搜一下“Unsupported
ioctl: cmd=0x89f0”可以找到一些蛮有意思的东西2333）
> 关于ioctl：[ioctl()函数详解_shanshanpt的专栏-> CSDN博客](https://blog.csdn.net/shanshanpt/article/details/19897897)
查看报错的页面（用vim看代码舒服一些），嗯，前端的东西：
从文件名可以猜到是个跟路由器界面语言选择有关的文件。
文件不长，注意到有个函数跟语言和硬件有关：
那么我们可以不让它运行到这个页面。
查找调用了*LangSelect.asp的页面，发现只有一个first.asp
直接修改，重新运行完事
> 这个固件成功运行后可以顺便看一看这个洞： [（CVE-2018-20057）D-Link DIR-619L&605L 命令注入漏洞 – Wiki
> ](https://wiki.96.mk/IOT%E5%AE%89%E5%85%A8/D-Link/%EF%BC%88CVE-2018-20057%EF%BC%89D-Link%20DIR-619L%26605L%20%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/)
> ，直接用了后门
这节的错误解决方法均通过修改指令，《路由器0day》书中的方法是伪造.so来劫持函数，也值得一学：[分析固件第一步](https://p1kk.github.io/2020/04/15/%E8%B7%AF%E7%94%B1%E5%99%A8/%E8%B7%AF%E7%94%B1%E5%88%86%E6%9E%90/)
## 结束
纯初学者，如果有啥地方写的不到位或者出错了，还请指出  
以上