Leader ğ¿ğ‘’â€² = ğ¿ğ‘’
Oğ‘’â€² â† ğ»(ğ‘…ğ‘’,
Oğ‘’â€²âˆ’1, . . . , Oğ‘’â€²âˆ’ğ‘¡)
Figure 3: Overview of RandPiper â€“ GRandPiper. In every epoch, a
PVSS sharing of some random value is secret shared. At the same
time, a reconstruction protocol is used to reconstruct the random
value committed by the leader of this epoch, the last time it was a
leader. Oğ‘’â€² is generated using the random value ğ‘…ğ‘’, shared in epoch
ğ‘’, reconstructed in epoch ğ‘’â€² > ğ‘’ + ğ‘¡, and outputs {Oğ‘’â€²âˆ’1, . . . , Oğ‘’â€²âˆ’ğ‘¡ }
from previous epochs by using them as inputs to the random oracle
ğ».
4We can use Merkle trees instead of ğ‘-SDH at the expense of ğ‘‚(log ğ‘›) multiplicative
communication complexity.
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3508We use the SMR protocol (refer Figure 1) described in Section 3
as a building block. At a high-level, consider using the SMR protocol
such that the leader outputs a number chosen uniformly at random
in each epoch. The random beacon output can be a function of
the outputs of the last ğ‘¡ + 1 epochs, allowing for the presence of
at least one honest input (chosen uniformly at random) which is
potentially sufficient to obtain a random output. This argument
holds only if each leader chooses their input in the SMR protocol
independently of other inputs. Otherwise, if a Byzantine leader
can choose an input after knowing the outputs of the previous ğ‘¡
instances then it can bias the output. A separate concern with using
the SMR protocol as is, is that in an epoch with a Byzantine leader,
honest nodes may not all output the same value or output at all.
To fix both of these concerns, we require each node to send a
commitment of a random value more than ğ‘¡ epochs before it will
be reconstructed and used in the beacon protocol. To ensure the
secrecy of this value (for unpredictability and bias-resistance), the
values are shared with the nodes using a publicly verifiable secret
sharing (PVSS) scheme (refer to Appendix B for detailed PVSS
interface). Committing a secretly chosen value ahead of time helps
us solve both of our previous concerns. First, if the same leader is
not chosen twice in any span of ğ‘¡ +1 epochs, it ensures that the ğ‘¡ +1
values that will be used to construct the beacon protocol are chosen
independently of one another. Thus, when nodes reconstruct a
value in an epoch, it corresponds to a value committed more than
ğ‘¡ epochs before. Moreover, the nodes can reconstruct this value
independent of the participation of the leader in this epoch. Second,
waiting for ğ‘¡ + 1 epochs before opening allows for the value to be
committed by the SMR protocol. Thus, all honest nodes will open
the same value in an epoch.
A graphical description of this approach is presented in Figure 3.
In epoch ğ‘’, a leader ğ¿ğ‘’ inputs PVSS shares corresponding to a
random value ğ‘…ğ‘’ to the SMR protocol. Conceptually, when the block
is committed, this value is added to a queue Q(ğ¿ğ‘’) corresponding
to this leader. When the same node is chosen the next time as a
leader, say in epoch ğ‘’â€², the committed shares of ğ‘…ğ‘’ is dequeued
and reconstructed by all honest nodes to obtain ğ‘…ğ‘’. The output Oğ‘’â€²
of epoch ğ‘’â€² can be computed as ğ»(ğ‘…ğ‘’, Oğ‘’â€²âˆ’1, . . . , Oğ‘’â€²âˆ’ğ‘¡). To allow
for unpredictability in leader selection while disallowing repetition
within ğ‘¡ + 1 epochs, the leader for the next epoch ğ‘’â€² + 1 is chosen
based on Oğ‘’â€² and by removing the leaders ğ¿ğ‘’â€², . . . , ğ¿ğ‘’â€²âˆ’ğ‘¡.
A remaining concern is when no values are added to the chain at
epoch ğ‘’. Observe that the reconstruction in epoch ğ‘’ is not affected,
since nodes reconstruct values previously committed. However,
nodes may not have shares in epoch ğ‘’â€² > ğ‘’ + ğ‘¡ where ğ‘’â€² is the first
epoch where ğ¿ğ‘’ is chosen as the leader again. To fix this concern,
we ensure that such a malicious leader who does not commit in
epoch ğ‘’ can be removed by all nodes by ğ‘’ + ğ‘¡  ğ‘¡ nodes will
reconstruct a unique secret.
Setup. We establish PVSS parameters PVSS.pp, and public keys
PVSS.pkğ‘– for every node ğ‘ğ‘– âˆˆ P. We also buffer shares for one
random value for every node ğ‘ğ‘–, i.e., fill Q(ğ‘ğ‘–) for ğ‘ğ‘– âˆˆ P. We
start with epoch ğ‘’ = 1, and use seed random values for ğ‘…ğ‘’ and
{Oğ‘’âˆ’1, . . . , Oğ‘’âˆ’ğ‘¡}. We also assign Lğ¿ğ‘ğ‘ ğ‘¡ â† {ğ‘ğ‘›, . . . , ğ‘ğ‘›âˆ’ğ‘¡} and set
Pğ‘Ÿ â† âˆ… arbitrarily.
Leader selection. The leader for epoch ğ‘’ is chosen based on the
following rule:
Definition 4.1 (Leader selection rule). Let ğ‘’ be the current epoch,
Lğ¿ğ‘ğ‘ ğ‘¡ := {ğ¿ğ‘’âˆ’1, . . . , ğ¿ğ‘’âˆ’ğ‘¡} be the leaders of the last ğ‘¡ epochs, Pğ‘Ÿ be
the set of nodes that are removed (due to misbehavior), and Lğ‘’ =
(P \ Lğ¿ğ‘ğ‘ ğ‘¡) \ Pğ‘Ÿ := {ğ‘™0, . . . , ğ‘™ğ‘¤âˆ’1}, be a set of candidate leaders for
epoch ğ‘’ ordered canonically, with 0  ğ‘¡ shares will reconstruct a unique secret,
which implies that the degree of the polynomial cannot be more
than ğ‘¡. Finally, the block in our SMR protocol consists of the outputs
of the PVSS.ShGen algorithm, i.e., ğ‘â„ := (PVSS.(cid:174)ğ¸, PVSS.ğœ‹) â†
PVSS.ShGen(ğ‘…ğ‘’). An honest nodes acknowledges ğµâ„ if ğ‘â„ meets
the validity condition PVSS.ShVrfy algorithm. Note that despite
the blocks being ğ‘‚(ğœ…ğ‘›) sized, due to our usage of Deliver primitive,
we retain a communication complexity of ğ‘‚(ğœ…ğ‘›2) per epoch.
Commit, reconstruct, and output beacon value. In each epoch,
nodes commit the shares sent by the leader. They also reconstruct
the last sharing sent by the leader at the start of the epoch. Note
that each node can separately maintain the last time a node was
elected as the leader, and thus, be able to appropriately invoke
Dequeue(Q(ğ¿ğ‘’)). Moreover, since a leader does not repeat in any
consecutive ğ‘¡ + 1 epochs, and we ensure that the set of leaders are
consistently known to all honest nodes (as will be shown in the next
subsection), the value being reconstructed is agreed upon by all the
honest nodes. When the nodes reconstruct ğ‘…ğ‘’, they already have
access to {Oğ‘’âˆ’1, . . . , O1}. Hence, they can compute a consistent
output Oğ‘’. Observe that since all nodes enter epoch ğ‘’ within a
delay of Î”, they also output the beacon value within Î” time of each
other.
Remove misbehaving leaders. Finally, at the end of an epoch ğ‘’,
if no block was committed in epoch ğ‘’ âˆ’ ğ‘¡ by ğ¿ğ‘’âˆ’ğ‘¡, ğ¿ğ‘’âˆ’ğ‘¡ is removed
from all future proposals. Since this operation is performed after
ğ‘¡ + 1 epochs, all nodes will perform this action consistently.
Due to space constraints, we analyze security in Appendix B.2.
4.2 RandPiper â€“ BRandPiper Protocol
In this section, we present a random beacon protocol using ğ‘‚(ğœ… ğ‘“ ğ‘›2)
bits of communication complexity where ğ‘“ â‰¤ ğ‘¡ is the actual number
of faults and with 1-absolute unpredictability. Thus, in the optimistic
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3509All nodes ğ‘ğ‘– âˆˆ P running the SMR protocol do the following:
â€¢ Setup. Set ğ‘’ = 1. All nodes agree upon seed random values for ğ‘…ğ‘’ and {Oğ‘’âˆ’1, . . . , Oğ‘’âˆ’ğ‘¡ }. Set Lğ¿ğ‘ğ‘ ğ‘¡ â† {ğ‘ğ‘›, . . . , ğ‘ğ‘›âˆ’ğ‘¡ }, Pğ‘Ÿ â† âˆ…. Run PVSS.Setup and
agree on the public parameters PVSS.pp. Then every node generates a key pair (PVSS.sk, PVSS.pk) â† PVSS.KGen(ğœ…), and all nodes agree on each others
public keys.
â€¢ Leaders. Choose leaders for an epoch ğ‘’ using Definition 4.1 instead of a round-robin order.
â€¢ Blocks. The leader ğ¿ğ‘’ of an epoch ğ‘’, creates a PVSS sharing (PVSS.(cid:174)ğ‘†, PVSS. (cid:174)ğ¸, PVSS.ğœ‹) â† PVSS.ShGen(ğ‘…) of a random value chosen from the input
space of PVSS, and creates a block ğµâ„ with block contents ğ‘â„ as ğ‘â„ := (PVSS. (cid:174)ğ¸, PVSS.ğœ‹) â† PVSS.ShGen(ğ‘…). (We drop the individual shares in PVSS.(cid:174)ğ‘†.)
â€¢ Update. When committing a block ğµâ„ sent by leader ğ¿ğ‘’â€² for some epoch ğ‘’â€², Enqueue(Q(ğ¿ğ‘’â€²), ğ‘â„). At the end of epoch ğ‘’, if no block was committed for
epoch ğ‘’ âˆ’ ğ‘¡ by ğ¿ğ‘’âˆ’ğ‘¡ , then remove ğ¿ğ‘’âˆ’ğ‘¡ from future proposals, i.e., Pğ‘Ÿ â† Pğ‘Ÿ âˆª {ğ¿ğ‘’âˆ’ğ‘¡ } from epoch ğ‘’ + 1.
â€¢ Reconstruct. When the epoch timer epoch-timerğ‘’âˆ’1 for epoch ğ‘’ âˆ’ 1 ends, obtain the (PVSS. (cid:174)ğ¸, PVSS.ğœ‹) corresponding to the committed block in
Dequeue(Q(ğ¿ğ‘’)). Send ğ‘  â† PVSS.Dec(PVSS.sk, PVSS. (cid:174)ğ¸ğ‘–) to all the nodes in the system. On receiving share ğ‘ â€² from another node ğ‘ ğ‘— , ensure that
PVSS.Enc(PVSS.pkğ‘— , ğ‘ â€²) = PVSS. (cid:174)ğ¸ ğ‘— . On receiving ğ‘¡ + 1 valid shares in PVSS.(cid:174)ğ‘†, reconstruct ğ‘…ğ‘’ â† PVSS.Recon(PVSS.(cid:174)ğ‘†).
â€¢ Output. After reconstructing ğ‘…ğ‘’ for epoch ğ‘’, output the beacon value Oğ‘’ by computing Oğ‘’ â† ğ» (ğ‘…ğ‘’, Oğ‘’âˆ’1, . . . , Oğ‘’âˆ’ğ‘¡)
Figure 4: RandPiper â€“ GRandPiper beacon protocol description.
case when ğ‘“ = ğ‘‚(1), our communication complexity is quadratic.
In order to achieve 1-absolute unpredictability, we need to ensure
that we reconstruct inputs from > ğ‘¡ nodes in every epoch. If we
use PVSS schemes, we need to add ğ‘‚(ğ‘¡) shares in every epoch, so
that we can consume > ğ‘¡ combined shares in every round. A PVSS
sharing for one secret is of size ğ‘‚(ğ‘›), and therefore performing
ğ‘‚(ğ‘›ğ‘¡) sharings trivially results in a communication complexity of
ğ‘‚(ğ‘›3). Therefore, we will use VSS schemes (refer to Appendix B for
detailed VSS interface) in an attempt to improve the communication
complexity for a 1-absolute unpredictable random beacon protocol.
Improved VSS. We will first describe an improved VSS (iVSS)
4.2.1
scheme that achieves better communication complexity to share ğ‘›
secrets in the optimistic case which will then be used in our random
beacon protocol.
Efficient VSS (eVSS). eVSS [32] (refer Figure 5) presents the state-
of-the-art VSS scheme for synchronous network setting. The pro-
tocol is described assuming the presence of a bulletin board (or
broadcast channels) [6, 17, 20, 32] where there exists a public bul-
letin board, in which messages posted by any node are available
instantly, and the bulletin board provides a consistent view to all
the nodes. We can realize such message delivery guarantees by
invoking Byzantine Broadcast (BB) protocols.
In this protocol, a dealer ğ¿ creates a commitment VSS.C to a
random polynomial whose constant term is the secret, and posts the
commitment on the bulletin board (Step 1), while privately sending
individual shares VSS.sğ‘— along with witnesses VSS.ğœ‹ ğ‘— to every node
ğ‘ ğ‘— âˆˆ P (Step 2). Nodes post complaints on the bulletin board in the
form of blame message if they do not receive valid shares (Step 3)
in a timely manner. The dealer then opens the secret shares on the
bulletin board corresponding to the nodes that blamed (Step 4). If
there are > ğ‘¡ complaints, the nodes abort (Step 5). Otherwise, the
honest nodes commit their shares (Step 5), with the guarantee that
all honest nodes will be able to reconstruct the shared secret.
Note that ğ‘“ â‰¤ ğ‘¡ Byzantine nodes can always blame regardless
of the dealer being honest or not. This forces an honest dealer to
post ğ‘‚(ğ‘“ ğ‘›) shares on the bulletin board when secret sharing ğ‘‚(ğ‘›)
secrets. In general, the amount of information posted on the bulletin
board is ğ‘‚(ğœ…ğ‘› + ğœ… ğ‘“ + ğœ… ğ‘“ ğ‘›) corresponding to ğ‘‚(ğ‘›) commitments, ğ‘“
blame messages and ğ‘‚(ğ‘“ ğ‘›) opened secret shares. A naÃ¯ve approach
of using BB protocols (extension protocols [36] for larger inputs)
to instantiate the bulletin board involves following steps:
9
(1) Commitment and sharing. Dealer ğ¿ invokes BB to broadcast ğ‘›
commitments Step 1, while privately sharing individual shares
Step 2.
(2) Blame. Nodes invoke ğ‘› parallel instances of BB to broadcast
blame messages Step 3.
(3) Open shares. Dealer ğ¿ invokes an instance of BB with secret
shares corresponding to the blames received.
We note that state-of-the-art honest majority BB protocols, with-
out threshold signatures, incur ğ‘‚(ğœ…ğ‘›3) bits communication cost to
achieve consensus on a single decision [1, 23, 33]. Thus, invoking ğ‘›
parallel instances of BB trivially incurs ğ‘‚(ğœ…ğ‘›4) communication cost.
In addition, running BB on inputs of size ğ‘‚(ğ‘“ ğ‘›) incurs ğ‘‚(ğœ… ğ‘“ ğ‘›3)
without threshold signatures and extension techniques. Thus, the
total communication complexity is ğ‘‚(ğœ…ğ‘›4) bits.
Improved eVSS (iVSS). In order to reduce the large communication
overhead, we first present an improved VSS scheme, that reduces
(i) the number of posts to the bulletin board, and (ii) the amount of
information posted on the bulletin board.
In iVSS (refer Figure 6), the dealer posts commitments on the
bulletin board, privately sends the secret shares and corresponding
witnesses similar to eVSS. However, unlike eVSS, nodes send the
blame messages to all nodes. In addition, nodes forward the received
blame messages to the dealer to request for missing shares. The
dealer privately sends missing shares to the nodes that forwarded
the blame message instead of posting on the bulletin board. If
an honest node receives missing shares for all blame messages it
forwarded, it sends an ack to the dealer. The dealer collects ğ‘¡ + 1
ack messages and posts the ack certificate on the bulletin board.
An honest node commits the proposed commitment if it observes
an ack certificate on the bulletin board.
The honest nodes then forward the missing shares if the dealer
sent the missing shares. A key correctness argument for our scheme
is the following: if an honest node ğ‘ğ‘– âˆˆ P does not receive commit-
ments and secret shares, it must have sent blame messages to all
honest nodes. If some honest node ğ‘ ğ‘— âˆˆ P sends an ack message, it