**SESSION_ID** \- 是一个会话的随机标识符;  
**version** \- TACACS+ 协议的版本;  
**seq_no** \- 会话数据包的增量;  
**key** \- PSK。  
加密的数据如下图所示：
图 3 ：数据包中的加密数据
### No.2 爆破 PSK 绕过 Cisco TACACS+
OK，了解了上面的一些知识后，我们就可以理解后面两种攻击方式了。  
假设现在有一台 Cisco 网络设备和一台 TACACS+ 服务器，我们已经得到了这两台服务器之间传输的 TACACS+
协议的加密数据（可以通过中间人攻击得到）。现在，我们只要得到了 PSK 就可以解密已加密的数据，之后，我们就可以得到一个有效的账户了。  
现在，让我们看看该如何做到这一点。首先，我们可以看到，任何一个 MD5 哈希（尤其是第一个 MD5）都是由几个固定的值组成的。但是，其中只有一个是未知的
—— PSK。所有其它的值（SESSION_ID，version，seq_no），我们都可以从 TACACS+
数据包的报头中获取到。因此，我们可以使用本地离线暴力破解攻击的方式获得 PSK。而我们知道，暴力破解 MD5 是很快的。但在开始爆破前，我们需要得到第一个
MD5 哈希（ **MD5_1** ）。  
我们知道，XOR 是一种可逆性的操作。所以，我们可以这样做
**`data^pseudo_pad = enc_data`**
将其转换为
**`pseudo_pad = data^enc_data`**
**MD5_1** 只是 **pseudo_pad** 的第一部分。“ **pseudo_pad** ” 的大小为 128位（或16字节）。如果我们想得到
**MD5_1** ，我们需要知道 16字节的已加密和已解密的数据即（“ **data**
”）。我们可以从传输的数据包中获得已加密数据。但是，现在我们如何才能得到 16字节 的解密数据呢？  
需要注意的是，身份验证、授权、计费这三种类型的 TACACS +
数据包的请求和响应的格式是不同的。然而，对于这些不同的数据包，我有一个通用的思路，因为，在任何类型的数据包的前 16 个字节中几乎没有未知的或随机的值。  
我不会去深究每种数据包类型中的技术细节。只是举一个例子以说明这个想法。这是 TACACS+
服务器响应的第一个数据包(如下图所示)。它由几个具有单一意义的字段和一条 Cisco 设备发送给用户的问候消息组成。由于我们可以任意连接到 Cisco
设备，所以就可以很轻易的得到响应数据包同时也就知道了所有字段的值。
图 4 : TACACS+ 服务器响应的第一个数据包
因此，从目前来看，我们几乎总是可以知道任何数据包的前 16 字节解密后的数据。所以我们就可以得到 **MD5_1**
，并使用本地离线暴力破解进行攻击。如果爆破成功了，我们就能够解密整个通信的数据。为了简化数据包的接收并解析出 **MD5_1** ，我写了一个小脚本 ——
tac2cat.py。它是 [TacoTaco 项目](https://github.com/GrrrDog/TacoTaco)的一部分。
### No.3 利用中间人攻击 绕过 Cisco TACACS+
对于最后一种攻击方式，我们可以利用中间人攻击篡改 TACACS+ 服务器和 Cisco 设备之间传输的数据。我们的目的是获取到 Cisco 设备的所有权限。  
在重新审查 TACACS+ 协议时，我发现了两个额外的"特点"。  
第一个是在 TACACS+ 协议传输过程中并没有检查数据包的完整性。所以，如果我们利用中间人攻击改变了传输中的加密的部分，那么也就改变了解密的结果
(因为它只进行了 XOR 操作)，但 TACACS+ 服务器并不会发现所做的更改，并以正常的方式处理已经被修改过的传输数据。
图 5 ： TACACS+ 协议数据包
第二个特点是关于 TACACS+ 数据包的格式。在身份验证和授权的过程中，应答的数据包中的第一个字节指示了访问权限授予的结果。  
例如，"0x01"代表了用户通过了服务器的身份验证过程 (授予访问权限) ，"0x02"代表了用户的凭据是无效的。
总之，我们只需要更改服务器应答的数据包的一个字节即可!
  * 获取该字节的 " **pseudo_pad** ": 将加密的字节和解密的字节进行 XOR 操作 (我们知道解密的字节的值，因为如果我们输入不正确的凭据后，服务器会拒绝访问并设置第一个字节为 0x02。
  * 将这个 " **pseudo_pad** " 与成功的身份验证标识 (0x01) 进行 XOR 操作 
  * 将新的字节加入到加密的数据包中并发送给服务器。
因此，利用中间人攻击，我们可以对任何使用无效凭证的用户的传输数据和访问权限授予（身份认证和授权）进行更改。此外，我们也可以绕过 Cisco
设备中特权用户提升（“enable” 密码）的身份验证过程。  
为了方便进行中间人攻击，我写了一个小脚本——tacflip.py，是 [TacoTaco
项目](https://github.com/GrrrDog/TacoTaco)的一部分。
我已经在 Cisco 7200 路由器的 GNS3 模拟器和开源实现的 TACACS+ 服务器——tac_plus
中成功验证了这种（绕过身份验证，特权用户提升授权）攻击方式，下面是路由器中配置文件的一部分：
    aaa authentication login default group tacacs+ local
    aaa authentication enable default group tacacs+
    aaa authorization exec default group tacacs+ local
    tacacs-server host 192.168.182.136
    tacacs-server directed-request
    tacacs-server key 12345
这个小视频演示了在 Cisco 路由上进行绕过身份验证/授权、特权提权和命令执行的攻击过程。
[点我看小视频](https://youtu.be/HdTib8wftHA)
## 0x04 一点儿题外话
在 2000 年，Solar Designer 针对 TACACS+
协议做了一个很有趣的研究（[链接在此](https://goo.gl/E2IGnk)），例如，他发现了重放攻击，用户密码长度信息泄漏，位翻转攻击等漏洞。但我并没有找到
这些漏洞的 PoCs。  
对于我对 TACACS+ 协议所做的"研究"，都是在与协议进行了随机的互动操作后的很长一段时间里的一些想法。正因为如此，我忘了有关 Solar
Designer 研究的结果并且重新了解了他的一些发现。  
因此，可能我工作的最重要的结果就是 [TacoTaco
项目](https://github.com/GrrrDog/TacoTaco)。它是这篇文章所讲述的攻击方式的具体实现。
## 0x05 总结
从目前来看，我认为，TACACS+ 协议并没有针对中间人攻击提供必要的保护级别。  
不过话又说回来，有时很难在实战中执行所有这些攻击操作，因为 Cisco 建议将 TACACS+ 服务器放置在一个特殊的管理方式中 —— VLAN
(只有管理员和网络设备才能访问) 。当然，也有方法可以渗透到 VLAN 中并控制它，不过这就是另一码事儿了。
## 参考及引用