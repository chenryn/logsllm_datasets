### 客户-服务器与缓存
**图5-7：统一-分层-客户-缓存-无状态-服务器风格**

在分层系统中，主要缺点在于增加了数据处理的开销和延迟，从而降低了用户体验到的性能[32]。然而，在支持缓存约束的网络系统中，通过在中间层使用共享缓存可以弥补这一不足。设置在组织边界上的共享缓存能够显著提高性能[136]。此外，这些中间层还允许我们对跨组织边界的数据实施安全策略，例如防火墙所要求的安全措施[79]。

当分层系统约束与统一接口约束结合时，产生的架构属性类似于统一管道和过滤器风格（见3.2.2小节）。尽管REST中的交互是双向的，但超媒体的大粒度数据流可以被视为一个数据流网络，其中包含了一些选择性地应用于数据流的过滤组件，用于在传递过程中转换其内容[26]。在REST架构中，中间组件能够主动修改消息内容，因为这些消息是自描述的，并且其语义对中间组件可见。

### 按需代码
**图5-8：REST风格**

我们为REST添加的最后一项约束来自按需代码风格（参见3.5.3小节）。通过下载并执行以applet或脚本形式存在的代码，REST允许扩展客户端功能。这不仅简化了客户端开发，减少了必须预先实现的功能数量，而且通过允许在部署后下载功能代码来增强系统的可扩展性。不过，这也降低了系统的透明度，因此它只是REST的一个可选约束。

可选约束的概念看似矛盾，但在设计跨越多个组织边界的系统架构时非常有用。这意味着只有当特定领域的整个系统都支持某项约束时，架构才能从中受益或受到影响。例如，如果一个组织内的所有客户端软件都支持Java applets[45]，那么该组织的服务就可以通过下载Java类来增强客户端功能。但是，如果该组织的防火墙阻止外部资源的Java applets传输，则对于Web的其他部分来说，这些客户端可能不支持按需代码。因此，可选约束使我们能够在一般情况下设计出支持预期行为的架构，同时理解这些行为在某些环境中可能不可用。

### REST约束总结
**图5-9：REST继承的风格约束**

REST由一组选定的架构约束组成，旨在赋予候选架构所需的特性。虽然每个约束都可以独立考虑，但从它们在通用架构风格中的来源出发进行描述，有助于更好地理解选择这些约束的基本原理。图5-9根据第3章中探讨的基于网络的架构风格图形化地展示了REST约束的来源。

### REST架构元素

表述性状态转移（REST）风格是对分布式超媒体系统中架构元素的一种抽象。REST忽略了组件实现和协议语法的具体细节，专注于以下几个方面：组件的角色、组件间交互的约束以及对关键数据元素的解释。REST包括了一组定义Web架构基础的组件、连接器和数据的基本约束，代表了基于网络应用行为的本质。

#### 数据元素
在分布式对象风格中，所有数据都被封装在处理组件内，并对外隐藏。而REST的关键方面之一是架构的数据元素性质和状态。这种设计理念源于分布式超媒体的特点。当选定一个链接时，链接指向的信息需要从存储位置移动到使用位置，通常是人类阅读者。这与许多其他分布式处理模型不同，后者通常将“处理代理”（如可移动代码、存储过程等）移动到数据所在的位置，而不是将数据移动到处理器的位置。

分布式超媒体系统的架构师有三种基本选项：
1. 在数据所在地呈现数据，并向接收者发送固定格式的映像。
2. 将数据和呈现引擎一起封装并发送给接收者。
3. 发送原始数据和描述数据类型的元数据，让接收者选择自己的呈现引擎。

每种选项都有其优缺点。第一种选项对应传统的客户-服务器风格，隐藏了与数据真实性质相关的所有信息，简化了客户端实现，但也限制了接收者的功能，并将大部分处理负担放在发送方，导致可伸缩性问题。第二种选项对应于可移动对象风格，提供信息隐藏并通过唯一的呈现引擎支持专门处理，但限制了接收者的功能并可能增加数据传输量。第三种选项允许发送者保持简单性和可伸缩性，最小化传输数据量，但丧失了数据隐藏的优点，要求发送者和接收者都理解相同的数据类型。

通过聚焦于共享带有元数据的数据类型的理解，但限制暴露为标准接口的操作范围，REST提供了上述三种选项的混合体。REST组件通过以一种匹配进化中的标准数据类型之一的数据格式转移资源的表述来进行通信。不同的表述可以根据接收者的能力和期望的内容以及资源的性质动态选择。表述与其原始来源格式相同或由来源衍生但使用不同格式的信息被隐藏在接口之后。通过发送由封装的呈现引擎（如Java[45]）的标准数据格式中的指令组成的表述，可以获得可移动对象风格的好处。REST因此获得了客户-服务器风格分离关注点的好处，没有服务器的可伸缩性问题，支持封装和服务的演变，并可以通过下载功能引擎来提供不同的功能。

REST的数据元素总结如下：

| 数据元素 | 现代Web实例 |
| --- | --- |
| 资源 | 一个超文本引用意图指向的概念目标 |
| 资源标识符 | URL、URN |
| 表述 | HTML文档、JPEG图片 |
| 表述元数据 | 媒体类型、最后修改时间 |
| 资源元数据 | 源链接、alternates、vary |
| 控制数据 | if-modified-since、cache-control |

#### 资源和资源标识符
REST对信息的核心抽象是资源。任何可命名的信息都可以作为资源：文档、图片、时间相关的服务（如“洛杉矶今日天气”）、资源集合、非虚拟对象（如人）等。简而言之，任何可以作为创作者的超文本引用目标的概念都符合资源的定义。资源是到一组实体的概念映射，而不是在任何特定时刻与该映射关联的实体本身。

更精确地说，资源R是一个随时间变化的成员函数M(t)，该函数将时间t映射到等价的实体或值的集合，集合中的值可能是资源的表述和/或资源的标识符。资源可以映射到空集，允许在概念实现之前引用这个概念——这是Web之前的大多数超文本系统较为陌生的概念[61]。一些资源在其创建后的任何时候检查都是相同的值集合，因此是静态的；其他资源的值则会随时间频繁变化。对于资源来说，唯一必须是静态的是映射的语义，因为语义才是区分资源的关键。

例如，“一篇学术论文的创作者首选版本”是一个其值经常变化的映射；相反，“X会议学报中发表的论文”的映射则是静态的。即使某个时刻它们可能会映射到相同的值，它们也是两个截然不同的资源。这种区别是必要的，使得两个资源可以独立标识和引用。类似地，在软件工程领域中，版本控制系统的源代码文件可以单独标识为“最新版本”、“版本号1.2.7”或“包含Orange功能实现的修订版本”。

资源的这种抽象定义实现了Web架构的核心功能。首先，它通过包含多种信息来源而不对其进行类型或实现的人为区分，实现了通用性。其次，它允许对表述的延迟绑定，支持基于请求性质的内容协商。最后，它允许创作者引用概念而不是具体的表述，从而在表述改变时无需修改所有现有链接（假设创作者使用正确的标识符）。