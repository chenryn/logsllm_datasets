$
$ $
ClientConnector: Client+Cache: $ ServerConnector: Server+Cache: $
图5-7：统一-分层-客户-缓存-无状态-服务器风格
分层系统的主要缺点是：增加了数据处理的开销和延迟，因此降低了用户可觉察的性能
[32]。对于一个支持缓存约束的基于网络的系统来说，可以通过在中间层使用共享缓存所获
得的好处来弥补这一缺点。在组织领域的边界设置共享缓存能够获得显著的性能提升
[136]。这些中间层还允许我们对跨组织边界的数据强制执行安全策略，例如防火墙所要求
的那些安全策略[79]。
分层系统约束和统一接口约束相结合，导致了与统一管道和过滤器风格（3.2.2小节）
类似的架构属性。尽管REST的交互是双向的，但是超媒体交互的大粒度的数据流每一个都
能够被当作一个数据流网络来处理，其中包括一些有选择地应用在数据流上的过滤器组件，
以便在数据传递的过程中对它的内容进行转换[26]。在REST 中，中间组件能够主动地转换
消息的内容，因为这些消息是自描述的，并且其语义对于中间组件是可见的。
5.1.7 按需代码
我们为REST添加的最后的约束来自于3.5.3小节中描述的按需代码风格（图5-8）。通
过下载并执行applet形式或脚本形式的代码，REST允许对客户端的功能进行扩展。这样，
通过减少必须被预先实现的功能的数目，简化了客户端的开发。允许在部署之后下载功能代
码也改善了系统的可扩展性。然而，这也降低了可见性，因此它只是REST的一个可选的约
束。
$ $ orb
$
$ $
$
$ $
ClientConnector: Client+Cache: $ ServerConnector: Server+Cache: $
图5-8：REST风格
可选的约束的想法似乎有些矛盾。然而，在设计一个包含多个组织边界的系统的架构时，
第5章 表述性状态转移（REST） 46
它确实是有用的。这意味着只有当已知对于整个系统的某些领域有效的情况下，架构才会从
可选的约束得到好处（或蒙受损失）。例如，如果已知一个组织中的所有客户端软件都支持
Java applet[45]，那么该组织中的服务就能够构造为可以通过下载Java类来增强客户端的功
能，以便从可选的约束得到好处。然而，与此同时，该组织的防火墙可能会阻止转移来自外
部资源的Java applet，因此对于Web的其余部分来说，这些客户端似乎是不支持按需代码的。
一个可选的约束允许我们设计在一般的场合下支持期待的行为的架构，但是我们需要理解，
这些行为可能在某些环境中无法使用。
5.1.8 风格推导小结
REST由一组选择用来在候选架构上导致想要得到的属性的架构约束组成。尽管这些约
束每一个都能够独立加以考虑，但是根据它们在通用的架构风格中的来源来对它们进行描述，
使得我们理解选择它们背后的基本原理更加容易。图5-9根据第3章中调查过的基于网络的
架构风格图形化地描述了REST约束的来源。
layered
progra
replicated
uniforminterface
m
mabl
separated
e
RR CS LS VM U
i
nt
er
on-demand stateless pr oc esm sie ndi mobile s vi im sip bl le
at
e e
g
$ CSS LCS COD
reliable shared extensible reusable
cacheable
scalable multi-
C$SS LC$SS LCODC$SS REST
org.
图5-9：REST所继承的风格约束
5.2 REST架构的元素
表述性状态转移（REST）风格是对分布式超媒体系统中的架构元素的一种抽象。REST
忽略了组件实现和协议语法的细节，以便聚焦于以下几个方面：组件的角色、组件之间的交
互之上的约束、组件对重要数据元素的解释。REST包括了一组对于定义Web架构基础的组
件、连接器和数据的基本约束，因此它代表了基于网络的应用的行为的本质。
5.2.1 数据元素（Data Elements）
在分布式对象风格[31]中，所有的数据都封装在数据的处理组件之中，并且被数据的处
理组件隐藏起来。与分布式对象不同的是，架构的数据元素的性质和状态是REST的一个关
键的方面。这一设计的基本原理能够在分布式超媒体的特性中看到。当选择了一个链接后，
该链接所指向的信息需要从它的存储地移动到它的使用地，后者在大多数情况下是一个人类
阅读者。这与很多其他的分布式处理模型[6,50]不同，在这些模型中，有可能而且通常也是
更高效的做法是将“处理代理”（例如，可移动的代码、存储过程、搜索表达式等等）移动
第5章 表述性状态转移（REST） 47
到数据所在地，而不是将数据移动到其处理器的所在地。
一个分布式超媒体系统的架构师仅拥有三种基本的选项：1）在数据的所在地对数据进
行呈现，并向接收者发送一个固定格式的映象（a fixed-format image）；2）将数据和呈现引
擎封装起来并将两者一起发送给接收者；或者，3）发送原始数据和一些描述数据类型的元
数据，这样接收者就能够选择它们自己的呈现引擎。
每一种选项都有其优点和缺点。第一种选项对应于传统的客户-服务器风格[31]，它使得
与数据的真实性质有关的所有信息都被隐藏在数据发送者之中，防止了其他组件对数据结构
作出假设，并且简化了客户端的实现。然而，它也严重限制了接收者的功能，并且将大部分
处理负担都放在了发送者一边，这导致了可伸缩性的问题。第二种选项对应于可移动对象
（mobile object）风格[50]，它提供了信息的隐藏，同时还可以通过唯一的呈现引擎来支持对
于数据的专门处理。但是，它将接收者的功能限制在了引擎所能预测的范围之内，并且可能
会大幅增加需要转移的数据量。第三种选项允许发送者保持简单性和可伸缩性，同时还使得
需要转移的数据最小化。但是，它丧失了数据隐藏的优点，要求发送者和接收者都必须理解
相同的数据类型。
通过聚焦于共享对于带有元数据的数据类型的理解，但是限制暴露为标准接口的操作的
范围，REST提供的是所有三种选项的一个混合体。REST组件通过以一种数据格式转移资
源的表述来进行通信，该格式与一组进化中的标准数据类型之一相匹配，可以基于接收者的
能力和期待的内容、以及资源的性质来动态地选择不同的表述（译者注：不同的表述，体现
在使用不同数据格式）。表述与其原始来源格式相同，还是由来源衍生但使用不同的格式，
这些信息被隐藏在了接口的背后。可移动对象风格的好处通过以下方式来获得：发送一个表
述，这个表述由一个封装过的呈现引擎（例如：Java[45]）的标准数据格式中的指令组成。
REST因此获得了客户-服务器风格的分离关注点的好处，而不存在服务器的可伸缩性问题，
它允许通过一个通用的接口来隐藏信息，从而支持封装和服务的进化，并且可以通过下载功
能引擎（feature-engine）来提供一组不同的功能。
REST的数据元素总结于表5-1。
表5-1 REST的数据元素
数据元素 现代Web实例
资源 一个超文本引用意图指向的概念上的目标
资源标识符 URL、URN
表述 HTML文档、JPEG图片
表述元数据 媒体类型、最后修改时间
资源元数据 源链接、alternates、vary
控制数据 if-modified-since、cache-control
5.2.1.1 资源和资源标识符（Resources and Resource Identifiers）
REST对于信息的核心抽象是资源。任何能够被命名的信息都能够作为一个资源：一份
文档或一张图片、一个与时间相关的服务（例如，“洛杉矶今日的天气”）、一个其他资源
的集合、一个非虚拟的对象（例如，人）等等。换句话说，任何可能作为一个创作者的超文
本引用的目标的概念都必须符合资源的定义。一个资源是到一组实体的概念上的映射，而不
是在任何特定时刻与该映射相关联的实体本身。
第5章 表述性状态转移（REST） 48
更精确地说，资源R是一个随时间变化的成员函数M (t)，该函数将时间t映射到等价的
R
一个实体或值的集合，集合中的值可能是资源的表述和/或资源的标识符。一个资源可以映
射到空集，这允许在一个概念的任何实现存在之前引用这个概念——这一观念对于Web之
前的大多数超文本系统来说比较陌生[61]。一些资源在它们被创建后的任何时刻来检查，它
们都对应着相同的值的集合，从这个意义上说它们是静态的。其他的资源所对应的值则会随
时间而频繁地变化。对于一个资源来说，唯一必须是静态的是映射的语义，因为语义才是区
别资源的关键。
例如，“一篇学术论文的创作者首选的版本”是一个其值会经常变化的映射；相反，到
“X会议学报中发表的论文”的映射则是静态的。它们是两个截然不同的资源，即使某个时
刻它们可能会映射到相同的值。这种区别是必要的，这样两个资源就能够被独立地标识和引
用。软件工程领域中一个类似的例子是版本控制系统的源代码文件的单独标识，这些标识可
以是：“最新版本”、“版本号1.2.7”，或“包含有Orange功能实现的修订版本”。
对资源的这一抽象的定义使得Web架构的核心功能得以实现。首先，它通过包含了很
多信息来源而没有人为地通过类型或实现对它们加以区分，从而实现了通用性。其次，它允
许引用到表述的延迟绑定（late binding），从而支持基于请求的性质来进行内容协商。最后，
它允许一个创作者引用一个概念而不是引用此概念的某个单独的表述，从而使得当表述改变
时无须修改所有的现有链接（假设创作者使用了正确的标识符）。