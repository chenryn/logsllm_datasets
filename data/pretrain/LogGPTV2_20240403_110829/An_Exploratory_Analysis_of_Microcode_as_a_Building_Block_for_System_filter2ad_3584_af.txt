code injection attacks. In ACM Conference on Computer and Communications
Security (CCS). ACM.
[11] Ben Hawkes. 2013. Notes on Intel Microcode Updates.
[Online]. Available:
http://inertiawar.com/microcode/.
[12] Andrew R Bernat and Barton P Miller. 2011. Anywhere, Any-time Binary Instru-
mentation. In PASTE.
[13] Ferdinand Brasser, Urs Müller, Alexandra Dmitrienko, Kari Kostiainen, Srdjan
Capkun, and Ahmad-Reza Sadeghi. 2017. Software Grand Exposure: SGX Cache
Attacks Are Practical. In USENIX Workshop on Offensive Technologies (WOOT).
[14] Daming D. Chen and Gail-Joon Ahn. 2014. Security Analysis of x86 Processor
Microcode. [Online]. Available: https://www.dcddcc.com/docs/2014_paper_
microcode.pdf.
[15] Xi Chen, Asia Slowinska, Dennis Andriesse, Herbert Bos, and Cristiano Giuffrida.
2015. StackArmor: Comprehensive Protection From Stack-based Memory Error
Vulnerabilities for Binaries. In NDSS.
[16] Clang’s SafeStack [n. d.]. Clang’s SafeStack. http://clang.llvm.org/docs/
SafeStack.html.
[17] Control-Flow Enforcement Technology Preview 2016. Control-Flow Enforcement
Technology Preview. https://software.intel.com/sites/default/files/
managed/4d/2a/control-flow-enforcement-technology-preview.pdf.
[18] Victor Costan and Srinivas Devadas. 2016. Intel SGX Explained. Cryptology
[Online]. Available: http://eprint.iacr.
ePrint Archive, Report 2016/086.
org/2016/086.
[19] Stephen Crane, Christopher Liebchen, Andrei Homescu, Lucas Davi, Per Larsen,
Ahmad-Reza Sadeghi, Stefan Brunthaler, and Michael Franz. 2015. Readactor:
Practical Code Randomization Resilient to Memory Disclosure. In IEEE Sympo-
sium on Security and Privacy.
[20] CVE Details. [n. d.]. CVSS Score Distribution Reports and Trends Over Time. [On-
line]. Available: https://www.cvedetails.com/cvss-score-charts.php.
[21] CVE Details. [n. d.].
[On-
line]. Available: https://www.cvedetails.com/vulnerability-list/opbyp-
1/bypass.html.
input validation statistics.
Insufficient
[22] CVE Details. [n. d.]. Memory corruption statistics.
[Online]. Available:
https://www.cvedetails.com/vulnerability-list/opmemc-1/memory-
corruption.html.
[23] Thurston HY Dang, Petros Maniatis, and David Wagner. 2015. The performance
cost of shadow stacks and stack canaries. In ASIA CCS ’15.
[24] Lucas Davi, Matthias Hanreich, Debayan Paul, Ahmad-Reza Sadeghi, Patrick Koe-
berl, Dean Sullivan, Orlando Arias, and Yier Jin. 2015. HAFIX: Hardware-assisted
flow integrity extension. In Proceedings of the 52nd Annual Design Automation
Conference. ACM, 74.
[25] Lucas Davi, Christopher Liebchen, Ahmad-Reza Sadeghi, Kevin Z Snow, and
Fabian Monrose. 2015. Isomeron: Code Randomization Resilient to (Just-In-Time)
Return-Oriented Programming. In Symposium on Network and Distributed System
Security (NDSS).
[26] Discussion for porting SafeStack to GCC [n. d.]. Discussion for porting SafeStack
to GCC. https://gcc.gnu.org/ml/gcc/2016-04/msg00083.html.
[27] Goran Doychev, Dominik Feld, Boris Köpf, Laurent Mauborgne, and Jan Reineke.
2013. CacheAudit: A Tool for the Static Analysis of Cache Side Channels. In
USENIX Security Symposium.
[28] DynamoRIO contributors. [n. d.]. DynamoRIO Dynamic Instrumentation Tool
Platform. [Online]. Available: http://www.dynamorio.org/.
[29] Isaac Evans, Sam Fingeret, Julian Gonzalez, Ulziibayar Otgonbaatar, Tiffany Tang,
Howard Shrobe, Stelios Sidiroglou-Douskos, Martin Rinard, and Hamed Okhravi.
2015. Missing the Point(er): On the Effectiveness of Code Pointer Integrity. In
S&P.
[30] John G. Favor. 2002. RISC86 INSTRUCTION SET. http://www.google.com/
patents/US6336178 US Patent 6,336,178.
[31] FortiGuard SE Team. 2018. Meltdown/Spectre Update | Fortinet Blog. [Online].
https://blog.fortinet.com/2018/01/30/the-exponential-
Available:
growth-of-detected-malware-targeted-at-meltdown-and-spectre.
[32] Robert Gawlik and Thorsten Holz. 2014. Towards Automated Integrity Protection
of C++ Virtual Function Tables in Binary Programs. In Annual Computer Security
Applications Conference (ACSAC).
[33] Robert Gawlik, Benjamin Kollenda, Philipp Koppe, Behrad Garmany, and
Thorsten Holz. 2016. Enabling Client-Side Crash-Resistance to Overcome Diver-
sification and Information Hiding. In NDSS.
[34] Enes Göktaş, Robert Gawlik, Benjamin Kollenda, E Athanasopoulos, G Portoka-
lidis, C Giuffrida, and H Bos. 2016. Undermining information hiding (and what to
do about it). In 25th USENIX Security Symposium (USENIX Security 16). 105–119.
[35] Ben Gras, Kaveh Razavi, Erik Bosman, Herbert Bos, and Christiano Giuffrida.
2017. ASLR on the Line: Practical Cache Attacks on the MMU. In Symposium on
Network and Distributed System Security (NDSS).
[36] Ilya Grigorik, James Simonsen, and Jatinder Mann. 2017. W3C Recommendation
17 December 2012. https://www.w3.org/TR/2017/CR-hr-time-2-20170803/
#dom-domhighrestimestamp.
[37] Jann Horn. 2018.
Project Zero: Reading privileged memory with a side-
channel. [Online]. Available: https://googleprojectzero.blogspot.co.at/
2018/01/reading-privileged-memory-with-side.html.
[38] Wei Hu, Jason Hiser, Dan Williams, Adrian Filipi, Jack W Davidson, David Evans,
John C Knight, Anh Nguyen-Tuong, and Jonathan Rowanhill. 2006. Secure
and practical defense against code-injection attacks using software dynamic
translation. In International conference on Virtual execution environments. ACM.
[39] Ralf Hund, Carsten Willems, and Thorsten Holz. 2013. Practical timing side
channel attacks against kernel space ASLR. In Security and Privacy (SP), 2013
IEEE Symposium on.
[40] Intel Corporation. 2016. 6th Generation Intel® Processor Family Specification
Update.
[41] Intel Corporation. 2017. Intel Issues Updates to Protect Systems from Security
Exploits. [Online]. Available: https://newsroom.intel.com/news-releases/
intel-issues-updates-protect-systems-security-exploits/.
[42] Intel Corporation. 2017. Microcode Revision Guidance.
[Online]. Avail-
able: https://newsroom.intel.com/wp-content/uploads/sites/11/2018/
01/microcode-update-guidance.pdf.
[43] Intel Corporation. 2018. Intel® 64 and IA-32 Architectures Software Developer’s
Manual. , 2809 pages.
[44] Gaurav S Kc, Angelos D Keromytis, and Vassilis Prevelakis. 2003. Countering
code-injection attacks with instruction-set randomization. In ACM Conference on
Computer and Communications Security (CCS). ACM.
[45] Paul Kocher, Daniel Genkin, Daniel Gruss, Werner Haas, Mike Hamburg, Moritz
Lipp, Stefan Mangard, Thomas Prescher, Michael Schwarz, and Yuval Yarom.
2018. Spectre Attacks: Exploiting Speculative Execution. ArXiv e-prints (2018).
[46] Paul C. Kocher. 1996. Timing Attacks on Implementations of Diffie-Hellman,
RSA, DSS, and Other Systems. In CRYPTO. 104–113.
[47] David Kohlbrenner and Hovav Shacham. 2016. Trusted Browsers for Uncertain
Times.. In USENIX Security Symposium. 463–480.
[48] Benjamin Kollenda, Enes Göktaş, Tim Blazytko, Philipp Koppe, Robert Gawlik,
RK Konoth, Cristiano Giuffrida, Herbert Bos, and Thorsten Holz. 2017. Towards
Automated Discovery of Crash-Resistant Primitives in Binary Executables. In
Dependable Systems and Networks (DSN), 2017 47th Annual IEEE/IFIP International
Conference on. IEEE, 189–200.
[49] Philipp Koppe, Benjamin Kollenda, Marc Fyrbiak, Christian Kison, Robert Gawlik,
Christof Paar, and Thorsten Holz. 2017. Reverse Engineering x86 Processor
Microcode. In USENIX Security Symposium.
[50] Volodymyr Kuznetsov, Laszlo Szekeres, Mathias Payer, George Candea, R Sekar,
and Dawn Song. 2014. Code-Pointer Integrity. In Symposium on Operating Systems
Design and Implementation (OSDI), Vol. 14.
[51] Michael A Laurenzano, Mustafa M Tikir, Laura Carrington, and Allan Snavely.
2010. Pebil: Efficient static binary instrumentation for linux. In International
Symposium on Performance Analysis of Systems & Software.
[52] Sangho Lee, Ming-Wei Shih, Prasun Gera, Taesoo Kim, Hyesoon Kim, and Marcus
Inferring fine-grained control flow inside SGX enclaves with
Peinado. 2017.
branch shadowing. In USENIX Security Symposium. 16–18.
[53] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval Yarom, and Mike Hamburg.
2018. Meltdown. ArXiv e-prints (2018).
[54] Kangjie Lu, Chengyu Song, Byoungyoung Lee, Simon P. Chung, Taesoo Kim, and
Wenke Lee. 2015. ASLR-Guard: Stopping Address Space Leakage for Code Reuse
Attacks. In ACM Conference on Computer and Communications Security (CCS).
[55] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff
Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin:
building customized program analysis tools with dynamic instrumentation. In
Acm sigplan notices.
[56] Kevin J. McGrath and James K. Pickett. 2002. MICROCODE PATCH DEVICE.
http://www.google.com/patents/US6438664 US Patent 6,438,664.
[57] Microprograms. [n. d.]. [Online]. Available: https://github.com/RUB-SysSec/
[58] Nicholas Nethercote and Julian Seward. 2007. Valgrind: a framework for heavy-
weight dynamic binary instrumentation. In ACM Sigplan notices.
Microcode.
[59] Ben Niu and Gang Tan. 2015. Per-input control-flow integrity. In CCS.
[60] Kaan Onarlioglu, Leyla Bilge, Andrea Lanzi, Davide Balzarotti, and Engin Kirda.
2010. G-Free: defeating return-oriented programming through gadget-less bina-
ries. In Annual Computer Security Applications Conference (ACSAC).
[61] Yossef Oren, Vasileios P Kemerlis, Simha Sethumadhavan, and Angelos D
Keromytis. 2015. The spy in the sandbox: Practical cache attacks in javascript and
their implications. In ACM SIGSAC Conference on Computer and Communications
Security.
[62] pakt. 2012. Leaking information with timing attacks on hashtables.
[63] Antonis Papadogiannakis, Laertis Loutsis, Vassilis Papaefstathiou, and Sotiris
Ioannidis. 2013. ASIST: architectural support for instruction set randomization.
In Annual Computer Security Applications Conference (ACSAC). ACM.
[64] Vasilis Pappas, Michalis Polychronakis, and Angelos D Keromytis. 2012. Smash-
ing the gadgets: Hindering return-oriented programming using in-place code
randomization. In IEEE Symposium on Security and Privacy.
[65] PaX Team. 2003. Address Space Layout Randomization (ASLR).
[Online].
Available: pax.grsecurity.net/docs/aslr.txt.
[66] Georgios Portokalidis and Angelos D Keromytis. 2010.
Fast and practical
instruction-set randomization for commodity systems. In Annual Computer Secu-
rity Applications Conference (ACSAC). ACM.
[67] Ted Romer, Geoff Voelker, Dennis Lee, Alec Wolman, Wayne Wong, Hank Levy,
Instrumentation and optimization of
Brian Bershad, and Brad Chen. 1997.
Win32/Intel executables using Etch. In USENIX Windows NT Workshop.
[68] Babak Salamat, Andreas Gal, and Michael Franz. 2008. Reverse stack execution
in a multi-variant execution environment. In IEEE Workshop on Compiler and
Architectural Techniques for Application Reliability and Security (CATARS).
[69] Michael Schwarz, Clémentine Maurice, Daniel Gruss, and Stefan Mangard. 2017.
Fantastic timers and where to find them: high-resolution microarchitectural
attacks in JavaScript. In International Conference on Financial Cryptography and
Data Security.
[70] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry
Vyukov. 2012. AddressSanitizer: A Fast Address Sanity Checker. In USENIX
Annual Technical Conference.
[71] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry
[Online]. Available: https:
Vyukov. 2015. AddressSanitizer In Hardware.
//github.com/google/sanitizers/wiki/AddressSanitizerInHardware.
[72] Kanad Sinha, Vasileios P Kemerlis, and Simha Sethumadhavan. 2017. Reviving
instruction set randomization. In International Symposium on Hardware Oriented
Security and Trust (HOST). IEEE.
[73] Ana Nora Sovarel, David Evans, and Nathanael Paul. 2005. Where’s the FEEB? The
Effectiveness of Instruction Set Randomization.. In USENIX Security Symposium.
[74] William Stallings. 2005. Computer Organization and Architecture: Designing for
Performance (7th Edition). Prentice-Hall, Inc.
[75] Laszlo Szekeres, Mathias Payer, Tao Wei, and Dawn Song. 2013. SoK: Eternal
War in Memory. In IEEE Symposium on Security and Privacy.
[76] Arrigo Triulzi. 2015. Pneumonia, Shardan, Antibiotics and Nasty MOV: a
Dead Hand’s Tale. [Online]. Available: https://www.troopers.de/events/
troopers15/449_pneumonia_shardan_antibiotics_and_nasty_mov_a_
dead_hands_tale/.
[77] Arrigo Triulzi. 2016. The Chimaera Processor. [Online]. Available: https://www.
troopers.de/events/troopers16/655_the_chimaera_processor/.
[78] Victor van der Veen, Dennis Andriesse, Manolis Stamatogiannakis, Xi Chen,
Herbert Bos, and Cristiano Giuffrdia. 2017. The Dynamics of Innocent Flesh
on the Bone: Code Reuse Ten Years Later. In ACM Conference on Computer and
Communications Security (CCS).
[79] Shuai Wang, Pei Wang, and Dinghao Wu. 2015. Reassembleable Disassembling..
In USENIX Security Symposium.
[80] Richard Wartell, Vishwath Mohan, Kevin W Hamlen, and Zhiqiang Lin. 2012.
Binary stirring: Self-randomizing instruction addresses of legacy x86 binary code.
In ACM Conference on Computer and Communications Security (CCS).
[81] David J Wheeler and Roger M Needham. 1994. TEA, a tiny encryption algorithm.
In International Workshop on Fast Software Encryption.
[82] Working Intel CET Bits Now Land In GCC8 2017. Working Intel CET Bits Now
Land In GCC8. https://www.phoronix.com/scan.php?page=news_item&px=
Intel-CET-Working-GCC8.
A APPENDIX
A.1 Hardware Details of the Microcode ROM
Figure 7 shows a SEM image of one of the four Region Of Interests (ROIs). As an extension to previous work by Koppe et al. [49], we
further delayered the chip to analyze the region above the array A2 — the second array from the bottom. Its repetitive structure looked
visually different compared to the other analyzed NOR-ROM arrays. A cross section and an additional delayering process revealed a
prominent structure in the layer underneath, due to which we identified the area as SRAM. Compared to modern Dynamic random-access
memory (DRAM), SRAM uses more space but can be manufactured in the same process as the adjacent NOR-ROM. Additionally, SRAM
does not require periodic refreshes to retain the stored data and is often used in microcontrollers and smaller System on a Chips (SOCs). The
usage of two different storage types in this close proximity is an indication of a highly optimized in-house design process. The common
practice is to use (third-party) Intellectual Property (IP) cores providing a single memory type.
In the ROM, the microcode triads are ordered with an eight line interleaving, meaning that in a linear readout the successor of a triad
is found seven triads ahead. This ordering was verified by searching for all-zero triads at the end of the array A2. After encountering the
first all-zero triad, more were found at the expected seven triad distance. Moreover, the hardware layout already hints at the usage of
this technique. Note that these and other techniques used are not implemented for the sake of obfuscating the ROM contents, but instead
optimize the storage in regards to die area.
Figure 7: SEM image of region R1. The middle part contains the wiring and addressing for the ROM and RAM. To reduce the
average signal path length, the wiring is placed between the two memory areas.
A.2 RTL Representations of Microcode Programs
In the following, we list the RTL form of our custom microcode programs described in the paper. The RTL is the same as used by
Koppe et al. [49] and follows the x86 assembly syntax closely. Where appropriate, the differences to the x86 syntax are highlighted in a
comment. A major difference is the availability of a three operand mode. In that case, the left-most operand is the destination, the remaining
two operands are the sources. More examples can be found in our Github repository [57].
Listing 1: Implementation of our custom rdtsc variant with reduced accuracy. It completely replaces the default by intercept-
ing triad 0x318, the entry point for this instruction on the K8 architecture. The dbg opcode that is used for the read of an
internal register sets certain flags that are not currently supported with standard annotations in the RTL. We omitted the
check of the CR4.TSD control bit, which optionally prevents access to this instruction from usermode. While we were able to
partially reconstruct the check from the ROM readout, we encountered a read error during this and cannot fully and reliably
reconstruct the corresponding semantics. However, this is a limitation of the current state of reverse engineering and we are
working on improving the readout method.
; implement default rdtsc semantics , loading TSC to edx : eax
; emit a fixed bitstring , this instruction reads an internal register
dbg 0001010000101111111000000011111111111111110001101010000000001011
; .q annotation switches to 64 bit operand size
; srl performs a logic shift right
srl.q rdx , t9q , 32
srl.q rax , t9q , 0
; load the and mask
mov t1d , 0 xffff
sll t1d , 16
or t1d , 0 xff00
; sequence word annotation , continue at the next x86 instruction
; the following triad is still executed after this annotation
.sw_complete
; reduce accuracy of the lower 32 bit TSC
; includes two operations as padding
and eax , t1d
add t2d , 0
add t2d , 0
Listing 2: Assembly code of a test case for the ISR. The original x86 assembly code is shown on the left. The right side is the
translation performed by our transpiler. Each source instruction maps to a single replacement instruction. In this case we used
a single instruction, bound, to implement all semantics, but it is also possible to repurpose multiple different x86 instructions.
The correct handler is selected by the lower 16 Bits of the displacement given in brackets. The higher 16 Bits are used as an
optional argument for the selected handler. In the case of memory loads, the argument is the 16 Bit offset of the memory
location to be loaded relative to a fixed base address. The argument to the shift handler is the amount of bits to shift. The
mapping of handler number to semantics is the trivial case in this example: the handler indices are used directly. However,
the full 16 Bits are available to identify handlers. This also allows for using multiple different indices for the same handler,
further strengthening the ISR.
mov esi , [ msg0 ]
mov edi , [ msg1 ]
mov ecx , [ rc ]
add edi , ecx
add esi , edi
mov edi , esi
add esi , esi
shr esi , 8
add esi , edi
bound esi , [ eax + 0 x1 ]
bound edi , [ eax + 0 x40001 ]
bound ecx , [ eax + 0 x180001 ]
bound edi , [ ecx + 0 x4 ]
bound esi , [ edi + 0 x4 ]
bound edi , [ esi + 0 x0 ]
bound esi , [ esi + 0 x4 ]
bound esi , [ eax + 0 x80003 ]
bound esi , [ edi + 0 x4 ]