# References

1. **Code Injection Attacks**. In *ACM Conference on Computer and Communications Security (CCS)*. ACM.

2. **Ben Hawkes**. 2013. *Notes on Intel Microcode Updates*. [Online]. Available: <http://inertiawar.com/microcode/>.

3. **Andrew R Bernat and Barton P Miller**. 2011. *Anywhere, Any-time Binary Instrumentation*. In *PASTE*.

4. **Ferdinand Brasser, Urs Müller, Alexandra Dmitrienko, Kari Kostiainen, Srdjan Capkun, and Ahmad-Reza Sadeghi**. 2017. *Software Grand Exposure: SGX Cache Attacks Are Practical*. In *USENIX Workshop on Offensive Technologies (WOOT)*.

5. **Daming D. Chen and Gail-Joon Ahn**. 2014. *Security Analysis of x86 Processor Microcode*. [Online]. Available: <https://www.dcddcc.com/docs/2014_paper_microcode.pdf>.

6. **Xi Chen, Asia Slowinska, Dennis Andriesse, Herbert Bos, and Cristiano Giuffrida**. 2015. *StackArmor: Comprehensive Protection From Stack-based Memory Error Vulnerabilities for Binaries*. In *NDSS*.

7. **Clang’s SafeStack** [n.d.]. *Clang’s SafeStack*. <http://clang.llvm.org/docs/SafeStack.html>.

8. **Control-Flow Enforcement Technology Preview** 2016. *Control-Flow Enforcement Technology Preview*. <https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf>.

9. **Victor Costan and Srinivas Devadas**. 2016. *Intel SGX Explained*. *Cryptology ePrint Archive*, Report 2016/086. [Online]. Available: <http://eprint.iacr.org/2016/086>.

10. **Stephen Crane, Christopher Liebchen, Andrei Homescu, Lucas Davi, Per Larsen, Ahmad-Reza Sadeghi, Stefan Brunthaler, and Michael Franz**. 2015. *Readactor: Practical Code Randomization Resilient to Memory Disclosure*. In *IEEE Symposium on Security and Privacy*.

11. **CVE Details** [n.d.]. *CVSS Score Distribution Reports and Trends Over Time*. [Online]. Available: <https://www.cvedetails.com/cvss-score-charts.php>.

12. **CVE Details** [n.d.]. *Insufficient Input Validation Statistics*. [Online]. Available: <https://www.cvedetails.com/vulnerability-list/opbyp-1/bypass.html>.

13. **CVE Details** [n.d.]. *Memory Corruption Statistics*. [Online]. Available: <https://www.cvedetails.com/vulnerability-list/opmemc-1/memory-corruption.html>.

14. **Thurston HY Dang, Petros Maniatis, and David Wagner**. 2015. *The Performance Cost of Shadow Stacks and Stack Canaries*. In *ASIA CCS '15*.

15. **Lucas Davi, Matthias Hanreich, Debayan Paul, Ahmad-Reza Sadeghi, Patrick Koeberl, Dean Sullivan, Orlando Arias, and Yier Jin**. 2015. *HAFIX: Hardware-assisted Flow Integrity Extension*. In *Proceedings of the 52nd Annual Design Automation Conference*. ACM, 74.

16. **Lucas Davi, Christopher Liebchen, Ahmad-Reza Sadeghi, Kevin Z Snow, and Fabian Monrose**. 2015. *Isomeron: Code Randomization Resilient to (Just-In-Time) Return-Oriented Programming*. In *Symposium on Network and Distributed System Security (NDSS)*.

17. **Discussion for Porting SafeStack to GCC** [n.d.]. *Discussion for Porting SafeStack to GCC*. <https://gcc.gnu.org/ml/gcc/2016-04/msg00083.html>.

18. **Goran Doychev, Dominik Feld, Boris Köpf, Laurent Mauborgne, and Jan Reineke**. 2013. *CacheAudit: A Tool for the Static Analysis of Cache Side Channels*. In *USENIX Security Symposium*.

19. **DynamoRIO Contributors** [n.d.]. *DynamoRIO Dynamic Instrumentation Tool Platform*. [Online]. Available: <http://www.dynamorio.org/>.

20. **Isaac Evans, Sam Fingeret, Julian Gonzalez, Ulziibayar Otgonbaatar, Tiffany Tang, Howard Shrobe, Stelios Sidiroglou-Douskos, Martin Rinard, and Hamed Okhravi**. 2015. *Missing the Point(er): On the Effectiveness of Code Pointer Integrity*. In *S&P*.

21. **John G. Favor**. 2002. *RISC86 Instruction Set*. <http://www.google.com/patents/US6336178>. US Patent 6,336,178.

22. **FortiGuard SE Team**. 2018. *Meltdown/Spectre Update | Fortinet Blog*. [Online]. Available: <https://blog.fortinet.com/2018/01/30/the-exponential-growth-of-detected-malware-targeted-at-meltdown-and-spectre>.

23. **Robert Gawlik and Thorsten Holz**. 2014. *Towards Automated Integrity Protection of C++ Virtual Function Tables in Binary Programs*. In *Annual Computer Security Applications Conference (ACSAC)*.

24. **Robert Gawlik, Benjamin Kollenda, Philipp Koppe, Behrad Garmany, and Thorsten Holz**. 2016. *Enabling Client-Side Crash-Resistance to Overcome Diversification and Information Hiding*. In *NDSS*.

25. **Enes Göktaş, Robert Gawlik, Benjamin Kollenda, E Athanasopoulos, G Portokalidis, C Giuffrida, and H Bos**. 2016. *Undermining Information Hiding (and What to Do About It)*. In *25th USENIX Security Symposium (USENIX Security 16)*. 105–119.

26. **Ben Gras, Kaveh Razavi, Erik Bosman, Herbert Bos, and Christiano Giuffrida**. 2017. *ASLR on the Line: Practical Cache Attacks on the MMU*. In *Symposium on Network and Distributed System Security (NDSS)*.

27. **Ilya Grigorik, James Simonsen, and Jatinder Mann**. 2017. *W3C Recommendation 17 December 2012*. <https://www.w3.org/TR/2017/CR-hr-time-2-20170803/#dom-domhighrestimestamp>.

28. **Jann Horn**. 2018. *Project Zero: Reading Privileged Memory with a Side-Channel*. [Online]. Available: <https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html>.

29. **Wei Hu, Jason Hiser, Dan Williams, Adrian Filipi, Jack W Davidson, David Evans, John C Knight, Anh Nguyen-Tuong, and Jonathan Rowanhill**. 2006. *Secure and Practical Defense Against Code-Injection Attacks Using Software Dynamic Translation*. In *International Conference on Virtual Execution Environments*. ACM.

30. **Ralf Hund, Carsten Willems, and Thorsten Holz**. 2013. *Practical Timing Side Channel Attacks Against Kernel Space ASLR*. In *Security and Privacy (SP), 2013 IEEE Symposium on*.

31. **Intel Corporation**. 2016. *6th Generation Intel® Processor Family Specification Update*.

32. **Intel Corporation**. 2017. *Intel Issues Updates to Protect Systems from Security Exploits*. [Online]. Available: <https://newsroom.intel.com/news-releases/intel-issues-updates-protect-systems-security-exploits/>.

33. **Intel Corporation**. 2017. *Microcode Revision Guidance*. [Online]. Available: <https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/microcode-update-guidance.pdf>.

34. **Intel Corporation**. 2018. *Intel® 64 and IA-32 Architectures Software Developer’s Manual*. 2809 pages.

35. **Gaurav S Kc, Angelos D Keromytis, and Vassilis Prevelakis**. 2003. *Countering Code- Injection Attacks with Instruction-Set Randomization*. In *ACM Conference on Computer and Communications Security (CCS)*. ACM.

36. **Paul Kocher, Daniel Genkin, Daniel Gruss, Werner Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael Schwarz, and Yuval Yarom**. 2018. *Spectre Attacks: Exploiting Speculative Execution*. ArXiv e-prints (2018).

37. **Paul C. Kocher**. 1996. *Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems*. In *CRYPTO*. 104–113.

38. **David Kohlbrenner and Hovav Shacham**. 2016. *Trusted Browsers for Uncertain Times*. In *USENIX Security Symposium*. 463–480.

39. **Benjamin Kollenda, Enes Göktaş, Tim Blazytko, Philipp Koppe, Robert Gawlik, RK Konoth, Cristiano Giuffrida, Herbert Bos, and Thorsten Holz**. 2017. *Towards Automated Discovery of Crash-Resistant Primitives in Binary Executables*. In *Dependable Systems and Networks (DSN), 2017 47th Annual IEEE/IFIP International Conference on*. IEEE, 189–200.

40. **Philipp Koppe, Benjamin Kollenda, Marc Fyrbiak, Christian Kison, Robert Gawlik, Christof Paar, and Thorsten Holz**. 2017. *Reverse Engineering x86 Processor Microcode*. In *USENIX Security Symposium*.

41. **Volodymyr Kuznetsov, Laszlo Szekeres, Mathias Payer, George Candea, R Sekar, and Dawn Song**. 2014. *Code-Pointer Integrity*. In *Symposium on Operating Systems Design and Implementation (OSDI)*, Vol. 14.

42. **Michael A Laurenzano, Mustafa M Tikir, Laura Carrington, and Allan Snavely**. 2010. *Pebil: Efficient Static Binary Instrumentation for Linux*. In *International Symposium on Performance Analysis of Systems & Software*.

43. **Sangho Lee, Ming-Wei Shih, Prasun Gera, Taesoo Kim, Hyesoon Kim, and Marcus Inferring Fine-Grained Control Flow Inside SGX Enclaves with Branch Shadowing*. 2017. In *USENIX Security Symposium*. 16–18.

44. **Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval Yarom, and Mike Hamburg**. 2018. *Meltdown*. ArXiv e-prints (2018).

45. **Kangjie Lu, Chengyu Song, Byoungyoung Lee, Simon P. Chung, Taesoo Kim, and Wenke Lee**. 2015. *ASLR-Guard: Stopping Address Space Leakage for Code Reuse Attacks*. In *ACM Conference on Computer and Communications Security (CCS)*.

46. **Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood**. 2005. *Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation*. In *ACM SIGPLAN Notices*.

47. **Kevin J. McGrath and James K. Pickett**. 2002. *MICROCODE PATCH DEVICE*. <http://www.google.com/patents/US6438664>. US Patent 6,438,664.

48. **Microprograms** [n.d.]. [Online]. Available: <https://github.com/RUB-SysSec/Microcode>.

49. **Nicholas Nethercote and Julian Seward**. 2007. *Valgrind: A Framework for Heavy-Weight Dynamic Binary Instrumentation*. In *ACM SIGPLAN Notices*.

50. **Ben Niu and Gang Tan**. 2015. *Per-Input Control-Flow Integrity*. In *CCS*.

51. **Kaan Onarlioglu, Leyla Bilge, Andrea Lanzi, Davide Balzarotti, and Engin Kirda**. 2010. *G-Free: Defeating Return-Oriented Programming Through Gadget-less Binaries*. In *Annual Computer Security Applications Conference (ACSAC)*.

52. **Yossef Oren, Vasileios P Kemerlis, Simha Sethumadhavan, and Angelos D Keromytis**. 2015. *The Spy in the Sandbox: Practical Cache Attacks in JavaScript and Their Implications*. In *ACM SIGSAC Conference on Computer and Communications Security*.

53. **pakt**. 2012. *Leaking Information with Timing Attacks on Hashtables*.

54. **Antonis Papadogiannakis, Laertis Loutsis, Vassilis Papaefstathiou, and Sotiris Ioannidis**. 2013. *ASIST: Architectural Support for Instruction Set Randomization*. In *Annual Computer Security Applications Conference (ACSAC)*. ACM.

55. **Vasilis Pappas, Michalis Polychronakis, and Angelos D Keromytis**. 2012. *Smashing the Gadgets: Hindering Return-Oriented Programming Using In-Place Code Randomization*. In *IEEE Symposium on Security and Privacy*.

56. **PaX Team**. 2003. *Address Space Layout Randomization (ASLR)*. [Online]. Available: <pax.grsecurity.net/docs/aslr.txt>.

57. **Georgios Portokalidis and Angelos D Keromytis**. 2010. *Fast and Practical Instruction-Set Randomization for Commodity Systems*. In *Annual Computer Security Applications Conference (ACSAC)*. ACM.

58. **Ted Romer, Geoff Voelker, Dennis Lee, Alec Wolman, Wayne Wong, Hank Levy, Brian Bershad, and Brad Chen**. 1997. *Instrumentation and Optimization of Win32/Intel Executables Using Etch*. In *USENIX Windows NT Workshop*.

59. **Babak Salamat, Andreas Gal, and Michael Franz**. 2008. *Reverse Stack Execution in a Multi-Variant Execution Environment*. In *IEEE Workshop on Compiler and Architectural Techniques for Application Reliability and Security (CATARS)*.

60. **Michael Schwarz, Clémentine Maurice, Daniel Gruss, and Stefan Mangard**. 2017. *Fantastic Timers and Where to Find Them: High-Resolution Microarchitectural Attacks in JavaScript*. In *International Conference on Financial Cryptography and Data Security*.

61. **Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry Vyukov**. 2012. *AddressSanitizer: A Fast Address Sanity Checker*. In *USENIX Annual Technical Conference*.

62. **Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry Vyukov**. 2015. *AddressSanitizer in Hardware*. [Online]. Available: <https://github.com/google/sanitizers/wiki/AddressSanitizerInHardware>.

63. **Kanad Sinha, Vasileios P Kemerlis, and Simha Sethumadhavan**. 2017. *Reviving Instruction Set Randomization*. In *International Symposium on Hardware Oriented Security and Trust (HOST)*. IEEE.

64. **Ana Nora Sovarel, David Evans, and Nathanael Paul**. 2005. *Where’s the FEEB? The Effectiveness of Instruction Set Randomization*. In *USENIX Security Symposium*.

65. **William Stallings**. 2005. *Computer Organization and Architecture: Designing for Performance (7th Edition)*. Prentice-Hall, Inc.

66. **Laszlo Szekeres, Mathias Payer, Tao Wei, and Dawn Song**. 2013. *SoK: Eternal War in Memory*. In *IEEE Symposium on Security and Privacy*.

67. **Arrigo Triulzi**. 2015. *Pneumonia, Shardan, Antibiotics and Nasty MOV: A Dead Hand’s Tale*. [Online]. Available: <https://www.troopers.de/events/troopers15/449_pneumonia_shardan_antibiotics_and_nasty_mov_a_dead_hands_tale/>.

68. **Arrigo Triulzi**. 2016. *The Chimaera Processor*. [Online]. Available: <https://www.troopers.de/events/troopers16/655_the_chimaera_processor/>.

69. **Victor van der Veen, Dennis Andriesse, Manolis Stamatogiannakis, Xi Chen, Herbert Bos, and Cristiano Giuffrida**. 2017. *The Dynamics of Innocent Flesh on the Bone: Code Reuse Ten Years Later*. In *ACM Conference on Computer and Communications Security (CCS)*.

70. **Shuai Wang, Pei Wang, and Dinghao Wu**. 2015. *Reassembleable Disassembling*. In *USENIX Security Symposium*.

71. **Richard Wartell, Vishwath Mohan, Kevin W Hamlen, and Zhiqiang Lin**. 2012. *Binary Stirring: Self-Randomizing Instruction Addresses of Legacy x86 Binary Code*. In *ACM Conference on Computer and Communications Security (CCS)*.

72. **David J Wheeler and Roger M Needham**. 1994. *TEA, a Tiny Encryption Algorithm*. In *International Workshop on Fast Software Encryption*.

73. **Working Intel CET Bits Now Land in GCC8** 2017. *Working Intel CET Bits Now Land in GCC8*. <https://www.phoronix.com/scan.php?page=news_item&px=Intel-CET-Working-GCC8>.

## Appendix

### A.1 Hardware Details of the Microcode ROM

Figure 7 shows a Scanning Electron Microscope (SEM) image of one of the four Regions of Interest (ROIs). As an extension to previous work by Koppe et al. [49], we further delayered the chip to analyze the region above the array A2 — the second array from the bottom. Its repetitive structure looked visually different compared to the other analyzed NOR-ROM arrays. A cross-section and an additional delayering process revealed a prominent structure in the layer underneath, due to which we identified the area as SRAM. Compared to modern Dynamic Random Access Memory (DRAM), SRAM uses more space but can be manufactured in the same process as the adjacent NOR-ROM. Additionally, SRAM does not require periodic refreshes to retain the stored data and is often used in microcontrollers and smaller System on a Chips (SoCs). The usage of two different storage types in this close proximity is an indication of a highly optimized in-house design process. The common practice is to use (third-party) Intellectual Property (IP) cores providing a single memory type.

In the ROM, the microcode triads are ordered with an eight-line interleaving, meaning that in a linear readout, the successor of a triad is found seven triads ahead. This ordering was verified by searching for all-zero triads at the end of the array A2. After encountering the first all-zero triad, more were found at the expected seven-triad distance. Moreover, the hardware layout already hints at the usage of this technique. Note that these and other techniques used are not implemented for the sake of obfuscating the ROM contents, but instead optimize the storage in regards to die area.

**Figure 7: SEM Image of Region R1**
- The middle part contains the wiring and addressing for the ROM and RAM.
- To reduce the average signal path length, the wiring is placed between the two memory areas.

### A.2 RTL Representations of Microcode Programs

In the following, we list the Register-Transfer Level (RTL) form of our custom microcode programs described in the paper. The RTL is the same as used by Koppe et al. [49] and follows the x86 assembly syntax closely. Where appropriate, the differences to the x86 syntax are highlighted in a comment. A major difference is the availability of a three-operand mode. In that case, the left-most operand is the destination, and the remaining two operands are the sources. More examples can be found in our GitHub repository [57].

#### Listing 1: Implementation of Our Custom `rdtsc` Variant with Reduced Accuracy
- It completely replaces the default by intercepting triad 0x318, the entry point for this instruction on the K8 architecture.
- The `dbg` opcode that is used for the read of an internal register sets certain flags that are not currently supported with standard annotations in the RTL. We omitted the check of the CR4.TSD control bit, which optionally prevents access to this instruction from user mode. While we were able to partially reconstruct the check from the ROM readout, we encountered a read error during this and cannot fully and reliably reconstruct the corresponding semantics. However, this is a limitation of the current state of reverse engineering, and we are working on improving the readout method.

```assembly
; implement default rdtsc semantics, loading TSC to edx:eax
; emit a fixed bitstring, this instruction reads an internal register
dbg 0001010000101111111000000011111111111111110001101010000000001011
; .q annotation switches to 64-bit operand size
; srl performs a logical shift right
srl.q rdx, t9q, 32
srl.q rax, t9q, 0
; load the and mask
mov t1d, 0xffff
sll t1d, 16
or t1d, 0xff00
; sequence word annotation, continue at the next x86 instruction
; the following triad is still executed after this annotation
.sw_complete
; reduce accuracy of the lower 32-bit TSC
; includes two operations as padding
and eax, t1d
add t2d, 0
add t2d, 0
```

#### Listing 2: Assembly Code of a Test Case for the ISR
- The original x86 assembly code is shown on the left.
- The right side is the translation performed by our transpiler.
- Each source instruction maps to a single replacement instruction.
- In this case, we used a single instruction, `bound`, to implement all semantics, but it is also possible to repurpose multiple different x86 instructions.
- The correct handler is selected by the lower 16 bits of the displacement given in brackets.
- The higher 16 bits are used as an optional argument for the selected handler.
- In the case of memory loads, the argument is the 16-bit offset of the memory location to be loaded relative to a fixed base address.
- The argument to the shift handler is the amount of bits to shift.
- The mapping of handler number to semantics is the trivial case in this example: the handler indices are used directly.
- However, the full 16 bits are available to identify handlers.
- This also allows for using multiple different indices for the same handler, further strengthening the ISR.

```assembly
; Original x86 assembly code
mov esi, [msg0]
mov edi, [msg1]
mov ecx, [rc]
add edi, ecx
add esi, edi
mov edi, esi
add esi, esi
shr esi, 8
add esi, edi

; Transpiled code
bound esi, [eax + 0x1]
bound edi, [eax + 0x40001]
bound ecx, [eax + 0x180001]
bound edi, [ecx + 0x4]
bound esi, [edi + 0x4]
bound edi, [esi + 0x0]
bound esi, [esi + 0x4]
bound esi, [eax + 0x80003]
bound esi, [edi + 0x4]
```

This optimized version of the references and appendix ensures clarity, coherence, and professionalism.