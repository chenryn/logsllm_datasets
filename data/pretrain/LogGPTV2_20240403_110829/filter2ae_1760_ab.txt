图4-6 智能网关中/sbin/telnetd程序
该程序是指向busybox的软链接，如果把解压缩出的固件内容拿到windows环境后，可能会导致/sbin目录中是空的。我们可以使用串口shell登陆设备，然后运行telnetd程序，但这就意味着每次设备重启之后，我们都要使用shell启动telnetd程序，这样操作很麻烦。
继续翻找，我们在squashfs文件系统中找到initrun.sh脚本，这个脚本是在网关上电启动后进行初始化操作的。如果我们在该脚本中启动telnetd，然后将固件重新打包烧录回去，这样应该就不需要软排线连接设备了，为此我们给initrun.sh增加telnetd命令，如下图：
图4-7 在initrun.sh中启动telnetd程序
接下来，就要考虑如何将固件重新打包，然后刷回至Flash中了。固件解包时，只要binwalk跑一下就完事了，但是重打包就相对麻烦一些。我们刚刚修改了initrun.sh文件，该文件在squashfs文件系统中，所以就需要重新打包squashfs文件系统，但mksquashfs在打包时，有很多细节的参数和配置，这些参数和配置将直接影响到我们重打包的系统是否可以正常运行，而且有些设备只能识别特定版本的mksquashfs打包出来的固件。
为解决squashfs文件系统打包的问题，我们最好参考一下MT7688AN的官方SDK。假设海康萤石的开发者基于该SDK的进行开发的，那么我们也根据SDK中的固件打包方法进行操作，得到的固件应该就是可运行的。首先在官网上下载MT7688
SDK，链接如下：。
在下载到的SDK文件中，我们可以在include文件夹中找到image.mk文件，在该文件中可以找到打包squashfs文件系统时的命令和参数，如下图所示：
图4-8 打包squashfs文件系统的命令和参数
同时，在‘staging_dir\host\bin’目录中可以找到图4-8 中的mksquashfs4程序.
我们尝试用SDK中的mksquashfs4程序和图4-8中的参数打包一下开启了telnetd程序的squashfs文件系统，如下图所示：
图4-9 完成squashfs文件系统打包
上图中，-comp xz是选择xz压缩格式，通过binwalk可以直接查看到原固件中的压缩格式，所以我们也选择该压缩格式。
最后，将打包后的文件系统重新放回固件文件中。我们用了一个颇为简单粗暴的方法，即用UltraEdit直接16进制编辑。4.2节中binwalk分析结果显示从地址0x700000开始的位置是squashfs文件系统的位置，我们只需要将重新打包的squashfs文件覆盖到此处即可。需要注意的是固件文件从地址0x900000起始就是另一个squashfs文件系统了，所以，覆盖完成后需要调整两个文件系统之间的填充字节数量以保证另一个squashfs文件系统的起始偏移仍然是0x900000。至此，我们完成了重打包工作。
重打包完成之后，还需要将打包的固件烧录到Flash中去。烧录和提取是类似的操作，使用编程器就可以完成，操作过程我们就不再赘述了。
# 5． 主要程序分析
按照4.3的方式重打包并烧录固件后，我们应该已经可以通过telnet连接到萤石的网关上了。telnet连上后执行“ps”指令，通过简单的排除法，就可以确定我们要分析主程序是：“/dav/davinci”（达芬奇？达文西？）。接下来我们就对这个程序以及部分它调用的动态库进行分析。
## 5.1 静态分析
我们首先静态看一下davinci文件，通过代码可以看到这个程序是有运行日志的，只是把不重要的日志屏蔽了(debug、verbose等)，只输出了较为严重的日志内容(fatal、error等)。那么我们修改几条指令，使其跳过对日志严重程度的判断，如下图：
图5-1 patch日志输出代码
除了要patch日志输出代码之外，davinci在启动之后，初始化了一个线程操作看门狗，该线程会不断向/dev/watchdog进行写操作。如果一段时间内/dev/watchdog没有收到任何数据，那么整个设备就会重启。由于我们计划调试davinci程序，如果在调试过程中，触发断点导致看门狗线程挂起，那么整个系统就会重启。为此，我们先把该线程patch掉，然后再弄一个写入/dev/watchdog的小脚本，用以专门喂狗防止重启。相关位置的代码截图如下：
图5-2 patch watchdog相关代码
喂狗的小脚本内容如下：
图5-3 喂狗小脚本
相信脚本内容一眼就能够看懂，所以我们不做太多的解释了。此外，还有个guard.sh是用于检测davinci程序是否运行的，但它不影响我们的操作，所以就不讨论该脚本了，有兴趣的读者可以去看看。
完成上述操作之后，就可以把被patch的davinci上传至海康萤石的智能网关，此处我们不再采用烧录固件的方法，因为过于麻烦。通过翻阅该设备的文件系统，可以在设备中发现tftp程序，这是一个使用tftp协议传输文件的程序，可以用它从tftpd服务器上传或下载文件。我们使用从这个链接下载到的tftpd程序：[http://tftpd32.jounin.net/tftpd64_download.html
](http://tftpd32.jounin.net/tftpd64_download.html
"http://tftpd32.jounin.net/tftpd64_download.html
")，运行后，调整tftpd服务器的文件目录和监听网卡。然后在智能网关设备中使用tftp程序获取相关文件即可，相关命令截图如下：
图5-4 使用tftp下载文件
待相关文件传输到萤石网关中之后，就可以运行FeedWatchdog.sh脚本开始喂狗，然后终止原本的davinci进程，接着删除/home/pidfile文件，该文件相当于互斥体，用于控制davinci仅运行了一次，最后启动我们自己的davinci_1进程，相关命令如下：
图5-5 启动patch之后的davinci进程
待程序运行一段时间之后，就可以查看程序的运行日志，然后通过日志分析程序的各种行为。
## 5.2 日志分析
待程序运行一段时间之后，就会在‘/applog/devlog’目录下生成日志文件，每个文件500KB左右，如下图所示：
图5-6 程序运行时生成的日志
用tftp程序将日志取回，然后打开程序日志，在日志中搜索litedev.ys7.com，这个地址是智能网关上电之后第一个访问的地址，我们第二章中介绍过。搜索结果如下图：
图5-7 与litedev.ys7.com有关的日志
上图中，我们可以看到由litedev.ys7.com解析而来的ip地址：115.231.107.14，这与我们用wireshark抓包时得到的结果是相同的。
继续翻看日志，在距离上图不远的地方，可以看到另一条日志，看起来像是与海康萤石MQTT服务器相关的日志内容，截图如下：
图5-8 与MQTT服务器有关的日志
从图中，我们可以看到另一个ip地址：101.71.30.172，该地址同样与我们wireshark抓包的结果吻合。MQTT通信协议是构建于TCP/IP协议之上的一种轻量级通信协议，经常出现在IoT设备系统中设备端与云端的通信过程中。
结合这两条日志内容和wireshark的抓包结果，我们可以进一步确认设备的工作流程：与litedev.ys7.com通信，获取了MQTT服务器的地址；然后与MQTT服务器通信，实现设备的逻辑功能。
在图5-7和图5-8中，我们分别用红框标识了一个关键字符串。在海康萤石智能网关的文件系统中，二进制搜索其中一个字符串“lbs_connect”，确认该字符串出现在libmicrokernel.so.1中。用IDA加载该so文件，可以找到与lbs_connect字符串有关系的函数，查找该函数的交叉引用，可以看到有多处代码调用了此函数，我们随便找一处点开看下，如下图所示：
图5-9 调用lbs_connect函数
可以看到在lbs_connect函数返回成功之后，就会调用send_authentication_i函数。这个函数看起来就是加密和认证相关的函数，接下来我们通过动态调试的方式分析网关加密和认证的流程。
## 5.3 动态调试的准备
对于嵌入式Linux操作系统，我们通常选用gdb和gdbserver作为调试工具。我们可以直接在设备上使用gdb进行本地调试，但gdb程序体积比较大，而且直接在设备上运行gdb会有很多不方便的地方，所以我们选择通过gdbserver进行远程调试。为了完成调试工作，我们首先需要一个可以运行在海康萤石智能网关设备上的gdbserver程序。
在4.3节中，我们使用MT7688
SDK中的工具对固件进行了重打包，所以当我们需要与芯片配套的gdbserver时，也是去MTK官方查阅资料。事实上，MT7688开发板的固件包中确实内置了一个gdbserver，但是当我们提取出这个gdbserver，并通过tftp传输到网关上开始运行后，发现并没有任何输出，可能是MTK官方定制了gdbserver的代码，导致我们无法使用该程序调试。
那么，就只能去找一找有没有其他可以正常运行在海康萤石智能网关中的gdbserver程序了。经过一番搜索后，在rapid7官方github账户上发现了已经编译好的gdbserver程序，链接如下：[https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver ](https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver "https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver ")， 这里我们选择下载芯片对应的mipsle版本的gdbserver。
这里需要说明一下，rapid7提供的gdbserver，可能在某些设备上也无法正常使用，所以最靠谱的方法是使用SDK自己编译一个出来，但是这里既然有可用的，我们就不（懒）再（得）去费功夫了。
我们通过tftp将gdbserver传输到网关中，并使用
gdbserver启动davinci。如果使用附加方式调试，很可能会错过davinci程序与服务器通信的认证过程。所以我们选择使用gdbserver启动程序，这样一来，在远程调试器连接之前，davinci程序将处于挂起状态。命令如下：
图5-10 通过gdbserver启动程序
此时，gdbserver就开始监听23946端口，等待远程调试器的连接。
接下来，我们可以选择gdb或IDA作为远程调试器连接gdbserver。IDA提供图形界面，可以帮助我们理解程序的逻辑；但gdb要更稳定，可以有效避免IDA调试时出现的奇怪错误。我们这里直接选择gdb作为远程调试器，在后续的文章中会有介绍用IDA作为调试器的例子。
由于我们需要调试的是MIPS指令集的程序，而gdb默认情况下，仅支持调试与当前环境采用相同指令集的程序（i386），所以我们需要安装可以调试MIPS指令集的gdb程序。安装方法比较简单，直接输入sudo
apt install gdb-multiarch即可。还可以给gdb程序加一个pwndbg插件，用于辅助我们的调试工作，该插件的官方地址是：
，只需要下载下来，然后运行./setup.sh即可。此插件并非必需品，但是推荐装上。
完成gdb的配置工作之后，就可以使用gdb连接gdbserver开始远程调试了。gdb的调试命令非常多，可以直接搜索到很多整理好的常用命令，在这里，我们就遇见什么指令就解释什么指令吧。运行gdb-multiarch，截图如下：
图5-11 运行gdb-multiarch程序
上图中，我们分别设置architecture为MIPS，读取davinci的符号文件，在main函数设置断点，并连接远程的gdbserver，关键位置已用绿框圈出。然后，我们用快捷键c（continue），让程序开始执行，过一会程序就会在main函数的入口处被断下来。
此时，参考图5-11中的file命令加载libmicrokernel.so.1的符号文件，然后就可以直接使用函数名lbs_connect下断点了，如下图：
图5-12 在lbs_connect函数下断点