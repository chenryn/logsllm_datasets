POINT
> Now we need to talk about ﬂoating point
> Floating Point (Speciﬁcally IEEE 754) is how most 
computer systems represent rational numbers 
such as 12.34
FLOATING 
POINT
> Floating point has some "special" values
+/- Inﬁnity (or INF)
+/- Not-a-Number (or NaN)
FLOATING 
POINT
> These special values usually result from 
undeﬁned mathematical operations
 1.0 / 0.0 =  INF
-1.0 / 0.0 = -INF
 0.0 / 0.0 =  NaN
 sqrt(-1)  =  NaN
FLOATING 
POINT
> NaN in particular has some special properties
> Any aﬃrmative comparison against NaN 
evaluates to false
NaN == 0   // false
NaN >  0   // false
NaN  NaN tends to “propagate”
> Any mathematical operation including NaN 
evaluates to NaN
NaN + 1 = NaN
NaN - 1 = NaN
NaN * 2 = NaN
NaN / 2 = NaN
NaN 
POISONING
> NaN Poisoning is where these properties of NaN 
are used to cause some unintended effect
> For example, take the following code
float num = NaN
if (num > 100.0f || num  NaN poisoning attacks are rare because it is 
typically diﬃcult to introduce NaN into an 
equation
> However, when we call RPCs we can use any 
arguments we want (including NaN or INF)
MOVEMENT 
RPC
> Back to our movement RPC, what happens if our 
timestamp is NaN?
> Timestamp is ﬁrst passed through the function 
UCharacterMovementComponent::IsClientTimeStampValid
if (TimeStamp  By pure luck, all of these conditionals are written 
such that NaN will pass right through
> Since our timestamp was "valid", we generate 
DeltaTime using NaN
float DeltaTime = ClientTimeStamp - CurrentClientTimeStamp;
MOVEMENT 
RPC
> Now the server will attempt to apply our 
movement
> Here we run into our ﬁrst issue
// Perform actual movement
if (DeltaTime > 0.f)
{
    MoveAutonomous(TimeStamp, DeltaTime);
}
MOVEMENT 
RPC
> Our movement doesn't apply since DeltaTime is 
NaN
> But we're not done yet! We've caused 
ServerData->CurrentClientTimeStamp to be NaN
> Now we need to look back at 
UCharacterMovementComponent::IsClientTimeStampValid
if (TimeStamp  DeltaTimeStamp will be NaN regardless of what 
our second TimeStamp is
> On this second RPC call any timestamp >0.0 will 
pass the validity check
> Unfortunately, our DeltaTime will still calculate to 
NaN, so still nothing happens!
> Fortunately, now we've poisoned another value
float ClientError = ClientDelta - ServerDelta;
float NewTimeDiscrepancy = ServerData.TimeDiscrepancy + ClientError;
MOVEMENT 
RPC
> The value NewTimeDiscrepancy is used to detect 
a difference between client time and server time
> If this difference becomes too large, the server 
will start ignoring our movement RPCs
> By poisoning this value we can make it 
impossible for the server to detect that our time 
difference is invalid
if (NewTimeDiscrepancy > MovementTimeDiscrepancyMaxTimeMargin)
{
    // Time discrepancy detected
}
MOVEMENT 
RPC
> Once NewTimeDiscrepancy is NaN, the server 
cannot detect a time discrepancy for any 
timestamp we send
> We can now pull off an old-school speed hack by 
“speeding up time” client side
> This allows us to move signiﬁcantly faster than 
built-in limitations would normally allow
UE4 SPEEDHACK
DEMO #1
RPC FLOAT 
POISONING
> Fixed in UE4.25.2 with commit 
012a7fa095d18d4c4b6c29e9f7bda0904377b667
> This demonstrates a fun type of attack against 
UE4 games - ﬂoat poisoning
> Can also apply to UNET
UNET REMOTE SESSION HIJACKING
BUG #4
UNET SESSION 
AUTHENTICATION
> UNET uses a protocol-level process to 
authenticate packets
> Remember - UNET is over UDP
> Packets are not validated by source IP address, 
only by values within the packet
> Knowing this, it is theoretically possible to hijack 
another player’s session fully remotely
UNET SESSION 
AUTHENTICATION
> There are 3 important values that are used to 
validate an incoming packet:
> Host ID
> Session ID
> Packet ID
HOST ID
> The Host ID is a 16-bit integer that associates a 
packet with a given client
> Host IDs are assigned sequentially starting at 1
> Note that this is per CLIENT. The server player 
does not get a Host ID
> Host IDs are not intended to be a secret
> We can easily enumerate the Host ID of other 
players
SESSION ID
> The Session ID is the primary authenticating 
secret of a connection
> Session ID is randomly generated by the client 
when connecting
> All packets must have the correct Session ID or 
be discarded
SESSION ID
> Session IDs are also 16-bit integers and cannot 
be 0. This means there are only 65535 possible 
Session IDs (1 - 0xFFFF inclusive)
> There is no penalty for guessing a wrong Session 
ID other than the packet being dropped
> We can easily brute force 65535 possible options
SESSION ID
> We can narrow down the search even more
> Session IDs are generated with the function 
UNET::GetRandNotZero
> This function ensures the result is not zero by 
OR’ing the result with 1
> This means a legitimate client will only ever 
generate odd-number Session IDs
> This reduces possible Session IDs to 32768
PACKET ID
> Knowing the Host ID and guessing the Session ID 
means our spoofed packet will be accepted
> There’s one more hiccup though, the Packet ID
> The packet ID is incremented with each packet 
sent by the client (Like a sequence number)
> Again, 16-bits long
PACKET ID
> The packet ID is used to detect duplicate or 
out-of-order packets
> It’s also used to determine the rate of packet loss
> If the last packet ID was 1 and the next packet 
ID is 1000, we assume 998 packets are 
missing
PACKET ID
> We can determine Host ID and guess Session ID, 
what can we do with Packet ID?
> What happens if we send a random Packet ID?
> Let’s read the documentation
PACKET ID
> If new packet ID is greater than last packet ID + 
512 (0x200), disconnect the session
> If packet ID is more than 512 behind current 
packet ID, discard
> If packet ID has been seen recently, discard
> Otherwise, accept and process packet
From https://github.com/Unity-Technologies/UnetEncryptionExample/blob/master/docs/duplication.md
PACKET ID
> If our guessedPacketId > lastPacketId + 512 the 
connection will be disconnected
> This is still useful! We can easily kick other 
players off the server
> However, it’s much more interesting if we can 
bypass this check
PACKET ID
> From the documentation, the odds of us injecting 
a valid packet are low
> guessedPacketId must be lastPacketId +/- 512
> Less than 7% chance of success
> The implementation tells a slightly different story 
however
PACKET ID
> Packet ID validation is done by the function 
UNET::ReplayProtector::IsPacketReplayed
> In practice, this function does not actually 
discard packets that are more than 512 packets 
old
> Instead, old packets are accepted!
PACKET ID
> Unfortunately, we can’t just use a low packet ID to 
always be accepted
> The check accounts for cases where the packet 
ID overﬂows from 0xFFFF to 0
> Instead, the server has a “rolling window” of 
0x7FFF IDs used to determine if a packet is old or 
new
PACKET ID
> Doing the math, we have very close to a 50% 
chance that a packet ID will be accepted
> Most of the rest of the time, we cause the other 
player to get kicked
> Occasionally our packet ID will be a duplicate 
and the injected packet will be discarded
SESSION HIJACKING
DEMO #2
REMEDIATION
> This is considered to be an architectural 
weakness of UNET
> The only mitigation against this encrypting UNET
> Unity provides a reference implementation
> Does not implement key exchange
> I have not found a single game implementing this
FUTURE 
WORK
> I probably haven’t found all the bugs even in the 
components I looked at
> Both protocols have other transport modes 
(Particularly websockets)
> Third party networking plugins (Like Photon, 
Mirror)
> Other engines (GameMaker Studio, Godot, etc)
THANKS
> Epic Games and Unity Technologies security 
teams for putting up with me
> Igor Grinku (https://twitter.com/Grigoreen) for 
the background art
github.com/qwokka/defcon28