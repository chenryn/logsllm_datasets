                 * Decide which operations should be JITed.  
                 */  
                if (jit_expressions)  
                        result->jitFlags |= PGJIT_EXPR;  
                if (jit_tuple_deforming)  
                        result->jitFlags |= PGJIT_DEFORM;  
        }  
```  
### 开发参数  
1、jit_debugging_support (boolean)  
If LLVM has the required functionality, register generated functions with GDB. This makes debugging easier. The default setting is off, and can only be set at server start.  
如果要使用GDB调试JIT动态产生的code，那么需要打开jit_debugging_support  
2、jit_dump_bitcode (boolean)  
Writes the generated LLVM IR out to the filesystem, inside data_directory. This is only useful for working on the internals of the JIT implementation. The default setting is off, and it can only be changed by a superuser.  
是否导出JIT产生的中间代码。会写入$PGDATA目录中。  
3、jit_expressions (boolean)  
Determines whether expressions are JIT compiled, subject to costing decisions (see Section 32.2). The default is on.  
是否对表达式实施jit。默认打开，关闭的话不会对表达式实施JIT.  
4、jit_profiling_support (boolean)  
If LLVM has the required functionality, emit required data to allow perf to profile functions generated by JIT. This writes out files to $HOME/.debug/jit/; the user is responsible for performing cleanup when desired. The default setting is off, and can only be set at server start.  
如果要使用perf来分析JIT代码的profiling，那么需要打开jit_profiling_support这个参数。结果保留在```$HOME/.debug/jit/```，注意自己清理这个目录。  
5、jit_tuple_deforming (boolean)  
Determines whether tuple deforming is JIT compiled, subject to costing decisions (see Section 32.2). The default is on.  
是否对tuple deforming式实施jit。默认打开，关闭的话不会对tuple deforming(即将磁盘中的TUPLE格式转换为内存中的TUPLE格式)实施JIT.  
## JIT code gen有CACHE吗  
暂时没有  
```  
 225 Currently it is not yet possible to cache generated functions, even  
 226 though that'd be desirable from a performance point of view. The  
 227 problem is that the generated functions commonly contain pointers into  
 228 per-execution memory. The expression evaluation machinery needs to  
 229 be redesigned a bit to avoid that. Basically all per-execution memory  
 230 needs to be referenced as an offset to one block of memory stored in  
 231 an ExprState, rather than absolute pointers into memory.  
 232   
 233 Once that is addressed, adding an LRU cache that's keyed by the  
 234 generated LLVM IR will allow to use optimized functions even for  
 235 faster queries.  
 236   
 237 A longer term project is to move expression compilation to the planner  
 238 stage, allowing e.g. to tie compiled expressions to prepared  
 239 statements.  
 240   
 241 An even more advanced approach would be to use JIT with few  
 242 optimizations initially, and build an optimized version in the  
 243 background. But that's even further off.  
 244   
```  
## 目前支持的编译器有哪些  
目前支持LLVM  
```  
  52 PostgreSQL, by default, uses LLVM to perform JIT. LLVM was chosen  
  53 because it is developed by several large corporations and therefore  
  54 unlikely to be discontinued, because it has a license compatible with  
  55 PostgreSQL, and because its IR can be generated from C using the Clang  
  56 compiler.  
 199 It obviously is undesirable to maintain a second implementation of  
 200 commonly used functions, just for inlining purposes. Instead we take  
 201 advantage of the fact that the Clang compiler can emit LLVM IR.  
```  
通过实现jit provider可以扩展更多的编译器支持。  
```  
  59 Shared Library Separation  
  60 -------------------------  
  61   
  62 To avoid the main PostgreSQL binary directly depending on LLVM, which  
  63 would prevent LLVM support being independently installed by OS package  
  64 managers, the LLVM dependent code is located in a shared library that  
  65 is loaded on-demand.  
  66   
  67 An additional benefit of doing so is that it is relatively easy to  
  68 evaluate JIT compilation that does not use LLVM, by changing out the  
  69 shared library used to provide JIT compilation.  
  70   
  71 To achieve this, code intending to perform JIT (e.g. expression evaluation)  
  72 calls an LLVM independent wrapper located in jit.c to do so. If the  
  73 shared library providing JIT support can be loaded (i.e. PostgreSQL was  
  74 compiled with LLVM support and the shared library is installed), the task  
  75 of JIT compiling an expression gets handed off to the shared library. This  
  76 obviously requires that the function in jit.c is allowed to fail in case  
  77 no JIT provider can be loaded.  
  78   
  79 Which shared library is loaded is determined by the jit_provider GUC,  
  80 defaulting to "llvmjit".  
  81   
  82 Cloistering code performing JIT into a shared library unfortunately  
  83 also means that code doing JIT compilation for various parts of code  
  84 has to be located separately from the code doing so without  
  85 JIT. E.g. the JIT version of execExprInterp.c is located in jit/llvm/  
  86 rather than executor/.  
```  
## 内置的类型转换在哪里  
```  
 177 Instead there is one small file (llvmjit_types.c) which references each of  
 178 the types required for JITing. That file is translated to bitcode at  
 179 compile time, and loaded when LLVM is initialized in a backend.  
```  
## 已有的JIT bitcode代码在哪里  
```  
$pkglibdir/bitcode/postgres/  
 211 Similarly extensions can install code into  
 212   $pkglibdir/bitcode/[extension]/  
 213 accompanied by  
 214   $pkglibdir/bitcode/[extension].index.bc  
```  
## 性能对比  
1、建表(65个字段，33个INT8，32个TEXT)  
```  
do language plpgsql $$   
declare  
  sql text;  
begin  
  sql := 'create table test(id int8,';  
  -- 32 个text字段  
  for i in 1..32 loop  
    sql := sql||'c'||i||' text default md5(random()::text),';  
  end loop;  
  -- 32 个int8字段  
  for i in 33..64 loop  
    sql := sql||'c'||i||' int8 default random()*10,';  
  end loop;  
  sql := rtrim(sql, ',');  
  sql := sql||')';  
  execute sql;  
end;  
$$;  
```  
2、写入1亿测试数据  
```  
for((i=1;i/dev/null 2>&1 & done  
```  
空间占用127 GB  
```  
postgres=# \dt+  
                    List of relations  
 Schema | Name | Type  |  Owner   |  Size  | Description   
--------+------+-------+----------+--------+-------------  
 public | test | table | postgres | 127 GB |   
(1 row)  
```  
并行度24强制开关  
```  
set max_parallel_workers_per_gather =24;  
set parallel_setup_cost =0;  
set parallel_tuple_cost =0;  
set min_parallel_table_scan_size =0;  
set min_parallel_index_scan_size =0;  
alter table test set (parallel_workers =24);  
```  
3、多表达式计算测试  
```  
explain select c33,c64,count(*),avg(c33),min(c34),max(c35),stddev(c36),sum(c37),stddev(greatest(c37,c38)),  
        sum(  
  case c38   
  when 0 then c39  
  when 1 then c40  
  when 2 then c41  
  when 3 then c42  
  when 4 then c43  
  when 5 then c44  
  when 6 then c45  
  when 7 then c46  
  when 8 then c47  
  when 9 then c48  
  when 10 then c49  
  when 11 then c50  
  when 12 then c51  
  when 13 then c52  
  when 14 then c53  
  when 15 then c54  
  when 16 then c55  
  else c56  
  end   
)  from test   
where   
c64^2>0   
and sqrt(c64)>0   
and hashtext(c1)>hashtext(c2)  
and   
pow(sqrt(abs(hashint8(case c38   
  when 0 then c39  
  when 1 then c40  
  when 2 then c41  
  when 3 then c42  
  when 4 then c43  
  when 5 then c44  
  when 6 then c45  
  when 7 then c46  
  when 8 then c47  
  when 9 then c48  
  when 10 then c49  
  when 11 then c50  
  when 12 then c51  
  when 13 then c52  
  when 14 then c53  
  when 15 then c54  
  when 16 then c55  
  else c56  
  end))),2) >0  
group by c33,c64;  
                                        QUERY PLAN                                           
-------------------------------------------------------------------------------------------  
 Finalize GroupAggregate  (cost=4545694.04..4549612.47 rows=121 width=200)  
   Group Key: c33, c64  
   ->  Gather Merge  (cost=4545694.04..4549500.85 rows=2904 width=200)  
         Workers Planned: 24  
         ->  Partial GroupAggregate  (cost=4545693.46..4549425.58 rows=121 width=200)  