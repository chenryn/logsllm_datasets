39.2
1.5
P6
49.0
0.4
P7
43.7
1.6
P8
43.8
1.1
P10
32.3
1.8
Avg FPS
Std Dev
TABLE III: Proﬁling Policy Performance. As described in Sec-
tion VI-B1, we calculate the average frame rate of the Arya core
with different active policies, compared to a baseline with no active
policies. Policy identiﬁers in this table match those in Tables I and II.
In our experimental scenes, we load the system by having 500 objects
that each move once per frame, and each tested policy is violated on
every frame. Results are averaged over ﬁve 30-second trials.
Baseline
Avg FPS
StdDev
4.6
1.0
P4
57.7
2.0
Baseline
32.6
1.0
P9
30.7
1.2
Avg FPS
StdDev
TABLE IV: Proﬁling Policy Performance. For two policies, we use
a different experimental setup, with different baseline measurements,
than used in Table III. For P4, which acts on the CreateObject()
API, we create and delete objects every frame rather than moving
them. For P9, we create virtual objects locked to a real-world
billboard. Since the object-locking functionality itself incurs overhead
(independently of policies), we generate a separate baseline. As in
Table III, results are averaged over ﬁve 30-second trials.
Fig. 7: Performance with Multiple Policies and Scaling AR Objects.
We investigate the performance impact of combining multiple policies
and how that impact scales with increasing numbers of AR objects in
the scene. We ﬁnd that the performance overhead of multiple policies
is less than the sum of the overhead from those policies individually,
and that the performance hit of adding AR objects (unrelated to
policies) dominates the impact of policy enforcement.
frame rate of less than 60 FPS.
We designed the scene such that every frame, each virtual
object violates each policy we implemented (see Table II),
though we only activate and evaluate one policy at a time.
Two of our policies required slightly different experimental
setups to trigger violations: P4 requires that
the baseline
setup repeatedly attempt to create objects each frame, and P9
requires the baseline setup to contain objects that are locked
to real-world objects (in this case, billboards). The results for
these two policies are in Table IV, and the caption further
details the speciﬁc experimental setups.
Tables III and IV show the results of these experiments. We
observe a range of performance impacts across our different
policies. For example, P1 (which limits the speed at which
objects can move) and P2 (which makes objects too close to the
user transparent) incur virtually no additional overhead over
the baseline. On the other hand, P10 (which makes virtual
objects that obscure other virtual objects transparent) incurs
an almost 20 FPS hit.
A key observation is that
the complexity of object at-
tributes directly inﬂuences policy performance. For example,
P1 simply sets a threshold on objects’ movement speeds,
which is easily checked and enforced when an application
calls object.Move() with a speed parameter. On the other
hand, P10 incurs more overhead because it must detect virtual
objects that occlude others in every frame, requiring costly
raycasting operations. This lesson suggests that optimizing
attribute computations and intelligently caching information
will be critical for such a scheme to work in practice.
This lesson is further supported by our experience apply-
ing preliminary optimizations to P10. Initially, P10 incurred
signiﬁcant overhead due to redundant raycasting operations
between overlapping objects, resulting in an average frame
rate under 2 FPS. However, by optimizing P10 to not repeat
computation on AR objects that the policy has already acted
upon, we signiﬁcantly improved its performance. This suggests
that pursuing policy optimizations can have a great impact.
Finally, we note that P4, a policy that denies certain
OnCreate() calls, actually improved performance over the
baseline. This is a result of the baseline scene repeatedly
creating and deleting headlocked AR objects, in contrast to P4
simply denying the requests. Thus, we observe that policies
that deny object creation could also be used as a denial-of-
service protection against applications attempting to create
many objects.
Policy Performance Scaling with AR Objects. The above
benchmark provides a single snapshot of how our policies
compare, with a ﬁxed number of virtual objects (500). How-
ever, we also wish to understand (1) how policy performance
scales as the number of active AR objects that violate them
increases, and (2) how performance is affected by multiple
simultaneously running policies.
Using the same experimental setup from Table III, we
compare the baseline scene to several policies, as well as
combinations of policies, as we vary the number of active
AR objects present. We select the policies for this experi-
ment based on the results in Table III, choosing our best
performing policy (P1) and two worst-performing policies
(P3 and P10). Figure 7 shows the results of this experiment.
Note that we cap the maximum FPS at 60 using Unity’s
Application.targetFrameRate feature.
Our results reveal several interesting lessons. First, policy
overhead is not additive. The performance hit incurred by
several policies combined, even those that leverage different
attributes, is less than the sum of their overheads individually.
This ﬁnding is promising, since in practice, multiple policies
may indeed be active at once. Even if the list of policies
332
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:24:47 UTC from IEEE Xplore.  Restrictions apply. 
Avg Msgs/App/Second
Std Dev
1 App
1808
221
2 Apps
1020
115
3 Apps
4 Apps
646
251
508
141
TABLE V: Arya Message Throughput. To inform our choice of
parameters for a full system evaluation (shown in Figure 8), we
ﬁrst characterize the performance of our unoptimized application
communication infrastructure, by which applications use local sockets
to communicate with the Arya core to make API calls. The results
are averaged over ﬁve 30-second trials.
increases, we expect overlapping work between policies. For
example, the cost of loading objects in memory could be
amortized across multiple policies, and multiple policies may
require similar computations about objects.
Second, we observe that the performance impact of addi-
tional virtual objects dominates the impact of policies. That
is, as the number of AR objects increases, the frame rate of
the baseline with no policies drops below 60 FPS, scaling with
the number of objects. Although the frame rate with multiple
active policies drops below 60 FPS more quickly, the impact of
multiple policies scales with number of AR objects similarly
to the baseline, after the initial performance hit of activating
any policies. This is perhaps not surprising: more complex
applications will run more slowly. However, the fact that the
performance impact of policy enforcement does not become
increasingly worse with more AR objects is promising.
2) FULL SYSTEM EVALUATION
Our above experiments isolate the performance impact of
the output policy module and evaluate it with respect
to
varying numbers of AR objects and policies. However, we
also wish to understand the impact of the output policy
module in the face of multiple prototype applications simulta-
neously running on Arya. Since our primary focus was on
the output policy module, other elements of the system —
speciﬁcally, its handling of multiple application threads and
local socket communications — are unoptimized. To isolate the
performance impacts of these unoptimized components, we
ﬁrst conduct a microbenchmark evaluation to proﬁle Arya’s
application communication infrastructure. Using the results of
this microbenchmark, we choose parameters for a meaningful
full system evaluation such that we do not hit bottlenecks due
to communication and accidentally mask the impact of the
output policy module.
Communication Microbenchmark. We ﬁrst measure the
throughput of Arya’s message processing infrastructure. We
connect application processes to Arya over local sockets,
after which the applications saturate the connections with
messages, which Arya then processes as fast as it can. Table V
summarizes the message throughput of Arya with increasing
numbers of concurrently running applications, where one mes-
sage corresponds to one API call. As we increase the number
of applications, the number of messages Arya can process
per application decreases. This result is expected, since each
application runs as a separate process, and communication
between Arya and each app run on separate threads.
Fig. 8: Full System Evaluation. This graph shows the results, in terms
of Arya’s core frame rate, of running 1-4 applications with 7 active
policies, compared to a baseline with no active policies. As described
in Section VI-B2, the total number of objects is ﬁxed at 48, split
evenly across the number of applications in a given trial. Note that
this graph’s y-axis does not start at 0, so that the small differences in
performance are visible. We ﬁnd that under this reasonable workload,
the performance impact of policy enforcement is minimal.
Putting It All Together. Finally, we evaluate our full pro-
totype. We compare the average FPS under workloads with
different numbers of applications communicating over sockets,
and with many active policies. As before, we designed a scene
in which there are multiple virtual objects, each moving once
per frame, and we calculate the average FPS over a 30 second
interval.
We use the results of our socket microbenchmark to de-
termine a realistic workload — i.e., a total number of AR
objects — that will avoid communication bottlenecks. We ﬁx
the total number of AR objects for this experiment at 48,
evenly split across the number of running applications (1-4).
Each application calls the object.Move() API on each of
its objects approximately 30 times per second. We arrive at 48
objects based on the results from Table V: Arya can support
up to about 1800 messages per second, and 48 × 30 < 1800,
and it is evenly divided by 1, 2, 3, and 4 (number of apps
we test). While 48 objects is much less than the 500 we used
in our proﬁling experiments above, those experiments were
speciﬁcally designed to tax Arya, whereas 48 represents a
more reasonable workload for applications. For example, our
case study apps consisted of only a handful of objects each.
Additionally, in practice, apps may not call APIs on each of
their objects continuously, though we do so in our experiments.
We compared this workload, with all seven policies from
Table III active and continuously violated, to the baseline. Our
results are shown in Figure 8. The error bars represent the
standard deviation of 5 trials. The result is promising: we ﬁnd
that under this realistic, 48-object workload, the performance
impact of policy enforcement is negligible over the baseline.
Whereas our earlier proﬁling of the output policy module
highlights bottlenecks (e.g., attributes that are expensive to
compute) under load, our full system evaluation suggests that
even our unoptimized prototype can handle multiple applica-
tions and multiple policies under a realistic workload.
333
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:24:47 UTC from IEEE Xplore.  Restrictions apply. 
VII. DISCUSSION
Designing a full-ﬂedged operating system for AR platforms
that supports strong security, privacy, and safety properties
while enabling rich application functionality is challenging.
Prior work addresses many input privacy challenges for AR,
and in this work, we make signiﬁcant strides towards securely
handling visual output. However, many challenges remain.
We step back and reﬂect on these challenges, and we make
recommendations for designing future secure AR systems.
Handling Noisy Input Sensing. While our prototype used
simulated AR environments to enable controlled output-related
experiments, real AR systems will need to handle potentially
noisy sensor inputs. Input noise may confound output policy
management (e.g., if a recognizer fails to detect a person).
Thus, future work must explore how to mitigate risks from
noisy input — e.g., considering how to deal with ambiguity and
probabilities, and how to determine appropriate defaults. For
example, recognizers may need to output conﬁdence values —
e.g., conﬁdence that there is a person in the video feed — and
the output policy module may need to use conﬁdence values
across multiple frames to make determinations.
Constraint-Solving Policy Framework. By supporting policy
mechanisms that compose by design, Arya avoids challenges
raised by potentially conﬂicting or ﬂip-ﬂopping policies. How-
ever, this design choice excludes some policy mechanisms,
particularly those that move AR objects (since they might
move objects to locations where they violate other policies).
Some systems may wish to support such policies: for example,
automatically repositioning a safety dialog on an AR wind-
shield to ensure that it remains visible but does not obscure
pedestrians. Future work should consider whether it is possible
to design a more complex policy framework that supports
policies that may conﬂict. One approach may be to allow
applications to express AR object attributes as constraints
rather than ﬁxed values (e.g., specifying several acceptable
locations where an AR objects may be displayed), giving
the output policy module the responsibility of solving those
constraints in the face of all active policies. However, such
a system would still need to answer the question of what to
do when a given set of constraints cannot be solved. Prior
work has considered similar constraint-solving approaches for
laying out UIs in more traditional platforms (e.g., tablets or
phones) [12]. Techniques from this work may be applicable
here, though the AR context also raises new challenges (e.g.,
the potential for constant constraint solving due to rapid
changes in the real world).
Application Prioritization. With many applications poten-
tially competing to display output that is subject to a variety of
policies, we argue that Arya could beneﬁt from a prioritization
scheme that favors certain applications over others. While not
the focus of this study, we observe, for example, that a safety-
critical application might receive priority over a game if their
outputs conﬂict or if the user encounters a dangerous situation.
API Extensibility. Arya hides low-level data from untrusted
applications, providing high-level abstractions for applications
to receive input (recognizers [18]) and to display output (AR
objects). While this model effectively restricts the capabilities
of malicious or buggy applications, it may also present ﬂexi-
bility challenges for honest applications (similar to the input
ﬂexibility challenges faced in [18]). A key question is thus
how Arya should expose mechanisms for adding additional
functionality without compromising the security of the system.
While also not
the focus of our study, we observe that
an extensibility model analogous to OS device drivers, with
modules developed by reputable third parties, could facilitate
more ﬂexible options for application developers.
Non-Visual AR Output. Arya focuses on managing visual
output, but as AR systems continue to evolve, we will likely
see increased richness in non-visual output, such as auditory
or haptic. Thus, future work should explore how the design
choices and lessons presented in this paper can be applied to
other types of AR output. We expect that some challenges and
design choices will be similar (e.g., a condition/mechanism-
based policy framework) while others will differ. For example,
beyond blocking certain audio output entirely, are there other,
less strict mechanisms that may be viable (similar to partial
transparency of visual content)?
Low-Level Support for AR Objects. Arya relies on the AR
object abstraction, by which an application’s visual output
consists of multiple non-rectangular regions of pixels, rather
than a single rectangular window. The traditional window
abstraction is deeply embedded in today’s operating systems
and their interactions with graphics and display hardware. In
our prototype, these issues were below the abstraction level
of our implementation, which was built atop the Unity game
engine. However, future work — and certainly non-prototype
AR systems interfacing more directly with hardware — will
need to consider how the AR object abstraction can and/or
should be incorporated into lower-level design choices.
VIII. RELATED WORK