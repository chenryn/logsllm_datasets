80
81
B2
83
84
85
86
8
88
89
90
91
92
93
94
95
96
97
9B
99
通过这个谜题想让大家明白的是，如果把数看成字符串，其实它就是
由各个数位上的数字组成的集合。谜题我们就分析到这里。
接下来回到正题。首先我们生成一张存储了各个数位上数字的表“数
字表”。这张表只有10行，我们只用来读取数据。我们都知道，无论多大
的数，都可以由这张表中的10个数字组合而成。
---
## Page 164
19用 SOL 处理数列 —
151
Digits
digilt数字
这样，我们就可以通过对两个Digits集合求笛卡儿积而得出0～99
的数字。
--求连续编号（1）：求0-99的数
SBLBCT D1.digit + (D2.digit * 10)AS Beq
ORDER BY 8eq;
FROM Digit8 D1 CEOSS JOIN Digits D2
■执行结果
geg
98
99
这段代码中，D1代表个位数字的集合，D2代表十位数字的集合。
在1-2节中，我们已经学习了通过对同一张表进行交叉连接求笛卡儿积的
方法。这里我们再回顾一下，交叉连接可以得到两个集合中元素的“所有
可能的组合”，像下面这样。
---
## Page 165
152—第1章神奇的SQL
■笛卡儿积：得到所有可能的组合
D1
D2
diait
同样地，通过追加D3、D4等集合，不论多少位的数都可以生成。而且，
如果只想生成从1开始，或者到542结束的数，只需在WHERE子句中加入
过滤条件就可以了，
--求连续编号{2）：求1-542的数
SELBcr D1.digit + (D2.digit * 10) + (D3.digit * 100) AS seg
FBOM Diglts D1 CROSS JOIN Digita D2
CROSS JOIN Digita D3
HHERE D1.digit + (D2.digit * 10)
+ (D3.digit + 10o) BETWERN 1 AND 542
ORDER BY seq;
也许大家已经注意到了，这种生成连续编号的方法，完全忽略了数
的“顺序”这一属性。将这个解法和本书多次介绍过的冯·诺依曼型有
注0
序数的定义进行比较，可以很容易发现它们的区别·。冯·诺依曼的方
关于冯·诺依量型道归集合，请
鲁考 1-2 节X及 2-7 节。
法使用递归集合定义自然数，先定义0然后得到1，定义1然后得到2，
是有先后顺序的（因此这种方法适用于解决位次、累计值等与顺序相关
的问题）。
而这里的解法完全丢掉了顺序这一概念，仅把数看成是数字的组合。
这种解法更能体现出SQL语言的特色。
通过将这个查询的结果存储在视图里，就可以在需要连续编号时通过
简单的SELECT来获取需要的编号。
图灵社区会员 非洲铜(PI:EMAIL) 专享 尊重版权
---
## Page 166
1-9用SOL处理数列—153
--生成序列视图（包含0~9991
CREATE VIEN Sequence (seq)
AS SEL&CT D1.digit + (D2.digit * 10) + (D3.digit · 100)
PROM Digit8 D1 CROSS JOIN Digit8 D2
CROSS JOIN Digits D3/
--从序列视图中获取1-100
ORDER BY Beq/
这个视图可以用于多种目的，非常方便，因此事先生成一个后，它就
可以在很多场景发挥作用。
求全部的缺失编号
1-4节介绍了查找连续编号中的缺失编号的方法。当时的解法是，如
果缺失编号有多个，只取其中最小的一个。但是，也许有些人看完那个解
法后不能满足，想要知道如何求出全部的缺失编号吧。
没间题。如果使用前一道例题里的序列视图，很容易就可以满足上面
的要求。因为我们可以任意地生成0～#的自然数集合，所以只需要和比
较的对象表进行差集运算就可以了，通过SQL求差集的方法有很多种。
如果数据库支持EXCEPT，那么我们可以直接使用它。我们还可以使用
NOT EXISTS或NOT IN，甚至外连接的方法。
作为示例，我们假设存在下面这样一张编号有缺失的表。
Seqtbl
q|连续编号）
11
12
---
## Page 167
154—第1章神奇的SQL
因为表中最小的值是1，最大的值是12，所以我们可以根据这个范围
从序列视图中获取数。下面两条SQL语句都会返回缺失的编号3、9、10。
S8L8CT seq
--EXCEPT 版
EICEPT
SELSCT seq FROM SeqTbl;
--NOT IN 版
SELBCT seq
AND Beq NOT IN (SBLBCT Beq FROM SeqTbl) /
■执行结果
seg
10
9
不满足于之前解法的人看到这里的新解法应该可以满足了。
这里补充一些内容。可能像下面这么做性能会有所下降，但是通过扩
展BETWEEN谓词的参数，我们可以动态地指定目标表的最大值和最小值。
代码如下所示。
--动态地指定连续编号范围的SQL语句
SEL&CT Beq
MHERE Beq BETWEEN (SELECT HIN (Beq) PROM SeqTbl)
AND (SELECT MAX [seq) PROM SeqTbl)
EKCEPT
这种写法在查询上限和下限未必固定的表时非常方便。两个自查询没
有相关性，而且只会执行一次。如果在“seq”列上建立索引，那么极值
函数的运行可以变得更快速。
图灵社区会员非洲铜(PI:EMAIL）专享尊重版权
---
## Page 168
19用 SOL 处理数列 —
155
三个人能坐得下吗
和朋友们一起去旅行，预约火车票或机票时，却发现没有能让所有人
挨着坐的空位，于是某个人不得不和大家分开坐一这样不爽的事情可能
不少人都遭遇过吧。接下来我们思考几道与连座相关的例题，
我们假设存在下面这样一张存储了火车座位预订情况的表。
Seats
此座位
status（状态）
已预订
已预订
未预订
未预订
未预订
已预订
未预订
未预订
未预订
10
未预订
11
未预订
12
已预订
13
已预订
14
未预订
15
未预订
我们假设一共3个人一起去旅行，准备预订这列火车的车票。间题是，
从1～15的座位编号中，找出连续3个空位的全部组合。我们把由连续
的整数构成的集合，也就是连续编号的集合称为“序列”。这样序列中就
不能出现缺失编号。
我们希望得到的结果是下面四种。
* 3 - 5
 7 - 9
▪ 8 - 10
+ 9 - 11
图灵社区会员非洲铜(PI:EMAIL）专享尊重版权
---
## Page 169
156—第1章神奇的SOL
（7,8,9,10,11)这个序列中，包含3个子序列(7,8,9)、(8,9,10)、(9,
10,11)，我们也把它们当成不同的序列。还有，通常火车的一排只有几个
座位，所以可能我们表里的座位会分布在几排里，但我们暂时忽略掉这个
问题，假设所有的座位排成了一条直线。
■7=11的序列包含3个子序列
借助上面的图表我们可以知道，需要满足的条件是，以n为起点、
n+(3-1)为终点的座位全部都是未预订状态（请注意如果不减1，会多取
一个座位）。我们的解法如下所示。
--找出需要的空位（1）：不考虑座位的换排
SELBCT S1.seat  AS start_sest,  , S2-seat AS end_seat
FROM Seats S1, Seats S2
MHERE S2.Beat - S1.seat ▪1head_cnt-1)--决定起点和终点
AND NOT EXISTS
SELECT *
FROM Seats S3
MHERE S3-Beat BEIWEEN S1.seat AND S2.seat
ANDS3.BtatuB<>未预订+
其中，”：head_cnt”是表示需要的空位个数的参数。通过往这个参
数里赋具体值，可以应对任意多个人的预约。
这条查询语句充分体现了SQL在处理有序集合时的原理，这里详细
地解说一下，对于这个查询的要点，我们分成两个步骤来理解更容易一些。
第一步：通过自连接生成起点和终点的组合
就这条 SQL语句而言，具体指的是 s2.seat-S1.seat +（：head
cnt-1）的部分。这个条件排除掉了像1～8、2～3这样长度不是3的组合，
从而保证结果中出现的只有从起点到终点刚好包含3个空位的序列。
第二步：描述起点到终点之间所有的点需要满足的条件
决定了起点和终点以后，我们需要描述一下内部各个点需要满足的条
件。为此，我们增加一个在起点和终点之间移动的所有点的集合（即以上
---
## Page 170
19用 SOL 处理数列 —
—157
SQL中的 S3）。限定移动范围时使用 BETWEEN谓词很方便。
在本例中，序列内的点需要满足的条件“所有座位的状态都是‘未
预订'”
这种形式的条件我们在前面已经见过了，这是谓词逻辑里的一种被称
为全称量化的命题。但是，我们在SQL中不能直接表达这个条件。在
SQL中遇到需要全称量化的问题时，一般的思路都是把“所有行都满足条
件P”转换成它的双重否定—不存在不满足条件P的行。
因此，子查询里的条件也不是“s3.status-‘未预订'”，而是它的
否定形式“s3.status<>‘未预订""
接下来我们看一下这道例题的升级版，即发生换排的情况。假设这列
火车每一排有5个座位。我们在表中加上表示行编号“row_id”列。
Seats2
塑[座位】
row_idf 行跨号ID)stalus(状态]
A
已预定
2
A
已预定
A
未预定
A
未预定
b
A
未预定
6
B
已预定
B
已预定
B
未预定
9
B
未预定
10
B
未预定
11
C
未预定
12
C
未预定
13
C
未预定
14
C
已预定
15
C
未预定
这种情况的话，即使不考虑换排，属于连续编号的序列(9,10,11)也
不符合条件，这是因为，坐在11号座位的人其实已经是自己一个人坐在
另一排了。
---
## Page 171
158—
第1章种奇的 SQL
因为爱生换排，所以9-11的序列不特合条件
A行:
B6：(
88000
要想解决换排的间题，除了要求序列内的所有座位全部都是空位，还
需要加入“全部都在一排”这样一个条件。稍微修改一下就可以实现，请