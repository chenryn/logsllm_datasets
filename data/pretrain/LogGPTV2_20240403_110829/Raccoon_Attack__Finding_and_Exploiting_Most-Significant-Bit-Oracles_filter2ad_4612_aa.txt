title:Raccoon Attack: Finding and Exploiting Most-Significant-Bit-Oracles
in TLS-DH(E)
author:Robert Merget and
Marcus Brinkmann and
Nimrod Aviram and
Juraj Somorovsky and
Johannes Mittmann and
J&quot;org Schwenk
Raccoon Attack: Finding and Exploiting 
Most-Significant-Bit-Oracles in TLS-DH(E)
Robert Merget and Marcus Brinkmann, Ruhr University Bochum; 
Nimrod Aviram, School of Computer Science, Tel Aviv University; 
Juraj Somorovsky, Paderborn University; Johannes Mittmann, 
Bundesamt für Sicherheit in der Informationstechnik (BSI), Germany; 
Jörg Schwenk, Ruhr University Bochum
https://www.usenix.org/conference/usenixsecurity21/presentation/merget
This paper is included in the Proceedings of the 30th USENIX Security Symposium.August 11–13, 2021978-1-939133-24-3Open access to the Proceedings of the 30th USENIX Security Symposium is sponsored by USENIX.Raccoon Attack: Finding and Exploiting Most-Signiﬁcant-Bit-Oracles in
TLS-DH(E)
Robert Merget1, Marcus Brinkmann1, Nimrod Aviram2, Juraj Somorovsky3, Johannes Mittmann4, and Jörg
Schwenk1
1Ruhr University Bochum
2School of Computer Science, Tel Aviv University
4Bundesamt für Sicherheit in der Informationstechnik (BSI), Germany
3Paderborn University
Abstract
Difﬁe-Hellman key exchange (DHKE) is a widely adopted
method for exchanging cryptographic key material in real-
world protocols like TLS-DH(E). Past attacks on TLS-DH(E)
focused on weak parameter choices or missing parameter
validation. The conﬁdentiality of the computed DH share, the
premaster secret, was never questioned; DHKE is used as a
generic method to avoid the security pitfalls of TLS-RSA.
We show that due to a subtle issue in the key derivation
of all TLS-DH(E) cipher suites in versions up to TLS 1.2,
the premaster secret of a TLS-DH(E) session may, under
certain circumstances, be leaked to an adversary. Our main
result is a novel side-channel attack, named Raccoon attack,
which exploits a timing vulnerability in TLS-DH(E), leaking
the most signiﬁcant bits of the shared Difﬁe-Hellman secret.
The root cause for this side channel is that the TLS standard
encourages non-constant-time processing of the DH secret.
If the server reuses ephemeral keys, this side channel may
allow an attacker to recover the premaster secret by solving an
instance of the Hidden Number Problem. The Raccoon attack
takes advantage of uncommon DH modulus sizes, which
depend on the properties of the used hash functions. We
describe a fully feasible remote attack against an otherwise-
secure TLS conﬁguration: OpenSSL with a 1032-bit DH
modulus. Fortunately, such moduli are not commonly used
on the Internet.
Furthermore, with our large-scale scans we have identiﬁed
implementation-level issues in production-grade TLS imple-
mentations that allow for executing the same attack by directly
observing the contents of server responses, without resorting
to timing measurements.
1 Introduction
Difﬁe-Hellman Key Exchange. In Difﬁe-Hellman (DH) Key
Exchange, a client A and a server B both use a prime p and a
generator g ∈ Z∗
p as public parameters, where g generates a
cyclic subgroup G ≤ Z∗
p of prime order q. B chooses a secret
b ∈ Zq and A chooses a secret a ∈ Zq. B sends the DH “share”
Figure 1: Raccoon attack overview. The attacker passively
observes the public DH shares of a client-server connection
and uses an oracle in the TLS key derivation to calculate
the shared DH secret using a solver for the Hidden Number
Problem.
gb mod p to A, while A sends its share ga mod p to B. Both
parties can then compute (ga)b = (gb)a = gab mod p. If the
parameters p and q are chosen in such a way that the Com-
putational Difﬁe-Hellman Assumption (CDH) holds for G, a
third party that observes the transmitted values ga,gb mod p
cannot compute this shared secret gab.
TLS-DH(E). Transport Layer Security (TLS) relies on the
DH assumption and adapts the DH key exchange to compute
a shared key (ga)b between a client and a server. The shared
key is used as a premaster secret to derive all necessary cryp-
tographic material for the established connection. In practice,
TLS peers can use two DH key exchange types: TLS-DH and
TLS-DHE. In a TLS-DH connection, the server uses a static
value b. In TLS-DHE, the server uses an ephemeral value b.
Side-channel attacks against TLS. Due to its importance,
the TLS protocol was subject to many cryptographic analyses,
including the security of the TLS handshake structure [14]
and TLS-DHE [35]. These analyses conﬁrm the security of
the design of TLS, which is essential for its implementation
and deployment. However, models used in these studies rely
on speciﬁc assumptions and implementation correctness. For
USENIX Association
30th USENIX Security Symposium    213
example, they assume that the secret-processing functions
work in constant time and do not leak any conﬁdential data.
Such behavior is not always given in practice and can be prac-
tically exploited by an attacker using speciﬁc side channels.
A typical example of side-channel attacks are timing at-
tacks. In timing attacks, an attacker measures the response
time of an implementation to recover secret information.
There are numerous examples of timing side-channel attacks
that have been successfully applied to TLS. Brumley and
Boneh [20] showed how to recover the private key of a TLS-
RSA server by measuring timing differences in arithmetic
optimizations for different ciphertext lengths. AlFardan and
Paterson [6] were able to recover plaintext bytes from the
TLS Record Layer by observing subtle timing differences in
the computation of the HMAC. Meyer et al. [46] constructed
a Bleichenbacher oracle from timing differences in the han-
dling of valid and invalid PKCS#1 encoded premaster secrets
within the ClientKeyExchange message.
The standard strategy for preventing timing attacks is to
make implementations constant time, i.e., the implementa-
tion’s processing time should always be the same, regardless
of any conditions on the secret. Deploying such a countermea-
sure can be very challenging, especially if the side channel
results from the behavior described in the protocol speciﬁ-
cation. For example, the Lucky 13 attack by AlFardan and
Paterson resulted from the failure in the TLS speciﬁcation to
process ciphertext in constant time [6]. While the paper de-
scribes concrete countermeasure strategies, we could observe
several resurrections of this attack in recent years [4, 8, 57].
A timing oracle in the TLS-DH(E) KDF. We start our study
with the critical observation that the TLS speciﬁcation pre-
scribes variable-length secrets as input to the key derivation
function (KDF); all TLS versions up to version 1.2 mandate
that the DH premaster secret must be stripped of leading zero
bytes before it is used to derive connection secrets. Since
the ﬁrst step of the KDF is to apply a hash function to the
secret, this hash calculation will use less internal iterations
if a critical number of leading zeros has been stripped. For
example, for SHA-384 (cf. Table 1), the internal block size
is 128 bytes. Due to the structure of the length and padding
ﬁelds used in SHA-384, the last hash input block can contain
up to 111 bytes. Therefore, inputs with up to 239=128+111
bytes will be processed in two blocks. For inputs with 240
bytes and more, at least three hash blocks are necessary.
Processing an additional hash block results in an additional
hash compression computation. Therefore, for some DH
modulus sizes, the KDF is faster for premaster secrets with
leading zero bytes, since these zero bytes will be stripped. If
an attacker can use precise timing measurements to learn the
number of hash compressions performed on the premaster
secret, the attacker is also able to learn some leading bits of
the premaster secret. This behavior allows the attacker to
create a most signiﬁcant bits (MSBs) oracle from a server
and to determine the MSBs of the DH secret.
The Hidden Number Problem. In 1996, Boneh and Venkate-
san presented the Hidden Number Problem (HNP) [17], orig-
inally to show that using the most signiﬁcant bits (MSB) of
a Difﬁe-Hellman secret is as secure as using the full secret.
Their proof includes an algorithm that, given an oracle for
the MSBs of DH shared secrets where one side of the key
exchange is ﬁxed, computes the entire secret for another such
key exchange. The algorithm presented in that seminal work
uses basis reduction in lattices to efﬁciently solve the Closest
Vector Problem. While initially presented as part of a positive
security result, the HNP and its solutions later were also used
as components in cryptographic attacks. For example, such
algorithms have been used to break DSA, ECDSA, and qDSA
with biased or partially known nonces [9,11,18,23,48–50,62].
Perhaps surprisingly, the original target of the HNP, Difﬁe-
Hellman key exchange, remained unattacked until now. We
close this gap by presenting the ﬁrst full HNP-based attack on
Difﬁe-Hellman key exchange as implemented in TLS-DH(E).
Raccoon attack. The Raccoon attack can recover TLS-
DH(E) premaster secrets from passively-observed TLS-
DH(E) sessions by exploiting a side channel in the server
and solving the Hidden Number Problem using lattice reduc-
tion algorithms. The attack requires that the server reuses the
same Difﬁe-Hellman share across sessions, which is the case
for a server with static TLS-DH or a server reusing ephemeral
keys in TLS-DHE [61].
On a high level, the attack works as follows (cf. Figure 1):
1. The attacker records the TLS handshake, including both
the client DH share ga and the server share gb.
2. The attacker initiates new handshakes to the same server
(therefore with the same gb), using gri · ga for some ran-
domly chosen ri. The premaster secret for these new
sessions is (gri · ga)b = grib · gab. The attacker can com-
pute the ﬁrst term, and the second term is the targeted
DH secret.
3. For each handshake, the attacker measures the response
time of the server. For some modulus sizes, DH secrets
with leading zeroes will result in a faster server KDF
computation, and hence a shorter server response time.
4. Assume temporarily that the attacker can perfectly detect
the above case. Each such case can be converted to
an equation in the Hidden Number Problem. When a
sufﬁcient number of equations has been determined, the
HNP can be solved to calculate gab, the secret Difﬁe-
Hellman value of the original handshake. The attacker
can then decrypt the original TLS trafﬁc to recover its
plaintext.
Contributions. We make the following contributions:
• We present a novel side channel, stemming from the
TLS-DH(E) standard, that leaks the value of some most
signiﬁcant bits of a DH shared secret.
214    30th USENIX Security Symposium
USENIX Association
• We demonstrate that this side channel can be exploited
remotely, allowing an adversary to decrypt TLS trafﬁc.
More broadly, our ﬁndings serve as another example of
the dangers of computations in cryptography that are
not constant-time, which are relevant to cryptographic
protocols beyond TLS.
• We perform large-scale scans of the most prominent
servers on the Internet to estimate the impact of the
vulnerability. Interestingly, with our scans, we were able
to ﬁnd servers presenting different behavior based on
the ﬁrst byte of the premaster secret; this allowed us to
construct a direct form of our Raccoon attack.
• We report the ﬁrst attack targeting ﬁnite-ﬁeld Difﬁe-
Hellman using the Hidden Number Problem as a crypt-
analytic tool.
Responsible Disclosure. We responsibly disclosed our ﬁnd-
ings to large server operators, major TLS implementations,
the IETF, and our national CERT. F5 assigned the issue CVE-
2020-5929. In particular, several F5 products enable a special
version of the attack, without the need for precise timing mea-
surements.1 OpenSSL assigned the issue CVE-2020-1968.2
OpenSSL uses fresh DH keys per default since version 1.0.2f
from 2016. To further mitigate the attack, OpenSSL moved all
remaining DH cipher suites to the weak ciphers list. In addi-
tion, motivated by this research, the developers also switched
to fresh generation of EC ephemeral keys in OpenSSL 1.0.2w
(these keys were previously long-lived). Mozilla assigned the
issue CVE-2020-12413. It has been solved by disabling DH
and DHE cipher suites in Firefox (which was already planned
before our report). Microsoft assigned the issue CVE-2020-
1596.3 BearSSL and BoringSSL are not affected because they
do not support DH(E) cipher suites. Botan, Mbed TLS, Wolf-
SSL and s2n do not support static DH cipher suites. Their
DHE cipher suites never reuse ephemeral keys.
Artifacts Availability. The code that was used in this
work is available under an Open Source license at
https://github.com/tls-attacker/raccoon-code.
2 Background
Here we provide a description of the Transport Layer Security
(TLS) handshake protocol and its key derivations.
2.1 Transport Layer Security (TLS)
The TLS protocol (previously known as SSL) provides con-
ﬁdentiality, integrity, and authenticity to many common ap-
plications on the Internet. The latest version of the protocol
is TLS 1.3 [55], while the older versions TLS 1.0, 1.1, and
1.2 [26–28] are currently still deployed alongside of it. The
1https://support.f5.com/csp/article/K91158923
2https://www.openssl.org/news/secadv/20200909.txt
3https://portal.msrc.microsoft.com/en-US/security-guidance/
advisory/CVE-2020-1596
The TLS protocol structure consists of two phases.
older versions SSLv3 and SSLv2 are considered to be inse-
cure. SSLv3 and TLS versions 1.0 to 1.2 all share a similar
structure, while TLS 1.3 overhauled the design of the protocol
and is fundamentally different from the previous versions. In
this work, we focus on SSLv3 and TLS versions 1.0 to 1.2.
In
the ﬁrst phase, called the handshake, the client and server
negotiate the cryptographic algorithms and establish session
keys. In the second phase, the peers can securely send and
receive application data using the record protocol, which is
encrypted and authenticated using the keys and algorithms
established in the previous phase.
The aforementioned choice of cryptographic algorithms
is called a TLS cipher suite [28]. More precisely, a cipher
suite is a concrete selection of algorithms for all of the re-
quired cryptographic tasks. For example, the cipher suite
TLS_DHE_RSA_WITH_AES_128_CBC_SHA uses ephemeral DH
key exchange and RSA signatures over server DH shares in
order to establish a shared session key. In order to encrypt and
authenticate data, it uses symmetric AES-CBC encryption
with a 128-bit key and HMACs based on SHA-1.
In the following, we focus on cipher suites using DH(E) as
the key exchange method. To establish a TLS connection, the
client starts the TLS handshake by sending a ClientHello
message, which contains the supported cipher suites, the sup-
ported version(s), and TLS features, as well as a nonce (called
ClientRandom). The server answers this with a ServerHello,