it on to the server, but for now, let’s just go ahead and forward the request
(and any subsequent ones) by clicking the Forward button. Returning to
the browser, we see the server has sent us the main page of the bookservice
site, as shown in Figure 14-5.
316 Chapter 14
Figure 14-5: Bookservice site
Next let’s try signing up for an account (Figure 14-6). Click Login at
the top left of the page, and then forward the request to the server from the
proxy. Do the same to get to the Sign Up page by clicking New User and
forwarding the request to the server.
Figure 14-6: Signing up for a new account
Enter a username, password, and email address, then submit the request
by clicking Go. The request should be captured in Burp Proxy, as shown in
Figure 14-7.
Web Application Testing 317
Figure 14-7: Captured request
In addition to looking at the raw request, which is a bit unfriendly to
read, you can click the Params tab at the top of the request window in Burp
Suite to display the request parameters in a more readable format, as shown
in Figure 14-8.
Figure 14-8: Request parameters
318 Chapter 14
For example, the new display shows the User field georgia, Pass field
password, and Email field georgia@bulbsecurity.com.
You can change these fields directly in the proxy. For example, if you
change georgia’s password to password1 before forwarding the request to the
server, the server will set the password for user georgia to password1, because
the server never saw the original request from the browser requesting the
password password.
The proxy allows you to see the details of any request to the server. If
at any point you don’t need to proxy traffic, click Intercept is on to toggle
it to Intercept is off and allow traffic to pass through to the server without
user interaction. Switch the button back on if you want to catch a particular
request.
sQL injection
Many web applications store data in a backend, SQL-based database. For
example, we encountered a SQL database during our network penetration
test, when we found an open MySQL database through phpMyAdmin in the
XAMPP install on the Windows XP target on page 186. We then used a
SQL query to write a simple PHP command shell to the web server.
We typically won’t have direct access to run SQL queries on a site’s
backend database from a web application. However, if a developer fails to
sanitize user input when interacting with the database, you may find that
you can perform a SQL injection attack to manipulate the queries sent to it.
Successful SQL injection attacks can read data from the database, modify
data, shut down or destroy the database, and, in some cases, even run com-
mands on the underlying operating system (which can be especially power-
ful because database servers often run as privileged users).
A natural place to look for SQL injection issues is in the login page.
Many web applications store user data in a database, so we can use a SQL
query to pull out the correct user, based on the username and password
provided by the user. When developers don’t sanitize user input, we can
build SQL queries to attack the database. An example of an injectable SQL
statement that could be leveraged by an attacker is shown here:
SELECT id FROM users WHERE username='$username' AND password='$password';
What if an attacker supplied a username ' OR '1'='1 and the user’s pass-
word was ' OR '1'='1? The SQL statement turns into:
SELECT username FROM users WHERE username='' or '1'='1' AND password='' or '1'='1'
Because the OR '1'='1' will always be true, this SELECT statement will now
return the first username in the user table, regardless of the username and
password.
Web Application Testing 319
au: inserted space
in “ms sql” – ok?
As we’ll see in “XPath Injection” on page 323, our application uses
Xpath, a query language for XML documents, which authenticates against
an XML file rather than a database, though the injection process is similar.
However, our application does use a SQL database to store records of the
books available in the store, and when we select a book on the main page,
its details are pulled from an MS SQL backend database. For example,
click the More Details link for the first book on the site, Don’t Make Me
Think. The URL requested is:
http://192.168.20.12/bookservice/bookdetail.aspx?id=1
The book’s details are filled in based on the results returned from the
database query for the record with ID 1.
Testing for SQL Injection Vulnerabilities
A typical first test for SQL injection vulnerabilities is to use a single quotation
mark to close the SQL query. If a SQL injection vulnerability is present, the
addition of that quotation mark should cause the application to throw a SQL
error, because the query will already be closed as part of the underlying
code and the extra single quote will cause the SQL syntax to be incorrect.
That error will tell us that we can inject SQL queries to the site’s database
using the id parameter.
Let’s try this out by sending the query again with the id parameter to 1',
as shown here.
http://192.168.20.12/bookservice/bookdetail.aspx?id=1'
As expected, the application serves an error page indicating that our
SQL syntax is incorrect, as shown in Figure 14-9.
Figure 14-9: The application identifies a SQL error.
In particular, note the message “Unclosed quotation mark after the
character string” in our SQL query.
320 Chapter 14
au: inserted space
in “ms sql” – ok?
As we’ll see in “XPath Injection” on page 323, our application uses note Not all applications that are vulnerable to SQL injection will be so verbose with their
Xpath, a query language for XML documents, which authenticates against error messages. In fact, there is a whole class of blind SQL injection vulnerabilities,
an XML file rather than a database, though the injection process is similar. where error messages detailing the injection are not shown, even though the injection
However, our application does use a SQL database to store records of the flaw is still present.
books available in the store, and when we select a book on the main page,
its details are pulled from an MS SQL backend database. For example,
Exploiting SQL Injection Vulnerabilities
click the More Details link for the first book on the site, Don’t Make Me
Think. The URL requested is: Now that we know a SQL injection vulnerability is present in this site, we
can exploit it to run additional queries on the database that the developer
http://192.168.20.12/bookservice/bookdetail.aspx?id=1 never intended. For example, we can find out the name of the first database
with the following query:
The book’s details are filled in based on the results returned from the
database query for the record with ID 1.
http://192.168.20.12/bookservice/bookdetail.aspx?id=2 or 1 in (SELECT DB_NAME(0))--
Testing for SQL Injection Vulnerabilities The query throws an error message, Conversion failed when converting the
nvarchar value ‘BookApp’ to data type int, which tells us that the name of the first
A typical first test for SQL injection vulnerabilities is to use a single quotation
database is BookApp, as shown in Figure 14-10.
mark to close the SQL query. If a SQL injection vulnerability is present, the
addition of that quotation mark should cause the application to throw a SQL
error, because the query will already be closed as part of the underlying
code and the extra single quote will cause the SQL syntax to be incorrect.
That error will tell us that we can inject SQL queries to the site’s database
using the id parameter.
Let’s try this out by sending the query again with the id parameter to 1',
as shown here.
http://192.168.20.12/bookservice/bookdetail.aspx?id=1'
As expected, the application serves an error page indicating that our
SQL syntax is incorrect, as shown in Figure 14-9.
Figure 14-10: Error message showing the database name
Using SQLMap
We can also use tools to automatically generate SQL queries to perform var-
ious tasks on a site using SQL injection. All we need is an injection point;
the tool does the rest. For example, Listing 14-1 shows how when we give a
tool in Kali SQLMap a potentially injectable URL, SQLMap tests for SQL
injection vulnerabilities and performs injection queries.
root@kali:~# sqlmap -uu "http://192.168.20.12/bookservice/bookdetail.aspx?id=2" --dumpv
--snip--
Figure 14-9: The application identifies a SQL error. [21:18:10] [INFO] GET parameter 'id' is 'Microsoft SQL Server/Sybase stacked queries' injectable
--snip--
In particular, note the message “Unclosed quotation mark after the Database: BookApp
Table: dbo.BOOKMASTER
character string” in our SQL query.
[9 entries]
+--------+---------------+-------+-------+-------------------------------------
Web Application Testing 321
| BOOKID | ISBN | PRICE | PAGES | PUBNAME | BOOKNAME
| FILENAME | AUTHNAME | DESCRIPTION
|
+--------+---------------+-------+-------+-------------------------------------
| 1 | 9780470412343 | 11.33 | 140 | Que; 1st edition (October 23, 2000) | Do not Make
Me Think A Common Sense Approach to Web Usability |
4189W8B2NXL.jpg | Steve Krug and Roger Black | All of the tips, techniques, and examples
presented revolve around users being able to surf merrily through a well-designed site
with minimal cognitive strain. Readers will quickly come to agree with many of the books
assumptions, such as We do not read pages--we scan them and We do not figure out how things
work--we muddle through. Coming to grips with such hard facts sets the stage for Web design
that then produces topnotch sites. |
--snip-- |
Listing 14-1: Dumping the database with SQLMap
Specify the URL to test with -u option u. The --dump option v dumps
the contents of the database—in this case, details of the books.
We can also use SQLMap to try to get command-shell access on the
underlying system. MS SQL databases contain a stored procedure called
xp_cmdshell, which will give us command-shell access, but it’s often disabled.
Luckily, SQLMap will try to reenable it. Listing 14-2 shows how we can get
a command shell on the site’s underlying Windows 7 target system using
SQLMap.
root@kali:~# sqlmap -u "http://192.168.20.12/bookservice/bookdetail.aspx?id=2" --os-shell
--snip--
xp_cmdshell extended procedure does not seem to be available. Do you want sqlmap to try to
re-enable it? [Y/n] Y
--snip--
os-shell> whoami
do you want to retrieve the command standard output? [Y/n/a] Y
command standard output: 'nt authority\system'
Listing 14-2: xp_cmdshell access through SQL injection
As you can see in Listing 14-2, we receive a shell running as System with-
out having to guess credentials for the database.
note The MS SQL database is not listening on a port anyway, so we can’t access it directly.
Unlike our Windows XP system in Chapter 6, this web server lacks phpMyAdmin, so
we have no other way to access the database. A SQL injection issue in the hosted web-
site gives us full system access.
322 Chapter 14
xPath injection
As mentioned previously, this bookservice application uses XML authen-
tication, in which the XML is queried using Xpath. We can use XPath
injection to attack XML. Though its syntax differs from SQL, the injection
process is similar.
For example, try entering single quotes (') for both the username and
password fields at the login page. You should receive an error like the one
shown in Figure 14-11.
Figure 14-11: XML error at login
As you can see from the error message shown in Figure 14-11, we again
have an injection issue because we have an error in our syntax. Because
we are at a login page, a typical injection strategy for Xpath would be to
attempt to bypass authentication and gain access to the authenticated por-
tion of the application by attacking the Xpath query logic.
For example, as shown in the error details, the login query grabs the
username and password provided, and then compares the values provided
against credentials in an XML file. Can we create a query to bypass the
need for valid credentials? Enter a set of dummy credentials at login, and
capture the request with Burp Proxy, as shown in Figure 14-12.
Now change the txtUser and txtPass parameters in the captured request
to this value.
' or '1'='1
Web Application Testing 323
Figure 14-12: Captured login request
This tells the login Xpath query to find the user account where the
username and password field is blank or 1=1. Because 1=1 always evaluates
as true, the logic of this query says to return the user where the username
is blank or present—likewise with the password. Thus using this injection
method, we can get the application to log us in as the first user in the authen-
tication file. And, as shown in Figure 14-13, we are logged in as the user Mike.
Figure 14-13: Authentication bypass through Xpath injection
Local File inclusion
Another vulnerability commonly found in web applications is local file inclu-
sion, which is the ability to read files from the application or the rest of the
filesystem that we should not have access to through the web app. We saw an
example of this in Chapter 8 where the Zervit web server on the Windows XP
target allowed us to download files from the target, such as a backup of the
SAM and SYSTEM hives.
Our bookservice app also suffers from local file inclusion. As user Mike,
go to Profile4View Newsletters. Click the first newsletter in the list to view
the contents of the file, as shown in Figure 14-14.
324 Chapter 14
Figure 14-14: Viewing a newsletter
Now resend the request, and capture it with Burp Proxy, as shown in
Figure 14-15.
Figure 14-15: Captured newsletter request
Click the Params tab, and note the parameter c:\inetpub\wwwroot\Book\
NewsLetter\PI:EMAIL\Web Hacking Review.txt. The path c:\inetpub\wwwroot\
Book\NewsLetter\Mike suggests that the newsletter functionality is pulling the
newsletters from the local filesystem by their absolute path. It also looks like
there’s a folder called PI:EMAIL in the Newsletter folder. Perhaps each
user subscribed to the newsletters has such as folder.
It also seems as if our application is actually at the path c:\inetpub\
wwwroot\Book, as noted in the newsletter requests, instead of c:\inetpub\
wwwroot\bookservice as we might expect from the URL. We note this
because it may come in handy later on.
Web Application Testing 325
What if we change the filename parameter to another file in the web
application? Can we gain access to the app’s full source code? For example,
change the file to the following, and forward the request to the server.
C:\inetpub\wwwroot\Book\Search.aspx
As you can see, the source
code of the Search.aspx page
is displayed in the Newsletter
box, as shown in Figure 14-16.
Having access to the full
server-side source code of the
web application allows us to do
a complete source code review
to look for issues.
But perhaps we can access
even more sensitive data. For
example, we know that the
usernames and passwords are
stored in an XML file. Perhaps
we can request this file. We
Figure 14-16: Local file inclusion vulnerability
don’t know its name, but a few
guesses for common filenames
in XML authentication scenar-
ios will lead us to the filename AuthInfo.xml. Capture the newsletter request
in Burp Proxy, and change the requested file to the one shown here.
C:\inetpub\wwwroot\Book\AuthInfo.xml
As you can see in Figure
14-17, we now have access to
the usernames and passwords
in plaintext. Now we know why
our previous Xpath injection
logged us in as the user Mike:
Mike is the first user in the file.
This is a prime example
of when using a proxy comes
in handy. A user with just a
browser would have been lim-
ited to only the files he or she
could click on, namely the
newsletters presented. On the
other hand, with the proxy
Figure 14-17: Authentication info
we are able to see the request
ask for a specific file from the
326 Chapter 14