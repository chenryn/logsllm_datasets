title:Poster: Directed Hybrid Fuzzing on Binary Code
author:Juhwan Kim and
Joobeom Yun
POSTER: Directed Hybrid Fuzzing on Binary Code
Juhwan Kim and Joobeom Yun∗
Sejong University, Seoul, Republic of Korea
PI:EMAIL,PI:EMAIL
ABSTRACT
Hybrid fuzzers combine both fuzzing and concolic execution with
the wish that the fuzzer will quickly explore input spaces and the
concolic execution will solve the complex path conditions. However,
existing hybrid fuzzers such as Driller cannot be effectively directed,
for instance, towards unsafe system calls or suspicious locations,
or towards functions in the call stack of a reported vulnerability
that we wish to reproduce. In this poster, we propose DrillerGO, a
directed hybrid fuzzing system, to mitigate this problem. It mainly
consists of a static analysis and a dynamic analysis module. In
the static analysis, it searches suspicious API call strings in the
recovered control flow graph (CFG). After targeting some suspicious
API call lines, it runs the concolic execution along with path guiding.
The path guiding is helped by backward pathfinding, which is a
novel technique to find paths backward from the target to the start
of main(). Also, we will show that DrillerGo can find the crashes
faster than Driller through experimental results.
CCS CONCEPTS
• Security and privacy → Software and application security.
KEYWORDS
software; vulnerability; fuzzing; symbolic execution; state explosion
ACM Reference Format:
Juhwan Kim and Joobeom Yun. 2019. POSTER: Directed Hybrid Fuzzing on
Binary Code. In 2019 ACM SIGSAC Conference on Computer and Communi-
cations Security (CCS’19), November 11–15, 2019, London, United Kingdom.
ACM, New York, NY, USA, 3 pages. https://doi.org/10.1145/3319535.3363275
1 INTRODUCTION
Fuzzing is an automatic testing technique that covers numerous
boundary cases using invalid data as application input to better
ensure the absence of exploitable vulnerabilities [1]. Among sev-
eral fuzzing techniques, the coverage-guided fuzzing [2] and the
concolic execution [3, 4] are notable nowadays. Coverage-guided
fuzzing can quickly explore the input spaces and the concolic execu-
tion can solve the complex branch constraints. For instance, Driller
[5] showed its effectiveness of the hybrid fuzzing in the DARPA
Cyber Grand Challenge (CGC) [6] binaries, which generated six
new crashing inputs out of 126 binaries that were not possible when
running either the fuzzing or the concolic execution alone.
∗Corresponding author
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
CCS ’19, November 11–15, 2019, London, United Kingdom
© 2019 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-6747-9/19/11.
https://doi.org/10.1145/3319535.3363275
However, sometimes hybrid fuzzers having a coverage-guided
fuzzer show a strange behavior. It executes exhaustively the path
having no possible crashes because the coverage-guided fuzzer
tends to widen the code coverage. If we have a special target line
in a huge binary program, this is very awkward. We dubbed this
phenomenon a confusion of the fuzzer. We eliminate this phenome-
non by providing a guidance to the suspicious target line. In order
to give a guidance, DrillerGo first runs a static analysis. After it
searches suspicious API calls (target lines) in the disassembled code,
it finds paths from the target line to the program start point in the
recovered CFG. DrillerGo uses these paths and explores the binary
code until it triggers crashes during the dynamic analysis.
2 HYBRID FUZZING
Figure 1: Concept of hybrid fuzzing. When a fuzzer cannot
explore the path any more, a symbolic execution engine
starts.
In order to mitigate a fuzzer’s limited code coverage and symbolic
execution’s state explosion problem, a hybrid fuzzing technique
combining the concolic execution, also known as dynamic symbolic
execution, with the fuzzing has been proposed. As shown in Figure
1, it first performs the fuzzing and then runs the concolic execution
only when the fuzzer no longer finds a new path. That is, it performs
the concolic execution based on the input generated by the fuzzer,
and the concolic execution is used to check whether there are other
branches which the fuzzer could not explore. Unlike traditional
concolic execution, it does not explore into branched compartments,
it only solves the constraints and sends the generated input to the
fuzzer and it exits. As a consequence, hybrid fuzzing mitigates the
problem of the state explosion by reducing calls to the concolic
execution and relying on the fuzzing. However, it suffers from a lack
of directed properties. If the concolic execution passes the inputs
that are not related to the crashes to the fuzzer, it will explore
meaningless paths, and a vicious circle will occur, which explores
meaningless paths deeply. As a result, the fuzzer’s work queue is
increased by the number of input values that are not related to the
PosterCCS ’19, November 11–15, 2019, London, United Kingdom2637Figure 2: Architecture of DrillerGO.
Figure 3: An example of Backward Pathfinding.
crashes, and this process causes waste of system resources and time.
We dubbed this phenomenon a confusion of the fuzzer.
3 DRILLERGO OVERVIEW
DrillerGo reads program binary as an input and outputs crash
triggering information as shown in Figure 2. It consists of three
modules; backward pathfinding, the fuzzing, and the directive con-
colic execution. Backward pathfinding is the core of this system
and is a novel technique. It is a static analysis, allows crashes to
be triggered quickly, and mitigates the confusion of the fuzzer. We
use American Fuzzy Lop (AFL) [2] as DrillerGo’s fuzzing engine,
which trigger crashes efficiently. Also, we use angr [7], the next-
generation binary analysis tool, as our directive concolic execution
engine.
Common Vulnerabilities and Exposures (CVE) [8] announces
known information-security vulnerabilities to the public. It has
vulnerability descriptions (e.g., the affected product and version,
the type of vulnerability, etc.). We parsed these descriptions and
extracted unsafe API function names. Using these, the backward
pathfinding module searches their strings in the recovered CFG.
If it finds unsafe function names in the recovered CFG, it marks
there as a target. For instance, gets() is unsafe function so it can be a
target line in Figure 3. And then, it collects addresses of nodes that
call directly a target function and it repeatedly collects addresses
of parent nodes until it reaches the start of main() function. These
collected addresses will be used by the directive concolic execution
module, which informs the fuzzing module a right path to the target
line.
After the backward pathfinding module is finished, a dynamic
analysis starts to run. The fuzzing module and the directive concolic
execution module runs with complementary cooperation, and the
directive concolic execution is just a stepping stone to increase the
efficiency of fuzzing. Our fuzzing module uses AFL, which performs
a grey-box fuzzing [9] technique. The grey-box fuzzing generates
input values that cause a new state transition by performing an
instrumentation differently from a traditional fuzzing. That is, the
generated input values are unique. However, fuzzing suffers from
difficult constraints of many conditional branches. In order to solve
this, our system runs the directive concolic execution module to trace
the input values generated by the fuzzing module. Specifically, it
determines the branched compartments that the fuzzing module
has failed to enter, solves the constraints, and passes the new input
values to the fuzzing module. However, if it solves every constraint
of all branched compartments, the fuzzing module will receive all
input values which can explore all the paths, but more than a half
of them are useless because they are not related to the crash. So we
have implemented the backward pathfinding module to prevent this
problem. As shown in Figure 4, DrillerGo solves the path constraint
only when the address of the branched compartment is included
in the collected addresses that the backward pathfinding gathered
earlier.
Figure 4: Path constraint solving of DrillerGO.
PosterCCS ’19, November 11–15, 2019, London, United Kingdom2638Table 1: Time-to-Exposure (TTE) and Total-of-Paths (TP), Driller versus DrillerGO.
Driller #TTE
#TP
DrillerGO #TTE
#TP
Factor
Driller #TTE
#TP
DrillerGO #TTE
#TP
Factor
CROMU00012
8m 58s
501
7m 03s
457
1.27
CROMU00027
10m 0s
149
6m 59s
67
1.43
CROMU00014
3m 22s
154
2m 22s
82
1.42
CROMU00031
2h 19m 0s
204
1h 13m 50s
213
1.88
CROMU00015
5m 04s
183
4m 19s
173
1.17
CROMU00033
4h 22m 20s
511
2h 56m 31s
446
1.49
CROMU00018
4h 04m 54s
256
2h 03m 27s
332
1.98
CROMU00035
4h 02m 11s
545
2h 32m 33s
457
1.59
CROMU00019
18h 19m 14s
1080
9h 50m 11s
692
1.86
CROMU00039
17m 42s
140
12m 24s
121
1.43
CROMU00023
8h 18m 10s
925
3h 30m 11s
811
2.37
KRPCA00011
4h 36m 03s
344
2h 02m 31s
468
2.25
CROMU00024
1h 41m 18s
589
1h 13m 08s
581
1.39
N RF I N00005
21m 13s
139
11m 53s
114
1.79
4 EVALUATION
In this section, we demonstrate the performance evaluation of
DrillerGO. First, we evaluated whether DrillerGO triggers a crash
faster than a previous system, Driller. Second, we evaluated the
code coverage of how many program paths are explored until the
crash is triggered.
To evaluate our system, we compared it with Driller and selected
the CGC dataset as a benchmark dataset. We set the timeout as 24
hours per binary, and terminated the system if a crashing input was
found. Time-to-Exposure (TTE) measures the length of the fuzzing
campaign until the first test input is generated that exposes a crash.
And we gave a same string (“fuzz”) as the initial input to both sys-
tems because the initial input makes a big performance difference
to the fuzzer. We conducted our experiments on a machine with a
3.5 GHz Intel(R) Core i7-7800X CPU and 64GB of RAM. We used
the Ubuntu 16.04 LTS version. Our experimental results are shown
in Table 1. Most of Driller’s TTE is greater than DrillerGo’s in Table
1. This means that DrillerGo finds a first crashing input than Driller.
In order to calculate how much DrillerGo finds a crash faster, we
calculate time efficiency. The formula to calculate time efficiency
is:
Fi = TDriller
TDrillerGo
(1)
Where Fi is time efficiency, Tsystem is TTE of system. In Ta-
ble 1, the most improved result is on CROMU00023 binary, where
DrillerGo finds a crash 2.37 times faster than Driller.
We also measure total-of-paths (TP), which means the code cov-
erage. TP is the number of paths found by a fuzzer. In Table 1,
Most of DrillerGO’s TP is smaller than Driller’s. This means that
DrillerGO doesn’t spend its execution time to widen the code cov-
erage but concentrates on exploring the path which guides to the
target line. As a result, DrillerGo shows better performance than
Driller because finding a crash more quickly is important in a di-
rected fuzzing technique.
5 CONCLUSION AND FUTURE WORKS
In this poster, we propose DrillerGO, which is a directed hybrid
fuzzing system. Our system has a novel method, backward pathfind-
ing, which prevents the confusion of the fuzzer. We also show that
DrillerGo finds a crash more quickly than Driller. However, it has
a heavy-weight concolic execution engine and cannot perform an
analysis on binaries that do not have a suspicious API function
name. We will research these shortcomings. First, we will apply a
light-weight and speedy symbolic execution engine, QSYM [10] to
mitigate DrillerGo’s overhead for a concolic execution. Second, we
will study cases that don’t have suspicious API calls.
ACKNOWLEDGMENTS
This research was supported by the Basic Science Research Program
through the National Research Foundation of Korea (NRF) funded
by the Ministry of Education (No.2018R1D1A1B07047323). Also,
this research was supported by the MSIT(Ministry of Science and
ICT), Korea, under the ITRC(Information Technology Research
Center) support program(IITP-2019-2018-0-01423) supervised by
the IITP(Institute for Information communications Technology
Promotion).
REFERENCES
[1] P. Oehlert, “Violating assumptions with fuzzing,” IEEE Security Privacy, vol. 3,
no. 2, pp. 58–62, 2005.
[2] M. Zalewski, “American fuzzy lop.” http://lcamtuf.coredump.cx/afl/.
[3] C. Cadar, D. Dunbar, and D. R. Engler, “Klee: Unassisted and automatic generation
of high-coverage tests for complex systems programs,” In Proceedings of the
USENIX Symposium on Operating Systems Design and Implementation (OSDI),
2008.
[4] R. Majumdar and K. Sen, “Hybrid concolic testing,” In Proceedings of the 29th
International Conference on Software Engineering (ICSE), 2007.
[5] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshitaishvili,
C. Kruegel, and G. Vigna, “Driller: Augmenting fuzzing through selective sym-
bolic execution,” In Proceedings of the Symposium on Network and Distributed
System Security, 2016.
[6] “Darpa cyber grand challenge.” https://github.com/cybergrandchallenge/.
[7] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher, J. Grosen,
S. Feng, C. Hauser, C. Kruegel, and G. Vigna, “(state of) the art of war: Offensive
techniques in binary analysis,” In Proceedings of the IEEE Symposium on Security
and Privacy, 2016.
[8] “Common vulnerabilities and exposures.” https://cve.mitre.org/.
[9] L. team, “libfuzzer - a library for coverage-guided fuzz testing.” https://llvm.org/
docs/LibFuzzer.html.
[10] I. Yun, S. Lee, M. Xu, Y. Jang, and T. Kim, “Qsym: A practical concolic execu-
tion engine tailored for hybrid fuzzing,” In Proceedings of the USENIX Security
Symposium, 2018.
PosterCCS ’19, November 11–15, 2019, London, United Kingdom2639