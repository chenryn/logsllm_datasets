我们希望，可以在任何情况下都可以主动的发起对一条协议的测试，从而绕过客户端上的逻辑限制，深度挖掘游戏服务器中的问题（还是那个原则，客户端不可信）。这里就有一个很巧妙的办法：协议劫持。
而劫持的具体做法是：寻找一条简单的，不会受到客户端逻辑限制的协议，比如游戏里的动作、表情等。因为这类协议对于游戏安全来说是冗余的，安全可靠的。
使用中间人工具进行测试的工作流程如图所示
**2.2.4 方案局限性**
基于中间人的测试方案可以在游戏客户端上直接看到bug的展示效果，这很大程度上提升了漏洞的发现效率；但相对于上一代方案来说，还是有两点问题没有解决：
  1. 协议接入时间较久，因为协议包的解析还涉及到粘包和拆包等问题，较为复杂， 不仅需要对数据层面进行解析，还要对协议层面和数据流层面进行解析。工作量较大。
  2. 对于新游戏的二次适配消耗较高，在进行增量测试时，游戏往往已经根据业务需求和首轮安全评估结果修改了加密和协议方案，该方案很可能和当前接入的协议流程不一致，所以需要对协议流程进行重新的解析，较为耗时。
以上问题的产生，都是由于协议解析类方案的局限性而导致的，想要进一步发展，就需要从根本上抛弃原有的思路。
### 2.3 基于客户端注入的劫持和伪造工具（GameDancer）
为了解决以往方案中的不足，我们准备对测试方案进行重新设计，结合以往的测试经验，重新设计的方案的目标是：
1、 **不在数据流层面进行操作** ，较少的在协议层面进行操作，直接操作可以看到的明文数据内容。
2、 **测试协议的组件过程尽量在加解密之前** ，因为加解密方案是多变的、难以固定适配的。
3、 **可以直接在客户端上看到漏洞的展示效果** ，不需要脱机运行。
4、 **可以方便的主动发起测试协议** ，用非劫持的方法来向游戏服务器发起测试协议，并且不需要对游戏本身的包序号进行管理。
5、 **测试工具在前端展示完整解析的协议格式和数据** ，进行测试数据推荐和fuzz自动覆盖。
**2.3.1 核心模型**
为了达到以上的设计目标，我们放弃了原有的协议方案，通过代码注入的方式来开发一款新的游戏安全漏洞挖掘工具——GameDancer。
设计的主要思路是通过hook游戏逻辑中协议交互的接口，拿到游戏的交互明文数据，对数据进行解析后，通过主动调用游戏接口，将测试协议通过游戏客户端发往游戏服务器。
说的简单一点，对于这套测试方案来讲，游戏客户端就是一个给我们工具提供协议解析和协议发送服务的模块，将这部分复杂的工作通过游戏本身来自动化的完成。其整体的设计模型如下：
**2.3.2 前端UI**
工具前端是与安全评审人员主要的交互场景，也是决定使用效率的地方。为了提高漏洞的发现效率，我们需要完成以下目标：
  1. 针对不同类型的协议字段进行可能导致BUG的字段值推荐，减少评估人员填入数据的环节
  2. 可以对某条或者某几条协议进行快速自动fuzz的高级发送功能，一键覆盖可能的问题
  3. 针对测试环境的不同，提供PC版和网页版前端界面，PC截图如下：
前端主要和核心框架中的hook引擎进行数据交互，数据交互流程较为简洁；
**2.3.3 加载器和hook引擎**
加载模块主要提供注入游戏的功能，需要将包含游戏脚本hook引擎功能的库文件加载到游戏同一个进程和命名空间下，使我们自定义的游戏测试逻辑可以注入到游戏上下文当中，从而对游戏原生逻辑进行修改和操控；
加载器有两种技术选型，一种是针对root环境，使用附加Zygote的方式来完成注入；另一种是针对非root环境使用虚拟多开技术进行注入，root模式对测试终端的环境有一定要求，但是其适配的游戏范围广；非root模式不额外需要root环境，但是对于有些游戏和机型需要特殊的适配。
注入Hook引擎的流程如下：
hook引擎中包含了针对各类游戏引擎及其技术选型的hook支持，可以对游戏脚本进行注入和替换，是该套技术方案中的重点部分。
以Unity3d引擎mono选型为例，主要方案是借助libmono.so本身的接口和Mono的JIT机制；
  1. 首先加载我们自己逻辑的模块，这里是我们用C#开发的dll文件。
  2. 通过mono_class_get_methods 定位到我们要替换的目标方法、替换方法，以及代替原方法的空指针。
  3. 接下来借助libmono.so 的mono_compile_method 进行JIT编译，得到native code 返回地址。
  4. 完成方法替换，即hook了目标逻辑。
**2.3.4 逻辑层**
逻辑层是控制游戏运行逻辑和游戏协议管理的核心，在逻辑层我们需要完成以下预定功能：
  1. 版本适配
  2. 因为游戏开发商很多，其所使用的Unity的.Net FrameWork版本也不同，高版本的.NET特性无法在低版本运行。
  3. 由于需要引入游戏的逻辑，所以想要解析游戏的脚本作为动态库，那么需要适当的版本来支持解析。
  1. 协议解析&数据上报
  2. 因为这里hook的游戏接口不同，需要根据不同的情况，将数据解析成明文数据，一般是针对proto和json的解析
  3. 数据上报即将解析完成的数据以Json的形式传递给UI前端，这里最大的问题在于Json的构建，由于游戏Unity版本的问题，有的.net版本不支持通用的Json库，所以需要根据游戏的运行环境来选择对应的Json代码
  4. 热更脚本交互（Lua）
  5. 除了在C#层进行hook之外，还需要对游戏的热更脚本进行操作，因为一部分游戏的主要逻辑存在于热更脚本中，例如C#与lua的交互流程如下
  1. 线程监控，持续注入；在一些自定义脚本引擎中，一段时间后会清空注册过的脚本方法，所以需要利用MonoBehaviour等自动创建实例按帧调用的方式来监控脚本方法的注册情况。
  2. 回调收集；
  3. 由于游戏的协议设计机制不同，有的游戏在收到返回包后根据返回包的内容进行页面渲染，有的游戏需要通过发包时的回调来完成对应的状态改变，所以需要对发包时的回调进行收集并保存。
  4. 需要额外注意公开枚举器IEnumerable与yeild的调用流程，这里的流程不可打断，不可单独调用。
**2.3.5 未来展望**
GameDancer的开发，并不只是提供了一款快捷、高效游戏安全评审工具，更重要的，它提供了一个游戏注入平台，根据一定的文档指引，相关人员可以开发自己的游戏插件来控制游戏的逻辑走向、观察游戏实时性能数据、了解游戏BUG产生的详细情况；这些也是我们对工具未来发展的期望；
### 2.4 小结
各个方案虽然是一代代的演进过程，但是旧方案并不会被淘汰，每一个技术方案在漏洞挖掘的过程中都有其独特的用处：基于客户端注入的方案虽然高效。但是无法发现游戏加密方案和登录流程在设计上的安全问题，这类问题仍然需要通过协议重建来发现。
在安全评审工作中，我们会采用多类型的工具对游戏进行多角度的安全评估，保证在评审覆盖的过程中不留遗漏。
## 三、结束语
“工欲善其事必先利其器”，如你所见，通过技术方案的不断演进，游戏安全漏洞的挖掘效率和漏洞质量得到了提升；从最开始为了快速开展安全评估工作的协议重建方案，到后来可以直观看到漏洞效果的中间人方案，再到GameDancer方案，每一次的方案升级都是为了更好的解决游戏安全评审业务眼下所存在的问题和局限。
游戏安全评审是一项繁琐的工作，漏洞的种类及其产生条件、原因不一而足，想要尽可能全面的覆盖一款游戏中的安全问题，需要评审人员耐心与细致的检查，更加需要技术能力和高效工具的支持。在游戏安全评审技术方案的进阶之路上，“追求极致”是激励我们不断前进的动力。
如果你也想参与到我们的游戏安全工作建设中来，体会在各类游戏中发现漏洞的乐趣、享受和黑产外挂斗的其乐无穷，欢迎加入无恒实验室，简历投递：https://job.toutiao.com/s/ee1qpHt
；或者通过二维码直接投递：