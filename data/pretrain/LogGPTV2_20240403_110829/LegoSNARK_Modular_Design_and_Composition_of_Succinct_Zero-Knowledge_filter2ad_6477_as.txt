Abstract with the PolyCom commitment and CPpoly argument from [ZGK+17b] as described in
Appendix E. This is essentially the only diﬀerence with the original Hyrax scheme that uses (an
extension of) a matrix commitment of size O(|w|1/l) and Bulletproof for proving polynomial eval-
uations with O(|w|(l−1)/l) veriﬁcation time. In HyrPoly there is instead a succinct commitment (of
constant size) and a veriﬁcation time, in step (iii), of O(log(|w|)).
Using HyrPoly for Data-Parallel Computations. Hyrax, and in particular its Gir++ core
protocol, is designed to work on arithmetic circuits of fan-in two, consisting of N identical sub-
computations, each having d layers and width at most G. For this class of circuits, consider-
ing Hyrax’s cost analysis combined with the costs of PolyCom commitment and CPpoly, we have
that in HyrPoly: the veriﬁer runs in time O(|x| + |y| + dG + λd log(N G)) and proofs have length
O(λd log(N G)).
j=1 R(cid:48)(uj) can be modeled with an arith-
metic circuit C consisting of N copies of a circuit C(cid:48) that outputs 0 on uj iﬀ R(cid:48)(uj) holds.
j=1 R(cid:48)(u(cid:48)
j) where
each u(cid:48)
j is a subset of the entries of u, a corresponding circuit can be built by taking the parallel
C as for Rpar, and by adding one layer – called redistribution layer (RDL) in [WTs+18] – that
appropriately duplicates and redistributes wires from the input layer to the input wires of each C(cid:48)
It is easy to see that the relation Rpar((uj)j∈[N ]) :=(cid:86)N
If we instead consider a parallel relation with joint inputs, i.e., Rparjnt(u) :=(cid:86)N
63
Hyrax-Abstract.Setup(1λ) → ck :
ck ← PolyCom.Setup(1λ)
Hyrax-Abstract.Prove(ek, u) → π :
(c˜u, o˜u) ← ComPoly(ck, ˜u)
(πcore, qd, ζ) ← ZK-Gir++CoreP (ek, u)
y ← ˜u(qd); (cy, oy) ← ComVal(ck, y)
πeval ← CPpoly.Prove(ek, qd, (c˜u, cy), (˜u, y), (o˜u, oy))
πeq ← NIPoK-EqP (cy, ζ)
π ←(cid:0)c˜u, πcore, cy, πeval, πeq
(cid:1)
Hyrax-Abstract.KeyGen(ck) → (ek, vk) :
Hyrax-Abstract.VerProof(cid:0)vk, c˜u, πcore, cy, πeval, πeq
(ek, vk) ← CPpoly.KeyGen(ck)
(cid:1) :
(qd, ζ) ← ZK-Gir++CoreV (vk, πcore)
Run and test CheckCom(vk, c˜u) and CheckCom(vk, cy)
Run and test CPpoly.VerProof(vk, qd, c˜u, cy, πeval)
Run and test NIPoK-EqV (πeq, cy, ζ)
Accept if all tests above pass
Figure 17: Pseudocode for Hyrax-Abstract.
copy. In the case of using an RDL, the veriﬁer of Hyrax, and also in our HyrPoly scheme, incurs an
additional overhead in running time of the veriﬁer O(|x| + |u| + N G). Essentially, for this break of
parallelism the veriﬁer must pay a cost in the total width of the circuit.
For the sake of our experiments, we call HyrPoly-Par the HyrPoly scheme executed on fully
parallel circuits (no RDL), and we call HyrPoly-RDL the version of Hyrax − PolyCom executed with
circuits with an RDL.
G A CP-SNARK for Internal Products from Thaler’s Protocol
In this section we show how to modify the zk-vSQL protocol of [ZGK+17b] with a special class of
circuits that simply consist of a tree of multiplications. The basic idea is to replace the CMT protocol
over homomorphic commitment schemes proposed in [ZGK+17b] with an analogous version of the
protocol proposed by Thaler [Tha13] for the speciﬁc case of trees of multiplications. The advantage
of this encoding is to bring the prover runtime linear in the number of gates in the circuit.
We ﬁrst explain some preliminaries and then present this construction.
G.1 CMT Protocol
The CMT protocol [CMT12] is a variant of the GKR protocol [GKR08] where the prover runs in
time O(S log S), where S is the size of the circuit. This protocol provides a proof that an element
is the output of a circuit evaluated over a certain input. That is y = C(x), where C is a circuit of
depth d, x are the wires of layer d and y is claimed to be the output wire of the ﬁrst layer 0. In
short, the prover reduces recursively a claim on layer i to another claim on layer (i + 1), until he
obtains a publicly veriﬁable claim on the input. In order to do that, both prover and veriﬁer engage
in a sum-check protocol for each layer, using one polynomial representing the values of the wires in
layer i. Its multilinear extension links layer i (of size si) to layer (i + 1) by a summation of wiring
predicates as follows
˜βi(q, b) ·(cid:0)(cid:103)addi+1(l, r, b)·( ˜Vi+1(l) + ˜Vi+1(r)) +(cid:103)muli+1(l, r, b)· ˜Vi+1(l)· ˜Vi+1(r)(cid:1)
g(i)
q (b, r, l) :=
(cid:88)
(cid:88)
˜Vi(q) =
b∈{0,1}si
l,r∈{0,1}si+1
b∈{0,1}si
l,r∈{0,1}si+1
64
where ˜Vi returns the value of one gate, ˜βi(q, b) = q ?= b is a selector function, and(cid:103)opni(l, r, b) checks
whether the value of gate b at layer i is the result of an opn ∈ {add, mul} addition or multiplication
gate with l and r being its left and right inputs in the (i + 1)-th layer.
The standard version of the protocol suggests that for each layer of the circuit the veriﬁer has
to check two claims. This results in O(2d) calls to the sum-check protocol. However, an ingenious
technique shows how to use a single claim per layer using a line through both values. Then the
veriﬁer chooses one random point on which they perform a single sum-check invocation per layer,
resulting in O(d) calls.
G.2 Thaler’s Protocol for Trees of Multiplications
In [Tha13], Thaler proposes another variation of the CMT/GKR protocol [GKR08, CMT12] for some
speciﬁc classes of circuits, allowing for a logarithmic factor reduction in the prover’s runtime. One of
his protocols takes advantage of circuits where all gates perform the same operation, and whose wires
are settled in a binary tree structure. He denotes these regular circuits by trees of multiplications
or additions. This section only shows the notation of the former one due to its suitability for our
construction of CPsfprm. Nonetheless, moving to the addition case is straightforward.
The main diﬀerence that will be discussed here is a diﬀerent polynomial for sum-check, as well
as the notation of the wiring predicates. Thaler’s protocol assumes highly structured wiring in order
to reduce the number of arguments of the predicates. Namely, given a gate at layer i with label
b ∈ {0, 1}si, we assume its value is the result of a multiplication of gates of layer (i + 1) with labels
(b|0) ∈ {0, 1}si+1 and (b|1) ∈ {0, 1}si+1. This means, the number of inputs to the circuit is a power
of two and each layer has half the size of its preceding one. On this basis, the resulting polynomial
of each layer is much simpler as shown below:
(cid:88)
(cid:88)
˜Vi(q) =
g(i)
q (b) =
b∈{0,1}si
b∈{0,1}si
˜βi(q, b) · ˜Vi+1(b|0) · ˜Vi+1(b|1)
This tweak, together with a series of precomputations of ˜βi(q, b) and ˜Vi+1(b) values allows to obtain
a linear-time prover.
G.3 Adapting zk-vSQL to Thaler’s Protocol
Here we show how to change the CMT protocol over homomorphic commitments in [ZGK+17b,
Construction 3] in order to work with circuits that are a tree of multiplication gates using Thaler’s
representation [Tha13] to achieve faster prover runtime. From the point of view of security, this
modiﬁcation of [ZGK+17b, Construction 3] does not require any signiﬁcant change; essentially a
proof would be a rewrite of the one in [ZGK+17b]. The precise description of the protocol is however
interesting and therefore we give it for completeness in Figure 18.
Let C : Fm → F be a depth-d binary tree of multiplications such that C(y) = z represents the
i=1 yi where m is a power of two, and let ck ← Setup(1λ) be a commitment key
of a linearly homomorphic commitment scheme. The protocol in Figure 18 allows a prover P to
convince a veriﬁer V that C(y) = z with respect to y and z committed in {cyj}j∈{1...m} and cz.
operation z =(cid:81)m
As in [ZGK+17b], let CPeq (resp. CPprd) be a zero-knowledge argument of knowledge for testing
equality of two committed values (resp. the product relation between three commitments).
A Succinct Zero Knowledge Argument for Rprd. In Figure 19 we give the succinct version of
the protocol TTMCom presented in Figure 18. The protocol is almost identical to Construction 4 in
65
TTMCom :
1 : Common input: cvk ; r0 = 0 ; c0 := cz ; (cyj )j∈{1...m}
2 : P input: ck ; t0 := z ; o0 := oz ; y ; (oyj )j∈{1...m}
3 :
for i = 0 . . . d − 1 :
(cid:88)
Run Step 1 of Construction 2 [ZGK+17b] (sum-check over homomorphic commitments)
on the claim ti = Vi(ri) =
g(i)
ri (b)
b∈{0,1}si
At the end of Step 1, P and V hold r
i ∈ Fsi and commitment c
(cid:48)
(cid:48)
(cid:48)
i to t
i = g(i)
P : Claims that VerCommit(cvk, c
(cid:48)
(cid:48)
(cid:48)
i) = 1
i, o
i, t
(cid:48)
P : (cR, oR) ← ComVal(cid:0)ck, vR := ˜Vi+1(r
i|0)(cid:1) ; (cL, oL) ← ComVal(cid:0)ck, vL := ˜Vi+1(r
(cid:1)
i|1)(cid:1)
ri (r
(cid:48)
i)
∗
∗
(cid:48)
))(cid:1)
∗
), (oL, oR, o
)
∗
∗
∗
, o
); ((vL, vR, v
:= vL · vR
) ← ComVal(cid:0)ck, v
(cid:0)ck, (cL, cR, c
(cid:0)ck, (c
P : (c
∗
P → V : cR, cL, c
∗
P and V run CPprd
P : (c
i ) ← HomEval(cvk, ˜βi(ri, r
∗
∗
i , o
V : (c
i ,·) ← HomEval(cvk, ˜βi(ri, r
(cid:48)
∗
i), c
P and V run CPeq
(cid:48)
∗
(cid:48)
i, o
i, (o
i ); (t
P : Computes {(c(cid:96)j , o(cid:96)j ) ← ComVal(ck, (cid:96)j)}si+1
P → V : {c(cid:96)j}j∈{0...si+1}
P : c(cid:96)(0) ← c(cid:96)0
V : c(cid:96)(0) ← c(cid:96)0
P and V run CPeq
V → P : r
V : (ci+1,·)← HomEval(cid:0)ck, (1, r
i ←$ F and deﬁne ri+1 ← (r
(cid:48)(cid:48)
(cid:48)(cid:48)
(cid:48)(cid:48)
i , ..., r
i
(cid:48)
∗
i), c
, o
,·)
∗
∗
i ))(cid:1)
(cid:48)
i, c
(cid:48)(cid:48)
i )
4 :
5 :
6 :
7 :
8 :
9 :
10 :
11 :
12 :
13 :
14 :
15 :
16 :
17 :
18 :
19 :
20 :
21 :
j=0 where (cid:96)(ρ) = ˜Vi+1(r
i|ρ) for ρ ∈ F and {(cid:96)j}si+1
(cid:48)
j=0 its coeﬃcients
; (c(cid:96)(1), o(cid:96)(1)) ← HomEval(cvk, (1, . . . , 1),{c(cid:96)j , o(cid:96)j}j∈[0,si+1])