side defense can address this evasion. Moreover, note that
the attacker cannot induce such behavior on arbitrary ap-
plications — he can only exploit applications that already
perform extensive, non-standard transformations.
8. Employ second order attacks that operate by injecting
malicious parameters into links or forms contained in the
victim web page. An XSS attack would be eﬀected when
these forms are subsequently submitted. Note, however,
that XSSFilt will apply policies to these submissions as
well, and hence detect second (or higher order) order
attacks.
IE has an exception for same-origin links and
would be vulnerable to this attack.
7. EVALUATION AND COMPARISON
In this seciton, we evaluate and compare the protection
and compatibility oﬀered by XSSFilt, XSSAuditor and No-
Script. Our results demonstrate that the techniques used in
XSSFilt provide better compatibility as well as protection.
In addition, we provide data that shows the prevalence of
partial injection attacks.
7.1
Implementation
We implemented XSSFilt by modifying the Content Se-
curity Policies (CSPs) [23] implementation in Firefox. This
allowed us to leverage the CSP interface and code, which
include most of the required interposition callbacks.
CSPs implement the nsIContentSecurityPolicy inter-
face, which is only used to check the URL of external re-
sources being loaded, including scripts. We added a new
method permits to check inlined resources for XSS injec-
tions.
We modiﬁed the existing CSP callbacks to pass the script
content to permits where appropriate. We also added new
callbacks for Base elements and Data URLs, which CSPs do
not need to address for technical reasons.
To test NoScript, we downloaded the latest version (2.2.3)
and disabled all features except for XSS protection, which
we turned on for all requests.
To test XSSAuditor, we reimplemented it in Firefox to
avoid instrumenting a second browser. XSSFilt is based on
XSSAuditor’s architecture, so reimplementing its policies is
rather simple.
Dataset
xssed
cheatsheet
XSSFilt XSSAuditor NoScript
400/400
399/400
20/20
20/20
379/400
18/20
Dataset
xssed
cheatsheet
Partial Script Injection
16
2
String Transformation
5
0
Figure 3: Results for xssed and cheatsheet dataset
Figure 4: XSSAuditor failures
7.2 Protection Evaluation
We tested the three ﬁlters against two sources of XSS
attack data that have been widely used in previous research.
xssed: xssed.com [6] contains reports of websites vulnerable
to XSS, along with a URL for a sample attack. Since the
dataset is very large, we randomly selected a subset of 400
recent, working attacks among these in order to estimate
the eﬀectiveness of our ﬁlter against real-world attacks.
XSS cheatsheet: The xssed dataset is biased towards very
simple attack payloads, since most of them simply inject
a script tag. To assess the ﬁlter’s protection for more
complex attacks, we created a web page with multiple
XSS vulnerabilities and tried attack vectors from the XSS
Cheat Sheet [8], a well-known and oft-cited source for
XSS ﬁlter circumvention techniques.
To automatically test this large set of attacks, we modiﬁed
Firefox to log XSS violations to a ﬁle and used its extension
API to automatically navigate the browser to all URLs in
the two datasets.
Figure 3 summarizes the results for both datasets. XSS-
Filt successfully stopped all but one of the attacks from the
xssed dataset and all attacks from the cheatsheet dataset.
Its lone failure is attributed to a limitation of taint-inference
previously explained: when the web application applies ex-
tensive string transformations, the algorithm might fail to
ﬁnd a relationship between the parameter and the content.
In this speciﬁc example, the ﬁlter failed because the param-
eter:
alert ( " HaCkEd By N2n - HaCkEr
3 r d @ l i v e " );
-
was transformed to
alert ( " HaCkEd N2n - HaCkEr 3 r d @ l i v e " );
by the web application. Some (but not all) spaces and dashes
had been deleted, along with the word “By”. In these sit-
uations, no client-side ﬁlter can realistically be expectd to
detect the attack.
The 100% coverage on the cheatsheet dataset is not sur-
these attacks are designed to bypass server-side
prising:
sanitization functions, which look for speciﬁc patterns in
text and are vulnerable to browser quirks and unusual XSS
vectors. Since this ﬁlter architecture is immune to browser
quirks and covers all vectors uniformly, none of these attacks
succeeded.
XSSAuditor missed several attacks in these datasets. Fig-
ure 4 identiﬁes the underlying causes:
Partial Script Injection: XSSAuditor does not detect this
type of attack because, unlike XSSFilt, it does not per-
form URL parsing and substring matching.
String Transformation: XSSAuditor relies on canonical-
ization to account for common string transformations in
web applications. This approach can break when an un-
common transformation takes place. Taint-inference re-
lies on approximate substring matching, which is more
tolerant of exceptions.
ditor over the xssed dataset is 95% vs 99.75% for XSSFilt.
However, the xssed dataset is biased towards simple vulner-
abilities that inject a script tag, and a 4% prevalence of
partial script injections does not necessarily imply that this
is the case for XSS vulnerabilities in general.
NoScript’s XSS ﬁlter did well against both datasets. The
reason is that, unlike XSSAuditor and XSSFilt, NoScript
speciﬁcally looks for JavaScript syntax and common Java-
Script functions such as alert. Since most attacks on xssed
simply attempt to open a script tag and popup an alert
box, it is clear that NoScript should have no trouble in de-
tecting them. Even though considerable skills and eﬀorts
may be required to transform the payload until it bypasses
the ﬁlter, it has been shown to be possible [22, 16]. In our
own experiments, we were able to bypass the ﬁlter in some
cases by substituting the alert call with another JavaScript
identiﬁer. Had the web application bound that identiﬁer to
a suitable function, we could have carried out a successful
XSS attack.
7.3 Partial Injection Prevalence
Compared to XSSAuditor, XSSFilt is able to detect par-
tial script injection vulnerabilities. Therefore, it is impor-
tant to assess how prevalent these are. To estimate their
prevalence, we used three diﬀerent methods.
7.3.1 Partial Injections in xssed.com Data Set
Out of 400 real-world live XSS attacks, 4% were targeting
partial injection vulnerabilities. We analyzed the rest of the
vulnerable pages attacked through whole script injections to
discover if they contained partial injection vulnerabilities as
well, and we discovered that an additional 4% of pages are
vulnerable, for a total of 8% of pages vulnerable to partial
script injection.
Thus, even though the coverage against attacks on the
xssed dataset for XSSAuditor was 95%, the actual cover-
age on vulnerabilities is lower at 91%. However, the size of
this dataset is quite limited for the purpose of extrapolating
statitics about the nature of XSS attacks in general. More-
over, the website does not review submissions and does not
reward contributors for creative or complex attacks. For this
reason, the dataset is biased towards simple vulnerabilities
that can be discovered automatically.
7.3.2 Partial Injection Vulnerabilities in the Wild
We have developed a tool/scanner called gD0rk [18] to
study the prevalence of XSS vulnerabilities in deployed sites.
Although gD0rk was not developed for the purpose of this
paper, we believe that it is very helpful for assessing the
prevalence of partial injection vulnerabilities:
• gD0rk analyzed a much larger collection of web sites
as compared to xssed.com data, and hence provides a
broader basis for drawing inferences about vulnerabilities
in deployed sites.
• gD0rk uses a mechanical procedure for ﬁnding vulnera-
The results report that the protection oﬀered by XSSAu-
bilities, with no built-in bias for partial injections.
We note that, due to the nature of reﬂected XSS attacks,
we are targeting ourselves in these attacks, and hence be-
lieve that the web sites scanned by gD0rk were in no way
subjected to any harm.
gD0rk uses Google’s advanced search capabilities to short
list candidate web sites that are likely to be vulnerable,
probes them for reﬂected content by modifying the URL,
and examines the context in which the content is injected
in the web pages returned to build an attack. The exact
details of the tool are not important for the purposes of this
paper, but we do want to note that it is sophisticated enough
to detect and circumvent many sanitizations performed by
web applications where possible. For example, if a reﬂection
is inside a JavaScript string in a script tag, the scanner
attempts to write
" ; payload (); //
through the ﬁlter to exploit the partial injection vulnerabil-
ity. However, if the application sanitizes double quotes, the
scanner attempts to close the script tag instead and open a
new script node with
We describe an example from this dataset that contains a
partial injection vulnerability. The server-side code for this
page can be abstracted as:
  " ;
...
- - > 
The scanner detects that the sanitization function trans-
forms %22 into double quotes, and derives the following string
for an XSS attack:
\%22; alert (1); //
We ran gD0rk for one month and identiﬁed 272,051 vul-
nerable websites. For scalability and performance reasons,
we did not validate the generated attacks for all these vulner-
abilities. Instead, we used statistical sampling to estimate
the fraction of these sites that were actually vulnerable. In
particular, a random subset of 1000 vulnerabilities among
these were selected, and then we were able to verify that
98% of the generated attacks worked on this subset. We
then selected a random subset of 10000 vulnerable websites
and used the scanner to identify the context of the vulnera-
ble reﬂections. We found that 18% of these reﬂections were
included within script tags or event handlers, and thus rep-
resent partial script injection vulnerabilities.
7.3.3 Dynamically Generated Scripts
Intuitively, the necessary requirement for a partial injec-
tion vulnerability is a script that is assembled dynamically
from input parameters by the web application. We believe
that it is reasonable to expect developers to fail to sani-
tize parameters which appear inside scripts just as often as
they fail to sanitize them anywhere else in the page. Un-
der this hyphothesis, the rate of pages that construct scripts
dynamically is a good estimator for the ratio of partial injec-
tion vulnerabilities to whole script injection vulnerabilities.
The beneﬁt of this indirect approach over the previous one is
that the dataset is not made out of vulnerable pages, which
represents a skewed sample from mostly unpopular websites.
For this reason, we built a browser-resident crawler for
Firefox and bootstrapped it with the 1000 most popular
websites according to the Alexa rankings. When the crawler
processes a page with non-trivial HTTP parameters and de-
tects that a parameter appears in a script, it substitutes the
parameter value with a placeholder, requests the page with
the newly constructed URL and then attempts to ﬁnd the
original value and the new placeholder in the response. If
the placeholder is found in the same script and the original
parameter value is not found, then the relationship between
script and parameter is conﬁrmed and the page is marked as
containing a dynamic script. When we stopped the crawler,
it had crawled a total of 35145 pages, of which 9% contained
dynamically generated scripts. Given the strictness of the
requirements, we believe this is a conservative estimate.
7.4 Compatibility Evaluation
Browser-resident reﬂected XSS defenses restrict the ca-
pabilities of browsers with respect to content found in in-
put parameters, such as GET parameters from the querys-
tring. As a result, they have the potential to break some web
pages, and thus lead to compatibility problems. To estimate
the compatibility of these defenses, we instrumented Fire-
fox to log information about XSS checks while performing
the aforementioned crawl on major websites. The browser-
resident crawler was developed using the new Addon-SDK
[14] for Firefox. This allowed us not only to support discov-
ery of dynamically constructed links and forms, but also to
check all the resources loaded by the web page (including
scripts and advertisements inserted through DOM manipu-
lation) for XSS violations.
Overall, all ﬁlters reported very few false positives. This
is due to the benign nature of the dataset, which contains
very few special characters to begin with: only 26 URLs
contained any of the characters in the following set: {”,’,<}.
However, not all ﬁlters performed equally:
• NoScript’s 15 false positives are complex URLs contain-
ing long identiﬁers that erroneously match NoScript reg-
ular expressions. For example: the following (simpliﬁed)
URL triggers a violation:
http://domain.com/dir/page.php?
n=PHNjcmlwdP25plJmo9MCI%2BPC9zY3JpcHQ%2B&
h=55e1652a183.
An interesting property of NoScript’s XSS ﬁlter is that
if a parameter triggers a false positive in one web ap-
plication, it will do so in every other web application,
because the actual HTTP response does not matter. For
this reason, when we devised the heuristics to ﬁll and
submit forms, we chose not to submit suspicious strings
that would trigger XSS violations on every web applica-
tion. Had we conﬁgured the crawler to ﬁll forms with
values such as alert(1), NoScript would have triggered
many more policy violations.
• XSSFilt initially reported a much higher number of false
positives than NoScript. Most of them were either due
to a URL being supplied as a parameter and then used
by an existing script to construct a new script tag (for
advertisements), or by a parameter being passed to a
string-to-code function such as eval. These practices
would be safe if the application code checked the value
against a whitelist of pre-approved URLs for the former
case or JavaScript snippets for the latter, and the viola-
tion could be indeed considered spurious. However, we
found that out of 51 XSSFilt notiﬁcations, only 8 did
Filter
# of violations
XSSFilt XSSAuditor NoScript
15
8
6
Figure 5: Compatibility Comparison
such checks; the remaining violations were in fact due to
vulnerable pages that could be subverted to load a script
from an arbitrary host or execute arbitrary code. This
set of pages include important websites such as wsj.com,
weather.com and tripadvisor.com. For this reason, we
do not consider these scenarios as false positives.
• XSSAuditor behaved similarly to XSSFilt, reporting the
same vulnerable pages as XSS violations. We disconted
them from XSSAuditor results as well. A couple of ac-
tual false positives produced by XSSFilt involving partial