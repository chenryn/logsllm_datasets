trusted
system processes (e.g., svchost.exe) or applications with
valuable user information (e.g., Web Browser). Some well-
known code injection techniques include remote thread in-
jection, reﬂective DLL injection [47], portable executable
injection, and recently discovered process hollowing [13] and
shim-based DLL injection [2].
Script-based Attacks. Attackers can embed scripts in benign
documents like Microsoft Ofﬁce documents to run their mali-
cious payload. Worse, the Windows system opens access to its
core functionalities via various language interfaces (e.g., Pow-
erShell and .Net) that an attacker could take advantage of. Such
dynamic languages facilitate execution of a malicious logic on-
the-ﬂy, leaving little or no footprints on the ﬁlesystem.
Vulnerability Exploits.
The third way is to take advantages
of the vulnerabilities of a benign software. For example, CVE-
2019-0541 [23] allows adversaries to execute arbitrary code in
Internet Explorer (IE) through a specially crafted web page.
In Figure 1, we show the kill chain of a real-world DDE1
(Dynamic Data Exchange) script-based attack, which launches
several stages of PowerShell scripts in memory, reported by the
Juniper Threat Labs [5]. The attack starts from an email phish-
ing campaign which includes a seemly benign Microsoft Word
(MS Word) document as an attachment. When a user opens
the document, a message box is shown to enable DDE. Once
the DDE is enabled, the embedded DDEAUTO command invokes
cmd.exe, which executes powershell.exe to download and
execute a PowerShell script (0.ps1) using Dropbox service.
The 0.ps1 script then introduces the next PowerShell module
1The Dynamic Data Exchange (DDE) is a protocol of Microsoft Windows
for sharing data between applications.
3
Phishing Emaildownload & openWord Fileinvokecmd.exeinvokeexecute 0.ps1download0.ps1downloadEmpireexecute Empirepowershell.exepowershell.exeAttacker Servery.y.y.y:443Empire  BackdoorC&CDropbox Serverx.x.x.xTABLE I: The system entities and their relations we consider.
Src
Entity
Process
Dst
Entity
Process
File
Socket
Attributes
Relations
Executable path, Pid, Host name
File path, Host name
Src IP, Src port, Dst IP, Dst port
Start, End
Read, Write, Execute
Read, Write
(a) The provenance graph of a benign instance of MS Word.
(b) The provenance graph of a malicious instance of MS Word.
Fig. 2: An illustration of the behavior differences of a benign
process instance and a malicious process instance of MS Word
(winword.exe) using provenance graphs.
ﬁles. However, it starts a cmd.exe process, which further
spawns several powershell.exe processes. This behavior is
very different from that of the benign one.
Once these process behaviors are represented as prove-
nance graphs, these attack paths become very distinguishable
from benign ones. Therefore, provenance tracking and analysis
is a key technique to detect stealthy attacks. On the other
hand, as shown in Figure 2b, since stealthy attacks take
advantages of processes already running in the system, their
malicious behaviors could be hidden in benign behaviors of
the processes. Moreover, to make the attacks stealthy, malware
could mimic and blend in existing benign behaviors. Thus,
it is a main challenge to accurately capture the robust and
stable features from provenance graphs that can effectively
differentiate malicious behaviors from benign ones.
III. THREAT MODEL AND ASSUMPTIONS
In this paper, we focus on stealthy malware (or stealthy
attack) that impersonates or abuses legitimate tools or services
already present on the victim’s host or exploits trusted off-
the-shell applications (e.g., applications in the whitelist of an
enterprise’s intrusion detection system) to perform malicious
activities. As discussed in §II-A, such attacks could conduct
extremely damaging activities such as exﬁltrating sensitive
data, crippling computers, or allowing remote access. Exploit-
ing legitimate tools or applications enable those attacks to
do their malicious activities while blending in with normal
system behavior and leaving fewer footprints, which makes
their detection very difﬁcult. Such stealthy attacks can be
achieved through:
• Impersonation techniques such as memory code injec-
tion, script-based attacks and vulnerability exploits as
described in §II-A.
4
• A malicious version of a trusted application accidentally
installed by the user with attack payloads embedded.
Traditional malware that needs to drop a custom built malware
binary to the victim’s machine to execute its payload is out
of our scope. We make the following assumptions about our
system. Similar with existing provenance-based systems [56],
[73], [30], [74], [89], [55], we assume the underlying OS
and the provenance tracker are in our trusted computing base
(TCB). We assume the attacker cannot manipulate or delete the
provenance record, i.e., log integrity is maintained at all time.
Log integrity violation detection is an orthogonal problem and
has existing solutions [82]. We also do not consider the attacks
performed using implicit ﬂows (side channels) that bypass
the system call interface and thus cannot be captured by the
underlying provenance tracker. Finally, since our system tries
to differentiate benign process instances from malicious ones,
we assume that our system has benign provenance data for
each monitored program to proﬁle its normal behaviors.
IV. PROBLEM DEFINITION AND BASIC ASSUMPTIONS
In this section, we formally deﬁne several concepts that
will be used in the rest of this paper and then we formulate
the problem statement for PROVDETECTOR.
A. Deﬁnitions
System Entity and System Event.
Similar with [56], [39],
[43], we consider the following three types of system entities:
processes, ﬁles and network connections (i.e., sockets). A
system event e = (src, dst, rel, time) models the interaction
between two system entities, where src is the source entity,
dst is the destination entity, rel is the relation between them
(e.g., a process writes a ﬁle), and time is the timestamp when
the event happened. Note that, only the process entity can
be the source entity in a system event. Each system entity is
associated with a set of attributes. For example, a process entity
has attributes like its pid and the executable path. In Table I,
we show the entity attributes and relations we consider.
System Provenance Graph. Given a process p (identiﬁed by
its process id and host) in the system, the system provenance
graph (or dependency graph) of p is the graph that contains all
the system entities that have control dependencies (i.e., start or
end) or data dependencies (i.e., read or write) to p. Formally,
the provenance graph of p is deﬁned as G(p) =,
where V and E are the sets of vertexes and edges respectively.
Vertexes V are system entities and edges E are system events.
Process Instance. We refer a program (or an application) we
are interested in monitoring as a program. For example, some
trusted applications like MS Word. A process is an execution
of a program. A process instance of a program is the process
created in one execution of the program.
winword.exe*.doc*.txt*.png168.x.x.xoutlook.exeoutlook.exe*.dat*.cssiexplore.exe.........winword.exe*.doc*.tmp*.dat*.csscmd.exepower-shell.exepower-shell.exepower-shell.exex.x.x.xy.y.y.y:443B. Problem Statement
Suppose we have a set of n provenance graphs s =
{G1, G2, . . . , Gn} for n benign process instances of a program
A. Given a new process instance p of A, we aim to detect if
its provenance graph G(p) is benign or malicious. Here and
hereafter, we refer to a malicious process instance of A as
the process hijacked or abused by a stealthy malware. The
provenance graph of the malicious process is thus referred to
as a malicious provenance graph.
V. PROVDETECTOR
In this section, we detail the design and implementation of
PROVDETECTOR.
A. Overview
To detect stealthy malware, we make the following design
decisions about PROVDETECTOR:
• PROVDETECTOR is an anomaly detection based tech-
nique that only learns from benign data.
• PROVDETECTOR uses causal paths,
i.e., ordered se-
in
• PROVDETECTOR only learns a subset of causal paths of
quences of system events with causal dependency,
provenance graphs as features for detection.
a provenance graph.
it
We design PROVDETECTOR as an anomaly detection based
technique [81] for two reasons: ﬁrst,
is able to detect
unknown attacks (as well as zero-day attacks) as it models the
normal operation of a system; second, as the normal proﬁles
are tailored for every application or system, it is very difﬁcult
for an attacker to know what activities he can carry out to evade
detection. PROVDETECTOR uses causal paths as features to
distinguish the malicious part of the provenance data from the
benign part. As shown in §VI, this decision helps PROVDE-
TECTOR improve the detection performance. PROVDETECTOR
selects a subset of causal paths from a provenance graph to
address the dependency explosion problem [70], [74] and to
accelerate the speed of both training and detection.
In Figure 3, we show the workﬂow of PROVDETECTOR
which comprises four stages: graph building, representation ex-
traction, embedding, and anomaly detection. PROVDETECTOR
is conﬁgured to monitor a list of M programs (e.g., Microsoft
Word or Internet Explorer) and detect if they are hijacked
by stealthy malware. To do this, PROVDETECTOR deploys
a monitoring agent on each monitored host, collects system
provenance data as we deﬁned in §IV-A, and stores the data
in a centralized database. PROVDETECTOR’s data collection
follows the same principles as previous work [56], [73]. Then,
PROVDETECTOR periodically scans the database and checks if
any of the newly added processes has been hijacked. For each
given process, PROVDETECTOR ﬁrst builds its provenance
graph (Stage: Graph Building). Then it selects a subset of paths
from the provenance graph (Stage: Representation Extraction)
and converts the paths into numerical vectors (Stage: Em-
bedding). After that, PROVDETECTOR uses a novelty/outlier
detector to get predictions for the embedding vectors and
reports its ﬁnal decision (i.e., if the process has been hijacked)
(Stage: Anomaly Detection).
5
PROVDETECTOR has two modes: the training mode and
the detection mode. The workﬂow of the detection mode
is described above. The workﬂow of the training mode is
similar. The only difference is that instead of querying the
novelty/outlier detector, PROVDETECTOR uses the embedding
vectors to train the detector (i.e., building the normal proﬁles
for the applications). Next, we present each stage in detail.
B. Provenance Graph Building
Given a process instance p (identiﬁed by its process id and
host), PROVDETECTOR builds its provenance graph G(p) = as a labeled temporal graph using the data stored in the
database. As deﬁned in §IV-A, the nodes V are system entities
whose labels are their attributes, and E are edges whose labels
are relations and timestamps. Each node in V belongs to
one of the following three types: processes, ﬁles or sockets.
We deﬁne each edge e in E as e = {src, dst, rel, time}.
The construction of a provenance graph G(p) starts from
v == p. Then we add any edge e and its source node src and
destination node dst to the graph if e.src ∈ V or e.dst ∈ V .
C. Representation Extraction
After the provenance graph is built, the next step is repre-
sentation extraction, the goal of which is to ﬁnd representations
(or features) from the graph to differentiate benign ones and
malicious ones. One naive approach is to use the provenance
graph itself as the representation. However, as the discussions
in §II-C and §VI-C2, the whole provenance graph is not a good
representation for detecting stealthy malware as the majority
parts of the graph are still benign (the attacks try to blend their
attack activities with the normal activities to evade detection).
To isolate the malicious parts from the whole provenance
graph, we propose to select certain causal paths as the features
for the graph. In Figure 4, we show some causal paths from the
provenance graphs in Figure 2. Formally, we deﬁne a causal
path λ in a dependency graph G(p) as an ordered sequence
of system events (or edges) {e1, e2, . . . , en} in G(p), where
∀ei, ei+1 ∈ λ, ei.dst == ei+1.src and ei.time < ei+1.time.
Note that the time constraint is important since an event can
only be depended on events in the future. Due to the time
constraints, PROVDETECTOR will not generate inﬁnite number
of paths in loops. For each selected path, PROVDETECTOR
removes the host-speciﬁc or entity-speciﬁc features, such as
host name and process identiﬁcation (PID), from each node
and edge. This process ensures that the extracted representation
is general for the subsequent learning tasks.
1) Rareness-based Path Selection: Directly extracting all
paths from a provenance graph may cause the “dependency
explosion problem” [73]. The number of paths is exponential
to the number of nodes. Since a provenance graph may contain
thousands of nodes [73], it is impossible to traverse all its
paths. To address this problem, we propose a rareness-based
path selection method that only selects the K most uncommon
paths from a provenance graph.
Our intuition is as follows. A process instance of a program
may contain two types of workloads: the universal workload
and the instance-speciﬁc workload. The universal workloads
are common across all instances of the same program and are
thus less likely to be malicious. For example, the MS Word
Fig. 3: The overview of PROVDETECTOR
and OU T (v) are calculated using Equation 2 and Equation 3
respectively where |T (cid:48)
f rom| is the count of stable windows in
which no edge connects from v, |T (cid:48)
to| is the count of stable
windows in which no edge connects to v, and |T| is the total
number of windows.
|T (cid:48)
to|
|T|
OU T (v) =
(3)
IN (v) =
(2)
f rom|
|T (cid:48)
|T|
By deﬁning the regularity score, we formalize our path
selection problem as ﬁnding the top K paths with the lowest
regularity scores from a provenance graph. To efﬁciently solve
this problem, PROVDETECTOR further converts it to a K
longest path problem [25]. To do this, for a provenance graph
G, we add a pseudo source node vsource to all the nodes whose
in-degree are zero and a pseudo sink node vsink to all the
nodes whose out-degree are zero. This process converts G to
a single source and single sink ﬂow graph G(cid:48). We then assign a
distance to each edge e as W (e) = − log2 R(e) (the outgoing
edges of vsource and incoming edges of vsink are all uniformly
initialized to 1). Thus, the length of λ could be converted as
i=1 R(ei). Hence, the K
longest paths in G(cid:48) are the K paths with lowest regularity
scores in G.
L(λ) = (cid:80)n
i=1 W (ei) = − log2
(cid:81)n
Although solving the K longest path problem on a general
graph is an NP-hard problem, it could be efﬁciently solved
by reducing it to the K longest paths problem on a Directed
Acyclic Graph (DAG), which can be efﬁciently solved by the
Epstein’s algorithm [44] with a time complexity linear to the
number of nodes. To reduce our problem to the K longest
paths problem on a DAG, we convert G(cid:48) to a DAG. For each
node N in G(cid:48), PROVDETECTOR orders all its in-edges and
out-edges in the temporal order. Then N is split into a set of
nodes {n1, n2, n3, . . . , ni}. Any ni has the same attributes as
N but guarantees that all its in-edges are temporally earlier
than any of its out-edges. As PROVDETECTOR requires all
events on a causal graph are temporally ordered, splitting a
node based on the temporal orders of its in-edges and out-