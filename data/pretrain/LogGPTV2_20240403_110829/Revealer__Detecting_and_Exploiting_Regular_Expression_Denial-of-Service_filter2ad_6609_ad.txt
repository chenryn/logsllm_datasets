Therefore, we denote k·l′ as the maximum length of a matching
path of s, where k ≤ 3. When matching the attack string, the
engine backtracks at most an times, and each backtracking
takes at most k · l′ steps, thus the maximum matching step
count is k · l′ · anm, which shall be no less than γ to pass
the runtime validation. Therefore, we have k · l′ · anm ≥ γ,
and thus l′ · a⌊ lm
k . We get l′ ≤ 9 under the settings of
l′ ⌋ ≥ γ
a = 2, k = 3, and set l′
m as 9. We use the setting because other
cases (e.g., a regex has a complexity over 2n, or each character
needs more than three states to match) are rare. Besides, even
if a rare case occurs, only under specific conditions, it will
become a false negative (FN). For example, if there exists a
regex with 3n complexity, the result becomes l′ ≤ 16. It would
be a FN only if the common match string happens to have a
length 9 < l′ ≤ 16. In practice, we tried l′
m from 9 to 14, and
REVEALER reported the same number of true positives. So we
finalize our setting with l′
m = 9.
3:
4:
Algorithm 1 Dynamic Analysis: Getting a common match
string for each potential vulnerable pattern.
Input: P : a set of possible vulnerable patterns
Output: S: a set of vulnerable patterns with corresponding attack strings
1: S ← {}
2: for all p ∈ P do
r0, r1, r2 ⇐ p // Get the subexpressions of a vulnerable pattern p
T0 ⇐ r0, T1 ⇐ r1, T2 ⇐ r2 // Ti stores all matching paths with the
largest match string length l′
for all τ0 ∈ T0, τ1 ∈ T1, τ2 ∈ T2 do
m = 9 for a subexpression ri
end if
end for
S ← S ∪ {⟨p, s⟩}
break
s ← CommM atch(τ0, τ1, τ2)
if s ̸= ϵ then
5:
6:
7:
8:
9:
10:
11:
12: end for
13: return S
algorithm to take a lazy matching strategy by requiring the
matching count cv of a state v ∈ τ to be no more than cmin
(e.g., for a+ we need only one instance of a).
v
2) Suffix: A valid suffix has to cause the regex match to fail
on all possible matching paths. We first collect states where the
match of attack core s could possibly end in a set ES. We run
CommM atch with initial V = ES, but by generating rejecting
characters Π = Σ−{s[0] | s ∈ ASv′ ∧v′ = δ′
v(Sv, t)∧v ∈ V },
where Σ is the alphabet of symbols. Then we select a character
from Π as s′ to cause next matches of all possible paths to fail.
If Π = Φ, we let CommM atch match one state in a lazy way,
and continue the process until we find a character to make the
next matches fail.
3) Attack String: We combine the attack prefix s0, the
attack core s, and the attack suffix s1 under the format
s0.sk.s1 to generate the final attack string, where k =
⌊ lm−length(s0)−length(s1)
⌋.
length(s)
E. Validation
In this part, we use the original regex engine together with
an extra variable for counting matching steps to verify if the
attack string can trigger a ReDoS vulnerability. Inside the
original matcher in the Java 8 regex engine, there is a structure
called “Trace”, which records the log information generated
along the matching process. Its log size is the matching step
count. We break the matching process and report a successful
attack if matching step count exceeds the upper limit γ.
Even the dynamic analysis can find a valid attack core, the
final attack string might not trigger a ReDoS. For example,
the vulnerable pattern .*?tn=.*id=.* is for sure of polynomial
complexity, but its attack core tn=id= is relatively long. The
attack string generated cannot pass the validation in our
evaluation (§VI).
D. Generation
F. Limitations
With the attack core s generated in dynamic analysis, the
generation phase produces attack prefix s0 and attack suffix
s1 of a vulnerable pattern, to generate the final attack string.
We get prefix tail and suffix head from states v and w in a
vulnerable pattern ⟨v, w⟩ according to our definition in §IV-D.
1) Prefix: We use the SingM atch algorithm to generate
a match string for the path τ starting from v0 to the prefix
tail. To make the prefix as short as possible, we instruct the
The validation phase of REVEALER ensures it reports no
false positive. However, the choices of the thresholds in the
validation phase can have impact on the results, i.e., a case
may be considerred as either a true positive or a negative
under different attack string lengths and matching step count
thresholds. We demonstrate that in detail in §VI-A.
Further, REVEALER may have false negatives for the
following reasons. First, our definition of vulnerable patterns
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1475
in §IV-C may be incomplete. We tried our best to consider
all possible structural patterns. But the completeness of such
definition would need another work to prove. Second, although
e-NFA can describe all extended features, our prototype
implementation does not fully support them. It extracts the e-
NFA from the Java 8 regex engine, which cannot parse regexes
with conditionals. Further, it removes backreferences when
constructing E-TREE. A detailed discussion about extended
features is in §VI-C1. Third, our implementation of the end
state set ES may be incomplete. We only use state v, its next
state v′ through an inclusion transition, and its next state v′′
through a connection transition, i.e., ES = {v, v′, v′′}. Fourth,
we do not find attack cores that are longer than l′
m in our
dynamic analysis for targeting the most powerful attack strings
and for efficiency concerns. There might exist false negatives
of which the attack cores are longer than l′
m. Nevertheless,
such attack cores result in fewer rounds of backtracking.
VI. EVALUATION
In this section, we evaluate the effectiveness of REVEALER.
We first demonstrate that REVEALER is able to effectively
generate attack strings that help trigger and detect (unknown)
ReDoS vulnerabilities (§VI-B). We then characterize the
detected vulnerabilities (§VI-C), and validate the attacks with
regex engines of other languages (§VI-D). Finally, we apply it
to detect unknown ReDoS vulnerabilities in popular real-world
applications (§VI-E). We describe the experiment setup next.
A. Setup
To evaluate whether REVEALER is able to effectively detect
ReDoS vulnerabilities, we use the dataset—a collection of
29,088 regexes from three different sources—used in [30].
We compare REVEALER with the following three state-of-the-
art ReDoS vulnerability detection tools on the same dataset:
1) ReScue [30], a genetic fuzzing tool for detecting ReDoS
vulnerabilities; 2) RXXR2 [29], an improved version of the
static analysis tool RXXR [18] based on transition production;
and 3) Rexploiter [38], a static analysis tool based on vulnerable
structure identification. These tools were among the best
performing tools used in two recent works about ReDoS
vulnerability detection [11, 30]. Since the authors of [30] did
not disclose publicly their detected vulnerabilities, we cannot
directly compare with their results. We preprocess the regexes
for RXXR2 and Rexploiter according to their requirements.
We apply each tool for generating the corresponding prefix s0,
attack core s1 and suffix s2 to construct an attack string s in the
form s0.sk
1.s2 for validating a vulnerability. The experiments
are performed on a 20-core Intel Xeon server with 240 GB
RAM running Ubuntu 16.04.
We limit the length l of the generated attack string to be
less than 1288 by following the practice in [30]. Under such
a limited input length, it is hard to differentiate super-linear
complexity regexes from linear complexity ones by wall-clock
time. A super-linear complexity criteria was proposed in [11]
that a 10-second timeout shall be triggered with at most 85,615
pumps (100K-1M characters)9. We used REVEALER with this
large length limit to generate attack strings and found 2,172
TABLE I: Matching steps of super-linear regexes.
Range
Count
(1e3, 1e4]
393
(1e4, 1e5]
1,332
(1e5, 1e6]
94
(1e6, 1e7]
92
(1e7, 1e8]
25
(1e8, +∞)
236
TABLE II: The overall evaluation results.
Tool
REVEALER
ReScue
RXXR2
Rexploiter
# of Vul.
450
187
112
63
# of FP
0
0
103
1,959
Error Rate (%)
0.00
0.00
47.91
96.88
Avg. Time (s)
0.0076
18.2259
0.0042
0.4472
triggered the timeout. However, by reducing the limit to 128,
these vulnerable regexes can be matched in as low as only
0.159 second, which is even lower than the matching time of
many linear regexes. Therefore, we use matching step count
(also used in [30]) instead of wall-clock time as the metric for
validating an attack.
We conclude that a reported vulnerability is a true positive
if the matching step count is greater than the threshold γ. To
determine γ, we count the matching steps of those 2,172 verified
super-linear cases with a 128-character attack string length
limit and show in Table I. To include all severe vulnerabilities
that could cause a 10-minute timeout with 100 pumps, we
choose 105 as γ because there is one in the (1e5, 1e6] group as
discussed in §VI-B. However, this prevents REVEALER from
reporting more than 1,700 regexes as vulnerable under an attack
string not longer than 128 characters. Indeed, these 1,700+ cases
found by REVEALER can be exploited to cause a DoS if an
attacker uses a very long attack string according to the criteria
in [11].
We also measure the time each tool spends on analyzing
one regex. We found that ReScue can spend up to 12.49 hours
on analyzing one single regex without limitation in one round,
but its reported vulnerable regexes were all found within 250
seconds. Therefore, we set a time limit of 250 seconds per
regex for ReScue in our experiment. In three runs, it initially
found 174 true positives, which were fewer than reported in
[30]. We found using a larger time limit did not help much
and was time-consuming for analyzing all 29K regexes. We
instead focused on the additional ones found by other tools
with the 10-minute limit (as used in [30]), and finally detected
187 vulnerabilities in 20 rounds, which were even 1 more than
reported in [30]. We used the same 108 matching step threshold
as in [30] for ReScue because we found a smaller one would
result in a worse performance, which we will explain in §VI-B.
B. Results
The overall evaluation results are shown in Table II. In
total, the four tools detected 450 true positive regexes that are
vulnerable under ReDoS attacks. The numbers of vulnerabilities
reported by the three tools we compared are close to the ones
reported in [30]. Therefore, we believe our evaluation results are
valid. Note that the validation threshold we used is smaller than
that (108) in [30] as we allow ALL tools to report more super-
linear (and sub-exponential) time vulnerabilities. We draw a
Venn diagram based on the numbers of vulnerabilities detected
by the four tools in Figure 6.
8A larger limit lets ReScue run for longer time without improving its results.
9A pump represents one repetition of the attack core in the attack string.
REVEALER significantly outperformed all three state-of-the-
art tools. It could detect all 237 vulnerabilities that were found
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1476
TABLE III: Extended features supported by each tool. ✓ means the
feature is supported; × indicates the feature is not supported.
Extended Features
Unicode chars
Set operations
Lookarounds
Backreferences
Non-capturing groups
Named groups
Atomic groups
Conditionals
Greedy quantifiers
Lazy quantifiers
Possessive quantifiers
REVEALER
✓
✓
✓
×
✓
✓
✓
×
✓
✓
✓
ReScue RXXR2
×
×
×
✓
✓
×
×
×
✓
✓
×
✓
×
✓
✓
✓
✓
✓
×
✓
✓
✓
Rexploiter
✓
×
×
×
×