title:Practical Multi-party Private Set Intersection from Symmetric-Key
Techniques
author:Vladimir Kolesnikov and
Naor Matania and
Benny Pinkas and
Mike Rosulek and
Ni Trieu
Practical Multi-party Private Set Intersection from
Symmetric-Key Techniques
Vladimir Kolesnikov
Bell Labs
Murray Hill, New Jersey, USA
vladimir.kolesnikov@nokia-bell-labs.
com
Naor Matania
Bar-Ilan University
Tel Aviv, Israel
PI:EMAIL
Benny Pinkas
Bar-Ilan University
Tel Aviv, Israel
PI:EMAIL
Mike Rosulek
Oregon State University
Corvallis, Oregon, USA
PI:EMAIL
ABSTRACT
We present a new paradigm for multi-party private set intersection
(PSI) that allows n parties to compute the intersection of their
datasets without revealing any additional information. We explore
a variety of instantiations of this paradigm. Our protocols avoid
computationally expensive public-key operations and are secure
in the presence of any number of semi-honest participants (i.e.,
without an honest majority).
We demonstrate the practicality of our protocols with an imple-
mentation. To the best of our knowledge, this is the first implemen-
tation of a multi-party PSI protocol. For 5 parties with data-sets of
220 items each, our protocol requires only 72 seconds. In an opti-
mization achieving a slightly weaker variant of security (augmented
semi-honest model), the same task requires only 22 seconds.
The technical core of our protocol is oblivious evaluation of a
programmable pseudorandom function (OPPRF), which we instanti-
ate in three different ways. We believe our new OPPRF abstraction
and constructions may be of independent interest.
CCS CONCEPTS
‚Ä¢ Theory of computation ‚Üí Cryptographic protocols; ‚Ä¢ Secu-
rity and privacy ‚Üí Privacy protections; Cryptography; Symmetric
cryptography and hash functions;
KEYWORDS
Private Set Intersection; Oblivious PRF; Secure Multiparty Compu-
tation
1 INTRODUCTION
In the problem of private set intersection (PSI), several parties each
hold a set of items and wish to learn the intersection of these sets
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ‚Äô17, October 30-November 3, 2017, Dallas, TX, USA
¬© 2017 Association for Computing Machinery.
ACM ISBN 978-1-4503-4946-8/17/10...$15.00
https://doi.org/10.1145/3133956.3134065
Ni Trieu
Oregon State University
Corvallis, Oregon, USA
PI:EMAIL
and nothing else. Today, two-party PSI is a truly practical prim-
itive, with extremely fast cryptographically secure implementa-
tions [26, 38, 40]. Incredibly, these implementations are only a small
factor slower than the na√Øve and insecure method of exchanging
hashed values. Among the specific functions of interest in secure
multiparty computation (MPC), PSI is probably one of the most
strongly motivated by practice. Indeed, already today companies
such as Facebook routinely use PSI to share and mine shared in-
formation [34, 52]. In 2012, (at least some of) this sharing was
performed with insecure na√Øve hashing, where players send and
compare hashes of their set elements. Today, companies are able
and willing to tolerate a reasonable performance penalty, with the
goal of achieving stronger security [52]. We believe that the ubiq-
uity and the scale of private data sharing, and PSI in particular, will
continue to grow as big data becomes bigger and privacy becomes
a more recognized issue. We refer reader to [38‚Äì40] for additional
discussion and motivation of PSI.
In our work, we consider multi-party PSI in the semi-honest
model. By ‚Äúmulti-party‚Äù we refer to cases where more than two par-
ties wish to compute the intersection of their private data sets. This
is a natural generalization of the practically very useful two-party
PSI, creating opportunities for much richer data sharing than what
was possible with two-party PSI. Consider, for example, a scenario
where several organizations, e.g., Facebook, an advertiser, and a
third-party data provider, wish to combine their data to find a target
audience for an ad campaign. As another application, consider a
set of enterprises which have private audit logs of connections to
their corporate networks, and wish to identify similar activities in
all networks.
We note that the multi-party setting in secure computation is
notoriously difficult to tackle. Existing protocols in generic MPC,
such as garbled circuits, are significantly more complex and costly
in the multi-party case compared to the two-party case. Quite sur-
prisingly, each player in our protocols expend effort similar to that
in the two-party case.
1.1 State of the Art for Two-Party PSI
We focus on the discussion of the state-of-the-art of semi-honest PSI
protocols. We note that the earliest PSI protocols, based on Diffie-
Hellman assumptions, can be traced back to the 1980s [19, 30, 47],
and refer the reader to [39] for an overview of the many different
Session F1:  Private Set IntersectionCCS‚Äô17, October 30-November 3, 2017, Dallas, TX, USA1257protocol paradigms for PSI. Protocols based on oblivious transfer
extension have proven to be the fastest in practice. We note that
the OT-based protocols do not have the lowest communication cost.
In settings where computation is not a factor, but communication
is at a premium, the best protocols are in [5, 23, 41]. In the semi-
honest version of these protocols, each party sends only 2n group
elements, where n is the number of items in each set. However,
these protocols require a number of exponentiations proportional
to the number of items, making their performance slow in practice.
Concretely, [38] found Diffie-Hellman-based protocols to be over
200√ó slower than the OT-based ones.
Current state-of-the-art semi-honest PSI protocols in the two-
party setting are [26, 40]. They both use bucketing to reduce the
number of comparisons, and rely on oblivious PRF evaluation. Until
our work, these ideas were not used in PSI protocols for the multi-
party case.
Most work on concretely efficient PSI is in the random oracle
model, and with security against semi-honest, rather than malicious,
adversaries. Some notable exceptions are [12, 16, 20] in the standard
model, and [7, 8, 10, 12, 37, 44, 45] with security against malicious
adversaries.
Lastly, we note that there are efficient constructions for generic
MPC [2, 25, 27, 29, 32, 43, 49‚Äì51], which can be used for implement-
ing any functionality. In particular, these protocols can be used for
securely implementing PSI, in either the two-party or multi-party
settings. However, circuits for computing PSI are relatively large.
A natural circuit for two-party PSI performs ùí™(n
2) comparisons,
whereas more efficient circuits are of size ùí™(n log n) [18, 40]. How-
ever, as demonstrated in [40], secure evaluation of these circuits is
about two orders of magnitude slower than the most efficient PSI
protocols.
1.2 State of the Art for Multi-party PSI
A multi-party PSI protocol was first proposed by Freedman, Nissim,
and Pinkas [12]. The protocol of [12] is based on oblivious poly-
nomial evaluation (OPE) which is implemented using additively
homomorphic encryption, such as Paillier encryption scheme. The
basic idea is to represent a dataset as a polynomial whose roots are
its elements, and send homomorphic encryptions of the coefficients
of this protocol to obliviously evaluate it on the other party‚Äôs inputs.
Relying on the OPE technique, Kissner and Song [24] proposed a
multi-party PSI protocol with quadratic computation and commu-
nication complexity in both the size of dataset and the number
of parties. The computation overhead is reduced to be linear in
number of participants in [46], which was based on bilinear groups.
Furthermore, an efficient solution with quasi-linear complexity in
the size of dataset is proposed in [6]. In both [6, 46], the maximum
number of the corrupted parties are assumed to be n/2. Very recent
work [17] describes new protocols which run over a star network
topology, and are secure in the standard model against either semi-
honest or malicious adversaries. The basic idea is to designate one
party to run a version of the protocol of [12] with all other par-
ties. The main building block in [17] is an additively homomorphic
public-key encryption scheme, with threshold decryption, whose
key is mutually generated by the parties. The protocol requires com-
puting a linear number of encryptions and decryptions (namely,
exponentiations) in the input sets. In contrast, our main building
block is based on Oblivious Transfer extensions where the number
of exponentiations does not depend on the size of the dataset. [17]
does not include implementation, but we expect that our protocols
are much faster due to building from symmetric primitives. We de-
scribe the performance of representative multi-party PSI protocols
in the semi-honest settings in Table 1.
We mention that multi-party PSI was also investigated in the
server-aided model, based on the existence of a server which does
not collude with clients [1, 31]. Information-theoretic PSI protocols,
possible in the multi-party setting, are considered in [3, 28, 36].
1.3 Our Contributions
We design a modular approach for multi-party PSI that is secure
against an arbitrary number of colluding semi-honest parties. Our
approach can be instantiated in a number of ways providing trade-
offs for security guarantees and computation and communication
costs.
We implemented several instantiations of our PSI approach. To
our knowledge, this is the first implementation of multi-party PSI.
We find that multi-party PSI is practical, for sets with a million items
held by around 15 parties, and even for larger instances. The main
reason for our protocol‚Äôs high performance is its reliance on fast
symmetric-key primitives. This is in contrast with prior multi-party
PSI protocols, which require expensive public-key operations for
each item. Our implementation will be made available on GitHub.
Our PSI Approach. The main building block of our protocol,
which we believe to be of independent interest, is oblivious, pro-
grammable PRF (OPPRF). Recall, oblivious PRF (OPRF) is a 2-party
protocol in which the sender learns a PRF key k and the receiver
learns F(k, r), where F is a PRF and r is the receiver‚Äôs input. In
an OPPRF, the PRF F further allows the sender to ‚Äúprogram‚Äù the
output of F on a limited number of inputs. The receiver learns the
PRF output as before, but, importantly, does not learn whether his
input was one on which the PRF was programmed by the sender.
We propose three OPPRF constructions, with different tradeoffs in
communication, computation, and the number of points that can
be programmed.
. It holds thatn
Basic idea. Our PSI protocol consists of two major phases. First,
in the conditional zero-sharing phase, the parties collectively
and securely generate additive sharings of zero, as follows. Each
party Pi obtains, for each of its items xj, a share of zero, denoted
= 0. Namely, if all parties have xj in their
si
j
sets then the sum of their obtained shares is zero (else, w.h.p., the
sum is non-zero). In the second phase, parties perform conditional
reconstruction of their shares. The idea is for each Pi to program
an instance of OPPRF to output its share si
when evaluated on input
j
xj. Intuitively, if all parties evaluate the corresponding OPPRFs on
the same value xj, then the sum of the OPPRF outputs is zero. This
signals that xj is in the intersection. Otherwise, the shares sum to
a random value.
This brief overview ignores many important concerns ‚Äî in partic-
ular, how the parties coordinate shares and items without revealing
the identity of the items. We propose several ways to realize each
i =1 si
j
Session F1:  Private Set IntersectionCCS‚Äô17, October 30-November 3, 2017, Dallas, TX, USA1258Protocol
[24]
[6]
[17]
Ours
Client
Computation
Leader
Communication
Leader
Client
ùí™(tnm log(|X|))Œª
ùí™((n
m + nm)Œª)
2
ùí™(nmŒª) ùí™(mŒª) ùí™(mn log2(m)) ùí™(m)
ùí™(Œ∫)
ùí™(nmŒª) ùí™(mŒª)
ùí™(tŒ∫)
ùí™(mtŒª)
ùí™(ntm
2)
ùí™(nm + m)
ùí™(nŒ∫)
Corruption
Threshold
n ‚àí 1
‚åän/2‚åã
n ‚àí 1
n ‚àí 1
Security
Model
semi-honest
semi-honest
semi-honest
augmented semi-honest
semi-honest
Table 1: Communication (bits) and computation (number of exponentiations) complexities of multi-party PSI protocols in the
semi-honest setting, where n is number of parties, t dishonestly colluding, each with set size m; X is the domain of the ele-
ment; and Œª and Œ∫ are the statistical and computational security parameters, respectively. In our protocols, the computational
complexities are in an offline preprocessing phase.
of the two PSI phases, resulting in a suite of many possible instan-
tiations. We then discuss the strengths and weaknesses of different
instantiations.
A more detailed overview of the approach and the two phases is
presented in Section 5, prior to the presentation of the full protocol.
2 PRELIMINARIES
2.1 Secure Computation
The security of a secure multi-party protocol is formally defined
by comparing the distribution of the outputs of all parties in the
execution of the protocol œÄ to an ideal model where a trusted third
party is given the inputs from the parties, computes f and returns
the outputs. The idea is that if it is possible to simulate the view
of the adversary in the real execution of the protocol, given only
its view in the ideal model (when it only sees its input and output),
then the adversary cannot do in the real execution anything that is
impossible in the ideal model, and hence the protocol is said to be
secure.
We work in the multi-party setting where the corrupt parties
collude. This is modeled by considering a single monolithic adver-
sary that obtains the views of all corrupt parties. The protocol is
secure if the joint distribution of those views can be simulated.
Functionalities. We define a particular secure computation
task by formally describing the behavior of the ideal functionality
(trusted third party). The ideal functionality for multi-party PSI is
given in Figure 1.
Augmented semi-honest model. We present an optimized vari-
ant of our protocols that is in a slightly weaker security model. In
the augmented semi-honest model the adversary is allowed to
change the inputs of corrupted parties (but thereafter run the pro-
tocol honestly on those inputs).
In the specific case of multi-party PSI, this additional power is
relatively harmless. One can think of a multi-party PSI as computing
XH ‚à©XC, where XH is the intersection of all honest parties‚Äô sets and
XC is the intersection of all corrupt parties‚Äô sets. The augmented
semi-honest model simply allows an adversary to choose XC, rather
than being bound to whatever XC was chosen by the environment.
Without loss of generality, an augmented semi-honest adversary
can simply set all corrupt parties to have the same input set XC.
We note that the augmented semi-honest model is well known [14,
16] and was used in previous work on multi-party PSI and related
functionalities [12, 13]. We define and discuss this security notion
at length in Appendix A.
2.2 Cuckoo Hashing
We review the basics of Cuckoo hashing [35], specifically the vari-
ant of Cuckoo hashing that involves a stash [22]. In basic Cuckoo
hashing, there are m bins, a stash, and several random hash func-
tions h1, . . . , hk (often k = 2), each with range [m]. The invariant
is that any item x stored in the Cuckoo hash table is stored either
in the stash or (preferably) in one of the bins {h1(x), . . . , hk(x)}.
Each non-stash bin holds at most one item. To insert and element