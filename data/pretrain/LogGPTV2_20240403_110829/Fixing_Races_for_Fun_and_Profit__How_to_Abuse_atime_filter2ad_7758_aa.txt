title:Fixing Races for Fun and Profit: How to Abuse atime
author:Nikita Borisov and
Robert Johnson
Fixing Races for Fun and Proﬁt: How to abuse atime
Nikita Borisov
David Wagner
Rob Johnson
Naveen Sastry
University of California, Berkeley
{nikitab, rtjohnso, nks, daw}@cs.berkeley.edu
Abstract
Dean and Hu proposed a probabilistic countermeasure
to the classic access(2)/open(2) TOCTTOU race condi-
tion in privileged Unix programs [4]. In this paper, we
describe an attack that succeeds with very high proba-
bility against their countermeasure. We then consider a
stronger randomized variant of their defense and show
that it, too, is broken. We conclude that access(2) must
never be used in privileged Unix programs. The tools
we develop can be used to attack other ﬁlesystem races,
underscoring the importance of avoiding such races in
secure software.
1 Introduction
At USENIX Security 2004, Dean and Hu described a
probabilistic scheme for safely using the access(2) sys-
tem call in Unix systems [4]. The access(2) system call
is known to be vulnerable to Time Of Check To Time Of
Use (TOCTTOU) race attacks, and for this reason it has
fallen into almost complete disuse. This leaves Unix pro-
grammers without a portable, secure, and efﬁcient way
of checking a ﬁle’s permissions before opening it. Thus
Dean and Hu’s scheme would be a boon to systems pro-
grammers if it were secure. In this paper, we show that it
is not.
Dean and Hu’s scheme, which we call k-Race, thwarts
attackers by forcing them to win numerous races to suc-
cessfully attack the system. The strength of their scheme
rests on the assumption that an attacker has a low prob-
ability of winning each race, and hence an exponentially
low probability of winning all the races. Dean and Hu
identify two difﬁculties with winning repeated races: en-
suring that the attacker gets scheduled in time to win
each race, and staying synchronized with the victim over
many successive races. We develop three tools which
help us overcome these difﬁculties: ﬁlesystem mazes,
which greatly slow down ﬁlesystem operations of a vic-
OS
FreeBSD 4.10-PR2
Linux 2.6.8
Solaris 9
Attacker Wins / Trials
92/100
98/100
100/100
Table 1: Success rates of our attack against Dean
and Hu’s defense using the recommended security pa-
rameter, k = 7, on several platforms.
tim, system call synchronizers, and system call distin-
guishers. Using these tools, we can win races with ex-
tremely high probability, violating Dean and Hu’s as-
sumption. We use these tools to build an attack that
reliably breaks the k-Race algorithm using the recom-
mended parameter, and works on a variety of operating
systems. As shown in Table 1, our attack defeats the k-
Race algorithm over 90% of the time on every operating
system we tested.
Our attack remains successful even when the security
parameter is much larger than recommended by Dean
and Hu. We also consider a randomized extension of
the k-Race algorithm that makes non-deterministic se-
quences of calls to access(2), open(2), and fstat(2), and
show that it can be defeated as well. The tools we de-
velop for this attack are applicable to other Unix ﬁlesys-
tem race vulnerabilities, such as the stat(2)/open(2) race
common in insecure temporary ﬁle creation. We have
ported our attack code to several Unix variants and it suc-
ceeds on all of them. Our technique exploits the perfor-
mance disparity between disks and CPUs, so as this gap
grows our attack will become more powerful. This re-
futes Dean and Hu’s claim that as CPU speeds increase in
the future, the risk to systems using their defense would
decline.
Recent research in automated code auditing has dis-
covered over 40 TOCTTOU races in the Red Hat Linux
distribution [10]. This result, combined with our tech-
USENIX Association
14th USENIX Security Symposium
303
niques for exploiting race conditions, shows that races
are a prevalent and serious threat to system security.
In short, we show that the k-Race algorithm is inse-
cure, that Unix ﬁlesystem races are easy to win, and that
they will continue to be easy to win for the foreseeable
future. The rest of this paper is organized as follows. We
begin by reviewing setuid programs in Unix and the ac-
cess(2)/open(2) race. Section 3 presents Dean and Hu’s
countermeasure for preventing access(2)/open(2) races.
We then describe a simple attack on Dean and Hu’s
scheme in Section 4, and enhance this attack in Sec-
tion 5. Sections 6 and 7 describe a randomized gener-
alization of the k-Race algorithm, and an attack on that
scheme. Section 8 considers other defenses against the
access(2)/open(2) race. We consider related work in Sec-
tion 9, and summarize our contributions in Section 10.
2 The access(2)/open(2) race
The access(2) system call was introduced to address a
problem with setuid-root programs. The original Unix
authors invented the setuid mechanism to support con-
trolled sharing in Unix environments. A setuid program
runs with the permissions of the executable’s owner in-
stead of the invoker, enabling it to use private data ﬁles
that the program’s invoker cannot access. As a special
case, a setuid-root program can access any ﬁle on the
system, including the invoker’s personal ﬁles. This leads
to a classic confused deputy problem [6].
To see how the confused deputy problem arises, con-
sider a setuid-root printing program that prepares users’
ﬁles for printing and puts them onto the printing queue.1
The queue is not accessible to ordinary users, but the
setuid-root program can write to it. The program should
only let users print ﬁles that they themselves can access.
Unfortunately, since setuid-root programs have permis-
sion to read every ﬁle on the system, this implementation
does not have any easy way to determine whether the re-
quested input ﬁle is readable by the caller.
To solve this problem, Unix introduced the access(2)
system call. A setuid program can use the access(2) sys-
tem call to determine whether the invoker has the rights
needed to open a ﬁle. This solves the confused deputy
problem, but it also introduces a new security vulnera-
bility: Time Of Check To Time Of Use races [8]. The
vulnerability occurs because the return value from ac-
cess(2) tells us about the state of the ﬁlesystem at some
recent time in the past, but tells us nothing about what
the state will be when we next operate on the ﬁlesystem.
To illustrate the vulnerability, consider a typical setuid
program, which might call access(2) to check a ﬁle’s per-
1This example is inspired by an actual vulnerability in lpr
see https://www.redhat.com/archives/
in Red Hat,
redhat-watch-list/1999-October/msg00012.html.
// Victim (installed setuid-root)
void main (int argc, char **argv)
{
int fd;
if (access(argv[1], R OK) != 0)
exit(1);
fd = open(argv[1], O RDONLY);
// Do something with fd...
}
Figure 1: A setuid-root program vulnerable to the ac-
cess(2)/open(2) TOCTTOU race attack. An attacker may
be able to change the ﬁlesystem between the calls to ac-
cess(2) and open(2).
missions and then call open(2) to actually open the ﬁle
if the check succeeds, as shown in Figure 1. Unfortu-
nately, this code idiom is insecure. A clever attacker can
attempt to modify the ﬁlesystem (e.g. by changing sym-
bolic links) between the access(2) and open(2) system
calls so that when the setuid program calls access(2), the
given ﬁlename points to a safe, accessible ﬁle, but when
the setuid program calls open(2), the ﬁlename points to
a protected ﬁle. Thus, even if a setuid program uses ac-
cess(2), an attacker can still trick it into opening ﬁles that
it should not.
Figure 1 shows a typical setuid-root program that is
vulnerable to the access(2)/open(2) race, and Figure 2
shows a simple attack program that can trick the vic-
tim into opening /etc/shadow, a ﬁle that only root
can read. The attack is very timing dependent: the at-
tack program only succeeds if it manages to interrupt the
victim program between its access(2) call and open(2)
call. When this happens, the access(2) call succeeds
because, at that time, the path activedir/lnk re-
solves to a user-accessible ﬁle, public file. Af-
ter the victim calls access(2), it gets interrupted, and
the victim changes the symbolic link activedir to
point to dir1. When the victim resumes,
it calls
open(2) on activedir/lnk, which now resolves to
/etc/shadow. Since the victim is a setuid-root pro-
gram, the open(2) succeeds, but the victim believes that
it has opened a ﬁle accessible by the invoking user.
Notice that the attacker has a much better chance of
winning the race if dir0 is not currently in the buffer
cache. If that is the case, then the victim’s call to ac-
cess(2) will have to fetch the contents of dir0 from disk.
This I/O will put the victim to sleep, giving the attacker a
chance to run and switch the symbolic link activedir.
This observation is one of the key ideas behind our attack
on the k-Race defense.
304
14th USENIX Security Symposium
USENIX Association
// Attacker
void main (int argc, char **argv)
{
// Assumes directories and links:
// dir0/lnk -> public file
// dir1/lnk -> /etc/shadow
// activedir -> dir0
// Let the victim run
if (fork() == 0) {
system("victim activedir/lnk");
exit(0);
}
usleep(1); // yield CPU
// Switch where target points
unlink("activedir");
symlink("dir1", "activedir");
}
Figure 2: A program for exploiting access(2)/open(2)
races. A non-root attacker can use this program to ex-
ploit the setuid-root program shown in Figure 1.
3 The k-Race proposal
Dean and Hu noticed that, in practice, exploiting the ac-
cess(2) race condition can be quite difﬁcult. Their exper-
iments showed that a naive attacker can only expect to
win a race with probability 10−3 on uniprocessor ma-
chines and 10−1 on multiprocessor machines. Based
on this evidence, Dean and Hu proposed a probabilistic
countermeasure to this race condition. By requiring the
attacker to win a large number of races, they intended to
make it practically impossible to successfully exploit the
access(2)/open(2) race.
An implementation of their defense is given in Fig-
ure 3. The k-Race algorithm essentially repeats the ac-
cess(2)/open(2) idiom k times. To ensure that the at-
tacker must win a race between every system call, the k-
Race algorithm uses fstat(2) to check that every open(2)
call resolves to the same ﬁle. To see how this works, con-
sider an attacker trying to defeat k-Race. After the victim
makes the ﬁrst access(2) call, the attacker must switch
symlinks so that, when the victim calls open(2), the given
ﬁlename points to a protected ﬁle. After the ﬁrst call to
open(2), the attacker has tricked the victim into opening
a secret ﬁle, but the k-Race algorithm forces the attacker
to continue racing with the victim as follows. The vic-
tim next performs another call to access(2). The attacker
must race to switch the symlink to point to a public ﬁle,
or this access(2) call will not succeed. Next, the victim
calls open(2) again and uses fstat(2) to verify that the re-
int dh_access_open(char *fname)
{
int fd, rept_fd;
int orig_ino, orig_dev;
struct stat buffer;
if (access(fname, R_OK) != 0)
return -1;
fd = open(fname, O_RDONLY);
if (fd < 0)
return -1;
// This is the strengthening.
// *First, get the original inode.
if (fstat(fd, &buffer) != 0)
goto error;
orig_inode = buffer.st_ino;
orig_device = buffer.st_dev;
// Now, repeat the race.
// File must be the same each time.
for (i=0; i < k; i++) {
if (access(fname, R_OK) != 0)
goto error;
rept_fd = open(fname, O_RDONLY);
if (rept_fd < 0)
goto error;
if (fstat(rept_fd, &buffer) != 0)
goto error;
if (close(rept_fd) != 0)
goto error;
if (orig_inode != buffer.st_ino)
goto error;
if (orig_device != buffer.st_dev)
goto error;
/* If generation numbers are
available, do a similar check
for buffer.st_gen. */
}
return fd;
error:
close(fd);
close(rept_fd);
return -1;
}
Figure 3: Dean and Hu’s k-Race algorithm [4]. An at-
tacker must win 2k + 1 races to defeat this algorithm.
USENIX Association
14th USENIX Security Symposium
305
sulting ﬁle descriptor is a handle on the same ﬁle as the
result of the ﬁrst call to open(2). In order for this test
to succeed, the attacker must race to switch the symlinks