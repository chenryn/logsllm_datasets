ered that Outsourced1 escapes the − character, while
Outsourced2 does not. We also found that one of the
HTMLEncode implementations does not encode the sin-
gle quote character. Because the single quote charac-
ter can close HTML contexts, failure to encode it could
cause unexpected behavior for a web developer who uses
this implementation. For example, a recent attack on the
Google Analytics dashboard was enabled by failure to
sanitize a single quote [33].
This case study shows the beneﬁt of automatic analy-
sis of string manipulating functions to check equivalence.
Without BEK, obtaining this information using manual
inspection would be difﬁcult, error prone, and time con-
suming. With BEK, we spent roughly 3 days total trans-
lating from C# to BEK programs. Then BEK was able
to compute the contents of Figure 11 in less than one
minute, including all equivalence
and containment checks.
4.4 Checking Filters Against The Cheat Sheet
The Cross-Site Scripting Cheat Sheet (“XSS Cheat
Sheet”) is a regularly updated set of strings that trigger
JavaScript execution on commonly used web browsers.
These strings are specially crafted to cause popular web
browsers to execute JavaScript, while evading common
sanitization functions. Once we have translated a sani-
tizer to a program in BEK, because BEK uses symbolic
ﬁnite state transducers, we can take a “target” string and
determine whether there exists a string that when fed to
the sanitizer results in the target.
In other words, we
can check whether a string on the Cheat Sheet has a pre-
image under the function deﬁned by a BEK program.
We sampled 28 strings from the Cheat Sheet. The
Cheat Sheet shows snippets of HTML, but in practice a
sanitizer might be run only on a substring of the snip-
pet. We focused on the case where a sanitizer is run
on the HTML Attribute ﬁeld, extracting sub-strings from
the Cheat Sheet examples that correspond to the attribute
parsing context. While HTMLEncode should not be used
for sanitizing data that will become part of a URL at-
tribute, in practice programmers may accidentally use
HTMLEncode in this “incorrect” context. We also added
some strings speciﬁcally to check the handling of HTML
attribute parsing by our sanitizers. As a result, we ob-
tained two sets of attack strings: HTML and Attribute.
For each of our implementations, for all strings in
each set, we then asked BEK whether pre-images of that
string exist. Figure 12 shows what percentage of strings
have no pre-image under each implementation. All seven
implementations correctly escape angle brackets, so no
string in the HTML set has a pre-image under any of the
sanitizers. In the case of the Attribute strings, however,
we found that some of the implementations do not escape
the string“&#”, potentially yielding an attack. Only one
of our implementations of HTMLEncode made it impos-
sible for all of the strings in the Attribute set from ap-
pearing in its output. Each set of strings took between 36
and 39 seconds for BEK to check the entire set of strings
against a sanitizer.
Figure 13: Self-equivalence experiment.
Figure 14: Commutativity experiment.
4.5 Scalability of Equivalence Checking
4.6 From BEK to Other Languages
Our theoretical analysis suggests that
the speed of
queries to BEK should scale quadratically in the number
of states of the symbolic ﬁnite transducer. All sanitiz-
ers we have found in “the wild,” however, have a small
number of states. While this makes answering queries
about the sanitizers fast, it does not shed light on the em-
pirical performance of BEK as the number of states in-
creases. To address this, we performed two experiments
with synthetically generated symbolic ﬁnite transducers.
These transducers were specially created to exhibit some
of the structure observed in real sanitizers, yet have many
more states than observed in
practical sanitizer implementations.
Self-equivalence experiment. We generated symbolic
ﬁnite transducers A from randomly generated BEK pro-
grams having structure similar to typical sanitizers. The
time to check equivalence of A with itself is shown in
Figure 13 where the size is the number of states plus
the number of transitions in A. Although the worst case
complexity is quadratic, the actual observed complexity,
for a sample size of 1,000, is linear.
Commutativity experiment. We generated symbolic
ﬁnite transducers from randomly generated BEK pro-
grams having structure similar to typical santizers. For
each symbolic ﬁnite transducer A, we checked commu-
tativity with a small BEK program UpToLastDot that re-
turns a string up to the last dot character. The time to
determine that A ◦ UpToLastDot and UpToLastDot ◦ A
are equivalent is shown in Figure 14 where the size is the
total number of states plus the number of transitions in
A. The time to check non-equivalence was in most cases
only a few milliseconds, thus all experiments exclude the
data where the result is not equivalent, and only include
cases where the result is equivalent. Although the worst
case complexity is quadratic, the actual observed com-
plexity, over a sample size of 1,000
individual cases, was near-linear.
We have built compilers from BEK programs to com-
monly used languages. When the time comes for deploy-
ment, the developer can compile to the language of her
choice for inclusion into an application.
// orginal Bek program
program test0(t);
string s;
s := iter(c in t)
{b := false;} {
i
case ((c == ’a’)):
b := !(b) && b;
b := b || b;
b := !(b);
yield (c);
case (true) :
yield (’$’);
};
//
// JavaScript translation
//
function test0(t) {
var s
=
function ($){
var result = new Array();
for(i=0;i<$.length; i++){
var c = $[i];
if ((c == String.fromCharCode(97))) {
b = (!(b) && b);
b = (b || b);
b = !(b);
result.push(c);
}
if (t) {
result.push(String.fromCharCode(36));
}
};
return result.join(’’);
}
return s(t);
}
Figure 15: A small example BEK program (top) and its
compiled version in JavaScript (bottom). Note the use of
result.push instead of explicit array assignment.
Figure 15 shows a small example of a BEK program
and the result of its JavaScript compilation. As part of
the compilation, we have taken advantage of our knowl-
edge of properties of JavaScript to improve the speed of
the compiled code. For example, we push characters into
arrays instead of creating new string objects. The result
is standard JavaScript code that can be easily included in
any web application. By adding additional compilers for
common languages, such as C#, we can give a developer
multiple implementations of a sanitizer that are guaran-
teed to be equivalent for use in different contexts.
5 Related Work
SANER combines dynamic and static analysis to validate
sanitization functions in web applications [9]. SANER
creates ﬁnite state transducers for an over-approximation
of the strings accepted by the sanitizer using static anal-
ysis of existing PHP code. In contrast, our work focuses
on a simple language that is expressive enough to capture
existing sanitizers or write new ones by hand, but then
compile to symbolic ﬁnite state transducers that precisely
capture the sanitization function. SANER also treats the
issue of inputs that may be tainted by an adversary, which
is not in scope for our work. Our work also focuses on ef-
ﬁcient ways to compose sanitizers and combine the the-
ory of ﬁnite state transducers with SMT solvers, which
is not treated by SANER.
Minamide constructs a string analyzer for PHP code,
then uses this string analyzer to obtain context free gram-
mars that are over-approximations of the HTML output
by a server [26]. He shows how these grammars can
be used to ﬁnd pages with invalid HTML. The method
proposed in [21] can also be applied to string analysis
by modeling regular string analysis problems as higher-
order multi-parameter tree transducers (HMTTs) where
strings are represented as linear trees. While HMTTs al-
low encodings of ﬁnite transducers, arbitrary background
character theories are not directly expressibly in order to
encode SFTs. Our work treats issues of composition and
state explosion for ﬁnite state transducers by leveraging
recent progress in SMT solvers, which aids us in reason-
ing precisely about the transducers created by transfor-
mation of BEK programs and by avoiding state space ex-
plosion and bitblasting for large character domains such
as Unicode. Moreover, SMT solvers provide a method
of extracting concrete counterexamples.
Wasserman and Su also perform static analysis of
PHP code to construct a grammar capturing an over-
approximation of string values. Their application is to
SQL injection attacks, while our framework allows us to
ask questions about any sanitizer [36]. Follow-on work
combines this work with dynamic test input generation to
ﬁnd attacks on full PHP web applications [37]. Dynamic
analysis of PHP code, using a combination of symbolic
and concrete execution techniques, is implemented in the
Apollo tool [8]. The work in [39] describes a layered
static analysis algorithm for detecting security vulnera-
bilities in PHP code that is also enable to handle some
dynamic features. In contrast, our focus is speciﬁcally
on sanitizers instead of on full applications; we empha-
size analysis precision over scaling to large code bases.
Christensen et al.’s Java String Analyzer is a static
analysis package for deriving ﬁnite automata that charac-
terize an over-approximation of possible values for string
variables in Java [13]. The focus of their work is on an-
alyzing legacy Java code and on speed of analysis. In
contrast, we focus on precision of the analysis and on
constructing a speciﬁc language to capture sanitizers, as
well as on the integration with SMT solvers.
Our work is complementary to previous efforts in ex-
tending SMT solvers to understand the theory of strings.
HAMPI [20] and Kaluza [31] extend the STP solver to
handle equations over strings and equations with mul-
tiple variables. Rex extends the Z3 solver to handle
regular expression constraints [35], while Hooimeijer et
al.show how to solve subset constraints on regular lan-
guages [17]. We in contrast show how to combine any
of these solvers with ﬁnite transducers whose edges can
take symbolic values in any of the theories
supported by the solver.
The work in [28] introduces the ﬁrst symbolic ex-
tension of ﬁnite state transducers called a predicate-
augmented ﬁnite state transducer (pfst). A pfst has two
kinds of transitions: 1) p
ϕ/ψ
−→ q where ϕ and ψ are char-
acter predicates or ǫ, or 2) p
In the ﬁrst case
the symbolic transition corresponds to all concrete tran-
c/c
−→ q.
sitions p
a/b
−→ q such that ϕ(a) and ψ(b) are true, the
a/a
−→ q
second case corresponds to identity transitions p
for all characters a. A pfst is not expressive enough for
describing an SFT. Besides identities, it is not possible
to establish functional dependencies from input to out-
put that are needed for example to encode sanitizers such
as EncodeHtml.
A recent symbolic extension of ﬁnite transducers is
streaming transducers [6]. While the theoretical expres-
siveness of the language introduced in [6] exceeds that
of BEK, streaming transducers are restricted to charac-
ter theories that are total orders with no other operations.
Also, composition of streaming transducers requires an
explicit treatment of characters. It is an interesting future
research topic to investigate if there is an extension of
SFTs or a restriction of streaming transducers that allows
efﬁcient symbolic analysis techniques to be applied.
6 Conclusions
Much prior work in XSS prevention assumes the correct-
ness of sanitization functions. However, practical expe-
rience shows writing correct sanitizers is far from triv-
ial. This paper presents BEK, a language and a compiler
for writing, analyzing string manipulation routines, and
converting them to general-purpose languages. Our lan-
guage is expressive enough to capture real web sanitizers
used in ASP.NET, the Internet Explorer XSS Filter, and
the Google AutoEscape framework, which we demon-
strate by porting these sanitizers to BEK.
We have shown how the analyses supported by our
tool can ﬁnd security-critical bugs or check that such
bugs do not exist. To improve the end-user experience
when a bug is found, BEK produces a counter-example.
We discover that only 28.6% of our sanitizers commute,
∼79.1% are idempotent, and only 8% are reversibe. We
also demonstrate that most hand-written HTMLEncode
implementations disagree on at least some inputs. Un-
like previously published techniques, BEK deals equally
well with Unicode strings without creating a state ex-
plosion. Furthermore, we show that our algorithms for
equivalence checking and composition computation are
extremely fast in practice, scaling near-linearly with the
size of the symbolic ﬁnite transducer representation.
References
[1] About Safari 4.1 for Tiger. http://support.apple.com/kb/DL1045.
[2] Internet
Explorer
8:
Features.
http://www.microsoft.com/windows/internet-
explorer/features/safer.aspx.
[3] NoXSS Mozilla Firefox Extension. http://www.noxss.org/.
[4] OWASP: ESAPI project page. http://code.google.com/p/owasp-
esapi-java/.
[5] XSS
(Cross
Site
Scripting)
Cheat
Sheet.
http://ha.ckers.org/xss.html.
[6] R. Alur and P. Cern´y. Streaming transducers for algorithmic
veriﬁcation of single-pass list-processing programs. In Proceed-
ings of the Symposium on Princples of Programming Languages,
pages 599–610, 2011.
[7] Apple.
Jsdecode implementation, 2011.
http://trac.
webkit.org/browser/releases/Apple/Safari%205.0/
JavaScriptCore/runtime/JSGlobalObjectFunctions.
cpp.
[8] S. Artzi, A. Kie˙zun, J. Dolby, F. Tip, D. Dig, A. Paradkar, and
M. D. Ernst. Finding bugs in Web applications using dynamic
test generation and explicit-state model checking. Transactions
on Software Engineering, 99:474–494, 2010.
[9] D. Balzarotti, M. Cova, V. Felmetsger, N. Jovanovic, E. Kirda,
C. Kruegel, and G. Vigna. SANER: Composing static and dy-
namic analysis to validate sanitization in Web applications.
In
Proceedings of the Symposium on Security and Privacy, 2008.
[10] D. Bates, A. Barth, and C. Jackson. Regular expressions con-
sidered harmful in client-side XSS ﬁlters. In Proceedings of the
Conference on the World Wide Web, pages 91–100, 2010.
[11] N. Bjørner, N. Tillmann, and A. Voronkov. Path feasibility analy-
sis for string-manipulating programs. In Proceedings of the Inter-
national Conference on Tools And Algorithms For The Construc-
tion And Analysis Of Systems, 2009.
[12] C. Y. Cho, D. Babi´c, E. C. R. Shin, and D. Song. Inference and
analysis of formal models of botnet command and control proto-
cols. In Proceedings of the Conference on Computer and Com-
munications Security, pages 426–439, 2010.
[13] A. S. Christensen, A. Møller, and M. I. Schwartzbach. Precise
Analysis of String Expressions. In Proceedings of the Static Anal-
ysis Symposium, 2003.
[14] L. de Moura and N. Bjørner. Z3: An Efﬁcient SMT Solver. In
Proceedings of the International Conference on Tools And Algo-
rithms For The Construction And Analysis Of Systems, 2008.
[15] A. J. Demers, C. Keleman, and B. Reusch. On some decidable
properties of ﬁnite state translations. Acta Informatica, 17:349–
364, 1982.
[16] P. Hooimeijer. Decision procedures for string constraints. Ph.D.
Dissertation Proposal, University of Virginia, April 2010.
[17] P. Hooimeijer and W. Weimer. A decision procedure for subset
constraints over regular languages.
In Proceedings of the Con-
ference on Programming Language Design and Implementation,
pages 188–198, 2009.
[18] P. Hooimeijer and W. Weimer. Solving string constraints lazily. In
Proceedings of the International Conference on Automated Soft-
ware Engineering, 2010.
[19] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: a static analysis
tool for detecting Web application vulnerabilities (short paper).
In Proceedings of the Symposium on Security and Privacy, May
2006.
[20] A. Kiezun, V. Ganesh, P. J. Guo, P. Hooimeijer, and M. D. Ernst.
HAMPI: a solver for string constraints.
In Proceedings of the
International Symposium on Software Testing and Analysis, 2009.
[21] N. Kobayashi, N. Tabuchi, and H. Unno. Higher-order multi-
parameter tree transducers and recursion schemes for program
veriﬁcation.
In Proceedings of the Symposium on Principles of
Programming Languages, pages 495–508, 2010.
[22] D. Lindsay and E. V. Nava. Universal XSS via IE8’s XSS ﬁlters.
In Black Hat Europe, 2010.
[23] B. Livshits and M. S. Lam. Finding security errors in Java pro-
grams with static analysis. In Proceedings of the Usenix Security
Symposium, pages 271–286, Aug. 2005.
[24] B. Livshits, A. V. Nori, S. K. Rajamani, and A. Banerjee. Merlin:
Speciﬁcation inference for explicit information ﬂow problems. In
Proceedings of the Conference on Programming Language De-
sign and Implementation, June 2009.
[25] M. Martin, B. Livshits, and M. S. Lam. SecuriFly: Runtime
vulnerability protection for Web applications. Technical report,
Stanford University, Oct. 2006.
[26] Y. Minamide. Static approximation of dynamically generated
In Proceedings of the International Conference on
web pages.
the World Wide Web, pages 432–441, 2005.
[27] A. Nguyen-Tuong, S. Guarnieri, D. Greene, J. Shirley, and
D. Evans. Automatically hardening Web applications using pre-
cise tainting. In Proceedings of the IFIP International Informa-
tion Security Conference, June 2005.
[28] G. V. Noord and D. Gerdemann. Finite state transducers with
predicates and identities. Grammars, 4:2001, 2001.
[29] G. Rozenberg and A. Salomaa, editors. Handbook of Formal Lan-
guages, volume 1. Springer, 1997.
[30] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and
D. Song. A symbolic execution framework for JavaScript. Tech-
nical Report UCB/EECS-2010-26, EECS Department, University
of California, Berkeley, Mar 2010.
[31] P. Saxena, D. Akhawe, S. Hanna, S. McCamant, F. Mao, and
D. Song. A symbolic execution framework for JavaScript.
In
Proceedings of the IEEE Symposium on Security and Privacy,
2010.
[32] P. Saxena, D. Molnar, and B. Livshits. ScriptGard: Prevent-
ing script injection attacks in legacy Web applications with auto-
matic sanitization. Technical Report MSR-TR-2010-128, Micro-
soft Research, Sept. 2010.
[33] B.
Schmidt.
2011.
google-analytics-xss-vulnerability/.
vulnerability,
http://spareclockcycles.org/2011/02/03/
analytics XSS
Google
[34] M. Veanes, N. Bjørner, and L. de Moura. Symbolic automata
constraint solving.
In C. Ferm ¨uller and A. Voronkov, editors,
LPAR-17, volume 6397 of LNCS, pages 640–654. Springer, 2010.
Proceedings of the International Symposium on Software Testing
and Analysis, 2008.
[35] M. Veanes, P. de Halleux, and N. Tillmann. Rex: Symbolic Regu-
lar Expression Explorer. In Proceedings of the International Con-
ference on Software Testing, Veriﬁcation and Validation, 2010.
[36] G. Wassermann and Z. Su. Sound and precise analysis of Web
applications for injection vulnerabilities.
In Proceedings of the
Conference on Programming Language Design and Implementa-
tion, 2007.
[37] G. Wassermann, D. Yu, A. Chander, D. Dhurjati, H. Inamura, and
In
Z. Su. Dynamic test input generation for Web applications.
[38] J. Williams. Personal communications, 2005.
[39] Y. Xie and A. Aiken. Static detection of security vulnerabilities
In Proceedings of the Usenix Security
in scripting languages.
Symposium, pages 179–192, 2006.
[40] L. Yuan, J. Mai, Z. Su, H. Chen, C.-N. Chuah, and P. Mohapa-
tra. Fireman: A toolkit for ﬁrewall modeling and analysis.
In
Proceedings of the Symposium on Security and Privacy, pages
199–213, 2006.