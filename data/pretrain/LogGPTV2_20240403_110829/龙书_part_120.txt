（用于LD 和 ST运算）。假设除了LD 运算需要两个时钟周期之外，其余所有运算都只需要一个
力到另一个基本块的代码生成策略。同时考虑多个基本块的策略称为全局调度（global schedu-
假设变量α、b、c、d和e的地址互不相同，并且这些地址被分别存放在寄存器 R1～R5 中。
让我们首先通过一个简单的例子来研究--下指令移动可能涉及的问题。
2）虽然优化后的程序可以投机性地执行一些额外指令，但这些指令不能产生任何有害的副作用。
462
1）所有在原程序中执行的指令都会在优化后的程序中运行，并且
对于一个具有中等数量的指令并行机制的机器，通过压缩各个基本块而得到的调度方案往
3）假设有无限多个MEM 资源，对于这七条指令的所有可能的
2）
1）为图10-11中的代码画出数据依赖图。
练习10.3.4：使用例10.6中的机器模型（和练习10.3.2一
3）该机器具有两个 ALU 资源和两个 MEM资源。
2）
1）该机器具有一个 ALU 资源和两个 MEM 资源。
练习10.3.3：在如下假设下重复练习10.3.2。
对于问题(1)得到的数据依赖图，全部关键路径包括哪些？
假设我们有一个可以在单个时钟周期内同时执行任意两条指令的机器。除了加载运
该机器具有两个ALU资源和一个MEM资
C亿
9
6
2
R1，
图10-10练习10.3.1的机器代码
SS
22
b）
源
22
图10-11 练习10.3.4 的
23
一
机器代码
——
第10章
2
中
8
---
## Page 479
10.4.2向上的代码移动
10-12中的例子，假设 B是流图入口,且B是出口，则
一个不同的“支配关系”，因此关于何时以及如何在每一对基本块之间移动指令的考虑是不同的。
和单独执行基本块B, 所需的时间一样。
图 10-12c中显示了经过这样优化后的调度方案。优化后的代码在4个时钟周期内执行完毕，
基本块B2时才能执行这个保存运算。但是，我们可以把保存运算放在B，的一个拷贝中。
行一个保存运算。我们不能直接把 B2中的保存运算放到基本块 B中，因为只有当控制流经i
钟周期。
机性执行B2中的加载运算而不会产生任何附加开销，并且只要该分支执行，就可以节约两个时
(control equivalent），其含义是一个基本块会被执行当且仅当另一个基本块也会被执行。对于目
配
8
合
的运算移动到 B，因为需要它们来决定分支跳转的出口。
( postdominate)B'。当B支配 B'并且 B'反向支配 B 的时候，我们就说B 和 B'是控制等价é
，那么就认为B 支配 B'。类似地，如果从 B'到达流图出口处的路径都经过B，我们说 B 反向.
例10.9表明我们可以沿着一个执行路径上下移动指令。在这个例子中，每－-对基本块都7
保存运算不应该投机性地执行，因为它们覆写了某个内存位置上的原值。但是可以延迟执
指令级并行性
我们现在仔细考查把一个运算沿着一条路径向上移动意味着什么。假设我们希望把一个运
在一条路径上的一对基本块之间也可能既不具有支配关系，也不具有反向支配关系。
2）B, 支配 B2，但是 B2不反向支配 B。
1） B 和 B 是控制等价的；B; 支配 B, 而 B, 反向支配 B1。
B2中的运算和基本块 B，中的测试指令之间具有控制依赖关系。我们可以在基本块 B，中投
B2 不支配 B, 但是 B, 反向支配 B2。
if (a==0) goto L
a)源程序
L：
= d+d 
ST 0(R5),R8
图 10-12例10.9 中全局调度之前和之后的流图
ADD R8,R8,R8, BEQZ R6,L
66
R6,0(R1), LD R8,0(R4)
0(R2)
c)全局调度得到的机器代码
B3
L:
LD
b)局部调度得到的机器代码
R6,0(R1)
LD
0(R3),R7
R7,0(R2)
463
有
过
---
## Page 480
需要补偿代码。
面四种情况：
价以及实现复杂度各不相同。图10-13 中给出了这些代码移动方法的总结。图中的各行对应于下
src 之月
上都被执行了。这个转换仍然和部分冗余消除类似，不同之处在于运算的拷贝被放置在基本块
计算该断言的基本块所支配的基本块中，否则该断言的值会不可用。
我们
10.4.3向下的代码移动
被优化路径的执行频率高于其他未被优化的路径时，这个代码移动才会提高程序执行的性能。
关键边上插人基本块来放置这些拷贝。补偿代码可能使得某些路径的执行变慢。因此，只有当
拷
值
割集。在每个插人这个拷贝的地方，下列约束必须满足：
们把这个运算的拷贝放置在一组基本块中，这组基本块形成了一个将入口基本块和 src 分割开的
当控制流到达 src 的时候这次代码移动才是有益的。
“免费"执行的（即它只使用那些本来会被闲置的资源），那么这次代码移动没有产生开销。只有
非被移动的运算没有任何有害的副作用，否则这个代码移动就是非法的。如果被移动的运算是
那么被移动的运算会在它应该运行的时候被恰好运行一次。
数据依赖关系，并且使得从 dst 到 src 的路径运行得更快。如果 dst 支配 src 并且 src 反向支配 dst,
1）在控制等价的基本块之间移动指令最简单且性价比最高。不需要执行额外的运算，也不
本块 src 的卫式断言作为被移动运算的卫式断言。请注意，这些带断言的指令只能被安排在由
考贝中放置这个运算。另一-个方法是，如果可以在使用带断言的指令时使用这种指令。我们用
。我们可以设法绕过这个问题，方法是复制从 src 到 dst 的路径上的基本块，并且只在 dst 的新
页外的运算。遗憾的是，向下代码移动经常用于写运算。这种运算具有副作用，会覆盖原来的
多动运算的拷贝。根据9.5 节中对部分冗余消除的讨论我们可以知道如何准确做到这--点。我
2）在向上（向下)代码移动中，如果源基本块不反向支配(支配）目标基本块，那么就可能需
464
从上面的讨论中可知，我们看到存在一组可能的全局代码移动的方法。这些方法的收益、代
关于向上和向下代码移动的总结
和上面的讨论一样，我们必须插人补偿代码以使得被移动的运算在所有没有到达 dst 的路径
如果 dst 不反向支配 src
在这种情况下，存在一条没有先访问 src 就到达 dst 的路径。同样，在这种情况下会执行-一
如果 src 不支配 dst 
可以像上面介绍的那样考虑这样的代码移动。
假设我们感兴趣的是把一个运算从基本块 src 沿着一条控制流路径向下移动到基本块 dst。
后、把 src 和流图出口处分开的割集中。
我们把这个运算指令的额外拷贝称为补偿代码（compen sation code）。9.5 节讨论过，可以在
这些拷贝使得 src 中的原指令完全冗余，因此可以被消除。
1）该运算的运算分量必须和原运算的运算分量具有相同的值。
这种情况下存在--条没有首先经过 dst 就到达 src 的路径。我们需要在这样的路径中插人被
如果 dst 不支配 src
这种情况下，存在一条经过 dst 但是没有到达 src 的路径。此时会执行一个多余的运算。除
如果 src 不反向支配dst
此运算本身的结果没有在到达 src 之前被覆盖掉。
）运算的结果没有覆盖掉可能在后面使用的值。
第10章
---
## Page 481
化过程中使用。
人们发现应用这个技术得到的结果相当精确。这样的信息可以反馈给编译器，由编译器在其优
条件分支的出口选择情况。然后，程序就在有代表性的输人上运行，确定程序总体的运行行为。
估算来自于动态获取的程序运行剖面。在这个技术中，程序经过插装以记录程序运行时刻各个
用频率。另外，转向程序出口或者异常处理例程的分支不大可能被选择执行。但是，最好的频率
中的指令执行得更频繁，也有理由假设选择向回跳转分支的使用频率高过不选择这个分支的使
的路径更快运行，虽然有可能降低不频繁路径的运行速度。
的90%以上的执行时间被花在不到10%的代码上。因此，我们可以把目标确定为使得频繁执行
是会损害另外一些路径的性能。好消息是指令并不是生而平等的。实际上，我们知道，
10.4.5全局调度算法
的，但是在移动之后就变得活跃了。如果一个变量在一个
个赋值语句上移，就不能再移动另一-个。更明确地说，我
之--可以被向上移动到顶部的基本块，因为这样的转换保
例10.10对于图10-14中显示的流图，对x的两个赋值
动之后都必须更新数据依赖关系。
10.4.4更新数据依赖关系
又需要补偿代码。
重要的。
码。带有补偿代码的路径的运行可能会变慢，因此保证被优化的路径具有较高的执行频率是很
移动就是有益的。
要执行额外的运算。
到该程序点的前面。
序点上活跃，那么我们不能把对该变量的投机性定值移
看到在代码移动之前顶部的基本块的出口处×是不活跃
编译器有多种技术来估算执行频率。我们有理由假设在最内层的循环中的指令比外层循环
在上一节中，我们看到代码移动对某些路径有益，但
如下面的例10.10所示，代码移动可能会改变运算之间的数据依赖关系。因此在每次代码移
4）最后一种情况把第二和第三种情况的不利之处合并了起来：可能既需要执行额外运算，
指令级并行性
3）在向上(向下)代码移动中，如果目标基本块不支配(反向支配)源基本块，就需要补偿代
1）把运算向上移动到控制等价的基本块。
现在我们描述一个简单的全局调度器，它支持两种最容易的代码移动：
基于区域的调度
向下：sre支配dst
向上：src反向支配dst
当该额外运算能够免费执行并且通过源基本块的路径被执行时，这个代码
是否是否
图10-13代码移动的总结
dst 反向支配syz
dst 支配 sre
是否否
否是否
图10-14说明因为代码移动而改变
数据依赖关系的例子
补偿代码
2
是是
否否
X
一个程序
465
---
## Page 482
量地展开该循环。如下的 for 循环
算不能和来自其他迭代的运算重叠。可缓解这一-问题的简单且高效的技术是在代码调度之前少
令只是在基本块B 中被投机性执行。
块的指令，而对来自于后继基本块的指令赋予较低的优先级。这么做的原因是后一-种类型的指
而，我们作了一个重要的修改。我们把较高的优先级赋予那些来自和基本块 B 控制等价的基本
所有指令都被安排完毕。
情况下把指令安排在该时钟周期上。然后，算法 10.11 更新 CandInsts 并重复这个过程，直到B 中
调度方案。对于每个时钟周期，它按照优先级顺序检查CandInsts 中的各条指令，在资源允许的
sts，这个列表中包含了候选基本块中的所有其前驱已调度好的指令。该算法逐个时钟周期地构造
的基本块(包含 B)，以及这些等价基本块的、被B支配的直接后继。
才对这个基本块进行调度。将被安排在一个基本块B 中的指令来自于所有和基本块B控制等价
本块的访问遵守拓扑排序。这个顺序保证了只有在该基本块所依赖的所有指令都被调度好之月
本块的控制和依赖边，因此最后得到的控制流和数据依赖图都是无环的。对每个区域中的各
子区域移动这些指令。
依赖关系都得到满足，我们可以绕者