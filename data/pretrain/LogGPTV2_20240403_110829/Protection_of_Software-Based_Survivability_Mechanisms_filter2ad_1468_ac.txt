precise  indirect  branch  addresses  statically  is  a  NP-hard 
problem in the presence of general pointers. 
6.1. A NP-hard argument 
Theorem  1: In  the  presence  of  general  pointers,  the 
indirect  branch  target 
problem  of  determining  precise 
addresses is NP-hard. 
Proof  Our proof consists of a polynomial  time reduc- 
tion from the 3-SAT problem to that of determining precise 
indirect branch targets. This is a variation of the proof orig- 
inally  proposed  by  Myers in  which  he  proved  that  various 
data--flow  problems are NP-hard  in the presence of aliases 
[ 121. Landi later proposed  a similar proof to prove that alias 
detection  is  NP-hard  in  the  presence  of  general  pointers 
[ 161. The detailed reduction can be found in other extended 
documents [21,22]. 
The NP-hardness proof establishes that the problem of 
statically determining branch  target addresses is NP hard in 
the presence  of general pointers. This result  applies to the 
set  of  general  programs  (with  general pointers), which,  at 
197 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:00:07 UTC from IEEE Xplore.  Restrictions apply. 
the first brush of reaction, may not be the same as the set of 
programs  produced  by  our transformations.  We  must  fur- 
ther establish that the set of transformed  programs does not 
represent  a restricted  class of programs  and  that  the proof 
also applies. We approach this as follows. 
Assuming the set of general programs  is A  and the set 
of programs produced by our transformations is A', to show 
that A' is not a restricted subset of A  (with respect to the NP 
hard proof) it suffices to show that 
1)  There  is  a  polynomial  time  mapping  for  every 
instance a in A to a functionally equivalent instance in A'. 
2)  If  there  is  a  polynomial-time  algorithm  to  resolve 
indirect branch targets for any instance in A', then this algo- 
rithm  can  be  used  to  resolve  indirect  branch  targets  for 
instances of A. 
Establishing  a  polynomial 
from 
instances  of  A  to  instances  of  A'  is  straightforward;  this 
mapping  consists  of  exactly  the  code  transformations  we 
described in Section 4 and 5. 
time  mapping 
Because  the  transformations  introduced  in  Section  4 
and  5  are  semantics-preserving  transformations,  an  algo- 
rithm that resolves indirect branch targets for an instance in 
A'  will  by  definition resolve  indirect  branch  targets  for  its 
functionally equivalent instance in A. More intuitively, if all 
the  indirect  branching  targets  for  an  instance  in  A'  are 
resolved  to  direct  jumps,  it  is  a  polynomial-time  task  to 
restore the original control-constructs (from the flattened $- 
else-goro constructs)  and  therefore  deduce the  branch  tar- 
gets for the original program in A. 
The reduction  from  3-SAT does  not  make use  of  any 
program characteristics other than multiple levels of pointer 
dereferencing  and  conditional  branches.  The  transforma- 
tions described in Section 4 and 5 preserve the presence of 
conditional  branches  and  arbitrary  levels  of  pointers  and 
pointer  dereferencing.  From  an  intuitive  standpoint,  this 
suggests that  the reduction from 3-SAT also stands for the 
transformed program. 
6.2. Complexity evaluation for approximation 
analysis methods 
While the NP-hard result bode  well for the alias-based 
code  transformations,  we  still  need 
to  evaluate  our 
approach  against  possible  heuristics  and  approximation 
methods. In this section, we explore the effect of two analy- 
sis methods: brute-force search and alias approximations. 
Brute-force search method. To determine the execu- 
tion  order of the code blocks that  appear in  the degenerate 
form of  the  program,  an  adversary  might  employ a brute- 
force search method in which all combinations  of the code 
block  ordering  are  explored.  This  is  a  naive  exhaustive 
search  heuristic  in  which each block  is  considered equally 
likely  to  be  the  immediate successor  of  the  current  block 
(including the current block itself). The time complexity of 
such a brute-force  method is O(nk), where II  is the number 
of  distinct  program  blocks  and k  is the  number  of  blocks 
that will be executed. Clearly, this represents the worst-case 
time complexity and is extremely inefficient when the value 
of n and k are sufficiently large. 
Alias-detection  approximation  methods.  The  prob- 
lem  of  precise  alias  detection  in  the  presence  of  general 
pointers  and  recursive  data  structures  is  undecidable  [ 1 I ,  
161.  In  practice,  however,  approximation  algorithms  are 
often  used  [ 111.  An  alias  analysis  algorithm  may  analyze 
aliases  intra-procedurally  as  well  as  across  procedural 
boundaries. 
Intra-procedural  alias  analysis  requires  as  input  the 
alias set holding at the entry node of the procedure, the alias 
set propagated  back from  any  procedure  called  within  the 
, int 'pl,;2, 
I 
'p3; , 
use (b); 9 
b.2; 
p i  = &array; 
swVar = array[f()]; 
Y 
if  (  !(a iO)) 
swVar  = array[f()]; 
b--. 
' p 3 t t ;  
swVar = array[f()]; 
a t t ;  
' ( p l t 1 4 )   = 0; 
swVar = array[f()]; 
- 
Figure 6: An example transform using pointer manipulation 
198 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:00:07 UTC from IEEE Xplore.  Restrictions apply. 
current procedure, and the alias processing functions (trans- 
fer functions) of  each pointer assignment statement. Well- 
known  data-flow  frameworks  [ I I ,   171 exist  for  handling 
intra-procedural  alias analysis. They are divided  into flow- 
sensitive  and  flow-insensitive  methods.  Flow-sensitive 
methods  make  use  of  control-flow  path  information, and 
are more precise  than flow-insensitive methods. The trans- 
formations described in Section 4 and 5 produce a degener- 
ate form of  static control flow. As  a result, flow-sensitive 
analysis conducted on this form of control flow loses preci- 
sion  advantage  it  has  over  the  flow-insensitive methods. 
Figure 7 illustrates such an example. 
The CFG in Figure 7 shows that the assignment q = &c 
overwrites the alias relation , and p = &b overwrites 
, , } for this segment. The 
degenerate  control  flow  in  Figure  7(b)  essentially  repre- 
sents the set of all possible paths with these blocks. Even a 
flow-sensitive  analysis  algorithm  at  best  must  conclude 
with  the  alias  set ,   , , }. Horwitz  [ 141 presented  a  definition  of precise  flow- 
insensitive  alias  analysis.  Under  this  definition, the  flow- 
sensitive analysis  result  obtained from the  CFG  in  Figure 
7(b) is exactly the same result as a precise  flow-insensitive 
algorithm  would  have  concluded  with  the  CFG in  Figure 
7(a). We thus conjecture that,  with  the  degenerate form of 
control  flow, a flow-sensitive analysis can be no more pre- 
cise than its flow-insensitive  counterpart. 
The transformations presented  in  this  paper are intra- 
procedural  transforms  in the sense that they  do not affect  a 
control-flow analysis on the procedural level. However, an 
inter-procedural  alias  analysis  is  inherently  based  on  the 
result  of intra-procedural alias analysis, therefore  its preci- 
sion suffer likewise. A step beyond the current scheme is to 
generalize  the 
transformations  to  produce  degenerate 
I 
PCGs,  which  will  further  degrade  analysis  results.  A 
detailed discussion on this topic as well as an in-depth study 
of the complexity of existing alias analysis frameworks can 
be found in [21]. 
7.  Implementation and Performance Results 
We implemented the transformations in a source trans- 
lator  for ANSI  C in  the  SUIF programming  environment 
[I].  In our implementation, we developed  compiler passes 
for the code transformations. Each pass traverses the SUIF 
representation and performs the desired modifications. The 
exact  transformations  are  determined  by  a  random  seed: 
that is, the resulting  program is different for each compila- 
tion.  For example, the layout  of the global  array, the  exact 
percentage of the control-transfers that are transformed, and 
the number of dead blocks that are added are all determined 
by a random number generated  from the seed. 
We  tested  performance  results  obtained  with  experi- 
mental  transformations  on  the  SPEC95  benchmark  pro- 
issue  here  are  three  measures:  Run-tinze 
grams.  Of 
performance  of  the  transformed program, perforniance of 
static analysis, and precision of static analysis. 
By run-time performance of the transformed  programs, 
we mean the execution time and the executable object size 
after transformation. These measures reflect  the cost of the 
transformation. By performance of static analysis, we mean 
the time taken for the analysis tool to reach closure and ter- 
minate. A related  but equally important criterion  is the pre- 
cision of  static analysis, which  indicates how  accurate the 
analysis result is compared to the true alias relationships. 
7.1. Performance of the transformed program 
The following data was obtained by applying our trans- 
forms to  SPEC95 benchmark programs. Three  SPEC pro- 
Statement 
Figure 7: Effect of the degenerate control flow on alias analysis 
199 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:00:07 UTC from IEEE Xplore.  Restrictions apply. 
Figure 8: Execution time (non- 
optimized) 
Figure 9: Execution Tim e (optim ized) 
10% 
3 0 %  
5 0 %  
8 0 %  
Percentage of branches transformed 
1 0 %  
3 0 %  
5 0 %  
8 0 %  
Percentage of branches transformed 
grams are used in this experiment, Compress95, Go and LI. 
Go  is  a  branch-intensive  implementation  of  the  Chinese 
board game GO. Compress95 implements a tightly-looping 
compression  algorithm,  and  LI  is  a  typical  input-output 
bound  program for a LISP interpreter. These programs are 
standard  benchmarks  used  in  the  compiler  community. 
They  embody  three  major  classes  of  high-level  language 
constructs that are widely  used  in general programming. It 
would  be  more  satisfying,  however,  to  test  our  results  on 
the  class  of  networking  programs  for  which  this  solution 
was  intended.  But  in  the  absence  of  that,  we  believe  that 
these  test  programs are good representatives  of  real-world 
programs. 
We conducted experiments on both optimized (with the 
gcc -0 option) and non-optimized versions of the programs. 
The  experiments  were  executed  on  a  SPARC  server.  The 
experimental  results  show  that,  in  both  cases, the  perfor- 
mance-slowdown increases exponentially with the percent- 
age  of  transformed  branches  in  the  program.  On  average, 
the  performance  speedup  due  to  optimization  is  signifi- 
cantly reduced when a more substantial portion  of the pro- 
gram is obfuscated. 
This  is  an  encouraging  result;  it  is  highly  suggestive 
(albeit  not  conclusive)  that  our  transformations  consider- 
ably  hindered the  optimization that  the compiler  is  able to 
perform. 
Figure 10: Executable Size (non- 
optim ized) 
The  performance  of  Go  and  li  were  similar  for both 
optimized  and  non-optimized  code.  Of  the  three  original 
programs,  compiler optimization  performed best  on  Com- 
press-a  whopping 80% decrease in the execution time due 
to optimization.  However, as can  be  seen in Figure  9, our 
transforms removed significant optimization potential from 
Compress; the execution speed of the transformed and opti- 
mized  Compress diverges  most significantly from the  per- 
formance of the original optimized  program.  As Compress 
is a loop-intensive program, it is likely that certain analyses 
that  enabled  significant  loop  or  loop  kernel  optimization 
were no longer possible after our transform was performed. 
The  object  size  of  the  three  benchmarks  grew  with 