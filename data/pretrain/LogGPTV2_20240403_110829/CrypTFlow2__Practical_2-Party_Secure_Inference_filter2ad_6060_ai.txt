[59] Adi Shamir. 1979. How to Share a Secret. Commun. ACM 22, 11 (1979), 612â€“613.
Microsoft Research, Redmond, WA.
https://doi.org/10.1145/359168.359176
[60] N.P. Smart and F. Vercauteren. 2011. Fully Homomorphic SIMD Operations.
Cryptology ePrint Archive, Report 2011/133. http://eprint.iacr.org/2011/133.
[61] Sameer Wagh, Divya Gupta, and Nishanth Chandran. 2019. SecureNN: 3-Party
Secure Computation for Neural Network Training. PoPETs 2019, 3 (2019), 26â€“49.
[62] Xiao Wang, Alex J. Malozemoff, and Jonathan Katz. 2016. EMP-toolkit: Efficient
MultiParty computation toolkit. https://github.com/emp-toolkit.
[63] Andrew Chi-Chih Yao. 1986. How to Generate and Exchange Secrets (Extended
Abstract). In 27th Annual Symposium on Foundations of Computer Science, Toronto,
Canada, 27-29 October 1986. IEEE Computer Society, 162â€“167. https://doi.org/10.
1109/SFCS.1986.25
[64] Wenting Zheng, Raluca Ada Popa, Joseph E. Gonzalez, and Ion Stoica. 2019.
Helen: Maliciously Secure Coopetitive Learning for Linear Models. In 2019 IEEE
Symposium on Security and Privacy, S&P 2019, San Francisco, CA, USA, May 19-23,
2019. 724â€“738.
[65] Xiaoyong Zhu, George Iordanescu, Ilia Karmanov, and Mazen Zawaideh.
2018. https://blogs.technet.microsoft.com/machinelearning/2018/03/07/using-
microsoft-ai-to-build-a-lung-disease-prediction-model-using-chest-x-ray-
images/
A SUPPORTING PROTOCOLS
Here, we describe supporting protocols that our main protocols
rely on.
A.1 Protocol for regular FAND
Regular FAND can be realized using bit-triples [8], which are
of the form (âŸ¨ğ‘‘âŸ©ğµ
ğ‘ ), where ğ‘ âˆˆ {0, 1} and ğ‘‘ âˆ§ ğ‘’ = ğ‘“ .
(cid:1)-OT2, the parties can generate two bit-
Using an instance of(cid:0)16
, âŸ¨ğ‘“ âŸ©ğµ
, âŸ¨ğ‘’âŸ©ğµ
1
triples [25]. We describe this protocol for generating the first triple,
and from there, it will be easy to see how to also get the second
ğ‘
ğ‘
14
MUX:
ğ‘ and âŸ¨ğ‘âŸ©ğµ
ğ‘ .
ğ‘ s.t. ğ‘§ = ğ‘ if ğ‘ = 1, else ğ‘§ = 0.
Algorithm 6 Multiplexer, Î ğ‘›
Input: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ holds âŸ¨ğ‘âŸ©ğ‘›
Output: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ learns âŸ¨ğ‘§âŸ©ğ‘›
1: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ picks ğ‘Ÿğ‘
$â† Zğ‘›.
0 = 0, (ğ‘ 0, ğ‘ 1) = (âˆ’ğ‘Ÿ0,âˆ’ğ‘Ÿ0 + âŸ¨ğ‘âŸ©ğ‘›
2: ğ‘ƒ0 sets ğ‘ 0, ğ‘ 1 as follows: If âŸ¨ğ‘âŸ©ğµ
0 ).
Else, (ğ‘ 0, ğ‘ 1) = (âˆ’ğ‘Ÿ0 + âŸ¨ğ‘âŸ©ğ‘›
0 ,âˆ’ğ‘Ÿ0).
1
with inputs (ğ‘ 0, ğ‘ 1) and ğ‘ƒ1 is the receiver with input âŸ¨ğ‘âŸ©ğµ
ğ‘ƒ1â€™s output be ğ‘¥1.
Else, (ğ‘¡0, ğ‘¡1) = (âˆ’ğ‘Ÿ1 + âŸ¨ğ‘âŸ©ğ‘›
with inputs (ğ‘¡0, ğ‘¡1) and ğ‘ƒ0 is the receiver with input âŸ¨ğ‘âŸ©ğµ
ğ‘ƒ0â€™s output be ğ‘¥0.
3: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of(cid:0)2
5: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of(cid:0)2
(cid:1)-OTğœ‚ where ğ‘ƒ0 is the sender
(cid:1)-OTğœ‚ where ğ‘ƒ1 is the sender
4: ğ‘ƒ1 sets ğ‘¡0, ğ‘¡1 as follows: If âŸ¨ğ‘âŸ©ğµ
1 ,âˆ’ğ‘Ÿ1).
1
1 . Let
1 = 0, (ğ‘¡0, ğ‘¡1) = (âˆ’ğ‘Ÿ1,âˆ’ğ‘Ÿ1 + âŸ¨ğ‘âŸ©ğ‘›
1 ).
0 . Let
6: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ outputs âŸ¨ğ‘§âŸ©ğ‘›
ğ‘ = ğ‘Ÿğ‘ + ğ‘¥ğ‘.
ğ‘
1
1
1
1
1 ||âŸ¨ğ‘’âŸ©ğµ
, âŸ¨ğ‘’âŸ©ğµ
ğ‘
1
1 = âŸ¨ğ‘“ âŸ©ğµ
triple using the same OT instance. The parties start by sampling
$â† {0, 1} for ğ‘ âˆˆ {0, 1}. ğ‘ƒ1 sets the first
random shares âŸ¨ğ‘‘âŸ©ğµ
1 , while the other two
bits are used for the second triple. ğ‘ƒ0 samples a random bit ğ‘Ÿ and
where ğ‘– âˆˆ {0, 1}4, ğ‘ƒ0 uses the first two bits ğ‘–1||ğ‘–2 of ğ‘– to compute
ğ‘ŸâŠ•((ğ‘–1âŠ•âŸ¨ğ‘‘âŸ©ğµ
0 )), and sets it as the first bit of the message,
while reserving the second bit for the other triple. Finally, ğ‘ƒ0 sets
âŸ¨ğ‘“ âŸ©ğµ
1 .
It is easy to see correctness by noting that âŸ¨ğ‘“ âŸ©ğµ
0 âŠ• (ğ‘‘ âˆ§ ğ‘’),
and since âŸ¨ğ‘“ âŸ©ğµ
0 is uniformly random, security follows directly in
(cid:1)-OT2 as âŸ¨ğ‘‘âŸ©ğµ
two bits of its input to(cid:0)16
(cid:1)-OT2 as follows: for the ğ‘–-th message,
sets its input messages to(cid:0)16
(cid:1)-OT2 as âŸ¨ğ‘“ âŸ©ğµ
0 = ğ‘Ÿ, and ğ‘ƒ1 sets the first bit of the output of(cid:0)16
the(cid:0)16
(cid:1)-OT2-hybrid.
(cid:1)-OT2,
The communication of this protocol is the same as that of(cid:0)16
0 )âˆ§(ğ‘–2âŠ•âŸ¨ğ‘’âŸ©ğµ
which is 2ğœ† + 16 Â· 2 bits. Since we generate two bit-triples using this
protocol, the amortized cost per triple is ğœ† + 16 bits, which is 144
for ğœ† = 128.
A.2 Protocol for correlated FAND
Correlated triples are two sets of bit triples (âŸ¨ğ‘‘âŸ©ğµ
ğ‘ , âŸ¨ğ‘“ âŸ©ğµ
ğ‘ )
(cid:0)16
(cid:1)-OT2 invocation to generate two regular triples, where the 4
and (âŸ¨ğ‘‘â€²âŸ©ğµ
ğ‘ ), for ğ‘ âˆˆ {0, 1}, such that ğ‘’ = ğ‘’â€², ğ‘‘ âˆ§ ğ‘’ = ğ‘“ ,
and ğ‘‘â€² âˆ§ ğ‘’â€² = ğ‘“ â€². The protocol from Appendix A.1 required a
(cid:0)8
(cid:1)-OT2 because ğ‘’ = ğ‘’â€², and thus, 3 bits suffice to represent ğ‘ƒ1â€™s
1
bits of ğ‘ƒ1â€™s input were its shares of ğ‘‘, ğ‘’, ğ‘‘â€², and ğ‘’â€². However, when
generating correlated triples, we can instead use an instance of
(cid:1)-OT2,
The communication of this protocol is equal to that of(cid:0)8
1
input. Correctness and security follow in a similar way as in the
case of regular FAND (see Appendix A.1).
which costs 2ğœ†+8Â·2 bits. Thus, we get an amortized communication
of ğœ† + 8 bits per correlated triple.
A.3 Protocol for Multiplexer
ğ‘ , âŸ¨ğ‘“ â€²âŸ©ğµ
ğ‘ , âŸ¨ğ‘’â€²âŸ©ğµ
ğ‘ , âŸ¨ğ‘’âŸ©ğµ
We describe our protocol for realizing F ğ‘›
First we argue correctness. Let ğ‘ = Reconstğµ(âŸ¨ğ‘âŸ©ğµ
0 âŠ• âŸ¨ğ‘âŸ©ğµ
(cid:1)-OTğœ‚, ğ‘¥1 = âˆ’ğ‘Ÿ0+ğ‘ Â·âŸ¨ğ‘âŸ©ğ‘›
1 . By correctness of(cid:0)2
MUX in Algorithm 6.
0 , âŸ¨ğ‘âŸ©ğµ
1 ) =
0 . Similarly,
1 ) = ğ‘§0 + ğ‘§1 = ğ‘ Â· ğ‘.
1 . Hence, Reconstğ‘›(âŸ¨ğ‘§âŸ©ğ‘›
âŸ¨ğ‘âŸ©ğµ
ğ‘¥0 = âˆ’ğ‘Ÿ1 + ğ‘ Â· âŸ¨ğ‘âŸ©ğ‘›
0 , âŸ¨ğ‘§âŸ©ğ‘›
1
1
B2A:
Algorithm 7 Boolean to Arithmetic, Î ğ‘›
Input: ğ‘ƒ0, ğ‘ƒ1 hold âŸ¨ğ‘âŸ©ğµ
Output: ğ‘ƒ0, ğ‘ƒ1 learn âŸ¨ğ‘‘âŸ©ğ‘›
1: ğ‘ƒ0 & ğ‘ƒ1 invoke an instance of(cid:0)2
0 and âŸ¨ğ‘âŸ©ğµ
0 and âŸ¨ğ‘‘âŸ©ğ‘›
1
1 , respectively, where ğ‘ âˆˆ {0, 1}.
(cid:1)-COTğœ‚ where ğ‘ƒ0 is the sender
1 , respectively, s.t. ğ‘‘ = ğ‘.
with correlation function ğ‘“ (ğ‘¥) = ğ‘¥ + âŸ¨ğ‘âŸ©ğµ
with input âŸ¨ğ‘âŸ©ğµ
learns ğ‘¦1.
0 and ğ‘ƒ1 is the receiver
1 . Party ğ‘ƒ0 learns ğ‘¥ and sets ğ‘¦0 = ğ‘› âˆ’ ğ‘¥ and ğ‘ƒ1
2: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ computes âŸ¨ğ‘‘âŸ©ğ‘›
ğ‘ = âŸ¨ğ‘âŸ©ğµ
ğ‘ âˆ’ 2 Â· ğ‘¦ğ‘.
Algorithm 8 â„“-bit integer ReLU, Î int,â„“
ReLU:
Input: ğ‘ƒ0, ğ‘ƒ1 hold âŸ¨ğ‘âŸ©ğ¿
0 and âŸ¨ğ‘âŸ©ğ¿
Output: ğ‘ƒ0, ğ‘ƒ1 get âŸ¨ReLU(ğ‘)âŸ©ğ¿
1: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ invokes F int,â„“
1 , respectively.
0 and âŸ¨ReLU(ğ‘)âŸ©ğ¿
1 .
ğ‘ to learn
ğ‘ and âŸ¨ğ‘¦âŸ©ğµ
ğ‘ to
DReLU with input âŸ¨ğ‘âŸ©ğ¿
MUX with inputs âŸ¨ğ‘âŸ©ğ¿
ğ‘ = âŸ¨ğ‘§âŸ©ğ¿
ğ‘ .
(cid:1)-OTğœ‚-hybrid. Communication com-
output âŸ¨ğ‘¦âŸ©ğµ
ğ‘ .
2: For ğ‘ âˆˆ {0, 1}, ğ‘ƒğ‘ invokes F ğ¿
ğ‘ and sets âŸ¨ReLU(ğ‘)âŸ©ğ¿
Security trivially follows in(cid:0)2
learn âŸ¨ğ‘§âŸ©ğ¿
plexity is 2(ğœ† + 2ğœ‚).
A.4 Protocol for B2A
1
1 âˆ’ 2âŸ¨ğ‘âŸ©ğµ
B2A formally in Algo-
0 , âŸ¨ğ‘‘âŸ©ğ‘›
1 )
1 . By correctness of(cid:0)2
1 . Security follows from the security of(cid:0)2
We describe our protocol for realizing F ğ‘›
rithm 7. For correctness, we need to show that ğ‘‘ = Reconstğ¿(âŸ¨ğ‘‘âŸ©ğ‘›
0 âŸ¨ğ‘âŸ©ğµ
0 + âŸ¨ğ‘âŸ©ğµ
= âŸ¨ğ‘âŸ©ğµ
âŸ¨ğ‘âŸ©ğµ
1 âˆ’ 2ğ‘¥ âˆ’
0 = âŸ¨ğ‘âŸ©ğµ
1 . Using this, âŸ¨ğ‘‘âŸ©ğ‘›
0 âŸ¨ğ‘âŸ©ğµ
0 âŸ¨ğ‘âŸ©ğµ
2âŸ¨ğ‘âŸ©ğµ
munication required is ğœ† + ğœ‚ bits.
B PROTOCOL FOR ReLU
(cid:1)-COTğœ‚, ğ‘¦1 = ğ‘¥ +
(cid:1)-COTğœ‚ and com-
1
1 = âŸ¨ğ‘âŸ©ğµ
0 + 2ğ‘¥ and âŸ¨ğ‘‘âŸ©ğ‘›
1
MUX. F int,â„“
DReLU and F ğ¿
MILL, which requires ğœ†(â„“ âˆ’ 1) + 13 1
We describe our ReLU protocol for the case where the input and
output shares are over Zğ¿ in Algorithm 8, and note that the case
of Zğ‘› follows similarly. It is easy to see that the correctness and
, F ğ¿
MUX)âˆ’hybrid.
security of the protocol follow in the (F int,â„“
DReLU
Communication complexity. We first look at the complexity of Î int,â„“
ReLU,
which involves a call to F int,â„“
DReLU has the same
communication as F â„“âˆ’1
2 (â„“ âˆ’ 1) âˆ’
2ğœ† âˆ’ 22 bits if we assume ğ‘š = 4 and ğ‘š | (â„“ âˆ’ 1), and exclude
optimization (3.1.1) in the general expression from Section 3.1.2.
MUX incurs a cost of 2ğœ† + 4â„“ bits, bringing the total cost to ğœ†â„“ +
F ğ¿
2 bits, which can be rewritten as < ğœ†â„“ + 18â„“. We get
2 â„“ âˆ’ ğœ† âˆ’ 35 1
17 1
our best communication for â„“ = 32 (with all the optimizations) by
taking ğ‘š = 7 for the Î 31
DReLU, which gives
us a total communication of 3298 bits.
Now, we look at the complexity of Î ring,ğ‘›
ReLU , which makes calls to
MUX. The cost of F ring,ğ‘›
F ring,ğ‘›
DReLU and F ğ‘›
1
2 ğœ†(ğœ‚ +1)+27(ğœ‚ +1)âˆ’4ğœ†âˆ’44 bits for 2 invocations of F ğœ‚+1
3
MILL, where
ğ‘ƒ1â€™s input is the same in both invocations and the same assumptions
are made as for the expression of F â„“âˆ’1
MUX is
2 ğœ†(ğœ‚ + 1) + 31ğœ‚ âˆ’ 13, which
2ğœ† + 4ğœ‚ bits, and thus, the total cost is 3
DReLU is 2ğœ†+4 bits for(cid:0)4
MILL above. The cost of F ğ‘›
MILL invocation inside Î int,32
(cid:1)-OT1, plus
15
1{ğ‘0 â‰¥ ğ‘›â€²}
1{ğ‘1 â‰¥ ğ‘›â€²}
1{ğ‘ğ‘¢ â‰¥ ğ‘›â€²} ğ‘¤ ğ‘1
ğ‘0
0 ğ´â€²
0
-1 ğ´â€²
1
0 ğ´â€²
1