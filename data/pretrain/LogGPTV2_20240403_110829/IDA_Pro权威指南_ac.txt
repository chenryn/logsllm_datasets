分析编译器生成的代码，以验证编译器的性能和准确性。
在调试时显示程序指令。
下面详细介绍上述每一种情况。
1.3.1 分析恶意软件
通常，恶意软件的作者很少会提供他们“作品”的源代码，除非你对付的是一种基于脚本的蠕虫。由于缺乏源代码，要准确地了解恶意软件的运行机制，你的选择非常有限。动态分析和静态分析是分析恶意软件的两种主要技术。动态分析
 （dynamic analysis ）是指在严格控制的环境（沙盒）中执行恶意软件，并使用系统检测实用工具记录其所有行为。相反，静态分析
 （static analysis ）则试图通过浏览程序代码来理解程序的行为。此时，要查看的就是对恶意软件进行反汇编之后得到的代码清单。
1.3.2 漏洞分析
为了简单起见，我们将整个安全审核过程划分成 3 个步骤：发现漏洞、分析漏洞、开发破解程序（exploit ）。无论是否拥有源代码，都可以采用这些步骤来进行安全审核。但是，如果只有二进制文件，你可能需要付出巨大的努力。这个过程的第一个步骤，是发现程序中潜在的可供利用的条件。一般情况下，我们可通过模糊测试1
 等动态技术来达到这一目的，也可通过静态分析来实现（通常需要付出更大的努力）。一旦发现漏洞，通常需要对其进行深入分析，以确定该漏洞是否可被利用，如果可利用，可在什么情况下利用。
1.模糊测试是一种发现漏洞的技术，它为程序生成大量不常见的输入，希望其中一个输入会在程序中造成可被检测、分析，最终可被利用的错误。
至于编译器究竟如何分配程序变量，反汇编代码清单提供了详细的信息。例如，程序员声明的一个70 字节的字符数组，在由编译器分配时，会扩大到80 字节，知道这一点会很有用。另外，要了解编译器到底如何对全局声明或在函数中声明的所有变量进行排序，查看反汇编代码清单是唯一的办法。在开发破解程序时，了解变量之间的这些空间关系往往非常重要。最后，通过结合使用反汇编器和调试器，就可以开发出破解程序。
1.3.3 软件互操作性
如果仅以二进制形式发布软件，竞争对手要想创建可以和它互操作的软件，或者为该软件提供插件，将会非常困难。针对某个仅有一种平台支持的硬件而发布的驱动程序代码，就是一个常见的例子。如果厂商暂时不支持，或者更糟糕地，拒绝支持在其他平台上使用他们的硬件，那么为了开发支持该硬件的软件驱动程序，可能需要完成大量的逆向工程工作。在这些情况下，静态代码分析几乎是唯一的补救方法。通常，为了理解嵌入式固件，还需要分析软件驱动程序以外的代码。
1.3.4 编译器验证
由于编译器（或汇编器）的用途是生成机器语言，因此优秀的反汇编工具通常需要验证编译器是否符合设计规范。分析人员还可以从中寻找优化编译器输出的机会，从安全角度来看，还可查知编译器本身是否容易被攻破，以至于可以在生成的代码中插入后门，等等。
1.3.5 显示调试信息
在调试器中生成代码清单，可能是反汇编器最常见的一种用途。遗憾的是，调试器中内嵌的反汇编器往往相当简单。它们通常不能批量反汇编，在无法确定函数边界时，它们有时候会拒绝反汇编。因此，在调试过程中，为了解详细的环境和背景信息，最好是结合使用调试器与优秀的反汇编器。
1.4 如何反汇编
现在，你已经知道了反汇编的目的，接下来介绍如何反汇编。以反汇编器所面临的一个艰巨任务为例：对于一个100 KB的文件，请区分其中的代码与数据，并把代码转换成汇编语言显示给用户。在整个过程中，不要遗漏任何信息
 。在这个任务中，我们还可以附加许多特殊要求，如要求反汇编器定位函数，识别跳转表并确定局部变量，这进一步增加了反汇编器工作的难度。
为了满足所有要求，反汇编器必须从大量算法中选择一些适当的算法，来处理我们提供的文件。反汇编器所使用算法的质量及其实施算法的效率，将直接影响所生成的反汇编代码的质量。在这一节中，我们将讨论当前对机器代码反汇编时所使用的两种基本算法。在介绍这些算法的同时，我们还将指出它们的缺陷，以便于你对反汇编器失效的情形有所防备。了解反汇编器的局限后，就可以通过手动干预来提高反汇编输出的整体质量了。
1.4.1 基本的反汇编算法
为方便初学者，首先开发一个以机器语言为输入、以汇编语言为输出的简单算法。这样做有助于我们了解自动反汇编过程中的挑战、假设和折中方案。
第一步
 。确定进行反汇编的代码区域。这并不像看起来那么简单。通常，指令与数据混杂在一起，区分它们就显得非常重要。以最常见的情形——反汇编可执行文件——为例，该文件必须符合可执行文件的某种通用格式，如 Windows 所使用的可移植可执行
 （Portable Executable ，PE）格式或许多 Unix 系统常用的可执行和链接格式
 （Executable and linking format ，ELF ）。这些格式通常含有一种机制，用来确定文件中包含代码和代码入口点1
 的部分的位置（通常表现为层级文件头的形式）。
1. 代码入口点是一个指令地址，一旦程序加载到内存，操作系统就将控制权交给该指令。
第二步
 。知道指令的起始地址后，下一步就是读取该地址（或文件偏移量）所包含的值，并执行一次表查找，将二进制操作码的值与它的汇编语言助记符对应起来。根据被反汇编的指令集的复杂程度，这个过程可能非常简单，也可能需要几个额外的操作，如查明任何可能修改指令行为的前缀以及确定指令所需的操作数。对于指令长度可变的指令集，如Intel x86 ，要完全反汇编一条指令，可能需要检索额外的指令字节。
第三步
 。获取指令并解码任何所需的操作数后，需要对它的汇编语言等价形式进行格式化，并将其在反汇编代码中输出。有多种汇编语言输出格式可供选择。例如，x86 汇编语言所使用的两种主要格式为 Intel 格式和AT & T 格式。
第四步
 。输出一条指令后，继续反汇编下一条指令，并重复上述过程，直到反汇编完文件中的所有指令。
x86 汇编语法：AT&T 和Intel
汇编语言源代码主要采用两种语法：AT & T 语法和 Intel 语法。尽管它们都属于第二代语言，但这二者的语法在变量、常量、寄存器访问、段和指令大小重写、间接寻址和偏移量等方面都存在巨大的差异。AT & T 汇编语法以%作为所有寄存器名称的前缀，以$作为文字常量（也叫做立即操作数）的前缀。它这样对操作数排序：源操作数位于左边，目的操作数位于右边。使用AT & T 语法，EAX寄存器加4 的指令为： add
$0x4,%eax
 。GNU汇编器（Gas）和许多其他GNU工具（如 gcc 和gdb）都使用AT & T 语法。
Intel 语法与AT & T 语法不同，它不需要寄存器和文字前缀，它的操作数排序方式与AT & T语法操作数恰恰相反：源操作数位于右边，目的操作数位于左边。使用 Intel 语法，上述加法的指令为：add
eax, 0x4
 。使用 Intel 语法的汇编器包括微软汇编器（MASM）、Borland的Turbo汇编器（TASM ）和Netwide汇编器（NASM ）。
有大量算法可用于确定从何处开始反汇编，如何选择下一条反汇编的指令，如何区分代码与数据，以及如何确定何时完成对最后一条指令的反汇编。线性扫描
 （linear sweep）和递归下降
 （recursive descent ）是两种最主要的反汇编算法。
1.4.2 线性扫描反汇编
线性扫描反汇编算法采用一种非常简单的方法来确定需要反汇编的指令的位置：一条指令结束、另一条指令开始的地方。因此，确定起始位置最为困难。常用的解决办法是，假设程序中标注为代码（通常由程序文件的头部指定）的节所包含的全部是机器语言指令。反汇编从一个代码段的第一个字节开始，以线性模式扫描整个代码段，逐条反汇编每条指令，直到完成整个代码段。这种算法并不会通过识别分支等非线性指令来了解程序的控制流。
进行反汇编时，可以维护一个指针来标注当前正在反汇编的指令的起始位置。在反汇编过程中，每一条指令的长度都被计算出来，并用来确定下一条将要反汇编的指令的位置。为此，对由长度固定的指令构成的指令集（如 MIPS）进行反汇编有时会更加容易，因为这时可轻松定位随后的指令。
线性扫描算法的主要优点，在于它能够完全覆盖程序的所有代码段。线性扫描方法的一个主要缺点，是它没有考虑到代码中可能混有数据。代码清单 1-1 就说明了这个问题，它显示的是用线性扫描反汇编器反汇编一个函数所得到的输出结果。这个函数包含一个switch
 语句，这里使用的编译器选择使用跳转表来执行 switch
 语句。而且，编译器选择在函数本身中嵌入一个跳转表。401250
 （➊）处的jmp
 语句引用了一个以 401257
 （➋）为起始位置的地址表。但是，反汇编器把（➋）作为一条指令来处理，并错误地生成了其对应的汇编语言形式。
代码清单 1-1 线性扫描反汇编
  40123f:    55                       push   ebp
  401240:    8b ec                    mov    ebp,esp
  401242:    33 c0                    xor    eax,eax
  401244:    8b 55 08                 mov    edx,DWORD PTR [ebp+8]
  401247:    83 fa 0c                 cmp    edx,0xc
  40124a:    0f 87 90 00 00 00        ja     0x4012e0
➊ 401250:    ff 24 95 57 12 40 00     jmp    DWORD PTR [edx*4+0x401257]
➋ 401257:    e0 12                    loopne 0x40126b
  401259:    40                       inc    eax
  40125a:    00 8b 12 40 00 90        add    BYTE PTR [ebx-0x6fffbfee],cl
  401260:    12 40 00                 adc    al,BYTE PTR [eax]
  401263:    95                       xchg   ebp,eax
  401264:    12 40 00                 adc    al,BYTE PTR [eax]
  401267:    9a 12 40 00 a2 12 40     call   0x4012:0xa2004012
  40126e:    00 aa 12 40 00 b2        add    BYTE PTR [edx-0x4dffbfee],ch
  401274:    12 40 00                 adc    al,BYTE PTR [eax]
  401277:    ba 12 40 00 c2           mov    edx,0xc2004012
  40127c:    12 40 00                 adc    al,BYTE PTR [eax]
  40127f:    ca 12 40                 lret   0x4012
  401282:    00 d2                    add    dl,dl
  401284:    12 40 00                 adc    al,BYTE PTR [eax]
  401287:    da 12                    ficom  DWORD PTR [edx]
  401289:    40                       inc    eax
  40128a:    00 8b 45 0c eb 50        add    BYTE PTR [ebx+0x50eb0c45],cl
  401290:    8b 45 10                 mov    eax,DWORD PTR [ebp+16]
  401293:    eb 4b                    jmp    0x4012e0
如果将（➋）处开始的连续 4 字节组作为小端（little endian ）2
 值分析，我们发现，每个字节组都代表一个指向邻近地址的指针。实际上，这个地址是许多跳转的目的地址（004012e0
 、0040128b
 、00401290
 …）中的一个。因此，（➋）处的loopne
 指令并不是一条指令；相反，它说明线性扫描算法无法正确地将嵌入的数据与代码区分开来。
2. 如果CPU 首先存储一个多字节值的最高有效字节，则称该CPU 为大端（big-endian）CPU ；如果该CPU 首先存储最低有效字节，则称为小端（little-endial ）CPU 。
GNU调试器（gdb）、微软公司的 WinDbg调试器和 objdump
 实用工具的反汇编引擎均采用线性扫描算法。
1.4.3 递归下降反汇编
递归下降采用另外一种不同的方法来定位指令。递归下降算法强调控制流的概念。控制流根据一条指令是否被另一条指令引用来决定是否对其进行反汇编。为便于理解递归下降，我们根据指令对CPU 指令指针的影响对它们分类。
1. 顺序流指令
顺序流指令将执行权传递给紧随其后的下一条指令。顺序流指令的例子包括简单算术指令，如add
 ；寄存器与内存之间的传输指令，如 mov
 ；栈操作指令，如 push
 和pop
 。这些指令的反汇编过程以线性扫描方式进行。
2. 条件分支指令
条件分支指令（如 x86 jnz
 ）提供两条可能的执行路径。如果条件为真，则执行分支，并且必须修改指令指针，使其指向分支的目标。但是，如果条件为假，则继续以线性模式执行指令，并使用线性扫描方法反汇编下一条指令。因为不可能在静态环境中确定条件测试的结果，递归下降算法会反汇编上述两条路径。同时，它将分支目标指令的地址添加到稍后才进行反汇编的地址列表中，从而推迟分支目标指令的反汇编过程。
3. 无条件分支指令
无条件分支并不遵循线性流模式，因此，它由递归下降算法以不同的方式处理。与顺序流指令一样，执行权只能传递给一条指令，但那条指令不需要紧接在分支指令后面。事实上，如代码清单1-1 所示，根本没有要求规定在无条件分支后必须紧跟一条指令。因此，也就没有理由反汇编紧跟在无条件分支后面的字节。
递归下降反汇编器将尝试确定无条件跳转的目标，并将目标地址添加到要反汇编的地址列表中。遗憾的是，某些无条件分支可能会给递归下降反汇编器造成麻烦。如果跳转指令的目标取决于一个运行时值，这时使用静态分析就无法确定跳转目标。x86 的jmp eax
 指令就证实了这个问题。只有程序确实正在运行时，eax
 寄存器中才会包含一个值。由于寄存器在静态分析过程中不包含任何值，因此无法确定跳转指令的目标，也就无法确定该从什么地方继续反汇编过程。
4. 函数调用指令
函数调用指令的运行方式与无条件跳转指令非常相似（包括反汇编器无法确定call eax
 等指令的目标），唯一的不同在于，一旦函数完成，执行权将返回给紧跟在调用指令后面的指令。在这方面，它们与条件分支指令类似，因为它们都生成两条执行路径。调用指令的目标地址被添加到推迟进行反汇编的地址列表中，而紧跟在调用后面的指令则以类似于线性扫描的方式进行反汇编。
从被调用函数返回时，如果程序的运行出现异常，递归下降就有可能失败。例如，函数中的代码可能会有意窜改该函数的返回地址，这样，在函数完成时，控制权将返回到一个反汇编器无法预知的地址。下面的错误代码就是一个简单的例子。在这个例子中，函数foo
 在返回调用方之前，对返回地址加了 1。
foo                 proc near  
  FF 04 24          inc     dword ptr [esp]  ; increments saved return addr  
  C3                retn  
foo                 endp
; -------------------------------------  
bar:
  E8 F7 FF FF FF    call    foo
  05 89 45 F8 90    ➊add eax, 90F84589h
结果，在调用 foo 之后，控制权实际上并未返回给（➊）处的 add 指令。正确的反汇编过程如下所示。  
 foo                 proc near                 
   FF 04 24          inc     dword ptr [esp]  
   C3                retn  
foo                 endp  
; -------------------------------------
bar:  
   E8 F7 FF FF FF    call    foo  
   05                db    5 ;formerly the first byte of the add instruction  
   89 45 F8          Y mov [ebp-8], eax  
   90                nop
以上代码更清楚地展示了程序的实际流程。实际上，函数foo
 将控制权返回给了位于➋处的mov
 指令。值得注意的是，线性扫描反汇编器可能也同样无法正确对这段代码反汇编，只是原因稍有不同。
5. 返回指令
有时，递归下降算法访问了所有的路径。而且，函数返回指令（如 x86 ret
 ）没有提供接下来将要执行的指令的信息。这时，如果程序确实正在运行，则可以从运行时栈顶部获得一个地址，并从这个地址开始恢复执行指令。但是，反汇编器并不具备访问栈的能力，因此反汇编过程会突然终止。这时，递归下降反汇编器会转而处理前面搁置在一旁的延迟反汇编地址列表。反汇编器从这个列表中取出一个地址，并从这个地址开始继续反汇编过程。递归下降反汇编算法正是因此而得名。
递归下降算法的一个主要优点在于，它具有区分代码与数据的强大能力。作为一种基于控制流的算法，它很少会在反汇编过程中错误地将数据值作为代码处理。递归下降算法的主要缺点在于，它无法处理间接代码路径，如利用指针表来查找目标地址的跳转或调用。然而，通过采用一些用于识别指向代码的指针的启发
 （heuristics ）式方法，递归下降反汇编器能够提供所有代码，并清楚地区分代码与数据。代码清单1-2 是对前面代码清单 1-1 中的switch