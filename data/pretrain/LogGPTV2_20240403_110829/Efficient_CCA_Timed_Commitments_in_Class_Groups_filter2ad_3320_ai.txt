Definition A.3 (Homomorphic Time-Lock Puzzles). Let C =
{Cğœ†}ğœ†âˆˆN be a class of circuits and let ğ‘† be a finite domain. A homo-
morphic time-lock puzzle scheme HTLP with respect to C and with
solution space ğ‘† is tuple of four algorithms (PSetup, PGen, Solve,
PEval) defined as follows.
pp â† PSetup(1ğœ†, T): a probabilistic algorithm that takes as input a
security parameter 1ğœ† and a time hardness parameter T, and outputs
public parameters pp.
ğ‘ â† PGen(pp, ğ‘ ): a probabilistic algorithm that takes as input public
parameters pp, and a solution ğ‘  âˆˆ ğ‘†, and outputs a puzzle ğ‘.
ğ‘  â† Solve(pp, ğ‘): a deterministic algorithm that takes as input public
parameters pp and a puzzle ğ‘ and outputs a solution ğ‘ .
ğ‘ â€² â† PEval(ğ¶, pp, ğ‘1, . . . , ğ‘ğ‘›): a probabilistic algorithm that takes
as input a circuit ğ¶ âˆˆ Cğœ†, public parameters pp and a set of ğ‘› puzzles
(ğ‘1, . . . , ğ‘ğ‘›) and outputs a puzzle ğ‘ â€².
Security requires that the solution of the puzzles is hidden for all
adversaries that run in (parallel) time less than T. We additionally
require compactness that requires that the size of the homomor-
phically evaluated puzzles does not depend on the function that is
evaluated.
Definition A.4 (Security of HTLP [55]). An HTLP scheme con-
sisting of (PSetup, PGen, Solve, PEval), is secure with gap ğœ€ < 1 if
there exists a polynomial ËœT(Â·) such that for all polynomials T(Â·) â‰¥
ËœT(Â·) and every polynomial-size adversary A = {(A1, A2)ğœ†}ğœ†âˆˆN
where the depth of A2 is bounded from above by Tğœ€(ğœ†), there exists
a negligible function negl, such that for all ğœ† âˆˆ N it holds that
 â‰¤ 1
2 + negl(ğœ†)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
ğ‘ = ğ‘â€²
Pr
and (ğ‘ 0, ğ‘ 1) âˆˆ ğ‘†2.
pp â† PSetup(1ğœ†, T(ğœ†))
(ğœ, ğ‘ 0, ğ‘ 1) â† A1(1ğœ†, pp)
ğ‘ â†$ {0, 1}
ğ‘ â˜… â† PGen(pp, ğ‘ ğ‘)
ğ‘â€² â† A2(pp, ğ‘ â˜…, ğœ)
Definition A.5 (Compactness [55]). Let C = {Cğœ†}ğœ†âˆˆN be a
class of circuits (along with their respective representations). An HTLP
scheme (PSetup, PGen, Solve, PEval) is compact (for the class C) if
for all ğœ† âˆˆ N, all polynomials T in ğœ†, all circuits ğ¶ âˆˆ Cğœ† and respective
inputs (ğ‘ 1, . . . , ğ‘ ğ‘›) âˆˆ ğ‘†ğ‘›, all pp in the support of PSetup(1ğœ†, T), and
all ğ‘ğ‘– in the support of PGen(pp, ğ‘ ğ‘–), the following two conditions are
satisfied:
â€¢ There exists a fixed polynomial ğ‘(Â·) such that |ğ‘| = ğ‘(ğœ†, |ğ¶(ğ‘ 1,
Ëœğ‘(Â·) such that the runtime of
â€¢ There exists a fixed polynomial
. . . , ğ‘ ğ‘›)|), where ğ‘ â† PEval(ğ¶, pp, ğ‘1, . . . , ğ‘ğ‘›).
PEval(ğ¶, pp, ğ‘1, . . . , ğ‘ğ‘›) is bounded by Ëœğ‘(ğœ†, |ğ¶|).
Non-Interactive Zero-Knowledge Proofs. A NIZK proof [9] al-
lows a prover to convince a verifier about the validity of a certain
statement without revealing anything beyond that. We recall the
syntax in the following.
Definition A.6 (NIZK). Let L be an NP-language with relation
R. A NIZK system for R consists of the following efficient algorithms.
crs â† Setup(1ğœ†): On input the security parameter 1ğœ†, the setup al-
gorithm returns a common reference string crs.
ğœ‹ â† Prv(crs, stmt, wit): On input the common reference string crs,
a statement stmt, and a witness wit, the prover algorithm returns a
proof ğœ‹.
0/1 â† Vfy(crs, stmt, ğœ‹): On input the common reference string crs,
a statement stmt, and a proof ğœ‹, the verifier algorithm returns a bit
ğ‘ âˆˆ {0, 1}.
Correctness requires that for all ğœ† âˆˆ N and all pairs (stmt, wit) âˆˆ
R it holds that
Pr[Vfy(crs, stmt, Prv(crs, stmt, wit)) = 1] = 1
where crs â†$ Setup(1ğœ†).
We recall the definition of zero-knowledge in the following.
Definition A.7 (Zero-Knowledge). A NIZK system for R is
zero-knowledge if there exists a PPT algorithm (Sim0, Sim1) such
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2677(cid:16)
that for all pairs (stmt, wit) âˆˆ R and for all PPT distinguishers the
following distributions are computationally indistinguishable
crs â† Setup(1ğœ†), ğœ‹ â† Prv(crs, stmt, wit)(cid:17) â‰ˆ
(cid:0)crsâˆ—, ğœ‹ â† Sim1(crs, stmt, td)(cid:1)
where (crsâˆ—, td) â† Sim0(1ğœ†).
We require that the protocol satisfies the strong notion of simu-
lation soundness [67].
Definition A.8 (Simulation Soundness). A NIZK system for R
is simulation-sound if there exists a negligible function negl(Â·) such
that for all ğœ† âˆˆ N and all PPT algorithms A it holds that
(cid:20) 1 = Vfy(crs, stmt, ğœ‹)
âˆ§ stmt âˆ‰ ğ‘„ âˆ§ stmt âˆ‰ L
Pr
(cid:12)(cid:12)(cid:12)(cid:12) (crs, td) â† Sim0(1ğœ†)
(ğœ‹, stmt) â† AO(Â·)(crs)
(cid:21)
= negl(ğœ†)
where O takes as input a (possibly false) statement stmt and returns
Sim1(crs, stmt, td) and we denote by ğ‘„ the list of queries issued by
A.
B ASSUMPTIONS
We give the formal definition of a DDH-hard prime order group.
Definition B.1 (DDH-hard prime order group). We say that
a group generation algorithm ËœGGen is DDH hard if there exists a
negligible function negl, such that for all ğœ† âˆˆ N, all PPT adversaries
A the following holds:
We can extend the above definition to the case of a class group
where the order of the group is not known. In this case, the values
ğ‘¥, ğ‘¦, ğ‘§ are sampled uniformly at random from a domain exponen-
tially larger than the upper bound on the group order.
Definition B.2 (DDH-hard unknown order group). We say
that a group generation algorithm CGGen is DDH hard if there exists
a negligible function negl, such that for all ğœ† âˆˆ N all ğœ† bit primes ğ‘,
and all PPT adversaries A the following holds:
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
Pr
ğ‘â€² = ğ‘
(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘) â† CGGen(1ğœ†, ğ‘)
ğ‘¥, ğ‘¦, ğ‘§ â† Zâˆ—
Ëœğ‘
ğ‘‹0 := ğ‘‹1 = ğºğ‘¥
ğ‘Œ0 := ğ‘Œ1 = ğº ğ‘¦
ğ‘ â† {0, 1}
ğ‘0 := ğºğ‘¥ ğ‘¦ and ğ‘1 := ğºğ‘§
ğ‘â€² â† A(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘, ğ‘‹ğ‘, ğ‘Œğ‘, ğ‘ğ‘)
We also recall the subgroup membership assumption.
â‰¤ 1
2 + negl(ğœ†)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
Pr
ğ‘â€² = ğ‘
( ËœG, Ëœğº, Ëœğ‘) â† ËœGGen(1ğœ†)
ğ‘¥, ğ‘¦, ğ‘§ â† Zâˆ—
Ëœğ‘
Ëœğ‘‹0 := Ëœğ‘‹1 = Ëœğºğ‘¥
Ëœğ‘Œ0 := Ëœğ‘Œ1 = Ëœğº ğ‘¦
ğ‘ â† {0, 1}
Ëœğ‘0 := Ëœğºğ‘¥ ğ‘¦ and Ëœğ‘1 := Ëœğºğ‘§
ğ‘â€² â† A( ËœG, Ëœğ‘, Ëœğº, Ëœğ‘‹ğ‘, Ëœğ‘Œğ‘, Ëœğ‘ğ‘)
â‰¤ 1
2 + negl(ğœ†)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
ğ‘â€² = ğ‘
Pr
Definition B.3 (Hard Subgroup Membership ([28])). We say
that a group generation algorithm CGGen is HSMğ¶ğ¿ hard if there
exists a negligible function negl, such that for all ğœ† âˆˆ N, all ğœ† bit
primes ğ‘, and all PPT adversaries A, the following holds:
(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘) â† CGGen(1ğœ†, ğ‘)
ğ‘Ÿ0 â† Zğ‘ Ëœğ‘ and ğ‘Ÿ1 â† Z Ëœğ‘
ğ›¿0 := ğ›¾ğ‘Ÿ0 and ğ›¿1 := ğ›¾ğ‘Ÿ1
ğ‘
ğ‘ â† {0, 1}
ğ‘â€² â† A(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘, ğ›¿ğ‘, SolveDL)
â‰¤ 1
2 + negl(ğœ†)
We recall the strong root assumption for class groups.
Definition B.4 (Strong root assumption [26]). We say that
the strong root assumption holds for the class group generation CGGen
if there exists a negligible function negl, such that for all ğœ† âˆˆ N, all
PPT adversaries A the following holds:
 ğº = ğ‘ˆ â„“
â„“ â‰  1, 2ğ‘˜,âˆ€ğ‘˜
Pr
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘) â† CGGen(1ğœ†, ğ‘)
(ğ‘ˆ , â„“) â† A(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘, ğ»)
ğ» â† G
â‰¤ negl(ğœ†)
We recall the 2ğœ†-low order assumption for class groups.
Definition B.5 (ğ›¾-Low order assumption [26]). We say that
the ğ›¾-low order assumption holds for the class group generation
CGGen for a given ğ›¾ if there exists a negligible function negl, such
that for all ğœ† âˆˆ N, all PPT adversaries A the following holds:
 ğ‘ˆ â„“ = 1
ğ‘ˆ â‰  1
1 < â„“ < ğ›¾
Pr
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘) â† CGGen(1ğœ†, ğ‘)
(ğ‘ˆ , â„“) â† A(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘)
 â‰¤ negl(ğœ†)
C CL FAST VARIANT
We describe here a slightly modifed version of the faster variant
of CL encryption which is sketched in [27], and provide a clean
security proof under the hard subroup membership assumption,
HSMğ¶ğ¿, introduced in [28] (cf. Definition B.3).
The main difference with the scheme from [27] is the fact that
instead of choosing ğœ‘ğ‘(ğ›¾) as a generator of G we choose ğº as the
ğ‘-th power of this element (so G = ğœ‘ğ‘(ğ›¾)ğ‘) in order for the IND-CPA
proof to go through. Thanks to this slight modification, we are able
to prove the security of this scheme under the HSMğ¶ğ¿ assumption
(see Theorem C.1), instead of the â€œnon-standardâ€ assumption stated
in [27]. Remark that ğ‘  is the (unknown) order of ğº and of ğ›¾ğ‘ =
ğœ“ğ‘(ğº), since ğœ“ğ‘ is an injective homomorphism.
Theorem C.1. Let CGGen be a HSMğ¶ğ¿-hard group generator,
then the above cryptosystem is IND-CPA-secure.
Proof. We describe a sequence of games whose transitions
are then analysed to show that our fast variant of CL is secure
under the HSMğ¶ğ¿ assumption. Recall that ğº = ğœ‘ğ‘(ğ›¾)ğ‘ so that
ğº = ğœ‘ğ‘(ğœ“ğ‘(ğ‘…))ğ‘ = ğ‘…ğ‘2 and ğ‘ is prime to ğ‘  and ğ¹ is in the kernel of
ğœ‘ğ‘. The fact that the composition of ğœ‘ğ‘ and ğœ“ğ‘ is the exponentiation
to the ğ‘ is crucial in the proof.
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2678set Ëœğ‘ = 2ğœ†ğµ
that ğ‘ğ‘ â‰¡ âˆ’1 (mod 4) and (ğ‘/ğ‘) = âˆ’1
Setup(1ğœ†, ğ‘):
â€¢ Let ğœ‡ be the bit size of ğ‘. Pick ğ‘ a ğœ‚(ğœ†) âˆ’ ğœ‡ bits prime such
â€¢ Î”ğ¾ := âˆ’ğ‘ğ‘, Î”ğ‘ := ğ‘2Î”ğ¾
â€¢ Compute ğµ an upper bound on the order of ğ¶ğ‘™(Î”ğ¾) and
â€¢ Generate a random square ğ‘… âˆˆ ğ¶ğ‘™(Î”ğ¾)
â€¢ Compute ğ›¾ğ‘ = ğœ“ğ‘(ğ‘…)
â€¢ Set ğ¹ := (ğ‘2, ğ‘) in ğ¶ğ‘™(Î”ğ‘)
â€¢ Set ğ›¾ := ğ›¾ğ‘ Â· ğ¹ and compute ğº = ğœ‘ğ‘(ğ›¾)ğ‘