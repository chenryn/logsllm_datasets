# 关闭连接        conn.close()这段代码使用了"SELECT"SQL语句实现了联系人"Tom"的手机号码读取。"SELECT"语句执行后，会把结果放到"result"变量中。由于取出的结果是一个对象，因此还需要通过fetchone()函数，把对象中的一行取出，得到用户的手机号码。那在这一查找流程中，我们要重点关注的就是"SELECT"语句，它是实现读取内容的语句。在任何一个数据库中，它都是最常用的SQL语句。我们从它的结构开始分析。    SELECT phone FROM address_book WHERE name = "Tom" 这条语句的执行顺序和书写顺序是不同的，它的执行顺序是从"FROM"到"WHERE"，再到"SELECT"关键字。它们三个的含义分别是：1.       FROM：从一张表中查找数据，用于来指定查询的表。        2.       WHERE：表示查询的条件是什么。在这个例子中，查询条件是 name    字段的值为"Tom"字符串。        3.       SELECT：显示哪一列。在这个例子中，只显示 phone    这一字段的值。        "SELECT"语句按照代码中的顺序实现了电话号码的查找。当然了，这只是个非常简单的查找，而你在工作中肯定会遇到更加复杂的查找，我也会在下一讲教你怎样使用Python 来为更加复杂的查询编写高效的代码。如果你想要更加深入的学习 SELECT语句，可以参考官方文档slate-object="inline"。官方文档slate-object="inline"中会有"SELECT"中其他语句的执行顺序和功能介绍，并且还采用了流程图方式来为你介绍它的子句之间是如何进行组合的。如下图：![](Images/56fecd4ff7316830437fbeeab99ae76c.png)savepage-src="https://uploader.shimo.im/f/ohsimau6gXE485ta.png!thumbnail"}小结最后让我来为你总结一下，在本讲中，我使用了 SQLite数据库为你讲解了数据库对比文本文件和 Excel的优势，它在存储结构化数据方面，已经作为了业界的标准解决方案。想要用好SQLite，你还要掌握数据库的四个操作步骤，那就是：1.       连接数据库文件        2.       创建游标        3.       执行 SQL 语句        4.       关闭游标和连接        这四个步骤是实现一切数据库操作的基础，在掌握四个操作步骤的基础上实现数据操作的SQL 语句，包括增删改查四种操作，在本讲中我为你讲解了如何使用 SQL 实现SQLite 的读写，下一讲将为你讲解更加复杂的 SQL 语句以及修改和删除的 SQL语句。 查找和写入作为最常用的 SQL语句，是需要你重点掌握的。除了存储通讯录数据，像是我们从网络批量下载的数据，以及工作中的员工信息表等数据都可以采用SQLite存放。它将是以后你存储结构化数据最实用的工具。思考题按照惯例，我为你出一道思考题，如果使用 SELECT语句查询到的结果不止一条，使用 fetchone()函数得到的是什么样的呢？你能否通过官方文档再找到获得多条查询结果的函数呢？欢迎把你的想法和思考写在留言区，我们一起交流讨论。如果这节课在数据保存上帮你提高了办公效率，那也欢迎你把课程分享给你的朋友或同事，我们一起做职场上的效率人。
# 22｜SQLite文本数据库：如何进行数据管理（下）？你好，我是尹会生。在上节课，我提到了使用比较简单的 SQL 来操作SQLite，并为你讲解了数据库的基本操作步骤。不过当你的程序功能越来越强大的时候，随之而来的就是代码的复杂度越来越高。像是上一讲，我们在进行SQLite数据库搜索的时候，你需要建立连接、申请游标对象，才能进行查询。而这些准备工作，我们更希望在程序运行的时候就准备好，这样就不必多次重复编写。而且对数据库进行增删改查能够通过尽可能少的 SQL来实现数据库的操作。那么能实现这一功能的就是**类**。通过类，你可以为越来越复杂的程序编写结构更清晰的代码。同时也能更好地把SQLite的增删改查封装成一个独立的对象，便于你调用数据库时能进行数据持久化。那么今天这节课，我就带你使用类来实现 SQLite数据的读取和写入。与此同时，我会继续以通讯录为例，来给你讲解，如果使用了比较复杂的SQL 来操作 SQLite时，怎么合理组织代码结构，让你更优雅地书写代码。**使用类实现 SQLite 的读写**由于类这个概念比较抽象，我还是采用老办法帮你理解它，我将使用"类"对SQLite 的读写 SQL 操作进行封装，并将类进行实例化以后进行调用，得到SQLite中的通讯录数据。我先把代码贴出来，供你参考：    import sqlite3    import pathlib    class OptSqlite(object):        def __init__(self, dbname = "new.db"):            """            :param dbname  数据库名称            """            self.dir = pathlib.PurePath(__file__).parent            self.db = pathlib.PurePath(self.dir, dbname)            self.conn = sqlite3.connect(self.db)            self.cur = self.conn.cursor()        def close(self):            """            关闭连接            """            self.cur.close()            self.conn.close()        def get_one_phone(self, username):            """            获取一个联系人的电话            """            self.get_user_phone_sql = f"""                SELECT phone FROM address_book WHERE name = "{username}" """            try:                self.result = self.cur.execute(self.get_user_phone_sql)                return self.result.fetchone()            except Exception as e:                print(f"失败原因是：{e}")        def set_one_phone(self, name, phone):            """            增加一个联系人            """            self.set_user_phone_sql = '''INSERT INTO address_book              VALUES (?, ?, ?)'''            self.v =  (2, str(name), int(phone))            try:                self.cur.execute(self.set_user_phone_sql, self.v)                self.conn.commit()            except Exception as e:                print(f"失败原因是：{e}")    if __name__ == "__main__":        my_query = OptSqlite("contents.db")                my_query.set_one_phone("Jerry","12344445555")                phone = my_query.get_one_phone("Tom")        phone2 = my_query.get_one_phone("Jerry")                    my_query.close()        print(phone)        print(phone2)    
# 输出结果    