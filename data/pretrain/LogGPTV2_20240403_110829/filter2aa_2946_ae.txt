DC（Device Contexts）：设备上下文对象（内存）
图像（图形）对象：决定你要画的东西的属性
滴水逆向课程笔记  –  Win32
窗口的本质  –  62
14.2 进行简单的绘画
如下代码就是在桌面中进行绘画，具体代码意思都在注释中了，不了解的可以在MSDN Library中查询：
滴水逆向课程笔记  –  Win32
窗口的本质  –  63
#include 
1
2
int main(int argc, char* argv[])
3
{
4
    HWND hWnd; // 窗口句柄
5
    HDC hDc; // 设备上下文对象
6
    HPEN hPen; // 画笔
7
    // 1. 设备对象，要绘画的位置
8
    // 设置为NULL则表示在桌面中绘画
9
    hWnd = (HWND)NULL;
10
11
    // 2. 获取设备的上下文对象（DC）
12
    /*
13
        语法格式：
14
        HDC GetDC(
15
            HWND hWnd   // handle to window
16
        );
17
    */
18
    hDc = GetDC(hWnd);
19
20
    // 3. 创建画笔，设置线条的属性
21
    /*
22
        语法格式：
23
        HPEN CreatePen(
24
            int fnPenStyle,    // pen style
25
            int nWidth,        // pen width
26
            COLORREF crColor   // pen color
27
        );
28
    */
29
    hPen = CreatePen(PS_SOLID, 5, RGB(0xFF,00,00)); // RGB表示红绿蓝，红绿蓝的组合就可以组成新的一种颜色。
30
31
    // 4. 关联
32
    /*
33
        语法格式：
34
        HGDIOBJ SelectObject(
35
            HDC hdc,          // handle to DC
36
            HGDIOBJ hgdiobj   // handle to object
37
        );
38
    */
39
    SelectObject(hDc, hPen);
40
41
    // 5. 开始画线
42
    /*
43
        语法格式：
44
        BOOL LineTo(
45
            HDC hdc,    // device context handle
46
            int nXEnd,  // x-coordinate of ending point
47
            int nYEnd   // y-coordinate of ending point
48
        );
49
    */
50
    LineTo(hDc, 400, 400);
51
52
    // 6. 释放资源
53
    DeleteObject(hPen);
54
    ReleaseDC(hWnd, hDc);
55
滴水逆向课程笔记  –  Win32
窗口的本质  –  64
56
    return 0;
57
}
58
滴水逆向课程笔记  –  Win32
消息队列  –  65
15 消息队列
15.1 什么是消息
当我们点击鼠标的时候，或者当我们按下键盘的时候，操作系统都要把这些动作记录下来，存储到一个结构体
中，这个结构体就是消息。
15.2 消息队列
每个线程只有一个消息队列。
15.3 窗口与线程
当我们把鼠标点击左边窗口关闭按钮，为什么它会关闭，这个关闭（坐标、左右键...）操作系统会封装到结构
体里（消息），那么这个消息如何精确的传递给对应进程的线程呢？
滴水逆向课程笔记  –  Win32
消息队列  –  66
那是因为操作系统可以将坐标之类的作为索引，去找到对应的窗口，窗口在内核中是有窗口对象的，而这个窗
口对象就会包含一个成员，这个成员就是线程对象的指针，线程又包含了消息，所以这样一个顺序就很容易理
解了。
注意：一个线程可以有多个窗口，但是一个窗口只属于一个线程。
滴水逆向课程笔记  –  Win32
第一个Windwos程序  –  67
16 第一个Windwos程序
16.1 新建Windows窗口程序项目
VC6新建工程，选择Win32 Application，下一步选择一个简单的Win32的程序。
控制台程序是从Main函数为入口开始执行的，而Win32窗口程序是从WinMain函数开始执行的。
新建的项目里的头文件已经把需要用到的Windows.h头文件包含了：
滴水逆向课程笔记  –  Win32
第一个Windwos程序  –  68
1.
2.
3.
16.2 WinMain函数
WinMain函数作为Win32窗口程序的入口函数，我们需要了解一下其函数的参数，语法格式如下：
参数解释：
HINSTANCE hInstance，这是一个句柄，在Win32中H开头的通常都是句柄，这里的HINSTANCE是指向模
块的句柄，实际上这个值就是模块在进程空间内的内存地址；
HINSTANCE hPrevInstance，该参数永远为空NULL，无需理解；
第三、第四个参数（LPSTR lpCmdLine、int nCmdShow）是由CreateProcess的LPTSTR lpCommandLine、
LPSTARTUPINFO lpStartupInfo参数传递的。
16.3 调试信息输出
我们在窗口程序中想要输出信息就不可以使用printf了，我们可以使用另外一个函数OutputDebugString，其语
法格式如下：
int WINAPI WinMain(
1
  HINSTANCE hInstance,      // handle to current instance
2
  HINSTANCE hPrevInstance,  // handle to previous instance 
3
  LPSTR lpCmdLine,          // command line
4
  int nCmdShow              // show state
5
);
6
void OutputDebugString(
1
  LPCTSTR lpOutputString
2
);
3
滴水逆向课程笔记  –  Win32
第一个Windwos程序  –  69
传参就是一个LPCTSTR类型（字符串），但是需要注意的是这个函数只能打印固定字符串，不能打印格式化的
字符串，所以如果需要格式化输出，需要在这之前使用sprintf函数进行格式化（自行查阅），这里我们可以尝
试输出当前模块的句柄：
运行该代码就会在Debug输出框中发现打印的字符串，这就是一个内存地址：
#include "stdafx.h"
1
2
int APIENTRY WinMain(HINSTANCE hInstance,
3
                     HINSTANCE hPrevInstance,
4
                     LPSTR     lpCmdLine,
5
                     int       nCmdShow)
6
{
7
    // TODO: Place code here.
8
    DWORD dwAddr = (DWORD)hInstance;
9
10
    char szOutBuff[0x80];
11
    sprintf(szOutBuff, "hInstance address: %x \n", dwAddr); // 该函数需要包含stdio.h头文件
12
    OutputDebugString(szOutBuff);
13
14
    return 0;
15
}
16
滴水逆向课程笔记  –  Win32
第一个Windwos程序  –  70
16.4 创建窗口程序
如下代码创建了一个简单的窗口程序：
滴水逆向课程笔记  –  Win32
第一个Windwos程序  –  71
// Windows.cpp : Defines the entry point for the application.
1
//
2
3
#include "stdafx.h"
4
5
// 窗口函数定义
6
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
7
    // 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的
8
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
9
}
10
11
int APIENTRY WinMain(HINSTANCE hInstance,
12
                     HINSTANCE hPrevInstance,
13
                     LPSTR     lpCmdLine,
14
                     int       nCmdShow)
15
{
16
    char szOutBuff[0x80];
17
18
    // 1. 定义创建的窗口(创建注册窗口类)
19
    TCHAR className[] = TEXT("My First Window");
20
    WNDCLASS wndClass = {0};
21
    // 设置窗口背景色
22
    wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND;
23
    // 设置类名字
24
    wndClass.lpszClassName = className;
25
    // 设置模块地址
26
    wndClass.hInstance = hInstance;
27
    // 处理消息的窗口函数
28
    wndClass.lpfnWndProc = WindowProc; // 不是调用函数，只是告诉操作系统，当前窗口对应的窗口回调函数是什么
29
    // 注册窗口类
30
    RegisterClass(&wndClass);
31
32
    // 2. 创建并显示窗口
33
    // 创建窗口
34
    /*
35
    CreateWindow 语法格式：
36
    HWND CreateWindow(
37
        LPCTSTR lpClassName,  // registered class name 类名字
38
        LPCTSTR lpWindowName, // window name 窗口名字
39
        DWORD dwStyle,        // window style 窗口外观的样式
40
        int x,                // horizontal position of window 相对于父窗口x坐标
41
        int y,                // vertical position of window 相对于父窗口y坐标
42
        int nWidth,           // window width 窗口宽度：像素
43
        int nHeight,          // window height 窗口长度：像素
44
        HWND hWndParent,      // handle to parent or owner window 父窗口句柄
45
        HMENU hMenu,          // menu handle or child identifier 菜单句柄
46
        HINSTANCE hInstance,  // handle to application instance 模块
47
        LPVOID lpParam        // window-creation data  附加数据
48
    );
49
    */
50
    HWND hWnd = CreateWindow(className, TEXT("窗口"), WS_OVERLAPPEDWINDOW, 10, 10, 600, 300, NULL, 
NULL, hInstance, NULL);
51
52
    if (hWnd == NULL) {
53
        // 如果为NULL则窗口创建失败，输出错误信息
54
滴水逆向课程笔记  –  Win32
第一个Windwos程序  –  72
如下图是窗口程序创建执行流程：
        sprintf(szOutBuff, "Error: %d", GetLastError());
55
        OutputDebugString(szOutBuff);
56
        return 0;
57
    }
58
59
    // 显示窗口
60
    /*
61
    ShowWindow 语法格式：
62
    BOOL ShowWindow(
63
        HWND hWnd,     // handle to window 窗口句柄
64
        int nCmdShow   // show state 显示的形式
65
    );
66
    */
67
    ShowWindow(hWnd, SW_SHOW);
68
69
    // 3. 接收消息并处理
70
    /*
71
    GetMessage 语法格式：
72
    BOOL GetMessage(
73
        LPMSG lpMsg,         // message information OUT类型参数，这是一个指针
74
        // 后三个参数都是过滤条件
75
        HWND hWnd,           // handle to window 窗口句柄，如果为NULL则表示该线程中的所有消息都要
76
        UINT wMsgFilterMin,  // first message 第一条信息
77
        UINT wMsgFilterMax   // last message 最后一条信息
78
    );
79
    */
80
    MSG msg;
81
    BOOL bRet;
82
    while( (bRet = GetMessage( &msg, NULL, 0, 0 )) != 0)
83
    { 
84
        if (bRet == -1)
85
        {
86
            // handle the error and possibly exit
87
            sprintf(szOutBuff, "Error: %d", GetLastError());
88
            OutputDebugString(szOutBuff);
89
            return 0;
90
        }
91
        else