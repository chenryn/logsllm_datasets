malicious TCP connections, executables which match a
virus signature, and ﬂagged PIDs. Using these rules,
both dynamic and static policy elements can be created.
Dynamic policies are created from alerts generated by
other systems, such as IDS’s or antivirus scanners. For
instance, outbound ﬁrewall rule violations might trigger
the generation of a policy to terminate any process at-
tempting to communicate which a suspicious IP address.
Users can also deﬁne static policies which have a base
of assertions that are always enforced, regardless of the
type of malware. For example, perhaps some processes
should never have child processes under normal execu-
tion, or perhaps it is not expected for any process to have
a sensitive ﬁle open. These assertions can be encoded
as static policies, to which dynamic policies are added
as attacks are detected. The combination of static and
dynamic policy rules allows for detection of a wide vari-
ety of malware, including malware which may run exclu-
sively in memory, such as the meterpreter metasploit
payload [9].
These changes to CRIU source code are mostly addi-
tions at the point when information about ﬁles, connec-
tions, or process identiﬁers are being dumped to disk.
Essentially, we check if there are any matching policy el-
ements for each of these resources, and if there are, the
PIDs of relevant processes are written to an additional
protobuf formatted ﬁle named omit.img. It is important
to note that no process dump information is discarded
in this phase; it is simply logged for later action. This
is so that information about potentially malicious pro-
cesses can be forensically analyzed at a later time, but
not restored.
were
also
to
the
Modiﬁcations
the
made
lxc-checkpoint command to accept
same
parameters as the ones that were added for CRIU.
Speciﬁcally, parameter processing for the --policy
(path to the policy to use) and --base-path (path to
the container ﬁlesystem) parameters was added. This
required 44 lines of C code added across 3 ﬁles. The
modiﬁed version of LXC is available on GitHub as
well2.
4.2 Restore
The core modiﬁcations for the CRIU restore process en-
sure that malicious processes ﬂagged by the checkpoint
process in omit.img are not restored. This is as simple
as iterating over this list of omitted processes and remov-
ing the corresponding PIDs. Additionally, the way that
missing ﬁles are handled by vanilla CRIU is changed.
Vanilla CRIU will crash immediately if any process is
missing a referenced ﬁle. Instead, CRIU-MR is adjusted
to simply omit any process with a missing ﬁle refer-
ence. This is performed by checking to ensure ﬁles refer-
enced by ﬁle descriptors are actually present on the target
ﬁlesystem during the reconstruction of the container pro-
cess tree. In the case of a process with an omitted parent,
the child is omitted as well. These changes ensure that as
the container is restored on the backup ﬁlesystem, pro-
cesses referencing potentially malicious ﬁles that are no
longer present will be gracefully omitted during the re-
store, even if these processes were not directly ﬂagged
via a policy rule. This will not harm non-malware pro-
cesses given the “mostly-static” ﬁlesystem assumption.
4.3 Architecture
In order to automatically trigger the checkpoint/restore
process when an infection is detected and allow for man-
ual triggering, we write a simple program called the re-
covery agent. The recovery agent listens on a given
TCP port for JSON formatted input used to generate a
policy.
It can receive these input messages from local
processes or even other hosts, as demonstrated in Fig-
ure 1. Note that this architecture requires no integra-
tion on the part of third-party IDS/IPS vendors; all that
is required to integrate an alert system with the recov-
ery agent is a small parsing script for turning the sys-
tem’s alerts into JSON and forwarding these alerts to the
2https://github.com/ashtonwebster/lxc
1202    27th USENIX Security Symposium
USENIX Association
The policy is then compiled as a protobuf formatted ﬁle
which is read by our modiﬁed version of CRIU. Next, a
folder is created for storing the checkpoint/restore data
generated by CRIU.
During the subsequent checkpoint/restore, the con-
tainer will be unavailable for a few seconds. To avoid
the loss of any packets arriving during this time, it may
be necessary to use the iptables target NFQUEUE on the
container host to buffer packets. Essentially, NFQUEUE
allows trafﬁc to be sent to userspace for processing, and
in this case it can be used to buffer packets while the mal-
ware recovery process is being executed. We provide a
code listing and further description in appendix B.
CRIU Checkpoint: CRIU dumps the relevant image
data for all processes (including malicious processes) on
the container. Processes will be ﬂagged as malware if
they match a speciﬁed policy and are written to disk in a
protobuf ﬁle named omit.img.
Filesystem Restore: In order to allow for fast ﬁlesys-
tem restore, CRIU-MR maintains two backups. One
backup, which we denote the “swap backup”, is sim-
ply renamed to match the Linux container root ﬁlesystem
path via the mv command. The other backup, denoted the
“master backup”, is used to restore the swap backup so
this process can be repeated. Using these backups, the
ﬁlesystem for the container is restored with a few simple
shell commands:
mv $ l x c _ p a t h / r o o t f s $ i n f e c t e d _ f s _ d i r / i n f e c t e d f s
mv $ b a c k u p _ p a t h / r o o t f s . swap_backup \
$ l x c _ p a t h / r o o t f s
One beneﬁt of this method is that the infected ﬁlesys-
tem can be later inspected (with the assistance of the
CRIU-MR log ﬁles) to collect malware samples and de-
tect malicious ﬁlesystem changes.
CRIU Restore: At this point, the CRIU restore of
the checkpointed non-malware processes begins. Dur-
ing construction of the process tree, processes may be
omitted for two reasons. First, processes which refer-
ence missing ﬁles are omitted. Next, processes contained
in the omit.img ﬁle previously created are omitted. Any
children of these processes are also ignored. Restore then
continues as normal, with established TCP connections
also being restored.
Cleanup: Finally, a few cleanup tasks are performed to
return the system to its normal state. If NFQUEUE was
used, the process is stopped so that buffered packets are
forwarded along to the container. The swap backup for
the container is also restored from the “master” backup
to allow for a quick ﬁlesystem restore in the event of an-
other breach using the following command:
cp $ b a c k u p _ p a t h / r o o t f s . m a s t e r _ b a c k u p \
$ b a c k u p _ p a t h / r o o t f s . backup_swap
The preparation, CRIU checkpoint, ﬁlesystem restore,
CRIU restore, and cleanup steps are all automated via the
Figure 1: The CRIU recovery agent can receive alerts
from a variety of sources, both at the host and network
level.
CRIU-MR agent. The produced JSON messages consti-
tute dynamic policy rules for triggering a checkpoint/re-
store event and are added to any static rules in the policy
ﬁle used by default. This combined policy is then written
in the protobuf format and passed to CRIU to perform a
checkpoint/restore. The recovery agent also handles the
ﬁlesystem restore, preparation, and cleanup operations
needed to perform quick malware recovery, which will
be covered in more detail below. The agent code was im-
plemented in python and is available as a separate open
source GitHub repository3. With these components, a
typical malware recovery follows these steps:
Infection: Malware is introduced to the system. This
may be through a backdoor, network exploit, or other
method. At some point it begins executing and may mod-
ify the ﬁlesystem.
Detection: As a result of the malware on the system,
one or more “triggers” may send an alert to the recovery
agent. The recovery agent creates a JSON ﬁle specifying
the trigger type (e.g. AV scanner, IDS, IPS) and relevant
information (e.g. ﬁlename, TCP connection). This JSON
ﬁle is used to build the policy used by CRIU for mali-
cious process removal. We have created example JSON
generators for Snort [17] (a rule based IDS) and ClamAV
[16] (an antivirus scanner). The example code used to
generate the JSON alerts and send them to the recovery
agent are shown in Appendix A.
Preparation: The recovery agent for CRIU-MR lis-
tens on a TCP port for a JSON message. Upon receipt
of a message, a new rule for process omission will be
generated and added to the policy ﬁle of existing rules.
3https://github.com/ashtonwebster/CRIU-MR-agent
USENIX Association
27th USENIX Security Symposium    1203
CRIU-MR recovery agent program. Thus, the response
to malware can be completely independent of human in-
teraction for rapid recovery from attacks.
5 Experiments
We conduct experiments to address two questions. First,
we seek to answer the question “How long does it take to
successfully remove various malware from the system?”
In order to answer this question, we measure the recovery
time for six different malware programs. Then, we ad-
dress the question “What is the availability impact of the
recovery process on a running service?”. To answer this
question, we devise an experiment using Apache Bench-
mark [1] to simulate HTTP requests to an Apache web
server running on the container. We observe the impact
of the checkpoint/restore process on the active connec-
tions and ﬁnd that no connections fail while the maxi-
mum response time increases by only a few seconds. All
experiments were run on a Virtual Machine with 4 In-
tel Xeon 2.4GHz cores and 4 GB RAM running Ubuntu
16.04 hosting a linux container. The container used ran
Ubuntu 16.04 with AMD64 architecture.
5.1 Experiment I: Malware Recovery Du-
ration
For our ﬁrst experiment, we measure the duration of the
recovery process and ensure that all malware processes
and ﬁles are removed. To conduct the experiment, we
collect six Linux malware samples.
• linux_lady: This malware was written in Go and
attempts to mine bitcoin using the resources of in-
fected computers. It primarily works by download-
ing the mining script payload and adding itself as
a cronjob to the victim host. This sample was col-
lected from the Contagio malware repository[2].
• ms_bind_shell: This is a simple payload from the
Metasploit framework [9] which binds on a spec-
iﬁed port and IP and provides shell access to the
attacker.
• ms_reverse_shell: This is another malware from the
Metasploit framework which creates a reverse shell
by initiating a connection with the speciﬁed host.
The reverse shell method is often more effective
than the bind shell method in practice because it can
more easily evade ﬁrewalls by initiating the connec-
tion rather than accepting a connection to an unused
port.
• wipefs: This malware was found on the Hybrid
It uses the stratum mining
Analysis website [5].
protocol to mine bitcoin on the victim’s machine.
• Linux.Agent: This malware, ﬁrst discovered by
Tim Strazzere [29] attempts to exﬁltrate either the
/etc/shadow ﬁle with encrypted passwords (if
root access is available) or the /etc/passwd ﬁle
(otherwise).
• goahead_ldpreload: This is actually a vulnerabil-
ity in GoAhead [36], a lightweight embedded web-
server and not a malware sample. However, we are
able to inject a long-running malware script via the
remote code execution vulnerability explained by
Daniel Hodson of Elttam [24] with associated CVE-
2017-17562 [10]. Unlike the other samples, this
is an example of a benign process being infected
with a malicious payload (instead of a malware bi-
nary being executed). To simulate a long-running
malicious payload, we remotely execute commands
which create a ﬁle each second on the ﬁlesystem,
but any arbitrary C code can be executed.
Each experiment consists of the following: ﬁrst, an ssh
session is started, and the malware is started as root in the
background and using the unix command nohup to avoid
termination when the ssh session ends. The exception is
the goahead_ldpreload exploit, which begins by running
the GoAhead server as root and remotely executing the
malicious payload). Next, detection is simulated by trig-
gering the checkpoint/restore process with a JSON ﬁle
specifying the executable ﬁle to omit4. After 3 seconds
of allowing the malicious processes to execute, the re-
covery process is triggered, as described in §4. The tim-
ing measurements are taken by using the timeit library
in Python [11]. Each malware is removed 10 times with
timing results shown in Figure 2, and the time for each
stage of checkpointing is shown in Table 1. In addition
to an experiment for each malware sample, we also run
the malware recovery process with no malware present
for comparison (labeled as “None”).
By restoring the infected ﬁlesystem to a safe backup
state, we observe that any ﬁle state changes made by
the malware were undone. We also observed that for
each experiment, each malware process was successfully
omitted and no longer running on the restored container.
We acknowledge that it is possible that the malware also
changed memory or features of other restored processes,
and we discuss this in more detail in the Discussion sec-
tion (§6).
The results for this experiment suggest that the type
of malware does not affect the time for recovery in a no-
ticeable way.
In fact, the removal of malware appears
to match the time taken for a checkpoint and restore
4For
that
the
code
execution
goahead_ldpreload
re-
mote
process
/root/goahead/test/cgi-bin/cgitest handling CGI scripts,
which is the executable name used in the policy for that exploit.
we
occurs
observe
in
a
separate
1204    27th USENIX Security Symposium
USENIX Association
using ssh and trigger the recovery process in a method
similar to Experiment I. The results of this process are
summarized in Table 2.
In each experiment, all requests complete successfully.
We observe that relative to the median request comple-
tion time, the “Max Request Time” for each ﬁle tends to
increase by an amount of time comparable to the time it
takes for CRIU-MR to execute as measured in Experi-
ment I. These results show that while some connections
are subjected to a latency increase of 3-6 seconds by the
checkpoint/restore process, CRIU-MR still ensures that
each request succeeds.
Figure 2: Boxplots summarizing duration of malware re-
covery process for six different malware.
6 Discussion and Limitations
Table 1: Mean (Std. Dev.) Time per Recovery Step
Step
Prep. Time
Checkpoint Time
FS Swap Time
Restore Time
Total Time
Time (s)
0.022 (0.003)
2.157 (0.202)
0.012 (0.005)
0.572 (0.110)