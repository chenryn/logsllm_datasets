However, issuing unneeded capabilities can increase an at-
tacker’s options. To avoid this, we use a static analysis of
target code to determine if the return address generated by
a call is deﬁnitely discarded before being used by a return
instructions.
In the simplest case, a discard will happen
through the use of a pop instruction that pops oﬀ the return
address at the top of the stack. More generally, the loca-
tion containing the return address may be overwritten, or
the stack pointer incremented to a value greater than this
location. If one of these properties holds on every execution
path starting at the target of the call, then we conclude that
the return address will not be used as the target of a return.
After identifying unintended calls, the remaining calls are
instrumented for storing the return address on RCAP-stack.
For unintended calls, the RCAP-stack is left unchanged.
3.2 Returns
Returning to a code location is permitted only if the pro-
gram possesses the capability to do so. We check RCAP-
stack for this capability. Typically, this capability originates
at the most recent call instruction, but there are instances
where the return address is pushed by other means. We call
such returns as non-standard returns.
One example of a non-standard return is shown in Fig-
ure 1. The return instruction (at 0x146bb) uses a return
address generated by a mov instruction (at 0x146b4) rather
than a call. This code snippet is taken from GNU’s dy-
namic loader, and the non-standard return is used for dy-
namic function dispatch after resolving a symbol. Speciﬁ-
cally, when a function from another module is called for the
very ﬁrst time, its execution traps to the dynamic loader for
symbol resolution. After the loader has resolved the address
for the function and cached the result in original module’s
Global Oﬀset Table (GOT), control should be directed to
the called function. This is achieved by ﬁrst moving the
function address (stored in eax register) to the top of stack
using a mov, and then issuing a return1, as shown in Figure 1.
Note that while this non-standard return achieves the ef-
fect of an indirect jump, it does so without using any register
1The argument 0xc to the ret instruction speciﬁes the number
of additional bytes that should be popped oﬀ the stack.
(other than the stack pointer), and moreover, deallocates the
memory location used to store the target address.
As discussed in the next section, there are a number of
such non-standard returns, scattered in diﬀerent modules.
Moreover, unlike a call, whose intended return address is
its successor, the intended target of non-standard return is
not immediately obvious. These factors motivate the static
analysis described below.
3.3 Static Analysis of Non-standard Returns
The distinction between a standard and non-standard re-
turn is the return address being used. The return address
used by a standard return is pushed by the call instruction
in its caller, and not modiﬁed in the callee. In contrast, re-
turn address used by a non-standard return is written to the
return address stack slot by a non-call instruction. Based on
this observation, we develop a static analysis that consists
of four main steps as discussed below.
Candidate snippet extraction. After a binary module is
disassembled, we build its CFG. We then perform a back-
ward scan on the CFG starting from each return instruction,
and going back by n instructions, with n = 30 in our imple-
mentation. These snippets are our candidates for analysis.
Each such snippet may contain multiple execution paths
to the return instruction. We analyze each path separately,
as this enables more accurate analyis. In particular, this ap-
proach avoids approximations that result from least upper
bound operations needed to handle path merges. However,
this approach introduces two problems. First, loops can lead
to an unbounded number of paths. We only consider paths
corresponding to zero and one iteration of such loops. As a
result, we may fail to discover some instances where an in-
struction inside a loop pushes a return address on the stack.
In theory, this could lead to a compatibility problem, but
in practice, it is very unlikely that such instructions occur
within a loop body. The second diﬃculty is that it is the-
oretically possible for a single instruction I to participate
in two distinct paths such that in the ﬁrst path, I pushes
a value on the stack that would be used by the return in-
struction at the end of the snippet, while it does not do so
in the second path. Note that this (unlikely) scenario does
not lead to an incompatibility: if the second execution path
were to be taken at runtime, the return capability pushed
by I would simply not be used.
Semantic analysis. The second step is to analyze the se-
mantics of each snippet by performing an abstract inter-
pretation using an abstract domain similar to that used in
Reference [38]. At the beginning of each snippet, each reg-
ister is assigned a corresponding initial symbolic value. The
program state is updated based on the semantics of each ex-
ecuted instruction. At the end of each instruction, the ab-
stract value of each register (or memory location) will consist
of simple expressions consisting of constants and initial regis-
ter values. Since we are analyzing each execution path sepa-
rately, these expressions rarely involve approximations. Our
analysis includes a simple procedure for maintaining these
expressions in a canonical form, thereby enabling equivalent
expressions to be recognized in most instances.
Non-standard return identiﬁcation. The next step is to
identify non-standard returns. After semantic analysis, the
value of stack pointer register before the return instruction
can be determined by an expression. Since it is the pointer
for the return address slot, if there is any memory write to
that location, a non-standard return is identiﬁed.
Intended control-ﬂow inference. The last step of the
analysis is to infer the intended control ﬂow for the non-
standard return. To that end, we need to ﬁrst identify the
non-call instruction that stores the values used by the re-
turn. We call such an instruction as an RAstore. Such an
instruction can be identiﬁed from the contents of memory
and registers computed by our static analysis after each in-
struction in the snippet.
In the following section, we will describe real-world non-
standard return examples identiﬁed by our analysis.
3.3.1 Non-standard return examples
Previous shadow stack solutions rely on manual identiﬁ-
cation and ad-hoc instrumentation to support non-standard
returns [15, 50, 12]. However, manual approaches are not
scalable, and/or can lead to false positives on large and
complex software. Figure 2 illustrates some of the more
prominent real-world non-standard returns identiﬁed by our
static analysis.
In this ﬁgure, upper case register names
(e.g., EAX) denote initial symbolic values, while lower case
ones (e.g., eax) denote the current contents of registers or
memory. For easier illustration, each code snippet is sim-
pliﬁed to only include the last basic block. We omit the ef-
fects on ﬂoating point registers and segment registers. Note
that our analysis results do not change when the full code
snippets are used and when eﬀects to non-general purpose
registers are captured.
The ﬁrst example is the same one as shown in Figure 1.
Our analysis indicates that the return address comes from
eax. The analysis discovers the highlighted instruction as
the one that pushes the return address.
The second example comes from setcontext(3) function
of glibc. The single argument of setcontext is a pointer
to ucontext_t structure, which is loaded to eax at the ﬁrst
instruction. Since the user context structure contains all
saved register information, most of the snippet code per-
forms the job of register restores. Particularly, the program
counter placed at oﬀset 0x4c of ucontext_t was loaded to
ecx at loction 0x3fa81. And the push instruction at 0x3fa87
pushes it as return address onto stack, which is consumed
by the return instruction at the end of the snippet. This
non-standard return and the RAstore at 0x3fa87 are identi-
ﬁed by our static analysis. Another similar case in function
swapcontext(3) from the same module, was also identiﬁed
(not shown in ﬁgure).
The third example is a snippet from one of the stack un-
winding functions in libgcc s.so.1. The code ﬁrst stores edi,
the address of landing pad (handler code) which is previ-
ously computed, to the return address slot of next frame
(0x154cd). Therefore, the following return will redirect con-
trol to the landing pad. This example also demonstrates
the power of the analysis: the store to 0x4(%ebp,%esi,1)
at 0x154cd does not “look” like a return address overwrite,
however our static analysis is able to detect it. This is also an
example why simple pattern matching based non-standard
return identiﬁcation would not work well.
Our last example is from an unwinding library libunwind.
The snippet is simple, and similar to the ﬁrst example, but
used for implementing longjmp.
We note that although the non-standard return compati-
bility problem has been recognized by many in the literature
[15, 12], only the ﬁrst and third of these four examples have
Code Snippet
;; #1 /lib/ld-2.15.so
0x146b0 popl %edx
0x146b1 movl (%esp),%ecx
0x146b4 movl %eax,(%esp)
0x146b7 movl 0x4(%esp),%eax
0x146bb ret $0xc
;; #2 /lib/i386-linux-gnu/libc.so.6
0x3fa73 movl 0x4(%esp),%eax
0x3fa77 movl 0x60(%eax),%ecx
0x3fa7a ﬂdenvl (%ecx)
0x3fa7c movl 0x18(%eax),%ecx
0x3fa7f movl %ecx,%fs
0x3fa81 movl 0x4c(%eax),%ecx
0x3fa84 movl 0x30(%eax),%esp
0x3fa87 pushl %ecx
0x3fa88 movl 0x24(%eax),%edi
0x3fa8b movl 0x28(%eax),%esi
0x3fa8e movl 0x2c(%eax),%ebp
0x3fa91 movl 0x34(%eax),%ebx
0x3fa94 movl 0x38(%eax),%edx
0x3fa97 movl 0x3c(%eax),%ecx
0x3fa9a movl 0x40(%eax),%eax
0x3fa9d ret
;; #3 /lib/i386-linux-gnu/libgcc s.so.1
0x154cb movl %esi,%ecx
0x154cd movl %edi,
0x4(%ebp,%esi,1)
0x154d1 addl $0x10,%esp
0x154d4 leal 0x4(%ebp,%ecx,1),%ecx
0x154d8 movl -0x14(%ebp),%eax
0x154db movl -0x10(%ebp),%edx
0x154de movl -0xc(%ebp),%ebx
0x154e1 movl -0x8(%ebp),%esi
0x154e4 movl -0x4(%ebp),%edi
0x154e7 movl 0x0(%ebp),%ebp
0x154ea movl %ecx,%esp
0x154ec ret
;; #4 /usr/lib/libunwind-setjmp.so
0x674 pushl %eax
0x675 movl %edx,%eax
0x677 ret
Semantics Equations
eax = *(ESP+8)
edx = *ESP
ecx = *(ESP+4)
esp = ESP + 4
*(ESP+4) = EAX
ra = *esp
= *(ESP+4) = EAX
eax = *(*(ESP+4)+64)
edx = *(*(ESP+4)+56)
ecx = *(*(ESP+4)+60)
ebx = *(*(ESP+4)+52)
esi = *(*(ESP+4)+40)
edi = *(*(ESP+4)+36)
ebp = *(*(ESP+4)+44)
esp = *(*(ESP+4)+48)-4
*(*(*(ESP+4)+48)-4)
= *(*(ESP+4)+76)
ra = *esp
= *(*(*(ESP+4)+48)-4)
= *(*(ESP+4)+76)
eax = *(EBP-20)
edx = *(EBP-16)
ecx = ESI+EBP+4
edx = *(EBP-12)
esi = *(EBP-8)
edi = *(EBP-4)
ebp = *EBP
esp = ESI+EBP+4
*(ESI+EBP+4) = EDI
ra = *esp
= *(ESI+EBP+4)
= EDI
eax = EDX
esp = ESP-4
*(ESP-4) = EAX
ra = *esp
= *(ESP-4) = EAX
Figure 2: Code snippets and their analysis results
seen manual handling [15]. In contrast, our static analysis
systematically identiﬁes all of them, and serves as a basis
for automatic instrumentation.
3.4 Discussion
Since that our static analysis is local, it can fail to identify
non-standard returns when the RAstore instruction is far
away from the return. If this assumption were to be violated,
we can address it by strengthening the analysis, or using
manual annotations. As mentioned before, we have not had
to do this so far in our implementation.
4. Enforcing Intended Control Flow
In this section, we describe our approach for enforcing
intended control-ﬂow using static binary instrumentation.
A key component of our design is its support for standard
as well as “non-standard” threading mechanisms in order to
provide better compatibility with a wide range of software.
Finally, we describe the protection of the RCAP-stack to
ensure that the same mechanisms used to corrupt the main
stack cannot corrupt the RCAP-stack.
4.1
Instrumentation-based Enforcement
Intended control ﬂow enforcement is realized by instru-
menting calls, RAstores and returns. Both calls2 and RA-
2As discussed earlier, we avoid instrumenting calls that are de-