title:Authenticated Network Time Synchronization
author:Benjamin Dowling and
Douglas Stebila and
Greg Zaverucha
Authenticated Network Time Synchronization
Benjamin Dowling, Queensland University of Technology; Douglas Stebila,  
McMaster University; Greg Zaverucha, Microsoft Research
 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/dowling
This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Authenticated Network Time Synchronization
Benjamin Dowling
Queensland University of Technology
Douglas Stebila
McMaster University
PI:EMAIL
PI:EMAIL
Greg Zaverucha
Microsoft Research
PI:EMAIL
Abstract
The Network Time Protocol (NTP) is used by many
network-connected devices to synchronize device time
with remote servers. Many security features depend on the
device knowing the current time, for example in deciding
whether a certiﬁcate is still valid. Currently, most services
implement NTP without authentication, and the authen-
tication mechanisms available in the standard have not
been formally analyzed, require a pre-shared key, or are
known to have cryptographic weaknesses. In this paper
we present an authenticated version of NTP, called ANTP,
to protect against desynchronization attacks. To make
ANTP suitable for large-scale deployments, it is designed
to minimize server-side public key operations by infre-
quently performing a key exchange using public key cryp-
tography, then relying solely on symmetric cryptography
for subsequent time synchronization requests; moreover,
it does so without requiring server-side per-connection
state. Additionally, ANTP ensures that authentication
does not degrade accuracy of time synchronization. We
measured the performance of ANTP by implementing it
in OpenNTPD using OpenSSL. Compared to plain NTP,
ANTP’s symmetric crypto reduces the server throughput
(connections/second) for time synchronization requests
by a factor of only 1.6. We analyzed the security of ANTP
using a novel provable security framework that involves
adversary control of time, and show that ANTP achieves
secure time synchronization under standard cryptographic
assumptions; our framework may also be used to analyze
other candidates for securing NTP.
Keywords: time synchronization, Network Time Pro-
tocol (NTP), provable security, network security
1
Introduction
The Network Time Protocol (NTP) is one of the Internet’s
oldest protocols, dating back to RFC 958 [15] published
in 1985. In the simplest NTP deployment, a client device
sends a single UDP packet to a server (the request), who
responds with a single packet containing the time (the
response). The response contains the time the request was
received by the server, as well as the time the response
was sent, allowing the client to estimate the network delay
and set their clock. If the network delay is symmetric, i.e.,
the travel time of the request and response are equal, then
the protocol is perfectly accurate. Accuracy means that
the client correctly synchronizes its clock with the server
(regardless of whether the server clock is accurate in the
traditional sense, e.g., synchronized with UTC).
The importance of accurate time for security. There
are many examples of security mechanisms which (often
implicitly) rely on having an accurate clock:
• Certiﬁcate validation in TLS and other protocols.
Validating a public key certiﬁcate requires conﬁrm-
ing that the current time is within the certiﬁcate’s
validity period. Performing validation with a slow
or inaccurate clock may cause expired certiﬁcates to
be accepted as valid. A revoked certiﬁcate may also
validate if the clock is slow, since the relying party
will not check for updated revocation information.
• Ticket veriﬁcation in Kerberos. In Kerberos, authen-
tication tickets have a validity period, and proper
veriﬁcation requires an accurate clock to prevent
authentication with an expired ticket.
• HTTP Strict Transport Security (HSTS) policy du-
ration. HSTS [10] allows website administrators to
protect against downgrade attacks from HTTPS to
HTTP by sending a header to browsers indicating
that HTTPS must be used instead of HTTP. HSTS
policies specify the duration of time that HTTPS
must be used. If the browser’s clock jumps ahead,
the policy may expire re-allowing downgrade attacks.
A related mechanism, HTTP Public Key Pinning [7]
also relies on accurate client time for security.
For clients who set their clocks using NTP, these se-
curity mechanisms (and others) can be attacked by a
USENIX Association  
25th USENIX Security Symposium  823
network-level attacker who can intercept and modify NTP
trafﬁc, such as a malicious wireless access point or an
insider at an ISP. In practice, most NTP servers do not
authenticate themselves to clients, so a network attacker
can intercept responses and set the timestamps arbitrarily.
Even if the client sends requests to multiple servers, these
may all be intercepted by an upstream network device
and modiﬁed to present a consistently incorrect time to
a victim. Such an attack on HSTS was demonstrated by
Selvi [28], who provided a tool to advance the clock of
victims in order to expire HSTS policies. Malhotra et
al. [12] present a variety of attacks that rely on NTP being
unauthenticated, further emphasizing the need for authen-
ticated time synchronization. (Conﬁdentiality, however,
is not a requirement for time synchronization, since all
time synchronization is public. Similarly, client-to-server
authentication is not a goal.)
NTP security today.
Early versions of NTP had no
standardized authentication method. NTPv3 added an
authentication method using pre-shared key symmetric
cryptography. An extension ﬁeld in the NTP packet added
a cryptographic checksum, computed over the packet.
In NTPv3 negotiation of keys and algorithms must be
done out-of-band. For example, NIST offers a secure
time server, and (symmetric) keys are transported from
server to client by postal mail [21]. Establishing pre-
shared symmetric keys with billions of client PCs and
other NTP-synchronizing devices would be impractical.
NTPv4 introduced a public key authentication mechanism
called Autokey which has not seen widespread adoption;
and unfortunately, Autokey uses small 32-bit seeds that
can be easily brute forced to then forge packets. A more
recent proposal is the Network Time Security (NTS) pro-
tocol [31], which we discuss in §2.3.
Most NTP servers do not support NTP authentica-
tion, and NTP clients in desktop and laptop operating
systems will set their clocks based on unauthenticated
NTP responses. On Linux and OS X, by default the
client either polls a server periodically, or creates an NTP
request when the network interface is established.
In
both cases the system clock will be set to any time spec-
iﬁed by the NTP response. On Windows, by default
clients will synchronize their clock every nine hours (us-
ing time.microsoft.com), and ignore responses that
would change the clock by more than 15 hours. These two
defaults reduce the opportunity for a man-in-the-middle
(MITM) attacker to change a victim clock and the amount
by which it may be changed, but cumulative small-scale
changes can build over time to large-scale time inaccu-
racies. Teichel et al. used this technique when attacking
time-synchronization secured by TESLA-like protocols
[33]. In Windows domains (a network of computers, of-
ten in an enterprise), the domain controller provides the
time with an authenticated variant of NTPv3 [14].
1.1 Contributions
We present the ANTP protocol for authenticated network
time synchronization, along with results on its perfor-
mance and security. ANTP protocol messages are trans-
ported in the extension ﬁelds of NTP messages. ANTP
allows a server to authenticate itself to a client using pub-
lic key certiﬁcates and public key exchange, and provides
cryptographic assurance using symmetric cryptography
that no modiﬁcation of the packets has occurred in transit.
Like other authenticated time synchronization protocols
using public keys [31], we assume an out-of-band method
for certiﬁcate validation exists, as certiﬁcate validation
requires an accurate clock. We follow the direction set
by the IETF Informational document “Security Require-
ments of Time Protocols in Packet-Switched Networks”
(RFC 7384) [20] to determine what cryptographic, com-
putational, and storage properties ANTP should achieve.
ANTP has three phases. In the negotiation phase, the
client and server agree on which cryptographic algorithms
to use; this phase would be carried out quite infrequently,
on the order of monthly or less.
In the key exchange
phase, the client and server use public key cryptography
to establish a symmetric key that the server will use to
authenticate later time synchronization responses; this
phase would also be carried out infrequently, say monthly.
In the time synchronization phase, the client sends a time
synchronization request, and the server replies with an
NTP response that is symmetrically authenticated using
the key established in the key exchange phase; this may
be done frequently, perhaps daily or more often. No-
tably, the server need not keep per-client state: the server
ofﬂoads any such state to the client by encrypting and
authenticating it under a long-term symmetric key, and
the client sends that ciphertext back to the server with
each subsequent request.
The time synchronization phase of ANTP can be run in
a “no-cryptographic-latency” mode: here, the server sends
two response packets, the ﬁrst being the unauthenticated
NTP packet, and the second being the same NTP packet
(with unchanged timestamps) along with the ANTP ex-
tensions providing authentication. The client measures
the roundtrip time based on the unauthenticated response,
but does not update its clock until authenticating the re-
sponse. In this way, no time synchronization inaccuracy is
added by the time required to compute the authentication
tag over the outgoing timestamp. Since the latency of
ANTP’s time synchronization phase is nearly as fast as
unauthenticated simple NTP time synchronization (only
21 microseconds slower at 50% load in our implementa-
tion as reported below), we make this mode optional since
plain ANTP may be sufﬁciently accurate for general use.
ANTP performance. Performance constraints on time
synchronization protocols are driven by the fact that time
824  25th USENIX Security Symposium 
USENIX Association
Phase
Throughput
ANTP – Negotiation – RSA
ANTP – Negotiation – ECDH
ANTP – Key Exchange – RSA
ANTP – Key Exchange – ECDH
ANTP – Time Synchronization
ANTP – All 3 phases – RSA
ANTP – All 3 phases – ECDH
NTP
58 240
146 808
1 754
13 210
175 644
–
–
291 926
Latency within LAN (µs)
90% load
50% load
202 ± 44
186 ± 26
172 ± 35
233 ± 133
997 ± 348
891 ± 125
344 ± 142
197 ± 56
168 ± 35
230 ± 160
2646 ± 345
2255 ± 587
2252 ± 1172
1325 ± 499
147 ± 34
181 ± 136
Latency across US (ms)
90% load
50% load
77.5 ± 0.1
76.3 ± 0.1
75.3 ± 0.1
75.3 ± 0.1
76.9 ± 0.5
75.8 ± 0.2
75.4 ± 0.4
74.7 ± 0.2
73.7 ± 0.1
73.5 ± 0.1
226.6 ± 6.2
258.0 ± 35
223.3 ± 6.7
231.8 ± 10.5
72.4 ± 0.1
74.0 ± 0.1
Table 1: Performance results for each phase of ANTP (top), a complete 3-phase execution of ANTP (middle), and NTP
(bottom). Throughput: mean completed phases per second. Latency: mean and standard deviation of the latency of
server responses at either 50% or 90% server load on a local area network (reported in microseconds) and across the
United States (between Virginia and California) (reported in milliseconds). All are computed over 5 trials, top and
bottom over 100 seconds each; see Section 4.2 for details.
servers are heavily loaded, and must provide responses
promptly. ANTP’s design allows it to achieve high per-
formance while maintaining high security. The frequently
performed time synchronization phase uses only symmet-
ric cryptography, making it only slightly more expensive
than simple NTP time synchronization. Since the ses-
sion key established in the key exchange phases is reused
across many time synchronization phases, expensive pub-
lic key operations are amortized, and can be separately
load-balanced. And, as noted above, ANTP ofﬂoads state
to clients, leaving the server stateless.
We implemented ANTP in OpenNTPD’s [34] imple-
mentation of NTP, using OpenSSL’s libcrypto library
(but not SSL/TLS) [35] for cryptographic computations.
Table 1 reports the performance of our implementation,
compared with unauthenticated simple NTP. ANTP does
decrease throughput and increase latency, but the im-
pact is quite reasonable. On a single core of a server,
ANTP can support 175k authenticated time synchroniza-
tion phase connections per second, a factor of 1.6 fewer
than the 291k unauthenticated simple NTP connections
per second. Latency for time synchronization (over a 1
gigabit per second local area network) at 50% load in-
creases from 147 microseconds for unauthenticated sim-
ple NTP to 168 microseconds for ANTP’s time synchro-
nization phase. The other two phases, negotiation and
key exchange, will be performed far less frequently on
average by clients. Throughput of negotiation phases is
bandwidth-, not CPU-, limited. For exchange, we imple-
mented methods: 2048-bit RSA key transport and static-
ephemeral elliptic curve Difﬁe–Hellman key exchange
using the NIST P-256 curve; as expected, both of these
are substantially more expensive than time synchroniza-
tion phases, but are also performed far less frequently.
Protocol
NTPv0–v2
NTPv3
sym. key
NTPv4
Autokey
Auth.