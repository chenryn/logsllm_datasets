While eﬀective in small, managed systems such as en-
terprise networks, the ﬂaws of TLS client authentication
begin to emerge as we examine them at web scale:
Bad User Experience One issue that prevents conven-
tional TLS client authentication from becoming the stan-
dard for web authentication is the cumbersome, com-
plicated, and onerous interface that a user must wade
through in order to use a client certiﬁcate. Typically,
when web servers request that browsers generate a TLS
client certiﬁcate, browsers display a dialog where the
user must choose the certiﬁcate cipher and key length.
Even worse, when web servers request that the browser
provide a certiﬁcate, the user is prompted to select the
client certiﬁcate to use with the site they are attempting to
visit. This “login action” happens during the TLS hand-
shake, before the user can inspect any content of the web-
site (which presumably would help her decide whether
or not she wanted to authenticate to the site in the ﬁrst
place).
Layer Confusion Arguably, TLS client authentication
puts user identity at the wrong layer in the network stack.
An example that reveals this layer confusion is multi-
login: Google has implemented a feature in which mul-
tiple accounts can be logged into the website at the same
time (multiple user identities are encoded in the cookie).
This makes it easy to quickly switch between accounts
on the site, and even opens up the potential to show a
“mashup” of several users’ accounts on one page (e.g.,
show calendars of all the logged-in accounts). With TLS
client authentication, the user identity is established at
the TLS layer, and is “inherited” from there by the HTTP
and application layers. However, client certiﬁcates usu-
ally contain exactly one user identity, thus forcing the
application layer to also only see this one use identity.
Privacy Once a user has obtained a certiﬁcate, any site
on the web can request TLS client authentication with
that certiﬁcate. The user can now choose to not be logged
in at all, or use the same identity at the new site that they
use with other sites on the web. That is a poor choice.
Creating diﬀerent certiﬁcates for diﬀerent sites makes the
user experience worse: Now the user is presented with a
list of certiﬁcates every time they visit a website requir-
ing TLS client authentication.
Portability
Since certiﬁcates ideally are related to a
private key that can’t be extracted from the underlying
platform, by deﬁnition, they can’t be moved from one
device to another. So any solution that involves TLS
client authentication also has to address and solve the
user credential portability problem. Potential solutions
include re-obtaining certiﬁcates from the CA for diﬀer-
ent devices, extracting private keys (against best security
practices) and copying them from one device to another,
or cross-certifying certiﬁcates from diﬀerent devices. So
far we have not been able to come up with good user
interfaces for any of these solutions.
Trusted Computing Base in Datacenters Large dat-
acenters often terminate TLS connections at the datacen-
ter boundary [3], perhaps even using specialized hard-
ware for this relatively expensive part of the connection
setup between client and server. If the TLS client certiﬁ-
cate is what authenticates the user, then the source of that
authentication is lost at the datacenter boundary.
This means that the TLS terminators become part of
the trusted computing base – they simply report to the
backends who the user is that was authenticated during
the TLS handshake. A compromised TLS terminator
would in this case essentially become “root” with respect
to the applications running in the datacenter.
Contrast this with a cookie-based authentication sys-
tem, in which the TLS terminator forwards the cookie
that the browser sends to the app frontend. In such a sys-
tem, the cookies are minted and authenticated by the app
frontend, and the TLS terminator would not be able to
fabricate arbitrary authentic cookies. Put another way,
in a cookie-based authentication system a compromised
TLS terminator can modify an incoming request before
it is delivered to the backend service, but cannot forge a
completely new request from an arbitrary user.
In summary, TLS client authentication presents a
range of issues, ranging from privacy to usability to de-
ployment problems that make it unsuitable as an authen-
tication mechanism on the web.
8.2 Other Related Eﬀorts
CardSpace Microsoft’s CardSpace [13] authentica-
tion system attacked two of the problems mentioned so
far: First, it replaced passwords with a public-key based
protocol, thus eliminating one kind of bearer tokens.
Second, it moved user identity from the TLS layer to the
application layer.
It allowed users to manage multiple digital identities
from a single user interface. CardSpace stored user iden-
tities in the form of identity “cards”. When visiting a
website that implemented the CardSpace protocol, users
could choose which card, and hence which identity, to
use to authenticate with that website. Instead of a user-
name/password pair, a cookie, or a TLS client certiﬁcate,
CardSpace would authenticate users by sending crypto-
graphic tokens that encoded the user identity. There is no
consensus on why CardSpace did not become an indus-
try standard; however, we believe the same complexity
that gave CardSpace a wide variety of features, also con-
tributed to its demise by unnecessarily complicating the
user interface, interaction, and development models.
CardSpace by itself was also agnostic to the use of
bearer tokens in lower layers of the protocol stack once
the user was logged in. In this paper we approach the
problem from the opposite direction: we build a strong
foundation at the TLS layer that allows us to harden other
protocols (HTTP, application-speciﬁc login, etc.), so the-
oretically origin-bound certiﬁcates and CardSpace are
more complementary than competing proposals – in par-
ticular one could imagine a “channel-bound” CardSpace
token that results in a channel-bound cookie (see Sec-
tion 4). However, we strive to learn from CardSpace’s
failure in the market and carefully designed our system
to not alter the user experience (and burden developers)
too much from what users (and developers) are already
used to.
BrowserID
recently developed a
prototype of an authentication mechanism called
BrowserID [14], which abstracts identity to the level of
email addresses. BrowserID is aimed at the password
bearer token, at least for websites that choose to become
relying parties to email providers. For those, instead
of using a password, users authenticate by providing a
cryptographic proof of email ownership. Similarly to
CardSpace,
the browser maintains a cache of emails
(identities) and generates the respective proofs (tokens)
for the user. Unlike CardSpace, BrowserID is based
on both a simpler model of identity (email addresses
vs. a variety of claims) and a simpler implementation
platform (JWTs vs. WS-Trust).
Mozilla has
BrowserID is complementary to the ideas put forth in
this paper. Since it mostly plays at the application layer,
it is agnostic to the use of bearer tokens at lower layers
(e.g., HTTP cookies). It could easily be adjusted by bind-
ing BrowserID identity assertions to the underlying TLS
channel if the browser supports origin-bound certiﬁcates.
TLS-SA As another approach, Opplinger et al. address
the disconnect between user authentication and TLS
channels in their proposed TLS Session Aware (TLS-
SA) User Authentication scheme [17, 18]. TLS-SA is in-
tended to solve the man-in-the-middle (MITM) problem
by providing the server side of a TLS connection with
the information necessary to determine if a user’s cre-
dentials have been sent over a diﬀerent TLS session than
the session that the client thought the credentials were
being sent over. However, these protections apply only
to the initial user credentials and not to the subsequent
bearer tokens. To our knowledge TLS-SA has neither
been implemented nor tested on a mass, web scale.
Hardening Cookies
Some work has also focused on
hardening the information stored in HTTP cookies. For
example, Murdoch presented a method for toughening
cookies by encoding values not only based on on a secret
server key, but also on a hash of the user’s password [15].
This approach has the beneﬁt of making it harder for at-
tackers to fabricate fake cookies (even if the secret server
key has been compromised), but does not protect the user
if the cookie is ever stolen.
9 Conclusion
10 Acknowledgements
A great number of individuals have contributed to the
work presented in this paper. We would like to thank
the team at Google, including Mayank Upadhyay, Adam
Langley, Wan-Teh Chang, Matt Mueller, Ryan Hamilton,
Diana Smetters, Adam Barth and Warren Zhang for help-
ing us develop the ideas presented in this paper, and for
implementing and testing them. Our thanks go out to Ben
Adida, Mike Hanson and Brian Smith from Mozilla, as
well as the members of the IETF TLS Working Group for
sanity-checking and improving our proposals. We would
also like to thank Tadayoshi Kohno for his support.
Finally, we would like to thank the anonymous review-
ers of our manuscript for helping us make this a better
paper.
In this paper we presented TLS origin-bound certiﬁcates
as a new approach to TLS client certiﬁcates. TLS-OBCs
act as a foundational layer on which the notion of an au-
thenticated channel for the web can be established.
We showed how TLS-OBCs can be used to harden ex-
isting HTTP layer authentication mechanisms like cook-
ies, federated login protocols, and user authentication.
We implemented TLS-OBCs as an extension to the
OpenSSL and NSS TLS implementations and deployed
TLS-OBC to the Chromium open source browser as well
as the TLS terminator of a major website.
Finally, we demonstrated that the performance over-
head imparted by using TLS-OBC is small in terms of
CPU and memory load on the TLS server and observed
latency on the TLS client.
We see origin-bound certiﬁcates as a ﬁrst step towards
enabling more secure web protocols and applications.
References
[1] H.
Adkins.
at-
tempted
attacks.
http://googleonlinesecurity.blogspot.com/2011/08/update-
on-attempted-man-in-middle.html, Aug 2011.
man-in-the-middle
update
An
on
[2] D. Balfanz.
http://tools.ietf.org/html/draft-balfanz-tls-obc-01,
2011.
TLS Origin-Bound Certiﬁcates.
Nov
[3] J.
Barr.
AWS
Elastic
Support
ing:
http://aws.typepad.com/aws/2010/10/elastic-load-
balancer-support-for-ssl-termination.html, Oct 2010.
SSL
for
Load
Balanc-
Termination.
[4] S. Blake-Wilson, T. Dierks, and C. Hawk. ECC Ci-
pher Suites for TLS. http://tools.ietf.org/html/draft-ietf-
tls-ecc-01, March 2001.
[5] S. Blake-Wilson, M. Nystrom, D. Hopwood,
Transport layer secu-
http://tools.ietf.org/html/rfc4366,
J. Mikkelsen, and T. Wright.
rity (tls) extensions.
Apr 2006.
[6] A. Bortz, A. Barth, and A. Czeskis. Origin cookies: Ses-
sion integrity for web applications. In Web 2.0 Security &
Privacy, 2011.
[7] E. Butler. Firesheep.
http://codebutler.com/ﬁresheep,
2010.
[8] A. Czeskis and D. Balfanz. Protected Login. In Proceed-
ings of the Workshop on Usable Security (at the Finan-
cial Cryptography and Data Security Conference), March
2012.
[9] T. Dierks and C. Allen. The TLS Protocol, Version 1.0.
Internet Engineering Task Force, Jan. 1999. RFC-2246,
ftp://ftp.isi.edu/in-notes/rfc2246.txt.
[10] T. Dierks and E. Rescorla. The Trandsport Layer Security
(TLS) Protocol Version 1.2 – Client Certiﬁcates, 2008.
http://tools.ietf.org/html/rfc5246#section-7.4.6.
[11] I.
Hickson.
HTML5 Web Messaging.
http://dev.w3.org/html5/postmsg/, Jan 2012.
[12] J. Hurwich.
Chrome
exten-
http://www.chromium.org/developers/design-
sion.
documents/extensions/how-the-extension-system-
works/chrome-benchmarking-extension, Sept 2010.
benchmarking
[13] Microsoft. Introducing windows cardspace, 2006. http:
//msdn.microsoft.com/en-us/library/aa480189.aspx.
[14] Mozilla. BrowserID, 2012. https://developer.mozilla.org/
en/BrowserID.
[15] S. Murdoch. Hardened stateless session cookies. Security
Protocols XVI, pages 93–101, 2011.
[16] A. Mushaq. Man in the Browser:
Inside the Zeus
http://threatpost.com/en\_us/blogs/man-
Trojan, 2010.
browser-inside-zeus-trojan-021910.
[17] R. Oppliger, R. Hauser, and D. Basin.
SSL/TLS
session-aware user authentication–or how to eﬀectively
thwart the man-in-the-middle. Computer Communica-
tions, 29(12):2338–2246, 2006.
[18] R. Opplinger, R. Hauser, and D. Basin. SSL/TLS session-
aware user authentication revisited. Computers & Secu-
rity, 27(3-4):64–70, 2008.
[19] S. Park and D. L. Dill. Veriﬁcation of cache coherence
protocols by aggregation of distributed transactions. The-
ory of Computing Systems, 31(4):355–376, 1998.
[20] D. Recordon and B. Fitzpatrick. OpenID authentica-
http://openid.net/specs/openid-authentication-
tion 1.1.
1_1.html, May 2008.
[21] E. Rescorla. Keying Material Exporters for Transport
Layer Security (TLS). http://tools.ietf.org/html/rfc5705,
March 2010.
Rizzo
Duong.
[22] J.
and
T.
http://vnhacker.blogspot.com/2011/09/beast.html,
2011.
Beast.
Sept
[23] N. Sakimura, D. Bradley, B. de Mederiso, M. Jones,
and E. Jay. OpenID connect standard 1.0 - draft 07.
http://openid.net/specs/openid-connect-standard-1
[24] C. M. Shields and M. M. Toussain. Subterfuge: The
http://subterfuge.googlecode.com/
MITM Framework.
ﬁles/Subterfuge-WhitePaper.pdf, 2012.
[25] A. S. Tanenbaum, S. J. Mullender, and R. van Renesse.
Using sparse capabilities in a distributed operating sys-
In 6th International Conference on Distributed
tem.
Computing Systems, pages 558–563, Cambridge, Mas-
sachusetts, May 1986.
[26] The Chromium Project.
SPDY, 2012.
http://www.
chromium.org/spdy.
[27] E. Wobber, M. Abadi, M. Burrows, and B. Lampson. Au-
thentication in the Taos operating system. ACM Transac-
tions on Computer Systems (TOCS), 12(1):3–32, 1994.