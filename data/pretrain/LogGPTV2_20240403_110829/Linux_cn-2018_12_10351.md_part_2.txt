由于每个 CPU 都能同时运行不同的用户进程，所以我们重新定义了符号 `curenv`，让它指向到 `cpus[cpunum()].cpu_env`（或 `thiscpu->cpu_env`），它指向到当前 CPU（代码正在运行的那个 CPU）上当前正在运行的环境上。
* **每个 CPU 的系统寄存器**
所有的寄存器，包括系统寄存器，都是一个 CPU 私有的。所以，初始化这些寄存器的指令，比如 `lcr3()`、`ltr()`、`lgdt()`、`lidt()`、等待，必须在每个 CPU 上运行一次。函数 `env_init_percpu()` 和 `trap_init_percpu()` 就是为此目的而定义的。
> 
> **练习 3**、修改 `mem_init_mp()`（在 `kern/pmap.c` 中）去映射每个 CPU 的栈从 `KSTACKTOP` 处开始，就像在 `inc/memlayout.h` 中展示的那样。每个栈的大小是 `KSTKSIZE` 字节加上未映射的保护页 `KSTKGAP` 的字节。你的代码应该会通过在 `check_kern_pgdir()` 中的新的检查。
> 
> 
> 
.
> 
> **练习 4**、在 `trap_init_percpu()`（在 `kern/trap.c` 文件中）的代码为 BSP 初始化 TSS 和 TSS 描述符。在实验 3 中它就运行过，但是当它运行在其它的 CPU 上就会出错。修改这些代码以便它能在所有 CPU 上都正常运行。（注意：你的新代码应该还不能使用全局变量 `ts`）
> 
> 
> 
在你完成上述练习后，在 QEMU 中使用 4 个 CPU（使用 `make qemu CPUS=4` 或 `make qemu-nox CPUS=4`）来运行 JOS，你应该看到类似下面的输出：
```
    ...
    Physical memory: 66556K available, base = 640K, extended = 65532K
    check_page_alloc() succeeded!
    check_page() succeeded!
    check_kern_pgdir() succeeded!
    check_page_installed_pgdir() succeeded!
    SMP: CPU 0 found 4 CPU(s)
    enabled interrupts: 1 2
    SMP: CPU 1 starting
    SMP: CPU 2 starting
    SMP: CPU 3 starting
```
##### 锁定
在 `mp_main()` 中初始化 AP 后我们的代码快速运行起来。在你更进一步增强 AP 之前，我们需要首先去处理多个 CPU 同时运行内核代码的争用状况。达到这一目标的最简单的方法是使用大内核锁。大内核锁是一个单个的全局锁，当一个环境进入内核模式时，它将被加锁，而这个环境返回到用户模式时它将释放锁。在这种模型中，在用户模式中运行的环境可以同时运行在任何可用的 CPU 上，但是只有一个环境能够运行在内核模式中；而任何尝试进入内核模式的其它环境都被强制等待。
`kern/spinlock.h` 中声明大内核锁，即 `kernel_lock`。它也提供 `lock_kernel()` 和 `unlock_kernel()`，快捷地去获取/释放锁。你应该在以下的四个位置应用大内核锁：
* 在 `i386_init()` 时，在 BSP 唤醒其它 CPU 之前获取锁。
* 在 `mp_main()` 时，在初始化 AP 之后获取锁，然后调用 `sched_yield()` 在这个 AP 上开始运行环境。
* 在 `trap()` 时，当从用户模式中捕获一个 陷阱   trap 时获取锁。在检查 `tf_cs` 的低位比特，以确定一个陷阱是发生在用户模式还是内核模式时。
* 在 `env_run()` 中，在切换到用户模式之前释放锁。不能太早也不能太晚，否则你将可能会产生争用或死锁。
> 
> **练习 5**、在上面所描述的情况中，通过在合适的位置调用 `lock_kernel()` 和 `unlock_kernel()` 应用大内核锁。
> 
> 
> 如果你的锁定是正确的，如何去测试它？实际上，到目前为止，还无法测试！但是在下一个练习中，你实现了调度之后，就可以测试了。
> 
> 
> 
.
> 
> **问题 2**、看上去使用一个大内核锁，可以保证在一个时间中只有一个 CPU 能够运行内核代码。为什么每个 CPU 仍然需要单独的内核栈？描述一下使用一个共享内核栈出现错误的场景，即便是在它使用了大内核锁保护的情况下。
> 
> 
> **小挑战！**大内核锁很简单，也易于使用。尽管如此，它消除了内核模式的所有并发。大多数现代操作系统使用不同的锁，一种称之为细粒度锁定的方法，去保护它们的共享的栈的不同部分。细粒度锁能够大幅提升性能，但是实现起来更困难并且易出错。如果你有足够的勇气，在 JOS 中删除大内核锁，去拥抱并发吧！
> 
> 
> 由你来决定锁的粒度（一个锁保护的数据量）。给你一个提示，你可以考虑在 JOS 内核中使用一个自旋锁去确保你独占访问这些共享的组件：
> 
> 
> * 页分配器
> * 控制台驱动
> * 调度器
> * 你将在 Part C 中实现的进程间通讯（IPC）的状态
> 
> 
> 
#### 循环调度
本实验中，你的下一个任务是去修改 JOS 内核，以使它能够在多个环境之间以“循环”的方式去交替。JOS 中的循环调度工作方式如下：
* 在新的 `kern/sched.c` 中的 `sched_yield()` 函数负责去选择一个新环境来运行。它按顺序以循环的方式在数组 `envs[]` 中进行搜索，在前一个运行的环境之后开始（或如果之前没有运行的环境，就从数组起点开始），选择状态为 `ENV_RUNNABLE` 的第一个环境（查看 `inc/env.h`），并调用 `env_run()` 去跳转到那个环境。
* `sched_yield()` 必须做到，同一个时间在两个 CPU 上绝对不能运行相同的环境。它可以判断出一个环境正运行在一些 CPU（可能是当前 CPU）上，因为，那个正在运行的环境的状态将是 `ENV_RUNNING`。
* 我们已经为你实现了一个新的系统调用 `sys_yield()`，用户环境调用它去调用内核的 `sched_yield()` 函数，并因此将自愿把对 CPU 的控制禅让给另外的一个环境。
> 
> **练习 6**、像上面描述的那样，在 `sched_yield()` 中实现循环调度。不要忘了去修改 `syscall()` 以派发 `sys_yield()`。
> 
> 
> 确保在 `mp_main` 中调用了 `sched_yield()`。
> 
> 
> 修改 `kern/init.c` 去创建三个（或更多个！）运行程序 `user/yield.c`的环境。
> 
> 
> 运行 `make qemu`。在它终止之前，你应该会看到像下面这样，在环境之间来回切换了五次。
> 
> 
> 也可以使用几个 CPU 来测试：`make qemu CPUS=2`。
> 
> 
> 
> ```
> ...
> Hello, I am environment 00001000.
> Hello, I am environment 00001001.
> Hello, I am environment 00001002.
> Back in environment 00001000, iteration 0.
> Back in environment 00001001, iteration 0.
> Back in environment 00001002, iteration 0.
> Back in environment 00001000, iteration 1.
> Back in environment 00001001, iteration 1.
> Back in environment 00001002, iteration 1.
> ...
> ```
> 
> 在程序 `yield` 退出之后，系统中将没有可运行的环境，调度器应该会调用 JOS 内核监视器。如果它什么也没有发生，那么你应该在继续之前修复你的代码。
> 
> 
> **问题 3**、在你实现的 `env_run()` 中，你应该会调用 `lcr3()`。在调用 `lcr3()` 的之前和之后，你的代码引用（至少它应该会）变量 `e`，它是 `env_run` 的参数。在加载 `%cr3` 寄存器时，MMU 使用的地址上下文将马上被改变。但一个虚拟地址（即 `e`）相对一个给定的地址上下文是有意义的 —— 地址上下文指定了物理地址到那个虚拟地址的映射。为什么指针 `e` 在地址切换之前和之后被解除引用？
> 
> 
> 
.
> 
> **问题 4**、无论何时，内核从一个环境切换到另一个环境，它必须要确保旧环境的寄存器内容已经被保存，以便于它们稍后能够正确地还原。为什么？这种事件发生在什么地方？
> 
> 
> 
.
> 
> 小挑战！给内核添加一个小小的调度策略，比如一个固定优先级的调度器，它将会给每个环境分配一个优先级，并且在执行中，较高优先级的环境总是比低优先级的环境优先被选定。如果你想去冒险一下，尝试实现一个类 Unix 的、优先级可调整的调度器，或者甚至是一个彩票调度器或跨步调度器。（可以在 Google 中查找“彩票调度”和“跨步调度”的相关资料）
> 
> 
> 写一个或两个测试程序，去测试你的调度算法是否工作正常（即，正确的算法能够按正确的次序运行）。如果你实现了本实验的 Part B 和 Part C 部分的 `fork()` 和 IPC，写这些测试程序可能会更容易。
> 
> 
> 
.
> 
> 小挑战！目前的 JOS 内核还不能应用到使用了 x87 协处理器、MMX 指令集、或流式 SIMD 扩展（SSE）的 x86 处理器上。扩展数据结构 `Env` 去提供一个能够保存处理器的浮点状态的地方，并且扩展上下文切换代码，当从一个环境切换到另一个环境时，能够保存和还原正确的状态。`FXSAVE` 和 `FXRSTOR` 指令或许对你有帮助，但是需要注意的是，这些指令在旧的 x86 用户手册上没有，因为它是在较新的处理器上引入的。写一个用户级的测试程序，让它使用浮点做一些很酷的事情。
> 
> 
> 
#### 创建环境的系统调用