it will have updated the currentItem variable, so all the Current property
needs to do is return the value in this variable.
12. Locate the IDisposable.Dispose method. Comment out the throw new
NotImplementedException(); statement as shown in bold in the code that
follows. The enumerator does not use any resources that require explicit
disposal, so this method does not need to do anything. It must still be
present, however. For more information about the Dispose method, refer
to Chapter 14.
Click here to view code image
void IDisposable.Dispose()
{
    // throw new NotImplementedException();
}
13. Build the solution, and correct errors if any are reported.
Initializing a variable defined with a type parameter
You should have noticed that the statement that defines and initializes
the currentItem variable uses the default keyword:
Click here to view code image
private TItem currentItem = default(TItem);
The currentItem variable is defined by using the type parameter
TItem. When the program is written and compiled, the actual type that
will be substituted for TItem might not be known; this issue is resolved
only when the code is executed. This makes it difficult to specify how
the variable should be initialized. The temptation is to set it to null.
However, if the type substituted for TItem is a value type, this is an
illegal assignment. (You cannot set value types to null, only reference
types.) Similarly, if you set it to 0 with the expectation that the type will
be numeric, this will be illegal if the type used is actually a reference
type. There are other possibilities as well; TItem could be a boolean, for
Download from finelybook PI:EMAIL
647
example. The default keyword solves this problem. The value used to
initialize the variable will be determined when the statement is
executed. If TItem is a reference type, default(TItem) returns null; if
TItem is numeric, default(TItem) returns 0; if TItem is a boolean,
default(TItem) returns false. If TItem is a struct, the individual fields in
the struct are initialized in the same way. (Reference fields are set to
null, numeric fields are set to 0, and boolean fields are set to false.)
Implementing the IEnumerable interface
In the following exercise, you will modify the binary tree class to implement
the IEnumerable  interface. The GetEnumerator method will return a
TreeEnumerator object.
Implement the IEnumerable interface in the Tree class
1. In Solution Explorer, double-click the file Tree.cs to display the
Tree class in the Code and Text Editor window.
2. Modify the definition of the Tree class so that it implements the
IEnumerable interface, as shown in bold in the following code:
Click here to view code image
public class Tree : IEnumerable where TItem :
IComparable
Notice that constraints are always placed at the end of the class
definition.
3. Hover over the IEnumerable interface in the class definition.
On the drop-down context menu that appears, click Implement Interface
Explicitly.
This action generates implementations of the
IEnumerable.GetEnumerator and IEnumerable.GetEnumerator
methods and adds them to the class. The nongeneric IEnumerable
interface method is implemented because the generic
IEnumerable interface inherits from IEnumerable.
Download from finelybook PI:EMAIL
648
4. Locate the generic IEnumerable.GetEnumerator method near
the end of the class. Modify the body of the GetEnumerator() method,
replacing the existing throw statement, as shown in bold in the following
example:
Click here to view code image
IEnumerator IEnumerable.GetEnumerator()
{
    return new TreeEnumerator(this);
}
The purpose of the GetEnumerator method is to construct an enumerator
object for iterating through the collection. In this case, all you need to do
is build a new TreeEnumerator object by using the data in the
tree.
5. Build the solution. Correct any errors that are reported, and rebuild the
solution if necessary.
You will now test the modified Tree class by using a foreach
statement to iterate through a binary tree and display its contents.
Test the enumerator
1. In Solution Explorer, right-click the BinaryTree solution, point to Add,
and then click New Project.
2. Add a new project by using the Console App (.NET Framework)
template. Name the project EnumeratorTest, set the location to
\Microsoft Press\VCSBS\Chapter 19\BinaryTree in your Documents
folder, and then click OK.
3. Right-click the EnumeratorTest project in Solution Explorer, and then
click Set As StartUp Project.
4. On the Project menu, click Add Reference. In the Reference Manager -
EnumeratorTest dialog box, in the left pane, expand the Projects node
and click Solution. In the middle pane, select the BinaryTree project,
and then click OK.
The BinaryTree assembly appears in the list of references for the
EnumeratorTest project in Solution Explorer.
Download from finelybook PI:EMAIL
649
5. In the Code and Text Editor window displaying the Program class, add
the following using directive to the list at the top of the file:
using BinaryTree;
6. Add the statements shown below in bold to the Main method. These
statements create and populate a binary tree of integers:
Click here to view code image
static void Main(string[] args)
{
      Tree tree1 = new Tree(10);
      tree1.Insert(5);
      tree1.Insert(11);
      tree1.Insert(5);
      tree1.Insert(-12);
      tree1.Insert(15);
      tree1.Insert(0);
      tree1.Insert(14);
      tree1.Insert(-8);
      tree1.Insert(10);
}
7. Add a foreach statement, as follows in bold, that enumerates the
contents of the tree and displays the results:
Click here to view code image
static void Main(string[] args)
{
     ...
     foreach (int item in tree1)
     {
        Console.WriteLine(item);
     }
}
8. On the Debug menu, click Start Without Debugging.
The program runs and displays the values in the following sequence:
–12, –8, 0, 5, 5, 10, 10, 11, 14, 15
9. Press Enter to return to Visual Studio 2017.
Implementing an enumerator by using an iterator
Download from finelybook PI:EMAIL
650
As you can see, the process of making a collection enumerable can become
complex and is potentially prone to error. To make life easier, C# provides
iterators that can automate much of this process.
An iterator is a block of code that yields an ordered sequence of values.
An iterator is not actually a member of an enumerable class; rather, it
specifies the sequence that an enumerator should use for returning its values.
In other words, an iterator is just a description of the enumeration sequence
that the C# compiler can use for creating its own enumerator. This concept
requires a little thought to understand properly, so consider the following
simple example.
A simple iterator
The following BasicCollection class illustrates the principles of
implementing an iterator. The class uses a List object for holding data
and provides the FillList method for populating this list. Notice also that the
BasicCollection class implements the IEnumerable interface. The
GetEnumerator method is implemented by using an iterator:
Click here to view code image
using System;
using System.Collections.Generic;
using System.Collections;
class BasicCollection : IEnumerable
{
     private List data = new List();
     public void FillList(params T [] items)
     {
        foreach (var datum in items)
        {
          data.Add(datum);
        }
     }
     IEnumerator IEnumerable.GetEnumerator()
     {
         foreach (var datum in data)
         {
            yield return datum;
         }
     }
     IEnumerator IEnumerable.GetEnumerator()
Download from finelybook PI:EMAIL
651
     {
        // Not implemented in this example
        throw new NotImplementedException();
     }
}
The GetEnumerator method appears to be straightforward, but it warrants
closer examination. The first thing to notice is that it doesn’t appear to return
an IEnumerator type. Instead, it loops through the items in the data
array, returning each item in turn. The key point is the use of the yield
keyword. The yield keyword indicates the value that should be returned by
each iteration. If it helps, you can think of the yield statement as calling a
temporary halt to the method, passing back a value to the caller. When the
caller needs the next value, the GetEnumerator method continues at the point
at which it left off, looping around and then yielding the next value.
Eventually, the data is exhausted, the loop finishes, and the GetEnumerator
method terminates. At this point, the iteration is complete.
Remember that this is not a normal method in the usual sense. The code in
the GetEnumerator  method defines an iterator. The compiler uses this code
to generate an implementation of the IEnumerator class containing a
Current method and a MoveNext method. This implementation exactly
matches the functionality specified by the GetEnumerator method. You don’t
actually get to see this generated code (unless you decompile the assembly
containing the compiled code), but that is a small price to pay for the
convenience and reduction in code that you need to write. You can invoke the
enumerator generated by the iterator in the usual manner, as shown in the
following block of code, which displays the words in the first line of the
poem “Jabberwocky” by Lewis Carroll:
Click here to view code image
BasicCollection bc = new BasicCollection();
bc.FillList("Twas", "brillig", "and", "the", "slithy", "toves");
foreach (string word in bc)
{
    Console.WriteLine(word);
}
This code simply outputs the contents of the bc object in this order:
Twas, brillig, and, the, slithy, toves
Download from finelybook PI:EMAIL
652
If you want to provide alternative iteration mechanisms to present the data
in a different sequence, you can implement additional properties that
implement the IEnumerable interface and that use an iterator for returning
data. For example, the Reverse property of the BasicCollection class,
shown here, emits the data in the list in reverse order:
Click here to view code image
class BasicCollection : IEnumerable
{
     ...
     public IEnumerable Reverse
     {
        get
        {
           for (int i = data.Count - 1; i >= 0; i--)
           {
              yield return data[i];
           }
        }
     }
}
You can invoke this property as follows:
Click here to view code image
BasicCollection bc = new BasicCollection();
bc.FillList("Twas", "brillig", "and", "the", "slithy", "toves");
foreach (string word in bc.Reverse)
{
      Console.WriteLine(word);
}
This code outputs the contents of the bc object in reverse order:
toves, slithy, the, and, brillig, Twas
Defining an enumerator for the Tree class by
using an iterator
In the next exercise, you will implement the enumerator for the Tree
class by using an iterator. Unlike in the preceding set of exercises, which
required the data in the tree to be preprocessed into a queue by the MoveNext
method, here you can define an iterator that traverses the tree by using the
more naturally recursive mechanism, similar to the WalkTree method
Download from finelybook PI:EMAIL
653
discussed in Chapter 17.
Add an enumerator to the Tree class
1. Using Visual Studio 2017, open the BinaryTree solution, located in the
\Microsoft Press\VCSBS\Chapter 19\IteratorBinaryTree folder in your
Documents folder. This solution contains another copy of the
BinaryTree project you created in Chapter 17.
2. Open the file Tree.cs in the Code and Text Editor window. Modify the
definition of the Tree class so that it implements the
IEnumerable interface, as shown here in bold:
Click here to view code image
public class Tree : IEnumerable where TItem :
IComparable
{
     ...
}
3. Hover over the IEnumerable interface in the class definition.
On the drop-down context menu that appears, click Implement Interface
Explicitly to add the IEnumerable. GetEnumerator and
IEnumerable.GetEnumerator methods to the end of the class.
4. Locate the generic IEnumerable.GetEnumerator method.
Replace the contents of the GetEnumerator method as shown in bold in
the following code:
Click here to view code image
IEnumerator IEnumerable.GetEnumerator()
{
     if (this.LeftTree != null)
     {
        foreach (TItem item in this.LeftTree)
        {
           yield return item;
        }
     }
     yield return this.NodeData;
     if (this.RightTree != null)
     {
        foreach (TItem item in this.RightTree)
Download from finelybook PI:EMAIL
654
        {
           yield return item;
        }
     }
}
It might not be obvious at first glance, but this code follows the same
recursive algorithm that you used in Chapter 17 for listing the contents
of a binary tree. If LeftTree is not empty, the first foreach statement
implicitly calls the GetEnumerator method (which you are currently
defining) over it. This process continues until a node is found that has no
left subtree. At this point, the value in the NodeData property is yielded,
and the right subtree is examined in the same way. When the right
subtree is exhausted, the process unwinds to the parent node, outputting
the parent’s NodeData property and examining the right subtree of the
parent. This course of action continues until the entire tree has been
enumerated and all the nodes have been output.
Test the new enumerator
1. In Solution Explorer, right-click the BinaryTree solution, point to Add,
and then click Existing Project. In the Add Existing Project dialog box,
move to the folder \Microsoft Press\VCSBS\Chapter
19\BinaryTree\EnumeratorTest, select the EnumeratorTest project file,
and then click Open.
This is the project that you created to test the enumerator you developed
manually earlier in this chapter.
2. Right-click the EnumeratorTest project in Solution Explorer, and then
click Set As StartUp Project.
3. In Solution Explorer, expand the References folder for the
EnumeratorTest project. Right-click the BinaryTree reference and then
click Remove.
4. On the Project menu, click Add Reference.
5. In the Reference Manager - EnumeratorTest dialog box, in the left pane,
expand the Projects node and click Solution. In the middle pane, select
the BinaryTree project, and then click OK.
Download from finelybook PI:EMAIL
655
Note These two steps ensure that the EnumeratorTest project
references the correct version of the BinaryTree assembly. It
should use the assembly that implements the enumerator by using
the iterator rather than the version created in the previous set of
exercises in this chapter.
6. Display the Program.cs file for the EnumeratorTest project in the Code
and Text Editor window. Review the Main method in the Program.cs
file. Recall from testing the earlier enumerator that this method
instantiates a Tree object, fills it with some data, and then uses a
foreach statement to display its contents.
7. Build the solution, and correct any errors if necessary.
8. On the Debug menu, click Start Without Debugging.
The program runs and displays the values in the same sequence as
before.
–12, –8, 0, 5, 5, 10, 10, 11, 14, 15
9. Press Enter and return to Visual Studio 2017.
Summary
In this chapter, you saw how to implement the IEnumerable and
IEnumerator interfaces with a collection class to enable applications to
iterate through the items in the collection. You also saw how to implement an
enumerator by using an iterator.
If you want to continue to the next chapter, keep Visual Studio 2017
running and turn to  Chapter 20, “Decoupling application logic and
handling events.”
If you want to exit Visual Studio 2017 now, on the File menu, click
Exit. If you see a Save dialog box, click Yes and save the project.
Download from finelybook PI:EMAIL
656
Quick reference
To
Do this
Make a collection
class enumerable,
allowing it to support
the foreach construct
Implement the IEnumerable interface and provide a
GetEnumerator method that returns an IEnumerator
object. For example:
Click here to view code image
public class Tree : IEnumerable
{
    ...
    IEnumerator GetEnumerator()
    {
        ...
    }
}
Implement an
enumerator without
using an iterator
Define an enumerator class that implements the
IEnumerator interface, and that provides the
Current property and the MoveNext method (and
optionally the Reset method). For example:
Click here to view code image
public class TreeEnumerator :
IEnumerator
{
    ...
    TItem Current
    {
        get
        {
            ...
        }
    }
    bool MoveNext()
    {
        ...
    }
}
Define an enumerator
by using an iterator
Implement the enumerator to indicate which items
should be returned (using the yield statement) and in
which order. For example:
Click here to view code image
Download from finelybook PI:EMAIL
657
IEnumerator GetEnumerator()
{
     for (...)
     {
         yield return ...
     }
}
Download from finelybook PI:EMAIL
658
CHAPTER 20
Decoupling application logic and
handling events
After completing this chapter, you will be able to:
Declare a delegate type to create an abstraction of a method signature.
Create an instance of a delegate to refer to a specific method.
Call a method through a delegate.
Define a lambda expression to specify the code to be executed by a
delegate.
Declare an event field.
Handle an event by using a delegate.
Raise an event.
Many of the examples and exercises in this book have placed great
emphasis on the careful definition of classes and structures to enforce
encapsulation. In this way, the implementation of the methods in these types
can change without unduly affecting the applications that use them.