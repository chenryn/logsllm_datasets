title:A Unilateral-to-Mutual Authentication Compiler for Key Exchange (with
Applications to Client Authentication in TLS 1.3)
author:Hugo Krawczyk
A Unilateral-to-Mutual Authentication Compiler for Key
Exchange (with Applications to Client Authentication in
TLS 1.3) ∗
†
Hugo Krawczyk
IBM Research
ABSTRACT
We study the question of how to build “compilers” that
transform a unilaterally authenticated (UA) key-exchange
protocol into a mutually-authenticated (MA) one. We present
a simple and eﬃcient compiler and characterize the UA pro-
tocols that the compiler upgrades to the MA model, showing
this to include a large and important class of UA protocols.
The question, while natural, has not been studied widely.
Our work is motivated in part by the ongoing work on the
design of TLS 1.3, speciﬁcally the design of the client au-
thentication mechanisms including the challenging case of
post-handshake authentication. Our approach supports the
analysis of these mechanisms in a general and modular way,
in particular aided by the notion of “functional security” that
we introduce as a generalization of key exchange models and
which may be of independent interest.
1.
INTRODUCTION
A natural question in the area of key-exchange (KE) pro-
tocols is how to transform a given KE protocol that is se-
cure in the unilateral-authentication (UA) setting (where
only one of the parties authenticates and the other remains
anonymous) into a secure mutual-authentication (MA) pro-
tocol. Somewhat surprisingly this question has not received
much attention in the complexity-based KE literature, in
part since much of the work in this area has focused on the
mutual authentication case. In practice, however, the most
widely used KE protocol, TLS, is centered around unilateral
(server-only) authentication, with optional upgrade to mu-
tual authentication. Namely, one starts from a core protocol
where only the server authenticates and then extends it with
an optional mechanism for client authentication.
In this work we investigate the above question in the con-
text of complexity-theoretic models of KE, striving for re-
sults that are general as well as practically relevant to real-
∗Full version (includes proofs): eprint.iacr.org/2016/711
†Email: hugo@ee.technion.ac.il.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’16, October 24–28, 2016, Vienna, Austria.
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978325
world protocols, in particular to the ongoing work on the
design of TLS 1.3 [33] which provides particular motiva-
tion for this work. We think of this problem as developing
compilers that extend secure unilateral key-exchange proto-
cols into secure mutual key-exchange protocols. We focus
on signature-based compilers, namely the case in which the
second party to authenticate - which we refer to as the client
- uses a digital signature as the means for public-key for au-
thentication (even though our approach can potentially be
extended to other forms of authentication).
The SIGMAC Compiler. Our compiler is simple: To
upgrade a unilateral protocol Π1 into a mutually authenti-
cated Π2, upon completion of Π1 the client sends a single
message comprised of: (i) the client’s signature on a por-
tion of the Π1’s transcript; and (ii) a MAC value computed
on the client and server’s identities with a MAC key com-
puted by Π1. The intuition of the design is simple too: First
note that anyone can sign the transcript, hence just a sig-
nature by the client on the transcript is not suﬃcient. Just
MACing the identities is clearly not suﬃcient either since
any party that participated in the unilateral protocol can
compute the MAC on any identities. Yet the combination
of signature and MAC ensures a binding between an iden-
tity and the knowledge of a key (computed in the unilateral
protocol). We call the compiler SIGMAC for SIGnature and
MAc Compiler, and also since it is reminiscent of the SIGMA
protocol [24].
While intuitively appealing, proving the compiler, namely,
showing that it can upgrade a secure unilateral protocol into
a secure mutual one turns out to be non-trivial, in particu-
lar regarding what information needs to be covered by the
signature. One can show examples, even in natural and
practical settings, where even signing the whole transcript
is not enough to ensure client authentication. Fortunately,
we show that the compiler works for important classes of
protocols, including any protocol that derives its session key
from a Diﬃe-Hellman exchange. A core issue is to character-
ize what needs to be included under the signature. For this,
we ﬁnd a general suﬃcient condition (through a notion we
call transport replication security, abbreviated as “treplica-
tion security”) that if satisﬁed by a unilateral KE protocol
Π, then applying the SIGMAC compiler to Π results in a
provably secure mutually authenticated KE protocol. We
then show extensive classes of unilateral protocols to pos-
sess this property, including KE mechanisms used in TLS
1.3.
By characterizing the minimal amount of information to
be included under the client’s signature, we achieve more
1438general results that not only apply to a wider class of pro-
tocols but also allow to remove from the signature any in-
formation that the client may not want to sign with a non-
repudiable signature. In particular, signing the server’s iden-
tity leaves a transferable proof that the client communicated
with the speciﬁc server. While full deniability of commu-
nication is hard to achieve against a malicious server [32],
an explicit signature on the server’s identity fails deniabil-
ity even with a passive (or “honest-but-curious”) server. We
show that signing the server’s identity can be safely omitted.
On the other hand, we stress that if the protocol contains
speciﬁc information that needs explicit authentication, e.g.,
the negotiation of security properties, these can and must
be included under the signature even if these elements are
not essential for the correct functioning of SIGMAC.
Finally, we comment on the use of a MAC function in
the SIGMAC compiler. The essential observation (see Sec-
tion 3.1) is that even if the client’s signature covers both
server’s and client’s identities, omitting the MAC - in par-
ticular, the MACed client identity - voids the ability of the
compiler to produce a mutually authenticated protocol. As
we note below, the use of a MAC function ﬁts particularly
well with TLS and its Finished message.
TLS 1.3: Application and Motivation. While the
main results in this paper are of general applicability and in-
tended to generically lift unilateral authentication protocols
into mutual authentication ones, one timely motivation and
application of this work is the analysis of TLS 1.3 [33]. The
TLS key exchange (or handshake) protocol in the current
and prior versions is built as a server-only authentication
protocol with optional extension to client authentication.
This approach calls exactly for a unilateral-to-mutual com-
piler as studied here.
In particular, the speciﬁc SIGMAC
compiler captures the type of mechanism used in TLS which
is based on the combination of a signature and a MAC (the
latter referred to as the client’s Finished message in TLS).
A challenging aspect of the new TLS 1.3 design is that
the protocol allows for post-handshake client authentication,
namely, a setting where a session key, authenticated by the
server only, is used to protect TLS data (record layer) and
only later is the client authentication extension applied. This
raises the question of what’s the value of this late authen-
tication; can the exchanged data be considered as mutually
authenticated upon this late client authentication? Fortu-
nately, our compiler approach turns out to be particularly
useful for analyzing this setting. It allows us to show that
upon client authentication and successful veriﬁcation by the
server, the data exchanged and protected up to this point
(as well as subsequent data) enjoys mutual authentication
security in the sense of “secure channels”. That is, it is guar-
anteed that only the parties that passed authentication (the
named server and client) are those generating the informa-
tion and being able to decrypt it. Of course, the server
obtains this assurance for past data only a-posteriori, i.e.,
only after verifying client authentication. Other questions
our methodology helps addressing regard the eﬀect of late
authentication on keys derived prior to the authentication
(e.g., a “resumption key”) or the validity of using a session
key to encrypt the very messages that carry client authen-
tication (see Section 6).1
1An immediate conclusion from these results is that it is not
necessary to introduce a dedicated key for encrypting post-
In all, our results are relevant to the analysis of client au-
thentication for the PFS modes of TLS 1.3, namely, 1-RTT
and PSK, and for PSK without PFS (hence, also for re-
sumption mode). This includes the cases of post-handshake
authentication and the use of the session key (or application
key) for encrypting the client authentication message.
An important tool for analyzing the above complex ques-
tions is our “functional” generalization of the key exchange
model from [9] which may be of independent interest.
It
provides an abstraction that frees the analysis from spe-
ciﬁc model and functionality details while at the same time
adding generality. For example, one can use this abstraction
to reason about whether a session key used to protect key
exchange messages may still be secure for another purpose
(say, to derive other keys) or whether a late client authen-
tication implies authentication of keys derived prior to the
authentication (e.g., a resumption key in TLS 1.3).
Final note: Familiarity with TLS 1.3 is not essential for un-
derstanding the results in this paper that, while applicable
and motivated by the TLS 1.3 design, are more general and
emphasize the conceptual aspects rather than the details of
a speciﬁc protocol. Even in the context of the ongoing speci-
ﬁcation of TLS 1.3, generality is a beneﬁt for informing basic
aspects of the design (such as the complex issues related to
late client authentication). At the same time, we stress that
a full analysis of TLS 1.3 is well beyond the scope of this
work.
Related Work. The literature on key-exchange protocols
is extensive with many diﬀerent models and many analyzed
protocols. Yet, the number of papers dealing with unilat-
eral authentication is relatively small. In particular, the ba-
sic earlier models, such as those of Bellare-Rogaway [1] and
Canetti-Krawczyk (CK) [9], do not treat it. One exception
is the work by Shoup [34] that deals with “anonymous pro-
tocols” explicitly. Halevi and Krawczyk [17] treat unilateral
security in the context of password protocols. Our treat-
ment is based on the CK model which we specialize to the
unilateral case with minimal changes following the approach
of [26, 25]. More recently, and motivated by the increased
interest in analyzing TLS, several papers study unilateral
authentication. Particularly, the works of Maurer et. al [29]
and Goldberg et al. [16] center on this model but do not deal
with the question of building generic transformations from
unilateral to mutual authentication.
Several works have presented authentication compilers for
unauthenticated key-exchange protocols including [2, 9] and
[19]. Authenticators from [2, 9] can be applied to upgrade
unilateral authentication (UA) to mutual authentication (MA)
but since authenticators are applied separately to each UA
protocol message they result in added (and possibly inter-
leaved) interaction, hence necessitating of changes in the UA
part of the protocol (rather than acting as an extension).
The compilers from [19] are intended to lift unauthenticated
protocols to mutually authenticated ones, but a closer look
reveals that they do not achieve this goal except if identi-
ties are somehow included under their signatures and MACs.
Even if ﬁxed, applying such compilers to a UA protocol is
“overkill” (in terms of communication and complexity, e.g.,
the compilers from [19] add 3-6 ﬂows to the protocol) and
handshake messages, a design choice being contemplated by
the TLS working group. Avoiding such dedicated key has
the major advantage of dispensing with cumbersome mech-
anisms involving trial decryption and the like.
1439applying “half” compiler (in one direction only) does not nec-
essarily work. For example, the SIGMA protocol from [24]
shows that if each party signs the transcript (but not the
identities) and also applies a MAC on its own identity then
the protocol is secure. However, if we used the same tech-
nique for one party only to upgrade a UA protocol to MA
we would end with an insecure protocol (see Section 3.1).
The recent work of Kohlweiss et al. [23] analyzes a UA-to-
MA transformation based on client passwords. We leave for
future work the analysis of other compilers (e.g., one where
both parties sign part of the transcript and only MAC their
own identity as in [24] or a variant of SIGMAC where the
client’s signature is replaced with KEM-based authentica-
tion).
Analyses of TLS that address unilateral authentication
include [30, 26, 21, 5, 22, 6, 3] and work directly relevant
to TLS 1.3 [28, 14, 12, 23, 25, 13, 11]. Of particular rel-
evance to the present paper is the work of Cremers et al.
[11] who present a detailed formal analysis of TLS 1.3 (draft
10) using the Tamarin prover.
It includes a formulation
of delayed client authentication whose analysis uncovered a
surprising attack on an early TLS 1.3 version of this mech-
anism which we use as a motivating example in Section 3.1.
Additional work related to post-authentication in diﬀerent
protocol settings is the design of “channel binding” proto-
cols whose track record of repeated breaks illustrates the
misleading intuition behind many of these techniques - see
Bhargavan et al. [7, 4]. It will be interesting to apply the