引言  
在Blackhat2018，来自Secarma的安全研究员Sam
Thomas讲述了一种攻击PHP应用的新方式，利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。
漏洞原理  
漏洞触发点在使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Metadata信息会被反序列化。其实这个漏洞点并不是第一次出现，早在hitcon2017就被Orange大佬用来出CTF题了（见baby^h-master-php-2017）。  
从PHP官方手册中我们可以看到Meta-data是用serialize()生成并保存在phar文件中的：  
跟进PHP内核可以看到，当内核调用phar_parse_metadata()解析metadata数据时，会调用php_var_unserialize()对其进行反序列化操作，因此会造成反序列化漏洞。  
漏洞利用  
在Sam Thomas的举出的例子中可以看到，该漏洞主要通过利用魔术方法 **destruct或**
wakeup构造利用链，但是在实战环境里往往较难找到可以直接通过魔术方法触发的漏洞点。  
由于通过反序列化可以产生任意一种数据类型，因此我想到了PHP的一个很古老的漏洞：PHP内核哈希表碰撞攻击（CVE-2011-4885）。在PHP内核中，数组是以哈希表的方式实现的，攻击者可以通过巧妙的构造数组元素的key使哈希表退化成单链表（时间复杂度从O(1)
=> O(n)）来触发拒绝服务攻击。  
PHP修复此漏洞的方式是限制通过$_GET或$_POST等方式传入的参数数量，但是如果PHP脚本通过json_decode()或unserialize()等方式获取参数，依然将受到此漏洞的威胁。  
接下来的漏洞利用思路就很明显了：构造一串恶意的serialize数据（能够触发哈希表拒绝服务攻击），然后将其保存到phar文件的metadata数据区，当文件操作函数通过phar://协议对其进行操作的时候就会触发拒绝服务攻击漏洞！
我们可以通过如下代码生成一个恶意的phar文件：
    hacker = $array;
    $p = new Phar(__DIR__ . '/avatar.phar', 0);
    $p['hacker.php'] = '';
    $p->setMetadata($new_obj);
    $p->setStub('GIF');
然后通过如下代码测试拒绝服务攻击效果：
[2]  
[3]  
[4]  
[5]
~ChaMd5安全招聘~  
360企业安全  
安全分析师  
逆向分析师  
数据挖掘工程师  
安全运营顾问  
中国羊奶城  
市场部经理  
新媒体运营/编辑  
上海匡创信息技术有限公司  
渗透测试工程师  
代码审计工程师  
安全开发工程师  
网信集团  
高级安全工程师（代码审计方向）  
多者金融  
Python高级工程师  
众安科技  
二进制安全专家  
安全运维工程师  
安全产品经理  
信息安全运营实习生  
大数据数据分析实习生  
平安集团信息安全运营中心  
SOC监控工程师  
猎豹移动安全平台部  
安全工程师  
安全开发工程师  
上海锦江国际电子商务有限公司  
渗透测试工程师  
北京丁牛科技有限公司  
渗透测试岗  