involved when something has gone wrong, so you shouldn’t assume that network ser-
vices will be available in this situation.
 The solution is to make user credentials available to the device so that it can locally
authenticate the user. This doesn’t mean that the user’s password hash should be
transmitted to the device, because this would be very dangerous: an attacker that
intercepted the hash could perform an offline dictionary attack to try to recover the
password. Even worse, if the attacker compromised the device, then they could just
intercept the password directly as the user types it. Instead, the credential should be
short-lived and limited to just the operations needed to access that device. For exam-
ple, a user can be sent a one-time code that they can display on their smartphone as a
QR code that the smart locker can scan. The same code is hashed and sent to the
519
Offline access control
device, which can then compare the hash to the QR code and if they match, it opens
the locker, as shown in figure 13.9.
For this approach to work, the device must be online periodically to download new
credentials. A signed, self-contained token format can overcome this problem. Before
leaving to service a device in the field, the technician can authenticate to a central
authorization server and receive an OAuth2 access token or OpenID Connect ID
token. This token can include a public key or a temporary credential that can be used
to locally authenticate the user. For example, the token can be bound to a TLS client
certificate as described in chapter 11, or to a key using CWT PoP tokens mentioned in
section 13.3.2. When the technician arrives to service the device, they can present
the access token to access device APIs over a local connection, such as Bluetooth
Secure locker
Locker 1
Locker 2
Cloud retailer
One-time code
SHA-256(one-time code)
Locker 1
QR code
scanner
When the user orders
goods for collection, they
are given a one-time code.
A secure hash of the
code and details of the
delivery are transmitted
to the locker.
The user’s phone
displays the code
as a QR code that is
scanned by the locker.
If the code matches
the hash, then the locker
is unlocked and the
code deleted.
Figure 13.9
One-time codes can be periodically sent to an IoT device such as a 
secure locker. A secure hash of the code is stored locally, allowing the locker to 
authenticate users even if it cannot contact the cloud service at that time.
520
CHAPTER 13
Securing IoT APIs
Low-Energy (BLE). The device API can verify the signature on the access token and
check the scope, issuer, audience, expiry time, and other details. If the token is valid,
then the embedded credentials can be used to authenticate the user locally to allow
access according to the conditions attached to the token.
13.4.2 Offline authorization
Offline authentication solves the problem of identifying users without a direct con-
nection to a central authentication service. In many cases, device access control
decisions are simple enough to be hard-coded based on pre-existing trust relation-
ships. For example, a device may allow full access to any user that has a credential
issued by a trusted source and deny access to everybody else. But not all access con-
trol policies are so simple, and access may depend on a range of dynamic factors and
changing conditions. Updating complex policies for individual devices becomes diffi-
cult as the number of devices grows. As you learned in chapter 8, access control poli-
cies can be centralized using a policy engine that is accessed via its own API. This
simplifies management of device policies, but again can lead to problems if the device
is offline.
 The solutions are similar to the solutions to offline authentication described in the
last section. The most basic solution is for the device to periodically download the lat-
est policies in a standard format such as XACML, discussed in chapter 8. The device
can then make local access control decisions according to the policies. XACML is a
complex XML-based format, so you may want to consider a more lightweight policy
language encoded in CBOR or another compact format, but I am not aware of any
standards for such a language.
 Self-contained access token formats can also be used to permit offline authoriza-
tion. A simple example is the scope included in an access token, which allows an
offline device to determine which API operations a client should be allowed to call.
More complex conditions can be encoded as caveats using a macaroon token format,
discussed in chapter 9. Suppose that you used your smartphone to book a rental car.
An access token in macaroon format is sent to your phone, allowing you to unlock the
car by transmitting the token to the car over BLE just like in the example at the end of
section 13.4.1. You later drive the car to an evening event at a luxury hotel in a
secluded location with no cellular network coverage. The hotel offers valet parking,
but you don’t trust the attendant, so you only want to allow them limited ability to
drive the expensive car you hired. Because your access token is a macaroon, you can
simply append caveats to it restricting the token to expire in 10 minutes and only
allow the car to be driven in a quarter-mile radius of the hotel. 
 Macaroons are a great solution for offline authorization because caveats can be
added by devices at any time without any coordination and can then be locally verified
by devices without needing to contact a central service. Third-party caveats can also
work well in an IoT application, because they require the client to obtain proof of
authorization from the third-party API. This authorization can be obtained ahead
521
Summary
of time by the client and then verified by the device by checking the discharge maca-
roon, without needing to directly contact the third party.
Answers to pop quiz questions
1
False. The PSK can be any sequence of bytes and may not be a valid string.
2
d. the ID is authenticated during the handshake so you should only trust it after
the handshake completes.
3
d. Entity authentication requires that messages are fresh and haven’t been
replayed.
4
b, c, and d.
5
a.
6
c. The device authorization grant.
Summary
 Devices can be identified using credentials associated with a device profile.
These credentials could be an encrypted pre-shared key or a certificate contain-
ing a public key for the device.
 Device authentication can be done at the transport layer, using facilities in TLS,
DTLS, or other secure protocols. If there is no end-to-end secure connection,
then you’ll need to implement your own authentication protocol.
 End-to-end device authentication must ensure freshness to prevent replay attacks.
Freshness can be achieved with timestamps, nonces, or challenge-response pro-
tocols. Preventing replay requires storing per-device state, such as a monotoni-
cally increasing counter or recently used nonces.
 REST APIs can prevent replay by making use of authenticated request objects
that contain an ETag that identifies a specific version of the resource being
acted on. The ETag should change whenever the resource changes to prevent
replay of previous requests.
 The OAuth2 device grant can be used by devices with no input capability to
obtain access tokens authorized by a user. The ACE-OAuth working group at
Pop quiz
6
Which OAuth authorization grant can be used on devices that lack user input
features?
a
The client credentials grant
b
The authorization code grant
c
The device authorization grant
d
The resource owner password grant
The answer is at the end of the chapter.
522
CHAPTER 13
Securing IoT APIs
the IETF is developing specifications that adapt OAuth2 for use in constrained
environments.
 Devices may not always be able to connect to central cloud services. Offline
authentication and access control allow devices to continue to operate securely
when disconnected. Self-contained token formats can include credentials and
policies to ensure authority isn’t exceeded, and proof-of-possession (PoP) con-
straints can be used to provide stronger security guarantees.
523
appendix A
Setting up Java
and Maven
The source code examples in this book require several prerequisites to be installed
and configured before they can be run. This appendix describes how to install and
configure those prerequisites. The following software is required:
■
Java 11
■
Maven 3
A.1
Java and Maven
A.1.1
macOS
On macOS, the simplest way to install the pre-requisites is using Homebrew (https://
brew.sh). Homebrew is a package manager that simplifies installing other software
on macOS. To install Homebrew, open a Terminal window (Finder > Applications >
Utilities > Terminal) and type the following command:
/usr/bin/ruby -e "$(curl -fsSL 
➥ https://raw.githubusercontent.com/Homebrew/install/master/install)"
This script will guide you through the remaining steps to install Homebrew. If
you don’t want to use Homebrew, all the prerequisites can be manually installed
instead.
INSTALLING JAVA 11
If you have installed Homebrew, then the latest Java can be installed with the fol-
lowing simple command:
brew cask install adoptopenjdk
524
APPENDIX A
Setting up Java and Maven
TIP
Some Homebrew packages are marked as casks, which means that they
are binary-only native applications rather than installed from source code.
In most cases, this just means that you use brew cask install rather than brew
install.
The latest version of Java should work with the examples in this book, but you can tell
Homebrew to install version 11 by running the following commands:
brew tap adoptopenjdk/openjdk
brew cask install adoptopenjdk11
This will install the free AdoptOpenJDK distribution of Java into /Library/Java/Java-
VirtualMachines/adoptopenjdk-11.0.6.jdk. If you did not install Homebrew, then
binary installers can be downloaded from https://adoptopenjdk.net. 
 Once Java 11 is installed, you can ensure that it is used by running the following
command in your Terminal window:
export JAVA_HOME=$(/usr/libexec/java_home -v11)
This instructs Java to use the OpenJDK commands and libraries that you just installed.
To check that Java is installed correctly, run the following command:
java -version
You should see output similar to the following:
openjdk version "11.0.6" 2018-10-16
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.1+13)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.1+13, mixed mode)
INSTALLING MAVEN
Maven can be installed from Homebrew using the following command:
brew install maven
Alternatively, Maven can be manually installed from https://maven.apache.org. To
check that you have Maven installed correctly, type the following at a Terminal window:
mvn -version
The output should look like the following:
Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-
17T19:33:14+01:00)
Maven home: /usr/local/Cellar/maven/3.5.4/libexec
Java version: 11.0.1, vendor: AdoptOpenJDK, runtime: /Library/Java/
JavaVirtualMachines/adoptopenjdk-11.0.1.jdk/Contents/Home
Default locale: en_GB, platform encoding: UTF-8
OS name: "mac os x", version: "10.14.2", arch: "x86_64", family: "mac"
525
Installing an Authorization Server
A.1.2
Windows
On Windows 10, you can install the dependencies using Homebrew using the Win-
dows Subsystem for Linux (WSL). To install WSL, go to https://docs.microsoft.com/
en-us/windows/wsl/about and follow the instructions. You can then follow the
instructions for installing Homebrew for Linux in section A.1.3.
A.1.3
Linux
On a Linux system, you can either install the dependencies using your distribution’s
package manager, or you can install Homebrew and follow the same instructions for
macOS to install Java and Maven. To install Homebrew on Linux, follow the instruc-
tions at https://docs.brew.sh/Homebrew-on-Linux.
A.2
Installing Docker
Docker (https://www.docker.com) is a platform for building and running Linux con-
tainers. Some of the software used in the examples is packaged using Docker, and the
Kubernetes examples in chapters 10 and 11 require a Docker installation.
 Although Docker can be installed through Homebrew and other package managers,
the Docker Desktop installation tends to work better and is easier to use. You can down-
load the installer for each platform from the Docker website or using the following links:
■
Windows: http://mng.bz/qNYA
■
MacOS: https://download.docker.com/mac/stable/Docker.dmg
■
Linux installers can be found under https://download.docker.com/linux/
static/stable/
After downloading the installer for your platform, run the file and follow the instruc-
tions to install Docker Desktop.
A.3
Installing an Authorization Server
For the examples in chapter 7 and later chapters, you’ll need a working OAuth2
Authorization Server (AS). There are many commercial and open source AS imple-
mentations to choose from. Some of the later chapters use cutting-edge features that
are currently only implemented in commercial AS implementations. I’ve therefore
provided instructions for installing an evaluation copy of a commercial AS, but you
could also use an open source alternative for many of the examples, such as MITREid
Connect (http://mng.bz/7Gym). 
A.3.1
Installing ForgeRock Access Management
ForgeRock Access Management (https://www.forgerock.com) is a commercial AS
(and a lot more besides) that implements a wide variety of OAuth2 features.
NOTE
The ForgeRock software is provided for evaluation purposes only.
You’ll need a commercial license to use it in production. See the ForgeRock
website for details.
526
APPENDIX A
Setting up Java and Maven
SETTING UP A HOST ALIAS
Before running AM, you should add an entry into your hosts file to create an alias
hostname for it to run under. On MacOS and Linux you can do this by editing the
/etc/hosts file, for example, by running:
sudo vi /etc/hosts
TIP
If you’re not familiar with vi use your editor of choice. Hit the Escape
key and then type :q! and hit Return to exit vi if you get stuck.
Add the following line to the /etc/hosts file and save the changes:
127.0.0.1  as.example.com
There must be at least two spaces between the IP address and the hostname.
 On Windows, the file is in C:\Windows\System32\Drivers\etc\hosts. You can create
the file if it doesn’t already exist. Use Notepad or another plain text editor to edit the
hosts file.
WARNING
Windows 8 and later versions may revert any changes you make to
the hosts file to protect against malware. Follow the instructions on this site to
exclude the hosts file from Windows Defender: http://mng.bz/mNOP.
RUNNING THE EVALUATION VERSION
Once the host alias is set up, you can run the evaluation version of ForgeRock Access
Management (AM) by running the following Docker command:
docker run -i -p 8080:8080 -p 50389:50389 \
  -t gcr.io/forgerock-io/openam:6.5.2
This will download and run a copy of AM 6.5.2 in a Tomcat servlet environment inside
a Docker container and make it available to access over HTTP on the local port 8080. 
TIP
The storage for this image is non-persistent and will be deleted when
you shut it down. Any configuration changes you make will not be saved.
Once the download and startup are complete, it will display a lot of console output
finishing with a line like the following:
10-Feb-2020 21:40:37.320 INFO [main] 
➥ org.apache.catalina.startup.Catalina.start Server startup in 
➥ 30029 ms
You can now continue the installation by navigating to http:/ /as.example.com:8080/
in a web browser. You will see an installation screen as in figure A.1. Click on the link
to Create Default Configuration to begin the install.
 You’ll then be asked to accept the license agreement, so scroll down and tick the
box to accept and click continue. The final step in the installation is to pick an admin-
istrator password. Because this is just a demo environment on your local machine,
527
Installing an Authorization Server
choose any value you like that is at least eight characters long. Make a note of the pass-
word you’ve chosen. Type the password into both boxes and then click Create Config-
uration to finalize the installation. This may take a few minutes as it installs the
components of the server into the Docker image.
 After the installation has completed, click on the link to Proceed to Login and
then enter the password you chose during the installer with the username amadmin.
You’ll end up in the AM admin console, shown in figure A.2. Click on the Top Level
Realms box to get to the main dashboard page, shown in figure A.3.
 On the main dashboard, you can configure OAuth2 support by clicking on the
Configure OAuth Provider button, as shown in figure A.3. This will then give you the
option to configure OAuth2 for various use cases. Click Configure OpenID Connect
and then click the Create button in the top right-hand side of the screen.
 After you’ve configured OAuth2 support, you can use curl to query the OAuth2
configuration document by opening a new terminal window and running:
curl http://as.example.com:8080/oauth2/.well-known/
➥ openid-configuration | jq
TIP
If you don’t have curl or jq installed already, you can install them by run-
ning brew install curl jq on Mac or apt-get install curl jq on Linux. On
Windows, they can be downloaded from https://curl.haxx.se and https://
stedolan.github.io/jq/.
Figure A.1
The ForgeRock AM installation screen. Click on the link to Create Default Configuration.
528
APPENDIX A
Setting up Java and Maven
Figure A.2
The AM admin console home screen. Click the Top Level Realms box.
Click Conﬁgure OAuth Provider
to set up OAuth2 support.
OAuth2 clients are
conﬁgured under
Applications.
Figure A.3
In the main AM dashboard page, click Configure OAuth Provider to set up OAuth2 support. 
Later, you will configure an OAuth2 client under the Applications page in the sidebar.
529
Installing an Authorization Server
The JSON output includes several useful endpoints that you’ll need for the examples
in chapter 7 and later. Table A.1 summarizes the relevant values from the configura-
tion. See chapter 7 for a description of these endpoints.
To register an OAuth2 client, click on Applications in the left-hand sidebar, then
OAuth2, and then Clients. Click the New Client button and you’ll see the form for
basic client details shown in figure A.4. Give the client the ID “test” and a client secret.
You can choose a weak client secret for development purposes; I use “password.”
Finally, you can configure some scopes that the client is permitted to ask for.
TIP
By default, AM only supports the basic OpenID Connect scopes: openid,
profile, email, address, and phone. You can add new scopes by clicking on
Table A.1
ForgeRock AM OAuth2 endpoints
Endpoint name
URI
Token endpoint
http:/ /as.example.com:8080/oauth2/access_token
Introspection endpoint
http:/ /as.example.com:8080/oauth2/introspect
Authorization endpoint
http:/ /as.example.com:8080/oauth2/authorize
UserInfo endpoint
http:/ /as.example.com:8080/oauth2/userinfo
JWK Set URI
http:/ /as.example.com:8080/oauth2/connect/jwk_uri
Dynamic client registration endpoint
http:/ /as.example.com:8080/oauth2/register
Revocation endpoint
http:/ /as.example.com:8080/oauth2/token/revoke
Figure A.4
Adding a new client. Give the client a name and a client secret. Add some permitted scopes. Finally, 
click the Create button to create the client.
530
APPENDIX A
Setting up Java and Maven
Services in the left-hand sidebar, then OAuth2 Provider. Then click on the
Advanced tab and add the scopes to the Supported Scopes field and click