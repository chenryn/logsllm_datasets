title:The Startup Problem in Fault-Tolerant Time-Triggered Communication
author:Wilfried Steiner and
Hermann Kopetz
The Startup Problem
in Fault-Tolerant Time-Triggered Communication
Wilfried Steiner
Real-Time Systems Group
Hermann Kopetz
Real-Time Systems Group
Vienna University of Technology, Austria
Vienna University of Technology, Austria
PI:EMAIL
PI:EMAIL
Abstract
Fault-tolerant time-triggered communication relies on
the synchronization of local clocks. The startup problem
is the problem of reaching a sufﬁcient degree of synchro-
nization after power-on of the system. The complexity of
this problem naturally depends on the system assumptions.
The system assumptions in this paper were compiled from
cooperation with partners in the automotive and aeronautic
industry. We present a general startup strategy for safety-
critical systems that discusses the solution to the startup
problem from an abstract point of view. From this abstract
view we derive and analyze a new startup algorithm that is
used in a TTP/C research derivative protocol (LTTP). We
also analyze the FlexRay startup algorithm and discuss its
behavior in presence of simple failures. The analyses were
done by exhaustive fault simulation using the SAL model
checker. While LTTP was found to tolerate the arbitrary
failure of one node, the FlexRay startup shows to be vulner-
able to simple failure modes.
1 Introduction
A fault-tolerant system calls for a distributed solution
where the critical tasks are replicated on several “nodes”
to tolerate the permanent loss of parts of the system. A ma-
jor problem in distributed systems is the communication of
information between nodes. An attractive way for message
exchange is the usage of shared communication media such
as bus or star topologies, which allows a reduction of phys-
ical connections. The application of shared resources, how-
ever, introduces a mutual exclusion problem and, hence,
dedicated communication protocols have to be used to guar-
antee that each node connected to the shared medium will
get its speciﬁed amount of bandwidth for communication.
Time-division multiple-access (TDMA) protocols, such as
FlexRay [4] or TTP/C [9], which are protocols that off-line
specify the access pattern of nodes to the shared medium,
are promising due to low transmission latency and trans-
mission jitter. In order to establish synchronization, TDMA
protocols have to solve the startup problem.
Claesson et al. present a strategy for the solution of the
startup problem that is based on unique message lengths
and full-duplex communication links [3]. L¨onn discusses
startup algorithms in [12] and formally veriﬁes with Pet-
tersson a particular startup algorithm in [13]. The startup
algorithms discussed within this paper, which are startup al-
gorithms based on unique timeouts, are similar to the startup
algorithm of the Token Bus protocol [7]. Kr¨uger introduces
such an algorithm for the startup of time-triggered proto-
cols [11]. The TTP/C startup algorithm as speciﬁed in [9]
is based on this principle.
The presented approaches are based on fault-hypotheses
which assume certain restricted fault-models for an indi-
vidual node, e.g., fail-silence. Despite the research of the
startup problem, none of the presented work tolerates the ar-
bitrary failure of one node (e.g. masquerading) [17]. Hence,
in further research, [19], we aimed to establish a sufﬁcient
degree of fault tolerance (see the fault hypothesis in Sec-
tion 2.2) by introducing a guardian concept. In that work
we tried to avoid changes in the startup algorithm of TTP/C
which led to three necessary design choices for the guardian
instances:
• the guardian has to execute a “semantic ﬁlter”, that is,
messages are analyzed by the guardian and, if a se-
mantic failure is detected, the message is transformed
into a syntactically faulty message, by truncation of the
message,
• the centralized guardian instances have to use “inter-
links” which are uni-directional direct connections be-
tween the two centralized guardians, such that a cen-
tralized guardian receives the messages transmitted on
the respective other channel, and
• any one non-faulty guardian has to be powered-on be-
fore any non-faulty node starts to transmit messages.
This paper presents a general startup strategy that makes
these design choices optional by moving fault-tolerance
functionality from the guardian instances to the startup al-
gorithm. We start this paper in Section 2 by thoroughly dis-
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:30:08 UTC from IEEE Xplore.  Restrictions apply. 
cussing our system assumptions, which include the physi-
cal structure, the fault hypothesis, the minimum system re-
quirements, timing assumptions, and the synchronous op-
eration mode and steady state. Section 3 formulates the
startup problem. In Section 4 we present the general startup
strategy. Section 5 discusses two particular startup al-
gorithms: a new LTTP startup algorithm that was devel-
oped according the general startup strategy and the FlexRay
startup algorithm. The analysis of both algorithms was done
by model-checking experiments. This paper concludes in
Section 6.
2 System Model
2.1 Physical Structure
Physically, a system, consists of nodes and replicated
channels. The channels are implemented as half-duplex
connections, either in bus or star topology. To avoid
medium access by a faulty node we specify guardians that
can be either local at the nodes [20], or central at hubs [2]. If
central guardians are implemented, these components may
be connected directly. This paper does not cover the con-
struction of a guardian instance. A general study of central
guardians was done in [14, Chapter 5], where two particular
implementations are presented as well.
2.2 Fault Hypothesis
Each node and each communication channel (together
with its guardian) forms one fault-containment region
(FCR) [10], that is, a fault within an FCR may cause this
FCR to fail, but no different FCR. The failure modes of the
different FCRs are deﬁned as follows. A node is allowed to
fail “arbitrarily”, that means it may: a) send arbitrary sig-
nals, b) at arbitrary times, c) for arbitrary durations.
The fault model of a channel is deﬁned to be “passive
arbitrary”. That means a faulty channel/guardian: a) may
delay and accelerate a message only for an upper bound in
time, b) may relay a received message only to a subset of
connected nodes, and c) may not create correct messages.
On a logical, algorithmic level these failure modes mean:
a faulty node is allowed to send an arbitrary sequence of
messages and noise (that is activity that is not recognized
as a valid message), with arbitrary intervals of silence in
between two accesses to the communication channels. A
faulty channel may relay valid messages only to a (possibly
empty) subset of nodes whenever a node sends a valid mes-
sage. Furthermore, a faulty channel is allowed to send noise
itself to a subset of nodes at any time.
The system has to tolerate the permanent loss of any one
of its FCRs in the deﬁned failure mode. We say the system
assumes a “single-failure hypothesis”.
Byzantine Failure We consider Byzantine failures to ap-
pear as SOS failures [1] that have been examined during
fault-injection experiments and as an architecture decision
the central guardians were equipped with control mecha-
nism to transform such asymmetric SOS behavior into de-
tectable symmetric failures. This method is also called
“Byzantine ﬁltering” in the literature [5].
This interpretation of a Byzantine faulty component ab-
stracts from failures caused by metastability [8]. A faulty
node may send such a metastable signal that can be inter-
preted by two receivers differently. However, such a signal
would have to propagate through the central guardians. By
increasing the logic in the central guardians as well as by
decreasing their clock speed, the probability of the propa-
gation of the metastable signal can be reduced.
Information Loss Our system model, which is based on
a shared communication medium, causes the manifestation
of a particular failure behavior: a faulty component may
not only introduce additional faulty information, it can po-
tentially cause a reduction of correct information. In our
case this reduction can be caused by a faulty channel that
drops messages but can also be caused by a faulty node that
destroys a message of a correct node by sending at an inap-
propriate point in time.
2.3 Minimum Conﬁguration
the
correct
execution of
We require a minimum conﬁguration of four nodes
to guarantee
clock-
synchronization algorithm. This is a natural consequence
of the deﬁned fault hypothesis: a) the failure behavior of a
faulty node may be arbitrary; b) in general we need 3k + 1
nodes to tolerate k arbitrary faulty nodes; c) we allow one
node to fail d) hence, for k = 1 we need 4 nodes to tolerate
one arbitrary faulty component.
the
We also require a minimum number of two channels: a)
the failure behavior of a faulty channel may be passive arbi-
trary; b) we allow one channel to fail; c) hence, having two
channels allows the good channel to mask the failure of the
faulty channel.
2.4 Timing Assumptions
We assume the following timing bounds:
Bounded Propagation Delay:
for a correct channel there
is a known upper bound δpd on the propagation delay. δpd
consists of the time it takes for sending the ﬁrst bit of a mes-
sage, transporting, and receiving the ﬁrst bit of a message
over a communication medium.
every correct node n has a local
Bounded Clock Drift:
clock Cn with a known bounded rate of drift ρn ≥ 0 with
respect to physical time.
Bounded Processing Time:
for every correct node there
are known upper and lower bounds on the time required by
a process to execute a processing step.
the time, ∆power−on ,
Uncertain Power-On Time:
that a correct node/channel needs until it is able to par-
ticipate in the distributed system, is bounded but not known.
The ﬁrst three items are natural assumptions and usually
reﬂect the upper bounds that are required for real-time sys-
tems. The last item in this enumeration is the most critical
one because it makes the distinction of a crashed component
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:30:08 UTC from IEEE Xplore.  Restrictions apply. 
from a late component impossible; this follows from the im-
possibility result on crash failure detection in asynchronous
systems [6]. Of course, the easiest way to circumvent the
problem with item 4 is to ignore it and require known up-
per bounds for all actions in the computer system, that is, to
move to a fully synchronous system. However, the power-
on line is external to the communication protocol. By using
the eventually synchronous system model, the developed
algorithms apply as well to those applications that require
bounded power-on times at design time, and those that do
not. And, of course, less assumptions increase the assump-
tion coverage of the system model.
2.5 Synchronous Operation, Steady State
During synchronous operation the nodes execute a
time-triggered communication (also called a time-division
media-access) strategy. Such a strategy splits up time into
(non-overlapping) pieces of not necessarily equal durations
τ slot , which are called slots. Slots are grouped into se-
quences called TDMA rounds of length τ round . The se-
quence of slots is the same for all TDMA rounds. The
knowledge which node occupies which slot in a TDMA
round is static, available to all components a priori, and
equal for all TDMA rounds, we call this information the
“TDMA round layout”. We assume that each node will oc-
cupy only one slot per TDMA round.
Steady state is then reached when the synchronous oper-
ation tolerates the failure of a component according the fault
hypothesis. If the system is in steady state and one compo-
nent becomes (or stays) faulty, the system is still able to ex-
ecute clock synchronization, that means the startup process
does not have to be re-executed.
In an extended version of this paper [16] we discuss the
impossibility of a steady state detection algorithm under the
given system model.
3 Problem Speciﬁcation
There are two key properties that a startup algorithm has
to guarantee: timely startup and safe startup.
Property 1 Timely Startup:
Whenever at least a minimum conﬁguration of nodes
and channels is powered-on, a startup algorithm establishes
synchronous communication of the non-faulty components
within an upper bound in time.
The minimum conﬁguration is speciﬁed in Section 2.3.
The “whenever” factor in the property speciﬁcation is
highly important, since it does not specify an upper bound
in time until a minimum conﬁguration is powered-up. Note
also that this timeliness property is stronger than a “live-
ness” property: in contrast to liveness properties, timeliness
properties require a known upper bound on the duration af-
ter which a property has to be established.
Property 2 Safe Startup:
When the startup algorithm terminates, all correct nodes
that communicate synchronously are synchronized to each
other.
The safety property ensures that the startup algorithm
will not produce multiple “cliques”, that are sets of nodes
that communicate synchronously within the set but not with
nodes in other sets. However, cliques can be formed tempo-
rally during the startup process.
Ensuring these properties is a non-trivial problem, even
in the failure-free case, since there is a cyclic dependency
between the synchronization process and the communica-
tion process:
• each synchronization process requires the timely and
• a shared broadcast medium requires synchronization in
order to timely and deterministically deliver messages.
deterministic delivery of messages, and
4 General Startup Strategy
The general strategy for starting up the system is de-
picted in Figure 1. It identiﬁes three protocol phases: in-
tegration, coldstart, and sync.
Init
Integrate
Coldstart
Sync
Figure 1. General startup strategy
After power-on (that is after the node is initialized) the
node starts the integration phase. As deﬁned by the sys-
tem model, each slot in the communication schedule is a
priori assigned to a sending node and each message carries