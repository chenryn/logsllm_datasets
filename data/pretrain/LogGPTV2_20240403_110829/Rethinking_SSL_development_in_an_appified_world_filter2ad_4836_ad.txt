code analysis and interviews.
We only allow this option on devices that have developer
settings enabled. Thus, app developers have a simple way to
work with self-signed certiﬁcates during development while
preventing careless users from turning oﬀ SSL certiﬁcate val-
idation for their apps.4 Nonetheless, we show a warning
message using strong wording that advises against abuse
(cf. Fig. 2(b)) when this option is toggled.
4While it is conceivable that users annoyed by warning mes-
sages could ﬁnd information online on how to activate de-
veloper options and then turn oﬀ certiﬁcate validation for a
speciﬁc app, we believe this risk is fairly low compared to
the huge beneﬁt this option brings. Additionally, we recom-
mend limiting this option to devices that are registered with
Google developer accounts to prevent normal users from
55(a) Developer settings to turn
oﬀ certiﬁcate validation for an
app. This option is not dis-
played for normal users.
(b) On disabling validation, a
message warns against security
threats.
Figure 2: Instead of writing code, SSL parameters
can be changed with via Developer settings options.
5.2.3 SSL Pinning
SSL public key pinning can be conﬁgured by app develop-
ers to limit the number of certiﬁcates an app trusts. It can
either be used to specify exactly which CA certiﬁcates are
trusted to sign SSL certiﬁcates for this app or directly specify
which individual SSL certiﬁcates are to be used. The stan-
dard Android approach to use certiﬁcate pinning requires
developers to implement it individually in their source code,
resulting in only very few apps implementing pinning at all.5
The standard approach for limiting the number of trusted
issuers is using a custom keystore, which is also complex
and requires custom code to load the keystore. Using our
extension, it is possible to conﬁgure SSL certiﬁcate pinning
in an Android app’s Manifest.xml ﬁle. This allows devel-
opers who know which endpoints their app connects to (this
should be most apps) to easily and securely add SSL pin-
ning without having to write any code. Figure 3 shows the
Manifest.xml for an Android app with SSL pinning.
Pinning individual leaf certiﬁcates also allows developers
to use self-signed certiﬁcates in a production environment
in a secure way, which is a requirement several app devel-
opers articulated (cf. Section 4). In case developers wish
to restrict the number of trusted issuers instead of pinning
individual leaf certiﬁcates, pins for certiﬁcate issuers can be
added to the Manifest.xml ﬁle in the same way. The app
then accepts only certiﬁcates issued by the pinned certiﬁ-
cate issuers. To simplify the process of creating certiﬁcate
pins and adding them to the Manifest.xml ﬁle, we extended
Eclipse’s Android Development Tools. This way pins for
given certiﬁcates can be generated and added to an app’s
Manifest.xml ﬁle automatically.
Since SSL public key pinning can be problematic in some
rare cases, for instance if a company mandates the use of
an SSL proxy6, we allow for SSL pinning to be disabled
globally using the (enterprise) Device Administration API
policies. While careless users cannot unintentionally turn
oﬀ SSL pinning since they do not have access to the De-
carelessly breaking their apps’ SSL security.
5One of these apps is the Twitter app by Twitter Inc., for
whom Moxie Marlinspike developed the SSL pinning code.
6Some companies use SSL proxy servers to monitor the net-
work traﬃc of their employees.
Figure 3: The new SSL conﬁguration options for an
Android app’s Manifest.xml ﬁle allow developers to
easily conﬁgure diﬀerent options for handling SSL.
Developers can pin either leaf or issuer certiﬁcates,
determine if their app should log SSL-relevant infor-
mation and observe how their apps react to failed
SSL certiﬁcate validations. By default no pin is set,
logging is turned oﬀ and apps refuse to connect to
hosts for which certiﬁcate validation failed.
vice Administration API, enterprises can conﬁgure devices
to respect company policies.
5.2.4 User Protection
Currently it is entirely up to the developers to implement
the UI to interact with the user when something goes wrong
with SSL. This has led to a large number of apps silently
accepting invalid certiﬁcates, crashing or displaying unin-
telligible warning messages such as: ”Reset your local time
to the current time” when faced with a certiﬁcate valida-
tion error. The lack of a ready-to-use warning message was
also an issue criticized by developers in our study. It should
also be impossible for app developers to invisibly accept un-
trusted certiﬁcates without the users’ consent. We oﬀer a
system-triggered, standardized warning that gives app users
the chance to recognize security threats originating from
insecure SSL connections, thus preventing app developers
from silently accepting invalid certiﬁcates. This capability
is needed for apps that connect to endpoints outside of the
control of developers and thus might not have trusted cer-
tiﬁcates, such as mobile browsers, news readers, blog aggre-
gators, etc.7. In these cases, the users are allowed to decide
if they want to connect anyway after being shown a warning
message.
Usability studies on SSL warning messages for browsers [16]
show that designing meaningful and eﬀective SSL warning
messages is a challenging task. Designing such a system is
outside the scope of this paper which is why we use An-
droid’s stock browser warning message for now. Still, we
think that having a standardized warning message that app
developers can use to let the user decide what to do with
untrusted certiﬁcates is a good starting point for such fu-
ture work. Issues such as habituation need to be taken into
account at that point, but showing any warning message is
better than allowing apps to silently accept all invalid cer-
tiﬁcates due to developers’ negligence.
7One of the developers we interviewed explicitly stated he
turned oﬀ certiﬁcate validation for his app entirely because
his customers wanted to connect to blogs with self-signed
certiﬁcates.
AndroidManifest.xml169    170    171    172    173    174    175    176    177    178    179180 181  182  183  184  185 186 187 188189190191192Page 756While we no longer allow developers to silently accept con-
nections for which validation fails, we do allow developers to
be more restrictive and drop connections for which valida-
tion fails without allowing the user to override. This is the
correct (and default) behavior for most apps where the de-
veloper knows which endpoints the app communicates with
and these endpoints have valid certiﬁcates, such as online
banking, social networking and most other single purpose
apps. As long as developers exercise due diligence with their
server certiﬁcates, the only validation errors would be in the
presence of a real MITMA.8 In these cases, users would be
eﬀectively protected from themselves.
The decision of whether a warning message should be dis-
played or connections should be dropped was added as a
conﬁguration parameter to an app’s manifest (cf. Fig. 3).
Thus, our framework can protect users of multi-purpose
apps from developers who would hide warnings and accept
untrusted certiﬁcates as well as enabling developers to pro-
tect their users from accidentally accepting connections from
MITMAs for apps where the endpoints are known in ad-
vance.
5.2.5 Alternate SSL Validation Strategies
One feature which oﬀers promising future potential is the
capability of our system to plug new validation strategies
into the system and thus protect both new and existing
apps without requiring a large number of app developers
to update their code. This could signiﬁcantly speed up
the adoption of alternatives to the current weakest-link CA
based system. We have created a plugin infrastructure for
this purpose and are in the process of evaluating Certiﬁcate
Transparency (CT) [11] and AKI [10] as new approaches to
validate certiﬁcates. This feature is still in the experimental
phase and is currently conﬁgured into an app’s manifest. It
is a matter for future work to research how and by whom this
feature should be conﬁgured and of course to create plugins
to improve certiﬁcate validation.
6. EVALUATION
As Section 4 showed, all broken SSL implementations on
Android and iOS came about because developers wanted
to customize the way their app uses SSL and failed to do
so safely. While our new approach to SSL-development in
apps closes all the security holes we found, it will only be
adopted by developers if all their needs are met and they
feel comfortable with conﬁguration instead of coding. To
evaluate our approach, we conducted two evaluation studies.
We ran interviews with the 14 developers of our previous
developer study to discuss how they perceived our proposed
solution and if they would be comfortable using it. Since the
number of developers available for interview was fairly small,
we also did an extensive code analysis of all custom SSL-
handling code in the set of 13,500 Android apps to ensure
that all use-cases could be covered by our solutions and thus
remove the need for dangerous code-level customization.
6.1 Developer Evaluation
8We realize not all developers practice due diligence with
their certiﬁcates, however we still believe this to be the
right default setting. With this setting developers would
quickly realize that there is a problem with their certiﬁcate
and would be forced to update it.
We conducted a pre-test study in which novice developers
added SSL to their apps and used pinning and self-signed
certiﬁcates. Since our framework made all these tasks triv-
ial, we decided not to deploy this study on a large scale, since
it would not have led to any valuable insights. Instead, we
focused on whether the proposed paradigm shift would ﬁnd
the developers’ approval and make them feel comfortable
with conﬁguring SSL instead of implementing it. We pre-
sented our approach to the 14 developers from Section 4.2
and queried them if these features would fulﬁll their require-
ments and remove the need to customize the way their app
uses SSL. We also asked if they would feel comfortable us-
ing conﬁguration instead of coding to add advanced features
such as SSL pinning to their apps.
All use-cases of these developers were met with our new
design and the reaction of the developers was very positive.
They conﬁrmed their previous statements – that SSL devel-
opment is too complex – and that they very much appre-
ciated anything which would ease the burden. They were
particularly positive about the option to use self-signed cer-
tiﬁcates during development and to use pinning in such an
easy way for their production apps. None of the interviewed
developers were concerned that they could not fulﬁll their
certiﬁcate validation tasks with the provided conﬁguration
options. Due to the small number of developers willing to
discuss the problems they have with SSL development, we
decided to follow up this qualitative study with a quantita-
tive study.
6.2 Compatibility Evaluation
To evaluate whether our proposed solution really covers
all relevant use-cases, we ran another static code analysis on
the set of 13,500 Android apps [5]. We extracted all cus-
tomized TrustManager implementations and manually an-
alyzed the semantics of the checkServerTrusted methods.
Unlike in the previous study, we also analyzed the 2.04 %
of implementations that customized SSL handling without
breaking SSL. While there are not many apps in this cate-
gory, it is still imperative that these good apps also continue
to work as expected with our new approach. In total, we
found 3,464 classes that implement customized TrustMan-
agers. We categorized them based on their handling of SSL
validation compared to the default procedure. Table 2 gives
an overview of the customizations we found. We denote a
customization that weakens certiﬁcate validation with a “−”,
a customization that strengthens validation with a “+” and
customizations that do not aﬀect validation security with a
“=”.
Customized Implementations
Accept All Certiﬁcates
Expiry-Only Check
Leaf-Cert Pinning
Add Logging to Default Validation
Add Hostname Pinning to Default Validation
Limit Trusted Issuers
I
y
t
t
i
c
r
a
u
p
c
m
e
3,464 S
−
−
+
=
+
+
3,098
263
47
32
16
8
Table 2: Distribution of Customized TrustManager
Implementations in Android Apps
57In the 97.02 % of cases where TrustManagers accept all
certiﬁcates or only check certiﬁcates’ expiry dates, our ap-
proach protects app users from careless developers by enforc-
ing secure certiﬁcate validation. As we previously showed [5],
97.1 % of the endpoints in the 1,074 vulnerable apps had
valid certiﬁcates. In these cases, our modiﬁcation ﬁxes the
apps without any development eﬀort or negative side-eﬀects
for the developer or the user.
In the remaining 2.9 % of
cases, the endpoints used by the apps do not have valid
certiﬁcates.
In these cases, our system would prevent the
connection, unless the developer installs a valid certiﬁcate,
updates their application to pin the current certiﬁcate or
sets the handle-validation-fails option in the manifest
(cf. Fig. 3) to show warning messages. Since all three mod-
iﬁcations a developer would have to perform are very easy
in our framework, we believe this to be a good trade-oﬀ for
the broken apps.
While the majority of all implementations turns eﬀective
SSL certiﬁcate validation oﬀ entirely, a small number of de-
velopers created beneﬁcial customizations. 0.9 % of Trust-
Managers add logging to the default certiﬁcate validation
process. While this does not strengthen certiﬁcate valida-
tion itself, it still is a potentially positive feature that should
not be made impossible. We therefore added a conﬁguration
option (cf. Fig. 3) that allows developers to get log output
from the framework’s validation process.
0.5 % of implementations add hostname veriﬁcation di-
rectly to the certiﬁcate validation process. This strengthens
an app’s security since default SSL certiﬁcate validation does
not cover checking the hostname during the SSL handshake
outside of an HTTPSUrlConnection. This feature is covered
in our framework (cf. Section 5.2.1 above).
In the 1.6 % of cases where TrustManagers were used to
improve SSL validation (i. e. through pinning a leaf certiﬁ-
cate or a CA), the functionality added by the custom code is
available as a conﬁgurable option in our solution. Thus, we
found no custom SSL code which implements a use-case that
is not covered by our solution with signiﬁcantly less eﬀort.
We conducted ﬁeld trials that conﬁrmed this analysis.
6.3 Deployability
All our modiﬁcations are implemented as part of An-
droid’s Java Framework. A system update would thus be
the most convenient way to make the new features of our
system available to developers and users. All apps built
from then on would use this update by default and would