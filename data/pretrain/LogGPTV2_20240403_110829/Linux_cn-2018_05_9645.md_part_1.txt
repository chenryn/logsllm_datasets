---
author: Gustavo Duarte
category: 技术
comments_data: []
count:
  commentnum: 0
  favtimes: 1
  likes: 0
  sharetimes: 0
  viewnum: 12538
date: '2018-05-15 18:31:28'
editorchoice: false
excerpt: 栈非常重要，因为它追踪着一个程序中运行的函数，而函数又是一个软件的重要组成部分。
fromurl: https://manybutfinite.com/post/journey-to-the-stack/
id: 9645
islctt: true
largepic: /data/attachment/album/201805/15/182842wn8zd9pnfynzfh4v.jpg
permalink: /article-9645-1.html
pic: /data/attachment/album/201805/15/182842wn8zd9pnfynzfh4v.jpg.thumb.jpg
related:
- displayorder: 0
  raid: 9731
reviewer: ''
selector: ''
summary: 栈非常重要，因为它追踪着一个程序中运行的函数，而函数又是一个软件的重要组成部分。
tags:
- 堆栈
- 栈帧
- 函数
thumb: false
title: 探秘“栈”之旅
titlepic: true
translator: qhwdw
updated: '2018-05-15 18:31:28'
---
![](/data/attachment/album/201805/15/182842wn8zd9pnfynzfh4v.jpg)
早些时候，我们探索了 [“内存中的程序之秘”](/article-9255-1.html)，我们欣赏了在一台电脑中是如何运行我们的程序的。今天，我们去探索*栈的调用*，它在大多数编程语言和虚拟机中都默默地存在。在此过程中，我们将接触到一些平时很难见到的东西，像 闭包   closure 、递归、以及缓冲溢出等等。但是，我们首先要作的事情是，描绘出栈是如何运作的。
栈非常重要，因为它追踪着一个程序中运行的*函数*，而函数又是一个软件的重要组成部分。事实上，程序的内部操作都是非常简单的。它大部分是由函数向栈中推入数据或者从栈中弹出数据的相互调用组成的，而在堆上为数据分配内存才能在跨函数的调用中保持数据。不论是低级的 C 软件还是像 JavaScript 和 C# 这样的基于虚拟机的语言，它们都是这样的。而对这些行为的深刻理解，对排错、性能调优以及大概了解究竟发生了什么是非常重要的。
当一个函数被调用时，将会创建一个 栈帧   stack frame 去支持函数的运行。这个栈帧包含函数的*局部变量*和调用者传递给它的*参数*。这个栈帧也包含了允许被调用的函数（*callee*）安全返回给其调用者的内部事务信息。栈帧的精确内容和结构因处理器架构和函数调用规则而不同。在本文中我们以 Intel x86 架构和使用 C 风格的函数调用（`cdecl`）的栈为例。下图是一个处于栈顶部的一个单个栈帧：
![](/data/attachment/album/201805/15/183135uglyl5cwdxxwizzs.png)
在图上的场景中，有三个 CPU 寄存器进入栈。 栈指针   stack pointer  `esp`（LCTT 译注：扩展栈指针寄存器） 指向到栈的顶部。栈的顶部总是被最*后一个推入到栈且还没有弹出*的东西所占据，就像现实世界中堆在一起的一叠盘子或者 100 美元大钞一样。
保存在 `esp` 中的地址始终在变化着，因为栈中的东西不停被推入和弹出，而它总是指向栈中的最后一个推入的东西。许多 CPU 指令的一个副作用就是自动更新 `esp`，离开寄存器而使用栈是行不通的。
在 Intel 的架构中，绝大多数情况下，栈的增长是向着*低位内存地址*的方向。因此，这个“顶部” 在包含数据的栈中是处于低位的内存地址（在这种情况下，包含的数据是 `local_buffer`）。注意，关于从 `esp` 到 `local_buffer` 的箭头不是随意连接的。这个箭头代表着事务：它*专门*指向到由 `local_buffer` 所拥有的*第一个字节*，因为，那是一个保存在 `esp` 中的精确地址。
第二个寄存器跟踪的栈是 `ebp`（LCTT 译注：扩展基址指针寄存器），它包含一个 基指针   base pointer 或者称为 帧指针   frame pointer 。它指向到一个*当前运行*的函数的栈帧内的固定位置，并且它为参数和局部变量的访问提供一个稳定的参考点（基址）。仅当开始或者结束调用一个函数时，`ebp` 的内容才会发生变化。因此，我们可以很容易地处理在栈中的从 `ebp` 开始偏移后的每个东西。如图所示。
不像 `esp`， `ebp` 大多数情况下是在程序代码中通过花费很少的 CPU 来进行维护的。有时候，完成抛弃 `ebp` 有一些性能优势，可以通过 [编译标志](http://stackoverflow.com/questions/14666665/trying-to-understand-gcc-option-fomit-frame-pointer) 来做到这一点。Linux 内核就是一个这样做的示例。
最后，`eax`（LCTT 译注：扩展的 32 位通用数据寄存器）寄存器惯例被用来转换大多数 C 数据类型返回值给调用者。
现在，我们来看一下在我们的栈帧中的数据。下图清晰地按字节展示了字节的内容，就像你在一个调试器中所看到的内容一样，内存是从左到右、从顶部至底部增长的，如下图所示：
![](/data/attachment/album/201805/15/183138nz4ogo2hlsa4oihg.png)
局部变量 `local_buffer` 是一个字节数组，包含一个由 null 终止的 ASCII 字符串，这是 C 程序中的一个基本元素。这个字符串可以读取自任意地方，例如，从键盘输入或者来自一个文件，它只有 7 个字节的长度。因为，`local_buffer` 只能保存 8 字节，所以还剩下 1 个未使用的字节。*这个字节的内容是未知的*，因为栈不断地推入和弹出，*除了你写入的之外*，你根本不会知道内存中保存了什么。这是因为 C 编译器并不为栈帧初始化内存，所以它的内容是未知的并且是随机的 —— 除非是你自己写入。这使得一些人对此很困惑。
再往上走，`local1` 是一个 4 字节的整数，并且你可以看到每个字节的内容。它似乎是一个很大的数字，在8 后面跟着的都是零，在这里可能会误导你。
Intel 处理器是 小端   little endian 机器，这表示在内存中的数字也是首先从小的一端开始的。因此，在一个多字节数字中，较小的部分在内存中处于最低端的地址。因为一般情况下是从左边开始显示的，这背离了我们通常的数字表示方式。我们讨论的这种从小到大的机制，使我想起《格里佛游记》：就像小人国的人们吃鸡蛋是从小头开始的一样，Intel 处理器处理它们的数字也是从字节的小端开始的。
因此，`local1` 事实上只保存了一个数字 8，和章鱼的腿数量一样。然而，`param1` 在第二个字节的位置有一个值 2，因此，它的数学上的值是 `2 * 256 = 512`（我们与 256 相乘是因为，每个位置值的范围都是从 0 到 255）。同时，`param2` 承载的数量是 `1 * 256 * 256 = 65536`。