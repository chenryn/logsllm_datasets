# CVE-2019-0211 Apache提权漏洞分析
##### 译文声明
本文是翻译文章，文章原作者 cfreal，文章来源：cfreal.github.io
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 简介
从2.4.17（2015年10月9日）到2.4.38(2019年4月1日)的Apache
HTTP版本中，存在着一个可以通过数组越界调用任意构造函数的提权漏洞。这个漏洞可以通过重新启动Apache服务(apache2ctl
graceful)来触发。在Linux默认配置中，每天会在早上6点25分自动运行一次该命令，从而重启日志文件的处理任务。
该漏洞涉及到三个函数mod_prefork,mod_worker和mod_event。后面的漏洞描述，分析和触发都主要从mod_prefork展开。
## 漏洞描述
在MPM prefork模式下，服务器主进程会运行在root权限下，管理一个单线程的进程池。低权限(www-data)的Worker进程处理HTTP请求头。Apache通过共享包含有scoreboard（包含诸如PID、请求等Worker进程信息）的共享内存空间（SHM）来处理worker进程返回的信息。每一个Worker进程都对应一个关联自身PID的process_score结构，拥有着对SHM的读写权限。
ap_scoreboard_image: 共享内存空间的指针
    (gdb) p *ap_scoreboard_image 
    $3 = {
      global = 0x7f4a9323e008, 
      parent = 0x7f4a9323e020, 
      servers = 0x55835eddea78
    }
    (gdb) p ap_scoreboard_image->servers[0]
    $5 = (worker_score *) 0x7f4a93240820
    PID19447的Worker进程的共享内存空间
    (gdb) p ap_scoreboard_image->parent[0]
    $6 = {
      pid = 19447, 
      generation = 0, 
      quiescing = 0 '00', 
      not_accepting = 0 '00', 
      connections = 0, 
      write_completion = 0, 
      lingering_close = 0, 
      keep_alive = 0, 
      suspended = 0, 
      bucket = 0 parent
    type = struct process_score {
        pid_t pid;
        ap_generation_t generation;
        char quiescing;
        char not_accepting;
        apr_uint32_t connections;
        apr_uint32_t write_completion;
        apr_uint32_t lingering_close;
        apr_uint32_t keep_alive;
        apr_uint32_t suspended;
        int bucket; parent[0]->bucket
    (gdb) p all_buckets[$index]
    $7 = {
      pod = 0x7f19db2c7408, 
      listeners = 0x7f19db35e9d0, 
      mutex = 0x7f19db2c7550
    }
    (gdb) ptype all_buckets[$index]
    type = struct prefork_child_bucket {
        ap_pod_t *pod;
        ap_listen_rec *listeners;
        apr_proc_mutex_t *mutex; meth->child_init()这一调用过程，实现暂时以root权限调用函数。
存在风险的代码区域
理一遍server/mpm/prefork/prefork.c来看下是什么地方导致了这一漏洞。
（译者注：L数字代表该文件中对应的代码行数）
  * 一个恶意的Worker进程改变自身共享内存中自身的bucket的值，从而指向共享内存空间。
  * 在第二天的早上6.25分，logrotate请求Apache重启一次服务。
  * 之后Apache主进程会关闭第一个Worker进程，生成新的Worker级才能哼。
  * 这个过程是通过发送SIGUSR1信号给Worker进程来实现的，Worker进程收到信号后会立刻退出。
  * 然后调用prefork_run()（L853）函数来生成新的Worker进程。由于存在retained->mpm->was_graceful这一过程，Worker进程不会立刻重启。
  * 在进入主循环（L933）并监控旧的Worker进程的PID，可以看到旧的Worker进程关闭后，ap_wait_or_timeout()函数会返回它PID的值（L940）
  * process_score的index值以及PID值会存储在child_slot(L948)中
  * 如果删除旧的Worker进程没有报错（L969）的话，make_child()函数会调用ap_get_scoreboard_process(child_slot)->buctet的值作为参数（L985），正如之前提到的一样，bucket的值已经被恶意Worker给修改了。
  * make_child()函数会fork(L671)主进程来生成新的子进程。
  * OOB会读取(L691)发生的过程，导致my_bucket函数遭到攻击者的控制。
  * child_main()函数会调用(L722)，相比(L433)处更快调用函数。
  * SAFE_ACCEPT()只有在Apache监听两个或更多的端口时执行，一般来说服务器通常监听着HTTP(80)和HTTPS(443)
  * 假设成功执行，会调用apr_proc_mutex_child_init()函数，从而通过(*mutex)->meth->child_init(mutex, pool, fname)的调用过程来控制互斥锁。
  * 在执行完(L446)后权限恢复到正常的低权限。
## 利用过程：
利用过程包括四个步骤：1、获取Worker进程的读写权限.2、向共享内存空间（SHM）写入一个假的prefork_child_bucket结构。3、将all_bucket[bucket]指向结构。4、等待构造的函数被调用。
这一过程的好处：
始终没有创建过主进程，所有过程都映射在访问/proc/self/maps(ASLR/PIE保护无效)中，当一个Worker进程关闭或报错时，它会自动由主进程重新创建，所以不会有DOS
Apache服务器的风险。
缺点：
PHP不允许对/proc/self/mem的读写，也就是说我们没法直接编辑共享内存空间，只能等待重启的时候调用all_bucket函数。
###  1\. 获取Worker进程的读写权限
PHP UAF的0day漏洞
由于mod_prefork函数经常和mod_php函数一起使用，因此可以从CVE-2019-6977这里下手实现漏洞的利用。我在写exp的过程中发现PHP7.X下的UAF
0day漏洞在PHP5.X中也能复现。
    PHP UAF
    y;
        return $this;
      }
    }
    function get_aslr()
    {
      global $p, $y;
      $p = 0;
      $y = [new X('PT1S')];
      json_encode([1234 => &$y]);