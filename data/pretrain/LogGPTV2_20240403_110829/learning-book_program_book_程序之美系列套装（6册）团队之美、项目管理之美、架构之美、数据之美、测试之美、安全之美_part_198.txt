代码
JPCJava代码
静态类
图9-8：JPC架构中的三个编译器
目前我已经知道如何使我们的模拟程序速度更快，但是，我们稍微
掩盖了一些详细信息。这些详细信息（我们的新问题）现在落入两
个不同的区域：我们如何进行这样的编译，以及我们应该如何载入
最终的类？
9.8.1编译：如何多此一举
我们这里讲述的编译器不是最理想的例子，但是，我们所处的情况
也略有些不平常。javac和JPC编译器都仅是第一阶段的编译器，这
意味着它们仅仅把它们的输出提供给第二阶段，一个字节码解析程
序或一个即时编译器。我们知道javac几乎不优化它的输出：javac生
成的字节码只是输入的Java代码的一个翻译（参见例9-2）。
例9-2：Javac的未优化的编译
1118
---
## Page 1120
public int function () public int function () ;
{0: iconst_1
boolean a=true: l: istore_l
if (a) 2: iload_1
return 1: 3: ifeq 8
else 6: iconst_1
return 0: 7: ireturn
)8: iconst_0
9: ireturn
很容易证明进行最小限度的优化是恰当的，因为大部分的优化工作
都留给编译的后续阶段来进行。在JIPC中，我们不仅有理由，也有
额外的时间压力：
我们想要使编译的并销最小化以避免占用其他模拟程序线程的CPU
时间。
我们想要使编译的延迟时间最短以便解析的类可以尽快地替换。一
要了。
简单的代码生成
现在，JIPC中的编译任务就是把单个解析的基础块的微代码转换到
一组Java字节码这么简单的一件事。我们最有可能会假设这个基础
块不能抛出异常。这意味着这样的基础块是一个严格定义的基础
块，只有一个入口和一个出口。现在，由一个特定基础块改进的每
个变量都可以由包含一组输入寄存器和内存状态的一个函数来表
示。在JPC内部，我们共同把这些函数表示成一个有向无环图。
图的源点（source）
源点表示以寄存器值的形式或直接以指令的形式的输入数据。
1119
---
## Page 1121
图的汇点（sink）
汇点表示以寄存器值和内存的形式的输出数据或写I/O端口的输出数
据。对于受到块影响的每个状态变量，都有一个汇点。
图的边界（edge）
边界表示变量值在图的内部传播。
图的节点（node）
节点表示对输入边界的运算，其结果会沿着输出边界传播。在JIPC
中，这些运算是对已解析微代码的单态修正的组成部分。因此，如
果微代码影响多个变量，它就会映射到多个图节点。
把已解析基础块的这种图形表示法转换到Java字节码，只是图形上
每个汇点依次简单的最浅层的移动。图中的每个节点把栈中最顶端
的元素作为输入，然后把它的结果放在最顶端，准备由任意子节点
进行处理（参见图9-9）。
注意：图的经典的最佳移动顺序需要每个节点上的优先权都应该按
深度的顺序进行计算。距离最远源的路线最长的节点应该最先计
算，路线最短的节点最后计算。在一个基于寄存器的目标上，这会
生成最短的代码，因为它消除了大多数的寄存器修改。在一个基于
栈的机器上，例如JVM，同样的决策过程会引起编码的栈深度最
小。在JPC中，我们忽略这些细节并依靠IVM消除其中的差异，仅
追踪所有节点的深度这个额外的复杂情况就不值得这么做。
1120
---
## Page 1122
代码
栈
①loadeax
xea
EAX
load eax
ebx
loadebx
xea
ADD
loadeax
ebx+eax
③loadebx
ppe
loadeax
EAX
loadebx
4
ppe
?
storeeax
图9-9：把x86运算表示成一个有向无环图
这种汇点接着汇点、最浅层分析的方式引起图的自然优化，如图9-
10所示。对应于无用代码的图的孤立部分不能通过汇点访问，所以
会自动删除，因为解析永远都不会达到那儿。在图的解析中，重用
的代码区域会发现自身计算了多次。我们可以把它们的结果缓存到
一个本地变量中，在对这个节点进行后续访问时载入这个结果，由
此避免了所有的代码重复。
与一棵树中的节点相关联的代码表示成由源编译成的部分JPC代码
的单个静态函数。那样，我们生成的代码只是对处理器变量的一系
列推动并直接压入栈，紧接着是对每个节点的一系列静态调用，最
后是取出成一系列的处理器对象。
技巧#2：静态好
如果一个方法可以定义成静态的，那就定义成静态的。静态方法不
是虚的，所以，不会动态分派。与实例方法相比，高级的VM更容
易也更愿意内联静态的方法。
1121
---
## Page 1123
重复节点
EAX
EBX
孤立部分
ADD
ECX
CX
EBX
SUB
ADD
EAX
ECX
图9-10：有向无环图的特性
处理异常
既然我们可以处理基础块的编译，那么，我们必须把一些异常情况
恢复正常。正如我们先前讨论的那样，异常并不总是错误。页错误
和保护系统侵犯很自然地任意抛出。当异常抛出时，处理器的状态
必须和最后成功执行的那个操作一致。这对于编译器来说显然有相
当重要的含义。把IA-32中的异常映射到Java异常，我们知道这个问
题的唯一可用的解决办法是在异常处理器中捕获这个异常，然后确
保处理器的状态与最后成功的操作一致。
任意特定基础块内的异常行为路线就像基础块本身的路线。它有一
个入口和一个出口，和主路线唯一的区别是出口。因为异常的路线
和基础块本身的路线的区别不是很大，描绘它的最自然的方式是在
它自己的有向非循环图内。异常路线的图将和基础块共享相同的
组节点，但是，它另外拥有一组映射到它自己不同的出口的汇点。
然后，异常处理器的代码通过遍历选定的路线图而生成了。当异常
抛出时，与主路线共享的节点重新设置回主路线遍历它们时的原来
状态。这意味着从主路线来的所有缓存和计算值都可以在异常处理
器中重用，因此避免了重复任何工作。
1122
---
## Page 1124
字节码处理
已经有许多已建立和设计良好的解决方案来把我们已编译的字节码
转变成可载入的类。Apache的字节码工程库（ByteCodeEngineering
Library,BCEL）自身定位于便利地“分析、创建和处理（二进制的）
Java类文件”。【2LASM是一个"完全致力于Java字节码处理和分析的
框架”。[3]
遗憾的是，我们要做的只是修改单个框架类中的单个方法（总是修
改同一个方法）。我们只能生成一小部分可能的字节码序列，不必
提供任何分析工具。这样看来，BCEL和ASM对我们的要求来说有
些重量级了。我们改为并发一个只有非常有限能力的完全符合我们
需要的定制的字节码处理库。例如，我们的栈深度算法调整为快速
确定方法的最大栈深度（以便它们可以通过验证）。虽然这个算法
不适用于常规的类编译，但是，对于我们的用途来说，它足够了，
而且更有效。
技巧#9：小心外部的库
避免使用超出你的目的的外部库。如果任务简单而且重要，那就认
真地考虑在内部编码实现它；定制的解决方案可能更适合这个任
务，导致更好的性能和更少的外部依赖。
[1]对于那些喜欢摆弄JVM顽皮代码的人来说，位于
可以用来做许多非常有趣的事，包括重新定义类文件。
[2]_http://jakarta.apache.org/bcel
[3]http://asmobjectweb.org/.
9.8.2大规模的类加载和卸载
既然有了类，那么，它们必须进行加载。第一个显而易见的问题是
“有多少？”图9-11给了我们关于这个问题的一个说明。可以证实把
100000个类加载到单个JVM中只是一个微不足道的挑战。
1123
---
## Page 1125
100000
90000
80000
70000
类
60000
载入的
50000
40000
30000
20000
10000
0
00:00:00