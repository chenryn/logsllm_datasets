## Q5：六个最实用的、督促自己学习的办法看到很多同学在留言里分享了自己学习方法，我看了也非常受益，我把这些方法筛选总结了一下，又结合我自己的学习经验，放在这里分享给你。1.  好奇心是一个优秀程序员必然要有的特质。多去想想"为什么是这样的"，有助于你更深入地掌握这些知识点。2.  先了解知识面，再寻找自己有兴趣的点深入，学习也是个反复迭代的过程。3.  带着问题去学习是最快的成长方式之一。彻底搞清楚实际在开发过程中遇到的困难的问题，而不是只满足于功能问题被实现和解决，是提升自己的必经之路。4.  "教别人"是一种非常高效的学习方式，自己有没有弄清楚，在教别人的过程中，会体会得明明白白。5.  每个月给自己投资 100-200    块在专业学习上面，这样花了钱，通过外部约束，也是一个让自己坚持下去的好办法。6.  坚持到底就是胜利✌️。把学习和成长变成一种习惯，这个习惯带来的惯性会让你更快地成长。------------------------------------------------------------------------好了，到这里，我们第一期答疑就要结束了。这次我主要和你谈了谈"学习"这个话题，不知道你有什么感受呢？你还想听我和你聊什么专栏之外的话题呢？欢迎积极留言给我。如果觉得这篇文章对你有帮助，也欢迎你收藏并分享给你的朋友。对了，看到这里的同学，记得在留言区给后面的同学招个手啊：）![](Images/79d06107d349635530fbf82aa8dfb625.png){savepage-src="https://static001.geekbang.org/resource/image/28/29/281ca28b90c8aa0aecbb5adc08394f29.jpg"}
# FAQ第二期 \| 世界上第一个编程语言是怎么来的？你好，我是徐文浩，今天是第二期 FAQ，我搜集了第 3 讲到第 6讲，大家在留言区问的比较多的问题，来做一次集中解答。有些问题，可能你已经知道了答案，不妨看看和我的理解是否一样；如果这些问题刚好你也有，那可要认真看啦！希望今天的你，也同样有收获！------------------------------------------------------------------------
## Q1：为什么 user + sys 运行出来会比 real time 多呢？![](Images/2105d6f8e23b83732ab6530fbfb9c2c6.png){savepage-src="https://static001.geekbang.org/resource/image/36/4c/3665db1602c971c2cad1932ee8d0804c.png"}我们知道，实际的计算机运行的过程中，CPU会在多个不同的进程里面切换，分配不同的时间片去执行任务。所以，运行一个程序，在现实中走过的时间，并不是实际CPU 运行这个程序所花费的时间。前者在现实中走过的时间，我们叫作 realtime。有时候叫作 wall clock time，也就是墙上挂着的钟走过的时间。而实际 CPU 上所花费的时间，又可以分成在操作系统的系统调用里面花的 systime 和用户态的程序所花的 user time。如果我们只有一个 CPU 的话，那 realtime \>= sys time + user time。所以，我当时在文章里给大家看了对应的示例。不过，有不少同学运行出来的结果不是这样的。这是因为现在大家都已经用上多核的CPU 了。也就是同一时间，有两个 CPU 可以同时运行任务。你在一台多核或者多 CPU 的机器上运行，seq 和 wc 命令会分配到两个 CPU上。虽然 seq 和 wc 这两个命令都是单线程运行的，但是这两个命令在多核 CPU运行的情况下，会分别分配到两个不同的 CPU。``{=html}于是，user 和 sys 的时间是两个 CPU 上运行的时间之和，这就可能超过 real的时间。而 real 只是现实时钟里走过的时间，极端情况下 user+sys 可以到达real 的两倍。你可以运行下面这个命令，快速验证。让这个命令多跑一会儿，并且在后台运行。    time seq 100000000 | wc -l &然后，我们利用 top 命令，查看不同进程的 CPU 占用情况。你会在 top的前几行里看到，seq 和 wc 的 CPU 占用都接近100，实际上，它们各被分配到了一个不同的 CPU 执行。我写这篇文章的时候，测试时只开了一个 1u 的最小的虚拟机，只有一个CPU，所以不会遇到这个问题。
## Q2：时钟周期时间和指令执行耗时有直接关系吗？![](Images/310c9d5c88b2fd8c651682a15f5b9016.png){savepage-src="https://static001.geekbang.org/resource/image/f9/31/f9da13f81cc676645a224b8ea6744931.png"}这个问题提的得非常好，[\@易儿易]{.orange}同学的学习和思考都很仔细、深入。"晶振时间与 CPU执行固定指令耗时成正比"，这个说法更准确一点。我们为了理解，可以暂且认为，是晶振在触发一条一条电路变化指令。这就好比你拨算盘的节奏一样。算盘拨得快，珠算就算得快。结果就是，一条简单的指令需要的时间就和一个时钟周期一样。当然，实际上，这个问题要比这样一句话复杂很多。你可以仔细去读一读专栏关于CPU 的章节呢。从最简单的单指令周期 CPU来说，其实时钟周期应该是放下最复杂的一条指令的时间长度。但是，我们现在实际用的都没有单指令周期CPU了，而是采用了流水线技术。采用了流水线技术之后，单个时钟周期里面，能够执行的就不是一个指令了。我们会把一条机器指令，拆分成很多个小步骤。不同的指令的步骤数量可能还不一样。不同的步骤的执行时间，也不一样。所以，一个时钟周期里面，能够放下的是最耗时间的某一个指令步骤。这样的话，单看一条指令，其实一定需要很多个时钟周期。也就是说，从响应时间的角度来看，一个时钟周期一定是不够执行一条指令的。但是呢，因为有流水线，我们同时又会去执行很多个指令的不同步骤。再加上后面讲的像超线程技术等等，从吞吐量的角度来看，我们又能够做到，平均一个时钟周期里面，完成指令数可以超过1。想要准确理解 CPU 的性能问题，请你一定去仔细读一读专栏的整个 CPU的部分啊。
## Q3：为什么低压主频只有标压的 2/3？计算向量点积的时候，怎么提高性能？![](Images/b7b00c2cf6712dbaa45087cad51f4899.png){savepage-src="https://static001.geekbang.org/resource/image/87/6b/87e8925f9d8b12906164e17dad86626b.png"}低压和低主频都是为了减少能耗。比如 Surface Go的电池很小，机器的尺寸也很小。如果用上高主频，性能更好了，但是耗电并没有下来。另外，低电压对于 CPU的工艺有更高的要求，因为太低的电压可能导致电路都不能导通，要高主频一样对工艺有更高的要求。所以一般低压CPU 都是通过和低主频配合，用在对于移动性和续航要求比较高的机器上。向量计算是可以通过让加法也并行来优化的，不过真实的 CPU 里面其实是通过SIMD 指令来优化向量计算的，我在后面也会讲到 SIMD 指令。
## Q4：世界上第一个编程语言是怎么来的？![](Images/035621a66c2d0bec3617d89c74f4e57b.png){savepage-src="https://static001.geekbang.org/resource/image/8d/75/8d8e399dfef0d4b62c34910ccd4f4d75.png"}如果你去计算机历史博物馆看一下真机，就会明白，第一台通用计算机ENIAC，它的各种输入都是一些旋钮，可以认为是类似用机器码在编程，后来才有了汇编语言、C语言这样越来越高级的语言。编程语言是自举的，指的是说，我们能用自己写出来的程序编译自己。但是自举，并不要求这门语言的**第一个**编译器就是用自己写的。比如，这里说到的 Go，先是有了 Go 语言，我们通过 C++ 写了编译器A。然后呢，我们就可以用这个编译器 A，来编译 Go语言的程序。接着，我们再用 Go 语言写一个编译器程序 B，然后用 A 去编译B，就得到了 Go 语言写好的编译器的可执行文件了。这个之后，我们就可以一直用 B 来编译未来的 Go语言程序，这也就实现了所谓的自举了。所以，即使是自举，也通常是先有了别的语言写好的编译器，然后再用自己来写自己语言的编译器。更详细的关于鸡蛋问题，可以直接看 Wikipedia上[这个链接](https://en.wikipedia.org/wiki/Bootstrapping_(compilers))，里面讲了多种这个问题的解决方案。