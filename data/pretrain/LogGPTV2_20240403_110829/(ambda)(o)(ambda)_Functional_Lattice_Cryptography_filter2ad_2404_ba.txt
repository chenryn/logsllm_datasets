--
Mul intp (PreDiv2 intp z2), Div2 intp z2, ...)
=> intp e (PreMul intp (PreDiv2 intp z2) -> z2)
expr = untag $ rescalePTPow2 @2 -- set k=2 => p=4
pprint expr
-- "(\\v0 -> (div2 ((mul v0) (addLit (Scalar ZqB 1) v0))))"
192
Note that the type of expr (including the complex type of the input to the object-language
function) is inferred by the Haskell compiler.
6.6.2 Ring Rounding
Our goal is to round the coefï¬cients of an encrypted cyclotomic ring element. Recall
from subsection 5.3.1 that the ğ‘šth cyclotomic ring is isomorphic to Z[ğ‘‹]/(Î¦ğ‘š(ğ‘‹)), so
elements can be represented as a list of coefï¬cients with respect to some ï¬xed basis. For
a cyclotomic ring ğ‘…, moduli ğ‘ = 2ğ‘˜, ring rounding proceeds by ï¬rst moving the Zğ‘
coefï¬cients of the input into â€œCRT slotsâ€ of a different ring ğ‘†ğ‘ using ring switching. Once
the coefï¬cients are in slots, we can apply the Zğ‘ rounding function rescalePTPow2 to the
entire ring element, which induces the operation on each coefï¬cient. If desired, we can
use ring switching again to move the rounded coefï¬cients back to the ring Rğ‘. The exact
number of ring switches needed to move the coefï¬cients into slots depends on the particular
choice of parameters. The following example implements a variant of âŒŠÂ·âŒ‰ğ‘ that moves the
coefï¬cients of a ring H0 into the slots of the ring H2 via the intermediate ring H1. Since it
does not switch back, the output ring element is in ğ‘†2:
roundCycCoeffs = do
rescalePT  writeErrorRates prfeval
-- print the error rates
print rates
-- the PRF output
clearResult <- decrypt result
print clearResult
The call to withKeys creates an environment where the compiler creates keys, and encrypt
and ErrorRateWriter use the same keys to encrypt inputs and collect runtime statistics,
respectively. homomPRF prints the intermediate error rates from the homomorphic compu-
tation. result is the output of the homomorphic PRF evaluation, i.e. an encrypted PRF
output, so we print its decryption, i.e. the in-the-clear PRF output.
6.7 ALCHEMY Evaluation
In this section we use the example of homomorphic PRF evaluation to quantify the advan-
tages of using ALCHEMY. For the evaluation, we compute various metrics on the homomPRF
expression given above, but using parameters corresponding to a cryptographically secure
instantiation. Speciï¬cally, we instantiate homomPRF with ğ‘˜ = 5 (corresponding to ğ‘ = 32)
and we use a sequence of ï¬ve tunnels rather than two. These secure parameters allow us
evaluate the savings that users of ALCHEMY are likely to obtain in the real-world.
The main goal of ALCHEMY is to reduce the complexity of writing homomorphic
computations. We can measure these savings by calculating size of an alchemy expression,
in terms of source lines of code and by counting the number of DSL expressions. Of course
ALCHEMY will not be used if the compiled expression is much more inefï¬cient than hand-
196
written homomorphic code for the same operation, so we also evaluate the performance of
compiled expressions.
Expression Size. We can compare the size of the user-written plaintext expression with the
corresponding homomorphic expression produced by the compiler. We measure expression
size with the S interpreter, which counts the number of individual DSL operations that
make up the epxression. Since the compiler introduces new operations, the difference in the
size of the DSL expressions is a rough measure of the work done by the compiler, which
corresponds to reduced complexity for the author of the plaintext expression.
The size of the in-the-clear homomRoundCycCoeffs expression is 39, while the size of
the compiled expression increases to 87. Thus the homomorphic computation has about 48
more DSL operations than the plaintext computation, a considerable savings for the user.
Unfortunately, this measure both overstates and understates ALCHEMYâ€™s contribution.
First, the compiler misses many opportunities for beta reduction, which corresponds to
inlining certain function arguments. A fully beta-reduced expression would be much smaller
(as measured with S) because we could elimiate many lam nodes in the expression. Thus the
compiled expression size could have many fewer than 87 DSL operations. On the other hand,
DSL expression size greatly understates the compilerâ€™s work because it does not account for
the knowledge required for the user to manually insert the extra DSL expressions and to
choose ciphertext moduli.
Comparison to Hand-written Applications. All existing HE implementations require
users to write homomorphic computations using a low-level HE interface. Thus another
way to measure ALCHEMYâ€™s contribution is to compare the number of source lines of code
needed to hand-write a particular application using the HE interface directly with the total
number of lines to write and compile the corresponding ALCHEMY expression on plaintexts.
In order to compare ALCHEMY, we used Î›âˆ˜ ğœ†â€™s SHE interface to write code which
computes the same function as homomPRF. This hand-written implementation uses the SHE
197
interface directly, meaning the author must understand all SHE operations and interfaces
and manually choose appropriate parameters throughout the computation.
The hand-written implementation is about 225 lines of Haskell code, whereas our
ALCHEMY implementation is about ï¬ve lines of code for the (in-the-clear) implementation
of roundCycCoeffs, three more for the PRF, and about ï¬ve lines to invoke the PT2CT
compiler and interpret the result (as in homomPRF). Thus ALCHEMY resulted in about 32x
less code for much more functionality: the hand-written code can only be evaluated, while
we can interpret the ALCHEMY expression in many interesting ways.
Runtime Performance. Finally, we compare the performance of the optimized hand-
written computation with the compiled ALCHEMY expression. The runtime of the hand-
written homomorphic computation is about 44 seconds, while the compiled ALCHEMY
expression can be evaluated in 41 seconds. Thus ALCHEMY expressions incurs no runtime
overhead compared to hand-tuned code, but are much easier to write and more ï¬‚exible to
use.
Homomorphic Encryption for Non-experts. We emphasize that although the above
metrics show that ALCHEMY allows homomorphic computations to be expressed with
moderately less code (with no performance loss), they do not capture how much simpler the
plaintext expressions are compared to their homomorphic counterpart. Homomomorphic
expressions in ALCHEMY can be written with no knowledge of the HE scheme, and compiled
with only general knowledge. Concretely, compared to the ALCHEMY expression, the hand-
written homomorphic computation required knowledge of where to place maintenance
operations, explicit management of moduli at every step of the computation, and the manual
generation of secret keys and key switch hints. Although this simplicity cannot be captured
with simple numbers, we believe it is the most signiï¬cant contribution of this work.
198
CHAPTER 7
CHALLENGES FOR RING-LWE
As lattice cryptography begins a transition to widespread deployment (see, e.g., [Ste14;
LS16; Bra16b]), there is a pressing need for increased cryptanalytic effort and higher-
conï¬dence hardness estimates for its underlying computational problems. Of particular
interest is a class of problems used in many recent implementations (e.g., [HS; GLP12;
Duc+13; Bos+15; Alk+16; Bos+16a] and Î›âˆ˜ğœ† [CP16b]), namely:
â€¢ Learning With Errors (LWE) [Reg09],
â€¢ its more efï¬cient ring-based variant Ring-LWE [LPR13b], and
â€¢ their â€œdeterministic errorâ€ counterparts Learning With Rounding (LWR) and Ring-
LWR [BPR12].
Informally, the search version of the Ring-LWE problem is to ï¬nd a secret ring element ğ‘ 
given multiple random â€œnoisy ring productsâ€ with ğ‘ , while the decision version is to
distinguish such noisy products from uniformly random ring elements. More precisely,
Ring-LWE is actually a family of problems, with a concrete instantiation given by the
following parameters:1
1. a ring ğ‘…, which can often (but not always) be represented as a polynomial quotient
ring ğ‘… = Z[ğ‘‹]/(ğ‘“ (ğ‘‹)) for some irreducible ğ‘“ (ğ‘‹), e.g., ğ‘“ (ğ‘‹) = ğ‘‹ 2ğ‘˜ + 1 or another
cyclotomic polynomial;
2. a positive integer modulus ğ‘ deï¬ning the quotient ring ğ‘…ğ‘ := ğ‘…/ğ‘ğ‘… = Zğ‘[ğ‘‹]/(ğ‘“ (ğ‘‹));
3. an error distribution ğœ’ over ğ‘…, which is typically concentrated on â€œshortâ€ elements
(for an appropriate meaning of â€œshortâ€);
1This actually describes the â€œtweaked,â€ discretized form of Ring-LWE, which for convenience avoids a
special ideal denoted ğ‘…âˆ¨. This form is equivalent to the original â€œuntweakedâ€ form under a suitable change to
the error distribution; see subsection 2.2.7 for details.
199
4. a number of samples provided to the attacker.
The Ring-LWE search problem is to ï¬nd a uniformly random secret ğ‘  âˆˆ ğ‘…ğ‘, given indepen-
dent samples of the form
(ğ‘ğ‘– , ğ‘ğ‘– = ğ‘  Â· ğ‘ğ‘– + ğ‘’ğ‘–) âˆˆ ğ‘…ğ‘ Ã— ğ‘…ğ‘,
where each ğ‘ğ‘– âˆˆ ğ‘…ğ‘ is uniformly random and each ğ‘’ğ‘– â† ğœ’ is drawn from the error
distribution. The decision problem is to distinguish samples of the above form from
uniformly random samples over ğ‘…ğ‘ Ã— ğ‘…ğ‘.
Ring-LWR is a â€œderandomizedâ€ variant of Ring-LWE in which the random errors are
replaced by deterministic â€œroundingâ€ to a smaller modulus ğ‘ < ğ‘. Speciï¬cally, the search
problem is to ï¬nd a random secret ğ‘  âˆˆ ğ‘…ğ‘ given independent samples
(ğ‘ğ‘– , ğ‘ğ‘– = âŒŠğ‘  Â· ğ‘ğ‘–âŒ‰ğ‘) âˆˆ ğ‘…ğ‘ Ã— ğ‘…ğ‘,
where each ğ‘ğ‘– âˆˆ ğ‘…ğ‘ is uniformly random, and âŒŠÂ·âŒ‰ğ‘ : ğ‘…ğ‘ â†’ ğ‘…ğ‘ denotes the function
that rounds each coefï¬cient ğ‘ğ‘— âˆˆ Zğ‘ of the input (with respect to an appropriate basis)
ğ‘ Â· ğ‘ğ‘—âŒ‰ âˆˆ Zğ‘. The decision problem is to distinguish such samples from (ğ‘ğ‘–,âŒŠğ‘¢ğ‘–âŒ‰ğ‘),
to âŒŠ ğ‘
where ğ‘ğ‘–, ğ‘¢ğ‘– âˆˆ ğ‘…ğ‘ are uniformly random and independent. (Notice that âŒŠğ‘¢ğ‘–âŒ‰ğ‘ âˆˆ ğ‘…ğ‘ itself is
uniformly random when ğ‘ divides ğ‘, but otherwise is biased.)
Hardness. A main attraction of Ring-LWE (and Ring-LWR) is their worst-case hardness
theorems, also known as worst-case to average-case reductions. Essentially, these say
that solving certain instantiations is at least as hard as quantumly solving a corresponding
approximate Shortest Vector Problem (approx-SVP) on any â€œideal lattice,â€ i.e., a lattice
corresponding to an ideal of the ring. (Interestingly, the converse is unclear: it is unknown
how to solve Ring-LWE using an oracle for even exact-SVP on any ideal lattice of the ring.)
See [LPR13b; PRS17] and [BPR12] for precise theorem statements, subsection 7.1.1 below
200
for further discussion, and [Cra+16; CDW17] for the status of approx-SVP on ideal lattices
for quantum algorithms.2
As long as the underlying approx-SVP problem is actually hard in the worst case, the
above-described theorems give strong evidence of cryptographic hardness, at least asymptot-
ically (i.e., for large enough ğ‘›). For practical purposes, though, the following property of
(Ring-)LWE and related problems has been noticed, studied, and exploited for many years
(see, e.g., [Lyu+08; MR09; Lyu09; LP11; Ban+14; HKM15]): even instantiations that are
not supported by known worst-case hardness theorems, or that have too-small dimensions ğ‘›
to draw any meaningful conclusions from them, can still appear very hardâ€”as measured
against all known classes of attack. Indeed, almost every implementation of lattice cryptog-
raphy to date has used considerably smaller dimensions and errors than what worst-case
hardness theorems alone would recommend. However, care is needed in following this
approach: e.g., some instantiations involving especially small errors turn out to be broken or
seriously weakened by various attacks (see, e.g., [AG11; CLS15; Pei16]).
Given this state of affairs, and especially the common usage in practice of parameters
that lack much (if any) theoretical support, we believe that a deeper understanding of how
the different aspects of Ring-LWE affect concrete hardness is a critically important direction
of research.
7.1 Contributions
This work provides a broad collection of cryptanalytic challenges for concrete instantia-
tions of the search-Ring-LWE/LWR problems over cyclotomic rings, which are the most
widely used and studied class of rings in this context. Our challenges cover a wide variety