conditions via symbolic execution.
Instead, we leverage a concept called counterfactual execution
which systematically explores all executable statements. It neither
requires any inputs of the program, nor is based on symbolic ex-
ecution which has difficulty handling a large number of complex
conditions in real-world PHP programs.
Counterfactual execution enables discovery of parts of code that
would not be accessible in a vanilla dynamic analysis [48]. Specifi-
cally, counterfactual execution (1) forcibly drives an execution into
branches even if the branch conditions are not satisfied, (2) past
exit nodes so that it can execute the pieces of code that are not
normally covered, and (3) continuing executions when exceptions
occur. It enables us to unwrap, decode, and expose the original code
of obfuscated and encoded code.
Malicious Code Discovery in Dynamic Languages. Counter-
factual execution shares the idea of forcing executions into all
possible branches with multi-path exploration [36] and forced exe-
cution [34]. However, counterfactual execution differs from them in
that it focuses on discovery of new code in addition to exploring all
possible paths. Specifically, counterfactual execution treats dynamic
constructs such as eval(), include(), and dynamic function calls,
each of which might lead to discovery of new files and generation
of new paths along the program execution, specially. It does so
by creating nested isolated program states every time a branch
or dynamic construct is encountered. The isolated states not only
CUBISMOInput	(1	file)PHP	ProgramOutput	(Nfiles)Multiple	Decoded	PHP	Programs	…Existing	Malware	DetectorsDetect	Malware	if	at	least	1	out	of	N	file	is	flagged(a)	Cubism	Program	Analysis(b)	Leveraging	Existing	Tools…Cubismo: Decloaking Server-side Malware via Cubist Program Analysis
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
Figure 3: Architecture of Cubismo
Figure 4: Example of Normalization Process
Figure 5: Crash Inducing Program for PHP-Parser
ensure integrity of program state, they also enable continuation of
execution past exceptions and fatal errors (by creating new isola-
tions with negated error conditions). Moreover, PHP malware often
uses nested predicates with dynamic constructs, making analysis at-
tempts by symbolic execution approaches particularly challenging.
Specifically, resolving string arguments of dynamic constructs (e.g.,
eval()) is a challenging problem in symbolic approaches. Counter-
factual execution does not have such problems as it forcibly drives
execution paths regardless of predicate conditions and handles run-
time faults that can be caused by the forced execution paths via its
sandboxed fail-free environment. When there is a runtime error or
an exception that may terminate the execution, Cubismo creates
a new nested isolated program state and continues the execution.
Loops and recursive calls can also hinder analysis. We handle them
by limiting the number of iterations and recursions (e.g., 100 itera-
tions/recursion in this paper). For example, if a loop iterates more
than 100 times, we terminate the loop by manipulating its control
flow.
Sharing Artifacts between Isolated Executions. A vital feature
of counterfactual execution is that it enables sharing of discovered
artifacts throughout isolated executions. Database connections, file
pointers, network connections, function and class redefinitions and
system resources are among the artifacts that can be procured and
shared via counterfactual execution. The importance of this artifact
sharing is shown in Fig. 1, where the obfuscated code in block
6 requires a key obtained in block 2 to decloak itself. Without
counterfactual execution forcing itself into block 2 to discover
and share the key, counterfactual execution of block 6 will yield
no malicious code.
When counterfactual execution encounters a dynamic construct
statement, it checks if other isolated executions have different defi-
nitions for the statement (e.g., including different files via include
or creating different dynamic code). If they do, counterfactual ex-
ecution creates new isolated execution for each of the definitions
from other isolated executions using the current execution context.
We find that such new executions contribute to the discovery of
new statements, resulting in the discovery of a significant propor-
tion of the program code. Indeed our evaluation show that vanilla
multi-path exploration (without sharing analysis results between
explored paths) discovers 36,034 statements in Wordpress (a popu-
lar PHP application), whereas counterfactual execution discovers
58,786 statements, 63% more code.
Figure 6: Example of Counterfactual Execution Discovering
Malicious Code
Robust Sandbox. Counterfactual execution is also bundled with
a robust sandbox to prevent malicious behavior from affecting the
host system, while guarding against reflective and introspective be-
havior. Counterfactual execution sandboxes more than 50 functions
and classes of the original interpreter to make it ever harder for the
malware to recognize it is being analyzed by Cubismo. Counter-
factual execution analyzes dynamically generated code recursively
until it comprehensively covers all possible dynamically gener-
ated code. PHP malware actively leverages recursive dynamic code
generation.
InputOutput…NormalizationNormalized	Abstract	Syntax	TreeCounterfactual	ExecutionCUBISMOCode	Generator…DecloackedASTs<?phperror_reporting(0);@ini_set('error_log',NULL);@ini_set('log_errors',0);@ini_set('display_errors','Off');@eval(base64_decode('aWYobWQ1KCRfUE9TVFsicGYiXSkgPT09ICI5M2FkMD...sgfSA7fTsNCiB9DQoNCiB9'));@ini_restore('error_log');@ini_restore('display_errors'); ...12(a)	Original	Program<?phperror_reporting(0); @ini_set('error_log',NULL); @ini_set('log_errors',0); @ini_set('display_errors','Off'); @eval(base64_decode('aWYobWQ1KCRfUE9TVFsicGYiXSkgPT09ICI5M2FkMD...sgfSA7fTsNCiB9DQoNCiB9')); @ini_restore('error_log');@ini_restore('display_errors'); ...123456789(b)	Normalized	ProgramNormalization<?phpnamespaceA {classClassA{functionfuncA() { ... } }}namespace{$a= new\A\ClassA();...}// Comment to break parser12345678910111213(a)	Original	Program(PHP-Parser	Crash)<?phpnamespaceA {classClassA{functionfuncA() { ... } }}namespace{$a= new\A\ClassA();...}12345678910111213(b)	Normalized	Program(No	Crash)Normalizationif(!isset($_GET[1]))die(“Invalid Access”);if($_GET[1]==$password) {decode_malicious();if(ip2long($_SERVER[...]) <=$IP)    copy_the_malware();} else do_benign();...123456789(a) Source code(b) Traces from Dynamic Analysis and Counterfactual Exec.  (Numbers in traces are line numbers and an arrow means a creation of a new isolated execution state)12Dyn.12Counterfactual Execution1238…12345…123456……ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
A. Naderi et al.
Figure 7: Decloaking Process Example
Running Example. Consider the code in Fig. 6-(a). Line 1 checks
if an input is provided to the script. When no input is available,
line 2 exits the script (die() is the exit expression in PHP). Line
3 checks if the provided input is the expected password. If not, it
executes benign statements on line 8 and exits. If the password is
provided correctly, it decodes and executes malicious code (e.g.,
sending spam mails) on line 4. Then, it checks the range of client’s
IP address. If it is lower than a certain IP (e.g., $IP on line 5), it
copies the malware which is another malicious activity (controlled
spreading of the malware).
A naive dynamic analysis is unable to expose the malicious
behavior as it is not able to drive execution past lines 2 and 3 (Dyn.
in Fig. 6-(b)), missing the entire malicious logic.
5.3 Code Generator
For each decloaked AST, we generate a program file by travers-
ing the tree. The generated program is different from the original
program in two ways. First, it is based on the normalized AST from
the first phase. The generated file may have different syntactic fea-
tures such as indentations, whitespaces and line count. Second, it
contains the decloaked version of obfuscated code in the original
file, i.e., the respective parts of the AST that deobfuscate and ex-
ecute dynamic code are replaced by the actual executed dynamic
code.
Decloaking Process Example. Fig. 7 shows how Cubismo re-
veals malicious code in malware. First, Cubismo first normalizes
the original input program and obtains its AST. Then, Cubismo
uses the counterfactual execution to expose malicious code pieces.
Specifically, whenever Cubismo executes dynamic constructs (e.g.,
Decoder 1 ( A ) in Fig. 7-(a)) that are used for deobfuscation, it
replaces the resulting deobfuscated code ( B and C ) with the orig-
inal (obfuscated) code as depicted in Fig. 7-(b). Malware may also
include multiple layers of obfuscations. For instance, Fig. 7-(b)’s
deobfuscated code includes another piece of nested obfuscated code
(Obfuscated Code 2) and its decoder (Decoder 2) ( C ).
Cubismo repeatedly executes dynamic constructs (i.e., deobfusca-
tor) until it does not observe any new resolvable dynamic construct.
For instance, it executes the decoder 2 ( C ) to get the deobfuscated
code 2 in Fig. 7-(c) and stops there as there is no more decoders
that can expand code. Note that even if there is the decoder 1, exe-
cuting it does not lead to newly observable code. Cubismo stops
its exploration when arguments of dynamic constructs are attacker
controlled inputs (e.g., eval($_GET[$var])). As a program con-
taining dynamic constructs with inputs from untrusted sources (e.g.,
other websites) is generally considered malicious (e.g., web shell
malware), Cubismo intentionally leaves such dynamic execution
code intact so that detectors can use them to detect malware. For
example, a malware detector that is aware of Decoder 2 (i.e., having
a signature of Decoder 2) can detect the program after the first
obfuscation layer (annotated with 1 ) while it cannot detect the
program after the second obfuscation layers (Fig. 7-(c)) as Decoder
2 is removed after its execution (annotated with 2 ).
A malicious program may also alter itself in order to hinder
analysis tools. For instance, after the deobfuscation in Fig. 7-(b),
Decoder 2 is removed ( 2 ) and is not a part of the program any more
in Fig. 7-(c) ( D ). In PHP, alternation can be done by using the built-
in tokenizer and code inspection and modification functions, which
can remove an existing function in the current program. Because
of these self-modifying behaviors, the last deobfuscated file does
not always contain all malicious code snippets. It is also noteworthy
that the obfuscations can be nested, and by unwrapping one layer
of obfuscation, Cubismo can observe a new obfuscation in the
generated code. There can be an arbitrary number of obfuscation
layers.
6 EVALUATION
We evaluated Cubismo in order to answer the following research
questions.
RQ 1. How effective is Cubismo in revealing malware disguised
behind multiple layers of obfuscation? (§ 6.1)
RQ 2. Does Cubismo cause false positives on benign files? (§ 6.2)
RQ 3. What is the performance overhead? (§ 6.3)
RQ 4. How effective is Cubismo in handling real-world malware?
(§ 6.4)
Experiment Setup. All experiments are run on an iMac 27" 2017
base model, running macOS 10.14.1 and PHP version 7.2. Samples
were submitted to VirusTotal (VT) [1] via its API. Submissions are
done in parallel and submitted samples are processed within a small
Code	(Not	obfuscated)Obfuscated	Code	1Code	(Not	obfuscated)DeobfuscatedCode	1Obfuscated	Code	2Code	(Not	obfuscated)DeobfuscatedCode	1DeobfuscatedCode	2(a)Original	FileOne	decoder	is	observed(b)	DeobfuscatedFile	(First	Layer)Two	decoders	are	observed(c)	DeobfuscatedFile	(Second	Layer)One	decoder	is	observedDecoder	1Decoder	2Decoder	1Decoder	1DeobfuscationABCDDeobfuscationAnti-virus	tools	do	not	recognize	this	malwareAnti-virus	tools	do	not	recognize	this	malwareAnti-virus	tools	flag	this	as	malware	by	recognizing	Decoder	2Signature	of	Decoder	2Removal	of	Decoder	212Cubismo: Decloaking Server-side Malware via Cubist Program Analysis
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
time window (i.e., in a few minutes), reducing the side effects of
our submission to the VT. As for each malware, the submissions
are analyzed within a few minutes, we did not observe anti-virus
engines in VT changing their behaviors because of our submissions
(i.e., learn new malware samples because of our submission). From
our experience, such learning behaviors happens a few days (e.g., 3-
5 days) after the first submission. For example, many VT anti-virus
engines were able to detect malware samples a few days after our
submissions that they were not able to detect initially, .
Dataset Selection. To evaluate the effectiveness of Cubismo in
practice, we leverage a large data set of real-world websites de-
ployed in the wild obtained from a web hosting company, that
maintains nightly backups of over 400,000 websites [2]. For each
backup, Linux Malware Detector [47] is used to scan every file in
the backup. Any website included in our dataset had at least one file
flagged as malware. Hence, the dataset includes both benign and
malicious PHP files, some of which are flagged by Linux Malware
Detector. The total size of the dataset is 1TB including more than 3
million files. We filtered non-program files which are not the focus
of this work, by parsing every file in the dataset and looking for
PHP code in the parse tree, resulting in approximately 700k files.
From the 700k files, we selected files including dynamic code exe-
cution constructs (such as eval(), create_function(), include(),
etc.), totaling 1,269 files with dynamic constructs. Note that this
selection was static. We selected files that had dynamic code gen-
eration and execution constructs in their parse tree. We realized
that a static filtering may not precisely identify all files containing
dynamic features. However, we did this filtering to obtain a reason-
able data set that includes PHP malware, and it was not meant to
be exhaustive.
From the 1,269 files, we removed duplicate files, resulting in
1,040 unique files. These files were then all submitted to VT to get
a baseline for detection. All but 352 (i.e., 688) files were detected by
VT as previously known malware.
From the undetected 352 files, we manually inspected all files to
obtain 56 malicious files. The 56 unique malicious files are zero-day
PHP malware that are not detected by VT, and are the basis of this
evaluation. We also manually selected 100 benign files from the
remaining files for false positive evaluations (§ 6.2).
6.1 Decloaking Real-world Malware
By processing the 56 malware samples through Cubismo, we
obtained 200 decloaked sample files that can be scanned by malware
detection tools. We used VirusTotal (VT) as our malware detection
oracle in this work, even though there are some other PHP mal-
ware detection tools [20, 43, 47]. VirusTotal is an aggregate virus
scanning engine that scans submitted files with up to 60 different
anti-virus engines, and aggregates the detection results.
The 200 files consisted of 56 original malware samples (which
were undetected by VT), 56 normalized versions of the same mal-
ware samples, and 1 to 4 additional decloaked files per malware
sample (depending on how many layers of obfuscation could be
decloaked). All of these files were submitted to VT for scanning,
and Table 2 shows the results. Each cell in the table shows how
many engines in VT detected a particular file as malicious. Note
that there are malware samples employing multiple obfuscation
layers (namely m2, m34, m40, m45) to hide malicious behavior.
Observations. First, normalization is necessary in detecting real-
world malware samples that actively exploit ill-formatted code
snippets. Specifically, several malware samples (namely m1, m10,
m14, m19, m33, m36, m38, m42 and m53) are detected after normal-
ization, even before decloaking. Our further investigations revealed
that this is due to the fact that normalization fixes several dubious
syntax issues present in the original malware.
Second, scanning each deobfuscated layer is necessary for accu-
rate detection. Specifically, in some malware samples such as m21,
we saw that decloaking the last obfuscation layer enables several
more engines to detect maliciousness, jumping from 1 detection
at first decloaking layer to 5 in the second layer. In other samples
such as m34, we observed that the third decloaking layer results
in no more engines discovering the maliciousness. This result is
because the engines that detect malicious behavior on first and
second decloaking layers have signatures for detecting obfuscation,
which are removed from the code gradually. However, on the last
(fourth) deobfuscation, a new engine recognizes the (now revealed)
maliciousness. The same pattern can be observed on m40 where
detection goes from 3 to 1, and then back to 3. Complementary
to this behavior, samples such as m11, m14 and m33 go from 3 de-
tections on the first deobfuscation layer to 1 on the second layer.
These patterns establish that no particular layer is always the most
suitable for detection, and best result is achieved by scanning results
of all decloaking layers.
Third, there are 3 samples that are not flagged as malware even
after the decloaking: m17, m27 and m50. These samples are true
zero-days, i.e., no signature exists for them, and thus even after
decloaking, the malicious behavior is not detected.
6.2 Cubismo on Benign Applications
To evaluate whether Cubismo introduces false positives in de-
tection, as previously noted, we manually selected 100 benign PHP
files from our dataset that included dynamic code generation and
execution. Additionally, we randomly selected 200 files from Word-
press to evaluate whether Cubismo causes false positives in benign
applications. These samples were decloaked using Cubismo and
submitted to VT, along with their normalized and original versions.
None of these samples and their different versions were flagged
as malicious by VT (i.e., no false positives). Note that, for benign
applications, Cubismo simply unfolds the dynamic constructs if
possible, without changing any semantics. In benign applications,
dynamically generated code should also be benign (e.g., they should
not form webshells). Hence, we argue that doing so is unlikely to
cause false positives (FP). Even if it does cause false positives, it
means that malware detectors contain wrong signatures.
6.3 Performance
The execution times on Table 3 show that counterfactual execu-
tion typically takes around 20 milliseconds (ms) per sample. Some
samples need up to 740 ms to completely decloak themselves. The
average execution time is 52 ms. Scan times vary among different
underlying scan engines. Antivirus engines typically take 10 to 120
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
A. Naderi et al.
Table 2: Results of Scanning Decloaked Malware Samples with VirusTotal
Orig. Norm. Layer 1 Layer 2 Layer 3 Layer 4
Orig. Norm. Layer 1 Layer 2 Layer 3 Layer 4
m1
m2
m3
m4
m5
m6
m7
m8
m9
m10
m11
m12
m13
m14
m15
m16
m17
m18
m19
m20
m21
m22
m23
m24
m25
m26
m27
m28
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
1
0
0
0
0
0
0
0
0
0
2
1
1
1
1
1
1
1
1
1
3
1
1
3
1
1
0
1
1
1
1