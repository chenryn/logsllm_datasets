able CFI property for such binaries, we introduce a cat-
egory of ICF transfer in addition to RET, IC and IJ de-
scribed earlier. This category, called PLT, includes all
ICF transfers in the program linkage table, a section of
code used in dynamic linking5.
We are now ready to deﬁne bin-CFI as shown in Fig-
ure 2.
4Speciﬁcally, a tail call optimization that replaces a call occurring
5Speciﬁcally, for each function belonging to another module, a stub
at the very end of a function with a jump.
routine is created by the compiler in this section.
342  22nd USENIX Security Symposium 
USENIX Association
6
Returns (RET),
PLT targets,
Indirect
Jumps (IJ)
Indirect
Calls (IC)
Return addresses (RA)
Exception handling
addresses (EH)
Exported symbol
addresses (ES)
Code pointer
constants (CK)
Computed code
addresses (CC)
Y
Y
Y
Y
Y
Y
Y
Figure 2: Bin-CFI Property Deﬁnition
It is easy to see that strict-CFI is stricter than bin-
CFI. The reasons for relaxing strict-CFI are as follows.
In general,
there is no easy way to distinguish be-
tween returns used for purposes such as stack unwind-
ing, longjmp, thread context switch, and function dis-
patch from (the more common) use of returning from
functions. We therefore permit returns to go to any of
the valid targets corresponding to each of these uses. Re-
turns are some times broken up into a pop and jump, so
all possible targets of RET are permissible targets of IJ.
This explains the ﬁrst column of the table.
Since the purpose of PLT stubs is to dispatch cross-
module calls, it would seem that the targets can only
be exported symbols from other modules. However, re-
cent versions of gcc support a new function type called
gnu indirect function, which allows a function to have
many different implementations, with the most suitable
one selected at runtime based on factors such as the CPU
type. Currently, many glibc low level functions such as
memcpy, strcmp and strlen use this feature. To support
this feature, a library exports a chooser function that se-
lects at runtime which of the many implementations is
going to be used. These implementation functions may
not be exported at all. To avoid breaking such programs,
the policy for PLT should be relaxed to include code
pointers in the target library. This is what we have done
on the second column of Figure 2.
Indirect calls should go to the targets in one of the sets
CC or CK. Since these two sets are usually much larger
than ES, we chose to merge IC and PLT to use the same
table of valid targets.
Implementation
5
Although our design is largely applicable to most archi-
tectures, our implementation targets 32-bit x86 proces-
sors running Linux. For this reason, some implementa-
tion aspects discussed below are speciﬁc to this platform.
5.1 Disassembly
Binaries on Linux (and most other UNIX systems) use
the ELF (Executable and Linkable Format) [25] for-
mat. We support binaries that represent executables and
shared libraries. The ELF format divides a binary into
several sections, each of which may contain code, read-
only data, initialized data, and so on. While our approach
utilizes the data in read-only data sections, it is mainly
concerned with the code sections.
Our implementation utilizes objdump to perform lin-
ear disassembly. We have built our disassembly error
detection and correction components on top of objdump.
In our experience, disassembly errors occurred primarily
due to insertion of null padding generated by legacy code
or linker script. In addition, we discovered jump table
data in the middle of code in libffi.so and libxul.so
There were also several instances where conditional
jumps targeted the middle of an instruction. Further anal-
ysis revealed that these errors occurred with instructions
that had optional preﬁxes, such as the “lock” preﬁx. We
eliminated this error by treating these preﬁxes as inde-
pendent instructions, so that jumps could target the in-
struction with or without the preﬁx.
Instrumentation and Regeneration of Binary
5.2
After disassembly, the resulting code is instrumented to
enforce CFI. The speciﬁcs of this instrumentation are de-
scribed in Section 5.3. Below we describe the genera-
tion of a binary from instrumented code, since a general
understanding of this process will enable a fuller under-
standing of the instrumentation steps.
Instrumentation is performed on assembly representa-
tion. This simpliﬁes our implementation since it does
not need to be concerned with details such as encoding
and decoding of instructions. Moreover, it can use labels
instead of addresses. In particular, for each instruction
location A in the disassembler output of objdump, we
associate a symbolic label L_A as follows:
L_8040930:movl %ecx, %eax
These symbolic labels are used as targets of direct branch
instructions, which means that the assembler will take
care of ﬁxing up the branch offsets. (These offsets will
typically change since we are inserting additional code
during instrumentation.)
After rewriting, the instrumented assembly ﬁle is pro-
cessed using the system assembler (in our case, the GNU
assembler gas) to produce an object ﬁle. We extract the
code from this object ﬁle and then use the objcopy tool to
inject it into the original ELF ﬁle. Note that the original
code sections are not overwritten. This ensures that any
attempt by the instrumented program to read its own code
will produce the same results as the original program.
USENIX Association  
22nd USENIX Security Symposium  343
7
The ﬁnal step prepares the ELF ﬁle produced by ob-
jcopy for execution. This step requires relocation ac-
tions on the newly added segment, and updating the ELF
header to set its entry point to the segment containing in-
strumented code. The original code segments are made
unexecutable. For shared libraries, it is also necessary to
update the dynamic symbol sections.
5.3 Instrumentation for CFI
As described above, instrumented code resides in a dif-
ferent code segment (and hence a different memory lo-
cation) from the original code. This means that function
pointer values, which will typically appear in the code
as constants, will have incorrect values. Unfortunately,
it is not possible to ﬁx them up automatically, since we
cannot distinguish constants representing code addresses
from other types of constants. It would obviously be un-
sound to modify a constant value that does not represent
a code pointer6.
The typical way to deal with this uncertainty, em-
ployed in dynamic binary translation (DBT) [8], is to
wait until a value is used as the target of an ICF transfer.
At that point, this target value is translated into the corre-
sponding location in the instrumented code. This trans-
lation is performed using a table that consists of pairs of
the form
(cid:31)original address, new address(cid:30)
At runtime, addr trans, a piece of trampoline code, per-
forms address translation.
(In fact, there are two such
trampolines, one corresponding to each column of Fig-
ure 2.) Instrumentation is inserted at the site of the origi-
nal indirect control-ﬂow transfer instruction as shown in
Figure 3.
060c0:
call *%ecx
L_060c0: push $060c2
060c2:
......
movl %eax, %gs:0x44
movl %ecx, %eax
jmp addr_trans
L_060c2: ......
Figure 3: Original (left) and Instrumented code (right)
for ICF transfer
This code saves the register (eax) used by the instrumen-
tation, and moves the target address into it.7 Then the
original indirect jump (or call) is replaced with a direct
jump to the trampoline routine, addr trans. Note the use
of labels such as L_060c0 that are used to associate lo-
cations in the instrumented code with the corresponding
6Here again, relocation information can address this uncertainty, but
in our case, this is unavailable.
7Note that %gs points to the base of thread-local storage, and
%gs:0x44 is not used by existing system software.
original address, namely, 060c0. As a result, the transla-
tion table can consist of entries of the form
(cid:31)A, L A(cid:30)
for each valid ICF target A. As noted earlier, there are
two address translation routines, one corresponding to
each column of Figure 2. The valid ICF targets for each
table consists of the subset of ICF targets computed by
the static analysis described in Section 3 that appear in
the corresponding column of Figure 2.
The details of addr trans are as follows: After saving
registers and ﬂags needed for its operation, addr trans
performs an address range check to determine if the tar-
get is within the current module. If not, this represents
a cross-module control transfer that is described later in
this section. After the range check, addr trans performs
address translation. Our implementation relies on closed
hashing [44] to perform an efﬁcient lookup of the table
described above. Rather than storing just the target ad-
dress L A in the table, our implementation stores code
that transfers control to L A. For instance, the hash table
entry to translate a code address 0x060c2 looks as fol-
lows.
0x060c2
movl %gs:0x44, %eax; jmp L 060c2
If no translation is found for
the target address,
addr_trans will set an error code to help in debugging,
and terminate the program.
Note that, for shared libraries, translation table only
contains the offsets rather than absolute addresses. Con-
sequently, the base address of the module needs to be
subtracted from the runtime address given to the transla-
tion routine. We rely on the dynamic linker to patch the
routine with the module’s base address when the module
is loaded.
In order to preserve the functionality of original code,
it is necessary to ensure that the instrumentation does not
modify any of the registers or memory used by the pro-
gram. It is relatively easy to avoid changes to memory, or
registers other than the program counter (PC). Since in-
strumentation changes code locations (as described ear-
lier), it is not possible to preserve the PC register. So,
what we need to do is to add a compensation for any op-
eration that uses the PC for any purpose other than fetch-
ing the next instruction. Fortunately, on x86, there are
only two instructions that use PC this way: call and re-
turn. A call X is translated into a push next; jmp X,
where next denotes the address of the instruction fol-
lowing call in the original program. Similarly, a return
is translated into a pop followed by a direct jump. Note
that after this transformation, none of the instructions in
the original program involve movement of data between
PC and other registers or memory8, thus ensuring that
8 In x86-64 architecture, any PC-relative data addressing needs to
344  22nd USENIX Security Symposium 
USENIX Association
8
program behavior is unaffected by our instrumentation.
Modularity. Support for shared libraries is achieved as
follows. Our technique rewrites a single module (an ex-
ecutable or a shared library) at a time. There is exactly
one version of a transformed shared library, regardless of
the context (or the executable) in which it is used. Note
that we transform all shared libraries, including glibc
and ld.so.
As described before, addr_trans already handles
intra-module control transfers.
Inter-module transfers
rely on a two-stage process. In the ﬁrst stage, a global
translation table (GTT) is used to map an ICF target to
the translation routine address in the target module. This
table is constructed as follows. Since shared libraries
must begin at page boundaries, any two modules have
to be apart by at least 4KB, the page size on 32-bit Linux
systems. Thus, it is enough to use the leading 20 bits of
the ICF target in this lookup table. We use a simple array
implementation for GTT since there are only 220 = 1M
entries in this table. This array is made read-only in or-
der to protect it. The second stage performs a lookup in
the destination module, using the address translation ta-
ble for that module. We use the term module translation
table (MTT) for the translation table that speciﬁes trans-
lations for addresses within the module.
Changes to the Loader. Note that the GTT needs to be
updated as and when modules are loaded. Naturally, the
best place to do this is the dynamic linker. We modiﬁed
the source code of ld.so to accomplish this. Our change
uniformly handles the typical case of the loader mapping
all of shared libraries referenced by an executable (or an-
other shared library loaded by the loader), as well as the
less common case of an application using dlopen and
dlclose primitives to load and unload libraries at run-
time. Our changes relate to about 300 lines of the source
code of ld.so.
Our loader modiﬁcation also addressed two other id-
iosyncrasies of ld.so. First, note that our approach mod-
iﬁes the entry point of a binary. Thus, any program that
uses the entry point for purposes other than jumping to it
may not work any more. As it turns out, ld.so does make
use of this information when it is invoked to load a pro-
gram, as in ld.so . We changed the loader so
that it compensates for the change in the entry point, and
hence works correctly in all cases.
The second idiosyncrasy concerns the use of return
instructions for lazy symbol resolving. Lazy symbol
resolving is implemented by the dl runtime resolve
function (or dl runtime profile if proﬁling is enabled)
in ld.so. This function computes the target address cor-
responding to the symbol, pushes this address on the
top of stack, and returns. For this to work correctly, re-
be translated too. This can be done easily by modifying the offset value.
060b1: call 060c0
L_060b1: call S_060b1
.....
.....
S_060b1: add $offset, (%esp)
jmp L_060c0
Figure 4: Optimized instrumentation of calls
turns should be permitted to target exported symbols, fur-
ther decreasing the accuracy of our CFI implementation.
Instead, we chose to modify the loader to use indirect
jumps instead of returns, and restricted the target of these
jumps with the policy shown in Figure 2 for PLT entries.
Signals. Signal is another mechanism to redirect pro-
gram control ﬂow. If a program registers its signal han-
dlers, once again we will have the problem that the pro-
gram will specify the location of the handler in original
code, whereas we want the signal to be delivered to the
instrumented code. (This problem arises because signals
are delivered by the kernel, which is not aware of the ad-
dress translations used to correctly handle code pointers.)
Our implementation intercepts sigaction and signal