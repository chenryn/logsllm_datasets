### 逆向分析德国Enigma密码机以解密电报

#### 背景
1940年9月6日，英国情报部门军情六处截获了一封重要的德国电报。为了帮助军情六处解密这封电报，我们需要逆向分析德国使用的密码机Enigma。请将最终得到的flag以MD5格式提交。

#### 主要函数
- **main函数**：读取`inp`文件中的内容进行加密，并将结果输出到`enc`文件中。题目直接给出了`enc`文件，要求我们求出`inp`文件的内容。关键的加密内容位于`loc_4018F0`。
- **加密函数**：IDA无法正常识别这段代码，其中`0xC7 0xFF`开头的代码是无法执行的。程序通过调用`SetUnhandledExceptionFilter`来设置异常接管函数，处理异常时提取附近信息并将后几个字节作为参数处理。例如，这里的`4`会进入switch语句并调用case 4分支，并传入参数`1`和`0`。

#### 加密逻辑
- 通过类似opcode和异常处理机制，实现了虚拟机的效果。由于不会使用IDC脚本，只能通过反汇编引擎逐个读取指令，遇到错误内容时将其视为opcode处理，最后手动还原所有汇编代码。

#### 反汇编工具
- 使用OD（OllyDbg）内部反汇编引擎，该引擎已开源并在GitHub上提供。修改后的代码可以在VS上调用，具体实现见[GitHub地址](https://github.com/your-repo)。

#### opcode还原代码
```c
// Free Disassembler and Assembler -- Demo program
//
// Copyright (C) 2001 Oleh Yuschuk
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

/*
* int Assemble(char *cmd, ulong ip, t_asmmodel *model, int attempt, int constsize, char *errtext) - 将文本命令汇编为二进制代码
* int Checkcondition(int code, ulong flags) - 检查命令中是否满足条件
* int Decodeaddress(ulong addr, ulong base, int addrmode, char *symb, int nsymb, char *comment) - 用户提供的函数，将地址解码为符号名称
* ulong Disasm(char *src, ulong srcsize, ulong srcip, t_disasm *disasm, int disasmmode) - 确定二进制命令的长度或将其反汇编到文本中
* ulong Disassembleback(char *block, ulong base, ulong size, ulong ip, int n) - 向后走二进制代码
* ulong Disassembleforward(char *block, ulong base, ulong size, ulong ip, int n) - 向前走二进制代码
* int Isfilling(ulong addr, char *data, ulong size, ulong align) - 确定命令是否等于NOP
* int Print3dnow(char *s, char *f) - 转换3DNow！常量为文本而不触发无效操作数的FPU异常
* int Printfloat10(char *s, long double ext) - 将10字节浮点常量转换为文本而不会导致异常
* int Printfloat4(char *s, float f) - 将4字节浮点常量转换为文本而不会导致异常
* int Printfloat8(char *s, double d) - 将8字节浮点常量转换为文本而不会导致异常
*/

#define STRICT
#define MAINPROG                       // Place all unique variables here
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdarg.h>
#pragma hdrstop
#include "disasm.h"

unsigned char opcode[] = {
    0x55, 0x8B, 0xEC, 0x53, 0x56, 0x57, 0x68, 0x30, 0x16, 0xAF,
    0x00, 0xFF, 0x15, 0x00, 0x20, 0xB3, 0x00, 0xC7, 0xFF, 0x04,
    0x01, 0x00, 0x33, 0xC9, 0x83, 0xF9, 0x20, 0x7D, 0x17, 0xC7,
    0xFF, 0x00, 0x01, 0x11, 0xC7, 0xFF, 0x04, 0x01, 0x1F, 0x89,
    0x04, 0x8D, 0x70, 0x7A, 0xB4, 0x00, 0xC7, 0xFF, 0x02, 0x03,
    0xEB, 0xE4, 0x33, 0xC9, 0x83, 0xF9, 0x20, 0x7D, 0x2D, 0x8B,
    0x1C, 0x8D, 0x70, 0x7A, 0xB4, 0x00, 0x8B, 0x14, 0x8D, 0x74,
    0x7A, 0xB4, 0x00, 0x8A, 0x82, 0x4C, 0x7A, 0xB4, 0x00, 0x88,
    0x83, 0xE0, 0x79, 0xB4, 0x00, 0x8A, 0x83, 0x4C, 0x7A, 0xB4,
    0x00, 0x88, 0x82, 0xE0, 0x79, 0xB4, 0x00, 0xC7, 0xFF, 0x00,
    0x03, 0x02, 0xEB, 0xCE, 0x33, 0xC9, 0x83, 0xF9, 0x20, 0x7D,
    0x35, 0x8A, 0x99, 0xE0, 0x79, 0xB4, 0x00, 0xC7, 0xFF, 0x04,
    0x02, 0x1F, 0xC7, 0xFF, 0x07, 0x02, 0x03, 0x8B, 0xF1, 0x46,
    0x83, 0xE6, 0x1F, 0x8A, 0x96, 0xE0, 0x79, 0xB4, 0x00, 0x80,
    0xE2, 0xE0, 0x81, 0xE2, 0xFF, 0x00, 0x00, 0x00, 0xC7, 0xFF,
    0x08, 0x04, 0x05, 0x0A, 0xDA, 0x88, 0x99, 0x04, 0x7A, 0xB4,
    0x00, 0x41, 0xEB, 0xC6, 0xA0, 0x04, 0x7A, 0xB4, 0x00, 0xA2,
    0x28, 0x7A, 0xB4, 0x00, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x83,
    0xF9, 0x20, 0x7D, 0x28, 0x8A, 0x99, 0x04, 0x7A, 0xB4, 0x00,
    0x8B, 0xF1, 0xC7, 0xFF, 0x03, 0x05, 0x32, 0x9E, 0x04, 0x7A,
    0xB4, 0x00, 0x8B, 0xF1, 0xC7, 0xFF, 0x04, 0x05, 0x03, 0x32,
    0x9E, 0xF0, 0x68, 0xB4, 0x00, 0x88, 0x99, 0x28, 0x7A, 0xB4,
    0x00, 0x41, 0xEB, 0xD3, 0x5F, 0x5E, 0x5B, 0x5D, 0xC3
};
```

#### 总结
- 通过分析和逆向工程，我们可以逐步还原出加密算法的具体实现。
- 利用反汇编工具和手动分析，可以将opcode还原为可读的汇编代码。
- 最终，我们将能够解密电报并提交MD5格式的flag。

希望各位师傅能给我点个Star，嘿嘿~ 😊