[31] A. Fog. The microarchitecture of Intel, AMD and VIA
https : / / www . agner . org / optimize /
CPUs.
microarchitecture.pdf. Accessed: January 2020.
[32] S. Weiser, A. Zankl, R. Spreitzer, K. Miller, S. Mangard,
and G. Sigl. “DATA – Differential Address Trace Analysis:
Finding Address-based Side-Channels in Binaries”. 27th
USENIX Security Symposium (USENIX Security ’18).
J. Wichelmann, A. Moghimi, T. Eisenbarth, and B. Sunar.
“MicroWalk: A Framework for Finding Side Channels in
Binaries”. Proceedings of the 34th Annual Computer Security
Applications Conference (ACSAC ’18).
[33]
[34] C. D. Walter and S. Thompson. “Distinguishing Exponent
Digits by Observing Modular Subtractions”. Topics in Cryp-
tology — CT-RSA 2001.
[35] A. Cabrera Aldaya and B. B. Brumley. “When one vulnerable
primitive turns viral: Novel single-trace attacks on ECDSA
and RSA”. IACR Transactions on Cryptographic Hardware
and Embedded Systems (2020).
[36] O. Acıiçmez, S. Gueron, and J.-P. Seifert. “New Branch Pre-
diction Vulnerabilities in OpenSSL and Necessary Software
Countermeasures”. Cryptography and Coding 2007.
[37] A. Cabrera Aldaya, A. J. C. Sarmiento, and S. Sánchez-Solano.
“SPA vulnerabilities of the binary extended Euclidean algo-
rithm”. Journal of Cryptographic Engineering (2017).
[38] B. Krzanich. Advancing Security at the Silicon Level. https:
/ / newsroom . intel . com / editorials / advancing -
security-silicon-level/#gs.yh984y. Accessed March
2020.
[39] B. Solomon, A. Mendelson, R. Ronen, D. Orenstien, and Y.
Almog. “Micro-operation cache: A power aware frontend for
variable instruction length ISA”. IEEE Transactions on Very
Large Scale Integration (VLSI) Systems (2003).
[40] A. Rane, C. Lin, and M. Tiwari. “Raccoon: Closing Digital
Side-Channels through Obfuscated Execution”. 24th USENIX
Security Symposium (USENIX Security ’15).
[41] M. Hähnel, W. Cui, and M. Peinado. “High-Resolution Side
Channels for Untrusted Operating Systems”. 2017 USENIX
Annual Technical Conference (USENIX ATC ’17).
[42] B. Gras, K. Razavi, H. Bos, and C. Giuffrida. “Translation
Leak-aside Buffer: Defeating Cache Side-channel Protec-
tions with TLB Attacks”. 27th USENIX Security Symposium
(USENIX Security ’18).
[43] Y. Yarom, D. Genkin, and N. Heninger. “CacheBleed: a
timing attack on OpenSSL constant-time RSA”. Journal of
Cryptographic Engineering (2017).
[44] A. Moghimi, J. Wichelmann, T. Eisenbarth, and B. Sunar.
“MemJam: A False Dependency Attack Against Constant-
International Journal of
Time Crypto Implementations”.
Parallel Programming (2019).
[45] A. C. Aldaya, B. B. Brumley, S. ul Hassan, C. Pereida García,
and N. Tuveri. “Port Contention for Fun and Proﬁt”. 2019
IEEE Symposium on Security and Privacy.
[47]
[46] D. Skarlatos, M. Yan, B. Gopireddy, R. Sprabery, J. Torrellas,
and C. W. Fletcher. “MicroScope: Enabling Microarchitec-
tural Replay Attacks”. Proceedings of the 46th International
Symposium on Computer Architecture (ISCA ’19).
J. Gyselinck, J. Van Bulck, F. Piessens, and R. Strackx. “Off-
Limits: Abusing Legacy x86 Memory Segmentation to Spy
on Enclaved Execution”. Engineering Secure Software and
Systems (2018).
S. Shinde, Z. L. Chua, V. Narayanan, and P. Saxena. “Prevent-
ing Page Faults from Telling Your Secrets”. Proceedings of
the 11th ACM on Asia Conference on Computer and Commu-
nications Security (ASIA CCS ’16).
J. Seo, B. Lee, S. Kim, M.-W. Shih, I. Shin, D. Han, and T.
Kim. “SGX-Shield: Enabling Address Space Layout Ran-
domization for SGX Programs”. Proceedings 2017 Network
and Distributed System Security Symposium (NDSS ’17).
[48]
[49]
[50] D. Gruss, M. Lipp, M. Schwarz, R. Fellner, C. Maurice, and
S. Mangard. “KASLR is Dead: Long Live KASLR”. Engi-
neering Secure Software and Systems (2017).
[51] Q. Ge, Y. Yarom, D. Cock, and G. Heiser. “A survey of mi-
croarchitectural timing attacks and countermeasures on con-
temporary hardware”. Journal of Cryptographic Engineering
(2018).
[52] C. Disselkoen, D. Kohlbrenner, L. Porter, and D. Tullsen.
“Prime+Abort: A Timer-Free High-Precision L3 Cache At-
tack using Intel TSX”. 26th USENIX Security Symposium
(USENIX Security ’17).
[53] R. Guanciale, H. Nemati, C. Baumann, and M. Dam. “Cache
Storage Channels: Alias-Driven Attacks and Veriﬁed Counter-
measures”. 2016 IEEE Symposium on Security and Privacy.
[54] O. Acıiçmez. “Yet Another MicroArchitectural Attack: Ex-
ploiting I-Cache”. Proceedings of the 2007 ACM Workshop
on Computer Security Architecture (CSAW ’07).
[55] D. A. Osvik, A. Shamir, and E. Tromer. “Cache Attacks and
Countermeasures: The Case of AES”. Topics in Cryptology –
CT-RSA 2006.
[56] O. Acıiçmez and W. Schindler. “A Vulnerability in RSA
Implementations Due to Instruction Cache Analysis and Its
Demonstration on OpenSSL”. Topics in Cryptology – CT-RSA
2008.
678    30th USENIX Security Symposium
USENIX Association
[57] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. “Cross-
VM Side Channels and Their Use to Extract Private Keys”.
Proceedings of the 2012 ACM Conference on Computer and
Communications Security (CCS ’12).
[58] E. Tromer, D. A. Osvik, and A. Shamir. “Efﬁcient Cache At-
tacks on AES, and Countermeasures”. Journal of Cryptology
(2010).
[59] Y. Yarom and K. Falkner. “FLUSH+RELOAD: A High Res-
olution, Low Noise, L3 Cache Side-Channel Attack”. 23rd
USENIX Security Symposium (USENIX Security ’14).
[60] D. Gruss, C. Maurice, K. Wagner, and S. Mangard.
“Flush+Flush: A Fast and Stealthy Cache Attack”. Detec-
tion of Intrusions and Malware, and Vulnerability Assessment
(DIMVA ’16).
[61] M. Schwarz, S. Weiser, D. Gruss, C. Maurice, and S. Man-
gard. “Malware Guard Extension: Using SGX to Conceal
Cache Attacks”. Detection of Intrusions and Malware, and
Vulnerability Assessment (DIMVA ’17).
P. C. Kocher. “Timing Attacks on Implementations of Difﬁe-
Hellman, RSA, DSS, and Other Systems”. Advances in Cryp-
tology — CRYPTO ’96.
[62]
[63] C. Percival. Cache missing for fun and proﬁt. http://css.
csail.mit.edu/6.858/2014/readings/ht-cache.pdf.
2005.
[64] C. Liu, A. Harris, M. Maas, M. Hicks, M. Tiwari, and E.
Shi. “GhostRider: A Hardware-Software System for Memory
Trace Oblivious Computation”. Proceedings of the Twenti-
eth International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS
’15).
[65] D. Molnar, M. Piotrowski, D. Schultz, and D. Wagner. “The
Program Counter Security Model: Automatic Detection and
Removal of Control-Flow Side Channel Attacks”. Informa-
tion Security and Cryptology - ICISC 2005.
[66] C. Liu, M. Hicks, and E. Shi. “Memory Trace Oblivious
Program Execution”. 2013 IEEE 26th Computer Security
Foundations Symposium.
A Supplemental information
A.1 Responsible disclosure
We notiﬁed the Intel PSIRT on February 21 2020, about the
Frontal attack. We sent them a previous version of this paper
and a proof of concept for the vulnerabilities we identiﬁed.
They informed us on April 22 that their best practices [27] al-
ready suggest avoiding secret-dependent branching, and there-
fore our attack is considered out-of-scope for their SGX li-
braries. In particular, they stated that the balanced branches of
the IPP Crypto library we attack in Section 5.1 are not used for
secret-dependent operations in the SGX architectural enclaves
and hence do not pose any security implication. The vulnera-
bility shown in Listing 1 was reported to the mbedTLS team,
which promptly ﬁxed it. The vulnerability was also described
in a 2017 paper [14] and was still unknown to the developers.
A.2 Data-oblivious Execution
Resilience against side-channel attacks is often a desired secu-
rity property when implementing software. This property is
particularly important for libraries and applications that oper-
ate on secret and sensitive data on a system controlled by the
attacker. Side-channel attacks exploit secret-dependent varia-
tions of the program execution. These variations are generally
of two types: control-ﬂow dependent and data-dependent.
Control-ﬂow secret dependencies are present whenever the
control ﬂow of an application depends on conﬁdential in-
formation. Data dependencies manifest when latency or re-
sources utilized depend on the input data. For example, when
memory accesses at different addresses are performed based
on some secret. Countless attacks have exploited these types
of dependencies in the past [62, 63, 59], targeting in particular
cryptographic libraries, as extracting secret keys handled by
these libraries breaks any security guarantee built on top of
them. Data oblivious execution defends against side-channel
attacks by removing the two dependencies mentioned above.
This eliminates any variation in program execution that would
be potentially observable by the attacker. There are two ways
to obtain a data oblivious executable - ﬁrst writing it directly
in low level assembly code, second by performing an auto-
matic transformation at compile time from a higher level lan-
guage. Note that writing the code in a higher level language in
a data oblivious way, and then simply compiling it, might rein-
troduce data or control ﬂow dependencies at the binary level.
Several techniques for compiling and transforming code
from an arbitrary high level language to data oblivious code
have been proposed [40, 64, 65, 66, 26]. One of the most com-
plete constant-time transformation for SGX is Raccoon [40].
It removes any control ﬂow and most data dependencies by
transforming secret-dependent branches into a decoy and a
real path that contain similar instructions. At run time, both
paths are executed, allowing only the real one to modify mem-
ory by carefully applying the conditional move instruction
(cmov). Raccoon runs on SGX enclaves and uses SGX’s mem-
ory protections to ensure conﬁdentiality against an attacker
that can otherwise read arbitrary locations of memory.
A.3 Measurement Details
We made several changes from stock SGX-Step [29],
primarily aiming to reduce measurement noise as much as
possible. In terms of functionality, we added the possibility
to measure performance counters alongside instructions’
timings. We identiﬁed four major sources of noise: the OS,
variability in the APIC timer, unpredictability of shared
resource state, and enclave creation offset noise. We discuss
how we addressed each of these in the following paragraphs.
The OS is a source of noise as it needs to run the scheduler
on each core to decide which tasks to execute.
If the
scheduler runs in between the start of a measurement and its
USENIX Association
30th USENIX Security Symposium    679
between single-steps and the function always has the same
cache footprint. Even with this change, we observed that
instructions that cross a virtual page boundary remained
noisy. To account for this, we remove these measurements
from the trace when possible. Note that the attacker can
easily tell if an instruction crosses the page boundary as the
access bit of the new page is set by the CPU.
Finally, while validating these changes, we noticed a
source of noise across enclave creations, whose effects we
illustrate in Figure 10. The ﬁgure shows the measurement of
the movs from Figure 6 across enclave creations. As can be
seen, the distributions remain bimodal, but the position of the
modes across creations changes. However, the relative posi-
tion between the modes stays the same: the mov at alignment
0x6 is slower than that at 0xe on both runs. While we never
observed modes shifting more than 200 cycles, this shift is
still large enough such that, for instance, the distribution of
nop instructions could overlap with the distribution of multi-
plication instructions from different runs. Given this shifting
between enclave creations, we concluded that instructions’
timings are only comparable within the same enclave.
loop_start :
mov
xor
cmp
setb
sub
mov
mov
mov
cmp
adc
sub
mov
add
cmp
jne
(% rcx ,% rdx ,8) ,% rax
%r9d ,% r9d
%rsi ,% rax
% r9b
%rsi ,% rax
%rax ,(% rcx ,% rdx ,8)
(% rdi ,% rdx ,8) ,% r8
%r9 ,% rsi
%r8 ,% rax
$0x0 ,% rsi
%r8 ,% rax
%rax ,(% rcx ,% rdx ,8)
$0x1 ,% rdx
%rdx ,% rbp
loop_start
Listing 2: Exploited for loop in the mbedTLS library’s
mpi_montmul function (compiled on gcc 7.5.0 with -O3).
loop_start :
mov
sub
mov
shl
shr
or
mov
mov
cmp
jnz
(% rax ) , % rcx
$0x8 , % rax
%rcx , % rdx
$0x3f , % rcx
$0x1 , % rdx
%rdi , % rdx
%rcx , % rdi
%rdx , (% rax +8)
%rax , % rsi
loop_start
Listing 3: Exploited for loop in the mbedtls_rsa_gen_key
function of the mbedTLS library.
Figure 10: Distribution of the instructions of Figure 6 across
different runs, split by their alignments. This ﬁgure highlights
how different enclave runs exhibit a shift in the mean of
their instructions’ distribution and hence distributions are not
directly comparable between runs.
end, the measurement will inevitably be longer. Moreover,
running any OS function while we single-step can sometimes
evict part of the enclave memory from the cache, thus forcing
the enclave to fetch it again when it is resumed. This also
happens when the scheduler executes on the sibling core.
As recommended in the original SGX-Step framework, we
run the code in its own isolated core to reduce this noise.
However, this alone stops neither the scheduler nor the other
cores from interrupting the isolated core. We observed that
disabling watchdogs at boot and disabling the graphical user
interface tends to reduce the noise produced by the OS, albeit
it does not eliminate it completely.
In stock SGX-Step,
the APIC timer is set
in the
aep_cb_func. The aep_trampoline then executes and
resumes the enclave. Various conditions can create variability
between the time in which the APIC timer is set and the time
at which the enclave resumes. For instance, sometimes, the
aep_trampoline code page or some of the data it uses might
not be present in the cache. We addressed this variability by
setting the APIC timer from the aep_trampoline function
with a value passed from the aep_cb_func function and by
serializing the instruction stream (using CPUID) just before
setting the timer.
Interestingly, while debugging for this
source of noise, we observed that we were never able to
interrupt in between fused macro-instructions as these seem
to be treated atomically by the CPU, as also observed in [23].
The third source of noise stems from the difference in the
microarchitectural state in-between measurements. While
we could not completely eliminate this source of noise
as we have no direct view of the microarchitecture, we
were able to reduce it signiﬁcantly. The most effective
change in this regard was obtained by linearizing the code
of the aep_cb_func so that there is no mis-speculation in
680    30th USENIX Security Symposium
USENIX Association