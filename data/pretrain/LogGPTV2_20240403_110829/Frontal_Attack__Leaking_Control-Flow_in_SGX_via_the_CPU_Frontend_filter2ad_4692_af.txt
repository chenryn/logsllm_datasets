### References

1. A. Fog. *The Microarchitecture of Intel, AMD, and VIA CPUs*. Available at: <https://www.agner.org/optimize/CPU_microarchitecture.pdf>. Accessed: January 2020.

2. S. Weiser, A. Zankl, R. Spreitzer, K. Miller, S. Mangard, and G. Sigl. "DATA – Differential Address Trace Analysis: Finding Address-based Side-Channels in Binaries." *27th USENIX Security Symposium (USENIX Security '18)*.

3. J. Wichelmann, A. Moghimi, T. Eisenbarth, and B. Sunar. "MicroWalk: A Framework for Finding Side Channels in Binaries." *Proceedings of the 34th Annual Computer Security Applications Conference (ACSAC '18)*.

4. C. D. Walter and S. Thompson. "Distinguishing Exponent Digits by Observing Modular Subtractions." *Topics in Cryptology — CT-RSA 2001*.

5. A. Cabrera Aldaya and B. B. Brumley. "When One Vulnerable Primitive Turns Viral: Novel Single-Trace Attacks on ECDSA and RSA." *IACR Transactions on Cryptographic Hardware and Embedded Systems (2020)*.

6. O. Acıiçmez, S. Gueron, and J.-P. Seifert. "New Branch Prediction Vulnerabilities in OpenSSL and Necessary Software Countermeasures." *Cryptography and Coding 2007*.

7. A. Cabrera Aldaya, A. J. C. Sarmiento, and S. Sánchez-Solano. "SPA Vulnerabilities of the Binary Extended Euclidean Algorithm." *Journal of Cryptographic Engineering (2017)*.

8. B. Krzanich. "Advancing Security at the Silicon Level." Available at: <https://newsroom.intel.com/editorials/advancing-security-silicon-level/#gs.yh984y>. Accessed: March 2020.

9. B. Solomon, A. Mendelson, R. Ronen, D. Orenstien, and Y. Almog. "Micro-operation Cache: A Power Aware Frontend for Variable Instruction Length ISA." *IEEE Transactions on Very Large Scale Integration (VLSI) Systems (2003)*.

10. A. Rane, C. Lin, and M. Tiwari. "Raccoon: Closing Digital Side-Channels through Obfuscated Execution." *24th USENIX Security Symposium (USENIX Security '15)*.

11. M. Hähnel, W. Cui, and M. Peinado. "High-Resolution Side Channels for Untrusted Operating Systems." *2017 USENIX Annual Technical Conference (USENIX ATC '17)*.

12. B. Gras, K. Razavi, H. Bos, and C. Giuffrida. "Translation Leak-aside Buffer: Defeating Cache Side-Channel Protections with TLB Attacks." *27th USENIX Security Symposium (USENIX Security '18)*.

13. Y. Yarom, D. Genkin, and N. Heninger. "CacheBleed: A Timing Attack on OpenSSL Constant-Time RSA." *Journal of Cryptographic Engineering (2017)*.

14. A. Moghimi, J. Wichelmann, T. Eisenbarth, and B. Sunar. "MemJam: A False Dependency Attack Against Constant-Time Crypto Implementations." *International Journal of Parallel Programming (2019)*.

15. A. C. Aldaya, B. B. Brumley, S. ul Hassan, C. Pereida García, and N. Tuveri. "Port Contention for Fun and Profit." *2019 IEEE Symposium on Security and Privacy*.

16. D. Skarlatos, M. Yan, B. Gopireddy, R. Sprabery, J. Torrellas, and C. W. Fletcher. "MicroScope: Enabling Microarchitectural Replay Attacks." *Proceedings of the 46th International Symposium on Computer Architecture (ISCA '19)*.

17. J. Gyselinck, J. Van Bulck, F. Piessens, and R. Strackx. "Off-Limits: Abusing Legacy x86 Memory Segmentation to Spy on Enclaved Execution." *Engineering Secure Software and Systems (2018)*.

18. S. Shinde, Z. L. Chua, V. Narayanan, and P. Saxena. "Preventing Page Faults from Telling Your Secrets." *Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security (ASIA CCS '16)*.

19. J. Seo, B. Lee, S. Kim, M.-W. Shih, I. Shin, D. Han, and T. Kim. "SGX-Shield: Enabling Address Space Layout Randomization for SGX Programs." *Proceedings 2017 Network and Distributed System Security Symposium (NDSS '17)*.

20. D. Gruss, M. Lipp, M. Schwarz, R. Fellner, C. Maurice, and S. Mangard. "KASLR is Dead: Long Live KASLR." *Engineering Secure Software and Systems (2017)*.

21. Q. Ge, Y. Yarom, D. Cock, and G. Heiser. "A Survey of Microarchitectural Timing Attacks and Countermeasures on Contemporary Hardware." *Journal of Cryptographic Engineering (2018)*.

22. C. Disselkoen, D. Kohlbrenner, L. Porter, and D. Tullsen. "Prime+Abort: A Timer-Free High-Precision L3 Cache Attack Using Intel TSX." *26th USENIX Security Symposium (USENIX Security '17)*.

23. R. Guanciale, H. Nemati, C. Baumann, and M. Dam. "Cache Storage Channels: Alias-Driven Attacks and Verified Countermeasures." *2016 IEEE Symposium on Security and Privacy*.

24. O. Acıiçmez. "Yet Another MicroArchitectural Attack: Exploiting I-Cache." *Proceedings of the 2007 ACM Workshop on Computer Security Architecture (CSAW '07)*.

25. D. A. Osvik, A. Shamir, and E. Tromer. "Cache Attacks and Countermeasures: The Case of AES." *Topics in Cryptology – CT-RSA 2006*.

26. O. Acıiçmez and W. Schindler. "A Vulnerability in RSA Implementations Due to Instruction Cache Analysis and Its Demonstration on OpenSSL." *Topics in Cryptology – CT-RSA 2008*.

27. Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. "Cross-VM Side Channels and Their Use to Extract Private Keys." *Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS '12)*.

28. E. Tromer, D. A. Osvik, and A. Shamir. "Efficient Cache Attacks on AES, and Countermeasures." *Journal of Cryptology (2010)*.

29. Y. Yarom and K. Falkner. "FLUSH+RELOAD: A High Resolution, Low Noise, L3 Cache Side-Channel Attack." *23rd USENIX Security Symposium (USENIX Security '14)*.

30. D. Gruss, C. Maurice, K. Wagner, and S. Mangard. "Flush+Flush: A Fast and Stealthy Cache Attack." *Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA '16)*.

31. M. Schwarz, S. Weiser, D. Gruss, C. Maurice, and S. Mangard. "Malware Guard Extension: Using SGX to Conceal Cache Attacks." *Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA '17)*.

32. P. C. Kocher. "Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems." *Advances in Cryptology — CRYPTO '96*.

33. C. Percival. "Cache Missing for Fun and Profit." Available at: <http://css.csail.mit.edu/6.858/2014/readings/ht-cache.pdf>. 2005.

34. C. Liu, A. Harris, M. Maas, M. Hicks, M. Tiwari, and E. Shi. "GhostRider: A Hardware-Software System for Memory Trace Oblivious Computation." *Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '15)*.

35. D. Molnar, M. Piotrowski, D. Schultz, and D. Wagner. "The Program Counter Security Model: Automatic Detection and Removal of Control-Flow Side Channel Attacks." *Information Security and Cryptology - ICISC 2005*.

36. C. Liu, M. Hicks, and E. Shi. "Memory Trace Oblivious Program Execution." *2013 IEEE 26th Computer Security Foundations Symposium*.

### Supplemental Information

#### A.1 Responsible Disclosure

We notified the Intel PSIRT on February 21, 2020, about the Frontal attack. We sent them a previous version of this paper and a proof of concept for the vulnerabilities we identified. They informed us on April 22 that their best practices [27] already suggest avoiding secret-dependent branching, and therefore our attack is considered out-of-scope for their SGX libraries. Specifically, they stated that the balanced branches of the IPP Crypto library we attack in Section 5.1 are not used for secret-dependent operations in the SGX architectural enclaves and hence do not pose any security implication. The vulnerability shown in Listing 1 was reported to the mbedTLS team, which promptly fixed it. The vulnerability was also described in a 2017 paper [14] and was still unknown to the developers.

#### A.2 Data-Oblivious Execution

Resilience against side-channel attacks is often a desired security property when implementing software. This property is particularly important for libraries and applications that operate on secret and sensitive data on a system controlled by the attacker. Side-channel attacks exploit secret-dependent variations of the program execution. These variations are generally of two types: control-flow dependent and data-dependent.

- **Control-Flow Dependencies**: Present whenever the control flow of an application depends on confidential information.
- **Data Dependencies**: Manifest when latency or resources utilized depend on the input data. For example, when memory accesses at different addresses are performed based on some secret.

Countless attacks have exploited these types of dependencies in the past [62, 63, 59], targeting cryptographic libraries, as extracting secret keys handled by these libraries breaks any security guarantee built on top of them. Data-oblivious execution defends against side-channel attacks by removing these dependencies, eliminating any variation in program execution that would be potentially observable by the attacker.

There are two ways to obtain a data-oblivious executable:
1. Writing it directly in low-level assembly code.
2. Performing an automatic transformation at compile time from a higher-level language.

Note that writing the code in a higher-level language in a data-oblivious way and then simply compiling it might reintroduce data or control-flow dependencies at the binary level.

Several techniques for compiling and transforming code from an arbitrary high-level language to data-oblivious code have been proposed [40, 64, 65, 66, 26]. One of the most complete constant-time transformations for SGX is Raccoon [40]. It removes any control flow and most data dependencies by transforming secret-dependent branches into a decoy and a real path that contain similar instructions. At runtime, both paths are executed, allowing only the real one to modify memory by carefully applying the conditional move instruction (cmov). Raccoon runs on SGX enclaves and uses SGX’s memory protections to ensure confidentiality against an attacker who can otherwise read arbitrary locations of memory.

#### A.3 Measurement Details

We made several changes from stock SGX-Step [29], primarily aiming to reduce measurement noise as much as possible. In terms of functionality, we added the possibility to measure performance counters alongside instructions' timings. We identified four major sources of noise: the OS, variability in the APIC timer, unpredictability of shared resource state, and enclave creation offset noise. We discuss how we addressed each of these in the following paragraphs.

**OS Noise**: The OS is a source of noise as it needs to run the scheduler on each core to decide which tasks to execute. If the scheduler runs between the start of a measurement and its end, the measurement will inevitably be longer. Moreover, running any OS function while we single-step can sometimes evict part of the enclave memory from the cache, thus forcing the enclave to fetch it again when it is resumed. This also happens when the scheduler executes on the sibling core. As recommended in the original SGX-Step framework, we run the code in its own isolated core to reduce this noise. However, this alone does not stop the scheduler or other cores from interrupting the isolated core. We observed that disabling watchdogs at boot and disabling the graphical user interface tends to reduce the noise produced by the OS, albeit not completely.

**APIC Timer Variability**: In stock SGX-Step, the APIC timer is set in the `aep_cb_func`. The `aep_trampoline` then executes and resumes the enclave. Various conditions can create variability between the time the APIC timer is set and the time the enclave resumes. For instance, sometimes, the `aep_trampoline` code page or some of the data it uses might not be present in the cache. We addressed this variability by setting the APIC timer from the `aep_trampoline` function with a value passed from the `aep_cb_func` function and by serializing the instruction stream (using CPUID) just before setting the timer. Interestingly, while debugging for this source of noise, we observed that we were never able to interrupt in between fused macro-instructions, as these seem to be treated atomically by the CPU, as also observed in [23].

**Shared Resource State**: The third source of noise stems from the difference in the microarchitectural state between measurements. While we could not completely eliminate this source of noise as we have no direct view of the microarchitecture, we were able to reduce it significantly. The most effective change in this regard was obtained by linearizing the code of the `aep_cb_func` so that there is no mis-speculation in the execution.

**Enclave Creation Offset Noise**: Finally, while validating these changes, we noticed a source of noise across enclave creations, whose effects we illustrate in Figure 10. The figure shows the measurement of the `movs` from Figure 6 across enclave creations. As can be seen, the distributions remain bimodal, but the position of the modes across creations changes. However, the relative position between the modes stays the same: the `mov` at alignment `0x6` is slower than that at `0xe` on both runs. While we never observed modes shifting more than 200 cycles, this shift is still large enough such that, for instance, the distribution of `nop` instructions could overlap with the distribution of multiplication instructions from different runs. Given this shifting between enclave creations, we concluded that instructions' timings are only comparable within the same enclave.

```assembly
loop_start:
    mov (%rcx, %rdx, 8), %rax
    xor %r9d, %r9d
    cmp %rsi, %rax
    setb %r9b
    sub %rsi, %rax
    mov %rax, (%rcx, %rdx, 8)
    mov (%rdi, %rdx, 8), %r8
    mov %r9, %rsi
    cmp %r8, %rax
    adc $0x0, %rsi
    sub %r8, %rax
    mov %rax, (%rcx, %rdx, 8)
    add $0x1, %rdx
    cmp %rdx, %rbp
    jne loop_start
```

**Listing 2**: Exploited for loop in the mbedTLS library's `mpi_montmul` function (compiled on gcc 7.5.0 with -O3).

```assembly
loop_start:
    mov (%rax), %rcx
    sub $0x8, %rax
    mov %rcx, %rdx
    shl $0x3f, %rcx
    shr $0x1, %rdx
    or %rdi, %rdx
    mov %rcx, %rdi
    mov %rdx, (%rax + 8)
    cmp %rax, %rsi
    jnz loop_start
```

**Listing 3**: Exploited for loop in the `mbedtls_rsa_gen_key` function of the mbedTLS library.

**Figure 10**: Distribution of the instructions of Figure 6 across different runs, split by their alignments. This figure highlights how different enclave runs exhibit a shift in the mean of their instructions' distribution and hence distributions are not directly comparable between runs.