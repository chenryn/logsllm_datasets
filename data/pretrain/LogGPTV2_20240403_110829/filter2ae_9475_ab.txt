从上一节的最后一个图中可以看到，越界写覆盖的两个字节是未分配的内存。因为 v8 中在 New Space
中分配对象是顺序分配的，而在代码片段3的第二步和第三步之间没有分配任何对象，所有 RawOneByteString
后总是未分配的内存空间，改写未分配的内存数据没有任何意义。那么如何使 RawOneByteString
对象后的内容是有意义的数据就成了从越界写到任意地址写的关键。
首先想到的是能不能控制在分配 RawOneByteString 时触发一次 GC ，使得分配的 RawOneByteString
被重新拷贝，从而使得它之后的内存是已分配的其它对象，经过深入分析后发现此路不通，因为一个新分配的对象的第一次 GC 拷贝只是在两个半空间(from
space 和 to space)之间移动，拷贝后还是在 New Space 内部，拷贝后 RawOneByteString
之后的内存依然是未分配的内存数据。
第二种思路是越界写时写过 New Space 的边界，改写非 New Space 内存的数据。这需要跟在 New Space
后的内存区间是被映射的内存并且是可写的。New Space
的内存范围是不连续的，它的基本块的大小为1MB，最大可以达到16MB，所以越界写时可以选择写过任意一个基本块的边界。我们需要通过地址空间布局将我们需要被覆盖的内容被映射到一个
New Space 基本块之后。将一个 Large Space[7] 的基本块映射到 NewSpace 基本块之后是一个比较好的选择，这样可以能覆盖
Large Space 中的堆对象。不过这里有个障碍，我们应该记得，当第一个参数为 NULL 时，mmap 映射内存是总是返回 mm->mmap_base
到 TASK_SIZE 之间能够满足映射大小范围的最高地址，也就是说一般多次 mmap
时返回的地址应该是连续的，这样的特性很有利于操纵内存空间布局，但很不幸的是，chrome 在分配堆的基本块时，第一个参数给的是随机值，如下代码所示[9]：
这使得 New Space 和 Large Space 分配的基本块总是随机的，Large Space 的基本块刚好位于 New Space
之后后几率很小。我们采取了两个技巧来保证 Large Space 基本块刚好分配在 New Space 基本块之后。
第一个技巧是使用 web worker 绕开不能进行地址空间布局的情形；New Space 起始保留地址是
1MB，为一个基本块，随着分配的对象的增加，最大可以增加到 16MB，这16个基本块是不连续的，但一旦增加到
16MB，它的地址范围就已经确定了，不能再修改，如果此时 New Space 的内存布局如下图所示：
即每一个 New Space 的基本块后都映射了一个只读的内存空间，这样无论怎样进行地址空间布局都不能在 New Space 之后映射 Large
Space ，我们采用了 web worker 来避免产生这种状态，因为 web worker 是一个单独的 JS 实例，每一个 web worker 的
New Space 的地址空间都不一样，如果当前 web worker 处于上图所示状态，我们将结束此次利用，重新启动一个新的 webworker
来进行利用，期望新的 web worker 内存布局处于以下状态，至少有一个 New Space 基本块之后是没有映射的内存地址空间：
现在使用第二个技巧，我将它称为暴力风水，这与堆喷射不太一样，堆喷是指将地址空间喷满，但 chrome 对喷射有一定的限制，它对分配的 v8 对象和 dom
对象的总内存大小有限制，往往是还没将地址空间喷满， chrome 就已经自动崩溃退出了。暴力风水的方法如下：先得到16个 New Space
基本块的地址，然后触发映射一个 Large Space 基本块，我们通过分配一个超长字符串来分配一个 Large Space 基本块；判断此 Large
Space 基本块是否位于某一 New Space 基本块之后，若不是，则释放此 Large Space 基本块，重新分配一个 Large Space
基本块进行判断，直到条件满足，记住满足条件的 Large Space 基本块之上的 New Space 基本块的地址，在此 New Space
基本块中触发越界写，覆盖紧随其后的 Large Space 基本块。
当在 v8 中分配一个特别大（大于 kMaxRegularHeapObjectSize==507136）的 JS 对象时，这个对象会分配在 Large
Space 中，在 Large Space 基本块中，分配的 v8 对象离基本块的首地址的偏移是 0x8100 ，基本块的前 0x8100
个字节是基本块的头，要实现任意地址读写，我们只需要将 Large Space 中的超长字符串对象修改成 JSArrayBuffer
对象即可，但在改写前需要保存基本块的头，在改写后恢复，这样才能保证改写只修改了对象，没有破坏基本块的元数据。要精确的覆盖 Large Space
基本块中的超长字符串，根据 unescape 的解码规则有个较复杂的数学计算，下图是执行 unescap 前的内存示意图：
假设 Large Space 基本块的起始地址为 border address，border address 之上是 New Space ,之下是
Large Space , 需要被覆盖的超长字符串对象位于 border+0x8100 位置，我们构造一个越界串，它的起始地址为
border-0x40000 ,结束地址为 border-0x2018 ,其中 border-0x40000 到 border-0x20000
范围是已分配并已初始化的内存，存储了编码后的 JSArrayBuffer 对象和辅助填充数据 “a”, border-0x20000 到
border-0x2018 是未分配内存，存取的数据为堆喷后的残留数据 “a”, 整个越界串的内容都是以 “%xxy”
的形式存在，y不是字符%,整个越界串的长度为 (0x40000-0x2018)，所以 unescape 代码片段3中第一步计算出的目的字符串的长度为
(0x40000-0x2018)/2 ,起始地址为 border-0x20000 ，执行完 unescape 后的内存示意图如下：
在执行完代码片段3第二步后， Write Point 指向 border-0x20000+0xc ，因为 NewRawOneByteString
创建的对象的起始地址为 border-0x20000 ,对象头为12个字节。
我们将代码片段3的第三步人为地再分成三步，第一步，解码从 border-0x40000 到 border-0x20000 的内容，因为此区间的内容为
“%xxy” 形式，所以解码后长度会减半，解码后写的地址范围为 border-0x20000+0xc 到 border-0x10000+0xc ，解码后的
JSArrayBuffer 位于此区间的 border-0x17f18 ；第二步，解码从 border-0x20000 到 border-0x10000
的内容，因为此时此区间不含%号，所以解码只是简单拷贝，解码后长度不变，解码后写的地址范围为 border-0x10000+0xc 到 border+0xc
，解码后的 JSArrayBuffer 位于此区间的 border-0x7f0c ，第三步，解码从 border-0x10000 到
border-0x2018 (越界串的边界)的内容，这步解码还是简单拷贝，解码后写的地址范围为 border+0xc 到 border+0xdfe8
，解码后的 JSArrayBuffer 正好位于 border+0x8100 ，覆盖了在 Large Space 中的超长字符串对象。在
JavaScript 空间引用此字符串其实是引用了一个恶意构造的 JSArrayBuffer 对象，通过这个 JSArrayBuffer
对象可以很容易实现任意地址读写,就不再赘述。
#### 7\. 任意地址读写到任意代码执行
现在已经有了任意地址读写的能力，要将这种能力转为任意代码执行非常容易，这一步也是所有步骤中最容易的一步。Chrome 中的 JIT 代码所在的页具有 rwx
属性，我们只需找到这样的页，覆盖 JIT 代码即可以执行 ShellCode 。找到 JIT 代码也很容易，下图是 JSFunction
对象的内存布局，其中 kCodeEnryOffset 所指的地址既是 JSFucntion 对象的 JIT 代码的地址。
#### 8.总结
这篇文章从一个微小的逻辑漏洞出发，详细介绍了如何克服重重阻碍，利用这个漏洞实现稳定的任意代码执行。文中所述的将一个越界读漏洞转换为越界写漏洞的思路，应该也可以被一些其他的信息泄露漏洞所使用，希望对大家有所帮助。
对于漏洞的具体利用，此文中还有很多细节没有提及，真正的利用流程远比文中所述复杂，感兴趣的可以去看这个漏洞的详细利用[10]。
#### 引用
[1] [2]
[3]  
[4]
[5]
[6]
[7]
[8]
[9]  
[10]
* * *