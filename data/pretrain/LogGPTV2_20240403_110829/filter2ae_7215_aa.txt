文章文类：漏洞分析类
来源文章链接：
# 标题：投稿-画二进制0x000001攻击的艺术 【基于栈的溢出】
> 亲爱的黑客同伴和安全爱好者，你好鸭。
## 1.什么是二进制攻击？
大家好，我现在计划在接下来的时间里发布一个“二进制Exploitation”系列的文章。不知道你是否知道其实这是一个在黑客空间中巨大而又核心的领域。在我开始之前，坦白说，对那些没有计算机背景的来说并不值得花这么多时间在这方面，但是我希望我能够尽可能以简单和容易的方式讲解。然而平铺直叙的罗列基础知识无趣死了，所以，敲重点！如果你有一个这方面好的基础，你一定会喜欢跟着我做的。
二进制漏洞攻击是一个在网络安全非常宽泛的主题，目的是发现程序中的漏洞并且攻击他，来获得shell控制全或者修改程序的功能。计算机能够理解的语言部分称为“二进制”。计算机以二进制操作，意味着存储数据和执行计算都只用0和1。一个比特二进制代表不二逻辑中的True（1）和False（0）。每一种语言，都有其特别的地方，同时很多时候他们也有许多程序语言的共性。二进制的原理是利用弱势转化为优势，即利用缺陷和漏洞来导致意外和不可预料的行为发生。
> 先修课程
>
> 编程基础 64位汇编 Linux终端使用
所以我们开始一个简单的基于堆的缓冲区溢出。
## 2.缓冲区溢出
这里有两种不同的缓冲区溢出攻击。一种是基于堆的，另一种是基于栈的缓冲区溢出。这两种情况，都是发挥了应用等待用户的输入的优势。它可以造成程序崩溃或者执行任意代码。一个缓冲区溢出发生当程序尝试将比他能够接收到的更多的数据充满内存（一个内存缓冲区）。攻击者通过覆写应用的内存执行缓冲区溢出问题。缓冲区溢出是一种软件应用常见的漏洞，他可以攻击实现远程代码执行RCE或者DoS攻击。最简单最长的缓冲区溢出出现在堆上。最重要的原因缓冲区溢出是编程语言的使用，没有自动的监视和现实内容的缓冲区或者基于堆的缓冲区溢出问题。这包括C和C++语言，下面给出一个例子。
## 3.漏洞C程序
    #include 
    #include 
    #include 
    #include 
    #include 
    char *gets(char *);
    void abracadabra() {  
     printf("Success..! Function called :D\n");  
     exit(0);  
    }
    int main(int argc, char **argv) {  
     struct {  
     char buffer[64];  
     volatile int (*point)();  
     } hackvist;  
     hackvist.point = NULL;  
     gets(hackvist.buffer);  
     if (hackvist.point) {  
     printf("Function Pointer → %p\n", hackvist.point);  
     fflush(stdout);  
     hackvist.point();  
     } else {  
     printf("Try Again\n");  
     }  
     exit(0);  
    }
如果你有一写C语言的编程基础那么你就明白上面的代码是如何运行的。如果还是存在着疑惑，
等待我来解释吧。
> 我们的目标：为了执行没有被调用的“abracadabra”函数
代码提供了一段函数“abracadabra”，却没有在任何地方调用。代码使用了一个大小为64的缓冲区和一个“*point”指针。并且指针的值设置为NULL，通过`gets()函数`赋值`&`。`gets()`从标准输入`(stdin)`读取字符，然后以一个C语言字符串类型存储起来，直到出现一个换行符或者输入文件结尾。然后`point
value`会被校验（默认时我们设置为NULL）并且以`print`输出。如果值仍然是`NULL`呢？那么会尝试重新获取输出。下面编译和运行程序看看：
**代码成功编译并且准备执行。你可以看到在编译后发现一个告警信息，通常情况下，人们最关心`errors`类的错误，忽视`warnings`类的错误。**
> 警告：gets函数非常危险，不应该使用。
## 4.为什么gets()是非常危险的？
因为函数假设用户输入是不安全的。绝不要考虑使用它。因为gets没有办法阻止buffer
overflow，所以你不会要用gets。他不会对其输入的大小做边界检测。攻击者可以很轻松的发送一个任意大小的输入到gets()中，以造成buffer溢出的目的。如果用户输入更多的数据，那就会使得非常可能以出错或者更早的形式结束。
通过提供一些输入我执行这个程序。程序代码显示相同的“Try Again”输出。
假设else语句开始输出。
> _if (hackvist.point) {_  
>  _printf(“Function Pointer → %p\n”, hackvist.point);_  
>  _fflush(stdout);_  
>  _hackvist.point();_  
>  _}_ **else {  
>  printf(“Try Again\n”);** _//\_ This One *// __}*
这意味着指针的值仍然为`NULL`，“hackvist.point=NULL”，所以让我们开始探索代码。
目的是改变程序执行流程，执行`abracadabra`函数。现在我们开始调试代码。
> 第一，我会进入main，然后以不进任何输入运行。
>
> b main
>
> 断点位于 0x119a
我通过每次输入ni跳过指令。最后到达`gets()`函数的指针地址。我将以不进行任何输入进行分析流程。
正如我所说的，我没有提供在需要输入的时候提供任何值。代码依然像上一次那么运行。指针的值是`NULL`，那就是说else语句被执行。结果如下：
现在，是时候分析并绕过这个值了。buffer缓冲区的大小是64，所以我将以可识别的格式传递这些值。也很容易理解，在这里，我简单的做了一个python样本。
> 我们会使用它作为输入，所以我只需要简单的做：
>
> _python exploit.py > exp_
>
> b main：首先打入main断点
>
> r  在持续执行else语句之后，我们在嗲吗
>
> **NB: 指针值被彻底改变了!**
继续输入`ni`，我们可以发现有趣的东西。
## 5. **分段故障（Segmentation Fault）**
一个程序分段错误是一个常见的条件，可以造成程序崩溃，又叫做segfault。这通常发生在程序试图访问不被允许访问的内存位置，或者试图以不被允许的方式访问内存位置。现在，我们已经走上了正轨，我们能够通过类似的r
0x5252525251515151\n`，我们知道Q和R好像被溢出了，&具体的值储存在缓冲区后的pointer指针中。所以，那么现在程序代码`hackvist.point();`会被调用。我们的目的是执行`abracadabra`函数。显然，如果我们把函数的入口地址放在pointer指针中，那么程序将会调用这个函数。现在我们检查`abracadabra`的地址。
我们得到了函数的地址，现在我们编辑一个python脚本，写一小点点的代码。我们以合适的方式放置`0x555555555179`并且不得不考虑字节顺序。因此，我清除了buffer中Q，因为我知道输入仍然是可识别的格式。我添加地址“0x555555555179”到payload并且因为需要完成移动所以保存它。
让我们运行这个python脚本 exploit.py > exp & 在gdb中 "r  objdump -d ./stack-three | grep complete_level
我们放置这个地址在指针pointer的值中，然后它就会调用这个函数。一行简单的python代码就足以通过缓冲区溢出这种非常有效的方式来解决这个挑战。结果如下。
简单的输入:
python -c 'print"A"*64 + "\x9d\x06\x40"' | ./stack-three