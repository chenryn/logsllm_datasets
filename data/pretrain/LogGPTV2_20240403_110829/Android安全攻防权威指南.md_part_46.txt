导致GDB客户端遇到错误甚至崩溃。第二，非AOSP设备很少包含任何类型的符号，在没有获
取到完整编译系统的情况下自己编译是不可能的。除了函数名、源代码文件和行号信息不可用外，
标识处理器模式的ARM符号也是缺失的。这一重要信息的缺失导致难以确定代码处于处理器的
哪种执行模式，从而在设置断点和查看调用栈时出现问题。
调试非Nexus设备的整体流程与Nexus设备非常相似，按照7.6.3节中的步骤就可以得到期
望的结果。
找到可以工作的GDB服务器和GDB客户端可能比较困难，需要尝试这些程序的一些不同版
本。如果能够确定生成设备二进制文件所使用的工具链，使用该工具链中的GDB服务器和客户
端会得到最好的结果。完成此步骤后，就可以勇往直前了。
如果没有符号，GDB就无法知道二进制文件的哪些部分是Thumb代码，哪部分是ARM代
码。因此，无法自动确定如何反汇编或者设置断点。可以使用静态分析工具逆向分析代码来解决
此问题。GDB也支持访间当前程序状态寄存器（CPSR），检查该寄存器的第5位可以得知处理
器处于ARM模式还是Thumb模式。一且确定调试器位于Thumb模式的函数中，运行带有thumb
值的setarmfallback-mode或setarmforce-mode命令会告知GDB如何对待该函数。
如果在Thumb函数中设置断点，千万要记住把地址加一，这会通知GDB该地址指向的是一个
Thumb指令，从而改变其插入断点的方式。
也可以直接使用CPSR寄存器设置断点，如下所示：
(gdb) break 0x400c0e88 +( ($cpsr>>5)&1)
使用此方式时要小心，因为不能保证目标函数与调试器当前上下文在相同的模式下运行。在
任何情况下，正确运行的概率都是50%。设置断点后，如果断点没有触发或者目标进程发生错误，
可能是因为设置断点时处于错误的模式之下。
即使有了这些技术的支持，调试非AOSP设备仍然是不可预知的，可能会遇到各种问题。
7.7调试混合代码
Android操作系统包含原生和 Dalvik代码。在Android框架层，有许多代码路径从Dalvik代
码执行到原生代码：一些代码甚至从原生代码回调至DalviVM。调试混合代码时，查看并单步
调试整个代码路径是非常有用的，尤其是查看整个函数调用栈。
幸运的是，在Eclipse中可以非常方便地同时调试Dalvik和原生代码。虽然会偶尔发生一些
小问题，但是可以在两种类型的代码上设置断点。不论到达哪种断点，Eclipse都会正确地暂停执
行并支持交互式调试。为了调试混合代码，需要结合7.5节和7.6节介绍的所有技术。在Eclipse
中启动调试会话时，务必使用AndroidNative Application调试选项。
---
## Page 207
7.8其他调试技术191
7.8其他调试技术
虽然交互式调试方法是跟踪数据流或确定假设的最好方法，但是一些其他方法也可以替代或
增强调试过程。在源代码中植人调试语句是查看代码覆盖路径或跟踪变量内容的常用方法。不论
是使用自定义的调试器还是ARM平台下的GDB，在设备上调试本身就有一定的作用。最后，一
些对于时序敏感的问题可能需要使用高级技术，例如注入（instrumentation）。本节将讨论这些方
法的优势和缺陷。
7.8.1调试语句
直接在源代码中植人调试语句是调试程序最古老的方法之一，对Dalvik和原生C/C++代码都
有效。遗憾的是，该技术在没有源代码的情况下是不能使用的。即便可以获得源代码，这种方法
也需要重新编译，并将生成的二进制文件重新部署到设备上。在某些情况下，可能需要通过重启
来重新加载目标代码。如果要将调试语句迁移到源代码的新版本上，可能需要进行额外的移植工
作。虽然这些缺陷会导致较高的前期成本，但是调试语句自身的运行成本非常低。此外，植人调
试语句可以很好地将源代码与运行时的情况关联起来。总而言之，这个方法是跟踪bug和理解程
序的可靠选择
7.8.2在设备上进行调试
、
7
调试类似Android手机的嵌入式设备，远程调试方法已经成为了事实标准，但是直接在设备
上进行调试可以避免一些麻烦。首先、远程调试比在设备上调试慢得多，因为每一个调试事件都
需要往返于设备和主机调试器之间。远程调试对于有条件的断点来说尤其慢，因为这需要通过额
外的一次往返确定条件是否满足。此外，在设备上进行调试有时候不需要主机。有多种方式可以
实现在设备上的调试，本节对部分进行介绍。
1. strace
尝试调试一些古怪的代码行为时，strace工具就是天赐之物。该工具支持系统调用级别的
跟踪功能，这也是其名称的由来。在系统调用级别进行调试可以方便地查看原因不明的“nosuch
fileordirectory”错误源自何处。该工具也有助于准确查看是什么系统调用导致了前溃。strace
工具支持启动新的进程，也可以附加至已有的进程。对于查看该进程在什么地方挂起，或者确认
网络通信或进程间通信（IPC）确实正在发生，附加至已有进程是非常有用的。
strace工具在AOSP中，被编译为userdebug生成的一部分。然面，该工具在配置文件
中并不会被放入默认安装镜像。将该二进制文件推送至设备需要执行如下代码：
dev:~/android/source $ adb push \
out/target/product/maguro/obg /EXECUTABLES/strace_intermediates/LINKED/
strace
656 KB/s (625148 byte8 in 0.929s)
data/1oca1/tmp/
---
## Page 208
192第7章调试与分析安全漏润
上面的例子来自于我们为GalaxyNexus生成的环境。该二进制文件可以应用在支持ARMv7
的所有设备上。
2.自编译GDB
在Android设备上直接运行GDB是再理想不过的。不过GDB不直接支持Android，而且将
GDB移植到Android上运行并非易事。已经有人尝试过创建原生的Android GDB二进制，一些
人甚至宣称自己成功了。其中之一是Alfredo Ortega，他在https:/sites.google.com/site/ortegaalfredo/
android上提供了GDB 6.7和 6.8版本的二进制文件。另一种方法可以参考来自Debian项目的
Debootstrap使用说明：https://wiki.debian.org/ChrootOnAndroid。遗撼的是，上面这两种二进制文
件都不支持Android线程，只能调试进程的主线程。
注意使用Debootstrap版本的GDB时，可以按照说明使用Id.so在chroot外运行chroot内的二
进制文件。此外，将/system/1ib添加到LD_LIBRARY_PATH的开头以修复符号解析问
题。
3.编写自定义调试器
本章用来调试原生代码的所有工具都是基于ptraceAPI创建的。ptrace API是用于调试进
程的标准UnixAPl。因为该API被实现为Linux内核的系统调用，所以儿乎所有的Linux系统中
都存在该API。只有很少的情况，例如一些GoogleTV设备，不支持ptrace。研究人员使用该
API能够直接开发强大的自定义调试器，而无需依赖现有的GDB。本书作者创建的一些工具就
是基于ptrace的。这些工具直接在设备上运行，运行速度通常比GDB快（甚至比设备上的GDB
还快）。
7.8.3动态二进制注入
即便调试器处于最佳状态，也可能会有其他问题：使用大量跟踪断点可能导致调试过程非常
缓慢；在时序敏感的代码区城设置断点可能影响程序运行，使漏洞利用的开发更加复杂。在这些
情况下，另一种优秀的技术就可以发挥作用了。
动态二选制注入（DynamicBinaryInstrumentation，DBI）是一种将额外代码插入程序正常执
行流的方法，通常被称为hooking。一般是首先构造一些自定义代码，然后将其注人目标进程中。
与断点一样，DBI也需要对一些重要的代码进行重写。然而，DBI并非插人一条断点指令，面是
插入跳转指令，将执行流重定向到所插入的自定义代码上。该方法大大提升了性能，避免了不必
要的上下文切换。此外，被注入的自定义代码可以直接访问进程内存空间，不必进行额外的上下
文切换来获取内存内容（和ptrace一样）。
注意DBI是一项强大的技术，不只应用于调试，也可以用来在运行时修补漏润，扩展功能，
在代码中增加新的接口来进行测试，等等。
---
## Page 209
7.9漏洞分析
193
本书作者利用 ptrace API和 DBI编写了一些工具。Collin Mulliner的 Android动态二进制注
人工具包（adbi）和 Georg Wicherski的AndroProbe 都使用了ptrace 来注入自定义代码，但是
实现的目的不同。Collin的工具包可以在https://github.com/crmulliner/adbi找到。
7.9漏洞分析
在信息安全领域，漏润分析这一术语指的是集中精力去发现、分类和理解系统中潜在的危险
问题。这个定义几乎涵盖了信息安全中的一切。把这个定义细分来看，就会涉及研究人员和分析
师使用的许多技术和程序。不管最终目标是攻击还是防御，实现的步骤都极其相似。
本章剩余的部分关注漏润分析当中的一个小领域：分析内存破坏漏润导致的前溃。本章介绍
的调试技术可以为第6章和第8章建立联系。掌握这类分析技术后，研究人员能够深人理解漏洞
的成因和潜在的影响。
无论从漏洞修补还是利用的角度来看，对内存破坏漏洞的分析都是富有挑战性的。分析有两
个主要的目标：明确问题的根源，以及判断漏洞的可利用性。
7.9.1明确问题根源
对于潜在可利用的内存破坏漏润，首要任务是理解bug产生的根源。和其他信息安全概念一
样，讨论问题根源时会有不同的明确程度。对于崩溃分析来说，我们把带来漏洞状态的首次异常
行为作为问题根源。
注意未定义行为可能会产生许多类型的内存破坏。MITRE的通用缺陷列表（CWE）项目记录
了这些类型信息，变多内容参考http://cwe.mitre.org/data/index.html。
这些异常行为来自于编程语言中的未定义行为（undefinedbehavior）概念。这个术语指的是
那些规范中没有定义的行为，可能是由于不同的底层架构、内存模型或者边角细节造成的。C和
C++语言规范中就定义了很多未定义行为。在理论上，未定义的行为可能会导致任何事情发生，
如正常行为、故意的期溃、微妙的内存破坏等。这些行为是研究者感兴趣的一个重要领域。
正确地判断漏洞根源是漏洞分析中最重要的一步。对于防御者来说，如果不能准确理解问题
的根源，就很可能无法充分解决问题。对于攻击者来说，理解问题根源是漫长攻击过程中的第一
步。只要想根据漏洞的可利用性来对漏润优先级进行排序，对漏洞原因的分析都是必不可少的。
值得高兴的是，有很多技巧和有用的工具来帮助我们完成这个任务。
1.提示和技巧
寻找漏洞根源需要学习很多技巧，这里介绍其中的一小部分。具体使用哪些技术取决于异常
行为是如何被发现的。模棚测试技术可以用来比较和精简输入，Android等操作系统也包含了一
些辅助调试工具。调试器是非常关键的工具，要充分利用它的特性。当然，漏洞最终的根源存在
于代码本身，这些技术有助于快速定位相关代码。
---
## Page 210
t61
第7章调试与分析安全漏洞
·比较和精简输入
模测试方法是自动生成输人并进行测试，直到找到引发异常行为的输入，然后通过分析输
人来理解错误原因。这是一个非常好的思路。
对于基于变异的模测试来说，通过比较变异前后的样本可以找到差异所在。例如，如果对
文件格式进行模糊测试时只改变了一个字节，就可以通过两个文件的差异分析出究竞是哪个值发
生了改变。使用同一个解析器产生了语义的改变，就可以分析出改过的字节究竞是一个长度值的
类型还是标签长度值（TLV）类型：还可以进一步分析出这个字节和哪一个标签相关。这些语义
信息为研究者寻找相关代码提供了很好的提示。
无论是基于变异还是基于生成的模糊测试，精简输人都很有帮助。精简输人有两种方式：恢
复变异和消除不必要的输人。恢复变异可以帮助找到真正产生异常行为的变异。消除测试当中不
改变运行结果的输入部分，就意味着可以减少需要分析的目标。考虑前面比较输人的例子，如果
有上万个数据包含同样的tag值，分析就没法进行了，因为会得到上万次断点。消除那些没必要
的数据块就能够将命中的断点精简为一。与输入比较的方法一样，语义信息可以很好地帮助我们
精简输人。将文件格式划分为分层结构的组件，然后在不同的层级上进行副除，可以加快输人精
简的过程。
虽然这两种技术很强大，但是很难用于模糊测试以外的漏洞发现方法。后面要讲的其他技术
适用于大量分析场景，更加通用。
·Android堆调试
Android的BionicC运行时库包含了内建的堆调试工具。这个特性在http:/source.android.com/
devices/native-memory.html中有简单的讨论。该特性受系统属性1ibc.debug.ma11oc控制。如
前面的网页所述，想要为那些从Zygotefork出来的进程开启堆调试工具（例如浏览器）需要重
启整个Dalvk运行时。相应的方法已经在7.5.3节中进行了介绍。
通过这个变量，Android提供了调试堆内存错误的4种策略。bionic/libc/bionic目录下的
malloc_debug_common.cpp文件包含更多的细节，如下所示：
455
// Initialize malloc dispatch table vith appropriate routines.
457
456
svitch (debug_level)(
458
case 1:
459
InitMal1oc (&gMa11ocUse, debug_leve1, *leak*);
break;
460
461
ca8e 5:
InitMalloc(&gMallocUse, debug_level, *fi11*);
462
463
case 10:
break)
464
InitMa11oc(&gMa11ocUse, debug_level,*chk*);
465
466
case 20:
break;
467
InitMa11oc (&gMa1loeUse, debug_leve1, *qemu_instrunented*) :
468
break;
这个文件开头有一条注释，解释了每种策略的用途：但是第4个选项gemu_instrumented