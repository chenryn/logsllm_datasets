that we are developing based on the BF implementation pre-
sented in the previous section.
5.1. Watch Lists
BFs can be used to store hashes of any kind. In partic-
ular, they can store hashes of features[10] extracted from
ﬁles or bulk data.
We are developing a bulk extraction application which
extracts features, computes the HMAC using a selectable
secret key, and stores the results in a BF. This program can
be applied to list of email addresses, credit card numbers,
or other kinds of pseudounique information to create watch
list ﬁlters. These ﬁlters can be taken into the ﬁeld and used
to triage suspect hard drives while minimizing the risk that
the features in the ﬁlter will be compromised.
5.2. Cross-Drive Analysis
Boolean operations can be applied directly to BFs. This
allows BFs to be used for cross drive subsection. The proce-
dure is straightforward. First, a BF containing the hashes of
the extracted features is created for each drive in the corpus.
A threshhold is set for the maximum number of drives for
which a ﬁlter will be considered (a threshhold of n
3 where
n is the number of hard drives in the corpus is a good start-
ing point). Next, a threshold vector ¯F of integers is created
where the size of the vector is equal to the number of bits in
the BFs. Each BF is scanned; for every bit i that is encoun-
tered, the corresponding integer in ¯F is incremented. At the
conclusion of the ﬁrst pass, all integers in ¯F that are larger
than the threshold are zeroed. Those that remain are used
as a ﬁlter of relevant pseudounique features. A correlation
vector ¯Fi,j can now be constructed for each (i, j) pair of
drives by computing ¯F + Fi + Fj.
5.3. Segmenting RDS
File hashes present a useful way of eliminating known
ﬁles that are unlikely to be modiﬁed from the set of ﬁles of
interest to a forensic investigator. However, a set of known
ﬁles of interest can provide much more useful information,
though it can be harder to ﬁnd.
Instead of having a single BF for all of RDS, an alterna-
tive is to divide the data set into smaller sets: one containing
Windows installation ﬁles, one containing ﬁles from com-
mon desktop application, one for video production applica-
tions, and so on.
Dividing RDS in half and storing each in its own BF
that is half the size signiﬁcantly decreases the false posi-
tive rate, since there are fewer opportunities for aliasing.
Although the time to search the BFs increases because each
BF must be searched sequentially, the advantage is that the
BFs can be used to characterize the ﬁles beyond simply
known/unknown. This is equivialent to using a Bloomier
ﬁlter[5].
Figure 5. A test image for creating Bloom ﬁl-
ter false positives.
p = 0.016. Finding all ﬁve together is p = (0.016)5, or
roughly 2−30, which makes the difﬁculty of ﬁnding such a
collision roughly equal to the task of cracking a 30-bit en-
cryption key.
We tested this hypothesis by taking a JPEG of a kit-
ten (Figure 5), appending a binary counter, computing the
SHA-1 and checking for a false positive. If no false pos-
itive was found we incremented the counter and repeated.
We found a collision with the M = 32 k = 4 BF
after 110,223,107 iterations by appending the hex bytes
03 df 91 06. Total computation time to ﬁnd the alias
was roughly 5.5 CPU hours. Details are in Table 4.
The only defense against this attack is to use an en-
crypted bloom ﬁlter—for example, by hashing each 160-bit
SHA-1 with a 160-bit random key that is kept secret. Since
the adversary does not know the key, she cannot construct
an alias. Unfortunately, the key must be kept secret, and the
BF cannot be used without it.
In practice, this means that while BFs are a useful tool
for distributing hash sets within an organization, publishing
the BFs in a public forum makes those BFs unsuitable for
use if there is an adversary who might wish to hide data by
creating false positives.
The permutation attack is also a useful defense against
the use of BFs for ﬁnding known bads or for performing
cross-drive analysis, but that attack is also useful against
traditional hash analysis as well. That is, making minor
changes to hacker tools or contraband content necessarily
changes the hash value of these ﬁles. Therefore, using BFs
for ﬁnding known bads does not introduce any more vulner-
abilities than using traditional hash tools, but does make the
searches dramatically faster.
1020
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:48 UTC from IEEE Xplore.  Restrictions apply. 
Original SHA1:
df7ce34d
SHA1 of modiﬁed ﬁle:
cb6b989b
SHA1 of “Index.htm” from “WIN”
C076275E
SHA1 of “MEMLABEL.PCT” from “Mac” B961495D
SHA1 of “1TXT047.gif” from “WIN2000”
EAA0EF99
SHA1 of “H8499.GIF” from “Gen”
4B8A4059
f723ae1a
97ad04fb
694CC871
3CDCC1C6
B62CD185
19B1E394
675cd06f
eaa0ef99
C9624246
97AD04FB
3A9DD81A
85B7B439
e202d060
4b8a4059
CB6B989B
4CF2CFFE
1FF458C3
E3A0B940
bd82bd9b
f2d51dc6
BFFEA55F
1BDA3025
734767DF
AD65865F
Table 4. Results of a brute force attack against Bloom ﬁlter with M=32 and k=4. The ﬁrst line shows
the SHA1 of the original JPEG (Figure 5); The second line shows the SHA1 of the ﬁle modiﬁed by
appending the hex bytes 03 DF 91 06. The remaining lines show the SHA1 of the speciﬁc ﬁles names
and application distributions within RDS 2.19 that contributed to the false-positive, with the speciﬁc
aliases boxed.
5.4. Preﬁltering with Bloom Filters
An alternative to segmenting the RDS into multiple BFs
is to use the BFs in conjunction with a slower lookup ser-
vice that returns additional information. That is, instead of
viewing the RDS BF as an alternative to storing the RDS
in a MySQL database, the BF can be used as an accelera-
tor for database: hashes that are to be looked up can ﬁrst
be checked against the BF and, if the hash is in the RDS,
then the MySQL database can be consulted to obtain the
additional metadata.
To this end, our MySQL schema stores signiﬁcantly
more information for each hash: we store all of the infor-
mation distributed with the RDS, including ﬁle name, size,
operating system ID, application ID, language, and RDS re-
lease. This information is stored in structured many-to-one
and many-to-many SQL tables. The information can be ac-
cessed directly using a MySQL connector or through a web-
based XMLRPC server.
6. Conclusions
Validating previous work, we ﬁnd that BFs are good
tools for performing high-speed matches against hash sets.
However, we learned that BFs are not a good tool for dis-
tributing hash sets of “known goods” if the adversary can be
reasonably expected to get access to the ﬁlter or the ﬁlter’s
parameters, because it is relatively easy for an adversary to
modify hostile content to create a false positive. The way
to defend against this attack is to create bloom ﬁlters in the
ﬁeld with a randomly chosen cryptographic key.
By testing RDS with a variety of different BF param-
eters, we found that a ﬁlter with 232 one-bit elements
(512MB in size) with 5 hash functions produced excellent
performance. We have made our BF implementation freely
available for download; the implementation is Public Do-
main and can be freely used or modiﬁed by anyone for any
purpose. Finally, we have shown how BFs can be used to
build secure watch lists and for cross drive analysis.
6.1. Availability
All of the programs discussed in this paper are dis-
tributed in source code form and build with GNU build
tools. We have tested them on MacOS 10.5, Linux, and
FreeBSD. The code may be downloaded from our web
server at http://www.afflib.org/.
6.2. Future Work
We are in the process of evaluating the use of BFs for
hash sets of individual ﬁle blocks or disk sectors.
We are modifying our web-based hash lookup service so
that new hashes can be automatically submitted by mem-
bers of the community; we hope to implement a reputation
system and voting algorithm to prevent database poisoning.
We may further modify the system so that users will be able
to download BFs constructed “on the ﬂy” to match speciﬁc
SQL queries based on the RDS (e.g., a BF that matches the
ﬁles that were part of a speciﬁc application program).
We are working on a new release of our BF code that
will be able to directly open BFs that have been compressed
with the ZIP or GZIP algorithms. Given that Java has
memory-mapped ﬁles and there are persistent reports that
well-written Java code can out preform the equivalent C,
we are also writing a compatible Java implementation of
our BF code.
6.3. Acknowledgments
The authors wish to express their thanks to Brian Carrier,
Jesse D. Kornblum, Beth Rosenberg and Vassil Roussev, all
of whom have provided useful feedback on this research and
this paper. Thanks also to the anonymous reviewers who
saw and corrected signiﬁcant errors in a previous version
of this paper and recommended exploring the possibility of
false-positive attacks.
This research was supported in part by the Naval Post-
graduate School’s Research Initiation Program. The views
expressed in this report are those of the author and do not
nnecessarily reﬂect the ofﬁcial policy or position of the De-
partment of Defense, the National Institute of Standards and
Technology, or the U.S. Government.
References
[1] Fabrice Bellard. Qemu: Open source processor emulator,
2008. http://bellard.org/qemu.
1121
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:48 UTC from IEEE Xplore.  Restrictions apply. 
[2] Burton H. Bloom. Space/time trade-offs in hash coding
with allowable errors. Commun. ACM, 13(7):422–426, 1970.
ISSN 0001-0782.
[3] Andrei Broder and Michael Mitzenmacher. Network appli-
cations of bloom ﬁlters: A survey. Internet Mathematics, 1
(4):485–509, May 2004.
[4] Brian Carrier.
The Sleuth Kit & Autopsy: Forensics
tools for Linux and other Unixes, 2005. http://www.
sleuthkit.org/.
[5] Bernard Chazelle, Joe Kilian, and Ronitt Rubinfeld. The
blomier ﬁlter: an efﬁcient data structure for static sup-
port lookup tables. In Proceedings of the Fifteenth Annual
ACM-SIAM Symposium on Discrete Algorithms, pages 30–
39, 2004.
[17] Vassil Roussev, Yixin Chen, Timothy Bourg, and Golden
G. Richard III. md5bloom: Forensic ﬁlesystem hashing re-
visited. Digital Investigation, 3(Supplement-1):82–90, 2006.
[18] Vassil Roussev, Golden G. Richard III, and Lodovico
Marziale. Multi-resolution similarity hashing. Digital In-
vestigation, 4(Supplement-1):105–113, 2007.
[19] Douglas White. NIST national software reference library
(NSRL), September 2005. http://www.nsrl.nist.
gov/documents/htcia050928.pdf.
[20] Douglas White, August 17 2006. http://www.nsrl.
nist.gov/RDS/rds_2.13/bloom/.
[6] Franck Delattre and Marc Prieur.
Intel core 2 duo –
July 4 2006. http://www.behardware.com/
test.
articles/623-6/intel-core-2-duo-test.
html.
[7] Peter J. Denning and Stuart C. Schwartz. Properties of the
working-set model. Commun. ACM, 15(3):191–198, 1972.
ISSN 0001-0782.
[8] Peter C. Dillinger and Panagiotis Manolios. Bloom ﬁlters in
probabilistic veriﬁcation. In Formal Methods in Computer-
Aided Design. Springer-Verlag, 2004. http://www.cc.
gatech.edu/fac/Pete.Manolios/research/
bloom-filters-verification.html.
[9] Li Fan, Pei Cao, J. Almeida, and A. Z. Broder. Summary
cache: a scalable wide-area web cache sharing protocol.
IEEE/ACM Transactions on Networking, 8:281–293, June
2000.
[10] Simson Garﬁnkel. Forensic feature extraction and cross-
In Proceedings of the 6th Annual Digi-
drive analysis.
tal Forensic Research Workshop (DFRWS). Lafayette, Indi-
ana, August 2006. http://www.dfrws.org/2006/
proceedings/10-Garfinkel.pdf.
[11] Guidance Software,
Inc.
EnCase Forensic, 2007.
http://www.guidancesoftware.com/
products/ef_index.asp.
[12] William Henning.
Intel
Neoseeker, September 19 2006.
view.
//www.neoseeker.com/Articles/Hardware/
Reviews/core2duo_e6600/6.html.
core 2 duo e6600 re-
http:
[13] Ken Jacobs and Keikki Tuuri.
features, and latest enhancements.
Conference 2006,
com/wp/wp-content/uploads/2007/04/
innodb-overview-mysql-uc-2006-pdf.pdf.
2006.
Innodb: Architecture,
In MySQL Users
http://www.innodb.
[14] Panagiotis Manolios.
Bloom ﬁlter calculator, 2004.
http://www.cc.gatech.edu/˜manolios/
bloom-filters/calculator.html.
[15] Michael Mitzenmacher. Compressed bloom ﬁlters. pages
144–150, 2001.
[16] James K. Mullin. A second look at bloom ﬁlters. Commun.
ACM, 26(8):570–571, 1983. ISSN 0001-0782.
1222
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:48 UTC from IEEE Xplore.  Restrictions apply.