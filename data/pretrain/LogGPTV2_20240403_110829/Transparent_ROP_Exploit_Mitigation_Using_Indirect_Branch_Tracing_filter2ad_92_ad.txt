image names when available.
5 Evaluation
In this section we present the results of our experimental
evaluation of kBouncer in terms of runtime overhead and
effectiveness against real-world ROP exploits. All exper-
iments were performed on a computer with the following
speciﬁcations: Intel i7 2600S CPU, 8GB RAM, 128GB
SSD, 64-bit Windows 7 Professional SP1.
5.1 Performance Overhead
5.1.1 Microbenchmarks
We started with some micro-benchmarks of differ-
ent parts of kBouncer’s functionality. Speciﬁcally, we
measure the average time needed for the following op-
erations, also listed in Table 3: hash table lookups
(“HashLookup”), checks for illegal returns (“Illegal-
Ret”), performing a system call (“SysNull”), reading the
contents of the LBR stack (“SysLBR”), and reading parts
of a process’ address space (“SysRead”).
In each case, we isolated the measured operation and
tried to make the experiment as realistic as possible. For
example, we extracted the hash table characteristics (do-
main size, hash table size, hit ratio) based on the dataset
shown in Table 2. The data we used for the illegal return
checks come from
, and use a worst-case
workload by treating each location in its code segment
as a possible return target. The next three experiments
where measured in kernel level, as opposed to the ﬁrst
two. We measured the time needed to perform a no-op
system call, a system call that only reads the LBR stack
contents, and ﬁnally, a system call that in addition to
reading the LBR stack, also fetches data from the sources
and targets of each branch.
Table 3 shows the results of these benchmarks. Each
benchmark runs the number of operations shown in the
second column ten times, and calculates the average and
456  22nd USENIX Security Symposium 
USENIX Association
Normal
kBouncer
)
c
e
s
(
e
m
l
i
t
n
o
i
t
e
p
m
o
c
.
g
v
A
14
12
10
8
6
4
2
0
profile
pipe mailslot
file
thread comm console sync process
Figure 10: Execution time with and without kBouncer
for Wine’s
test suite, which resulted in
the invocation of about 100K monitored Windows API
functions. The average runtime overhead is 1%.
standard deviation (next two columns). The last column
shows the average time for a single operation. As we can
see, looking up the hash table and checking for an ille-
gal return are both very fast operations, in the order of a
few nanoseconds. Performing a system call and reading
the LBR stack are relatively more expensive, but still, in
the order of a few microseconds. When attempting to
access the instructions located at the source and target
addresses of each branch record, the measured duration
starts to ﬂuctuate. We are not sure whether this behavior
is normal, or it is a result of non-optimal use of the ker-
nel API for accessing user-level memory. Overall, these
microbenchmarks show that kBouncer’s LBR stack anal-
ysis on each protected API function call takes on average
no more than 5 microseconds.
5.1.2 Runtime Overhead
Measuring the performance overhead impact on inter-
active applications, such as web browsers and docu-
ment viewers, is a challenging task.
Instead, we de-
cided to measure the performance overhead on programs
that stress the core functionality of kBouncer, by making
heavy use of the monitored Windows API functions. For
this purpose, we used a subset of the tests provided in
the test suite of Wine [15], which repeatedly call Win-
dows API functions with different arguments. To get
more conﬁdent timing results, we kept only tests that
do not interfere with external factors, such as network
communication. The ﬁnal set we used performs about
100,000 calls to Windows API functions that are pro-
tected by kBouncer, which is 20 times more than the
protected calls made by the actual applications we pre-
viously tested (listed in Table 2).
Figure 10 shows the completion time for each of the
different tests, with and without kBouncer. The average
runtime overhead is 1%, with the maximum being 4%
Table 4: Tested ROP exploits.
in the worst case. The total extra time spent across all
tests when enabling kBouncer was 0.3 sec, a result con-
sistent with the average cost of 5 µs per check based on
our microbenchmarks (100,000 calls × 5 µs = 0.5 sec).
Based on these results, which show that the performance
overhead is negligible even for workloads that continu-
ously trigger the core detection component, we believe
that kBouncer is not likely to cause any noticeable im-
pact on user experience.
5.2 Effectiveness
In the ﬁnal part of our evaluation, we tested whether
our prototype can effectively protect applications that
are typically targeted by in-the-wild attacks, using the
ROP exploits shown in Table 4. All exploits except
the ones against Internet Explorer work on the latest
and up-to-date version of Windows 7 Professional SP1
64-bit. For the IE exploits to work, we had to unin-
stall the updates that ﬁxed the relevant vulnerabilities
(KB2744842 and KB2799329). We also had to tweak the
ROP payload of the MPlayer exploit to correctly calcu-
late the offset of
for the latest version
of
, as the public version of the exploit
was based on a previous version of that DLL.
The ROP code in the exploit against Adobe Reader
), memory-maps the
v9.3.4 creates a ﬁle (
ﬁle in RWX mode (
,
), copies the shellcode in the newly mapped area,
and executes it. Similarly, the MPlayer and IE 8 ex-
ploits change the permissions of the memory region
where the shellcode resides to RWX (
)
and execute it. What is interesting about the IE 8
ROP code, is that it is constructed from the statically
loaded Skype protocol handler DLL (
).
The last two exploits in Table 4 were generated using
the Metasploit Framework [5]. For vulnerable applica-
tions that include widely used non-ASLR modules (like
Java’s
, which is loaded in Internet Ex-
plorer), Metasploit uses the same ROP payload based
on
, which has been pre-generated by
Mona [27]. This payload is similar to the one used in
the MPlayer exploit, as it also uses
to bypass Data Execution Prevention (DEP). Finally, the
Adobe Reader XI (v11.0.1) exploit is more complex,
USENIX Association  
22nd USENIX Security Symposium  457
as it is the ﬁrst in-the-wild exploit that uses ROP-only
code, i.e., it does not carry any shellcode [19]. The mali-
cious sample we tested (“Visaform Turkey.pdf”) exploits
a ﬁrst vulnerability to escape from Reader’s sandboxed
process, and a second one to hijack the execution of
its privileged process by loading a malicious DLL using
.
using
In the ﬁrst ﬁve exploits, the embedded shellcode sim-
ply invokes
. The Reader XI
exploit drops a malicious DLL. In all cases, we veriﬁed
that the exploits worked properly on our testbed, by con-
ﬁrming that the calculator was successfully launched, or,
for the Reader XI exploit, that the malicious DLL was
loaded successfully. When kBouncer was enabled, it
successfully blocked all exploits due to the identiﬁcation
of illegal returns at the time one of the
,
functions was in-
or
voked by the ROP code in each case.
6 Limitations
The Last Branch Recording feature of recent Intel pro-
cessors is what enables kBouncer to achieve its transpar-
ent and low-overhead operation. Many of our design de-
cisions are corollaries of the very limited size of the LBR
stack, which in the most recent processors holds only 16
records. Given that previous processor generations had
even more size-constrained LBR implementations, this
is deﬁnitely a signiﬁcant improvement, and hopefully fu-
ture processors will support even larger LBR stacks. This
would allow kBouncer to achieve even higher accuracy
by inspecting longer execution paths, making potential
evasion attempts even harder.
Currently, an attacker could evade kBouncer by ensur-
ing that the ﬁnal 16 executed gadgets before the invoca-
tion of an API function are considered legitimate. Specif-
ically, given that kBouncer looks for both illegal returns
and gadget chaining in parallel, this would require i) all
16 gadgets to be either
gad-
gets, and ii) at least one out of every eight of them (eight
is our current gadget chaining detection threshold) to be
longer than 20 instructions.
-preceded or non-
are
A more thorough analysis on the feasibility of con-
structing such a payload for typical applications is part of
our future work. Our preliminary evidence (Section 3.1),
however, shows that only 6.4% of all gadgets ending
with
-preceded, and this is when consid-
ering even fragmented gadgets up to 20 instructions long
(this percentage drops to 3% when considering gadgets
with at most ﬁve instructions). On the other hand, ROP
compilers like Q [60] typically take into account non-
fragmented gadgets up to ﬁve instructions long. Longer
gadgets incur more CPU state changes, which compli-
cate the (either manual or automated) gadget arrange-
Indicatively, for a similar set of appli-
ment process.
cations, even when 20% of all gadgets are available, Q
could not generate a functional payload [53]. Note that
the selection of a maximum gadget length of 20 instruc-
tions was arbitrary—four times the typically used stan-
dard seemed enough. If evasion becomes an issue, longer
gadgets could be considered during the gadget chaining
analysis of an LBR snapshot.
Alternatively, an attacker could look for a long-enough
execution path that leads to the desired API call as part
of the application’s logic. Such a path should satisfy
the following constraints: i) contain at least 16 indirect
branches, the targets of which happen to lead to the ex-
ecution of the desired API function, and ii) the executed
code along the path should not alter the state or the func-
tion arguments set by the previously executed ROP code.
Finding such a path seems quite challenging, as in many
cases the desired function might not be imported at all,
and the path should end up with the appropriate regis-
ter values and arguments to properly invoke the function.
This is even more difﬁcult in 64-bit systems, where the
ﬁrst four parameters are passed trough registers, as op-
posed to the 32-bit standard calling conventions in which
parameters are passed through the stack.
Our selection of sensitive Windows API functions was
made empirically based on a large set of different shell-
code and ROP payload implementations [5, 3, 56, 12,
27, 60]. A list of the 52 currently protected functions
is provided in the appendix. Although current ROP ex-
ploits rely mainly on only a handful of API functions
(see Sec. 5.2), we have included many others that have
been used in the past in legacy shellcode, as some ex-
ploits might implement their whole functionality using
purely ROP code (as demonstrated recently by an exploit
against the latest version of Adobe Reader XI [19]). The
set of protected functions can be easily extended with any
additional potentially sensitive functions that we might
have left out. Although it would be possible to protect
all Windows API calls, we believe that this would not
offer any additional protection beneﬁts, and would just
introduce unnecessary overhead.
7 Related Work
Address Space Randomization and Code Diversiﬁca-
tion As code-reuse attacks require precise knowledge
of the structure and location of the code to be reused,
diversifying the execution environment or even the pro-
gram code itself is a core concept in preventing code-
reuse exploits [26, 33]. Address space layout randomiza-
tion [55, 49] is probably one of the most widely deployed
countermeasures against code-reuse attacks. However,
it’s effectiveness is hindered by code segments left in
static locations [35, 75, 40], while, depending on the ran-
458  22nd USENIX Security Symposium 
USENIX Association
domization entropy, it might be possible to circumvent
it using brute-force guessing [63]. Even if all the code
segments of a process are fully randomized, vulnerabil-
ities that allow the leakage of memory contents can en-
able the calculation of the base address of a DLL at run-
time [19, 61, 44, 69, 37, 66].
Intra-DLL randomization at the function [20, 21, 42,
9], basic block [11, 10], or instruction level [53, 36, 70]
can provide protection for executables that do not sup-
port ASLR, or against de-randomization attacks through
memory leaks. The practical deployment of these tech-
niques for the protection of third-party applications de-
pends on the availability of source code [20, 21, 42, 9],
debug symbols [11, 10], or the accuracy of disassembly
and control ﬂow graph extraction [53, 36, 70, 74].
As kBouncer is completely transparent to user appli-
cations, it can complement all above randomization tech-
niques as an additional mitigation layer against ROP ex-
ploits, while it does not depend on source code, debug
symbols, or code disassembly.
Control Flow Integrity and Indirect Branch Protec-
tion The execution of ROP code disrupts the normal
call path of typical programs, resulting to an unantici-
pated ﬂow of control. Control ﬂow integrity [17] can
conﬁne program execution within the bounds of a pre-
computed proﬁle of allowed control ﬂow paths, and thus
can prevent most of the irregular control ﬂow transfers
that connect the gadgets of a ROP exploit. Depending on
program complexity, however, deriving an accurate view
of the control ﬂow graph is often challenging. Alter-
native approaches against return-oriented programming
enforce a more relaxed policy for the integrity of indi-
rect control transfers [52, 45, 22]. Using code trans-
formations, these techniques eliminate the occurrence of
unintended indirect branch instructions in the generated
code, and safeguard all legitimate indirect branches us-
ing cookies or additional levels of indirection.
The main factor that limits the practical applicabil-
ity of the above techniques is that they require the re-
compilation of the target application, which is usually
not possible for the popular proprietary applications that
are commonly targeted by ROP exploits.
In contrast,
kBouncer is completely transparent to applications and
does not require any modiﬁcation to their code.
Runtime Execution Monitoring Many defenses
against
return-oriented programming are based on
monitoring program execution at the instruction level.
A widely used mechanism for this purpose is dynamic
binary instrumentation (DBI), using frameworks such
as Pin [46]. DROP [24] and DynIMA [28] follow this
approach to monitor the frequency of
instructions,
and raise an alert in case irregularly many of them are
and
observed within a small window of executed instruc-
tions. ROPdefender [29] also uses DBI to keep a shadow
stack that is updated by instrumenting
instructions. A disruption of the expected
pairs due to ROP code is detected by comparing the
shadow stack with the system’s stack on every function
exit. A limitation of the above techniques is that they
cannot prevent exploits that use gadgets ending with
indirect
instructions. More importantly,
though, the signiﬁcant runtime overhead imposed by
the additional instrumentation instructions and the DBI
framework itself limit their practical applicability.
-
or
Similarly to kBouncer, ROPGuard [34] is based on
the observation that a ROP exploit will eventually in-
voke critical API functions, and performs various checks
before such a function is called. These include check-
ing whether
is within the proper stack boundaries,