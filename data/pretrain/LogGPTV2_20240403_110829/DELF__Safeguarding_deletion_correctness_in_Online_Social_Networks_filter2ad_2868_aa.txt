# Title: DELF: Safeguarding Deletion Correctness in Online Social Networks

## Authors
- Katriel Cohn-Gordon, Facebook
- Georgios Damaskinos, Facebook, EPFL
- Divino Neto, Facebook
- Joshi Cordova, Facebook
- Benoît Reitz, Facebook
- Benjamin Strahs, Facebook
- Daniel Obenshain, Facebook
- Paul Pearce, Facebook, Georgia Tech
- Ioannis Papagiannis, Facebook

## Abstract
Deletion is a fundamental aspect of Online Social Networks (OSNs). For users, deletion is a tool to manage their shared data and maintain control. For OSNs, robust deletion is both a user obligation and a risk when developer errors occur. While developers can identify high-level deletion requirements (e.g., users should be able to delete posted photos), they often struggle to translate these into concrete operations (e.g., deleting all relevant items in data stores). Without proper framework support, developer mistakes can lead to privacy violations, such as retaining data that should be deleted, deleting the wrong data, or creating exploitable vulnerabilities.

We introduce DELF, a deletion framework for modern OSNs. In DELF, developers specify deletion annotations on data type definitions, which the framework maps into asynchronous, reliable, and temporarily reversible operations on backing data stores. DELF validates these annotations both statically and dynamically, proactively flagging errors and suggesting fixes. We deployed DELF in three distinct OSNs, demonstrating its feasibility. DELF detected, surfaced, and helped developers correct thousands of omissions and dozens of mistakes, while also enabling timely recovery in tens of incidents where user data was inadvertently deleted.

## 1. Introduction
The ability to delete data is a core privacy expectation for users of Online Social Networks (OSNs) [1, 2]. Users rely on deletion to retract posts, avoid future conflicts, forget past experiences, remove accidental content, comply with organizational policies, and address privacy or security concerns [3–6]. Deletion empowers users to protect their privacy directly. This right is increasingly recognized worldwide [7, 8].

Providing robust deletion infrastructure is crucial for service providers. Bugs in deletion can undermine service integrity by deleting the wrong data or creating exploitable vulnerabilities. Conversely, failing to delete user data can erode trust and result in significant regulatory fines [7, 8]. These issues are common, affect numerous services, and are widely reported [9–16].

OSNs present unique challenges in identifying what to delete and when. Unlike traditional communication services (e.g., email, messaging), where data ownership is clear and limited to a user's inbox, OSNs have a complex and frequently changing data model. Billions of users interact on shared containers (e.g., profiles, groups, events, live videos, marketplace items, stories), performing various actions (e.g., commenting, sharing, retweeting, reacting, linking, painting over, buying, watching, upvoting). Deleting a shared container (e.g., a group) should delete all subcontainers (e.g., all posts and photos in the group) and recursively delete all actions for each leaf container (e.g., all reactions, shares, and upvotes of each photo), regardless of who created the data. However, deleting a subcontainer (e.g., a retweet) should not delete the original container (e.g., the original tweet), especially if this could allow malicious users to delete content they do not control. Identifying what to delete and when is challenging [3, 17, 18] and is cited as a reason for mistrust in services' deletion capabilities [19, 20].

Our insight is that both developer input and control in the deletion process should be minimized. Instead of expecting developers to handle deletions correctly, a framework should execute all deletions in an application. Centralized control of deletions allows us to provide three key features at the framework level: (a) enforcing that all developers specify how user data should be deleted before any data is collected, (b) validating developer specifications to surface mistakes early, and (c) enabling recovery of inadvertently deleted data with minimal engineering effort.

We demonstrate these ideas in DELF, a deletion framework that provides a simple declarative API to specify deletion behavior, supporting OSNs' complex data models and abstracting away heterogeneous storage infrastructure. DELF validates deletion specifications via static and dynamic analysis, helps developers correct mistakes, and executes all deletions to completion, despite transient infrastructure errors. To our knowledge, DELF is the first framework that helps developers delete data correctly at scale.

We deployed DELF at FACEBOOK, a large OSN service provider, and explored its effectiveness. Through a case study of developer actions, we measured that even when forced to specify how data should be deleted during product development—a scenario occurring about a hundred times daily—developer precision is limited to 97.6%. DELF detects most resulting mistakes with high confidence. It independently validates developer data models for deletion correctness and raises mismatches to developers for consideration. In our deployment, we observed that due to DELF's static validation, developers changed how 62.2% of the object types they create are deleted. Dynamic validation of edge types achieved 95.0% precision at 74.8% recall, indicating that DELF discovers how three-quarters of all edge types should be deleted and is correct 95% of the time. This shows that DELF can independently pinpoint most developer mistakes when annotating edge types.

In practice, DELF surfaced thousands of historical omissions and dozens of mistakes, which developers corrected. When undetected mistakes led to inadvertent data deletion, DELF enabled recovery with significantly less engineering effort.

The main contributions of this paper are:
1. A case study of developer actions at FACEBOOK, quantifying the rate of mistakes developers introduce when specifying how data should be deleted in OSNs spanning tens of thousands of data types and hundreds of millions of lines of code.
2. The design of DELF, an application-agnostic and robust framework for controlling deletion with restoration capabilities. We show how DELF simplifies and unifies the deletion process across different data store types, including relational databases, graph databases, key-value stores, and blob stores.
3. A demonstration of how DELF detects and helps developers correct common types of mistakes.
4. The deployment of DELF at FACEBOOK, where it detected thousands of omissions and dozens of mistakes, preventing privacy violations and vulnerabilities.

The rest of this paper is organized as follows. §2 introduces common types of data stores used to persist user data and outlines the deletion policy of one popular OSN service provider. §3 establishes our baseline regarding the observed frequency of developer mistakes in a large-scale codebase. §4 introduces the high-level technical design of DELF, and §5 discusses topics related to its implementation. §6 assesses the effectiveness of our system in production. We close with a discussion of related work in §7, areas for future work in §8, our conclusions in §9, and acknowledgments in §10.

## 2. Background
Modern large-scale OSNs are supported by a variety of scalable persistent data stores [21–27]. These data stores expose different data models optimized for specific application workloads. It is common for a modern OSN to leverage multiple data stores simultaneously. For example, photos and videos may be stored in a blob store, while social interactions like likes or follows may be stored in a graph database.

We refer to application-level delete operations as subgraph deletions or simply deletions, in contrast to row-level or object-level delete operations permitted by most data store APIs, which we call point deletes.

### 2.1 Data Models
Scaling relational databases to handle large numbers of reads and writes is non-trivial [24, 28]. Modern OSNs are read-heavy, and their scale requires sharding user data across thousands of servers. Even data created by a single user is sharded across multiple servers to facilitate reads. For example, all comments on a post are typically stored on the same shard as the post for faster loading. In a sharded deployment, multiple database servers follow the same schema but each stores only a subset of rows from each logical table [21, 29].

Many scalable data stores trade off advanced querying capabilities, transaction support, or consistency of the full relational data model for throughput, availability, and latency improvements with more constrained data models [23, 24, 26, 27]. Under a key-value model, data is indexed by arbitrary strings [22, 29]. Keys may be generated automatically [22] or chosen by the application [22, 29]. Values may be structured [27, 30] or unstructured [22, 25]. Under a graph model, data forms a graph [21, 31] whose main entities are objects and associations.

There are domain-specific data stores that empower specialized functionality within OSNs. Bloom filters [32] and HyperLogLog [33, 34] store aggregate hashes of input and have applications in security, abuse prevention, analytics, and performance optimization [35, 36]. Data warehouse systems [37–39] store large amounts of logs and shard based on time to facilitate daily batch processing for analytics and machine learning. In such domain-specific data stores, indexes to enable point queries may be prohibitively demanding and are often not available. Techniques to address deletion when point deletes are not feasible include storing all data with short retention, anonymization, and encryption at write time with a key that can be deleted separately [40, 41]. The rest of this paper focuses on deletion from relational, key-value, and graph data stores where indexes to perform point deletes are available.

### 2.2 Dangling Data
Dangling data refers to references to deleted objects and the corresponding objects storing such references. Dangling data can convey information about deleted objects, such as a key-value entry linking a phone number to a deleted account, or a graph association from an account to a deleted video. For correct deletion, no dangling data should remain.

Relational databases use integrity constraints [42, 43] to achieve referential integrity and identify what should be deleted once a row is deleted. With foreign key declarations and appropriate indexes, a relational database propagates point deletes for rows on the parent table to cascade and delete dangling rows in child tables. Developers control this process via referential actions on foreign key declarations, such as ON DELETE CASCADE and ON DELETE SET NULL. However, there is no guarantee that developers define either foreign keys or referential actions correctly, and no mechanism to detect omissions. Modern sharded data stores like MongoDB [44], Dynamo [29], and Redis [30] offload enforcing referential integrity to applications [45].

### 2.3 Recovery via Backups
Data store backups enable service providers to recover from hardware failures, system crashes, and application-level bugs. Typically, a full database snapshot is scheduled periodically [46], and the data store is configured to log incremental mutations [47]. To recover the data store to any point in time, a full snapshot is restored, and subsequent incremental mutations are replayed. Reverting specific deletions is impractical without additional information, as incremental mutations do not store metadata about application-level actions [48]. We illustrate these challenges in the context of a data loss incident in our case study (§3).

### 2.4 FACEBOOK
FACEBOOK is a major service provider in the social networking space, with approximately 3 billion monthly active users [49]. Its products include multiple distinct consumer OSNs, such as Facebook, Instagram, and Dating, offering a variety of features, including private and public media sharing, messaging, groups, video streaming, and a marketplace.

**Infrastructure:** In the backend, FACEBOOK products define tens of thousands of distinct data types to support external-facing features, new products under testing, and internal tools. Major data stores include TAO [21], Everstore [22], MySQL [50], and ZippyDB [26], which are a graph, blob, relational, and key-value data store, respectively. None of these data stores enforce referential integrity for references across shards and across data stores. Objects of several popular data types, such as photos, videos, and group posts, may get deleted as a result of dozens of actions.

FACEBOOK infrastructure requires developers across most products to define their data types in a structured format, at minimum exposing object types connected via edge types. Figure 1 presents an example in pseudocode of such a definition. The implementation depends on the backing data store. For example, MySQL maps an object type to a table and an edge type to a different table with columns to store the primary keys of the referenced tables; TAO maps objects and edges to objects and associations directly. A subsequent code generation step creates implementation classes with strongly-typed read, write, and delete methods for common languages used to develop applications. This intermediate abstraction layer for defining and manipulating data types is similar to object-relational mapping [51] and facilitates access control [52] and performance improvements [26].

**Deletion Policy:** FACEBOOK’s deletion policy prescribes that...