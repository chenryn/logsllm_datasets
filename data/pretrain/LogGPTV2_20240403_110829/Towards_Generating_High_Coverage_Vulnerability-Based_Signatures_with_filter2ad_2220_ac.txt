graph, the prioritization engine decides which node’s open edge to explore next; (3) for
Prioritization 
Engine
Protocol -level 
exploration graph
Node
Explorer
Field constraint 
chain
Message 
format
Decision 
Procedure
Branch 
reachability 
predicate
Input 
Generator
New Input
Fig. 4. Exploration module architecture. The darker color module is given, while the lighter color
components have been designed and implemented in this work.
Towards Generating High Coverage Vulnerability-Based Signatures
173
Start
Start
Start
Start
strcmp (
METHOD ,
"GET ") ==  0
strncmp (URI,"/
cgi-bin/",9) ==  0
URI[0] !=  /
A
T
B
T
C
T
VP
A
strcmp (
METHOD ,
"HEAD") 
== 0
A
F
D
T
B
T
C
T
VP
B
F
D
T
A
T
B
T
C
T
VP
C
F
D
T
A
T
B
T
C
T
F
E
T
F
T
strcmp (
VERSION ,
"HTTP /0.9") 
==  0
strcmp (
VERSION ,
"HTTP /1.0") 
==  0
VP
Exit
D
Start
A
T
B
T
C
T
VP
D
T
F
F
F
F
E
T
F
T
F
F
Exit
E
Fig. 5. Building the protocol-level exploration graph for our running example
the selected node’s open edge, the input generator generates a new input that will lead
the program execution to reach that node and follow the selected open edge.
The new input is then used to start another iteration of the whole process as shown
in Figure 2, that is, the new input is replayed to the program running in the execution
monitor and a new ﬁeld constraint chain is generated by the constraint extractor, which
is passed to the explorer and so on. The prioritization engine is in charge of stopping
the whole process once there are no more paths to explore or a user-speciﬁed time-limit
is reached. When the exploration stops, the explorer outputs the VPRP.
Next, we detail the 3 steps in the exploration process and how to extract the VPRP.
We illustrate the different steps using Figure 5 which represents the graph for our run-
ning example. Note that, the A–F node labels are not really part of the protocol-level
exploration graph but we add them here to make it easier to refer to the nodes.
Adding the new path to the exploration graph. To insert a new ﬁeld constraint chain
into the protocol-level exploration graph, the explorer starts merging from the top until
it ﬁnds a node that it cannot merge, either because it is not in the graph yet, or because
the successor in the new ﬁeld constraint chain is not the same one as in the graph. To
check if the node is already in the graph, the explorer checks if the node to be inserted
is equivalent (same EIP, same callstack hash, equivalent condition, and same state) to
any other node already in the graph. We call the last node that can be merged from the
top the split node.
Once a split node has been identiﬁed the explorer keeps trying to merge the rest of
the nodes in the new ﬁeld constraint chain until it ﬁnds a node that it can merge, which
we term the join node. At that point, the explorer adds all the nodes in the new ﬁeld
constraint chain between the split node and the join node as a sequence of nodes in
the graph hanging from the split node and merging at the join node. The process of
looking for a split node and then for a join node is repeated until the sink of the new
ﬁeld constraint chain is reached. At that point, if the explorer was looking for a join
node then all nodes between the last split node and the sink are added to the graph as a
sequence that hangs from the last split node and ends at the sink.
For example, in Figure 5A the graph contains only the original ﬁeld constraint chain
generated by sending the starting exploit message to the program, which contains the
174
J. Caballero et al.
three nodes introduced by lines 24, 26, and 29 in our running example (since the parsing
conditions have already been removed). The sink of the original ﬁeld constraint chain
is the vulnerability point node (VP). Figure 5B shows the second ﬁeld constraint chain
that is added to the graph, which was obtained by creating an input that traverses the
false branch of node A. When adding the ﬁeld constraint chain in Figure 5B to the graph
in Figure 5A, the explorer merges node A and determines that A is a split node because
A’s successor in the new ﬁeld constraint chain is not A’s successor in the graph. Then,
at node B the explorer ﬁnds a join node and adds node D between the split node and
the join node in the graph. Finally node C is merged and we show the updated graph in
Figure 5C.
Selecting the next node to explore. Even after removing the parsing conditions and
merging nodes, the number of paths to explore can still be large. Since we are only
interested in paths that reach the vulnerability point, we have implemented a simple
prioritization scheme that favours paths that are more likely to reach it. The prioriti-
zation engine uses a simple weight scheme, where there are three weights 0, 1, and 2.
Each weight has its own node queue and the prioritization engine always picks the ﬁrst
node from the highest weight non-empty queue. The explorer assigns the weights to the
nodes when adding them to the graph. Nodes that represent loop exit conditions get a
zero weight (i.e., lowest priority). Nodes in a ﬁeld constraint chain that has the VP as
sink get a weight of 2 (i.e., highest priority). All other nodes get a weight of 1. We favor
nodes that are in a path to the VP because if a new path does not quickly lead back to the
VP node, then the message probably failed the current check or went on to a different
task and thus it is less likely to reach VP later. We disfavor loop exit conditions to de-
lay unrolling the same loop multiple times. Such heuristic helps achieve high coverage
quickly.
Generating a new input for a new branch. We deﬁne a node reachability predicate
to be the predicate that summarizes how to reach a speciﬁc node in the protocol-level
exploration graph from the Start node, which includes all paths in the graph from the
Start to that node. Similarly, we deﬁne a branch reachability predicate to be the predi-
cate that summarizes how to traverse a speciﬁc branch of a node. A branch reachability
predicate is the conjunction of a node reachability predicate with the node’s condition
(to traverse the true branch), or the negation of the node’s condition (to traverse the false
branch). To compute a new input that traverses the speciﬁc branch selected by the pri-
oritization engine, the explorer ﬁrst computes the branch reachability predicate. Then,
the input generator creates a new input that satisﬁes the branch reachability predicate.
To compute the branch reachability predicate, the explorer ﬁrst computes the node
reachability predicate. The node reachability predicate is essentially the weakest
precondition (WP) [39] of the source node of the open edge over the protocol-level
exploration graph—by deﬁnition, the WP captures all paths in the protocol-level explo-
ration graph that reach the node. Then, the explorer computes the conjunction of the
WP with the node’s condition or with the negated condition depending on the selected
branch. Such conjunction is the branch reachability predicate, which is passed to the
input generator.
Towards Generating High Coverage Vulnerability-Based Signatures
175
Table 1. Vulnerable programs used in the evaluation
CVE
Protocol Type
Guest OS Vulnerability Type
Program
Buffer overﬂow
gdi32.dll (v3159)
Integer overﬂow
gdi32.dll (v3099)
Buffer overﬂow
Windows DCOM RPC CVE-2003-0352
Buffer overﬂow
GHttpd
AtpHttpd
Buffer overﬂow
Microsoft SQL Server CVE-2002-0649 Proprietary Binary Windows 2000 Buffer overﬂow
CVE-2008-1087 EMF ﬁle Binary Windows XP
CVE-2007-3034 WMF ﬁle Binary Windows XP
Binary Windows XP
Red Hat 7.3
Text
Text
Red Hat 7.3
RPC
CVE-2002-1904 HTTP
CVE-2002-1816 HTTP
For example, in Figure 5C if the prioritization engine selects the false branch of node
D to be explored next, then the branch reachability predicate produced by the explorer
would be: A && D. Similarly, in Figure 5D if the prioritization engine selects the false
branch of node B to be explored next, then the branch reachability predicate produced
by the explorer would be: (A||(A && D)) && B.
The input generator generates a new input that satisﬁes the branch reachability pred-
icate using a 3-step process. First, it uses a decision procedure to generate ﬁeld values
that satisfy the branch reachability predicate. If the decision procedure returns that no
input can reach that branch, then the branch is connected to the Unreachable node.
Second, it extracts the values for the remaining ﬁelds (not constrained by the decision
procedure) from the original exploit message. Third, it checks the message format pro-
vided by the parser to identify any ﬁelds that need to be updated given the dependencies
on the modiﬁed values (such as length or checksum ﬁelds). Using all the collected ﬁeld
values it generates a new input and passes it to the replay tool. We refer the reader to
our extended version [36] for our handling of ﬁeld conditions that depend on a memory
read from a symbolic address.
Extracting the vulnerability point reachability predicate. Once the exploration ends,
the protocol-level exploration graph contains all the discovered paths leading to the
vulnerability point. To extract the VPRP from the graph the explorer computes the
node reachability predicate for the VP node. For our running example, represented in
Figure 5E the VPRP is: (A||(A && D)) && C. Note that, a mere disjunction
of all paths to the VP, would generate the following VPRP: (A && B && C)||(A
&& D && B && C)||(A && B && C)||(A && D && B && C). Thus,
Elcano’s VPRP is more compact using 4 conditions instead of 14.
5 Evaluation
In this section, we present the results of our evaluation. We ﬁrst present the experiment
setup, then the constraint extractor results and ﬁnally the exploration results.
Experiment setup. We evaluate Elcano using 6 vulnerable programs, summarized in
Table 1. The table shows the program, the CVE identiﬁer for the vulnerability [21],
the protocol used by the vulnerable program, the protocol type (i.e., binary or text), the
guest operating system used to run the vulnerable program, and the type of vulnerability.
176
J. Caballero et al.
Table 2. Constraint extractor results for the
ﬁrst test, including the number of condi-
tions in the protocol-level path-predicate
and the number of remaining conditions af-
ter parsing conditions have been removed
Table 3. Exploration results,
including
whether all open edges in the protocol-level
exploration graph were explored and the
number of conditions remaining in the vul-
nerability point reachability predicate
Program Original Non-parsing
conditions
Program All branches
explored VPRP
Gdi-emf
Gdi-wmf
DCOM RPC
GHttpd
AtpHttpd
SQL Server
860
4
535
2498
6034
2447
65
4
521
5
10
7
Gdi-emf
Gdi-wmf
DCOM RPC
GHttpd
AtpHttpd
SQL Server
no
yes
no
yes
yes
yes
72
5
1651
3
10
3
We select the vulnerabilities to cover ﬁle formats as well as network protocols, multi-
ple operating systems, multiple vulnerability types, and both open-source and closed
programs, where no source code is available. In addition, the older vulnerabilities (i.e.,