个Oops的代码清单。如果我们不能把看到的地址与实际的函数名称联系起来，这一堆东西也就
没有什么用处。ksymoops工具可以为我们完成这一工作-—它还有许多其他用途。它一般存放
在你内核源代码目录下的scripts/ksymoops子目录里。在ksymoops里运行上面这个Oops，我们将
看到一些如下所示的内容：
Unable to handle kernel paging request at virtual address 01380083
current >tss.er3 + 06704000.tcr3= 06704000
*pde =00000000
0000:sdo0
CPU:
EFLAGS:00010202
&IP:
0010: []
eax:c0144000
es1: c64e9c20
edi:c5f17f84
ebx:01380083
00000000:dq
ecx: 00000005
edx:c64e8550
ds:0018es:0018 69:0018
esp: c5f17f3c
加入iaVa编程群：524621833
---
## Page 769
752
Linux程序设计
Process bash (pid: 390.process nr: 32, stackpage+e5f17000)
Stack:c5f17f84 c64e859c c64e859c fffffffe c012dfaf c64e5550 c64e9c20
c5f17f84 00000000 c60dd004 00000001 c0:2e17a c64e9620 c5f17f84
c60dd000c60dd000
c5f16000 bffff6b0 c60dd002 00000002 000006b3
Cal1 Trace:[][][][][]
c012e26c c60dd000 c64e9620
Code: 66 83 3b 00 74 4e 31 c9 8b 74 24 20 66 8b 4b 02 3b 4e 44 75
>>EIP: c0144040 
Trace: 
c012e17a 
c012dfaf 
Trace:
Trace: 
Trace:
c012c232 
7race: e3108be4 
Code:
：c0144040
c0144040 
C0000C00
Code:
:
S0x0, (tebx}
:0
66 83 3b 00
cnpw
Code:c0144044 
 c0144094 
4 :
74 4e
je
5·4
Code:c0144046 
6 :
31c9
xor1
Code:c0144048 
tecx,eecx
0x20($esp,1),$es1
8:
8b 7424 20
nov1
Code:c014404c 
0x2（ebx),8cx
c :
66 8b 4b 02
novw
Code:c0144050
0x44(8esi).decx
10 :
3b 4e 44
du
 c0144055 
Code:c0144053 
13 :
7500
jne
15
在把地址解析为函数名的时候，ksymoops需要用到当前运行内核的系统地图。内核在建立
过程中会在内核源代码子目录的根位置产生或刷新一个系统地图文件，一般情况下就是
/usr/src/linux/System.map文件。但这个文件里只能告诉我们内核在编译时都包括有哪些文件，因
为它不可能知道某个特定的模块最终会被加载到什么地方。要想知道模块化代码的具体加载位
置必须在使用insmod命令加载模块时给它加上“-m”选项。模块向外界提供的导出符号也会出
现在/proc/ksyms里。
这个Oops的函数调用追溯从system_call开始，沿途经过Oops里列出来的各个函数，最后到
达出现了错误的proc_lookup。追查法按下面的格式把沿途的函数列出来：
offset偏移量是function函数里的跳转出发点，length是这个函数的总长度。引起错误的代码
经反汇编以后显示给我们。出现在proc_lookup函数0x4c偏移量位置上的是-个对ebx寄存器进行
的字比较操作，通过查看寄存器映象我们得知出现在其中的是一个非法地址。接下来，我们需
要找出包含着这个函数的文件，看看到底是什么引起的这个问题。在我们的这个例子里，
proc_lookup函数看起来象是与proc文件系统有关，而我们也确实在fs/proc/root.c文件里找到了这
个函数。内核里的Makefile制作文件允许我们通过执行“makefs/proc/root.s”命令的办法得到一
个包含着调试信息的汇编语言清单。用一个编辑器打开roo.s文件，找到那个proc_lookup函数和
引起问题的操作，root.c文件里的行号也会出现在root.s文件里。检查结果表明，传递给
proc_lookup的dentry指针完全是失效的。
事情才刚刚开始一一你还得继续查明为什么会出现这样的事情。这也许是一个必不可少的操
作，要是这样的话，就必须加上一个指针失效与否的检查操作。但问题更有可能是出在我们正
在编写的驱动程序身上。这个Oops出现在我们对Schar里实现的proc文件系统接口进行测试的时
加入jaVa编程群：524621833
---
## Page 770
第21章设备驱动程序753
候。问题的根源终于被找到了：当有人在访问proc注册项的时候，这个模块从内核里被去掉了，
与它关联着的子目录注册项也就被释放了。因此、下一次查看这个注册项的时候，传递过来的
dentry就不再是有效的了。对Schar的修补措施是：在有人在访问它的proc注册项时增加它的模块
使用计数。问题就这样解决了。
21.8.2对模块进行调试
我们不可能象对待普通应用程序那样对内核代码采用单步执行方式进行调试，至少不能一
上来就这么做。调试你自己模块的最佳手段是在问题区域里有策略地增加一些printk语句，然后
再从头开始执行到那个地方。但要注意的是有些难以查出来的bug却会因为增加了一个简单的
printk语句而消失无踪，而原因只不过是printk语句对操作定时或数据对齐方面的细微影响。但
这仍不失为一个好办法，来看看接下去该怎么办。如果模块挂起来了，就必须查出是在哪里挂
起的，把当时的关键变量打印出来。Oops信息可以用刚才演示的技巧进行解码。此外，
kymoops会把/proc/ksyms缺省地包括进来，这就意味着它还能够对被加载模块提供给外界的各个
导出函数进行解码。我们建议大家在开发过程中把所有的函数和变量都导出来，确保ksymoops
能把它们都抓住。
21.8.3“魔术键”
最不幸事情就是遇上能够使整个系统彻底崩溃的bug们了。如果真的遇到这样的情况，人
们称之为“魔术键”的SysRq按键—也叫做“SystemAttentionKey”（SAK键，系统呼唤键）
一一就可能会帮上你很大的忙。这个使利的功能是在2.1版的开发期里添加进来的，你可以在配
置内核的时候激活这个选项。它只是解除系统完全死机现象的一个办法，不会给正常的系统操
作增加任何开销。因此，不管你是否正从事着内核的开发工作，永远要激活这项功能。同时按
下Alt、SysRq和一个命令键就可以激活不同的命令。在Documentation/sysrq.txt文件里可以查
出各种可用的命令-我们将在这里看一下“p”命令的用法。我们来按下“AltSysRqp”组
合键：
SysRq: Show Reg6
EIP:0010:[] EPLAGS:00003246
EAX:0000001f BBX:c022a000 ECX:c022a000 EDX:c0255378
ES1:c0255300 BDI:c0106000EBP:000000a0
CRO: 8005003b CR2: 4000b000 CR3: 00101000
DS: 0018 ES: 0018
这是一个处理器状态的明细表，包括各个标志和寄存器。EIP是指令寄存器，它给出的是内
核当前执行指令的位置，需要查看内核的符号图才能确定这个值所对应的地点。我们的内核与
这里给出的EIP值最接近的匹配是：
c0107c8c T cpu_idle
c0107ce4 T sys_idle
这表明我们的内核现在正在cpu_idle里执行着。如果有个模块陷在-个无限循环里了，
"SAKp”就能告诉你它到底发生在什么地方一前提是进程调度器还在运行中。系统也可能是
完全死机，真要是这样，SAK也帮不上你了。
加入jaVa编程群：524621833
---
## Page 771
754Linux程序设计
21.8.4内核调试器—KDB
使用内核调试器既可以安全地对一个运行中的内核进行调试，又能够把对正常的系统操作
的影响降低到最小程度，但要想在Intel平台上使用这个办法还必须先给内核打补丁，这是因为
该功能目前还没有被集成到内核里去一—也许将来会吧。其他一些平台也提供有类似的功能，而
且还不需要对内核打补丁。请读者自行检查自己的内核配置情况，如有必要，可以再到因特网
上搜索一番。
这个调试器可以在不同地点被启动。你可以在开机引导时向ilo传递一个“kdb”参数使调
试器尽快被启动。然后，在系统操作过程中，按下键盘上的Pause键就可以手动进人调试器；而
如果出现了一个Oops错误，调试器将自动被启动。你可以在调试器里做的事情包括：查看和修
改CPU寄存器或变量的值，单步执行、设置断点，等等。
这个补丁自带的使用手册内容充实，对它的用法做了详细的介绍，我们就不在这里多浪费
笔墨了。这个调试器很容易使用，但它与gdb的配合并不是很好，而且在功能方面与gdb相比也
要弱一些。虽然与我们期望的内建调试器相比还有·段差距，但它仍不失为一个非常方便的工
具。进人调试器，设上一个断点，然后在到达断点时让调试器自动启动一一这使我们能够在不过
多影响系统整体性能的前提下单步调试自已的模块。
21.8.5远程调试
我们在第9章里学习了gdb的使用方法，对它在普通应用程序方面的应用已经有了一定的认
识。给内核打上kdb补丁之后，运行中内核的调试工.作就完全可以利用一条申行线通过gdb来进
行，就象对待其他任何程序一样。这个方法需要使用两台计算机：一个是用来对gdb的运行情况
加以调控的主控机，另一个是被调试的受控机。两台计算机不使用调制解调器直接用电缆连接
起来，最好用Minicom或其他类似的终端程序测试一下这个连接以保证链路通畅而又可靠。
给受控机打上内核补丁之后，重新编译，再重新启动。如果我们不执行该补丁自带的一个
调试脚本，机器的运行情况与往常并没有什么不同。在内核里设上一个断点，然后启动调试脚
本，受控机将停止运行，把控制移交给主控机。gdb在主控机上的使用方法和平时一样一一用
"continue”命令恢复受控机的运行，如果用户按下“Ctrl-C”组合键或者它执行到达一个断点时
受控机的执行将再次停止。
KDB补丁还提供了串行线调试功能，可如果你真的有两台机器，还是打上kgdb补丁更好。
些。kgdb提供了通向功能更强大的gdb调试器的操作接口。是否需要选用那些高级功能就全在你
个人了。
21.8.6调试工作中的注意事项
在内核进行调试有各种各样的手段，虽然它们手法各异，但都还有一些共性。一般来说，
对断点必须特别注意。如果你使用的是一个集成性的调试器，就应该尽量避免某些键盘处理过
程里设置断点。如果是通过网络连接而进行的远程调试，在驱动程序或网络堆栈里设置断点时
也要考虑这个建议。它有可能达到目的，也有可能根本就不管用一可要是还执行了fsck命令的
加入java编程群：524621833
---
## Page 772
第21章设备盟动程序755
话，你就准备好关电源喝咖啡吧一一它几乎百分之百地会出问题！有些驱动程序对时间关系的要
求很严格，对它们进行单步调试也有可能是白费工夫。中断处理器和定时器处理器也存在这样
的间题。有些断点是不能设的，可在你明白这个道理之前也许已经在调试内核时遇上好几次死
机现象了一—要有应付系统崩漫的惠想准备。
以我们的经验看，专门用一台机器来进行测试和调试是最灵活的解决方案。而且这个解决
方案的花费也用不着很人一我们使用的就是一台老式的486机器，我们把它连接到我们的主工
作站上，通过网络来启动它，再使用NFS来挂装它的根文件系统。这台测试用机里只有一块带少
量RAM内存的主板、一块网卡、一个软盘驱动器和一块廉价的显卡。开发工作在工作站上完成，
而测试和调试工作则在这台测试用机上独立完成。如果它真的崩溃了，因为不需要检查恢复文
件系统，它只要不到半分钟的时间就能够完成重启动，面我们对源代码的编辑修改工作可以不
受影响地在工作站上进行。再加上一根串行线，对测试用机的远程调试就更有把握了。
21.9可移植性
既然编写的是设备驱动程序，自然应该能够运行在尽可能多的计算机平台上。发展到了今
天，各种计算机平台上的API其可移植性都非常好，容易引起问题的主要就是平台本身之间的差
异了。大多数可移植性方面的问题我们都在容易产生这类问题的有关章节讨论过了。这小节再
对其中的一些做进一步的探讨，同时再介绍几个新问题。
21.9.1数据类型
在本章开始的“数据类型”小节里，我们向大家介绍了_uXX和_sXX数据类型。在需要使用
特定长度尺寸的变量时，使用这些数据类型永远是个好主意，这是因为（比如说）我们不能保
证long长整数在所有的计算机平台上都有相同的长度尺寸。
21.9.2字节的存储顺序
Intel和Alpha等体系结构的计算机平台采用的是字节的降序存储方式，也就是说，最高位和
最低位的字节值在内存里是颠倒过来存放的。而同样能够运行Linux的PowerPC和SPARC体系结
构的CPU则是一些采用字节升序存储方式的平台，它们按数据原来的字节顺序存放它们。这也
是C语言看待事物的方式，人们也更熟悉这样的写法。大部分时候用不着你去关心目标机器上的
字节存储顺序，可如果你真的需要建立或者检索某个特定字节存储顺序的数据，就需要在这两
者之间进行转换。升序存储需要定义_BIG_ENDIAN_BITFIELD标志，而对降序平台则要定义
_LITTLE_ENDIAN_BITFIELD标志。有关代码要放在定义检查的中间，如下所示：
if defined(LITTLs_ENDIAN_BITPIELD)
felse
8<<x=
tendif
bytevalx&0xff;
Linux还准备了一些用来对变量的字节存储顺序进行转换的指令。这些指令涉及面很广，它
们都定义在头文件linux/byteorderlgeneric.h里。其中最常用的（至少在lntel平台上）见表21-23。
加入java编程群：524621833
---
## Page 773
756Linux程序设计
表21-23
unsigned long cpu_to_be32(unsigned ong x)
把变量x从CPU使用的字节存储顺序转换为月序
unsigned short cpu_to_bel6 unsigned short x1
存储方式
unsigned 1or.g be32_co_cpu (unsigned Long x)
把以字节的升序存储方式保存的变量x转换
unsigned short be16_bo_epu [unsigned short x1
为CPU使用的字节存储顺序
还有许多其他的函数是用来完成对16位、32位、64位变量的字节存储顺序进行转换的；它
们都可以在刚才提到的头文件里查到。
21.9.3数据的对齐
如果一个数据在内存里的存放地址能够使CPU处理器以最有效的方式对它进行访间，我们
就说这个数据是正确对齐了的。非对齐数据的访问和访问非对齐数据的后果取决于CPU处理器
的具体类型。如果计算机的体系结构允许非对齐访问，后果会是执行速度的降低：如果计算机
的体系结构不支持非对齐访问，后果将是操作失败。
get_unaligned (ptr)
访间非对齐数据。