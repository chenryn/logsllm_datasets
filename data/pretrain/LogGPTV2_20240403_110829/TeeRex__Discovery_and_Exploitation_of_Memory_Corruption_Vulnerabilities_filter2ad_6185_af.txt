periments. However, during a security analysis of an enclave,
the analyst can schedule more time and memory as needed
for speciﬁc ECALLs. Furthermore, we did not yet implement
all of the advanced techniques to improve the efﬁciency of
symbolic execution that was proposed in prior work [4, 5, 12].
This was simply not necessary to discover vulnerabilities in
our set of analyzed enclaves.
6.2 Accuracy and False Alarms
Since the analysis of TEEREX does focus on soundness rather
than on completeness, the number of false alarms is rather
small. Note that a complete false positive analysis is impos-
sible as we lack any ground-truth, i.e., all of our ﬁndings
are zero-day vulnerabilities and we are unable to provide any
comparison of TEEREX to related approaches since there does
not yet exist any other automated vulnerability discovery ap-
proach for SGX enclaves. Hence, we opted for the following
strategy: we conﬁrmed TEEREX’ alarms by constructing PoC
exploits and disclosing our ﬁndings to the affected vendors.
After the vendors ﬁxed the vulnerabilities, we manually veri-
ﬁed that the enclaves’ source code (for Intel GMP Example,
Rust SGX SDK’s tlsclient, and WolfSSL Example Enclave)
does not contain further vulnerabilities. These patched en-
claves give us a limited form of ground-truth as any ﬁnding
in the updated enclaves is a false alarm.
In our analysis of the three vulnerable enclaves TEEREX
produced 149 ﬁndings. By constructing a proof-of-concept
exploit based on the ﬁndings of TEEREX, we conﬁrm that
those ﬁndings were indeed true alarms. We selected gadgets
in shallow program paths containing the least conditions on
the initial state (i.e., constraints on the enclave’s pre-ECALL
state) and then constructed a PoC exploit based on the selected
gadgets.
Thereafter, we analyzed the patched versions of the en-
claves. TEEREX conﬁrmed that our original and exploited
ﬁndings are not longer present in the patched enclaves. How-
ever, the analysis of TEEREX still produced 56 ﬁndings. Our
root-cause analysis of those ﬁndings reveals a possible indi-
cator of a false alarm in TEEREX’ reports: global memory
is treated as unconstrained symbolic value by TEEREX (see
challenge C4 in Section 4.2). For example, the patched Intel
GMP Example utilizes an initializing ECALL which sets up
a function pointer in global memory. TEEREX discovered
that other ECALLs do not check that function pointer be-
fore use. Due to the ECALL-centric analysis of TEEREX, the
function pointer is considered unconstrained and a controlled
jump is reported. However, in reality, the function pointer
can only take ﬁxed values. Thus, this ﬁnding on its own is
not exploitable. On the other hand, in case TEEREX would
have also discovered a controlled write primitive, we still
would have been able to construct a proof-of-concept exploit.
The false positives that we encountered in the other patched
enclaves (Rust SGX SDK’s tlsclient and WolfSSL Example
Enclave) are caused by the same issue. In our future work, we
plan to annotate and ﬁlter such false alarms as low severity
based on TEEREX’ pointer-tracking component.
7 Discussion
Analyzing OCALLs. TEEREX puts its focus on ECALLs as
those are the prevalent way to pass data to enclaves. Further,
since OCALLs are only reachable through ECALLs, their
support is a precondition for OCALLs. Nevertheless, we plan
to implement OCALL-support in our future work.
Handling the OCALL interface is particularly challenging
due to the lack of semantic information. From a binary analy-
sis point-of-view, an OCALL is not easily distinguished from
a regular return from an ECALL, i.e., both utilize the EEXIT
instruction to exit the enclave. As such, TEEREX will stop
executing a program path in the enclave once an OCALL
(or EEXIT) is reached and thus will not analyze any ECALL
code beyond the ﬁrst OCALL. To overcome this limitation,
we utilize symbol information to detect OCALL invocations
in TEEREX. If TEEREX discovers that an OCALL is exe-
cuted, e.g., due to symbols and functions of the Intel SGX
SDK, then TEEREX will skip the execution of the OCALL
and set the return value of the OCALL to an unconstrained
symbolic value. This allows TEEREX to continue the analy-
sis after the OCALL with a rough over-approximation of the
OCALL’s effects since the actual semantics of the OCALL
are not emulated. We leave the development of a heuristic to
detect OCALLs on a binary-level without symbols as future
work.
Manual Effort with TEEREX. TEEREX automatically de-
tects vulnerabilities in enclaves. More speciﬁcally, TEEREX
reports the exploit primitives resulting from the vulnerabilities.
854    29th USENIX Security Symposium
USENIX Association
For instance, TEEREX will show the location of a controlled
write combined with the constraints (i.e., possible values) on
the address, value, and path that leads to the write instruction.
An analyst must then inspect the report and decide whether
the ﬁndings or any combination of ﬁndings is exploitable, or
if the alarm is a false positive. While the information reported
by TEEREX is sufﬁcient to construct PoC exploits, we plan to
incorporate exploit generation schemes as proposed in prior
work [3, 12, 29, 31] into TEEREX to automatically synthesize
a malicious host application that reproduces the crash.
Fuzzing Enclaves. Coverage-guided fuzzing is another
prominent technique to identify vulnerabilities in binary
code [71]. In contrast to symbolic execution, fuzzing scales
well to large software projects. As such, fuzzing would po-
tentially allow analysis of large and complex enclave binaries
to tackle the general problem of path explosion. On the other
hand, applying fuzzing to SGX enclaves is not straightfor-
ward: (1) To ensure efﬁciency, fuzzing requires a sophisticated
mutation strategy. However, mutation for the complex ECALL
interface requires signiﬁcant engineering effort. (2) Fuzzing
relies on dynamic analysis tools to instrument binaries [9, 46],
which are currently not available for SGX enclaves. In partic-
ular, integrating dynamic analysis tools is highly challenging
when analyzing proprietary enclave binaries. Note that the
protection mechanisms provided by SGX impede dynamic
binary instrumentation. Further, static binary instrumentation
often fails to accurately rewrite binaries. Consequently, we
decided to rely on symbolic execution as it allows us to fully
control the simulated environment. Further, it comes with ad-
ditional ﬂexibility signiﬁcantly simplifying implementation
and integration of symbolic vulnerability detectors. However,
enabling hybrid fuzzing/concolic execution in TEEREX is
worthwhile investigating for future work.
8 Related Work
The security research on privilege separation lead to system
architectures that separate user from kernel space. However,
several kernel vulnerabilities bypassed this separation sim-
ply because the kernel is not strictly separated from user
space [14, 19, 25, 26, 41]. As a response, CPU vendors intro-
duced hardware-based mitigation mechanisms, such as SMAP
or SMEP [35], to enforce stricter separation. In fact, there are
many parallels between the user/kernel space interface and
the SGX host-to-enclave interface. That is, a higher privi-
leged partition (the enclave) must carefully parse and validate
any data that is written by the untrusted partition (the host
application).
Prior work in this area introduced mechanism allowing a
user space program to reliably execute in the presence of a
compromised operating system [16, 45, 49, 54]. However,
Checkoway et al. [13] have shown that existing legacy soft-
ware cannot be simply retroﬁtted to such environments mainly
because many kernel and operating system APIs implicitly
assume that the kernel is the most trusted part of the system,
e.g., in the threat model of a traditional Unix-like system the
kernel is assumed to have full control over the code and data
areas of any user space process. As such, existing software,
such as most implementations of the C standard library, lack
any validation of data passed from the kernel. So-called Iago
attacks exploit this fact and show that a malicious kernel can
easily corrupt memory of a user space process by returning
bogus arguments from system calls. As we show in this paper,
very similar issues apply to SGX enclaves; especially when
legacy code is retroﬁtted to run inside SGX enclaves.
Hu et al. [32] showed that any software that is separated
into equally-privileged but mutually untrusted partitions can
be vulnerable to similar attacks. They presented an approach
based on taint tracking and constraint solving to detect arbi-
trary write and possible TOCTOU vulnerabilities for a limited
number of execution paths. In contrast, TEEREX utilizes full
symbolic execution to identify arbitrary write primitives. Fur-
thermore, TEEREX also discovers control-ﬂow hijacking and
NULL-pointer dereferences. TEEREX’ analysis also includes
scenarios, where the exploit depends on the global state of
the target.
Recently, Van Bulck et al. [63] presented a security analy-
sis of several TEE SDKs, whereas we focus on analyzing
enclaves. They identiﬁed vulnerabilities in TEE SDKs using
only manual code review. In contrast, we introduce an auto-
mated vulnerability detection framework for SGX enclave
binaries, which additionally assists an analyst in assessing the
vulnerability and constructing an exploit.
Many Android phones using ARM processors utilize the
TrustZone trusted execution environment (TEE) to protect
critical software. In contrast to SGX, TrustZone splits all
privilege levels into a trusted and untrusted world, where the
trusted OS has the highest privilege on the system. Machiry
et al. [47] analyzed the attack surface of the privilege bound-
ary between normal world and TEE. They identiﬁed a class
of vulnerabilities caused by to the semantic gap between nor-
mal world and TEE. They allow unprivileged, untrusted user
space applications (e.g., a sandboxed Android app) to abuse
the TEE to compromise the normal OS (the Linux kernel).
This type of vulnerability does not apply to SGX as enclaves
have little privileges and are prohibited to interact with the
OS. Harrison et al. [28] implemented a fuzzer based on full-
system emulation of the TrustZone TEE including the trusted
OS and trusted applications. The main challenge for analyz-
ing ARM-based TEEs is the fact that a custom trusted OS,
including required hardware, must be emulated. In contrast,
SGX enclaves generally lack direct hardware access. Further,
as discussed in Section 7, symbolic execution offers several
advantages over fuzzing when analyzing SGX enclaves.
USENIX Association
29th USENIX Security Symposium    855
9 Conclusion
Intel SGX is a promising security technology to strongly
isolate sensitive code and data into enclaves. However, im-
plementing the host-to-enclave boundary securely is highly
critical as the enclave processes and operates on input orig-
inating from untrusted memory space. To allow thorough
security testing of this interface, we perform a systematic
investigation on publicly available SGX enclaves. A major
contribution of this paper is to introduce an automated analy-
sis approach to determine vulnerabilities in enclaves. To do
so, our approach develops a sophisticated symbolic execution
framework that is able to analyze enclave binaries and pro-
duce detailed vulnerability reports to signiﬁcantly simplify the
construction of proof-of-concept (PoC) exploits. Our ﬁndings
on public enclaves reveal vulnerabilities in two ﬁngerprint
drivers (by Synaptics and by Goodix), three TLS libraries,
and a project published by Intel. For each, we constructed
PoC exploits to conﬁrm the severity of the vulnerability and
perform control-ﬂow hijacking allowing an attacker to subvert
any conﬁdentiality or integrity guarantees offered by the SGX
enclaves. We analyzed the root causes of the vulnerabilities
and identiﬁed vulnerability patterns that likely also affect pri-
vately deployed enclaves. Addressing our ﬁndings is crucial
to allow secure deployment of SGX enclaves.
Acknowledgment
We would like to thank the affected vendors, Intel, Baidu,
WolfSSL, Goodix, Synaptics, and the enclave developers for
promptly acting upon our reports and developing patches.
Furthermore, we especially thank our shepherd, Nathan Daut-
enhahn, for helping us to improve this work. Funded by the
Deutsche Forschungsgemeinschaft (DFG, German Research
Foundation) under Germany’s Excellence Strategy - EXC
2092 CASA - 390781972 and under SFB 1119 – 236615297.
[2]
References
[1] Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti.
“Control-ﬂow integrity principles, implementations, and applications”.
In: ACM Trans. Inf. Syst. Secur. 13.1 (2009). DOI: 10.1145/1609956.
1609960.
Pierre-Louis Aublin, Florian Kelbert, Dan O’Keeffe, Divya Muthuku-
maran, Christian Priebe, Joshua Lind, Robert Krahn, Christof Fetzer,
David Eyers, and Peter Pietzuch. TaLoS: Secure and Transparent TLS
Termination inside SGX Enclaves. en. Tech. rep. 2017/5. Imperial
College London, Mar. 2017. URL: https://www.doc.ic.ac.uk/
research/technicalreports/2017/DTRS17-5.pdf.
Thanassis Avgerinos, Sang Kil Cha, Brent Lim Tze Hao, and David
Brumley. “AEG: Automatic Exploit Generation”. In: Proceedings
of the Network and Distributed System Security Symposium, NDSS.
2011. URL: https://www.ndss-symposium.org/ndss2011/aeg-
automatic-exploit-generation.
Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David
Brumley. “Enhancing symbolic execution with veritesting”. In: Com-
mun. ACM 59.6 (2016), pp. 93–100. DOI: 10.1145/2927924.
[3]
[4]
[5] Roberto Baldoni, Emilio Coppa, Daniele Cono D’elia, Camil Deme-
trescu, and Irene Finocchi. “A Survey of Symbolic Execution Tech-
niques”. In: ACM Comput. Surv. 51.3 (May 2018). ISSN: 0360-0300.
DOI: 10.1145/3182657.
[6] Andrew Baumann, Marcus Peinado, and Galen C. Hunt. “Shielding
Applications from an Untrusted Cloud with Haven”. In: 11th USENIX
Symposium on Operating Systems Design and Implementation, OSDI.
2014. URL: https://www.usenix.org/conference/osdi14/
technical-sessions/presentation/baumann.
[7] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso Frassetto, and
Ahmad-Reza Sadeghi. “The Guard’s Dilemma: Efﬁcient Code-Reuse
Attacks Against Intel SGX”. In: 27th USENIX Security Sympo-
sium, USENIX Security. 2018. URL: https://www.usenix.org/
conference/usenixsecurity18/presentation/biondo.
[8] Robert S Boyer, Bernard Elspas, and Karl N Levitt. “SELECT—
a formal system for testing and debugging programs by symbolic
execution”. In: ACM SigPlan Notices 10.6 (1975). URL: https :
//dl.acm.org/citation.cfm?id=808445.
[9] Bryan Buck and Jeffrey K Hollingsworth. “An API for Runtime Code
Patching”. In: Int. J. High Perform. Comput. Appl. 14.4 (Nov. 2000).
ISSN: 1094-3420. DOI: 10.1177/109434200001400404.
[10] Cristian Cadar, Daniel Dunbar, and Dawson R Engler. “KLEE: Unas-
sisted and Automatic Generation of High-Coverage Tests for Com-
plex Systems Programs”. In: 8th USENIX Symposium on Operat-
ing Systems Design and Implementation, OSDI. 2008. URL: http:
//www.usenix.org/events/osdi08/tech/full%5C_papers/
cadar/cadar.pdf.
[12]
[11] Nicholas Carlini and David Wagner. “ROP is Still Dangerous:
Breaking Modern Defenses”. In: 23rd USENIX Security Sympo-
sium, USENIX Security. 2014. URL: https : / / www . usenix .
org / conference / usenixsecurity14 / technical - sessions /
presentation/carlini.
Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David
Brumley. “Unleashing Mayhem on Binary Code”. In: 2012 IEEE
Symposium on Security and Privacy. IEEE, May 2012. DOI: 10 .
1109/SP.2012.31.
Stephen Checkoway and Hovav Shacham. “Iago attacks: why the
system call API is a bad untrusted RPC interface”. In: ASPLOS.
Vol. 13. 2013. DOI: 10.1145/2499368.2451145.
[13]
[14] Haogang Chen, Yandong Mao, Xi Wang, Dong Zhou, Nickolai Zel-