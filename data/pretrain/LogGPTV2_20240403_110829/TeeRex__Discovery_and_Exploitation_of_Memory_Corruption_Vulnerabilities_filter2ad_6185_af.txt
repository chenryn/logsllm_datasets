### 6.2 Accuracy and False Alarms

TEEREX prioritizes soundness over completeness, resulting in a relatively low number of false alarms. However, a comprehensive analysis of false positives is not feasible due to the lack of ground truth. All identified vulnerabilities are zero-day, and there are no other automated vulnerability discovery tools for SGX enclaves to compare against. To address this, we confirmed TEEREX's findings by constructing proof-of-concept (PoC) exploits and disclosing them to the affected vendors. After the vendors patched the vulnerabilities, we manually verified that the updated source code (for Intel GMP Example, Rust SGX SDK’s tlsclient, and WolfSSL Example Enclave) did not contain further vulnerabilities. These patched enclaves serve as a limited form of ground truth, as any new findings in the updated enclaves would be false positives.

In our analysis of the three vulnerable enclaves, TEEREX produced 149 findings. By constructing PoC exploits based on these findings, we confirmed their validity. We selected gadgets from shallow program paths with minimal initial state constraints and then built the PoC exploits using these gadgets.

Subsequently, we analyzed the patched versions of the enclaves. TEEREX confirmed that the original and exploited findings were no longer present in the patched enclaves. However, the analysis still generated 56 findings. Our root-cause analysis revealed that global memory being treated as an unconstrained symbolic value by TEEREX (see challenge C4 in Section 4.2) was a potential indicator of false alarms. For example, the patched Intel GMP Example uses an initializing ECALL to set up a function pointer in global memory. TEEREX detected that other ECALLs did not check this function pointer before use. Due to TEEREX's ECALL-centric analysis, the function pointer was considered unconstrained, leading to a reported controlled jump. In reality, the function pointer can only take fixed values, making this finding non-exploitable. If TEEREX had also discovered a controlled write primitive, a PoC exploit could have been constructed. The false positives in the other patched enclaves (Rust SGX SDK’s tlsclient and WolfSSL Example Enclave) were caused by the same issue. In future work, we plan to annotate and filter such false alarms as low severity based on TEEREX's pointer-tracking component.

### 7 Discussion

#### Analyzing OCALLs

TEEREX focuses on ECALLs, as they are the primary means of passing data to enclaves. Since OCALLs are only reachable through ECALLs, supporting OCALLs is a prerequisite. However, we plan to implement OCALL support in future work.

Handling the OCALL interface is particularly challenging due to the lack of semantic information. From a binary analysis perspective, an OCALL is not easily distinguished from a regular return from an ECALL, as both use the EEXIT instruction to exit the enclave. Therefore, TEEREX stops executing a program path once an OCALL or EEXIT is reached, preventing the analysis of ECALL code beyond the first OCALL. To overcome this, we use symbol information to detect OCALL invocations. If TEEREX detects an OCALL, it skips its execution and sets the return value to an unconstrained symbolic value, allowing the analysis to continue with a rough over-approximation of the OCALL's effects. Developing a heuristic to detect OCALLs at the binary level without symbols is planned for future work.

#### Manual Effort with TEEREX

TEEREX automatically detects vulnerabilities in enclaves, reporting the exploit primitives resulting from these vulnerabilities. For instance, TEEREX shows the location of a controlled write, along with the constraints on the address, value, and path leading to the write instruction. An analyst must then inspect the report to determine if the findings or any combination of findings are exploitable or if the alarm is a false positive. While TEEREX provides sufficient information to construct PoC exploits, we plan to incorporate exploit generation schemes from prior work [3, 12, 29, 31] to automatically synthesize a malicious host application that reproduces the crash.

#### Fuzzing Enclaves

Coverage-guided fuzzing is another prominent technique for identifying vulnerabilities in binary code [71]. Unlike symbolic execution, fuzzing scales well to large software projects, potentially allowing the analysis of large and complex enclave binaries. However, applying fuzzing to SGX enclaves is not straightforward:

1. **Mutation Strategy**: Efficient fuzzing requires a sophisticated mutation strategy, which is challenging for the complex ECALL interface.
2. **Dynamic Analysis Tools**: Fuzzing relies on dynamic analysis tools to instrument binaries [9, 46], which are currently unavailable for SGX enclaves. The protection mechanisms provided by SGX impede dynamic binary instrumentation, and static binary instrumentation often fails to accurately rewrite binaries.

Given these challenges, we opted for symbolic execution, which allows full control over the simulated environment and offers additional flexibility for implementing and integrating symbolic vulnerability detectors. Investigating hybrid fuzzing/concolic execution in TEEREX is a worthwhile direction for future work.

### 8 Related Work

Research on privilege separation has led to system architectures that separate user and kernel space. However, several kernel vulnerabilities bypassed this separation because the kernel is not strictly separated from user space [14, 19, 25, 26, 41]. In response, CPU vendors introduced hardware-based mitigation mechanisms like SMAP and SMEP [35] to enforce stricter separation. There are many parallels between the user/kernel space interface and the SGX host-to-enclave interface, where the higher-privileged partition (the enclave) must carefully parse and validate data from the untrusted partition (the host application).

Prior work introduced mechanisms allowing user space programs to execute reliably in the presence of a compromised operating system [16, 45, 49, 54]. However, Checkoway et al. [13] showed that existing legacy software cannot be easily retrofitted to such environments, as many kernel and operating system APIs assume the kernel is the most trusted part of the system. This makes existing software, such as C standard library implementations, vulnerable to Iago attacks, where a malicious kernel corrupts user space memory by returning bogus arguments from system calls. Similar issues apply to SGX enclaves, especially when legacy code is retrofitted to run inside them.

Hu et al. [32] demonstrated that software separated into equally-privileged but mutually untrusted partitions can be vulnerable to similar attacks. They presented an approach based on taint tracking and constraint solving to detect arbitrary writes and TOCTOU vulnerabilities for a limited number of execution paths. In contrast, TEEREX uses full symbolic execution to identify arbitrary write primitives and also discovers control-flow hijacking and NULL-pointer dereferences. TEEREX's analysis includes scenarios where the exploit depends on the global state of the target.

Van Bulck et al. [63] recently presented a security analysis of several TEE SDKs, focusing on manual code review. We introduce an automated vulnerability detection framework for SGX enclave binaries, which assists analysts in assessing vulnerabilities and constructing exploits.

Many Android phones using ARM processors utilize TrustZone, a trusted execution environment (TEE) that splits all privilege levels into a trusted and untrusted world. Machiry et al. [47] analyzed the attack surface of the privilege boundary between the normal world and TEE, identifying vulnerabilities caused by the semantic gap between the two. These vulnerabilities do not apply to SGX, as enclaves have limited privileges and cannot interact with the OS. Harrison et al. [28] implemented a fuzzer based on full-system emulation of the TrustZone TEE, including the trusted OS and applications. The main challenge for analyzing ARM-based TEEs is the need to emulate a custom trusted OS and required hardware. In contrast, SGX enclaves generally lack direct hardware access, and symbolic execution offers several advantages over fuzzing for SGX enclaves, as discussed in Section 7.

### 9 Conclusion

Intel SGX is a promising security technology for strongly isolating sensitive code and data into enclaves. Securely implementing the host-to-enclave boundary is critical, as enclaves process and operate on input from untrusted memory space. To enable thorough security testing of this interface, we performed a systematic investigation of publicly available SGX enclaves. A major contribution of this paper is the introduction of an automated analysis approach to determine vulnerabilities in enclaves. Our approach develops a sophisticated symbolic execution framework that analyzes enclave binaries and produces detailed vulnerability reports, significantly simplifying the construction of PoC exploits. Our findings on public enclaves revealed vulnerabilities in two fingerprint drivers (by Synaptics and Goodix), three TLS libraries, and a project published by Intel. For each, we constructed PoC exploits to confirm the severity of the vulnerability and perform control-flow hijacking, allowing an attacker to subvert the confidentiality and integrity guarantees offered by the SGX enclaves. We analyzed the root causes of the vulnerabilities and identified patterns likely affecting privately deployed enclaves. Addressing these findings is crucial for the secure deployment of SGX enclaves.

### Acknowledgment

We thank the affected vendors, Intel, Baidu, WolfSSL, Goodix, Synaptics, and the enclave developers for promptly acting on our reports and developing patches. We also thank our shepherd, Nathan Dautenhahn, for helping us improve this work. This research was funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany’s Excellence Strategy - EXC 2092 CASA - 390781972 and under SFB 1119 – 236615297.

### References

[1] Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti. "Control-Flow Integrity Principles, Implementations, and Applications." ACM Trans. Inf. Syst. Secur. 13.1 (2009). DOI: 10.1145/1609956.1609960.

[2] Pierre-Louis Aublin, Florian Kelbert, Dan O’Keeffe, Divya Muthukumar, Christian Priebe, Joshua Lind, Robert Krahn, Christof Fetzer, David Eyers, and Peter Pietzuch. TaLoS: Secure and Transparent TLS Termination inside SGX Enclaves. Tech. rep. 2017/5. Imperial College London, Mar. 2017. URL: https://www.doc.ic.ac.uk/research/technicalreports/2017/DTRS17-5.pdf.

[3] Thanassis Avgerinos, Sang Kil Cha, Brent Lim Tze Hao, and David Brumley. "AEG: Automatic Exploit Generation." Proceedings of the Network and Distributed System Security Symposium, NDSS. 2011. URL: https://www.ndss-symposium.org/ndss2011/aeg-automatic-exploit-generation.

[4] Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David Brumley. "Enhancing Symbolic Execution with Veritesting." Commun. ACM 59.6 (2016), pp. 93–100. DOI: 10.1145/2927924.

[5] Roberto Baldoni, Emilio Coppa, Daniele Cono D’elia, Camil Demetrescu, and Irene Finocchi. "A Survey of Symbolic Execution Techniques." ACM Comput. Surv. 51.3 (May 2018). ISSN: 0360-0300. DOI: 10.1145/3182657.

[6] Andrew Baumann, Marcus Peinado, and Galen C. Hunt. "Shielding Applications from an Untrusted Cloud with Haven." 11th USENIX Symposium on Operating Systems Design and Implementation, OSDI. 2014. URL: https://www.usenix.org/conference/osdi14/technical-sessions/presentation/baumann.

[7] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso Frassetto, and Ahmad-Reza Sadeghi. "The Guard’s Dilemma: Efficient Code-Reuse Attacks Against Intel SGX." 27th USENIX Security Symposium, USENIX Security. 2018. URL: https://www.usenix.org/conference/usenixsecurity18/presentation/biondo.

[8] Robert S Boyer, Bernard Elspas, and Karl N Levitt. "SELECT—A Formal System for Testing and Debugging Programs by Symbolic Execution." ACM SigPlan Notices 10.6 (1975). URL: https://dl.acm.org/citation.cfm?id=808445.

[9] Bryan Buck and Jeffrey K Hollingsworth. "An API for Runtime Code Patching." Int. J. High Perform. Comput. Appl. 14.4 (Nov. 2000). ISSN: 1094-3420. DOI: 10.1177/109434200001400404.

[10] Cristian Cadar, Daniel Dunbar, and Dawson R Engler. "KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs." 8th USENIX Symposium on Operating Systems Design and Implementation, OSDI. 2008. URL: http://www.usenix.org/events/osdi08/tech/full_papers/cadar/cadar.pdf.

[11] Nicholas Carlini and David Wagner. "ROP is Still Dangerous: Breaking Modern Defenses." 23rd USENIX Security Symposium, USENIX Security. 2014. URL: https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/carlini.

[12] Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. "Unleashing Mayhem on Binary Code." 2012 IEEE Symposium on Security and Privacy. IEEE, May 2012. DOI: 10.1109/SP.2012.31.

[13] Stephen Checkoway and Hovav Shacham. "Iago Attacks: Why the System Call API is a Bad Untrusted RPC Interface." ASPLOS. Vol. 13. 2013. DOI: 10.1145/2499368.2451145.

[14] Haogang Chen, Yandong Mao, Xi Wang, Dong Zhou, Nickolai Zeldovich, and M. Frans Kaashoek. "Shredder: Learning to Remove Redundant Instructions from x86 Binaries." 2018 IEEE Symposium on Security and Privacy (SP). IEEE, 2018. DOI: 10.1109/SP.2018.00060.