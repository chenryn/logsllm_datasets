turing [6, 22], since they implement a large set of utilities, hence
producing a wide range of real-world different CFGs that do not
emerge in toy examples. For the benchmarks, the GNU Coreutils
9.29 have been compiled with GCC 4.9.3 targeting the x86-64 archi-
tecture, without debug symbols and dynamic linking. We evaluated
the performances of 4 optimizations levels, O0, O1, O2 and O3.
At this point, all the generated binaries have been decompiled
with all the decompilers, to generate C code. It is worth nothing that,
on the basis of the data collected during our evaluation, revng-c
is the only decompiler that produces valid C code as output. The
decompiled code generated by Hex-rays Decompiler and Ghidra
cannot be parsed as-is by a standard-conforming C parser. In order
to do this, which was a requirement to collect our evaluation metrics
on the decompiled code, we had to perform ad-hoc changes on the
decompiled sources, such as declaring missing variables and types,
correcting the number of parameters in function calls, and others.
To ensure a fair comparison, with the help of IDAPython for
the Hex-Rays Decompiler and Java scripts for Ghidra, we extracted
some information on the decompiled functions, such as their entry
point and their size. We then proceeded to compare only the func-
tions for which the three tools gave identical information about
entry point and size. Later, in Table 1, we report the percentage of
functions which matched in dimension, and that we used in our
evaluation.
There is another aspect to keep in mind about using Coreutils as
benchmarks. All these programs share a core library, called gnulib,
whose code is statically linked with all binaries. This means that the
functions in gnulib are duplicated many times. This problem has
already been pointed out in the past, by the authors of DREAM [22],
who also designed a strategy to overcome it. The idea is simple:
all the decompiled functions across all Coreutils need to be dedu-
plicated before the final comparison, to avoid overrepresenting
duplicated functions. We adopted the same strategy for the com-
parison of our results.
5.2 Evaluation of the Results
The quality of the generated code has been measured according to
the two following metrics.
gotos. The number of the emitted goto statements. goto state-
ments are very detrimental to the readability of the decompiled
code since they can arbitrarily divert the control flow, and keeping
track of the execution becomes significantly more difficult [10].
Cyclomatic Complexity. The increment in cyclomatic complex-
ity [18] of the decompiled code, using the one of the original code
as baseline. This measures the mental effort required to understand
the decompiled code.
We evaluate the code generated by the three decompilers from bi-
naries with different optimization levels according to these metrics.
The evaluation is limited to the functions that all the decompilers
were able to correctly identify. The results are reported in Table 1.
By construction, revng-c zeros out the gotos metric, generating
0 gotos, over the entire GNU Coreutils suite. We can also see how
revng-c generates decompiled code with a reduced cyclomatic
complexity with respect to the Hex-Ray Decompiler and Ghidra.
Note that the cyclomatic complexity of decompiled code of the
tools is expressed with respect to this baseline. In fact, we assume
that this complexity is intrinsic in the code, and the objective of
the decompilation is to introduce as little additional complexity as
Session 12: Software Security ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan646-O0
IDA Ghidra
+16%
1370
-O1
IDA Ghidra
+20%
2622
-O2
IDA Ghidra
+72%
2062
-O3
IDA Ghidra
+94%
2282
revng-c
revng-c
revng-c
revng-c
0
+13% +17%
2370
91%
0
+36% +60%
2082
89%
+11% +12%
1010
93%
Cyclomatic Complexity
Gotos
Matched functions
Table 1: Comparison between revng-c, IDA, and Ghidra. Results are aggregated for the optimization level that was used to obtain the binaries
that were then decompiled (-O0, -O1, -O2, -O3). For each optimization level, the first row shows percentage of functions that were matched
by all the decompilers (percentage of the binary code size). The second and third row show respectively the number of gotos produced by
each decompiler, and the additional cyclomatic complexity introduce by the decompilation process with respect to the baseline cyclomatic
complexity of the original source code.
possible. If we observe the -O2 optimization level, the one typically
adopted in release builds, we can notice that revng-c is able to
reduce the additional cyclomatic complexity by 40% with respect
to IDA, and by almost 50% with respect to Ghidra.
-O0
-O3
1.07× 1.10× 1.15× 1.32×
1.04× 1.08× 1.12× 1.25×
+78% +86%
2119
81%
0
Goto
No-Goto
-O1
-O2
0
For what concerns the metrics for the Hex-Rays Decompiler and
Ghidra, we can see that Ghidra performs slightly better in terms
of goto statements emitted, emitting less gotos when compared to
the Hex-Rays Decompiler. Overall, as previously stated, we think
that these metrics shows that the two decompilers adopt a similar
approach to decompilation.
In Table 2 we provide an overview of the increase in terms of
size of the decompiled code due to the duplication introduce by our
approach. In Figure 12 we also show an estimate of the probability
distribution function (using the KDE method) of the increase in size
for all the optimizations levels. This metric, has not been computed
for the other tools, since they do not introduce duplication.
Note also that the effects of duplication could be significantly mit-
igated by performing regular optimizations on the generated code,
such as dead code elimination. In fact, the optimizer might be able
to prove that, for instance, part of the code duplicated outside of a
loop due to the outlining of the first iteration will never be executed
and can therefore be dropped. However, due to timing constraints,
we have not been able to assess the impact of such optimizations.
We also produced a pair of heat maps Figure 13 that helps visu-
alizing how the relationship between duplication and decrement
in cyclomatic complexity evolves. We plotted the values for the
-O2 optimization level, comparing with both Hex-Rays and Ghidra.
In particular, apart from the bright spots in correspondence of a
low duplication level which are positive, we can see some reddish
clouds towards the center of the heat maps, which represents a
class of functions for which the duplication is significant, but for
which the cyclomatic complexity is reduced with respect to IDA
and Ghidra. This represent the fact that even when a cost in terms
of duplication is payed, we have a gain in terms of reduction of
cyclomatic complexity.
6 CONCLUSION
In this work we presented a novel approach to control flow restruc-
turing and to decompilation, by introducing new techniques for
transforming any given CFG into a DAG form, which we called Pre-
processing, to which we later apply our Combing algorithm. Thanks
to Combing, we are able to build a C AST from the input code,
which is then transformed by the Matching phase to emit idiomatic
C. We implemented our solution on top of the rev.ng framework,
Table 2: Size increment metrics (over the original size) for the
functions over different optimization levels. For each optimization
level, we also provide the duplication factor metric computed
only on functions which do not have goto statements in the
original source code. While our algorithm is able to completely
eliminate gotos in the decompiled code, we can see that in case we
approach decompilation of code with gotos our duplication factor
is penalized. Indeed, our algorithm makes the assumption that we
are trying to decompile well-structured code, therefore gotos in
the original source code make this assumption to fail.
Figure 12: Plot showing the Probability distribution functions of
the duplication introduced by revng-c. On the x axis, we have the
amount of duplication introduced (measured in terms of code size
increase over the original value). We can notice that as the optimiza-
tion level increases, revng-c introduces a little bit more duplication
in order to be able to be able to emit goto-free decompiled code.
building a decompiler tool called revng-c. In the evaluation, we
performed compared our results against both academic and com-
mercial state-of-the-art decompilers.
The experimental results show that our solution is able to avoid
the emission of goto statements, which is an improvement over
the Hex-Rays Decompiler and Ghidra, but at the same time does
not resorts to predicated execution, which on the other hand af-
fects DREAM. In future work, we will to improve the quality of the
decompiled code by focusing on the recovery of more idiomatic
C constructs. This type of work will be greatly simplified by the
already modular nature of the Matching phase of our algorithm.
Session 12: Software Security ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan647(a) Cyclomatic complexity improvement w.r.t. IDA
(b) Cyclomatic complexity improvement w.r.t. Ghidra
Figure 13: Cyclomatic Complexity improvements of revng-c at O2. This heat maps helps us visualizing where the cyclomatic complexity
improvement gain obtained by revng-c is introduced. The cyclomatic improvement is represented on the x axis, while the duplication
factor introduced by revng-c is represented on the y axis (higher means less duplication). To color of a cell of the heat map is computed by
performing a sum of bivariate distributions for each data point in our dataset (every function). This means that a cell will assume a brighter
color as more data points showing values of duplication and decrease in cyclomatic complexity in its surrounding are present.
[9] Alessandro Di Federico, Mathias Payer, and Giovanni Agosta.
[8] Alessandro Di Federico and Giovanni Agosta. A jump-target identification
method for multi-architecture static binary translation. In Compliers, Architec-
tures, and Sythesis of Embedded Systems (CASES), 2016 International Conference
on, 2016.
rev. ng: a
unified binary analysis framework to recover cfgs and function boundaries. In
Proceedings of the 26th International Conference on Compiler Construction, 2017.
[10] Edsger W Dijkstra. Go to statement considered harmful. Communications of
the ACM, 11(3), 1968.
[11] Alessandro Di Federico, Pietro Fezzardi, and Giovanni Agosta. rev.ng: A
multi-architecture framework for reverse engineering and vulnerability
discovery. In International Carnahan Conference on Security Technology, ICCST
2018, Montréal, Canada, October 22-25, 2018. IEEE, 2018.
[12] Ilfak Guilfanov. Decompilers and beyond. Black Hat USA, 2008.
[13] Hex-Rays. Ida pro. https://www.hex-rays.com/products/ida/.
[14] Donald E. Knuth. The Art of Computer Programming, Volume 1 (3rd Ed.):
Fundamental Algorithms. Addison Wesley Longman Publishing Co., Inc.,
Redwood City, CA, USA, 1997.
[15] Christopher Kruegel, William Robertson, Fredrik Valeur, and Giovanni Vigna.
In USENIX security Symposium,
[16] Chris Lattner and Vikram Adve. LLVM: A Compilation Framework for Lifelong
Static disassembly of obfuscated binaries.
volume 13, 2004.
Program Analysis & Transformation. In CGO 2004.
[17] Thomas Lengauer and Robert Endre Tarjan. A fast algorithm for finding
dominators in a flowgraph. ACM Transactions on Programming Languages and
Systems (TOPLAS), 1979.
[18] T. J. McCabe. A complexity measure. IEEE Transactions on Software Engineering,
SE-2(4), Dec 1976.
[19] Dawn Song, David Brumley, Heng Yin, Juan Caballero, Ivan Jager, Min Gyung
Kang, Zhenkai Liang, James Newsome, Pongsin Poosankam, and Prateek
Saxena. Bitblaze: A new approach to computer security via binary analysis. In
International Conference on Information Systems Security. Springer, 2008.
martini/Staff/yakdan/code_snippets_ndss_2015.pdf.
[20] Khaled Yakdan. Dream code snippets. https://net.cs.uni-bonn.de/fileadmin/ag/
[21] Khaled Yakdan, Sergej Dechand, Elmar Gerhards-Padilla, and Matthew Smith.
Helping johnny to analyze malware: A usability-optimized decompiler and
malware analysis user study. In 2016 IEEE Symposium on Security and Privacy
(SP). IEEE, 2016.
[22] Khaled Yakdan, Sebastian Eschweiler, Elmar Gerhards-Padilla, and Matthew
Smith. No more gotos: Decompilation using pattern-independent control-flow
structuring and semantic-preserving transformations. In NDSS, 2015.
More in general, in the future we aim to further improve the qual-
ity of the decompiled code in other areas, such as arguments and
return values detection and advanced type recognition techniques.
In addition, we are also considering the possibility for our de-
compiler to support the emission of some goto statements in a very
limited and controlled setting, i.e., where they may be considered
idiomatic and legitimate, e.g., in the goto cleanup pattern. The goal of
this would be to trade the introduction of a goto in order to further
reduce the duplication introduced by our combing algorithm.
We also want to address the verification of the semantics preser-
vation of the control flow restructuring transformation we intro-
duce. We deem this goal achievable thanks to the very nature of the
rev.ng framework. The idea is to enforce back the modifications
done by the control flow restructuring algorithm at the level of the
LLVM IR lifted by rev.ng, and to use the recompilation features
of the framework to prove the behavioural equivalence between
the original binary and the one generated after the restructuring.
REFERENCES
[1] Hex-rays decompiler. https://www.hex-rays.com/products/decompiler/.
[2] National Security Agency. Ghidra. https://ghidra-sre.org/.
[3] Fabrice Bellard. QEMU, a fast and portable dynamic translator. In Proceedings
of the FREENIX Track: 2005 USENIX Annual Technical Conference, April 10-15,
2005, Anaheim, CA, USA, 2005.
[4] David Brumley, Ivan Jager, Thanassis Avgerinos, and Edward J Schwartz. Bap:
A binary analysis platform.
In International Conference on Computer Aided
Verification. Springer, 2011.
[5] David Brumley, JongHyup Lee, Edward J Schwartz, and Maverick Woo. Native
x86 decompilation using semantics-preserving structural analysis and iterative
control-flow structuring.
In Presented as part of the 22nd USENIX Security
Symposium (USENIX Security 13), 2013.
[6] David Brumley, JongHyup Lee, Edward J. Schwartz, and Maverick Woo. Native
x86 decompilation using semantics-preserving structural analysis and iterative
control-flow structuring. In Proceedings of the 22th USENIX Security Symposium,
Washington, DC, USA, August 14-16, 2013, 2013.
[7] Cristina Cifuentes. Reverse compilation techniques. Queensland University of
Technology, Brisbane, 1994.
Session 12: Software Security ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan6481
2
5
6
4
3
1
2