# 2019年Pwn2Own上用于攻破 VMware 的虚拟机逃逸漏洞分析
##### 译文声明
本文是翻译文章，文章原作者 zerodayinitiative，文章来源：zerodayinitiative.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
在今年的温哥华Pwn2Own比赛期间，Fluoroacetate团队展示了他们通过利用VMware
Workstation从客户机虚拟机逃逸到物理机。他们利用虚拟USB 1.1 UHCI（通用主机控制器接口）中的越界读/写漏洞来达到此目的。
Fluoroacetate 通过此漏洞赢得了Pwn2Own温哥华的Pwn Smrter大奖，总奖金为340,000美元，还得到了一个全新的Tesla
Model
3。他们为VMware编写了两个漏洞利用程序，都是针对通用主机控制器接口（UHCI）的。第一个是基于堆的溢出，另一个是一个条件竞争漏洞。这两个漏洞都需要guest虚拟机操作系统上的Admin权限才能利用成功。
在这篇分析中，我将介绍基于堆的缓冲区溢出漏洞，这是我最喜欢的Pwn2Own漏洞之一。
###  漏洞描述
在处理发送到批量端点的特定UHCI请求时存在一个堆溢出漏洞，这些端点主要用于传输大量数据，这个漏洞也可用于触发一个越界写。
首先，当端点接收到用于处理的帧时，它会从相应的帧中提取传输描述符（TD），检查是否存在URB对象。如果不存在对象，则通过名为“NewUrb”的函数分配新的URB对象。
URB对象简述：英特尔UHCI规范提到的URB对象是USB中的一个请求块，研究发现，从`NewUrb`函数返回的对象是一个围绕有效规范USB请求块（URB）的包装器结构。检查TD的类型以及缓冲区大小后，如果TD类型是0xE1（USB_PID_OUT），那么TD缓冲区被复制到从中返回的对象内的缓冲区`NewUrb`函数。如果TD对象的类型不是0xE1，则它会传递缓冲区指针（在代码中引用`purb_data_cursor`）。
触发漏洞并不难，只要创建一个TD对象，在token属性中设置正确的长度以及`0x1E/USB_PID_OUT`类型就可以触发。
可以参阅下面的PoC代码：
WinDbg附加的崩溃结果显示，已经控制了程序流程：
上面的崩溃现场是一个基于堆的缓冲区溢出漏洞。但是，如果想要达到越界写，那么必须创建更多不同类型的TD，这对于利用此漏洞至关重要。之后再创建另一个类型为USB_PID_OUT的TD对象来触发写入。
###  漏洞分析
为了允许VMware客户计算机访问USB设备，VMware会安装guest虚拟机中指定的内核设备驱动程序`uhci_hcd`，“hcd”代表“主机控制器驱动程序”。此驱动程序允许guest虚拟机与主机端的主机控制器接口（HCI）进行通信，主机端是主机用于与物理USB端口通信的硬件接口。通过向USB设备定义的各种端点发送或接收USB请求块（URB）分组来完成通信。USB设备的每个端点用于接收来自主机（OUT）的数据包，或者将数据包发送到主机（IN）。通过将特制的OUT数据包发送到称为批量端点的特定端点来触发此漏洞。
由`uhci_hcd`驱动程序处理的数据包由`uhci_td`（传输描述符）结构在内存中表示如下：
该`token`字段包含不可见的某些位对齐子字段，最低的8位表示“分组ID”，它定义了分组的类型。前10位是一个名为MaxLen的长度字段。
要触发此漏洞，guest虚拟机必须发送精心构造的TD结构，将Packet
ID设置为OUT（0xE1）。此外，由`MaxLen`子字段指示的TD的缓冲区长度必须大于0x40字节才能溢出堆上的对象。通过将windbg附加到vmware-vmx.exe并触发漏洞，会收到以下漏洞崩溃场景：
回溯调用堆栈显示了一系列处理UHCI请求的函数：
`memcpy`崩溃进程的调用是在从TD的缓冲区复制数据的过程中发生的：
这是`memcpy`从TD缓冲区复制到堆中的内容：
让我们看看目标缓冲区大小是多少：
缓冲区的大小为0x58，因为`vmware-vmx`分配了[number_of_TD_structures]
_0x40+0x18大小的目标缓冲区。现在只发送了一个TD结构，缓冲区大小是`1_ 0x40+0x18=0x58`字节。
在这个`memcpy`调用中，我们可以精确地确定要复制的字节数。为此，我们将`MaxLen`OUT
TD的`token`字段（从21位到31位）中的子字段设置为所需的`memcpy`大小减1。
现在就可以溢出堆布局了，除了溢出堆之外还能利用此漏洞执行其他越界写。调用函数`NewURB()`（位于`vmware_vmx+0x165710`）以处理传入的URB数据包。每次函数`NewURB()`接收TD时，它都会将TD的`MaxLen`值添加到cursor
变量中。cursor 变量指向函数接收TD结构时应该写入的位置，以这种方式，该`MaxLen`字段可用于在处理后续TD时控制目的地址。
###  漏洞利用
为了利用此漏洞，必须进行`vmware-vmx`进程堆的布局。漏洞利用主要依赖于客户端上的SVGA3D协议，它用于通过SVGA
FIFO与主机通信。在后端VMware使用DX11Renderer组件处理请求。漏洞利用代码从初始化阶段开始，初始化SVGA
FIFO内存，然后分配SVGA3D对象表。
利用该漏洞可以尝试创建未分配内存块，每个都具有0x158字节的大小。这正是将一定数量的TD与缓冲区头一起分配所需的大小。TD可能会在其中一个漏洞内分配，在每个漏洞之后，漏洞利用尝试放置一个称为“资源容器”的0x150字节结构表示数据。
漏洞利用代码使用以下步骤准备堆内存：  
定义并绑定大小为0x5000的Context内存对象。  
定义SPRAY_OBJ大小为0x1000 的内存对象（），利用漏洞重复绑定结构。  
定义大小为0x158的2400个着色器，将它们绑定到SPRAY_OBJ。之后，该漏洞利用代码用于SVGA_3D_CMD_SET_SHADER在主机中。  
执行以下操作：  
—-取消分配每个偶数编号的容器。  