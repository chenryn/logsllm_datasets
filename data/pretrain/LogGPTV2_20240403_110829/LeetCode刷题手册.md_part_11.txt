5
Go
5
Medium
Medium
Medium
Medium
Medium
Medium 
Medium
Medium
Medium
Medium
Medium
Easy
Easy
Easy
Easy
Easy
Easy
Easy
Easy
Easy
Easy
Easy
Easy
Hard
Hard 
Hard 
Easy
(u)o
(u)o
O(n)
O(n)
O(n)
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
O(n)
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
0(1)
0(1)
0(1)
(u)o
0(1)
0(1)
(u)o
(u)o
0(1)
0(1)
0(1)
0(1)
0(1)
0(1)
0(1)
0(1)
0(1)
0(1)
0(1)
0(1)
0(1
(u)o
0(1)
0(1)
0(1)
(u)o
0(1)
---
## Page 57
Union Find
Sample 
992. Subarrays with K Different 
 977. Squares of a Sorted Array
 930. Binary Subarrays With Sum 
 925. Long Pressed Name 
 923. 3Sum With Multiplicity
904. Fruit Into Baskets 
881. Boats to Save People
845. Longest Mountain in Array
 844. Backspace String Compare 
838. Push Dominoes 
 828. Unique Letter String 
 826. Most Profit Asigning Work
1093. Statistics from a Large
1004. Max Consecutive Ones Ill
Integers 
986. Interval List Intersections
5
G
Go
5
5
15
5
5
15
5
5
5
5
 Medium
Medium
Medium 
Medium
Medium
Medium
Medium
 Medium
 Medium
Easy
Medium 
Hard 
Easy
Easy
Hard 
 O(n log n) 
O(n log n) 
 O(n log n)
O(n~2)
(u)o
(u) 
(u)o
(u)o
(u)o
(u)o
(u)o
(u)o
O(n)
(u)o
(u)o
0(1)
0(1)
O(n)
0(1)
0(1)
O(n)
0(1)
(u)o
0(1)
0(1)
0(1)
(u)o
O(n)
0(1)
O(n)
---
## Page 58
●
●
有些题死套模板反而做不出来，比如第 685题，这一题不能路径压缩和秩优化，因为题目中涉及
的用 int 节点编号实现的。
stringUnionFind，利用并查集思想实现的。这里每个节点是基于字符串和 map 的，而不是单纯
并查集是一种思想，有些题需要灵活使用这种思想，而不是死套模板，如第399 题，这一题是
题。第 803 题秩优化和统计集合个数这些地方会卡时间，如果不优化，会TLE。
缩+秩优化的版本，另外一种是计算每个集合中元素的个数+最大集合元素个数的版本，这两种
灵活使用并查集的思想，熟练掌握并查集的模板，模板中有两种并查集的实现方式，一种是路径压
 LeetCode  Explore 
题
版本都有各自使用的地方。能使用第一类并查集模板的题目有：第128 题，第130题，第 547
第952题，第959题，
Show problem tags
You have solved 18/26 problems.
Subscribe to see which companies asked this question
 Union Find 
?
839
6.8
3
1
#
豆
1  Lexicographiclly Smallest Equivalent String   
 Connecting Cities With Minimum Cost 
 Satisfiabity of Equality Equations
 Largest Component Size by Common Facto
Most Stones Removed with Same Row or Column
Minimize Malware Spread ll 
 Bricks Falling When Hit
Number of Islands
 Surounded Regions
Longest Consecutive Sequence
Path With Maximum Minimum Value
The Earliest Moment When Everyone Becc
Regions Cut By Slashes
Minimize Malware Spread 
Similar String Groups
Swim in Rising Water
Couples Holding Hands
Redundant Connection ll
Redundant Connection 
Friend Circles
Number of Connected Components in an Undirected Graph 
Number of Islands Il   
Graph Valid Tre
Title
Sentence Similarty  
Accounts Merge
Evaluate Division
Problems
MocKew
第990题。能使用第二类并查集模板的题目有：第803题，第952
D
come Friends
Discuss
Stol
Help Center | Jobs | Bug Bounty 丨 Tems | Privacy Policy 
51.4%
43.9%
64.0%
62.7%
40.9%
62.6%
26.7%
54.4%
39.4%
40.5%
35.3%
29.2%
48.6%
52.1%
43.9%
41.9%
31.1%
52.8%
54.6%
48.3%
52.7%
41.4%
40.3%
42.5%
23.7%
42.4%
Acceptance
Medlum
Modlum
Medlum
Medlum
Medium
0
Medlum
Medium
Hard
Difficulty Frequency 
，第947
---
## Page 59
990. Satisfiability of Equality
959. Regions Cut By Slashes
952. Largest Component Size by
928. Minimize Malware Spread Il 
 924. Minimize Malware Spread 
 839. Similar String Groups 
 803. Bricks Falling When Hit 
Same Row or Column
947. Most Stones Removed with
778. Swim in Rising Water
765. Couples Holding Hands 
721. Accounts Merge
685. Redundant Connection Il
684. Redundant Connection 
547. Friend Circles 
399. Evaluate Division
200. Number of Islands 
130. Surrounded Regions 
128. Longest Consecutive
·能用并查集的题目，一般也可以用 DFS 和 BFS 解答，只不过时间复杂度会高一点。
Equations
Common Factor
Sequence
Title
这个特殊节点上。第130题，第803题。
关于地图，砖块，网格的题目
度，如第721题，第959题。
灵活的抽象题目给的信息，将给定的信息合理的编号，使用并查集解题，并用 map 降低时间复杂
缩和秩优化。
到有向图，需要知道节点的前驱节点，如果路径压缩了，这一题就没法做了。这一题不需要路径压
，可以新建一
Solution
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
G
一个特殊节点，将四周边缘的砖块或者网格都union() 到
Difficulty
Medium
Medium
Medium
Medium
Medium
Medium
Medium
Medium
Medium
Hard 
Hard 
Hard 
Hard
Hard
Hard
Hard
Hard
Hard 
(UW)o
O(m*n)
O(n~2)
O(n^2)
O(n~2)
O(n~2)
O(n^2)
O(n)
(uxW)o
(uxW)o
O(n)
(u)o
(u)o
Time
O(n)
(u)o
(u)o
(u)o
(u)o
O(n^2)
O(m*n)
O(m*n)
O(n)
O(n)
O(n)
Space
O(n)
(u)o
O(n)
(u)o
O(n)
(u)o
O(n)
O(n)
O(n)
(u)o
(u)o
(u)o
1
---
人
藏
收
---
## Page 60
线段树Segment Tree
这一章会罗列一些整理好的模板。一起来看看吧。
第三章一些模板
make([]int, 4*]en(nums)) 
func (st *SegmentTree) Init(nums []int, oper func(i, j int) int) {
// Init define 
type SegmentTree struct {
// SegmentTree define
package template
for i := O; i0{ 
st.data, st.tree, st.lazy = data, tree, lazy
st.merge = oper 
merge 
left,right 
data, tree, lazy []int
 data[i] = nums[i] 