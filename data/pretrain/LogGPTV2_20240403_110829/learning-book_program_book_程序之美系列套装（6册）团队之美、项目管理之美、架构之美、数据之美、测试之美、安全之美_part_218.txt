当定义一个新的食谱时，如果要完成糖量的计算，无需任何其他工
作。
当然，我们真实的目标不是布丁而是金融契约。在该幻灯片中提供
了该方法的梗概，在其文章中则做了更加详细的介绍。它采用了相
同的观点，应用到了更为有趣的元素、合成方式和操作的集合。
元素可以是金融契约、日期和可观测量（如特定日期的特定汇
率）。在基本契约示例中，包含0个（可以在任何时候获取，没有
权利与义务约束）或1个（c）针对货币c（立即支付给债务人一个
单位的c）的契约。
针对这种契约的合成方式包括：or，如获取契约（orclc2），表示
获取cl或者c2，只有它们都过期，契约才过期；anytime，如
（anytimec），表示可以在c的过期之前的任意时间获取，只要c过
期该契约就过期；truncate，如（truncatetc），表示除非c的过期时
间比t早，否则将其过期时间提前到t；get，如（getc），表示在其
过期日获取c。在该文章中，列出了一打这样的基本合成方式，还
有一些可观测量和日期。通过它们可以定义出更高级的金融指令，
如"欧式期权”可以表示为：
european t u=get (truncate t (or u zero))
在一个操作中，包括契约的过期日期（这是所有建模努力所预期获
得的最终的、重要的、具有实际意义的好处）和其值处理过程，以
及一个按时间排列的预期值序列。与布丁中的糖量类似，在其案例
分析中，该函数的定义是基于相同基本构造的。在以下的例子中，
是一个包含前面的基本元素和合成逻辑的H操作，它用来表示过期
日期函数，或者“范围”：
H（zero）=-预期属性的一个特殊值
H (or c1 c2) =max (H(c1)， H(c2)
H (anytime c) =H (c)
H (truncate t c) =min (t,H (c)
1230
---
## Page 1232
H (get c) =H (c)
在值处理过程所遵循的规则中，采用了类似的结构，虽然右边的内
容相对比较复杂难懂，涉及许多金融及数学计算。
[L]布丁是一种以面粉、牛奶、鸡蛋等为基料的糊状甜食；括号中
列出的是不同口味的布丁，依次是屈莱弗甜食、柠檬布丁、荷兰苹
果蛋糕、圣诞布丁。
[2]即米、千克等国际通用的度量单位体系。
13.3函数式解决方案的模块性评价
在先前的介绍中，虽然忽略了该幻灯片和该文章中的许多观点，但
对于讨论函数式方法的架构特性，以及将它们和OO视图进行比
较，这些已经足够了。在后续的内容中，我们将会自由地使用“布
）（实）
应用程序的视角）。
13.3.1可扩展性标准
正如前面的介绍中所说的那样，这种方法对于架构所产生的最直接
的好处就是添加新的合成方式很简单：“当需要定义一个新的食谱
时，无需更多的工作就能够完成糖量的计算”。不过，这只不过是
使用函数式编程方法必然带来的效果之一。合成方式这一概念背后
的本质是基于基本成分来创建布丁及布丁原料，或者金融契约，这
些基本成分要么是原子性的，要么是应用合成方式所生成的成分。
该文章和幻灯片看起来像是针对金融契约问题的新思路，但实际上
它也适用于其他问题。我们转到GUI设计领域，如果采用在该幻灯
片之初否决的“坏方法”（列出所有布丁的类型，然后分别计算其糖
量等），那么将需要以特定的方式，逐一生成能够执行显示、移
动、大小调整、隐藏等操作的交互式应用程序界面。当然没有人会
这样做；所有GUI设计环境都提供了一些原子性元素，如按钮、菜
单项，而通过操作将它们递归式地组合成窗口、菜单以及其他容器
元素，最终生成完整的用户界面。这就像布丁的合成方式定义了糖
量、根据其成分计算卡路里值，金融契约的合成方式则按照复杂契
药的要素定义了其范围和值序列一样，对组件的显示、移动、调整
大小、隐藏等操作将针对组件中的所有成分递归执行。EiffelVision
1231
---
## Page 1233
程序库（Eiffel软件：EifelVision文档）就以一种特殊的系统化途径
应用了这些成分，不过这种方法十分独特。它当然并不仅限于函数
式编程；任何带有子程序和递归机制的框架都能够实现它。
在与模块性相关的问题中，最有趣的并不是在将原有合成方式应用
到原有类型的成分时出现的问题，而是当合成方式和成分类型发生
改变时遇到的问题。该幻灯片明确指出，“只有当我们需要添加新
的合成方式或新的成分时，才需要增强S”（针对合成方式sugar）。
大家所感兴趣的问题是，接下来如何在架构中适应这些变化。
相关的变化实际上比其提到的更多：
不管是原子类型还是合成方式，我们都认为变化在操作中：为“布
了"应用程序添加卡路里计算函数，为“金融契约"应用程序添加“延
期"操作，为图形化对象添加翻转操作。
除了添加各种操作之外，还要考虑到可能修改和删除操作。为了保
持简单，我们只考虑添加新操作的情况。
13.3.2函数式方法的评价
其提供的程序结构很简单，是由一组定义构成的，定义的格式要么
形如（Arnout，2004）：
O (a) =b a, 0
要么形如（Arnout和Meyer，2006）：
O (c (x, y. ….) =f c, O (x, y， ….)
对于任何操作O，原子类型a以及合成方式c，右边都是由适当的常
量b和函数组成的。同样，为了保持简单，我们将诸如a之类的原子
类型视为O-元合成方式，因此我们只需考虑第二种格式。对于合成
方式t（on_top_of、hipped等）和操作f（糖量、卡路里等），我们需
要定义txf。不管采用什么方法，tμf元素都必须提供。其架构性问题
是如何将它们组织到模块中，以便对其进行扩展和复用。在该幻灯
1232
---
## Page 1234
片和文章中都没有对这个问题进行讨论。当然，对于小型的和f而
信这并不是问题；我们可以将所有的定义都封装到一个独立的模块
中。这是一种考虑可扩展性的简单方法：
添加一个合成逻辑c，并以上述格式在其中添加一个定义，它是针
对现有的所有操作的。
添加一个操作0，并在其中添加一个定义，它是针对现有的所有合
成方式的。
这种方法的可伸缩性不好，对于较大型的并发项目而言，必然需要
将该系统分拆到不同模块中。现在的扩展性问题就将变成了如何使
这样的修改影响的模块尽可能少。
即使t和都很小，这种单模块的解决方案是无法实现复用的。如果
其他程序只需要一部分操作和合成方式，那么就必将面临模块化技
术中经常遇到的两难选择：
Charybdis I!l
复制-粘贴相关的部分，但这样做也有一些风险，当原始内容发生改
变时（可能是修复一个缺陷），派生模块是无法做相应更新的。
Scylla [21
引用整个模块，使用模块中一部分可用功能，最终担负起不必要的
包袱，它会使更新工作更加麻烦，更容易产生冲突（例如，当派生
模块定义了一个新的合成方式或函数，而原模块的最新版本也定义
了与之重名的合成方式或函数）。
这些观测结果让我想起可复用性和可扩展性之间存在着紧密的联
系。关于函数式编程语言OCaml（Steingold2007）[31-的在线评论
中，有一个具体的例子：
在模块之外，很难对模块中的行为进行修改。假设使用了Time模块
中定义的Time.date_of_string函数—用来解析ISO8601基本格式
（“YYYYMMDD"），但如果还想能够识别ISO8601扩展格式
（“YYYY-MM-DD"）。那么很不幸，只能让该模块的开发人员来
修改这个函数，无法在自己的模块中重新定义该函数。
1233
---
## Page 1235
随着软件的发展和变化，另一方面的可复用性将变得十分关键，那
就是对公共属性的复用。该文章在介绍“欧式期权”合成方式的同时
还介绍了“美式期权"的合成方式，它们的函数签名是不同的（分别
是Data-Contract—Contract和（Date,Date）→Contract—Contract），
对于它们而言，所有的操作都必须分别定义。不过，这样做经常被
置疑，因为这两种期权中有许多属性和操作是相同的，同样，不同
的布丁也可以分成几种类型。这样的分类，对软件的模块化是有帮
助的，同时还带来了额外的好处（如果相同的内容比较多），那就
是定义中所需的内容将大大减少，要比txf沙得多。不过，这需要我
们花些时间来研究问题域，不仅仅是从函数角度，而是从类型的角
度。这样的视图是位于更高抽象等级上的。在实践中，其中最容易
引发争论的是函数及其签名的确定。根据该文章的说明，“美式期
权要比欧式期权更加灵活。通常，美式期权授予的权利是在两个日
期之间的任何时候行权，也可以不这样做。”这会让我们想起该定
义的一个变体：要么美式期权是欧式期权的一种变体，要么它们都
是某种通用期权的变体。不过，如果我们采用合成方式来定义它
们，会马上让它们显得完全不同，因为在签名中将引入额外的日期
值。同样，这也是一种基于具体实现来定义某一概念的方法，不管
它采用的是数学计算实现还是计算机实现，这仍然意味着该解决方
案缺乏抽象度和通用性。使用类型作为基本的模块化机制（正如面
向对象设计中那样）将会提升抽象的等级。
[1]西西里海岸附近墨西里海峡的一个漩涡，被拟人化为一个吞噬
船只的海怪（希腊神话中的六头女妖）。
[2].锡拉巨岩，正好位于著名大漩涡Charybdis对面。因此在英文中
经常用"betweenScyllaandCharybdis"来表示进退维谷、进退两难、
腹背受敌之意。
3]此处引用做了些删节。并且这也不意味着作者认同该评论中的
其他观点。
13.3.3模块性等级
将模块性作为评价函数式编程的标准之一是合理的，因为该方法所
宣扬的主要优点就是提供了更好的模块性。我们在该幻灯片中看到
了原作者对这个问题的说明，下面是来源于一篇针对函数式编程
的、更为基础的论文（Hughes1989）中所提到的更通用的描述，它
对该方法的描述是：
1234
---
## Page 1236
[程序]可以通过新方法进行模块化和简化。函数式编程的主要价值
就是大大改进了程序的模块化程度。采用函数式编程的程序员也必
须努力确保程序使用更小、更简单、更通用的模块，并使用新的粘
合剂（我们稍后就将介绍）将它们整合在一起。
在Hughes的论文中所提到的“新的粘合剂”，实际上就是我们在前面
两个示例中所使用的方法之一，即无状态函数的系统化应用，包括
高抽象层次的函数（合成生成），它们将对其他函数产生作用。此
外，还有大量使用的列表、其他递归定义的类型，以及延迟计算
(lazyevaluation，[ll.）等概念。
虽然这很吸引人，不过这些技术仍主要致力于提供更为精细的模块
化。Hughes用函数式编程方法开发了一个平方根计算程序，采用的
是牛顿选代法，它将计算数字N的平方根，公差为eps，初始近似值
为a0：
sqrt a0 eps N=within eps (repeat (next N) a0)
在此除了使用了within、repeat、next等合成方式之外，作者还将该
程序与使用了大量goto语句的FORTRAN程序版本进行了比较。即使
我们不考虑这一价值不大的改进（在该论文最初发表时，
FORTRAN语言已经略显过时，而且goto语句也已经被弃用了），大
家也能理解为什么我们会喜欢这样的解决方案，它完全是基于一些
通过合成因子粘合在一起的小型函数实现的，而不是使用循环结
构。不过也有人更喜欢循环结构，但我们认为结构良好的程序要比
大规模模块化更为重要，这比基础性架构问题更麻烦。在实践中，
所展示问题的正确性实际上对于任何方法而言都是相同的。例如，
在Hughes的论文中定义的函数里，序列中第一个元素和前一例子并
不相同，它处理的是当值小于eps时的情况：