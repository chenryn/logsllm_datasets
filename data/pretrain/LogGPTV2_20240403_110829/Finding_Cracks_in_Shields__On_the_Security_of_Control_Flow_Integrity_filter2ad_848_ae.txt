### 优化后的文本

#### CFI机制评估与常见问题总结

在对多种CFI（Control-Flow Integrity）机制进行评估后，我们总结了7个常见的设计缺陷和实现漏洞。这些缺陷和漏洞可能导致实际应用中的安全威胁。我们将这些问题按照开发周期组织起来，以期缩小理论安全与实际安全之间的差距。

##### 7.1 不精确的分析

CFI机制依赖于静态或动态分析提供的信息来减少允许的目标集。随着编译器将源代码逐步降低为机器码，信息会逐渐丢失。二进制级别的CFI机制由于可用信息较少，因此容易出现不精确的问题；但如果源代码级别的CFI机制实现不当，也可能无法充分利用丰富的语义。

**LockDown:**
- **理论模型：** LockDown允许向前跳转到导入函数以支持跨DSO（Dynamic Shared Object）转移，并且可以调用外部回调函数。它通过识别一组候选回调函数来减少误报。
- **实际问题：** 实际上，LockDown错误地标记了许多函数为候选回调函数，从而引入了意外目标。此外，LockDown的真实边界不仅包括所有函数入口，还包括所有已执行过的可执行地址（即指针常量），这进一步引入了意外目标。

**MCFI:**
- **类型检查：** MCFI根据结构等价规则进行类型检查，但这种做法可能会引入意外目标。例如，在gobmk中，`gtp_aa_confirm_safety`函数和musl libc中的静态子函数被归为同一等价类，尽管它们的参数类型不同（分别为`char *`和`void *`）。

**πCFI:**
- **基于IR的设计：** πCFI基于MCFI构建，同样存在类似问题。由于其在IR（Intermediate Representation）级别进行插桩而不是源代码级别，导致间接控制转移的类型信息丢失。虽然这种设计简化了实现，但降低了精度。

**µCFI:**
- **监测过程：** µCFI需要另一个监控进程，且不符合我们的测试工具要求，因此未使用CScan进行测试。但我们使用CBench测试套件对其进行了评估。
- **结果：** 如表2所示，µCFI在检测指针覆盖攻击方面具有很高的精度，并能识别许多ICT指令的唯一目标。然而，它无法防御代码指针重用和VTable重用攻击。
  - **代码指针重用攻击：** 我们展示了越界攻击的场景。假设有一个包含两个不同类型函数指针数组的结构，在运行时从第一个数组中检索一个函数指针并间接调用。如果此操作被对手篡改，将导致越界内存访问，从而检索到错误的指针。有两种情况：
    1. 访问仍在结构内，第二个数组中的另一个函数指针将被调用，而µCFI未能检测到这种情况。
    2. 访问超出结构范围，任何函数指针都可能被调用。但µCFI报告第三种状态（空）而没有报告攻击。根本原因是分析数据收集不精确：µCFI的分析依赖于运行时信息，但无法区分合法和恶意的数据。
  - **VTable重用攻击：** 如果派生类对象被释放，稍后再次调用其虚函数，对手可以通过覆盖已释放对象的VTable指针来执行基类中的虚函数。由于点对分析的不准确，µCFI也未能检测到这种攻击。

#### 示例代码片段

以下是一个MCFI/πCFI中的示例gadget：

```assembly
1   push rax
2   pop rax
3   pop rcx
4   mov ecx, ecx
5   mov rdi, QWORD PTR gs:0x14240
6   mov rsi, QWORD PTR gs:[rcx]
7   cmp rsi, rdi
8   jne 0x400559
9   jmp rcx
# 目标地址
# 比较
# 跳转到目标
# BaryID
# TaryID
```

通过上述优化，文本变得更加清晰、连贯和专业，便于读者理解各种CFI机制及其存在的问题。