×
—
—
×
×
⋒
⋒
—
—
⋒
⋒
—
—
⋒
⋒
—
—
binCFI
⊕ ⊗ ⊙
⊕ ⊗ ⊙
⊕ ⊗ ⊙
×
×
⊕ ⊗ ⊙
⊕ ⊗ ⊙
N/A
⊗ 4○
×
×
⊕ ⊗ ⊙
∗
∗
∗
∗
∗
—
⊕ ⊙
⊕ ⊙
⊕ ⊙
×
×
⊕ ⊙
⊕ ⊙
N/A
✓
×
×
⊕ ⊙
⋄
⋄
∆
⋒
✓
×
∆
∆
✓
✓
✓
∆
∆
N/A
—
✓
✓
×
—
—
—
—
—
—
∆
✓
✓
πCFI CFI-LB OS-CFI
1○
⋆
✓
2○
2○
1○
⋆
✓
∆

÷
÷
×
×
N/A
—

×
×
—
—
—
—
—
—
✓
÷
÷
×
×
N/A
—
×
×
×
—
—
—
—
—
—
µCFI
PARTS
CBench Testsuite
✓
×
∗
✓
3○
✓
×
N/A
✓
×
×
×
—
—
—
—
—
—
✓
∆
—
—
—
✓
∆
N/A
✓
×
—
×
—
—
—
—
—
—
Code Pointer
VTable Reuse
Tail Call
Overwrite
Reuse
VTable Injection
COOP
UAF
Overwrite
Reuse
setjmp/longjmp
Return Address Overwrite
Function Type Confusion
Object Type Confusion
Indirect Call/Jump
Code Pointer Overwrite/Reuse
Object Injection/Reuse
Callback
Code Pointer Overwrite/Reuse
Object Injection/Reuse
Return Address Overwrite
Code Pointer Overwrite
⋆
⋆
✓
2○
2○
⋆
⋆
✓
✓
✓
✓
×
⋒
⋒
⋒
⋒
⋒
—
✓
✓
✓
×
⋒
⋒
⋒
⋒
⋒
—
∆
∆
✓
✓
✓
∆
∆
N/A
—
✓
✓
×
∆
✓
∆
✓
—
—
✓: Success Protection, ∆: Targets of the same type, ⋆: Targets of the same structural type,÷: all virtual function of the same type ⊕: Function entries, ⊗: Callsites, ⊙: Immediate
value used in assignment instruction, ⋄: Imported symbols only, ⋒: Same as Non-dso protection ×: Failed to protect, —: Unsupported, N/A: Target unavailable, : Compilation failed.
∗: Crashed at runtime
1○: Part of all function entries of the same structural type are feasible targets. 2○: Successfully hijacked the control flow to all virtual function entries of the same type, but available
syscalls are limited. 3○: If the member variable is initialized in the base class, then in the VTable reuse attack that exploits the UAF vulnerability, the hijacked ICT only allows
jumping to the base class instead of the same class. 4○: Function entry instructions after call exit() are feasible targets.
ICT instructions in vDSO, since these instructions are introduced
by the system and cannot be instrumented by any CFI mechanism.
7 Pitfalls
We further summarize 7 common pitfalls by studying the root
causes of both the design flaws and implementation bugs. Noting
that both types of issues cause security threats in practical appli-
cations, we use the development lifetime to organize them. We
hope the organization can help to bridge the gap between practical
security and claimed security.
7.1 Imprecise Analysis
CFI mechanisms rely on information provided by static or dy-
namic analysis to trim down the set of allowed targets. As the
compiler gradually lowers the source code to machine code in mul-
tiple passes, information gradually get lost. By design, binary-level
CFI mechanisms have less information to utilize; however, if imple-
mented inappropriately, source-level CFI mechanisms also fail to
maximize rich semantics.
LockDown: In the theoretical model, LockDown allows forward
ICT instructions to jump to imported functions to support Cross-
DSO transfers. Furthermore, ICT instructions may call external
callback functions. LockDown is designed to resolve callbacks to
reduce false positives. Specifically, it first identifies a set of candidate
callback functions, and skips security checks if the target function
is in this set or performs the CFI check otherwise. However, it
wrongly marks many functions as candidate callbacks, and thus
introduces unintended targets.
In addition, we found that the real boundary of each ICT instruc-
tion of LockDown contains not only all function entries but also all
executable addresses that have been taken (i.e., pointer constants),
introducing unintended targets as well.
MCFI MCFI performs type checking following the structural equiv-
alence rule, which will introduce unintended targets. For example,
MCFI considers the function gtp_aa_confirm_safety in gobmk
and the static child function in musl libc as the same equivalent
class. However, the parameter type of gtp_aa_confirm_safety is
char *, and the parameter type of child is void *.
πCFI: πCFI is built based on MCFI, and has similar problems. As
the instrumentation works on IR instead of source code, the type
information of indirect control transfers gets lost. This IR-level
design simplifies implementation, but reduces the precision.
µCFI: Since µCFI needs another monitoring process and does not
meet the requirements of our testing tools, we did not test it with
CScan. But we have evaluated it with our test suite CBench. As
shown in Table 2, µCFI has very high precision in detecting pointer
overwrite attacks, and can identify the unique target for many ICT
instructions. However, it fails to defeat the code pointer reuse and
VTable reuse attacks.
In the code pointer reuse attack scenario, we demonstrated an
out-of-bounds attack. Assume there is a structure consisting of two
arrays of function pointers (of different types), at runtime a func-
tion pointer is retrieved from the first array and invoked indirectly.
If the pointer retrieval operation is tampered by the adversary, an
out-of-bound memory access is yielded and a wrong pointer will
be retrieved. There are two cases. First, the access is still in the
structure, and another function pointer in the second array will be
invoked, and µCFI fails to detect it. Second, the access is outside the
structure, then any function pointer could be invoked. However,
instead of reporting succeed and failed, µCFI reports a third state
(empty) without reporting an attack. The root cause is imprecise
analysis data collection: µCFI’s analysis relies on runtime informa-
tion (constraining data), but it cannot differentiate legitimate vs
malicious ones.
In the VTable reuse attack scenario, if an object of a derived
class is freed and later one of its virtual functions is invoked again,
the adversary could override the freed object’s VTable pointer and
execute the virtual function defined in the base class. µCFI also fails
to detect this attack due to the inaccuracy in the point-to analysis.
Session 6B: Exploitation and Defenses CCS '20, November 9–13, 2020, Virtual Event, USA18301 push
2 pop
3 pop
4 mov
5 mov
6 mov
7 cmp
8 jne
9 jmp
# Target address
rax
rax
rcx
ecx , ecx
rdi , QWORD PTR gs :0 x14240
rsi , QWORD PTR gs :[ rcx ]
rsi , rdi
0 x400559 
rcx
# Compare
# Transfer to target
# BaryID
# TaryID
Listing 1: An example gadget in MCFI/π CFI.