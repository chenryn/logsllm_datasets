used repeatedly.
To model asymmetric keys, we use fresh (unique) terms
as long-term private keys (here: ~ltkA) and use an abstract
one-way function pk that yields the corresponding public
key.
veriﬁcation. The action OnlyOne ensures that each domain
can only be registered once at the ILS. The state fact ILS-
toAdd stores the list of new ARCerts that must be added.
The message MSG1 that is sent out is a macro that expands to
contain the relevant parts of the registration request RegReq
and is signed by the ILS.
rule A_Receive_SignedCerts:
rule ILS_Reg_ILS:
let contactCA = $CA1 in
[ DomainCombineARCertA($A, CertA, $CA1, $CA2) ,
In() , In()]
[ In() , !Ltk($ILSk, ~ltkK)
, !Ltk($CA1, ~ltkCAx1) , !Ltk($CA2, ~ltkCAx2)
, ILStoAdd(~ltkK, $ILSk, AddList) ]
--[ NotEq(~ltkCAx1, ~ltkCAx2)
, ReceivedCASignedARCert($A,~ltkA) ]->
[ DomainHasARCertA($A, contactCA, ARCertA) ]
--[ OnlyOne() ]->
[ Out()
, ILStoAdd(~ltkK, $ILSk, AddList + ARCertA) ]
We use the action NotEq(x,y) to specify that the rule can
only be triggered for two diﬀerent CAs. This concludes the
ARCert generation as described at the top of Figure 4.
We next describe the remaining message ﬂows for the
domain registering the new ARCert and the creation of the
registration conﬁrmation by CA1, CA2, and ILS, ignoring
the ILS synchronization as that is not part of our model.
In Figure 4 these message ﬂows are given by Steps 1–2 and
Steps 7–9. Each such step is a message exchange between
two parties, the sender and receiver. In the following step the
previous receiver becomes the sender of the next message. As
each rule is written from the point of view of one participant,
we simply combine the receiving of one message and the
sending of the next message into a single rule.
First, rule ILS_REG_A1 models sending the message from
Step 1. Note that the presence of private keys does not mean
that the participant actually knows the long-term private
keys of CA1 or CA2, but rather that it can check that the
correct signatures are used for those. The OnlyOne action
guarantees that for each ARCert, represented by its key
~ltkA, this registration will only be started once by an honest
participant. The state fact DomainHasARCertA connects this
rule with the previous one (initial generation) and the ﬁnal
rule which receives the fully signed ARCert. Note that the
message being sent, represented as RegReq, hides much of
the complexity of generating and checking the content of
messages.
rule ILS_Reg_A1:
let ILSlist = $ILSk in
[ DomainHasARCertA($A, $CA1, ARCertA)
, !Ltk($A, ~ltkA), !Ltk($CA1, ~ltkCAx1)
, !Ltk($CA2, ~ltkCAx2) ]
--[ OnlyOne() ]->
[ Out(),
DomainHasARCertA($A, $CA1, ARCertA) ]
The rule ILS_REG_CA1_FORWARD models receiving the mes-
sage from Step 1 and sending the message of Step 2. Note
that CA1 matches the contact CA in the ARCert. CA1 keeps
state of the received message in ContactCAStateILSReg and
does additional checks later.
rule ILS_Reg_CA1_Forward:
[ In() ] --[ ]->
[ Out()
, ContactCAStateILSReg($A, $CA1, RegReq) ]
Next, rule ILS_REG_ILS receives the message from Step 2
and sends the message of Step 7 as an ILS. The two CAs are
bound inside the message that is received and the private
keys of CA1 and CA2 are again exclusively used for signature
The rule ILS_REG_CA2 receives the message of Step 7 and
sends the message of Step 8. Again, the private keys of ILS
and CA1 are used only for signature veriﬁcation. CA2 here
must take responsibility to only allow the registration of a
domain once. The message MSG1 is as described previously,
and MOK1 is an extension that is signed by CA2.
rule ILS_Reg_CA2:
[ In(), !Ltk($CA2, ~ltkCAx2)
, !Ltk($ILSk, ~ltkK), !Ltk($CA1, ~ltkCAx1) ]
--[ OnlyOne() ]->
[ Out() ]
The rule ILS_REG_CA1 receives the message of Step 8 and
sends the message for Step 9. Again, the private keys of
ILS and CA2 are used only for signature veriﬁcation. Here,
CA1 ensures that the domain is only registered once. The
message sent out, MOK2, again extends MOK1 with a signature,
and is the proof of registration that will be used later by the
domain.
rule ILS_Reg_CA1:
[ In(), !Ltk($CA1, ~ltkCAx1)
, !Ltk($ILSk, ~ltkK), !Ltk($CA2, ~ltkCAx2)
, ContactCAStateILSReg($A, $CA1, RegReq) ]
--[ OnlyOne()
, AcceptedARCert($A, ~ltkA) ]->
[ Out() ]
Finally, the rule ILS_REG_A2 receives the MOK2 message
of Step 9, i.e., as the registering domain. Here, the private
keys of both CAs and the ILS are used just for signature
veriﬁcation. The domain also checks that the two CAs and
the ILS are distinct entities using NotEq.
rule ILS_Reg_A2:
[ DomainHasARCertA($A, $CA1, ARCertA)
, !Ltk($CA1, ~ltkCAx1), !Ltk($CA2, ~ltkCAx2)
, !Ltk($ILSk, ~ltkK), In() ]
--[ HasARCertNoLog($A, ~ltkA, ARCertANotVerified)
, NotEq(~ltkCAx1, ~ltkCAx2) , NotEq(~ltkCAx1, ~ltkK)
, NotEq(~ltkCAx2, ~ltkK)
, ReceivedARCert($A, ~ltkA) ]->
[ Out( ARCertANotVerified )
, StoredARCertA($A, ARCertA, ARCertANotVerified) ]
The state fact StoredARCertA is used to store the ARCert
that will subsequently be used by the domain for all connec-
tion requests.
5.4 Adversary Model
By default, Tamarin’s adversary model assumes that the
adversary has full network control. All messages sent using
Out(m) facts in the right hand side of rules are added to
lemma main_prop:
"( All cid a b reason oldkey key #i1 #i2 #i3 #i4 .
( GEN_LTK(a,oldkey,’trusted’) @i1
& AskedForARCert(a,oldkey) @i2
& ReceivedARCert(a,oldkey) @i3
// ’Honest’ agent
// domain has asked for a ARCert with this exact key
// domain has confirmation that its ARCert with this
//
exact key has been processed.
& ConnectionAccepted(cid,b,a,reason,key) @i4 // browser accepted connection, based on private key
//
’key’ in for domain a.
& i3 
( (not (Ex #j. K(key) @j)) )
) "
// adversary cannot know that private key
Figure 7: Main security property proven
the adversary’s knowledge, and any message that can be
constructed from this knowledge can be used to trigger an
In(m) fact in the left hand side of a rule. Thus, the adversary
can eavesdrop, modify, and insert messages.
Additionally we assume that the adversary can compromise
ILSes and CAs. For the main security property, we assume
that the adversary has compromised at most two such entities.
It is clear that for any design, if the adversary can compromise
all involved entities (here: two CAs, one ILS) that the browser
trusts, he can convince the browser that a certiﬁcate is good.
We model this by adding rules that enable the adversary to
register public keys that are later designated as a CA or an
ILS. A compromised ILS will then sign any integrity tree
represented as a list as usual.
5.5 Analysis Guarantees
Proof goal. Whenever (i) a domain A has been registered
initially by an honest party with an ARCert; and (ii) a
browser later accepts a connection to domain A with some
ARCert (which may have been updated and hence diﬀer from
the original ARCert), then the adversary does not know the
private key for that ARCert.
We require that the adversary does not know the private
key for the ARCert to model that the browser communicates
with the right domain, because for a bogus certiﬁcate the
adversary would know the private key. The part (i) makes
explicit the assumption that until a domain has had an
ARCert issued using ARPKI, anyone can register that domain
themselves, including the adversary, as long as they can fool
(or have compromised) two CAs.
We analyze this proof goal twice: once for at most two
compromised entities, and once for three or more compro-
mised entities. The formula that encodes this property in
Tamarin is shown in Figure 7 and takes the form of an
implication. The formula starts with a quantiﬁcation over
variables (cid, a, b, . . .): for all values of those variables there
should be a GEN_LTK(...) action in the trace at position i1
(#i1 denotes a variable i1 of type ‘timepoint’). In our model,
this action can only be produced by a particular rule that
generates initially trusted keys. If a domain A has initially
received an ARPKI certiﬁcate using a non-compromised pri-
vate key, and the browser accepted a connection for that
domain for any key pair (uniquely determined by the private
key key), then the implication holds if the adversary does
not know the private key key (encoded by K(key)).
This is precisely the connection integrity property from
Section 3. As we will show next, it holds for ARPKI whenever
up to two entities are compromised, and can be broken only
with three or more compromised entities.
Analysis. Using Tamarin, we ﬁnd the expected attack
for the case of three or more compromised CAs and ILSes.
An adversary that, for example, controls two CAs as well as
one ILS can create an ARCert for any domain. But, when
at most two entities are compromised, Tamarin veriﬁes the
lemma. This guarantees that no attack with less than three
compromised parties is possible.
We ran our experiments on a PC with an Intel Xeon CPU
(2.60GHz) with 16 cores and 32 GB of RAM with Ubuntu
14.04 64bit as the operating system. The proof runtime with
at most two compromised entities was 78 minutes, and the
runtime for ﬁnding the attack with three or more compro-
mised entities was 52 minutes. We had to develop extensions
and provided hints to Tamarin as indicated in Section 5.2.
We estimate the overall veriﬁcation eﬀort at several person
months.
5.6 Co-design
We developed our formal speciﬁcation of ARPKI in tandem
with its implementation, working from a single evolving
design document. As a result, the speciﬁcation and the
implementation are tightly linked, signiﬁcantly reducing the
possibility of modeling errors.
Tamarin played a critical role during the development in
helping us make all details of the protocol design precise and
in uncovering missing details. During development, we found
a number of attacks on early designs, even when limited
to two compromised parties. For example, in one case, we
discovered that checks done on the browser side, to protect
against a party signing more than once, were missing during
certiﬁcate creation, where the domain owner did not perform
these checks. The missing checks were then added to the
model, the speciﬁcation document, and the implementation.
Once the formal model had stabilized, further issues found
in failed proof attempts were quickly communicated and
ﬁxed on all sides.
6.
IMPLEMENTATION
In this section we describe our proof-of-concept implemen-
tation of ARPKI and assess its performance. Our proto-
type provides all the features required for deployment. In
particular, we implemented the following parts: (a) the
communication ﬂows and processing logic for the message
exchanges presented in Section 4, (b) the ILS process with
the fully implemented Integrity Tree, and the capability to
publish the information required for its consistency checks,
(c) the validator process, which monitors the ILSes and pub-
lishes misbehaviors, (d) the CA process that includes the
validator’s role with the additional ability to produce on-line
conﬁrmations, (e) the client process, i.e., a browser extended
with support for full ARCert validation, (f ) the protocol for
accountable synchronization, and (g) the domain tool, which
can register, update, revoke, recover, and conﬁrm ARCerts.
6.1
Implementation Choices
We implement the ARCert certiﬁcates using a concate-
nation of standard X.509 certiﬁcates, where we used X.509
extensions [8] to introduce ARPKI-related ﬁelds such as
CA_LIST, ILS_LIST, ILS_TIMEOUT, and CA_MIN.
The implementation of all processes is written in C++.
We use OpenSSL (version 1.0.1) APIs for all cryptographic
operations, and use the JavaScript Object Notation (JSON)
and Base64 encoding for request and response messages. We
implement the Integrity Tree using SHA-512 as the hash
function, and use RSA-2048 as the signature algorithm.
Entities are implemented in a modular manner, where
every module provides its own API. The communications
module, which receives and serves requests, is implemented
using a multi-threaded work queue with TCP sockets. The
Integrity Tree is implemented as a separate database module,
while the publishing module is realized by a local HTTP
server. The ILS publishes all accepted requests and the root
hash at each update time. This module also allows every
entity to publish detected misbehaviors.
We implement the ARPKI TLS server by extending the
Nginx HTTP server (version 1.5.7). We conﬁgure the TLS
server to periodically interact with ARPKI’s infrastructure
to provide fresh conﬁrmations to the browser. After at most
every ILS_TIMEOUT (expected to be a few hours), the server
sends a request CCReq and receives fresh conﬁrmations, i.e.,
either Proof or Accept. The received conﬁrmations are
validated and saved for future HTTPS connections.
We implement the client by extending the Chromium
web browser and we deploy our system without signiﬁcant
changes to the server code and TLS protocol. During the
client-server connection, the server’s ARCert is sent within
the handshake’s Server Certiﬁcate message while conﬁrma-
tions are provided to the browser using the existing Online
Certiﬁcate Status Protocol Stapling extension. This architec-
ture includes the ARCert validation process from Section 4,
so the browser veriﬁes the ARCert and the signatures of the
received conﬁrmation. The browser additionally veriﬁes the
consistency of the ARCert and the conﬁrmation.
6.2 Performance Evaluation
We analyzed the performance of our prototype imple-
mentation in a real-world scenario. We set up a testbed
that included all entities: the ILS, CAs, validators, ARPKI-
supporting server, and browser. We ran our tests on a PC
with an Intel i5-3470 (3.20GHz) CPU and 16GB of RAM
with Ubuntu 12.04 64bit as the operating system. On this
machine we ran three virtual machines, acting as CA1, CA2,
and ILS1, respectively.
First we investigated how long it takes for the infras-
tructure to process three requests initiated by the domain:
RegReq, UpdateReq, and CCReq. Note that these ac-
tions are infrequently performed by our infrastructure for any
given domain. RegReq is sent once, while UpdateReq is,
in general, envisioned to be sent annually. The most common
request is CCReq, which is sent roughly every ILS_TIMEOUT.
Measurements are given as the average over 1000 test runs,
and the results are presented in Table 1. The total processing
time is calculated from the time that the domain sends the
Table 1: Total processing time (in milliseconds) re-
quired for the given request by the given entity.
Request