难易程度（主要取决于威胁的类型和系统特征）以及实现威胁的可能性（取决于是否存在适
当的对策）来定义。 
步骤 3:确定对策和缓解措施。 
缺乏针对威胁的保护可能表示存在漏洞，通过实施对策可以减轻该漏洞的风险。可以使
用威胁-反措施映射列表来识别此类对策。一旦为威胁分配了风险等级，就可以将威胁从最
59 
高风险到最低风险进行排序，并确定缓解工作的优先级，例如通过应用已识别的对策来响应
此类威胁。 
风险缓解策略可能涉及从这些威胁带来的业务影响来评估它们，并建立对策(或设计变
更)来降低风险。 
其他选择可能包括接受风险、假设由于补偿控制而使业务影响可以接受、通知用户威胁、
完全消除威胁带来的风险，或者最不可取的选择，即什么也不做。如果确定的风险是极端的，
则功能或产品可能会停产，因为发生问题的风险大于收益。 
对策识别的目的是确定是否有某种保护措施(例如，安全控制、策略措施),可以防止之前
通过威胁分析识别的每个威胁被发现。漏洞就是那些没有对策的威胁。 
由于这些威胁中的每一个都已经用 STRIDE 或 ASF 进行了分类，因此可以在给定类别
的应用程序中找到适当的对策。上述每个步骤在执行时都有记录。生成的文档集是应用程序
的威胁模型。附录 B 给出了如何进行威胁建模的详细示例。 
威胁概况 
一旦识别出威胁和相应的对策，就可以根据以下标准得出威胁概况: 
60 
2.2.10 指标和代码审计 
度量标准衡量一段代码的大小和复杂性。审计代码时可以考虑一长串质量和安全特征
(例如，但不限于，正确性、效率、可移植性、可维护性、可靠性和安全性)。没有两个代码
的审计会议是相同的，所以需要一些判断来决定最佳路径。度量可以帮助决定代码审计的规
模。 
度量还可以记录与代码审计者的性能和审计过程的准确性、代码审计功能的性能以及代
码审计功能的效率和有效性。 
图 5 描述了整个代码审计过程中度量的使用。计算审阅任务大小的一些选项包括: 
代码行 
可执行代码行的计数(不计算注释掉的代码或空行)。这给出了一个粗略的估计，但不是
特别科学。 
功能点 
通过测量功能来估计软件的规模。执行特定任务的若干语句的组合，独立于所用的编程
语言或开发方法。在面向对象的语言中，类可以是一个功能点。 
缺陷密度 
每代码行编程错误的平均发生率。这给出了代码质量的高级视图，但仅此而已。故障密
度本身不会产生实用的度量标准。缺陷密度将涵盖代码中的次要问题和主要安全缺陷，所有
61 
人都受到同样的评估。仅使用缺陷密度无法准确判断代码的安全性。 
风险密度 
与缺陷密度相似，但发现的问题按风险(高、中、低)进行评级。通过这样做，我们可以
通过内部应用程序开发政策和标准定义的[X 风险/ LoC]或[Y 风险/功能点]值(X 和 Y 是高、
中或低风险)来洞察正在开发的代码的质量。 
例如: 
每 1000 个高风险缺陷(代码行) 
每 3 个功能点有 2 个中等风险缺陷 
62 
圈复杂度(CC): 
一种静态分析度量，用于帮助建立对代码项的风险和稳定性评估，例如一个类、方法甚
至一个完整的系统。它是由托马斯·麦凯布在 70 年代定义的，易于计算和应用，因此非常有
用。 
63 
McCabe 圈复杂度度量标准旨在表示程序的可测试性、可理解性和可维护性。这是通
过测量控制流结构来实现的，以便预测理解、测试、维护等方面的困难。一旦理解了控制流
结构，就可以了解程序可能包含缺陷的程度。圈复杂度度量旨在独立于语言和语言格式，用
于测量通过程序模块的线性独立路径的数量。这也是应该测试的最小路径数。 
通过了解产品的圈复杂度，人们可以关注具有最高复杂度的模块。这很可能是数据将采
取的路径之一，从而能够将一个路径引导到潜在的漏洞高风险位置。复杂性越高，出现更多
bug 的可能性就越大。bug 越多，出现更多安全漏洞的概率就越高。 
圈复杂度是否揭示了安全风险？在对模块的安全状况进行审计之前，人们不会知道。圈
复杂度度量提供了一种基于风险的方法：从哪里开始审计和分析代码。保护应用程序是一项
复杂的任务，在许多方面，复杂性是安全性的敌人，因为软件复杂性会使软件错误难以检测。
随着产品的更新或维护，软件的复杂性会随着时间的推移而增加。 
圈复杂度可以计算为: 
CC =决策数+1 
…其中决策将被认为是命令，即执行通过 if/else、switch、case、catch、while、do、
模板类调用等的分支。 
随着决策数量的增加，复杂性和路径数量也会增加。复杂的代码导致稳定性和可维护性
降低。 
代码越复杂，缺陷的风险就越高。公司可以为模块建立圈复杂度阈值: 
⚫ 
0-10:稳定的代码，可接受的复杂性 
64 
⚫ 
11-15:中等风险，更复杂 
⚫ 
16-20:高风险代码，一个代码单元的决策太多。 
圈复杂度非常高的模块极其复杂，可以重构为更小的方法。 
错误修复概率: 
这是在试图修复以前的错误时意外插入程序的错误概率，一些公司也称之为回归。 
⚫ 
圈复杂度:1–10 = =错误修复概率:5% 
⚫ 
圈复杂度:20–30 = =错误修复概率:20% 
⚫ 
圈复杂度:> 50 ==错误修复概率:40% 
⚫ 
圈复杂度:接近 100 ==错误修复概率:60% 
随着软件复杂性的增加，引入新错误的可能性也在增加。 
检验率: 
这个度量可以用来大致了解执行代码审计所需的持续时间。审计率是代码审计者每单位
时间可以覆盖的覆盖率。例如，每小时 250 行的速率可以作为基线。这个比率不应该作为
评估质量的一部分，而只是用来确定任务的持续时间。 
缺陷检测率: 
65 
该度量标准衡量单位时间内发现的缺陷。同样，可以用来衡量代码审计团队的性能，但
不能用作质量度量。缺陷检测率通常会随着审计率(以上)的降低而增加。 
复验缺陷率: 
在重新审计代码时，更多的缺陷存在，一些缺陷仍然存在，或者其他缺陷通过试图解决
以前发现的缺陷(回归)而显现的速度。 
2.2.11 爬行代码 
爬行代码是扫描审计目标和接口入口点的代码库的实践，寻找可能存在安全漏洞的关键
代码指针。某些应用编程接口与面向外部世界或文件输入输出或用户管理相关，这是攻击者
关注的关键领域。在爬行代码中，我们寻找与这些领域相关的应用编程接口。我们还需要寻
找可能导致安全问题的业务逻辑领域，但通常这些是定制的方法，它们有定制的名称，不能
被直接检测到。尽管我们可能会触及某些方法，因为它们与某个关键的应用编程接口有关系。 
我们还需要寻找与特定语言相关的共同问题，可能与安全无关，但在特殊情况下可能影
响应用程序稳定性/可用性的问题。执行代码审计时的其他问题是为了保护个人知识产权而
发布简单的版权声明。一般来说，这些问题应该是公司编码指南(或标准)的一部分，并且应
该在代码审计期间强制执行。例如，审计者可以拒绝代码审计，因为代码违反了编码指南中
的某些内容，而不管代码是否在其当前状态下工作。 
抓取代码可以手动完成，也可以使用自动化工具以自动化方式完成。然而，手动工作可
能并不有效，因为(如下所示)有很多指标可以应用于一种语言。可以使用 grep 或 wingrep
66 
这样简单的工具。其他工具可以搜索与特定编程语言相关的关键字。如果一个团队正在使用
一个特定的审计工具，该工具允许它指定要在审计中突出显示的字符串(例如。基于 Python
的审计工具使用 pygments 语法高度轻量级，或者团队可以更改源代码的内部工具)，然后
他们可以从下面的列表中添加相关的字符串指示器，并自动向审计者突出显示它们。 
代码审计的基础是定位和分析代码区域，这些代码区域可能有应用程序安全隐患。假设
代码审计者对代码、它的意图以及它的使用环境有一个彻底的理解，那么首先我们需要在代
码库中寻找感兴趣的区域。 
附录 C 给出了如何在以下编程语言中执行代码爬行的实例: 
⚫ 
.NET 
⚫ 
Java 
⚫ 
ASP 
⚫ 
C++/Apache 
3 安全代码审计技术参考 
3.1 A1 注入漏洞 
3.1.1 概述什么是注入 
注入攻击允许恶意用户向应用程序添加或注入内容和命令，以修改其行为。这些类型的
攻击是常见且广泛的，黑客很容易测试网站是否易受攻击，攻击者也很容易利用这些攻击。
如今，它们在尚未更新的遗留应用程序中非常常见。 
67 
3.1.2 SQL 注入 
最常见的注射漏洞是 SQL 注入，也很容易修复和防范。注入漏洞涵盖了 SQL、LDAP、
Xpath、OS 命令、XML 解析器。 
注入漏洞会导致： 
⚫ 
敏感信息的泄露。 
⚫ 
数据完整性问题。SQL 注入可以修改数据、添加新数据或删除数据。 
⚫ 
特权的提升。 
⚫ 
进入后端网络。 
SQL 命令不受不可信输入的保护。SQL 解析器无法区分代码和数据。 
在开发人员不考虑安全性的遗留应用程序中，使用字符串连接来生成 SQL 语句是非常
常见的。问题是这种编码技术不能告诉解析器语句的哪一部分是代码，哪一部分是数据。在
用户输入被连接到 SQL 语句的情况下，攻击者可以通过向输入数据添加 SQL 代码来修改
SQL 语句。 
应用程序可以接受不可信的输入。有几种方法可以减轻注入漏洞、白名单、正则表达式
等。下面是五个比较好的方法，这五种方法应该一起用于纵深防御。 
68 
1. 
HtmlEncode 所有用户输入。 
2. 
使用静态分析工具。静态的语言分析对.Net，Java，python 都比较准确。然而，当注
入来自 JavaScript 和 CSS 时，静态分析可能会成为一个问题。 
3. 
参数化 SQL 查询。使用编程语言或框架提供的参数化语句的 SQL 方法，以便 SQL 解
析器能够区分代码和数据。 
4. 
使用存储过程。存储过程通常有助于 SQL 解析器区分代码和数据。然而，存储过程可
以用来构建动态的 SQL 语句，允许代码和数据混合在一起，导致它容易被注入。 
5. 
为开发人员提供安全编码最佳实践的培训。 
SQL 盲注 
通常，SQL 查询会返回呈现给用户的搜索结果。然而，在某些情况下，SQL 查询是在
幕后进行的，这影响了页面的呈现方式。不过，攻击者仍然可以从各种用户界面元素的错误
响应中收集信息。SQL 盲注攻击是一种向数据库询问真假问题并根据应用程序的响应来确
定答案的攻击。 
实际上，攻击者使用 SQL 查询来确定为有效的 SQL 返回哪些错误响应，以及为无效的
SQL 返 回 哪 些 响 应 。 然 后 攻 击 者 就 可 以 探 查 真 实 的 数 据 。 例 如 ， 审 计 名 为
“user_password_table”的表是否存在。一旦他们获得了这些信息，他们就可以使用类似
上述的攻击来恶意删除表，或者试图从表中返回信息(用户名“john”是否存在？盲目的 SQL
注入也可以使用计时来代替错误消息。例如，如果无效的 SQL 需要 2 秒钟来响应，但是有
69 
效的 SQL 在 0.5 秒内返回，那么攻击者可以使用这些信息推断正确的拼接方式。 
参数化的 SQL 查询 
参数化的 SQL 查询(有时称为预编译的语句)允许定义 SQL 查询字符串。以这样一种方
式，客户端输入不会被视为 SQL 语法的一部分。以示例 7.1 中的例子为例: 
在本例中，字符串“查询”是以不依赖任何客户端输入的方式构造的，而“准备状态”
是由该字符串构造的。当客户端输入要输入到 SQl 中时，使用“setString”函数，第一个
问号“?”替换为字符串值“名字”，第二个问号替换为“姓氏”。当调用“setString”函
数时，该函数会自动审计字符串值中是否包含任何 SQL 语法。大多数准备好的语句接口允
许您指定应该输入的类型，例如。' setInt '，或' setBinary '等。 
安全字符串连接？ 
那么这是否意味着在您的数据库处理代码中根本不能使用字符串连接呢？安全地使用
字符串连接是可能的，但是它确实增加了出错的风险，即使攻击者没有试图将 SQL 语法注
入您的应用程序。 
您不应该将字符串串联与客户端输入值结合使用。举个例子，用一个客户端输入变量“姓
氏”的存在(不是值)来构造准备好的语句的 SQL 查询： 
70 
这里没有使用' lastname '的值，不过仍然增加条件判断是否存在。然而，当 SQL 语句
更大并且创建它涉及更复杂的业务逻辑时，仍然存在风险。以下面的例子为例，该函数将根
据名字或姓氏进行搜索: 
当给定名字或姓氏时，这种逻辑将是正确的，但是如果两者都没有给定，那么 SQL 状
态将没有任何 WHERE 子句，并且将返回整个表。这不是 SQL 注入(攻击者除了没有传递两
个值之外，没有做任何事情来导致这种情况)，但是最终结果是相同的，尽管使用了参数化
查询，信息还是从数据库中泄露了。 
因此，建议避免使用字符串连接来创建 SQL 查询字符串，即使是在使用参数化查询时。
尤其是注意当连接涉及在 where 子句中构建任何项时。 
71 
使用灵活的参数化语句 
功能需求通常需要基于用户输入灵活地执行 SQL 查询。例如，如果最终用户为他们的
交易搜索指定了一个时间跨度，那么应该使用这个时间跨度，或者他们可能希望基于姓氏或