title:The Return of Coppersmith's Attack: Practical Factorization of Widely
Used RSA Moduli
author:Mat&apos;us Nemec and
Marek S&apos;ys and
Petr Svenda and
Dusan Klinec and
Vashek Matyas
The Return of Coppersmith’s A(cid:130)ack:
Practical Factorization of Widely Used RSA Moduli
Matus Nemec
Petr Svenda
Masaryk University,
Marek Sys∗
Ca’ Foscari University of Venice
PI:EMAIL
Masaryk University
syso@(cid:128).muni.cz
Masaryk University
svenda@(cid:128).muni.cz
Dusan Klinec
EnigmaBridge, Masaryk University
PI:EMAIL
ABSTRACT
We report on our discovery of an algorithmic (cid:131)aw in the construc-
tion of primes for RSA key generation in a widely-used library
of a major manufacturer of cryptographic hardware. (cid:140)e primes
generated by the library su(cid:130)er from a signi(cid:128)cant loss of entropy.
We propose a practical factorization method for various key lengths
including 1024 and 2048 bits. Our method requires no additional
information except for the value of the public modulus and does
not depend on a weak or a faulty random number generator. We
devised an extension of Coppersmith’s factorization a(cid:138)ack utilizing
an alternative form of the primes in question. (cid:140)e library in ques-
tion is found in NIST FIPS 140-2 and CC EAL 5+ certi(cid:128)ed devices
used for a wide range of real-world applications, including identity
cards, passports, Trusted Platform Modules, PGP and tokens for
authentication or so(cid:137)ware signing. As the relevant library code was
introduced in 2012 at the latest (and probably earlier), the impacted
devices are now widespread. Tens of thousands of such keys were
directly identi(cid:128)ed, many with signi(cid:128)cant impacts, especially for
electronic identity documents, so(cid:137)ware signing, Trusted Comput-
ing and PGP. We estimate the number of a(cid:130)ected devices to be in
the order of at least tens of millions.
(cid:140)e worst cases for the factorization of 1024 and 2048-bit keys
are less than 3 CPU-months and 100 CPU-years on single core of
common recent CPUs, respectively, while the expected time is half
of that of the worst case. (cid:140)e a(cid:138)ack can be parallelized on multiple
CPUs. Worse still, all susceptible keys contain a strong (cid:128)ngerprint
that is veri(cid:128)able in microseconds on an ordinary laptop – meaning
that all vulnerable keys can be quickly identi(cid:128)ed, even in very large
datasets.
KEYWORDS
RSA, factorization, smartcard, Coppersmith’s algorithm
∗M. Sys and M. Nemec contributed equally.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for pro(cid:128)t or commercial advantage and that copies bear this notice and the full citation
on the (cid:128)rst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permi(cid:138)ed. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speci(cid:128)c permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’17, October 30–November 3, 2017, Dallas, TX, USA
© 2017 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4946-8/17/10...$15.00
DOI: h(cid:138)p://dx.doi.org/10.1145/3133956.3133969
Vashek Matyas
Masaryk University
matyas@(cid:128).muni.cz
1 INTRODUCTION
RSA [69] is a widespread algorithm for asymmetric cryptography
used for digital signatures and message encryption. RSA security
is based on the integer factorization problem, which is believed
to be computationally infeasible or at least extremely di(cid:129)cult for
su(cid:129)ciently large security parameters – the size of the private primes
and the resulting public modulus N . As of 2017, the most common
length of the modulus N is 2048 bits, with shorter key lengths
such as 1024 bits still used in practice (although not recommend
anymore) and longer lengths like 4096 bits becoming increasingly
common. As the private part of the key is a very sensitive item, a
user may use secure hardware such as a cryptographic smartcard
to securely store and use the private key value.
Successful a(cid:138)acks against RSA based on integer factorization
((cid:128)nding the private primes p and q from the public modulus N ) en-
able the a(cid:138)acker to impersonate the key owner and decrypt private
messages. (cid:140)e keys used by secure hardware are of special interest
due to the generally higher value of the information protected –
e.g., securing payment transactions.
RSA requires two large random primes p and q, that can be
obtained by generating a random candidate number (usually with
half of the bits of N ) and then testing it for primality. If the candidate
is found to be composite, the process is repeated with a di(cid:130)erent
candidate number.
However, there are at least three reasons to construct a candidate
number from several smaller (randomly) generated components
instead of generating it randomly: 1) an improved resistance against
certain factorization methods, such as Pollard’s p − 1 method [65];
2) certi(cid:128)cation requirements such as the NIST FIPS 140-2 standard,
which mandates that for all primes p, the values of p − 1 and p + 1
have at least one large (101-bit or larger) factor each; and 3) speedup
of keypair generation, since testing random candidate values for
primality is time consuming, especially on restricted devices like
smartcards.
Yet, constructed primes may bring new problems as demon-
strated in our work.
In the past, practical a(cid:138)acks against RSA
exploited the use of insecurely short key lengths susceptible to
factorization via NFS [67] (e.g., 512-bit, still found on the Inter-
net [38]); faulty or weak random number generators producing
partially predictable primes, as in the electronic IDs of Taiwanese
citizens [9]; so(cid:137)ware bugs causing primes to be generated from an
insu(cid:129)ciently large space, as in the Debian RNG (cid:131)aw [7]; or seeding
with insu(cid:129)cient entropy, leading to multiple keypairs sharing a
Session H1:  Crypto AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1631prime [38]. (cid:140)e knowledge or recovery of all bits of a private key is
not always required for a successful a(cid:138)ack thanks to the powerful
technique proposed by Coppersmith [22]. If at least one half of
the bits of one of the primes is known, the remaining bits can be
computationally recovered. (cid:140)en, even otherwise secure designs
can be a(cid:138)acked by various side-channel and implementation-based
a(cid:138)acks or by introducing faults into the computation.
Only on very rare occasions is an a(cid:138)acker potentially able to
recover the private primes of a chosen key of a seemingly su(cid:129)-
cient bit length, without physical access to the target device or a
large amount of side-channel information. One notable a(cid:138)ack that
comes close is a simple GCD computation [10], which can quickly
factorize a collection of moduli, but only if they happen to share a
common prime, making the a(cid:138)ack less likely to succeed on a single
targeted keypair. (cid:140)e cause of such vulnerability is typically insuf-
(cid:128)cient entropy during the keypair generation, as demonstrated for
a large number of TLS and SSH keys [36, 38], therefore requiring
multiple public keys to be created with the same malfunctioning
implementation of a random number generator.
We present our a(cid:138)ack against keys generated in cryptographic
smartcards of In(cid:128)neon Technologies AG (further denoted as Manu-
facturer), and our a(cid:138)ack is not based on any weakness in a random
bit generator or any additional side-channel information. Instead,
the a(cid:138)ack utilizes the speci(cid:128)c structure of the primes as generated
by Manufacturer’s on-chip cryptographic library (further denoted
as RSALib1). We had access neither to the RSALib’s source code
nor to the object code (since it is stored only in the secure on-chip
memory and is not extractable), and the whole analysis was per-
formed solely using RSA keys generated and exported from the
Manufacturer’s cards and tokens.
In short, the paper has the following contributions:
1. Recovery of the internal structure of the primes: We
identify the structure of RSA primes as produced by a black-box
cryptographic library by a manufacturer of widely used crypto-
graphic smartcards. (cid:140)e structure was recovered solely from our
observations of statistical properties of large number of private
keys generated in accordance with the speci(cid:128)cation of the product.
2. Practical factorization: We propose and implement a tech-
nique for the factorization of such RSA keys, with lengths including
1024 and 2048 bits, using our derivation of the methods by Copper-
smith and Howgrave-Graham.
3. Fast detection algorithm: We design a very fast algorithm
to verify whether a particular key originates from the inspected
library based on the properties of the public modulus. (cid:140)e imple-
mentation was released2 to allow users to check their own keys.
4. Analysis of impacted domains: We analyze multiple usage
domains (TLS, PGP, eID, authentication tokens, so(cid:137)ware signing,
etc.) for the prevalence of vulnerable keys and discuss the impact
of key factorization.
(cid:140)e speci(cid:128)c structure of the primes as generated by RSALib (most
likely introduced to speed up prime generation) allows us to quickly
identify keys generated by the library using only the public modulus
(regardless of the length of the key) and to practically factorize RSA
keys with various key lengths up to 2048 bits. (cid:140)e factorization
method uses knowledge of the speci(cid:128)c structure of such primes to
apply our derivation of Coppersmith’s method. Furthermore, we
devised an alternative representation of the primes in question to
make the a(cid:138)ack computationally feasible on consumer hardware.
(cid:140)e impact is signi(cid:128)cant due to Manufacturer being one of the
top three secure integrated circuit (IC) producers. Furthermore,
the weakness lies in an on-device so(cid:137)ware library; hence, it is not
limited just to a particular range of physical devices. (cid:140)e weakness
can be traced back to at least the year 2012, increasing the number
of a(cid:130)ected domains. We assessed the impact in a several important
real-world usage scenarios and made some recommendations for
mitigation.
(cid:140)e (cid:128)ngerprinting method is fast, requiring just microseconds
to run on a modulus. We successfully used the (cid:128)ngerprinting tech-
nique on large datasets of certi(cid:128)cates, such as those submi(cid:138)ed to
Certi(cid:128)cate Transparency logs, collected in Internet-wide TLS scans
and stored on public PGP keyservers. (cid:140)is led to a discovery of
thousands of keys in the wild with primes of the form in question.
Our method has negligible false negative and false positive rates
(observed as zero), as guaranteed by the very rare properties.
Where datasets with public RSA keys were not available (e.g.,
Trusted Platform Modules or EMV payment cards), we collected
sample keys from di(cid:130)erent devices to get an idea about the typical
key lengths used for the domain and to estimate the prevalence of
devices producing potentially vulnerable keys.
Although the RSALib is not automatically shipped with every
chip, the developers are motivated to deploy it in order to bene(cid:128)t
from ready-to-use higher-level functions (such as the RsaKeyGen
method in question) and to get an implementation designed with
protections against side-channel and fault induction a(cid:138)acks in mind.
However, even for certi(cid:128)cation, the RSALib is provided only as
object (cid:128)les, without the source code [20].
(cid:140)e rest of our paper is organized as follows: Section 2 is in-
tended for readers with interest in the mathematical details of the
discovered (cid:131)aw and the proposed factorization and (cid:128)ngerprinting
methods. (cid:140)e readers interested mainly in the practical impacts
should focus on the speci(cid:128)cs of the implementation of the factor-
ization method covered in Section 3 and the survey of impacted
usage domains and the analysis of vulnerable keys found in the
wild, as provided in Section 4. (cid:140)e possible approaches to short-
and long-term mitigation are discussed in Section 5. Related work
and conclusions are provided in Sections 6 and 7, respectively.
2 FINGERPRINTING AND FACTORIZATION
To use the RSA algorithm, one must generate a key:
(1) Select two distinct large primes3
(2) Compute N = p ∗ q and φ(N ) = (p − 1) ∗ (q − 1).
(3) Choose a public exponent4
(4) Compute the private exponent d as e−1 mod φ(N ).
e < φ(N ), e coprime to φ(N ).
p and q.
(cid:140)e pair (e, N ) is the public key; either (d, N ) serves as the secret
private key, or (p, q) can be used ((d, N ) can be calculated from
(p, q, e) and vice versa).
1Likely RSA v1.02.013 library and later revisions.
2Full details and a tool for the detection of vulnerable keys can be found at
h(cid:138)ps://crocs.(cid:128).muni.cz/papers/rsa ccs17.
3Generated randomly, but possibly constructed to achieve certain required properties.
4Usually with a low Hamming weight for faster encryption.
Session H1:  Crypto AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1632A factorization a(cid:138)ack a(cid:138)empts to obtain p and q from the knowl-
edge of N . Such an a(cid:138)ack is believed to be computationally infeasi-
ble for su(cid:129)ciently long N . (cid:140)e factorization can be sped up if some
additional information about the private exponent d or about the
primes p or q is known by the a(cid:138)acker.
2.1 Format of the constructed primes
Our motivation for a deeper analysis of the keys produced by Man-
ufacturer’s devices stemmed from the observation of interesting
statistical properties extracted from a large number of keys as de-