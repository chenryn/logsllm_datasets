52 t.Log("\tShould have a Name.", checkMark)
53 } else {
54 t.Error("\tShould have a Name.", ballotX, u.Name)
55 }
56
57 if u.Email == "PI:EMAIL" {
58 t.Log("\tShould have an Email.", checkMark)
59 } else {
60 t.Error("\tShould have an Email.", ballotX, u.Email)
61 }
62 }
63 }
代码清单9-25展示了对收到的两个值的检测。在第51行，我们检测Name字段的值是否为
"Bill"，之后在第 57 行，检查 Email 字段的值是否为"PI:EMAIL"。如果
这些值都匹配，单元测试通过；否则，单元测试失败。这两个检测使用Error方法来报告失败，
所以不管检测结果如何，两个字段都会被检测。
9.2 示例
Go语言很重视给代码编写合适的文档。专门内置了godoc工具来从代码直接生成文档。在
第3章中，我们已经学过如何使用godoc工具来生成包的文档。这个工具的另一个特性是示例
代码。示例代码给文档和测试都增加了一个可以扩展的维度。
如果使用浏览器来浏览json包的Go文档，会看到类似图9-8所示的文档。
图9-8 包json的示例代码列表
包json含有5个示例，这些示例都会在这个包的Go文档里有展示。如果选中第一个示例，
会看到一段示例代码，如图9-9所示。
图9-9 Go文档里显示的Decoder示例视图
开发人员可以创建自己的示例，并且在包的Go文档里展示。让我们看一个来自前一节例子
的SendJSON函数的示例，如代码清单9-26所示。
代码清单9-26 handlers_example_test.go
01 // 这个示例程序展示如何编写基础示例
02 package handlers_test
03
04 import (
05 "encoding/json"
06 "fmt"
07 "log"
08 "net/http"
09 "net/http/httptest"
10 )
11
12 // ExampleSendJSON提供了基础示例
13 func ExampleSendJSON() {
14 r, _ := http.NewRequest("GET", "/sendjson", nil)
15 rw := httptest.NewRecorder()
16 http.DefaultServeMux.ServeHTTP(rw, r)
17
18 var u struct {
19 Name string
20 Email string
21 }
22
23 if err := json.NewDecoder(w.Body).Decode(&u); err != nil {
24 log.Println("ERROR:", err)
25 }
26
27 // 使用fmt将结果写到stdout来检测输出
28 fmt.Println(u)
29 // Output:
30 // {Bill PI:EMAIL}
31 }
示例基于已经存在的函数或者方法。我们需要使用Example代替Test作为函数名的开始。
在代码清单9-26的第13行中，示例代码的名字是ExampleSendJSON。
对于示例代码，需要遵守一个规则。示例代码的函数名字必须基于已经存在的公开的函数或
者方法。我们的示例的名字基于handlers包里公开的SendJSON函数。如果没有使用已经存
在的函数或者方法，这个示例就不会显示在包的Go文档里。
写示例代码的目的是展示某个函数或者方法的特定使用方法。为了判断测试是成功还是失
败，需要将程序最终的输出和示例函数底部列出的输出做比较，如代码清单9-27所示。
代码清单9-27 handlers_example_test.go：第27行到第31行
27 // 使用fmt将结果写到stdout来检测输出
28 fmt.Println(u)
29 // Output:
30 // {Bill PI:EMAIL}
31 }
在代码清单9-27的第28行，代码使用fmt.Println输出变量u的值到标准输出。变量u
的值在调用/sendjson服务端点之前使用零值初始化。在第29行中，有一段带有Output:的
注释。
这个Output:标记用来在文档中标记出示例函数运行后期望的输出。Go的测试框架知道如
何比较注释里的期望输出和标准输出的最终输出。如果两者匹配，这个示例作为测试就会通过，
并加入到包的Go文档里。如果输出不匹配，这个示例作为测试就会失败。
如果启动一个本地的godoc服务器（godoc -http=":3000"），并找到handlers包，
就能看到包含示例的文档，如图9-10所示。
在图9-10里可以看到handlers包的文档里展示了SendJSON函数的示例。如果选中这个
SendJSON链接，文档就会展示这段代码，如图9-11所示。
图 9-11 展示了示例的一组完整文档，包括代码和期望的输出。由于这个示例也是测试的一
部分，可以使用go test工具来运行这个示例函数，如图9-12所示。
图9-10 handlers包的godoc视图 图9-11 在godoc里显示完整的示例代码
图9-12 运行示例代码
运行测试后，可以看到测试通过了。这次运行测试时，使用-run 选项指定了特定的函数
ExampleSendJSON。-run选项接受任意的正则表达式，来过滤要运行的测试函数。这个选项
既支持单元测试，也支持示例函数。如果示例运行失败，输出会与图9-13所示的样子类似。
图9-13 示例运行失败
如果示例运行失败，go test会同时展示出生成的输出，以及期望的输出。
9.3 基准测试
基准测试是一种测试代码性能的方法。想要测试解决同一问题的不同方案的性能，以及查看
哪种解决方案的性能更好时，基准测试就会很有用。基准测试也可以用来识别某段代码的 CPU
或者内存效率问题，而这段代码的效率可能会严重影响整个应用程序的性能。许多开发人员会用
基准测试来测试不同的并发模式，或者用基准测试来辅助配置工作池的数量，以保证能最大化系
统的吞吐量。
让我们看一组基准测试的函数，找出将整数值转为字符串的最快方法。在标准库里，有3种
方法可以将一个整数值转为字符串。
代码清单9-28展示了listing28_test.go基准测试开始的几行代码。
代码清单9-28 listing28_test.go：第01行到第10行
01 // 用来检测要将整数值转为字符串，使用哪个函数会更好的基准
02 // 测试示例。先使用fmt.Sprintf函数，然后使用
03 // strconv.FormatInt函数，最后使用strconv.Itoa
04 package listing28_test
05
06 import (
07 "fmt"
08 "strconv"
09 "testing"
10 )
和单元测试文件一样，基准测试的文件名也必须以_test.go 结尾。同时也必须导入
testing包。接下来，让我们看一下其中一个基准测试函数，如代码清单9-29所示。
代码清单9-29 listing28_test.go：第12行到第22行
12 // BenchmarkSprintf对fmt.Sprintf函数
13 // 进行基准测试
14 func BenchmarkSprintf(b *testing.B) {
15 number := 10
16
17 b.ResetTimer()
18
19 for i := 0; i < b.N; i++ {
20 fmt.Sprintf("%d", number)
21 }
22 }
在代码清单9-29的第14行，可以看到第一个基准测试函数，名为BenchmarkSprintf。
基准测试函数必须以Benchmark开头，接受一个指向testing.B类型的指针作为唯一参数。
为了让基准测试框架能准确测试性能，它必须在一段时间内反复运行这段代码，所以这里使用了
for循环，如代码清单9-30所示。
代码清单9-30 listing28_test.go：第19行到第22行
19 for i := 0; i < b.N; i++ {
20 fmt.Sprintf("%d", number)
21 }
22 }
代码清单9-30第19行的for循环展示了如何使用b.N的值。在第20行，调用了fmt包
里的Sprintf函数。这个函数是将要测试的将整数值转为字符串的函数。
基准测试框架默认会在持续1秒的时间内，反复调用需要测试的函数。测试框架每次调用测
试函数时，都会增加 b.N 的值。第一次调用时，b.N 的值为 1。需要注意，一定要将所有要进
行基准测试的代码都放到循环里，并且循环要使用b.N的值。否则，测试的结果是不可靠的。
如果我们只希望运行基准测试函数，需要加入-bench选项，如代码清单9-31所示。
代码清单9-31 运行基准测试
go test -v -run="none" -bench="BenchmarkSprintf"
在这次go test调用里，我们给-run选项传递了字符串"none"，来保证在运行制订的基
准测试函数之前没有单元测试会被运行。这两个选项都可以接受正则表达式，来决定需要运行哪
些测试。由于例子里没有单元测试函数的名字中有none，所以使用none 可以排除所有的单元
测试。发出这个命令后，得到图9-14所示的输出。
图9-14 运行单个基准测试
这个输出一开始明确了没有单元测试被运行，之后开始运行 BenchmarkSprintf 基准测
试。在输出PASS之后，可以看到运行这个基准测试函数的结果。第一个数字5000000表示在
循环中的代码被执行的次数。在这个例子里，一共执行了500万次。之后的数字表示代码的性能，
单位为每次操作消耗的纳秒（ns）数。这个数字展示了这次测试，使用Sprintf 函数平均每次
花费了258纳秒。
最后，运行基准测试输出了ok，表明基准测试正常结束。之后显示的是被执行的代码文件的名字。
最后，输出运行基准测试总共消耗的时间。默认情况下，基准测试的最小运行时间是1 秒。你会看到
这个测试框架持续运行了大约1.5 秒。如果想让运行时间更长，可以使用另一个名为-benchtime 的
选项来更改测试执行的最短时间。让我们再次运行这个测试，这次持续执行3秒（见图9-15）。
图9-15 使用-benchtime选项来运行基准测试
这次Sprintf函数运行了2000万次，持续了5.384秒。这个函数的执行性能并没有太大的
变化，这次的性能是每次操作消耗256纳秒。有时候，增加基准测试的时间，会得到更加精确的
性能结果。对大多数测试来说，超过3秒的基准测试并不会改变测试的精确度。只是每次基准测
试的结果会稍有不同。
让我们看另外两个基准测试函数，并一起运行这3个基准测试，看看哪种将整数值转换为字
符串的方法最快，如代码清单9-32所示。
代码清单9-32 listing28_test.go：第24行到第46行
24 // BenchmarkFormat对strconv.FormatInt函数
25 // 进行基准测试
26 func BenchmarkFormat(b *testing.B) {
27 number := int64(10)
28
29 b.ResetTimer()
30
31 for i := 0; i < b.N; i++ {
32 strconv.FormatInt(number, 10)
33 }
34 }
35
36 // BenchmarkItoa对strconv.Itoa函数
37 // 进行基准测试
38 func BenchmarkItoa(b *testing.B) {
39 number := 10
40
41 b.ResetTimer()
42
43 for i := 0; i < b.N; i++ {
44 strconv.Itoa(number)
45 }
46 }
代码清单 9-32 展示了另外两个基准测试函数。函数 BenchmarkFormat 测试了 strconv
包里的FormatInt函数，而函数BenchmarkItoa测试了同样来自strconv包的Itoa函数。
这两个基准测试函数的模式和 BenchmarkSprintf 函数的模式很类似。函数内部的 for 循环
使用b.N来控制每次调用时迭代的次数。
我们之前一直没有提到这3个基准测试里面调用b.ResetTimer的作用。在代码开始执行循环之
前需要进行初始化时，这个方法用来重置计时器，保证测试代码执行前的初始化代码，不会干扰计时
器的结果。为了保证得到的测试结果尽量精确，需要使用这个函数来跳过初始化代码的执行时间。
让这3个函数至少运行3秒后，我们得到图9-16所示的结果。
图9-16 运行所有3个基准测试
这个结果展示了BenchmarkFormat测试函数运行的速度最快，每次操作耗时45.9纳秒。紧随其
后的是BenchmarkItoa，每次操作耗时49.4 ns。这两个函数的性能都比Sprintf函数快得多。
运行基准测试时，另一个很有用的选项是-benchmem选项。这个选项可以提供每次操作分
配内存的次数，以及总共分配内存的字节数。让我们看一下如何使用这个选项（见图9-17）。
图9-17 使用-benchmem选项来运行基准测试
这次输出的结果会多出两组新的数值：一组数值的单位是 B/op，另一组的单位是
allocs/op。单位为 allocs/op 的值表示每次操作从堆上分配内存的次数。你可以看到
Sprintf 函数每次操作都会从堆上分配两个值，而另外两个函数每次操作只会分配一个值。单
位为B/op的值表示每次操作分配的字节数。你可以看到Sprintf函数两次分配总共消耗了16
字节的内存，而另外两个函数每次操作只会分配2字节的内存。
在运行单元测试和基准测试时，还有很多选项可以用。建议读者查看一遍所有选项，以便在
编写自己的包和工程时，充分利用测试框架。社区希望包的作者在正式发布包的时候提供足够的
测试。
9.4 小结
测试功能被内置到Go语言中，Go语言提供了必要的测试工具。
go test工具用来运行测试。
测试文件总是以_test.go作为文件名的结尾。
表组测试是利用一个测试函数测试多组值的好办法。
包中的示例代码，既能用于测试，也能用于文档。
基准测试提供了探查代码性能的机制。
语言实战
Go
Go Go
即便不处理类似可扩展的Web并发或者实时性能等复杂的系统
编程问题，应用程序开发也是一件非常困难的事情。尽管使用一些工
具和框架也可以解决这些常见的问题，但Go语言却以一种更加自然 “探索、学习并使用Go语言的简洁
且高效的方式正确处理了这类问题。由谷歌公司开发的Go语言，为 而全面的指导手册。” 语
语言实战
在基础设施中非常依赖高性能服务的初创公司和大企业提供了足够的 ——摘自Hugo创立者Steven Francia
能力。 为本书写的序 言
本书目标读者是已经有一定其他编程语言经验，想要开始学习
“这本权威的书为所有想要开始学习
Go语言或者更深入了解Go语言及其内部机制的中级开发者。本书 实
会提供一个专注、全面且符合习惯的视角。本书关注Go语言的规范 Go语言的人提供了一站式的指引。” Go
和实现，涉及的内容包括语法、Go的类型系统、并发、通道和测试 ——Sam Zaydel，RackTop Systems 战
等主题。
“写得太好了！完整介绍了Go语言。
IN ACTION
强烈推荐。”
本书主要内容
——Adam McKay，SUEZ
●● Go语言规范和实现。
●● Go语言的类型系统。 “这本书把Go语言不寻常的部分讲
●● Go语言的数据结构的内部实现。 得通俗易懂。”
●● 测试和基准测试。●● ——Alex Vidal，Atlassian的HipChat团队
●William●Kennedy●●
〔美〕●●●●●●B●●r●i●a●●n●●●●K●●e●●t●e●●l●s●●e●●n●●●●●●●著
本书假设读者是熟练使用其他语言（如Java、Ruby、Python、
Erik●St.●Martin
C#或者C++）的开发者。
李兆海●●●译
William Kennedy是一位熟练的软件开发者，也是博客GoingGo. 谢孟军●●审校
Net的作者。Brian Ketelsen和Erik St. Martin是全球Go
语言大会GopherCon的组织者，也是Go语言框架Skynet的联合作者。
美术编辑：董志桢
分类建议：计算机／程序设计／Go语言
人民邮电出版社网址：www.ptpress.com.cn
FM44535Go语言实战.indd 1-3 17-1-19 下午2:38