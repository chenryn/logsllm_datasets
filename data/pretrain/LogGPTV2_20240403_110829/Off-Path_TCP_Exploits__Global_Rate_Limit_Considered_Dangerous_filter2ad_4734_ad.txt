• Step 2 – Narrow down the sequence number
space to a single block. From step 1, we know that the
receive window is within a chunk. We now further nar-
row down the search space to an exact block within the
chunk. Note that we have now updated the block size so
that there will be one and only one block that can trig-
ger challenge ACKs. To locate the exact block, the same
binary search strategy outlined in Figure 8 can be used
except that the search space now is dramatically reduced
after step 1.
The located block has a beginning value which, is an
in-window sequence number; therefore, one of the fol-
lowing is true: (i) its beginning value is the correct se-
quence value; or (ii) the correct sequence value is in its
left neighboring block.
In the ﬁrst case, since the se-
quence number matches the RCV.NXT , the spoofed RST
packet can already terminate the connection. In the sec-
ond case, the attacker performs an additional search in
the left neighboring block (see Step 3).
• Step 2 (optimized version) – Identify the correct
sequence block using multi-bin search. With the pre-
vious assumption that the attacker can send n spoofed
packets per second, with a binary search, the ﬁrst round
requires only n
2 packets (as we divide a chunk into two
halves initially). The second round requires only n
4 pack-
ets and so on. As we see, the number of packets sent in
each round reduces quickly. This is not an efﬁcient use
of the network bandwidth. We show that it is possible to
speed up the search process by sending more packets per
round (still at most n per round).
The idea is, instead of dividing the search space into
two halves in each round, we can divide the space into
multiple bins and probe them simultaneously. This is
illustrated in Figure 9(a) where 4 bins are present in a
chunk. Each bin here holds an equal number of blocks.
To determine which bin the receive window falls in, the
attacker sends a different number of spoofed RST pack-
ets in each bin. In the example, he sends 1 RST packet
per block in the 2nd bin, 2 RST packets per block in the
3rd bin, and 3 RST packets per block in the 4th bin. Since
the receive window can fall into one and only one of the
bins, the attacker can determine which bin it is in, by ob-
serving how many challenge ACKs are received at the
end of the 1-second interval. If there are 100 challenge
ACKs received, it indicates that the receive window is in
the 1st bin (since no RST packets were sent in the 1st
bin). Receipt of 99 challenge ACKs indicates that the
receive window is in the 2nd bin, etc.
Note that the more bins we have, the faster we can
narrow down the sequence number space. However, the
number of bins chosen for each round is constrained by
n. The larger the n, the more the bins that can be created.
The number of bins is also capped at 14, given that the
number of spoofed packets may already exhaust the 100
challenge ACK counter in one round (0 + 1 + 2 + ... +
13 = 91).
• Step 3 – Find the correct sequence number us-
ing binary search. Now we are sure that RCV.NXT is
within a speciﬁc block, we need to locate its exact value.
To achieve the goal, another modiﬁed binary search strat-
egy is used here. The observation is that the correct se-
quence number (RCV.NXT ) is the highest value in the
block, such that any spoofed RST packet with a sequence
number less than it will not trigger a challenge ACK
packet. It is worth noting that we may not realize which
value is the correct sequence number until the connection
is terminated, as all the probing packets are RST packets.
• Step 3 (optimized version) – Find the correct
sequence number using multi-bin search. Similar to
the previous multi-bin search, the attacker can divide the
single block into many small bins and probe them simul-
taneously. All bins before the left boundary of the re-
ceive window (RCV.NXT ) will not trigger any challenge
ACKs; the ones after will. Thus, in this step attacker
only sends one spoofed packet per bin and accumulates
all the challenge ACKs received from right to left (See
Figure 9). If the attacker sees (100-X) challenge ACKs
at the end of the 1-second interval, it indicates that X
probed bins are after RCV.NXT . In Figure 9, let us say
we divide the block into 4 bins. After probing them, the
number of observed challenge ACK will be 97 because
2nd, 3rd, and 4th bins turn out to be after RCV.NXT .
Note that if the observed challenge ACK is 100, it in-
dicates that the correct sequence number is somewhere
inside the 4th bin (but not its beginning value).
Similar to the previous multi-bin search, the number
of bins chosen for each round is constrained by n. In ad-
dition, the number of bins is always capped at 100, as the
spoofed packets may exhaust the limit of 100 challenge
ACK count.
USENIX Association  
25th USENIX Security Symposium  217
9
The RST off-path TCP attack is successfully launched
after the above three steps. The exact number of prob-
ing rounds depends on the available bandwidth, and will
determine the time it takes to ﬁnish the attack. We will
evaluate this in §7.
5 Off-Path Connection Hijacking Attack
In this section, we discuss how an off-path attacker can
hijack an ongoing connection and inject spoofed data.
The methodology used to inject data into the client or
to the server are similar; thus, without loss of general-
ity, we exemplify the attack targeting the server. First,
we describe the challenges that the attacker will need to
overcome; subsequently, the entire attack process is de-
scribed in detail.
5.1 Challenges and Overview
The attacker will experience obstacles that are similar to
those associated with launching an off-path reset attack.
In addition, the following additional challenges need to
be addressed.
Preventing unwanted connection reset. As de-
scribed in §4.3, the RST packets with in-window se-
quence numbers are leveraged towards identifying the
next expected sequence number on the connection. How-
ever, with that process, sending a RST packet with the
exact, expected sequence number (RCV.NXT ) to the
server will terminate the TCP connection; this is not the
goal of the hijack attack. The challenge is thus, to infer
RCV.NXT without causing connection termination.
Identifying both the sequence number and ACK
number. In order to trick the server into believing that
the injected data is valid, and sent from the server, the at-
tacker needs to know both the correct sequence number
(RCV.NXT ) and the acceptable ACK range on the server
side of the connection. The latter is typically a fairly
small range as discussed in §2.3.
At a high level, our design of the attack consists of the
following steps: First, the attacker ﬁnds an in-window
sequence number on the server using the techniques de-
scribed in §4.3. Based on this, the attacker will be able
to guess the range of acceptable ACK values that trig-
ger challenge ACKs. The range of these acceptable val-
ues (ACK window) can be used to identify the highest
acceptable ACK number, i.e., SND.NXT , on the server.
We will show next that obtaining this ACK number then
allows the attacker to infer the exact expected sequence
number on the server without resetting the connection.
Inferring Acceptable ACK Numbers
5.2
Assuming an in-window sequence number is already in-
ferred, we now discuss how an attacker can infer the
next ACK number, SND.UNA, which is expected by
the server. As illustrated in Figure 3, an incoming data
packet is accepted if the ACK number is in the range of
[SND.UNA− MAX.SND.W ND, SND.NXT ]. If not, the
receiver will respond with a challenge ACK packet, if the
ACK number is in the range of [SND.UNA− (231 − 1),
SND.UNA− MAX.SND.W ND); this range is called the
challenge ACK window. It is obvious that SND.UNA can
be computed if one can successfully infer the left bound-
ary of the challenge ACK window, SND.UNA− (231 −
1). This in turn can be found using the following ap-
proach.
Step 1: Identify the challenge ACK window posi-
tion. According to RFC 1323, by using the window
scaling option, the maximum receive window size can
be extended from 216 to a maximum of 230 = 1G. Thus,
the MAX.SND.W ND cannot be larger than 1G. Accord-
ingly, the challenge ACK window size is between 1G and
2G, which is one quarter of the entire ACK space size.
Because of this, we divide the entire ACK space into 4
bins and probe each bin to check which bin(s) the chal-
lenge ACK window falls in. In our implementation, we
probe the ﬁrst value of each bin, i.e. 0, 1G, 2G, 3G. We
know for certain that either one or two bins can trigger
challenge ACK packets. Therefore, we need to send dif-
ferent number of packets for each bin to differentiate the
resulting cases. A simple strategy is to send one packet
at ACK number 0, two packets at 1G, four packets at 2G,
and 8 packets at 3G. For instance, if the number of ob-
served challenge ACKs is 94 (6 missing), then we can
infer that both ACK number 1G and 2G have triggered
challenge ACKs. If the number of observed challenge
ACKs is 96 (4 missing), then only ACK number 2G has
triggered challenge ACKs. We can then easily determine
the “left-most” bin whose beginning value falls in chal-
lenge ACK window.
Step 2: Find the left boundary of the challenge
ACK window Now the problem is, given the bin located
in the previous step, we need to identify an ACK number
in the left neighboring bin, such that it is the “left-most”
value (in the circular sense) that can still trigger chal-
lenge ACKs. This is a problem that can be solved in a
similar way to the last step of sequence number inference
using multi-bin search (§4.3).
Finally, when the left boundary of the challenge ACK
window (SND.UNA− (231 − 1)) is found, an acceptable
ACK value (SND.UNA) is trivially computed.
Identify the Exact Sequence Number
5.3
To locate RCV.NXT without resetting a connection, we
leverage the knowledge learned about the various ACK
number ranges. The idea is that, instead of sending
spoofed RST packets (which may terminate a connec-
218  25th USENIX Security Symposium 
USENIX Association
10
tion), the attacker can send spoofed data packets with
ACK numbers that fall in the challenge ACK window
and thus, intentionally trigger challenge ACKs (if the
sequence number is in-window). Combined with the
fact no challenge ACK will be triggered if the guessed
sequence number is before RCV.NXT (considered old
packet and dropped), RCV.NXT can be located as the
“left-most” value that can trigger challenge ACKs. The
search process is in fact similar to the last step in se-
quence number inference except that we now use spoofed
data packets.
Now that the attacker knows both the RCV.NXT and
SND.UNA on the server, it is trivial to inject legitimate-
looking data packets that will be accepted by the server.
Further,
it is also trivial to inject legitimate-looking
data packets to the client because the RCV.NXT on the
server is effectively the SND.UNA on the client, and the
SND.UNA is the RCV.NXT on the client (assuming no
trafﬁc is in ﬂight). In §7.2, we will present a case study
on how a web service can be hijacked by a completely
blind off-path attacker.
6 Other Practical Considerations
We have fully implemented the attacks described in §4
and §5. In §7, we will evaluate the effectiveness and ef-
ﬁciency of the attacks extensively.
In this section, we
outline a few practical considerations that need to be han-
dled.
Detecting and handling packet loss. So far, we have
assumed that spoofed connections will not incur packet
loss and the challenge ACK side channel has no noise.
However, in reality, even if the number of packets sent
per second is chosen conservatively (well below band-
width constraints), there is still no guarantee that packet
loss will not occur, and a host may legitimately gen-
erate challenge ACKs that are not triggered by the at-
tack. They exhibit the same effect to the attacker —
the number of observed challenge ACKs will be smaller
than expected. In this paper, we call them both packet
loss for convenience. We address packet loss based on
the two following principles: 1) when in doubt, repeat
the probes; 2) add redundancy in the probing scheme to
proactively detect packet loss.
In the initial step of the sequence number search, if
packet loss occurs, the number of observed challenge
ACKs may reduce to 99; the attacker thus, may incor-
rectly conclude that a chunk that contains the receive
window is located. This will affect all subsequent search
steps. Therefore, every time when a “plausible” chunk
is detected, we repeat the probe on the same chunk. The
search will proceed to step 2 only when both rounds re-
turn exactly 99 challenge ACKs (no more, no less).
In step 2 and step 3 of the sequence number search,
we add redundancy to actively detect packet loss so that
we repeat only the round of probing that experienced
packet loss. The idea is similar to using parity bits. In
each round, instead of allowing the number of observed
challenge ACKs to be any value equal to or below 100,
we can construct the probing packets such that only odd
number of challenge ACKs will be considered a valid
outcome. If an even number of challenge ACKs is re-
ceived, packet loss must have happened. This strategy
can be visualized by referring to Figure 9(a). Instead of
sending 1, 2, or 3 packets per block for each bin, we will
send 1, 3, and 5 packets per block for each bin. This
means that if the receive window falls in 2nd bin, the
number of challenge ACKs will be 99; if the receive win-
dow is in 3rd bin, the number of challenge ACKs will be
97, etc.
Both schemes are implemented and shown to be very
effective in cases where the network conditions between
the attacker and the victim are poor.
Moving receive window and challenge ACK win-
dow. So far, we have assumed that the connection is
relatively idle, and the window does not change while
the inference is in progress. This is likely to be the case
in many real world scenarios, especially with long-lived
connections. One example is the push notiﬁcation con-
nections on mobile platforms [2]. They are idle most
of the time until a new push notiﬁcation arrives. Even
when a connection is not idle at one point, it is likely
to become idle at some point and become more suscep-
tible to the attack. Moreover, the trafﬁc activity will
mostly be concentrated on either uplink and downlink,
rarely both. Typically, downlink trafﬁc dominates; there-
fore, the attacker targeting at resetting the connection on
the server side will experience less difﬁculty (client’s se-
quence number increases very slowly). Tor network con-
nections are also candidates as the end-to-end throughput
is typically very low.
To support sequence number inference against (slow)
moving receive windows, we implement a simple strat-
egy which conducts a brute-force style sequence number
guessing. Speciﬁcally, once a “left-most” in-window se-
quence number is inferred (which may become invalid in
the next interval due to the ongoing activities), we send
20,000 RST packets with sequence numbers, with offset
1, 2, ..., 20,000 to the valid sequence number. As will be
shown in §7.1.2, for low-activity connections, this strat-
egy works well. We leave the exercise to come up with
a strategy to target connections with heavier trafﬁc to fu-
ture work.
Per-connection rate limit. Since the Linux kernel
version 4.0 (released in Apr 2015), in addition to the
global challenge ACK rate limit, a per-connection rate
limit was introduced. The idea is to reduce the im-
pact of potential ACK loops [3] that may occur if client
USENIX Association  
25th USENIX Security Symposium  219
11
and server are de-synchronized. Theoretically, the per-
connection rate limit provides an isolation between the
victim connection and the attacker connection, and the
side channel should be eliminated completely. For in-
stance, even if the challenge ACK count limit is reached
for the victim connection, it does not affect the limit on
the attacker connection at all.
However, interestingly, the per-connection rate limit
only applies to SYN packets or packets without any pay-
load. The comment in the Linux kernel states “Data
packets without SYNs are not likely part of an ACK
loop”, hinting that such packets do not need to be gov-
erned by the per-connection rate limit. It is evident that
the developers assumed a benign scenario instead of an
adversarial one. To get around this restriction, we simply
send spoofed packets with a single byte of payload. For
the spoofed SYN-ACK packets though, it is impossible
to bypass the per-connection rate limit. Unfortunately,
upon a closer look at the implementation, when a per-
connection challenge ACK is sent out, it is also counted
towards the global challenge ACK limit. Therefore, it
is still possible to infer that the four-tuple of an ongo-
ing connection has been guessed correctly by observing
only 99 challenge ACKs at the end of the 1-second inter-
val. In practice, the per-connection rate limit is 1 packet
every 0.5 second, which does allow the attacker to pro-
ceed with the binary search approach outlined in §4.2.
We have veriﬁed experimentally that it does work against
the latest Linux kernels with per-connection rate limit.
Conﬁgurable maximum challenge ACK count. For