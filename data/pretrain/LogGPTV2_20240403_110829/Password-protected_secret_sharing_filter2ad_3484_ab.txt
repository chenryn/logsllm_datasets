user-centric communication model, assuming ROM.
MacKenzie and Reiter’s “Capture-Resilient Device” protocols
[18] considered essentially the same goals as a PPSS scheme cast
in the private storage setting, but in a less general setting where
the trust threshold is ﬁxed at t = 1, i.e. where a single trustee, in
addition to the client’s device, is needed to reconstruct user’s data.
Their schemes considered not only password-protected storage of
user’s data, but also password-protected computation of RSA sig-
natures and ElGamal decryption. Note that any T-PAKE protocol,
including one implied by a PPSS scheme, can be used to imple-
ment such password-protected computation given a non-interactive
threshold protocol for the respective computation. The servers sim-
ply encrypt the messages of the threshold function-computation
protocol under the session keys generated by a T-PAKE instance.
Thus the 2-party password-protected signature/decryption compu-
tation of [18] can be generalized to any (t, n) threshold using our
PPSS and non-interactive threshold RSA signature of [24] and non-
interactive threshold ElGamal decryption of [6]. (We note, how-
ever, that the protocols of [18] for the t = 1 case use only 2 mes-
sages, while those built using our PPSS scheme would take 3 mes-
sages.) Xu and Sandhu [26] consider the same notion of password-
authenticated threshold signature computation called TPAKE-TSig,
except that they consider it in the roaming user setting. Since their
construction is exactly the composition of a T-PAKE and a thresh-
old signature sketched above, their TPAKE-Sig protocol can only
be as fast as a T-PAKE.
PPSS is remotely related to the “key-insulated” and “intrusion-
resilient” cryptosystems introduced in [9, 8], which also concern
protecting user’s data against device corruption via secret-sharing
user’s private key among semi-trusted entities. However, they con-
sider only embedded entities like smartcards or co-processors, to
whom the user does not need to authenticate remotely.
Our Contributions. We present a practical PPSS scheme in the
PKI model, where the client trusts some public key(s), provably
secure under the DDH assumption, assuming non-interactive zero-
knowledge proofs which can be efﬁciently instantiated in ROM.
Our scheme requires fewer than 16 exponentiations per trustee and
8t + 17 exponentiations per user, with O(1) bandwidth between
the user and each trustee, and only three message ﬂows, implying
a single round of interaction if trustees’ ﬁrst messages are precom-
puted. We also show that a PPSS implies a T-PAKE with very little
computation and communication overhead, and no additional com-
munication rounds. Thus our scheme implies a T-PAKE with fewer
communication rounds, less bandwidth, and less server computa-
tion than existing T-PAKE’s of [19, 7]. The exact cost compari-
son in the user-mediated communication model is shown in Table
1. For the special case of n = 2, our scheme has lower message
complexity and server computation costs than even the 2-party T-
PAKE’s of Brainard et al. [3] and Katz et al. [15]. However, in the
private storage setting and threshold t set at 1, our scheme is beaten
by those of [18].
2. PPSS DEFINITION
A Password-Protected Secret Sharing (PPSS) scheme is a proto-
col involving n + 1 parties, a user U, and n servers P1, ..., Pn.
A PPSS scheme for secret space S and dictionary D is a tuple
(Init, User, Server), where Init(p, s) is an initialization algorithm
which on inputs a secret s ∈ S and password p ∈ D generates
st = (st0, st1, ...., stn) where st0 are public parameters and sti
is the private state of server Pi; User(˜p, st0) is an interactive al-
gorithm followed by U on its password ˜p (presumably equal to p)
and parameters st0; and Server(sti) is an interactive algorithm fol-
lowed by Pi on input sti. The Server algorithm has no local output,
while the User algorithm has a local output which is either some
bitstring s(cid:48) or a special rejection symbol ⊥. We require a PPSS
protocol to be complete in the sense that if PPSS(p, st) is a ran-
dom variable deﬁned as the local output of algorithm User(p, st0)
after an interaction with oracles Server(st1), ..., Server(stn) then
PPSS(p, Init(p, s)) = s for any (s, p) ∈ S × D. To model con-
current execution of several PPSS protocol instances we denote by
User(cid:5)(p, st0) an oracle which allows the caller to interact with any
number of User(p, st0) instances. Importantly, the caller sees only
protocol messages output by each User instance it interacts with,
and not the local output of any of these instances, although this view
is crucially amended in the strong security notion below. Similarly,
for any set B we denote by Server(cid:5)(stB) an oracle which allows
the caller to interact with any number of Server(sti) instances for
any i in B (cid:44) {1, ..., n} \ B. We say that probabilistic algorithm A
interacts with at most qU user sessions if in any of its executions
A initializes at most qU instances of User(p, st0) algorithm when
(cid:80)
interacting with oracle User(cid:5)(p, st0), and we say that A interacts
with at most qS server sessions if in any execution of A we have
i∈B qi ≤ qS where qi is the number of Server(sti) instances A
initializes when interacting with oracle Server(cid:5)(stB).
We deﬁne security of a PPSS scheme in terms of advantage in
distinguishing between PPSS instances initialized with two differ-
ent secrets, where the adversary sees the public parameters st0, the
private states stB (cid:44) {sti}i∈B of corrupted servers {Pi}i∈B, and has
concurrent oracle access to instances of the user and server algo-
rithms executing on inputs deﬁned by the initialization procedure.
Note that this deﬁnes a PPSS scheme in the PKI model, because
the user algorithm is assumed to execute only on the st0 parame-
ters generated by Init(p, s), and this st0 could be certiﬁed under a
trusted public key instead of being stored locally. We call an (t, n)-
threshold PPSS scheme secure if this advantage is bounded by 1|D| ,
the probability of guessing the password, times (cid:98)
t−t(cid:48)+1(cid:99) where
t(cid:48) ≤ t is the number of servers an adversary corrupts, plus at most
a negligible amount. The last factor corresponds to the probability
of success of an on-line dictionary attack in a threshold setting: An
adversary who learns the shares of t(cid:48) ≤ t servers can test any pass-
word ˜p in D by executing User(˜p, st0) and interacting with any
subset of t − t(cid:48) + 1 uncorrupted servers. To the best of our knowl-
edge all previous works on T-PAKE’s bound attackers’ success by
qS|D| , which is higher than the above bound, except if the adversary
corrupts the maximum threshold of servers, t(cid:48) = t. In particular, if
each server locally bounds the number of sessions it performs with
the same user to k, such deﬁnition bounds the number of passwords
which a network attacker can test to n∗ k passwords, instead of the
optimal number of (cid:98) n∗k
Formally, we call a PPSS scheme on dictionary D and secret
space S is (n, t, T, qU , qS, )-secure if for any s0, s1 ∈ S, any set
B s.t. t(cid:48) (cid:44) |B| satisﬁes t(cid:48) ≤ t, and any algorithm A with running
time T , we have
t+1(cid:99) passwords.
qS
(cid:22)
(cid:23)
|p0 − p1| ≤
qS
t − t(cid:48) + 1
∗ 1
|D| + 
where pb is the probability that A(s0, s1, st0, stB) outputs 1 on ac-
cess to qU sessions with oracle User(cid:5)(p, st0) and qS sessions with
oracle Server(cid:5)(stB), for st output by Init(p, sb) on p chosen at ran-
dom in D, with probability taken over all random processes.
To make a PPSS scheme easier to use as a building block, e.g. in
a construction of a T-PAKE protocol in Section 4, the above secu-
rity deﬁnition needs to be strengthened by allowing the adversary
435to learn whether honest user sessions output some reconstructed
secret or reject. Intuitively, whenever any application employs a
PPSS scheme to reconstruct a secret, it uses this reconstructed se-
cret in some higher-level protocol, e.g. in the case of a T-PAKE to
authenticate a key exchange, thus allowing a network adversary to
learn whether the PPSS subprotocol accepted or rejected, as in the
latter case the protocol built on top of PPSS will visibly diverge
from its usual course. Formally, a PPSS scheme on dictionary D
and secret space S is (n, t, T, qU , qS, )-strongly secure if it satis-
ﬁes the (n, t, T, qU , qS, )-security deﬁnition above with the user
oracle User(cid:5) modiﬁed so that for every User(p, st0) instance the
adversary learns a bit which indicates whether this instance accepts,
i.e. outputs some s(cid:48) (cid:54)=⊥, or rejects, i.e. outputs ⊥.
A practical PPSS scheme should satisfy two further properties,
namely robustness and soundness. Robustness requires that a user
communicating with n servers recovers the shared secret as long as
at least t + 1 of these servers follow the protocol. Soundness re-
quires that even n corrupt servers cannot cause a user using the pre-
scribed public parameters st0 to recover a secret which is different
from the one which was initially shared. We differentiate between
weak soundness, where this is required only for a user entering the
correct password, and strong soundness, where this is required for
any password the user enters, including incorrect ones. Formally a
PPSS scheme on dictionary D and secret space S is (T, )-robust if
for any (s, p) ∈ S×D, any B s.t. n−|B| ≥ t+1, and any algorithm
A with running time T , the probability that s(cid:48) (cid:54)= s where st is out-
put by Init(p, s) and s(cid:48) is output by User(p, st0) interacting with
A(s, p, stB) and Server(cid:5)(stB), is bounded by . To formally deﬁne
soundness we say that a PPSS scheme on dictionary D and secret
space S is (T, )-sound if for any (s, p, ˜p) ∈ S × D × D and any
algorithm A with running time T , the probability that s(cid:48) (cid:54)∈ {s,⊥}
where st is output by Init(p, s) and s(cid:48) is output by User(˜p, st0)
interacting with A(s, p, ˜p, st), is bounded by . We deﬁne weak
soundness in the same way but restricting ˜p to ˜p = p.
3. PPSS PROTOCOL SECURE UNDER DDH
We describe the protocol for password protected secret sharing.
We start by introducing the basic idea of our scheme, which can
use any threshold homomorphic encryption. We then explain how
to reduce the round complexity of this basic protocol using special
properties of ElGamal. The resulting protocol involves only three
message ﬂows between the user and each server (and one round
of interaction in an on-line phase), each message involving con-
stant number of group elements. For exposition’s sake, we ﬁrst
show this protocol secure only against honest-but-curious players,
assuming secure channels (PPSS1 in Figure 2), and then proceed
to explain how we can address active threats and achieve security
against malicious adversaries (PPSS2 in Figure 3).
Basic PPSS Protocol. Our protocol can use any homomorphic
encryption with a threshold decryption protocol, but for the sake
of subsequent modiﬁcations we describe it instantiated with El-
Gamal. Let g be a generator of group G of prime order q. Take
dictionary D = Zq and message space S = G. Note that any
other dictionary can be hashed into Zq using a collision-resistant
hash, and as we discuss later message space G can be easily ex-
tended to a standard message space of ﬁxed-length bitstrings. For
(p, s) ∈ Zq × G, procedure Init(p, s) picks an ElGamal key-pair
(x, y = gx), secret-shares x among servers using a (t, n) secret
sharing [23] (i.e. stj = xj = f (j) where f is a random t-degree
polynomial over Zq s.t. f (0) = x), and outputs public parameter
st0 which consists of public key y, a “shifted” ElGamal encryption
of password p, (cp, dp) = (grp , yrp gp), and a textbook ElGamal
encryption of secret s, (cs, ds) = (grs , yrs s), for random rp, rs
in Zq. The PPSS protocol between the user U on input ˜p and the
servers {Pj}n
j=1 on inputs stj proceeds as follows:
1. U sends an encryption of ˜p, (c ˜p, d ˜p) = (gr ˜p , yr ˜p g ˜p), to each
Serverj. Note that for a legitimate user, ˜p = p.
2. Pj’s randomize (cδ, dδ) = (cp/c ˜p, , dp/d ˜p) by each Pj re-
r← Zq.
turning (cβj , dβj ) = ((cδ)tj , (dδ)tj ) for tj
3. U sends (cβ, dβ) = ((cid:81)n
i=1 βi = δp ·(cid:80)n
(cid:80)n
i=1 cβi ,(cid:81)n
i=1 ti and δp = p − ˜p.
1=1 dβi ) to each Pj. Note
that (cβ, dβ) is an ElGamal encryption of gβ where β =
Note that α = s · g
4. Pj’s threshold-decrypt (cα, dα) = (cs · cβ, ds · dβ) [6], i.e.
each Pj returns zj = (cα)xj and U interpolates any t + 1 of
these zj’s to z = (cα)x and outputs α = dα · (z)−1.
(cid:80)
i βi = s · g(p− ˜p)(cid:80)
˜p = p; but α is random in G if ˜p (cid:54)= p and(cid:80)
servers’ contributions (cβj , dβj ) to (cβ, dβ) so that the sum(cid:80)
i ti. Hence, α = s if
i ti is random in Zq.
This basic PPSS protocol is secure in the honest-but-curious set-
ting under the DDH assumption on G. Moreover we have to as-
sume secure channels between U and each Pj because α = s
can be decrypted from the values (cβ, dβ) and zj exchanged in
the last two messages of this protocol. However, in the presence
of malicious parties, and without secure channels, a whole range
of issues needs to be addressed: For example, since the protocol
relies on the homomorphic property of ElGamal encryption, a ma-
licious user can recover s by setting (c ˜p, d ˜p) as a randomization of
(cp, dp), thus ensuring that ˜p = p without the knowledge of p. In
another example, a single malicious server can cancel out all other
i ti
hits some adversarially chosen value t. (The malicious server sets
its (cβj , dβj ) as an encryption of gt divided by the product of all
other (cβj , dβj )’s.) This way the “ciphertext randomization” step
(2) above fails its purpose of providing a random mask for s in the
case ˜p (cid:54)= p, and the value α = s · gt( ˜p−p) which the user outputs
allows the adversary to recover s in an off-line dictionary attack.
On-Line Non-Interactive PPSS Protocol. Before addressing the
active threats, we observe that relying on speciﬁc properties of El-
Gamal Encryption, we can shave off one communication round in
the above protocol, by combining the distributed ciphertext ran-
domization step (i.e. step 2) and the threshold decryption step (i.e.
step 4), given some precomputation from the Servers. The result-
ing protocol (Figure 2 below) involves only three communication
ﬂows, with the on-line phase, i.e. between User contributing its
password ˜p and recovering the secret s, taking only two communi-
cation ﬂows (hence the term non-interactive on-line).
(cid:80)
(cid:80)