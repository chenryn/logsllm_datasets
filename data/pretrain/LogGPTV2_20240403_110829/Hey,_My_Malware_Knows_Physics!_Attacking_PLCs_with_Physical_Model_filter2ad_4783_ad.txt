to the HMI allow the operator to observe the system state.
When the PLC is power-cycled, an LED sequence is
generated where each LED associated to the embedded I/O
is sequentially blinked, starting from the Input Ports to the
Output Ports. This sequence is relatively slow and involves a
sleep period. This allowed us to halt the processor in between
two LEDs being blinked. After stepping through the LED
sequence, we were able to determine the subroutine associated
with sending the LED values over I2C. Additionally, we
identiﬁed the address where the I/O values are stored before
they are sent to the LEDs. We conﬁrmed this by modifying the
associated registers (while the CPU was halted) and stepping
through to force arbitrary values different from the typical LED
sequence. Although this conﬁrmed that we could control what
values were being sent to the LEDs, we still needed to take
control of the interchange between the LEDs/HMI and the
GPIO Ports.
7
We found that the main loop has one reference to this
LED update function. We noticed that before this update
function, a few timer interrupts were being disabled. Using
the information from the re-based NVIC table as well as the
data sheet, we were able to ﬁnd the associated ISRs located
in SRAM. In particular we found that the Timer 0A ISR was
responsible for the interchange between the GPIO Pins and the
LEDs/HMI.
As described in Section II-A PLCs operate on the basis of
so-called scan cycles, i.e., in ﬁxed intervals inputs are read,
the control logic is executed, and the results are written back.
We are careful to identify this main loop as being directly
correlated to the scan cycle. The Timer 0A ISR seems to be
independent of the scan cycle as it is set to run every 0.25 µs.
It is only interrupted when updating the LED values. Because
this process has not been fully reverse-engineered, we cannot
make much stronger inferences than those already mentioned.
C. I/O Interception Code Modiﬁcations
As described in the previous section, we identiﬁed the exact
two subroutines where the values from GPIO Ports E and F are
being forwarded to the PLC memory associated with the input
values, i.e., the input values sent to the control logic program,
the LEDs and the HMI, as well as where the output values
from the PLC memory are forwarded to the associated output
memory for the LEDs, HMI, and GPIO Ports G and H.
For the output update routine, HARVEY uses the physical
models to send legitimate-looking data to the LEDs/HMI,
and sends malicious values to GPIO Ports G and H. For the
input update routine, HARVEY uses the legitimate input data
from GPIO Ports E and F to update the malicious model and
possibly coordinate with the output modiﬁcations. HARVEY
again uses the physical models to report legitimate-looking
input values to the LEDs/HMI. The input values, which the
control logic might report, e.g., to the system operator, can be
crafted such that they correspond to the observation HARVEY
makes on the control logic’s output, as described in Section IV.
I/O Interception Details. In order to implement our attacks,
we modiﬁed two subroutines within the Timer 0A ISR that are
responsible for the interchange of values to and from the GPIO
Ports. Figure 5 shows the aforementioned ﬁrst attack scenario
where we reported false output values to the LEDs and HMI.
The ﬁgure shows the original subroutine that was responsi-
ble for forwarding an updated output value from memory to the
GPIO Ports G and H. The subroutine ﬁrst updates the address
corresponding to the LED and HMI output, =LED Output, and
then calculates the correct values to send to the GPIO Ports.
For our attack, we ﬁrst modiﬁed an arbitrary location of usable
(or re-usable) memory in SRAM and injected our malicious
assembly code. Once the malicious code was written, we
modiﬁed the subroutine to branch to our malicious code. The
malicious code would then branch back to the subsequent
instructions once the appropriate values were modiﬁed. In our
attack scenario, a safe system state with Output Port 0 high
would have a “0” at the least signiﬁcant bit, representing the
0 port, and the rest of the bits would be set to 1, i.e., a value
of 0xFFFFFFFE. In our attack, we want to set Output Port
0 to low and Output Port 1 to high, i.e., write a value of
0xFFFFFFFD to the associated memory address. We chose to
branch to an arbitrary memory location to prove that we can
make use of the available memory to implement more complex
attacks. Figure 6 shows the second attack implemented in a
similar fashion.
Fig. 5: Original GPIO-output update ISR assembly code com-
pared to modiﬁed subroutine with branch to malicious code.
Fig. 6: Original GPIO-input update ISR assembly code com-
pared to modiﬁed subroutine with branch to malicious code.
In this case, the goal was to fake the input values being sent
to the LED’s/HMI as well as the actual ladder logic program
running on the PLC. With no inputs, the expected value would
be 0xFFFFFFFF. In our attack, we disregard the values read
from the GPIO Ports E and F and simply wrote a value of
0xFFFFFFFC to the input LEDs, setting Input Port 0 and Input
Port 1 to high.
D. Firmware Update
We believe that the built-in remote ﬁrmware update func-
tionality of PLCs is the most likely method for an attacker to
compromise a device. This is based on observations in related
work that ﬁrmware updates are not protected against malicious
modiﬁcations [7], [44]. For our PLC model, the situation is
different. Firmware updates are protected by cryptographic
means. Firmware updates are delivered together with certiﬁ-
cates in the X.509 standard [16]. The certiﬁcate contains a
SHA-1 [37] hash of the ﬁrmware binary ﬁle and is signed
with 1024bit RSA [41]. Although the certiﬁcate is self-signed,
the PLC will abort the update process when provided with a
self-signed certiﬁcate using a different key than the original
one. This makes it practically impossible for an attacker to
change the ﬁrmware and install it on the PLC. To succeed,
8
the attacker has two options, (1) he could attempt to ﬁnd a
pre-image hash collision for the SHA-1 hash of the benign
ﬁrmware binary, or (2) he could factorize the public key used
to sign the certiﬁcate.
However, an attacker can always compromise a device
through the JTAG interface, like we did.
VI. EVALUATIONS
We evaluated several aspects of HARVEY. On one hand,
we evaluated the effects of HARVEY on the individual pro-
grammable logic controllers (PLC), its inﬂuence on execution
times and its memory consumption. On the other hand, we
evaluated HARVEY in a real-world power system to empirically
prove that HARVEY can (1) maximize the effects on the
physical system, and (2) hide its malicious effects from the
operator.
A. PLC Evaluation
Our PLC model is equipped with an ARM Cortex-M3
processor with 64KB RAM [49]. It has 512KB memory for
user programs (control logic), as well as 16 DC digital inputs
and 16 DC digital outputs.
Experimental Setup. To evaluate the effects of HARVEY
on a PLC we set
logic.
We installed a control
logic program for a PID (propor-
tional–integral–derivative) controller which is shipped by the
vendor of our PLC as a standard control logic instruction used
in many environments.
it up with a typical control
In order to model fake input and output values, we used a
custom implementation of a PID controller. Figure 9 shows an
extract of its assembler code. The code represents a sample
PID update function that takes in the current system error
and the difference in time since the last iteration and updates
the control output based on the summation of the scaling
terms. These scaling terms are determined by the type of PID
controller. In this case, we deﬁned proportional, derivative
and integration error terms to be summed for the control
output. A windup guard is used to set a maximum value for
the integration term. We compiled this code using a pre-built
GNU toolchain for ARM Cortex-M3 processors as well as the
StellarisWare libraries for our processor.
To validate the modiﬁcations of HARVEY we had to
compare the physical outputs of the PLC with the information
provided to the operator. To measure the physical output of the
PLC we wired it to a voltmeter. To determine the operator’s
view of the system state, we used the built-in LEDs of the
PLC as well as the online monitoring provided by the vendor’s
control logic development suite, which we will refer to as our
HMI. The PLC has a dedicated LED per input and output pin
which lights up according the logical state of the pin, i.e., when
there is current on the pin the LED will turn on, otherwise,
the LED will be off. On the HMI side, online updates of the
downloaded control logic program are displayed in real-time.
We used HARVEY to break the relationship between the
displayed system state and the actual inputs and outputs on
the physical pins of the PLC.
Attack. We were able to change the LED and HMI states of the
PLC arbitrarily and independently of the state of the input and
output pins. Similarly, we were able to set the output values
of pins regardless of the commands sent by the control logic.
Fig. 7: Feasibility Analysis: Performance Overhead
Execution Time. To evaluate the performance of HARVEY, we
measured its execution time and compared it to the execution
time of the PID control logic. The measurements are provided
in Figure 7, depending on the mode the PID control logic takes
between 31.03µs and 31.74µs. The timer A0 interrupt handler,
which controls the input/output interchange between the GPIO
ports and the LEDs/HMI, takes only 0.25µs, which is two
orders of magnitude faster. Our attack code, which implements
a simple relay logic, takes only 0.18µs.
As described in Section II-A PLCs work in scan cycles.
This means inputs are read and outputs are written at a ﬁxed
rate, while the control logic gets executed in between. The
control logic execution time may not exceed the scan cycle
length, otherwise it gets interrupted. Usually, the execution
time of control
logic is well below the length of a scan
cycle. This means that HARVEY can utilize the time difference
between control logic execution length and scan cycle length.
If the unused time of a scan cycle is not sufﬁcient for
HARVEY, there are several potential solutions that can be
implemented to inﬂuence the length of a scan cycle. For
instance, HARVEY’s periodic execution depends on a timer
interrupt conﬁguration. Because HARVEY is executing within
the ﬁrmware, the timer interrupt conﬁguration can be modi-
ﬁed to better suit the attacks needs. Similarly, the reporting
mechanisms for the control logic/HMI also depend on the
timer interrupt conﬁgurations that are implemented within the
ﬁrmware. Therefore, there are several permutations of an attack
vector that would allow HARVEY to execute in a timely fashion
with a reasonable amount of independence from the scan cycle
duration.
Memory Consumption. Our PLC has a ﬁnite amount of
memory which must be shared between the benign ﬁrmware
and HARVEY. Although the ﬁrmware initially occupies most
parts of the memory, large parts are never used. These sections
were determined during our online analysis. Furthermore, we
examined subroutines that were no longer called after the ini-
tial boot sequence. Once the PLC reached the aforementioned
main loop, we were able to identify the subset of subroutines
that were called by the PLC during the boot sequence but
were no longer referenced within the main loop. We refer
to this memory as reusable memory. We veriﬁed that these
functions were no longer used by setting breakpoints at the
function addresses as well as any referenced locations within
the subroutine. We consider unused memory as memory parts
which contain regular patterns that indicate that the memory
is not used, for instance, memory sections ﬁlled with all
0x00000000 or all 0xFFFFFFFF. Additionally, we found large
chunks of memory that contain what seems to be garbage code
that is never referenced throughout the ﬁrmware execution.
For the practical feasibility of HARVEY, Figure 8 lists
9
31,7431,030,180,2505101520253035PID (DINT)PID (REAL)Relay Logic AttackCodeTimer 0A InterruptExecution Time (µs)Fig. 8: Available Memory vs. Malware Size
the memory consumption of the PID control logic as well as
reusable and unused memory in the ﬁrmware. It also shows
the memory consumption of the custom PID update function
we used as the adversary’s system model in our setup.
HARVEY can utilize the unused memory as well as the
reusable memory parts, which is signiﬁcant portion of the
PLC’s memory (56.033Bytes out of 65.536Bytes).
B. Real-World Power System Case Study
We evaluated HARVEY on a real-world power system test-
bed, where distributed PLCs with installed PID modules along
with more complicated control algorithms (discussed below)
maintain safe power system operation.
The electricity grid is modeled using the mathematical
power ﬂow equations (physical Kirchhoff laws):
i = −Pg
f p
i + Pl
i + ∑
k∈C
|Vi||Vk|(Gik cosθik + Bik sinθik),
(3)
which mandate how the sensor measurements (e.g., real/re-
active power values on i-th power node (bus) Pi/Qi, power
bus voltages Vi, inter-bus phase angles θi j, and the admittance
(inverse resistance) parameters (Gi j,Bi j) on the transmission
line between the buses i and j correlate due to well-known
physics Kirchhoff laws. Pg
represents the amount of power
i
that is injected to the i-th power bus by a generator, and Pl
i is
the amount that is consumed by the end-users at that bus.
Optimal power ﬂow (OPF) is the most widely used control
algorithm that is used in practice nowadays to calculate the op-
timal control commands continuously. In power systems, OPF
ﬁnds an optimal power generation set-point that minimizes
total cost c while meeting operational safety constraints [2].
The control commands typically include power output (set-
points) of generators [19]. The OPF’s equality constraints are
the power balance equations at each bus in the system. Its
inequality constraints are the network operating safety limits
such as line ﬂow capacities and generator power output limits:
min
u
s.t.
|Vi||Vk|(Gik cosθik + Bik sinθik)
|Vi||Vk|(Gik sinθik − Bik cosθik)
k
i = ∑
i = ∑
k∈C
c(x,u)
i − Pl
Pg
i − Ql
Qg
l ≤ Pgmax
Pg
∀i, j ∈ N, ∀l ∈ G, ∀k ∈ C
l
(4)
where u denotes the controls commands to be calculated; x
represents dependent variables; V and θ denote the bus voltage