title:CHEX: statically vetting Android apps for component hijacking vulnerabilities
author:Long Lu and
Zhichun Li and
Zhenyu Wu and
Wenke Lee and
Guofei Jiang
CHEX: Statically Vetting Android Apps for
Component Hijacking Vulnerabilities
Long Lu†
†College of Computing, Georgia Institute of Technology
Zhichun Li‡
Zhenyu Wu‡ Wenke Lee† Guofei Jiang‡
{long, wenke}@cc.gatech.edu
{zhichun, adamwu, gfj}@nec-labs.com
‡NEC Labs America, Inc.
ABSTRACT
An enormous number of apps have been developed for Android
in recent years, making it one of the most popular mobile operat-
ing systems. However, the quality of the booming apps can be a
concern [4]. Poorly engineered apps may contain security vulner-
abilities that can severally undermine users’ security and privacy.
In this paper, we study a general category of vulnerabilities found
in Android apps, namely the component hijacking vulnerabilities.
Several types of previously reported app vulnerabilities, such as
permission leakage, unauthorized data access, intent spooﬁng, and
etc., belong to this category.
We propose CHEX, a static analysis method to automatically
vet Android apps for component hijacking vulnerabilities. Mod-
eling these vulnerabilities from a data-ﬂow analysis perspective,
CHEX analyzes Android apps and detects possible hijack-enabling
ﬂows by conducting low-overhead reachability tests on customized
system dependence graphs. To tackle analysis challenges imposed
by Android’s special programming paradigm, we employ a novel
technique to discover component entry points in their completeness
and introduce app splitting to model the asynchronous executions
of multiple entry points in an app.
We prototyped CHEX based on Dalysis, a generic static analysis
framework that we built to support many types of analysis on An-
droid app bytecode. We evaluated CHEX with 5,486 real Android
apps and found 254 potential component hijacking vulnerabilities.
The median execution time of CHEX on an app is 37.02 seconds,
which is fast enough to be used in very high volume app vetting
and testing scenarios.
Categories and Subject Descriptors
D.2.4 [Software Engineering]: Software/Program Veriﬁcation—
Validation; D.2.5 [Software Engineering]: Testing and Debug-
ging—Code inspections and walk-throughs
General Terms
Security
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.
Keywords
Static analysis, app splitting, component hijacking vulnerability
1.
INTRODUCTION
Android has gained tremendous popularity in recently years,
with over 100 million activations globally [22]. Part of the success
should be attributed to Android’s easy-to-join application develop-
ment community. More than 400k apps are available in the ofﬁcial
Android Market, yielding 10 billion accumulative installations by
the end of 2011 [3]. Alternative markets also play a big role in
hosting and distributing a large number of apps. Most apps were
developed and released in the last three years.
As large numbers of new apps, including newly updated ver-
sions, are constantly submitted to app markets and become in-
stantly available for users, we believe it is critical to provide a scal-
able vulnerability ﬁltering system for app market operators. Before
apps are released, the system quickly vets the apps for potential
security vulnerabilities and provides warning messages to help the
developers generate ﬁxes. Apparently, such systems should scale
well in face of a high input volume and have reasonably low false
positive rates to be useful. Therefore, we advocate a static analysis
based approach, as opposed to dynamic ones, for its complete code
coverage and scalability.
In this paper, we propose CHEX1, a static app vetting tool for
component hijacking vulnerabilities. Such vulnerabilities are found
in apps that implement access control improperly on external re-
quests or accidentally leak private data or privileges. In general,
these vulnerabilities are exploited to carry out unauthorized read
or write operations on sensitive resources. Therefore, we trans-
form the detection problem into an equivalent data-ﬂow problem
that seeks to identify the existence of hijack-enabling ﬂows in apps.
Component hijacking vulnerabilities include, but are not limited to,
several previously reported vulnerabilities, such as permission re-
delegation and leakage [20, 21], intent spooﬁng [10], and private
data leakage (e.g. login credentials).
Our work makes three folds of contributions. First, we designed
a sound method that automatically discovers all types of app en-
try points at a low false rate, whereas previous works primarily
use simple domain knowledge and only ﬁnds the common entry
point types. Second, in order to efﬁciently model interleaved exe-
cutions of multiple entry points and track data-ﬂows crossing them,
we propose the concept of app splitting, which generates and per-
mutes data-ﬂow summaries of each split2. The existence of hijack-
1CHEX stands for Component Hijacking Examiner.
2A term we deﬁned to describe a fragment of code reachable from
a single entry point
229app can easily take advantage of (or hijack) the Enumerator
Service and consequently gain access to user’s contacts without
the required permission. Recent works [11, 20, 21, 27] reported at-
tacks similar to this particular example, all of which derive from the
classic confused deputy attack [23] and aim at escalating privileges
of attacking apps in the context of Android’s permission system.
Note that, although permission-protected resources (e.g. contacts,
geo-location, and etc.) are obvious targets, component hijacking is
by no means limited to these confused deputy attacks that bypass
the permission checks. In fact, if carelessly exposed, data or invok-
able interfaces that are only intended for app’s internal use (thus
not permission-protected) can also become targets of component
hijacking attacks. In this case, where no explicit permission is in-
volved, the attacking app seeks to tamper or steal private data of a
vulnerable app that does not enforce access control or input valida-
tion properly. For instance, in Figure 1, the security-critical infor-
mation stored in the app internal database can be tampered through
the Setting Update Receiver in an SQL-injection fashion.
Complicated cases exist, where an attacker can leverage a chain
of vulnerable components to steal private data, modify critical set-
tings, or perform privileged actions, by simply issuing crafted re-
quests as a regular app.
Several topics related to component hijacking were studied by
recent works. ComDroid [10] checks app metadata and API usages
for publicly exported components. Such components, if granted di-
rect or indirect access to sensitive resources, may become launch-
ing points for hijacks. Grace et al. [21] analyzed factory stock apps
to identify permission leakage, a threat that also spurred studies on
its runtime mitigations [8, 12, 20]. While these works are effective
in archiving their own goals, they target at the vulnerabilities that
only represent a subset of component hijacking (i.e. hijacks seek-
ing to access non-permission-protected sensitive resources are not
covered). Plus, these works do not intend to provide any in-depth
detection method suited for scalable app vetting. Our work aims to
bridge this gap.
It is noteworthy that component hijacking vulnerability is not
caused by any insecurity intrinsic to Android framework. In fact,
Android does provide a set of mechanisms to secure app compo-
nents and their interactions. Instead, similar to other security vul-
nerabilities in software, component hijacking stems from issues
that are hard to avoid in reality, such as undertrained developers,
lacks of proper app quality assurance, and usability issues of ex-
isting security mechanisms. We expect component hijacking vul-
nerability to emerge rapidly in terms of popularity and severity. As
the user population of Android constantly grows, more and more
developers are migrating to this platform, often with inadequate ex-
perience or knowledge on its security mechanisms. In addition, the
current app distribution model offers a convenient way for amateur
developers to release their apps to a wide range of users. With these
factors adding up, the odds becomes high for a regular Android user
to install apps that insecurely handle external requests and thus are
subject to component hijacking. Attackers who are now struggling
with crafting new exploiting techniques on Android would not eas-
ily let this new attacking vector pass by.
Apps with component hijacking vulnerabilities are generally not
malicious on their own, but can be coerced by attacking apps to
conduct malicious activities. Defensive efforts may focus on either
ﬁnding the vulnerabilities in benign apps, or detecting correspond-
ing exploits from suspicious apps. Our work follows the ﬁrst ap-
proach for the more distinguishable and less volatile nature of the
Figure 1: An app vulnerable to component hijacking
enabling data-ﬂows is checked by means of a reachability analysis
on customized system dependence graphs [25] that capture the vari-
able dependencies globally. Finally, we built CHEX, an in-depth
and scalable static app vetting tool for component hijacking vul-
nerabilities. We exercised CHEX with 5,486 popular free Android
apps collected from both the Ofﬁcial Android Market and alterna-
tive Android markets. The median execution time of CHEX on an
app is 37.02 seconds, which is fast enough to be used in very high
volume app vetting and testing scenarios. Among all tested apps,
254 were found to have hijack-enabling ﬂows. Our manual val-
idation on all these suspicious apps shows a true positive rate of
81%. We also conducted detailed case studies on the vulnerable
apps we uncovered, providing practical insight into the vulnerabil-
ity and possible exploits. CHEX is based on Dalysis, our static anal-
ysis framework that directly consumes off-the-shelf Android apps
in bytecode form and supports various types of program analysis
tasks.
The rest of the paper is organized as follows. We study the com-
ponent hijacking problem and present our analysis method in Sec-
tion 2 and 3, followed by the implementation and evaluation of
CHEX and Dalysis in Section 4 and 5. In Section 6, we discuss lim-
itations of our work and possible workarounds. We survey related
work in Section 7 and conclude the paper in Section 8.
2. COMPONENT HIJACKING PROBLEM
Android framework dictates a component-based approach to
app design, for ﬂexible interoperability among apps and efﬁ-
cient app lifecycle management.
In this approach, app develop-
ers organize their code into individual application components [6]
(i.e. Activities, Services, and etc.). Each component ful-
ﬁlls a logically independent task and can serve requests from other
components in the same app, the framework, or another app if the
component is publicly available (or is exported, in Android termi-
nology). For example, an instant messaging app may need a con-
tact enumerator (i.e. collecting all contacts on the device) to suggest
friends for the user. Instead of implementing its own, the app can
leverage an existing contact enumerator component exported by a
contact manager app.
However, the capability of reusing a component under its con-
taining app’s identity can lead to serious security threats, when the
component is security-critical but not well protected. To generalize
threats of this kind, we introduce the concept of component hijack-
ing, describing a class of attacks that seek to gain unauthorized
access to protected or private resources through exported compo-
nents in vulnerable apps. As shown in Figure 1, if the contact man-
ager app fails to deny requests from unauthorized apps, a malicious
Contact Manager AppSetting Update ReceiverEnumerator ServiceContactProviderNetwork InterfacePermission-protectedResources                       Read_Contacts                             InternetPermissions:Receiving external requestsAppFrameworkValueVoIP_PreﬁxKeyfalseIs_App_Lisenced"1234".........App internal DB(non-permission-protected)230subject being detected, than that of the second one. Without loss of
generality, we deﬁne component hijacking attacks as follows:
DEFINITION 1. An unauthorized app, issuing requests to one
or more public components in a vulnerable app, seeks to:
G1 : READ sensitive data out of the app; or
G2 : WRITE to critical data region inside the app; or
G3 : perform a combination of G1 and G2.
Based on this deﬁnition, to determine if a given component (or
set) is vulnerable to hijacking is equivalent to ﬁnding feasible data
ﬂows that can enable any of the three goals above without going
through any security checkpoint. We refer to these ﬂows as hijack-
enabling ﬂows hereafter.
In a simple example, the Emulator
Service in Figure 1 is vulnerable if a hijack-enabling ﬂow exists
that fulﬁlls G1: the ﬂow propagates the contact list into an object to
be returned to the requestor, serving as a data sink from which the
requestor (or attacking app) can read data directly. In a more com-
plex scenario, the data sink may not seem immediately accessible
to the requester (e.g. sending contact to an URL, as shown in Fig-
ure 1). However, if the component contains a hijack-enabling ﬂow
that writes requester-supplied input into certain output-controlling
data (e.g. the destination URL), requestors can still indirectly read
the contact information by redirecting the output and achieve G3.
Component hijacking is also possible on a chain of components,
when the hijack-enabling ﬂows span across component boundaries.
Deﬁning component hijacking from a data ﬂow perspective al-
lows us to transform the vulnerability detection problem into an
equivalent data ﬂow analysis problem. A different but related topic
is data leakage detection [15, 24], which looks for individual data
ﬂows that indicate sensitive data being propagated out of certain
containment scope. Note that apps sending out sensitive data are
not necessarily exploitable nor harmful (e.g. an app sends users’
GPS information to remote servers for location-based services).
Therefore, data leakage detection only reports outbound sensitive
data ﬂows without clarifying their security implications. In con-
trast, component hijacking vulnerability is always exploitable and
undermines user’s privacy. On the other hand, techniques for iden-
tifying component hijacking vulnerability can be applied to ﬁnding
data leaks, but not vice versa. Because ﬁnding data leaks are essen-
tially identifying special hijack-enabling ﬂow that enable G1 with
all data sinks supposed to be accessible by attackers.
Component hijacking gives attackers the freedom to surrepti-
tiously perform privileged actions and access private data. In our
threat model, successful hijacks require users to willingly install
the attacking app on their devices. To create a user population of
decent size, attackers can resort to many illicit techniques that pro-
mote their apps in the market and lure users. Given component
hijacking apps often requesting little to no permissions, users, even
vigilant ones, tend to trust them easily. Although attackers cannot