check whether I violates ϕ and detect the underlying semantic
bug. CHIRON achieves this objective by extracting the imple-
mented FSM (E-FSM) from I and model checking it against
ϕ. CHIRON also ensures that each reported semantic bug is
indeed reproducible in an actual execution of I.
Extracted protocol FSM (E-FSM). We deﬁne an E-FSM M
as a tuple hQ, Ev, A, V, qI , Ri. Q is a ﬁnite set of states
{q0, . . . , qn}, and qI ∈ Q is the initial state of the E-FSM M .
We use Ev to denote a ﬁnite set of network events (e.g., recv,
which means the arrival of a network packet) and A to denote
a ﬁnite set of high-level actions the protocol can perform
utilizing the underlying socket functions of the protocol stack
(e.g., send ack, which means sending an acknowledgment).
Let V be a ﬁnite set of program variables. We assume that
Ev, A, and V are pairwise disjoint.
Let R be the transition relation such that R ⊆ Q × Ev ×
C × 2A × Q, where C represents a set of transition conditions
such that each element c ∈ C is a quantiﬁer-free ﬁrst order
logic (QF-FOL) formula [19] over V. If V = {x, y}, then c
can be, for instance, x ≥ 0 ∧ x + y 6= 10. Since transitions are
conditioned on the variables in V, we call them conditional
variables. In addition, each atomic formula of the transition
condition (e.g., x ≥ 0) is called an atom. Given a transition
hqa, recv, buf len 6= 0 ∧ buf[0] = 255, {send ack}, qbi, it
signiﬁes that if the protocol implementation is currently at
state qa, the event recv is triggered, the receive buffer is not
empty (i.e., buf len 6= 0), and buf’s ﬁrst byte is 255, then the
implementation performs the action send ack and moves to
state qb.
III. DESIGN OF CHIRON
In this section, we ﬁrst give an overview of CHIRON’s
design followed by the details of its major components.
A. Overview
CHIRON’s workﬂow consists of three major steps as shown
in Fig.2. Given the protocol source and some meta-information
(conﬁguration ﬁles), the FSM extractor (❶) extracts the E-FSM
Conf
Protocol
Src
Conf
ProtocolStack
Property List
FSM 
1
Extractor
E-FSM 
FSM 
Translator
Model
P,Q,R 
Propositions
CEX
CEX Parser
CEX
Property  
CEX Validator
3
Consistent CEX
Spurious
CEX Checker
CEX
Replayer
P∧Q→R 
Invariants
Realizable
CEX
Model
Checker
2
Unrealizable 
CEX 
(false alarm)
Reported CEX
(semantic bug)
No Violation
Detected
Fig. 2: CHIRON’s workﬂow
(say M ) of the protocol by leveraging symbolic execution. The
details will be described in §III-B. Appendix A presents a brief
introduction to symbolic execution.
Next, CHIRON utilizes a model checker (❷) that takes
M and a temporal property (ϕ) of the protocol expressed
as a propositional linear temporal logic (pLTL) formula [20].
Thus CHIRON tries to ﬁnd an execution of M that violates
ϕ. If a violation is detected, the model checker generates a
counterexample (CEX) as evidence, which is essentially an
execution of the protocol demonstrating the violation.
To employ any pLTL model checker with CHIRON, the
FSM translator takes M as input and translates it to a high-
level modeling language (e.g., SMV [21]). Note that
the
conditions associated with the transitions of M are QF-FOL
formulas over conditional variables, e.g., (x > 0)∧(x+y = 5).
As pLTL model checkers expect the transition conditions to be
boolean formulas, the translator maps each unique atom (e.g.,
x > 0) in the conditions to a unique propositional variable
(say, P ) and stores the mappings in an atom-proposition map
ﬁle, which is used later to automatically translate a temporal
property ϕ in pLTL (see §III-C).
Due to the incompleteness of symbolic execution (e.g., for
unrolling loops for a small number of iterations to achieve
termination [22], [23]) and due to the level of abstraction used
in our analysis, the CEX generated by the model checker may
not always be realizable in an actual execution of the given
implementation. To rule out such unrealizable CEXs (i.e.,
false alarms), CHIRON uses a 2-step CEX validation technique
(❸). If a CEX passes both validation steps, CHIRON reports
the CEX to the user as a realizable CEX which points out the
underlying semantic bug causing the violation of ϕ (§III-D).
One additional module is employed by CHIRON: the CEX
parser which interfaces the model checker with the CEX
validator. It parses a CEX generated by the model checker and
uses the atom-proposition map ﬁle to replace each proposition
in the CEX with its corresponding atom. For instance, if the
map ﬁle contains the mapping P 7→ {x > 0} and the CEX has
P 7→ false, then the parsed CEX becomes (x > 0) 7→ false.
The CEX validator inspects this parsed CEX (§III-D).
B. FSM Extraction
We now describe our E-FSM extraction algorithm.
Required meta-information. CHIRON needs the protocol
source and two conﬁguration ﬁles (meta-information) from
the developer for extracting the E-FSM: one is speciﬁc to the
protocol stack and the other is speciﬁc to the implementation.
The conﬁguration ﬁle speciﬁc to the protocol stack contains
information about all possible network events (e.g., arrival of a
packet, new connection, disconnection) that the protocol reacts
to. For instance, if the protocol under analysis runs on top of
TCP, CHIRON requires the list of network events that TCP
can trigger. Obtaining such a list of network events for the
underlying protocol stack is a one-time effort because the same
list can be reused for other protocols developed for the same
protocol stack. Such a list of events is often standardized for
the protocol stacks of popular operating systems (e.g., Linux,
Windows) and well-documented for newer stacks such as uIP
and FNET for IoT devices.
The conﬁguration ﬁle speciﬁc to the protocol implementa-
tion consists of: (i) the names of the state variables that encode
the protocol’s state (e.g., state in struct SSL); (ii) the name of
the event dispatcher function (i.e., the entry point to the event
handling code); (iii) the names of the conditional variables
(e.g., the packet buffer buf), which should be considered in our
analysis as variables that will use symbolic values; and (iv) a
list of haction name, identiﬁeri pairs for each high-level action
performed by the protocol (e.g., sent client hello). Requiring
users to provide such meta-information is a common practice
to conduct symbolic execution of network protocols [22],
[24]. Note that CHIRON’s FSM extraction is agnostic to how
the meta-information is obtained. Automatically extracting the
meta-information with higher accuracy is left as future work.
The provided action list is not necessarily an exhaustive
the developer is free
list of all protocol actions. In fact,
to specify the necessary actions relevant
to the analysis.
Hence, we provide a simple API (void set_action (int
identifier);) that the developer can leverage to annotate
the source code to indicate each desired protocol action. One
of the beneﬁts of this list is that it makes the E-FSM easy to
comprehend. In addition, selecting conditional variables may
seem difﬁcult. Therefore, we apply a rule of thumb and that
is to select any input or environment variables (e.g., packet
buffer) that can inﬂuence the state transition of the protocol.
Algorithm. Our algorithm (Algorithm 1) constructs the E-FSM
M by searching for new FSM states and transitions in a
breadth-ﬁrst search (BFS) manner. While BFS is memory
inefﬁcient, it can ﬁnd new states in a shorter time and can
also be parallelized. Our algorithm begins by constructing the
initial program state e0, which contains initialized values for
both protocol state variables and other global variables. It then
extracts the initial protocol state q0 from e0 using the function
ExtractFsmState, which returns the underlying protocol state
consisting of the values assigned to the state variables in the
given program state. It marks q0 as seen (i.e., old) and adds
it to M . It then adds e0 to a working queue We.
The algorithm then processes each program state ei ∈ We,
one at a time in FIFO manner, until We is empty. It ﬁrst ex-
tracts the associated protocol state qi from ei and then applies
all events to ei. For each event τ , it symbolically executes
the implementation starting from the event dispatcher function
by simulating the occurrence of τ . The symbolic execution
returns all possible paths where each path is summarized by
its associated program state ej , path constraints on conditional
variables c, and actions a performed by the protocol. For each
possible path and its associated hej, c, ai, the algorithm ﬁrst
extracts the protocol state qj from ej . If qj is new, it inserts
qj into M , marks qj as seen, and adds ej to We. Finally, it
τ,c,a
−→ qj . If not,
checks whether it has seen the transition qi
the algorithm adds it to M and marks it as seen. Once We
becomes empty, the algorithm returns M as the E-FSM.
Protocol state driven path exploration. Traditional symbolic
execution of a protocol
implementation using an off-the-
shelf symbolic execution tool can lead to path explosion as
the tool aims to explore as many (possibly new) program
states as possible to achieve a high code-coverage of the
given implementation, often within a limited resource budget.
Consequently, such exploration techniques are not suitable for
our FSM extraction as they are not tailored to give precedence
to the program states that encode new protocol states. We
customize the path exploration technique of symbolic execu-
tion by restricting the exploration to only those program states
that contain new protocol states (line 10 and 17 of Algorithm
1). Thus, we avoid redundant execution paths for the FSM
extraction.
C. Protocol Properties
Due to its proﬁciency in capturing the relative temporal
order of events succinctly, we use pLTL to express the de-
sired protocol behavior. Requiring developers to formulate the
desired temporal properties in pLTL is very inconvenient. In-
stead, we envision developers to write the temporal properties
in SALT (Structured Assertion Language for Temporal Logic)
[25]. SALT is close to a high-level programming language,
containing constructs for frequently occurring property pat-
terns. In addition to being user-friendly and permitting users to
express properties using regular expressions, SALT properties
can be automatically translated to optimized pLTL formulas
using its compiler. All the protocol properties we examined
were written in SALT and then converted to pLTL.
We demonstrate the expressiveness of SALT by con-
sidering the following property from [25]: “In a nor-
mal case, connection open event must be followed by
zero or more receive data events and a connection close
Algorithm 1: FSM Extraction Algorithm
Input: The protocol source S, implementation speciﬁc
conﬁguration C, protocol stack conﬁguration N
Output: The implemented FSM M of the protocol
//q0 : initial protocol state
//M.Q : set of states
//M.qI : initial state
//M.R : set of transitions
1 Queue We ← ∅; FSM M ← ∅;
2 Create initial program state e0;
3 q0 ← ExtractFsmState(e0);
4 We.enqueue(e0);
5 M.Q ← {q0};
6 M.qI ← q0;
7 M.R ← ∅;
8 Mark state q0 as old;
9 while We 6= ∅ do
10
ei ← We.dequeue();
qi ← ExtractFsmState(ei);
foreach Event τ ∈ EventList do
11
12
13
14
15
16
17
18
19
20
21
22
Sq ← SymbolicExecution(S, C, N, ei, τ );
foreach hej, c, ai ∈ Sq do
qj ← ExtractFsmState(ej);
if qj is not old then
We.enqueue(ej);
M.Q ← M.Q ∪ {qj};
Mark state qj as old ;
if Transition hqi, τ, c, a, qji is not old then
M.R ← M.R ∪ {hqi, τ, c, a, qji};
Mark transition hqi, τ, c, a, qji as old ;
23 return M
event unless a reset event occurs, which makes the re-
trivially satisﬁed”. This can be expressed in
quirement
SALT as: assert / connection_open; receive_data*;
connection_close/ accepton reset. Its pLTL counter-
part is expressed as:
(connection_open ∨ reset) ∧ ((  ((receive_data ∨
reset) U (connection_close ∨ reset))) ∨ reset).
For model checking, we need the properties in pLTL format
using propositions (see § III-A) while the pLTL generated
by the SALT compiler contains a semantic name for each
atom (e.g., connection_open). We automatically translate the
pLTL generated by SALT compiler to the pLTL format re-
quired by the model checker by utilizing the atom-proposition
map (say, MAP) generated by our FSM translator and an
additional map (MAE) between atoms and their semantic
names. We require the developer to provide the map MAE.
D. Validating CEXs
The CEX generated by the model checker can be unrealiz-
able (i.e., false alarms) due to the following reasons: (i) the
abstraction caused by the replacement of atoms with propo-
sitions during FSM translation and (ii) the incompleteness of
symbolic execution and the limited granularity of user input
to FSM extraction. We use a 2-step CEX validation technique
where Step 1 and 2 rule out the unrealizable CEXs generated
due to reason (i) and (ii) respectively.
Step 1 (Spurious CEX checking). The propositions used in
the translated E-FSM can have, possibly nontrivial, dependen-
cies among each other with respect to their corresponding
1
2
3
4
5
6
7
8
9
10
11