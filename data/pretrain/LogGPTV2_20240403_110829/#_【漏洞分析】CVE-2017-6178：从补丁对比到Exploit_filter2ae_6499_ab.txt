    {
      HANDLE v8; // eax@2
      NTSTATUS v9; // eax@3
      NTSTATUS v11; // eax@13
      struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+10h] [bp-20h]@13
      CPPEH_RECORD ms_exc; // [sp+18h] [bp-18h]@6
      if ( !lpOverlapped )
      {
        if ( (dwIoControlCode & 0xFFFF0000) != 589824 )//将CTL CODE和0x90000做比较，如果相同，则执行NtFsControlFile，不同则执行NtDeviceIoControlFile
          v11 = NtDeviceIoControlFile(
                  hDevice,
                  0,
                  0,
                  0,
                  &IoStatusBlock,
                  dwIoControlCode,
                  lpInBuffer,
                  nInBufferSize,
                  lpOutBuffer,
                  nOutBufferSize);
        else
          v11 = NtFsControlFile(
                  hDevice,
                  0,
                  0,
                  0,
                  &IoStatusBlock,
                  dwIoControlCode,
                  lpInBuffer,
                  nInBufferSize,
                  lpOutBuffer,
                  nOutBufferSize);
回溯到DeviceIoControl之后，我发现这里将dwIoControlCode和0XFFFF0000做了与运算，也就是保留高4位，然后和0x90000作比较，如果相等，则会进入NtFsControlFile，原来还是CTL_CODE决定了进入漏洞函数，但不是Function部分，而是DeviceType部分，来看一下我们常用对第三方驱动DeviceType的CTL_CODE值0x220000的定义，以及我们这次用到的0x90000的定义。
    #define FILE_DEVICE_FILE_SYSTEM         0x00000009
    #define FILE_DEVICE_UNKNOWN             0x00000022
这样，我们利用对驱动通信过程的回溯分析，找到了能命中可能存在漏洞的方法，首先利用CreateFile创建和\\.USBPcap1句柄，随后利用DeviceIOControl和设备通信，传递的CTL_CODE为0x90000。
文末我上传了关于这个漏洞的PoC，exp的话由于网络安全法刚刚颁布，关于exp的技术分享还不明晰暂时不公开，等确认是合法的技术分享后再公开。
随后我们引发了BSOD。
    kd> r
    eax=8700e8a8 ebx=868dd638 ecx=0000000d edx=8700e838 esi=00000000 edi=868dd628
    eip=83e54587 esp=a1340ae0 ebp=a1340ae8 iopl=0         nv up ei ng nz na po cy
    cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010283
    nt!IofCallDriver+0x57:
    83e54587 8b4608          mov     eax,dword ptr [esi+8] ds:0023:00000008=????????
BOOM!接下来我们进行漏洞分析。
**0x02 CVE-2017-6178漏洞分析**
其实这个漏洞形成原因非常简单，是一个简单的DeviceObject未初始化引发的漏洞，通过kb可以回溯堆栈调用。
    kd> kb
     # ChildEBP RetAddr  Args to Child              
    00 a1340ae8 91cdf8a6 857e9948 868dd570 00000000 nt!IofCallDriver+0x57
    WARNING: Stack unwind information not available. Following frames may be wrong.
    01 a1340afc 83e54593 00000000 8700e838 8700e838 USBPcap+0x18a6
    02 a1340b14 8404899f 857e9948 8700e838 8700e8a8 nt!IofCallDriver+0x63
    03 a1340b34 8404bb71 868dd570 857e9948 00000001 nt!IopSynchronousServiceTail+0x1f8
    04 a1340bd0 840746cc 868dd570 8700e838 00000000 nt!IopXxxControlFile+0x6aa
    05 a1340c04 83e5b1ea 0000001c 00000000 00000000 nt!NtFsControlFile+0x2a
    06 a1340c04 76df70b4 0000001c 00000000 00000000 nt!KiFastCallEntry+0x12a
    07 002cfb08 76df5a14 751b7414 0000001c 00000000 ntdll!KiFastSystemCallRet
    08 002cfb0c 751b7414 0000001c 00000000 00000000 ntdll!ZwFsControlFile+0xc
在USBPcap.sys中调用了IofCallDriver而引发了读取了0x0这个无效地址的值，引发了BSOD，这里esi寄存器的值为0x0，来看一下这个值由何而来。
    NTSTATUS __fastcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp)
    {
      v2 = DeviceObject;
      if ( pIofCallDriver )
      {
      }
      else
      {
        ……
          result = v2->DriverObject->MajorFunction[v5](v2, Irp);//漏洞位置，esi是v2的值，v2的值是DeviceObject，也就是说这是一个DeviceObject未初始化的原因
      }
      return result;
    }
这里v2的值也就是esi寄存器的值是DeviceObject，而这个值是0x0，证明未给DeviceObject赋初值，来往外层回溯一下USBPcap.sys对应函数中。
      if ( v3 >= 0 )
      {
        v5 = *(struct _DEVICE_OBJECT **)(v2 + 8);
        ++*((_BYTE *)Tag + 35);
        *((_DWORD *)Tag + 24) += 36;
        v6 = (struct _IO_REMOVE_LOCK *)(v2 + 16);
        v7 = IofCallDriver(v5, (PIRP)Tag);
        IoReleaseRemoveLockEx(v6, Tag, 0x18u);
        result = v7;
在USBPcap.sys函数中，v5会获取v2+8的值，这里是一个DEVICE
OBJECT结构体，然后直接调用IofCallDriver，并将v5传入，这里没有对v5的值是否赋初值进行检查，而直接调用了IofCallDriver引发了漏洞，来看一下补丁后这里的结果。
        if ( v4 >= 0 )
      {
         v6 = *(struct _DEVICE_OBJECT **)(v2 + 8);
        if ( v6 )
        {
          ++*((_BYTE *)Tag + 35);
          *((_DWORD *)Tag + 24) += 36;
          v7 = IofCallDriver(v6, (PIRP)Tag);
        }
      }
补丁后，对DEVICE_OBJECT的值进行了判断，若不为0，也就是赋初值了，才会正常调用IofCallDriver函数。完成了PoC，我们来最后完成对这个漏洞的利用。
**0x03 PWN!!**
其实关于这个漏洞利用非常简单，这个和我之前写过的MS16-034的利用过程很像，地址在：
在Win7下没有对零页地址的限制，可以直接在零页分配地址，来构造一个fake device object来进行赋值，同时来看一下漏洞利用前后的。
    loc_437587:
    mov     eax, [esi+8]
    push    edx
    movzx   ecx, cl
    push    esi
    call    dword ptr [eax+ecx*4+38h]
这里esi的值由于未初始化是0x0，在零页申请地址后，我们可以在0x8中构造一个fake
address，这里直接是0x0就行，那么eax的值就是0x0，到最后call调用的就是0x0+ecx*4+0x38中存放的值，ecx在这里是定值0xd，那么最后相当于call
[6c]，我们申请完零页地址后，在6c部署shellcode，就能在Ring0态执行shellcode了。
到这里其实都没有问题，利用也很简单，但事实上在我们使用shellcode之后存在一个堆栈平衡的问题，导致常用的shellcode无法使用，需要进行一个小patch，来看一下这到底是是怎么回事。
首先，我们执行到shellcode末尾的时候，需要返回外层调用。
可以看到，之前的返回地址时83e54593，这个地址是IofCallDriver的地址，后面的返回地址时USBPcap.sys中的地址91cdf8a6，只有返回到USBPcap.sys中之后，才能正常通过USBPcap.sys中的ret结束和驱动通信。
但是这里，如果从shellcode返回到IofCallDriver后，来看一下上下文。
    kd> u 83e54593 l4
    nt!IofCallDriver+0x63:
    83e54593 5e              pop     esi
    83e54594 59              pop     ecx
    83e54595 5d              pop     ebp
    83e54596 c3              ret
这里是3个pop，然后就ret了，这样到达不了上面我们分析的图中的USBPcap.sys的地址，而是返回到0x0这个地址中，随后会执行报错，因此这里我们需要打一个小补丁，其中一种方法就是在shellcode中，不让shellcode返回到IofCallDriver，而是直接返回到USBPcap.sys中，因此我们在shellcode要返回的时候，调整esp，直接将其指向USBPcap.sys的ret
address即可。
    kd> u 13e103c l3
    013e103c 61              popad
    013e103d 83c424          add     esp,24h
    013e1040 c3              ret
通过add esp,24h，就可以保持堆栈平衡了。这样，我们利用EPROCESS的shellcode对token进行替换，完成Kernel PWN。
**0x04 关于补丁以及不成熟的脑洞**
到此我们完成了对CVE-2017-6178从补丁对比，到漏洞分析，其中比较麻烦的过程就是对DeviceIOControl的逆向过程，但也挺有意思了，了解到IRP这个驱动通信极重要结构体的一些功能，当然还存在很多的不足，需要在以后慢慢学习，驱动利用也是内核利用的一部分，也是很重要很有趣的一部分。
当然，经过刚才的分析，我发现在补丁中只是对device object对象是否为0进行了判断，而不是对device
object的合法性进行判断，也就是说，当device
object为一个任意不为0的值的时候，也能够绕过判断，那就导致如果指向的是一个我们可控的位置，就仍然存在漏洞，但我花了一段时间研究如何修改device
object的值，发现好像device object只能在内核层被赋值，有想过hook的想法，但终究没有实现，身边也没有有相关经验的小伙伴一起研究。
所以就算一个不成熟的脑洞，如果有师傅觉得可以做到，欢迎一起交流，最后感谢大家阅读！谢谢大家！
最后放一下我的CVE-2017-6178 POC地址，exp会在之后确认仅用于技术交流不触犯网络安全法后公开：