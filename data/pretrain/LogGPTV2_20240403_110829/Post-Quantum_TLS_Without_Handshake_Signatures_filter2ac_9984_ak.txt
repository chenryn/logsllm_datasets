Advğºğ´A1 â‰¤ ğ‘›ğ‘  Â· Advğºğ´1A1
.
From this point on, we will make a series of replacements in the
tested session ğœ‹, and its (unique) contributive partner ğœ‹â€² which we
know by game A1.
Game A2 (ephemeral KEM). In this game, in session ğœ‹ğ‘ , we re-
place the ephemeral secret ssğ‘’ with a uniformly random(cid:102)ssğ‘’. If ğœ‹ğ‘
the same(cid:102)ssğ‘’. All values derived from ssğ‘’ in ğœ‹ğ‘  (and ğœ‹ğ‘, if ssğ‘’ was
replaced in it) use the randomized value(cid:102)ssğ‘’.
received the same ctğ‘’ that ğœ‹ğ‘  sent, then we also replace its ssğ‘’ with
Any adversary A1 that can detect this change can be used to
construct an adversary B2 against the IND-1CCA security of KEMe
as follows.
B2 obtains the IND-1CCA challenge pkâ˜…, ctâ˜… and challenge
shared secret ssâ˜…. In ğœ‹ğ‘, it uses pkâ˜… in the ClientHello. In ğœ‹ğ‘ ,
it uses ctâ˜… in the ServerHello reply, and ssâ˜… as ğœ‹ğ‘ â€™s shared secret
ssğ‘’. If A1 delivers ctâ˜… to ğœ‹ğ‘, then B2 uses ssâ˜… as ğœ‹ğ‘â€™s shared secret
ssğ‘’ as well. If A1 delivers some other ctâ€² Ì¸= ctâ˜… to ğœ‹ğ‘, then B2 makes
a single query to its IND-1CCA decapsulation oracle with ctâ€² to
obtain the required shared secret.
A1 eventually terminates its guess of ğ‘ = 0 or ğ‘ = 1. If ssâ˜… was
the real shared secret, then B2 has exactly simulated ğºğ´1 to A1; if
ssâ˜… was a random value, then B2 has exactly simulated ğºğ´2 to A1.
Thus:
Game A3 (random HS). In this game, in session ğœ‹ğ‘ , we replace the
handshake secret HS with a uniformly random(cid:102)HS. If ğœ‹ğ‘ received
(cid:102)HS. All values derived from HS in ğœ‹ğ‘  (and ğœ‹ğ‘, if HS was replaced
in it) use the randomized value(cid:102)HS.
the same ctğ‘’ that ğœ‹ğ‘  sent, then we also replace its HS with the same
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B3 against the PRF security of HKDF.Extract
in its second argument as follows.
When B3 needs to compute HS in ğœ‹ğ‘  (or ğœ‹ğ‘, if ğœ‹ğ‘ received the
same ctğ‘’ that ğœ‹ğ‘  sent), it queries its HKDF.Extract challenge oracle
on dES and uses the response as HS. If the response was the real
output, then B3 has exactly simulated ğºğ´2 to A1; if the response
was a random value, then B3 has exactly simulated ğºğ´3 to A1.
Thus:
Advğºğ´1A1 â‰¤ Advğºğ´2A1
+ AdvIND-1CCA
KEMe,B2
.
Advğºğ´2A1 â‰¤ Advğºğ´3A1
+ AdvPRF-sec
HKDF.Extract,B3
.
Game A4 (random CHTS, SHTS, dHS). In this game, in session
ğœ‹ğ‘ , we replace the values CHTS, SHTS, and dHS with uniformly
random values. If ğœ‹ğ‘ received the same ctğ‘’ that ğœ‹ğ‘  sent, then we
replace its dHS with the same replacement as in ğœ‹ğ‘ . Furthermore,
if ğœ‹ğ‘ received the same ctğ‘’ that ğœ‹ğ‘  sent and the same ServerHello
(i.e., if ğœ‹ğ‘ is a partner to ğœ‹ğ‘  at stage 1 and 2), then we also replace
its CHTS and SHTS with the same replacements as in ğœ‹ğ‘ . If ğœ‹ğ‘
received the same ctğ‘’ that ğœ‹ğ‘  sent but not the same ServerHello,
then we replace its CHTS and SHTS with independent uniformly
random values. All values derived from dHS in ğœ‹ğ‘  (and ğœ‹ğ‘, if dHS
was replaced in it) use the newly randomized values.
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B4 against the PRF security of HKDF.Expand
as follows.
When B4 needs to compute CHTS, SHTS, or dHS in ğœ‹ğ‘  (or ğœ‹ğ‘, if
ğœ‹ğ‘ received the same ctğ‘’ that ğœ‹ğ‘  sent), it queries its HKDF.Expand
challenge oracle on the corresponding label and transcript, and uses
the responses. If the responses were the real output, then B4 has
exactly simulated ğºğ´3 to A1; if the responses were random values,
then B4 has exactly simulated ğºğ´4 to A1. Note that if ğœ‹ğ‘ did receive
the same ctğ‘’ as was sent by ğœ‹ğ‘ , but other parts of the ServerHello
message were altered such that ğœ‹ğ‘ and ğœ‹ğ‘  are not partners at stage
1, the adversary may be permitted to query Reveal(ğœ‹ğ‘, 1); but since
the transcript in ğœ‹ğ‘ and ğœ‹ğ‘  is now different, the label input to
the HKDF.Expand oracle for CHTS and SHTS is different, so the
simulation in B4 remains good. Thus:
Advğºğ´3A1 â‰¤ Advğºğ´4A1
+ AdvPRF-sec
HKDF.Expand,B4
.
The stage-1 and stage-2 keys CHTS and SHTS are now uniformly
random strings independent of everything else in the game. Thus,
the stage-1 and stage-2 keys have been shown to have wfs1 security.
Game A5 (random AHS). In this game, in session ğœ‹ğ‘ , we replace
the secret AHS with a uniformly randomAHS. If ğœ‹ğ‘ received the
AHS was replaced in it) use the randomized valueAHS.
same ctğ‘† that ğœ‹ğ‘  sent, then we replace its AHS with the same
replacement as in ğœ‹ğ‘ . All values derived from AHS in ğœ‹ğ‘  (and ğœ‹ğ‘, if
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B5 against the PRF security of HKDF.Extract
in its first argument as follows (which we view as â€œdual PRF securityâ€
of HKDF.Extract).
When B5 needs to compute AHS in ğœ‹ğ‘  (or ğœ‹ğ‘, if ğœ‹ğ‘ received the
same ctğ‘† that ğœ‹ğ‘  sent), it queries its HKDF.Extract challenge oracle
on ssğ‘† and uses the response as AHS. If the response was the real
output, then B5 has exactly simulated ğºğ´4 to A1; if the response
was a random value, then B5 has exactly simulated ğºğ´5 to A1.
Thus:
Advğºğ´4A1 â‰¤ Advğºğ´5A1
+ Advdual-PRF-sec
HKDF.Extract,B5
.
Game A6 (random CAHTS, SAHTS, dAHS). In this game, in ses-
sion ğœ‹ğ‘ , we replace the values CAHTS, SAHTS, and dAHS with
uniformly random values. If ğœ‹ğ‘ received the same ctğ‘† that ğœ‹ğ‘  sent
and is a partner to ğœ‹ğ‘  at stage 3 and 4, then we replace its CAHTS,
SAHTS, and dAHS with the same replacements as in ğœ‹ğ‘ . If ğœ‹ğ‘ re-
ceived the same ctğ‘† that ğœ‹ğ‘  sent but is not a partner to ğœ‹ğ‘  at stage
3 and 4, then we replace its CAHTS, SAHTS, and dAHS with inde-
pendent uniformly random values. All values derived from dAHS
in ğœ‹ğ‘  (and ğœ‹ğ‘, if dAHS was replaced in it) use the newly randomized
values.
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B6 against the PRF security of HKDF.Expand
as follows.
When B6 needs to compute CAHTS, SAHTS, or dAHS in ğœ‹ğ‘ 
(or ğœ‹ğ‘, if ğœ‹ğ‘ received the same ctğ‘† that ğœ‹ğ‘  sent), it queries its
Post-Quantum TLS Without Handshake Signatures
CCS â€™20, November 9â€“13, 2020, Virtual Event, USA
HKDF.Expand challenge oracle on the corresponding label and
transcript, and uses the responses. If the responses were the real
output, then B6 has exactly simulated ğºğ´5 to A1; if the responses
were random values, then B6 has exactly simulated ğºğ´6 to A1.
Note that if ğœ‹ğ‘ did receive the same ctğ‘† as was sent by ğœ‹ğ‘ , but other
parts of the transcript were altered such that ğœ‹ğ‘ and ğœ‹ğ‘  are not
partners at stage 3 and 4, the adversary may be permitted to query
Reveal(ğœ‹ğ‘, 3) or Reveal(ğœ‹ğ‘, 4); but since the transcript in ğœ‹ğ‘ and ğœ‹ğ‘ 
is now different, the label input to the HKDF.Expand oracle for
CAHTS and SAHTS is different, so the simulation in B6 remains
good. Thus:
Advğºğ´5A1 â‰¤ Advğºğ´6A1
+ AdvPRF-sec
HKDF.Expand,B6
.
The stage-3 and stage-4 keys CAHTS and SAHTS are now uni-
formly random strings independent of everything else in the game.
Thus, the stage-3 and stage-4 keys have been shown to have wfs1
security.
Game A7 (random MS). In this game, in session ğœ‹ğ‘ , we replace
the master secret MS with a uniformly random(cid:102)MS. If ğœ‹ğ‘ is a partner
in it) use the randomized value(cid:102)MS.
of ğœ‹ğ‘  at stage 4, then we replace its MS with the same replacement
as in ğœ‹ğ‘ . If ğœ‹ğ‘ is not a partner of ğœ‹ğ‘  at stage 4 but did receive the
same ctğ‘† as ğœ‹ğ‘  sent, we replace ğœ‹ğ‘â€™s MS with a uniformly random
value. All values derived from MS in ğœ‹ğ‘  (and ğœ‹ğ‘, if MS was replaced
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B7 against the PRF security of HKDF.Extract
in its first argument as follows (which we view as â€œdual PRF securityâ€
of HKDF.Extract).
When B7 needs to compute MS in ğœ‹ğ‘  (or ğœ‹ğ‘, if ğœ‹ğ‘ received the
same ctğ‘† that ğœ‹ğ‘  sent), it queries its HKDF.Extract challenge oracle
on âˆ… and uses the response as MS. If the response was the real
output, then B7 has exactly simulated ğºğ´6 to A1; if the response
was a random value, then B7 has exactly simulated ğºğ´7 to A1.
Thus:
Advğºğ´6A1 â‰¤ Advğºğ´7A1
+ Advdual-PRF-sec
HKDF.Extract,B7
.
Game A8 (random CATS, fkğ’„, fkğ’”). In this game, in session ğœ‹ğ‘ ,
we replace the values CATS, fkğ‘, and fkğ‘  with uniformly random
values. If ğœ‹ğ‘ is a partner of ğœ‹ğ‘  at stage 5, then we replace its CATS,
fkğ‘, and fkğ‘  with the same replacements as in ğœ‹ğ‘ . If ğœ‹ğ‘ is not a
partner of ğœ‹ğ‘  at stage 5 but did receive the same ctğ‘† as ğœ‹ğ‘  sent, we
replace ğœ‹ğ‘â€™s CATS, fkğ‘, and fkğ‘  with uniformly random value.
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B8 against the PRF security of HKDF.Expand
as follows.
When B8 needs to compute CATS, fkğ‘, or fkğ‘  in ğœ‹ğ‘  (or ğœ‹ğ‘, if
ğœ‹ğ‘ received the same ctğ‘† that ğœ‹ğ‘  sent), it queries its HKDF.Expand
challenge oracle on the corresponding labels and transcripts, and
uses the responses. Note that if ğœ‹ğ‘ did receive the same ctğ‘† as was
sent by ğœ‹ğ‘ , but other parts of the transcript were altered such that ğœ‹ğ‘
and ğœ‹ğ‘  are not partners at stage 5, the adversary may be permitted
to query Reveal(ğœ‹ğ‘, 5); but since the transcript in ğœ‹ğ‘ and ğœ‹ğ‘  is now
different, the label input to the HKDF.Expand oracle for CATS is
different, so the simulation in B8 remains good. If the response was
the real output, then B8 has exactly simulated ğºğ´7 to A1; if the
response was a random value, then B8 has exactly simulated ğºğ´8
to A1. Thus:
Advğºğ´7A1 â‰¤ Advğºğ´8A1
+ AdvPRF-sec
HKDF.Expand,B8
.
The stage-5 key CATS is now a uniformly random string inde-
pendent of everything else in the game. Thus, the stage-5 key has
been shown to have wfs1 security.
Game A9 (random SATS). In this game, in session ğœ‹ğ‘ , we replace
the value SATS with a uniformly random value. If ğœ‹ğ‘ is a partner of
ğœ‹ğ‘  at stage 6, then we replace its SATS with the same replacement
as in ğœ‹ğ‘ . If ğœ‹ğ‘ is not a partner of ğœ‹ğ‘  at stage 6 but did receive the
same ctğ‘† as ğœ‹ğ‘  sent, we replace ğœ‹ğ‘â€™s SATS with a uniformly random
value.
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B9 against the PRF security of HKDF.Expand
as follows.
When B9 needs to compute SATS in ğœ‹ğ‘  (or ğœ‹ğ‘, if ğœ‹ğ‘ received the
same ctğ‘† that ğœ‹ğ‘  sent), it queries its HKDF.Expand challenge oracle
on the corresponding label and transcript, and uses the responses.
Note that if ğœ‹ğ‘ did receive the same ctğ‘† as was sent by ğœ‹ğ‘ , but
other parts of the transcript were altered such that ğœ‹ğ‘ and ğœ‹ğ‘  are
not partners at stage 6, the adversary may be permitted to query
Reveal(ğœ‹ğ‘, 5); but since the transcript in ğœ‹ğ‘ and ğœ‹ğ‘  is now different,
the label input to the HKDF.Expand oracle for SATS is different, so
the simulation in B9 remains good. If the response was the real
output, then B9 has exactly simulated ğºğ´8 to A1; if the response
was a random value, then B9 has exactly simulated ğºğ´9 to A1.
Thus:
Advğºğ´8A1 â‰¤ Advğºğ´9A1
+ AdvPRF-sec
HKDF.Expand,B9
.
The stage-6 key SATS is now a uniformly random string inde-
pendent of everything else in the game. Thus, the stage-6 key has
been shown to have wfs1 security.
Analysis of game A9. In game A9, all stage keys in the tested
session are uniformly random and independent of all messages
in the game, so the hidden bit ğ‘ used in the tested session is now
independent all information sent to the adversary. Thus Advğºğ´9A1
= 0.
This concludes case A, yielding:
+ AdvPRF-sec
AdvIND-1CCA
KEMe,B2
+ AdvPRF-sec
HKDF.Expand,B4
+ AdvPRF-sec
HKDF.Expand,B6
+ AdvPRF-sec
HKDF.Expand,B8
HKDF.Extract,B3
+ Advdual-PRF-sec
+ Advdual-PRF-sec
+ AdvPRF-sec
Advğºğ´A1 â‰¤ ğ‘›ğ‘ 
HKDF.Extract,B5
HKDF.Extract,B7
HKDF.Expand,B9
Case B: No contributive partner, peer never
corrupted
Since in this case the tested session ğœ‹ does not have a contributive
partner in stage 1 (and hence in any stage), stages aiming for wfs1
are outside the scope of this case, so we can assume that the tested
session ğœ‹ is a client session.
Game B1 (guess peer). In this game, we guess the identity ğ‘‰ of the
intended peer of the test session, and abort if the guess is incorrect
(i.e., if ğ‘‰ Ì¸= ğœ‹ .pid). This reduces the advantage of A1 by a factor of
the number of users ğ‘›ğ‘¢:
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172) .
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
AdvğºğµA1 â‰¤ ğ‘›ğ‘¢ Â· Advğºğµ1A1
.
CCS â€™20, November 9â€“13, 2020, Virtual Event, USA
Schwabe, Stebila, Wiggers
Game B2 (long-term KEM). In this game, in session ğœ‹ we replace
ally, in any sessions ğœ‹â€² of ğ‘‰ which received the same ctğ‘† that was
the static shared secret ssğ‘† with a uniformly random(cid:102)ssğ‘†. Addition-
sent in ğœ‹, we replace the static shared secret ssğ‘† with the same(cid:102)ssğ‘†.
All values derived from ssğ‘† in ğœ‹ use the randomized value(cid:102)ssğ‘†.
Any adversary A1 that can detect this change can be used to
construct an adversary B10 against the IND-CCA security of KEMs
as follows.
B10 obtains the IND-CCA challenge pkâ˜…, ctâ˜…, and challenge
shared secret ssâ˜…. It uses pkâ˜… as the long-term public key of ğ‘‰ .
In the tested session ğœ‹, B10 uses ctâ˜… as ğœ‹â€™s encapsulation ctğ‘† in
message CKC, and uses ssâ˜… as ssğ‘†. In any session of ğ‘‰ , if the cipher-
text ctğ‘† received in the CKC message is not ctâ˜…, then B10 queries its
IND-CCA decapsulation oracle, and uses the response as ssğ‘†; if the
received ciphertext ctğ‘† = ctâ˜…, B10 uses ssâ˜… as ssğ‘†. By the assump-
tions of Case B, there is never a Corrupt(ğ‘‰ ) query that needs to be
answered. A1 terminates and outputs its guess of ğ‘ = 1 or ğ‘ = 1. If
ssâ˜… was the real shared secret, then B10 has exactly simulated ğºğµ1
to A1; if ssâ˜… was a random value, then B10 has exactly simulated
ğºğµ2 to A1. Thus:
Advğºğµ1A1 â‰¤ Advğºğµ2A1
+ AdvIND-CCA
KEMe,B10
.
the secret AHS with a uniformly randomAHS. Additionally, in any
Game B3 (random AHS). In this game, in session ğœ‹, we replace
sessions ğœ‹â€² of ğ‘‰ which received the same ctğ‘† that was sent in ğœ‹, we
replace AHS with random values, maintaining consistency among
any sessions of ğ‘‰ that use the same ctğ‘† and the same dHS. All values
derived from AHS in these sessions use the newly randomized
values.
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B11 against the PRF security of HKDF.Extract
in its second argument as follows.
When B11 needs to compute AHS in ğœ‹ or in any of the sessions
of ğ‘‰ that received the same ctğ‘† that was sent in ğœ‹, it queries its
HKDF.Extract challenge oracle on that sessionâ€™s dHS and uses the
response AHS. If the HKDF.Expand challenge oracle was returning
real outputs, then B11 has exactly simulated ğºğµ2 to A1; if it was
returning random values, then B11 has exactly simulated ğºğµ3 to
A1. Thus:
Advğºğµ2A1 â‰¤ Advğºğµ3A1