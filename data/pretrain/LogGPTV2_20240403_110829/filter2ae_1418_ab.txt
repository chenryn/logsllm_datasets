第四类中的所有其他设备都是被动的，仅检查服务器和用户之间现有的HTTP流量，就可以用这些设备指纹来构建。
### 5.6 可区分性
为了描述指纹向量能够识别设备的粒度，我们使用了可区分性。业界一般会熵来表示，但是香农熵是相对于一个既定的概率分布而言的，而我们实际上很难对设备指纹进行完整描述。可识别性取决于用户设备空间的大小，以及指纹属性的多样性。一个向量的可区分性可能取决于一个网站的目标用户分布，例如对于中文网站用户，系统时间和地理位置的分离度较低。
为了帮助比较和选择要组合的向量，我们对每个向量的可区分性进行了定性分析：
1(a)主要软硬件细节：高，因为它包括user-agent、插件列表、屏幕分辨率、是否存在localStorage和sessionStorage等属性，另外还有其他属性。
1(b) WebGL信息：低，根据初步实验得出。
1(c)系统时间：取决于时区，一共24个值，但实际上用户在不同时区的分布会有偏移。时钟偏移也可以测量，但缺少大规模试验，所以这个向量整体评定为低。
1(d)电池信息，低，一般设备电池基本上在4-10小时内，如果充电则可提供更多的区分度。
1(e)Evercookies：非常高，服务器可以在设备上保存一个全球唯一标识符。
1(f)WebRTC：中，大多数家用路由器分配的IP地址在192.168.0.x范围内，因此这些IP地址有上限。
1(g)密码自动填充和4(i)广告拦截器检测：非常低，每个都是二进制值。
2(a)HTML5画布指纹被：中，提供了˜8.6位的区分信息。
2(b)系统性能：低，在几秒钟时间的约束下，可测量系统性能的粒度有限。
2(c)硬件传感器：中，根据Bojinov收集的3000多个设备加速度计数据，计算出分布的熵为˜7.5位。
2(d)滚轮指纹：非常低。滚轮指纹产生一个二进制值来区分滚轮和触摸板，但也有可能因为操作系统滚动速度设置造成。
向量2(e)、2(f)、2(g)尚未有实证研究报告，但估计位非常低。这些向量的作用是区分不同的浏览器厂商和版本，对于这些厂商和版本，其分布很可能偏向于最新的版本。
2(h)显卡RAM：低或非常低。因为选择很有限，例如1GB、2GB、4GB。而且很多设备共享显卡内存，这一点变得复杂了。
2(i)字体检测：低或中。通过Flash插件枚举所有字体的结果是7-14位，这个差值主要是由于移动设备上字体多样性大大降低。JavaScript字体检测是无序的，不能进行完全枚举，它使用已知字体列表进行测试。
2(j)音频处理：中，概念上类似于2(a)。
3(a)浏览器插件指纹：低或中，除了可以采集更细粒度的系统信息（如内核版本）外，还包括完整的系统字体枚举。但移动设备不支持插件，而桌面网页浏览器则转向扩展模式。
3(b)浏览器扩展指纹：低或非常低。除了技术含量高的用户外，很少有用户安装很多浏扩展。
3(c) 系统指纹插件：高。可以提供相当多的识别信息，与JavaScript相比，对底层操作系统和硬件的访问限制较少。  
4(a) IP地址：高。通常可以作为全局标识符，例如由于NAT、代理，以及在某些情况下地址的快速变化。
4(b) 地理定位：从低到高，有较大可变性。地理定位如果颗粒度够细的话，可以提供相当大的区分度。
4(c,d)基于p0f的MTU和TCP标志签名列表：从低到中。被动式TCP/IP协议栈指纹为低，主动式为低到中，主动式更强大一些。
4(e)协议指纹：高。包括HTTP header文件列表(˜4.36位)、某些header文件对应的值，如user-agent、resp、DoNotTrack。也可以推断出是否启用cookies，SSL指纹还不太能确定。但总体等级为高。
4(f) DNS解析：低到中。类似于地理定位，但颗粒度较小。
4(g) 时钟偏移：中。根据Kohno收集的几千台设备数据，计算出分布的熵为˜6位。
4(h)计算NAT后面的主机数量：低。对家庭用户来说，NAT后面主机数量变化不大，比如1到16台设备（企业设备来说会更高）。
## 六、设备指纹在认证中的价值
设备指纹其实不适合作为唯一认证机制，一个理想化的设备指纹认证需要：
每个设备都有一个独特的指纹，可以与用户账户关联。
不同时间从同一设备上获得的指纹要么是相同的，要么是可链接的，即可以高度确信来自同一设备。如果无法链接，比如用户换硬件了，则通过类似二次短信之类的备份机制确保可用
攻击者即使完全掌握设备软硬件配置，也很难伪造。
如果能够满足上述要求，仅设备指纹就可以用于账户认证，但目前显然无法达到这些要求。所以设备指纹主要作为额外的风控机制，尤其是这种机制不会增加用户负担。在这种情况下，设备指纹有两种用法，一是在会话开始时认证，二是在整个会话中维持认证。
### 6.1 会话开始时认证
设备指纹作为附加认证维度使用时，为了授权一个会话，服务器需要正确的响应和匹配用户指纹数据，因此服务器必须能持久访问指纹数据。同时，指纹要在单位时间内稳定跨越多个会话。前面我们说过，如果设备配置发生变化，以至于进化后的指纹不再可验证，则需要一个备份机制来重新关联设备和账户。
这种方式下指纹只需在会话开始时采集一次，因此资源消耗不是主要障碍。
增强双因素认证。用户端指纹可以增强双因素认证，值得注意的是，因素这个词通常涉及用户操作，设备指纹这样的维度最好不要涉及用户操作这部分。以Google的两步验证为例，首先用户名密码登陆，然后发送一个6位短信验证码，如果用户选择信任登陆的电脑，浏览器会保存一个cookie，用户在未来30天内无需验证码登陆。显然这是为了可用性而做出的妥协，攻击者获得cookie后就可以直接绕过第二个因素。所以设备指纹可以至少以三种方式作为辅助验证：
(a) 当用户提交密码时，服务器在发送短信代码之前验证设备指纹。如果指纹验证失败，则需要额外的认证，或向用户发送警报—在接收短信设备被盗的情况下提高安全性。
(b)当用户提交密码时，服务器可验证设备指纹和受信任的cookie，提高cookie被盗时的安全性。
(c)如果用户清除了浏览器cookie，之后试图重新认证，服务器可通过设备指纹识别出用户之前的可信情况，并允许跳过第二个认证因素。
### 6.2 整个会话的认证
在典型基于密码认证过程中，服务器接收到用户名密码后，会返回一个浏览器会话cookie，允许客户端在后续请求中用cookie来保持认证状态。cookie作为一个不记名标记，取代了密码。因此，获得cookie的对手可以在不知道密码的情况下提交认证，获取cookie可以有很多方法，设备盗窃、跨站脚本、MITM攻击等。
有的网站在发起认证会话时记录IP，并检查任何包含cookie的请求是否来自同一地址。这种会话cookie的IP绑定增强了安全性，如果IP交叉验证失败，服务器则终止会话，并选择向用户发出警告，锁定账户，额外认证等步骤。由于客户端在发送每个HTTP请求的同时发送会话cookie，服务器最好在每个请求上都验证源IP地址。不过这可能会影响可用性，用户IP地址在移动环境中可能经常变化。在这里，使用多个指纹向量会有帮助。
一个页面会产生很多HTTP请求，在这种情况下，被动向量应作为主要选择。对于完全被动向量，服务器可从现有流量中提取相关指纹数据，从而在每个请求中验证。但对于部分被动的4(c)或4(f)，则需要额外的网络流量。
非被动向量要求浏览器执行某些操作，并生成指纹输出，且包含在每个HTTP请求中。如果服务器使用固定向量，而且不涉及时间变化的挑战，设备配置也不改变，那么在用户浏览一个网页的过程中，这个指纹就会保持静态。因此在每次请求之前重新计算这个指纹对于合法用户端来说是多余的。但静态指纹可进行重放攻击。
在客户端用计数器对设备指纹进行哈希处理，然后再发送给服务器，这样可解决重放攻击。但对于XSS窃取会话cookie是无效的，因为XSS也可以窃取明文设备指纹和计数器，然后攻击者可以在自己的机器上恢复会话，并继续生成有效设备指纹，例如递增计数器和重新计算哈希。攻击脚本可以收集关于目标设备的额外信息，以便在服务器动态调整其指纹的情况下伪造。严格情况下，服务器可在每次设备被指纹时收集不同的属性。
综上所述，对于全会话指纹：
  1. 设备指纹应对每个HTTP请求进行验证。
  2. 被动向量的优点：向攻击者隐藏服务器指纹策略；消除用户端资源负担。
  3. 定期改变指纹方法可提高防御能力，但要考虑资源使用成本。
  4. 改变用户端生成指纹格式可提高安全性，例如使用计数器和哈希，或改变指纹属性。但对高级攻击者效果有限。
  5. 抗欺骗能力较强的向量可提供更强的认证保证。
## 七、总结
本文涉及的指纹向量，除了参考业界研究，我们自己也对19个指纹向量做了仿真实验，从这些研究中得出的一个结论是，任何向量子集结合起来都是可行的，但向量组合成需要平衡稳定性和可重复性。向量越多，可识别性则会增加，但并不是在所有情况下都会增加，例如在手机端的user-agent中中，屏幕分辨率不会增加区别性，因为一个型号的所有手机都有一个固定的分辨率。虽然攻击者可从统计学上猜测设备指纹的一些组件，比如伪造最常见的屏幕分辨率，但硬件传感器校准等组件可能是完全随机的，因此难以有效伪造。虽然目前无法给出精确的量化，但结合更多的向量往往会提高抗欺骗性，或至少提高标准。