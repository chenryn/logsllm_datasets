# CVE-2020-25695 Postgresql中的权限提升
已经快一年多了,我希望每个人都安康。这是我今年的第一篇也是唯一的一篇文章，涵盖了我在Postgresql中发现的一个有趣的特权升级漏洞。这会影响从9.5开始的所有受支持的Postgresql版本，很可能也会影响大多数较早的版本。
该漏洞类似于检查时间到使用时间[TOCTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use)的问题，但是在这种情况，它与退出安全受限操作之前未完全清除/重置状态有关。
测试版本:
  * 13.0 – PostgreSQL 13.0 (Debian 13.0-1.pgdg100+1)
  * 12.4 – PostgreSQL 12.4 (Debian 12.4-1.pgdg100+1)
  * 12.3 – PostgreSQL 12.3 (Debian 12.3-1.pgdg100+1)
  * 11.9 – PostgreSQL 11.9 (Debian 11.9-1.pgdg90+1)
发行说明和更新：[https](https://www.postgresql.org/about/news/postgresql-131-125-1110-1015-9620-and-9524-released-2111/)
:
[//www.postgresql.org/](https://www.postgresql.org/about/news/postgresql-131-125-1110-1015-9620-and-9524-released-2111/)
## 目标
我的目标找到一个漏洞，该漏洞将允许一个没有权限的用户将其提升到`superuser`。
有一些合法的方法可以为用户提供更高的Postgresql权限，而不给予用户完整的`superuser`权限。
通常使用`SECURITY DEFINER`函数完成此操作。
配置不当时,可以使用一个恶意编写的`SECURITY DEFINER` 函数和可控制`search_path`来提升特权。([Cybertec
Blog](https://www.cybertec-postgresql.com/en/abusing-security-definer-functions/))
在Postgresql文档中([how to safely write security definer
functions](https://www.postgresql.org/docs/current/sql-createfunction.html#SQL-CREATEFUNCTION-SECURITY))显式地说明了此功能。
> 由于`SECURITY DEFINER`函数是以拥有它的用户的特权执行的,因此,需要注意使用，确保该函数不会被滥用。
尽管这是合法的功能，它仍然提供了一个很好的开始，因为它使我了解了在源代码中查找的位置。
或许会有一种在其他上下文使用`SECURITY DEFINER`的方式。
## 查找
我首先研究了安全定义器函数和Postgresql切换用户权限的其他位置,我注意到其中提高`security-restricted
operations`。这立即引发了一种幻想，即可能在其中找到某些东西。调用grep,并搜索了提到`security-restricted
operations`的位置。
该术语出现的两个地方是`src/backend/commands/analyze.c`（`ANALYZE`指令）和`src/backend/commands/vacuum.c`（`VACUUM`指令),两者中都有相同的代码注释。
    /*
    * Switch to the table owner's userid, so that any index functions are run
    * as that user.  Also lock down security-restricted operations and
    * arrange to make GUC variable changes local to this command.
    */
这带我们走进下一部分。
## 索引和功能
这似乎很有趣,我不知道索引可以运行函数。现在是时候去先弄清楚如何使索引运行用户功能。
原来这是很容易做到的。[文档](https://www.postgresql.org/docs/current/sql-createindex.html)有大量的索引调用函数示例(即使这些不是用户定义的, 它也展示了如何构造sql查询的语法)
例如:
    CREATE INDEX ON films ((lower(title)));
在这种情况下,
一个索引被创建在`films`表`title`列,并使用`lower`函数将其转换为小写。这将很直接轻松地提供一个用户创建的功能而不是`lower`。
我跳过了一些必要的调试步骤，但可以归结为阅读使用函数时抛出的错误信息。此时要注意的事情是一个`INDEX`需要一个`IMMUTABLE`函数，这意味着该函数将始终为给定的输入返回相同的结果。这是有道理的,`INDEX`正在尝试优化唯一性。
    CREATE FUNCTION sfunc(integer) 
      RETURNS integer
      LANGUAGE sql IMMUTABLE AS
      'SELECT $1';
现在创建一个表,并在该表创建一个索引:
    CREATE TABLE blah (a int, b int);
    INSERT INTO blah VALUES (1,1);
    CREATE INDEX indy ON blah (sfunc(a));
这作用并不是很大,我想要一个做更有用事情的功能。例如将值插入到其他表中。原因是我想索引正在执行索引功能的用户。 在这点上，我的想法是:
    create index as unpriv --> privileged user executes ANALYZE/VACUUM --> index function executes as privileged user
在这种场景，我计划使用`SERCURITY INVOKER`诱使Postgres以特权用户执行此功能。
    -- create the table to insert the user into
    CREATE TABLE t0 (s varchar);
    -- create the security invoker function
    CREATE FUNCTION sfunc(integer) RETURNS integer
       LANGUAGE sql 
       SECURITY INVOKER AS
       'INSERT INTO t0 VALUES (current_user); SELECT $1';
如上文所说, 索引需要一个`IMMUTABLE`函数.因此，尝试在索引使用该函数，将引发错误:
    tmp=# CREATE INDEX indy ON blah (sfunc(a));
    ERROR:  functions in index expression must be marked IMMUTABLE
这似乎是一个死胡同。然后我突然想到可以重新创建/重新定义功能。只要您使用`CREATE OR REPLACE
FUNCTION`,任何现有的功能将会被覆盖。也许`INDEX`不会去检查一个定义好的函数是否会发生改变。(剧透,它的确不会)
    CREATE FUNCTION sfunc(integer) 
      RETURNS integer
      LANGUAGE sql IMMUTABLE AS
      'SELECT $1';
    CREATE INDEX indy ON blah (sfunc(a));
    CREATE OR REPLACE FUNCTION sfunc(integer) RETURNS integer
       LANGUAGE sql 
       SECURITY INVOKER AS
    'INSERT INTO t0 VALUES (current_user); SELECT $1';
现在,当索引运行时，`current_user`将会被插入到`t0`表中,为了确认,我切换到特权用户(postgres)并执行了该`ANALYZE`功能。
    tmp=# SELECT * FROM t0;
     s
    ---    (0 rows)
    tmp=# ANALYZE;
    ANALYZE
    tmp=# SELECT * FROM t0;
      s
    -----     foo
    (1 row)
    tmp=#
函数有效地触发了,但是我们插入了用户`foo`而不是`postgres`。这说明`SECURITY INVOKER`没有效果。
回顾前面的源代码解释，我们可以回想起在`security-restricted`函数中已切换所有者的uid.是的,我们证明了此功能有效,确认了我们找到了一个不错的绕过`IMMUTABLE`检查的功能，但这不是一个真正的安全问题。
## 稍后再说-延缓
回到源代码,我了解了如何进入`security-restricted`操作,然后退出。
在`vacuum.c`文件中，有一些有趣的注释。也许您可以立即发现引起我注意的部分。
    /*
      * Switch to the table owner's userid, so that any index functions are run
      * as that user.  Also lock down security-restricted operations and
      * arrange to make GUC variable changes local to this command. (This is
      * unnecessary, but harmless, for lazy VACUUM.)
      */
    GetUserIdAndSecContext(&save_userid, &save_sec_context);
    SetUserIdAndSecContext(onerel->rd_rel->relowner,
                                                save_sec_context | SECURITY_RESTRICTED_OPERATION);
    save_nestlevel = NewGUCNestLevel();
    // DO LOTS OF WORK
    // 
    /* Restore userid and security context */
    SetUserIdAndSecContext(save_userid, save_sec_context);
    /* all done with this class, but hold lock until commit */
    if (onerel)
            relation_close(onerel, NoLock);
    /*
      * Complete the transaction and free all temporary memory used.
      */
    PopActiveSnapshot();
    CommitTransactionCommand();
看到最后的注释和函数调用了吗？
在`CommitTransactionCommand()`之后执行`SetUserAndSecContext`，将上下文用户标识重置为执行用户的上下文。在SQL中，您具有事务，并且直到提交的时候事务才终结。这为你提供了执行某些SQL的空间，让它的一部分失败，然后完整地回滚到输入事务之前对状态的任何更改。在此代码中，用户在提交事务之前已还原，这事实使我想知道是否有可能在提交完成之前潜入一些其他命令来执行。
接下来，花了很长时间去阅读文档并寻找延迟执行SQL命令的方法。最终，我碰到了`INITIALLY
DEFERRED`,他掌握了解锁这个难题的关键。这是文档的一部分[TRIGGERS](https://www.postgresql.org/docs/current/sql-createtrigger.html),其进一步让幻想成真。
什么是`INITIALLY DEFERRED`?
> INITIALLY DEFERRED The default timing of the trigger. See the CREATE TABLE
> documentation for details of these constraint options. This can only be
> specified for constraint triggers.
进入`CREATE TABLE`参考文献，您会发现：
> If a constraint is deferrable, this clause specifies the default time to
> check the constraint. If the constraint is INITIALLY IMMEDIATE, it is
> checked after each statement. This is the default. If the constraint is
> INITIALLY DEFERRED, it is checked only at the end of the transaction. The
> constraint check time can be altered with the SET CONSTRAINTS command.
听起来完全像我们想要的!初始化延迟的约束只在"事务结束"时检查。这表明他将在上下文切换之后，但在`commit`之前发生。
## 实践
下一个技巧是弄清楚如何使用约束触发器以及应将约束触发器放置在何处，以便它在正确的时刻触发。
首先，一个`CONSTRAINT
TRIGGER`需要一个函数去执行。这将是我们"最终"的步骤,应该在特权用户上下文执行。因此,我们将特权操作插入到这个函数,另外一个技巧是`CONSTRAINT
TRIGGER`需要以某种方式触发。幸运地是，我们已经准备好了初始位。由于索引调用我们插入到table中的自定义函数插入`t0`表,这个动作将导致约束触发器执行
    Index runs --> sfunc inserts into t0 --> constraint trigger fires --> strig function is executed
这留给我们以下的SQL语句: