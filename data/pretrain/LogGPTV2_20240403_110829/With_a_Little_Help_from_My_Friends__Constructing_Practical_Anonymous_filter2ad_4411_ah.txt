273â€“290.
[55] Stephan Krenn, Thomas LorÃ¼nser, Anja Salzer, and Christoph Striecks. 2017.
Towards Attribute-Based Credentials in the Cloud. In CANS 17 (LNCS, Vol. 11261).
179â€“202.
[56] Ben Kreuter, TancrÃ¨de Lepoint, Michele OrrÃ¹, and Mariana Raykova. 2020. Anony-
mous Tokens with Private Metadata Bit. In CRYPTO 2020, Part I (LNCS, Vol. 12170).
308â€“336.
[57] Michael Z. Lee, Alan M. Dunn, Brent Waters, Emmett Witchel, and Jonathan Katz.
2013. Anon-Pass: Practical Anonymous Subscriptions. In 2013 IEEE Symposium
on Security and Privacy. 319â€“333.
[58] BenoÃ®t Libert, Fabrice Mouhartem, Thomas Peters, and Moti Yung. 2016. Practical
â€œSignatures with Efficient Protocolsâ€ from Simple Assumptions. In ASIACCS 16.
511â€“522.
[59] Jinyu Lu, Yunwen Liu, Tomer Ashur, Bing Sun, and Chao Li. 2020. Rotational-
XOR Cryptanalysis of Simon-Like Block Ciphers. In ACISP 20 (LNCS, Vol. 12248).
105â€“124.
[60] MAOSCO Limited. 2020. MULTOS Standard Technology. https://www.multos.
[61] Milica Milutinovic, Koen Decroix, Vincent Naessens, and Bart De Decker. 2015.
Privacy-Preserving Public Transport Ticketing System. In Data and Applications
Security and Privacy XXIX. Springer.
com/.
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2017[62] Daniel Moghimi, Berk Sunar, Thomas Eisenbarth, and Nadia Heninger. 2020. TPM-
FAIL: TPM meets Timing and Lattice Attacks. In 29th USENIX Security Symposium,
USENIX Security 2020, August 12-14, 2020, Srdjan Capkun and Franziska Roesner
(Eds.). USENIX Association, 2057â€“2073. https://www.usenix.org/conference/
usenixsecurity20/presentation/moghimi-tpm
[63] Wojciech Mostowski and Pim Vullers. 2012. Efficient U-Prove Implementation
for Anonymous Credentials on Smart Cards. In Security and Privacy in Com-
munication Networks, Muttukrishnan Rajarajan, Fred Piper, Haining Wang, and
George Kesidis (Eds.). Springer.
[64] Oracle. 2020. Java Card Technology. https://www.oracle.com/java/technologies/
java-card-tech.html.
[65] Christian Paquin and Greg Zaverucha. 2013. U-Prove Cryptographic Specification
V1.1 (Revision 3). https://www.microsoft.com/en-us/research/publication/u-
prove-cryptographic-specification-v1-1-revision-3/
[66] David Pointcheval and Olivier Sanders. 2016. Short Randomizable Signatures. In
CT-RSA 2016 (LNCS, Vol. 9610). 111â€“126.
[67] Himanshu Raj, Stefan Saroiu, Alec Wolman, Ronald Aigner, Jeremiah Cox,
Paul England, Chris Fenner, Kinshuman Kinshumann, Jork LÃ¶ser, Dennis Mat-
toon, Magnus NystrÃ¶m, David Robinson, Rob Spiger, Stefan Thom, and David
Wooten. 2016.
fTPM: A Software-Only Implementation of a TPM Chip. In
25th USENIX Security Symposium, USENIX Security 16, Austin, TX, USA, Au-
gust 10-12, 2016, Thorsten Holz and Stefan Savage (Eds.). USENIX Associa-
tion, 841â€“856. https://www.usenix.org/conference/usenixsecurity16/technical-
sessions/presentation/raj
[68] Kai Rannenberg, Jan Camenisch, and Ahmad Sabouri (Eds.). 2015. Attribute-based
[69] Olivier Sanders. 2020. Efficient Redactable Signature and Application to Anony-
Credentials for Trust: Identity in the Information Society. Springer.
mous Credentials. In PKC 2020, Part II (LNCS, Vol. 12111). 628â€“656.
[70] Michael Schwarz and Daniel Gruss. 2020. How Trusted Execution Environments
Fuel Research on Microarchitectural Attacks. IEEE Secur. Priv. 18, 5 (2020), 18â€“27.
https://doi.org/10.1109/MSEC.2020.2993896
Identity-Based Cryptosystems and Signature Schemes. In
[71] Adi Shamir. 1984.
[72] Victor Shoup. 1997. Lower Bounds for Discrete Logarithms and Related Problems.
CRYPTOâ€™84 (LNCS, Vol. 196). 47â€“53.
In EUROCRYPTâ€™97 (LNCS, Vol. 1233). 256â€“266.
[73] Alberto Sonnino, Mustafa Al-Bassam, Shehar Bano, Sarah Meiklejohn, and George
Danezis. 2019. Coconut: Threshold Issuance Selective Disclosure Credentials
with Applications to Distributed Ledgers. In NDSS 2019.
In ASIACRYPT 2001 (LNCS, Vol. 2248). 533â€“551.
Oracles. In EUROCRYPT 2005 (LNCS, Vol. 3494). 114â€“127.
[75] Brent R. Waters. 2005. Efficient Identity-Based Encryption Without Random
[74] Eric R. Verheul. 2001. Self-Blindable Credential Certificates from the Weil Pairing.
A OMITTED FORMAL DEFINITIONS
A.1 Preliminaries
A,Î¨(1ğœ†) â‡’ 1 for the event that the experiment Exp
We write Exp
ğœ™
returns 1, when instantiated with parameters ğœ™, adversary A and
primitive Î¨, all of which possibly omitted. We define the adjusted
advantage of adversary A in this experiment as
(cid:12)(cid:12)(cid:12)Pr(cid:104)
A,Î¨(1ğœ†) â‡’ 1(cid:105) âˆ’ ğ‘¥
(cid:12)(cid:12)(cid:12)
Adv [ğ‘¥] Expğœ™
A,Î¨ (1ğœ†) :=
ğœ™
Exp
If ğ‘¥ = 0, we write instead AdvExpğœ™
A,Î¨ (1ğœ†) for its advantage.
A.2 Signatures with Flexible Public Key
Definition A.1 (Class-hiding with Key Corruption). For SFPK with
relation R and adversary A we define the following experiment:
A,SFPK(ğœ†)
C-HR
(skğ‘–, pkğ‘–) â†$ SFPK.KeyGen(1ğœ†) for ğ‘– âˆˆ {0, 1}
ğ‘ â†$ {0, 1}; ğ‘Ÿ â†$ coin
(skâ€², pkâ€²) â† SFPK.ChgKeys(skğ‘, pkğ‘, ğ‘Ÿ)
Ë†ğ‘ â†$ ASFPK.Sign(skâ€²,Â·) ((sk0, pk0), (sk1, pk1), pkâ€²)
return ğ‘ = Ë†ğ‘
saries A, their advantage Adv(cid:2) 1
2(cid:3) C-HA,SFPK(1ğœ†) is negligible.
A SFPK is class-hiding with key corruption if for all ğ‘ƒğ‘ƒğ‘‡ adver-
Definition A.2 (Existential Unforgeability under Flexible Public
Key). For scheme SFPK with relation R and adversary A we define
the following experiment:
A,SFPK(ğœ†)
EUF-CMAR
(sk, pk, ğ›¿) â†$ SFPK.TKGen(1ğœ†); ğ‘„ := âˆ…
(pkâ€², ğ‘šâˆ—, Sigâˆ—) â†$ AO1(sk,Â·),O2(sk,Â·,Â·) (pk, ğ›¿)
return ğ‘šâˆ— âˆ‰ ğ‘„ âˆ§
return SFPK.ChkRep(ğ›¿, pkâ€²) = 1 âˆ§
SFPK.Verify(pkâ€², ğ‘šâˆ—, Sigâˆ—) = 1
O2(sk, ğ‘š, ğ‘Ÿ)
skâ€² â†$ SFPK.ChgSK(sk, ğ‘Ÿ)
Sig â†$ SFPK.Sign(skâ€², ğ‘š)
ğ‘„ := ğ‘„ âˆª {ğ‘š}
return Sig
O1(sk, ğ‘š)
Sig â†$ SFPK.Sign(sk, ğ‘š)
ğ‘„ := ğ‘„ âˆª {ğ‘š}
return Sig
A SFPK is existentially unforgeable with flexible public key under
chosen message attacks if for all ğ‘ƒğ‘ƒğ‘‡ adversaries A, their advantage
AdvEUF-CMAR
A.3 Structure Preserving Signatures on
(1ğœ†) is negligible.
A,SFPK
Equivalence Classes
EUF-CMA security is similar to that of conventional signatures, but
a forgery needs to be with respect to an unqueried class.
Definition A.3 (EUF-CMA). For scheme SPS-EQ and adversary
A we define the following experiment:
EUF-CMAA,SPS-EQ(ğœ†, â„“)
BG â†$ Setup(ğœ†); ğ‘„ := âˆ…
(sk, pk) â†$ KeyGen(BG, â„“)
(ğ‘€âˆ—, ğœâˆ—) â† AO1(sk,Â·) (pk)
return [ğ‘€âˆ—] â‰  [ğ‘€] âˆ€ğ‘€ âˆˆ ğ‘„ âˆ§
Verify(pk, ğ‘€âˆ—, ğœâˆ—) = 1
O1(sk, ğ‘€)
ğœ â†$ Sign(sk, ğ‘€)
ğ‘„ := ğ‘„ âˆª {ğ‘€}
return ğœ
An SPS-EQ over (Gâˆ—
ğ‘– )â„“ is existentially unforgeable under adap-
tively chosen-message attacks, if for all PPT adversaries A, their
advantage AdvEUF-CMA
A,SPS-EQ(1ğœ†, â„“) is negligible.
ğ‘– )â„“ âˆ§ Verify(ğ‘€, ğœ, pk) = 1 âˆ§ ğœ‡ âˆˆ Zâˆ—
Definition A.4 (Perfect Adaption of Signatures under malicious
keys [44]). Let â„“ > 1. An SPS-EQ scheme SPS-EQ on (Gâˆ—
ğ‘– )â„“ perfectly
adapts signatures under malicious keys if for all tuples (pk, ğ‘€, ğœ, ğœ‡)
with ğ‘€ âˆˆ (Gâˆ—
ğ‘ we have that
the output of ChgRep(ğ‘€, ğœ, ğœ‡, pk) is a uniformly random element
in the space of signatures, conditioned on Verify(ğ‘€ ğœ‡, ğœâ€², pk) = 1.
A relaxation of this definition (perfect adaption) considers tu-
ples of the form (sk, pk, ğ‘€, ğœ, ğœ‡) for which VKey(sk, pk) = 1 and
requires that the output of ChgRep(ğ‘€, ğœ, ğœ‡, pk) and Sign(ğ‘€ ğœ‡, sk)
are identically distributed. We note that for our CHAC construction
we only need this relaxed definition.
A.4 Tag-Based Equivalence Class Signatures
Definition A.5 (EUF-CMA). For scheme TBEQ and adversary A
we define the following experiment:
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2018EUF-CMAA,TBEQ(ğœ†, â„“)
pars â†$ Setup(ğœ†); ğ‘„ := âˆ…
(sk, pk) â†$ KeyGen(pars, â„“)
(ğ‘€âˆ—, ğœâˆ—, ğœâˆ—) â† AO1(sk,Â·,Â·)
return Verify(pk, ğ‘€âˆ—, ğœâˆ—, ğœâˆ—) = 1 âˆ§
([ğ‘€âˆ—], ğœâˆ—) â‰  ([ğ‘€], ğœ) âˆ€(ğ‘€, ğœ) âˆˆ ğ‘„
(pk)
CMA
O1(sk, ğ‘€, ğœ)
ğœ â†$ Sign(sk, ğ‘€, ğœ)
ğ‘„ := ğ‘„ âˆª {(ğ‘€, ğœ)}
return ğœ
A TBEQ is EUF-CMA, secure if for all PPT adversaries A, their
advantage AdvEUFA,TBEQ(1ğœ†, â„“) is negligible.
A.5 Aggregatable Attribute-Based EQs
Definition A.6 (EUF-CMA). For scheme AAEQ and adversary A
we define the following experiment:
EUF-CMAA,AAEQ(ğœ†, ğ‘¡, â„“)
(msk, mpk) â†$ Setup(1ğœ†, ğ‘¡, â„“); ğ‘„, ğ´ := âˆ…
ğ‘– }) â†$ AO1(msk,Â·,Â·,Â·) (mpk)
(ğ‘€âˆ—, ğœâˆ—, {Attrâˆ—
(Attrâˆ—
ğ‘– , ğ‘£âˆ—
return

Attrğ‘–
, [ğ‘€âˆ—]) âˆ‰ ğ‘„ âˆ§
ğ‘– }, ğ‘€âˆ—, ğœâˆ—) = 1
ğ‘–
Verify(mpk, {Attrâˆ—
O1(msk, Attr, ğ‘£Attr, ğ‘€)
if (Attr, Â·) âˆ‰ ğ´
skAttr â†$ AKGen(msk, Attr)
ğ´ := ğ´ âˆª {(Attr, skAttr)}
ğœ â†$ Sign(skAttr, ğ‘£Attr, ğ‘€)
ğ‘„ := ğ‘„ âˆª {(Attr, ğ‘£Attr, ğ‘€)}
return {ğœ}
tacks if for all ğ‘ƒğ‘ƒğ‘‡ adversaries A, the advantage AdvEUF-CMA
is negligible.
An AAEQ is existentially unforgeable under chosen message at-
A,AAEQ (1ğœ†, ğ‘¡, â„“)
Definition A.7 (Perfect Adaption of Signatures). An AAEQ scheme
on (Gâˆ—
ğ‘– )â„“ perfectly adapts signatures if for all tuples ({skAttrğ‘– }, mpk,
ğ‘€, {Attrğ‘–}, ğœ, ğœ‡) where it holds that VKey({skAttrğ‘– }, mpk) = 1,
Verify(mpk, {Attrğ‘–}, ğœ, ğ‘€) = 1, ğ‘€ âˆˆ (Gâˆ—
ğ‘, the distribu-
tions (ğ‘€ ğœ‡, Agg(mpk, {Sign(skAttrğ‘–
, ğ‘£Attrğ‘– , ğ‘€ ğœ‡,)}) and ChgRep(ğ‘€, ğœ,
ğœ‡, mpk) are identical.
ğ‘– )â„“, and ğœ‡ âˆˆ Zâˆ—
A.6 CHAC: Formal Model
Let HD, CD, SN, MN be empty sets. We introduce lists DSK, CRED,
ATTR, D, AID, I2D to track honest device secret keys, credentials
issued to honest devices, the corresponding attributes, device iden-
tifiers, session identifiers for issuing/showing, a list used to identify
which credential corresponds to which honest device. Addition-
ally, we will use an array CATTR to store sets with attributes of
dishonest devices where we use the device identifiers as indexes
to the array. Finally, we introduce a counter ğ‘AID initialized to 0.
Moreover, let us define the following oracles.
OHD(ğ‘–) : takes as input an identifier ğ‘– and outputs âŠ¥ if ğ‘– âˆˆ HDâˆª CD.
Otherwise, it creates a honest core device by running DSK[ğ‘–] â†$
CKGen(1ğœ†), adding ğ‘– to HD and setting D[ğ‘–] = âŠ¥.
Ononce() : this allows the adversary to initiate an issuing/showing
session. The oracle chooses nonce â†$ {0, 1}ğœ†, increments counter
ğ‘AID and sets AID[ğ‘AID] = nonce. Finally, it returns (ğ‘AID, nonce).
OObtIss(ğ‘–, Attr) : creates credentials for honest device ğ‘–, i.e. it out-
puts âŠ¥ if ğ‘– âˆ‰ HD. Otherwise, it generates a nonce nonce â†$ {0, 1}ğœ†,
generates aid â†$ AIDGen(Attr, nonce) and issues a credential for ğ‘–
by running apreq â†$ CObtain(aid, ipk, DSK[ğ‘–]), areq â†$ HObtain(
Attr, nonce, ipk, apreq), and (cred, did) â†$
Issue(Attr, nonce, areq,
isk). If cred = âŠ¥ it returns âŠ¥. Otherwise it adds (ğ‘–, cred, Attr) to
lists (I2D, CRED, ATTR) and sets D[ğ‘–] = did.
OCD(ğ‘–): takes as input an identifier ğ‘–. If ğ‘– âˆ‰ HD it outputs âŠ¥. Other-
wise, it creates a corrupted core device by adding ğ‘– to CD and setting
HD = HD \ {ğ‘–}. If D[ğ‘–] â‰  âŠ¥ it computes the union CATTR[D[ğ‘–]]
of all sets ATTR[ ğ‘—] for all ğ‘— where I2D[ ğ‘—] = ğ‘–. Finally, it returns
DSK[ğ‘–].
OIssue(ğ‘ , Attr, areq): allows the adversary, who impersonates a ma-
licious device, to obtain credentials. It takes as input a session
index ğ‘  > 0 and returns âŠ¥ if AID[ ğ‘—] = âŠ¥. The oracle generates
(cred, did) â†$ Issue(Attr, AID[ ğ‘—], areq, isk) and aborts if cred = âŠ¥.
Otherwise, it computes the union CATTR[did] = CATTR[did] âˆª
Attr. The oracle sets AID[ ğ‘—] = âŠ¥ and returns cred.
OCShow(ğ‘–, aid): allows the adversary to obtain a partial show tokens
from an honest device and impersonate a malicious helper device.
It takes a input a device index ğ‘– and attribute identifier aid. If ğ‘– âˆ‰ HD
then returnâŠ¥. Otherwise, compute apsig â†$ CShow(aid, ipk, DSK[ğ‘–]),
adds (aid) to set SN and return apsig.
OHShow( ğ‘—, nonce, Attr): allows the adversary, who impersonates a
malicious verifier, to trigger showings with an honest device. It
takes as input an index of an issuance ğ‘—, nonce and a set of attributes
Attr. Let ğ‘– â† I2D[ ğ‘—]. If ğ‘– âˆ‰ HD or Attr âŠˆ ATTR[ ğ‘—] or CRED[ ğ‘—] = âŠ¥
then return âŠ¥. Otherwise, compute aid â† AIDGen(Attr, nonce),
apsig â†$ CShow(aid, ipk, DSK[ğ‘–]) and asig â†$ HShow(Attr, nonce,
CRED[ ğ‘—], ipk, apsig). Add (nonce) to MN and return asig.
OObtain1(ğ‘–, Attr, nonce): allows the adversary, who impersonates a
malicious issuer, to issue credentials for a honest device. It takes
as input a device index ğ‘– and returns âŠ¥ if ğ‘– âˆ‰ HD. Otherwise it
computes aid â†$ AIDGen(Attr, nonce), apreq â†$ CObtain(aid, ipk,
DSK[ğ‘–]), and areq â†$ HObtain(Attr, nonce, ipk, apreq). and adds
(ğ‘–, ğœ€, Attr) to lists (I2D, CRED, ATTR).
OObtain2( ğ‘—, cred): allows the adversary, who impersonates a ma-
licious issuer, to issue credentials for a honest device. It takes as
input a device index ğ‘— and returns âŠ¥ if cred = âŠ¥ or CRED[ ğ‘—] â‰  ğœ€.