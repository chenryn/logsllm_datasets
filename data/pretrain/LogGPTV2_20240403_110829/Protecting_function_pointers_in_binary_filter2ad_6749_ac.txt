1
0
0
0
0
0
1
0
0
0
495
123
774
105
185
125
107
465
1,853
109
10,452
55,025
2,702
290
10,254
238
566
429
407
369
1,065
256
29,557
17,273
Benchmarks
SPECint2006
400.perlbench
401.bzip2
403.gcc
429.mcf
445.gobmk
456.hmmer
458.sjeng
464.h264ref
471.omnetpp
473.astar
1,380
73
3,501
73
1,967
117
84
185
4,798
95
46
20
26
20
22
23
20
20
30
20
5
3
3
3
3
3
3
3
3
3
Browsers
mshtml.dll (IE6)
xul.dll (FF3.6)
1,526
145,224
139
283
21
34
Table 2: Real World Exploit Samples Prevented by FPGate.
ID
CVE-2011-0065
CVE-2010-0249
CVE-2008-0348
CVE-2010-5081
OSVDB-83362
CVE-2007-1195
OSVDB-82798
App
FF 3.6
IE 6
coolplayer
RM-MP3
urlhunter
XM ftp
ComSndFTP
Vul Type
Use After Free
Use After Free
Stack Overflow
Stack Overflow
Stack Overflow
Format String
Format String
Vul Module
xul.dll
mshtml.dll
core exe
core exe
core exe
core exe
core exe
Protected
yes
yes
yes
yes
yes
yes
yes
struction to encrypt and decrypt the jump targets. Encode-
Pointer is slowest, because it queries the kernel heavily.
For the porting of CFI-fp, its overhead is about 1.5%,
much faster than the original implementation in [1]. That
is because this porting only protects function pointers but
not return addresses.
But the CFI-fp is slower than FPGate, mainly due to the
optimizations introduced by FPGate. As shown in the last
column of Table 1, the count of function pointers skipped
encoding is quite large, usually larger than the count of en-
coded function pointers. This optimization can greatly pro-
mote the performance of FPGate. However, this optimiza-
tion cannot be deployed easily to CFI-fp. For example, for
instruction call foo, FPGate can skip encoding the foo and
thus introduce no overheads, but CFI cannot skip inserting
an ID at the beginning of function foo because foo may be
used as the target of another indirect jump.
In addition, the ID inserted by CFI-fp at the beginning
of each jump target (e.g. function entries) is the prefetch-
nta instruction. This instruction has no side-eﬀect but is
extremely slow. For each direct (relative or absolute) jump
or call instruction, the instrumented slow prefetchnta in-
structions at the beginning of the jump target will be always
executed. As a result, CFI-fp is a little slower than FPGate.
4.4 Security Comparison
FPGate limits indirect instructions transfer only to valid
targets with IDs. There is only one ID in FPGate, and thus
it provides a weaker protection than CFI. However, due to
the complexity of building a complete control ﬂow graph,
the count of unique IDs introduced by CFI for a given ap-
plication is also small. And thus, the security gap between
FPGate and CFI is not so much.
We chose 7 publicly available exploits from Metasploit [11]
and ExploidDB [15] and tested them in a virtual machine
running Windows XP SP3 within a separate experiment net-
work. These exploits are tested against the original vulner-
able applications and corresponding hardened applications.
Table 2 shows the 7 vulnerabilities attacked by exploits we
used. Results show that all these protection schemes can
protect target browsers from attacking.
4.5 Miscellaneous
FPGate disassembles target binary and rewrites them.
The static analysis time is positively correlated with the tar-
get ﬁle size and is usually small. As our experiments shows,
it costs 63 seconds for gcc which is 1,200KB, and costs only
0.16 seconds for mcf which is 80KB.
FPGate instruments a trampoline section and allocates
16-bytes for each encoded function. The runtime memory
overhead it introduced is positively correlated with the count
of functions. For example, perlbench has about 700 func-
tions, and the runtime memory overhead is about 10KB.
5. DISCUSSION
FPGate relies on relocation tables to disassemble binary
and rewrite them. A recently published work REINS [20]
utilizes IDA Pro to provide similar protection without relo-
cation tables. However, IDA Pro is heuristic and suﬀers sig-
niﬁcant disassembly errors. REINS cannot identify all valid
function pointers and thus maintain a lookup table to encode
function pointers at runtime. A larger runtime overhead is
then introduced. Moreover, if the computed jump targets
fall into external modules and are retrieved through meth-
ods like GetProcAddress, REINS fails to protect the control
ﬂow, and causes compatibility issues.
FPGate uses only one ID and thus permit jumps to any
valid target with an ID. This is vulnerable to jump-to-libc
attacks. Attackers can hijack controls to valid jump targets
and launch an attack. Further work is needed to defend
against this kind of attack.
6. CONCLUSION
In this paper, we investigate several protection methods
against function pointers, including PointGuard, Encode-
Pointer and CFI. Inspired by them, a new approach called
FPGate is proposed. FPGate limits all indirect calls and
jumps to known valid targets. It can block various attacks
against function pointers.
FPGate can be applied through binary rewriting on ex-
ecutables generated by modern compilers. It is compared
with existing protections from the perspectives of perfor-
mance, robustness, and ease of deployment. Results show
that FPGate achieves a good balance between performance,
robustness and compatibility.
Acknowledgments
This research was supported in part by the National Natural
Science Foundation of China under the grant No. 61003216
and No. 61003217, the Chinese NDRC InfoSec Foundation
under Grant No.[2010]3044, the National Science Founda-
tion under Grant No. 0842695, 0831501 CT-L, CCF-0424422
and CNS-0831298, the Oﬃce of Naval Research under MURI
Grant No. N000140911081, N000140710928 and award FA9550-
09-1-0539, the AFOSR under grant FA9550-09-1-0539, and
DARPA under award HR0011-12-2-005. Any opinions, ﬁnd-
ings, and conclusions or recommendations expressed in this
material are those of the author(s) and do not necessarily
reﬂect the views of the National Science Foundation.
7. REFERENCES
[1] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.
Control-ﬂow integrity: Principles, implementations,
and applications. In Proceedings of the 12th ACM
Conference on Computer and Communications
Security, pages 340–353, 2005.
[2] S. Alexander. Defeating compiler-level buﬀer overﬂow
protection. The USENIX Magazine ;LOGIN,
30(3):59–71, 2005.
[3] S. Andersen and V. Abella. Data execution
prevention: Changes to functionality in microsoft
windows xp service pack 2, part 3: Memory protection
technologies. http://technet.microsoft.com/en-us/
library/bb457155.aspx, 2004.
[4] E. Buchanan, R. Roemer, H. Shacham, and S. Savage.
When good instructions go bad: generalizing
return-oriented programming to risc. In Proceedings of
the 15th ACM conference on Computer and
communications security, pages 27–38, 2008.
[5] C. Cifuentes and M. Van Emmerik. Recovery of jump
table case statements from binary code. In Proceedings
of the 7th International Workshop on Program
Comprehension, pages 192–199. IEEE, 1999.
[6] CORE Security Technologies Advisories.
Core-2007-0219: Openbs’s ipv6 mbufs remote kernel
buﬀer overﬂow. http://www.securityfocus.com/
archive/1/462728/30/150/threaded, 2007.
[7] C. Cowan, S. Beattie, J. Johansen, and P. Wagle.
PointguardTM: protecting pointers from buﬀer
overﬂow vulnerabilities. In Proceedings of the 12th
conference on USENIX Security Symposium,
volume 12, pages 91–104, 2003.
[8] M. Daniel, J. Honoroﬀ, and C. Miller. Engineering
heap overﬂow exploits with javascript. In Proceedings
of the 2nd conference on USENIX Workshop On
Oﬀensive Technologies, 2008.
[9] J. L. Henning. Spec cpu2006 benchmark descriptions.
SIGARCH Comput. Archit. News, 34:1–17, Sept. 2006.
[10] Hex-Rays SA. IDA Pro: a cross-platform
multi-processor disassembler and debugger. http:
//www.hex-rays.com/products/ida/index.shtml.
[11] Metasploit Open Source Commitment. Metasploit
penetration testing software & framework.
[12] Microsoft Visual Studio 2005. Image has safe
exception handlers. http://msdn.microsoft.com/
en-us/library/9a89h429%28v=vs.80%29.aspx.
[13] MSDN online library. EncodePointer function: provide
another layer of protection for pointer values.
http://msdn.microsoft.com/en-us/library/
bb432254(v=vs.85).aspx.
[14] MSDN online library. Microsoft Portable Executable
(PE) and Common Object File Format (COFF)
Speciﬁcation. http://msdn.microsoft.com/en-us/
windows/hardware/gg463119.aspx.
[15] Oﬀensive Security. Expoit database.
[16] A. One. Smashing the stack for fun and proﬁt. Phrack
magazine, 7:14–16, 1996.
[17] PaX Team. Pax address space layout randomization.
http://pax.grsecurity.net/docs/aslr.txt, 2003.
[18] V. Thampi. Udis86 disassembler library for x86.
http://udis86.sourceforge.net/.
[19] P. Vreugdenhil. Pwn2Own 2010 Windows 7 Internet
Explorer 8 exploit. http://vreugdenhilresearch.nl/
Pwn2Own-2010-Windows7-InternetExplorer8.pdf,
2010.
[20] R. Wartell, V. Mohan, K. Hamlen, and Z. Lin.
Securing untrusted code via compiler-agnostic binary
rewriting. In Proceedings of the 28th Annual Computer
Security Applications Conference (ACSAC’12),
Orlando, FL, December 2012.
[21] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres,
S. McCamant, D. Song, and W. Zou. Practical control
ﬂow integrity & randomization for binary executables.
In Proceedings of the 34th IEEE Symposium on
Security and Privacy, San Francisco, CA, May 2013.