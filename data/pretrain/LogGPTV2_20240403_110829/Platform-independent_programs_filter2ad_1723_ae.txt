Previous approaches have focused on data hiding. While
there are interpretations of our model that may be similar
to data hiding, the fundamental goal is to hide execution
behavior.
8. DISCUSSION
PIP Length. PIPs can be much longer than the input
programs. This makes sense because the resulting program
must be functionally equivalent to all input programs. In our
implementation we make no signiﬁcant eﬀort to reduce the
size of the PIP, though we recognize that it may be possible
to perform optimizations to reduce the size. We leave this
as future work. In addition, if PIPs are used in a stegano-
graphic setting, then one may also want to use additional
steganographic techniques to mask other attributes, such as
instruction and operand frequency.
More Gadget Headers. In § 3.1, we only considered gad-
get headers that did not change the system state other than
the program counter: (nop)∗(jump). This requirement was
primarily a simplifying assumption so that the gadget header
would not interfere with the semantics of the gadget body.
We see three ways to relax this requirement. First, make
sure any side-eﬀects in the gadget header are “undone” in
Figure 7: Performance comparison of PIPs.
We have used our platform to generate shellcode that
works on all three platforms. Our experiments show that
both OS-independent and platform-independent shellcode
is possible. Our results indicate that attackers only need
to care about their exploits, but not shellcodes, regardless
of the targeting OS or architecture.
6.4 Execution-Based Steganography
Recall from § 1, the security scenarios where a PIP hides
its execution behavior, e.g., execution-based steganography.
In order to show that these scenarios are feasible, we gen-
erated a PIP that acts as a simple “hello world” on ARM,
but as a virus on x86. We ﬁrst created a virus for x86
(RG.poc) from scratch, which infects ELF ﬁles on the sys-
tem whenever it executes. Then we fed the virus into our PI
generator with a “hello world” program compiled for ARM
to generate a PIP. The resulting PIP acts as a simple virus
on x86. However, if we change the ELF header of the PIP to
indicate the ﬁle is for ARM, then the program runs as a sim-
ple “hello world” program on ARM. It is trivial to generate
a platform-independent virus by simply substituting ARM
virus for the “hello world” program. Thus, we conclude that
both hiding the execution behaviors of a program and cre-
ating platform-independent viruses by generating a PIP is
possible.
6.5 Performance Comparison
We measured the running time for executing three PIPs
on x86 and ARM: the prime checker, helloworld, and lo-
calshell (from the previous sections). We ran helloworld
and the localshell 100 times on ARM, and 1000 times on
x86 in a loop to measure the time, and all the results were
averaged over 10 runs. Figure 7 shows the run-time perfor-
mance on our x86 Pentium D machine running the native
x86 as baseline. We ran the PIP natively, and ran the native
ARM using a QEMU emulator on the same machine. The
result shows 0.1% and 5.5% of average performance degra-
dation on x86 and ARM, respectively. We think that the
performance degrade on ARM is greater than on x86 due to
the QEMU’s emulation overhead. Thus, we conclude that
PIPs do not degrade performance signiﬁcantly.
7. RELATED WORK
Multi-Platform Executables. There has been consider-
able eﬀort toward running an executable on multiple plat-
 1 10 100helloworldlocalshellprime checkerAverage Time in log-scale (sec)native x86PIP on x86native ARMPIP on ARM556the gadget body, e.g., push eax in the gadget header can
be undone by pop eax in the gadget body before the actual
machine-speciﬁc logic. Second, it might be possible to per-
form semantic analysis of the input program to make sure
any side eﬀects in the header have no overall eﬀect on the
program. Third, the requirement of nop instructions does
not apply to most of the shellcode because shellcode does
not consider the eﬀect of ﬂags in general.
Large Input Programs. Given two input programs b1 and
b2, one simple way to create a PIP is to generate h||b1||b2
where h is a gadget header that identiﬁes the running plat-
form. We stress that such a solution does not demonstrate
a Turing-complete PIP scenario. In addition, one practical
issue is that we may not be able to ﬁnd a header h with a
jump target large enough to skip over b1 to execute b2. This
problem can be solved by inserting a long jump trampoline
that eventually lead to executing b1 on m1, and b2 on m2.
It is trivial to apply this technique in RG.
Indirect Jumps and Self-Modifying Code. Our current
prototype does not handle indirect jumps (e.g., jmp *eax)
and self-modifying code. Both cases would require an anal-
ysis, or set of techniques to ensure the jump target is to the
correct gadget header. For example, indirect jumps can be
handled if we know the jump targets, e.g., using an analysis
such as VSA [5]. Alternatively, one could include a run-time
monitor in the PIP itself that “ﬁxed-up” jumps at run-time.
Such extensions touch more on static and dynamic analysis
than the fundamental possibility of automatic PIP genera-
tion and, thus, are left outside the scope of this paper.
Generating Platforms. In our approach, we create a sin-
gle program that can exhibit diﬀerent behaviors, depending
upon which platform it is run on. A related problem is:
given a program string, generate a new platform (e.g., emu-
lator or instruction set update) such that the same program
string has a predetermined diﬀerent behavior. For example,
Intel could use such a procedure to design a micro-code up-
date to turn a pre-determined program into malware. We
leave such questions as open problems for future work.
9. CONCLUSION
In this paper, we have developed techniques for automati-
cally generating a single program string may run on multiple
architectures. The central security implications of our algo-
rithm is that the results of any static or dynamic analysis
must be prefaced with the assumed platform. These im-
plications lead directly to new security scenarios, such as
execution-based steganography and rogue updates aﬀecting
security. Our techniques can also be used to ease cross-
platform program (and shellcode) development. Finally, we
show that, empirically, the amount of overlap between in-
struction sets means PIPs are likely hard to detect.
10. ACKNOWLEDGEMENTS
We thank Richard (Drew) Dean, Virgil D. Gligor, Melanie
Thompson, and the anonymous reviewers for their helpful
feedback. We also thank Jessica K. Hodgins, Lujo Bauer,
and Raj Rajkumar for providing the variety of hardware
needed for this paper. The authors were supported in part
by funding by CMU CIT’s Dean Fellowship.
References
[1] exploit-db. http://www.exploit-db.com/.
[2] FatELF. http://icculus.org/fatelf/.
[3] A. Appel. Modern Compiler Implementation in ML.
Cambridge University Press, 1998.
[4] Apple.
Universal binary programming guidelines.
http://developer.apple.com/documentation/
MacOSX/Conceptual/universal_binary/universal_
binary.pdf.
[5] G. Balakrishnan, R. Gruian, T. Reps, and T. Teitel-
baum. Codesurfer/x86 - a platform for analyzing x86
executables. In Proc. of the International Conference
on Compiler Construction, Apr. 2005.
[6] C. Cachin.
An information-theoretic model
for
steganography.
In Proc. of the Second International
Workshop on Information Hiding, pages 306–318, Lon-
don, UK, 1998. Springer-Verlag.
[7] C. Cifuentes, M. V. Emmerik, and N. Ramsey. The de-
sign of a resourceable and retargetable binary transla-
tor. In Proc. of the 6th Working Conference on Reverse
Engineering, pages 280–291, Oct. 1999.
[8] D. Dean. Personal email correspondence. Email ex-
change regarding prior work in multi-platform pro-
grams on August 4, 2009.
[9] K. Ebcioglu, E. Altman, M. Gschwind, and S. Sathaye.
IEEE
Dynamic binary translation and optimization.
Transactions on Computers, 50(6):529–548, 2001.
[10] funkysh.
Into my ARMs: Developing StrongAR-
M/Linux shellcode. Phrack, 58, Dec. 2001.
[11] G. R. Gircys. Understanding and using COFF. O’Reilly
& Associates, Inc., Sebastopol, CA, USA, 1988.
[12] N. Hopper, L. von Ahn, and J. Langford. Provably se-
cure steganography. IEEE Trans. Comput., 58(5):662–
676, 2009.
[13] O. Kolesnikov and W. Lee. Advanced polymorphic
worms: Evading ids by blending in with normal traf-
ﬁc. Technical Report GIT-CC-05-09, Georgia Institute
of Technology, 2004.
[14] J. Mason, S. Small, F. Monrose, and G. MacManus.
English shellcode. In Proc. of the 16th ACM conference
on Computer and Communications Security, pages 524–
533, New York, NY, USA, 2009.
[15] G. Neiger, A. Santoni, F. Leung, D. Rodgers, and
Intel R(cid:13)virtualization technology: Hard-
R. Uhlig.
ware support for eﬃcient processor virtualization.
Intel R(cid:13)Technology Journal, 10(3):167–177, 2006.
[16] Nemo. Multi-arch shellcode. http://seclists.org/
fulldisclosure/2005/Nov/387, 2005.
[17] H. Shacham. The geometry of innocent ﬂesh on the
bone: Return-into-libc without function calls (on the
x86). In Proc. of the 14th ACM Conference on Com-
puter and Communications Security, pages 552–561,
New York, NY, USA, 2007.
[18] G. J. Simmons. The prisoners’ problem and the sub-
liminal channel. In Proc. of CRYPTO ’83, pages 51–67.
Plenum Press, 1984.
[19] R. L. Sites, A. Chernoﬀ, M. B. Kirk, M. P. Marks, and
S. G. Robinson. Binary translation. Commun. ACM,
36(2):69–81, 1993.
[20] A. Tevanian, M. DeMoney, K. Enderby, D. Wiebe, and
G. Snyder. Method and apparatus for architecture in-
dependent executable ﬁles, 1993.
[21] C. Vulnerabilities
CVE-2005-
3252. http://cve.mitre.org/cgi-bin/cvename.cgi?
name=CAN-2005-3252, 2005.
and Exposures.
[22] C. Vulnerabilities
CVE-2010-
0036. http://cve.mitre.org/cgi-bin/cvename.cgi?
name=CVE-2010-0036, 2010.
and Exposures.
[23] Y. Younan, P. Philippaerts, F. Piessens, W. Joosen,
S. Lachmund, and T. Walter. Filter-resistant code in-
jection on ARM. In Proc. of the 16th ACM conference
on Computer and Communications Security, pages 11–
20, New York, NY, USA, Nov. 2009.
557APPENDIX
s h e l l c o d e = ”\ x06\ xeb\ x55\ x0e\ x 0 f \ x60\ xa0\ xe1\ x32\ x6e\ x86\ xe2\ x06\ xd0\ xa0\ xe1\ x24\ x70\ x 8 f \ xe2\ x32\
x7e\ x47\ xe2\ x06\ x60\ x26\ xe0\ x32\ x6e\ x86\ xe2\ x07\ x20\ xd6\ xe7\ x30\ x20\ x82\ xe2\ x07\ x20\ xc6\ xe7\
x01\ x60\ x86\ xe2\ x4b\ x0e\ x56\ xe3\ x f 9 \ x f f \ x f f \ xda\ x06\ x60\ x26\ xe0\ xd2\ x f 0 \ x f 2 \ xb0\ xd1\ xe0\ x52\
xb2\ xd1\ xd0\ x51\ xb2\ xd1\ x4c\ x70\ xb3\ xe9\ x40\ x57\ xb2\ xd0\ xd0\ xd0\ x b f\ xeb\ xd0\ xd0\ xba\ x31\ xc9\
x83\ xe9\ xeb\ xd9\ x e e\ xd9\ x74\ x24\ x f 4 \ x5b\ x81\ x73\ x13\ xe8\ x8e\ x30\ x01\ x83\ xeb\ x f c \ xe2\ x f 4 \ xd9\
x55\ x63\ x42\xbb\ xe4\ x32\ x6b\ x8e\ xd6\ xa9\ x88\ x09\ x43\ xb0\ x97\ xab\ xdc\ x56\ x69\ xe7\ x f 2 \ x56\ x52\
x61\ x 6 f \ x5a\ x67\ xb0\ xde\ x61\ x57\ x61\ x 6 f \ x f d\ x81\ x58\ xe8\ xe1\ xe2\ x25\ x0e\ x62\ x53\ xbe\ xcd\ xb9\
xe0\ x58\ xe8\ x f d\ x81\ x7b\ xe4\ x32\ x58\ x58\ xb1\ x f d\ x81\ xa1\ x f 7 \ xc9\ xb1\ xe3\ xdc\ x58\ x2e\ xc7\ x f d\
x58\ x69\ xc7\ x e c\ x59\ x 6 f \ x61\ x6d\ x62\ x52\ x61\ x 6 f \ x f d\ x81\ x0a\ x90\ x90\ x90\ xd0\ x20\ x70\ xb1\ xd1\
xe0\ x f 1 \ xb0\ xd2\ xd0\ x f d\ xb9\ xd0\ xe0\ x 6 f \ xb5\ xd0\ xd0\ xd0\ xba\ xd2\ xd0\ x f 0 \ xd0\ xd4\ xe0\ x f d\ xb5\
xdd\ xe0\ x70\ xb1\ xd2\ xd0\ x70\ xb1\ xe0\ x f 0 \ x70\ xb3\ xd1\ x40\ x57\ xb2\ xd0\ xd0\ xd0\ x b f\ xd5\ xd0\ x70\
xb1\ xd1\ xeb\ x70\ xb3\ xe0\ x f 0 \ x70\ xb3\ xd2\ x40\ x57\ xb2\ xd0\ xd0\ xd0\ x b f\ xd5\ xd0\ x70\ xb1\ xd0\ xe0\
x70\ xb3\ xd0\ x f 0 \ x70\ xb3\ xd1\ x40\ x57\ xb2\ xd0\ xd0\ xd0\ x b f\ xd0\ x20\ x70\ xb1\ xd2\ xe0\ x70\ xb3\ x 0 f \
x40\ x70\ xb3\ xd0\ xd0\ xd0\ x b f\ xd5\ xd0\ x70\ xb1\ xd1\ xe0\ x70\ xb3\ xd0\ xd0\ xd0\ x b f\ xd5\ xd0\ x70\ xb1\
xd0\ xe0\ x70\ xb3\ xd0\ xd0\ xd0\ x b f\ xd0\ xd0\ x f 0 \ xb0\ xd1\ xe0\ x f 1 \ xb0\ xd2\ x f 0 \ x f 2 \ xb0\ xd4\ x f 0 \ x f d\
xb5\ xd0\ x90\ x 6 f \ xb5\ xd0\ xd0\ xd0\ xba\ x f f \ x f f \ x43\ x38\ xd4\ x90\ x f d\ xb5\ xd0\ x90\ x 6 f \ xb5\ xd0\ xd0\
xd0\ xba\ x f f \ x32\ x39\ x3e\ xd4\ x90\ x f d\ xb5\xdd\ xd0\ x70\ xb1\xdb\ x40\ x70\ xb3\ xd0\ xd0\ xd0\ x b f\ xd0\
xd0\ x70\ xb3\ xd1\ x40\ x70\ xb3\ xd0\ xd0\ xd0\ x b f ”
Figure 8: Example generated PI (ARM/x86) remote bind-shell shellcode.
00000000
00000010
00000020
00000030
00000040
00000050
00000060
00000070
00000080
00000090
000000 a0
000000 b0
000000 c0
000000 d0
000000 e0
000000 f0
7 f 45 4 c 46 01 01 01 00
02 00 03 00 01 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 01 00 00 00
00 80 04 08 f4 00 00 00
00 10 00 00 90 eb 3 e 20
07 00 00 10 00 00 04 24
a4 0 f 02 24 0 c 00 00 00
f8 ff 11 04 00 00 00 00
72 6 c 64 0 a 90 90 90 90
ba 0 c 00 00 00 b8 04 00
80 e8 e4 ff ff ff 48 65
64 0 a 90 90 01 00 a0 e3
04 70 a0 e3 00 00 00 ef
00 00 00 ef 00 00 a0 e1
72 6 c 64 0 a
00 00 00 00 00 00 00 00
54 80 04 08 34 00 00 00
34 00 20 00 01 00 00 00
00 00 00 00 00 80 04 08
f4 00 00 00 05 00 00 00
17 00 00 2 a 16 00 00 3 a
21 28 e0 03 0 c 00 06 24
a1 0 f 02 24 0 c 00 00 00
48 65 6 c 6 c 6 f 20 77 6 f
eb 17 31 db 43 8 b 0 c 24
00 00 cd 80 31 c0 40 cd
6 c 6 c 6 f 20 57 6 f 72 6 c
18 10 8 f e2 0 c 20 a0 e3
00 00 a0 e3 01 70 a0 e3
48 65 6 c 6 c 6 f 20 57 6 f
|. ELF . . . . . . . . . . . . |
| . . . .. . . . T ...4...|
| . . . . . . . . 4 . .....|
| . . . . . . . . . . . . . . . . |
| . . . . . . . . . . . . . . . . |
|...... > . .. * . . . : |
|....... $ !(..... $ |
|... $ ....... $ ....|
| . . . .. . . . Hello wo |
| rld . .. . . . . 1 . C .. $ |
| . . . . . . . . . . . . 1 . @ .|
|...... Hello Worl |
| d . . . . . . . . . . . . ..|
|. p . . . . . . . . . . . p ..|
| . . . . . .. . Hello Wo |
| rld .|
Figure 9: Hexdump of a Hello World PI program for ARM, MIPS and x86 (244 byte).
558