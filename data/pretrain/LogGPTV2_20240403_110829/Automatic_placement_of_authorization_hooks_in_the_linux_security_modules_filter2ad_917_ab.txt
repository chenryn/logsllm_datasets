nel analysis to produce the authorization graph, which relates each
kernel function to the set of hooks that must guard it—each ker-
nel function must be guarded by a set of hooks that authorize the
conceptual operations it performs.
Figure 2: Overall architecture of TAHOE.
An example best demonstrates TAHOE’s analysis. Figure 3(A)
shows a snippet of kernel code: vfs rmdir, the virtual ﬁle sys-
tem function to remove a directory. This function accepts two ar-
guments, corresponding to data structures of the directory to be
deleted (dentry), and the parent of this directory (dir). It tran-
sitively calls permission, which performs a discretionary access
control (DAC) [16] check on line (P3) to determine whether the
current process has “write” and “execute” permissions on the par-
ent directory. If so, control reaches line (V5), which resolves to
the appropriate physical ﬁle system call (such as ext2 rmdir) to
remove the directory.
Figure 3(B) shows a portion of the output for vfs rmdir when
TAHOE is used with the kernel module from the LSM implementa-
tion of SELinux (henceforth abbreviated to LSM-SELinux). It de-
termines that the call to dir->i op->rmdir (on line (V5)) must be
protected with two LSM-SELinux hooks: selinux inode rmdir
and selinux inode permission, called with MAY WRITE, while
the DAC check on line (P3) must be supplemented with the hook
selinux inode permission, which checks for the correspond-
ing MAC permissions. We now provide a high-level description of
the analysis that TAHOE employs.
TAHOE’s kernel analysis (Section 3.2) analyzes the ﬁle system
code and infers that directory removal (dir->i op->rmdir, line
(V5)) involves performing the conceptual operations DIR RMDIR,
DIR WRITE and DIR SEARCH. Intuitively, this is because a typ-
ical ﬁle system, such as ext2 does the following to remove a di-
rectory bar from a directory foo: (i) it ﬁnds the entry of bar in an
appropriate kernel data structure of foo (DIR SEARCH), and (ii)
removes the entry of bar from this data structure (DIR RMDIR),
which involves writing to the data structure (DIR WRITE). Note
that directory removal is a specialized write: removal of bar from
foo requires removal of the entry of bar from foo, as opposed
to other directory manipulations, such as directory creation, which
adds a new entry. Thus, DIR RMDIR denotes a special kind of di-
rectory write, as opposed to DIR WRITE, which denotes the generic
write operation.
(P1)int permission(struct inode *inode,
int mask) {
(P2)
(P3)
(P4)
...
inode->i_op->permission(inode,mask);
...}
(M1)int may_delete(struct inode *dir,
(M2)
(M3)
(M4)
(M5)
struct dentry *vic, int isdir) {
...
// DAC check for WRITE and EXEC
permission(dir,MAY_WRITE|MAY_EXEC);
...}
(V1)int vfs_rmdir(struct inode *dir,
struct dentry *dentry) {
(V2)
(V3)
(V4)
(V5)
(V6)
may_delete(dir, dentry, 1);
...
// Remove the directory
dir->i_op->rmdir(dir, dentry);
...}
(A) VFS code from linux-2.4.21/fs/namei.c for directory
removal. Error checking code has been omitted for brevity.
Hooks for inode->i op->permission on Line (P3):
(H1) selinux inode permission(dir,mask)
Hooks for dir->i op->rmdir on Line (V5):
(H2) selinux inode rmdir(dir,dentry)
(H3) selinux inode permission(dir, MAY WRITE)
(B) Analysis results of TAHOE (with SELinux hooks) for code
fragment shown in (A).
Figure 3: Example to illustrate analysis performed by TAHOE.
TAHOE’s hook analysis (Section 3.1) analyzes the source code
of SELinux hooks (not shown in Figure 3) and infers that the hook
selinux inode permission, when invoked with MAY EXEC and
MAY WRITE, checks that the conceptual operations DIR SEARCH
and DIR WRITE, respectively, are authorized. It also infers that
selinux inode rmdir checks that both the conceptual operations
DIR SEARCH and DIR RMDIR are authorized.
When TAHOE combines the results of these analyses (Section 3.3)
it produces an authorization graph, a portion of which is shown in
Figure 3(B). Because dir->i op->rmdir performs DIR SEARCH
and DIR RMDIR, it is protected by selinux inode rmdir, which
authorizes these operations. In addition, dir->i op->rmdir per-
forms DIR WRITE, which selinux inode permission autho-
rizes when invoked with MAY WRITE. TAHOE also supplements
existing DAC checks, such as the one on line (P3), with hooks that
perform the corresponding MAC checks, as shown in line (H1) of
the output. It is important to note that TAHOE does not use exist-
ing DAC checks to determine hook placement. Its analysis is based
upon conceptual operations performed by each kernel function.
Indeed, hooks are also placed in LSM-SELinux as shown in Fig-
ure 3(B), though in the case of LSM-SELinux this placement was
determined manually. This validates the results of TAHOE’s anal-
ysis because the hook placement in LSM-SELinux has been tested
thoroughly, and the errors found by veriﬁcation tools [10, 23] have
been ﬁxed. However, in the case of vfs rmdir, LSM-SELinux
optimizes hook placement: A closer look at the source code of
vfs rmdir reveals that all code paths to line (V5) pass through
line (M4) and line (P3) (formally, line (M4) and line (P3) dominate
line (V5) [17]). Because the hook call on line (H3) is subsumed
Ops authorizedby each hookOps performed byeach kernel functionHookAnalysisJoinAlgorithmHook PlacerAuthorization graphHook−PlacedKernelSource code ofauthorization hooksKernelAnalysisLinux kernel(no hooks placed)TAHOEby the hook call on line (H1), LSM-SELinux only places the hooks
shown in line (H1) and line (H2). While TAHOE infers the autho-
rization graph which relates hooks and kernel functions correctly, it
currently does not optimize hook placement; we leave optimization
for future work. We also note that the security of the LSM frame-
work is determined by the correctness of the authorization graph.
The rest of this section describes each of TAHOE’s components in
greater detail.
3.1 Analysis of Authorization Hooks
To determine the conceptual operations authorized by each hook,
TAHOE analyzes the kernel module that contains source code of
hooks. In addition to determining the conceptual operations autho-
rized, it also determines the conditions under which these opera-
tions are authorized. Consider Figure 4(A), which shows a snippet
of the implementation of the hook selinux inode permission
in the LSM-SELinux kernel module. This snippet authorizes search-
ing, writing to, or reading from an inode representing a directory,
based upon the value of mask. The authorization is performed by
the call to inode has perm, which authorizes a conceptual op-
eration on an inode based upon the access vector2 it is invoked
with.
In Figure 4(A), the access vector is obtained by a call to
file mask to av.
(S1)int selinux_inode_permission(struct *inode, int mask)
(S2){ if (mask == 0) return 0;
(S3)
return inode_has_perm
(file_mask_to_av(inode->i_mode,mask),...);
(S4)}
if ((mode & S_IFMT) != S_IFDIR) {
/* File-related conceptual operations */
(F1)access_vector_t file_mask_to_av(int mode, int mask)
(F2){ access_vector_t av = 0;
(F3)
(F4)
(F5)
(F6)
(F7)
(F8)
(F9)
(F10) return av; }
if (mask & MAY_EXEC) av |= DIR__SEARCH;
if (mask & MAY_WRITE) av |= DIR__WRITE;
if (mask & MAY_READ) av |= DIR__READ;
} else {
}
(A) Code for the hook selinux inode permission.
Analysis output (from Algorithm 1) for selinux inode permission:
• h(mask 6= 0) ∧ inode isdir ∧ (mask & MAY EXEC) k DIR SEARCHi
• h(mask 6= 0) ∧ inode isdir ∧ (mask & MAY WRITE) k DIR WRITEi
• h(mask 6= 0) ∧ inode isdir ∧ (mask & MAY READ) k DIR READi
where “inode isdir” denotes (inode->i mode & S IFMT == S IFDIR).
(B) Portion of the output of TAHOE’s hook analysis for
selinux inode permission.
Figure 4: Example to illustrate TAHOE’s hook analysis.
Figure 4(B) shows a fragment of the output of TAHOE’s anal-
ysis for this hook. Each line of the output is a tuple of the form
hpredicate k OPERATIONi, where the predicate only contains for-
mal parameters of the hook. This tuple is interpreted as follows:
if the hook is invoked in a context such that predicate holds, then
it checks that the conceptual operation OPERATION is authorized.
In this case, TAHOE infers that for inodes that represent directories
(i.e., the inodes with (inode->i mode & S IFMT == S IFDIR)) the
hook selinux inode permission checks that the conceptual op-
erations DIR SEARCH, DIR WRITE or DIR READ are authorized,
based upon the value of mask. We now describe the hook analysis
algorithm used by TAHOE.
2Conceptual operations in LSM-SELinux are represented using bit-vectors, called ac-
cess vectors. Because we derived the set of conceptual operations used by TAHOE by
examining LSM implementations of popular MAC policies, including LSM-SELinux,
there is a one-to-one mapping between the conceptual operations used by TAHOE and
the access vectors in LSM-SELinux.
3.1.1 The Hook Analysis Algorithm
The algorithm to analyze the kernel module containing source
code of hooks is shown in Algorithm 1. For ease of explanation,
assume that there is no recursion; we explain how we deal with
recursion later in the section. The analysis proceeds by ﬁrst con-
structing the call-graph [17] of the kernel module. A call-graph
captures caller-callee relationships. Each node of the call-graph is
a function in the kernel module; an edge f → g is drawn if func-
tion f calls function g. The call-graph is processed bottom-up,
starting at the leaves, and proceeding upwards. For each node in
the call-graph, it produces a summary [19], and outputs summaries
of hooks.
Algorithm : ANALYZE MODULE(M, H)
Input
: (i) M: Module containing source code of hooks, (ii) H: A set
containing the names of hooks.
: For each h ∈ H, a set {hpredicate k CONCEPTUAL-OPi},
denoting the conceptual operations authorized by each hook,
and the conditions under which they are authorized.
Output
1
2
3
4
5
6
Construct the call-graph G of the module M
L := List of vertices of G, reverse topologically sorted
foreach (f ∈ L) do
Summary(f ) := ANALYZE FUNCTION(f , Entrypoint(f ), true)
foreach (h ∈ H) do
Output Summary(h)
Algorithm 1: TAHOE’s algorithm for hook analysis.
Summary construction is described in Algorithm 2. The sum-
mary of a function f is a set of pairs hpred k OPi, denoting the
condition (pred) under which a conceptual operation (OP) is au-
thorized by f. The analysis in Algorithm 2 is ﬂow- and context-
sensitive. That is, it respects the control-ﬂow of each function, and
precisely models call-return semantics. Intuitively, summary con-
struction for a function f proceeds by propagating a predicate p
though the statements of f. At any statement, the predicate denotes
the condition under which control-ﬂow reaches the statement. The
analysis begins at the ﬁrst statement of the function f (denoted by
Entrypoint(f)), with the predicate set to true.
At an if-(q)-then-else statement, the true branch is ana-
lyzed with the predicate p ∧ q, and the false branch is analyzed
with the predicate p ∧ ¬q. For instance, the value of p at line (F3)
in Figure 4(A) is true. Thus, lines (F6)-(F8) are analyzed with
true ∧ (mode & S IFMT) == S IFDIR. At Call g(a1, a2, . . . , an),
a call to the function g, the summary of g is “specialized” to the
calling-context. Note that because of the order in which functions
are processed in Algorithm 1, the summary of g is computed be-
fore f is processed. The summary of g is a set of tuples hqi k OPii.
Because of the way summaries are computed, formal parameters
of g appear in the predicate qi. To specialize the summary of g,
actual parameters a1, a2, . . ., an are substituted in place of formal
parameters in qi. The resulting predicate ri is then combined with
p, and the entry hp ∧ ri k OPii is included in the summary of f. In-
tuitively, g authorizes operation OPi if the predicate qi is satisﬁed.
By substituting actual parameters in place of formal parameters,
we determine whether this call to g authorizes operation OPi; i.e.,
whether the predicate qi, specialized to the calling context, is satis-
ﬁable. Because the call to g is reached in f under the condition p,
an operation is authorized by g only if p ∧ ri is satisﬁable.
For other statements, the analysis determines whether the state-
ment potentially authorizes an operation OP. Determining whether
a statement authorizes an operation OP is speciﬁc to the way con-
ceptual operations are represented in the kernel module. For in-
stance, in LSM-SELinux, conceptual operations are denoted by
bit-vectors, called access vectors (of type access vector t), and
there is a one-to-one mapping between access vectors and concep-
Algorithm : ANALYZE FUNCTION(f , s, p)
Input
: (i) f : Function name, (ii) s: Statement in f from which to start
the analysis, (iii) p: A Boolean predicate.
: A set {hpredicate k CONCEPTUAL-OPi}.
Output
R := φ
switch TYPE-OF(s) do
case if (q) then Btrue else Bf alse
R := ANALYZE FUNCTION(f , Entrypoint(Btrue), p ∧ q)