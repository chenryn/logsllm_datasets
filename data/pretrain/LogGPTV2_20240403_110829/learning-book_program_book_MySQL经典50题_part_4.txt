where s_id in (select s_id
--3、步骤2中得别的学号是满是登求的
from(select distinct(s_id) , count(c_id) number
5
from Score
 6
group by s_id) t1 -- 1 、学号和所修课程分 组的结 果 t1
where number=3
2 、 投机：选择出所修课程数是3（61修了 3门) 的学
号
to=i p"s pue
- 01 本 身排除
);
nysql> select *
-> where s_1d 1n (select s_1d 
fros(select distinct(s_id) . count(c_id) number
-3、步骤2中得到的学号是满足要求的
from 5core
19=i p1"s pue
2、
选择出所修课程数是3（61修了3门）的学号
-01本身排除
) ：
1s_birth
1 s_sex 1
修满3门课
03
孙风
11990-05-201男
云
in set (0.e1 sec)
我们在上面的步骤2中不考虑直接指定3（wherenumber=3），而是用01学生所修的课程数（虽然也是3）来
代替：
from Student
select *
2
where s_id in(
select s_id
from(select distinct(s_1d), count(c_id) number
-3、步骤2中得到的学号是满足要求的
5
6
from Score
7
group by s_id) t1 -- 1 、学号 和 所 修 课程 分 组的 结果 t1
8
where number= (select count(c_id) number
from Score
10
group by s_id having s_id=01)
=2、改变的地方：便用学号
01 的课程数3来代替
http:/liyangbit.com
34
---
## Page 35
Chapter1.超经典MySQL练习50题
Python数据之道
11
and s_1idI=01--01 本身 排除
12
fron Student
Mheres_id1n(
frem(select distinct(s_i6), count(c_id) nunber
select s_fd
3、步疆2中得则的学号是满足要求的
group by s_1d)t11、学号和所耀课程分组的结果t1
fron Score
(select count(c_id)m
fron Score
and s_1d 1=01
group by s_id having s_id=01)
2、置接用61跨课程数3案托督
s_id 1 s_nane I s_birth
1 s_sex 1
|1990-12-211男
94
李云
11999-68-961男
1990-85-261
2.使用group_concat函数
group_concat的使用方法为：
我们将Score表中每个s_id的c_id进行分组合并，实际的效果如下：
select
s_id
group_concat（c_idorder by c_id）--分组合并：同时排序
fron Score
group by s_id;
http://liyangbit.com
35
---
## Page 36
Chapter1.超经典MySQL练习50题
Python数据之道
mysql> select
-> 5_1d
group_concat(c_id order by c_id)
分组合并，
同时排序
>
from Score
>
group by s_id;
1s_id 1 group_concat(c_1d order by c_id) 1
+-
101,02,03
02
101,02,03
03
101,02,03
104
101,02,03
05
101,02
06
101,03
07
102,03
rows 1n set (0.8θ sec)
需要进行排序的原因是防止出现这种情况：01修的课程顺序是：01，02，03；如果有同学修课的顺序是02，03，
01，虽然顺序不同，但是本质上他们修的课程是相同的
使用排序后都会变成：01，02，03，保证结果相同
那么之后，我们只需要判断合并后和01号同学相同的结果即可，取出学号：
select *
3、查均信息
2
from Student
where s_id in(
from Score
select s_id
group by s_id
having group_concat(c_id order by c_id)=(
-2、找出和01号学生分组合井结果
相同的学号s_id;也需要排序
select group_concat(c_id order by c_id)
= 1 、找出 81 号学生分组合井的结
果，同时排序；推序很重
9
from Score
10
group by s_id
11
having s_id=01)
12
Tθ =i ps"s pue
将自身排除
13
（
http://liyangbit.com
36
---
## Page 37
Chapter1.超经典MySQL练习50题
Python数据之道
mysql>select
*
3、
查询信息
>fromStudent
where s_id in(
select s_id
from Score
group by s_id
having group_concat(c_id order by c_id)=(
select
group_concat(c_id order by c_id)
from Score
group by s_id
having s_id=θ1)
and s_id !=θ1
将自身排除
s_1d
S_name |s_birth
s_sex
θ2
钱电
1990-12-21
男
θ3
孙风
1990-05-20
04
李云
11990-08-06
男
rows
in set （0.00 sec)
1.15题目14
1.15.1题目需求
查询没有修过张三老师讲授的任何一门课程的学生姓名
1.15.2 SQL实现
自己的方法，具体过程如下：
select s_nane
学号取反找到学生姓名
from Student
where s_id not in(
select distinct(s_id)
3、课程号找到对应的学号
from Score
where c_id=(
select c_id
2、数师编号找到对应的课程号
from Course
where t_id=(
http://liyangbit.com
37
---
## Page 38
Chapter1.超经典MySQL练习50题
Python数据之道
10
select t_id
姓名找到救师增号
 11
from Teacher
12
where t_name=*张 三 *)
13
)）；
mysql> select s_name
4、
学号取反找到学生姓名
->from Student
->where s_idnot in(
>
selectdistinct（s_id）--3、课程号找到对应的学号
from Score
where c_1d=(
select c_id --
2、教师编号找到对应的课程号
from Course
where t_1d=(
select t_id
1、姓名找到教师编号
from Teacher
where t_name='张三‘)
)):
5_name
吴兰
王菊
rows in set (0.eθ sec)
修过张老师课程的学：
select distinct(s_id)
生
from Score
where c_id=(
from Course
select c_id
where t_id=(
select t_id
from Teacher
10
where t_name=′张 三 ')); --
修过张三老灯课的学生
http://liyangbit.com
38
---
## Page 39
Chapter1.超经典MySQL练习50题
Python数据之道
mysq1>
select distinct(s_id)
from Score
>
where c_id=(
select c_id
from Course
>
where t_id=(
>
select t_id
>
from Teacher
where t_name='张三‘))
修过张三老师课的学生
Is_id1
|01
03
84
rows
in set (0.00 sec)
1.16题目15
1.16.1题目需求
查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩
1.16.2 SQL实现
首先看看哪些同学是满足两门或者两门以上是及格的
mysql> select s_1d
->from Score
-> where s_score
89
> having count(s_score) >= 2;
>groupbys id
-2门课程大于等于69分的数量
5_id 1
θ1
EO
05
rows in set (0.e0 sec)
http://liyangbit.com
39
---
## Page 40
Chapter1.超经典MySQL练习50题
Python数据之道
2 门及以上不及格 的
select
s_id
,round (avg(s_score))
avg_score
from Score
where s_score = 2;
不及格的有2门以上
说明04，06是我们最终想要的结果
mysql> select
-> s_id
>
,round(avg(s_score))
->from Score
avg_score
-> where 5_score  group by s_id
->having count(s_score) >= 2;
"-2门课程大于等于60分的数量
s_id | avg_score |
401
5e1
自己的方法
select
s.s_id
,s.s_nane
, t.avg_score
一
from Student s
7
join (select
8
s_id
9
,round(avg(s_score))
from Score
avg_score
10
11
where s_score = 2)t
14
on s.s_id=t.s_id
http:/liyangbit.com
40
---
## Page 41
Chapter1.超经典MySQL练习50题
Python数据之道
>5.5_id
>
,s.s_name
,t.avg_score
>
from Student S
>
join (select
s_id
,round(avg(s_score))
avg_score
from Score
where s_score = 2)t
on s.s_id=t.s_id;
s_id|s_name|avg_score|
θ4
李云
401
66
吴兰
501
rows
inset
(0.00 sec)
参考方法 1
select
a.s_id,
ROUND(AVG(b. s_score))
a.s_name,
from Student a
left join Score b
9
on a.s_id = b.s_id
10
where a.s_id in(
11
select s_id
from Score
13
where s_score=2)
16
group by a.s_id,a.s_name
17
18
参考方法 2
19
select
20
s.s_id
21
,S_name
22
,round(avg(s_score), 2) avg_score
23
fron Student s
24
join Score sc
2.5
on s.s_id=sc.s_id
26
and sc.s_score = 2;
2门课
1.16.3改进点
上面的两种方法都没有考虑都08学生，3门都没有成绩，这个本题需要改进的地方。
1.17题目16
1.17.1题目需求
检索01课程分数小于60，按分数降序排列的学生信息
1.17.2 SQL实现
自己的方法如下：
首先从Score表中找出哪些学生是满足这个要求：
select
s_id
,s_score
4
from Score
where s_score 
select
s_id
,s_score
from Score
wheres_score select s.
->from Student s
->where s.s_id in （
select
s_id
2
from Score
->where5_scoreandc_id=01
->）：
5_id
|s_name|s_birth
s_sex
θ4
李云
1990-08-06
男
06
吴兰
1992-03-011
女
rows
in set
（0.00sec)
select
S , *
,t.s_score
4
from Student s
join (select s_id,s_score
2 、 Student 和 t的 连 接 查 询
from Score
where s_score  select
-> 5.*
>
,t.s_score
>
from Student 5
->join (select s_id,s_score
-2、Student和t的连接查询
>
from Score
7
where s_score on 5.5_id=t.s_id;
s_id | s_name
1s_birth
Is_sex|s_score|
|李云
+
84
1990-08-06
男
/
501
186
吴兰
|1992-03-01丨女
431
rows 1n set (e.θθ sec)
http:/liyangbit.com
44
---
## Page 45
Chapter1.超经典MySQL练习50题
Python数据之道
自己的方法2：两个表的直接连接查询+where条件
select
3
S , *
4
,sc.s_score
from Student s
b
join Score sc
on s.s_id=sc.s_id
S
where sc.c_id=e1 and sc.s_score  select
->5. *
->,sc.s_score
->
from Student 5
>
join Score sc
on s.s_id=sc.s_id
->where sc.c_id=θ1 and sc.s_score  order by sc.s_score desc;
默认就是降序desc
5_id|s_name |s_birth
1s_sex| s_score|
04
李云
1990-08-061男
50
06
吴兰
1992-03-01
1女
431
rows
in set （0.θθ sec)
1.18题目17
1.18.1题目需求
按平均成绩从高到低（降序）显示所有学生的所有课程的成绩以及平均成绩
1.18.2 SQL实现
下面是自己的解法：
1、先求出每个同学的平均分，并降序排列
select
s_id
,round(avg(s_score) ,2) avg_score
from Score
group by s_1d
order by 2 desc;
http://liyangbit.com
45
---
## Page 46
Chapter1.超经典MySQL练习50题
Python数据之道
mysql> select
->s_id
>
,round(avg(s_score),2) avg_score
>fromScore
group by s_id
->orderby2desc;
PL
avg_score
θ7
91.50
01
88.67
θ3
82.00
05
81.50
2
70.00
06
49.50
θ4
40.00
rows in set(0.00sec)
自己的方法
2
select
3
s.s_id
,s.c_1d
5
,s.s_score
6
from Score s
, t.avg_score
T
8
join (select
9