# 前言
前天参加web安全测试大赛决赛，遇到了一个题目，在网上找到了类似的题目，但是当时看了下看不懂，拿着payload无法利用，因此这几天一直在复现比赛的题目，顺便记录一下什么是`hash长度拓展攻击`
# 0x01 什么是hash长度拓展攻击
hash长度拓展攻击，概括一下就是由于hash的生成机制使得我们可以人为的在原先的明文基础上添加新的拓展字符，从而使得原本的加密链变长，进一步控制加密链的最后一节，使得我们得以控制最终的结果。  
这里简单介绍一下hash算法。
## hash算法
hash算法又叫做散列算法。是一种把任意长度的字符串加密为固定长度的字符串的加密算法，该算法生成的密文就是散列值。简单说hash算法就是一种通过单向函数加密明文生成信息摘要的算法。  
现在常用的has算法有MD5和SHA-1。这里就以MD5算法为例，解释一下hash长度扩展攻击。  
**要去利用MD5算法解释该攻击方式，那就要先去了解一下MD5的加密过程**
# 0x02 MD5加密
## MD5
MD5算法是典型的一种信息摘要算法，它是由md2、md3和md4演变而来的。无所是哪一种的MD算法都是将一个任意长度的字符串加密为一串固定长度的密文。在这整个加密过程中，会将明文字符串转换为一个128位的消息摘要，接着把消息摘要转换为一个十六进制的字符串就会得到32位的字符串，也就是我们平时见到的MD5密文  
`因为MD5加密过程经过了压缩，加密和hash算法，所以MD5加密的内容是不可逆的`
## MD5算法过程
要了解算法的原理过程，肯定要有一个算法的流程图，这样看起来就会很明白了  
按照这个图片，我们可以把流程分为下面几个步骤：
  1. 把消息分为n个分组
  2. 对最后一个消息分组进行填充
  3. 和输入量进行运算，运算结果位下一个分组的输入量
  4. 输出最终结果
## MD5算法实现
因为单纯讲过程过于枯燥而且不易明白，所以这里采用举例子方式进行解释
### 加密举例
比如现在我们要对明文0123456789abcdef进行加密，首先第一步，将明文字符串转换为二进制字符串，这里贴出转换脚本
    def text_to_binary(text_str):
        binary_str = ' '.join(format(ord(x), 'b') for x in text_str)
        return binary_str
    text_input = '0123456789abcdef'
    binary_output = text_to_binary(text_input)
    print('binary result is:{0}'.format(binary_output))
    #转换结果 00110000 00110001 00110010 00110011 00110100 00110101 00110110 00110111 00111000 00111001 01100001 01100010 01100011 01100100 01100101 01100110
由于一个ASCII码字符对应8位二进制字符，那么我们现在就得到了128位二进制字符，为了方便观看，我们在010（winhex）里面写入这些内容，因为010（winhex）是16进制，所以还要去转换为16进制字符。
    def binary_to_hex(binary_str):
        decimal_number = int(binary_str, 2)
        hex_number = hex(decimal_number)
        return hex_number
    binary_input = '110000110001110010110011110100110101110110110111111000111001110000111000101100011110010011001011100110'
    hex_output = binary_to_hex(binary_input)
    print('hex result is:{0}'.format(hex_output))
    #转换结果：0x80
在010（winhex）写入内容  
这样子看起来就舒服多了，下面要对明文进行填充，使得明文位长度mod
512=448（bit）。进行填充的方式前面说了，就是在二进制下第一个补1，后面的依次补0
。但是在这里咱们是以十六进制形式在010里演示的，而对于十六进制来说，一个十六进制字符对应4个二进制字符，所以对于010里面数据来说，10000000(2)==80(16)，补充上去就是  
然后后面依次补0，直至满足上面式子为止。得到最终补位结果  
然后进行补位。  
现在经过填充明文有448it，也就是56byte，还需要补位8byte。原始明文为`0123456789abcdef`共16byte，有16 *
8=128bit，转换为十六进制为80，写入倒数第八个byte位，之后补7byte的0x00 。  
接下来就用这64byte的数据进行计算，与初始向量进行运算  
计算信息的摘要需要用补位结果的数据进行运算，也就是补位后的512bit的消息，在计算时候有一个初始的向量，这里初始的向量是一个固定的值
    A 01 23 45 67 0x67452301
    B 89 AB CD EF 0xEFCDAB89
    C FE DC BA 98 0x98BADCFE
    D 76 54 32 10 0x10325476
由于在计算机存储中采用的是小端存储方式，所以上面的初始化向量在程序中的初始化代码为后面的0x部分。  
然后将刚才的512bit消息和初始化向量进行第一轮的运算，之后初始化向量会被新的值覆盖，最后一轮的向量经过高低位互换后就是计算出的MD5值。
    高低位互换：
        abcdef->fedcba
这个高低位互换的过程如下：
    假如最后一轮的运算后的向量值为：
        A=0xabcdef12
        B=0xabcdef12
        C=0xabcdef12
        D=0xabcdef12
    那么进行高低位互换之后得到的数值为：
    12 ef cd ab
    12 ef cd ab
    12 ef cd ab
    12 ef cd ab
进行拼接得到最后加密结果  
`12efcdab12efcdab12efcdab12efcdab`
# hash长度扩展攻击
hash长度的拓展攻击的实现就是基于上面的最后一轮的值进行的，下面结合一下这次做题遇到的一个题目进行解释
    > (32 - n))) & (0xffffffff))
    shi_1 = (7, 12, 17, 22) * 4
    shi_2 = (5, 9, 14, 20) * 4