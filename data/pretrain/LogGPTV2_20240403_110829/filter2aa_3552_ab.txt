| --------- | ------ | -------------- |
| ET_NONE   | 0      | 无文件类型     |
| ET_REL    | 1      | 可重定位文件   |
| ET_EXEC   | 2      | 可执行文件     |
| ET_DYN    | 3      | 共享目标文件   |
| ET_CORE   | 4      | 核心转储文件   |
| ET_LOPROC | 0xff00 | 处理器指定下限 |
| ET_HIPROC | 0xffff | 处理器指定上限 |
虽然核心转储文件的内容没有被详细说明，但 `ET_CORE` 还是被保留用于标志此类文件。从 `ET_LOPROC` 到 `ET_HIPROC` (包括边界)被保留用于处理器指定的场景。其它值在未来必要时可被赋予新的目标文件类型。
### e_machine介绍
这一项指定了当前文件可以运行的机器架构。
| 名称       | 值    | 意义             |
| -------- | ---- | -------------- |
| EM_NONE  | 0    | 无机器类型          |
| EM_M32   | 1    | AT&T WE 32100  |
| EM_SPARC | 2    | SPARC          |
| EM_386   | 3    | Intel 80386    |
| EM_68K   | 4    | Motorola 68000 |
| EM_88K   | 5    | Motorola 88000 |
| EM_860   | 7    | Intel 80860    |
| EM_MIPS  | 8    | MIPS RS3000    |
其中 EM 应该是 `ELF Machine` 的简写。
其它值被在未来必要时用于新的机器。 此外，特定处理器的ELF名称使用机器名称来进行区分，一般标志会有个前缀`EF_` （ELF Flag）。例如，在`EM_XYZ`机器上名叫 `WIDGET` 的标志将被称为 `EF_XYZ_WIDGET`。
### e_version介绍
标识目标文件的版本。
| 名称         | 值    | 意义   |
| ---------- | ---- | ---- |
| EV_NONE    | 0    | 无效版本 |
| EV_CURRENT | 1    | 当前版本 |
1 表示初始文件格式；未来扩展新的版本的时候(extensions)将使用更大的数字。虽然在上面值`EV_CURRENT`为1，但是为了反映当前版本号，它可能会改变，**比如ELF到现在也就是1.2版本。**
### e_entry介绍
这一项为系统转交控制权给 ELF 中相应代码的虚拟地址。如果没有相关的入口项，则这一项为0。
### e_phoff介绍
这一项给出**程序头部表**在文件中的字节偏移（**Program Header table OFFset**）。如果文件中没有程序头部表，则为0。
### e_shoff介绍
这一项给出**节头表**在文件中的字节偏移（ **Section Header table OFFset** ）。如果文件中没有节头表，则为0。
### e_flags介绍
这一项给出文件中与特定处理器相关的标志，这些标志命名格式为`EF_machine_flag`。
### e_ehsize介绍
这一项给出 ELF 文件头部的字节长度（ELF Header Size）。
### e_phentsize介绍
这一项给出程序头部表中每个表项的字节长度（**Program Header ENTry SIZE**）。每个表项的大小相同。
### e_phnum介绍
这一项给出程序头部表的项数（ **Program Header entry NUMber** ）。因此，`e_phnum` 与 `e_phentsize` 的乘积即为程序头部表的字节长度。如果文件中没有程序头部表，则该项值为0。
### e_shentsize介绍
这一项给出节头的字节长度（**Section Header ENTry SIZE**）。一个节头是节头表中的一项；节头表中所有项占据的空间大小相同。
### e_shnum介绍
这一项给出节头表中的项数（**Section Header NUMber**）。因此， `e_shnum` 与 `e_shentsize` 的乘积即为节头表的字节长度。如果文件中没有节头表，则该项值为0。
### e_shstrndx介绍
这一项给出节头表中与节名字符串表相关的表项的索引值（**Section Header table InDeX related with section  name STRing table**）。如果文件中没有节名字符串表，则该项值为`SHN_UNDEF`。关于细节的介绍，请参考后面的“节”和“字符串表”部分。
### Program Header Table概述
Program Header Table 是一个结构体数组，每一个元素的类型是 `Elf32_Phdr`，描述了一个段或者其它系统在准备程序执行时所需要的信息。其中，ELF 头中的 `e_phentsize` 和 `e_phnum` 指定了该数组每个元素的大小以及元素个数。一个目标文件的段包含一个或者多个节。**程序的头部只有对于可执行文件和共享目标文件有意义。**
可以说，Program Header Table 就是专门为 ELF 文件运行时中的段所准备的。
`Elf32_Phdr` 的数据结构如下
```c++
typedef struct {
	ELF32_Word	p_type;
	ELF32_Off	p_offset;
	ELF32_Addr	p_vaddr;
	ELF32_Addr	p_paddr;
	ELF32_Word	p_filesz;
	ELF32_Word	p_memsz;
	ELF32_Word	p_flags;
	ELF32_Word	p_align;
} Elf32_Phdr;
```
每个字段的说明如下
| 字段     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| p_type   | 该字段为段的类型，或者表明了该结构的相关信息。               |
| p_offset | 该字段给出了从文件开始到该段开头的第一个字节的偏移。         |
| p_vaddr  | 该字段给出了该段第一个字节在内存中的虚拟地址。               |
| p_paddr  | 该字段仅用于物理地址寻址相关的系统中， 由于“System V”忽略了应用程序的物理寻址，可执行文件和共享目标文件的该项内容并未被限定。 |
| p_filesz | 该字段给出了文件镜像中该段的大小，可能为0。                  |
| p_memsz  | 该字段给出了内存镜像中该段的大小，可能为0。                  |
| p_flags  | 该字段给出了与段相关的标记。                                 |
| p_align  | 可加载的程序的段的 p_vaddr 以及 p_offset 的大小必须是 page 的整数倍。该成员给出了段在文件以及内存中的对齐方式。如果该值为 0 或 1 的话，表示不需要对齐。除此之外，p_align 应该是 2 的整数指数次方，并且 p_vaddr 与 p_offset 在模 p_align 的意义下，应该相等。 |
### Program Header Table段类型
可执行文件中的段类型如下
| 名字                | 取值                    | 说明                                                         |
| ------------------- | ----------------------- | ------------------------------------------------------------ |
| PT_NULL             | 0                       | 表明段未使用，其结构中其他成员都是未定义的。                 |
| PT_LOAD             | 1                       | 此类型段为一个可加载的段，大小由 p_filesz 和 p_memsz  描述。文件中的字节被映射到相应内存段开始处。如果 p_memsz  大于  p_filesz，“剩余”的字节都要被置为0。p_filesz 不能大于 p_memsz。可加载的段在程序头部中按照 p_vaddr 的升序排列。 |
| PT_DYNAMIC          | 2                       | 此类型段给出动态链接信息。                                   |
| PT_INTERP           | 3                       | 此类型段给出了一个以 NULL  结尾的字符串的位置和长度，该字符串将被当作解释器调用。这种段类型仅对可执行文件有意义（也可能出现在共享目标文件中）。此外，这种段在一个文件中最多出现一次。而且这种类型的段存在的话，它必须在所有可加载段项的前面。 |
| PT_NOTE             | 4                       | 此类型段给出附加信息的位置和大小。                           |
| PT_SHLIB            | 5                       | 该段类型被保留，不过语义未指定。而且，包含这种类型的段的程序不符合ABI标准。 |
| PT_PHDR             | 6                       | 该段类型的数组元素如果存在的话，则给出了程序头部表自身的大小和位置，既包括在文件中也包括在内存中的信息。此类型的段在文件中最多出现一次。**此外，只有程序头部表是程序的内存映像的一部分时，它才会出现**。如果此类型段存在，则必须在所有可加载段项目的前面。 |
| PT_LOPROC~PT_HIPROC | 0x70000000  ~0x7fffffff | 此范围的类型保留给处理器专用语义。                           |
### Program Header Table基地址-Base Address
程序头部的虚拟地址可能并不是程序内存镜像中实际的虚拟地址。通常来说，可执行程序都会包含绝对地址的代码。为了使得程序可以正常执行，段必须在相应的虚拟地址处。另一方面，共享目标文件通常来说包含与地址无关的代码。这可以使得共享目标文件可以被多个进程加载，同时保持程序执行的正确性。尽管系统会为不同的进程选择不同的虚拟地址，但是它仍然保留段的相对地址，**因为地址无关代码使用段之间的相对地址来进行寻址，内存中的虚拟地址之间的差必须与文件中的虚拟地址之间的差相匹配**。内存中任何段的虚拟地址与文件中对应的虚拟地址之间的差值对于任何一个可执行文件或共享对象来说是一个单一常量值。这个差值就是基地址，基地址的一个用途就是在动态链接期间重新定位程序。
可执行文件或者共享目标文件的基地址是在执行过程中由以下三个数值计算的
- 虚拟内存加载地址
- 最大页面大小
- 程序可加载段的最低虚拟地址
要计算基地址，首先要确定可加载段中 p_vaddr 最小的内存虚拟地址，之后把该内存虚拟地址缩小为与之最近的最大页面的整数倍即是基地址。根据要加载到内存中的文件的类型，内存地址可能与 p_vaddr 相同也可能不同。
### Program Header Table段权限-p_flags
被系统加载到内存中的程序至少有一个可加载的段。当系统为可加载的段创建内存镜像时，它会按照 p_flags 将段设置为对应的权限。
其中，所有在 PF_MASKPROC 中的比特位都是被保留用于与处理器相关的语义信息。
如果一个权限位被设置为 0，这种类型的段是不可访问的。实际的内存权限取决于相应的内存管理单元，不同的系统可能操作方式不一样。尽管所有的权限组合都是可以的，但是系统一般会授予比请求更多的权限。在任何情况下，除非明确说明，一个段不会有写权限。
例如，一般来说，.text 段一般具有读和执行权限，但是不会有写权限。数据段一般具有写，读，以及执行权限。
### Program Header Table段内容
一个段可能包括一到多个节区，但是这并不会影响程序的加载。尽管如此，我们也必须需要各种各样的数据来使得程序可以执行以及动态链接等等。下面会给出一般情况下的段的内容。对于不同的段来说，它的节的顺序以及所包含的节的个数有所不同。此外，与处理相关的约束可能会改变对应的段的结构。