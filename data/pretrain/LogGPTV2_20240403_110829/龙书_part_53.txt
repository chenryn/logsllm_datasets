2
%token DIGIT
图4-58
return c;
C=
int c;
return DIGIT;
getchar();
DIGIT
: expr
factor
term‘*’factor
2}2!
一个简单的桌上计算器的 Yacc 规约
|n丨n
'\n
$$=$1＃$3；}
=$2;
=+$3；
{ printf("%d\n"，$1);}
第4章
---
## Page 201
义性文法：
算术运算符+、－（包括双目和单目）、＊和/。描述这类表达式的最容易的方式是使用下面的二
我们将第---个规则修改为：
算器对一个表达式序列进行求值,其中每个表达式占一行。我们还将允许表达式之间出现空行。
4.9.2使用带有二义性文法的Yacc 规约
符本身被当作词法单元名返回。
单元的相关属性值通过一个 Yacc 定义的变量 yylval 传送给语法分析器。
个词法单元名字，比如 DIGIT，那么这个名字必须先在Yacc 规约的第一部分进行声明。
动作打印出了输人表达式的十进制取值和一个换行符。
=$1;。
只包含一个文法符号的产生式，默认的语义动作就是拷贝属性值。总的来说，默认动作是”$
结果赋给产生式头上的非终结符号éxpr。我们省略了第二个产生式的语义动作，因为对于体中
恢
二个文法符号。与第一个产生式关联的语义动作将产生式体中的 expr 和 term 的值相加，并把
和它们的相关语义动作写作：
因此语义动作通常根据寂的值来计算$$的值。在上面的 Yacc 规范中，我们将两个E产生式
器)。不同的产生式体用竖线分开，每个产生式头以及它的可选产生式体及语义动作之后跟一-个
4
是一个数位，这个数位的值就存放在变量 Yylval中，返回词法单元的名字 DIGIT。否则，字
复例程这样的过程。
法分析器。用Lex 来生成 yylex（)是--个常用的选择，见4.9.3节。在需要时可以添加错误
号。第一个产生式的头符号被看作开始符号。
语法分析
其次，我们将扩展表达式的种类，使得它的语言可以包含数字，而不是单个数位，并且包含
现在让我们修改这个Yacc规约，使得这个桌面计算器更加有用。首先，我们将允许桌面计
图4-58 中的词法分析器是非常原始的。它使用C 函数 getchar（）逐个读入字符。如果字
在 Yacc 中，像第三行那样的空白产生式表示∈。
词法分析器 yylex（)返回一个由词法单元名和相关属性值组成的词法单元。如果要返回-
一个 Yacc 规约的第三部分由辅助性C 语言例程组成。这里必须提供---个名为 yylex（）的
辅助性 C 语言例程部分 
这个产生式说明桌面计算器的输人是一个跟着换行符的表达式。和这个产生式相关的语义
6.
请注意,我们向这个 Yacc 规范中加入了一个新的开始符号产生式
请注意，第一个产生式中的非终结符号term是该产生式体中的第三个文法符号，而＋是第
一个Yacc 语义动作是--个C语句的序列。在--个语义动作中，符号 $S 表示和相应产生式头
empty */
"\n'
 $= $+ 3；
{ printf("%g\n"，$2);}
E→E + TI T
，一个词法
185
！
A
---
## Page 202
使得+和－具有相同的优先级，并且都是左结合的。我们可以把一
移人/归约冲突。在声明部分，我们可以给终结符号赋予优先级和结合性。声明
生的移人/归约冲突。
检查 Yacc 是否已经正确解决了它们。
动作冲突，那么最好创建并查阅y.output 文件，了解为什么会产生这些语法分析动作冲突，并
读表示形式显示了Yacc 是如何解决这些语法分析动作冲突的。只要 Yacc 报告发现了语法分析
LALR 算法产生的语法分析动作冲突的描述，以及LR 语法分析表的一个可读表示形式。这个可
会报告产生的语法分析动作冲突的数量。使用-v选项调用 Yacc 可以得到关于项集和语法分析
得到的Yacc 规约如图4-59所示。
因为这些默认规则不可能总是编译器作者需要的，所以 Yacc 提供了-一-
186
%left‘+' 
2）解决移人/归约冲突时总是选择移人。这个规则正确地解决了因为悬空 else二义性而产
除非另行指定，否则Yacc 会使用下面的两个规则来解决所有的语法分析动作冲突：
因为图 4-59 中 Yac 规约的文法是二义性的，LALR 算法将会出现语法分析动作冲突。Yacc
1）解决一个归约/归约冲突时，选择在Yacc 规约中列在前面的那个冲突产生式。
E→E+EＩE-EＩE＊EＩE/E丨－EＩ（E)Ｉmumber
expr
%token NUMBER
#define YSTYPE double /* double type for Yacc stack */
lines
#include 
ight UMINUS
left '*''/!
left '+''-'
图4-59
return c;
return NUMBER;
expr
expr
expr
expr
lines
lines
empty
一个更加先进的桌上计算器的 Yacc 规约
expr
-+-
'）丨(isdigit(c)））{
%prec UMINUS
#
expr
&yylval);
{ printf("%g\n"， $2);}
的
IF
＄—2;
$2;}
十
-个运算符声明为右结合的，比如：
-一-个通用的机制来解决
第
4章
---
## Page 203
y.tab.c的一部分被编译的。
的驱动程序。Yacc 要求它的词法分析器的名字为 Yylex（）。如果用 Lex 来生成词法分析器，那
4.9.3用Lex创建Yacc 的词法分析器
赋予词法单元UMINUS一个高于＊和/的优先级。在翻译规则部分，产生式
号不会被词法分析器返回，声明它的目的仅仅是为了定义一个产生式的优先级。在图4-59 中，
机制解决了的移入/归约冲突。
结符号的优先级和结合性应该在声明部分定义。Yacc 不会报告那些已经使用这个优先级/结合性
来指明该产生式的优先级。此时这个产生式的优先级和结合性将和这个终结符号相同,而这个终
个标记
看符号的优先级高于产生式体中+的优先级。
号具有相同的优先级，且它是左结合的。在向前看符号为＊时，我们将选择移人，因为这个向前
个明智的选择。比如，给定产生式
是左结合的时，Yacc 就选择归约;否则就选择移人动作。
和结合性，来解决移人/归约冲突。如果它必须在移人一个输入符号α和按照 A→α 进行归约之
赋予词法单元 UMINUS 的优先级要高于前面五个终结符号的优先级。
起),方法如下：
Lex 的作用是生成可以和 Yacc一起使用的词法分析器。Lex 库Ⅱl 将提供一个名为 YYlex（）
明
这里的“终结符号”可以仅仅作为一个占位符，就像图4-59中的UMINUS那样。这个终结符
在那些最右终结符号不能为产生式提供正确优先级的情况下，我们可以在产生式后增加-
语法分析
在UNIX 系统中，如果Lex 规约存放在文件first.1 中，且 Yacc 规约在 second:y中，我
并令每个Lex 动作都返回 Yacc 已知的终结符号。通过使用语句#inciude"lex.YY.c"，
%right UMINUS
%prec(终结符号)
通常，一个产生式的优先级被设定为它的最右终结符号的优先级。在大多数情况下，这是一
我们将在向前看符号为+时按照E->E+E进行归约，因为产生式体中的+和这个向前看符
除了给各个终结符号赋予优先级，Yacc 也可以给和某个冲突相关的各个产生式赋予优先级
%right UMINUS
后
词法单元的优先级是根据它们在声明部分的出现顺序而定的。优先级最低的词法单元最先
我们可以声明---个运算符是非结合性的二目运算符（即这个运算符的两次出现不能合并到一-
%right.
面的标记
187
---
## Page 204
态重新设置为正常操作模式。
符号，直到它发现一个换行符为止。此时，语法分析器将换行符移人到栈中，将 error‘n"归约
在输人为error 时执行移人动作的状态。状态0 就是这样的一-个状态（在这个例子里面，它是唯
作。
例4.70
一些处理，比如设置-一-个标志来禁止生成目标代码。
了--个语句。这个错误产生式的语义例程不需要处理输入，而是可以直接生成诊断消息并做出
的错误产生式规定语法分析器在碰到一个错误的时候要跳到下－个分号之后，并假装已经找到
的语法分析。
此时，语法分析器栈的顶部是 error α。然后语法分析器将把 error α 归约为 A，并继续进行正常
由终结符号组成，那么它就在输入中寻找这个终结符号串，并将它们移入到栈中进行“归约”
到它找到某个使它可以继续进行正常的语法分析的符号为止。
的语义动作(这可能是一个用户定义的错误恢复例程)。然后语法分析器抛弃一些输人符号，直
分析器就好像在输入中看到了error，将虚构的词法单元error移人栈中。
碰到--个满足如下条件的状态：该状态对应的项集包含--个形如 A-→·error α 的项。然后语法
项集包含错误产生式的状态。当碰到--个错误时，Yacc 就会从它的栈中不断弹出符号，直到
样的错误产生式当作普通产生式，根据这个规约生成一个语法分析器。
一个主要非终结符号，α是一个可能为空的文法符号串；error 是Yacc 的一个保留字。Yacc 把这
4.9.4Yacc 中的错误恢复
的模式必须被写作\n！，因为在Lex中，点（．）表示除了换行符之外的任意字符。
要词法分析器的地方。最后的表示“任意字符”
来得到想要的翻译器。
们可以使用命令
-个这样的状态)，因为它的项包括了
如果α不为空，Yacc 将向前跳过一些输人符号，寻找可以被归约为α的子串。如果α全部
当α为∈时，语法分析器立刻就执行一次归约到 A 的动作，并调用和产生式 A-→error 相关
然而，当Yacc 生成的语法分析器碰到一个错误时，它就以一种特殊的方法来处理那些对应
Yacc 的错误恢复使用了错误产生式的形式。首先，用户定义了哪些“主要”非终结符号将具
图 4-60 中的 Lex规约可以用在图 4-59中需
188
同时，状态0总是在栈的底部。语法分析器将词法单元error 移人栈中，然后向前跳过输入
当碰到错误时，桌上计算器的语法分析器开始从它的栈中弹出符号，直到它在栈中发现一个
这个错误产生式使得这个桌上计算器在输人中发现一个语法错误时停止正常的语法分析工
lines :error '\n'
比如，…-个形如
图4-61在图 4-59 所示的Yacc 桌上计算器中增加了错误产生式
 lines-→·error '\n'
 stmt-→ error ;
\n!.
{number} { sscanf(
%门
mumber
图4-60图4-59 中的 yiex 的 Lex 规约
{return yytext[o]；}
[0-9]+\.?1[0-9]*\.[0-9]+