## 描述信息
> What's apl?
>
> flag格式：flag{xxxx}
>
> [Download](https://share.weiyun.com/5815I0m)
简单google可以知道文件内容为APL程序，我们要读懂然后逆向得到flag
    {⍵(~⍵)/('No_Please_continue')('Yes,This_is_flag')}(∊(41(41)0+140)(⎕UCS('µě»ÕĀ$#Ğ$èáËĞĞĝ`âÞĠ#"!Ġ"KE(©$#Ğ$Q Most verbs have two definitions, one for the monadic case (one argument),
> and one for the dyadic case (two arguments).
## 代码阅读
### 1\. 代码结构分析
首先我们通过括号将代码分行，增加可读性
    {
      ⍵(~⍵)/('No_Please_continue')('Yes,This_is_flag')
    }
    (∊(41(41)0+140)
    (⎕UCS('µě»ÕĀ$#Ğ$èáËĞĞĝ`âÞĠ#"!Ġ"KE(©$#Ğ$Q Monad. ~ applies only to boolean arguments, and negates them: ~0 1 ←→ 1 0 .
我们分别给参数0和1，发现第一个函数需要参数0，即第二个函数计算结果应为0
    {   ⍵(~⍵)/('No_Please_continue')('Yes,This_is_flag') }1
    ┌──────────────────┐
    │No_Please_continue│
    └──────────────────┘
    {   ⍵(~⍵)/('No_Please_continue')('Yes,This_is_flag') }0
    ┌────────────────┐
    │Yes,This_is_flag│
### 3\. 函数二
#### 3.1 `(1+(|¯8)⍴1)⊤⎕UCS(⍵)`
我们接着看第二个函数，先看加密过程，一行一行往上看
    ...
    {
      ...
      // 结果固定，为（2 2 2 2 2 2 2 2）
      (1+(|¯8)⍴1)
      ⊤
      //首先将字符转成ascii
      ⎕UCS(⍵)
    }
    'YourFlagIsWhat?'
`a ⍴ b`表示将b填充至长度a。`8 ⍴ 'abcd'`即为`abcdabcd`
`⊤`和`⊥`互为逆运算
> For simple cases, ⊤ is inverse to the base ⊥ .
这里我们不用详细看文档，实验可以知道这里是将ascii转成二进制
    {⎕UCS(⍵)}'YourFlagIsWhat?'
    89 111 117 114 70 108 97 103 73 115 87 104 97 116 63
    (1+(|¯8)⍴1)
    2 2 2 2 2 2 2 2
    {(1+(|¯8)⍴1)⊤⎕UCS(⍵)}'YourFlagIsWhat?'
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 0
    0 1 1 1 0 1 1 1 0 1 0 1 1 1 1
    1 0 1 1 0 0 0 0 0 1 1 0 0 1 1
    1 1 0 0 0 1 0 0 1 0 0 1 0 0 1
    0 1 1 0 1 1 0 1 0 0 1 0 0 1 1
    0 1 0 1 1 0 0 1 0 1 1 0 0 0 1
    1 1 1 0 0 0 1 1 1 1 1 0 1 0 1
#### 3.2 `(∊4(⍴⍴88888)+16)`
    ...
    {
      ...
      (∊4(⍴⍴88888)+16)
      ⍴
      # 字符转二进制
      (1+(|¯8)⍴1)⊤⎕UCS(⍵)
    }
    'YourFlagIsWhat?'
这是一个独立的表达式，其值是固定的。
    (∊4(⍴⍴88888)+16)
    20 16
`(20 16) ⍴ a`表示将a填充为20*16的矩阵
    {(∊4(⍴⍴88888)+16)⍴(1+(|¯8)⍴1)⊤⎕UCS(⍵)}'YourFlagIsWhat?'
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1
    1 1 0 1 1 1 0 1 0 1 1 1 1 1 0 1
    1 0 0 0 0 0 1 1 0 0 1 1 1 1 0 0
    0 1 0 0 1 0 0 1 0 0 1 0 1 1 0 1
    1 0 1 0 0 1 0 0 1 1 0 1 0 1 1 0
    0 1 0 1 1 0 0 0 1 1 1 1 0 0 0 1
    1 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 0 0 1 1 1 0 1 1 1 0 1
    0 1 1 1 1 1 0 1 1 0 0 0 0 0 1 1
    0 0 1 1 1 1 0 0 0 1 0 0 1 0 0 1
    0 0 1 0 1 1 0 1 1 0 1 0 0 1 0 0
    1 1 0 1 0 1 1 0 0 1 0 1 1 0 0 0
    1 1 1 1 0 0 0 1 1 1 1 1 0 1 0 1
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1
    1 1 0 1 1 1 0 1 0 1 1 1 1 1 0 1
    1 0 0 0 0 0 1 1 0 0 1 1 1 1 0 0
    0 1 0 0 1 0 0 1 0 0 1 0 1 1 0 1
#### 3.3 `10⊖⊖⌽`
    ...
    {
      ...
      10⊖⊖⌽
      # 将二进制矩阵(8*40)转成(20*16)矩阵
      (∊4(⍴⍴88888)+16)⍴(1+(|¯8)⍴1)⊤⎕UCS(⍵)
    }