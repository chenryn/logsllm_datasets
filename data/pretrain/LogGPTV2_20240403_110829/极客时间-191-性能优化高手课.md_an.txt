# 14 \| 内存使用篇：如何高效使用内存来优化软件性能？你好，我是尉刚强。今天，我们来聊聊如何通过内存的高效使用，来进一步优化和提升软件性能。软件的实现是通过变量和变量之上的计算逻辑组成的，而在计算机运行期间，变量主要依赖于内存来承载。所以，如何高效地使用内存，就成为了高性能编码优化的重要手段之一。而在软件编码的过程中，不同实现方式对内存的影响，则主要体现在这三个场景：**内存的空间与布局**、**内存的申请与释放**、**内存的读取与修改**。不过就我的观察发现，很多研发团队在软件的开发阶段，并不会去关注内存使用优化，这样当业务上线后，伴随着用户规模的快速增长，各种内存引起的性能问题就逐渐暴露出来了，比如内存空间不够、内存操作引起比较大的时延抖动等。只有到了这个时候，他们才会意识到内存使用优化的重要性，但这时与内存相关的代码实现已经侵入业务的各个地方，调整重构变得举步维艰。所以可见，我们应该在编码实现的过程中，就去掌握优化内存使用的技巧和方法，以避免软件后期引起比较严重的性能问题。那么今天这节课，我就会从这三个场景出发，带你了解如何通过不同的编码方式，来调整优化内存使用效率，从而提升软件性能。不过在开始之前，我要先说明一点，就是不同编程语言的语法、解析运行机制的差异都很大，在高性能编码实现的技巧手法上也都不太一样。所以今天，我主要是以使用范围和人群都很广泛的Java语言为主，给你讲解如何从内存使用的角度进行高性能编码，从而开发出性能更加优越的软件。而在一些特定场景下，我还会选用一些C/C++代码片段进行对比分析，这样有助于你理解背后的原理与意义。好了，接下来，我们就一起看看如何通过代码实现来优化内存的空间与布局吧。内存的空间与布局优化首先你要清楚的是，通过编码实现手段减少对内存空间的使用，不仅能帮助你节省软件运行期间占用的内存开销，还可以减少代码运行期间对内存空间的操作，从而提升软件运行速度。那么这样问题也就来了：我们要如何通过编码实现，来减少使用的内存空间呢？这里，我给你总结了三种优化思路，虽然它们的关注视角不太一样，但最终都可以改善内存使用的性能。当你理解了这三种思路背后的原理，自然就会在编码过程中，朝着提升内存使用效率的方向改进。下面我就详细给你介绍下。按照变量存储信息量选择对应的类型定义第一个手段是：按照变量存储信息量来选择对应的类型定义。这要怎么理解呢？我先带你来看一个具体的例子。这个例子针对的是一个学生年龄的数据信息，你可以先想一想，一个在校学生的年龄有效范围会是多少呢？首先，基于常识判断，你可以认为该学生年龄是小于100 岁的。因此针对这个场景，你在 Java 中使用一个 byte基本类型，差不多就能满足信息的存取需求了。可是，如果你使用 long类型来保存，就会造成额外空间的浪费，并且也会潜在地影响程序的执行速度。所以，这就是一个没有根据存储信息量来选择类型定义的反例。遗憾的是，很多开发工程师在实际的代码开发过程中，并没有关注到这样的代码实现细节。OK，现在我们换个思路，看看还有没有更极致的优化内存空间的方法。首先我想问你的是，在计算机上最小的存储单位是多大呢？答案是一个 bit位。那么这里，我们就来看下，在 C/C++中是如何记录该学生的结构体定义的，如下所示：    struct Student    {        unsigned char gender: 1;        unsigned char gradeId: 3; //年级号（1~6）        unsigned char classId: 5; //班级号（1~20）    };可以看到，在这个代码结构体中，使用了一个字节表示该学生的性别（gender）、年级号（gradeId）和班级号（classId）。因为小学一共只有6 个年级，所以年级号（gradeId）使用 3 个 bit位保存就足够了，其他字段也是相同原理。这样一来，因为在 C/C++语言中支持**位域操作**（即可以针对 bit位来记录变量信息），我们就可以进一步缩减内存空间。而利用 bit位来节省内存，正是嵌入式或高性能系统中重要的内存优化手段之一，但比较遗憾的是，Java语言并不提供原生位域能力，因此直接使用 bit位变量来压缩内存空间会有点不方便。但是，Java 中有 **BitSet**这个类型，它可以支持位操作，不过它的主要思想是通过压缩存储来节省空间开销。比如，假设你要保存元素值为 64以内且不重复的数组：\[1,3,5,6,10,11,12,25,44,56,2,55\]，那么如果你使用正常byte 数组来保存的话，可能需要十几个字节才可以。而使用 BitSet，使用每一bit 位来表示一个数字，那么用 8 个字节就可以记录很多个数字了（当然，Java使用 BitSet压缩存储的应用场景也并不只限于这种方式）。不过这样问题也就来了：**针对 C/C++ 语言的位域优化实现，Java是否也可以实现这样类似的功能呢？**其实当然是可以的，但你可能需要借助**位运算**。这里我们来看一段 Java代码示例，同样是实现类在一个字节保存 classID，gradeID，gender等多个信息的能力，从中我们会观察到，在 Java内也可以使用一个字节，来保存多个有效的字段信息。    public class Student {        byte data; // |classID(4bit) |gradeID(3bit)| gender(1bit)|        Student() {            data = 0;        }        public void setGender(boolean isMale) {            data = (byte) (isMale ? (data | 0x01) : (data & 0xFE));        }        public boolean isMale() {            return (data & 0x01) == (byte) 1 ? true : false;        }        public byte getGradeId() {            return (byte) ((data & 0x0E) >> 1);        }        public void setGradeId(byte gradeID) {            data = (byte) (data | ((gradeID & 0x07) > 4);        }        public void setClassId(byte ClassId) {            data = (byte) (data | ((ClassId & 0x0F)   > 不过，在一些高实时性嵌入式系统中，动态内存使用是被禁止的，程序的所有内存都需要通过静态预分配与管理来实现。> > >可是在 Java中，如果一些业务逻辑内，频繁地申请和释放对象操作对性能的影响比较大，那么我们是否有办法去优化解决呢？当然是有的！这里我想给你介绍的一个性能优化手段，就是**对象池共享技术**。对象池本质上是通过集合来管理已经申请过的对象，如果线程需要这种类型的对象，就直接从集合中取一个元素，但是使用完也一定要归还，否则就会造成内存泄漏。另外，在使用对象池来管理一些创建比较耗时的对象时，我们还可以通过减少对象申请与创建的过程，来提高软件的运行速度和性能。好了，简而言之，对于内存的申请与释放优化，就是通过减少内存的申请和释放操作，或提升内存申请和释放的速度，来达到提升软件运行性能的目的。那么下面，我们接着来看看，要如何优化内存的读取和修改，来进一步提升软件性能。内存的读取与修改优化在 CPU 中，Cache的存取与替换都是以缓存行（Cacheline）为单位，而且在不同的 CPU体系架构实现中，缓存行的长度也都不一样，具体从 8 字节到 128字节之间不等。因此，如果说我们可以**把变量空间按照缓存行对齐，那么就可以提升 Cache的读写效率，从而就能够达到提升性能的效果。**既然如此，具体我们该怎么做呢？这里我们先来看一个例子，这个例子主要用来说明：变量 A、变量 B是否在一个 Cacheline 中，并会对 Cache的读取操作产生影响。![](Images/93caee9eb961ea9e7dc9a95eabaafd0e.png)savepage-src="https://static001.geekbang.org/resource/image/60/fd/60e2a112ae488a46cfb3681acc9463fd.jpg?wh=2000x710"}如上图的左半部分所示，如果两个变量不在一个 Cacheline中，那么在读取变量 A、变量 B 时，就需要读取两个Cacheline。而在图的右侧，由于两个变量在一个 Cacheline中，所以只需要读取一个 Cacheline即可。 也就是说，你在编码的过程中，就需要**充分利用局部性原理，把经常一起使用的变量放在一起**，从而最大化地实现 Cacheline的长度对齐，来优化提升软件的运行效率。>  > 注意：由于 CPU 的> > **指令预取技术**> > ，通常情况下在串行程序中，Cacheline> 对齐对性能的影响可能不是那么明显，所以很容易被我们忽视。> > >好，除此之外，我们还要知道在多核并发的场景下，由于 Cacheline没有对齐，造成的**伪共享**（FalseSharing），也会显著地影响程序的运行效率。如下图所示：![](Images/1339d4095ce7d4ccf1bc22812744b9a1.png)savepage-src="https://static001.geekbang.org/resource/image/63/0a/63a5122b86a84f3e37d07fb8dc185c0a.jpg?wh=2000x1125"}已知在 Core 1 上需要更新变量 X，而 Core 2 需要读取变量Y。但是由于变量 X 与 Y 在一个 Cacheline中，它们会映射在相同的内存地址上，所以每次当 Core1 上更新变量 X之后，就会造成 Core 2 上的变量 Y 对应的 Cacheline失效，需要重新读取，进而就会影响性能。所以在并发系统的设计中，针对 Cacheline未对齐造成软件性能受影响的场景，我们可以通过**显式字段的冗余**来实现 Cacheline对齐，以避免这种情况的发生。不过好在，Java 8 中引入了**sun.misc.Contended注解**，它就可以针对性地识别并发场景下存在的 Cacheline伪共享问题。那么，除了伪共享问题外，在实现编码的过程中，还有一些手段也可以优化内存读取和修改的性能。比如说， **在 Java语言中** ，你可以借助一些 **native方法**来优化拷贝赋值数据的性能，而其中最常用的，就是使用接口的System.arraycopy 方法、对象的 clone方法。那么再进一步，对内存拷贝的性能优化极限就是**零拷贝**，你可以通过业务逻辑或算法优化来尽量减少拷贝操作，从而进一步优化性能。而对于  **C/C++语言**来说，对一块内存进行修改时，使用 **memcopy操作**性能则优于直接赋值操作，这是因为 memcopy在汇编过程，使用了特殊的汇编指令来优化连续内存的拷贝操作。小结学完了这节课，我们需要明确一点，就是不同编程语言在如何高效地使用内存上，存在不同的权衡策略，但不管是静态类型语言（如C/C++、Java 等），还是动态类型语言（如 Ruby、Python、Node.js等），高效使用内存都是编码性能优化的重要考量因素之一。在面对不同编程语言进行业务编码的过程中，你都可以充分利用编程语言内置的内存使用策略，并从内存空间与布局优化、内存申请与释放优化、内存读取与修改优化三个维度进行思考，从而就能够写出高性能的代码。思考题代码在运行期间，也是从内存中加载到 Cache 来运行的吗?你知道还有哪些手段，可以优化代码逻辑使用内存的效率呢？欢迎在留言区分享你的思考和看法。如果觉得有收获，也欢迎你把今天的内容分享给更多的朋友。