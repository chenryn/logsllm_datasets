址的范围比线性寻址的范围要大得多。在16位计算机的时代，这是很重要的。现在，在
32位和64位计算机中，情况就有所不同了。事实上，现在已经几乎不再使用段式寻址
了。x86架构的64位版本对段式寻址的支持已经非常有限。
页式寻址利用称为页的内存单元和页表，页表描述了物理地址和线性地址的映射关系。每个
线性地址分成一个或多个部分，分别与页表的相应级一一对应，正如在图3.1中所看到的那样。
在32位架构中一般是2～3级的结构，而在64位系统架构中是4级的结构。
32位线性地址
31
2221
1211
0
目录
表
偏移量
4KB页
?
物理地址
页表
页目录
页表输人
页目录输人
寄存器
图3.132位虚拟地址的两级页式寻址
虚拟地址的最后部分（如图3.1中的最后12位）指定了一个页的偏移量：最前面部分的虚
拟地址（图3.1中前20位）指定了一个页表的索引（或者多个，这依赖于页表的结构）。当在
---
## Page 50
第3章成功内核利用进阶41
指令中使用线性地址的时候，CPU把线性地址送到MMU（MemoryManagementUnit，存储管
理装置），它的任务就是运行页表进行映射以得到相应的物理地址。为了达到目的，MMU需要
通过存储在特殊寄存器中的物理地址来识别当前正在使用的页表的结构。操作系统利用这个功
能使人们产生错觉，让大家都以为每个处理器都对应着一个线性的地址空间。系统为每个处理
器的页表分配存储空间，当处理器之间进行切换时，系统会将当前处理器的页表地址保存到一
个特殊寄存器中。
对CPU来说，要想能够正确地工作，从虚拟地址到物理地址的转换是必须进行的。然而，
这是一个耗时的操作，为了提高这个周期性操作的性能，CPU提供了一个缓冲器用于存储最近
虚拟地址到物理地址的映射关系，我们称这个为“快表”（TranslationLookasideBuffer，TLB）。
TLB的原理非常简单：保存最近转换过的记录以便将来再需要映射相同的地址时无需再去获取
物理内存而是去“快表”中直接读取。如其他缓存一样，TLB也利用局部性的原理，包括时间
与空间上：很快，一个程序可能将访问相同的地址数据。作为一个经典的例子，想想循环访问
一个数组元素的问题。我们通过缓存数组的物理地址而不是每次读取元素然后通过内存管理单
元来映射。
操作系统使人们产生了一种错觉，让大家以为每一个进程都有一个私有的虚拟地址空间。
因此，相同的虚拟地址在不同的进程中总是有不同的翻译结果。事实上，这样的虚拟地址在某
些时候根本就不存在。如果在每次处理器转换的时候都能够保存与TLB相关的信息，CPU就
不会出现读取错误物理地址的问题。鉴于这个原因，所有架构都提供了一种刷新TLB缓存或特
定TLB人口的方法。架构还提供了一种通过刷新可用的全局入口保存TLB入口的方法，这种
方式在上下文切换时不改变虚拟地址到物理地址的映射。
可以想象，刷新TLB肯定会对性能产生一定的影响。让我们回到数组循环的例子。两个进
程交叉遍历两个长数组。每次这两个进程之间进行上下文切换时，其他的进程试图访问数组元
素时都需要在页表中进行一次MMU遍历。
从MMU的角度来看，操作系统存取内存都是通过本身的页表，就如任何的用户态的进程
一样。因为用户态和内核态之间的切换是非常普通的任务。并非只在进程状态切换时才会刷新
快表，每次进入或是跳出内核态的时候也会引发TLB的刷新。而且内核经常需要用户态去访
问，比如输入调用的参数或是返回调用的结果。在诸如x86/x86-64的体系架构中不提供任何硬
件支持去访问其他进程的资源，每一次进入/退出内核操作时都会导致TLB的刷新，在引I用访
问其他进程的时候都需要手动运行页表转换程序，这在很大程度上影响了机器的性能。
为了提高这种体系架构的性能（一直是操作系统设计中的一个关键点），操作系统实现了
在第1章中提到的组合的用户态/内核态地址空间，在每一个进程地址空间的顶部都保存有一
份内核页表的备份。这些页表的转换（从内核虚拟地址到物理地址）将在快表中标记为全局的
并且不可改变。通过只允许有权限的代码对其访问来保护它。每次进程调用内核代码的时候都
不需要再改变TLB（如刷新TLB）；如果出于某种原因内核直接在进程上下文中解引I用了一个
已经映射的虚拟地址空间，那么将会访问这个进程的内存。
一些体系架构（如SPARCV9）不支持从一个进程访问另一个进程的机制，并将TLB与特
定的进程环境关联。因此，它能够将内核态和用户态区分并且不会影响机器性能。我们将会在
---
## Page 51
42第一部分内核态
“执行阶段”讨论这些设计的深远意义。
警告虽然内核态和用户态相结合的设计是x86的通用选择，但是这种选择主要是
考虑了性能原因：在内核态和用户态之间实行适当分离是完全可行的。Linux内核的
4G/4G分割项目、Pax项目，而且，更有趣的是，MacOSX操作系统是在x86系统
上实现了独立的用户态和内核态地址空间的一个例子。x86-64架构已经稍微改变了
这种状况，它有很大的虚拟地址空间，对用户态和内核态来说都有很大的空间。对段
寻址的有限支持使得基于段寻址的技术在独立环境中想要达到很好的性能是不可能的
（如基于x86的Pax设计）。
栈
栈是一个内存结构，该结构儿乎是所有应用程序二进制接口（ApplicationBinaryInterface
ABI）的基础，规则集的任务是如何创建（数据类型和大小、栈对齐、特定语言结构等）和规
范（调用规约、系统调用号和调用机制等）可执行文件。因为内核本身是可执行的，我们将涵
盖与内核利用方法关系比较密切的ABI部分，特别侧重于调用规约。
调用规约指出对支持嵌套程序非常必要的粘性机制是如何组织到一起的，比如，参数和返
回值是如何传递的，或者当一个过程结束的时候控制流是如何正确返回调用函数的。所有的架
构在支持嵌套程序的机制上可能略有差异，但是这些机制有一个共同点：都基于栈。
栈有两种基本操作：
·PUSH人栈操作，将一数值放到栈顶。
·POP出栈操作，移除栈顶元素并且返回给调用者。
由于这种设计，栈是一种后进先出（LastInFirstOut，LIFO）的数据结构。我们最后一
个PUSH的对象将会是接下来我们执行POP操作时返回的值。习惯上，栈从高地址向低地址增
长，正如我们在第2章中看到的那样。在这种情况下，入栈操作从栈顶（TOS）减去对象的大
小个地址单元并且复制对象到栈顶；相反，出栈操作从栈顶（TOS）读取对象并且栈顶指针加
上对象的大小。
CPU架构中有专门的寄存器保存栈顶（TOS）地址，并且POP和PUSH指令都会隐含地
修改该寄存器的值。图3.2表明CPU架构特征是如何支持嵌套程序的。
这种想法是将每个程序限定在一个栈结构中，这个结构是栈的一部分，而且它是这个程序私
有的，这段私有区域可以通过预留足够的空间来存放局部变量。在调用一个程序时，调用函数
在调用后将会把下一条指令的指令指针（IP）放人栈结构中。一旦被调用函数结束，它将在栈
中使用的局部变量清空，并将栈中的栈顶值出栈。这个值是调用函数中下一条指令的地址，是
调用函数之前将它压入栈中的。被调函数将这个值设成指令指针，函数继续正确地执行下去。
虽然函数之间传递参数大多数情况是通过寄存器来完成的，尤其是在精简指令集计算机系
的工作。调用函数简单地将参数压入栈中然后被调函数将参数出栈。栈的这种用途在图3.2中
有所展示。这种方式中，被调用函数从栈中移出参数。因为栈是一个简单的内存结构，被调函
---
## Page 52
第3章成功内核利用进阶43
数也可以通过偏移地址访问栈中的参数而不必将参数出栈。这种情况下，调用函数在被调函数
返回后清除栈中的参数。第一种方式是x86的Windows系统中的经典实现方式，而后一种方式
在x86的Linux系统中更为常见。
栈顶
栈指针
func3的位置
func3子程序
返回地址
的栈结构
帧指针
func3的参数
func2的位置
func2子程序
返回地址
的栈结构
func2的参数
funcl的位置
funcl子程序
返回地址
的栈结构
funcl的参数
图3.2基于栈的嵌套程序的实现
x86和×86-64
现在我们已经描述了架构的一般概念，是时候讨论一下选择什么样的架构来实施内核利用
了。这里的讨论引导我们进入接下来要讲的利用开发的第一阶段一执行阶段。
基于x86的32位架构
最著名的复杂指令计算机系统也可能是您最为熟悉的：x86。这个架构的第一个实例可以
追溯到1978年Intel的16位处理器8086的问世。并且还影响着现在的x86CPU系统。当您
打开电脑，CPU以真实模式（RealMode）启动，此时16位的环境与8086的CPU极为相似。
http://download.intel.com/museum/archives/brochares/pdfs/35yrs_web.pdf
---
## Page 53
44第一部分内核态
x86的设计要求满足向上兼容性，正是这个原因才使它成功，但是同时这也使得它本身比较笨重。
用户非常高兴，因为能够保证运行老版本的应用程序而不必过多地关注当前机器的指令集。
在x86架构中，启动机器以后的第一件事是将CPU切换到保护模式，使操作系统运行在
32位的环境中。从操作系统的角度看，保护模式是非常重要的，提供了诸如分页内存管理单
元、权限管理、可寻址的32位虚拟地址空间等特征。在32位保护模式中，x86架构提供了8
个32位通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP和ESP）、6个16位段寄存
器（CS、DS、ES、FS、GS和SS），还有很多专用寄存器。经常用到的寄存器包括：
·ESP/EBP分别表示栈指针（ESP）和帧指针（EBP）。栈指针指向当前栈的栈顶，而顿
指针指向当前函数的入口。EBP用来引用传递给函数的参数和函数内部的局部变量。需
要指出的是，EBP作为顿指针不是强制性的；事实上，内核的编译没有使用帧指针，而
是使用了很多其他的寄存器。
·EIP这个寄存器保存指令指针（IP）。
·EFLAGS这个寄存器保存与当前执行状态相关的位标志。
·IDTR这是中断描述符表寄存器，保存着中断描述符表（InterruptDescriptorTable，
IDT）的物理地址。这个表将每一个中断与特定的服务程序相关联。权限指令和非权限指
令都充许从中断描述表寄存器中读和写。
·GDTR这是全局描述符表寄存器，保存着全局描述符表（GlobalDescriptorTable，
GDT）的物理地址。这是一个段描述符的表。由于x86的独特设计，这个寄存器是必须
使用的。与IDT一样，权限指令和非权限指令都可以从寄存器中读和写。
x86架构有4个权限级别，称为环。0环拥有最高级别的权限，内核程序在这个级别上运行。
用户程序运行在拥有最低权限级别的3环上。1环和2环在现代操作系统中很少使用。
x86架构支持页式寻址和段式寻址。实际上，段式寻址在保护模式下也不能禁用。因此
在x86架构中一直使用段地址：偏移地址（seg：offset）的模式进行寻址。段地址存储在
6个段寄存器中的一个内。如果没有指定段寄存器，将会使用默认段寄存器：CS是默认的
程序段寄存器，DS是默认的数据段寄存器，SS是默认的栈段寄存器，ES是默认的串指令段
寄存器。为了拥有一个单一的线性地址空间，操作系统定义所有的段从基址0到段的最大值
0xFFFFFFFF，从而创建一个独立的段跨越整个4GB的虚拟地址空间。页式寻址在此基础上
高效运行。
x86架构实现了两级页表（如果物理地址扩展（PhysicalAddressExtension，PAE）可行的
理地址，线性地址的最高10位有效位保存着页目录表中的索引，选择1024（2"°）个入口中的
一个。每一个人口都保存着一个页表（PT）的物理地址。接下来的10位有效位从页表中选择
一个入口，这个入口通常称为页表人口（PTE），保存着要指向的页的物理地址。剩下的12位
有效位作为物理页中的偏移地址，用于寻址由4096个字节组成的页。内存管理单元（MMU）
每次从CPU中取得线性地址的时候都会进行这样的操作。
与页表入口相关的是一组描述页的属性的标志。这些标志中最有趣的就是描述页的保护模
---
## Page 54
第3章成功内核利用进阶45
式的标志位。在x86的架构中，页是可写的或可读的或既可读也可写的。没有一个标志位表示
一个页是可以执行的（所有可以访问的页都是可以执行的）。您将会在本章看到，这是一个非
常有意思的属性。
同样需要指出的是，x86架构提供了通用标志，称为写保护（WriteProtect，WP）。该标注
在CRO寄存器中，当设置了这个标志位时，就会防正任何权限代码修改只读的页，而不论是在
权限的段还是非权限的段中，这个标志位在现在内核中是默认打开的。
x86-64
由于应用程序开始需要更大的地址空间并且内存价格下降，InteI和AMD都开始设计自己
的64位架构。Intel开发了崭新的IA64RISC架构：AMD采用x86-32位的架构原理，实现了
64位的架构，称为AMD64。AMD64是完全向上兼容的，允许用户不加修改地运行32位的应
用程序和操作系统，并且有两种操作模式：
·传统模式CPU行为就如32位CPU一样，将所有64位的环境都关掉。
·长模式这是64位本地运行模式。在这种模式下，32位应用程序仍旧可以不加修改地运
行（接下来会立即讨论）在一个称为兼容模式的模式中。在兼容模式和64位模式之间来
回切换既简单又快速。MacOSX内核（到SnowLeopard）已经采用这种特性来在32位
内核上运行64位应用程序。
完全不用吃惊，AMD64比IA64更加成功，这迫使Intel不得不开发它自己的兼容版本，
我们称为EM64T/IA-32e。这两者的区别非常小，我们将不会在这里进行讨论。现在，32位架
构的64位版本通常称为x86-64。
现在，我们讨论一下上面谈到的64位架构的特性：
·32位通用寄存器（EAX、EBX等）扩展成64位并且称作RAX、RBX等。
·新添加了8个64位的寄存器，称为R8～R15。
·默认有“非执行”位（NX）的标记页是不可执行的。当页目录入口（PAE）允许使用时，
NX标志位就在一些32位X86系统中出现了。
·现在用RIP（EIP寄存器的64位版本）保存与指令指针相关的内存地址。对位置独立的
代码来说，这是一个有趣的特征（代码中不含有任何绝对地址引用，因此可以放在任何
线性地址空间中并且正确执行）。
·虚拟地址空间明显大了很多。因为64位的地址空间用来表示它可能略显庞大（如页表），
因此只使用了它的一个子集，即仅有2个地址可用。这是通过将剩余的16位设置为第
47位的值来实现的。这样就生成了一个从0x7FFFFFFFFFFF到0xFFFF800000000000的
户态，而将高地址部分分配给内核态。
·页表表目现在是64位宽（当x86架构中设置物理地址扩展时），所以每一级包含512
个表目。页大小可能是4096KB、2MB或是1GB。需要一个新级别的表目，称为
PML4。
·在64位模式中，段式寻址基本上已经废弃使用了。比如，GDT仍旧存在，但是将忽略其
---
## Page 55
46第一部分内核态
中的信息（如段的限制和访问类型等）。GS和FS段寄存器也依然存在，但是它们通常只
用来保存重要数据结构的偏移地址。特别地，经常将GS用于用户态和内核态，这是因为
该架构提供了一种基于进入/退出内核的状态而转换其值的方法：SWAPGS。我们将会在
本书的第二部分详细讨论SWAPGS的具体使用。
·调用规约的步骤发生了变化。x86架构中通常通过栈来传送，而x86-64架构中的应用程