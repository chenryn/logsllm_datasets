第12章Python虚拟机中的类机制
Pyobject
传递到
调用metaclass
一深度探索动态语言核心技术
一个tuple对象中，最终进入pyobjeot_Cal1函数。好了，现在我们开
cesult
一个Python程序中olass可能成千上万，而pyType_Type却只有一
classA
（*ternapyfunc）（PyObject,PyobdectPyobiect））
?
图12-21class对象与元信息之间的关系
属性表
(*call)（fune,arg,kw);
tunc
stype'type>
dassB
属性表
type
>tpucall
classC
属性表
?
②动态元信息
静态元信息
type>（也就是
---
## Page 321
static PyObjecttype_new(EyTypeobject metatype,Pyobject amgs,Pyobject
代码清单12-4
单14-2），有兴趣的读者请参考Python源码。
[typeobject.c]
Lype_call(eyTypeobject*type
[typeobject.c]
一案发现场。由于type_new的代码相当繁杂，
kwds)
PyType_Type中的tp_new指向type_new，而这个type_new才是class对象创建的
//设置基类和基类列表
PyArg_ParseTupleAndKeywords(args,
return obj:
obj
Pyobject*abi
type->tp_name =Pystring_As_sTRING(name);
设置PyTypeObject中的各个域
type->tp_as_number=ket->asnumber:
et->ht_name = name;
为class对象申请内存
type->tp_as_buffer
PyHeaDTypeObject
statie:char
type->tp_new(-ype,
定最佳metaclass.
shame
*kwlist[]
&PyDict_Type,
&name,
基类列表，
Met:
*bage,
aouenhas ses-a3=
*)typei
args,
Pyobiect*args,Pyobject *kwds)
属性表）
("name",
*tmptype,
sdict))
kwdsY
Python源码剖析
分别解析到name，
kwds,
"bases",
进行初始化
所以这里我们做了相当的简化（代码清
*winner:
Bo1ol:type", kwlist,
12.3
"aict",o1
用户自定义class
一深度探索动态语言核心技术
bases,
dict三个变量中
291
---
## Page 322
Python源码剖析
292
instance对象的内存大小信息，换句话说，当我们以后通过a=A（）这样的表达式创建
了属性表。需要特别关注代码清单12-4的[1]处，这里计算了与对应的
原来PyHeapTypeObject是为用户自定义的class对象准备的。
吧，当初就觉得PyHeapTypeobject这个东西怎么莫名其妙地在Python中就出现了呢，
大小的内存空间。从pyType_Type的定义中我们可以看到，这个大小实际上就是sizeof
GenericAlloc对于我们的A（或者说，对于任何继承自object的class对象来说）
动作就是从基类继承各种操作。由于type.
对所有的内置class对象通过PyType_Ready进行初始化，在这个初始化过程中，有一项
NULL，这很奇怪，对吧？但是别忘了，之前我们已经提到，在Pyhon进行初始化时，会
class对象分配内存。这里需要注意的是，在pyType_Type中，我们会发现tpalloc
（PyHeapTypeObject）+sizeof（PyMemberDef）。到这里，有种天开云散见晴空的感觉
于基类列表及传入的metaclass（参数metatype）确定最佳的metaclass和base，对
此后，就是设置这个elass对象的各个域，其中包括了在tp_dict上设置
随后，Python虚拟机会调用metatype->tp_alloc尝试为所要创建的与A对应的
Pyhon虚拟机首先会将类名、基类列表和属性表从tuple对象中解析出来，然后会基
第12章Python虚拟机中的类机制
//调用pyType_Ready (type）对ciass对象进行初始化
eturn:(Pyobject
type->tp_itemsize
slotoffset
slotoffset
//[11：为class对象对应的nstance对象设置内存大小信息
1/如果自定义class中重写了
type->tpdict=dict=PyDictCopy(dct);
Cyoe
//设置属性表
type-tp_base=base;
=
一深度探索动态语言核心技术
PyStaticMeth
dlatoffset
sizeof(Pyobject
babe
32
)type;
=base->tp_itemsize;
一
slotoffset
mew
new
将new_对应的函数改造为statie画数
tmp）
---
## Page 323
12.4
义的class对象和内置的class对象最终在内存布局上的区别。
里先不表，
的空间，而且这些空间的地址被设置给了tp_dictoffset和tp_weaklistoffset呢？这
tp_basicsize+8。其中的8为2*sizeof（PyObject*）。为什么后面要跟着两个pyobject*
继承自object的class对象也成立）来说，这个大小为PyBaseObject_Type->
class机制到底何时到头啊？这里，我有一个坏消息，
及与其关联的PyNumberMethods等的内存位置都是在编译时确定的，它们在内存中的位
一样的初始化动作。到此，A对应的ciass对象正式创建完毕。图12-22显示了用户自定
测一步，那么调用class对象，是不是就能得到instance对象呢？欲知后事如何，且听
用”metaclass对象（比如）创建的。如果按照这个逻辑小小地向前推
了tp_cal1操作，就能进行“调用”操作。我们已经看到，Python中的class对象是“调
Python中，这个概念实际上是一个相当通用的概念，不拘对象，不拘大小，只要对象定义
存位置是连续的，必须在运行时动态申请内存。
下节分解。
一个instance对象时，需要为这个instance对象申请多大的内存呢？对于A（对任何
从class对象到instance对象
现在我们对Pyhon中“可调用（calable）”这个概念应该是有一定的感性认识了。在
本质上，无论是用户自定义的class对象还是内置的class对象，在Pyhon虚拟机
嘿，朋友，现在是不是已经头脑发张，两眼发晕了？前面罗罗嗦嗦说了几十页，这个
留待以后详解。
图12-22用户自定义class对象和内置class对象的内存布局对比
1:tp_asnumber
PySequenceMethods
PyMappingMethods
PyNumberMethods
PyTypeObject
2:tp_as_mapping
12.4从class对象到instance对象
PyTypeObjert
Python源码剖析
3:tp_as_sequence
一个好消息。
PyMappingMethods
PySequenceMethods
PyNumberMethods
一深度探索动态语言核心技术
293
---
## Page 324
Python源码剖析
294
object_newe
对象，Python虚拟机使用的是type_new：而对于instance对象，Python虚拟机则使用
new。创建class对象和创建instance对象的不同之处正是在于tp_new不同。创建class
实际上也就是object.tp_new，在PyBaseobject_Type中，这个操作被定义为object_
Ready对进行了初始化，其中的一项动作就是继承基类的操作，所以A.tp_new
会寻找class对象的type中定义的tp_ca11操作。的type为这个class对象时，Python虚拟机调用PyType
在class_O.py中，创建nstance的动作如下：
好消息是我们到了一个关键的转折点，在本节中，我们来看看从class对象出发，创
第12章Python虚拟机中的类机制
在上一节我们看到，在创建class对象的最后，Python执行引擎通过指令“19
坏消息是，很不幸，我们费尽千辛万苦，创建了class对象，仅仅是万里长征走完了
STORE NAME2（a)
LOAD NAME
一深度探索动态语言核心技术
EUNCTION
图12-23创建instance 对象后的 local名字空间
(A)
"A”
>
>
---
## Page 325
而是instance对象，type_call会尝试进行初始化的动作。
的所有工作就是申请了一个24字节的内存空间。
为A.tp_basicsize=PyBaseobject_Type.tp_basicsize+8三sizeof(Pyobject)
A.tp_basicsize+A.tp_itemsize大小的内存空间。上一节中，这两个量的计算结果
slotdefs中指定的与“_init_
将是调用object_init，在object_init中，Python虚拟机什么也不做，直接返回，所
的定义中重写了
PyBaseobject_Type的objectinit操作，但正如在本章2.3.3节中描述的那样，因为A
以，当我们通过a=A（）创建一个instance对象时，实际上是没有进行任何初始化的动
重写了_init_操作，那么搜索的结果就是你写的操作，如果没有重写，那么最终的结果
作。属性搜索是一个以后会剖析的独立主题，这里先按下不表。如果你在定义elass时，
及其mro列表中搜索属性
statie PyObjecttype_call PyTypeObject *type,
[typeobject.c]
[typeobject.a]
tatic int slot_tp_init(Pyobject *self,Pyobject *args, Pyobject *kwas)
*kwds)
在申请了24字节的内存空间，回到type_cal1之后，由于创建的不是class对象，
在执行slot_tp_init时，Python虚拟机会首先通过1ookup_method在class对象
对于基于创建的Instance对象obj，其ob_type当然也在PyType
在object_new中，调用了A.tp-alloc，这个操作也是从object继承而来的，是
到了这里，我们可以小结一下，从class对象创建instance对象的两个步骤：
PyObject_Call(meth, args,kwds);
Pyobject tmeth=lookup_method(self
static Pyobject *init_str;
type
Pyobject*obj;
returru O;
->tp
init(obi.
typei
arg5,kwds）
"对应的slot_tp_init:
12.4从class对象到instance对象
Python源码剖析
Pyobject*args,Pyobjeat
一深度探索动态语言核心技术
295
---
## Page 326
Python源码剖析
12.5访问instance对象中的属性
296
代码清单12-5
身上（见代码清单12-5）。
吗？没错，
关键所在，
的instance对象压入到运行时栈中。随后的指令“34LOAD_ATTR2”是属性访问机制的
函数，其调用过程是怎样的：
员函数，而另一个是需要参数的成员函数。这里，我们先来看看，对于不需要参数的成员
单的数据，比如字符事或整数，当然，也有可能是成员函数这类比较复杂的东西。
表达式称为“属性引用”，其中x为对象，而y为对象的属性，这个属性，有可能只是简
象的过程，前面我们就已经提过，class对象具有二相性。
象。从metaclass对象创建class对象的过程也是一个从class对象创建instance对
通常为NULL。需要特别注意的是，这两个步骤也适用于从metaclass对象创建class对
Pyobieet*Pyobject_Getattr（Pyobject*y,Pyobiect *name)
[object.c]
[LOAD_ATTR]
40
[PyCodeobject for class_0.py]
V
在class_0.py中，我们一共调用了两个classA的成员函数，
其中w为pyStringobject对象，而为运行时栈中的那个instance对象
Python虚拟机通过指令“31LOAD_NAME1”，会将1ocal名字空间中符号“a”对应
在前面的章节我们讨论名字空间时就提到，在Python中，形如x.y或x.y（)形式的
其中，args为一个tuple对象，里面包含着创建instance对象的各种参数，而kwds
第12章Python虚拟机中的类机制
class.
instance=class._new_（class,args,kwds)
POP_TOP
CALTFONCITION
LOADNAME
OAD
是一个PyFunctionObject对象：
深度探索动态语言核心技术
SET_TOP(X)
ATTR
Py_DECREF(V)
init_(instance,args;kwds)
PyObjectGetAttr(v,w);
o
(E)
一个是不需要参数的成
---
## Page 327