说了这么多，在我们的例子中，RUN命令的目的就是用最新的软件包（apt-get
需要注意的是，大小并不是要考虑的唯一要素，我们应该尽量在大小和可维护
下一组指令为容器提供了可在运行时更改的环境变量：
当然，这样看起来更清爽，更容易维护。但是这么做有一系列问题，其中之
ENV DB_COLLECTION books
ENVDB_DBNAMEbooks
RUN rm -rf /var/lib/apt/lists/*
 o s-su-ou-- s----s -e 
RUN apt-get update
UN
apt-get clean
一个容器是一层层镜像
5.2部署流水线步骤69
---
## Page 85
第5章部署流水线的实现——初始阶段
复制其余文件（后端JAR包和前端组件）。
支持）。
我鼓励你使用COPY，除非需要ADD 提供的其他功能（最显著的是TAR 提取和URL
地址为目录，请以斜线（/）结尾。
个文件，则目标地址也是一个文件，当源地址是一个目录时也如此。要强制目标
通配符。
的。源地址可以是文件或整个目录，并且接受与Go的filepath.Match规则匹配的
所在的目录或其子目录之内的文件，比如coPY../something/something是不允许
Dockerfile的位置，并且必须位于构建的上下文中，这意味着你只能复制Dockerfile
器中，应该写成coPY..．的格式。源地址是相对于
境变量是在运行时将特定于环境的信息传递到容器的首选方法。
些情况下，虽然这是不切实际的（例如，随后将使用nginx作为反向代理），但环
上的容器。理想情况下，应该运行一个不依赖于任何其他外部文件的容器。在某
到）
原因想改变这些值，则可以在执行dockerrun命令时设置它们（我后面会介绍
COLLECTION。服务的代码使用这些变量来创建到MongoDB的连接。如果出于某种
在我们的例子中，复制 run.sh 并通过 chmod RUN 指令使其变得可执行，然后
虽然没有在例子中使用ADD，但是要注意它和COPY非常相似。大多数情况下，
COPY指令，顾名思义，它是将文件从主机文件系统复制到我们正在构建的容
在容器的世界里，我们不鼓励把特定于环境的文件传递到运行在不同服务器
在这个特定的例子里，我们使用默认值来声明变量DB_DBNAME 和 DB_
COPY client/components /client/components
COPY target/scala-2.10/books-ms-assembly-1.0.jar /bs.jar
COPYrun.sh/run.sh
在我们的例子里，接下来是几条COPY指令：
，目标地址也可以是文件或目录。目标与源的类型匹配，如果源地址是一
---
## Page 86
run.sh 文件的权限。另一方面要考虑 Docker 缓存。当 docker build 命令运行时，
比如不能在安装之前运行可执行文件，或者在我们的例子中，在复制之前更改
用于指定Dockerfile位于当前目录中。
用推送到云端而把你公司的CEO吓出心脏病来。最后，末尾的参数是一个点（.)，
因为它提供了对容器的全面控制，比本地网络的速度更快，并且不会因为你把应
Docker Hub 用户名。这允许我们将容器推送到私人镜像库。通常这种方式更好，
由于不想分享密码，这里采取了不同的方法，使用镜像库IP和端口，而不是
份，并且稍后会用于推送容器以便连接到Internet 的任何服务器上都可以拉取它。
使用/格式。如果你在Docker Hub上拥有该账户，那么用户名将用于标识你的身
我们用特定的名字来标记容器。如果你想将此容器推送到公共Hub，那么标签将
花费的时间更长)来看看我们使用的参数。第一个参数用于构建容器，参数-t允许
docker bui1d-t 10.100.198.200:5000/bo0ks-ms
学习其他指令来熟悉这种格式。与此同时，请访问Dockerfile参考文档了解更多信
只提供默认的执行程序，当容器运行时，可以很容易把它覆盖掉。
前，脚本包含命令 java-jar bs.jar，它将启动 Scala/Spray 服务器。请记住，CMD
parameter1,parameter2 等]。在我们的例子中，/run.sh 不带任何参数运行。
EXP0SE8080
CMD["/run.sh"]
还有一件要讨论的重要事情是Dockerfile中指令的顺序。一方面要合乎逻辑，
配备了这些知识后，让我们来构建容器，命令如下：
我们解释的示例Dockerfile 没有包含所有可用的指令。在本书中，我们将通过
EXPOSE指令用于指定容器内的哪个端口在运行时可用。
CMD 指令用于指定容器启动时要执行的命令。指令格式是[executable,
下面趁这个命令运行所花的时间（第一次构建所花费的时间总是比其他构建要
让我们看看Dockerfile里的最后两条指令。
5.2部署流水线步骤71
---
## Page 87
72
第5章部署流水线的实现——初始阶段
同开发人员和项目之间共享代码的方式一样，Docker Hub 不仅改变了我们部署正
Mongo.
要使用的镜像的名称。在我们的例子中，使用官方的 Docker MongoDB 镜像
字。如果没有指定，Docker 就会分配一个随机的名字。最后，末尾的参数是我们想
以下命令运行：
运行容器
的容器。
using the command 页面获取更多信息。
底是哪个指令，取决于我们是更改了JAR文件还是前端组件）。
当更改源代码时，Docker将继续输出--->使用缓存直到最后两个coPY指令之一（到
docker build 命令，就会注意到Docker 输出--->在所有步骤中使用缓存。之后，
添加了run.sh，因为后者可能随着每个构建的改变而改变。如果你第二次执行
可能改变的文件放在更高的位置。在我们的例子中，在 JAR 文件和前端组件之前
靠近底部的位置。即使在一组全是COPY和 ADD的指令中，也应该确保把那些不太
的指令。这意味着，在大多数情况下，cOPY指令和 ADD指令应放置在Dockerfile中
像。一旦找到构建新镜像的指令，Docker 将不仅构建该指令，还将构建所有后续
Docker 将一条一条地执行指令，
器，
该命令展示了Docker 非常有用的一个功能。就像GitHub彻底改变了我们在不
这意味着它将在后台运行。第二个参数--namebooks-db用于给容器指定一个名
docker run -d--name books-ms\
docker run-d--name books-dbmongo
运行容器很容易，只要你知道使用哪个参数即可。刚刚构建的容器可以使用
希望这时容器已经构建完成。如果没有，请稍事休息，下面即将运行新构建
第一个命令启动了服务所需的数据库容器。参数-d允许我们以分离模式运行容
下面将会频繁使用 Docker 命令，你将有很多机会去熟悉它们。同时请访问
10.100.198.200:5000/b00ks-ms
--link books-db:db\
-p8080:80801
，并检查其他某个构建过程是否已经创建了该镜
---
## Page 88
DB_NAME=/books-ms/db
名字。env的输出如下：
链接为db。由于所有的环境变量都是大写的，所以 Docker创建了不少以 DB开头的
量，并过滤出那些包含数据库的输出。当运行容器时，应该指定它把books-ms-db
话说，通过运行bash进入正在运行的容器。进入容器后就可列出所有的环境变
的容器的名称，最后使用bash覆盖Dockerfile中指定为cMD指令的默认命令。换句
exit
env|grepDB
docker exec-it books-ms bash
下面看看这些变量是什么样子的。
接到的容器的名称是books-ms-db。在容器内部，这个链接将被转换成环境变量。
是--link books-db：db，这样允许我们链接两个容器。在这个例子中，我们要链
样的参数，Docker会将其内部端口8080暴露给外部端口8080。使用的下一个参数
为随机端口。
供一个单一的端口，例如-p 8080。这种情况下，Docker 会将其内部端口 808 暴露
外，它还暴露了端口8080，并与books-ms-db容器链接。暴露端口很容易，可以提
作为Dockerfile中的FROM指令，并在下面添加副本指令。
可能希望启用replication set 的 MongoDB。获得这样镜像的最好方法是使用 mongo
有适合目标的镜像，通常使用现有镜像作为基础镜像也是一个好主意。例如，你
镜像。Docker的高效使用通常是由自己和其他人构建的运行镜像的组合。即使没
可能你会发现不止一个（通常是官方的docker容器），还有很多其他由社区完成的
随时访问https://hub.docker.com/并搜索你最喜爱的应用程序、服务或数据库。
在构建的应用程序的方式，也改变了我们部署其他人构建的应用程序的方式。请
参数-it告诉Docker希望这次执行是通过终端交互式进行的，接着是正在运行
可以使用exec命令进入正在执行的容器里：
在这个例子中，我们使用了两个用冒号分隔的端口（-p8080：8080）。有了这
稍后将在开始学习服务发现工具时使用这种方法。
第二个 docker run 命令更复杂一些。除了在分离模式下运行并给它一个名字
5.2部署流水线步骤
73
---
## Page 89
74
第5章部署流水线的实现一
Creating booksms_app_1
Creating booksms_db_1
docker-compose -f docker-compose-dev.yml up -d app
命令停止容器，然后用rm删除它们。
参数，则只有停止的容器可以被删除。rm命令与-f参数相结合，相当于先用 stop
docker rm-f books-ms books-db docker ps-a
我们先删除正在运行的容器：
完成相同结果更简单的方式是使用 Docker Compose。在查看其实际行为之前，让
books-ms-db。logs 命令，如名称所示，输出容器 books-ms 的日志。①
docker logs books-ms
dockerps-a
果
接的名字、TCP、端口等。最后两个（DB_COLLECTION 和DB_DBNAME）不是链接的结
DB_DBNAME=books
DB_COLLECTION=books
DB_PORT_27017_TCP_ADDR=172.17.0.5
DB_P0RT_27017_TCP_PR0T0=tCp
DB_ENV_MONGO_MAJOR=3.0
DB_PORT_27017_TCP_PORT=27017
DB_ENV_MONGO_VERSION=3.0.5
DB_P0RT=tCp://172.17.0.5:27017
DB_PORT_27017_TCP=tcp://172.17.0.5:27017
这次使用 docker-compose 命令运行这两个容器。-f 参数用于指定我们要使用
命令的输出如下：
下面用Docker Compose运行与之前相同的两个容器（mongo和books-ms）：
第一个命令（rm）用于删除所有列出的容器。参数-f用于强制删除，没有这个
尽管运行 Mongo DB 和 books-ms 容器非常简单，但仍然要记住所有的参数。
ps-a 命令列出了所有（-a）容器。这个命令应该输出books-ms 和
现在可以做更多的事情来确保一切正常运行：
而是在Dockerfile中定义的变量。
最后退出容器。
除了最后两个变量外，
一初始阶段
所有变量都是与其他容器链接的结果。我们得到了链
---
## Page 90
器的日志。
同一个容器的多个实例，你将有机会看到这个数字在不断地增加。
booksms_app_1
docker-compose ps
来做这件事：
目标，因此会首先启动db。
将自动启动所有相关的容器。运行 app 目标，Docker Compose 意识到 app 依赖 db
booksms_db_1
Name
中是mongo）、然后启动链接到它的那个（books-ms）容器不同，docker-compose
解。有趣的是链接，与我们在手动命令链接中需要首先启动源容器（在我们的例子
和db目标。它们的定义与我们已经使用的Docker命令和参数相似，应该很容易理
标。之前在建立开发环境时使用过它们，稍后会再次使用。现在，让我们讨论 app
-f参数。接下来是以分离模式启动 app 容器的启动命令（-d）。
默认的 docker-compose.yml 中定义生产环境配置。当使用默认文件名时，不需要
的规范文件。我倾向于在 docker-compose-dev.yml中定义所有的开发配置，并在
（app）和实例号（1）的组合来命名运行容器。稍后将运行分布在多个服务器上的
在两个容器都启动并运行的情况下，可以通过DockerCompose 来检查运行容
默认情况下，DockerCompose使用项目名称（默认为目录名称）、目标名称
输出应该和下面的内容类似：
与之前一样，可以验证这两个容器是否正常运行，这次使用 Docker Compose
上面的输出只显示了目前感兴趣的目标。还有一些主要用于测试和编译的目
db:image:mongo
:dde
下面来看看 docker-compose-dev.yml文件的内容：
links:- db:db
ports:- 8080:8080
image: 10.100.198.200:5000/b00ks-ms
/entrypoint.sh mongod
/run.sh
Command
Up
S
State
27017/tcp
0.0.0.0:8080->8080/tcp
Ports
5.2部署流水线步骤
75
---
## Page 91
76
第5章部署流水线的实现——初始阶段
Ansible 来创建CD虚拟机，但还没有时间来解释它是如何工作的。甚至最糟糕的
置管理，它不仅可以让我们简化部署，还可以设置服务器。虽然我们已经使用
独的虚拟机来模拟这样的服务器）。在开始部署到生产环境之前，应该仔细检查配
建的容器应该运行在单独的生产服务器上（或者在我们的例子中，应该使用一个单
与导入它们的Web站点一起部署到生产环境中时，我们会尝试这些内容。
与数据库通信。请注意，使用 jq格式化 JSON 输出。
的特定书籍有关的数据。通过这些手动验证，确认服务可以正常工作，并且可以
MongoDB中。最后两个命令调用服务API来检索所有书籍的列表，以及与ID 为1
具和库。在我们的例子中，使用它向服务发送三个PUT请求，然后将数据存储到
docker-composelogs
-个简单的手动验证。
正在运行的容器放错了位置，正在使用的VM应该专门用于持续部署，而构
请记住，服务还包含前端Web组件，但目前并不会尝试它们。当将这个服务
对于那些不熟悉cur1的人来说，它是一个使用URL语法传输数据的命令行工
我更喜欢把测试尽可能地自动化，但这个主题会留给后面的章节，现在要做
curlhttp://localhost:8080/api/v1/books/_id/1|jq'
curl-H'Content-Type:application/json'
请注意，Docker Compose logs 命令处于跟随模式，你需要按 Ctrl+C 来停止它。
http://localhost:8080/api/v1/books|jq
"description":"Failed writers club"}′
"title":
"description":"Nota bad asthe firstbook"}'
http://localhost:8080/api/v1/books|jq'
"description":"Nota very good book"}'
"title":"My First Book"，"author":"John Doe",
'{"_id":1,
"My Third Book"，
-XPUT-d
---
## Page 92
检查表
vagrant destroy -f
exit
docker push 10.100.198.200:5000/books-ms-tests
存储在主机（目录镜像库）上，而不依赖正在运行的虚拟机：
容器具有将主机目录映射到存储镜像的内部路径的卷。这样，所有推送的镜像都
前，我们把测试容器推送到镜像库，这样下次就不必从头开始重新构建。镜像库
得的知识中受益，但从技术上讲，它们都是独立运作的。在摧毁所做的一切之
于我们之前做的任务而导致失败。每章都是完全自治的。虽然你将从以前章节获
拟机。这样，你可以在继续冒险之前休息一下，或者跳入任何一章，不用担心由
学习了配置管理，就有额外的服务器来运行存储在这个镜像库中的容器。
10.100.198.200 和端口为 5000 上的镜像库。10.100.198.200 是 cd 虚拟机的 IP。
镜像库推送的一种特殊格式；：/。容器被标记之后，可以将其推送到运行在IP为
docker push 10.100.198.200:5000/books-ms
允许我们从任何可以访问cd服务器的地方拉取容器。请运行以下命令：
虚拟机来运行镜像库。当 books-ms 容器构建好时，就可以把它推送到镜像库，并
将容器推入镜像库
docker-composestop
来应该做的事情：启用持续部署流水线。
是，还没有选择使用哪种工具。
让我们通过销毁所有的虚拟机来结束这一章。第7章将创建我们需要的那些虚
随着容器安全地存储到镜像库中，可以在任何服务器上运行它。很快，一旦
Docker 镜像库可以用来存储和检索容器，我们已经使用在本章开头创建的 cd
现在，让我们停止并删除 books-ms 容器及其依赖项，从而让 cd服务器做它本
我们仍然缺少几个基本实现部署流水线的步骤。作为提醒，步骤如下。
前面我们使用 10.100.198.200:5000/books-ms 标签构建了容器。这是向私有
5.2部署流水线步骤77
---
## Page 93