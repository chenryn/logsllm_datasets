---
## Page 177
直9
有D、G、H、1，如图6-2-5所示。
A，我是你孩子
C，我们是兄弟
D.我
图6-2-5
6.2.3树的其他相关概念
结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。若某结
点在第1层，则其子树的根就在第1+1层。其双亲在同一层的结点互为堂兄弟。显然
图6-2-6中的D、E、F是堂兄弟，而G、H、1、J也是。树中结点的最大层次称为树
的深度（Depth）或高度，当前树的深度为4。
第一层
第二层
B
第三层
D
E
第四层
G
H
堂兄弟
深度为4
图6-2-6
如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有
序树，否则称为无序树。
森林（Forest）是m（m>0）棵互不相交的树的集合。对树中每个结点而言，其
子树的集合即为森林。对于图6-2-1中的树而言，图6-2-2中的两棵子树其实就可以
理解为森林。
对比线性表与树的结构，它们有很大的不同，如图6-2-7所示。
153
---
## Page 178
大话数据结构
线性结构
树结构
第一个数据元素：无前驱
根结点：无双亲，唯一
·最后一个数据元素：无后继
叶结点：无孩子，可以多个
·中间元素：一个前驱一个后继
中间结点：一个双亲多个孩子
图6-2-7
6.3树的抽象数据类型
相对于线性结构，树的操作就完全不同了，这里我们给出一些基本和常用操作。
ADT 树（tree）
Data
树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。
Operation
InitTree（*）：构造空树T。
DestroyTree（*T）：销毁树T。
CreateTree（*T,definition）：按definition中给出树的定义来构造树。
ClearTree（*T）：若树T存在，则将树T清为空树。
TreeEmpty（T）：若T为空树，返图true，否则返四false
TreeDepth（T）：返回的深度。
RoOt（T）：返图T的根结点。
Value（T，cur_e）：cur_e是树T中一个结点，返回此结点的值。
Assign（T，cur_e，value）：给树T的结点cur_e赋值为value。
Parent（T，cur_e）：若cur_e是树T的非根结点，则返回它的双亲，否则返田空。
Leftchild（T，cur_e）：若cur_e是树T的非叶结点，则适回它的最左孩子，否则通园空。
RightSibling（T，cur_e）：若cur_e有右兄弟，则返回它的右兄弟，否则返田空。
InsertChild（*T，*p，1,c）：其中p指向树的某个结点，1为所指结点p的度加上1，
非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树。
DeleteChild（*T，*p，i）：其中p指向树的某个结点，i为所指结点p的度，操作
结果为删除T中p所指结点的第i媒子树。
endADT
154
---
## Page 179
第6章树
6.4树的存储结构
说到存储结构，就会想到我们前面章节讲过的顺序存储和链式存储两种结构。
先来看看顺序存储结构，用一段地址连续的存储单元依次存储线性表的数据元
素。这对于线性表来说是很自然的，对于树这样一多对的结构呢？
树中某个结点的孩子可以有多个，这就意味着，无论按何种顺序将树中所有结点
存储到数组中，结点的存储位置都无法直接反映逻辑关系，你想想看，数据元素挨个
的存储，谁是谁的双亲，谁是谁的孩子呢？简单的顺序存储结构是不能满足树的实现
要求的。
不过充分利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的
表示，我们这里要介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表
示法。
6.4.1双亲表示法
我们人可能因为种种原因，没有孩子，但无论是谁都不可能是从石头里蹦出来
的，孙悟空显然不能算是人，所以是人一定会有父母。树这种结构也不例外，除了根
结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。
我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指
示其双亲结点到链表中的位置。也就是说，每个结点除了知道自已是谁以外，还知道
它的双亲在哪里。它的结点结构为表6-41所示。
表6-4-1
dataparent
其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双
亲在数组中的下标。
以下是我们的双亲表示法的结点结构定义代码。
76
/树的双亲表示法结点结构定义·/
#define MAX_TREE_SIZE 100
typedetint TElemype;/·树结点的数据类型，目前智定为整型
typedef8tructPTNode/·结点结构*/
155
---
## Page 180
大据数据结
TElemType data;
1·结点数据/
int parent;
/双录位置·/
typedef struct
树结构/
PTNodenodes[MAX_TREE_SIZE]:/·结点数组*/
intr,n;
/根的位置和结点数/
}PTree;
有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲
的，所以我们约定根结点的位置域设置为一1，这也就意味着，我们所有的结点都存
有它双亲的位置。如图6-4-1中的树结构和表6-4-2中的树双亲表示所示。
A
H
图6-4-1
表6-4-2
下标data
parent
0
A
-1
0
2
C
0
E
D
1
4
E
2
2
G
.7
3
3
8
6
4
这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所
用的时间复杂度为0（1），直到parent为一1时，表示找到了树结点的根。可如果我们
要知道结点的孩子是什么，对不起，请遍历整个结构才行。
156
---
## Page 181
第6章树
这真是麻烦，能不能改进一下呢？
当然可以。我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很
容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为一1，如表6-4-3
所示。
表6-4-3
下标dataparent
firstchild
。
A
-1
-1
1
B
0
3
2
C
0
4
3
D
1
6
4
E
9
5
1F
12
-1
6
G
3
-1
7
H
3
1
8
13
-1
6
-1
对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。
甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。
另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的
关系，那我们怎么办？嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一
个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则
赋值为-1，如表6-4-4所示。
表6-4-4
下标dataparent
rightsib
0
A
-1
B
-1
1
0
2
2
C
0
-1
E
D
1
-1
4
3
5
5
F
2
-1
6
G
3
7
H
E
8
8
3
-1
6
4
1-
但如果结点的孩子很多，超过了2个。我们又关注结点的双亲、又关注结点的孩
子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩
展为有双亲域、长子域、再有右兄弟域。存储结构的设计是一个非常灵活的过程。一
个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时
间复杂度好不好等。注意也不是越多越好，有需要时再设计相应的结构。就像再好听
157
---
## Page 182
大语数据结构
的音乐，不停反复听上千遍也会腻味，再好看的电影，一段时间反复看上百遍，也会
无趣，你们说是吧？
6.4.2孩子表示法
换一种完全不同的考虑方法。由于树中每个结点可能有多棵子树，可以考虑用多
重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这
种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同
的。所以可以设计两种方案来解决。
方案一
一种是指针域的个数就等于树的度，复习一下，树的度是树各个结点度的最大
值。其结构如表6-4-5所示。