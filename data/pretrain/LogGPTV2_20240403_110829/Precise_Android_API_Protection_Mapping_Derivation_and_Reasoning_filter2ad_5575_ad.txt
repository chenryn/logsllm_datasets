292
332
166
118
227
235
281
301
541
581
292
377
36
36
49
49
104
115
55
69
180
186
309
313
629
669
369
421
40.11
40.31
42.55
43.53
51.8
51.79
44.09
42.29
Table 2: Most Common Disjoint Protections Paths
Category
Protection Path 1
Protection Path 2
User Checks
UID Checks
Permission Checks
Perm = android.permission.INTERACT_ACROSS_USERS_FULL
Perm = android.permission.INTERACT_ACROSS_USERS_FULL
Perm = android.permission.INTERACT_ACROSS_USERS_FULL
Perm = android.permission.INTERACT_ACROSS_USERS_FULL
Perm = android.permission.INTERACT_ACROSS_USERS
Perm = android.permission.INTERACT_ACROSS_USERS
Perm = android.permission.INTERACT_ACROSS_USERS
UID = SYSTEM_UID
UID = ROOT_UID
UID = ROOT_UID
Perm = android.permission.UPDATE_DEVICE_STATS
Perm = android.permission.MANAGE_APP_TOKENS
Perm = android.permission.UPDATE_APP_OPS_STATS
Perm = android.permission.SET_KEYBOARD_LAYOUT
Perm = android.permission.UPDATE_APP_OPS_STATS
Perm = android.permission.READ_PHONE_STATE
Perm = android.permission.ACCESS_FINE_LOCATION
Perm = android.permission.GET_TASKS
Perm = android.permission.DEVICE_POWER
Perm = android.permission.SCORE_NETWORKS
Perm = android.permission.WRITE_SETTINGS
Perm = android.permission.INTERACT_ACROSS_USERS
xi = UserId
UID = SYSTEM_UID
UID = ROOT_UID
xi = UserId
UID = SYSTEM_UID
UID = ROOT_UID
xi = UserId
xi = UserId
UID = SYSTEM_UID
PID = Process.myPid
PID = Process.myPid
PID = Process.myPid
PID = Process.myPid
xi = UID
Perm = android.permission.READ_PRIVILEGED_PHONE_STATE
Perm = android.permission.ACCESS_COARSE_LOCATION
Perm = android.permission.REAL_GET_TASKS
Perm = android.permission.UPDATE_DEVICE_STATS
Perm = android.permission.BROADCAST_NETWORK_PRIVILEGED
Perm = android.permission.CHANGE_NETWORK_STATE
one of the following: verifying if the supplied user id is equivalent
to the calling user id (meaning the user is performing a functional-
ity for herself and thus is allowed to do so), holding either one of
the permissions INTERACT_.._FULL, or INTERACT_.._USERS or be-
longing to a privileged UID (meaning the user is privileged enough
to perform operations for another user).
The 2nd category denotes access control where a privileged caller
is exceptionally allowed to perform an operation without holding
a permission. Such disjoint checks always include a privileged UID
/ PID check.
The last category includes disjoint permission enforcements,
where a permission is required for one path while another is needed
for the other path. Our analysis revealed that the condition deciding
which permission to enforce is often related to a supplied parameter.
These associated security checks disclose the access control de-
sign patterns in Android.
6.2 Applications of Protection Mappings
We leverage the generated protection mapping of Arcade to ad-
dress permission overprivilege and component hijacking problems.
We follow our proposed reasoning of the satisfiability of logic for-
mulas to vet Android apps for these security issues. Following, we
describe our collected apps and then present our achieved detection
results.
Collected Apps. Our app dataset (Table 3) consists of a large
corpus of Android system apps (total 12043 apps) extracted from
62 custom ROMs, which we have collected from various resources
Figure 7: Distribution of Protection Paths Count for AOSP 6.0.1 &
7.0
the access is granted. To this end, we examine the generated dis-
joint protection paths and group them into possible pairs. if a pair
exists in our protection map, we increase the corresponding count.
Table 2 lists the most common disjoint paths as generated by our
analysis (for AOSP 7.0). Each row denotes a pair.
As shown, we can group the disjoint protection paths into 3
categories. The 1st category denotes a cross user interaction check.
This category has been added into the framework to implement the
multi-user access control, i.e., enforce that the user has the right to
perform certain operations. As listed, user checks consist of either
[33, 34] and a few physical devices. The images belong to 12 distinct
vendors and operate Android versions 6.0.1 to 7.1.
Table 3: Collected System Apps
# Images
# System Apps
Avg # of Apps per Image
20
1
5
1
3
11
2
7
5
1
5
1
62
5919
201
781
137
350
1505
240
861
1040
235
633
139
12043
295
201
156
137
116
136
120
123
208
235
126
139
167
Vendor
Samsung
LG
HTC
Advan
Kata
Lenovo
Xiaomi
Mobicel
Oppo
Sony
Wileyfox
ZTE
Total
Please note that we focus on system apps because of the fol-
lowing two reasons. First, the usage of System and Signature level
permissions, contributing to a significant percentage of the API
map, is not relevant in the context of 3rd party apps. Second, any
vulnerability detected in system app has a bigger impact as it is
automatically present in the corresponding victim images.
6.2.1 Permission Overprivilege Problem.
Across all vendors, we identified that 61.5% of apps are over-
privileged, with Oppo exhibiting the highest % of overprivileges (∼
74%) and HTC having the lowest (∼ 43%). Fortunately, the situation
seems to have improved since the overprivilege results (85.78%)
reported by [37] for system apps (Android 2.3 to 4.1).
Our conducted app analysis abstracts the context of invoked
APIs in an app and selects accordingly the least privileged access
control path from its protection mapping, generated by Arcade.
This intuitively implies that our set of required permissions per
app would be smaller than the ones produced through leveraging
PScout’s or Axplorer’s mappings. To demonstrate whether this
indeed leads to capturing more overprivileges instances than other
tools, we further perform overprivilege detection using Axplorer’s
permission mapping. Table 4 reports the average number of un-
needed permissions per app as produced by our mappings and by
the approach relying on Axplorer’s.
On average, using Arcade’s mapping, we can exclusively de-
tect 2.5 more unneeded permissions per overprivileged app, an
average increase of 43.8% over the other approach, which clearly
demonstrates the strengths of our conducted path-sensitive anal-
ysis. Due to the lack of a ground truth, we manually verified the
flagged permissions that were reported as unneeded by our ap-
proach. Specifically, we inspected the apps to locate invocation
sites to APIs requiring these flagged permissions. Then, for each
API, we checked whether the app indeed does not need to hold the
permission because of its implicit properties or the specific parame-
ters passed to the APIs. This verification process involves extensive
manual work and thus cannot scale to cover a large number of
apps. Thus, we performed the manual verification on 120 randomly
sampled apps. Our manual analysis revealed that in 112 apps, the
flagged permissions are indeed unneeded (92%). For the remaining
8 apps, we could not confirm the result as it was not possible to
infer the implicit parameters passed to the APIs.
Furthermore, through our manual inspection, we noticed that
the permissions responsible for the observed detection differences
Table 4: Permission Overprivilege across Vendors
Vendor
Avg # of Unneeded Permissions
Arcade
Axplorer
Samsung
LG
HTC
Advan
Kata
Lenovo
Oppo
Xiaomi
Mobicel
Sony
Wileyfox
ZTE
Total
7.8
5.5
6.5
11.8
6.6
9.8
10.4
9.8
7.9
8.4
6.2
8.5
8.3
5.3
3.5
4.3
8.8
4.5
6.3
8.1
6.8
5.1
5.9
4.2
5.8
5.7
are unsurprisingly the permissions appearing in Table 2. They
were not captured as unneeded by the other approaches, due to
their lack of path-sensitive analysis. For example, the permissions
INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, READ_
PRIVILEGED_PHONE_STATE and ACCESS_FINE_LOCATION were all
deemed as needed by other approaches, while they were the main
reason for the overprivileges detected by our tool.
6.2.2 Component hijacking Vulnerability.
Table 5: Component Hijacking
Vendor
Avg % of Vulnerable Apps
Arcade
Axplorer
Avg #(%) of Additional FP
Components by Axplorer1
Samsung
LG
HTC
Advan
Kata
Lenovo
Oppo
Xiaomi
Mobicel
Sony
Wileyfox
ZTE
Total
2.7
3.8
1.4
2.7
3.9
3.8
4.6
1.8
3.1
1.3
3.1
2.7
2.9
3.4
4.4
1.5
3.4
4.5
4.7
5.8
2.3
4
1.7
3.9
3.5
3.4
7 ( 9.3 %)
9 ( 14.1 %)
4 ( 31.2 %)
11 ( 23.3 %)
12 ( 15.1 %)
11 ( 14.4 %)
14 ( 20.2 %)
8 ( 22.7 %)
23 ( 32.3 %)
5 ( 16.6 %)
18 ( 18.7 %)
19 ( 21.2 %)
11.8 ( 19.8 %)
1. Due to the lack of ground truth, we cannot automatically identify the FP for our
tool. Manual inspection on 70 components reported show that 13% are FPs. Note
that these FPs are common for both our tool and Axplorer, while the FPs reported
in the last column are unique to Axplorer.
Our analysis for component hijacking detection led to the results
depicted in Table 5. As reported by our tool (Column 2), the average