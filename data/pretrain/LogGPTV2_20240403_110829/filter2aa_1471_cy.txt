host the ETW logger thread, which is the main entity that flushes the events
to the log file or delivers them to the real-time consumer.
Sessions are created using the StartTrace API and configured using
ControlTrace and EnableTraceEx2. Command-line tools such as xperf,
logman, tracelog, and wevtutil use these APIs to start or control trace
sessions. A session also can be configured to be private to the process that
creates it. In this case, ETW is used for consuming events created only by the
same application that also acts as provider. The application thus eliminates
the overhead associated with the kernel-mode transition. Private ETW
sessions can record only events for the threads of the process in which it is
executing and cannot be used with real-time delivery. The internal
architecture of private ETW is not described in this book.
When a global session is created, the StartTrace API validates the
parameters and copies them in a data structure, which the NtTraceControl
API uses to invoke the internal function EtwpStartLogger in the kernel. An
ETW session is represented internally through an
ETW_LOGGER_CONTEXT data structure, which contains the important
pointers to the session memory buffers, where the events are written to. As
discussed in the “ETW initialization” section, a system can support a limited
number of ETW sessions, which are stored in an array located in a global
per-SILO data structure. EtwpStartLogger checks the global sessions array,
determining whether there is free space or if a session with the same name
already exists. If that is the case, it exits and signals an error. Otherwise, it
generates a session GUID (if not already specified by the caller), allocates
and initializes an ETW_LOGGER_CONTEXT data structure representing the
session, assigns to it an index, and inserts it in the per-silo array.
ETW queries the session’s security descriptor located in the
HKLM\System\CurrentControlSet\Control\Wmi\Security registry key. As
shown in Figure 10-33, each registry value in the key is named as the session
GUID (the registry key, however, also contains the provider’s GUID) and
contains the binary representation of a self-relative security descriptor. If a
security descriptor for the session does not exist, a default one is returned for
the session (see the “Witnessing the default security descriptor of ETW
sessions” experiment later in this chapter for details).
Figure 10-33 The ETW security registry key.
The EtwpStartLogger function performs an access check on the session’s
security descriptor, requesting the TRACELOG_GUID_ENABLE access right
(and the TRACELOG_CREATE_REALTIME or
TRACELOG_CREATE_ONDISK depending on the log file mode) using the
current process’s access token. If the check succeeds, the routine calculates
the default size and numbers of event buffers, which are calculated based on
the size of the system physical memory (the default buffer size is 8, 16, or
64KB). The number of buffers depends on the number of system processors
and on the presence of the
EVENT_TRACE_NO_PER_PROCESSOR_BUFFERING logger mode flag,
which prevents events (which can be generated from different processors) to
be written to a per-processor buffer.
ETW acquires the session’s initial reference time stamp. Three clock
resolutions are currently supported: Query performance counter (QPC, a
high-resolution time stamp not affected by the system clock), System time,
and CPU cycle counter. The EtwpAllocateTraceBuffer function is used to
allocate each buffer associated with the logger session (the number of buffers
was calculated before or specified as input from the user). A buffer can be
allocated from the paged pool, nonpaged pool, or directly from physical large
pages, depending on the logging mode. Each buffer is stored in multiple
internal per-session lists, which are able to provide fast lookup both to the
ETW main logger thread and ETW providers. Finally, if the log mode is not
set to a circular buffer, the EtwpStartLogger function starts the main ETW
logger thread, which has the goal of flushing events written by the providers
associated with the session to the log file or to the real-time consumer. After
the main thread is started, ETW sends a session notification to the registered
session notification provider (GUID 2a6e185b-90de-4fc5-826c-
9f44e608a427), a special provider that allows its consumers to be informed
when certain ETW events happen (like a new session being created or
destroyed, a new log file being created, or a log error being raised).
EXPERIMENT: Enumerating ETW sessions
In Windows 10, there are multiple ways to enumerate active ETW
sessions. In this and all the next experiments regarding ETW, you
will use the XPERF tool, which is part of the Windows
Performance Toolkit distributed in the Windows Assessment and
Deployment Kit (ADK), which is freely downloadable from
https://docs.microsoft.com/en-us/windows-hardware/get-
started/adk-install.
Enumerating active ETW sessions can be done in multiple ways.
XPERF can do it while executed with the following command
(usually XPERF is installed in C:\Program Files (x86)\Windows
Kits\10\Windows Performance Toolkit):
xperf -Loggers
The output of the command can be huge, so it is strongly advised
to redirect the output in a TXT file:
Click here to view code image
xperf -Loggers > ETW_Sessions.txt
The tool can decode and show in a human-readable form all the
session configuration data. An example is given from the
EventLog-Application session, which is used by the Event logger
service (Wevtsvc.dll) to write events in the Application.evtx file
shown by the Event Viewer:
Click here to view code image
Logger Name           : EventLog-Application
Logger Id             : 9
Logger Thread Id      : 000000000000008C
Buffer Size           : 64
Maximum Buffers       : 64
Minimum Buffers       : 2
Number of Buffers     : 2
Free Buffers          : 2
Buffers Written       : 252
Events Lost           : 0
Log Buffers Lost      : 0
Real Time Buffers Lost: 0
Flush Timer           : 1
Age Limit             : 0
Real Time Mode        : Enabled
Log File Mode         : Secure PersistOnHybridShutdown 
PagedMemory IndependentSession
NoPerProcessorBuffering
Maximum File Size     : 100
Log Filename          :
Trace Flags           : "Microsoft-Windows-
CertificateServicesClient-Lifecycle-User":0x800
0000000000000:0xff+"Microsoft-Windows-
SenseIR":0x8000000000000000:0xff+
... (output cut for space reasons)
The tool is also able to decode the name of each provider
enabled in the session and the bitmask of event categories that the
provider should write to the sessions. The interpretation of the
bitmask (shown under “Trace Flags”) depends on the provider. For
example, a provider can define that the category 1 (bit 0 set)
indicates the set of events generated during initialization and
cleanup, category 2 (bit 1 set) indicates the set of events generated
when registry I/O is performed, and so on. The trace flags are
interpreted differently for System sessions (see the “System
loggers” section for more details.) In that case, the flags are
decoded from the enabled kernel flags that specify which kind of
kernel events the system session should log.
The Windows Performance Monitor, in addition to dealing with
system performance counters, can easily enumerate the ETW
sessions. Open Performance Monitor (by typing perfmon in the
Cortana search box), expand the Data Collector Sets, and click
Event Trace Sessions. The application should list the same sessions
listed by XPERF. If you right-click a session’s name and select
Properties, you should be able to navigate between the session’s
configurations. In particular, the Security property sheet decodes
the security descriptor of the ETW session.
Finally, you also can use the Microsoft Logman console tool
(%SystemRoot%\System32\logman.exe) to enumerate active ETW
sessions (by using the -ets command-line argument).
ETW providers
As stated in the previous sections, a provider is a component that produces
events (while the application that includes the provider contains event tracing
instrumentation). ETW supports different kinds of providers, which all share
a similar programming model. (They are mainly different in the way in which
they encode events.) A provider must be initially registered with ETW before
it can generate any event. In a similar way, a controller application should
enable the provider and associate it with an ETW session to be able to receive
events from the provider. If no session has enabled a provider, the provider
will not generate any event. The provider defines its interpretation of being
enabled or disabled. Generally, an enabled provider generates events, and a
disabled provider does not.
Providers registration
Each provider’s type has its own API that needs to be called by a provider
application (or driver) for registering a provider. For example, manifest-based
providers rely on the EventRegister API for user-mode registrations, and
EtwRegister for kernel-mode registrations. All the provider types end up
calling the internal EtwpRegisterProvider function, which performs the actual
registration process (and is implemented in both the NT kernel and NTDLL).
The latter allocates and initializes an ETW_GUID_ENTRY data structure,
which represents the provider (the same data structure is used for
notifications and traits). The data structure contains important information,
like the provider GUID, security descriptor, reference counter, enablement
information (for each ETW session that enables the provider), and a list of
provider’s registrations.
For user-mode provider registrations, the NT kernel performs an access
check on the calling process’s token, requesting the
TRACELOG_REGISTER_GUIDS access right. If the check succeeds, or if
the registration request originated from kernel code, ETW inserts the new
ETW_GUID_ENTRY data structure in a hash table located in the global ETW
per-silo data structure, using a hash of the provider’s GUID as the table’s key
(this allows fast lookup of all the providers registered in the system.) In case
an entry with the same GUID already exists in the hash table, ETW uses the
existing entry instead of the new one. A GUID could already exist in the hash
table mainly for two reasons:
■    Another driver or application has enabled the provider before it has
been actually registered (see the “Providers enablement” section later
in this chapter for more details) .
■    The provider has been already registered once. Multiple registration
of the same provider GUID are supported.
After the provider has been successfully added into the global list, ETW
creates and initializes an ETW registration object, which represents a single
registration. The object encapsulates an ETW_REG_ENTRY data structure,
which ties the provider to the process and session that requested its
registration. (ETW also supports registration from different sessions.) The
object is inserted in a list located in the ETW_GUID_ENTRY (the
EtwRegistration object type has been previously created and registered with
the NT object manager at ETW initialization time). Figure 10-34 shows the
two data structures and their relationships. In the figure, two providers’
processes (process A, living in session 4, and process B, living in session 16)
have registered for provider 1. Thus two ETW_REG_ENTRY data structures
have been created and linked to the ETW_GUID_ENTRY representing
provider 1.
Figure 10-34 The ETW_GUID_ENTRY data structure and the
ETW_REG_ENTRY.
At this stage, the provider is registered and ready to be enabled in the
session(s) that requested it (through the EnableTrace API). In case the
provider has been already enabled in at least one session before its
registration, ETW enables it (see the next section for details) and calls the
Enablement callback, which can be specified by the caller of the
EventRegister (or EtwRegister) API that started the registration process.
EXPERIMENT: Enumerating ETW providers
As for ETW sessions, XPERF can enumerate the list of all the
current registered providers (the WEVTUTIL tool, installed with
Windows, can do the same). Open an administrative command
prompt window and move to the Windows Performance Toolkit
path. To enumerate the registered providers, use the -providers
command option. The option supports different flags. For this
experiment, you will be interested in the I and R flags, which tell
XPERF to enumerate the installed or registered providers. As we
will discuss in the “Decoding events” section later in this chapter,
the difference is that a provider can be registered (by specifying a
GUID) but not installed in the
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEV
T\Publishers registry key. This will prevent any consumer from
decoding the event using TDH routines. The following commands
Click here to view code image
cd /d “C:\Program Files (x86)\Windows Kits\10\Windows 
Performance Toolkit”
xperf -providers R > registered_providers.txt
xperf -providers I > installed_providers.txt
produce two text files with similar information. If you open the
registered_providers.txt file, you will find a mix of names and
GUIDs. Names identify providers that are also installed in the
Publisher registry key, whereas GUID represents providers that
have just been registered through the EventRegister API discussed
in this section. All the names are present also in the
installed_providers.txt file with their respective GUIDs, but you
won’t find any GUID listed in the first text file in the installed
providers list.
XPERF also supports the enumeration of all the kernel flags and
groups supported by system loggers (discussed in the “System
loggers” section later in this chapter) through the K flag (which is a
superset of the KF and KG flags).
Provider Enablement
As introduced in the previous section, a provider should be associated with an
ETW session to be able to generate events. This association is called Provider
Enablement, and it can happen in two ways: before or after the provider is
registered. A controller application can enable a provider on a session
through the EnableTraceEx API. The API allows you to specify a bitmask of
keywords that determine the category of events that the session wants to
receive. In the same way, the API supports advanced filters on other kinds of
data, like the process IDs that generate the events, package ID, executable
name, and so on. (You can find more information at
https://docs.microsoft.com/en-us/windows/win32/api/evntprov/ns-evntprov-
event_filter_descriptor.)
Provider Enablement is managed by ETW in kernel mode through the
internal EtwpEnableGuid function. For user-mode requests, the function
performs an access check on both the session and provider security
descriptors, requesting the TRACELOG_GUID_ENABLE access right on
behalf of the calling process’s token. If the logger session includes the
SECURITY_TRACE flag, EtwpEnableGuid requires that the calling process
is a PPL (see the “ETW security” section later in this chapter for more
details). If the check succeeds, the function performs a similar task to the one
discussed previously for provider registrations:
■    It allocates and initializes an ETW_GUID_ENTRY data structure to
represent the provider or use the one already linked in the global
ETW per-silo data structure in case the provider has been already
registered.
■    Links the provider to the logger session by adding the relative session
enablement information in the ETW_GUID_ENTRY.
In case the provider has not been previously registered, no ETW
registration object exists that’s linked in the ETW_GUID_ENTRY data
structure, so the procedure terminates. (The provider will be enabled after it
is first registered.) Otherwise, the provider is enabled.
While legacy MOF providers and WPP providers can be enabled only to
one session at time, Manifest-based and Tracelogging providers can be
enabled on a maximum of eight sessions. As previously shown in Figure 10-
32, the ETW_GUID_ENTRY data structure contains enablement information
for each possible ETW session that enabled the provider (eight maximum).
Based on the enabled sessions, the EtwpEnableGuid function calculates a
new session enablement mask, storing it in the ETW_REG_ENTRY data
structure (representing the provider registration). The mask is very important
because it’s the key for event generations. When an application or driver
writes an event to the provider, a check is made: if a bit in the enablement
mask equals 1, it means that the event should be written to the buffer
maintained by a particular ETW session; otherwise, the session is skipped
and the event is not written to its buffer.
Note that for secure sessions, a supplemental access check is performed
before updating the session enablement mask in the provider registration.
The ETW session’s security descriptor should allow the
TRACELOG_LOG_EVENT access right to the calling process’s access token.
Otherwise, the relative bit in the enablement mask is not set to 1. (The target
ETW session will not receive any event from the provider registration.) More
information on secure sessions is available in the “Secure loggers and ETW
security” section later in this chapter.
Providing events
After registering one or more ETW providers, a provider application can start
to generate events. Note that events can be generated even though a controller
application hasn’t had the chance to enable the provider in an ETW session.
The way in which an application or driver can generate events depends on the
type of the provider. For example, applications that write events to manifest-
based providers usually directly create an event descriptor (which respects the
XML manifest) and use the EventWrite API to write the event to the ETW
sessions that have the provider enabled. Applications that manage MOF and
WPP providers rely on the TraceEvent API instead.
Events generated by manifest-based providers, as discussed previously in
the “ETW session” section, can be filtered by multiple means. ETW locates
the ETW_GUID_ENTRY data structure from the provider registration object,
which is provided by the application through a handle. The internal
EtwpEventWriteFull function uses the provider’s registration session
enablement mask to cycle between all the enabled ETW sessions associated
with the provider (represented by an ETW_LOGGER_CONTEXT). For each
session, it checks whether the event satisfies all the filters. If so, it calculates
the full size of the event’s payload and checks whether there is enough free
space in the session’s current buffer.
If there is no available space, ETW checks whether there is another free
buffer in the session: free buffers are stored in a FIFO (first-in, first-out)
queue. If there is a free buffer, ETW marks the old buffer as “dirty” and
switches to the new free one. In this way, the Logger thread can wake up and
flush the entire buffer to a log file or deliver it to a real-time consumer. If the
session’s log mode is a circular logger, no logger thread is ever created: ETW
simply links the old full buffer at the end of the free buffers queue (as a result
the queue will never be empty). Otherwise, if there isn’t a free buffer in the
queue, ETW tries to allocate an additional buffer before returning an error to
the caller.
After enough space in a buffer is found, EtwpEventWriteFull atomically
writes the entire event payload in the buffer and exits. Note that in case the
session enablement mask is 0, it means that no sessions are associated with
the provider. As a result, the event is lost and not logged anywhere.
MOF and WPP events go through a similar procedure but support only a
single ETW session and generally support fewer filters. For these kinds of
providers, a supplemental check is performed on the associated session: If the
controller application has marked the session as secure, nobody can write any
events. In this case, an error is yielded back to the caller (secure sessions are
discussed later in the “Secure loggers and ETW security” section).
EXPERIMENT: Listing processes activity using ETW
In this experiment, will use ETW to monitor system’s processes
activity. Windows 10 has two providers that can monitor this
information: Microsoft-Windows-Kernel-Process and the NT
kernel logger through the PROC_THREAD kernel flags. You will
use the former, which is a classic provider and already has all the
information for decoding its events. You can capture the trace with
multiple tools. You still use XPERF (Windows Performance
Monitor can be used, too).
Open a command prompt window and type the following
commands:
Click here to view code image
cd /d “C:\Program Files (x86)\Windows Kits\10\Windows 
Performance Toolkit”
xperf -start TestSession -on Microsoft-Windows-Kernel-
Process -f c:\process_trace.etl
The command starts an ETW session called TestSession (you
can replace the name) that will consume events generated by the
Kernel-Process provider and store them in the C:\process_trace.etl
log file (you can also replace the file name).
To verify that the session has actually started, repeat the steps
described previously in the “Enumerating ETW sessions”
experiment. (The TestSession trace session should be listed by both
XPERF and the Windows Performance Monitor.) Now, you should
start some new processes or applications (like Notepad or Paint, for
example).
To stop the ETW session, use the following command:
xperf -stop TestSession
The steps used for decoding the ETL file are described later in
the “Decoding an ETL file” experiment. Windows includes
providers for almost all its components. The Microsoft-Windows-
MSPaint provider, for example, generates events based on Paint’s
functionality. You can try this experiment by capturing events from
the MsPaint provider.
ETW Logger thread
The Logger thread is one of the most important entities in ETW. Its main
purpose is to flush events to the log file or deliver them to the real-time
consumer, keeping track of the number of delivered and lost events. A logger
thread is started every time an ETW session is initially created, but only in