### Hosting the ETW Logger Thread

The Event Tracing for Windows (ETW) logger thread is the primary entity responsible for flushing events to a log file or delivering them to a real-time consumer. Sessions are created using the `StartTrace` API and configured with `ControlTrace` and `EnableTraceEx2`. Command-line tools such as `xperf`, `logman`, `tracelog`, and `wevtutil` utilize these APIs to start or control trace sessions.

A session can be configured to be private, meaning it is exclusive to the process that creates it. In this configuration, ETW is used to consume events generated by the same application that acts as the provider. This setup eliminates the overhead associated with kernel-mode transitions. Private ETW sessions can only record events for the threads of the process in which they are executing and cannot be used for real-time delivery. The internal architecture of private ETW sessions is not covered in this book.

### Global Session Creation

When a global session is created, the `StartTrace` API validates the parameters and copies them into a data structure. This data structure is then used by the `NtTraceControl` API to invoke the internal function `EtwpStartLogger` in the kernel. An ETW session is internally represented by an `ETW_LOGGER_CONTEXT` data structure, which contains pointers to the session's memory buffers where events are written. As discussed in the "ETW Initialization" section, a system can support a limited number of ETW sessions, stored in an array within a global per-SILO data structure.

`EtwpStartLogger` checks the global sessions array to determine if there is free space or if a session with the same name already exists. If a session with the same name is found, it exits and signals an error. Otherwise, it generates a session GUID (if not already specified), allocates and initializes an `ETW_LOGGER_CONTEXT` data structure, assigns it an index, and inserts it into the per-silo array.

### Security Descriptor and Access Check

ETW queries the session’s security descriptor from the `HKLM\System\CurrentControlSet\Control\Wmi\Security` registry key. Each registry value in the key is named after the session GUID and contains the binary representation of a self-relative security descriptor. If a security descriptor for the session does not exist, a default one is returned.

The `EtwpStartLogger` function performs an access check on the session’s security descriptor, requesting the `TRACELOG_GUID_ENABLE` access right (and either `TRACELOG_CREATE_REALTIME` or `TRACELOG_CREATE_ONDISK` depending on the log file mode) using the current process’s access token. If the check succeeds, the routine calculates the default size and number of event buffers based on the system's physical memory (the default buffer size is 8, 16, or 64KB). The number of buffers depends on the number of system processors and the presence of the `EVENT_TRACE_NO_PER_PROCESSOR_BUFFERING` flag, which prevents events from being written to a per-processor buffer.

### Timestamp and Buffer Allocation

ETW acquires the session’s initial reference timestamp. Three clock resolutions are supported: Query Performance Counter (QPC), System Time, and CPU Cycle Counter. The `EtwpAllocateTraceBuffer` function allocates each buffer associated with the logger session. Buffers can be allocated from the paged pool, nonpaged pool, or directly from physical large pages, depending on the logging mode. Each buffer is stored in multiple internal per-session lists, providing fast lookup for the ETW main logger thread and providers.

If the log mode is not set to a circular buffer, the `EtwpStartLogger` function starts the main ETW logger thread, which flushes events written by the providers to the log file or to the real-time consumer. After starting the main thread, ETW sends a session notification to the registered session notification provider (GUID `2a6e185b-90de-4fc5-826c-9f44e608a427`), a special provider that informs consumers about certain ETW events, such as session creation, destruction, new log file creation, or log errors.

### Experiment: Enumerating ETW Sessions

In Windows 10, you can enumerate active ETW sessions using various methods. For this experiment, you will use the `XPERF` tool, which is part of the Windows Performance Toolkit distributed in the Windows Assessment and Deployment Kit (ADK). You can download the ADK from [Microsoft's documentation](https://docs.microsoft.com/en-us/windows-hardware/get-started/adk-install).

To enumerate active ETW sessions, execute the following command in an administrative command prompt:

```sh
cd /d "C:\Program Files (x86)\Windows Kits\10\Windows Performance Toolkit"
xperf -Loggers > ETW_Sessions.txt
```

This command redirects the output to a text file, making it easier to read. The `XPERF` tool decodes and displays all session configuration data in a human-readable format. For example, the `EventLog-Application` session, used by the Event Logger service (`Wevtsvc.dll`), writes events to the `Application.evtx` file shown in the Event Viewer.

### ETW Providers

An ETW provider is a component that produces events. The application that includes the provider contains event tracing instrumentation. ETW supports different types of providers, which share a similar programming model but differ in how they encode events. A provider must be registered with ETW before it can generate any events. A controller application must enable the provider and associate it with an ETW session to receive events. If no session has enabled a provider, the provider will not generate any events.

### Provider Registration

Each provider type has its own API for registration. For example, manifest-based providers use `EventRegister` for user-mode registrations and `EtwRegister` for kernel-mode registrations. All provider types ultimately call the internal `EtwpRegisterProvider` function, which performs the actual registration process.

The `EtwpRegisterProvider` function allocates and initializes an `ETW_GUID_ENTRY` data structure, which represents the provider. This data structure contains important information such as the provider GUID, security descriptor, reference counter, enablement information, and a list of provider registrations.

For user-mode provider registrations, the NT kernel performs an access check on the calling process’s token, requesting the `TRACELOG_REGISTER_GUIDS` access right. If the check succeeds, or if the registration request originated from kernel code, ETW inserts the new `ETW_GUID_ENTRY` data structure into a hash table in the global ETW per-silo data structure, using the provider’s GUID as the key.

If an entry with the same GUID already exists in the hash table, ETW uses the existing entry. This can happen if another driver or application has enabled the provider before it was registered, or if the provider has been registered multiple times.

After the provider is successfully added to the global list, ETW creates and initializes an `ETW_REG_ENTRY` data structure, which ties the provider to the process and session that requested its registration. The object is inserted into a list located in the `ETW_GUID_ENTRY`.

### Experiment: Enumerating ETW Providers

To enumerate the list of all currently registered providers, use the `XPERF` tool with the `-providers` command option. Open an administrative command prompt and navigate to the Windows Performance Toolkit path. Execute the following commands:

```sh
cd /d "C:\Program Files (x86)\Windows Kits\10\Windows Performance Toolkit"
xperf -providers R > registered_providers.txt
xperf -providers I > installed_providers.txt
```

These commands produce two text files containing information about registered and installed providers. The `registered_providers.txt` file lists both names and GUIDs, while the `installed_providers.txt` file lists only names with their respective GUIDs.

### Provider Enablement

A provider must be associated with an ETW session to generate events. This association is called Provider Enablement and can occur before or after the provider is registered. A controller application can enable a provider on a session using the `EnableTraceEx` API, which allows specifying a bitmask of keywords to filter event categories.

Provider Enablement is managed by ETW in kernel mode through the `EtwpEnableGuid` function. For user-mode requests, the function performs an access check on both the session and provider security descriptors, requesting the `TRACELOG_GUID_ENABLE` access right on behalf of the calling process’s token. If the check succeeds, the function allocates and initializes an `ETW_GUID_ENTRY` data structure to represent the provider or uses an existing one if the provider has already been registered.

The `EtwpEnableGuid` function links the provider to the logger session by adding the relative session enablement information to the `ETW_GUID_ENTRY`. If the provider has not been previously registered, no `ETW_REG_ENTRY` object exists, and the procedure terminates. Otherwise, the provider is enabled.

Manifest-based and Tracelogging providers can be enabled on up to eight sessions, while legacy MOF and WPP providers can be enabled only to one session at a time. The `EtwpEnableGuid` function calculates a new session enablement mask, storing it in the `ETW_REG_ENTRY` data structure. This mask is crucial for event generation: if a bit in the enablement mask is set to 1, the event is written to the buffer maintained by the corresponding ETW session; otherwise, the session is skipped.

### Providing Events

After registering one or more ETW providers, a provider application can start generating events. The method for generating events depends on the provider type. For example, applications that write events to manifest-based providers typically create an event descriptor and use the `EventWrite` API to write the event to the ETW sessions that have the provider enabled. Applications that manage MOF and WPP providers use the `TraceEvent` API instead.

Events generated by manifest-based providers can be filtered by various means. The `EtwpEventWriteFull` function uses the provider’s registration session enablement mask to cycle through all enabled ETW sessions associated with the provider. For each session, it checks if the event satisfies all filters. If so, it calculates the full size of the event payload and checks if there is enough free space in the session’s current buffer.

If there is no available space, ETW checks for a free buffer in the session’s FIFO queue. If a free buffer is found, ETW marks the old buffer as "dirty" and switches to the new one, allowing the Logger thread to wake up and flush the entire buffer to a log file or deliver it to a real-time consumer. If the session’s log mode is a circular logger, no Logger thread is created, and the old full buffer is linked at the end of the free buffers queue. If there is no free buffer, ETW tries to allocate an additional buffer before returning an error to the caller.

### Experiment: Listing Processes Activity Using ETW

To monitor system processes activity using ETW, you can use the `Microsoft-Windows-Kernel-Process` provider. Open a command prompt and execute the following commands:

```sh
cd /d "C:\Program Files (x86)\Windows Kits\10\Windows Performance Toolkit"
xperf -start TestSession -on Microsoft-Windows-Kernel-Process -f c:\process_trace.etl
```

This command starts an ETW session called `TestSession` that consumes events generated by the `Kernel-Process` provider and stores them in the `C:\process_trace.etl` log file.

To verify that the session has started, repeat the steps described in the "Enumerating ETW Sessions" experiment. The `TestSession` should be listed by both `XPERF` and the Windows Performance Monitor. Start some new processes or applications (like Notepad or Paint) to generate events.

To stop the ETW session, use the following command:

```sh
xperf -stop TestSession
```

The steps for decoding the ETL file are described in the "Decoding an ETL File" experiment. Windows includes providers for almost all its components. For example, the `Microsoft-Windows-MSPaint` provider generates events based on Paint’s functionality. You can try this experiment by capturing events from the `MsPaint` provider.

### ETW Logger Thread

The Logger thread is a critical component of ETW, responsible for flushing events to the log file or delivering them to a real-time consumer. It keeps track of the number of delivered and lost events. A logger thread is started whenever an ETW session is initially created, but only if the log mode is not set to a circular buffer.