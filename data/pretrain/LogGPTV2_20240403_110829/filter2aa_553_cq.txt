6.编写一个名为is_within()的函数，接受一个字符和一个指向字符串的
指针作为两个函数形参。如果指定字符在字符串中，该函数返回一个非零值
（即为真）。否则，返回0（即为假）。在一个完整的程序中测试该函数，
使用一个循环给函数提供输入值。
7.strncpy(s1, s2, n)函数把s2中的n个字符拷贝至s1中，截断s2，或者有必
要的话在末尾添加空字符。如果s2的长度是n或多于n，目标字符串不能以空
字符结尾。该函数返回s1。自己编写一个这样的函数，名为mystrncpy()。在
一个完整的程序中测试该函数，使用一个循环给函数提供输入值。
8.编写一个名为string_in()的函数，接受两个指向字符串的指针作为参
数。如果第2个字符串中包含第1个字符串，该函数将返回第1个字符串开始
854
的地址。例如，string_in("hats", "at")将返回hats中a的地址。否则，该函数返
回空指针。在一个完整的程序中测试该函数，使用一个循环给函数提供输入
值。
9.编写一个函数，把字符串中的内容用其反序字符串代替。在一个完整
的程序中测试该函数，使用一个循环给函数提供输入值。
10.编写一个函数接受一个字符串作为参数，并删除字符串中的空格。
在一个程序中测试该函数，使用循环读取输入行，直到用户输入一行空行。
该程序应该应用该函数只每个输入的字符串，并显示处理后的字符串。
11.编写一个函数，读入10个字符串或者读到EOF时停止。该程序为用
户提供一个有5个选项的菜单：打印源字符串列表、以ASCII中的顺序打印字
符串、按长度递增顺序打印字符串、按字符串中第1个单词的长度打印字符
串、退出。菜单可以循环显示，除非用户选择退出选项。当然，该程序要能
真正完成菜单中各选项的功能。
12.编写一个程序，读取输入，直至读到 EOF，报告读入的单词数、大
写字母数、小写字母数、标点符号数和数字字符数。使用ctype.h头文件中的
函数。
13.编写一个程序，反序显示命令行参数的单词。例如，命令行参数是
see you later，该程序应打印later you see。
14.编写一个通过命令行运行的程序计算幂。第1个命令行参数是double
类型的数，作为幂的底数，第2个参数是整数，作为幂的指数。
15.使用字符分类函数实现atoi()函数。如果输入的字符串不是纯数字，
该函数返回0。
16.编写一个程序读取输入，直至读到文件结尾，然后把字符串打印出
来。该程序识别和实现下面的命令行参数：
-p     按原样打印
855
-u     把输入全部转换成大写
-l     把输入全部转换成小写
如果没有命令行参数，则让程序像是使用了-p参数那样运行。
856
第12章 存储类别、链接和内存管理
本章介绍以下内容：
关键字：auto、extern、static、register、const、volatile、restricted、
_Thread_local、_Atomic
函数：rand()、srand()、time()、malloc()、calloc()、free()
如何确定变量的作用域（可见的范围）和生命期（它存在多长时间）
设计更复杂的程序
C语言能让程序员恰到好处地控制程序，这是它的优势之一。程序员通
过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制。合理
使用内存储存数据是设计程序的一个要点。
857
12.1 存储类别
C提供了多种不同的模型或存储类别（storage 
class）在内存中储存数
据。要理解这些存储类别，先要复习一些概念和术语。
本书目前所有编程示例中使用的数据都储存在内存中。从硬件方面来
看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为
对象（object）。对象可以储存一个或多个值。一个对象可能并未储存实际
的值，但是它在储存适当的值时一定具有相应的大小（面向对象编程中的对
象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对
象编程语言）。
从软件方面来看，程序需要一种方法访问对象。这可以通过声明变量来
完成：
int entity = 3;
该声明创建了一个名为entity的标识符（identifier）。标识符是一个名
称，在这种情况下，标识符可以用来指定（designate）特定对象的内容。标
识符遵循变量的命名规则（第2章介绍过）。在该例中，标识符entity即是软
件（即C程序）指定硬件内存中的对象的方式。该声明还提供了储存在对象
中的值。
变量名不是指定对象的唯一途径。考虑下面的声明：
int * pt = &entity;
int ranks[10];
第1行声明中，pt是一个标识符，它指定了一个储存地址的对象。但
是，表达式*pt不是标识符，因为它不是一个名称。然而，它确实指定了一
个对象，在这种情况下，它与 entity 指定的对象相同。一般而言，那些指定
对象的表达式被称为左值（第5章介绍过）。所以，entity既是标识符也是左
858
值；*pt既是表达式也是左值。按照这个思路，ranks + 2 * entity既不是标识符
（不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式*
(ranks + 2 * entity)是一个左值，因为它的确指定了特定内存位置的值，即
ranks数组的第7个元素。顺带一提，ranks的声明创建了一个可容纳10个int类
型元素的对象，该数组的每个元素也是一个对象。
所有这些示例中，如果可以使用左值改变对象中的值，该左值就是一个
可修改的左值（modifiable lvalue）。现在，考虑下面的声明：
const char * pc = "Behold a string literal!";
程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值
的数组就是一个对象。由于数组中的每个字符都能被单独访问，所以每个字
符也是一个对象。该声明还创建了一个标识符为pc的对象，储存着字符串的
地址。由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的
左值。const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指
向别的字符串。由于*pc指定了储存'B'字符的数据对象，所以*pc 
是一个左
值，但不是一个可修改的左值。与此类似，因为字符串字面量本身指定了储
存字符串的对象，所以它也是一个左值，但不是可修改的左值。
可以用存储期（storage duration）描述对象，所谓存储期是指对象在内
存中保留了多长时间。标识符用于访问对象，可以用作用域（scope）和链
接（linkage）描述标识符，标识符的作用域和链接表明了程序的哪些部分可
以使用它。不同的存储类别具有不同的存储期、作用域和链接。标识符可以
在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函
数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也
可以仅存在于它所在函数的执行期。对于并发编程，对象可以在特定线程的
执行期存在。可以通过函数调用的方式显式分配和释放内存。
我们先学习作用域、链接和存储期的含义，再介绍具体的存储类别。
12.1.1 作用域
859
作用域描述程序中可访问标识符的区域。一个C变量的作用域可以是块
作用域、函数作用域、函数原型作用域或文件作用域。到目前为止，本书程
序示例中使用的变量几乎都具有块作用域。块是用一对花括号括起来的代码
区域。例如，整个函数体是一个块，函数中的任意复合语句也是一个块。定
义在块中的变量具有块作用域（block scope），块作用域变量的可见范围是
从定义处到包含该定义的块的末尾。另外，虽然函数的形式参数声明在函数
的左花括号之前，但是它们也具有块作用域，属于函数体这个块。所以到目
前为止，我们使用的局部变量（包括函数的形式参数）都具有块作用域。因
此，下面代码中的变量 cleo和patrick都具有块作用域：
double blocky(double cleo)
{
double patrick = 0.0;
...
return patrick;
}
声明在内层块中的变量，其作用域仅局限于该声明所在的块：
double blocky(double cleo)
{
double patrick = 0.0;
int i;
for (i = 0; i 
int units = 0;    /* 该变量具有文件作用域 */
void critic(void);
int main(void)
{
...
}
void critic(void)
{
...
862
}
这里，变量units具有文件作用域，main()和critic()函数都可以使用它
（更准确地说，units具有外部链接文件作用域，稍后讲解）。由于这样的变
量可用于多个函数，所以文件作用域变量也称为全局变量（global
variable）。
注意 翻译单元和文件
你认为的多个文件在编译器中可能以一个文件出现。例如，通常在源代
码（.c扩展名）中包含一个或多个头文件（.h 扩展名）。头文件会依次包含
其他头文件，所以会包含多个单独的物理文件。但是，C预处理实际上是用
包含的头文件内容替换#include指令。所以，编译器源代码文件和所有的头
文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元
（translation unit）。描述一个具有文件作用域的变量时，它的实际可见范围
是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个
翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。
12.1.2 链接
接下来，我们介绍链接。C 变量有 3 种链接属性：外部链接、内部链接
或无链接。具有块作用域、函数作用域或函数原型作用域的变量都是无链接
变量。这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作
用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中
使用，内部链接变量只能在一个翻译单元中使用。
注意 正式和非正式术语
C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源
代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述
可延伸至其他翻译单元的作用域。但是，对程序员而言这些术语太长了。一
些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的
文件作用域”简称为“全局作用域”或“程序作用域”。
863
如何知道文件作用域变量是内部链接还是外部链接？可以查看外部定义
中是否使用了存储类别说明符static：
int giants = 5;       // 文件作用域，外部链接
static int dodgers = 3;   // 文件作用域，内部链接
int main()
{
...
}
...
该文件和同一程序的其他文件都可以使用变量giants。而变量dodgers属
文件私有，该文件中的任意函数都可使用它。
12.1.3 存储期
作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访
问的对象的生存期。C对象有4种存储期：静态存储期、线程存储期、自动
存储期、动态分配存储期。
如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作
用域变量具有静态存储期。注意，对于文件作用域变量，关键字 static表明
了其链接属性，而非存储期。以 
static声明的文件作用域变量具有内部链
接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态
存储期。
线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程
存储期的对象，从被声明时到线程结束一直存在。以关键字_Thread_local声
明一个对象时，每个线程都获得该变量的私有备份。
864
块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块
时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。
这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存
区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调
用函数的变量。
变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的
开始处到块的末尾。
我们到目前为止使用的局部变量都是自动类别。例如，在下面的代码
中，变量number和index在每次调用bore()函数时被创建，在离开函数时被销
毁：
void bore(int number)
{
int index;
for (index = 0; index < number; index++)
puts("They don't make them the way they used to.\n");
return 0;
}
然而，块作用域变量也能具有静态存储期。为了创建这样的变量，要把
变量声明在块中，且在声明前面加上关键字static：
void more(int number)
{
int index;
865
static int ct = 0;
...
return 0;
}
这里，变量ct储存在静态内存中，它从程序被载入到程序结束期间都存