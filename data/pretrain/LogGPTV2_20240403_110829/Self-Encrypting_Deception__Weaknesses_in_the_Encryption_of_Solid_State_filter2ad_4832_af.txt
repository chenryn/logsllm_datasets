tation of the cryptography, to keep avoiding these problems in
the future. These tests too should be independently assessed.
In general, we can ask ourselves what problem SEDs
are trying to address. SEDs do not offer any meaningful
mitigations in situations where software encryption falls short
(see Section III). However, as demonstrated,
in situations
where software encryption offers full data conﬁdentiality,
hardware encryption often does not. Hence, at best, the data
conﬁdentiality guarantees of SEDs are similar to that of
software encryption, and often much less. The traditional
advantage of SEDs was performance, but this is no longer
the case as the AES-NI extension on x86 CPUs has become
mainstream. Therefore,
the industry should reevaluate any
preference for hardware encryption, as software encryption
has the beneﬁt
its workings are easier to verify and
audit. This hold especially for open-source software solutions,
but also proprietary ones as reverse engineering software-only
solutions take less effort as opposed to reverse engineering the
works of SEDs. A start of this reevaluation has been made, as
since our public release Microsoft has made available a new
preview version (build 18317) of the next Windows 10 version
(19H1). In that version, the default behavior of BitLocker is
to not delegate (and trust) the encryption of data to the drives.
that
(cid:25)(cid:21)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:42:15 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] Statista.
(2018) Global market
suppliers.
412158/global-market-share-solid-state-drive-suppliers
[Online]. Available:
share
drive
https://www.statista.com/statistics/
solid
state
of
[2] J. Domburg, “Hard disk hacking,” 2013, see http://spritesmods.com/?art=
hddhack.
[3] J. Zaddach, A. Kurmus, D. Balzarotti, E.-O. Blass, A. Francillon,
T. Goodspeed, M. Gupta, and I. Koltsidas, “Implementation and im-
plications of a stealth hard-drive backdoor,” in Proceedings of the 29th
Annual Computer Security Applications Conference. ACM, 2013, pp.
279–288.
[4] T. Goodspeed, “Active disk antiforensics and hard disk backdoors,” in
Talk at 0x07 Sec-T Conference (video: https://www.youtube.com/watch?
v=8Zpb34Qf0NY), vol. 8, 2014.
[5] L. Cojocar, K. Razavi, and H. Bos, “Off-the-shelf embedded devices
as platforms for security research,” in Proceedings of
the 10th
European Workshop on Systems Security, ser. EuroSec’17. New
York, NY, USA: ACM, 2017, pp. 1:1–1:6.
[Online]. Available:
http://doi.acm.org/10.1145/3065913.3065919
[6] J. Horchert, J. Appelbaum, and C. Stöocker, “Shopping for spy gear:
catalog advertises NSA toolbox,” Der Spiegel, 2013.
[7] R. Verdult, “The (in) security of proprietary cryptography,” Ph.D.
dissertation, Radboud University, Nijmegen, 2015.
[8] J. Domburg
and Tweakers.net,
see
2007,
security,”
of
secustick-gives-false-sense-of-security.html.
“Secustick
sense
https://tweakers.net/reviews/683/
gives
false
[9] G. Alendal, C. Kison, and modg, “Got HW crypto? on the (in) security
of a Self-Encrypting Drive series.” IACR Cryptology ePrint Archive, vol.
2015, p. 1002, 2015.
[10] D. Boteanu and K. Fowler, “Bypassing self-encrypting drives (SED) in
enterprise environments,” in BlackHat Europe, 2015.
[11] C. Stevens, “AT Attachment 8-ATA/ATAPI Command Set – 4 (ACS-4),”
Working Draft, American National Standard, Revision 14, 2016. [On-
line]. Available: http://www.t13.org/documents/UploadedDocuments/
docs2016/di529r14-ATAATAPI_Command_Set_-_4.pdf
[12] Trusted Computing Group, “TCG storage security subsystem class: Opal
speciﬁcation version 2.01,” 2015.
[13] T. Müller, F. C. Freiling, and A. Dewald, “TRESOR runs encryption
securely outside RAM,” in USENIX Security Symposium, vol. 17, 2011.
[14] T. Müller, B. Taubmann, and F. C. Freiling, “Trevisor,” in International
Conference on Applied Cryptography and Network Security. Springer,
2012, pp. 66–83.
[15] T. Müller, T. Latzo, and F. C. Freiling, “Self-encrypting disks pose self-
decrypting risks,” in the 29th Chaos Communinication Congress, 2012,
pp. 1–10.
[16] K. Mowery, M. Wei, D. Kohlbrenner, H. Shacham, and S. Swanson,
“Welcome to the entropics: boot-time entropy in embedded devices,” in
Security and Privacy (SP), 2013 IEEE Symposium on.
IEEE, 2013, pp.
589–603.
[17] J. Wetzels and A. Abbasi, “Wheel of fortune: Analyzing embedded OS
random number generators,” 2016.
[18] “IEEE standard for cryptographic protection of data on block-oriented
storage devices,” IEEE Std 1619-2007, pp. c1–32, April 2008.
[19] P. Rogaway, “Efﬁcient
instantiations of tweakable blockciphers and
reﬁnements to modes OCB and PMAC,” in International Conference
on the Theory and Application of Cryptology and Information Security.
Springer, 2004, pp. 16–31.
[20] T. Ptacek and E. Ptacek, “You don’t want XTS,” 2014, see https:
//sockpuppet.org/blog/2014/04/30/you-dont-want-xts/.
[21] D. Clunie, R. Shroeppel, P. Rogaway, V. Bharadwaj, and N. Ferguson,
“Public comments on the XTS-AES mode,” Collected email comments
released by NIST, available from their web page, 2008.
[22] N. Ferguson, “AES-CBC+ Elephant diffuser: A disk encryption algo-
rithm for Windows Vista,” Tech. Rep., 2006.
[23] J. Grand, “JTAGulator: assisted discovery of on-chip debug interfaces,”
in 21st DefCon Conference, Las Vegas, 2013.
[24] D. Chen. (2015) Firmware deobfuscation utilities. [Online]. Available:
https://github.com/ddcc/drive_ﬁrmware
[26] Microsoft.
[25] P. Gühring, “The missing Samsung EVO 840 - 250 GB SSD re-
pair manual,” 2016-2018, see http://www2.futureware.at/~philipp/ssd/
TheMissingManual.pdf.
(2018) Guidance for conﬁguring BitLocker
to enforce
software encryption. [Online]. Available: https://portal.msrc.microsoft.
com/en-us/security-guidance/advisory/ADV180028
(2018) Consumer
regarding Samsung SSDs.
[Online]. Available: https://www.samsung.com/semiconductor/minisite/
ssd/support/consumer-notice/
notice
[27] Samsung.
[28] Trusted Computing Group, “TCG storage security subsystem class:
Opalite speciﬁcation version 1.00,” 2015.
(cid:25)(cid:22)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:42:15 UTC from IEEE Xplore.  Restrictions apply. 
Algorithm 1 ProtectPasswd
Require: abRdsKey, abDeviceKey, aabCredentialTable
Ensure: Credential szPasswd is stored in aabCredentialTable at dwSlotNo
procedure PROTECTPASSWD(szPasswd, bStoreRdsKey, dwSlotNo)
Security evaluation: We managed to identify several im-
plementation mistakes, two of which, depending on the cir-
cumstances, can be leveraged into full recovery of the data.
(cid:2) abPlaintext is a zero buffer
PSEUDOCODE OF VARIOUS ROUTINES IN THE CRUCIAL
APPENDIX C
MX300 FIRMWARE.
if bStoreRdsKey then
abPlaintext ← abRdsKey
else
abPlaintext ← [0x00 × 32]
abSalt ← RANDOM(32 bytes)
abKey ← PBKDF2(szPasswd, abSalt)
abCiphertext ← ENCRYPT(abKey, abPlaintext)
stProtectedPasswd ← (abSalt, abCiphertext)
abOutput ← ENCRYPT(abDeviceKey, stProtectedPasswd)
aabCredentialTable[dwSlotNo] ← abOutput
VENDOR COMMANDS AVAILABLE ON THE CRUCIAL
APPENDIX A
MX100 AND MX200
The Crucial MX100 and MX200 feature several vendor-
speciﬁc commands that allow engineers to diagnose the device.
The commands must be unlocked before they can be used. The
list of commands presented below is far from exhaustive.
Unlocking. Unlocking the vendor-speciﬁc features is done by
issuing a FDh (vendor-speciﬁc) ATA command, with feature
code 55h. Setting the LBA to 306775h, and the block count
to 65h will unlock the vendor-speciﬁc commands.
SPI ﬂash functions. Both the MX100 and the MX200 have a
NOR ﬂash connected through the SPI bus. It contains, among
other things, the drive’s capacity, serial number, error logs, and
boot loader (see Section VI-C). Vendor-speciﬁc ATA command
FAh, with feature code D2h reads a page from the SPI ﬂash
and returns the result. The LBA represents the page number
that is to be retrieved. Likewise, command FCh, feature E2h
erases a page. Command FBh, feature D2h writes data to the
SPI ﬂash.
The MX100 allows one to write
Arbitrary memory write.
arbitrary data to any desired address within the address space.
The opcode is FBh, feature code 23h. The command expects
a concatenated list of address-value tuples.
VENDOR COMMANDS AVAILABLE ON THE SAMSUNG
APPENDIX B
840EVO
The 840 EVO features several vendor-speciﬁc commands.
As is the case with the Crucial drives, these commands require
unlocking. Only a small subset of commands are analyzed,
since the vast majority are not security related.
Unlocking the vendor-speciﬁc features is done by issuing a
85h (vendor-speciﬁc) ATA command with feature code 46h.
The payload is a single block (512 bytes) with the last 16
bytes set to
C7D0B1B3C1BEC0CCB6AFB6AFBEEEBCAD
The crypto blob can be retrieved by issuing a 83h (vendor-
speciﬁc) ATA command, with feature code 12h. Likewise, the
crypto blob can be overwritten with command 83h, feature
code 13h.
in the credential
The ProtectPasswd function (Algorithm 1) takes a password
and stores it
table so that an incoming
password can be checked for validity at a later point in time.
The bStoreRdsKey parameter determines whether the stored
credential should encapsulate the RDS key. In that case, the
credential allows access to protected ranges (see Figure 2).
The function VerifyPasswd (Algorithm 2) is the inverse of
ProtectPasswd. It has two purposes: checking the validity of a
password, and, in case the bExtractRdsKey parameter is set,
using the password to decrypt the RDS key and copying it to
the global RDS key buffer, allowing other functions to use it.
Algorithm 2 VerifyPasswd
Require: abRdsKey, abDeviceKey, aabCredentialTable
Ensure: Verify szPasswd and set global RDS key if bExtractRdsKey = true
function VERIFYPASSWD(szPasswd, bExtractRdsKey, dwSlotNo)
abInput ← aabCredentialTable[dwSlotNo]
stProtectedPasswd ← DECRYPT(abDeviceKey, abInput)
if decrypt failed then
(abSalt, abCiphertext) ← stProtectedPasswd
abKey ← PBKDF2(szPasswd, abSalt)
abPlaintext ← DECRYPT(abKey, abCiphertext)
if decrypt failed then
return ERROR
if bExtractRdsKey then
return ERROR
abRdsKey ← abPlaintext
return SUCCESS
Furthermore, the UnwrapDek function (Algorithm 3) takes
an entry from the range key table, and decrypts it using either
the RDS key, or the device key (for protected and unprotected
ranges, respectively), as determined by the bIsProtectedRange
parameter. Obviously, for protected ranges, the RDS key must
be decrypted, prior to invoking UnwrapDek.
Algorithm 3 UnwrapDek
Require: abRdsKey, abDeviceKey, aabRangeKeyTable,
aabUnwrappedRangeKeyTable
Ensure: Range key dwRangeNo is unwrapped
function UNWRAPDEK(dwRangeNo, bIsProtectedRange)
if bIsProtectedRange then
abKey ← abRdsKey
abKey ← abDeviceKey
else
abCiphertext ← aabRangeKeyTable[dwSlotNo]
abPlaintext ← DECRYPT(abKey, abCiphertext)
if decrypt failed then
aabUnwrappedRangeKeyTable[dwSlotNo] ← abPlaintext
return SUCCESS
return ERROR
Finally, we implicitly deﬁne the functions WrapDek, Copy-
Credential, GenerateRandomDekAndWrap, and StoreCrypto-
ContextInSpiFlash as their functionality is clear from their
names.
(cid:25)(cid:23)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:42:15 UTC from IEEE Xplore.  Restrictions apply. 
EXECUTION TRACE CAPTURED ON A CRUCIAL MX300 DRIVE DURING THE BITLOCKER SET-UP PHASE.
APPENDIX D
(cid:2) szPasswd is zero buffer
VerifyPasswd(szPasswd="AEGIS_ACADIA_MSID_12456789012345", bExtractRdsKey=true, dwSlotNo=2)
VerifyPasswd(szPasswd="AEGIS_ACADIA_MSID_12456789012345", bExtractRdsKey=true, dwSlotNo=2)
CopyCredential(dwSourceSlot=2, dwDestinationSlot=10)
ProtectPasswd(szPasswd=[0x00 × 32], bStoreRdsKey=true, dwSlotNo=11)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=12)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=13)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=14)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=15)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=16)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=17)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=18)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=19)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=20)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=21)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=22)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=23)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=24)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=25)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=26)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=27)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=28)
CopyCredential(dwSourceSlot=11, dwDestinationSlot=29)
StoreCryptoContextInSpiFlash()
VerifyPasswd(szPasswd="AEGIS_ACADIA_MSID_12456789012345", bExtractRdsKey=true, dwSlotNo=2)
VerifyPasswd(szPasswd="AEGIS_ACADIA_MSID_12456789012345", bExtractRdsKey=true, dwSlotNo=10)
VerifyPasswd(szPasswd="AEGIS_ACADIA_MSID_12456789012345", bExtractRdsKey=true, dwSlotNo=2)
ProtectPasswd(szPasswd=«BitLocker SID password», bStoreRdsKey=true, dwSlotNo=2))
StoreCryptoContextInSpiFlash()
VerifyPasswd(szPasswd="AEGIS_ACADIA_MSID_12456789012345", bExtractRdsKey=true, dwSlotNo=10)
ProtectPasswd(szPasswd=«BitLocker SID password», bStoreRdsKey=true, dwSlotNo=10)
StoreCryptoContextInSpiFlash()
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
GenerateRandomDekAndWrap(dwRangeNo=1, bIsProtectedRange=false)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
StoreCryptoContextInSpiFlash()
UnwrapDek(dwRangeNo=1, bIsProtectedRange=false)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
UnwrapDek(dwRangeNo=1, bIsProtectedRange=false)
WrapDek(dwRangeNo=1, bIsProtectedRange=true)
VerifyPasswd(szPasswd=[0x00 × 32], bExtractRdsKey=true, dwSlotNo=15)
ProtectPasswd(szPasswd=«BitLocker user password», bStoreRdsKey=true, dwSlotNo=15)
StoreCryptoContextInSpiFlash()
VerifyPasswd(szPasswd=«BitLocker user password», bExtractRdsKey=true, dwSlotNo=15)
VerifyPasswd(szPasswd=«BitLocker user password», bExtractRdsKey=true, dwSlotNo=15)
(cid:25)(cid:24)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:42:15 UTC from IEEE Xplore.  Restrictions apply.