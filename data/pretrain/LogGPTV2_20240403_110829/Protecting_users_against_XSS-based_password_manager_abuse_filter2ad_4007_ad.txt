able to inject a new ﬁeld called query into the form. Once
the password manager has ﬁlled in the placeholder into the
password ﬁeld, the attacker’s code copies the value of that
ﬁeld into the newly added query ﬁeld. He then changes the
action of the form to the application’s search functionality.
If the password manager now replaced all occurrences of the
placeholder in the request, the query parameter would also
contain the clear-text password. Under the assumption that
a search page will in some manner reﬂect the search term
back to the user, the attacker could then extract the pass-
word from this response. Therefore, making sure that the
password manager only exchanges the correct ﬁeld is essen-
tial.
6.2 Implementation
To investigate the soundness of our proposal, we imple-
mented a proof-of-concept password manager. Since com-
pletely changing the implementation of one of the built-in
password managers in the modern browsers would have been
to complex, we opted to instead build an extension for Fire-
fox. The extension is built upon the original, built-in pass-
word manager which is used to only store the placeholder
values. The clear-text passwords in turn are stored in a
separate storage located inside the extension. For our pro-
totype, we did not implement any form of encryption for
these values, since securely storing the passwords inside the
browser is out of scope for this work.
Figure 2 shows how our approach works when a new user-
name and password combination is saved. First, the user
is prompted to have the login manager remember the re-
cently sent password. In the second step, once the user has
agreed to do so, the login manager stores the username and
password combination. Firefox provides all plugins with a
means of being notiﬁed when credentials are stored in the
password manager [20]. The notiﬁcation message contains
– along with the recently stored username and password –
the origin of the site the password was posted to as well as
the names for both the username and password ﬁeld in the
submitted form. Our extension saves all this information
in its own storage and replaces the password in the built-
Figure 2: Initial login and credential storing
in storage with a random placeholder value (nonce). This
placeholder value is subsequently also stored inside the ex-
tension’s database alongside the previously persisted data to
ensure that the matching credentials can be extracted later
on.
Figure 3 outlines how the placeholder is later restored in
a normal login. When opening the login page, the built-in
password manager inserts the username and the placeholder
into the form. Similar to the internal password manager,
the extension is notiﬁed of a password form being submit-
ted. [6] Subsequently, the next outgoing POST request is
scanned by our extension for the easily discernible place-
holder value. If the nonce is found, the extension searches
its own database for the corresponding entry. Next, the
entry’s origin is checked against the origin of the page the
data is being sent to. If the origins match, the placeholder
is replaced with the actual passwords adhering to the afore-
mentioned constraint that only the password ﬁeld (whose
name is stored in the extension’s data storage) should be
changed. On the lower half of the ﬁgure, this is shown. Al-
though the nonce is contained in the HTTP request, it is
not replaced with the actual secret data since the name of
the POST parameter does not match. Thus, the attacker
cannot utilize the search functionality to extract the secret
password data from our password manager.
We also evaluated the option of exchanging GET parame-
ters in a request. In our empirical study we found that none
of the sites use a form in combination with a GET request.
An attacker could however easily exchange the method of a
form from POST to GET. If our proposed password manager
would then exchange the nonce with the secret password, the
adversary could easily read the complete URL of the newly
loaded page and thus retrieve the password. Therefore, we
explicitly disable the replacement of our nonces in GET pa-
rameters and only exchange them for the real credentials in
POST requests.
6.3 Evaluation
In this section, we discuss both the security and the func-
tional evaluation of our approach, showing that it adds se-
curity while not causing incompatibility with existing appli-
cations.
6.3.1
After the password value has initially been stored by the
password manager, it is never again inserted into Web docu-
Security Evaluation
Our Extension Password Manager host=http://localhost,  user=user1,  pwd=secret host=http://localhost,  user=user1,  pwd=nonce 1 2 3 191Figure 3: Replacement of login credentials by our enhanced password manager
ments. Hence, it is kept out of reach of potentially malicious
JavaScript.
Furthermore, our implementation enforces strict matching
constraints, before the replacement process executes: Only
password nonces for which the combination of target origin
and password parameter name matches the recorded values
are substituted with the actual password value in the out-
going request. This requirement eﬀectively thwarts attack
attempts in which the adversary tries to leak the password
via tampering with the password ﬁeld’s form element in the
timespan between the autoﬁll process and the form submis-
sion. Thus, our proposed implementation of a secure pass-
word manager eﬀectively hinders an attacker who utilizes
XSS attacks against his victim.
However, the attacker model discussed by Gonzalez et
al. [9] – positioned at the network layer – could still be suc-
cessful if password data is transmitted in clear-text to the
server. In our study of the Alexa Top 4000 sites, we found
that 44,1% of the examined sites utilize HTTP instead of
HTTPS to transmit the credentials to the server. In these
cases, the network-based attacker could wait for the form
to be submitted and subsequently retrieve the secret login
data from the traﬃc capture. Nevertheless, this kind of at-
tack does not speciﬁcally target password managers and can
therefore not be fully prevented by a secure password man-
ager in any case.
6.3.2 Functional Evaluation
From the user’s point of view, nothing changes compared
to the behavior of the current generation of deployed pass-
word managers: After page load, the password ﬁeld is au-
tomatically ﬁlled with characters, which are presented to
the user with masquerading asterisks. After form submit,
the browser exchanges the password nonce with the actual
values, before it is sent to the server.
Our approach aims at only putting the real password of a
user in the outgoing request to the server and not into the
password ﬁeld. This however leads to potential problems
with Web applications that do some transformation on the
original ﬁeld’s value before submitting it. For instance, an
application might derive the hash sum of the user-provided
password on the client-side before submitting it.
In the evaluation of the top 4000 Alexa sites, we detected
325 JavaScript accesses to password data (see Sec. 5.2). We
then manually analyzed the snippets responsible for these
accesses and detected that a total 96 domains used client-
side functionality such as XmlHttpRequests to transmit the
password data to the server. Out of these 96 cases, 24 pages
transformed the provided password before forwarding it to
the server, whereas 23 employed hashing functions like MD5
and SHA1 and the remaining case encoded the password as
Base64. Of the remaining 72 pages that did not post the
form directly to server, only 6 pages employed HTTP GET
requests to transmit the credentials, whereas the rest used
HTTP POST in their XmlHttpRequests. Our proposed ap-
proach would obviously not work in these 30 cases, since our
extension neither exchanges passwords directly in the input
ﬁeld nor does it modify HTTP GET requests. However, the
current implementations of the password managers do not
support storing passwords that are not sent via submitting
HTML forms – thus our approach is in no way inferior to the
currently deployed concepts [6]. Also, if the built-in pass-
word manager stored these credentials, there is no way of
detecting whether access to a given password ﬁeld is done
by the legitimate page or is a Cross-Site Scripting attack.
Hence, we deliberately fail in the aforementioned scenario
by not replacing the nonce in the input ﬁeld with the real
password. Therefore, our approach is secure by default and
can also not be undermined by an unknowing user.
The purpose of the remaining 229 scripts was verify was
that certain criteria had been met in ﬁlling the user and
password ﬁeld, e.g. the username being an e-mail address
or the password consisting of at least a certain amount of
chars.
7. RELATED WORK
Most research in the area of password managers focussed
mainly on three diﬀerent aspects: generating pseudo-random
and unique passwords for each single Web application based
one some master secret [11, 25, 4], storing passwords in a se-
cure manner [31, 3, 14, 8] and protecting users from phishing
attacks [29, 30].
The problem of weak password manager implementations
with respect to their vulnerability towards Cross-Site Script-
ing attacks has been discussed by browser vendors since
2006 [23]. However, researchers did not re-evaluate possi-
bilities in terms of adopting new concepts to protect users
from these kinds of attacks. In a recent blog post, Ben Toews
again brought up the issue of password managers that were
prone to XSS attacks [28]. However, the question on how to
improve the security of password managers remained unan-
swered.
Furthermore, in 2013, Gonzalez et al. [9] discovered a re-
lated attack. They described a network-based attacker that
can inject code of his own choosing into any unencrypted
HTTP connection. To leverage this, they injected multiple
invisible frames into pages loaded by the victim and iterated
through the login pages of diﬀerent domains. They auto-
mated their attack using a self-developed tool called Lupin
and were able to extract 1000 passwords in 35 seconds from
a victim’s machine. They propose a ﬁrst set of countermea-
sures, which are either in line with the mitigation strategies
covered in Sec. 4, and thus, share the same drawbacks, or
POST /login.php Data: user=user1&pwd=nonce POST /login.php Data: user=user1&pwd=secret Our Extension POST /search.php Data: user=user1&query=nonce POST /search.php Data: user=user1&query=nonce 192are targeted at strict network layer security, which is not
applicable to our XSS attacker.
8. CONCLUSION
In this paper, we have demonstrated that current imple-
mentations of built-in password managers in browsers are
vulnerable to XSS attacks targeting the stored passwords.
We have identiﬁed the root cause of these problems, namely
the fact that password managers automatically ﬁll out pass-
word ﬁelds with the clear-text password which are subse-
quently accessibly by client-side code.
Our approach thwarts this class of attacks through keep-
ing the actual password value out of the reach of potentially
malicious JavaScript. It works by ﬁlling the password ﬁelds
with placeholder values which are only replaced later, once
the request is sent to the server. For robust protection, our
prototype enforces strict integrity constraint in respect to
the password form’s context and only exchanges the place-
holder for the credentials if the origins and names of both
login URL and saved password match.
Our solution robustly protects auto-saved passwords from
XSS-based theft attempts, and, in the majority of the ex-
amined cases, mitigates related, network-level attacks un-
covered by Gonzalez et al [9], while maintaining a high de-
gree of compatibility with the currently established behavior
of password managers and real-world practices in handling
password ﬁelds.
Acknowledgements
The authors would like to thank Eric Schmall and Armin
Stock for their work pertaining to the implementational parts
of this work as well as the anonymous reviewers for their
helpful comments. Martin Johns’ work was partially funded
by the EU projects WebSand (FP7-256964, http://websand.
eu) and STREWS (FP7-318097, http://strews.eu). The
support is gratefully acknowledged.
9. REFERENCES
[1] Alexa Internet, Inc. Alexa Top 500 Global Sites.
Website, http://www.alexa.com/, accessed in March
2010.
[2] Barth, A. The web origin concept, November 2009.
[3] Bojinov, H., Bursztein, E., Boyen, X., and
Boneh, D. Kamouﬂage: Loss-resistant password
management. In Computer Security–ESORICS 2010.
Springer, 2010, pp. 286–302.
[4] Chiasson, S., van Oorschot, P. C., and Biddle,
R. A usability study and critique of two password
managers. In 15th USENIX Security Symposium
(2006), pp. 1–16.
[5] Dierks, T., and Allen, C. The TLS Protocol
Version 1.0. RFC 2246,
http://www.ietf.org/rfc/rfc2246.txt, January
1999.
[6] Dolske, J. On ﬁrefox’s password manager. [online]
https://blog.mozilla.org/dolske/2013/08/20/
on-firefoxs-password-manager/, August 2013.
[7] Franks, J., Hallam-Baker, P., Hostetler, J.,
Lawrence, S., Leach, P., Luotonen, A., and
Stewart, L. HTTP Authentication: Basic and Digest
Access Authentication. RFC 2617,
http://www.ietf.org/rfc/rfc2617.txt, June 1999.
[8] Gasti, P., and Rasmussen, K. B. On the security of
password manager database formats. In Computer
Security–ESORICS 2012. Springer, 2012, pp. 770–787.
[9] Gonzalez, R., Chen, E. Y., and Jackson, C.
Automated password extraction attack on modern
password managers. arXiv preprint arXiv:1309.1416
(2013).
[10] Google Developers. Chrome Extensions -
Developer’s Guide. [online], http://developer.
chrome.com/extensions/devguide.html, last access
06/05/13, 2012.
[11] Halderman, J. A., Waters, B., and Felten,
E. W. A convenient method for securely managing
passwords. In Proceedings of the 14th international
conference on World Wide Web (2005), ACM,
pp. 471–479.
[12] Hickson, I. Web forms 2.0, Apri 2005.
[13] Ives, B., Walsh, K. R., and Schneider, H. The
domino eﬀect of password reuse. Communications of
the ACM 47, 4 (2004), 75–78.
[14] Karole, A., Saxena, N., and Christin, N. A
comparative usability evaluation of traditional
password managers. In Information Security and
Cryptology-ICISC 2010. Springer, 2011, pp. 233–251.
[15] Klein, A. Dom based cross site scripting or xss of the
third kind. Web Application Security Consortium,
Articles 4 (2005).
[16] Lekies, S., Stock, B., and Johns, M. 25 million
ﬂows later: large-scale detection of dom-based xss. In
Proceedings of the 2013 ACM SIGSAC conference on
Computer & communications security (2013), ACM,
pp. 1193–1204.
[17] Magazinius, J., Phung, P. H., and Sands, D. Safe
wrappers and sane policies for self protecting
JavaScript. In The 15th Nordic Conference in Secure
IT Systems (October 2010), T. Aura, Ed., LNCS,
Springer Verlag. (Selected papers from AppSec 2010).
[18] Mazurek, M. L., Komanduri, S., Vidas, T.,
Bauer, L., Christin, N., Cranor, L. F., Kelley,
P. G., Shay, R., and Ur, B. Measuring password
guessability for an entire university. In Proceedings of
the 2013 ACM SIGSAC conference on Computer &
communications security (2013), ACM, pp. 173–186.
[19] Microsoft. Ie8 security part vii: Clickjacking
defenses, 2009.
[20] Mozilla. Firefox Add-On SDK - Passwords.
[21] Mozilla Developer Network. How to Turn Oﬀ
Form Autocompletion. [online],
https://developer.mozilla.org/en-US/docs/
Mozilla/How_to_Turn_Off_Form_Autocompletion,
May 2013.
[22] Mozilla Developer Network.
Object.deﬁneProperty(). [online],
https://developer.mozilla.org/en-US/docs/Web/
JavaScript/Reference/Global_Objects/Object/
defineProperty, November 2013.
[23] O’Shannessy, P. Bug 359675 - provide an option to
manually ﬁll forms and log in.
[24] OWASP. Cross-site scripting (xss), September 2013.
[25] Ross, B., Jackson, C., Miyake, N., Boneh, D.,
and Mitchell, J. C. Stronger password
193authentication using browser extensions. In
Proceedings of the 14th Usenix Security Symposium
(2005), vol. 1998.
[26] Rydstedt, G., Bursztein, E., Boneh, D., and
Jackson, C. Busting Frame Busting: a Study of
Clickjacking Vulnerabilities on Popular Sites. In Web
2.0 Security and Privacy (W2SP 2010) (2010).
[27] Security, W. Website security statistics report, May
2013.
[28] Toews, B. Abusing password managers with xss.
online, 04 2012.
[29] Wu, M., Miller, R. C., and Little, G. Web
wallet: preventing phishing attacks by revealing user
intentions. In Proceedings of the second symposium on
Usable privacy and security (2006), ACM,
pp. 102–113.
[30] Ye, Z. E., Smith, S., and Anthony, D. Trusted
paths for browsers. ACM Transactions on Information
and System Security (TISSEC) 8, 2 (2005), 153–186.
[31] Zhao, R., and Yue, C. All your browser-saved
passwords could belong to us: A security analysis and
a cloud-based new design. In Proceedings of the third
ACM conference on Data and application security and
privacy (2013), ACM, pp. 333–340.
194