title:AUDACIOUS: User-Driven Access Control with Unmodified Operating
Systems
author:Talia Ringer and
Dan Grossman and
Franziska Roesner
AUDACIOUS: User-Driven Access Control with
Unmodiﬁed Operating Systems
Talia Ringer
Dan Grossman
Franziska Roesner
University of Washington
Seattle, WA, USA
{tringer,djg,franzi}@cs.washington.edu
ABSTRACT
User-driven access control improves the coarse-grained ac-
cess control of current operating systems (particularly in
the mobile space) that provide only all-or-nothing access to
a resource such as the camera or the current location. By
granting appropriate permissions only in response to explicit
user actions (for example, pressing a camera button), user-
driven access control better aligns application actions with
user expectations. Prior work on user-driven access con-
trol has relied in essential ways on operating system (OS)
modiﬁcations to provide applications with uncompromisable
access control gadgets, distinguished user interface (UI) ele-
ments that can grant access permissions.
This work presents a design, implementation, and evalu-
ation of user-driven access control that works with no OS
modiﬁcations, thus making deployability and incremental
adoption of the model more feasible. We develop (1) a user-
level trusted library for access control gadgets, (2) static
analyses to prevent malicious creation of UI events,
ille-
gal ﬂows of sensitive information, and circumvention of our
library, and (3) dynamic analyses to ensure users are not
tricked into granting permissions. In addition to providing
the original user-driven access control guarantees, we use
static information ﬂow to limit where results derived from
sensitive sources may ﬂow in an application.
Our implementation targets Android applications. We
port open-source applications that need interesting resource
permissions to use our system. We determine in what ways
user-driven access control in general and our implementa-
tion in particular are good matches for real applications.
We demonstrate that our system is secure against a variety
of attacks that malware on Android could otherwise mount.
1.
INTRODUCTION
Modern operating systems (such as mobile platforms) iso-
late applications and limit their privileges. Mobile platforms
do not let applications access user resources — such as the
camera or location — unless the user grants those permis-
sions to the application. Despite this, applications can still
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978344
Figure 1: UI elements in applications that, when
pressed, cause the application to access sensitive re-
sources. Clockwise from top left: Location in Google
Maps, ﬁle system in Gmail, camera and microphone
in WhatsApp, microphone in Google Search. Mod-
ern OSes do not enforce that resources are accessed
only through these elements.
steal data or take actions without the user’s intention or
even knowledge. For example, the FTC recently took action
against a ﬂashlight application for leaking user location to
advertisers [6], and Android malware is known to covertly
send costly premium SMS messages [35].
Mobile platforms typically grant permissions through install-
time manifests or runtime prompts. These access control
models are problematic: Users ﬁnd them diﬃcult to un-
derstand, and they allow application behaviors that violate
user expectations [4, 8, 23, 30]. Prior work introduces user-
driven access control [23] to improve these models. In user-
driven access control, the system extracts permissions infor-
mation from the user’s interactions. Access control gadgets
(ACGs) [23] are one way of realizing user-driven access con-
trol. ACGs are special user interface (UI) elements that let
applications access sensitive resources only when the user
naturally interacts with that portion of the application’s UI.
Figure 1 shows examples of ACG-like buttons.
User-driven access control is not on a clear path to reach-
ing users. Prior work instantiating ACGs [22, 23] modiﬁes
the target OS (Android in the former [22] and ServiceOS [27]
in the latter [23]). Changing the OS poses serious deploy-
ability challenges.
It requires the companies that develop
these OSes to make supporting ACGs a priority. Such a
drastic change requires signiﬁcant development eﬀort and
impedes backwards compatibility for existing applications.
Furthermore, third-party devices often use old OS versions,
so there is a long delay before changes reach users [13]. Re-
cent data from the Google Play Store shows that 92.5% of
current Android devices run old API versions [1].
Our work makes user-driven access control practical and
immediately deployable. We present a design, implementa-
tion, and evaluation of user-driven access control that works
with no operating system modiﬁcations. Our design com-
bines a secure library with static and dynamic analyses to
ensure that applications can access sensitive resources only
through distinguished UI elements.
We provide the same guarantees as the original user-driven
access control design [23]: The application cannot access a
diﬀerent resource; the application also cannot access the
resource at a diﬀerent time.1 We move beyond the original
design to provide an additional guarantee: The application
cannot use the resource for a diﬀerent purpose. Consider
a simple camera application: The user expects it to access
just the camera, just when the user presses the camera but-
ton, and just to save the photo (not to send it over the
network). We enforce this without modifying the OS.
In summary, we contribute the following:
1. We enable user-driven access control in entirely un-
modiﬁed operating systems by combining a secure li-
brary design with static and dynamic analyses.
2. We instantiate this design in a concrete implementa-
tion for Android, which we call AUDACIOUS (An-
droid User-Driven Access Control in Only User Space).
3. We integrate AUDACIOUS into real applications and
evaluate how well user-driven access control ﬁts appli-
cations in practice.
4. We evaluate the beneﬁts of an approach that requires
no OS changes and identify key areas where even lim-
ited OS support would be beneﬁcial.
2. CONTEXT
This work targets modern operating systems. These OSes
isolate applications and grant them limited permissions. We
assume a permission model analogous to the latest Android
(API level 23): The OS automatically grants “normal” per-
missions (for example, network access) at install-time.
It
grants “dangerous” permissions (for example, the camera)
through a prompt to the user at the time of initial use. Once
the OS grants permissions, it never revokes them unless the
user explicitly revokes them, and it allows the application to
use the resources however it wishes. Though we focus our
implementation eﬀorts on Android, the broader concepts ap-
ply to any modern OS.
2.1 Goals
We aim to support user-driven access control though ac-
cess control gadgets. Building on the work that introduced
ACGs [23], we maintain the ﬁrst goal:
Goal 1: User-Driven Access Control. Our design should
ensure that applications can access sensitive resources only
when the user interacts with the corresponding ACG in that
application’s UI. It should guarantee this even in the face of
malicious applications that attempt to circumvent the user
or trick the user into interacting with ACGs.
We introduce three additional goals:
Goal 2: Unmodiﬁed Operating System. Our design
should not make any modiﬁcations to the OS.
1The original design also guarantees that a diﬀerent ap-
plication cannot access the resource. We assume an OS
that isolates applications, so this is inherently true.
Goal 3: Regulate Resource Use, not Just Access. In
the original ACG design, once an application has access to
a resource, it may use the resource however it wants. For
example, an application may use the user’s location both to
map the user’s run (the expected use) and to send to an
advertising server (the unexpected use). Our design should
provide guarantees about the ﬂow of resources.
Goal 4: Permission Model Flexibility. User-driven ac-
cess control is not well-suited for all application scenarios [7].
Some applications may require the ability to access sensi-
tive resources in the background without explicit user in-
teraction. These applications are not necessarily malicious.
Consider a calendar application that stays in sync with an
online calendar. This application may wish to communicate
silently with the calendar over the internet rather than ex-
plicitly ask the user to sync the calendar. Our design should
allow these applications to use alternative permission models
for some of their functionalities.
2.2 Threat Model
We deﬁne our system as sound if it guarantees for every
application that every sensitive resource is accessed as a re-
sult of a legitimate user interaction with the expected UI for
the ACG and used only as permitted. That is, the applica-
tion does not access a diﬀerent resource, access the resource
at a diﬀerent time, or use the resource for a diﬀerent pur-
pose. We pursue this in the context of the following threat
model.
We assume that the OS is trustworthy and uncompro-
mised. We do not modify the OS; instead, we implement a
secure library. We assume that our library is implemented
correctly. We assume that the static analysis tools and their
outputs are trusted. For the sake of simplicity, we accom-
plish this by adopting the application store model: Users
download applications from an application store and the ap-
plication store runs our analysis tools prior to approval.
Our adversary is a skilled application developer who aims
to improperly access sensitive resources such as the camera
or location. That is, he attempts to access resources in a
way that circumvents the ACG-based access restrictions. He
may do so by misusing the trusted library, evading analysis
tools, misleading the user, or bypassing the trusted library.
Our design and implementation assume all code in the ap-
plication is well-typed Java (we do not support native code).
We consider the following classes of attacks out of scope:
phishing-style attacks (in which users misidentify applica-
tions) and side-channel attacks.
3. TECHNIQUES FOR SECURING ACGS
This section describes our high-level design for securely
supporting user-driven access control without OS support.
Our design (summarized in Table 1) combines a secure li-
brary and program analyses. Applications include our li-
brary. In our library, ACGs encapsulate the details of both
resource APIs and the UI elements through which users
grant permissions to access resources. Our library prevents
applications from modifying the ACG UI after it is created
and from modifying the ACG validation logic. The library
and program analyses together ensure that resource access
is authentic (intended by the user) using the techniques we
introduce in this section. These techniques occur in three
conceptual phases:
Goal
Developer cannot modify the ACG
Developer can easily include and deploy ACGs
Technique
Library design
Library design
Events are authentic
Static event analysis
Resources, unless speciﬁed, are accessed through ACGs
Static information ﬂow analysis
Resources, once accessed, are used as expected
Static information ﬂow analysis
UI does not deceive the user
Dynamic bitmap check
User has enough time to perceive the valid UI
Dynamic bitmap check at random intervals
Sections
§3 and §4.2
§3 and §4.2
§3.1 and §4.3
§3.3 and §4.5
§3.3 and §4.5
§3.2 and §4.4
§3.2.3 and §4.4
Table 1: ACG design overview.
1. Event Flow
2. UI Context
User → UIseen
The user (not the application) interacts with the UI.
UIseen (cid:39) UIACG
The UI does not trick the user into interacting with it.
∗→ . . .
The application accesses the resource through the ACG
and uses it appropriately.
UIACG → ACG
3. Resource Flow
The library combined with these checks form a sound sys-
tem: An application that passes all three of these checks
must use the resource in a way that is consistent with user
expectations. Check (1) guarantees that the user genuinely
interacts with the ACG UI. Check (2) guarantees that this
interaction is deliberate, and that this UI does not mislead
the user about the resource that the ACG guards (diﬀerent
resource). Finally, check (3) guarantees that the application
does not access the resource when the user does not inter-
act with the ACG (diﬀerent time) or use the resource in an
unexpected way (diﬀerent purpose).
3.1 Event Flow: User → UIseen
If the application, not the user, triggers the UI events
that access the ACG, then the application impersonates the
user. This allows the application to perform arbitrary ac-
tions. The ﬂow from the user to the UI must be authentic.
Attack. Eve is developing an evil camera application that
secretly takes pictures. She writes code that clicks on the
camera ACG button automatically. This is direct event
forgery: The application creates fake user events.
Eve realizes that this attack may be easy to catch. She
disguises the events to make them appear authentic. She
adds a misleading button to her application. Whenever the
user clicks on this button, she intercepts the event and passes
it to the camera ACG. This is indirect event forgery: The
application uses an authentic event to trigger a forged event.
Defense. In both attacks, the application interferes with
the ﬂow of events from the user to the ACG UI. To prevent
these attacks, we must ensure that events ﬂow from the user
to the ACG UI without any application interference. We
can accomplish this through a taint analysis. Taint analysis
tracks the ﬂow of data to some sensitive sink and marks
anything which passes through a certain source as tainted.
In our case, the sink is the ACG UI code and the source is
the application code. That is, we consider events tainted if
they pass through application code on the way to an ACG.
More simply and conservatively, we can prohibit appli-
cations from constructing and modifying events at all. We
suspect the choice of which approach to take should depend
on how often benign applications create and modify events.
Time of Defense. We accomplish the event analysis stat-
ically. A dynamic approach may incur unnecessary perfor-
mance overhead since it must occur for every event. This
is especially pronounced without OS support; the analysis
must determine if an event is tainted rather than rely on an
OS-native ﬂag. Since we have enough information for either
the conservative check or the taint analysis at compile-time,