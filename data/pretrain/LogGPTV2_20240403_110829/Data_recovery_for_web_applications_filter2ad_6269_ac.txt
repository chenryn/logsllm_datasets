parameters. 
but without 
themselves. 
For example, 
requiring 
available 
in request 
code in our monitor 
is typ­
3.5 Recovery 
4 Evaluation 
We evaluate 
our system in terms of how well it helps re­
cover from data corruption 
web applications. 
and space overheads. 
configured 
For our experiments, 
we used MySQL 
with its transactional 
storage 
engine (InnoDB). 
caused by bugs found in popular 
We also measure our system's performance 
component 
provides 
These tools provide 
tools that simplify 
the 
information 
(e.g., 
time 
generated 
tables, 
pages), 
that affected 
specific 
requests 
that are the root cause of the 
point for the analysis 
as the starting 
the root cause can be determined 
com­
by 
The recovery 
process. 
the user identify 
and serving 
recovery 
line of requests 
helping 
failure, 
ponent. For example, 
reverting 
istrator 
requests 
determines 
After the analysis 
the recovery 
using binary-search 
which request 
component 
component 
caused the corruption. 
generates 
the set of tainted 
uses the information 
[36], until the admin­
in the 
requests, 
4.1 Dependency Policies 
The aim of our analysis 
tools is to provide 
sufficient 
data corruption. 
dependency 
for different 
in­
To 
to the administrator 
to identify 
described 
formation 
this end, our tools provide 
policies 
ery accuracy 
1) Request-level 
(request-row): 
of these policies. 
dependency 
support 
This policy is the most conservative 
depen-
with row-level 
tainting 
below. Our evaluation 
compares 
the recov­
978-1-4244-7501-8/10/$26.00 
©2010 IEEE 
85 
DSN 20lO: Akku & Goel 
20lO IEEEIIFIP International 
Conference 
on Dependable Systems 
& Networks (DSN) 
of whether tainted 
and there was no easy way to restore 
it (except 
It assumes that a request 
is tainted 
if it reads 
row. All further 
database 
regardless 
is used to update the database. 
updates 
by the 
dependency 
with row-level 
tainting 
data flow 
This policy takes application-level 
the dependency 
using a 
that are initialized 
when generating 
all variables 
row are marked tainted. 
The taint is propagated 
graph. 
When a query with tainted 
values 
is saved in the database 
at a 
across requests. 
with row-level 
tainting 
This policy implements 
previously 
pro­
taints when 
methods [19]. It propagates 
rows and update other rows. Since this 
such 
application-level 
dependencies, 
between the queries 
of a request, 
it may fail 
all the effects of the corruption. 
Also, the recovery 
at the query level rather than the request 
the request. 
the taint information 
taints 
dependency 
database 
preserving 
are marked as tainted, 
dency policy. 
a tainted 
request 
information 
2) Program-level 
(program-row): 
into consideration 
During a request, 
tainted 
throughout 
is executed, 
row granularity 
3) Database-level 
(database-row): 
posed recovery 
queries 
policy does not consider 
as dependencies 
to identify 
reverts 
level, 
4) Program-level 
(program-field): 
taints 
are stored in the database 
also allows us to take advantage 
5) Database-level 
dependency 
(database-field): 
taints 
are stored in the database 
dependency 
operations 
read tainted 
resulting 
probably 
in application-level 
inconsistencies. 
with field-level 
tainting 
This policy is similar 
to 2), except that 
which 
at  a field granularity, 
of blind writes. 
with field-level 
tainting 
This policy is similar 
to 3), except that 
at a field granularity. 
these bugs as follows: 
We investigated 
bug 
1) data was 
and selected 
Drupal and Gallery2. 
ing Wordpress, 
repositories 
corrupted/lost 
using backups which may lose valid data), 
related 
to the application-logic 
ware (e.g., 
We describe 
scenarios, 
covery system performed. 
has identified 
Section 
3.5, and thus, the initially 
PHP, MySQL). 
the correct 
recovery 
actions 
and not the underlying 
2) the bugs were 
soft­
these bugs, failure 
and report how our re­
the root cause of the corruption 
request 
is known. 
recovery actions 
tainted 
we define correct 
as explained 
in 
to 
For our evaluation, 
We assume that the administrator 
inconsistencies 
that break application 
whether recovery 
operations 
to measure recovery 
corruption 
and its effects, 
state and minimize 
the 
we determine 
that will remove data 
into a consistent 
lost. We use three metrics 
be the actions 
bring the application 
amount of data 
accuracy. 
First, 
cause application-level 
functionality. 
requests 
lated to the corruption 
ery. Third, we measure false negatives, 
that are not marked tainted, 
verted. 
tion after recovery, 
These will cause corruption 
that are marked tainted 
possibly 
causing 
Second, we measure false positives, 
which are 
even though they are unre­
and will cause data loss during recov­
to linger in the applica­
in the future. 
problems 
but whose effects should be re­
which are requests 
4.2.1 Results 
rows or even fields, to stop taint 
needs to undo to correctly  recover 
more accurately. 
An administrator 
Our analysis 
tools can also incorporate 
administrator 
about the application 
and help her determine 
the 
of data corruption 
columns, 
tables, 
at the database 
knowledge 
effects 
can whitelist 
propagation 
cient information 
application 
We used this approach 
layers, 
about taint propagation, 
tier. Our replay logs collect 
and 
at the database 
suffi­
which is useful for generating 
to create whitelists 
whitelists. 
for our evaluation. 
profiler 
detecting 
We have also implemented 
a request 
INSERT), their order, and the database 
application-level 
a post or updating 
semantics, 
such as 
a user. The 
issued 
items (i.e., 
The profiler 
types based on the queries 
ta­
generates 
a list of 
with heavily  accessed 
is that these items may 
The intuition 
but the frequent requests 
data items suit­
taint propagation, 
request 
identifies 
with different 
they accessed. 
types  together 
requests 
adding a comment,  editing 
profiler 
(e.g., 
bles, columns) 
request 
able for whitelisting. 
cause significant 
and accesses 
the administrator 
ignores 
dencies, 
of how the corruption 
whitelists 
are unlikely 
to be a cause of corruption. 
engine 
these items, the tainting 
generating 
a new set of depen­
Once 
them during replay, 
thus giving the administrator 
may have propagated. 
a better understanding 
tainted 
analysis 
The next column shows the dependency 
of various 
the results 
analysis. 
dependency 
All bugs had one initial 
data and each replay starts 
to undo" column shows the number of 
The "requests 
the administrator 
in Table 2 and Table 3. In Table 2, the second col­
we had to replay for 
that 
request 
with one initially 
We summarize 
policies 
umn shows the total number of requests 
the dependency 
corrupted 
request. 
requests 
from data corruption. 
policy used; 'none' indicating 
tion is considered 
accuracy 
tive requests. 
whitelisting. 
level dependency 
create dependencies 
terms of queries. 
that are encountered 
in Table 2 did not have any inconsistencies. 
for undo. The last two columns present 
the 
and nega­
Since database-level 
all the numbers are in 
in terms of false positive 
numbers are without 
The false positive 
In Table 3, we present 
after undoing these queries. 
that no dependency 
across queries, 
of the policies 
policies. 
the results 
and with 
of database­
policies 
only 
informa­
The policies 
Many bugs we investigated 
did not corrupt 
data after the 
and thus the 'none' policy (no dependency 
works well. One bug in Drupal created 
dependen­
request 
initial 
analysis) 
cies, and hence false negatives 
considered. 
a corruption 
analysis 
provides 
Note that we do not know beforehand 
will create dependencies, 
and thus dependency 
when dependencies 
are not 
whether 
useful information 
during recovery. 
Table 2 shows that the request-level 
dependency 
policies 
4.2 Recovery Accuracy 
We evaluate 
the accuracy 
of our dependency 
triggering 
five real bugs in popular 
web applications, 
by 
policies 
includ-
suffer from high false positive 
that the database-level 
and inconsistencies. 
These results 
policies 
rates, while Table 3 shows 
can have many false negatives 
show that web applications 
The last column shows the inconsistencies 
978-1-4244-7501-8/10/$26.00 
©20lO IEEE 
86 
DSN 20lO: Akku & Goel 
2010 IEEEIIFIP International 
Conference 
on Dependable Systems 
& Networks (DSN) 
Table 2. Recovery accuracy for request-level 
tives column shows numbers without and with table whitelisting, 
and program-level 
respectively. 
dependency policies. 
The false posi­
Case 
Total Number of Requests Requests to Undo  Dep. Policy False Positives False Negatives 
Wordpress 
-
109 
link category 
rename 
Drupal-
118 
lost voting information 
Drupal-
lost comments 
117 
Gallery2 
-
91 
removing 
permissions 
Gallery2 
-
resizing 
images 
151 
1 
7 
1 
1 
1 
none 
0 
request-row 60 
program-row 8 
program-field  6 
0 
none 
request-row 111/100 
program-row 95/89 
program-field  89/0 
none 
0 
request-row 116/102 
program-row 100/93 
program-field  95/0 
none 
0 
request-row 90/13 
program-row 88/11 
program-field  82/10 
none 
0 
request-row 148/0 
program-row 139/0 
program-field  119/0 
0 
0 
0 
0 
6 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
Table 3. Recovery accuracy of database-level 
dependency policies. 
All numbers indicate queries. 
Queries to Undo  Dep. Policy False Positives False Negatives Inconsistencies 
after Undo 
Case 
-
Wordpress 
23 
link category 
rename 
Drupal -lost vo-
ting information 
38 
Drupal-
24 
lost comments 
Gallery2 
-
9 
removing 
permissions 
Gallery2 
-
17 
resizing 
images 
database-row 
0 
database-field 
0 
86 
database-row 
database-field 
0 
database-row 
database-field 
0 
97 
database-row 
database-field 
9 
database-row 
database-field 
110 
20 
116 
15 
21 
16 
18 
0 
0 
0 
0 
0 
0 
The count value does not match 
the actual number of links. 
The polLvotes 
has duplicate 
table 
entries. 
none 
The global sequence 
id has 
an old value breaking 
future inserts 
requiring 
a new id. 
atomically, 
and thus re­
4.2.2 Wordpress: 
Link Category 
Rename 
generally 
expect that requests 
covery should be performed 
mize inconsistencies in 
also shows that the program-field 
least number of false positives 
execute 
at a request 
the application 
dependency 
policy has the 
and no false negatives. 
to mini­
granularity 
after recovery. 
Table 2 
Although 
database-level 
policies 
can cause application­
they tend to have fewer false positives 
level inconsistency, 
than the others. 
puts of the database 
recovery 
policies 
gram policy replay fails (e.g., 
actions 
do not require 
Thus, an administrator 
can compare the out­
and program policies 
more accurately 
and rapidly. 
to derive the correct 
The request 
replay and can be useful if the pro­
incomplete 
implementation). 
Below, we describe 
one bug for each application 
in more 
Wordpress 
to create content 
egories 
is a popular 
(e.g., 
to group and present 
blogging 
posts, links) 
and associate 
it in a more organized 
way. 
application 
that allows users 
it with cat­
category, 
has some links associ­
An administrator 
already 
caL1. To edit a category's 
Scenario: 
ated with a certain 
name, she has to click on it. A bug [14] allows her to rename 
ca Ll to an empty string. 
this  category 
by selecting 
associated 
caL2 }, {caL2,  caL3 }) and changes some settings. 
Correct recovery 
Undo the rename operation. 
and others (e.g., {old_caLl, 
with this category 
She can still associate 
She adds new links 
its checkbox. 
actions: 
links with 
the results 
an overview 
For each case, we provide 
detail. 
tion, background  information 
explain 
show that our approach 
for data recovery, 
bugs can be complex and it is hard to know what was cor­
rupted without 
of each dependency 
is essential 
dependency 
analysis. 
for the corresponding 
policy. 
Background: 
gories) 
separate 
Another table stores 
the terms (i.e., 
this table, 
These results 
of the applica­
because 
bug and 
tables (i.e., 
Wordpress 
maintains 
links, terms (i.e., 
cate­
to posts or links) in 
and their types (i.e., 
belonging 
links, terms, term_taxonomy). 
the relationships 
between the content 
and 
term_relationships). After querying 
category 
the number of links belonging 
to a certain 
978-1-4244-7501-8/10/$26.00 
©201O IEEE 
87 
DSN 2010: Akku & Goel 
20lO IEEEIIFIP International 
Conference 
on Dependable Systems 
& Networks (DSN) 
The request-row 
a page. 
policy marks many requests 
of an actively  shared  table 
is stored in the count column in the term_taxonomy ta­
ble. This field is used for fast access when generating 
Results: 
as 
falsely  dependent  because 
options). It does not consider 
quest reads from the above mentioned tables 
the database, 
updates 
this table, 
is used to update 
the request 
Since all requests 
a row in the options table. 
to many false positives. 
it conservatively 
that 
query 
whether tainted 
they get tainted 
leading 
instead 
(e.g., 
taints 
data a re­
recovery 
correct 
for this case because of the small number of tainted 
action. 
We did not have to use whitelisting 
requests. 
4.2.3 Drupal: Lost Voting Information 
The updated  poll 
a poll for registered 
A bug [7] causes the information 
fixes 
creates 
asserts 
who can vote 
because the sum 
repeat votes. This 
of who has voted. 
only registered 
an inconsistency 
An administrator 
A user can only vote once and 
to create a poll with multiple 
via a module. One can control 
in the application, 
than the number of users. 
users). 
this by keeping track 
Drupal allows an administrator 
choice options 
(e.g., 
the application 
Scenario: 
users. After some users have voted, the administrator 
a typo in the poll contents. 
about who has voted to be lost, allowing 
creates 
of votes becomes greater 
Correct recovery 
restore 
Background: Drupal maintains 
ses s ions table and retrieves 
quest to obtain the associated 
The table is updated with a timestamp 
at the end of each request. 
the choices, 
whereas the polLvotes table tracks who has voted. 
table, 
Results: 
policy marked all requests 
tainted  because 
of the shared  session  data. 
is put to the front page. Since every session  starts 
the front page, the taint is spread between different 
of each re­
user's id for permission 
and other related 
data 
the text of 
actions: 
Determine 
about who has voted. 
number of votes) is saved in the polLchoices 
The request-row 
it at the beginning 
session data in the 
The poll content 
information 
the repeat votes and 
checks. 
(e.g., 
as 
requesting 
users. 
that read and use 
users vote on the 
many false pos­
policy 
get tainted, 