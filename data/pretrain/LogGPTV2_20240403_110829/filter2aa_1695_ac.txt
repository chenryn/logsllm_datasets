  spray	
a4acking();	
  //	
  trigger	
  vulnerability	
  to	
  overwrite	
  vector	
  length	
if	
  (	
  !ﬁndCorruptVector()	
  )	
  {	
  return	
  (false);	
};	
buildRopAndShellcode()	
exec(); 
A	
  real	
  example	
  :	
  CVE-­‐2015-­‐3090 
•  For	
  example,	
  we	
  want	
  to	
  get	
  the	
  ROP	
  gagdets	
and	
  shellcode	
  used	
  by	
  this	
  exploit.	
•  Uses	
  DbgFlashVul	
  can	
  easily	
  do	
  this.	
A	
  real	
  example	
  :	
  CVE-­‐2015-­‐3090 
•  Almost	
  every	
  ﬂash	
  exploit	
  using	
  corrupt	
  vector	
will	
  have	
  two	
  AS3	
  funcGons,	
  like	
read_memory	
  and	
  write_memory.	
•  The	
  two	
  funcGon	
  use	
  corrupt	
  vector	
  to	
  read	
and	
  write	
  arbitrary	
  memory. 
•  So,	
  we	
  can	
  use	
  DbgFlashVul	
  to	
  break	
  the	
execuGon	
  on	
  write_memory.	
  Exploit	
  uses	
  this	
funcGon	
  to	
  construct	
  ROP	
  chain	
  and	
shellcode. 
A	
  real	
  example	
  :	
  CVE-­‐2015-­‐3090 
•  Steps:	
  >	
  Set	
  break	
  point	
  at	
  write_memory	
  >	
  Aoer	
  break,	
  get	
  the	
  address	
  of	
  “corruptVector[index]	
  =	
  value”,	
  the	
assembly	
  is	
  like	
  “mov	
  dword	
  ptr	
  [edx+eax*4+8],	
  ecx”	
  >	
  Set	
  break	
  point	
  on	
  the	
  address.	
  >	
  When	
  break,	
  every	
  ecx	
  is	
  a	
  part	
  of	
  ROP	
  chain	
  and	
  shellcode 
A	
  real	
  example	
  :	
  CVE-­‐2015-­‐3090 
0:008>	
  !SetBaseAddress	
  038f0000	
0:008>	
  !SetBpForJitCode	
  test/write_memory	
0:008>	
  g	
BreakPoint	
  at	
  [test/write_memory]	
eax=05072424	
  ebx=05039100	
  ecx=020bf4b0	
  edx=00000002	
  esi=05023b08	
  edi=05023b08	
eip=05072424	
  esp=020bf464	
  ebp=020bf480	
  iopl=0	
  nv	
  up	
  ei	
  pl	
  nz	
  na	
  pe	
  nc	
cs=001b	
  ss=0023	
  ds=0023	
  es=0023	
  fs=003b	
  gs=0000	
  eﬂ=00040206	
+0x5072423:	
05072424	
  55	
  push	
  ebp	
0:008>	
  p	
……	
0:008>	
  p	
eax=00089352	
  ebx=05039100	
  ecx=03bcbeb6	
  edx=0510e2c0	
  esi=05023b08	
  edi=05023b08	
eip=05072553	
  esp=020bf428	
  ebp=020bf460	
  iopl=0	
  nv	
  up	
  ei	
  ng	
  nz	
  na	
  po	
  cy	
cs=001b	
  ss=0023	
  ds=0023	
  es=0023	
  fs=003b	
  gs=0000	
  eﬂ=00040283	
+0x5072552:	
05072553	
  894c8208	
  mov	
  dword	
  ptr	
  [edx+eax*4+8],ecx	
  ds:0023:05333010=00000000	
0:008>	
  bu	
  05072553	
0:008>	
  g	
Breakpoint	
  4	
  hit	
eax=0008937b	
  ebx=05039100	
  ecx=03b66ea0	
  edx=0510e2c0	
  esi=05023a78	
  edi=04a6a020	
eip=05072553	
  esp=020bf548	
  ebp=020bf580	
  iopl=0	
  nv	
  up	
  ei	
  ng	
  nz	
  na	
  pe	
  cy	
cs=001b	
  ss=0023	
  ds=0023	
  es=0023	
  fs=003b	
  gs=0000	
  eﬂ=00040287	
+0x5072552:	
05072553	
  894c8208	
  mov	
  dword	
  ptr	
  [edx+eax*4+8],ecx	
  ds:0023:053330b4=00000000	
0:008>	
  u	
  ecx	
Flash32_17_0_0_134!DllUnregisterServer+0x92fe4:	
03b66ea0	
  94	
  xchg	
  eax,esp	
  //	
  stack	
  pivot	
03b66ea1	
  c3	
  ret	
How	
  to	
  implement	
  it? 
•  Get	
  MethodInfo::	
  getMethodName	
  address	
  by	
binary	
  searching	
•  Hook	
  BaseExecMgr::verifyJit	
  like	
  FED	
•  In	
  Hook	
  funcGon:	
  >	
  Get	
  emi4ed	
  code	
  address	
  and	
  MethodInfo	
  object	
  >	
  Call	
  MethodInfo::	
  getMethodName	
  with	
  MethodInfo	
object(ecx)	
  >	
  Get	
  AS3	
  method	
  name	
  from	
  eax	
  >	
  Save	
  AS3	
  method	
  name	
  and	
  code	
  address 
How	
  to	
  implement	
  it? 
void	
  BaseExecMgr::verifyJit	
  (…)	
  {	
…	
…	
jump	
  hook_funck	
…	
…	
} 
void	
  hook_func	
  (…)	
  {	
  name	
  =	
  method_info-­‐>getMethodName	
  ();	
  address	
  =	
  code_address;	
  Map[name]	
  =	
  address	
  ;	
  jump	
  verifyJit	
} 
DbgFlashVul	
  can	
  do	
  other	
  things 
•  Help	
  to	
  write	
  ﬂash	
  player	
  exploit	
•  Help	
  to	
  verify	
  template	
  SWF	
  is	
  correct	
  or	
  not	
when	
  do	
  fuzzing	
•  Help	
  to	
  dump	
  embedded	
  SWF	
  by	
  seung	
  break	
point	
  at	
  LoadBytes	
  ……	
Agenda 
•  Who	
  am	
  I	
•  Background	
•  Discover	
  ﬂash	
  0-­‐day	
  a4acks	
  from	
  big	
  set	
samples	
•  Vector	
  Length	
  miGgaGon	
Vector	
  exploit	
  miGgaGon 
Vector	
  exploit	
  miGgaGon 
•  Vector	
  length	
  check	
  >	
  add	
  a	
  length	
  XOR	
  cookie	
  in	
  vector	
  buﬀer	
  object	
  |	
  length	
  |	
  cookie	
  |	
  gc	
  relate	
  |	
  data	
  |	
  >	
  compare	
  when	
  using	
  length,	
  (length	
  ^	
  seed)	
  ==	
  cookie	
Vector	
  exploit	
  miGgaGon 
•  Vector	
  length	
  check	
  bypass	
  >	
  need	
  a	
  strong	
  info	
  leak	
  bug	
  to	
  read	
  both	
  length	
  and	
  cookie	
to	
  calculate	
  the	
  seed	
  >	
  seed	
  =	
  (length	
  ^	
  cookie)	
Vector	
  exploit	
  miGgaGon 
•  Vector	
  buﬀer	
  object	
  isolated	
  >	
  allocate	
  vector	
  object	
  in	
  system	
  heap	
  not	
  in	
  ﬂash	
  gc	
  heap	
  >	
  makes	
  vector	
  buﬀer	
  memory	
  hard	
  to	
  occupy	
  the	
  freed	
memory,	
  miGgate	
  the	
  exploit	
  of	
  UAF	
  bugs	
  >	
  makes	
  heap	
  buﬀer	
  overﬂow	
  bugs	
  hard	
  to	
  overwrite	
  vector	
buﬀer	
  object.	
Vector	
  exploit	
  miGgaGon 
•  Vector	
  buﬀer	
  object	
  isolated	
  bypass	
  >	
  need	
  to	
  heap	
  spray	
  many	
  vector	
  objects	
  to	
  some	
  address	
  >	
  need	
  a	
  overwrite	
  bug	
  to	
  overwrite	
  a	
  heap	
  sprayed	
  address 
Conclusion 
•  The	
  miGgaGon	
  makes	
  vector	
  length	
  based	
exploit	
  hard.	
•  This	
  miGgaGon	
  doesn’t	
  decrease	
  the	
  number	
of	
  vulnerabiliGes	
  of	
  Flash	
  Player.	
•  The	
  miGgaGon	
  can	
  bypass	
  but	
  need	
  more	
good	
  bugs	
•  Some	
  one	
  may	
  ﬁnd	
  replacement	
  for	
  vector 
Reference 
•  “Smashing	
  The	
  Heap	
  With	
  Vector,”	
  Haifei	
  Li	
•  “Inside	
  AVM,”	
  Haifei	
  Li	
•  Google	
  Project	
  zero,	
h4p://googleprojectzero.blogspot.tw/
2015/07/signiﬁcant-­‐ﬂash-­‐exploit-­‐
miGgaGons_16.html	
Special	
  Thanks	
  To 
•  @LambdaTea	
  >	
  Implemented	
  FED	
  together	
  with	
  me	
Thank	
  you!