### 模块中的面向对象原则

该模块遵循了面向对象编程的基本原则。

### VC6 编译 CFaultClass 类时的 c4251 警告

在使用 Visual C++ 6.0 (VC6) 编译 `CFaultClass` 类时，会遇到编译器发出的 c4251 警告。警告信息如下：

```
'm_cstrMember' : class 'std::basic_string' needs to have dll-interface to be used by clients of class 'CFaultClass'
```

这条警告意味着，如果 `CFaultClass` 类以动态链接库（DLL）的形式导出，则其成员变量 `m_cstrMember` 所属的 `std::basic_string` 类也需要具有 DLL 接口才能被外部客户端正确使用。具体来说，这是因为 `CFaultClass` 的定义中包含了 `__declspec(dllexport)` 修饰符，表明该类是作为 DLL 导出的一部分；然而，其成员 `m_cstrMember` 所属的标准库字符串类型 `std::basic_string` 并未同样地声明为可导出。

**根本原因分析：**

- 在本例中，`FaultApp` 和 `FaultDll` 分别静态链接了各自的 C 运行时库 (CRT) 版本。因此，当两者尝试通过 `fc.m_cstrMember` 交互操作同一个实例时，实际上是在处理两份不同的 `std::basic_string` 实现。
- 如果 `FaultDll` 动态链接了 `std::basic_string` 或者将 `std::basic_string` 也作为 DLL 导出部分，那么就不会出现上述问题。
- 此案例再次强调了关注并理解编译器警告的重要性，因为它们往往指向潜在的设计或实现缺陷。

### 《软件调试》补编说明

这部分内容原计划包含于《软件调试》第 24 章后半部分，主要探讨编译器如何处理异常代码的一些内部机制，包括局部展开、全局展开等概念。目的是为了让读者能够深入且全面地理解异常编译过程。

然而，在向朋友展示这部分草稿时，尽管他们认可其深度，但对其必要性提出了质疑——毕竟这不是一本专门讲述编译原理的书籍。最终，在对书稿进行最后一次篇幅压缩时，决定移除这部分内容。作者对此表示遗憾，因为他认为撰写这些章节确实花费了不少时间和精力。

#### 栈展开详解

栈展开是异常处理过程中一个相对复杂的主题。为了更好地阐述这一概念及其工作原理，我们通过一个名为 `SehUnwind` 的示例程序来加以说明。

##### 示例程序代码

```c
// 省略了完整的代码段，请参见原文档中的清单 24-15
```

在这个例子中，`FuncFoo` 函数手动注册了一个异常处理器 `_uraw_seh_handler`。而 `main` 函数则利用结构化异常处理语句 (`__try{}__except()`) 来捕获任何可能发生的异常。这种多层嵌套的异常处理模式在实际应用中非常常见。

当程序运行时，如果没有提供命令行参数，即 `argc=1`，会导致 `FuncFoo` 内部执行整数除零运算从而触发异常。此时，系统首先调用 `_uraw_seh_handler` 处理函数，但由于它总是返回 `ExceptionContinueSearch`，因此继续搜索其他可用的异常处理器，并最终找到并执行 `main` 函数内的异常处理逻辑。

这个过程揭示了两个关键问题：
1. **资源清理问题**：由于异常导致函数非正常退出，原本应该被执行的清理代码（如释放资源）可能会被跳过。
2. **栈状态恢复问题**：需要将当前执行上下文恢复到适合执行异常处理块的状态，以便确保后续代码能够顺利执行。

这些问题正是引入“栈展开”机制的原因所在。“栈展开”的目标就是解决上述问题，确保即使在发生异常的情况下，程序仍能保持良好的控制流和状态一致性。