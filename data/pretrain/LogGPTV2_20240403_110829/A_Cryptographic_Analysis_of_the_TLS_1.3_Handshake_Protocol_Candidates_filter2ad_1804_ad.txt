Our model allows the adversary to learn certain secret inputs to the protocol execution, as well as
outputs such as session keys; we do not allow the adversary to learn intermediate values from protocol
execution, as we do not aim to capture implementation ﬂaws within the protocol. The Corrupt query
models leakage of long-term authentication keys. The Reveal query models leakage of session keys. For
both of these, we must prohibit compromise of secrets that make it trivial to break the security property:
6https://www.ietf.org/mail-archive/web/tls/current/msg15594.html and follow-up (March 2015)
12
we do so by deﬁning partners via session identiﬁers. In the multi-stage setting, each stage involves its
own identiﬁer. An important aspect for the Reveal query in the multi-stage setting concerns the security
of future session keys of later stages, given that a session key of some stage is revealed. (Session-)key
independence says that such leakage does not endanger future keys. Our model does not consider leakage
of draft-dh’s semi-static keys: since draft-dh does not actually include 0-RTT session keys, the leakage
of semi-static secrets does not aﬀect the security of the handshake. However, in a future protocol using
semi-static secrets to derive 0-RTT session keys, security would depend on semi-static secrets and leakage
would have to be modeled appropriately.
For TLS 1.3 some adaptations of the multi-stage model of Fischlin and Günther [FG14] are necessary
or beneﬁcial. In order to cover the various authenticity properties of the TLS 1.3 handshake, we extend
their model to encompass, besides mutually and unilaterally authenticated keys, also unauthenticated
keys. One can imagine TLS 1.3 as being composed of various protocol versions which share joint steps,
but are fundamentally diﬀerent in terms of security. Namely, TLS 1.3 can be seen as a family of three
protocols, one without any authentication, one for unilateral authentication (of the server), and another
one for mutual authentication where both client and server authenticate. We capture this by allowing the
adversary in the security model to determine the type of authentication, and thus the corresponding sub
protocol, when initializing a session. We also capture keys and executions with increasing authenticity
properties, starting with an unauthenticated session key and then establishing a unilaterally or mutually
authenticated key. We also allow executions of diﬀerent types to run concurrently, even within a single
party.
We additionally allow the communication partner of a session to be unknown at the start of the
protocol, i.e., we allow for “post-speciﬁed peers” as introduced by Canetti and Krawczyk [CK02]. In our
model, this is captured by letting the adversary initialize a session with a wildcard ‘∗’ as the intended
communication partner and corresponds to the regular case in TLS 1.3 that parties discover their peer’s
identity during protocol execution when they receive their peer’s certiﬁcate. Note that the common
approach to authenticate clients by password-based login over the already established TLS connection is
beyond the scope of this paper; from the perspective of our key exchange model, those are sessions where
the client does not authenticate.
Another change concerns stronger key secrecy properties for sessions communicating with unauthenti-
cated partners. For example, in TLS 1.3 a server can communicate with an unauthenticated client. Since
the adversary could easily impersonate the unauthenticated client and thereby legitimately compute the
shared session key, we cannot in general allow all server sessions with unauthenticated partners to be
tested. However, if there is an honest unauthenticated client, then the key between these honest parties
should still be secure, so we allow Test queries for sessions with unauthenticated partners if an honest
partner exists (as done in [FG14]).
This, though, turns out to be overly restrictive and less handy for our composition result. Intuitively,
one should also allow to Test such a server session even if the adversary does not deliver the server’s ﬁnal
message to the honest client session. Since the client at this point has already completed his contribution
to the session key on the server side, this key should already be considered secure. We hence introduce the
notion of contributive identiﬁers, identifying sessions of honest parties which are currently not partnered
according to (full) session identiﬁers, but indicating that the key is entirely based on an honest peer’s
contribution. For soundness we assume that partnered sessions (having matching session identiﬁers) also
agree on the contributive identiﬁer. Both session identiﬁers and contributive identiﬁers are set primarily as
administrative tokens by the key exchange protocol during the execution. In contrast to session identiﬁers,
a contributive identiﬁer can be updated several times instead of being set only once, e.g., to eventually
match the session identiﬁer. Guidance for how and when to set contributive identiﬁers can be obtained
by considering composition: we will show that secure usage of an established session key in a subsequent
symmetric protocol is possible whenever the parties honestly (or authentically) contributed to that key, i.e.,
13
agree on the contributive identiﬁers. Contributive identiﬁers may be seen as the identiﬁer-based analogue
to preﬁx-matching deﬁnitions used in ACCE models [JKSS12], allowing the adversary to issue Test queries
to sessions that are non-trivial to break but normally force the adversary to lose the game.
4.2 Preliminaries
We denote by U the set of identities used to model the participants in the system, each identiﬁed by
some U ∈ U and associated with a certiﬁed long-term public key pkU and secret key skU. Note that in
addition to the long-term keys parties may also hold (uncertiﬁed) temporary (“semi-static” in draft-dh)
key pairs for the 0-RTT protocol version, each identiﬁed by a key identiﬁer kid. Sessions of a protocol are
uniquely identiﬁed (on the administrative level of the model) using a label label ∈ LABELS = U × U × N,
where (U, V, k) indicates the k-th local session of identity U (the session owner) with V as the intended
communication partner.
For each session, a tuple with the following information is maintained as an entry in the session list
ListS, where values in square brackets [ ] indicate the default/initial value. Some variables have values for
each stage i ∈ {1, . . . , M}.7
for “unknown identity” and can be set to a speciﬁc identity in U once by the protocol
• label ∈ LABELS: the (administrative) session label
• U ∈ U: the session owner
• V ∈ (U ∪ {∗}): the intended communication partner, where the distinct wildcard symbol ‘∗’ stands
• role ∈ {initiator, responder}: the session owner’s role in this session
• auth ∈ AUTH ⊆ {unauth, unilateral, mutual}M: the aspired authentication type of each stage from the
set of supported properties AUTH, where M is the maximum stageand authi indicates the authenti-
cation level in stage i > 0
• kidU: the key identiﬁer for the temporary public/secret key pair (tpk, tsk) used by the session owner
• kidV : the key identiﬁer for the communication partner
• stexec ∈ (RUNNING ∪ ACCEPTED ∪ REJECTED): the state of execution [running0], where RUNNING =
• stage ∈ {0, . . . , M}: the current stage [0], where stage is incremented to i when stexec reaches acceptedi
• sid ∈ ({0, 1}∗ ∪ {⊥})M: sidi [⊥] indicates the session identiﬁer in stage i > 0
• cid ∈ ({0, 1}∗ ∪ {⊥})M: cidi [⊥] indicates the contributive identiﬁer in stage i > 0
• K ∈ ({0, 1}∗ ∪ {⊥})M: Ki [⊥] indicates the established session key in stage i > 0
• stkey ∈ {fresh, revealed}M: stkey,i [fresh] indicates the state of the session key in stage i > 0
• tested ∈ {true, false}M: test indicator testedi [false], where true means that Ki has been tested
{runningi | i ∈ N0}, ACCEPTED = {acceptedi | i ∈ N}, REJECTED = {rejectedi | i ∈ N}
resp. rejectedi
By convention, if we add a partly speciﬁed tuple (label, U, V, role, auth, kidU , kidV ) to ListS, then the other
tuple entries are set to their default value. As labels are unique, we write as a shorthand, e.g., label.sid for
the element sid in the tuple with label label in ListS, and analogously for other entries.
4.3 Authentication Types
We distinguish between three diﬀerent levels of authentication for the keys derived in a multi-stage key
exchange protocol: unauthenticated stages and keys (which provides no authentication for either commu-
nication partner); unilaterally authenticated stages and keys (which authenticates one party, in our case
the responder); and mutually authenticated stages and keys (which authenticates both communication
partners). We let the adversary choose the authentication type for each session it creates.
7We ﬁx a maximum stage M only for ease of notation. Note that M can be arbitrary large in order to cover protocols
where the number of stages is not bounded a-priori.
14
For stages with unilateral authentication, where only the responder authenticates, we consequently
only aim for secrecy of the initiator’s session key, or of the responder’s key, if the initiator’s contribution
to the key is honest and the adversary merely observes the interaction.
In the non-authenticated case
we only ask for secrecy of those keys established through contributions of two honest parties. Since the
adversary can trivially impersonate unauthenticated parties we cannot hope for key secrecy beyond that.
Formally, we capture the authenticity properties provided in a protocol by a set AUTH ⊆ {unauth,
unilateral, mutual}M, representing each protocol variant’s authentication by a vector (auth1, . . . , authM) ∈
AUTH specifying for each stage i the protocol whether it is unauthenticated (authi = unauth), unilaterally
authenticated (authi = unilateral), or mutually authenticated (authi = mutual). We moreover treat all
authenticity variants of a protocol concurrently in our model (and hence speak about concurrent authenti-
cation properties): we allow concurrent executions of the diﬀerent key exchange sub protocols, simultane-
ously covering all potential unauthenticated, unilaterally authenticated, or mutually authenticated runs.
Given that the authenticity of keys is a strictly non-decreasing property with progressing stage, we also
use the following simpler notation:
• no authentication: the keys of all stages are unauthenticated.
• stage-k unilateral authentication: the keys of stage i are unauthenticated for i  stage, or testedi = true, then return ⊥. Otherwise, set stkey,i to revealed and provide the
adversary with Ki.
If there is a tuple (label0, V, U, role0, auth0, kidV , kidU , st0
key, tested0) in ListS
with sidi = sid0
key,i is set to revealed as well. This means the i-th session keys
of all partnered sessions (if established) are considered revealed too.
As above, in the case of key-dependent security, since future keys depend on the revealed key, we
cannot ensure their security anymore (neither in this session in question, nor in partnered sessions).
Therefore, if i = stage, set stkey,j = revealed for all j > i, as they depend on the revealed key. For
the same reason, if a partnered session label0 with sidi = sid0
i has stage0 = i, then set st0
key,j = revealed
for all j > i. Note that if however stage0 > i, then keys K0
j for j > i derived in the partnered session
8This implicitly assumes the following property of the later-deﬁned Match security: Whenever two partnered sessions both
exec, stage0, sid0, cid0, K0, st0
accept a key in some stage, these keys will be equal.
16
are not considered to be revealed by this query since they have been accepted previously, i.e., prior
to Ki being revealed in this query.
• Corrupt(U): Provide skU to the adversary. No further queries are allowed to sessions owned by U.
In the non-forward-secret case, for each session label owned by U and all i ∈ {1, . . . , M}, set label.stkey,i
to revealed. In this case, all (previous and future) session keys are considered to be disclosed.
In the case of stage-j forward secrecy, label.stkey,i is set to revealed only if i  stage. This
means that session keys before the j-th stage (where forward secrecy kicks in) as well as keys that
have not yet been established are potentially disclosed.