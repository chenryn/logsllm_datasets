    1022          for (m = control; m != NULL && len >= m->m_len; m = m->m_next) {
    1023              if ((error = copyout(mtod(m, caddr_t), ctlbuf,
    1024                  m->m_len)) != 0)
    1025                  goto out;
    1026  
    1027              ctlbuf += m->m_len;
    1028              len -= m->m_len;
    1029              mp->msg_controllen += m->m_len;
    1030          }
    1031          if (m != NULL) {
    1032              mp->msg_flags |= MSG_CTRUNC;
    1033              m_dispose_extcontrolm(m);
    1034          }
    1035      }
可见，如果发送包含控制部分中的文件描述符的消息，则遵循此路径运行，但用于接收此消息的`recvmsg()`函数是不需要控制消息的。但是由于第1020行中的`len`将为0，而`m->m_len`更大，这将触发`m_dispose_controlm()`函数。因为在发送的消息中存在控制消息，程序不执行第1022行中的循环，而是分配给`m`非NULL的内容。
也就是说，要调用`m_dispose_constrolm()`，必须完成以下操作：
> 1.创建一个UNIX域套接字  
>  2.分配一个足够大的缓冲区，通过包含文件描述符的套接字发送消息  
>  3.分配一个不够大的缓冲区，通过包含文件描述符的套接字接收消息  
>  4.使用sendmsg（）发送消息  
>  5.使用recvmsg（）接收消息
现在，可以找到漏洞位置了。再次观察`m_dispose_extcontrolm()`的第1606行。
    1578  void
    1579  m_dispose_extcontrolm(struct mbuf *m)
    1580  {
    ...
    1606                  while (nfd-- > 0) {
    1607                      fd = *fds++;
    1608                      error = fget(td, fd, &cap_no_rights,
    1609                          &fp);
    1610                      if (error == 0)
    1611                          fdclose(td, fp, fd);
    1612                  }
有趣的部分是对`fget()`的调用。此函数最终会导致`fget_unlocked()`，它从文件描述符fd中提取指向struct文件对象的指针，将地址保存在指针fp中，并将struct文件对象的引用计数器`f_count`加1。但是，因为接收器使用自己的文件描述符保存对同一struct文件对象的引用，发送文件描述符时也会增加引用计数器的值，因此，计数器总共增加了2。
最后，第1611行中的`fdclose()`关闭了接收者的文件描述符，删除了对结构的引用，但没有考虑到调用fget()过程中f_count总共增加了2。
因此，该函数会产生一个可以将f_count增加1的语句。因为f_count的类型为u_int，其大小为32位，所以可以在合理的时间内溢出该变量。可以通过迭代增加f_count的语句，直到结果超过32位。变量将删除高于32位的所有位，再次回绕到0。
如果用这种方法将f_count溢出为1，则有可能实现UaF。为此，发送进程需要将两个文件描述符保存到同一个struct文件中，可以利用`dup()`函数复制一个文件描述符来实现这一操作。现在，如果其中一个文件描述符在溢出后关闭，则调用`fdrop()`。如上所述，此调用会看到`f_count`为1，释放struct文件对象。而此时，仍然可以通过第二个仍然打开的文件描述符引用释放的块。
现在捋清了基本的想法。因为这部分非常重要，所以应该更详细地描述如何触发漏洞，以及一些需要解决的问题。
首先，使用`open()`打开文件，并使用`dup()`复制文件描述符。这会使两个文件描述符引用相同的struct文件对象。因此，`f_count`是2。
接下来，如上所述，重复触发`m_dispose_extcontrolm()`以溢出f_count，最后再次将其设置为1。但这有一些问题。在这一过程中不可能发送任意数量的文件描述符。因为每个文件描述符都需要占用发送消息的空间，但内核内部只有有限的`mbufs`（构建消息以供进一步处理的空间）可用。
幸运的是，在调用`m_dispose_extcontrolm()`递减计数器前可以通过套接字多次发送文件描述符会多次增加引用计数器。
因此，UaF的准备需要一些时间。用于本研究的虚拟机，大概需要准备20分钟（2G内存，双核处理器）。
此外，重要的是要注意溢出必须使`f_count == 1`而不是0，因为如果f_count ==
0时调用fdrop()，会导致内核崩溃。这是因为`refcount_release()`仅通过检查计数器是否为0判断是否空闲，但_fdrop()会使f_count正好为0。如果计数器为负，`_fdrop`会使程序崩溃（通过将引用计数器增加到0xffffffff
= -1`二进制补码`，可以将此行为用作概念验证，因为在递减到0xffffffff之前，f_count将为0）。
将`f_count`调整为1后，其中一个文件描述符被“手动”关闭。调用_fdrop()使f_count递减为0后将触发`free`。使struct文件对象释放到Files区域的存储“桶”中。由于之前的`dup()`，第二个文件描述符仍引用已释放的struct文件对象，但因为对象本身被标记为无效,对第二个文件描述符来说，这个已释放的struct文件对象现在是无效的。
在这有另一个问题：struct文件的其他系统调用如`read()`或`write()`会用到`fget_unlocked()`函数。此函数将检查所使用的文件描述符是否小于最大有效文件描述符。因此，最好关闭第一个文件描述符，因为重复的文件描述符通常会更大。
至此，我们已经获得了一个引用无效结构文件的文件描述符。一旦这个struct文件的内存被另一个`open()`函数重用，我们的“悬空”的文件描述符将再次生效。但是，它将指向新打开的文件。“悬空”文件描述符可用于与新打开的文件描述符相同的操作。因为它们共享相同的struct文件，所以新打开的文件描述符的所有权限都由“悬挂”的文件描述符继承。例如，如果第一个文件是以只读方式打开而第二个文件是可写的，则可以使用悬空文件描述符写入新打开的文件。
将在下一节和之后的部分讲解如何利用它。
总结触发策略：
> 用open（）打开一个文件  
>  使用dup（）复制文件描述符  
>  通过调用m_dispose_extcontrol（）溢出f_count为1  
>  关闭第一个文件描述符并触发free  
>  再次调用open（）以从Files区域分配另一个struct文件，从而产生利用“悬空”的文件描述符的对象
可以在`trigger_uaf.c`中找到第一个概念验证。值得注意的是，程序关闭时会导致内核崩溃。这将在最终的漏洞利用中得到解决。感兴趣的读者可以在继续阅读之前尝试找出解决的方案。
## 0x04 漏洞利用策略
本节将讨论三种可能的漏洞利用策略，其中两种在研究期间失败了。
###  1.利用suid程序
最简单的策略之一是检查是否有可能触发UaF并在此之后执行suid程序(如passwd)，使“悬挂”的文件描述符得到root权限。
exploit需要将结构体对象完全放入Files区域的“桶”中。如果suid程序以可写方式打开root所拥有的文件（如master.passwd或libmap.conf），则可以从用户上下文写入此文件。
理论上这种策略是有效的。可以在文件`setuid_test_client.c`和`setuid_test_server.c`中找到概念验证（注意：编译的setuid_test_server.c和suid必须是root所有的）。
但是，找到这样一个程序非常难。标准安装中的大多数实用程序以只读方式打开可利用的文件或很快就关闭它们。
因此这种方法很早就被pass了。
###  2.内存损坏
另一种典型的办法是找到破坏内核内存的方法，以便执行用户提供的代码。这意味着可能要覆盖例如结构文件对象内的函数指针或可以由结构文件对象间接引用的另一个对象。
实际上，[fail0verflow](https://fail0verflow.com/blog/2017/ps4-namedobj-exploit/)使用了一种非常类似的技术,利用了基于FreeBSD 9的PlayStation 4操作系统中的漏洞。他们打开了一个kqueue-一个监视内核事件的FreeBSD机制。
kqueue-files利用结构体中的`f_data`指针来管理kqueue。堆空间是从其中一个匿名区域分配的。因此，可以使用`ioctl()`对该区域进行堆喷射，并覆盖文中描述的函数指针。
但是，fail0verflow使用的漏洞与本研究中使用的漏洞之间存在显着差异：前者允许任意free，例如`f_data`指针。后者只允许释放struct文件。当内核清理所有可用的struct字段和指针时，不可能使用fail0verflow的代码。
在研究期间，对所有其他可能依赖于struct文件的对象都及进行了尝试，但是由于刚才所说的原因，无法通过内存损坏来利用漏洞。
###  3.在write()期间交换文件对象
这是第一种方法的变体。
一旦用户尝试通过文件描述符写入，FreeBSD内核就会检查文件是否可写。如果检查通过，则准备执行写操作。这创建了一个基于`Time-of-Check-Time-of-Use（TOCTOU）`条件竞争的方案。
思路如下：传递的检查和写入操作之间的时间窗口会产生条件竞争。可以利用漏洞释放struct文件对象，并立即打开另一个只读文件。由于此时写入检查已经完成，但struct文件被替换被，最终会在只读文件上执行写入操作。
由于此策略最终成功用于利用UaF获取root权限，因此将在下一节中详细介绍。
值得一提的是，Google Project Zero的Jann Horn在Linux中利用了相似的漏洞并使用了类似的方法。2016年在Project
Zero上发布的[相关文章](https://bugs.chromium.org/p/project-zero/issues/detail?id=808)。
## 0x05 提权
如上一节所述，基于Time-of-Check-Time-of-Use（TOCTOU）条件竞争的攻击：对用户可写的文件调用write()。系统调用首先检查文件描述符引用的文件是否确实可由用户写入，如果没有写权限，将导致系统错误。检查通过后，将触发UaF漏洞，之后普通用户可以打开root所拥有的只读文件。
检查的工作方式如下：`write()`函数将调用在`sys/kern/sys_generic.c`中的内核函数`sys_write()`。随后，调用同一文件中的`kern_writev()`，这会调用`fget_write()`函数。后者在`sys/kern/kern_descrip.c`中定义。此函数用于检索文件描述符的struct文件对象，并检查是否可写。
为此，该函数会调用`_fget()`函数。
    2716  static __inline int
    2717  _fget(struct thread *td, int fd, struct file **fpp, int flags,
    2718      cap_rights_t *needrightsp, seq_t *seqp)
    2719  {
    2720      struct filedesc *fdp;
    2721      struct file *fp;
    2722      int error;
    2723  
    2724      *fpp = NULL;
    2725      fdp = td->td_proc->p_fd;
    2726      error = fget_unlocked(fdp, fd, needrightsp, &fp, seqp);
    ...
    2738      switch (flags) {
    2739      case FREAD:
    2740      case FWRITE:
    2741          if ((fp->f_flag & flags) == 0)
    2742              error = EBADF;
    2743          break;
    ...
    2753      }
    2754  
    2755      if (error != 0) {
    2756          fdrop(fp, td);
    2757          return (error);
    2758      }
    2759  
    2760      *fpp = fp;
    2761      return (0);
    2762  }
请看第2741行的检查函数，`f_flag`是在第一次调用open()时设置的struct文件中的一个字段。调用write()会检查`FWRITE`位。因此，仅当用户对打开的文件具有写权限时才能设置该位。
应注意：假设此时已经准备好UaF，即f_count变量溢出为1，且调用fget_unlocked()将f_count增加到了2。计数器将在调用write()结束时再次减少到1。
但是，如果通过检查，则可以通过UaF和另一个open()操作将文件对象变换为只读文件。之后将能在第二个文件中写入。可以在`test_rd_only_write.c`中找到第一个概念验证（请注意，如文件开头的注释中所述，该测试需要内核补丁;详细信息，请参阅附录）。
检查通过后，`kern_writev()`将调用同一文件中的`dofilewrite（）`。
    545  static int
    546  dofilewrite(struct thread *td, int fd, struct file *fp, struct uio *auio,
    547      off_t offset, int flags)
    548  {
    ...
    564      if (fp->f_type == DTYPE_VNODE &&
    565          (fp->f_vnread_flags & FDEVFS_VNODE) == 0)
    566          bwillwrite();
    567      if ((error = fo_write(fp, auio, td->td_ucred, flags, td))) {
    ...
    576          }
    577      }
    ...
    587  }
这个函数有两个有趣的函数调用。第一个是第567行中的`fo_write()`。该函数最终会执行写操作。也就是说，struct文件变换必须在调用此函数之前(或者在fo_write()内部的后续函数调用中，这不是必需的)。
不过，条件竞争过程非常紧张，如果其他条件不满足也难以成功。此外，必须一次就成功，否则内核将会崩溃。
假设在通过检查时`f_count`为2。此时必须调用`close()`两次。但是如果检查尚未通过或者write()已经完成，f_count仍然是1。`_fdrop（）`将判断引用计数器正好为0，但是调用两次`close()`会使函数将引用计数器解释为负数。错误的判断将导致程序崩溃。
Jann
Horn通过编写FUSE文件系统来延迟Linux的内核操作，该系统延迟能够帮助赢得竞争条件，提高写入操作的成功率。在标准的FreeBSD中由于无法加载FUSE（并且可供相应用户使用），是不可能实现的。
在第566行中对`bwillwrite()`的调用创造了条件。此函数和`buf_dirty_count_severe()`函数在`sys/kern/vfs_bio.c`中定义。
    2564  bwillwrite(void)
    2565  {
    2566  
    2567      if (buf_dirty_count_severe()) {
    2568          mtx_lock(&bdirtylock);