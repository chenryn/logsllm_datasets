继承
延期
COMPOSITE_PART
COMPOSITE_PUDDING
↑
CREAMY FRUIT_SALAD
CREAM
图13-3：展示布丁继承结构的类图
继承和客户（client）关系之间的区别是值得注意的。水果沙拉
（fruitsalad）是一种布丁，它同时也是一种复用品（我们忽略了通
用参数）。一种复用品（repetition）并不是一种布丁，而是一种描
述食物构成的“布丁成分”。有些"布丁成分”（诸如“合成布丁”）也
是布丁，当然也不全是。水果沙拉（fruit salad）是一种布丁，同时
也是一种复用品（repetition），它是一种布丁成分
（pudding_part）。另一方面，一种奶油水果沙拉（creamyfruit
salad）不是一种水果沙拉（fruitsalad），即使我们使用这一表示法
表示用水果制成的布丁。它拥有水果沙拉和奶油，因此它使用了客
户关系。它是一种合成布丁（compositepudding），因为该表示法
用来表示它是由几个部分组成的，它和更通用的表示法
COMPOSITE_PART一样，也是一种布丁。对于这个成分而言，它和
水果沙拉（fruitsalad）和奶油（cream）之间是客户关系。
对于金融契约示例而言，我们可以使用相似的方法，可以基于契约
的类型将其分成“零息票债券”、“期权"以及其他由问题域专家经过
仔细分析所得出的类别。
多重继承对于这种形式的面向对象建模是至关重要的。特别注意组
合部分（compositepart）的定义，在此应用了一个通用的模式来描
述这种组合结构（参见Meyer1997，5.1节，“compositefigures”）：
1247
---
## Page 1249
Class COMPOSITE PART inherit
PUDDING_PARTLIST [PUDDING_PART]
feature
end
其中方括号引入了泛型参数一个组成部分（composite part）既是布
丁的成分，拥有所有可应用的属性和操作（sugar content等），也是
一个布丁成分列表，同样带有一些可应用的列表操作：诸如start、
forth之类的指针移动命令，诸如item和index之类的查询，以及插
入、删除元素的命令。列表中的元素可以是任何一种布丁成分，包
括（递归的）组合部分（composite part）。这样，多态和动态绑定
技术也就有了用武之地，我们稍后将对其进行说明。泛型和继承都
是很有用的机制。另外，多重继承使针对类的机制更加完整，它不
仅仅局限于用接口（Java风格）实现，这此并没有应用到接口。
13.4.5多态、多态容器和动态绑定
继承和泛化对可扩展性的贡献，以及多态和动态绑定技术所带来的
可扩展性，我们可以从COMPOSITE_PART类中的sugar_content中体
会到（参见图13-4）：
sugar_content: REAL
do
from start until after loop
Result: =Result+item.sugar_content
forth
end
end
1248
---
## Page 1250
Before
After
1
index
count
item
+
Forth
Start
光标
Finish
图13-4：带光标的多态列表
在此直接将LIST类中的操作应用到COMPOSITEPART中了，这是因
为COMPOSITEPART就是从LIST类中继承的。item命令返回的结果
可以是任何类型（包括子类型）的PUDDING（布丁）：由于它的结
果是多种类型的对象，也就是众所周知的多态变量（在这个例子中
正好是多态查询）。一个完整的COMPOSITEPART结构，包括不同
类型的项目，这也就是众所周知的多态容器。多态容器使多态的合
成成为可能，它本身是继承和泛型的结果。（在此有两种完全不同
的机制，在函数式编程中，针对泛型的“参数化多态"很容易与这里
的多态混淆起来。）
item的多态，意味着后续调用item.sugar_content时可能会应用在不同
类型的对象上；相应的类可能会有不同版本的sugar_content查询。
动态绑定就是负责确保这样的调用能够应用合适的版本，它将基于
item所属对象的实际类型来决定。如果某种成分本身就是组合部
分，也就是前面所示的版本，它将递归地应用，而且可以是其他任
何版本，例如针对CREAM的版本。
这是针对面向对象设计的最新方法，多态是由类型系统控制的。
item值的类型是可变的，不过它肯定是PUDDING及其子孙类，它们
是由COMPOSITEPART的泛型参数指定的。这部分的内容不管对函
数式编程的环境，还是面向对象编程的环境都有影响：使用日益复
杂的类型系统（仍然是基于诸如继承、泛型和多态等少量概念），
将与系统架构相关的、日益发展的部分整合到类型结构中。
13.4.6延期类和特性
1249
---
## Page 1251
在前面的类结构图中，PUDDING和PUDDING_PART类都被标识为
“延期”（deffered）（使用的是BON面向对象建模表示法[Walden和
Nerson，1994]中所指定的星号）。这意味着，它们并没有完整实
现：换一种说法，可以称之为"抽象类”。一个延期类通常拥有延期
特性，拥有一个签名和（更重要的）契约，但没有实现。具体的实
现是由非延期的（“已实现的类”）子孙类呈现的，适合的选择是由
每个已实现类来实现延期类中定义的通用概念。在该示例中，
PUDDING和PUDDING_PART类都拥有延期特性sugar_content和
calories；其子孙类将实现它。例如，在COMPOSITE_PART就将
sugar_content定义为计算其各成分的糖量总和。在
COMPOSITE_PUDDING中，它就从COMPOSITE_PART中继承了该
版本，并从PUDDING类中继承了一些延期版本的特性，并给予实
现。
注意：当继承了两个同名特性时就将导致名称冲突，这就需要通过
重命名来解决，除非一个特性是延期的，另一个是已实现的。在这
种情况下，只有一个特性可用，那就是那个已实现的。对于继承机
制带来的名字重载会引发难以处理的复杂度，因此通常建议在面向
对象语言中不提供这种机制。
延期类要比Java和.NET中的"接口"更为复杂，它们都可以指定一个
未来必须实现的契约，而且它们都可以包含已实现的特性，这样它
能够提供的就是一个完整的特性集，从全部特性都是延期的类（只
描述了要实现的特性）到全部都已实现的类（提供了完整实现的
类）。它也可以只实现了一部分特性，这也是在架构和设计中使用
面向对象技术的本质。
在金融契约示例中，CONTRACT和OPTION就是纯延期类的候选
者，尽管它们可能无需对所有特性的实现进行延期。
13.5面向对象模块性的评价和改进
在前一个小节中，我们总结了面向对象架构设计在这两个例子中的
应用。接下来我们将按照本章之前描述的模块化标准来检查这个初
步应用的结果。虽然类型系统和契约对可靠性也有贡献，不过我们
在此只专注于可复用性和可扩展性。
13.5.1复用操作
1250
---
## Page 1252
使用继承的原则之一是将公共特性放在可应用的最高等级类上，这
样在子孙类中就无需重复它们；也就是说继承关系就是“asis”。如
果既需要保留该功能，又需要修改其实现，那么只需要重新定义
原来的契约，但其内容需要重写，不管它是已实现还是仍然为延期
的。这和动态绑定能够很好地结合：一个客户端可以使用高层级类
中定义的操作，例如my_pudding.sugar_content或my_contract.value，
而无需知道实际使用的是哪个类中的哪个版本，也不管它是该类定
义的还是继承的。
由于继承捕获了类之间的公共信息，因此要定义的特性会明显小于
最大的txf。任何减少代码的工作在此都是有价值的。代码重复始终
是有害的，这是软件设计的通用规则，这是因为代码重复意味着在
后续的配置管理、维护和调试时（当发现原代码存在问题时，必须
修改所有的副本）会带来问题。正如DavidParnas所说的那样，复
制-粘贴是软件工程师的敌人。
实际上能够减少多少代码量，取决于继承结构的质量。我们发现抽
象数据类型的原则在此仍然适用：由于在面向对象设计中，定义类
型的关键在于分析其可应用的操作，在一个设计良好的继承结构
中，最顶层的类中将收集在大量变体中可应用的特性。
该技术在函数式的模型中没有明确的等价物。在使用组合子时，对
13.5.2可扩展性：添加类型
面向对象风格的架构对可扩展性的支持如何呢？系统最常见的扩展
形式就是添加新的类型：一种新的布丁、布丁成分或金融契约。这
种情况，是面向对象技术充分发挥自已作用的地方。你只需要在继
承结构中找到最适合新类型的位置（也就是具有最多相同操作的
类），然后编写一个新的类，让它继承一些原有的特性，根据自己
的情况重新定义或修改原有的操作，并添加一些新的类可以使用的
新特性和不变量。
动态绑定在此又起关键作用；面向对象方法的好处在于当客户类执
行某个操作时，无需进行多路分支判断，诸如：“如果是水果沙拉
（fruitsalad），那么就以这种方式计算，而如果它是flan，那么就
用那种方式计算，否则....."，这样的判断必须在每种操作中不断
1251
---
## Page 1253
重复，更坏的是当添加或修改某种类型时，我们需要分别针对每个
客户、每个操作进行相应的更新。这样的结构，需要客户类维护各
种复杂的知识，了解不同结构提供的不同概念以及它们依赖的基
础，这是架构退化的根源，也是面向对象之前的技术逐渐过时的原
因。动态绑定解决了这个问题；客户应用程序只需调用
my_contract.value，内建的机制就将自动选择出相应的版本，客户无
需知道它们之间的不同。
没有哪种软件架构技术能够提供如此优美的解决方案，这也是面向
对象方法所能够提供的最佳解决方案。
13.5.3可扩展性：添加操作
面向对象技术对于可扩展性的支持，有一部分（此外还有诸如信息
隐藏、泛型以及契约等重要特性）源于这样的假设：系统中最最重
要的变化是由于添加一个新的类型，它和原有类型共享了部分操
作，并添加了一些新的操作。经验确实表明，这些是实际系统中最
常见的变化，也是面向对象技术展示其优势的地方。但如果我们想
在原有类型中添加一些操作呢？例如，有些要使用pudding类的客户
应用程序，可能想确定生产不同种类布丁所需的成本，虽然pudding
类中并未包含与成本相关的信息。
与添加类别相比，对于添加新操作而言，函数式编程表现得不好也
不坏，不管添加1个到f个，还是添加t个。不过，在面向对象解决方
案中是无法享受这种中性的优点。其基本解决方案是在继承层次结
构中合适的等级上添加一个特性。但这样做有两个潜在的缺点：
由于继承是类间的强绑定（“is-a"），因此所有原有的子孙类都会
受到影响。一般来说，在继承结构的较高层次的类中添加一个特
性，经常会带来一些微妙的麻烦。