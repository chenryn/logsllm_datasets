transformation from the user’s sensitive password to a site-
speciﬁc hash of the password, based on the domain name
of the remote webserver.
8.4 The Webserver’s Perspective
We now describe the process of acquiring sensitive input
from the perspective of a Bumpy-enabled webserver. Prior
to handling any requests, the webserver generates an asym-
metric encryption keypair and signs the public key using
its private SSL key (using calls to OpenSSL), resulting in
Cert ws enc. Cert ws enc can be used for multiple clients.
Our implementation consists of a Perl CGI script. When
a request arrives at the webserver for a page that accepts
user input, our CGI script is invoked to bundle Cert ws enc
with a freshly generated nonce (for the upcoming attesta-
tion from the user’s computer) and the hash and URL of the
binary image of our direct-encryption PoPr. The ensuing
bundle is then embedded into a hidden input ﬁeld on the re-
sulting web page. The hash and URL of the PoPr prevents
wasting bandwidth on transferring the full PoPr unless it is
the user’s computer’s ﬁrst time employing this PoPr.
When the user submits the resulting page, the webserver
expects to receive an attestation from the user’s computer
covering the PreP, the provided PoPr and nonce, and a pub-
lic signing key (KPoPr sig ) newly generated by the PoPr
on the user’s computer. Currently, we employ trust-on-
ﬁrst-use to accept the Attestation Identity Key (AIK) that
the user’s computer’s TPM used to sign the PCR register
values. We have manually conﬁgured the webserver with
the expected measurement of the PreP and PoPrs, as they
are part of the same binary in our implementation. If the
measurements in the attestation match the expected values,
then KPoPr sig is associated with K −1
ws enc (and the user’s
computer’s TPM’s AIK) to enable decryption and authenti-
cation of subsequent strings of sensitive input encrypted by
the PoPr.
9 Evaluation
We discuss the size of the trusted computing base (TCB)
for our implementation, the performance impact on ordi-
nary typing, webserver overhead, and the impact of network
latency on the refresh rate of the Trusted Monitor’s display.
Code Size. Bumpy provides strong security properties in
part due to its small trusted computing base (TCB). Fig-
ure 5 shows the code size for our PreP and PoPrs, USB In-
terposer, webserver CGI script, and Trusted Monitor. Note
that the TCB for the PreP and PoPrs includes no additional
code beyond the listed Flicker libraries thanks to the prop-
erties of Flicker. Our current USB Interposer runs as a
Linux application on a BeagleBoard; however, its only in-
terface is the USB bridge to the user’s computer, and its
only function is to transmit encrypted keyboard and mouse
events. Our Trusted Monitor includes Symbian OS in its
TCB, as it runs as a normal smartphone application. We
emphasize that the inclusion of Linux in the TCB of our
USB Interposer and Symbian OS in the TCB of our Trusted
Monitor is an artifact of our prototype implementation, and
not a necessary consequence of our architecture.
Typing Overhead with USB Interposer. We measured
the round-trip-time between reception of a keypress on
the USB Interposer (from the physical keyboard) and re-
ception of an acknowledgement from the user’s computer.
This includes the time to encrypt and HMAC the key-
press in the USB Interposer, send it to the user’s com-
puter via the USB-to-USB bridge, invoke the Flicker ses-
sion on the user’s computer with the PreP (unseal PreP
state using the master key kept in PCR-protected TPM Non-
Volatile RAM, decrypt and authenticate the newly arrived
keypress, reseal PreP state, and release the new keypress
to the OS), and send the acknowledgement back over the
USB-to-USB bridge. In 500 trials, we experienced over-
head of 141±15 ms (Figure 6). This is mildly noticeable
during very fast typing, similar to an SSH session to a far-
away host.
It is noteworthy that the overhead consumed
by Flicker (i.e., by the PreP) is 66±0.1 ms per keystroke,
Func.
Main
PwdHash
PwdHash
Total
Func.
Crypto
Crypto
TPM
TPM
Util
Util
Util
Total
PreP and PoPrs
Lang.
.c
.c
.h
.c, .h
Flicker libraries
Lang.
.c
.h
.c
.h
.c
.h
.S
.c, .h, .S
SLOC
1044
99
4
1147
SLOC
3980
471
1210
252
518
251
161
6854
USB Interposer
Func.
Decode, Encrypt & TX .c
Lang.
SLOC
489
Webserver CGI
Func.
Embed & Verify
Lang.
.pl
SLOC
167
Trusted Monitor
Func.
Protocol
Protocol
UI
UI
Util
Util
Total
Lang.
.cpp
.h
.cpp
.h
.cpp
.h
.cpp, .h
SLOC
979
286
539
160
50
34
2048
code
for
5. Lines of
Figure
trusted
Bumpy components obtained using SLOC(cid:173)
Count [36]. The PreP and PoPrs include only
the Flicker libraries in their software TCB. The
USB Interposer, webserver, and Trusted Mon(cid:173)
itor also include their respective operating
systems.
suggesting that more than half of the latency in our current
prototype may be an artifact of the untrusted Perl script in
our implementation. Indeed, the contribution of the Uin-
put driver used to inject keystrokes (42±8 ms) is unchar-
acteristically large, and grows over time. Writing to the
driver from our Perl script presently involves the creation
of a child process and a new virtual input device for every
keystroke. The virtual input device driver was not designed
Keystroke
PreP
Uinput
)
s
m
(
y
c
n
e
t
a
L
p
i
r
t
-
d
n
u
o
R
 300
 250
 200
 150
 100
 50
 0
3G/3.5G cellular radio, or using standard 802.11b/g wire-
less access points. To evaluate the latency impact of using
these networks, we performed a simple echo experiment
with an established TCP connection, where the E51 sends
a series of 4-byte requests and receives 24-byte responses
(excluding TCP/IP headers) from the HP workstation. We
observed an average round-trip time (RTT) of 102±82 ms
using the 802.11 network, and 211±25 ms using AT&T’s
3.5G network. In our experience, these latencies are imper-
ceptible to the user as she turns her head to look away from
her primary display and towards the Trusted Monitor.
 0
 50  100  150  200  250  300  350  400  450  500
Keystroke
10 Discussion
Figure 6. Latencies for 500 individual
keystrokes. The PreP and Uinput latencies
are components of the Keystroke latencies.
We discuss design alternatives and other interesting fea-
tures that Bumpy might be extended to offer.
to scale so far. Our script should be modiﬁed to employ
the same virtual input device throughout. Ample opportu-
nities remain for optimization, which we plan to pursue in
the course of future work in preparation for a user study.
Webserver Overhead with Encryption PoPr. With our
direct-encryption PoPr enabled, the webserver must embed
Cert ws enc, a newly generated nonce, the hash of the de-
sired PoPr, the URL at which the client system can obtain
the PoPr, and a signature covering the favicon and all of
these items into each page that may accept sensitive input.
Our webserver is a Dell PowerEdge 2650 with two Intel
Xeon 2.4 GHz CPUs running the Debian Linux ﬂavor of
Apache 2.2.3. In 25 trials, our CGI script induces a page-
load latency of 17.0±0.4 ms, which is primarily composed
of reading the cryptographic keys from disk (8.2±0.0 ms)
and signing the nonce and metadata (8.6±0.5 ms). When
the user submits the completed page, the webserver must
verify an attestation from her platform.
In 25 trials, our
CGI script induces a form-submission latency of less than
2 ms to verify the signature on the attestation. Note that
symmetric keys can be established that reduce the need
for the signature-veriﬁcation operation to a one-time over-
heads. Though we have not yet implemented this optimiza-
tion, the only cost is a few tens of bytes of long-term state
maintained on the user’s computer and the webserver.
Trusted Monitor Network Latency. Our Trusted Mon-
itor uses a TCP connection between the Nokia E51 smart-
phone and the user’s computer. If there is signiﬁcant net-
work latency, then the Trusted Monitor may not be display-
ing the correct URL and favicon when the user looks at
it. The smartphone can access the Internet using either its
10.1 Bumpy Design Alternatives
@@ at Any Time. As presented, the secure attention se-
quence for Bumpy is the @@ sequence immediately follow-
ing a focus event from the web browser GUI. There are no
technical limitations to enabling a secure attention sequence
at any time, regardless of where in a ﬁeld the cursor may be.
However, we anticipate signiﬁcant usability challenges for
all but the most savvy users. This may prove to be an inter-
esting direction for future work.
Editing Bumpy-Protected Input. As presented (Sec-
tion 4.1), Bumpy ignores non-display characters that do
not cause a blur event in the web browser GUI while the
user is entering sensitive data. Examples of such characters
are backspace and the arrow keys. Here too, there are no
technical limitations to enabling the user to edit her opaque
(from the browser’s perspective) data. However, we are
concerned about a malicious browser tampering with the
cursor and confusing the user. Additional investigation is
warranted to determine whether this attack amounts to any-
thing beyond a denial-of-service attack (e.g., to get better
data for a keystroke timing attack [32]).
Trusted Path Between Trusted Monitor and Webserver.
There are many circumstances where the lack of a trusted
path from a remote server to a user with a compromised
computer can lead to the user’s loss of sensitive informa-
tion. For example, when a remote server checks an attes-
tation from the user’s computer and ﬁnds known malware
installed, it is desirable to inform the user that her system is
compromised. Other researchers have considered the use of
PDAs or smartphones in such roles (e.g., Balfanz et al. [2]),
but we consider this enhancement to Bumpy to be beyond
the scope of the current paper.
PreP as Password Store. The direct-encryption PoPr
breaks the web browser’s ability to remember passwords on
behalf of the user. This feature can be reenabled using the
PreP or PoPr as a password store, and the Trusted Monitor
as the interface to select a stored password.
10.2 Other Interesting Features
Password Leak Detection. A compelling feature that can
readily be added to a PreP is to look for the user’s pass-
word(s) in the input stream and detect whether it appears
when input protections are not enabled. This may allow the