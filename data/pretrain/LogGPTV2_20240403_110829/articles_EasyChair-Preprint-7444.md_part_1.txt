EasyChair Preprint
№ 7444
LogNG: an Online Log Parsing Method Based on
N-Gram
Xiangrui Liu, Shi Ying, Xinquan Ge, Shengkang Hu and
Tiangang Li
EasyChair preprints are intended for rapid
dissemination of research results and are
integrated with the rest of EasyChair.
February 8, 2022
LogNG: An Online Log Parsing Method Based on
N-gram
1st Xiangrui Liu 2nd Shi Ying 3rd Xinquan Ge 4th Shengkang Hu
School of Computer Science School of Computer Science School of Computer Science School of Computer Science
Wuhan University Wuhan University Wuhan University Wuhan University
Wuhan, China Wuhan, China Wuhan, China Wuhan, China
PI:EMAIL PI:EMAIL PI:EMAIL PI:EMAIL
5th Tiangang Li
School of Computer Science
Wuhan University
City, Country
PI:EMAIL
Abstract—Thefirststepinautomaticloganalysisislogparsing. tainers ”) The position of the dynamic variable in the
The number of logs exploded with the increase in system size. log template is marked with a wildcard ””.
Manual analysis of logs has become a difficult problem. To
solve this problem, we proposed logNG, an online log parsing
method based on N-gram that can efficiently parse logs in a
Log Record
streaming manner without the requirement for historical data LOG.info("Got allocated containers " + variable)
Statement
training. When log messages are input in a stream, we first
dividelogmessagesofdifferentlengthsintodifferentloggroups.
We’ll use an intuitive and simple assumption: If continuous
multipledifferenttokensappearbetweenlogmessages,theselog Raw Log 2015-10-18 18:01:56,916 INFO [RMCommunicator Allocator]
messages belong to different log template. For each log group, Message org.apache.hadoop.mapreduce.v2.app.rm.RMContainerAllocator: Got allocated containers 1
we will use N-gram for template matching to further group
Log Parsing
log messages within our assumption. We evaluate and compare
logNG with other log parsers on public data sets. The results Header Information:2015-10-18 18:01:56,916 INFO [RMCommunicator Allocator]
of the experiments reveal that logNG can achieve the highest org.apache.hadoop.mapreduce.v2.app.rm.RMContainerAllocator:
Date:2015-10-18 Time:18:01:56 Level:916 INFO Process:[RMCommunicator Allocator]
accuracy and efficiency.
Parsed Component:org.apache.hadoop.mapreduce.v2.app.rm.RMContainerAllocator:
Index Terms—Log parsing, Online algorithm, N-gram
Log
Content:Got allocated containers 1
Static text:Got allocated containers
I. INTRODUCTION Dynamic variable:1
Log Template：Got allocated containers 
Logs play an important role in modern software systems,
but mining its value is still a huge challenge [1], [2], [3], [4].
Fig.1. TheLogParsingProcessofaRawLogMessagefromHadoop.
Log parsing is the first step in automatic log analysis. The
quality of log parsing greatly affects the downstream tasks In this paper, we propose an online automatic log parsing
of automatic log analysis [5], [6], [7]. The definition of log method logNG, which accurately and efficiently parses the
parsingistoconvertunstructureddataintostructureddata[8], rawlogmessagesinastreamingmanner.logNGautomatically
[9]. Its purpose is to separate header information (including extracts log templates from raw log messages without source
date, time, level, etc.) and content (including static text and code and historical log data.
dynamic variables) [10], [11], [12]. We evaluated logNG and other log parsers on real log data
As shown in “Fig. 1”, when the system is running, a log sets collected by the LogPai team1 [14]. logNG achieved the
record statement will generate a raw log message [13], which highest results on most of the data sets, and it was also very
usuallyconsistsofheaderinformationandcontent.Theheader fast in running time.
information is usually composed of date (“2015-10-18”), time Ingeneral,ourworkmainlyhasthefollowingcontributions:
(“18:01:56”), level (“916 INFO”) and other parts.
• This paper proposes logNG, an online automatic log
Log parsing requires more content (“Got allocated con- parsingmethod.Thelogmessagesweinputintheformof
tainers”) than the header information which can be filtered a stream are divided into different log groups according
out by regular expressions. The content consists of the static to their length. For each log group, we use N-gram to
text of the log record statement (”“Got allocated containers”) further divide log messages for template matching.
and its designated dynamic variable (“1”). The log template
corresponding to this log message is (”“Got allocated con- 1https://github.com/logpai/logparser
• Our method not only solves the problem of manually Whentheloggroupiscreatedforthefirsttime,wedirectly
parsing log templates, but also is an online method that assign the content of the log message to Template. At this
does not require collection of historical data for training. time, logNG has not distinguished between static text and
• The experimental results on real log data sets prove the dynamic variables. When the next log message comes, we
accuracy and high efficiency of logNG. will match it with Template of the existing log group. If the
match is successful, logNG will compare Template with this
II. RELATEDWORK log message. logNG will recognize static text and dynamic
Rule-based log parsing relies on artificial heuristic rules variables, and finally update.
(basically in the form of regular expressions) to parse logs. TemplateID refers to the ID of Template. The log group
However, this approach is not feasible due to rapid develop- list is empty at the beginning. There is no log group, and
ment of log size [15], [16], [17], [18], [19]. TemplateID value does not exist at this time. When a new log
Log parings based on source code has been supported by group is generated, logNG assign TemplateID to 1. After that,
some research [20], [21]. However, this method is actually whenever a new log group appears, logNG will assign a new
difficult to achieve because of unavailability of source code. TemplateID, the value of which is the previous TemplateID
plus 1, so that TemplateID value is equivalent to the sequence
Log parsing based on data mining does not require source
number of this log group in the log group list. For example,
code, but uses various data mining techniques to separate
TemplateID in “Fig. 2” is 13, indicating that this is the 13th
dynamicvariablesandstatictextbyminingthecharacteristics
loggroupandlogtemplategeneratedandidentifiedbylogNG.
in the log [22].
LogIDList is a list of the log ID. Each log message has a
LKE [23] is a representative algorithm for log parsing. In
corresponding log ID. When the log message matches the log
this offline parser, log messages are hierarchically clustered
group, the LogIDList of the log group will add the ID value
using weighted edit distance, and log keys are generated from
of the log message. For example, LogIDList in “Fig. 2” is
the generated cluster. The log key corresponds to the log
[1,22,56,168,245. ..], this means that log messages with log
print statement. After the log message is converted to the log
ID 1, 22, 56, 168, 245, etc. match Template with TemplateID
key, a finite state automaton is learned from the training log
13.
sequence.
LogMine [24] is an unsupervised framework. It only scans
log messages once and works in an iterative manner to Log Group List
generate a pattern hierarchy that can be extracted from a set Log Group Log Group Log Group Log Group
of log messages quickly and efficiently High-quality mode, Template:VeT rie fm icap tl ia ot ne I sD u: c1 c3
eeded for 
LogIDListL :[e 1n ,2g 2t ,h 5: 64
which can process millions of log messages in a few seconds. ,168,245...]
MoLFI [25] is a tool for solving the problem of log
message format identification. It reconstructs the problem of
log message identification into a multi-objective problem and Fig.2. DataStructure.
uses an evolutionary method to solve this problem.
2) Hierarchical Structure: logNG is divided into 4 hierar-
SHISO [26] is an online method of mining log formats and
chical structures from beginning to end, as shown in “Fig. 3”.
retrievinglogtypesandparameters.Itcreatesastructuredtree
When the raw log message is input into the logNG, it
by using nodes generated from log messages.
firstpassesthroughthepreprocessinglayer.Thepreprocessing
III. METHODOLOGY layer will filter out the header information part of the raw log
message first, and mark some fixed format data (such as IP
A. Method Overview
address, blockID, etc.) as “”, tofacilitate the subsequent
1) Data Structure: A good data structure can be more parsing process.
convenient for us to analyze. We introduced a data structure, In the length layer, logNG will divide log messages into
the log group, as shown in “Fig. 2”. differentloggroupsbylength.Taking“Fig.3”asanexample,
The log group is a data structure with four attributes, log messages can be divided into groups of the length less
including Template, Length, TemplateID, and LogIDList. In than 3, the length less than 4, and the length equal to 5 and
this paper, italicized and capitalized words indicate attributes. so on.
Before the logs are entered in the form of a stream, we It should be noted that when the length of the log message
first create an empty log group list. When log messages are is less than N, logNG cannot parse this kind of log message
continuouslyinput,logNGwillcreateloggroupsandaddthem becausethelengthisnotenough.WhenlogNGencountersthis
to the log group list. situation, it first checks whether the log group corresponding
Each attribute of the log group has its role. As the name to this log message has been saved in the log group list. If so,
implies, Template and Length are the log template parsed by itonlyaddstheIDofthelogmessagetoLogIDList ofthelog
our parser and the number of tokens. Taking the log group group. If not, it creates a new log group directly.
in “Fig. 2” as an example, Length is 4 and Template is In the matching layer, logNG will make N-gram judgments
“Verification succeeded for ”. on log messages and divide them into more detailed log