    assert(p*q==n2)
    phi=(p-1)*(q-1)
    d=gmpy2.invert(e2,phi)
    c_bytes=open("flag_encry2","rb").read()
    c=bytes_to_long(c_bytes)
    m=pow(c,d,n2)
    flag=long_to_bytes(m)
    print(flag)
## [INSHack2019]Yet Another RSA Challenge – Part 1
  * 题目链接（buu平台）
[https://buuoj.cn/challenges#[INSHack2019]Yet Another RSA Challenge – Part
1](https://buuoj.cn/challenges#%5BINSHack2019%5DYet%20Another%20RSA%20Challenge%20-%20Part%201)
  * 附件 
    * yarsac.py
    * output.txt
题面很清晰，就是一个RSA加密，然后给了公钥n的其中有一个因子p，但是p是16进制表示的，最后输出的时候把9F替换成了FC。那么我们在给的output.txt文件中得到p的时候，其中的FC的位置就有可能为9F，亦有可能为FC。这边写个脚本爆破一下求解即可。
  * 题解exp如下： 
        import gmpy2
    from Crypto.Util.number import *
    n=719579745653303119025873098043848913976880838286635817351790189702008424828505522253331968992725441130409959387942238566082746772468987336980704680915524591881919460709921709513741059003955050088052599067720107149755856317364317707629467090624585752920523062378696431510814381603360130752588995217840721808871896469275562085215852034302374902524921137398710508865248881286824902780186249148613287250056380811479959269915786545911048030947364841177976623684660771594747297272818410589981294227084173316280447729440036251406684111603371364957690353449585185893322538541593242187738587675489180722498945337715511212885934126635221601469699184812336984707723198731876940991485904637481371763302337637617744175461566445514603405016576604569057507997291470369704260553992902776099599438704680775883984720946337235834374667842758010444010254965664863296455406931885650448386682827401907759661117637294838753325610213809162253020362015045242003388829769019579522792182295457962911430276020610658073659629786668639126004851910536565721128484604554703970965744790413684836096724064390486888113608024265771815004188203124405817878645103282802994701531113849607969243815078720289912255827700390198089699808626116357304202660642601149742427766381
    cipher=596380963583874022971492302071822444225514552231574984926542429117396590795270181084030717066220888052607057994262255729890598322976783889090993129161030148064314476199052180347747135088933481343974996843632511300255010825580875930722684714290535684951679115573751200980708359500292172387447570080875531002842462002727646367063816531958020271149645805755077133231395881833164790825731218786554806777097126212126561056170733032553159740167058242065879953688453169613384659653035659118823444582576657499974059388261153064772228570460351169216103620379299362366574826080703907036316546232196313193923841110510170689800892941998845140534954264505413254429240789223724066502818922164419890197058252325607667959185100118251170368909192832882776642565026481260424714348087206462283972676596101498123547647078981435969530082351104111747783346230914935599764345176602456069568419879060577771404946743580809330315332836749661503035076868102720709045692483171306425207758972682717326821412843569770615848397477633761506670219845039890098105484693890695897858251238713238301401843678654564558196040100908796513657968507381392735855990706254646471937809011610992016368630851454275478216664521360246605400986428230407975530880206404171034278692756
    e=65537
    guess=["9F","FC"]
    p_=0
    for a in guess:
      for b in guess:
          for c in guess:
              for d in guess:
                  p="DCC5A0BD3A1"+a+"0BEB0DA1C2E8CF6B474481B7C12849B76E03C4C946724DB577D2825D6AA193DB559BC9DBABE1DDE8B5E7805E48749EF002F622F7CDBD7853B200E2A027E87E331A"+b+"FD066ED9900F1E5F5E5196A451A6F9E329EB889D773F08E5FBF45AACB818FD186DD74626180294DCC31805A88D1B71DE5BFEF3ED01F12678D906A833A78EDCE9BDAF22BBE45C0BFB7A82AFE42C1C3B8581C83BF43DFE31BFD81527E507686956458905CC9A660604552A060109DC81D01F229A264AB67C6D7168721AB36DE769CEAFB97F238050193EC942078DDF5329A387F46253A4411A9C8BB71F9AEB11AC9623E41C14"+c+"D2739D76E69283E57DDB11"+d+"531B4611EE3"
                  p=int(p,16)
                  q=n//p
                  if (p*q==n):
                      p_=p
    p=p_
    q=n//p
    print(p*q==n)
    phi=(p-1)*(q-1)
    d=gmpy2.invert(e,phi)
    m=pow(cipher,d,n)
    flag=long_to_bytes(m)
    print(flag)
## [GUET-CTF2019]NO SOS
  * 题目链接（buu平台）
[https://buuoj.cn/challenges#[GUET-CTF2019]NO
SOS](https://buuoj.cn/challenges#%5BGUET-CTF2019%5DNO%20SOS)
  * 附件： 
    * attachment.txt
首先发现一个很类似摩斯电码的东西。但是题目也写了no
sos，所以应该不是莫斯电码。并且也发现没有间隔。与之类似的有可能是2进制的表示或者培根密码。这边将.转为A将—转为B后发现位数刚好为5的倍数。
培根密码解密得到flag
## [UTCTF2020]basic-crypto
  * 题目链接（buu平台）
[https://buuoj.cn/challenges#[UTCTF2020]basic-crypto](https://buuoj.cn/challenges#%5BUTCTF2020%5Dbasic-crypto)
  * 附件： 
    * attachment.txt
这题附件里面表示的就很明显，每一组都是8位二进制。直接转ascii字符即可。
  * 题解exp如下： 
        f=open("attachment.txt","r")
    arr=f.read().split(" ")
    re=""
    for i in arr:
      re+=chr(int(i,2))
    print(re)
## [ACTF新生赛2020]crypto-rsa3
  * 题目链接（buu平台）
[https://buuoj.cn/challenges#[ACTF新生赛2020]crypto-rsa3](https://buuoj.cn/challenges#%5BACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020%5Dcrypto-rsa3)
  * 附件： 
    * rsa3.py
    * output.txt
可以发现就是最基础的RSA加密，其中p q为相邻的素数。直接yafu分解即可。
然后基础RSA解密即可
题解exp如下：
    n=177606504836499246970959030226871608885969321778211051080524634084516973331441644993898029573612290095853069264036530459253652875586267946877831055147546910227100566496658148381834683037366134553848011903251252726474047661274223137727688689535823533046778793131902143444408735610821167838717488859902242863683
    c=1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049
    e=65537
    p = 13326909050357447643526585836833969378078147057723054701432842192988717649385731430095055622303549577233495793715580004801634268505725255565021519817179293
    q = 13326909050357447643526585836833969378078147057723054701432842192988717649385731430095055622303549577233495793715580004801634268505725255565021519817179231
    from Crypto.Util.number import *
    import gmpy2
    phi=(p-1)*(q-1)
    d=gmpy2.invert(e,phi)
    m=pow(c,d,n)
    flag=long_to_bytes(m)
    print(flag)
## [MRCTF2020]babyRSA
  * 题目链接（buu平台）
[https://buuoj.cn/challenges#[MRCTF2020]babyRSA](https://buuoj.cn/challenges#%5BMRCTF2020%5DbabyRSA)
  * 附件： 
    * baby_RSA.py
题目脚本比较长，一步一步分析。
    if __name__ == "__main__":
        _E = base
        _P = gen_p()
        _Q = gen_q()
        assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1)
        _M = bytes_to_long(flag)
        _C = pow(_M, _E, _P * _Q)
        print("Ciphertext = ", _C)
首先，在主函数里面可以看到。其实这就是一个RSA加密。无非是_P和_Q都是带入了两个函数里面求解的。
    def gen_q():
        sub_Q = getPrime(1024)
        Q_1 = getPrime(1024)
        Q_2 = getPrime(1024)
        Q = sub_Q ** Q_2 % Q_1
        print("Q_1: ", Q_1)
        print("Q_2: ", Q_2)
        print("sub_Q: ", sub_Q)
        return sympy.nextprime(Q)
_Q这个参数的话可以看到我们已知Q_1、Q_2、sub_Q就可以直接求解。
    import sympy
    import gmpy2
    from Crypto.Util.number import *
    Q_1=103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
    Q_2=151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
    sub_Q=168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
    Q=pow(sub_Q,Q_2, Q_1)
    q=sympy.nextprime(Q)
    print(q)
然后看到gen_p()这个函数
    def gen_p():
        P = [0 for i in range(17)]
        P[0] = getPrime(128)
        for i in range(1, 17):
            P[i] = sympy.nextprime(P[i-1])
        print("P_p :", P[9])
        n = 1
        for i in range(17):
            n *= P[i]
        p = getPrime(1024)
        factor = pow(p, base, n)
        print("P_factor :", factor)
        return sympy.nextprime(p)
这边我们要求解p，其实就相当于求解一个RSA。n是由17个连续的质数作为因子的。然后我们得到了其中的第十个也就是下标为9的因子。那么我们通过sympy.prevprime和sympy.nextprime去求解得到所有的质数进行RSA基础解密得到p，然后取p的下一个质数作为_P即可。
  * 题解exp如下： 
        import sympy
    import gmpy2
    from Crypto.Util.number import *
    Q_1=103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
    Q_2=151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
    sub_Q=168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
    Q=pow(sub_Q,Q_2, Q_1)
    q=sympy.nextprime(Q)
    print(q)
    P_p=206027926847308612719677572554991143421
    P=[]
    for i in range(9):
      P_p=sympy.prevprime(P_p)
      P.append(P_p)
    P=P[::-1]
    P_p=206027926847308612719677572554991143421
    P.append(P_p)
    for i in range(9):
      P_p=sympy.nextprime(P_p)
      P.append(P_p)
    n_p=1
    for i in range(17):
      n_p *= P[i]
    phi_p=1
    for i in range(17):
      phi_p *= (P[i]-1)
    P_factor=213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839
    base = 65537
    d_p=gmpy2.invert(base,phi_p)
    p=sympy.nextprime(pow(P_factor,d_p,n_p))
    Ciphertext =  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832
    phi=(p-1)*(q-1)
    d=gmpy2.invert(base,phi)
    m=pow(Ciphertext,d,p*q)
    flag=long_to_bytes(m)
    print(flag)
## [WUSTCTF2020]dp_leaking_1s_very_d@angerous
  * 题目链接（buu平台）  
https://buuoj.cn/challenges#[WUSTCTF2020]dp_leaking_1s_very_d@angerous
  * 附件： 
    * attachment
题意很明显，是dp泄露。
    dp=d%(p-1)
这种参数是为了让解密的时候更快速产生的
  * 题解exp如下： 
        import  gmpy2
    import  rsa
    import  binascii
    p=0
    e=65537
    n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847
    c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869
    dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825
    temp=dp*e
    for i in range(1,e) :
      if (temp-1)%i==0:
          x=(temp-1)//i+1
          y=n%x
          if y==0:
              p=x
              break
    q=n//p
    d=gmpy2.invert(e,(p-1)*(q-1))
    key=rsa.PrivateKey(n,e,d,p,q)
    m=pow(c,d,n)
    print(binascii.unhexlify(hex(m)[2:]))