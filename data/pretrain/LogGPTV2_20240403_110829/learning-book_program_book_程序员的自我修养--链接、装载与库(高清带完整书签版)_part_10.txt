hello.
(ooB)
Object Fle
Assembly
Assembly
ibc.s
hello.o
(as)
hello.s
Linking
Executable
(l)
a.out
图2-1GCC编译过程分解
2.1.1预编译
首先是源代码文件hello.c和相关的头文件，如 stdio.h等被预编译器cpp预编译成一个.i
文件。对于C++程序来说，它的源代码文件的扩展名可能是.cpp或cxx，头文件的扩展名可
能是.hpp，而预编译后的文件扩展名是i。第一步预编译的过程相当于如下命令（-E表示只
进行预编译）：
Sgcc -E hello.c -o he11o.i
或者：
$cpp he11o.c > hel1o.i
预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如“include”、
“#define”等，主要处理规则如下：
·将所有的“#define”删除，并且展开所有的宏定义。
·处理所有条件预编译指令，比如“wir"、“ifder"、“#elir”、“#else”、“endif"。
处理“include”预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这
个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
·删除所有的注释“/”和“/*"/”
信息及用于编译时产生编译错误或警告时能够显示行号。
·保留所有的#pragma编译器指令，因为编译器须要使用它们。
经过预编译后的i文件不包含任何宏定文，因为所有的宏已经被展开，并且包含的文件
程序员的自我修养—链接、装载与库
---
## Page 63
40
第2章编译和链接
也已经被插入到i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，
可以查看预编译后的文件来确定问题。
2.1.2编译
编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生
产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂
的部分之一，我们将在下一节简单介绍编译的具体几个步骤，这涉及编译原理等一些内容，
由于它不是本书介绍的核心内容，所以也仅仅是介绍而已。上面的编译过程相当于如下命令：
$gcc =S he1lo.i -o he11o.s
现在版本的GCC把预编译和编译两个步骤合并成一个步骤，使用一个叫做ccI的程序
来完成这两个步骤。这个程序位于“/usr/lib/gcc/i486-linux-gnu/4.1/”，我们也可以直接调用
cc1来完成它：
$ /usr/1ib/gcc/i486-1inux-gnu/4.1/cc1 he11o.c
Execution times (seconds)
main
preprocessing
:0.01 (100%)u8r 0.01 (33$)8y8 0.004 0$)wa11 77 kB(88)ggc
parser
:0.00 ( 0%)usr
0.00(08)sys 0.01(25$)wa11
125kB(13e)ggc
expand
5（）9 （0)000（8）10029n（0）00*01
TOTAL
: 0 .01
0 . 03
0.04
982 kB
或者使用如下命令：
Sgcc -S hello,c =o he11o.s
都可以得到汇编输出文件hello.s.对于C语言的代码来说，这个预编译和编译的程序是cc1，
对于C++来说，有对应的程序叫做cclplus：Objective-C是cclobj：forran是r771：Java是
jc1。所以实际上gcc这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用
预编译编译程序cc1、汇编器as、链接器ld.
2.1.3汇编
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器
指令，所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，
也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编”
这个名字也来源于此。上面的汇编过程我们可以调用汇编器as来完成：
$as hello.8 -o bel1o.0
或者：
$gcc -c he1lo.8 -0 hel1o.0
程序员的自我修养一链接、装载与库
---
## Page 64
2.2编译器做了什么
41
或者使用gc命令从C源代码文件开始，经过预编译、编译和汇编直接输出目标文件（Object
File ):
$gcc -c he11o.c -o he11o.0
2.1.4链接
链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件面是输出一
个目标文件呢？链接过程到底包含了什么内容？为什么要链接？这恐怕是很多读者心中的
疑惑。正是因为这些疑惑总是挥之不去，所以我们特意用这一章的篇幅来分析链接，具体地
说分析静态链接的章节，下面让我们来看看怎么样调用d才可以产生一个能够正常运行的
HelloWorld 程序：
$1d -static /uar/1ib/crt1.o/uer/lib/crti.o
-L/u8r/1ib/gce/1486-11inux-gnu/4.1.3 -L/usr/1ib -L/1ib he11o.o --atart-group
/usr/1ib/gcc/1486-1inux-gnu/4.1.3/crtbeginr.o
/usr/1ib/crtn.o
-1gcc -1gcc_eh -1c --end-group/u8r/1ib/gce/1486-11nux-gna/4.1.3/crtend.o
如果把所有的路径都省略掉，那么上面的命令就是：
1d -static crt1.o crti.o crtbeginT.o hello.o -start-group -1gcc -1gcc_eh -1c
-end-group crtend.o crtn.o
可以看到，我们需要将一大堆文件链接起来才可以得到“aout”，即最终的可执行文件。
看了这行复杂的命令，可能很多读者的疑感更多了，crtl.o、crti.o、crtbeginT.o、crtend.o、
crtn.o这些文件是什么？它们做什么用的？-lgcc-lgcc_ehlc这些都是什么参数？为什么要
使用它们？为什么要将它们和hello.o链接起来才可以得到可执行文件？等等。
这些问题正是本书所需要介绍的内容，它们看似简单，其实涉及了编译、链接和库，甚
至是操作系统的一些很底层的内容，我们将紧紧围绕着这些内容，进行必要的分析。不过在
分析这些内容之前，我们还是来关注一下上面这些过程中，编译器担任了一个什么样的角色。
2.2编译器做了什么
从最直观的角度来讲，编译器就是将高级语言翻译成机器语言的一个工具。比如我们用
C/C++语言写的一个程序可以使用编译器将其翻译成机器可以执行的指令及数据。我们前面
也提到了，使用机器指令或汇编语言编写程序是十分费事及乏味的事情，它们使得程序开发
的效率十分低下。并且使用机器语言或汇编语言编写的程序依赖于特定的机器，一个为某种
CPU编写的程序在另外一种CPU下完全无法运行，需要重新编写，这儿乎是令人无法接受
的。所以人们期望能够采用类似于自然语言的语言来描述一个程序，但是自然语言的形式不
程序负的自找修养一链接、装载与库
---
## Page 65
42
第2章编译和链接
够精确，所以类似于数学定义的编程语言很快就诞生了，20世纪的六七十年代诞生了很多
高级语言，有些至今仍然非常流行，如FORTRAN、C语言等（准确地讲，FORTRAN诞生
于20世纪50年代的IBM）。高级语言使得程序员们能够更加关注程序逻辑的本身，而尽量
少考虑计算机本身的限制，如字长、内存大小、通信方式、存储方式等。高级编程语言的出
现使得程序开发的效率大大提高，高级语言的可移植性也使得它在多种计算机平台下能够游
刃有余。据研究，高级语言的开发效率是汇编语言和机器语言的5倍以上。
让我们继续回到编译器本身的职责上来，编译过程一般可以分为6步：扫描、语法分析、
语义分析、源代码优化、代码生成和目标代码优化。整个过程如图2-2所示。
Source
Code
Scannef-
Tokens
Parser
Syntax
Tree
Semantic
Analyzer
Source
Code
Syntax
Optimizer
Tree
Code
Teget
Code
图2-2编译过程
我们将结合图2-2来简单描述从源代码（Source Code）到最终目标代码（FinalTarget
Code）的过程，以一段很简单的C语言的代码为例子来讲述这个过程，比如我们有一行C
语言的源代码如下：
array [index] =(index + 4) *(2 •6)
CompilerExpression.c
2.2.1
词法分析
首先源代码程序被输入到扫描器（Scanner），扫描器的任务很简单，它只是简单地进
行词法分析，运用一种类似于有限状态机（FiniteStateMachine）的算法可以很轻松地将源
代码的字符序列分制成一系列的记号（Token）。比如上面的那行程序，总共包含了28个非
空字符，经过扫描以后，产生了16个记号，如表2-1所示。
表2-1
记号
类型
array
标识符
左方括号
程序员的自我修养一链接、装载与库
---
## Page 66
2.2编译器做了什么
43
续气
记号
类型
index
标识符
1
右方括号
=
赋值
左圆括号
index
标识持
+
加号
4
数字
）
右国括号
乘号
左图括号
2
数字
加号
6
数字
右禹括号
词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量（包含数字、字
符串等）和特殊符号（如加号、等号），在识别记号的同时，扫描器也完成了其他工作，比
如将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。
有一个叫做lex的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入
的字符串分割成一个个记号。因为这样个程序的存在，编译器的开发者就无须为每个编译
器开发一个独立的词法扫描器，而是根据需要改变词法规则就可以了。
另外对于一些有预处理的语言，比如C语言，它的宏替换和文件包含等工作一般不归
入编译器的范围而交给一个独立的预处理器。
2.2.2语法分析
接下来语法分析器（GrammarParser）将对由扫描器产生的记号进行语法分析，从而
产生语法树（SyntaxTree）。整个分析过程采用了上下文无关语法（Context-free Grammar）
的分析手段，如果你对上下文无关语法及下推自动机很熟悉，那么应该很好理解，否则，可
以参考一些计算理论的资料，一般都会有很详细的介绍。此处不再警述。简单地讲，由语法
分析器生成的语法树就是以表达式（Expression）为节点的树。我们知道，C语言的一个语
句是一个表达式，而复杂的语句是很多表达式的组合。上面例子中的语句就是一个由赋值表
达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句。它在经过语法
分析器以后形成如图2-3所示的语法树。
程序员的自我修养一—链接、装载与库
---
## Page 67
44
第2章编译和链接
Assign
Expression
Multiplicaive
Expression
Addiive
Expres
Iden
btie
Pidex
图2-3语法树
从图2-3中我们可以看到，整个语句被看作是一个赋值表达式：赋值表达式的左边是
个数组表达式，它的右边是一个乘法表达式：数组表达式又由两个符号表达式组成，等等。
符号和数字是最小的表达式，它们不是由其他的表达式来组成的，所以它们通常作为整个语
法树的叶节点。在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。比如乘
法表达式的优先级比加法高，而圆括号表达式的优先级比乘法高，等等，另外有些符号具有
多重含义，比如星号*在C语言中可以表示乘法表达式，也可以表示对指针取内容的表达式，
所以语法分析阶段必须对这些内容进行区分，如果出现了表达式不合法，比如各种括号不匹
配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。
正如前面词法分析有 lex一样，语法分析也有一个现成的T.具叫做yacc（Yet Another
CompilerCompiler）。它也像lex-样，可以根据用户给定的语法规则对输入的记号序列进行
解析，从面构建出一棵语法树。对于不同的编程语言，编译器的开发者只须改变语法规则，
而无须为每个编译器编写一个语法分析器，所以它又被称为“编译器编泽器（Compiler
Compiler)*.
2.2.3
语义分析
接下米进行的是语义分析，由语义分析器（SemanticAnalyzer）来完成。语法分析仅
仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句是否真正有意义。比如C
语言里面两个指针做乘法运算是没有意义的，但是这个语句在语法上是合法的：比如同样一