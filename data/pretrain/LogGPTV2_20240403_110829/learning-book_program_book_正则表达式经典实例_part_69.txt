## Page 373
我们使用或<>将匹配定位到字符串的开头。使用[a-z][a-z0-9+\-.]*：/>跳过通信
协议方案，并且使用跳过授权。鉴于已经知道URL是合法的，并且我们对
从授权中抽取用户名、主机和端口号不感兴趣，因此就可以为授权使用非常简单的正
则式。
授权以两个正斜杠作为开始，一直匹配到路径的开始（正斜杠）、查询的开始（问号）
或者是片段的开始（井号）。其中的否定字符类会匹配下一个正斜杠、问号或井号之前
的一切内容（参考实例2.3）。
因为授权是可选的，所以我们会把它放进一个分组中，在它的后面紧跟着一个问号：
。通信协议方案也是可选的。如果通信协议方案被省略，那么授权就必须
被省略。为了匹配这一点，我们把正则式中匹配通信协议方案和可选的授权放到另外
一个分组中，同时用一个问号把它也变成是可选的。
因为URL已知是合法的，所以我们可以很容易地用单个字符类来匹配包括正斜杠的路
径：匹配到任何东西。这样就会匹配到//www.regexcookbook.com为路径，这显然不是我们想
要的。如果为路径使用一个更为准确的正则式，不允许出现成对的正斜杠，那幺正则
式引擎就会简单地再次回溯，这次会假设URL中不包含通信协议方案。对路径使用一
个更加准确的正则式，它可能会把http匹配为路径。为了防止这一点，我们要再加上
一个检查，确保路径后跟随着查询、片段或者什么也没有。如果做到了全部这些检查，
那么我们得到的就是本实例的“解决方案”中标明为“只匹配实际含有路径的URL”
URL、路径和Internet地址357
www.TopSage.com
---
## Page 374
的正则表达式。这个正则表达式比前面两个要更复杂一些，而这些增加的复杂性只是
为了让正则式不要匹配不含路径的URL。
如果你的正则流派支持原子分组，那么就可以使用更简单的办法。本书中讨论的所有
流派除了JavaScript和Python外，都支持原子分组（参见实例2.15)。本质上来说，一
个原子分组的首要作用是告知正则式引擎不需要回溯。如果我们把正则式的通信协议
方案和授权部分放到一个原子分组里，即使匹配路径的字符类没有余下的可匹配空间，
正则引擎也会被强迫保留通信协议方案和授权部分所匹配到的内容。这种解决方案与
把路径改成可选的一样高效。
不管你在本实例中选择了哪种正则表达式，路径都会保存在第3个捕获分组中。如果
你使用了前两个充许路径是可选的正则式，那么第3个捕获分组就可能会返回空字符
串，或者是在JavaScript中返回null。
如果你并不知道自标文本是一个合法的URL，那么可以使用实例7.7中的正则式。如
集你使用的是.NET，那么你可以使用.NET专用的正则式，其中包含了3个名为"path”
的分组，它们会分别捕获可能会匹配到URL路径的3个正则式组成部分。如果你使用
的是另外一种支持命名捕获的流派，那么路径会被捕获到如下3个分组之一中：
“hostpath”、“schemepath”或者“relpath”。因为3个路径中只有-个实际会捕获到真正
的路径，因此可以用一个简单的小窍门，把这3个分组所返回的字符串连接起来就可
以获得路径。因为它们中的两个一定会返回空字符事，所以并不会有实际的连接发生。
如果你喜欢使用的编程语言并不支持命名捕获，那么可以使用实例7.7中的第一个正则
式。它会在分组6、7或8中捕获路径。你可以用同样的小跨门来连接3个分组获得的
文本，因为它们中的2个只会返回空字符串。不过在Javascript中这样就行不通。
JavaScript会对没有实际参与匹配的分组返回undefined。
关于在你喜欢使用的编程语言中，如何从命名和编号捕获分组所匹配的文本中提取文
本，可以参考实例3.9中的讲解。
参见
实例2.9、实例3.9和实例7.7。
7.13从URL中抽取查询
问题描述
你想要从一个包含URL的字符串中抽取其中的查询（query）。例如，你想要从
http://www.regexcookbook.com？param=value或者/index.html?param=value中抽取其中
的param=value。
358第7章
www.TopSage.com
---
## Page 375
解决方案
[？#]+\？（[~#]+)
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
如果已知你的目标文本是个合法的URL，那么从URL中抽取查询是件很轻松的事。查询和
它之前的URL部分之间会用一个问号进行分隔。这是URL中第一个允许出现问号的地方。
因此，我们可以用个[~?#+\?简单地跳过第一个问号之前的部分。只有在字符类之外的问
号才是个元字符，而在字符类内则不是。所以我们要为这个字符类外的字面上的问号进行
转义。第一个是一个定位符（实例2.5），第二个则用来对字符类取反（实例2.3）。
在查询之后，问号可以作为（可选的）片段中的一部分出现在URL中，所以只用（?)
是不行的，我们需要使用个[^?#]+\?>以确保所获得的是在URL中的第一个问号，从而
可以确保这个问号并不会出现在不包含查询的URL的片段中。
查询的部分一直延伸到片段开始部分或者URL的结尾为止。片段会用一个井号和URL
的其余部分隔开。因为并号只能在片段部分出现，所以我们只需要用#+>来匹配查
询。这个否定字符类匹配到第一个井号出现前的所有字符，当目标文本不含有任何并
号的时候，它会匹配到目标字符串结尾为止。
只有当URL确实含有一个查询时，这个正则表达式才能找到一个匹配。当匹配到一个
URL时，匹配中会包括从URL开端开始的任何字符，所以我们需要把正则式匹配到的
查询的部分{#+>放到一个捕获分组中。当正则式找到匹配时，你可以提取第一个（也
是唯一的）捕获分组来获取匹配到的文本，就可以得到不含任何分隔符或者URL其他
部分的查询部分。关于捕获分组的讲解请参考实例2.9。关于在习惯使用的编程语言中
如何提取捕获分组匹配到的文本，请参看实例3.9。
如果你尚不清楚目标文本是否是-一个合法的URL，那么可以使用实例7.7中正则式中
的任意一个。当查询存在于URL中时，该实例中的第一个正则式会把查询捕获到第12
个捕获分组中。
参见
实例2.9、实例3.9和实例7.7。
7.14从URL中抽取片段
问题描述
你想要从一个包含URL的字符事中抽取其中的片段（fragment）。例如，你想要从
URL、路径和Internet地址
359
www.TopSage.com
---
## Page 376
解决方案
#(. +)
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
如果已知你的目标文本是个合法的URL，那么从URL中抽取片段是件很轻松的事。
片段和它之前的URL部分之间会用一个井号进行分隔。片段是URL中第一个充许
出现井号的地方，而且片段总是在URL中最后出现的部分。因此，我们可以用《#.+
简单地跳过第一个井号之前的部分，然后把直到字符串结束之前的所有内容都抓下
来。一定要记住关掉宽松排列模式，否则，你就需要对字面的井号用一个反斜杠进
行转义。
只有当URL确实含有-一个片段的时候，这个正则表达式才能找到一个匹配。这个匹配
中只会包含片段中的内容，但是会包含把片段和URL其余部分进行分隔的井号。这个
解决方案中使用了一个额外的捕获分组，只获取片段，把用来分隔的并号去掉。
如果你尚不清楚目标文本是否是一个合法的URL，那么可以使用实例7.7中正则式中
的任意一个。当片段存在于URL中时，该实例中的第一个正则式会把片段捕获到第13
个捕获分组中。
参见
实例2.9、实例3.9和实例7.7。
7.15域名合法性验证
问题描述
你要检查一个字符串是否看起来像-个有效的全限定（fully-qualified）域名，或者在
大段文本中查找一个这样的域名。
解决方案
检查一个字符串是否看起来像一个有效域名：
?
([a-z0-9]+(-[a-z0-9]+) *\.) +[a-z]{2,}$
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
\A（[a-z0-9]+(-[a-z0-9]+) *\.)+[a-z]{2, }\2
360第7章
www.TopSage.com
---
## Page 377
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
在更长的文本中查找合法的域名：
\b（[a-z0-9]+(-[a-z0-9]+) *\.)+[a-z]{2,}\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
检查域名的每个组成部分的长度是否不超过63个字符：
\b((？=[a-z0-9-](1, 63}\.)[a-20-9]+(-[a-z0-9]+) *\.)+[a-z]{2, 63}\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
允许使用Punycode标准编码的国际化域名：
\b((xn--) ?[a-z0-9]+(-[a-z0-9]+) *\.)+[a-z](2,}\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
检查域名的每个部分的长度是否不超过63个字符，并且允许使用Punycode标准编码
的国际化域名：
\b（(？=[a-z0-9-]{1,63}\.)(xn=-) ?[a-z0-9]+(-[a-z0-9]+) *\.)+[a-z]{2,63}\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
域名的格式可以是domain.tld、subdomain.domain.tld或者再加上任何数量的子域名。顶
级域名（tld）由2个或更多字母组成。这是正则式中最简单的部分：[a-z]{2,}>。
域名，或者任何子域名，都是由字母、数字和连字符组成的。连字符不能成对出现，
也不能作为域名中的第一个或者最后一个字符。我们可以用正则表达式
来匹配这样的模式。这个正则式会匹配任何长度的字母和
数字组合，后面可以跟随可选的任意多个分组，每个分组中包含一个连字符以及紧
跟其后的字母数字序列。记住，连字符如果出现在字符类中是一个元字符（实例
2.3），但是在字符类外它就是一个普通字符，所以我们不需要在正则式中对连字符
进行转义。
域名和子域名由字面上的点号分隔开，在正则表达式中以心>表示。既然域名后可添加
任意数量的子域名，我们把正则式的域名部分和字面上的点号放在一个重复的分组中：
，而除了JavaScript之外的所有流派都可以使用和。
更多信息请参见实例2.5。
如果要在一大段文本中查找域名，那么你可以在正则式两边添加单词边界（匹配一个长度为1～63个字符的域名组成部分，或者对
整个域名使用。但是这样就无法排除连字符位置不正
确的字符串了。
要解决这个问题，我们可以使用顺序环视来两次匹配同样的文本。如果不熟悉顺序环
视，可以参阅实例2.16。我们使用同样的正则式[a-z0-9]+(-[a-z0-9]+)*.>匹配带有合法
连字符的域名，并把放在顺序环视中，用来检查它的长度是否同样
少于或等于63个字符。这样我们就可得到如下的正则表达式：（?-[-a-z0-9]{1，63)\)
[a-z0-9]+(-[a-z0-9]+)*\.>
9~9-0--]）
母、数字和连字符。在这里把点号包含在顺序环视中是非常重要的。如果你不
求。只有把字面上的点号放在顺序环视中，我们才能真正满足最多63个字符的
需求。
顺序环视并不会消耗它所匹配到的字符。所以，如果顺序环视匹配成
功，就会被匹配到顺序环视已经匹配到的同一段文本上。我们
已经确认了这段文本的长度不会超过63个字符，现在就可以检查它是否为正确的连字
符和非连字符组合。
国际化域名理论上可以包含几乎所有学符。实际上可以包含的学符列表则是由管理顶
级域名的注册机构决定的。例如，.es允许在域名中包含西班牙语字符。
在实践中，国际化域名常使用所谓punycode编码标准。虽然punycode算法相当复杂，
但是我们在这里关心的是，按照它的规定，域名可以是任何字母、数字和连字符的组
合，这与我们在域名正则表达式中已经使用过的那些规则是一样的。唯一不同的是，
由punycode生成的域名会包含一个前缀xn--。为了在我们的正则式中支持这些域名，
我们只需要在正则式中的匹配域名组成部分的分组内添加xn--)?>。
参见
实例2.3、实例2.12和实例2.16。