## 总结延伸到这里，想必你也应该明白了，我们在这一讲的开头介绍的打孔卡，其实就是一种存储程序型计算机。只是这整个程序的机器码，不是通过计算机编译出来的，而是由程序员，用人脑"编译"成一张张卡片的。对应的程序，也不是存储在设备里，而是存储成一张打好孔的卡片。但是整个程序运行的逻辑和其他CPU 的机器语言没有什么分别，也是处理一串"0"和"1"组成的机器码而已。这一讲里，我们看到了一个 C语言程序，是怎么被编译成为汇编语言，乃至通过汇编器再翻译成机器码的。除了 C 这样的编译型的语言之外，不管是 Python 这样的解释型语言，还是 Java这样使用虚拟机的语言，其实最终都是由不同形式的程序，把我们写好的代码，转换成CPU 能够理解的机器码来执行的。只是解释型语言，是通过解释器在程序运行的时候逐句翻译，而 Java这样使用虚拟机的语言，则是由虚拟机对编译出来的中间代码进行解释，或者即时编译成为机器码来最终执行。然而，单单理解一条指令是怎么变成机器码的肯定是不够的。接下来的几节，我会深入讲解，包含条件、循环、函数、递归这些语句的完整程序，是怎么在CPU 里面执行的。
## 推荐阅读这一讲里，我们用的是相对最简单的 MIPS 指令集作示例。想要对我们日常使用的Intel CPU 的指令集有所了解，可以参看《计算机组成与设计：软 /硬件接口》第 5 版的 2.17 小节。
## 课后思考我们把一个数字在命令行里面打印出来，背后对应的机器码是什么？你可以试试通过GCC 把这个的汇编代码和机器码打出来。欢迎你在留言区写下你的思考和疑问，你也可以把今天的文章分享给你朋友，和他一起学习和进步。![](Images/79d06107d349635530fbf82aa8dfb625.png){savepage-src="https://static001.geekbang.org/resource/image/28/29/281ca28b90c8aa0aecbb5adc08394f29.jpg"}
# 06 \| 指令跳转：原来if\...else就是goto上一讲，我们讲解了一行代码是怎么变成计算机指令的。你平时写的程序中，肯定不只有int a = 1 这样最最简单的代码或者指令。我们总是要用到 if...else这样的条件判断语句、while 和 for 这样的循环语句，还有函数或者过程调用。对应的，CPU 执行的也不只是一条指令，一般一个程序包含很多条指令。因为有if...else、for这样的条件和循环存在，这些指令也不会一路平铺直叙地执行下去。今天我们就在上一节的基础上来看看，一个计算机程序是怎么被分解成一条条指令来执行的。
## CPU 是如何执行指令的？拿我们用的 Intel CPU来说，里面差不多有几百亿个晶体管。实际上，一条条计算机指令执行起来非常复杂。好在CPU在软件层面已经为我们做好了封装。对于我们这些做软件的程序员来说，我们只要知道，写好的代码变成了指令之后，是一条一条**顺序**执行的就可以了。我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，CPU其实就是由一堆寄存器组成的。而寄存器就是 CPU内部，由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。这块内容并不是我们这节课的重点，所以你只要了解就好。如果想要深入学习的话，你可以学习数字电路的相关课程，这里我们不深入探讨。``{=html}好了，现在我们接着前面说。N 个触发器或者锁存器，就可以组成一个 N位（Bit）的寄存器，能够保存 N 位的数据。比方说，我们用的 64 位 Intel服务器，寄存器就是 64 位的。![](Images/05b40ca182249588282b2bcd086997b3.png){savepage-src="https://static001.geekbang.org/resource/image/cd/6f/cdba5c17a04f0dd5ef05b70368b9a96f.jpg"}一个 CPU 里面会有很多种不同功能的寄存器。我这里给你介绍三种比较特殊的。一个是**PC 寄存器**（Program CounterRegister），我们也叫**指令地址寄存器**（Instruction AddressRegister）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。第二个是**指令寄存器**（InstructionRegister），用来存放当前正在执行的指令。第三个是**条件码寄存器**（StatusRegister），用里面的一个一个标记位（Flag），存放 CPU进行算术或者逻辑计算的结果。除了这些特殊的寄存器，CPU里面还有更多用来存储数据和内存地址的寄存器。这样的寄存器通常一类里面不止一个。我们通常根据存放的数据内容来给它们取名字，比如整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。![](Images/8fda209ef6242b43101167e07cc530cc.png){savepage-src="https://static001.geekbang.org/resource/image/ad/8a/ad91b005e97959d571bbd2a0fa30b48a.jpeg"}实际上，一个程序执行的时候，CPU 会根据 PC寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。而有些特殊指令，比如上一讲我们讲到 J 类指令，也就是跳转指令，会修改 PC寄存器里面的地址值。这样，下一条要执行的指令就不是从内存里面顺序加载的了。事实上，这些跳转指令的存在，也是我们可以在写程序的时候，使用if...else 条件语句和 while/for 循环语句的原因。
## 从 if...else 来看程序的执行和跳转我们现在就来看一个包含 if...else 的简单程序。    // test.c  #include #include   int main(){  srand(time(NULL));  int r = rand() % 2;  int a = 10;  if (r == 0)  {    a = 1;  } else {    a = 2;  } 我们用 rand 生成了一个随机数 r，r 要么是 0，要么是 1。当 r 是 0的时候，我们把之前定义的变量 a 设成 1，不然就设成 2。    $ gcc -g -c test.c$ objdump -d -M intel -S test.o 我们把这个程序编译成汇编代码。你可以忽略前后无关的代码，只关注于这里的if...else 条件判断语句。对应的汇编代码是这样的：        if (r == 0)  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0  3f:   75 09                   jne    4a     {        a = 1;  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1  48:   eb 07                   jmp    51     }    else    {        a = 2;  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2  51:   b8 00 00 00 00          mov    eax,0x0    } 可以看到，这里对于 r == 0 的条件判断，被编译成了 cmp 和 jne 这两条指令。cmp 指令比较了前后两个操作数的值，这里的 DWORD PTR 代表操作的数据类型是32 位的整数，而 \[rbp-0x4\则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 r的值。第二个操作数 0x0 就是我们设定的常量 0 的 16 进制表示。cmp指令的比较结果，会存入到**条件码寄存器**当中去。在这里，如果比较的结果是 True，也就是 r ==0，就把**零标志条件码**（对应的条件码是 ZF，Zero Flag）设置为1。除了零标志之外，Intel 的 CPU 下还有**进位标志**（CF，CarryFlag）、**符号标志**（SF，Sign Flag）以及**溢出标志**（OF，OverflowFlag），用在不同的判断条件下。cmp 指令执行完成之后，PC 寄存器会自动自增，开始执行下一条 jne 的指令。跟着的 jne 指令，是 jump if not equal的意思，它会查看对应的零标志位。如果为 0，会跳转到后面跟着的操作数 4a的位置。这个 4a，对应这里汇编代码的行号，也就是上面设置的 else条件里的第一条指令。当跳转发生的时候，PC寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 4a这个地址。这个时候，CPU 再把 4a 地址里的指令加载到指令寄存器中来执行。跳转到执行地址为 4a 的指令，实际是一条 mov 指令，第一个操作数和前面的cmp 指令一样，是另一个 32 位整型的寄存器地址，以及对应的 2 的 16 进制值0x2。mov 指令把 2 设置到对应的寄存器里去，相当于一个赋值操作。然后，PC寄存器里的值继续自增，执行下一条 mov 指令。这条 mov 指令的第一个操作数 eax，代表累加寄存器，第二个操作数 0x0 则是16 进制的 0的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的if 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 jmp的无条件跳转指令。跳转的地址就是这一行的地址 51。我们的 main函数没有设定返回值，而 mov eax, 0x0 其实就是给 main函数生成了一个默认的为 0 的返回值到累加器里面。if条件里面的内容执行完成之后也会跳转到这里，和 else里的内容结束之后的位置是一样的。![](Images/f7484f575ab4302a806323d54c25b34a.png){savepage-src="https://static001.geekbang.org/resource/image/b4/fa/b439cebb2d85496ad6eef2f61071aefa.jpeg"}上一讲我们讲打孔卡的时候说到，读取打孔卡的机器会顺序地一段一段地读取指令，然后执行。执行完一条指令，它会自动地顺序读取下一条指令。如果执行的当前指令带有跳转的地址，比如往后跳10 个指令，那么机器会自动将卡片带往后移动 10个指令的位置，再来执行指令。同样的，机器也能向前移动，去读取之前已经执行过的指令。这也就是我们的while/for 循环实现的原理。