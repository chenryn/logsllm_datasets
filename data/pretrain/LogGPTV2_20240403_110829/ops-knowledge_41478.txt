User: I have a multithreaded Python application running on a Linux server.  I can use PyDev's Debug Server to remotely debug into it, which seems like a very valuable debug resource.  There is however a problem I'm seeing that's preventing it from being as helpful as I would like.
While my application is running on the server, I can go into Eclipse on the other box, suspend MainThread, get a nice stack trace of what it was up to at the time, then resume execution.  It's great.  However, when I try that on one of the child threads, the suspend button grays out but there's no stack trace and everything just keeps on running as normal.  I can see in the Debug window that there IS a child thread and it's PID, but can't really control it or see what it is up to.  Right-clicking and trying the helpful-sounding "copy stack" only gives me "Thread-4 - pid29848_seq5".
Breakpoints seem to work okay.  If a child thread hits one of those, I can step through and watch variables and such.  However, using that effectively requires me to already have a specific point of interest in the code.  I'm really more looking to run my application and, when it gets into an unusual state, use PyDev to see what's up.
Do I have something wrong with my setup?  Is this just a limitation of PyDev I'm up against?  How can I see what's going on with the child threads?
Assistant: Given that Python doesn't really do threads properly (the GIL is bound to cock things up one way or another) I wouldn't be surprised if debugging them was a less than thrilling experience. If it comes to that it's not that good an experience either debugging C/C++ threads, even under the latest versions of GDB and CDT.
I don't actually know for sure but I've a hunch that adopting multiple processes in Python instead of multiple threads might make your experience better. If you arrange things so that a single instance of Eclipse/PyDev was debugging a single Python process you might end up with a lot of windows on your screen but it will be a much more flexible debugging experience.
Thats what I used to do under VxWorks in C, where there was no threads or processes just tasks. A consequence was that you could run a debugger for each task and it was wonderful.