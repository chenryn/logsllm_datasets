键值。
这个k选项非常有趣，而且还有很多特点，但是首先我们需要讲讲sort程序怎样来定义字
段。让我们考虑一个非常简单的文本文件，只有一行包含作者名字的文本。
Wi1lias
Shotts
277
---
## Page 279
默认情况下，sort程序把此行看作有两个字段。第一个字段包含字符：
和第二个字段包含字符：
意味着空白字符（空格和制表符）被当作是字段间的界定符，当执行排序时，界定符会被包
含在字段当中。再看一下1s命令的输出，我们看到每行包含八个字段，并且第五个字段是文件
大小：
=rvxr-xr-x 1 root root 8234216 2008-04-07 17:42 inkscape
让我们考虑用下面的文件，其包含从2006年到2008年三款流行的Linux发行版的发行历
史，来做一系列实验。文件中的每一行都有三个字段：发行版的名称，版本号，和MM/DD/
YYYY格式的发行日期：
SUSE
10.212/07/2006
Fedora
10
11/25/2008
3SOS
11.04 06/19/2008
Ubuntu
8.04
04/24/2008
Fedora
8
11/08/2007
3S0S
10.3
10/04/2007
使用一个文本编辑器（可能是vim），我们将输入这些数据，并把产生的文件命名为
distros.txt 
下一步，我们将试着对这个文件进行排序，并观察输出结果
[ne@linuxbox -]$ sort distros.txt
Fedora
10
11/25/2008
Fedora
5
03/20/2006
Fedora
6
10/24/2006
Fedora
7
05/31/2007
Fedora
11/08/2007
版本号“10”在最顶端，然而版本号“9”却掉到底端。
278
---
## Page 280
为了解决这个问题，我们必须依赖多个键值来排序。我们想要对第一个字段执行字母排序，
然后对第三个字段执行数值排序。sort程序允许多个-k选项的实例，所以可以指定多个排序
关键值。事实上，一个关键值可能包括一个字段区域。如果没有指定区域（如同之前的例子），
sort程序会使用一个键值，其始于指定的字段，一直扩展到行尾。下面是多键值排序的语法：
[ne@linuxbox -]$ sort --key=1,1 --key=2n distros.txt
Fedora
5
03/20/2006
Fedora
6
10/24/2006
Fedora
7
05/31/2007
虽然为了清晰，我们使用了选项的长格式，但是-k1.1-k2n格式是等价的。在第一个key
选项的实例中，我们指定了一个字段区城。因为我们只想对第一个字段排序，我们指定了1.1，
是排序的键值，并且按照数值排序。一个选项字母可能被包含在一个键值说明符的末尾，其用
来指定排序的种类。这些选项字母和sort程序的全局选项一样：b（忽略开头的空格），n（数
值排序），r（逆向排序），等等。
我们列表中第三个字段包含的日期格式不利于排序。在计算机中，日期通常设置为
YYYY-MM-DD格式，这样使按时间顺序排序变得容易，但是我们的日期为美国格式MM/
幸运地是，sort程序提供了一种方式。这个key选项允许在字段中指定偏移量，所以我们
能在字段中定义键值。
[neglinuxbox -]$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt
Fedora
1011/25/2008
Ubuntu
8.1010/30/2008
3SOS
11.006/19/2008
通过指定-k3.7，我们指示sort程序使用一个排序键值，其始于第三个字段中的第七个字
符，对应于年的开头。同样地，我们指定-k3.1和-k3.4来分离日期中的月和日。我们也添加
了n和：选项来实现一个逆向的数值排序。这个b选项用来删除日期字段中开头的空格（行与
行之间的空格数迥异，因此会影响sort程序的输出结果）。
一些文件不会使用tabs和空格做为字段界定符：例如，这个/etc/passwd文件：
---
## Page 281
[ne@linuxbox -]$ head /etc/passud
root :x:0:0:root:/root: /bin/bash
daemon:x:1 : 1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin: /bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
ganes:x:5 : 60:ganes:/usr/ganes :/bin/sh
man:x:6: 12:nan:/var/cache/nan:/bin/sh
1p:x:7:7 :1p: /var/spoo1/1pd:/bin/sh
mail:x:8:8:mail: /var/nai1: /bin/sh
nevs:x:9:9:news: /var/spoo1/nevs : /bin/sh
这个文件的字段之间通过管号分隔开，所以我们怎样使用一个key字段来排序这个文件？
sort程序提供了一个-t选项来定义分隔符。按照第七个字段（帐户的默认shell）来排序此
passwd文件，我们可以这样做：
peou 1 passed/o/ x- :, 4- axos s[-xoqxnutgou]
me:x:1001: 1001 :Myself,,, : /hone/me: /bin/bash
root :x:0:0:root:/root: /bin/bash
dhcp:x: 101:102: :/nonexistent : /bin/fa1se
gdn:x:106 : 114 :Gnome Display Manager:/var/1ib/gdm: /bin/false
hp1ip:x:104:7:HPLIP systen user,,, :/var/run/hp1ip:/bin/false
k1og:x: 103: 104: : /hone/k1og:/bin/false
messagebus :x:108 : 119 : : /var/run/dbus: /bin/fa1se
polkituser:x:110 : 122:PolicyKit,,, : /var/run/Po1icyKit : /bin/fa1se
pulse:x:107:116:PulseAudio daemon,,, :/var/run/pulse: /bin/false
通过指定冒号字符做为字段分隔符，我们能按照第七个字段来排序。
21.2.3uniq
与sort程序相比，这个uniq程序是个轻量级程序。uniq执行一个看似琐碎的行为。当给定一
个排好序的文件（包括标准输出），uniq会删除任意重复行，并且把结果发送到标准输出。它
常常和sort程序一块使用，来清理重复的输出。
280
---
## Page 282
uniq程序是一个传统的Unix工具，经常与sort程序一块使用，但是这个GNU版本的sort
程序支持一个-u选项，其可以从排好序的输出结果中删除重复行。
让我们创建一个文本文件，来实验一下：
[ne@linuxbox -]$ cat > foo.txt
b
记住输入Ctrl-d来终止标准输入。现在，如果我们对文本文件执行unig命令：
[ne@linuxbox -]$ uniq foo.txt
输出结果与原始文件没有差异：重复行没有被删除。实际上，uniq程序能完成任务，其输
入必须是排好序的数据，
[nellinuxbox -]$ sort foo.txt 1 umiq
$
281
---
## Page 283
选项
说明
-C
输出所有的重复行，并且每行开头显示重复的次数。
-d
只输出重复行，而不是特有的文本行。
-f n
忽略每行开头的n个字段，字段之间由空格分隔，正如sort
程序中的空格分隔符：然而，不同于sort程序，uniq没有
选项来设置备用的字段分隔符。
-i
在比较文本行的时候忽略大小写。
-8 II
跳过（忽略）每行开头的n个字符。
-11
只输出独有的文本行。这是默认的。
表21-2:常用的uniq选项
这里我们看到uniq被用来报告文本文件中重复行的次数，使用这个-c选项：
[neglinuxbox -]$ sort foo.txt 1 umiq -c
2 a
2 b
2 c
21.3
切片和切块
下面我们将要讨论的三个程序用来从文件中获得文本列，并且以有用的方式重组它们。
21.3.1 cut
这个cut程序被用来从文本行中抽取文本，并把其输出到标准输出。它能够接受多个文件参数
或者标准输入。
从文本行中指定要抽取的文本有些麻烦，使用以下选项：
选项
说明
-c char_list
从文本行中抽取由char_list定义的文本。这个列表可能由
一个或多个逗号分隔开的数值区间组成。
282
---
## Page 284
-f field_list
从文本行中抽取一个或多个由feld_list定义的字段。这个
列表可能包括一个或多个字段，或由逗号分隔开的字段区
间。
-d delim_char
当指定-f选项之后，使用delim_char做为字段分隔符。默
认情况下，字段之间必须由单个tab字符分隔开。
--complement
抽取整个文本行，除了那些由-c和/或-f选项指定的文本。
表21-3:cut程序选择项
正如我们所看到的，cut程序抽取文本的方式相当不灵活。cut命令最好用来从其它程
序产生的文件中抽取文本，而不是从人们直接输人的文本中抽取。我们将会看一下我们的
distros.txt文件，看看是否它足够“整齐”成为cut实例的一个好样本。如果我们使用带有-A
选项的cat命令，我们能查看是否这个文件符号由tab字符分离字段的要求。
[neglinuxbox -]$ cat -A distros.txt
SUSE*I10.2*I12/07/2006$
Fedora*I10*I11/25/2008$
SUSE*I11.0*I06/19/2008$
Ubuntu~I8.04~I04/24/2008$
Fedora~I8°I11/08/2007$
SUSE*I10.3*I10/04/2007$
Ubuntu~I6. 10°I10/26/2006$
Fedora°I7~I05/31/2007$
Ubuntu~I7. 10~I10/18/2007$
Ubuntu~I7. 04~I04/19/2007$
SUSE*I10.1*I05/11/2006$
Fedora*I16°I10/24/2006$
Fedora^I9°I05/13/2008$
Ubuntu~I6. 06~I06/01/2006$
Ubumtu°I8.10~I10/30/2008$
Fedora~I5°I03/20/2006$
看起来不错。字段之间仅仅是单个tab字符，没有嵌入空格。因为这个文件使用了tab而
不是空格，我们将使用-f选项来抽取一个字段：
283
---
## Page 285
[ne@linuxbox -]$ cut -f 3 distros.txt
12/07/2006
11/25/2008
06/19/2008
04/24/2008
11/08/2007
10/04/2007
10/26/2006
05/31/2007
10/18/2007
04/19/2007
05/11/2006
10/24/2006
05/13/2008
06/01/2006
10/30/2008
03/20/2006
因为我们的distros文件是由tab分隔开的，最好用cut来抽取字段而不是字符。这是因为
一个由tab分离的文件，每行不太可能包含相同的字符数，这就使计算每行中字符的位置变得
困难或者是不可能。在以上事例中，然而，我们已经抽取了一个字段，幸运地是其包含地日期
长度相同，所以通过从每行中抽取年份，我们能展示怎样来抽取字符：
[ne@linuxbox -]$ cut -f 3 distros.txt 1 cut -c 7-10
2006
2008
2007
2006
2007
2006
2008
2006
2008
2006
通过对我们的列表再次运行cut命令，我们能够抽取从位置7到10的字符，其对应于日期
284
---
## Page 286
字段的年份。这个7-10表示法是一个区间的例子。cut命令手册包含了一个如何指定区间的完
整描述。
展开Tabs
distros.txt的文件格式很适合使用cut程序来抽取字段。但是如果我们想要cut
程序按照字符，而不是字段来操作一个文件，那又怎样呢？这要求我们用相应数目
的空格来代替tab字符。幸运地是，GNU的Coreutils软件包有一个工具来解决这
个问题。这个程序名为expand，它既可以接受一个或多个文件参数，也可以接受标
准输入，并且把修改过的文本送到标准输出。
如果我们通过expand来处理distros.txt文件。我们能够使用cut-c命令来从文
件中抽取任意区间内的字符。例如，我们能够使用以下命令来从列表中抽取发行年
份，通过展开此文件，再使用cut命令，来抽取从位置23开始到行尾的每一个字符：
∫me@linuzboz ~/$ ezpand distros.tzt / cut -c 23-
Coreutils软件包也提供了unexpand程序，用tab来代替空格。
当操作字段的时候，有可能指定不同的字段分隔符，而不是tab字符。这里我们将会从/
etc/passwd文件中抽取第一个字段：
peou 1 pnssed/>o/ T - ,:, p-4n3 s[- xoqxnutgou]
root
daenon
bin
sys