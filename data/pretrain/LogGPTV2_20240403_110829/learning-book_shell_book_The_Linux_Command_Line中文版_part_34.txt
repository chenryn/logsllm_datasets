### 字段定义与排序

在讨论`sort`程序的`-k`选项之前，我们需要先了解`sort`如何定义字段。以一个简单的文本文件为例，该文件仅包含一行作者名字：

```
Wi1lias
Shotts
277
---
## Page 279
```

默认情况下，`sort`将此行视为两个字段。第一个字段包含字符“W”，第二个字段包含字符“i1lias”。空白字符（空格和制表符）被视为字段间的分隔符，并且在排序时会包含在字段中。

再来看一下`ls`命令的输出，我们可以看到每行包含八个字段，其中第五个字段是文件大小：

```
-rw-r--r-- 1 root root 8234216 2008-04-07 17:42 inkscape
```

接下来，我们用一个包含从2006年到2008年三款流行的Linux发行版发行历史的文件进行一系列实验。文件中的每一行都有三个字段：发行版的名称、版本号以及MM/DD/YYYY格式的发行日期。以下是示例数据：

```
SUSE 10.2 12/07/2006
Fedora 10 11/25/2008
SUSE 11.04 06/19/2008
Ubuntu 8.04 04/24/2008
Fedora 8 11/08/2007
SUSE 10.3 10/04/2007
Ubuntu 6.10 10/26/2006
Fedora 7 05/31/2007
Ubuntu 7.10 10/18/2007
Ubuntu 7.04 04/19/2007
SUSE 10.1 05/11/2006
Fedora 6 10/24/2006
Fedora 9 05/13/2008
Ubuntu 6.06 06/01/2006
Ubuntu 8.10 10/30/2008
Fedora 5 03/20/2006
```

使用文本编辑器（如`vim`），我们将这些数据输入并保存为`distros.txt`文件。然后尝试对这个文件进行排序，并观察结果：

```bash
[ne@linuxbox -]$ sort distros.txt
Fedora 10 11/25/2008
Fedora 5 03/20/2006
Fedora 6 10/24/2006
Fedora 7 05/31/2007
Fedora 8 11/08/2007
...
```

可以看到，版本号“10”排在最顶端，而版本号“9”却掉到了底部。

为了解决这个问题，我们需要使用多个键值来排序。我们希望首先按第一个字段字母顺序排序，然后按第三个字段数值顺序排序。`sort`程序允许多个`-k`选项实例，可以指定多个排序关键值。事实上，一个关键值可能包括一个字段区域。如果没有指定区域（如同之前的例子），`sort`会使用一个键值，其始于指定的字段，一直扩展到行尾。下面是多键值排序的语法：

```bash
[ne@linuxbox -]$ sort --key=1,1 --key=3n distros.txt
Fedora 5 03/20/2006
Fedora 6 10/24/2006
Fedora 7 05/31/2007
Fedora 8 11/08/2007
...
```

虽然为了清晰，我们使用了长格式选项，但`-k1,1 -k3n`格式是等价的。在第一个`-k`选项实例中，我们指定了一个字段区域。因为我们只想对第一个字段排序，所以我们指定了`1,1`作为排序键值，并且按照数值排序。一个选项字母可能被包含在一个键值说明符的末尾，用来指定排序的种类。这些选项字母和`sort`程序的全局选项一样：`b`（忽略开头的空格）、`n`（数值排序）、`r`（逆向排序）等。

我们的列表中第三个字段包含的日期格式不利于排序。通常，日期设置为YYYY-MM-DD格式，这样按时间顺序排序变得容易，但我们的日期为美国格式MM/DD/YYYY。幸运的是，`sort`程序提供了一种方法。`-k`选项允许在字段中指定偏移量，因此我们可以在字段中定义键值。

```bash
[ne@linuxbox -]$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt
Fedora 10 11/25/2008
Ubuntu 8.10 10/30/2008
SUSE 11.04 06/19/2008
...
```

通过指定`-k3.7`，我们指示`sort`程序使用一个排序键值，其始于第三个字段中的第七个字符，对应于年的开头。同样地，我们指定`-k3.1`和`-k3.4`来分离日期中的月和日。我们也添加了`n`和`r`选项来实现一个逆向的数值排序。`b`选项用来删除日期字段中开头的空格（行与行之间的空格数不同，会影响`sort`程序的输出结果）。

一些文件不会使用制表符和空格作为字段分隔符，例如`/etc/passwd`文件：

```bash
[ne@linuxbox -]$ head /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
```

这个文件的字段之间通过冒号分隔，因此如何使用`-k`字段来排序这个文件？`sort`程序提供了一个`-t`选项来定义分隔符。按照第七个字段（账户的默认shell）来排序此`passwd`文件，我们可以这样做：

```bash
[ne@linuxbox -]$ sort -t: -k7 /etc/passwd
...
```

通过指定冒号字符作为字段分隔符，我们可以按照第七个字段来排序。

### `uniq`程序

`uniq`程序是一个轻量级工具，常与`sort`程序一起使用。当给定一个已排序的文件（包括标准输出），`uniq`会删除任意重复行，并将结果发送到标准输出。它经常用于清理重复的输出。

让我们创建一个文本文件来进行实验：

```bash
[ne@linuxbox -]$ cat > foo.txt
a
a
b
b
c
c
```

记住输入`Ctrl-d`来终止标准输入。现在，如果我们对文本文件执行`uniq`命令：

```bash
[ne@linuxbox -]$ uniq foo.txt
a
a
b
b
c
c
```

输出结果与原始文件没有差异：重复行没有被删除。实际上，`uniq`程序要完成任务，其输入必须是排好序的数据。

```bash
[ne@linuxbox -]$ sort foo.txt | uniq
a
b
c
```

### `cut`程序

`cut`程序用于从文本行中抽取文本，并将其输出到标准输出。它能够接受多个文件参数或标准输入。

从文本行中指定要抽取的文本有些麻烦，使用以下选项：

- `-c char_list`：从文本行中抽取由`char_list`定义的文本。这个列表可以由一个或多个逗号分隔开的数值区间组成。
- `-f field_list`：从文本行中抽取一个或多个由`field_list`定义的字段。这个列表可以包括一个或多个字段，或由逗号分隔开的字段区间。
- `-d delim_char`：当指定`-f`选项后，使用`delim_char`作为字段分隔符。默认情况下，字段之间必须由单个制表符分隔。
- `--complement`：抽取整个文本行，除了那些由`-c`和/或`-f`选项指定的文本。

我们来看一下`distros.txt`文件，看看它是否足够“整齐”成为`cut`实例的一个好样本。使用带有`-A`选项的`cat`命令，我们可以查看文件是否符合由制表符分隔字段的要求。

```bash
[ne@linuxbox -]$ cat -A distros.txt
SUSE^I10.2^I12/07/2006$
Fedora^I10^I11/25/2008$
SUSE^I11.04^I06/19/2008$
Ubuntu^I8.04^I04/24/2008$
Fedora^I8^I11/08/2007$
SUSE^I10.3^I10/04/2007$
Ubuntu^I6.10^I10/26/2006$
Fedora^I7^I05/31/2007$
Ubuntu^I7.10^I10/18/2007$
Ubuntu^I7.04^I04/19/2007$
SUSE^I10.1^I05/11/2006$
Fedora^I6^I10/24/2006$
Fedora^I9^I05/13/2008$
Ubuntu^I6.06^I06/01/2006$
Ubuntu^I8.10^I10/30/2008$
Fedora^I5^I03/20/2006$
```

看起来不错。字段之间仅仅是单个制表符，没有嵌入空格。因为这个文件使用了制表符而不是空格，我们将使用`-f`选项来抽取一个字段：

```bash
[ne@linuxbox -]$ cut -f 3 distros.txt
12/07/2006
11/25/2008
06/19/2008
04/24/2008
11/08/2007
10/04/2007
10/26/2006
05/31/2007
10/18/2007
04/19/2007
05/11/2006
10/24/2006
05/13/2008
06/01/2006
10/30/2008
03/20/2006
```

因为我们的`distros`文件是由制表符分隔的，最好用`cut`来抽取字段而不是字符。这是因为一个由制表符分隔的文件，每行不太可能包含相同的字符数，这使得计算每行中字符的位置变得困难或不可能。然而，在以上示例中，我们已经抽取了一个字段，幸运的是其包含的日期长度相同，所以通过从每行中抽取年份，我们可以展示如何抽取字符：

```bash
[ne@linuxbox -]$ cut -f 3 distros.txt | cut -c 7-10
2006
2008
2008
2006
2007
2006
2008
2006
2008
2006
```

通过对我们的列表再次运行`cut`命令，我们可以抽取从位置7到10的字符，这对应于日期字段的年份。`7-10`表示法是一个区间的例子。`cut`命令手册包含了一个如何指定区间的完整描述。

### 展开制表符

`distros.txt`文件的格式很适合使用`cut`程序来抽取字段。但是如果我们想要`cut`程序按照字符而不是字段来操作一个文件，那该怎么办呢？这要求我们用相应数目的空格来代替制表符。幸运的是，GNU的Coreutils软件包提供了一个工具来解决这个问题。这个程序名为`expand`，它可以接受一个或多个文件参数，也可以接受标准输入，并将修改过的文本送到标准输出。

如果我们通过`expand`处理`distros.txt`文件，我们可以使用`cut -c`命令来从文件中抽取任意区间内的字符。例如，我们可以使用以下命令来从列表中抽取发行年份，通过展开此文件，再使用`cut`命令，来抽取从位置23开始到行尾的每一个字符：

```bash
[ne@linuxbox -]$ expand distros.txt | cut -c 23-
```

Coreutils软件包还提供了`unexpand`程序，用制表符来代替空格。

当操作字段时，可以指定不同的字段分隔符，而不是制表符。这里我们将会从`/etc/passwd`文件中抽取第一个字段：

```bash
[ne@linuxbox -]$ cut -d: -f1 /etc/passwd
root
daemon
bin
sys
sync
games
man
lp
mail
news
...
```

通过指定冒号字符作为字段分隔符，我们可以从`/etc/passwd`文件中抽取第一个字段。