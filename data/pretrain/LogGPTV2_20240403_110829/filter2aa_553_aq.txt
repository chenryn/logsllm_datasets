转换成double类型。一般而言，ANSI 
C不会把float自动转换成double。然
而，为保护大量假设float类型的参数被自动转换成double的现有程序，
printf()函数中所有float类型的参数（对未使用显式原型的所有C函数都有
效）仍自动转换成double类型。因此，无论是K&R C还是ANSI C，都没有显
示float类型值专用的转换说明。
表4.5 printf()中的标记
1.使用修饰符和标记的示例
接下来，用程序示例演示如何使用这些修饰符和标记。先来看看字段宽
度在打印整数时的效果。考虑程序清单4.7中的程序。
程序清单4.7 width.c程序
201
/* width.c -- 字段宽度 */
#include 
#define PAGES 959
int main(void)
{
printf("*%d*\n", PAGES);
printf("*%2d*\n", PAGES);
printf("*%10d*\n", PAGES);
return 0;
printf("*%-10d*\n", PAGES);
}
程序清单4.7通过4种不同的转换说明把相同的值打印了4次。程序中使
用星号（*）标出每个字段的开始和结束。其输出结果如下所示：
*959*
*959*
*   959*
*959   *
第1个转换说明%d不带任何修饰符，其对应的输出结果与带整数字段宽
度的转换说明的输出结果相同。在默认情况下，没有任何修饰符的转换说
明，就是这样的打印结果。第2个转换说明是%2d，其对应的输出结果应该
202
是 2 字段宽度。因为待打印的整数有 3 位数字，所以字段宽度自动扩大以符
合整数的长度。第 
3个转换说明是%10d，其对应的输出结果有10个空格宽
度，实际上在两个星号之间有7个空格和3位数字，并且数字位于字段的右
侧。最后一个转换说明是%-10d，其对应的输出结果同样是 
10 
个空格宽
度，-标记说明打印的数字位于字段的左侧。熟悉它们的用法后，能很好地
控制输出格式。试着改变PAGES的值，看看编译器如何打印不同位数的数
字。
接下来看看浮点型格式。请输入、编译并运行程序清单4.8中的程序。
程序清单4.8 floats.c程序
// floats.c -- 一些浮点型修饰符的组合
#include 
int main(void)
{
const double RENT = 3852.99; // const变量
printf("*%f*\n", RENT);
printf("*%e*\n", RENT);
printf("*%4.2f*\n", RENT);
printf("*%3.1f*\n", RENT);
printf("*%10.3f*\n", RENT);
printf("*%10.3E*\n", RENT);
printf("*%+4.2f*\n", RENT);
203
printf("*%010.2f*\n", RENT);
return 0;
}
该程序中使用了const关键字，限定变量为只读。该程序的输出如下：
*3852.990000*
*3.852990e+03*
*3852.99*
*3853.0*
* 3852.990*
* 3.853E+03*
*+3852.99*
*0003852.99*
本例的第1个转换说明是%f。在这种情况下，字段宽度和小数点后面的
位数均为系统默认设置，即字段宽度是容纳带打印数字所需的位数和小数点
后打印6位数字。
第2个转换说明是%e。默认情况下，编译器在小数点的左侧打印1个数
字，在小数点的右侧打印6个数字。这样打印的数字太多！解决方案是指定
小数点右侧显示的位数，程序中接下来的 4 个例子就是这样做的。请注意，
第4个和第6个例子对输出结果进行了四舍五入。另外，第6个例子用E代替
了e。
第7个转换说明中包含了+标记，这使得打印的值前面多了一个代数符
号（+）。0标记使得打印的值前面以0填充以满足字段要求。注意，转换说
204
明%010.2f的第1个0是标记，句点（.）之前、标记之后的数字（本例为10）
是指定的字段宽度。尝试修改RENT的值，看看编译器如何打印不同大小的
值。程序清单4.9演示了其他组合。
程序清单4.9 flags.c程序
/* flags.c -- 演示一些格式标记 */
#include 
int main(void)
{
printf("%x %X %#x\n", 31, 31, 31);
printf("**%d**% d**% d**\n", 42, 42, -42);
printf("**%5d**%5.3d**%05d**%05.3d**\n", 6, 6, 6, 6);
return 0;
}
该程序的输出如下：
1f 1F 0x1f
**42** 42**-42**
**  6** 006**00006** 006**
第1行输出中，1f是十六进制数，等于十进制数31。第1行printf()语句
中，根据%x打印出1f，%F打印出1F，%#x打印出0x1f。
第 2 行输出演示了如何在转换说明中用空格在输出的正值前面生成前导
205
空格，负值前面不产生前导空格。这样的输出结果比较美观，因为打印出来
的正值和负值在相同字段宽度下的有效数字位数相同。
第3行输出演示了如何在整型格式中使用精度（%5.3d）生成足够的前
导0以满足最小位数的要求（本例是3）。然而，使用0标记会使得编译器用
前导0填充满整个字段宽度。最后，如果0标记和精度一起出现，0标记会被
忽略。
下面来看看字符串格式的示例。考虑程序清单4.10中的程序。
程序清单4.10 stringf.c程序
/* stringf.c -- 字符串格式 */
#include 
#define BLURB "Authentic imitation!"
int main(void)
{
printf("[%2s]\n", BLURB);
printf("[%24s]\n", BLURB);
printf("[%24.5s]\n", BLURB);
printf("[%-24.5s]\n", BLURB);
return 0;
}
该程序的输出如下：
206
[Authentic imitation!]
[  Authentic imitation!]
[          Authe]
[Authe          ]
注意，虽然第1个转换说明是%2s，但是字段被扩大为可容纳字符串中
的所有字符。还需注意，精度限制了待打印字符的个数。.5告诉printf()只打
印5个字符。另外，-标记使得文本左对齐输出。
2.学以致用
学习完以上几个示例，试试如何用一个语句打印以下格式的内容：
The NAME family just may be $XXX.XX dollars richer!
这里，NAME和XXX.XX代表程序中变量（如name[40]和cash）的值。
可参考以下代码：
printf("The %s family just may be $%.2f richer!\n",name,cash);
4.4.4 转换说明的意义
下面深入探讨一下转换说明的意义。转换说明把以二进制格式储存在计
算机中的值转换成一系列字符（字符串）以便于显示。例如，数字76在计算
机内部的存储格式是二进制数01001100。%d转换说明将其转换成字符7和
6，并显示为76；%x转换说明把相同的值（01001100）转换成十六进制记数
法4c；%c转换说明把01001100转换成字符L。
转换（conversion）可能会误导读者认为原始值被转替换成转换后的
值。实际上，转换说明是翻译说明，%d的意思是“把给定的值翻译成十进制
整数文本并打印出来”。
207
1.转换不匹配
前面强调过，转换说明应该与待打印值的类型相匹配。通常都有多种选
择。例如，如果要打印一个int类型的值，可以使用%d、%x或%o。这些转换
说明都可用于打印int类型的值，其区别在于它们分别表示一个值的形式不
同。类似地，打印double类型的值时，可使用%f、%e或%g。
转换说明与待打印值的类型不匹配会怎样？上一章中介绍过不匹配导致
的一些问题。匹配非常重要，一定要牢记于心。程序清单4.11演示了一些不
匹配的整型转换示例。
程序清单4.11 intconv.c程序
/* intconv.c -- 一些不匹配的整型转换 */
#include 
#define PAGES 336
#define WORDS 65618
int main(void)
{
short num = PAGES;
short mnum = -PAGES;
printf("num as short and unsigned short: %hd %hu\n", num,num);
printf("-num as short and unsigned short: %hd %hu\n", mnum,mnum);
printf("num as int and char: %d %c\n", num, num);
printf("WORDS as int, short, and char: %d %hd %c\n",WORDS,WORDS,
208
WORDS);
return 0;
}
在我们的系统中，该程序的输出如下：
num as short and unsigned short: 336 336
-num as short and unsigned short: -336 65200
num as int and char: 336 P
WORDS as int, short, and char: 65618 82 R
请看输出的第1行，num变量对应的转换说明%hd和%hu输出的结果都是
336。这没有任何问题。然而，第2行mnum变量对应的转换说明%u（无符
号）输出的结果却为65200，并非期望的336。这是由于有符号short 
int类型
的值在我们的参考系统中的表示方式所致。首先，short int的大小是2字节；
其次，系统使用二进制补码来表示有符号整数。这种方法，数字0～32767代
表它们本身，而数字32768～65535则表示负数。其中，65535表示-1，65534
表示-2，以此类推。因此，-336表示为65200（即， 65536-336）。所以被解
释成有符号int时，65200代表-336；而被解释成无符号int时，65200则代表
65200。一定要谨慎！一个数字可以被解释成两个不同的值。尽管并非所有
的系统都使用这种方法来表示负整数，但要注意一点：别期望用%u转换说
明能把数字和符号分开。
第3行演示了如果把一个大于255的值转换成字符会发生什么情况。在我
们的系统中，short int是2字节，char是1字节。当printf()使用%c打印336时，
它只会查看储存336的2字节中的后1字节。这种截断（见图4.8）相当于用一
个整数除以256，只保留其余数。在这种情况下，余数是80，对应的ASCII值
是字符P。用专业术语来说，该数字被解释成“以256为模”（modulo 256），
即该数字除以256后取其余数。
209
图4.8 把336转换成字符
最后，我们在该系统中打印比short int类型最大整数（32767）更大的整
数（65618）。这次，计算机也进行了求模运算。在本系统中，应把数字
65618储存为4字节的int类型值。用%hd转换说明打印时， printf()只使用最后
2个字节。这相当于65618除以65536的余数。这里，余数是82。鉴于负数的
储存方法，如果余数在32767～65536范围内会被打印成负数。对于整数大小
不同的系统，相应的处理行为类似，但是产生的值可能不同。
混淆整型和浮点型，结果更奇怪。考虑程序清单4.12。
程序清单4.12 floatcnv.c程序
/* floatcnv.c -- 不匹配的浮点型转换 */
#include 
int main(void)
{
float n1 = 3.0;
double n2 = 3.0;
long n3 = 2000000000;
long n4 = 1234567890;
printf("%.1e %.1e %.1e %.1e\n", n1, n2, n3, n4);
210
printf("%ld %ld\n", n3, n4);
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
return 0;
}
在我们的系统中，该程序的输出如下：
3.0e+00 3.0e+00 3.1e+46 1.7e+266
2000000000 1234567890
0 1074266112 0 1074266112
第1行输出显示，%e转换说明没有把整数转换成浮点数。考虑一下，如
果使用%e转换说明打印n3（long类型）会发生什么情况。首先，%e转换说
明让printf()函数认为待打印的值是double类型（本系统中double为8字节）。
当printf()查看n3（本系统中是4字节的值）时，除了查看n3的4字节外，还会
查看查看n3相邻的4字节，共8字节单元。接着，它将8字节单元中的位组合
解释成浮点数（如，把一部分位组合解释成指数）。因此，即使n3的位数正
确，根据%e转换说明和%ld转换说明解释出来的值也不同。最终得到的结果
是无意义的值。
第1行也说明了前面提到的内容：float类型的值作为printf()参数时会被
转换成double类型。在本系统中，float是4字节，但是为了printf()能正确地显
示该值，n1被扩成8字节。
第2行输出显示，只要使用正确的转换说明，printf()就可以打印n3和
n4。
第3行输出显示，如果printf()语句有其他不匹配的地方，即使用对了转
换说明也会生成虚假的结果。用%ld转换说明打印浮点数会失败，但是在这
里，用%ld打印long类型的数竟然也失败了！问题出在C如何把信息传递给函
211
数。具体情况因编译器实现而异。“参数传递”框中针对一个有代表性的系统
进行了讨论。
参数传递
参数传递机制因实现而异。下面以我们的系统为例，分析参数传递的原
理。函数调用如下：
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
该调用告诉计算机把变量n1、n2、、n3和n4的值传递给程序。这是一种
常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。
计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1被
储存在栈中，占8字节（float类型被转换成double类型）。同样，n2也在栈中
占8字节，而n3和n4在栈中分别占4字节。然后，控制转到printf()函数。该函
数根据转换说明（不是根据变量类型）从栈中读取值。%ld转换说明表明
printf()应该读取4字节，所以printf()读取栈中的前4字节作为第1个值。这是
n1的前半部分，将被解释成一个long类型的整数。根据下一个%ld转换说
明，printf()再读取4字节，这是n1的后半部分，将被解释成第2个long类型的
整数（见图4.9）。类似地，根据第3个和第4个%ld，printf()读取n2的前半部