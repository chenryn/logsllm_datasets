8139cp
Faults
400
400
NoCrash
49
134
UD
26
14
Clear
212
147
InLog
113
105
Detect
95 (84%)
64 (61%)
Figure 8. Results from fault injection.
uhci-hcd drivers because of limitations of our prototype in-
frastructure.) We used an oﬀ-the-shelf fault injector [42] to
inject 400 random faults in the u-driver of each microdriver.
We measured the number of faults that propagated to the ker-
nel (via RPC) and the number of these faults that were de-
tected by our invariants. Note that our prototype currently
lacks a recovery subsystem. Therefore, faults that propagate
to the kernel crash the system, i.e., the RPC monitor can de-
tect data corruption, but cannot prevent or recover from a
system crash. Our experimental methodology was therefore
to inspect system logs following each system crash to deter-
mine whether the RPC monitor detected the crash.
Figure 8 presents the results of this study. As this ﬁgure
shows, there were several cases in which the system did not
crash and in which the faults were contained within the u-
driver (the #NoCrash and #UD columns, respectively). The
remaining faults, which constituted the majority, propagated
to the kernel, thereby showing the need for an RPC monitor
to inspect kernel data structure updates initiated by the u-
driver. As discussed above, we used system logs to determine
whether the RPC monitor detected a crash. In several cases
(shown in the #Clear column), we observed that the system
log had been cleared following the crash. In these cases, we
could not determine whether the RPC monitor would have
detected the crash. Nevertheless, there were several cases in
which we observed a crash for which we could inspect our
logs to determine the eﬀectiveness of invariants (shown in
the #InLog column). The #Detect column shows the number
of #InLog crashes that were detected by the RPC monitor.
As these results indicate, the RPC monitor could detect 84%
of the injected faults in the 8139too driver and 61% of the
faults in the 8139cp driver. These results also show that the
RPC monitor can eﬀectively thwart a signiﬁcant fraction of
attacks enabled by a compromised u-driver.
5.3. Performance
We measured both the throughput and CPU utilization of
the two network drivers and the USB driver using our QEMU
testbed. While QEMU does not provide an accurate repre-
sentation of performance on real hardware, it allows us to
measure diﬀerences in performance. If the driver has lower
performance, it will be re ected either as higher CPU utiliza-
tion or low throughput. If neither changes, the performance
on real hardware should be unchanged.
We measured throughput and CPU utilization of the net-
work drivers using netperf [15]. We transmitted packets be-
tween our QEMU test environment and a client machine.
The netperf tests used TCP receive and send buﬀer sizes of
87KB and 16KB, respectively. To test the USB driver, we
copied a 140MB ﬁle into a USB disk. All our measurements
are averaged over 10 runs, and are presented in Figure 7. As
309
this Figure shows, our security architecture minimally im-
pacts common-case performance (the minor speedups that
we observed are within the margin of experimental error).
This is because the code to transmit packets is in the k-driver;
sending a packet does not involve any user/kernel transitions.
For the sound driver, we compared the CPU utilization of
both the original driver and the split driver as they played a
256-Kbps MP3; CPU utilization in both cases was zero.
However, uncommon functionality, such as device ini-
tialization, shutdown and conﬁguration, resulted in several
user/kernel transitions and took almost thrice as long.
6. Related Work
Hardware-based isolation techniques, such as Nooks [35]
and Mondrix [40], rely on memory protection at the page
level (Nooks) or with ﬁne-grained segments (Mondrix) to
isolate device driver failures. There are two main diﬀerences
between Nooks/Mondrix and our work. First, both Nooks
and Mondrix execute device drivers in kernel mode. Second,
they do not enforce integrity speciﬁcations on kernel data
structure updates, because doing so is likely to impose sig-
niﬁcant performance overheads. The consequence of these
diﬀerences is that while Nooks and Mondrix can improve re-
liability with benign but vulnerable drivers, they cannot pro-
tect against compromised drivers that attempt to subvert the
kernel. For example, they cannot protect against buﬀer over-
ow exploits that maliciously modify kernel data structures.
Virtual machine-based techniques isolate device drivers by
running a set of device drivers within their own virtual ma-
chine e.g., [17, 20, 25]. In principle, this approach oﬀers all
the beneﬁts of our architecture. However, in practice, there
are two key diﬃculties. First, these techniques require the
use of a VMM. Although VMMs have seen wide deployment
for server-class systems, they are still not in wide use on per-
sonal desktops—platforms that support a wide variety of de-
vices and hence, drivers. Second, VM-based techniques must
provide a front-end driver within the guest VM that commu-
nicates requests between the device driver (running on a sep-
arate VM) and I/O requests from applications in the guest.
Although such front-ends can be developed easily for stan-
dard classes of drivers (e.g., network, sound, SCSI), develop-
ing front-ends for other one-of-a-kind drivers, e.g., those that
support non-standard ioctl interfaces, is cumbersome.
SafeDrive [42] and XFI [18] are language-based mech-
anisms to isolate device drivers. SafeDrive is an adapta-
tion of CCured [32] to protect against type-safety violations
in device drivers. While SafeDrive oﬀers low-performance
overhead and compatibility, device drivers protected with
SafeDrive still execute with kernel privilege. Moreover,
SafeDrive only protects against type-safety violations;
in
contrast, our RPC monitor can protect against violations that
transcend type-safety, such as requests by the u-driver to al-
locate large amounts of memory, which may lead to memory
exhaustion. Similarly XFI ensures control- ow integrity for
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:08:20 UTC from IEEE Xplore.  Restrictions apply. 
device drivers. Our security architecture allows the use of
any user-space security mechanism to be applied to a large
fraction of device driver code without investing the eﬀort
needed to adapt these mechanisms to kernel code.
Microkernels [26, 39, 41] provide new operating system
abstractions that allow device drivers to execute in user
mode. Nexus [39] is one such microkernel OS that enforces
domain-speciﬁc rules on driver/device communication using
a kernel-resident reference monitor. Supplied with appropri-
ate rules, Nexus can prevent attacks at the driver/device inter-
face that our architecture cannot prevent. The eﬀort required
to port Linux drivers to Nexus is also comparable to the eﬀort
required to port them to our architecture. However, Nexus
is a microkernel; consequently, its security mechanisms are
largely inapplicable to commodity operating systems, which
are structured as macrokernels. In addition, Nexus reports
high CPU utilization for CPU-intensive workloads and lower
throughputs with a network driver.
In contrast, our archi-
tecture imposes minimal overheads in the common-case be-
cause performance-critical code executes in kernel mode.
User-mode driver frameworks [11, 16, 24, 28, 37] also at-
tempt to execute drivers without kernel privilege. However,
these techniques either oﬀer poor performance [3, 38] be-
cause they transmit large amounts of data frequently across
the user/kernel boundary, or are incompatible with commod-
ity operating systems, often requiring complete rewrites of
drivers and modiﬁcations to the kernel [11, 24, 28, 37].
Program partitioning techniques have previously been for
privilege separation [6] and to create secure web applica-
tions [10]. In contrast to prior work, our architecture applies
partitioning to device driver code, which enables user-mode
drivers and the use of user-mode tools such as Daikon to in-
fer invariants. Prior work has also investigated the use of
program invariants for bug detection [22], data structure re-
pair [14], rootkit detection [5] and improving the security of
web applications [12]. Again, our contribution is to apply
these techniques to improve the security of device drivers.
References
[1] D. Abramson, J. Jackson, S. Muthrasanallur, G. Neiger, G. Regnier,
R. Sankaran, I. Schoinas, R. Uhlig, B. Vembu, and J. Weigert. Intel
virtualization technology for directed I/O. Intel Technology Journal,
10(3), 2006.
[2] AMD. AMD I/O virtualization technology (IOMMU) speciﬁcation,
[3] Francois Armand. Give a process to your drivers! In EurOpen Autumn
Feb 2007.
1991, 1991.
[4] AusCERT. Esb-2006.0896: Intel network adapter driver local priv-
ilege escalation, 2006. http://www.vul.org.au/render.html?
it=7058.
[5] A. Baliga, V. Ganapathy, and L. Iftode. Automatic inference and en-
forcement of kernel data structure invariants. In ACSAC, 2008.
[6] D. Brumley and D. Song. Privtrans: Automatically partitioning pro-
grams for privilege separation. In USENIX Security, 2004.
[7] Yuriy Bulygin. Remote and local exploitation of network drivers. In
Blackhat-USA, 2007.
[8] S. Butt, C. Chang, V. Ganapathy, and M. M. Swift. Protecting com-
modity OS kernels from vulnerable device drivers. Technical Report
DCS-TR-645, Rutgers Univ., Dept. of Comp. Sci., Nov 2008.
[9] J. Cache, H. D. Moore, and Skape. Exploiting 802.11 wireless driver
vulnerabilities on windows. http://www.uninformed.org/?v=6\
&a=2\&t=sumry.
[10] S. Chong, J. Liu, A. C. Myers, X. Qi, K. Vikram, L. Zheng, and
In
X. Zheng. Secure web applications via automatic partitioning.
ACM SOSP, 2007.
[11] P. Chubb. Get more device drivers out of the kernel! In Ottawa Linux
Symp., pages 149–161, 2004.
[12] M. Cova, D. Balzarotti, V. Felmgester, and G. Vigna. Swaddler: An
approach for the anomaly-based detection of state violations in web
applications. In RAID, 2007.
[13] Coverity. Anaylsis of the Linux kernel, 2004. Available at http:
//www.coverity.com.
[14] Brian Demsky, Michael D. Ernst, Philip J. Guo, Stephen McCamant,
Jeﬀ H. Perkins, and Martin Rinard. Inference and enforcement of data
structure consistency speciﬁcations. In ISSTA, 2006.
[15] Information Networks Division. Netperf: A network performance
benchmark. http://www.netperf.org.
[17]
[16] J. Elson. FUSD: A Linux framework for user-space devices, 2004.
User manual for FUSD 1.0.
´U. Erlingsson, T. Roeder, and T. Wobber. Virtual environments for
unreliable extensions. Technical Report MSR-TR-05-82, Microsoft
Research, 2005.
[18] Ulfar Erlingsson, Martin Abadi, Michael Vrable, Mihai Budiu, and
George Necula. XFI: Software guards for system address spaces. In
OSDI, 2006.
[19] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamanat, C. Pacheco, M. S.
Tschantz, and C. Xiao. The Daikon system for dynamic detection of
likely invariants. Science of Computer Programming, 69(1–3), 2007.
I. Pratt, A. Warﬁeld, and
M. Williamson. Safe hardware access with the Xen virtual machine
monitor. In Workshop on Operating System and Architectural Support
for the On-Demand IT Infrastructure, 2004.
[20] K. Fraser, S. Hand, R. Neugebauer,
[21] V. Ganapathy, M. Renzelmann, A. Balakrishnan, M. M. Swift, and
S. Jha. The design and implementation of microdrivers. In ACM AS-
PLOS, 2008.
[22] S. Hangal and M. S. Lam. Tracking down software bugs using auto-
matic anomaly detection. In ICSE, 2002.
[23] Rob Johnson and David Wagner. Finding user/kernel pointer bugs with
type inference. In USENIX Security Symposium, 2004.
[24] B. Leslie, P. Chubb, N. Fitzroy-Dale, S. Gotz, C. Gray, L. Macpherson,
D. Potts, Y. Shen, K. Elphinstone, and G. Heiser. User-level device
drivers: Achieved performance. Jour. Comp. Sci. and Tech., 20(5),
2005.
[25] J. LeVasseur, V. Uhlig, J. Stoess, and S. Gotz. Unmodiﬁed device
driver reuse and improved system dependability via virtual machines.
In OSDI, 2004.
[26] J. Liedtke. On μ-kernel construction. In ACM SOSP, 1995.
[27] D. Maynor. Os X kernel-mode exploitation in a weekend. http:
//uninformed.org/index.cgi?v=8\&a=4.
[28] Microsoft. Architecture of the user-mode driver framework, 2006.
[29] Microsoft Inc. Microsoft interface deﬁnition language.
[30] Linux device driver vulnerabilities from the MITRE database. CVEs
2007-4571, 2007-05, 2007-4308, 2008-0007, 2005-0504, 2006-2935,
2006-2936, 2005-3180, 2004-1017, 2007-4997, 2006-1368.
[31] G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer. CIL: Interme-
diate languages and tools for analysis and transformation. In Compiler
Construction, 2002.
[32] George C. Necula, Scott McPeak, and Westley Weimer. CCured:
Type-safe retroﬁtting of legacy code. In Symposium Principles of Pro-
gramming Languages, 2002.
[33] N. L. Petroni, T. Fraser, A. Walters, and W. Arbaugh. An architec-
ture for speciﬁcation-based detection of semantic integrity violations
in kernel dynamic data. In USENIX Security Symposium, 2006.
[34] N. L. Petroni and M. W. Hicks. Automated detection of persistent
kernel control- ow attacks. In ACM CCS, 2007.
[35] Michael M. Swift, Brian N. Bershad, and Henry M. Levy. Improving
the reliability of commodity operating systems. ACM Transactions on
Computer Systems, 23(1), 2005.
[36] L. Tan, E. M. Chan, R. Farivar, N. Mallick, J. C. Carlyle, F. M. David,
and R. C. Campbell.
iKernel: Isolating buggy and malicious device
drivers using hardware virtualization support. In IEEE Intl. Symp. on
Dependable, Autonomic and Secure Computing, 2007.
[37] L. Torvalds. UIO: Linux patch for user-mode I/O, 2007.
[38] K. T. Van Maren. The Fluke device driver framework. Master’s thesis,
Dept. of Computer Science, Univ. of Utah, 1999.
[39] Dan Williams, Patrick Reynolds, Kevin Walsh, Emin Gun Sirer, and
Fred B. Schneider. Device driver safety through a reference validation
mechanism. In OSDI, 2008.
[40] E. Witchel, J. Rhee, and K. Asanovic. Mondrix: Memory isolation for
linux. In ACM SOSP, 2005.
[41] M. Young, M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid,
and A. Tevanian. Mach: A new kernel foundation for UNIX develop-
ment. In Summer USENIX Conference, 1986.
[42] F. Zhou, J. Condit, Z. Anderson, I. Bagrak, R. Ennals, M. Harren,
G. Necula, and E. Brewer. SafeDrive: Safe and recoverable extensions
using language-based techniques. In OSDI, 2006.
310
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:08:20 UTC from IEEE Xplore.  Restrictions apply.