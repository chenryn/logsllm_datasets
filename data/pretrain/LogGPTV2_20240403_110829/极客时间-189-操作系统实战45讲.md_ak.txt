# 11 \| 设置工作模式与环境（中）：建造二级引导器你好，我是 LMOS。上节课，我们建造了属于我们的"计算机"，并且在上面安装好了GRUB。这节课我会带你一起实现二级引导器这个关键组件。看到这儿你可能会问，GRUB不是已经把我们的操作系统加载到内存中了吗？我们有了GRUB，我们为什么还要实现二级引导器呢？这里我要给你说说我的观点，二级引导器作为操作系统的先驱，它需要**收集机器信息**，确定这个计算机能不能运行我们的操作系统，对CPU、内存、显卡进行一些初级的配置，放置好内核相关的文件。因为我们二级引导器不是执行具体的加载任务的，而是解析内核文件、收集机器环境信息，它具体收集哪些信息，我会在下节课详细展开。设计机器信息结构二级引导器收集的信息，需要地点存放，我们需要设计一个数据结构。信息放在这个数据结构中，这个结构放在内存1MB的地方，方便以后传给我们的操作系统。为了让你抓住重点，我选取了这个数据结构的**关键代码**，这里并没有列出该结构的所有字段（Cosmos/initldr/include/ldrtype.h），这个结构如下所示。    typedef struct s_MACHBSTART    {        u64_t   mb_krlinitstack;//内核栈地址        u64_t   mb_krlitstacksz;//内核栈大小        u64_t   mb_imgpadr;//操作系统映像        u64_t   mb_imgsz;//操作系统映像大小        u64_t   mb_bfontpadr;//操作系统字体地址        u64_t   mb_bfontsz;//操作系统字体大小        u64_t   mb_fvrmphyadr;//机器显存地址        u64_t   mb_fvrmsz;//机器显存大小        u64_t   mb_cpumode;//机器CPU工作模式        u64_t   mb_memsz;//机器内存大小        u64_t   mb_e820padr;//机器e820数组地址        u64_t   mb_e820nr;//机器e820数组元素个数        u64_t   mb_e820sz;//机器e820数组大小        //……        u64_t   mb_pml4padr;//机器页表数据地址        u64_t   mb_subpageslen;//机器页表个数        u64_t   mb_kpmapphymemsz;//操作系统映射空间大小        //……        graph_t mb_ghparm;//图形信息    }__attribute__((packed)) machbstart_t;规划二级引导器在开始写代码之前，我们先来从整体划分一下二级引导器的功能模块，从全局了解下功能应该怎么划分，这里我特意为你梳理了一个表格。![](Images/54f4ad3db3435d899e00a7ba9dda31f7.png)savepage-src="https://static001.geekbang.org/resource/image/31/1e/3169e9db4549ab036c2de269788a281e.jpg?wh=1636*846"}二级引导器功能划分表前面表格里的这些文件，我都放在了课程配套源码中了，你可以从这里slate-object="inline"下载。上述这些文件都在 lesson10～11/Cosmos/initldr/ldrkrl目录中，它们在编译之后会形成三个文件，编译脚本我已经写好了，下面我们用一幅图来展示这个编译过程。![](Images/cef7b8c0cbf8d3d406e098dead92dd51.png)savepage-src="https://static001.geekbang.org/resource/image/bd/40/bd55f67d02edff4415f06c914403bc40.jpg?wh=5005*3110"}二级引导器编译过程示意图这最后三个文件用我们前面说的映像工具打包成映像文件，其指令如下。    lmoskrlimg -m k -lhf initldrimh.bin -o Cosmos.eki -f initldrkrl.bin initldrsve.bin实现 GRUB 头我们的 GRUB 头有两个文件组成，一个 imginithead.asm 汇编文件，它有两个功能，既能让 GRUB 识别，又能设置 C 语言运行环境，用于调用 C 函数；第二就是 inithead.c 文件，它的主要功能是查找二级引导器的核心文件——initldrkrl.bin，然后把它放置到特定的内存地址上。我们先来实现 imginithead.asm，它主要工作是初始化 CPU 的寄存器，加载GDT，切换到 CPU的保护模式，我们一步一步来实现。首先是 GRUB1 和 GRUB2需要的两个头结构，代码如下。    MBT_HDR_FLAGS  EQU 0x00010003    MBT_HDR_MAGIC  EQU 0x1BADB002    MBT2_MAGIC  EQU 0xe85250d6    global _start    extern inithead_entry    [section .text    [bits 32    _start:      jmp _entry    align 4    mbt_hdr:      dd MBT_HDR_MAGIC      dd MBT_HDR_FLAGS      dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)      dd mbt_hdr      dd _start      dd 0      dd 0      dd _entry    ALIGN 8    mbhdr:      DD  0xE85250D6      DD  0      DD  mhdrend - mbhdr      DD  -(0xE85250D6 + 0 + (mhdrend - mbhdr))      DW  2, 0      DD  24      DD  mbhdr      DD  _start      DD  0      DD  0      DW  3, 0      DD  12      DD  _entry       DD  0        DW  0, 0      DD  8    mhdrend:然后是关中断并加载GDT，代码如下所示。    _entry:      cli           ；关中断      in al, 0x70       or al, 0x80        out 0x70,al  ；关掉不可屏蔽中断         lgdt [GDT_PTR] ；加载GDT地址到GDTR寄存器      jmp dword 0x8 :_32bits_mode ；长跳转刷新CS影子寄存器      ;………………    ;GDT全局段描述符表    GDT_START:    knull_dsc: dq 0    kcode_dsc: dq 0x00cf9e000000ffff    kdata_dsc: dq 0x00cf92000000ffff    k16cd_dsc: dq 0x00009e000000ffff ；16位代码段描述符    k16da_dsc: dq 0x000092000000ffff ；16位数据段描述符    GDT_END:    GDT_PTR:    GDTLEN  dw GDT_END-GDT_START-1  ;GDT界限    GDTBASE  dd GDT_ST  最后是初始化段寄存器和通用寄存器、栈寄存器，这是为了给调用inithead_entry 这个 C函数做准备，代码如下所示。    _32bits_mode：      mov ax, 0x10      mov ds, ax      mov ss, ax      mov es, ax      mov fs, ax      mov gs, ax      xor eax,eax      xor ebx,ebx      xor ecx,ecx      xor edx,edx      xor edi,edi      xor esi,esi      xor ebp,ebp      xor esp,esp      mov esp,0x7c00 ；设置栈顶为0x7c00      call inithead_entry ；调用inithead_entry函数在inithead.c中实现      jmp 0x200000  ；跳转到0x200000地址上述代码的最后调用了 inithead_entry 函数，这个函数我们需要另外在inithead.c中实现，我们这就来实现它，如下所示。    #define MDC_ENDGIC 0xaaffaaffaaffaaff    #define MDC_RVGIC 0xffaaffaaffaaffaa    #define REALDRV_PHYADR 0x1000    #define IMGFILE_PHYADR 0x4000000    #define IMGKRNL_PHYADR 0x2000000    #define LDRFILEADR IMGFILE_PHYADR    #define MLOSDSC_OFF (0x1000)    #define MRDDSC_ADR (mlosrddsc_t*)(LDRFILEADR+0x1000)    void inithead_entry()    {        write_realintsvefile();        write_ldrkrlfile();        return;    }    //写initldrsve.bin文件到特定的内存中    void write_realintsvefile()    {        fhdsc_t *fhdscstart = find_file("initldrsve.bin");        if (fhdscstart == NULL)        {            error("not file initldrsve.bin");        }        m2mcopy((void *)((u32_t)(fhdscstart->fhd_intsfsoff) + LDRFILEADR),                (void *)REALDRV_PHYADR, (sint_t)fhdscstart->fhd_frealsz);        return;    }    //写initldrkrl.bin文件到特定的内存中    void write_ldrkrlfile()    {        fhdsc_t *fhdscstart = find_file("initldrkrl.bin");        if (fhdscstart == NULL)        {            error("not file initldrkrl.bin");        }        m2mcopy((void *)((u32_t)(fhdscstart->fhd_intsfsoff) + LDRFILEADR),                (void *)ILDRKRL_PHYADR, (sint_t)fhdscstart->fhd_frealsz);        return;    }    //在映像文件中查找对应的文件    fhdsc_t *find_file(char_t *fname)    {        mlosrddsc_t *mrddadrs = MRDDSC_ADR;        if (mrddadrs->mdc_endgic != MDC_ENDGIC ||            mrddadrs->mdc_rv != MDC_RVGIC ||            mrddadrs->mdc_fhdnr mdc_filnr mdc_fhdbk_s) + LDRFILEADR);        for (u64_t i = 0; i mdc_fhdnr; i++)        {            if (strcmpl(fname, fhdscstart[i].fhd_name) == 0)            {                rethn = (s64_t)i;                goto ok_l;            }        }        rethn = -1;    ok_l:        if (rethn mb_migc=MBS_MIGC;        return;    }    void init_bstartparm()    {        machbstart_t* mbsp = MBSPADR;//1MB的内存地址        machbstart_t_init(mbsp);        return;    }目前我们的经理 init_bstartparm() 函数只是调用了一个machbstart_t\_init() 函数，在 1MB 内存地址处初始化了一个机器信息结构machbstart_t，后面随着干活越来越多，还会调用更多的函数的。检查 CPU首先要检查我们的CPU，因为它是执行程序的关键。我们要搞清楚它能执行什么形式的代码，支持 64位长模式吗？这个工作我们交给 init_chkcpu() 函数来干，由于我们要 CPUID 指令来检查CPU 是否支持 64位长模式，所以这个函数中需要找两个帮工：**chk_cpuid、chk_cpu_longmode** 来干两件事，一个是检查 CPU 否支持 CPUID指令，然后另一个用 CPUID 指令检查 CPU 支持 64位长模式。 下面我们去写好它们，如下所示。    //通过改写Eflags寄存器的第21位，观察其位的变化判断是否支持CPUID    int chk_cpuid()    {        int rets = 0;        __asm__ __volatile__(            "pushfl \n\t"            "popl %%eax \n\t"            "movl %%eax,%%ebx \n\t"            "xorl $0x0200000,%%eax \n\t"            "pushl %%eax \n\t"            "popfl \n\t"            "pushfl \n\t"            "popl %%eax \n\t"            "xorl %%ebx,%%eax \n\t"            "jz 1f \n\t"            "movl $1,%0 \n\t"            "jmp 2f \n\t"            "1: movl $0,%0 \n\t"            "2: \n\t"            : "=c"(rets)            :            :);        return rets;    }    //检查CPU是否支持长模式    int chk_cpu_longmode()    {        int rets = 0;        __asm__ __volatile__(            "movl $0x80000000,%%eax \n\t"            "cpuid \n\t" //把eax中放入0x80000000调用CPUID指令            "cmpl $0x80000001,%%eax \n\t"//看eax中返回结果            "setnb %%al \n\t" //不为0x80000001,则不支持0x80000001号功能            "jb 1f \n\t"            "movl $0x80000001,%%eax \n\t"            "cpuid \n\t"//把eax中放入0x800000001调用CPUID指令，检查edx中的返回数据            "bt $29,%%edx  \n\t" //长模式 支持位  是否为1            "setcb %%al \n\t"            "1: \n\t"            "movzx %%al,%%eax \n\t"            : "=a"(rets)            :            :);        return rets;    }    //检查CPU主函数    void init_chkcpu(machbstart_t *mbsp)    {        if (!chk_cpuid())        {            kerror("Your CPU is not support CPUID sys is die!");            CLI_HALT();        }        if (!chk_cpu_longmode())        {            kerror("Your CPU is not support 64bits mode sys is die!");            CLI_HALT();        }        mbsp->mb_cpumode = 0x40;//如果成功则设置机器信息结构的cpu模式为64位        return;    }上述代码中，检查 CPU 是否支持 CPUID 指令和检查 CPU是否支持长模式，只要其中一步检查失败，我们就打印一条相应的提示信息，然后主动死机。**这里需要你留意的是，最后设置机器信息结构中的 mb_cpumode字段为 64,mbsp 正是传递进来的机器信息 machbstart_t结构体的指针。**获取内存布局好了，CPU 已经检查完成，合乎我们的要求。下面就要获取内存布局信息了，物理内存在物理地址空间中是一段一段的，描述一段内存有一个数据结构，如下所示。    #define RAM_USABLE 1 //可用内存    #define RAM_RESERV 2 //保留内存不可使用    #define RAM_ACPIREC 3 //ACPI表相关的    #define RAM_ACPINVS 4 //ACPI NVS空间    #define RAM_AREACON 5 //包含坏内存    typedef struct s_e820{        u64_t saddr;    /* 内存开始地址 */        u64_t lsize;    /* 内存大小 */        u32_t type;    /* 内存类型 */    }e820map_t;获取内存布局信息就是获取这个结构体的数组，这个工作我们交给 init_mem函数来干，这个函数需要完成两件事：一是获取上述这个结构体数组，二是检查内存大小，因为我们的内核对内存容量有要求，不能太小。下面我们来动手实现这个 init_mem函数。     #define ETYBAK_ADR 0x2000    #define PM32_EIP_OFF (ETYBAK_ADR)    #define PM32_ESP_OFF (ETYBAK_ADR+4)    #define E80MAP_NR (ETYBAK_ADR+64)//保存e820map_t结构数组元素个数的地址    #define E80MAP_ADRADR (ETYBAK_ADR+68) //保存e820map_t结构数组的开始地址    void init_mem(machbstart_t *mbsp)    {        e820map_t *retemp;        u32_t retemnr = 0;        mmap(&retemp, &retemnr);        if (retemnr == 0)        {            kerror("no e820map\n");        }        //根据e820map_t结构数据检查内存大小        if (chk_memsize(retemp, retemnr, 0x100000, 0x8000000) == NULL)        {            kerror("Your computer is low on memory, the memory cannot be less than 128MB!");        }        mbsp->mb_e820padr = (u64_t)((u32_t)(retemp));//把e820map_t结构数组的首地址传给mbsp->mb_e820padr         mbsp->mb_e820nr = (u64_t)retemnr;//把e820map_t结构数组元素个数传给mbsp->mb_e820nr         mbsp->mb_e820sz = retemnr * (sizeof(e820map_t));//把e820map_t结构数组大小传给mbsp->mb_e820sz         mbsp->mb_memsz = get_memsize(retemp, retemnr);//根据e820map_t结构数据计算内存大小。        return;    }上面最难写的是 mmap函数。不过，我们还是有办法破解的。如果你理解了前面调用 BIOS的机制，就会发现，**只要调用了 BIOS 中断，就能获取 e820map结构数组**。为了验证这个结论，我们来看一下 mmap的函数调用关系：    void mmap(e820map_t **retemp, u32_t *retemnr)    {        realadr_call_entry(RLINTNR(0), 0, 0);        *retemnr = *((u32_t *)(E80MAP_NR));        *retemp = (e820map_t *)(*((u32_t *)(E80MAP_ADRADR)));        return;    }可以看到，mmap 函数正是通过前面讲的**realadr_call_entry函数**，来调用实模式下的 \_getmmap 函数的，并且在 \_getmmap函数中调用 BIOS 中断的。    _getmmap:      push ds      push es      push ss      mov esi,0      mov dword[E80MAP_NR],esi      mov dword[E80MAP_ADRADR],E80MAP_ADR ;e820map结构体开始地址      xor ebx,ebx      mov edi,E80MAP_ADR    loop:      mov eax,0e820h ;获取e820map结构参数      mov ecx,20    ;e820map结构大小      mov edx,0534d4150h ;获取e820map结构参数必须是这个数据      int 15h  ;BIOS的15h中断      jc .1      add edi,20      cmp edi,E80MAP_ADR+0x1000      jg .1      inc esi      cmp ebx,0      jne loop ;循环获取e820map结构      jmp .2    .1:      mov esi,0    ;出错处理，e820map结构数组元素个数为0    .2:      mov dword[E80MAP_NR],esi ;e820map结构数组元素个数      pop ss      pop es      pop ds      ret如果你不明白上面代码的原理，请回到"Cache与内存：程序放在哪儿"那节课slate-object="inline"，看一下获取内存视图相关的知识点。init_mem 函数在调用 mmap 函数后，就会得到 e820map结构数组，其首地址和数组元素个数由 retemp，retemnr两个变量分别提供。初始化内核栈因为我们的操作系统是 C语言写的，所以需要有栈，下面我们就来给即将运行的内核初始化一个栈。这个操作非常简单，就是在机器信息结构machbstart_t中，记录一下栈地址和栈大小，供内核在启动时使用。不过，就算操作再简单，我们也要封装成函数来使用。让我们动手来写出这个函数吧，如下所示。    #define IKSTACK_PHYADR (0x90000-0x10)    #define IKSTACK_SIZE 0x1000    //初始化内核栈    void init_krlinitstack(machbstart_t *mbsp)    {        if (1 > move_krlimg(mbsp, (u64_t)(0x8f000), 0x1001))        {            kerror("iks_moveimg err");        }        mbsp->mb_krlinitstack = IKSTACK_PHYADR;//栈顶地址        mbsp->mb_krlitstacksz = IKSTACK_SIZE; //栈大小是4KB        return;    }init_krlinitstack 函数非常简单，但是其中调用了一个 move_krlimg函数你要注意，这个我已经帮你写好啦，它主要负责判断一个地址空间是否和内存中存放的内容有冲突。因为我们的内存中已经放置了机器信息结构、内存视图结构数组、二级引导器、内核映像文件，所以在处理内存空间时不能和内存中已经存在的他们冲突，否则就要覆盖他们的数据。0x8f000～（0x8f000+0x1001），正是我们的内核栈空间，我们需要检测它是否和其它空间有冲突。放置内核文件与字库文件放置内核文件和字库文件这一步，也非常简单，甚至放置其它文件也一样。因为我们的内核已经编译成了一个独立的二进制程序，和其它文件一起被打包到映像文件中了。所以我们必须要从映像中把它解包出来，将其放在特定的物理内存空间中才可以，放置字库文件和放置内核文件的原理一样，所以我们来一起实现。    //放置内核文件    void init_krlfile(machbstart_t *mbsp)    {    //在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找kernel.bin文件        u64_t sz = r_file_to_padr(mbsp, IMGKRNL_PHYADR, "kernel.bin");        if (0 == sz)        {            kerror("r_file_to_padr err");        }        //放置完成后更新机器信息结构中的数据        mbsp->mb_krlimgpadr = IMGKRNL_PHYADR;        mbsp->mb_krlsz = sz;        //mbsp->mb_nextwtpadr始终要保持指向下一段空闲内存的首地址         mbsp->mb_nextwtpadr = P4K_ALIGN(mbsp->mb_krlimgpadr + mbsp->mb_krlsz);        mbsp->mb_kalldendpadr = mbsp->mb_krlimgpadr + mbsp->mb_krlsz;        return;    }    //放置字库文件    void init_defutfont(machbstart_t *mbsp)    {        u64_t sz = 0;        //获取下一段空闲内存空间的首地址         u32_t dfadr = (u32_t)mbsp->mb_nextwtpadr;    //在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找font.fnt文件        sz = r_file_to_padr(mbsp, dfadr, "font.fnt");        if (0 == sz)        {            kerror("r_file_to_padr err");        }        //放置完成后更新机器信息结构中的数据        mbsp->mb_bfontpadr = (u64_t)(dfadr);        mbsp->mb_bfontsz = sz;        //更新机器信息结构中下一段空闲内存的首地址          mbsp->mb_nextwtpadr = P4K_ALIGN((u32_t)(dfadr) + sz);        mbsp->mb_kalldendpadr = mbsp->mb_bfontpadr + mbsp->mb_bfontsz;        return;    }以上代码的注释已经很清楚了，都是调用 r_file_to_padr 函数在映像中查找kernel.bin 和 font.fnt文件，并复制到对应的空闲内存空间中。请注意，由于内核是代码数据，所以必须要复制到指定的内存空间中。r_file_to_padr函数我已经帮你写好了，其中的原理在前面的内容里已经做了说明，这里不再展开。建立 MMU 页表数据前面解决了文件放置问题，我们还要解决另一个问题------建立 MMU页表。 我们在二级引导器中建立 MMU页表数据，目的就是要在内核加载运行之初开启长模式时，MMU需要的页表数据已经准备好了。由于我们的内核虚拟地址空间从 0xffff800000000000开始，所以我们这个虚拟地址映射到从物理地址 0 开始，大小都是 0x400000000即16GB，也就是说我们要虚拟地址空间：0xffff800000000000～0xffff800400000000映射到物理地址空间0～0x400000000。我们为了简化编程，使用**长模式下的 2MB分页方式**，下面我们用代码实现它，如下所示。    #define KINITPAGE_PHYADR 0x1000000    void init_bstartpages(machbstart_t *mbsp)    {        //顶级页目录        u64_t *p = (u64_t *)(KINITPAGE_PHYADR);//16MB地址处        //页目录指针        u64_t *pdpte = (u64_t *)(KINITPAGE_PHYADR + 0x1000);        //页目录        u64_t *pde = (u64_t *)(KINITPAGE_PHYADR + 0x2000);        //物理地址从0开始        u64_t adr = 0;        if (1 > move_krlimg(mbsp, (u64_t)(KINITPAGE_PHYADR), (0x1000 * 16 + 0x2000)))        {            kerror("move_krlimg err");        }        //将顶级页目录、页目录指针的空间清0        for (uint_t mi = 0; mi > KPML4_SHIFT) & 0x1ff项，指向同一个页目录指针页          p[((KRNL_VIRTUAL_ADDRESS_START) >> KPML4_SHIFT) & 0x1ff] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);        p[0] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);        //把页表首地址保存在机器信息结构中        mbsp->mb_pml4padr = (u64_t)(KINITPAGE_PHYADR);        mbsp->mb_subpageslen = (u64_t)(0x1000 * 16 + 0x2000);        mbsp->mb_kpmapphymemsz = (u64_t)(0x400000000);        return;    }这个函数的代码写得非常简单，**映射的核心逻辑由两重循环控制**，外层循环控制页目录指针顶，只有 16项，其中每一项都指向一个页目录，每个页目录中有 512个物理页地址。物理地址每次增加 2MB，这是由 26～30行的内层循环控制，每执行一次外层循环就要执行 512次内层循环。最后，顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) \>\>KPML4_SHIFT) & 0x1ff项，指向同一个页目录指针页，这样的话就能让虚拟地址：0xffff800000000000～0xffff800400000000和虚拟地址：0～0x400000000，访问到同一个物理地址空间0～0x400000000，这样做是有目的，**内核在启动初期，虚拟地址和物理地址要保持相同。**设置图形模式在计算机加电启动时，计算机上显卡会自动进入文本模式，文本模式只能显示ASCII字符，不能显示汉字和图形，所以我们要让显卡切换到图形模式。切换显卡模式依然要用 BIOS中断，这个调用原理我们前面已经了如指掌。在实模式切换显卡模式的汇编代码，我已经帮你写好了，下面我们只要写个C函数调用它们就好了，代码如下所示。    void init_graph(machbstart_t* mbsp)    {        //初始化图形数据结构        graph_t_init(&mbsp->mb_ghparm);        //获取VBE模式，通过BIOS中断        get_vbemode(mbsp);        //获取一个具体VBE模式的信息，通过BIOS中断        get_vbemodeinfo(mbsp);        //设置VBE模式，通过BIOS中断        set_vbemodeinfo();        return;    }上面 init_graph 函数中的这些处理 VBE模式的代码，我已经帮你写好，你可以自己在 graph.c文件查看。 什么？你不懂VBE，其实我开始也不懂，后来通过搜寻资料才知道。其实 VBE是显卡的一个图形规范标准，它定义了显卡的几种图形模式，每个模式包括屏幕分辨率，像素格式与大小，显存大小。调用BIOS 10h中断可以返回这些数据结构。如果你实在对 VBE感兴趣，可以自行阅读其规范。 这里我们选择使用了 VBE 的 118h 模式，该模式下屏幕分辨率为1024x768，显存大小是 16.8MB。显存开始地址一般为0xe0000000。屏幕分辨率为 1024x768，即把屏幕分成 768 行，每行 1024个像素点，但每个像素点占用显存的 32 位数据（4 字节，红、绿、蓝、透明各占8位）。我们只要往对应的显存地址写入相应的像素数据，屏幕对应的位置就能显示了。每个像素点，我们可以用如下数据结构表示：    typedef struct s_PIXCL    {        u8_t cl_b; //蓝        u8_t cl_g; //绿        u8_t cl_r; //红        u8_t cl_a; //透明    }__attribute__((packed)) pixcl_t;    #define BGRA(r,g,b) ((0|(rmb_ghparm.gh_framphyadr;    dispmem[x + (y * 1024)] = pix;    //x，y是像素的位置串联好了，所有的实施工作的函数已经完成了，现在我们需要在 init_bstartparm() 函数中把它们串联起来，即按照事情的先后顺序，依次调用它们完成相应的工作，实现检查、收集机器信息，设置工作环境。    void init_bstartparm()    {        machbstart_t *mbsp = MBSPADR;        machbstart_t_init(mbsp);        //检查CPU        init_chkcpu(mbsp);        //获取内存布局        init_mem(mbsp);        //初始化内核栈        init_krlinitstack(mbsp);        //放置内核文件        init_krlfile(mbsp);        //放置字库文件        init_defutfont(mbsp);        init_meme820(mbsp);        //建立MMU页表        init_bstartpages(mbsp);        //设置图形模式        init_graph(mbsp);        return;    }到这里，init_bstartparm()函数就成功完成了它的使命。显示 Logo前面我们已经设置了图形模式，也应该要展示一下了，检查一下工作成果。我们来显示一下我们内核的logo。其实在二级引导器中，我已经帮你写好了显示 logo 函数，而 logo文件是个  **24位的位图文件**，目前为了简单起见，我们**只支持这种格式的图片文件**。下面我们去调用这个函数。    void logo(machbstart_t* mbsp)    {        u32_t retadr=0,sz=0;        //在映像文件中获取logo.bmp文件        get_file_rpadrandsz("logo.bmp",mbsp,&retadr,&sz);        if(0==retadr)        {            kerror("logo getfilerpadrsz err");        }        //显示logo文件中的图像数据        bmp_print((void*)retadr,mbsp);        return;    }    void init_graph(machbstart_t* mbsp)    {            //……前面代码省略        //显示        logo(mbsp);        return;    }在图格式的文件中，除了文件头的数据就是图形像素点的数据，只不过 24位的位图每个像素占用 3字节，并且位置是倒排的，即第一个像素的数据是在文件的最后，依次类推。我们只要依次将位图文件的数据，按照倒排次序写入显存中，这样就可以显示了。我们需要把二级引导器的文件和 logo文件打包成映像文件，然后放在虚拟硬盘中。复制文件到虚拟硬盘中得先 mount，然后复制，最后转换成 VDI格式的虚拟硬盘，再挂载到虚拟机上启动就行了。这也是为什么要手动建立硬盘的原因，打包命令如下。    lmoskrlimg -m k -lhf initldrimh.bin -o Cosmos.eki -f initldrsve.bin initldrkrl.bin font.fnt logo.bmp如果手动打命令对你来说还是比较难，也别担心，我已经帮你写好了 make脚本，你只需要进入代码目录中 make vboxtest 就行了，运行结果如下。 ![](Images/8d8988ed257eed3fb56809ddde97f291.png)savepage-src="https://static001.geekbang.org/resource/image/c3/y0/c3d4f0b072b837f208fbd52749913yy0.jpg"}代码运行结果示意图啊哈！终于显示了logo。是不是挺有成就感的？这至少证明我们辛苦写的代码是正确的。但是目前我们的代码执行流还在二级引导器中，我们的目的是开发自己的操作系统，不，我们是要开发Cosmos。 **后面，我们正式用 Cosmos命名我们的操作系统。**Cosmos可以翻译成宇宙，尽管它刚刚诞生，但我对它充满期待，所以用了这样一个能够"包括万物，包罗万象"的名字。进入 Cosmos我们在调用 Cosmos 第一个 C 函数之前，我们依然要写一小段汇编代码，切换CPU 到长模式，初始化 CPU 寄存器和 C语言要用的栈。因为目前代码执行流在二级引导器中，进入到 Cosmos中这样在二级引导器中初始过的东西都不能用了。因为 CPU进入了长模式，寄存器的位宽都变了，所以需要重新初始化。让我们一起来写这段汇编代码吧，我们先在Cosmos/hal/x86/ 下建立一个 init_entry.asm文件，写上后面这段代码。    [section .start.text    [BITS 32    _start:        cli        mov ax,0x10        mov ds,ax        mov es,ax        mov ss,ax        mov fs,ax        mov gs,ax        lgdt [eGdtPtr        ;开启 PAE        mov eax, cr4        bts eax, 5                      ; CR4.PAE = 1        mov cr4, eax        mov eax, PML4T_BADR             ;加载MMU顶级页目录        mov cr3, eax          ;开启 64bits long-mode        mov ecx, IA32_EFER        rdmsr        bts eax, 8                      ; IA32_EFER.LME =1        wrmsr        ;开启 PE 和 paging        mov eax, cr0        bts eax, 0                      ; CR0.PE =1        bts eax, 31        ;开启 CACHE               btr eax,29                    ; CR0.NW=0        btr eax,30                    ; CR0.CD=0  CACHE        mov cr0, eax                    ; IA32_EFER.LMA = 1        jmp 08:entry64    [BITS 64    entry64:        mov ax,0x10        mov ds,ax        mov es,ax        mov ss,ax        mov fs,ax        mov gs,ax        xor rax,rax        xor rbx,rbx        xor rbp,rbp        xor rcx,rcx        xor rdx,rdx        xor rdi,rdi        xor rsi,rsi        xor r8,r8        xor r9,r9        xor r10,r10        xor r11,r11        xor r12,r12        xor r13,r13        xor r14,r14        xor r15,r15        mov rbx,MBSP_ADR        mov rax,KRLVIRADR        mov rcx,[rbx+KINITSTACK_OFF        add rax,rcx        xor rcx,rcx        xor rbx,rbx        mov rsp,rax        push 0        push 0x8        mov rax,hal_start                 ;调用内核主函数        push rax        dw 0xcb48        jmp $    [section .start.data    [BITS 32    x64_GDT:    enull_x64_dsc:  dq 0      ekrnl_c64_dsc:  dq 0x0020980000000000   ; 64-bit 内核代码段    ekrnl_d64_dsc:  dq 0x0000920000000000   ; 64-bit 内核数据段    euser_c64_dsc:  dq 0x0020f80000000000   ; 64-bit 用户代码段    euser_d64_dsc:  dq 0x0000f20000000000   ; 64-bit 用户数据段    eGdtLen      equ  $ - enull_x64_dsc   ; GDT长度    eGdtPtr:    dw eGdtLen - 1      ; GDT界限            dq ex64_GDT上述代码中，1～11 行表示加载 70～75 行的 GDT，13～17 行是设置 MMU并加载在二级引导器中准备好的 MMU 页表，19～30 行是开启长模式并打开Cache，34～54 行则是初始化长模式下的寄存器，55～61行是读取二级引导器准备的机器信息结构中的栈地址，并用这个数据设置 RSP寄存器。 最关键的是 63～66 行，它开始把 8 和 hal_start 函数的地址压入栈中。dw0xcb48是直接写一条指令的机器码------0xcb48，这是一条返回指令。这个返回指令有点特殊，它会把栈中的数据分别弹出到RIP，CS 寄存器，这正是为了调用我们 Cosmos的 **第一个 C 函数hal_start**。重点回顾这是我们设置工作模式与环境的最后一课，到此为止我们的二级引导器已经建立起来了，成功从GRUB手中接过了权柄，开始了它自己的一系列工作，二级引导器完成的工作不算少，我来帮你梳理一下，重点如下。1. 二级引导器彻底摆脱了 GRUB 的控制之后，就开始检查CPU，获取内存布局信息，确认是不是我们要求的 CPU和内存大小，接着初始化内核栈、放置好内核文件和字库文件，建立 MMU页表数据和设置好图形模式，为后面运行内核做好准备。2. 当二级引导器完成了上述功能后，就会显示我们操作系统的logo，这标志着二级引导器所有的工作一切正常。3. 进入 Cosmos，我们的二级引导器通过跳转到 Cosmos的入口，结束了自己光荣使命，Cosmos 的入口是一小段汇编代码，主要是开启CPU 的长模式，最后调用了 Cosmos 的第一个 C 函数hal_start。 你想过吗？我们的二级引导器还可以做更多的事情，其实还可以在二级引导器中获取ACPI 表，进而获取 CPU数量和其它设备信息，期待你的实现。思考题请你想一下，init_bstartparm() 函数中的 init_mem820()函数，这个函数到底干了什么？欢迎你在留言区跟我互动。如果你身边有朋友对手写操作系统有热情，也欢迎你把这节课转发给他。