# 22 \| Catalyst物理计划：你的SQL语句是怎么被优化的（下）？你好，我是吴磊。上一讲我们说了，Catalyst优化器的逻辑优化过程包含两个环节：逻辑计划解析和逻辑计划优化。逻辑优化的最终目的就是要把Unresolved Logical Plan 从次优的 Analyzed Logical Plan最终变身为执行高效的 Optimized LogicalPlan。 但是，逻辑优化的每一步仅仅是从逻辑上表明 Spark SQL需要"做什么"，并没有从执行层面说明具体该"怎么做"。因此，为了把逻辑计划交付执行，Catalyst还需要把 Optimized Logical Plan转换为物理计划。物理计划比逻辑计划更具体，它明确交代了 Spark SQL的每一步具体该怎么执行。![](Images/853d5907daf6835ad81ffc506ca0ce23.png)savepage-src="https://static001.geekbang.org/resource/image/53/fd/534dd788609386c14d9e977866301dfd.jpg"}物理计划阶段今天这一讲，我们继续追随小 Q 的脚步，看看它经过 Catalyst的物理优化阶段之后，还会发生哪些变化。优化 Spark Plan物理阶段的优化是从逻辑优化阶段输出的 Optimized Logical Plan开始的，因此我们先来回顾一下小 Q 的原始查询和 Optimized LogicalPlan。     val userFile: String = _    val usersDf = spark.read.parquet(userFile)    usersDf.printSchema    /**    root    |-- userId: integer (nullable = true)    |-- name: string (nullable = true)    |-- age: integer (nullable = true)    |-- gender: string (nullable = true)    |-- email: string (nullable = true)    */    val users = usersDf    .select("name", "age", "userId")    .filter($"age"  SMJ \> SHJ \> BNLJ \> CPJ的顺序，依次判断查询语句是否满足每一种 Join策略的先决条件进行"择优录取"。如果开发者不满足于 JoinSelection 默认的选择顺序，也就是 BHJ \> SMJ \>SHJ \> BNLJ \> CPJ，还可以通过在 SQL 或是 DSL 语句中引入 Joinhints，来明确地指定 Join 策略，从而把自己的意愿凌驾于 Catalyst之上。不过，需要我们注意的是，要想让指定的 Join策略在运行时生效，查询语句也必须要满足其先决条件才行。在生成 Physical Plan 这个环节，Catalyst 基于既定的几组 PreparationRules，把优化过后的 Spark Plan 转换成可以交付执行的物理计划，也就是Physical Plan。在这些既定的 Preparation Rules 当中，你需要重点掌握EnsureRequirements 规则。EnsureRequirements用来确保每一个操作符的输入条件都能够得到满足，在必要的时候，会把必需的操作符强行插入到Physical Plan 中。比如对于 Shuffle Sort Merge Join来说，这个操作符对于子节点的数据分布和顺序都是有明确要求的，因此，在子节点之上，EnsureRequirements会引入新的操作符如 Exchange 和Sort。 每日一练3 种 Join 实现方式和 2 种网络分发模式，明明应该有 6 种 Join策略，为什么 Catalyst 没有支持 Broadcast Sort Merge Join策略？ 期待在留言区看到你的思考和答案，我们下一讲见！