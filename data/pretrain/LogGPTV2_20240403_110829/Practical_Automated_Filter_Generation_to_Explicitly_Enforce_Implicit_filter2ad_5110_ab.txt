Module
4
Input
2
3
Script
 Output
Filtering
 Script
All assumptions hold ⇒
Pass input on to application
Failing assumption found ⇒
Drop input; write to error log
Figure 2. Decision-making process – events
are numbered in temporal sequence
Note  that  the  script  generation  process  (Fig.1)  is
completely  decoupled  from  the  real-time  processing  of
input  data  (Fig.2),  i.e.,  the  filtering  script  is  generated
entirely  offline,  once  per  application.  The  performance
cost  of  filtering  is  thus  determined  solely  by  the  cost  of
script interpretation at run-time, plus the time to perform
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:06:13 UTC from IEEE Xplore.  Restrictions apply. 
two local procedure calls – from the intercepting  module
to the filtering script and back.
3.2. Expressing Assumptions
We  express  each  assumption  about  an  application’s
input  as  a  logical  clause.  Semantically  these  clauses  are
AND-ed  together  to  form  a  Boolean  expression  in
conjunctive  normal  form  (CNF).  Verifying  that  the
Boolean  expression  is  satisfied  for  a  given  input  is
equivalent to  ensuring  that  all  stated  assumptions  on  this
input  hold.  For  a  broad  set  of  assumptions, 
their
representation  naturally  translates  into  simple  logical
expressions  without  disjunction  or  negation  operations;
this in turn significantly simplifies the formal language for
describing  assumptions.  There  are 
few  exceptions
requiring  more  complex  clauses  and  the  semantics  of  a
disjunction  (we  discuss  them  in  the  Implementation
section);  as  it  turns  out,  these  can  be  easily  handled
without  compromising  the  simplicity  of 
the  formal
description.
An important design choice we made was to embrace
the  “positive”  filtering  approach  (as  in  [21]),  having
assumptions  explicitly  specify  what  is  permitted,  rather
than  what  is  not.  (We  allowed  one  specific  exception  to
this rule, adding a provision for checking for known rogue
inputs. Although such an assumption carries a “negative”
meaning,  it  does  not  alter  the  general  thrust  toward
positive  filtering,  while  significantly  enhancing 
the
expressive power and usefulness of filters, as explained in
[4].) In contrast, [17] specifies known misbehaviors on the
part of a Java applet, and applies a set of filtering rules to
each  new  (downloaded)  applet.  In  [12]  too,  incorrect  –
rather than correct – behavior  is  specified  in  the  security
policy, which restricts the violations to check for to only a
set of  well-known and anticipated attacks. The default in
both  of  these  systems  is  to  allow  any  behavior  not
explicitly prohibited. Our more conservative approach has
the benefit of making filters more likely to catch unknown
vulnerabilities  as  well  (for  which  a  “negative”  filter  can
only be specified after the fact). Moreover, in the case of
an  underspecified  input  filtering  policy,  the  error  would
more often be on the side of security.
3.3. Intermediate Description Language
For  greater  flexibility  we  decided  in  favor  of  going
through 
intermediate  filter  descriptions  and  against
generating filtering scripts directly from a GUI-based tool
(which  would  have  effectively  merged  the  description
synthesizer  and  filter  generator  in  Figure  1).  As  a  result,
filter  specification  is  decoupled  from  script  generation,
allowing the administrator to mix choices of specific tools
to be used for each.
The  most  obvious  candidate  for  an  intermediate
description language is XML [26] – an emerging standard
for  data  representation  in  distributed  applications.  XML
ideally  fits  our  needs,  being  flexible  (allowing  custom-
defined  structures),  extensible,  human-readable  and
portable  across  platforms.  The  portability  in  particular
ensures  that  the  subset  of  XML  we  use  can  serve  as  a
common 
language,  while
anything built on top can be replaced or bypassed.
intermediate  description 
4. Implementation
For  our  prototype  implementation,  we  focus  on  the
back-end  server  application  case.  In  a  typical  scenario,  a
web  server  receives  HTTP  requests  from  clients  and
passes  those  on  to  back-end  server  applications.  If
requests  (say,  in  the  form  of  scripting  page  URLs
followed  by  input  values  presented  as  tuples  of  the  form
‘=’)  are  not  validated,  then
maliciously  constructed  data  in  the  requests  (e.g.,  values
of  unexpectedly  large  sizes,  or  ones  containing  active
scripting  code  disguised  as  data,  etc.)may  undermine  the
operation  of  the  back-end  server  application.  Hence  the
need for filtering of client input data by web servers.
4.1. Web Server Input Filtering
Once  a  web  server  filtering  script  is  produced  by  a
filter  generator  (via  the  process  illustrated  in  Figure  1),
input filtering works as follows (see Figure 2):
  Upon  receiving  an  HTTP  request,  the  filtering
script  is  invoked  by  the  web  server  via  an  intercepting
module. (For example, in the case of an IIS server running
on  Windows  NT,  the  filtering  script  is  registered  as  a
COM  object,  and  the  intercepting  module  is  an  ISAPI
filter  DLL  configured  to  call  the  script  via  its  COM
interface.)
to 
  The  intercepting  module  passes  the  request  to  the
filtering  script,  which  then  parses  it  into  a  set  of
“parameters”,  according 
the  corresponding  XML
description of the parsing scheme (as implemented in the
script).
  The  filtering  script  tests  each  extracted  parameter
to  make  sure  it  satisfies  the  assumptions  specified  in  the
corresponding XML description of assumptions (and thus
also implemented in the script).
  The  output  of  the  filtering  script  is  an  error  code
indicating whether the HTTP request was accepted by the
filter  and,  if  not,  what  problem  was  detected.  The
intercepting module receives that output and either passes
the  HTTP  request  on  to  the  back-end  application  (if  the
request  was  successfully  validated)  or  writes  to  an  error
log and has the  web server redirect  the  client  to  an  error
notification URL (in the case of a rejected HTTP request).
Next, we give implementation details for the building
blocks shown in Figure 1.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:06:13 UTC from IEEE Xplore.  Restrictions apply. 
4.2. Scripting Language
scripting 
The  appropriate 
language  necessarily
depends on the type of filter being generated. For instance,
if  a  firewall  filter  were  needed,  a  specially  tailored
(firewall) scripting language would be employed, whereas
in the context of back-end server applications it would be
a  scripting  language  suitable  for  web  servers,  such  as
VBScript  or  JavaScript.  We  have  chosen  VBScript  [15]
for our prototype implementation. However, we note that,
in  order  to  provide  a  proof-of-concept  solution,  our
filtering  scripts  do  not  use  any  language-specific  or
platform-specific  features.  Thus,  the  scripting  language
itself may later be replaced by altering the component of
the filter generator responsible for writing out the filtering
script,  without  necessitating  any  changes 
to  other
components.
4.3. Description of the Parsing Scheme
The  input  is  initially  treated  as  a  single  character
string,  which  is  to  be  delimited  first  into  what  would
become  the  constituent  parameters.  As  an  example,
consider  the  sample  HTTP  request  shown  in  Figure  3
being  sent  to  a  web  server,  and  one  possible  parsing  of
this input string into parameters.
We allow two alternative ways to define the boundary
between  one  parameter  and  the  next:  by  specifying  a
single-character  end-delimiter  of 
(first)
parameter, or by giving the exact length of that parameter.
The only exception to this rule is the very last parameter –
running to the end of the input string – it is “delimited” by
the  special  NULL  end-delimiter. 
(An  end-delimiter
character,  if  specified,  is  excluded  from  the  current
extracted parameter.)
the  current 
If  there  are  multiple  possible  formats  for  the  input
(with  different  structures  and  thus  different  constituent
parameters),  then  a  separate  filter  will  be  necessary  for
each  such  structure.  The  intercepting  module  would
invoke  each  filter,  and  accept  the  input  only  if  it  is
accepted by at least one of the filters.
To  aid  the  administrator  in  formally  describing  a
parsing scheme, we have implemented a GUI-based tool,
the output of which is the XML description of the parsing
scheme specified via the GUI. A sample XML description
is shown in Figure 4.
It highlights the small uniform set of XML tags needed
to  express  how  a  string  is  to  be  parsed  into  parameters.
Each  parameter  has  its  boundaries  defined  inside  an
instance  of  a    tag  structure.  This  structure
represents a collection of four substructures:
    –  the  current  parameter  number  (in
order from left to right);
    –  specifies  whether  the  end  of  the
current  parameter  is  determined  by  an  exact  parameter
length  in  number  of  characters  (LENGTH)  or  by  an  end-
delimiter character (END_DELIM);
    –  either  the  parameter  length  or  the
end-delimiter  character,  depending  on  the  choice  of
;
    –  (optional)  concise  natural-language
description of the semantics of the current parameter.
    1
    END_DELIM
    :
    Protocol name
    2
    LENGTH
    2
    Double slash, i.e. //
    3
    END_DELIM
    /
    Server name
    8
    END_DELIM
    NULL
    Second (real) parameter value
Figure 4. XML parsing scheme description of
the sample HTTP request; output from GUI tool
from 
the  protocol  name)  starts 
Reading the XML description in Figure 4, parameter 1
(semantically, 
the
beginning of the input string and ends immediately before
the  first  colon.  Then,  parameter  2  (meant  to  be  the
delimiting double slash after the protocol name) picks up
immediately  after  the  delimiting  colon  and  is  exactly  2
characters long. Parameter 3 (supposed to contain a server
name) starts immediately after parameter 2 and continues
until the next slash-character in the input, etc. Parameter 8
http://www.foomusic.com/my-query?page=%2Fpop%2F&club=classical
http1  //2  www.foomusic.com3  my-query4  page5  %2Fpop%2F6  club7  classical8
Figure 3. One possible parsing of a sample HTTP request string into parameters.
For clarity parameters (second line) are shown separated by spaces and numbered in superscript
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:06:13 UTC from IEEE Xplore.  Restrictions apply. 
(meant  in  our  sample  break-up  to  hold  the  value  of  the
“club” property) starts (naturally) after parameter 7 and
is  comprised  of  all  characters  until  the  end  of  the  input
string.
4.4. Description of the Assumptions
We  now  turn  to  the  set  of  assumptions  that  can  be
enforced on each parameter.
The majority of desirable constraints can be expressed
using  a  fairly  simple  set  of  relations.  The  expected
improved  usability  was  the  reason  we  decided  against
expressing assumptions using more general and powerful
languages  such  as  that  of  regular  expressions.  Although
there  may  be  a  few  constraints  of  practical  interest  that
regular  expressions,  but  not  our  limited  language,  can
capture, we have not sacrificed any essential functionality
(although some assumptions may need to be expressed as
“complex assumptions”; see below). Our goal is to be able
to  prevent  a  substantial  fraction  of  the  recurring  (and
potentially  highly  damaging)  vulnerabilities,  while
keeping  the  filtering  process  as  simple  as  possible.
Avoiding some security holes may require more complex
treatment, but many others will be relatively easy to fend
off. (Facing a similar choice between simplicity and extra
functionality  the  authors  of  [21]  also  decided  in  favor  of
simplicity.)  We  believe  that  in  practice  this  more  than
makes  up  for  the  lack  of  extra  generality  in  the  basic
language; the simpler the security tools, the more likely it
is that they will be used effectively.
Our  tool  implements  a  set  of  13  relations  (Table  1).
Adding more would not conflict with the model; however
it  would  require  minor  changes  to  the  filter-generating
tool.
In 
the  XML  description  of  assumptions,  each
assumption  is  specified  either  on  a  parameter  itself
(SELF)  or  on  its  size  (SIZE).  (The  latter  naturally  takes
only numerical values.)
Consider the sample HTTP request (above) and the set
of parameters extracted  from it. Below is a partial list  of
the  assumptions  (first  in  natural  language,  then  in  XML)
that one might wish to impose on some of the parameters:
Parameter  1  (protocol  name)  should  be  one  of
“http” or “https”
Parameter 3 (server name) should be no more than
30 characters long
Parameter 3 (server name) should have “.com” as
suffix
We  describe  these  sample  assumptions  in  XML  in
Figure 5. As the example makes obvious, each assumption
on  a  parameter  is  described  within  a  separate  
tag  structure.  That  structure 
is  comprised  of  six
substructures:
    –  the  number  (in  order  from  left  to
right) of the parameter to which the assumption applies;
    –  the  parameter  function,  specifying
whether  the  current  assumption  concerns  the  parameter
itself (SELF), or its size in number of characters (SIZE);
   – the relation (from Table 1) between the
current parameter (or its size – depending on the choice of
)  and  the  list  of  constants  specified  in  the
 tag;