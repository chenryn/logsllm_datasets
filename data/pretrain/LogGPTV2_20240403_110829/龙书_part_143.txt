2）从读访问 x[j+2]到写访问x[j+1]的反依赖关系。这里j+2=j’+1，即j=j′-1。把j=
让我们考虑三对数据依赖关系：
对于从 s 到 s;以及从 s 到其自身的依赖关系的分析将得到类似的结果。外层循环的第个
当ix40
，寻找时间分划约束解的算法必
第11章
口
---
## Page 569
求解。方法如下：
因为i和嵌套在循环结构d2中的语句s2的访问,=，令和<C2,C2
算法11.59
c,y≥0 的解，从而证明系统的否命题，即对于所有满足 Ax≥0 的x，都有c"x≥0。
对于每个对偶系统中有解的向量c，原系统不存在解。换句话说，我们可以找到对偶系统A“y
仍然没有找到有关这个引理或者它的某个等价定理的简单、直观的证明。
明的 Farkas 引理是择一性定理之一。这些定理相互等价，但是尽管经过了多年的尝试，人们
并行性和局部性优化
@和算法11.43的步骤 2@类似，对方程
2）对于每一对具有数据依赖的访问，在循环结构d中的语句s,中的访问.买=<F;,f,B,
这个对偶系统可以用 Fourier-Motzkin 消除法进行处理，通过投影消除变量y。这个引理保证,
① 应用 Farkas 引理。找到满足上面两个约束的x 的任务等价于寻找满足下列条件的 y：
其中A为一个矩阵。
@把循环下标变量的先后关系约束和循环边界表示为
其中D为-一个矩阵。
令c为这个分划映射中的所有未知量。把因为分划映射而产生的线性不等式约束可写成
归约为某个未知量的向量x。
应用高斯消除法把向量
那么必然有Ci+C≤C2i2+C2
4)Fi+f=F2i2+f2
3) B2i2 +b2≥0
2) B;i +b,≥0
1) i <
·如果 Z中所有的i和Zd中的i满足下列条件,
1）找出程序中所有具有数据依赖关系的访问对。
方法：算法包括以下步骤：
输出：线性独立时间分划映射的最大集。
输入：一个带有数组访问的循环嵌套结构。
关于这个引理的证明可以在很多关于线性规划的标准课本中找到。最早在1901 年被证
为一个外层的顺序循环找到一个合法的最大线性独立的仿射时间分划映射。
A'y=D'c 且y ≥0
Fi+f=F2i2+f2
关于 Farkas 引理
cTDx≥0
 Ax ≥0
L2
553
V
---
## Page 570
例11.61
来生成代码。
的第行，我们就可以得到这样的转换。一旦构造出这个仿射变换，我们就可以使用算法11.45
一个循环嵌套结构，其最外层的k个循环是完全可交换的循环。通过直接把第k个解变成新转换
提高单处理器系统的数据局部性或降低并行执行中的处理器之间的同步开销。
线，或得到－1个可并行化的内层循环。而且，我们还可以对完全可交换循环应用分块技术，以
换成为具有个最外层完全可交换循环的结构。可以对这个结构进行转换得到k－1度的流水
11.9.8代码转换
请注意，我们在例11.57中得到的特定解满足这些约束。
等价。解这个不等式系统，我们得到
Farkas 引理说这些约束和
例11.60
到。
本思路是跟踪每个语句的当前解集，并通过插人一些约束不断寻找更多的独立解。这些被插人
约束表示为 Ec≥0。
如果一个循环嵌套结构的时间分划约束存在个独立解，那么就可能把这个循环嵌套结构转
4）根据找到的每个解c'得到一个仿射时间分划映射。映射的常量项通过不等式 Ec ≥0 得
554
如果一个循环嵌套结构的时间分划约束具有k个独立解，我们就可以容易地根据这些解生成
利用完全可交换循环
3）使用附录B 中的算法B.1，找出 E'c'≥0 的线性独立解的最大集合。这一-复杂的算法的基
令E'c＇≥0 为不包含常量项的约束。
 在这个形式中，应用 Fourier-Motzkin 消除法把y 的变量通过投影消除，并把关于系数c 的
请注意，这里的cT'D 就是 Farkas 引理中的c，而且我们使用的是这个引理的否定形式。
在例11.58 中为我们的 SOR 例子找到的解是
例11.57 的约束可以写作
"-］
0= - =10=11
[-1 0 1 0]]
- C12
[z] =
C21
[C2 -C1
- C11
(c2-c)]
且z≥0 
=
L.1
厂i
≥0
第11章
口
---
## Page 571
算任务，其中"被定义为这k个可交换循环中所有下标的某种组合。比如，=i++i就是这
容易的。虽然我们更倾向于使用流水线化，但为完整起见，我们仍在这里给出这个方法。
发出的信号，表明它们已经执行完了各自的第k个循环中的第i个选代。
度上相同，而第k个下标值则包括了该下标的全部可能值。每个处理器顺序地执行第k个循环中
O( n-1）个处理器上。每个处理器负责一个选代的集合，该集合中选代的下标值在前k-1个维
已经执行完毕。因此，我们可以按照如下方法把这个迭代空间的前k－1个维度的分划分配到
违反数据依赖约束的前提是下列迭代
11-52a和图11-52b 中的代码。
行了选代[p-1,i2］。这个技术可以根据图 11-51la 和图 11-51b 中的完全可交换循环分别生成图
处理器p在执行选代[p,i2]之前必须等待处理器p-1 的信号，这个信号表明处理器 p-1 已经执
方法在一个流水线中保证这个顺序。我们把迭代i分配给处理器 P。每个处理器按照原来的川
余各行，以上讨论仍然成立。因为我们可以任意排列这些解，所以这些循环是完全可交换的。
约束保证这样的分解不会违反任何数据依赖关系。然后，我们根据第二个解对各个最外层循环中的迭
它生成图11-51c中的代码。
这个转换生成图11-51a 中的代码。
样的一个组合。
代的前提是它收到了处理器
序执行内层循环中的迭代，因此保证了迭代[i,]在迭代[,-1]之后执行。另外，我们要习
知道只要在迭代[,-I]和[－1,i]执行之后，迭代[,]就可以被执行。我们可以用如
任务依然按以前的顺序执行。每个分划单元中的前k-1个循环--定是可并行化的。直观地讲
－1度流水线并行性的代码。
代进行分划。这个分划必然是合法的，原因是我们处理的是原来的迭代空间的子集。对于矩阵中的其
显然，这样的转换产生了--个合法的顺序程序。第一-行按照第--个解来分划整个迭代空间。时间
并行性和局部性优化
我们创建一个最外层的顺序循环，该循环以升序遍历这个讠'分划，在各个分划单元中的计算
波阵面化 
一般来说，给定k个最外层的完全可交换循环，具有下标值（i，,i）的迭代可以执行且不
根据一个具有个最外层完全可交换循环的循环结构生成k-1个可并行化内层循环是比较
我们可以轻易地把一个具有k个最外层完全可交换循环的循环嵌套结构转换成为-一个具有
利用流水线化技术
如果我们把第二个解作为第一行，我们可以得到转换
[i-1,i..,],[i,-1,i...,ik],..,[i...,-,k-1]
0]
0
555
口
---
## Page 572
一个二维数据数组进行运算。被执行的迭
的代码实现了一个 0(n²）的算法，该算法对
下处理单循环嵌套结构的。图11-57 中显
11.59 是如何在只有流水线化并行性的情
例11.G3
交换被访问的数据。处于块内部的数据仅由
点是程序只需要在块和它的邻居块的边界上
粒度。请注意，每个处理器只在块的边界上和它的前驱及后继进行通信。因此，分块的另一个优
传递不需要处理器之间的通信。我们还可以把块的一列分配给一个处理器，以便加粗流水线的
算任务分成6×b块。分块后的代码的执行顺序如图 11-56 所示，等价的代码显示在图 11-55h中。
一个处理器处理。
分块技术可以用于增强数据局部性并最小化流水线的开销。
迭代的块组合成为一个单元，而不是根据最外层或者最内层的循环下标值把迭代分配给处理器。
执行。这个策略保证了在最外层循环中的各个选代之间没有数据依赖。
如果给定一个二维的迭代空间，这个转换沿着135°的斜线把迭代组合起来，作为外层循环的一-次
法一
假设我们有－一个二维完全可交换的循环嵌套结构，如图 11-55a所示，且我们希望把这个结构的计
556
一个深度为k的完全可交换的循环嵌套结构可以在k个维度上进行分块。我们可以把多个