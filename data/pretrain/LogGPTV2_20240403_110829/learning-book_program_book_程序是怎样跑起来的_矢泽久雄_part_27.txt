点估计大家也预料到了。
没错，条件分支就是利用这些指令来实现的。不过，为了以防万
一，我们来确认一下。代码清单10-11是，根据变量a的值来调用不同
函数（MySub1函数、MySub2函数、MySub3函数）的C语言源代码。
为了实现条件分支，这里使用了if语句。示例中被调用的各个函数，
都不进行任何处理。将代码清单10-11的MyFunc函数处理转换成汇编
202
---
## Page 217
10.12条件分支的实现方法
语言源代码后，结果就如代码清单10-12所示。
代码清单10-11进行条件分支的C语言源代码
//定义nySub1函数
void MySub1 ()
//不做任何处理
//定义mySub2函数
void MySub2 ()
//不做任何处理
//定义购ySub3函数
vold MySub3 ()
//不做任何处理
//定义MyPune函数
void MyFunc [)
int a - 123;
//根据条件调用不同的函数
if (a > 100)
MySub1 (1 ;
el=e if (a < 50)
MySub2 () :
else
MySub3 () ;
代码清单10-12将代码清单10-11的MyFunc函数转换成汇编语言后的结果
_MyPune
push
ebp:
proc
near
mov
ebp.esp:
更多资料请关注裁的新浪薄客http：//blc
---
## Page 218
第10章通过汇编语言了解程序的实际构成
mov
eax, 123
：把123存入eax寄存慕中
eax, 100
把eax寄存器的值同100进行比较
short e8
：比100小时，跌转到8标签
ca11
_MySub1
：院转到011标签
；调用MySub1函数
jnp
short e11
88:
cnp
eax, 50
把eax备存器的值同50进行比较
Jge
short 810
大于50时，凯转到10标签
ca11
_hySub2
：调用MySub2函数
jnp
short 911
：跳转到011标签
810:
ca11
_MySub3
ebp
：调用MySub4函数
911:
pop
19.1
_MyPunc
endp
代码清单10-12中用到了三种跳转指令，分别是比较结果小时跳转
的 jle （ jump on less or equal ）、大时跳转的 jge （ jump on greater or
equal）、不管结果怎样都无条件跳转的jmp。在这些跳转指令之前还有
用来比较的cmp指令，比较结果被保存在了标志寄存器中。这里我们
添加了注释，大家不妨顺着程序的流程看一下。虽然同C语言源代码
的处理流程不完全相同，不过大家应该知道处理结果是相同的。此外，
还有一点需要注意的是，eax寄存器表示的是变量a。
虽然大部分的C语言参考书中都写着“为了便于理解程序的结构，
应尽量避免使用无条件分支的goto语句”，不过，在汇编语言这一领域
中，如果不使用相当于C语言goto语句的jmp指令，就无法实现循环
和条件分支。由此看来，关于应不应该在C语言中使用goto语句，大
家没有必要这么紧张。
10.13
了解程序运行方式的必要性
通过对C语言源代码和汇编语言源代码进行比较，想必大家对
“程序是怎样跑起来的”又有了更深的理解。而且，从汇编语言源代码
中获得的知识，在某些情况下对查找bug的原因也是有帮助的。
---
## Page 219
10.13了解程序运行方式的必要性
让我们来看个示例。代码清单10-13是更新全局变量coumter的值
的C语言程序。MyFunc1函数和MyFunc2函数的处理内容，都是把全
局变量counter的值放大到2倍。counter*=2；指的是把coumter的数
值乘以2，然后再把所得结果赋值到coamter的意思。这里，假设我们
利用多线程处理同时调用了一次MyFunc1函数和MyFunc2函数。这
时，全局变量coumter的数值，理应变成100x2x2=400。然面，某些
时候结果也可能会是200。至于为什么会出现该bug，如果没有调查过
汇编语言的源代码，也就是说如果对程序的实际运行方式不了解的话，
是很难找到其原因的。
代码清单10-13两个函数更新同一个全局变量数值的C语言程序
//定义全局变量
int counter -100;
//定义wyPunc1函数
void HyPuncl ()
counter *= 2;
1/定义xyPunc2函数
vofd MyFunc2 ()
countex *=2;
将代码清单10-13的counter*=2：部分转换成汇编语言源代码后
结果就如代码清单10-14所示。这里希望大家注意的是，C语言源代码
中counter*=2；这一个指令的部分，在汇编语言源代码，也就是实际运
行的程序中，分成了3个指令。如果只是看counter*=2：的话，就会以
为couter的数值被直接扩大为了原来的2倍。然而，实际上执行的却
①“线程”是操作系统分配给CPU的最小选行单位。源代码的一个品数就相
当于一个线程。多线程处理指的是在一个程序中同时运行多个函数的意思。
---
## Page 220
第10章通过汇编语言了解程序的实际构成
是“把coumter的数值读入cax寄存器”“将eax寄存器的数值变成原来
的2倍”“把cax寄存器的数值写人coumter”这3个处理。
代码清单10-14将全局变量的值翻倍这一部分转换成汇编语言源代码的结果
mov eax, dword ptr [_oounter]
：将counter的值读入eax寄存器
add eax, eax
：将eax奇存器的值扩大至原来的2倍
mov dvord ptx [_counter],eax
：将eax寄存器的数值存入counter中
在多线程处理中，用汇编语言记述的代码每运行1行，处理都有
可能切换到其他线程（函数）中。因面，假设MyFunc1函数在读出
counfer的数值100后，还未来得及将它的2倍值200写入counfer时，
正巧MyFunc2函数读出了counter的数值100，那么结果就会导致
counter的数值变成了200（图10-8）。
多线程处理中（1）-[6）的处理交互运行
MyFunc1西数
100
全局变量
counter
100
MyFunc2函数
（1）读出counter的数值
200
初始值
（2）读出counter的数值
（3）读出的数值放大
100
200
（4）将读出的数值放大
到原来的2倍
更新后
到原来的2信
（5）写入结果
200
（6]写入结果
图10-8100×2×2的结果成200的过程
为了避免该bug，我们可以采用以函数或C语言源代码的行为单位
来禁止线程切换的锁定方法。通过锁定，在特定范围内的处理完成之
前，处理不会被切换到其他函数中。至于为什么要锁定MyFuncl函数
和MyFunc2函数，大家如果不了解汇编语言源代码的话想必是不明白
的吧。
---
## Page 221
10.13了解程序运行方式的必要性
现在基本上没有人用汇编语言来编写程序了。因为C语言等高级
编程语言用1行就可以完成的处理，使用汇编语言的话有时就需要多
行，效率很低。不过，汇编语言的经验还是很重要的。因为借助汇编
语言，我们可以更好地了解计算机的机制。特别是对专业程序员来说，
至少要有一次使用汇编语言的经验
下面让我们以开车为例进行说明。没有汇编语言经验的程序员，
就相当于只知道汽车的驾驶方法面不了解汽车结构的驾驶员。对这样
的驾驶员来说，如果汽车出现了故障或奇怪的现象，他们就无法自己
找到原因。不了解汽车结构的话，开车的时候还可能会浪费油。这样
的话，作为职业驾驶员是不合格的。与此相对，有汇编语言经验的程
序员，也就相当于了解计算机和程序机制的驾驶员，他们不仅能自己
解决问题，还能在驾驶过程中省油。
本章的内容确实有些绕，但是对了解计算机和程序的实际运行方
式来说，体验汇编语言是最有效的。如果大家会使用C语言的话，希
望大家对C语言的各种语法所对应的汇编语言都一一确认一下。最好
能编写一些简短的程序来进行反复的测试。笔者自身也是通过进行这
些会试才使自己的编程技能有了大幅提高的。
下一章，我们将会对IO端口的输人输出及中断处理等用程序来控
制硬件的方法进行说明，同时也会介绍一个使用汇编语言的示例程序。
---
## Page 223
11
第
章
硬件控制方法
热身问答
阅读正文前，让我们先回答下面的问题来热热身吧。
1.在汇编语言中，是用什么指令来同外围设备进行输入输出操
作的？
2.VO是什么的缩写？
3.用来识别外围设备的编号称为什么？
4.IRQ是什么的缩写？
5.DMA是什么的缩写？
6.用来识别具有DMA功能的外围设备的编号称为什么？
更多资料请关注我的新浪薄客tp
---
## Page 224
第11章硬件控制方法
怎么样？是不是发现有一些问题无法简单地解释清楚呢？下面
是笔者的答案和解析，供大家参考。
1.IN指令和OUT指令
2. Input/Output
3.I/O地址或1/0端口号
4. Interrupt Request
5. Direct Memory Access
6.DMA通道
1.在x86系列CPU用的汇编语言中，通过IN指令来实现IO输
人.OUT指令来实现I/O输出。
2.用来实现计算机主机和外围设备输入输出交互的IC称为I/O控
制器或简称为1O。
3.所有连接到计算机的外围设备都会分配一个1/O地址编号。
4.IRQ指的是用来执行硬件中断请求的编号。
5.DMA指的是，不经过CPU中介处理，外围设备直接同计算机
的主内存进行数据传输。
6.像磁盘这样用来处理大量数据的外围设备都具有DMA功能。
---
## Page 225
11.1应用和硬件无关？
本章
重点
“计算机如果没有软件，就仅仅是个箱子”这个该
谐的描述大家都知道吧？也就是说，即使是计算机这
种看起来很了不起的设备（硬件），离开了软件依然什么也做不了。虽
然这句话极具讽刺意味，不过也正戳到了计算机的本质。因为软件的
存在是硬件正常运行的必要条件。通过前面的章节我们已经知道，控
制CPU，只需把编译器或汇编器生成的本地代码加载到主内存并运行
就可以了。那么，如何用程序来控制CPU和主内存以外的硬件呢？本
章我们就会对这个问题进行解答。
11.1应用和硬件无关？
在用C语言等高级编程语言开发的Windows应用中，大家很少能
接触到直接控制硬件的指令。这是因为硬件的控制是由Windows全权
负责的。
不过，Windows 提供了通
过应用来间接控制硬件的方法。
应用
利用操作系统提供的系统调