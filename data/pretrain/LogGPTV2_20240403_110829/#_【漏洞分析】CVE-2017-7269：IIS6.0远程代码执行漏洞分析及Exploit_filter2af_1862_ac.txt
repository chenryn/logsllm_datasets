        else if ( !*v17 )
        {
          v16 = v41-- - 1;
        }
      }
      v18 = v16 - v42 + v7 + 1;
      v19 = *v34 > 2;
        qmemcpy(v35, WideCharStr, 4 * v24);//拷贝虚拟路径
        v26 = &WideCharStr[2 * v24];
        v25 = &v21[2 * v24];
        LOBYTE(v24) = v23;
        v27 = v42;
        qmemcpy(v25, v26, v24 & 3);
        v28 = v7 - v27;//这里v7是0x2fd，相减赋值给v28，这个值很大，v27为0
        v29 = &Str[v27];
        v30 = v35;
        qmemcpy(&v35[v22], v29, 2 * v28 + 2);//直接拷贝到栈中，没有对长度进行检查，导致溢出
        for ( i = &v30[v41]; *i; ++i )
        {
          if ( *i == 47 )
            *i = 92;
        }
        *v34 = v37;
        result = v36;
      }
      return result;
    }
**CVE-2017-7269 Exploit!精妙的漏洞利用**
其实通过上面的分析，我们发现这个漏洞的 原理非常简单，但是究竟如何利用呢，我们来看一下关于ScStorageFromUrl函数中，包含了GS
check，也就是说，我们在进行常规的覆盖ret方式利用的情况下，将会把cookie也会覆盖，导致利用失败。
    .text:67127017 loc_67127017:                           ; CODE XREF: ScStoragePathFromUrl(IEcb const &,ushort const *,ushort *,uint *,CVRoot * *)+50j
    .text:67127017                                         ; ScStoragePathFromUrl(IEcb const &,ushort const *,ushort *,uint *,CVRoot * *)+67j
    .text:67127017                 mov     ecx, [ebp+var_C]
    .text:6712701A                 pop     edi
    .text:6712701B                 mov     large fs:0, ecx
    .text:67127022                 mov     ecx, [ebp+var_10]
    .text:67127025                 pop     esi
    .text:67127026                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
    .text:6712702B                 leave
    .text:6712702C                 retn    0Ch
漏洞利用非常精妙，也就是用这种方法，巧妙的绕过了gs的检查，最后达到漏洞利用，稳定的代码执行，首先，WebDav对数据包的处理逻辑是在DAVxxx函数中完成的。比如当前数据包是PROPFIND，那么当前的函数处理逻辑就是DAVpropfind函数。
    0:009> kb
    ChildEBP RetAddr  Args to Child              
    00fff798 67119469 680312c0 00fff800 00000000 httpext!ScStoragePathFromUrl
    00fff7ac 6712544a 0060e7b0 680312c0 00fff800 httpext!CMethUtil::ScStoragePathFromUrl+0x18
    00fffc34 6712561e 0060b508 0060584e 00fffc78 httpext!HrCheckIfHeader+0x124
    00fffc44 6711f659 0060b508 0060584e 00000001 httpext!HrCheckStateHeaders+0x10
    00fffc78 6711f7c5 0060c010 00fffcd4 671404e2 httpext!CPropFindRequest::Execute+0xf0
    00fffc90 671296f2 0060c010 00000004 01017af8 httpext!DAVPropFind+0x47
在内层的函数处理逻辑中，有一处关键的函数处理逻辑HrCheckIfHeader，主要负责DAVPropFind函数对头部的check，这个函数处理逻辑中有一处while循环，我已经把这个循环的关键位置的注释写在伪代码中。
    __int32 __stdcall HrCheckIfHeader(struct CMethUtil *a1, const unsigned __int16 *a2)
     while ( 2 )
      {
      v6 = IFITER::PszNextToken(&v20, 0);
        v7 = v6;
        if ( v6 )／／这里获取下一个url值，第一轮会进入这里，第二轮也会，第三轮就进不去了
        {
          CStackBuffer::CStackBuffer(260);
          v9 = (const wchar_t *)(v7 + 2);
          LOBYTE(v34) = 2;
          v27 = _wcslen(v9);
          if ( !CStackBuffer::resize(2 * v27 + 2) )
            goto LABEL_35;
          v5 = ScCanonicalizePrefixedURL(v9, v32, &v27);
          if ( v5 )
            goto LABEL_43;
          v27 = v29 >> 3;
          v5 = CMethUtil::ScStoragePathFromUrl(a1, v32, Str, &v27);
          if ( v5 == 1 )
          {
            if ( !CStackBuffer::resize(v27) )
            {
    LABEL_35:
              LOBYTE(v34) = 1;
              CStackBuffer::release(&v31);
              v5 = -2147024882;
              goto LABEL_39;
            }
            v5 = CMethUtil::ScStoragePathFromUrl(a1, v32, Str, &v27);
          }
          if ( v5 ::release(&v31);
            goto LABEL_39;
          }
          v10 = _wcslen(Str);
          v27 = v10;
          v11 = &Str[v10 - 1];
          if ( *v11 == 62 )
            *v11 = 0;
          v8 = Str;
          LOBYTE(v34) = 1;
          CStackBuffer::release(&v31);
        }
        else
        {
          if ( !v25 )／／进不去就跳入这里，直接break掉，随后进入locktoken，会调用sc函数
            goto LABEL_38;
          v8 = (const unsigned __int16 *)v24;
        }
        v25 = 0;
        for ( i = (wchar_t *)IFITER::PszNextToken(&v20, 2); ; i = (wchar_t *)IFITER::PszNextToken(&v20, v19) )
        {
          v17 = i;
          if ( !i )
            break;
          v12 = *i;
          if ( *v17 == 60 )
          {
            v13 = HrValidTokenExpression((int)a1, v17, (int)v8, 0);
          }
          else if ( v12 == 91 )
          {
            if ( !FGetLastModTime(0, v8, (struct _FILETIME *)&v23)
              || !FETagFromFiletime((int)&v23, &String, *((_DWORD *)a1 + 4)) )
            {
    LABEL_26:
              if ( v22 )