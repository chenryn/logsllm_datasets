(2) InputUrl.startsWith("https://") == 0
(3) InputUrl.startsWith("file://") == 0
(4) InputUrl.startsWith("content://") == 0
(5) InputUrl.startsWith("mx") == 0
(6) InputUrl.contains("app_name") == 1
(7) flag == 1
(8) InputUrl.contains("%IMEI%") == 1
All constraints can be satisﬁed except (7). By addressing
the event handler dependency problem on (7),
the event
handler execution order is generated : onP ageF inished() →
shouldOverrideU rlLoading().
However, due to the trigger constraint (Section V-A), we
found onPageFinished() was executed after shouldOverrideUrl-
Loading(). Hence, to generate the required execution order, the
web page should be refreshed as follows.
(1) 
Then, the web code that can guide shouldOverrideUrlLoading()
to execute the sensitive API getDeviceId() is shown as follows,
if assuming FTP is supported by users’ phone.
(2) 
D. Performance and Accuracy
The performance and accuracy of EOEDroid may be
impacted by our symbolic execution implementation, where
several heuristics are leveraged to mitigate the path explosion
problem. Admitting that
these heuristics may cause over
approximation and/or inaccuracy to our analysis, they help us
make a good tradeoff between performance and accuracy. In this
section, we presented more evaluation details, and showed that
our current system performance and accuracy were acceptable.
For each app, the average successful analysis time of
EOEDroid is around 4.2 minutes, including 3.4 minutes for
the event handler analysis. Considering our tool is designed to
analyze apps ofﬂine, the overhead is acceptable.
We use false positives (FP) and false negatives (FN) to
measure EOEDroid’s accuracy. We deﬁne a FP as that a non-
vulnerable event handler is ﬂagged as vulnerable, and a FN as
that a vulnerable event handler is identiﬁed as non-vulnerable.
False Positives. We manually analyzed all vulnerable event
handlers by running the exploit code generated by EOEDroid.
Finally, we found that all vulnerabilities were successfully
triggered, which indicated EOEDroid’s FP rate was low.
False Negatives. To conﬁrm false negatives, we randomly
selected 200 apps from the hybrid apps that were ﬂagged as non-
vulnerable by EOEDroid. By carefully manually checking their
event handlers, we found all apps were non-vulnerable except
two apps. Our further study on these two apps showed that the
main reason was that the SMT solver failed to resolve some
path constraints that contained multiple regular expressions and
string split operations. This still represents a low FN rate for
EOEDroid.
13
VII. EOE COUNTERMEASURE DISCUSSION
The key to counter EOE is that apps should only allow
trustable web code to access critical functionalities in event
handlers. To achieve this, apps should ﬁrst fully use HTTPS
in all communications, which will effectively reduce the attack
surface. Second, when a critical functionality is called through
an event handler, the frame level and origin information of web
code should be carefully checked.
The newest version of Android provides a new setting
that only allows web code downloaded over HTTPS to
access shouldOverrideUrlLoading(), and also includes more
information in the event handler’s parameters, such as the frame
level and origin information of web code. Hence, we strongly
recommend developers port their apps to the new version, and
leverage these security information in their development.
VIII. RELATED WORK
Attacks on WebView. Recently, security issues caused by event
handlers have received signiﬁcant attention from researchers.
Luo et al. [26] discussed that event handlers may be used by
malware to hijack and sniff web events. However, compared
with EOE, this type of attacks is more difﬁcult to launch,
because adversaries have to control the native code in user
devices, such as registering their own native event handlers in
WebView. Chen et al. [13] and Mutchler et al. [27] discovered
the event handler feature may cause sensitive data leakage (such
as the authentication URL) in Oauth. Georgiev et al. [19] and
Tuncay et al. [35] discussed the possibilities that adversaries
may leverage the event handler feature to access native code.
In contrast, we systematically study all types of feasible web
event oriented attacks, including the attacks that are carried out
by leveraging both one single web event and stitching multiple
web events together to inﬂuence the program state.
Compared with existing attacks on WebView, EOE is more
feasible and practical. Chin et al. [14] analyzed WebView
vulnerabilities that result in excess authorization and ﬁle-based
cross-zone scripting attacks. Wu et al. [40] discussed ﬁle
leakage problems caused by ﬁle:// and content:// schemes in
webview. However, these two kinds of attacks are limited in
the Android new versions, which provide better protections on
directly accessing local ﬁles.
Bhavani et al. [10] also studied the possibility of cross-site
scripting attacks in WebView. Neugschwandtner et al. [28]
described data leakage scenarios and presented several real-
world case studies of JavaScript injection attacks through
WebView. Jin et al. [24] systematically investigated the
JavaScript code injection consequences on hybrid apps and
showed the pervasiveness of data leakage due to classic web
attack vectors that are possible through WebView. Wei et al.
[38] introduced attack scenarios where attackers could exploit
existing vulnerabilities (such as CVE-2012-6636 [2] and CVE-
2013-4710 [3]) to invoke arbitrary Java functions in WebView.
Rastogi et al. [30] demonstrated the hidden attacks based on
app-web bridges. However, all above attacks require JavaScript
and JavaScript-Bridge to be enabled, whereas EOE does not
have such requirement.
Wang et al. [36] systematically studied the Intent abuse
problem and demonstrated the serious consequences. However,
this attack requires the pre-installation of a WebView-enabled
malware in user devices, which is not required in EOE.
Yang et al. [41] and Hassanshahi et al. [22] studied app-
web bridge based attacks, and proposed detection solutions
to vet hybrid apps. However, they either did not support the
event handler feature, or focus on the attacks launched from a
special URL navigation event (i.e., “intent://...”). In contrast,
EOEDroid is generic.
Defense On WebView. Several defense approaches, such as
NoFrak [19], MobileIFC [33], and Draco [35], are proposed
to extend SOP to local resources, or provide access control
on event handlers in the native layer. However, there are
difﬁculties in applying existing approaches to prevent the EOE
attacks. First, Draco requires the root permission to replace
WebView’s internal native library, and MobileIFC and NoFrak
also require the recompilation of hybrid apps with their own
customized hybrid frameworks. Second, they are implemented
by instrumenting WebView or third-party hybrid frameworks.
Hence, they may have to keep doing extra more work in porting
their systems into newest versions. Third, the defense level
totally depends on how well the security policies are written
by developers. Finally, they performed access control based on
the web frame’s origin information. Hence, it is challenging
for them to limit the access from embedded inline JavaScript
code.
Other defense approaches, such as WIREframe [17] and
HybridGuard [29], provided policy enforcement in WebView to
protect app-web bridges. However, both of them only focused
on JavaScript code and yet ignored HTML code. Hence, they
can still be evaded by EOE, since EOE can be launched purely
in HTML code.
Symbolic Execution. In past years, symbolic execution has
made big progress. Several static approaches (such as Intel-
lidroid [39] and TriggerScope [18]) were proposed to vet
Android apps using symbolic execution. However, these static
approaches may have both higher false positives and negatives
in the context faced in this paper. First, static analysis has to
address points-to and alias problems. Second, due to the lack of
real data, it is challenging to resolve Java Reﬂection and Intent.
Finally, it is difﬁcult to address the array indexing type implicit
ﬂows. In real world, this type of implicit ﬂows is frequently
used in popular apps and ad libs, such as Google Ads.
Many dynamic approaches were also implemented based
on symbolic execution. For example, DART [20] and CUTE
[31] applied concolic execution to automatically test software.
EXE [12] and KLEE [11] used symbolic execution to ﬁnd bugs.
IntScope [37] employed symbolic execution to detect integer
overﬂow problems. SAGE [21] was designed for Windows to
apply symbolic execution to vet the operating system. S2E
[15] proposed the selective symbolic execution to improve the
performance. Driller [34] used selective symbolic execution to
guide fuzzing, and the result showed the combination was very
effective. Existing dynamic approaches may have low false
positives. However, it is challenging for them to generate the
event sequences required for triggering a found vulnerability.
Several symbolic execution based approaches were also
designed to handle implicit ﬂows. For instance, DTA++ [25]
used symbolic execution to solve control ﬂow problem (i.e.,
implicit ﬂows), while Spandex [16] implemented symbolic
execution in Android to vet apps about password usage.
However, these two systems fall short of handling Android
speciﬁcations (such as Android Intent) and array indexing type
14
implicit ﬂows.
IX. SYSTEM LIMITATIONS AND FUTURE WORK
EOEDroid is not perfect. First, currently we simply use Mon-
key to trigger WebView. Exploring all possible UI components
is a difﬁcult issue, though orthogonal to this research. Second,
in EOEDroid, we do not solve all implicit ﬂow problems,
instead only focus on array-indexing type operations, which are
frequently used in event handlers. Finally, we do not handle all
native code in Android, instead only model important native
code such as system.arraycopy(). In future work, we plan to
explore solutions in these directions to improve EOEDroid.
X. CONCLUSION
In this paper, we thoroughly studied all web events, native
event handlers and their triggering constraints. Based on
our ﬁndings, we present EOEDroid, a novel system that
can automatically detect and verify EOE vulnerabilities by
generating exploit code. We evaluated EOEDroid using a large
number of apps and found several critical vulnerabilities.
ACKNOWLEDGMENT
We thank all anonymous reviewers and our shepherd, Adam
Doupé, for their insightful comments and suggestions. This
material is based upon work supported in part by the the
National Science Foundation (NSF) under Grant no. 1314823
and 1700544. Any opinions, ﬁndings, and conclusions or
recommendations expressed in this material are those of the
authors and do not necessarily reﬂect the views of NSF.
REFERENCES
[1] Calling fork() from jni code. https://groups.google.com/forum/#\protect\
kern-.1667em\relaxtopic/android-platform/80jr-_A-9bU.
[2] Cve-2012-6636. https://cxsecurity.com/cveshow/CVE-2012-6636.
[3] Cve-2013-4710. https://cxsecurity.com/cveshow/CVE-2013-4710.
[4] Dalvik. https://en.wikipedia.org/wiki/Dalvik_(software).
[5] Dalvik opcode. https://source.android.com/devices/tech/dalvik/dalvik-
bytecode.html.
[6] An interactive tls-capable intercepting http proxy for penetration testers
and software developers. https://github.com/mitmproxy/mitmproxy.
[7] Mcafee mobile threat report. https://www.mcafee.com/us/resources/
reports/rp-mobile-threat-report-2016.pdf.
[8] Same origin policy. https://en.wikipedia.org/wiki/Same-origin_policy.
[9] Ui/application exerciser monkey. https://developer.android.com/studio/
test/monkey.html.
[10] A. B. Bhavani. Cross-site Scripting Attacks on Android WebView. IJCSN
International Journal of Computer Science and Network, 2(2):1–5, 2013.
[11] C. Cadar, D. Dunbar, and D. Engler. Klee: Unassisted and automatic
generation of high-coverage tests for complex systems programs. In
OSDI’08.
[12] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler.
Exe: Automatically generating inputs of death. In CCS’06.
[13] E. Y. Chen, Y. Pei, S. Chen, Y. Tian, R. Kotcher, and P. Tague. Oauth
demystiﬁed for mobile application developers. CCS’14, 2014.
[14] E. Chin and D. Wagner. Bifocals: Analyzing webview vulnerabilities in
android applications. In WISA’13. Jeju Island, Korea.
[15] V. Chipounov, V. Kuznetsov, and G. Candea. S2e: A platform for in-vivo
multi-path analysis of software systems. In ASPLOS’11.
[16] L. P. Cox, P. Gilbert, G. Lawler, V. Pistol, A. Razeen, B. Wu, and
S. Cheemalapati. Spandex: Secure password tracking for android. In
USENIX Security’14.
15
[17] D. Davidson, Y. Chen, F. George, L. Lu, and S. Jha. Secure integration
of web content and applications on commodity mobile operating systems.
ASIA CCS’17, New York, NY, USA.
[18] Y. Fratantonio, A. Bianchi, W. Robertson, E. Kirda, C. Kruegel, and
G. Vigna. TriggerScope: Towards Detecting Logic Bombs in Android
Apps. In IEEE S&P’16, San Jose, CA.
[19] M. Georgiev, S. Jana, and V. Shmatikov. Breaking and ﬁxing origin-
based access control in hybrid web/mobile application frameworks. In
NDSS’14, San Diego, USA.
[20] P. Godefroid, N. Klarlund, and K. Sen. Dart: Directed automated random
testing. In PLDI’05.
[21] P. Godefroid, M. Y. Levin, and D. Molnar. Sage: Whitebox fuzzing for
security testing. Queue, 10(1):20:20–20:27, Jan. 2012.
[22] B. Hassanshahi, Y. Jia, R. H. C. Yap, P. Saxena, and Z. Liang. Web-to-
application injection attacks on android: Characterization and detection.
In ESORICS, volume 9327, pages 577–598. Springer, 2015.
InfoSecurity.
https://www.infosecurity-magazine.com/news/public-wiﬁ-hotspots-
ripe-for-mitm-attacks/.
Public wiﬁ hotspots
[23]
ripe
for mitm attacks.
[24] X. Jin, X. Hu, K. Ying, W. Du, H. Yin, and G. N. Peri. Code injection
attacks on html5-based mobile apps: Characterization, detection and
mitigation. In CCS’14.
[25] M. G. Kang, S. McCamant, P. Poosankam, and D. Song. DTA++:
In
dynamic taint analysis with targeted control-ﬂow propagation.
NDSS’11. San Diego, California, USA.
[26] T. Luo, H. Hao, W. Du, Y. Wang, and H. Yin. Attacks on webview in
the android system. In ACSAC’11.
[27] P. Mutchler, A. DoupÃ, J. Mitchell, C. Kruegel, G. Vigna, A. Doup,
J. Mitchell, C. Kruegel, and G. Vigna. A Large-Scale Study of Mobile
Web App Security. MoST’15.
[28] M. Neugschwandtner, M. Lindorfer, and C. Platzer. A view to a kill:
Webview exploitation. In LEET’13.
[29] P. H. Phung, A. Mohanty, R. Rachapalli, and M. Sridhar. Hybridguard:
A principal-based permission and ﬁne-grained policy enforcement
framework for web-based mobile applications. MoST’17.
[30] V. Rastogi, R. Shao, Y. Chen, X. Pan, S. Zou, and R. Riley. Are
these Ads Safe: Detecting Hidden Attacks through the Mobile App-Web
Interfaces. NDSS’16.
[31] K. Sen, D. Marinov, and G. Agha. Cute: A concolic unit testing engine
for c. In ACM SIGSOFT’05, Lisbon, Portugal.
[32] H. Shacham. The geometry of innocent ﬂesh on the bone: Return-into-
libc without function calls (on the x86). In CCS’07.
[33] K. Singh. Practical context-aware permission control for hybrid mobile
applications. In RAID’13.
[34] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Kruegel, and G. Vigna. Driller: Augmenting
fuzzing through selective symbolic execution. In NDSS’16.
[35] G. S. Tuncay, S. Demetriou, and C. A. Gunter. Draco: A system for
uniform and ﬁne-grained access control for web code on android. In
CCS’16.
[36] R. Wang, L. Xing, X. Wang, and S. Chen. Unauthorized origin crossing
on mobile platforms: Threats and mitigation. In CCS’13.
[37] T. Wang, T. Wei, Z. Lin, and W. Zou. Intscope: Automatically detecting
integer overﬂow vulnerability in x86 binary using symbolic execution.
In NDSS’09, San Diego, CA.
[38] T. Wei, Y. Zhang, H. Xue, M. Zheng, C. Ren, and D. Song. Sidewinder
targeted attack against android in the golden age of ad libraries. In
Black Hat’14.
[39] M. Y. Wong and D. Lie. Intellidroid: A targeted input generator for the
dynamic analysis of android malware. In NDSS’16.
[40] D. Wu and R. K. C. Chang. Indirect File Leaks in Mobile Applications.
In MoST’15.
[41] G. Yang, A. Mendoza, J. Zhang, and G. Gu. Precisely and scalably
vetting javascript bridge in android hybrid apps. In RAID’17.
[42] Y. Zheng, X. Zhang, and V. Ganesh. Z3-str: a z3-based string solver
for web application analysis. In ESEC/SIGSOFT FSE’13.