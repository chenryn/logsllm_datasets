McIlroy的程序阐明了UNIX工具程序的处理方式是强大的：将复杂的间题切分成数个
较简单的部分，简单到你已经知道这个部分该怎么处理，为解决单词出现频率问题，
Mcllroy将纯文本文件转换为单词列表，一行一个字（由tr来完成此工作）、将单词对
应到单一的字母大小写（一样还是用tr）、单词列表的排序（用sort）、从单词列表中
去除重复部分，简化为仅提供唯一的单词（用uniq）且加上计数、再将单词列表以计数
的数字由大至小排序，最后，显示单词列表的前儿项（这里是使用sed，不过head也
可以)。
通5：
{Programming Pearls; A Literate Program): A wEB program for common words,
Comm.ACM 29(6),471-483, June(1986):以及 《Programming Pearls: Literate
Programming: Printing Common Words) , 30(7), 594-599, July(1987), Knuth 的论文也
再版子《Literate Programming》 $中。t Stanford University Center for the Study of
Language and Information ±&: 1992冬 , 1SBN 0-937073-80-6 (浆发) 与 0-937073
81-4（性苯底）。
www.TopSage.com
---
## Page 129
管道的神奇魔力
LII
最后形成的程序应该值得给它个名字wf（wordfrequency，单词出现频率之意），然后
附上注释标题，打包成Shell脚本。我们也扩充了Mcllroy原本的sed命令，让输出列
表长度参数可选，并现代化sort选项。完整程序可见例5-5。
例5-5：单词出现频率过滤器
从标准输入该取文本选，再输出出现频率最高的能n（取认值：25）个单词的列表
#1/bin/sh
附上出现频率的计数，按照这个计数由大而小排列，
输出到标准输出
语法：
[u] 
tr -c8 A-Za-z\• *\n′ 1
将非字母字符置换成换行符号
tr A-Z a=z 1
所有大写字母转为小写
sort 1
去除重复，并显示其计数
由小面大排序单词
uniq -c 1
sort -k1,1nr -k2 1
计数由大面小排序后，再按照单词由小而大排序
sed $(1:-25)q
显示前n行（联认为25）：见第3章
PortabilityGuide规格则仅有八进制的转义序列，且原始的tr更是完全不支持，会强制
将换行符号逐字写出，这也是Mcliroy原始程序里被批判的一点。还好，我们测试过的
所有系统，其tr命令现在都支持POSIX转义序列。
Shell管道井不是使用UNIX工具解决此问题的唯一方式：Bentley提出的awk程序实作
只有6行，在他早期的专栏里已出现过了（注6），内容上大致与Mcllroy的管道之前4
个步骤差不多，
Knuth与Hanson讨论了他们的程序在计算上的复杂度，且Hanson使用运行时探测
（runtimeprofiling）的方式研究该程序的数种变化，以找出最快的一种。
Mcllroy的复杂度是容易识别的。sort之外的所有步骤，执行时间都与其输入数据的大
小呈线性关系，输人量多半在uniq步骤之后会明显减少，因此，会牵制速度的其实是
第一步：sort。一个好的排序算法主要是看它的比较功能，以UNIX的sort来看，排
序n个项目的时间是与nlogn成正比。这个底为2的对数值会很小：假设=为一百万，
则它就是大约20.因此，在实际上，我们预期wf会比只是使用cat复制它的输入流还
要慢些。
注 6:
(Programming Pearls: Associative Arrays), Comm. ACM 28(6), 570-576, June, (1985),
这是一属介绍美联式数组（associative arrays）的好文章（表格是遥过字将事来索引，而
不是整数），这是文多数脚本语言的常见功能。
www.TopSage.com
---
## Page 130
811
第5章
这里用莎士比亚的作品来套用这个脚本试试，我们用最著名的《哈姆雷特》（运7），使）111
用pr重新格式化输出的结果，以每行4列显示：
$ wf 12 tr，但是在其他地方，我们可能举例说明你输人的内容，
便会用tr这样的标记，还有一种是提及手册页参考时，标记形
式为 tr(1)。
例5-6里的taglist程序就是这类问题的解决方案。该程序找出写在同一行里开始/结
束的一对标签（tag），然后再输出一个排序列表，该列表将标签的使用与输人文件相关
联。此外，对于多次的方式标记相同单词的地方，给出一个箭头标志。下列片段即为本
章内容应用该程序后的输出：
S tagliat ch05.xm1
2 cut
pueauoo
ch05 .xn1
1 cut
ch05.xn1 与，分别转换成较
简单的与标签。
3.下一个步骤使用tr将空白与成对的定界符转换为换行符（newline）：
.. 1 tr *() {)[1·*\n\n\n\n\n\n\n* |...
4.至此，输人数据包括一行一个单词（word）（或是空行）。这里所指的单词，不是真
正的文本就是SGML/XML标签。所以下一步骤我们使用egrep，选定由标签括起
来的单词：
... I egrep '>[^<>]+tr，即切分为4栏，依次是：一个空字
段、literal，tr，最后为/literal。文件名通过命令行传给awk，其中-v选
项把awk变量FILE设置为此文件名。该变量之后会应用到print语句上，以输
出单词、标签与文件名：
.. 1 awk -P[<>]-v pILg=$1\
‘( printf(*$31s\t-15s\ts\n*, $3, $2, ILE) )' 1 ..*
6.sort步骤是以单词顺序排列每一行：
.*. E 8ort l .*.
7.uniq命令提供初始的计数字段。输出为记录列表，其中字段依次为计数、单词、标
签、文件：
... I uniq -c 1 ...
8.第二个sort是将输出结果以单词及标签的顺序排列（第2、3字段）：
.-. 1 sort -k2,2 -k3,3 1 ..
9.
最后参骤是使用一个小小的awk程序，过滤掉连续的行，加上结尾的箭头符号，当
出现与上一行相同单词时使用。然后，此箭头符号可清楚地指出哪个字使用了不同
的标记，也就是作者、编辑或出版社相关人员应特别检查的地方：
www.TopSage.com
---
## Page 133
管道的神奇魔力
print（$2 = Last)7（$0*word这样的标记，再输出到标准输出，
读取命令行上给定的HTNL/SGML/XML文件，
该标准输出将以制表字符（tab）分隔字段，依次为
计数单词标签文件名
按阻单词与标签由小至大排序。
语法：
taglist xml-fi1e
cat *$1* 1
sed -e*s#systemitem *role=*ur1*#URL#g*-es#/systemitem/URL+*1
tr·(）（）[]\nn\nnn）n\n1
egrep‘>[^＜>]+].-x
‘（printf(*#-31s\t-15g\ts\n*,$3,$2,FILE) }′1
sort 1
uniq -e 1
sort -k2,2 -k3,3 1
axk '{
print($2 = Last)?($0 ·<**-*): $0
Last = $2
}*
在6.5节里，我们将告诉你如何将标签列表的运算应用到多文件的情况上。
5.6
小结
本章说明的是解决许多文字处理问题的一些方法，这些问题里没有一个是能够在大部分
程序语言中简单地解决的，本章主要话题如下：
数据标记相当有价值，但又不能太复杂。具有唯一性的单一字符，例如制表字符
（Tab）、冒号或是逗点通常就够用了。
将单纯的UNIX工具与管道结合使用，加上在适合的文字处理语言中的简短程
序一例如awk，可灵活运用数据标记来传递多个数据片段，使其通过一系列的
处理步骤，产生有用的报告。
www.TopSage.com
---
## Page 134
122
第5章
通过保持数据标记的简单，我们的工具所产生的输出，可以马上变成新工具的输
入，就像单词频率次数过滤器（wf那样的输出分析）可应用到莎士比亚的作品上
一样。
将一些小型标记保留在输出结果里，之后还能再进一步处理这样的数据，就像我们
把简单的ASCII办公室名录转换成网页形式那样，绝不要以为任何一种电子数据的
形式就会是最后的结果：现在有越来越多能将四页显示成一面的程序语言，例如
PCL、PDF以及PostScript，它们可以保留原始标记，再进行页面的格式化。字处
理程序所产生的文件现在也缺乏有条理的标记方式，不过这种情况即将转变！就在
写这本书的同时，已有优秀的字处理程序厂商提出：“正考虑将XML表达式作为文