### 1. 实验过程

为了验证恢复服务在没有注入错误的情况下是否采取任何行动，我们在每个恢复点（RP）上重复此操作50次。由于错误检测会触发恢复服务，并且POD-Recovery不考虑触发消息提供的任何原因，我们不会进一步调查更复杂的假阳性情况。此外，如前所述，如果瞬时错误在恢复开始前消失，我们将其视为从恢复角度来看的假阳性。

### 2. 实验结果

表52展示了恢复服务处理错误检测服务中假阳性的能力。我们可以看到所有假阳性都被成功检测到：在我们的400次实验运行中，没有任何恢复行动被采取。

**表52. 错误检测的假阳性处理**

| 恢复点 | 假阳性数量 | 未采取恢复行动的数量 |
| --- | --- | --- |
| RP 1 | 50 | 50 |
| RP 2 | 50 | 50 |
| RP 3 | 50 | 50 |
| RP 4 | 50 | 50 |
| RP 5 | 50 | 50 |
| RP 6 | 50 | 50 |
| RP 7 | 50 | 50 |
| RP 8 | 50 | 50 |

### 3. 满足恢复要求R6

由于我们的恢复方法设计了动态计划生成，因此来自错误检测的假阳性不会导致不必要的恢复行动。

---

### G. 恢复自身的恢复

#### 1. 实验过程

为了测试POD-Recovery在执行恢复计划过程中出现错误时的行为，我进行了迁移操作，在每个确定的恢复点注入故障以触发POD-Recovery，等待选定的恢复行动执行，然后手动向恢复行动中注入额外的故障以触发“恢复自身的恢复”模块。对于迁移操作中的每个恢复点，我进行了30次这种“恢复自身的恢复”测试。

#### 2. 实验结果

表53显示了迁移操作中“恢复自身的恢复”的恢复时间。相对标准偏差最多为2.0%。

**表53. “恢复自身的恢复”的恢复时间**

| 恢复点 | 进程步骤 | 错误 | 选择的恢复行动 (Pareto Set) | 恢复时间 (Pareto Set) | 选择的恢复行动 (用户约束) | 恢复时间 (用户约束) |
| --- | --- | --- | --- | --- | --- | --- |
| 恢复点 1 | 停止旧可用区中的旧Web实例 | 旧Web实例未停止 | 再次停止旧Web实例 (直接重做) | 36.45 s | 停止旧Web实例 (修复) | 39.01 s |
| 恢复点 2 | 从旧Web实例创建AMI | AMI未创建 | 从旧Web实例创建AMI (直接重做) | - | - | - |
| 恢复点 3 | 在新可用区启动新Web实例，使用AMI；重新分配IP给新Web实例 | 新Web实例未启动 | 从旧Web实例创建AMI (直接重做) | 124.55 s | 在新可用区启动新Web实例；重新分配IP给新Web实例 (直接重做) | 63.88 s |
| 恢复点 4 | 终止旧Web实例 | 旧Web实例未终止 | 终止旧Web实例 (直接重做) | 32.33 s | 删除失败的AMI；从旧Web实例创建新的AMI (修复)；在新可用区启动新Web实例；重新分配IP给新Web实例 (直接重做) | 123.66 s |
| 恢复点 5 | 停止旧可用区中的旧数据库实例 | 旧数据库实例未停止 | 再次停止旧数据库实例 (直接重做) | 40.77 s | 停止旧数据库实例 (修复) | 38.55 s |
| 恢复点 6 | 从旧数据库实例创建AMI | AMI未创建 | 从旧数据库实例创建AMI (直接重做) | - | - | - |
| 恢复点 7 | 在新可用区启动新数据库实例，使用AMI；重新分配IP给新数据库实例 | 新数据库实例未启动 | 从旧数据库实例创建AMI (直接重做) | - | - | - |
| 恢复点 8 | 终止旧数据库实例 | 旧数据库实例未终止 | 创建新的AMI (直接重做)；在新可用区启动新数据库实例；重新分配IP给新数据库实例 (直接重做) | 177.44 s | 删除失败的AMI；从旧数据库实例创建新的AMI (修复)；在新可用区启动新数据库实例；重新分配IP给新数据库实例 (直接重做) | 81.66 s |

通过这些实验结果，我们可以确认POD-Recovery在处理假阳性和自身恢复方面表现良好。