该架构能否帮助我们创建出正确、健壮的软件？
可扩展性
应对变化是否很容易？
复用性
该解决方案是否具有通用性？或者甚至可以将其作为一个组件直接
插入到新的应用程序中，而无需做定制并发？
对象技术的成功在于它能够使最终并发出来的程序在可靠性、可扩
展性、复用性等方面获得很大改进，当然前提是你正确地应用了该
方法，而不仅仅是使用了一种面向对象编程语言。函数式的编程方
法比面向对象编程方法出现得更早些，最早可以追溯到约50年前就
已经很流行的Lisp语言。近几年来，它有卷土重来之势，出现了一
些诸如Scheme（基于Lisp）、Haskell、OCaml和F#之类的新语言，
高级语言机制。现在看起来，函数式编程甚至正在变成改进面向对
象编程的新技术之一。在本章中，我们将从之前所概括的软件架构
评价标准入手，对两种方法进行比较。我们将从反方向来论证它们
之间的关系：面向对象的架构融合了函数式编程的思想，特别是吸
纳了诸如Eiffel中的代理（agents，有的语言称之为闭包或委托）之
类的新技术之后，在保留了其优点的同时克服了其缺点。
要证明这些发现是否合格，需要同时注意这项研究的限制条件，以
及为缓和这些限制条件而提出的一些论据。这些限制包括：
较少的数据点
以下的分析将从两个函数式设计的实例并始。这可以让本章内容更
具通用性。
细节不足
1224
---
## Page 1226
该示例的来源是一篇文章（PeytonJones等2000）和一个PPT幻灯片
（Eber等2001），我们后面再次提到它们时，将称之为"该文章"和
“该幻灯片”（对本小节有帮助的还包括函数式编程的一篇经典论文
[Hughes1989]）。如果和那些更加详细的文档相比，使用该幻灯片
可能会忽略掉一些细节。
具体关注
我们只考虑模块化。函数式编程也依赖于其他标准，如声明方式的
优雅性。
实验者偏见
本章的作者长期以来一直是面向对象技术的贡献者和支持者。
以下的论据，将减少一些可能的批评：
函数式编程的示例源于行业的实践；具体来说，是一家通过函数式
编程技术实现的应用程序来对外提供商业服务的公司。主要的示例
是一个金融工具，用来解决金融行业所面临的复杂问题。根据该文
章作者（一位该领域的专家）的说法，这个工具并不能很好地解决
当前的问题。这暗示它体现了当前的技术发展水平。（本章中的第
一个示例是一个关于布丁的理论性项目，是一个用于教学的试验
品。）
该文章的作者之一，S.Peyton-Jones是一位底层技术研究领域的知名
作者，它是Haskell语言的主设计者，是函数式编程领域的著名人
物，因此该文章具有很高的可信度。在13.3节中用了一篇文章作为
补充的例子，这篇文章极有影响，是函数式编程社群中另一位一流
人士J.Hughes所写的。
虽然有些地方值得探讨，但该文章中描述的解决方案提供了一些清
晰、有效的解决方案。
在这些示例中，我们将不考虑可改变状态的概念，而这正是面向对
象编程语言必须支持的特性之一。
在此还将关注诸如代理之类的机制，它是实现完整面向对象解决方
案的基本成分，它显然是从函数式编程的观点中获得启发的。因此
可以得出一个结论，那就是我们无法忽略函数式编程学派的贡献，
1225
---
## Page 1227
只不过从论据中能够看出面向对象风格更适用于可靠、可扩展、可
复用软件架构的定义，而这样的架构通常是面向对象和函数式技术
的融合体。
关于下面的讨论还有一些要注意的方面：
在此使用的是Eiei所提供的对象技术。我们并不打算分析除了多
重继承（Java和C#就没有提供）、泛型（在这些语言的早期版本中
都没有提供）、契药（除了JIML和Spec#之外未提供）以及代理风格
设施（Java未提供），或添加如重载、静态函数之后还有什么，这
些东西都会影响面向对象的简单性。
讨论将围绕架构和设计进行。我们不管它叫什么名字，这些任务都
与函数式编程（与对象技术类似）是相关的，因为“编程"并不局限
于实现。Eel通过无缝开发的概念，明确地引入了从规格说明到设
计和实现的连续过程。对于其中那些面向实现的属性，在此将不会
详细地涉及，虽然它们在实践中也是十分重要的。
与实现有关的还有与表示式和表示法相关的问题。之所以考虑它
们，是因为它们对架构和设计的关键标准有一定影响。不过，这些
讨论在很大程度上只讨论语义的本质，而不讨论语义的形式。
还有两个更基本的提示。首先是术语问题，“契约"在此默认是指金
融契约，它是与文档中的应用程序域相关的，别和软件中的“契约”
（Meyer1997）混为一谈，软件中的契约是指规约的元素（前置条
件、后置条件、不变式）。为了避免混淆，这里将分别采用术语金
融契约和软件契约来描述。
其次，我需要表示一下款意：当在后半部分讨论到面向对象问题
时，我将从作者先前的文章和幻灯片中引用或复制更多内容，而没
有提出更多自己的判断和观点。这是因为面向对象技术已经有了广
泛的应用，已经不缺乏command-queryseparation（命令-查询分离原
则，参见第13.3.5节）之类的精妙的关键原则（我们的观点）：在
此只需做一些简单的说明即可。要想了解更完整的内容，可以阅读
在此提及的参考文献。
13.2函数式示例
该文章和该幻灯片的核心目标就是为描述、处理金融契约提供一个
便利的机制，特别是针对那些非常复杂的现代金融手段，正如幻灯
1226
---
## Page 1228
片中所提到的一个例子那样（数值会在不同时间、不同的主要货币
之间呈现不同的关系）：
针对在12月27日支付2.00美元的承诺（期权的价格），持有者有权
在12月4日选择：
在12月29日接受1.95美元，或
有权在12月11日选择：
在12月28日接受2.20欧元，或
在12月18日选择：
在12月30日接受1.20英榜，或
·马上多支付1.00欧元并在12月29日接受3.20欧元”
（在本小节中，所有加引号的内容都是从该幻灯片或该文章中节选
的。没有加引号的内容则是我们对其的解释和说明。）
为了解释这个问题，该幻灯片首先介绍了一个教学用的虚拟示例：
它用“布丁”替代了“金融契约”。要想精确地描述布丁，可能需要涉
及“计算所需糖量”、“估计布丁所需的制作时间”，并获取“制作的方
法”。下面就是一种解决该问题的“坏方法”：
cake,Christmas pudding）[1]
对于每种布丁，写下它的糖量、制作时间、制作方法等信息。”
虽然在该幻灯片中没有说明这种方法为什么不好，但我们能够很容
易地猜出其理由：这是一个由特定描述组成的集合，不具有可复用
性，因为它没有充分发挥“不同布丁可能共用相同原料"的特点；它
也不具有可扩展性，因为如果要对某种布丁的某个部分进行任何修
改，都需要对依赖这一部分的所有布丁进行修改。
这里的“布丁”是对我们真正感兴趣的“金融契约”的一个隐喻，不过
由于它十分易懂，也不需要你事先掌握特定问题域的知识，因此我
1227
---
## Page 1229
们还是先继续讨论完这个例子。对于这个问题，以下就是可行的
“好方法"之一：
定义一个小型的*布丁合成方法"集。
·用这些合成方法定义所有布丁。
·糖量的计算也从这些合成方法中得出。”
图13-1所示的树形结构（节选于该幻灯片）展示了这些合成逻辑的
结构。
Ontopof
Whipped
Mixture
Chopped
Oplional
Take
1pint
Cream
Take
Take
Apples
Oranges
图13-1：描述布丁食谱的成分与合成方式
提示：我能够理解有些读者对于该示例中的甜点没有胃口，特别是
因为它还出自于巴黎的作者。比较合理的解释是，该幻灯片是针对
外国观众的，作者假定他们不熟悉度量系统21、不熟悉烹调习惯。
而幻灯片中的讨论也是基于这样的假设：餐后甜点本身的味道不够
好，并不会导致其语言和架构范型也随之不好。
在图13-1中，非叶子节点表示应用于其子树的合成方式。例如，
“Take"就是一种合成方式，它需要两个参数，一个是布丁原料（左
边的"Cream"，右边的"Oranges"），另一个是重量（"1pint"和
“6”）。最终这个树形节点在该应用程序的结果将成为一个布丁原
料，或者由指定重量的指定原料制作而成的布丁。
1228
---
## Page 1230
它也可以通过一个微型的、“针对布丁描述”的“领域特定语言
（DSL）来描述，得出如下所示的结构化文本（黑体字部分是为操
作员添加的）：
"salad=on_top_oftoppingmain_part"-为了保持一致，将其改成
"OnTopOf"
"topping=whipped (take pint cream)
main_part=mixture apple_part orange_part
apple_part=chopped (take 3 apple)
orange_part=optional (take 6 oranges) "
这里使用了一个匿名的、但很典型的函数式编程表示法的变体（我
们可以称之为“香草”），在函数式的应用程序中通常写为函数变量
（例如，plusab在应用程序中表示将a和b相加），而圆括号只是用
来完成分组而已。
有了这一基础，我们就可以定义合成方式（如案例分析中“糖量”）
所需的操作了（它的定义与递归定义的数学函数一样，都将遵循相
同的递归结构）：
"s (on_top_of p1 p2) =S(p1) +S (p2)
S (whipped p)=S (p)
S (take q i) =q*S (i)
etc."
对于"etc."是什么操作，在此尚未明确，也可能是S处理的可选合成
方式；我们必须有一些方法来确定某种特定调合物中是否拥有可选
的部分。我们先将这个问题放在一边，这种方法所能够带来的好处
主要是：
·只有当我们需要添加新的合成方式或者新的成分时，才需要增强
S。
1229
---
## Page 1231