transitive application of the dependence function DV to
F B(i)∪BB(i) for a read operation i ∈ ρ. We then cluster all
read operations within the execution trace and group together
those reads that are bound to common abstract variables.
Our clustering uses a simple similarity metric that treats two
reads i1, i2 ∈ ρ as similar if Vars(i1) ∩ Vars(i2) (cid:54)= ∅, and
dissimilar otherwise. The clustering algorithm will output n
clusters C1, . . . , Cn where each cluster Ci is a set of read
operations.
The malware bytecode should be fetched for execution
exclusively by memory read operations contained within
one of the n clusters. Abstract variable binding over-
approximates actual bindings due to the backward algorithm,
which results in two reads clustered together if they may use
the same abstract variable to specify the accessed address.
The transitive closure of the dependencies among abstract
variables ensures two reads will be similar even if the reads
use two distinct abstract variables. Therefore, the bytecode
program will be completely contained within a cluster. Each
cluster is then a candidate collection of instruction fetches
into bytecode, and the common abstract variables at each
cluster are candidate VPCs.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
3.3. Identifying Emulation Behavior
We analyze each candidate cluster and VPC to ﬁnd a
cluster containing memory reads characteristic of emula-
tion. Decode-dispatch emulators have fundamental execution
properties: a main loop with a bytecode fetch through the
VPC, decoding of the opcode within the bytecode, dispatch
to an opcode handler, and a change to the VPC value. For
each candidate cluster, we hypothesize that the memory
region read by the cluster corresponds to bytecode and then
test that hypothesis. We determine whether there exists an
iterative pattern of bytecode fetches through the associated
candidate VPC and updates to that possible VPC. To detect
loops, we ﬁrst create a partial dynamic control-ﬂow graph
(CFG) of the program in execution. We use the control-ﬂow
semantics of the executed instructions to create new basic
blocks and split already created blocks. We use function call
semantics to create separate CFGs for each function. Then,
we use the standard loop detection methods used for static
intra-procedural CFGs [1].
To ﬁnd decoding, dispatching, and execution of bytecode
after the memory read fetches it from the bytecode buffer,
we analyze how read values are used by other instructions
within the execution trace. We use multi-level dynamic
tainting [38] to track the propagation of the data read from
instructions in a candidate cluster through the emulator’s
code. In contrast to traditional taint analysis with 0/1 taint
labels, we apply multiple labels to memory contents and reg-
isters at the byte level. Different labels track individual data
read from the cluster and maintain state information related
to which phase—fetch, decode, dispatch, or execute—that
the emulator may be in for a particular read.
We use dynamic taint analysis as follows. For each
candidate cluster, we taint the data bytes in the hypothe-
sized bytecode buffer region of the cluster with the label
(cid:104)opcode, id(cid:105) where an id is a unique per-byte identiﬁer.
When a read operation in the execution trace accesses a
tainted byte, we mark the instruction as an opcode fetch
for the particular id in the label. If the instruction sequence
number is i, then we also taint the forward bound variables
F B(i) and the register holding the address accessed by the
read operation with the label (cid:104)vpc, id(cid:105), indicating that it is a
VPC for the emulator. Execution continues until our analyzer
detects opcode dispatch behavior.
We identify dispatch behavior by looking for control-ﬂow
transfer instructions executed by the emulator that are inﬂu-
enced by data read from the cluster’s hypothesized bytecode
buffer: these are transfers into handlers for speciﬁc bytecode
opcodes. In the simplest scenario, an x86 instruction like
jmp or call can target an address read from a tainted
register or from a dispatch table accessed through a tainted
register. More complex code patterns may include arbitrary
data and control ﬂows between a control-ﬂow target lookup
and the actual dispatch. Taint propagation ensures that taint
labels transfer from address to values read through that
address, to copies of those values, and to the control-ﬂow
transfer. Once the analyzer detects a dispatch-like behavior,
it marks the dispatch instruction with the id of the taint label
and the analysis now tracks the target of the control-transfer
as a probable execute routine.
Each subsequent read in the candidate cluster may be
accessing a new bytecode, operands for the current bytecode,
or an unrelated memory value included in the cluster due
to the imprecision of backward variable binding. We ﬁrst
identify new bytecode accesses by analyzing the dynamic
CFG to see if execution looped since the previous bytecode
fetch. If a loop is not detected, we then check to see if the
read is accessing a probable operand in the bytecode buffer.
If the register used to perform the read operation is tainted
as (cid:104)vpc, id(cid:105) with the id of the current iteration, and the
computation of the accessed address added a small constant
to the candidate VPC value, then the memory access is likely
for an operand. We consider all other accesses to be spurious.
We consider every candidate cluster containing iterative
memory reads in a loop that includes dispatch behavior.
There must be at least two loop executions in the dynamic
trace for our analysis to identify the loop.
3.4. Extracting Syntax and Semantics
Once the analyzer identiﬁes the emulation behavior, it
reverse engineers each iteration of the emulator loop to
extract the syntax and semantics of the bytecode instruction
executed on that iteration. The syntax of bytecode details
how to parse the instruction: its length and the placement of
its opcode and operands. Bytecode semantics describe the
bytecode’s effect upon execution of the malware instance.
We are particularly interested in identifying bytecode in-
structions exhibiting control-ﬂow transfer semantics, as these
are the locations where malware analysis techniques such as
multipath exploration [21] should be applied.
We identify the syntax of bytecode instructions by observ-
ing the memory reads made from the data regions containing
bytecode, as determined in Section 3.3. To identify the
opcode part of the instruction, we apply our taint analysis to
determine which portion was used by the emulator’s dispatch
stage for selection of an execution handler. We can identify
opcodes at the granularity of one or more bytes within a
bytecode instruction, as our taint analysis works at byte-
level. An emulator may dispatch several different opcodes
to the same execution routine because their semantics may
be similar. As a result, we count the number of instructions
in the bytecode instruction set as the number of unique
execution routines identiﬁed in our analysis.
The execution routine invoked by the emulator for the
bytecode’s opcode encodes the semantics of the opcode. We
ﬁnd control ﬂow transfers by analyzing the changes made
by an execution routine upon the VPC of the emulator.
101
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
Figure 3. Analysis process overview
Unconditional transfers, including fall-through instructions,
will always set the VPC to the same value on every execution
of that instruction. Commonly, fall-throughs simply advance
the VPC to the next
instruction in sequential order, a
regular update pattern that can be readily identiﬁed. Con-
ditional control-ﬂow transfers and transfers to dynamically-
computed targets will update the VPC in different ways upon
repeated execution of the bytecode instruction.
By determining how to parse the bytecode buffer and
by locating control-ﬂow transfer opcodes, we are then able
to construct a control-ﬂow graph (CFG) for the bytecode.
The locations of the control-ﬂow transfers and their target
addresses within the bytecode stipulate how to divide the
entire bytecode buffer into basic blocks. The transfers then
produce edges between the blocks corresponding to possible
VPC changes during emulated execution. The CFG structure
provides a foundation for subsequent malware analysis.
4. Implementation
Our automatic reverse engineering occurs in three dif-
ferent phases: dynamic tracing, clustering, and behavioral
analysis. Figure 3 shows the different phases of our process
and the interactions among the architectural components
used by the different analysis steps. The dynamic tracing
phase gathers run-time data related to a malware emulator’s
execution, and allows the clustering and behavioral analysis
phases to extract malware bytecode and the syntactic and
semantic information for the bytecode instruction set.
There are two important requirements for the run-time
environment of the dynamic tracing phase: instruction-level
tracing, and isolation from malware and attacks. Since
the analysis techniques in Rotalum´e are orthogonal to the
underlying run-time environment and our goal here is to
develop and evaluate these techniques, we implemented our
dynamic analysis techniques on top of QEMU [6], which
emulates an x86 computer system. For a deployable version
of Rotalum´e, we suggest using a more transparent and robust
environment, such as a hardware virtualization based system
like Ether [12]. The components in the latter two phases
were developed as an ofﬂine analyzer written in C++. In
our current prototype implementation, each individual phase
is activated manually using the result of the previous phase.
However, our design can be completely automated to process
large numbers of malware samples.
4.1. Dynamic Tracing
The ﬁrst phase collects the dynamic instruction trace
of the emulator program that is executing as the QEMU
guest operating system. We modiﬁed QEMU by inserting a
callback function that invokes Rotalum´e’s Trace Extractor
Engine (EE) for every instruction executed in QEMU. The
EE component collects necessary context information related
to the executed instruction and stores the intermediate-
representation (IR) that
is used in latter phases of the
system. Our IR is self-contained—we store the instruction
representation as well as the values of the operands involved
in the instruction. We log all information so that we may per-
form off-line analysis without requiring additional dynamic
analysis. The output information of this phase is represented
by the dynamic trace of the program in IR form.
4.2. Clustering
takes as input
The second phase clusters the memory read operations
visible in the trace. We group together every read operation
performed by the program based on the common variable
used to access that read memory location. This phase is
performed by two main components: the Binding Engine
(BE) and Clustering Engine (CE). The BE component is
a program that
the IR dynamic program
trace and applies the backward and forward abstract vari-
able binding algorithms described in Section 3.1. For each
algorithm, we store binding information differently. More
speciﬁcally, for each instruction in forward binding, we store
the following information: instruction id (a unique identiﬁer
for each instruction present in the dynamic program trace
IR), the destination register operand of the instruction, and
the bound variables associated with the destination register
102
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
according to the rules described in Section 3.1.1. For each
instruction in backward binding, we store the instruction
id and the bound variables associated with the registers or
memory locations according to the rules deﬁned in Section
3.1.2. The BE component provides the binding information
to the CE. The CE component is a program that inputs the
IR dynamic trace and the binding information, and applies
the clustering algorithm. At a high level, CE takes the union
of forwarding and backward binding information, applies the
dependence function in Section 3.2, and provides the cluster
information. The cluster information contains a vector of sets
where each set contains the addresses of the memory read
instructions that are accessed by the same variable. At the
end of this phase, the cluster information is saved to a ﬁle.
4.3. Behavioral Analysis
The behavioral analysis phase provides the ﬁnal infor-
mation output of Rotalum´e. We implemented a behavioral
analyzer composed of two sub-components: the Taint En-
gine and the Emulation Behavior Detector. The behavioral
analyzer is a program that takes as input the IR dynamic
trace and clustering information, and analyzes one cluster at
a time. For each cluster, the Taint Engine taints the memory
address contained in the cluster and activates the Emulation
Behavior Detector. This analyzer is a state machine that
follows the tainted addresses and identiﬁes the emulation
behavior, as described in Sections 3.3 and 3.4. Whenever
the analyzer recognizes an opcode, the system stores in-
formation of the opcode into a ﬁle. More speciﬁcally, the
analyzer stores for each opcode executed: its opcode value,
the operands’ values, and the x86 code in assembly format
associated with the executed opcode.
5. Evaluation
We evaluated Rotalum´e using both synthetic and real pro-
grams that include both legitimate applications and malware,
including real-world emulated malware. These programs are
obfuscated to run on three commercially available packers
that support emulation: Code Virtualizer [23], Themida [24],
and VMProtect [35]. VMProtect and Code Virtualizer con-
vert selective functions of a given binary program into
a bytecode program with a randomly generated bytecode
language. Themida, which is more widely used for malware,
does not apply emulation to the given malicious binary
program but rather to the unpacking routine and the code
that invokes API calls.
5.1. Synthetic Tests
We ﬁrst experimented with synthetic test programs. Our
goal was to use the ground truth of the synthetic programs
to evaluate the information about the extracted bytecode
Table 1. Description of synthetic test programs
Program
Description
synth1
synth2
synth3
No branch
Nested if
Loop and if
x86 Program
Inst.
C-Flow
24
61
55
1
11
10
x86 Trace
Inst.
24
21
270
C-Flow
1
7
54
program and the syntax and semantics of the virtual instruc-
tion set architecture identiﬁed by Rotalum´e. We used Code
Virtualizer and VMProtect because they can obfuscate any
user-speciﬁed function in a program.
We wrote three simple synthetic test programs in C.
Each test program contained a function with distinguish-
able control-ﬂow characteristics that we wanted to obfus-
cate. We compiled these programs and converted them
to x86 binaries. We analyzed the static characteristics of
the compiled code using IDAPro [13] and the dynamic
characteristics by tracing the programs in our QEMU-based
system. Table 1 lists information about the three functions
of these test programs. For each function, the table shows
the total numbers of x86 instructions (“Inst.”) and control-
ﬂows instructions (“C-Flow”) obtained from static analysis.
The total numbers of x86 and control-ﬂow instructions in
an execution trace of the functions, obtained from dynamic
analysis, are also shown. Program synth1 involves simple
computation without any conditional branch or function.
Program synth2 contains nested if statements, and hence
its execution trace contains only a part of its (static) program
instructions. Finally, synth3 contains both if statements
and a for loop. Its trace length was larger than the static
x86 instruction count because of loops.
We used VMProtect and Code Virtualizer to obfuscate
the selected functions in our three test (binary) programs.
We then applied Rotalum´e to analyze them. Rotalum´e was
able to correctly identify emulation behavior in all of the
test cases, and Tables 2 and 3 summarize respectively the
results of reversing Code Virtualizer and VMProtect. The
results show information for bytecode instructions traced and
identiﬁed at run-time in terms of the instruction counts (of
all types and the control-ﬂow instructions) of the bytecode
execution trace and the program itself. The results also show
the virtual instruction set architecture (ISA) discovered by
Rotalum´e in terms of the number of unique bytecode in-
structions, information regarding the syntax of the bytecode
language in terms of number of operands, and information
regarding the semantics of conditional control-ﬂow transfers.
In both VMProtect and Code Virtualizer, the bytecode
trace of a program was signiﬁcantly longer than its original
x86 binary. For example, synth3 executed 3,481 bytecode
instructions of Code Virtualizer and 5,709 of VMProtect,
compared to just 270 x86 instructions in the original pro-
gram. The results also show that for all test cases, Rotalum´e
103
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
Table 2. Results for synthetic programs obfuscated with Code Virtualizer
Bytecode Trace (inst. count)
All types
C-Flow
Bytecode Program (inst. count)
All types
C-Flow
All types
Virtual Instruction Set Architecture
1 Opr
C-Flow (Cond.)
0 Opr
277
254
3481
1
7
54
277
254
684
1
7
8