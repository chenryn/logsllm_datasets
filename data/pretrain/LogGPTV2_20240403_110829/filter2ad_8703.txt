# 【技术分享】用户模式下基于异常和内核控制的线程级钩子技术分析

## 译文声明
本文为翻译文章，原文来源于 [cyberark.com](http://cyberark.com)。译文仅供参考，具体内容及含义请以原文为准。
- 译者：[WisFree](http://bobao.360.cn/member/contribute?uid=2606963099)
- 预估稿费：200 RMB
- 投稿方式：发送邮件至 linwei#360.cn 或登录网页版在线投稿

## 简介
在本文中，我们将介绍一种在研究过程中发现的新颖钩子（Hook）技术。钩子技术广泛应用于各种软件组件，包括应用程序安全解决方案、系统工具、编程软件（如拦截、调试和功能扩展工具），以及恶意软件（如rootkit）。钩子机制允许应用程序截获并处理Windows消息或特定事件，从而实现对目标窗口消息的监视和处理。

需要注意的是，本文所介绍的技术不涉及提权和漏洞利用，而是主要用于后渗透场景，即攻击者已经成功获取目标设备控制权的情况。由于恶意内核代码（如rootkit）通常会尝试在目标系统中实现持久化感染，因此隐藏技术变得尤为重要。

## 技术描述
我们称这项技术为BoundHook。BoundHook技术通过在用户模式下的特定位置引发异常，并捕获这些异常来接管线程的执行。具体来说，我们可以使用BOUND指令（Intel MPX内存保护扩展的一部分）来实现这一操作。BOUND指令原本用于检测指针引用，提升软件安全性。简而言之，BOUND指令可以检测数组索引是否越界，如果测试失败则会触发软件中断（32-bit: **nt!KiTrap05** , 64-bit: **nt!KiBoundFault**）。

### BOUND指令
BOUND指令的语法如下：
- `BOUND r16, m16&16`：检测r16（数组索引）是否越界（m16&16指定）
- `BOUND r32, m32&32`：检测r32（数组索引）是否越界（m32&32指定）

当边界检查失败时，陷阱处理程序将调用 **nt!KiHandleBound** 并执行已注册的边界异常回调程序。

### 注册边界异常回调
内核模式驱动程序或运行在内核模式下的shellcode payload可以使用 **nt!KeRegisterBoundCallback** 来注册边界检测异常的回调程序。需要注意的是，这个函数并不是WDK header提供的，需要动态加载指向该函数的指针。回调程序没有参数，并返回一个 **BOUND_CALLBACK_STATUS** 枚举类型值。

完成边界异常的注册后，内核模式代码会获取用户模式DLL基地址的指针，并计算出需要设置钩子的函数地址。获取函数地址可以通过解析PE头等多种方法实现。需要注意的是，解析特定进程加载的镜像需要在进程环境中进行或使用特定API。

### 内存写入问题
由于目标代码位于只读/可执行内存中，直接写入数据是不可行的。Windows内存保护主要依赖于以下几个因素：
- 复制写入（COW）保护
- CR0寄存器的写保护位
- 内存描述符列表（MDL）

我们有几种选择：
1. 触发COW保护
2. 使用 __readcr0() 和 __writecr0() 修改CR0寄存器
3. 分配MDL并调整权限

#### 修改CR0寄存器
CR0寄存器的写保护位（WP）控制高等级进程向只读页面写入数据的能力。以下是一个简单的修改样例：

```c
// 读取当前CR0寄存器值
unsigned long cr0 = __readcr0();
// 清除写保护位
cr0 &= ~0x10000;
// 写回CR0寄存器
__writecr0(cr0);
```

#### 触发边界异常
触发边界异常也很简单。例如，以下代码将触发一次错误异常：

```asm
UCHAR opcodes[5] = {0x36, 0x66, 0x62, 0x0C, 0x24};
```

这行汇编代码相当于 `BOUND CX, DWORD PTR SS : [ESP]`。在这种情况下，假设CX为0，栈顶的值大于0（仅作为概念验证）。

### 应用示例
假设我们要挂钩 `KERNELBASE!CreateFileW` 函数，可以将上述操作码注入到该函数的起始位置。当用户模式下的线程调用该函数时，内核模式下的回调函数将接管该线程的执行。

### 优势
1. 挂钩的页面仍然是COW，反恶意软件解决方案和手动分析难以发现篡改。
2. 大多数反病毒产品无法检测这种技术，因为页面仍然是COW。
3. 用户模式调试器无法捕捉到这种钩子。普通的内联钩子方法会让已挂钩的程序跳转到其他用户模式代码，而BoundHook技术通过内核边界异常处理器修改执行流程。
4. 大多数PatchGuard（PG）保护机制无法察觉这种钩子技术。根据当前PG的设计原理，使用MDL方法绕过COW机制不会被检测到。对于修改CR0寄存器的方法，虽然CR0寄存器受PG保护，但修改操作可以在短时间内完成，被检测的可能性较小。

### PoC-已挂钩的线程调用栈
此处展示PoC的调用栈示例。

## 总结
尽管微软认为BoundHook技术所利用的因素不属于安全漏洞，因为它是在攻击者已经获得设备管理员权限的情况下使用的。此前，微软从CyberArk（GhostHook技术）那里收到类似问题报告时，回应称这只是躲避安全检测的技术，并不符合他们的漏洞规定，因此不会发布补丁，但会在未来的Windows版本中考虑解决这个问题。

无论如何，我们认为这种技术为软件安全厂商和恶意软件开发者提供了新的思路，希望微软能够尽快解决这个问题。