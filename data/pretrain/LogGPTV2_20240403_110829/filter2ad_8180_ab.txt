    ROM:000002A0                 li      R24, 0x66546330 ;; 0
    ROM:000002A8                 cmp     op0, R1, R15    ;; R33
    ROM:000002AC                 jmpcmp  R33, loc_2C0
    ROM:000002B0                 sub     R2, R1, R15
    ROM:000002B4                 loop    loc_2B8, R2
    ROM:000002B8
    ROM:000002B8 loc_2B8:                                ;; CODE XREF: sub_1E0+DC↓j
    ROM:000002B8                 add     R24, R24, R19
    ROM:000002BC                 endloop loc_2B8
    ROM:000002C0
    ROM:000002C0 loc_2C0:                                ;; CODE XREF: sub_1E0+CC↑j
    ROM:000002C0                 add     R26, R25, R24
    ROM:000002C4                 load    R0, op1         ;; R26
    ROM:000002C8                 in5
    ROM:000002CC                 retn
第一条指令我也不知道有啥用
func函数包括两个参数a,b
第一个循环：b从b+1到b+a+1不断的模a，结果以dowrd存在0x2019中
第二个循环中，可以看到有两层循环，次数都是之前获得的数组的长度，每次比较相邻两个元素并根据大小交换。不难发现这是一个排序。特别的，它排序并非是按照数值大小排序的（这样就是从1到a所有的数了），而是之前提到过的字符串大小比较（将整数转成字符串）
排好序后，将第b个数返回。
稍微简化一下，贴出python代码及fun(233,144)的输出和list作为参考
    def icmp(a,b):
        return cmp(str(a),str(b))
    def fun(a,b):
        r = []
        for i in range(a):
            r.append((b+i)%a+1)
        r.sort(icmp)
        print(r)
        return r[b-1]
    print(fun(233,144))
输出：
    [1, 10, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 11, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 12, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 13, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 14, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 15, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 16, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 17, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 18, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 19, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 2, 20, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 21, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 22, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 23, 230, 231, 232, 233, 24, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 7, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 8, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 9, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
    228
可以看到与常规排序的不同。然而光用上面的代码没办法求出结果，因为数值实在太大了，占用空间也太多了，甚至无法编译通过。
我们需要找到一种映射，给出一个b，在限定范围的a内，找到a按字符串排序后的第b个元素。
分析：可以看出来，以1开头的数都在前面，然后是2开头，3开头。。。由于a不同，1、2、3。。。开头的数目也不同。我们先分析999个数，每个字符开头的数的数目是一样的。
对于1到999这999个数，1开头的数有：
1 1个
10，11，12 …… 19 10个
100，101，102 …… 199 100个
每个字符开头的数目都是111个，这样把要求的n除以111再加以，就能得到它是几开头的了
注意，对于111，由于1是第一个数，并没有第0个数。第111个数是199，然而111//111 ==
1。实际上除以111的到结果为0的值范围在[0,110]，因此除以的时候要先-1。
对于所有的1开头的111个数，n-1模111（同样的，这里也要减一）后得到的数，就是这些1开头的数种的第几个了。模后的结果如果为0，就直接返回1本身。大于0时，不难看出，以10开头的数共有11个，以11开头的数共有11个，以12开头的数也有11个……又回到相似的地方。不同的，第一位是从1到9共9个数，而第二位有从0到9共10个数。
分析完可以写出快速求解的代码：
    def func(a,b):
        ret = ''
        table = [1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,11111111111]
        n = b
        lenth = len(str(a))
        num = (n-1) // table[lenth-1]
        ret+=str(num+1)
        n = (n-1) % table[lenth-1]
        if n == 0:
            return int(ret)
        i = lenth - 2
        while(True):
            num = (n-1) // table[i]
            n = (n-1) % table[i]
            ret+=str(num)
            if n == 0:
                return int(ret)
            i -= 1
        return int(ret)
此函数逆完，剩下的部分没有需要优化的，抄抄代码就行了。注意下面几个case里的或非最后其实都是异或
最终的脚本
    def func(a,b):
        ret = ''
        table = [1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,11111111111]
        n = b
        lenth = len(str(a))
        num = (n-1) // table[lenth-1]
        ret+=str(num+1)
        n = (n-1) % table[lenth-1]
        if n == 0:
            return int(ret)
        i = lenth - 2
        while(True):
            num = (n-1) // table[i]
            n = (n-1) % table[i]
            ret+=str(num)
            if n == 0:
                return int(ret)
            i -= 1
        return int(ret)
    p = [0xFA730603, 0xF8084C29, 0xF4290A55, 0xF17A02CD, 0xF1E59BC4, 0xF41ABBF1, 0xFDF84718, 0xF0083FD1, 0xF1BAED2B, 0xFA2AEAC7, 0xF652CC03, 0xF178B08D, 0xF1198EB5, 0xF0672595, 0xF1753690, 0xF2E67825, 0xF2B0197A, 0xF84C8755, 0xFB72A68F, 0xF656D307, 0xFC005E80, 0xF350372A, 0xF27B843E, 0xF1AE2E9B, 0xF2ECB793, 0xF2CF233D, 0xFDAB487F, 0xFB7989EE, 0xF585E8A7, 0xFB155234, 0xF8615835, 0xFE982EE1, 0xF6C42E3E, 0xF96E377C, 0xF102A7E0, 0xFE2391E8, 0xFA7500A5, 0xF640F391, 0xF1E1670F, 0xF9D0235F, 0xF7C12D7D, 0xF863762C, 0xFBED5B8A, 0xFDB8DEC7, 0xF186136E, 0xF2DFACF3, 0xFE5D1AC8, 0xF25E770D, 0xFB56D6DD, 0xF33EB123, 0xF4B7FADA, 0xF6242889, 0xF59F048F, 0xFC86FA29, 0xFCD04769, 0xF14B8063, 0xFAA6F222, 0xF0D23990, 0xF6846A8C, 0xF3CD8234, 0xFA440DE1, 0xF5DE4EE7, 0xF40C2BCA, 0xF0590358, 0xF4A968CB, 0xF65A2DFF]
    q = [0x2FA2377, 0x6D1C33E, 0x1B22D44, 0x171F345, 0x183FF47, 0x2879609, 0x36EB9D7, 0x811BB, 0xC12DB0, 0x1B7DB20, 0x54F2EC9, 0x11A893B, 0x48DB44, 0x1F61D0, 0x8B7372, 0x1A717EF, 0x167692A, 0x55ACE9B, 0x47D0923, 0x9E4F8E, 0x2036162, 0x2F9AC19, 0x1E0DBF7, 0x1852D9B, 0x26D4EBA, 0x20E3486, 0xBB0F702, 0x3E40DF6, 0x24284B, 0x447418E, 0x7BB11A6, 0x6A330BC, 0xC5815A, 0x2EFAA0D, 0xC1E170, 0x628F151, 0x1C629CF, 0x2E04C82, 0x15445D, 0x1BDE2A7, 0x46ABA70, 0x11A1341, 0xB733982, 0x6E87A60, 0xF7715D, 0x24F3682, 0x181C131, 0x23AA7F6, 0xA44B51, 0x29E1B4F, 0x2686A1, 0x1956047, 0x214B4AC, 0xF3BF0, 0x9701B3, 0x1C3E00, 0x6B4AAF, 0x773A9A, 0x2BCB4D1, 0x1690AF8, 0x4139BD8, 0xE04630, 0x17E5300, 0x473799, 0x401B105, 0x373A611]
    a = [  0x4E, 0xE4, 0x4C, 0x7A, 0xFE, 0xC9, 0xB7, 0x4E, 0xFE, 0xF1, 
      0x1E, 0x3B, 0xBE, 0x41, 0xB3, 0x5A, 0xD6, 0xBB, 0x52, 0x37, 
      0x62, 0xEE, 0x67, 0x32, 0xF6, 0x03, 0x55, 0x0B, 0x56, 0xB4, 
      0x12, 0x59, 0x13, 0xA6, 0x8E, 0x56, 0x04, 0x74, 0x6A, 0x12, 
      0xE5, 0xC3, 0x3F, 0x97, 0xF4, 0x82, 0x47, 0xA6, 0xCB, 0x46, 
      0x97, 0xBD, 0x65, 0x13, 0x07, 0xF0, 0x2E, 0xDE, 0x36, 0x4C, 
      0x44, 0x26, 0x02, 0xFB, 0xA3, 0x42]
    b = [  0x97, 0x15, 0x43, 0x98, 0x11, 0x2F, 0x3E, 0x06, 0x6D, 0x12, 
      0x45, 0x33, 0x58, 0x0F, 0x6A, 0x8E, 0x84, 0x23, 0x3E, 0xAD, 
      0x4D, 0x79, 0x21, 0x1D, 0x7B, 0x40, 0x1C, 0xC8, 0x8F, 0x11, 
      0x6A, 0x18, 0x37, 0x97, 0x2E, 0x82, 0x2D, 0x2E, 0x28, 0x7C, 
      0x3C, 0x8B, 0x0C, 0x68, 0x14, 0x7D, 0x49, 0x35, 0x37, 0x63, 
      0x54, 0x13, 0x73, 0xCC, 0x9C, 0x54, 0x7C, 0x1F, 0x19, 0x59, 
      0x40, 0x30, 0x13, 0x20, 0xCE, 0x64]
    r = []
    for i in range(66):
        r.append(func(p[i],q[i]))
    # print(r)
    s = ''
    for i in range(66):
        case = a[i]&3
        if case == 0:
            s+=chr((((r[i]%0x100)^a[i])+b[i]))
        elif case == 1:
            s+=chr((((r[i]%0x100)^a[i])+b[i]))
        elif case == 2:
            s+=chr((((r[i]%0x100)^a[i])-b[i]))
        elif case == 3:
            s+=chr((((r[i]%0x100)^a[i])-b[i]))
    print(s)