在本书中，我们将重点放在实现网际网路服务的系统上，这些系统通常与超级计算机看起来有很大不同：
* 许多与网际网路有关的应用程式都是 **线上（online）** 的，因为它们需要能够随时以低延迟服务使用者。使服务不可用（例如，停止丛集以进行修复）是不可接受的。相比之下，像天气模拟这样的离线（批处理）工作可以停止并重新启动，影响相当小。
* 超级计算机通常由专用硬体构建而成，每个节点相当可靠，节点透过共享记忆体和 **远端直接记忆体访问（RDMA）** 进行通讯。另一方面，云服务中的节点是由商用机器构建而成的，由于规模经济，可以以较低的成本提供相同的效能，而且具有较高的故障率。
* 大型资料中心网路通常基于 IP 和乙太网，以 CLOS 拓扑排列，以提供更高的对分（bisection）频宽【9】。超级计算机通常使用专门的网路拓扑结构，例如多维网格和 Torus 网路 【10】，这为具有已知通讯模式的 HPC 工作负载提供了更好的效能。
* 系统越大，其元件之一就越有可能坏掉。随著时间的推移，坏掉的东西得到修复，新的东西又坏掉，但是在一个有成千上万个节点的系统中，有理由认为总是有一些东西是坏掉的【7】。当错误处理的策略只由简单放弃组成时，一个大的系统最终会花费大量时间从错误中恢复，而不是做有用的工作【8】。
* 如果系统可以容忍发生故障的节点，并继续保持整体工作状态，那么这对于运营和维护非常有用：例如，可以执行滚动升级（请参阅 [第四章](ch4.md)），一次重新启动一个节点，同时继续给使用者提供不中断的服务。在云环境中，如果一台虚拟机器执行不佳，可以杀死它并请求一台新的虚拟机器（希望新的虚拟机器速度更快）。
* 在地理位置分散的部署中（保持资料在地理位置上接近使用者以减少访问延迟），通讯很可能透过网际网路进行，与本地网路相比，通讯速度缓慢且不可靠。超级计算机通常假设它们的所有节点都靠近在一起。
如果要使分散式系统工作，就必须接受部分故障的可能性，并在软体中建立容错机制。换句话说，我们需要从不可靠的元件构建一个可靠的系统（正如 “[可靠性](ch1.md#可靠性)” 中所讨论的那样，没有完美的可靠性，所以我们需要理解我们可以实际承诺的极限）。
即使在只有少数节点的小型系统中，考虑部分故障也是很重要的。在一个小系统中，很可能大部分元件在大部分时间都正常工作。然而，迟早会有一部分系统出现故障，软体必须以某种方式处理。故障处理必须是软体设计的一部分，并且作为软体的运维，你需要知道在发生故障的情况下，软体可能会表现出怎样的行为。
简单地假设缺陷很罕见并希望始终保持最好的状况是不明智的。考虑一系列可能的错误（甚至是不太可能的错误），并在测试环境中人为地建立这些情况来检视会发生什么是非常重要的。在分散式系统中，怀疑，悲观和偏执狂是值得的。
> #### 从不可靠的元件构建可靠的系统
>
> 你可能想知道这是否有意义 —— 直观地看来，系统只能像其最不可靠的元件（最薄弱的环节）一样可靠。事实并非如此：事实上，从不太可靠的潜在基础构建更可靠的系统是计算机领域的一个古老思想【11】。例如：
>
> * 纠错码允许数字资料在通讯通道上准确传输，偶尔会出现一些错误，例如由于无线网路上的无线电干扰【12】。
> * **网际网路协议（Internet Protocol, IP）** 不可靠：可能丢弃、延迟、重复或重排资料包。传输控制协议（Transmission Control Protocol, TCP）在网际网路协议（IP）之上提供了更可靠的传输层：它确保丢失的资料包被重新传输，消除重复，并且资料包被重新组装成它们被传送的顺序。
>
> 虽然这个系统可以比它的底层部分更可靠，但它的可靠性总是有限的。例如，纠错码可以处理少量的单位元错误，但是如果你的讯号被干扰所淹没，那么透过通道可以得到多少资料，是有根本性的限制的【13】。TCP 可以隐藏资料包的丢失，重复和重新排序，但是它不能神奇地消除网路中的延迟。
>
> 虽然更可靠的高阶系统并不完美，但它仍然有用，因为它处理了一些棘手的低阶错误，所以其余的错误通常更容易推理和处理。我们将在 “[资料库的端到端原则](ch12.md#资料库的端到端原则)” 中进一步探讨这个问题。
## 不可靠的网路
正如在 [第二部分](part-ii.md) 的介绍中所讨论的那样，我们在本书中关注的分散式系统是无共享的系统，即透过网路连线的一堆机器。网路是这些机器可以通讯的唯一途径 —— 我们假设每台机器都有自己的记忆体和磁碟，一台机器不能访问另一台机器的记忆体或磁碟（除了透过网路向伺服器发出请求）。
**无共享** 并不是构建系统的唯一方式，但它已经成为构建网际网路服务的主要方式，其原因如下：相对便宜，因为它不需要特殊的硬体，可以利用商品化的云计算服务，透过跨多个地理分布的资料中心进行冗余可以实现高可靠性。
网际网路和资料中心（通常是乙太网）中的大多数内部网路都是 **非同步分组网路（asynchronous packet networks）**。在这种网路中，一个节点可以向另一个节点发送一个讯息（一个数据包），但是网路不能保证它什么时候到达，或者是否到达。如果你传送请求并期待响应，则很多事情可能会出错（其中一些如 [图 8-1](../img/fig8-1.png) 所示）：
1. 请求可能已经丢失（可能有人拔掉了网线）。
2. 请求可能正在排队，稍后将交付（也许网路或接收方过载）。
3. 远端节点可能已经失效（可能是崩溃或关机）。
4. 远端节点可能暂时停止了响应（可能会遇到长时间的垃圾回收暂停；请参阅 “[程序暂停](#程序暂停)”），但稍后会再次响应。
5. 远端节点可能已经处理了请求，但是网路上的响应已经丢失（可能是网路交换机配置错误）。
6. 远端节点可能已经处理了请求，但是响应已经被延迟，并且稍后将被传递（可能是网路或者你自己的机器过载）。
![](../img/fig8-1.png)
**图 8-1 如果传送请求并没有得到响应，则无法区分（a）请求是否丢失，（b）远端节点是否关闭，或（c）响应是否丢失。**
传送者甚至不能分辨资料包是否被传送：唯一的选择是让接收者传送响应讯息，这可能会丢失或延迟。这些问题在非同步网路中难以区分：你所拥有的唯一资讯是，你尚未收到响应。如果你向另一个节点发送请求并且没有收到响应，则不可能判断是什么原因。
处理这个问题的通常方法是 **超时（Timeout）**：在一段时间之后放弃等待，并且认为响应不会到达。但是，当发生超时时，你仍然不知道远端节点是否收到了请求（如果请求仍然在某个地方排队，那么即使传送者已经放弃了该请求，仍然可能会将其传送给接收者）。
### 真实世界的网路故障