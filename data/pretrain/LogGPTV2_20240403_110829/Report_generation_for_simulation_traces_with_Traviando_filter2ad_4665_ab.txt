tailed diagram and the aggregated information of a linear
regression are provided. For regular behavior, we assume
that the slope of the regression is close to zero and that the
frequency with which the variable gets modiﬁed shows lit-
tle variation. For each variable, we report on which actions
perform changes to its values and in which manner. We also
check, if a variable is rarely changed or frequently changed
and if after an initial period of changes those die out and the
variable remains constant for the rest of the trace. The lat-
ter can indicate a deadlocking situation, if actions that have
made changes to that variable die out as well.
Actions. For each action, we want to provide feedback
about which states enable this action and what state trans-
formations are observed. This feedback helps a modeler to
recognize faulty action speciﬁcations. The ﬁrst issue is to
recognize actions that are declared in the preﬁx but never
occur in the trace, which may indicate dead model com-
ponents or indicate that the trace is too short to represent
the dynamic behavior of a model completely. For those
actions that are indeed present in the trace, we are inter-
ested in a characterization of states where they can occur
(enabling conditions) and what changes an action causes to
which state variable (state transformation function). We try
to ﬁt the transformation that an action a performs for a nu-
merical variable with current value v and resulting value
v(cid:48) as a linear function v(cid:48) = b · v + c. Linear transforma-
tions are often seen for encodings of automata, in particular
for Petri nets. If a linear function does not ﬁt, we consider
the function as dependent on the current state s, such that
v(cid:48) = v + δ(v, a, s), which works for all deterministic state
transformations. In those cases, we report how often a in-
creases, decreases, or does not change the value of v as well
as the range of values seen for δ(v, a,∗). One possible rea-
son for a state dependent function may actually be a range
overﬂow of an integer-valued variable. We check this by
looking at states preceding action a and detect the one with
the highest value seen for v. Given that value, we see if
we can exceed a common integer range threshold (e.g., 28
for unsigned short, 232 for unsigned integer) by adding a
possible value seen for δ(v, a, s). In a similar manner, we
check for underﬂow for signed and unsigned short and in-
teger variables. By checking all predecessor and succes-
sor states of events that perform a particular action, we can
also detect if the action shows a non-deterministic behavior
(same action yields different successor states for equal pre-
decessor states). As for variables, we check if occurrences
of an action are seen only for some initial phase of the trace,
which can indicate a deadlock situation.
Immediate actions. A discrete event simulator schedules
events according to its time stamps. In practice, it is pos-
sible that multiple events get scheduled for a single point
of time. Examples for this scenario are discrete time steps,
actions that have particular deterministic, discrete delays,
or actions that model immediate reactions to state changes
triggered by some other actions.
It is often difﬁcult for
a modeler to evaluate how a simulator schedules multiple
events at a single point of time. Documentation may not be
detailed and speciﬁc enough to cover all cases or may not
be up to date and in sync with the simulator code.
In any case, a sequence of events with the same time
stamps can be easily recognized in a given trace. We iden-
tify those sequences and report the triggering actions, pro-
vide a set of immediate successor actions and the length
of such subsequences. However, for an investigation of
full details, the interactive use of Traviando with its event
browser and its trace visualization with message sequence
charts is more suitable than what can be provided in a gen-
erated HTML report.
Invariants. So far, we have considered properties of in-
dividual variables or actions. However, models often carry
invariants like a constant number of customers in a closed
queueing network or that particular sets of actions may
cause the simulation to return to a state, e.g., a failure and
repair of a subsystem. We aim to detect some of these in-
variants of a model as well. We consider invariants of two
kinds, namely (1) action invariants that describe occurrence
counts for sequences of actions that describe a cyclic subse-
quence in a trace, i.e., a sequence of events that leads back
to its starting state, and (2) state (variable) invariants, i.e.,
weighted sums of numerical state variables that remain con-
stant throughout a trace. The presence or absence of an in-
variant provides useful feedback to a modeler. For example,
a particular component like a resource goes through differ-
ent levels of utilization and operational modes, which often
constitutes a state invariant if there are state variables that
account for how many components are in which operational
mode and an action invariant accounting for all actions that
take place between two states where the resource is idle and
If those expected invariants are not seen, a
operational.
modeler may want to check all involved actions and their
state transformations to identify the reason for an absence
of the expected regular behavior.
Invariants can be obtained in two ways, either by ob-
serving and checking invariants throughout the trace or, for
a subclass of models, by identifying an underlying vector
addition system that allows us to apply traditional invari-
ant analysis known for Petri nets. For actions, both ways
are currently supported; for variables, only the latter is cur-
rently available. From exercising a set of traces from a vari-
ety of example models, we have seen that sets of invariants
tend to be large, such that we decided to restrict the set of
observed invariants that are reported on a web page to those
vectors that are linearly independent.
For a modeler, it is of interest to obtain a list of invari-
ants as well as an enumeration of all actions (all variables)
that are not covered by any invariant (whose computation is
immediate). This information is provided on the same page
with some further textual explanations and the list of invari-
ants such that the search feature of a web browser make it
straightforward to identify invariants that cover a particular
action (or variable).
Warnings. While the generated content we discussed so
far gives guidance to a model on the dynamic behavior of
a discrete event model as observed in a simulation run, we
also generate a list of warnings. Conceptually, the warn-
ings are of two kinds. The main category is for warnings
that describe anomalies detected for certain actions, vari-
ables and combinations thereof. The second category con-
sists of warnings that indicate difﬁculties the analysis tech-
niques can face, e.g., the ﬁtting of a state transformation
function to a linear function is based on a single occurrence
of an action, which is not enough data, or if a trace may be
too short to observe all actions, such that a lot of actions are
not present and detected as potentially dead code.
Each warning carries a link to a corresponding external
and static webpage that documents the underlying rule that
raises the warning, its rationale, symptoms, diagnosis and
therapy as a concrete advice on how to ﬁx the problem.
4. Example
In this section, we brieﬂy discuss how to detect an error
in the speciﬁcation of an action in a simple queueing model
with two customer classes, where the server is subject to
failures and repair. The model is described with M¨obius and
we consider a generated trace of 113,654 events. The model
is taken from [8], where it is described how the progress
measure of the trace points us to the error. The new ver-
sion of Traviando generates a report of 73 webpages for this
model of 6 processes with a total of 11 variables and 12 ac-
tions. The purpose of the report is to give guidance to a
modeler if something is wrong and what that can be. It pro-
vides multiple clues that help to recognize the faulty state
transformation including the results of [8]. Fig. 2 shows
the sequence of states reached in the trace, which indicates
that certain events seem to prohibit the simulation to return
to previous states which is not as expected. The ﬁgure for
the progress measure gives a similar message. If we check
Figure 3. Progress measured for a single pro-
cess of the server model
the page for all variables, we see the same stepwise func-
tion for the progress of variables in process FullModel as
in Fig. 3. The name of the process should not be under-
stood as being the complete server model; this process cor-
responds to the top-level Join node in the M¨obius model
where four variables are shared that are seen as variables
of this process in Traviando. The webpage reports for each
variable the ﬁrst and last events that make assignments to it
and, if its type is numerical, the range of values observed.
For variables corresponding to one customer class, we can
easily detect that there are more customers than speciﬁed
since the range of values is reported as {0, 1, ..., 12} in-
stead of {0, 1}. Following a link for one of those variables,
namely C1WaitsForServer gets us to the variable’s detailed
page which informs us how the value of that variable in-
creases throughout the trace, which actions perform which
state transformation to the variable (as given in Table 1) and
ﬁnally a warning that this variable is not an element of any
variable invariant computed for this trace. By checking the
list of actions that increase the value of this variable, we see
that an action C2RestartIfFailed occurs 11 times and incre-
ments the variable. This tells us that this action which is
supposed to deal with customers of class 2 is faulty. Al-
though at this point, it is clear where the problem comes
from, we can also follow the link to the detailed page of that
action and check what else this action does. We see that the
state transformations performed with other variables are all
as expected, only the one to C1WaitsForServer is incorrect.
Action
Occurrences Transformation
C1RestartIfFailed(a7)
C2RestartIfFailed(a8)
C1StartService(a9)
C1StopThinking(a17)
18
11
19340
19323
v’=v+1
v’=v+1
v’=v-1
v’=v+1
Table 1. Table of actions that change variable
C1WaitsForServer as given in the report
Alternatively, we can check results of the invariant anal-
ysis: the page on observed action invariants lists four in-
variants and informs us that action C2RestartIfFailed is the
only that is not present in any invariant. Again, this points
us check this particular action. Action invariants computed
from a Petri-net type invariant analysis give a similar re-
sult. The variable invariants computed with invariant anal-
ysis tell us that three variables are not covered by any in-
variant, namely C1WaitsForServer, C1WaitsForUser, and
C1Thinking which are all state variables modeling the cus-
tomer class that does not have a constant population of cus-
tomers. The computed three variable invariants, on the other
hand, conﬁrm that the server is either in the state failed or
available, a constant number of customers of class 2 dis-
tribute over four variables and the server is either idle or
serving a customer of class 1 or of class 2, which is all as
expected. The list of warnings contains 4 warnings, one for
each of the three variables and one for the action that are all
not covered by any invariant, which guides us to the error in
the model.
For further details and the full report for the server
model, see the Traviando’s example page [2].
5. Conclusion
We presented an approach to identify model character-
istics from a simulation trace that contains information on
states as a set of value settings for state variables and events
with associated information on time stamps and actions.
The approach is implemented as a command-line extension
to Traviando and generates a detailed report in HTML for-
mat. Among other information, the report lists warnings
for unusual behavior and those warnings come with links to
webpages that contain further documentation on the rules
that are associated with a warning. A webpage for a partic-
ular rule gives guidance on symptoms, possible causes and
suggests solutions for known pitfalls in simulation model-
ing. Ongoing work is dedicated to extending the ruleset
and increasing the size of the sample set. At this point, the
existing software is available on request for research and
teaching purposes. We plan to make a future version freely
available together with a rule set of modeling rules.
Acknowledgements. We would like to thank the re-
viewers and Daniel Varro for their constructive comments
and Ruth Lamprecht for her editorial assistance, which all
helped to improve this paper.
References
[1] NS2:
http://www.isi.edu/nsnam/ns/.
The
network
simulator.
[2] Traviando: www.cs.wm.edu/∼kemper/traviando.html,
www.cs.wm.edu/∼kemper/traviando/examples.html.
[3] O. Balci. Quality assessment, veriﬁcation, and valida-
tion of modeling and simulation applications. In Proc.
of the 2004 Winter Simulation Conference, pages 122–
129. IEEE, 2004.
[4] D. D. Deavours, G. Clark, T. Courtney, D. Daly, S. De-
risavi, J. M. Doyle, W. H. Sanders, and P. G. Webster.
The M¨obius framework and its implementation. IEEE
Trans. Software Eng., 28(10):956–969, 2002.
[5] F. Bause et al. A toolbox for functional and quanti-
In Computer Performance
tative analysis of DEDS.
Evaluation / TOOLS, Springer LNCS 1469, pages
356–359, 1998.
[6] F. Bause et al. The ProC/B toolset for the modelling
and analysis of process chains. In T. Field et al, editor,
Computer Performance Evaluation / TOOLS, Springer
LNCS 2324, pages 51–70, 2002.
[7] D. Hovemeyer and W. Pugh.
Finding more null
In Proc. 7th ACM
pointer bugs, but not too many.
SIGPLAN-SIGSOFT Workshop on Program Analysis
for Software Tools and Engineering, 2007.
[8] P. Kemper and C. Tepper. Automated trace analysis of
discrete event system models. IEEE Transactions on
Software Engineering, in print, 2009.
[9] R. G. Sargent. Veriﬁcation and validation of simula-
tion models. In Winter Simulation Conference, pages
157–169. ACM, 2008.
[10] A. J. M. M. Weijters and L. Maruster. Workﬂow
mining: Discovering process models from event logs.
IEEE Transactions on Knowledge and Data Engineer-
ing, 16, 2004.