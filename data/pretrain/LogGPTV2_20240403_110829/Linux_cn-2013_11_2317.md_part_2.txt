> 
> 注:由于Boyer-Moore(BM)从右到左搜索匹配，仍然有可能匹配分布在多个块，在这种情况下该算法并没有优势。
> 
> 
> 如果你希望确保这样的事情永远不会发生，那使用Knuth-Pratt-Morris(KMP)实现。总之，根据您的设置适当地选择字符串搜索算法。
> 
> 
> 如果你正在用文本搜索器进行过滤，NIDS或任何类似的注重安全的目的，那么使用KMP。否则，如果你真的关心性能，并且你对数据包进行分类以使用服务质量(QoS)政策，当你不介意匹配可能分布分散，那么用BM。
> 
> 
> 
### Chromium 浏览器中的数据结构和算法
Chromium的([源代码在 Google code](https://code.google.com/p/chromium/))。我只会列出一部分。我建议使用搜索来找到你最喜欢的算法或者数据结构。
1.[伸展树](https://code.google.com/p/chromium/codesearch#chromium/src/v8/src/splay-tree.h)。
> 
> 这个树通过分配策略（分配器）参数化。这个策略用于C的可用存储区的列表分配，参见zone.h。
> 
> 
> 
2.[Voronoi算法](https://code.google.com/p/chromium/codesearch#chromium/src/native_client_sdk/src/examples/demo/voronoi/index.html)用于一个示例。
3.[基于Bresenham算法的选项卡](https://code.google.com/p/chromium/codesearch#chromium/src/chrome/browser/ui/cocoa/tabs/tab_strip_controller.mm)
在Chromium的第三方代码里面也有如下的数据结构和算法。
1.[二叉树](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/bintrees/bintrees/bintree.py)
2.[红黑树](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/bintrees/bintrees/rbtree.py)
> 
> Julian Walker的总结
> 
> 
> 红黑树是一个有趣的小东西。他们被认为比AVL树(它们的直接竞争对手)简单，乍一看这似乎是由于插入是一项轻松的乐事。然而，当你开始删除时，红黑树变得非常棘手。然而，通过复杂性的平衡，插入和删除可以使用单通道，实现自上而下的算法。这与AVL树情况不一样，插入只能自顶向下，删除则需要自下而上。
> 
> 
> ...
> 
> 
> 红黑树是很流行的，像大多数数据结构一样有一个古怪的名字。比如，在Java和c++库映射结构通常用红黑树实现。红黑树的速度也与AVL树相当。而AVL树平衡性不是很好，需要保持平衡的话红黑树通常更好。有一些流传的误解，但在大多数情况下对红黑树的宣传是准确的。
> 
> 
> 
3.[AVL 树](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/bintrees/bintrees/avltree.py)
4.[Rabin-Karp字符串匹配](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/zlib/deflate.c)用于比较。
5.[自动机后缀的计算](https://code.google.com/p/chromium/codesearch#chromium/src/native_client/src/trusted/validator_ragel/dfa_traversal.py)。
6.由Apple公司实现的[bloom过滤器](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/wtf/BloomFilter.h)。
7.[Bresenham 算法](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/libvpx/source/libvpx/vp8/common/textblit.c)。
### 编程语言库
我想这个问题值得思考。编程语言设计者们认为值得花一些工程师的时间和精力来实现这些数据结构和算法，这样其他人就不必这么做了。这些库是我们在JAVA里面比C更少的发现需要重新实现基本数据结构的部分原因。
1.[C++ STL](http://www.cplusplus.com/reference/stl/)包含了链表、栈、队列、映射、向量和[排序](http://www.cplusplus.com/reference/algorithm/)、[搜索和堆操作](http://www.cplusplus.com/reference/algorithm/)算法。
2.[Java API](http://docs.oracle.com/javase/7/docs/api/)易于扩展的并且越来越多。
3.[Boost C++ 库](http://www.boost.org/doc/libs/1_55_0/libs/algorithm/doc/html/index.html#algorithm.description_and_rationale)包含了像 Boyer-Moore以及Knuth-Morris-Pratt字符串匹配算法。
### 分配和调度算法
我发现这些很有趣，因为即使他们被称为启发式，您使用的策略规定了算法类型和需要的数据结构，因此，所以需要人们知道栈和队列。
1.最近最少使用（LRU）算法可以用不同的方法实现。Linux内核有一种[基于列表的实现](https://github.com/mirrors/linux-2.6/blob/master/include/linux/list_lru.h)。
2.其他的还有先入先出（FIFO）、最常使用和轮询。
3.FIFO的一个变种用于VAX/VMS系统。
4.[Richard Carr](http://dl.acm.org/citation.cfm?id=4750)的[时钟算法](http://en.wikipedia.org/wiki/Page_replacement_algorithm#Clock)用于Linux中的页面替换。
5.Intel i860处理器是一种随机替代策略。
6.[自适应置换高速缓存](http://en.wikipedia.org/wiki/Adaptive_Replacement_Cache)用于一些IBM存储控制器中，也曾经用于PostgreSQL中([虽然仅仅因为一些专利问题](http://www.varlena.com/GeneralBits/96.php)）。
7.Knuth在《计算机程序设计艺术 卷1》中讨论过的[Buddy内存分配算法](http://en.wikipedia.org/wiki/Buddy_memory_allocation)内用于Linux内核中，jemalloc并发分配器被用于FreeBSD和[facebook](http://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919)中。
### \*nix系统核心工具
1.*grep*和*awk*同时从正则表达式中实现NFA的Thompson-McNaughton-Yamada构造，显然[这甚至击败了Perl的实现](http://swtch.com/%7Ersc/regexp/regexp1.html)。
2.*tsort*实现了拓扑排序。
3.*fgrep*实现了[Aho-Corasick字符串匹配算法](http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm)。
4.*GNU grep*，根据作者Mike Haertel实现了[Boyer-Mooresuan算法](http://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html)。
5.Unix上的crypt(1)实现了一个在Enigma机器上的不同加密算法。
6.[*Unix diff*](http://www.cs.dartmouth.edu/%7Edoug/diff.pdf)由Doug McIllroy实现，基于和James Hunt合作编写的原形。它比用于计算Levenshtein距离的标准动态规划算法执行地更好。[Linux 版本](http://linux.die.net/man/3/diff)计算最短编辑距离。
### 加密算法
这本是一个非常长的列表。加密算法在所有执行安全通信和交易的程序中都有实现。
1.[Merkle 树](http://en.wikipedia.org/wiki/Merkle_tree)，特别是 Tiger Tree Hash变种，被用于点对点应用，比如[GTK Gnutella](https://github.com/gtk-gnutella/bitter)和[LimeWire](http://en.wikibooks.org/wiki/LimeWire)。
2.[MD5](http://en.wikipedia.org/wiki/MD5)被用于提供软件包的校验和并被用于在\*nix系统上的完整性检测([Linux 实现](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/crypto/md5.c))，同样也支持Windows和OSX。
3.[OpenSSL](http://www.openssl.org/)实现了很多加密算法包括AES、Blowfish、DES、SHA-1、SHA-2、RSA、DES等等。
### 编译器
1.[LALR 解析](http://en.wikipedia.org/wiki/LALR_parser)在yacc和bison实现。
2.支配算法被用于大多数基于SSA形式的编译器优化。
3.lex和flex将正则表达式编译为NFA。
### 压缩和图像处理
1.用于GIF图片格式的[Lempel-Ziv](http://en.wikipedia.org/wiki/Lempel_Ziv)算法在图像处理程序中实现，从\*unix工具转化到复杂的程序。
2.行程长度编码用于产生PCX文件(用于原来的画笔程序)，它是被压缩的BMP和TIFF文件。
3.小波压缩是JPEG2000的基础，所以所有生成JPEG2000文件的数码相机会支持这个算法。
4.Reed-Solomon纠错在[Linux内核](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/lib/reed_solomon/reed_solomon.c)、CD驱动器、条形码读取器、结合从Voyager中的卷积图像传输中实现。
### 冲突驱动语句学习算法 (CDCL)
自2000年以来，SAT求解器在工业标准的运行时间(通常是硬件工业，虽然其他地方也被使用)以近乎指数的方式每年下跌。这发展中很重要的一部分是冲突驱动语句学习算法，它结合了Davis Logemann和Loveland在约束规划和人工智能研究中关于语句学习的原始论文中的布尔约束传播算法。特定地，工业造型，SAT被认为是一个简单的问题([见这个讨论](http://rjlipton.wordpress.com/2009/07/13/sat-solvers-is-sat-hard-or-easy/))。对我而言，这个一个最近最好的成功故事，因为它结合了这几年算法的不断发展、清晰的工程理念、实验性的评估、齐心协力地解决一个问题。[Malik 和 Zhang的CACM文章](http://dl.acm.org/citation.cfm?id=1536637)值得阅读。这个算法在许多大学中教授(我参加过的4个地方都是如此)，但是通常在一个逻辑或者形式方法课上。
SAT求解器的应用有很多。IBM，Intel和许多其他公司都有他们的SAT求解器实现。OpenSuse的[包管理器](http://dl.acm.org/citation.cfm?id=1536637)同样使用了一个SAT求解器。
---
via: 
译者：[geekpi](https://github.com/geekpi) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创翻译，[Linux中国](http://linux.cn/) 荣誉推出