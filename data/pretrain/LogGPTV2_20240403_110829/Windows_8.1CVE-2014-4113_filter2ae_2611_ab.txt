### 3.1 设计 win32k!tagWND 结构

为了在 Windows 8.1 上利用此漏洞，我在用户模式下构造了一个伪造的 `win32k!tagWND` 结构，并为其分配了内存空间。当漏洞被触发时，`win32k!xxxSendTransformableMessageTimeout` 函数会首先读取一个64位的数据，该数据存储在偏移地址为0x10的位置。如果在这个位置提供无效数据，程序将出错。接着，程序会在偏移地址0处读取一个字节的数据，并将其作为内存地址的索引项。在该索引项指向的内存空间中存储的数据会被用来与0x01进行比较。

若我们将 `win32k!tagWND` 结构开始的两个字节设为0，那么对0x01的检查将会失败，代码执行将在调用 `win32k!xxxInterSendMessageEx` 函数时结束，前提是已经将该指针作为第一个参数传递给 `win32k!tagWND` 结构。此时，`win32k!xxxInterSendMessageEx` 函数将重新读取存储在偏移地址0x10处的指针，并尝试解引用它。该指针的作用是读取存储在0x170处的数值，并将其与 `ntoskrnl!PsGetCurrentProcessWin32Process` 函数的返回值进行比较。

我们构造 `win32k!tagWND` 结构是为了能够从用户内存中成功读取数据0x0。然后，`win32k!xxxInterSendMessageEx` 函数会从偏移地址0x2b0处读取一个字节的数据。这个数据可以是任意值，但不能包括0x20。

当所有条件满足时，程序会给 `win32k!tagWND` 结构传递一个指针参数，随后 `win32k!xxxInterSendMessageEx` 函数将调用 `win32k!IsWindowsDesktopComposed` 函数。`win32k!xxxInterSendMessageEx` 函数会从偏移地址0x10处读取一个数值。如果该数值为0，函数将返回0，表示没有解引用 `win32k!tagWND` 结构中的任何参数。

如果这些条件都满足，`win32k!xxxInterSendMessageEx` 函数将执行以下操作：尝试将RDI寄存器中的数据添加到链表尾部。该数据是一个我们无法直接控制的内核指针。代码将读取存储在 `win32k!tagWND` 结构中偏移地址0x60处的链表头，并检查其是否为空。如果为空，则将该数据设为链表的新头；否则，遍历链表直到找到插入位置，插入数据并将下一个指针的指针域设为空，覆盖RDI寄存器中的旧指针。

这段代码为我们提供了在内核空间中任意插入8个字节数据的能力。尽管我们不能直接写入该数据值（受限于系统），但这足以让我们利用CVE-2014-4113漏洞。

### 3.2 在内核空间中寻找一个覆盖目标

由于系统允许我们在内核空间中覆盖一定量的存储空间，我们需要寻找一个初始值为0的64位内核空间。当我们需要在该空间中加入数据时，系统会提升我们对内核的使用权限。此外，我们还需要从用户模式中分配一些地址到该空间中。

Cesar Cerrudo 在其文章《Easy local Windows Kernel exploitation》中提到，可以通过使用 `NtQuerySystemInformation(SystemHandleInformation)` API 函数来泄露 Windows 令牌对象的地址。该函数能让我们获得嵌套在 `SEP_TOKEN_PRIVILEGES` 结构中的地址。我的想法是：通过可控的方式，使用原始令牌来覆盖这个结构，从而向其中添加一个已认证的新权限。这样做的好处是不必担心SMEP的问题。

我们可以从标准用户的原始令牌的角度来看待 `SEP_TOKEN_PRIVILEGES` 结构。在该结构中，权限通过位掩码表示，每个权限由单个字节表示。我们感兴趣的是那些启用的位掩码字段，这些字段是 Windows 内核授予的有效特殊权限。

在 `SEP_TOKEN_PRIVILEGES` 结构中，没有连续的8个空字节空间供我们覆盖。然而，通过禁用特权，我们可以实现这一要求。首先，找到执行原始令牌的代码并修改之，降低该令牌的权限。运行结果存储在 `SEP_TOKEN_PRIVILEGES` 结构中。

可以看到，系统并没有提供8个连续的空字节空间。但我们可以通过使用 `AdjustTokenPrivileges` API 函数的 `DisableAllPrivileges` 标志位来禁用已启用的特殊权限。调用 `AdjustTokenPrivilege` 函数后，可以有效地删除所有的64位字段，并设置字段数据为0。

通过这种方式，我们现在可以覆盖之前启用的字段。但仍然无法有效控制写入的内核地址。在填写地址的过程中，可能会开启某些有趣的特权。我们的假设是：在该地址中，有两个非常显著的字节被设置为0xff。我们选择部分地覆盖这两个字节，以保证能够启用以下特权：

有很多有趣的特权，例如 `SeDebugPrivilege`。接下来，我们将演示如何启用这个特权。

### 3.3 整合所有步骤

为了成功利用 CVE-2014-4113 漏洞，我们首先需要在用户模式下分配一个伪造的 `win32k!tagWND` 结构。方法是找到偏移地址为0xfffffffb的内核空间，并使用 `ZwAllocateVirtualMemory` API 函数进行分配。在第3.1节中已经讨论过 `win32k!tagWND` 结构中的字段设置问题，在这里不再赘述。

其次，我们需要创建一个没有任何权限的令牌，并将内核地址传给 `SEP_TOKEN_PRIVILEGES` 结构中的令牌。所使用的 API 函数是 `NtQuerySystemInformation(SystemHandleInformation)`。为了使该地址指向当前字段的中部，我们需对其进行扩展。方法是以3为步长自增长。扩展完成后，在偏移地址0x60处存储该地址。以上所有操作都在我们精心设计的 `win32k!tagWND` 结构中进行。

完成以上步骤后，我们可以开始触发该漏洞。方法是使用一个任意的内核指针覆盖之前设置的那个没有权限的令牌，进而有效启用该字段。

为了使用这个新特权，我们使用 `ImpersonateLoggedOnUser` API 函数来模拟受限制的安全环境。最终，虽然我们只向系统用户进程中加入了一个 shellcode，但也能达到像 `WriteProcessMemory` 函数一样的效果。如果以上步骤都能顺利实现，系统将弹出一个界面，并提供一个带有系统权限的 shell。

### 4. 总结

上述结果是有可能实现的。例如，利用一个内核漏洞，我们可以控制类似 `win32k!tagWND` 这样的大型内核结构。测试环境是 Windows 8.1，但在 Windows 8 系统中也是可行的。

总的来说，即使系统中有安全保护机制（如 SMEP），只要能够控制系统中的内核，仅利用一个微小的漏洞就能提升用户访问内核的权限，而无需使用诸如覆盖函数指针或执行 shellcode 等方法。