**3.1 ****设计 win32k** **！ tagWND** **结构**
为了能在Windows
8.1上利用这个漏洞，我在用户模式下，构造了一个假的win32k！tagWND结构，并为其分配了内存空间。当这个漏洞被引发时，win32k!xxxSendTransformableMessageTimeout函数会率先读取一个64位的数据。该数据是存储在一个偏移地址为0x10的空间内，而win32k！tagWND结构恰好也在该内存里。程序会将其与win32k!gptiCurrent指针进行比较。如果我们在这个地方提供了一个无效数据，那么程序的运行就会出错。接下来，程序就会在偏移地址为0的地方，读取一个字节的数据，并将其作为一个内存地址的索引项。在该索引项指向的内存空间中存储着一段数据，该数据会被程序用来与数据0x01进行比对。
如果我们将win32k！tagWND结构开始的两个字节设为0，那么之后对于0x1的检查将会失败，同时代码的执行将会在调用win32k!xxxInterSendMessageEx函数时结束，前提是我们已经将这个指针作为了第一个要传给win32k！tagWND结构的参数。
这时，win32k!xxxInterSendMessageEx函数将会重新读取存储在偏移地址为0x10处的指针。该指针位于win32k！tagWND结构中；同时，它还会尝试解引该指针，之后重新读取其他指针。0x10处的指针的作用是读取一个存储在0x170处的数值，系统会将它与ntoskml!PsGetCurrentProcessWin32Process函数的返回值进行比较。
我们之所以要构造win32k！tagWND结构函数，是为了能够成功地从用户内存中读取数据0x0。接下来，win32k!xxxInterSendMessageEx函数会从偏移地址为0x2b0处读取一个字节的数据。这个数据的值是任意的，但不能包括0x20。
当以上所有条件都具备时，程序会给win32k！tagWND结构函数传递一个指针参数，接着win32k!xxxInterSendMessageEx函数就会调用win32k!IsWindowsDesktopComposed函数。
win32k!xxxInterSendMessageEx函数将会从win32k！tagWND结构中，偏移地址为0x10处读取一个数值。如果读取的数值为0，那么程序的返回值就是0，表示没有解引win32k！tagWND结构中的任何参数。
如果这些条件都满足，win32k!xxxInterSendMessageEx函数将会执行下面的代码：
这段代码在功能上实现了对一个链表的追加操作。具体操作为：尝试着将在RDI寄存器中发现的数据加到链表的表尾。这个数据实质上是一个我们无法直接控制的内核指针。这段代码将率先读取存储在win32k！tagWND结构中，偏移地址为0x60处的链表表头，同时检查表头是否为空。如果表头为空，那么该数据将会被设为链表的新表头。如果表头不为空，那么系统就会遍历整个链表直到发现一个新的链表插入位置为止，之后将数据插入，并将下一个指针的指针域设为空，之后再覆盖原来存储在RDI寄存器中的旧指针。
此段代码为我们提供了一个非常有效的，能够让我们在内核空间内任意加入8个字节的数据空间。尽管我们不能直接编写这个数据值（同时也受到系统的限制），但这样也足以能够让我们对CVE-2014-4113漏洞加以利用了。
**3.2 ****在内核空间中寻找一个覆盖目标**
**  
**
由于系统允许我们在内核空间中覆盖一定的存储空间，因而我们就在积极寻找一个初始值为0的64位内核空间。当我们需要在该空间内加入一些数据时，系统会提升我们对内核的使用权限。此外，我们还需从用户模式中分配一些地址到该空间中。
Cesar Cerrudo在他的《[Easy local Windows Kernel
exploitation](http://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernel_WP.pdf)》一文中提到：我们可以通过使用NtQuerySystemInformation（SystemHandleInformation），这个API函数，来泄露Windows令牌对象的地址。该函数能让我们获得嵌套到SEP_TOKEN_PRIVILEGES结构中的地址。我的想法是：利用某种可控的方式，使用原始令牌来覆盖这个结构，从而向其中添加一个已认证的新权限。相较于采用覆盖一个潜在指针的办法，利用这个函数的好处是：我们不必再担心SMEP的问题。
所以，我们可以从一个标准用户的原始令牌的角度出发，来看待SEP_TOKEN_PRIVILEGES这个结构
在SEP_TOKEN_PRIVILEGES结构中，以上的三个字段是用位掩码表示的。每个权限都是通过单个字节来表示。其中，我们更感兴趣的位掩码是那些已经启用的位掩码字段，那些字段是Windows内核授予的有效特殊权限。
正如我们看到的那样，在这个结构中，没有连续的8个空字节空间来让我们实现覆盖。然而，如果通过取消特权使用的方式，也许就能实现上述的要求了。
首先，我们应找到那段执行原始令牌的代码，修改之，降低该令牌的权限。
运行结果存储于下面的SEP_TOKEN_PRIVILEGES结构中：
我们可以看到，系统并没有给我们提供8个连续的空字节空间。但是，我们可通过使用AdjustTokenPrivileges这个API函数的DisableAllPrivileges标志位，来禁用已经启用的特殊权限。
在调用AdjustTokenPrivilege函数后，我们可以有效地删除所有的64位字段，并设置字段数据为0。
通过这种方式，现在我们可以覆盖之前启用的字段了。但是，我们还是不能有效地控制被写入的内核地址。在填写地址的过程中，可能还会开启某些有趣的特权。然而，我们不能使用那样的方法。我们关于内核地址安全性的假设是：在该地址中，有两个非常显著的字节被设置为了0xff。我们选择部分地覆盖这两个字节，以保证能够开启以下特权：
这其中有很多有趣的特权，比如：SeDebugPrivilege。接下来，我们将会演示这个特权的提示过程。
**3.3 ****整合所有步骤**
**  
**
为了能够成功地利用CVE-2014-4113漏洞，我们首先需要让程序分配一个假的win32k！tagWND结构。分配方法是：在用户模式下，找到偏移地址为0xfffffffb的内核空间，使用ZwAllocateVirtualMemoryAPI函数进行分配。在3.1节中，我们已经讨论过win32k！tagWND结构中的字段设置问题了，在这里就不再赘述。
其次，我们需在启用权限的字段上，创建一个没有任何权限的令牌，并将内核地址传给SEP_TOKEN_PRIVILEGES结构中的令牌。所使用到的API函数是：NtQuerySystemInformation（SystemHandleInformation）。之后，为了让该地址能够指向当前字段的中部，我们需对该地址进行扩展。方法是：以3为步长，进行自增长。扩展完成后，在偏移地址为0x60处存储该地址。以上所有的操作都是在我们精心设计的win32k！tagWND结构中进行的。
在以上步骤完成后，我们就可以开始引发该漏洞了。引发的方法是：使用一个任意的内核指针，覆盖之前设置的那个没有权限的令牌，进而能够有效地启用该字段。
为了使用这个新特权，我们使用ImpersonateLoggedOnUser，这个API函数来模拟受到限制的安全环境。最终，虽然我们只向系统用户进程中加入了一个shellcode，但也能达到像Windows.exe进程调用WriteProcessMemory函数一样的效果。如果以上步骤都能顺利实现，那么系统会弹出如下的一个界面，并向我们提供一个带有系统权限的shell。这样的话，就大功告成了。
**  
**
**4. ****总结**
**  
**
以上出现的结果是有可能实现的。比如：利用一个内核漏洞，就能够让我们实现控制类似于win32k！tagWND这样的大型内核结构。上述测试过程的测试环境是Windows
8.1，但在Windows 8系统中也是可行的。
总的来说，即使系统中有安全保护机制的存在（比如：SMEP），但只要能够控制系统中的内核，仅仅利用一个微小的漏洞，你就能提升用户访问内核的权限，而不再需要使用诸如覆盖函数指针或执行shellcode等类似方法。