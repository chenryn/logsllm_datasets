n
u
o
r
t
s
a
c
i
t
l
u
m
0
1
/
)
s
m
(
e
m
T
i
1000
100
10
3
4
5
7
6
10
Number of group members
8
9
11
12
1
3
4
5
7
6
10
Number of group members
8
9
11
12
s
d
n
u
o
r
t
s
a
c
i
t
l
u
m
0
1
/
)
s
m
(
e
m
T
i
(c) Overhead of the extra mes-
sages in reliable multicast
(d) Cost of cryptography in
reliable multicast
Figure 2. Performance results for reliable multi-
cast and total ordering
note that for all key sizes, there is a sharp increase in time
for completion for group sizes 7 and 10. This is because 7
and 10 are of the form 3f + 1, and the number of faults be-
ing tolerated changes at those group sizes. Thus, when the
group size changes from 6 to 7, the number of faults toler-
ated, (cid:6)(n − 1)/3(cid:7), goes from 1 to 2. Correspondingly, the
number of replies4 that the sender of a message digest has to
wait to collect before sending the message (2f + 1) changes
from 3 to 5. There is a similar change when the group size
goes from 9 to 10. The ﬁgure also shows that increasing
key size causes additional overheads. The differences be-
come more pronounced for higher group sizes, because the
message trafﬁc increases, so that more messages need to be
processed for the same number of multicast rounds.
As mentioned before, the efﬁciency of the total-ordering
protocol depends on the closeness of the match between
the chosen sequence-number-generating functions and the
actual trafﬁc.
In the measurement application, the group
members generate similar trafﬁc. The default generating
function (see Section 2.3) is a good ﬁt for that application.
Therefore, the total-ordering scheme has low overhead, as
can be seen from Figure 2(b). The total-ordering protocol
slows down the delivery of messages because it forces the
faster processes to wait for the slower ones. If some pro-
cess is very slow compared to others, null messages are
4The sender counts his own signature as one reply, so the number of
messages it waits for is actually 2 and 4 respectively.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:28:00 UTC from IEEE Xplore.  Restrictions apply. 
exchanged, causing additional overhead. Finally, there is
some slowdown due to the fact that every message deliv-
ered has to go through an extra protocol in the stack.
The cost of reliable multicast can be broken down into
two parts. The ﬁrst part of the cost is introduced by the
cryptographic functions. The other part is caused by the ex-
change of extra messages needed before the actual message
can be sent. To isolate that overhead, the time taken by the
application when using the mnak-no total stack was com-
pared to the time taken when using the reliable-no total-
dummy crypt stack. We expected the increase in cost to be
less than threefold, because the two additional control mes-
sages that must be exchanged in order to authenticate the
message are small and don’t need the same delivery guar-
antees that a regular message needs. (The difference can be
seen in Figure 2(c).) We thereby obtained a lower bound on
the overhead of using the intrusion-tolerant reliable delivery
protocol relative to the cost of using the crash-tolerant mnak
protocol.
The performance costs due to the use of cryptography
are shown in Figure 2(d), which compares running times
for the application using only the reliable protocol with and
without 1024-bit RSA cryptography. We see a 1 to 2 orders
of magnitude difference between the performances depend-
ing upon group size. Such results were expected, because
of the high computational costs of public-key cryptography.
3.2 Results for Group Membership
This section presents results that show the cost of ex-
cluding a corrupt member or members from the group when
faults occur. We injected faults at one or more group mem-
bers. For the purpose of these experiments, a correct group
member is one that has not been fault-injected. A corrupt
group member is one at which a fault has been injected.
A group member has detected a fault when it has received
f +1 Suspect messages for that corrupt member. The mem-
ber then starts the view installation protocol described in
Section 2.4. At each correct member, we take time mea-
surements whenever a fault has been detected and whenever
a new view excluding all known corrupt members has been
installed. The elapsed time is the time taken for the view
installation. The average of these times across all correct
group members is the presented time for view installation
for that particular group size. We study the time taken for
view installation when more than one group member was
corrupted, when the injected faults are activated at different
phases of transitional views, and when fault detection does
or does not involve time-out mechanisms.
The scenario we use to quantify the cost of removing cor-
rupt group members is as follows. Each process is started
with the same group name and the same target group size.
The group membership protocol ensures that all processes
join a single group. When the group size reaches the target
group size, each process starts multicasting messages to all
the members in the group. After a ﬁxed number of rounds of
message multicast, one or more members are injected with
one of the following three types of faults:
1. Crash, causing the corrupted process to kill itself,
2. Mutant message, in which the corrupted process sends
two messages with same sequence number but with
different contents, or
3. Impede Total Ordering,
in which the total order-
ing layer in the corrupted process does not send
the required null messages (see Section 2.3) when
application-level multicasts are stopped.
The faults are detected in different ways. For crash
faults, if heartbeat messages have not been received from
a group member for more than a speciﬁed time, the group
member is suspected to have crashed. Mutant messages are
identiﬁed by the reliable multicast protocol. For Impede
Total Ordering faults, the total-ordering protocol at correct
members ﬁnds that neither application-level messages nor
null messages have been received from a member for more
than a speciﬁed time, and reports the suspected member to
the group membership protocol.
A group whose size is greater than 6 processes can tol-
erate two simultaneous faults (we call such faults double
faults). To quantify the cost of tolerating two faults, we in-
ject a crash fault at one of the non-leader processes, and one
of the faults in Table 1 at the leader process. When a view
installation is initiated to exclude the crashed process from
the group, a fault at the leader process is activated, so as to
impede the view installation. The fault at the leader will be
detected by the time-out mechanisms described in Section
2.4 and result in a transitional view.
A group whose size is greater than 9 processes can tol-
erate three simultaneous faults (we call such faults triple
faults). For groups larger than 9, we inject a crash fault
into one of the group members, inject one of the faults in
Table 1 at the leader, and inject one of the faults in Table
1 at the deputy. When a view installation to remove the
crashed member is initiated, the fault at the leader becomes
activated, causing that view installation to become a transi-
tional view. The deputy is supposed to start a new round of
view installation. The fault at the deputy becomes activated
during this round, resulting in another transitional view. A
new protocol stack will be installed at the correct members
in the group only when the deputy’s deputy becomes the
leader and starts the view installation procedure.
Figure 3 shows the view installation times for three pro-
tocol stacks:
gmp-reliable-total: This is the Ensemble stack with the
new intrusion-tolerant microprotocols for providing
group membership, reliable multicast, and total order-
ing. This stack uses the normal cryptography func-
tions.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:28:00 UTC from IEEE Xplore.  Restrictions apply. 
Table 1. Faults injected during a view installation to make it a transitional view
Fault
Bad New-View
Fault Activation Point Description
start of PHASE1
New-View Time-out
Bad Commit
start of PHASE1
start of PHASE2
Commit Time-out
Ready-to-Switch Time-out
start of PHASE2
end of PHASE2
Impede Stabilization
PHASE3
Leader sends a New-View message with insufﬁcient justiﬁcation (less than f + 1
signed suspects)
Leader does not send a New-View message after receiving f + 1 suspects
Leader sends a Commit message with insufﬁcient justiﬁcation (less than 2f + 1
signed Ack-New-Views)
Leader does not send a Commit message after receiving 2f + 1 Ack-New-Views
Process does not send a Ready-to-Switch after receiving a valid Commit exclud-
ing all known corrupt members
Process claims to have received a high sequence number that was never mul-
ticast. When it does not rebroadcast that message for a sufﬁciently long time,
other members start suspecting it.
gmp-reliable-total
gmp-reliable-total-dummy-crypt
C-Ensemble
10000
1000
100
10
)
s
m
(
e
m
T
i
10000
1000
100
10
)
s
m
(
e
m
T
i
gmp-reliable-total
gmp-reliable-total-dummy-crypt
C-Ensemble
1
3
4
5
6
7
8
9
10
11
12
Number of group members
1
3
4
5
6
7
8
9
10
11
12
Number of group members
(a) View installation time for
single crash fault
(b) View installation time for
double crash faults
Figure 3. Comparing gmp-reliable-total, gmp-
reliable-total-dummy crypt, & C-Ensemble stacks
gmp-reliable-total-dummy crypt: This
stack includes
the same microprotocols as the ﬁrst stack, but has a
dummy version of the cryptographic library. This stack
does not provide intrusion tolerance.
C-Ensemble: This is the original C version of Ensemble
[13], tolerant only to crash faults.
We compare the view installation times for the above
three stacks in the presence of a single crash fault or mul-
tiple simultaneous crash faults, because the original C-
Ensemble can handle only crash faults.
Figure 3(a) shows the comparison for the single crash
fault case. Figure 3(b) shows the comparison for the double
faults case, where two non-leader processes in the group are
injected with crash faults. From Figures 3(a) and 3(b), we
see that the time difference for view installation between C-
Ensemble and the gmp-reliable-total stacks is two orders
of magnitude, and becomes higher with increasing group
sizes. This is because of the multiple rounds of message ex-
change and use of public key cryptography. The increase in
the view installation time with increase in the group size
is very low in the C-Ensemble stack, on the order of a
few milliseconds. In the gmp-reliable-total-dummy crypt
stack, the increase is on the order of a few tens of millisec-
onds. That increase is particularly pronounced in the gmp-
reliable-total stack, when moving from group size 6 to 7,
and from 9 to 10. That is because the number of messages
that need to be collected and processed before progression
)
s
m
(
e
m
T
i
1800
1600
1400
1200
1000
800
600
400
200
0
gmp−reliable−total : 
Crash
Impede Total Ordering
gmp−reliable−total−dummy−crypt : 
Crash
Impede Total Ordering
3
4