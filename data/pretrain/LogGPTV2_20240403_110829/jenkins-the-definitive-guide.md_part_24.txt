administrators, and can be very useful for certain critical build jobs.
221
Figure 8.26. Receiving notification via SMS
8.13. Making Noise
If you have your Jenkins instance running on a machine that is physically located in proximity to the
development team, you may also want to add sounds into the mix of notification strategies. This can be
an effective strategy for small co-located teams, though it becomes trickier if the build server is set up
on a virtual machine or elsewhere in the building.
There are two ways to integrate audio feedback into your build process in Jenkins: the Jenkins Sounds
plugin and the Jenkins Speaks plugin. Both can be installed via the Plugin Manager page in the usual
manner.
The Jenkins Sounds plugin is the most flexible of the two. It allows you to build a detailed notification
strategy based on the latest build result and also (optionally) on the previous build result as well (see
Figure 8.27, “Configuring Jenkins Sounds rules in a build job”). For example, you can configure Jenkins
to play one sound the first time a build fails, a different sound if the build fails a second time, and yet
another sound when the build is fixed.
222
Figure 8.27. Configuring Jenkins Sounds rules in a build job
To set this up, you need to tick the Jenkins Sounds checkbox in the Post-build Actions section of your
build job configuration page. You can add as many sound configuration rules as you like. Adding a rule
is simple enough. First, you need to choose which build result will trigger the sound. You also need
to specify the previous build results for which this rule is applicable: Not Build (NB), Aborted (Ab),
Failed (Fa), Unsuccessful (Un) or Successful (Su).
The Jenkins Sounds plugin proposes a large list of pre-defined sounds, which usually offer plenty of
choice for even the most discerning build administrator, but you can add your own to the list if you
really want to. Sounds are stored as a ZIP or JAR file containing sound files in a flat directory structure
(i.e., no subdirectories). The list of sounds proposed by the plugin is simply the list of filenames, minus
the extensions. The plugin supports AIFF, AU, and WAV files.
In the System Configuration page, you can give Jenkins a new sound archive file, using the http://
notation if your sound archive file is available on a local web server, or the file:// notation if
it is available locally (see Figure 8.28, “Configuring Jenkins Sounds”). Once you have saved the
configuration, you can test the sounds in your sound archive via the Test Sound button in the Advanced
section.
Figure 8.28. Configuring Jenkins Sounds
The Jenkins Sounds plugin is an excellent choice if you want to complement your more conventional
notification techniques. Short, recognizable sounds are a great way to grab a developer’s attention and
let the team know that something needs fixing. They will then be a bit more receptive when the more
detailed notifications follow.
Another option is the Jenkins Speaks plugin. With this plugin, you can get Jenkins to broadcast a
customized announcement (in a very robotic voice) when your build fails (see Figure 8.29, “Configuring
Jenkins Speaks”). You can configure the exact message using Jelly. Jelly is an XML-based scripting
language used widely in the lower levels of Jenkins.
223
Figure 8.29. Configuring Jenkins Speaks
The advantage of this approach lies in it’s precision: since you can use Jenkins variables in the Jelly
script, you can get Jenkins to say just about anything you want about the state of the build. Here is a
simple example:
Your attention please. Project ${build.project.name} has failed
 again
If you leave this field blank, the plugin will use a default template that you can configure in the System
Configuration page. In fact, it is usually a good idea to do this, and only to use a project-specific script
if you really need to.
The disadvantage is that the robotic voice can make it a little hard to understand. For this reason, it
is a good idea to start your announcement with a generic phrase such as “Your attention please,” or
to combine it with the Jenkins Sounds plugin, so that you have developers’ attention before the actual
message is broadcast. Using hyphens in your project names (e.g., game-of-life rather then gameoflife)
will also help the plugin know how to pronounce your project names.
Both these approaches are useful for small teams, but can be limited for larger ones, when the server is
not physically located in close proximity to the development team. Future versions may support playing
sounds on a separate machine, but at the time of writing this feature was not available.
8.14. Extreme Feedback Devices
Many more imaginative notification tools and strategies exist, and there is plenty of scope for
improvisation if you are willing to improvise with electronics a little. This includes devices such as
Ambient Orbs, Lava Lamps, traffic lights, or other more exotic USB-controlled devices. The Build
Radiator (see Section 8.6, “Build Radiators”) also falls into this category if you project it onto a big
enough screen.
One device that integrates very nicely with Jenkins is the Nabaztag. The Nabaztag (see Figure 8.30, “A
Nabaztag”) is a popular WiFi-enabled robotic rabbit that can flash colored lights, play music, or even
speak. Once advantage of the Nabaztag is that, since it works via WiFi, it is not constrained to be located
224
near the build server, and so will work even if your Jenkins instance is in a server room or on a virtual
machine. As far as extreme feedback devices go, these little fellows are hard to beat.
Figure 8.30. A Nabaztag
And best of all, there is a Jenkins plugin available for the Nabaztag. Once you have installed the Nabaztag
plugin and restarted Jenkins, it is easy to configure. In Jenkins’s main Configuration page, go to the
Global Nabaztag Settings section and enter the serial number and secret token for your electronic bunny
(see Figure 8.31, “Configuring your Nabaztag”). You can also provide some default information about
how your build bunny should react to changes in build status (should it report on starting and successful
builds, for example), what voice it should use, and what message it should say when a build fails,
succeeds, is fixed, or fails again. Then, to activate Nabaztag notification for a particular build job,
you need to tick the Nabaztag Publisher option in your build job configuration. Depending on your
environment, for example, you may or may not want all of your builds to send notifications to your
Nabaztag.
225
Figure 8.31. Configuring your Nabaztag
With the notable exception of the build radiator, many of these devices have similar limitations to the
Jenkins Speaks and Jenkins Sounds plugins (see Section 8.13, “Making Noise”)—they are best suited
for small, co-located teams, working on a limited number of projects. Nevertheless, when they work,
they can be a useful addition to your general notification strategy.
8.15. Conclusion
Notification is a vital part of your overall CI strategy. After all, a failed build is of little use if there is no
one listening. Nor is notification a one-size-fits-all affair. You need to think about your organization,
and tailor your strategy to suite the local corporate culture and predominant tool set.
Indeed, it is important to define and implement a well thought-out notification strategy that suits your
environment. Email, for example, is ubiquitous, so this will form the backbone of many notification
strategies, but if you work in a larger team or with a busy technical lead, you may want to consider
setting up an escalation strategy based on the advanced email options (see Section 8.3, “More Advanced
Email Notification”). But you should complement this with one of the more active strategies, such as
instant messaging or a desktop notifier. If your team already uses a chat or IRC channel to communicate,
try to integrate this into your notification strategy as well. And SMS notification is a great strategy for
really critical build jobs.
You should also ensure that you have both passive and active (or pull and push) notification strategies.
A prominent build radiator or an extreme feedback device, for example, sends a strong message to the
team that fixing builds is a priority task, and can help install a more agile team culture.
226
Chapter 9. Code Quality
9.1. Introduction
Few would deny the importance of writing quality code. High quality code contains less bugs, and is
easier to understand and easier to maintain. However, the precise definitions of code quality can be more
subjective, varying between organizations, teams, and even individuals within a team.
This is where coding standards come into play. Coding standards are rules, sometimes relatively
arbitrary, that define the coding styles and conventions that are considered acceptable within a team or
organization. In many cases, agreeing on a set of standards, and applying them, is more important than
the standards themselves. Indeed, one of the most important aspects of quality code is that it is easy to
read and to understand. If developers within a team all apply the same coding standards and practices,
the code will be more readable, at least for members of that team. And if the standards are commonly
used within the industry, the code will also be more readable for new developers arriving on the team.
Coding standards include both aesthetic aspects such as code layout and formatting, naming
conventions, and so forth, as well as potentially bad practices such as missing curly brackets after a
condition in Java. A consistent coding style lowers maintenance costs, makes code clearer and more
readable, and makes it easier to work on code written by other team members.
Only an experienced developer can really judge code quality in all its aspects. That is the role of code
reviews and, among other things, practices like pair programming. In particular, only a human eye can
decide if a piece of code is truly well written, and if it actually does what the requirements ask of it.
However, code quality metrics tools can help a great deal. In fact it is unrealistic to try to enforce coding
standards without the use of such tools.
These tools analyze your application source code or byte code, and check whether the code respects
certain rules. Code quality metrics can encompass many aspects of code quality, from coding standards
and best practices right through to code coverage, with everything from compiler warnings to TODO
comments in between. Certain metrics concentrate on measurable characteristics of your code base,
such as the number of lines of code (NLOC), average code complexity, or the number of lines per class.
Others focus on more sophisticated static analysis, or on looking for potential bugs or poor practices
in your code.
There are a wide range of code quality reporting plugins available for Jenkins. Many are for Java static
analysis tools, such as Checkstyle, PMD, FindBugs, Cobertura, and JDepend. Others, such as fxcop and
NCover, are focused on .NET applications.
With all of these tools, you need to configure your build job to generate the code quality metrics data
before Jenkins can produce any reports.
The notable exception to this rule is Sonar. Sonar can extract code quality metrics from any Maven
project, with no additional configuration required in your Maven project. This is great when you have
large numbers of existing Maven projects that you need to integrate into Jenkins, and you want to
configure consistent code quality reporting across all of your projects.
In the rest of this chapter, we will see how to set up code quality reporting in your Jenkins builds, and
also how you can use it as an effective part of your build process.
9.2. Code Quality in Your Build Process
Before we look at how to report on code quality metrics in Jenkins, it can be useful to take a step back
and look at the larger picture. Code Quality metrics are of limited value in isolation—they need to be
part of a broader process improvement strategy.
The first level of code quality integration should be the IDE. Modern IDEs have great support for
many code quality tools—Checkstyle, PMD, and FindBugs all have plugins for Eclipse, NetBeans, and
IntelliJ, which provide rapid feedback for developers on code quality issues. This is a much faster and
more efficient way to provide feedback for individual developers, and to teach developers about the
organizational or project coding standards.
The second level is your build server. In addition to your normal unit and integration test build jobs, set
up a dedicated code quality build, which runs after the normal build and test. The aim of this process is
to produce project-wide code quality metrics, to keep tabs on how the project is doing as a whole, and
to address any issues from a high level. The effectiveness of these reports can be increased by a weekly
code quality review, in which code quality issues and trends are discussed within the team.
It is important to run this job separately, because code coverage analysis and many static analysis tools
can be quite slow to run. It is also important to keep any code coverage tests well away from builds, as
the code coverage process produces instrumented code which should never be deployed to a repository
for production use.
Code quality reporting is, by default, a relatively passive process. No one will know the state of the
project if they don’t seek out the information on the build server. While this is better than nothing, if
you are serious about code quality, there is a better way. Rather than simply reporting on code quality,
set up a dedicated code quality build, which runs after the normal build and test, and configure the build
to fail if code quality metrics are not at an acceptable level. You can do this in Jenkins or in your build
script, although one advantage of configuring this outside of your build script is that you can change
code quality build failing criteria more easily without changing the project source code.
As a final word, remember that coding standards are guidelines and recommendations, not absolute rules.
Use failing code quality builds and code quality reports as indicators of a possible area of improvement,
not as measurements of absolute value.
228
9.3. Popular Java and Groovy Code Quality Analysis
Tools
There are many open source tools that can help identify poor coding practices.
In the Java world, three static analysis tools have stood the test of time, and are widely used in
very complementary ways. Checkstyle excels at checking coding standards and conventions, coding
practices, as well as other metrics such code complexity. PMD is a static analysis tool similar to
Checkstyle, more focused on coding and design practices. And FindBugs is an innovative tool issued
from the ongoing research work of Bill Pugh and his team at the University of Maryland that focuses
on identifying potentially dangerous and buggy code. And if you are working with Groovy or Grails,
you can use CodeNarc, which checks Groovy coding practices and convention.
All of these tools can be easily integrated into your build process. In the following sections, we will look
at how to set up these tools to generate the XML reports that Jenkins can then use for its own reporting.
9.3.1. Checkstyle
Checkstyle1 is a static analysis tool for Java. Originally designed to enforce a set of highly-configurable
coding standards, Checkstyle now also lets you check for poor coding practices, as well as overly
complex and duplicated code. Checkstyle is a versatile and flexible tool that should have its place in
any Java-based code quality analysis strategy.
Checkstyle supports a very large number of rules, including ones relating to naming conventions,
annotations, javadoc comments, class and method size, code complexity metrics, poor coding practices,
and many others.
Duplicated code is another important code quality issue—duplicated or near-duplicated code is harder
to maintain and to debug. Checkstyle provides some support for the detection of duplicated code, but
more specialized tools such as CPD do a better job in this area.
One of the nice things about Checkstyle is how easy it is to configure. You can start off with the Sun
coding conventions and tweak them to suit your needs, or start from scratch. Using the Eclipse plugin (or
even directly in XML), you can pick and choose from several hundred different rules, and fine-tune the
settings of the rules you do choose (see Figure 9.1, “It is easy to configure Checkstyle rules in Eclipse”).
This is important, as different organizations, teams and even projects have different requirements and
preferences with regards to coding standards, and it is better to have a precise set of rules that can be
adhered to, rather than a broad set of rules that will be ignored. It is especially important where large
legacy code bases are involved—in these cases, it is often better to start off with a more limited set of
rules than to be overwhelmed with a large number of relatively minor formatting issues.
1 http://checkstyle.sourceforge.net
229
Figure 9.1. It is easy to configure Checkstyle rules in Eclipse
Configuring Checkstyle in your build is usually straightforward. If you are using Ant, you need to
download the checkstyle JAR file from the website2 and make it available to Ant. You could place it
in your Ant lib directory, but this would mean customizing the Ant installation on your build server
(and any slave nodes), so it is not a very portable solution. A better approach would be to place the
Checkstyle JAR file in one of your project directories, or to use Ivy or the Maven Ant Task library
to declare a dependency on Checkstyle. If you opt for keeping the Checkstyle JAR file in the project
directories, you could declare the Checkstyle task as shown here:
Then, to generate Checkstyle reports in an XML format that Jenkins can use, you could do the following:
Now, just invoke this task (e.g., ant checkstyle) to generate the Checkstyle reports.
2 http://checkstyle.sourceforge.net
230
In Maven 2, you could add something like the following to the  section:
org.apache.maven.plugins
maven-checkstyle-plugin
2.4
src/main/config/company-checks.xml
For a Maven 3 project, you need to add the plugin to the  element of the
 section of the maven-site-plugin:
http://buildserver.acme.org:9000
...
...
org.apache.maven.plugins
maven-site-plugin
3.0-beta-2