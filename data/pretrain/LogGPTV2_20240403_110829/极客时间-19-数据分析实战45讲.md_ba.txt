# 得到图像尺寸width, height = img.size这里会使用 PIL 这个工具包，它的英文全称叫 Python ImagingLibrary，顾名思义，它是 Python 图像处理标准库。同时我们也使用到了skimage 工具包（scikit-image），它也是图像处理工具包。用过 Matlab的同学知道，Matlab 处理起图像来非常方便。skimage可以和它相媲美，集成了很多图像处理函数，其中对不同分类标识显示不同的颜色。在Python 中图像处理工具包，我们用的是 skimage 工具包。这节课没有太多的理论概念，主要讲了 K-Means聚类工具，数据规范化工具，以及图像处理工具的使用，并在图像分割中进行运用。其中涉及到的工具包比较多，你需要在练习的时候多加体会。当然不同尺寸的图像，K-Means运行的时间也是不同的。如果图像尺寸比较大，你可以事先进行压缩，长宽在 200像素内运行速度会比较快，如果超过了 1000 像素，速度会很慢。![](Images/efcf3f6fe9e9b28b5c4b47d4a59f5a63.png){savepage-src="https://static001.geekbang.org/resource/image/5a/99/5a3f0dfaf5e6aaca1e96f488f8a10999.png"}\今天我讲了如何使用 K-Means聚类做图像分割，谈谈你使用的体会吧。另外我在[GitHub](https://github.com/cystanford/kmeans/blob/master/baby.jpg)上上传了一张baby.jpg 的图片，请你编写代码用 K-Means 聚类方法将它分割成 16 个部分。链接：欢迎在评论区与我分享你的答案，也欢迎点击"请朋友读"，把这篇文章分享给你的朋友或者同事。![](Images/8b75105190797b2e4f7be2536b6543db.png){savepage-src="https://static001.geekbang.org/resource/image/48/96/48cb89aa8c4858bbc18df3b3ac414496.jpg"}
# 28丨EM聚类（上）：如何将一份菜等分给两个人？今天我来带你学习 EM 聚类。EM 的英文是 Expectation Maximization，所以 EM算法也叫最大期望算法。我们先看一个简单的场景：假设你炒了一份菜，想要把它平均分到两个碟子里，该怎么分？很少有人用称对菜进行称重，再计算一半的分量进行平分。大部分人的方法是先分一部分到碟子A 中，然后再把剩余的分到碟子 B 中，再来观察碟子 A 和 B里的菜是否一样多，哪个多就匀一些到少的那个碟子里，然后再观察碟子 A 和 B里的是否一样多......整个过程一直重复下去，直到份量不发生变化为止。你能从这个例子中看到三个主要的步骤：初始化参数、观察预期、重新估计。首先是先给每个碟子初始化一些菜量，然后再观察预期，这两个步骤实际上就是期望步骤（Expectation）。如果结果存在偏差就需要重新估计参数，这个就是最大化步骤（Maximization）。这两个步骤加起来也就是EM 算法的过程。![](Images/115cd6268df2fb05ca63f0ff9bf74d00.png){savepage-src="https://static001.geekbang.org/resource/image/91/3c/91f617ac484a7de011108ae99bd8cb3c.jpg"}
## EM 算法的工作原理说到 EM 算法，我们先来看一个概念"最大似然"，英文是 MaximumLikelihood，Likelihood 代表可能性，所以最大似然也就是最大可能性的意思。什么是最大似然呢？举个例子，有一男一女两个同学，现在要对他俩进行身高的比较，谁会更高呢？根据我们的经验，相同年龄下男性的平均身高比女性的高一些，所以男同学高的可能性会很大。这里运用的就是最大似然的概念。``{=html}最大似然估计是什么呢？它指的就是一件事情已经发生了，然后反推更有可能是什么因素造成的。还是用一男一女比较身高为例，假设有一个人比另一个人高，反推他可能是男性。最大似然估计是一种通过已知结果，估计参数的方法。那么 EM 算法是什么？它和最大似然估计又有什么关系呢？EM算法是一种求解最大似然估计的方法，通过观测样本，来找出样本的模型参数。再回过来看下开头我给你举的分菜的这个例子，实际上最终我们想要的是碟子 A和碟子 B中菜的份量，你可以把它们理解为想要求得的**模型参数**。然后我们通过 EM算法中的 E 步来进行观察，然后通过 M 步来进行调整 A 和 B的参数，最后让碟子 A 和碟子 B 的参数不再发生变化为止。实际我们遇到的问题，比分菜复杂。我再给你举个一个投掷硬币的例子，假设我们有A 和 B 两枚硬币，我们做了 5 组实验，每组实验投掷 10次，然后统计出现正面的次数，实验结果如下：![](Images/68a465bdebee2a4b61b2b0ea700afdda.png){savepage-src="https://static001.geekbang.org/resource/image/c8/e4/c8b3f2489735a21ad86d05fb9e8c0de4.png"}\投掷硬币这个过程中存在隐含的数据，即我们事先并不知道每次投掷的硬币是 A还是 B。假设我们知道这个隐含的数据，并将它完善，可以得到下面的结果：![](Images/e13900be481efc0505cae78e2542a2d6.png){savepage-src="https://static001.geekbang.org/resource/image/91/0d/91eace1de7799a2d2d392908b462730d.png"}\我们现在想要求得硬币 A 和 B 出现正面次数的概率，可以直接求得：![](Images/7d8e02b639c7af60a1b10a1d69c2350a.png){savepage-src="https://static001.geekbang.org/resource/image/51/d8/51ba3cc97ed9b786f4d95f937b207bd8.png"}而实际情况是我不知道每次投掷的硬币是 A 还是 B，那么如何求得硬币 A 和硬币B 出现正面的概率呢？这里就需要采用 EM 算法的思想。1\. 初始化参数。我们假设硬币 A 和 B 的正面概率（随机指定）是θA=0.5和θB=0.9。2\. 计算期望值。假设实验 1 投掷的是硬币 A，那幺正面次数为 5 的概率为：![](Images/9350d88d5bc6fdfbaf975486782a3b84.png){savepage-src="https://static001.geekbang.org/resource/image/09/e0/09babe7d1f543d6ff800005d556823e0.png"}\公式中的 C(10,5) 代表的是 10 个里面取 5个的组合方式，也就是排列组合公式，0.5 的 5 次方乘以 0.5 的 5次方代表的是其中一次为 5 次为正面，5 次为反面的概率，然后再乘以 C(10,5)等于正面次数为 5 的概率。假设实验 1 是投掷的硬币 B ，那幺正面次数为 5 的概率为：![](Images/f4feabeab420efd4b35f6ee7d6eff335.png){savepage-src="https://static001.geekbang.org/resource/image/7b/f6/7b1bab8bf4eecb0c55b34fb8049374f6.png"}\所以实验 1 更有可能投掷的是硬币 A。然后我们对实验 2\~5重复上面的计算过程，可以推理出来硬币顺序应该是{A，A，B，B，A}。这个过程实际上是通过假设的参数来估计未知参数，即"每次投掷是哪枚硬币"。3\. 通过猜测的结果{A, A, B, B, A}来完善初始化的参数θA 和θB。然后一直重复第二步和第三步，直到参数不再发生变化。简单总结下上面的步骤，你能看出 EM 算法中的 E步骤就是通过旧的参数来计算隐藏变量。然后在 M步骤中，通过得到的隐藏变量的结果来重新估计参数。直到参数不再发生变化，得到我们想要的结果。
## EM 聚类的工作原理上面你能看到 EM算法最直接的应用就是求参数估计。如果我们把潜在类别当做隐藏变量，样本看做观察值，就可以把聚类问题转化为参数估计问题。这也就是EM 聚类的原理。相比于 K-Means 算法，EM 聚类更加灵活，比如下面这两种情况，K-Means会得到下面的聚类结果。![](Images/2aaac0b29433475c27efb9c4f4cf80d3.png){savepage-src="https://static001.geekbang.org/resource/image/ba/ca/bafc98deb68400100fde69a41ebc66ca.jpg"}\因为 K-Means是通过距离来区分样本之间的差别的，且每个样本在计算的时候只能属于一个分类，称之为是硬聚类算法。而EM聚类在求解的过程中，实际上每个样本都有一定的概率和每个聚类相关，叫做软聚类算法。你可以把 EM 算法理解成为是一个框架，在这个框架中可以采用不同的模型来用EM 进行求解。常用的 EM 聚类有 GMM 高斯混合模型和 HMM隐马尔科夫模型。GMM（高斯混合模型）聚类就是 EM聚类的一种。比如上面这两个图，可以采用 GMM 来进行聚类。和 K-Means一样，我们事先知道聚类的个数，但是不知道每个样本分别属于哪一类。通常，我们可以假设样本是符合高斯分布的（也就是正态分布）。每个高斯分布都属于这个模型的组成部分（component），要分成K 类就相当于是 K个组成部分。这样我们可以先初始化每个组成部分的高斯分布的参数，然后再看来每个样本是属于哪个组成部分。这也就是E 步骤。再通过得到的这些隐含变量结果，反过来求每个组成部分高斯分布的参数，即 M步骤。反复 EM 步骤，直到每个组成部分的高斯分布参数不变为止。这样也就相当于将样本按照 GMM 模型进行了 EM 聚类。![](Images/344c19d6556357520f9f61d4317e8297.png){savepage-src="https://static001.geekbang.org/resource/image/18/3b/18fe6407b90130e5e4fa74467b1d493b.jpg"}
## 总结EM 算法相当于一个框架，你可以采用不同的模型来进行聚类，比如GMM（高斯混合模型），或者 HMM（隐马尔科夫模型）来进行聚类。GMM是通过概率密度来进行聚类，聚成的类符合高斯分布（正态分布）。而 HMM用到了马尔可夫过程，在这个过程中，我们通过状态转移矩阵来计算状态转移的概率。HMM在自然语言处理和语音识别领域中有广泛的应用。在 EM 这个框架中，E 步骤相当于是通过初始化的参数来估计隐含变量。M步骤就是通过隐含变量反推来优化参数。最后通过 EM 步骤的迭代得到模型参数。在这个过程里用到的一些数学公式这节课不进行展开。你需要重点理解 EM算法的原理。通过上面举的炒菜的例子，你可以知道 EM算法是一个不断观察和调整的过程。通过求硬币正面概率的例子，你可以理解如何通过初始化参数来求隐含数据的过程，以及再通过求得的隐含数据来优化参数。通过上面 GMM 图像聚类的例子，你可以知道很多 K-Means 解决不了的问题，EM聚类是可以解决的。在 EM框架中，我们将潜在类别当做隐藏变量，样本看做观察值，把聚类问题转化为参数估计问题，最终把样本进行聚类。![](Images/dcb92b28dcac7df6708c2d71bccfa2cf.png){savepage-src="https://static001.geekbang.org/resource/image/d8/80/d839e80d911add15add41163fa03ee80.png"}\最后给你留两道思考题吧，你能用自己的话说一下 EM 算法的原理吗？EM 聚类和K-Means 聚类的相同和不同之处又有哪些？欢迎你在评论区与我分享你的答案，也欢迎点击"请朋友读"，把这篇文章分享给你的朋友或者同事，一起来交流。![](Images/8b75105190797b2e4f7be2536b6543db.png){savepage-src="https://static001.geekbang.org/resource/image/48/96/48cb89aa8c4858bbc18df3b3ac414496.jpg"}
# 29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分今天我来带你进行 EM 的实战。上节课，我讲了 EM 算法的原理，EM算法相当于一个聚类框架，里面有不同的聚类模型，比如 GMM高斯混合模型，或者 HMM 隐马尔科夫模型。其中你需要理解的是 EM的两个步骤，E 步和 M 步：E 步相当于通过初始化的参数来估计隐含变量，M步是通过隐含变量来反推优化参数。最后通过 EM步骤的迭代得到最终的模型参数。今天我们进行 EM 算法的实战，你需要思考的是：-   如何使用 EM 算法工具完成聚类？-   什么情况下使用聚类算法？我们用聚类算法的任务目标是什么？-   面对王者荣耀的英雄数据，EM 算法能帮助我们分析出什么？
## 如何使用 EM 工具包在 Python 中有第三方的 EM 算法工具包。由于 EM算法是一个聚类框架，所以你需要明确你要用的具体算法，比如是采用 GMM高斯混合模型，还是 HMM 隐马尔科夫模型。这节课我们主要讲解 GMM 的使用，在使用前你需要引入工具包：     from sklearn.mixture import GaussianMixture 我们看下如何在 sklearn 中创建 GMM 聚类。首先我们使用 gmm = GaussianMixture(n_components=1,covariance_type='full', max_iter=100) 来创建 GMM聚类，其中有几个比较主要的参数（GMM类的构造参数比较多，我筛选了一些主要的进行讲解），我分别来讲解下：``{=html}1.n_components：即高斯混合模型的个数，也就是我们要聚类的个数，默认值为1。如果你不指定 n_components，最终的聚类结果都会为同一个值。2.covariance_type：代表协方差类型。一个高斯混合模型的分布是由均值向量和协方差矩阵决定的，所以协方差的类型也代表了不同的高斯混合模型的特征。协方差类型有4 种取值：-   covariance_type=full，代表完全协方差，也就是元素都不为 0；-   covariance_type=tied，代表相同的完全协方差；-   covariance_type=diag，代表对角协方差，也就是对角不为 0，其余为 0；-   covariance_type=spherical，代表球面协方差，非对角为    0，对角完全相同，呈现球面的特性。3.max_iter：代表最大迭代次数，EM 算法是由 E 步和 M步迭代求得最终的模型参数，这里可以指定最大迭代次数，默认值为 100。创建完 GMM 聚类器之后，我们就可以传入数据让它进行迭代拟合。我们使用 fit 函数，传入样本特征矩阵，模型会自动生成聚类器，然后使用prediction=gmm.predict(data)来对数据进行聚类，传入你想进行聚类的数据，可以得到聚类结果 prediction。你能看出来拟合训练和预测可以传入相同的特征矩阵，这是因为聚类是无监督学习，你不需要事先指定聚类的结果，也无法基于先验的结果经验来进行学习。只要在训练过程中传入特征值矩阵，机器就会按照特征值矩阵生成聚类器，然后就可以使用这个聚类器进行聚类了。
## 如何用 EM 算法对王者荣耀数据进行聚类了解了 GMM 聚类工具之后，我们看下如何对王者荣耀的英雄数据进行聚类。首先我们知道聚类的原理是"人以群分，物以类聚"。通过聚类算法把特征值相近的数据归为一类，不同类之间的差异较大，这样就可以对原始数据进行降维。通过分成几个组（簇），来研究每个组之间的特性。或者我们也可以把组（簇）的数量适当提升，这样就可以找到可以互相替换的英雄，比如你的对手选择了你擅长的英雄之后，你可以选择另一个英雄作为备选。我们先看下数据长什么样子：![](Images/f0a46e559c1a4d0d6fb80ea9d9c6a55b.png){savepage-src="https://static001.geekbang.org/resource/image/3c/a0/3c4e14e7b33fc211f96fe0108f6196a0.png"}\这里我们收集了 69 名英雄的 20个特征属性，这些属性分别是最大生命、生命成长、初始生命、最大法力、法力成长、初始法力、最高物攻、物攻成长、初始物攻、最大物防、物防成长、初始物防、最大每5 秒回血、每 5 秒回血成长、初始每 5 秒回血、最大每 5 秒回蓝、每 5秒回蓝成长、初始每 5 秒回蓝、最大攻速和攻击范围等。具体的数据集你可以在 GitHub上下载：。现在我们需要对王者荣耀的英雄数据进行聚类，我们先设定项目的执行流程：![](Images/a59d4ba830d25df0b3f89484da685a98.png){savepage-src="https://static001.geekbang.org/resource/image/8a/78/8af94562f6bd3ac42036ec47f5ad2578.jpg"}1.  首先我们需要加载数据源；2.  在准备阶段，我们需要对数据进行探索，包括采用数据可视化技术，让我们对英雄属性以及这些属性之间的关系理解更加深刻，然后对数据质量进行评估，是否进行数据清洗，最后进行特征选择方便后续的聚类算法；3.  聚类阶段：选择适合的聚类模型，这里我们采用 GMM    高斯混合模型进行聚类，并输出聚类结果，对结果进行分析。按照上面的步骤，我们来编写下代码。完整的代码如下：    
# -*- coding: utf-8 -*-import pandas as pdimport csvimport matplotlib.pyplot as pltimport seaborn as snsfrom sklearn.mixture import GaussianMixturefrom sklearn.preprocessing import StandardScaler 
# 数据加载，避免中文乱码问题data_ori = pd.read_csv('./heros7.csv', encoding = 'gb18030')features = [u'最大生命',u'生命成长',u'初始生命',u'最大法力', u'法力成长',u'初始法力',u'最高物攻',u'物攻成长',u'初始物攻',u'最大物防',u'物防成长',u'初始物防', u'最大每 5 秒回血', u'每 5 秒回血成长', u'初始每 5 秒回血', u'最大每 5 秒回蓝', u'每 5 秒回蓝成长', u'初始每 5 秒回蓝', u'最大攻速', u'攻击范围']data = data_ori[features] 