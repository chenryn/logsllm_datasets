图芯GPU驱动程序。这个驱动来自Etnaviv项目，在GitHub上可以找到这
个项目的更多子项目[2]。
14.4.4 TI TMS34010
20世纪80年代和90年代的PC浪潮，让人们意识到了显卡的重要
性。也令很多半导体公司都不禁思考：“我们是不是也应该做显卡？”德
州仪器（Texas Instruments，TI）是老牌的半导体公司，它也曾投身显
卡领域，而且出手不凡，早在1986年就发布了领先于时代的可编程显卡
芯片，名叫TMS34010图形系统处理器，简称TMS34010。
TMS34010内部包含了一个完整的32位处理器，这个处理器支持很
多面向图形操作的指令，比如在二维位图上画曲线，以及对像素数据做
各种算术运算等。TMS34010也支持普通的CPU指令，可以运行标准C编
译器编译出的程序。用今天的话来说，TMS34010集CPU和GPU于一
身，与多年后的英特尔Larabee有些相似。
图14-2所示的TMS34010系统框图来自TI官方的TMS34010产品手册
（Specification），其中虚线框起来的部分就是TMS34010芯片，左侧与
主CPU交互，右侧与内存、显存以及显示器交互。
图14-2 TMS34010系统框图[3]
TMS34010推出后，曾在街机游戏（Arcade game）领域有一些应
用。从1988年到1995年，有十几种街机游戏支持TMS34010。PC端的3D
游戏走红后，TMS34010逐渐没落了。
14.5 学习资料和工具
CPU的时代正在悄然落幕，GPU的时代正在开启。这样说并不意味
着我们不再需要CPU，只是说它不再是热点，不再有蓬勃发展的机会。
而GPU则像一个刚出道的明星，活力四射。也可以说GPU领域像一块新
大陆，很多领地等待开垦。
在本书第三篇结束前，特别推荐一些学习资料和工具，分三个类别
（文档、源代码和工具），各推荐三种。
14.5.1 文档
不管你是否一定用CUDA，都值得读一下《PTX ISA手册》，感觉
这个手册是懂开发的人写给开发者看的。这个手册的前三章特别值得细
读。在10多页的篇幅中，作者以精湛的语言解说了GPU编程的基本特征
和关键概念。第4章介绍PTX指令的语法。第5章介绍GPU程序的状态空
间，包括寄存器、参数、常量、共享内存和全局内存。第9章篇幅最
长，介绍指令集和每一条指令。
《CUDA C编程指南》（《CUDA C Programming Guide》）也是非
常宝贵的学习资料，它的篇幅也是300余页，不过只有前100页是正文
（分5章），后面都是附录。第1章是简介，对背景稍作介绍。第2章涉
及编程模型，介绍了算核、线程组织结构和内存组织结构等重要概念。
第3章名为“编程接口”，介绍了nvcc编译器、CUDA运行时库，以及计算
模式等。第4章名为“硬件实现”，介绍了单指令多线程（SIMT）架构，
以及硬件和线程并行模型。第5章对如何提高性能给出了一些基本的指
导意见。
上面两个资料都是偏向软件的，如果希望多了解一些硬件细节，那
么经典的G965手册是最好的入门资料。第11章曾经反复提到过这个手
册，它分为4卷，比较系统地涵盖了现代GPU的四大功能：显示、
2D/3D、媒体和GPGPU。第4卷的EU部分最值得细读。
14.5.2 源代码
有人说，源代码就是非常好的文档。这句话虽然有失偏颇，但是读
源代码确实也是一种高效的学习方式。直接读技术手册难免枯燥，而且
不知哪里是实，哪里是虚。看了代码后，很多理论就落到了实处。
首先，CUDA工具包里包含很多的示例程序，包含完整的源代码和
项目文件，很容易编译和执行。建议试着运行感兴趣的例子，再中断到
调试器，然后结合调试器里的状态信息理解源代码。
其次，英特尔和AMD在GitHub上的开源项目都是宝贵的学习资
源，这些在前面各章分别提到过。如果希望深入理解GPU编译器的工作
原理，那么英特尔开源的几个编译器是优秀的资料。如果希望理解GPU
调试器的工作原理，那么可以结合本书ROCm GDB的内容阅读它的源代
码。
如果希望理解GPU驱动程序的细节，那么VirtualBox开源代码中包
含了比较完整的GPU驱动源代码，有Windows版本，也有Linux版本，
有KMD，也有UMD。特别是Windows版本很宝贵，因为大多数显卡厂
商都不公开Windows版本的驱动源代码。
14.5.3 工具
阅读文档和源代码都容易疲倦。与实践结合可以让学习过程变得生
动而有趣。建议选择一个硬件平台，安装好必要的驱动程序和工具，然
后一边学习理论，一边实践。
首先推荐CUDA工具集中的Nsight，第9章曾反复提到过这个工具。
它以IDE插件的形式工作，既支持Visual Studio，也支持Eclipse。Nsight
提供了一系列调试、错误检查和优化功能。它既支持传统的图形调试，
也支持CUDA调试。它的CUDA调试功能稳定强大，是学习CUDA和理
解GPGPU的有力助手。
在安装好Visual Studio的环境中，安装CUDA工具包（CUDA
Toolkit），安装好后启动Visual Studio，就有Nsight菜单了。打开CUDA
工具包中的一个示例项目，比如曼德罗（Mandelbrot）分形图形程序。
选择一个算核函数，按F9键在其中设置一个断点，单击Nisght→Start
CUDA Debugging就可以调试了。片刻之后，断点命中，大量的GPU细
节呈现在眼前，如图14-3所示。
图14-3中，左侧偏上是反汇编窗口，只要使用Visual Studio的菜单
（调试→窗口→反汇编）就可以将其调出，其中同时显示了CUDA C源
程序、PTX中间指令和SASS硬件汇编三种语言的代码，很适合对照学
习。中间是寄存器窗口，可以观察硬件寄存器的情况。右侧偏上是著名
的CUDA Info窗口，可以打开多个实例，观察多种信息，图中显示的是
WARP状态，每行描述一个WARP。CUDA Info窗口下面是GPU程序的
栈回溯，反映了GPU函数的调用经过。再看下面的两个窗口，左侧是局
部变量窗口，除了应用程序自己定义的变量外，还包括CUDA的内置变
量；右侧是断点管理窗口。
图14-3 在Nsight中理解CUDA和GPU
对于Linux环境或者需要远程调试的场景，CUDA-GDB是个很好的
选择。CUDA-GDB具有Nsight的大多数调试功能，包括断点、跟踪和观
察各类信息。这曾在第9章介绍过，在此不再细谈了。
正如本书多次提及的，今天GPU还严重依赖CPU。很多逻辑都与
CPU端的代码有着这样那样的联系。因此，理解CPU端的软件栈也很重
要。WinDBG和GDB是这方面的强大武器，本书后续分卷将详细介绍这
两个工具。
14.6 本章小结
本章旨在对前面5章分开介绍的内容加以总结，让读者的思路从分
散状态聚合起来，实现GPU篇的“总分合”结构：开始有总论，中间有分
论，最后再汇合到一起。
本篇内容是专为本书第2版新增的。写作这部分书稿的实际工作量
远远超出了最初的估计，导致出版计划多次延期。如果这部分内容可以
帮助读者在GPU时代占据领先位置，那么延期也是值得的。
参考资料
[1] VideoCore IV 3D Architecture Reference Guide.
[2] Open Source drivers for Vivante GPU's.
[3] TMS34010 Product Specs.
第四篇 可调试性
前面两篇分别探讨了CPU和GPU的调试设施，其中有些用于调试硬
件本身，有些用于调试上层软件。
无论是硬件还是软件，当它的复杂度较高时，它的可调试性就变得
非常重要。概言之，一个硬件或者软件部件的可调试性
（debuggability）就是指它容易被调试的程度，或者说当这个部件发生
故障时，调试人员可以多方便或多快地寻找到问题的根源。如果上升到
成本和费用的层次，那么可调试性就是调试这个部件所需成本的倒数。
调试代价越高，可调试性越差；调试代价越低，可调试性越好。第15章
将详细讨论可调试性的内涵、外延和衡量标准。
如果把软件或者硬件故障比喻成“灾害”，则提高它的可调试性就是
增强它抵御灾害的能力。在如何应对灾害方面，古人留给我们一个非常
好的成语：未雨绸缪。这个成语源于我国最早的诗歌总集《诗经》，其
中有一首著名的寓言诗《鸱鸮（chī xiāo）》，原诗如下。
鸱鸮
鸱鸮鸱鸮，既取我子，无毁我室。恩斯勤斯，鬻（yù）子之闵斯。
迨天之未阴雨，彻彼桑土，绸缪（móu）牖（yǒu）户。今女下
民，或敢侮予？
予手拮据，予所捋荼。予所蓄租，予口卒瘏，曰予未有室家。
予羽谯谯，予尾翛翛，予室翘翘。风雨所漂摇，予维音哓哓！
这首诗以一只被猫头鹰（鸱鸮）夺去幼鸟的母鸟的口气叙述了它重
建鸟巢时的所想和所感：“猫头鹰夺取了我的幼鸟，再不能毁坏我的鸟
巢。我辛苦养育（鬻）儿女，已经病（闵）了。趁着天还未阴雨，我啄
取桑根，缚紧（绸缪）巢的缝隙（牖本指窗，户指门）……”
未雨绸缪的道理对计算机系统的开发也是适用的，它告诉我们应该
在设计阶段就为调试做好准备，否则等故障出现了，就会措手不及，甚
至为时晚矣！这种在设计时就考虑调试的思想经常称为Design For
Debug（DFD）或Design Better, Debug Faster。
对于较大型的项目，要做到DFD并不单单是某个角色（比如程序
员）的事情，它需要整个团队所有成员的共同努力。这是提高可调试性
的一个重要原则。要把提高可调试性纳入到计算机项目的每个环节当
中，使其成为所有团队成员的目标。第16章将详细讨论如何在项目中贯
穿可调试性思想，提高整个项目的可调试性。
硬件的可调试性和软件的可调试性是有关联的，常常是相互影响
的。从实现的方法来看，很多原则也是通用的。本篇侧重讨论可调试性
的一般原则，为了行文方便，当难以兼顾软硬件两者时，多以软件为例
展开讨论。
第15章 可调试性概览
本章将先介绍软件可调试性的概念（见15.1节）和意义（见15.2
节），然后讨论实现可调试性的基本原则（见15.3节）。15.4节将从反
面讨论不可调试代码对可调试性的危害，15.5节将分析Windows系统中
所包含的可调试设计，15.6节将探讨在实现可调试性时应该注意的问
题。
15.1 简介
在计算机硬件领域，人们很早就开始重视系统的可调试性。以著名
的UNIVAC计算机为例，系统内部有专门的错误检测电路，控制面板上
有多个提示错误的指示灯，操作手册有对这些设施的详细介绍。通过这
些设施，人们可以很方便地了解内部电路或元器件的状态，如果出现故
障，可以比较迅速地找到原因并排除故障。人们把这些支持检修和调试
的设计统称为Design For Test或Design For Testability（DFT）。这里的
测试一词（Test）显然包含了调试（Debug）的含义，于是逐渐地有人
开始使用Design For Debug或Design For Debuggability（DFD）来称呼可
调试设计。
随着大规模集成电路的出现，人们开始更加重视可调试性。很多芯
片设计厂商开始在芯片中加入支持调试的机制，并着手建立行业标准，
以便让多个芯片组成的系统也具有很好的可调试性。1990年，多家厂商
联合制定了JTAG标准并得到IEEE的批准，并从此得到业界的广泛接受
（详见7.1.2节）。
2005年6月13日，DFD联盟（Design-for-Debug Consortium）成立，
其宗旨就是要解决集成芯片领域的调试（silicon debug）问题。DFD联
盟的成员包括Corelis公司、DAFCA公司、First Silicon Solutions（FS2）
公司、Intellitech公司、JTAG Technologies公司、Fidel Muradali公司和
Novas Software公司等。
从以上介绍可以看到，在电子、电路和芯片设计生产等领域，可调
试设计已经发展多年，并且得到了广泛的重视，应用得也比较好。在今
天的很多集成芯片中，都可以找到调试支持，比如JTAG扫描和
BIST（Built-In Self Test）。
与硬件领域相比，软件方面的可调试性还没有得到足够的重视。从
行业标准角度来看，目前尚没有专门针对提高软件可调试性的标准，有
关的两个标准如下[1]。
DMTF（Distributed Management Task Force）组织发起的公共诊断
模型（Common Diagnostic Model，CDM）。CDM是对DMTF的
CIM（WMI的基础）的扩展，旨在指导软件实现标准的诊断支持，
以便可以通过统一的方式发现和执行诊断功能，提取诊断信息。
DMTF的基于Web的企业管理（Web-Based Enterprise Management）
标准，简称WBEM，这个标准不是专门针对调试设计的，但是其中
的分布式管理方法有利于收集软件的执行状态，提高软件的可调试
性。
从工具角度来看，尽管以下方面的努力已经持续了很久，但是软件
领域中还没有像硬件领域中诸如示波器和分析仪那样成熟的工具来测量
软件。目前使用的方法主要有以下两类。
程序插桩（program instrumentation），即通过向程序中加入测量代
码（instrumented code）来收集软件的执行路径和状态信息，以实
现观察、记录和寻找错误（调试）等目标。插入测量代码的方法有
在编译期插入和在执行期动态插入等多种方法。
采样（sampling），即先通过工具软件在被分析软件运行的环境中
收集事件样本，统计其在某个时间段内的活动资料，比如内存分配
和释放及执行轨迹等，然后使用这些资料来发现内存使用方面的问
题或寻找运行为调优（Tuning）提供信息。采样可以使用操作系统
提供的事件追踪设施，也可以使用CPU提供的监视功能，比如第5
章介绍的分支记录和性能监视机制。
从工程实践的角度来看，目前最有效的还是在设计软件中规划出支
持调试的各种机制，并将其实现在软件代码中。这也是本篇重点讨论的
方向——在软件开发过程中考虑并实现软件的可调试性。