# CVE-2021-1732 Windows10 本地提权漏洞复现及详细分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 00 前言
CVE-2021-1732 是蔓灵花（BITTER）APT 组织在某次被披露的攻击行动中使用的 0day 漏洞，该 **高危**
漏洞可以在本地将普通用户进程的权限提升至最高的 SYSTEM 权限。受到该漏洞影响的 Windows
版本众多[1]，原始利用代码经过少量修改后甚至可以在（当时的）最新版 Windows 10 20H2 64 位全补丁环境进行提权。漏洞的利用样本最早在
2020 年 12 月 10 号就被安恒威胁情报中心捕获到[2]，在其与 MSRC 的通力合作下，今年 2 月初，MSRC 将漏洞修复。
目前在 github 上公布的可用 EXP 主要有两个版本，分别由 Kernel Killer[3] 和 KaLendsi[4] 编写，本文将使用
**前者** 的 EXP 来做分析和调试（Windows 版本为 Windows 10 Version **1809** for
x64）。其本人也在看雪论坛发布了 EXP 开发的相关文章[5]（与 github 仓库中的 pdf 内容相同），本文会对 EXP
作者文章的技术细节进行补充，并对 EXP 代码进行近乎逐行的分析、注释。
接下来，我会用最详尽的方式带你从零认知到完全理解 CVE-2021-1732。如果你正打算入门 Windows
内核，那么这篇文章将会给你提供一些静态分析及动态调试的技巧，如果你是这方面的老师傅，也欢迎对我说错的地方批评指正。总之，要是能在某些方面帮到你的话，就再好不过了。
* * *
## 01 漏洞综述
###  1.1 漏洞成因
用户态进程 p 在调用 CreateWindowEx 创建带有 **扩展内存** 的 Windows 窗口时，内核态图形驱动 win32kfull.sys
模块的 xxxCreateWindowEx 函数会通过 nt!KeUserModeCallback 回调机制调用用户态函数
user32!_xxxClientAllocWindowClassExtraBytes，其向内核返回用户态创建的窗口扩展内存。该返回值如何解释，由窗口对应
tagWND 结构体的 dwExtraFlag 字段规定。如果 dwExtraFlag 包含 0x800 属性，则返回值被视作
**相对内核桌面堆起始地址的偏移** 。攻击者可以 hook user32!_xxxClientAllocWindowClassExtraBytes
函数，通过一些手段使得 dwExtraFlag 包含 0x800 属性，然后直接调用 ntdll!NtCallbackReturn
向内核返回一个任意值。回调结束后，dwExtraFlag 不会被清除，未经校验的返回值直接被用于堆内存寻址（桌面堆起始地址 +
返回值），引发内存越界访问。随后攻击者通过一些巧妙的构造及 API 封装，获得内存越界读写能力，最后复制 system 进程的 Token 到进程 p
完成提权。
总的来说，漏洞是由 win32kfull!xxxCreateWindowEx 函数内一处由用户态回调导致的 flag 位设置与对应偏移设置不同步所导致的。
###  1.2 漏洞及攻击样本特点[2]
  * 攻击目标为最新版 Windows 10 操作系统 
    * 1.在野样本攻击的是当时最新版 Windows10 1909 64 位操作系统（在野样本的编译时间为 2020 年 5 月）
    * 2.在野样本适配了从 Windows10 1709 到 Windows10 1909 多个版本，且会只在 Windows10 1709 及以上版本中运行利用代码
    * 3.原始利用代码经过少量修改后可在（当时的）最新版 Windows10 20H2 64 位全补丁环境进行提权
  * 漏洞质量高，利用手法精湛，稳定性好，动态检测难度大 
    * 1.在野样本借助漏洞绕过了最新版 Windows 10 系统的内核地址空间布局随机化（KASLR）
    * 2.本次漏洞不同于以往的 Win32k 漏洞，漏洞类型不是 UAF，整个利用过程不涉及堆喷射和内存重用，Type Isolation 缓解机制对其无效。在野样本在打开 DriverVerifier 验证器的情况下依然可以正常提权，无法通过开启内核池追踪检测到，动态检测难度大
    * 3.在野样本的任意地址写入采用了漏洞特性结合 SetWindowLong 系列函数的手法，令人眼前一亮
    * 4.在野样本借助 GetMenuBarInfo 实现任意地址读取，这种手法此前未被公开过，这体现出开发者精湛的利用编写水平
    * 5.在野样本在构造出任意地址读写原语后，采用 DataOnlyAttack 的方式替换了当前进程的 Token，目前的内核缓解机制无法防御此类攻击
    * 6.在野样本的漏洞利用成功率几乎为 100%
    * 7.在野样本在完成利用后，将相关内核结构全部还原，整个过程不会对系统造成蓝屏影响，工作稳定
  * 使用谨慎，隐蔽性好 
    * 1.在野样本在进行漏洞利用前对特定杀毒软件进行了检测
    * 2.在野样本对当前操作系统版本进行了判断，低于 Windows 10 1709 版本的系统不会调用漏洞利用函数
    * 3.在野样本从 2020 年 5 月完成编译，到 2020 年 12 月被发现，中间至少存活了 7 个月，这说明使用者在使用该漏洞时相当谨慎，间接体现出捕获此类隐蔽性样本的难度
###  1.3 受影响的系统版本
Windows Server, version 20H2 (Server Core Installation)  
Windows 10 Version 20H2 for ARM64-based Systems  
Windows 10 Version 20H2 for 32-bit Systems  
Windows 10 Version 20H2 for x64-based Systems  
Windows Server, version 2004 (Server Core installation)  
Windows 10 Version 2004 for x64-based Systems  
Windows 10 Version 2004 for ARM64-based Systems  
Windows 10 Version 2004 for 32-bit Systems  
Windows Server, version 1909 (Server Core installation)  
Windows 10 Version 1909 for ARM64-based Systems  
Windows 10 Version 1909 for x64-based Systems  
Windows 10 Version 1909 for 32-bit Systems  
Windows Server 2019 (Server Core installation)  
Windows Server 2019  
Windows 10 Version 1809 for ARM64-based Systems  
Windows 10 Version 1809 for x64-based Systems  
Windows 10 Version 1809 for 32-bit Systems  
Windows 10 Version 1803 for ARM64-based Systems  
Windows 10 Version 1803 for x64-based Systems
###  1.4 漏洞利用效果
平台：Windows 10 Version 1809 for x64
* * *
## 02 漏洞复现
###  2.1 制作 Win10 1809 虚拟机
首先自然是需要一个 Win10 操作系统镜像，在 [MSDN 工具站](https://msdn.itellyou.cn) 上找到这个镜像并下载：
使用 VMware 创建一个新的虚拟机：
注册码不用填，选择一个要安装的版本，并另外注册一个非 admin 用户：
完成配置之前，需要注意，不论你的电脑配置有多好，请将 **处理器数和核心数都设置为 1** ，以排除多核复杂性对后面动态调试造成影响：
内存的话给个 2G 就行了，内存给得越大，快照的拍摄和还原就会越慢。之后就是等待 Win10 安装完毕。
###  2.2 编译 exp
使用 Visual Studio 2019 创建一个新项目，选择 Windows 桌面向导，下一步：
取个项目名 ExploitTest：
应用程序类型选择 **桌面应用程序** ，并勾选空项目：
从 Kernel Killer 的 Github 仓库[3] 获取 CVE-2021-1732_Exploit.cpp，在 VS
侧面的源文件处右击，添加一个 **现有项** ，选择刚下载的 CVE-2021-1732_Exploit.cpp：
这里切换成 Debug x64：
双击打开 CVE-2021-1732_Exploit.cpp，然后 项目 -> ExploitTest 属性，再次确认配置的是 Debug x64：
将 C/C++ -> 优化 -> 优化 设置为 **禁用** ：
将 C/C++ -> 代码生成 -> 运行库 设置为 **多线程调试（MTd）** ，将运行库静态链接到可执行文件中，否则在虚拟机中运行时可能会报找不到
dll 的错。
将 链接器 -> 调试 -> 生成调试信息 设置为 **生成经过优化以共享和发布的调试信息（/DEBUG:FULL）** ，这是为了后面用 ida 加载
pdb 时有符号。
将 链接器 -> 高级 -> 随机基址 设置为 **否（/DYNAMICBASE:NO）** ，固定基址 设置为 **是（/FIXED）**
，这是为了动调的时候方便下断点。
**应用** 后选择上方的 生成 -> 生成解决方案，生成好后就能在项目所在的文件夹下看到一个 x64 文件夹：
进入其中的 Debug 文件夹，就能看到生成的 exe 和 pdb 了：
###  2.3 提权复现
将 ExploitTest.exe 拷贝到虚拟机中，再拷贝一个 64 位的
[ProcessExplorer](https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer) 到虚拟机桌面：
**右键以管理员身份运行** ProcessExplorer，在上方空白处右键 -> Select Columns，勾选上 Integrity
Level，这样就能看到进程的权限了：
**拍摄快照** （这里务必拍摄快照，方便之后回退）后，双击运行 ExploitTest.exe，查看进程权限：
在命令行界面按任意键让程序继续执行，再看进程权限，已提升为 system：
可能一次不能成功（也有可能直接蓝屏），这个时候恢复一下快照，再重新尝试运行即可。
* * *
## 03 漏洞原理分析
###  3.1 Windows 桌面程序编程
这个部分是为没有进行过/不太熟练 Windows 桌面应用开发的读者而写的，我会用尽可能少的篇幅来让读者快速上手桌面开发 API
以及一些相关的结构体。如果你已经知晓了结构体 WNDCLASSEX 的 cbWndExtra 字段的作用，以及其与
GetWindowLong/SetWindowLong 系列 API 配合的含义，那么你可以选择跳到下个部分去。
和 **2.2 节** 操作相同，使用 Visual Studio 2019 创建一个桌面应用程序的空项目，切换成 Debug
x64，在左侧源文件处右击，添加一个新建项，命名为 main.cpp，将下面的代码复制进去：
    #include 
    /* 窗口类的窗口过程函数(负责消息处理) */
    LRESULT CALLBACK MyWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) 
    {
        switch (message)
        {
            case WM_RBUTTONDOWN:    // #define WM_RBUTTONDOWN 0x0204 - 代表鼠标右键按下
                MessageBox(hWnd, L"Right Button Down Detected", L"Message Arrival", MB_OK); // 简单弹个对话框
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam); // 对其他消息都使用默认方式处理
        }
        return 0;
    }
    /* 程序入口点 */
    int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
        _In_opt_ HINSTANCE hPrevInstance,
        _In_ LPWSTR    lpCmdLine,
        _In_ int       nCmdShow)
    {
        HWND hwnd;    // 创建窗口函数 CreateWindowEx 会返回一个窗口句柄，这里定义下，用来接收这个句柄
        MSG msg;      // 消息结构体，在消息循环的时候需要
        WNDCLASSEX wndclass = { 0 }; // 创建窗口类结构体
        /* 对窗口类的各属性进行初始化 */
        wndclass.cbSize = sizeof(WNDCLASSEX);     // 字段 cbSize 需要等于结构体 WNDCLASSEX 的大小
        wndclass.style = CS_HREDRAW | CS_VREDRAW; // 窗口类风格 - 窗口水平/竖直方向的长度变化时重绘整个窗口
        wndclass.lpfnWndProc = MyWndProc;         // 窗口消息处理函数 - 这里使用上面声明的 MyWndProc
        wndclass.hInstance = hInstance;           // 该窗口类的窗口消息处理函数所属的应用实例 - 这里就使用 hInstance
        wndclass.lpszClassName = L"TestWndClass"; // 窗口类名称
        /* 注册窗口类 */
        RegisterClassEx(&wndclass);
        /* 创建窗口 */
        hwnd = CreateWindowEx(
            NULL,                              // 扩展窗口风格
            L"TestWndClass",                   // 窗口类名
            L"Hello World",                    // 窗口标题
            WS_OVERLAPPEDWINDOW | WS_VISIBLE,  // 窗口风格
            CW_USEDEFAULT,                     // 窗口左上角 x 坐标 - 这里使用默认值
            CW_USEDEFAULT,                     // 窗口左上角 y 坐标 - 这里使用默认值
            CW_USEDEFAULT,                     // 窗口宽度 - 这里使用默认值
            CW_USEDEFAULT,                     // 窗口高度 - 这里使用默认值
            NULL,                              // 父窗口句柄
            NULL,                              // 菜单句柄
            hInstance,                         // 窗口句柄
            NULL                               // 该值会传递给窗口 WM_CREATE 消息的一个参数
        );
        /* 消息循环 */
        while (GetMessage(&msg, hwnd, NULL, 0))
        {
            TranslateMessage(&msg);   // 翻译消息
            DispatchMessage(&msg);    // 派发消息
        }
        return msg.wParam;