employs stealth techniques that shield the breakpoints from
detection and/or countermeasures, and (d) it is constructed
to be portable and can be plugged into an existing debug-
ger with ease. These features make VAMPiRE the ﬁrst, and a
very powerful breakpoint framework speciﬁcally tailored to
combat malware that is increasingly becoming hardened to
analysis.
3. Design and Implementation
Our goal in designing and implementing VAMPiRE was
twofold. First, it should be able to provide unlimited break-
points to be set on code, data and I/O with the same precision
as hardware breakpoints. Second, the breakpoints should be
undetectable and impossible to circumvent. This section de-
scribes how VAMPiRE achieves these capabilities. We begin
with an overview of the framework. We follow that by a de-
tailed discussion on how VAMPiRE provides stealth break-
points. Finally, we discuss the framework API.
Breakpoints under VAMPiRE are realized through a com-
bination of virtual memory, single-stepping, TSS (for appli-
cable processors) and simple stealth techniques. The basic
idea involves breakpoint triggering by manipulation of mem-
ory page attributes of the underlying virtual memory system
(for code, data or memory-mapped I/O breakpoints) and I/O
port access control bits in the TSS (for legacy I/O break-
points). Note that virtual memory and single-stepping are
common to most if not all processor architectures and, a TSS
(or an equivalent) is typically found on processors support-
ing legacy I/O such as the IA-32 (and compatible) proces-
sors. Figure 1 illustrates the architecture of VAMPiRE in its
current version.
Figure 1. VAMPiRE Architecture
The core of the framework is composed of a page-fault
handler (PFH), a general protection fault handler (GPFH), a
single-step handler and a framework API. The PFH provides
breakpoints to be set on code, data and memory-mapped I/O
while the GPFH provides legacy I/O breakpoint support. A
debugger employing VAMPiRE interacts with the framework
through its API to set and/or remove breakpoints at desired
locations. Every breakpoint has an associated callback (pro-
vided by the debugger), a function to which control is trans-
ferred upon breakpoint triggering.
When a breakpoint triggers, the framework fault handlers
(PFH or GPFH) receive control, determine the type of break-
point (by employing a disassembler) and invoke the callback
to do the processing and resume execution. The single-step
handler is employed by the framework for breakpoint per-
sistence, a feature that allows a breakpoint to re-trigger au-
tomatically in the future. A breakpoint under VAMPiRE can
be persistent (re-triggerable) or non-persistent (one-shot) and
can be active or inactive at any instant. VAMPiRE uses a
breakpoint-table — a memory structure speciﬁc to the frame-
work — to maintain a list of breakpoints set using the frame-
work. The information stored in the breakpoint-table is used
to identify a breakpoint (and its callback) during breakpoint
triggering and processing.
3.2. Breakpoint Triggering for Code, Data and
Memory-Mapped I/O
VAMPiRE uses the virtual memory system of the un-
derlying platform to provide breakpoints on code, data and
Disassembler(ProcessorAbstraction)Page FaultHandler(PFH)General ProtectionFault Handler(GPFH)BreakpointTableSingle Step HandlerOperating System AbstractionVampireAPIDebuggerInteractionDebuggerCallbacksBreakpointTriggeringResumeExecutionmemory-mapped I/O. Support for virtual memory on most
processors, is in the form of page directories and page ta-
bles. The memory addressing space is divided into chunks
of equal size elements called a page. (typically 4K or 8K
bytes in size). Pages can have various attributes such as
read, read/write, present, not-present, user,
supervisor etc. These attributes along with a page-fault
exception is used to provide virtual memory support and
memory protection.
A page-fault exception is generated by the underlying pro-
cessor when a reference to a page is inconsistent with the
page attributes (e.g. a write is issued to a location in the ref-
erenced page, while the page attribute is readonly). The
OS normally installs a handler for the page-fault exception,
which implements a paging algorithm, provides protection
and other features such as copy-on-write etc. VAMPiRE in-
stalls its PFH (pseudo-code shown in Figure 2), replacing and
chaining to the existing handler to implement breakpoints on
code, data and memory-mapped I/O.
Figure 2. VAMPiRE PFH
To set a breakpoint (code, data or memory-mapped I/O)
at the desired memory location, VAMPiRE sets the at-
tribute of the page corresponding to the memory location
to not-present. This results in a page-fault exception
when any location is referenced in that page. When VAM-
PiRE’s PFH gets control it obtains the linear-address of the
fault (this is passed to the handler by the processor) and de-
termines the page corresponding to the linear-address. The
PFH then performs a check to determine if the page corre-
sponding to the linear-address contains any active break-
points. If not, the PFH applies a clock patch (if applica-
ble) to hide its processing latency from the malware (see
Section 3.6) and chains to the original page-fault han-
dler since the fault is not due to the framework. This is
shown in lines 1–6, Figure 2.
If the page corresponding to the linear-address of the fault,
contains active breakpoints, the PFH sets the page attribute
to present to prevent recursive page-faults within the han-
dler. A disassembler is then employed to obtain the effective
address of the instruction causing the fault. If the effective
address is a breakpoint address, the disassembled instruction
is analysed to see if it is a read, write or execute breakpoint
for code, data and memory-mapped I/O. If so, the breakpoint
is triggered and processed. This is shown in lines 7–12, Fig-
ure 2.
The PFH then prepares to re-trigger any persistent break-
points on the page corresponding to the linear-address caus-
ing the fault. This is accomplished by populating a global
breakpoint re-trigger array (see Section 3.5). A single-step
handler is then setup to step over the current instruction that
caused the breakpoint to enable breakpoint persistence (see
Section 3.4). At this point, the PFH applies a clock patch (if
applicable) to hide the latency of the handler from the mal-
ware (see Section 3.6). Finally, the PFH returns, marking the
end of exception. This is shown in lines 13–16, Figure 2.
3.3. Breakpoint Triggering for Legacy I/O
Legacy I/O uses processor supported I/O instructions to
read from or write to a I/O port. Legacy I/O breakpoints in-
volve breakpoint triggering due to such I/O instructions at-
tempting to read from or a write to a speciﬁc I/O port. Pro-
cessors which support legacy I/O along with virtual memory,
support legacy I/O protection or virtualization in the form
of a TSS (or an equivalent). VAMPiRE relies on the TSS to
provide breakpoints on legacy I/O on processors that support
them. The TSS consists of a bitmap structure called the I/O
Bitmap which is a bit array with 1 bit for every legacy I/O
port in the system. If the bit corresponding to a I/O port is set
to a 1, the processor causes a general protection fault (GPF)
when I/O instructions referencing that I/O port are executed.
VAMPiRE makes use of this feature to support legacy I/O
breakpoints. It installs its GPFH (pseudo-code shown in Fig-
ure 3), replacing and chaining to the existing handler to im-
plement breakpoints on legacy I/O.
Figure 3. VAMPiRE GPFH
VAMPiRE’s GPFH semantics is very similar to that of its
PFH. To set a breakpoint at the desired I/O location (read or
write), VAMPIRE sets the bit corresponding to the I/O port,
in the I/O Bitmap array to a 1. This results in a GPF when
any access is attempted using that particular I/O port. When
VAMPiRE’s GPFH gets control, the handler obtains the lin-
ear address of the fault via the TSS and disassembles the in-
struction causing the fault. If the instruction does not belong
to the category of legacy I/O instructions, the GPFH applies
 1. obtain linear-address of fault 2. find memory page corresponding to linear-address 3. if (no active breakpoints on memory page){ 4.   apply clock patch 5.   chain to previous page-fault handler 6. }  7. mark memory page present preventing recursive faults 8. find effective address of instruction causing the fault 9. if (effective address is a breakpoint address){10.   get breakpoint type (read, write and/or execute)11.   trigger breakpoint and process12. }13. setup re-triggering for persistent breakpoints on     memory page14. setup single-step handler for breakpoint persistence15. apply clock patch16. return     1. obtain linear-address of the fault via TSS 2. disassemble the instruction causing the fault 3. if (not legacy I/O instruction){ 4.   apply clock patch 5.   chain to previous GPF handler 6. }  7. determine I/O port in disassembled instruction  8. if (I/O breakpoint on I/O port){ 9.   reset I/O bitmask for the port10.   find breakpoint type (read or write)11.   trigger breakpoint and process12. }13. setup re-triggering for persistent breakpoints on     memory page14. setup single-step handler for breakpoint persistence15. apply clock patch16. return  a clock patch (if applicable) to hide its processing latency
from the malware (see Section 3.6) and chains to the origi-
nal GPF handler since the fault is not due to the framework.
This is shown in lines 1–6, Figure 3.
If the instruction causing the fault is identiﬁed as a legacy
I/O instruction, the GPFH checks to see if the correspond-
ing I/O port (extracted from the instruction) has a breakpoint
set on it. If so, the corresponding I/O permission bit in the
I/O Bitmap is set to a 0 to prevent recursive faults from ac-
cessing that port within the handler. The GPFH then obtains
the breakpoint type (read or write) and processes the break-
point. This is shown in lines 7–12, Figure 3. The rest of the
GPFH processing (lines 13–16, Figure 3) is the same as de-
scribed for the framework PFH (lines 13–16, Figure 2, Sec-
tion 3.2) for the framework PFH.
3.4. Breakpoint Persistence via Single-Stepping
The single-step exception is a standard exception on all
processor architectures that is triggered upon execution of
each instruction when a certain processor ﬂag (also called the
trap ﬂag) is activated. VAMPiRE installs its own single-step
handler (pseudo-code shown in Figure 4), replacing the exist-
ing handler to implement breakpoint persistence. The single-
step handler is installed on demand from the framework fault
handlers (PFH and GPFH).
When the single-step handler is invoked due to a sin-
glestep exception , the handler ﬁrst makes sure that any effect
of the trap ﬂag (indicator for single-step) is masked out of
the instruction that has just been stepped over. This is a very
important step towards hiding the framework from the mal-
ware being analysed (see Section 3.6). The single-step han-
dler then iterates through every element in the breakpoint re-
trigger array (see Section 3.5) and sets the appropriate bit in
the I/O Bitmap to 1 (in case of legacy I/O breakpoint) or sets
the appropriate memory page attribute to not-present (in
case of code, data or memory-mapped I/O breakpoint). This
ensures that future accesses to the page or the legacy I/O port
re-triggers the breakpoint, thereby achieving breakpoint per-
sistence. Finally, the handler resets the trap ﬂag, uninstalls it-
self, and issues an end of exception. This is shown in lines
1–9, Figure 4.
3.5. Breakpoint Table, Callbacks, Re-trigger Array
VAMPiRE makes use of certain important storage el-
ements for
its functioning. Chief among them is the
breakpoint-table, which is an array of structures, one ele-
ment for each breakpoint that is set using the framework.
The breakpoint-table (shown in Figure 5) consists of (1) the
breakpoint address (2) the breakpoint type (code, data, mem-
ory mapped I/O or legacy I/O), (3) the breakpoint at-
tributes which include read, write, execute and the persis-
tence ﬂags, (4) the address of the callback which gets control
when the breakpoint is triggered, and (5) the breakpoint sta-
tus, which indicates if the breakpoint is currently active or
inactive.
Figure 4. VAMPiRE Single-Step Handler
A callback is simply a function that is supplied with pa-
rameters identifying the breakpoint address, the breakpoint
type (code, data, memory mapped or legacy i/o), the break-
point condition (read, write or execute) and the breakpoint
attribute (persistent or non-persistent). A debugger using
VAMPiRE will have to provide such a function that gets con-
trol when a breakpoint is triggered to do the appropriate pro-
cessing. The breakpoint address is the address in memory,
which would trigger a breakpoint when accessed. The break-
point address is the I/O port number if the breakpoint is of
type legacy I/O. The breakpoint address and its attributes are
usually set by the debugger using the appropriate VAMPiRE
API. Though a breakpoint can be set as persistent or non-
persistent during its creation, a callback can subsequently
over-ride this at runtime by returning an appropriate inte-
ger value in the breakpoint attribute parameter, to determine
if the breakpoint is to remain persistent or a one shot. One
could use different callbacks for different breakpoints, or use
a single callback to handle all the breakpoints set using the
framework.
Figure 5. VAMPiRE Breakpoint Table
Figure 5 shows several examples of entries one may ﬁnd
in the breakpoint table. The ﬁrst entry shows a breakpoint
set on memory read for the address 00501020h. The break-
point will only be triggered once since the persistent attribute
is missing. Similarly, the second entry shows a breakpoint
being set on memory read, write, and/or execute at location
10005000h with the breakpoint being re-triggered automati-
cally because of the presence of the persistent attribute. The
third entry shows a legacy I/O breakpoint being set for a read
on port 50h that is currently inactive. Also from Figure 5
one can see that all breakpoints are routed through one sin-
gle callback function at address 812E5000h.
VAMPiRE uses an array, called the breakpoint re-trigger
array in its fault handlers. Each entry in the breakpoint re-
trigger array is a structure containing the breakpoint type,
the target page of the breakpoint address (for code, data and
 1. mask out effect of the trap flag 2. for(each entry in breakpoint re-trigger array){ 3.   if (breakpoint type is legacy I/O) 4.     set corresponding bit in I/O bitmap to 1 5.   else 6.     set target memory page attribute to not-present 7. } 8. restore trap flag and uninstall handler  9. returnBreakpoint AddressTypeAttributesCallback AddressStatus00501020h10005000h50h50001200hDataCodeLegacy I/OCodeRR W X PRX812E5000h812E5000h812E5000h812E5000hR = Read      W = Write      X = Execute      P = Persistent       = Active       = Inactivememory-mapped I/O) or the target I/O port number (in case
of legacy I/O), and its associated callback address. This ar-
ray is used by the single-step handler (see Section 3.4) to en-
able breakpoint persistence.
3.6. Stealth Techniques
VAMPiRE uses the fault handlers (PFH and GPFH) at its
core for implementing breakpoints. However, the fault han-
dlers, their latency and issues involving single-stepping can
be detected during runtime albeit using some subtle tricks.