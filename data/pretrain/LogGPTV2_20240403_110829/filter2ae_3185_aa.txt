关键词：
  * 不需要编译llvm
  * 仅依赖NDK，不需要额外的其他环境
  * 不会遇到配置引起的符号NotFound问题
  * 不污染NDK
# 一、背景介绍
现在代码保护技术很多是在llvm上实现的，例如 `ollvm` 和
`hikari`，作者给出的实现是将源码混杂在llvm中，这样做非常不优雅。近来越来越多安全工作者都开始接触和研究基于llvm的代码保护，工欲善其事必先利其器，在编译、运行均是本机的环境下，不会出问题，因此本文介绍的是，如何优雅地在NDK中加载pass。
安卓开发者使用混淆技术来保护native代码时，一般有两种选择：
第一个选择是获得git上 `ollvm` 或 `hikari` 的代码，编译后，替换掉NDK中原先的toolchain。  
这是最不优雅的方式，因为维护起来很麻烦，因为需要编译整个llvm工程，并且对NDK有侵入性，无法保证修改前和修改后NDK的功能不发生变化。
第二个选择是，编译llvm工程，替换掉NDK中原先的toolchain，并且在相同环境下，移植 `ollvm` 或`hikari`
为独立的plugin，（移植方案我的github里有写 
）用编译为插件的形式，动态加载插件。  
相比第一个方案，极大降低维护的代价，只编译一个pass即可，但仍然对NDK有侵入性。
这两种方案的共同特点是：都需要编译整个llvm项目，初次部署时要消耗大量的时间和资源，另外在选择llvm版本时，也会纠结适配性的问题（虽然通常不会出现适配问题）
笔者曾经使用的是第二种方案，经过研究，本文提出第三种方案，使用NDK中的环境编译pass并加载pass，优雅程度上来看，有以下的特点：
  * 最最重要的，不需要编译llvm项目，节省巨大的时间和资源消耗；
  * 其次，不修改原先的NDK运行环境，和原生的NDK是最像的，没有侵入性；
  * 再次，上下文均和NDK完全一致，不需要担心符号问题，不需要额外安装软件和环境，有NDK的环境就足矣；
本文演示的环境是：ubuntu18.04（任意linux均可）、ndk-r20（任意NDK版本均可）、cmake（选择较高版本）
# 二、使用NDK的环境编译一个pass
众所周知，编译Pass时需要使用llvm的环境，由于NDK中的llvm环境是破损的，所以开发者一般自己编译一份llvm环境出来，替换掉NDK中的llvm环境，包括我本人之前也是这样处理的，这样做的原因是NDK中的llvm是破损的，因为NDK来自AOSP编译好的toolchain，而AOSP在制作toolchain的过程中是移除了部分文件的。
上文提到，本文的方案是不需要亲自编译llvm的，因此就需要使用NDK中的破损的llvm环境来编译一个pass。
根据对 
的阅读和调试，NDK中的llvm缺失的是一部分binary文件、全部静态链接库文件、全部头文件，采用的是静态连接的方式，它的clang是较为独立的文件（它会依赖libc++，因此成为较为独立）。
平时编译Pass时，需要使用cmake并且导入各种cmake相关的环境，通常写如下的配置文件，
    cmake_minimum_required(VERSION 3.4)
    # we need LLVM_HOME in order not automatically set LLVM_DIR
    if(NOT DEFINED ENV{LLVM_HOME})
        message(FATAL_ERROR "$LLVM_HOME is not defined")
    else ()
        set(ENV{LLVM_DIR} $ENV{LLVM_HOME}/lib/cmake/llvm)
    endif()
    find_package(LLVM REQUIRED CONFIG)
    add_definitions(${LLVM_DEFINITIONS})
    include_directories(${LLVM_INCLUDE_DIRS})
    link_directories(${LLVM_LIBRARY_DIRS})
    add_subdirectory(skeleton)  # Use your pass name here.
**幸运的是** ，NDK中的lib/cmake/llvm还在，里面的cmake文件都是原汁原味的的。
**不幸的是** ，由于AOSP在编译toolchain时设置了 `defines['LLVM_LIBDIR_SUFFIX'] = '64'`
，导致find_package的路径应该是 `lib64/cmake/llvm`，需要稍加修改
之后进行 `mkdir b;cd b;cmake ..`
会报如下的错误：
    ➜  b git:(master) ✗ cmake ..
    CMake Error at /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/cmake/llvm/LLVMExports.cmake:806 (message):
      The imported target "LLVMDemangle" references the file
         "/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/libLLVMDemangle.a"
      but this file does not exist.  Possible reasons include:
      * The file was deleted, renamed, or moved to another location.
      * An install or uninstall procedure did not complete successfully.
      * The installation package was faulty and contained
         "/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/cmake/llvm/LLVMExports.cmake"
      but not all the files it references.
    Call Stack (most recent call first):
      /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/cmake/llvm/LLVMConfig.cmake:173 (include)
      CMakeLists.txt:8 (find_package)
    -- Configuring incomplete, errors occurred!
    See also "/home/leadroyal/llvm-pass-tutorial/b/CMakeFiles/CMakeOutput.log".
因为NDK不含有.a文件，而cmake会检查这些文件，用于静态连接，被认为初始化失败，出错。
看源码对应的位置：
    # Loop over all imported files and verify that they actually exist
    foreach(target ${_IMPORT_CHECK_TARGETS} )
      foreach(file ${_IMPORT_CHECK_FILES_FOR_${target}} )
        if(NOT EXISTS "${file}" )
          message(FATAL_ERROR "The imported target \"${target}\" references the file
       \"${file}\"
    but this file does not exist.  Possible reasons include:
    * The file was deleted, renamed, or moved to another location.
    * An install or uninstall procedure did not complete successfully.
    * The installation package was faulty and contained
       \"${CMAKE_CURRENT_LIST_FILE}\"
    but not all the files it references.
    ")
        endif()
      endforeach()
      unset(_IMPORT_CHECK_FILES_FOR_${target})
    endforeach()
在文件不存在时，报 `message(FATAL_ERROR
xxxxxx)`，从而中断编译，但我们本来就是编译动态链接库的，不需要.a文件，所以这里做一个patch，降低log_level，使用WARNING等级。
    - message(FATAL_ERROR "The imported target \"${target}\" references the file
    + message(WARNING "The imported target \"${target}\" references the file
接下来面对第二个问题，之前提到过，NDK中缺失我们需要的头文件，它们本该出现在include/llvm中，因此这句话失效了
    include_directories(${LLVM_INCLUDE_DIRS})
但我们又不能随便找一堆头文件过来，版本之间可能有变更，万一用到一些配置不一样的头文件，就会出现非预期（例如经常出错的LLVM_ENABLE_ABI_BREAKING_CHECKS配置）
此时的思路是，找到NDK中llvm生成时的那份commit，从中获取include文件，有两个方案
  * 第一个方案是找到源码并使用cmake帮我们提取一遍。
  * 第二个方案是直接使用aosp提供的prebuilt文件，显然为了方便我们选择后者。
`toolchain` 在生成时会有一份描述版本信息的文件，在ndk生成时也被拷贝过来了
    ➜  linux-x86_64 cat /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/AndroidVersion.txt 
    8.0.7
    based on r346389c
**【AOSP相关访问google的前提条件你懂的】**
`r346389c` 就是这份toolchain的唯一标识，它与出现在
中的一系列clang-rxxxx是一回事，由于这个README.md经常被更新，我们需要checkout到对应的tag才可以找到它，。
于是在
中我们非常轻易就获取到了那份编译时刻的
`include/llvm`和`include/llvm-c`文件，使用点击右上角的tgz，有用的只有`llvm`和`llvm-c`，另外的`clang`、`clang-c`、`lld`我们用不到我就不下载了。
[https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm-c.tar.gz](https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm.tar.gz)
即可获得到这个目录的压缩包。
mac 对应的目录是  
如果可以接受NDK被污染（我使用的是这个方案），可以将它放到NDK的toolchain中，这样就可以继续使用 `${LLVM_INCLUDE_DIRS}`
这个变量；
如果不能接受NDK被污染，就随便放个目录，使用 `include_directories(/path/to/clang-r346389c/include)`
比如放在NDK里的include里，是这个样子（c++目录本来就有）
    ➜  include lsa
    total 5.4M
    drwxr-xr-x  8 leadroyal leadroyal 4.0K Oct 21 02:13 .
    drwxr-xr-x 15 leadroyal leadroyal 4.0K Oct 20 23:16 ..
    drwxr-xr-x  4 leadroyal leadroyal 4.0K Oct 21 02:12 c++
    drwxr-xr-x 33 leadroyal leadroyal 4.0K Oct 21 02:12 llvm
    drwxr-xr-x  3 leadroyal leadroyal 4.0K Oct 21 02:12 llvm-c
然后有几率遇到C++版本的问题，llvm10以上需要添加
    set(CMAKE_CXX_STANDARD 14)
在这在情况下使用的CMakeLists.txt最终是：
    cmake_minimum_required(VERSION 3.4)
    if(NOT DEFINED ENV{LLVM_HOME})
        message(FATAL_ERROR "$LLVM_HOME is not defined")
    endif()
    if(NOT DEFINED ENV{LLVM_DIR})
        set(ENV{LLVM_DIR} $ENV{LLVM_HOME}/lib64/cmake/llvm)
    endif()
    find_package(LLVM REQUIRED CONFIG)
    add_definitions(${LLVM_DEFINITIONS})
    include_directories(${LLVM_INCLUDE_DIRS})
    set(CMAKE_CXX_STANDARD 14)
    add_subdirectory(skeleton)  # Use your pass name here.
修复完include问题后，就可以舒舒服服地使用cmake来生成demo了，如下：
    export LLVM_HOME=/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64
    ➜  b git:(master) ✗ cmake ..       
    -- The C compiler identification is GNU 7.4.0
    -- The CXX compiler identification is GNU 7.4.0
    -- Check for working C compiler: /usr/bin/cc
    -- Check for working C compiler: /usr/bin/cc -- works
    -- Detecting C compiler ABI info
    -- Detecting C compiler ABI info - done
    -- Detecting C compile features
    -- Detecting C compile features - done
    -- Check for working CXX compiler: /usr/bin/c++
    -- Check for working CXX compiler: /usr/bin/c++ -- works
    -- Detecting CXX compiler ABI info
    -- Detecting CXX compiler ABI info - done
    -- Detecting CXX compile features
    -- Detecting CXX compile features - done
    -- Configuring done
    -- Generating done
    -- Build files have been written to: /home/leadroyal/llvm-pass-tutorial/b
    ➜  b git:(master) ✗ cmake --build .                    
    Scanning dependencies of target SkeletonPass
    [ 50%] Building CXX object skeleton/CMakeFiles/SkeletonPass.dir/Skeleton.cpp.o
    [100%] Linking CXX shared module libSkeletonPass.so
    [100%] Built target SkeletonPass
# 三、使用NDK的环境加载一个pass
编译部分完成了，接下来是加载部分，我们随便找一个android native项目，修改build.gradle中的flag
    externalNativeBuild {
        cmake {
            cppFlags "-Xclang -load -Xclang /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so"
        }
    }