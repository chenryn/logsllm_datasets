ADB virtualization. We add a control center app for VPBox users to
start and switch VPs swiftly. More importantly, we improve Cells
in four significant ways to meet our requirements on transparency
and stealthiness.
(1) We design kernel-level device virtualization to be compati-
ble with device changes in the new Android systems. Our
method makes it possible to have no in-guest virtualization
component for our user-level device virtualization(§4).
(2) We propose a novel user-level virtualization mechanism,
which offers a flexible and stealthy solution to virtualize new
hardware devices without compromising transparency (§5).
(3) We take new measures to reduce memory consumption and
enable SELinux settings for each VP (§6).
(4) We provide a broad spectrum of options to customize the
VP’s device attributes stealthily. This enables us to simulate
more diversified VPs on a single device (§7).
4 KERNEL-LEVEL DEVICE VIRTUALIZATION
Kernel-level device virtualization provides efficient hardware re-
source multiplexing, and it is also transparent to user-mode apps
running in VPs. Our kernel-level mechanism enables the virtualiza-
tion of Binder, power management, core network resource, and GPS
on mainstream Android versions. Our key method is to rewrite the
source code of kernel drivers to be aware of the device namespace.
Next, we use Binder and GPS as examples to present the strategy of
our kernel-level device virtualization. We put core network resource
and power management virtualization in Appendix A.
Binder. Binder allows high-level framework APIs to cross pro-
cess boundaries and interact with Android system services. The
Binder driver consists of three pseudo-device drivers. In addition
to the traditional “/dev/binder” driver, the Android system adds
another two Binder drivers since Android 8.0: “/dev/hwbinder” and
“/dev/vndbinder”; they are used for IPC between framework/vendor
processes and IPC between vendor/vendor processes [8]. Without
Binder virtualization, Binder’s IPC feature can be abused by dif-
ferent container processes, violating the system isolation between
containers. In VPBox, we have modified all Binder drivers’ data
structures to enable IPC between two processes that share the same
device namespace. Binder driver virtualization is the foundation of
our new user-level device virtualization technique (see §5), which
allows a service process in the VP to share the corresponding ser-
vice in the host system and leaves no virtualization component in
the VP’s userspace.
GPS. GPS provides a more accurate positioning service than
network positioning, but existing Android containers do not sup-
port GPS virtualization. GPS relies on a physical chip for loca-
tion tracking. In the Android framework layer, the GPS provider,
Session 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2862GpsLocationProvider, calls the hardware abstraction layer (HAL)
interface via Java Native Interface methods. The HAL interface inter-
acts with the GPS chip through “/dev/gss” driver. The GPS chip is an
active tracking device. After a user’s first request, the GPS chip will
continue to report the location information to GpsLocationProvider
without interruption. However, the GPS chip only supports one
connection. Our virtualization of GPS is to rewrite “/dev/gss” dri-
ver to support multiple connections. We modify “gss_open” and
“gss_event_output” functions so that the location information re-
ceived from the chip is forwarded to multiple clients simultaneously.
The location information goes through HAL and eventually reaches
GpsLocationProvider in the Android framework layer of the host
and virtual phones, respectively.
5 USER-LEVEL DEVICE VIRTUALIZATION
User-level device virtualization is necessary because some hardware
vendors provide proprietary software stacks that are completely
closed source. Without hardware vendor’s support, it would be
difficult, if not impossible, to virtualize them in the kernel. VPBox’s
user-level virtualization achieves the goal of having no in-guest
virtualization component by developing two new methods, which
enable the VP space to retain native-like system components.
1. Binder Service Sharing For the system services registered
in ServiceManager (e.g., WifiService & SurfaceFlinger), we pro-
pose a new, general virtualization technique via Binder service
sharing. We first modify the Binder-driver data structure (e.g.,
context_mgr_node, procs, and dead_nodes) to ensure that each
VP has its own Binder-driver data structure. Next, we create a
new specific handler in Binder’s data structure and let it point to
the host’s context_mgr_node. As context_mgr_node is associated
with ServiceManager, with this handler, the VP can access the host
phone’s ServiceManager node. Therefore, this mechanism allows
a VP’S service process to share the corresponding service in the
host system. Then, we leverage the SELinux technique to enforce
which services the VP can share in the host system. In VPBox, we
use Binder service sharing to virtualize WiFi configuration, Display,
GPU, Audio, and Camera.
2. Device Namespace Proxy We cannot apply Binder service
sharing to the anonymous services not registered in ServiceMan-
ager, such as telephone and Bluetooth, because their binder_node
and binder_ref kernel structures are missing. Therefore, we de-
velop a new device namespace proxy to virtualize telephone and
Bluetooth, leaving no in-guest virtualization component. Cells’s
user-level virtualization is not stealthy. It creates each VP’s own
proxy, connecting to CellD running in the host’s root namespace.
CellD, in turn, communicates related hardware vendor libraries
to respond to the VP’s requests. However, Cells’s proxy layer is
located at the VP’s application framework layer. Like API hooking,
apps running in the VP can easily detect the presence of Cells’s
proxy layer because they share the same privilege level. We address
the stealthiness concern by creating a device namespace proxy in
the host’s userspace only.
Next, §5.1 and §5.2 explore the method of Binder service sharing,
and §5.3 takes Bluetooth as an example to present the method of de-
vice namespace proxy. We put the details of other user-level devices’
Host Userspace
App
1
WifiService
4
ConnectivityService
3
NetworkAgent
VP NetworkAgent
6
WiFi Java Native
Interface
WPA Server &
Client
2
wpa_supplicant
VP Userspace
App
WifiManager
7
ConnectivityService
Host: Binder
5
Binder service
sharing
VP: Binder
Linux Kernel
WiFi configuration and status notifications before virtualization.
The workflow to answer a WiFi status query from the VP(cid:3244)s app.
The VP(cid:3244)s app receives network status notifications.
Figure 2: VPBox’s WiFi configuration virtualization.
virtualization (telephony, filesystem, and ADB) in Appendix B and
Appendix C.
5.1 WiFi Configuration
WiFi configuration and status notifications occur at the userspace.
We use Binder service sharing for its virtualization. Compared with
Cells’s method, our approach is simpler and leaves no virtualization
component in the VP’s userspace. Cells’s WiFi virtualization is not
stealthy because it adds a WiFi poxy inside each VP. In contrast,
our virtualization occurs at the host’s userspace and the kernel.
Figure 2 illustrates our design. In the Android system, before vir-
tualization, WifiService ( 1 ) calls the library of “wpa_supplicant”
( 2 ) to detect WiFi connections. The “wpa_supplicant” library is a
user-level library that contains wireless network service code. The
WiFi-connection information is sent through NetworkAgent ( 3 )
to ConnectivityService ( 4 ), which answers app queries about the
state of network connectivity. To virtualize WiFi, we use the binder
service sharing mechanism ( 5 ) to bridge WifiService between the
VP and the host. The blue double arrow line in Figure 2 shows the
workflow to respond to a WiFi status query from the VP’s app. In
addition, we create a new NetworkAgent in the host and bind it to
the VP’s device namespace ( 6 ). As shown by the red dotted line,
we also use Binder service sharing to connect the new NetworkA-
gent ( 6 ) with the VP’s ConnectivityService ( 7 ). The purpose of
doing so is to automatically forward network status notifications
(e.g., WiFi signal strength) to the VP.
5.2 Display, GPU, Audio, and Camera
Display, GPU, Audio, and Camera are all virtualized via the Binder
service sharing mechanism while ensuring the isolation between
VPs. We use Display and GPU as examples to describe the design.
The virtualization methods of Audio and Camera are similar by
sharing the Binder service of AudioFlinger and CameraService.
Session 11A: Attestation and Firmware Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2863APP
1
Android
Bluetooth APIs
Binder IPC
2
com.android.bluetooth
JAVA Module
JNI Module
Java Native
Interface
(JNI)
e
c
a
p
s
r
e
s
U
P
V
APP
Android
Bluetooth APIs
5
Binder IPC
com.android.bluetooth
JAVA Module
Binder Service
Sharing
e
c
a
p
s
r
e
s
U
t
s
o
H
y
x
o
r
P
I
N
J
h
t
o
o
t
e
u
B
l
APP
Android
Bluetooth APIs
Binder IPC
com.android.bluetooth
JAVA Module
Binder IPC
6
Binder Service
7
Foreground VP ?
Yes
packages/apps/Bluetooth
JNI Module
5
8
Java Native
Interface (JNI)
Bluetooth Stack
Bluetooth Stack
3
4
HIDL
Bluetooth
Controller
Drivers
Linux Kernel
(a) Android Bluetooth
Architecture
HIDL
Bluetooth
Controller
Drivers
Linux Kernel
(b) VPBox Bluetooth Architecture
Figure 3: VPBox’s Bluetooth virtualization.
The Display is an essential device in smartphones, and the GPU
provides hardware display acceleration. Before Android 6.0, the
Android system takes Linux framebuffer (FB) as an abstraction
to a physical display and screen memory. Cells virtualizes FB by
multiplexing FB’s device driver. However, Android 6.0 and later
versions have switched to the ION driver for managing the screen
memory. Modifying the ION driver to virtualize FB is error-prone
and complicated.
To solve this issue, we take advantage of the Binder service shar-
ing to enable each VP to multiplex an essential graphics service—
SurfaceFlinger of the host system. SurfaceFlinger is responsible for
compositing all of the application and system surfaces into a single
framebuffer for a final display. Also, we adapt related data struc-
tures, graphics rendering APIs, and interfaces for virtualization. 1)
We add the system tag field in the Layer data structure to detect
to which system (VP or host) the Layer belongs. 2) With the added
system tag, we identify the foreground system layer from Surface-
Flinger’s APIs, such as layer cropping and compositing, to display
the final image on the screen. 3) To switch the screen between the
VP and host, we add new interfaces for clearing and redrawing im-
ages in SurfaceFlinger. Our design is two-birds-one-stone because
no additional measures are needed for GPU virtualization. Since the
VP multiplexes the host system’s screen memory buffer, the host’s
GPU can directly work on it for display acceleration. Additionally,
to properly support the foreground-background usage model, we
limit the SurfaceFlinger service to only respond to the request from
the foreground VP, ignoring the requests from background VPs.
5.3 Bluetooth
None of the existing Android emulators or containers can virtu-
alize Bluetooth. Each smartphone manufacturer provides its own
proprietary Bluetooth vendor code that is entirely closed source.
Without the hardware vendor’s support, the kernel-level virtual-
ization of Bluetooth would be very challenging. Figure 3(a) shows
the Android Bluetooth architecture since Android 8.0. To use the
Bluetooth service, an app first calls Android Bluetooth APIs ( 1 ),
which further sends the request to the Bluetooth service process
( 2 ) via Binder IPC. Next, the Bluetooth service process connects to
the Bluetooth stack ( 3 ) via Java Native Interface (JNI). Then, the
Bluetooth stack interacts with the Bluetooth controller ( 4 ) using
Hardware Interface Design Language (HIDL).