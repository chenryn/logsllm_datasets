Linux (§5.1), we modified two things to work for Windows:
(i) use a different syscall for setting up a thread’s CPU
affinity (i.e., SetThreadAffinityMask() in Windows) and (ii)
additionally invoke a syscall to set the high priority using
SetThreadPriority().
TLB Shootdown IPI. Similar to Linux, the TLB shoot-
down mechanism is carried out by sending IPI. Thus, we
confirmed that the race window could be mainly extended
by the same method introduced in §5.2.1. The difference is
platform-dependent syscall uses (more precisely, WinAPI in
the Windows terminology), i.e., we used VirtualAlloc(),
VirtualProtect(), and VirtualFree() to allocate, modify,
and free the memory page, respectively.
HW Interrupt. Windows also offers a kernel feature that
each device driver can configure an affinity policy, such
that each can declare a set of CPU cores to serve relevant
hardware interrupts. Specifically, the affinity policy can be
configured in the device’s INF file or registry settings (e.g.,
#Device ParametersInterrupt registry [41]).
However, in our experimental setup (§7), all device drivers
installed on the machine are configured to have no core
affinity. In other words, all device drivers are handled in a
round-robin order. Although this may imply that the exten-
sion method with HW interrupt (§5.3) cannot be used for
Windows, still this brings a significant benefit in extending
the race window. Theoretically, if there are k different cores
in the machine, the HW interrupt-based method in Windows
would have k times less efficient than Linux. This is because
in Windows it is possible that the IPI can be served by k− 1
irrelevant cores due to the round-robin, while in Linux it is
always served by the dedicated core.
6.2 Mac OS X
munmap(), we were able to raise TLB shootdown IPI, thereby
extending the race window (i.e., Ty).
HW Interrupt. OS X does not provide internal information
on hardware interrupts, so we could not understand whether
IRQ handling mechanisms in OS X involve the core affinity.
We developed a similar exploitation attack, as shown in §5.3,
but it does not work and we were not able to understand the
reason due to lack of information.
7 Evaluation
This section aims at evaluating the exploitation effectiveness
of EXPRACE. First, we used EXPRACE to exploit 10 real-
world multi-variable races in Linux (§7.1). Then to under-
stand more detailed aspects of real-world exploitation, we
developed and exploited synthetic multi-variable races in
Linux (§7.2). Lastly, we launched the synthetic multi-variable
races on Windows and Mac OS X, testing if EXPRACE also
works for OSes other than Linux (§7.3).
Experimental Setup. For the experiments on Linux, we ran
Ubuntu 18.04.3 LTS on Intel i7-8700 (3.20GHZ) with 32 GB
of memory, which enabled the CONFIG_PREEMPT_VOLUNTARY
option (which is a default configuration for desktop machines).
For the experiments on Microsoft Windows, we ran Win-
dows 10 version 1909 (OS build 18363.592) on Intel i7-8700
(3.20GHZ) with 32 GB of memory. For the experiments on
Mac OS X, we ran macOS 10.14 (19A583) on Mac mini
(2018) on Intel i5-8500B (3.00GHz) with 8 GB of memory.
Evaluation Methods. Throughout this evaluation sec-
tion, we varied the exploitation method as
follows:
Baseline refers to the brute-force attack without EXPRACE.
Reschedule refers to the brute-force attack with EXPRACE’s
reschedule IPI method (§5.1). membarrier refers to
the brute-force attack with EXPRACE’s membarrier IPI
method (§5.2.2). TLB shootdown refers to the brute-force
attack with EXPRACE’s TLB shootdown IPI method (§5.2.1).
HW interrupt refers
to the brute-force attack with
EXPRACE’s hardware interrupt method (§5.3).
Reschedule IPI. Although Mac OS X kernel is designed
to support a preemption mode, its default configuration is
a non-preemption mode, and the configuration cannot be
changed [20]. We developed the similar exploitation attack as
shown in §5.1, but the exploitation failed and it was challeng-
ing for us to simply understand why it fails due to the limited
internal information.
TLB Shootdown IPI. Similar to Linux, Mac OS X sends
an IPI to the CPU core which has a TLB entry to be flushed.
Since Mac OS X is UNIX-based operating systems, we con-
firmed that the race window extension method is shown
in §5.2.1 also works on Mac OS X as well—i.e., using sim-
ilar OS X system calls including mmap(), mprotect(), and
7.1 Exploiting Real-World Races in Linux
Real-World Exploitation Setup.
In order to demonstrate
that EXPRACE is truly effective in exploiting race vulnera-
bilities, we used EXPRACE to exploit 10 real-world multi-
variable races in Linux listed in Table 1. We utilized publicly
available exploits for CVE-2019-1999 and CVE-2019-2025.
Since the rest eight do not have publicly available exploits,
we developed an exploit for the rest eight. We run the vul-
nerable kernel version of each vulnerability to launch the ex-
ploitation: CVE-2017-15265 on v4.13.5; da1b9564 on v4.18-
rc3; 4842e98f on v4.4.19; and all the other vulnerabilities on
v4.19.0.
2372    30th USENIX Security Symposium
USENIX Association
7.2 Exploiting Synthetic Races in Linux
7.2.1 Design Synthetic Races
To perform an in-depth study on the effectiveness of
EXPRACE, we created a synthetic race vulnerability for Linux.
This vulnerability is implemented as a device driver, which
takes two syscalls from userspace, Syscallx and Syscally,
where two syscalls have multi-variable race vulnerability on
two global variables P1 and P2. In order to check if the race
exploitation was successful, we designed the vulnerability
such that Syscallx returns 0x1337 if successful. Otherwise,
it returns zero. We also inserted two for loops, one in be-
tween A and D and the other in between B and C , so that
we can control Tx and Ty by modifying the number of loop
iterations (i.e., LOOPNUM_A for Tx and LOOPNUM_B for Ty). Note
that we cannot precisely control CPU cycles of Tx and Ty as it
is indirectly impacted by executed instructions.
To successfully exploit this race, the initialization stage is
similar to the attack shown in §5. The important thing is that
the execution should occur in the following order: A ≫ B ≫
C ≫ D . When trying each race window enlarging method,
we performed the necessary steps to trigger IPI or interrupts
as described in §5 (i.e., creating Taskint and invoking a set of
syscalls from Taskint). Similar to the real-world exploitation
case, we kept invoking Syscallx and Syscally while varying
an exploitation method. We repeated the above mentioned
exploitation for one minute since one minute was enough to
collect a meaningful number of data as we show next.
7.2.2 Synthetic Race Exploitation Results
We launched an exploitation as described in §7.2.1 so as
to clearly interpret the exploitation result against real-world
races (shown in Table 4). In order to simulate Tx and Ty of
real-world cases, we picked four different Ty, and launched
the exploitation for each Ty while varying Tx. For each Tx
and Ty pair, we launched an exploitation for one minute and
measured the following information: the number of total trials,
the number of successful exploitation, and the number of
issued interrupts.
The results of the synthetic exploitation are shown in Fig-
ure 9. Each subfigure is the result of fixing Ty at around 17,
41, 130, and 1135 cycles, and X-axis represents Tx and Y-axis
represents the number of successful exploitation after trying
one minute.
Overall, the baseline method only shows the success case
if Tx  Ty (implicating
the non-inclusive multi-variable race). Moreover, TLB shoot-
down is the most effective when Tx is less than 1,500 cycles.
This is because it takes less time to invoke TLB shootdown
by Taskint, so it issues a large number of IPIs compared to
other exploitation methods. Hardware interrupts show the
stable success number over Tx, because TE (i.e., an enlarged
Figure 8: A workflow of synthetic race exploitation evaluation
These 10 real-world vulnerabilities are non-inclusive multi-
variable races, and its Tx and Ty are measured, as shown in Ta-
ble 4. For each vulnerability, we attempted to exploit for 24
hours at maximum (i.e., simply taking an infinite loop to trig-
ger the race) while varying an exploitation method to enlarge
Ty. Note that once the exploitation is successful, we stopped
the experiment due to the following two reasons: i) kernel
crashes due to memory corruption; (ii) even if not crashing,
the kernel is in an abnormal state that the race cannot be trig-
gered again. The only reliable way is to reboot the system,
which requires non-trivial evaluation efforts.
Real-World Exploitation Results. The overall results are
shown in Table 4. Without EXPRACE, the 24-hours long ex-
ploitation attempts were failed for all 10 real-world vulner-
abilities as expected (shown in Baseline column). Using
Reschedule, three vulnerabilities were successfully exploited
within 66 seconds, while the rest seven cases were failed.
These failed cases were related to the fact that the length of
an enlarged race window Ty′ is smaller than Tx − Ty, which
we further study shortly. Using membarrier IPI, three cases
were successfully exploited. It failed to exploit five cases (i.e.,
CVE-2019-6974, CVE-2019-1999, 11eb85ec, 1a6084f8, and
e20a2e9c) due to the small Ty′. With TLB shootdown, seven
cases were successfully exploited. With hardware interrupts,
all 10 cases were successfully exploited. Note that membarrier
and TLB shootdown cannot be applied to exploit CVE-2019-
6974 and da1b9564, as these require that the two racy syscalls
should be invoked from the same process, which cannot be
supported by these methods.
Accuracy of Probability Model.
To interpret these re-
sults using the exploitation probability model (i.e., PEXPRACE
),
we also collected the number of relevant events during
the exploitation (shown in Table A.1). This confirms that
EXPRACE’s exploitation is feasible within a reasonable time
(i.e., at most 118 seconds).
multi
USENIX Association
30th USENIX Security Symposium    2373
Kernel thr for Taskintint :P1 =1;P2 = 0;Interrupt handlerUser thr for Taskyy :Kernel thr for Taskyy :Kernel thr for Taskyy :Core 1 (C1C1)Core 2 (C2C2)if( !P1 )if( !P2 )User thr for Taskxx :Kernel thr for Taskxx :Core 0 (C0C0)Race-stageFunction() (related to attack method)User thr for Taskintint :    return 0;      return 0;ABCDSend interrupt to  C1C1Initialization-stageEnvironment setting based on attack method3    Create three tasksfork/threadfork/thread12Pinning each tasksched_setaﬃntiy(C1C1)sched_setaﬃntiy(C2C2)sched_setaﬃntiy(C0C0)TaskxxTaskxxTaskyyTaskyyTaskintintTaskintint TxTx TyTy TyTy TETE Ty′Ty′for(LOOPNUM_A);for(LOOPNUM_B);Syscallxx()Syscallyy()Vulnerability
CVE-2019-6974
CVE-2019-2025
CVE-2019-1999
CVE-2017-15265
11eb85ec... [35]
1a6084f8... [53]
20f2e4c2... [36]
4842e98f... [32]
da1b9564... [33]
e20a2e9c... [34]
Success (Time taken until the first success)
Baseline
Reschedule
✗ (> 24 hours)
✗ (> 24 hours)
✗ (> 24 hours)
✗ (> 24 hours) ✔ ( 24 hours)
✗ (> 24 hours) ✔ ( 24 hours)
✗ (> 24 hours)
✗ (> 24 hours)
✗ (> 24 hours) ✔ ( 24 hours)
✗ (> 24 hours)
✗ (> 24 hours)
✗ (> 24 hours)
✗ (> 24 hours)
✗ (> 24 hours)
✗ (> 24 hours)
membarrier
✗ (Cannot apply)
✔ ( 24 hours)
✔ ( 24 hours)
✗ (> 24 hours)
✗ (> 24 hours)
✔ ( 24 hours)
TLB shootdown
HW interrupt
✗ (Cannot apply) ✔ (< 30 sec)
✔ (< 25 sec)
✔ (< 10 sec)
✔ (< 70 sec)
✔ (< 60 sec)
✔ (< 60 sec)
✔ (< 80 sec)
✔ (< 70 sec)
▲ (< 30 sec)
✔ (< 60 sec)
▲ (< 40 sec)
✔ (< 45 sec)
✔ (< 20 sec)
✔ (< 10 sec)
✔ (< 25 sec)
✗ (Cannot apply) ✔ (< 118 sec)
✔ (< 30 sec)
▲ (< 30 sec)
Average Cycles
Ty
Tx
18
1,210
50
600
150
1,800
35
450
113
2,515
158
2,363
122
1,580
120
730
18
2,250
13,121 1,153
TSyscallx
3,818
8,131
52,285
9,893
54,389
56,275
50,755
11,704
349,342
109,873
TSyscally
7,102
227,538
623,597
17,893
18,296
13,499
6,392
28,363
176,165
19,503
Table 4: Exploitation results on real-world race vulnerabilities in Linux. ✔: the exploitation is successful within 24 hours; ▲: The extended
cycle by TLB shootdown IPI are vary depends on the number of pages. The exploitation with 1 page isn’t successful for given 24 hours but
successful with a number of pages; ✗: the exploitation has failed for given 24 hours. The time enclosed in a parentheses denotes the time taken
for the first exploitation success.
cycles) is larger than all plotted Tx values (i.e., according to
our measurement shown in §7.2.3, TE is measured to be about
14,103 cycles for hardware interrupts, respectively).
In each subfigure, annotated vertical lines indicate when Tx
and Ty are similar as those of real-world vulnerability. When
Ty is about 17 cycles (Figure 9-a-1), it can be explained why
da1b9564 can be exploited by the hardware interrupt—the
hardware interrupt maintains its success number even if Tx is
more than 2,250 cycles. All other methods failed to maintain