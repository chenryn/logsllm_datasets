# CS插件之DLL反射加载EXP绕过AV提升权限
## 0x0 前言
本文主要是笔者归纳一些实践经验，针对常见的AV拦截落地提权EXP进行的一些躲避尝试的记录。本文内容并不深入原理，但会尽量说明技术的基本体系和操作的核心步骤，即使你是个萌新，依然可以轻松且愉快地阅读并进行实践。
## 0x1 DLL注入概念
[DLL注入-维基百科](https://zh.wikipedia.org/zh-hans/DLL%E6%B3%A8%E5%85%A5)
> DLL注入(DLL
> Injection)是一种计算机编程技术，它可以强行使另一个进程加载一个动态链接库(DLL)以在其地址空间内运行指定代码。常见用途是改变原先程序的行为，实现程序作者本未设计或可预期的结果。比如用于hook系统调用、读取密码框内容。
>
> 将任意代码注入任意进程的程序被称为DLL注入器。
通俗来说，DLL注入的目标对象是某一进程，然后在该进程的地址空间上注入DLL中的代码并且执行，主要是起到了动态修改程序行为的作用。合理地来说，也可用于动态拓展程序功能，即起到增强作用。
## 0x2 DLL注入方式
下面主要介绍两种注入反射方式，对比差异，来帮助学习。
### 0x2.1 常规DLL注入
常规的DLL注入方式是远程线程注入(`CreateRemoteThread`)  
步骤如下:  
1.打开目标进程句柄  
2.开辟目标进程空间，用于存放需要注入的DLL文件路径  
3.获取`LoadLibrary`的地址  
4.通过`CreateRemoteThread`函数调用LoadLibrary，传入DLL文件路径的地址作为参数，进行远程动态调用。
> 技术的核心原理：  
>
> 我们注入器的进程的内存空间是没办法让目标进程访问到的，而核心调用DLL的基础原理是程序执行`LoadLibrary`函数去加载指定的DLL，所以我们必须要在目标进程空间存放DLL的文件地址(这样目标进程才能调用到)，由于`kernel.dll`加载的地址在所有进程都是一样的，且`LoadLibrary`是其导出模块，其RVA地址是固定在PE结构的，所以注入器获取到的API地址是一样，可作用于目标进程，这样我们就可以通过远程执行目标进程的新线程，然后线程执行`LoadLibrary`函数加载指定DLL实现DLL注入。
>
> 关于为什么系统模块加载地址会相同，可以理解为设计需要，可查阅 
先采用VS2019 编写一个简单的DLL: hello.dll  
DLL_PROCESS_ATTACH状态时执行`MessageBoxA`:
    MessageBoxW(NULL, TEXT("Hello i am hello!"), TEXT("box"), MB_OK);
当然如果你本机装有msfvenom,可以更加方便生成一个dll:
    msfvenom -p windows/exec cmd=calc.exe -f dll -o calc32.dll # 生成32位dll
    msfvenom -p windows/x64/exec cmd=calc.exe -f dll -o calc64.dll # 生成64位dll
整完，开始编写注入器,用到核心API函数如下:  
[OpenProcess](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)
    HANDLE OpenProcess(
      DWORD dwDesiredAccess, //PROCESS_ALL_ACCESS 进程控制的权限
      BOOL  bInheritHandle, //false, 句柄是否可以被继承
      DWORD dwProcessId //目标进程pid,某些系统进程会出错
    );
[VirtualAllocEx](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)
    LPVOID VirtualAllocEx(
      HANDLE hProcess,  //目标进程句柄 PROCESS_VM_OPERATION 
      LPVOID lpAddress, //NULL，自动分配空间地址
      SIZE_T dwSize, //单位byte， 分配的空间区域大小
      DWORD  flAllocationType, //MEM_COMMIT  内存类型
      DWORD  flProtect //PAGE_READWRITE， 内存区域权限可读可写
    );
[WriteProcessMemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
    BOOL WriteProcessMemory(
      HANDLE  hProcess, //目标进程句柄  PROCESS_VM_WRITE and PROCESS_VM_OPERATION 
      LPVOID  lpBaseAddress, //写入内容的基地址
      LPCVOID lpBuffer, //指向写入数据的指针
      SIZE_T  nSize, //写入数据的大小
      SIZE_T  *lpNumberOfBytesWritten //NULL，不记录写入字节数目
    );
[CreateRemoteThread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)
    HANDLE CreateRemoteThread(
      HANDLE                 hProcess, //目标句柄
      LPSECURITY_ATTRIBUTES  lpThreadAttributes,//NULL，默认描述符
      SIZE_T                 dwStackSize, //0，使用默认栈大小
      LPTHREAD_START_ROUTINE lpStartAddress,// 指针指向远程调用函数的地址
      LPVOID                 lpParameter, //指针指向参数地址
      DWORD                  dwCreationFlags,//0,立刻执行
      LPDWORD                lpThreadId //NULL,不返回验证信息
    );
[GetModuleHandle](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)
    HMODULE GetModuleHandleA(
      LPCSTR lpModuleName //kernel32.dll 模块名称
    );
[GetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)
    FARPROC GetProcAddress(
      HMODULE hModule, //模块句柄
      LPCSTR  lpProcName //导出函数名称
    );
下面开始编写我们的注入器，我的编程规则是先声明必须的变量，这样代码写起来有层次感。  
VS2019创建个窗口程序项目DllInject:
    #include 
    #include 
    using namespace std;
    int main(int argc, char ** argv)
    {
        // declare varibales
        HANDLE processHandle;
        LPVOID remoteAllocAddr;
        BOOL writeRet;
        HMODULE hModule;
        HANDLE hThread;
        LPTHREAD_START_ROUTINE  dwLoadAddr;
        char* dllPath;
        /*
        wchar_t tPath[] = TEXT("C:\\Users\\god\\Desktop\\test\\hello.dll");
        LoadLibraryW(tPath);
        exit(0);
        */
        if (argc 
> 相比于常规的DLL注入，反射注入能够躲避ProcessExplorer、Procexp64等工具的module检查，文件也无需落地，只能从内存层面来做检测，操作来说更加隐蔽，缺点就是因为使用了很多FUZZ和循环进行定位，实现代码较为复杂，代码量也比较大。
一般DLL在内存加载的流程(非权威):  
1.检索DLL，文件数据映射到内存中  
2.检查PE文件有效性（DOS、PE header）  
3.分配PE文件中的`SizeOfImage`的内存大小  
4.解析节区数据，根据PE中的区段对齐大小和VA偏移拷贝到内存空间中  
5.实际加载到进程地址空间与PE文件中指定的基地址不一致，则需要修复重定向表。  
6.修复导入表，加载DLL依赖的其他DLL  
7.根据每个节区的`Characteristics`属性设置内存页访问属性  
8.通过`AddressOfEntryPoint`获取到DllMain的函数地址，进行调用。
>
> LoadLibrary的具体执行流程应该比这个会更为复杂，处理的细节也会更多，处理的步骤可能也不一样，但是程序执行的核心还是Rip执行内存的指令代码，是不断寻址的过程，只要指令和数据正确，便能正确执行。
实际DLL反射加载的流程:  
下面基于一个较为出名但比较古老却仍然被CS、MSF使用活跃的项目代码进行分析。
> 有趣的是项目在8年前就已经不再更新，至于为什么叫反射，从结果来说，通过外部调用自身编写的ReflectLoader函数，然后实现 **动态加载自己**
> ，动态获取DLL的所有功能，实现完整的控制流程。
Github:[ReflectiveDLLInjection](https://github.com/stephenfewer/ReflectiveDLLInjection)
> Reflective DLL injection is a library injection technique in which the
> concept of reflective programming is employed to perform the loading of a
> library from memory into a host process. As such the library is responsible
> for loading itself by implementing a minimal Portable Executable (PE) file
> loader. It can then govern, with minimal interaction with the host system
> and process, how it will load and interact with the host.
这里我从完整的执行流程作为时间线进行debug分析：  
1）Inject项目  
入口Inject.C  
注入部分LoadLibraryR.c  
后面就是常规的远程调用函数执行的流程：
这里我选择跟进`GetReflectiveLoaderOffset`  
前面先通过预编译判断编译的注射器和DLL的位数是不是一致的，否则return。  
一致的话，就开始静态解析PE结构的导出表，  
解读上图的代码,
    uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)->e_lfanew;
获取到PE头的NTheader，解析导出表,获取到名称、地址、序号的数组基址  
然后根据`NumberOfNames`导出函数数目，这里只有一个导出函数，然后数组和序号地址根据4字节偏移开始递增，将`uiNameArray`转换为char类型比较是否`ReflectiveLoader`函数，如果是则，加上序号*4+((PIMAGE_EXPORT_DIRECTORY
)uiExportDir)->AddressOfFunctions作为`ReflectiveLoader`函数，至此完成函数的地址定位工作。
>
> 这里不用寻找也可以，调用该函数的时候，放入一个参数存放注射器分配的DLL空间,这样的话通用性会差点，因为有时候我们可能没办法直接获取到地址，只能盲写之类的。
>
> 这种能直接通过地址进行调用，而无须进行修正就能够正常运行的函数，采用了地址无关的代码实现，基本的原理实现是将指令部分需要修改的分离出来跟数据部分放在一起，保持指令部分不变，或者保持指令部分不需要改变，不去引用绝对地址。
2）reflective_dll项目  
这个函数首先调用`caller`，其实现是[`_ReturnAddress()`],(
然后通过不断在内存回溯，暴力匹配DLL文件DOS头`MZ`来确认DLL的加载地址。
接下来需要利用PEB来获取进程加载的module模块的地址，只获取kerner.dll、ntdll.dll