volatile 关键字告诉编译器i 是随时可能发生变化的，每次使用它的时候必须从内存
中取出i的值，因而编译器生成的汇编代码会重新从i 的地址处读取数据放在k 中。
这样看来，如果i 是一个寄存器变量或者表示一个端口数据或者是多个线程的共享数
据，就容易出错，所以说volatile 可以保证对特殊地址的稳定访问。
但是注意：在VC++6.0 中，一般Debug 模式没有进行代码优化，所以这个关键字的作
用有可能看不出来。你可以同时生成Debug 版和Release 版的程序做个测试。
留一个问题：const volatile int i=10；这行代码有没有问题？如果没有，那i 到
底是什么属性？
1.14 最会带帽子的关键字----extern
extern，外面的、外来的意思。那它有什么作用呢？举个例子：假设你在大街上看到
一个黑皮肤绿眼睛红头发的美女（外星人？）或者帅哥。你的第一反应就是这人不是国产的。
extern 就相当于他们的这些区别于中国人的特性。extern 可以置于变量或者函数前，以
标示变量或者函数的定义在别的文件中，下面的代码用到的这些变量或函数是外来的，不是
本文件定义的，提示编译器遇到此变量和函数时在其他模块中寻找其定义。就好比在本文件
中给这些外来的变量或函数带了顶帽子，告诉本文件中所有代码，这些家伙不是土著。
那你想想extern 修饰的变量或函数是定义还是声明？
看列子：
A.c 文件中定义： B.c 文件中用extern 修饰：
int i = 10； extern int i； //写成i = 10；行吗？
void fun（void） extern void fun（void）；//两个void 可否省略？
- 35 -
{
//code
}
C.h 文件中定义： D.c 文件中用extern 修饰：
int j = 1; extern double j； //这样行吗？为什么？
int k = 2; j = 3.0； //这样行吗？为什么？
至于extern“C”的用法，一般认为属于C++的范畴，这里就先不讨论。当然关于extern
的讨论还远没有结束，在指针与数组那一章，你还会和它亲密接触的。
1.15 struct 关键字
struct 是个神奇的关键字，它将一些相关联的数据打包成一个整体，方便使用。
在网络协议、通信控制、嵌入式系统、驱动开发等地方，我们经常要传送的不是简单的
字节流（char 型数组），而是多种数据组合起来的一个整体，其表现形式是一个结构体。
经验不足的开发人员往往将所有需要传送的内容依顺序保存在char 型_______数组中，通
过指针偏移的方法传送网络报文等信息。这样做编程复杂，易出错，而且一旦控制方式及通
信协议有所变化，程序就要进行非常细致的修改，非常容易出错。这个时候只需要一个结构
体就能搞定。平时我们要求函数的参数尽量不多于4 个，如果函数的参数多于4 个使用起来
非常容易出错（包括每个参数的意义和顺序都容易弄错），效率也会降低（与具体CPU 有关，
ARM芯片对于超过4 个参数的处理就有讲究，具体请参考相关资料）。这个时候，可以用结
构体压缩参数个数。
1.15.1 空结构体多大？
结构体所占的内存大小是其成员所占内存之和（关于结构体的内存对齐，请参考预处理
那章）。这点很容易理解，但是下面的这种情况呢？
struct student
{
}stu;
sizeof(stu)的值是多少呢？在Visual C++ 6.0 上测试一下。
很遗憾，不是0，而是1。为什么呢？你想想，如果我们把struct student 看成一个
模子的话，你能造出一个没有任何容积的模子吗？显然不行。编译器也是如此认为。编译器
认为任何一种数据类型都有其大小，用它来定义一个变量能够分配确定大小的空间。既然如
此，编译器就理所当然的认为任何一个结构体都是有大小的，哪怕这个结构体为空。那万一
结构体真的为空，它的大小为什么值比较合适呢？假设结构体内只有一个char 型的数据成
员，那其大小为1byte（这里先不考虑内存对齐的情况）.也就是说非空结构体类型数据最
少需要占一个字节的空间，而空结构体类型数据总不能比最小的非空结构体类型数据所占的
空间大吧。这就麻烦了，空结构体的大小既不能为0，也不能大于1，怎么办？定义为0.5个
byte？但是内存地址的最小单位是1 个byte，0.5 个byte 怎么处理？解决这个问题的最
好办法就是折中，编译器理所当然的认为你构造一个结构体数据类型是用来打包一些数据成
员的，而最小的数据成员需要1 个byte，编译器为每个结构体类型数据至少预留1 个byte
的空间。所以，空结构体的大小就定位1 个byte。
- 36 -
1.15.2 柔性数组
也许你从来没有听说过柔性数组（flexible array）这个概念，但是它确实是存在的。
C99 中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构
中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变
的数组。sizeof 返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用
malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数
组的预期大小。
柔性数组到底如何使用呢？看下面例子：
typedef struct st_type
{
int i;
int a[0];
}type_a;
有些编译器会报错无法编译可以改成：
typedef struct st_type
{
int i;
int a[];
}type_a;
这样我们就可以定义一个可变长的结构体， 用sizeof(type_a) 得到的只有4 ， 就
是sizeof(i)=sizeof(int)。那个0 个元素的数组没有占用空间，而后我们可以进行变长
操作了。通过如下表达式给结构体分配内存：
type_a *p = (type_a*)malloc(sizeof(type_a)+100*sizeof(int));
这样我们为结构体指针p 分配了一块内存。用p->item[n]就能简单地访问可变长元素。
但是这时候我们再用sizeof（*p）测试结构体的大小，发现仍然为4。是不是很诡异？我们
不是给这个数组分配了空间么？
别急，先回忆一下我们前面讲过的“模子”。在定义这个结构体的时候，模子的大小就
已经确定不包含柔性数组的内存大小。柔性数组只是编外人员，不占结构体的编制。只是说
在使用柔性数组时需要把它当作结构体的一个成员，仅此而已。再说白点，柔性数组其实与
结构体没什么关系，只是“挂羊头卖狗肉”而已，算不得结构体的正式成员。
需要说明的是：C89 不支持这种东西，C99 把它作为一种特例加入了标准。但是，C99
所支持的是incomplete type，而不是zero array，形同int item[0];这种形式是非法
的，C99 支持的形式是形同int item[];只不过有些编译器把int item[0];作为非标准扩
展来支持，而且在C99 发布之前已经有了这种非标准扩展了，C99 发布之后，有些编译器
把两者合而为一了。当然，上面既然用malloc 函数分配了内存，肯定就需要用free 函数
来释放内存：
free(p);
经过上面的讲解，相信你已经掌握了这个看起来似乎很神秘的东西。不过实在要是没掌
握也无所谓，这个东西实在很少用。
- 37 -
1.15.3 struct 不 class 的区别
在C++里struct 关键字与class 关键字一般可以通用，只有一个很小的区别。struct
的成员默认情况下属性是public 的，而class 成员却是private 的。很多人觉得不好记，
其实很容易。你平时用结构体时用public 修饰它的成员了吗？既然struct 关键字与
class 关键字可以通用，你也不要认为结构体内不能放函数了。
当然，关于结构体的讨论远没有结束，在指针与数组那一章，你还会要和它打交道的。
1.16 union 关键字
union 关键字的用法与struct 的用法非常类似。
union 维护足够的空间来置放多个数据成员中的‚一种‛，而不是为每一个数据成员配
置空间，在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，
所有的数据成员具有相同的起始地址。例子如下：
union StateMachine
{
char character;
int number;
char *str;
double exp;
};
一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最
大长度是double 型态，所以StateMachine 的空间大小就是double 数据类型的大小。在
C++里，union 的成员默认属性页为public。union 主要用来压缩空间。如果一些数据不
可能在同一时间同时被用到，则可以使用union。
1.16.1 大小端模式对 union 类型数据的影响
下面再看一个例子：
union
{
int i;
char a[2];
}*p, u;
p =&u;
p->a[0] = 0x39;
p->a[1] = 0x38;
p.i 的值应该为多少呢？
这里需要考虑存储模式：大端模式和小端模式。
大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存
放在高地址中。
小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节
- 38 -
则存放在低地址中。
union 型数据所占的空间等于其最大的成员所占的空间。对union 型的成员的存取都
是相对于该联合体基地址的偏移量为0 处开始，也就是联合体的访问不论对哪个变量的存取
都是从union 的首地址位置开始。如此一解释，上面的问题是否已经有了答案呢？
1.16.2 如何用程序确认当前系统的存储模式？
上述问题似乎还比较简单，那来个有技术含量的：请写一个C 函数，若处理器是
Big_endian 的，则返回0；若是Little_endian 的，则返回1。
先分析一下，按照上面关于大小端模式的定义，假设int 类型变量i 被初始化为1。
以大端模式存储，其内存布局如下图：
以小端模式存储，其内存布局如下图：
变量i 占4 个字节，但只有一个字节的值为1，另外三个字节的值都为0。如果取出低
地址上的值为0，毫无疑问，这是大端模式；如果取出低地址上的值为1，毫无疑问，这是
小端模式。既然如此，我们完全可以利用union 类型数据的特点：所有成员的起始地址一
致。
到现在，应该知道怎么写了吧？参考答案如下：
int checkSystem( )
{
union check
{
int i;
char ch;
} c;
c.i = 1;
return (c.ch ==1);
}
现在你可以用这个函数来测试你当前系统的存储模式了。当然你也可以不用函数而直接
去查看内存来确定当前系统的存储模式。如下图：
- 39 -
图中0x01 的值存在低地址上，说明当前系统为小端模式。
不过要说明的一点是，某些系统可能同时支持这两种存储模式，你可以用硬件跳线或在
编译器的选项中设置其存储模式。
留个问题：
在x86 系统下，输出的值为多少？
#include 
intmain()
{
int a[5]={1,2,3,4,5};
int *ptr1=(int *)(&a+1);
int *ptr2=(int *)((int)a+1);
printf("%x,%x",ptr1[-1],*ptr2);
return 0;
}
1.17 enum 关键字
很多初学者对枚举(enum)感到迷惑，或者认为没什么用，其实枚举(enum)是个很有用
的数据类型。
1.17.1 枚举类型的使用方法
一般的定义方式如下：
enum enum_type_name
{
ENUM_CONST_1,
ENUM_CONST_2,
...
ENUM_CONST_n
} enum_variable_name;
注意：enum_type_name 是自定义的一种数据数据类型名，而enum_variable_name
- 40 -