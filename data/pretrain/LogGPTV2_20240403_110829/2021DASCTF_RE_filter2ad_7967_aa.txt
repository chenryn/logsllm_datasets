# 2021DASCTF 一月赛 RE部分
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
个人赛，最后总排名第三，AK了RE部分。
## decryption-100
> Try to decrypt me!
###  main函数
发现代码还原的很好，可以可清楚地看到整个逻辑
其中第一个限制就是要求输入的字符长度为32位，否则就会直接退出，然后通过一个加密函数把输入的内容加密，加密之后通过 **memcmp**
进行比对，这也是一种非常常见的RE模型，也就是让你还原 **encrypt** 的过程
###  encrypt函数
很清楚的可以发现一个特性，那么就是程序的加密过程都是 **单字节相关**
的，这意味着我们只需要逐字节的爆破比对就可以得到加密前的结果，由于这里伪代码是C的，所以我们考虑直接用C++编写爆破代码。
###  导出比对内容
双击进入比对的内容，发现没有识别为字节数组，我们按下 **小键盘的*键**
就可以转换为数组的形式显示
再按下 **Shift + E** ，就可以把内容都提取出来了
###  爆破程序
    #include 
    unsigned char _buf[] =
    {
      0x12, 0x45, 0x10, 0x47, 0x19, 0x49, 0x49, 0x49, 0x1A, 0x4F,
      0x1C, 0x1E, 0x52, 0x66, 0x1D, 0x52, 0x66, 0x67, 0x68, 0x67,
      0x65, 0x6F, 0x5F, 0x59, 0x58, 0x5E, 0x6D, 0x70, 0xA1, 0x6E,
      0x70, 0xA3
    };
    unsigned char ans[32];
    int main()
    {
        unsigned char v3; // [esp+8h] [ebp-8h]
        unsigned char v4; // [esp+Ah] [ebp-6h]
        unsigned char v5; // [esp+Bh] [ebp-5h]
        for (int i = 0; i  小红电脑上的文件被黑客加密了，只留下了一个解密程序，但需要支付比特币购买序列号才能使用，你能帮助小红破解这个程序吗？
压缩包给出了两个文件
用IDA打开后，发现这道题的符号信息基本上都被清楚了，故尝试用字符串进行搜索
查找引用找到对应位置
发现程序逻辑相当的复杂，但是还是大概可以看出和上一题类似的一个模型，就是通过先加密，然后再比对来进行验证。
###  加密函数
观察代码可以发现输入的内容都被传入了 **sub_401410** 函数进行进一步的加密。并且第一个参数接受加密后的内容，第二个参数传入要加密的内容。
对我们已知的变量名称进行重命名，并且对已知的类型进行重新操作后，我们可以得到一份比较舒服的伪代码
####  第一部分
虽然不知道他的那个while是在干什么，但是通过动态调试可以发现，这一段其实就在把你输入的16进制字符串转换为内部储存的字节形式。
也就是从输入内容的32位字符串，变成了16位字节。
####  第二部分
这里其实是一个for循环，直到idx == 16的时候结束，不过ida的伪代码识别成while循环了
也就是一个加密的过程，所做的事情就是把en1加密后的内容进行第二部分的加密，但是我也不清楚他干了啥，但是简单的一看可以发现几个特征
1.首先就是当前字节的内容和前后两个字节的内容相关，虽然单字节爆破变成了双字节，但是这个爆破范围还是能够在接受范围内的
2.通过这个代码，我们有16个未知数和16个等式，其实我们可以直接通过z3约束来解出结果。
####  第三部分
不知道这里这一块在干什么，但是经过测试可以发现这一块的内容所生成的数据都是固定的（不会受到输入数据的影响），所以我们可以不进行分析
####  第四部分
可以发现最后生成的key是固定的，我们所需要分析的就是 **sub_402B70**
函数了，他传入了en2，也就是我们之前加密的内容，并且传入了key（名字是我分析之后修改的）
进入分析之后发现，虽然代码相当的复杂，分析也毫无头绪
我们可以注意到这样的函数
加密程序往里面传入了固定的key值和长度16，我们非常有理由怀疑这里就是加密的主要逻辑
点进去分析就可以直接发现，其实这就是一个 **rc4加密**
这里说一点识别的窍门，但主要还是见得多就知道了
**rc4加密最显著的特征就是他的循环次数是256，在初始化的过程中会生成一个内容为0-255的数组（有些时候会直接赋值）**
而这里的循环的次数和循环内所干的事情都符合，并且我们可以发现他对传入的key的信息进行处理，所以我们就可以大胆的猜测这里是rc4
本来以为分析到这里应该也就差不多了，结果发现后面居然还有一层加密
加密后的内容传回到了encode_data中，并且又传递给了下一个函数。
这个函数我显然不是很脸熟，但是我通过 **Findcrypt** 插件找到了他的关键
可以发现在这个函数的内部实际上调用了
这部分的内容，所以我们大胆猜测这里其实就是AES加密，并且key的内容和rc4的key一致（正好两者要求也都是16位），v7也就是AES加密的iv。
到此加密函数就结束了
###  解密程序
我们需要完全的倒推内容
1.AES加密
2.RC4加密
3.可爆破的加密
最后得到的内容就是我们要输入的字节信息
程序中直接对第三步用z3约束进行求解（是真的好用）
其他的数据内容是通过动态调试提取得到的
    from Crypto.Cipher import AES, ARC4
    from z3 import *
    iv = bytes([0x6E, 0xD6, 0xCE, 0x61, 0xBB, 0x8F, 0xB7, 0xF3, 0x10, 0xB7, 0x70, 0x45, 0x9E, 0xFC, 0xE1, 0xB1])
    key = bytes([0x8C, 0xE5, 0x1F, 0x93, 0x50, 0xF4, 0x45, 0x11, 0xA8, 0x54, 0xE1, 0xB5, 0xF0, 0xA3, 0xFB, 0xCA])
    m = bytes([0x21, 0x23, 0x2F, 0x29, 0x7A, 0x57, 0xA5, 0xA7, 0x43, 0x89, 0x4A, 0x0E, 0x4A, 0x80, 0x1F, 0xC3])
    aes = AES.new(key, iv=iv, mode=AES.MODE_CBC)
    c = aes.encrypt(m)
    rc4 = ARC4.new(key)
    target = rc4.decrypt(c)
    solver = Solver()
    ans = [BitVec('u%d' % i, 8) for i in range(16)]
    for i in range(16):
        solver.add((32 * ans[(i + 15) % 16]) | (ans[i] >> 3) & 0x1F == ord(target[i:i+1]))
    solver.check()
    result = solver.model()
    input_data = ''.join('%02x' % result[ans[i]].as_long() for i in range(16))
    print(input_data)
## babyre-200
IDA打开之后
发现和一般的re题目不太一样，这道题目的加密函数似乎不是可以直接查看的，而是用了某种方式调用，但是最后的逻辑还是一样的，也就是通过比对加密后的内容最后判断是否正确
在各个函数中苦苦的寻找，最后终于找到一点可能是在加密的东西
###  反调试
他这里特意通过异或来动态解密，似乎就是再告诉我们这里在干一些见不得人的事情。
调试发现最后解密取出的地址是 **ZwSetInformationThreadi** 函数
百度搜索这个关键词发现这个似乎就是一种反调试操作
所以我们考虑把这里的调用函数操作给nop掉
从传参开始nop，并且保存内容，之后就可以正常调试了。
###  动态解密
观察后面的内容发现这道题是动态解密出Cipher.dll，不过我采用动态调试的方法，其实可以不用管解密的这部分内容
###  加密函数
我们就直接分析调用解密后代码的这一部分的内容即可
这部分就是重要的加密函数， **这里把数据前十六字节和后十六字节分段进行加密**
发现这一块内容因为是SMC生成的，所以IDA没有识别出来，我们按P手动转换成函数
接着不断的进入函数最后可以发现关键的内容
####  第一个循环
可以发现第一个循环动态生成了一个data数组，而这个数组的内容都是固定的，我们可以直接提取。
####  第二个循环
第二个循环的才是重要的加密内容，他通过一个循环进行不断的迭代，并且可以发现其中的
v5[0] – v5[3]的内容就是我们输入的前16个
而迭代的最后四位v5[32]-v5[35]的内容就是最后加密得到的内容，我们暂且先不管encode函数内部实现如何。
可以发现，我们encode函数传入的参数完全是已知的的内容，我们只需要有encode函数正向的计算代码，就可以从后往前推出所有的内容
###  encode函数
我们只需要正向的编写encode函数的代码即可，所以不需要复杂的分析，不过我这里还是说明一下吧，这个函数取出了参数的每一位bytes，并且作为下标找到相应的key数组中的内容赋值给data数组，最后又通过函数把data数组的内容转换为int，再用get函数异或一下。这个过程虽然很复杂，但是不要求逆向就无所谓了。
###  解密程序
    #include 
    unsigned int encode_data[8] =
    {
        0xB75863EA, 0xE9A1E28C, 0x538F29C5, 0x593208E8, 0xAE671BAF, 0xC4CFDAD9, 0xECB1FF72, 0x06F37376
    };
    unsigned int data[33] =
    {
        0xC05103FD, 0xD1DBA4A4, 0xB693F50A, 0xB3A4E3B7, 0xA15183E9, 0x75562A4D, 0x25B5EC04, 0xC6C71137,
        0x0CB9B0C9, 0xD7F95262, 0x618D8F3A, 0xB12AAC90, 0x6F024009, 0x3C317396, 0xECB905CB, 0xEBBA737B,
        0x189CDA0F, 0xB35E97F2, 0xA459666D, 0x7438091C, 0x61A02896, 0xDB905062, 0xBDA9F172, 0x4531376F,
        0x634C619D, 0xD37BD2FB, 0xDB3DFBC3, 0xE88EF7F2, 0x37E2C886, 0x2DF2AC0C, 0xE58F0D02, 0xF5CA718D,
        0xEFE40BDF
    };
    unsigned char key[] =
    {
      0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6,
      0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76,
      0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86,
      0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A,
      0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3,
      0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA,
      0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73,
      0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8,
      0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB,