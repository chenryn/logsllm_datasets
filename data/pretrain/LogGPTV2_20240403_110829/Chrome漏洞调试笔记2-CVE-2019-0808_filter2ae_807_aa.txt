# Chrome漏洞调试笔记2-CVE-2019-0808
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
在《Chrome漏洞调试笔记1-CVE-2019-5768》中，笔者介绍了2019年出现的一个Chrome浏览器在野漏洞的原理和利用方法。文末通过关闭Chrome沙箱的方法（–no-sandbox）演示了渲染进程中Shellcode的执行。但是在实际利用中，由于Chrome浏览器的渲染进程受到沙箱模块的保护，像blink或者v8这些在渲染进程中模块的漏洞即使被利用，也难以穿过沙箱。因此在实际利用中，仍需要寻找其他方法穿过Chrome的沙箱。
我们知道，Chrome基于多进程架构，主要包括浏览器进程和渲染进程，进程间通过IPC通信（Mojo）:
其中渲染进程运行着不可信的HTML和JS代码，浏览器中的每一个tab为一个独立的进程，运行在Untrusted的低权限等级，并通过沙箱引擎隔离。因此像CVE-2019-5768这样的渲染进程中的远程代码执行漏洞仍需要结合其他高权限漏洞实现沙箱逃逸。一般来说有几种思路：1）利用浏览器进程的漏洞，比如IndexedDB，Mojo等；
2）利用操作系统内核漏洞，比如与CVE-2019-5768组合的win32k.sys内核提权漏洞CVE-2019-0808。
## 0x0 漏洞原理分析
CVE-2019-0808是win32k.sys中的一个空指针解引用漏洞。根据360的Blog，漏洞存在于win32k！xxxMNMouseMove函数中：
首先分析xxxMNMouseMove函数：
可以看到，xxxMNMouseMove函数中首先通过xxxMNFindWindowFromPoint函数根据当前输入坐标返回对应的窗口对象，然后通过xxxMNUpdateDraggingInfo函数更新窗口拖动信息。跟进分析xxxMNFindWindowFromPoint函数：
这里通过xxxSendMessage函数像用户态发送WM_MN_FINDMENUWINDOWFROMPOINT（0x1EB）消息获取窗口句柄，并通过HMValidateHandleNoSecure函数将窗口句柄转为内核态窗口对象返回xxxMNMouseMove函数。
继续跟进xxxMNUpdateDraggingInfo函数：
xxxMNUpdateDraggingInfo函数内部首先调用MNGetpItem根据pMENUSTATE_->uDraggingIndex返回对应的tagITEM，跟进MNGetpItem函数：
MNGetpItem函数参数中pPopupMenu指向的就是xxxMNFindWindowFromPoint返回的窗口对象tagWND（tagMENUWND）+0xb0保存的弹出菜单tagPOPUPMENU，tagPOPUPMENU的spmenu属性指向其对应的菜单对象tagMenu。注意到pPopupMenu是通过xxxSendMessage返回的，这里在访问pPopupMenu->spmenu的cItems属性时，并没有对pPopupMenu->spmenu指针进行空指针检查。如果可以通过xxxSendMessage返回一个用户态伪造的pPopupMenu->spmenu
= NULL，那么这里就存在一处空指针解引用漏洞。而空指针解引用漏洞在Win7环境中是可以通过分配零页内存利用的。
那么如何返回一个(tagMENUWND +0xb0)->pPopupMenu->spmenu =
NULL的窗口对象呢，关键在于xxxMNFindWindowFromPoint函数中的xxxSendMessage函数调用。Windows
API提供了SetWindowsHookEx和SetWinEventHook这样的消息/事件钩子API用来截获窗口的消息/事件，因此可以通过设置SetWindowsHookEx和SetWinEventHook函数利用xxxSendMessage向用户态发送WM_MN_FINDMENUWINDOWFROMPOINT消息的机会，创造一个内核态到用户态的回调，从而打破内核态中xxxMNMouseMove中的原子操作，返回用户态伪造的窗口对象。
具体PoC构造如下：
  1. 获取user32! NtUserMNDragOver函数地址
win32k!xxxMNMouseMove由win32k!xxxMNDragOver调用，而win32k!xxxMNDragOver由用户态user32!
NtUserMNDragOver调用。由于user32! NtUserMNDragOver未导出，因此可以通过user32!
NtUserMNDragOver附近导出函数地址+偏移的方式获取。这里选择user32! NtUserMenuItemFromPoint：
可以看到，user32! NtUserMNDragOver在user32! NtUserMenuItemFromPoint + 0x3A处，对应PoC代码：
当然也可以通过内联汇编的方式直接调用syscall：
这里11ED是NtUserMNDragOver对应的syscall编码，[7FFE0300h]保存的是ntdll!KiFastSystemCall函数地址。
  2. 创建两个非模态可拖放的弹出菜单
这里分别创建两个非模态可拖放的弹出菜单Root和子菜单Sub。
  3. 创建伪造菜单窗口对象
根据MSDN，”#32768″为系统使用的ClassName，直接调用后创建的菜单窗口对象属性tagPOPUPMENU->spmenu =
NULL，满足漏洞触发条件：
  4. 创建主窗口
  5. Hook WH_CALLWNDPROC消息和EVENT_SYSTEM_MENUPOPUPSTART事件
  6. 显示弹出菜单窗口
TrackPopupMenuEx会调用内核函数xxxTrackPopupMenuEx。xxxTrackPopupMenuEx首先会调用xxxCreateWindowEx创建菜单对象tagMENU对应的窗口对象tagWND（tagMENUWND）和弹出菜单窗口对象tagPOPUPMENU，其中tagWND+0xb0
-> tagPOPUPMENU，tagPOPUPMENU + 0x8 -> tagWND（spwndPopupMenu）， tagPOPUPMENU +
0x14 ->
tagMENU（spmenu）；接着调用xxxSetWindowPos设置菜单窗口的坐标；最后调用xxxWindowEvent发送EVENT_SYSTEM_MENUPOPUPSTART事件表示菜单弹出开始。
  7. 处理窗口消息循环，等待条件触发漏洞
当主线程进入窗口消息循环后，因为xxxTrackPopupMenuEx发送事件EVENT_SYSTEM_MENUPOPUPSTART，且EVENT_SYSTEM_MENUPOPUPSTART事件被SetWinEventHook函数Hook，用户态函数DisplayEventProc第一次被调用：
此时iMenuCreated = 0，触发case
0分支，发送鼠标左键按下消息，从而子菜单sub弹出，再次触发EVENT_SYSTEM_MENUPOPUPSTART事件并第二次调用DisplayEventProc函数。第二次iMenuCreated
= 1，触发case 1分支，发送鼠标移动消息，返回前iMenuCreated++ = 2满足消息循环中的if (iMenuCreated >=
1)分支。由于两次调用DisplayEventProc形成了鼠标拖动的操作，最终进入xxxMNMouseMove函数触发漏洞。
根据前面的分析，xxxMNMouseMove函数内部的xxxMNFindWindowFromPoint函数通过xxxSendMessage发送WM_MN_FINDMENUWINDOWFROMPOINT消息。由于窗口消息WH_CALLWNDPROC被SetWindowsHookEx函数Hook，从而触发WindowHookProc中if分支代码的调用：
该if分支中通过SetWindowLongPtr替换窗口的默认过程函数DefWindowProc为SubMenuProc，从而进入SubMenuProc：
SubMenuProc最终返回用户态构造的窗口对象句柄hWndFakeMenu作为xxxMNFindWindowFromPoint函数调用xxxSendMessage的返回值，最终得到一个pPopupMenu->spmenu
= NULL的空指针。
动态调试过程如下：
用户态构造的弹出菜单窗口句柄：
在win32k!xxxMNFindWindowFromPoint函数call
win32k!xxxSendMessage前下断点，检查xxxSendMessage调用后的返回值：
可以看到返回的正是用户态构造的窗口对象句柄0x00020284。继续步过，win32k!HMValidateHandleNoSecure返回对应的内核对象tagWND地址0xfea22310。根据之前的分析，tagWND+0xb0
-> tagPOPUPMENU=0xfda091c0 ,而tagPOPUPMENU+0x14->spmenu = NULL满足漏洞触发要求：
继续执行，进入xxxMNUpdateDraggingInfo函数的MNGetpItem函数，因为此时spmenu（ecx）=
NULL，从而触发空指针解引用异常，最终导致BSOD：
## 0x1 寻找利用点
对于内核态的空指针解引用漏洞，Win7中用户态可以通过ntdll!NtAllocateVirtualMemory函数分配零页内存利用。分配零页内存的原理比较简单，不再详述：
具体分析分配零页内存后代码执行的流程，寻找后续可利用点：
可以看到在分配零页内存后，pMenu->cItems [0x00000020] =