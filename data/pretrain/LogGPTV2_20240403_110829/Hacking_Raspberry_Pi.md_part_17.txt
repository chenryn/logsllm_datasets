Well first of all, remember that RetroPie uses Raspbian under the hood as the host operating system,
so your first order of business is to run sudo raspi-config and perform the initial setup of the device.
If you need a refresher, just take a look back at the raspi-config sections in Chapter 4.
Next, you should update the system software and reboot:
Click here to view code image
sudo apt-get update && sudo apt-get upgrade
sudo reboot
Note: Enhancing Performance
You might also want to consider adjusting the Pi’s memory split to favor graphics over
processor performance, as well as enabling overclocking. I cover both of these subjects in
exhaustive detail in Chapter 18, “Raspberry Pi Overclocking.”
As you know, Raspbian enables Secure Shell (SSH) connections by default. Thus, you can use a
Secure Copy (SCP) utility to transfer ROM files to the Pi.
Task: Transferring ROMs to Your Raspberry Pi
1. On your Raspberry Pi, if you are in Emulation Station, press F4 to exit to a Terminal
prompt. Next, type ifconfig eth0 to obtain the Pi’s IP address.
2. On a remote computer that hosts your ROM files, use FileZilla, Cyberduck
(http://is.gd/JDzRgw), or another SFTP client tool to connect to your Pi. Be sure to
specify SFTP, and not FTP, as the connection method.
The default username and password are the ones you would expect: username, pi;
password, raspberry.
Take a look at Figure 13.3 to see how I set up my connection in FileZilla. To create a
new stored connection, open FileZilla and click File, Site Manager, New Site.
FIGURE 13.3 FileZilla enables you to store connection information permanently for
convenience.
3. Navigate to the path /home/pi/RetroPie/roms. You see that RetroPie creates folders to
store ROMs for all its supported console video game platforms.
4. You can now drag and drop your ROM files into the appropriate subfolders. Note that
you need to upload the actual binary ROM files to the Pi. For instance, NES ROMs
typically have the .nes file extension, but Atari 2600 ROMs usually employ the .bin file
extension. You can see my system in Figure 13.4.
FIGURE 13.4 Here you can see where ROMs should be stored on your RetroPie machine.
5. You can start Emulation Station from the Terminal prompt of your Pi by issuing the
following simple command:
emulationstation
Remember that Linux is case-sensitive; thus EmulationStation or
EMULATIONSTATION generate errors, but not Emulation Station.
By default, Emulation Station/RetroPie includes the following games:
Cave Story
Doom
Duke Nukem 3D (demo)
You can also start the LinApple Apple II emulator (http://is.gd/Ea0UUT) and the rpix86 DOS 5.0
emulator (http://is.gd/1vGqRY) and run old Apple II games.
You can use your mapped LEFT and RIGHT controls to switch among the installed games and use
your mapped ACCEPT button to start one. More on gameplay later, though—one step at a time!
If you run into any expected results in the ROM detection process, your first step should be to open up
the ~/.emulationstation/es_systems.cfg configuration file for editing.
The two parameters you want to watch for are
PATH: This is the default location where Emulation Station expects to find game ROMs for
each platform. If this is set incorrectly, you won’t be able to see your games.
EXTENSION: You need to ensure that your game ROMs all have one of the supported file
extensions for detection to complete properly. For instance, the most common Atari 2600 ROM
file extensions are .bin, .img, and .z26. NES file extensions are typically, reasonably enough,
.nes.
Note: Showing File Extensions in Windows
In Windows 7 or Windows 8, file extensions are hidden by default. To show them, open
the Folder Options Control Panel and navigate to the View tab. Under Advanced Settings:,
enable the option Hide extensions for known file types and click OK to confirm the change.
In OS X, choose Finder > Preferences, and then navigate to the Advanced pane. Next,
enable the option Show all filename extensions.
If you make any changes to the file, don’t forget to save your changes and reboot your Pi before
attempting another scrape.
Before I get to playing games (I know you are as excited to do that as I am), let’s revisit how to tweak
up the keyboard and, more importantly, the joystick controls.
Setting Up Your Controls
Emulation Station is optimized for joystick/gamepad-based control. However, for the sake of
completeness I want to show you how to edit the keyboard mappings.
From Emulation Station, press F4 to exit to a Terminal prompt. The RetroPie controls (all of them,
keyboard and joystick) are stored in a configuration file named retroarch.cfg. Use the following
command to edit the file:
Click here to view code image
sudo nano ~/RetroPie/configs/all/retroarch.cfg
Of course, you can also use your SFTP utility to download a copy of the file to your remote computer,
edit the file using your favorite text editor, and reupload the file to the Pi, overwriting the old version.
In any event, look for the line that starts with # Keyboard input. You can edit the key mapping values
directly here; look at Figure 13.5 to see my setup.
FIGURE 13.5 The retroarch.cfg file is where all RetroPie control defaults are stored.
Note: Extra, Extra, Read All About It!
You should study the full contents of the retroarch.cfg file because you can actually
make some pretty cool changes to RetroPie. For instance, visit the #Saves state section to
customize key or joystick mappings to save and load game state. Very useful!
Now let’s turn our attention to joystick mappings.
Task: Configure RetroPie Joystick Control Mappings
You can use the retroarch-joyconfig utility to customize joystick mappings. Let’s do that
now.
1. From the Terminal prompt on your RetroPie computer, navigate to the appropriate
directory location.
Click here to view code image
cd ~/RetroPie/emulators/RetroArch/tools
2. If you run retroarch-joyconfig with no parameters, the results of your configuration are
dumped to the screen but are not saved in the retroarch.cfg file. That isn’t cool. Thus, you
need to redirect the output of the retroarch-joyconfig program directly to the retroarch.cfg
file like so:
Click here to view code image
./retroarch-joyconfig >> ~/RetroPie/configs/all/retroarch.cfg
3. You are prompted to assign bindings for each command; do so by pressing the
appropriate button on your joystick. A screen capture (not the greatest) of my monitor is
shown in Figure 13.6.
FIGURE 13.6 Establishing your joystick key bindings
You can always edit the retroarch.cfg file afterward to remove or comment out lines that aren’t
relevant to your joystick. To comment out (and therefore nullify without deleting) an entry, simply
prepend the line with an octothorpe (#) character.
There’s one more edit you should consider making to retroarch.cfg because you should definitely add
a joystick mapping that allows you to exit your active emulator and return to Emulation Station. After
all, you shouldn’t have to reboot the Pi to revisit your game menus.
Note: Don’t Forget StartX
If you don’t like using nano or another text-based text editor, you can always type
startx and use the GUI tools in LXDE to accomplish your RetroPie configuration. Just
remember to dump X and return to the Terminal shell when you’re finished. (As a reminder
for doing so, you can click the red Power button in the lower right corner of LXPanel.)
Go to the end of the retroarch.cfg file and add the following two lines:
Click here to view code image
input_enable_hotkey_btn = "X"
input_exit_emulator_btn="Y"
Substitute X and Y for two joystick buttons that you’ll press simultaneously to exit the emulator and
return to Emulation Station. (And don’t forget what you selected!)
Playing Your Games
If you haven’t already done so, reboot your Raspberry Pi or type emulationstation from the Terminal
prompt to start Emulation Station. Here’s the deal:
Use the LEFT and RIGHT controls to scroll through the emulator menus: You only see an
entry for emulators that actually contain ROMs. Thus, on my system I have game lists for Atari
2600 and NES because I uploaded ROMs for those platforms.
Use the UP and DOWN controls to scroll through the game menus, and use the ACCEPT
and SELECT controls to launch and start games: If you mapped the PAGE UP, PAGE
DOWN, or START WITH LETTER mappings, it makes it easier to locate games in huge ROM
lists.
Use ESC or whatever custom joystick mapping you specified to exit the emulator and
return to Emulation Station: This is a particularly important option because you should be
able to return to Emulation Station without having to reboot the Raspberry Pi.
Figure 13.7 shows you a typical game screen.
FIGURE 13.7 This is Super Mario Brothers, one of the most popular video games of all time.
I’ve found that the performance of the retro video games is (at least) as good as it is on original
hardware. Does that surprise you? Think of it this way: Even the Model A Raspberry Pi board is
orders of magnitude more powerful than, say, the Atari 2600 or the NES (SNES, for that matter).
One thing—you might be put off by the slightly warped display of old 8-bit games on your widescreen
monitor. By default, the games fill the entire screen. To tweak up the emulator resolution, open
retroarch.cfg for editing, and check out the #### Video section.
Notice that most of the configuration entries are commented out (that is to say, deactivated). To
activate an option, simply remove the octothorpe (#) preceding the appropriate line.
Installing Useful Add-Ons
In Chapter 12, “Raspberry Pi Media Center,” you learned how useful media scrapers are to fill in the
blanks on media content. Did you know that you can use media scrapers with your retro video game
ROMs as well?
Yes, indeed. Not only can you play your favorite old-school games, but you can see the original box
art, learn trivia about the game’s history, and much more.
To truly dig into all possible retro video game goodness, let me show you how to install the ES-
scraper utility to scrape your ROM directories and download box art and game descriptions.
Task: Install ES-Scraper
1. From Terminal on your Raspberry Pi, navigate to the appropriate directory:
Click here to view code image
cd (to ensure you're in your home directory)
cd RetroPie/supplementary
2. Create a local copy of the ES-scraper online repository and run the RetroPie setup Linux
shell script:
Click here to view code image
git clone http://github.com/elpender/ES-scraper
cd
cd RetroPie-Setup
sudo ./retropie_setup.sh
3. When you’re in the RetroPie Setup utility, use the Tab, number, and Enter keys to
navigate the text menus.
In the Choose installation either based on binaries or on sources dialog, select Setup
(only if you already have run one of these installations).
4. In the Choose task dialog, select Run ‘ES-scraper’ as shown in Figure 13.8.
FIGURE 13.8 You can force a game ROM metadata scrape from within the RetroPie Setup
script.
5. Select (Re-)scrape of the ROMs directory to perform an immediate ROM discovery and
metadata download.
The time required for ES-Scraper to complete its metadata scrape and resource download depends on
the number and type of game ROMs you have available on your Raspberry Pi.
When the process is complete, you can cancel out of the RetroPie Setup script, reboot your Pi, and
enjoy the new artwork! An example of downloaded game descriptions and box art is shown in Figure
13.9.
FIGURE 13.9 The downloaded box art and game description data makes browsing your ROM
collection that much more enjoyable.
In Search of the Perfect Joystick
In my experience, RetroPie does an excellent job of detecting your USB joystick or gamepad. I have
used many, many game controllers over the years, and for my money nothing beats my old Logitech
Rumblepad 2, which employs the classic Playstation/PS2 form factor.
Note: In Case You Wondered...
If you’ve wondered throughout this chapter, “What’s the difference between a gamepad
and a joystick?” let me clear up any residual confusion. A gamepad, also called a joypad,
is a game controller that is typically operated with two hands. Gamepads usually have an 8-
way digital pad (d-pad) as well as one or two analog sticks. By contrast, a joystick consists
of a single 8-way or analog control handle, with or without additional action buttons or
triggers.
On the other hand, many retro video game purists want to enjoy their favorite emulated games by
using either a reproduction or original controller from the original consoles. Quality varies widely
for the USB reproductions; most of us prefer adapters that transform the proprietary controller plugs
into USB. In Figure 13.10 you can see a mashup of some of my favorite video game controllers.
FIGURE 13.10 Some of my favorite video game controllers: (1) Logitech Rumblepad 2; (2)
Atari 2600; (3) SNES; (4) Sega Genesis.
RetroZone (http://is.gd/Cs2GKf) sells USB adapters for the following console video game
controllers:
Atari 2600
NES
Nintendo 64
Sega Genesis
SNES
Please note that you still need to purchase the original controller in addition to buying an adapter.
They don’t all rate so well among hardcore classic gamers, but some companies produce
reproductions of old controllers with native USB connectivity:
Tomee NES USB Controller (http://is.gd/DkrM9c)
Tomee SNES USB Controller (http://is.gd/kEZg3P)
Retrolink NES USB Controller (http://is.gd/1kuzKi)
Retrolink SNES USB Controller (http://is.gd/PJUB0h)
Retrolink Nintendo 64 USB Controller (http://is.gd/68XUFP)
Retrolink “Classic Controller” (modeled on Sega Genesis controller) (http://is.gd/3HzHns)
The people behind the Retropie Project have developed a GPIO adapter for the original Super
Nintendo Entertainment Center (SNES) controllers. You can get all of the details and assembly
instructions at their website at http://is.gd/clRqqZ.
As you can see (at least in part) in Figure 13.11, the unit consists of an adapter PCB, two SNES
connectors, a couple ribbon cables, and a ribbon crimp connector.
FIGURE 13.11 The PetRockBlog RetroPie GPIO Adapter
The GPIO adapter includes an extra tactile pushbutton that can be useful, for instance, to map to the
EXIT EMULATOR command, which of course allows you to cleanly close the emulator.
From the looks of their documentation, the mapping between the SNES controller pinout and the
Raspberry Pi pinout is pretty straightforward. Check out Figure 13.12 to judge for yourself. Basically
you are soldering each SNES connector lead to a ribbon cable, which in turn connects to particular
pins on the Raspberry Pi GPIO header.
FIGURE 13.12 RetroPie GPIO Adapter pinout schematic
If you can catch them while they have units in stock, the PetRockBlog also sells fully assembled units
for $18.40 USD. All you have to do with the purchased units is to solder the SNES controller
connectors to the included ribbon cable.
Chapter 14. Raspberry Pi Minecraft Server
Minecraft, a sandbox construction game originally created by the Swedish programmer Markkus
“Notch” Persson (http://is.gd/Y7W6Gy) and later absorbed by Notch’s company Mojang AB
(http://is.gd/07x9Au), is more than a game: It is a phenomenon. In a gaming context, “sandbox” means
that the game has no defined storyline; instead, players can roam around the game world and do pretty
much whatever they want (see Figure 14.1).
FIGURE 14.1 Minecraft 1.5.2 for Microsoft Windows
As a game developer you know you are onto something when your product is used in school as well
as home, and gamers collaborate with each other and lose sleep playing it.
Retro video game nerds such as myself deeply appreciate the chunky 8-bit graphics. In fact, the visual
presentation of Minecraft reminds me of a cross between Super Mario Brothers for the Nintendo
Entertainment System and Doom for the PC.
As the game title suggests, the two main tasks in Minecraft are mining, which involves breaking
various and sundry ore blocks in search of useful raw materials, and crafting, which means taking
mined raw materials and fashioning tools, weapons, furniture, food...you name it.
Minecraft includes two primary game modes:
Survival: The player’s avatar can die, and the world is inhabited by enemy nonplayer
characters (NPCs) called mobs that can destroy the player. The player also starts with no tools
or raw materials but can install other user-made modifications (mods) to change how the game
world works. The focus on this mode is on exploration, combat, resource gathering, and
construction.
Creative: The player’s avatar cannot die and is capable of flight. No mobs exist in this world.
The player’s inventory includes all items found in the game, including materials, eggs, potions,
and so forth. Because Creative mode involves no combat and has no need to forage for tools
and resources, the focus here is on creative construction.
Minecraft includes two additional gameplay modes, Adventure and Hardcore, that aren’t completely
fleshed out as of this writing in summer 2013. You can read more about Minecraft game modes by
visiting the Minecraft Wiki at http://is.gd/8kEFWj.
Note: Learn How to Play Minecraft
In this chapter, I provide only the most cursory of introductions to Minecraft and
assume you have at least a passing familiarity with its gameplay. For a complete
introduction to the game, please read my Pearson colleague Stephen O’Brien’s excellent
book (which I tech-edited it, in fact), The Ultimate Player’s Guide to Minecraft
(http://is.gd/yvXXbl).
In general, I think the main reasons why Minecraft is so popular are the following:
Players can assert and flex their creativity.
The game enables players to create objects and share them with other players around the
world.
The game is extensible, allowing proficient players to broaden and deepen the game world.
Minecraft is also used in primary, secondary, and higher education. Why? Let’s count some of the
ways:
The game teaches problem-solving skills in a manner that is engaging and fun.
It teaches players how to use code to modify the behavior of a system (modding; more on that
subject later).
The game itself can be used as an instructional tool. For instance, a teacher can build lessons
inside a shared Minecraft game world, and the students can interact with the lesson as avatars.
The Mojang business model for Minecraft is to give players what they want and port the game to as
many different computing platforms as possible. Check it out:
Minecraft: The original game is coded in Java and runs on Windows, OS X, and Linux.
Minecraft-Pocket Edition: This is a heavily scaled-back edition of Minecraft that is coded in
C++ and runs on iOS (iPhone, iPod touch, iPad) and Android.
Minecraft: Xbox 360 Edition: This is not only the full version of Minecraft, but the game also
includes several features that are specific to the Xbox 360 port, such as simpler crafting
mechanics, in-game tutorials, and robust split-screen and Internet multiplayer gaming.
Minecraft: Pi Edition: This is an educational Minecraft port that is largely unlocked and
allows the gamer much greater control over the game world compared to the other editions of
the game.
Naturally, this book is all about the Raspberry Pi, so I am constraining the discussion in the remainder
of this chapter to Minecraft: Pi Edition.
The Minecraft server forms the basis of the multiplayer aspect of the game. Therefore, I also cover
how to build a Raspberry Pi-powered Minecraft game server.
Let’s get to work!