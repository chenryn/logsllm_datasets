Baseline
Stateful (w/o valid)
Stateful
Min Max Median
790
772
1527
1482
2447
2400
540
500
822
846
925
899
170
165
193
189
225
210
543
580
1371
1344
2037
1978
614
589
798
759
1003
1026
1156
1559
2671
590
929
1024
178
205
230
803
1562
2080
627
829
1040
Mean
843.40
1525.93
2468.70
539.87
847.90
930.60
179.53
194.17
223.86
617.70
1381.80
2034.90
611.93
797.93
1024.10
95% CI lower
786
1515
2436
532
842
917
169
190
222
563
1364
2019
608
794
1021
95% CI upper
797
1536
2464
548
853
937
171
198
225
646
1382
2056
618
806
1028
Var
13490.17
361.13
4813.61
334.12
368.76
633.91
8.50
23.50
16.44
5687.81
1549.76
807.22
104.86
226.66
93.76
p-value
1.42E-11
N/A
1.42E-11
1.42E-11
N/A
6.26E-11
1.26E-11
N/A
1.27E-11
1.43E-11
N/A
1.42E-11
1.42E-11
N/A
1.41E-11
Table 6: Syscall coverage. The number of unique syscalls in the vanilla sequence are given in the “Application” column. p-values
are calculated by comparing with the Stateful (w/o valid) setting. We tabulate the range, averages, conﬁdence intervals and
variance
B. Effects of Valid Values
VII. LIMITATIONS
Here, we compare the Stateful strategy with and without
valid values from the Value Extractor. Our experiments show
that the inclusion of values in the value set also leads to greater
syscall coverage and core dumps, though in general not to
the extent that using Stateful as opposed to Fuzz-all target
selection does. For example, in OpenSSH, a poll syscall
will never be reached unless the previous read syscall returns
EAGAIN or EWOULDBLOCK. The EAGAIN in the valid set of
read’s return value will help trigger this syscall.
In summary, our evaluation shows that both Value Ex-
traction and Stateful target-selection contribute to increased
syscall coverage and more core dumps being found. While
they require a longer time to achieve results due to the larger
number of targets, they are better able to make use of additional
computational resources, on average increasing the syscall
coverage by 2.1× and number of core dumps found by 2.4×.
As a fuzzing tool, Emilia has some limitations. First,
it only fuzzes the syscall return values but not
inputs to
the application, which limits the code Emilia can cover. We
believe it would be straightforward to combine Emilia with a
standard input fuzzer to achieve both code coverage and syscall
coverage. Second, Emilia requires source code to generate the
valid value sets, and the number of unique crashes found does
not increase a lot by adding valid values (Table 5). This is
because not all values in the valid set are useful for ﬁnding
new syscall invocations due to our coarse-grained static value
extractor. Emilia currently also does not associate values from
the Value Extractor with speciﬁc invocations, but only with the
syscall type (i.e., syscall number). When we cannot associate
a value with a speciﬁc syscall type, Emilia adds the value to
the valid set of all syscalls. Third, Emilia only uses the stack
hash to identify syscall invocations but not the arguments. As
a result, if return value handling is different based on different
syscall arguments, Emilia may miss some Iago vulnerabilities.
14
(a) Openssh
(b) Redis
(c) Curl
(d) Lighttpd
Figure 2: Crashes found over time. Solid lines are medians; dashed lines are max/min; Yellow and cyan lines are conﬁdence
intervals for stateful (w/o valid) and baseline settings
(e) Memcached
15
VIII. RELATED WORK
REFERENCES
A review of previous OFLs is given in Section V. Here,
we focus on prior work in detecting and analyzing systems for
Iago vulnerabilities.
Hong Hu et al. [13] studied the memory access vulner-
abilities leading to arbitrary code execution despite privilege
separation mechanisms that divide software into trusted and
untrusted partitions. If the OS kernel is considered as the
untrusted one, then it matches the Iago attack model. They
use binary level symbolic execution and dynamic taint analysis
to detect invalid memory access introduced by data received
through the untrusted interface. Their ﬁne-grained analysis
could also analyze the capability of the attacker for each
vulnerability found. However, symbolic execution suffers from
path explosion, and their work was only evaluated on simple
programs or function level. In 2019, Jo Van Bulck et al. [41]
analyzed responsibilities and attack vectors of a TEE shielding
runtime. They generalized Iago attacks from the OS syscall
interface to OCALLS in general, and detected Iago vulner-
abilities in Graphene-SGX [40] and SGX-LKL [33] similar
to the one we found in Google Asylo. Their work is more
like a guideline, and all
the analysis was done manually.
COIN attacks [20] describe Iago attacks as a subset of input
manipulation against the SGX enclave’s untrusted interfaces.
They use symbolic execution and several policies to identify
vulnerabilities caused by OCALL return values. Their work
aims to detect errors in existing SGX projects, which are
aware of the malicious OS. In contrast, we focus on legacy
applications, and seek to provide guidelines for porting them.
Moreover, we are the ﬁrst to use fuzzing to detect Iago attacks,
which can apply to large applications.
IX. CONCLUSION
Using Emilia, developed as part of this work, we were able
to ascertain a base rate of Iago vulnerabilities over a set of 17
diverse legacy applications and libraries. We ﬁnd and detect 51
Iago vulnerabilities, and note that they are widespread, with
nearly every application or library having at least one vul-
nerability. Categorizing the vulnerabilities into Static, Local,
Stateful, Unauthenticated Channel and External classes, we
ﬁnd that 82.4% are Static and Local vulnerabilities, which
can be easily mitigated by an OFL using simple, stateless
checks. Our analysis of current, state-of-the-art OFLs and SGX
applications shows that the majority do not completely mitigate
all Static and Local vulnerabilities in legacy applications,
suggesting that OFLs may beneﬁt from research into how
to systematically check for and detect attacks against these
vulnerabilities. Finally, our results show that using Stateful
target-selection and Value Extraction Emilia is able to achieve
syscall coverage signiﬁcantly better than a baseline fuzzer that
does not use these features.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their insightful
suggestions and comments. We would also like to thank Sibin
Mohan, Raskesh Bobba, Somesh Jha, Tom Reps, Austin Kuo,
Wei Huang, Shengjie Xu and He Shuang for their suggestions
and feedback, which helped improve our research. This re-
search was supported by ONR Award N00014-17-1-2889 and
NSERC Discovery Grant RGPIN-2018-05931.
[1] ARM Security technology: Building a secure system using TrustZone
technology (white paper), ARM Ltd, 2009.
[2] S. Arnautov, B. Trach, F. Gregor, T. Knauth, A. Martin, C. Priebe,
J. Lind, D. Muthukumaran, D. O’keeffe, M. L. Stillwell et al., “SCONE:
Secure linux containers with Intel SGX,” in 12th USENIX Symposium
on Operating Systems Design and Implementation (OSDI’16), Savan-
nah, GA, USA, 2016, pp. 689–703.
[3] A. Baumann, M. Peinado, and G. Hunt, “Shielding applications from an
untrusted cloud with haven,” ACM Transactions on Computer Systems
(TOCS), vol. 33, no. 3, pp. 1–26, 2015.
[4] S. Checkoway and H. Shacham, “Iago attacks: Why the system call
API is a bad untrusted RPC interface,” SIGPLAN Not., vol. 48, no. 4,
pp. 253–264, Mar. 2013.
[5] X. Chen, T. Garﬁnkel, E. C. Lewis, P. Subrahmanyam, C. A. Wald-
spurger, D. Boneh, J. Dwoskin, and D. R. Ports, “Overshadow: A
virtualization-based approach to retroﬁtting protection in commodity
operating systems,” SIGPLAN Not., vol. 43, no. 3, pp. 2–13, Mar. 2008.
[6] Y. Cheng, X. Ding, and R. Deng, “Appshield: Protecting applications
against untrusted operating system,” Singaport Management University
Technical Report, SMU-SIS-13, vol. 101, 2013.
J. Criswell, N. Dautenhahn, and V. Adve, “Virtual ghost: Protecting
applications from hostile operating systems,” in Proceedings of the 19th
International Conference on Architectural Support for Programming
Languages and Operating Systems (ASPLOS’14), Salt Lake City, UT,
USA, 2014, pp. 81–96.
J. de Ruiter and E. Poll, “Protocol state fuzzing of TLS implemen-
tations,” in 24th USENIX Security Symposium (USENIX Security’15),
Washington, D.C., USA, 2015, pp. 193–206.
[7]
[8]
[9] Asylo, Google, available at https://asylo.dev [Accessed December 30,
2020].
J. Greene, Intel Trusted Execution Technology, white paper, Intel
Corporation, 2012.
[10]
[11] L. Guan, P. Liu, X. Xing, X. Ge, S. Zhang, M. Yu, and T. Jaeger,
“Trustshadow: Secure execution of unmodiﬁed applications with ARM
TrustZone,” in 15th Annual International Conference on Mobile Sys-
tems, Applications, and Services (MobiSys’17), Niagara Falls, NY, USA,
2017, pp. 488–501.
[12] O. S. Hofmann, S. Kim, A. M. Dunn, M. Z. Lee, and E. Witchel, “Ink-
tag: Secure applications on an untrusted operating system,” SIGPLAN
Not., vol. 48, no. 4, pp. 265–278, Mar. 2013.
[13] H. Hu, Z. L. Chua, Z. Liang, and P. Saxena, “Identifying arbitrary mem-
ory access vulnerabilities in privilege-separated software,” in 20th Eu-
ropean Symposium on Research in Computer Security (ESORICS’15),
ser. Lecture Notes in Computer Science, G. Pernul, P. Y. A. Ryan, and
E. R. Weippl, Eds., vol. 9327, Vienna, Austria, 2015, pp. 312–331.
[14] T. Hunt, Z. Zhu, Y. Xu, S. Peter, and E. Witchel, “Ryoan: A distributed
sandbox for untrusted computation on secret data,” ACM Transactions
on Computer Systems (TOCS), vol. 35, no. 4, pp. 1–32, 2018.
Intel Software Guard Extensions SDK for Linux OS: Developer Refer-
ence, Intel, 2016.
[15]
[16] Processor Tracing, Intel Corporation, available at https://software.
intel.com/content/www/us/en/develop/blogs/processor-tracing.html
[Accessed December 30, 2020].
Intel SGX SSL, Intel Corporation, 2019, available at https://github.com/
intel/intel-sgx-ssl [Accessed December 30, 2020].
[17]
[18] P. Jain, S. J. Desai, M. Shih, T. Kim, S. M. Kim, J. Lee, C. Choi,
Y. Shin, B. B. Kang, and D. Han, “Opensgx: An open platform for SGX
research,” in 23rd Annual Network and Distributed System Security
Symposium (NDSS’16), San Diego, CA, USA, 2016.
[19] D. Jones, Trinity: Linux system call fuzzer, available at https://github.
com/kernelslacker/trinity [Accessed December 30, 2020].
[20] M. R. Khandaker, Y. Cheng, Z. Wang, and T. Wei, “COIN attacks: On
insecurity of enclave untrusted interfaces in SGX,” in 25th International
Conference on Architectural Support for Programming Languages and
Operating Systems (ASPLOS’20), Lausanne, Switzerland, 2020, p.
971–985.
[21] S. Kim, J. Han, J. Ha, T. Kim, and D. Han, “SGX-Tor: A secure
16
and practical tor anonymity network with SGX enclaves,” IEEE/ACM
Transactions on Networking, vol. 26, no. 5, pp. 2174–2187, 2018.
[22] G. Klees, A. Ruef, B. Cooper, S. Wei, and M. Hicks, “Evaluating fuzz
testing,” in ACM SIGSAC Conference on Computer and Communica-
tions Security (CCS’18), Toronto, Canada, 2018, p. 2123–2138.
J. Kneschke, Lighttpd, 2003, available at https://www.lighttpd.net/ [Ac-
cessed December 30, 2020].
[23]
[24] R. Kunkel, D. L. Quoc, F. Gregor, S. Arnautov, P. Bhatotia, and
C. Fetzer, “TensorSCONE: A secure tensorﬂow framework using intel
SGX,” CoRR, vol. abs/1902.04413, 2019.
[25] Y. Kwon, A. M. Dunn, M. Z. Lee, O. S. Hofmann, Y. Xu, and
E. Witchel, “Sego: Pervasive trusted metadata for efﬁciently veriﬁed
untrusted system services,” ACM SIGARCH Computer Architecture
News, vol. 44, no. 2, pp. 277–290, 2016.
[26] Large-Scale Data & Systems (LSDS) Group, TaLoS: Efﬁcient TLS Ter-
mination Inside SGX Enclaves for Existing Applications, 2019, available
at https://github.com/lsds/TaLoS [Accessed December 30, 2020].
[27] Y. Li, J. McCune, J. Newsome, A. Perrig, B. Baker, and W. Drewry,
“Minibox: A two-way sandbox for x86 native code,” in USENIX Annual
Technical Conference (USENIX ATC’14), Philadelphia, PA, USA, 2014,
pp. 409–420.
J. Lind, C. Priebe, D. Muthukumaran, D. O’Keeffe, P.-L. Aublin, F. Kel-
bert, T. Reiher, D. Goltzsche, D. Eyers, R. Kapitza et al., “Glamdring:
Automatic application partitioning for Intel SGX,” in USENIX Annual
Technical Conference (USENIX ATC’17), Santa Clara, CA, USA, 2017,
pp. 285–298.
[28]
[29] Y. Liu, T. Zhou, K. Chen, H. Chen, and Y. Xia, “Thwarting memory
disclosure with efﬁcient hypervisor-enforced intra-domain isolation,”
in 22nd ACM SIGSAC Conference on Computer and Communications
Security (CCS’15), Denver, CO, USA, 2015, pp. 1607–1619.
[30] V. J. M. Man`es, H. Han, C. Han, S. K. Cha, M. Egele, E. J. Schwartz,
and M. Woo, “The art, science, and engineering of fuzzing: A survey,”
IEEE Transactions on Software Engineering, pp. 1–1, 2019.
[31] Y. Mazhkenov, SGX-SQLite, 2019, available at https://github.com/
yerzhan7/SGX SQLite [Accessed December 30, 2020].
[32] D. R. K. Ports and T. Garﬁnkel, “Towards application security on
untrusted operating systems,” in 3rd USENIX Workshop on Hot Topics
in Security (HotSec’08), San Jose, CA, USA, 2008.
[33] C. Priebe, D. Muthukumaran, J. Lind, H. Zhu, S. Cui, V. A. Sartakov,
and P. R. Pietzuch, “SGX-LKL: securing the host OS interface for
trusted execution,” CoRR, vol. abs/1908.11143, 2019.
[34] B. Shastry, M. Leutner, T. Fiebig, K. Thimmaraju, F. Yamaguchi,
K. Rieck, S. Schmid, J.-P. Seifert, and A. Feldmann, “Static program
analysis as a fuzzing aid,” in Research in Attacks, Intrusions, and
Defenses, M. Dacier, M. Bailey, M. Polychronakis, and M. Antonakakis,
Eds. Springer International Publishing, 2017, pp. 26–47.
[35] S. Shinde, D. L. Tien, S. Tople, and P. Saxena, “Panoply: Low-TCB
linux applications with SGX enclaves,” in 24th Annual Network and
Distributed System Security Symposium (NDSS’17), San Diego, CA,
USA, 2017.
strace: linux syscall tracer, strace, available at https://strace.io/ [Ac-
cessed December 30, 2020].
[36]
[37] L. Szekeres, M. Payer, T. Wei, and D. Song, “SoK: Eternal war in
memory,” in IEEE Symposium on Security and Privacy (S&P’13), San
Francisco, CA, USA, 2013, pp. 48–62.
[38] R. Ta-Min, L. Litty, and D. Lie, “Splitting interfaces: Making trust
between applications and operating systems conﬁgurable,” in 7th Sym-
posium on Operating Systems Design and Implementation (OSDI’06),
Seattle, WA, USA, 2006, pp. 279–292.
[39] B. Trach, A. Krohmer, F. Gregor, S. Arnautov, P. Bhatotia, and C. Fetzer,
“Shieldbox: Secure middleboxes using shielded execution,” in Proceed-
ings of the Symposium on SDN Research (SOSR’18), Los Angeles, CA,
USA, 2018, pp. 1–14.
[40] C.-C. Tsai, D. E. Porter, and M. Vij, “Graphene-SGX: A practical
library OS for unmodiﬁed applications on SGX,” in USENIX Annual
Technical Conference (USENIX ATC’17), Santa Clara, CA, USA, 2017,
pp. 645–658.
J. Van Bulck, D. Oswald, E. Marin, A. Aldoseri, F. D. Garcia, and
F. Piessens, “A tale of two worlds: Assessing the vulnerability of
enclave shielding runtimes,” in ACM Conference on Computer and
Communications Security (CCS’19), London, UK, 2019, pp. 1741–
1758.
[41]
[42] V. Velciu, F. Stancu, and M. Chiroiu, “Hiddenapp-securing linux
applications using ARM TrustZone,” in International Conference on Se-
curity for Information Technology and Communications (SECITC’18),
Bucharest, Romania, 2018, pp. 41–52.
[43] H. Wang, E. Bauman, V. Karande, Z. Lin, Y. Cheng, and Y. Zhang,
“Running language interpreters inside SGX: A lightweight, legacy-
compatible script code hardening approach,” in ACM Asia Conference
on Computer and Communications Security (ASIACCS’19), Auckland,
New Zeland, 2019, pp. 114–121.
17