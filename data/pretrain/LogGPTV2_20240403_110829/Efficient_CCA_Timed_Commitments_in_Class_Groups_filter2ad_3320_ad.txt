CGGen(1ğœ†, ğ‘): On input the security parameter 1ğœ†, and a ğœ†
bits prime ğ‘ do the following:
â€¢ Let ğœ‡ be the bit size of ğ‘. Pick ğ‘ a ğœ‚(ğœ†) âˆ’ ğœ‡ bits prime such
â€¢ Î”ğ¾ := âˆ’ğ‘ğ‘, Î”ğ‘ := ğ‘2Î”ğ¾
â€¢ Compute ğµ an upper bound on the order of ğ¶ğ‘™(Î”ğ¾)
â€¢ Pick a random prime Ëœğ‘ âˆˆ [2ğœ†ğµ, 2ğœ†+1ğµ]
â€¢ Generate a random square ğº âˆˆ ğ¶ğ‘™(Î”ğ¾)
â€¢ Compute ğ›¾ğ‘ = ğœ“ğ‘(ğº)
â€¢ Set ğ¹ the class (ğ‘2, ğ‘) in ğ¶ğ‘™(Î”ğ‘)
â€¢ Set ğ›¾ := ğ›¾ğ‘ Â· ğ¹ and G = âŸ¨ğºâŸ©
â€¢ Output pp := (G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘)
Figure 1: Class Group Generator
Analysis. Intuitively, from the structure of ğ‘2, the puzzle hides ğ‘š
under the HSMğ¶ğ¿ assumption for adversaries that cannot distin-
guish ğœ“ğ‘((ğ‘1)2T) from random. In the following we thus recall a
definition of a strong sequential squaring assumption, which states
that knowing of the group structure does not help to break the
sequentially of the squaring operation, and analyse it in the context
of class groups.
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2668PSetup(1ğœ†, 1T, ğ‘): On input the security parameter 1ğœ†, the
time parameter 1T, and a ğœ† bits prime ğ‘ do the following:
â€¢ Run CGGen(1ğœ†, ğ‘) to get (G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘)
â€¢ Set ğ» := ğº2T
â€¢ Output pp := (ğº, ğ», ğ¹, Ëœğ‘)
PGen(pp, ğ‘š): On input public parameters pp = (ğº, ğ», ğ¹, Ëœğ‘)
and a message ğ‘š, do the following:
â€¢ Sample ğ‘Ÿ â† Z Ëœğ‘
â€¢ Output ğ‘ := (ğºğ‘Ÿ ,ğœ“ğ‘(ğ»ğ‘Ÿ) Â· ğ¹ğ‘š)
PEval({ğ‘1, . . . , ğ‘ğ‘›}): On input ğ‘ğ‘– = (ğ‘ˆğ‘–, ğ‘‰ğ‘–) for all ğ‘–, do the
following:
â€¢ Compute Ëœğ‘ˆ :=ğ‘›
ğ‘–=1 ğ‘ˆğ‘– and Ëœğ‘‰ =ğ‘›
ğ‘–=1 ğ‘‰ğ‘–
â€¢ Output ğ‘âˆ— := ( Ëœğ‘ˆ , Ëœğ‘‰)
Solve(ğ‘): On input ğ‘ = (ğ‘ˆ , ğ‘‰), do the following:
â€¢ Compute ğœ” := ğ‘ˆ 2T
â€¢ Output SolveDL(ğ‘‰ Â· ğœ“ğ‘(ğœ”)âˆ’1)
Figure 2: Homomorphic Time-Lock Puzzle from Class
Group
Definition 4.1 (Strong Seqential Sqaring Assumption
([55])). Let ğœ† âˆˆ N, ğ‘ be a ğœ†-bit prime, and (G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘) the output
of CGGen(1ğœ†, ğ‘) and T(Â·) be a polynomial. Then there exists some
0 < ğœ€ < 1 such that for every polynomial-size adversary (S1,S2) =
{(S1,S2)ğœ†}ğœ†âˆˆN where the depth of S2 is bounded from above by
Tğœ€(ğœ†), there exists a negligible function negl(Â·) such that
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
Pr
ğ‘â€² = ğ‘
ğœ â† S1(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘, T(ğœ†))
ğ‘¥ â† Z Ëœğ‘; ğ‘‹ := ğºğ‘¥
ğ‘¦ â† Z Ëœğ‘; ğ»1 := ğº ğ‘¦;
ğ‘â€² â† S2(ğ‘‹, ğ»ğ‘, ğœ)
ğ»0 := ğ‘‹ 2T(ğœ†)
ğ‘ â† {0, 1}
â‰¤ 1
2 + negl(ğœ†)
Computational versions of the sequential squaring assumption
have been used within class groups in the context of VDF [74]. In
such a setting, the factorization of the discriminant Î”ğ¾ is usually
public. As a consequence one can efficiently compute square roots
in G âŠ‚ ğ¶ğ‘™(Î”ğ¾) using an algorithm from Lagarias [49], while it
is not possible in Z/ğ‘›Z when ğ‘› is an RSA modulus of unknown
factorization. From [34, Prop. 3.11], there are two elements of order
dividing 2 in ğ¶ğ‘™(Î”ğ¾), one is the neutral element, and the other one,
ğœ– has order exactly 2 and it is not a square in our setting where the
subgroup of squares has odd order. As the order ğ‘  of G is odd, each
element of G has at least a square root ğ‘† âˆˆ G. The other one, ğ‘† Â· ğœ–
is not a square so is not in G. In other word, each element of G as a
unique square root in G.
For our decisional problem, we can use these facts to implement
a meet in the middle attack. Namely, from a challenge, ğ‘‹, ğ»ğ‘, we
can iteratively compute ğ‘‹0 := ğ‘‹, ğ‘‹1 := ğ‘‹ 2, ğ‘‹2 := ğ‘‹ 4, . . . , and in
parallel ğ‘‹ğ‘¡
:= ğ»ğ‘, ğ‘‹ğ‘¡âˆ’1 the unique square root of ğ‘‹ğ‘¡ in G, and
so on. If both ends meet, it means that ğ»ğ‘ is equal to ğ‘‹ 2T(ğœ†). In
practice, this is not a huge improvement, because of the complexity
of the square root algorithm, which involves computations of square
roots modulo the prime factors of the discriminant and a reduction
procedure of ternary quadratic forms due to Gauss. This is far more
expensive than squaring in G, and in practice our implementation
using the setting of Section 8 suggests that we gain only a 5% time
improvement using this strategy, we means that one has to increase
T by 5%.
Recent improvements have been obtained to partially parallelize
squarings in class groups with dedicated hardware in [75], which
result in a speedup by a factor 2 compared to a standard CPU. Again,
computing square roots in class group is far more intricate, but
similar techniques might apply to a certain extent.
To conclude, the fact that one can compute square roots only
affects marginally the time parameter of the scheme. We now state
the theorem that ensures the security of our HTLP.
Theorem 4.2. If the strong sequential squaring and HSMğ¶ğ¿ as-
sumption hold for the output of the CGGen generator, then the ho-
momorphic time-lock puzzle from Figure 2 is secure.
Proof. Letâ€™s consider a sequence of hybrid games.
1 , ğ‘ â˜…
1 , ğ‘ â˜…
2 ) is modified. It is computed as ğ‘ â˜…
Hyb0 It is the original game.
Hyb1 In this hybrid game, the only change is the second component
of the time-lock puzzle challenge ğ‘ â˜… = (ğ‘ â˜…
2 ) which is replaced
2 = ğœ“ğ‘(ğ»â˜…) Â· ğ¹ ğ‘ ğ‘ where ğ»â˜… = ğº ğ‘¦ for ğ‘¦ picked uniformly at
by ğ‘ â˜…
random in Z Ëœğ‘.
Hyb2 Again, the second component of the time-lock puzzle chal-
lenge ğ‘ â˜… = (ğ‘ â˜…
2 := ğ›¾ğ‘Ÿ Â· ğ¹ ğ‘ ğ‘
for ğ‘Ÿ uniformly at random in Zğ‘ Ëœğ‘.
We now analyse the transitions:
Hyb0 â‰ˆğ‘ Hyb1 A distinguisher between the two hybrids breaks
the strong sequential squaring assumption. Indeed, letâ€™s construct
(S1,S2) as follows: S1 receives (G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘, T(ğœ†)) and com-
putes ğ» = ğº2T(ğœ†) (which he can do since he is not bounded by T),
feeds A1 with (ğº, ğ», ğ¹, Ëœğ‘) and waits for its output (ğœ, ğ‘ 0, ğ‘ 1), which
he forwards as his output for his own challenger. Then S2 receives
(ğ‘‹ â˜…, ğ»â˜…, ğœ). Now S2 runs A2 with ğ‘ â˜… = (ğ‘‹ â˜…,ğœ“ğ‘(ğ»â˜…) Â· ğ¹ ğ‘ ğ‘) for
a random bit ğ‘. When A2 outputs his bit ğ‘â€², S2 outputs the bit
ğ‘ == ğ‘â€². Let us now analyse the situation:
â€¢ Either ğ»â˜… equals to ğ‘‹ â˜…2T(ğœ†) and in this case the challenge ğ‘ â˜… =
â€¢ or ğ»â˜… is random in G and in this case, ğ‘ â˜… is distributed as in
(ğºğ‘¥,ğœ“ğ‘(ğ» ğ‘¥) Â· ğ¹ ğ‘ ğ‘) is distributed as in Hyb0;
Hyb1.
It means that any distinguisher between Hyb0 and Hyb1 will trans-
late into an adversary against the strong sequential squaring as-
sumption.
Hyb1 â‰ˆğ‘ Hyb2 A distinguisher between Hyb1 and Hyb2 can be
turned into an attacker against HSMğ¶ğ¿. Let us construct such an
attacker D: he takes as input (G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘) and ğ›¿. He computes
ğ» = ğº2T(ğœ†) and feeds A1 with (ğº, ğ», ğ¹, Ëœğ‘) and waits for its output
(ğœ, ğ‘ 0, ğ‘ 1). Now D runs A2 with ğ‘ â˜… = (ğºğ‘Ÿ , ğ›¿ Â· ğ¹ ğ‘ ğ‘) for a random bit
ğ‘ and a random ğ‘Ÿ in Z Ëœğ‘. When A2 outputs his bit ğ‘â€², S2 outputs
the bit ğ‘ == ğ‘â€². We now have:
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2669ğ‘ with ğ‘¥ â† Z Ëœğ‘. In this case, ğ›¿ = ğœ“ğ‘(ğºğ‘¥) so ğ‘ â˜… is
â€¢ Either ğ›¿ = ğ›¾ğ‘¥
distributed as in Hyb1;
â€¢ Or ğ›¿ = ğ›¾ ğ‘¦ with ğ‘¦ â† Zğ‘ Ëœğ‘ so Zâ˜… is distributed as in Hyb2.
It means that any distinguisher between Hyb1 and Hyb2 will trans-
late into an attacker against the HSMğ¶ğ¿ assumption, which con-
cludes the proof.
â–¡
Expanding Message Space. Our HTLP can be generalized into a
scheme with message space Zğ‘ğ‘¡ using DamgÃ¥rd-Jurikâ€™s ideas [35]
for Paillierâ€™s encryption. This generalization was shown in [72]
to be useful in constructing efficient verifiable timed signatures
which has applications in privacy preserving timed payments in
cryptocurrencies.
Indeed, starting from a discriminant Î”ğ‘ = ğ‘2ğ›¿ğ¾, it is possible to
extend the parameters into a scheme with message space Zğ‘ğ‘¡ by
considering the new discriminant Î”ğ‘ğ‘¡ = ğ‘2ğ‘¡ Î”ğ‘˜, and ğ¹ğ‘¡ := (ğ‘2ğ‘¡ , ğ‘)
in ğ¶ğ‘™(Î”ğ‘ğ‘¡) which is now of order ğ‘ğ‘¡. The puzzle becomes ğ‘ :=
(ğºğ‘Ÿ ,ğœ“ğ‘ğ‘¡ (ğ»ğ‘Ÿ) Â· ğ¹ğ‘¡
ğ‘š) (using the appropriate mappings between class
groups) and it remains to adapt the SolveDL Ã  la Pohlig-Hellman as
suggested in [27] and analysed in [36]. In this setting, a message is
of size ğ‘¡ log(ğ‘) bits whereas the ciphertext is of size 2 log(ğ‘) + (2ğ‘¡ +
2) log(ğ‘) so that the expansion factor tends to 2 when ğ‘¡ grows to
infinity.
5 CCA TIMED COMMITMENTS
In the following we introduce the notion of CCA timed commit-
ments and we propose a new construction.
5.1 Definitions
We recall the definition of CCA timed commitment, an object re-
cently introduced by Katz et al. [47]. Our syntax heavily borrows
from their definitional framework.
Definition 5.1 (Timed Commitments). A timed commitment
scheme consists of PPT algorithms (TSetup, TCom, TVfy, TForceOp)
that are defined below:
TSetup(1ğœ†, 1T): the setup algorithm on input the security parameter
1ğœ† and the time parameter 1T returns a common reference string crs.
TCom(crs, ğ‘š): the commitment algorithm takes as input a common
reference string crs and a message ğ‘š and returns a commitment ğ‘ and
a proof ğœ‹.
TVfy(crs, ğ‘, ğœ‹): the verification algorithm takes as input a common
reference string crs, a commitment ğ‘, and a proof ğœ‹, and returns a bit
ğ‘ âˆˆ {0, 1}.
TForceOp(crs, ğ‘): the force opening algorithm on input a common
reference string crs and a commitment ğ‘, returns a message ğ‘š.
As a note on efficiency, all algorithms should run in time poly-
nomial in the security parameter and poly-logarithmic in T, except
for the TForceOp and (possibly) the TSetup algorithms. For correct-
ness, we require that for all ğœ† âˆˆ N, all time parameters T âˆˆ N, and
all messages ğ‘š it holds that
Pr[TForceOp(crs, ğ‘) = ğ‘š] = 1 and Pr[TVfy(crs, ğ‘, ğœ‹) = 1] = 1
where crs â† TSetup(1ğœ†, 1T) and (ğ‘, ğœ‹) â† TCom(crs, ğ‘š). We
define the properties perfect binding, verifiability and CCA security
in the following.
Definition 5.2 (Perfect Binding). A timed commitment
(TSetup, TCom, TVfy, TForceOp) is perfectly binding if for all ğœ† âˆˆ N,
all time parameters T âˆˆ N, all (ğ‘š0, ğ‘š1) such that ğ‘š0 â‰  ğ‘š1, and all
(ğ‘Ÿ0, ğ‘Ÿ1) âˆˆ {0, 1}2ğœ† it holds that
TCom(crs, ğ‘š0; ğ‘Ÿ0) â‰  TCom(crs, ğ‘š1; ğ‘Ÿ1)
where crs â† TSetup(1ğœ†, 1T).
Definition 5.3 (Verifiability). A timed commitment
(TSetup, TCom, TVfy, TForceOp) is verifiable if there exists a negli-
gible function negl(Â·) such that for all ğœ† âˆˆ N, all time parameters
T âˆˆ N, and all PPT algorithms A, it holds that
 1 = TVfy(crs, ğ‘, ğœ‹)
âˆ§ ğ‘ âˆ‰ TCom(crs, ğ‘š)
Pr
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) crs â† TSetup(1ğœ†, 1T)
(ğ‘, ğœ‹) â† A(crs)
ğ‘š â† TForceOp(crs, ğ‘)
â‰¤ negl(ğœ†)
Definition 5.4 (CCA Security). A timed commitment